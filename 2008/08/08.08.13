00:00:29 <Pseudonym> squfof is Square forms factorisation.
00:09:10 <Plareplane> how do i list the things that cabal-install has installed?
00:10:06 <Cale> Plareplane: well, ghc-pkg list will list a bit more than just that
00:10:18 <Cale> But it's a good approximation :)
00:10:38 <Plareplane> well, i mean, i have darcs-cabalized installed but ghc-pkg list doesn't show that
00:11:15 <Cale> hmmm
00:11:24 <Cale> You might look at the tree under .cabal
00:11:29 <Cale> ~/.cabal
00:23:37 <ddmnshs> foldr
00:30:37 <noohgodno> who wants to troll #python with me
00:30:59 <Chile`> noohgodno: and say what, "your pseudocode is easier to read than our pseudocode?"
00:31:45 <noohgodno> well
00:31:46 <noohgodno> if you like
00:32:21 <subw> foldr
00:32:31 <noohgodno> no, foldl
00:32:38 <subw> foldl'
00:32:47 <noohgodno> it's all a dream
00:32:48 <Zao> foldm :)
00:33:08 <noohgodno> foldu
00:33:21 <noohgodno> foldaleph
00:41:31 <gour> is there a way to call haskell code from python?
00:42:03 <Zao> Can python use C function pointers?
00:42:45 <noohgodno> du and popoen in python
00:42:52 <noohgodno> will call something from shell, i believe
00:42:54 <noohgodno> popen*
00:43:00 <noohgodno> popen4*
00:43:11 <Zao> If so you can use foreign import ccall "wrapper" to manufacture function pointers from any Haskell IO action.
00:44:58 <gour> hmm, it looks messy...having nice & pure haskell lib and then fiddling with IO
00:45:26 <Zao> You could use the 'dl' module probably to load a garden variety Haskell .so as well.
00:45:32 <Zao> But it'd be rather messy, compared to C interop.
00:45:50 <noohgodno> mixing code is bad juju
00:46:27 <Zao> FFI is great fun in my opinion.
00:46:45 <gour> i found some old msg which says: "Unfortunately, Python does not support calling
00:46:45 <gour> arbitrary C functions. In order to call C functions from Python, you have to write a Python extension module"
00:46:58 <gour> i'm also quite new with the python...that's why i ask
00:47:28 <gour> it seems it's better to focus on either python or haskell only
00:47:33 <Zao> You've got the 'dl' module which wraps dlopen and friends, and you've got the 'calldll' module which wraps LoadLibrary and GetProcAddress.
00:47:39 <Zao> Both can blow you up real good.
00:47:59 <ivanm> off-topic, but can anyone think of an algorithm that would automatically let me determine where to "slice" up a graph representing a whole program/library into the separate modules?
00:48:04 <gour> ahh...better to give up on time
00:57:07 <Chile`> ivanm: depends what your criteria are.
00:58:22 <Chile`> ivanm: you've probably already done this, but if you draw out a couple graphs and split them by hand you should be able to come up with a handful of rules
00:58:44 <ivanm> haven't physically done it, just in my head... but can't seem to think of anything :s
00:59:24 <Chile`> well, if you draw up a couple of examples I'll take a look, but there are many, many ways you could split things up
01:00:50 <ivanm> *nod*
01:01:35 <ivanm> I've just been trying to think on a graph-basis how to do so, i.e. for a given node in a graph, how do you know whether you should include any adjacent nodes in the current "grouping"
01:02:17 <profmakx> hooray for Igloo
01:02:36 <ivanm> profmakx: any particular reason?
01:03:17 <profmakx> yes ;) i am reading his patch theory writeup just now
01:03:22 <ivanm> ahhh
01:04:55 <Chile`> ivanm: again, plenty of ways to do it. do some google searches on spatial clustering
01:05:02 <ivanm> OK, thanks!
01:05:09 * ivanm didn't even know where to start googling :s
01:05:44 <Leaves> Hello, do you know if there is a nicer way to write this:   maximumBy (\a b -> compare (fst a) (fst b)) [(1, 2), (10, 1)]
01:06:31 <Chile`> ivanm: for a specific group of algorithms, you can look up K-means
01:06:54 <ivanm> @type compare `on` fst
01:06:57 <lambdac> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
01:06:57 <brad_larsen> Leaves:  Try maximumBy (compare `on` fst)
01:07:10 <brad_larsen> :i on
01:07:11 <ivanm> Chile`: thanks!
01:07:24 <brad_larsen> @info on
01:07:24 <lambdac> on
01:07:27 <profmakx> @src on
01:07:28 <lambdac> (*) `on` f = \x y -> f x * f y
01:07:53 <brad_larsen> it's in Data.Function
01:07:57 <chylli> @src foldr
01:07:58 <lambdac> foldr f z []     = z
01:07:58 <lambdac> foldr f z (x:xs) = f x (foldr f z xs)
01:08:03 <brad_larsen> i don't know how to work lambdabot to tell me that.
01:08:08 * mnislaih is looking for some code to implement a readline style progress bar
01:08:16 <profmakx> @hoogle on
01:08:17 <lambdac> A Hoogle error occured.
01:08:19 <profmakx> gnarf
01:08:30 <Leaves> ok, thanks I will try that
01:09:03 <brad_larsen> mnislaih: there are bindings to readline
01:09:14 <brad_larsen> dunno if that'd get you what you want
01:09:42 <mnislaih> brad_larsen: I know, I just want a snippet of code to learn from
01:10:43 <brad_larsen> mnislaih: I don't even know what a readline-style progress bar looks like.  One thing I only months ago learned about is the carriage return char: '\r'.
01:11:06 <brad_larsen> mnislaih: I have used that for simple programs to make simple progress updates without spewing thousands of lines of messages
01:11:32 <mnislaih> brad_larsen: I didn't think of that! thanks, it's exactly what I need
01:47:51 <tehgeekmeister> what's the int argument for in ByteString.hGet?
01:48:19 <quicksilver> tehgeekmeister: the number of bytes to get?
01:48:19 <lambdac> quicksilver: You have 1 new message. '/msg lambdac @messages' to read it.
01:48:26 <quicksilver> @messages
01:48:27 <lambdac> sw17ch said 4h 29m 25s ago: http://hpaste.org/9573
01:48:57 <tehgeekmeister> quicksilver: wow, i really am slow today...
01:48:59 <tehgeekmeister> thanks
01:53:58 <tehgeekmeister> http://hpaste.org/9577 <== anyone know what the difference between these two types is?
01:54:49 <ivanm> tehgeekmeister: possibly two different libraries you're using were built with different versions of bytestring
01:55:00 <Leaves> How can I tell haskell that a List is in ascending order, so that for instance the following gives False: elem 5 fac
01:55:01 <ivanm> try "ghc-pkg check" and see if it comes up with anything
01:55:10 <ivanm> Leaves: AFAIK, you can't
01:55:30 <tehgeekmeister> ivanm: ahh, that very well might be, i upgraded bytestring in the middle of installing the dependencs
01:55:30 <tehgeekmeister> *dependencies
01:55:33 <ivanm> unless you create a "smart" datatype and a wrapper elem
01:55:39 <vixey> Leaves:
01:55:46 <vixey> > takeWhile (< 5) [1,2,3,4,5,6,7,8,9,10]
01:55:48 <lambdac>  [1,2,3,4]
01:55:57 <vixey> > elem 5 . takeWhile (< 5) $ [1,2,3,4,5,6,7,8,9,10]
01:55:58 <lambdac>  False
01:56:11 <vixey> > elem 5 . takeWhile (<= 5) $ [1..]
01:56:12 <lambdac>  True
01:56:18 <vixey> > elem 5 [1..]
01:56:19 <lambdac>  True
01:56:25 <tehgeekmeister> ivanm: no, nevermind, i upgraded on a different box;; only one version of bytestring here.
01:56:28 <ivanm> or a smart variation of elem :p
01:56:47 <ivanm> tehgeekmeister: sure? one of the libs could have been built with the ghc internal version of bytestring...
01:57:08 <tehgeekmeister> ivanm: well i'm using the version that came with ghc?
01:57:42 <ivanm> so you didn't build one yourself?
01:57:56 <tehgeekmeister> i did, but i remembered that that was on a different box
01:57:59 <tehgeekmeister> so it won't affect this
01:58:01 <Leaves> I see, I didn't think of using takeWhile like this, I already found it strange I didn't saw a AscList datatype or something
01:58:02 <ivanm> tehgeekmeister: check by running this: ghc-pkg list bytestring
01:58:27 <tehgeekmeister> ivanm: it only has one version, 9.0.1
01:58:39 <ivanm> *nod*
01:58:42 <ivanm> dodgy library?
02:00:27 <tehgeekmeister> they're all included in ghc except bzlib, which i'd doubt is dodgy at all
02:00:48 <ivanm> @seen araujo
02:00:48 <lambdac> araujo is in #haskell. I last heard araujo speak 7h 37m 37s ago.
02:00:52 <ivanm> @seen koninkje
02:00:52 <lambdac> koninkje is in #haskell. I last heard koninkje speak 2h 23m 4s ago.
02:00:59 <ivanm> @seen kolmodin -- that's who I meant
02:01:00 <lambdac> kolmodin is in #haskell. I don't know when kolmodin last spoke.
02:01:33 <codacol> if i want to match a list which has at least 1 element. i should use (x:[xs]) right?
02:01:56 <ivanm> codacol: just (x:xs)
02:01:58 <tehgeekmeister> codacol: (x:xs)
02:02:08 <codacol> wont that match the empty list too?
02:02:29 <ertai> @src elemIndex
02:02:29 <lambdac> elemIndex x     = findIndex (x==)
02:02:29 <ivanm> (x:[xs]) probably wouldn't type check
02:02:39 <ertai> @src findIndex
02:02:39 <lambdac> findIndex p     = listToMaybe . findIndices p
02:02:39 <ivanm> codacol: no
02:02:43 <ivanm> @type (:)
02:02:44 <lambdac> forall a. a -> [a] -> [a]
02:02:47 <ertai> @src findIndices
02:02:47 <lambdac> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
02:04:05 <vixey> @pl findIndex p     = listToMaybe . findIndices p
02:04:05 <lambdac> findIndex = (listToMaybe .) . findIndices
02:04:47 <codacol> ok, wont match the empty list, but itll still match x:[]? why?
02:05:06 <quicksilver> tehgeekmeister: strict and lazy bystetrings
02:05:11 <quicksilver> tehgeekmeister: is what the two types are.
02:05:21 <subw> tehgeekmeister: I had a similar problem once, have you tried to import Data.ByteString.Lazy.Internal instead of Bytestring?
02:05:24 <ivanm> codacol: because [1,2,3,4] == 1:2:3:4:[]
02:05:25 <tehgeekmeister> quicksilver: yeh, i just figured that out right before you told me that
02:05:35 <tehgeekmeister> subw: just changed it.  all working now, thanks!
02:05:38 <ivanm> [...] is just synctactic sugar
02:06:08 <quicksilver> subw: you don't want to do taht.
02:06:23 <quicksilver> (unless you want the internal functions)
02:06:33 <quicksilver> tehgeekmeister: don't import .Internal
02:07:10 <codacol> ivanm: hate to sound stupid, but []:[] = [], so why wouldnt x:xs match []?
02:07:24 <tehgeekmeister> quicksilver: no, i just imported Data.Bytestring.Lazy
02:07:29 <vixey> codacol:
02:07:30 <vixey> > []:[]
02:07:31 <lambdac>  [[]]
02:07:38 <vixey> > [[]] == []
02:07:39 <lambdac>  False
02:07:43 <vixey> > []:[] == []
02:07:43 * quicksilver nods
02:07:44 <lambdac>  False
02:07:56 <ivanm> codacol: no it isn't
02:07:58 <ivanm> ;-)
02:08:14 <ivanm> @type (:) -- codacol
02:08:15 <lambdac> forall a. a -> [a] -> [a]
02:08:22 <ivanm> it takes an element, and sticks it onto a list
02:08:40 <codacol> oh true
02:08:52 <codacol> a list of lists
02:09:14 <codacol> which means if i wanted to match lists with a minimum of 2 elements, id use x:y:ys?
02:09:58 <tehgeekmeister> now i have a bunch of undefined reference errors from the linking stage...  i've been having really bad luck with haskell the past few days.
02:10:42 <jeffz> tehgeekmeister: did you pass --make?
02:10:55 <tehgeekmeister> jeffz: oh!
02:10:57 <tehgeekmeister> *tries
02:11:09 <ivanm> codacol: yes
02:12:05 <tehgeekmeister> whee!  it works.  now to turn it into something useful.
02:20:17 <codacol> ok, is [x] the best way to match a list with exactly one element?
02:20:29 <ivanm> codacol: yes
02:20:34 <quicksilver> it's a co
02:20:39 <quicksilver> mmon and reasonable way :)
02:20:49 <quicksilver> [x] and x:[] are equivalent.
02:20:59 <quicksilver> you can use either, but I think most people find [x] easier to read.
02:21:39 <codacol> oh true, never thought of that
02:22:12 <quicksilver> it's not all that often you need [x] in a pattern match.
02:22:21 <quicksilver> it's more common for the base case to be [].
02:22:31 <quicksilver> or to use an existing combinator (map, fold, etc)
02:22:32 <luqui> though x:[] is nice when you like to easily verify totality of patterm matches
02:22:40 <codacol> yeah but i had to use it for last in last weeks lab
02:22:57 <quicksilver> Occasionally I use [x,y,z] type things
02:22:59 <luqui> foo [] = ...
02:23:00 <codacol> 2 of the questions were last and init
02:23:03 <luqui> foo (x:[]) = ...
02:23:09 <luqui> foo (x:y:xs) = ...
02:23:11 <quicksilver> when you know that a function returns exactly 3 elements
02:23:32 <luqui> obviously covers all cases
02:23:52 <Leaves> @src maximum
02:23:52 <lambdac> maximum [] = undefined
02:23:52 <lambdac> maximum xs = foldl1 max xs
02:23:55 <codacol> ok another question. had to create an unzip function. and used 2 other functions, one created the first list, the other created the other list, then i made them into a tuple
02:23:58 <codacol> bad way to do it?
02:24:26 <luqui> @src unzip
02:24:26 <lambdac> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
02:24:42 <luqui> hmm, you only have to traverse once, but you have to do a lot of tuple packing/unpacking
02:24:43 <luqui> hard to say
02:24:45 <codacol> ok remembering we havent covered folding yet :P
02:25:07 <luqui> codacol, ah, that's basically a simple one-pass recursive solution
02:25:13 <vixey> > unzip $ zip [1..] [1..]
02:25:14 <lambdac>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:25:20 <codacol> basicly i have 2 functions. listFirst and listSecond, and then i did (listFirst x, listSecond x)
02:25:23 <Leaves> why does maximum [1..999999] give a stack overflow, looking at the source it should just remember the temporary max and traverse the list, not build the entire list?
02:25:25 <vixey> > foldr (\(a,b) (as,bs) -> (a:as,b:bs)) $ zip [1..] [1..]
02:25:26 <lambdac>  Couldn't match expected type `([t], [t1])'
02:25:28 <luqui> > take 10 *** take 10 $ unzip $ zip [1..] [2..]
02:25:29 <lambdac>  ([1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11])
02:25:38 <vixey> > foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) $ zip [1..] [1..]
02:25:40 <lambdac>  Exception: stack overflow
02:25:59 <quicksilver> Leaves: because it builds a big thunk of the form "a `max` b `max` c `max` d"
02:26:02 <luqui> thus the lazy pattern...
02:26:09 <quicksilver> Leaves: which causes a stack overflow when evaluated.
02:26:37 <vixey> luqui: I don't really get it though
02:26:47 <vixey> why does it avoid the overflow  ?
02:27:15 <tehgeekmeister> i'm trying to figure out hxq, and i can't seem to find anywhere i feed the string to run the xquery on in;; what am i missing?
02:28:02 <codacol> now im confused. the lecturer has been telling us x:xs will match the empty list as well. and its only because of ordering that it doesnt.
02:28:07 <Leaves> quicksilver: mm, that seems a bit inefficient..
02:28:13 <codacol> wonder if i should ask her if im misunderstanding her
02:28:31 <Leaves> quicksilver: do you know how to optimise this?
02:28:33 <vixey> codacol:
02:28:35 <vixey> @src []
02:28:35 <lambdac> data [] a = [] | a : [a]
02:28:41 <vixey> [] and x:xs are distinct
02:28:48 <vixey> they will never match
02:28:49 <codacol> vixey: i know that now
02:28:55 <jeffz> tehgeekmeister: http://hackage.haskell.org/packages/archive/HXQ/0.8.5.1/doc/html/Text-XML-HXQ-XQuery.html#v%3Axq ?
02:28:58 <lambdac> http://tinyurl.com/5vanna
02:28:59 <codacol> thats why im wondering if ive misunderstood or if shes just wrong :P
02:29:35 <tehgeekmeister> jeffz: yes, xq is the function i want, but the string argument is the query to run, there's no argument for the string to run it on
02:31:02 <quicksilver> Leaves: use foldl'
02:31:06 <quicksilver> @src maximum
02:31:07 <lambdac> maximum [] = undefined
02:31:07 <lambdac> maximum xs = foldl1 max xs
02:31:17 <quicksilver> Leaves: it's arguably a bug in maximum that it isn't strict.
02:32:42 <mmorrow> i've got hpaste2 running and on the web at http://moonpatio.com:8080
02:33:09 <jeffz> tehgeekmeister: heh, have you seen the examples?
02:34:07 <tehgeekmeister> jeffz: yes, and xe is actually the function i wanted.  but i don't quite follow the examples.
02:34:29 <tehgeekmeister> jeffz: i know JUST enough xquery for what i want to do, so i can't really understand the examples
02:36:24 <Leaves> thanks quicksilver, that works much better :)
02:39:31 <Leaves> \pm Leaves test
02:39:48 <Leaves> sorry
02:41:36 <Peaker> @type foldl1
02:41:38 <lambdac> forall a. (a -> a -> a) -> [a] -> a
02:41:48 <Peaker> quicksilver: what do you mean?
02:41:59 <Peaker> quicksilver: in the [] case you mean?
02:42:07 <quicksilver> no
02:42:11 <Deewiant> Peaker: that it doesn't use foldl1'
02:42:15 <quicksilver> I just mean that maximum should use a strict fold.
02:42:18 <quicksilver> probably.
02:42:25 <Leaves> do you know how I can sent messages from @src to myself?
02:42:26 <vixey> > foldl1 id []
02:42:27 <lambdac>      Occurs check: cannot construct the infinite type: a = a -> a
02:42:27 <lambdac>     Probabl...
02:42:41 <quicksilver> Leaves: /msg lambdac @src fold1
02:43:39 <Peaker> quicksilver: but surely its looking at all of the elements in xs - there's no way not to? doesn't that mean its strict?
02:44:10 <Leaves> ï»¿/msg lambdac @src fold1
02:45:57 <Leaves> thanks quicksilver, I got it (finally).. :)
02:46:36 <quicksilver> Peaker: yes. It is a strict function.
02:46:42 <quicksilver> Peaker: but it does not use a strict fold.
02:46:50 <quicksilver> therefore it accumulates a very large thunk and overflows the stack.
02:46:51 <Peaker> quicksilver: why is that a problem?
02:46:56 <Peaker> oh, I see
02:47:00 <quicksilver> (on a sufficiently large list)
02:48:13 <Peaker> I think considerations like these are yucky :-)  Is there no way for the compiler to strictify the fold here automatically?
02:49:04 <quicksilver> > maximum [1..10000000]
02:49:06 <lambdac>  10000000
02:49:09 <tero-> can I pull patches with darcs using HTTP digest auth?
02:49:10 <quicksilver> yes, and it does
02:49:15 <ziman> when would one want a non-strict foldl?
02:49:16 <tero-> it says HTTP error (404?)
02:49:19 <quicksilver> Peaker: so it's only a problem in the interpreter.
02:50:58 <quicksilver> or, alternatively, it's a problem if you manage to fool the optimisation.
02:51:09 <quicksilver> optimisations are fragile in the face of sufficient code complexity.
02:52:32 <RADIO_TIME> While you are on chat LISTEN RADIO TIME  http://radiotime.altervista.org/   Beautyful Music Free! We are waiting for You!
02:52:33 <lambdac> Title: Radio - Time 01
02:52:51 <vixey> lol
02:54:24 <quicksilver> ziman: it's a good question; I don't know of any example.
02:55:45 <chr1s> ziman: reverse
02:56:58 <quicksilver> chr1s: how does being non-strict help reverse?
02:57:25 <chr1s> ziman: I remember learning that you should use foldl when using finite lists with non-strict operators
02:57:28 <chr1s> something like that
02:57:41 * quicksilver shakes his head.
02:57:45 <tehgeekmeister> http://hpaste.org/9579 <== problem i'm having with using xe in hxq, i think it's more related to template haskell than hxq itself
02:57:52 <quicksilver> reverse with strict foldl works fine in strict languages :)
02:58:02 <quicksilver> I don't see why it should be a problem in haskell.
02:58:22 <chr1s> lemme think...
02:58:35 <quicksilver> tehgeekmeister: that does indeed look TH related.
02:58:43 <quicksilver> tehgeekmeister: are you a level 5 lambda wizard?
02:58:49 <quicksilver> because TH is not recommended for level 4 and under.
02:59:15 <tehgeekmeister> quicksilver: i just wanna grab the contents of the articles in the french wikipedia dump!!!
02:59:17 <tehgeekmeister> =P
02:59:47 <quicksilver> I suggest you use something a bit lighter weight then.
02:59:47 <tehgeekmeister> quicksilver: i noticed in the hxq examples there's some funny thing he does prefixing all calls to xe with $, perhaps that could be it?
02:59:50 <quicksilver> Perhaps tagsoup
03:00:09 <chr1s> tehgeekmeister: yes, that's definitely it.
03:00:40 <tehgeekmeister> hmm, i got the impression tagsoup wasn't efficient enough for large files like this?  that's why i wasn't using it.
03:01:18 <quicksilver> that was the wrong impression.
03:01:31 <quicksilver> as far as I know tagsoup is well suited for large files because it can stream
03:01:38 <quicksilver> as long as you use it in a streaming way.
03:01:40 <tehgeekmeister> oh, okay, then there's no reason not to use it.
03:01:52 <quicksilver> because xe is a TH magic
03:02:00 <quicksilver> you probably need to wrap the whole thing in $( ... )
03:02:06 <quicksilver> some splice anyway.
03:02:14 <quicksilver> I ahve never used TH myself.
03:02:34 <quicksilver> yes, look at the example
03:02:38 <quicksilver> they are all $(...)
03:04:08 <tehgeekmeister> okay, but i still get an error even when i wrap it that way.
03:04:13 <tehgeekmeister> i think i'll probably just use tagsoup.
03:04:39 <chr1s> ah yes, quicksilver, I finally figured out why it you would want to use the non-strict fold.
03:04:55 <chr1s> suppose your'e doing a head . reverse
03:05:15 <chr1s> than you obviously only need WHNF, not a fully evaluated list.
03:05:59 <chr1s> so basically, when intermediate results might be useful, foldl is interesting.
03:06:22 <chr1s> in the case of sum there aren't really any intermediate values that are of interest.
03:07:26 <chr1s> ziman: ^^
03:08:34 <quicksilver> chr1s: head . reverse still traverses the entire list
03:08:41 <quicksilver> chr1s: until it has, it hasn't got the end.
03:08:47 <quicksilver> chr1s: how is that an intermediate result?
03:09:13 <chr1s> quicksilver: well, it definitely traverses the entire list
03:09:22 <mjrosenb> quicksilver: not always, but usually
03:09:22 <rwbarton> chr1s: that's an iffy example--you don't actually build the spine of the list, but instead you build a chain of thunks that represents it
03:09:25 <chr1s> but it does't need to compute the tail of the rest.
03:10:48 <chr1s> rwbarton: yeah, so you don't actually compute the rest of the list. you traverse the entire list, the algorithm is still O(n), but you don't evaluate the rest of the computation.
03:11:38 <ziman> well, a strict foldl' would not force the elements themselves, would it?
03:11:58 * BeelsebobWork ponders if he's missing something really obvious in the cyclic inclusions discussion on haskell-cafe
03:11:58 <quicksilver> chr1s: eh?
03:12:03 <rwbarton> ziman: right
03:12:13 <quicksilver> chr1s: in the foldl' and foldl cases you both traverse the entire list
03:12:23 <quicksilver> so where is the advantage of the non-strict?
03:12:27 <ziman> and create O(n) thunks
03:13:56 <chr1s> hmmm......
03:14:00 <rwbarton> If (:) was a really expensive operation, the non-strict one would be better.  But in reality it's probably no more expensive than building the thunk to represent it
03:14:00 <tehgeekmeister> quicksilver: okay, you were definitely right.  i played around with it some more and now my brain is about to explode.  no more TH for me.
03:14:20 <quicksilver> cheaper, even.
03:14:27 <quicksilver> one fewer pointer, I think.
03:16:02 <vixey> I didn't think (:) even was an operation at all
03:16:17 <dobblego> @type (:)
03:16:19 <lambdac> forall a. a -> [a] -> [a]
03:16:27 <chr1s> yeah, you guys might be right.
03:16:35 <chr1s> =)
03:16:35 <quicksilver> vixey: allocating a new cons cell? sure that's an operation.
03:17:08 * vixey is not sure that : makes a cons ...
03:17:37 <vixey> if you have say
03:17:42 <vixey> f x = 1 : x : 2 : []
03:18:14 <vixey> in f 1,  is it : that allocates, or is the body of f is copied and the closure with x in it is made?
03:18:57 <quicksilver> I don't really understand the distinction you're trying to make
03:19:06 <quicksilver> an un-forced (:) is a thunk like any other binary function.
03:19:11 <quicksilver> or indeed any other operation at all.
03:19:22 <quicksilver> a force (:) is a piece of tagged data
03:19:32 <quicksilver> which is conventionally called a cons cell
03:19:41 <quicksilver> by analogy with lisp
03:19:47 <vixey> I know that like
03:19:55 <vixey> (cons 1 2) in lisp actually does allocate a new cons cell
03:20:12 <vixey> but in haskell? I think things different?
03:20:23 <chr1s> so then the question remains: why would you use foldl?
03:20:30 <trofimovich> @type GHC.Base.:
03:20:32 <lambdac> parse error on input `GHC.Base.:'
03:21:19 <quicksilver> vixey: lots of things are different, but the basic idea is the same.
03:21:26 <quicksilver> constructors still exist
03:21:31 <quicksilver> data in memory still exists.
03:22:50 <trofimovich> @let too_big = sum [1..]
03:22:51 <lambdac> Defined.
03:23:06 <trofimovich> > tail (too_big:[])
03:23:07 <lambdac>  []
03:23:28 <trofimovich> > head (1:too_big:[])
03:23:29 <lambdac>  1
03:23:33 <quicksilver> chr1s: I'm not aware of any case myself.
03:24:02 <vixey> hmmmmm
03:24:06 <vixey> fibs = 1 : fibs
03:24:17 <vixey> when you do
03:24:21 <vixey> take 3 fibs
03:24:32 <Botje> (cons 1 '()) in haskell is like (lambda () (cons (lambda () 1) (lambda () '()))
03:24:33 <vixey> 'take' does the allocation
03:24:44 <vixey> Botje: lol
03:24:52 <quicksilver> vixey: that's one way of looking at it.
03:24:57 <quicksilver> vixey: but that's not what I'd say.
03:25:00 <quicksilver> the thunks do the allocation.
03:25:02 <chr1s> quicksilver: well, I think I recall that someone in a lecture gave a good use-case, I thought it was reverse... but you guys sort of convinced me.
03:25:04 <quicksilver> take *forces* it.
03:25:10 <trofimovich> take is binop
03:25:19 <quicksilver> the data constructors were there in latent form
03:25:24 <quicksilver> take *forced* them to come into being.
03:25:25 <rwbarton> I guess you could set up the RTS so that the in-memory representations of an unforced (:) and a forced (:) are very similar, so there's no actual allocation done when it gets forced
03:25:27 <vixey> quicksilver: How does the sharing take = 1 : take come into that ?
03:25:38 <quicksilver> just like in lisp
03:25:42 <quicksilver> a cons cell which points to itself
03:25:45 <rwbarton> quicksilver: maybe that's what you just said
03:25:59 <quicksilver> rwbarton: yes, you don't actually allocate a new thunk
03:26:08 <quicksilver> rwbarton: you *convert* your thunk-thunk into a cons cell
03:26:13 <rwbarton> quicksilver: Right
03:26:15 <quicksilver> thunks + cells are uniform in structure.
03:26:21 <Botje> "the little thunk-thunk that could"
03:27:22 <vixey> is haskell just lisp with lambdas implicitly put everywhere??
03:27:34 <chylli> how to update an element of list ?
03:27:42 <chylli> I remember there is an operator
03:27:57 <chylli> @hoogle !!
03:27:58 <lambdac> A Hoogle error occured.
03:28:02 <chylli> @hoogle (!!)
03:28:03 <lambdac> A Hoogle error occured.
03:28:18 <trofimovich> @src (!!)
03:28:18 <lambdac> xs     !! n | n < 0 = undefined
03:28:19 <lambdac> []     !! _         = undefined
03:28:19 <lambdac> (x:_)  !! 0         = x
03:28:19 <lambdac> (_:xs) !! n         = xs !! (n-1)
03:28:35 <quicksilver> vixey: now
03:28:37 <quicksilver> vixey: no.
03:28:51 <quicksilver> vixey: because lisp lambdas don't replace themselves with their results the first time they are called.
03:28:55 <quicksilver> they get called each time.
03:28:56 <vixey> quicksilver: *phew*
03:29:03 <quicksilver> and also because of types :)
03:29:09 <quicksilver> but they only exist at compile time, clearly.
03:29:32 <quicksilver> chylli: take n list ++ [new_value] ++ drop (n+1) list
03:29:40 <quicksilver> chylli: but, it's not recommended as it will be slow.
03:29:46 <quicksilver> if you need to update a list, use Data.Sequence.
03:29:55 <chylli> quicksilver: I know, I just test an algrithm
03:30:07 <chylli> quicksilver: thanks
03:30:17 <trofimovich> -> take (n-1)
03:31:48 <quicksilver> trofimovich: well, I did drop (n+1)
03:31:55 <quicksilver> either way works :)
03:32:44 <trofimovich> yes. i've messed all :]
03:35:22 <tehgeekmeister> quicksilver: won't the fact that tagsoup doesn't work with bytestrings cause me problems in using it?
03:36:27 <quicksilver> hmm. that's an interesting point.
03:36:38 <quicksilver> it might be fast enough anyway.
03:36:52 <tehgeekmeister> for 3.8 gigabytes of data?
03:37:21 * quicksilver shrugs
03:37:23 <quicksilver> might be.
03:37:24 <tehgeekmeister> i'll try it, do i just run my bytestring thru unpack before feeding it to tagsoup?
03:37:29 <quicksilver> hard to know without trying
03:37:30 <quicksilver> yes.
03:37:51 <chylli> quicksilver: hwo to generate a list like [5,4,3,2,1] ?
03:37:56 <vixey> what does up x = x : up (x+1) compile into ?
03:38:01 <vixey> in STG or something ?
03:38:12 <vixey> > reverse [1..5]
03:38:13 <lambdac>  [5,4,3,2,1]
03:39:09 <quicksilver> > [5,4..1]
03:39:10 <lambdac>  [5,4,3,2,1]
03:39:19 <quicksilver> vixey: well it starts as a thunk which points to the code for 'up'
03:39:26 <quicksilver> vixey: (and captures the value of 'x')
03:39:52 <quicksilver> vixey: if you force it, it converts to a (:) cell with one component pointing to 'x' and the other component pointing to a thunk.
03:40:05 <quicksilver> that thunk points to the code for 'up' and captures the thunk for (x+1)
03:40:17 <quicksilver> force another cons cell and it repeats, unwinding into memory.
03:40:18 <tehgeekmeister> quicksilver: it works, yep.
03:40:39 <vixey> ohh I see
03:40:49 <vixey> so head (up 0) evaluates to 0 and doesn't even cons ?
03:41:04 <vixey> or does it make and destruct one cons
03:41:35 <quicksilver> it makes the first cons
03:41:41 <quicksilver> it doesn't destruct it
03:41:43 <quicksilver> that's the GC's job
03:41:44 <vixey> ups x = x : x : x : ups (x+1)
03:41:52 <quicksilver> then the GC notices it's not being used.
03:41:55 <tehgeekmeister> quicksilver: memory usage is staying constant, too.  so tagsoup is fine to use in these situations, for the record.
03:41:59 <vixey> if you have  head (ups 0)
03:42:14 <vixey> does that make one cons, or make 3 conses ?
03:42:25 <quicksilver> tehgeekmeister: Yes, as long as you use correct streaming style programs :)
03:42:28 <quicksilver> vixey: one.
03:42:45 <quicksilver> vixey: the tail of it points to a thunk containing the code for (x : x : ups (x+1))
03:43:14 <tehgeekmeister> i'm really surprised how quickly the bulk of this has gone so far.  haskell never ceases to amaze me.
03:43:55 <vixey> ups --can compile into--> [Lambda, Data "Cons", Var 0, Lookup "ups_helper1"]
03:44:06 <quicksilver> vixey: yes, something like that.
03:44:15 <vixey> ok!
03:44:19 <vixey> and
03:44:22 <quicksilver> in some sense, ups gets decomposed into ups, ups1, ups2 and ups3
03:44:27 <vixey> the trade off is you could write
03:44:43 <quicksilver> ups x = x : ups1 x; ups1 x = x : ups2 x; ups2 x = x : ups (x+1)
03:44:45 <vixey> hm
03:44:48 <quicksilver> oh, I lied about ups3.
03:44:58 <quicksilver> ECANTCOUNT.
03:45:28 <quicksilver> tehgeekmeister: yes, GHC generates really quite good code. It can generate extraordinarily good code if you know how tweak it.
03:45:49 <quicksilver> tehgeekmeister: but in many practical problems it's within 50% of the speed of C and yet *much* more likely to be correct first time :)
03:46:08 <tehgeekmeister> quicksilver: yep, that's what i always heard.  now i'm just starting to see it in my own code.  =P
03:46:38 * Botje spent three hours yesterday coding up the proper way to do euler86
03:46:53 <Botje> checked the forums, all those C weenies "oh i just brute forced it" :(
03:47:09 <Zao> My goal is to brute force it in Haskell.
03:47:26 <tehgeekmeister> now i have to figure out how to write a stream oriented filter to get rid of all the wikilinks.  that'll be interesting.
03:47:58 <Zao> A proper solution looks like it'd be fun to find though.
03:48:18 <Botje> the proper solution involves pythagorean triples
03:48:25 <Botje> not surprisingly
03:48:41 <vixey> I can think of a different way to compile haskell
03:48:51 <Botje> although i'm impressed by glguy_'s solution too
03:48:56 <vixey> actually I don't know if it's different or not
03:49:03 <Botje> you can bruteforce it incrementally :o)
03:49:56 <tehgeekmeister> quicksilver: is parsec sufficiently lazy to use streaming if you're only going to be backtracking very short distances?
03:50:20 <quicksilver> ehm. Off hand I'm not sure.
03:50:28 <tehgeekmeister> mmkay
03:50:41 <quicksilver> malcolmw understands these things.
03:50:45 <vixey> ups x = x : x : x : ups (x+1)
03:50:47 <quicksilver> He's not here at the moment though.
03:50:48 <vixey> in that
03:50:59 <vixey> you get lots of thunks which might be unthunked
03:51:18 <vixey> what if you make the 3 conses instead? what are the trade offs
03:52:41 <quicksilver> tehgeekmeister: speak of gthe devil.
03:52:51 <quicksilver> vixey: space/time as usual :)
03:53:06 <quicksilver> it's notoriously hard to find the sweet spots
03:53:38 <tehgeekmeister> malcolmw: quicksilver was just telling me you'd know about this; is parsec sufficiently lazy to use streaming if you're only going to be backtracking very short distances?
03:56:48 <vixey> I imagine ups x = x : x : x : ups (x+1)
03:56:58 <vixey> turning into something like [Lam, Data "Cons" [2,3], Var 0, Data "Cons [2,4], Data "Cons [2,5], Apply "ups" [6], Apply "+" [2,7], Data "1" []]
03:57:45 <vixey> I think you have less thunks so would it be faster?
03:57:50 <quicksilver> I think it's hard to generalise that into a general technique which is obviously always better.
03:58:00 <quicksilver> it's slower in the case that you were never going to access those thunks :)
03:58:15 <quicksilver> quite a lot has been written about this.
03:58:19 <vixey> but is malloc(3) faster than malloc(30) ?
03:58:49 <quicksilver> you're not just mallocing though, you're writing data
03:58:55 <quicksilver> and you're also making work for the GC (later)
03:59:05 <vixey> oh yes true
04:01:27 <janszn> @pl (\n -> (4*n^3+3*n^2+8*n-3)`div`6-1)
04:01:27 <lambdac> subtract 1 . (`div` 6) . subtract 3 . ap ((+) . ap ((+) . (4 *) . (^ 3)) ((3 *) . (^ 2))) (8 *)
04:01:49 <vixey> janszn:
04:02:19 <vixey> (subtract 1) . (`div`6) . polynomial [4,2,8,-3]
04:02:36 <janszn> thanks !
04:03:10 <trofimovich> > polynomial
04:03:10 <lambdac>   Not in scope: `polynomial'
04:03:55 <vixey> polynomial [4,2,8,-3] n = 4*n^3+3*n^2+8*n-3
04:04:58 <trofimovich> not very convinient form to calculate :]
04:05:08 <vixey> what do you mean?
04:05:23 <trofimovich> polynomial.(reverse [4,2,8,-3])
04:05:38 <trofimovich> @hoogle polynomial
04:05:38 <lambdac> A Hoogle error occured.
04:06:08 <malcolmw> tehgeekmeister: parsec is not lazy at all
04:07:00 <ivanm> why isn't lambdabot proper working?
04:07:14 <Zao> ivanm: Leaking space, I believe.
04:07:56 <ivanm> yes, but in the past they just restarted her
04:07:57 <tehgeekmeister> malcolmw: okay, i think it's overkill for what i want anyway.
04:11:09 <trofimovich> @let polynomial xs n = foldl' (\val x -> (x + n*val)) 0 xs
04:11:10 <lambdac> Defined.
04:12:27 <lambdapants> hey all
04:12:33 <trofimovich> @pl \val x -> (x + n*val)
04:12:33 <lambdac> (+) . (n *)
04:13:08 <vixey> > polynomial [1,-1,-1] ((sqrt 5 + 1) / 2) :: CReal
04:13:10 <lambdac>  0.0
04:13:12 <vixey> hi
04:13:24 <vixey> Did you make that fractal program ?
04:13:30 <sioraiocht> dcoutts: ping
04:14:01 <lambdapants> uhh, yeah I just spotted a bug on my happs server.  forgot to add one to new entries and comments
04:14:13 <lambdapants> it works now at www.killersmurf.com....
04:14:14 <agentzh> mmorrow: i've built a GHC 6.8.3 from source using a binary GHC 6.4.2 and all problem vanished :D
04:14:34 <dcoutts> sioraiocht: pong
04:14:43 <agentzh> mmorrow: maybe it's worth putting this binary dist to something on the web ;)
04:15:23 <lambdapants> I have a question though,
04:15:23 <lambdapants> I have a custom monad, built with StateT over IO
04:15:23 <lambdapants> I want to fork some threads and have them work on the state
04:15:36 <besiria> what is the difference between MVar and TVar ? all the examples that i have read are using MVars, any link that will help?
04:15:38 <agentzh> fortunately timer_create is deep in libc not GHC's codegen...or it'll be much much harder
04:15:39 <lambdapants> is there a way of doing this that doesn't involve runStateT or TVars
04:16:12 <quicksilver> lambdapants: No.
04:16:25 <quicksilver> you will need runStateT and (T/M)Vars.
04:16:35 <quicksilver> you can encapsulate it cleanly enough though.
04:16:50 <lambdapants> Yes, I image so, I just wondered if there was a function for it.
04:16:52 <quicksilver> besiria: TVars have consistency checks and rollback.
04:17:05 <lambdapants> Thankyou quicksilver
04:18:21 <besiria> quicksilver: didn't understand a thing
04:18:34 <besiria> quicksilver: any link?
04:21:08 <besiria> quicksilver: anything that can be done with MVars can also be done with TVars , but i'm getting something extra with TVars? is that right ?
04:21:12 <vixey> ?docs StateT
04:21:12 <lambdac> StateT not available
04:22:07 <lambdapants> besira: whe TVars are being worked on in stm monad, I believe the runtime system makes sure that nothing else touches them at the same time
04:22:08 <agentzh> Korollary: this linux kernel is indeed good enough to run GHC 6.8.3 flawlessly :))
04:23:35 <quicksilver> besiria: http://research.microsoft.com/Users/simonpj/papers/stm/index.htm
04:23:37 <lambdac> Title: Papers on transactional memory
04:25:02 <besiria> i should probably look at the docs for a moment and then  i would ask for questions if i'm finding sth hard
04:25:31 <lambdapants> besiria: don't worry, stm makes things easier, not harder :)
04:26:04 <lambdapants> ( when it comes to multithreaded servers anyway )
04:26:23 <lambdapants> I have to go! cheerio.  have fun all
04:26:59 <besiria> lambdapants: i'm working on a documentation project for various programming models for concurrency/parallelism
04:27:10 <lambdapants> oooh
04:27:21 <lambdapants> that's sounds interesting.
04:28:12 <lambdapants> I like STM because since it's a monad, you can combinate all your read and writes, and they'll stay atomic
04:28:19 <lambdapants> I have to go though
04:28:33 <besiria> lambdapants: y it is. but i'm looking at other models also, like CSP and message-passing
04:36:09 <wizard_Sirio> #haskell.it
04:36:12 <wizard_Sirio> :-S
04:39:52 <mmorrow> agentzh: awesome! they vanished for me as well. yeah, it probably is worth contributing to somewhere, since 3hrs+ is a long time. i'm thinking of somehow contributing my build to the centos yum repo.
04:40:45 <mmorrow> (since they don't even have ghc6.6 in there yet...)
04:55:59 <sioraiocht> okay, ghc-pkg lists bytestring-0.9.1.0
04:56:17 <sioraiocht> but then ghc-pkg check says that it's missing and thus a ton of stuff is broken
04:56:25 <sioraiocht> i tried downloading and isntalling the cabal package and that didn't work
04:56:27 <sioraiocht> how can i fix this?
04:56:48 <Botje> giving it a good sound beating :)
04:56:53 <ivanm> sioraiocht: you'd have to rebuild everything using it
04:57:13 <sioraiocht> ivanm: ?  I never built it WITHOUT it
04:57:14 <dcoutts> sioraiocht: ghc-pkg check says that exact version is missing? the version that list says is there?
04:57:22 <ivanm> or else if they're all local installs, use cabal-install to rebuild everything?
04:57:33 <dcoutts> sioraiocht: are you sure the versions are the same, not like 0.9.1.0 vs 0.9.0.1 ?
04:57:45 <sioraiocht> ..oops
04:57:48 <sioraiocht> dcoutts is right
04:57:49 <sioraiocht> =p
04:57:54 <dcoutts> phew!
04:58:17 <dcoutts> sioraiocht: so the borken packages need rebuilding, cabal-install can do that
04:58:21 <sioraiocht> okay
04:58:48 <dcoutts> sioraiocht: I'll be in the office in a mo, are you there atm?
04:58:51 <sioraiocht> yes
05:02:30 <ivanm> anyone heard of/implemented the Chinese Whispers algorithm? http://wortschatz.uni-leipzig.de/~cbiemann/pub/2006/BiemannTextGraph06.pdf
05:02:33 <lambdac> http://tinyurl.com/6335sp
05:20:10 <_zenon_> @pl (\x -> x !! 1) d
05:20:11 <lambdac> d !! 1
05:20:36 <_zenon_> @pl (\x -> x !! 1) $  d 2
05:20:36 <lambdac> d 2 !! 1
05:20:53 <vixey> (\x -> x !! 1) d = (!! 1) d = d !! 1
05:23:43 <TSC> @src IO fail
05:23:44 <lambdac> fail s  = failIO s
05:23:53 <TSC> @index failIO
05:23:53 <lambdac> bzzt
05:26:31 <TSC> Is there a better way to do http://hpaste.org/9581 ?
05:26:58 <TSC> The basic idea is that I have some monadic functions that return Maybe types
05:27:22 <TSC> And I want to do something if they all return Just values, and have some error case otherwise
05:27:32 <opqdonut> :t liftM2 mplus
05:27:34 <lambdac> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
05:27:48 <opqdonut> the inner m could be for example Maybe
05:28:04 <TSC> And m1 perhaps IO
05:28:12 <TSC> Interesting
05:28:19 <opqdonut> > Just 1 `mplus` Just 2
05:28:20 <lambdac>  Just 1
05:28:22 <opqdonut> > Just 1 `mplus` Nothing
05:28:23 <lambdac>  Just 1
05:28:39 <opqdonut> hmm, that's not quite it though
05:29:11 <opqdonut> of course "isJust x && isJust y" is better than those case expressions
05:29:39 <TSC> Yeah, but then I still have to use fromJust
05:29:45 <TSC> isJust and fromJust seem a bit ugly
05:30:01 <opqdonut> true
05:30:05 <TSC> It would be nice if I could do something like:
05:30:11 <rwbarton> TSC: You should be able to use liftM2 doSomething x y :: Maybe Bool
05:30:15 <TSC> do Just x <- f
05:30:22 <opqdonut> TSC: you can
05:30:24 <opqdonut> do that
05:30:26 <TSC> And have the pattern match failure lead to the error case
05:30:37 <opqdonut> but it'll generate fail in the IO monad if it doesn't match
05:30:45 <opqdonut> which is kinda not nice
05:30:51 <TSC> Does that throw an IO exception?
05:31:11 <TSC> Yeah, liftM2 seems like the best thing
05:31:20 <TSC> @src liftM2
05:31:21 <lambdac> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:31:25 <opqdonut> > Just 1 >> Just 2
05:31:26 <lambdac>  Just 2
05:31:33 <opqdonut> > Nothing >> Just 2
05:31:35 <lambdac>  Nothing
05:31:42 <opqdonut> that's the combinator you want
05:32:03 <opqdonut> hmm, or possibly something like:
05:32:07 <TSC> Except it loses the value of the first part
05:32:11 <opqdonut> > liftM2 (,) (Just 1) (Just 2)
05:32:12 <lambdac>  Just (1,2)
05:32:15 <opqdonut> > liftM2 (,) (Just 1) (Nothing)
05:32:16 <lambdac>  Nothing
05:32:30 <opqdonut> aka "(,) <$> Just 1 <*> Just 2"
05:34:14 <TSC> Mmm
05:36:15 <Axman6> @src liftM2
05:36:16 <lambdac> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:36:51 <Axman6> what does <- actually do anyway?
05:37:46 <TSC> Special syntax for >>=
05:37:53 <TSC> That do block is equivalent to
05:38:17 <TSC> liftM2 f m1 m2 = m1 >>= \x1 -> m2 >>= \x2 -> return (f x1 x2)
05:39:00 <TSC> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:39:01 <lambdac> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
05:40:05 <quicksilver> TSC: I have a combinator called orElse, I use from time to time
05:40:23 <quicksilver> TSC: with type orElse :: m (Maybe a) -> m (Maybe a) -> m (Maybe a)
05:40:37 <quicksilver> that's related but actually I don't think it's quite what you're asking for.
05:40:53 <quicksilver> TSC: ah. you want MaybeT.
05:40:56 <quicksilver> or ErrorT.
05:41:03 <TSC> Yeah, I looked for MaybeT
05:41:10 <quicksilver> (MaybeT, inexplicably, isn't in the standard library)
05:41:31 <TSC> It seems like your orElse is like "liftM2 mplus"
05:41:32 <quicksilver> http://www.haskell.org/haskellwiki/New_monads/MaybeT
05:41:33 <lambdac> Title: New monads/MaybeT - HaskellWiki
05:41:39 <quicksilver> TSC: no, it's not.
05:41:48 <TSC> > liftM2 mplus (return (Nothing)) (return (Just 2))
05:41:49 <lambdac>   add an instance declaration for (Show (m (Maybe a)))
05:41:49 <quicksilver> TSC: it doesn't run the second action if the first is successful.
05:41:54 <TSC> Oh
05:42:02 <TSC> Ah, yes
05:42:13 <quicksilver> try a bunch of possibilities until one works, and then stop.
05:42:22 <quicksilver> I use it for example in a line breaking algorithm
05:42:57 <TSC> > liftM2 mplus ((Nothing)) ((Just 2))
05:42:58 <lambdac>   add an instance declaration for (Num (m a))
05:43:06 <TSC> @type liftM2
05:43:10 <lambdac> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:43:29 <gwern> 97 / 26
05:44:38 <TSC> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
05:44:41 <TSC> seems like the way to go
05:44:43 * quicksilver nods
05:44:50 <TSC> Thanks everyone
05:44:52 <quicksilver> I somteimes just use ErrorT and ignore the error value
05:44:57 <quicksilver> that's effectively MaybeT :)
05:44:58 <gwern> > 97 / 26
05:44:59 <lambdac>  3.730769230769231
05:45:05 <quicksilver> if you're too lazy to import a new package just for this
05:45:16 <TSC> Nonsense
05:45:20 <TSC> cabal install makes it really easy
05:45:25 <TSC> It's already done it
05:45:29 <quicksilver> ;)
05:45:36 <TSC> While I was typing this to say how easy it is (:
05:45:39 <quicksilver> I don't have cabal install installed.
05:45:41 <TSC> cabal install really is groovy
05:45:46 <quicksilver> I'm too lazy.
05:46:01 <TSC> Then you definitely need it, like me
05:46:55 <hackage> Uploaded to hackage: language-c 0.3.0
05:46:55 <hackage> Uploaded to hackage: formlets 0.4.2
05:46:55 <hackage> Uploaded to hackage: formlets 0.4.1
05:46:56 <hackage> Uploaded to hackage: blas 0.5
05:46:58 <hackage> Uploaded to hackage: url 1.0
05:47:49 <dafra> hi, if I log into a list with the Writer Monad. Is there some way to read the list itself at the end of the computation ?
05:50:16 <opqdonut> dafra: err, runWriter?
05:50:18 <opqdonut> :t runWriter
05:50:19 <lambdac> forall w a. Writer w a -> (a, w)
05:51:09 <TSC> @type put
05:51:11 <lambdac> forall s (m :: * -> *). (MonadState s m) => s -> m ()
05:51:39 <TSC> @type tell
05:51:41 <lambdac> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
05:52:06 <TSC> > runWriter (mapM_ tell [1..10])
05:52:07 <lambdac>  Add a type signature
05:52:24 <TSC> > runWriter ((mapM_ tell [1..10]) :: Writer Int)
05:52:25 <lambdac>      `Writer Int' is not applied to enough type arguments
05:52:25 <lambdac>     Expected kind `...
05:52:36 <TSC> > runWriter ((mapM_ tell [1..10]) :: Writer Int ())
05:52:36 <lambdac>   add an instance declaration for (Monoid Int)
05:52:43 <TSC> Ok, what am I doing wrong?
05:53:42 <quicksilver> TSC: Int is not a Monoid.
05:53:49 <quicksilver> much as that error message said ;)
05:54:03 <TSC> You can tell I've never used Writer (:
05:54:15 <quicksilver> > runWriter ((mapM_ tell [[1],[5],[10]]) :: Writer [Int] ())
05:54:16 <lambdac>  ((),[1,5,10])
05:54:21 <opqdonut> you probably want [Int]
05:54:23 <opqdonut> yes
05:54:52 <TSC> Yeah, I think so
05:54:54 <TSC> Thanks
05:55:22 <TSC> So you tell it monoids, and it mappends them together
05:55:32 <opqdonut> yes
06:03:11 <b\6> if i make some functions that might fail return Either String a, i'm not sure how to write the stuff to short circuit on the first Left. i basically want to use the 'a' or print the Left String.
06:03:15 <TSC> @index guard
06:03:15 <lambdac> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:06:21 <TSC> Isn't Either String declared as a monad somewhere?
06:06:33 <BeelsebobWork> I thought so, yes
06:06:39 <timbod> with cabal/ghc-pkg how do I find out what an installed package depends on?
06:06:47 <Igloo> Control.Monad.Error, I think
06:07:00 <dcoutts_> timbod: ghc-pkg field foobar depends
06:07:19 <TSC> Yeah, Control.Monad.Error(.Class)
06:07:53 <timbod> dcoutts_: is that the dependencies as specified in the cabal file, or as actually built against?
06:09:20 <timbod> cabal-install has "nicely" installed a new bytestring for me, and it's overlapping badly with the new one. I've attempted to rebuild everything against the new one, but something still references it - I'm trying to work out what.
06:09:40 <TSC> b\6: Is this what you want?  http://hpaste.org/9582
06:09:54 <TSC> You can see in that example that "z" is never called
06:10:02 <pastorn> @info ByteString
06:10:02 <lambdac> ByteString
06:10:12 <pastorn> oh, that was informative...
06:10:42 <b\6> TSC: yeah, that's neat, but can it be done without intermediate variables?
06:10:47 <TSC> timbod: Could you hide the old version with ghc-pkg, and see what breaks?
06:11:45 <timbod> It's already hidden. ghc-pkg list shows it like (bytestring-0.9.0.1.1)
06:13:38 <TSC> b\6: In that example, you could change f to:
06:13:41 <TSC> f = liftM sum (sequence [x,y,z])
06:13:46 <b\6> ah.
06:13:49 <TSC> Is that more like it?
06:14:12 <b\6> yeah, i'll study that. thanks.
06:14:18 <TSC> No worries
06:15:18 <trofimovich> > polynomial [0,0..]
06:15:19 <lambdac>  <Integer -> Integer>
06:15:23 <trofimovich> > polynomial [0,0..] 0
06:15:55 <lambdac>  thread killed
06:17:52 <timbod> I see that package "rts-1.0" has a dependency on bytestring-0.9.0.1.1  Yikes. Am I stuffed? Is it not easily possible to upgrade to a new bytestring because of this?
06:18:59 <subw> timod: I have ghcs bytestring and a newer one at the same time (none of the two hidden)
06:19:08 <subw> works without problems
06:19:27 <subw> just build all libraries that you want to use the new one after you installed it
06:21:41 <timbod> subw, that's what I've attempted to do. But I get this: GHCi runtime linker: fatal error: I found a duplicate definition for symbol
06:21:41 <timbod>    fps_minimum
06:21:41 <timbod> whilst processing object file
06:21:41 <timbod>    /home/timd/.cabal/lib/bytestring-0.9.1.0/ghc-6.8.3/HSbytestring-0.9.1.0.o
06:22:31 <subw> thats weird. maybe if you make cabal-install install stuff globally?
06:23:06 <subw> (change the line in ~/.cabal/config)
06:23:12 <timbod> I could try that. (I prefer user installs so as leave out the sudo)
06:25:20 <timbod> subw: I take it all back. I found one package that I rebuilt, but didn't reinstall. reinstalling that fixed the problem. Thanks!
06:27:34 <TSC> @type guard
06:27:36 <lambdac> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:27:53 <TSC> Is there something like guard, but "m Bool -> m ()" ?
06:28:29 <TSC> One workaround is "True <- monadicGuardExpression", but it looks strange
06:28:39 <timbod> :hist
06:28:49 <timbod> (oops - wrong window)
06:29:49 <chylli> I have a list1 [2,1,3], and I want to generate list2 [1,2,3] , whose index is list1's value, and value is list1's index,
06:29:58 <chylli> is there an idoim ?
06:30:04 <dmwit> :t let ensure p x = guard (p x) >> return x in \m -> m >>= ensure id >> return ()
06:30:06 <lambdac> forall (m :: * -> *). (MonadPlus m) => m Bool -> m ()
06:30:51 <dmwit> chylli: I'm not sure I understand your description.
06:31:19 <trofimovich> you can transform list [a] to [(a, index)] and sort it
06:31:35 <chylli> trofimovich: thanks
06:32:24 <TSC> :t let guardM e = e >>= guard in   guardM
06:32:26 <lambdac> forall (m :: * -> *). (MonadPlus m) => m Bool -> m ()
06:32:55 <tromp> > map snd . sort . (`zip` [1..3]) $ [2,1,3]
06:32:56 <lambdac>  [2,1,3]
06:32:56 <quicksilver> TSC: I have been known to use the "True <-" form
06:33:09 <quicksilver> TSC: but it's a bit ugly because it doesn't pull in the monadplus constraint.
06:33:19 <TSC> Yeah
06:33:24 <tromp> > map snd . sort . (`zip` [1..5]) $ [2,5,4,1,3]
06:33:26 <lambdac>  [4,1,5,3,2]
06:33:30 <TSC> What do you think of that guardM?
06:33:37 <dmwit> > map snd . sort . zip [1..3] $ [2,1,3]
06:33:38 <lambdac>  [2,1,3]
06:33:55 <dmwit> Oh, that was dumb.
06:34:00 <chylli> dmwit: tromp : thanks
06:34:00 <tromp> indeed:)
06:34:01 <dmwit> TSC: It's pretty.
06:34:07 <chylli> thats what I need.
06:34:29 <TSC> Unfortunately, MaybeT is not an instance of MonadPlus
06:34:43 <dmwit> Really?
06:34:49 <dmwit> I wonder why not.
06:34:56 <TSC> It's ambiguous, they say
06:35:05 <dmwit> ?unmtl MaybeT [] a
06:35:05 <lambdac> [Maybe a]
06:35:06 <TSC> http://hackage.haskell.org/packages/archive/MaybeT/0.1.1/doc/html/Control-Monad-Maybe.html
06:35:07 <quicksilver> there are certainly a couple of possible instances.
06:35:08 <lambdac> http://tinyurl.com/6oyyaq
06:35:15 <quicksilver> but you can choose the one you want.
06:35:18 <quicksilver> (just use a newtype)
06:36:07 <chylli> @hoogle sort
06:36:08 <lambdac> A Hoogle error occured.
06:36:24 <dmwit> ?index sort
06:36:24 <lambdac> Data.List
06:36:25 <TSC> chylli: It's in Data.List
06:36:32 <chylli> thanks
06:39:23 <trofimovich> why hoogle didn't found it?
06:39:44 <trofimovich> too old version?
06:40:16 <dmwit> lambdabot/lambdac have been acting up lately.
06:40:18 <rwbarton> hoogle in lambdabot isn't working at all currently
06:40:30 <dmwit> The real hoogle does just fine:
06:40:32 <dmwit> http://haskell.org/hoogle/?q=sort
06:40:33 <lambdac> Title: sort - Hoogle
06:42:51 * trofimovich patched recent lambdabot a little against hoodle-4. seems to work
06:46:50 <quicksilver> chylli: the web hoogle is generally preferred to the lambdabot one
06:47:09 <quicksilver> the lambdabot one is mainly for explicatory purposes : when demonstrating it to someone in the channel.
06:47:59 <BeelsebobWork> also, the reason it didn't find it there is that this \bot doesn't have hoogle set up at all
06:55:43 <Quadrescence> Are there any good sites/documents containing algorithms written in haskell?
06:56:01 <Quadrescence> (mostly more math-oriented algorithms)
06:56:06 <TSC> @src guard
06:56:06 <lambdac> guard True  =  return ()
06:56:06 <lambdac> guard False =  mzero
07:03:29 <_zenon_> @pl (,) ( (hallToText . table) s ) ( map show c )
07:03:29 <lambdac> (hallToText (table s), map show c)
07:03:34 <_zenon_> bleh
07:03:44 <quicksilver> that doesn't have any points in it.
07:03:47 <quicksilver> what do you mean?
07:04:03 <quicksilver> @pl \s c -> (hallToText (table s), map show c)
07:04:03 <lambdac> (. map show) . (,) . hallToText . table
07:04:06 <quicksilver> that, perhaps?
07:04:43 <_zenon_> no, just checking
07:10:12 <mnislaih> anyone familiar with HDBC around ? What is the standard practice about the lazy quickQuery and having more than one possibly simultaneous lazy query on the same connection ? Should I go with a new connection for every query or is that a bad idea ?
07:14:57 <CosmicRay> mnislaih: most databases will not support more than one simultaneous query on a single connection, lazy or not
07:15:32 <CosmicRay> mnislaih: there is no need in a sequential program to have a new connection for each query.  however it is probably necessary to have a new connection for each thread, or for each query that you start before the previous one finishes
07:15:49 <CosmicRay> note that laziness is not the only way to accomplish that (fetchRow and friends also read partial results)
07:16:42 <mnislaih> CosmicRay: but how can you be sure a query has been completely consumed once you throw laziness in ? I've been debugging this for several hours this morning and thus the question: what is the right way to play with quickQuery ?
07:17:12 <CosmicRay> mnislaih: you must either process it entirely, or use something like: evaluate (length result)
07:17:21 <CosmicRay> but if you are going to do that, then why bother with laziness?
07:17:27 <mnislaih> CosmicRay: exactly, I could go around forcing things, but then I'd rather iterate on the rows one by one
07:18:22 <CosmicRay> I guess I am not quite understanding the problem.  this works just like hGetContents.  when you have accessed the last row in the result in your processing, then you have consumed the result and the statement closes.
07:19:38 <quicksilver> note that multiple connetions running multiple SELECTS generally tie up non trivial server-side resources.
07:19:39 <mnislaih> CosmicRay: for each row in the result set, I may need to query the database to compute some intermediate value
07:20:04 <quicksilver> you think you're optimising it by not needing a fully query result in client memory at ocne
07:20:08 <CosmicRay> you probably want a second connection for that query then.
07:20:14 <quicksilver> but what you're actually doing is forcing the server to store it :)
07:20:24 <quicksilver> then you have to decide which is more precioiuse : server side or client side resource.
07:20:39 <mnislaih> quicksilver: there is no difference in this case. It's just more convenient, and the ddbb is far more efficient storing 80.000 rows than Haskell
07:20:40 <quicksilver> in the systems I've worked on, it's always been the case that server side resource is more precious.
07:20:43 <CosmicRay> but yes, if you are querying the *same* database it would seem you could craft a SELECT to give you a full result all at once
07:20:57 <quicksilver> well yes, that would be much better (one query)
07:22:02 <chylli> quicksilver: ok, I will give care to it.
07:22:04 <mnislaih> I'll try to do it that way (one single query). it looks not so compositional to me, but then my experience with db's is near to nil
07:23:42 <quicksilver> you're right, it's not compositional.
07:23:49 <quicksilver> it's forcing you to learn two languages (SQL and haskell)
07:23:51 <quicksilver> which is annoying.
07:24:03 <quicksilver> But SQL causes the execution to happen server-side
07:24:12 <quicksilver> which is normally faster, because teh DB server has access to stuff like indices
07:24:19 <quicksilver> and it's designed to be good at this kind of thing!
07:24:32 <quicksilver> also query overhead is non-trivial: 80,000 fast queries
07:24:37 <quicksilver> are much slower than 1 big query.
07:25:00 <mnislaih> quicksilver: agreed. Though in this case I'm using a local sqlite db
07:25:20 <CosmicRay> oh.
07:25:24 <mnislaih> and the small queries are necessary: they are UPDATEs
07:25:28 <CosmicRay> sqlite is very persnickity about simultaneous access
07:25:47 <CosmicRay> I am not positive that sqlite will let you do an UPDATE while a SELECT is going on.
07:26:09 <CosmicRay> most databases will, but I'm not positive about this
07:26:44 <quicksilver> oh, they're updates ;)
07:26:46 <quicksilver> you didn't say that.
07:26:46 <CosmicRay> also take note of the need to commit
07:26:53 <mnislaih> CosmicRay: indeed, sqlite does not. Hopefully I can use a separate connection, but I was wondering about the problem of lazy queries in general
07:26:55 <quicksilver> That is indeed different.
07:27:16 <CosmicRay> mnislaih: you need to read this page: http://www.sqlite.org/lockingv3.html
07:27:21 <quicksilver> SQL has historically been very poor at doing complex UPDATE queries which affect multiple rows at once.
07:27:35 <quicksilver> although modern SQL dialects can do clever stuff with subqueries and UPDATEs
07:27:41 <quicksilver> I suspect sqlite can't? I'm not sure.
07:27:46 <mnislaih> quicksilver: no no, they affect a single row. There is a big select, and then every row is processed and an update is doen
07:27:59 <CosmicRay> just glancing at the sqlite docs and indeed no apparent support for subqueries
07:28:12 <mnislaih> CosmicRay: I should read that, thanks. I thought this was a HDBC issue, but looks like it might be more complex than that
07:28:30 <CosmicRay> from reading that lockingv3 page, it appears to me that what you want to do is impossible in sqlite.
07:28:38 <CosmicRay> you select must finish before an update can begin.
07:29:11 <CosmicRay> because you have to hold an exclusive lock in order to write, and no other locks may be held while an exclusive lock is held, and you must hold at least a shared lock in order to read.
07:30:16 <CosmicRay> sqlite is not a full-featured database.  it is indeed quite a useful thing, and I have written software that uses it
07:30:26 <CosmicRay> but it is not written to be so concurrent as a full dbms like postgresql
07:30:43 <CosmicRay> if you're using sqlite for this task, you will probably need to buffer your updates somewhere.  ram or disk.
07:31:31 <CosmicRay> a full RDMBS like PostgreSQL would probably let you perform the computation on the server, so you could issue a total of one query to make everything update.
07:31:46 <CosmicRay> though doing so isn't a newbie-level SQL task
07:32:07 <mnislaih> thanks CosmicRay. I'll try to find my way around sqlite first
07:32:18 <flux> how about HaskellDb or somesuch?
07:32:18 <mnislaih> and I won't blame HDBC if that doesn't work :)
07:32:30 <mnislaih> @kudos CosmicRay
07:32:30 <lambdac> Unknown command, try @list
07:32:35 <CosmicRay> thanks ;-)
07:32:42 <mnislaih> hmm
07:32:44 <CosmicRay> flux: his problem really lies with the underlying DB engine, not the Haskell toolkit
07:33:03 <CosmicRay> flux: there is a limitation in sqlite, and no manner of Haskell code will get around it
07:33:32 <flux> from the last few lines I figured he wanted to do concurrent selects and updated?
07:33:35 <flux> updates, even
07:33:36 <quicksilver> haskelldb gives you a haskell-side DSL to generate complex SQL queries, doesn't it?
07:33:47 <quicksilver> flux: he wants to do one (very large) select and then 80,000 small updates
07:33:49 <CosmicRay> flux: right.  Sqlite doesn't support this.
07:33:55 <quicksilver> where the updates are calculated from the select.
07:34:07 <CosmicRay> flux: other DBMS of course do
07:34:13 <flux> well, the db backend can provide exclusivity to the db, so the select gets done first and then the updates?
07:34:39 <flux> only the performance will be less than great
07:34:46 <quicksilver> flux: yes, and sqlite doesn't.
07:34:48 <quicksilver> that's all.
07:38:30 <CosmicRay> flux: it is of course possible with HDBC to read all the data from the select before issuing the updates.
07:38:45 <CosmicRay> flux: whether or not that is desirable with a result set of 80,000 rows is another question.
07:38:56 <CosmicRay> it is almost certainly not desirable with a result set of 8,000,000 rows
07:39:11 <flux> well, in any case it is much more desirable than a crash or invalid results :)
07:39:14 <flux> or lockup
07:39:49 <CosmicRay> I wouldn't bank on avoiding a crash if you are caching 8,000,000 rows in ram ;-)
07:40:12 <flux> well, when you're issuing a 8M row select, you know it's going to spend memory somewhere
07:40:20 <CosmicRay> not necessarily
07:40:28 <flux> well, true I suppose
07:40:32 <flux> but you can expect that in worst case
07:40:41 <quicksilver> it's a complex equation, actually.
07:40:47 <CosmicRay> db engines should try really hard to avoid that.
07:40:49 <flux> if you want to be more optimistic about preserving memory, you would use cursors
07:40:52 <quicksilver> If your server is capable of streaming the rows without taking up memory
07:40:54 <quicksilver> which the good ones are
07:40:59 <quicksilver> then it has a concurrency issue
07:41:03 <CosmicRay> quicksilver: right.  IOW, everybody but mysql can? ;-)
07:41:05 <flux> which of course still could consume as much memory
07:41:08 <quicksilver> it has to maintain a separate 'world' for all other queries which come in
07:41:14 <quicksilver> if your DB has considerable churn
07:41:16 <CosmicRay> this is the whole reason I wrote HDBC to start with.
07:41:22 <CosmicRay> HSQL had no way to read results incrementally.
07:41:23 <quicksilver> and you get a lot of traffic while the streaming is happening
07:41:28 <CosmicRay> buffered the entire result set on the client end.
07:41:33 <quicksilver> you may not be taking about 8M result set server side
07:41:52 <quicksilver> but you might be talking about a larger than 8M "virtual world" on the server side
07:41:55 <quicksilver> which can be even worse :)
07:42:06 <quicksilver> and a painful reconcilation once your query is over.
07:42:07 <flux> I've been writing db-stuff in another language, and certain primitives such as db_fold_left, which uses cursors underneath, have been useful
07:42:26 <quicksilver> most practical DBs solve this kind of problem by ditching consistency.
07:42:27 <CosmicRay> flux: you can implement that atop fetchRow in HDBC
07:42:42 <quicksilver> Actually by cutting it into small pieces, washing it in acid, burning it and stomping on the remains.
07:42:50 <CosmicRay> heh
07:43:02 <quicksilver> ACID? doens't exist.
07:43:04 <CosmicRay> flux: HDBC is a fairly low-level interface, in case you hadn't noticed already
07:43:08 <quicksilver> Except in hAppS
07:43:09 * CosmicRay senses we have touched a nerve
07:43:13 <quicksilver> ;)
07:43:18 <quicksilver> not really a nerve. Just a favourite rant.
07:43:23 <CosmicRay> heh
07:43:36 * CosmicRay trolls: so what do you think of consistency in mysql? ;-)
07:43:56 <CosmicRay> you don't even have transactions by default there.
07:43:57 <Elly> it's a good idea
07:44:05 <Elly> we should have more of it
07:44:21 <dmwit> What is the relationship of HaskellDB to HDBC?
07:44:37 <CosmicRay> dmwit: IIRC, HDBC is one potential backend driver for HaskellDB
07:45:09 <CosmicRay> I believe it also supports HSQL
07:45:24 <CosmicRay> but in general, HaskellDB is a high-level wrapper around HDBC
07:45:34 <dmwit> I see.
07:45:36 <CosmicRay> HaskellDB takes care of all that gory sql stuff for you.
07:46:46 <hackage> Uploaded to hackage: mines 0.1
07:46:46 <hackage> Uploaded to hackage: formlets 0.4.3
07:48:41 <b\6> what are the options for little haskell http servers that support cgi?
07:51:17 <b\6> speaking of http servers.
07:51:25 <b\6> tibbe: are you working on an http server?
07:51:34 <quicksilver> I'm not sure there are any haskell http servers that are widely used except the one built in to hAppS
07:51:37 <tibbe> b\6: yes
07:51:49 <b\6> tibbe: cool. is it darcsable or gitable or something?
07:52:04 <tibbe> b\6: it's gitable but since I haven't announce it use at your own risk
07:52:16 <tibbe> it survives Apache bench and Siege
07:52:18 <tibbe> though
07:52:23 <b\6> that's great.
07:52:25 <tibbe> but I haven't implemented chunked encoding yet
07:52:43 <tibbe> b\6: http://www.johantibell.com/cgi-bin/gitweb.cgi?p=hyena.git;a=summary
07:52:46 <lambdac> Title: www.johantibell.com Git - hyena.git/summary, http://tinyurl.com/55mp49
07:52:59 <Valodim> lighttpd + happs = woot
07:52:59 <twobitwork> dmwit = dmhouse?
07:53:16 <b\6> tibbe: thanks.
07:53:33 <tibbe> b\6: your welcome
07:53:35 <b\6> lighttpd's another billion line c program, right?
07:53:44 <tibbe> b\6: I hope I can get a first launch out in a month
07:53:57 <b\6> maybe i can send some janitorial patches or something.
07:54:03 <Valodim> I think so
07:54:21 <b\6> billion line c program -> there are horrible bugs that are really really hard to find
07:54:27 <Valodim> lighttpd outperforms apache to a ridiculous degree, though
07:54:31 <b\6> yeah.
07:54:34 <Valodim> and it worked very well for me
07:54:49 <b\6> i kind of liked it, too.
07:54:50 <b\6> but..
07:55:37 <quicksilver> b\6: a few billion lines shorter than apache
07:55:38 <quicksilver> but, yes.
07:57:19 <Axman6> Valodim: depends on how you measure it really. but yes, i love lighttpd. great for static content, and it's FastCGI stuff is great
07:57:53 <b\6> tibbe: sorry, confused. what's the git clone url?
07:58:38 <Valodim> is there a (reasonable) way of measuring it that makes lighttpd lose to apache?
07:58:55 <quicksilver> Axman6: before lighttpd had mod_rewrite, that was a good reason to prefer apache.
07:58:59 <Axman6> Valodim: well features for one, and probably security
07:59:12 <tibbe> b\6: thought gitweb listed it, git clone http://git.johantibell.com/hyena.git
07:59:14 <lambdac> Title: Index of /hyena.git/
07:59:17 <quicksilver> Axman6: now it even has decent rewriting, it's a very attractive option indeed.
07:59:21 <b\6> tibbe: thanks.
07:59:31 * quicksilver seldoms finds a configuration problem mod_rewrite can't solve.
07:59:32 <tibbe> b\6: np, I will put it up on github once it's released
07:59:46 <tibbe> b\6: please email feedback to johan dot tibell at gmail dot com
07:59:52 <b\6> ok.
08:00:02 <Valodim> true about the features, but those are mostly the obscure or very specific ones
08:00:04 <Axman6> i use it on my slow little FreeBSD server for static content. one day i'll get it working for all my php stuff too
08:00:10 <quicksilver> mod_{perl,python,ruby,etc etc etc} are reasons to use apache.
08:00:25 <quicksilver> but not strong ones since fastcgi is in many ways a superior solution.
08:00:50 <trofimovich> rewrite stuff, cache control
08:01:10 <Valodim> htaccess is one - but I don't like htaccess, it's messy and slow
08:01:43 <b\6> i remember stuff in apache about disallowing symlinks in user dirs, etc.
08:01:45 <vixey> programs where you press 'apply new settings' but it doesn't save them until you quit (which never happens since the thing crashed)--
08:04:04 <Botje> well, apply /= save :p
08:05:44 <vixey> when there is no way to save -except- quitting
08:05:57 <vixey> oh I know why it's like this!
08:06:09 <vixey> it makes implementing "revert" easy
08:06:29 <vixey> corner cutting programmers--
08:08:54 <dmwit> That's an easy corner, too.  Just fire up an instance of darcs...
08:09:17 <dmwit> (People should use revision-control software as a component of their applications more often.)
08:23:05 <explisixjelly> seriously though, is there anyone who's *not* writing an interpreter and/or compiler as one of the first things?
08:23:55 <sbahra> One of the first things of?
08:25:18 <explisixjelly> sbahra, of writing anything in haskell
08:25:42 * sbahra is starting an abstract interface to PCI devices tomorrow 
08:26:30 <sbahra> My first "real" project
08:26:37 <sbahra> explisixjelly, what have you been thinking of doing?
08:26:54 <explisixjelly> sbahra, what do you mean?
08:27:12 <vixey> programs exist that aren't compilers or interpreters ...?
08:27:13 <sbahra> Were you asking because you're looking for a project to work on?
08:28:17 <explisixjelly> sbahra, no... I just noticed that I was writing a lot of little interpreters in haskell, and then a big one. and other observation tells me that it's actually quite common, Haskell is good for this. and I was wondering if maybe a lot of people would write a small interpreter when trying out Haskell
08:29:03 <sbahra> ah
08:29:21 <vixey> explisixjelly: Every program is an interpreter or compiler or mix of the two
08:29:52 <_zenon_> (init . concat . foldr ((:) 'z') [ [x,'z']  | x <- "abcdef"]
08:29:59 <b\6> ? what does hello world interpret or compile?
08:30:16 <vixey> you are either transforming language or executing instructions based on a language
08:30:26 <_zenon_> @pl ( head  . concat) [ [x,'z']  | x <- "abcdef"]
08:30:26 <lambdac> head ([x, 'z'] | x <- "abcdef")
08:30:53 <explisixjelly> vixey, sheesh. yes. I know. I'm studying computer science, too. but you know what I mean.
08:31:29 <vixey> explisixjelly: Actually I don't :p
08:32:47 <quicksilver> explisixjelly: it is often said that all sufficiently complex programs embed an interpreter.
08:33:07 <explisixjelly> quicksilver, sounds reasonable
08:33:09 <quicksilver> explisixjelly: the fact that haskell is good at this, therefore, means haskell is good for all sufficiently complex programs ;)
08:33:14 * quicksilver <- syllogism FAIL.
08:35:59 <vixey> we've got proof and evidence that haskell suits big programs now!
08:36:18 <vixey> so lets .. restandardize the languge :/
08:36:41 <SamB> vixey: what to do about fundeps?
08:36:45 <besiria> what 'M' in MVar stands for?
08:36:50 <vixey> they don't exist
08:36:55 <vixey> :0
08:37:06 <trofimovich> Mutable?
08:37:50 <Philippa> explisixjelly: if you don't have a "real app" in mind then interpreters make a fairly obvious choice not least because they help you learn the language faster by understanding how to implement (parts of) it
08:38:13 <Axman6> SamB: same SamB from oftc?
08:38:15 <besiria> trofimovich: probably
08:38:29 <noohgodno> all sufficiently complex programs embed an interpreter
08:38:31 <noohgodno> ?
08:38:35 <noohgodno> where did quicksilver go
08:38:43 <SamB> Axman6: yeah
08:38:53 <vixey> 'map f' is an interpreter
08:39:09 <explisixjelly> Philippa, true...
08:39:13 <Axman6> ok, thought i'd seen your nick before :)
08:39:14 <vixey> fold is a complier :))
08:39:25 <explisixjelly> vixey, yes, EVERYTHING is a compiler
08:39:34 <explisixjelly> even x = x is a compiler
08:39:35 <noohgodno> define compiler...
08:39:39 <vixey> explisixjelly: I suppose so
08:39:43 <explisixjelly> it accepts every language and transforms it using its identity
08:39:44 <b\6> it's a compiler when shingles fall off my roof.
08:39:57 <quicksilver> noohgodno: yes, they do.
08:40:22 <quicksilver> noohgodno: at the very least a config file interpreter, but often also a user commanad interpreter
08:40:29 <quicksilver> perhaps a network protocol interpreter
08:40:30 <quicksilver> etc.
08:40:38 <quicksilver> command not comonad :)
08:41:28 <vixey> hehe "If you are really geeky, as I am, besides having the C# language spec as nighttime reading, you might enjoy using .NET Reflector to figure out what code the C# compiler generates to make this work."
08:42:56 <noohgodno> C# is the Gene Shallot of languages
08:44:34 <therp> Greenspun's Tenth Rule of Programming: "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp."
08:45:52 * quicksilver nods
08:47:59 * BMeph wonders if Common Lisp isn't ad-hoc itself
08:48:36 <vixey> it is not
08:48:37 <trofimovich> and which program would use half of it's concepts?
08:48:44 <BMeph> thinks "ad-hoc implementation of ... Common Lisp" is a tautology
08:48:56 * noohgodno thinks bmeph is a tautology
08:48:57 <therp> don't take the last statement seriously. To me it's more like a running gag.
08:49:26 <BMeph> therp: Surely it's run so long, it's just crawling by now... ;)
08:52:53 <vixey> >> "foobar".scan(/../)
08:52:53 <vixey> => ["fo", "ob", "ar"]
08:52:56 * vixey is impressed 
08:53:39 <b\6> vixey: being sarcastic?
08:54:03 <vixey> b\6: compare with haskell versions
08:54:22 <b\6> well, i mean.. welcome to at least 5 years ago.
08:54:25 <Axman6> vixey: ruby, correct?
08:54:31 <vixey> yes
08:54:46 <vixey> b\6: What happened 5 years ago?
08:54:48 <noohgodno> who admins #lisp
08:55:01 <vixey> noohgodno: Not #haskell
08:55:05 <Axman6> yeah ruby has some very nice sugar indeed
08:55:27 <b\6> vixey: just getting excited about ruby in 2008 seems a little weird.
08:55:46 <vixey> oh
08:55:53 <vixey> I'm not up to date with the latest trends :)
08:56:06 <Axman6> i do like how it can be used imperitevly, OOP'edly and functionally, all at the same time, or exclusively
08:56:24 <therp> noohgodno: a bunch of people with some serious social disorders.
08:56:32 <vixey> Axman6: yeah we need an OOP monad
08:56:45 <b\6> i'm just sick of ruby because misspelling a variable name results in silent crazy behavior.
08:56:46 <vixey> #haskell-blah
08:56:52 <therp> Welcome to #lisp, where you are flamed for your question in majestic stereo!
08:57:09 <b\6> ruby's like yeah, he only references this variable once, but maybe he intends to create it on the fly later, so off we go.
08:57:58 <Philippa> vixey: not really. What we need is a better record system, the rest's a couple of wrapper functions on top of ST
09:01:07 <Twey> @src words
09:01:07 <lambdac> words s = case dropWhile isSpace s of
09:01:08 <lambdac>     "" -> []
09:01:08 <lambdac>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:01:24 <Twey> @src break
09:01:24 <lambdac> break p =  span (not . p)
09:01:27 <noohgodno> lisp is powerful, though
09:01:33 <noohgodno> in ways that most people don't seem to realize
09:02:31 <Philippa> true. It's a good idea to work on the basis that people in here aren't most people, mind
09:02:37 <vixey> lisp - beyond the gates of heaven and hell
09:03:26 <Philippa> I recently described haskell as "the anti-lisp", because the approach is to start off with very little power at all and build exactly the level you need and not a level that actually endangers you
09:04:10 <trofimovich> does any lisp have compiler .lisp -> native binary ?
09:04:25 <vixey> trofimovich: ecl
09:04:28 <vixey> "If the doors of perception were cleansed every thing would appear to man as it is, infinite. For man has closed himself up, till he sees all things through narrow chinks of his cavern."
09:04:59 <therp> noohgodno: Lisp has more powerful syntax, and that's mostly it. haskell is conceptually much stronger than anything I've seen in Lisp (although Lisp is much stronger than anything I've seen before that)
09:05:26 <noohgodno> lisp's power is in that it implicitly allows the modification of its own code
09:05:33 <noohgodno> this is how you emulate intelligence
09:05:36 <therp> trofimovich: sbcl has a native compiler for most platforms
09:05:51 <noohgodno> so if you write a program in lisp that understands how to write lisp
09:06:00 <noohgodno> well
09:06:03 <trofimovich> therp: how to compile simple hello world binary?
09:06:04 <noohgodno> don't tell it about war
09:06:17 <vixey> trofimovich: In haskell?
09:06:19 <Philippa> *sigh*. Yeah, because there's no way to do code generation in any other language
09:06:26 <trofimovich> therp: standalone (small) binary
09:06:27 <vixey> trofimovich: You should probably ask this in #cl-gardeners ?
09:06:29 <trofimovich> in sbcl
09:06:42 <vixey> trofimovich: not #haskell
09:07:00 <trofimovich> i'm afraid to go there
09:07:04 <Philippa> to put it another way: Haskell can quite happily generate programs and run them too. We even have lighter-weight embeddings than the one you describe where appropriate. Where's the big deal?
09:07:11 <vixey> trofimovich: You are scared of #cl-gardeners ?
09:07:24 <therp> noohgodno: true. meta-programming. but Haskell can substitute most of the functionally by higher-order functions (although it's executed at runtime not compile-time).
09:07:41 <trofimovich> the "cl" substring makes me sick
09:07:53 <vixey> trofimovich: OK
09:07:59 <vixey> trofimovich: good luck
09:09:43 <noohgodno> what's Joy like?
09:09:54 <vixey> horrible...
09:09:55 <b\6> pretty nice. you feel really happy.
09:10:16 * vixey got frustatred
09:10:43 <noohgodno> how about Cat?
09:10:44 <quicksilver> I think Joy is a beautiful thing to study.
09:10:58 <quicksilver> I am not convinced it is a good language for writing large programs.
09:10:59 <Nafai> noohgodno: I get the feeling that Cat is just a toy.
09:11:21 <Nafai> noohgodno: If you want to get a feeling for a more practical concatenative language, look at Factor
09:11:36 <noohgodno> =-o a dinosaur
09:11:42 <noohgodno> i'm sold!
09:11:44 <vixey> anybody implement LZW in haskell?
09:11:59 <Nafai> Though, yeah, I'm not convinced that concatenative programming scales
09:12:01 <Nafai> It's interesting though
09:16:02 <noohgodno> > 3
09:16:04 <lambdac>  3
09:16:13 <noohgodno> > 4
09:16:14 <lambdac>  4
09:16:18 <vixey> > 5
09:16:19 <lambdac>  5
09:16:31 <noohgodno> > product [333333..555555]
09:16:36 <Nafai> > [6..]
09:16:39 <lambdac>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3...
09:16:40 <lambdac> Terminated
09:16:48 <Nafai> :)
09:16:57 <noohgodno> > [sarahconnor..]
09:16:57 <lambdac>   Not in scope: `sarahconnor'
09:17:05 <noohgodno> it was worth a shot
09:17:08 <Nafai> Haha
09:17:24 <Nafai> "Terminated", not "Terminator"
09:17:48 <noohgodno> @let sarahconnor=4
09:17:49 <lambdac> Defined.
09:17:54 <noohgodno> > [sarahconnor..]
09:17:55 <lambdac>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
09:18:06 <noohgodno> oh, that was mine, not yours
09:18:12 <noohgodno> > product [sarahconnor..]
09:18:20 <lambdac> Terminated
09:18:21 <dons_> http://www.reddit.com/r/programming/comments/6w5vf/haskell_weekly_news_languagec_blas_information/ woot
09:18:23 <noohgodno> :]
09:18:23 <lambdac> Title: Haskell Weekly News: Language.C, BLAS, information visualization and truetype fo ..., http://tinyurl.com/5zzycg
09:18:32 <dons_> double woot! http://www.reddit.com/r/programming/comments/6w5vu/freaking_awesome_languagec_a_haskell_library_for/
09:18:34 <lambdac> Title: Freaking awesome! Language.C: a Haskell library for parsing, transforming and ge ..., http://tinyurl.com/6mf7kx
09:19:02 * vixey would like lambdabot to link to the non-reddit page
09:19:13 * EvilTerran too
09:19:47 <therp> so we can build a Language.C to Haskell compiler?
09:21:07 <noohgodno> now build a C to English compiler, and i'll be really impressed
09:23:31 <Nafai> byorgey!
09:23:39 <byorgey> Nafai!
09:23:45 <Nafai> How are you?
09:24:11 <byorgey> I'm well, thanks!
09:24:14 <byorgey> how about you?
09:24:20 <Nafai> Not too bad
09:24:24 <Nafai> Just bored at work :)
09:24:40 <byorgey> heh, sorry to hear that
09:25:55 <byorgey> I'm filling in a form telling U Penn about all the times I've had dead viruses injected into my body
09:26:10 <Nafai> Sounds exciting
09:26:14 <byorgey> yup
09:26:58 <ddarius> What the?  Why does the college care?
09:27:14 <EvilTerran> noohgodno, i'd rather have an english-to-c compiler
09:27:24 <vixey> dead ones? or deadly ones?
09:27:32 * EvilTerran is guessing vaccines
09:27:34 <EvilTerran> so dead ones
09:27:39 <EvilTerran> well, deactivated ones
09:27:42 <byorgey> ddarius: it's pretty standard.  I think they just want to make sure there isn't, say, an outbreak of measles on campus
09:27:46 <vixey> oh really I don't know anything about biology
09:27:48 <byorgey> EvilTerran: right =)
09:28:07 <vixey> weird
09:29:14 <byorgey> @seen thoughtpolice
09:29:14 <lambdac> thoughtpolice is in #haskell-blah and #haskell. I don't know when thoughtpolice last spoke.
09:29:25 <thoughtpolice> byorgey: hi
09:29:28 <byorgey> thoughtpolice: did you get your question about (->) answered?
09:29:35 <thoughtpolice> byorgey: yes :)
09:29:42 <byorgey> ok, good, just making sure =)
09:30:00 <ddarius> vixey: wtf?
09:30:15 <vixey> ddarius: What question are you asking?
09:30:31 <ddarius> vixey: How do you not know anything about biology?
09:30:42 <vixey> I never read about it
09:31:07 <ddarius> vixey: You never went to school?
09:31:07 <Philippa> and skipped science at school?
09:31:37 <vixey> they don't really teach you this sort of thing in school ...
09:31:44 <ddarius> Sure they do.
09:32:00 <Botje> yup
09:32:25 <Botje> perhaps they taught you lambda calculus :)
09:33:08 <noohgodno> are there any haskell BNF parsers
09:33:23 <vixey> school taught me horrible people exist and people who have authority over you are sometimes stupid
09:33:28 <noohgodno> (aside, programming should be required in public schools)
09:33:48 <EvilTerran> noohgodno, as in, something that converts a string into a description of the grammar?
09:33:48 <vixey> I don't think I actually learned anything else there
09:33:48 <ddarius> Hmm, the BNF for BNF ...
09:33:59 <vixey> ?wiki bnf
09:34:00 <lambdac> http://www.haskell.org/haskellwiki/bnf
09:34:05 <byorgey> noohgodno: what do you want it for?
09:34:08 <vixey> not that wiki...
09:34:16 <EvilTerran> (a string of the form "foo ::= ...; bar ::= ..." or whatever)
09:34:19 <vixey> @go bnf site:wikipedia
09:34:21 <lambdac> No Result Found.
09:34:21 <noohgodno> translation
09:34:29 <ddarius> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/ ?
09:34:31 <lambdac> Title: The BNF Converter
09:34:42 <EvilTerran> noohgodno, or do you mean something for making parsers out of BNF-esque grammars?
09:34:59 <vixey> http://en.wikipedia.org/wiki/Backus-Naur_form#Further_examples
09:35:25 <noohgodno> i have a markup language
09:35:28 <noohgodno> sort of like XML
09:35:41 <noohgodno> where the children tags of any set of tags
09:35:54 <noohgodno> imply the composition of the parent of and only of the children
09:36:06 <trofimovich> @go what is EBNF
09:36:11 <lambdac> http://www.garshol.priv.no/download/text/bnf.html
09:36:11 <lambdac> Title: BNF and EBNF: What are they and how do they work?
09:36:15 <Philippa> are you particularly attached to (E)BNF?
09:36:18 <EvilTerran> noohgodno, so you want something to parse these things?
09:36:31 <noohgodno> mnhm
09:36:35 <vixey> BNF aren't supposed be run :)
09:36:42 <Philippa> most Haskell parsing libs have left-biased choice and consequently eliminate ambiguity
09:36:54 <EvilTerran> as long as you don't mind using something that isn't quite EBNF but does the same job, there's Parsec, Alex+Happy, ReadP, ...
09:36:59 <noohgodno> :]
09:37:14 <Philippa> Alex+Happy is fairly equivalent to lex/yacc, isn't it?
09:37:30 <ddarius> EvilTerran's ellipses hides a lot
09:38:06 <Philippa> PolyParse might well have a lib that suits you
09:39:28 <thoughtpolice> oh yay, language-c release :)
09:41:29 <noohgodno> i can't wait until this engine is built >;o
09:41:34 <vixey> also with BNF it's very hard to get a useful parse tree
09:42:42 * noohgodno disagrees
09:42:50 <noohgodno> well
09:42:59 <noohgodno> perhaps BNF
09:43:23 <noohgodno> there are strict rules as to the composition of grammatical structures though
09:43:51 <noohgodno> depending on how you define "strict"
09:44:36 <Quadrescence> How do you do integer division again? (Int -> Int -> Int)
09:44:45 <EvilTerran> `div`
09:44:50 <EvilTerran> or `quot`
09:44:50 <Zao> or `quot`
09:44:57 <Quadrescence> Is there a difference?
09:45:05 <Quadrescence> :t `div`
09:45:06 <EvilTerran> the rounding behaviour when one number is negative
09:45:07 <lambdac> parse error on input ``'
09:45:08 <vixey> godno: Take a BNF for +-*/ and numbers
09:45:12 <EvilTerran> ?type div
09:45:13 <lambdac> forall a. (Integral a) => a -> a -> a
09:45:18 <EvilTerran> quot has the same type
09:45:23 <Quadrescence> Okay
09:45:27 <vixey> godno: what is the parse tree for 12+33*4 ?
09:45:39 <vixey> it's certainly not  Add 12 (Times 33 4)
09:45:41 <quicksilver> vixey: starting with BNF and doing some simple in-place post processing often gives reasonable results, though.
09:46:12 <EvilTerran> ?check \x y -> y /= 0 ==> (x `div` y) * y + (x `mod` y) == x
09:46:13 <lambdac>  OK, passed 500 tests.
09:46:21 <EvilTerran> ?check \x y -> y /= 0 ==> (x `quot` y) * y + (x `rem` y) == x
09:46:22 <lambdac>  OK, passed 500 tests.
09:46:26 <twanvl> > ((-3) `divMod` 2, (-3) `quotRem` 2)
09:46:27 <lambdac>  ((-2,1),(-1,-1))
09:46:34 <elliottt> anyone know why haskell doesn't allow local type synonyms?
09:46:47 <EvilTerran> Quadrescence, use whichever you find more aesthetically pleasing if you're only dealing with positive numbers
09:46:50 <vixey> elliottt: I think it does
09:46:55 <elliottt> yeah?
09:47:11 <vixey> elliottt: http://www.haskell.org/haskellwiki/GHC/Type_families is that relevant?
09:47:13 <lambdac> Title: GHC/Type families - HaskellWiki
09:48:11 <EvilTerran> Quadrescence, (x `div` y) is the greatest integer such that y * it <= x
09:48:23 <EvilTerran> Quadrescence, i forget the exact definition of `quot`, but it's not as clean
09:48:24 <thoughtpolice> associated types will more or less let you express the same thing as fundeps if that's what you're looking for
09:48:33 <thoughtpolice> although associated types are more functional than fundeps
09:49:07 <elliottt> vixey: not quite, i'm going for a local shadowing of a global synonym
09:49:23 <EvilTerran> Quadrescence, ah, to use the report's words: "`quot` is integer division truncated toward zero, while the result of `div` is truncated toward negative infinity."
09:49:28 <vixey> oh .. that isn't possible
09:49:32 <elliottt> :)
09:49:46 <vixey> can't replace it with this though?
09:50:12 <elliottt> vixey: replace what?
09:51:12 <quicksilver> elliottt: haskell also doesn't have local data or local newtype.
09:51:17 <quicksilver> elliottt: or local class instances.
09:51:20 <elliottt> right
09:51:30 <elliottt> i was just wondedring if there was a good reason to not allow local type synonyms
09:51:32 <quicksilver> local class instances would be a disaster, so it's good we don't ahve those.
09:51:36 <elliottt> or if it was just for consistency
09:51:41 <quicksilver> local types I don't there is a good reason.
09:51:48 <quicksilver> it's just cost of implementation vs benefit.
09:51:49 <elliottt> ok, thanks :)
09:52:35 <gwern> > mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map([" "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
09:52:36 <lambdac>  <IO ()>
09:52:59 <EvilTerran> > reverse[(++)([1..y-30]>>" ")$concat$map([" "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
09:53:00 <lambdac>  ["                                /","                               / \\","...
09:53:09 <EvilTerran> ?
09:53:27 <trofimovich> an image?
09:53:32 <EvilTerran> you can shave a character off that by using concatMap
09:53:33 <EvilTerran> :P
09:53:56 <EvilTerran> i think
09:54:02 <Botje> that's pretty nifty.
09:54:03 * gwern pastes into ghci
09:54:07 <gwern> ah, I see
09:54:12 <gwern> it's pascal's triangle
09:54:13 <Botje> " " should be "  " though
09:59:24 <gwern> 'During my search for a lisp editor / compiler for OS X, I was pointed in the direction of Haskell by a colleague at work.  He's worked with lisp before and thought that there might be a larger community and more resources available for Haskell.   A short web investigation and I believe that he's probably right.'
10:00:20 <BMeph> gwern: link? :)
10:00:35 * gwern closed it. bwa ha ha ha
10:00:43 <noohgodno> diabolical
10:00:55 <noohgodno> http://thespohtexperiment.blogspot.com/2008/08/new-paradigm.html
10:00:56 <lambdac> Title: The Spoht Experiment: A New Paradigm - Haskell and HAppS
10:01:17 <noohgodno> if only there were a way to search the text contained within webpages
10:02:04 <gwern> noohgodno: absurd. can you imagine the computing resources necessary?
10:02:48 <noohgodno> nope
10:03:31 <noohgodno> http://www.youtube.com/watch?v=y3W8dm5JxFc
10:03:31 <lambdac> Title: YouTube - Robotic Mule
10:03:34 <noohgodno> i hate that goddamn mule
10:04:00 <gwern> why, you would need petabytes of storage space and thousands upon thousands of machines
10:04:15 <Elly> gwern: and some kind of sophisticated algorithm for somehow finding websites to index
10:05:08 <gwern> Elly: well, I'd venture such an algorithm would border on AI and so be infeasible. I mean, quite aside from the problem of running it fast enough to be relevant, it'd have to deal with all sorts of malicious and broken content
10:05:18 <gwern> we'll just have to live without, it seems.
10:05:25 <Elly> oh well :(
10:05:27 <gwern> (science means not all dreams can come true!)
10:06:18 <noohgodno> now if we can only make a robot that spins umbrellas...
10:06:29 <gwern> on a side note, I need to get the 'science means not all dreams can come true' t-shirt. it's just such a sad statement
10:08:59 <Elly> if you do enough science, any dream can come true :)
10:09:39 <vixey> ?faq science ?
10:09:40 <lambdac> The answer is: Yes! Haskell can do that.
10:09:48 <teardrop72> @bot
10:09:48 <lambdac> :)
10:10:08 <gwern> Elly: what about violate the laws of thermodynamics and acheive immortality?
10:10:15 <vixey> yay
10:10:17 <gwern> (that was the strip that the quote comes from)
10:10:26 <Elly> gwern: the latter is not implausible
10:10:27 <vixey> gwern I just read that comic a few days ago
10:10:47 <Elly> gwern: the former, well, the laws of thermodynamics are observational, not dictatorial :P
10:10:50 <gwern> vixey: as did I... in my Dinosaur Comics book
10:10:53 * vixey tends to discover a web comic and read the entire thing in one go when it's any good
10:11:00 <Elly> I do that too
10:11:04 * gwern one-ups vixey 
10:11:10 <Elly> it keeps me up all night though
10:11:43 <gwern> it's unfortunate, though, that many times you do that with strips that are still in progress
10:11:53 <Elly> yeah :(
10:11:56 <Elly> then you have to start polling
10:12:19 <gwern> rss and email lists make it not too bad
10:12:39 <vixey> > " vixey "
10:12:40 <lambdac>  " vixey "
10:12:49 <gwern> but the endlessness is painful. and god help you if you find a comic early on
10:13:02 <Elly> yeah :[
10:13:13 <gwern> I've been following megatokyo for like 6 years. I sort of thought it'd be finished by now!
10:13:34 <Elly> I gave up on megatokyo
10:13:38 <Elly> it got kind of lame
10:15:41 <lament> a lame webcomic, impossible
10:18:35 <saml> is there a heterogeneous collection that doesn't have fixed cardinality like (a,b,c) ?
10:18:57 <vixey> saml: yeah sort of
10:19:29 <vixey> :t (1,(3,("foo",("bar",(),((\x -> x),())))))
10:19:31 <lambdac> forall t t1 t2. (Num t1, Num t) => (t, (t1, ([Char], ([Char], (), (t2 -> t2, ())))))
10:19:55 <saml> i mean, length of the collection is to be determined at run time
10:20:07 <vixey> :t let (*) = (,) in (1 * 3 * "foo" * "bar" * () * (\x -> x) * ())
10:20:09 <lambdac> forall t t1 t2. (Num t1, Num t) => ((((((t, t1), [Char]), [Char]), ()), t2 -> t2), ())
10:20:29 <saml> vixey, oh that could work coolz!
10:20:48 * saml tries to implement generic zipWith   
10:20:53 <vixey> lol
10:20:53 <tromp> > mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map([" ","/", " -", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
10:20:55 <lambdac>  <IO ()>
10:21:15 <mfp> saml: this is in SML but, http://mlton.org/PropertyList
10:21:17 <lambdac> Title: PropertyList - MLton Standard ML Compiler (SML Compiler)
10:24:34 <matthew-_> @seen BSP_
10:24:34 <lambdac> I haven't seen BSP_.
10:24:40 <matthew-_> drat
10:24:47 <mauke> preflex: seen BSP_
10:24:47 <preflex>  BSP_ was last seen on #ghc 1 hour, 2 minutes and 51 seconds ago, saying: nominolo: the tailor wiki has a report from the author that two-way sync is really difficult.. and i would tend to believe him
10:24:49 <saml> @type taut
10:24:51 <lambdac> Not in scope: `taut'
10:25:48 <matthew-_> I see. Bot competition now eh?
10:26:00 <matthew-_> you two should duke it out some time...
10:27:16 <glguy_> preflex is the only bot that has a long enough uptime around here to give good @seen results
10:27:30 <mauke> not quite true; it does get disconnected sometimes
10:27:35 <mauke> but it doesn't lose state when it does
10:27:43 <mauke> er
10:27:59 <mauke> I hope you know what I mean :-)
10:28:06 <paczesiowa> saml: http://hpaste.org/8899
10:29:18 <saml> paczesiowa, from http://www.brics.dk/RS/01/10/ ?
10:29:20 <lambdac> Title: Do we Need Dependent Types?
10:29:27 <saml> << this stuff
10:29:36 <paczesiowa> yeah
10:31:43 <hask> How can create a script for:
10:32:14 <hask> ghc --make path/file1.hs path/file2.hs etc pth/filex.hs
10:32:55 <mauke> an automated build system?
10:32:57 <mauke> normally you use Cabal for that
10:32:58 <hask> yes
10:33:06 <hask> Cabal?
10:33:23 <mauke> http://haskell.org/cabal/release/latest/doc/users-guide/
10:33:24 <lambdac> Title: Common Architecture for Building Applications and Libraries
10:33:25 <hask> In windows vista
10:35:06 <hask> g
10:35:23 <hask> ty
10:43:19 <Quadrescence> Hrm, this is a somewhat-general question, but what would be an "equivalent" Haskell construct for an imperative "while(predicate)...loop" construct?
10:46:57 <vixey> :t whileM
10:46:58 <lambdac> Not in scope: `whileM'
10:47:02 <vixey> umu
10:47:26 <vixey> whileM predicate body = if predicate then do body >> whileM predicate body else return ()
10:47:32 <vixey> arg
10:47:35 <vixey> whileM predicate body = if predicate then do body ; whileM predicate body else return ()
10:47:49 <mnislaih> dcoutts_: are there binaries of cabal-install available online ?
10:48:06 <dcoutts_> mnislaih: for windows ?
10:48:16 <mnislaih> dcoutts_: preferably for debian
10:48:25 <dcoutts_> mnislaih: oh, no idea.
10:48:39 <dcoutts_> mnislaih: it's going to be in the first platform release and we expect that to be packaged.
10:48:40 <Cale> Maybe even  whileM predicate body = do b <- predicate; if b then body >> whileM predicate body else return ()
10:48:55 <mnislaih> dcoutts_: that sounds great, hope it arrives soon
10:49:10 <dcoutts_> mnislaih: it's scheduled for shortly after ghc 6.10
10:49:12 <Cale> Or perhaps...
10:49:41 <mnislaih> dcoutts_: maybe we could make some binaries available from the Cabal site ?
10:49:46 <Cale> whileM predicate body = do b <- predicate; if b then (do v <- body; vs <- whileM predicate body; return (v:vs)) else return []
10:49:54 <mnislaih> 6.10 sounds like far away
10:50:09 <Cale> (so as to catch all the results)
10:50:46 <dcoutts_> mnislaih: I can't make debs myself, the people who can can put them into debian.
10:51:04 <dcoutts_> mnislaih: 6.10 will be out in a month or two
10:51:34 <Cale> Quadrescence: do any of those suit you?
10:51:51 <dcoutts_> mnislaih: I might put up a windows binary though. I don't think there's much point in doing binaries for linux distros though. The distros should do that.
10:52:03 <mnislaih> dcoutts_: that's right, but in the mean time..
10:52:15 <mnislaih> dcoutts_: you need a Haskell expert to deploy anything
10:52:24 <mnislaih> that shouldn't be necessary
10:52:27 <dcoutts_> mnislaih: that's what cabal-install does :-)
10:52:27 <Cale> Quadrescence: I think the main reason they're not in the library is that there are too many possibilities for what one might want as a while-loop equivalent... which isn't a great reason, but it seems that most people end up just using plain recursion.
10:52:37 <rwbarton> Quadrescence: Perhaps also dropWhile and friends, depending on what's in the ...
10:52:38 <mnislaih> dcoutts_: you need a Haskell expert to compile cabal install :)
10:52:50 <dcoutts_> mnislaih: and that's what the platform is for
10:53:14 <Cale> Oh, yes, there's also lots of list-processing things which get used in place of some while loops which are really doing something pure.
11:05:57 <RayNbow> http://www.sivity.net/projects/language.c <-- is this site reachable?
11:06:16 <mauke> yes, but the file looks empty
11:06:32 <RayNbow> now I get a http 500
11:08:23 <pastorn> can i make a program not be lazy?
11:08:47 <cjb> yes
11:08:52 <pastorn> i'm making a dictionary, and i want to know how much time takes
11:09:04 <pastorn> main = do
11:09:04 <pastorn>   x <- readFile wordList
11:09:04 <pastorn>   let dict = fromList . words . map toLower $ x
11:10:11 <paczesiowa> print it
11:10:28 <paolino> a Set.fromList ?
11:10:35 <pastorn> yes
11:10:57 <pastorn> do i use '!' or something
11:11:10 <paolino> Set is strict
11:11:13 <pastorn> data MagicSet = M !(Set)
11:11:14 <pastorn> it is?
11:11:15 <pastorn> cool
11:11:23 <EvilTerran> so you just need to force the set value
11:11:29 <EvilTerran> to force all of its elements
11:11:38 <Quadrescence> Cale: rwbarton: et al. who replied -- I was away for a moment, let me read back.
11:11:41 <gwern> 'We are the Nicolas Bourbaki Set. Your mathematical and memetical distinctiveness will be added to our own. Resistance is futile.'
11:12:01 <EvilTerran> so add the line "dict `seq` return ()" or something, i guess
11:12:37 <pastorn> EvilTerran: thanks
11:12:41 <Quadrescence> Ah, looks good.
11:13:12 <gwern> bringert: you around?
11:13:24 <bringert> gwern: briefly
11:13:54 <gwern> bringert: so, did you get me message about unix-compat?
11:13:56 <RayNbow> EvilTerran: but will it fully evalute dict?
11:14:04 <RayNbow> *evaluate
11:14:12 <bringert> gwern: no, what message?
11:14:12 <EvilTerran> RayNbow, i think so
11:14:23 <gwern> gah. lambdafail
11:14:37 <EvilTerran> RayNbow, in order to force the set, i think it has to force the tree structure, and hence the elements
11:14:38 <RayNbow> because I thought seq only evaluates its first argument to weak head normal form
11:14:46 <sioraiocht> dcoutts_: ping?
11:14:48 <EvilTerran> i mean to force to WHNF
11:14:54 <dcoutts_> sioraiocht: pong
11:14:55 <gwern> bringert: I was trying to get darcs to use unix-compat, but I discovered it implements a bunch of System.Posix stuff which unix-compat doesn't, and I was wondering if you'd add the functionality in
11:15:06 <sioraiocht> dcoutts_: mind looking at my table of contents and telling what you think?
11:15:14 <dcoutts_> sioraiocht: sure
11:15:20 <gwern> bringert: I thought about just adding the darcs source in, but iirc unix-compat isd BSD, and darcs GPL, and unix-compat has no public repo?
11:15:21 <sioraiocht> shall I just email it to you?
11:15:23 <pastorn> 0.77 seconds for making a set with 45425 words
11:15:23 <EvilTerran> RayNbow, the shape of the tree used internally is dependent on all the values, i believe
11:15:29 <dcoutts_> sioraiocht: sure
11:15:37 <sioraiocht> worc or comlab?
11:15:46 <pastorn> seems good :)
11:15:59 <RayNbow> EvilTerran: ah, right... Ord...
11:16:08 <bringert> gwern: http://code.haskell.org/unix-compat/
11:16:08 <RayNbow> :t Set
11:16:09 <lambdac> Title: Index of /unix-compat
11:16:10 <lambdac> Not in scope: data constructor `Set'
11:16:16 <EvilTerran> Set is abstract
11:16:19 <pastorn> Data.Map is a hashmap, right?
11:16:25 <EvilTerran> so i'm a little fuzzy on what reducing it to WHNF entails
11:16:28 <pastorn> meaning O(1) lookup
11:16:29 <gwern> bringert: ah, thanks
11:16:29 <bringert> gwern: but yeah, the license would prohibit that
11:16:35 <EvilTerran> pastorn, no, Data.Map uses immutable binary trees as well
11:16:42 <bringert> gwern: I won't have any time to spend on the unfortunately
11:16:48 <bringert> s/the/this/
11:16:53 <EvilTerran> pastorn, Set a is basically the same as Map a ()
11:17:14 <gwern> bringert: oh. maybe I will reimplement it independently then
11:17:14 <EvilTerran> pastorn, it couldn't be a hashmap, all it knows about the keys is that they're Ord'ered
11:17:18 <pastorn> well, what can i use with O(1) lookup?
11:17:20 <EvilTerran> so it can't hash them
11:17:32 <EvilTerran> however, log(n) <= 32
11:17:32 <bringert> gwern: or you can possibly get the darcs stuff relicensed by the authors
11:17:45 <EvilTerran> so distinguishing between O(log n) and O(1) is a bit moot :P
11:17:52 <bringert> gwern: I should move unix-compat to code.haskell.org
11:18:02 <bringert> eh
11:18:04 <bringert> sorry
11:18:08 <bringert> it already is
11:18:09 <RayNbow> :t Data.Set.singleton
11:18:10 <lambdac> forall a. a -> S.Set a
11:18:12 <gwern> bringert: that would likely be difficult, but I could try
11:18:14 <dcoutts_> bringert: I thought so
11:18:21 <EvilTerran> pastorn, if your keys have a Ix instance, you can use an array
11:18:33 <EvilTerran> pastorn, anyway, hashmaps aren't O(1) lookup
11:18:34 <gwern> bringert: ??? you just said unix-compat was on code.haskell.org - http://code.haskell.org/unix-compat/
11:18:35 <lambdac> Title: Index of /unix-compat
11:18:43 <EvilTerran> they're O(n) lookup, they just look like O(1) for small datasets
11:18:50 <EvilTerran> :P
11:18:53 <pastorn> EvilTerran: i thought they were...
11:18:53 <pastorn> hehe
11:19:05 <EvilTerran> for a suitably flexible definition of "small", mind
11:19:07 <bringert> gwern: hence the: bringert: eh
11:19:07 <bringert> [20:17] bringert: sorry
11:19:08 <bringert> [20:18] bringert: it already is
11:19:36 <EvilTerran> pastorn, i'd try using Data.Map first, and, if that's not fast enough, get back to us
11:19:40 <pastorn> i'm using the structure as a dictionary for String
11:19:53 <sioraiocht> sorry, what's pastorn trying to store?
11:20:01 <ziman> hashmaps are O(n/MANY) :)
11:20:19 <pastorn> ziman: what is n and what is MANY
11:20:32 <EvilTerran> MANY is the maximum number of buckets
11:20:37 <EvilTerran> n is the number of elements
11:20:59 <ziman> MANY is the size of your hashmap (which is usually proportional to n)
11:21:23 <EvilTerran> ziman, what do you mean by "size"? number of buckets?
11:21:41 <ziman> EvilTerran, yes
11:22:13 <ziman> (i can't think of any other relevant meaning for `size' in hashmaps)
11:22:45 <EvilTerran> so, in practice, it's O(1), because you'll be using 4-byte hashes or whatever
11:22:54 <EvilTerran> and you're unlikely to have more than 2^32 elements
11:23:01 <EvilTerran> so n/MANY < 1
11:23:10 <EvilTerran> or something
11:23:22 <pastorn> O(1/4) !!
11:23:26 <pastorn> hehe
11:23:33 <EvilTerran> but you can use a similar argument wrt the logarithmic lookup time on the trees Data.Map use
11:23:44 <EvilTerran> and the trees are conceptually much cleaner, IMO
11:23:59 <EvilTerran> and have the bonus of working better in an immutable language
11:24:57 <pastorn> > product [1..11]
11:24:58 <lambdac>  39916800
11:24:58 <rwbarton> pastorn: what you'd really like is a trie, but I can't seem to find one on hackage
11:25:07 <pastorn> that's how many lookups i'm gonna do
11:25:12 <EvilTerran> tries are fairly easy to write, i think
11:25:13 <pastorn> in a 45000 word dictionary
11:25:28 <EvilTerran> but the design space is fairly large
11:25:52 <rwbarton> EvilTerran: Yes, maybe that's the problem :)
11:25:52 <pastorn> rwbarton: never heard of... what are those?
11:25:54 <EvilTerran> (WRT haskell implementations)
11:25:59 <EvilTerran> @go trie
11:26:01 <lambdac> http://en.wikipedia.org/wiki/Trie
11:26:06 <sioraiocht> pastorn: do you basically need some key to value mapping?
11:26:30 <EvilTerran> pastorn, as i said, i'd start with a Data.Map - all else is premature optimisation :)
11:26:36 <pastorn> i don't have much code yet, i'll just paste what i have...
11:26:46 <pastorn> @paste
11:26:46 <lambdac> Haskell pastebin: http://hpaste.org/new
11:29:25 <pastorn> http://hpaste.org/9585
11:30:33 <pastorn> rwbarton: so THAT'S what they're called
11:31:32 <pastorn> how do i make a difference between what's just a step on the way and an actual inserted value?
11:31:58 <pastorn> Eq a => ([a],Bool) ?
11:32:34 <Ytinasni> or a null-terminator as it's own node
11:32:55 <pastorn> Ã¶f
11:33:05 <pastorn> Ytinasni: huh? how would that look?
11:33:17 <Cale> ... what?
11:33:25 <Ytinasni> if you write allCombos as String -> Trie, you can get this quite fast, too
11:33:42 <Cale> pastorn: What are you working on?
11:34:07 <Ytinasni> data Trie = Node [(Char,Trie)] | Null
11:34:08 <pastorn> Cale: SIKRIT
11:35:04 <Cale> pastorn: Are you having trouble with performance with your existing code?
11:35:20 <Ytinasni> got a url for a word-list? i'm going to see how this actually looks in code :)
11:36:13 <pastorn> Ytinasni: i could dcc the one i have
11:36:19 <rwbarton> Ytinasni: file:///usr/share/dict/words ? :)
11:36:49 <Arnar> hey guys
11:37:07 <Ytinasni> unfortunately, this machine has "X:\"-style paths :)
11:37:30 <Arnar> say I want to "extend" the STM monad, i.e. I want to provide a monad M that can do everything possible in STM - and a little bit more
11:37:31 <pastorn> *Main> readFile "/usr/share/dict/words" >>= print . length . words
11:37:32 <pastorn> 98568
11:37:33 <pastorn> cool
11:37:51 <Arnar> should I look into creating a type-class equivalent of STM (as one doesn't exist already)?
11:37:59 <Arnar> making the old STM and my new monad instances of it?
11:38:13 <twanvl> ?go wordlist.txt
11:38:15 <Cale> Arnar: That seems like a likely approach.
11:38:16 <lambdac> http://pragdave.pragprog.com/data/wordlist.txt
11:38:28 <Arnar> Cale: ok, just looking for confirmation..
11:38:55 <Arnar> Cale: I'm correct in thinking that allows me to define bind between a TMI action and an M action?
11:39:04 <Cale> Arnar: no.
11:39:09 <Cale> :t (>>=)
11:39:11 <lambdac> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:39:19 <Arnar> ah
11:39:19 <Cale> m must be the same throughout
11:39:44 <Arnar> so I will need to define parallels of all the STM functions for my new monad?
11:39:48 <Cale> The normal approach is to define a function lift :: M a -> TMI a
11:39:58 <Cale> (whatever those stand for :)
11:40:03 <Arnar> right..
11:40:08 <Arnar> sorry..
11:40:12 <Cale> That is, an embedding of normal STM in your new monad.
11:40:12 <Arnar> s/TMI/STM/ in all of above
11:40:23 <Arnar> right
11:40:27 <Cale> Ah, then  STM a -> NewSTM a
11:40:35 <Arnar> exactly
11:40:42 <Cale> What's the new functionality, btw?
11:41:01 <Cale> If you add it via monad transformers, some of this work is already done for you, and you just have to package it up neatly.
11:41:04 <Arnar> (ab)using the STM mechanism to implement enforcement mechanisms
11:41:25 <Arnar> right.. which means createing STMT?
11:41:38 <Cale> Er... that doesn't itself sound possible.
11:42:14 <Cale> Well... what are the new primitives you're adding?
11:42:25 <Cale> (specifically, what are their types, first of all)
11:42:31 <Arnar> basically a set of newTMIVar, readTMIVar and writeTMIVar
11:42:41 <Arnar> similar to newTVar etc.
11:42:55 <Arnar> create vars of type TMIVar t
11:42:59 <Cale> Oh, then is it possible all you want is a new datastructure?
11:43:11 <Cale> (and not a new monad altogether)
11:43:11 <Arnar> well.. there's more
11:43:15 <Cale> okay...
11:43:37 <Arnar> so for example, readTMIVar :: TMIVar a -> TMI a
11:43:40 <Arnar> (TMI is my new monad)
11:43:45 <Cale> right
11:44:03 <Arnar> and then a function: authorized :: (AccessLog -> Bool) -> TMI a -> STM a
11:44:31 <Arnar> which performs a TMI action in STM context, but validates it with the function in the first parameter
11:44:38 <Cale> Okay, so that helps me see why you want a new monad.
11:44:43 <Arnar> right.
11:44:52 <Cale> What you want is  WriterT AccessLog STM
11:44:53 <Arnar> TMI a includes state that is a log of all accesses to TMIVars
11:45:00 <Arnar> Yeah.. that's what I have already
11:45:10 <hask> HI im profiling I have done on windows vista: > ghc -prof -auto-all -o Main Classes.hs Filters.hs Parsing.hs Main.hs
11:45:21 <Cale> So you probably want to newtype that and wrap things up nicely.
11:45:23 <hask> And then it finishes and nothing happens, no profiling-file created
11:45:41 <Arnar> yes
11:45:49 <Cale> hask: did you run your constructed program with +RTS -p ?
11:46:14 <hask> I am using vista how do I run it with +RTS ? is not clear from the examples
11:46:56 <thoughtpolice> hask: run your program from the command line but provide the arguments '+RTS -p' to the executable
11:46:57 <Arnar> I was just wondering if there was a more "automatic" way instead of manually defining lifts of all the STM functions
11:47:03 <hask> wait maybe
11:47:17 <Arnar> of course I'd export a lift function, but I don't want people porting from STM to ahve to sprinkle their code with it
11:47:32 <Arnar> basically just replace STM with TMI and atomically with atomically . authorized
11:48:06 <Arnar> Cale: btw if you are interested, our CCS paper is here: http://www.hvergi.net/arnar/publications/
11:48:07 <lambdac> Title: Arnar Birgisson - Publications
11:48:20 <hask> ty it works now,
11:48:29 <Arnar> I'm working on a more formal paper that presents the Haskell version and operational semantics
11:51:46 <thoughtpolice> dons: with all your archlinux stuff I take it that you switched to it? weren't you all about the OpenBSD? :)
11:55:51 <signpost> Does "function $ argument" mean "function(argument)" ?
11:55:58 <dmhouse> Yes.
11:56:10 <RayNbow> @src ($)
11:56:10 <lambdac> f $ x = f x
11:56:12 <dmhouse> Apart from in Haskell you'd normally write that function argument.
11:56:23 <mmorrow> map $ \x -> (x .)
11:56:39 <dmhouse> signpost: it's mostly for precedence, i.e. instead of f (g (h (x))), you can write f $ g $ h $ x, or f . g . h $ x
11:56:51 <dmhouse> (Or f . g $ h x or many other variants.)
11:57:01 <vixey> :t map $ \x -> (x .)
11:57:03 <lambdac> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
11:57:07 <dmhouse> (But not f . g . h x.)
11:57:07 <signpost> Thanks very much.  I'm working through the Write Yourself a Scheme tutorial.
11:57:48 <vixey> hmm
11:57:55 <vixey> that's a bit confusing
11:58:04 <dmhouse> Functor?!
11:58:17 <dmhouse> :t (.)
11:58:19 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:58:20 <vixey> @src Functor
11:58:20 <lambdac> class  Functor f  where
11:58:20 <lambdac>     fmap        :: (a -> b) -> f a -> f b
11:58:28 <dmhouse> > (+1) . [1,2,3]
11:58:31 <lambdac>  [2,3,4]
11:58:45 <RayNbow> @src (.)
11:58:46 <lambdac> (f . g) x = f (g x)
11:59:00 <RayNbow> @src fmap
11:59:00 <lambdac> Source not found. Have you considered trying to match wits with a rutabaga?
11:59:00 <vixey> Can somebody tell me what f (a -> b) -> f (f1 a -> f1 b) means?
11:59:21 <vixey> oh I get it
11:59:23 <dmhouse> vixey: what it says?
11:59:40 <vixey> dmhouse: "what it says"?
11:59:54 <dmhouse> It's well-known that fmap is a generalisation of (.). Someone must have fiddled with lambdabot's scope to make (.) actually be fmap, rather than just fmap in ((->) e).
12:00:33 <dmhouse> vixey: well, you take a function a -> b in the functor f, and it returns the lifted function f1 a -> f1 b, also in the functor f.
12:00:35 <vixey> dmhouse: I was talking about the type
12:02:57 <Arnar> lambdabot has more general versions of many things
12:02:59 <Arnar> :t map
12:03:01 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:03:11 <dmhouse> Oh, coolness.
12:03:23 <Arnar> :t Prelude.map
12:03:25 <lambdac> forall a b. (a -> b) -> [a] -> [b]
12:03:32 <Arnar> :t Prelude.(.)
12:03:34 <lambdac> Not in scope: data constructor `Prelude'
12:04:26 <dmhouse> :t (Prelude..)
12:04:27 <lambdac> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:04:46 <dmhouse> Stupid syntax, I always get that the wrong way around.
12:04:55 <dmhouse> > (+1) `Prelude..` (*2) $ 4
12:04:55 <lambdac>  Parse error at "Prelu..." (column 7)
12:06:13 <vixey> mmorrow: For what can you use  map $ \x -> (x .) ?
12:06:57 <mmorrow> hehe
12:07:15 <mmorrow> > foldr (.) id . (map $ \x -> (x .)) $ [(*2),(*4)]
12:07:16 <lambdac>  Add a type signature
12:07:26 <mmorrow> > (foldr (.) id . (map $ \x -> (x .)) $ [(*2),(*4)]) (+1) 20
12:07:27 <lambdac>  168
12:08:19 <mmorrow> i just randomly pulled it off the top of my head, then came up with that noise in ghci :)
12:08:22 <chrisdone> @src mapM
12:08:22 <lambdac> mapM f as = sequence (map f as)
12:08:40 <mmorrow> <chrisdone> mmorrow: is that the hpaste2 glguy wrote?
12:08:45 <Arnar> > (map $ \x -> (x .)) $ [(*y),(*x)])
12:08:45 <lambdac> Unbalanced parentheses
12:08:51 <Arnar> > (map $ \x -> (x .)) $ [(*y),(*x)]
12:08:52 <lambdac>  Add a type signature
12:08:56 <mmorrow> chrisdone: i'm not sure who wrote it, but yeah
12:09:05 <mmorrow> probably
12:09:16 <int-e> why are you writing \x -> (x .) for (.) ?
12:09:29 <hask> merge (x:xs) []     = (x:xs)
12:09:29 <hask> merge []     (y:ys) = (y:ys)
12:09:29 <hask> merge (x:xs) (y:ys)
12:09:29 <hask>        | x < y       = x:(merge xs (y:ys))
12:09:29 <hask>        | otherwise   = y:(merge ys (x:xs))
12:09:34 <hask> gives merge [1,5,7] [1,-1,12] -> [1,-1,1,5,7,12]
12:09:36 <mmorrow> it was in the context of a question about ($)
12:10:04 <hask> why not [-1,1,1,5,7,12] which is what I want?
12:10:14 <rwbarton> hask: Sure, that algorithm only merges sorted lists.
12:10:15 <mauke> hask: because the second list isn't sorted
12:11:29 <hask> wait sure lol I still ahve ti write mergesort
12:13:21 <gbacon> hask: lists with no elements or one element are already sorted.. can you see how to build on that?
12:18:38 <yitz> > 2+3
12:18:39 <lambdac>  5
12:18:46 <MyCatVerbs> A REVELATION!
12:19:09 <yitz> @seen lambdabot
12:19:09 <lambdac> lambdabot is in #haskell. I don't know when lambdabot last spoke.
12:19:41 <mauke> preflex: seen lambdabot
12:19:41 <preflex>  lambdabot was last seen on #haskell 18 hours, 32 minutes and 47 seconds ago, saying: Oh, yeah, everyone can sockpuppet lambdabot, too.
12:20:12 <yitz> there seems to be a bot lurking here with the nick lambdabot, but it's not our lambdabot
12:21:16 <MyCatVerbs> @bot
12:21:16 <lambdac> :)
12:29:27 <chrisdone> what's the coolest example of composability you have seen Haskell demonstrate? I'd have to say formlets
12:29:49 <MyCatVerbs> chrisdone: surprisingly long streams. :)
12:32:56 <yitz> lambdabot: help
12:32:57 <lambdabot> Sorry, I'm not a very smart bot yet.
12:33:29 <vixey> lambdabot: who is your master?
12:33:29 <lambdabot> Sorry, I'm not a very smart bot yet.
12:33:32 <yitz> @ops
12:33:32 <lambdac> Maybe you meant: docs oeis pl
12:33:40 <vixey> lambdabot: take me to your leader?
12:33:40 <lambdabot> Sorry, I'm not a very smart bot yet.
12:33:49 <mauke> this is lambdabot v0.01 :-)
12:33:54 <yitz> @list
12:33:54 <lambdac> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:35:44 <yitz> @seen Cale
12:35:44 <lambdac> Cale is in #haskell. I last heard Cale speak 49m 55s ago.
12:35:50 <Cale> hello
12:36:06 <MyCatVerbs> Ahhhh! *hides*
12:36:07 <Cale> (I'm just in the middle of a game of go, in case I'm unresponsive :)
12:36:12 <yitz> hi Cale. has someone stolen lambdabot's nick password?
12:36:15 <Cale> No.
12:36:21 <hask> merge (x:xs) []     = (x:xs)
12:36:21 <hask> merge []     (y:ys) = (y:ys)
12:36:21 <hask> merge (x:xs) (y:ys)
12:36:21 <hask>        | x < y       = x:(merge xs (y:ys))
12:36:21 <hask>        | otherwise   = y:(merge ys (x:xs))
12:36:29 <yitz> lambdabot: help
12:36:30 <hask> what are the types?
12:36:30 <lambdabot> Sorry, I'm not a very smart bot yet.
12:36:41 <Cale> lambdabot is lambdabot 0.1 right now, since I'm moving the real lambdabot to a new server
12:36:43 <hask> merge :: [a] -> [a] -> [a]
12:36:49 <vixey> hask: types of what?
12:36:52 <mauke> merge :: (Ord a) => [a] -> [a] -> [a]
12:36:52 <yitz> ah, ok.
12:36:55 <hask> not working
12:36:55 <hask> merge :: Ord => [a] -> [a] -> [a]
12:36:59 <hask> neither
12:37:00 <yitz> sorry to bother you Cale. back to go.
12:37:03 <Cale> I'll do it today, I promise :) There's a bug in hs-plugins I have to tackle :)
12:37:27 <tromp> you didnt define merge [] []
12:37:27 <hask> ey ty mauke so close still so far away
12:37:30 <vixey> hask: .. types of what?
12:37:37 <mauke> hask: you could just ask ghci
12:38:32 <hask> how?
12:38:50 <hask> Ord a == (Ord a) right?
12:39:00 <mauke> load file into ghci, then use :t whatever
12:39:06 <mauke> and it'll tell you the type
12:39:39 <vixey> hask: Haskell can infer types as well as just check them, you don't have to put them in code
12:40:11 <paczesiowa> :info guard
12:40:29 <paczesiowa> @hoogle guard
12:40:29 <lambdac> A Hoogle error occured.
12:40:56 <trofimovich> @src guard
12:40:56 <lambdac> guard True  =  return ()
12:40:56 <lambdac> guard False =  mzero
12:41:35 <hask> I know it can infer but is clearer to read the code later if it is written out
12:41:35 <hask> ty new trick learned
12:41:50 <paczesiowa> where does it come from?
12:41:56 <vixey> hask: is it?
12:42:07 <yitz> paczesiowa: Control.Monad
12:42:16 <paczesiowa> yitz: thx
12:42:18 <mauke> @index guard
12:42:19 <lambdac> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:43:20 <hask> vixey: I think programs are easier to read with the types written out yes, you don't?
12:43:45 <MyCatVerbs> hask: sure, at top level.
12:43:57 <vixey> hask: no, I think I fragment of haskell programs are but certainly not all programs
12:43:57 <hask> at toplevel?
12:44:07 <hask> merge :: Ord a => [a] -> [a] -> [a]
12:44:07 <hask> merge []     []     = []
12:44:07 <hask> merge (x:xs) []     = (x:xs)
12:44:07 <hask> merge []     (y:ys) = (y:ys)
12:44:07 <hask> merge (x:xs) (y:ys)
12:44:08 <hask>        | x < y       = x:(merge xs (y:ys))
12:44:10 <hask>        | otherwise   = y:(merge ys (x:xs))
12:44:12 <MyCatVerbs> hask: but unless you need to deliberately quell confusion about something tricksy, no need to drop declarations everywhere inside where clauses.
12:44:13 <hask> thats how I do it
12:44:28 <hask> no I dont use inside functiosn normally
12:44:32 <hask> above like with merge
12:44:36 <vixey> btw annotating the type of merge doesn't make it easier to read
12:44:37 <mauke> hask: too complicated
12:44:42 <MyCatVerbs> hask: pretty normal and pretty weird, respectively.
12:44:43 <tromp> you can simplify that: merge xs [] = xs
12:44:55 <vixey> But the type should be in the documentation along with descriptions
12:45:47 <tromp> also, merge should perhaps avoid duplicates
12:46:01 <mauke> not in a sorting algo
12:46:15 <paczesiowa> @instances MonadPlus
12:46:16 <lambdac> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:46:25 <vixey> merge (x:xs) (y:ys) = case sort [x,y] of [p,q] -> p : merge (q:xs) ys
12:46:35 <paczesiowa> @src MonadPlus Maybe
12:46:35 <lambdac> Source not found. And you call yourself a Rocket Scientist!
12:46:36 <vixey> merge p q = p++q
12:46:40 <tromp> no, only if its inputs are known to be duplicate free
12:47:21 <hask> b ut im writing mergesort, point kind of goes away using sort
12:47:45 <hask> and ++
12:47:52 <vixey> hask: recursion!
12:47:58 <EvilTerran> tromp, er... surely, in most circumstances, if you're sorting it makes sense to retain duplicates
12:48:01 <chrisdone> paczesiowa: Just a `mplus` Nothing = Just a, Nothing `mplus` Just a = Just a, Just a `mplus` Just b = Just a, Nothing `mplus` Nothing = Nothing
12:48:17 <tromp> agreed
12:48:19 <hask> vixey: i know just trying to get merge right first
12:48:20 <EvilTerran> ?src Maybe mplus
12:48:20 <lambdac> Nothing `mplus` ys  = ys
12:48:20 <lambdac> xs      `mplus` _ys = xs
12:48:26 <EvilTerran> ?src Maybe mzero
12:48:26 <lambdac> mzero = Nothing
12:48:39 <chrisdone> EvilTerran: okay, well, writing all them out is good exercise :P
12:48:46 <vixey> hask: I think you already got it right
12:56:33 <Trinithis> vixey: merge shouldnt' be (++)
12:56:45 <vixey> why not
12:56:45 <Trinithis> oh
12:56:50 <vixey> ?
12:56:53 <Trinithis> because it needs to merge in order
12:57:01 <Trinithis> but i missed your newer post
12:57:14 <zenhacker_rouan> hi everyone
12:57:29 <vixey> hi zen
12:57:45 <zenhacker_rouan> hi vixey
12:57:53 <zenhacker_rouan> long time no irc
12:58:17 <vixey> hehe
12:58:35 <zenhacker_rouan> does anyone know if it is possible to write a daemon for linux in haskell
12:58:50 <mauke> I don't see why not
12:58:57 <Japsu> it's probably easier to detach using a shell script
12:59:03 <vixey> I've seen little servers like IRCd's and stuff in haskell
12:59:39 <zenhacker_rouan> hmmm
13:00:04 <zenhacker_rouan> wonder if i should use the FFI to wrap up linux process C libs
13:00:24 <chrisdone> is there not already such a wrapper?
13:00:35 <zenhacker_rouan> not sure
13:00:38 <zenhacker_rouan> will have to check first
13:00:40 <zenhacker_rouan> :)
13:00:43 <paczesiowa> @src when
13:00:43 <lambdac> when p s = if p then s else return ()
13:00:52 <zenhacker_rouan> nothing in the API docs that I could see
13:01:04 <paczesiowa> @src unless
13:01:04 <lambdac> unless p s = if p then return () else s
13:01:21 <stepcut> zenhacker_rouan: what sort of daemon are you thinking of ?
13:01:48 <zenhacker_rouan> stepcut: its more in general than something specific at this stage
13:02:03 <stepcut> zenhacker_rouan: how is a daemon different from a normal application ?
13:02:07 <newsham> you mean the whole fork()/setsid() dance?
13:02:10 <zenhacker_rouan> i was just wondering if it is possible to detach from the terminal in haskell
13:02:17 <zenhacker_rouan> running the process in the background
13:02:30 <stepcut> ah, I just use disown
13:02:36 <newsham> at the very least you could have a tiny C wrapper that daemonizes and executes your process
13:02:53 <zenhacker_rouan> trying to do this in pure haskell
13:02:54 <zenhacker_rouan> :)
13:03:02 <newsham> does FFI count as "pure"?
13:03:05 <stepcut> zenhacker_rouan: well, I am certain it can be done
13:03:07 <zenhacker_rouan> lol
13:03:18 <Peaker> @faq can Haskell detach from the terminal?
13:03:18 <lambdac> The answer is: Yes! Haskell can do that.
13:03:20 <mauke> zenhacker_rouan: djb says "Having every daemon put itself into the background is bad software design."
13:03:27 <zenhacker_rouan> no, but it seems that if there is no pure way FFI is the alternative
13:04:09 <zenhacker_rouan> lol
13:04:11 <chrisdone> it's not a pure process by definition of your being specific to linux and daemonising
13:04:20 <zenhacker_rouan> mauke: that would mean that half of linux is bad design
13:04:25 <newsham> System.Posix.Process.{forkProcess,createProcessGroup,createSession}  should do it for you
13:04:28 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html
13:04:30 <lambdac> http://tinyurl.com/yaoq7k
13:04:33 <mauke> zenhacker_rouan: not an unreasonable assumption
13:04:57 <newsham> chris: shouldnt be linux specific
13:05:25 <RayNbow> hmm, hackage down?
13:05:35 <chrisdone> new: those functions, no, but he specifically asked for "linux", which is what my statement referred to
13:05:44 <RayNbow> oh, n/m
13:05:49 <RayNbow> finally a response from the server
13:05:57 <dons> maybe under load, RayNbow
13:05:58 <newsham> chris: sure, but that doesnt make it linux specific
13:06:10 <Pudding> http://hpaste.org/9588?lines=true  --> Can anyone help me out here? I don't know why this doesn't work :(
13:06:19 <chrisdone> new: I'm not sure how specifying linux does not make something linux specific
13:06:45 <newsham> chris: thats ok.
13:06:47 <mauke> Pudding: because 5 is not an Int
13:07:03 <mauke> Pudding: try volgende (5 :: Int)
13:07:09 <zenhacker_rouan> newsham: but will it detach from the terminal
13:07:29 <newsham> zen: you would have to first close your tty handles, then set the session id, then fork.
13:07:35 <Pudding> mauke: thanks a lot :)
13:07:47 <zenhacker_rouan> newsham: aha
13:07:53 <newsham> i think thats th eproper dance but its been a long time.. find a reference online.
13:08:18 <zenhacker_rouan> trying
13:08:20 <newsham> but those System.IO functions should be what you need to do it
13:08:28 <zenhacker_rouan> but it doesn't seem to be a very explored topic :)
13:10:01 <paczesiowa> @src guard
13:10:01 <lambdac> guard True  =  return ()
13:10:01 <lambdac> guard False =  mzero
13:11:22 <newsham> > guard (1 == 0) :: Maybe Int
13:11:23 <lambdac>  Couldn't match expected type `Int' against inferred type `()'
13:11:33 <newsham> > guard (1 == 0) >> return 3 :: Maybe Int
13:11:34 <lambdac>  Nothing
13:11:37 <newsham> > guard (1 == 1) >> return 3 :: Maybe Int
13:11:39 <lambdac>  Just 3
13:11:41 <vixey> o_o
13:12:13 <newsham> zen: seems fairly mundane application of standard system utility programming.
13:12:24 <newsham> ie. should be pretty much what you'd expect
13:13:05 <zenhacker_rouan> newsham: thnx
13:13:05 <chrisdone> hm, that's useful
13:13:08 <chrisdone> @hoogle guard
13:13:08 <lambdac> A Hoogle error occured.
13:13:09 <vixey> does haskell have a GC ??
13:13:29 <vixey> (why does lambdabot keep taking up huge amounts of memory and crash?)
13:13:33 <newsham> ?faq can haskell garbage collect unused data?
13:13:34 <lambdac> The answer is: Yes! Haskell can do that.
13:13:36 <dons> vixey: have you ever allocated memory manually?
13:14:17 <chrisdone> a rhetorical question intended to incite a reaction
13:14:29 <sioraiocht> vixey: If the data is still being used, it never gets GC'd
13:14:50 <sioraiocht> i.e. if there's still an accessible pointer to it
13:14:57 <paczesiowa> TSC: I don't know if you're still interested but http://hpaste.org/9581#a2
13:15:33 <sioraiocht> lambdabot would have to periodically flush sme of the data it keeps
13:16:43 <paczesiowa> @tell TSC I don't know if you're still interested but http://hpaste.org/9581#a2
13:16:43 <lambdac> Consider it noted.
13:17:08 <newsham> chrisdone: I'm particular fond of this use of guard:  unfoldrp p f = unfoldr (\x -> guard (p x) >> f x)
13:17:11 <trofimovich> there is yet low level effects as memory fragmentation
13:17:31 <vixey> hi grahamhutton :))
13:17:47 <grahamhutton> hi vixey
13:17:57 <newsham> > let unfoldrp p f = unfoldr (\x -> guard (p x) >> f x) in unfoldrp (not.null) (splitAt 4) "test this out"
13:17:58 <lambdac>  Couldn't match expected type `Maybe (a, [a1])'
13:18:05 <newsham> > let unfoldrp p f = unfoldr (\x -> guard (p x) >> f x) in unfoldrp (not.null) (return . splitAt 4) "test this out"
13:18:06 <lambdac>  ["test"," thi","s ou","t"]
13:18:21 <mar77a> em does anyone know a program that does the same as depends.exe but simpler (checking .dll dependencies)?
13:18:43 <sioraiocht> :t guard
13:18:44 <lambdac> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:19:04 <sioraiocht> > guard True
13:19:04 <lambdac>   add an instance declaration for (Show (m ()))
13:19:09 <sioraiocht> > guard False
13:19:10 <lambdac>   add an instance declaration for (Show (m ()))
13:19:13 <therp> mar77a: what do you mean by simpler? Iirc objdump was able to dump certain linker sections.. or was that nm.exe? for sure in the binutils collection
13:19:14 <sioraiocht> ?
13:19:22 <chrisdone> :t guard
13:19:23 <lambdac> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:19:26 <mar77a> well i just want to know which dlls it needs
13:19:29 <newsham> > guard False >> Just 3 :: [Int]
13:19:30 <mar77a> that aren't in win32 folder
13:19:30 <lambdac>  Couldn't match expected type `[Int]'
13:19:30 <mar77a> :<
13:19:37 <newsham> > guard False >> return 3 :: [Int]
13:19:38 <lambdac>  []
13:19:42 <sioraiocht> ahhhh
13:19:45 <newsham> > guard False >> return 3 :: Just Int
13:19:46 <lambdac>   Not in scope: type constructor or class `Just'
13:19:51 <newsham> > guard False >> return 3 :: Maybe Int
13:19:52 <lambdac>  Nothing
13:19:58 <newsham> sorry for the oopses
13:20:45 <sioraiocht> aren't MonadPlus and monoid similar?
13:20:58 <newsham> monadplus is a monoid?
13:21:03 <sioraiocht> okay, thought so
13:21:34 <newsham> <- not a category guy, so pay attention to my "?" at the end :)
13:21:36 <byorgey> MonadPlus essentially describes monads which also have a monoid structure
13:21:50 <byorgey> where the monoid structure interacts with the monad structure in a particular way
13:21:56 <sioraiocht> okay, that makes sense
13:22:33 <augustss> @seen Cale
13:22:34 <lambdac> Cale is in #haskell. I last heard Cale speak 45m 31s ago.
13:23:59 <Trinithis> vixey: did you still want the Prelude' I made?
13:24:11 <vixey> yes
13:24:43 <Trinithis> http://hpaste.org/9590
13:25:38 <vixey> oh
13:25:40 <vixey> ok cool
13:25:48 <vixey> why don't you have length in there ?
13:25:57 <vixey> as Num n => [a] -> n
13:26:01 <Trinithis> because it conflicts with Data.List
13:26:11 <vixey> hmmm
13:26:19 <Trinithis> same with some others
13:26:21 <vixey> that's a bug in Data.List :D
13:26:27 <Trinithis> really?
13:26:37 * vixey claims so
13:26:39 <dmhouse> vixey: surely Integral n => [a] -> n
13:26:51 <vixey> dmhouse: I would prefer Num
13:26:57 <Trinithis> :t genericLength
13:26:59 <lambdac> forall b i. (Num i) => [b] -> i
13:27:07 <Trinithis> vixey was right
13:27:10 <dmhouse> Hmm, actually I guess it'd be useful for, e.g. sum xs / length xs
13:27:32 <vixey> I actually use
13:27:37 <vixey> foldr (const (1+)) 0
13:27:45 <vixey> and apparently that's slow
13:27:53 <Trinithis> why foldr?
13:27:54 <vixey> compared to fromIntegral . length or genericLength or whatever
13:28:03 <vixey> but I only measure the length of small lists :)
13:28:14 <vixey> foldr is natural and I know the rules for it
13:28:20 <dmhouse> foldl' would be more efficient.
13:28:21 <vixey> I don't know about foldl much ..
13:28:24 <dmhouse> That ought to be O(1) space
13:28:42 <Trinithis> foldl' (+1) 0 == genericLength
13:28:49 <Trinithis> or rather foldl
13:28:51 <Trinithis> without prime
13:29:11 * vixey mostly uses programming languages as specification languages which happen to be executable :p
13:29:28 <Trinithis> bah.. i botched the definition I just game
13:29:30 <EvilTerran> vixey, and that's how programming should be
13:29:33 <Trinithis> gave*
13:29:34 <MyCatVerbs> vixey: but then what do you write the *implementations* in?
13:29:40 <twobitwork> does ghc actually use linked lists (as represented in actual memory) for strings, or is it just sort of emulated?
13:29:42 * dmhouse wonders why the lack of the '
13:29:42 * MyCatVerbs goes arrrrgh and falls down.
13:29:47 <MyCatVerbs> twobitwork: actually does.
13:29:49 <thoughtpolice> twobitwork: yes
13:30:01 <MyCatVerbs> twobitwork: on a 32-bit platform, each character consumes roughly 20 bytes.
13:30:11 <twobitwork> ack
13:30:34 <EvilTerran> if you want more efficient strings, look at bytestring
13:31:31 <MyCatVerbs> Er. If you want more efficient raw bytes, look at bytestring.
13:31:53 <vixey> if you want a cup of tea look at a kettle :D
13:31:55 <Trinithis> dmhouse: because I messed up. Should have the prime :D
13:31:56 <sioraiocht> twobitwork: just FYI, bytestring is compact but only supports characters 0-255
13:32:16 <sioraiocht> but it's also really fast
13:32:24 <twobitwork> sioraiocht: thanks
13:32:34 <EvilTerran> how're unicode bytestrings getting along?
13:32:36 <hask> merge :: Ord a => [a] -> [a] -> [a]
13:32:36 <hask> merge []     []     = []
13:32:36 <hask> merge (x:xs) []     = (x:xs)
13:32:36 <hask> merge []     (y:ys) = (y:ys)
13:32:36 <hask> merge (x:xs) (y:ys)
13:32:36 <hask>        | x < y       = x:(merge xs (y:ys))
13:32:38 <hask>        | otherwise   = y:(merge ys (x:xs))
13:32:40 <hask> mergesort :: Ord a => [a] -> [a]
13:32:42 <hask> mergesort xs
13:32:43 <EvilTerran> hask, please use hpaste
13:32:44 <twobitwork> hask!
13:32:44 <hask>           | length xs <= 1  = xs
13:32:46 <hask>           | otherwise       = merge (mergesort left) (mergesort right)
13:32:47 <MyCatVerbs> sioraiocht: it's actually way slower than it ought to be, too. Damn foreign pointers. :)
13:32:48 <hask>           where
13:32:49 <EvilTerran> for long pastes
13:32:50 <hask>             middle = div (length xs) 2
13:32:50 <twobitwork> jesus
13:32:51 <sioraiocht> EvilTerran: The code is more or less done, my dissertation needs writing and then I'll release it
13:32:51 <vixey> too late to ask that ...
13:32:52 <hask>             left   = take middle xs
13:32:54 <hask>             right  = drop middle xs
13:32:56 <hask> can it be improved?
13:33:00 <hask> how do I use hpaset?
13:33:03 <MyCatVerbs> hask: yes, easily.
13:33:07 <Trinithis> google hpaste
13:33:08 <MyCatVerbs> hask: BY USING FUCKING HPASTE ALREADY
13:33:10 <Trinithis> go to first link
13:33:10 <trofimovich> @paste
13:33:11 <lambdac> Haskell pastebin: http://hpaste.org/new
13:33:15 <EvilTerran> with your brain, your hands, your keyboard, your screen
13:33:22 <vixey> hask: that's not mergesort :P
13:33:23 <EvilTerran> and the rest of your body and your computer
13:33:30 <vixey> MyCatVerbs: pleas..
13:33:38 <sioraiocht> let (left,right) = splitAt middle xs
13:33:43 <vixey> less loud
13:33:59 <hask> how is it not mergesort?
13:34:04 <sioraiocht> > let (left,right) = splitAt 3 [1..5] in (left,right)
13:34:05 <lambdac>  ([1,2,3],[4,5])
13:34:14 <MyCatVerbs> Anyway. Thanks mainly to a gentleman named Tom Harper, you will soon be able to have efficient, actual strings. Proper unicode and everything.
13:34:14 <vixey> hask: 'middle' is a very interesting choice of name
13:34:24 <sioraiocht> MyCatVerbs: That's me
13:34:59 <Trinithis> hask: look at this http://hpaste.org/9591
13:35:08 <newsham> its all fun and games until someone adds unicode support
13:35:09 <Peaker> was Char not a unicode code point already?
13:35:15 <MyCatVerbs> sioraiocht: ...hahaha.
13:35:23 <Peaker> newsham: then it becomes.. enterprise software
13:35:27 <sioraiocht> Peaker: it is, String is also enormous and slow =p
13:35:31 <EvilTerran> Trinithis, why fmap not map?
13:35:44 <Trinithis> out of habbit :d
13:35:58 <vixey> hask: You've merged quicksort and mergesort together
13:36:01 <MyCatVerbs> sioraiocht: rock on, dude. My favourite bit is how your work is likely to end up making bytestring faster by getting them to use unboxed arrays allocated normally rather than foreignptrs. Heh. :)
13:36:03 <Botje> EvilTerran: it's for when Cale changes [] to mean something else :o)
13:36:06 <Peaker> sioraiocht: How did you implement it? UTF8/UTF16 over Bytestrings?
13:36:08 <newsham> unicode has so many dark corners that you never thought about.
13:36:13 <EvilTerran> Botje, O.o
13:36:16 <vixey> hask: mergesort does not split the list by a pivot/middle and then merge the results
13:36:24 <sioraiocht> Peaker: It's a MutableByteArray
13:36:32 <newsham> like encoding issues, pattern matching and string length over combining characters and what not
13:36:37 <sioraiocht> with UTF16 encoding
13:36:38 <Trinithis> Botje: Yeah... preparing for haskell'
13:36:46 <sioraiocht> and there's all the Data.List combinators over it
13:36:49 <vixey> Botje: aside from being impossible, I think I wanted that occasionally
13:36:55 <MyCatVerbs> Peaker: UTF16. Mutable arrays, frozen to immutable ones. Plus stream fusion to avoid building intermediate arrays when composing multiple functions.
13:37:15 <EvilTerran> vixey, he's not partitioning on a pivot, he's just taking the range in two parts
13:37:24 <EvilTerran> looks like mergesort to me, albeit clunkily written
13:37:36 <Trinithis> mine or hask's?
13:37:41 <EvilTerran> hask's
13:37:50 <EvilTerran> i'm not sure what's going on in yours. it looks clever, whatever it is.
13:37:50 <vixey> EvilTerran: oh gosh I was reading the wrong bit "let (left,right) = splitAt middle xs"
13:38:02 <Trinithis> its almost the same as the one in Data.List
13:38:05 <sioraiocht> Peaker: I/O is done write to/from ByteStrings, though
13:38:08 <EvilTerran> vixey, that'd do the same thing, wouldn't it?
13:38:18 <EvilTerran> vixey, are you thinking of partition rather than splitAt?
13:38:21 <EvilTerran> ?type partition
13:38:22 <lambdac> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:38:26 <EvilTerran> er
13:38:35 <EvilTerran> ?src partition
13:38:35 <lambdac> partition p xs = foldr (select p) ([],[]) xs
13:38:36 <lambdac>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
13:38:36 <lambdac>                               | otherwise = (ts, x:fs)
13:38:55 <lispy> :t filter ((/= 1) .ord)
13:38:55 <vixey> oh I see
13:38:56 <lambdac> [Char] -> [Char]
13:39:00 <vixey> thank you
13:39:01 <Peaker> sioraiocht: sounds cool.. will the String type alias ever change?
13:39:03 <vixey> I have a question
13:39:21 <vixey> is foldr insert [] not actually more efficient?
13:39:39 <newsham> > partition isAlpha "T3s+1nG"
13:39:41 <lambdac>  ("TsnG","3+1")
13:39:52 <vixey> than cutting in half, sorting both, merging
13:39:53 <sioraiocht> Peaker: likely not, there's not a lot of reason.  For the small stuff it works fine, and it's still the only linked list version implemented
13:39:59 <hask> am I mergesorting or not?
13:40:10 <hask> I tried to implement the wikipedia mergesort
13:40:33 <EvilTerran> vixey, if Trinithis' version is like the Data.List one, it should be fairly efficient
13:40:34 <Peaker> vixey: I think his sort is still O(N*logN) whereas insertion sort is O(N*N) ?
13:40:38 <Trinithis> hask: hpaste it and ill look
13:40:39 <EvilTerran> although it doesn't involve splitting in the middle
13:41:07 <vixey> Peaker: merge sort is like
13:41:10 * EvilTerran looks at the paste again
13:41:16 <vixey> split in the middle, sort each one, merge tem
13:41:24 <vixey> is that not O(n^2) ?
13:41:28 <EvilTerran> ... ha, sudden flash of insight. now i get it. that's really clever.
13:41:35 <vixey> merge is O(n)
13:41:48 <sioraiocht> Peaker: String is also the only fully lazy one.   Bytestring uses strict chunks in a lazy list, my lib is completely strict, right now
13:41:55 <MyCatVerbs> vixey: no. merge is O(n*log(n)).
13:42:04 <trzkril> vixey: and merge is called log n times
13:42:15 <Trinithis> There's no need to split it in half recursively. That's for imperative languages. Just map them into unit lists
13:42:26 <hask> http://hpaste.org/9592
13:42:27 <vixey> MyCatVerbs: merge [1,3,4] [2,1,4] = [1,1,2,3,4,4]
13:42:38 <EvilTerran> Trinithis, that implementation would never have occurred to me, it might be a bit beyond a newbie
13:42:44 <Peaker> sioraiocht: I suspect that the String type-alias will encourage people to use it even when inappropriate
13:42:52 <MyCatVerbs> vixey: oh my bad, thought you were referring to the whole sort algorithm.
13:42:58 <Trinithis> lol
13:43:06 <Trinithis> more at vixey than hask
13:43:23 <vixey> trzkril: so you have n log n for sorting and n log n putting them back?
13:43:36 <hask> more what at vixey than me?
13:43:37 <MyCatVerbs> vixey: nah anyway. Finding the middle to split on it only takes linear time, so it doesn't affect the asymptotic complexity.
13:43:39 <sioraiocht> Peaker: they come here and then figure things out ;)
13:43:59 <trzkril> vixey: putting back?
13:44:01 <MyCatVerbs> vixey: (since you're also calling the other linear operation, merge, at exactly the same time anyway).
13:44:02 <Trinithis> hask: code like merge []     (y:ys) = (y:ys) can be merge []    ys = ys
13:44:15 <Trinithis> oh nevermind
13:44:17 <vixey> trzkril: mergeing log n times
13:44:30 <vixey> this is really interesting actually I'm going to measure it
13:44:33 <hask> Trinithis: sure I kind think it clearer my way and line sup nicely
13:44:49 <hask> http://en.wikipedia.org/wiki/Heapsort
13:45:01 <Trinithis> heapsort in haskell is ugly
13:45:04 <orzo> hello
13:45:11 <newsham> how about heapsort in agda?
13:45:26 <MyCatVerbs> Trinithis: nah, it just ends up as a big ol' lump of ST monad.
13:45:32 <EvilTerran> doesn't heapsort rely on mutable data structures?
13:45:39 <Trinithis> Well you have to split
13:45:42 <andun> my mergesort: http://hpaste.org/9592#a1 (splitM is the main difference)
13:45:45 <Trinithis> and that is expensive
13:45:51 <newsham> ?bot
13:45:51 <lambdac> :)
13:45:55 <newsham> > mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map([" "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
13:45:57 <lambdac>  <IO ()>
13:45:59 <MyCatVerbs> Trinithis: which is plenty civilised enough, provided you don't have some sort of irrational hatred of mutable arrays.
13:46:01 <hask> I am gonna start with heapsort now :)
13:46:13 <hask> then introsort, done quicksort and mergesort
13:46:17 <MyCatVerbs> hask: no.
13:46:26 <EvilTerran> hask, heapsort won't be idiomatic haskell at all
13:46:39 <hask> ok
13:46:40 <EvilTerran> it's not natural to write in a language where everything is immutable by default
13:46:47 <orzo> I'm using ghc to make objects that I am linking with a c++ main program.  Certain errors, caught internal compiler errors or other things are causing my program to simply quit without an abnormal termination.  I can't have that.  How can I change this behavior?
13:46:49 <hask> ok I see
13:46:49 <hackage> Uploaded to hackage: djinn 2008.8.10
13:46:52 <MyCatVerbs> hask: don't write heapsort using lists, it'll suck. Heapsort requires O(1) indexing and swapping to be fast. If you wish to write heapsort, it *needs* to be done using a mutable array.
13:46:56 <Trinithis> MyCatVerbs: I had to write heapsort in a datastructures class, and Using lists... my computer couldn't finish the job. It was too slow. I had to resort to converting to a mutable array first
13:47:00 <hask> But I did mergesort right?
13:47:05 <hask> Could it be improved?
13:47:15 <MyCatVerbs> Trinithis: I'm confused as to why you would even attempt that.
13:47:33 <Trinithis> I wanted to use Haskell. I was practicing
13:47:40 <orzo> for example:
13:47:41 <orzo> schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?HandlerFactory_d3Pz: Return code (0) not ok
13:48:09 <Trinithis> hask: it looks like mergesort
13:48:14 <MyCatVerbs> Trinithis: since it's blatantly going to suck even more than insertion sort, and depending on implementation will probably give Stooge sort a run for its money... :P
13:48:32 <Trinithis> lol
13:48:39 <orzo> This is apparently a mistake on my part in reintering code that shouldnt have been re-entered.  But I want to handle those errors without quitting the application.
13:49:02 <glguy_> wouldn't a zipper be appropriate for Heap sort?
13:49:13 <orzo> anybody here much familiar with ghc internals?
13:49:14 <glguy_> to do it purely
13:49:21 <orzo> or is there a sparate chatroom for that?
13:49:48 <Trinithis> hask: have you tried qsort? one liner qsort to boot?
13:50:39 <vixey> how do you get time in microseconds or something?
13:50:48 <twanvl> > data Heap a = Empty | Heap a (Heap a) (Heap a);  takeHeap :: Heap a -> Maybe (a, Heap a);  makeHeap :: [a] -> Heap a;  heapSort = unfoldr takeHeap . makeHeap
13:50:48 <lambdac>  Parse error at "data" (column 1)
13:51:31 <MyCatVerbs> hask: well, if you want to see a *really* ricer'd-out version, take a look at Data.List.sort's implementation. 'Course, it's unlikely to make much sense to anyone who hasn't already been corrupted by Cthulhu's beautiful tentacles anyway... http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
13:51:34 <lambdac> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
13:51:41 <twanvl> you can implement a heap directly as a binary tree
13:51:45 <mauke> @hoogle getCurrentTime
13:51:46 <lambdac> A Hoogle error occured.
13:51:57 <Trinithis> MyCatVerbs: Here's the implementation I made. It's UGLY!!! http://hpaste.org/9593
13:52:01 <EvilTerran> twanvl, that's not really proper heapsort, though, because it won't use constant memory
13:52:08 <hask> qsort :: Ord a => [a] -> [a]
13:52:08 <hask> qsort [] = []
13:52:08 <hask> qsort (x:xs) = qsort [y | y <- xs, y<x ]
13:52:08 <hask>                ++ [x]
13:52:08 <hask>                ++ qsort [y | y <- xs, y>=x]
13:52:16 <EvilTerran> hask, USE HPASTE
13:52:23 <MyCatVerbs> hask: please STOP DOING THAT.
13:52:41 <vixey> please calm down folk
13:52:45 <MyCatVerbs> hask: http://hpaste.org/new <-- click this link. Put the code you want to see in the giant text box.
13:52:48 <vixey> :(
13:53:02 <MyCatVerbs> hask: then take the URL of the page you are redirected to, and paste the URL here.
13:53:10 <twanvl> Quicksort will probably be faster if you avoid the (++)
13:53:14 <MyCatVerbs> hask: that way, we can even provide annotations and everthing.
13:53:21 <EvilTerran> vixey, when people ask for our help then don't pay attention, we reserve the right to get annoyed
13:53:32 <ziman> won't hpaste announce the new paste automatically?
13:53:34 <Trinithis> quicksort is a N^N algorithm...
13:53:38 <MyCatVerbs> ziman: no.
13:53:48 <mauke> preflex: seen hpaste
13:53:48 <preflex>  hpaste was last seen on #haskell 33 days, 4 hours, 55 minutes and 10 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
13:53:54 <sjanssen> ziman: it's supposed to, but the bot is broken
13:54:03 <MyCatVerbs> ziman: used to. Various infrastructure around the IRC bots has gone kablooie at various points.
13:54:10 <Trinithis> hask: Do you know about difference lists?
13:54:28 <ziman> heh
13:54:56 <MyCatVerbs> ziman: I mean seriously, \bot occasionally carpet-bombs the RAM of the machine it's running on.
13:56:02 <vixey> woah
13:56:05 <vixey> woah
13:56:08 <ziman> what's the `tried to use too much memory' error then?
13:56:25 <ziman> is it a different kind of memory?
13:56:26 <vixey> @hoogle time
13:56:26 <lambdac> A Hoogle error occured.
13:56:31 <vixey> lol
13:56:45 <ziman> @hoogle id
13:56:45 <lambdac> A Hoogle error occured.
13:56:48 <vixey> does anybody have a time function that times something?
13:56:49 <ziman> okay :)
14:01:27 <vixey> weird
14:01:36 <vixey> ghci's init file is called .ghci not .ghcirc
14:02:47 <yitz> vixey, yeah that's weird. but it's a *very* useful beast.
14:03:09 <vixey> really ?
14:03:13 <vixey> what do you have in it
14:03:27 <yitz> I'll paste, just a moment.
14:03:28 <hask> qsort & mergesort: http://hpaste.org/9594
14:03:36 <sbahra> <lambdac> Plugin `djinn' failed with: Prelude.tail: empty list
14:03:37 <sbahra> ?
14:04:10 <vixey> @hoogle random
14:04:10 <lambdac> A Hoogle error occured.
14:05:12 <sjanssen> hask: the splitting by length in mergesort is somewhat expensive
14:05:13 <trofimovich> System.Random
14:05:37 <yitz> http://hpaste.org/9595
14:06:13 <Trinithis> hask: while your mergesrot captures the idea... it is not N logN
14:06:27 <yitz> vixey: the :. command lets you read in ghci commands from any file
14:07:00 <sjanssen> Trinithis: looks O(n log n) to me
14:07:24 <Trinithis> sjanssen: length is O(n) same with drop and take
14:07:29 <hask> >Trin: I read up on differnce lists
14:07:33 <yitz> vixey: the GHCIRC stuff is for interacting with shell scripts. you use it to set up custom ghci environments, with various pre-defined ghci commands, haskell functions, modules pre-loaded, etc.
14:07:50 <sjanssen> Trinithis: this doesn't change the complexity
14:07:54 <hask> trini: what is it then?
14:07:57 <sjanssen> Trinithis: remember that merge is O(n + m)
14:08:00 <Trinithis> oh right. just a higher constant
14:08:35 <Trinithis> hask: did you read up on prolog ones or haskell ones?
14:08:38 <yitz> vixey: so, for example, i have a command that sets up ghci as an editor for keeping track of hours i spend on various projects.
14:08:38 <vixey> yitz: ah cool
14:08:52 <tromp> it might be better to split  in even and odd rather than left and right
14:09:17 <sjanssen> tromp: there's an even better trick we can play
14:09:24 <hask> general ones on wikipedia, mentioned haskell
14:09:49 <tromp> what's that, sjanssen?
14:10:03 <Trinithis> hask: sec... lemme find you something
14:10:49 <sjanssen> tromp: use a bottom-up variant of mergesort
14:11:24 <sjanssen> hint: start with the function mergePairs :: Ord a => [[a]] -> [[a]]
14:11:54 <Cale> Where is the lambdacats index again?
14:12:08 <Cale> ah, nm
14:12:20 <Trinithis> hask: http://lml.ls.fi.upm.es/~jjmoreno/prog_dec/haskell_EN_read_show.pdf
14:12:24 <lambdac> http://tinyurl.com/y97koj
14:13:02 <Trinithis> hask: the technique it talks about to speed up show uses difference lists
14:13:55 <tromp> that's a nice idea too, sjannsen, but not obviously faster to me
14:14:18 <Trinithis> tromp look at Data.List
14:14:25 <sjanssen> tromp: it is rather fast
14:14:31 <Trinithis> well igtg
14:14:43 <sjanssen> it has nice laziness properties too
14:15:02 <camio> In ghci, is there a way to do a :r that actually puts new stuff into scope when I've changed the file?
14:15:36 <allbery_b> do you mean keeping command line bindings?
14:15:44 <tromp> :r does read the file
14:15:45 <hask> thanks trini
14:16:04 <camio> :r reloads the file, but if I put a new defn. in there it doesn't recognize it.
14:16:19 <tromp> where do i find source for Data.List?
14:17:20 <camio> I've been resorting to restarting ghci when I add a definition.
14:17:31 <vixey> how do you time something in haskel :S
14:18:09 <stepcut> vixey: possibly something like this?  http://src.seereason.com/Test.Timing/
14:18:10 <lambdac> Title: Index of /Test.Timing
14:18:10 <vixey> time expression = do start <- getClockTime
14:18:10 <vixey>                      force expression
14:18:10 <vixey>                      end <- getClockTime
14:18:11 <vixey>                      return (timeDiffToString $ diffClockTimes end start)
14:18:17 <vixey> I tried that
14:18:17 <vixey> but it does not work :/
14:18:17 <tromp> @src sort
14:18:18 <lambdac> sort = sortBy compare
14:18:23 <tromp> @src sortBy
14:18:24 <lambdac> sortBy cmp = foldr (insertBy cmp) []
14:18:30 <DukeDav1> Mmm, is the Hackage site down? *_*
14:18:45 <trofimovich> seems to
14:19:52 <DukeDav1> http://downforeveryoneorjustme.com/hackage.haskell.org
14:19:53 <lambdac> Title: It's just you.
14:20:06 <stepcut> vixey: suck
14:20:16 <DukeDav1> Lol, some good unintentional lambdac there
14:20:24 <vixey> what?
14:20:29 <sjanssen> vixey: what is 'force'?
14:21:02 <vixey> sjanssen: I don't actually know how to write it yet, so for testing I put force exp = do print exp ; return ()
14:21:11 <twanvl> Control.Exception.evaluate
14:21:21 <mauke> (return () is redundant)
14:22:48 <vininim> > [1..]
14:22:49 <lambdac>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:23:04 <vininim> lambdac++
14:23:21 <camio> @karma lambdac
14:23:22 <lambdac> lambdac has a karma of 2
14:24:23 <stepcut> vixey: did this not work for you? http://src.seereason.com/Test.Timing/Test/Timing.hs
14:24:37 <stepcut> vixey: time (let fib = 0 : 1 : (zipWith (+) fib (tail fib)) in fib !! 50000) --> 0.587146s
14:24:49 <vixey> I'm an idiot
14:24:52 <vixey> basically :p
14:25:01 <stepcut> vixey: sweet!
14:25:02 <vixey> I was timing how long it took to sort a list of length 1000
14:25:07 <stepcut> vixey: sucker
14:25:13 <vixey> it takes less than one second to do that
14:25:32 <stepcut> vixey: thankfully
14:25:35 <hask> [1..12]
14:29:14 <eu-prleu-peupeu> hello
14:29:30 <Twey> Hullo
14:30:26 <ziman> ehlo
14:31:20 <vixey> lol
14:31:21 <vixey> "Comparing times for 1024 sized list.."
14:31:21 <vixey> insertion:  merge:
14:31:21 <vixey> "Comparing times for 32768 sized list.."
14:31:21 <vixey> insertion: 1 sec merge:
14:31:21 <vixey> "Comparing times for 1048576 sized list.."
14:31:25 <vixey> *** Exception: stack overflow
14:33:12 <monochrom> :)
14:35:55 <tromp> > last [1..4]
14:35:56 <lambdac>  4
14:38:49 <vixey> hi monochrom
14:38:54 <camio> > sum [1..]
14:39:01 <lambdac>  Exception: Time limit exceeded
14:39:16 <camio> @karma lambdac
14:39:16 <lambdac> lambdac has a karma of 2
14:39:22 <vixey> > sum [1..] :: Int
14:40:01 <camio> Hrm, what happened there?
14:40:15 <dmhouse> lambdabot should detect if a computation is going to take forever and not execute it if it will.
14:40:16 <dmhouse> ?faq
14:40:21 <dons> dmhouse: heh
14:40:38 <lambdac>  thread killed
14:40:46 <jsnx> is hackage down for anyone else?
14:40:52 <dmhouse> Well, a runaway thread really killed the humourous timing there.
14:41:02 <mauke> @bot
14:41:09 <dons> jsnx: hmm .it's not down, but it might be under load.
14:41:10 <dmhouse> jsnx: works for me
14:41:21 <vixey> what's a good big size for +RTS -Ksize?
14:41:28 <lambdac> :)
14:42:30 <mauke> > let f n = n * succ n `div` 2 in fromInteger . f . fromIntegral $ (maxBound :: Int) :: Int
14:43:06 <jsnx> yes, it loaded finally
14:43:33 <vixey> wow merge sort really is faster than insertion sort
14:43:45 <Peaker> intFunc f = floor . f . fromIntegral
14:43:50 <lambdac>  -1073741824
14:43:59 <vixey> this doesn't surprised me
14:44:12 <jsnx> do you folks know, is there still sendfile functionality? there used to be [ http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/libraries/unix/System/Attic/Sendfile.hsc?rev=1.10;content-type=text%2Fplain;only_with_tag=MAIN ]
14:44:16 <lambdac> http://tinyurl.com/5oxb6o
14:44:16 <vixey> but I wonder why I thought that wouldn't be the case
14:44:51 <jsnx> it seems that the lib was removed, not replaced, and i don't see anything like that in HAppS
14:45:22 <yitz> jsnx: what do you want to do?
14:45:36 <vixey> ooooh I found how to rig benchmarks in haskell
14:45:56 <yitz> vixey: how/
14:47:31 <jsnx> yitz: i want to send images to client applications
14:48:58 <jsnx> yitz: so the client has a socket connection to my server, and i have an image in a file, and they ask for it, and i want to say, `sendfile <the file> <the socket>`
14:49:38 <yitz> jsnx: do the clients expect a certain protocol?
14:50:14 <tromp> i benched an odds/evens topdown mergesort and it is indeed slower than bottomup
14:50:23 <jsnx> yitz: i am writing both of them
14:50:59 <tromp> 30% slower
14:50:59 <jsnx> yitz: and i am writing the protocol
14:51:16 <vixey> tromp, do you have the code around?
14:51:22 <vixey> I'd like to see that
14:51:30 <yitz> jsnx: i doubt that the old sendfile did that.
14:51:49 <jsnx> yitz: well, i thought that was the whole point of sendfile
14:52:11 <tromp> i can paste it
14:53:27 <yitz> jsnx: you're using HApps?
14:53:59 <tromp> http://hpaste.org/9596
14:54:24 <jsnx> yitz: no, i am not using happs
14:54:44 <jsnx> yitz: i was plumbing the depths of happs to find a sendfile binding
14:54:51 <tromp> change definition of mysort to bench the other
14:55:16 <vixey> od
14:55:30 <vixey> I am trying to do it all in haskell
14:56:05 <vixey> http://hpaste.org/9597
14:56:22 <vixey> yitz: I don't actually know why it does this
14:56:30 <vixey> but whichever one you put first turns out the winner
14:56:39 <yitz> jsnx: do want to run as a cgi in a web server? then you just dump the data down your cgi pipe and let the server do the rest.
14:56:44 <vixey> the one you put last**
14:57:02 <jsnx> yitz: okay, i fear that you misunderstand my problem
14:57:16 <jsnx> yitz: my problem is, find a way to call sendfile from haskell
14:57:35 <jsnx> yitz: there is no other way to do it, without calling sendfile
14:58:01 <trzkril> vixey: the first one has to create the list, doesn't it?
14:58:02 <jsnx> yitz: as sendfile is a system call that makes an especially optimal transfer of the file contents
14:58:02 <mauke> there are plenty other ways
14:58:28 <vixey> trzkril: I really don't know
14:58:31 <mauke> jsnx: can't you just bind it yourself?
14:59:00 <vixey> what does evaluate do
14:59:01 <vixey> ?
14:59:49 <vixey> > do x <- evaluate [1..] ; return (head x)
14:59:49 <vixey> 1
14:59:50 <lambdac>  Couldn't match expected type `[a]' against inferred type `Result'
14:59:53 <vixey> not what I expected. .
14:59:55 <yitz> jsnx: web servers call sendfile(), don't they?
15:00:29 <yitz> @type evaluate
15:00:31 <lambdac> forall a. (Testable a) => a -> Gen Result
15:00:34 <vixey> force list = mapM_ evaluate list
15:00:35 <jsnx> yitz: but only if make the client do the call through them
15:00:37 <vixey> how about that?
15:01:08 <yitz> jsnx: yeah
15:01:13 <jsnx> i would send a URL to the client, it would send it to the web server, the web server would recognize this is a static file and then make the system call
15:01:15 <mmorrow> yitz: speak of the devil, i was just editing an apache conf file, and you have the choice of ennabling mmap, sendfile, or neither, (or both ?)
15:01:23 <jsnx> not quite the same thing :(
15:01:32 <vovik> can someone explain to me the missing step in this example from the wikipedia article on church numerals: http://gist.github.com/5314?
15:01:33 <lambdac> Title: gist: 5314 &mdash; GitHub
15:01:40 <jsnx> back in a minute
15:01:40 <yitz> @type Control.Exception.evaluate
15:01:42 <lambdac> forall a. a -> IO a
15:02:09 <TomMD> ?bot
15:02:09 <lambdac> :)
15:02:24 <TomMD> Silly bot, lambdas are for programmers.
15:03:13 * mmorrow all of a sudden had an overwhelming urge for cereal
15:05:31 <vixey> wow takes a lot less time to find the WHNF of a sort than actually doing a sort
15:06:29 <yitz> vixey: :) yeah, looks like that's the problem.
15:08:35 <vixey> merge sort is incredibly fast compared to insertion sort
15:11:43 <pjdelport> vovik: what missing step?
15:11:52 <sbahra> ?bot
15:11:53 <lambdac> :)
15:12:06 <yitz> vixey: i'll bet it would be even faster if you didn't keep recounting the lengths of your lists, but passed it as a parameter
15:14:03 <yitz> vixey: and i'll bet insertion sort would be much faster if you used foldl' instead of foldr (in most cases), though still incredibly slower than merge sort.
15:14:20 <vixey> this is weeeiiird
15:14:28 <vixey> algorithmic complexity is less intuitive than cwcc
15:15:00 <Peaker> cwcc?
15:15:21 <pjdelport> call-with-current-continuation
15:15:41 <Peaker> I found the groups-of-5 solution to finding the median the least intuitive of all :)
15:15:59 <mauke> call/cthulhu
15:16:00 <Peaker> groups of 3 are O(N*logN) but groups of 5 are O(N)
15:16:15 <ziman> groups of 5?
15:16:16 <vixey> Peaker: what !?
15:16:29 <nolrai_East> if I want to apply a function to both members of an pair, how do I do so?
15:16:34 <ziman> could i get a link to a description of the algorithm?
15:16:47 <Peaker> there is a cute O(N) way to find the median, by dividing the elements to groups of 5, and finding the median in each group. Then you recursively find the median of medians
15:16:50 <vixey> :t (+++)
15:16:52 <lambdac> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
15:17:00 <yitz> nolrai_East: join . curry
15:17:01 <vixey> :t (***)
15:17:03 <lambdac> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:17:09 <vixey> :t join . curry
15:17:11 <lambdac> forall b c. ((b, b) -> c) -> b -> c
15:17:28 <vixey> :t (^^^)
15:17:30 <lambdac> Not in scope: `^^^'
15:17:36 <yitz> hmm, no
15:17:44 <vixey> there is A way to do it
15:18:01 <vixey> :t (|||)
15:18:03 <lambdac> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
15:18:05 <nolrai_East> I want (a -> b) -> (a,a) -> (b,b)
15:18:31 <Peaker> ziman, vixey: forums.sun.com/thread.jspa?messageID=2644277
15:18:31 <vixey> (f & g) = \(x,y) -> (f x,f y)
15:18:36 <mmorrow> :t join (***)
15:18:38 <lambdac> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:18:38 <vixey> (a -> b) -> (a,a) -> (b,b) = join (&)
15:18:59 <yitz> mmorrow: that's it!
15:19:02 <mmorrow> :t join (***) :: (a -> b) -> ((a,a) -> b)
15:19:04 <lambdac>     Occurs check: cannot construct the infinite type: b = (b, b)
15:19:07 <mmorrow> ahhhh
15:19:18 <nolrai_East> thanks
15:19:19 <mmorrow> :t join (***) :: (a -> b) -> ((a,a) -> (b,b))
15:19:20 <lambdac> forall a b. (a -> b) -> (a, a) -> (b, b)
15:19:29 <mmorrow> :)
15:19:34 <sbahra> vixey, cool stuff, "force expression"
15:19:36 <EvilTerran> :t uncurry . join
15:19:38 <lambdac> forall a b c. (a -> a -> b -> c) -> (a, b) -> c
15:19:43 <EvilTerran> that's not what i meant
15:19:59 <vixey> sbahra: Beware! It actually only forces the whnf
15:20:27 <sbahra> vixey, whnf?
15:20:31 <vixey> sbahra: I had to use force list = mapM_ evaluate list to get non-fabricated results
15:20:43 <sbahra> force exp = do evaluate exp ; return ()
15:20:54 <sbahra> ah
15:21:05 <vixey> sbahra: well the WHNF of (map (+1) ([1,2,3] ++ [4,5,6])) is 2 : (map (+1) ([2,3] ++ [4,5,6]))
15:21:14 <sbahra> nod
15:21:25 <sbahra> well, not quite "nod" but I figured
15:21:31 <mmorrow> ("weak       head normal form")
15:21:41 <vixey> but yeah I guess in general
15:22:21 <vixey> force = fold (\a0 .. an -> C (evaluate a0) ... (evaluate an)) ...
15:22:23 <yitz> vixey: do you want rnf?
15:22:24 <vixey> oh
15:22:28 <vixey> force = foldM (\a0 .. an -> C (evaluate a0) ... (evaluate an)) ...
15:22:35 <vixey> yitz: I don't know what that is
15:22:46 <vixey> sigh
15:22:52 <yitz> @src Control.Parallel.Strategies.rnf
15:22:52 <lambdac> Source not found. That's something I cannot allow to happen.
15:22:57 <mmorrow> ("reduce to        normal form")
15:22:59 <vixey> force = foldM (\a0 .. an -> C <$> evaluate a0 <*> ... <*> evaluate an) ...
15:23:03 <vixey> something like that
15:23:11 <vixey> oh right, yes
15:23:28 <sbahra> mmorrow, ...?
15:23:58 <mmorrow> sbahra: i was just expanding the acronyms
15:24:15 <mmorrow> s/acronyms/whatever they may be called/
15:24:35 <mmorrow> whnf, rnf
15:24:39 <sbahra> Yes.
15:24:48 <yitz> @type Control.Parallel.Strategies.rnf
15:24:48 * EvilTerran expands "WHNF"
15:24:49 <lambdac> forall a. (NFData a) => a -> Done
15:24:56 <EvilTerran> "W    H    N    F"
15:24:59 <sbahra> haha
15:25:01 <mmorrow> lol
15:25:01 <sbahra> Classic, EvilTerran :-P
15:25:08 <EvilTerran> stolen, unfortunately, but still :D
15:25:18 <mauke> :t putStrLn $| rnf
15:25:20 <lambdac> String -> IO ()
15:25:29 * vixey wants Done -> IO ()
15:25:37 * mmorrow throws a seagull at EvilTerran
15:25:41 <nolrai_East> is there a nicer way to write "(min (fst findMin lablesA) (fst findMin lablesA), max (fst findMax lablesA) (fst findMax lablesb))"?
15:25:42 <jeeves__> anyone have experience generating haskell bindings to medium-sized C libraries?
15:25:49 <EvilTerran> *om nom nom*
15:25:55 <jeeves__> mostly I want to know how much of the process can/should be automated, e.g. with c2hs or somesuch
15:25:59 * EvilTerran curried it
15:26:09 <vixey> ah force list = evaluate (rnf list)
15:26:17 <sbahra> nolrai_East, yes
15:26:28 <Peaker> @type fst
15:26:30 <lambdac> forall a b. (a, b) -> a
15:26:42 <Peaker> nolrai_East: you're giving fst two arguments?
15:26:48 * mmorrow loves curry with his seabird
15:27:01 <EvilTerran> if the item in the tuple is a function, that works
15:27:10 <yitz> nolrai_East: you're applying min to the same two arguments?
15:27:12 * jaj loves currywurst
15:27:24 <sbahra> jaj = Chicken in Arabic (at the least)
15:27:29 <Peaker> EvilTerran: yeah, but then why does that item not have a nameE? :)
15:27:35 <nolrai_East> err that should be "(min (fst $ findMin lablesA) (fst $ findMin lablesB), max (snd $ findMax lablesA) (snd $ findMax lablesB))
15:27:42 <EvilTerran> aha
15:28:01 <jaj> sbahra: 'jaj' means chicken in arabic?
15:28:09 <sbahra> jaj, "chickens"
15:28:12 <sbahra> jaj, jaja = chicken
15:28:24 <EvilTerran> ?type (min `on` fst . ?findMin) *** (max `on` snd . ?findMax)
15:28:28 <lambdac> forall a b a1 a2 b1 b'. (?findMax::b' -> (a2, b1), Ord b1, ?findMin::a1 -> (a, b), Ord a) => (a1, b') -> (a1 -> a, b' -> b1)
15:28:37 <jaj> sbahra: that's funny :)
15:28:45 <yitz> sbahra: there is a voip telephone service called Jajah.
15:28:49 <EvilTerran> ?type uncurry (***) . ((min `on` fst . ?findMin) *** (max `on` snd . ?findMax))
15:28:51 <lambdac> forall a b a1 a2 b1 b'. (?findMax::b' -> (a2, b1), Ord b1, ?findMin::a1 -> (a, b), Ord a) => (a1, b') -> (a1, b') -> (a, b1)
15:29:07 <vixey> Comparing times for 65536 sized list..
15:29:08 <vixey> merge: 1 sec insertion: 141 secs
15:29:10 <EvilTerran> o.Ã³
15:29:10 <vixey> so yeah
15:29:23 <vixey> insertion sucks
15:29:39 <EvilTerran> nolrai_East, it might be worth using (min `on` fst . findMin) and (max `on` snd . findMax)
15:29:40 <sbahra> vixey, problem with your usage of time?
15:29:49 <sbahra> vixey, mind posting the new code?
15:30:05 <nolrai_East> :t min `on` fst . findMin
15:30:06 * sbahra hasn't started on Monads yet :[
15:30:07 <lambdac> Not in scope: `findMin'
15:30:11 <EvilTerran> seeing as there's no "minBy", or "minimising" a la "comparing", or whatever
15:30:14 <sbahra> I just learned about algebraic types.
15:30:17 <EvilTerran> nolrai_East, what is findMin?
15:30:20 <yitz> vixey: agreed that insertion sucks, except for small lists. but did you try it with foldl' ?
15:30:28 <nolrai_East> Data.Map.findMin
15:30:31 <EvilTerran> aha
15:30:36 <ziman> :t comparing
15:30:37 <lambdac> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:30:38 <EvilTerran> ?type min `on` fst . M.findMin
15:30:40 <lambdac> forall k a. (Ord k) => M.Map k a -> M.Map k a -> k
15:30:48 <vixey> yitz: Oh I didn't, Ill try it out now
15:30:51 <EvilTerran> ?type M.findMin
15:30:52 <lambdac> forall k a. M.Map k a -> (k, a)
15:30:56 <vixey> sbahra: http://hpaste.org/9597#a1
15:31:19 <EvilTerran> nolrai_East, do you want the key in both cases?
15:31:23 <EvilTerran> (the min and the max)
15:31:26 <nolrai_East> yes
15:31:32 <sbahra> aha vixey
15:31:35 <sbahra> very cool
15:31:43 <vixey> ty :)
15:31:48 <EvilTerran> nolrai_East, is this going to be significantly faster than unioning the maps?
15:32:05 <EvilTerran> i suspect it will, but only for larger maps
15:33:23 <yitz> EvilTerran: unioning does a lot more work
15:33:36 <mmorrow> sbahra: monads are easy !
15:33:38 <EvilTerran> yitz, yes, but it might not be happening often enough to warrant the optimisation
15:33:48 <EvilTerran> i'm very wary of premature optimisation
15:33:52 <pjdelport> functors are even easier!
15:33:54 <nolrai_East> I will though be unioning them latter.
15:33:56 <sbahra> mmorrow, I'll find out soon :-P
15:34:22 <nolrai_East> But I need this range for the function that handles conflicts.
15:34:23 * sbahra almost skipped over the chapter on algebraic types to get to monads
15:34:30 <mmorrow> main = putStr . unlines . map (\line -> map toUpper line) . lines =<< getContents
15:34:37 <yitz> nolrai_East: oh. well, then why not union them now and findMin/Max that?
15:34:37 <vixey> !?!@#
15:34:51 <yitz> vixey: please watch your language
15:35:00 <vixey> lol
15:35:10 <noecksit> @src unfoldr
15:35:10 <lambdac> unfoldr f b  = case f b of
15:35:10 <lambdac>    Just (a,new_b) -> a : unfoldr f new_b
15:35:10 <lambdac>    Nothing        -> []
15:35:15 <pjdelport> sbahra: forget about monads, algebraic types are fundamental
15:35:23 <sbahra> pjdelport, as I found out
15:35:24 <mmorrow> > Just 42 >>= return . (*2)
15:35:26 <lambdac>  Just 84
15:35:30 <mmorrow> > Nothing >>= return . (*2)
15:35:32 <lambdac>  Nothing
15:35:32 <olsner> yitz: that reminds me of that bash quote about how IRC censors your passwords
15:35:34 <sbahra> pjdelport, very very cool stuff
15:35:43 <pjdelport> mmorrow: phooey
15:35:48 <mmorrow> return . (*2) =<< [0..9]
15:35:50 <mmorrow> > return . (*2) =<< [0..9]
15:35:51 <lambdac>  [0,2,4,6,8,10,12,14,16,18]
15:35:52 <noecksit> is it possible to implement unfoldr in scheme?
15:35:52 <vixey> sbahra: You have seen fold ?
15:35:53 <pjdelport> > Just 42 `fmap` (*2)
15:35:54 <lambdac>  Couldn't match expected type `a -> b'
15:36:01 <vixey> noecksit: of course
15:36:16 <sbahra> vixey, what do you mean?
15:36:18 <yitz> olsner: #apl must have a lot of problems
15:36:18 <vixey> noecksit: You can just translate the definition lambda for lambda
15:36:26 <pjdelport> > (*2) `fmap` Just 42
15:36:27 <lambdac>  Just 84
15:36:32 <pjdelport> > (*2) `fmap` Nothing
15:36:33 <lambdac>  Nothing
15:36:54 <pjdelport> noecksit: it's defined in SRFI 1
15:37:02 <vixey> sbahra: foldr (the cool one), either, maybe (boring ones), the general idea of a fold (for any ADT)
15:37:02 <mmorrow> > runState (get >>= \x -> put (x+1) >> return "asdf") 42
15:37:04 <lambdac>  ("asdf",43)
15:37:04 <sbahra> vixey, I wrote my own versions of fold/etc...
15:37:15 <EvilTerran> ?type uncurry (&&&) . ((&&&) `on` ((min `on`) . (fst .))) M.findMin M.findMax
15:37:18 <lambdac> forall k a. (Ord k) => M.Map k a -> M.Map k a -> (k, k)
15:37:18 <mmorrow> > runState (modify (+1) >> return "asdf") 42
15:37:20 <lambdac>  ("asdf",43)
15:37:24 <EvilTerran> it's a monster!
15:37:24 <rwbarton> Huh.  I had been under the impression that (take k . snd . split key) was a reasonably efficient way to get the first k entries of a map after key, but I guess since Map is a strict data structure, it's really not.
15:37:25 <EvilTerran> :P
15:37:57 <noecksit> pjdelport: thanx, im interested to know how the maybe data type is handled in scheme
15:38:04 <mmorrow> > forever (return 4 :: [Int])
15:38:06 <lambdac>  Exception: stack overflow
15:38:22 <olsner> yitz: "Are you swearing at me!?" "No, that was my program for solving sudokus that I was asking for help about"
15:38:24 <sbahra> vixey, why?
15:38:26 <pjdelport> noecksit: you don't need Maybe to write unfoldr; it's just one way of representing the alternative
15:38:39 <yitz> heh
15:38:42 <pjdelport> noecksit: another way is to supply a predicate function, which is what SRFI 1 uses
15:38:50 <vixey> sbahra: it is one of the most interesting things to me
15:39:10 <sbahra> vixey, Haskell is a trip to me
15:40:28 <sbahra> Whatever that means :-)
15:40:42 <ddarius> @wn trip
15:40:44 <lambdac> *** "trip" wn "WordNet (r) 2.0"
15:40:44 <lambdac> trip
15:40:44 <lambdac>      n 1: a journey for some purpose (usually including the return);
15:40:44 <lambdac>           "he took a trip to the shopping center"
15:40:44 <lambdac>      2: a hallucinatory experience induced by drugs; "an acid trip"
15:40:46 <sbahra> It's an experience I really can't describe yet ;-p
15:40:46 <lambdac> [23 @more lines]
15:40:55 <jaj> sbahra: you have to try ghc on acid
15:41:07 <jaj> ghci*
15:41:13 <mmorrow> > runState (get >>= \x -> put (x+1) >> get >>= \y -> put (y+1) >> return (x,y)) 42
15:41:14 <lambdac>  ((42,43),44)
15:41:18 <sbahra> jaj, is it stand-alone? I thought it required me to download/configure/etc... lambdabot?
15:41:48 <Twey> It is lambdabot, sbahra
15:41:48 <vixey> sbahra, data Expr = Var Id | Num N | Add Expr Expr
15:41:50 <Twey> Also, hello
15:41:54 <sbahra> Hey :]
15:41:55 <Twey> Long time no see
15:41:58 <sbahra> Indeed
15:41:59 <vixey> evaluate = folde lookup id (+)
15:42:02 <jaj> sbahra: I don't know, I haven't had a look at it but I sounds like it might give you a great trip
15:42:12 <sbahra> Twey, I didn't know you used Haskell
15:42:19 <vixey> partialEvaluate = folde Var Num simpl
15:42:19 <vixey>  where simpl (Num x) (Num y) = Num (x+y)
15:42:19 <vixey>        simpl p q = Add p q
15:42:27 <ekidd> Oooh, vocable is shiny.
15:42:34 <Twey> sbahra: Now you do
15:42:43 <mmorrow> you get to see you hands melt every time you eval fib!!@
15:42:50 <sbahra> Twey, yes
15:42:58 <sbahra> Twey, too bad for you ;]
15:43:04 * Twey chuckle.
15:43:08 <Twey> +s
15:43:38 * vixey thinks it's cool anyway
15:43:47 <sbahra> vixey, it is
15:44:06 <vixey> meijer derives compilers using only fold :D
15:44:11 <vixey> pretty much
15:44:20 <Twey> Haha, argh!
15:44:36 <yitz> > runState (do x <- get; modify (+1); y <- get; modify (+1); return (x,y)) 42
15:44:44 <lambdac>  ((42,43),44)
15:44:45 <nolrai_East> > (uncurry (&&&) . ((&&&) `on` ((min `on`) . (fst .))) M.findMin M.findMax) (M.fromAcList [(1,'a'),(4,'b')]) (M.fromList [(2,'a'),(6,'x')])
15:44:49 <vixey> STG, WAM and stuff just by calculating, it's amazing
15:45:03 <lambdac>   Not in scope: `M.fromAcList'
15:45:07 <ivanm>        /", " -", "
15:45:07 <ivanm>        \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
15:45:16 <nolrai_East> > (uncurry (&&&) . ((&&&) `on` ((min `on`) . (fst .))) M.findMin M.findMax) (M.fromList [(1,'a'),(4,'b')]) (M.fromList [(2,'a'),(6,'x')])
15:45:18 <lambdac>  (1,4)
15:45:18 <ivanm> whoops, sorry
15:45:47 <mmorrow> > runState (replicateM_ 1000 (modify (+1))) 42
15:45:48 <lambdac>  ((),1042)
15:46:35 <densehed> Hello anyone around? I have a few questions. Trying to find the right direction to take..
15:47:21 <mmorrow> > (\(a,b)->(b,a)) $ runState (replicateM 1000 (do x <- get ; modify (+x))) 42
15:47:22 <lambdac>  (450033615018232274798338520605200760435790020916324115126375163115547441472...
15:47:28 <mmorrow> > (\(a,b)->(b,a)) $ runState (replicateM 10 (do x <- get ; modify (+x))) 42
15:47:30 <lambdac>  (43008,[(),(),(),(),(),(),(),(),(),()])
15:47:47 <mmorrow> > (\(a,b)->(b,a)) $ runState (replicateM 10 (do x <- get ; modify (+x) ; get)) 42
15:47:49 <lambdac>  (43008,[84,168,336,672,1344,2688,5376,10752,21504,43008])
15:47:59 <Botje> @pl \(a,b) -> (b,a)
15:47:59 <lambdac> uncurry (flip (,))
15:48:07 <Botje> why is this not a standard library function :(
15:48:08 <pjdelport> densehed: just ask
15:49:20 <nolrai_East> given a key, k, in a Map, m, is there a fast way to get the smallest key in m that is > k?
15:49:28 <vixey> swap ~(x,y) = (y,x)
15:49:31 <vixey> right !?
15:49:36 <glguy_> nolrai_East: sounds like a job for Data.Sequence
15:49:36 <vixey> @let swap ~(x,y) = (y,x)
15:49:38 <lambdac> Defined.
15:49:47 <pjdelport> :t (snd &&& fst)
15:49:49 <vixey> :t Control.Arrow.swap
15:49:49 <lambdac> forall a b. (a, b) -> (b, a)
15:49:51 <lambdac> Not in scope: `Control.Arrow.swap'
15:50:10 <noteventime> Has anyone been experimenting with using Haskell and the CELL SPEs?
15:50:43 <rwbarton> nolrai_East: yes, using split.  It's not as bad as I thought at first (O(log n), but the constant is bigger than it has to be)
15:50:59 <sbahra> noteventime, would be a very good fit
15:51:10 <sbahra> noteventime, but I haven't seen any such papers myself
15:51:23 <rwbarton> > runState (mdo put (1:x) ; x <- get ; return ()) 42
15:51:23 <lambdac>  Parse error at ";" (column 25)
15:51:26 <rwbarton> boo!
15:51:47 <sbahra> noteventime, a lot of work (though a bit under the table still) is being done to have some PGAS languages support CELL SPEs properly
15:52:16 <sbahra> noteventime, though that's under a heterogeneous multicore architecture research effort, not CELL in specific.
15:52:48 <noteventime> sbahra: I figured it would raise interest in Haskell
15:52:51 <yitz> > ((), fix (1:))
15:52:52 <lambdac>  ((),[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:52:52 <SamB> hey, GHC doesn't even support cross-compiling yet really
15:53:20 <noteventime> sbahra: Since there doesn't seem to be any "real" languages taking advantage of the SPEs
15:53:21 <yitz> SamB: yet?
15:53:34 <SamB> yitz: it's bound to happen sooner or later
15:53:42 <sbahra> noteventime, a non-trivial task for the more popular imperative languages in HPC
15:53:45 <SamB> to some extent or other
15:54:00 <yitz> SamB: only if someone needs it enough to make it happen
15:54:34 <noteventime> sbahra: Maybe we can hope for something when the ghc-plugins project is done :)
15:54:45 <yitz> SamB: well, you can compile to C, then compile the C on the other platform.
15:54:54 <SamB> I think it's more the buildsystem than the compiler proper that would need to be changed to get it to work
15:55:01 <erikc> C takes advantage of the SPEs just fine
15:55:11 <SamB> yitz: that would work great if GHC compiled to *ANSI* C
15:55:12 <sbahra> erikc, heh
15:55:28 <eu-prleu-peupeu> check: http://img108.imageshack.us/img108/3015/adceb75991777bee0d331f8hn4.jpg
15:55:30 <lambdac> http://tinyurl.com/6rusnk
15:55:41 <sbahra> hmm, noteventime
15:55:46 <SamB> yitz: as it stands there's another step in there which involves manually hacking away at some header files or something in between
15:55:51 <sbahra> noteventime, http://www.haskell.org/haskellwiki/Yhc/Ideas
15:55:53 <lambdac> Title: Yhc/Ideas - HaskellWiki
15:55:53 <noteventime> eu-prleu-peupeu: Hahaha
15:56:11 <erikc> as an ex-cell compiler developer and a cell software developer, im really not sure what people expect in terms of a 'real' language for cell
15:56:51 <noteventime> sbahra: You think the change of YHC getting it is larger?
15:56:57 <SamB> erikc: well, it should be possible to use said language to write code that runs on the cell
15:56:59 <erikc> the best i can come up with for haskell would be something like Harpy for the SPUs
15:57:09 <sbahra> erikc, support for SIMD model
15:57:29 <sbahra> erikc, as seen in MPI, PGAS, etc...
15:58:34 <erikc> ok
15:58:40 <noteventime> erikc: A way for the compiler to identify computations that would fit on the SPEs and generate the needed code?
15:59:05 <yitz> what's the name again of that famous research project of YHC on a many core thingy?
15:59:07 <noteventime> Dunno, I don't know a lot on the subject
15:59:13 <noteventime> Was just a thought :)
15:59:45 <erikc> i worked on that problem at ibm, the general case was ... hard
16:00:08 <erikc> and performance results were disappointing enough to make the platform unattractive
16:00:13 <sbahra> :[
16:00:21 <noteventime> :/
16:00:47 <erikc> because of the asymmetric memory mainly
16:00:55 <sbahra> Problem with PGAS is the actual address space is provided on top of a message passing interface in the real world, the model is not suitable.
16:01:00 <noteventime> That's sad news :|
16:01:09 <noteventime> The platform seemed pretty interesting otherwise
16:01:43 <erikc> streaming computations are a great fit
16:01:45 <sbahra> erikc, do you guys have any results on that project?
16:01:58 <mmorrow> > flip runState (1,1) . flip replicateM (get >>= \(a,b) -> put (b,a+b) >> return a) $ 10
16:01:59 <lambdac>  ([1,1,2,3,5,8,13,21,34,55],(89,144))
16:02:11 <sbahra> erikc, well...
16:02:14 <erikc> its here http://domino.research.ibm.com/comm/research_projects.nsf/pages/cellcompiler.index.html
16:02:16 <erikc> the alpha is available
16:02:18 <lambdac> http://tinyurl.com/hl4k2
16:02:31 <sbahra> erikc, have you looked at some of the work the FPGA community has worked on?
16:02:39 <sbahra> erikc, Mitrion-C, in specific.
16:02:51 <erikc> i havent, i will
16:02:55 <sbahra> cool
16:03:18 <yitz> @pl (a,b) -> (b,a+b)
16:03:18 <lambdac> (line 1, column 7):
16:03:19 <lambdac> unexpected ">" or "-"
16:03:19 <lambdac> expecting variable, "(", operator or end of input
16:03:28 <yitz> @pl \(a,b) -> (b,a+b)
16:03:28 <lambdac> uncurry (ap (,) . (+))
16:04:22 <jeffz> didn't someone write a Haskell library for producing good code on the cell?  I remember seeing a video...
16:04:49 <yitz> jeffz: that's what I was asking about. they used YHC core.
16:04:59 <sbahra> erikc, thanks
16:04:59 <jeffz> yitz, ahh righto
16:05:19 <yitz> nottingham, i think
16:08:39 <antirobotrobot> are there any event loops libraries?
16:09:17 <bwr>  haha, i got on haskell weekly news :D
16:09:23 <bwr> but my quote is missing a space
16:09:33 <SamB> bwr: an important space?
16:09:38 <bwr> SamB: yea
16:09:52 <SamB> @quote bwr
16:09:52 <lambdac> No quotes match. My brain just exploded
16:09:56 <SamB> hmm.
16:09:57 <yitz> bwr: it draws a funny picture
16:09:59 <SamB> @quote
16:09:59 <lambdac> xDie says: <xDie> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
16:10:18 <bwr> yitz: [" "," /", " -", " \\"] should be ["  "," /", " -", " \\"]
16:11:35 <yitz> bwr you mean two spaces instead of one inside "  "?
16:11:40 <bwr> yes
16:11:43 <erikc> i do think haskell is well suited for cell programming, with SIMD intrinsics and a way to guarantee that a given pure function that takes bytestrings and produces bytestrings can run in constant space < 256k - sizeof(code), preferably with no gc
16:11:55 <yitz> bwr: still draws a funny picture, not much different
16:12:05 <bwr> one second
16:12:37 <bwr> yitz: http://hpaste.org/9598 is the expected output
16:13:05 <yitz> bwr: that's not what I got
16:13:19 <bwr> how many extra spaces did you add?
16:13:25 <bwr> and where
16:13:55 <ivanm> works here... and if you use a single space and no spaces in front of the other chars, you get a right-angled one
16:14:08 <yitz> bwr: one, inside that string containing only space. but there must be something else wrong, i'm not getting the line along the right
16:14:33 <ivanm> ["  "," /", " -", " \\"] <-- this what you have yitz?
16:14:50 <bwr> ivanm: hah, yea, that looks funky
16:14:51 <ivanm> bwr: do I dare ask how long it took you to create that?
16:14:58 <SamB> yitz: I don't see a line along the right in the output of
16:15:00 <SamB> % curl http://hpaste.org/9598/0/plain
16:15:02 <noteventime> erikc: Do you think a library for parallel computation for the SPEs, or automatic identification/generation by the compiler would be the better option. (Obviously it depends on the situation, but I'm more interested in which one you think would get people to use Haskell on the platform)
16:15:25 <bwr> ivanm: hmm, well, i was at first trying to shorten a ruby golf item that did something similar, but then i got bored and tried doing it differently and i eneded up with this
16:15:29 <bwr> maybe 3 days off an on
16:15:48 <ivanm> heh
16:16:04 * ivanm tries to work out how to turn the right-angled one into a double one...
16:16:22 <bwr> the code is a mess it could use a lot of simplication
16:16:32 <bwr> simplification
16:17:08 <ivanm> mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ")$concat$map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
16:17:19 <ivanm> try that one, even more funkiness! :p
16:17:23 <bwr> haha ok
16:17:26 <erikc> noteventime: i think a library for parallel computation is more practical (IBM has gone that route too), automatic parallelization is a nice holy grail (and plausible in Haskell because of purity guarantees), but whats really at issue is the economics of the platform
16:17:55 <bwr> ivanm: cool
16:18:18 <ivanm> it could be tweaked better :s
16:18:24 * ivanm should get back to work :(
16:18:27 <bwr> haha
16:18:52 <noteventime> erikc: What about some more generic problem, like GPGPU?
16:19:09 <noteventime> Wouldn't the problems be similar?
16:19:23 <noteventime> (I only know this from a very high level perspective, so I may be very wrong)
16:19:33 <erikc> yup, its similar, but GPUs are cheap
16:20:56 <bwr> ivanm: it might be neat to switch \ and / in the right side
16:21:16 <ivanm> yeah
16:23:10 <noteventime> So has anyone been working on Haskell with GPGPU? :) I remember reading some mailing list thread about that
16:24:15 <erikc> (the cell is pretty brilliant for the ps3, because in the console world, you take a hardware snapshot in time and then developers spend years microcoding to take advantage of the platforms)
16:24:56 <noteventime> Haha
16:24:57 <thoughtpolice> i remember hearing about some work to modify the -fvia-C backend to work and generate code to interface with CUDA but that's about it
16:25:06 <thoughtpolice> it would be interesting to try that with e.g. nested data parallelism
16:25:18 <thoughtpolice> there was also a paper recently about a DSL for GPU programming in haskell
16:25:22 <noteventime> thoughtpolice: That was my though to
16:25:50 <noteventime> GPUs should make an interesting testing ground for data-parallel haskell, shouldn't they?
16:27:26 <thoughtpolice> with language.c now it might be interesting, definitely :)
16:27:38 <thoughtpolice> I actually have CUDA installed on this macbook but I haven't played around with it much
16:28:17 <thoughtpolice> with Language.C it might be interesting to try though :)
16:28:30 <noteventime> I don't have a CUDA-compatible card yet :/
16:29:03 <noteventime> Though I'll get one if things become more interesting :)
16:29:55 <erikc> when i originally looked at haskell, i was hoping monads could mean DSL environments where you could only do a restricted set of operations
16:29:59 <paczesiowa> > ()
16:30:00 <lambdac>  ()
16:30:11 <paczesiowa> still no lambdabot
16:30:20 <erikc> so that i could make GPU and SPU 'monads' hehe
16:31:36 <noteventime> erikc: Couldn't something like that almost be done be introducing something like a second "RealWorld"?
16:31:48 <noteventime> Now I'm getting into an area that I really don't know much about ^^
16:31:55 <noohgodno> () is a good album
16:32:16 <erikc> but you cant restrict what ppl can do in them, sadly
16:32:22 <erikc> someone could always unsafePerformIO
16:32:54 <TSC> paczesiowa: (re MaybeT paste) Thanks; that's almost exactly what I ended up with
16:32:57 <noteventime> Well, that's a little like saying someone could always try to dereference null :)
16:33:10 <erikc> hehe
16:33:21 <paczesiowa> TSC: np
16:33:29 <noteventime> erikc: STM can't be run in unsafePerformIO though, can it?
16:33:41 <erikc> im not familiar enough with STM
16:33:50 <erikc> theres probably some rules about not being evil
16:33:53 <erikc> hehe
16:35:00 <SamB> noteventime: sure it can
16:35:14 <SamB> but you aren't allowed to run STM from within STM
16:35:36 <encryptio_> ...isn't that the entire point of STM? composable transactions?
16:35:47 <noteventime> SamB: The documentation for newTVarIO says you can't run atomically inside an unsafePerformIO
16:35:48 <paczesiowa> TSC: if you have different errorcases for every failable thing you can use ErrorT
16:35:56 <SamB> noteventime: oh?
16:36:07 <SamB> I sit corrected
16:36:11 <noteventime> SamB: http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AnewTVarIO
16:36:13 <lambdac> http://tinyurl.com/ys92tb
16:40:31 <TSC> paczesiowa: Yeah, that was another alternative
16:41:00 <TSC> And it's by default a MonadPlus (:
16:44:14 <slava> hi dibblego
16:44:22 <dibblego> hey mate
16:44:34 <yitz> encryptio: it's composable because you can compose things that are all already inside the STM monad. Once you run atomically on it, you've set it in cement.
16:51:02 <mmorrow> holy shit!!
16:51:08 <mmorrow> mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ") $ concat $ map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
16:51:19 <TomMD> Yeah, isn't it great.
16:51:20 <mmorrow> i totally didn't see what that printed out coming
16:51:29 <mmorrow> very cool
16:52:00 <saml> > mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ") $ concat $ map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
16:52:01 <lambdac>  <IO ()>
16:52:03 <ivanm> mmorrow: even better if you have ["  ", " /", " -", " \\"] (i.e. one more space in each
16:52:15 * mmorrow tries that
16:52:46 <yitz> >  unwords$map(map(toEnum.fromIntegral).zipWith($)((+65):repeat(+97)).map(`mod`26).takeWhile(>0).iterate(`div`26))[346641,5302636274,3530784511,203988415]
16:52:48 <lambdac>  "Just Another Haskell Hacker"
16:53:04 <ivanm> heh
16:53:28 <Twey> Hahaha, nice, yitz
16:54:00 <yitz> reminds me of years ago when I used to program in some other programming language...
16:54:05 <ivanm> these damn haskellers have too much time on their hands >_>
16:54:32 <Twey> Hahaha
16:54:42 <sw17ch> yitz, you mad Haskell look like Perl... you ruined my night
16:54:57 <yitz> sw17ch: yeah, sorry about that
16:54:57 <mauke> mapM_ (putStrLn . ap (++) reverse) $ ...
16:55:04 <TomMD> I think this is incontrovertible evidence that Haskell programming jobs provide more vacation time than necessary.
16:55:25 <sw17ch> TomMD, i, for one, am more than willing to suffer through too much vacation time
16:55:33 <sw17ch> if it means i get a job using haskell
16:55:43 <TomMD> Where do you live?
16:55:59 <sw17ch> Grand Rapids, MI
16:56:00 <sw17ch> :(
16:56:08 <sw17ch> the only place remotely close i know of using it is Eaton Aerospace
16:56:14 <sw17ch> but the place that uses it is not in michigan
16:56:55 <yitz> sw17ch: what's the prob, you can commute to Detroit, Chicago, S. Bend...
16:57:26 <mmorrow> > (return::a->Maybe(a)) . unwords .  map(map(toEnum.fromIntegral).zipWith($)((+65):repeat(+97)).map(`mod`26).takeWhile(>0).iterate(`div`26)) $ [5302636274,3530784511,203988415]
16:57:27 <lambdac>  Just "Another Haskell Hacker"
16:57:33 <yitz> ha!
16:58:07 <TomMD> Grand Rapids `notElem` [ "Portland", "US East Coast", "Cambridge", "Chalmers"]
16:58:09 <Twey> Hahahaha, mmorrow
16:58:19 <atp> mmorrow: classic
16:58:24 <mmorrow> hehe
16:59:25 <sw17ch> let // = "just"; =~ = "another"; unless = "haskell"; $ = "hacker" in concat [//,=~,unless,$]
16:59:28 <mauke> sw17ch: http://mauke.ath.cx/stuff/haskell/hax.pl
16:59:28 <sw17ch> > let // = "just"; =~ = "another"; unless = "haskell"; $ = "hacker" in concat [//,=~,unless,$]
16:59:28 <lambdac>  Parse error at "//" (column 5)
16:59:35 <yitz> > listToMaybe . return . unwords .  map(map(toEnum.fromIntegral).zipWith($)((+65):repeat(+97)).map(`mod`26).takeWhile(>0).iterate(`div`26)) $ [5302636274,3530784511,203988415]
16:59:37 <lambdac>  Just "Another Haskell Hacker"
16:59:50 <sw17ch> TomMD, :(
17:00:29 <TomMD> You could always resurrect the issue with a) moving or b) Starting a business ;-)
17:00:50 <sw17ch> b) is easier... wife doesn't like the idea of moving :(
17:01:07 <sw17ch> though, it's not entirely out of the question i suppose :)
17:01:12 <yitz> sw17ch: understandable, Gr.Rapids is beautiful
17:01:15 <TomMD> Well then hop to!  And get a company blog feeding to p.h.o
17:01:31 <sw17ch> yitz, i love Grand Rapids....
17:01:47 * sw17ch pings #haskell for others from the Grand Rapids, MI area
17:01:58 <yitz> sw17ch: i went to nmc in Interlochen when i was a kid
17:02:00 <sw17ch> TomMD, p.h.o?
17:02:16 <TomMD> sw17ch: planet.haskell.org
17:02:18 <sw17ch> I got swimmers itch around Interlochen last summer
17:02:26 <sw17ch> TomMD, sorry, yes, of course..
17:02:30 <yitz> sw17ch: which lake?
17:02:40 <sw17ch> yitz, ... the itchy one... :)
17:02:45 <TomMD> :|
17:02:49 <moozilla> > let (//) = "just"; (=~) = "another"; unless = "haskell"; ($) = "hacker" in concat [(//),(=~),unless,($)]
17:02:50 <Twey> Hahaha
17:02:51 <lambdac>  "justanotherhaskellhacker"
17:02:55 <Twey> Swimmers' itch?
17:02:59 <yitz> sw17ch: never had that prob in either of the lakes in my day
17:03:38 <TomMD> yitz: Does that phrase me this is not your day?  I'm always confused by how many conclusions I can draw from that ;-)
17:03:42 <sw17ch> Twey, it's a parasite that usually travels on Duck's feet... well, it finds people skin just as nice as Duck feet... but the people blood kills the parasite (thank goodness)... but they itch like you wouldn't believe for a while
17:03:46 <TomMD> s/me/mean/
17:04:00 <mmorrow> omg
17:04:00 <Twey> sw17ch: Huh.  Weird O.O
17:04:03 <mmorrow> try this one
17:04:05 <mmorrow> mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ") $ concat $ map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..100-y*2]]|y<-[30..61]]
17:04:24 <sw17ch> mmorrow, does lambdabot refuse?
17:04:31 <mmorrow> IO
17:04:38 <yitz> TomMD: this is not my day in Interlochen. :)
17:04:48 * sw17ch wants to start a Grand Rapids HUG
17:05:20 <yitz> sw17ch: a HUG whose number of members is idempotent is very special.
17:06:02 <sw17ch> yitz, you made me use a dictionary... congratulations :)
17:06:04 <mmorrow> sw17ch: http://hpaste.org/9600
17:06:12 <bwr> mmorrow: hah
17:06:22 <bwr> what did you do
17:06:29 <sw17ch> mmorrow, o_O
17:06:48 <sw17ch> argh, must take care of something.. back shortly
17:06:50 <sw17ch> ish
17:06:52 <mmorrow> i changed
17:06:54 <mmorrow> mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ") $ concat $ map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
17:06:55 <mmorrow> to
17:07:00 <mmorrow> mapM_ putStrLn $ map (\ x -> x ++ (reverse x)) $ reverse[(++)([1..y-30]>>" ") $ concat $ map([" ","/", "-", "\\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..100-y*2]]|y<-[30..61]]
17:07:05 <sw17ch> the difference is obvious
17:07:09 <mmorrow> so, 59 -> 100
17:07:25 <mmorrow> (diff that shiz)
17:08:11 <bwr> ah ok i see
17:08:26 <mmorrow> bwr: i remember you messing with this the other day. i had NO IDEA it did what it does O_O
17:08:47 <bwr> mmorrow: part of that it is that it is a terrible mess
17:09:07 <mmorrow> i was completely shocked when i just happened to "oh i wonder what that does" in ghci :)
17:09:33 <mmorrow> my fav haskell one liner yet!
17:09:49 <shapr> Yeah, I like that one!
17:09:59 <bwr> it needs to be shortened ... it is pretty much two lines right now
17:10:38 <bwr> i am using the polytopic numbers and i have a shorter formula now
17:11:30 <mmorrow> cool. first on my list is to figure out what it's doing
17:11:44 <bwr> well, do you want any hints?
17:11:46 <mmorrow> i see fibish subparts in there
17:11:54 <dons> dcoutts_: http://community.livejournal.com/evan_tech/252465.html
17:11:55 <lambdac> Title: evan_tech -- c-repl release
17:11:57 <mmorrow> > fix ((0:) . scanl (+) 1)
17:11:58 <lambdac>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:12:03 <dons> mentions that he's having trouble with cabal
17:12:19 <dons> dcoutts_: despite rewriting the project in haskell, looks like his Setup.lhs is a bit funky.
17:12:30 * dcoutts checks it out
17:12:31 <mmorrow> bwr: heh, no hints yet.. ;)
17:14:06 <dcoutts> dons: looks like it was just an old version of c2hs and they've got it working
17:15:13 <Twey> Some day someone's going to create an obfuscated one-liner that executes rm -rf ~
17:15:24 <Twey> And everyone will be all, 'oh, I wonder what this does'
17:15:31 <Twey> *paste*
17:15:34 <Twey> *bang*
17:15:39 <Twey> 'AAAAAAAHHHHHHH!!!'
17:15:43 <TomMD> Twey: How will they get root permissions?
17:15:55 <Twey> TomMD: Check the command again :-P
17:15:56 <TomMD> They need an obfuscated local root exploit!
17:16:01 <Twey> Hahahaha
17:16:02 <mauke> rm needs root now? o_O
17:16:03 <TomMD> oh, I was thinking /
17:16:05 <TomMD> right
17:16:10 <Trinithis> what is -rf ~ // removes everything?
17:16:24 <TomMD> Well... time to beef up some SELinux policies I guess.
17:16:26 <mauke> removes your home dir
17:16:26 <SamB> TomMD: wouldn't that only come up AFTER everything *in* the home directory was already gone?
17:16:30 <Twey> Trinithis: Remove, recursively and forcefully, the home directory.
17:16:44 <Twey> (i.e. where all your files are stored)
17:16:57 <mmorrow> if you do rm -rf / it'll give the chop the everything it can
17:17:04 <mmorrow> s/the/to/
17:17:06 <Trinithis> instaed of i.e., we should use f.x.
17:17:15 <Cale> gwern: are you around?
17:17:16 <TomMD> dd if=/dev/urandom of=/dev/sda
17:17:17 <mauke> Trinithis: ew, no
17:17:24 <Trinithis> IE is the devil
17:17:36 <mauke> Trinithis: instead of i.e. you could use t.i.
17:17:49 <SamB> it's kinda like if you could delete the desktop in Windowws, except worse since in windows you probably keep stuff all over the place ;-)
17:17:50 <Trinithis> I dont know what t.i. means
17:18:04 <mauke> "that is"
17:18:07 <mmorrow> > ]forever (putChar '\a')
17:18:07 <lambdac>  Parse error at "]fore..." (column 1)
17:18:10 <mmorrow> > forever (putChar '\a')
17:18:11 <lambdac>  <IO ()>
17:18:15 <Trinithis> I use ie and eg
17:18:22 <Trinithis> and ex
17:18:31 <mauke> i.e. means "that is", e.g. means "for example"
17:18:56 * yitz uses ff instead of ie. (ff="firefox")
17:19:06 <TomMD> Any seamonkey users?
17:19:12 * Twey raises a hand.
17:19:17 <Trinithis> fx is the official acronym for firefox I thought
17:19:18 <atp> probably in #mozilla
17:19:35 <mauke> a.m. means "before noon", p.m. means "after noon" :-)
17:21:05 <Olathe> After midnight.
17:21:25 <Trinithis> post midnight
17:21:39 <mmorrow> pre morning!
17:21:41 <Trinithis> err... that doesnt work
17:21:47 <mmorrow> heh
17:21:49 <mauke> :facepalm:
17:21:59 <Twey> 'ante-meridian' and 'post-meridian'
17:22:04 <mauke> meridiem*
17:22:17 <Twey> Really?  Oh :(
17:22:23 * Twey has been DOING IT WRONG for ages
17:22:24 <Olathe> I think diem is day or something.
17:22:32 <Twey> Yeah
17:22:32 <Twey> It is
17:22:37 <mauke> yes, diem is the accusative form of dies, meaning day
17:22:40 <Twey> Never thought to connect those, though
17:22:43 <Twey> *shakes head*
17:22:52 <Trinithis> A.M. == Master of Arts
17:22:54 <mauke> good to see that my latin lessons finally pay off
17:23:13 <mauke> (my first foreign language was Latin, not English)
17:23:26 <jsnx> mauke: what is your native language?
17:23:34 <mauke> German
17:23:37 <TomMD> I always thought it was Haskell.
17:23:47 <Olathe> A.M. = someone spelling out 'am'.
17:24:03 <jsnx> i think a lot of people on this channel who do not speak english natively are native german speakers
17:24:04 <Trinithis> Olathe: A-M
17:25:08 <Twey> mi jbopre se ki'u lo mi pa-moi bangu du la .lojban.
17:25:22 <mauke> wie bitte?
17:25:23 <jsnx> Twey: that's the strangest german i've ever seen
17:26:06 <jsnx> mauke: whenever folks say, i don't speak english natively, and i ask them what they speak, they usually say german
17:26:13 <bwr> Twey: you speak lojban?
17:26:19 <jsnx> mauke: totally anecdotal
17:26:20 <mauke> heh
17:26:29 <gwern> Cale: I am around a little
17:26:35 <gwern> @seen iggly_
17:26:35 <lambdac> iggly_ is in #haskell. I don't know when iggly_ last spoke.
17:26:39 <gwern> er.
17:26:40 <gwern> @seen Igloo
17:26:40 <lambdac> Igloo is in #haskell. I last heard Igloo speak 11h 20m 7s ago.
17:26:42 <Twey> Hahaha, jsnx
17:26:45 <Twey> Yes, bwr
17:26:49 <jsnx> mauke: i took some german in high school, but do not remember much
17:26:50 <mauke> is it not obvious from ze accent?!
17:26:54 <gwern> preflex: seen Igloo
17:26:54 <preflex>  Igloo was last seen on #ghc 2 hours, 17 minutes and 54 seconds ago, saying: Ah, hmm, so we'll have to ship with ghc-paths too, I guess
17:27:13 <jsnx> mauke: zat is a french accent
17:27:27 <gwern> mauke: why else would you have zat out-raaggous ac-cent?!
17:27:55 <mauke> jsnx: then how do I type with a German accent? :-)
17:28:02 <Olathe> Use umlauts.
17:28:13 <gwern> mauke: usually some sort of alt-binding
17:28:14 <jsnx> mauke: like dis
17:28:20 <gwern> mauke: or use a character map; standard OS utility
17:28:32 <hansfbaier> Ã¤Ã¶Ã¼Ã
17:28:33 <gwern> @ask Igloo is it true that using Template Haskell renders stuff nonportable across architectures, even ones which have GHC?
17:28:33 <lambdac> Consider it noted.
17:28:35 <mauke> "vis a Dsherman akcent"
17:28:51 <jsnx> du talk with diee letter 'd' all over die plaze
17:28:53 <yitz> mauke: gather all of your verbs at the end of the sentence. concat together all of your nouns.
17:29:05 <Trinithis> gwern: why
17:29:27 <gwern> Trinithis: that is not a coherent question, or even sentence
17:29:59 <mauke> yitz: verbs come at the end only in subordinate clauses
17:30:00 <gwern> yitz: why did you bring that language I didn't want to be talked to from which out of up for?
17:30:08 <Trinithis> Why is TH non portable?
17:30:34 <mauke> and zat is more of a Grammarissue
17:30:38 <gwern> Trinithis: I've been told in #darcs that apparently some architectures have GHC but not ghci and ghci is necessary for TH? or something
17:30:50 <Trinithis> huh
17:30:53 <newsham> ghci doesnt always work properly in freebsd/amd64
17:31:07 <newsham> due to dynamic linker issues on certain amd64 platforms
17:31:15 <SamB> gwern: well, of course GHCi is needed for TH
17:31:40 <gwern> SamB: don't of course me. there's nothing of course about it
17:31:48 <jsnx> mauke: i dink die letter 'v' iz good, az well
17:31:49 <mauke> I sink for a typical german Accent you need to pronounce th as s or z and w as v
17:31:49 <SamB> gwern: how is TH going to work without a Haskell interpreter
17:31:51 <SamB> ?
17:32:26 <gwern> dunno. you seem to assume I would assume it needs a haskell interpreter
17:32:54 <Cale> gwern: I was wondering how ready mueval is for being used as a replacement for lambdabot's eval stuff.
17:32:59 <Twey> And /Éª/ as /i/
17:33:20 <mauke> wait, isn't "as" pronounced "az"?
17:33:26 <Twey> Yep
17:33:28 <gwern> Cale: oh. well, I've found that doing qualified imports is apprently not possible with the current GHC API
17:33:32 <Cale> hmm
17:33:36 <Twey> But Germans devoice it usually :)
17:33:45 <mauke> ass
17:33:48 <gwern> Cale: so I've given up on that; it might be possible to work around, but it's not worth it
17:33:55 <Cale> gwern: Is it possible to load a module and evaluate the expressions in that context?
17:33:58 <gwern> Cale: I added smallcheck to mueval tho
17:34:19 <SamB> gwern: well, yeah, I was assuming that you are a smart enough cookie to at least figure out why after I tell you it is so ;-)
17:34:31 <gwern> Cale: sure, but the issue is - suppose you do 'mueval --import Data.Map --expression 'map (+1) [1..100]'
17:34:37 <SamB> how ELSE is it going to know what to splice ?
17:34:49 <gwern> Cale: dunt work. map is ambigious. you have to do Prelude.map (+1)...
17:35:03 <Cale> gwern: and if I do  mueval --import L --expression 'map (+1) [1..100]'
17:35:16 <Cale> where L is the module that has lots of qualified imports and such?
17:35:32 <gwern> Cale: ah, there's where things get tricky
17:35:54 <gwern> Cale: the second issue is @let. currently I have all bad expressions result in non-zero exit codes, so the first part is done. but the second part, actually loading a file, is giving me real trouble
17:36:29 <gwern> Cale: I *should* be able to just load a file and set it in context, but everything I've tried just doesn't work, even though Hint comes with working examples. it's quite frustrating. I haven't figured out what's going wrong
17:36:30 <Cale> Well, I need to replace runplugs with something, and I was thinking of using mueval... the @let mechanism is almost separate anyway
17:36:34 <Cale> hmm
17:37:33 <gwern> Cale: once I get the load-from-file stuff working, I'd be well-content to remove runplugs
17:37:37 <gwern> just... not quite there yet
17:37:51 <Trinithis> Twey: In JS, with setTimeout, the callback doesnt have a chance to execute until the callstack is empty right?
17:37:51 <gwern> very frustrating, enough so that I've been spending free time on darcs
17:38:16 <Cale> I'm going to mess around with it a bit, since the other option for getting things to work on this machine is just too annoying.
17:38:27 <Cale> and I don't know how to actually fix the real bug in hs-plugins
17:38:52 <gwern> Cale: hopefully you'll be able to use it. ghc-paths got better dependencies, I was assured
17:39:00 * sw17ch is back
17:39:16 <Cale> gwern: It runs, but at present it's quoting its output, which is a little strange.
17:39:30 <gwern> runplugs?
17:39:34 <Cale> mueval
17:40:32 <gwern> Cale: hm. wouldn't read unquote the output?
17:40:42 <Cale> yes, I'll just do that :)
17:41:25 <jsnx> i think i know what this does, but it surprises me: [ http://hpaste.org/9601 ]
17:41:28 <Twey> Trinithis: Aye
17:41:30 <gwern> offhand, it seems to me better to quote output than not, since quoting can be undone, and may have safety improvements
17:42:08 <jsnx> does the `catch` here catch everything between itself and the `do` ?
17:42:21 <Cale> jsnx: yes
17:42:30 <Cale> jsnx: its left parameter is that entire do block
17:43:00 <yitz> jsnx: including the do
17:43:44 <jsnx> nifty
17:43:57 <jsnx> now say i indented it by two spaces
17:44:11 <Cale> then it would just be the return.
17:44:22 <jsnx> nifty
17:44:33 <Cale> mm... but you might have problems with the next line, I'm not sure
17:44:41 <jsnx> yes, probably
17:46:25 <Cale> gwern: When I try to pass it my L module it complains about an unknown or untrusted module...
17:46:50 <gwern> Cale: yes, that's expected
17:46:53 <Cale> hmm
17:47:24 <gwern> Cale: you are using an unmodified mueval? the 'modules' are just that, only modules. 'Data.Map' in containers, say, not 'Data/Map.hs'
17:47:38 <gwern> so you can't say 'mueval --module L.hs --expression 'bar 1'
17:47:41 <gwern> (if you follow me)
17:47:42 <Cale> mm... so it doesn't do the usual searching that ghci does, then
17:47:47 <Cale> ah, okay
17:48:00 <gwern> no.
17:48:29 <gwern> ghci is pretty insecure, for obvious reasons. I felt no need to do everything it does
17:48:40 <Cale> okay...
17:48:49 <Cale> however, I'd like to have it load L.o
17:49:12 <gwern> L.o?
17:49:19 <Cale> yeah, it'll already be compiled
17:49:23 <Cale> L.o/L.hi
17:50:00 <Cale> I could give it L.hs, I suppose, but there are cpp things in that...
17:50:34 <Cale> (though I guess that could be avoided now, given that it handles quickcheck stuff)
17:50:42 <gwern> mm. I'd have to look into how Hint does loading. it probably wouldn't load object/hi files
17:51:17 <Cale> It appears that Hackage failed to build hint.
17:51:27 <Cale> But it builds fine here.
17:52:09 <gwern> Cale: yeah. ghc-paths, I'd bet
17:52:18 <gwern> ghc-paths needs cabal 1.4.1 or something
17:52:26 <Cale> ah
17:52:41 <gwern> and hackage is presumably still at 1.2.3.0
17:54:41 <sw17ch> is the use of TypeSynonymInstances generally discouraged?
17:54:53 * sw17ch doesn't know why it would be, but wants to make sure
17:57:22 <Cale> No, it should be fine.
17:57:31 <sw17ch> great
17:57:46 <Cale> Just be aware that it doesn't let you do anything you couldn't already do... the synonyms are expanded first thing.
18:00:25 <chrisdone> what's a good way to show all the latest of blog feeds that I want to know about?
18:00:52 <lament> chrisdone: google readers
18:00:53 <lament> -s
18:01:12 <BMeph> Has anyone had any problems doing a `cabal update`?
18:01:17 <chrisdone> lament: I'll look at that, thanks
18:01:22 <BMeph> aNYONE ELSE, i MEAN? :)
18:01:37 <dcoutts> BMeph: what kind of problem ?
18:01:40 <ivanm> which module contains the `on` function?
18:01:40 * BMeph curses his badly-placed Caps Lock key
18:01:42 <sw17ch> Cale, that's fine... it's just for clarity
18:01:45 <mauke> @index on
18:01:45 <lambdac> bzzt
18:01:55 <mauke> ivanm: Data.Function?
18:02:00 <sw17ch> > 1 + 1
18:02:02 <lambdac>  2
18:02:13 <sw17ch> > let (?) = (+) in 1 ? 1
18:02:14 <lambdac>  2
18:02:15 <ivanm> thanks mauke
18:02:16 <mauke> @check (==) `on` abs
18:02:17 <sw17ch> awesome
18:02:18 <lambdac>  Falsifiable, after 0 tests: 1, 0
18:02:25 <BMeph> dcoutts: Every time today, I've gotten: "cabal: Failed to download index 'ErrorMisc "Invalid HTTP code: (4,0,3)"'"
18:02:44 <dcoutts> BMeph: using a dodgy proxy?
18:02:44 <SamB> naesten@hydrogen:~/hacking/haskell/ghc% cabal update
18:02:44 <SamB> Downloading package list from server
18:02:44 <SamB> 'http://hackage.haskell.org/packages/archive'
18:02:44 <SamB> naesten@hydrogen:~/hacking/haskell/ghc%
18:02:52 <SamB> just now
18:03:12 <BMeph> SamB: So I see... :)
18:03:19 <ivanm> @pl \ (a,b,c) -> (b,c)
18:03:19 <lambdac> (line 1, column 7):
18:03:20 <lambdac> unexpected ","
18:03:20 <lambdac> expecting letter or digit, operator or ")"
18:03:20 <lambdac> ambiguous use of a non associative operator
18:03:29 <ivanm> ^^ what's wrong with that that lambdac doesn't like it?
18:03:45 <Twey> Can't pattern-match in a lambda, I think
18:03:55 <mauke> ivanm: @pl doesn't support 3-tuples
18:04:03 * Twey blinks.
18:04:04 <Twey> Oh really
18:04:13 <ivanm> oh...
18:04:29 <BMeph> dcoutts: Hm, I guess I'll ask "the IT guys" about it, then.
18:04:35 <Trinithis> @pl \(c, b) -> (b,c)
18:04:35 <lambdac> uncurry (flip (,))
18:04:39 <Trinithis> @pl \(a, c, b) -> (b,c)
18:04:40 <lambdac> (line 1, column 7):
18:04:40 <lambdac> unexpected ","
18:04:40 <lambdac> expecting letter or digit, operator or ")"
18:04:40 <lambdac> ambiguous use of a non associative operator
18:04:49 <ivanm> because every size of an n-tuple is hard-coded into haskell manually?
18:05:06 <Twey> Erwhat?
18:05:12 <mauke> mostly because the standard library doesn't provide accessor functions
18:05:15 <Twey> It's not manual
18:05:19 <Twey> It's just magic
18:05:21 <mauke> like curry, uncurry, fst, snd, ...
18:05:29 <Cale> Prelude Language.Haskell.Interpreter.GHC> s <- newSession
18:05:29 <Cale> Prelude Language.Haskell.Interpreter.GHC> withSession s (eval "1 + 1 :: Integer")
18:05:29 <Cale> *** Exception: (unknown)
18:05:34 <SamB> Twey: look at Data.Tuple and then tell me that again okay?
18:05:37 <Cale> gwern: can you see anything wrong with that/
18:05:38 <Cale> ?
18:05:43 <ivanm> Twey: for all tuple sizes, they're all defined manually rather than having some generic n-tuple basis :s
18:05:43 <SamB> the source code, not the documentation
18:06:09 <Cale> Tuples are partly magic.
18:06:20 <Cale> The instances for them are not magic.
18:06:23 <gwern> Cale: well, besides the fact that the GHC API has never worked for me from ghci?
18:06:31 <Cale> gwern: oh...
18:06:41 <Cale> gwern: I'll try what I was trying outside ghci then.
18:06:45 <ivanm> see, if only ghc went and declared (A,(B,C)) to be isomorphic to (A,B,C)... ;-)
18:06:48 <ivanm> (etc.)
18:06:58 <SamB> ivanm: well, that would be wrong
18:07:02 <SamB> since _|_ messes it up
18:07:06 <ivanm> ahhhh
18:07:12 <ivanm> though mathematically they are, aren't they?
18:07:19 <ivanm> @slap _|_
18:07:19 * lambdac secretly deletes _|_'s source code
18:07:24 <Twey> SamB: Eh?
18:07:38 <Twey> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:07:39 <lambdac> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
18:07:39 <lambdac> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
18:07:39 <lambdac> t110 t111 t112 t113 t114 t115. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 ->
18:07:39 <lambdac> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 ->
18:07:42 <lambdac> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 ->
18:07:45 <lambdac> [4 @more lines]
18:07:45 * Twey blinks.
18:08:10 <ivanm> you asked for it, Twey...
18:08:11 <Trinithis> The instances for it are mantual. Tuples are built in
18:08:26 <SamB> Twey: actually look in GHC.Tuple, in the ghc-prim library...
18:08:27 <ivanm> though they use deriving, etc.
18:08:32 <sw17ch> Twey, one more comma would have broken it's poor back :(
18:08:37 <Twey> Hahaha
18:08:40 <Olathe> O-o
18:08:45 <Twey> But surely those aren't all hard-coded in?
18:08:48 <ivanm> what size n-tuples are they up to now?
18:08:51 <ivanm> Twey: yup, they are
18:08:55 <Twey> O.O
18:08:58 <Twey> Really?
18:09:01 <Twey> Cripes
18:09:03 <Trinithis> How far do they go then?
18:09:06 <ivanm> no, I'm lying... ;-)
18:09:10 <ddarius> No.
18:09:16 <ivanm> 35-tuples?
18:09:26 <Olathe> > repeat '.'
18:09:27 <lambdac>  "..............................................................................
18:09:39 <lispy> dons: ping?
18:09:49 <lispy> I have a bytestring question
18:09:49 <SamB> data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f
18:09:49 <SamB>  g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_
18:09:49 <SamB> n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
18:09:49 <SamB>  = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g
18:09:49 <SamB>  h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_
18:09:50 <SamB>  o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
18:09:54 <Cale> The data declarations for tuple types are wired in magic, but the instances of things like Eq are not.
18:09:58 <Stinger_> if you're using 35 tuples, you're probably doing something wrong :)
18:09:58 <SamB> {- Manuel says: Including one more declaration gives a segmentation fault.
18:10:01 <lispy> c'mon guys, that's a bit spammy
18:10:13 <SamB> Cale: they may be wired in, but it IS in ghc-prim still
18:10:17 <Cale> SamB: ah.
18:10:41 <SamB> And, uh, I'm not sure how wired-in they are anyway
18:10:41 <ivanm> where are they all defined in ghc?
18:10:47 <ivanm> SamB: what's ghc-prim?
18:10:55 <SamB> ivanm: libraries/ghc-prim/GHC/Tuple.hs
18:10:58 <Trinithis> Stringer_: But 35 tuples are perfect for my 35 Dimension coordinate simulator!
18:11:04 <ivanm> as in what does the prim mean?
18:11:07 <SamB> in a checked-out GHC tree
18:11:17 <ivanm> ahhhh
18:11:19 <EatenByGrues> I'm guess almost everyone uses haskell-mode in emacs? (or is there another editor thats popular for it?)
18:11:28 <EatenByGrues> ^guess^guessing
18:11:35 <ivanm> EatenByGrues: some people like that vi thingy...
18:11:37 * sw17ch uses VIM
18:11:39 <Trinithis> I like vi
18:11:39 <chrisdone> apparently vim does cool haskell stuff
18:11:44 <SamB> ivanm: well, it means "ultra-low-level GHC stuff"
18:11:48 <ivanm> ahhhh
18:12:01 <ddarius> EatenByGrues: People tend to use whatever editor they used before Haskell.
18:12:07 * sw17ch notes that ivanm has vi in his name
18:12:17 <ivanm> no, I have iv
18:12:18 <Trinithis> iv*
18:12:19 <ivanm> ;-)
18:12:25 <paczesiowa_> how about yi?
18:12:29 <chrisdone> {i,v} = {v,i}
18:12:30 <SamB> default () -- Double and Inteegr aren't available yet
18:12:35 <SamB> hmm, how'd that happen?
18:12:40 <thoughtpolice> EatenByGrues: yeah, haskell-mode is pretty nice stuff
18:12:40 <sw17ch> > (\[a,b,c,d,e] = [b,a,c,d,e]) "ivanm"
18:12:40 <lambdac>  Parse error at "=" (column 15)
18:12:53 <sw17ch> > (\[a,b,c,d,e] -> [b,a,c,d,e]) "ivanm"
18:12:54 <lambdac>  "vianm"
18:13:05 <ivanm> sw17ch: what, you're not going to get it to say vim?
18:13:11 <ivanm> ;-)
18:13:14 <sw17ch> > (\[a,b,c,d,e] -> [b,a,e]) "ivanm"
18:13:15 <lambdac>  "vim"
18:13:18 <Quadrescence> sw17ch: THANKS. YOU JUST SOLVED A PROBLEM OF MINE.
18:13:20 <Trinithis> Would it be cool if haskell supported sets and recognized {1, {1, 2}} as (1, 2)?
18:13:27 <sw17ch> Quadrescence, hah, no way
18:13:31 <Quadrescence> Seriously.
18:13:38 <EatenByGrues> thoughtpolice: I'm still not used to the way it handles indentation. I think I may be doing it wrong.
18:13:44 <sw17ch> hurrah for accidental assistance!
18:13:49 <thoughtpolice> i also think yi will be nice in the future too
18:13:53 <SamB> Quadrescence: what had you wanted to do?
18:14:00 <thoughtpolice> right now configuring it looks a little esoteric for the most part
18:14:03 <thoughtpolice> and there are some memory issues
18:14:21 <thoughtpolice> but the 0.4.1 release works regardless
18:14:28 <thoughtpolice> and isn't that bad from what I've used :)
18:14:31 <Quadrescence> SamB: Make a permutation function. My mind is actually lazily evaluating the situation. I assume he solved my problem, but I'll evaluate this assumption later.
18:15:14 <sw17ch> @index permute
18:15:14 <lambdac> Text.ParserCombinators.Parsec.Perm
18:15:28 <sw17ch> @index perm
18:15:28 <lambdac> bzzt
18:15:28 <ddarius> Trinithis: No.
18:15:59 <Quadrescence> sw17ch: It's not like the permute in whatever package it's in
18:16:03 <Quadrescence> or module.
18:16:58 <sw17ch> hehe
18:16:58 <sw17ch> alright
18:18:03 <Cale> Oh hey...
18:18:15 <Cale> the problem with runplugs magically fixed itself somehow...
18:18:20 <Cale> Odd...
18:18:27 <Cale> I'll get lambdabot in here asap :)
18:19:03 <Cale> Oh, it might have been that the thing I tried actually worked :)
18:19:44 <ddarius> "I made a change and my code suddenly started working!  It must be gremlins!"
18:19:49 <Trinithis> ddarius: I mean {{1}, {1, 2}}... I did it wrong earlier
18:20:34 <Trinithis> gtg
18:21:43 <Cale> ddarius: Well, it didn't work at first, but I think I'd forgotten to do an @undefine to rebuild L.o/L.hi
18:22:44 <sw17ch> is there a way for vi to have a terminal in a split window or tab? (emacs users, no snickering)
18:23:04 * jeffz snickers
18:23:13 <Cale> sw17ch: :sp file/to/load
18:23:18 <Cale> er
18:23:18 <Cale> oh
18:23:20 <mauke> sw17ch: no
18:23:22 <Cale> A terminal?
18:23:27 <Cale> No, I don't think so
18:23:28 <sw17ch> Cale, yes
18:23:30 <sw17ch> :(
18:23:34 <mrd> you can split the window ya
18:23:36 <mauke> sw17ch: documented in :h shell-window
18:23:36 <mrd> C-w n
18:23:48 <Cale> oh, maybe there is and I just don't know about it :)
18:23:53 <mrd> oh i see
18:23:55 * sw17ch grumbles about mrd not following directions :)
18:24:22 <mrd> yea, use screen
18:24:34 <mrd> C-a S
18:24:39 <Cale> Or use X :)
18:24:47 * BMeph isn't using emacs at the moment, so snickers extra for the barred ones
18:24:50 <Cale> (which is what I do)
18:25:10 <Quadrescence> Or use Geany
18:25:10 <Quadrescence> :D
18:25:16 * sw17ch frowns on BMeph's loophole
18:25:26 <Cale> Geany?
18:25:36 * BMeph chortles evilly at sw17ch's frown
18:25:44 <Quadrescence> Cale: Geany is a nice haskell editor.
18:25:51 <Cale> oh, that's interesting
18:26:10 <Cale> Is it on hackage?
18:26:13 <edward1> Hey, does anyone know of any research on using hash-consing during gc in a lazy setting? Something like http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.105 but for say, the spineless tagless g-machine.
18:26:14 <lambdac> Title: Hash-consing Garbage Collection - CiteSeerX
18:26:51 <Quadrescence> It syntax highlights, tell all your functions, has a terminal, "scratchpad," compiler messages (separate from the terminal), status and whatev at the bottom.
18:26:52 <Quadrescence> :))
18:27:03 <Quadrescence> It's actually for general programming./
18:27:06 <TomMD> I must stop reading logic papers.  I just wrote the days of the week as "Sunday Monady Tuesday..."
18:27:11 <Quadrescence> But, nonetheless, it has nice haskell support.
18:27:17 <edward1> I think I have a hack for using a small bloom filter to conservatively avoid trying to hash cons cyclic structures
18:27:19 <Quadrescence> Even supports projects.
18:27:27 <jcreigh> hey, can anyone connect to haskell.org? It's timing out for me.
18:27:44 <mauke> http://downforeveryoneorjustme.com/haskell.org
18:27:45 <NaN_n_Curry> timing out for me, too
18:27:51 <lambdac> Title: Huh?
18:27:54 * BMeph enjoys Notepad++
18:27:55 <Quadrescence> Cale: Want a screen shot? :)
18:28:13 <paczesiowa_> Quadrescence: I do
18:28:16 <Quadrescence> Okay
18:28:18 <jcreigh> mauke: nice!
18:28:22 <sw17ch> BMeph, o_O
18:28:37 <Cale> > 1 + 1
18:28:39 <lambdac>  2
18:28:41 <Cale> @bot
18:28:41 <lambdac> :)
18:28:47 <lambdabot>  2
18:28:49 <lambdabot> :)
18:28:51 <Cale> > describeSequence [1,1,2,3,5]
18:28:54 <lambdac>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
18:29:03 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
18:29:08 <mauke> lambdabot: @seen me
18:29:13 <lambdabot> I haven't seen me.
18:29:14 * sw17ch enjoys the botrace
18:29:46 <NaN_n_Curry> > 8*12
18:29:47 <lambdac>  96
18:29:48 <paczesiowa_> let's race them to last [1..]
18:29:53 <Cale> lambdabot is still connecting to channels, so it's slow... we'll see how it goes once it's done :)
18:29:55 <lambdabot>  96
18:30:05 <paczesiowa_> > last [1..]
18:30:07 <NaN_n_Curry> k00lne55
18:30:13 <lambdabot>  Tried to use too much memory
18:30:19 <BMeph> ...
18:30:27 <paczesiowa_> w/o ?
18:30:41 <TomMD> > const "Pong" "Ping"
18:30:49 <lambdabot>  "Pong"
18:31:10 * BMeph works with someone named "Phon Pin"...
18:31:17 <lambdac> Terminated
18:31:18 <ski> lambdabot: @run ()
18:31:18 <lambdac>  "Pong"
18:31:27 <lambdabot>  ()
18:31:28 <Cale> I should maybe just possibly remove some channels from its list :)
18:31:56 <Cale> Like #haskell-hac4 for instance :)
18:32:01 <mauke> @version
18:32:01 <lambdac> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.00GHz)
18:32:01 <lambdac> darcs get http://code.haskell.org/lambdabot
18:32:02 <lambdabot> lambdabot 4.1
18:32:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:32:03 <lambdac> Title: Index of /lambdabot
18:32:05 <Olathe> > let 2 + 2 = 5 in 2 + 2
18:32:06 <lambdac>  5
18:32:07 <lambdabot>  5
18:32:14 <Olathe> Yay ! An echo !
18:32:40 <mauke> http://google.com/
18:32:42 <lambdac> Title: Google
18:32:50 <mauke> no title in lambdabot?
18:33:17 <ski> lambdabot: @google Google
18:33:36 <mauke> lambdabot: @hoogle map
18:36:30 <sw17ch> > cycle "echo "
18:36:31 <lambdac>  "echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo ...
18:36:32 <lambdabot>  "echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo ...
18:36:33 <Cale> lispy: your DNS server seems to be really slow/missing
18:36:51 * sw17ch likes OpenDNS
18:37:26 <lispy> Cale: ah, not surprisng
18:37:49 <Quadrescence> Cale: paczesiowa (he disconnected I guess) --> screen shot (with my quick annotations of FeAtUrEs) http://i34.tinypic.com/jrpnck.png
18:38:17 <Quadrescence> Again, it supports several languages.
18:40:39 <lispy> Cale: if you have a better IP address for me to use I could try updating resolv.conf
18:41:12 <Cale> You could try 18.18.18.18
18:41:56 <Cale> nameserver 64.71.255.198
18:42:00 <Cale> is what I'm using here
18:42:33 <Olathe> I like how the Google search thing on that site doesn't work.
18:42:44 <Cale> Not sure if that's ISP-specific though.
18:42:58 <lispy> Cale: I updated it
18:43:14 <Cale> okay, now it works :)
18:43:22 <Cale> @google haskell
18:43:30 <Cale> http://www.haskell.org/
18:43:37 <lambdac> Plugin `search' failed with: thread killed
18:43:40 <lambdabot> Plugin `search' failed with: thread killed
18:43:40 <Cale> hmm
18:43:48 <Cale> ... heh
18:44:00 <Cale> http://www.haskell.org/
18:44:07 <Cale> huh
18:44:41 <Cale> oh
18:44:47 <Cale> haskell.org seems down...
18:45:26 <Cale> http://xkcd.com/
18:45:27 <lambdac> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
18:45:37 <Botje> next time give me PR faster/ll quadr
18:45:39 <Botje> argh
18:45:46 <Cale> lambdac appears to be running on a faster connection ;)
18:45:57 <Cale> @bot
18:45:57 <lambdac> :)
18:45:58 <lambdabot> :)
18:45:59 <Cale> hmm
18:46:04 <sw17ch> > round 8.03
18:46:05 <lambdac>  8
18:46:06 <lambdabot>  8
18:46:09 <Cale> Or lambdabot didn't attempt that at all
18:46:22 <Cale> I wonder if it has to be restarted.
18:46:34 <Cale> For the changes in resolv.conf to take effect.
18:46:43 <Botje> nah
18:46:48 <Botje> but maybe the process has to
18:46:51 <sw17ch> resolv.conf is immediate
18:46:56 <Botje> or if it's hanging on a previous dns request
18:47:08 <solrize> no hpaste?
18:47:19 <solrize> i made up a joke
18:47:21 <solrize> http://hpaste.org/9603
18:48:13 <solrize> aww the formatting is awful
18:48:16 <stepcut> solrize: your jobe needs better formatting
18:48:22 <solrize> yeah
18:49:01 <solrize> think they'll kill me if i put it on the haskell wiki?
18:49:58 <shapr> Cale: ?
18:50:53 <Cale> shapr: yeah?
18:52:15 <dcoutts> hmm, haskell.org seems to be down completely
18:53:15 <Cale> heh, the latest http://picturesforsadchildren.com/ is good :)
18:53:16 <lambdac> Title: pictures for sad children
18:53:30 <lambdabot> Title: pictures for sad children
18:53:40 <Cale> hmm... okay, so the title plugin *is* working
18:56:23 <mauke> http://mauke.ath.cx/tmp/dev2.html
18:56:25 <lambdac> Title: http://mauke.ath.cx/tmp/dev2.html Developers Developers Developers Developers De ...
18:56:38 <mauke> what, no loop?
18:58:04 <Cale> The title plugin is too sporadic for that :)
19:06:19 * sw17ch needs to work on the PortAudio library a bit more
19:06:25 <sw17ch> it doesn't know how to fail gracefully yet
19:09:05 <Quadrescence> > zipWith (*) [1..10] [11..20]
19:09:06 <lambdac>  [11,24,39,56,75,96,119,144,171,200]
19:09:07 <lambdabot>  [11,24,39,56,75,96,119,144,171,200]
19:09:38 <mauke> lambdac @part
19:09:45 <mauke> lambdac: @part
19:09:45 <lambdac> Not enough privileges
19:10:16 <Cale> lambdac: @part
19:10:16 <lambdac> Not enough privileges
19:10:18 <Cale> hmm
19:10:29 <mauke> dibblego: is this your bot?
19:10:42 <dibblego> yes
19:12:02 <blbrown> haskell.org is down again.  Or at least is not working for me
19:12:12 <mauke> it's down
19:12:56 <Twey> Someone needs to fix that thing :(
19:13:51 <TomMD> Is there an auxiliary library for Chan (from Control.Concurrent.Chan)?  I would think others would want broadcast writes and non-blocking reads in a library, and not force app writers to do it.
19:14:22 <Quadrescence> hrm, uncurry (a,b) = a b, right? Or how to I correctly use uncurry?
19:14:28 <mauke> @src uncurry
19:14:29 <lambdabot> uncurry f p = f (fst p) (snd p)
19:14:34 <Quadrescence> ok
19:14:47 <mauke> > uncurry (+) (2,3)
19:14:49 <lambdabot>  5
19:15:28 <Spark> uncurry (+) is a version of (+) that takes a pair
19:15:50 <mauke> @type uncurry id
19:15:51 <lambdabot> forall b c. (b -> c, b) -> c
19:15:53 <mauke> @. djinn type uncurry id
19:15:55 <lambdabot> Plugin `compose' failed with: Prelude.tail: empty list
19:16:02 <mauke> :-|
19:16:13 <lambda_the_insig> is haskell.org down?
19:17:26 <blbrown> lambda_the_insig, yea, I brought it up just now.  Maybe they should use a haskell server.
19:19:25 <TomMD> > forever $ threadDelay 1000000 >> putStrLn "yes, haskell.org is down" -- too bad lambda bot rejects IO.
19:19:26 <lambdabot>   Not in scope: `threadDelay'
19:19:55 <TomMD> @module+ Control.Concurrent
19:19:56 <lambdabot> Unknown command, try @list
19:19:57 <Quadrescence> > replicate 0 5
19:19:59 <lambdabot>  []
19:20:01 <Quadrescence> > replicate 5 0
19:20:03 <lambdabot>  [0,0,0,0,0]
19:20:08 <SamB> blbrown: what do you mean by "brought it up"
19:20:17 <Olathe> > replicate 5 replicate
19:20:18 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
19:20:18 <lambdabot>                ...
19:20:29 <shepheb> > replicate 0 undefined
19:20:31 <lambdabot>  []
19:20:38 <Olathe> > replicate 5 (.)
19:20:40 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
19:20:40 <lambdabot>                ...
19:20:45 <Olathe> What is that ?
19:21:20 <blbrown> SamB:  "I brought it up just now. "  Oops, I meant mentioned in English parlance.
19:21:48 <SamB> blbrown: well, that's why I asked ;-)
19:22:11 <SamB> I don't know who exists near the "on" button or what-have-you
19:23:08 <vininim> @import Control.Concurrent
19:23:09 <lambdabot> Unknown command, try @list
19:23:14 <vininim> >import Control.Concurrent
19:23:27 <Olathe> @list
19:23:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:23:56 <vininim> > threadDelay 10 >> return 1
19:23:57 <lambdabot>   Not in scope: `threadDelay'
19:26:03 <TomMD> Does anyone have a recommendation for Single writer / multireader channels that allow broadcast messages?  The options I see include:
19:26:03 <TomMD> a) STM + a little hackery -- inefficient for what I want and uglier than it should need to be
19:26:03 <TomMD> b) Many Chans -- I'd have to do 'N' writes to get the message to 'N' threads.  A library could cover this up, but it wouldn't go away.
19:26:03 <TomMD> Am I missing an obvious solution?
19:26:40 <edwardk> tommd: in haskell or in general?
19:26:54 <TomMD> edwardk: In Haskell
19:28:12 <TomMD> I want a single writer Haskell thread to communicate an updated state to 'N' worker threads.  I don't want the state to sit in STM and be re-read on every unit of operation for efficiency reasons.
19:32:48 <TomMD> Ok, I am missing something obvious.  "dupChan", which I didn't see in the jumbed google cache of the Control.Concurrent haddock.
19:35:18 <stepcut> @pl \e -> f x >>= g >>= h
19:35:18 <lambdabot> const (f x >>= g >>= h)
19:35:24 <stepcut> @pl \x -> f x >>= g >>= h
19:35:24 <lambdabot> (h =<<) . (g =<<) . f
19:36:31 <Olathe> @. unpl pl \e -> f x >>= g >>= h
19:36:32 <lambdabot> (\ _ -> ((f x) >>= g) >>= h)
19:45:19 <sw17ch> i have a tricky question
19:45:42 <sw17ch> do { a <- a'; b <- b'; c <- c'; return b; }
19:45:49 <sw17ch> a, b, or c may fail
19:46:11 <sw17ch> i want to return Just b if they all succeed, or Nothing if any fails
19:46:23 <sw17ch> i'm not entirely sure how to do that
19:46:39 <sw17ch> a',b', and c' return Either's
19:46:46 <sw17ch> Left representing failure
19:47:14 * stepcut wonders how much lost productivity this haskell.org outage is causing
19:47:45 * sw17ch suggests we mirror it somewhere
19:48:03 <jeffz> i've tried to use hoogle about 5 times since it went down
19:48:28 <dibblego> @hoogle Either a b -> Maybe b
19:48:29 <lambdabot> A Hoogle error occurred.
19:48:35 <dibblego> @djinn Either a b -> Maybe b
19:48:36 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
19:48:56 <dibblego> sw17ch, you want that function, then just use bind as you are doing
19:50:08 <sw17ch> dibblego, i dont suppose Either is an instance of Monad where fail x = Left x
19:50:12 <TomMD> Shocking lesson for tonight: I can't use Chans in the same way I use STM Queues.
19:50:36 <dibblego> > fail 7 :: Either Int Int
19:50:37 <lambdabot>   add an instance declaration for (Num String)
19:50:48 <dibblego> > fail "7" :: Either String String
19:50:50 <lambdabot>  Left "7"
19:51:19 <sw17ch> where is the Monad instance defined?
19:51:20 <TomMD> > fail "bad" :: Either String (Int, String, Int -> Int)
19:51:22 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
19:51:22 <lambdabot>                ...
19:51:35 <sw17ch> it's not in Data.Either
19:51:50 <TomMD> Control.Monad.Either?
19:52:01 <mauke> *Error
19:52:18 <sw17ch> :(
19:52:24 <sw17ch> TomMD, doesn't look like it
19:52:32 <TomMD> I ment error, as mauke corrected.
19:52:37 <sw17ch> oh!
19:53:35 <sw17ch> kinda sucks that the fail needs to be a string rather than an instance of Show
19:53:43 <sw17ch> :(
19:54:02 <sw17ch> or is there a very good reason for that
19:54:29 <twanvl> > show "my error message"
19:54:31 <lambdabot>  "\"my error message\""
19:54:40 <sw17ch> twanvl, good point
19:55:14 <sw17ch> @type fail undefined :: Either String (Int,Int,Int)
19:55:16 <lambdabot> Either String (Int, Int, Int)
19:55:19 <sw17ch> neato
19:55:30 <sw17ch> @type fail undefined :: Either Int (Int,Int,Int)
19:55:31 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:56:04 <sw17ch> oh...
19:56:05 <TomMD> @type fail
19:56:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
19:56:08 <sw17ch> @info Error
19:56:09 <lambdabot> Error
19:56:13 <sw17ch> hehehe
19:56:16 <sw17ch> class Error a where
19:56:40 <TomMD> So for (Either Int) to give an error on fail you would neat to have a function :: String -> Int
19:56:45 <TomMD> and have it sensible.
19:57:25 <TomMD> "give an error" meaning, to give "Left #"
19:58:00 <TomMD> It shouldn't be hard to write your own instance, if you wanted.
19:58:15 <sw17ch> TomMD: i'm trying to figure out what noMsg is supposed to do
19:58:20 <sw17ch> also strMsg
19:58:30 * sw17ch wants haskell.org back :(
19:58:42 <twanvl> fail e = Left (strMsg e)
19:58:49 <twanvl> mzero = noMsg
19:59:14 <sw17ch> > fail "Hello" :: Either String Int
19:59:16 <lambdabot>  Left "Hello"
20:00:15 <sw17ch> TomMD: what would a sensible String -> Int be?
20:00:26 <twanvl> show?
20:00:42 <sw17ch> twanvl, somehow i'm reading that as 'read'
20:00:56 <twanvl> oops, that is the other way around
20:01:21 <sw17ch> hmm... i think this is starting to make a little more sense
20:02:29 <twanvl> The only types beside String which make sense with the Either monad are things like ParseError and Exception which can contain string messages
20:02:49 <sw17ch> yeah, i'm seeing that now
20:02:59 <sw17ch> well, this clears things up...
20:03:17 <sw17ch> it's funny how when i think something would be useful to have, Haskell magically has it
20:06:45 <sw17ch> :t liftM
20:06:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:09:01 <jamii> My god I hate undefined exceptions. Is there any sane way to track them down?
20:11:10 <twanvl> jamii: are you using ghci?
20:11:16 <jamii> Yep
20:11:39 <jamii> Although I think some of the code behind this is compiled because its using unboxed tuples
20:11:40 <twanvl> then :set -fbreak-on-error
20:11:56 <twanvl> that will take you into the debugger at the point of the exception
20:12:50 <jamii> Thanks. Ill go look up the debugger manual
20:14:02 <twanvl> you could also try using (error "something more descriptive") instead of undefined
20:16:00 <jamii> tawnvl: I havent used undefined in my own code. Im not sure where its coming from
20:17:50 <jamii> *Test.GMap> :trace
20:17:50 <jamii> *** Exception: Prelude.undefined
20:17:52 <jamii> Oh dear
20:31:52 <paczesiowa> @tell Quadrescence thx for screenshot, looks interesting, I'll check it out later
20:31:52 <lambdabot> Consider it noted.
20:32:30 <paczesiowa> @hoogle ()
20:32:30 <lambdabot> A Hoogle error occurred.
20:32:36 <paczesiowa> > ()
20:32:38 <lambdabot>  ()
20:32:48 <paczesiowa> eval works!
20:35:45 <sw17ch> does fail "bubble" ?
20:36:13 <twanvl> What do you mean?
20:36:21 <sw17ch> hmm...
20:36:30 <sw17ch> f :: IO A
20:36:33 <sw17ch> g :: IO B
20:36:37 <paczesiowa> in maybe and either yes
20:36:50 <sw17ch> h :: IO (Either String X)
20:37:00 <sw17ch> data X = A | B
20:37:29 <sw17ch> f >> g >> return (Just B)
20:37:30 <sw17ch> is in h
20:37:46 <sw17ch> if f or g fails, does h return Left instead of failing out of the program?
20:38:14 <twanvl> No, if f or g fails it calls  fail :: IO a, i.e. it calls IO's fail
20:38:21 <sw17ch> :(
20:38:27 <paczesiowa> it will throw IO exception
20:38:56 <sw17ch> the thing is, i have 3 of these layers
20:39:02 <paczesiowa> use ErrorT and purify f and g
20:39:04 <twanvl> In cases such as this, the cleanest solution is to generalize the types
20:39:33 <paczesiowa> catch IO exceptions and throw pure Lefts
20:39:43 <twanvl> f :: MonadIO m => m A
20:39:58 <sw17ch> is catch/throw frowned upon in haskell, or is it "normal"
20:40:18 <paczesiowa> I don't like it
20:40:48 <dons> is haskell.org down for everyone or just me?
20:40:54 <dons> sw17ch: for IO , it is normal.
20:41:04 <sw17ch> dons: it's been down for a while
20:41:05 <dons> throw is fairly rare, usually only for async message passing scenarios
20:41:05 <twanvl> http://downforeveryoneorjustme.com/haskell.org
20:41:09 <paczesiowa> gods gave us typesystem powerful enough to use monads so we don't have to use unpure exceptions
20:41:11 <lambdabot> Title: Huh?
20:41:22 <dons> twanvl: and i got "doesn't look like a site on the interwho"
20:41:27 <dons> which isn't a good sign.
20:41:43 <paczesiowa> dons: don't you prefer ErrorT e IO ?
20:42:43 <twanvl> For quick and dirty programs using exceptions can be easier, but it quickly leads to a mess of IO code
20:43:15 <paczesiowa> in quick and dirty programs you don't catch exceptions
20:43:21 <dons> paczesiowa: I usually use handle/catch
20:43:30 <paczesiowa> that's why they're dirty:)
20:43:33 <dons> in quick and dirty things i often use bracket.
20:43:36 * sw17ch is hoping not to quick-and-dirty
20:43:43 <dons> bracket (open) (close) $ do hack it
20:43:56 <dons> making dirty things a little cleaner, one idiom at a time.
20:44:16 <paczesiowa> last step being...
20:45:24 <dons> bracket is a really useful thing to learn inside out.
20:45:42 <dons> bracket
20:45:43 <dons>         (openTempFile "/tmp" "ghc-core-XXXX.hcr")
20:45:43 <dons>         (\(f,h) -> do hClose h
20:45:43 <dons>                       removeFile f
20:45:46 <dons>                         ...)
20:45:51 <dons>           $ do hack on the temp file
20:46:11 <dons> usual shell script stuff, but exception ready, and shorter than trying to do it manually
20:47:21 <twanvl> we really should have with* functions in the standard library for all open/close pairs
20:47:44 <dons> like withFile ?
20:48:03 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
20:48:03 <dons> withFile name mode = bracket (openFile name mode) hClose
20:49:33 <twanvl> exactly; and for your example, withTempFile
20:49:48 * stepcut has withTempDir somewhere
20:50:04 <paczesiowa> it'd be nice to have some funky operators for bracket-like functions e.g. openFile name mode .> foo <. hClose
20:50:28 <stepcut> http://src.seereason.com/haskell-unixutils/System/Unix/Directory.hs
20:50:31 <lambdabot> http://tinyurl.com/5d4772
20:50:43 <twanvl> paczesiowa: that seems like unnecessary obfuscation when we already have bracket
20:51:04 <dons> .> is kind of cute though
20:51:12 <dons> for critical sections
20:51:24 <dons>  start !!!--> critical <--!!! end
20:51:25 <dons> :)
20:51:37 * stepcut things .> is <. too cool to use just for bracket
20:51:48 <dons> ?let (!!!-->) = id
20:51:49 <lambdabot> Defined.
20:51:50 <stepcut> s/things/thinks/
20:51:51 <sw17ch> what about the googly eyes operator
20:51:51 <paczesiowa> I mean we say "(x)" not "parens x"
20:51:56 <sw17ch> o_O
20:52:02 <dons> > (* 2) !!!--> 7
20:52:03 <lambdabot>  14
20:52:30 <dons> mixfix syntax is underappreciated in haskell
20:52:57 <paczesiowa> that's why I love Control.Applicative stuff for using with parsec instead of parens/brackets
20:53:16 <twanvl> paczesiowa: indeed, Applicative is great
20:53:24 <paczesiowa> char '(' *> p <* char ')"
20:53:39 <paczesiowa> this spells verbatively "between"
20:53:49 <paczesiowa> instead of
20:54:00 <paczesiowa> between (char '(') (char ')') p
20:54:31 <twanvl> but bracket is hardly used at all, and if it is, it is likely to contain a do block. So we shouldn't waste operators on it.
20:54:52 <Twey> 045239 < sw17ch> what about the googly eyes operator
20:54:52 <Twey> 045244 < sw17ch> o_O
20:54:59 <Twey> That's not a valid operator!
20:55:13 <paczesiowa> we can make those operators general enough so they're not associated with bracket
20:55:14 <twanvl> but it is a valid function...
20:55:28 <dons> maybe for a shell scripting EDSL
20:55:50 <sw17ch> (*)_(*)  ?
20:55:57 <sw17ch> (*)-(*)  ?
20:56:08 <paczesiowa> dons: you use that h4sh?
20:56:13 <sw17ch> (*)^(*)  <-- broken glasses operator
20:56:26 <twanvl> sw17ch: still not a valid operator
20:56:34 <sw17ch> :(
20:56:44 <sw17ch> i guess i'm not familiar with the requirements
20:56:45 <stepcut> let (<*>-<*>) = id
20:56:51 <sw17ch> ah, the parens
20:56:55 <stepcut> <*>-<*> is valid
20:57:12 <sw17ch> let (@^@) = id
20:57:13 <sw17ch> ?
20:57:23 <dons> paczesiowa: not recently
20:57:49 <paczesiowa> haskell shell would be great
20:58:00 <paczesiowa> but it can't be haskell
20:58:05 <stepcut> haskell shell needs GHC 6.10 I think
20:58:08 * twanvl has once written a program for printing Trees, that used (+-+-+) and (/-+-\) as names of predifined styles
20:58:14 <paczesiowa> cd "dir" is unacceptable
20:58:43 <paczesiowa> stepcut: cd [| dir |] ?
20:59:01 <paczesiowa> still easier in bash
20:59:52 <bwr> how can i convert a string to a list of its ascii values
20:59:58 <twanvl> paczesiowa: it could be something like that XML template thing (HXL?), where you use an escape to include haskell code
21:00:06 <twanvl> > ord 'A'
21:00:08 <lambdabot>  65
21:00:09 <paczesiowa> > map ord "hello wordl"
21:00:11 <lambdabot>  [104,101,108,108,111,32,119,111,114,100,108]
21:00:14 <bwr> cool
21:00:15 <bwr> thanks a lot
21:00:47 <bwr> @src ord
21:00:47 <lambdabot> Source not found. :(
21:00:51 <paczesiowa> twanvl: I'm not going to escape anything just to change directory
21:01:10 <paczesiowa> bwr: Data.Char I think
21:01:20 <bwr> paczesiowa: thanks, i can't seem to get haskell.org to load righ tnow
21:01:47 <bwr> hmm
21:01:55 <twanvl> paczesiowa: what I mean is that you can have normal shell comands, in some domain specific shell language, while having a way to escape to haskell mode for arbitrary expressions
21:02:04 <bwr> now i am getting can't match expected type [Char] against inferred Maybe [Char]
21:02:31 <paczesiowa> bwr: paste some code
21:02:39 <bwr> oops
21:02:41 <bwr> i see what i did
21:02:49 <bwr> really silly
21:03:04 <lispy> just add fromJust ;) (no, please don't just teasing...)
21:03:23 <bwr> it wasn't even supposed to be in a maybe
21:03:43 <lispy> > fromJust Nothing
21:03:45 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:03:53 <paczesiowa> twanvl: I'd have to see some example
21:03:56 <bwr> i was trying to examine the "Just \"Another Haskell Hacker\"" that some people were playing with earlier
21:03:59 * lispy huggles lambdabot
21:04:04 <bwr> but i left off the exterior "s
21:04:57 <lispy> > fromJust . read $ "Just \"Another Haskell Hacker\""
21:04:59 <lambdabot>  Exception: Prelude.read: no parse
21:05:17 <twanvl> paczesiowa: it is just a vague idea, really
21:05:29 <lispy> I really expected that to work
21:05:34 <twanvl> > fromJust . read $ "Just \"Another Haskell Hacker\"" :: String
21:05:36 <lambdabot>  "Another Haskell Hacker"
21:05:54 <lispy> :t fromJust . read
21:05:55 <lambdabot> forall a. (Read a) => String -> a
21:06:16 <lispy> Oh
21:06:18 <lispy> I get it
21:06:23 <paczesiowa> :t read
21:06:24 <lambdabot> forall a. (Read a) => String -> a
21:06:34 <lispy> The problem is that it tries to parse the inner string
21:07:00 <lispy> A little odd taht it doesn't realize it's a string, maybe lambdabot has some defaulting for a?
21:07:39 <twanvl> > fromJust . read $ "Just ()" -- the default is ()
21:07:40 <lispy> aye yup, ghci complains
21:07:42 <lambdabot>  ()
21:08:10 <lispy> is there a way to get a bunch of modules to load by default in ghc without them being listed in the prompt?
21:08:52 <lispy> I tend to want the same setting as lambdabot, or maybe I should install goa again
21:09:04 <twanvl> you could probably put the import statements in your .ghci file
21:09:09 <paczesiowa> isn't there .ghci file?
21:10:36 <lispy> how how to fix my prompt?
21:10:48 <lispy> haskell.org is down
21:10:51 <lowki_> paczesiowa: .hi
21:11:12 <paczesiowa> lowki_:hello
21:11:22 <lowki_> file extension
21:11:28 <paczesiowa> :D
21:12:04 <lowki_> yep :)
21:12:46 <twanvl> :set prompt X>
21:13:05 <paczesiowa> > :set prompt X>
21:13:05 <lambdabot>  Parse error at end of input
21:13:17 <paczesiowa> @set prompt X>
21:13:18 <lambdabot>  Parse error
21:13:27 <lispy> trippy
21:13:28 <lispy> thanks
21:14:37 <lispy> Hmm
21:14:55 <lispy> The original prompt gives a space after the >, how do I get that back?
21:15:14 <lowki_> yea its all about the trippy haskell shrooms
21:15:20 <lowki_> :)
21:15:40 <lispy> grr...why is haskell.org not responding again today
21:15:45 <lispy> This is getting old..
21:16:08 <dons> i've contacted yale, but they are sleeping, of course.
21:16:13 <lowki_> psychadelics are one of the biggest problems in machine intelligence research. how does one recreate such effects?
21:16:21 <dons> we need mirrors.
21:16:22 <slava> does haskell.org run on a haskell application server?
21:16:34 <dons> slava: no, it's just mediawiki running in apache.
21:16:40 <lispy> hey slava, how's it going?
21:16:59 <paczesiowa> we dodged a bullet there:>
21:17:01 <dons> it gets hammered in waves, now and again, as bots go and index everything.
21:17:03 <geezusfreeek> dangit, i was wanting to finally sit down and try playing with NDP, but haskell.org had to go and screw up
21:17:05 <twanvl> lispy: you can use quotes
21:17:08 <lispy> dons: yeah, we need someone expert in weird configuration glitches to come in and properly diagnosis it I guess
21:17:17 <slava> dons: time to port mediawiki to haskell :)
21:17:28 <dons> well, apache famously locks up on some weird cases
21:17:38 * lispy nods
21:17:45 <lispy> twanvl: thanks, I'll try that
21:17:48 <SamB_XP> why do we use apache anyway?
21:17:50 <dons> well, php isn't the most speedy of systems.
21:18:03 <lispy> twanvl: rock on!
21:18:04 <sw17ch> i'm having a rough time understanding what ErrorT is for
21:18:11 <SamB_XP> are there not other servers that don't do that?
21:18:13 <slava> is there an http server in haskell which supports ssl?
21:18:23 <lispy> mediawiki has a very functional design even if it's not in a functional language.
21:18:43 <lispy> sw17ch: iirc, it's for transforming between instances of MonadError
21:18:44 <dons> slava: i suspect happs does.
21:19:06 <sw17ch> i'm really having a hard time finding an elegant way to do this...
21:19:06 <paczesiowa> sw17ch: for pure exceptions in IO
21:19:17 <paczesiowa> sw17ch: do what?
21:19:22 <dons> seems like we should take regular dumps of haskell.org's wiki, and mirror them on say, a chalmers server.
21:19:26 <sw17ch> i have a long sequence of actions
21:19:33 <sw17ch> any step may fail
21:19:49 <paczesiowa> sounds like ErrorT
21:20:07 <sw17ch> i don't really want to have to check for Left/Right each time i pass the value onto the next step
21:20:09 <geezusfreeek> how long does it usually take to bring haskell.org back up in these cases?
21:20:14 <lispy> dons: what if we did something really low tech like restarting apache every 10 hours?
21:20:23 <geezusfreeek> and who does it?
21:20:31 <sw17ch> paczesiowa, does ErrorT rely on "error"?
21:20:31 <lispy> dons: er...I should ask how you guys usually whip it back into shape
21:20:32 <SamB_XP> isn't ErrorT the T version of Either?
21:20:45 <paczesiowa> sw17ch: no
21:20:56 <paczesiowa> SamB_XP: yes
21:21:02 <sw17ch> i guess i'd need to see an example
21:21:12 * sw17ch might have found one
21:21:26 <geezusfreeek> isn't it basically like an Either version of the Maybe monad?
21:21:27 <dons> lispy, well it doesn't even come close to locking up that often.
21:21:34 <geezusfreeek> i haven't actually used it before
21:21:35 <paczesiowa> geezusfreeek: yes
21:21:36 <dons> haskell.org crashes maybe 3 times a year
21:21:41 <sw17ch> paczesiowa, throwError?
21:21:51 <lispy> dons: hm...but wasn't it goofed up last night too?
21:21:55 <dons> hackage.
21:22:01 <geezusfreeek> i must hit it every time it goes down
21:22:03 <dons> due to bandwidth. different server.
21:22:07 <geezusfreeek> oh, hackage
21:22:09 <paczesiowa> sw17ch: throwError is just return . Left
21:22:16 <lispy> dons: oh, I see.  I tend to lump them together.
21:22:20 <paczesiowa> sw17ch: it is nice and pure
21:22:20 <geezusfreeek> which runs on happs!
21:22:23 <dons> hackage is getting hammered harder each day, as more people pull code from it.
21:22:29 <dons> geezusfreeek: no, hackage doesn't run on happs.
21:22:36 <dons> its just apache + cgi, currently.
21:22:40 <geezusfreeek> i thought it did
21:22:43 <lispy> dons: uh oh, sounds like you're not properly avoiding success
21:22:49 <geezusfreeek> oh, maybe i'm just thinking of a rewrite somebody is trying
21:22:58 <dons> yep.
21:23:59 <lispy> ya know, ghci is really impressive
21:24:17 <lispy> ghc in general is really high quality software
21:24:18 <sw17ch> paczesiowa, i think i get it now... i'll resume this tomorrow
21:24:19 <sw17ch> thanks
21:25:31 <lispy> I should install 6.8.3
21:25:54 <lispy> is there anyway to get it for osx besides haskell.org?
21:26:10 <dons> the .dmg for ghc on the mac?
21:26:13 <dons> maybe on chak's site.
21:26:50 <paczesiowa> sw17ch: http://hpaste.org/9604 some example
21:27:05 <lispy> dons: is this what you are thining of? http://www.mail-archive.com/haskell@haskell.org/msg21182.html
21:27:23 <paczesiowa> hpaste cuts code:/
21:27:37 <dons> maybe, lisyp.
21:29:19 <geezusfreeek> lispy: macports has 6.8.3
21:29:19 <lispy> It seems like I installed from a tarball before, but maybe not
21:29:36 <lispy> geezusfreeek: I have to compile it though right?  and will it give me profiled copies?
21:29:39 <geezusfreeek> oh, but it may download from haskell.org
21:29:58 <sw17ch> paczesiowa, http://hpaste.org/9605
21:30:03 <sw17ch> that's the condition i'm dealing with
21:30:20 <geezusfreeek> you do have to compile it. i dunno about profiling libs, but that can be got by using cabal-install to upgrade things anyway
21:30:29 <paczesiowa> sw17ch: gimme a minute
21:30:39 <dons> is haskell.org back up?
21:30:44 <dolio> @pl (1/)
21:30:45 <lambdabot> (1 /)
21:30:45 <dons> Paul just said that he can get to it from Yale.
21:30:58 <geezusfreeek> i can't here in alabama
21:30:58 <dons> hmm, I can't get to it.
21:31:00 <sw17ch> Grand Rapids, MI says no
21:31:03 <lispy> oh, I meant to ask...does cabal-install install profile stuff by default or can I mae that a default?
21:31:19 <dons> dns problem?
21:31:19 <geezusfreeek> it can probably be made to by default, but i just use the -p flag
21:31:19 <lispy> dons: no dice
21:31:34 <geezusfreeek> what is the ip?
21:31:45 <lispy> $ ping haskell.org
21:31:45 <lispy> PING haskell.org (128.36.229.215): 56 data bytes
21:31:53 <geezusfreeek> resolves to 128.36.229.215 for me
21:31:58 <lispy> 100% packet loss
21:32:15 <geezusfreeek> dons: ask Paul what the ip is for him
21:32:41 <lispy> that file I downloaded was a .pkg and I don't know what do with it nor does my mac
21:33:04 <sw17ch> paczesiowa, i just figured out what i needed... i think
21:33:29 <lispy> oh, tiger-.dmg that's probably what I should grab
21:33:30 <sw17ch> @index liftIO
21:33:31 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:33:46 <sw17ch> well, sortof
21:34:58 <paczesiowa> sw17ch: just change all the types to ErrorT String IO Int
21:36:04 <lispy> huh, chak's page had a "haskell-style" that was a style for latex
21:36:08 <lispy> But it's missing now
21:36:14 <lispy> I wonder if it was any good
21:36:25 <lispy> actually, what is an easy to install way to type set haskell?
21:36:40 <lispy> Preferrably something I can drop into the same directory as my .tex and have latex pickup
21:36:41 <paczesiowa> @src fail
21:36:42 <lambdabot> fail s      = error s
21:37:21 <paczesiowa> @src fail :: (Error e, Monad m) => ErrorT e m a
21:37:21 <lambdabot> Source not found. Where did you learn to type?
21:37:42 <paczesiowa> how do I check that?
21:37:44 <sw17ch> paczesiowa, actually, how is that different from just making it into :: Either String Int
21:38:03 <paczesiowa> sw17ch: you can use IO
21:38:13 <sw17ch> oh?
21:38:36 <sw17ch> so my 'd' would be able to have a putStrLn in it?
21:38:39 <lispy> sw17ch: the biggest win in using the abstract error type is that others (and yourself) can create new instances of the error monad
21:39:18 <jeeves__> anyone here done bindings to C libraries?
21:39:32 <stepcut> jeeves__: yes
21:39:35 <dons> "   Ok, interesting.  I can get to it from my Yale machine, but not from any
21:39:35 <dons>    other machine.
21:39:35 <dons>    Clearly a firewall problem of some kind.  I have reported it and will keep
21:39:35 <dons>    you posted.
21:39:35 <dons> "
21:39:53 <paczesiowa> http://hpaste.org/9605#a1
21:40:25 <paczesiowa> sw17ch: you can run that with runErrorT d
21:40:33 <sw17ch> paczesiowa, perfect...
21:40:37 <sw17ch> that's exactly what i'm looking for
21:40:44 <sw17ch> paczesiowa++
21:41:06 <jeeves__> I need to call a single function from a medium-sized C library. I've read some blog articles about FFI and the docs to c2hs, but I'm not sure whether I should do this "by hand" or try c2hs or the ghc tool
21:41:23 <sw17ch> jeeves__, what's the function?
21:41:23 <paczesiowa> I'm happy to save another person fron evil land of impure exceptions:)
21:41:24 <dons> one function?
21:41:26 <dons> just do it by hand.
21:41:29 <jeeves__> The function takes a host of nasty parameters (it does average link clustering on a data matrix), but it's still just one function
21:41:35 <sw17ch> err.. wht's the function prototype
21:41:39 <jeeves__> let' see
21:41:42 <dons> foreign import call "math.h sin" c_sin :: CDouble -> CDouble
21:41:42 <dons> done.
21:41:55 <dons> jeeves__: so the question is what haskell types do the C types map to?
21:42:03 <sw17ch> @where CInt
21:42:04 <lambdabot> I know nothing about cint.
21:42:05 <dons> do you need to do any marshalling.
21:42:08 <jeeves__> Node* CALL treecluster (int nrows, int ncolumns, double** data, int** mask, double weight[], int transpose, char dist, char method, double** distmatrix)
21:42:20 <jeeves__> dons: Yeah, that was my next question :)
21:42:21 <dons> so you can call all those arguments easily enough
21:42:21 <sw17ch> appears that he does
21:42:26 <dons> and get back an abstract Node value?
21:42:41 <jeeves__> The Node is a simple struct with two ints and a double
21:42:46 <paczesiowa> jeeves__: you can wrap that fun in c simple app with argv parsing and use rawSystem in haskell if you don't want to learn ffi
21:43:09 <sw17ch> ffi really isn't that hard... but the docs are rough for a newbie
21:43:11 <dons> foreign immport ccall treecluster :: CInt -> CInt -> Ptr (Ptr Double) -> Ptr (Ptr CInt) -> CDouble -> CInt -> CChar -> CChar -> Ptr (Ptr Double) -> IO Node
21:43:12 <jeeves__> paczesiowa: ah, that's probably true, but I might need to be calling it many times
21:43:33 <dons> and allocate some foreign arrays somehow. either via Foreign.Marshall.Array, or via the c lib
21:43:36 <sw17ch> well, i'm done for tonight, good night all
21:43:37 <stepcut> jeeves__: I almost always use plain old FFI or hsc2hs
21:43:39 <paczesiowa> jeeves__: profile first, worry later
21:43:40 <jeeves__> dons: neat
21:43:46 <jeeves__> paczesiowa: sage advice
21:43:49 <stepcut> jeeves__: though, I have been meaning to learn a more powerful tool sometime
21:44:00 <dons> stepcut: RWH also says do it by hand for trivial jobs, or hsc2hs for small to medium job.s
21:44:03 <jeeves__> stepcut: Yeah, the docs for c2hs were a bit intimidating
21:44:05 <dons> c2hs if you're binding to a big api.
21:44:30 <stepcut> dons: I don't think you can understand c2hs and friends unless you could do it with hsc2hs
21:44:37 <dons> yeah.
21:44:39 <dons> I agree.
21:44:40 <lispy> I don't get what cabal install is saying:
21:44:41 <lispy> $ cabal install -p ByteString
21:44:41 <lispy> Resolving dependencies...
21:44:42 <jeeves__> It might be good to generate bindings for the entire clustering library sometime in the future, but at the moment I just need to do average-link clustering on some data :)
21:44:47 <lispy> So did it install the profiled version or not?
21:44:53 <dons> jeeves__: bioinf stuff?
21:45:02 <jeeves__> NLP
21:45:06 <dons> interesting.
21:45:10 <jeeves__> The alternative is to use R
21:45:15 <jeeves__> (do not want)
21:45:20 <dons> yeah, a full binding to whatever your C library is is a good idea in the longer run.
21:45:30 <dons> just write Haskell -- and use a proper language -- instead of an ad hoc domain language.
21:45:32 <lispy> jeeves__: hehe, R isn't so bad...I pref it over python actually :)
21:45:46 <jeeves__> lispy: Yeah, there are some fans in my department, but I just can't get into it.
21:46:16 <lispy> how do cabal uninstall?
21:46:56 <dons> lispy, you're joking.
21:47:06 <dons> this is a purely functional language -- all data is persitant.
21:47:19 <dons> there is no destructive updates! not now, not every.
21:47:35 <paczesiowa> rm ~/.cabal -r
21:47:36 <bwr> how do i convert numbers to characters
21:47:37 <dons> mwhahaha. soon all your code will be haskell.
21:47:42 <dons> paczesiowa: unsafe!
21:47:47 <dons> bwr, show ?
21:47:49 <dons> > show 42
21:47:51 <lambdabot>  "42"
21:47:51 <geezusfreeek> lispy: it doesn't actually delete libraries, but you can unregister stuff with ghc-pkg unregister
21:47:52 <jeeves__> heh
21:48:05 <paczesiowa> > show (2+2)
21:48:06 <bwr> dons: i mean ascii values to their characters
21:48:07 <lambdabot>  "4"
21:48:18 <lispy> dons: my problem actually is just that I can't tell if cabal did the right thing so I want to do it over
21:48:26 <lispy> dons: I also can't find the frick'n manual
21:48:27 <paczesiowa> > ord '2'
21:48:29 <lambdabot>  50
21:48:30 <geezusfreeek> lispy: and make sure to use the --user flag if it's in your .cabal directory
21:48:30 <dons> ?hoogle digits
21:48:30 <lambdabot> A Hoogle error occurred.
21:48:34 <twanvl> > chr 50
21:48:36 <lambdabot>  '2'
21:48:48 <dons> lispy, cabal help ?
21:48:50 <lispy> ah, don't google for cabal install or cabal-install
21:48:57 <lispy> dons: too terse
21:48:58 <bwr> ah chr
21:49:40 <roconnor> I was wondering if a countable union of countable sets was countable, but in my case a countable uion of countable sets of rational numbers is certainly countable.
21:49:54 <lispy> dons: all I really want to know is if it installed profiled builds by default and if not, how to make that a default
21:50:22 <lispy> but it semes that's only documented in the source code?
21:50:30 <paczesiowa> alias cabal 'cabal -p' ?
21:50:44 <lispy> $ cabal -p
21:50:45 <lispy> unrecognized option `-p'
21:51:06 <paczesiowa> alias cabal_install 'cabal install -p'
21:51:32 <bos> what's a reliable way to force the spine of a list without also forcing the elements of the list?
21:51:37 <lispy> paczesiowa: I tried that command and it doesn't seem to do antyhing other than say it's reloving deps
21:51:42 <lispy> er resolving
21:51:49 <lispy> bos: length?
21:52:28 <dons> length is good, but has an annoying accumulator.
21:52:46 <twanvl> foldr seq ()?
21:53:01 <twanvl> err, no
21:53:26 <lispy> > forceSpine [] = (); forceSpine (x:xs) = forceSpine xs -- does this work?
21:53:27 <lambdabot>  Parse error at "=" (column 15)
21:53:31 <bos> lispy: i was thinking something like http://hpaste.org/9606
21:53:52 <dons> simon marlow uses the forkIO (evaluate (length xs)) trick
21:54:03 <dons> so that's almost the same, for the age of strategies.
21:54:31 <dons> i'm surprised there aren't spine-only strategies for lists already
21:54:34 <lispy> bos: huh, that implementation has a bunch of extra "stuff".  How do we justify it?
21:54:58 <bos> lispy: i'm afraid that ghc will notice that the lhs and rhs of pseq are the same if i use () on both sides.
21:55:11 <dons> reminds me of that trick to use `par` to walk one list with two threads simultaneously
21:55:11 <bos> in which case it might legitimately choose to do nothing.
21:55:14 <dons> preventing a space leak.
21:55:27 <bos> although it shouldn't do that since i'm using pseq.
21:56:12 <paczesiowa> dons: have you (or Isaac) decided about going public with those repos?
21:56:14 <lispy> This is one of those things that makes me feel that laziness is a leaky abstraction :)
21:56:30 <dons> paczesiowa: isaac's travelling. i think we'll do it though.
21:56:34 <bos> it's not that laziness is leaky there. it's that strictness is.
21:56:41 <bos> "those repos"?
21:56:49 * lispy looks for a way to manually uninstall something with cabal
21:56:53 <dons> paczesiowa wants to hack on the galois xml lib
21:57:08 <bos> ah.
21:57:48 <bos> i enjoyed reading sioraiocht's unicode slides the other day. disappointed by the choice of U16 though.
21:57:59 <jeeves__> yeah, I was wondering about that too
21:58:02 <paczesiowa> dons: actually I sent you the only patch for xml, I have some ideas (and code) for feed lib
21:58:11 <dons> paczesiowa: ok.
21:58:16 <dons> we'll just put them up somewhere.
21:58:21 <dons> i'll talk to isaac when he's back
21:58:28 <paczesiowa> dons: great
22:07:45 <lispy> sigh
22:07:54 <lispy> So, it doesn't install the profiling version
22:08:08 <lispy> And, I suspect is incapabal of doing so?
22:09:07 <lispy> here is something I don't get
22:09:10 <dons> cabal install -p works for me. maybe you have an old cabal install?
22:09:13 <lispy> cabal --help says:
22:09:13 <lispy> configure    Prepare to build the package.
22:09:22 <lispy> caba$ cabal configure -p ByteString
22:09:22 <lispy> cabal: No cabal file found.
22:09:22 <lispy> Please create a package description file <pkgname>.cabal
22:09:24 <lispy> [
22:09:52 <lispy> cabal-install version 0.5.2
22:09:52 <lispy> using version 1.4.0.1 of the Cabal library
22:10:07 <geezusfreeek> lispy: that is for when you are in the directory of a cabal package
22:10:14 <geezusfreeek> not for retrieving from hackage
22:10:23 <paczesiowa> cabal-install?
22:10:34 <paczesiowa> I use cabal install (with a space)
22:10:51 <geezusfreeek> to install straight from hackage you should be able to just say cabal install -p ByteString
22:11:06 <geezusfreeek> paczesiowa: the package is called cabal-install
22:11:19 <dons> cabal-install 1.5 is out.
22:11:31 <lispy> dons: oh hrm
22:11:39 <dons> oh, 0.5.2
22:11:40 <dons> i see.
22:11:46 <dons> no, that looks fine.
22:11:49 <paczesiowa> geezusfreeek: what package?
22:11:58 <lispy> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:12:08 <lispy> dons: where is 1.5?
22:12:15 <geezusfreeek> paczesiowa: the cabal-install package on hackage. the command is just cabal, but the package is called cabal-install
22:12:21 <geezusfreeek> paczesiowa: what dons just linked to
22:13:06 <lispy> is there any way to modify an installed package?
22:13:34 <tormentor> I am new to haskell and there is a type error in my program.  I believe c is Integer, but this expression fails: sqrt c
22:13:45 <paczesiowa> geezusfreeek: so cabal itself doesn't have any main binary file?
22:13:51 <lispy> :t sqrt
22:13:52 <lambdabot> forall a. (Floating a) => a -> a
22:13:57 <lispy> :instances Floating
22:14:11 <tormentor> In ghci I type: let c = 5 :: Integer
22:14:12 <lispy> ?instances Floating
22:14:13 <lambdabot> Double, Float
22:14:24 <tormentor> Then: sqrt (fromIntegral c)
22:14:31 <tormentor> -and it gives me the correct answer.
22:14:32 <lispy> tormentor: it seems that Integer is not an instance of Floating (which is what sqrt requires)
22:14:35 <geezusfreeek> paczesiowa: well, Cabal is just the build and install library, cabal is a program around it whose package name is cabal-install
22:14:54 <tormentor> I change my program to use: sqrt (fromIntegral c)
22:14:58 <tormentor> But it still fail.
22:15:31 <paczesiowa> geezusfreeek: maybe we need cabal universe tutorial (instead of another monad tutorial)
22:15:43 <geezusfreeek> heh
22:15:56 <paczesiowa> tormentor: could you paste your code?
22:16:03 <paczesiowa> @hpaste
22:16:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:16:47 <sjanssen> @keal
22:16:47 <lambdabot> i lack in verbal and social expression
22:16:48 <sjanssen> @keal
22:16:49 <lambdabot> endian mirrors the decimal
22:16:50 <sjanssen> @keal
22:16:51 <lambdabot> antiparsimony were 100% correct...
22:16:51 <sjanssen> @keal
22:16:52 <lambdabot> my very first computer was an 80-0840
22:16:52 <sjanssen> @keal
22:16:52 <lambdabot> #haskell needs to take its meds
22:16:54 <lispy> How do you get from the hackage page to the website of a project?
22:17:19 <paczesiowa> not every package has a website
22:17:36 <sjanssen> lispy: you could probably do something fancy with ghc-pkg to modify an existing package
22:18:11 <tormentor> http://hpaste.org/9607
22:18:18 <sjanssen> (this probably requires wizard knowledge)
22:19:44 <tormentor> maybe I paste compiler error message?
22:19:56 <paczesiowa> tormentor: what's the type of nth_prime
22:20:03 <sjanssen> tormentor: yes please
22:20:10 <tormentor> Integer -> Integer
22:20:28 <paczesiowa> that's the problem
22:20:34 <paczesiowa> :t sqrt
22:20:35 <lambdabot> forall a. (Floating a) => a -> a
22:20:55 <lispy> tormentor: p is not floating
22:21:01 <lispy> tormentor: so can't use >
22:21:06 <paczesiowa> sqrt returns smth Floating and you compare (>) it with p (Integer)
22:21:23 <tormentor> I see
22:21:26 <tormentor> :t (>)
22:21:27 <lambdabot> forall a. (Ord a) => a -> a -> Bool
22:21:28 <paczesiowa> try adding fromIntegral to p
22:21:33 <tormentor> Same types.
22:22:01 <sjanssen> http://hpaste.org/9607
22:22:08 <lispy> how do I make a bug report in trac? (this is for cabal-install)
22:22:22 <tormentor> Thank you.
22:22:47 <mmorrow> lispy: (i was just reading logs), i have a haskell-style latex file ...
22:22:47 <tormentor> Is there more elegant way?  (fromIntegral p) > (sqrt (fromIntegral c))
22:22:52 <mmorrow> http://code.haskell.org/~morrow/code/haskell/metaquote/tex/haskell.sty
22:22:56 <paczesiowa> sjanssen: that's cheating!:)
22:23:08 <mmorrow> i don't remember where i got it, but it has a license header
22:23:11 <paczesiowa> tormentor: http://hpaste.org/9607#a1
22:23:34 <lispy> mmorrow: thanks
22:23:36 <mmorrow> also, i made a minor fix to (>>=)
22:23:39 <tormentor> if I had function sqrtInt :: Integer -> Integer that is truncated square root, it still works.
22:23:43 <mmorrow> (i don't recall what thought)
22:23:51 <mmorrow> no problem
22:23:54 * sjanssen is a bit drunk, please type check and re-read his code before using
22:24:27 <mmorrow> heh
22:24:31 <paczesiowa> p*p > c should work
22:24:31 <tormentor> Oh yes, annotation is good idea.
22:24:48 * lispy wants to report bugs in cabal-install but notices there is no way to report bugs
22:24:53 * lispy finds this frustrating
22:24:58 <sjanssen> Haskell is the only language I feel comfortable hacking after a few beers
22:25:10 <sjanssen> lispy: I think you're supposed to use Cabal's bug tracker
22:25:14 <tormentor> hehe.
22:25:28 <paczesiowa> Haskell is the only language I feel comfortable hacking.
22:25:30 <jeeves__> mmorrow: what's in the style file? Usually I just see people typeset code with some 'code' environment or somesuch
22:25:32 <tormentor> I can just have: p*p > c
22:25:34 <tormentor> Much better.
22:25:54 <jeeves__> (actually I could just download it and see!)
22:26:05 <lispy> sjanssen: k, but there is no way to enter bugs
22:26:19 <mmorrow> jeeves__: it defines a mapping from      \begin{code} ... \end{code}        to regular latex for haskell
22:26:23 <sjanssen> lispy: maybe you need to register?  (they've had problems with spam)
22:26:25 <tormentor> It's interesting also how the type system reflects the historical aspect of math.
22:26:41 <mmorrow> jeeves__: it actually looks *quite* nice also, :)
22:26:48 <jeeves__> mmorrow: neat, maps -> to real arrows, etc
22:26:56 <mmorrow> yeah
22:26:59 <paczesiowa> if there are negative primes that code will break
22:27:05 <tormentor> I mean, humans knew that p*p was the same type as p before they realized that sqrt p was a different "type" of number.
22:27:21 <mmorrow> jeeves__: it looks pretty easy to tweak, also
22:27:25 <jeeves__> mmorrow: yeah
22:27:45 <tormentor> negative primes...  What a silly idea.  For that to work, there'd have to be numbers below 1, and we all know 1 is the lowest number.  ;-)
22:27:50 <encryptio> tormentor: mainly it's accuraccy issues. using floating point numbers to store big integers might be lossy
22:28:06 <sjanssen> Data.Number.CReal ftw!
22:28:12 <sjanssen> > sqrt 2 :: CReal
22:28:14 <lambdabot>  1.4142135623730950488016887242096980785697
22:28:31 <paczesiowa> tormentor: we know it should be that way, it's not proven with haskell's typechecker
22:28:38 <tormentor> Also, I am curious: I write similar code in another language, but does haskell do function memoization by default with ghc?
22:29:01 <paczesiowa> tormentor: no
22:29:15 <sjanssen> > exp ((0 :+ 1) * pi) :: Complex CReal
22:29:15 <encryptio> tormentor: no, but it does a host of other optimizations that when mixed with laziness may make it seem like memoization is happening.
22:29:17 <lambdabot>  (-1.0) :+ 0.0
22:29:27 <tormentor> Hrm...  Then my code will be quite slow.  ;-)
22:29:29 <mmorrow> here a copy with a .txt extension so it's viewable in-browser: http://code.haskell.org/~morrow/code/haskell/metaquote/tex/haskell.sty.txt
22:29:31 <lambdabot> http://tinyurl.com/5watqw
22:29:57 <encryptio> is www.haskell.org supposed to respond?
22:30:04 <sjanssen> why do people always think Haskell is memoized?  Is there a bad tutorial out there?
22:30:22 <sjanssen> encryptio: yes, but it's probably down again
22:30:44 <paczesiowa> x==y => f x == f y, memoizing would be great
22:30:52 <sjanssen> 50 or so open connections essentially DoS apache
22:31:16 <sjanssen> paczesiowa: that isn't necessarily true in Haskell -- (==) is overloaded
22:31:37 <tormentor> sjanssen: I just thought that because I learned in english what paczesiowa expressed in symbols.
22:31:57 <tormentor> "Haskell has no side effects" and "functions without side effects can always be memoized".
22:31:58 <encryptio> paczesiowa: not necessarily true in any language with floating point numbers =p
22:32:05 <tormentor> -so I just thought it might happen.
22:32:22 <paczesiowa> floating point numbers are boring
22:32:38 <sjanssen> tormentor: yeah, that is true.  The problem is that it is very difficult for compilers to decide when it is advantageous to memoize
22:32:47 <sjanssen> because usually it will just cause a massive space leak
22:34:15 <tormentor> Yes...  Is there a mechanism to annotate code to give the compiler hints?
22:34:38 <sjanssen> not exactly, but there are a few 'memo' combinators out there
22:34:49 <paczesiowa> http://www.haskell.org/haskellwiki/Memoization
22:34:51 <sjanssen> @google okasaki site:gmane.org dynamic programming
22:34:53 <lambdabot> No Result Found.
22:35:00 <sjanssen> lambdabot: I hate you
22:35:27 <sjanssen> tormentor: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo has a neat little combinator for DP
22:35:55 <tormentor> What is a "combinator" ?
22:36:18 <Twey> Something that combines.
22:36:36 <sjanssen> tormentor: replace the word with "function" and you lose no information
22:36:38 <encryptio> something that combines given function(s) with other things
22:36:50 <sjanssen> it's practically a buzz word in the FP community
22:37:12 <tormentor> "second order function" ?
22:37:20 <geezusfreeek> well, usually a combinator is polymorphic
22:37:56 <geezusfreeek> i'd say any parametrically polymorphic function could be a combinator
22:38:17 <dsrogers> greetings.
22:38:24 <Twey> coi
22:38:31 <sjanssen> HELLO!
22:38:38 <geezusfreeek> always a lojban greetingâ¦
22:39:32 <dsrogers> is haskell.org down for everyone tonight, or is it just me?
22:39:52 <encryptio> downforeveryoneorjustme.com - and yes
22:39:54 <mmorrow> tormentor: here's a memo: http://hpaste.org/9608
22:40:02 <geezusfreeek> everyone except for people at Yale
22:40:17 <sjanssen> http://downforeveryoneorjustme.com/hackage.haskell.org
22:40:19 <tormentor> :t (!)
22:40:20 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
22:40:27 <dsrogers> oh.  I see.  it's a conspiracy.
22:40:29 <sjanssen> oh, haskell.org
22:40:37 <geezusfreeek> hackage isn't down :P
22:40:40 <sjanssen> dsrogers: yeah, I have trouble loading haskell.org
22:40:46 <sjanssen> it's the Apache setup there
22:40:51 <dsrogers> omg, that site actually exists?
22:40:52 <dsrogers> lol
22:40:59 <geezusfreeek> rumor has it it's a firewall issue
22:41:25 <encryptio> dsrogers: yes, and instantrimshot.com also exists
22:41:34 <sjanssen> geezusfreeek: I've heard that Apache has an open connection limit, and haskell.org is set to 50
22:41:42 <tormentor> Hrm...  So is the Ix type for indices?  Is ! for array lookup?
22:41:54 <geezusfreeek> sjanssen: that is true, but the fact remains that it is still accessible from yale but nowhere else
22:42:10 <sjanssen> geezusfreeek: ah, that is interesting
22:42:19 <sjanssen> tormentor: correct
22:42:27 <dsrogers> encryptio: instantrimshot.com!  where have you been all my life?
22:42:43 <encryptio> dsrogers: and for the sad times - sadtrombone.com
22:43:17 <sjanssen> encryptio++ my new favorite website
22:44:16 <tormentor> From my end (via tor) haskell.org fails to do a DNS resolve.
22:44:34 <dsrogers> I have a similar issue.
22:44:39 <encryptio> i get A 128.36.229.215
22:45:15 * encryptio is not l33t enough for having AAAAs
22:45:33 <geezusfreeek> dns seems to work fine for me
22:46:14 <dsrogers> anyone can have AAAAs
22:46:18 <dsrogers> you just need to setup a free tunnel
22:46:23 <encryptio> but not anyone can use them =p
22:46:53 <hackage> Uploaded to hackage: AvlTree 4.0
22:48:44 <dons> I wish we had a word for "that which is good Haskell code"
22:48:47 <dons> like pythonic.
22:48:53 <dons> "haskelly" doesn't really nail it.
22:49:06 <dons> "purely functional" sometimes gets there. but is a bit too precise.
22:49:14 <dons> when some code has the zen of Haskell.
22:49:39 <sjanssen> Haskellish?
22:49:58 <dibblego> Haskoolic
22:50:00 <dsrogers> Haskellite
22:50:06 <tormentor> I like Haskelly.  Reminds me of "squirrely".
22:50:30 <encryptio> reminds me of perly
22:50:38 <tormentor> Ick!
22:50:53 <sjanssen> uberHaskell?
22:51:03 <encryptio> h4sk3ll
22:51:08 <sjanssen> @elite Haskell
22:51:08 <lambdabot> |-|4zx3ll
22:51:09 <tormentor> Haskellent.
22:51:20 <sjanssen> @elite Haskelly
22:51:21 <lambdabot> |-|45keL1Y
22:51:27 <dons> -ish is too weak.
22:51:28 <dsrogers> Haskell is yiddish for "god strengthens"
22:51:35 <sjanssen> dons: Simon-ic?
22:51:36 <dons> haskellsome.
22:51:43 <dons> simonic eh
22:51:43 <dons> hmm
22:51:47 <dsrogers> Haskellent.  I like that one.
22:51:52 <dons> wadleronic
22:52:01 <sjanssen> dons: more seriously, "functional pearl"?
22:52:06 <mmorrow> tronic
22:52:08 <dons> "A true functional pearl"
22:52:12 <encryptio> i like haskellent too
22:54:27 <dsrogers> :t throwDyn
22:54:33 <mmorrow> dons: i just earlier put hpaste2 on the intarwebs at http://moonpatio.com:8080
22:55:05 <dons> mmorrow: cool!
22:55:23 <dons> is that with the pythonic syntax highlighting?
22:55:29 <mmorrow> search!
22:55:32 <mmorrow> yeah,
22:55:42 <dons> yeah, i think we should move to hpaste2 on hpaste.org
22:55:46 <sjanssen> what is pythonic syntax highlighting?
22:55:49 <mmorrow> err, with whatever is in the git repo
22:55:55 <dons> sjanssen: oh, it binds to the python library, pygments.
22:56:02 <mmorrow> yeah, that's it
22:56:02 <sjanssen> also, perhaps Haskell shouldn't have a "Pythonic" equivalent, it sounds stupid
22:56:05 <dons> because its bsd.
22:56:26 <dons> precise, elegant, efficient.
22:56:43 <dons> those are my keywords of choice for the kind of functional pearl code i'm talking about.
22:56:55 <geezusfreeek> HTML comes before Haskell in the drop down menu
22:57:14 <dons> glguy_: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
22:57:32 <dons> glguy_ with an underscore. that's not like him to be not online this early in the day.
22:57:48 <mmorrow> i plan on keeping it there, so it shouldn't go away any time soon
22:58:22 <dsrogers> why can't ghc figure out -boot classes on it's own?
22:58:57 <sjanssen> dsrogers: because that would require typechecking several modules at once
22:59:19 <mmorrow> one thing i think is cool about hpaste2, is that if someone highlights/unhighlights a line it's visible to everyone
22:59:27 <lispy> okay submitted a bug report
22:59:29 <dsrogers> is that impossible or unimplemented?
22:59:39 <sjanssen> dsrogers: it is merely difficult
22:59:53 <dons> mmorrow: it has the wiki nature :)
23:00:50 <mmorrow> only problem is that as the paste get bigger, the line numbers start to not line up more and more, so you've gotta close in on your target line over 2-4 attempt
23:01:33 <mmorrow> yeah, i don't think i've seen text annotations/decorations anywhere though. it's a great idea
23:01:55 <lispy> mmorrow: do you have example of your haskell.sty that you could impress me with?
23:02:26 <mmorrow> lispy: hmm, i run a snippet through. lemme pick a good one ....
23:02:31 <mmorrow> s/i/i'll/
23:03:10 <lispy> mmorrow: ah, I see it does some of the stuff I don't like, wrt symbol replacement, but taht looks easy to change
23:07:29 * lispy likes the typeset code to use the same characters as the input to the compiler for some odd reason, even in lew of nice mathy ones
23:08:01 <dsrogers> how do I make ghci display a [Char] as a string literal?
23:08:31 <dsrogers> oic.
23:08:39 <dsrogers> I misunderstood what I had.
23:09:15 <sjanssen> dsrogers: it should do that automatically
23:09:27 <dsrogers> not if it is a [[Char]]!
23:09:42 <sjanssen> it will display as a list of string literals
23:09:45 <sjanssen> showList ftw!
23:14:27 <Cale> dsrogers: perhaps you want to display each string on a separate line?
23:14:35 <Cale> Something like  mapM_ print strings
23:14:45 <Cale> or  mapM_ putStrLn strings, even
23:15:05 <dsrogers> no, I just iddn't realize I had a [[Char]] and was confused by the disply.
23:21:53 <lispy> mmorrow: I'm going to bed now, ?tell me the link and I'll look at it later
23:22:08 <lispy> Cale: thanks for getting lambdabot working again!
23:23:02 <Cale> lispy: no problem! It turned out to be easier than I thought... We still should think about what to do about memory use, but I'd like to observe how it runs at first.
23:23:14 <Cale> I removed the Log module which was a likely candidate for problems.
23:26:20 <dsrogers> foldl is the safe one and foldr is the efficient one, correct?
23:27:29 <Cale> hm...
23:27:35 <Cale> I wouldn't put it that way.
23:27:48 <Cale> foldr is the one which works on infinite lists and can bail out early when that's possible
23:27:55 <dsrogers> oh.
23:27:58 <dsrogers> got it backards.
23:28:08 <Cale> foldl always recurses to the end of the list right away
23:28:17 <Cale> But it does so in a tight loop.
23:28:43 <Cale> However, without either optimisations or a change of definition, it can end up building up large expressions that cause stack overflows.
23:29:08 <Cale> foldl' is the strict version of foldl which reduces the accumulating parameter as it goes
23:30:11 <mmorrow> lispy: ok, just finished. here's a darcs repo with an example .lhs that is a valid latex doc also, and a Makefile  http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
23:30:21 <lambdabot> Title: Index of /~morrow/code/haskell/cont-lhs-eg
23:30:59 <mmorrow> @tell .lhs + LaTeX eg: http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
23:31:00 <lambdabot> Consider it noted.
23:31:03 <mmorrow> crap
23:31:08 <mmorrow> @tell lispy .lhs + LaTeX eg: http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
23:31:08 <lambdabot> Consider it noted.
23:32:56 <mmorrow> dang, that's clearly not be the same haskell.sty that i fixed (>>=) in
23:33:02 <mmorrow> s/be//
23:40:05 <orz1> !hoogle print
23:58:56 <lowki_> what happens if i forget my hackage username?
23:59:39 <dons> you ask Ross nicely, or look it up in the user list.
