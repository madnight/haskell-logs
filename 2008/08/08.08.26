00:00:43 <ac> Although it sure would look nicer if I could use the IO monad from within. I think what I want is to return a type of: IO (Render ())
00:01:01 <name___> people usually suggest to avoid tainting everything with IO if you can avoid it
00:02:02 <ac> well, I have this timer type and I want a function to return time elapsed, and it seems uggly to pass in now to get that
00:02:51 <Trinithis> Do that in IO and in between to getTimes, do the action
00:03:20 <Trinithis> That way you don't need transformers
00:06:02 <ac> yeah, there are definitely ways I can reduce the awkwardness
00:09:14 <mapreduce> What's the best resource for understanding Kleisli arrows?
00:09:36 <Trinithis> Do you understand >=> ?
00:10:03 <mapreduce> I'm trying to grasp arrows in general, but the only complete examples I can find are functions ( -> ) and some notes saying "Kleisli arrows make monads into arrows".
00:10:08 * mapreduce looks up >=>.
00:10:19 <Trinithis> @src (>=>)
00:10:19 <lambdabot> Source not found. :(
00:10:27 <Trinithis> @ty (>=>)
00:10:28 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:10:49 <Trinithis> It just composes two monadic functions
00:10:56 <mapreduce> I think so, yes.
00:11:20 <Trinithis> f >=>g = \a -> f a >>= g
00:11:26 <Trinithis> ok?
00:11:26 <newsham> ?type readFile >=> writeFile "out"
00:11:28 <lambdabot> FilePath -> IO ()
00:11:36 <mapreduce> Sure.
00:12:04 <Trinithis> Well, >=> is the definition for >>> in the Kleisli instance
00:12:09 <Trinithis> for Arrow
00:12:31 <newsham> ?type (Kleisli readFile) >>> (Kleisli $ writeFile "out")
00:12:33 <lambdabot> Kleisli IO FilePath ()
00:12:42 <newsham> ?type runKleisli $ (Kleisli readFile) >>> (Kleisli $ writeFile "out")
00:12:44 <lambdabot> FilePath -> IO ()
00:12:48 <mapreduce> Ok.
00:12:54 <Trinithis> :t readFile >=> writeFile ""
00:12:55 <lambdabot> FilePath -> IO ()
00:13:23 <Trinithis> first would look like...
00:13:24 <newsham> ?type (Kleisli readFile) >>> (pure reverse) >>> (Kleisli $ writeFile "out")
00:13:26 <lambdabot>     Couldn't match expected type `[a] -> [a]'
00:13:26 <lambdabot>            against inferred type `String'
00:13:26 <lambdabot>       Expected type: Kleisli IO ([a] -> [a]) d
00:13:35 <newsham> ?type (Kleisli readFile) >>> (arr reverse) >>> (Kleisli $ writeFile "out")
00:13:36 <lambdabot> Kleisli IO FilePath ()
00:14:12 <Trinithis> :t first
00:14:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
00:14:14 <mapreduce> ?type readFile . liftM2 reverse . writeFile "out"
00:14:16 <lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `[a]'
00:14:16 <lambdabot>     Probable cause: `reverse' is applied to too many arguments
00:14:16 <lambdabot>     In the first argument of `liftM2', namely `reverse'
00:14:26 <mapreduce> ?type readFile . liftM reverse . writeFile "out"
00:14:28 <lambdabot>     Couldn't match expected type `[a]' against inferred type `()'
00:14:28 <lambdabot>       Expected type: String -> IO [a]
00:14:28 <lambdabot>       Inferred type: String -> IO ()
00:14:47 <mapreduce> Does this have a version without arrows?  Would that have to use >>= ?
00:15:01 <Trinithis> umm
00:15:15 <Trinithis> replace . with >=>
00:15:24 <Trinithis> all of the .'s
00:15:26 <newsham> ?type writeFile "out" =<< reverse <$> readFile "in"
00:15:27 <lambdabot> IO ()
00:15:35 <mapreduce> ?type readFile >=> liftM reverse >=> writeFile "out"
00:15:37 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
00:15:37 <lambdabot>       Expected type: Char -> b
00:15:37 <lambdabot>       Inferred type: [a] -> [a]
00:15:38 <lispy> It's sad that the different version control systems can't talk to each other
00:15:51 <mapreduce> lispy: There is a project that helps with that.
00:15:55 <Trinithis> :t readFile
00:15:57 <lambdabot> FilePath -> IO String
00:15:57 <lispy> mapreduce: tailor?
00:16:01 <Trinithis> oh
00:16:08 <newsham> ?type readFile >=> liftM reverse (writeFile "out")
00:16:10 <lambdabot>     Couldn't match expected type `IO c' against inferred type `[a]'
00:16:10 <lambdabot>       Expected type: [a] -> IO c
00:16:10 <lambdabot>       Inferred type: [a] -> [a]
00:16:13 <Trinithis> ?type readFile >>= liftM reverse >>= writeFile "out"
00:16:14 <lambdabot>     Couldn't match expected type `IO String'
00:16:14 <lambdabot>            against inferred type `FilePath -> String'
00:16:14 <lambdabot>       Expected type: IO String -> FilePath -> [Char]
00:16:24 <newsham> oops.. forgot about the extra arg :)
00:16:29 <Trinithis> ?type readFile "abc" >>= liftM reverse >>= writeFile "out"
00:16:31 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
00:16:31 <lambdabot>       Expected type: Char -> a1
00:16:31 <lambdabot>       Inferred type: [a] -> [a]
00:16:39 <Trinithis> :t readFile ""
00:16:41 <lambdabot> IO String
00:16:47 <newsham> ?type readFile >=> (liftM reverse . writeFile "out")
00:16:49 <lambdabot>     Couldn't match expected type `[a]' against inferred type `()'
00:16:49 <lambdabot>       Expected type: String -> IO [a]
00:16:49 <lambdabot>       Inferred type: String -> IO ()
00:17:23 <lispy> ?type readFile "abc" >=> (liftM reverse . writeFile "out")
00:17:25 <lambdabot>     Couldn't match expected type `a -> m b'
00:17:25 <lambdabot>            against inferred type `IO String'
00:17:25 <lambdabot>     In the first argument of `(>=>)', namely `readFile "abc"'
00:17:36 <Trinithis> :t readFile >=> return
00:17:38 <lambdabot> FilePath -> IO String
00:17:44 <Trinithis> :t readFile >=> liftM reverse
00:17:46 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
00:17:46 <lambdabot>       Expected type: Char -> c
00:17:46 <lambdabot>       Inferred type: [a] -> [a]
00:18:22 <Trinithis> :t liftM reverse
00:18:23 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a]
00:18:51 <lispy> :t (>=>)
00:18:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:18:55 <Trinithis> :t readFile >>> liftM reverse
00:18:57 <lambdabot> FilePath -> IO [Char]
00:19:11 <lispy> Oh
00:19:18 <Trinithis> :t readFile >>> liftM reverse >=> writeFile "out"
00:19:20 <lambdabot> FilePath -> IO ()
00:19:21 <lispy> >=> is like, >>= ?
00:19:24 <Trinithis> :t readFile >>> liftM reverse >>> writeFile "out"
00:19:26 <lambdabot>     Couldn't match expected type `IO [Char]'
00:19:26 <lambdabot>            against inferred type `String'
00:19:26 <lambdabot>       Expected type: IO [Char] -> d
00:19:30 <lispy> and >>> is like >>
00:19:38 <Trinithis> :t readFile >>> liftM reverse >=> writeFile "out"
00:19:40 <lambdabot> FilePath -> IO ()
00:19:50 <Trinithis> >=> is the monad equivalent to .
00:20:06 <lispy> :t ((>=>), ap)
00:20:08 <lambdabot> forall a (m :: * -> *) b c (m1 :: * -> *) a1 b1. (Monad m1, Monad m) => ((a -> m b) -> (b -> m c) -> a -> m c, m1 (a1 -> b1) -> m1 a1 -> m1 b1)
00:20:25 <Trinithis> >>> in this case = flip (.)
00:20:42 <newsham> ?type liftM reverse . readFile >=> writeFile "out"
00:20:44 <lambdabot> FilePath -> IO ()
00:22:13 <Trinithis> :t writeFile "out" <=< fmap reverse . readFile
00:22:15 <lambdabot> FilePath -> IO ()
00:22:46 <lispy> It seems a bit convoluted to work with thou.
00:22:49 <lispy> Er though.
00:22:58 <lispy> I'm not sure I'd want to see that daily in code :)
00:23:14 <mapreduce> So Kleisli just maps return to pure/arr, >>= to >=>, etc.?
00:23:26 <newsham> writeFile "out" =<< reverse <$> readFile "in"      seems pretty clear and fine for every day use to me
00:23:28 <Trinithis> It's not so bad
00:23:47 <Trinithis> Kleisli is not a monad
00:23:55 <Trinithis> it's an arrow
00:23:55 <mapreduce> I don't really get where the other type parameter comes in.
00:23:56 <newsham> much better than:   i <- readFile "in"\nlet r = reverse i\nwriteFile "out" r
00:24:22 <Trinithis> hmmm.... what's that paper by Huges?
00:24:32 <mapreduce> There's nothing I can envisage doing to Maybe a that would give me some instance of Arrow a b
00:24:37 <mapreduce> Trinithis: I have it. :)
00:24:55 <Trinithis> I read half of it a week ago... guess I ought to finish :)
00:25:00 <newsham> http://www.haskell.org/arrows/biblio.html#Hug00
00:25:01 <lambdabot> Title: Arrows: bibliography
00:25:30 <newsham> mapreduce: kleisli arrows arent monadic actions.  they are functions a -> m b
00:25:38 <newsham> so functions a -> Maybe b    would form arrows
00:26:27 <Trinithis> and functions a -> Cthulhu b
00:26:35 <Trinithis> and many others
00:26:52 <newsham> ?type find (== 'a')
00:26:54 <lambdabot> [Char] -> Maybe Char
00:27:03 <lispy> ?hoogle unsafeCthulhu
00:27:03 <lambdabot> No results found
00:27:04 <newsham> ?type Kleisli . find (== 'a')
00:27:06 <lambdabot>     Couldn't match expected type `a -> m b'
00:27:06 <lambdabot>            against inferred type `Maybe Char'
00:27:06 <lambdabot>     Probable cause: `find' is applied to too many arguments
00:27:09 <Trinithis> lol
00:27:11 <mapreduce> > pure (find (== 'a'))
00:27:13 <lambdabot>      No instance for (Show (f ([Char] -> Maybe Char)))
00:27:13 <lambdabot>       arising from a u...
00:27:16 <Trinithis> He's inherintly unsafe!
00:27:17 <mapreduce> :t pure (find (== 'a'))
00:27:18 <lambdabot> forall (f :: * -> *). (Applicative f) => f ([Char] -> Maybe Char)
00:27:31 <newsham> ?type Kleisli $ find (== 'a')
00:27:33 <lambdabot> Kleisli Maybe [Char] Char
00:27:45 <lispy> Trinithis: Either that, or you can't escape from Cthulu
00:27:51 <Trinithis> lol
00:27:51 <mapreduce> How does using Kleisli differ from using pure?
00:27:55 <haskellian> what atastructures does Haskell offer builtin and in the stdlib? Lists, Maps...?
00:28:16 <Trinithis> My cthulhu doll is sitting on top of my computer right now.
00:28:17 <lispy> haskellian: man, there is a lot
00:28:23 <newsham> mapreduce: combining with (>>>) will combine using the Maybe rules for (>>=)
00:28:26 <mapreduce> haskellian: Lazy lists and tuples are the basic ones.
00:28:29 <newsham> instead of normal composition
00:28:45 <Trinithis> pure /= Kleisli
00:28:48 <Trinithis> :t pure
00:28:49 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:28:54 <Trinithis> :t Control.Arrowpure
00:28:56 <lambdabot> Couldn't find qualified module.
00:28:56 <Trinithis> :t Control.Arrow.pure
00:28:58 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:28:59 <lispy> haskellian: you could start by getting familiar with the Prelude
00:29:01 <mapreduce> :t pure (find (== 'a')) >>> pure (find (== 'b'))
00:29:03 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a, Applicative (a ([Char] -> Maybe Char)), Applicative (a b)) => a b ([Char] -> Maybe Char)
00:29:04 <Trinithis> :t Kleisli
00:29:05 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
00:29:35 <haskellian> ?src Maybe
00:29:35 <lambdabot> data Maybe a = Nothing | Just a
00:29:36 <Trinithis> pure takes ANY function. Kleisli takes only certain types of functions (a -> m a)
00:30:01 <gour> any hint where to look to find some example of Data.Map in action?
00:30:04 <Trinithis> pure f = return . f :: for Kleisli
00:30:19 <Trinithis> pure = Kleisli . return :: for Kleisli
00:30:21 <Trinithis> sorry
00:30:32 <lispy> is it Kl-eye-sli?
00:30:38 <mapreduce> Trinithis: Why is pure f not the same as Kleisli f, given a matching function?
00:30:44 <haskellian> ?src Data.Map
00:30:44 <lambdabot> Source not found. Are you on drugs?
00:30:48 <Trinithis> I imagine it a Kleezly
00:30:53 <Trinithis> as*
00:31:15 <lispy> is it german?
00:31:18 <mapreduce> Kleenex functions.
00:31:25 <Trinithis> because pure on a (a -> m a) gives (a -> m (m a))
00:31:31 <lispy> iirc, german ei is english eye
00:31:46 <mapreduce> lispy: Heidi agrees.
00:32:13 <lispy> mapreduce: and what Heidi wants, Heidi gets.
00:32:33 <Trinithis> O.o
00:32:54 <lispy> ?faq can Haskell provide Heidi with whatever she wants?
00:32:54 <lambdabot> The answer is: Yes! Haskell can do that.
00:33:22 <newsham> why is "3" different than "Just 3" ?
00:33:34 <Trinithis> :t pure :: Kleisli
00:33:36 <lambdabot>     `Kleisli' is not applied to enough type arguments
00:33:36 <lambdabot>     Expected kind `?', but `Kleisli' has kind `(* -> *) -> * -> * -> *'
00:33:36 <lambdabot>     In an expression type signature:
00:33:41 <Trinithis> :t arr
00:33:43 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:34:11 <gour> newsham: type :t (Just 3) and :t 3 in ghci
00:34:44 <mapreduce> :t pure (find . (=='a'))
00:34:46 <lambdabot>     Couldn't match expected type `a -> Bool'
00:34:46 <lambdabot>            against inferred type `Bool'
00:34:46 <lambdabot>     In the second argument of `(.)', namely `(== 'a')'
00:34:55 <mapreduce> :t pure (find (=='a'))
00:34:57 <lambdabot> forall (f :: * -> *). (Applicative f) => f ([Char] -> Maybe Char)
00:35:02 <Trinithis> mapreduce, arr/pure for Kleisli will wrap the output in a monadic layer no matter the original output. So if it is already a monad, then you get 2 monad layers
00:35:28 <lispy> :t join . pure
00:35:30 <lambdabot> forall (m :: * -> *) a. (Applicative m, Monad m) => m a -> m a
00:35:36 <thomashartman1> in darcs, after a rollback, how do I "unrollback" ?
00:35:43 <Trinithis> :t join . arr
00:35:45 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1, Monad (a1 b)) => (b -> a1 b a) -> a1 b a
00:35:52 <thomashartman1> if I decide I shouldn't have rolled back in the first place?
00:35:52 <Trinithis> use arr to not confuse the bot
00:35:58 <newsham> ?type Kleisli (elemIndex 'c') >>> Kleisli (M.empty M.!)
00:35:59 <lambdabot> forall d. Kleisli Maybe [Char] d
00:36:10 <mapreduce> thomashartman1: If nobody answers you might try #darcs.
00:36:21 <lispy> thomashartman1: Hmm..I think you can rollback the rollback patch
00:36:56 <lispy> thomashartman1: and if you're feeling cavalier, you can obliterate the rollback patch (but that becomes unsafe if you've shared the rollback patch with any other repositories)
00:36:56 <thomashartman1> mapreduce: I just tried but... more people here.
00:37:04 <newsham> ?type (\s -> elemIndex 'c' s) >>= (\k -> M.empty M.! k)
00:37:06 <lambdabot> forall b. [Char] -> b
00:37:33 <Trinithis> :t elemIndex 'c' >=> M.empty M.!
00:37:35 <lambdabot> parse error (possibly incorrect indentation)
00:37:45 <Trinithis> :t elemIndex 'c' >=> (M.empty M.!)
00:37:46 <lambdabot> forall c. [Char] -> Maybe c
00:38:36 <newsham> ?type (\s -> elemIndex 'c' s >>= (\k -> M.empty M.! k))
00:38:37 <lambdabot> forall b. [Char] -> Maybe b
00:38:40 <newsham> oops, botched earlier.
00:41:16 <newsham> so (>=>) is kleisli composition
00:41:21 <Trinithis> yes
00:41:41 <Trinithis> f >=>g = \x -> f x >>= g
00:42:08 <newsham> f >=> g = runKleisli $ Kleisli f >>> Kleisli g     ;-)
00:42:44 <Trinithis> Is there a sequence type operator for Arrows?
00:43:03 <Trinithis> [a, b, c] --> a >>> b >>> c
00:43:05 <newsham> like foldl (>>>) ?
00:43:13 <Trinithis> yeah
00:43:48 <lispy> :t sequence
00:43:49 <newsham> i dont see in std arrows lib.
00:43:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:44:59 <newsham> i havent used arrows much, but they look pretty neat when applied properly.
00:45:21 <newsham> this awesome example was from one of conal's papers:  http://www.thenewsh.com/%7Enewsham/x/machine/paddleball.hs
00:45:47 <newsham> i'ver never had occasion to break into arrow do-notation yet.
00:46:16 <Trinithis> It's just a matter of first, second, ...
00:46:28 <Trinithis> naturally :D
00:46:37 <newsham> i've used first a few times..  handy operation on tuples
00:46:54 <binrapt> What's that Maybe () thing?
00:47:24 <newsham> splitStr ch = unfoldrp (not.null) (return.f) where f = (second (drop 1)) . (splitWhile (/= ch))
00:47:36 <Trinithis> Maybe () is pretty much the same as Bool
00:47:49 <Trinithis> but with different operators.... but still
00:51:21 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/splitStr.hs
00:52:46 <Trinithis> what about?
00:53:13 <newsham> [21:44] < Trinithis> It's just a matter of first, second, ...
00:53:21 <newsham> just commenting that i dig "second"
00:53:27 <Trinithis> oh
00:53:37 <Trinithis> you could use fmap in that case :D
00:53:42 <Trinithis> I think
00:53:48 <osfameron> dons: sorry for the kneejerk perl fanboyism last night -- I was tired and very bad-tempered... and thanks for taking it in good grace.
00:53:52 <newsham> not using it for fancy wiring like in do-arrows though
00:54:11 <newsham> ?src (,) fmap
00:54:11 <lambdabot> fmap f (x,y) = (x, f y)
00:54:16 <newsham> yup, I suppose I could.
00:54:50 <newsham> is there something for first?  (other than swap.fmap.swap ?)
00:55:10 <Trinithis> second is defined by first
00:55:17 <Trinithis> first is an Arrow primitive
00:55:26 <newsham> right, but i mean... for fmap...
00:55:41 <Trinithis> for tuples?
00:55:43 <Trinithis> no
00:55:58 <newsham> and actually "first" is not defined to be strictly in terms of second.
00:56:06 <newsham> only in the default def'n
00:56:14 <Trinithis> mm
00:56:34 <newsham> and actually the other way around..  first is left undefined and there's a class default for second
00:56:37 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html
00:56:39 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/62bzdg
00:57:32 <newsham> also, why is "swap" defined as a "where" in Control.Arrow..  that needs to be an exported function in some std lib :(
00:57:59 <newsham> i should sleep.
00:58:09 <Trinithis> same
00:58:11 <Trinithis> night
01:21:55 <davidL> how can I fix this? cabal: dependencies conflict: ghc-6.8.2 requires bytestring ==0.9.0.1 however bytestring-0.9.0.1 was excluded because zlib-0.4.0.4 requires bytestring ==0.9.1.2
01:22:23 <thomashartman1> davidL: have you tried using cabal install for whatever it is you are trying to do?
01:22:41 <davidL> yeah, I'm using cabal install
01:23:09 <thomashartman1> what are you trying to instal?
01:23:24 <davidL> lambdabot, heh
01:23:35 <thomashartman1> shouldn't you try mueval?
01:23:56 <ivanm> davidL: you can't
01:23:56 <thomashartman1> I thought that was the lambdabot replacement
01:24:04 <davidL> I've got mueval
01:24:09 <ivanm> thomashartman1: no, its replacing the haskell evaluator in lambdabot
01:24:12 <ivanm> already has IIRC
01:24:24 <davidL> ivanm: can't what?
01:24:52 <thomashartman1> davidL: maybe you could try installing zlib via cabal install and then try for lambdabot again
01:25:01 <thomashartman1> or edit the cabal file somehow to make the stars align
01:25:44 <ivanm> davidL: can't resolve it
01:26:06 <ivanm> the problem is, lambdabot uses hsplugins, which uses ghc internals IIRC, and ghc is bundled with a copy of bytestring
01:26:13 <ivanm> so you get the diamond dependency problem
01:26:29 <Mitar> is there a floating point modulo already defined somewhere?
01:26:43 <ivanm> davidL: you might be able to get it working by downgrading zlib to one that allows bytestring 0.9.12, build lambdabot and then upgrade everything
01:26:46 <ivanm> Mitar: yes
01:26:50 <ivanm> Data.Fix IIRC
01:26:53 <ivanm> @hoogle mod'
01:26:54 <lambdabot> Prelude undefined :: a
01:26:54 <lambdabot> Test.QuickCheck.Batch bottom :: a
01:26:54 <lambdabot> Data.Function fix :: (a -> a) -> a
01:26:57 <davidL> @version
01:26:57 <lambdabot> lambdabot 4.2
01:26:57 <lambdabot> darcs get http://code.haskell.org/lambdabot
01:27:00 <ivanm> grrr......
01:27:16 <ivanm> what's with @hoogle lately? it's returning garbage!
01:27:16 <ivanm> @hoogle mod
01:27:18 <lambdabot> Prelude mod :: Integral a => a -> a -> a
01:27:18 <lambdabot> keyword module
01:27:18 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
01:27:27 <ivanm> Mitar: Data.Fixed ^^
01:27:36 <Mitar> thanks
01:27:58 <ivanm> no worries
01:30:29 <davidL> ivanm: I thought that was fixed in the latest cabal-install
01:30:43 <ivanm> davidL: no, you can't
01:30:47 <ivanm> it's a requirement AFAIK
01:31:24 <ivanm> hsplugins requires ghc, ghc requires bytestring 0.9.0.1, and all packages need to be built with the same bersion of bytestring
01:31:30 <ivanm> @go diamond dependency problem
01:31:36 <lambdabot> http://blog.well-typed.com/2008/08/solving-the-diamond-dependency-problem/
01:31:36 <lambdabot> Title: blog.well-typed.com » Blog Archive » Solving the diamond dependency problem
01:31:43 <ivanm> davidL: ^^ see that post
01:33:20 <mm_freak> i tried to write a subsets function yesterday and it really caused me a lot of headache…  and as always i sleep over it, wake up in the morning and find that it's as always just a simple fold
01:33:33 <mm_freak> subsets = foldr (\x ys -> map (x:) ys ++ ys) [[]]
01:35:31 <haskellian> ?syntax Data.Map
01:35:31 <lambdabot> Unknown command, try @list
01:35:40 <haskellian> @list Data.Map
01:35:40 <lambdabot> No module "Data.Map" loaded
01:35:49 <haskellian> how do i create a map?
01:35:59 <ivanm> davidL: hmmm... looks like it isn't needed now... just updated cabal-install's cache and it isn't asking...
01:36:41 <davidL> ivanm: asking for bytestring?
01:36:52 <shukhov> haskellian: use the "empty" map in Data.Map
01:37:33 <ivanm> davidL: nope
01:37:43 <ivanm> it's just wanting to rebuild everything I've already got installed :o
01:37:49 <davidL> ivanm: are you using darcs version of cabal-install?
01:38:08 <ivanm> yes
01:47:39 <haskellian> I'm looking at http://www.haskell.org/tutorial/classes.html but don't quite get it, what is a class in a short description?
01:47:40 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
01:48:31 <thomashartman1> it's kind of like an interface that a concrete type has to implement
01:48:50 <thomashartman1> if you want your type to be a member of the Eq class, you need to implement ==
01:49:13 <mapreduce> haskellian: What's the programming language you're most familiar with?
01:49:17 <quicksilver> haskellian: it's a way to overload operators.
01:49:42 <quicksilver> haskellian: it's nothing like a 'class' in any other language
01:49:46 <quicksilver> (well, almost nothing like)
01:50:04 <haskellian> python
01:50:29 <Vq^> haskellian: then it's most similar to zope interfaces
01:50:35 <haskellian> ok I get it now kind og
01:50:45 <haskellian> haven't used zope(web framework right?)
01:51:04 <Vq^> their interface library is used quite a lot outside of zope
01:51:33 <haskellian> haskell is very interesting to learn, you learn a lot! not just about programming but math etc
01:51:41 <quicksilver> haskellian: the canonical example of a class is Num.
01:51:49 <Axman6> @type (>>=) :: Maybe Int
01:51:51 <lambdabot>     Couldn't match expected type `Maybe Int'
01:51:51 <lambdabot>            against inferred type `m a -> (a -> m b) -> m b'
01:51:54 <quicksilver> haskellian: Num is the class of all types which support (+),(*) etc.
01:51:59 <Axman6> @type (>>=) :: Maybe a
01:52:01 <lambdabot>     Couldn't match expected type `Maybe a'
01:52:01 <lambdabot>            against inferred type `m a1 -> (a1 -> m b) -> m b'
01:52:03 <Axman6> @type (>>=) :: Maybe
01:52:05 <lambdabot>     `Maybe' is not applied to enough type arguments
01:52:05 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
01:52:05 <lambdabot>     In an expression type signature:
01:52:08 <Axman6> rawr
01:52:14 <mapreduce> :t \x -> x + 1
01:52:16 <lambdabot> forall a. (Num a) => a -> a
01:52:19 <quicksilver> haskellian: so, what a class is, is a way to overload operators like (+) and (*) so you can use them on multiple types.
01:52:37 <mapreduce> The above function is defined for all types that are a member of the class Num.
01:52:42 <mapreduce> @src Num
01:52:42 <lambdabot> class  (Eq a, Show a) => Num a  where
01:52:42 <lambdabot>     (+), (-), (*)           :: a -> a -> a
01:52:42 <lambdabot>     negate, abs, signum     :: a -> a
01:52:42 <lambdabot>     fromInteger             :: Integer -> a
01:52:43 <Axman6> @type (Just 1 >>=)
01:52:45 <haskellian> i hava data RedBlackTree deriving Eq, do I have to implement Eq then or what does Eq defualt to?
01:52:45 <lambdabot> forall t b. (Num t) => (t -> Maybe b) -> Maybe b
01:52:59 <haskellian> I can also create my own operators it seems no?
01:53:02 <mapreduce> Something that is a member of the class Num has all the operations above.
01:53:09 <ac> is there a function in the prelude or stdlib that does: \x -> x - (fromIntegral $ floor x) -- ?
01:53:11 <mapreduce> haskellian: Operators == functions in this context.
01:53:27 <Axman6> > [a] >>= return
01:53:27 <haskellian> quiksilver: i see
01:53:30 <lambdabot>  mueval: Time limit exceeded
01:53:30 <mapreduce> haskellian: Operators as other languages define them are pretty much functions with symbolic names.
01:53:35 <Axman6> > [1] >>= return
01:53:38 <lambdabot>  [1]
01:53:41 <thomashartman1> haskellian: ask ghci for information about the Eq class. in ghci, :info Eq
01:53:45 <mapreduce> > let 4+6=10 in 4+6
01:53:48 <lambdabot>  mueval: Time limit exceeded
01:53:55 <Smurfen_> If I want an empty string, does it make any difference if I use "" or "\0"? Same question goes for spaces, " " or "\SP"?
01:54:01 <BeelsebobWork> @let return = id
01:54:02 <lambdabot> Defined.
01:54:06 * BeelsebobWork hides
01:54:07 <jacobian> supposing you disallow infinitely constructed data such that every data type description actually refers to a least-fixed point rather than greatest
01:54:08 <mapreduce> > "" == "\0"
01:54:11 <lambdabot>  False
01:54:12 <quicksilver> Smurfen_: "" is very different from "\0"
01:54:18 <mapreduce> > " " == "\SP"
01:54:21 <lambdabot>  mueval: Time limit exceeded
01:54:27 <jacobian> under these conditions, what restrictions are necessary on the datatype to make it denumerable?
01:54:28 <mapreduce> What's this mueval thing?
01:54:30 <thomashartman1> Smurfen_: TITS... in ghci: "" == "\0" -> False
01:54:39 <mapreduce> thomashartman1: TITS?
01:54:42 <quicksilver> Smurfen_: however, there is no difference between " " and "\SP"
01:54:44 <thomashartman1> Try It To See
01:55:01 <Smurfen_> Ah
01:55:08 <Smurfen_> I thought it was just a way to get my attention :)
01:55:17 <Smurfen_> It worked, though
01:55:44 <BeelsebobWork> Smurfen_: just so you know the difference -- "" is syntactic sugar for [ ] :: [Char].  "\0" is syntactic sugar for ['\0']
01:56:00 <Smurfen_> Ah
01:56:16 <Smurfen_> But " " and "\SP" are squivalent?
01:56:17 <mapreduce> [] :: [Char] just means "an empty list of Chars"
01:56:25 <Vq^> it's only in assembler when using C libraries one has to write \0 in the end of a string
01:56:32 <BeelsebobWork> Smurfen_: yes, because ' ' and '\SP' are the same character
01:56:34 <BeelsebobWork> mapreduce: yep
01:56:38 <Smurfen_> Ok
01:56:56 <BeelsebobWork> Smurfen_: remember, putting a null terminator on a string is a pure C convention
01:57:02 <BeelsebobWork> even similar languages do it differently
01:57:11 <BeelsebobWork> e.g. pascal makse the first character the string length
01:57:36 <ejt> morning
01:57:46 <mapreduce> And you set an upper limit on the length of the string in Pascal.
01:58:05 <mapreduce> Because it's a non-resizeable array under the hood.  Not very far under the hood.
01:59:35 <mapreduce> How would you get from Int -> Boolean to Int -> Maybe Int ?
01:59:54 <mapreduce> @hoogle (Int -> Boolean) -> (Int -> Maybe Int)
01:59:54 <lambdabot> Warning: Unknown type Boolean
01:59:55 <lambdabot> Prelude . :: (b -> c) -> (a -> b) -> a -> c
01:59:55 <lambdabot> Data.Function . :: (b -> c) -> (a -> b) -> a -> c
01:59:56 * _zenon_ really has to get another coffee
02:00:05 <mapreduce> @hoogle (Int -> Bool) -> (Int -> Maybe Int)
02:00:05 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:00:06 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
02:00:06 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:00:57 <quicksilver> mapreduce: I have occasionally wondered if that operation deserves a name.
02:01:04 <quicksilver> mapreduce: it doesn't have one as far as I know.
02:01:11 <quicksilver> if p x then Just x else Nothing
02:01:24 <quicksilver> or, if you like guard (p x) >> return x
02:01:38 <BeelsebobWork> quicksilver: surely if' p Just (const Nothing) is a nicer one
02:01:39 <Axman6> @src guard
02:01:39 <lambdabot> guard True  =  return ()
02:01:39 <lambdabot> guard False =  mzero
02:02:16 <Axman6> @src (>>)
02:02:16 <lambdabot> m >> k      = m >>= \_ -> k
02:02:24 <quicksilver> BeelsebobWork: that's not the normal definiton of if'
02:02:38 <quicksilver> BeelsebobWork: are you trying to lift it into the reader monad, maybe?
02:02:44 <Axman6> @type (>>)
02:02:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:02:50 <BeelsebobWork> no, I'm trying to lift if to applicative
02:02:59 <quicksilver> well, the reader applicative then.
02:03:01 <quicksilver> (same thing)
02:03:05 <BeelsebobWork> no, applicative
02:03:11 <BeelsebobWork> no readers about it
02:03:17 <quicksilver> which applicative?
02:03:53 <BeelsebobWork> whichever you chose
02:04:02 <quicksilver> but p has a concrete type
02:04:06 <quicksilver> p :: Int -> Bool
02:04:08 <BeelsebobWork> if' = liftA3 (\c t e -> if c then t else e)
02:04:37 <haskellian> has anyoen seen an atom with a microscope?
02:04:37 <BeelsebobWork> if' :: Applicative f => f Bool -> f a -> f a -> f a
02:04:57 <quicksilver> ok, so you are using the reader applicative
02:04:57 <mapreduce> quicksilver: Thanks.
02:05:01 <quicksilver> (in mapreduce's case)
02:05:39 <BeelsebobWork> in that case, yes
02:06:44 <quicksilver> That's not often a useful if'
02:06:56 <BeelsebobWork> that's the most useful if' I've ever come across
02:06:57 <quicksilver> in particular, it's a pretty surprising if' in applicatives which have side-effects
02:07:00 <BeelsebobWork> I use it almost everywhere
02:07:09 <BeelsebobWork> yeh -- I don't use applicatives with side effects
02:07:15 <BeelsebobWork> I do functional programming
02:07:17 <quicksilver> because it causes the side-effect of all the clauses, even those which don't get executed.
02:07:45 <quicksilver> you don't do parsing then?
02:07:52 <quicksilver> that's a common applicative with a side effect
02:07:59 <BeelsebobWork> since when does parsing have anything to do with side effecting
02:08:14 <BeelsebobWork> it's a function from token stream to AST
02:08:16 <BeelsebobWork> and it's pure
02:08:20 <quicksilver> of course it's pure.
02:08:28 <BeelsebobWork> and it doesn't have side effects
02:08:33 <quicksilver> most monads are pure and yet they still have side effects.
02:08:35 <BeelsebobWork> some implementation in your head may have side effects
02:08:42 <BeelsebobWork> but my implementation doesn't
02:08:42 <quicksilver> the effect of a parsing monad is to consume the token stream
02:08:53 <BeelsebobWork> not mine
02:08:57 <quicksilver> don't you dare patronise me.
02:09:04 <earthy> ????
02:09:08 <earthy> folks folks
02:09:11 <earthy> calm down
02:09:17 <earthy> it's just perspective
02:09:24 <BeelsebobWork> I'm not patronising you - I'm pointing out an assumption you're making
02:09:32 <quicksilver> I'm not making any assumptions.
02:09:32 <BeelsebobWork> that I would always want to use side-effecting code to parse things
02:09:37 <BeelsebobWork> which is rubbish
02:09:41 <BeelsebobWork> because I would never want to do that
02:09:45 <ivanm> when did Data.Bytestring.Base get split up?
02:09:45 <quicksilver> I'm using an meaning of the term 'effect' which differs from yours.
02:09:56 <quicksilver> my term is the standard term, though.
02:10:03 <BeelsebobWork> no
02:10:07 <quicksilver> as used by people who discuss applicatives, monads, and arrows.
02:10:08 <BeelsebobWork> there's no different definition
02:10:10 <earthy> beelsebobwork: do you want to have to explicitly write down the handling of the input stream in your definition of the parser?
02:10:13 <BeelsebobWork> I don't do programming with side effects
02:10:15 <dobblego> yes there is
02:10:22 <quicksilver> there is a different definition, BeelsebobWork
02:10:27 <BeelsebobWork> dobblego: not in this conversation there isn't
02:10:32 <quicksilver> the 'effect' of a state monad action is to change the state.
02:10:40 <quicksilver> the 'effect' of a parser action is to consume tokens.
02:10:40 <dobblego> clearly there is, evidenced by quicksilver
02:10:43 <BeelsebobWork> since when do I use the state monad?
02:10:47 <quicksilver> it was an example.
02:10:53 <quicksilver> parser is another example.
02:10:59 <BeelsebobWork> I repeat... I DON'T USE THINGS WITH SIDE EFFECTS
02:11:04 <BeelsebobWork> I'm a functional programmer
02:11:14 <quicksilver> The if' combinator you described has a surprising behaviour in the context of a parser applicative.
02:11:15 <earthy> beelsebobwork: 'side effect' /= 'effect'
02:11:21 <quicksilver> it consumes the tokens needed for both branches.
02:11:33 <quicksilver> that "consumption of tokens" is what I term an "effect".
02:11:38 <Vq^> isn't the whole point of applicatives and monads to have effects?
02:11:40 <dobblego> Applicative Programming with ***Effects***
02:11:41 <BeelsebobWork> quicksilver: yes, and that's why I don't use the parser applicative that you're thinking of
02:11:41 <mapreduce> To be fair, quicksilver switched between saying side effect and effect.
02:11:44 <haskellian> can I make up my own operator? like using =:= for 4 =:= 4.0 -> False
02:11:56 <quicksilver> (I'm not alone here, though, that's the standard definition of effect)
02:12:06 <mapreduce> > let 4 =:= 4.0 = False in 4 =:= 4.0
02:12:08 <Axman6> haskellian: erlang equality?
02:12:08 <lambdabot>  mueval: Time limit exceeded
02:12:09 <dobblego> > let (=:=) = 7 in (=:=)
02:12:12 <lambdabot>  mueval: Time limit exceeded
02:12:13 <quicksilver> mapreduce: I did, because BeelsebobWork didn't like the usage "side effect" and I felt it was hindering communication.
02:12:16 <haskellian> axman: yes
02:12:17 <Vq^> mapreduce: is it really so different?
02:12:24 <earthy> an effect is anything that does happen but is not explicitly shown in the code.
02:12:25 <mapreduce> Vq^: Dunno.
02:12:28 <haskellian> mapreduce: but for all numbers
02:12:31 <quicksilver> mapreduce: however, standard terminology is actually to use 'side effect' and 'effect' synonymously in this context.
02:12:44 <mapreduce> haskellian: let x =:= y = False in 4 =:= 4.0
02:12:45 <quicksilver> the context of arrows, monads, and applicatives.
02:12:51 <quicksilver> (some people choose 'computational effect')
02:12:55 <earthy> side effect has the connotation of 'stuff beyond your program' such as IO
02:13:00 <BeelsebobWork> quicksilver: so, why then, are you getting so het up at me using them interchangably?
02:13:04 <quicksilver> I'm not.
02:13:08 <earthy> even though it strictly doesn't mean that
02:13:10 <quicksilver> I believe you are misunderstanding my point.
02:13:21 <BeelsebobWork> oh, neither you are
02:13:23 <quicksilver> You say your parser applicative doesn't consume tokens as an effect?
02:13:23 <BeelsebobWork> it was other people
02:13:34 <quicksilver> then I don't know what your parser applicative does
02:13:35 <BeelsebobWork> quicksilver: no, I say I don't use the parser applicative
02:13:39 <quicksilver> ah, OK.
02:13:43 <quicksilver> which applicatives do you use then?
02:13:51 <earthy> the point of applicative combinators is to 'hide' explicit handling of the token stream
02:14:00 <haskellian> mapreduce: i dont get it , how would I generalize that so anywhere in my program I could ask "x =:= y"
02:14:06 <earthy> (that lacked 'parser' somewhere)
02:14:09 <BeelsebobWork> quicksilver: at the moment, the Event, Reactive, Fun, etc
02:14:17 <BeelsebobWork> various others on other days
02:14:21 <Axman6> > 4 == 4.0
02:14:24 <lambdabot>  mueval: Time limit exceeded
02:14:32 <Axman6> ...
02:14:34 <Axman6> > 4 == 4.0
02:14:35 <haskellian> yes
02:14:36 <lambdabot>  True
02:14:50 <haskellian> but i want 4==4.0 True but 4=:=4.0 False
02:14:57 <BeelsebobWork> incidentally quicksilver here's an interesting use of that def of if'
02:14:59 <BeelsebobWork> satisfiesM p x = x >>= if' p return (const (satisfiesM p x))
02:15:02 <Axman6> > (4 :: Integer) == (4.0 :: Double)
02:15:04 <lambdabot>  Couldn't match expected type `Integer'
02:15:05 <mapreduce> haskellian: Because 4 is an Int and 4.0 is a Double?
02:15:08 <haskellian> and 4.0=:=4.0 True
02:15:21 <earthy> you want a type conformity check?
02:15:28 <haskellian> map: yes, not that i specifically need it now, just playing around with haskell and exploring
02:15:35 <mapreduce> haskellian: You don't need =:= because the typesystem will disallow Int == Double.
02:15:53 <haskellian> map: true
02:16:02 <Axman6> unlike erlang, they're not interchangable
02:16:06 <mapreduce> Oh, "map:" lines are to me.
02:16:18 <thomashartman1> > :i (==)
02:16:20 <lambdabot> Terminated
02:16:39 <Vq^> > Left (4 :: Int) == Right (4.0 :: Double)
02:16:40 <Axman6> @info (==)
02:16:40 <lambdabot> (==)
02:16:42 <lambdabot>  mueval: Time limit exceeded
02:16:56 <mapreduce> @increaseTimeLimit
02:16:56 <lambdabot> Unknown command, try @list
02:17:00 <thomashartman1> @list
02:17:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:17:15 <BeelsebobWork> quicksilver: also, sorry for accusing you of something you didn't do there -- about 3 people attacked me for it at the same time, and I thought one was you
02:17:29 <thomashartman1> @type (==)
02:17:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:18:09 <haskellian> buti can do 4+4.0, lets say i dont want to add but divide if my function gets 4 and 4.0 as parameters
02:18:38 <thomashartman1> haskellian: if you don't specify the types are different, haskell figures a way to make them the same
02:18:56 <thomashartman1> I forget how though. does it just assume they're doubles?
02:19:02 <Axman6> haskellian: the 4 becomes 4.0 i think
02:19:40 <thomashartman1> @type 4 + 4.0
02:19:42 <lambdabot> forall t. (Fractional t) => t
02:19:59 <mapreduce> 4 is a Num, though none in particular, until forced.
02:20:03 <mapreduce> :t 4
02:20:05 <lambdabot> forall t. (Num t) => t
02:20:11 <mapreduce> :t 4 :: Integer
02:20:13 <lambdabot> Integer
02:20:16 <mapreduce> :t 4 :: Double
02:20:18 <lambdabot> Double
02:20:38 <thomashartman1> is there a way to figure out what happens when it's forced, behind the scenes, using the ghci/lambdabot info system?
02:20:40 <trzkril> :t +
02:20:42 <lambdabot> parse error on input `+'
02:20:48 <trzkril> :t (+)
02:20:50 <lambdabot> forall a. (Num a) => a -> a -> a
02:20:54 <mapreduce> thomashartman1: Yes, look at the types.  The 'forcing' is done at compile time.
02:21:12 <haskellian> thomas: havent tried just lets say i want to tell the difference, in python i can do type(x)==int, can i in haskell?
02:21:14 <Axman6> :t (4+)
02:21:16 <lambdabot> forall t. (Num t) => t -> t
02:21:24 <mapreduce> :t \x => x+1
02:21:25 <lambdabot> parse error on input `=>'
02:21:31 <mapreduce> :t \x -> x+1
02:21:33 <lambdabot> forall a. (Num a) => a -> a
02:21:37 <mapreduce> :t \x -> x/1
02:21:39 <lambdabot> forall a. (Fractional a) => a -> a
02:21:44 <thomashartman1> haskellian: you'll get info by usint :t however it might not tell you a concrete type
02:22:04 <trzkril> :t 4.0
02:22:04 <haskellian> yes but at runtime?
02:22:06 <lambdabot> forall t. (Fractional t) => t
02:22:13 <thomashartman1> in the examples we're seeing, it tells you, what you're doing will work for types in typeclass Fractional, or Num, or whatever
02:22:15 <Axman6> haskellian: there's no need
02:22:16 <mapreduce> Because / is on Fractional and not Num, \x -> x/1 makes x a Fractional of some type.
02:22:24 <mapreduce> haskellian: At runtime there are no types.
02:22:49 <mapreduce> What you're used to as dynamic types are probably more accurately described as tagged values.
02:22:51 <Axman6> it won't compile basically
02:23:16 <earthy> number denotations are fed into 'fromInteger' and  'fromRational' respectively
02:23:19 <Axman6> you can make something take say Double's be using func :: Double -> Something
02:23:26 <earthy> fromInteger  :: (Num a) => Integer -> a
02:23:34 <earthy> fromRational :: (Fractional a) => Rational -> a
02:23:46 <earthy> see section 6.4.1 of the Haskell '98 report
02:24:10 <haskellian> print (4/4.0)
02:24:10 <haskellian>   works
02:24:29 <earthy> hasekellian: and you want it to not work?
02:24:45 <earthy> ???
02:24:53 <haskellian> i want: if type(x)==int then x/4 else x*x
02:25:07 <thomashartman1> :t 4 + 4.0
02:25:09 <lambdabot> forall t. (Fractional t) => t
02:25:38 <haskellian> or wait, ic ant have a function that could sometimes return float sometime sint right?
02:25:47 <mapreduce> haskellian: Right, you can't.
02:25:50 <thomashartman1> @i Double
02:25:50 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
02:25:51 <mapreduce> You could use Either for that.
02:26:02 <haskellian> ok thanks
02:26:25 <mapreduce> > (\x -> if x<10 then Left(4.0) else Right(6)) 5
02:26:27 <thomashartman1> @type Double
02:26:28 <lambdabot>  mueval: Time limit exceeded
02:26:29 <lambdabot> Not in scope: data constructor `Double'
02:26:39 <mapreduce> :t \x -> if x<10 then Left(4.0) else Right(6)
02:26:41 <lambdabot> forall a t b. (Num b, Fractional t, Ord a, Num a) => a -> Either t b
02:26:49 <mapreduce> I'll simplify that.
02:27:05 <mapreduce> :t \x -> if x<10 then Left(4.0) else Right(6) :: Int -> Either Double Int
02:27:07 <lambdabot>     Couldn't match expected type `Int -> Either Double Int'
02:27:07 <lambdabot>            against inferred type `Either a t'
02:27:07 <lambdabot>     In the expression:
02:27:09 <mapreduce> Or not.
02:27:44 <thomashartman1> When I do 4 + 4.0 it's clear that 4 becomes something other than integer. But how do I know whether it's Double, Float, or something else behind the scenes?
02:28:47 <mapreduce> thomashartman1: Depends where you use it.
02:29:14 <thomashartman1> say at the toplevel of ghci
02:29:18 <mapreduce> If you use it in a context that expects a Double it is a Double.
02:31:03 <thomashartman1> It seems there's no way to see what concrete type ghci actually unifies it into other than reading the ghci source/documentation
02:31:13 <cjs> @seen dcoutts
02:31:14 <lambdabot> dcoutts has changed nick to dcoutts_.
02:31:14 <lambdabot> dcoutts_ is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts_ speak 7h 53m 9s ago.
02:31:47 <mapreduce> thomashartman1: This seems to be on purpose.
02:32:30 <mapreduce> > 16777216 + 1.0
02:32:33 <lambdabot>  mueval: Time limit exceeded
02:32:46 <mapreduce> (answer: 16777217)
02:32:53 <mapreduce> > 16777216 + 1.0 :: Float
02:32:56 <lambdabot>  1.6777216e7
02:33:01 <mapreduce> bzzt :)
02:33:10 <thomashartman1> mapreduce: fair enough. But every value does get a concrete type during the compile phase right?
02:33:17 <mapreduce> Yes.
02:33:42 <mapreduce> Did you notice the difference in answers in those last two?
02:33:45 <cjs> @tell dcoutts_ Ping me if you have a sec to help with some cabal parameters--I'm getting "Could not find module `Data.Map': it is a member of package containers-0.1.0.2, which is hidden" when trying to use a separate package file.
02:33:45 <lambdabot> Consider it noted.
02:34:06 <cjs> Unless anybody else has any ideas? Any Cabal experts around?
02:34:19 <thomashartman1> mapreduce: yes but I don't know what it means
02:34:51 <thomashartman1> I guess it means ghci is smarter than mueval
02:34:53 <mapreduce> thomashartman1: Float and Double are both imprecise types.  You can tell which is used by observing rounding errors.
02:35:05 <quicksilver> BeelsebobWork: according to my copy of reactive, Events are not a useful applicative.
02:35:11 <thomashartman1> or rather, ghci has some defaulting mechanism for types that mueval doesn't
02:35:17 <mapreduce> lambdabot is quite screwed up, don't read much into lambdabot's error messages.
02:35:22 <mapreduce> No.
02:35:28 <mapreduce> Try both of those in ghci.
02:35:31 <ivanm> is there a way of mapping over arrays such that I can use the index value as a parameter of my mapping function?
02:35:36 <BeelsebobWork> quicksilver: no, Event's def of Applicative is only there for completenes -- Reactive's is useful though
02:35:37 <thomashartman1> i did, and they work
02:35:41 <BeelsebobWork> as is Behavior's
02:35:45 <thomashartman1> ghc 6.8.2
02:35:47 <mapreduce> thomashartman1: But they give different results to each other.
02:35:49 <ivanm> i.e. something like: (i -> e -> e') -> a i e -> a i e' ?
02:36:09 <BeelsebobWork> quicksilver: also, we're rethinking how Events work -- there's a number of problems with them at the moment that need to get sorted out
02:36:19 <thomashartman1> mapreduce: same result
02:36:33 <mapreduce> thomashartman1: 16777217 for the first, 16777216 for the second.
02:37:13 <thomashartman1> mapreduce: i get 216 for both
02:37:29 <thomashartman1> correction: ghc 6.8.3
02:37:37 <mapreduce> 6.8.2 here
02:37:46 <quicksilver> :t ixmap
02:37:48 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
02:37:49 <thomashartman1> -> launch missiles ;)
02:38:37 <mapreduce> thomashartman1: Could you pastebin your ghci session?
02:38:55 <ivanm> quicksilver: yes, but that just applies a function on the indices...
02:38:55 <mapreduce> I didn't think Haskell's types differed per-machine.
02:38:59 <quicksilver> ivanm: I think you have to go via 'assocs'
02:39:02 <ivanm> :(
02:39:36 <ivanm> or else use an external library? e.g. carray ?
02:39:42 <thomashartman1> ? hpaste
02:40:05 <thomashartman1> @? hpaste
02:40:05 <lambdabot>  hpaste
02:41:17 <ivanm> oh, CArray is meant to be slower than IArray :(
02:42:03 <quicksilver> BeelsebobWork: yes, Reactive is a rather unusual Applicative because its effects are only observable in its result.
02:42:19 <quicksilver> BeelsebobWork: so if you discard the result, you don't need to worry about the effect.
02:42:20 <BeelsebobWork> quicksilver: what, you mean conal wrote a functional program in Haskell?
02:42:22 <BeelsebobWork> how dare he?
02:42:24 <BeelsebobWork> :D
02:42:37 <quicksilver> you might call them 'affine', I think.
02:42:46 <quicksilver> that's not typically applicative behaviour.
02:43:10 <quicksilver> (and this has nothing to do with a program being 'functional' or otherwise, but I'm not going to re-hash last weeks argument)
02:43:22 <thomashartman1> mapreduce: http://hpaste.org/9930
02:43:27 <thomashartman1> I get inconsistent behavior from ghci
02:44:21 <BeelsebobWork> quicksilver: bottom line, things like referential transparency and "effects being only observable in the result" are *central* to why I do functional programming
02:44:29 <BeelsebobWork> these aren't unusual things to me
02:44:35 <ejt> thomashartman1: Float in one Double in other
02:44:36 <BeelsebobWork> they're crucial things to me
02:45:04 <quicksilver> BeelsebobWork: using, for example, parser monads or state monads doesn't have any referential transparency consequence.
02:45:20 <thomashartman1> oops
02:45:25 <quicksilver> it's merely a way of abstracting over a particular (purely functional) pattern of arguments and results.
02:45:44 <mapreduce> thomashartman1: That looks how I expected.
02:45:56 <mapreduce> thomashartman1: So by inspection it appears that ghci defaults to Double.
02:46:02 <BeelsebobWork> quicksilver: yes, but it does have a "effects being only observable in the result" consequence
02:46:05 <BeelsebobWork> hence, I don't use them
02:46:26 <thomashartman1> i see, I see. thanks.
02:46:36 <igel> is there a standard function to convert an (Either String a) to (Monad a)?
02:46:53 <quicksilver> igel: (a) please don't do that.
02:46:59 <quicksilver> (b) either fail return
02:47:03 <aeolist> hello #haskell :)
02:47:35 <igel> quicksilver: why not? you've got to unpack an Either somewhere
02:47:48 <quicksilver> igel: because 'fail' is a wart and shouldn't exist.
02:48:34 <igel> true
02:48:39 <igel> so true
02:49:27 <mapreduce> Is it a wart because it makes one side of the Either seem like a failure rather than a valid path?
02:49:42 <quicksilver> no, that's fine.
02:49:48 <thomashartman1> mapreduce: i overlooked your earlier comment about rounding
02:49:50 <quicksilver> it's a wart because it exists in Monad.
02:50:00 <quicksilver> when some Monads do not have a useful notion of failure.
02:50:10 <quicksilver> it should be in MonadZero or MonadPlus or something like that.
02:50:53 <igel> you can easily see that, if you have a look at the default definition auf fail, which is error
02:52:21 <thomashartman1> > 4 + 1
02:52:23 <lambdabot>  5
02:53:03 <quicksilver> BeelsebobWork: that would also rule out the Error and Maybe monads then?
02:53:13 <quicksilver> BeelsebobWork: I think you really don't like monads or applicatives very much :)
02:53:14 <mapreduce> > 2000000000 + 2000000000
02:53:17 <lambdabot>  4000000000
02:53:21 <BeelsebobWork> quicksilver: no, I really don't
02:53:21 <mapreduce> > 2000000000 + 2000000000 :: Int
02:53:24 <lambdabot>  mueval: Time limit exceeded
02:53:27 <BeelsebobWork> you noticed did you?
02:53:54 <mapreduce> -294967296 is what ghci says to the above.
02:53:56 <Cale_> Time limit?
02:58:00 <quicksilver> BeelsebobWork: do you also dislike combinators in general?
02:58:10 <BeelsebobWork> no, not at all
02:58:25 <BeelsebobWork> I dislike things that have side effects
02:58:35 <quicksilver> because higher-order combinators frequently conceal, to some extent, the details of what they do.
02:58:36 <BeelsebobWork> because they invariably cause problems in otherwise beautiful code
02:59:11 <BeelsebobWork> I probably dislike those ones, if I really can tell that they're doing something different (for example by using my if' and discoving odd behavior)
02:59:46 <quicksilver> well parsing is certainly one popular example
02:59:54 <quicksilver> but maybe that's not something you happen to do much of
03:00:07 <|Steve|> I looked at Parsec. Painful.
03:00:09 <BeelsebobWork> no, I write a good few parsers -- I just rarely use the combinators for them
03:00:28 <BeelsebobWork> depends if I'm in the mood to write nice code, or write quickly written non-functional code
03:01:54 * BeelsebobWork notes that his typo (filp) really should be a function
03:03:41 <quicksilver> BeelsebobWork: you explicitly pass the list of tokens unconsumed around between the different productions?
03:03:51 <BeelsebobWork> occasionally
03:03:55 <BeelsebobWork> depends on my mood
03:04:09 <BeelsebobWork> depends on what I feel is the best approach that day
03:04:17 <ivanm> has anyone ever implemented the complete elliptic integrals in haskell?
03:04:31 <quicksilver> I think it's an unusual metric which makes that 'nice code' as compared to nicely making the token stream implicit.
03:04:55 <BeelsebobWork> quicksilver: depends what you're trying to accieve
03:05:03 <quicksilver> that's true.
03:05:23 <BeelsebobWork> in a lot of ways I feel that parser combinators that stop the token stream being explicit are fairly nasty
03:05:27 <BeelsebobWork> in that parsers are all about token streams
03:05:45 <BeelsebobWork> if I read parsing code, what I want to be constantly reminded of is which bits of the token stream are going where
03:06:41 <BeelsebobWork> but at the end of the day, the most common approach to writing parsers I use is to write a .y file
03:10:10 <aeolist> :t /topic
03:10:11 <lambdabot> parse error on input `/'
03:10:15 <aeolist> mmmm
03:10:21 <aeolist> :t topic
03:10:23 <lambdabot> Not in scope: `topic'
03:10:39 <BeelsebobWork> @help topicCons
03:10:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:10:40 <aeolist> meh, it's a list of strings! inference it already!
03:10:54 <BeelsebobWork> ah bugger, can't have been the right spelling
04:05:34 <juhe> Hello people, I'm trying to get this http://hpaste.org/9931 working, but I have troubles.... Any idea how to make it working?
04:07:27 <Saizan> juhe: R can't be both MonadReader RConfig and MonadReader Connection
04:08:10 <Saizan> because MonadReader is defined with a functional dependency MonadReader r m | m -> r
04:08:24 <dcoutts> cjs: pong
04:09:02 <Botje> juhe: you could use ReaderT (RConfig, Maybe Connection) ?
04:09:12 <juhe> Saizan: Hm, is there a way how to get what I want? I.e. have two different readers - one for RConfig another one for Connection?
04:09:17 <Saizan> the solution is to not derive those but write your own primitives like askConfig = R ask, askConnection = R (lift ask)
04:09:18 <juhe> Hm, that might work
04:09:44 <Saizan> or use a tuple/record, yeah
04:09:49 <juhe> Yes, this sounds good.
04:10:19 <dcoutts> davidL: did you work out the dep conflict
04:10:41 <juhe> Hm, but I think I won't modify the Nothing to Maybe someConnection later.
04:10:56 <juhe> actually, local could do this for me...
04:11:08 <Botje> woops, heh
04:11:15 <Botje> i'm used to working with state :)
04:12:25 <Saizan> oh, why introducing Maybe?
04:12:57 <juhe> You are right, there's no need for Maybe :-)
04:13:33 <cjs> dcoutts: Ping!
04:14:18 <dcoutts> cjs: so the error message from ghc is unhelpful, what is going on is that Cabal tells ghc to hide all packages except the ones you list in build-depends.
04:14:39 <cjs> Ah! So I just list it and I'm ok?
04:14:44 <dcoutts> cjs: so what that's saying is there's a module you need, but it's hidden, because it's not listed in build-depends.
04:14:47 <juhe> Saizan: What exactly that 'MonadReader r m | m -> r' means? I've seen this type of writing only in sources of MonadReader class. (Maybe pointer to doc would be helpful).
04:15:40 <Saizan> juhe: it means that for every m there must be only one r, or equivalently from m you can determine r
04:16:02 <dcoutts> cjs: so yeah, unfortunately at the moment you need to understand the underlying mechanism for the error message to make sense. In future cabal will do the dep chasing itself so will be able to tell you that you're missing things from build-depends.
04:16:42 <Saizan> juhe: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
04:16:50 <juhe> Saizan: Ok, bulb lighted :-)
04:16:56 <juhe> Saizan: Thanks for link
04:17:34 <MarcWeber> Saizan: would you mind having a look at http://rafb.net/p/Fp4Lwg84.html  :))
04:17:39 <lambdabot> Title: Nopaste - No description
04:17:48 <MarcWeber> I'm puzzled again because I don't see why the instance is not matched
04:20:44 <MarcWeber> If someone else wants to help me, you can get the full code using git clone git://mawercer.de/vxml && git checkout origin/test
04:22:43 <cjs> dcoutts: Yeah, that fixed that. So, on to the next....
04:23:31 <cjs> Really, cabal should be able to figure out that build-depends itself, though, right?
04:24:01 <cjs> Though it's reasonable to be able to specify it if you want to make sure you don't add depends without knowing about it.
04:24:50 <Saizan> MarcWeber: the last parameter of Element in the first and fourth parameter of AddElT are the same in the instance
04:25:23 <Saizan> MarcWeber: while in the error one is HTrue and the other is HFalse
04:26:27 <cjs> This Paths_tsuru_trader module is very nice.
04:26:52 <cjs> Now I see what you mean about the env vars.
04:30:06 <cjs> dcoutts: Ah! So main-is does not actually specify a module to use instead of Main, a la the ghc --main-is flag, does it?
04:32:07 <cjs> So what do I use for that? ghc-options?
04:32:24 <explicitjelly> hello.
04:32:43 <explicitjelly> I'm just checking out Arrows
04:35:09 <explicitjelly> can anybody tell me why Arrows seem particularly nice for event processing?
04:35:37 <BeelsebobWork> they do?
04:35:38 <explicitjelly> because there's a javascript Arrow library on the rise, which eases event processing.
04:35:40 <dcoutts> cjs: ghc's main-is is not supported. The main-is cabal field gives a file for a Main module
04:35:52 <explicitjelly> BeelsebobWork, http://blog.tupil.com/look-ma-no-callbacks/
04:36:00 <lambdabot> Title: Tupil Code Blog » Blog Archive » Look ma, no callbacks!
04:36:22 <mapreduce> explicitjelly: I think the question is related to "why do conveyor belts seem particularly nice for manufacturing?".
04:36:24 <BeelsebobWork> explicitjelly: I wouldn't use "javascript does it" as a reason for them being nice
04:36:28 <dcoutts> cjs: see http://hackage.haskell.org/trac/hackage/ticket/179
04:36:34 <lambdabot> Title: #179 (support GHC's main-is extension) - Hackage - Trac
04:36:47 <explicitjelly> mapreduce, ok, I meant "for example", "particularly" was the wrong word
04:37:29 <explicitjelly> or does anybody have a better example for using arrows?
04:37:30 <mapreduce> explicitjelly: I think the answer is related to how conveyor belts seem particularly nice for manufacturing.
04:37:43 <explicitjelly> mapreduce, what do you mean?
04:37:50 <quicksilver> explicitjelly: You don't see many arrows which aren't the kleisli arrows of a monad.
04:37:56 <explicitjelly> (what's a conveyor belt, by the way? I will look that up)
04:38:09 <quicksilver> in which case, arrows are just a particular way of composing monad actions
04:38:17 <explicitjelly> quicksilver, I understand that arrows are a further generalization...
04:38:26 <explicitjelly> so I'm interested in Arrow examples that aren't Monads
04:38:42 <explicitjelly> I suspected the event processing stuff might be one?
04:39:09 <quicksilver> I would also be interested to see good examples of arrows which don't derive trivially from monads.
04:39:13 <explicitjelly> mapreduce, oh, that's a conveyor belt. you mean it's essential?
04:39:35 <quicksilver> explicitjelly: I've not seen this JS library before.
04:39:37 <mapreduce> I mean that arrows seem to resemble conveyor belts.
04:39:52 <explicitjelly> so the JS stuff there could just jave implemented Monads instead of Arrows?
04:39:53 <quicksilver> On a very brief scan of that page I'm not sure I see how to map the concept to what I understand as arrows.
04:40:01 <quicksilver> although it looks nice enough.
04:40:08 <mapreduce> explicitjelly: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
04:40:38 <explicitjelly> mapreduce, aah. now I'm beginning to understand. sorry, I didn't know the word "conveyor belt" and I've not really wrapped my head around arrows yet :)
04:40:47 <mapreduce> Heh.
04:41:04 <mapreduce> Me neither.
04:41:22 <quicksilver> I find that wikibook page singularly unhelpful.
04:41:31 <quicksilver> It introduces arrows as if all they are is functions.
04:41:44 <quicksilver> and gives a bunch of pictures which show how you can apply functions to tuples (no shit!)
04:41:57 <quicksilver> it totally fails to give intuition on what it is about arrows that are more than functions.
04:41:59 <cjs> dcoutts: So, should I answer ross@...'s question?
04:42:19 <mapreduce> quicksilver: What would you recommend, other than John Hughes' paper?
04:42:27 <sclv> quicksilver is so on the money about that.
04:42:48 <dcoutts> cjs: sorry, I must have missed something, what is Ross's question?
04:43:05 <cjs> "Why complicate Cabal and break compatibility with non-GHC implementations when the portable solution (a little Main module) is so easy?"
04:43:18 <cjs> I'm open to other ideas on this, BTW, I went back and forth a bit.
04:43:41 <dcoutts> cjs: oh I see
04:43:44 <cjs> But basically, I have several a large pile of code, and I build several command line programs out of it, a lot of which share common code.
04:43:57 <cjs> s/several a //
04:44:02 <dcoutts> cjs: if you can make a good argument for supporting that ghc feature then go for it
04:44:02 <quicksilver> mapreduce: the swierstra + duponcheel parser is the only interesting arrow I'm aware of.
04:44:13 <quicksilver> mapreduce: (it's described at the end of that wikibook page, to be fair)
04:44:22 <sclv> cjs: in the same boat here.
04:44:22 <dcoutts> cjs: we'd need a syntax to specify it
04:45:02 <cjs> Ok, well let me bounce this off you first here, and see if it makes sense, or if I'm missing some better solution.
04:45:04 <quicksilver> note that the 'DynamicParser' is just the kleisli arrow of a state monad.
04:45:11 <mapreduce> quicksilver: I find parser examples hard to follow.
04:45:14 <cjs> (If that's ok with you.)
04:45:24 <_ar> quicksilver: i think the whole point is that you can combine functions in a way that resembles concurrency
04:45:25 <quicksilver> and the StaticParser is a totally trivial thing with no composition at all.
04:45:27 <cjs> Or should we do this in #cabal?
04:45:29 <mapreduce> I can fix that, but I'd rather tackle that deficiency later.
04:45:36 <quicksilver> the only clever part is the way they are combined.
04:45:37 <sclv> (vis a vis the multiple executables one codebase issue, not vis a vis main-is, per se...)
04:45:39 <quicksilver> (and that is clever)
04:46:01 <izzy1> is there a library i could use for sorting a table structure? im planning to order rows with multiple columns ala excel.
04:46:07 <dcoutts> cjs: #haskell-overflow
04:46:20 <dcoutts> sclv: ^^
04:46:27 <mapreduce> Duponcheel started posting Scala and Java functional code samples on a blog less than a year ago.
04:46:39 <_ar> it's maybe more about an appeal to physical intuition about physical problems and less about formal differences
04:46:58 <mapreduce> I'd never heard of him, but I had guessed that there was a little more to him than his description "Java trainer, Sun Microsystems".
04:47:02 <_ar> sorry i meant physical processes
04:47:08 <quicksilver> _ar: formall differences between what? arrows and monads? or arrows and functions??
04:47:17 <_ar> arrows and functions
04:47:31 <quicksilver> the formal differences are pretty important.
04:47:35 <mapreduce> I think stream processing would be a good example of arrows.
04:47:40 <quicksilver> arrows can have effects, functions don't.
04:47:57 <quicksilver> The best definition of arrow I know of is 'a function with computational effects'
04:48:26 <quicksilver> I think the wikibook doesn't make that at all clear.
04:48:37 <quicksilver> "Monads allow you to combine these machines in a pipeline. Arrows allow you to combine them in more interesting ways"
04:48:45 <quicksilver> ^^ I think that is at best confusing and misleading.
04:48:52 <quicksilver> at worst it is simply utterly wrong.
04:50:01 <mapreduce> How would you write it?
04:50:17 <_ar> quicksilver: it certainly doesn't ("make that clear"), but how can arrows have side-effects (what you meant by 'computational effects'?) if implemented in haskell? that's just a point-of-view thing
04:50:58 <quicksilver> computational effects in the same sense as monads.
04:51:06 <quicksilver> effects other than calculating a result from an input.
04:51:14 <_ar> i see
04:51:29 <quicksilver> Arr a b is more than (a -> b) in general because, as well as calculating a value of type 'b' from a value of type 'a', something else "happens"
04:51:38 <quicksilver> where the sense of "happens" varies from arrow to arrow.
04:51:59 <ziman> could you give an example?
04:52:08 <DrSyzygy> quicksilver: A more non-trivial example than (a -> b)? '
04:56:51 <quicksilver> ziman: a -> IO b
04:57:15 <quicksilver> ziman: (a,s) -> (b,s)
04:57:20 <_ar> i guess all i was really getting at was how are arrows that much different than functions together with a tensor product
04:57:37 <quicksilver> DrSyzygy: yes, (a -> b) is the trivial arrow like Id is the trivial monad.
04:57:44 <quicksilver> _ar: that's what I was getting at too :)
04:57:56 <Wild_Cat> quick question regarding RWH and Haskell's handling of unicode: it says that Haskell uses unicode internally, but that I/O functions don't do any kind of conversion. Something sounds off to me.
04:57:57 <quicksilver> _ar: if that was indeed all arrows are, then they'd just be a library for manipulating functions and tuples.
04:58:22 <quicksilver> Wild_Cat: haskell's Char type is fully unicode supporting but the only "encoding" used by the IO calls is "truncate to 8-bit"
04:58:34 <quicksilver> Wild_Cat: most people don't consider that a real encoding, but there you go :)
04:58:43 <Wild_Cat> quicksilver: truncate to 8-bit as in convert to ASCII, or is there more to it?
04:58:50 <Wild_Cat> what's the internal representation used by ghc? UTF-8?
04:58:55 <quicksilver> _ar: doubtless that would be useful, but arrows are supposed to be more than that.
04:59:10 <quicksilver> Wild_Cat: truncate to 8-bit as in, emit the 8-bit number which is the lowest 8 bits of the unicode code point.
04:59:22 <quicksilver> Wild_Cat: you are forbidden from asking what the internal representation is. It is abstract.
04:59:25 <quicksilver> ;)
04:59:27 <Wild_Cat> quicksilver: oh Ghost. That's dreadful.
04:59:37 <_ar> quicksilver: well then i guess i really don't get them
04:59:54 <quicksilver> I think it's platform dependent. Under glibc operating systems, the underlying rep used by ghc is wchar_t
05:00:02 <Wild_Cat> quicksilver: well, if the internal representation is abstract and the IO functions use its low 8 bits without any kind of real encoding, then I submit it's not really abstract anymore.
05:00:04 <quicksilver> I would imagine under win32 it's something sensible for win32.
05:00:16 <quicksilver> Wild_Cat: they don't use the low 8 bits of the internal rep.
05:00:23 <quicksilver> Wild_Cat: they use the low 8 bits of the unicode code point.
05:00:28 <quicksilver> (which may or may not be the internal rep)
05:01:02 <Wild_Cat> That really is dire. I heard it was getting more or less fixed in ghc 6.10, though, isn't it?
05:01:59 <quicksilver> Wild_Cat: Yes. In ghc 6.10 they have chosen the also-broken but perhaps more useful 'always assume UTF8'
05:02:04 <quicksilver> at least, I think that was the decision.
05:02:22 <quicksilver> Wild_Cat: in any case, it's not a big problem under 6.6 or 6.8
05:02:25 <Wild_Cat> well, it's slightly less broken.
05:02:36 <quicksilver> you just import a library which gives you explicit access to encoding.
05:02:39 <quicksilver> and choose the one you want.
05:02:44 <Wild_Cat> figures.
05:05:00 <quicksilver> _ar: my contention is that most people don't get them :)
05:05:09 <quicksilver> and I don't think that wikibook goes far to help.
05:05:25 <quicksilver> As I say, I'm only aware of two classes of non-trivial arrows: Kleisli arrows, and the S&D parser.
05:05:40 <quicksilver> Kleisli arrows are really just a particular choice of monad combinator.
05:05:50 <quicksilver> and the S&D parser is very closely related to a kleisli arrow.
05:06:04 <_ar> quicksilver: at least in my case it's not the fault of the wikibook... but the wikibook does happily satisfy my confirmation bias
05:07:51 <sclv> quicksilver: what about yampa?
05:08:13 <quicksilver> sclv: I should read up about it properly.
05:08:24 <quicksilver> sclv: I got as far as learning that conal's TVs are not arrows.
05:08:31 <quicksilver> I've not read the yampa paper.
05:08:36 * quicksilver stuffs on in to-read list.
05:09:15 <sclv> my impression is that yampa and hxt both uses arrows "right" -- but that, especially in the latter case, the marginal benefits are questionable.
05:09:20 <sclv> s/uses/use/
05:11:30 <quicksilver> sclv: HXT arrows are all kleisli arrows.
05:11:35 <quicksilver> Nothing wrong with that.
05:11:54 <quicksilver> but they don't provide my sought-after non-kleisli example :)
05:12:05 <quicksilver> HXT arrows are typically a -> IO [b]
05:12:05 <sclv> then what's their benefit?
05:12:15 <quicksilver> just interesting ways of combination.
05:12:27 <quicksilver> they form an interesting point in the combinator library design space.
05:12:52 <explicitjelly> hmm.
05:13:05 <explicitjelly> I think I get arrows now.
05:13:17 <sclv> hmm... i think you're right. i was wrestling with hxt a while ago and forgot the details.
05:13:54 <quicksilver> HaXML uses arrows too, it just doesn't call them that.
05:14:01 <quicksilver> it uses lots of types of the form a -
05:14:05 <quicksilver> a -> [b]
05:14:07 <quicksilver> (sorry)
05:15:09 <mauke> > let f :: a Int -> a Int; f = id in (f Nothing, f [42])
05:15:12 <lambdabot>  mueval: Time limit exceeded
05:15:49 * quicksilver slaps lambdabot 
05:16:46 <explicitjelly> huh? why does that timeout?
05:18:02 <mm_freak> @src Monad
05:18:02 <lambdabot> class  Monad m  where
05:18:02 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:18:02 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:18:02 <lambdabot>     return      :: a -> m a
05:18:02 <lambdabot>     fail        :: String -> m a
05:18:23 <mm_freak> is this 'forall' necessary?
05:19:42 <quicksilver> mm_freak: yes; types which are not bound are always foralled
05:19:53 <quicksilver> mm_freak: however explicit use of the keyword is a GHC extension
05:19:59 <quicksilver> standard haskell would have that forall implicit.
05:20:27 <mm_freak> i mean, if i'd write a monad class, would i need to mention forall explicitly in this case?
05:20:34 <mm_freak> or is it redundant?
05:20:39 <quicksilver> it's redundant.
05:20:57 <quicksilver> mm_freak: that @src is hand-written and it's not even consistent with itself.
05:21:06 <quicksilver> mm_freak: (why is there no forall a. on return and fail?)
05:21:12 <quicksilver> it's an inconsistency that's all :)
05:21:21 <mm_freak> ok, thank you =)
05:21:25 <quicksilver> explicitjelly: that arrowlet stuff looks quite interesting.
05:21:42 <quicksilver> explicitjelly: of course any function in JS has side-effects
05:21:57 <quicksilver> explicitjelly: so, arguably, any function in JS is a -> IO b
05:26:10 <quicksilver> explicitjelly: I'd added the paper to my read list :)
05:27:48 <DrSyzygy> quicksilver: Does the Hom-Tensor product adjunction (as popping up in currying) have an Arrow correspondence?
05:28:26 <sw17ch> are there any tools for working with polynomials (solvers, etc) for haskell?
05:28:43 <quicksilver> DrSyzygy: I think so, yes.
05:29:06 <quicksilver> DrSyzygy: I mean, I think if you're a "proper" arrow and you give working definitions for &&&, ***, first, second and all that stuff.
05:29:18 <quicksilver> DrSyzygy: then I think your definitions exhibit the adjunction.
05:30:05 <DrSyzygy> So, what's a ; such that (arr a (arr b c)) ~ (arr (a;b) c) ?
05:30:12 <DrSyzygy> @src Arrow
05:30:12 <lambdabot> class Arrow a where
05:30:12 <lambdabot>     arr, pure   :: (b -> c) -> a b c
05:30:12 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
05:30:12 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
05:30:12 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
05:30:14 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
05:30:16 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
05:30:37 <DrSyzygy> Hrm.
05:30:58 <DrSyzygy> a x (a y z) ~ a (x;y) z < is what I should have meant.
05:32:54 <quicksilver> DrSyzygy: (,), I think.
05:33:15 <quicksilver> DrSyzygy: I don't think the setup allows for the tensor to be something novel.
05:33:22 <DrSyzygy> Awwww
05:33:24 <quicksilver> I think it assumes that the tensor will always be (,)
05:33:40 <quicksilver> look at the types of first,second,(***),(&&&)
05:33:41 <DrSyzygy> So are all instances of Arrow -really- right (left) adjoints to (x)??
05:33:48 <DrSyzygy> Yeah, I guess.
05:34:19 <quicksilver> it's related to whether you can push monadic effects down a composition, I think
05:34:30 <quicksilver> can you convert a -> IO (b -> IO c)
05:34:32 <quicksilver> into
05:34:35 <quicksilver> a -> b -> IO c
05:34:56 <quicksilver> if you can push the effects all the way down, then you can reuse the same adjoint.
05:34:59 <quicksilver> I'm not sure :)
05:35:04 <quicksilver> I bet edwardk has something more general.
05:35:17 <DrSyzygy> Good point. Where is he? We need a categorist!
05:37:05 <mauke> :t \f a b = f a >>= \f' -> f' b
05:37:07 <lambdabot> parse error on input `='
05:37:12 <mauke> :t \f a b -> f a >>= \f' -> f' b
05:37:14 <lambdabot> forall t t1 (m :: * -> *) b. (Monad m) => (t -> m (t1 -> m b)) -> t -> t1 -> m b
05:37:26 <gwern> @seen Cale
05:37:27 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and #japanese. I last heard Cale speak 2h 43m 30s ago.
05:37:55 <Saizan> to go from a x (a y z) to a (x,y) z you need app which makes your arrow equivalent to a monad
05:37:56 <mauke> @pl \f a b -> f a >>= \f' -> f' b
05:37:57 <lambdabot> flip flip (flip id) . (((.) . (>>=)) .)
05:38:08 <BeelsebobWork> haha
05:38:12 <BeelsebobWork> that's why filp should do
05:40:26 <Baughn> For encryption modes (such as ecb, cbc, ofb, etc..), have any of you heard of an "xor mode" that basically encrypts the /key/ (plus a counter, plus a nonce) N times for N blocks, then uses the new keys to encrypt the blocks?
05:41:06 <Baughn> It's in my book here, but I get the impression the author outright invented it. It's equivalent to CTR, of course
05:41:27 <Baughn> ..
05:41:36 <Baughn> Hm. It really /is/ equivalent to CTR. Never mind.
05:41:58 <quicksilver> rule (1) of crypto ideas
05:42:13 <quicksilver> 99.99% of all new ideas are equivalent to, but weaker than, something already published :)
05:42:33 <Baughn> In this case it's just plain equivalent. I was confused by the nomenclature. :P
05:43:54 <solrize> hmm, unless the nonce is supposed to be uniform-random then that is not necessarily equivalent to CTR
05:44:16 <Baughn> It is
05:44:32 <Baughn> (THere are nonces that aren't? Isn't that missing the point?)
05:45:56 <solrize> not sure.  uniqueness may be enough under some definitions.
05:46:26 <Baughn> I suppose. It's the nonce-plus-counter that's supposed to be unique, though, not just the nonce
05:46:53 <solrize> also, nonces are sometimes not secret
05:46:55 <solrize> is this one?
05:47:09 <Baughn> No
05:47:32 <solrize> errr
05:48:01 <solrize> N,E(K+N),E(K+N+1),...
05:49:15 <solrize> i am skeptical.  that leaks information about a relationship between the plaintext and the key.  the usual assumption of a block cipher is that the plaintext and key are uncorrelated
05:49:37 <solrize> for AES it is supposed to be ok to do stuff like that, but that's a special characteristic of AES
05:50:00 <Baughn> It's pretty typical, though.. um, as I said, it really is ctr-mode
05:50:29 <solrize> typical of what?  i've never seen anything like that
05:50:42 <Baughn> I'm pretty sure it's safe. Encrypt nonce+counter, use that "encryption key" to xor with the plaintext
05:51:12 <Baughn> http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29 <-- This thing, right?
05:51:14 <lambdabot> Title: Block cipher modes of operation - Wikipedia, the free encyclopedia, http://tinyurl.com/bbcmf
05:51:14 <solrize> you said "encrypts the /key/ ... "
05:51:32 <Baughn> Um. Hang on
05:51:54 <Baughn> Oh. No, it doesn't encrypt the key. I misspoke.
05:51:58 <gwern> @tell Cale hey, I've pushed my ~/ patches. you may find this functionality interesting? basically just reinstall and try running lambdabot somewhere besides lambdabot/
05:51:58 <lambdabot> Consider it noted.
05:52:21 <solrize> oh, you mean just N,E(N),E(N+1),.... ?    yes, that's CTR
06:01:14 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
06:01:16 <lambdabot> Terminated
06:01:22 <mmorrow> gah!
06:01:26 <mmorrow> > 1
06:01:29 <lambdabot>  mueval: Time limit exceeded
06:01:49 <Baughn> Mueval? Hmm
06:01:50 <Baughn> > 42
06:01:53 <lambdabot>  mueval: Time limit exceeded
06:01:54 <mmorrow> lambdabot is still maimed
06:02:45 <Saizan> maimed?
06:02:58 <mmorrow> crippled/broken/borked
06:03:09 <mmorrow> in-need-of-restart
06:03:17 <Saizan> > 1
06:03:19 <lambdabot>  mueval: Time limit exceeded
06:03:59 <Saizan> i don't see how a restart should help here, unless it's making the machine too slow
06:04:21 <sjanssen> > ()
06:04:24 <lambdabot>  ()
06:04:32 <mmorrow> ooh
06:04:34 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
06:04:37 <lambdabot> Terminated
06:04:40 <Saizan> gwern: maybe the default time-limit is too short? ^^^^
06:04:41 <mmorrow> > fix show
06:04:44 <lambdabot>  mueval: Time limit exceeded
06:04:53 <mmorrow> that may be it
06:05:15 <Saizan> mmorrow: that Terminated really means that something is not in scope
06:05:17 <mmorrow> but i don't know what's up with "Terminated"
06:05:21 <mmorrow> ahhhh
06:05:52 <Saizan> "Empty Output" would be a more accurate message
06:06:51 * mmorrow looks at mueval src to figure out if Data.Generics is accessible
06:08:18 <mmorrow> aww, Data.Generics isn't available by default in mueval :(
06:08:45 <mmorrow> i have the old default lambdabot imports somewhere
06:09:05 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/imports.h.txt
06:09:15 <Saizan> there's still imports.h in the lb repo iirc
06:09:44 <mmorrow> hmm, but is that used now that mueval is being used?
06:09:57 <mmorrow> (also, it looks like Data.Generics is qualified)
06:10:15 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in Data.Generics.everywhere (Data.Generics.mkT (+1)) x
06:10:18 <lambdabot>      Not in scope: `Data.Generics.everywhere'
06:10:54 <Saizan> it's not used, probably because mueval can't do qualified imports
06:11:06 <mmorrow> :(
06:11:15 <mmorrow> is that on account of hint?
06:12:35 <gwern> ghc api
06:12:35 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
06:12:50 <gwern> it's only hint's fault inasmuch as there's a possible workaround which the author hasn't implemented
06:12:52 <gwern> @messages
06:12:52 <lambdabot> rwbarton said 8h 39m 16s ago: "> 0 :: Word32" gives "mueval: Time limit exceeded", same for the other fixed size Word/Int types besides Int8
06:12:59 <mmorrow> gwern: dang
06:13:08 <Saizan> mmorrow: to do qualified imports you've to splice the expression inside a module, compile and link it like runplugs did
06:13:35 <gwern> basically
06:13:54 <mmorrow> Saizan: cool. that's on my todo list now.
06:14:29 <Saizan> can you do that with the ghc-api?
06:15:09 <mmorrow> if you can build and link modules with the ghc-api, then you could construct a module with the haskell-src-exts AST
06:15:41 <Baughn> @check 2::Int == 2
06:15:42 <lambdabot>  Parse error at "==" (column 8)
06:15:47 <gwern> no, qualified imports are not in the ghc api :(
06:15:49 <gwern> very sad
06:15:58 <Baughn> @check \x -> x == (x::Int)
06:15:59 <Saizan> gwern: i mean compile and load a module
06:16:00 <lambdabot>  "OK, passed 500 tests."
06:16:14 <Baughn> ..oh, good. It's "ok".
06:16:23 <gwern> oh. yeah, you can load from file without too much trouble
06:16:26 <mmorrow> yeah, if you can compile and load a module it should definitely be possible
06:16:56 <Saizan> mmorrow: make sure to check the user-submitted expression parses like one, to avoid code injections
06:17:33 <gwern> of course, one issue seems to be that you can't export qualified stuff
06:18:13 <mmorrow> Saizan: definitely, i'd parse the input String as an expression, then splice it into a haskell-src-exts HsModule, prettyPrint that, then hand it off to the ghc-api
06:18:25 <gwern> so if you were thinking that you could just do 'echo import Data.map as Map; loadFile; eval "Map.map (+1) $ Map.fromList [(1,2)]', it's not that easy
06:19:15 <Saizan> gwern: echo "import Data.Map as Map; foo = Map.map (+1) $ Map.fromList [(1,2)];"; loadFile; eval foo
06:19:54 <Saizan> which is what mmorrow said
06:19:59 * gwern thinks that would get around the issue, but it's another annoyance
06:20:07 <quicksilver> but at that point you have to worry about code injection
06:20:24 <quicksilver> which is the problem the LB author(s) spent some time solving.
06:20:25 <Saizan> quicksilver: yeah, we'd parse the expression first
06:25:04 <Saizan> gwern: have you read my message about the time-limit being too short? we get time-limit exceptions even for very simple expressions
06:25:26 <gwern> not really
06:25:47 <Saizan> 15:04     Saizan : > 1
06:25:48 <Saizan> 15:04  lambdabot :  mueval: Time limit exceeded
06:28:06 <quicksilver> it's presumably wall-clock time
06:28:16 <quicksilver> and includes the effort of paging stuff in on the poor collapsed machine.
06:28:26 <Saizan> it's done with threadDelay
06:28:29 <quicksilver> would it be nice to limit CPU time instead of wall-clock time?
06:28:43 * quicksilver nods
06:28:50 <quicksilver> CPu time could be done with rlimit
06:28:53 <quicksilver> I believe.
06:29:07 <gwern> quicksilver: sure. but then we'd cut out half the people who simply can't run rlimit-enabled mueval
06:29:16 <gwern> (for whatever reason)
06:29:34 <Saizan> we need an unix hacker that fixes unix :)
06:30:03 <mmorrow> heh
06:30:17 <haskellian> how do i create a Data.Map after having imported it as qualified Dmap?
06:30:32 <mmorrow> i'll do a short ghci session that shows which Resources and broken on my system
06:30:37 <gwern> what we need is some people to report rlimit bugs
06:30:39 <mmorrow> s/and/are/ Broken
06:30:40 * gwern won't/can't report bugs I can't reproduce!
06:30:48 <Saizan> haskellian: Dmap.empty, Dmap.insert, etc..
06:31:08 <quicksilver> gwern: well you can make both options available
06:31:19 <EvilTerran> > fix unix
06:31:20 <gwern> both are
06:31:22 <lambdabot>  mueval: Time limit exceeded
06:31:24 <quicksilver> gwern: then the lambdabot deployment could have a wall-clock time limit of (say) 30 seconds
06:31:30 <quicksilver> gwern: but a CPU time limit of 3 seconds.
06:31:35 <gwern>   -r             --rlimits                Enable resource limits (using POSIX rlimits). Mueval does not by default since rlimits are broken on many systems.
06:31:41 <gwern>   -t TIME        --timelimit=TIME         Time limit for compilation and evaluation
06:32:31 <Saizan> yeah, just agreeing on some value for TIME to use in lambdabot would solve this
06:32:33 * gwern notes that getopt is very useful. not well-documented or easy to use, but very useful
06:33:20 <gwern> I might a -t flag later today
06:33:23 <gwern> not right now tho
06:33:41 <zeroflag> greetings, FPers.
06:34:32 <BONUS> hi :]
06:34:46 <quicksilver> gwern: CosmicRay's getopt? I never had any trouble with the documentation.
06:35:03 <gwern> no, the one in the base lib
06:35:07 <quicksilver> ah.
06:35:28 <gwern> I only got it working through a night session, #haskell, and dons' blog posting. the haddocks are, imo, atrocious
06:35:39 <gwern> and the function which ties it all together is defined in the comments!
06:36:14 <Saizan> you could summarize all that knowledge in the haddocks then :)
06:36:17 <quicksilver> Oh. That is the one I was thinking of.
06:36:21 <quicksilver> why did I blame CosmicRay for it?
06:36:32 <CosmicRay> quicksilver: I was wondering that too.
06:36:32 <quicksilver> I think I must have conflated it in my head with his ConfigFile parser.
06:36:35 <mauke> "blame cosmic rays"
06:36:43 <quicksilver> true. It's easy to blame CosmicRays.
06:36:43 <gwern> dunno
06:36:55 <CosmicRay> quicksilver: MissingH does have a few wrapper functions around getopt to make it less of a total annoyance
06:37:20 <quicksilver> CosmicRay: did you make a blog post about it once?
06:37:24 <mauke> at first I was confused by GetOpt. then I tried to design my own SUPERIOR Haskell-style option parser.
06:37:27 <EvilTerran> BOFH Excuse #51: Cosmic ray particles crashed through the hard disk platter
06:37:27 <CosmicRay> quicksilver: doubtful
06:37:31 <mauke> I ended up with basically the same interface :-)
06:37:34 <CosmicRay> EvilTerran: heh
06:37:52 <quicksilver> CosmicRay: then I have no excuse.
06:38:04 <quicksilver> mauke: Yes. I went through a similar process in my head.
06:39:20 <mmorrow> gwern, anyone: am i somehow /actually/ giving it an invalid argument, or is this just broken? http://hpaste.org/9933
06:40:08 <quicksilver> mmorrow: maybe non-super-users are not permitted to unlimit on your system.
06:40:17 <mmorrow> ok, i'll try as root
06:40:31 <sbahra> You cannot raise rlimits as non-root most likely.
06:40:32 <CosmicRay> http://software.complete.org/static/missingh/doc//MissingH/System-Console-GetOpt-Utils.html
06:40:36 <lambdabot> Title: System.Console.GetOpt.Utils, http://tinyurl.com/6q6btw
06:40:38 <CosmicRay> I use that in hpodder and stuff
06:40:42 <sbahra> But that shouldn't be an EINVAL, it should be an EPERM :-P
06:40:46 <mauke> mmorrow: works here
06:40:55 <mmorrow> mauke: exactly
06:41:04 <CosmicRay> it mainly offers some simplification for common cases at the expense of a touch of flexibility
06:41:15 <quicksilver> sbahra: There isn't a haskell wrapper for EPERM, I don't think.
06:41:22 <mauke> *** Exception: setResourceLimit: permission denied (Operation not permitted)
06:41:31 <quicksilver> oh, maybe I'm wrong.
06:41:33 <quicksilver> ;)
06:41:35 <sbahra> ;p
06:42:32 <mmorrow> doesn't work as root either http://hpaste.org/9933#a1
06:42:49 <mmorrow> what could be busted on my system?
06:43:20 <mauke> does it work in C?
06:43:46 <Baughn> mmorrow: There used to be a (horrible, horrible) workaround that at one point made it not work on 64-bit systems, and at another point not on 32-bit ones
06:44:01 <Baughn> I don't know if that is still active. Oh, but post the output of ulimit -a, too
06:44:08 <mmorrow> mauke: if you have some C code, i'll happily try
06:44:16 <mauke> ok, sec
06:44:29 <mmorrow> Baughn: eeek
06:44:44 <mmorrow> Baughn: ok, a sec
06:44:53 <sbahra> mmorrow, it working in C is it working with limits(1)/ulimit(1)
06:45:06 <BeelsebobWork> quicksilver: we found a use for applicative on Events
06:45:18 <BeelsebobWork> it helps find bugs in Monads for events >.<
06:45:40 <mmorrow> Baughn: http://hpaste.org/9933#a2
06:46:02 <mmorrow> sbahra: checking now
06:46:05 <quicksilver> BeelsebobWork: ;)
06:46:39 <FunctorSalad> one for the logicians: I remember reading that a category needn't have a notion of equality of objects. but aren't two objects equal IFF their identity morphisms are equal?
06:46:54 <mauke> mmorrow: C code: http://rafb.net/p/FiR3pO45.html
06:46:56 <lambdabot> Title: Nopaste - No description
06:47:06 <sw17ch> > 894 / 899
06:47:09 <lambdabot>  mueval: Time limit exceeded
06:47:18 <mauke> preflex: calc 894/899
06:47:18 <preflex>  0.9944382647385984
06:47:29 <Baughn> mmorrow: And strace of LB/mueval? Grepping for setrlimit is fine
06:47:29 <EvilTerran> FunctorSalad, if you don't have equality of objects, can you even still have equality of morphisms?
06:47:31 <quicksilver> FunctorSalad: I think that what you read was about an "internal notion" of equality.
06:47:56 <mmorrow> sbahra: yeah, ulimit works fine
06:47:58 <mmorrow> [root@ganon Mueval]# ulimit -f
06:47:58 <mmorrow> unlimited
06:47:58 <mmorrow> [root@ganon Mueval]# ulimit -f 10
06:47:58 <mmorrow> [root@ganon Mueval]# ulimit -f
06:47:58 <mmorrow> 10
06:48:00 <mmorrow> [root@ganon Mueval]# ulimit -f unlimited
06:48:02 <mmorrow> [root@ganon Mueval]# ulimit -f
06:48:03 <quicksilver> FunctorSalad: categories don't necessarily have a way to represent equality on their own objects, inside themselves.
06:48:04 <mmorrow> unlimited
06:48:06 <FunctorSalad> EvilTerran: yes, why not? you definitely need equality of morphisms to express things like the basic laws
06:48:08 <mmorrow> oops, that was long
06:48:11 <EvilTerran> i guess
06:48:17 * EvilTerran is not that familiar with CT, really
06:48:26 <quicksilver> FunctorSalad: however I don't see how you can expect to define a category without 'external' identity of objects.
06:48:37 <FunctorSalad> quicksilver: well, the "outside" set-theoretic equality is cheating, I disregard that
06:48:37 <EvilTerran> mmorrow, i like your computer name :)
06:48:40 <mmorrow> mauke: trying now
06:48:53 <mmorrow> EvilTerran: heh, best video game evar
06:48:56 <FunctorSalad> quicksilver: I'm wondering whether it should be equipped with object equality, on the external level
06:48:56 <sbahra> No difference.
06:48:57 <EvilTerran> yyyyup
06:49:00 <quicksilver> FunctorSalad: but the "outside" equality is all you need to check laws.
06:49:13 <sbahra> mmorrow, check what values you are passing to setrlimit
06:49:13 <quicksilver> "outside" equality of morphisms and objects.
06:49:19 <sbahra> mmorrow, as Baughn suggested
06:49:35 <mmorrow> ah, i missed that. i'll check
06:49:36 <FunctorSalad> quicksilver: sure, but you don't need external equality of objects
06:50:22 <mauke> if you strace my C program, the last two lines should be
06:50:23 <mauke> setrlimit(RLIMIT_CORE, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
06:50:23 <mauke> exit_group(0)                           = ?
06:50:33 <FunctorSalad> quicksilver: you may be right that what I was thinking of is internal equality. the context was fibred categories, maybe Benabou
06:50:34 <mauke> I wonder what the Haskell version does
06:50:44 <quicksilver> FunctorSalad: without external equality of objects how will you even check which things *are* identity morphisms/
06:50:57 <quicksilver> FunctorSalad: you need to be able to check if their domains and codomains coincide.
06:51:06 <quicksilver> FunctorSalad: to me it doesn't seem like an interesting avenue :)
06:51:08 <FunctorSalad> quicksilver: you take composeability as a primitive instead
06:51:17 <FunctorSalad> quicksilver: then you don't need objects at all
06:51:20 <quicksilver> sure.
06:51:25 <haskellian> why doesn't the compiler complaing here http://hpaste.org/9934 ?
06:51:25 <quicksilver> You can do that if you like.
06:51:30 <quicksilver> I don't find that presentation to be simpler
06:51:36 <quicksilver> and it's obviously equivalent.
06:51:45 <quicksilver> I can recover the objects if I want them.
06:51:45 <haskellian> it compiles but then naurally goes into an infinite loop
06:51:48 <FunctorSalad> quicksilver: I think it saves some boilerplate when doing things in haskell
06:51:54 <quicksilver> (as equivalence classes of self-composable morphisms)
06:51:59 <FunctorSalad> quicksilver: you don't have to specify the objects for your categories
06:52:19 <quicksilver> haskellian: why should the compiler complain?
06:52:21 <mauke> haskellian: why should the compiler complain?
06:52:26 <sbahra> wowow
06:52:34 <quicksilver> haskellian: you've made a recursive definition.
06:52:37 <haskellian> I thought using let on the same variable int he same main was criminal
06:52:38 <quicksilver> (probably not deliberately)
06:52:49 <mauke> haskellian: it's not the same variable
06:52:54 <FunctorSalad> quicksilver: hmm, why do you think it's not interesting? in type theory you don't get an equality for free at all, so I need to wonder about how I do this...
06:53:02 <mauke> > let i = 1 in let i = 2 in let i = "hello" in i
06:53:04 <lambdabot>  "hello"
06:53:21 <quicksilver> FunctorSalad: type theory is syntactic, categories are semantic.
06:53:33 <quicksilver> FunctorSalad: it's usual that in syntactic domains, equality is something you 'have to prove'
06:53:36 <quicksilver> you don't get it for free.
06:53:41 <FunctorSalad> quicksilver: one attractive thing about the morphism-only approach is that the Category class needs only one parameter
06:53:45 <rog> quick question: is there any way i can declare an instance of a class that works for any type that is a member of another class?
06:53:49 <quicksilver> Similarly it's usual in semantic domains that equality of 'obviouus'
06:53:52 <mauke> rog: not really
06:53:53 <quicksilver> you assume it.
06:53:55 <FunctorSalad> quicksilver: I said you don't get it for free.
06:54:07 <quicksilver> FunctorSalad: I know you did. I'm agreeing with you.
06:54:09 <FunctorSalad> quicksilver: you get equality for free in ZFC, that's what I was saying
06:54:10 <rog> mauke: ok. thanks, i'd suspected as much.
06:54:17 <Baughn> rog: Not cleanly, but it's possible. Kinda
06:54:18 <EvilTerran> rog, it takes an extension, and the behaviour isn't ideal, but you can
06:54:19 <quicksilver> FunctorSalad: I'm drawing a constrast between syntactic and semantic systems.
06:54:40 <EvilTerran> two extensions, actually
06:54:49 <EvilTerran> UndecidableInstances and OverlappingInstances
06:54:58 <quicksilver> FunctorSalad: in syntactic systems we expect that equality is something we have to work for, whilst in semantic domains we expect that equality is something natural provided by the model, be it Set or Cat.
06:55:09 <rog> EvilTerran: are they in hugs?
06:55:12 <FunctorSalad> quicksilver: yeah, I'm still a bit in the dark about what I do statically and what dynamically
06:55:23 <quicksilver> FunctorSalad: of course the semantic equality is not necessarily syntactically provable.
06:55:36 <quicksilver> FunctorSalad: and it may not be syntactically observable, either.
06:55:39 <EvilTerran> rog, er, not sure. i use ghci (as do most folk, i believe)
06:55:46 <FunctorSalad> quicksilver: right
06:55:51 <rog> Baughn: are you referring to the same way of doing this as EvilTerran?
06:56:11 <EvilTerran> rog, alternatively, to stay in h98, you can do something like the "instance Monad m => Functor (WrappedMonad m) where fmap = liftM" in Control.Monad
06:56:14 <Baughn> rog: Yes, but he's better at it. He actually /understands/ it.
06:56:15 <rog> EvilTerran: maybe i should start using that then.
06:56:26 <quicksilver> rog: it's likely that you don't actually want to use that.
06:56:27 <FunctorSalad> quicksilver: though things can be made more typesafe to some degree, for example by having a "Triangle" type for two morphisms that are guaranteed to be composeable
06:56:37 <EvilTerran> where they've got "newtype WrappedMonad m a = WrappedMonad (m a)"
06:56:42 <quicksilver> FunctorSalad: Yes. I didn't mean there weren't practical advantages.
06:56:44 <FunctorSalad> quicksilver: with an "unsafeMakeTriangle" function if you can't get a Triangle instance
06:56:53 <quicksilver> FunctorSalad: I only meant, there weren't foundational advantages.
06:57:01 <EvilTerran> the presence of the constructor means that the instance isn't undecidable, and won't overlap everything
06:57:11 <mmorrow> Baughn: http://hpaste.org/9933#a3   an unrelated weird thing is that the output of strace is on neither stdout nor stderr, so grep didn't work (does it write directly to the terminal?)
06:57:14 <quicksilver> FunctorSalad: i.e., I don't really see it as an interestingly different mathematical way of looking at things. Just a matter of taste, a convenient choice.
06:57:26 <EvilTerran> while an "instance Monad m => Functor m where fmap = liftM" would overlap everything, and fails the decidability check
06:57:28 <mauke> mmorrow: it writes to stderr by default
06:57:34 <mmorrow> mauke: ok, trying that C now
06:57:53 <mauke> ah, I see
06:58:00 <mauke> rlim_cur > rlim_max
06:58:08 <mmorrow> mauke: ewird, because i did                   $ strace ./mything | grep ... >&2 2> log.txt
06:58:12 <mmorrow> and log.txt was empty
06:58:19 <FunctorSalad> quicksilver: what's "it" here? the type system?
06:58:20 <mauke> well, duh
06:58:28 <mmorrow> oh, hah. probably because it didn't find anything
06:58:31 <mmorrow> hehe
06:58:38 <mauke> strace doesn't print to stdout, so grep had nothing to search
06:58:46 <mmorrow> haha, ok.
06:58:50 <FunctorSalad> quicksilver: I agree that for the mathematical part ZFC would be fine, I mostly need the type system to implement things in haskell
06:58:50 <quicksilver> FunctorSalad: the advantage of forgoing objects in favour of morphisms. Or other similar simplifications.
06:58:54 * mmorrow does it again
06:58:57 <mauke> strace ./foo 2>&1 | grep ...
06:59:03 <mmorrow> yeah
06:59:26 <FunctorSalad> quicksilver: oh. sure, mathematically it doesn't matter which of two equivalent structural axioms you take
06:59:43 <mmorrow> setrlimit(RLIMIT_FSIZE, {rlim_cur=RLIM_INFINITY, rlim_max=0}) = -1 EINVAL (Invalid argument)
06:59:48 <FunctorSalad> quicksilver: as I said, I think the haskellian advantage is that Category needs just one parameter
06:59:54 <FunctorSalad> (the arrow type)
06:59:58 <mmorrow> that corresponds to this
06:59:59 <mmorrow> setResourceLimit ResourceFileSize (ResourceLimits ResourceLimitInfinity ResourceLimitInfinity)
07:01:12 <rog> the thing is, i encountered this in a laughingly simple example - i've got a class that does min/max (such that it's possible that to allow piecewise vector min/max), and i'd like to define an instance of this for any instance of Ord, without defining it for every numerical type specifically.
07:01:54 <mmorrow> mauke: that C code does this
07:01:55 <mmorrow> setrlimit(RLIMIT_CORE, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
07:02:06 <mmorrow> haskell does this
07:02:07 <mmorrow> setrlimit(RLIMIT_FSIZE, {rlim_cur=RLIM_INFINITY, rlim_max=0}) = -1 EINVAL (Invalid argument)
07:02:10 <rog> EvilTerran: i don't see where you're going with the Functor (WrappedMonad m) thingy.
07:02:23 <mauke> mmorrow: yep
07:02:32 <quicksilver> FunctorSalad: Yes. I can see that as a significant practical advantage.
07:02:54 <mmorrow> mauke: what is your interpretation of this
07:03:01 * mmorrow doesn't know what this implies
07:03:05 <mauke> which makes me suspect my haskell code works only by accident
07:03:12 <rog> EvilTerran: NB. rog <- haskell newbie!
07:03:18 <EvilTerran> rog, do you see why "instance Monad m => Functor m where fmap = liftM" is correct in theory but wrong according to haskell 98?
07:03:22 <EvilTerran> er, ok
07:03:31 <EvilTerran> do you know what the functor and monad classes are?
07:03:44 <rog> EvilTerran: yes, i think so.
07:03:49 <EvilTerran> ?type fmap
07:03:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:03:51 <EvilTerran> ?type liftM
07:03:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:04:18 <EvilTerran> note the similarity - every monad is a functor, in that liftM for a monad fits the laws demanded of fmap for a functor
07:04:21 <FunctorSalad> quicksilver: care to comment on the gazzilionth refactoring of my Category class? ;) http://hpaste.org/9935
07:04:31 <rog> EvilTerran: were you just giving a representative example, or a general method?
07:04:41 <EvilTerran> rog, i was giving an example of a general method
07:04:57 <rog> EvilTerran: ok. that helps.
07:05:06 <EvilTerran> in that i was saying it'd be nice to be able to say "instance Monad m => Functor m where fmap = liftM"
07:05:10 <quicksilver> FunctorSalad: constraints on newtypes not considered helpful :)
07:05:13 <EvilTerran> but you can't, for two reasons
07:05:14 <mauke> wtf
07:05:16 <sbahra> mauke, why? RLIM_INFINITY = 0 most likely
07:05:24 <mauke> sbahra: impossible
07:05:39 <sbahra> mauke, http://kxr.bitcanvas.net/kxr/source/include/asm-generic/resource.h?v=linux-2.6#057
07:05:50 <lambdabot> Title: kernel/include/asm-generic/resource.h, http://tinyurl.com/699tl4
07:06:02 <EvilTerran> firstly that the class context (Monad m) is no smaller than the instance head (Functor m)
07:06:10 <mauke> sbahra: what
07:06:12 <quicksilver> sbahra: (~0) is not 0, surely?
07:06:23 <sbahra> No
07:06:36 <sbahra> woop
07:06:45 <FunctorSalad> quicksilver: hmm? I need that so I can recover the identity from an object
07:06:49 <EvilTerran> this means that, when trying to work out if something is a Functor instance, the type inferer can't tell that it has less work to do if it's looking for a Monad instance instead
07:06:57 <r3m0t> @src sequence
07:06:57 <lambdabot> sequence []     = return []
07:06:57 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:06:57 <lambdabot> --OR
07:06:57 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:07:01 <EvilTerran> there could be a loop in the instance declarations, for all it knowsa
07:07:17 <EvilTerran> so it complains that the instance is potentially undecidable
07:07:22 <quicksilver> FunctorSalad: constraints on newtypes (or data) in haskell don't do what you want them do.
07:07:24 <mauke> why is sizeOf CRLim == 8 when sizeof (rlim_t) == 4?
07:07:25 <EvilTerran> hence the need for the UndecidableInstances extension
07:07:26 <quicksilver> it's not normally worth it.
07:08:00 <EvilTerran> secondly, the instance head "Functor m" matches every possible m, so overlaps with any other instance for Functor
07:08:11 <EvilTerran> this isn't allowed unless you use the OverlappingInstances extension
07:08:25 <EvilTerran> which, when enabled, tells it to use the "most specific" instance it can find that matches
07:09:05 <EvilTerran> rog, do you follow?
07:09:17 <FunctorSalad> quicksilver: I ran into the problem that I can't really demand (Eq c1) since it may not be computeable, so for now it returns a formal equality for the user to stare at ;)
07:09:26 <rog> EvilTerran: one mo - i was just looking up WrappedMonad...
07:09:52 <FunctorSalad> quicksilver: maybe at some point I'll add some support for actually deriving formal equalities...
07:10:07 <mauke> mmorrow: the only thing I can think of is a miscompiled System.Posix, where it thinks rlim_t is 8 bytes wide or something
07:10:13 <EvilTerran> rog, WrappedMonad is how to work around both those problems for h98
07:10:29 <FunctorSalad> quicksilver: but I'm trying not to get into a fully rigorous mess :)
07:10:34 <mauke> mmorrow: but that doesn't really make sense either :/
07:10:40 <rog> EvilTerran: it doesn't seem to be in the standard prelude.
07:10:40 <mmorrow> mauke: cool. i'll see ...
07:10:42 <mmorrow> hmm
07:11:25 <mauke> mmorrow: and I have no idea how to check this
07:11:35 <EvilTerran> rog, no, it's in Control.Monad
07:11:40 <EvilTerran> (i think i mentioned this above)
07:11:43 <EvilTerran> ?index WrappedMonad
07:11:44 <lambdabot> bzzt
07:11:45 <EvilTerran> hm
07:11:51 <mauke> sizeOf CRLim looks wrong on my system but everything seems to work fine
07:11:55 <mmorrow> mauke: ok, i'll try rebuilding System.Posix, but before i do skim over it and see if there's something resembling rlim_t and 8 bytes
07:12:13 <EvilTerran> rog, actually, it seems to be in Control.Applicative, of all places
07:12:23 <EvilTerran> newtype WrappedMonad m a = WrapMonad { unwrapMonad :: m a }
07:12:45 <mauke> oh great, maxBound :: CRLim is 18446744073709551615
07:12:55 <mmorrow> mauke: oh, also i'm using 6.9. i'll do strace on the same haskell prog built with 6.8.3 ....
07:12:55 <EvilTerran> instance Monad m => Functor (WrappedMonad m) where
07:12:56 <EvilTerran>  fmap f = WrapMonad . liftM f . unwrapMonad
07:13:05 <mauke> THIS DOESN'T MAKE ANY SENSE
07:13:06 <quicksilver> mmorrow, mauke: I remember some other error relating to the size of C types and stat64 and stuff and GHC's libraries
07:13:09 <quicksilver> could this be related?
07:13:20 <mmorrow> hmm
07:13:28 <rog> EvilTerran: yeah, i'd found that. takes a while to get my head around these things tho'.
07:13:45 <EvilTerran> rog, anyway, the point is that the instance is no longer undecidable, because "m" is "smaller" than "WrappedMonad m"
07:14:06 <quicksilver> mmorrow: http://hackage.haskell.org/trac/ghc/ticket/2093
07:14:08 <lambdabot> Title: #2093 (getSymbolicLinkStatus (and possibly other functions) broken on systems wi ...
07:14:15 <EvilTerran> and an instance for "WrappedMonad m" doesn't overlap any types other than subtypes of "WrappedMonad m"
07:14:17 <quicksilver> mmorrow: that's the bug I was thinking of. Not sure if this could be related really.
07:14:17 <mmorrow> whoa! on 6.8.3 it does this:
07:14:22 <mmorrow> setrlimit(RLIMIT_FSIZE, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
07:14:22 <rog> EvilTerran: side note: i don't really understand the status of modules like Control.Applicative - are they 3rd party things, or standard haskell, or what?
07:15:06 <mmorrow> it looks like it's a 6.9 bug. i was just using 6.9.2008050 but I built HEAD yesterday, i'll see if it's fixed in that
07:15:07 <quicksilver> rog: they're not standard haskell, but then, not much is, technically.
07:15:09 <mmorrow> a sec
07:15:18 <quicksilver> rog: most of the stuff which comes with GHC is not, technically, standard haskell.
07:15:24 <EvilTerran> rog, most of the modules, even those based off the ones in the report, that come with ghc are not standard haskell
07:15:30 <EvilTerran> but they're de facto standard
07:15:56 <EvilTerran> they're part of the proposed http://www.haskell.org/haskellwiki/Haskell_Platform
07:15:58 <lambdabot> Title: Haskell Platform - HaskellWiki
07:16:17 <rog> EvilTerran: ok. so i can assume them for all practical purposes. do i get them in hugs (which i'm using 'cos it's small and easy to bootstrap)?
07:16:22 <mauke> ah hah!
07:16:26 <sbahra> ?
07:16:35 <mmorrow> mauke, quicksilver, sbahra: ok, current HEAD has fixed whatever the bug was.
07:16:37 <mauke> sizeof (rlim_t) depends on _FILE_OFFSET_BITS
07:16:38 <EvilTerran> rog, not sure. as i said, most people use ghci, myself included.
07:16:41 <mmorrow> on ghc 6.9.20080821 :
07:16:47 <mmorrow> setrlimit(RLIMIT_FSIZE, {rlim_cur=RLIM_INFINITY, rlim_max=RLIM_INFINITY}) = 0
07:17:20 <mauke> mmorrow: maybe it wasn't linked against setrlimit64 or whatever
07:17:25 <quicksilver> mauke: ah, so maybe it is related to the bug I pasted!
07:17:29 <quicksilver> mauke: did you see it?
07:17:34 <mauke> ah, no
07:17:43 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2093
07:17:44 <lambdabot> Title: #2093 (getSymbolicLinkStatus (and possibly other functions) broken on systems wi ...
07:18:12 <quicksilver> seems like a very similar issue at least.
07:18:19 <mauke> quicksilver: yes, that looks relevant
07:18:54 <rog> EvilTerran: is ghci the same as the package that comes up on my ubuntu box as "ghc6"?
07:19:19 <rog> EvilTerran: scratch that: it seems to be!
07:20:12 <rog> EvilTerran: and i seem to have it installed anyway, on both my boxes. good.
07:21:03 <mmorrow> @tell gwern the rlimit problem was on account of a bug in 6.9 that is fixed in at least 6.9.20080821
07:21:04 <lambdabot> Consider it noted.
07:23:16 <mmorrow> mauke, quicksilver, Baughn, sbahra: thanks
07:29:44 <dmead> > take 5 [1..10]
07:29:46 <lambdabot>  [1,2,3,4,5]
07:29:56 <dmead> > last $ take 5 [1..10]
07:29:59 <lambdabot>  mueval: Time limit exceeded
07:30:02 <dmead> what
07:30:09 <dmead> > last ( take 5 [1..10])
07:30:12 <lambdabot>  mueval: Time limit exceeded
07:30:18 <dmead> crazy
07:31:06 <mmorrow> mauke: oh, also i have a question about preflex
07:31:29 <Wild_Cat> wow, \bot seems to have become greedy on resources.
07:32:26 <mmorrow> mauke: so i've built preflex, and i wrote a shown Config to a file. i can't figure out though how to make a socket file or something it expects as its second arg
07:33:05 <mmorrow> i'm not familiar with AF_UNIX
07:35:14 <matthew-_> @hoogle sizeof
07:35:15 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
07:35:28 <matthew-_> hmm. is there no way of accessing C's sizeof?
07:35:56 * mmorrow has become painfully aware that if he wants a bot that he knows how to use fully, he'll just have to write his own
07:37:07 <dmead> :t second
07:37:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:37:15 <dmead> > second [1..10]
07:37:18 <lambdabot>  Couldn't match expected type `a b c' against inferred type `[a1]'
07:37:24 <dmead> ?src second
07:37:24 <lambdabot> Source not found. My mind is going. I can feel it.
07:37:26 <dmead> ...
07:37:52 <EvilTerran> second = (id ***)
07:37:59 <EvilTerran> i think
07:38:03 <EvilTerran> ?type (id ***)
07:38:04 <lambdabot> forall a b' c'. (b' -> c') -> (a, b') -> (a, c')
07:38:08 <dmead> > last (take 3 [1..3])
07:38:11 <lambdabot>  mueval: Time limit exceeded
07:38:16 <dmead> what?
07:38:21 <EvilTerran> hm, not quite right
07:38:24 <EvilTerran> ?type (arr id ***)
07:38:26 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => a b' c' -> a (b, b') (b, c')
07:38:37 <EvilTerran> there we go
07:51:37 <sw17ch> when making a new data type, can i require a member value to implement a specific typeclass?
07:51:57 <sw17ch> data (Bar a) => Foo a | Foo Int a Int
07:52:03 <sw17ch> or something similar?
07:54:03 <ziman> you can but it's considered useless
07:54:22 <ziman> you'd have to repeat the constraint with all functions using the data type
07:54:52 <skorpan> @pl \x -> "hello" ++ x
07:54:52 <lambdabot> ("hello" ++)
07:54:53 <ziman> even when the functions don't make use of the properties provided by the typeclass
07:54:56 <mopped> I have a function that tries to compute an average of a list, but its complaining about a 'Fractional Integer', what should I change?
07:55:00 <skorpan> @pl \x -> x ++ "hello"
07:55:00 <lambdabot> (++ "hello")
07:55:46 <ziman> just write the constraints to the functions that need them and leave the data declaration unconstrained
07:56:13 <sw17ch> ziman, hmm... that's what i was thinking...
07:56:19 <sw17ch> thanks, just wanted to confirm
07:57:41 * sw17ch has a problem he's working through that's a single line of haskell, but requires a bunch of whacky stuff in JavaScript
07:57:42 <Saizan> mopped: use fromIntegral on integer values if you want to use (/) on them
07:58:36 <mopped> ok, thanks
08:03:25 <DukeDave1> Heya, does anyone know if there is a video to a talk on data parallel Haskell somewhere on the web?
08:04:55 <DukeDave1> Aha, the answer: http://video.google.co.uk/videoplay?docid=370317485066035666&hl=en-GB
08:05:08 <lambdabot> http://tinyurl.com/2e7u76
08:05:17 <Axman6> "We're sorry, but this video may not be available. " :(
08:05:19 <DukeDave1> Gah, cancel that
08:05:24 <DukeDave1> Not cool
08:06:15 <DukeDave1> Axman6: Win: http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
08:06:22 <lambdabot> Title: λondon HUG » Blog Archive » Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
08:12:56 <chrisdone_> haskell jobs in london: myth or reality?
08:13:39 <BeelsebobWork> quicksilver: apparently I was wrong -- the purpose of Applicative for Event isn't to find bugs in Monad for Event -- it's to find bugs in QuickCheck
08:15:34 <quicksilver> BeelsebobWork: hee hee :)
08:16:50 <BeelsebobWork> apparently quickCheck decides a size for your output that's a random number between 0 and the size you specify
08:17:02 <BeelsebobWork> which means that you can get consistantly 0-sized output
08:19:25 <Baughn> Hm. Does quickcheck have quickcheck-tests for itself?
08:20:54 <BeelsebobWork> that's a good point, and no
08:26:37 <mm_freak> hmm
08:27:00 <mm_freak> somehow i'm getting to the conclusion that writing haskell documentation is easier in HTML than in LaTeX
08:27:37 <osfameron> well, HTML is easier than latex
08:27:49 <BeelsebobWork> for values of easy
08:28:06 <BeelsebobWork> depends how much maths you want to embed for example
08:28:24 <mm_freak> that's not the point…  LaTeX has some annoying peculiarities and the syntax is ugly
08:28:41 <osfameron> well, latex for simple documents sucks, as it's likely to completely fail to compile your document and spit out a completely useless error message instead
08:28:42 <mm_freak> but the output is much nicer than HTML
08:30:13 <maltem> depends on your browser :)
08:30:24 <Baughn> Latex really, /really/ needs an update
08:30:30 <Baughn> TeX is good, though. :P
08:30:50 <quicksilver> HTML (also) has some annoying pecularities and the syntax is ugly ;)
08:30:58 <BeelsebobWork> also mm_freak, why are you not writing haddock?
08:31:10 <Baughn> Actually, I'd have to claim HTML syntax is /way/ uglier than latex
08:31:13 <BeelsebobWork> quicksilver: HTML has fewer semantic oddities than LaTeX though
08:31:18 <mm_freak> maltem: not really…  LaTeX output has and preserves beautiful fonts consistently, it does hyphenating for you and always gives readable output, not depending on the browser/font
08:31:20 <BeelsebobWork> although it's syntax is way uglier
08:31:20 <maltem> Baughn: Imagine... a software with all the goodies that Latex has, but with a consistent UI
08:31:36 <_zenon_> LaTeX really, really, really, should get  block-comment operators
08:31:45 <BeelsebobWork> mm_freak: HTML always gives you readable output -- what doesn't is CSS
08:31:48 <Baughn> maltem: LaTeX is.. um, a macro substitution language in this day and age?
08:31:52 <mm_freak> BeelsebobWork: i'm not writing package documentation
08:32:00 <matthew-_> WE JUST BOWLED SOUTH AFRICA ALL OUT FOR 83
08:32:05 <Baughn> maltem: Too fragile, I'd say. An UI would be good, but a total rewrite (based on TeX) would be better
08:32:11 <DrSyzygy> Baughn: LaTeX always was a macro substitution language, right?
08:32:18 <Baughn> DrSyzygy: Yes
08:32:22 <BeelsebobWork> Baughn: nothing wrong with term rewriting ;) :P
08:32:30 <maltem> mm_freak: my point was, if your browser had beautiful fonts consistently, did hyphenating for you, and so on, ...
08:32:34 <Baughn> BeelsebobWork: Text substitution?
08:32:42 <Baughn> BeelsebobWork: Anyway, the language is just plain ugly
08:32:45 <BeelsebobWork> yep
08:32:46 <mm_freak> i feel very comfortable with monads now and i have an idea, how to introduce someone to them…  so i'm writing a monads tutorial =)
08:33:01 <Baughn> Latex is still better than anything else out there, which makes me sad. ;_;
08:33:09 <BeelsebobWork> mm_freak: welcome to the right of passage
08:33:17 <maltem> Baughn: I agree fully
08:33:31 * EvilTerran also agrees
08:33:42 <Baughn> BeelsebobWork: Do I need to write a monad tutorial too?
08:33:42 <quicksilver> Baughn: latex (well tex) is good enough that no one has written something better.
08:33:49 <_zenon_> mm_freak, can't get enough monad tutorials ;)
08:33:51 <quicksilver> despite not being perfect :)
08:33:54 <Baughn> quicksilver: I have no issues with tex
08:34:01 <_zenon_> everyone should write one
08:34:03 <quicksilver> I have some issue with tex ;)
08:34:05 <EvilTerran> i have issues with tex
08:34:10 <quicksilver> it's not very compositional.
08:34:11 <BeelsebobWork> Baughn: dunno -- most people do though -- I was thinking of making mine very subversive, and tell everyone when they shouldn't use them
08:34:12 <mm_freak> maltem: ok, valid, but such a browser unfortunately doesn't exist, and i wouldn't want to force the reader to use a specific browser =)
08:34:31 <quicksilver> it has a surprising pipelined multi-stage parser
08:34:32 <Baughn> quicksilver: Yeah, well. I think of tex as the equivalent of assembly - something a compiler should output, not something you write by hand
08:34:39 <BeelsebobWork> mm_freak: browser uniformity is very easy to get with simple HTML these days
08:34:43 <mm_freak> _zenon_: hehe yeah…  but i guess that comes from the fact that there are as many monad interpretations as there are people =)
08:34:47 <EvilTerran> it was designed for the days when RAM and CPU ticks were expensive
08:34:50 <BeelsebobWork> even IE 7 will get it right unless you use CSS 2
08:35:00 <mm_freak> well…  i've started with LaTeX, so now i'll keep it
08:35:04 <maltem> mm_freak: Yeah. See, HTML and PDF are different media for different purposes
08:35:05 <quicksilver> EvilTerran: Yes, it was designed for all sorts of constraints which no longer apply.
08:35:27 <EvilTerran> also, it's missing out on several decades of programming language theory
08:35:43 <_zenon_> mm_freak, just make sure you don't reuse old examples. that's what bothered me the most when I read monat tutorials, that all seemed to use the same examples
08:35:51 <maltem> mm_freak: Even though those purposes are sometimes hard to make out, given mangled designs
08:35:54 <BeelsebobWork> maltem: indeed -- a lot of people try to get their sites rendering the same everywhere -- when one of the design goals of html was to be able to have it render differently depending on the user's needs
08:35:59 <Baughn> EvilTerran: So should we write a tex backend for ghc?
08:36:08 <BeelsebobWork> hence why html only encapsulates logical document structure
08:36:11 <BeelsebobWork> and not styling
08:36:16 <EvilTerran> as Baughn says, it's something designed to be easy for computers, not easy for people
08:36:20 <chrisdone> BeelsebobWork: yeah, I hate, for example, the tiny font syndrome
08:36:20 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
08:36:42 <BeelsebobWork> chrisdone: yes, especially seeing as the result is that in Safari it usually renders at about 3pt
08:36:48 <chrisdone> BeelsebobWork: right
08:36:53 <mm_freak> _zenon_: nope, i'm trying a completely new approach…  i'll make it public as sonn as it's ready
08:36:55 <BeelsebobWork> and hence most modern browsers set the default text size to 18 pt
08:37:06 <BeelsebobWork> because so many sites decide to force small sizes on you
08:37:30 <EvilTerran> ff3's zoom is nice
08:37:47 <EvilTerran> better than ff2's "text size" setting, imo
08:37:56 <BeelsebobWork> yep, Safari 4 does that too
08:37:57 <quicksilver> iphone's zoom is nice too :)
08:37:58 <BeelsebobWork> it's very nice
08:38:04 <quicksilver> but not having the problem in the first place would be nicer.
08:38:06 <BeelsebobWork> yeh, that too quicksilver
08:38:09 <EvilTerran> indeed
08:38:10 <chrisdone> I have simply disallowed web sites to alter fonts, on Firefox. I tend to forget the setting is even there until I use someone else's computer and discover reading pages is a chore
08:38:12 <_zenon_> mm_freak, nice, I'll read it and come with suggestions (as everyone else in here) ;)
08:38:24 <mm_freak> great =)
08:38:25 <BeelsebobWork> quicksilver: I'm not sure that carrying aronud a 13" phone is a good solution to that problem :P
08:38:39 <quicksilver> that doesn't sound like a solution to any problem.
08:38:49 <BeelsebobWork> chrisdone: I have a stylesheet that safari uses in preference to the site's one
08:38:52 <quicksilver> Unless the problem is some kind of practical joke or comedy sketch.
08:39:05 <chrisdone> it's a solution to the problem of carring a 14" phone around, which is too heavy :P
08:39:05 <BeelsebobWork> quicksilver: the problem of only having a tiny screen to view websites on
08:39:14 <BeelsebobWork> lol
08:39:24 <EvilTerran> going back to typesetting, i feel that mathml had the potential to be nicer than tex
08:39:29 <maltem> chrisdone: Same for me, but it's a shame that there are sites that prescribe monospaced fonts instead of using code tags correctly
08:39:30 <EvilTerran> except it's built on XML
08:39:40 <EvilTerran> Which puts it right out of the running :P
08:39:52 <BeelsebobWork> so use a scheme -> XML syntax rewriter?
08:40:24 <EvilTerran> well, it generally suffers a bit from being designed by a hulking beaurocracy
08:40:35 <BeelsebobWork> yep
08:40:56 <EvilTerran> i find most of the w3c's specs to suffer from design-by-committee to the nth degree
08:40:59 <BeelsebobWork> so... Lakell time then?
08:41:10 <_zenon_> Anyone thought about mobile-phone relaying?
08:41:15 <quicksilver> (almost) anything built on XML gives up the goal of being sanely human readable/modifiable.
08:41:16 <EvilTerran> s/to suffer/suffer/
08:41:16 <BeelsebobWork> i.e. document production DSL in Haskell
08:41:21 <_zenon_> So that each mobile-phone can relay another.
08:41:26 <EvilTerran> BeelsebobWork, i've thought about that, actually
08:41:29 <hackage> Uploaded to hackage: hgalib 0.1
08:41:31 <quicksilver> giving up that goal is taking the decision you will rely on tools to edit the files.
08:41:35 <quicksilver> that's not the end of the world.
08:41:38 <EvilTerran> something built on top of metapost or something
08:41:40 <BeelsebobWork> EvilTerran: yeh, so have I, it's not the easiest problem in the world though
08:41:42 <quicksilver> but it presupposes sufficiently good tools.
08:41:46 <BeelsebobWork> EvilTerran: oh, what's metapost?
08:41:50 <quicksilver> and it is definlely something to give up.
08:41:57 <quicksilver> BeelsebobWork: equational graphics language.
08:42:01 <quicksilver> it's rather cute, actually.
08:42:02 <BeelsebobWork> ah, I see
08:42:09 <maltem> quicksilver: yeah it's interesting that many XML structures would still look over-engineered with all XML syntax and XML oddities taken away
08:42:11 <BeelsebobWork> well... I have a pdf writing library for Haskell half finished
08:42:11 <EvilTerran> it generates postscript, i believe, hence the name
08:42:24 <quicksilver> (it's the generalisation of metafont, which was Knuth's equational font description language)
08:42:28 <BeelsebobWork> which I was at some point planning on abstracting
08:42:38 <BeelsebobWork> until it became a nice compositional document layout thing
08:42:50 <quicksilver> maltem: yes, that's an interesting observation.
08:42:52 <BeelsebobWork> and then an auto-layout engine on top of that
08:43:05 <quicksilver> maltem: although it's easier to get an overengineered complete structure.
08:43:10 <quicksilver> maltem: ...than a nice minimal one.
08:43:14 <quicksilver> maltem: minimality is hard :)
08:43:26 <maltem> quicksilver: true
08:43:42 <BeelsebobWork> and also not also what you want
08:43:54 <quicksilver> committees tend to design overengineered solutions
08:43:59 <quicksilver> because they aim always for completeness
08:44:03 <quicksilver> covering every single case
08:44:04 <BeelsebobWork> i.e. I don't want my library to only define join and return for me -- I want standard defs of (>>=) etc in there too
08:44:18 <EvilTerran> "if you assign three teams to build a compiler, you will get a three-pass compiler" etc
08:44:30 <quicksilver> BeelsebobWork: a compositional page layout thing would be *AWESOME*.
08:44:43 <BeelsebobWork> quicksilver: my usual feeling on that is that they aimed for a specific case, and then tacked on other ones afterwards
08:44:44 <quicksilver> BeelsebobWork: I use your technical term 'thing' as a term of respect ;)
08:45:01 <BeelsebobWork> rather than starting by thinking about what the general "thing" looks like
08:45:18 <BeelsebobWork> quicksilver: nothing wrong with using thingamybobs and doojeryflips
08:45:18 <BeelsebobWork> :P
08:45:21 <EvilTerran> quicksilver, i agree - it's one of the "maybe do sometime" projects i meditate on in my downtime
08:45:43 <BeelsebobWork> well -- at some point I'll put my pdf writing library on Hackage
08:45:45 <maltem> BeelsebobWork: which is just a plain mistake in methodology, obviously
08:45:54 <BeelsebobWork> I need to add text support first though
08:45:58 <BeelsebobWork> fonts are hard in pdf
08:46:23 <chrisdone> let's go shopping?
08:46:39 <r3m0t> chrisdone: I'll have some monoids please
08:46:40 <BeelsebobWork> o.O
08:46:59 <BeelsebobWork> chrisdone: can you take back these Monads, they have some odd "effects" just below the surface
08:47:04 <BeelsebobWork> I'd like a refund
08:47:37 <EvilTerran> BeelsebobWork, i don't think you can undo that if you've committed the transaction already
08:48:15 <BeelsebobWork> EvilTerran: I was advertised something other than I got, I'll call in the Sale of Goods and Services Act
08:48:17 <BeelsebobWork> :P
08:48:25 <EvilTerran> unless there's an outer transaction you're willing to rollback
08:48:29 <BeelsebobWork> hehe
08:48:33 <quicksilver> @remember EvilTerran If you assign three teams to build a compiler, you will get a three-pass compiler.
08:48:34 <lambdabot> I will remember.
08:48:39 <quicksilver> lambdabot: frankly I doubt that.
08:48:46 <EvilTerran> quicksilver, i think i got that from The Mythical Man-Month
08:48:59 <EvilTerran> same place as "adding more people to a late project makes it later"
08:49:21 <quicksilver> @remember chrisdone < BeelsebobWork> fonts are hard in pdf < chrisdone> let's go shopping?
08:49:21 <lambdabot> Done.
08:49:30 <quicksilver> EvilTerran: few years since I read it. Probably time to read it again.
08:49:40 <BeelsebobWork> I'm missing something with that quote though
08:49:41 <alson> hey, I have a small little memory leak issue that I'd love some help with
08:49:55 <alson> http://hpaste.org/9937 has the sample code
08:49:55 <quicksilver> alson: smoked too much dope?
08:49:59 <alson> ;)
08:50:18 <alson> might be a memory leak; might be me missing something obvious
08:50:23 <quicksilver> alson: not really a leak.
08:50:28 <quicksilver> just a fact about how mapM works.
08:50:41 <EvilTerran> http://img.photobucket.com/albums/v357/hockeystar31/memoryerror1.bmp
08:50:43 <lambdabot> http://tinyurl.com/2ku395
08:50:56 <quicksilver> alson: try mapM_
08:51:15 <alson> quicksilver: actually, I wrapped that mapM around there just for the example code.   My real code has the leak, but doesn't use mapM
08:51:29 <ziman> hm, forcing `str' will not force it completely, just the first cons cell, won't it?
08:51:37 <EvilTerran> alson, also note that those `seq`s won't be forcing the whole string
08:51:42 <quicksilver> alson: well the difference in memory usage between those two examples is, to me, explained by the fact that one does much more work :)
08:51:46 <EvilTerran> only the outermost cons/nil, as ziman says
08:52:00 <alson> the one that does much more work uses _LESS_ memory!
08:52:11 <quicksilver> oh.
08:52:13 <alson> that's the confusing part
08:52:13 * quicksilver reads again
08:52:21 <EvilTerran> massive thunk buildup?
08:52:40 <alson> ET: I think you're right, but I don't know where the thunks are building up.
08:52:43 <quicksilver> alson: did you check the real GC statistics?
08:52:54 <alson> I guess I should profile this now that I have it outside of my app code...
08:52:54 <quicksilver> peak memory usage is in itself not entirely reliable
08:53:01 <quicksilver> you don't need a full profile
08:53:05 <quicksilver> just -RTS -sstderr
08:53:09 <quicksilver> if I remember right
08:53:13 <quicksilver> gives you GC stats.
08:53:47 <quicksilver> peak memory usage tells you something about when the GC happened to get run, but there are a lot of factors involved. Somethign with higher peak memory might just be calling the GC a bit less often.
08:53:53 <osfameron> how would you write is_sorted :: Eq a => [a] -> Bool  ?
08:53:55 <desp> What Haskell module should I use as a base for a pretty-printer?
08:54:04 <quicksilver> 3.5MB of memory really isn't very much for a haskell program, either.
08:54:12 <quicksilver> osfameron: you can't possibly write that.
08:54:14 <osfameron> would that be a fold with an accumulator containing current boolean and last value?
08:54:21 <quicksilver> osfameron: do you mean Ord a => ? :)
08:54:25 <osfameron> quicksilver: er.  yes.  Ord a
08:54:31 <osfameron> heh
08:54:40 <quicksilver> yes, you can write it as a strict left fold.
08:54:50 <quicksilver> although I probably wouldn't.
08:54:53 <r3m0t> I would zipWith (<=) x (tail x)
08:54:55 <osfameron> it has to be strict?
08:54:59 <quicksilver> I'd probably do ... what r3m0t just said.
08:55:05 <r3m0t> > zipWith (<=) x (tail x) [1..5]
08:55:07 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
08:55:13 <r3m0t> > and $ zipWith (<=) x (tail x) [1..5]
08:55:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
08:55:16 <quicksilver> osfameron: no, it could also be a lazy right fold.
08:55:23 <r3m0t> > and $ zipWith (<=) x (tail x) where x = [1..5]
08:55:23 <lambdabot>  Parse error at "where" (column 31)
08:55:27 <r3m0t> oh...
08:55:36 <kowey> Toxaris: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tabular
08:55:37 <lilac> r3m0t: that's what i was thinking too :)
08:55:40 <Saizan> you can't use where in expressions
08:55:43 <Myoma> > let in (and $ zipWith (<=) x (tail x) where x = [1..5])
08:55:43 <lambdabot>  Parse error at "where" (column 39)
08:55:46 <r3m0t> > let f x = zipWith (<=) x (tail x)
08:55:46 <lambdabot>  Parse error at end of input
08:55:52 <lambdabot> Title: HackageDB: tabular-0.1, http://tinyurl.com/5a24eb
08:55:53 <lilac> > let x = [1..10] in and $ zipWith (<=) x (tail x)
08:55:54 <kowey> Toxaris: thanks again! now I can get on with my real work (using this library)
08:55:54 <Myoma> > let result = and $ zipWith (<=) x (tail x) where x = [1..5] in result
08:55:56 <lambdabot>  mueval: Time limit exceeded
08:55:57 <lambdabot>  True
08:56:03 <r3m0t> > let f x = zipWith (<=) x (tail x) in (f [1..5], f [5..1])
08:56:06 <lambdabot>  mueval: Time limit exceeded
08:56:10 <Myoma> > let result = and $ zipWith (<=) x (tail x) where x = [1..5] in result
08:56:12 <lambdabot>  mueval: Time limit exceeded
08:57:30 <JCGRAFICA> I live in Brazil and I do not know as well as esso functions somebody explains can me
08:57:53 <osfameron> that's a nice solution, and the laziness of and will Just Work
08:58:04 <quicksilver> osfameron: *nod*
08:58:06 <Myoma> Maybe
08:58:12 <quicksilver> the zipWith solution is more readable, definitely.
08:58:28 <quicksilver> the native recursion is probably slightly faster.
08:58:31 <quicksilver> the fold might be, too.
08:59:14 <gpds> what does Ord mean?  is it different from just saying Num?
08:59:20 <quicksilver> yes.
08:59:28 <quicksilver> Ord just means that > < >= etc work.
08:59:36 <gpds> but not necessarily anything else?
08:59:41 <quicksilver> right.
08:59:41 <r3m0t> gpds: for example strings have Ords
08:59:42 <Myoma> :t compare
08:59:44 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:59:49 <quicksilver> > "foo" < "bar"
08:59:52 <lambdabot>  mueval: Time limit exceeded
08:59:53 <quicksilver> > "foo" < "bar"
08:59:56 <lambdabot>  False
09:00:11 <r3m0t> @src Ordering
09:00:12 <lambdabot> data Ordering = LT | EQ | GT
09:00:54 <tromp> > LT < GT
09:00:57 <lambdabot>  mueval: Time limit exceeded
09:01:11 <r3m0t> > sort [LT,GT,LT,EQ]
09:01:13 <EvilTerran> ?src Ord
09:01:13 <lambdabot> class  (Eq a) => Ord a  where
09:01:13 <lambdabot>     compare      :: a -> a -> Ordering
09:01:13 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:01:13 <lambdabot>     max, min         :: a -> a -> a
09:01:14 <lambdabot>  [LT,LT,EQ,GT]
09:01:53 <tromp> > LT > GT
09:01:56 <lambdabot>  False
09:02:21 <gpds> so if i have data (Ord a, Num b) => Something a a = ...
09:02:26 <gpds> the name of the data type is Something?
09:02:30 <tromp> > [LT..GT]
09:02:30 <lambdabot>  Parse error at "LT..G..." (column 2)
09:02:39 <Myoma> @src Num
09:02:40 <lambdabot> class  (Eq a, Show a) => Num a  where
09:02:40 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:02:40 <lambdabot>     negate, abs, signum     :: a -> a
09:02:40 <lambdabot>     fromInteger             :: Integer -> a
09:02:54 <r3m0t> gpds: yes, but what the hell is it?
09:02:58 <EvilTerran> > [LT ..]
09:02:59 <Myoma> @instances Ord
09:03:00 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:03:01 <lambdabot>  mueval: Time limit exceeded
09:03:03 <quicksilver> gpds: Yes, that's right. Don't do that, by the way.
09:03:05 <gpds> well its a tree
09:03:07 <gpds> how would you do it?
09:03:07 <tromp> > [LT .. GT]
09:03:10 <quicksilver> don't put constraints on data types.
09:03:10 <lambdabot>  [LT,EQ,GT]
09:03:11 <quicksilver> they don't work.
09:03:21 <gpds> you wouldnt declare the (ord, num) before naming it?
09:03:23 <EvilTerran> tromp, "LT.." gets parsed as the name (.) in the module LT, unfortunately
09:03:36 <tromp> there;s a module called LT?
09:03:43 <EvilTerran> tromp, no
09:03:46 <tromp> ok:)
09:03:51 <EvilTerran> unless you import qualified ... as LT
09:03:53 <r3m0t> tromp: but there could have been! :-)
09:03:53 <Myoma> there's more likely to be than a module called 0
09:04:24 <EvilTerran> but, in "[NameStartingWithUppercase..", that's how it gets parsed
09:04:30 <EvilTerran> maximal munch rule
09:04:43 <tromp> > let n=0 in let m=2 in [n..m]
09:04:45 <lambdabot>  [0,1,2]
09:04:46 * quicksilver strictly adheres to the maximal lunch rule.
09:04:47 <r3m0t> ...om. nom. nom.
09:05:15 <tromp> hmm, specific to capitals
09:05:29 <EvilTerran> tromp, indeed, because names starting with a lowercase can't be a module name
09:05:50 <quicksilver> uppercase = Module or Constructor, remember.
09:05:53 <tromp> > [LT ..GT]
09:05:56 <lambdabot>  [LT,EQ,GT]
09:06:02 <quicksilver> lowercase = variable (type or value)
09:06:28 <EvilTerran> actually, i think it gets parsed as LT.<error: no alphanumeric character>
09:06:32 <EvilTerran> rather than LT.(.)
09:06:44 <EvilTerran> seeing as it's not expecting an operator there
09:07:05 <quicksilver> EvilTerran: why shouldn't it be an operator?
09:07:13 <quicksilver> EvilTerran: operators can be members of Enum.
09:07:17 <quicksilver> oh
09:07:22 <quicksilver> but they'd need to be in brackets :)
09:07:25 <quicksilver> good point.
09:10:48 <chrisdone> type Body = Expr
09:10:49 <chrisdone> type Operand = Expr
09:10:50 <chrisdone> type Argument = Expr
09:10:54 <chrisdone> is there a short-hand for this?
09:11:20 <r3m0t> write a preprocessor :P
09:11:22 <chrisdone> e.g. type Body,Operand,Argument = Expr
09:12:03 <chrisdone> I could write a Rule. seems a bit OTT, though
09:16:32 <haskellian> is there a red-black-tree in the stdlib?
09:17:20 <Myoma> no
09:17:26 <Myoma> edison probably has one
09:18:29 <Myoma> maybe not
09:19:34 <EvilTerran> aren't red-black trees mutable?
09:20:04 <osfameron> can be
09:20:38 <Myoma> http://www.rosettacode.org/wiki/Pattern_Matching#Haskell
09:20:47 <lambdabot> Title: Pattern Matching - Rosetta Code
09:21:22 <Beelsebob> given that I know the argumens of par are strict, should it be possible for par to cause a massive memory leak?
09:21:53 <quicksilver> haskellian: there is some similar kind of tree in Data.Map / Data.Set
09:21:58 <quicksilver> I'm not sure if it's RB.
09:22:05 <quicksilver> Beelsebob: I don't think so. Could be wrong, though.
09:22:13 <quicksilver> Beelsebob: par is just a hint, it shouldn't really cause memory leaks.
09:22:39 <Beelsebob> quicksilver: exactly -- I decided to be really naïve and add `par` statements to the binarytree benchmark on debian language shootout
09:22:48 <Beelsebob> it's exactly the same speed without -threaded
09:22:57 <Beelsebob> but with -threaded on, it suddenly leaks memory like a sive
09:24:04 <haskellian> I want to rep a Graph but How can I have unlimited nbr of nodes?
09:24:32 <Myoma> what
09:25:16 <Beelsebob> quicksilver: http://hpaste.org/9938 <-- I realise I'm probably adding too much parallelism here, but do you see any reason why this should explode?
09:25:30 <EvilTerran> haskellian, well, the conventional representation of a graph is something like Map Node (Set Node)
09:25:34 <EvilTerran> for whatever your Node type is
09:25:55 <EvilTerran> you'd need some kind of lazy infinite structure that had the same effect
09:26:05 <EvilTerran> you could perhaps do something with a trie
09:26:47 <EvilTerran> alternatively, you might be able to not concretise the graph at all, and leave it (or the part of it you explore, at least) implicit in the call graph of your code
09:29:21 <Svrog> http://hpaste.org/9939
09:29:35 <Svrog> how would I go about writing a Data instance for a GADT? is that even possible?
09:29:49 <Svrog> hmm wonder why the hpaste wasnt announced
09:30:53 <maltem> Beelsebob: shouldn't some of those par's be pseq's?
09:31:06 <Beelsebob> maltem: why?
09:31:52 <Svrog> are generics incompatible with GADTs?
09:32:03 <maltem> Beelsebob: for example, i + l' - r' depends on l' and r', so why bother and evaluate it in parallel with those?
09:32:35 <Beelsebob> maltem: oh, okay, yes, probably it should be (l' `par` r') `seq i + l' - r'
09:32:45 <Beelsebob> but still, it doesn't explain the memory explosion
09:32:50 <maltem> true
09:33:04 <maltem> still, what happens if you make those changes?
09:33:11 <Beelsebob> just checking
09:33:15 <maltem> (preferring pseq to seq)
09:33:25 <quicksilver> Beelsebob: isn't that tree strict anyway?
09:33:32 <quicksilver> so I'm surprised by the memroy explosion, yes.
09:33:37 <desp> Hey guys, I have a weird compile problem.
09:33:38 <Beelsebob> exactly
09:33:38 <desp> "Foo.hs:5:9: Not in scope: data constructor `LanguageDef'
09:33:47 <desp> This is Foo.hs: http://hpaste.org/9940
09:34:05 <desp> If I import the whole Language module, there is no compile error.
09:34:15 <Beelsebob> quicksilver: maltem: using seq there got rid of it
09:34:17 <Beelsebob> how odd
09:34:41 <quicksilver> desp: you have imported the type.
09:34:44 <quicksilver> desp: not the constructor.
09:34:48 <Myoma> Svrog, does something like
09:34:50 <Myoma>     gunfold cbr_cr r_cr c = case constrIndex c of
09:34:50 <Myoma>       0 -> case fromConstr c :: T Int of I i -> ?
09:34:50 <Myoma>       1 -> case fromConstr c :: T Float of F f -> ?
09:34:53 <desp> quicksilver: how do I import the constructor?
09:34:54 <quicksilver> perhaps you meant LanguageDef(LanguageDef)
09:34:56 <Myoma> Svrog, lead anywhere?
09:35:26 <desp> quicksilver: oh, ugh.
09:35:44 <maltem> Beelsebob: hm... I suppose then that we're missing something about par's operational semantics, I just don't have a clue what it is :)
09:36:27 <Beelsebob> hmm, par should work truely in parallel with -threaded and +RTS -N2 turned on, yes?
09:36:43 <quicksilver> maltem: I don't blame you for that, since you don't know what par's operational semantics are.
09:36:46 <quicksilver> maltem: no one does :)
09:36:52 <Svrog> Myoma: nope
09:36:58 <Svrog> that still doesn't work
09:36:58 <quicksilver> [except, perhaps, the person who wrote the code]
09:37:02 <maltem> quicksilver: its implementation then :)
09:37:11 <Myoma> Svrog, why not?
09:37:16 <Svrog> same error
09:37:26 <Myoma> Svrog, '?' isn't valid code
09:37:42 <Svrog> give me a sec - ill just double check something
09:40:26 <Svrog> Myoma: obviously
09:40:47 <Myoma> so it can't have given the same error as what you got befor
09:40:52 <Svrog> even so it still seems to be giving me the same error - im not really seeing how that would help really
09:41:29 <hackage> Uploaded to hackage: tabular 0.1
09:41:29 <hackage> Uploaded to hackage: haskell-src-exts 0.3.7
09:42:26 <maltem> Beelsebob: hm, doesn't it?
09:42:57 <Beelsebob> maltem: hmm, apparently it does -- but not where I'm putting it -- I think those tasks must be too small to get any usage over 1 thread
09:43:03 <Svrog> Myoma: i get the same error if i use k (z I) and k (z F) in place of those question marks
09:43:05 <Beelsebob> I moved it up the tree a bit
09:43:18 <Beelsebob> and got both CPUs being used fully
09:43:23 <Beelsebob> but an overall slowdown
09:43:38 <Beelsebob> which is rather odd -- given that there's no locking to do at all
09:43:44 <Myoma> Svrog: no you'd get variable out of scope error
09:43:50 <Beelsebob> garbage collector getting in my way possibly?
09:45:37 <Svrog> Myoma: http://hpaste.org/9939#a1
09:45:41 <Svrog> same error
09:46:12 <Trinithis> Is there some option to make the ParserChar combinators case insensitive?
09:46:56 <Trinithis> or would I have to build my own string function
09:47:24 <maltem> Beelsebob: this is odd, I tried to run the program, and it eats memory no matter what (par vs pseq vs seq)
09:47:38 <Beelsebob> maltem: that's very odd
09:47:45 <Beelsebob> I assume only when you compile with -threaded?
09:48:11 <maltem> Beelsebob: let me check. also, what would be a convenient input number to use for tests?
09:48:25 <Beelsebob> maltem: oh, 16 to 18 seems reasonable
09:48:35 <selmanj> So I'm learning haskell and wrote a version of findIndices for a 2d array, but I'm pretty sure my solution sucks.  Can someone tell me if there's a better way to do it?
09:48:38 <selmanj> http://hpaste.org/9941
09:48:58 <Trinithis> :t toLower
09:49:00 <lambdabot> Char -> Char
09:49:03 <Beelsebob> selmanj: so, what's findIndicies meant to do?
09:49:24 <Beelsebob> give a list of indicies where the property is true?
09:49:33 <selmanj> Beelsebob: exactly
09:50:03 <maltem> Beelsebob: oh ok, then I was probably mistaken by the program using much memory on input 30 :)
09:50:30 <selmanj> Beelsebob: I tried to use tail-recursion in my solution but I think ther'es probably a better way to do it still
09:50:33 <Beelsebob> selmanj: then I'd probably pair each element with it's index, filter on it, and then concat
09:50:37 <Trinithis> @src string
09:50:37 <lambdabot> Source not found. I feel much better now.
09:51:10 <Trinithis> @src Text.ParserCombinators.string
09:51:10 <lambdabot> Source not found. Wrong!  You cheating scum!
09:51:15 <Trinithis> @src Text.ParserCombinators.Parsec.string
09:51:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:51:18 <selmanj> Beelsebob: hmm, you can do this on a 2d array?
09:51:26 <selmanj> arg, sorry, a 2d list i mean
09:51:36 <Beelsebob> selmanj: map (filter p)
09:51:46 <Beelsebob> or better yet, concatMap (filter p) to do it all in one sweap
09:52:24 <selmanj> hmm, taht is much simpler
09:53:19 <selmanj> I guess I'm just having trouble thinking functionally.  I wrote something that is basically a for loop
09:53:39 <Beelsebob> yeh, it takes a while to get into thinking that way
09:53:40 <thou> selmanj: welcome to the club ;-)
09:53:55 <Beelsebob> a good metric is "if you write primitive recursion, you're doing it wrong"
09:54:10 <selmanj> hehe
09:54:15 <Beelsebob> pretty much all the basic primitive recursive patterns have in some way been captured by a higher order function
09:54:54 <Svrog> Myoma: http://hpaste.org/9939#a2
09:54:59 <Trinithis> Does parsec's string function behave like: sequence char ?
09:55:03 <Svrog> now im getting a more interesting error
09:55:22 <Svrog> GADT pattern match in non-rigid context for `I' - Tell GHC HQ if you'd like this to unify the context
09:56:27 <Trinithis> or rather ... mapM char
10:02:36 <BMeph> selmanj: Looks like a job for a Schwartian Transform... :)
10:03:51 <selmanj> BMeph: A new term to google!
10:04:59 <davidL> dcoutts: no, I wasn't able to work out the dep conflict
10:08:16 <Saizan> davidL: you've to recompile zlib against that older ByteString, iirc, which is usually done by unregistering zlib and the newer bytestring and recompiling zlib
10:09:19 <haskellian> what is a simple problem to solve with Markov chains?
10:09:32 <maltem> Beelsebob: Alright, I did some timings, and it seems that ghc does indeed not do any parallelizing here.
10:09:55 <Beelsebob> maltem: yeh, shame isn't it
10:10:05 <Beelsebob> if you move the par up to where a and be are computed
10:10:10 <Beelsebob> you get some parallelism
10:10:18 <Beelsebob> but you get more overhead
10:11:13 <maltem> d'oh, that would have been the next thing that I'd have tried
10:11:22 <dancor> haskellian: might find some at http://en.wikipedia.org/wiki/Markov_chain#Applications
10:11:23 <lambdabot> Title: Markov chain - Wikipedia, the free encyclopedia
10:11:41 <maltem> avoiding par in recursive calls
10:12:29 <dmhouse> haskellian: given a body of text, produce words that look like English.
10:13:29 <BMeph> dmhouse: s/English/Finnish/? ;)
10:16:05 <desp> Are there any tutorials on using Text.PrettyPrint.HughesPJ ?
10:21:55 <binarybandit>  <haskellian> what is a simple problem to solve with Markov chains? <-- IRC chat bot!
10:31:00 <haskellian> dmhouse: you mean produce sentences by sampling from the text? hmm i actually wrote a spamfilter in Haskell so this could be a good way to see if I could beat my own filter :)
10:31:24 <haskellian> binary: really, you mean generating random gibberish and insults? :)
10:31:41 <dmhouse> ?yow
10:31:41 <lambdabot> Couldn't find fortune file
10:31:50 <dmhouse> Aww. And it was so applicable, as well.
10:31:55 <qwr> BMeph: like finnish? kas see sobib, et oleks nagu soomekeel? :P
10:32:00 <dmhouse> ?ask Cale to fixify ?yow, pwetty pwease.
10:32:00 <lambdabot> Consider it noted.
10:33:19 <BMeph> qwr: En puhu suomi.
10:34:25 <qwr> BMeph: it was actually estonian. but yours looks like finnish even to me... ;)
10:34:51 <rwbarton> qwr: thanks, I was wondering whether it was Estonian or *really* colloquial Finnish :P
10:35:41 <rwbarton> (Not saying they are the same thing at all, just that my Finnish is not good enough to distinguish them)
10:35:52 <BMeph> qwr: ...my *what* looks like Finnish?
10:35:56 <Lamperi> Ihme hyypiöt puhuu viroa
10:35:57 <dons> hmm, this dataflow optimization engine for GHC looks pretty wild.
10:36:15 <qwr> BMeph: "en puhu suomi"
10:36:32 <Lemmih> dons: URL?
10:36:37 <dons> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen
10:36:39 <lambdabot> Title: Commentary/Compiler/IntegratedCodeGen - GHC - Trac, http://tinyurl.com/6g4fqb
10:36:52 <dons> "We can define a new optimization simply by defining a lattice of dataflow facts (akin to a specialized logic) and then writing the dataflow-transfer functions found in compiler textbooks. Handing these functions to the dataflow engine produces a new optimization"
10:37:54 <olsner> Or, in layman's terms: Build two big hammers, and hit as many nails as possible.
10:38:55 <dons> http://www.reddit.com/r/programming/comments/6y3yx/ghc_gets_a_new_native_code_generator_with_two_big/
10:38:57 <lambdabot> Title: GHC gets a new native code generator, with two big hammers: a dataflow optimizat ..., http://tinyurl.com/5met7y
10:39:25 <lament> is GHC much faster now?
10:39:31 <lament> oh, proposed
10:40:01 <dons> well, this is what is getting pushed.
10:41:36 <jeffersonheard> is there a haskell routine for calculating the gamma function?
10:41:41 <mm_freak> with Clean's uniqueness types, i have to pass around world's state explicitly, don't i?
10:41:45 <dons> jeffersonheard: in the cmath library
10:41:50 <jeffersonheard> thanks, dons
10:41:52 <idnar> wow, that sounds awesome
10:41:57 <dons> mm_freak: yeah.
10:42:46 <mm_freak> why don't we employ uniqueness types in haskell?  not for I/O, but for destructive updates
10:43:48 <dons> yet more complications to the type system?
10:43:52 <dmhouse> dons: who's the author for that page?
10:44:04 <dons> John Dias.
10:44:04 <bd_> dons: It would be nice to have the information available for the optimizer though
10:44:19 <bd_> eg, magically turn array updates into destructive updates
10:45:06 <mm_freak> dons: i like the concept, because it can make many things implicit, which you have to do explicitly now
10:45:31 <mm_freak> for example you could get rid of MArray, or at least provide an alternative that's useful in many places
10:49:15 * BMeph likes the emphasis around "using a big hammer should be easy"
10:51:01 <newsham> do hackage haddock docs get batch generated at a different time than the package web pages?
10:51:55 <Saizan> yes
10:53:44 <lilac> mm_freak: isn't the problem with uniqueness types that you have to explicitly thread them? you'd presumably want some do-notation-like thing, at which point you've basically reinvented monads...
10:54:38 <lilac> though some way to say to the compiler, "you can use this optimized function if the input value is unique" might be nice
10:54:55 <dons> you might want uniqueness annotations on your monadically threaded state, eh?
10:55:04 <lilac> yes please :)
10:55:07 <dons> instead of threading an IORef, or other mutable thing.
10:56:20 <lilac> specializing f (x:xs) = y:xs into a destructive update in the case where the cons is unique would be cool
10:57:23 <dons> yikes.
10:57:58 <Myoma> I think that is really hard
10:58:00 <Myoma> to optimize
10:58:17 <Myoma> did the linear lisps actually work in that way?
10:58:51 <mm_freak> lilac: i just find that there should be an easier way to have destructive updates than using explicitly mutable variables
10:59:17 <mm_freak> uniqueness types seem to be a good thing for things like:  cfg { someSetting = someNewSetting }
10:59:22 <Myoma> I thought it was more like a forth actually
10:59:26 <mm_freak> or for updating arrays
10:59:59 <binarybandit> > break odd [1, 2, 3, 4, 5, 6]
11:00:03 <lambdabot>  mueval: Time limit exceeded
11:00:12 <Myoma> > partition odd [1, 2, 3, 4, 5, 6]
11:00:14 <lambdabot>  ([1,3,5],[2,4,6])
11:00:15 <Myoma> @undef
11:00:15 <lilac> mm_freak: i'd prefer if it were a pure optimization, i think. if the compiler can check your uniqueness annotations, it can generate them
11:00:17 <lambdabot> Undefined.
11:00:25 <binarybandit> > break odd [1, 2, 3, 4, 5, 6]
11:00:28 <lambdabot>  mueval: Time limit exceeded
11:00:31 <binarybandit> oh
11:00:56 <Myoma> lilac: If you have a module with one function used only linearly-- you don't know if the module that uses it will do the same
11:01:06 <mm_freak> lilac: yes, and obviously the compiler doesn't always know what you mean, so it would be nice to be able to annotate uniqueness explicitly
11:01:11 <dmhouse> ?hoogle break
11:01:12 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:01:12 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
11:01:12 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
11:01:47 <mm_freak> just like you want to annotate trictness \begin{verbatim}
11:01:56 <mm_freak> just like you want to annotate strictness explicitly
11:02:20 <Myoma> uniqueness and linearity have some difference?
11:02:23 <Myoma> what are the differences
11:02:38 <haskellian> ?src unsafePerformIO
11:02:38 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
11:02:43 <haskellian> ?module
11:02:44 <lambdabot> Unknown command, try @list
11:02:59 <haskellian> @list unsafePerformIO
11:02:59 <lambdabot> No module "unsafePerformIO" loaded
11:03:00 <Myoma> o_o
11:03:05 <haskellian> what module?
11:03:12 <haskellian> anyone?
11:03:13 <Myoma> @List
11:03:14 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:04:06 <haskellian> unlambda yourself
11:04:12 <haskellian> ?unlambda yourself
11:04:12 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
11:04:31 <haskellian> lambdabot == leet?
11:04:45 <Myoma> haskellian stop ...
11:04:57 <mm_freak> lambdabot needs an own power plant for things like @pl
11:05:05 <mm_freak> so it must be leet
11:05:06 <Myoma> @pl (\x -> x x)
11:05:07 <lambdabot> join id
11:05:12 <Myoma> @pl (\x -> x x) (\x -> x x)
11:05:15 <lambdabot> ap id id (ap id id)
11:05:15 <lambdabot> optimization suspended, use @pl-resume to continue.
11:05:19 <Myoma> @pl-resume
11:05:25 <lambdabot> ap id id (ap id id)
11:05:25 <lambdabot> optimization suspended, use @pl-resume to continue.
11:05:57 <mm_freak> @pl \x ys -> map (x:) ys ++ ys
11:05:58 <lambdabot> join . ((++) .) . map . (:)
11:06:37 <Myoma> :t ?f . (:)
11:06:39 <lambdabot> forall c a. (?f::([a] -> [a]) -> c) => a -> c
11:07:05 <haskellian> http://hpaste.org/9942 , what do i need to do to print?
11:08:29 <mm_freak> haskellian: the code doesn't make sense to me
11:08:55 <mm_freak> f x = if x > 10 then unsafePerformIO (return x) else 5
11:09:27 <mm_freak> but if you're doing the unsafePerformIO to be able to print something, then your whole concept is flawed
11:09:32 <trofi> lua has special regular expressions, like "%{}". this one will detect nested multiline curly brackets, like "{ hello = { world = {1}}". does haskell have somethink like this or i shoud use parsec (for nestings)?
11:10:05 <dmhouse> (Interestingly, that makes lua's regexps non-regular.)
11:10:06 <Myoma> trofi: Well you can use parsec to implement something that works like '%'
11:10:09 <binarybandit> is there a variant of break that breaks AFTER the element that is false?
11:10:32 <mmorrow> binarybandit: heh, i always want that
11:10:42 <binarybandit> mmorrow, what did you do? :p
11:13:02 <mmorrow> > let split p xs = case span p xs of (ys,z:zs) -> (ys,zs) ; a@(_,[]) -> a in split (<4) [0..9]
11:13:14 <dmead> :t (>=)
11:13:23 <dmead> ?type (>=)
11:13:25 <mmorrow> hmm
11:13:32 <mmorrow> @botsnack
11:13:38 <dmead> > "ping"
11:13:47 <dmead> i think he's dead
11:14:01 <mmorrow> binarybandit: i usually wrap span (or break) in a function like that
11:14:09 <binarybandit> I see, thanks
11:14:13 <mmorrow> :)
11:14:51 <haskellian> mm: it is just to test unsafepERFORMio, iw ant to print isndie a norml function
11:15:15 <mmorrow> like debug?
11:15:23 <mmorrow> debug :: a -> a
11:15:35 <mmorrow> debug a = unsafePerformIO (print a >> return a)
11:15:36 <newsham> > "this is unsafe"
11:15:48 <mmorrow> (well, actually   debug :: (Show a) => a -> a
11:15:50 <mmorrow> )
11:15:59 <Deewiant> debug = trace . show
11:16:21 <paczesiowa> :t trace . show
11:16:22 <newsham> ?type trace . show
11:16:36 <paczesiowa> trace . show will return String always
11:16:37 <mmorrow> newsham: i fixed that!
11:16:46 <mmorrow> (the  > "asdsasddsasdunsafe2222"
11:16:48 <Deewiant> hmm, right
11:16:51 <Olathe> > 5
11:16:57 <Olathe> No bots
11:17:12 <newsham> ?type trace
11:17:14 <noBotE> Not in scope: `trace'
11:17:38 <Deewiant> debug = ap (flip trace) show
11:17:39 <mmorrow> someone needs to herd t3h bots into this here channel
11:17:41 <Deewiant> I think
11:17:54 <sw17ch> @where botHerd
11:17:54 <noBotE> I know nothing about botherd.
11:18:00 <newsham> debug x = trace (show x) x
11:18:07 <mmorrow> @botsnack
11:18:07 <noBotE> :)
11:18:12 <mmorrow> > "unsafe"
11:18:13 <noBotE>  "unsafe"
11:18:19 <newsham> ?info
11:18:19 <noBotE> ()
11:18:21 <mmorrow> who's bot is that?
11:18:22 <newsham> ?about
11:18:22 <noBotE> Unknown command, try @list
11:18:26 <newsham> ?version
11:18:26 <noBotE> lambdabot 4.1
11:18:26 <noBotE> darcs get http://code.haskell.org/lambdabot
11:18:30 <sw17ch> ?faq can you be botherd for a botHerd?
11:18:30 <noBotE> The answer is: Yes! Haskell can do that.
11:18:30 <newsham> grrr..
11:18:36 <newsham> thats my bot.
11:18:38 <paczesiowa> @pl \a -> unsafePerformIO (print a >> return a)
11:18:38 <noBotE> unsafePerformIO . liftM2 (>>) print return
11:18:40 <mmorrow> ah, nice
11:18:51 <Deewiant> @pl \x -> trace (show x) x
11:18:51 <noBotE> trace =<< show
11:18:56 <Deewiant> >_<
11:19:00 <mmorrow> > unsafePerformIO (return ())
11:19:01 <noBotE>   Not in scope: `unsafePerformIO'
11:19:09 <mmorrow> what a nice error msg
11:19:20 <mmorrow> as opposed to
11:19:32 <Feuerbach> mmorrow: lambdabot is safe
11:19:37 <lilac> > runST . unsafeIOToST $ print "hello"
11:19:38 <mmorrow> unsafe function
11:19:38 <noBotE>      Inferred type is less polymorphic than expected
11:19:38 <noBotE>       Quantified type va...
11:20:07 <mmorrow> > unsafeIOToST (runST (print "HAI"))
11:20:08 <noBotE>  Couldn't match expected type `ST s a' against inferred type `IO ()'
11:20:09 <lilac> > runST . unsafeIOToST $ print "hello" :: ()
11:20:10 <noBotE>      Inferred type is less polymorphic than expected
11:20:10 <noBotE>       Quantified type va...
11:20:18 <mmorrow> > runST (unsafeIOToST (print "HAI"))
11:20:19 <noBotE>  ()
11:20:23 <mmorrow> ohnoess
11:20:25 <lilac> hehe
11:20:27 <lilac> old bug
11:20:41 <mmorrow> newsham, unimport unsafeIOToST !!!!!
11:21:07 <mmorrow> people are probably haXXxoring you as we speak in t3h private msgs
11:21:11 <lilac> > -- runST (unsafeIOToST (readFile "/etc/passwd"))
11:21:12 <noBotE>   parse error on input `}'
11:21:17 <paczesiowa> > runST (unsafeIOToST (readFile "/etc/passwd"))
11:21:34 <lilac> bah, at least i had the decency to comment it out ;-)
11:21:41 <mmorrow> heheh
11:21:48 <paczesiowa> decewhat? :)
11:22:02 <sw17ch> has any one dealt with solving polynomials in Haskell?
11:22:12 <sw17ch> i just had a new idea this morning, and i need to do some of that :)
11:22:15 <lilac> sw17ch: exactly or numerically?
11:22:19 <sw17ch> exactly
11:22:23 <Myoma> eek
11:22:24 <sw17ch> symbolic solvers
11:22:33 <Myoma> that doesn't sound - possible
11:22:34 <Myoma> is it?
11:22:43 <Deewiant> not in general
11:22:45 <lilac> for some polynomials, yes
11:22:45 <sw17ch> my TI-89 can do it :)
11:23:04 <Myoma> but just look how crazy the derivation for cubics is
11:23:17 <Myoma> I can't imagine a computer solving a 8 order one
11:23:19 <mmorrow> i hope noBotE comes back soon
11:23:22 <lilac> Myoma: there's a quartic equation too, but Galois proved there's no general equation for order > 4.
11:23:31 <lilac> Galois: what a dude
11:23:41 <newsham> > runST (unsafeIOToST (writeFile "/tmp/gotcha" "oops"))
11:23:42 <noBotE>   Not in scope: `unsafeIOToST'
11:23:46 <newsham> anything else?
11:23:52 <lilac> > unsafePerformIO (print "hello")
11:23:52 <noBotE>   Not in scope: `unsafePerformIO'
11:24:01 * sw17ch only wants to do simple stuff
11:24:04 <mmorrow> newsham: heh
11:24:08 <Myoma> sw17ch: do you have a site or something you're going to put this on eventually ? I want to bookmark
11:24:24 <mmorrow> newsham: i think that's the only known hole that seems to be open by default
11:24:29 <sw17ch> Myoma, i have a site... i have yet to actually start writing on it.. .:\
11:24:42 <sw17ch> i'll announce on haskell-cafe when i actually get this going
11:24:56 <sw17ch> (sw17ch == "vanenkj")
11:24:57 <lilac> sw17ch: http://mathworld.wolfram.com/QuarticEquation.html
11:24:57 <noBotE> Title: Quartic Equation -- from Wolfram MathWorld
11:25:38 <mmorrow> > runST (return ())
11:25:38 <noBotE>   Not in scope: `runST'
11:25:48 <mmorrow> aww
11:26:01 <mmorrow> you should be able to just hide unsafeIOToST
11:26:09 <mmorrow> afaik that's safe
11:26:15 <newsham> i dont need ST
11:26:19 <mmorrow> heh
11:26:22 <rwbarton> > Data.ByteString.Internal.inlinePerformIO (return 5)
11:26:23 <noBotE>   Not in scope: `Data.ByteString.Internal.inlinePerformIO'
11:26:39 <mmorrow> > atomically
11:26:40 <noBotE>   Not in scope: `atomically'
11:26:41 <newsham> ?type inlinePerformIO
11:26:42 <noBotE> Plugin `type' failed with: invalid ghci output: no type signature
11:26:45 <sw17ch> in general, i don't want to deal with solving exactly for x
11:26:46 <mmorrow> IO a -> a
11:27:18 <sw17ch> I have no interest (or very little) in [x^2 + 2x^3 = 4 => x?]
11:27:35 <dmhouse> Hrm, getting used to git is a lot harder than how I remember getting used to darcs.
11:28:17 <sw17ch> but [x^2 + xy^3 + 4 = y^4 => x?] is a little more interesting
11:28:20 <sw17ch> (completely contrived)
11:28:25 <mmorrow> > [|()|]
11:28:25 <noBotE>  Parse error at "|()|]" (column 2)
11:28:52 <paczesiowa> > Data.Array.Base.unsafeAt
11:28:53 <noBotE>   Not in scope: `Data.Array.Base.unsafeAt'
11:31:10 <mmorrow> > withCString
11:31:11 <noBotE>   Not in scope: `withCString'
11:31:30 <mmorrow> > nullPtr
11:31:31 <noBotE>   Not in scope: `nullPtr'
11:32:34 <mmorrow> it'd be really cool if there was some way to simulate doing IO safely (*any* IO, including unsafePerformIO and friends)
11:32:48 <selmanj> findIndices2d f x = map (snd) (filter (f . fst) (concatMap (\x -> zip (fst x) (zip [snd x,snd x..] [0..])) (zip x [0..])))
11:32:51 <mmorrow> you'd be "faking" the RealWorld somehow
11:32:58 <selmanj> YOU SEE WHAT HAPPENS LARRY?  YOU SEE WHAT HAPPENS WHEN YOU ASK A MAN TO THINK FUNCTIONALLY
11:33:02 * selmanj self-destructs
11:33:44 <mmorrow> @type let findIndices2d f x = map (snd) (filter (f . fst) (concatMap (\x -> zip (fst x) (zip [snd x,snd x..] [0..])) (zip x [0..]))) in findIndices2d
11:33:45 <noBotE> forall a b t. (Num b, Enum t, Num t, Enum b) => (a -> Bool) -> [[a]] -> [(b, t)]
11:34:13 <eu-prleu-peupeu> hey
11:34:20 <selmanj> that is my non-recursive version of http://hpaste.org/9941
11:34:27 <selmanj> and it is terrible
11:34:31 <selmanj> and i am a horrible person for writing that
11:34:44 <eu-prleu-peupeu> today a friend asked me what is the advantage of learning haskell :P
11:34:52 <eu-prleu-peupeu> i did not know what to answer him
11:35:02 <mmorrow> selmanj: heh
11:35:12 <eu-prleu-peupeu> is there any link that enumerates some of the advantages of it ? :/
11:35:18 <eu-prleu-peupeu> over C# or Java, for instance... ?
11:35:29 <selmanj> eu-prleu-peupeu: http://book.realworldhaskell.org/beta/whyfp.html
11:35:42 <rwbarton> @type let findIndices2d f = map snd . filter (f . fst) . concatMap (\x -> zip3 (fst x) (repeat $ snd x) [0..]) . (`zip` [0..])
11:35:42 <noBotE> Title: Chapter 1. Why functional programming? Why Haskell?
11:35:43 <noBotE> <no location info>:
11:35:43 <noBotE>     not an expression: `let findIndices2d f = map snd . filter (f . fst) . concatMap (\x -> zip3 (fst x) (repeat $ snd x) [0..]) . (`zip` [0..])'
11:35:47 <rwbarton> @type let findIndices2d f = map snd . filter (f . fst) . concatMap (\x -> zip3 (fst x) (repeat $ snd x) [0..]) . (`zip` [0..]) in findIndices2d
11:35:48 <noBotE>     Couldn't match expected type `(a, b)'
11:35:48 <noBotE>            against inferred type `(a1, b1, t)'
11:35:48 <noBotE>       Expected type: [([a1], b1)] -> [(a, b)]
11:36:06 <rwbarton> @type let findIndices2d f = map snd . filter (f . fst) . concatMap (\x -> zip (fst x) (zip (repeat $ snd x) [0..])) . (`zip` [0..]) in findIndices2d
11:36:07 <noBotE> forall a b t. (Enum b, Num b, Enum t, Num t) => (a -> Bool) -> [[a]] -> [(b, t)]
11:36:23 <gwern> mmorrow: iospec on hackage is IO without IO
11:36:32 * sw17ch actually wants a library capable of working with polynomials/algebra symbolically 
11:36:59 * selmanj heads out, needs time for brain to recover from that :(
11:37:18 <Myoma> sw17ch: what operations?
11:37:21 <tristes_tigres> hi
11:37:24 <mmorrow> gwern: interesting
11:37:28 <tristes_tigres> @seen e-int
11:37:28 <noBotE> I haven't seen e-int.
11:37:29 * mmorrow looks
11:37:30 <Myoma> you can start, public class Polynomial {
11:38:00 <sw17ch> Myoma, your scary java/c# syntax angers me
11:38:05 <Myoma> :p
11:38:19 * Myoma has been writing some java today ...
11:38:25 <sw17ch> Myoma, I want to reproduce the capabilites of my TI-89... since i'm constantly losing it
11:38:39 <Myoma> I don't know what TI-89 does but it sounds like a cool project
11:39:06 <Olathe> It's a programmable calculator.
11:39:28 <Olathe> sw17ch: It might be better to just get a CAS.
11:39:36 <sw17ch> Olathe, CAS?
11:39:44 * tristes_tigres wants ghci prompt on his Nokia
11:39:47 <Olathe> sw17ch: A program that can do algebra and calculus and so on.
11:39:56 <Myoma> yeah Maxima probably does everything TI-89 does ...
11:40:06 <sw17ch> yes, Maxima does...
11:40:08 <Myoma> Maxima wish TeX is great
11:40:19 <sw17ch> in this case, it's something i'd like a library to do some of it for me :)
11:40:25 <Olathe> Ahh.
11:40:44 <sw17ch> it's going to be "evolving" polynomials which are going to be used to generate soemthing else
11:41:29 * sw17ch has always had an interest in digital evolution... wants to use an analog system to generate a digital program... try and mimic the physical/informatical laws found in biology
11:41:30 <Myoma> Maxima is a programming language
11:41:33 <lilac> > let findIndices2d p = map (second fst) . filter (\(x,(y,z)) -> p z) . concat . zipWith (zip . repeat) [1..] . map (zip [1..]) in findIndices2d (>= 0) [[-1,0,1],[-2,-1,2],[1,-1,1]]
11:41:34 <noBotE>  [(1,2),(1,3),(2,3),(3,1),(3,3)]
11:41:39 <Myoma> actually it's just lisp with funny syntax
11:42:02 <Olathe> > extend [1, 2, 3]
11:42:03 <noBotE>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:42:16 <sw17ch> @src extend
11:42:16 <noBotE> Source not found. You type like i drive.
11:42:18 <Olathe> > extend [1, 4, 9, 16]
11:42:19 <noBotE>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
11:42:29 <lilac> > extend [2, 3, 5, 7, 11, 13]
11:42:30 <noBotE>  [2,3,5,7,11,13,-6,-89,-312,-793,-1701,-3265,-5783,-9631,-15272,-23265,-34274...
11:42:39 <sw17ch> woa
11:42:42 <Myoma> Olathe: @src extend ?
11:42:43 <lilac> i KENW it
11:42:45 <Olathe> let tower = foldl' (flip $ scanl (+)) (repeat 0); untower = untower' 256; untower' limit = reverse . map head . takeWhile (not . all (0==) . take limit) . iterate (\xs -> zipWith (-) (tail xs) xs); extend = tower . untower; extended = ap (ap drop . (extend .) . flip take) length
11:42:51 <Olathe> There's the source.
11:43:06 <Myoma> oh ...
11:43:12 <Myoma> that didn't help me understand it
11:43:15 <sw17ch> :)
11:43:17 <newsham> ?let (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...)
11:43:18 <noBotE> Defined.
11:43:26 <Olathe> It makes a polynomial and uses that.
11:43:26 <newsham> ([1,4,9]...)
11:43:29 <newsham> > ([1,4,9]...)
11:43:30 <noBotE>  [1,4,9Exception: <local>:8:0-53: Non-exhaustive patterns in function ...
11:43:37 <newsham> oops
11:43:45 <Olathe> Well, that's effectively what it does.
11:43:51 <lilac> we used to have an OEIS lookup here somewhere
11:43:52 <dmhouse> Woah, what?
11:43:53 <newsham> ?undef
11:43:54 <noBotE> Undefined.
11:44:02 <dmhouse> What magic is ?let?
11:44:02 <newsham> ?let (...) [x] = repeat x; (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...)
11:44:03 <noBotE> Defined.
11:44:07 <newsham> > ([1,4,9]...)
11:44:08 <noBotE>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
11:44:15 <Olathe> O-o
11:44:19 <dmhouse> Heh, oh.
11:44:29 <dmhouse> I just managed to parse that.
11:44:34 <Olathe> > ([2,3,5,7,11,13]...)
11:44:35 <noBotE>  [2,3,5,7,11,13,-6,-89,-312,-793,-1701,-3265,-5783,-9631,-15272,-23265,-34274...
11:44:35 <newsham> courtesy of rwbarton.
11:45:15 <Olathe> Is it in lambdabot ?
11:45:26 <dmhouse> Olathe: newsham just ?let it
11:45:31 <Olathe> Oh, OK.
11:45:37 <Myoma> cool
11:45:38 <sw17ch> ([1,1]...)
11:45:39 <Olathe> Ahh, that's cool.
11:45:42 <Myoma> > ([1,2,4]...)
11:45:43 <noBotE>  [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,2...
11:45:51 <Myoma> > ([1,2,1]...)
11:45:52 <noBotE>  [1,2,1,-2,-7,-14,-23,-34,-47,-62,-79,-98,-119,-142,-167,-194,-223,-254,-287,...
11:46:04 <newsham> babbage's engine comes to irc
11:46:13 <Myoma> > ([0,1,999999]...)
11:46:14 <noBotE>  [0,1,999999,2999994,5999986,9999975,14999961,20999944,27999924,35999901,4499...
11:46:58 <newsham> > ((map sqrt [1..5]) ...)
11:46:59 <noBotE>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.4297801513...
11:47:37 <Olathe> > map ((take 4).show) ((map sqrt [1..5]) ...)
11:47:38 <newsham> > (((map sqrt [1..5]) ...) !! 6) - sqrt 6
11:47:38 <noBotE>  ["1.0","1.41","1.73","2.0","2.23","2.42","2.54","2.50","2.22","1.57","0.40",...
11:47:39 <noBotE>  9.269076335885984e-2
11:48:52 <newsham> > unwords $ intersperse ", " $ map ((take 4).show) ((map sqrt [1..5]) ...)
11:48:53 <noBotE>  "1.0 ,  1.41 ,  1.73 ,  2.0 ,  2.23 ,  2.42 ,  2.54 ,  2.50 ,  2.22 ,  1.57 ...
11:49:11 <newsham> > concat $ intersperse ", " $ map ((take 4).show) ((map sqrt [1..5]) ...)
11:49:12 <noBotE>  "1.0, 1.41, 1.73, 2.0, 2.23, 2.42, 2.54, 2.50, 2.22, 1.57, 0.40, -1.4, -4.2,...
11:50:08 <Olathe> > concat $ intersperse "," $ map ((take 4).show) ((map sqrt [1..5]) ...)
11:50:09 <noBotE>  "1.0,1.41,1.73,2.0,2.23,2.42,2.54,2.50,2.22,1.57,0.40,-1.4,-4.2,-8.2,-13.,-2...
11:50:12 <Olathe> Neat :)
11:50:43 <|Steve|> :t (...)
11:50:44 <noBotE> forall a. (Num a) => [a] -> [a]
11:51:40 <Deewiant> > ([0,1,1,2,3,5,8,13]...)
11:51:42 <noBotE>  [0,1,1,2,3,5,8,13,42,189,715,2200,5765,13377,28250,55355,102052,178857,30035...
11:52:07 <Myoma> > ([0,1,2]...)
11:52:08 <noBotE>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:52:11 <Myoma> > ([0,1,2,3,4,5,6]...)
11:52:12 <noBotE>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:52:15 <Olathe> Polynomials only go so far.
11:52:15 <Myoma> > ([0,1,2,3,4,5,6,24354537]...)
11:52:17 <noBotE>  [0,1,2,3,4,5,6,24354537,194836248,876763089,2922543610,8036994911,1928878777...
11:52:33 <int-e> > ([1,2,4,8,16,32,64]...)
11:52:34 <noBotE>  [1,2,4,8,16,32,64,127,247,466,848,1486,2510,4096,6476,9949,14893,21778,31180...
11:52:35 <Myoma> > ([0,1,0,1,0,1,0,1,0,1,0,1,0]...)
11:52:36 <noBotE>  [0,1,0,1,0,1,0,1,0,1,0,1,0,-4095,-49152,-323583,-1540096,-5914623,-19431424,...
11:52:41 <int-e> hehe
11:52:48 <Olathe> I think finding the expression that has the shortest representation would be better, but slower
11:52:52 <newsham> "Polynomials only go so far"  nah, they go on forever :)
11:52:58 <Olathe> Heheh.
11:52:58 <Deewiant> > ([0,1]...)
11:52:59 <noBotE>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:53:26 <int-e> > ([0,0,1,1,2,2]...)
11:53:27 <noBotE>  [0,0,1,1,2,2,-13,-77,-252,-636,-1371,-2651,-4730,-7930,-12649,-19369,-28664,...
11:53:40 <Olathe> > ((map (\x -> 4*x^3 + 3*x^2 + 2*x + 1) [1..2])...)
11:53:41 <noBotE>  [10,49,88,127,166,205,244,283,322,361,400,439,478,517,556,595,634,673,712,75...
11:53:52 <Olathe> > (map (\x -> 4*x^3 + 3*x^2 + 2*x + 1) [1..])
11:53:53 <noBotE>  [10,49,142,313,586,985,1534,2257,3178,4321,5710,7369,9322,11593,14206,17185,...
11:53:57 <dmead> > map (1+) [2..20]
11:53:58 <noBotE>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
11:54:02 <Olathe> > ((map (\x -> 4*x^3 + 3*x^2 + 2*x + 1) [1..4])...)
11:54:03 <noBotE>  [10,49,142,313,586,985,1534,2257,3178,4321,5710,7369,9322,11593,14206,17185,...
11:54:14 <Olathe> > ((map (\x -> 4*x^3 + 3*x^2 + 2*x + 1) [1..3])...)
11:54:16 <noBotE>  [10,49,142,289,490,745,1054,1417,1834,2305,2830,3409,4042,4729,5470,6265,711...
11:54:17 <mmorrow> gwern: IOSpec is pretty interesting
11:56:33 <dsrogers> mmorrow-p
11:57:22 <Olathe> > [0,0..]
11:57:23 <noBotE>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
11:57:50 <mmorrow> dsrogers: yo. fell asleep last night ...
11:57:57 <Olathe> > [0, 1, 4, 9..]
11:57:57 <noBotE>  Parse error at "..]" (column 12)
11:58:03 <mmorrow> dsrogers: any interesting TH happenings?
11:58:03 <Olathe> I wish that worked.
11:58:27 <dsrogers> 'sok.
11:58:31 <dsrogers> did you catch my link?
11:58:50 <mmorrow> oh, i must have missed it
11:59:20 * mmorrow looks in the logs
12:00:37 <dsrogers> http://phasevelocity.org/thtest.tgz
12:00:43 <dsrogers> sorry, I'm actually at work.
12:01:03 * mmorrow wgets
12:01:08 <dsrogers> which means my #haskell thread has to sleep a lot.
12:01:17 <dsrogers> just type make.
12:01:23 <mmorrow> cool
12:01:25 <dsrogers> the result will hopefully be obvious
12:01:29 <mmorrow> heh
12:01:52 <mmorrow> ha, nice.
12:02:54 <mmorrow> wow, that gives me tons of ideas (as in "whoa crap i think i have a great idea, but i'm just not sure what it is yet")
12:03:01 <dsrogers> lol
12:03:04 <mmorrow> ha
12:03:09 <tristes_tigres> mmorrow: Hi, did you notice Control.Exception has stuff for FP exceptions ?
12:03:17 <dsrogers> yeah, it's more of a proof of concept more than anything
12:03:30 <dsrogers> but definately something to build on.
12:04:04 <dsrogers> THDebug is extremely useful.  I sprinkle my TH code with print statements that show me what the hell is going on during compile.
12:04:12 <mmorrow> tristes_tigres: hmm. now that you explicitly mention that, i did know that. But i only recall they exist because you just brought it up ...
12:05:32 <mmorrow> dsrogers: definitely. that makes me think of some sort of organized system that allows you to do transformations/whatever of your code at compile time. so no preprocessor, no source filter, etc. i'm not sure of the details though.
12:05:46 <tristes_tigres> in principle, one may implement FP flags with exceptions, although it is not necessariily the right way
12:06:16 <dsrogers> mmorrow: I was wondering if getArgs will work within runIO.  Work in the sense that I wonder if I could see ghc command line arguments and use that to do conditional stuff.
12:06:42 <dsrogers> like reading out a -DTHDEBUG flag and usnig that to conditionally print debug statements
12:06:47 <dsrogers> I haven't tried it yet.
12:06:57 <mmorrow> tristes_tigres: is there one "right way", or is it context-dependent? one thing about exceptions is they'll get buried in thunks of pure code, then explode at some later time when you happen to eval that thunk
12:07:36 <mmorrow> dsrogers: whoa, nice idea. i think you can. i'll get the link ...
12:07:58 <tristes_tigres> mmorrow:of course there is no the right way, it's just that someone said that FP flags can be dispeced with because we got exceptions
12:08:19 <mmorrow> tristes_tigres: heh
12:08:54 <sw17ch> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen
12:09:05 <sw17ch> I'm assuming those enhancements will be in 6.10?
12:09:07 <noBotE> Title: Commentary/Compiler/IntegratedCodeGen - GHC - Trac, http://tinyurl.com/6g4fqb
12:09:10 <mmorrow> tristes_tigres: i think the game is, whoever thinks of the best way to do it wins, and by wins i mean that's how haskell'll do it :)
12:09:22 <tristes_tigres> mmorrow: what I wanted to try but did not yet got around to is to test your rounding mode code together with Control.Concurrent
12:09:33 <tristes_tigres> differnet modes in differen threads
12:09:44 <tristes_tigres> how would that play tgether
12:09:46 <mmorrow> tristes_tigres: ooh, interesting. i'd love to see those results
12:10:31 <mmorrow> tristes_tigres: i haven't had much time since writing to experiment, been swamped with a project. luckily it's wrapping up.
12:11:16 <mmorrow> dsrogers: i think this might do it. especially since GHC itself is running in the Haskell runtime. http://darcs.haskell.org/libraries/base/GHC/Environment.hs
12:12:39 <dsrogers> ah.
12:12:48 * mmorrow is trying it now ...
12:15:39 <mmorrow> haha oh snap
12:15:41 <mmorrow> it works
12:16:06 <dcoutts> davidL: you about? I'm wondering if we can improve the error message about dep conflicts to make them easier to understand the cause and solutions.
12:16:21 <dsrogers> nifty!
12:16:23 <mmorrow> http://hpaste.org/9943
12:16:53 <davidL> dcoutts: I'm here
12:17:32 <dcoutts> davidL: can you still reproduce the problem? if so could you hpaste it, including the command you used
12:17:44 <dcoutts> davidL: -v will help too
12:17:47 <mmorrow> dsrogers: this means that programs can now keep track of what args they were built with for free
12:17:58 <dcoutts> davidL: at least it'll help me :-)
12:18:09 <dcoutts> since I know what the algorithm is doing
12:18:10 <dsrogers> mmorrow: yes, but you still have to find a way to sneak additional arguments into ghc.
12:18:23 <dsrogers> mmorrow: because your TH program may need flags.
12:18:30 <davidL> dcoutts: sure. just a sec
12:18:42 <dsrogers> does ghc understand -D?
12:18:50 <dsrogers> I that was just a guess before, but that would be sufficient
12:19:08 <dcoutts> dsrogers: yep
12:19:16 <mmorrow> dsrogers: i've thought about something slightly similar to that. so, say you want to (in TH code) transform non-TH code that's currently being compiled at compile time.
12:19:17 <dsrogers> nifty
12:19:37 <mmorrow> there's no way to get ghc to restart or whatever
12:19:38 <mmorrow> but
12:20:52 <mmorrow> you could use System.Process to start *another* ghc process which you feed the transformed code, and *that* ghc compiles it to completion, then you just error out the ghc you're sitting in
12:21:02 <dsrogers> lol
12:21:05 <mmorrow> haha
12:21:13 <mmorrow> that'd work for args too!
12:21:42 <dsrogers> you'd probably just use the ghc api
12:21:51 <mmorrow> yeah, or that :(
12:21:57 <davidL> dcoutts: http://hpaste.org/9944
12:21:59 <olsner> oh, how wonderfully evil this sounds :D
12:22:00 <mmorrow> heh, actually i hadn't though of that
12:22:11 <mmorrow> hmm
12:22:20 <mmorrow> ok, be back later
12:22:22 <dsrogers> but erroring out GHC would cause --make to break, but you could still use a Makefile
12:22:31 <mmorrow> dsrogers: ahh, very true
12:22:52 <mmorrow> maybe you could replace the proc you're in with the new ghc ?
12:22:58 <mmorrow> similar the exec in bash
12:23:02 <dsrogers> oh, sure.
12:23:18 <mmorrow> heh, actually you could literally use system "exec ghc ....."
12:23:18 <dsrogers> just call exec somehow and bootstrap ghc in it.
12:23:23 <dsrogers> yep
12:23:27 <mmorrow> nice!
12:23:34 <dsrogers> well as long as system doesn't use a subshell.
12:23:38 <dsrogers> which it probably does.
12:23:57 <mmorrow> hmm, how would that mess stuff up?
12:24:05 <mmorrow> (not that it wouldn't, i just don't know how)
12:24:14 <dsrogers> because then the subshell is the process that gets execed
12:24:22 <dsrogers> not the process that spawned the subshell
12:24:28 <mmorrow> oh, i see.
12:24:42 <gwern> 'A novice came to Jacques Garrigue and spoke nervously: "I don't get rank-2 polymorphism. What is it good for? When to use it? How can I understand it?". Jacques asked: "Do you want an answer to each question, or the answer to all your questions?." The novice was enlightened.'
12:24:51 <mmorrow> hmm, i'm sure there's a way.
12:24:56 <dsrogers> sure.
12:25:25 <dsrogers> forgien unsafe "execve" [String]-> IO ()
12:25:31 <dsrogers> it's just that execve will never return
12:26:02 <dcoutts> davidL: so the problem is that what you're installing requires the ghc package, and the ghc package is already compiled and cannot be recompiled. Dependencies of installed packages are precise, they need the exact version they were built against. So that's why ghc needs that version.
12:26:13 <olsner> so, forkIO it?
12:26:31 <dsrogers> olsner: actually that's what we want.
12:26:45 <dsrogers> olsner: we're trying to restart ghc after a source transformation
12:26:58 <davidL> dcoutts: so I'd need to rebuild all those packages with the newer bytestring hidden?
12:27:01 <dcoutts> davidL: what's not quite clear is if one of the other packages really needs some different version of bytestring, or if the search procedure is just doing things in a foolish order.
12:27:09 <mmorrow> it seems like this situation is similar to that with continuations. you just have to figure out how to invert control. so suck the whole make process up into a continuation somehow, then call that continuation on the new ghc ("something ""like"" that")
12:27:34 <Cale> ~bot
12:27:36 <Cale> @bot
12:27:37 <noBotE> :)
12:27:38 <dcoutts> davidL: it's not really to do with rebuilding, cabal's dep planning doesn't really care that much about what you've got installed.
12:27:57 <dcoutts> davidL: the thing is to get the planning procedure to come up with a solution.
12:28:15 <dcoutts> davidL: so it's clear that we do need exactly ==0.9.0.1 because that's what ghc needs.
12:28:34 <newsham> ?bot
12:28:34 <noBotE> :)
12:28:41 <lambdabot> :)
12:29:18 <dcoutts> davidL: oh, you're building the thing in the current dir.
12:29:28 <davidL> dcoutts: yup
12:29:37 <olsner> @quote modular.love.units
12:29:43 <lambdabot> kealyow says: can you make a macro that builds the expression accoridng to those MODULAR LOVE UNITS??
12:30:41 <dcoutts> davidL: what is it you're building ooi?
12:30:55 <davidL> dcoutts: lambdabot
12:31:23 <dcoutts> davidL: see normally if we wanted to influence the dep solver we'd say cabal install -v --dry-run lambdabot bytestring-0.9.0.1
12:32:00 <dcoutts> davidL: it wouldn't bother to actually rebuild bytestring-0.9.0.1 if that were already installed, but it'd constrain the dep solver to use only that version.
12:32:17 <gwern> davidL: how is the build going?
12:32:23 <dcoutts> davidL: really we should be using --constraint= for that purpose, but I've not implemented that yet.
12:32:51 <gwern> davidL: incidentally, I'll bet your bytestring dep is coming by way of mueval; if you've already installed mueval, you can remvoe that dep
12:32:54 <gwern> lambdabot doesn't actually link in anything from mueval'
12:33:19 <gwern> (this lets you profile lambdabot as well since cabal no longer makes an issue over the GHC API not being profiled)
12:33:31 <gwern> dcoutts: actually, this is an annoying part of cabal deps
12:33:42 <dcoutts> gwern: what is exactly?
12:33:52 <dcoutts> the lack of cabal install --constraint= ?
12:34:23 <gwern> dcoutts: even if we don't actually use anything from a depended upon library, we still suffer the disadvantages of its lack of profiling and deps
12:34:43 <gwern> no, I think that's different
12:35:19 <dcoutts> gwern: you only need profiling versions of things you actually import modules from.
12:35:28 <dcoutts> gwern: though that's a pretty odd corner case
12:35:50 <dcoutts> since there's no point in depending on a package you import nothing from
12:36:04 <gwern> well, it'd mostly go away if runtime deps were expressible
12:36:16 <dcoutts> ahh, that's what you're after
12:37:18 <binarybandit> Hey #haskell, I can't for the life of me figure out why http://pastie.textmate.org/private/iwsur48u08w9ib5ougnqjw won't work. :(
12:37:23 <lambdabot> Title: Private Paste - Pastie
12:37:53 <Myoma> because of the type of head
12:38:15 <Myoma> maybe you meant tail instead ?
12:38:24 <gwern> head . snd?
12:38:33 <gwern> :t head . snd
12:38:35 <lambdabot> forall a a1. (a1, [a]) -> a
12:38:36 <davidL> gwern: heh, removing mueval from the dependency list worked
12:40:17 <gwern> davidL: I is not surprised.
12:40:35 <dcoutts> because that drops the dep on ghc
12:40:59 <gwern> yup. by way of mueval, by way of hint
12:41:01 <dcoutts> what I'm slightly confused by, is what other package required the later version of bytestring
12:41:34 <davidL> had to touch a bunch of files in State/ but then it built fine :)
12:41:37 <dcoutts> I wonder if it was lambdabot-utils-4.2
12:41:45 <BMeph> :t break
12:41:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:42:23 <gwern> dcoutts: possibly. it'd use the latest bytestring, wouldn't it? and it'd then be linked into lambdabot proper
12:42:28 <dcoutts> davidL: if cabal has to pick installed versions of stuff then the constraints are much tighter than if it knows that it could rebuild the package if necessary
12:42:49 <BMeph> fst res :: [[a]], snd res :: [[a]], head (snd res) :: [a]
12:43:11 <dcoutts> so if you're working with local packages that are not on hackage then cabal doesn't know that it can rebuild them
12:43:30 <dcoutts> gwern, davidL: so how could we improve that message to be more useful
12:43:59 <dcoutts> perhaps we should note which exact deps are caused by deps of installed things
12:44:38 <trofi> dcoutts: would be great if cabal-install showed inferred dependency tree with package versions by `-v' option
12:44:50 <dcoutts> trofi: unfortunately it's not a tree
12:45:00 <trofi> forest:]
12:45:05 <dcoutts> it's a graph
12:45:11 <dcoutts> with constraints on edges
12:45:23 <dcoutts> and it's only a graph when you pick a solution (or non-solution)
12:45:54 <dcoutts> and to explain problems you need to talk about decisions you could have made earlier
12:47:09 <gwern> dcoutts: yeah, I think better would be: 'forcing dependency on bytestring==foo because of mueval; forcing dep on bar because of baz'.. etc
12:49:10 <gwern> hm
12:49:42 <gwern> dcoutts: did recent cabal versions fix the profiling/import thing you mentioned? I'd've sworn I couldn't compile lambdabot with profiling jus a few days ago
12:50:02 <dcoutts> gwern: no changes in that area
12:51:32 <Minicity> salut
12:51:39 <Minicity> who wants fai one 4v4 they take his waiter?
12:51:55 <Minicity> who wants fai one 4v4 they take his waiter?
12:52:00 <Minicity> who wants fai one 4v4 they take his waiter?
12:52:54 --- mode: ChanServ set +o dons
12:52:54 --- mode: ChanServ set +o dmhouse
12:52:55 --- mode: dons set +b *!*n=mitar@druga.org
12:52:56 --- kick: Mitar was kicked by dons (dons)
12:53:04 <dons> grr
12:53:05 --- mode: dmhouse set -o dmhouse
12:53:06 <dobblego> woops :)
12:53:13 --- mode: dons set -b *!*n=mitar@druga.org
12:53:16 --- mode: ChanServ set -o dons
12:53:20 <dons> tab complete too fast.
12:58:39 <geezusfreeek> is the hackage server being pounded really hard right now or something?
12:58:56 <conal> how do i get authorized to create a mailing list on haskell.org?
13:01:02 <dmead> is there a way to programatically tell ghc to change it's working directory?
13:01:41 <dmhouse> dmead: GHCi? Or GHC?
13:01:47 <dmhouse> In the former it's :cd
13:01:58 <BMeph> Where can I get an "Immutable State" sweat-shirt? ;)
13:02:10 <dmhouse> Oh, programmatically. Then you probably meant GHC, never mind :)
13:02:54 <EvilTerran> ?hoogle setCurrentDirectory
13:02:55 <lambdabot> System.Directory setCurrentDirectory :: FilePath -> IO ()
13:03:01 <EvilTerran> dmhouse, like that ^
13:03:13 <dmhouse> dmead: use setCurrentDirectory.
13:03:32 <EvilTerran> er, dmead, yes
13:03:48 <EvilTerran> <.<  >.>
13:04:09 <EvilTerran> ?faq could I write an IRC client in haskell that'd never get the tab completion wrong?
13:04:10 <lambdabot> The answer is: Yes! Haskell can do that.
13:04:17 <dmead> well it's ghci but i have a whole patch of files i need to process
13:04:22 <dmead> *batch
13:04:30 <EvilTerran> dmead, "process"?
13:04:45 <dmead> yea
13:04:54 <dmead> all sorts of numbers in files
13:05:05 <EvilTerran> ah, non-haskell files?
13:05:08 <dmead> yea
13:05:10 <dmead> text files
13:05:33 <EvilTerran> <dmhouse> In [ghci] it's :cd
13:05:48 <dmead> yea but i need to do it from code
13:05:50 * gwern begins writing a screenplay for a anime. 'λ in the Shell: Immutable State Society'
13:05:58 <dmead> lol
13:06:00 <EvilTerran> then it's System.Directory.setCurrentDirectory
13:06:06 <dmead> ah
13:06:10 <dmead> EvilTerran++
13:06:13 <EvilTerran> there's other interesting stuff in that module too :)
13:06:38 <gwern> yes, I found System.Directory useful in lambdabot
13:07:20 <dmead> :t System.Directory.setCurrentDirectory
13:07:22 <lambdabot> FilePath -> IO ()
13:07:29 <dmead> rog
13:12:19 <skorpan> ~(a, s') <- runStateT m s
13:12:20 <skorpan> what does ~ mean?
13:12:40 <BONUS> irrefutable patterns
13:12:45 <sjanssen> skorpan: it is an irrefutable (lazy) pattern match
13:12:48 <BONUS> it means that its sort of a lazy pattern
13:12:58 <BONUS> that pattern can never fail
13:13:00 <BONUS> but it's lazy
13:13:31 <skorpan> hm, i see
13:13:40 <trofi> > let ~a = undefined in 0
13:13:42 <lambdabot>  0
13:13:48 <trofi> > let a = undefined in 0
13:13:49 <lambdabot>  0
13:14:07 <bd_> > let (a,b) = undefined in 0
13:14:08 <lambdabot>  0
13:14:10 <bd_> > let ~(a,b) = undefined in 0
13:14:11 <lambdabot>  0
13:14:14 <bd_> hmmm
13:14:16 <bd_> interesting
13:14:19 <BONUS> let f ~a = 2 in f undefined
13:14:24 <BONUS> > let f ~a = 2 in f undefined
13:14:25 <lambdabot>  2
13:14:29 <bd_> > let f (a, b) = 0 in f undefined
13:14:30 <lambdabot>  mueval: *** Exception: Prelude.undefined
13:14:31 <bd_> > let f ~(a, b) = 0 in f undefined
13:14:33 <lambdabot>  0
13:14:34 <BONUS> > let f a = 2 in f undefined
13:14:35 <bd_> ^^^ there you go
13:14:36 <lambdabot>  2
13:14:39 <BONUS> ugh
13:14:39 <BONUS> ah
13:14:45 <bd_> binding to a variable isn't enough to make it strict on that variable
13:14:47 <Cale> Matching against a pattern which has ~ applied to it does not cause immediate evaluation. Instead, when one of the matched variables is evaluated, the pattern is matched. (And if it doesn't really match at that point a runtime exception occurs)
13:15:03 <sjanssen> BONUS: "~a" == "a"
13:15:04 <BONUS> aha
13:15:09 <BONUS> yeah lol
13:15:10 <BONUS> actually
13:15:19 <BONUS> how silly of me
13:15:25 <trofi> > let !a = undefined in 0
13:15:26 <lambdabot>  Parse error at "!a" (column 5)
13:15:28 <Cale> > let ~(x:xs) = [] in x
13:15:30 <lambdabot>  mueval: *** Exception: /tmp/9140633996513359148:59:38-49: Irrefutable patter...
13:15:34 <Cale> heh
13:15:36 <sjanssen> > let f ~True = "success" in f False
13:15:38 <lambdabot>  "success"
13:15:40 <sjanssen> > let f True = "success" in f False
13:15:42 <Olathe> BONUS: (insert question for bonus points here)
13:15:42 <lambdabot>  mueval: "*** Exception: /tmp/7500882734949594350:59:38-55: Non-exhaustive pa...
13:15:52 <Cale> That's not a very pretty error message...
13:16:09 <Cale> I should update, I think gwern has updated some things...
13:17:01 <rwbarton> > show undefined
13:17:03 <lambdabot>  mueval: "*** Exception: Prelude.undefined
13:17:17 <BONUS> haha
13:17:31 <dmead> hah
13:17:44 <dmead> setCurrentDirectory puts my other modules out of scope from ghci
13:17:49 <dmead> that should probably be correct :S
13:17:56 <dmead> *corrected
13:18:16 <dmead> one would think the working directory of the running code would be different from the actual ghci session
13:19:37 <Trinithis> @seen lambdabot
13:19:37 <lambdabot> Yes, I'm here. I'm in #darcs-theory, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #japanese, #not-##freebsd, #haskell_ru, #haskell.se, #haskell.ru, #
13:19:38 <lambdabot> haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #
13:19:38 <lambdabot> haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
13:19:42 <Toxaris> dmead: I don't think ghci works that way
13:20:04 <Toxaris> It's more like a plugin shell then a debugger.
13:20:50 <dmead> ah
13:20:53 <Toxaris> so I guess the module search path should be decoupled from the current directory
13:21:01 <dmead> yea
13:21:04 <dmead> thats what i'm saying
13:21:36 <Toxaris> but the current directory of the ghci process would still be the current directory of the running code
13:21:43 <Toxaris> ghci would just not use it :)
13:22:15 <Toxaris> from the ghc api "documentation", I understand that you can do crazy things by using the ghc api from ghci
13:22:44 <Beelsebob> dons: you about?
13:25:25 <newsham> ?oeis 1,4,9
13:25:30 <lambdabot> The squares: a(n) = n^2.
13:25:30 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
13:27:17 <Trinithis> ?oeis 1,3,3,7
13:27:18 <lambdabot> Sigma(phi(n)).
13:27:18 <lambdabot> [1,1,3,3,7,3,12,7,12,7,18,7,28,12,15,15,31,12,39,15,28,18,36,15,42,28,39,28,5...
13:27:30 <dmhouse> ?help oeis
13:27:31 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
13:27:37 <Olathe> @oeis 8,0,0,8,1,3,5
13:27:37 <lambdabot> Sequence not found.
13:27:38 <Trinithis> ?oeis 1337
13:27:39 <lambdabot> List of codewords in binary lexicode with Hamming distance 4 written as decim...
13:27:39 <lambdabot> [0,15,51,60,85,90,102,105,150,153,165,170,195,204,240,255,771,780,816,831,854...
13:27:47 <trofi> ?oeis 0,-1,-2,-3,-4
13:27:48 <lambdabot> floor(n/10) - n mod 10.
13:27:49 <lambdabot> [0,1,2,3,4,5,6,7,8,9,1,0,1,2,3,4,5,6,7,8,2,1,0,1,2,3,4,5,6,7,3,2,1,0,1,2,3,4,...
13:28:09 <Olathe> So, negative signs are ignored ?
13:29:03 <tromp> ?oeis 0,1,-2,3
13:29:03 <lambdabot> Difference between n^2 and average of smallest prime greater than n^2 and lar...
13:29:04 <lambdabot> [0,0,1,1,2,1,0,0,1,1,0,1,1,0,2,1,0,2,1,0,1,3,2,0,1,1,4,5,3,1,2,0,2,1,2,1,1,4,...
13:30:00 <mrsolo> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen wow..woot!
13:30:08 <lambdabot> Title: Commentary/Compiler/IntegratedCodeGen - GHC - Trac, http://tinyurl.com/6g4fqb
13:30:34 <Trinithis> :t followedBy
13:30:36 <lambdabot> Not in scope: `followedBy'
13:32:30 <Trinithis> :t lookAhead
13:32:32 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
13:33:08 <Trinithis> :t lookAhead >>> (==' ')
13:33:11 <lambdabot>     Couldn't match expected type `Text.Parsec.Prim.ParsecT s u m a'
13:33:11 <lambdabot>            against inferred type `Char'
13:33:11 <lambdabot>     In the second argument of `(==)', namely ' '
13:33:23 <Trinithis> :t (==' ') . lookAhead
13:33:24 <lambdabot>     Couldn't match expected type `Char'
13:33:25 <lambdabot>            against inferred type `Text.Parsec.Prim.ParsecT s u m a'
13:33:25 <lambdabot>       Expected type: Text.Parsec.Prim.ParsecT s u m a -> Char
13:33:43 <Myoma> :t char ' '
13:33:44 <lambdabot>     Ambiguous occurrence `char'
13:33:45 <lambdabot>     It could refer to either `Text.PrettyPrint.HughesPJ.char', imported from Text.PrettyPrint.HughesPJ at State/L.hs:56:0-46
13:33:45 <lambdabot>                           or `Text.ParserCombinators.Parsec.char', imported from Text.ParserCombinators.Parsec
13:33:53 <Myoma> :t Text.ParserCombinators.Parsec.char ' '
13:33:54 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Text.Parsec.Prim.ParsecT s u m Char
13:33:55 <Trinithis> :t (==' ') . lookAhead (char ' ')
13:33:57 <lambdabot>     Ambiguous occurrence `char'
13:33:57 <lambdabot>     It could refer to either `Text.PrettyPrint.HughesPJ.char', imported from Text.PrettyPrint.HughesPJ at State/L.hs:56:0-46
13:33:57 <lambdabot>                           or `Text.ParserCombinators.Parsec.char', imported from Text.ParserCombinators.Parsec
13:33:58 <Myoma> :t lookAhead (Text.ParserCombinators.Parsec.char ' ')
13:33:59 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Text.Parsec.Prim.ParsecT s u m Char
13:34:11 <Myoma> :t parse (lookAhead (Text.ParserCombinators.Parsec.char ' '))
13:34:13 <lambdabot> forall s. (Text.Parsec.Prim.Stream s Identity Char) => SourceName -> s -> Either ParseError Char
13:34:21 <Myoma> :t parse (lookAhead (Text.ParserCombinators.Parsec.char ' ')) [] "   foo   "
13:34:23 <lambdabot> Either ParseError Char
13:34:27 <Myoma> > parse (lookAhead (Text.ParserCombinators.Parsec.char ' ')) [] "   foo   "
13:34:28 <lambdabot> Terminated
13:34:31 <Myoma> > parse (lookAhead (Text.ParserCombinators.Parsec.char ' ')) [] "   foo   "
13:34:33 <lambdabot> Terminated
13:34:35 <Myoma> rubbish
13:35:31 <Trinithis> :t (== ' ') . lookAhead anyChar
13:35:32 <lambdabot>     Couldn't match expected type `a -> Char'
13:35:33 <lambdabot>            against inferred type `Text.Parsec.Prim.ParsecT s u m Char'
13:35:33 <lambdabot>     In the second argument of `(.)', namely `lookAhead anyChar'
13:35:59 <Myoma> what are you doing with ==?
13:36:15 <Trinithis> I want to create a followedBy combinator
13:36:30 <Trinithis> to make sure a token ends with a space becasue I'm too lazy to lex it
13:36:38 <Trinithis> and the parser is really simple
13:36:42 --- mode: ChanServ set +o Saizan
13:36:53 --- mode: Saizan set +e fxr!i=user@gateway/tor/x-95d6de60578c1498
13:37:12 <Trinithis> eh... I gtg
13:37:26 --- mode: Saizan set -o Saizan
13:40:47 <paczesiowa> > let followeBy p k = do { x <- p; try k; return x} in string parseTest ((string "hello" `followeBy` char ' ') >> string " world") "hello world"
13:40:48 <lambdabot> Terminated
13:40:58 <paczesiowa> > let followeBy p k = do { x <- p; try k; return x} in parseTest ((string "hello" `followeBy` char ' ') >> string " world") "hello world"
13:41:00 <lambdabot> Terminated
13:41:08 <paczesiowa> > ()
13:41:10 <lambdabot>  ()
13:42:22 <paczesiowa> @src notFollowedBy
13:42:22 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:43:03 <athos> @src followedBy
13:43:04 <lambdabot> Source not found. Where did you learn to type?
13:43:14 <athos> i see
13:43:23 <paczesiowa> Trinithis: do you want to unget that following token?
13:44:14 <paczesiowa> if not then followedBy is just *>
13:44:20 <paczesiowa> or the other way
13:44:29 <EvilTerran> notFollowedBy p = try $ do { c <- p; unexpected (show [c]) } <|> return ()
13:44:38 <EvilTerran> "followedBy" doesn't seem to exist
13:51:08 <Myoma> Has anybody programmed this in haskell ? http://en.wikipedia.org/wiki/Dining_philosophers_problem
13:51:10 <lambdabot> Title: Dining philosophers problem - Wikipedia, the free encyclopedia
13:51:28 <Myoma> Can it be done very elegantly with Control.Concurrency?
13:51:34 <ddarius> Myoma: Almost certainly.
13:51:45 * Myoma wishes someone will write it
13:52:05 <EvilTerran> i don't think you even need Control.Concurrency, necessarily
13:52:40 <Myoma> I want to compare haskell and erlang and other solutions
13:53:35 <ddarius> Myoma: Make an MVar for each fork, write the eat and think routines, hook 'em together, done.
13:53:42 <Myoma> :D
13:53:52 * sw17ch loves MVars
13:54:03 * Twey dislikes MVars :(
13:54:06 <Myoma> perhaps a type level encoding should be done
13:54:14 <Twey> They feel like global state...
13:54:29 <dons> hmm, i'm surprised we don't have an example on the wiki for the dining category theorists.
13:54:29 <Vq^> Twey: they aren't so bad when used for the right thing (often quite simple things)
13:54:58 <dons> Twey: how are they global?
13:55:05 <dons> they're shared, threadsafe state.
13:55:07 <Myoma> it's in java http://www.doc.ic.ac.uk/~jnm/concurrency/classes/Diners/Diners.html
13:55:14 <lambdabot> Title: Dining Philosophers, http://tinyurl.com/26ehj3
13:55:14 <Vq^> dons: do they eat? i thought they just absorbed termal energy from the atmosphere
13:56:09 <Saizan> a package that uses happy as preprocessor?
13:59:35 <sw17ch> Twey, they really aren't scary... there's no state involved..
13:59:36 <ddarius> philosopher left right = do think; eat; philosopher left right; where think = do putMVar left (); putMVar right (); threadDelay <$> randomIO; eat = do takeMVar left; takeMVar right; threadDelay <$> randomIO; diningPhilosophers = do [a,b,c,d,e] <- replicateM 5 $ newMVar (); mapM_ (forkIO . uncurry philosopher) [(a,b), (b,c), (c,d), (d,e), (e,a)]
13:59:54 <sw17ch> the only state is taht the other guy can be logically considered putting or getting something from it at the same time you do the opposite action
13:59:58 * sw17ch goes home for the evening
14:00:16 <Twey> But if you modify it in one thread it changes in all the threads
14:00:33 <sbahra> What are you working on Twey?
14:00:36 <sbahra> ohhh
14:00:37 <ddarius> Yes, but each thread can only see a change to an MVar it was given.
14:00:43 <sbahra> That is what I forgot in my old apartment, my haskell book
14:01:03 <lament> buy a new one!
14:01:06 <dmead> @hoogle zipwith
14:01:06 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:01:07 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:01:07 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
14:01:19 <sbahra> lament, I'll have my friend drop it off in an hour or so ;p
14:01:26 <dmead> whats the kind of zip that keeps goin when one list runs out?
14:02:03 <Saizan> ddarius: putMVar blocks if the MVar is full, iirc
14:02:59 <ddarius> Saizan: Yeah, I was wondering about that.  There should be another function to try to put.
14:03:02 <MyCatVerbs> Saizan: yes it does.
14:03:04 <ddarius> :t tryPutMVar
14:03:05 <lambdabot> Not in scope: `tryPutMVar'
14:03:30 <Saizan> dmead: there isn't one in the libs, afaik
14:03:42 <Saizan> ?hoohle tryPutMVar
14:03:43 <lambdabot> GHC.Conc tryPutMVar :: MVar a -> a -> IO Bool
14:03:43 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
14:03:49 <EvilTerran> Saizan's right
14:03:49 <MyCatVerbs> ddarius: that isn't implemented and, I think, isn't implementable (properly, atomically) using the libs.
14:04:07 <EvilTerran> i think you need to resort to explicit recursion
14:04:14 * Myoma how do I get this to actually run
14:04:25 <MyCatVerbs> What is it who's trying to do, though?
14:04:26 <ddarius> MyCatVerbs: There is a function tryPutMVars
14:04:45 <paczesiowa> @src readsPrec
14:04:45 <lambdabot> Source not found. You type like i drive.
14:04:47 <ddarius> Myoma: You need to keep the main thread busy or it will just immediately exit.
14:04:52 <MyCatVerbs> Oh no, I'm wrong.
14:04:53 <yitz> isn't this an obvious candidate for STM and TVar?
14:05:01 <MyCatVerbs> Control.Concurrent.MVar has tryPutMVar.
14:05:05 <paczesiowa> where are docs for GHC.Read
14:05:15 <ddarius> One way of doing that would be to take out one of the philosophers and have it run in the main thread.
14:05:27 <Myoma> @hhoogle randomIO
14:05:28 <lambdabot> System.Random randomIO :: Random a => IO a
14:05:37 <MyCatVerbs> (But it _isn't_ implementable atomically, using the others, I'm sure. :)
14:05:50 <Myoma> yes
14:05:51 <Myoma> *Main> diningPhilosophers
14:05:51 <Myoma> *Main>
14:06:09 <ddarius> randomIO might not be the right function.
14:06:17 <Myoma> I will try to make them (philosophers) say what they are doing
14:06:20 <ddarius> Myoma: You may want to add output otherwise it could be running and nothing to see.
14:06:36 <dmead> hmm
14:06:39 <EvilTerran> using a channel for status messages would work
14:06:53 <EvilTerran> then the main thread could read from the channel and print what it reads - that'd give it something to do
14:07:25 <Myoma> I don't know how to do that
14:07:51 <smoofra> greetings #haskell.  I'm wondering if it's possible to defined one's own "deriving"able classes by using the Data class....
14:08:04 <smoofra> er.  define one's own
14:08:45 <Myoma> should I add a chan to each [a,b,c,d,e] <- replicateM 5 $ newMVar ()
14:09:16 <ddarius> Create a Chan in diningPhilosophers, pass it to philosopher, add a writeChan chan "eating" or whatever to think and eat, after all the philosophers are forked off, getChanContents >>= mapM_ putStrLn
14:09:25 <Myoma> oh! ok
14:09:42 <Cale> smoofra: the deriving keyword isn't extensible in any way currently, that I know of
14:10:00 <ddarius> It may do to label/number the philosophers in some way.
14:10:23 <byorgey> there are systems that allow you to do 'deriving'-like things, though
14:10:26 <byorgey> just not with the
14:10:31 <byorgey> 'deriving' keyword itself
14:10:33 <dsrogers> smoofra: if you need the effect of deriving, it's possible to write it with TH
14:10:51 <dsrogers> smoofra: assuming you can write a haskell program that does what you need.
14:10:52 <byorgey> I know I read a paper or two on it somewhere...
14:11:07 <Cale> Generic Haskell was a neat idea... I wonder what happened to that...
14:11:35 <byorgey> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1159
14:11:36 <lambdabot> Title: A generic programming extension for Haskell - CiteSeerX
14:11:55 <ddarius> Cale: My understanding was that it was never fully implemented.
14:12:21 <byorgey> also http://www.seas.upenn.edu/~sweirich/RepLib/
14:12:22 <lambdabot> Title: RepLib
14:12:52 <byorgey> no idea how helpful either of those are, smoofra, but worth a look perhaps
14:13:03 <smoofra> thanks everyone!
14:13:11 * smoofra reads
14:13:25 <Twey> smufra?
14:15:00 <kosmikus> Cale: nowadays, all the library approaches to generic programming can do almost everything Generic Haskell could ever do. there's not a lot of interest, it seems, so it's not actively developed anymore.
14:15:39 <smoofra> it seems like you can do a lot with ghc's deriving Data
14:16:34 <Cale> kosmikus: hmm... it did seem a whole lot more elegant than the library approaches though. Maybe that's wrong and I just don't have enough experience with it.
14:16:56 <kosmikus> Cale: more elegant why?
14:17:45 <Myoma> my philosophers wont think
14:17:46 <kosmikus> the main difference is that with a library, you still have to write boilerplate code per datatype
14:17:47 <Cale> hmm... I wonder if I can put it into words :)
14:17:54 <Myoma> they just put down the forks and wait
14:18:18 <kosmikus> for instance, if you want to use a GH-like sum-of-products view, you have to give mappings between a datatype and its structural representation
14:18:29 <kosmikus> this is something that a proper language extension can do for you automatically
14:18:34 <kosmikus> but a library can't
14:19:05 <smoofra> kosmikus: im not sure if this is right yet, but it looks like you can define a type deriving Data, and the data instance gives you enough low level access to the structure of the type that you don't need more boilerplate.
14:19:36 <kosmikus> apart from that, GH has types for generic functions that weren't somehow encoded using the class system, and it has support for type-indexed types (but they can now be coded using type families)
14:19:51 <ddarius> MyCatVerbs: Paste your code?
14:19:51 <Myoma> I got it to work
14:19:56 <ddarius> Sorry MyCatVerbs
14:20:19 <kosmikus> yes, Data is an example of such a generic view for the "Scrap your boilerplate" approach.
14:20:37 <MyCatVerbs> ddarius: my code? I have no code! I FAIL, WAHHHH! *cries*
14:20:44 <sbahra> Myoma, can you show us?
14:20:48 <Cale> kosmikus: It seemed nice to be able to just directly write generic functions by explicit recursion on the structure of the type.
14:20:51 <kosmikus> the GH approach needs a variant of Data which can't be derived automatically by ghc right now, but it could be built in as well
14:20:53 <Myoma> yeah
14:21:16 <kosmikus> Cale: ah, but you can do a similar thing using GADTs
14:21:17 <Myoma> can you name 5 philosophers?
14:21:35 <kosmikus> Cale: using type representations
14:21:48 <Myoma> @hoogle (a -> b -> c -> z) -> (a,b,c) -> z
14:21:49 <lambdabot> No results found
14:23:27 <kosmikus> Cale: http://people.cs.uu.nl/andres/GP3D.html makes use of this technique quite extensively ...
14:23:39 <lambdabot> Title: Generic programming in 3D
14:23:51 <Trinithis> what is the fixity of (*>) ?
14:23:59 <stepcut`> Myoma: i kant
14:24:29 * Myoma only gets Nietzsche Plato Descartes Zhaozhou
14:24:49 <Myoma> and Bertrand Russell
14:25:41 <sbahra> Well, why do you want me to name 5? :-P
14:25:53 <sbahra> Just call them A, B, C, D and E.
14:28:10 <matthew-_> bertrand russell basically invented type systems
14:28:37 <sbahra> And Whitehead didn't do anything
14:28:44 <sbahra> k
14:28:54 <matthew-_> chief publicist ;)
14:29:27 <Myoma> hw
14:29:31 <Myoma> weird
14:29:39 <Myoma> the only one that does anything is Nietzsche
14:30:04 <yitz> http://www.gla.ac.uk/philosophy/
14:30:16 <lambdabot> Title: University of Glasgow :: Philosophy :: Philosophy
14:30:56 <ddarius> You may want to modify the values passed to threadDelay as otherwise it is likely to be an extremely short amount of time.
14:31:17 <quicksilver> the important thing about philosophers is not their names
14:31:32 <quicksilver> it's where they sit, what they eat, and how many knives and forks they have.
14:31:38 <Myoma> randomRIO (seconds 1,seconds 2)
14:31:43 * Twey laughs.
14:31:47 <Myoma> is what I changed it to
14:32:46 <ddarius> If you didn't switch to tryPutMVar they'll block on thinking
14:33:17 <matthew-_> quicksilver: not only that, but who their bluddy chef was that couldn't serve them individual portions
14:35:16 <Myoma> I got a BUS error from ghci
14:35:23 <EvilTerran> we would go for naming them alphabetically if i wanted to give them names
14:35:32 <dcoutts> could I have a couple volunteers to check the latest cabal and cabal-install releases for brown paper bag errors, before I upload them to hackage?
14:35:32 <matthew-_> Myoma: playing with mmap?
14:35:35 <dcoutts> pretty please :-)
14:35:37 <Myoma> mvars
14:35:48 <dcoutts> gwern: go on, you know you want to
14:36:02 <EvilTerran> call the first guy Aristotle
14:36:14 * EvilTerran goes to look up philosophers whose names start with "B"
14:36:15 <dcoutts> kosmikus: here's your chance to get going with cabal-install :-)
14:36:23 <Myoma> Bertrand
14:36:39 <dcoutts> http://haskell.org/cabal/download.html
14:36:40 <lambdabot> Title: The Haskell Cabal
14:37:10 <r3m0t> there's a cabal? man, I need to get in there
14:37:17 <dcoutts> in particular, the cabal-install tarball now has a bootstrap.sh script
14:37:34 <dcoutts> r3m0t: the first rule of the Haskell Cabal is that there is no Haskell Cabal
14:37:35 <kosmikus> dcoutts: :)
14:37:58 <r3m0t> dcoutts: I'll just be on my way then
14:38:17 <dcoutts> kosmikus: report any problems, if all goes well I'll release these tarballs on hackage
14:38:58 <dcoutts> r3m0t: or you could help us test it ! :-)
14:42:28 <dmead> > foldr (map +1) [1..10]
14:42:29 <lambdabot>      Overlapping instances for Show ([b -> b] -> [b])
14:42:30 <lambdabot>       arising from a us...
14:42:35 <dmead> woops
14:42:43 <dmead> > foldr (+1) 0 [1..10]
14:42:44 <lambdabot>      No instance for (Num (b -> b))
14:42:44 <lambdabot>       arising from the literal `1' at <in...
14:42:49 <dmead> > foldr 0 (+1)  [1..10]
14:42:51 <lambdabot>      Overlapping instances for Show (a1 -> a1)
14:42:51 <lambdabot>       arising from a use of `s...
14:43:01 <dmead> > foldr 0 (1+)  [1..10]
14:43:03 <lambdabot>      Overlapping instances for Show (t -> t)
14:43:03 <lambdabot>       arising from a use of `sho...
14:43:07 <dmead> > foldr 0 (+)  [1..10]
14:43:09 <lambdabot>      Overlapping instances for Show (a1 -> a1 -> a1)
14:43:09 <lambdabot>       arising from a use...
14:43:14 <dmead> what...
14:43:17 <dmead> ?src foldr
14:43:17 <lambdabot> foldr f z []     = z
14:43:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:43:24 <Trinithis> :t <*>
14:43:26 <lambdabot> parse error on input `<*>'
14:43:28 <dmhouse> > foldr (+) 0 [1..10]
14:43:30 <lambdabot>  55
14:43:32 <dmead> oh
14:43:33 <r3m0t> success
14:43:33 <dmead> :P
14:43:38 <dmead> ah
14:43:40 <dmhouse> :t (<*>)
14:43:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:43:45 <dmead> what i'm thinking of isnt' exactly foldr
14:43:51 <dmhouse> dmead: what do you want?
14:43:54 <Trinithis> :t (<*>)
14:43:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:44:05 <r3m0t> > scanr (+) 0 [1..10]
14:44:07 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
14:44:18 <dmead> scanr, apparently
14:44:22 <dmead> ty, r3m0t
14:44:26 <r3m0t> :D psychic me
14:44:31 <r3m0t> > scanl (+) 0 [1..10]
14:44:33 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
14:44:35 <dmead> yea
14:44:39 <dmead> running totals
14:44:44 <dmead> most excellent
14:44:47 <Olathe> @src scanr
14:44:47 <lambdabot> scanr _ q0 []     =  [q0]
14:44:47 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
14:44:47 <lambdabot>     where qs@(q:_) = scanr f q0 xs
14:44:57 <dmead> r3m0t++
14:45:09 <dmead> no karma anymore?
14:45:13 <dmead> ?karma dmead
14:45:13 <lambdabot> You have a karma of 0
14:45:15 <dmead> what
14:45:19 <dmead> it was totally 3 last year
14:45:28 <dmead> karma++
14:45:32 <dmead> ?karma
14:45:33 <lambdabot> You have a karma of 0
14:45:42 <r3m0t> ?karma God
14:45:43 <lambdabot> God has a karma of 0
14:45:46 <dcoutts> dmead: lambdabot is forgetful
14:45:51 <dmead> ah
14:46:09 <Myoma> lambdabot didn't learn save early/save often
14:46:19 <Trinithis> What does the bot recognize ++ instead of succ?
14:46:42 <Olathe> What ?
14:46:55 <Trinithis> instead of karma++ ... succ karma
14:47:07 <paczesiowa> that wouldn't change karma
14:47:14 <mmorrow> could someone running ghc-6.8.2 do me a huge favor and in ghci do:
14:47:16 <mmorrow> ghci> :m + Language.Haskell.TH.Syntax
14:47:16 <mmorrow> ghci> :i Quasi
14:47:17 <mmorrow> ?
14:47:22 <paczesiowa> modifyIORef karma succ
14:47:32 <mmorrow> oh, the favor is to tell me if you have
14:47:34 <Trinithis> mmorrow... one sec
14:47:34 <mmorrow>   qLocation :: m Loc
14:47:48 <r3m0t> > forM_ (repeat God) (\x -> modifyIORef (karma x) succ)
14:47:50 <lambdabot> Terminated
14:47:51 <alec> mmorrow: no, I don't have one
14:48:07 <mmorrow>   qCurrentModule :: m String
14:48:10 <mmorrow> or ^^^
14:48:20 <dmhouse> mmorrow: http://hpaste.org/9945
14:48:22 <mmorrow> alec: so you have qCurrentModule then?
14:48:34 <mmorrow> cool. thanks Trinithis, alec, dmhouse
14:48:45 <alec> mmorrow: yes
14:49:01 <mmorrow> ok, and you're both running 6.8.2, correct?
14:49:06 <alec> yes
14:49:07 <dmhouse> Yep.
14:49:11 <mmorrow> thx
14:49:15 <Trinithis> is it any differnet in 6.8.3?
14:49:27 <mmorrow> i think the change happened 6.8.2 -> 6.8.3
14:49:30 <mmorrow> so yes
14:49:50 <mmorrow> (this just made me sure)
14:49:51 <Trinithis> I still need to install 6.8.3... too lazy to build
14:49:55 <mmorrow> heh
14:50:13 <mmorrow> the sooner you start, the sooner it'll finish
14:50:19 <Olathe> Trinithis: use 6.8.3
14:50:40 <Trinithis> I know. anyway, my internet is crappy here. I need to get it fixed
14:50:51 <dmead> @hoolge pretty prin
14:50:52 <lambdabot> module Text.PrettyPrint
14:50:52 <lambdabot> Language.Haskell.Pretty prettyPrint :: Pretty a => a -> String
14:50:52 <lambdabot> Language.Haskell.Pretty prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String
14:50:53 <dmead> @hoolge pretty print
14:50:54 <lambdabot> module Text.PrettyPrint
14:50:54 <lambdabot> Language.Haskell.Pretty prettyPrint :: Pretty a => a -> String
14:50:54 <lambdabot> Language.Haskell.Pretty prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String
14:51:00 <dmead> @hoolge pretty print list
14:51:01 <lambdabot> No results found
14:51:12 <Trinithis> im basically at a dialup speed
14:52:21 <Olathe> Trinithis: I don't think the problem is laziness. If it was laziness, the installation would wait until you used it, and I just said to use it, but the install didn't happen.
14:53:14 <Trinithis> huh? was that a lazy (as in thunks) joke?
14:53:27 <Olathe> Yes.
14:53:54 * Trinithis gives pity laugh
14:54:19 <Olathe> That laugh was pitifu.
14:54:38 <Trinithis> :(
14:55:22 <kosmikus> dcoutts: builds, installs fine. cabal-install seems to sometimes want to install (via --dry-run) packages I already have ...
14:55:56 <dons> dcoutts: this breaks 'riot' too, http://hackage.haskell.org/trac/hackage/ticket/245
14:55:57 <lambdabot> Title: #245 (Cabal should support hsc2hs's stub .c feature) - Hackage - Trac
14:56:03 <dmead> > scanr1  (+) [1..10]
14:56:05 <lambdabot>  [55,54,52,49,45,40,34,27,19,10]
14:56:17 <dmead> > scanrl  (+) [1..10]
14:56:18 <lambdabot> Terminated
14:56:20 <dcoutts> kosmikus: that's usually because it needs to rebuild them against different versions of deps to get a consistent install solution
14:56:28 <dcoutts> kosmikus: you can see in more detail with -v
14:56:37 <dcoutts> dons: riot?
14:57:35 <dons> dcoutts: details added, http://hackage.haskell.org/trac/hackage/ticket/245#comment:5
14:57:36 <lambdabot> Title: #245 (Cabal should support hsc2hs's stub .c feature) - Hackage - Trac
14:57:37 <kosmikus> dcoutts: possible, but I can't see that from the output even with -v
14:57:43 <dcoutts> dons: note Ross's comment on that ticket
14:58:35 <dons> yes, that doesn't affect riot, afaik, since it is an executable only. ?
14:59:37 <dmead> ?src mapAcummR
14:59:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:59:42 <dmead> ?src mapAcumR
14:59:43 <lambdabot> Source not found. Are you on drugs?
14:59:49 <dmead> not yet
14:59:51 <allbery_b> @src MapAccumR
14:59:51 <lambdabot> Source not found. :(
14:59:52 <dmead> it's still early
15:00:01 <allbery_b> right spelling, still not there
15:00:08 <dmead> @hoogle mapaccumr
15:00:08 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
15:00:09 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:00:09 <lambdabot> Data.ByteString.Char8 mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
15:00:11 <allbery_b> er, casse
15:00:12 <allbery_b> duh
15:00:13 <dmead> hmm
15:00:19 <allbery_b> @src mapAccumR
15:00:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:00:33 <dmead> wtf
15:00:37 * allbery_b killed it :/
15:00:37 <dmead> :t mapAccumR
15:00:39 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:00:54 <dcoutts> dons: the easy thing to do is to use a separate .c file
15:01:09 <dons> mm
15:01:14 <dmead> > mapAccumR 0 [1..10]
15:01:16 <lambdabot>      Overlapping instances for Show ([x] -> ([t], [y]))
15:01:16 <lambdabot>       arising from a ...
15:01:21 <dmead> > mapAccumR (+) 0 [1..10]
15:01:22 <lambdabot>      Occurs check: cannot construct the infinite type: acc = (acc, y)
15:01:23 <lambdabot>       E...
15:01:30 <dmead> > mapAccumR 0 (+) [1..10]
15:01:31 <lambdabot>      Overlapping instances for Show (a -> a -> a)
15:01:32 <lambdabot>       arising from a use of...
15:01:35 <dmead> hmm
15:01:51 <saya> > :t (>>=).(>>=).(>>=)
15:01:52 <lambdabot> Terminated
15:02:04 <saya> > show "wussy"
15:02:05 <lambdabot>  "\"wussy\""
15:02:16 <dcoutts> dons: in principle we should support it, but it's a fair bit of work for a little used feature with an easy alternative.
15:02:19 <Trinithis> try 2 c's
15:02:20 <dons> yeah.
15:02:30 <dons> so you're saying the C bits should just be in the .c file
15:02:35 <dons> rather than generated from hsc2hs
15:02:36 <dons> ?
15:02:37 <dcoutts> dons: yep
15:02:45 <dons> avoid the feature all together.
15:02:54 <dcoutts> dons: right, though it is neat I admit.
15:02:55 <yitz> mapAccumR _ s []        =  (s, [])
15:02:55 <yitz> mapAccumR f s (x:xs)    =  (s'', y:ys)
15:02:55 <yitz>                            where (s'',y ) = f s' x
15:02:55 <yitz>                                  (s', ys) = mapAccumR f s xs
15:03:14 <dcoutts> dons: we might support it one day, after the higher priority things are taken care of
15:03:26 <dons> yeah, no biggie.
15:04:00 <dcoutts> dons: btw, if you want to help me avoid a brown paper bag release you could do worse than to try out http://haskell.org/cabal/download.html
15:04:01 <lambdabot> Title: The Haskell Cabal
15:04:15 <dcoutts> dons: see the cabal-install changelog, there's quite a few new minor features
15:04:27 <dmead> can someone do a simple example of mapaccumr?
15:04:35 <dmead> the docs aren't clear to me
15:04:43 <dons> dcoutts: why not announce a release candidate on the list?
15:04:59 <dcoutts> dons: it's a minor release, I'm hoping to just do the release
15:05:21 <dmead> argh
15:05:22 <dmead> if have
15:05:24 <_ar> ?src Num
15:05:25 <lambdabot> class  (Eq a, Show a) => Num a  where
15:05:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:05:25 <lambdabot>     negate, abs, signum     :: a -> a
15:05:25 <lambdabot>     fromInteger             :: Integer -> a
15:05:29 <dmead> a list [1..3]
15:05:31 <dcoutts> dons: I just want to check I've not overlooked anything really obvious that'd leave egg on my face :-)
15:05:53 <dmead> how do you transform it into [[1,2,3],[1,2],[1]]
15:05:59 <dmead> from [1..3]
15:06:19 <Cale> > inits [1..3]
15:06:20 <dmead> > iterate tail [1..3]
15:06:21 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:06:22 <lambdabot>  mueval: [[1,2,3],[2,3],[3],[],*** Exception: Prelude.tail: empty list
15:06:30 <Cale> > drop 1 . inits $ [1..3]
15:06:32 <lambdabot>  [[1],[1,2],[1,2,3]]
15:06:36 <Cale> > reverse . drop 1 . inits $ [1..3]
15:06:37 <dmead> > iterate tail [1..3]
15:06:37 <lambdabot>  [[1,2,3],[1,2],[1]]
15:06:39 <lambdabot>  mueval: [[1,2,3],[2,3],[3],[],*** Exception: Prelude.tail: empty list
15:06:41 <Trinithis> wow. lots of lag for me
15:06:53 <dmead> ?src inits
15:06:54 <lambdabot> inits []     =  [[]]
15:06:54 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
15:06:58 <dmead> wow
15:06:59 <dmead> hmm
15:07:03 <dcoutts> kosmikus: does -v give you any insight?
15:07:19 <dmead> i guess i want map over inits
15:07:23 <dmead> not scanr
15:07:32 <dmead> @hoogle inits
15:07:33 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
15:07:33 <lambdabot> Data.List inits :: [a] -> [[a]]
15:07:33 <lambdabot> Data.ByteString.Char8 inits :: ByteString -> [ByteString]
15:07:52 <dmead> well shit
15:09:08 <yitz> dmead: what do you want to do?
15:10:12 <dmead> i wanted exactly this
15:10:31 <dmead> > map (1+) (map inits [1..10])
15:10:33 <lambdabot>      No instance for (Num [[a]])
15:10:33 <lambdabot>       arising from the literal `1' at <inter...
15:10:37 <dmead> or not
15:10:43 <dmead> > inits [1..10]
15:10:45 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
15:10:53 <dmead> > map sum (inits [1..10])
15:10:55 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
15:11:02 <Cale> > scanl (+) 0 [1..10]
15:11:03 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
15:11:18 <dmead> hmm
15:11:21 <dmead> scanl didn't work for me though
15:11:28 <Cale> Seems to work for me :)
15:11:30 <dmead> my function takes a list
15:11:35 <dmead> i would have to use sum
15:11:37 <dmead> not +
15:12:09 <dmead> subtle difference i guess
15:12:48 <yitz> > scanl (flip (:)) "" "This is a string."
15:12:50 <lambdabot>  ["","T","hT","ihT","sihT"," sihT","i sihT","si sihT"," si sihT","a si sihT",...
15:13:06 <dibblego> does Maybe have forall/exists (Maybe Bool -> Bool)?
15:13:09 <yitz> > scanr (:) "" "This is a string."
15:13:11 <lambdabot>  ["This is a string.","his is a string.","is is a string.","s is a string.","...
15:13:21 <dmead> Cale, can you use scan and sum together?
15:13:31 <yitz> > tails "This is a string."
15:13:32 <lambdabot>  ["This is a string.","his is a string.","is is a string.","s is a string.","...
15:14:06 <dmead> what kind of a name is "inits" anyway
15:14:21 <Cale> dmead: I guess you could sum the result of a scanl...
15:14:24 <Myoma> dmead: derived from init
15:14:30 <Cale> dmead: An appropriate one
15:14:34 <Myoma> > init "dmead"
15:14:36 <lambdabot>  "dmea"
15:14:40 <Olathe> > inits "This is a string."
15:14:41 <lambdabot>  ["","T","Th","Thi","This","This ","This i","This is","This is ","This is a",...
15:14:43 <Cale> dmead: It returns the initial sublists of a list.
15:14:45 <Myoma> > iterate init "dmead"
15:14:46 <lambdabot>  mueval: ["dmead","dmea","dme","dm","d","","*** Exception: Prelude.init: empt...
15:14:50 <dmead> ah
15:14:51 <Cale> hence inits :)
15:15:09 <dmead> it's more like ordered powerset though
15:15:18 <Myoma> not really
15:15:20 <dmead> ehh
15:15:20 <dmhouse> It's not a powerset.
15:15:31 <dmhouse> > inits "abc" -- notice the lack of, say, "b"
15:15:33 <lambdabot>  ["","a","ab","abc"]
15:15:43 <dmhouse> Hey wow, line comments now work. gwern++
15:15:53 <dmead> hmm
15:16:14 <dmead> ah
15:16:15 <dmead> i see
15:16:34 <dmead> > init [1..10]
15:16:36 <lambdabot>  [1,2,3,4,5,6,7,8,9]
15:16:38 <dmead> > inits [1..10]
15:16:40 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
15:16:45 <Olathe> > (liftM2 zip (reverse . inits) tails) "This is a string."
15:16:47 <lambdabot>  [("This is a string.","This is a string."),("This is a string","his is a str...
15:16:54 <dmead> it leaves off the end?
15:17:02 <dmead> > inits [1..3]
15:17:03 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:17:10 <Olathe> > init [1..3]
15:17:11 <lambdabot>  [1,2]
15:17:14 <dmead> hm
15:17:17 <dmead> > inits [1..3]
15:17:17 <Olathe> > init (init [1..3])
15:17:19 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:17:19 <lambdabot> Terminated
15:17:22 <Olathe> > init (init [1..3])
15:17:23 <dmead> > inits [1..3]
15:17:24 <lambdabot>  [1]
15:17:25 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:17:29 <Olathe> > init (init (init [1..3]))
15:17:31 <lambdabot>  []
15:17:36 <matthew-_> ok, metallica s&m is quite good
15:17:47 <dmead> i have to apply my list function over every successivly smaller sublist
15:17:48 <matthew-_> ww, for the 2nd time today. *sigh*. sorry.
15:17:55 <dmead> so scanr was sort of misleading
15:18:01 <dibblego> @type or . maybeToList -- is this function in the standard libs somewhere?
15:18:02 <lambdabot> Maybe Bool -> Bool
15:18:03 <dmhouse> matthew-_: wtf?
15:18:25 <Olathe> @hoogle Maybe Bool -> Bool
15:18:26 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
15:18:26 <lambdabot> Data.Foldable or :: Foldable t => t Bool -> Bool
15:18:26 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
15:18:37 <dmead> alright
15:18:40 <dmead> i'm tired
15:19:24 <matthew-_> dmhouse: http://en.wikipedia.org/wiki/S&M_(album)
15:19:45 <Philonous> > let sbs [] = [] ; sbs (x:xt) = [x] : map (x:) sxt ++ sxt where sxt = sbs xt in sbs [1..]
15:19:47 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
15:19:56 <Philonous> > let sbs [] = [] ; sbs (x:xt) = [x] : map (x:) sxt ++ sxt where sxt = sbs xt in sbs [1..4]
15:19:57 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,4],[1,3],[1,3,4],[1,4],[2],[2,3],[2,3,4],[...
15:20:32 <dmhouse> matthew-_: heh, okay.
15:20:38 <EvilTerran> Philonous, what's this meant to do?
15:21:00 <Philonous> > let sbs [] = [] ; sbs (x:xt) = [x] : map (x:) sxt ++ sxt where sxt = sbs xt in sbs "abc"
15:21:02 <lambdabot>  ["a","ab","abc","ac","b","bc","c"]
15:21:09 <Philonous> subset
15:21:34 <Philonous> I mean it should compute the power set
15:21:39 <Philonous> compute*
15:21:51 <Myoma> > "abc" >>= (\e -> [[],[e]])
15:21:52 <lambdabot>  ["","a","","b","","c"]
15:22:04 <dmhouse> Philonous: up to orderings, of course. (Which is really because lists aren't sets.)
15:22:17 * EvilTerran tries to remember the fancy-schancy monad trick he's seen for tha
15:22:18 <dmhouse> Philonous: and it will have duplicates if the original did. (Same disclaimer.)
15:22:22 <Myoma> > map (>>= (\e -> [[],[e]]))) "abc"
15:22:22 <lambdabot> Unbalanced parentheses
15:22:25 <Myoma> > map (>>= (\e -> [[],[e]])) "abc"
15:22:27 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
15:22:29 <dmhouse> EvilTerran: sequence?
15:22:32 <Trinithis> @pl \c -> oneOf [toUpper c, toLower c]
15:22:32 <lambdabot> oneOf . liftM2 (:) toUpper (return . toLower)
15:22:39 <Myoma> > map (>>= (\e -> [[],[e]])) "abc"
15:22:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
15:22:43 <Philonous> dmhouse I'm aware of that
15:22:51 <EvilTerran> > filterM (const [False, True]) "abc"
15:22:52 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
15:22:54 <Myoma> > (>>= (\e -> [[],[e]])) =<< "abc"
15:22:56 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
15:22:58 <EvilTerran> ta-dah!
15:23:01 <Myoma> :t (>>= (\e -> [[],[e]]))
15:23:02 <lambdabot> forall a. [a] -> [[a]]
15:23:10 <Philonous> I'm just wondering id there is a way to do that without including the trivial case explicitly
15:23:15 <EvilTerran> powerset = filterM (const [False, True]) -- :D
15:23:39 * EvilTerran even understands how that works, not that i could explain it very well
15:23:56 <Myoma> > map (const ("abc" >>= (\e -> [[],[e]]))) "abc"
15:23:58 <lambdabot>  [["","a","","b","","c"],["","a","","b","","c"],["","a","","b","","c"]]
15:24:05 <Myoma> > sequence (map (const ("abc" >>= (\e -> [[],[e]]))) "abc")
15:24:06 <lambdabot>  [["","",""],["","","a"],["","",""],["","","b"],["","",""],["","","c"],["","a...
15:24:13 <Philonous> @src filterM
15:24:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:24:23 <EvilTerran> you could probably transform it into something more obviously correct via equational reasoning
15:24:25 <Philonous> @hoogle filterM
15:24:25 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
15:24:35 <dsrogers> woah.  Lambda bot got snarky!
15:24:40 <dmhouse> ?src [] filterM
15:24:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:25:30 <dmhouse> ?src filterM
15:25:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:25:37 <EvilTerran> filterM p [] = return []; filterM p (x:xs) = do px <- p x; liftM (if px then (x:) else id) (filterM p xs)
15:26:17 <r3m0t> > show []
15:26:19 <lambdabot>  "[]"
15:26:27 <r3m0t> > show ([]::[Char])
15:26:28 <lambdabot>  "\"\""
15:26:45 <Myoma> > show ([]::[()])
15:26:47 <lambdabot>  "[]"
15:26:47 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#filterM
15:26:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5shf58
15:27:01 <Philonous> Thx
15:27:16 <jcpetruzza> @hoogle (a -> Bool) -> [a] -> ([a], [a])
15:27:17 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:27:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
15:27:17 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:27:23 <EvilTerran> i think that's the same as mine, including such things as strictness and side-effects
15:27:39 <EvilTerran> ?type partition
15:27:40 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:28:36 <Philonous> I'm pondering how you one-liner works. It will be fun to work it out :)
15:28:44 <jcpetruzza> @hoogle partition
15:28:45 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
15:28:45 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
15:28:45 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
15:29:13 <dmhouse> Philonous: instead of `p x', you can write `[True, False]'.
15:29:36 <EvilTerran> and you can switch from do notation to list comprehensions, if you like
15:30:16 <EvilTerran> powerset [] = return [] = [[]]
15:30:18 <dmhouse> do px <- [True, False]; liftM (if px then (x:) else id) rest
15:30:32 <Shurique> does anyone know if it's possible to initialize an editable command line (System.Console.Readline) with some default string?
15:30:34 <dmhouse> So for each px in [True, False] do liftM (if px then (x:) else id) rest
15:30:50 <dmhouse> So you get one branch where the (x:) hits and one where id hits
15:31:06 <dmhouse> The list monad handles the appropriate `concat's.
15:31:23 <EvilTerran> powerset (x:xs) = do flg <- [False, True]; ys <- powerset xs; return (if flg then x:ys else ys)
15:31:34 <Shurique> the setPendingInput action seems to do almost what I want, but it's limited to one character
15:31:45 <EvilTerran> = [if flg then x:ys else ys | flg <- [False, True], ys <- powerset xs]
15:33:54 <EvilTerran> > foldr (\x ss -> [id,(x:)] <*> ss) [[]] "abc"
15:33:56 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
15:34:38 <jcpetruzza> @src partition
15:34:38 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:34:38 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:34:38 <lambdabot>                               | otherwise = (ts, x:fs)
15:34:51 * EvilTerran gets carried away
15:34:56 <EvilTerran> > foldr (ap.(:[id]).(:)) [[]] "abc"
15:34:57 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
15:35:08 <BONUS> omg
15:35:24 <EvilTerran> >:D
15:35:29 <Olathe> > foldr (ap.(:[id]).(:)) [[]] "omg"
15:35:31 <lambdabot>  ["omg","om","og","o","mg","m","g",""]
15:35:34 <yitz> Shurique: how about setLineBuffer and then redisplay?
15:35:49 <dmhouse> > foldr ((<*>) . (id:) . (:)) [[]] "abc"
15:35:50 <lambdabot>  Couldn't match expected type `[a -> a]'
15:36:00 <dolio> > filterM(const [False ..])"omg"
15:36:01 <lambdabot>  ["","g","m","mg","o","og","om","omg"]
15:36:29 <dolio> You could make that shorter, actually.
15:36:37 <dolio> > filterM(\_->[False ..])"omg"
15:36:39 <lambdabot>  ["","g","m","mg","o","og","om","omg"]
15:37:18 <dmhouse> > foldr ((<*>) . (:[id]) . (:)) [[]] "abc"
15:37:19 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
15:37:31 <Shurique> yitz: as in setLineBuffer "foo" >> redisplay >> readline ""?
15:37:33 <dmhouse> -- slightly more natural pointsfree style than EvilTerran's.
15:37:52 * EvilTerran pronounces <*> as "ap" anyway
15:37:59 <yitz> Shurique: yeah, not sure if that exactly will work, but something to try
15:38:26 <Shurique> yitz: doesn't appear to work :/
15:38:35 <EvilTerran> it's still not a very natural pointsfree style
15:38:36 <dmhouse> EvilTerran: oh wait, I misread yours, I thought you were using ap as in the \x y z -> x y (z y).
15:38:39 <yitz> :[
15:39:30 <EvilTerran> powerset = foldr (\x sets -> [(x:), id] <*> sets) [[]] -- i'd actually be tempted to use this version in a serious context
15:40:12 <EvilTerran> seeing as it only requires the reader to have got his head around <*> for lists, which is pretty straightforward
15:40:21 <Cale> Why not  filterM (const [False,True])  ?
15:40:56 <dmhouse> That's much more opaque.
15:41:02 <Cale> Actually, I think that is the easiest to read version of powerset that I've ever seen :)
15:41:04 <EvilTerran> filterM is a rather more imposing combinator than <*>
15:41:05 <Olathe> > let f = f' [] where f' _ [] = []; f' xs yys@(y:ys) = xs:yys:(f' (xs ++ [y]) ys) in f "omg"
15:41:07 <lambdabot>  ["","omg","o","mg","om","g"]
15:41:07 <EvilTerran> IMO
15:41:24 <Cale> It specifically says "for each element, regardless of its value, either keep it or don't"
15:41:49 <Cale> Which I don't think could be any clearer :)
15:41:49 <EvilTerran> *i* understand it like that just fine
15:42:23 <EvilTerran> but i'm not sure if others who encountered it in the wild would see it the same way
15:42:42 <Philonous> I lack enlightenment -.-
15:43:09 <dmhouse> Philonous: translate it to list comprehension form
15:43:24 <dmhouse> Philonous: and make sure you understand how the following algorithm works:
15:43:56 <EvilTerran> Cale, yeah, considering that it's working code, it's an incredibly high-level characterisation of the powerset function
15:44:03 <Cale> Philonous: filterM is an analogue of filter in which the condition, rather than being a -> Bool, is instead a -> m Bool, for some monad m
15:44:28 <dmhouse> > let pset [] = []; pset (x:xs) = pset xs ++ map (x:) (pset xs) in pset "abc"
15:44:30 <lambdabot>  []
15:44:31 <Cale> Philonous: In the list monad, lists are 'executed' by picking an element from them.
15:44:34 <dmhouse> Err...
15:44:52 <dmhouse> > let pset [] = [[]]; pset (x:xs) = pset xs ++ map (x:) (pset xs) in pset "abc"
15:44:53 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
15:45:05 <MyCatVerbs> So it reads as, "for each element, create one set of lists in which that element is included, and another in which it isn't."
15:45:10 <Cale> Philonous: So  (const [False,True]) is the function which, regardless of the value, gives the list of possibilities for keeping that element [False, True]
15:45:19 <Philonous> dmhouse: I wrote this version on my own, too
15:45:27 <EvilTerran> Cale, it's so direct that i catch my brain trying to find complexity that isn't there :P
15:45:42 <yitz> Shurique: See http://tiswww.case.edu/php/chet/readline/readline.html#SEC23 for docs of functions that System.Console.Readline binds to.
15:45:43 <lambdabot> Title: GNU Readline Library:
15:45:44 <EvilTerran> i guess because i feel that a rarely-used function like filterM *must* be complicated :P
15:45:59 <Cale> Philonous: and so the list monad collects all the possible results of either throwing away, or keeping, each element
15:46:00 <Philonous> Cale Thanks for clarifying, I suspected it and whas just checking
15:46:11 <Philonous> was*
15:47:27 <Philonous> But what I actually meant was, that though I  could explain technically what's going on butI don't "feel" it. I'm not thinking in monads
15:47:36 <Philonous> .but
15:47:46 <r3m0t> > let f x = [[x],[]]; g = concat . foldr (liftM2 (:)) [[]] . map f in g "omg"
15:47:49 <lambdabot>  ["o","m","g","o","m","","o","","g","o","","","","m","g","","m","","","","g",...
15:48:03 <EvilTerran> ...
15:48:09 <r3m0t> > let f x = [[x],[]]; g = map concat . foldr (liftM2 (:)) [[]] . map f in g "omg"
15:48:10 <lambdabot>  ["omg","om","og","o","mg","m","g",""]
15:48:36 <Cale> Philonous: Did my explanation of how to think about it help?
15:48:49 <Philonous> Cale yes it did
15:48:58 <r3m0t> @src filterM
15:48:58 <lambdabot> Source not found. Sorry.
15:49:06 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#filterM
15:49:08 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5shf58
15:49:18 <Cale> oh, that's a shame... I should remember to add it...
15:50:24 <Cale> filterM p [] = return []; filterM p (x:xs) = do b <- p x; ys <- filterM p xs; if b then return (x:ys) else return ys
15:50:49 <EvilTerran> you can make that lazier by floating the return outside the if
15:51:02 <Cale> ah, yeah.
15:51:02 <smoofra> gah there is an error in 'scrap your boilerplate'   that's why i didn't understand it
15:51:06 <EvilTerran> (i think it makes it lazier. shorter, anyway.)
15:51:19 <Cale> hmm
15:51:24 <Cale> Probably depends on the monad...
15:52:03 <EvilTerran> it'll be internally lazier, although that may not carry through to the outside
15:52:27 <smoofra> oh nm there isn't
15:52:47 <EvilTerran> actually, altho the action (p x) must be run, (b) could remain an unevaluated thunk depending on how far you force the result
15:53:10 <EvilTerran> so i think it'd be lazier monad-independently
15:54:36 <r3m0t> @djinn [[a]] -> [a]
15:54:52 <r3m0t> @djinn (a,b) -> (b,a)
15:54:53 <lambdabot> f (a, b) = (b, a)
15:55:43 <Olathe> @djinn [a] -> Bool
15:55:49 <EvilTerran> djinn doesn't do recursive types
15:56:10 <Olathe> @djinn [a] -> [a]
15:56:14 <EvilTerran> although i think it should be possible to devise rules for lists
15:56:48 <r3m0t> well, for something as simple as a -> [a], you don't know how many repetitions you will have
15:57:04 <saya> Do you guys know a good tutorial on the Reader / State Monad?
15:57:05 <EvilTerran> possibly even interesting ones - try to structurally recurse on list parameters and co-recurse on a list result or something
15:57:26 <EvilTerran> r3m0t, well, that could be dealt with by pretending [] = Maybe, even
15:57:41 <Olathe> @djinn a -> Maybe a
15:57:42 <lambdabot> f = Just
15:57:49 <Olathe> @djinn a -> [a]
15:57:52 <EvilTerran> ignore all of lists after the first cons cell
15:58:09 <Olathe> @djinn a -> State a
15:58:37 <EvilTerran> ?djinn Maybe a -> Bool
15:58:37 <lambdabot> f a =
15:58:38 <lambdabot>     case a of
15:58:38 <lambdabot>     Nothing -> False
15:58:38 <lambdabot>     Just _ -> True
15:59:06 <EvilTerran> ?djinn Bool -> a -> Maybe a
15:59:06 <lambdabot> f a b =
15:59:06 <lambdabot>     case a of
15:59:06 <lambdabot>     False -> Nothing
15:59:06 <lambdabot>     True -> Just b
15:59:26 <gwern> ah, Cale installed djinn?
15:59:26 <Olathe> @djinn Bool -> Maybe a -> b
15:59:27 <lambdabot> -- f cannot be realized.
15:59:28 <Cale> Can anyone think of an example of a Cartesian-closed category with all coproducts such that there is an arrow 1 -> A + 0^A for all objects A, but there is some object A for which there is neither a map 1 -> A nor A -> 0?
15:59:29 <EvilTerran> it does have a knack for coming up with "interesting" results, though - i keep meaning to find out how it does that
15:59:37 <Olathe> @djinn a -> a -
15:59:38 <lambdabot> Cannot parse command
15:59:42 <Olathe> @djinn a -> a -> a -> a
15:59:43 <lambdabot> f _ _ a = a
15:59:50 <gwern> @djin (a,b) -> a
15:59:51 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
16:00:00 <gwern> @djinn (a,b) -> a
16:00:00 <EvilTerran> seeing as "const Just" would fit Bool -> a -> Maybe a
16:00:00 <lambdabot> f (a, _) = a
16:00:01 <Olathe> @djinn-names
16:00:02 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Eq Bool
16:00:07 <Olathe> @djinn-env
16:00:07 <lambdabot> data () = ()
16:00:07 <lambdabot> data Either a b = Left a | Right b
16:00:07 <lambdabot> data Maybe a = Nothing | Just a
16:00:07 <lambdabot> data Bool = False | True
16:00:07 <lambdabot> data Void
16:00:09 <lambdabot> type Not x = x -> Void
16:00:11 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:00:33 <Olathe> @djinn Eq a -> Eq b -> Bool
16:00:39 <EvilTerran> er
16:00:44 <Olathe> Heh
16:00:47 <r3m0t> what's this Void stuff?
16:00:49 <Olathe> @djinn Eq a -> Eq a -> Bool
16:01:04 <r3m0t> @djinn (Eq a) => Maybe a -> Maybe a -> Bool
16:01:04 <lambdabot> f a b =
16:01:05 <lambdabot>     case a of
16:01:05 <lambdabot>     Nothing -> case b of
16:01:05 <lambdabot>                Nothing -> False
16:01:05 <lambdabot>                Just c -> c == c
16:01:06 <lambdabot>     Just d -> d == d
16:01:19 <EvilTerran> that's a bit silly
16:01:22 <Olathe> Heheh
16:01:23 <r3m0t> @djinn (Eq a) => Maybe a -> Maybe a -> Maybe Bool
16:01:24 <lambdabot> f a b =
16:01:24 <lambdabot>     case a of
16:01:24 <lambdabot>     Nothing -> Nothing
16:01:24 <lambdabot>     Just c -> case c == c of
16:01:24 <lambdabot>               False -> Nothing
16:01:26 <lambdabot>               True -> case b of
16:01:28 <lambdabot>                       Nothing -> Nothing
16:01:30 <lambdabot>                       Just _ -> Just False
16:01:33 <Cale> r3m0t: Void is a type with no values.
16:01:34 <EvilTerran> hehe
16:01:40 <Cale> r3m0t: (no defined values)
16:01:56 <r3m0t> that function is... interesting
16:01:59 <Olathe> @djinn (Eq a) => Maybe a -> Maybe a -> Maybe Bool -> a
16:01:59 <lambdabot> -- f cannot be realized.
16:02:10 <Cale> r3m0t: So the existence of a map A -> Void essentially says that A has no values.
16:02:37 <r3m0t> "case c == c"... ha ha
16:03:13 <Cale> It doesn't know about the laws that Eq is meant to satisfy.
16:03:21 <Olathe> @djinn test -> Bool
16:03:21 <lambdabot> f _ = False
16:03:26 <lilac> @djinn (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool
16:03:27 <lambdabot> f a b c =
16:03:27 <lambdabot>     case b of
16:03:27 <lambdabot>     Nothing -> False
16:03:27 <lambdabot>     Just d -> case c of
16:03:27 <lambdabot>               Nothing -> False
16:03:29 <lambdabot>               Just e -> a d e
16:03:37 <Cale> It just knows that Eq gives you a function (==) :: a -> a -> Bool
16:03:37 <Olathe> @djinn test -> test -> Bool
16:03:42 <lambdabot> f _ _ = False
16:03:44 <dons> dcoutts: nice, cabal-install. those dependencies also look insane :)
16:03:49 <dons> you'll scare the children.
16:03:54 <Cale> @djinn (Eq a) => a -> a -> Bool
16:03:55 <lambdabot> f = (==)
16:03:58 <Cale> :)
16:04:06 <dcoutts> dons: you mean the crazy way hackage displays them ?
16:04:07 <Olathe> @djinn (Eq a) => (Maybe a -> Maybe a -> Maybe Bool) -> Maybe a -> Maybe Bool
16:04:08 * Cale pats djinn
16:04:09 <dons> yeah
16:04:10 <lambdabot> f a = a Nothing
16:04:14 <dcoutts> dons: aye
16:04:14 <dons> hmm..
16:04:21 <dons> we need 'core' packages able to be hidden perahps
16:04:30 <dons> so random users can know what extra stuff they actually need
16:04:36 <Olathe> @help djinn
16:04:36 <lambdabot> djinn <type>.
16:04:37 <lambdabot> Generates Haskell code from a type.
16:04:37 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
16:04:40 <Cale> I think djinn does some things to try to rate the solutions it finds, but it doesn't always do a perfect job...
16:04:54 <lilac> yeah, as i recall it tries to find the most 'complex' proof
16:05:02 <dcoutts> dons: and the full expansion into 'or' style does not help I think
16:05:08 <Cale> It would be nice if there was a solution which consumed all the inputs, it would always find it.
16:05:11 <dcoutts> dons: the form given in the .cabal file is the most compact
16:05:14 <dons> ls
16:05:33 <Cale> But it doesn't seem to manage sometimes.
16:07:20 <Cale> We need the opposite of linear logic, where we can force things to be used at least once :)
16:07:37 <Igloo> dcoutts/dons: It would be nicer if it listed what was necessary in addition to a couple of HP versions
16:08:11 <dcoutts> Igloo: there are two reasons for listing the deps, one is just for interest to browse, the other is what will I need to install.
16:08:28 <Igloo> dcoutts: Well, you could make it expandable then
16:08:37 <Olathe> @djinn Maybe a -> Maybe b -> Maybe (a, b)
16:08:37 <lambdabot> f a b =
16:08:37 <lambdabot>     case a of
16:08:37 <lambdabot>     Nothing -> Nothing
16:08:37 <lambdabot>     Just c -> case b of
16:08:37 <lambdabot>               Nothing -> Nothing
16:08:39 <lambdabot>               Just d -> Just (c, d)
16:08:56 <dcoutts> Igloo: ok, so long as it doesn't involve javascript :-)
16:09:02 <Igloo> dcoutts: For extra fanciness, users could set which HP they have in a cookie or something
16:09:09 <r3m0t> Olathe: that one's perfect
16:09:15 * dcoutts hates cookies
16:09:27 <lilac> @. djinn type maybe
16:09:27 <Olathe> @djinn a -> (a, a, a, a, a, a, a)
16:09:28 <lambdabot> f a b c =
16:09:29 <lambdabot>     case c of
16:09:29 <lambdabot>     Nothing -> a
16:09:31 <lambdabot>     Just d -> b d
16:09:33 <lambdabot> f a = (a, a, a, a, a, a, a)
16:09:42 <r3m0t> @djinn Maybe a -> Bool
16:09:43 <lambdabot> f a =
16:09:43 <lambdabot>     case a of
16:09:43 <lambdabot>     Nothing -> False
16:09:43 <lambdabot>     Just _ -> True
16:09:46 <r3m0t> @djinn Maybe Bool -> Bool
16:09:47 <lilac> @. djinn type isJust
16:09:47 <lambdabot> f a =
16:09:47 <lambdabot>     case a of
16:09:47 <lambdabot>     Nothing -> False
16:09:49 <lambdabot>     Just b -> b
16:09:51 <lambdabot> f a =
16:09:53 <lambdabot>     case a of
16:09:55 <lambdabot>     Nothing -> False
16:09:57 <lambdabot>     Just _ -> True
16:10:16 <Olathe> @djinn Maybe Bool -> Maybe a -> Maybe (Maybe Bool, Maybe a)
16:10:17 <lambdabot> f a b =
16:10:17 <lambdabot>     case a of
16:10:17 <lambdabot>     Nothing -> Nothing
16:10:17 <lambdabot>     Just c -> case c of
16:10:17 <lambdabot>               False -> Nothing
16:10:19 <lambdabot>               True -> case b of
16:10:22 <lambdabot>                       Nothing -> Nothing
16:10:26 <lambdabot>                       Just d -> Just (Nothing, Just d)
16:10:43 <Philonous> After some consideration it seems the list monad implements some sort of nondeterminism
16:10:48 <gwern> out of curiosity, can amyone check out pandoc? supposed to be 'svn checkout http://pandoc.googlecode.com/svn/trunk/ pandoc-read-only'
16:10:49 <lambdabot> Title: Revision 1414: /trunk
16:10:52 <gwern> but that's not working for me
16:11:05 <gwern> Cale: http://hackage.haskell.org/trac/ghc/ticket/1895
16:11:07 <lambdabot> Title: #1895 (Allow aliases in GHCi module imports) - GHC - Trac
16:11:25 <Saizan> Philonous: that's the idea, yes
16:11:27 <EvilTerran> Philonous, that's exactly what it does
16:11:34 <EvilTerran> with laziness, it works out to be backtracking
16:11:38 <Cale> gwern: cool :)
16:12:10 <BMeph> Philonous: Woot Yes, you got it! :)
16:12:17 <Olathe> @djinn [a] -> [Maybe a]
16:12:39 <gwern> Cale: the more ccs, the more votes
16:12:43 <gwern> encourage your friends to subscribe!
16:12:49 <dons> dcoutts: http://aur.archlinux.org/packages.php?ID=17509 :)
16:12:53 <lambdabot> Title: AUR (en) - haskell-cabal
16:13:14 <dcoutts> dons: good good. So it works ok for you? no egg on my face? :-)
16:13:20 <dons> nothing bad yet.
16:13:39 <dcoutts> great
16:13:45 <gwern> man, I really wish ubuntu would upgrade to 6.8.3
16:13:55 <gwern> 6.8.2 is so annoying for me right now
16:13:59 <dons> i will complain vociferously if things break, do not doubt :)
16:14:11 <dcoutts> dons: I'm sure :-)
16:14:37 <gwern> no threaded/profiling, empty .profs all over the place, no profiled GHC API, old bytestring etc etc
16:14:39 <gwern> not to mention the other GHC API infelicities
16:14:40 <dcoutts> dons: I do hope your arch package installs the bash command line completion
16:14:56 <dcoutts> I can't live without it
16:15:02 <dons> mm
16:16:21 <Igloo> Are you moving to arch, dcoutts? Or just hoping for the sake of other users?
16:16:30 <dons> no, we need him on Gentoo
16:16:33 <dcoutts> Igloo: for the sake of the users
16:16:36 <dons> and we need killer Debian maintainers.
16:16:42 <dons> Arch is under control.
16:17:06 <Twey> dcoutts: You do the Gentoo packages?
16:17:34 <dcoutts> Twey: I resigned as a gentoo dev about 5 months ago so I could do more work on the central infrastructure that benefits all distros
16:17:36 <Nafai> dons: I'm guessing you need someone that is already a maintainer, right?
16:17:42 * gwern bets gentoo is up to 6.8.3 :(
16:17:44 <Twey> Ah, right
16:17:59 <dons> dcoutts: http://aur.archlinux.org/packages.php?ID=17411 :)
16:18:01 <lambdabot> Title: AUR (en) - cabal-install
16:18:01 <Twey> gwern: *emerge to check*
16:18:13 <gwern> Twey: I is on ubuntu
16:18:18 <dcoutts> Twey: but we have a team of other people doing gentoo packaging, see #gentoo-haskell
16:18:25 <gwern> hence my earlier bletching and kvetching about ubuntu
16:19:04 <dcoutts> dons: what am I looking at?
16:19:06 <gwern> Cale: oh btw, have you tried out the ~/ lambdabot patches?
16:19:16 <dons> dcoutts: oh, cabal-install is also packaged now.
16:19:21 <Nafai> I really should learn Debian packaging.  I've been using Debian / Ubuntu for almost 10 years now
16:19:34 <dcoutts> dons: oh, the cabal-install pkg, right as well as the Cabal lib. Sorry I didn't spot that.
16:19:39 <dons> yep.
16:19:41 <gwern> Nafai: it's not that difficult. there are some very nice debian books
16:19:53 * gwern likes madduck's debian book, fwiw
16:19:59 <Cale> gwern: what do you mean by ~/? Whose homedir on what machine?
16:20:09 <dcoutts> dons: so eg on gentoo we just install bash-comp files into /usr/share/bash-completion/$pkgname
16:20:16 <gwern> Cale: wherever it's running, under whatever user
16:20:17 <Nafai> I've got some good friends that are pretty expert at it
16:20:21 <dcoutts> dons: check out what arch does and do it, it's really so useful
16:20:22 <Cale> oh!
16:20:23 <gwern> @hoogle getHomeDirectory
16:20:23 <dons> hmm. i'll need to try it out.
16:20:23 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
16:20:26 <Cale> in that sense :)
16:20:43 <Cale> So I get the patches from the main LB repo?
16:20:44 * gwern wonders what others senses of ~/ there are
16:20:56 <dcoutts> dons: check your darcs ebuild, it must already install the bash comp for that.
16:20:57 <gwern> wait, main?
16:21:04 <gwern> HAVE YOU BEEN HOLDING OUT ON ME
16:21:21 <Cale> gwern: The one on code.haskell.org that you've been pushing to.
16:21:52 <mmorrow> dsrogers: ping
16:22:25 <gwern> Cale: incidentally, do you know any particular reason lb needs to be compiled -threaded?
16:22:51 <Cale> gwern: I don't know of any particular reason myself.
16:23:03 <gwern> hm. maybe I'll remove that then
16:23:34 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/EXAMPLES
16:23:41 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/
16:23:42 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
16:23:43 <mmorrow> :)
16:24:04 * Cale wonders if he should repeat his category theory question :)
16:24:40 <Cale> Maybe I can just answer it myself :)
16:25:05 <lilac> Cale: i'll answer it, if you can explain what all the terms mean, and give me hints :)
16:26:14 <gwern> I'll answer it, if you'll put it in a machine executable form :)
16:27:15 <mmorrow> Cale: the suspense is killing me
16:27:31 <Cale> gwern: mmm... there are bytestring version issues here now.
16:27:57 <Cale> 0.9.0.1.1 (which is apparently what comes with 6.8.3) vs. 0.9.1.0
16:28:08 * mmorrow finally found it
16:28:11 <Cale> I don't want to upgrade bytestring unless it's absolutely necessary.
16:28:25 <gwern> Cale: someone else was mentioning that earlier. just remove the mueval dep
16:28:26 <dons> new bytestrings are more awesome
16:28:45 <Cale> dons: and more incompatible with ghc-as-a-library :)
16:28:55 <gwern> dcoutts claims that it shouldn't be a problem because cabal doesn't add deps if those modules aren't imported, but...
16:29:26 <Cale> gwern: from lambdabot.cabal?
16:29:31 <dcoutts> gwern: no, the dep is there. It just doesn't fail profiling.
16:29:33 <gwern> yes
16:30:11 <Saizan> cabal doesn't even know which modules you're importing (yet)
16:30:14 <gwern> lies! all lies!
16:30:49 <gwern> what makes you lie?
16:31:01 <gwern> (why do you say these terrible things?)
16:31:10 <mmorrow> Cale: if the cat is cartesian closed, then it has a terminal object => for every A there exists a map  A -> 0
16:31:27 <mmorrow> or possibly i misunderstood the question
16:32:36 <mmorrow> err, i think that says there's no such A
16:32:54 <Cale> mmorrow: 1 is the terminal object
16:33:02 <Cale> mmorrow: 0 is initial
16:33:18 <mmorrow> um, i've always seen otherwise especially in algebra
16:33:47 <mmorrow> like short exact sequences are usually     1 -> _ -> _ -> _ -> 0
16:33:56 <mmorrow> (or maybe i really did flip them)
16:34:22 <mmorrow> but that's irrelevant
16:34:48 <mmorrow> ok, it's a different question now :)
16:34:51 <Cale> Well, given the Set analogy, the names 0 and 1 make more sense :)
16:35:15 <Cale> (the empty set is initial, one element sets are terminal)
16:35:24 <ddarius> I don't think I've ever seen someone use 0 for terminal unless it was a zero object (both terminal and initial)
16:35:41 <mmorrow> hmm, i may have switched it in my head.
16:35:50 * mmorrow checks to see
16:35:54 <roconnor> @djinn void -> ()
16:35:54 <lambdabot> f _ = ()
16:36:01 <ddarius> Usually short exact sequences are 0 -> _ -> _ -> _ -> 0
16:36:03 <roconnor> @djinn () -> Void
16:36:04 <lambdabot> -- f cannot be realized.
16:36:05 <ddarius> where 0 is a zero object
16:36:14 <roconnor> looks like 0 -> 1
16:36:47 <roconnor> and what ddarius said
16:37:31 <Myoma> what's the use of a 0 -> ... -> 0 ?
16:37:51 <mmorrow> ddarius: you're exactly right. i was thinking of the case where 0 is the zero object, and i mentally inserted the 1 randomly
16:37:55 <mmorrow> http://en.wikipedia.org/wiki/Short_exact_sequence
16:37:56 <Olathe> @djinn @djinn -> @pl
16:37:56 <lambdabot> Cannot parse command
16:38:02 <Myoma> it's jutst a more specific version of False -> anything ?
16:38:20 <ddarius> Myoma: Those arrows are homomorphisms not implications.
16:38:22 <Cale> Myoma: you insist that the image of each map is the kernel of the next
16:39:25 <Olathe> @djinn Bool -> Maybe a
16:39:26 <lambdabot> f _ = Nothing
16:40:11 <Philonous> That's a pretty boring homology
16:41:14 <Cale> I think that's the point :)
16:41:46 <mmorrow> a single short exact sequence is like a single lego brick
16:42:47 <mmorrow> http://en.wikipedia.org/wiki/Snake_lemma
16:42:49 <lambdabot> Title: Snake lemma - Wikipedia, the free encyclopedia
16:42:49 <Cale> Exact sequences are precisely the chain complexes with the most boring possible homology ;)
16:45:55 <Olathe> http://en.wikipedia.org/wiki/Snakes_on_a_plane_lemma
16:46:01 <mmorrow> haha
16:46:31 <Cale> My original question was: Can anyone think of an example of a Cartesian-closed category with all coproducts such that there is an arrow 1 -> A + 0^A for all objects A, but there is some object A for which there is neither a map 1 -> A nor A -> 0?
16:47:24 <gwern> neat!
16:47:31 <gwern> pandoc can turn .lhs into .wiki!
16:47:52 <Cale> Oh! I can think of one :)
16:47:53 <gwern> and the output at first glance doesn't look too bad
16:47:59 <Cale> It's a complicated one though :/
16:48:39 <Pseudonym> It seems to me that there should be a finite example, Cale.
16:48:59 <Philonous> I think I shouldn't have skipped the algebra lecturs.
16:49:31 * gwern thinks I shouldn't've dumped all that teriyaki sauce in my oatmeal once
16:49:43 <Pseudonym> Philonous, I didn't study abstract algebra as an undergrad.
16:49:49 <Pseudonym> Honestly, you pick it up.
16:49:55 <gwern> http://haskell.org/haskellwiki/User:Gwern/kenn
16:49:57 <lambdabot> Title: User:Gwern/kenn - HaskellWiki
16:50:01 <gwern> for a first draft, it's not too bad
16:50:02 <Cale> My example has as objects all the statements of arithmetic, with an arrow A -> B if there's a proof A implies B. It's possible to prove "A or not A" for any A, but there are statements which are undecidable.
16:50:28 <Pseudonym> Oh, good example.
16:50:33 <dibblego> is the Prelude of Haskell' going to have (++) = mplus and (.) = fmap?
16:50:42 <Pseudonym> Hmm.
16:50:56 <Pseudonym> So let me think here.  Is this Goedel's statement in category theory form?
16:51:02 <gwern> dibblego: unlikely, I think. sounds too radical for them
16:51:06 <mmorrow> Cale: ooh, nice
16:51:10 <Cale> I suppose that it is, in some sense.
16:51:20 <dibblego> gwern, it's just really pissing me off at the moment :)
16:51:20 <gwern> maybe haskell-2
16:51:25 <EvilTerran> i'm unconvinced that haskell' will ever evolve into a formal successor for haskell
16:51:38 <dons> as in, written down and published?
16:51:57 <gwern> dibblego: at this point, I'd be happy with haskell' just finishing
16:51:57 <EvilTerran> but we may get various haskell-alikes using various combinations of ideas from the haskell' discussion
16:51:59 <dons> yes, there's no demand. and having standard flags for extensions + hackage, has given us 90% of the result.
16:52:04 <Philonous> Pseudonym: What did/do you study?
16:52:30 <vininim> you have the specification!
16:52:39 <vininim> (and good luck with that =D )
16:52:53 <Pseudonym> Philonous: In maths?  Lots of applied maths (maths methods, advanced calculus-type stuff) and logic/discrete.  Oh, and a fair bit of stats.
16:53:07 <Pseudonym> The rest is my own reading.
16:53:09 <Pseudonym> And stuff I picked up in CS classes.
16:53:23 <Philonous> So you studied math?
16:53:35 <Pseudonym> Like, for example, I learned what a semilattice was in CS classes, not maths.
16:54:03 <Pseudonym> Philonous: Actually, physics witha  minor in computer science, then in second year I switched the other way around.
16:54:13 <Philonous> I see
16:54:16 <Pseudonym> So I ended up with CS with a minor in physics.
16:54:31 <Pseudonym> And a bit of linguistics for good measure.
16:54:36 <roconnor> but we should get Caleskell soon, right?
16:54:52 <Philonous> *g* No philosophy?
16:54:56 <Pseudonym> Caleskell is a bunch of libraries.
16:55:04 <Pseudonym> Sadly, no.
16:55:31 <Pseudonym> This was a while ago, mind you.
16:55:36 <Pseudonym> I missed out on the whole quantum computing trend.
16:57:26 <Philonous> Strangely, it's like CS, physics, math, lingu and philosophy always come bundled. They must be connected somehow :>
16:57:35 <Pseudonym> They are!
16:57:41 <Myoma> o_O
16:57:50 <ddarius> They indeed are.
16:58:08 <Pseudonym> http://tunes.org/~nef/logs/haskell/
16:58:12 <Cale> Okay, here's another thing that's been bothering me... suppose we have a CCC + coproducts. Then it's rather easy to get a map (AxB)+(AxC) -> Ax(B+C). However, the reverse direction is not so easy. I don't care that the composition is the identity, is there any way to do it? Are there simpler assumptions I can put on my category to ensure there is an arrow in the opposite direction?
16:58:13 <lambdabot> Title: Index of /~nef/logs/haskell
16:58:14 <Pseudonym> Whoops, wrong link.
16:58:20 <Pseudonym> http://math.ucr.edu/home/baez/rosetta.pdf
16:58:22 <gwern> obviously the commonality is category theory
16:58:23 <lambdabot> Title: Physics, Topology, Logic and Computation: A Rosetta Stone
16:58:23 <Pseudonym> That's it.
16:59:09 <Pseudonym> Linguists haven't discovered category theory yet, despite having discovered unification.
16:59:26 <Myoma> and reified continuations and dependent types
16:59:30 <Philonous> But they appear to love the lambda calculus
16:59:43 <Cale> It seems that a Distributive category is exactly the case where the map (AxB)+(AxC) -> Ax(B+C) is an isomorphism...
17:00:04 <gwern> I wonder why I hardly ever hear about anyone using pandoc?
17:00:07 <gwern> seems pretty useful
17:00:35 <Pseudonym> What about cases where (A+B)x(A+C) -> A+(BxC) is an isomorphism?
17:00:52 <gwern> pandoc only needs a few more improvements and then we could autonmatically convert The monad reader articles into wiki articles. pretty neat imo
17:01:07 <dons> gwern: that's awesome.
17:01:18 <dons> gwern: do you want my auto-upload script for the wiki?
17:01:23 <gwern> indeed. doing it by hand is very buggy and tedious
17:01:25 * gwern knows
17:01:44 <Pseudonym> @djinn (Either a b, Either a c) -> Either a (b,c)
17:01:45 <lambdabot> f (a, b) =
17:01:45 <lambdabot>     case a of
17:01:45 <lambdabot>     Left c -> Left c
17:01:45 <lambdabot>     Right d -> case b of
17:01:45 <lambdabot>                Left e -> Left e
17:01:47 <gwern> dons: no, not yet.
17:01:47 <lambdabot>                Right f -> Right (d, f)
17:02:56 <ddarius> Cale: I think CCC + coproducts already implies distributive or are you asking if you can drop the 'closed' part?
17:02:58 <gwern> dons: so what do you advise I do with all the abandoned xmonad/xmc patches? wait until after 0.8 to agitate for them?
17:03:12 <Cale> ddarius: oh?
17:03:45 <Cale> ddarius: I was having trouble constructing the map in the other direction, but maybe I'm just not seeing something obvious.
17:04:05 <ddarius> Unless I'm just wrong and it's not possible, I don't think it is very obvious.
17:04:25 <Cale> hmmm...
17:04:48 <Cale> any idea where I could find a proof that CCC+coproducts => distributive? That would be really nice to see.
17:05:06 * Pseudonym asks Asperti and Longo
17:05:07 <Cale> (and would straighten things out with my intuition)
17:05:23 * ddarius asks Pitt.
17:06:37 <lament> "Shipping estimate for these items: Oct 1 2008" woo!
17:07:27 * BMeph will wait for the weekend before pre-ordering RWH
17:08:31 <dons> dcoutts: did i tell you about my "haskell christmas campaign" vision? haskell platform, RWH released, #1 on the quad core shootout. i think we can knock those off, and we'll be in a good position for next year.
17:08:57 <Cale> Oh, grr... this result appears in a book on google books, but the proof is on a page which is not included.
17:09:05 <Cale> But that's a good sign that it's true :)
17:09:17 <ddarius> Yeah, unless I'm misreading this, Andrew says CCC + coproducts => distributivity
17:09:37 <ddarius> The proof term, I imagine, is similar to a Church encoding.
17:12:26 <Pseudonym> OK, I fiound a proof.
17:12:27 <ajdhs> is there a "deepSeq" function?
17:12:53 <EvilTerran> ajdhs, yes, but it requires a typeclass
17:13:03 <Pseudonym> ftp://ftp.di.ens.fr/pub/users/longo/CategTypesStructures/6Lim.ps.gz
17:13:05 <Pseudonym> It's corollary 6.4.4.
17:13:10 <ajdhs> ah
17:13:12 <ajdhs> which one?
17:13:25 <sbahra> dons, quad-core shootout?
17:13:30 <ajdhs> oh, like a "deepSeqable" class?
17:13:33 <MyCatVerbs> EvilTerran: er, what about rnf?
17:14:10 <ddarius> Pseudonym: Screw books.
17:14:36 <dons> sbahra: yo, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
17:14:43 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® Computer Language Benchma ..., http://tinyurl.com/55nbs6
17:15:02 <dons> currently just implementations that will run on 64 bit/quad core, few (no?) programs have been parallelised.
17:15:05 <sbahra> Q6600?
17:15:07 <sbahra> hmmm
17:15:15 <sbahra> dons, I could offer some hours on a 16-core machine
17:15:16 <lament> BMeph: what happens on the weekend?
17:15:24 <Cale> Pseudonym: awesome, thanks :)
17:15:34 <MyCatVerbs> Oh, blast. rnf requires a typeclass? Bah. :/
17:15:37 <dons> sbahra: oh, interesting. i think bos was looking for some 16 core machine for benchmarking
17:15:38 <sbahra> dons, but you guys might have to add a thank you note for that in order for me to convince my lab to allow that ;-p
17:15:40 <Pseudonym> I have a stolen paper copy of this book.
17:16:15 <Myoma> stolen paper ?
17:16:29 <sbahra> dons, ok. If you guys have immediate plans or anything, please tell me and I can add some accounts.
17:16:50 <sbahra> dons, I cannot provide access until the 22nd of September though.
17:16:56 <sbahra> After that is fine
17:18:06 <jeffersonheard> I know someone earlier today mentioned running Cairo on windows
17:18:10 <jeffersonheard> that there was this obvious fix
17:18:42 <sbahra> dons, there's also a really nice IA64 machine I want to get rid of, personally
17:18:53 <sbahra> I offered earlier, no one really stepped up.
17:19:01 <dons> sbahra: interesting. did you ask on haskell-cafe@ ?
17:19:18 <dons> the ghc guys do have access to a 16 core amd64 box, currently
17:21:14 <jeffersonheard> does anyone know how to get Cairo, libglade, and gtk2hs working on Windows?
17:21:32 <ddarius> :t uncurry (either (curry Left) (curry Right))
17:21:35 <lambdabot> forall a b b1. (Either a b, b1) -> Either (a, b1) (b, b1)
17:21:40 <ddarius> voila
17:22:01 <Myoma> cool
17:22:16 <Myoma> ?djinn (Either a b, b1) -> Either (a, b1) (b, b1)
17:22:16 <lambdabot> f (a, b) =
17:22:16 <lambdabot>     case a of
17:22:16 <lambdabot>     Left c -> Left (c, b)
17:22:16 <lambdabot>     Right d -> Right (d, b)
17:22:31 <Myoma> :t curry Left
17:22:32 <lambdabot> forall a b b1. a -> b -> Either (a, b) b1
17:23:39 <Myoma> :t curry
17:23:41 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:24:50 <jeffersonheard> n/m, got it
17:25:37 <newsham> jefferson: i havent tried recently but in the past gtk2hs binary package "just worked" when i installed it in win32
17:26:22 <jeffersonheard> newshan, yeah.  It was a simple matter of restarting the console to grab the new environment after installing it
17:27:05 <ddarius> Cale: One nice thing about Inkscape is that I can use it as an infinite virtual pad of paper.  Unfortunately it has some bug or just poor combination of behaviours that makes it annoying to pan.
17:27:07 <newsham> sbahra: what kinda ia64 box?
17:27:19 <Cale> ddarius: hmm
17:27:28 <BMeph> lament: My monthly disability check comes in. :)
17:27:29 <sbahra> newsham, Itanium 2
17:27:31 <sbahra> newsham, 8GB RAM
17:27:34 <sbahra> newsham, 8MB L3
17:27:44 <sbahra> newsham, nVidia Quadro 2 (not really relevant)
17:27:51 <sbahra> newsham, 1 network card (I forget what kind)
17:27:55 <Cale> ddarius: Middle mouse button drag doesn't work?
17:27:57 <sbahra> newsham, 80GB HDD
17:28:37 <newsham> i always thought haskell + itanium could be pretty cool
17:29:05 <ddarius> It works, but if the pen goes to far from the pad while panning it seems to snap up and to the left rather than staying put (which is what happens in Gimp).
17:29:10 <roconnor> what's the difference between git pull and git merge?  -- learning git
17:29:34 <Cale> hmm
17:29:44 <Cale> I don't have a tablet, so I don't know...
17:30:11 <ddarius> Also, left+middle = zoom or something so if I touch the pad just before panning I end up zooming
17:30:49 <BMeph> ddarius: Thanks - I'm reading P&R now. :)
17:31:04 <ddarius> BMeph: It's nifty and short.
17:31:11 <heavensrevenge> hello
17:31:58 <heavensrevenge> i was wondering, has anyone tried to get GPU computations comping from haskell/lambda calculus??
17:32:48 <heavensrevenge> or just compile the lambda calculus into that CUDA, in order to get the GPU doing stuff instead of making the general purpose CPU doing everything?
17:32:55 <BMeph> ddarius: It's short, but it also has a ten-and-a-half page bibliography... o.O
17:33:45 <BMeph> dons: Do you know what's Debian's problem with regex-posix? It's been bombing out on the shootout for a while...
17:33:48 <heavensrevenge> if its so far been untouched, id love to try and get GHC to compile GPU stuff to cooperate with the CPU
17:33:57 <hansfbaier> dons: I compiled ghc 6.8.3 now on OpenBSD using the latest fastcgi on hackage, but my test fcgi app still dies every 10 requests or so, independent of the webserver Apache / lighttpd
17:34:04 <jeffz> heavensrevenge: yes, someone is working on it for nvidia cuda I think.
17:34:20 <heavensrevenge> coolness :)
17:34:32 * Cale wonders if he can get a PDF or something of Awodey's Category Theory :)
17:34:33 <heavensrevenge> if not i would have attempted to get that going
17:34:34 <sbahra> newsham, yeah, you can do some very nice things with functional languages and EPIC
17:34:39 <sbahra> newsham, I could imagine, that is :-)
17:35:19 <heavensrevenge> have some sort of GHC thing that factors in GPU able computations, and toss them at it instead of just letting the CPU handle it
17:35:53 <heavensrevenge> that would really kick some ass
17:36:11 <BMeph> Cale: Anything in particular? :)
17:36:23 <Cale> http://home.aubg.bg/faculty/AGanchev/Category%20Theory/Awodey/Cats%20for%20Everybody.pdf in particular looks good :)
17:36:34 <lambdabot> Title: Categories for Everybody, http://tinyurl.com/5frw8n
17:36:43 <dons> BMeph: just not installed, i think
17:36:45 <Cale> (It's a draft, but whatever :)
17:36:55 <dons> hansfbaier: very weird.
17:36:56 <dons> :/
17:37:06 <Cale> It contains a nice proof of that distributivity result.
17:38:13 <jrh> heavensrevenge, if you actually go down that road, let me know.  I started to, but the lack of recursion in CUDA made me go find something else to be distracted over
17:38:42 <Cale> (which uses Yoneda)
17:38:43 <jrh> with the latest in UArray, there might be a better way to go about it.  Right now, I just use shaders for my GPGPU stuff
17:38:51 <ddarius> The quick way of proving it is to say in a CCC Ax- is a left adjoint and thus preserves coproducts.
17:39:01 <hansfbaier> dons: Do you have an idea what I could do to further track down the problem (I opened all ulimits). Seems to be a problem in interaction with Haskell <-> OpenBSD kernel since the behavior is independent of Web-Server / ghc + fastcgi version
17:39:04 <heavensrevenge> well i didnt really mean general computations tho
17:39:24 <hansfbaier> dons: Debugging the script with ghci, tracing.... ?
17:39:30 <heavensrevenge> i was thinking some sort of pragma that would delimit a gpu block
17:39:55 <heavensrevenge> or something that would only do specific things
17:40:13 <dons> hansfbaier: hmm. are you running in ghci, or compiled fastcgi code?
17:40:19 <dons> we may need to get a syscall trace
17:40:25 <heavensrevenge> instead of being general purpose, since there is both a CPU and GPU, if only a cpu was able, then so be it, but if a gpu was around, then use that too
17:40:33 <heavensrevenge> alot of untapped power
17:41:08 <jrh> heavensrevenge: better to look at Data Parallel Haskell and build on it.  there's already a model for data parallelism in Haskell, and it's just a matter of writing something that will use a GPU on the backend when possible.
17:41:36 <jrh> all that could be handled in a monad rather than some kind of special pragma
17:41:47 <dons> seanl's phd topic
17:42:04 <heavensrevenge> then again CUDA bindings when translated into that C-- may be workable too
17:42:11 <jeffz> iirc seanl said he's releasing something soon
17:42:13 <heavensrevenge> i just had this thought last night
17:42:36 <dons> yeah, he is finishing an internship at nvidia
17:42:50 <dons> he'll be giving a tech talk next week at galois about it
17:42:51 <jrh> Dons: is he in the Raleigh area, then?
17:42:55 <dons> i'll try to get the slides online.
17:42:56 <heavensrevenge> awesome stuff
17:43:06 <dons> jrh, he's in santa clara currently.
17:43:17 <dons> for the next two weeks, then back to .au
17:43:18 <jrh> Ah, alright.  We have nVidia offices here as well
17:43:22 <dons> ic.
17:43:26 <heavensrevenge> if the Haskell camp can use a GPU for stuff, then were sure to bring alot more people over :P
17:43:35 <dons> heavensrevenge: for sure.
17:43:39 <dons> more data parallelism!
17:43:50 <dons> ?go data parallel haskell!
17:43:56 <heavensrevenge> yea, a couple hundred thousand internal GPU threads
17:43:58 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
17:43:58 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
17:44:01 <medfly> haskell cant use a GPU? why am i learning this language?
17:44:17 <medfly> :-p
17:44:19 <_ar> is it possible to do a comparison test for NaN?
17:44:37 <dons> ?hoogle isNAN
17:44:37 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
17:44:38 <jrh> I have access to a massively parallel GPU machine, BASS that's got 28 nVidia QuadroPlexes and 128 AMD cores.  Be fun to do some genetics work in it using DPH
17:44:39 <dcoutts> dons: "haskell christmas campaign" eh :-) sounds good.
17:44:51 <_ar> dons: thanks
17:44:51 <heavensrevenge> damnit... now i need some other interesting thing to work on
17:44:56 <BMeph> ddarius: So, when are you posting the "You could have invented adjoints (..."? :)
17:45:04 <heavensrevenge> since Haskell + gpu = taken :(
17:45:13 <dons> dcoutts: i think RWH will be a big deal (at least, similar was the case for erlang), so if we time that with the platform push, and some shootout parallelism buzz
17:45:16 <dons> then all is good.
17:45:23 <BMeph> s/"?/" blog article?/
17:45:35 <dcoutts> dons: aye, so I'll get that hackage-server released then
17:45:37 <dons> dcoutts: maybe have some people actually learn the damn language :)
17:45:40 <Pseudonym> heavensrevenge: I'm sure that Haskell + GPU isn't _completely_ taken.
17:45:42 * dons -> home
17:46:01 * jrh grins at someone asking for something interesting to do.  
17:46:17 <heavensrevenge> lol
17:46:24 <jrh> there's always those OpenGL 3 bindings.  I'm sure Sven would love help with that.
17:46:42 <newsham> arent there some libs for running numeric computations on gpus?
17:46:46 * BMeph thinks the HCC should have a red sphere w/ a green lambda for its sigil
17:47:06 <heavensrevenge> not really to do, but to innovate beyond current knowledge
17:47:23 <jrh> newsham, yes -- you could use CUBLAS or the CUDA LAPACK.  Also, haskell can handle a lot of the stuff on gpgpu.org, since it uses Cg and shaders
17:47:24 <hansfbaier> dons: compiled fastcgi code....
17:47:38 <newsham> http://graphics.stanford.edu/projects/brookgpu/
17:47:39 <lambdabot> Title: cb BrookGPU
17:48:05 <heavensrevenge> we really need tutorials for this GPGPU stuff....
17:48:16 <hansfbaier> dons: When I compile the fcgi app, I get the following warnings: /usr/lib/libfcgi.so.0.0: warning: strcpy() is almost always misused, please use strlcpy()
17:48:17 <hansfbaier> /usr/lib/libfcgi.so.0.0: warning: sprintf() is often misused, please use snprintf()
17:48:23 <newsham> no chapter in rwh for gpu stuff? ;-)
17:48:38 <heavensrevenge> that would have RULED
17:48:49 <heavensrevenge> hold the presses, shove some GPU stuff into rwh
17:49:20 <Pseudonym> That's going to be in the sequel, "So now you're a Haskell expert".
17:49:39 <jrh> ha.  Maybe I'll work up a tutoral for DEFUN 2009
17:49:45 <newsham> that and hopefully a chapter on changing the world with FRP
17:49:53 <heavensrevenge> that would rule so horribly much
17:50:00 <Myoma> I thought that was linear types
17:50:07 <ddarius> BMeph: I have several pages of crap written and I had made several of the figures, but I need to figure out how to blend things the way I want to.
17:50:22 <heavensrevenge> DUE, we need to make codecs, nd compression algorightms and shit with this GPU business
17:50:47 <heavensrevenge> really make something awesome with it, something that should matter to people ;)
17:50:49 <BMeph> ddarius: ...and Inkscape isn't behaving as it ought for you, eh? :)
17:50:57 <Myoma> heavensrevenge: well get working!
17:51:10 <heavensrevenge> i just started learning!!
17:51:20 <heavensrevenge> im fascinated so i try to think of new stuff
17:51:36 <heavensrevenge> chapter 8 in "Programming in Haskell"
17:54:31 <Cale> Oh, wow, the proof of the existence of the distributivity isomorphism in Awodey's book is rather enlightening in terms of the use of Yoneda's lemma.
17:54:50 <ddarius> BMeph: All the figures I wrote were made a month ago.
17:55:39 <Myoma> Yoneda's lemma
17:56:23 * jrh resists the urge...
17:56:31 * jrh is still resisting...
17:56:43 <jrh> nope.  "Yo momma's lemma."
17:56:58 * Myoma success
17:57:10 <Cale> Set^(C^op) can be seen as a kind of extension of C by ideal elements which make the category nicer (complete, cocomplete, cartesian closed, etc.), and permits some calculations that can't be done in C.
17:58:24 <Pseudonym> So it's the All Your Constructions Are Belong To us theorem.
17:59:14 <Cale> The existence of an isomorphism yA = yB implies that A = B, so you can pull results back down too :)
17:59:22 * BMeph wonders about the connection b/t Yomama's Lemma and the Snakes-on-a-Plane Lemma...
17:59:59 <Pseudonym> That would be that there are too many mf operations on this mf derived category?
18:00:04 <ddarius> That last corollary is -constantly- used.
18:00:27 <Myoma> what is y?
18:00:51 <ddarius> And the proof of (A^B)^C ~ A^(BxC) and of Ax(B+C) ~ AxB+AxC is exactly the style of proof I prefer.
18:01:00 <Cale> The functor C -> Set^(C^op)
18:01:05 <ddarius> Myoma: Hom(=,-)
18:02:01 <ddarius> I might need to replace/add some of my proofs in my -other- CT-paper-that-just-sits-there.
18:03:21 <ddarius> Actually, I don't.  Yay me.
18:04:38 <ddarius> My proof of distributivity is essentially "cocontinuity of left adjoints" and my proof of (A^B)^C ~ A^(BxC) is the same as that one only backwards.
18:06:14 <ddarius> I didn't explicitly connect it to Yoneda though Yoneda is the first section of content in my article and I state that I'll tacitly use YA~YB to prove A~B
18:07:13 <bjrn> Pierce's "Category theory for computer scientists" is pretty good. Have only studied a few pages this far tho.
18:07:35 <BMeph> Pseudonym: ROFLs with syrup! :)
18:10:20 <TomMD> "Green, renewable monads"  I like that.
18:10:32 * stepcut wishes the hackage atom feed included changelogs :(
18:11:13 <ddarius> So... any open source, easy to use OCR-from-handwritten-notes software ... ?
18:12:08 <stepcut> reCaptcha ? ;)
18:12:45 * BMeph waits to see ddarius "Get Down With the (Adjoint) Sickness"...
18:14:11 <Myoma> cabbage crates coming over the briny
18:14:22 <Myoma> @quote
18:14:23 <lambdabot> DavidRoundy says: ... the fun of haskell-cafe is that it's where all the cool people hang out
18:14:43 <Myoma> @quote
18:14:44 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexadecimal.
18:14:58 <vininim> lol
18:17:23 <seanmce> @check ((\x -> if x == 0.0 then True else let y = 1.0 / x in x*y == 1.0)::Double->Bool)
18:17:24 <lambdabot>  "Falsifiable, after 59 tests:\n7.9411764705882355\n"
18:17:41 <heavensrevenge> just wondering... but is there anything in this current time that thinks beyond the desktop market??
18:17:46 <seanmce> is there a package that could do this problem without floating point errors?
18:17:53 <heavensrevenge> maybe for scientific computing?
18:18:19 <Myoma> seanmce: You want numbers which can be divided by zero?
18:18:19 <heavensrevenge> im trying to figure out if everyone is in the desktop rut
18:18:23 <ddarius> @chek ((\x -> if x == 0.0 then True else let y = 1.0 / x in x*y == 1.0) :: CReal -> Bool)
18:18:24 <lambdabot>      No instance for (Arbitrary CReal)
18:18:25 <lambdabot>       arising from a use of `myquickch...
18:18:39 <Myoma> @check ((\x -> if x == 0.0 then True else let y = 1.0 / x in x*y == 1.0)::Rational->Bool)
18:18:41 <lambdabot>  "OK, passed 500 tests."
18:18:46 <heavensrevenge> its not quite Haskell related... but id like something beyond the desktop to be coded in Haskell indeed
18:18:55 <seanmce> great thanks
18:18:57 <heavensrevenge> im curious as to what is left in computing??
18:19:00 <Myoma> ?
18:19:18 <Myoma> > 1%0
18:19:21 <lambdabot>  mueval: *** Exception: Ratio.%: zero denominator
18:19:37 <bjrn> heavensrevenge: self-awareness. Think Mike.
18:19:45 <heavensrevenge> like, neural networks
18:19:56 <heavensrevenge> artificial intelligence basically?
18:19:58 <Myoma> how about programs that actually work?
18:19:59 <Myoma> I'd like that
18:20:03 <heavensrevenge> hehe win a game of hardcore Go
18:20:19 <vininim> regardless there is a lot "left in computing"
18:20:23 <b\6> yeah, "what's left" is such a crazy question.
18:20:40 <heavensrevenge> im asking since i cant really see it at the moment
18:20:41 <Myoma> we've not even scratched the surface yet
18:20:50 <Myoma> but written tonnes of non-working crap -- that's for sure
18:20:54 <heavensrevenge> beyond the desktop
18:21:14 <vininim> how is desktop relevant?
18:21:20 <stepcut> reversible computing!
18:21:26 <heavensrevenge> well, many things right now seem focused on the desktop
18:21:28 <ddarius> The desktop market is a very small part of commercial computing
18:21:35 <heavensrevenge> or to do something for it, other than fortran and matlab
18:21:37 <Myoma> yeah the reversible stuff is really cool
18:21:49 <stepcut> heavensrevenge: do you include web sites/applications in the desktop category ?
18:21:50 <heavensrevenge> database stuff
18:22:20 <heavensrevenge> kind of yea, id group the whole accessable knowledge of the internet as focused at the dewsktop market
18:22:23 <vininim> I don't see how encoding peano numbers in type systems is desktop related, and that's what most haskell programmers do. ;)
18:22:59 <heavensrevenge> nuclear physics id say not
18:22:59 <Philonous> @check \x y -> curry fst x y == \x y -> const x y
18:23:01 <lambdabot>      Overlapping instances for Show (a -> b -> a)
18:23:01 <lambdabot>       arising from a use of...
18:23:05 <b\6> need to make a haskell program that generates monad tutorials to save people all that effort.
18:23:28 <heavensrevenge> but really , what is there left to create?
18:23:45 <b\6> come on! we're in the infancy of computing.
18:23:46 <heavensrevenge> globally humongous systems, modular for running cities and such?
18:23:50 <ddarius> main = putStrLn "http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps"
18:24:04 <Myoma> @check \p q -> let f === g = f p q == g p q in (\x y -> curry fst x y) === (\x y -> const x y)
18:24:05 <lambdabot>  "OK, passed 500 tests."
18:24:15 <heavensrevenge> thats what id like to see, what is after the infance we are in now
18:24:25 <ddarius> heavensrevenge: Wait 50 years.
18:24:26 <heavensrevenge> so far, most apps in C are fine and do their job
18:24:37 <heavensrevenge> id like to see the next sage and prepare or start making things for it
18:24:54 <b\6> we must live on different planets.
18:24:58 <heavensrevenge> the inevitable next step in computing i want to code in Haskell :P
18:25:00 <b\6> i see almost no software working correctly.
18:25:09 <heavensrevenge> thats all C tho lol
18:25:30 <heavensrevenge> well C type Unix focused languages
18:25:34 <Philonous> Myoma: Thanks, though I have not the slightest Idea what makes your test work and mine fail
18:25:41 <Philonous> But I will figure it out tomorrow
18:25:59 <heavensrevenge> are we left with just bug fixing whats already been created?
18:26:06 <Myoma> @check \x y -> curry fst x y == const x y
18:26:07 <lambdabot>  "OK, passed 500 tests."
18:26:20 <Olathe> heavensrevenge: We can also snore a lot.
18:26:24 <Philonous> Oh, I see my error
18:26:36 <heavensrevenge> ahem.. software related
18:26:51 <vininim> you can improve the software.
18:26:52 <seanmce> No instance for (Arbitrary (Ratio Integer))?
18:27:15 <seanmce> I seems to be misssing the quickcheck code for rational?
18:27:21 <ddarius> Crap.  I forgot what I was doing.
18:27:29 <heavensrevenge> so... no actual innonvations are gonna happen unless a new superior architecture for computing is created??
18:27:33 <Olathe> heavensrevenge: It seems like you're saying that there's a problem, and the problem is that we've got what we need.
18:28:02 <heavensrevenge> thats pretty close Olathe
18:28:26 <heavensrevenge> we have quite complete desktop systems, buggy as hell, but it exists
18:28:29 <_ar> heavensrevenge: take a breath and relax for a moment
18:28:31 <Olathe> Well, alright.
18:28:44 <Olathe> I'll work on my personal life then.
18:29:02 <heavensrevenge> software oriented...
18:29:24 <vininim> From the HCI point of view, we're far from complete. And I don't see what is the fuzz around desktop when you consider software engineering in the large.
18:29:25 * BMeph waits in trepidation, for the dawn of the adolescence of computing
18:30:13 <heavensrevenge> HCI?
18:30:28 <clanehin> human computer interaction
18:30:33 * dufflebunk doesn't want his adolescent computing to have mood swings
18:30:38 <heavensrevenge> yea, id like to spark the adolecence of computing, screw being stuck in the infancy
18:31:46 <heavensrevenge> ooh bio computer interaction sounds good
18:31:50 * BMeph plans on taking the bus, when the adolescence of computing learns how to drive...
18:32:17 <_ar> the bus is a bigger target
18:32:19 <Twey> heavensrevenge: But new architectures for computing *are* being created.
18:32:24 <_ar> easier to hit
18:32:41 <mmorrow> i can't wait until we can compute on what makes up reality
18:32:44 <Olathe> Well, I think that, if being easier to hit is important, we need a barn.
18:32:47 <heavensrevenge> lol
18:32:48 <mmorrow> to obad i'll be long dead
18:32:59 <BMeph> _ar: Exactly - hit the bus, not every single passenger IN the bus! ;)
18:33:11 <heavensrevenge> hmm... so noone wants to work on the futuristic stuff from having too long term of a benefit?
18:33:25 <BMeph> Olathe: With extra-broad sides? ;)
18:33:28 <Olathe> What happens when the bus learns how to drive itself and doesn't need the adolescent computing field ?
18:33:34 <Olathe> What then ?!
18:33:39 <ddarius> mmorrow: http://www.ted.com/index.php/talks/aubrey_de_grey_says_we_can_avoid_aging.html
18:33:46 <lambdabot> Title: Aubrey de Grey says we can avoid aging | Video on TED.com, http://tinyurl.com/5dx28w
18:33:53 <heavensrevenge> artificial intelligence is still the forefront?
18:33:59 <heavensrevenge> and neural networks
18:34:12 * mmorrow is intrigued
18:34:33 <Olathe> I need a computer to clean my house and do my laundry.
18:34:42 <Olathe> I think that can be the adolescence of computing.
18:34:44 * BMeph thinks the adolescence of computing will bring a whole new definition to "mental masturbation"...
18:34:49 <Olathe> Hahaha
18:34:59 <heavensrevenge> so we need computers to be able to take out place in order to move forward??
18:35:13 <heavensrevenge> but wouldnt that just cause us to lose ground and get lazier?
18:35:13 <Olathe> No, we have cars to move us forward.
18:35:21 <vininim> I wonder where you do want us to move.
18:35:24 <ddarius> Olathe: And trebuchets
18:35:26 <heavensrevenge> since computers can do our mental work for us
18:35:35 <Olathe> If we lost the ground, we'd certainly get lazier since we'd have to sit up in a tree.e
18:35:47 <BMeph> heavensrevenge: Well, we don't _need_ it to be such, but it sure sounds fun... ;)
18:35:51 <heavensrevenge> well im interested in what actually may be the next stepin computing
18:36:08 <heavensrevenge> Olathe previously said what i was meaning
18:36:24 <heavensrevenge> we've got what we need, was pretty close
18:36:34 <vininim> you might want to use the divide and conquer stratey and learn what is happening in each sub-field of computing.
18:36:35 <Myoma> hardly...
18:36:38 <heavensrevenge> really... what else are we gonna do?
18:36:47 <BMeph> vininim: "Trebuchet Computing: Moving Humanity (and old Volkswagens) Forward" ;)
18:36:48 <heavensrevenge> just artificial intelligence?
18:37:25 <heavensrevenge> task completion seems pretty trivial
18:37:45 <vininim> heavensrevenge: no, we still need to make haskell+ghc wins the shootout
18:37:51 <vininim> the rest is moot
18:37:52 <heavensrevenge> task execution? task creation?
18:37:56 <Olathe> The shootout is moot !
18:38:08 <Olathe> This whole court is moot !
18:38:14 <heavensrevenge> lol well there are a few areas were 3x slower than C, when those kick ass we win, not far
18:38:15 <_ar> someone should have told aubrey de grey about thermodynamics
18:38:34 <heavensrevenge> OH megnetohydrodynamics is a fun word to say ;)
18:38:47 <vininim> _ar: in b4 sun
18:39:14 <ddarius> _ar: We have plenty of energy.
18:39:46 <heavensrevenge> *magnetohydrodynamics
18:40:31 <heavensrevenge> i think with the current architectures, weve gone almost as far as we can
18:40:37 <_ar> b4 sun? ddarius: if you look at his graph he's got people living forever... you have to extrapolate a little but it's easily exponential
18:40:45 <heavensrevenge> we got screwed when moores law started leveling off
18:41:03 <ddarius> Moore's law has not leveled off
18:41:30 <Olathe> > what
18:41:32 <lambdabot>  mueval: mueval: mueval: mueval: mueval: mueval: mueval: mueval: mueval: muev...
18:41:33 <heavensrevenge> single core got screwed pretty badly
18:41:43 <heavensrevenge> cant reach all of the chip on 1 clock cycle
18:42:03 <Twey> Olathe: O.O
18:42:37 <ddarius> > var $ cycle "mueval: "
18:42:41 <lambdabot>      Ambiguous occurrence `var'
18:42:43 <lambdabot>     It could refer to either `Data.Number.Sym...
18:42:46 <Twey> Heh
18:43:26 <heavensrevenge> were being forced to go multicore since single core isnt gonna work, instruction level parallelism and clock cycles cant move forward much further right?
18:44:10 <ddarius> Moore's law simply says that the transistors per unit area double every 18 months
18:44:37 <heavensrevenge> crap..
18:45:01 <heavensrevenge> shit man i entirely screwed up that analogy
18:45:54 <heavensrevenge> i more of mean that performance curve since the i386 just after the VAX
18:46:34 <Myoma> I think you can write a pretty printer with a single fold
18:46:57 <heavensrevenge> well shit, ddarius u got me on that, i was applying moores law too something not directly meaningful
18:48:17 <heavensrevenge> ill stop picking your brains on that note, but the argument is still generally valid
18:49:06 <mmorrow> > "unsafe"
18:49:07 <lambdabot>  mueval: Unsafe functions to use mentioned.
18:49:23 <Myoma> hmmm
18:49:31 <Olathe> > uns afe
18:49:33 <lambdabot> Terminated
18:49:39 <Myoma> I think the glom bit of parsing and the prec levels in a fold can match up
18:49:44 <ddarius> > error . error . error . error $ "foo"
18:49:46 <lambdabot>  mueval: foo
18:49:49 <mmorrow> haha
18:49:50 <Myoma> how to get a relation between both algorithms though ...
18:50:02 <ddarius> > error . error . error . error $ cycle "mueval: "
18:50:18 <lambdabot>  thread killed
18:50:25 <mmorrow> > foldr (.) (`id`"foo") (repeat error)
18:50:27 <lambdabot>      Overlapping instances for Show (([Char] -> [Char]) -> [Char])
18:50:27 <lambdabot>       aris...
18:51:16 <ddarius> > toLower
18:51:18 <lambdabot>      Overlapping instances for Show (Char -> Char)
18:51:18 <lambdabot>       arising from a use o...
18:51:32 <mmorrow> > foldr (.) (`id`"foo") (repeat error) $ id
18:51:48 <lambdabot>  thread killed
18:51:51 <Olathe> > error.error.(take 100).cycle $ ".\n"
18:51:54 <lambdabot>  mueval: .
18:51:54 <lambdabot> .
18:51:54 <lambdabot> .
18:51:54 <lambdabot> .
18:51:56 <lambdabot> .
18:51:57 <mmorrow> > foldr (.) (`id`"foo") (repeat error) $ error
18:51:58 <lambdabot> [30 @more lines]
18:52:13 <lambdabot>  thread killed
18:52:44 <mmorrow> oh sweet, it'll do newlines
18:53:14 <ryant5000> is there anything, other than inconvenience, that would prevent one from replacing all types with type classes + type variables?
18:53:28 <L3v1> Hi all, I am new to both haskell and irc. Nice to meet you.
18:53:34 <vininim> is lambdabot using a new bot code?
18:53:35 <Myoma> hi :)
18:53:35 <ryant5000> L3v1: nice to meet you too
18:54:08 <Myoma> ryant5000: what would  Maybe (Maybe a) -> Maybe a  be?
18:55:56 <mmorrow> > drawForest . (fmap . fmap) show . concat  $ unfoldForestM_BF (\n -> return (n+1,if n + 1 < 4 then replicate n (n+1) else [])) [0..4]
18:55:59 <lambdabot>  "1\n\n2\n|\n`- 3\n   |\n   +- 4\n   |\n   `- 4\n\n3\n|\n+- 4\n|\n`- 4\n\n4\n...
18:56:02 <mmorrow> aww
18:56:09 <mmorrow> > error (drawForest . (fmap . fmap) show . concat  $ unfoldForestM_BF (\n -> return (n+1,if n + 1 < 4 then replicate n (n+1) else [])) [0..4])
18:56:12 <lambdabot>  mueval: *** Exception: 1
18:56:13 <lambdabot>  
18:56:13 <lambdabot> 2
18:56:13 <lambdabot> |
18:56:13 <lambdabot> `- 3
18:56:14 <lambdabot> [10 @more lines]
18:56:17 <mmorrow> ahaha
18:56:21 <ryant5000> Myoma: (Maybe b a, Maybe c b, Function d c b) => d
18:56:22 <ddarius> More error
18:57:08 <Myoma> ryant5000: I see, it seems quite a bit harder to read
18:57:20 <Myoma> ryant5000: but more importantly, I don't think it computes
18:57:27 <ryant5000> Myoma: right; it would be horrifically inconvenient
18:57:32 <ryant5000> really, how so?
18:57:41 <Myoma> but I mean, besides that, perhaps it wouldn't even work
18:57:51 <ryant5000> why not?
18:59:41 <BMeph> Myoma: What are you guys discussing? :)
18:59:57 <seanmce> I must be missing an import for the quickCheck. Can someone help. http://hpaste.org/9948
19:00:28 <ryant5000> BMeph: whether you can eliminate types (other than type variables) and use only classes
19:01:07 <ryant5000> and whether that would cause any problems aside from the obvious absurdly bad syntax
19:01:10 <Myoma> if typeclasses were a more expressive relational language that would actually compute, I suppose it would be practical
19:01:30 <ryant5000> Myoma: yeah, i kinda want to figure out a type system like that
19:01:48 <Myoma> ryant5000: me too
19:02:12 <ryant5000> i'm thinking very strongly about starting a haskell tools company
19:02:20 <ryant5000> but i'm wondering if there are going to be any customers :-/
19:02:34 * Myoma wonders what haskell tools would be
19:02:49 <ddarius> ryant5000: There have been at least two consultancies services for Haskell programs.
19:02:53 <ryant5000> Myoma: dev environments, game engines, anything like that
19:03:01 <ryant5000> any sort of middleware
19:05:14 <ryant5000> ddarius: how did they fare? one is galois, right?
19:05:41 <RobotGuy> Is Haskell one of those always evolving moving target kinds of languages?
19:05:47 <ddarius> No.  Galois is not a consultancy.
19:05:54 <Smokey`> lol, haskell used for a game engine - I'd love to see it's memory manager efficiently handle ~1gig of data during your average load of graphical assets.
19:05:55 <ryant5000> ah
19:06:15 <ryant5000> Smokey`: well, that's why they pay you for a game engine :P
19:06:19 <dufflebunk> Smokey`: Isn't most of that data just bitmaps?
19:06:32 * dufflebunk knows very little about game internals
19:06:33 <ryant5000> the game engine doesn't need to be written entirely in haskell (though that would be nifty)
19:06:47 <ddarius> Alistair Reid had one and did fine but was lured back to academia.  Bjorn Bringert, Duncan Coutts, and Ian Lynaugh just recently started another.
19:06:52 <adu> omg, I am really liking reading about Agda
19:06:56 <adu> I can't wait to try it!
19:06:59 <Smokey`> dufflebunk: generally it's compressed, so you're loading raw DXT3/5 off the hdd, then you've got the geometric data of the models, byte/source code for shaders, audio files, etc
19:07:52 <adu> although, i must not let Agda prevent me from workin on my type-checker :)
19:08:15 <Smokey`> dufflebunk: you'd be correct in assuming the 'textures' (images) are the bulk of the data loaded into memory though
19:08:18 <dcoutts> ryant5000: galois are not a general Haskell consultancy, they specialise in high assurance systems.
19:08:23 <ryant5000> Smokey`: that sounds like about 8 functions to write in C
19:08:32 <ryant5000> then you wrap them
19:09:04 <_ar> Smokey`: typically the memory on the graphics card.
19:09:11 <Smokey`> ryant5000: if you're going to use FFI, you might as well just write it all in C/C++ imo.  and write a wrapper for haskell.
19:09:21 <Smokey`> _ar: yes, but when you're 'loading' data frmo the HDD, it goes via RAM.
19:09:30 <dcoutts> ryant5000: Well-Typed are the first Haskell consultancy group afaik (as opposed to individuals / sole trader companies)
19:09:32 <ryant5000> Smokey`: i certainly would prefer to use haskell for anything multithreaded
19:09:44 <adu> Smokey`: buy why C?
19:09:50 <_ar> Smokey`: more like memory-mapped io
19:10:09 <ddarius> or DMA
19:10:14 <ryant5000> Smokey`: if for no other reason than haskell's incredibly cheap (compared to C) light-weight threads
19:10:16 <Smokey`> _ar: OpenGL and DirectX both require memory to be in DRAM before beginning a DMA transfer.
19:10:35 <ryant5000> Smokey`: i bet you can use memory-mapped files to kill that
19:10:47 <ryant5000> Smokey`: (though i'm not sure)
19:10:51 * RobotGuy wonders if his question was seen
19:11:08 <Korollary> Game engines, database engines usually milk the OS primitives for all their worth.
19:11:16 <adu> Smokey`: for graphics applications, loading is a very small portion of the workload. Most of the work is in threading and physics, imo.
19:11:22 <adu> Smokey`: and for threading C sucks:
19:11:23 <adu> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all
19:11:25 <_ar> Smokey`: either way shouldn't the allocation/deallocation time be in proportion to the number of assets and not their size (roughly speaking)
19:11:25 <lambdabot> Title: thread-ring benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchmark ..., http://tinyurl.com/2lyngq
19:11:33 <ddarius> RobotGuy: There are standards for Haskell.  If you want stability, stick to the standard.
19:11:53 <ryant5000> RobotGuy: haskell is evolving, but you don't have to turn on new features
19:12:01 <Guest45242> offloading the assests management to FFI/C shouldnt be all that complicated anyway
19:12:13 <RobotGuy> Hmmm
19:12:52 <adu> Smokey`: if anything you SHOULD be writing the majority of your physics stuff in Haskell precisely because it is #1 in terms of parallel computation
19:13:21 <_ar> Smokey`: besides 10 years from now when everyone does raytracing in real-time on their 128 core cpus it'll be much nicer in haskell
19:13:31 <adu> ya
19:13:51 <Guest45242> 128 core cpu wired into your eyeball
19:13:55 <Smokey`> adu: possibly, most physics engines have a lot of state involved in each and every individual object though... for optimizations like damping and 'sleeping' (freezing objects that aren't moving), etc.
19:14:14 <_ar> Smokey` heavensrevenge can fill you in on the future
19:14:16 <Smokey`> _ar: agreed, I've written a ray tracer in haskell - it was nice (code-wise) - just hella slow.
19:14:27 <ryant5000> Smokey`: state doesn't have to be slow in haskell (see, e.g., ST monad)
19:14:27 <Smokey`> (that said, it was very brute force, single threaded - and using GHC ~6.4)
19:14:35 <heavensrevenge> lol
19:14:40 <adu> lol
19:14:43 <heavensrevenge> i just looked back and i got a refrence ;)
19:14:56 <heavensrevenge> glad to instigate revolutions :)
19:15:15 <mmorrow> bring out the guillotine!!
19:15:25 <mmorrow> uh, i meant ..
19:15:44 <heavensrevenge> not hr#2.. you monster!
19:15:53 <mmorrow> the horror!
19:17:11 <adu> I can't wait until you can get a Gigacore in your watch
19:18:07 <ddarius> adu: You could do that today most likely.
19:18:16 <_ar> you'd still wish whatever was on your desk at that time was in your watch
19:18:27 <adu> 1,000,000,000 CPUs in your 5G GPS RFID 3D projector watch
19:18:39 <ryant5000> how hard would it be to write a CPU that natively runs some sort of haskell bytecode?
19:18:51 <Myoma> "haskell bytecode" ?
19:18:59 <ryant5000> a bytecode designed for haskell stuff
19:19:01 <adu> would that be like GHC Core Core?
19:19:10 <ryant5000> sure
19:19:23 <ryant5000> it seems like you could cut out a *ton* of die space
19:19:30 <ryant5000> by eliminating pipelining, etc.
19:19:33 * mmorrow tirelessly mentions the reduceron in hopes that someone will take it and run
19:19:43 <ryant5000> (since parallelism is so much easier)
19:19:51 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron2/
19:19:52 <adu> mmorrow: the what? reduceron?
19:19:54 <ddarius> adu: The Connection Machine in the 80's had 65k processors.  (We'll ignore that they were 1-bit processors.)
19:19:59 <adu> mmorrow: what is it?
19:20:03 <lambdabot> Title: The Reduceron
19:20:08 <ryant5000> ddarius: lol
19:20:34 <adu> mmorrow: wow
19:20:35 <mmorrow> it's code for an fpga which "becomes" a hardware graph reduction machine
19:20:55 <mmorrow> cpus are things of the past!
19:21:21 <adu> omg
19:21:26 <adu> i live in the future
19:21:30 <mmorrow> heh
19:21:30 <ddarius> Custom hardware has been tried for a variety of things repeatedly, usually failing.
19:22:03 <adu> ddarius: are you dissing my future?
19:22:37 <ryant5000> ddarius: it all depends on how much speed you can get from it
19:23:54 <adu> I think CPUs should be benchmarks on how many RSA-1024 they can factor in a decade
19:24:08 <ddarius> Most of the time people have tried to make hardware to support a particular language they've ended up being beaten by better compilation techniques on stock hardware.
19:24:21 <Twey> There's some catch to using accumulator arguments in Haskell, isn't there?
19:24:29 <ddarius> @wiki Stack_overflow
19:24:30 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
19:24:32 <Twey> What is it?  I've forgotten >.<
19:24:34 <Twey> Ah
19:24:35 <Twey> Thanks
19:24:52 <ddarius> @wiki Performance/Accumulator_parameter ?
19:24:53 <lambdabot> http://www.haskell.org/haskellwiki/Performance/Accumulator_parameter_?
19:24:57 <mmorrow> ddarius: definitely. i think it would be really cool to see code for an fpga which can reconfigure itself .. in a sense something analogous to a metacircular interpreter which can reconfigure itself both at the level of it's logical structure and the level of the hardware itself that it's running on
19:24:58 <ddarius> Doh
19:25:08 <waynemokane> my friends - may I please direct your attention to "Simple StateT use"?  http://www.haskell.org/haskellwiki/Simple_StateT_use
19:25:10 <lambdabot> Title: Simple StateT use - HaskellWiki
19:25:13 <Myoma> @w80 deborch
19:25:14 <lambdabot> No match for "deborch".
19:25:17 <smoofra> wouldn't it be fun if ghc recognised λ as \
19:25:17 <Myoma> @w80 deborche
19:25:19 <lambdabot> No match for "deborche".
19:25:29 <Myoma> smoofra: sed scritp
19:25:34 <ddarius> @wiki Performance/Accumulating parameter
19:25:34 <lambdabot> http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter
19:25:58 <ddarius> smoofra: Not for Greek speakers.
19:25:58 <waynemokane> in that example ^^ what would you call "pop"?  it feels like a function but doesn't really have a function type.  it looks more like a constructor but it's not under a data declaration
19:26:44 <Twey> It's an action, waynemokane
19:27:18 <Twey> A function of type StateT [Integer] IO Integer
19:27:19 <smoofra> ddarius: hah i guess not
19:27:32 <mmorrow> i mean, the whole advantage of an fpga is that you can do many many things in parallel. they don't even have to have the same clock speed or even be in synch at all
19:27:58 <mmorrow> oh
19:28:03 <smoofra> aww it won't even take it as a variable name
19:28:05 * mmorrow finds a link to this freaky paper
19:28:13 <Twey> @src ($!)
19:28:13 <lambdabot> f $! x = x `seq` f x
19:28:25 <ddarius> smoofra: It will with the right flag.
19:28:47 <waynemokane> an action, you say?  hmm
19:29:02 <waynemokane> I basically understand what it DOES I would just feel much happier knowing what to call it
19:31:17 <mmorrow> i don't remember where i got it from, but it's here: http://code.haskell.org/~morrow/evolved-fpga.ps
19:31:50 <mmorrow> one might describe it as "odd" or "hmm"
19:32:36 <Olathe> Ewww...a ps file.
19:33:23 <mmorrow> are you on windows?
19:33:27 <Olathe> Yes.
19:33:31 <phil--> DON'T TOUCH IT
19:33:37 <ddarius> It's called ghostviewer
19:33:40 * Olathe stops on a dime.
19:34:59 <mmorrow> too bad windows doesn't come standard or have a package manager to instantly install such a program as ps2pdf for free
19:35:26 <ddarius> Converting from ps to pdf can often produce crappy results (though sometimes it produces better results)
19:36:11 <mmorrow> http://code.haskell.org/~morrow/evolved-fpga.pdf
19:36:12 <lambdabot> Title: cache:http://code.haskell.org/~morrow/evolved-fpga.pdf - Google Search
19:36:20 <mmorrow> i always apply pdfopt
19:36:48 <mmorrow> dunno what exactly it's optimizing, but it makes me sleep better at night
19:37:15 * Twey laughs.
19:38:49 <blbrown> with glut/opengl applications, how do I enable stdout
19:40:07 <b\6> blbrown: enable it? nothing happened to it.
19:40:14 <aFlag> Hello, I'm trying to compile ghc 6.8.3 and when I hit ./configure I get checking for path to top of build tree... configure: error: cannot
19:40:18 <aFlag> determine current directory
19:40:32 <newsham> evolved fpgas paper neatoh
19:40:32 <aFlag> after looking at the configure script I found out it calls utils/pwd/pwd
19:40:43 <mmorrow> heh
19:40:45 <mmorrow> i did
19:40:50 <aFlag> when I execute it I get:
19:40:51 <aFlag> %utils/pwd/pwd forwardslash
19:40:52 <aFlag> Floating point exception
19:41:04 <aFlag> does anyone else have that problem?
19:41:04 <mmorrow> echo 'pwd' > utils/pwd/pwd
19:41:13 <mmorrow> fixed it right up ;)
19:41:43 <mmorrow> you may need to chmod 755 utils/pwd/pwd also
19:41:55 <Twey> http://hpaste.org/9949 -- how do I optimise this code so it doesn't blow up on big lists?
19:41:56 <aFlag> it's already executable
19:42:05 <mmorrow> (or maybe i did  echo -ne "#!/bin/sh\npwd" > utils/pwd/pwd
19:42:06 <mmorrow> )
19:42:12 <mmorrow> one of the two
19:42:13 <Twey> I can't seem to work out how to make it strict where it needs to be
19:42:58 <aFlag> right, I did cp `which pwd` utils/pwd/ and it seems to have worked
19:43:05 <mmorrow> nice
19:43:11 <aFlag> maybe I should report that somewhere, though
19:43:25 <mmorrow> it seems to be cleared up in the current darcs ghc
19:43:31 <RobotGuy> Is there an implementation of Haskell that implements just the standard and no more?
19:43:45 <aFlag> cool, thanks
19:44:05 <Olathe> mmorrow: Ahh, thanks.
19:44:32 <mmorrow> Olathe: :)
19:46:21 <dolio> nhc98 is probably pretty close to just H98.
19:48:26 <heatsink> I like how the new hoogle puts unsafeCoerce at the top of every search :)
19:50:15 <Korollary> ghc has a -98 flag
19:51:20 <ddarius> If unsafeCoerce can't do it, it can't be done.
19:51:42 <jrh> can unsafeCoerce get my chocolate in temper?
19:51:52 <dolio> Twey: The reason it blows up is that it isn't tail recursive, more or less.
19:52:03 <Twey> Aye, dolio
19:52:09 <Twey> How can I make it so?
19:52:15 <heatsink> jrh: Maybe.  Maybe not.  But it will make you think it did.
19:52:28 <dolio> Turn the index into an accumulated parameter.
19:52:28 <jrh> heh heh heh...
19:52:38 <Twey> Oh, right :-\
19:52:43 <dolio> find l e = find' 0 l e
19:52:48 * Twey nods.
19:52:49 <Twey> 'kay
19:52:57 <mmorrow> heatsink: well, in that split millisecond before the segfault comes
19:52:59 <jrh> oh, and twey, when you do that
19:53:11 <jrh> make sure to make the accumulated parameter strict
19:53:19 <dolio> Yeah.
19:53:19 <Twey> Yeah
19:53:24 <Twey> I've just got that one :)
19:53:25 <jrh> otherwise you risk a stack overflow from hell
19:53:28 <jrh> ahhh
19:53:31 <jrh> excellent
19:53:35 <jrh> came into the conversation late
19:54:13 <heatsink> jrh: Do you make chocolate?
19:54:18 <Twey> Heh
19:54:50 <jrh> yes. well, I temper it.  My wife actually does most of the making, as she's better at it.
19:55:08 <jrh> so she's one up on me.  I'm a PhD candidate and she's a PhD candidate who can make chocolate
19:56:45 * heatsink can see that coming in handy
19:57:11 * Myoma can make marshmallows
19:57:21 <Myoma> but I am not a PhD candidate ...
19:57:31 <jrh> Sadly, I cannot make marshmallows
19:57:54 <jrh> nor can I keep a channel on-topic
19:58:03 * heatsink wants smores now
19:58:14 <jrh> dons will get back tomorrow morning and Julia Child's ghost will have possessed lambdabot
20:00:57 <waynemokane> does anyone here write in Haskell as part of gainful employment?
20:01:47 <Korollary> a few people
20:01:56 <Korollary> at least openly
20:02:42 <gchin> hi, I'm trying to build sdl_image from hackage on windows and having problems with the cabal install
20:03:26 <gchin> I don't suppose anyone here has anyone managed to compile it on windows before? (works fine in linux)
20:04:06 <jrh> yes, but I can't be helpful to you because I don't remember how I did it...
20:04:31 <jrh> If I didn't know how busy I'd be tomorrow, I'd say send a message to haskell cafe to remind me to look at it tomorrow
20:04:36 <jrh> I might remember anyway
20:04:52 <gchin> haskell-cafe is the mailing list, correct?
20:05:22 <gchin> nevermind, found it
20:06:02 <mib_e69jeq> I am having trouble wrapping my head around the Continuation Passing Style, in particular the cfold example given in Yet Another Haskell Tutorial.  I get the idea of what a continuation is but I just keep pounding my head against the example
20:06:14 <Myoma> what is cfold?
20:06:19 <blbrown> >(when True "")
20:06:40 <mib_e69jeq> the example is cfold' f z [] = z
20:07:21 <mib_e69jeq> and cfold' f z (x:xs) = f x z (\y -> cfold' f y xs)
20:07:45 <adu> gchin: there's a mailing list?
20:08:34 <Myoma> @let cfold' f z [] = z ; cfold' f z (x:xs) = f x z (\y -> cfold' f y xs)
20:08:35 <lambdabot> Defined.
20:08:52 <Myoma> > foldr (\x y -> x + y) 0 [3,6,8,4]
20:08:53 <gchin> adu: http://haskell.org/mailman/listinfo/haskell-cafe seems to be a mailing list. I understand there's also an irc channel by the name too
20:08:54 <lambdabot> Title: Haskell-Cafe Info Page
20:08:55 <lambdabot>  21
20:09:09 <Myoma> > cfold' (\x y k -> k (x + y)) 0 [3,6,8,4]
20:09:12 <adu> gchin: lol
20:09:12 <lambdabot>  21
20:09:29 <Myoma> mib_e69je: What is the example?
20:10:33 <mib_e69jeq> then they define cfold as f z l = cfold' (\x t g -> f x (g t)) z l
20:11:15 <mib_e69jeq> so I just cant follow this through
20:11:42 <Myoma> @let cfold f z l = cfold' (\x t g -> f x (g t)) z l
20:11:44 <lambdabot> Defined.
20:11:48 <Myoma> :t cfold
20:11:50 <lambdabot> forall t t1. (t -> t1 -> t1) -> t1 -> [t] -> t1
20:12:01 <Myoma> that's the old foldr again
20:12:06 <mib_e69jeq> yes
20:12:07 <Myoma> see my two checks?
20:12:09 <Myoma> > foldr (\x y -> x + y) 0 [3,6,8,4]
20:12:12 <Myoma> > cfold' (\x y k -> k (x + y)) 0 [3,6,8,4]
20:12:12 <lambdabot>  21
20:12:15 <lambdabot>  21
20:12:17 <Myoma> it's just doing that automatically
20:12:49 <Myoma> (although it does it a bit different, but since + is nice it's not noticeable)
20:13:08 <blbrown> is this a good(or only) haskell sleep function.  http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html
20:13:09 <lambdabot> Title: System.Posix.Unistd, http://tinyurl.com/4y6alz
20:13:10 <mib_e69jeq> but I am having trouble mentally stepping through what is going on in it.  ie i dont get how it is doing what it is doing
20:13:22 <Myoma> hm I don't step through it
20:13:47 <Myoma> I just accept what a continuation is, and use higher level thinking about it
20:14:45 <mib_e69jeq> I am worried that I am missing something fundamental though.
20:15:00 <Myoma> regarding? CPS in general ? or what
20:15:05 <dons> blbrown: threadDelay is more idiomatic
20:15:10 <mib_e69jeq> i think its the use of the lambda expressions that is tripping me up
20:15:15 <dons> blbrown: unless you have some specific reason to sleep the whole process.
20:15:21 <dons> and only want to do it on unix.
20:15:43 <blbrown> dons: nope
20:16:00 <blbrown> dons: is this covered in the book, hehe
20:16:41 <mib_e69jeq> so in cfold'...there is a function f that takes 3 arguments in this case x z and a function ... in this case lambda y
20:17:46 <Myoma> it takes x z and a -continuation-
20:18:25 <mib_e69jeq> so and the continuation is lambda y...right?
20:18:47 <mib_e69jeq> take out that and sorry
20:19:15 <Myoma> Have you looked at simpler (first order) examples of CPS first?
20:19:25 <Myoma> I think that's a good idea before thinking about higher order ones
20:19:46 <Myoma> and this example is a little odd because it's a mix of CPS and non-CPS -- with a higher order function
20:19:57 <mib_e69jeq> all i have is the yet another haskell tutorial...this is the first example given
20:20:18 <mib_e69jeq> can you recommend a better exampe?
20:22:10 <Myoma> here is a first order example:
20:22:11 <Myoma> hyp x y = sqrt (add (square x) (square y)
20:22:24 <Myoma> hyp'k x y k = square'k x (\r0 ->
20:22:24 <Myoma>               square'k y (\r1 ->
20:22:24 <Myoma>               add'k r0 r1 (\r2 ->
20:22:24 <Myoma>               sqrt'k r2 k )))
20:23:04 <dons> blbrown: sadly, not at the moment. there's a lot to cover, and we can't fit it all in 700 pages (amazingly)
20:23:43 <Myoma> and
20:23:44 <Myoma> map f [] = []
20:23:44 <Myoma> map f (x:xs) = f x : map f xs
20:23:50 <Myoma> map'k f'k [] k = k []
20:23:50 <Myoma> map'k f'k (x:xs) k = f'k x (\r0 ->
20:23:50 <Myoma>                      map'k f'k xs (\r1 ->
20:23:50 <Myoma>                      cons'k r0 r1 k ))
20:24:41 <mib_e69jeq> ok i will take a look at those examples for a bit...i hate that I have hit a conceptual wall so early on.  I hope I can get through this.  Thanks for the help
20:26:14 <blbrown> dons: It will be good and I hope to get it.  I already have two haskell books
20:28:16 <hansfbaier> dons: Another one on the haskell/fastcgi problem on OpenBSD: Here is a ktrace of the lighttpd server side: http://rafb.net/p/VFievO87.html
20:28:21 <lambdabot> Title: Nopaste - No description
20:31:49 <mmorrow> mib_e69jeq: you just have get comfortable with it is all
20:34:03 <adu> so has anyone used 'only' yet?
20:34:55 <Twey> mib_e69jeq: There are lots more of them coming up :)
20:45:47 * Cale wonders when enumFrom for Integer will be fixed.
20:45:56 <newsham> hmm.. I kinda wish Enum was split into two halves (the countable (fromEnum) part and the part that supports toEnum).
20:46:00 <dons> Cale, which part of it?
20:46:09 <Cale> dons: The lack of strictness.
20:46:13 <newsham> I would like to derive countable for   data Foo = Foo Stuff | Bar Stuff Stuff | Blah
20:46:17 <dons> a patch for fixing up the strictness was pushed a few months ago
20:46:24 <newsham> so that I could get   fromEnum Bar == 1
20:46:35 <Cale> Oh, that's good! So that'll be in 6.10?
20:50:23 <Myoma> :t only
20:50:25 <lambdabot> Not in scope: `only'
20:50:30 <Myoma> adu, what is it?
20:51:46 <mmorrow> newsham: this'll do exactly what you want, if you're willing to use it: http://hpaste.org/9950
20:52:15 <mmorrow> (going this is safe, the other way is most definitely unsafe)
20:52:26 <mmorrow> (but there's a function to go the other way too)
20:52:38 <mmorrow> *going this _way_ is ...
20:53:45 <newsham> morrow: heh!  tempting, but I shouldnt.
20:54:15 <TSC> You can do it with Typeable, I think
20:54:26 <adu> Myoma: 'only'? its like grep. its also like head, tail, and cut. and its on hackage :)
20:54:26 <adu> Myoma: also, I'm writing a manpage for v0.0.5 ... do you want to see a preview?
20:54:49 <mmorrow> if you choose not to, it should be because you don't want to be non-portable by import GHC._, not because it's unsafe, because this is what happens every time you pattern match on a constructor
20:54:51 <Myoma> oh that does sound good
20:55:10 <newsham> ?pl \a b c d -> (a,b,c,d)
20:55:11 <lambdabot> (,,,)
20:55:32 <Myoma> ?pl \c b a d -> (a,b,c,d)
20:55:32 <lambdabot> flip (flip . flip (,,,))
21:00:27 <L3v1> @help
21:00:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:00:35 <L3v1> @list
21:00:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:01:39 <L3v1> ?help babel
21:01:39 <lambdabot> babel <lang1> <lang2> <phrase>.
21:01:40 <lambdabot> Translate a phrase in lang1 to lang2.
21:01:40 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
21:01:56 <L3v1> ?bf
21:01:56 <lambdabot> Done.
21:02:05 <L3v1> ?.
21:02:05 <lambdabot> Not enough arguments to @.
21:02:14 <L3v1> ?help compose
21:02:15 <lambdabot> . <cmd1> <cmd2> [args].
21:02:15 <lambdabot> . [or compose] is the composition of two plugins
21:02:15 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
21:02:44 <L3v1> ?help bf
21:02:45 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
21:03:01 <b\6> typo.
21:03:07 <b\6> 'bain'.
21:03:18 <shapr> b\6: Quick, submit a patch!
21:03:22 <adu> ?bf +++++
21:03:23 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
21:03:27 <shapr> I broke my server...
21:03:34 <shapr> hpaste might get wiped...
21:03:40 <adu> shapr: uh oh
21:03:52 <shapr> I wonder if someone wants to do a web backup?
21:04:13 <shapr> I seem to have broken most of the server processes on scannedinavian during my most recent upgrade.
21:04:15 <adu> shapr: how so?
21:04:20 <shapr> libc upgrade
21:04:37 <adu> shapr: can I help?
21:05:07 <shapr> adu: Can you hack up something to suck down all the hpaste entries? :-)
21:05:18 <adu> would wget work?
21:05:28 <shapr> Yeah sure
21:05:53 <shapr> After that, I reboot the virtual machine, and hope it comes back up :-/
21:06:09 <shapr> I'd like to check my mail, for example...
21:06:53 <adu> okj
21:07:41 <mmorrow> shapr: i have space also if any's needed
21:08:37 <shapr> At the moment, I'm just hoping someone will rip a copy of the hpaste posts before I reboot the vm.
21:08:45 <adu> i'm doing it right now
21:08:50 <shapr> spiffy, thanks!
21:09:07 <shapr> Wow, almost up to entry 10k!
21:09:07 <adu> shapr: and if it all goes down, then I can let you download over 8080
21:09:14 <shapr> adu: cool
21:09:24 <shapr> It might take awhile...
21:10:43 <adu> shapr: I'm done with the current page, now I'm starting on 0-9999
21:11:00 <shapr> cool
21:11:36 <mmorrow> heh, i'm cruising along
21:12:26 <mmorrow> adu: what wget options are you using
21:12:27 <mmorrow> ?
21:12:30 <mmorrow> i botched it
21:12:33 <adu> -r -nc -np
21:12:37 <mmorrow> cool
21:12:44 <heavensrevenge> can i use a list as a command line argument?
21:13:01 <heavensrevenge> so far it only treats a list as 1 argument
21:13:07 <mmorrow> *now* i'm cruising ;)
21:13:09 <heavensrevenge> and not as the whole list
21:13:15 <adu> and also the bash syntax {0,1,2,3,4,5,6,7,8,9}
21:13:26 <b\6> heavensrevenge: please show example.
21:13:46 <heavensrevenge> just sumthin simple
21:13:47 <heavensrevenge> main = do
21:13:47 <heavensrevenge>   args <- getArgs
21:13:47 <heavensrevenge>   print $ length args
21:14:01 <shapr> heavensrevenge: You need to read it.
21:14:06 <heavensrevenge> oh..
21:14:09 <shapr> > read "3" :: Int
21:14:11 <lambdabot>  3
21:14:17 <shapr> > read "A" :: Int
21:14:20 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
21:14:40 <b\6> but there he's just trying to print the number of arguments.
21:14:43 <b\6> that should be ok.
21:15:13 <shapr> oh
21:15:40 <heavensrevenge> do i have to specify in the source? or on the command line?
21:15:43 <humasect> > read [1,2,3]
21:15:45 <lambdabot>      No instance for (Num Char)
21:15:45 <lambdabot>       arising from the literal `1' at <intera...
21:16:06 <b\6> heavensrevenge: what arguments do you give on the command line?
21:16:20 <heavensrevenge> just a list
21:16:39 <b\6> please show what you run.
21:16:42 <heavensrevenge> just a program that accumulates the # of elements in a list
21:16:56 <mmorrow> adu: heh, for i in `seq 1 300`; do  echo "http://hpaste.org/?offset=$i" >> a.wget; done && wget -r -nc -np -i a.wget
21:16:58 <heavensrevenge> but executable
21:17:16 <adu> mmorrow: that works too
21:20:38 <sw17ch> any reason the hackage package list is down?
21:20:38 <adu> mmorrow: where do you get 'seq'?
21:20:39 <heavensrevenge> hmm weird
21:20:44 <heavensrevenge> i get something
21:20:57 <heavensrevenge> but definately not what i expect
21:21:04 <b\6> adu: coreutils.
21:21:17 <b\6> heavensrevenge: you're not giving enough info to help.
21:21:21 <mmorrow> adu: bash i believe
21:21:26 <adu> b\6: ic, I don't have coreutils
21:21:28 <heavensrevenge> ill just hpaste it
21:21:33 <b\6> oh yeah?
21:21:35 <emma> where can i see some haskell code?
21:21:35 * adu is on macosx
21:21:51 <sw17ch> wget http://hackage.haskell.org/packages/archive/pkg-list.html -q -O - | wc -c => 0
21:21:52 <mmorrow> ah, it's not built in it looks like
21:21:54 <Myoma> emma: What code?
21:21:59 <mmorrow> adu: probably at gnu.org
21:22:01 <sw17ch> :\
21:22:15 <emma> I'd like to see some typical Haskell code, nothing difficult, but some basic nice code.
21:22:21 <emma> To see what it looks like.
21:22:26 <Myoma> @src map
21:22:26 <lambdabot> map _ []     = []
21:22:27 <lambdabot> map f (x:xs) = f x : map f xs
21:22:30 <adu> emma: start with the fibbonacci one-liner
21:22:31 <dsrogers> hey mmorrow, do you have that link GHC.Environment?
21:22:31 <Myoma> @src reverse
21:22:31 <lambdabot> reverse = foldl (flip (:)) []
21:22:36 <humasect> emma: http://dafx04.na.infn.it/WebProc/Proc/P_201.pdf
21:22:40 <Myoma> @src Either
21:22:40 <lambdabot> Source not found. You untyped fool!
21:22:43 <lambdabot> Title: cache:http://dafx04.na.infn.it/WebProc/Proc/P_201.pdf - Google Search
21:22:46 <Myoma> @src Maybe
21:22:47 <lambdabot> data Maybe a = Nothing | Just a
21:22:47 <b\6> emma: http://haskell.org/tutorial/
21:22:49 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
21:22:56 <heavensrevenge> http://hpaste.org/9951
21:22:58 <mmorrow> dsrogers: yeah, and something better too. i started putting together a th-utils package
21:22:59 <dsrogers> and do you know what license it is under?
21:23:05 <adu> @src sequence_
21:23:06 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:23:09 <mmorrow> (which includes the Environment code)
21:23:13 <dsrogers> mmorrow: awesome.
21:23:15 <dsrogers> where is it?
21:23:16 <mmorrow> ohhh, a link yeah, hold on
21:23:24 <emma> I've been told that it works much like mathematical notation works.
21:23:27 <heavensrevenge> definately not what i expect
21:23:29 <lispy> hi
21:23:38 <heavensrevenge> when i give it a list on the command line
21:24:09 <adu> emma: yup, my favorite part is sections
21:24:12 <mmorrow> dsrogers: it has in it Lift instances for all the TH datatypes + some util functions so far
21:24:16 <dsrogers> mmorrow: also a darcs repo would be nice.
21:24:19 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/
21:24:21 <mmorrow> bam
21:24:21 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
21:24:22 <b\6> heavensrevenge: please for the love of god tell what you mean by "give a list on the command line".
21:24:27 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/EXAMPLES
21:24:36 <heavensrevenge> well after copilation with ghc
21:24:37 <adu> emma: like 2+3 is what you'd expect, and (2+) is a function that adds two to its argument
21:24:47 <heavensrevenge> ./accumulator [1..20]
21:24:49 <mmorrow> dsrogers: oh, also i founf out the TH library changed slightly between 6.8.2-6.8.3
21:24:58 <mmorrow> you should upgrade to 6.8.3 at least
21:25:14 <dsrogers> ok
21:25:19 <dsrogers> I'm already on 6.8.3
21:25:21 <mmorrow> and Environment: http://darcs.haskell.org/libraries/base/GHC/Environment.hs
21:25:34 <heavensrevenge> lol and it magically gives 11
21:25:43 <dsrogers> you said th-utils already includes that code?
21:25:46 <heavensrevenge> instead of 20 or the "length" of the list
21:25:47 <mmorrow> dsrogers: ah, i confused something you said the other day then
21:26:00 <lispy> heavensrevenge: well, [1..20] means something to  your shell probably
21:26:03 <mmorrow> dsrogers: if you're on 6.8.3 you're good
21:26:22 <heavensrevenge> im more or less trying to make just a compiled "length" function
21:26:40 <rwbarton> heavensrevenge: how exactly do you expect the string "[1..20]" to get turned into a 20-element list?
21:26:44 <lispy> heavensrevenge: I mean, you don't really expect [1..20] to result in the haskell evaluated version of that do you?
21:26:56 <heavensrevenge> i dont want it to stay a string...
21:26:56 <lispy> > length "[1..20]"
21:26:59 <lambdabot>  mueval: Time limit exceeded
21:27:02 <lispy> > length "[1..20]"
21:27:05 <lambdabot>  7
21:27:07 <rwbarton> heavensrevenge: your OS is not a haskell interpreter
21:27:11 <Myoma> > read "[1..20]" :: [Integer]
21:27:14 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
21:27:18 <rwbarton> (probably :)
21:27:22 <heavensrevenge> haha sadly
21:27:29 <dsrogers> what is haskell-src-exts for?
21:27:41 <adu> > read "[1,2,3,4,5,6,7,8,9,10]" :: [Int]
21:27:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:27:50 <heavensrevenge> so... i cant just use a list as an argument
21:27:53 <mmorrow> dsrogers: also, the haddock docs are in that repo, but not added to the repo. so for reference in case you can't build the docs: http://code.haskell.org/~morrow/code/haskell/th-utils/haddock/
21:27:54 <lambdabot> Title: th-utils-0.1: th-utils
21:27:57 <heavensrevenge> but as something i type in afterwards?
21:28:33 <dsrogers> src/Language/Haskell/TH/Instances.hs:12:14:
21:28:33 <dsrogers>     Not in scope: type constructor or class `Loc'
21:28:41 <lispy> heavensrevenge: it might help you if you wrote a similar program that echos each of it's argumentns
21:28:57 <mmorrow> dsrogers: hmm, ok i'm confused now then. i thought Loc appeared in 6.8.3.
21:29:20 <stepcut> dsrogers: it parses haskell that includes literal XML syntax and regular expressions for pattern matching
21:29:24 <mmorrow> dsrogers: well, if you're interested i have a 6.8.3 which has been patched to have the new TH lib + QuasiQuotes
21:29:33 <emma> Is Haskell a lisp?
21:29:35 <adu> > let len xs = map (xs!!) [4..5] in len "[1..20]"
21:29:38 <lambdabot>  "20"
21:29:39 <Myoma> emma, no
21:29:39 <medfly> emma, ?
21:29:41 <heavensrevenge> ok lispy
21:29:41 <sw17ch> is there a flag similar to make's -jN for the setup scripts?
21:29:48 <heavensrevenge> ill have some fun
21:29:51 <dsrogers> mmorrow: I'm not that interested in patching my compiler, to be honest...
21:30:00 <humasect> adu=)
21:30:01 <cjb> emma: nope.  similar ideas, I guess, but laziness is a big difference.
21:30:02 <mmorrow> dsrogers: http://code.haskell.org/~morrow/quasiquotes/ghc-6.8.3_QQ-0.2.tar.bz2
21:30:04 <lambdabot> http://tinyurl.com/5m2grk
21:30:05 <lispy> heavensrevenge: and if you want to use haskell expressions in your command line, check out, ghc -e '[1..20]'
21:30:06 <dsrogers> mmorrow: besides, I'm on mac os x
21:30:07 <adu> humasect: :)
21:30:07 <mmorrow> audreyt's patch
21:30:18 <humasect> sw17ch: +RTS -N2 -RTS
21:30:19 <mmorrow> dsrogers: ok, that;s src :)
21:30:24 <dsrogers> also, what are quasiquotes?
21:30:44 <mmorrow> here's a regex quasiquoter: http://code.haskell.org/~morrow/quasiquotes/regexqq.txt
21:30:53 <adu> dsrogers: mee too! and I noticed that OpenGL works so much better when you compile GHC yourself
21:30:54 <lispy> heavensrevenge: for example, echo `ghc -e '[1..20]'`
21:31:30 <humasect> really, adu ? for mac's gl+ghci issues ?
21:31:35 <heavensrevenge> how very convenient!
21:31:48 <heavensrevenge> what a slew of tools we have
21:32:06 <sw17ch> runhaskell Setup -j3 build
21:32:06 <sw17ch> or something silly like that
21:32:11 <dsrogers> mmorrow: what is lift used for again?
21:32:12 <adu> humasect: ya, but it was with 6.8.1 i think, i'm guessing its been solved by now...
21:32:43 <mmorrow>  ghci> (\port -> [$lighttpd| server.port = $port |]) 80
21:32:43 <mmorrow>  Config [OptionE (QName {moduleName = Name "server", baseName = Name "port"}) (IntegerV 80)]
21:32:44 <humasect> adu: ah, i see. still not it seems (bus error) so i've managed my own shell which is in some ways more useful and less in others. =)
21:33:07 <adu> humasect: but it wasn't ghci specific, iirc, it either wouldn't compile or wouldn't run, its been awhile
21:33:20 <humasect> ahh i see
21:33:29 <mmorrow> dsrogers: class Lift a where lift :: a -> ExpQ      so it basically "quotes" an a, so you can bring it into a quote brackets
21:33:35 <mmorrow> \x -> [| x |]
21:33:39 <adu> maybe it couldn't like with OpenGL libs or something, i don't remember
21:33:51 <humasect> ok, no problem ^_^
21:33:51 <dsrogers> ah
21:33:53 <adu> humasect: so have you been using 'only'?
21:34:14 <humasect> nope, adu; but i've only needed one search since =)
21:34:33 <mmorrow> dsrogers: for (\x -> [|x|]) to work, a in (x::a) must be an instance instance of Lift
21:34:46 <humasect> i am better with recursion than regex that is for sure
21:34:55 <adu> humasect: ya, i still use grep for the -r, i should really add that...
21:35:07 <adu> i love grep -r
21:35:11 <Myoma> @w80 trepanning
21:35:13 <lambdabot> *** "trepanning" wn "WordNet (r) 2.0"
21:35:13 <lambdabot> trepan
21:35:13 <lambdabot>      n 1: a surgical instrument used to remove sections of bone from
21:35:13 <lambdabot>           the skull [syn: {trephine}]
21:35:13 <lambdabot>      2: a drill for cutting circular holes around a center
21:35:15 <lambdabot> [6 @more lines]
21:35:19 <humasect> ah, good point; recently i've broken my source into dirs too. =)
21:36:06 <adu> I'm also a big fan of sed -i
21:36:11 <lispy> as nice as grep -r is, I often have to resort to something wonky like, find . | grep .hs | xargs grep -n 'blah'
21:36:17 <dsrogers> mmorrow: I'm going to yoink your code into HOC, at least the parts I can currently compile, anyway
21:36:35 <humasect> ah yes
21:37:15 * sw17ch curses his crappy cable modem
21:37:36 <mmorrow> heh, ok. stick my name somewhere and it's fine with me (BSD3) :)
21:37:39 <humasect> i've got darcs yi to compile the other day, but no bins but libs to be found. hoc failed too - but i don't want to get into this. =)
21:37:43 <dsrogers> mmorrow: will this compile once GHC 6.10 comes out?
21:37:49 <mmorrow> dsrogers: for sure.
21:38:16 <mmorrow> i can't friggin wait til 6.10 comes out, if just for the TH/TH-related additions
21:38:22 <adu> lispy: you know the first 2 could be shorted to fins . -name '*.hs'
21:38:27 <humasect> mmorrow: what else for ?
21:38:40 <dsrogers> mmorrow: is TH.Utils going to make it into the official stuff?
21:38:43 <lispy> adu: ah, I never can remember the syntax of find
21:39:08 <mmorrow> dsrogers: err, i don't think so, just put it together an hour ago :)
21:39:10 <adu> lispy: actually find . -name '*.hs' -exec grep -n 'blah' {} \; should do the trick :)
21:39:19 <dsrogers> mmorrow: lol.
21:39:30 <lispy> adu: but isn't the exec version slower?
21:39:37 <adu> lispy: i dunno
21:39:47 <lispy> adu: plus, that whole, "{} \;" is weird
21:39:52 <mmorrow> humasect: parallell garbage collection, a new native codegen, a bunch of minor fixes, probably more that i can't think of off the top of my head
21:39:58 <lispy> adu: suspect -exect starts grep on each file riht?
21:39:59 <mmorrow> *parallel
21:40:08 <lispy> adu: but maybe xargs does too
21:40:08 <dsrogers> ok.  well I'm going to hack on hoc for a while with this new utilities.  I'll let you know how they work out.
21:40:14 <humasect> mmorrow: oh, wow =)
21:40:15 <adu> lispy: i dunno
21:40:20 <mmorrow> dsrogers: cool :)
21:40:26 <mmorrow> humasect: exciting!
21:40:28 <adu> lispy: no xargs only does the hs files
21:40:29 <humasect> yeah=)
21:41:04 <mmorrow> humasect: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
21:41:05 <lambdabot> Title: Status/Releases - GHC - Trac
21:41:15 <humasect> ah perfect, thank you =)
21:41:32 <adu> shapr: I'm about 40% done
21:41:40 <mmorrow> adu: me too
21:41:48 <sw17ch> lets try this again: is the package list blank for every one? or just me...
21:42:10 <humasect> ohh record syntax upgradez!
21:42:13 <geezusfreeek> me too
21:42:17 <mmorrow> actually, i've got 6000 pastes, have 3000 to go
21:42:27 <geezusfreeek> ^ @ sw17ch
21:42:33 <sw17ch> geezusfreeek, ty
21:42:34 * Myoma grumbles about haskell having enough syntax already
21:42:51 <shapr> adu: I think I'll be asleep before the backup is done, but I'll reboot the server tomorrow.
21:42:51 <adu> sw17ch: wow, everyone
21:42:52 <cjs> Grr. Nobody logs #haskell-overflow?
21:43:10 <dsrogers> mmorrow: would you accept a patch that lets this package compile under ghc 6.8.3?
21:43:19 <sw17ch> adu: yeah, i just tossed my super-experimental version of the portaudio bindings onto hackage and wanted to see it listed...
21:43:23 * Myoma watches the pre-sunrise
21:43:27 <mmorrow> dsrogers: definitely.
21:43:27 <sw17ch> and i'm greeted with a blank page, i feared i killed hackage :)
21:43:38 <mmorrow> sw17ch: it's blank for me too
21:44:00 <sw17ch> in the unlikely event that my cabal file *did* kill hackage, i'm not here right now
21:44:02 <humasect> it was dead for me earlier today.
21:44:19 <adu> sw17ch: did you use an Uppercase variable or something?
21:44:24 * adu shudders
21:44:43 <sw17ch> ah, you can see it with "what's new"
21:44:48 <sw17ch> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/portaudio-0.0.1
21:44:49 <dsrogers> mmorrow: sent
21:44:55 <lambdabot> Title: HackageDB: portaudio-0.0.1, http://tinyurl.com/6yz885
21:45:21 <sw17ch> but the empty package list is sad... :(
21:45:29 <humasect> view patterns! sexy..
21:45:47 <Myoma> they aren't quite as good as they could be
21:46:10 <humasect> as they are what they are
21:46:44 <humasect> this quasi quoting mechanism, is yours mmorrow ?
21:47:07 <dsrogers> :t lift
21:47:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
21:47:16 <humasect> how can they be better, Myoma ?
21:47:32 <Myoma> the implicit tupling seems to have not been implemented
21:47:44 <humasect> f (polar -> v) = let (x,y) = v in ..
21:48:05 <mmorrow> dsrogers: cool. checking now.
21:48:10 <mmorrow> humasect: hmm?
21:48:28 * Myoma would like to write i.e.  dgkd ([$rx|(.*)-(.*)|] -> name idS) = (name, read idS)
21:48:35 <lispy> syntatically I've always found f b = let blah = b in ..., to be confusing
21:48:51 <humasect> mmorrow: all i know about quasi quoting is from Nov07 status page for .10 and your texts here =)
21:48:58 * ddarius just finds it ugly.
21:49:23 <mmorrow> humasect: heh, i'll do a paste in a sec with some cool stuff ;)
21:49:25 <humasect> lispy: is there a cleaner way to unravel tuples ?
21:49:29 <humasect> mmorrow: hehe, ok =)
21:49:41 <humasect> Myoma: what is the $ ? TH ?
21:49:48 <lispy> humasect: that's not my objection.  My objection is starting a function body with a let
21:49:48 * sw17ch dislikes the quasiquoting syntax as well... looks perlesque
21:49:54 <rwbarton> f blah = ...?   can you not put a pattern on the RHS of a ->?
21:49:55 <lispy> humasect: I just find it a bit hard to read
21:49:59 <mmorrow> ddarius: an ugly car is better than no car and a horse if you're in manhattan
21:50:16 <mmorrow> actually, cars in manhattan are a bitch
21:50:29 <humasect> lispy: ohh, i see =) this is understandable. it makes it somewhat easier with syntax colors. function headers tend to be short
21:50:30 <mmorrow> change that to somewhere where cars are a lot better than hoses ;)
21:50:35 <mmorrow> *horses
21:50:41 <adu> mmorrow: lol
21:50:43 <sbahra> motor bike
21:50:53 <humasect> =)
21:51:10 <humasect> rwbarton: what is RHS ?
21:51:34 <mmorrow> dsrogers: where did you send it?
21:51:49 <adu> humasect: right-hand-side?
21:52:01 <humasect> doWithPoint (centerOfRect -> (x,y)) = ...
21:52:10 <mmorrow> dsrogers: (in case you did it with darcs send's direct email option, i've never been able to get that to work)
21:52:12 <humasect> adu: ahh, cool thanks.
21:52:28 <dsrogers> I used darcs send --to=...
21:52:33 <dsrogers> is that broken?
21:52:50 <Myoma> mergeSort (halve -> (left , right)) = (merge`on`mergeSort) left right
21:52:57 <mmorrow> dsrogers: i dunno, i can't get it to work. i've done the same thing, only to find out a week later that it never arrived
21:52:57 <humasect> =)
21:53:05 <Myoma> the (left , right) bit is ugly
21:53:08 <dsrogers> mmorrow: so how do I get it to work?
21:53:16 <dsrogers> how do I create the patch, basically
21:53:41 <humasect> Myoma: is it prettier to have [$rx|(.*)-(.*)|] ? type it again for your cosmetic sake
21:54:03 <Myoma> than?
21:54:06 <humasect> because halve gives a tuple, what else can be done ?
21:54:22 <Myoma> I'd rather write (halve -> left right)
21:54:25 <Myoma> to mean the same thing
21:54:33 <mmorrow> dsrogers: i do the --file=... option, then email it manually as an attachment
21:54:36 <humasect> what if left was a function taking right ?
21:54:47 <mmorrow> err, i meant --output=FILE
21:54:53 <mwc> Wee, I grok Text.XHtml now :)
21:55:00 <humasect> let x y = v  <-- v needs to be a -> a
21:55:10 <Myoma> no it doesn't
21:55:28 <dsrogers> mmorrow: it worked when I sent to myself :-(
21:55:31 <humasect> let (x,y) = v  there is a reason tuples have syntax like this i think.
21:55:34 <dsrogers> but I'll send it right away
21:55:58 <mmorrow> dsrogers: weird. i haven't gotten it.
21:56:04 <Myoma> I only want the view pattern changed, let can remain the same
21:56:05 <dsrogers> junk maybe?
21:56:31 <mmorrow> i don't even know what it's using to send it, and even if i did i know nothing about email
21:56:46 <humasect> because that is inside the view pattern is regular syntax. so we can say: f (halve -> halves) . there is no tuple unwrapping, because f still takes that one argument, it doesn't transform f to take two.
21:56:51 <mmorrow> ohh, i gotcha. checking ...
21:57:05 <mmorrow> haha, straight to the spam folder
21:57:08 <mmorrow> i got it
21:57:10 <dsrogers> great.
21:57:17 <Myoma> humasect: THis is described in the view pattern page anyway
21:57:26 <humasect> ok
21:57:39 <Myoma> it's just not been implemented
21:58:17 <humasect> vectorising in DPH sounds interesting
21:58:25 <humasect> ahh i see, Myoma , now i understand=)
21:58:40 <sbahra> Any haskellians located in the DC area by any chance?
21:58:57 * sbahra would like to organize a talk about haskell @GWU
21:59:20 <lispy> sbahra: probably just the wrong time of day to ask
21:59:25 <dons> sbahra: yeah, FringDC meets up
21:59:26 <lispy> it's pretty late there I suppose
22:00:00 <dsrogers> mmorrow: when is it safe to unQ?
22:00:20 <sbahra> dons, I signed up
22:00:28 <sbahra> dons, I didn't see too many haskell discussions
22:00:33 <sbahra> But I'll definitely be going to their next meeting
22:00:54 <sbahra> lispy, yes, 1AM
22:02:23 <humasect> base3-compat - is base library changed this much ?
22:02:30 <mmorrow> dsrogers: i don't think it'll ever cause a segfault, but i'm not sure if it is even unsafe at all in this context. i only use it though when i'm in pure code and i can't otherwise runQ to another monad and i'm forced to take an (eg) ExpQ as input
22:03:29 <dsrogers> mmorrow: that is what I was thinking.  You should make all the things that eventually pass to runIO strict.
22:03:31 <mmorrow> i guess it would be "safe" if you could just as easily have contructed the same Exp in an ExpQ with the AST constructor
22:03:37 <dsrogers> that will solve the reifiy problem, I think
22:03:48 <mmorrow> what's the reify problem?
22:03:56 <dsrogers> can't run reify in the IO monad
22:03:56 <mmorrow> you mean with IO?
22:03:58 <dsrogers> yeah
22:04:09 <mmorrow> yeah, because there's no type environment to get the info from
22:04:20 <mmorrow> it's hard coded to do   error "cant reify in the IO monad"
22:04:20 <dsrogers> as long as you evaluate the argument while you're still in Q and before you get into runIO you should be ok.
22:04:38 <mmorrow> you have to do it in a $( .... )
22:04:56 <mmorrow> $(lift =<< reify ''Int)
22:05:10 <dsrogers> ah
22:05:11 <mmorrow> (lift =<< reify ''Int) :: ExpQ
22:05:31 <mmorrow> print=<<runQ((lift =<< reify ''Int) :: ExpQ)::IO()   error ...
22:05:46 <mmorrow> print $(lift =<< reify ''Int) :: ExpQ)::IO()   OK
22:06:03 <mmorrow> it took me soooo long to figure that out ;)
22:06:39 <dsrogers> making pprintQ strict solve the problem too.
22:06:49 <dibblego> @type bimap
22:06:51 <lambdabot> Not in scope: `bimap'
22:06:59 <dsrogers> also AST versions of pprint and show are useful too.
22:07:09 <lispy> mmorrow, dsrogers: what does this code you're working on do?
22:07:11 <mmorrow> dsrogers: check out the instance Quasi IO  code  http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Syntax.html
22:07:14 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/67ddnk
22:07:20 <dsrogers> in fact, I use that more than anything else.
22:07:28 <dsrogers> mmorrow: yeah, saw that.
22:07:35 <mmorrow> lispy: dsrogers is working on HOC, i'm putting together a template-haskell utils package
22:07:36 <dsrogers> lipsy: it's tools for debugging TH
22:08:10 <dsrogers> lispy: I've written a test that runs as part of the compile to test TH functions.
22:08:25 <lispy> dsrogers: cool
22:08:38 <dsrogers> http://phasevelocity.org/thtest.tgz
22:09:54 <dsrogers> mmorrow: the reason I recommend strict is that when you're already in a th function, you're already in Q.
22:10:24 <dsrogers> so you don't need to run extra splices, if you just make your functions that exit Q strict.
22:10:45 <Mitar> ehm, why dons kicked me?
22:10:58 <dsrogers> and most of the time I'm debugging a TH function.
22:11:05 <rwbarton> Mitar: tab completion fail
22:11:19 <Mitar> ok
22:11:36 <dsrogers> anyways, I'm sleep now (zzzzz)
22:11:42 <dsrogers> goodnight everyone.
22:11:48 <lispy> dsrogers: good night
22:12:21 <b\6> humble request for help on parsing with parsec directly off a socket handle: http://www.haskell.org/pipermail/haskell-cafe/2008-August/046532.html
22:12:23 <lambdabot> Title: [Haskell-cafe] Parsec and network data, http://tinyurl.com/5gntmf
22:13:42 <dons> sbahra: start some haskell discussions then :)
22:14:03 <mmorrow> dsrogers: ok, i used #if __GLASGOW_HASKELL__ >= 609   to conditionally include the Loc/WordPrimL parts
22:14:03 <lispy> b\6: is this the question about blocking?
22:14:11 <b\6> lispy: blocking's related.
22:14:39 <mmorrow> dsrogers: i also added a few more functions, mostly misc though. so darcs pull if you desire
22:14:49 <lispy> b\6: I think you'll need a continuation or something do deal with the blocking
22:15:43 <b\6> lispy: not sure. i think the Stream implementation was the best idea yet, but i think it uses the "rest" part of the pair to look ahead.
22:16:47 <b\6> lispy: in my toy timeout Stream implementation, parsec misses the \r in \r\n, i think because it's the first character not like the previous stuff i was matching.
22:16:50 * lispy has a parsing task at work this week that would have been trivial in parsec, but is eating up time due to foolishly using lex/yacc
22:17:12 <b\6> yeah, i really like parsec.
22:17:25 <b\6> but this network thing is driving me insane.
22:17:42 <dons> who'ss the portaudio guy, again?
22:17:47 <b\6> switch.
22:17:49 <b\6> i think.
22:17:53 <lispy> I turns, out the way I tried to write down the syntax of this file I'm trying to parse I need to do some context sensitive stuff.  Hence the reason yacc failed me
22:17:58 <dons> sw17ch: ah yes, http://aur.archlinux.org/packages.php?ID=19382 enjoy
22:17:59 <lambdabot> Title: AUR (en) - haskell-portaudio
22:18:45 <mmorrow> humasect: ok, here's some code from a javascript quasiquoter i'm working on/experimenting with  http://code.haskell.org/~morrow/code/haskell/misc/JsQQLib.hs.html
22:18:46 <lambdabot> Title: Haskell Code by HsColour
22:18:46 <dons> if everyone switches to Arch, life's going to be good for Haskell. :) If only we could move Debian / Ubuntu this fast. sigh.
22:18:48 <lispy> I think I can constrain the context sensitive part to the lexer though...so maybe using yacc won't kill me
22:18:55 <humasect> mmorrow: k
22:19:04 <lispy> dons: Yeah, Debian Stale is really stale.
22:19:07 <Nafai> dons: So how much work needs to be done to get cabal-debian working well enought create .debs and then crank out the .debs for the Hackage libs?
22:19:25 <mmorrow> humasect: i'm actually using it to do real things too. it's really nice because it catches all js syntactic errors at haskell compile-time
22:19:28 <Heffalump> you still need a process for getting them into debian once that's done
22:19:46 <dons> Nafai: so that must be close. having an 'overlay' of all the haskell stuff.
22:19:59 <dons> then from there, take the solid platform and get it into debian, then on to ubuntu.
22:20:06 <humasect> hm ~
22:20:17 <humasect> interesting=)
22:20:24 <mmorrow> humasect: it
22:20:47 <mmorrow> humasect: it's nice because you can embed the lang, then use haskell's type system to type it almost seamlessly
22:20:55 <b\6> dons: please, please look at http://www.haskell.org/pipermail/haskell-cafe/2008-August/046532.html or i hang myself from the ceiling fan with a playstation 1 controller cord and slice my wrists with shard of slackware 1.0 cdrom and my blood sprays all over the walls and it spells "DONS".
22:20:57 <lambdabot> Title: [Haskell-cafe] Parsec and network data, http://tinyurl.com/5gntmf
22:21:13 <dons> scary, b\6
22:21:14 <mmorrow> humasect: i'm just starting to realize what this mean and how to go about doing it
22:21:31 <b\6> i know, slackware sux.
22:21:34 <mmorrow> b\6: hahahalol
22:21:39 <humasect> ohh i see, that is powerful stuff indeed!
22:21:46 <dons> isn't that a job for lazy hGetNonBlocking?
22:21:53 <dons> from Data.ByteString.Lazy ?
22:21:57 <mmorrow> ps1 controller: the suicide tool of choice for slackware users
22:22:00 <b\6> maybe!!
22:22:06 <dons> that as your underlying IO tool.
22:22:09 <b\6> that's something i haven't read about to death, at least.
22:22:13 <b\6> reading, thanks.
22:22:21 <dons> ?hoogle hGetNonBlocking
22:22:22 <lambdabot> Data.ByteString hGetNonBlocking :: Handle -> Int -> IO ByteString
22:22:22 <lambdabot> Data.ByteString.Char8 hGetNonBlocking :: Handle -> Int -> IO ByteString
22:22:22 <lambdabot> Data.ByteString.Lazy hGetNonBlocking :: Handle -> Int -> IO ByteString
22:22:28 <humasect> slackware..=)
22:22:45 <sclv> b\6 or just a better protocol?
22:22:48 <b\6> humasect: feeling like a few ./configure && make && make install && ldconfigs am i right?
22:22:52 <b\6> sclv: not under my control.
22:23:01 <humasect> hehe
22:23:01 <b\6> yeah, i'd love netstrings or something.
22:23:15 <sclv> oh right i just realized.
22:23:21 <humasect> luckily i still enjoy the ritual
22:24:37 <dons> b\6: netstrings?
22:24:51 <sclv> rolling a hGetLine or such with whatever behaviour you want shouldn't be too hard with the provided primitives though...
22:24:52 <dons> ah interessting.
22:24:53 <mmorrow> humasect: here's the wiki page http://haskell.org/haskellwiki/Quasiquotation
22:24:54 <lambdabot> Title: Quasiquotation - HaskellWiki
22:25:06 <mmorrow> humasect: and here's the paper by the implementor:
22:25:09 <humasect> mmorrow: hmm yep i just finished reading this
22:25:10 <mmorrow> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
22:25:13 <lambdabot> Title: Why It’s Nice to be Quoted: Quasiquoting for Haskell, http://tinyurl.com/yo9sa3
22:25:15 <b\6> dons: http://cr.yp.to/proto/netstrings.txt
22:25:15 <mmorrow> humasect: heh, nice
22:25:18 <dons> yup
22:25:21 <humasect> mmorrow=)
22:25:33 <b\6> sorry, late.
22:25:40 <humasect> its a little like pattern matching meets evaluating
22:27:27 <mmorrow> yeah, it's crazy. especially since you create the parser and everything yourself
22:38:09 <_zenon_> Someone here hot on bash script? Over at #bash, they're dead as fish. I don't know how to concatenate a string into a larger string using $variables,
22:38:54 <_zenon_> I would simply like an iterative string concatenation, like $var=$var":"$var2      where $var2 varies to build the string
22:39:03 <lispy> _zenon_: ghc -e '$variable1 ++ $variable2'
22:39:11 <Myoma> haha
22:39:14 <_zenon_> ;)
22:39:23 <mmorrow> $this$that  ==  "$this$that"  == "${this}${that}"  == ${this}${that}
22:39:24 <Nafai> _zenon_: var=$var":"$var2 doesn't work?
22:39:42 <mmorrow> oh, so
22:39:45 <mmorrow> var=$var":"$var2
22:39:50 <bd_> lispy: fails without "". Also with "" would fail if either variable contains "
22:40:02 <_zenon_> Nafai, doesn't seem so, but I'll try with a '+'
22:40:04 <bd_> Can one do imports with -e?
22:40:05 <lispy> bd_: :)  I was just teasing
22:40:35 <bd_> the correct solution would be putStrLn . fmap concat getArgs
22:40:41 <bd_> er
22:40:43 <bd_> =<< not .
22:40:51 <dibblego> (Monoid a, Monoid b) => Either a b -> Either a b -> Either a b -- which function is this?
22:41:06 <mmorrow> _zenon_: oh, i just realized what you're asking
22:41:15 <_zenon_> mmorrow, okay, np
22:41:30 <bd_> dibblego: What does it do when passed (Left _) (Right _)?
22:41:32 <mmorrow> so you want to do something like a foldr ??
22:41:43 <Myoma> :t mplus +++ mplus
22:41:45 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (MonadPlus m1, MonadPlus m) => Either (m a) (m1 a1) -> Either (m a -> m a) (m1 a1 -> m1 a1)
22:41:45 <_zenon_> mmorrow, it's fixed now, did it with another construct.
22:41:51 <mmorrow> cool
22:41:52 <Myoma> :t either mplus mplus
22:41:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Either (m a) (m a) -> m a -> m a
22:42:05 <Myoma> :t mplus ||| mplus
22:42:07 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Either (m a) (m a) -> m a -> m a
22:42:30 <bd_> dibblego: the type's a bit unnatural as it can take values of both a and b, but then have to arbitrarily throw out one of them
22:42:48 <mmorrow> _zenon_: could you explain what you're trying to do?
22:42:50 <dibblego> bd_, yes you're right; I throw out Right values on the first Left occurrence
22:42:52 <dibblego> brb
22:43:07 * mmorrow will take all the bash tricks he can get
22:43:08 <bd_> :t liftM2 mconcat
22:43:08 <Myoma> oh const
22:43:09 <lambdabot> forall a2 r (m :: * -> *). (Monad m, Monoid r) => m [a2 -> r] -> m a2 -> m r
22:43:13 <bd_> er
22:43:15 <bd_> :t liftM2 mplus
22:43:17 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
22:43:32 <bd_> :t liftM2 mplus :: (Monoid a, Monoid b) => (Either a b) -> (Either a b) -> (Either a b)
22:43:34 <lambdabot>     Could not deduce (Error a1) from the context (Monoid a1, Monoid b)
22:43:34 <lambdabot>       arising from a use of `liftM2' at <interactive>:1:0-11
22:43:34 <lambdabot>     Possible fix:
22:43:43 <_zenon_> mmorrow, in bash, I was trying to set the classpath correctly for a java 1.5 compilation, which works for java 1.6 since 1.6 let's you have *'s in the classpath, but 1.5 does not. So you have to add all the damn jars to the classpath explicitly
22:43:44 <bd_> :t liftM2 mplus :: (Monoid a, Monoid b, Error b) => (Either a b) -> (Either a b) -> (Either a b)
22:43:46 <lambdabot>     Could not deduce (Error a1)
22:43:46 <lambdabot>       from the context (Monoid a1, Monoid b, Error b)
22:43:46 <lambdabot>       arising from a use of `liftM2' at <interactive>:1:0-11
22:43:49 <bd_> :|
22:43:56 <bd_> :t liftM2 mplus :: (Monoid a, Monoid b, Error a) => (Either a b) -> (Either a b) -> (Either a b)
22:43:57 <lambdabot>     Couldn't match expected type `b' against inferred type `m a'
22:43:57 <lambdabot>       `b' is a rigid type variable bound by
22:43:57 <lambdabot>           the polymorphic type
22:44:01 <_zenon_> mmorrow, which really sucked
22:44:03 <bd_> blah
22:44:25 <mmorrow> _zenon_: yay for java!
22:44:42 <bd_> ah wait
22:44:47 <bd_> :t liftM2 mappend :: (Monoid a, Monoid b, Error a) => (Either a b) -> (Either a b) -> (Either a b)
22:44:49 <lambdabot> forall a b. (Error a, Monoid b, Monoid a) => Either a b -> Either a b -> Either a b
22:45:00 <bd_> dibblego: there you go: liftM2 mappend
22:45:29 <bd_> note that this will not combine Lefts under any case
22:45:44 <mmorrow> ls | tr '\n' ':'
22:46:06 <bd_> mmorrow: filenames may contain embedded \ns
22:46:18 <mmorrow> bd_: those bastards
22:46:31 <dibblego> thanks bd_
22:46:34 <cjs> This quasiquoting stuff is wonderful.
22:47:16 <bd_> mmorrow: hint: find -maxdepth 1 -print0 :)
22:47:39 <Myoma> @w80 magnanimous
22:47:40 <lambdabot> *** "magnanimous" wn "WordNet (r) 2.0"
22:47:40 <lambdabot> magnanimous
22:47:40 <lambdabot>      adj 1: noble and generous in spirit; "a greathearted general"; "a
22:47:40 <lambdabot>             magnanimous conqueror" [syn: {greathearted}]
22:47:40 <lambdabot>      2: generous and understanding and tolerant; "a heart big enough
22:47:42 <lambdabot> [3 @more lines]
22:48:20 <adu> shapr: all done
22:48:21 <mmorrow> bd_: ah, pulling out find are we. exccceelllentt
22:48:43 <mmorrow> adu: ah, me too
22:48:59 <bd_> mmorrow: well you could use for, but that's boring.
22:49:17 <mmorrow> bd_: oh no, i dig the find
22:49:26 <mmorrow> adu: 182M    hpaste.org/
22:50:12 <adu> hmm i have 238M but then again I have duplicates for 0###
22:50:34 <bd_> mmorrow: find -maxdepth 0 -print0 | xargs -P 0 -n 1 -0 perl -e '$_=$ARGV[0]; s|^.\/||; print' | head -c -1 | tr "\0" ":"
22:50:37 <bd_> :D
22:50:49 <Myoma> are you able to paste these back onto hpaste automatically?
22:50:59 <Myoma> wunget
22:51:02 <mmorrow> bd_: nice. that one's going in the ole $HOME/script folder for further analysis
22:51:09 <adu> Myoma: I can serve them on port 8080
22:51:23 * mmorrow has to do sum lernin on find flags
22:51:26 <bd_> mmorrow: careful, it's O(n * sizeof(perl)) memory usage
22:51:30 <mmorrow> haha
22:51:33 <adu> Myoma: I don't know how I would paste them back
22:51:37 <bd_> er, should be -maxdepth 1 not 0
22:52:27 <mmorrow> bd_: wow, i *never* use xargs, and i just realized this is not good ;)
22:52:57 <mmorrow> the only time ever use perl anymore though is in
22:53:02 <mmorrow> perl -lne '.....'
22:53:15 <mmorrow> and it's great
22:53:33 <qebab> xkcd is so great
22:53:56 <bd_> for i in *; do echo -n "$i:"; done | head -c -1 # production version :)
22:55:09 <adu> Myoma: I suppose I could write a script to paste them back...
22:55:20 <Myoma> adu, might not be required
22:55:25 <mmorrow> http://moonpatio.com:8080/hpaste.org/
22:55:32 <adu> Myoma: lets hope :)
23:06:09 <Myoma> @w80 jurgley
23:06:11 <lambdabot> No match for "jurgley".
23:06:18 <mmorrow> here's a complete backup of hpaste http://moonpatio.com:8080/hpaste.org/hpaste.org_20080827.tar.bz2
23:07:25 <_zenon_> Ooo!! I'm sure someone already thought of this, but anyway, if someone has not::::: What about incorporating haskell in shells=
23:07:26 <_zenon_> ?
23:07:58 <_zenon_> so you could do:::       ls somedir | (drop 2 $ reverse)
23:09:17 <lispy> _zenon_: h4sh
23:09:20 <lispy> ?where h4sh
23:09:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
23:09:39 <rwbarton> _zenon_: I have an 'interact' script that lets me do   ls | interact 'unlines . drop 2 . reverse . lines'
23:09:50 <_zenon_> ooh... nice nice indeed
23:09:57 <rwbarton> (I guess those quotes are unnecessary in this case)
23:10:16 <lispy> the shell is a lazy functional language already
23:10:39 <cjs> I just discovered pattern guards. This makes me happy.
23:10:43 <lispy> But it took dons to notice that and make h4sh to prove it :)
23:11:02 <humasect> cjs: they are useful for you? =)
23:11:09 <lispy> cjs: What is it you like about them?  I use them only very occasionally
23:11:21 <lispy> In fact, I have exactly 1 use for them
23:11:29 <mmorrow> a=`cat`; echo $a | head
23:11:30 <rwbarton> lispy: Sure, but try remembering the options to tail :P
23:11:35 <mmorrow> not lazy!
23:11:35 <lispy> And that's for using my EqCheck type to prove some types are equal at runtime
23:11:49 <lispy> mmorrow: heeh
23:11:53 <mmorrow> heh
23:12:07 <_zenon_> So, I'm writing a Marriage library in Haskell
23:12:16 <mmorrow> have you read the oleg thing comparing monadic io to shell pipes and redirecting ?
23:12:21 <mmorrow> i liked it
23:12:22 <lispy> _zenon_: tying the knot?
23:12:31 * mmorrow finds it
23:12:36 <mmorrow> (not tying the knot)
23:12:47 <cjs> Yes. Dealing with stuff like parsing command line options, for example.
23:12:59 <_zenon_> lispy, which will luckily work like a charm for placing people in an efficient way, based on different graph approximation algos.
23:13:01 <mmorrow> http://okmij.org/ftp/Computation/monadic-shell.html
23:13:02 <lambdabot> Title: UNIX pipes as IO monads
23:13:39 <lispy> mmorrow: cool
23:13:42 <lispy> I must get going
23:13:45 <lispy> night all
23:13:48 <mmorrow> night
23:13:49 <cjs> Basically, I can do a bunch of pattern matches to take apart an option and construct the appropriate value, and then have a default that evaluates to an error instead.
23:14:27 <_zenon_> lispy,  night
23:14:42 <cjs> Well, I've only used this once, admittedly, but I only discovered them an hour ago. :-)
23:26:40 <elliottt> anyone know if it's possible to use a foreignptr with a finalizer from within ghci?
23:27:08 <Beelsebob> elliottt: it will be as soon as svoarg's patch gets applied
23:27:17 <Beelsebob> until then you're not guarenteed that the finaliser will run
23:27:30 <Beelsebob> after that, you're not guarenteed when the finaliser will run
23:27:55 <b\6> sounds like a hell of a patch.
23:28:00 <elliottt> Beelsebob: the message that i'm getting is that it requires native code gen, or -fvia-c
23:28:36 <Beelsebob> elliottt: I think it does for finalisers for Haskell land stuff
23:29:01 <Beelsebob> Svoarg's patch guarentees that finalisers in C land will run
23:29:28 <elliottt> Beelsebob: i think my problem might have been using '&' on the foreign import statement
23:29:38 <elliottt> is that required to get a FunPtr?
23:29:45 <Beelsebob> dunno
23:29:48 <elliottt> :)
23:29:54 <elliottt> well, i'll see if things crash
23:30:07 <elliottt> as it loads in ghci without it :)
23:30:45 <humasect> is there a "catMaybes . map (either (\e-> Just e) (\s-> Nothing))" and its inverse somewhere in base libs ?
23:31:06 <Myoma> it doesn't have an inverse
23:31:07 <Myoma> :t map (either (\e-> Just e) (\s-> Nothing))
23:31:09 <lambdabot> forall a b. [Either a b] -> [Maybe a]
23:31:19 <Myoma> it's not injective
23:31:21 <TSC> :t either
23:31:21 <humasect> well, one would call that leftsOf. and the other would be called rightsOf.
23:31:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:31:28 <Myoma> btw
23:31:33 <humasect> not mathematical inverse, my apologies.
23:31:36 <Myoma> :t map (either Just (const Nothing))
23:31:38 <lambdabot> forall a b. [Either a b] -> [Maybe a]
23:31:53 <humasect> ah const, i see, thanks
23:31:54 <elliottt> Myoma: you mean something like, catLefts and catRights?
23:32:21 <Myoma> :t ((either (:[]) (const [])) =<<)
23:32:23 <lambdabot> forall a b. [Either a b] -> [a]
23:32:51 <Myoma> :t ((either (const []) (:[])) =<<)
23:32:53 <lambdabot> forall a a1. [Either a1 a] -> [a]
23:32:53 <humasect> hm=)
23:33:07 <humasect> very cool
23:33:22 <elliottt> Myoma: [ x | Left x <- [Left 10, Right 20, Left 30]]
23:33:28 <Myoma> [Either a b] -> ([a],[b]) -- is this possible ?
23:33:32 <Myoma> is a pointfree way
23:34:23 <mmorrow> :t flip foldl' ([],[]) $ \(ls,rs) -> either (flip (,) rs . (:ls)) ((,) ls . (:rs))
23:34:25 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
23:34:34 <mmorrow> that's as point free as i got it
23:34:44 <mmorrow> (i already had that written somewhere ;))
23:35:00 <mmorrow> @pl flip foldl' ([],[]) $ \(ls,rs) -> either (flip (,) rs . (:ls)) ((,) ls . (:rs))
23:35:01 <lambdabot> foldl' (uncurry (ap (ap . (either .) . flip ((.) . flip (,)) . flip (:)) ((. flip (:)) . (.) . (,)))) ([], [])
23:35:05 <mmorrow> yay
23:35:07 <TSC> Much simpler
23:35:12 <humasect> elliottt=)
23:35:18 <Myoma> :t \x -> (foldr (.) id . map (either (\o -> first (o:)) (\o -> second (o:))) x) ([],[])
23:35:20 <lambdabot>     Couldn't match expected type `a -> [a1 -> a1]'
23:35:20 <lambdabot>            against inferred type `[([a2], [b]) -> ([a2], [b])]'
23:35:20 <lambdabot>     In the second argument of `(.)', namely
23:35:28 <Myoma> :t (foldr (.) id . map (either (\o -> first (o:)) (\o -> second (o:)))
23:35:30 <lambdabot> parse error (possibly incorrect indentation)
23:36:05 <mmorrow> ooh, i like the o's as the var in the lambdas
23:36:08 <Myoma> @pl foldr (.) id
23:36:09 <lambdabot> foldr (.) id
23:36:13 <Myoma> hmrf
23:36:21 <humasect> mmorrow=)
23:36:28 <mmorrow> heh
23:36:43 <Myoma> :t foldr (.) id . map (either (\o -> first (o:)) (\o -> second (o:))
23:36:45 <Myoma> :t foldr (.) id . map (either (\o -> first (o:)) (\o -> second (o:)))
23:36:45 <lambdabot> parse error (possibly incorrect indentation)
23:36:47 <lambdabot> forall a b. [Either a b] -> ([a], [b]) -> ([a], [b])
23:36:51 <Myoma> oh
23:36:55 <Myoma> :t flip (foldr (.) id . map (either (\o -> first (o:)) (\o -> second (o:)))) ([],[])
23:36:57 <mmorrow> ahah
23:36:57 <lambdabot> forall a b. [Either a b] -> ([a], [b])
23:37:11 <Myoma> There is surely a good name for foldr (.) id
23:37:21 <mmorrow> there should be
23:37:22 <elliottt> mconcat?
23:37:24 <elliottt> :)
23:37:33 <mmorrow> > foldr (.) id (repeat read) $ fix show
23:37:36 <lambdabot>  mueval: Time limit exceeded
23:37:39 <mmorrow> aw
23:37:44 <mmorrow> > foldl' (.) id (repeat read) $ fix show
23:37:47 <lambdabot>  mueval: Time limit exceeded
23:38:04 <Myoma> :t let [x,y] = (mconcat,msum) in x
23:38:06 <lambdabot>     Couldn't match expected type `[t]'
23:38:06 <lambdabot>            against inferred type `([a] -> a, [m a1] -> m a1)'
23:38:06 <lambdabot>     In the expression: (mconcat, msum)
23:38:06 <mmorrow> dang, it used to just die having only printed one "
23:38:19 <Myoma> :t let [x,y] = (mconcat,foldr (.) id) in x
23:38:21 <lambdabot>     Couldn't match expected type `[t]'
23:38:21 <lambdabot>            against inferred type `([a] -> a, [a1 -> a1] -> a1 -> a1)'
23:38:21 <lambdabot>     In the expression: (mconcat, foldr (.) id)
23:39:01 <Myoma> :t [mconcat,foldr (.) id]
23:39:03 <lambdabot> forall a. (Monoid a) => [[a -> a] -> a -> a]
23:39:19 <Myoma> :t first . (:)
23:39:21 <lambdabot> forall d a. a -> ([a], d) -> ([a], d)
23:39:23 <Myoma> :t first . (:)
23:39:25 <lambdabot> forall d a. a -> ([a], d) -> ([a], d)
23:39:57 <mmorrow> :t uncurry(flip(,))
23:39:59 <lambdabot> forall b a. (a, b) -> (b, a)
23:40:07 <Myoma> is there an mconcatMap ?
23:40:36 <mmorrow> i wish
23:40:42 <elliottt> Myoma: what would the type of that be?
23:40:49 <mmorrow> mconcat . fmap is so tiresome
23:40:58 <elliottt> :t mconcat . fmap
23:41:00 <lambdabot>     Couldn't match expected type `[a]'
23:41:00 <lambdabot>            against inferred type `f a1 -> f b'
23:41:00 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
23:41:11 <mmorrow> well, that alone ..
23:41:21 <mmorrow> (mconcat .) . fmap
23:41:22 <mmorrow> :t (mconcat .) . fmap
23:41:24 <lambdabot> forall a b. (Monoid b) => (a -> b) -> [a] -> b
23:41:39 <medfly> does lambdabot try to evaluate everything you say?
23:41:47 <elliottt> i've seen that type before
23:41:53 <Myoma> :t flip (mconcat . map (either (first . (:)) (second . (:)))) ([],[])
23:41:55 <lambdabot> forall a b. [Either a b] -> ([a], [b])
23:42:45 <Myoma> :t (. (:)) ||| (. (:))
23:42:47 <lambdabot> forall c a. Either (([a] -> [a]) -> c) (([a] -> [a]) -> c) -> a -> c
23:42:59 <stepcut> :t foldMapDefault
23:43:01 <lambdabot> Not in scope: `foldMapDefault'
23:43:17 <stepcut> 	foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
23:43:53 <stepcut> or perhaps just, foldMap
23:44:00 <elliottt> :t foldMapDefault
23:44:02 <lambdabot> Not in scope: `foldMapDefault'
23:44:10 <stepcut> foldMap :: Monoid m => (a -> m) -> t a -> m
23:44:12 <elliottt> does lambdabot not have Data.Traversable?
23:44:22 <Myoma> :t either (first . ?f) (second . ?g)
23:44:24 <lambdabot> forall a (a1 :: * -> * -> *) c d b. (?g::b -> a1 c c, ?f::a -> a1 d d, Arrow a1) => Either a b -> a1 (d, c) (d, c)
23:44:33 <mmorrow> :t mconcat . fmap (either . ((first .)&&&(second .)) $ (:)) (mempty,mempty)
23:44:34 <lambdabot>     Couldn't match expected type `a -> c'
23:44:35 <lambdabot>            against inferred type `(a2 -> a1 (b, d) (c1, d),
23:44:35 <lambdabot>                                    a2 -> a1 (d1, b) (d1, c1))'
23:44:44 <elliottt> :t Data.Traversable.foldMapDefault
23:44:45 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Traversable.Traversable t) => (a -> m) -> t a -> m
23:45:05 <mmorrow> :t mconcat . fmap (uncurry either . ((first .)&&&(second .)) $ (:)) ([],[])
23:45:07 <lambdabot>     Couldn't match expected type `[]'
23:45:07 <lambdabot>            against inferred type `(->) ([b], [b])'
23:45:07 <lambdabot>     Probable cause: `$' is applied to too few arguments
23:45:11 <mmorrow> gah
23:45:11 <Myoma> @hoogle (a -> c -> c) -> (b -> d -> d) -> Either a b -> (c, d) -> (c, d)
23:45:12 <lambdabot> No results found
23:45:16 <Myoma> ?djinn (a -> c -> c) -> (b -> d -> d) -> Either a b -> (c, d) -> (c, d)
23:45:17 <lambdabot> f a b c =
23:45:17 <lambdabot>     case c of
23:45:17 <lambdabot>     Left d -> \ (e, f) -> (a d e, f)
23:45:17 <lambdabot>     Right g -> \ (h, i) -> (h, b g i)
23:46:36 <mmorrow> :t \xs f x -> maybe (f x) id (lookup x xs)
23:46:38 <lambdabot> forall a a1. (Eq a1) => [(a1, a)] -> (a1 -> a) -> a1 -> a
23:46:42 <mmorrow> @pl \xs f x -> maybe (f x) id (lookup x xs)
23:46:42 <lambdabot> flip (ap . flip flip id . (maybe .)) . flip lookup
23:46:53 <Myoma> :t filter left &&& filter right
23:46:55 <lambdabot>     Couldn't match expected type `Bool'
23:46:55 <lambdabot>            against inferred type `a (Either b d) (Either c d)'
23:46:55 <lambdabot>       Expected type: a b c -> Bool
23:47:01 <Myoma> :t left
23:47:02 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
23:47:12 <Myoma> liftM2 (&&&) (filter left) (filter right)
23:47:34 <b\6> anyone know if parsec does anything with the second element of the pair Stream's uncons returns? is it for lookahead?
23:47:59 <mmorrow> err, that's the rest of the stream i believe
23:48:19 <mmorrow> i don't know the particulars with parsec, but that's usually the case
23:48:39 <mmorrow> :t head&&&tail
23:48:41 <lambdabot> forall a. [a] -> (a, [a])
23:50:09 <Myoma> @let (f & g) x = (f x, g x)
23:50:11 <lambdabot> Defined.
23:50:23 <mmorrow> :t head&tail
23:50:24 <lambdabot> forall a. [a] -> (a, [a])
23:50:31 <Myoma> > liftM2 (&) (filter odd) (filter even) [1,2,3,4,5]
23:50:33 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `[a]'
23:50:39 <Myoma> :t liftM2 (&)
23:50:41 <lambdabot> forall t t1 t2 (m :: * -> *). (Monad m) => m (t -> t1) -> m (t -> t2) -> m (t -> (t1, t2))
23:51:36 <mmorrow> :t fmap (uncurry(:)) . join (zipWith (&)) . replicate 4
23:51:38 <lambdabot>     Couldn't match expected type `(a, [a])'
23:51:38 <lambdabot>            against inferred type `t -> (t2, t2)'
23:51:38 <lambdabot>       Expected type: (t -> t2) -> [(a, [a])]
23:52:10 <mmorrow> :t \xs -> fmap (uncurry(:)) . zipWith (&) (replicate xs 8) $ repeat xs
23:52:12 <lambdabot>     Couldn't match expected type `(a, [a])'
23:52:12 <lambdabot>            against inferred type `t -> (t1, t2)'
23:52:12 <lambdabot>       Expected type: [t -> t2] -> [(a, [a])]
23:53:28 <mmorrow> > fmap (uncurry(:) . (head&tail)) (replicate 4 [0..4])
23:53:31 <lambdabot>  [[0,1,2,3,4],[0,1,2,3,4],[0,1,2,3,4],[0,1,2,3,4]]
23:53:42 <Myoma> heh uncurry(:) . (head&tail)
23:53:47 <mmorrow> hehe
23:53:58 <Myoma> map id . filter (let in const True)
23:54:22 <mmorrow> whoa is (let in const True) valid?
23:54:30 <mmorrow> :t (let in const True)
23:54:32 <lambdabot> forall b. b -> Bool
23:54:33 <Myoma> > map id . filter (let in const True) $ "thunthaoeu"
23:54:34 <mmorrow> cool
23:54:36 <lambdabot>  "thunthaoeu"
23:54:43 <mmorrow> ha
23:58:47 <Myoma> hm
23:58:55 <Myoma> maybe I should prototype a language in lambda prolog
23:59:47 * Myoma wonders how to do efficent lazy evaluation on HOAS terms .. :/
23:59:52 <Myoma> I think it's too hard
23:59:59 <mmorrow> try it!
