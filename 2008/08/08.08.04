00:01:47 <hml> i   realixe this is hearesey, ... how do i create a global Data.IORef ?
00:02:19 <hml> @src GLFW.getKey
00:02:19 <lambdabot> Source not found. :(
00:03:36 <sjanssen> hml: globalref = unsafePerformIO (newIORef x)
00:03:50 <sjanssen> but there are several things you absolutely must to do make this safe
00:04:14 <sjanssen> firstly, give globalref an explicit type with no type variables
00:04:29 <sjanssen> also, use an {-# NOINLINE globalref #-} pragma
00:04:58 <sjanssen> hml: but the best answer is to simply not do it if at all possible
00:08:02 <bos> i'm trying to create a simple explanation for why (++) can execute in constant space, but it's too late at night for me to think clearly.
00:08:21 <hackage> Uploaded to hackage: haddock 2.2.1
00:08:37 <TSC> Laziness?
00:09:23 <bos> TSC: yes, the point is to explain how laziness occurs, but without going into much detail.
00:09:47 <TSC> It's because you can figure out head(xs ++ ys) in constant space
00:09:48 <Cale> bos: Well, to produce the first element of its result, it only has to look at the first element of its left parameter (or if that's empty, its right parameter). Once that's been determined, the element can be reclaimed.
00:12:19 <bos> Cale: what i'm tripping over is how to explain that we don't need extra stack space in haskell.  write (++) in ocaml, and it needs linear heap and stack.
00:12:39 <bos> i don't know whether to just not mention that, or to say something.
00:14:28 <Trinithis> Is standard IO lazy? In ghci, my program does IO fine, but when I compile it, some input is done before it should be.
00:14:34 <jganetsk_> does it require linear stack?
00:14:34 <Cale> hmm... well, the way I think of it is that evaluation is demanded by some case expressions which are eating the stack from the other end :)
00:14:37 <jganetsk_> in OCaml?
00:14:43 <Cale> Trinithis: It's the buffering
00:14:52 <Trinithis> How do I fix it?
00:15:16 <Cale> Trinithis: hSetBuffering stdout NoBuffering -- perhaps
00:15:21 <jganetsk_> i don't think ti requires linear stack in ocaml
00:15:33 <Trinithis> lemme try....
00:16:33 <Cale> jganetsk_: Well... at least the way that it's written:  [] ++ ys = ys; (x:xs) ++ ys = x : (xs ++ ys)
00:16:57 <Trinithis> Cale: Works like a charm!
00:17:20 <Cale> jganetsk_: You have to do something with the result of the recursive call, so it's not tail recursive written that way.
00:18:33 <Cale> jganetsk_: In a strict language, you can avoid the stack costs by building up the value in an accumulating parameter, but you can't run in constant space obviously.
00:20:18 <Cale> mm... also it seems a bit awkward to write in terms of an accumulating parameter, since it's easier to add to the front of a list than the end.
00:20:37 <dolio> You'd have to accumulate an [a] -> [a]
00:21:34 <dolio> CPS transform, basically, I guess.
00:25:38 <dolio> Or double-reverse. But that's the same thing if you squint.
00:26:49 <dolio> Both recreating the call stack on the heap.
00:28:28 <jganetsk_> http://pastebin.com/m18f32d7e
00:30:40 <BeelsebobWork> Is there a good reason why common container operations are not a class yet?
00:30:43 <Trinithis> tiz nice that haskellers are able to resort to lazy recursion over tail recursion
00:30:45 <BeelsebobWork> (e.g. union/intersection etc)
00:31:09 <Trinithis> and a size operation!
00:31:22 <dolio> BeelsebobWork: Union would be covered by Monoid.
00:31:43 <BeelsebobWork> no it wouldn't
00:31:51 <BeelsebobWork> monoid has an operation that looks very similar
00:31:54 <BeelsebobWork> what it is not, is union
00:32:24 <BeelsebobWork> (it's union but more general)
00:32:33 <BeelsebobWork> and it doesn't make as much sense in code either
00:32:58 <Trinithis> Union vs concatenation?
00:33:00 <BeelsebobWork> (which is more readable -- set1 `union` set2, or set1 `mappend` set2
00:33:19 <dolio> The collections package on hackage might have stuff more geared toward collections.
00:33:27 <BeelsebobWork> yeh, it does
00:33:27 <Trinithis> I defined (++) = mappend like lambdabot
00:33:29 <dolio> set1 ++ set2, clearly. :)
00:33:42 <BeelsebobWork> yeh, but that's semantically wrong
00:33:52 <BeelsebobWork> that's set2 appended onto set1, which is not necessarily a set
00:34:01 <Trinithis> ++ semantically means append in my book
00:34:15 <BeelsebobWork> what I'm mostly pondering is why I need to qualify Set.union, Map.union, IntMap.union etc, when it could all be done with a class
00:34:32 <BeelsebobWork> Trinithis: exactly -- which is not the same as union, and for sets doesn't exist
00:34:58 <dolio> The monoid action on sets isn't append, though. It's union.
00:35:06 <luqui> BeelsebobWork, what does the class mean?
00:35:12 <Trinithis> Does union satisfy monoid laws?
00:35:18 <BeelsebobWork> exactly -- so the monoid action *isn't* union
00:35:21 <BeelsebobWork> it's something more general
00:35:38 <dolio> But in the case of Sets, Maps and IntSets, it is union.
00:35:44 <luqui> Trinithis, yes, with empty set as unit
00:35:49 <BeelsebobWork> which causes set1 `mappend` set2 is a lot less readable than set1 `union` set2
00:35:56 <Trinithis> So ++ should work then
00:36:03 <BeelsebobWork> but ++ is semantically append
00:36:04 <BeelsebobWork> not union
00:36:12 <BeelsebobWork> append and union are not the same thing
00:36:20 <Trinithis> Think of it as a monoid (*)
00:36:27 <BeelsebobWork> no
00:36:36 <BeelsebobWork> I don't want people reading my code to have to "think of this as a monoid"
00:36:39 <Trinithis> Define union = mappend
00:36:40 <BeelsebobWork> I want them to read my intention
00:36:49 <BeelsebobWork> yes -- but then I get back to the same problem
00:36:54 <BeelsebobWork> in Set you define union = mappend
00:36:58 <BeelsebobWork> in Map you do the same
00:37:01 <BeelsebobWork> now you have to qualify them
00:37:16 <Trinithis> If people see the type to be Set, then they shouldn't be confusing union with append
00:37:17 * luqui actually likes having multiple names, so that class instances are single simple lines like mappend = union
00:37:20 <dolio> collections does have a union method of a Map class.
00:37:21 <Trinithis> it should be evident
00:37:31 <dolio> Although it doesn't build on 6.8 according to hackage...
00:37:57 <dolio> Cabal problems from the looks of it.
00:37:58 <luqui> and then when you're specifically talking about sets, you union, and when you have general actions, you use mappend...
00:38:09 <luqui> but I am also out of the context of this convo...
00:38:10 <BeelsebobWork> Trinithis: yes -- the point is, my code should read as it's intention -- I should be writing exactly what I mean, and I mean "take the union of these two sets"
00:38:25 <BeelsebobWork> luqui: yeh -- that's mostly what I do
00:38:32 <BeelsebobWork> what I was commenting on is that it becomes a bit ugly
00:38:47 <BeelsebobWork> in that if you have a module that imports both Set and Map, you have to start qualifying things everywhere
00:38:58 <BeelsebobWork> hence, it would be nice if common container operations had a class of their own
00:39:07 <BeelsebobWork> (containing things like union/size etc)
00:39:15 <luqui> if you could come up with a reasonable meaning for that class
00:39:32 <BeelsebobWork> yep
00:39:34 <luqui> (it's not entirely obvious to me what it means to be a container
00:39:34 <BeelsebobWork> ofc
00:39:45 <BeelsebobWork> no, but I think it's probably something that could be defined
00:40:05 <luqui> as in, are set union and map union _really_ the same thing in some sense, or do they just look about the same?
00:40:07 <Trinithis> Oh, I was just thinking you wanted a union operator, and not other stuff like size
00:40:29 <BeelsebobWork> Trinithis: no, general stuff for containers
00:40:37 <dolio> @hackage collections
00:40:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections
00:40:48 <BeelsebobWork> luqui: that's an interesting question -- but my suspicion is that union really *is* the same thing for all of them
00:40:49 * luqui was working on a zf module earlier today... size is kinda tough
00:41:34 <BeelsebobWork> zf?
00:41:55 <luqui> zermelo frankel!
00:42:31 <luqui> (set theory, constructing sets by axioms)
00:42:39 <luqui> implementing toList is quite a challenge ;-)
00:42:48 <luqui> (by which I mean I had no idea how to do it)
00:43:01 <BeelsebobWork> heh
00:43:03 <jganetsk_> lists don't count as containers
00:43:08 <jganetsk_> they don't have unions
00:43:19 <jganetsk_> intsets are sets... so you are stuck with sets and maps
00:43:21 * BeelsebobWork is staring at the wikipedia page now
00:43:21 * luqui considers ++ a certain kind of union...
00:43:38 <BeelsebobWork> luqui: I think that's pretty dangerous
00:44:05 <BeelsebobWork> I would have expected union to include some kind of "overlaps get covered only once" section
00:44:14 <luqui> what would union be for a bag?
00:44:24 <BeelsebobWork> oh, that's a good point
00:44:38 <jganetsk_> why don't you define a class called Setoid
00:44:45 <Trinithis> If you want, here's some ideas to consider http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html
00:45:01 <BeelsebobWork> Trinithis: I'm not sure that starting with java is a good thing ;)
00:45:17 <Trinithis> I know, but wouldnt hurt to see if you are missing anything
00:45:22 <BeelsebobWork> yep
00:45:25 <Stinger> yeah last thing we need is haskell becoming more like Java :P
00:46:05 * BeelsebobWork runs off to do some work having had his minor rant -- I was mostly pissed off that my code currently contains billions of tiny little qualifications everywhere
00:46:15 <Trinithis> The only things that could be of use would be empty and size in it imo
00:46:26 <mmorrow> luqui: these links may be useful:
00:46:31 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html
00:46:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2h2prk
00:46:37 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html
00:46:38 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2bjwxd
00:47:22 <mmorrow> bags:
00:47:23 <mmorrow> http://darcs.haskell.org/ghc/compiler/utils/Bag.lhs
00:47:47 <Trinithis> MVar!!!!
00:48:04 <hml> so i'm really used to idednting with 2 spaces, but do forces jme to ident with 3 spaces ... should i now just default to 3 spaces?
00:48:21 <Trinithis> hml: What? I use 2 in do
00:49:31 <glguy> i do ... too!
00:49:46 <Trinithis> pun?
00:50:05 <TSC> hml: You can use 2, as long as you don't put anything after the do
00:50:31 <Trinithis> main = do\n  putStrLn "hi"
00:51:32 <hml> hmm, interesting; thanks
00:53:36 <luqui> mmorrow, heh, thanks, but that was a rhetorical question :-)
00:55:00 <mmorrow> luqui: hehe. i realized after i'd already hit enter, but alas! it was too late ;)
00:57:33 <glguy> You should apply to have the logs redacted!
00:58:03 <luqui> it's okay, I took a continuation around 45 past
00:58:33 <mmorrow> i demand a sentence in the "corrections" section after the letters to the editor!
01:05:01 <audreyt> dcoutts_: Thanks, I managed to get the parts I needed to get Pugs going working
01:05:08 <audreyt> dcoutts_: patch is on its way to your mailbox
01:05:53 <pozic> Why doesn't the following work lazily? http://paste.debian.net/13843/
01:06:23 <pozic> take 5 $ foldr (:) [1..] does work and a similar pattern doesn't work.
01:07:40 <newsham> ?hoogle a -> (b -> [b] -> a) -> [b] -> a
01:07:41 <lambdabot> No matches, try a more general search
01:08:12 <newsham> there's no Data.List equiv of Data.Maybe.maybe ?
01:08:53 <thetallguy> A question about recursive type declarations
01:09:16 <thetallguy> I want to use Data.Map to make a tree
01:09:40 <MyCatVerbs> thetallguy: I want a pony.
01:09:52 <MyCatVerbs> thetallguy: er, I mean. Yyyyes? :)
01:10:10 <thetallguy> I gather I cannot do that simply with a type synonym, e.g.  type Tree = Map Int Tree
01:10:11 <mmorrow> MyCatVerbs: and i want it NOWWW daddy!
01:10:48 <thetallguy> MyCatVerbs: I know a story of a guy who got out of a job he didn't want by asking for a pony in the negotiations...
01:11:01 <MyCatVerbs> thetallguy: that's circular, a mapping from integers to... what?
01:11:09 <thetallguy> So, do I have to use Data and make a new Constructor?
01:11:27 <thetallguy> Map Int (Map Int (Map Int...
01:11:41 <MyCatVerbs> thetallguy: please make new constructors. :)
01:11:52 <thetallguy> Oh, but they are so clumsy
01:12:05 <thetallguy> Make me type a whole 'nother word.
01:12:15 <thetallguy> I suppose I need to end the recursion sometime.
01:12:17 <MyCatVerbs> thetallguy: you *can* achieve Map Int (Map Int (Map Int..., but it's not really a very pleasant way to model a tree, and it's a bit evil.
01:12:46 <Botje> pozic: define "doesn't work" ?
01:12:46 <pozic> Can anyone look at my paste?
01:12:47 <thetallguy> I really want Map Int (Maybe Map Int...
01:12:58 <mmorrow> why's it evil?
01:13:05 <MyCatVerbs> thetallguy: there aren't exactly many operations that you can conveniently express using that definition. Perhaps you should be looking into Data.Tree?
01:13:16 <pozic> Botje: take 5 (takeOneInN 5 [1..]) gives a stack overflow.
01:13:32 <MyCatVerbs> mmorrow: because it involves a fixed-point operator on types. So there. :P
01:13:55 <Botje> pozic: then it's _TOO_ lazy :)
01:14:04 <pozic> Botje: it seems this definition is productive, so it should work.
01:14:05 <mmorrow> i'm gonna go cry and think of ponies now
01:14:17 <dolio> It's evil because it allows too many typos to be correctly typed.
01:14:30 <MyCatVerbs> dolio: hah. That too.
01:14:35 <mmorrow> unsafePerformTypo to the notrescue!
01:15:08 <thetallguy> MyCatVerbs: I figured it out.  I was thrown off by another problem.
01:15:10 <Botje> pozic: personally, i'd write that as map snd $ filter (\(x,_) -> x `mod`n == 0) $ zip [0..] list
01:15:16 <MyCatVerbs> dolio: but, newtype Fix f = Mu (f (Fix f)), so you can get infinite tower types explicitly. (Mu [], Mu Either String, etc)
01:15:41 <Botje> pozic: I think you are accumulating too much unevaluated code (thunks) in the second parameter
01:15:46 <Botje> "result", that is
01:16:27 <dolio> MyCatVerbs: Sure. But typos are why you need a wrapper like that.
01:16:36 <dolio> More or less.
01:16:40 <pozic> Botje: can it be fixed while still using foldr?
01:16:48 <Botje> think so
01:16:56 <MyCatVerbs> dolio: yeah, I've read the rant on why allowing infinite types is such a suicidally bad idea. :)
01:17:00 <Botje> if ... then result `seq` (1,element:result)
01:17:09 <Botje> i _think_ that should do it
01:17:28 <Botje> don't have access to a haskell interpreter right now
01:17:33 <pozic> It's kind of stupid that the compiler doesn't see that.
01:17:42 <Botje> pozic: well, it's being lazy for you
01:17:52 <mmorrow> pozic wants a pony too :)
01:18:01 <Botje> since you never use the second element until the end
01:18:09 <Botje> MyCatVerbs: suicidally bad ideas?
01:18:14 <Botje> why, we _MUST_ just implement them
01:18:21 <Botje> otherwise we'd become famous!
01:18:23 <MyCatVerbs> Botje: we have! As fixpoint operators!
01:18:26 <MyCatVerbs> mmorrow: y'know what I -really- want?
01:18:32 <mmorrow> a burro??
01:18:34 <MyCatVerbs> mmorrow: rocking horse dung.
01:18:36 <Botje> MyCatVerbs: _two_ ponies?
01:18:40 <Botje> aww :(
01:18:54 <mmorrow> MyCatVerbs: wow, i hope it smells like cedar.
01:19:01 <MyCatVerbs> It's so rare, I could ebay it and buy _three_ ponies with the proceeds.
01:19:10 <Botje> three, you say.
01:19:18 <MyCatVerbs> And feed them, too.
01:19:24 * Botje prepares the pony kidnapping kit
01:19:27 <pozic> Botje: it doesn't help
01:19:27 <Botje> where did you live again?
01:19:53 <MyCatVerbs> Botje: whoa, slow down there.
01:19:56 <mmorrow> you could also sell one for two llama and use them as pack animals in the andes
01:20:02 <MyCatVerbs> Botje: I don't even have the rocking horse dung yet!
01:20:28 <MyCatVerbs> Botje: you're supposed to be lazy, not eager.
01:21:25 <Botje> but his fold is strict in that fst part, surely?
01:21:41 <Botje> or is it the element mucking things up?
01:23:11 <Botje> pah
01:23:19 * Botje goes back to reading about dynamic templates in .net
01:23:23 <pozic> Botje: I tried compiling it with optimizations, but that also doesn't work. There must be something wrong with the code.
01:24:27 <pozic> Botje: I think it's too strict.
01:24:40 <pozic> It's only computing 5 elements after all.
01:26:26 <Botje> the map/filter/zip solution i gave above should be lazy enough
01:26:47 <Botje> but i don't know how to fix up your solution
01:26:56 <Botje> in fact, i'm not sure if it can be done :/
01:27:10 <Botje> i hope i'm wrong :)
01:27:35 <mmorrow> > let go _ [] = [] ; go f (x:xs) = x : go f (f xs) ; takeOneInN n = go (snd . splitAt (n-1)) in takeOneInN 8 [0..40]
01:27:39 <lambdabot>  [0,8,16,24,32,40]
01:28:05 <vixey> why not map head . chunks 8
01:28:20 <vixey> or chunk
01:28:45 <mmorrow> vixey: that function is actually very similar to chunks.... the go is the same
01:28:51 <mmorrow> (interestingly)
01:29:19 <Botje> pozic: heh. i just realized
01:29:22 <rwbarton> pozic: your counter counts from the end of the list
01:29:32 <Botje> because of the foldr, you need to always walk to the end of the list
01:29:34 <mmorrow> actually, almost.. and that's just with a particular chunks that i wrote earlier..
01:29:46 <Botje> because you keep appending items to the front
01:29:58 <rwbarton> pozic: try it on a finite list
01:30:04 <Botje> so to find the first item of the list you need to walk everything
01:30:09 <Botje> that's bad :)
01:30:44 <Botje> BLAH
01:30:46 <Botje> never mind
01:30:49 <Botje> i'm not awake yet
01:31:06 <mmorrow> > let go f xs = let (y,ys) = f xs in y : go f ys ; chunks = (takeWhile (not . null) .) . go . splitAt in fmap last . chunks 8 $ [0..40]
01:31:07 <lambdabot>  [7,15,23,31,39,40]
01:31:15 <mmorrow> oops, not wuite
01:31:19 <mmorrow> s/w/q/
01:31:32 <mmorrow> ah
01:31:33 <pozic> rwbarton: it works on a finite list, I already knew that.
01:31:42 <mmorrow> > let go f xs = let (y,ys) = f xs in y : go f ys ; chunks = (takeWhile (not . null) .) . go . splitAt in map head . chunks 8 $ [0..40]
01:31:43 <lambdabot>  [0,8,16,24,32,40]
01:33:28 <rwbarton> *Main> takeOneInN 3 "abcde"
01:33:28 <rwbarton> "be"
01:33:40 <rwbarton> I don't think that's what you were expecting
01:33:42 <vixey> > map head $ chunk 8 [1..]
01:33:43 <lambdabot>  [1,9,17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137,145,153,161,169,17...
01:33:59 <mmorrow> oh no fair, you already have chunk defined :)
01:34:14 <Botje> mmorrow: go = unfoldr . Just
01:34:26 <mmorrow> Botje: ooh, nice
01:34:43 <rwbarton> @src iterate
01:34:43 <lambdabot> iterate f x =  x : iterate f (f x)
01:34:51 <mmorrow> heh
01:34:57 <rwbarton> I see, yours has a pair
01:36:07 <mmorrow> yeah, the splitAt
01:36:40 <pozic> Mine works too now.
01:36:43 <mmorrow> but the go in the version of takeOneInN is exactly iterate
01:36:50 <pozic> Doesn't even use mod anymore :)
01:37:10 <mmorrow> (except that it stops when [])
01:37:28 <mmorrow> pozic: do show!
01:38:20 <pozic> http://paste.debian.net/13845/
01:38:36 <pozic> It's not short, but should be fast.
01:38:47 <hml> which one of these operators is generally unused? !@#$%^&*_<> i'm looking to define my own set of infix operators; and want to have a prefix that is not generally used
01:39:13 <vixey> hml: You can make your own module and use existing operators
01:39:38 <hml> i'd like to export tem
01:39:39 <vixey> hml: haskell doesn't come with any non-ascii operators defined
01:39:43 <vixey> you can still do that
01:39:52 <hml> i don't want to overwdie existing ones
01:39:58 <hml> haskell supports unicode?
01:40:08 <hml> suggestion is to use unnicode cahars as infix operators?
01:40:32 <hml> @src #
01:40:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:40:40 <hml> @hoogle #
01:40:41 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
01:40:41 <lambdabot> Data.Ord.(>) :: Ord a => a -> a -> Bool
01:40:41 <lambdabot> Prelude.(>=) :: Ord a => a -> a -> Bool
01:40:41 <pozic> hml: unicode chars are annoying to type.
01:41:06 <hml> where does haskell chars define which ones are infix and which ones are notg?
01:41:33 <Botje> hmm
01:41:37 <Botje> paste.debian.net is slow :(
01:41:43 <sjanssen> @google haskell 98 report
01:41:44 <lambdabot> http://www.haskell.org/onlinereport/
01:41:44 <lambdabot> Title: The Haskell 98 Language Report
01:41:50 <sjanssen> hml: look in there
01:42:23 <Botje> pozic: is there a good reason you're still using foldr?
01:42:28 <pozic> Botje: no
01:42:29 <Botje> you might as well just use filter :)
01:43:19 <Botje> filter ((==0) . snd) $ zip list (cycle [0..n-1])
01:44:14 <ibid> anybody care to comment on http://planet.haskell.org/faq.html ?
01:44:15 <lambdabot> Title: FAQ – Planet Haskell
01:44:22 <trez> > let bajs = ("abc"==) . sort . show
01:44:22 <lambdabot>  Parse error at end of input
01:44:23 <hml> sjanssen: got it; found that
01:44:26 <hml> sjanssen: thanks
01:45:02 <Botje> haskell celebrity? O_o
01:45:24 <audreyt> what does that title even mean ;)
01:45:43 <ibid> what do you think it means? :)
01:45:54 <Botje> it's a bit pompous imo :p
01:45:55 <dolio> ibid: "What kids of blogs are eligible"
01:46:00 <ibid> (it's been a part of the planet policy since a long time)
01:46:11 <Botje> ibid: "to get a blog added, send AN email to ..."
01:46:32 <ibid> Botje: what, you mean two emails are not okay? :)
01:46:56 <ibid> Botje: i'm using email as an uncountable noun there - or at least that's the intent
01:47:27 <audreyt> s/and virtually no blog satisfies them all/and there is no need to satisfies all of them/
01:47:38 <ibid> audreyt: why?
01:48:02 <ibid> (that changes the meaning, btw)
01:48:04 <audreyt> it seems weird to tell people their blog cannot satisfy all of them
01:48:08 <audreyt> for example, my blog.
01:48:24 <hml> what documnentatino do you guys use for unicode? 'man ascii is very useful, man unicode is not as useful; manly interested in getting lists of chars that are alpha, numeric, and considedred to be symoblhs
01:48:24 <audreyt> I was wondering which one criteria it does not satisfy upon reading that sentence
01:49:25 <ibid> audreyt: "virtually no" is not the same thing as "no" :)
01:50:16 <audreyt> oh well. ok :)
01:50:45 <audreyt> "as blogs seldom satisfy all of them"
01:50:53 <ibid> audreyt: mm, ok :)
01:52:57 <ibid> the "haskell celebrity" term is intended to refer to people who have made significant contributions to the language or the community in the past but who aren't necessarily active any more
01:53:13 <ibid> (i believe one of the current blogs qualify chiefly by that criterion)
01:53:22 <ibid> *qualifies
01:54:22 <audreyt> which blog is that if I may ask?
01:54:27 <luqui> wadler?
01:55:02 <dolio> Reymont.
01:55:03 <ibid> wadler
01:55:19 <ibid> reymont is no longer listed
01:55:31 <dolio> Oh, okay.
01:56:03 <ibid> (was infact listed in error - he'd asked to be removed and he had been removed but somehow got re-added)
01:56:07 <audreyt> ibid: in any case, would you mind adding me (http://pugs.blogs.com/) to it? I've resumed active blogging and most posts there will be haskell related (for example today's post is going to be about cabal-install.)
01:56:08 <lambdabot> Title: Pugs
01:56:12 <dolio> Is FP Lunch still on there? It's not Haskell, but I imagine it appeals to people who read the planet.
01:56:25 <dolio> Or, usually not Haskell.
01:56:33 <Botje> no audreyt, you have to send an email proving you're the author ;)
01:56:57 <Botje> bah, vmware ate my control key
01:57:20 <audreyt> ok, done
02:02:11 <pozic> Anyone who used the microbench library?
02:02:40 <pozic> I just did and it doesn't work. It just keeps spinning without any output.
02:02:50 <pozic> I guess the functions are too fast to measure.
02:05:03 <pozic> Ah, the demo doesn't even work.
02:08:22 <hackage> Uploaded to hackage: Stream 0.2.6
02:08:54 <ibid> updated the faq (including a new question:)
02:09:34 <ibid> audreyt: i don't mind, but as you apparently have sent the email, i'm waiting for it to pass greylisting so i can have it properly recorded in my records :)
02:10:22 <audreyt> mmm the paperworks
02:10:25 <audreyt> ok, thanks :)
02:25:50 <guenni> hi, what is the recommended way to interface with windows COM in haskell?
02:34:20 <hml> i want to define a plane as a union of a Vector3 of type 't' and a scalar of type 't', is the foll.owing what I want?
02:34:23 <hml> data Plane t = Vector3 t t
02:34:25 <hml> it looks kind of weird
02:38:03 <EvilTerran> data Plane t = Plane (Vector3 t) t
02:38:22 <EvilTerran> the first word after the = is a new value constructor
02:38:29 <EvilTerran> then the types of its parametersw
02:39:03 <EvilTerran> this means you'd end up with the constructor "Plane :: Vector3 t -> t -> Plane t"
02:41:33 <hml> EvilTerran: awesome; thanks
02:42:57 <EvilTerran> hml, you can use a different name for the constructor and the type, if you like
02:43:32 <EvilTerran> as in, "data Plane t = VectorPlane (Vector3 t) t | ThreePtPlane (Vector3 t) (Vector3 t) (Vector3 t)"
02:43:34 <EvilTerran> or what-have-you
02:43:57 <EvilTerran> but, if you only have one constructor, it often makes sense to give it the same name as the type
02:46:41 <hml> why am i getting a parse error on the second @ in the following:
02:46:43 <hml> intersect @plane(Plane @normal(GL.Vector3 nx ny nz) offset) @ray(Ray @loc(GL.Vector3 lx ly lz) @dirc(GL.Vector3 dx dy dz)) =
02:47:30 <Baughn> hml: That should be plane@/ray@, and so on
02:47:48 <vixey> hml: why are prefixing everything with @ symbols?
02:49:17 <b\6> messed up as-patterns.
02:50:57 <hml> vixey: i'm stupid; wasn't sure if i needed to open it up in th einner level (didn't)
02:52:37 <hml> @src Maybe
02:52:37 <lambdabot> data Maybe a = Nothing | Just a
02:52:44 <hml> is Nothing == return () ?
02:53:03 <ziman> no
02:53:11 <ziman> > fail "" :: Maybe Int
02:53:16 <lambdabot>  Nothing
02:53:24 <ziman> > return () :: Maybe ()
02:53:25 <lambdabot>  Just ()
02:54:00 <hml> > return () :: Maybe ()
02:54:01 <lambdabot>  Just ()
02:54:09 <hml> ziman: taht is a cool trick; thanks :-)
02:54:19 <ziman> yw ;)
02:54:45 <hansfbaier> Has anyone ever compiled downloaded and installed HApps successfully?
02:54:57 <dolio> Surely someone has.
02:55:04 <vixey> I certainly haven't
02:58:53 <Baughn> hansfbaier: Sure, but that was back in the 6.6 days
02:59:00 <Baughn> Still, what about it?
03:00:21 <hansfbaier> Baughn: thanks, one of the folks in #happs helped me out...
03:00:43 <ibid> audreyt: added
03:02:10 <audreyt> danke
03:09:13 <ivanm> Lemmih: in this mailing list post of yours, what do you mean by plot pixels? as in graphs, or drawings? http://www.haskell.org/pipermail/haskell-cafe/2007-October/032997.html
03:09:14 <lambdabot> Title: [Haskell-cafe] Pixel plotter, http://tinyurl.com/5un4sw
03:10:24 <Lemmih> ivanm: That's not my post, I'm afraid.
03:10:24 <lambdabot> Lemmih: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:10:30 <b\6> monadius build for anyone?
03:10:51 <ivanm> Lemmih: you mean there's more than one person with the nick lemmih? :o
03:12:23 <xerox> ivanm: he wrote the code, not the post.
03:12:26 <Lemmih> ivanm: The poster is Roel van Dijk. I just wrote hsSDL.
03:12:30 <ivanm> ahhh
03:12:43 <ivanm> I figured if it was in your repo, you must have made the post :s
03:13:35 <ivanm> dammit, I've been waiting for you to come online for the past couple of days so I could ask you what you meant by that post, and only _now_ I find out it's not you!!! :s
03:13:53 <ivanm> oh well, I would probably only have procrastinated even more if I knew beforehand :p
03:16:22 <chrisdone> hansfbaier: I have, just recently
03:16:31 <chrisdone> hansfbaier: reading and understanding the documentation, however
03:16:35 <chrisdone> ..
03:17:42 <hansfbaier> chrisdone: it really sucks to download all the deps manually, compiling and installing them, I hope cabal-install works....
03:18:08 <chrisdone> hansfbaier: I just ran the line on the home page. use searchpath
03:18:23 <chylli> where is ghc 6.8.3 on archlinux ?
03:18:23 <chrisdone> hansfbaier: it downloads and installs everything you need
03:18:35 <hansfbaier> chrisdone: doesnt work for me.
03:18:40 <chrisdone> hansfbaier: :(
03:19:03 <hansfbaier> http://hpaste.org/9376
03:19:48 <chrisdone> hansfbaier: sudo cabal install hslogger
03:20:06 <chrisdone> hansfbaier: I think I had that problem too, just install hslogger and re-do the sp command
03:20:50 <hansfbaier> chrisdone: did it, but then it complains about xhtml, html ...........
03:21:06 <chrisdone> hansfbaier: hm, lame
03:21:48 <hansfbaier> chrisdone: now I got cabal-install, that works nice. Got them together, Happs is compiling now.
03:22:03 <chrisdone> hansfbaier: good luck
03:22:36 <hansfbaier> chrisdone: now it works...
03:22:58 <hansfbaier> chrisdone: I guess the source is more readable than the docs (of what I heard)
03:23:27 <pmurias> is it possible to have Show do pretty-printing?
03:24:33 <vixey> yes
03:24:45 <pmurias> how?
03:25:02 <BeelsebobWork__> write it
03:25:14 <BeelsebobWork__> otoh, you're probably more interested in the Pretty instance
03:25:20 <BeelsebobWork__> s/instance/class/
03:26:13 <chylli> ghc 6.8.3 has not been ported to archlinux ?
03:28:14 <ivanm> what? dons hasn't got 6.8.3 into arch yet? :o
03:28:20 <pmurias> BeelsebobWork__: is it possible to change how deriving works?
03:28:53 <BeelsebobWork__> pmurias: it's not possible to change how deriving works without modifying the compiler... you can ofc though, just not derive it
03:28:58 <BeelsebobWork__> write an instance instead of deriving it
03:30:22 <pmurias> ofc = ?
03:32:34 <mercury^> of course
03:33:40 <FordCortina> vixey: about that agda "bug" i found yesterday... funilly enough i did find some red splodges when i opened up the code in emacs to day... :)
03:34:35 <vixey> in types we trust!
03:34:39 <FordCortina> :D
03:46:18 <guenni> hi, what is the recommended way to interface with windows COM in haskell?
03:47:01 <BeelsebobWork__> write an ffi wrapper
03:48:14 <guenni> Beelsebob: thx, do you know of any examples of how to do that?
03:48:26 <BeelsebobWork> @docs ffi
03:48:26 <lambdabot> ffi not available
03:48:35 <BeelsebobWork> @where ffi
03:48:35 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
03:48:50 <BeelsebobWork> it's not the nicest of things to visit
03:49:44 <guenni> BeelsebobWork: oh I can see that, but it's either that or jumping off a cliff
03:54:10 <guenni> BeelsebobWork
03:54:21 <guenni> somebody up there just hates me
03:55:25 <pozic> How can I write a function that takes another function and saturates its arguments with undefined?
03:56:01 <ivanm> pozic: you'd have to know how many inputs the first function takes...
03:56:08 <ivanm> AFAIK, anyway
03:59:28 <pozic> ivanm: printf also takes an unbounded number of arguments.
03:59:48 <ziman> :t printf
03:59:49 <lambdabot> forall r. (PrintfType r) => String -> r
03:59:56 <luqui> pozic, using a pretty big hack
04:00:06 <luqui> pozic, but such a thing is not well defined anyway
04:00:10 <Baughn> No, no. A *nifty* hack. ;)
04:00:19 <luqui> since all arguments might not be known due to polymorphism
04:00:40 <vixey> :t printf ?x ?y ?z
04:00:41 <lambdabot> forall t t1 t2. (PrintfType (t -> t1 -> t2), ?z::t1, ?y::t, ?x::String) => t2
04:01:28 <pozic> luqui: can you give an example of that?
04:02:15 <luqui> so let's say your function is called saturate.  if f has type (a -> a), then saturate f == f undefined, right?
04:02:26 <luqui> however, f also has type ((Int -> Int) -> Int -> Int)
04:02:32 <ivanm> Baughn: why can't a nifty hack be pretty big?
04:02:39 <luqui> and then saturate f == f undefined undefined
04:03:29 <rwbarton> also what about saturate printf? :)
04:03:56 <pozic> rwbarton: ok, so it's a partial function.
04:04:23 <ski> pozic : no, it's not a well-defined function .. not just partiality
04:04:24 <luqui> rwbarton, good example =P
04:05:15 <pozic> ski: what's "well-defined"?
04:05:41 <rwbarton> You can do it using type classes if you only have a finite set of final return types (which doesn't include functions or "forall a. a")
04:05:48 <ski> pozic : it is not clear which of several different things to return .. also it is not clear what the return type is
04:06:23 <pozic> It should work for every function not involving typeclasses as a restriction.
04:06:50 <ski> pozic : what should `saturate id' return ?
04:07:07 <pozic> ski: that requires a type annotation.
04:07:25 <luqui> hmm, is it possible if he required Typeable?
04:07:28 <vixey> saturate1 f = f undefined
04:07:33 <vixey> saturate2 f = f undefined undefined
04:08:02 <pozic> ski: 1 + saturare id 1 should compile and give 2
04:08:06 <ski> pozic : ok. then it's another matter. possibly you can get something working in many cases, then
04:08:06 <pozic> saturate*
04:08:40 <luqui> pozic, well, perhaps not, but I think I know what you mean
04:08:48 <guenni> is anyone using hugs here?
04:08:50 <luqui> "foo" ++ saturate id "bar" should
04:08:53 <ski> pozic : really ?, i thought it would give `1 + id (undefined :: Int) 1'
04:09:20 <pozic> ski: er, right.
04:09:38 <pozic> ski: it should evaluate to undefined.
04:09:46 <ski> (well, maybe the `:: Int' wouldn't be forced by you ..)
04:09:49 <ski> > 1 + id undefined 1
04:09:51 <lambdabot>  Exception: Prelude.undefined
04:13:31 * ski wonders whether something like this can be made without overlapping instances
04:14:45 <ski> class Saturate a o | a -> o
04:14:47 <ski>   where
04:14:58 <ski>   saturate :: a -> o
04:15:29 <ski> instance Saturate b o => Saturate (a -> b) o
04:15:31 <ski>   where
04:15:49 <ski>   saturate f = saturate (f undefined)
04:16:04 <ski> instance Saturate a a
04:16:05 <ski>   where
04:16:10 <ski>   saturate a = a
04:16:14 <luqui> that overlaps doesn't it?
04:16:20 <ski> something like this, maybe
04:16:23 <ski> yes, it does
04:16:23 <rwbarton> That's what I was thinking about at first, but luqui's (Int -> Int) -> Int -> Int example confuses me (in a good way :)
04:17:01 <rwbarton> Oh, it's fine as long as you replace the second instance with "instance Saturate Int Int", "instance Saturate Char Char", ...
04:17:12 <ski> m
04:17:13 <luqui> hmm, infinitely many dots
04:17:26 <ski> (haskell really ought to have closed classes ..)
04:17:35 <AJ_> has nayone thought about a semantically aware version control system for haskell?
04:17:46 <luqui> yeah that would be nice (and probably has many worms in a can)
04:17:54 <ski> semantically aware, how ?
04:18:14 <pozic> AJ_ probably refers to tools like in Smalltalk.
04:18:20 <ski> (mm, worms in a can .. let's go fishing !)
04:18:26 <AJ_> well I don't know smalltalk
04:18:36 <pozic> AJ_: yes, people considered that for Darcs, but it was decided not too.
04:18:37 <AJ_> but I was reading darcs docs
04:18:38 <vixey> neither do I
04:18:38 <SamB> ... those are semantically aware???
04:18:40 <pozic> to*
04:18:48 <AJ_> really? why?
04:19:31 <pozic> AJ_: don't remember the details.
04:20:15 <AJ_> well I'm a newbie to haskell so I may be missing something big
04:20:20 <AJ_> but it'd be a useful feature
04:20:42 <vixey> what would?
04:20:42 <AJ_> like darcs has the token replace command
04:21:00 <AJ_> how difficult would it be to add more refactorings?
04:21:18 <AJ_> something which knows scope rules etc.
04:21:41 <AJ_> patches which work on functions instead of files
04:21:54 <ski> i would suppose that for semantically aware (whatever that means), you'd have to be aware of what language each source file is in, and be aware of lots of non-trivial things about the supported languages .. as opposed to managing basically chunks of text, with some few common semantic (or almost such) operations, like globally renaming identifiers
04:22:37 <AJ_> ski: it doesn't have to understand every language, just Haskell
04:22:48 <SamB> AJ_: suuuuuure
04:22:56 <SamB> "just Haskell", you say
04:23:08 <AJ_> well other languages can have the stuff present currently
04:23:15 <AJ_> but more goodies for Haskell code
04:23:26 <vixey> AJ_: If you write this people would probably use it
04:23:26 <ski> AJ_ : well, then other langauge writies won't have as much incentive to use this, yea ? .. also then may feel unjustly mistreated
04:23:34 <ski> (s/then/they/)
04:24:10 <AJ_> ski: not really. It's better than no language having special support
04:24:36 <ski> that may be argued, yes
04:24:38 <vixey> AJ_: Are you plannning on it ?
04:24:38 <AJ_> and people who love other languages are free to implement support for their languages
04:24:44 <mikael_> is the point just to reduce the byte size of patches?  or would this make diff/merge more robust?
04:24:50 <AJ_> vixey: I want to
04:25:01 <AJ_> I just wanted to see if anything had been done already
04:25:09 <vixey> I don't think so
04:25:45 <ski> mirakel : i would think one point would be to allow more sound commutings of patchings (possibly also useful in a refactoring editor), so that one can easier pick and choose from patches
04:25:49 <AJ_> mikael_: it would make it easier to commute patches
04:25:52 <AJ_> yeah
04:27:26 <ski> imagine getting presented with a graph of modification edges, when you want to undo or pick and choose
04:28:04 <pozic> In a dynamic language, it would be trivial to write saturate. 1) Find number of arguments of f 2) generate right function at 3) Call it.
04:28:31 <ski> pozic : how would you find number of arguments of a curried function ?
04:28:43 <ski> (yes, you can call and check again)
04:28:53 <pozic> ski: thanks for giving the answer.
04:29:14 <ski> but it seems this is incompatible with abstract types which are non-abstract in some scopes
04:29:33 <pozic> It's much more direct than to think in terms of type-classes for everything.
04:29:36 <ski> pozic :)
04:29:43 <pozic> Moreover, look at the source code for Printf.
04:29:54 <pozic> Gigantic redundancy.
04:30:06 <ski> well, you loose free theorems / parametricity
04:30:06 <newsham> def nargs(*xs) : print len(xs)
04:30:12 <newsham> what is saturate(nargs) ?
04:32:22 <ski> (pozic : i don't consider `printf' a very sane thing, barring dependent types ..)
04:32:50 <pozic> ski: yes, it's outside the expected use of type-classes.
04:32:59 <ski> (i.e., the idea of keeping code close to output is sane .. the encoding, not so much)
04:33:32 <pozic> ski: what do you mean with the idea... is sane?
04:33:43 <pozic> by*
04:33:57 <ski> consider quasi-quaotation (in this context, sometimes named string-interpolation)
04:34:31 <ski> the idea is that the shape of the code as closely resembles the output as possible, with subexpressions given for the varying parts
04:35:28 <ski> "a + b = $(a + b)"
04:35:44 <ski> `((a + b) = ,(+ a b))
04:36:16 <pozic> ski: ok, generated code. I see.
04:36:26 <ski> something like this is a lot better than a sequence of `putStr's and `print's ..
04:37:38 <ski> pozic : not just generating code, generating strings or output or formatted text or whatever
04:37:50 <ski> "The sum of `a' and `b' is `$(a + b)'"
04:39:11 <ski> i suppose one could say, many things in the vein of the `Writer' monad
04:39:34 <ski> hm
04:40:00 <ski> @hoogle [Writer o a] -> Writer [o] [a]
04:40:00 <lambdabot> No matches, try a more general search
04:40:58 <BeelsebobWork> is there a reason why put on strings outputs garbage before the string?
04:41:26 <rwbarton> BeelsebobWork: it's probably the length of the string
04:41:33 <BeelsebobWork> oh, duh, yeh
04:41:39 <ski> @hoogle put
04:41:39 <lambdabot> Control.Monad.State.Class.put :: MonadState s m => s -> m ()
04:41:39 <lambdabot> Prelude.putChar :: Char -> IO ()
04:41:39 <lambdabot> Prelude.putStr :: String -> IO ()
04:42:00 <BeelsebobWork> is there a build in way to do putByteString . CBS.pack?
04:42:02 <vixey> :t sequence
04:42:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:42:05 <luqui> @hoogle [Writer o a] -> Writer o [a]
04:42:05 <lambdabot> No matches, try a more general search
04:42:11 <pozic> ski: the writer monad is also an example of doing things indirectly. Everything in Haskell is like that.
04:42:14 <vixey> :t sequence :: [Writer o a] -> Writer o [a]
04:42:15 <luqui> (o is a monoid remember?)
04:42:23 <luqui> oh duh
04:42:53 <pozic> ski: except function application, but even that works via laziness somewhat indirectly.
04:43:21 <pozic> ski: er, no. That's direct.
04:43:27 <ski> pozic : well, in this case, the reason was better compositionality .. i.e. easier understandable semantics
04:43:52 <ski> (and i suspect that's the reason in a lot, if not most, cases)
04:44:38 <ski> vixey : i was pondering a more structured `Writer' thing .. where subactions wouldn't necessarily have the same output type as the whole action
04:46:26 <ski> @type Writer . unzip . map runWriter
04:46:26 <lambdabot> forall w a. [Writer w a] -> Writer [w] [a]
04:47:01 <pozic> ski: isn't there some calculus for dynamic languages? It could contain a theorem stating that when some expression doesn't use dynamic features, it's safe.
04:47:22 <ski> pozic : possibly, yes
04:48:15 * ski wonders whether he's maybe really after expressions under types in `(*,*)'
04:49:00 <ski> pozic : hm, how would you define `dynamic features' ?
04:49:04 <pozic> ski: what's (*,*)?
04:50:01 <ski> pozic : the product-kind of the kind of types, with itself .. was what i was intending
04:50:23 <ski> i.e. type expressions under that kind would be pairs of ordinary concrete types
04:50:54 <ski> (curse haskell's conflating syntax of type-pairs vs. pairs of types ..)
04:50:56 <pozic> ski: traverse all the modules in the system to collect all the names of all the functions would be one such a feature. In general: being able to access and modify everything.
04:51:32 <pozic> ski: in Scheme you cannot do that unless you write your own with-my-flexible-language macro.
04:52:22 <ski> how about things like checking whether a value is a procedure, and if so, checking what the possible number of arguments then is ?
04:52:44 <ski> (that was two questions)
04:53:00 <pozic> yes, those things should also be implementable by a user.
04:53:10 <pozic> (possible in Smalltalk today for example)
04:53:21 <ski> and wouldn't be termed as `dynamic feature' ?
04:53:55 <pozic> It's not really dynamic, as that one can be decided at compile time.
04:54:01 <pozic> But some cannot.
04:54:06 <ski> ok
04:54:15 <pozic> (for most functions at least)
04:54:38 <ski> (with many static type-systems, such can't always be decided at compile time)
04:56:05 <pozic> The type-systems are also not extensible.
04:56:06 <ski> (s/many/sufficiently-powerful/)
04:56:17 <pozic> Take the dimensional library for example.
04:56:46 <ski> what about it ?
04:57:04 <pozic> Force is a 10 line monster.
04:57:23 <ski> i'm not very familiar with this library
04:57:27 <ski> what is `force' ?
04:57:31 <pozic> It would be better to show Force does not match Power.
04:57:44 <pozic> Instead of Encoding of Force does not match Power.
04:57:52 <pozic> Er Encoding of Power*
04:58:11 <pozic> ski: it uses type-level number to maintain consistency between units.
04:58:14 * camio cues star wars music.
04:58:17 <pozic> ski: quite nifty.
04:58:23 <ski> *nod*
04:58:29 <pozic> ski: ... but not maintainable
04:58:44 <ski> i see
04:58:56 <pozic> Which brings us to either we need dependent types .. or we should just abandon it.
04:59:35 <pozic> And the dependently typed language needs an escape hatch anyway.
04:59:39 <ski> i'm nost sure about this case .. but in many cases, i don't think dependent types would be inherently needed
05:00:17 <pozic> But if the type-checker was extensible, one could parse in the format and give a nicer error message.
05:00:28 <pozic> It might be possible to do that with GHC API already.
05:00:40 <ski> mayhaps
05:01:05 <pozic> But I don't know that, and it probably takes a lot of work..
05:01:55 * luqui thinks dependent types are the future, but they have a long way to go yet...
05:02:16 * vixey is worried about dependent types...
05:02:18 <luqui> I mean, I consider that how you do an extensible type system correctly...
05:02:34 <luqui> but right now it seems you have to have a PhD to use them =P
05:02:54 <SamB_XP> luqui: heck no
05:03:04 <vixey> luqui, no! You can also get a PhD -by- using them
05:03:04 <SamB_XP> ... just a phd-level education ;-)
05:03:13 <luqui> :-)
05:03:31 <vixey> but I am worried because it seems impossible to prove things about dependent types using dependent types
05:03:41 <luqui> vixey, that's a very interesting point
05:03:42 <SamB_XP> spj doesn't even have an SPJ, though he presumably qualifies for many
05:03:54 <SamB_XP> vixey: eh?
05:04:07 <ski> SamB_XP : itym s/SPJ/PhD/ ?
05:04:16 <SamB_XP> er.
05:04:19 <ski> (:
05:04:21 <SamB_XP> yes!
05:04:28 <vixey> lol
05:04:29 <SamB_XP> how the heck did I do that ...
05:04:32 <luqui> I was wondering what an SPJ was, and what an incredible unnoticed pun that would be
05:04:52 <ski> possibly his wife has one ..
05:05:35 <vixey> SamB: Not sure what you are asking
05:05:36 <SamB_XP> hmm, doesn't SPJ have an SPJ ?
05:06:05 <SamB_XP> vixey: what do you mean about not being able to prove things about dependant types using dependant types?
05:06:13 <ski> > "spj" == "SPJ"  -- there !
05:06:14 <lambdabot>  False
05:06:42 <luqui> > "SPJ" `elem` ["spj"]
05:06:43 <lambdabot>  False
05:06:50 <SamB_XP> isn't there a sarah peyton jones ?
05:07:00 <luqui> soo desu
05:07:11 <ski> ah .. that could be it
05:07:34 <vixey> SamB_XP: there seems to be a fundamental limitation, I hope not though
05:07:36 <SamB_XP> but anyway, I did in fact mean to say PhD rather than SPJ there ;-)
05:07:57 <SamB_XP> vixey: is there some literature about this, or what ?
05:08:01 <pozic> vixey: you are confusing some things.
05:08:18 <vixey> I don't know
05:08:43 <SamB_XP> speaking of which, we should have more failed attempts in the literature
05:08:45 <pozic> The idea of dependent types is that it is a consistent system.
05:09:02 <pozic> So, since it can do arithmetic, it's incomplete.
05:09:03 <ski> istr Smerdyakov saying something about not being able to reason about dep. typed languages inside Coq, in a satisfying way ..
05:09:11 <SamB_XP> ah.
05:09:23 <SamB_XP> that I can believe
05:09:43 <pozic> Proving the own axioms to be correct isn't going to work either, IIRC.
05:10:27 <ski> SamB_XP : yes .. more counter-examples !
05:10:29 <SamB_XP> I would definately expect it to be a good deal less satisfying than I should like
05:10:40 <SamB_XP> ski: not necessarily counter-examples
05:10:55 <pozic> Neither can one write some theoretical programs thought of by Blum.
05:10:56 <SamB_XP> also abortive attempts
05:11:06 <dolio> I'm pretty sure I have a paper about implementing a categorical model of dependent type theory in a dependently typed language.
05:11:16 <ski> SamB_XP : well, i loosely included such, here, too .. :)
05:11:26 <pozic> The theory is that "most practical programs" can be written in these languages.
05:11:28 <vixey> dolio: What is the title?
05:11:51 <dolio> I'll have to google search.
05:12:07 <vixey> SamB_XP: I am wondering just what is possible.. and impossible
05:12:13 <SamB_XP> which might inspire others to succeed where those who have gone before have failed, or to show why that which was attempted cannot be done, etc.
05:12:38 <ski> *nod*
05:13:14 <dolio> Let's see...
05:13:40 <dolio> Internal Type Theory...
05:14:00 <dolio> Towards Formalizing Categorical Models of Type Theory in Type Theory.
05:14:20 <dolio> Are two.
05:16:01 <SamB_XP> I am reminded of http://math.rejecta.org/
05:16:03 <lambdabot> Title: Rejecta Mathematica | Caveat Emptor
05:18:38 <ddarius> Shouldn't that be caveat lector?
05:19:26 <SamB_XP> ddarius: hmm, I'm extremely rusty ...
05:19:37 <SamB_XP> what does that mean?
05:19:54 <ddarius> caveat emptor = buyer beware; caveat lector = reader beware
05:20:14 <idnar> cave canem
05:21:04 <SamB_XP> yeah, she sometimes bonks people in the nose when trying to lick their faces
05:40:48 * SamB wonders when x-chat started recovering scrollback from earlier invocations?
05:41:21 <ivanm> SamB: I've noticed it for a while now... can't work out how to disable it :s
05:41:33 <ddarius> Sometime between Ubuntu Feisty and Ubuntu Hardy
05:42:34 <SamB> Settings -> Preferences -> Chatting -> Logging -> Display scrollback from previous session
05:43:39 <ivanm> hmmm.... completely missed that option for some reason :s
05:43:56 <ddarius> Why isn't it colored is the question.
05:44:24 <ivanm> ddarius: I'm guessing xchat colours it as it gets it... whereas scrollback is just displaying the log file :s
05:44:47 <ivanm> so rather than incrementally parsing and colouring the scrollback, it just aligns times/nicks/etc. and that's it
05:45:02 <SamB> my guess would be it was deliberate
05:45:08 <dancor> do you ever wish some helper program would guess which imports you wanted
05:45:10 <ivanm> to differentiate it?
05:45:13 <SamB> yeah
05:45:22 <ivanm> especially for obscure functions...
05:45:28 <SamB> like they do flashbacks in black and white sometimes
05:45:42 <ivanm> I can _never_ remember which module contains first, second, ***, etc. :s
05:45:45 <gwern> @seen dcoutts
05:45:45 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 1h 44m 12s ago.
05:45:52 <ddarius> SamB: That's possible but doesn't seem to cover the actual case users would want.
05:46:08 <ski> @index first
05:46:08 <lambdabot> Control.Arrow
05:46:08 <SamB> ddarius: hmm?
05:46:09 <gwern> @tell dcoutts btw, haddock 2.2.1 fixes my cabal-install problem
05:46:09 <lambdabot> Consider it noted.
05:46:10 <dcoutts_> hia gwern
05:46:29 <dcoutts_> gwern: what was the cabal-install problem?
05:46:50 <ivanm> dcoutts_: cabal-install didn't install? :p
05:46:53 <gwern> I mentioned docs wouldn't build
05:47:06 <gwern> you said you were using .8 or something and never saw it
05:47:15 <dcoutts_> gwern: oh, it's more likely because I pushed some patches to fix it :-)
05:47:37 <dcoutts_> gwern: I tried cabal haddock with 0.8 and pushed some patches to fix haddock syntax errors
05:47:41 <ddarius> SamB: I'd prefer the presentation of one continuous conversation.  Normally I just leave xchat on so I have plenty of "old" conversations anyway.
05:47:52 <gwern> hm, I'm fairly sure I didn't pull any patches since the failure, but whatever
05:48:13 <dcoutts_> gwern: I don't normally bother for executables you see, only libs
05:55:07 <gwern> dcoutts_: did profiling option ever get added to .cabal/config?
05:55:24 <dcoutts_> gwern: yep, library-profiling: True
05:55:46 <gwern> not executable?
05:55:57 <dcoutts_> gwern: yep, executable-profiling: True :-)
05:56:14 <gwern> 'k
05:56:23 <gwern> is there a disabling option, btw?
05:56:27 <gwern> -no-profile, I mean
05:56:39 <dcoutts_> --enable/disable-library/executable-profiling
05:56:56 <ivanm> wow, that flag is a bit of a mouthful! :p
05:56:59 <gwern> great
05:57:13 <gwern> ivanm: it's 4 options in one, as I parse it
05:57:20 <dcoutts_> ivanm: that's what the bash command line completion is for :-)
05:57:27 <ivanm> gwern: yes, I know ;-)
05:57:39 <ivanm> though I normally use {} rather than / ;-)
05:57:49 <ddarius> --dwim
05:57:52 <ivanm> i.e. --{enable,disable}-{library,executable}-profiling
05:57:55 <ivanm> ddarius: lol
05:58:19 <dcoutts_> ddarius: that's the default! :-)
05:58:46 <ivanm> ddarius: like this? http://ars.userfriendly.org/cartoons/?id=20011121
05:58:46 <lambdabot> Title: UserFriendly Strip Comments
06:00:05 <Baughn> http://www.gpf-comics.com/ <-- On that note, does this keyboard look familiar to anyone? Anyone at all?
06:00:05 <lambdabot> Title: General Protection Fault--The Comic Strip
06:01:06 <gwern> I am always amazed that as terrible a comic strip as userfriendly is a going concern
06:01:18 <ivanm> gwern: userfriendly, terrible?
06:01:25 <ivanm> it's a damn sight better than gpf!
06:01:46 <Baughn> ivanm: It's a webcomic. Webcomic are terrible by definition.
06:01:46 <ddarius> Which is also terrible as far as I can tell.
06:02:01 <ddarius> There are a few entertaining ones.
06:02:05 <ivanm> Baughn: even xkcd! :o
06:02:17 <Baughn> ivanm: Well, okay, not xkcd or dresden codak
06:02:25 <gwern> ivanm: are you trying to argue that since beelzebub is not as evil as satan, he must be good?
06:02:31 <mirakel> objection, dinosaur comics is patently non-terrible
06:03:02 <Baughn> mirakel: People have patented infinite energy devices too. That does not mean they are actually possible.
06:03:05 <Baughn> Though it should..
06:04:18 <gwern> mirakel: I like a softer world too
06:04:53 * ivanm also reads CAD, dilbert, and a few others
06:05:02 <ivanm> though CAD is going downhill :s
06:06:46 <BeelsebobWork> what's the likely cause of this?
06:06:49 <BeelsebobWork> Loading package checkers-0.0 ... linking ... done.
06:06:50 <BeelsebobWork> <interactive>: unknown symbol `_checkerszm0zi0_TestziQuickCheckziInstancesziChar_coarbitrary_info'
06:07:10 <Baughn> BeelsebobWork: Version mismatches, actually
06:07:22 <Baughn> Say, if checkers was built against a different version of quickcheck than is actually installed
06:07:43 <BeelsebobWork> hmm, odd, it was working 5 minutes ago
06:07:58 <Baughn> Okay. What did you do in the meantime?
06:08:03 <BeelsebobWork> I moved an instance from one module to another in checkers though -- is it possible that it's a version missmatch in the checkers package?
06:08:14 <BeelsebobWork> ghc-pkg unregister checkers and build again?
06:08:28 <Baughn> That should work. cabal clean; cabal build
06:09:14 <BeelsebobWork> same error :/
06:09:38 <Baughn> You might try rm -rf ~/.ghc; it's a bit heavy-handed, but cleaning everything out tends to do it.
06:09:51 <Baughn> (And for this reason I try not to install any packages globally)
06:10:23 <adekoba> I made a little parsing program to parse an mp3 file. Some of the functions read flags in the mp3 file that affect other parsing functions. Would it be best to pass these flags in the state monad, or rather pass them explicitly by way of tuples?
06:11:06 <Baughn> adekoba: Are you writing your own parser from scratch, using parsec, or what?
06:11:24 <BeelsebobWork> nope, same error Baughn
06:11:25 <BeelsebobWork> :/
06:11:38 <adekoba> Baughn: I wrote it from scratch... I'm having a tough time learning how to use parsec with Data.ByteString
06:11:42 <Baughn> BeelsebobWork: checkers is a cabalized package, right?
06:11:50 <BeelsebobWork> Baughn: yeh
06:12:03 <BeelsebobWork> adekoba: the short answer, is that you don't
06:12:10 <BeelsebobWork> parsec and bytestrings are mutually exclusive
06:12:16 <Baughn> BeelsebobWork: Okay. Have you installed /any/ packages globally, with sudo, anything like that?
06:12:29 <BeelsebobWork> Baughn: almost all packages are installed globaly
06:12:30 <Baughn> adekoba: Unless you install parsec-3, in which case they aren't
06:12:54 <Baughn> BeelsebobWork: Ouch. Hm, I'd like to try to fix it, but..
06:13:07 <adekoba> Baughn: if I were to use parsec, would passing flags around in tuples be the only option?
06:13:10 <BeelsebobWork> Baughn: what's problematic about installing things globally?
06:13:12 <Baughn> BeelsebobWork: Do you have cabal-install (cabal binary) installed?
06:13:23 <BeelsebobWork> no, cabal install doesn't work right for me
06:13:34 <BeelsebobWork> plus, I see it as fairly pointless
06:13:36 <Baughn> adekoba: No, parsec provides a state monad for that use. I imagine it uses StateT
06:13:40 <BeelsebobWork> it has a longer list of dependancies than most packages
06:13:52 <Baughn> It's got /three/ dependencies
06:13:54 <dcoutts_> BeelsebobWork: remind me what the problem was that we ran into?
06:14:03 <BeelsebobWork> Baughn: yes, but most packages have at most one dep
06:14:07 <adekoba> Baughn: neat. Thanks.
06:14:14 <BeelsebobWork> dcoutts_: installed things just... weren't
06:14:17 <Baughn> BeelsebobWork: Once you've got a binary, you can just keep it around
06:14:45 <Baughn> BeelsebobWork: I'd like to try to solve the problem, figure out exactly what's causing it, but.. can't do that in a timely manner over irc
06:14:45 <BeelsebobWork> conal commented a couple of weeks back that he'd had the same experience with it dcoutts_
06:14:57 <dcoutts_> BeelsebobWork: both on OSX?
06:15:03 <BeelsebobWork> dcoutts_: no, conal on windows
06:15:10 <Baughn> BeelsebobWork: I'd have to recommend you (a) find someone else to help, (b) do it yourself, or (c) slash and burn - remove ghc entirely and reinstall
06:15:10 <dcoutts_> BeelsebobWork: btw, my latest project has 24 package deps ;-)
06:15:26 <dcoutts_> BeelsebobWork: do we have these problems recorded anywhere?
06:15:48 <dcoutts_> BeelsebobWork: otherwise they're unlikely to get fixed, drops out of people memories
06:15:52 <Baughn> BeelsebobWork: Also, in my experience this sort of issue doesn't happen if you use cabal-install
06:15:56 <BeelsebobWork> dcoutts_: no, I think both of us failed early enough in trying cabal-install that we both just went "doesn't work" and stopped using it
06:16:20 <BeelsebobWork> dcoutts_: also, damn, you beat me, I'm at 18 deps so far :P
06:16:37 <dcoutts_> BeelsebobWork: I'd really appreciate it if you could report what goes wrong: http://hackage.haskell.org/trac/hackage/
06:16:38 <lambdabot> Title: Hackage - Trac
06:16:58 <dcoutts_> BeelsebobWork: this stuff is supposed to work "out of the box" as they say, so if it doesn't we need to know so we can make it work
06:17:01 <BeelsebobWork> dcoutts_: at some point I'll have a go at isolating it
06:17:19 <BeelsebobWork> my suspicion is that it's probably installing into a path that neither ghc, nor I know anything about
06:17:19 * Baughn wonders why happs has a facebook module
06:17:34 <dcoutts_> BeelsebobWork: probably ~/.cabal/bin
06:18:09 <BeelsebobWork> sounds likely -- I've never heard of anything ending up there
06:18:22 <dcoutts_> BeelsebobWork: is there anything there now?
06:18:39 <BeelsebobWork> dcoutts_: dunno, I'm on a system that's never had cabal-install on it atm
06:18:46 <dcoutts_> BeelsebobWork: I actually just started a discussion yesterday on where it should install by default. There's remarkable resistance to installing somewhere on the path by default.
06:19:09 <dcoutts_> BeelsebobWork: on the libraries list, so your experience is a useful data point if you want to chime it
06:19:12 <Baughn> dcoutts_: And where should that be? There's no user-writable directory on the path by default
06:19:12 <dcoutts_> it/in
06:19:21 <Baughn> Installing in ~/bin would make me hopping mad, too
06:19:21 <dcoutts_> Baughn: depends on the platform
06:19:26 <dcoutts_> Baughn: why?
06:19:32 <BeelsebobWork> dcoutts_: if it doesn't, it should certainly be *very* well documented that you need to add something to your path
06:19:40 <adekoba> Baughn: ah, looking at the parsec docs, it seems to use Data.ByteString[.Lazy].Char8. Do you know if it works with just plain old Word8 ByteString's?
06:19:50 <BeelsebobWork> by which I mean it should say it in REALLY BIG LETTERS at the end of running Setup.hs install
06:19:59 <Baughn> dcoutts_: For one thing, I'm currently using ~/.cabal/bin as a staging directory, to let me test binaries before installing them. What's in ~/bin *has* to work.
06:20:12 <dcoutts_> BeelsebobWork: yes, that's a last resort. It should just work though.
06:20:20 <Baughn> dcoutts_: I don't want to install a new cabal-install before I know it'll work.. come to think of it, why aren't there any tests for it?
06:20:24 <dcoutts_> Baughn: what if we didn't overwrite anything you'd installed yourself in bin? what if it made symlinks in ~/bin to files installed in ~/.cabal/bin ?
06:20:33 <BeelsebobWork> Baughn: tbh -- I'd expect that if you want to stage it you should provide an extra argument
06:20:46 <BeelsebobWork> i.e. cabal install --prefix=~/.cabal/
06:20:57 <BeelsebobWork> and otherwise it should be expected to put it somewhere where it'll just work
06:21:00 <dcoutts_> BeelsebobWork: that's the default
06:21:29 <Baughn> dcoutts_: Then.. ~/bin still isn't a standard path. I used to use ~/usr/bin, and.. well, I don't want applications to write outside their own little dot-directory without asking me very nicely or permission first.
06:21:32 <BeelsebobWork> dcoutts_: yeh -- what I'm saying is that if I run any kind of configure/make/other build system, I expect that it'll put it somewhere on a normal, sane person's path
06:21:38 <Baughn> If there's a first-time configuration dialog, then sure
06:21:40 <BeelsebobWork> so I don't expect cabal install to be any different
06:21:48 <dcoutts_> BeelsebobWork: but yes, if someone wants deliberately to stage it, then setting --prefix or --bindir is the obvious thing to do
06:21:50 <BeelsebobWork> if I don't want it in my path, then it's *my* responsibility to change it
06:22:32 <dcoutts_> Baughn: many platforms use ~/bin and put it on the path, if you don't then fine we'll not use ~/bin by default on your system and shout at you to do something sensible
06:22:52 <dcoutts_> people who know what they're doing know enough to change defaults
06:23:01 <Baughn> dcoutts_: Actually, a first-time configuration/information dialog would be most handy
06:23:03 <dcoutts_> the people who don't know need sensible defaults
06:23:09 <dcoutts_> Baughn: yes, it would.
06:23:15 <Baughn> It's not like there's anything telling you it's installing in ~/.cabal/bin right now
06:23:21 <dcoutts_> right
06:23:31 <dcoutts_> and where the config file is if you want to change it
06:23:45 <dcoutts_> Baughn: if you can think of what info is should display, file a feature request.
06:23:49 <Baughn> Not to mention comments on the possible options in that file
06:23:49 <dcoutts_> is/it
06:23:59 <dcoutts_> yes, it needs to be self-documenting
06:24:15 <Baughn> dcoutts_: Can you point me at the code that writes the file right now?
06:25:10 <dcoutts_> Baughn: in the darcs version, Distribution/Client/Config.hs
06:25:21 <dcoutts_> Baughn: writeDefaultConfigFile
06:28:38 <Baughn> dcoutts_: Oh goodie. That's right..
06:28:55 <Baughn> If forgot. I found the cabal-install code somewhat impenetrable.
06:29:09 <dcoutts_> Baughn: na, it's simple :-)
06:29:25 <dcoutts_> Baughn: though the config code isn't that lovely, it needs replacing
06:29:48 <dcoutts_> Baughn: it's tied up with the command line arg parsing, since we want the same info represented in the config file and on the command line
06:31:09 <dcoutts_> Baughn: just documenting what it should do in a ticket would be useful, eg give a script of a first-time interaction
06:31:13 * Twey suggests a monad
06:32:27 <dcoutts_> Baughn: the user does $ cabal blah for the first time, how should cabal respond. What info does it print etc. A concrete example that we can agree on would be really useful.
06:33:38 <Baughn> dcoutts_: Right. I promised cale a new seen module for.. yesterday, but I might take a look at that eventually.
06:33:49 <dcoutts_> thanks
06:33:56 <Baughn> Has to be easier than actually /rewriting/ this. ;_;
06:35:48 <gchrupala> How is it possible that a function which is called only once has millions of "entries" in the profiling file??
06:36:07 <Baughn> gchrupala: You might be mistaen about its only being called once?
06:36:30 <Baughn> gchrupala: (Or it's recursive?)
06:36:55 <gchrupala> Baughn: when i put a call to trace in it i get just a single output
06:37:03 <gchrupala> its not recursive
06:38:03 <Baughn> gchrupala: Can I see the function? And the caller?
06:39:51 <gchrupala> Baughn: it's the f_slow function at http://hpaste.org/9378
06:40:22 <gchrupala> the profile file has this line:   f_slow                Main                                                 263    92904001  41.1   71.4    75.8   82.4
06:42:36 <Baughn> gchrupala: And how many entries to train?
06:43:44 <benpicco> Hi, I wonder why printPicture(rotate90 horse) (http://hpaste.org/9379) gives me Program error: pattern match failure: mergeLines []
06:44:47 <gchrupala> Baughn: train has 7 entries, which is also weird, its called only once...
06:45:41 <gchrupala> Maybe I'm misunderstanding what "entries" means...
06:46:51 <mirakel> maybe it's just a time sample count?
06:47:39 <Baughn> Nothing that simple.. and not a result of lazyness causing multiple entries or anything like that either, apparently
06:47:45 <gchrupala> According to the docs its The number of times this particular point in the call graph was entered.
06:47:55 <gchrupala> whatever that means
06:48:09 <vixey> why doesn't haskell have a Tcl/Tk lib?
06:48:42 <dolio> There was FranTK, I think.
06:49:57 <dolio> Apparently there's this too: http://www.dcs.gla.ac.uk/~meurig/TclHaskell/
06:49:58 <lambdabot> Title: TclHaskell
06:50:00 <dolio> Vintage 2001.
06:50:10 <jrh> very vintage...
06:50:25 <dolio> Tested with GHC 5.0.
06:50:26 <lilachaze> also http://www.informatik.uni-bremen.de/htk/
06:50:27 <lambdabot> Title: The HTk home page.
06:52:37 <dolio> Wow, FranTk is even older.
06:52:54 <dolio> "FranTk works under hugs98 and ghc-4.04."
06:53:16 <gwern> I always wonder when ghc will go to 7
06:53:47 <dolio> What pushed it to 6? I don't even know.
06:54:10 <Baughn> gchrupala: Try as I might, I can't make the profiler tell me I've entered a function more than once without actually calling it more than once
06:56:23 <dolio> Inlining can do that.
06:56:29 <dolio> I think.
06:56:49 <dolio> Some optimization messes up those statistics, at least.
06:56:55 <Baughn> gchrupala: Right.. try compiling with -Onot?
06:57:30 <rwbarton> I have no concrete examples, but I feel like most of the time I try to use the profiler I have the experience gchrupala describes
06:58:26 <benpicco> is [] the same as [[]] when it comes to returning an empty list of lists?
06:58:28 <dolio> I'm pretty sure inlining is the culprit. Back when I was tuning sorting stuff, adding and removing INLINE pragmas changed the entries a lot.
07:00:04 <rwbarton> benpicco: Nope. [[]] is not an empty list; it has one element, namely []
07:00:43 <vixey> [] and [[]] may have the same type
07:00:51 <vixey> they are not the same value though
07:02:50 <rwbarton> benpicco: mergeLines is supposed to return the first column, right?
07:03:03 <benpicco> rwbarton, yes
07:03:05 <rwbarton> benpicco: at the end of the recursion, it's going to get called with an empty list, not a list containing an empty row
07:03:27 <benpicco> rwbarton, so mergeLines [] = [] ?
07:03:34 <rwbarton> benpicco: right
07:04:00 <rwbarton> That should let you compute "mergeLines horse", at least.  Not sure about the rest
07:05:15 <benpicco> well, http://hpaste.org/9380 does the rotate, but at the end I get Program error: pattern match failure: mergeLines [[]] ++ reducePicture [".",".",".",".",".",".",".",".",".",".","."]
07:07:04 <rwbarton> benpicco: yes, defining the base case for rotate90 is trickier
07:07:59 <Toxaris> > transpose ["abc", "def", "ghi"]
07:08:00 <lambdabot>  ["adg","beh","cfi"]
07:10:08 <Jedai> @src transpose
07:10:08 <lambdabot> transpose []             = []
07:10:08 <lambdabot> transpose ([]   : xss)   = transpose xss
07:10:08 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
07:11:08 <jrh> lambdabot is like a useful Clippy.  I wish I had an IDE that he was embedded in.  That way I could type a piece of source where I wanted it, evaluate it via l-bot, and then if I liked it, insert it at point, otherwise it'd just go away
07:11:30 <Baughn> jrh: I'm sure you could do that with emacs. ;)
07:11:39 <rwbarton> jrh: s/he/she/
07:11:48 <test> lamdabot
07:11:51 <jrh> meta-m meta-k butteryfly
07:11:58 <test> @lamdabot
07:11:58 <lambdabot> Unknown command, try @list
07:12:04 <test> @list
07:12:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:12:22 <jrh> lambdabot's a she?  that's good to know
07:12:45 <rwbarton> So I hear
07:12:51 <jrh> I think of all computers as more or less having the voice of HAL
07:13:25 <jaj> @vixen: asl?
07:13:25 <lambdabot> 19/f/California
07:13:38 <rwbarton> @vixen are you male or female?
07:13:38 <lambdabot> i truely am
07:13:49 <jrh> ROFL.  Nice
07:14:22 <jrh> Sometimes i think of their voices as Collossus (from the film, not the real computer), but that's only when I'm losing the battle with them
07:18:24 <Philippa_> jrh: mostly you just need a terminal session in your IDE for the type-and-evaluate
07:18:33 <Philippa_> okay, it costs you a couple of clicks or equivalent, but hey
07:19:02 <test> @lamdabot
07:19:03 <lambdabot> Unknown command, try @list
07:19:13 <jrh> Yeah.  My IDE is still vi.  Vi in a tabbed Gnome Terminal, but it's still Vi
07:19:26 <test> >let counter x = [x..] for counter 10
07:19:47 <vixey> > let counter x = [x..] for counter 10
07:19:47 <lambdabot>  Parse error at end of input
07:19:58 <Philippa_> Ah. So you want a terminal that'll do splitters :-)
07:20:03 <Deewiant> s/for/in/
07:20:08 <jrh> that'd be nice, yeah
07:20:14 <lilachaze> > let counter x = [x..] in counter 10
07:20:16 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:20:24 <jaj> jrh: what about screen?
07:20:32 <lilachaze> > enumFrom 10
07:20:34 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:21:00 <jrh> I've started trying to use the new IDE that someone put out on Hackage.  Can't remember its name.
07:21:50 <jrh> screen might work.  Then again, with two monitors, it's often easiest just to have multiple terminals open.  I've a pretty efficient workspace considering that I use vi
07:22:05 * Philippa_ currently uses jEdit on one machine and kate on the other. Will probably switch to jEdit on the new eee when that hopefully arrives later this week
07:22:11 <Philippa_> (assuming I haven't just jinxed myself)
07:23:06 <lilachaze> jrh: yi?
07:25:38 <test> scale exPic 0 = ("......"++"........"):[]          how can i user putStr to produce a nice output ?   siganture says ->Pictures ([[Char]]
07:25:40 <jrh> lilachaze: the reason I use vi, or more specifically vim, is that the commands are already all under my hands, and I thus rarely have to leave the keyboard
07:26:13 <jrh> I even use VI to write Lisp, which even I realize is a travesty
07:26:50 <lilachaze> jrh: i've not used yi myself, but i believe it has vi keybindings
07:27:01 <jrh> hrm
07:27:02 * lilachaze is a vim user btw
07:27:02 <Deewiant> having vi bindings does not a vim make
07:27:06 <jrh> no
07:27:28 <Deewiant> I tried emacs with vimpulse a while ago and it was missing just too much compared to vim so I found it unbearable
07:27:42 <jrh> the other reason, of course, is that none of the inconvienences I incur from doing it my old way are annoying enough to change
07:27:48 <jrh> curmudgeon syndrome
07:28:07 <lilachaze> i tried ViEmu for visual studio a little while ago, and found it likewise unbearable...
07:30:55 <rwbarton> test: I don't really understand what you're asking, but you might find unlines useful
07:31:13 <rwbarton> > unlines ["...", ".#.", "###"]
07:31:14 <lambdabot>  "...\n.#.\n###\n"
07:37:03 <camio> @hoogle dist
07:37:03 <lambdabot> Distribution.Simple.LocalBuildInfo.distPref :: FilePath
07:37:04 <lambdabot> Distribution.Simple.SrcDist :: module
07:37:04 <lambdabot> Distribution.Simple.preSDist :: UserHooks -> Args -> SDistFlags -> IO HookedBuildInfo
07:37:20 <camio> Arg, that's not what I wanted.
07:37:45 <camio> Applicative distributor anyone?
07:40:21 <test>  unlines ["...", ".#.", "###"] is no solution for me
07:40:57 <test> scale exPic (-1) = "Error":[]
07:40:57 <test> scale exPic 0 = ("......"++"........"):[]
07:40:57 <test> scale exPic i = "2":[]
07:41:16 <vixey> why are you writing :[] ?
07:41:20 <camio> Ah, dist = sequenceA.
07:41:23 <camio> @hoogle sequenceA
07:41:24 <lambdabot> Data.Traversable.sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:41:24 <lambdabot> Data.Foldable.sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
07:41:35 <test> line 2 gives me
07:41:51 <test> scale ["kjh","kjh"] 0
07:41:51 <test> [".............."]
07:41:51 <test> scale ["kjh","kjh"] 0
07:41:51 <test> [".............."]
07:41:51 <test>  scale ["kjh","kjh"] 0
07:41:52 <test> [".............."]
07:41:56 <jrh> vixey, it's valid, just a little unusual.
07:42:00 <test> upps sorry for spamm
07:42:14 <jrh> test, ["2"] works as well, and is a little more readable
07:42:40 <test> i want to jrh ???
07:43:05 <test> i just want to use putstr for a nice output
07:43:35 <test> but my signature expects ->Pictures, that is a [Strings]
07:43:54 <rwbarton> putStr . unlines $ scale ["kjh", "kjh"] 0
07:44:08 <ndm> @seen dcoutts
07:44:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 3h 42m 35s ago.
07:44:13 <jrh> mapM_ putStrLn
07:44:13 <dcoutts_> hia ndm
07:44:19 <jrh> @type mapM_ putStrLn
07:44:20 <lambdabot> [String] -> IO ()
07:45:39 <ndm> hi dcoutts_, i'm just perparing a release of hoogle, which is designed to be cabal-install compatible - i.e. cabal-install hoogle and go :-)
07:45:46 <test>  jrh: @type mapM_ putStrLn  this is [String] -> IO ()
07:45:59 <ndm> dcoutts_: question is what to do about the binary file that hoogle uses as a database?
07:46:12 <test> i need ("......"\n".....") to [String]
07:46:19 <ndm> dcoutts_: the file is generated from a textfile, by hoogle, and takes around 2min to build
07:46:38 <ndm> so the options are ship the text file and tweak cabal to build the database - but then i'd have no idea where to install the db
07:46:57 <ndm> or ship the db in the .tar.gz, but then darcs users wouldn't have it
07:47:11 <ndm> or commit the db to the darcs repo, which i'm definately _not_ doing
07:47:17 <ndm> whats the solution, in terms of packaging?
07:47:24 <dcoutts_> ndm: you think having it generate the db the first time it's run is too onerous ?
07:47:37 <dcoutts_> ndm: afterall, doesn't it depend on what libs the user has?
07:48:01 <ndm> dcoutts_: that will be done later, this is more a beta release with one fixed, static database
07:48:16 <dcoutts_> I see
07:48:20 <jrh> not sure, test.  try rwbarton's line.
07:48:32 <dcoutts_> ndm: so ideally we'd use the data-files thing
07:49:05 <dcoutts_> ndm: so are you looking for a quick hack, or something you can support long term?
07:49:43 <dcoutts_> the quick hack is to just modify the release version to include data-files: the.db and put that db in the package tarball
07:49:56 <ndm> dcoutts_: don't know :) - i'm wondering if there is a nice way to have it work from both the darcs and the tarball?
07:50:02 <rwbarton> test: do you want a list with two strings?   [".....", "....."]
07:50:25 <dcoutts_> ndm: it can be done with a custom Setup.hs
07:50:38 <test> vixey: why are you writing :[] ?
07:50:48 <dcoutts_> ndm: eg, see alex and happy which generate their data files at compile time using perl :-)
07:50:53 <test> to put somthg in my list :) signature expects that
07:51:09 <vixey> test: Maybe you have the wrong signature
07:51:11 <ndm> dcoutts_: yes, i've had that fail for me...
07:51:24 <dcoutts_> ndm: what no perl ? :-)
07:51:41 <ndm> dcoutts_: my perl skills are rusty :)
07:51:47 <dcoutts_> ndm: right, but in principle that works, though you might avoid using perl
07:52:08 <test> rwbarton: no [".....", "....."] i just want to put a string in my list of strings but with nice format
07:52:29 <test> like that :
07:52:29 <test> ........
07:52:29 <test> ........
07:52:29 <test> ........
07:52:46 <test> problem is that my signature expects [String]
07:52:56 <dcoutts_> ndm: but if you can avoid it, I'd be tempted to just do the quick hack, and then next time have it generate the files on the client after install.
07:53:17 <ndm> dcoutts_: fair enough :)
07:54:09 <ndm> hopefully i'll have a hoogle beta by this evening :)
07:55:26 <lilachaze> test: i think it'd be helpful if you could either (1) explain what you're trying to accomplish, (2) paste your code (at hpaste.org), or (3) both. :)
07:55:43 <chr1s> is there a way to catch runtime exceptions?
07:55:56 <test> byeeeeeeee gotta go
07:55:57 <test> exit
07:55:58 <test> quit
07:56:00 <test> hmm
07:56:15 <fons> chr1s: like pattern matching errors? Using the standard catch function sould do it
07:56:18 <fons> should
07:56:42 <fons> look at COntrol.Exceptions
07:56:46 <Jedai> chr1s: You can catch exception in the IO monad
07:56:49 <fons> Control.Exceptions, sorry
07:56:55 <dcoutts_> ndm: you've got lots of competition all of a sudden I note
07:56:58 <chr1s> well, I want to do it without being in IO
07:57:19 <fons> chr1s: AFAIK, that's not possible
07:57:21 <Jedai> chr1s: Don't use the System.IO catch, use the Control.Exception one, it catch any kind of exception
07:57:33 <paczesiowa> you can catch in unsfePerformIO
07:57:33 <chr1s> I'll do it with an unsafePerformIO
07:57:37 <chr1s> yes.
07:57:55 <fons> expections can be thrown in pure code but not caught
07:57:58 <Jedai> chr1s: If you could catch exception outside of IO it would be impure, don't do that. You can use Either or Maybe as alternatives
07:58:01 <dcoutts_> ndm: hayoo just picked up searching of package names
07:58:05 <ski> @hoogle mapException
07:58:05 <lambdabot> Control.Exception.mapException :: (Exception -> Exception) -> a -> a
07:58:21 <ski> there's also that, if you just want to change what exception you raise
07:58:28 <paczesiowa> but you better have good reason no to use pure exception monads
07:58:49 <ndm> dcoutts_: yes, i saw - still absolutely no type searching though, and no command line version - but still good
07:58:50 <jeffwheeler> Are hoogle and hayoo trying to solve the problem, or is Hayoo more focused on extra-library searching?
07:59:03 <ndm> Hoogle is just as focused on extra-library searching
07:59:15 <ski> @where hayoo
07:59:16 <lambdabot> I know nothing about hayoo.
07:59:16 <jeffwheeler> Hmm; then they are trying to solve the same problem?
07:59:17 <ndm> I think Hayoo is meant to be showing how you can do a generalised search library in Haskell
07:59:29 <ndm> while Hoogle is trying to solve the Haskell search problem much more specifically
07:59:29 <jrh> @where hayoo!
07:59:29 <lambdabot> I know nothing about hayoo!.
07:59:41 <ndm> but yeah, roughly the same problem :)
07:59:49 <dcoutts_> ndm: aye, though we need both. Text search too.
07:59:57 <jeffwheeler> Ah, I've used Hayoo in the past with good luck; I should try Hoogle too, next time, for comparison
08:00:05 <dcoutts_> ndm: certainly, type search is insanely cool
08:00:08 <ndm> dcoutts_: I believe Hoogle 4 has faster text searching
08:00:29 <ski> @hoogle-version
08:00:30 <lambdabot> Unknown command, try @list
08:00:40 <ndm> jeffwheeler: hoogle is currently being rewritten from scratch, there will be a new version out this evening which is brand new
08:00:46 <fons> ndm: are you going to make the new beta usable online?
08:00:56 <fons> ndm: or are you just going to upload the code
08:00:58 <jeffwheeler> ndm: I'm excited; I'll definitely try it out --- now they both just need better URIs
08:01:23 <paczesiowa> do any of you use kde4[.1] versions of kate/kwrite for haskell? syntax highlighting seems broken (compared to kde3)
08:01:27 <jeffwheeler> I think Hoogle has the better one right now (IIRC), but both could be improved.
08:01:33 <ndm> fons: the beta will be command line only, but its structured so i hope to have a web version out at the end of next week
08:01:39 <ndm> jeffwheeler: better URI's?
08:01:57 <jeffwheeler> ndm: http://hoogle.com or something; haskell.org/hoogle/ is long as it is :P
08:02:00 <lambdabot> Title: Hypocrisy.com
08:02:13 <ndm> try http://hoogle.net :-) [NSFW]
08:02:14 <lambdabot> Title: Hoogle.Net cool BDSM Sites.
08:02:16 <jeffwheeler> ndm: well, obviously not that, since it's already owned, but something similar
08:02:19 <fons> ndm: cool, thanks for your work, I really appreciate the late heathly competition between hayoo! and hoogle
08:02:45 <ndm> yeah, most of the Hayoo ideas were already in Hoogle before they came out, but now i do have a strong incentive to make mine shinnier :)
08:03:58 <fons> ndm: last question, is the new version hackage-db aware?
08:04:09 <dcoutts_> ndm: though I get the impression their text search is more shiny. Or perhaps that's just because you don't talk about that bit so much :-)
08:05:10 <dcoutts_> fons: I'm planning to integrate hoogle with the new hackage-server, unless ndm gets run over by a bus in which case we'll have to go with hayoo
08:05:19 <ndm> fons: yes, it will be :)
08:05:29 * ndm tries to avoid the business end of a bus
08:05:29 <dcoutts_> ndm: I'll show you the hackage-server code at AngloHaskell
08:05:39 <fons> great!
08:05:41 <ndm> dcoutts_: and i'll show you Hoogle :)
08:05:42 <dcoutts_> ndm: though it may not build on windows, I've not tried it
08:05:55 <dcoutts_> and certainly not with hugs ;-)
08:06:15 <ndm> i believe their text search has more text search fatures, like fuzziness, but don't think its that useful
08:06:28 <ndm> (of course, people are encouraged to tell me if i'm wrong)
08:06:49 <ndm> Hoogle 4 has cool things like searching Data.Map.Map works :)
08:06:49 <fons> how's hugs development going BTW? stalled?
08:06:58 <ndm> stalled for years, i think
08:08:08 <fons> too bad
08:09:39 <tantalum> Hi. I'm trying to build ghc on Ubuntu 64bit but when I run "sh boot" I get this error: http://pastebin.com/d43212903
08:11:08 <tantalum> Does any one know what could be causing that
08:12:07 <fons> tantalum: wrong version of autoconf?
08:13:04 <tantalum> I just downloaded the latest compiled and installed it
08:14:28 <tantalum> that is the latest version of autoconf
08:15:09 <jrh> I have a package for FTGL, the FreeType for OpenGL library.  If I want to package it so that it's compatible with current heirarchical naming schemes, I was thinking Graphics.Rendering.FTGL
08:15:10 <fons> I can't really tell what's wrong, sorry
08:15:16 <jrh> does that make sense to everyone?
08:20:20 <dons> jrh: seems ok.
08:21:41 <jrh> thx, dons.
08:26:16 <dcoutts_> dons: get the latest darcs Cabal-1.4 and try installing the platform meta-package
08:26:43 <dons> dcoutts_: ok.
08:27:35 <dcoutts_> dons: I think we should probably require meta-packages to be identified on hackage
08:28:03 <dcoutts_> dons: eg, not allow upload of packages with no modules or C source, unless marked as x-hackage-meta-package or something
08:28:19 <dcoutts_> dons: and then not allow any other packages to depend on meta-packages, since that's bad form
08:29:19 <dons> well, i was also thinking of having Distribution.Haskell.Version or something , giving the meta package a real module.
08:29:25 <dons> i.e. just reexport the version number
08:29:29 <dons> and some docs.
08:29:37 <dcoutts_> dons: mm
08:30:29 <dons> in general we probably want these though
08:30:53 <dcoutts_> dons: aye, I guess so
08:31:20 <dcoutts_> dons: we should still mark it as a meta-package
08:31:28 <dcoutts_> and not allow further deps
08:32:29 <dcoutts_> dons: what's the use case for exporting the platform version number btw?
08:32:44 <dons> yeah
08:32:54 <dons> oh, might be useful?
08:32:56 <dons> :)
08:33:14 <dons> built with Haskell 1.0
08:33:36 <dcoutts_> dons: I'd rather discourage packages depending on the meta-package
08:33:49 <dcoutts_> dons: so any that did import it could not be uploaded to hackage anyway
08:34:28 <dons> yeah, that makes sense.
08:34:35 <dcoutts_> dons: docs are obviously fine, and it's sadly true at the moment that we have no decent support for docs except haddock
08:41:01 <ndm> dcoutts_: i've just tried building Hoogle, putting a Paths_hoogle.hs file in the src directory for debugging - and after a cabal install its still using that one rather than the generated one
08:41:17 <ndm> is that a cabal bug? it used to work, but perhaps it was never meant to
08:41:36 <dcoutts_> ndm: no, it's by design. If you put one in src then it masks the auto-generated one.
08:42:00 <ndm> dcoutts_: really? the other way round is very useful
08:42:14 <ndm> dcoutts_: but i can't possibly think of a use for the current way round
08:42:40 <ndm> and i'm sure it used to do what i want at some point
08:43:11 <dcoutts_> ndm: I don't think it ever did, that dir is always after the srcs dirs on the ghc -i search list
08:43:32 <dcoutts_> ndm: it's that by default you should be able to have any module name you like
08:43:58 <dcoutts_> your source .hs file have first precedence, then stuff that's magically provided and then packages
08:44:12 <ndm> dcoutts_: but how am i meant to test a program using Hugs if it requires Paths_hoogle ?
08:44:30 <ndm> I need to fake up a Paths_hoogle, which works best in src, but then gets ignored later
08:44:32 <dcoutts_> ndm: tell hugs to look in dist/build/autogen
08:45:00 <dcoutts_> ndm: though configure for hugs, or it generates different code for the Paths_ module
08:45:04 <ndm> i want to use a fake Paths_hoogle during development, then the real one when compiled
08:45:11 <dcoutts_> why?
08:45:15 <dcoutts_> you need to modify it?
08:45:25 <dcoutts_> to find data files? because we can do that
08:45:56 <ndm> i don't care about Paths_hoogle during the development, and searching in dist/build/autogen is annoying and will usually fail, since i usually cabal build with ghc
08:46:21 <ndm> its purely for debugging, i'm not interested in any Paths_* features while debugging, i just want it to work in Hugs - which means without cabal
08:46:43 <dcoutts_> ndm: cabal support hugs fine, if not report the bugs :-)
08:46:45 <ndm> i also don';t have Paths_hoogle in my Other-Modules command
08:46:52 <dcoutts_> you should
08:46:59 <ndm> cabal does not support Hugs in any good way for debugging a program using WinHugs
08:47:19 <ndm> i don't particularly think it should - cabal for Hugs is more for release stuff
08:47:27 <dcoutts_> ndm: you mean because of having to add -i dirs ?
08:47:33 <paczesiowa> how can I reexport module from another module? A imports B and should export A stuff and also whole B
08:47:54 <ndm> i guess i can do it with some weird -i-ness in Hugs
08:48:09 <ndm> but the other way used to be supported, and seems a lot more useful
08:48:46 <dcoutts_> ndm: if you want you can of course have another Paths_hoogle module that's not in the main src dir
08:48:52 <dcoutts_> and use -i the_other_dir
08:49:10 <ndm> yeah, thats what i probably will do
08:49:16 <dcoutts_> that's equivalent to -i dist/build/autogen except that you don't need to configure --hugs
08:52:01 <ndm> is there any reason a user would ever create their own Paths_foo which they wanted to be used in favour to an auto-gen'd one?
08:56:37 <Jedai> paczesiowa: You just put the name of the module in the exports list
08:57:14 <Jedai> paczesiowa: module A (module B, ... ) where
08:57:22 <Jedai> something like that
08:57:52 <paczesiowa> Jedai: thanks, problem was module keyword, didn't know about that one
08:57:56 <jrh> Does hackage automatically run haddock on my Haskell files?
08:58:25 <Jedai> paczesiowa: Try it before you thank me ! I think it's like that though :)
09:00:23 <paczesiowa> Jedai: it works, but I can't reexport some module with hiding one symbol
09:00:57 <paczesiowa> module A(module B hiding foo, foo) would be great
09:01:07 <Jedai> paczesiowa: Well you can import it with the symbole hidden if you want and then reexport
09:01:46 <Jedai> In this case I'm pretty sure the symbol will stay hidden
09:01:51 <pozic> Is it even possible to write a Haskell program with error reporting without using a monad somewhere without making a mess?
09:01:55 <paczesiowa> Jedai: that works, thanks!
09:02:03 <Jedai> pozic: No !
09:02:05 <ski> Jedai : are you sure that doesn't just rexport the whole module, while not keeping the identifier hidden in the module itself ?
09:02:20 <Valodim> it's not possible to write a haskell program without using a monad
09:02:30 <ski> s/not //
09:02:33 <Jedai> ski: I'm not sure, ask paczesiowa, he just tried
09:02:33 <paczesiowa> ski: looks like it works ok
09:02:53 <ski> ok, fine then
09:02:54 <Jedai> pozic: But why would you like to do that ?
09:03:20 <Jedai> pozic: (You're aware that we have exceptions, are you ?)
09:03:38 <pozic> Jedai: Functional programming is always advertised as being more easy to debug, but with a monad you still need to setup some kind of state in most cases.
09:03:51 <pozic> Er easy to test.
09:03:59 <Jedai> pozic: Either or MAybe monad don't have any kind of state
09:04:01 <Toxaris> pozic: why do you need to setup state for a Error monad?
09:04:06 <pozic> Jedai: yes, but that brings me in the IO monad.
09:04:12 <pozic> Jedai: (the exceptions)
09:04:33 <Jedai> pozic: Writer hasn't got a setup state either
09:04:34 <ski> `Either MyExceptions' doesn't necessarily involve `IO'
09:04:45 <pozic> Yes, so, I suppose it's alright.
09:04:45 <mattam> @src both
09:04:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:04:58 <ski> mattam ?
09:05:10 <paczesiowa> pozic: you can use Debug.Trace
09:05:54 <pozic> In this case the requirements changed from "you will always get correct input" to "you might get garbage input".
09:06:35 <pozic> Which is the difference between computing something that always exists to something that might not exists, i.e. I needed to recover from errors.
09:07:36 <paczesiowa> pozic: you can use regular exceptions inside IO
09:08:28 <lispy> All the different ways of doing errors does lead to some issues...it's not obvious which way is preferred when
09:10:43 <paczesiowa> MonadError is nice I think -> most general
09:11:44 <pozic> It's also not so cool that I lose the correspondence with the formulas from the domain I am working in.
09:12:08 <pozic> Instead of a/b it now becomes liftM (/b) . a
09:12:21 <pozic> (. = fmap)
09:12:47 <paczesiowa> wouldn't that be liftM2 (/) a b ?
09:12:57 <pozic> paczesiowa: no
09:13:03 <pozic> paczesiowa: only one is a monadic result
09:13:06 <Deewiant> why not do a' <- a; return (a/b)
09:13:11 <Deewiant> er, a'/b
09:13:21 <pozic> Deewiant: not introducing to much useless names.
09:13:30 <pozic> Deewiant: althought, sometimes I do it like that.
09:13:33 <Asgaroth> If I use a construct like this "let r = recursive_call foo in (r,bar)", would that be still a case of tail recursion and could thus be optimized by the compiler?
09:13:34 <pozic> although*
09:13:41 <paczesiowa> anyway, you can always redefine (/) to work inside your monad
09:13:46 <chrisdone> (/b) <$> a
09:13:52 <Deewiant> pozic: I think that's better than liftM or fmap all over the place
09:14:28 <Twey> Asgaroth: That's not tail recursion, no
09:14:44 <Asgaroth> Twey: Is it because of the pair building or the let?
09:14:45 <Twey> Because you're then performing another operation on it by putting it into a tuple
09:14:50 <Asgaroth> ok
09:14:57 <Asgaroth> thanks
09:15:29 <chrisdone> tail recursion modulo (,)
09:16:19 <ski> paczesiowa : actually, while `MonadError' is fine .. the instance for `Either error' is not general enough :(
09:16:24 <Asgaroth> Is there a simpler way to turn this into a tail recursive variant or would I have to use the standard accumulator-argument approach?
09:16:30 <chrisdone> operations like cons, +, etc can be optimised into th tail recursive process
09:16:43 <chrisdone> http://en.wikipedia.org/wiki/Tail_recursion#Tail_recursion_modulo_cons
09:16:44 <lambdabot> Title: Tail recursion - Wikipedia, the free encyclopedia, http://tinyurl.com/52tg2
09:17:18 <paczesiowa> ski: what Either error are you talking about?
09:19:12 <ski> `instance Error e => MonadError e (Either e)' and `instance (Monad m, Error e) => MonadError e (ErrorT e m)', specifically
09:20:57 <ski> @src Error
09:20:57 <lambdabot> class Error a where
09:20:57 <lambdabot>     noMsg  :: a
09:20:57 <lambdabot>     strMsg :: String -> a
09:21:00 <patc> can anyone help me with a c2hs question?
09:21:21 <ski> paczesiowa : i think you see the problem now, yes ?
09:21:33 <Asgaroth> chrisdone: So if I understood it correctly, I should be fine with my construct and ghc will take care of it, right?
09:23:04 * ndm pre-beta releases Hoogle 4.0 for the base only for the console
09:23:14 <lispy> ndm: congrats
09:23:27 <ndm> does anyone have cabal-install and want to give it a quick check? i don't have cabal-install on this machine?
09:23:32 <lispy> ndm: happy times!  I've been waiting for hoogle 4 or a while
09:23:45 <lispy> ndm: I don't have cabal-install either or I would
09:23:57 <lispy> actually let me double check
09:24:02 <ndm> it should be as simple as: cabal update && cabal install hoogle && hoogle "[a] -> [b]"
09:24:05 <lispy> yeah no cabal-install here
09:24:32 <dcoutts_> ndm: I'll test it when I get home
09:24:35 <ndm> non cabal-install users are of course welcome to try it, but it has a number of dependencies
09:24:57 <ndm> if one person gets it working, i'll do a blog article on it - just don't want to and then find it does't work
09:26:04 <dcoutts_> ndm: build reporting ftw!
09:26:39 <ndm> indeed :)
09:27:36 <ddarius> I'll give it a go now
09:28:15 <siponen> Is there some repositry of the Haskell research papers? The one on haskell.org seems to have only links and some that I wanted are dead.
09:28:34 <ndm> ddarius: cheers :) - if that exact command doesn't work, please let me know, i want to give something for users to play with easily
09:29:03 <ndm> https://haskell.org/ gives me a certificate expired message in both Opera and Firefox
09:29:03 <lambdabot> Title: Haskell - HaskellWiki
09:29:47 <Deewiant> heh, expired in 2005
09:30:05 <Twey> Haha
09:30:09 <EvilTerran> whups
09:31:08 <chrisdone> Asgaroth: I would imagine so, but I don't know for sure
09:33:57 <ddarius> ndm: It builds and seems to work.  That query produces a heck of a lot of output.
09:34:03 <ddarius> This is on Ubuntu x86
09:34:25 <ddarius> siponen: Google.
09:34:52 <ddarius> ndm: If you suggest that command line you may want to add a '| less' to the end.
09:34:58 <ndm> ddarius: fantastic! I guess I should recommend /n=10 - limit the output to 10 results
09:35:09 <ndm> cabal update && cabal install hoogle && hoogle "[a] -> [b]" /n=10
09:35:11 <Asgaroth> Is there a difference(memory-usage,etc) between using iterate foo !! bar and doing foo (foo (foo ... bar times? Due to lazy evaluation, they should be the same, right?
09:35:14 <Operator> hi, i am thinking of learning haskell, what do u guise think?
09:35:43 <ndm> Asgaroth: there is, slightly, but pick the iterate version as it is clearest
09:35:45 <ski> `/n' being windows-style option, yes ?
09:35:52 <jeffwheeler> Operator: You're in #haskell --- what do you think? ;)
09:35:53 <ndm> cabal update && cabal install hoogle && hoogle "[a] -> [b]" --n=10
09:35:59 <ndm> either works :)
09:36:12 <Operator> jeffwheeler, ah ok, just the answer i was looking for, can i write/use it in linux?
09:36:19 <Asgaroth> ndm: Well, I could write a helper function to apply it repeatedly without building a list, should I rather do that?
09:36:26 <Asgaroth> Operator: Of course.
09:36:31 <Operator> goody
09:37:29 <chrisdone> it probably works the best in linux
09:37:35 <Operator> what kind of language is it, i mean, does it compile into an executable, or do you run it as is?
09:37:38 <ndm> Asgaroth: not worth the hassle, if it turns out to be something you need to do frequently, and it appears on a profile, then you can try
09:37:58 <jeffwheeler> Operator: GHC can compile to an executable, but it also has an interpreter/REPL
09:38:19 <Asgaroth> ndm: No, it's not that important. Thanks for your help.
09:38:38 <Operator> ok, well time to get started, what shall i start off with
09:38:38 <opqdonut> how big is the ghc runtime?
09:38:42 <ski> `interpreter' is not the same as `interactive top-level' aka `interactor' aka `repl'
09:38:52 <jeffwheeler> Operator: Google for Real World haskell
09:38:53 <Operator> set me a large-ish challenge to complete please
09:39:27 <jeffwheeler> ski: Hmm, usually I consider a REPL to be an interpreter, but I could be completely wrong.
09:39:33 <ski> Operator : sometimes writing an irc bot is suggested
09:39:48 <Operator> oh cool i am familiar with the protocol
09:39:56 <Operator> i have made bots in python and php :)
09:40:12 <ski> jeffwheeler : `interpreter' refers to the way the implementation works, `interactor' refers to the interface
09:40:41 <jeffwheeler> ski: Ah, okay. So, under-the-hood, I would assume GHCi is in fact an interpreter, right?
09:40:47 <jeffwheeler> It doesn't compile and then output, does it?
09:40:51 <ski> jeffwheeler : no
09:40:56 <Asgaroth> So the repl, just compiles the stuff you give to it internally and executes it, instead of interpreting it, right?
09:41:15 <Asgaroth> The ghci repl that is.
09:41:20 <ski> Asgaroth : in the case of a repl/interactor in front of a compiler, yes
09:41:55 <ski> jeffwheeler : however, iirc, GHCi compiles down to a byte-code representation, which it then runs an interpreter on
09:41:56 <lispy> that's also how the lisp compiler SBCL implements the interactive mode too
09:41:57 <ddarius> @where rwh
09:41:58 <lambdabot> is http://www.realworldhaskell.org/blog/
09:42:20 <Operator> is it easy to use sockets
09:42:33 <ski> so, there's usually a trade-off between how much is compilation and how much is interpretation (your CPU is an interpreter)
09:42:35 <Operator> and are there a load of predefined functions i.e php's md5()
09:43:02 <jeffwheeler> Operator: try going through RWH, and there's a pureMD5 library in hackage
09:43:21 <Operator> ok cool, im just browsing through rwh now
09:49:45 <solrize> @quote solrize
09:49:45 <lambdabot> No quotes match. You type like i drive.
09:49:49 <solrize> @quote unlearning
09:49:49 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:49:54 <solrize> @quote unlearning
09:49:55 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:49:56 <solrize> @quote unlearning
09:49:56 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:49:57 <solrize> @quote unlearning
09:49:57 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:49:59 <solrize> @quote unlearning
09:49:59 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:50:00 <chrisdone> stop
09:50:00 <solrize> @quote unlearning
09:50:00 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
09:50:35 <solrize> somehow lambdabot has another version of that quote, misattributed to me
09:50:55 <Twey> Doesn't seem so
09:50:56 <ddarius> @quote solrize
09:50:57 <lambdabot> No quotes match. It can only be attributed to human error.
09:50:57 <jeffwheeler> solrize: /msg lambdabot and talk all you like
09:51:03 <solrize> tx
09:51:25 <jeffwheeler> (I don't get why people use lambdabot publicly, like for evaluation or pl.)
09:51:43 <Twey> So people can comment on it, of course
09:51:43 <Valodim> ..because it's more fun?
09:51:48 <Twey> 'Why are you doing that?'
09:51:52 <Twey> 'You can do it better this way'
09:51:55 <Valodim> yes!
09:51:56 <solrize> in this case i wanted to exhibit the error
09:51:59 <Twey> 'It looks better expressed as...'
09:52:19 <jeffwheeler> I guess so; I always have to do it fifty times before I get a half-working version. :P
09:52:26 <Baughn> Cale: Would you mind if I added an sqlite dependency to \bot?
09:52:36 <chrisdone> Baughn: what for?
09:52:53 <Baughn> chrisdone: ACID semantics and such
09:53:13 <Baughn> Well, it's mostly so I don't have to rewrite it
09:53:25 <chrisdone> Baughn: what are you using sqlite for? :)
09:53:37 <Baughn> chrisdone: Storing module states. Particularily Seen's
09:53:46 <chrisdone> Baughn: ahh, I see, cool
09:55:00 <Baughn> Hm. I think there's a simple solution that doesn't need it, though
09:55:35 <solrize> happs state?
09:55:36 <chrisdone> Baughn: channels?
09:56:03 <Baughn> Journalling. :P
09:56:07 <Valodim> wouldn't hurt though, sqlite is pretty nice to work with. happs state would be a good solution as well
09:56:56 <Valodim> journaling?
09:57:06 <chrisdone> Baughn: while on the subject, do you know if sqlite3 operations are thread-safe, on any of the sqlite libraries on hackage?
09:57:15 <Baughn> chrisdone: I do not.
09:57:32 <zachk1> > + 2 2
09:57:33 <lambdabot>   parse error on input `+'
09:57:39 <zachk1> wth
09:57:50 <jeffwheeler> > (+) 2 2
09:57:51 <lambdabot>  4
09:57:59 <zachk1> > 2 + 2
09:58:00 <jeffwheeler> + is an infix opreator.
09:58:00 <lambdabot>  4
09:58:07 <jeffwheeler> * operator
09:58:08 <Baughn> Valodim: http://en.wikipedia.org/wiki/Journaling_file_system <-- Journaling.
09:58:09 <lambdabot> Title: Journaling file system - Wikipedia, the free encyclopedia
09:58:11 <zachk1> too much rpn lately :-D
09:58:25 <ddarius> zachk1: That was Polish notation.
09:58:34 <jeffwheeler> zachk1: that'd be > 2 2 + ;)
09:58:40 <chrisdone> Baughn: well I'm implementing some web library with database support built-in, I may stick all DB operations in an MVar lock, somehow
09:59:20 <Baughn> chrisdone: That won't be enough. If the DB cares about which OS thread you're calling it from, you'll need to forkOS and then do all operations via that thread.
09:59:41 <Baughn> Obviously, that's costly and should be avoided if possible
10:00:17 <Baughn> If it just isn't okay with multiple threads /at once/, then an mvar would work, sure
10:01:17 <Baughn> @tell Cale Right. I've got a couple possible solutions for seen.. what I *want* to do is add in sqlite, or failing that happs-state, but I don't have to. Your call.
10:01:17 <lambdabot> Consider it noted.
10:02:30 <chrisdone> Baughn: why would it care about which OS thread I call it from?
10:03:12 <Baughn> chrisdone: The library might be using thread-local state
10:03:55 <Baughn> OpenGL usually does that, for example
10:04:02 <chrisdone> Baughn: however, if using forkIO, that is the same OS thread?
10:05:40 <MyCatVerbs> chrisdone: forkIO doesn't get you any guarantees at all about which OS thread things happen in.
10:06:18 <chrisdone> MyCatVerbs: hm, pity. okay, well, I guess then I'll have to see if sqlite is threadsafe
10:06:25 <Baughn> chrisdone: That's what forkOS is for
10:06:45 <Baughn> It gets you a thread all of your own
10:07:57 <chrisdone> according this, a Connection can be passed between threads, providing no transaction locks are in place: http://www.sqlite.org/faq.html#q6
10:08:26 <hackage> Uploaded to hackage: prof2dot 0.4.1
10:08:26 <hackage> Uploaded to hackage: hoogle 4.0
10:08:52 <Baughn> chrisdone: Problem is, the ghc rts will pass it between threads with no regard for transaction locks
10:09:17 <bd_> unless you use forkOS :)
10:09:18 <chrisdone> Baughn: but surely, MVar locks can ensure that transactions are completed?
10:09:33 <Baughn> chrisdone: No. It can only provide mutual exclusion.
10:09:52 <bd_> chrisdone: the issue is if you do:  withMVar lock (\() -> foo; bar)  then foo and bar may occur on different threads
10:09:55 <lispy> ?pl \p -> (f1 p) || (f2 p)
10:09:55 <lambdabot> liftM2 (||) f1 f2
10:09:58 <chrisdone> Baughn: right, that means other threads can't operate while the transaction is in play
10:10:01 <Baughn> chrisdone: There will only be one thread /at a time/, sure, but the rts may switch around which particular thread that is at a ny point
10:10:06 <Cale> Baughn: I say do whatever you think is best :)
10:10:06 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:10:19 <Baughn> Cale: Sqlite it is, then. Another dependency going up.
10:10:23 <bd_> chrisdone: haskell threads are not OS threads; a single haskell thread may bounce between OS threads at random times
10:10:46 <Cale> lambdabot has enough dependencies that it just doesn't matter anymore if there's one more :)
10:10:49 <bd_> chrisdone: so, if sqlite will explode if it moves between OS threads in the middle of an operation, then you need to use forkOS to bind it to a single OS thread
10:11:09 <chrisdone> hm, that is a pity
10:11:33 <chrisdone> then I may as well confine all DB operations to one OS thread and send messages to it via a channel
10:11:50 <bd_> chrisdone: send it IO () s :)
10:11:58 <chrisdone> bd_: good idea
10:12:05 <bd_> chrisdone: although, sqlite can handle multiple readers
10:12:16 <bd_> and so having multiple OS threads can be useful
10:13:19 <chrisdone> one OS thread to read from the database, one OS thread to write to the database
10:14:01 <bd_> chrisdone: a complex read query may block simpler queries on other threads
10:14:36 <bd_> chrisdone: "You can safely assume that no locks are being held if no transaction is pending and all statements have been finalized."
10:14:43 <bd_> I would introduce a sqlite transaction monad or something
10:14:56 <bd_> execute everything in the sqlite transaction in one forkOS'd thread
10:15:35 <pozic> Is there a sequence that is paralell?
10:16:05 <pozic> parallel*
10:16:10 <bd_> pozic: what do you mean?
10:16:16 <pozic> :t sequence
10:16:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:16:43 <pozic> bd_: I mean that the list of actions can be executed in any order.
10:17:48 <bd_> pozic: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v%3AmergeIO
10:17:49 <lambdabot> Title: Control.Concurrent, http://tinyurl.com/y2q5k2
10:18:00 <bd_> wait no
10:18:23 <chrisdone> bd_: if I run the transaction in an OS thread, how might I wait for it to finish and get a result? pass a channel and start reading from the channel for a return value?
10:18:47 <bd_> chrisdone: I'd just use an MVar to communicate the result value
10:18:58 <bd_> start it off empty; the calling thread blocks on the MVar being filled.
10:19:18 <bd_> exceptions can be caught, passed through the MVar, and re-thrown at the call site
10:20:35 <chrisdone> bd_: so when this forkIO call is started, we lock the Connection with an MVar to block all other threads at that point?
10:21:14 <bd_> wait, I think I misunderstood sqlite's design a bit
10:21:16 <chrisdone> bd_: well, not block them directly, but cause them to block if they try to access the connection
10:21:31 <bd_> okay, I was thinking you could easily do multiple simultaneous statements on one Connection
10:21:41 * ptolomy2 wonders if he should release his fast bytestring parser combinator library that has No Theoretical Basis (tm).
10:22:29 <bd_> but since that's not so, I'd fork a forkOS'd thread for each Connection, with a channel carrying IO (). To execute a statement, you'd enter a monad, which secretly passes the body off to said forkOS'd thread, and pass the result back across an MVar bound inside said IO ()
10:22:40 <ptolomy2> The world probably has enough of them, and putting a new one out there without evidence that it actually is faster compared to the alternatives seems pointless.
10:24:18 <bd_> chrisdone: this method of using a single forkOS'd thread for all statements implicitly serializes access, of course :)
10:24:19 <chrisdone> bd_: you mean I'll have to make a Connection for every forkIO thread on my web server?
10:24:48 <bd_> chrisdone: No, but you'll only be able to execute one statement at a time (others would have to block). This is implicit in the design of sqlite however.
10:24:49 <Toxaris> ptolomy2: has the world enough of them?
10:25:21 <bd_> chrisdone: the idea is that only one, forkOS'd thread, is allowed to interact with sqlite at all; as such, there's no need for locking per se.
10:25:24 <chrisdone> bd_: it all seems horribly complicated
10:25:45 <bd_> chrisdone: The alternative is using a lock AND forkOS'ing threads whenever you execute a statement
10:25:46 <ptolomy2> Toxaris: I'm pretty sure there are at least 3.
10:26:04 <ptolomy2> Mine actually may be accidentally PEG-based.
10:26:46 <chrisdone> bd_: it would be nice if multiple threads could read from the database simultaneously
10:27:20 <chrisdone> bd_: do you think there would be any performance gain to that? I'd imagine in Sql's implementation that it would be done in order anyway
10:27:35 <bd_> chrisdone: sqlite requires you to use multiple Connections in that case
10:28:05 <bd_> you're not allowed to pass Connections between threads if you have a) an open txn or b) a prepared statement
10:28:21 <bd_> and by 'threads' I mean 'OS threads' not 'haskell threads'
10:28:35 <chrisdone> right
10:29:28 <bd_> chrisdone: and because of that, you'll have to serialize reads - if you have one read in progress, it has a prepared statement, and thus you can't operate from another thread
10:29:38 <bd_> unless you use another Connection of course
10:29:48 <chrisdone> the “one OS thread for all DB stuff” seems simple and clean, appealing to Keep it Simple, Stupid!, but would there be a loss in performance?
10:30:16 <soduko> is there a way to control win32 apps through com interface similar to python win32com ?
10:30:27 <bd_> chrisdone: possibly.
10:30:30 <lispy> soduko: HDirect
10:30:51 <bd_> chrisdone: but I don't think it'll be much; if you hit against such issues you need multiple Connections anyway...
10:31:05 <bd_> (because, again, SQLite /requires/ multiple connections for multiple reads)
10:31:15 <lispy> soduko: there is currently a theard about com in haskell on haskell-cafe
10:31:22 <bd_> and if you don't use a single forkOS thread, you'll need to create one for every operation, which seems like it'd have more overhead
10:31:26 <chrisdone> bd_: I don't have any notion of how threads provide performance gains, other than when one thread is waiting for hardware things like HD, memory or TCP, other threads can run...
10:32:12 <chrisdone> bd_: well, that seems okay then
10:32:27 <lispy> soduko: my experience with hdirect is that it's not receiving adequate maintenance
10:32:35 <matt_estes> for the sqlite guys: under a certain level of load, you will start having problems with sqlite, threads or no threads. Don't get me wrong, its not a bad system at all, but it has load issues
10:33:07 <chrisdone> matt_estes: did you implement such a system as we're discussing?
10:33:14 <matt_estes> I know this because my friend's web server gets hit hard IO bound due to a PHP "shared nothing" web app that he's hosting... that I wrote... (I get nasty emails about this).
10:33:29 <matt_estes> Well, I don't know details, and I'm a total haskell n00b :)
10:34:05 <matt_estes> But I have used SQLite for web apps, and I played with some of the algorithms they based it on.
10:34:10 <matt_estes> http://www.sqlite.org/fileformat.html
10:34:13 <bd_> well, sqlite isn't really designed for heavy-load stuff, afaik
10:34:44 <matt_estes> I guess my experience is that's got a pretty sharp corner
10:34:53 <chrisdone> how heavy is “heavy”?
10:35:22 <chrisdone> let's say in requests per second
10:35:25 <matt_estes> 2-3 concurrent users, a few transactions per second.
10:35:31 <matt_estes> 2-3.
10:35:55 <matt_estes> Its the locking that keeps getting me.
10:36:20 <chrisdone> what do you mean by getting you?
10:36:24 <chrisdone> you get lock exceptions?
10:36:58 <matt_estes> 2-3 hits on the web app, back-to-back start timing out because the first request locks the DB, and the other just stall out.
10:37:28 <chrisdone> I ran a little poll web site with fastcgi and sqlite a while ago, without any kind of locking in my program, and then posted it to 4chan... after a while there were sqlite exceptions on the page
10:37:49 <matt_estes> Yeah, this one has been running a while, I think size has something to do with it, its got about 15,000 records.
10:38:00 <chrisdone> matt_estes: stall out? oh, wait. is that where it times out if it waits for too long?
10:38:10 <matt_estes> 120 seconds is the PHP timeout.
10:38:16 <matt_estes> On this app.
10:38:29 <chrisdone> I can't believe it would take 120 seconds for sqlite to do an insertion
10:38:42 <matt_estes> Its the select's actually...
10:38:48 <chrisdone> ah
10:38:53 <matt_estes> (Btw, I'm new to IRC too, so I hope I'm not out of line).
10:39:03 <matt_estes> Its doing a couple of inner and outer joins.
10:39:04 <chrisdone> on 15,000...
10:39:11 <dbbddbdb> Lemmih: Is it possible to add timers that generate events to hssdl?
10:39:23 <chrisdone> is that a lot by DB standards? I wouldn't have thought so, but I didn't know
10:39:35 <matt_estes> Its not by my standards.
10:39:57 <jeffwheeler> Perhaps for SQLite.
10:40:10 <chrisdone> (you're not out of line; input is welcome on IRC--especially in #haskell)
10:40:47 <matt_estes> (well, I also don't _technically_ know anything about irc commands or whether I should be doing something like typing "chrisdone:" at the beginning to not confused people)
10:41:08 <jrh> I went to school with a matt estes.
10:41:12 <jeffwheeler> It's sometimes good to do that if there are multiple conversations going on.
10:41:36 <chrisdone> matt_estes: typically you prepend their nick if other people are talking at the same time
10:41:45 <matt_estes> jrh: I went to school in Tennessee.
10:41:46 <EvilTerran> matt_estes, it's pretty common when you're addressing someone specific to prepend their nick
10:41:48 <jrh> and best not to alias over someone else's nick, or similar to, as it gets confusing
10:41:59 <jrh> matt, I went to school in Arkansas
10:41:59 <EvilTerran> followed by a comma or colon, generally
10:42:25 <mc__>  your client will probably autocomplete nicks if you write the beginning of them and hit tab, if not your client sucks
10:42:30 <chrisdone> EvilTerran: I like how both of us use "prepend" rather than "prefix", is it because we're used to "append"?
10:42:31 <jrh> I meant junior high/high school, actually...  suppose I could have been more explicit.
10:42:40 <EvilTerran> some people seem to write "<matt_estes> stuff like this" instead of "matt_estes: stuff like this", but don't do that, it's confusing
10:42:52 <EvilTerran> because it looks like you're quoting them
10:42:54 <matt_estes> cool, well I will try to behave then :)
10:43:11 <jrh> anyway, I had a question for the crowd.  I have a pattern that I'm running into that I'm wondering if there's a better way of doing
10:43:11 <matt_estes> jrh: I went to college and everything in TN.
10:43:21 <EvilTerran> chrisdone, well, prefix is a noun describing a sequence fragment, while prepend is a verb
10:43:29 <EvilTerran> that's how i see it, anyway
10:43:56 <jrh> In my GLUT/GL visualization work, I keep having to create a ProgramState record from scratch with a whole lot of "global" variables in it
10:43:57 <EvilTerran> i guess you *could* use "prefix" as a verb, but i prefer not to
10:44:03 <matt_estes> chrisdone: regarding databases, I actually have been implementing my own, that's far less imperative than SQLite. Solves the locking problem.
10:44:17 <chrisdone> EvilTerran: I'd agree, though I'd doubt everyone else is strict about prefix as a verb. natlangs, eh?
10:44:21 <mc__> EvilTerran: I read prefix as a verb all the time
10:44:26 <jrh> and then assigning that to an IORef that I curry into the event handler and render callbacks.
10:44:34 <chrisdone> matt_estes: does it work in haskell?
10:44:41 <lispy> This prefix no verb.
10:44:55 <matt_estes> chrisdone: alas, no, its written in Java(am I going to kicked out now :) ).
10:45:01 <EvilTerran> mc__, i have no trouble *reading* it as a verb, i just don't *use* it as a verb myself as a matter of course
10:45:02 <jeffwheeler> Anybody used Erlang's database stuff? (I haven't used it, but) I wonder how well something like that could be implemented in Haskell.
10:45:16 <matt_estes> chrisdone: http://www.metanotion.net/software/iolib/api/net/metanotion/io/appenddb/AppendBlockIO.html
10:45:17 <lambdabot> Title: AppendBlockIO, http://tinyurl.com/5cno3n
10:45:30 <jrh> That seems really ugly and unfunctional, but render and all other GL callbacks require that the "function" they call back is an IO ()
10:45:35 * EvilTerran is definitely interested in the possibility of some non-SQL-based database interfaces
10:45:35 <mc__> EvilTerran: Why do you dislike it?
10:45:56 <matt_estes> chrisdone: Its sorta like the "write-ahead-log" only. Basically, everything gets dumped back to back into the file, and a B-tree indexes the latest version of the block.
10:45:57 <EvilTerran> mc__, i don't particularly. i don't think that hard about which word i'm using where when i'm in mid-sentence
10:46:12 <EvilTerran> mc__, it just falls out that way when i have the choice between saying "prefix" and saying "prepend"
10:46:36 <vixey> why is opengl in IO?
10:46:38 <chrisdone> bd_: anyway, that sounds like a good plan for sqlite. though I intended for my web library to be DB agnostic, at least to SQL-kinds, using HDBC. I wonder if the "one OS thread" method would be satisfactory for all of those. this is tiresome
10:46:42 <vixey> and not GL
10:46:42 <vixey> ?
10:46:44 <vixey> or GLT
10:46:49 <matt_estes> chrisdone: I guess the main thing is that the idea is very much non-mutable-state. An in-memory cache lazily dumps blocks, so 10 changes don't equal 10 writes to the file.
10:46:53 <mc__> EvilTerran: oh okay, I thought there might be some religion behind it :)
10:46:57 <chrisdone> vixey: what would be in GL?
10:47:11 <jrh> because that's the way sven wrote it?
10:47:25 <chrisdone> jrh: banal comment
10:47:31 <matt_estes> chrisdone: So I guess what I was going to suggest was some ideas like that might be useful to you guys, again, I don't know what's going on :)
10:47:37 <jrh> my bad, chrisdone
10:48:13 <matt_estes> chrisdone: since lazy and immutable seemed to be a preferable approach to, say, a Haskell program.
10:48:17 <chrisdone> matt_estes: well, are you producing your own query language?
10:48:39 <matt_estes> chrisdone: That's the intent, again, I wasn't trying to suggest you guys use my code, I'm not that arrogant :)
10:48:42 <jrh> I honestly don't know.  Cairo has a Render monad, which I rather like, but HOpenGL functions are all * -> IO as are GLUT functions
10:49:08 <jeffwheeler> GLUT?
10:49:22 <jrh> Graphics.UI.GLUT
10:49:30 <chrisdone> hey gwern
10:49:31 <EvilTerran> (Open)GL User's Toolkit
10:49:32 <EvilTerran> or something
10:49:34 <matt_estes> chrisdone: the transactions are handled in a completely non-blocking way, though, except for commit's, but that's only commits.
10:49:49 <jrh> EvilTerran, that's correct
10:49:53 <lispy> jrh: I would very much lke to make a purely functional rendering library on top of opengl, but I haven't yet had the time for that project
10:50:04 <lispy> jrh: I would probably base it on scene graphs
10:50:21 <mc__> lispy: can a rendering engine be purely functional at all?
10:50:37 <bd_> chrisdone: I would think it would vary by DB engine
10:50:58 <bd_> chrisdone: eg, most other DBs are based on a network protocol, and probably wouldn't care as much. (then again they might)
10:50:59 <chrisdone> mc__: yeah, producing what is to be rendered could be
10:51:01 <jrh> lispy, an intelligent idea.  I'm more concerned with infoviz/visual analytics, so I'd base mine more along the lines of Processing (http://processing.org)
10:51:08 <lispy> mc__: you could, for example, use combinators to construct a graph representing each frame then feed that graph to something SceneGraph -> IO ()
10:51:23 <mc__> I see
10:51:38 <chrisdone> bd_: quite annoying
10:51:48 <lispy> mc__: Conal Eliot has papers about other approaches
10:51:52 <lispy> or is it Elliot
10:52:28 <EvilTerran> Elliott
10:52:32 <EvilTerran> according to whowas
10:52:40 <EvilTerran> /whowas conal
10:52:45 <EvilTerran> * [conal] (n=user@d5153048F.access.telenet.be): Conal Elliott
10:53:04 <matt_estes> chrisdone: I guess what I was trying to help suggest is that transactions and such can be handled in a non-blocking, thread-safe way(that doesn't even require the same thread to hang on to something) with STM, just that SQLite wouldn't work for that, and I have ran into some threading issues really bogging down my apps.
10:53:51 <lispy> mc__: it's good to have an OpenGL binding, but for us haskellers it makes much more sense to be able to separate our concerns
10:53:56 <matt_estes> chrisdone: and also, I guess, write-ahead-logging is slow too :).
10:54:07 <lispy> eg., separate the IO from the scene construction
10:54:32 <mc__> lispy: I understand that, OpenGL does not really integrate with most programming languages nowadays
10:54:42 <chrisdone> lispy: I made a simple LOGO-like program like that
10:54:49 <lispy> chrisdone: awesome
10:54:56 <jrh> and actually, the OpenGL framework for Haskell is probably the best framework out there
10:55:03 <jrh> as good or better than C's
10:55:13 <mc__> what makes it so good?
10:55:16 <lispy> What I didn't like about HOpenGL was that too many things were changed without adequate documentation
10:55:35 <lispy> So if you know OpenGL there is still a learning curve to HOpenGL and the documentation isn't often there
10:55:36 <chrisdone> matt_estes: sorry, I'm not really competent with database implementation so I don't have much to input
10:56:03 <matt_estes> chrisdone: I'm not either, I had to do one for a cellphone app, and got fired over it :)
10:56:14 <lispy> Also, due to the types used you usually end up telling the type checker what tytes you're working with instead of letting the type inference do its job :(
10:56:18 <chrisdone> matt_estes: oh dear :)
10:56:35 <jrh> mc_: little things, mostly.  Strongly typed enums, the ability to pass thunks to the renderer, integration with Haskell array syntax for vertex arrays etc, and the fact that unlike all the other implementations out there, it's complete up to the 2.1 spec
10:56:41 <jrh> including GLSL
10:57:06 <matt_estes> chrisdone: Basically, we were doing something in pure Java(no JNI), so SQLite was out, and so I borrowed some ideas, but the phone wouldn't honor fsync calls(to ensure data was on the disk) so transactions and everything went totally wrong.
10:57:19 <vixey> jrh: what array syntax?
10:57:47 <matt_estes> chrisdone: I later realized that by appending only to the end of the file, and indexing the latest version just for efficiency, you wouldn't have to trust the file system, since all writes to the file were never overwritten.
10:58:23 <matt_estes> chrisdone: And if the file gets "too big" you just do a copying garbage collector over the file.
10:58:34 <jrh> vixey: I say "syntax", but I meant interface -- having a bad day at the office, and my brain is fuzzed
10:58:40 <jrh> MArray / IArray
10:59:24 <vixey> oh I see what you mean now
10:59:29 <matt_estes> chrisdone: Obviously, I need a query language to make this useful to anyone who doesn't like playing with raw bytes, but its very fast because unlike write-ahead-logging, you don't write data to the disk twice.
11:00:07 <vixey> jrh, at least the day will end eventually
11:00:18 <jrh> vixey: thanks, thank goodness.
11:00:19 <bd_> matt_estes: so, why did you get fired for it? >.>
11:00:29 <bd_> seems like a reasonable approach to me...
11:00:58 <jrh> The other reason it makes sense for OpenGL to be in the IO monad is that most of OpenGL is "immediate mode" programming.  Stuff is supposed to, per spec, be sent to the video card as soon as it's called
11:01:23 <matt_estes> bd_: Well, the cell phone app got put in production too fast, so it started failing in the field, and the old system had been decommissioned, and so they went from ancient proprietary PDA, to cell phone, to pen and paper.
11:01:36 <bd_> ouch :/
11:01:53 <matt_estes> bd_: And the guy at the client who had wanted the system decided the problem was me, and refused to sign off on my timesheets.
11:02:20 <matt_estes> bd_: I have recently heard he decided the problem might be the cellphone. Oh well :)
11:03:17 <matt_estes> bd_: The reason we needed a database instead of just J2ME or web-based only was because we had to put records for about 40,000 customers on the phone, and it was guaranteed to not always have a signal at customer sites(this was a rural power company).
11:03:52 <matt_estes> bd_: but since the client's wouldn't pay for my time, and it was a pure contracting gig = fired.
11:04:45 <chrisdone> matt_estes: you should've hacked their mainframe and sent a pacman virus
11:05:06 <mc__> pacman virus?
11:05:34 <matt_estes> chrisdone: Well, I also wrote the software that translates their meter reading system data into the billing system. In theory, I could fix my power bill real easy.
11:06:10 <matt_estes> chrisdone: The problem with that one is that meters give a cumulative number, not just a difference, each month, the number you report for your bill would further away from the number on the meter :)
11:06:15 <chrisdone> mc__: pops up on your screen and says "here are your files. om nom nom"
11:06:26 <mc__> chnice one
11:07:27 <matt_estes> chrisdone: Eh, if you really wanted to have fun, just use a rifle to shoot a hole in the coolant for transformers at a TVA substation. The things you learn when talking with power company engineers :)
11:08:26 <hackage> Uploaded to hackage: parameterized-data 0.1.2
11:08:26 <hackage> Uploaded to hackage: type-level 0.2.1
11:09:51 <matt_estes> chrisdone: Sorry for sidetracking the sqlite discussion. :(
11:10:53 <jrh> Still wondering if there's a better way than creating an IORef ProgramState...
11:11:02 <chrisdone> jrh: for what?
11:11:15 <tibbe> .
11:11:20 <chrisdone> jrh: isn't that what yi does?
11:11:21 <jrh> for handling the things that need to be saved between rendering steps
11:11:26 <chrisdone> oh
11:11:48 <tibbe> I need to represent a C const void * in Haskell using FFI. What's the correct type?
11:12:08 <lispy> Ptr () is commonly used, iirc
11:12:11 <jrh> possibly resorting to Template Haskell to prettify the ugly code...  v
11:12:47 <jrh> tibbe, to be type safe, create an empty type with "data Foo" (or data Foo=Foo) and then use Ptr Foo
11:13:14 <jrh> That way you can't accidentally pass a void * of one type to a function expecting a different void *
11:13:16 <tibbe> jrh: hmm, ok, I'm trying to wrap mlock
11:15:46 <jamii> Does anyone know how to get the output of 'ghc -cpp'. I want to see what these macros expand to
11:15:56 <jrh> ah...  so you want to lock an arbitrary Haskell data structure into memory?
11:16:23 <jrh> or rather an arbitrary Haskell data structure that's already in memory...
11:17:33 <Baughn> jamii: Eh? You should be able to just run cpp over the code by itself
11:17:57 <Baughn> tibbe: What do you intend to lock in memory?
11:18:18 <tibbe> Baughn: a file
11:18:23 <Baughn> tibbe: You should be aware that ghc (and probably the others), using a copying garbage collector, won't have fixed addresses for the files..
11:18:27 <Baughn> Er, the objects
11:18:36 <jrh> Baughn, that was my thought
11:18:39 <Baughn> tibbe: You can't just mmap it?
11:18:40 <tibbe> hmm
11:18:47 <Deewiant> Baughn: running cpp yourself isn't quite the same as you don't know what #defines are in effect?
11:18:54 <tibbe> Baughn: yes, but mlock forces it to stay in memory so I want to do both
11:18:56 <jamii> No - cpp by itself chokes on things like apostrophes in haddock comments. ghc doesnt seem to call it over the whole file
11:19:06 <Baughn> Deewiant: True, but I don't know that ghc adds any
11:19:22 <jamii> ghc adds things like __HASKELL_98__
11:19:30 <Deewiant> it adds plenty
11:19:30 <fons> ping dons
11:19:47 <jamii> also ghc seems to do some parsing *before* calling cpp. like stripping comments
11:19:52 <Baughn> tibbe: You could use MAP_LOCK if you're on linux, or just pass the area to mlock after mapping it
11:20:01 <fons> has anyone had any luck using code coverage (-fhpc) with more than one module?
11:20:25 <tibbe> Baughn: right, I was planning on doing the latter
11:20:30 <jamii> fons: If you have them all in the same source tree then 'ghc --make -fhpc' should work
11:20:36 <tusho> jamii: well duh
11:20:39 <tusho> otherwise it could mess up big time
11:20:47 <fons> I'm trying to see how much the unit tests I made for a library (with more than 50 modules)
11:20:58 <fons> jamii: what version of ghc are you using?
11:21:11 <Pete_I> i'm trying to do print the commandline arguments, but it's going horribly http://hpaste.org/9384 could somebody take a look at it or me please?
11:21:16 <jamii> tusho: exactly. but I cant find a way to get the output of the cpp stage
11:21:19 <jamii> fons: 6.8.3
11:21:56 <jrh> well, then tibbe, the appropriate type signature should be Ptr a -> Int -> IO Int (or define an error enum that encapsulates the int)
11:22:02 <Deewiant> Pete_I: your indentation is wrong, the putStrLn should be at the same level as the ( on the previous line
11:22:03 <fons> I'm using ghc 6.8.2 and I'm getting an error (unkown symbol _hs_hpc_module)
11:22:06 <jrh> I would think, anyway, somone can correct me
11:22:18 <Pete_I> ....indentation matters that much?
11:22:27 <tibbe> jrh: are Int equivalent to CInt?
11:22:28 <Baughn> Pete_I: Also, the question marks I'm getting between < and getArgs scare me
11:22:38 <Baughn> Pete_I: Indentation matters if you don't use braces. You're not using braces, so..
11:22:46 <Deewiant> Pete_I: if you prefer to not use indentation, use braces and semicolons
11:22:51 <tibbe> jrh: ditto CSize
11:22:51 <Baughn> tibbe: No, they're different types
11:22:51 <Pete_I> those aren't there in the actual code. probably some funny with the clipboard
11:23:16 <tibbe> Baughn: right, so I'll use the C types in my wrapper and convert at the call size
11:23:20 <jrh> No...  it's just generally better to do those conversions in the FFI code module rather than littering the rest of your haskell code with C* types
11:23:26 <Pete_I> i've not seen semicolons and braces used yet
11:23:28 <Deewiant> Pete_I: so then it would be "do { ... getArgs; putStrLn args }"
11:23:29 <jrh> write a function that calls the mlock function, in other words
11:23:38 <Baughn> tibbe: Let's see.. on my system, Int has a range of 2^64, CInt of 2^32 and CSize of 2^64 again
11:23:43 <Pete_I> ah, that'll work great. thanks
11:23:49 <jrh> Gotta go...  I'm sure someone will pick up my slack.  Sorry, tibbe
11:23:50 <tibbe> Baughn: right
11:23:54 <jamii> fons: Just tried it on my current dir and it works ok. I dont know what could be causing your problem. Maybe someone else knows?
11:23:59 <tibbe> jrh: thanks :)
11:24:09 <Baughn> tibbe: But Int is only guaranteed to be 2^29 bits or more, so..
11:24:12 <Baughn> Use Integer if you're not sue
11:24:14 <Baughn> *sure
11:24:23 <tibbe> Baughn: right
11:24:26 <jamii> fons: Be sure to use '--make'
11:24:29 <fons> thanks jamii
11:24:40 <tibbe> Baughn: I think I'll try to stay true to the C interface in my wrapper and make the decision elsewhere
11:24:44 <Cale> Basically, use Integer unless you're having performance problems. Int is usually a premature optimisation.
11:24:56 * Baughn pokes take
11:25:28 <Cale> Oh, I suppose if you're interfacing with C code, you might want to use a plain Int or CInt.
11:26:15 <Baughn> Cale: Seen might take a bit longer. I'm adding in sqlite at a more central spot, so multiple plugins can use it
11:26:21 <Cale> ah, cool
11:27:04 <Baughn> Hugs.Base> maxBound::Int
11:27:08 <Baughn> 2147483647
11:27:25 <Pete_I> now it complains "args" and "<" are out of scope :/
11:27:36 <Baughn> tibbe: That's on the same system. CInt is still 32 bits, CSize is 64.. I don't think you want to take any chances here.
11:27:44 <Baughn> > 2^31-1
11:27:45 <lambdabot>  2147483647
11:27:56 <fons> jamii: hold on, I think I know what the problem is
11:28:19 <Baughn> Pete_I: You've got some weird characters in your code, yes. Try to stick to ascii.
11:28:19 <Deewiant> Pete_I: which probably has to do with those question marks in the paste. It should be "<-", maybe you've got "<–" or something instead
11:28:27 <fons> Has anyone tried to get code coverage statistics (-fhpc) of a program using template haskell?
11:30:41 <fons> there you go http://hackage.haskell.org/trac/ghc/ticket/1907
11:30:42 <lambdabot> Title: #1907 (HPC and Template Haskell don't mix) - GHC - Trac
11:30:49 <fons> I guess I'll just have to wait
11:30:53 <fons> :(
11:31:14 <Deewiant> fons: note it's "worksforme" since 6.9
11:32:27 <fons> Deewiant: yes, but I wanted to get the statistics automatically in a server where (for various reasons) I cannot install HEAD
11:32:29 <Pete_I> that's pretty wierd. wonder how that got there. works now though. thanks
11:32:39 <fons> but thanks for the remark anyway :)
11:33:10 <Deewiant> fons: I had to make sure :-)
11:35:49 <chrisdone> @src Applicative
11:35:49 <lambdabot> class Functor f => Applicative f where
11:35:49 <lambdabot>     pure  :: a -> f a
11:35:49 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:38:40 <siponen> Hmm... Is it Ok to just write "specialization" functions for a existential datatype if I later found out that I need to touch the specific instances too... Or should I go back to the deep caverns to re-think?
11:40:04 <chrisdone> could you define class Functor f where fmap = f (a -> b) -> f a -> f b, class Functor f => Applicative f where pure a -> f a, class Applicative m => Monad m where (>>=) :: m a -> (a -> m b) -> m b?
11:41:02 <chrisdone> any Monad would then also implement Applicative and Functor, right?
11:41:38 <Cale> chrisdone: yeah
11:41:51 <chrisdone> cool
11:41:58 <Cale> chrisdone: However, pure and fmap are not enough to define Applicative
11:42:25 <chrisdone> Cale: oh
11:42:44 <chrisdone> Cale: what else is needed?
11:43:16 <Cale> :t (<*>)
11:43:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:43:22 <chrisdone> @src <*>
11:43:22 <lambdabot> Source not found. Just try something else.
11:43:25 <chrisdone> @src (<*>)
11:43:25 <lambdabot> Source not found. I am sorry.
11:43:26 <fons> Does anyone know of a Haskell XML library working with Schemas and not DTD?
11:43:27 <Baughn> Cale: Do you think it'd make sense to rnf the state data when a module invocation exits?
11:43:29 <Cale> It's a class method :)
11:43:59 <Cale> Baughn: Wouldn't writing it to disk effectively do that as well?
11:44:11 <thetallguy> fons: not really
11:44:29 <chrisdone> cale: could you explain why fmap couldn't be used in place of <$> in my above definition?
11:44:52 <Baughn> Cale: If you're going to use the sqlite db, you don't have any other choice - there still won't be a way to keep data in memory between calls other than the module state, and generally you shouldn't want to
11:44:55 <chrisdone> cale: don't they do the same things?
11:45:08 <thetallguy> fons: there was one library that did some conversion, from DTD to Schema, I think, but there was very little else
11:45:11 <Cale> chrisdone: fmap is the same as <$>, but not the same as <*>
11:45:11 <Baughn> Cale: ..actually, I'm toying with marking it deprecated, and just removing it outright ASAP
11:46:01 <fons> thetallguy: too bad, I wanted to add some schema-based XML validation the the unit tests of my Haskell-embdedded compiler :(
11:46:03 <chrisdone> Cale: oh :(
11:46:15 <fons> embedded*
11:47:22 <chrisdone> Cale: so add <*> to the Applicative and then it is correct
11:48:13 <chrisdone> Cale: I suppose one could implement pure with fmap
11:48:28 <Cale> chrisdone: nope, that's separate too
11:48:30 <chrisdone> Cale: hmm, no
11:48:33 <chrisdone> Cale: yeah
11:49:42 <thetallguy> fons: yeah, I now.  I thought about writing something to fil the gap...
11:49:56 <chrisdone> Cale: did Monad exist before Functor? is that why Monad isn't a subclass of Functor?
11:50:06 <thetallguy> fons: but in the end I decided that XML sucked and I didn't want to get into it.
11:50:23 <Cale> chrisdone: no
11:50:53 <Baughn> Why don't we have an instance Monad a => Functor a, again?
11:50:56 <Cale> chrisdone: There's no good reason, other than that some people are lazy and didn't want to have to write a Functor instance.
11:51:10 <Baughn> I mean, isn't it /always/ fmap = liftM?
11:51:10 <Cale> Baughn: You mean  Functor a => Monad a?
11:51:13 <Trinithis> Monad fail....
11:51:26 <Trinithis> yes
11:51:39 <Trinithis> fmap = liftM
11:51:41 <Cale> class Functor m => Monad m where ...  would be reasonable
11:51:45 <Cale> Baughn: yeah
11:51:52 <chrisdone> Cale: it seems like Applicative m => Monad M would make sense, right? but one day Monad might be generalised again to be a subclass of something else..
11:51:53 <Baughn> Cale: I thought I meant what I said
11:52:19 <Baughn> instance Monad m => Functor m where fmap = liftM <-- Shouldn't this make any and all monads functors, without having to instance?
11:52:33 <chrisdone> that would make all functors a monad
11:53:05 <Baughn> ..right. How would you do what I suggested, then?
11:53:19 <Cale> Baughn: That instance would apply to everything.
11:53:34 <Baughn> Cale: I don't want it to apply to everything, just to monads. ;_;
11:53:38 <Cale> Baughn: well, it would overlap everything
11:54:34 <Cale> The problem is that you can never tell if a future module would end up defining an instance of Monad for a given type constructor.
11:55:14 <Cale> So when selecting instances, the instance selection is done based on the structure of the type alone, and not what classes it belongs to. Those restrictions are applied only after the instance is selected.
11:56:10 <Baughn> Hmm. And there's no way to make ghc apply them /before/ selection?
11:58:07 <opqdonut> well
11:58:16 <opqdonut> there is no real consensus on how the class system should be improved
11:58:32 <opqdonut> but there are some things like selectable instances are being considered
11:59:49 <Cale> Baughn: Well, you can allow overlapping instances...
12:01:41 <Baughn> Cale: This does not sit well with me. Oh well.
12:02:32 <chrisdone> I find it interesting that I often do things with types and instances and get a compiler error saying "NO. BAD. ...or *cough* enable -XThingie"
12:06:47 <Twey> chrisdone: *chuckle*
12:06:54 * byorgey waves from Philadelphia!
12:06:56 * byorgey hands out lambda-cheesesteaks
12:07:02 <lispy> hey byorgey
12:07:10 <byorgey> hey lispy
12:07:28 <lispy> byorgey: why did you move?  are you professor now or something?
12:07:41 <byorgey> lispy: I'm starting a PhD at U Penn
12:07:49 <lispy> byorgey: congrats
12:07:55 <byorgey> thanks
12:08:26 <hackage> Uploaded to hackage: hoogle 4.0.0.1
12:08:44 <nominolo> hackage: info
12:08:47 <chrisdone> :k Monad
12:09:07 <chrisdone> I wish I had Types and Programming Languages
12:09:09 <byorgey> @kind Monad
12:09:10 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:09:16 <nominolo> * -> *
12:09:24 <lispy> lambbot is severly broken of late
12:09:38 <chrisdone> I didn't realise type classes had a kind
12:09:43 <nominolo> @users
12:09:44 <lambdabot> Maximum users seen in #haskell: 477, currently: 474 (99.4%), active: 18 (3.8%)
12:09:54 <nominolo> -2 bots
12:09:55 * jeffwheeler really wants to use the nick lambdabt, just to screw with tab-triggers :P
12:10:25 <chrisdone> LambDaKewlSheep237
12:10:40 <chrisdone> nominolo: which is the second?
12:10:45 <byorgey> chrisdone: if type class Foo has kind k, it means that anything which is an instance of Foo must have kind k
12:10:46 <nominolo> hackage
12:10:58 <medfly> jeffwheeler, wouldnt lambdabot be ahead anyway
12:11:06 <medfly> jeffwheeler, first option of tab selection... a-z
12:11:15 <chrisdone> byorgey: I see
12:11:26 <jeffwheeler> medfly: depends on the client -- many only go up to where the difference is
12:11:29 <chrisdone> :k Just
12:11:37 <nominolo> *
12:11:41 <jeffwheeler> medfly: but you're right; it shoudl be lambbabot ;)
12:11:47 <chrisdone> nominolo: isn't it * -> *?
12:11:52 <nominolo> no, wait
12:11:56 <nominolo> Just is not a type
12:12:01 <nominolo> Maybe :: * -> *
12:12:02 <chrisdone> whoops
12:12:04 <chrisdone> i meant Maybe
12:12:08 <chrisdone> d'oh
12:12:22 <nominolo> think this way:  * means it's a type
12:12:34 <nominolo> * -> * means, requires a type parameter to become a type
12:12:35 <chrisdone> Maybe takes a type and produces another type?
12:12:41 <nominolo> exactly
12:13:03 <nominolo> only types of kind * can have values
12:13:18 <lispy> what is the difference between data Foo = forall a. Foo (a -> a), and data Foo = Foo (forall a. a -> a) ?
12:13:39 <nominolo> lispy: is there one?
12:13:55 <lispy> nominolo: I get different type errors for each :)
12:14:03 <Cale> lispy: In the first, for a given value of type Foo, there's *some* a for which it holds a function of type a -> a
12:14:20 <Cale> lispy: in the second, it holds a *polymorphic* function a -> a
12:14:38 <Cale> The first is equivalent to  data Foo = Foo (exists a. a -> a)
12:14:44 <lispy> Cale: I think I want the first one then
12:14:55 <byorgey> probably
12:15:03 <tibbe> where can I find the ghc haddocks?
12:15:18 <byorgey> functions of type  forall a. a -> a are not very useful in general =)
12:15:20 <chrisdone> @docs GHC
12:15:20 <lambdabot> GHC not available
12:15:38 <nominolo> tibbe: http://code.haskell.org/~nominolo/html/ghc/ for now
12:15:38 <lambdabot> Title: ghc-6.9: XXX
12:15:46 <Cale> lispy: It's a useless type there, since you've forgotten what type a you had.
12:15:55 <Cale> lispy: So the function can never be applied to anything.
12:15:57 <tibbe> nominolo: ok cool thanks
12:15:58 <drigz> does than link need an NSFW? :p
12:15:58 <chrisdone> is not forall a. a -> a == a -> a?
12:16:02 <nominolo> tibbe: this is only my branch, though
12:16:13 <tibbe> nominolo: I need to reach into the handle data type
12:16:14 <chrisdone> :t null
12:16:15 <lambdabot> forall a. [a] -> Bool
12:16:15 <Cale> chrisdone: yes, in Haskell, when you leave off the quantifier, forall is implied.
12:16:22 <lispy> Cale: okay, then I think I need the forall a. Foo ... version
12:16:28 <nominolo> tibbe: oh, isn't that libraries?
12:17:21 <tibbe> nominolo: couldn't find it in the standard libraries, I'm doing some FFI and need a file descriptor for pread
12:17:48 <tibbe> nominolo: so I guess it's internal GHC APIs
12:17:57 <tibbe> nominolo: GHC.Handle or something
12:18:12 <nominolo> tibbe: could be, yes
12:18:14 <chrisdone> :t id :: a -> a
12:18:15 <lambdabot> forall a. a -> a
12:18:22 <chrisdone> :t id :: (->) a a
12:18:23 <lambdabot> forall a. a -> a
12:18:27 <chrisdone> cool
12:18:38 <nominolo> tibbe: i wouldn't expect to find any documentation, though  ;)
12:19:14 <tibbe> nominolo: :p
12:19:24 <chrisdone> it's confusing that (->) is an instance of Arrow because I've always called (->) an arrow
12:19:38 <chrisdone> or is it ((->) e)
12:19:55 <nominolo> is there any other function than 'id' of type forall a. a -> a ?  (ignoring \_ -> undefined)
12:20:05 <chrisdone> :t fix
12:20:06 <lambdabot> forall a. (a -> a) -> a
12:20:14 <chrisdone> heh, ignore that
12:20:22 <drigz> @hoogle a -> a
12:20:22 <lambdabot> Prelude.id :: a -> a
12:20:22 <lambdabot> Data.Function.id :: a -> a
12:20:22 <lambdabot> GHC.Exts.breakpoint :: a -> a
12:20:23 <nominolo> :t fix id
12:20:24 <lambdabot> forall a. a
12:20:39 <lispy> Cale: so I'm using data Foo x y = forall a b. Foo (Bar a b -> Baz x y a b), and I have, apply_foo :: Foo x y -> (Bar a b -> Baz x y a b); apply_foo (Foo m) = m, this does not type check.  Any advice?
12:20:56 <chrisdone> :t first id
12:20:57 <lambdabot> forall a d. (a, d) -> (a, d)
12:21:19 <chrisdone> :t first
12:21:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:21:26 <lispy> Cale: it does not type check because of trying to match rigid and polymorphic types
12:21:39 <chrisdone> how come the type of "first id" doesn't show it as an Arrow instance?
12:22:01 <Trinithis> It limits it to a function
12:22:08 <nominolo> chrisdone: because it's instantiated
12:22:12 <chrisdone> like, "Arrow a => a (b,c) -> (b,c)"
12:22:19 <chrisdone> ah, I see
12:22:30 <nominolo> using Arrow (->)
12:22:45 <chrisdone> s/->// on my above message, of course
12:23:33 <Cale> lispy: You probably want the forall inside.
12:23:59 <chrisdone> the type of first is very pretty
12:24:29 <nominolo> chrisdone: well...
12:24:39 <nominolo> chrisdone: it's not very newbie-friendly
12:25:24 <lispy> Cale: hmm...I removed the type sig of apply_foo, to see if ghc could figure it out, and it doesn't type check regardless of where I put the forall in the data declaration
12:25:42 <lispy> Cale: I'm getting stuff about inferred types being less polymorphic than expected
12:26:05 <lispy> Cale: Usually, I solve this problem with a data type that can hold the types that are less polymorphic than expected
12:26:16 <chrisdone> nominolo: I didn't get it until I realised (->) is like an infix type... constructor, or something
12:26:26 <chrisdone> :k (->)
12:26:27 <lambdabot> ?? -> ? -> *
12:26:31 <nominolo> chrisdone: it is, yes.
12:26:56 <Cale> lispy: Well... let's see
12:26:58 <chrisdone> how come question marks are used there and then a *?
12:27:11 <Cale> lispy: Maybe it's best if you explain what it is that you're trying to represent.
12:27:12 <nominolo> chrisdone: you can have custom infix type constructors if they start with :
12:27:22 <Cale> lispy: and then we can work out an appropriate type...
12:27:25 <nominolo> chrisdone: i think it's due to GHC internals
12:27:28 <chrisdone> nominolo: example?
12:27:44 <lispy> Cale: we have "Matchers" that select patches...it allows users to use an expression language that we parse and transform into functons
12:27:50 <nominolo> chrisdone: data Pair key val = key := val
12:27:54 <lispy> Cale: and patches have two special phantom types
12:28:09 <lispy> Cale: a Match x y can only match a Patch x y
12:28:11 <chrisdone> nominolo: very pretty
12:28:16 <swiert> @seen bringert
12:28:17 <lambdabot> I haven't seen bringert.
12:28:22 <nominolo> or even: data key := val = key := val
12:28:55 <lispy> Cale: But, then I realized to use this is practice, the matcher function needs to be more like, Matcher x y -> Patch a b -> Bool
12:29:14 <nominolo> chrisdone: of course it requires sane programmers to use it appropriately :)
12:29:35 <Cale> lispy: But in that case, you don't know that the Matcher applies to the Patch in question at all?
12:29:51 <lispy> Cale: so I created a witness type, EqCheck2 x y a b, with constructors IsEq2 :: EqCheck2 x y x y and NotEq2 :: EqCheck2 x y a b, make sense so far?
12:29:54 <chrisdone> nominolo: but that's different to (->), right? (->) is a type level constructor, := is a value level constructor?
12:30:01 <Cale> ahh...
12:30:13 <Cale> You're trying to represent type equality constraints?
12:30:29 <lispy> Cale: so I updated the matcher function type to Matcher x y -> Patch a b -> EqCheck2 x y a b
12:30:30 <chrisdone> nominolo: oh, Data key := val = ... is type level... I see... crazy
12:30:35 <nominolo> chrisdone: my second example is a type-level constructor
12:30:37 <lispy> Cale: is that what this is called?
12:30:39 <Cale> lispy: If you use 6.8, I think... hmm or is that 6.10?
12:30:45 <nominolo> chrisdone: but, yes, functions are rather special
12:31:30 <chrisdone> hm
12:31:40 <lispy> Cale: so now the data structor to store a Matcher is like data Match x y = forall a b. MATCH (Patch a b -> EqCheck2 x y a b)
12:31:46 <chrisdone> :t null :: ([]) a -> Bool
12:31:47 <lambdabot> forall a. [a] -> Bool
12:32:06 <chrisdone> nominolo: it would be funky to have {a} for "set of a"
12:32:13 <lispy> Cale: there are some other fields that are irrelavent in this discussion, like a name
12:32:59 <lispy> Cale: I'm not sure if I want to say that there exists some a b such that the function can be applied or if I want a polymorphic function...Thinking about it now, I guess the latter is more appropriate
12:33:01 <dmhouse> chrisdone: might conflict with do/let-notation
12:33:15 <chrisdone> nominolo: are there any extensions for this kind of surrounding construction?
12:33:16 <Cale> lispy: Wait, I'm not 100% sure what the need is for this EqCheck stuff...
12:33:17 <dmhouse> But I guess it needn't. If preceeded by "do" or "let", braces mean something else.
12:34:01 <Cale> (Might just be because I'm not Oleg)
12:34:05 <lispy> Cale: yes, I'm increasingly of the mind that it's a mistake for Matcher to carry the phantom types
12:34:23 <nominolo> chrisdone: not that i know of.  it's also rather tricky to properly integrate this into the rest of the syntax.  but Agda allows such things
12:34:26 <Cale> lispy: Why can it not be ensured that matchers are only applied to patches of the right type?
12:34:36 <chrisdone> nominolo: interesting
12:34:48 <lispy> Cale: because, one way to fix this might be Matcher x y -> Sealed2 Patch -> Bool, but then why even have the phantom tyes there on the matcher at this point
12:35:00 <Cale> lispy: Is it possible that you're trying to represent dynamic data about the types of things in the static type system?
12:35:38 <lispy> Cale: Sort of.  once created the phantoms of a patch never change, but we do read them from the disk and generate unique phantoms at that time
12:36:08 <Cale> Read them from disk?
12:36:12 <Cale> At compile time?
12:36:13 <nominolo> chrisdone: Agda is dependently typed; that's a whole new level of crazy :)
12:36:27 <chrisdone> nominolo: I don't know dependant types
12:36:42 <Cale> (As far as I'm concerned, types are compile time phenomena only :)
12:36:44 <nominolo> chrisdone: you can do much nicer type-level programming, but at the expense of having to prove more things
12:37:06 <chrisdone> nominolo: like what?
12:37:15 <nominolo> chrisdone: i think it's most disrupting that you have to prove termination
12:37:55 <Jedai> chrisdone: You can write a "sorted list" type and then write a "sort" function of type "list -> sorted list"
12:38:00 <Cale> lispy: If it's possible for there to be a runtime failure of the phantom types to match, then they shouldn't be phantom types at all, but instead be data.
12:38:06 <nominolo> chrisdone: but you can have types like Vectors that keep track of its length
12:38:18 <lispy> Cale: I just mean that, we give the phantom types a value at some point.  For use, this happens when the patch is contructed, commonly that happens as the result of a parse.
12:38:22 <chrisdone> odd
12:38:32 <Cale> mm... okay
12:38:44 <lispy> Cale: I just heard back from david, he's of the same mind set as us, that it's a mistake for Matcher to have the phantoms
12:38:51 <lispy> Cale: So, I'll just solve the problem that way :)
12:38:57 <Jedai> chrisdone: Thing is in dependent typing, types can be parametrized by values, not only by types (like type constructor in Haskell or Template in C++)
12:39:27 <nominolo> chrisdone: or you could possibly have an embedded type-system with your embedded DSL
12:39:49 <Jedai> chrisdone: With a dependent type system, you can write really precise type, that express properties about the values you're manipulating
12:39:52 <lispy> Cale: thanks for talking it over wth me though, that helped
12:39:53 <chrisdone> Jedai: like [1]? a list of values 1?
12:40:08 <nominolo> chrisdone: or you could require proofs that your data structure actually implements the monad laws, or monoid laws or associativity, etc.
12:40:28 <chrisdone> nominolo: that sounds cool
12:40:46 <Jedai> chrisdone: You could write a "all equal to (n) list" (with n a parameter), yes
12:41:32 <Jedai> chrisdone: Dependent types are really cool, but difficult to use (because you must prove everything formally, you can't just wave your hand)
12:42:13 <nominolo> Jedai: actually I think you can, in a way
12:42:20 <nominolo> Jedai: at least for testing purposes
12:42:45 <Jedai> nominolo: Depends on the language, but in Coq for exemple you can't.
12:42:52 <nominolo> like in Coq you can just add assertions
12:43:04 <chrisdone> Jedai: do they support type classes?
12:43:09 <nominolo> no
12:43:15 <Jedai> nominolo: Oh, I see what you mean, like hypothesis
12:43:54 <Jedai> I think Agda support something close to type classes, but I'm not sure, nominolo may know better ?
12:43:56 <nominolo> Jedai: yes, it's meant for incremental refinement
12:44:02 <swiert> Coq 8.2 has type classes.
12:44:05 <chrisdone> oh, I was considering an instance of Num for all numbers less than 0 or greater than 7 which would wrap round, like a number system modulo 7
12:44:17 <nominolo> swiert: really? wow
12:44:21 <swiert> http://mattam.org/research/coq/classes.fr.html
12:44:25 <lambdabot> Title: Matthieu Sozeau :: Type classes in Coq
12:44:28 <Jedai> chrisdone: You can write a type of number in an interval if you want
12:44:54 <chrisdone> Jedai: what's an interval?
12:45:14 <seliopou> (0, 1)
12:45:20 <nominolo> "[...] support notational abuse by overloading. That's ample good reason to have them in a proof-assistant like Coq. [..]" - yeah
12:45:51 <Jedai> chrisdone: have you minimal basis in mathematics ?
12:45:55 <nominolo> swiert: do they have full type inference?
12:45:57 <chrisdone> Jedai: no
12:46:18 <swiert> nominolo: pretty much.
12:46:21 <Jedai> chrisdone: I frankly think you can forget dependent type right now then...
12:46:42 <swiert> but things break down once you have things like undecidable instances.
12:46:55 <Jedai> chrisdone: They really require a minimal comprehension of formal system and logic theory as they are now
12:47:57 <chrisdone> Jedai: I didn't mean to imply I would try to use them by listening to you talk about them
12:49:19 <Jedai> chrisdone: No, you don't understand : "dependently typed" languages use too much mathematical concept now, you can't use them without solid basis in logic theory, type theory and formal systems
12:49:40 <nominolo> ugh, big Pi instead of forall looks so ugly
12:50:19 <Jedai> chrisdone: There is a bunch of research in making them more easily usable by normal programmers (or even non-specialized mathematicians, really) but it's not there yet.
12:50:21 <chrisdone> jedai: no, I am not going to try to use them at all. I was merely listening to you talk about them
12:51:01 <Jedai> chrisdone: Oh that's fine then ^^
12:52:02 <lispy> ?hoogle liftM
12:52:03 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:52:03 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:52:03 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:52:09 <nominolo> Jedai: furthermore, the terminology used by the people working with dependently typed languages is scary as well
12:52:37 <Philippa_> yeah, the terminology's the big bit really
12:52:39 <Jedai> chrisdone: I've mainly done a bit of Coq myself, it's kinda fun too, but sometimes you would cry because things that are evident to you are extremly hard to show to the computer
12:52:46 <shukhov> How do you capture stdout from a system call?
12:52:49 <Philippa_> it's the equivalent of Functor instead of Mappable, only much worse
12:53:07 <Philippa_> Jedai: not all dependently typed programming is like Coq
12:53:15 <nominolo> @hoogle runProcess
12:53:15 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
12:53:28 <nominolo> @hoogle process
12:53:29 <lambdabot> System.Process :: module
12:53:29 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
12:53:29 <lambdabot> System.Posix.Types.ProcessID :: type ProcessID
12:53:37 <Jedai> Philippa_: Yeah I know and I intend to try other things by myself when I have the time
12:53:45 <shukhov> nominolo: thanks!
12:53:56 <Philippa_> and if you're not using it in a manner that's designed to prove that everything terminates, it can be fairly easy to work with
12:53:56 <nominolo> shukhov: http://haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html#v%3ArunInteractiveProcess
12:53:57 <lambdabot> Title: System.Process, http://tinyurl.com/38wv7e
12:53:58 <Jedai> Philippa_: But don't tell me it's that much better, I won't believe you !! ;-)
12:54:06 <Philippa_> certainly easier than encoding the equivalent in Haskell
12:54:25 <nominolo> shukhov: i think this one might be more usable
12:54:42 <Jedai> Philippa_: There are things that are a snap to do in Coq, but there are things that are much harder too
12:55:06 <Philippa_> *sigh*
12:55:08 <shukhov> shukhov: alright, i'll try it out
12:55:20 <Philippa_> yes. I just told you not to use Coq as a model for all ways of working with dependent types, didn't I?
12:55:37 <Jedai> Philippa_: What would you recommend to try ?
12:55:40 <Philippa_> Coq is primarily a system for proving theorems, that affects what it's designed to make easy
12:55:54 <Philippa_> I'm hearing a lot about Agda :-)
12:55:55 <nominolo> Jedai: did you try Agda?
12:56:20 <nominolo> Jedai: take a look at the examples
12:56:24 <Jedai> Not yet, but I read some scary papers, I should probably try by myself... :)
12:56:31 <nominolo> there's not much documentation, yet
12:56:32 <camio> http://www.adga.org isn't it.
12:56:32 <lambdabot> Title: American Dairy Goat Association
12:56:43 <nominolo> @where agda
12:56:43 <lambdabot> http://tinyurl.com/yp6zsr
12:57:40 <chrisdone> programming is much more accessible than maths
12:58:01 <Philippa_> Jedai: papers probably aren't how you want to get started
12:58:20 <Jedai> chrisdone: Well, that's all a question of point of view. For some of us, "programming" is maths.
12:58:37 <Jedai> Philippa_: Yeah, there were pretty scary, interesting though
12:59:17 <nominolo> Jedai: here's an example: http://code.haskell.org/Agda/examples/Lookup.agda
13:00:29 <nominolo> Jedai: or even http://code.haskell.org/Agda/examples/SummerSchool07/Lecture/
13:00:30 <lambdabot> Title: Index of /Agda/examples/SummerSchool07/Lecture
13:05:17 <tibbe_> so a GHC Int is not guaranteed to be as big as an CInt?
13:06:29 <ksandstr> I thought GHC's Int type was tagged, therefore 31/63 bits signed
13:07:41 <Philippa_> tibbe: correct. Use CInt if you want that
13:08:34 <tibbe> Philippa_: ok
13:13:27 <BMeph> tibbe_, ksandstr: By the Report, Haskell Ints are guaranteed to have 30 bits, signed (i.e., -2^29..2^29-1). Any more than that is "implementation-dependent," or just your good luck. :)
13:13:49 <BMeph> (See http://haskell.org/onlinereport/basic.html#sect6.4 for reference)
13:13:50 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
13:15:21 <tibbe> BMeph: ok thanks
13:15:34 * tibbe ponders what's the best abstraction for files.
13:17:31 <shukhov> nominolo: Thank you, I got it to work with runInteractiveCommand.
13:17:32 <nominolo> a capability
13:23:28 * BMeph wonders what the best abstraction is for a capability...
13:24:33 <gwern> BMeph: lightweight static ones? :)
13:25:09 <BMeph> gwern: The abstractions, or the capabilities? ;)
13:25:26 <igel> does anyone have experience with PixbufData?
13:25:31 <gwern> BMeph: the capabilities - I was referencing an Oleg paper
13:25:35 <gwern> he uses GADTS iirc
13:25:55 <igel> whenever i try to access PixbufData, i get gtk/Graphics/UI/Gtk/Gdk/PixbufData.hs.pp:58:0: No instance nor default method for class operation Data.Array.Base.getNumElements
13:26:02 <mohbana> i'm about to order some books for amazon so i thought i'd ask, what haskell books do you guys recommend for a "beginner".  we covered Simon Thompson's Haskell: The Craft of Functional Programming until Chapter 18 Programming with actions in one semester some (roughly) 2 years ago
13:26:32 <igel> no matter if i try to access it via readArray or freeze
13:26:39 <gwern> mohbana: IMO, my advice is always to go through YAHT and the wikibook and only buy books if those just don't work for you
13:26:43 * BMeph Googles to find "Lightweight Dependent-type Programming" and starts skimming...
13:26:52 <gwern> mohbana: save your money for advanced stuff like Purely Functional Datastructures
13:27:02 <nominolo> gwern: no, oleg uses no GADTs
13:27:13 <nominolo> just existentials (or SML modules)
13:27:15 <gwern> nominolo: oh. what was it then?
13:27:32 <nominolo> the same trick that ST does
13:27:38 <gwern> hm. existentials = phantom types?
13:27:49 <gwern> preflex: seen zooko
13:27:50 <preflex>  zooko was last seen on #haskell 77 days, 17 hours, 49 minutes and 2 seconds ago, saying: Ha!
13:28:22 <mohbana> i'd like something that would serve also serve as a reference
13:28:25 <nominolo> gwern: ok, maybe no existentials, just uninstantiated phantoms
13:28:26 * gwern goes back to wikipedia editing
13:29:44 <nominolo> mohbana: you could take a look at Real World Haskell
13:30:16 <moozilla> how do i use bitwise logic in haskell?
13:30:26 <nominolo> > 4 .|. 1
13:30:27 <lambdabot>  Add a type signature
13:30:32 <nominolo> > 4 .|. 1 :: Int
13:30:33 <lambdabot>  5
13:30:49 <nominolo> > 4 .&. (-1) :: Int
13:30:50 <lambdabot>  4
13:30:51 <Cale> moozilla: The stuff in Data.Bits
13:30:59 <moozilla> ah, thanks
13:32:01 <Cale> mohbana: Graham Hutton's book "Programming in Haskell" is supposed to be good for beginners.
13:32:23 <moozilla> also, how would I convert a number to a hexidecimal string
13:34:12 <dmhouse> ?hoogle showIntAtBase
13:34:13 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:34:25 <moozilla> thanks\
13:34:33 <dmhouse> ?hoogle showHex
13:34:33 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
13:34:38 <dmhouse> moozilla: the latter is probably easier.
13:35:05 <dmhouse> ShowS is a bit of a pain, you need to do something like the following:
13:35:22 <dmhouse> > showHex 255 ""
13:35:23 <lambdabot>  "ff"
13:35:37 <moozilla> what exactly does ShowS do?
13:35:50 <mauke> type ShowS = String -> String
13:35:58 <nominolo> moozilla: it avaids bad performance with (++)
13:35:59 <moozilla> just adds the string on the end?
13:36:38 <mauke> > showHex 255 . showHex 128 . showHex 144 $ ""
13:36:40 <lambdabot>  "ff8090"
13:36:52 <nominolo> in ShowS (.) works like (++)
13:37:01 <nominolo> as mauke demonstrated
13:37:18 <dmhouse> (++) is O(n), using ShowS with (.) is O(1) IIRC.
13:37:57 <nominolo> where n == length of left side
13:38:13 <Cale> right.
13:38:35 <nominolo> therefore ("foo"++"bar)++"baz" is very slow
13:38:47 <nominolo> first it duplicates "foo", then "foobar"
13:39:08 <Jedai> I guess you can more or less think of it as a StringBuffer in Java (ok, maybe not...)
13:39:37 <nominolo> > ("foo"++) . ("bar"++) . ("baz"++) $ ""
13:39:51 <Twey> That's the same, no?
13:39:53 <lambdabot>  thread killed
13:40:06 <Jedai> But anyway, when you have lots of (++) that are not in the right order, you want to use Difference List (ShowS for String, or DList on Hackage in general)
13:40:58 <dmhouse> I guess generalised string literals could be a solution to this.
13:41:13 <nominolo> why did that crash?
13:41:26 <jeffwheeler> > ("foo" ++) $ ""
13:41:26 <Jedai> We should all use ropes anyway
13:41:38 <lambdabot>  "foo"
13:41:40 <Jedai> nominolo: because lambdabot is capricious these days
13:41:46 <Jedai> > ("foo"++) . ("bar"++) . ("baz"++) $ ""
13:41:47 <lambdabot>  "foobarbaz"
13:41:48 <nominolo> Jedai: you men Data.Sequence ?
13:41:51 <jeffwheeler> That took a /really/ long time; funky.
13:42:26 <moozilla> I'm only using strings for debug anyways so it doesnt matter too much
13:43:18 <nominolo> well, with overloaded string literals, (++) could be moved into the monoid typeclass
13:43:31 <nominolo> which would be nice
13:48:05 <Jedai> www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
13:48:18 <mohbana> any more suggestions?
13:48:32 <Jedai> Hmm, I was disconnected for some minutes there, anyway this link should show you what a "rope" is. I believe we have an implementation for ByteString on Hackage already
13:49:53 <moozilla> how would i write something like this in point free form?
13:49:53 <moozilla> (.&&.) x y = (x .&. y) :: Int
13:50:07 <nominolo> Jedai: i know what a rope is.  the functional equialent is a finder-tree
13:50:14 <Jedai> (.&&.) = (.&.)
13:50:25 <nominolo> or maybe a finger tree with chunks at the leaves
13:50:45 <Jedai> nominolo: Ok, Data.Sequence then
13:50:55 <moozilla> Jedai: i just wanted to get rid of the akwardness of casting to Int
13:51:04 <Jedai> but a little bit tweaked I guess
13:51:08 <moozilla> i'm not clear on the "right way" to do that
13:51:15 <Baughn> moozilla: If you specifically want to constrain to int, you'll have to have it
13:51:24 <Baughn> moozilla: There's no "casting" or even conversion here, though
13:51:25 <Jedai> moozilla: Well you just do :
13:51:43 <Baughn> You're just telling the typechecker "If an Int doesn't turn out to work here, scream"
13:51:44 <Jedai> (.&&.) :: Int -> Int -> Int
13:51:53 <Jedai> (.&&.) = (.&.)
13:51:58 <moozilla> alright
13:51:59 <moozilla> i see
13:52:06 <Baughn> As opposed to .&., which say "If some type I can't do bitwise operations on doesn't turn up here, scream"
13:52:11 <tibbe> anyone used binary-strict?
13:52:22 <Baughn> s/doesn't turn up/turns up/
13:52:26 <Jedai> moozilla: though you shouldn't need it, in a real program, your int type would be imposed by the context in another place
13:53:25 <trofimovich> @type (.&&.)
13:53:26 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:53:56 <dcoutts> sioraiocht: ping
13:54:02 <dcoutts> @seen sioraiocht
13:54:02 <lambdabot> sioraiocht is in #haskell.de, #haskell-blah, #haskell.es and #haskell. I don't know when sioraiocht last spoke.
13:54:04 <sioraiocht> pong
13:54:13 <bos> sioraiocht: how goes the unicode string project?
13:54:20 <dcoutts> sioraiocht: want to meet on Friday morning to get the bus to AngloHaskell ?
13:54:26 <sioraiocht> dcounts, sure
13:54:30 <dcoutts> bos: he'll be talking about it at AngloHaskell :-)
13:54:41 <sioraiocht> dcoutts even, heh
13:55:01 <dcoutts> sioraiocht: we're getting the 8:20 bus from Gloucester Green, so meet say 8:10
13:55:08 <sioraiocht> sounds good to me
13:55:42 <dcoutts> sioraiocht: there'll be four of us
13:55:53 <sioraiocht> jim is coming as well
13:55:59 <dcoutts> oh, cool, five then
13:59:28 <enso> wah-hoo!
13:59:35 <enso> I made it through YAHT
13:59:48 <dmhouse> Yay!
14:00:10 <enso> I think I'm starting to get this Haskell deal ... (at least a little)
14:01:38 <enso> are there any other tutorials that have "exercises" for haskell?
14:02:20 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html isn't really a haskell tutorial but it has exercises
14:02:22 <lambdabot> Title: Haskell: How To IO
14:02:34 <enso> I've started "project euler" but I think I'd like a more Haskell/Monad centric "challenge
14:02:35 <enso> "
14:02:40 <Baughn> enso: I don't know if I'd call them exercises, but planet haskell blogs often have little puzzles.. or big puzzles. More often, just good ideas
14:02:47 <enso> ah
14:03:04 <enso> ok. thanks to both of you.
14:03:53 <enso> Is that "planet.haskell.com" Baughn
14:03:54 <enso> ?
14:04:05 <enso> org**
14:04:21 <Baughn> .org, yes
14:04:46 <Baughn> Go ahead and subscribe now. You'll have a nice backlog for when you start understanding them. ^_^
14:05:02 <mauke> http://www.spoj.pl/ is full of exercises but they're not haskell specific
14:05:05 <lambdabot> Title: Sphere Online Judge (SPOJ)
14:05:08 <Baughn> enso: http://logicaltypes.blogspot.com/2008/08/how-do-i-get-better.html <-- Oh, I think this entry is meant for you
14:05:08 <lambdabot> Title: Typed Logic: How do I get better?
14:06:50 <enso> ahh Arrows...there's the next milestone I suspect
14:07:36 <Baughn> > ((*) `ap` (+3)) 5
14:07:37 <enso> thanks yet again.
14:07:37 <lambdabot>  40
14:07:53 <Baughn> enso: ^-- Might want to figure out that one first. Or not, as you like
14:07:56 <enso> (5+3) * 5
14:08:04 <Baughn> Ah, right. ^^;
14:08:26 <enso> call it an educated guess
14:08:36 <Baughn> Okay. Now, /why/ does it do that?
14:08:55 <enso> I think if you'd done : ((*) `ap` (+3)) 5 i'd have had no clue :)
14:09:08 <Baughn> > (join (*)) 5
14:09:09 <lambdabot>  25
14:09:18 <Baughn> @type (join,ap)
14:09:19 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1 b. (Monad m1, Monad m) => (m (m a) -> m a, m1 (a1 -> b) -> m1 a1 -> m1 b)
14:09:42 <Baughn> ..that was a bit messy
14:09:47 <enso> damn you and your questioning of my ability to actually "learn" and "apply" :)
14:10:11 <Baughn> enso: Not at all, I'm just jealous of your willingness to learn about arrows when I haven't yet
14:10:32 * Baughn makes mental note to fix that asap
14:10:34 <enso> oh. Ha. Well, I have a boat load of documents on Monads
14:11:15 <enso> and your (2nd) suggestion had a link about Arrows
14:11:30 <enso> I need a break from monads I think.
14:11:41 <Baughn> enso: I found that link via reading planet haskell, so.. yep, nice site.
14:12:55 <enso> so...if you don't mind my taking a stab.  Arrows are like monads wrapping up TWO types?
14:13:30 <enso> don't all answer at once...please
14:13:31 <enso> :)
14:13:34 <Baughn> Oh, I don't mind at all. I don't /know/, but I don't mind.
14:13:46 <enso> hahaha
14:14:12 <enso> @type arr
14:14:12 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
14:14:26 <xerox> ?type (>>=)
14:14:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:14:27 <Baughn> enso: http://www.haskell.org/arrows/biblio.html <-- More arrow papers
14:14:27 <lambdabot> Title: Arrows: bibliography
14:15:11 <enso> really more like a monad that wraps up a function of (up to) two types?
14:15:27 <xerox> that combinator imposes a functional dependency on the second argument based on the result of the computation
14:15:30 <xerox> ?type (>>>)
14:15:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
14:15:44 <xerox> this one also links the input types
14:16:30 <xerox> (>>>) :: (Arrow (~>)) (a ~> b) -> (b ~> c) ) -> (a ~> c)
14:16:39 <enso> eep. what happened there?
14:17:12 <dmhouse> enso: xerox was using (~>) as the type variable instead of a.
14:17:18 <mauke> -!- Netsplit over, joins: shepheb, der_eq, dainanaki, Kopophex, AtnNn, soduko, joey`, twanvl, sad0ur, chris2 (+24 more)
14:17:18 <Baughn> enso: I got us a private channel to talk in, of course
14:17:20 <dmhouse> Infix type variables.
14:17:27 <dmhouse> Oh, the netsplit.
14:17:44 <sheyll> hi!
14:17:50 <nominolo> mauke: don't quote user names
14:17:59 <chris2> mauke: thanks for reminding me! :-P
14:18:03 <mauke> :-(
14:18:24 <Trinithis> How do I make it so that when a user inputs multiple characters for a getChar, the extraneous characters won't roll over?
14:18:34 <mauke> define "roll over"
14:18:38 <mauke> and then use getLine
14:18:43 <Trinithis> ok
14:18:44 <enso> haha
14:19:44 <monochrom> hi hi
14:20:43 <enso> hallo
14:21:09 <sheyll> I don't know if you care, but after some ppl in this channel explained some aspects of lazy evaluation to me, I thought it might help other beginners too, and I wrote a small blogpost about it. May I post the url here?
14:21:39 <monochrom> Yes surely.
14:21:40 <astrolabe> Please do
14:21:46 <sheyll> http://sheyll.blogspot.com/2008/08/lazy-evaluation-there-be-dragons-and.html
14:21:47 <lambdabot> Title: try { } catch blog: Lazy Evaluation(there be dragons and basement cats), http://tinyurl.com/5hw84o
14:22:11 <Baughn> sheyll: Hm. How about "There will be dragons (but only if you look)"?
14:22:51 <enso> interesting name for sure.
14:23:20 <BMeph> Anyone have any recommendations on learning Arrow Calculus, vice "classic" Arrows (for Baughn, that is) :)
14:23:52 <Baughn> Eep!
14:26:15 <sheyll> it's always the dragons, that's not fair... therefor I thought there should be some other animal in the title too ;) And the dragon are there only if you don;t look
14:26:34 <Baughn> No, they're there specifically only if you do look
14:26:36 <Baughn> That's the pint. ;)
14:26:41 <Baughn> Er, point
14:27:41 <Twey> sheyll: 'which' not 'wich'
14:27:44 <Twey> Sorry, bugged me
14:27:47 <olsner> Baughn: someone say pint?
14:27:50 <moozilla> is it not possible to specify the type of functions in where clauses?
14:28:05 <sheyll> thanks, will replace it.
14:28:05 <monochrom> It is possible.
14:28:15 <Baughn> monochrom: You can specify the type of anything, at any point
14:28:18 <Baughn> *moozilla
14:28:24 <mauke> moozilla: depends
14:28:30 <Baughn> moozilla: That is, even something like "4 + (3 :: Int)" is valid
14:28:38 <mauke> you can't specify the types of some local entities without language extensions
14:28:44 <mar77a> > 'c' :: Int
14:28:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
14:29:27 <Baughn> mauke: That's a first.. or did you mean "specify correctly", as with scoped types?
14:29:57 <moozilla> i'm uploading my code to a pastebin
14:30:02 <Jedai> What does {! !} means in Agda ?
14:30:04 <dmhouse> > foo (a :: Int) b = a + b -- this needs language extensions.
14:30:05 <lambdabot>  Parse error at "=" (column 18)
14:30:20 <mar77a> can't you just do
14:30:20 <dmhouse> > let foo (a :: Int) b = a + b in foo 4 5
14:30:21 <lambdabot>  Parse error in pattern at "in" (column 30)
14:30:21 <byorgey> Jedai: it's a goal
14:30:27 <mar77a> foo :: Int -> blah blah
14:30:34 <dmhouse> mar77a: yes, but that's not the point.
14:30:47 <byorgey> Jedai: emacs has support for hilighting goals, telling you what its type should be, etc.
14:31:01 <byorgey> i.e. it's some code you haven't written yet =)
14:31:13 <Baughn> Hm, right. (Not sure patterns count as "things", though)
14:31:16 <Jedai> Ok, like in Coq in a way
14:31:27 <byorgey> Jedai: yes, exactly
14:31:37 <mauke> Baughn: yeah
14:32:47 <moozilla> http://slexy.org/view/s2CtnjtKE1
14:32:48 <lambdabot> Title: Slexy 2.0
14:33:02 <moozilla> this is getting an "Invalid type signature"
14:33:13 <mauke> oh, yeah
14:33:16 <mauke> NNN :: Int
14:33:27 <mauke> that's invalid because variables must start with a lowercase letter
14:33:36 <mauke> uppercase is for constants
14:33:53 <dmhouse> Err, datatypes.
14:33:53 <moozilla> ah
14:34:01 <dmhouse> They're not really the same thing ;)
14:34:14 <monochrom> "NNN" is invalid.
14:34:28 <moozilla> well I feel sort of dumb
14:35:25 <nominolo> moozilla: that's what we're there for
14:35:32 <nominolo> make you feel dumb, that is
14:35:40 <moozilla> :P
14:35:49 <monochrom> No, that's the job of computers.
14:36:06 <nominolo> or Oleg
14:36:12 <Baughn> s/variable/binding/g
14:36:18 <mauke> hmm, I might use printf there
14:36:34 <olsner> a channel full of haskellites is enough to humble most :D
14:36:50 <nominolo> printf is a bit evil though
14:37:39 <nominolo> wasn't it dons that commented on reddit that Haskell makes the unthinkable thinkable?
14:37:52 <moozilla> heh
14:37:59 <moozilla> is bit shifting also included in Data.Bits
14:38:08 <nominolo> moozilla: yup
14:38:19 <nominolo> shiftL / shiftR
14:38:25 <hml> is there an implementation of haskell in haskell?
14:38:33 <moozilla> ghc?
14:38:35 <monochrom> Yes. GHC.
14:38:35 <nominolo> you mean GHC?
14:38:43 <hml> i thought ghc was writte in C ...
14:38:53 <nominolo> hml: the runtime is
14:39:10 <nominolo> but the majority of the compliler is written in haskell itself
14:39:13 <moozilla> i thought it was just bootstrapped from C originally
14:39:30 <monochrom> Last Century.
14:39:50 <thoughtpolice> no, the bootstrapping process happened a little differently; it started with LML, then it went to HBC and HBC was later used to bootstrap GHC
14:39:50 <thoughtpolice> from what I can tell
14:39:51 <nominolo> well, you have to start somewhere
14:40:12 <Cale> What was LML bootstrapped from?
14:40:42 <nominolo> SimonPJ himself created it by just thinking of it
14:41:15 <jeffwheeler> So, when most people install GHC today, how does it work?
14:41:25 <dmhouse> Most people install binaries.
14:41:41 <nominolo> And Simon said, Let there be LML: and there was LML.
14:41:43 <jeffwheeler> Or else you start with an older version of GHC that you already had? ;)
14:41:52 <dmhouse> Exactly.
14:42:17 <monochrom> I just download gcc and ghc binaries.
14:42:18 <yitz> nominolo: let's not fool ourselves. besides being very smart, SPJ works very, very hard.
14:42:21 <dmhouse> It's possible but painful to bootstrap from intermediate C files.
14:42:24 <monochrom> I don't build gcc myself.
14:42:28 <Zao> You either bootstrap with a GHC >= 6.4 or so, or cross-compile via-C.
14:42:32 <nominolo> jeffwheeler: yes, you start with an old version. create a ghc binary (stage1), then use that to compile ghc again (stage2)
14:42:33 <jeffwheeler> It seems scary from a security perspective --- you're always starting with a binary.
14:42:43 <dmhouse> These are architecture-specific. Goodness knows how they port to new archs.
14:42:44 <monochrom> How do you bootstrap Gentoo anyway.
14:42:51 <Zao> Via-C, mostly I think.
14:43:02 <Zao> Until the mangler is adjusted *shudder*
14:43:33 <thoughtpolice> Cale: I think augustss mentioned it was created using an un-named compiler for VAX machines
14:43:39 <monochrom> jeffwheeler you're exaggerating.
14:43:48 <nominolo> yitz: of course, he's also standing on the shoulders of giants
14:43:51 <Baughn> jeffwheeler: Then there's the firmware in your machine, and the production lines, and possible silicon bugs, and...
14:44:04 <Baughn> jeffwheeler: It'd be amusingly simple to put a rootkit in a NIC
14:44:16 <thoughtpolice> jeffwheeler: this one of those 'reflections on trusting trust' thing?
14:44:17 <nominolo> and of course there's a rootkit in your ipod
14:44:27 <jeffwheeler> I'm not worried about it myself, but I'm surprised nobody else got worried about it.
14:44:29 <monochrom> The real security worry is that every Haskell tutorial and everyone in #haskell tells you what code to run on your computer. They all contain trojans.
14:44:54 <jeffwheeler> It seems like the sort of thing people would complain about.
14:45:05 <olsner> thoughtpolice: so, ghc indirectly comes from a vax? that's kind of cool actually
14:45:14 <nominolo> jeffwheeler: how is this different from any other compiler?
14:45:20 <Baughn> jeffwheeler: We'd complain, if we knew of a better way to do it
14:45:29 <yitz> monochrom: ah, now i understand why certain people encourage the use of MonadCont.
14:45:36 <thoughtpolice> olsner: that was the way I saw augustss explain it; there was the VAX compiler, which was used to bootstrap LML, LML later became HBC, and HBC was used to bootstrap GHC
14:45:39 <thoughtpolice> (i think)
14:45:41 <enso> jeffwheeler: sorry, I just wanted to join it
14:45:42 <enso> in*
14:45:43 <jeffwheeler> nominolo: I don't know; does gcc do the same thing? Most compilers aren't written in their own language. :P
14:45:44 <Jedai> jeffwheeler: ?? You know gcc must be bootstrapped from a c compiler, you don't have much of these that are written using asm nowadays
14:45:45 <nominolo> you have to trust gcc, ld, the os, everything
14:45:54 <nominolo> jeffwheeler: gcc is written in C
14:46:08 <nominolo> LLVM in C++
14:46:15 <Baughn> nominolo: ...that's really not true. Not exactly C.
14:46:16 <enso> you do have to trust physics
14:46:17 <nominolo> MLton in SML
14:46:17 <jeffwheeler> That's what I suspected. Does gcc work the same way as GHC?
14:46:20 <Jedai> And even assembler must be assembled ? And maybe your linker contains a rootkit ?.
14:46:32 <nominolo> Baughn: well, it's supposed to look like Lisp
14:46:47 <thoughtpolice> heh, i remember hearing stories about how when ritchie wanted to create the first C compiler, he wrote it down on paper and compiled it by hand for the first time. :)
14:46:50 <Zao> jeffwheeler: gcc requires a reasonably standards compliant C compiler to bootstrap.
14:46:50 <Baughn> jeffwheeler: gcc can only be compiled by gcc, in fact. No other compiler implements the gnu99 language well enough.
14:46:52 <Jedai> jeffwheeler: Yep, most c compiler are bootstrapped
14:46:57 <olsner> a compiler written in assembly language is just the same as having the binary... you have about the same impossibility of figuring out if it's going to hurt you
14:47:12 <Jedai> olsner: Very true !! ^^
14:47:18 <Zao> Baughn: If I recall correctly, I've built it with vacpp.
14:47:31 <Baughn> Zao: It does have a bootstrap mode, yes
14:47:39 <jeffwheeler> olsner: yeah, you're absolutely right --- and I myself am not looking through even GHC's source as it is
14:47:41 <Baughn> Which then goes on to compile the /rest/ of the compiler with gcc
14:47:50 <Zao> It just needs a C90 compiler, or so the docs say.
14:47:59 <enso> well you could objdump the binary...but then again your objdump could contain a rootkit!
14:48:00 <Zao> Whatever is done in the later stages is quite different.
14:48:08 * olsner stops just short of repeating what Baughn just said
14:48:31 <Baughn> Zao: I may be mistaken, but I think the bootstrap compiler doesn't implement any optimizations, or that sort of thing. This makes it very simple
14:48:39 <lelf``> http://www.haskell.org/pipermail/haskell-cafe/2007-November/034474.html
14:48:40 <lambdabot> Title: [Haskell-cafe] Somewhat random history question - chicken and egg, http://tinyurl.com/5ojs77
14:48:42 <olsner> enso: you just connect the disk to an oscilloscope and hand-decompile it :D
14:49:58 <BMeph> You know, the first Lisp engine was written in Fortran... o.O
14:50:23 <ddarius> No wonder they were slow.
14:51:12 <nominolo> BMeph: wasn't it assembly?
14:51:42 <olsner> lisp certainly sounds feasible to write in assembly
14:51:55 * ddarius is pretty sure it was assembler too.
14:52:06 <nominolo> if you mean Lisp 1.5, i'm pretty sure i read that it their first implementation was to implement the primitives in machine code
14:52:13 <ddarius> Probably easier to write in assembly than FORTRAN.
14:52:36 <nominolo> fortran was there before lisp, yes, but i don't think they used it
14:52:44 <dino-> I've been messing with some code lately where I have a (WriterT [String] IO) a ..
14:52:52 <nominolo> after all CAR and CDR are named after machine registers
14:53:12 <dino-> And I've noticed that the whole computation executed with runWriterT has to complete before I get any logging at all out of that.
14:53:22 <olsner> ah, yes, wasn't it an assembly macro package at some point?
14:53:30 <yitz> I think it was a lot different than what we call "assembler" today. it was on one of those 1960's era IBMs that an "Address Register" (CAR) and a "Data Register" (CDR). The machine code was in base 10, not base 2, on those machines.
14:53:57 <nominolo> yitz: yes, that's why i said "machine code" :)
14:54:02 <dino-> Is this just not the approach to use if you want 'eager' log messages out of something?
14:54:03 <olsner> wasn't it "Decrement Register"?
14:54:53 <nominolo> olsner: according to wikipedia, yes
14:55:01 <yitz> olsner: I don't think so.
14:55:02 <monochrom> dino-: Control.Monad.Writer.Strict may help
14:56:06 <yitz> I once saw the manual for one of those things. I'm pretty sure it was "Data Register", but it was a long time ago.
14:56:40 <dino-> monochrom: I'll try it. Thank you
14:57:35 <mauke> contents of decrement part of register
14:59:58 <dino-> Hm, didn't change a thing. Maybe still doing it wrong. My runWriterT is happening in main's do block before the resulting log [] is output. :/
15:00:27 <dino-> Wonder if I need some sort of fork.
15:00:58 <BMeph> FYI: I got my info from: http://www-formal.stanford.edu/jmc/history/lisp/node3.html
15:01:13 <ddarius> dino-: I'm pretty sure you are doing something silly.
15:01:32 <dino-> ddarius: That would be my guess too, yeah. I'll get something onto hpaste.
15:03:24 <dino-> http://hpaste.org/9386
15:04:23 <moozilla> is it possible to have multiple levels of guards?
15:04:58 <mauke> not directly
15:05:10 <xd> can use a case
15:05:47 <ddarius> Why are you using WriterT?
15:06:11 <dino-> ddarius: Because many things I've read say that it can be used for logging as a side effect.
15:06:35 <Philippa_> yeah, but if you're on top of IO you can just write it straight out
15:07:14 <dino-> yes. This is the approach of thigns like hslogger, I think too.
15:07:23 <dino-> Just do it all in IO
15:07:26 <Philippa_> alternatively, you can just use Writer and do the logging from the outside
15:08:13 <dino-> I don't think I understand that.
15:09:34 <perspectival> there is some information on the Writer monad here as well: http://www.haskell.org/all_about_monads/html/writermonad.html
15:09:35 <lambdabot> Title: The Writer monad
15:09:45 <dino-> But if Writer is a poor choice for this type of thing, I'm ok with that. I wasn't really sure how to approach it.
15:09:50 <yitz> dino-: in your main, you run the computation, then output the log. so what exactly is wrong?
15:10:38 <dino-> yitz: It's really more in what I'd like to be happening. I'd like logging to occur to the outside as data is sent to the 'logger'
15:11:03 <perspectival> also, the cabal package info for the dlist package has this to say: "The dlist package (version 0.4.1)Differences lists: a list-like type supporting O(1) append. This is particularly useful for efficient logging and pretty printing, (e.g. with the Writer monad), where list append quickly becomes too expensive." I just noticed this today
15:12:00 <dino-> perspectival: Yeah, I actually need to stop using [String]. I was helped a few days ago with the suggestion of Data.Sequence as well.
15:12:06 <dino-> But first things first.
15:12:13 <yitz> moozilla: not exactly sure what you mean by "multiple levels of guards". But mplus may help you do what you want.
15:12:39 <moozilla> yitz: I'll paste an example of what I want to do
15:12:56 * monochrom evilly inserts a couple of unsafeInterleaveIO :)
15:13:29 <yitz> @slap monochrom
15:13:29 * lambdabot will count to five...
15:13:47 <dino-> The bigger overall problem is that I'm going to have a long-running program that I need to see log output from as it occurs. It may never ever finish running for weeks at a time.
15:13:51 <perspectival> dino-: I understand, as I'm at that exact same point ;-)
15:13:56 <dino-> Which I guess means: do it in IO
15:15:02 <yitz> dino-: sounds that way. the whole point of Writer is to accumulate the output gradually.
15:15:22 <dino-> yitz: But only be able to do anything with it when it's all complete, it seems like.
15:15:32 <moozilla> yitz: something like this: http://hpaste.org/9387
15:15:50 <dino-> Which, to me, is only a small subset of things that need logging.
15:16:36 <dino-> Philippa_: I still am not sure what you were saying about doing logging from the outside.
15:16:54 <dino-> With Writer (not WriterT)
15:17:19 <yitz> dino-: well, there's "listen" to look at what you have so far. But generally, the main point of Writer is to have it all at the end and use it then.
15:17:41 <dino-> yitz: ok
15:17:56 <dino-> Well, this helps me quite a bit so far already. In the form of attacking what I need to do in a better way.
15:18:00 <dino-> Thank you all.
15:19:00 <moozilla> nevermind yitz, i figured out the case expression
15:23:54 <Philippa_> dino-: something like (warning: this isn't actual code) do {let (log, result) = runWriter ...; writeFile file log; ...}
15:24:19 <Philippa_> it does interesting things because you demand the log first
15:27:44 <jeffwheeler> cabal install <pkg> should notice when it's in that pkg's src dir; I type the pkg name too frequently, and accidentally install the version on Hackage
15:28:03 <dcoutts> jeffwheeler: heh :-)
15:28:20 <dino-> Philippa_: But still sits and completes that runWriter before getting to the writeFile part of that sequence..?
15:28:32 <jeffwheeler> I just realized the version I installed doesn't work because it's old. ;)
15:28:34 <dcoutts> jeffwheeler: though you might really want to do that. If you have any suggestion about what we should actually do, file a feature request.
15:29:11 <jeffwheeler> dcoutts: I'll do that when I get home; although I can definitely understand the current behavior
15:32:08 <yitz> moozilla: http://hpaste.org/9387#a1
15:33:51 <moozilla> yitz: i see
15:34:36 <MyCatVerbs> yitz: honestly, I prefer the original.
15:35:45 <yitz> MyCatVerbs: yeah, except the indented guards don't work, so he has to use nested case instead.
15:36:12 <MyCatVerbs> yitz: which is just fine.
15:36:13 <yitz> (or she)
15:37:56 <MyCatVerbs> yitz: case optsub of { 0 -> "vx = vy"; 1 -> "vx .|. vy"; } seems sane enough to me.
15:44:49 <MyCatVerbs> yitz: if not, there's always _this_ travesty: http://hpaste.org/9387#a2 :)
15:47:47 <yitz> MyCatVerbs, moozilla: or this: http://hpaste.org/9387#a3
15:52:42 <moozilla> yitz: the point of using guards is to (hopefully) make the code more readable
15:52:57 <moozilla> i like the case expression though
15:52:59 <ddarius> Use a datastructure.
15:53:16 <moozilla> datastructure?
15:55:06 <ddarius> The code is basically a table between numbers and strings.
15:55:25 <moozilla> the strings are just placeholders for now
15:55:28 <moozilla> thats the thing
15:55:40 <ddarius> You can easily stick IO actions or whatever in place of strings.
15:56:09 <moozilla> i'm thinking i'll need to make a state machine
15:56:15 <moozilla> but i'm not quite sure how to do that
15:57:15 <ddarius> Why do you think you need a state machine?
15:57:38 <Twey> Is Exit just a relabelled Error?
15:57:52 <moozilla> ddarius: the intent is to code an emulator
15:58:01 <ddarius> So?
15:58:01 <moozilla> i need something to hold the variables and stack
15:58:18 <moozilla> i could pass them as arguments, but that seems clunky
15:59:49 <BMeph> Has anyone actually implemented the "Generic Zipper" structure written about in the "Scrap Your Zippers" Pearl?
16:01:33 <matthew-_> @seen dcoutts
16:01:33 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 32m 59s ago.
16:01:48 <dcoutts> hia matthew-_
16:01:53 <matthew-_> howdy
16:01:57 <dcoutts> @arr!
16:01:57 <lambdabot> Har de har har!
16:02:16 <matthew-_> so it looks like I'll be able to stream the AngloHaskell talks, live
16:02:30 <matthew-_> as well as record them
16:02:35 <matthew-_> audio only though, no video
16:02:47 <dcoutts> oh, cool
16:03:01 <matthew-_> is there some way you can update the haskell.org front page at a suitable moment to advertise this on Friday?
16:03:18 <dcoutts> matthew-_: I'm sure we can.
16:03:23 <matthew-_> awesome
16:03:26 <thoughtpolice> matthew-_: a post to -cafe would be in order too. :)
16:03:48 <matthew-_> true. Well obviously if people go to the url now, it'll just say stream doesn't exist
16:04:08 <matthew-_> so maybe a posting thurs evening and then a reminder when it's running friday morning
16:04:12 <dcoutts> matthew-_: in this case I think the best person to ask is dons. He's frequently updating the haskell.org home page. I could possibly but I worry I'd break something or step on someones toes. :-)
16:04:25 <matthew-_> well he be awake on friday morning though?
16:04:28 <dcoutts> dons: would that be ok?
16:04:33 <ddarius> matthew-_: You say "There will be a stream at this url at this time."
16:04:37 <matthew-_> s/^well/will/
16:04:41 <matthew-_> ddarius: yep. true
16:05:06 <dcoutts> matthew-_: or I can get instructions from dons if you think it needs to be done at a specific time.
16:05:29 <matthew-_> nah, probably putting it up on haskell.org on the thurs night will be fine
16:05:38 <matthew-_> it's not like it's a security risk or anything
16:12:22 <MyCatVerbs> yitz: http://hpaste.org/9387#a4 <-- at this risk of doing the obvious...
16:13:11 <MyCatVerbs> yitz: (er, looks like I left the "| otherwise" on there by mistake, oops.)
16:13:34 <yitz> MyCatVerbs: true. but it *does* demand a monad. every case is an implied Maybe monad.
16:14:39 <moozilla> yitz, MyCatVerbs: if you're interested here's the newest version: http://hpaste.org/9389
16:15:10 <MyCatVerbs> yitz: which he denotes well enough by returning the empty string, heh. :)
16:15:32 <yitz> moozilla: looking good :)
16:15:45 <moozilla> :)
16:16:37 <MyCatVerbs> moozilla: much nicer. Not having to check both nnn and optype makes it rather cleaner, IMO. :)
16:16:54 <moozilla> MyCatVerbs: that was my thinking as well
16:20:11 <MyCatVerbs> moozilla: http://hpaste.org/9389#a1
16:21:24 <MyCatVerbs> moozilla: in the top branch there, not so much point nesting cases when you only have two levels and there's only one tiny little special case there.
16:21:36 <shapr> yarr1
16:21:39 <moozilla> well
16:21:56 <MyCatVerbs> moozilla: unless you're going to expand those nested sections a lot, though. That'd be a good reason.
16:21:57 <moozilla> MyCatVerbs: optype ANDs off the last two digits
16:22:20 <moozilla> i did that so i could generalize it to just optype instead of opcode
16:24:51 <yitz> moozilla: note that this has slightly different semantics than my offerings. When checking all of the sub-cases fails, my method can fall through to the global "otherwise", whereas you need to repeat the "otherwise" each time there are sub-cases.
16:25:09 <MyCatVerbs> yitz: oh aye, good point.
16:25:22 <moozilla> right
16:29:05 <cnwdup> ?hoogle withFileStatus
16:29:06 <lambdabot> No matches found
16:29:36 <cnwdup> Where can I find this function or an equivalent one? Its used in System.Directory, but I can't find it in the Modules it imports.
16:31:44 <mauke> it's in System.Directory
16:32:01 <mauke> and it's not exported
16:32:25 <cnwdup> mauke: Oh, indeed. Thank you.
16:32:48 <mauke> see also System.Posix.Files
16:32:54 <cnwdup> Is there a similar function which is imported? I want to query wheather the file is a file or a directory.
16:33:13 <gwern> hm. hoogle 4 is out
16:33:19 <mauke> doesDirectoryExist
16:33:37 <cnwdup> mauke: Yeah, but I then have to call doesDirectoryExist and if not doesFileExist which is a little unhandy.
16:33:49 <cnwdup> But System.Posix.Files has what I need. Thanks.
16:35:41 <gwern> 'One short command-line? Hah! cabal-install has 13 dependencies, some of which aren't packaged in most distros. In order to avoid having to learn how to install packages from hackage the hard way, you first have to learn how to install packages from hackage the hard way.
16:35:46 <gwern> Perhaps this is merely a ploy to get people to realise how much they value cabal-install?'
16:42:08 <dcoutts> heh
16:42:29 <matthew-_> the "hard way" consists of 6 commands per package: wget, tar, cd, and 3 runghcs
16:42:53 <matthew-_> that's hardly onerous
16:43:04 <gwern> > 6 * 13
16:43:07 <lambdabot>  78
16:43:15 <matthew-_> or you could write a for loop
16:43:37 <matthew-_> shells have supported them since about the year 1326
16:44:23 <MyCatVerbs> alias capile='runghc Setup configure --prefix=$HOME/stuff --user; runghc Setup build; runghc Setup install --user"; # worked for me for long enough. ^^
16:44:53 <matthew-_> MyCatVerbs: yeah, I only switched to cabal install about a month ago
16:45:15 <matthew-_> not really noticed much difference tbh... it's hackage that's slow, not installing stuff
16:45:22 <gwern> MyCatVerbs: runghc?
16:45:46 * gwern also tsks the lack of profiling and haddocks
16:46:06 <gwern> MyCatVerbs: my scripts do all that and they build from sdist!</snob>
16:48:01 <MyCatVerbs> gwern: well, why not?
16:48:58 <MyCatVerbs> gwern: Cabal is going to (and possibly already has) completely obviate(d) the need for that. But in the meantime, runghc rather than runhaskell simply because I'm not using any other Haskell compiler.
16:49:17 <gwern> because when you want profiling, you'll have to backtrack through a bazillion libraries. haddocks are also annoying if you don't have'em but need'em
16:49:21 <gwern> especially offlnie
16:49:54 <MyCatVerbs> gwern: well... stick --enable-prof in the configure line.
16:50:46 <gwern> MyCatVerbs: and if it fails because it links in something unprofiled like GHC?
16:50:49 <MyCatVerbs> gwern: the main reason I don't have haddock in that is that I've been working on machines with broken haddock setups for a while. That and some packages fail Haddock for various reasons. uvector, for example.
16:51:16 <MyCatVerbs> gwern: then try again without. :P
16:51:46 * matthew-_ wonders when he last wrote a package that haddock liked
16:52:00 <thoughtpolice> cabal install is a nice convenience if you ask me. it mainly pays off when you have something with a bunch of dependencies, i.e. pugs or something.
16:52:05 <thoughtpolice> imo, anyway
16:52:16 <thoughtpolice> yi comes to mind too
16:52:37 <MyCatVerbs> thoughtpolice: I'd have more sympathy for that if cabal install had actually successfully built yi last time I tried it. ;)
16:52:45 <dcoutts> bah
16:52:48 <dcoutts> :-)
16:53:01 <dcoutts> MyCatVerbs: yi is a great cabal-install stress test
16:53:08 <dcoutts> they do some quite tricky things
16:53:17 <dcoutts> and make dep resolvers cry
16:53:32 <gwern> 0.4 yi installed for me, btw
16:53:44 <MyCatVerbs> dcoutts: I suspected as much. It took some doing to compile manually a year or so back. :P
16:54:31 <dcoutts> MyCatVerbs: the 0.5 release of cabal-install fixed their major problem, the issue of depending on multiple versions of the same thing and resulting type errors
16:54:49 <MyCatVerbs> dcoutts: when was that?
16:55:23 <MyCatVerbs> dcoutts: everything on my machine was current as of (roughly) GHC6.8.3's release.
16:55:24 <dcoutts> MyCatVerbs: 0.5 was released June 12th
16:55:31 <matthew-_> it's certainly a big win for dependencies.
16:55:38 <dcoutts> though now depending on the time of the month, it cannot actually find a consistent set of dependencies
16:55:53 <matthew-_> I think using cabal install is the same as using apt-get, and not using it is the same as using dpkg.
16:56:04 <matthew-_> and I only use dpkg when apt-get breaks
16:56:13 <dcoutts> eg at one point yi depended on Cabal-1.4 directly but also on the ghc api package which depends on Cabal-1.2
16:56:25 <dcoutts> so cabal-install (correctly) could not find a valid install plan
16:56:29 <gwern> fun times
16:56:56 <dcoutts> matthew-_: right
16:57:26 <MyCatVerbs> matthew-_: two quibbles I have with that. First thing, doing things manually isn't as reliable as dpkg. Secondly, cabal install seems to break down more often than apt-get does. The former is pretty predictable, the latter I'll just put down to teething troubles.
17:00:07 <MyCatVerbs> Odd. cabal install yi seems to be progressing, cabal install yi-vty breaks on a missing file.
17:01:01 <gwern> are you supposed to be installing yi-vty?
17:01:06 <gwern> I thought that was only for 0.2
17:01:22 <MyCatVerbs> gwern: ah, that would explain a lot.
17:01:47 <thetallgu1> > let f x = (`head` x, ())
17:01:47 <lambdabot>  Parse error at "," (column 20)
17:02:02 <MyCatVerbs> Seems I've been trying an unfashionable package and wondering why it doesn't fit on the catwalk anymore, if you don't mind the inappropriate bletcherous failure of an analogy.
17:03:31 <gwern> so you put on a white onion on your belt. which was all the fashion at the time.
17:04:09 <thoughtpolice> MyCatVerbs: you just need vty, and when you do cabal install be sure to 'cabal install yi -fvty'
17:04:40 <gwern> maybe I should reupload yi-vty and yi-gtk with forced yi deps and better descriptions
17:04:53 <thoughtpolice> currently if you cabal-install yi you can't build it with GHC-API support because of what duncan mentioned above (since cabal install requires cabal 1.4 to be installed, and the ghc api is dependent on cabal 1.2)
17:05:07 <thoughtpolice> other than that it installed perfectly fine for me.
17:05:17 <dcoutts> MyCatVerbs: do make sure you report those teething troubles or they might never get fixed :-)
17:05:35 <thoughtpolice> same with pugs, which I found surprising but was happy that it installed out of the box. :)
17:07:33 <dons> dcoutts: around?
17:08:35 <MyCatVerbs> dcoutts: I'm better at "whining" than "reporting", but I get your point. :)
17:09:10 <gwern> @seen ndm
17:09:11 <lambdabot> I saw ndm leaving #haskell 7h 28m 53s ago, and .
17:10:00 <gwern> man, hoogle has gotten complex. 75 modules
17:10:08 <gwern> I guess type searching is *hard*
17:11:26 <idnar> heh
17:11:34 <idnar> I bet it's smaller than google ;)
17:15:44 <Botje> google's most closely guarded secret is GHC 11.2
17:16:51 <dainanaki> lol
17:17:25 <dainanaki> or else they've got haskell machines like the lisp machines of days past
17:17:35 <gwern> hm. haddock on hoogle fails
17:18:15 <gwern> no, google's sinister secret is that they are the world's largest consumer of FPGAs, onto which they digitalize the brains of google engineers, forcing them to work billions of subjective years!
17:19:25 <dainanaki> i think haskell machines and ghc 11.2 sound way more intimidating
17:19:44 <Botje> in park view, ghc builds _YOU_
17:20:30 <gwern> dainanaki: what, a million google engineers silently screaming as they invert matrices for all eternity doesn't sound intimidating?
17:20:41 <Botje> :)
17:20:53 <dainanaki> nope, that's their own fault they've gotten themselves into that mess
17:20:58 <gwern> huh. hoogle 4 is pretty fast on the cli
17:21:21 <dainanaki> besides, ghc 11.2 includes an update to the IO monad for talking to God
17:21:33 <dainanaki> that's where they get all the money from
17:22:29 <gwern> absurd,. google has more money than god
17:22:29 <rwbarton> I was just going to ask whether the rumor that hoogle 4 has been released is true
17:23:02 <gwern> rwbarton: 'tis
17:23:25 <rwbarton> ah, on hackage I see
17:23:43 <gwern> of course
17:23:45 <clanehin> the command line version, only
17:23:49 <rwbarton> Right
17:23:53 * gwern helped cabalize hoogle 3
17:24:02 <rwbarton> I was wondering whether I missed an announcement to haskell-cafe
17:24:07 <gwern> clanehin: well, I am hardpressed to see how one would cabalize a website :)
17:24:23 <gwern> rwbarton: mm. I saw an announcement *somewhere*. maybe planet haskell
17:24:50 <idnar> gwern: a web server is just another application :P
17:26:30 <stepcut> hoogle 4 was annouced on planet haskell and the hackage RSS feed (and probably the hackage bot)
17:27:33 * stepcut cabalizes his websites
17:28:54 <TSC> If I do cabal install hoogle, will I get the command line binary?
17:29:50 <stepcut> TSC: if the hoogle.cabal is properly set up, I would expect so
17:30:35 <TSC> Looks like it builds it, but doesn't "install" it anywhere
17:30:39 <TSC> Which is good enough for me
17:31:06 <TSC> Ah, it puts it in .cabal/bin
17:31:07 <TSC> Groovy
17:32:26 <moozilla> what's the prelude function to make a list with a certain number of repeated values
17:32:48 <TSC> replicate
17:33:01 <TSC> > replicate 5 "x"
17:33:11 <lambdabot>  ["x","x","x","x","x"]
17:33:12 <moozilla> thanks
17:33:24 <TSC> No worries
17:34:49 <TSC> It seems that the "--web" option in Hoogle 4 doesn't work; it stops with "undefined"
17:41:17 * byorgey bakes lambdachip cookies
17:41:30 <moozilla> I'm having some trouble with a data type
17:41:32 <moozilla> http://hpaste.org/9393
17:41:48 <moozilla> I can't figure out the error on line 14
17:42:31 <moozilla> oops
17:42:33 <moozilla> nevermind
17:42:48 <moozilla> just a simple [Integer] instead of Integer
17:43:06 <BMeph> That reminds me; I tried building the "Scrap Your Zippers" generic zipped, and I got something about GADT pattern-matching on a non-rigid variable... I'll try it tomorrow, and record the results.
17:43:52 <stepcut> TSC: yes, the announcement said as much
17:44:08 <BMeph> For now, I wish happy Haskell Hackery to you all...
17:44:31 <yitz> byorgey: aren't those illegal?
17:45:24 <byorgey> yitz: yes, but I give a few to the local policemen and they look the other way
17:46:06 <yitz> byorgey: are they glassy-eyed when they look the other way?
17:46:56 <byorgey> I don't know, when they are looking the other way I can't see their eyes.
17:47:20 <moozilla> is there a function to 'inject' a list into another list? ie. inject [a,a,a] [b,b,b,b,b] 2 = [b, b, a, a, a]
17:47:31 <EvilTerran> er, (++)?
17:47:44 <EvilTerran> no, wait
17:47:51 <EvilTerran> i see... no, there isn't
17:48:44 <rwbarton> @pl \a b n -> take n b ++ a -- is this what you mean?
17:48:44 <lambdabot> flip (flip . ((++) .) . flip take)
17:49:10 <moozilla> sort of, except it should keep the end intact as well
17:49:33 <moozilla> ie. inject [a,a,a] [b,b,b,b,b,b] 2 = [b, b, a, a, a, b]
17:49:36 <rwbarton> I see
17:49:46 <moozilla> well, if it's easier
17:49:50 <moozilla> b will always be 0
17:49:56 <EvilTerran> not a particularly common desire, i think
17:50:20 <moozilla> i think i have a way to do this
17:51:05 <EvilTerran> > (\n xs ys -> zipWith ($) (replicate n id ++ map const xs ++ repeat id) ys) 2 [a,a,a] [b,b,b,b,b,b] :: [Expr]
17:51:20 <lambdabot>  thread killed
17:51:23 <EvilTerran> > (\n xs ys -> zipWith ($) (replicate n id ++ map const xs ++ repeat id) ys) 2 [a,a,a] [b,b,b,b,b,b] :: [Expr]
17:51:37 <EvilTerran> grr
17:51:37 <lambdabot>  [b,b,a,a,a,b]
17:51:41 <EvilTerran> ah, there we go
17:51:50 <EvilTerran> zipWith ($) to the rescue
17:52:03 <EvilTerran> moozilla, now work out how that works :P
17:52:11 <mmorrow> @pl \n xs ys -> zipWith ($) (replicate n id ++ map const xs ++ repeat id) ys
17:52:12 <lambdabot> (zipWith id .) . (. ((++ repeat id) . map const)) . (++) . flip replicate id
17:52:27 <enso> blech
17:52:28 <EvilTerran> inject n xs ys = zipWith ($) (replicate n id ++ map const xs ++ repeat id) ys
17:52:45 <moozilla> seems a little complicated
17:52:48 <EvilTerran> i don't think @pl really helps in comprehensibility most times
17:52:56 <enso> @ty zipWith
17:52:59 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:55:32 <hansfbaier> @src mfix
17:55:32 <lambdabot> Source not found. My brain just exploded
17:55:47 <mmorrow> @ty \f g o -> map (\x -> o (f x) (g x))
17:55:48 <lambdabot> forall a t t1 b (f :: * -> *). (Functor f) => (a -> t) -> (a -> t1) -> (t -> t1 -> b) -> f a -> f b
17:56:04 <rwbarton> mfix is a class method of MonadFix
17:56:21 <mmorrow> @ty \f g o -> map (\x -> o (f x) (g x)) :: (a -> b) -> (a -> c) -> (b -> c -> d) -> [a] -> [d]
17:56:22 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
17:56:35 <mmorrow> @ty (\f g o -> map (\x -> o (f x) (g x))) :: (a -> b) -> (a -> c) -> (b -> c -> d) -> [a] -> [d]
17:56:36 <lambdabot> forall a b c d. (a -> b) -> (a -> c) -> (b -> c -> d) -> [a] -> [d]
17:57:39 <yitz> > let inject n xs ys = catMaybes . zipWith (>>=) (replicate n Nothing ++ map return xs ++ repeat Nothing) (map return ys) in inject 3 [20,30] [1..5]
17:57:42 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
17:58:23 <mmorrow> @ty (\f g h i o -> map (\x -> o ((h . f) x) ((i . g) x))) :: (a -> b) -> (a -> c) -> (b -> d) -> (c -> d) -> (d -> d -> e) -> [a] -> [e]
17:58:24 <lambdabot> forall a b c d e. (a -> b) -> (a -> c) -> (b -> d) -> (c -> d) -> (d -> d -> e) -> [a] -> [e]
17:58:37 <yitz> > let inject n xs ys = catMaybes . zipWith (mplus) (replicate n Nothing ++ map return xs ++ repeat Nothing) (map return ys) in inject 3 [20,30] [1..5]
17:58:37 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
17:59:14 <yitz> > let inject n xs ys = catMaybes $ zipWith mplus (replicate n Nothing ++ map return xs ++ repeat Nothing) (map return ys) in inject 3 [20,30] [1..5]
17:59:16 <mmorrow> @pl \f g h i o -> map (\x -> o ((h . f) x) ((i . g) x))
17:59:16 <lambdabot> ((((map .) .) .) .) . (. flip (.)) . flip . (((.) . flip . (ap .) . flip (.)) .) . flip (.)
17:59:16 <lambdabot>  [1,2,3,20,30]
17:59:27 <yitz> > let inject n xs ys = catMaybes $ zipWith mplus (replicate n Nothing ++ map return xs ++ repeat Nothing) (map return ys) in inject 3 [20,30] [1..7]
17:59:28 <lambdabot>  [1,2,3,20,30,6,7]
18:04:00 <moozilla> can someone proofread this for readability/understandability: http://hpaste.org/9394
18:04:32 <rwbarton> Has anyone used M-x haskell-hoogle, either with hoogle 3 or hoogle 4?
18:04:44 <MyCatVerbs> moozilla: looks fine enough to me.
18:04:47 <gwern> not recently
18:04:48 <rwbarton> It's not working for me with hoogle 4, but I've never tried it before
18:05:00 <moozilla> MyCatVerbs: thanks :)
18:05:12 <gwern> moozilla: if the bits are so small, why Integer?
18:05:20 <gwern> you just like Integer better than Ints?
18:05:27 <moozilla> i was meaning to look up the other data types
18:05:31 <moozilla> for smaller data
18:05:32 <MyCatVerbs> moozilla: maybe you'll want to use a mutable array (probably with the ST monad) instead of a big list for memory, though. Indexing into a long list will get expensive.
18:05:57 <gwern> moozilla: Ints might get you some performance benefits, especially with strictness
18:06:04 <MyCatVerbs> For the moment, continue hacking away. ^^
18:06:07 <moozilla> alright, thanks
18:06:28 <moozilla> MyCatVerbs any recommendations on where to learn about mutable arrays?
18:06:54 <MyCatVerbs> moozilla: I personally just poked at the HHL docs an awful lot.
18:07:00 <gwern> moozilla: although I suspect any gains from Ints will be hidden in the noise of all your show and string stuff
18:07:04 <MyCatVerbs> moozilla: and then wrote some code which *really* sucked, heh. :)
18:07:26 <moozilla> gwern: what's the bitwidth of Int? (also the show and strings stuff is for debugging, it will be taken out)
18:07:38 <MyCatVerbs> moozilla: Int varies.
18:07:52 <gwern> machine word, I thought
18:07:59 <moozilla> alright, but GHC optimizes for Int?
18:08:21 <MyCatVerbs> moozilla: H98 requires that it's at least 29 bits long, but it's allowed to be anything bigger than that. GHC in practice gives you either 32 or 64 bits, depending on your CPU.
18:08:59 <mmorrow> > let inject n xs = uncurry ((++) . (++xs)) . splitAt n in inject 3 [20,30] [1..7]
18:09:03 <moozilla> so 32bits in practice for me
18:09:14 <lambdabot>  thread killed
18:09:18 <mmorrow> > let inject n xs = uncurry ((++) . (++xs)) . splitAt n in inject 3 [20,30] [1..7]
18:09:19 <MyCatVerbs> moozilla: if you want predictably sized integers, you need to use explicitly sized ones - if you look in Data.Word, you'll find Word8, Word16, Word32, Word64, which are all the unsigned integer types. In Data.Int there are Int8, Int16, Int32 and Int64 for signed arithmetic.
18:09:21 <lambdabot>  [1,2,3,20,30,4,5,6,7]
18:09:37 <MyCatVerbs> moozilla: er, if you want *portable* predictably sized integers, even. :)
18:09:49 <moozilla> ok cool
18:10:09 <yitz> > let inject n xs = uncurry ((++) . (++xs)) . splitAt n in inject 3 [20,30..80] [1..7]
18:10:10 <lambdabot>  [1,2,3,20,30,40,50,60,70,80,4,5,6,7]
18:10:23 <gwern> moozilla: my understanding was that Ints gain speed from not calling out to advanced GMP big integer routines, being stricter, and potentially being unboxed into tiny machine word stuff (at the price of overflows). but until you profile, no idea how germane this discussion is
18:10:31 <yitz> mmorrow: hmm, that's not what the other solutions do
18:10:54 <mmorrow> ahhh
18:11:07 <moozilla> honestly speed isnt a huge issue, i'm probably going to have to slow down the emulator to get a see-able framerate
18:11:25 <MyCatVerbs> Mmmm. With the design as you have it right now, you might not. ¬¬
18:11:38 <moozilla> :P, is it the memory as a list thing?
18:11:39 <MyCatVerbs> (I'm exaggerating, but not very much.)
18:11:44 <MyCatVerbs> Yes, that will kill you.
18:11:59 <moozilla> hmm
18:12:03 * moozilla looks up mutable arrays
18:12:04 <MyCatVerbs> But don't worry about it. Concentrate on getting it working first.
18:12:05 <rwbarton> You could use an IntMap Integer
18:12:14 <MyCatVerbs> Yes, IntMap would be a good idea.
18:12:26 <mmorrow> > let inject n xs = uncurry ((++) . (++xs)) . fmap (drop $ length xs) . splitAt n in inject 3 [20,30] [1..7]
18:12:28 <lambdabot>  [1,2,3,20,30,6,7]
18:12:37 <yitz> or a Data.Sequence
18:12:39 <MyCatVerbs> You can relatively painlessly convert a list solution to an IntMap or ST monad solution, though, so don't panic about it.
18:13:04 <MyCatVerbs> yitz: for emulating RAM? I hope not. ;P
18:13:26 <moozilla> ?hoogle IntMap
18:13:29 <lambdabot> Data.IntMap :: module
18:13:29 <lambdabot> Data.IntMap.IntMap :: data IntMap a
18:14:15 <yitz> MyCatVerbs: not much different than a Map.
18:14:27 <rwbarton> If you're familiar with Map, IntMap a is pretty much the same as Map Int a except it uses a more efficient data structure specialized to Int keys
18:14:54 <moozilla> i'm not familiar with Map
18:15:01 <moozilla> assuming it's not the same as the function map
18:15:50 <MyCatVerbs> moozilla: no it isn't. It's a dictionary, using balanced binary search tree.
18:16:09 <moozilla> okay, sounds like what i need
18:16:17 <moozilla> how do i access elements of it though
18:17:18 <rwbarton> > let m = IM.fromList [(1, "one"), (2, "two")] in m IM.! 1
18:17:20 <lambdabot>  "one"
18:17:44 <mmorrow> > foldl' (\m i -> M.insertWith (+) i 1 m) mempty . take 100000 . randomRs (0,9::Int) . mkStdGen $ 442421234
18:17:45 <lambdabot>  fromList [(0,10019),(1,9977),(2,10010),(3,9843),(4,10015),(5,9906),(6,10110)...
18:18:24 <MyCatVerbs> rwbarton: huh. Where's \bot's mapping from from IM to Data.IntMap documented, please?
18:18:47 <mmorrow> > let n = 100000 in fmap ((/fromIntegral n) . fromIntegral) . M.toList . foldl' (\m i -> M.insertWith (+) i 1 m) mempty . take n . randomRs (0,9::Int) . mkStdGen $ 442421234
18:18:48 <rwbarton> MyCatVerbs: beats me.  I just guessed :)  (tried some things in /msg lambdabot)
18:18:49 <lambdabot>   add an instance declaration for (Integral (Int, a))
18:19:09 <MyCatVerbs> rwbarton: damn. And there I was hoping you'd be able to tell me what all the other aliases are. Oh well. :)
18:19:39 <rwbarton> I could tell you what I would guess all the other aliases are :)
18:19:40 <mmorrow> > let n = 100000 in (fmap .fmap) ((/fromIntegral n) . fromIntegral) . M.toList . foldl' (\m i -> M.insertWith (+) i 1 m) mempty . take n . randomRs (0,9::Int) . mkStdGen $ 442421234
18:19:42 <lambdabot>  [(0,0.10019),(1,9.977e-2),(2,0.1001),(3,9.843e-2),(4,0.10015),(5,9.906e-2),(...
18:19:48 <MyCatVerbs> moozilla: you build them with either fromList or empty and insert, access elements with (!), update elements with either insert or insertWith.
18:20:05 <moozilla> alright
18:20:19 <moozilla> let's see if i can convert my existing implementation to IntMap
18:20:47 <mmorrow> > IntMap.empty
18:20:49 <lambdabot>   Not in scope: `IntMap.empty'
18:20:52 <mmorrow> > I.empty
18:20:52 <twanvl_> the list of imports is in scripts/Runplugs.hs in the λbot source
18:20:53 <lambdabot>   Not in scope: `I.empty'
18:21:04 <moozilla> also, while i'm at it, is there a better way to represent a set of 16 integers
18:21:10 <moozilla> for registers
18:21:17 <moozilla> right now i have them in a list
18:21:27 <moozilla> however that seems inefficient
18:21:42 <lispy> Huh, is λ a valid character in nicks?
18:21:52 <twanvl_> are the integers [0..15]?
18:22:01 <MyCatVerbs> lispy: nnn... maybe?
18:22:06 <lispy> renaming her to λ or λbot would be interesting...maybe painful to type though :)
18:22:27 <lispy> (I'm just using copy and paste as I have no idea what that keystroke is)
18:22:34 <MyCatVerbs> lispy: no, it isn't, I think.
18:22:54 <moozilla> twanvl: they are variables
18:23:01 <lispy> anyone know on mac osx what you type for lambda?
18:23:24 <mmorrow> i just put it here: http://code.haskell.org/~morrow/code/haskell/misc/imports.h.txt
18:23:36 <mmorrow> > IM.empty
18:23:40 <lambdabot>  fromList []
18:23:49 <Cale> In Gnome I type λ by hitting both shift keys to switch to a Greek keyboard layout, and then pressing l.
18:24:23 <MyCatVerbs> lispy: RFC1459 specifies that nicknames always match <letter> { <letter>|<digit>|<special> } *
18:24:26 <mmorrow> > foldl' (\m i -> IM.insertWith (+) i 1 m) mempty . take 100000 . randomRs (0,9::Int) . mkStdGen $ 442421234
18:24:27 <lambdabot>  fromList [(0,10019),(1,9977),(2,10010),(3,9843),(4,10015),(5,9906),(6,10110)...
18:24:36 <Cale> I also have SCIM, so I can type \lambda and it'll be turned into λ
18:24:53 <Cale> (when in LaTeX-mode)
18:25:29 <mmorrow> > BS.unsafeHead DB.empty
18:25:30 <lambdabot>   Not in scope: `DB.empty'
18:25:33 <mmorrow> > BS.unsafeHead BS.empty
18:25:34 <lambdabot>   Not in scope: `BS.unsafeHead'
18:25:35 <MyCatVerbs> lispy: letter is defined as [a-zA-Z], digit is defined as [0-9] and special is defined as any of - [ ] \ ` ^ { }. No room in there for unicode.
18:25:41 <lispy> on mac you can hold option to get some greek letters, but I can't find lambda
18:25:49 <lispy> MyCatVerbs: ah, okay
18:26:01 <moozilla> initialMem program = (replicate 0x200 0) ++ program ++ replicate (0xFE00 - (length program)) 0
18:26:07 <moozilla> that's a [Int] -> [Int]
18:26:19 <moozilla> how can i change that to [Int] -> IntMap
18:26:42 <MyCatVerbs> Cale: just wish SCIM wasn't such a Πain in the αρσϵ. :)
18:27:02 <MyCatVerbs> Cale: out of curiosity, what terminal emulator do you use, please?
18:27:20 <Cale> MyCatVerbs: gnome-terminal, but I use X-Chat for IRC.
18:27:35 <MyCatVerbs> Cale: does gnome-terminal play nicely with IRC, please?
18:27:43 <Sartak> > product [1..6]
18:27:43 <MyCatVerbs> Er, SCIM, not IRC.
18:27:44 <lambdabot>  720
18:27:51 <Cale> Uh, I think so. It supports UTF-8 characters, anyway.
18:28:04 <Cale> If the IRC client you're using does as well, it should be fine.
18:28:20 <bwr> I am using gnome-terminal and irssi and i can see unicode characters just fine
18:28:22 <MyCatVerbs> Oh hey, yes it does.
18:28:45 <yitz> moozilla: initialMemIM = fromList . zip [0..] . initialMem
18:29:06 <moozilla> yitz: thank you
18:29:09 <Cale> MyCatVerbs: Oh, I missed the s/IRC/SCIM/, but yeah :)
18:29:49 <MyCatVerbs> Huh.
18:30:05 <MyCatVerbs> Cale: what screws with my head is that gnome-terminal appears to be cooperating better with SCIM than mlterm does.
18:30:26 <Axman66> would someone be able to explain to me why "foldr1 (\x y -> (read [x]) + (read [y])) "123"" doesn't add the numbers in the list? (using read [x] :: Int doesn't work either)
18:30:52 <Cale> Axman66: y would be an integer.
18:31:19 <Cale> > foldr (\x y -> read [x] + y) 0 "123"
18:31:20 <lambdabot>  6
18:31:21 <Axman66> well i put :: Int after both read's and it didn't work
18:31:23 <MyCatVerbs> Cale: oh and urxvt absolutely cannot cooperate with SCIM at all for some reason. This makes me :(
18:31:27 <Axman66> hmm
18:31:34 <Axman66> oh, i get it
18:31:39 <Cale> > foldr1 (\x y -> read [x] + y) "123"
18:31:40 <lambdabot>   add an instance declaration for (Num Char)
18:31:40 <lambdabot>     In the expression: read [x] + y
18:31:54 <Cale> oh, I see, yeah, that's tough :)
18:31:58 <Cale> :t foldr1
18:31:59 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:32:06 <Cale> Can't change the element type with foldr1
18:32:17 <Cale> So the result would have to be a Char ;)
18:32:48 <Axman66> yeah :\
18:32:51 <Cale> MyCatVerbs: hmm...
18:33:04 <Axman66> and it seems there's nothing with the.. wait, i think i did see something
18:33:26 <Cale> I'll try urxvt here.
18:33:48 <Axman66> foldr (\x y -> read [x] + y) 0 "123"
18:33:52 <Cale> SCIM was generally poorly integrated until I used Ubuntu's language support to install it.
18:33:57 <MyCatVerbs> Cale: I've looked for documentation on how to get it to work with SCIM here, I find people saying they've gotten it working. But when I duplicate their (documented) actions, I get no response.
18:33:59 <Axman66> there we go
18:34:33 <Axman66> still, it would be nice if foldr1 allowed (a -> b -> b)
18:34:41 <Axman66> but, i guess you do need a starting position
18:34:45 <Cale> Axman66: of course, that's impossible :)
18:34:57 <MyCatVerbs> Cale: like it works with Firefox, gedit, basically everything using GTK2+. Also works with mlterm, albeit mlterm's support is decidedly poor (no nice popup detailing possible completions, etc).
18:35:17 <Cale> hmm
18:35:54 <MyCatVerbs> The point of foldr1 & foldl1 is that they use the initial element of the list as the base case for the fold. So of course you can't change the element type. :P
18:36:08 <Axman66> @src ($)
18:36:08 <lambdabot> f $ x = f x
18:36:13 <MyCatVerbs> You could do foldl1' (+) . map (\x -> read [x]), though.
18:36:20 <Cale> Well, in foldr1's case, it's the final element of course
18:36:27 <dolio> @remember JonHarrop Microsoft now have a monopoly over modern functional programming languages.
18:36:27 <lambdabot> Good to know.
18:36:35 <MyCatVerbs> Cale: oh, aye.
18:36:39 <MyCatVerbs> > foldl1' (+) . map (\x -> read [x]) $ "123"
18:36:40 <lambdabot>  6
18:36:49 <Axman66> MyCatVerbs: yeah that's what i was doing originally
18:36:50 <gwern> @quote monopoly
18:36:50 <lambdabot> JonHarrop says: Microsoft now have a monopoly over modern functional programming languages.
18:36:52 <gwern> @quote monopoly
18:36:52 <lambdabot> JonHarrop says: Microsoft now have a monopoly over modern functional programming languages.
18:37:02 <MyCatVerbs> Axman66: that's probably what you should be doing, then. :)
18:37:05 <gwern> dolio: that a fresh harropism?
18:37:15 <dolio> Yes.
18:37:27 <Axman66> MyCatVerbs: but... shortness :P
18:37:38 <moozilla> @src (.)
18:37:38 <lambdabot> (f . g) x = f (g x)
18:37:38 <lambdabot> -- In lambdabot, it's been generalised to:
18:37:38 <lambdabot> (.) = fmap
18:37:44 <Axman66> using it to redo my answer to problem 16 on project euler btw
18:37:46 <rwbarton> > sum . map (read . return) $ "123"
18:37:47 <lambdabot>  6
18:37:49 <MyCatVerbs> Axman66: concision is not a substitute for clarity. ;P
18:37:51 <dolio> He's gushing about F# because it has the best performance in the 'recursive' benchmark on the shootout or something.
18:38:16 <moozilla> F#, heh
18:38:24 <MyCatVerbs> Axman66: personally, I prefer the map-then-sum to folding all in one go because the types seem saner.
18:38:45 <dolio> I guess he has to, since he just wrote a book on it.
18:38:47 <Axman66> yeah
18:38:56 <Axman66> i did use a sum version at one point
18:39:09 <MyCatVerbs> Axman66: it reads more as "convert these characters to integers, sum the integers", rather than "run down this list, converting to integers and summing as you go".
18:39:17 <Axman66> i also used foldr1 instead of sum by accident originally :P
18:39:27 <lispy> dolio: he wrote an F# book?
18:39:40 * MyCatVerbs has a hunch...
18:39:48 <lispy> dolio: is it just based on his Ocaml book by any chance?
18:39:56 <yitz> Axman66: you often need to use foldl' (+) 0 instead of sum.
18:40:13 <gwern> seems kind of premature to write an F# book, isn't it still very young?
18:40:18 <dolio> lispy: I don't know. I haven't read either.
18:40:35 <Axman66> yitz: how come?
18:40:42 <dolio> He did just post some guy's review of his book on c.l.f.
18:40:45 <lispy> gwern: The youngness might be debatable...it is based heavily on ocaml
18:40:50 <yitz> @src sum
18:40:51 <lambdabot> sum = foldl (+) 0
18:40:57 <Axman66> heh, ok
18:41:01 <dolio> "Looks like I've done it again. :-)"
18:43:05 <lispy> I have mixed feelings about ocaml.  If wish if MS was going to make a "mainstream" FP language for .NET that it was Haskell with GHC's extensions.  Otoh, if this means I may get to write F# instead of C# code in the future, well, maybe it's not so bad.
18:43:56 <gwern> dolio: he and nietzsche should get together
18:44:11 <Axman66> i don't think i've ever understood any Ocaml i've ever read. it's not a very clear language
18:44:20 <gwern> 'Why I Am So Great' vs 'Why My FP Language Is So Great'
18:44:26 <dolio> Was Nietzsche shameless about self-promotion?
18:44:32 <Associat0r> speaking of F# http://lorgonblog.spaces.live.com/blog/cns!701679AD17B6D310!347.entry can anyone tell my why an IDE couldn't figure out the order of compilation itself like Visual Haskell does?
18:44:36 <lambdabot> http://tinyurl.com/6mbwzy
18:44:43 <MyCatVerbs> lispy: honestly, I suspect I might rather see a strict ML language become "mainstream" than Haskell, since Haskell's strategy so far has been to avoid success at all costs - and it seems to have worked reasonably.
18:45:14 <gwern> dolio: the essays in _Ecce Homo_ have infamously grandiose titles. they are a bit tongue-in-cheek, tho
18:45:23 <ramesh> i am a haskell newbie. i am trying to create a function scale which will apply replicate to a list of lists or to a list
18:45:28 <ramesh> >scale m n xs 	| m==0 = concatMap (replicate n) xs
18:45:32 <Axman66> I still haven't found a really good practical use for haskell, except for solving mathematical problems
18:45:42 <ramesh> >| otherwise =  concatMap ( scale (m-1) n ) xs
18:45:43 <MyCatVerbs> lispy: just plain ol' SML is, let's not forget, a damnably good programming language, and reasonably predictable in its performance and workings.
18:45:54 <ramesh> can some one help me what is wrong with my code
18:46:26 <lispy> MyCatVerbs: I like GHC's extensions :)
18:46:33 <lispy> MyCatVerbs: and I like type classes
18:46:46 <Axman66> can a function have a type sig. of [[a]] -> ... and [a] at the same time?
18:46:49 <lispy> MyCatVerbs: laziness I can sit on the fence about
18:46:50 <byorgey_> ramesh: ah, that's tricky because of the types.
18:47:23 <lispy> Axman66: well, [a] -> a, can take the form [[a]] -> [a],
18:47:29 <Axman66> yeah
18:47:50 <Axman66> but, can it work for [[a]] -> a and [a] -> a at the same time?
18:48:12 <byorgey_> ramesh: let me think about this for a minute.
18:48:12 <lispy> No, because that would require [a] to unify with a which creates an infinite type I'm guessing
18:48:23 <Axman66> yeah
18:48:32 <MyCatVerbs> lispy: laziness often trips people up in bad ways.
18:48:33 <ramesh> lispy: that is the message i get from the compiler
18:48:33 <Axman66> so, is what ramesh asking possible?
18:49:05 <rwbarton> Axman66: I think the phrase "apply replicate to a list of lists or to a list" is not a totally accurate description of what ramesh wants to do.
18:49:12 <MyCatVerbs> lispy: hypothetically, let's say F# does become mainstream in another fifteen years - what'll happen then? For one thing, Haskell won't look anywhere -near- as foreign to programmers as it does today.
18:49:30 <lispy> MyCatVerbs: Sure.  I'm on the fence about laziness.  But, the type system seems more powerful from the Haskell I've done.  Just consider the oddness in Ocaml where you have .+ and + but in Haskell you have (+) defined on Num a
18:49:56 <MyCatVerbs> lispy: yeah, true. OCaML's lack of overloading seems like a bit of a bummer.
18:49:59 <lispy> MyCatVerbs: yeah, I do like that side effect, but what if they instead sa, "Well, I have F# and Haskell isn't different enough."
18:50:21 <gwern> IMO, I don't buy into harrop's zero-sum theories. we may not particularly like common lisp or scheme or F#, but a defeat for them is a defeat for us as FPers
18:50:33 <Axman66> anyway, i have to get to my materials lecture. thanks Cale and MyCatVerbs
18:50:37 <gwern> I do hope we see ourselves as FPers first and haskellers second
18:50:37 <byorgey_> ramesh: you can do it if you use map instead of concatMap.
18:50:40 <MyCatVerbs> Axman66: no worries.
18:50:51 <MyCatVerbs> Axman66: have fun.
18:50:59 <ramesh> ok
18:51:16 <ramesh> but concat is also supposed to do [[a]]->[a]
18:51:19 <MyCatVerbs> lispy: but seriously, imagine the hordes of ex-VB4 programmers coming into contact with laziness for the first time in their lives. The resulting explosion in ass-slow applications that blow their stacks every five minutes would _murder_ Haskell's reputation. ;P
18:51:24 <ramesh> or am i wrong in assuming that
18:52:09 <MyCatVerbs> gwern: agreed! As fun as Haskell is, there's still a much bigger gap between having to hack in C versus, say, Scheme, than there is between hacking in Scheme and Haskell.
18:52:20 <lispy> MyCatVerbs: you mean in the same way it has hurt VB's reputation?
18:52:38 <MyCatVerbs> lispy: no, because I suspect it would actually be worse.
18:53:17 <yitz> MyCatVerbs: what do you mean. VB4 programmers are the epitome of laziness.
18:53:18 <MyCatVerbs> lispy: Haskell is inherently trickier. We're talking about the same level of intellect being applied to a much greater challenge, resulting in much messier failures.
18:53:29 <MyCatVerbs> gwern: and I'm sure Agda programmers would probably say the same about Haskell, etc. ^^
18:53:40 <ramesh> byorgey_ : i get the same error with map also
18:54:04 <MyCatVerbs> yitz: well, those who still hack in VB4 are, since they can't even be bothered to upgrade their compiler or OS. ;P
18:54:12 <monochrom> There will be ex-VB4 programmers?  I don't think VB is dying any time soon.
18:54:31 <gwern> MyCatVerbs: I sometimes wonder what it's like in rarefied worlds like agda. we must look blublike to them, but I couldn't say how
18:54:44 <MyCatVerbs> monochrom: mmmyes. There already are ex-VB4 programmers. These days they're called VB.NET programmers, usually.
18:55:26 <monochrom> VB.NET is viable and ex-VB4 programmers live happily in VB.NET.
18:55:46 <monochrom> I mean they don't worry about transiting to Haskell and we shouldn't worry either.
18:56:07 <MyCatVerbs> gwern: I don't even need to look to Agda for that. ∃ programmers who use mere Haskell features that bewilder me, and the rationales for which I cannot understand.
18:57:03 <MyCatVerbs> monochrom: if Haskell ever became "mainstream", a "lot" of them would at least try it, flail about fruitlessly, then start badmouthing it. FSVO "mainstream" and "lot". ;P
18:57:38 <monochrom> No one blackmouths the mainstream, FSVO mainstream.
18:58:10 <MyCatVerbs> monochrom: aren't Java and the CLI both mainstream? I hear people badmouthing both.
18:58:11 <monochrom> Or rather, whatever blackmouth effort is futile.
18:58:19 <lispy> MyCatVerbs: outside of Oleg, what features are people using that bewilder you?
18:58:41 <rwbarton> ramesh: I think there's a type reason you can't write your function
18:58:57 <monochrom> Yes, I hear fringe communities like #haskell blackmouth Java. No impact.
18:59:00 <rwbarton> ramesh: Consider a call  scale m n xs
18:59:09 <rwbarton> ramesh: Maybe m = 0, in which case xs just needs to be a list.
18:59:18 <rwbarton> ramesh: But if m = 1, then xs needs to be a list of lists.
18:59:26 <SamB> lispy: what features do people use INSIDE of oleg?
18:59:42 <lispy> SamB: Let me answer that in #haskell-blah ;)
18:59:55 <rwbarton> ramesh: If m = 2, then xs needs to be a list of lists of lists, and so on.  The compiler doesn't know what m is at compile time, and there's no type which is a list of lists of lists of ...
18:59:56 <monochrom> Hell, Java community blackmouths C#, C# community blackmouths Java. Still no impact.
19:00:31 <MyCatVerbs> lispy: SYB, most of the type system extensions. GADTs, for example, I have no idea even -whether- they are useful.
19:00:46 <lispy> Ah
19:00:54 * rwbarton wonders whether in 20 years we will all program in a language called 'oleg'
19:01:01 <MyCatVerbs> lispy: SYB in particular, I can't quite figure out why people bother to use it at all. It looks like it involves investring more work than it saves.
19:01:07 <bwr> rwbarton: oleg?
19:01:08 <MyCatVerbs> rwbarton: no, we won't.
19:01:11 <monochrom> Hell, in the US, Republicans and Democrats have blackmouthed each other for 100 years. Still no impact. :)
19:01:26 <ramesh> rwbarton: thanks for the explanation
19:01:28 <lispy> MyCatVerbs: Well, I know of some good uses for GADTs, I can see how SYB is nice but have never used it and type system extensions can be nice...like in standard libs they use fundeps
19:01:42 <Sartak> man, the Rendering JSON chapter of Real World Haskell is where it gets a little hard to follow
19:01:57 <Sartak> it uses the m word!
19:02:25 <mmorrow> microscope?
19:02:35 <lispy> mandible
19:02:41 <dolio> @seen dons
19:02:41 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 55m 8s ago.
19:03:09 <lispy> MyCatVerbs: Have you ever tried to embed a language inside of Haskell's type system?
19:03:38 <lispy> MyCatVerbs: if you do, and you want a simple way to type check your embedding using Haskell's type checker, GADTs are really handy
19:04:28 <MyCatVerbs> rwbarton: I absolutely guarantee that we will never use a language called Oleg.
19:04:48 * moozilla goes back in time and renames haskell 'Oleg'
19:05:04 <MyCatVerbs> rwbarton: because, y'see, when someone does get around to creating that language, they will call it Kiselyov instead.
19:05:33 <mmorrow> or someone in marketing'll call it to "jello" or something
19:05:37 <SamB> MyCatVerbs: that would be stupid
19:05:48 <lispy> mmorrow: haha
19:05:56 <MyCatVerbs> SamB: so was giving Haskell a name that's so often mistaken for "Pascal". ;P
19:05:57 <lispy> jello sounds like a dynamic language
19:06:19 <SamB> that would be like naming something after Ken but calling it Thompson
19:06:24 <chylli> @help
19:06:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:06:29 <chylli> @list
19:06:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:07:31 <lispy> Someone should make yet another multi-paradigm language and call it Prius
19:07:56 <MyCatVerbs> lispy: huh, cool. No, I've never tried embedding a language in the type system, hence I've never hit that use case. Fundeps and multiparam type classes do make perfect sense though because I've run into cases where I needed to use them.
19:08:35 <lispy> MyCatVerbs: My current use of GADTs is a bit far out though and I can understand if you wouldn't appreciate it
19:08:54 <lispy> MyCatVerbs: we use it to enforce sequencing in lists
19:08:59 <lispy> among other things
19:09:11 <lispy> but that one is the most readily available conceptually
19:09:36 <lispy> The elements know what order they can be placed in, and the cons cells are taught to respet that
19:09:46 <MyCatVerbs> Oh cool.
19:10:00 <MyCatVerbs> Adding GADTs makes the type checking Turing-complete, doesn't it?
19:10:09 <dolio> Anyone have both 6.8.2 and 6.8.3 handy, and is looking for something to do?
19:10:22 <MyCatVerbs> dolio: surprisingly, yes. What can I do for you?
19:10:30 <lispy> MyCatVerbs: I'm not sure.  I don't think so.  But, I think GADTs plus just about any extension would cause that.
19:10:49 <dolio> MyCatVerbs: Snatch the Recursive benchmark from the shotout, and see if it's way slower with the latter.
19:10:52 <Philippa> MyCatVerbs: They don't
19:10:53 <SamB> undecidable instances does
19:11:01 <dolio> MyCatVerbs: http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive&lang=ghc&id=0
19:11:03 <lambdabot> Title: recursive Haskell GHC program | Gentoo : Intel® Pentium® 4 Computer Language B ..., http://tinyurl.com/5r25kv
19:11:53 <MyCatVerbs> Right. I was under the impression that both did.
19:11:57 <chessguy> @type maybe
19:11:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:12:39 <chessguy> @hoogle Maybe a -> a -> a
19:12:40 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
19:12:40 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
19:12:40 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
19:12:55 <chessguy> @src fromMaybe
19:12:55 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
19:14:20 <MyCatVerbs> dolio: what range of parameters is reasonable for this?
19:14:42 <dolio> I've been running it with 11, per the shootout.
19:16:51 <MyCatVerbs> dolio: right. Compiling with ghc --make -O2 -fglasgow-exts -optc-O2 -optc-mfpmath=sse -optc-msse2 Recursive.hs, in both cases.
19:17:26 <MyCatVerbs> dolio: 683 takes about 13 and a half seconds.
19:17:47 <MyCatVerbs> dolio: 682 takes about 2.3 seconds. Crap, that's a regression.
19:18:02 <dolio> MyCatVerbs: Okay, good, it's not just me.
19:18:07 <dolio> 6.8.3 fails to specialize fib and tak.
19:18:13 <MyCatVerbs> Indeed, it's not just you. :)
19:18:48 <dolio> Bug report time, I guess.
19:23:33 <MyCatVerbs> dolio: http://www.cs.bris.ac.uk/home/rb6822/Recursive682-core.html http://www.cs.bris.ac.uk/home/rb6822/Recursive683-core.html
19:23:54 <MyCatVerbs> dolio: ghc-core's output with 682 and 683, respectively.
19:24:31 <dolio> Wait, 683 is "... ExitFailure 127"?
19:24:42 <MyCatVerbs> ...dammit.
19:25:06 <dolio> Anyhow, if I add back in SPECIALIZE pragmas, the 6.8.3 core looks like the 6.8.2 core you posted.
19:25:30 <MyCatVerbs> Hah. If you reload again, you'll see it now. :)
19:25:32 <dolio> But without it, the functions are still polymorphic, with lots of dictionary destruction.
19:25:47 <MyCatVerbs> Hell of a lot less inlining too, apparently?
19:26:09 <dolio> Possibly, although I don't know how well those functions inline.
19:26:27 <MyCatVerbs> Oh wow. 682's code for that looks (physically) nice.
19:26:44 <MyCatVerbs> 683's is, uh, bletcherous in appearance. ;P
19:26:59 <dolio> Yeah, it's pretty bad.
19:27:17 <MyCatVerbs> Why do fib and tak have to have (Num a,Ord a) => a -> a ... instead of just Int -> Int or somesuch?
19:27:32 <dolio> They're used at both Int and Double.
19:27:34 <MyCatVerbs> Or Double -> Double, even.
19:27:36 <MyCatVerbs> Ah, I see.
19:27:54 <SamB_XP> Double -> Double ???
19:27:55 * MyCatVerbs makes a mental note: the SPECIALIZE pragma is -powerful-.
19:28:17 <SamB_XP> so ... how far out does it stay accurate?
19:28:37 <dolio> The 6.8.3 code appears to take apart the dictionaries multiple times, even.
19:29:09 <dolio> Like it's doing loop unrolling or something.
19:29:17 <MyCatVerbs> SamB_XP: if I had to guess, up 'til ~2^53. ;P
19:30:03 <MyCatVerbs> Heh. <3 GHC - "SPECIALIZE PRAGMA (UK spelling also accepted):". :)
19:31:34 <glguy_> {-# LANGUAGE en-GB, Rank2Types .... #-}
19:31:43 <SamB_XP> MyCatVerbs: not that strange
19:31:58 <SamB_XP> Allegro accepts both COLOR and COLOUR
19:32:04 <SamB_XP> does it not?
19:32:16 <MyCatVerbs> SamB_XP: maybe. It's a nice touch, for certain.
19:32:22 <lispy> Allegro my eggo
19:32:45 <SamB_XP> personally, I would have been quite surprised if GHC accepted the american spelling only
19:33:22 <MyCatVerbs> SamB_XP: considering where it's written, it would've been confusing. :)
19:34:30 <dolio> MyCatVerbs: Can I link to those core pages on the bug report, or are they going to disappear?
19:34:54 <dococtagon> Hi, can someone tell me which diagramming tool was used to make the figures the Huet's-Zipper article (http://en.wikibooks.org/wiki/Haskell/Zippers)? I suspect that it's omni graffle...
19:35:28 <MyCatVerbs> dolio: good... question, I didn't think of that at all.
19:36:17 <MyCatVerbs> dolio: they're guaranteed not to last more than about two years from today. Aside from that, I'll make a note to not remove them. :)
19:36:31 <MyCatVerbs> dolio: if that's acceptable then feel free. :)
19:36:32 <dolio> Heh, I'm sure that will be sufficient.
19:36:42 <SamB_XP> pesky universities
19:36:56 <MyCatVerbs> SamB_XP: eh. The university isn't really the main risk here.
19:37:01 <TSC> I've downloaded the GHC 6.8.3 binaries and this happens; have I done something wrong?
19:37:02 <TSC> chris@server:~/ghc/ghc-6.8.3$ utils/pwd/pwd
19:37:02 <TSC> Floating point exception
19:37:19 <MyCatVerbs> SamB_XP: the most likely cause of them disappearing would be me forgetting why they're there and blowing them away. >_<
19:37:27 <glguy_> TSC: delete utils/pwd/pwd
19:37:52 <SamB_XP> MyCatVerbs: well, I meant, being so miserly with webspace and so forth, deleting it all so soon after graduation
19:38:11 <MyCatVerbs> SamB_XP: oh. I have no idea whether they will, I just can't think of any reason why they wouldn't.
19:38:15 <moozilla> how would i load a file as an [Int] with each Int being a byte of data
19:38:37 <TSC> glguy_: Really?  The other utils (e.g. hasktags) also give the floating point exception
19:38:39 <lispy> Word8 or Int8 ?
19:38:48 <SamB_XP> or ... practically any other manner of leaving the university, even potentially-temporary!
19:38:53 <lispy> moozilla: I bet Data.ByteString is what you want
19:39:03 <moozilla> Word8 i think but i'm just using Int
19:39:36 <glguy_> TSC: you can use the file(1) command to make sure that the architecture matches what you have
19:39:39 <lispy> moozilla: well, Word8 is a type, so you could read [Word8]
19:39:40 <MyCatVerbs> moozilla: you would probably prefer a [Word8] to an [Int]. If you really -do- want [Int], use readFile and (map Data.Char.ord).
19:40:04 <glguy_> TSC: the version of utils/pwd/pwd in particular was bad when I downloaded the src tarball
19:40:32 <moozilla> @src Word8
19:40:32 <lambdabot> Source not found. It can only be attributed to human error.
19:40:40 <lispy> ?hoogle Word8
19:40:41 <lambdabot> Data.Word.Word8 :: data Word8
19:40:41 <lambdabot> Data.ByteString.Internal.isSpaceWord8 :: Word8 -> Bool
19:40:44 <TSC> glguy_: I think it's compiled against the wrong version of libc
19:40:45 <bd_> data Word8 = GHC.Word.W8# GHC.Prim.Word#        -- Defined in GHC.Word
19:40:52 <MyCatVerbs> moozilla: er, I mean, the easiest way is to use readFile and map ord. You'd probably be better off using ByteString IO, and then unpack to get a [Word8], and then - if necessary - map fromIntegral to turn that into an [Int].
19:41:20 <MyCatVerbs> !
19:41:27 * lispy agrees wth MyCatVerbs 
19:41:41 <MyCatVerbs> moozilla: Word8 is in Data.Word. Please don't go playing around with Word#'s until it turns out that you really REALLY need to!
19:41:42 <moozilla> alright
19:41:44 <glguy_> fromEnum  can be : Word8 -> Int
19:42:05 <MyCatVerbs> glguy_: oh aye, good idea.
19:42:12 <moozilla> I'm just using Int's to make it less confusing
19:42:17 <MyCatVerbs> In fact, fromEnum can be Char -> Int too, which is always nice. ^^
19:42:24 <moozilla> the memory space should be Word8 technically
19:42:40 <dobblego> does template haskell require a GHC extension or is it standard Haskell syntax?
19:42:50 <MyCatVerbs> dobblego: it's a GHC extension.
19:42:57 <dobblego> ok ta
19:42:57 <lispy> dobblego: template haskell is specific to GHC's implementation
19:43:07 <SamB_XP> ... at the moment, anyway
19:43:29 <SamB_XP> ... there's no real reason it has to be...
19:43:46 <lispy> SamB_XP: perhaps not enouh Ian's to have it on other implementations
19:44:42 <MyCatVerbs> SamB_XP: I get the impression it's not stable enough to be worth adding to other implementations, though. Aren't loads of the details still in flux even now?
19:45:01 <SamB_XP> MyCatVerbs: it seems like a pretty slow flux to me
19:45:19 <SamB_XP> I mean, not all that long ago I cought it missing a Functor instance ...
19:45:37 <SamB_XP> it had been missing for a while ...
19:46:17 <MyCatVerbs> SamB_XP: huh. Well, incomplete, then.
19:47:01 <SamB_XP> I mean, I guess they change it now and then when GHC adds a new typesystem extension ...
19:49:08 <MyCatVerbs> Do those changes ever end up breaking old code, though?
19:50:08 <moozilla> how would i import only the ByteString type and readFile ?
19:50:43 <dolio> import Data.ByteString.Whatever (ByteString, readFile)
19:50:53 <SamB_XP> I'm sure it's happened before, but I imagine it most often happens when code is pulling apart syntax rather than constructing it...
19:51:05 <moozilla> dolio: thanks but what's the Whatever?
19:51:15 <dolio> There are a lot of ByteString modules.
19:51:34 <lispy> moozilla: hoogle is your friend
19:51:37 <lispy> ?hoogle readFile
19:51:38 <lambdabot> Prelude.readFile :: FilePath -> IO String
19:51:38 <lambdabot> System.IO.readFile :: FilePath -> IO String
19:51:38 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
19:51:57 <SamB_XP> @hoogle FilePath -> IO ByteString
19:51:58 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
19:51:58 <lambdabot> Data.ByteString.Char8.readFile :: FilePath -> IO ByteString
19:51:58 <lambdabot> Data.ByteString.Lazy.readFile :: FilePath -> IO ByteString
19:52:32 <moozilla> alright I think I understand that
19:52:39 <moozilla> but how do I specify which readFile to use
19:52:41 <moozilla> in the code
19:52:52 <lispy> moozilla: by importing the right module
19:53:08 <moozilla> can I hide the prelude readFile?
19:53:19 <dolio> Yes.
19:53:27 <dolio> import Prelude hiding (readFile)
19:57:15 <moozilla> @hoogle (Monad m) => m a -> a
19:57:15 <lambdabot> Prelude.id :: a -> a
19:57:15 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
19:57:15 <lambdabot> Data.Function.id :: a -> a
20:00:09 <patc> can anyone help me with some c2hs questions?
20:00:31 <moozilla> MyCatVerbs: i have the file loaded into a ByteString, now how do i turn that into a normal list
20:00:51 <lispy> ?hoogle ByteString -> [Word8]
20:00:52 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
20:00:52 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
20:00:59 <dolio> Don't.
20:01:05 <pjdelport> moozilla: you don't take the value out of the monad, you put your computation into the monad
20:01:29 <moozilla> well i need to turn the data into an IntMap
20:01:48 <dolio> If you read in a ByteString, and then unpack it, you might as well just read in a string.
20:01:49 <pjdelport> :t fmap
20:01:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:02:56 <MyCatVerbs> dolio: he's going to end up folding it all into a finite map anyway.
20:03:11 <lispy> ?hoogle ByteString -> IntMap
20:03:11 <lambdabot> No matches, try a more general search
20:03:29 <moozilla> ?hoogle FileBath -> IntMap
20:03:30 <lambdabot> No matches, try a more general search
20:03:33 <moozilla> ?hoogle FilePath -> IntMap
20:03:34 <lambdabot> No matches, try a more general search
20:03:55 <dolio> What's the ByteString contain?
20:04:03 <moozilla> binary data
20:04:11 <moozilla> from a file
20:04:16 <moozilla> ?hoogle [Word8] -> [Int]
20:04:17 <lambdabot> No matches, try a more general search
20:04:26 <moozilla> ?hoogle Word8 -> Int
20:04:26 <lambdabot> Data.ByteString.count :: Word8 -> ByteString -> Int
20:04:31 <MyCatVerbs> moozilla: there isn't one. You have to write it yourself. Probably (fromAscList . zip [0..] . map fromEnum), to get from a [Word8] to an IntMap Int.
20:05:24 <moozilla> @ty (fromAscList. zip [0..] . map fromEnum)
20:05:25 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:05:37 <MyCatVerbs> @type IM.fromAscList . zip [0..] . map fromEnum
20:05:38 <lambdabot> forall a. (Enum a) => [a] -> IM.IntMap Int
20:05:52 <dolio> @type BS.foldl
20:05:53 <lambdabot> forall a. (a -> Word8 -> a) -> a -> BSC.ByteString -> a
20:07:10 <moozilla> so are Word8's and Int's interchangable?
20:07:22 <moozilla> can I add a Word8 and an Int
20:07:28 <glguy_> no
20:07:39 <MyCatVerbs> moozilla: a Word8 is an unsigned 8-bit integer. An int is a signed (usually 32-bit) integer.
20:07:53 <MyCatVerbs> moozilla: you have to convert one into the other in order to add them.
20:08:02 <moozilla> maybe I shouldn't use Int then
20:08:29 <MyCatVerbs> Well, depends. Are you working with 8-bit stores/loads or something bigger?
20:09:01 <dolio> @type BS.foldl' (\(i,im) w8 -> (i+1, IM.insert i w8)) (0, IM.empty)
20:09:02 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:09:23 <dolio> @type BS.foldl' (\(i,im) w8 -> (i+1, IM.insert i w8 im)) (0, IM.empty)
20:09:24 <lambdabot> BSC.ByteString -> (IM.Key, IM.IntMap Word8)
20:09:25 <dmwit> moozilla: What are you trying to do?
20:09:39 <dmwit> i.e. what would the IntMap be, a map from offset to byte value?
20:09:58 <MyCatVerbs> dmwit: simulate a CPU. A map from addresses to contents.
20:10:04 <moozilla> yes
20:10:11 <dmwit> Then why not just use ByteString's addressing?
20:10:16 <dmwit> Isn't there some (!)-alike?
20:10:37 <dmwit> Also, look into that other guy's mmap bindings for Haskell.
20:10:40 <moozilla> not as effecient as an IntMap i assume
20:10:57 <dmwit> An unlikely assumption; have you tested it?
20:11:02 <rwbarton> dmwit: there's no efficient insert on ByteStrings
20:11:08 <moozilla> i'm just a humble newbie
20:11:13 <dmwit> rwbarton: So?
20:11:15 <moozilla> the goal of this is to get it to work
20:11:21 <moozilla> not to be the most effecient :P
20:11:35 <rwbarton> dmwit: I think the goal is to simulate a RAM, not a ROM :)
20:11:37 <dmwit> But if there is a solution that is both more efficient and less work, why wouldn't you use it?
20:11:44 <MyCatVerbs> dmwit: if moozilla's after speed, then it'll end up being rewritten as a gigantic STUArray, probably.
20:11:52 <dmwit> rwbarton: That's why I suggested mmap, it's read/write.
20:12:00 <bd_> Replacing a random byte inside a bytestring is O(n). Replacing a random value in an IntMap is O(lg n). Replacing a random value in a DiffArray is O(1) :)
20:12:16 <moozilla> it isnt neccissarily less work if i have to look up another thing
20:13:52 <dmwit> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mmap
20:13:53 <lambdabot> Title: HackageDB: mmap-0.2
20:13:56 <moozilla> is O(n) slower or faster than O(log n)?
20:14:04 <dmwit> That depends on the constant.
20:14:12 <moozilla> in general?
20:14:16 <dmwit> For large n, a*n > b*log n.
20:14:51 <moozilla> say n is between 0 and 0xFFFF
20:15:17 <MyCatVerbs> moozilla: hard to say without trying it. Again, it depends on the constants involved.
20:15:30 <moozilla> I see
20:15:44 <rwbarton> 65536 is probably large; 16 is probably not large
20:16:32 <glguy_> there is some X that for n > x O(n) > O(lg n)
20:17:08 <moozilla> so in IntMap Word8 does that mean the data is Word8 or the keys?
20:17:10 * MyCatVerbs throws a comma in to disambiguate: for n > X, O(n) > O (lg n)
20:17:11 <dmwit> For any a,b, there exists x such that n > x => a * n > b * log n.
20:17:20 <dmwit> a,b > 0, of course.
20:17:24 <MyCatVerbs> moozilla: it the keys are Ints, the data are Word8s.
20:17:29 <moozilla> ah ok
20:17:52 <moozilla> how do i convert Word16 or Word8 to Int?
20:18:00 <dmwit> fromEnum
20:18:02 <MyCatVerbs> fromEnum.
20:18:03 <moozilla> ?hoogle Word8 -> Int
20:18:03 <lambdabot> Data.ByteString.count :: Word8 -> ByteString -> Int
20:18:14 <MyCatVerbs> Or fromIntegral, but fromEnum is slightly less typing. ;)
20:18:17 <mmorrow> fromIntegral
20:18:21 <moozilla> @ty fromEnum
20:18:22 <lambdabot> forall a. (Enum a) => a -> Int
20:18:28 <moozilla> ok :)
20:18:49 <mmorrow> i think if either is better, it's from Integral. worst case they're equivalent :)
20:18:56 <mmorrow> s/ //
20:18:57 <MyCatVerbs> AFAIK both fromEnum and fromIntegral will (when you turn all the optimizations on) compile down to just about the same microcode.
20:19:05 <dmwit> Does Haskell make any guarantees about the size of an Int?
20:19:13 <glguy_> 29bits or more?
20:19:14 <MyCatVerbs> dmwit: at least 29 bits.
20:19:20 * mmorrow looks for the {-# RULE ... #-}
20:19:27 <dmwit> > odd 29
20:19:28 <lambdabot>  True
20:19:49 <MyCatVerbs> dmwit: aside from that, it's allowed to be anything. So the H98 spec doesn't actually explicitly ban, say, 16MB-wide Ints. :)
20:19:52 <lispy> ?check odd 29
20:19:53 <lambdabot>   Not in scope: `myquickcheck''
20:20:25 <lispy> MyCatVerbs: oh, I wonder if we could convince jhc to support those :)
20:20:40 <dmwit> MyCatVerbs: I would be willing to put up with that, if you just gave me 16MB of address space. ;-)
20:20:52 <dmwit> 2^(2^16) bytes of RAM...
20:20:58 <mmorrow> oh how convenient, i just *happen* to have the relevant code handy ;)
20:21:01 <Elly> that's a nice amount of ram
20:21:01 <mmorrow> {-# RULES
20:21:01 <mmorrow> "fromIntegral/Word8->Word8"   fromIntegral = id :: Word8 -> Word8
20:21:01 <mmorrow> "fromIntegral/Word8->Integer" fromIntegral = toInteger :: Word8 -> Integer
20:21:01 <mmorrow> "fromIntegral/a->Word8"       fromIntegral = \x -> case fromIntegral x of W# x# -> W8# (narrow8Word# x#)
20:21:01 <mmorrow> "fromIntegral/Word8->a"       fromIntegral = \(W8# x#) -> fromIntegral (W# x#)
20:21:02 <mmorrow>   #-}
20:21:08 <mmorrow> http://code.haskell.org/~morrow/code/haskell/ghc/html/Word.hs.html
20:21:08 <dmwit> Hey!
20:21:09 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/59t69w
20:21:19 <dmwit> You're a veteran, you should know to hpaste that. =)
20:21:29 <mmorrow> my bad
20:21:44 <mmorrow> it looks smaller on the web page ;)
20:21:49 <MyCatVerbs> dmwit: AFAIK the rationale for setting the minimum as 29 was that it was large enough for many practical purposes, but by allowing up to three bits to be burned at the top of a 32-bit integer, it'd still facilitate interesting uses of tag bits. :)
20:22:00 <dmwit> boooo
20:22:03 <MyCatVerbs> dmwit: er no. Not 2^(2^16) bytes of RAM - we can do better than that.
20:22:08 <lispy> and in other news, random denizens of #haskell were severly injured in a type-by spamming
20:22:14 <dmwit> MyCatVerbs: Yeah, I realized after writing.
20:22:29 <dmwit> Also: who needs *eight* tags for an Int?
20:22:37 <mmorrow> lispy: is there no RULE of law left!!
20:22:42 <MyCatVerbs> dmwit: pointer tagging.
20:22:50 <MyCatVerbs> dmwit: I think eight was meant to be overkill.
20:23:01 * dmwit nods
20:23:19 <MyCatVerbs> dmwit: we could get you 2^((2^16)+16) bytes by making load/store work at 16MB granularity. :)
20:23:54 <MyCatVerbs> Er, I mean, 2^((2^16)+14), sorry.
20:24:01 <dmwit> You'd better be able to get me 2^(2^(1024*1024*16)) bytes.
20:24:26 <MyCatVerbs> Whoops. +24, no less.
20:24:45 <hansfbaier> >﻿2^(2^(1024*1024*16))
20:24:56 <Twey> MyCatVerbs: That equation crashed KCalc.
20:25:02 <hansfbaier> >﻿ 2^(2^(1024*1024*16))
20:25:04 <MyCatVerbs> > (2^((2^16)+24)) == ((2^(2^16)) * ((2^20) * 16))
20:25:05 <lambdabot>  True
20:25:09 <Twey> Heh
20:25:12 <MyCatVerbs> Twey: weak.
20:25:21 <MyCatVerbs> Twey: hang on, how? I thought they used GMP too.
20:25:31 <Twey> > 2 ^ (2 ^ (1024 * 1024 * 16)) + 24
20:25:33 <dmwit> I guess it would just be 2^(1024*1024*16) 16MB chunks.
20:25:38 <lambdabot> Terminated
20:25:38 <Twey> MyCatVerbs: No idea.  Segfaulted.
20:25:49 * Twey tries it again.
20:25:57 <dmwit> Twey: Maybe you have faulty memory.
20:26:07 <dmwit> Didn't you say the GHC binaries were segfaulting earlier tonight?
20:26:23 <Twey> Not me
20:26:28 <mmorrow> MyCatVerbs: are you familiar with the dataToTag# :: a -> Int# function in GHC.Prim? if so, what is that function's relationship to pointer tagging/etc ?
20:26:57 <moozilla> so when tinkering around in ghci, how can i get a value out of a monad
20:27:19 <pjdelport> depends on the monad
20:27:32 <MyCatVerbs> Twey: well, at a guess, KCalc is written in C++ so it almost certainly has overflow bugs in all of its string-handling, and the result of that computation is just under 20kB long when you convert it to decimal form - longer than one allocation block for most small allocators. :)
20:27:35 <moozilla> the default monad?
20:27:37 <rwbarton> Is it the IO monad?    x <- getLine
20:27:41 * Twey chuckles.
20:27:43 <pjdelport> there is no "default" monad
20:27:49 <moozilla> yes the IO monad *headdesk*
20:28:01 <mmorrow> so, that function's behaviour is:
20:28:04 <mmorrow> let tag a = I# (dataToTag# a) in map tag [Nothing,Just(),Nothing]
20:28:07 <pjdelport> moozilla: if it's a list, you just access the elements
20:28:08 <mmorrow> [0,1,0]
20:28:20 <MyCatVerbs> mmorrow: no. To me, that is part of GHC's low-level black magic which I do not have any grasp upon.
20:28:56 <pjdelport> if it's Maybe, you can use maybe :: b -> (a -> b) -> Maybe a -> b
20:29:01 <moozilla> no i mean if i do something like let test = do file <- readFile "c:\\test.txt"; return file
20:29:13 <moozilla> it still returns an IO String
20:29:14 <mmorrow> the dark side beckons
20:29:20 <pjdelport> for State, there's runState
20:29:22 <pjdelport> and so on
20:29:24 <rwbarton> Right, just write    test <- readFile "c:\\test.txt"
20:29:29 <MyCatVerbs> moozilla: that'll be the IO monad, because readFile :: String -> IO String.
20:29:34 <dmwit> That is exactly equivalent to 'let test = readFile "c:\\test.txt"', by the way.
20:29:50 <MyCatVerbs> Or FilePath -> IO String, I forget. FilePath is just a type alias though, anyway.
20:29:56 <moozilla> ok
20:30:11 <dmwit> But yes, for now, you can do your binding as rwbarton suggests.
20:30:49 <dmwit> You might also want to :set -fno-print-binding or whatever it is.
20:31:03 <dmwit> :set -fno-print-bind-result
20:31:08 <enso> moozilla, you cant get things *out* of the IO monad
20:31:20 <moozilla> yes i think that is what i want
20:31:21 <enso> its a one-way monad
20:31:27 <moozilla> wait
20:31:30 <rwbarton> ghci turns an expression not of type IO a to something like  let it = ... in print it
20:31:44 <moozilla> alright here's exactly what i'm trying to do
20:31:56 <moozilla> i have a function readGame which returns an IO EmulatorState
20:32:00 <rwbarton> then it executes expressions you've entered as though you were writing a do block in the IO monad
20:32:08 <moozilla> i want to get just the EmulatorState to fool around with
20:32:13 <dmwit> too bad
20:32:20 <MyCatVerbs> mmorrow: oooh, that's pretty cool. Like a toEnum for constructors or something? :)
20:32:24 <rwbarton> (This is also why you can write   let x = 3)
20:32:52 <moozilla> hmm
20:32:53 <dmwit> moozilla: When you're mucking about in ghci, bind as rwbarton suggested (s <- readGame).
20:32:58 <enso> moozilla: do emState  <- readGame
20:33:03 <dmwit> It *looks* like you got s out of the monad, but you didn't.
20:33:15 <moozilla> ok, it's just annoying because it prints the whole state
20:33:22 <moozilla> which has 10000 bytes
20:33:27 <dmwit> :set -fno-print-binding
20:33:32 <dmwit> As I suggested earlier.
20:33:51 <moozilla> it says unrecognized flags
20:34:06 <MyCatVerbs> :set -fno-print-bind-result
20:34:32 <moozilla> ah, thanks
20:34:41 <MyCatVerbs> That's the one you want. I usually have that switched on when I'm using GHCi for analysing chunks of data I have lying around on disks. :)
20:34:45 <moozilla> what would i do without #haskell :P
20:34:59 <mmorrow> MyCatVerbs: totally. both
20:35:08 <MyCatVerbs> moozilla: you'd resort to the mailing lists instead, where the answers would come much more slowly but be far more detailed.
20:35:21 <moozilla> heh
20:35:53 <MyCatVerbs> mmorrow: heh. *pokes it again*
20:36:49 <mmorrow> MyCatVerbs: there's also a function that goes the other way, but you'll crash if you de (eg)   tagToData 3 :: Bool
20:36:53 <mmorrow> s/de/do/
20:37:14 <mmorrow> crash and burn!
20:38:10 <MyCatVerbs> mmorrow: cool. Seems to only be up to five values out of the result.
20:38:51 <mmorrow> i think it depends on how many constructors the type you give it has
20:39:12 <mmorrow> (and it tries to get con number whatever type you tell it too ;))
20:39:16 <MyCatVerbs> mmorrow: No, wait, I had that wrong.
20:39:34 <MyCatVerbs> Meh. Just tried it again and I'm seeing more values coming out of it.
20:39:55 <mmorrow> heh. i find it useful for debugging a bunch.
20:40:15 <mmorrow> it's great when you don't even know the constructors of a type, so you can't pattern match
20:40:38 <mmorrow> but info can still be gained by know if the constructor's "number"
20:41:00 <mmorrow> uh, ...
20:41:07 <chylli> how to execute a shell command and capture its output ?
20:41:15 <MyCatVerbs> mmorrow: ...
20:41:21 <MyCatVerbs> mmorrow: that is _very_ evil. Also kind of funny.
20:41:26 <mmorrow> ... gained by knowing the con's num
20:41:35 <mmorrow> haha
20:41:46 <mmorrow> yeah. they can't hide anymore!
20:41:59 <Zao> chylli: There's some relevant libraries on hackage, I believe.
20:42:03 <moozilla> woot got the basics of my emulator working :D
20:42:16 <chylli> Zao: I think so, but don't know which one is
20:42:17 <MyCatVerbs> chylli: take a look at System.Process. (There might be nicer ways on Hackage, I don't know.)
20:42:25 <chylli> thanks
20:42:39 <mmorrow> chylli: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
20:43:00 <chylli> thanks
20:43:27 <mmorrow> chylli: compile with the -threaded flag just to be sure
20:43:51 <chylli> thanks
20:44:11 <mmorrow> noproblem
20:44:17 <MyCatVerbs> chylli: checking Hackage, it seems that it's usually best to use either System.Process or HSH. Most of the alternatives seem to be out of date.
20:44:50 <chylli> thanks
20:45:05 <MyCatVerbs> Of the two, HSH is rather more heavyweight (but does a lot more for you). Most likely you want System.Process.
20:51:27 <hml> data Drawable t = DList [Drawable t] | DSegment (Segment t)
20:51:27 <hml> draw (DList lst) = map draw lst
20:51:27 <hml> gives me an error of: "Occurs check: cannot construct the infinite type: b = [b] Expected type: b Inferred type: [b] In the expression"
20:51:32 <lispy> All of the type variables in the constraint `RepoPatch p' are already in scope (at least one must be universally quantified here)
20:51:37 <lispy> That's an odd error I think
20:52:20 <hml> :t map
20:52:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:52:39 <hml> @src map
20:52:39 <lambdabot> map _ []     = []
20:52:39 <lambdabot> map f (x:xs) = f x : map f xs
20:53:44 <mmorrow> MyCatVerbs: this is a good one:
20:53:46 <mmorrow> (\(I# i) -> tagToEnum# i) 1 :: Bool
20:54:41 <hml> how do I fix 5the following?
20:54:42 <TSC> hml: What do you want the type of "draw" to be?
20:54:43 <hml> http://hpaste.org/9399
20:54:50 <MyCatVerbs> mmorrow: ouch, she segfaults.
20:54:57 <mmorrow> haha
20:55:06 <lispy> hey now
20:55:28 <hml> TSC: Drawable t -> IO ()
20:55:31 <lispy> That's some black magic if you made it segfault without something like FFI
20:55:42 <TSC> hml: Then you don't want map, you mant mapM_
20:55:54 <hml> @src mapM_
20:55:54 <lambdabot> mapM_ f as = sequence_ (map f as)
20:56:02 <MyCatVerbs> lispy: well, steps one and two to getting this to happen are :set -fglasgow-exts and :m GHC.Base.
20:56:15 <hml> TSC: got it htnak
20:56:18 <TSC> Because the type of (map draw) is [Drawable t] -> [IO ()]
20:56:18 <hml> &*tyhank
20:56:29 <TSC> You're welcome (:
20:56:30 <MyCatVerbs> lispy: and the general rule is that _everything_ with a "#" on the end is a) not portable and b) unsafe.
20:56:41 <lispy> MyCatVerbs: ah
20:56:58 * lispy grumbles about the automatic light system at night turning off repeatedly at his office
20:57:47 <mmorrow> yeah, so as i understand it, everything in the heap has info table, and if a heap object is a constructor it also has an Int# that identifies it as that constructor for pattern matching/etc, and that's what dataToTag# is grabbing
20:57:47 <MyCatVerbs> lispy: strictly the '#' character is used to mean "primitive". Practically you are allowed to read it as "only marginally less dangerous than juggling grenades and their pins separately.
20:58:17 <MyCatVerbs> mmorrow: bet there's a paper somewhere on the whole scheme. :)
20:58:24 <mmorrow> so dataToTag# is really being called every single time you pattern match on a constructor behing the scenes
20:58:44 <mmorrow> MyCatVerbs: yeah i bet
20:58:48 <MyCatVerbs> mmorrow: er, y'know how ever since 6.8, GHC implements pointer tagging?
20:59:05 <mmorrow> somewhat
20:59:25 <mmorrow> oh, i gotcha
20:59:52 <MyCatVerbs> I would guess that that's probably not the constructor's value, but actually the tag bits on the pointer.
21:00:07 <mmorrow> yeah exactly
21:00:25 <mmorrow> that's my understanding
21:00:46 <mmorrow> there's this really neat looking package on hackage called 'reify'
21:00:54 <MyCatVerbs> I have a vague feeling that the integers used to represent constructors might even be strictly distinct, because GHCi's debugger is able to reconstruct type information from them.
21:01:28 <MyCatVerbs> s/integers/values (or words, depending on religious issues)/
21:01:31 <mmorrow> i tried to get it to work, but the last time it did was 6.4 and i messed with it for a while, and eventually put it aside
21:02:13 <Guest61322> can foldM_ short terminate if it finds the node that needs to be processed before the end is reached? no right?
21:02:15 <MyCatVerbs> That's for serializing arbitrary thunks, right? I think BMeph's actively working either on that or on something just like it.
21:02:21 <mmorrow> hmm, i'm not very familiar with ghci's debugger but i need to check it out
21:02:56 <mmorrow> MyCatVerbs: yeah ... suck them right out of the heap
21:03:04 <chylli> are there  yaml parser ?
21:03:17 <MyCatVerbs> Guest61322: if you used a monad with an early exit feature, you could. But aside from that, it's not designed for scanning lists with early exit, no.
21:03:40 <chylli> got it
21:03:55 <MyCatVerbs> chylli: HsSyck?
21:03:57 <Guest61322> ok thanks
21:04:11 <mmorrow> oh BMeph is? sweet! i'll have to make a note to ask him about that
21:04:39 <MyCatVerbs> mmorrow: yeah, it's really difficult, though.
21:05:20 <MyCatVerbs> mmorrow: I depressed him by pointing out that there's a really easy solution to the problem - just freeze an entire OS image and serialize *that*. Naturally, his method has raaaather better performance characteristics than mine. ;)
21:06:23 * Twey laughs.
21:06:30 <MyCatVerbs> @src Data.List.find
21:06:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:06:37 <MyCatVerbs> @src find
21:06:37 <lambdabot> find p          = listToMaybe . filter p
21:06:43 <MyCatVerbs> Bah.
21:06:43 <mmorrow> haha, like "doood, my mOM did that with vmware yesterday morning!!"
21:07:10 <MyCatVerbs> mmorrow: precisely. Hell, I pointed out that you don't even have to write the code to serialize the OS image yourself - just use VMWare's feature for it. ;)
21:08:46 <MyCatVerbs> Guest61322: probably you want something like, findM f [] = return Nothing; findM f (a:as) = f a >>= \v -> if v then return (Just a) else findM f as; -- and then call with actions of type (Monad m) => a -> m Bool.
21:15:06 <TSC> How can I ask ghci for a list of instances of some class?
21:15:32 <Draconx> :info Class
21:15:50 <glguy_> let findM f xs = runContT return $ callCC $ \ done -> mapM_ (\ x -> lift (f x) >>= flip when (done (Just x))) xs >> return Nothing
21:16:03 <glguy_> (if you wanted to play with early escape ;)
21:16:38 <TSC> Draconx: Thanks; I was trying that but getting the spelling (capitalisation) wrong (:
21:27:21 <ddarius> glguy: You are missing a flip.
21:27:22 <Guest61322> mycatverbs: looks good, thanks
21:28:30 <ddarius> @pl \x -> lift (f x) >>= flip when (done (Just x))
21:28:30 <lambdabot> ap ((>>=) . lift . f) (flip when . done . Just)
21:31:21 <ddarius> findM f xs = flip runContT return $ callCC $ \done -> mapM_ (ap ((>>=) . lift . f) (flip when . done . Just)) xs >> return Nothing
21:32:37 <dolio> glguy is too used to MonadLib. :)
21:32:51 <dolio> Where the runX functions have a more sensible ordering.
21:33:07 <MyCatVerbs> ddarius: GAH.
21:33:18 <MyCatVerbs> ddarius: I insist that my version is easier to read. ;P
21:33:51 <MyCatVerbs> ddarius: as, Hell, was glguy_'s. @pl'ing that really wasn't helpful.
21:34:26 <glguy_> monadlib not only has the arguments in the right order
21:34:32 <glguy_> it has instances that aren't broken!
21:34:33 <glguy_> woot
21:34:41 <dolio> Heh.
21:34:58 <dolio> You mean the analogues of StateT Cont and such?
21:35:14 <glguy_> yeah
21:35:24 <glguy_> and who knows what else doesn't work
21:35:28 <glguy_> that's a huge oversight
21:35:32 <dolio> Does MonadLib use censor for writer, too?
21:35:56 <dolio> That seems like a more sensible method to me.
21:36:07 <MyCatVerbs> dolio: what's the CC-delcont library on hackage based on, please?
21:36:21 <dolio> What do you mean?
21:36:51 <dolio> You want to know the paper it's based on?
21:37:03 <MyCatVerbs> dolio: precisely that, please. ^^
21:37:17 <ellisk> Hi, does anyone know if there is a version of mapM for arrays, similar to amap (amapM)? The docs (http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html#v%3Aamap) seem to indicate there isn't one; just wondering if maybe I'm missing something in my noobish ways :/
21:37:18 <lambdabot> Title: Data.Array.IArray, http://tinyurl.com/5q8qp6
21:38:00 <dolio> Well, I don't remember the exact title, but it has the words "Monad" and "Delimited Continuations" and it's by Peyton-Jones, Dybvig and Sabry.
21:38:03 <Guest61322> http://book.realworldhaskell.org/beta/barcode.html
21:38:05 <lambdabot> Title: Chapter 14. Barcode recognition
21:38:13 <Guest61322> folding over arrays half way down
21:38:22 <Guest61322> actually kinda near the top but w/e
21:38:32 <dolio> I think Dybvig's home page has the most recent copy of it.
21:38:47 <MyCatVerbs> dolio: more'n enough, thanks. ^^
21:39:14 <dolio> Older versions use "subcontinuation" instead.
21:40:05 <dolio> But the newer version is more in line with what's in the library. Like the type equality GADT (not really major changes, though).
21:40:46 <ellisk> Guest61322: Thank you. I guess I'll have to write my own, although it won't be very difficult.
21:41:35 <dolio> @instances Data.Traversable.Traversable
21:41:35 <lambdabot> Maybe, []
21:42:42 <dolio> Array is Traversable.
21:42:55 <dolio> So the mapM therein will work.
21:43:23 <dolio> It might just be a skin over an intermediate list, though (not that you could necessarily do much better).
21:44:00 <int-e> @instances-importing Data.Traversable Data.Array Traversable
21:44:00 <lambdabot> Array i, Maybe, []
21:50:07 <hml> i'
21:50:08 <hml> i
21:50:17 <hml> i'm lookintg for a language like haskell, minus the laziness
21:50:22 <hml> what do you guys suggest?
21:50:25 <MyCatVerbs> hml: SML. OCaML.
21:50:45 <MyCatVerbs> hml: F#, maybe, if you want to work in .NET.
21:50:48 <hml> gah; ocaml looks so ugly
21:51:05 <thoughtpolice> why 'minus the laziness'? (just curious)
21:51:16 <hml> I like to be able to reason about running time in big oh notation
21:51:21 <hml> laziness kills that as far as i can tell
21:51:32 <hml> if i'm wrong; please correct me
21:51:33 <Twey> Eh, not really
21:51:49 <int-e> you get to talk about amortized costs a lot.
21:51:50 <Twey> The algorithm still takes the same amount of time (kind of)
21:51:58 <Twey> It just happens at different times
21:52:18 <Twey> Doesn't affect your beloved big-O
21:53:24 <mmorrow> i found the okasaki book very informative
21:53:36 <mmorrow> s/found/find/
21:53:41 <thoughtpolice> i've been wanting a copy of okasaki's book forever
21:53:58 <mmorrow> amazon.com is but a click away!
21:54:09 <MyCatVerbs> thoughtpolice: it's excellent. You'll enjoy the headaches it'll impart. ;)
21:56:40 <thoughtpolice> hehe, sounds like TAPL then. i still need to finish TAPL though.
21:57:12 <hml> what's tapl?
21:57:17 <thoughtpolice> i'm so bad with reading technical books in particular. i only need to look at the TOC and see something that sounds interesting and I have lost track of where I was :)
21:57:24 <thoughtpolice> hml: pierce's types and programming languages
21:57:41 <hml> oh; i tholught iwas Trying APL
21:58:02 <dons> hml, haskell is a language like haskell, minus laziness. just use strict data types.
21:58:13 <mmorrow> wow, i've never really even looked at monadLib before, and after 4 minutes i'm sold
21:58:17 <dons> there's no purely functional strict languages, btw.
21:58:23 <dons> mmorrow: huh.
21:58:29 <dons> glguy_: did you hear that?
21:58:46 <dons> mmorrow: ok. so that should be on the monadLib homepage
21:58:49 <mmorrow> dons:  just a random comment directed at no one in particular :)
21:59:02 <mmorrow> oh
21:59:04 <thoughtpolice> with max's new ghc plugin architecture in the future we can just have an' -fstrictify and be done with it. :)
21:59:14 <mmorrow> yeah, he was just talking about it earlier
21:59:16 <dons> mmorrow: well, glguy and i are in a conspiracy to help monadLib gain wider adoption.
21:59:24 <mmorrow> ahhh, i'm in!
22:00:01 <glguy_> dons: I've never heard anyone say "mtl is better" only "monadlib?"
22:00:05 <Guest61322> is there any way to get a circular reference to yourself in a type constructor? or do you have to do it in two passes
22:00:12 <glguy_> ;)
22:00:19 <mmorrow> heh
22:00:34 <dons> glguy_: i've rarely heard people expression any opinion other than "monads are hard"
22:00:43 <dons> but yes, good sign.
22:01:05 <dons> s/expression// ... i do too much PL stuff
22:01:09 <mmorrow> Guest112348: you can use a newtype
22:01:34 <dolio> monadLib, now with the mmorrow seal of approval!
22:01:43 * dons writes a talk about doing chemistry in haskell
22:02:05 <mmorrow> "four minutes, and i was sold!"
22:02:29 <mmorrow> (an that's actually the truth also)
22:02:30 <dolio> dons: Incidentally, if you have inside information about when the shootout is going to move to 6.8.3, you might want to submit a change to the recursive benchmark at that time.
22:02:43 <dons> dolio: saw that.
22:02:46 <dons> that's scary
22:02:47 <dolio> Otherwise the score on that is going to tank.
22:03:03 <dons> 6.8.3 gets my "sucks" seal of disapproval
22:03:39 <dons> i'll instruct them not to upgrade.
22:03:43 <thoughtpolice> mmorrow: what's sweet about it?
22:03:46 <dolio> Heh.
22:04:27 <dons> glguy_: tell the man about monadLib
22:05:13 <mmorrow> thoughtpolice: i like the global consistency, the fact that there is a BaseM, i thought the Iso datatype was "swell", and it i'm interested to see how exactly it's going about deriving things in MonadLib.Derive
22:05:36 <thoughtpolice> dons: is it, as they say, made of win and greatness?
22:05:49 <dons> i've heard rumours of win and awesome.
22:06:29 <glguy_> mmorrow: The iso stuff works like this:
22:06:33 <humasect> should i be using head branch for development using ghc as a library ?
22:06:45 <glguy_> support a data type: newtype M s a =
22:06:45 <glguy_>     M { unM :: StateT (UnionFind RevertArray s) (ChoiceT (ST s)) a }
22:06:53 <glguy_> then, iso = Iso M unM
22:07:09 <mmorrow> i like it
22:07:12 <glguy_> and instance BaseM (M s) (ST s) where inBase = derive_inBase iso
22:07:26 <glguy_> s/support/suppose/
22:08:14 <thoughtpolice> humasect: it will change with the upcoming GHC release but right now the HEAD is pretty wacky
22:08:33 <dons> stick to 6.8.x
22:08:34 <thoughtpolice> in particular I can get a stage-2 build finished but for example, no packages are registered with the compiler
22:08:35 <humasect> hmm. things are breaking and i don't know what to do'
22:08:37 <humasect> okay thanks
22:08:39 <dons> haddock, mueval and others are sticking to it.
22:08:45 <thoughtpolice> so yeah, the HEAD is chaotic right now. 6.8 will do fine. :)
22:08:51 <humasect> ok=)
22:09:14 <dolio> glguy_: Does the parameter order on the FooM classes cause problems with generalized newtype deriving?
22:09:15 <mmorrow> hmm, that's pretty cool. so essentially, the entire library is generated from derivations invloving this one construction  involving Iso (?)
22:10:24 <glguy_> dolio: I believe so
22:10:27 <nolrai_East> May i ask how monadLib is beter then the mtl? Its not that i like the mtl that much, but..
22:10:37 <dolio> That might be worth changing.
22:12:05 <glguy_> nolrai_East: better division of the typeclasses, attention to strictness, attention to ability to stack monads correctly
22:12:21 <nolrai_East> cool, sounds good to me!
22:13:03 <dons> its the child of mtl, after all.
22:13:10 <dons> by the student of the original mtl designer.
22:13:17 <dons> with all the lessons of mtl learnt
22:14:08 <glguy_> monadLib has two base monads, Id and Lift
22:14:13 <glguy_> Lift is strict
22:14:37 <glguy_> (or you can put IO or ST or whatever you'd like as the base
22:15:25 <nolrai_East> I like the terminalogy better anyway get/set put insted of get/put write.
22:15:56 <nolrai_East> Is that the main diffrence between Id and Lift?
22:16:10 <glguy_> yes, strictness
22:17:55 <thoughtpolice> yayus indeedy, my FFI binding works okay.
22:18:02 <thoughtpolice> i now only have to implement probably 200 other functions
22:18:39 <nolrai_East> hmm ChoiceT looks interesting to. Does it fallow the monad laws?  I remember reading that ListT didn't.
22:18:46 <nolrai_East> s/to/too
22:19:21 <dolio> ChoiceT appears to be roughly like LogicT.
22:19:27 <dolio> Which is a valid transformer.
22:20:33 <dolio> It's probably more like the ListT-done-right article on the wiki, really.
22:20:49 <dolio> I assume it doesn't do two continuation passing internally.
22:31:10 <newsham> hmm..  Network.Socket.ByteString uses Data.ByteString and Data.Binary uses Data.ByteString.Lazy?
22:31:15 <newsham> is there any way to reconcile this?
22:31:47 <dolio> Use strict-binary or whatever it's called?
22:32:00 <MyCatVerbs> newsham: fromChunks and toChunks. Or the strict version of binary.
22:32:33 <newsham> there's a strict version of binary?
22:32:42 <MyCatVerbs> newsham: indeed there is.
22:32:47 <newsham> ahh i see it
22:32:49 <dolio> binary-strict is the name.
22:33:02 <dolio> Apparently it's got 6.8 issues.
22:33:02 <newsham> why two separate libs?
22:33:15 <newsham> ahh, i'm on 6.8.2.
22:33:52 <dolio> I'm not sure what the problem is. The log says it has a parse error on `{-# UNPACK'
22:34:09 <newsham> grrr
22:34:30 <newsham> so B.concat . toChunks ?
22:36:27 <dons> newsham: you ccan convert back and forth, but flattening a lazy bytestring involves copying
22:36:53 <dolio> You're probably better off folding over toChunks.
22:37:11 <newsham> and doing multiple B.send's?  sounds like copying would be cheaper.
22:37:45 <dolio> Might depend on how long the strings are.
22:38:02 <dolio> You're using Binary to generate bytestrings?
22:38:07 <dolio> The chunk size is pretty big.
22:38:08 <newsham> *nod* mine are mostly short
22:38:20 <newsham> my messages are around 60bytes long
22:38:41 <dolio> Unless you use certain combinators, most of your strings will probably be one chunk, then.
22:39:23 <thoughtpolice> grr, does anybody know of a firefox extension that will let me view .hs files as text/html instead of downloading them?
22:39:28 <thoughtpolice> i had one before but I've lost the name of it
22:39:58 <newsham> obviously the right solution is to use the strict Binary package, but it sounds like thats not ready for me yet
22:40:21 <dolio> Well, I don't know how current binary-strict is.
22:40:39 <dolio> Its version number lags binary, at least.
22:40:57 <dolio> Not that that necessarily means anything.
22:41:55 <dolio> Actually, I just tried here, and it appears to build fine. The hackage log must be out of date.
22:42:17 <dolio> So, looks like you're good to go.
22:43:41 <newsham> sweet
22:43:50 <MyCatVerbs> dolio: was going to say, I usually just ignore the build-failure messages on Hackage, particularly if it's an FFI binding library (since most break on the build machine because it apparently has so little crap installed).
22:48:12 <newsham> hmm.. this isnt just a drop in replacement for Data.Binary
22:48:22 <newsham> will have to look into it more later.
22:58:19 <xor> Is it OK to use System.IO.Unsafe to get pure String values for stuff like file permissions, file size?
22:59:36 <dainanaki> that seems like an excessive use of that to just get string values
23:00:56 <xor> Is there a better way?
23:01:27 <dainanaki> well what are you going to do with it, and why can't you keep your operations within the IO monad?
23:02:53 <xor> Well, for example, I want to get file attributes for a file specified by a string. I end up getting an IO String back from my function. But I really just want a String.
23:03:25 <Guest61322> use "<-" to pull it out of IO
23:03:36 <geezusfreeek> xor: in haskell you are strongly encouraged to keep your IO stuff at the top levels of your programs. you call your pure functions from there
23:03:51 <geezusfreeek> rather than your pure functions using IO functions
23:04:05 <xor> Ahh
23:04:20 <xor> That seems a bit strange
23:04:27 <xor> I guess I need to think about that for a bit.
23:04:32 <geezusfreeek> why? the point is to keep your pure functions pure
23:04:35 <dainanaki> that's the point of a purely functional programming language
23:04:40 <geezusfreeek> if you use IO in a "pure" function it can't be pure anymore
23:05:22 <gnut> hello
23:05:33 <Guest61322> hey
23:05:43 <dainanaki> unlike OO or imperative languages, you don't return stuff from IO to other functions usually. Usually you put the functions into your IO action
23:06:01 <dainanaki> it's kind of backwards from other languages in a way
23:06:11 <geezusfreeek> in addition to keeping your pure functions pure, this also has the positive benefit that all your side effects are in one place
23:06:18 <geezusfreeek> think of it as an impure shell around a pure core
23:07:44 <xor> OK.. imagine I want to count all of the bytes on a given file system for a given userID. What parts of that process would be pure functions? Any at all?
23:08:28 <geezusfreeek> the pure functions would mainly be the filtering (on userID) and arithmetic (on byte count) stuff
23:10:22 <geezusfreeek> although i could blow your mind by making an argument that the plumbing in the IO monad is also pure
23:10:32 <xor> OK. Thanks. I think I am starting to get the picture.
23:10:37 <geezusfreeek> but that might be deceptive at this point
23:10:44 <dainanaki> don't hurt him, geezusfreeek
23:10:52 <dainanaki> he's still learning
23:11:05 <dainanaki> that would be quite confusing
23:11:07 <geezusfreeek> right, that's why i'm making sure it's clear that it's unimportant at this point ;)
23:11:42 <dainanaki> someone on irc did that to me a long while back and it got me lost for a reaaaally long time
23:11:47 --- mode: ChanServ set +b climdan!*@*
23:11:47 --- kick: ClimDan was kicked by ChanServ (Banned: History of spam)
23:12:02 <geezusfreeek> really? that stinks
23:12:19 <dainanaki> yeah, well they were trying to help
23:12:33 <xor> In an imperative language I would write utility functions that would do low-level stuff like I/O, and then call higher level functions that determine the control flow of the program. It seems weird that the top level of my program would be I/O.
23:13:00 <dainanaki> like I said xor, it's kind of backwards from what you are used to
23:13:09 <geezusfreeek> xor: i now write my imperative programs this way too. it really helps to make things more clear
23:13:11 <gnut> just say state is a variable that gets passed around
23:13:29 <Guest61322> isnt it basicly just a dataflow pipe
23:14:31 <dainanaki> more or less
23:14:54 <dainanaki> I like to think of it as a box with a leprechaun in it
23:15:04 <dainanaki> If you open the box, it will escape
23:15:22 <dainanaki> So you have to put the food in the box to keep it alive through a little slot
23:15:30 <geezusfreeek> ...
23:15:37 <dainanaki> :)
23:15:40 <geezusfreeek> that is the oddest metaphor i have heard so far
23:15:56 <papermachine> Does anyone have any experience with HBlas or other haskell linalg libraries?
23:16:05 <xor> Well, thanks folks :)
23:16:10 <papermachine> I'm trying to decide which would be easiest to use.
23:16:14 <gnut> do you eat a lot of lucky charms?
23:16:22 <dainanaki> nope!
23:16:33 <dainanaki> But everyone knows that IO is magic anyways
23:16:34 <gnut> ah... you make them. I get it now.
23:17:35 <dainanaki> nah
23:18:06 <dainanaki> You can interchange leprechaun with any other sort of vicious but useful creature and the analogy works
23:19:19 <dainanaki> I think there's a monster monad tutorial out there somewhere that I maybe got that one from
23:20:35 <dainanaki> papermachine, sorry, I'm not familiar with those
23:22:24 <papermachine> Well, it looks like HBlas' docs are MIA, so I'll just cabal hmatrix and take it for a spin.
23:22:42 <allbery_b> there's a link to the old joke about putting teenage boys in a barrel and feeding them through the bunghole until he's 18 in there
23:27:17 <dainanaki> who's been reading my biography?
23:27:35 <gnut> were you a leprechaun?
23:28:33 <dainanaki> no i was talking about the boy in the barrel til he was 18 :P
23:29:01 <gnut> I thought leprechauns didn't live in barrels
23:29:17 <dainanaki> gnut, I'm no leprechaun
23:29:20 <gnut> but potsn of gold!
23:29:23 <allbery_b> only if their tree got cut down and turned into a barrel :)
23:29:32 <gnut> a golden barrel
23:29:33 <dainanaki> I just use them for functional purity
23:30:13 <gnut> it was functionally a barrel
23:31:14 <opqdonut> a functional barrel
23:31:25 <dainanaki> a barrel of functions
23:35:23 <stepcut> a barrel full of barrels ?
23:35:35 <papermachine> Data.Vec is pretty :)
23:35:41 * papermachine uses it instead.
23:43:04 <hml> does there exist a program H in haskell; where it's asymptotic running time when using strict evaluation is smaller than the's symptotic running time when yusing lazy evaluation?
23:43:11 <gnut> barrel of monkeys
23:44:08 <gnut> papermachine: where do you see Data.Vec? Is this ghc?
23:44:14 <hml> ?
23:44:37 <papermachine> gnut, it's on hackage
23:44:45 <gnut> papermachine: thanks.
23:49:50 <gnut> I needed some sparse matrix routines a while back
23:54:21 <ahunter2> Odd question:  Suppose I'd like to define an infix expression which has a different type on each side; but I'd like you to be able to place either type on either side.  In particular, I want something vaguely like: (**) :: Foo -> Int -> Foo (where Foo is my particular type of interest), and I'd really like it if 2**f and f**2 (where f is a Foo) are both legal...is there any reasonable way at all to do this?
23:54:24 <dolio> hml: I don't think there are any such programs, but I'm not certain.
23:55:29 <dolio> hml: Interestingly enough, there are problems whose solutions are asymptotically slower in a pure strict language than in a pure lazy or impure language.
23:55:32 <ahunter2> I mean, I kind of expect that'd make typechecking nigh on impossible, but I figured someone might know some Deep Magic.
23:55:54 <ahunter2> dolio: I think Nick Pippenger wrote a paper giving such a problem, is that what you're referring to?
23:55:58 <dolio> Impure meaning you have assignment.
23:56:16 <dolio> Possibly. Did he write More Haste, Less Speed or whatever?
23:57:09 <ahunter2> dolio: I think he wrote an earlier paper that was rebutting (that simply claimed pure was insufficent) and they were just noting that lazy is as good as impure here :P
23:58:28 <dolio> Ah, well, from what I understand, someone wrote a paper showing that a pure lisp was strictly less powerful than an impure lisp. Then someone(s) came along and showed that with call-by-need, you get back the power. Maybe that was him.
23:58:46 <ahunter2> It was, now that I remember (and double-checked...)
23:59:20 <rwbarton> ahunter2: Sounds like you could do it by (ab)using type classes?  class BinOp a b c | a b -> c where (**) :: a -> b -> c; instance BinOp Foo Int Foo where ...; instance BinOp Int Foo Foo where ...
