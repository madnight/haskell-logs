00:00:01 <joed> So what problems were hit?
00:00:13 <mwc> Crap performance mostly
00:00:53 <mwc> IIRC, the F# development effort introduced extensions to the .NET machine to better support functional languages... so...
00:00:56 * mwc shrugs
00:00:56 <mmorrow> another big problem as i understand is the jvm's lack of support for anything resembling jumps
00:01:02 <mmorrow> only calls
00:01:09 <ddarius> mwc: Both a CLR and a JVM backend have been made for Haskell.  The problems seemed to me to be mainly one of usefulness.  Compiling to the JVM doesn't mean pain-free integration with Java libraries.
00:01:31 <mwc> no, the semantic gap would be extreme
00:01:52 <mwc> You'd almost need a language like Ocaml (functional + objects) to bridge between them
00:02:15 <Twey> Or O'Haskell?
00:03:04 <mwc> By which I mean, you'd need to synthesis haskell modules with java modules in some sort of strict language with rich OO
00:05:37 <joed> Okay.,
00:07:14 <waynemokane> just did cabal "Quick Installation on Unix", cabal install json, and boom, I have JSON modules in ghc.  not very often that things just work; awesome!
00:08:22 <BMeph> mwc: And maybe even *synchronize* them, too? ;)
00:08:28 <Saizan_> yay!
00:09:39 <waynemokane> quite a relief to see that I'm not the only one getting excited about cabal at 2:00AM on a Saturday morning
00:10:11 <Saizan_> BMeph: i hate java concurrency.. last time i worked with it i started being paranoic "what if someone sends an interrupt to this thread!?"
00:10:40 <dons> waynemokane: cabal just works :)
00:10:51 <Lycurgus> seems like concurrency is inherently muddied in any VM env
00:10:55 <Saizan_> it's 9AM here :)
00:11:47 <mmorrow> joed: this looks possibly promising http://www.cs.rit.edu/~bja8464/lambdavm/
00:11:48 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
00:11:48 <BMeph> ...and it's just after midnight on the US West Coast. ;)
00:12:52 <waynemokane> dons: and so does your json package
00:12:57 <mwc> well, I guess I should sleep
00:13:01 <waynemokane> dons: which is quite nice
00:13:01 <joed> It does, mmorrow quite so.
00:13:01 <mwc> stupid diurnal species
00:13:55 <mmorrow> joed: the implem: http://wiki.brianweb.net/LambdaVM/Implementation
00:13:55 <waynemokane> who would be interested in entering an obfuscated Java contest?
00:13:58 <lambdabot> Title: Brian's Wiki: LambdaVM / Implementation
00:14:22 <mmorrow> "We can't make direct branches. What should be a single direct jump instruction turns into an indirect jump back to the caller (who in running the interpreter loop), a conditional branch (while (c != null), followed by a virtual method call (memory read, and another indirect jump). And this is the best case scenario (there might be other stuff going on in the jvm under the hood). This is a lot of overhead."
00:14:30 <waynemokane> a few ideas: throw exceptions wrapping values instead of returning them, have red herring classes that do random things and remove themselves from the classpath
00:14:52 * Twey blinks at mmorrow.
00:14:54 <Twey> Urgh
00:15:19 <joed> Haha
00:16:37 <mmorrow> but since that's the only way to go, it's definitely better than not having an implementation at all
00:20:08 <mmorrow> but gah, compare that too
00:20:10 <mmorrow> jmp *(%esi)
00:20:46 <mmorrow> (btw ghc -S in fairly entertaining)
00:22:12 <Capso> I just don't have the disk space for a full ghc distrib. :/
00:23:01 <mmorrow> Capso: delete some pr0n
00:23:07 <mmorrow> :)
00:23:17 <Capso> None found
00:23:42 <mmorrow> are you running on a pda?
00:24:03 <Capso> I don't want to discuss this with you, sorry.
00:24:23 <Capso> Your arguments are not very interesting, and your questions even less so.
00:24:27 <mmorrow> the biggest it gets is maybe 200-300MB during build
00:25:00 <mmorrow> after make install && make distclean i'm not sure, but way less than that
00:26:39 <mmorrow> Capso: also, my apologies if i've offended you by jokingly suggesting you delete nonexistent porn.
00:27:17 <Capso> I don't mind that.
00:27:25 <mmorrow> :)
00:27:52 <Capso> I have 937 megs in root partition. I'm sure to run out quick.
00:28:22 <mmorrow> hmm, i wonder how big my install is...
00:28:26 * mmorrow checks
00:28:59 <chrisdone> my install is bigger
00:29:45 <mmorrow> eeee, a "little" bigger than i thought:
00:29:46 <mmorrow> [m@ganon code]$ du -h /usr/local/ghc/ghc-6.9.20080822 | tail -1
00:29:47 <mmorrow> 266M    /usr/local/ghc/ghc-6.9.20080822
00:30:04 <ScriptDevil> has the parsec website changed?
00:30:06 <mmorrow> (that's with all the extras though)
00:30:12 <guenni> can I hide an instance declaration from an import so I can override it?
00:30:15 <ScriptDevil> well.. daan's page has only till 2.0
00:30:23 <mmorrow> guenni: unfortunately no
00:30:29 <dons> heya ScriptDevil
00:30:39 <guenni> shit
00:30:52 <newsham> you can newtype it, deriving what you want ot keep, and instancing new stuff
00:31:05 <ScriptDevil> heya dons: And yeah.. sorry about not replying. I was working my head off at college for a week
00:31:19 <guenni> newsham: thx
00:31:50 <dons> ScriptDevil: sure. no worries. i think we're all sorted now.
00:31:59 <dons> ScriptDevil: btw, #arch-haskell is a good place to idle
00:32:27 <newsham> what is #arch-haskell?
00:32:41 <Capso> Haskell on ArchLinux?
00:33:20 <newsham> ahh
00:33:46 <dons> yeah, just talk about packaging on Arch.
00:33:52 <dons> same function as #gentoo-haskell
00:33:56 <Capso> Linux is far too predictable. :/
00:33:58 <Capso> And boring.
00:34:16 <dons> :/ :| :\ :] :D
00:34:59 <dons> so did you get ghc installed, Capso ?
00:35:12 <Capso> See? Normal Linux obsessed behaviour: picking the least interesting bit, and exploiting it beyond basic boredom.
00:35:15 <Capso> ;)
00:35:22 <Capso> dons: Nah, not here.
00:35:28 <Capso> dons: I have HUGS on my Plan 9 system.
00:35:53 <dons> ok. so you're not planning on writing anything useful?
00:36:09 <dons> or is it some domain specific thing you're trying to solve?
00:36:12 <guenni> plan 9 still exists?
00:36:30 <newsham> the news said that there's a shortage of women in australia.  why did you move to usa, dons?
00:36:32 <ScriptDevil> Caspo: Arch is the only distro I never got bored with. And yeah. I am exploring l4 Pistachio now. :P
00:36:49 <dons> newsham: heh, a shortage eh?
00:37:01 <newsham> they called it a "man drought"
00:37:10 <ScriptDevil> well.. anyway... what is the parsec page?
00:37:11 <dons> ScriptDevil: heh, you could try sel4, the haskell-based verified l4.
00:37:30 <newsham> can you actually try sel4?  still being translated to C, no?
00:37:34 <ScriptDevil> dons: Oh.. I will do that.. I did not know...
00:37:39 <dons> i think it's "done"
00:38:00 <Capso> dons: I came about Haskell as something of a Mathematician's paradise away from the nonsense of normal computer science. Now, if you'll pull this "useful" baloney on me, well, I might have to reconsider!
00:38:10 <newsham> hmm.. i wish they'd keep the web pages more up to date, that project sounds really cool
00:38:25 <dons> Capso: still, you'll need ghc to do anything other than toys.
00:38:29 <newsham> capso: what are you doing with p9?
00:38:41 <ScriptDevil> :P Working for bell labs ;)
00:39:11 <newsham> i dont think there are many people left at the labs using p9.
00:39:29 <Capso> newsham: Having lots of fun, getting work done, and finally implementing properly distributed processes.
00:40:00 <newsham> i used to spend a bit of time goofing with p9..  wish i had the time.  very elegant system.
00:40:09 <Capso> Sure is.
00:40:32 <Capso> Lots of people use it -- it just never became huge. Bruce Ellis is running a company off of it.
00:40:51 <newsham> i know lots of people use, i just said not at lot left at the labs :)
00:41:14 <Capso> That was sort of directed at the norm, i.e, guenni, who think otherwise.
00:41:19 <newsham> inferno not the same thing
00:41:30 <newsham> oh, oops
00:41:33 <Capso> It's not so much 'antiquated', as it succeeds in 'antiquating' other OS'.
00:41:58 <mmorrow> ah, the ol' ed/ing switcharoo
00:42:15 <Capso> newsham: Yeah, Inferno is a sort of a 'fork', and has a little different style. It's meant mainly for embedded systems.
00:42:22 <newsham> http://shell.lava.net/~newsham/plan9/
00:42:23 <lambdabot> Title: Plan9
00:42:44 <Capso> newsham: Ah, 9P in Python, haha
00:44:22 <Capso> dons: Hmm, yeah, probably. It's a massive beast to port.
00:44:33 <Capso> Hell, it's a 'massive beast' to begin with.
00:44:35 <newsham> was fun for goofing w/ the protocol and also nice having a portable client around for things like sources
00:49:33 <mmorrow> Capso: jhc generates iso C
00:50:16 <mmorrow> eg http://code.haskell.org/~morrow/jhc/tests/csv/hs.out_code.c
00:50:23 <mmorrow> from http://code.haskell.org/~morrow/jhc/tests/csv/csv.hs
00:50:56 <mmorrow> and that hs.out_code.c contains the entire runtime as well
00:51:14 <Capso> Cool, but why do you tell me?
00:52:06 <mmorrow> Capso: ah, now i see what massive beast you were refering to ;)
00:52:07 <sjanssen> mmorrow: does Language.Haskell.Exts support TH?
00:52:19 <mmorrow> sjanssen: yep :)
00:52:49 <mmorrow> sjanssen: as well as pretty much all other extension syntax
00:52:56 <sjanssen> I will consider using this in lambdabot
00:53:17 <sjanssen> though I think it is a bit sketchy assuming that "Modules.hs" is in the current directory
00:53:21 <mmorrow> (w/ the exception of the new quasiquoting, but i'm trying to add that)
00:53:27 <Capso> mmorrow: There ought to be a remote GHC "compile your Haskell" utility.
00:53:31 <Capso> It would be awesome.
00:53:58 <ddarius> It would be somewhat tricky.
00:54:00 <mmorrow> sjanssen: yeah, it's a bummer only getting qCurrentModule
00:54:17 <ScriptDevil> Capso: yeah.. I was wondering.. Like ruby's Try It now
00:54:19 <Capso> ddarius: Mhm, how so?
00:54:22 <sjanssen> mmorrow: what do you think about adding qImports, or something like that, to Quasi?
00:54:24 <mmorrow> Capso: heh, but who could we convince to do such a thing?
00:54:30 <Capso> mmorrow: Me.
00:54:34 <ddarius> Though I guess if you limit to "small" things, it wouldn't be a problem, i.e. you could memory/time restrict it.
00:55:00 <sjanssen> > product [1 .. 100] -- try Haskell here
00:55:01 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
00:55:10 <newsham> isnt the new ghc going to support cross compiling?
00:55:13 <Capso> mmorrow: If someone is willing to donate some hardware, I'm up for it.
00:55:20 <mmorrow> sjanssen: that would great. exports would be in there just as easily.
00:55:31 <newsham> sjanssen: if you just want to try, there's also codepad.com
00:55:59 <mmorrow> Capso: hmm.
00:56:21 <Capso> I have a whole garage and extra room to fill!
00:56:25 <Capso> ;)
00:56:25 <Cale> http://mysqlgame5.appspot.com/?redirect=1 -- heh, a game where you play as a row in a MySQL database...
00:56:26 <lambdabot> Title: mysqlgame - shard 5
00:56:41 <ddarius> Cale: And the objective?
00:56:48 <Korollary> to be the best row ever
00:57:09 <BMeph> Best. R0w. Evar!
00:57:10 <newsham> cale: sounds like a developers bad dream
00:57:11 <BMeph> ;p
00:57:12 <Cale> ddarius: To increase the numbers in your row, and decrease the numbers in other player's rows.
00:57:20 <mmorrow> sjanssen: i have the new TH with Loc's haddocks at http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/
00:57:21 <lambdabot> Title: template-haskell-2.2, http://tinyurl.com/6xdh6w
00:57:33 <Korollary> that doesn't sound like something a row would do.
00:58:12 <ddarius> You know what we need.  A children's game to teach children database design aspects like normalization, functional dependencies, join dependencies.
00:58:22 <newsham> ' or 1=1 --
00:58:37 <ScriptDevil> Capso: Is plan9 hosted like inferno or stand alone as an OS??
00:58:40 <Korollary> build indexed tables on OLPC's?
00:59:10 <newsham> script: plan9 runs on bare hardware or in an emulator.  there is a userland port for several unixes, and there's a userland binary emulation that runs in some unixes
00:59:20 <newsham> but mostly its a complete OS system for bare hardware
00:59:21 <Capso> Um...
00:59:29 <Capso> That's not how Plan 9 was meant to be used, however.
00:59:33 <ddarius> It will be like a puzzle game where the things to avoid are update anomolies.
00:59:44 <Capso> Right, newsham's last statement is correct.
00:59:59 <newsham> and really to be run properly you should run it on several systems :)
01:00:05 <ScriptDevil> Capso: Good. I  have some 10 gig free
01:00:10 <ScriptDevil> i will try it out
01:00:11 <ScriptDevil> :D
01:00:21 <ScriptDevil> feels nice to read the docs
01:00:28 <Capso> ScriptDevil: Moreover, you normally use it with a CPU/Auth server and a File Server.
01:00:59 <Capso> ScriptDevil: You connect to them as necessary to run your processes and access your files, via your Terminal that also runs Plan 9 -- it may be a diskless machine or whatever.
01:01:05 <mmorrow> sjanssen: hmm, maybe something like adding qCurrentModule /back/ in (so now both qCurrentModule and qLocation), but qCurrentModule :: m CurrentModule and CurrentModule = Curr..ule { imports :: [something], exports :: [something], ... }
01:01:18 <Capso> ScriptDevil: You can also use an Inferno install on top of another OS as a Terminal.
01:01:42 <ScriptDevil> Capso: I will try plan 9's live disk first..
01:02:40 <Capso> ScriptDevil: Of course, you can just have one box as your CPU/Auth and File Server and Terminal.
01:03:09 <ScriptDevil> Oh.. fine then
01:03:14 <ScriptDevil> I am leaving now..
01:03:24 <Capso> But then you don't get to experiment with the networking capabilities and how simple that part is.
01:03:25 <newsham> also #plan9 hereand on otfc.net
01:03:25 <ScriptDevil> But before that.. Why isnt parsec's page updated?
01:03:53 <Capso> newsham: Meh, Freenode's is more reccommended. OFTC is just a hack nowadays. ;)
01:05:01 <mmorrow> <sjanssen> though I think it is a bit sketchy assuming that "Modules.hs" is in the current directory
01:05:50 <mmorrow> sjanssen: possibly the filepath could be handed in somehow ... maybe cpp?
01:08:08 <Saizan_> ScriptDevil: http://legacy.cs.uu.nl/daan/parsec.html <-- this one? because daan is no longer working on parsec
01:08:12 <lambdabot> Title: Parsec
01:08:44 <ScriptDevil> Saizan_: is parsec to be dropped or something? Please say no!
01:10:10 <Saizan_> ScriptDevil: it has been extended last summer as a gsoc project, so i don't think so :)
01:10:57 <Saizan_> ScriptDevil: but this new version, parsec 3.0, needs to be tuned for performance
01:11:31 <Saizan_> however there are a several parsing combinators on hackage now
01:12:44 <ScriptDevil> Saizan_: What should I use. I have a project for creating a compiler
01:14:02 <mmorrow> ScriptDevil: Alex/Happy is nice
01:14:21 <ScriptDevil> mmorrow: it is not a combinator is it?
01:14:32 <newsham> hmmm 100kloc's of proofs in sel4 now.
01:15:29 <mmorrow> ScriptDevil: no, it's more lex/yacc, but since s/c/haskell/ it's not bad once you get going
01:15:58 <mmorrow> http://darcs.haskell.org/ghc/compiler/parser/HaddockLex.x
01:16:03 <mmorrow> http://darcs.haskell.org/ghc/compiler/parser/HaddockParse.y
01:16:37 <mmorrow> http://darcs.haskell.org/alex/examples/haskell.x
01:16:47 <ScriptDevil> mmorrow: oh.. okie.. Thanks..
01:17:57 <ScriptDevil> mmorrow: The final link was good
01:17:59 <ScriptDevil> Thanks
01:18:02 <ScriptDevil> Bye all!
01:18:11 <mmorrow> ScriptDevil: yeah, that's a really good example
01:28:28 <Taejo> what is the performance of split like on StdGen?
01:28:45 <quicksilver> its performance is fin.
01:28:47 <quicksilver> fine.
01:28:54 <quicksilver> it's random qualities are doubtful :)
01:30:29 <Taejo> quicksilver: I'm not using it to run a nuclear power station
01:30:49 * quicksilver nods.
01:30:59 * quicksilver hopes that nuclear power stations are not run by random numbers.
01:31:06 <quicksilver> Not even really good quality ones.
01:31:09 <mgsloan> hrmm, does hpaste no longer announce?
01:31:16 <mgsloan> anyways, http://hpaste.org/10023
01:31:50 <Taejo> quicksilver: I hope so too, but there is surely some Monte Carlo in the research that they are based on?
01:33:14 <ulfdoz> quicksilver: At least they should have a very good source of entropie.
01:35:27 <Saizan_> that was a good question, what's the recommended parsing library this days?
01:36:19 <Twey> Still Parsec as far as I'm aware
01:37:04 <quicksilver> parsec or polyparse, IMO.
01:37:24 <quicksilver> myself I much prefer combinators to adding a preprocessing step.
01:37:31 <quicksilver> btu I've never actually *tried* happy and alex
01:39:52 <Cale> Hooray, more Catsters :)
01:40:33 <Taejo> Cale: can you recommend a starting point for watching Catster videos?
01:41:33 <Cale> Well, they do jump around quite a bit. The recent videos have been more introductory, so perhaps start with initial and terminal objects, and now the stuff about products and coproducts.
01:41:44 <Cale> Then the playlists on Natural transformations
01:41:57 <Cale> and then perhaps Monads
01:42:07 <Saizan> i wish there was more documentation on the Utrecht one, the promised features are quite interesting
01:42:07 <Cale> and maybe Adjunctions after that
01:42:52 <Capso> Cale: This game is pretty interesting.
01:43:20 <Cale> It's also *really* slow though :)
01:43:34 <Capso> Well, how many money factories do you have?
01:44:12 <Capso> And is there no one around you whom you can defeat?
01:44:16 <Cale> 5 so far :)
01:44:58 <Cale> I'm weighing the option of upgrading my attack multiplier (500) vs. getting another money factory (640).
01:45:17 <Capso> Go for the money factory.
01:45:30 <Capso> You'll seldom upgrade attack multipliers, but you always need more attackers.
01:46:06 <Capso> Either way, you need to make your time count, so the money factory is the way to go for now.
01:46:09 <Cale> It seems that attacking doesn't get me much more than the cost of my attackers back though...
01:46:53 <Sadache> hello
01:46:54 <Capso> Well, wherever you use the money, you will always need more of it.
01:47:08 <Cale> That's true :)
01:47:10 <Sadache> I am in my third day of happs installation
01:47:29 <Cale> Sadache: any luck with it?
01:47:36 <Capso> I'm going to try to get up to 100% efficiency -- 1 money to 1 second (or 10 money_factories).
01:47:47 <Sadache> i didnt succeed yet
01:48:06 <Saizan> Sadache: what do you have so far?
01:48:15 <Sadache> i am trying to install unix-2.3.0.0
01:48:25 <Saizan> are you on windows?
01:48:32 <Sadache> and i am getting errors on configure and on build
01:48:46 <Capso> Cale: I tried attacking a really heavy player once, haha. I think he would have obliterated me befor I ever started playing. ;)
01:48:48 <Sadache> i am on windows, but i installed cygwin with gcc
01:48:55 <Capso> before*
01:49:47 <Saizan> Sadache: happs can be compiled without unix, but you need an updated package
01:50:14 <Sadache> updated package, what does that mean?
01:51:19 <Sadache> http://www.mibbit.com/pb/Q54Tvg
01:51:20 <lambdabot> Title: Mibbit: PasteBin
01:51:33 <Saizan> Sadache: darcs get from the repos, they include the fixes to make it build on windows
01:52:01 <Capso> Cale: I'm actually in a good spot: the player next to me hasn't started playing yet. ;)
01:52:08 <Sadache> so in this case i wont need cygwin?
01:52:22 <Saizan> Sadache: exactly
01:52:32 <Capso> Cale: We can even team up, if we transfer things back and forth (i.e., I think I have too many fuel factories).
01:53:13 <mgsloan> heh, it's kinda ironic how cabal-install has a bunch of dependencies >.<
01:54:58 <Saizan> mgsloan: there's a bootstrap script in the latest package, iirc
01:55:10 <mgsloan> oh?
01:55:19 <mgsloan> ah so there is!
02:06:19 <Sadache> here is what i get when i try to install happs-http http://www.mibbit.com/pb/MFrzXS
02:06:20 <lambdabot> Title: Mibbit: PasteBin
02:07:00 <Sadache> missing dependency unix
02:10:01 <Cale> Sadache: what does  ghc-pkg list unix  say?
02:11:16 <Saizan> Sadache: did you use --tag=0.9.2? you've to pull more patches
02:12:13 <Sadache> Cale: it gives C:/ghc/ghc-6.8.2\package.conf:
02:12:32 <Cale> Sadache: then the unix package is not properly installed.
02:13:17 <Sadache> Saizan: yes i did, i copied it from http://happs.org/
02:13:18 <lambdabot> Title: HAppS — The Haskell Application Server
02:13:47 <Sadache> Cale:  they ve just told me i dont need unix package to install happs
02:13:50 <Saizan> Sadache: run "darcs pull -a" then
02:14:01 <Saizan> Sadache: so that you get the latest version
02:15:24 <Sadache> ok
02:19:39 <dancor> is there a simple way to go from [(String, String)] to a=b&c=d&e=f for a uri?  escapeURIString is a bit odd
02:21:00 * Twey frowns.
02:21:12 <Twey> :t intercalate
02:21:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:21:52 <dancor> ..i guess it's just   let esc = escapeURIString isUnescapedInURI in intercalate "&" $ map (\ (key, val) -> esc key ++ "=" ++ esc val)
02:22:24 <Twey> > (intercalate "=") . (map \(a, b) -> a ++ "&" ++ b) $ [("foo", "bar"), ("baz", "quux")]
02:22:25 <lambdabot>  mueval: Prelude.read: no parse
02:22:30 <Twey> Bah
02:22:47 <Twey> Well something like that, yeah.
02:23:06 <dancor> isUnescapedInURI is still weird!  :)
02:24:14 <Saizan> > intercalate "=" . map (\(a, b) -> a ++ "&" ++ b) $ [("foo", "bar"), ("baz", "quux")]
02:24:15 <lambdabot>  "foo&bar=baz&quux"
02:24:32 <wjt> any debian packagers around who could recommend a package as a good example of debianizing a cabalized library?
02:29:51 <Saizan> Cale: sorry to bug you, but what's the current policy for the c.h.o lambdabot repo? some patches applied to the running \lb are not there, i think
02:30:05 <Cale> oh...
02:30:13 <Cale> I might have forgot to push, sorry.
02:31:02 <Cale> Okay, should be pushed now :)
02:31:25 <dons> wjt, 'dlist'?
02:31:32 <dons> it at least in the past was the canonical example
02:31:32 <Capso> bzr?
02:31:38 <Saizan> yeah :)
02:32:31 <trofi> :t printf
02:32:32 <lambdabot> forall r. (PrintfType r) => String -> r
02:34:38 <dons> we used to consider that magic.
02:35:13 <Saizan> @quote canonical.procedure
02:35:13 <lambdabot> No quotes match. The more you drive -- the dumber you get.
02:35:20 <Saizan> @quote standard.procedure
02:35:20 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
02:35:34 <Saizan> @quote procedure
02:35:34 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
02:35:40 <wjt> dons: aha! this blog post about debianizing it looks good
02:38:00 <Heffalump> wjt: what about stepcut's stuff?
02:39:12 <mgsloan> hrmm, newest version of ByteString seems to not have a Binary instance
02:40:48 <Heffalump> dons: presumably that printf is unsafe, though?
02:40:53 <Heffalump> it's safe printf that is magic, IMO
02:42:01 <wjt> Heffalump: i'm hamstrung slightly by never having debianized anything before, and dh_haskell's documentation assuming you already know about debianization in general
02:42:12 <wjt> Heffalump: but I'll have a play
02:42:28 <Heffalump> debian package building is a black art until you get the hang of it, IME
02:42:39 <Heffalump> there are lots of silly little hoops you have to jump through
02:42:48 <Heffalump> and as you say the helper scripts are designed for people who have done so once
02:44:49 <wjt> so i think I'll work through http://pupeno.com/2006/12/12/the-lambda-revolution-v/ which assumes rather less knowledge (although it does involve cargo-culting from hunit's packaging!) to get started
02:44:54 <lambdabot> Title: Pupeno’s web site » Blog Archive » The lambda revolution, Episode V, the deb ...
02:45:06 <Saizan> Heffalump: which safe printf? the one with delimited continuations?
02:45:33 <Heffalump> Saizan: I mean that any printf you can define in Haskell is unsafe in terms of the format string matching up with the types passed.
02:45:42 <Heffalump> (template-haskell aside)
02:46:24 <Cale> Unless, of course, you change your definition of "format string" ;)
02:46:58 <Heffalump> yeah
02:47:04 <Saizan> ok :)
02:47:04 <Heffalump> presumably some neat games can be played with GADTs
02:47:08 <Cale> yeah
02:47:53 <Cale> I wonder if that would be worth actually doing.
02:48:20 <Heffalump> I don't think so
02:48:27 <quicksilver> a safe printf requires the compiler to interpret the format string at compile time.
02:48:27 <Heffalump> the attraction of printf format strings is the conciseness
02:48:47 <quicksilver> I think if you go down that route you end up with something like a generalised concatenation operator.
02:49:01 <Saizan> the one with continuations is quite neat, and just uses (a -> s) -> r for them
02:49:04 <Capso> There is no attraction of printf, in any way, whatsoever.
02:49:13 <quicksilver> bit like C++'s (<<) which is, to be honest, a bit of a mess.
02:49:32 <Heffalump> Capso: yeah right. That's why nobody ever uses it.
02:49:46 <quicksilver> "Your weight is " ++>* FloatFormat 4 2 ++>> (weight :: Double)
02:50:52 <Heffalump> if you're going to design that, you should also use type-level ints for the argument positions if possible.
02:50:58 <Twey> (format)
02:50:59 <Heffalump> To support i18n.
02:51:33 <Heffalump> does cabal have any way of detecting whether we are in "native" windows (i.e. not cygwin or mingw)?
02:54:05 <Saizan> Heffalump: i think there's only os(name) where name is matched against System.Info.os
02:55:55 <Heffalump> I'm trying to figure out how to make a package with Build-type: configure work
03:06:23 <Saizan> are there useful but not turing complete sets of logic combinators?
03:08:09 <Taejo> why doesn't haddock like (##) in an export list? is there anything I can do about it?
03:10:52 <quicksilver> # is illegal in identifiers
03:11:00 <quicksilver> unless you activate -XMagicHash or something?
03:11:03 <quicksilver> isn't it?
03:12:13 <u_quark> does anyone else miss the Graphics.Rendering.Cairo.SVG package in gtk2hs in debian or ubuntu ?
03:12:28 <u_quark> or is it just me ?
03:12:32 <Saizan> quicksilver: it's the opposite i think
03:13:00 <Saizan> u_quark: cairo is a separate package, iirc
03:13:13 <Saizan> > let (#) = 42 in (#)
03:13:14 <lambdabot>  mueval: Prelude.read: no parse
03:13:42 <Saizan> Prelude> let (#) = 42 in 42
03:13:42 <Saizan> 42
03:14:23 <u_quark> it's not in libghc6-cairo-dev
03:23:21 <Sadache> I guess i succeded installing happs, but i am getting an error running the sample program, when i execute sp ghc -isrc src/Main.hs --make --run --http-port=5000  i get:  sp: echo: runProcess: does not exist (No such file or directory)
03:23:53 <Saizan> don't use sp
03:24:52 <Saizan> just compile it with ghc --make -isrc src/Main.hs, and then run it with Main.exe --http-port=5000
03:25:03 <Sadache> ok
03:26:40 <dancor> how do you do onclick with Text.XHtml
03:28:04 <dancor> i guess strAttr
03:29:37 <Sadache> HTTP request failed with: <socket: 1832>: hGetBufNonBlocking: failed (Unknown er
03:32:13 <Sadache> firefox gives Server error: Prelude.last: empty list
03:34:42 <ac> is there a function like tail that returns an empty list given an empty list?
03:36:09 <Saizan> > drop 1 []
03:36:10 <lambdabot>  []
03:36:20 <Saizan> > drop 1 ['x']
03:36:21 <lambdabot>  ""
03:36:35 <ac> Saizan: ah thanks
03:55:10 <sioraiocht> @seen dcoutts
03:55:10 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 7h 57m 9s ago.
03:55:16 <sioraiocht> @seen dcoutts_
03:55:16 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
03:55:23 <sioraiocht> booo
03:59:39 <Sadache> do i need to put main.exe in any special directory to run it on happs?
04:01:17 <Saizan> Sadache: main.exe is the whole server
04:01:37 <Sadache> then it is strange why it doesnt run
04:01:49 <ivanm> Saizan: wow, you can collapse entire computers into a single executable? :o
04:02:31 <Saizan> ivanm: awesome what gzip can do these days, eh?
04:03:13 <ivanm> oh? would have thought you'd need bzip2 at the very least :s
04:03:26 <Capso> gzip can compress hardware?
04:03:47 <mgsloan> hmm, I wonder if zlib can compress RealWorld
04:04:05 <Saizan> Sadache: true, but i can't help you there, maybe you should try some more guided tutorial
04:04:16 <Saizan> s/some/a/
04:04:50 <Sadache> ok, already u helped me more than enough
04:05:02 <Sadache> thank you
04:05:50 <Sadache> so you know just any simple way of checking whether happs is poperly installed, just to be sure i am done with that at least
04:06:10 <Saizan> http://groups.google.com/group/HAppS
04:06:11 <lambdabot> Title: HAppS | Google Groups
04:08:19 <Saizan> Sadache: http://happstutorial.com:5001/tutorial/run-tutorial-locally <-- this looks like a simple app to install
04:08:30 <Saizan> if it works you've installed happs correctly :)
04:08:41 <Sadache> ok
04:08:50 <Sadache> have a nice day
04:11:47 <ivanm> has anyone managed to build haddock docs for gtk2hs-0.9.13 with haddock-2?
04:14:54 <FordCortina> what does the kind |*| denote?
04:15:44 <Saizan> the |s are for quoting or part of the kind?
04:15:57 <FordCortina> part of the kind i think
04:16:17 <Saizan> never seen it then
04:16:38 <Saizan> hwere is it from?
04:17:05 <EvilTerran> FordCortina, where is this?
04:17:09 <FordCortina> http://crab.rutgers.edu/~pjohann/popl08.pdf
04:17:11 <lambdabot> Title: Foundations for Structured Programming with GADTs
04:18:00 <FordCortina> (page 4)
04:18:34 <FordCortina> "...in order for G f h and its data constructor GCon to be well-kinded we should have in Haskell"
04:18:40 <gwern> @flush
04:18:42 <FordCortina> ...
04:18:56 <EvilTerran> "That is, we take the category C' to be the discrete category derived from C. Writing |C| for this category..."
04:19:03 <EvilTerran> section 3.1
04:19:25 <EvilTerran> I presume |*| is related
04:19:58 <FordCortina> yes i saw that
04:20:06 <Saizan> so it's not real haskell
04:20:16 <FordCortina> that's what i wondered
04:20:31 <Sadache> Saizan: My happs seems to work
04:21:04 <Sadache> i tried a tutorial project and it works
04:22:55 <EvilTerran> I'm not sure what * means as a category - presumably the category of fully-applied types?
04:24:12 <Lycurgus> or some closure
04:24:54 <gwern> > tail $ lines []
04:24:55 <lambdabot>  mueval: Prelude.read: no parse
04:24:56 <lambdabot> mueval: *** Exception: Prelude.tail: empty list
04:25:26 <gwern> ah, so that's the djinn issue. no executable means popen returns [], and then lb thoughtlessly calls tail
04:26:24 <Saizan> Sadache: nice :)
04:27:22 * Saizan wonders how it manages to print two exceptions
04:27:37 <Saizan> one must come from the watchdog..
04:28:07 <gwern> > tail $ lines []
04:28:08 <lambdabot>  mueval: Prelude.read: no parse
04:28:09 <lambdabot> mueval: *** Exception: Prelude.tail: empty list
04:28:54 <gwern> hm. at a guess, haskell-src-exts can't parse the exception, and then the watchdog prints the error/exception
04:29:11 <gwern> :t lines
04:29:12 <lambdabot> String -> [String]
04:29:51 <Saizan> are you parsing exceptions?
04:30:51 <sjanssen> gwern: you're parsing the result of an expression?  Why?
04:31:06 <gwern> dunno
04:35:50 <IsoPallo> Hmm... Why do all the utils of the generic-linux package of ghc-6.8.3 give only floating-point errors when I try to compile the compilator?
04:36:05 <IsoPallo> You made that on purpose?
04:36:27 <Zao> IsoPallo: It's pwd that's broken.
04:36:35 <Zao> IsoPallo: Your libc is too old.
04:36:57 <IsoPallo> ghc-pkg gives that too.
04:37:11 <IsoPallo> Ok, will try to change libc...
04:40:24 <gwern> @seen dcoutts
04:40:24 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 8h 42m 23s ago.
04:40:26 <gwern> @seen dcoutts_
04:40:26 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
04:40:39 <gwern> dang
04:40:58 <gwern> anyone know why cabal claims 'Dependency bytestring -any: using bytestring-0.9.0.1
04:41:10 <gwern> but th claims: [23 of 81] Compiling Lambdabot        ( Lambdabot.hs, dist/build/lambdabot/lambdabot-tmp/Lambdabot.o )
04:41:13 <gwern> Failed to load interface for `Data.ByteString': no package matching bytestring-0.9.1.0 was found
04:41:17 <gwern> ?
04:43:09 <Heffalump> are you building for profiling?
04:43:21 <Heffalump> or some other way that the GHC RTS wasn't built for?
04:43:31 <Heffalump> s/the GHC RTS/GHC/
04:43:57 <gwern> no, this is nonprofiled
04:45:54 <Igloo> gwern: Do you have old .o/.hi files?
04:46:10 <gwern> dunno, let me look
04:46:47 <ttt--> hi, which is easier to build a little app with (im thinking a menubar and some buttons).. wxhaskell or gtk2hs?
04:47:53 <gwern> ttt--: I'd go with gtk2hs
04:48:12 <ttt--> ok :)
04:49:08 <gwern> hm. cleaning gets me a different th error
04:49:15 <gwern> ghc-6.8.2: /home/gwern/bin/lib/utf8-string-0.3.1.1/ghc-6.8.2/HSutf8-string-0.3.1.1.o: unknown symbol `bytestringzm0zi9zi0zi1_DataziByteStringziLazzy_chunks_info'
04:49:19 <gwern> Loading package utf8-string-0.3.1.1 ... linking ... ghc-6.8.2: unable to load package `utf8-string-0.3.1.1'
04:49:23 <gwern> perhaps I need to reinstall utf8-string as well
04:51:05 <gwern> I also find myself wondering about these warning at the start of the build,eg.
04:51:06 <gwern> I also find myself wondering about these warning at the start of the build,eg. ./dist/build/autogen/cabal_macros.h:52:0: warning: "MIN_VERSION_haskell" redefined
04:55:35 <gwern> [31 of 81] Compiling Plugin.Babel     ( Plugin/Babel.hs, dist/build/lambdabot/lambdabot-tmp/Plugin/Babel.o )
04:55:37 <gwern> Failed to load interface for `Data.ByteString': no package matching bytestring-0.9.1.0 was found
04:55:40 <gwern> argh
04:55:47 <gwern> the reinstall of utf8-string helps but little!
04:58:04 <Saizan> i think ghc is not respecting the -hide-all-packages and -package flag for TH
04:58:30 <Leaves> hello, do you know why this doesn't work?    numDigits :: Integer -> Integer; numDigits n = 1 + (floor $ log 10 (fromInteger n))
04:58:42 <Leaves> it gives an error on the second arg of log
04:59:44 <Saizan> :t log
04:59:45 <lambdabot> forall a. (Floating a) => a -> a
04:59:45 <Twey> :t log
04:59:46 <lambdabot> forall a. (Floating a) => a -> a
04:59:47 * Twey laughs.
05:00:09 <Leaves> oops, that should be logBase
05:00:10 <Twey> log is a natural logarithm, I think, Leaves
05:00:14 * Twey nods.
05:00:32 <Leaves> but in the code I have logBase
05:00:40 <Saizan> :t logBase
05:00:41 <lambdabot> forall a. (Floating a) => a -> a -> a
05:00:42 <Leaves> just typed in in here wrong, it gives an error
05:01:01 <Saizan> what's the error?
05:01:27 <Leaves> Saizan:  No instance for (Floating Integer)
05:01:51 <Saizan> :t floor
05:01:52 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
05:02:34 <Saizan> :t \n -> 1 + floor (logBase 10 $ fromInteger (n :: Integer))
05:02:35 <lambdabot> forall t. (Integral t) => Integer -> t
05:03:01 <Saizan> > let numDigits n = 1 + floor (logBase 10 $ fromInteger (n :: Integer)) in numDigits 123
05:03:02 <lambdabot>  3
05:03:41 <Saizan> Leaves: it's something else, maybe paste your code?
05:03:48 <tristes_tigres> :t float log
05:03:49 <lambdabot>     Couldn't match expected type `Float' against inferred type `a -> a'
05:03:49 <lambdabot>     In the first argument of `float', namely `log'
05:04:15 <Saizan> :t float
05:04:16 <lambdabot> Float -> Doc
05:04:33 <zandax> hi
05:04:41 <Leaves> Saizan: sorry, it seems to work now, I don't know what I was trying
05:04:53 <tristes_tigres> @vixen floating log
05:04:54 <lambdabot> my keyboard doesn't have an
05:04:56 <Leaves> Saizan: what I don't get is why there is a function fromInteger
05:05:05 <Twey> :t fromInteger
05:05:06 <lambdabot> forall a. (Num a) => Integer -> a
05:05:09 <Twey> It's a type-helper
05:05:15 <Saizan> ?src Num
05:05:15 <lambdabot> class  (Eq a, Show a) => Num a  where
05:05:15 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:05:15 <lambdabot>     negate, abs, signum     :: a -> a
05:05:15 <lambdabot>     fromInteger             :: Integer -> a
05:05:17 <Twey> It can convert an Integer to any Num
05:05:19 <Leaves> Saizan: instead of toFloat which works on integer or something..
05:05:35 <Saizan> Leaves: there's fromIntegral actually
05:05:38 * tristes_tigres doesn't get it either
05:05:40 <Saizan> :t fromIntegral
05:05:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:06:18 <Saizan> Leaves: fromInteger is used for numeric literals however, i.e. 10 == fromInteger (10 :: Integer)
05:06:35 <Saizan> :t realToFrac -- also useful for conversions
05:06:36 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
05:08:57 <Leaves> but it seems like haskell works in the opposite way as other languages, in many other language you would have toInteger :: Fraction -> Inegerl, toInteger :: Float -> Integer etc, so depending on the input type it would look up the correct function, but in haskell you can only have one input type for a function and it depends on the return type what it does.. (hope I'm clear)
05:09:52 <Saizan> Leaves: we can have both, it just depends on how you've defined the typeclass in question
05:11:15 <Saizan> and since fromInteger and fromRational are already needed to implement string literals i guess they didn't see a need for adding things like toFloat
05:11:17 <ivanm> is there a better way of doing something like this: filter (\ x -> (f x) `elem` ys)) ?
05:11:31 <ivanm> I can't seem to find a delete function or something like that that's applicable :s
05:11:54 <ivanm> f = fst or snd, not quite sure which one it'll be atm
05:12:17 <Saizan> s/string literals/numeric literals/
05:13:56 <Leaves> mm, but how I see it (which probably is too javaish way of looking at it) that Num is just an interface that is implementen by Int, Integer, Double and Float, but then one can only convert between Int, Integer etc but not to Num?
05:14:16 <Botje> :t fromInteger
05:14:17 <lambdabot> forall a. (Num a) => Integer -> a
05:14:30 <Botje> you can convert to a type that implements num, yes
05:14:32 <Botje> not to num itself
05:14:58 <Leaves> but how does fromIntegral know where to convert to?
05:15:04 <Botje> context.
05:15:26 <Botje> :t (/)
05:15:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:15:39 <Botje> > 5 / (fromIntegral 2)
05:15:39 <Saizan> yeah, typeclasses are like interfaces with generics
05:15:40 <lambdabot>  2.5
05:16:03 <Botje> because / needs a Fractional a, fromIntegral converts to a Fractional type
05:16:04 <ivanm> Leaves: magic!
05:16:27 <Botje> then, because of the monomorphism restriction
05:16:43 <Botje> haskell picks out the Float type from all those that "implement" Fractional
05:16:48 <Botje> and types it with that
05:17:56 <Leaves> Botje: by monomorphism restriction you mean that it is in haskell for instance impossible to also define a function (/) :: Char -> Char- > Bool
05:18:01 <Leaves> ?
05:18:14 <Leaves> since / is already defined
05:18:15 <Botje> no
05:18:22 <Botje> take the example above
05:18:34 <Botje> :t (/)
05:18:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:18:45 <Botje> / limits the types of its arguments to "Fractional a"
05:19:02 <Botje> however, the type inferencing engine needs an exact type
05:19:23 <Botje> There are two types that are Fractional: Float, Double, and Ratio (iirc)
05:19:34 <gwern> ah, I solved it! regex-compat was installed against bytestring 0.9.1.0!
05:19:38 <gwern> gee, thanks for nothing cabal
05:19:47 <Botje> to satisfy this "exact type" requirement, it just picks the first type that matches.
05:19:55 <Botje> :t 5 / (fromIntegral 2)
05:19:56 <lambdabot> forall t. (Fractional t) => t
05:20:35 <Botje> if you use that in an expression without any further restrictions, it'll just pick Float
05:20:52 <Leaves> ok, I see
05:21:20 <dcoutts> gwern: what could it have done or said that would have been more helpful?
05:22:05 <gwern> dcoutts: I have no idea. TH was just erroring saying it couldn't find b-0.9.1, and ultimately I looked at the module it was failing on, examined the imports, and guessed that the issue was the 'import Text.Regex'
05:22:40 <gwern> if had said something like 'couldn't find dep b-0,9.1 forced by import of regex-compat' (or even Text.Regex) that would've been better
05:22:55 <Leaves> Botje: do you know why it works this way?
05:22:57 <dcoutts> gwern: well that's ghc of course
05:23:19 <Leaves> Botje: for me it seems much more logical to give the return type instead of the input type
05:23:26 <Botje> Leaves: i believe it was implemented to simplify the type inferencer
05:23:38 <dcoutts> gwern: but I'm slightly surprised, did the package say it depends on regex-compat?
05:23:39 <Botje> but i'm sure haskell.org has more data on the monomorphism restriction
05:23:58 <gwern> dcoutts: yes
05:24:01 <Leaves> ok, I'll look there, thanks for you help
05:24:04 <gwern> lb does declare a compat dep
05:24:38 <dcoutts> gwern: because we depend on regex and it needs a version of bytestring that isn't installed anymore then cabal should have noticed that the package was broken
05:25:00 <dcoutts> gwern: can you reproduce the problem and give me any more details ?
05:25:06 <gwern> dcoutts: I'm looking at the configure output from one th-broken run. it says noithing about missing bytestring or conflicts
05:25:43 <dcoutts> gwern: so you fixed it by doing what?
05:25:44 <gwern> dcoutts: http://hpaste.org/10024
05:25:59 <dcoutts> gwern: ta
05:26:06 <gwern> dcoutts: I reinstalled regex-compat, forcing it to compile against b-0.9.0.1
05:27:06 <dcoutts> gwern: you didn't happen to have the same version of regex compat installed in both global and user package db or something?
05:27:17 <gwern> dcoutts: I notice that the configured regex-compat is 0.91, but the one TH used was 0,.92
05:27:27 <gwern> I believe this is the issue - TH is not respecting the configured deps
05:27:46 <dcoutts> gwern: hmm, right, perhaps TH just uses the latest rather than the one we specify
05:28:04 <gwern> cabal is smart enough to use the old regex-compat which was linked against 0.9.0.1, but TH used the higher 0.92 regex-compat which was brokenly linked against 0.9.1.0
05:28:09 <gwern> is my interpretation
05:28:24 <dcoutts> gwern: would regex-compat-0.91 have been ok then? I presume it was built against bytestring-0.9.0.1 right?
05:28:35 <gwern> dcoutts: right
05:28:45 <gwern> and cabal *was* building with 0.91, afaic
05:29:02 <dcoutts> gwern: ok, so cabal isn't going bonkers. So report it as a TH bug then I think.
05:29:24 <gwern> who, me? :(
05:29:37 <dcoutts> gwern: yes you :-)
05:30:40 * gwern sighs. all this yak-shaving when I just wanted to fix a djinn bug in lb
05:31:32 <dcoutts> gwern: ah stop complaining and go shave those yaks
05:31:41 <zandax> I started reading  the tutorial on arrays in the Gentle Introduction to Haskell, but I am still puzzled
05:31:42 <gwern> s
05:32:07 <dcoutts> Heffalump: as far as cabal is concerned it's always using "native" windows.
05:32:32 <zandax> Can I do something like this somehow "numbers1to10 = array (something) [1,2,3,4,5,6,7,8,9,10]" ?
05:32:43 <dcoutts> Heffalump: if ghc could be built as a cygwin program (which it cannot at the moment afaik) then Cabal might need to know too.
05:32:52 <gwern> dcoutts: so cabal is in fact hiding all packages and exposing only a few?
05:32:57 <Botje> zandax: you want listArray, then
05:33:08 <Botje> listArray (1,10) [1..10]
05:33:29 <dcoutts> gwern: yes, -hide-all-package -package regex-compat-0.91
05:33:35 <zandax> I see! And is it possible to have two-dimensional arrays in a similar way?
05:33:49 <Botje> listArray ((1,1),(4,4)) [1..16]
05:34:17 <zandax> great :)
05:35:12 <zandax> thank you!
05:35:21 <Botje> np, have fun :)
05:36:05 <zandax> and the addressing with myarray ! (column, row) ?
05:36:25 <Botje> i think it's row, column
05:36:31 <Botje> not sure how it lays it out :)
05:36:41 <Botje> > range ((1,1),(4,4))
05:36:42 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
05:36:45 <Botje> yeah
05:36:51 <Botje> first coordinate is row
05:37:06 <zandax> ok :D
05:38:00 <RayNbow> > 1 + maxBound :: Int
05:38:02 <lambdabot>  -9223372036854775808
05:38:14 <Heffalump> dcoutts: hmm, ok. Is there any way for it to know whether "build-type: configure" can actually work or not?
05:38:31 <RayNbow> hmm
05:38:36 <jeffz> I mixed cygwin with cabal-install the other day, got it to build alex.
05:38:39 <RayNbow> > maxBound :: Int
05:38:40 <lambdabot>  9223372036854775807
05:38:44 <RayNbow> large ints :)
05:38:52 <dcoutts> Heffalump: only by trying to run sh, I guess it could probe this earlier
05:39:01 <Heffalump> I'm trying to add "native windows" support to a package that uses that build-type, and I would guess that the author would be unhappy if I just ripped out the configure stuff :-)
05:39:13 <Heffalump> but I think it could at least fall back, in this case.
05:39:42 <dcoutts> Heffalump: hmm, that seems like a fairly bold decision for it to take
05:40:02 <Heffalump> I mean that this package could fall back, not that cabal could.
05:40:04 <Botje> hmm
05:40:12 <Heffalump> I'd like to be able to say "if configure doesn't work, do this" in the .cabal file.
05:40:13 <Botje> haskell seems to cram more bits into an int than other competing languages.
05:40:16 <Botje> that's good.
05:40:29 <dcoutts> Heffalump: then do it in the Setup.hs and use build-type: Custom
05:40:54 <Heffalump> ok.
05:40:56 <dcoutts> Heffalump: build-type configure is just a one liner in Setup.hs and you can customise from there
05:41:08 <Heffalump> not very declarative :-)
05:41:32 <dcoutts> Heffalump: build-type: configure is really just a short hand
05:42:02 <gwern> dcoutts:         process_ _ "djinn-add"  s = do
05:42:04 <gwern> dammnit
05:42:09 <Heffalump> in what way is build-type: simple not a short hand?
05:42:09 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2555
05:42:10 <lambdabot> Title: #2555 (Template Haskell does not respect -package and -hide constraints) - GHC - ...
05:42:43 <dcoutts> Heffalump: in a sense it is too, but it allows several short cuts
05:43:07 <dcoutts> Heffalump: all the build-types are specified in terms of different Setup.hs scripts
05:43:32 <dcoutts> Heffalump: but if it's a known common one then we can avoid compiling and linking and invoking an external Setup program
05:43:34 <Heffalump> so what are the constraints for making thinks like cabal-install work?
05:43:43 <Heffalump> s/thinks/things/
05:44:04 <dcoutts> Heffalump: it just has to be a Cabal package that respects the deps declared in the .cabal file
05:44:52 <Heffalump> so the autoconf would be banned from probing Haskell deps itself?
05:45:11 <dcoutts> Heffalump: well, so long as it comes up with the same decisions is ok :-)
05:45:52 <dcoutts> Heffalump: I mean if you end up depending on things you didn't mention then the package manager is going to make incorrect decisions
05:46:24 <dcoutts> Heffalump: so for build-type Simple it's enforced, for build-type: Make or Custom it is not
05:46:47 <Heffalump> and for build-type: Configure it's not?
05:47:11 <dcoutts> Heffalump: I can't remember if the .buildinfo files can add build-depends or not, they probably can
05:48:17 <dcoutts> Heffalump: in other words, configure scripts probably can add deps behind the back of the package manager
05:48:59 <dcoutts> Heffalump: even when using the simple build system (build-type configure being autoconf + simple)
05:49:33 <gwern> @seen cantor
05:49:33 <lambdabot> cantor is in #ghc and #haskell. I don't know when cantor last spoke.
05:49:37 <gwern> @seen Cale
05:49:37 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 3h 1m 44s ago.
05:50:18 <gwern> @tell Cale I've pushed a patch improving the djinn error when it's not installed. I know you'll find this useful...
05:50:18 <lambdabot> Consider it noted.
05:51:00 <dmhouse> gwern: really? I thought "Prelude.tail: empty list" was perfectly clear! :)
05:51:18 <gwern> dmhouse: perhaps to you, but we need to think of the newbies
05:58:26 <ivanm> if using something like sortBy (compare `on` f), does it save the results of f or recompute it for each comparison?
05:59:02 <Saizan> ivanm: recompute
05:59:15 <ivanm> Saizan: so f isn't O(1), would it be better to do something like map (\x -> (f x, x)) and then sortBy (compare `on` f) ?
05:59:30 <ivanm> that's what I've been doing up till now, but just wanted to check
05:59:45 <Saizan> if the latter is compare `on` fst, then yes
05:59:57 <ivanm> ummm, yeah, that
06:00:07 <Saizan> if you care about performance
06:00:17 <ivanm> *nod*
06:00:39 <r3m0t> :t first ?f
06:00:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a, ?f::a b c) => a (b, d) (c, d)
06:01:01 <Saizan> :t ?f *** id
06:01:02 <lambdabot> forall b c a. (?f::b -> c) => (b, a) -> (c, a)
06:01:08 <Saizan> err..
06:01:13 <Saizan> :t ?f &&& id
06:01:14 <lambdabot> forall b c. (?f::b -> c) => b -> (c, b)
06:03:28 <Saizan> it's very nice to not get those random "thread killed" anymore
06:07:00 <gwern> yes, the increased timeout seems to fix the issue
06:16:23 <zandax> I'm struggling now when I changed lists to arrays, because I don't know how to iterate through a bunch of indices :(
06:18:07 <dmhouse_> zandax: which array are you using?
06:19:45 <zandax> I don't know exactly to be honest. I'm creating it with listArray and it is two-dimensional
06:19:52 <zandax> I felt lucky that it worked at least
06:20:02 <dmhouse> zandax: well, which array module are you importing?
06:20:48 <zandax> Data.Array
06:20:49 <Saizan> zandax: by iterate through a bunch of indices you mean like a for loop in other langs?
06:20:55 <zandax> yes Saizan
06:22:09 <dmhouse> Hmm, doesn't seem to be a good way of doing that apart from by using assocs and then array again.
06:22:24 <Saizan> it depends on the result you want to compute
06:22:24 <dmhouse> There is, in Data.Array.IArray:
06:22:29 <dmhouse> ?hoogle amap
06:22:29 <lambdabot> Data.Array.Base amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
06:22:29 <lambdabot> Data.Array.IArray amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
06:22:33 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
06:22:34 <dmhouse> ?hoogle ixmap
06:22:34 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
06:22:34 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
06:22:35 <lambdabot> Title: Data.Array.IArray, http://tinyurl.com/5q8qp6
06:32:06 <zandax> I can't really figure out how to use ixmap :/
06:35:09 <dmhouse> > ixmap (1,5) (+1) $ array (1,5) (zip [1..5] "abcde")
06:35:11 <lambdabot>  mueval: Prelude.read: no parse
06:35:11 <lambdabot> mueval: array (1,5) [(1,'b'),(2,'c'),(3,'d'),...
06:35:37 <dmhouse> Oh, interesting.
06:35:46 <dmhouse> It doesn't behave like I expected it to.
06:37:56 <dmhouse> zandax: I think ixmap (a,b) f a returns the array for which the entry at x is given by a ! (f x)
06:38:26 <dmhouse> Err, I used two `a's. ixmap (p,q) f a returns the array for which the entry at x is given be a ! f x.
06:39:39 <zandax> I give up :/
06:40:00 <dmhouse> zandax: ? Something wrong with my explanation?
06:40:34 <zandax> no, its rather my understanding.
06:41:02 <dmhouse> zandax: well, what exactly don't you understand?
06:41:11 <IsoPallo> Argh. Is there no ghc distribution that just works...
06:41:37 <jeffz> IsoPallo: which platform?
06:41:40 <IsoPallo> Now the official one destroyed the previous version I had too...
06:41:49 <zandax> I don't know what you mean by "given be a ! f x"
06:41:56 <IsoPallo> jeffz: PC/Linux
06:41:58 <dmhouse> zandax: typo, I meant "given by"
06:42:05 <dmhouse> IsoPallo: which distro?
06:42:15 <IsoPallo> eeePC/Linux, I menta.
06:42:23 <IsoPallo> dmhouse: xandros
06:42:31 <dmhouse> No idea.
06:42:34 <jeffz> that's something like debian... did you try the debian packages?
06:42:38 <zandax> @dmhouse: that is not the problem sadly
06:42:38 <lambdabot> Unknown command, try @list
06:42:40 <dmhouse> Although I suspect just downloading the binaries would work
06:42:43 <IsoPallo> It has 6.6, but I wanted 6.8 and that seems to give roble.
06:43:15 <IsoPallo> Debian has ghc only up to 6.6 too
06:43:18 <dmhouse> zandax: okay, so say you have this array a, and you define a new array b by b = ixmap (p,q) f a
06:43:23 <jeffz> yeah, downloading the binaries should work, I did that when I was on Ubuntu 7.10, 8.04 ships with 6.8 so I don't have to anymore
06:43:28 <zandax> ok dmhouse
06:43:35 <dmhouse> zandax: then whenever you do b ! x, what you're really doing is a ! f x
06:44:03 <zandax> now I got it! :)
06:44:29 <zandax> I'm not used to this kind of notation
06:44:35 <IsoPallo> jeffz: I tried the "unknown-linux" binares and they just crashed.
06:44:53 <IsoPallo> Naturally first overwriting the 6.6 there was :)
06:45:32 <gwern> 1/quit
06:45:59 <IsoPallo> Hmm... But maybe the Ubuntu package woud go in...
06:47:06 <jeffz> IsoPallo: might have been a good idea to remove the 6.6 package
06:49:38 <zandax> @dmhouse: The only problem remaining is that my function is not modifying the array and has a wrong return type
06:49:38 <lambdabot> Unknown command, try @list
06:50:03 <Myoma> don't type @ before names
06:50:33 <dmhouse> zandax: what do you mean?
06:50:35 <zandax> sorry, I'm doing that already for 5 years on daily basis. It's hard to stop
06:50:54 <zandax> dmhouse, my function returns a monad
06:51:38 <dmhouse> zandax: can you pastebin some code/
06:51:52 <zandax> of course
06:52:34 <zandax> http://pastebin.com/d6f25c4ae
06:53:15 <sioraiocht> @src reverse
06:53:16 <lambdabot> reverse = foldl (flip (:)) []
06:54:29 <dmhouse> zandax: firstly, I don't think you mean to pass (x,y) as the first parameter to ixmap
06:54:39 <dmhouse> zandax: the first parameter ought to be the new bounds of the array
06:55:03 <dmhouse> zandax: secondly, what is the type of drawTile_?
06:55:12 <luite_> is it possible to trap Int overflows in a haskell program?
06:55:43 <dmhouse> luite_: use Integer?
06:56:02 <luite_> dmhouse: I was afraid someone would suggest that ;)
06:56:44 <zandax> dmhouse: Draw ()
06:56:53 <dmhouse> zandax: no, the entire type
06:57:47 <zandax> actually it returns a "Graphic", but I'm sure Graphic equals Draw ()
07:10:34 <dansa> hello? anyone here using happs? i tried to install it; reported my failure to the mail list; have been ignored so far; i fulfilled all requirements; version of the compiler, et cetera, but things did not work; i've a feeling that's still under wild development; i thought the idea was good: take a webserver as part of your web system; wonderful for portability.
07:12:24 <dansa> i haven't seen yet anyone talking about template engines in haskell; but there's gotta be; i can't think of anyone seriously programming on the web without using a template engine like... smarty in php.
07:13:03 <jeffz> dansa: you might try the #happs irc channel
07:13:15 <dansa> jeffz: hm, alright
07:13:44 <jeffz> dansa: I don't think HAppS has had a "stable" release yet, still in beta is my understanding.
07:14:08 <dansa> yeah; feels like it;
07:14:14 <jeffz> dansa: even still, people have managed to put it to good use.
07:14:31 <dansa> i think the whole idea is of good use :)
07:15:17 <jeffz> I've tried to build it three times, I had a success rate of one third.
07:15:39 <Saizan> jeffz: there's a release on hackage
07:15:51 <dansa> i haven't been working with web development in years, but when i used to, i used to very carefully code in php to avoid clashes when moving to other webservers/phpengines and it was painful; with happs, i have a feeling that if my thing compiles, then it should also compile and run as i expect somewhere else, since the compiler being the same, the behavior will be the same :)
07:15:55 <jeffz> Saizan: yeah, I tried to install it with cabal-install on windows :)
07:15:59 <Saizan> jeffz: which builds as it is if you're on unix
07:16:23 <Saizan> jeffz: then you need the darcs version, which is basically the same + patches to avoid the unix dep
07:16:50 <dansa> i tried the darcs version
07:17:03 <jeffz> Saizan: ah, I wasn't really serious, I was just curious to see how it would fail... I was just testing cabal-install.
07:17:51 <dcoutts> jeffz: doesn't it have a dep on the unix package ?
07:18:44 <bos> @seen cosmicray
07:18:44 <lambdabot> cosmicray is in #haskell-blah and #haskell. I don't know when cosmicray last spoke.
07:19:11 <jeffz> dcoutts: I don't recall, I think was just picking things out of cabal list at random
07:20:19 <dcoutts> jeffz: well if you find anything that you think is a Cabal bug rather than a broken package then do report it. We don't get so much testing on windows.
07:20:25 <jeffz> dcoutts: I was testing in Wine, I managed to get hxq, a few games and then alex after fooling around with cygwin for sh.
07:20:37 <dcoutts> jeffz: are you using the latest release on windows btw? 0.5.2, it can actuall re-install itself :-)
07:21:01 <jeffz> dcoutts: it's good, cabal exposed some bugs in Wine, so I've been writing testcases to integrate into the Wine testsuite to figure out how to fix the bug
07:21:20 <jeffz> dcoutts: I used whatever was on hackage
07:22:30 <dansa> @seen Cale
07:22:30 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 4h 34m 37s ago.
07:22:33 <dcoutts> jeffz: I released 0.5.2 a couple days ago
07:22:38 <dansa> :)
07:22:41 <trofi> how can i make my parces parser lazy? i have such structure: parse = skipSpaces; result <- many1 parseEntry; eof; return result {- try to use: Right r = parse input; print $ head r; parses whole input(600 megs) -}
07:22:56 <dcoutts> jeffz: oh yeah? what kind of wine bugs?
07:23:10 <Myoma> trofi: it has to read the eof to succeed
07:23:41 <jeffz> dcoutts: exposed a bug affecting the implementation of msvcrt's _unlink and kernel32's DeleteFile, in short removeDirectoryRecursive doesn't work without patching Wine
07:23:59 <CosmicRay> hi bos
07:24:16 <bos> good morning.
07:24:55 <jeffz> dcoutts: all good fun.
07:25:12 <bos> CosmicRay: i was confused by that email you sent two weeks ago or so, wondering if there was anything i ought to be doing.
07:25:20 <dcoutts> jeffz: :-)
07:25:41 <trofi> Myoma: is it fundamental for parsec parsers, or it is just in my case?
07:25:56 <Myoma> trofi: the bit: eof;
07:26:11 <dcoutts> jeffz: do you happen to know if MoveFileEx REPLACE_EXISTING  is supposed to be atomic on win32?
07:26:56 <trofi> Myoma: if i remove it - i will loose error handling at eof. will it become lazy?
07:27:51 <jeffz> dcoutts: not offhand
07:28:21 <Myoma> trofi: Why not try it out?
07:28:33 <trofi> ok :]
07:28:56 <dcoutts> jeffz: np, msdn is monumentally unhelpful on the point. Perhaps I'll look at the wine code to see if they've investigated that aspect.
07:29:11 <trofi> doesn't help
07:30:09 <ayu2008> > 1+1
07:30:11 <lambdabot>  2
07:30:17 <ayu2008> >foldl (\a b -> a/b)1[2]
07:30:34 <trofi> >"no"
07:30:40 <trofi> > "yes"
07:30:41 <lambdabot>  "yes"
07:30:59 <ayu2008> hey guys, i want to ask about foldl(/)1[1]
07:31:10 <Myoma> > foldl(/)1[1]
07:31:11 <ayu2008> is it the same as foldl (\a b -> a/b)1[1] ?
07:31:11 <lambdabot>  1.0
07:31:16 <dmhouse> ayu2008: yes.
07:31:21 <Myoma> ayu, it does
07:31:24 <trofi> @pl (\a b -> a/b)
07:31:24 <lambdabot> (/)
07:31:30 <ayu2008> ok, i just realised something new :D
07:31:45 <ayu2008> took me some time to understand how foldl works
07:31:56 <dmhouse> ayu2008: see http://en.wikibooks.org/wiki/Haskell/More_on_functions#Infix_versus_Prefix
07:32:08 <lambdabot> Title: Haskell/More on functions - Wikibooks, collection of open-content textbooks, http://tinyurl.com/yxvt8f
07:34:03 <ayu2008> dmhouse: thanks for the link :D
07:34:06 <ayu2008> very useful
07:35:29 <jeffz> dcoutts: I notice there's a MoveFileTransacted
07:35:50 * SamB_XP_ thinks its a bad sign that his desktop wallpaper looks like a vista dialog claiming to warn of spyware infections ...
07:36:31 <dcoutts> jeffz: aye, in vista iirc.
07:37:18 * SamB_XP_ also thinks it's a bad sign that some program tried to add a program with a totally gibberish name to the startup list, and a program with a name like .tmp.foo or foo.tmp. or something had a fatal exception ...
07:37:33 <dcoutts> jeffz: but the transacted stuff is more sophisticated, it allows a series of operations to be initiated and then committed or rolled back.
07:38:23 <SamB_XP_> so ... do you think I might have a piece of arrogant spyware on my hands ? so arrogant it tells you when it believes itself to have been installed?
07:38:52 <jeffz> dcoutts: ah vista/2008, I hadn't noticed the transacted stuff untill earlier today
07:38:59 <dmhouse> SamB_XP_: hehe. It's pretty standard practice these days for spyware to pretend to identify other spyware, then "clean" your hard drive,
07:44:53 <SamB_XP_> dmhouse: the funny thing is that it just says to run your antivirus software ...
07:45:27 <dmhouse> SamB_XP_: oh, no "Let me fix that for you!" message?
07:50:37 <Botje> unsafeInstallspyware
07:59:33 <ayu2008> test
07:59:40 <Myoma> test
07:59:47 <ayu2008> hey guys, i received an error message
07:59:50 <ayu2008> Last generator in do {...} must be an expression
07:59:57 <ayu2008> what does it mean?
08:01:14 <dmhouse> ayu2008: pastebin your code.
08:01:18 <BONUS> @where that dons blog entry about making haskell really fast
08:01:18 <lambdabot> I know nothing about that.
08:01:24 <ayu2008> ok
08:01:25 <EvilTerran> ayu2008, well, you can have three different types of line in a do-block
08:01:26 <Myoma> > do x <- return 1
08:01:27 <lambdabot>      The last statement in a 'do' construct must be an expression
08:01:30 <Myoma> > do x <- return 1 ; return x
08:01:31 <lambdabot>      No instance for (Show (t1 t))
08:01:31 <lambdabot>       arising from a use of `show' at <int...
08:02:03 <EvilTerran> do ...; expression; ...; pattern <- expression; ...; let { pattern = expression; ... }; ...
08:02:35 <EvilTerran> because of how the desugaring works, only an expression on its own makes sense at the end of a do-block - this being the value returned by the block as a whole
08:03:29 <EvilTerran> if a block finished with "pattern <- expression" or a standalone "let" (as in with no "in" - only valid in do-blocks), there'd be no meaningful value for the block to return
08:03:36 <ayu2008> http://www.mibbit.com/pb/6UChGT
08:03:37 <lambdabot> Title: Mibbit: PasteBin
08:03:38 * shepheb curses haddock's worthless error messages.
08:03:53 <EvilTerran> ayu2008, remove the "in"
08:03:59 <shepheb> there's more haddock comments than code in this module and it won't even give a line number
08:04:09 <EvilTerran> ayu2008, you don't need it in do-blocks
08:04:33 <EvilTerran> > (do let x = 1; return x) :: Maybe Int
08:04:34 <lambdabot>  mueval: Prelude.read: no parse
08:04:48 <EvilTerran> > (do let { x = 1 }; return x) :: Maybe Int
08:04:51 <lambdabot>  Just 1
08:04:55 <Myoma> > do let x = 1 in x
08:04:57 <ayu2008> evilterran: i don't need do-blocks?
08:04:57 <lambdabot>      No instance for (Num (t t1))
08:04:57 <lambdabot>       arising from the literal `1' at <inte...
08:05:00 <Myoma> > do let x = 1 ;in x
08:05:01 <lambdabot>      No instance for (Num (t t1))
08:05:01 <lambdabot>       arising from the literal `1' at <inte...
08:05:12 <EvilTerran> ayu2008, no, you don't need "in"s at the end of "let"s in do-blocks
08:05:14 <Myoma> ayu2008: Remove teh 'in'
08:05:39 <ayu2008> i have remove it, it works now :D but have other haskell errors haha, how do i change a string to 1 character?
08:05:53 <EvilTerran> ayu2008, the problem is that "let count c = ..." and "in count c s" are being interpreted as different lines of the do-block
08:06:24 <ayu2008> ok...
08:06:29 <EvilTerran> ayu2008, the other solution would be to indent the "in" more than the line above, which would make them count as the same line. but that wouldn't be as idiomatic.
08:06:58 <EvilTerran> strings are lists of characters
08:07:00 <EvilTerran> > ['a']
08:07:02 <lambdabot>  "a"
08:07:10 <EvilTerran> > 'a':[] -- also the same
08:07:12 <lambdabot>  "a"
08:07:45 <EvilTerran> ?src String
08:07:45 <lambdabot> type String = [Char]
08:08:05 <EvilTerran> ayu2008, so, to get the first Char out of a [Char], you would use...?
08:09:03 <ayu2008> use head?
08:10:51 <ayu2008> am I wrong?
08:11:29 <dmhouse> No.
08:12:06 <EvilTerran> ayu2008, yep, head is the right answer
08:12:18 <EvilTerran> but be careful you don't pass it an empty string/list
08:12:19 <ayu2008> there wasn't any reply, so i was thinking im wrong somewhere
08:12:21 <EvilTerran> > head "a"
08:12:23 <lambdabot>  'a'
08:12:33 <trofi> :t bracket
08:12:34 <EvilTerran> ayu2008, sorry, i was AFK for a minute
08:12:36 <lambdabot> Not in scope: `bracket'
08:12:46 <ayu2008> don't pass an  empty string?
08:12:54 <EvilTerran> you could always have tried it out in an interpreter (or lambdabot) yourself, though :)
08:12:57 <EvilTerran> > head ""
08:12:59 <lambdabot>  mueval: Prelude.read: no parse
08:12:59 <lambdabot> mueval: *** Exception: Prelude.head: empty list
08:13:02 <EvilTerran> ?src head
08:13:03 <lambdabot> head (x:_) = x
08:13:03 <lambdabot> head []    = undefined
08:13:28 <EvilTerran> head is a partial function - it'll cause an error if you ask for the head of an empty list
08:15:03 <ayu2008> weird
08:15:05 <ayu2008> i get the same error again
08:15:23 <ayu2008> http://www.mibbit.com/pb/4ikGA6
08:15:24 <lambdabot> Title: Mibbit: PasteBin
08:15:32 <ayu2008> ERROR file:.\test.hs:10 - Last generator in do {...} must be an expression
08:15:49 <dino-> Has anyone here used Data.Yaml.Syck ?
08:17:14 <dino-> I must be doing it wrong. Parsing even a super simple one-line document and then emitYaml on it is giving me garbage output.
08:17:24 <dmwit> ayu2008: Change "in" to "return $"
08:17:38 <dmwit> ayu2008: Also: you can't pattern match on head.
08:17:56 <dmwit> let count (c:_) = ... -- you need to do this instead
08:18:08 <dmwit> You can only pattern-match on constructors.
08:18:14 <ayu2008> ok
08:18:18 <dmwit> (:) and [] are the list constructors
08:18:37 <dmwit> But...
08:18:41 <dmwit> why don't you do
08:18:44 <dmwit> c <- getChar
08:18:45 <dmwit> instead?
08:18:57 <dmwit> Then not bother mucking about with head, (:)-matching, etc?
08:19:26 <ayu2008> lol I did not think about getChar, since i used lots of getLine XD
08:19:46 <ayu2008> ok i replace getLine with getChar for my character :)
08:20:36 <EvilTerran> ayu2008, incidentally, something which may make understanding pattern-matching easier is the concept of "equational reasoning"
08:21:51 <EvilTerran> which basically boils down to, if you have a definition "... = ...", you can replace something that matches the left-hand-side (with appropriate values substituted for any variables) with the right-hand-side (with the same values for the variables)
08:22:01 <EvilTerran> indeed, you can go the other way, too
08:22:24 <ayu2008> is equational reasoning on wiki?
08:22:40 <Myoma> why would it have to be on the wiki, EvilTerran just explained it
08:23:04 <EvilTerran> this is one of my favourite things about haskell
08:24:01 <ayu2008> oh thought you grab somewhere on wiki, usually people give me links -_-
08:24:17 <ayu2008> i ran into another error. *** Type           : Char  *** Does not match : [Char]
08:24:17 <dino-> Myoma: For future seekers of knowledge who don't get somebody 'live' to explain.
08:24:25 <EvilTerran> i don't know of any particularly good explanations, on wiki pages or elsewhere
08:24:30 <EvilTerran> perhaps i should write one
08:24:38 <dmwit> ayu2008: I suggest you try to track this one down yourself.
08:24:39 <dmwit> ;-)
08:24:42 <Myoma> dino-: That seems like a motivating reason to _write_ a page
08:25:09 <dmwit> ayu2008: It should be within your grasp, and it will help you a lot to figure these things out on your own.
08:25:10 <Myoma> rather than read a wiki page, why not a book?
08:25:12 <EvilTerran> ayu2008, anyway, if you were familiar with equational reasoning, you would see that "count (head c) = ..." wouldn't mean what you wanted even if it were valid
08:25:21 <Myoma> (Algebra of Programming)
08:25:45 <ayu2008> i dont have a book
08:25:54 <dmwit> ayu2008: On the other hand, if you bang your head against it for more than, say, 15 minutes, definitely let us know.  It makes sense to think, but not to be frustrated. =)
08:26:02 <EvilTerran> Myoma, that'd be by the very people who made me so fond of equational reasoning, at that :)
08:26:17 <ayu2008> i dont get it, why does char not equal to [Char]
08:26:24 <ayu2008> is it anything within brackets means string?
08:26:30 <EvilTerran> it means "list of"
08:26:35 <EvilTerran> [Char] = list of characters
08:26:38 <EvilTerran> [Int] = list of integers
08:26:51 <EvilTerran> [[Bool]] = list of (lists of booleans)
08:26:59 <EvilTerran> also note
08:27:01 <EvilTerran> ?src String
08:27:01 <lambdabot> type String = [Char]
08:27:21 <EvilTerran> [Char] and String are exactly equivalent
08:27:26 <ayu2008> ?src Int
08:27:26 <lambdabot> data Int = I# Int#
08:27:35 <EvilTerran> ew internals. ignore that one.
08:27:42 <Myoma> ?src Int#
08:27:43 <lambdabot> Source not found.
08:28:13 <EvilTerran> Myoma, i think that one's impossible to define in haskell, because of its strictness properties
08:28:23 <ayu2008> what does this mean? (c:_)
08:28:24 <EvilTerran> (Int# = unboxed integer, i believe)
08:28:36 <Myoma> ayu2008: Do you kow what : means?
08:28:39 <EvilTerran> ayu2008, that's a list that starts with c, and we don't care what comes after
08:28:46 <EvilTerran> ayu2008, have you read any haskell tutorials?
08:29:14 <ayu2008> not really
08:29:14 <Myoma> ayu,
08:29:15 <Myoma> > 1 : (2 : (3 : []))
08:29:17 <lambdabot>  [1,2,3]
08:29:20 <Myoma> > [1,2,3]
08:29:22 <lambdabot>  [1,2,3]
08:29:26 <EvilTerran> most beginners' tutorials will explain all the list syntax
08:29:38 <EvilTerran> including what [...] means in types, what : means, and so forth
08:29:42 <ayu2008> so : join character into a list?
08:29:46 <pastorn> @type (:)
08:29:47 <lambdabot> forall a. a -> [a] -> [a]
08:29:53 <Myoma> : is the CONStructor of lists
08:30:33 <EvilTerran> ayu2008, http://book.realworldhaskell.org/read/getting-started.html#starting.string
08:30:34 <Myoma> > let (c:_) = 1 : (2 : (3 : [])) in c
08:30:39 <lambdabot> Title: Chapter 1. Getting Started, http://tinyurl.com/5r9u2l
08:30:39 <lambdabot>  1
08:30:39 <Myoma> > let (c:_) = [1,2,3] in c
08:30:41 <lambdabot>  1
08:30:43 <dino-> ayu2008: This is one of the first things I started really digging into. http://en.wikibooks.org/wiki/Haskell/YAHT
08:30:44 <ayu2008> so what does the underscore do?
08:30:44 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
08:30:54 <Myoma> _ is a dont-care pattern
08:30:58 <pastorn> Myoma: http://en.wikibooks.org/wiki/Haskell/Lists_and_tuples
08:31:04 <Myoma> pastorn: Thank you
08:31:30 <EvilTerran> ayu2008, sorry, i mean http://book.realworldhaskell.org/read/getting-started.html#starting.list
08:31:31 <lambdabot> Title: Chapter 1. Getting Started, http://tinyurl.com/5r9u2l
08:31:36 <pastorn> Myoma: it might be a good idea to start a /query with lambdabot
08:31:46 <pastorn> it helped me alot when i started to learn
08:31:55 <pastorn> especially the @src command
08:32:04 <ayu2008> wow nice tutorial websites, i have not seen those before
08:32:13 <pastorn> @src (:)
08:32:13 <lambdabot> Source not found. There are some things that I just don't know.
08:32:17 <EvilTerran> ?src []
08:32:17 <pastorn> @src map
08:32:17 <lambdabot> data [] a = [] | a : [a]
08:32:17 <lambdabot> map _ []     = []
08:32:17 <lambdabot> map f (x:xs) = f x : map f xs
08:32:18 <ayu2008> bookmarking them :D
08:32:36 <EvilTerran> that definition of [] is pseudocode, not valid haskell
08:32:49 <pastorn> EvilTerran: wired into compiler?
08:32:54 <EvilTerran> but it could be compared to "data List a = Nil | a : List a", which would be valid haskell
08:33:14 <EvilTerran> pastorn, yeah, lists are very syntactic-sugary
08:33:24 <pastorn> heh :)
08:34:49 <ayu2008> syntactic surgary?
08:35:08 <dmhouse> EvilTerran: no it wouldn't
08:35:12 <Valodim> surgery? haha
08:35:15 <ayu2008> what does return$ do?
08:35:15 <dmhouse> EvilTerran: Nil | Cons a (List a) would be
08:35:18 <dmhouse> EvilTerran: : is reserved
08:35:23 <Myoma> use :::
08:35:25 <dmhouse> ayu2008: "$" is an operator
08:35:45 <dmhouse> ayu2008: it's useful for removing parenthese. Instead of writing f (g x) you can write f $ g x
08:36:06 <SamB> pastorn: many compilers accept such pseudocode when building their Preludes, but ... well, that's an implementation detail ;-)
08:36:08 <EvilTerran> dmhouse, well, yes, but i felt a minor lie would save obfuscating the simularity
08:36:22 <ayu2008> thanks dmhouse for explaining :)
08:36:25 <EvilTerran> dmhouse, and, if the syntactic sugar were absent, mine would be valid
08:36:47 <pastorn> is Real World Haskell availabel for purchase yet?
08:37:29 <dmhouse> pastorn: I don't think it's finished
08:37:55 <dmhouse> I.e. hasn't been proof-read etc.
08:39:43 <ayu2008> hmm
08:39:43 <ayu2008> my code works now
08:39:56 <ayu2008> no errors, but it does not generate results o_o
08:40:26 <ayu2008> http://www.mibbit.com/pb/AOFnHt
08:40:26 <lambdabot> Title: Mibbit: PasteBin
08:40:45 <Myoma> ayu, did you want it to print something out?
08:42:12 <ayu2008> yeah
08:42:15 <Myoma> ... instead of return use print
08:42:17 <ayu2008> i want to print out the number
08:42:23 <EvilTerran> ayu2008, well, you're not telling it to print out the number
08:43:54 <ayu2008> if i replace return with print, it has error
08:44:02 <Myoma> :t return
08:44:03 <Myoma> :t print
08:44:04 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:44:05 <lambdabot> forall a. (Show a) => a -> IO ()
08:44:17 * Myoma doubts that
08:45:02 <ayu2008> Unresolved top-level overloading
08:45:11 <ayu2008> *** Binding             : main  *** Outstanding context : (Num b, Show ([Char] -> b))
08:45:12 <Myoma> what haskell are you using?
08:45:19 <ayu2008> winhugs
08:45:38 <Myoma> what's the exact line of code?
08:45:45 <sclv> the problem is polymorphism
08:46:02 <ayu2008> whats the exact line?
08:46:11 <sclv> print works on all Show. so if you don't specify exactly which type of number you're using somewhere, it doesn't know how to print it.
08:46:49 <EvilTerran> sclv, defaulting should get that
08:47:09 <EvilTerran> sclv, the problem is some mistake causing it to look for "Show ([Char] -> b)"
08:47:12 <Myoma> ayu, what code you have written?
08:47:18 <ayu2008> http://www.mibbit.com/pb/QjmrKr
08:47:18 <lambdabot> Title: Mibbit: PasteBin
08:47:34 <Myoma> oh you should hive
08:47:37 <zandax> Ok, I completly switched from lists to arrays now, but how can I edit a value in an array? :|
08:47:38 <Myoma> count (c:s) (c:s)
08:47:47 <EvilTerran> Myoma, er, what?
08:48:11 <EvilTerran> count doesn't even need any parameters - all the variables it needs are in scope at the point of definition
08:48:11 <Myoma> "what"?
08:48:22 <EvilTerran> Myoma, why the heck would you have the same parameter twice?
08:48:25 <Myoma> count needs two parameters
08:48:32 <EvilTerran> the same one?
08:48:36 <EvilTerran> twice?
08:48:51 <EvilTerran> i mean it could perfectly well be defined with no parameters, if it's being defined there
08:48:55 <EvilTerran> by changing the definition
08:49:19 <pastorn> what's the name/author of a series of algorithm books where all examples are written in an ASM-y language?
08:49:29 <EvilTerran> i can see the point for using one parameter if it were to use explicit recursion
08:49:38 <EvilTerran> but it isn't, so there isn't one
08:49:52 <pastorn> i think it's like 4 or 7 volumes or something...
08:50:40 <EvilTerran> ayu2008, incidentally, i would suggest defining count using explicit recursion instead of foldl
08:51:09 <ayu2008> i cant use foldl?
08:51:13 <Myoma> yes you can
08:51:15 <EvilTerran> did i say "can't"?
08:51:17 <Myoma> just make the change I suggested
08:51:18 <EvilTerran> (hint: no)
08:51:49 <EvilTerran> Myoma, sorry, but writing "count (c:s) (c:s)" is an utterly absurd suggestion
08:51:52 <ayu2008> huh
08:51:52 <ayu2008> im confused now >.<
08:52:03 <ayu2008> so remove one of them?
08:52:07 <Myoma> EvilTerran: You suggest changing several things at once -- and the result is confusion
08:52:13 <joey`> ayu2008: Is the purpose of the program to take a string, then a char and return how many times the char occurs in the string?
08:52:15 <Myoma> EvilTerran: I suggest fixing one problem at a time
08:52:27 <ayu2008> yes joey
08:52:35 <ayu2008> you got straight to the point
08:52:37 <EvilTerran> Myoma, and then, when ayu2008 gets it working, he goes away thinking that's a sensible way to write code
08:52:42 <Myoma> EvilTerran: absurd or not it's not going to be set in stone
08:52:57 <Myoma> EvilTerran: no, that's ridiculous, they can look at the code and see a way to improve it
08:53:08 <joey`> ayu2008: http://hpaste.org/10028 Something like that?
08:53:08 <EvilTerran> i've seen beginners be told a minimal change that gets their code working and then leaving as soon as it seems to work
08:53:15 <EvilTerran> with no insight into why it works
08:53:15 <Toxaris> ayu2008: I suggest filtering the string so that only the char to be counted remains, and then using the length of the string as result
08:53:48 <dmhouse> joey`: length . filter (==c) alternatively
08:54:10 <joey`> dmhouse: I used a foldl to keep it similar to his original paste.
08:54:38 <Myoma> :t count
08:54:39 <lambdabot> Not in scope: `count'
08:54:50 <ayu2008> hey joey , it works
08:54:57 <dmhouse> joey`: okay.
08:55:38 <ayu2008> hmm
08:55:56 <ayu2008> haskell generates the answer on the same line after my getChar
08:56:09 <Myoma> nl = putStrLn ""
08:56:12 <zandax> ok, so how can I increment a specific value in an Array?
08:56:13 <Myoma> nl;nl;nl
08:56:13 <EvilTerran> Myoma, i prefer to steer someone towards a solution they will understand rather than outright giving them one they won't
08:56:26 <Myoma> EvilTerran: Then you failed at that
08:56:44 <EvilTerran> it takes time
08:56:45 <EvilTerran> patience
08:56:50 <EvilTerran> grasshopper :)
08:56:54 <Myoma> and does it take everyone talking at once?
08:57:03 <Toxaris> zandax: what kind of array? Data.Array?
08:57:16 <EvilTerran> Myoma, no, that isn't helpful. it's not my fault you were talking, though. :P
08:57:17 <Saizan> zandax: Array is an immutable array, so you basically have to create a new one with the element incremented
08:57:45 <ayu2008> myoma: where do i place this nl
08:57:45 <EvilTerran> and it becomes wholly impossible when other folk choose to take the other tactic
08:58:01 <Myoma> ayu2000: In your source file
08:58:02 <Saizan> zandax: so, updating an Array is O(n)
08:58:02 <dmwit> joey`: ewww
08:58:18 <EvilTerran> ayu2008, do you understand why the code you now have works?
08:58:18 <dmwit> joey`: Why not just "print . length . filter (== c) $ s"?
08:58:20 <zandax> O(n) ?
08:58:20 <joey`> dmwit: ewwwww indeed
08:58:22 <Myoma> EvilTerran: You jumped in and confused them after I gave them something to try -- not sure what you are saying with that "not my fault you were talking"
08:58:34 <joey`> dmwit: As I said, I tried to change his original code as little as possible
08:58:38 <dmwit> o
08:58:43 <joey`> dmwit: Hence the foldl. Hence the let etc.
08:58:47 <zandax> Saizan I don't understand :)
08:58:53 <ayu2008> myoma: putStrLn "nl" ?
08:59:10 <Myoma> ayu2000: what
08:59:27 * dmwit notices there are many, many people helping
08:59:28 <ayu2008> hmm i want to make a new line after getChar
08:59:31 <dmwit> I'll step out. =)
08:59:31 <EvilTerran> dmwit, "helping"
08:59:41 <EvilTerran> i'm giving up as well
08:59:56 <ayu2008> EvilTerran from starcraft or something
08:59:56 <Myoma> nl;
09:00:00 <EvilTerran> Myoma seems convinced he can do a better job on his own
09:00:20 <EvilTerran> ayu2008, well, partly. there's terrans in plenty of science fiction. :)
09:00:20 <Myoma> ayu2014: The idea is to make a function nl that will print a newline .. and then use it
09:00:42 <ayu2008> i have not use nl before, so I do not know where to put it
09:00:58 <ayu2008> in c , they teach "\n abcdef \n"
09:01:07 <Toxaris> ayu2008: that will work in Haskell as well.
09:01:11 <Myoma> nl; putStrLn "abcdef"
09:01:12 <ayu2008> but haskell, its a little different
09:01:17 <Myoma> nl; putStr "abcdef"; nl
09:02:08 <ayu2008>  Undefined variable "nl"
09:02:13 <ayu2008> o_O
09:02:25 <Myoma> ayu____: You can define it like I showed you min ago:  nl = putStrLn ""
09:02:26 <Toxaris> EvilTerran: I see what you mean ...
09:02:57 <Toxaris> EvilTerran: But teaching is hard, and irc-based teaching is harder, so there is no point in preventing people to try it
09:03:39 <ayu2008> oh ok
09:03:47 <ayu2008> i finally get it now :)
09:03:54 <EvilTerran> Toxaris, indeed -- i do get uncomfortable when i don't like how it's being done, though. i worry that we may break the beginners ;)
09:04:19 <ayu2008> i was thinking of putting nl=putStrLn in my main, but does not work
09:04:32 <EvilTerran> i don't want someone coming away from here thinking that haskell is weird and ugly because someone corrected their code to something highly non-idiomatic
09:04:46 <ayu2008> i just realised that nl = putStrLn"" should be placed outside
09:05:29 <shapr> SHAZAM!
09:05:37 <EvilTerran> i want them coming away from here thinking haskell is weird and beautiful :)
09:05:47 <shapr> It's not weird, everything else is weird!
09:06:05 <Myoma> everyone else is crazy too
09:06:22 <ayu2008> evilteran: i do get uncomfortable when i don't like how it's being done, though ?
09:07:09 <Saizan> zandax: by O(n) i meant that it takes linear instead of constant time to update an array, an the code will look like arr // [(index,newelement)]
09:07:21 <Saizan> ?type (//)
09:07:22 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
09:07:42 <EvilTerran> ayu2008, by "it", i mean "irc-based teaching"
09:07:54 <ayu2008> i find that joey code is easy to understand ^_^
09:08:27 <ayu2008> makes sense for me
09:08:31 <joey`> joey`: That was the intention; I wasn't aiming for idtiomatic code.
09:08:38 <joey`> ayu2008: *
09:09:03 <Toxaris> ayu2008: I may be wrong, but I think EvilTerran tried to steer you into the direction of joey`s code. which is fine, imho.
09:09:11 <Toxaris> both the steering and the code
09:09:17 <dino-> Yesterday I made my deadline at work. This is a kind of big project I've inherited. I completed parts of it with Haskell and going forward am aiming to replace everything else. It's been a big success so far.
09:09:27 <ayu2008> steering?
09:09:49 <Toxaris> it's not as "cool" as length . filter (c ==), but it works and is not totally absurd
09:10:00 <Toxaris> ayu2008: as in "making you invent it yourself", or something.
09:10:10 <dino-> I want to say thank you to a lot of you who hang around here. I have been helped quite a bit over the past couple of years.
09:10:29 <EvilTerran> Toxaris, yeah, joey` pretty much ended up where i was aiming
09:10:30 <dmwit> yay!
09:10:42 <Lycurgus> yeah this is the most active and useful channel of it's kind known to me
09:11:01 <Lycurgus> *its
09:11:02 <joey`> EvilTerran: Maybe I should have let him get there on his own. But I assumed since he understood his own code, changing 5 characters wouldn't be too much of a jump.
09:11:08 <EvilTerran> ayu2008, by "steering" i mean "not giving you the answer directly, but encouraging you to work it out yourself"
09:11:37 <ayu2008> sorry evilterran, the truth is, I did not really understand what you are trying to guide me on.
09:11:46 <EvilTerran> joey`, yeah, i wasn't entirely sure if ayu2008 understood his own code, TBH (no offence meant, ayu2008 - i sometimes write code i don't understand, too :P)
09:12:45 <EvilTerran> ayu2008, sorry, it takes me some time to get a feel for how closely i should be guiding someone towards the correct answer
09:12:46 <ayu2008> i was puzzled when someone first mention that let does not need in, because of the do-block stuff, but joey code have let and in
09:12:54 <EvilTerran> ayu2008, http://hpaste.org/10028#a1
09:13:06 <EvilTerran> that shows what i meant about not needing "in"
09:13:08 <Myoma> > do let x = 1; return x
09:13:09 <lambdabot>  mueval: Prelude.read: no parse
09:13:16 <Toxaris> :)
09:13:26 <EvilTerran> it also shows what i meant about "count" not needing any parameters
09:13:40 <EvilTerran> > (do let { x = 1 }; return x) :: Maybe Int
09:13:42 <lambdabot>  Just 1
09:13:50 <Myoma> Toxaris: ?
09:14:06 <zandax> "array // [((y, x), 0)]" <- is this a way to change the value at y|x in an array?
09:14:13 <ayu2008> and the funny thing appears (c:_) which made me more confused
09:14:17 <EvilTerran> ayu2008, in a do-block, "let ..." followed by a newline is the same as "let ... in do" followed by a newline
09:14:23 <ayu2008> i could not really link that stuff into the code
09:14:44 <Toxaris> Myoma: I find it funny when the "explain things through code snippets for lambdabot" fail with a buggy error message.
09:14:46 <Myoma> zandax: for a  a mutable array I wouldn't use that
09:14:53 <EvilTerran> ayu2008, i've relied on that in the code at http://hpaste.org/10028#a1
09:14:55 <SamB> hmm, is there a < O(n^2) algorithm to build up an array from one-element arrays by using only binary concatenation ?
09:15:28 <Myoma> SamB: Allocate the space and write each cell into the correct location
09:15:31 <zandax> Myoma: why not?
09:15:48 <EvilTerran> ayu2008, does that code i've pasted make sense to you?
09:15:50 <SamB> oh, nevermind, it seems that with this P4 the naive algorithm is good enough ...
09:15:57 <Myoma> zandax: STArray is better
09:16:04 * SamB for some reason is working on ICFP 2006 again ;-)
09:16:09 <dolio> @type runSTArray
09:16:10 <lambdabot> Not in scope: `runSTArray'
09:16:19 <zandax> :/
09:16:27 <Myoma> zandax: what?
09:16:55 <ayu2008> oh thanks for the clarification about the let and in, previously i use let and in, but my let was in a few lines instead of 1
09:17:02 <zandax> I thought I could finally make it work now with a few steps, Myoma
09:17:14 <Myoma> zandax: You probably could
09:17:15 <EvilTerran> ayu2008, you can leave off the "in" on multi-line "let"s in do-blocks, too
09:17:26 <zandax> Myoma, where are the advantages with an STArray?
09:17:55 <joey`> Hmm, the "let" in that code is pretty superfluous anyways
09:18:55 <Toxaris> SamB: I would expect a divide-and-conquer approach to copy O(n log n) elements instead of O(n^2).
09:19:39 <EvilTerran> ayu2008, see http://hpaste.org/10028#a2 for a contrived (but relevant) example
09:20:37 <Toxaris> SamB: the first step produces (n/2) arrays of size 2 copying all n elements, the second step produces (n/4) arrays of size 4 copying all n elements, ... in total, you need log n steps to produces a single array of size n
09:21:40 <Toxaris> SamB: you can use something like my growfold to implement this: http://hpaste.org/9124
09:21:51 * Toxaris ignores SamB's "never mind"
09:23:51 <ayu2008> evilterran: neat :D
09:24:31 <ayu2008> you created a custom function f to be used in foldl ; foldl value1 value2
09:25:37 <EvilTerran> ayu2008, yep. haskell is awesome like that.
09:27:09 <ayu2008> your code is much more neater than the previous ^_^ "
09:27:42 <ayu2008> hmm
09:27:49 <bran> does anyone have examples of hooking up a monadic alex lexer to a monadic happy parser?
09:27:58 <ayu2008> does haskell have an inbuilt function that is able to convert small letter into big letter?
09:28:05 <Myoma> toUpper
09:28:07 <ayu2008> and the opposite way round
09:28:10 <joey`> > toUpper 'a'
09:28:11 <lambdabot>  'A'
09:28:16 <joey`> > toLower 'A'
09:28:18 <lambdabot>  'a'
09:28:23 <ayu2008> > toUpper '.'
09:28:24 <lambdabot>  '.'
09:28:31 <ayu2008> > toUpper '+'
09:28:33 <lambdabot>  '+'
09:28:39 <IsoPallo> bran: I think GHC does that? :)
09:28:58 <ayu2008> aha jsut realiased something
09:29:04 <ayu2008> pretty cool :D
09:29:24 <ayu2008> > a `elem` [A]
09:29:25 <lambdabot>  mueval: Prelude.read: no parse
09:29:34 <ayu2008> eh not working?
09:29:38 <Myoma> > a `elem` "A"
09:29:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
09:29:45 <Toxaris> > 'a' `elem'  "A"
09:29:45 <joey`> > 'a' `elem` "A"
09:29:47 <lambdabot>  mueval: Prelude.read: no parse
09:29:47 <lambdabot> Terminated
09:29:57 <Toxaris> > 'a' `elem` "A"
09:29:58 <lambdabot>  False
09:30:08 <EvilTerran> ayu2008, the reasoning that i used was that (\pattern -> expression) is precisely the same as (let f pattern = expression in f)
09:30:58 <ayu2008> oh
09:31:00 <EvilTerran> ayu2008, and then it was just a case of moving that definition of "f" from the rather silly place it was (inside a parameter to foldl) to a better-placed "let"
09:31:31 <ayu2008> so the pattern expression thingy is the one (latest code you show me) ?
09:32:39 <EvilTerran> the intermediate step in my reasoning looked like "let count = foldl (let f x y = if y == c then x+1 else x in f) 0
09:32:39 <EvilTerran> s"
09:32:50 <EvilTerran> er, that s should be on the same line. not sure what happened there.
09:33:22 <EvilTerran> as i said, direct replacement of (\ ... -> ...) with (let f ... = ... in f)
09:33:32 <EvilTerran> then i could move that definition of "f" to somewhere more appropriate
09:34:00 <ayu2008> im not good with jargons like pattern matching or pattern expression, so if someone mention it, I do not grasp what they are saying (me being as a newbie)
09:34:12 <EvilTerran> of course, as i've been writing haskell for a while, i really did all this in my head, and didn't have to write down the intermediate step
09:34:27 <EvilTerran> but i used that reasoning in my mind
09:34:53 <EvilTerran> ayu2008, ok, well, never mind the jargon for now. basically i meant "anything that looks like (\ ... -> ...) can be replaced with with (let f ... = ... in f), keeping the '...'s the same"
09:35:38 <ayu2008> ok :)
09:36:11 <ayu2008> i'll jot that down in my haskell diary :)
09:36:59 <EvilTerran> yeah, that's a useful one to know. especially if you find (\ ... -> ...) as ugly as i find it :)
09:37:59 <ayu2008> now i have a new problem :)
09:38:13 <ayu2008> a new question :D
09:38:42 <ayu2008> im now trying to do a string conversion, from lowercase to uppercase,
09:38:58 <EvilTerran> ayu2008, well, you know about toUpper, right?
09:39:02 <Toxaris> whats the point / reason / workaround about "mueval: Prelude.read: no parse"?
09:39:09 <ayu2008> however, the user input might have inserted dots. example Mr. Apple, and I want to make it as MR APPLE
09:39:19 <EvilTerran> ... i'm afraid i have to go sort out my dinner just now, but i should be back on here later today
09:39:19 <Myoma> :t isAlpha
09:39:20 <ayu2008> removing any symbols or dots, (which are not letters)
09:39:21 <lambdabot> Char -> Bool
09:39:23 <dmwit> Toxaris: Is it valid Haskell?
09:39:29 <EvilTerran> there's plenty of people here to help you, though :)
09:39:31 <Myoma> > filter (not . isAlpha) "Mr. Apple"
09:39:33 <lambdabot>  ". "
09:39:34 <ayu2008> ]ok
09:39:36 <Toxaris> > (let f (a, b) = 42 in f) undefined
09:39:37 <lambdabot>  mueval: Prelude.read: no parse
09:39:38 <lambdabot> mueval: *** Exception: Prelude.undefined
09:40:11 <Toxaris> @type (isUpper &&& toLower) 'c'
09:40:12 <lambdabot> (Bool, Char)
09:40:15 <Toxaris> > (isUpper &&& toLower) 'c'
09:40:17 <lambdabot>  mueval: Prelude.read: no parse
09:40:25 <ayu2008> myoma?
09:40:29 <Myoma> what?
09:40:31 <Toxaris> > 21 * 2
09:40:33 <lambdabot>  42
09:40:40 <ayu2008> what is this filter (not . isAlpha) "Mr. Apple"
09:40:44 <Toxaris> dmwit: seems pretty random to me
09:40:56 <joey`> ayu2008: Filter removes elements from a list based on some predicate
09:41:12 <ayu2008> joey: isAlpha?
09:41:33 <joey`> isAlpha is just a function to determine if a character is an alphabetic character
09:41:36 <joey`> > isAlpha 'a'
09:41:37 <lambdabot>  True
09:41:40 <joey`> > isAlpha '%'
09:41:42 <trofi> how can i get part of input parsec already consumed at successful parse?
09:41:42 <lambdabot>  False
09:42:01 <Toxaris> ayu2008: in case you don't know, there is a cool Haskell API search at http://haskell.org/hoogle/
09:42:06 <ayu2008> wow, cool function :) did not know it exist
09:42:10 <lambdabot> Title: Hoogle
09:42:59 <Toxaris> ayu2008: you can use it both to search for documentation on function names (e.g. "isAlpha"), and to search for function of type you want, e.g. ("Char -> Char" for "toUpper")
09:43:26 <im_alone__> @google watkin learning
09:43:44 <lambdabot> Plugin `search' failed with: thread killed
09:44:00 <im_alone__> @google watkins learning
09:44:02 <lambdabot> http://www.lib.alasu.edu/
09:44:02 <bran> isopallo: ah, thanks
09:44:02 <lambdabot> Title: University Library
09:44:12 <ayu2008> what does the dot do in between of (not . isAlpha) ?
09:44:19 <joey`> ayu2008: It's function composition
09:44:25 <dmwit> Toxaris: I agree, very arbitrary.
09:44:33 <joey`> It's the same as not (isAlpha x)
09:44:35 <ayu2008> composition = to join?
09:44:42 <dmwit> Toxaris: complain at gwern
09:44:57 <joey`> @src (.)
09:44:57 <lambdabot> (f . g) x = f (g x)
09:44:59 <dmwit> f . g x = f (g x)
09:45:19 <bpalmer>   @src ($)
09:45:25 <dmwit> ayu2008: If you've seen function composition in math, this is the same beast.
09:45:36 <dmwit> bpalmer: f $ x = f x
09:46:05 <bpalmer> dmwit: right, just experimenting with lambdabot :)
09:46:11 <ayu2008> hmm maths use x
09:46:12 <ayu2008> like 3x2=6
09:46:28 <bpalmer> (but thanks)
09:46:57 <ayu2008> weird my winhugs does not recognise isAlpha
09:47:22 <ayu2008> Hugs> :t isAlpha  ERROR - Undefined variable "isAlpha"
09:47:28 <dmwit> ayu2008: import the Char module
09:47:43 <dmwit> I think it's ":load Char" in Hugs.
09:47:59 <joey`> ayu2008: If you're looking to just filter out '.' then you probably don't want isAlpha
09:48:01 <dmwit> Also, x in math is multiplication, not composition.
09:48:02 <ayu2008> coool it works now ^_^
09:48:38 <dmwit> Math uses a centered, hollow circle for composition.
09:48:41 <joey`> > filter isAlpha "A sentence with a space."
09:48:43 <lambdabot>  "Asentencewithaspace"
09:50:22 <byorgey> greetings, #haskell!
09:50:23 <dmwit> :t isSymbol
09:50:24 <lambdabot> Char -> Bool
09:51:07 <dmwit> > filter (not . isSymbol) "A sentence."
09:51:09 <lambdabot>  "A sentence."
09:51:12 <dmwit> bummer
09:51:16 <dmwit> :t isPunctuation
09:51:17 <lambdabot> Char -> Bool
09:51:21 <dmwit> hey, alright!
09:51:29 <dmwit> > filter (not . isPunctuation) "A sentence."
09:51:29 <byorgey> what does isSymbol do?
09:51:31 <lambdabot> Terminated
09:51:33 <dmwit> > filter (not . isPunctuation) "A sentence."
09:51:35 <lambdabot>  "A sentence"
09:51:35 <Toxaris> im_alone__: do you mean a specific text about e-learning applicable to #haskell?
09:51:45 <dmwit> > isSymbol '\161'
09:51:46 <joey`> > flter (not . isSymbol) "Mr. Apple"
09:51:47 <lambdabot>  mueval: Prelude.read: no parse
09:51:47 <lambdabot> Terminated
09:51:51 <dmwit> > isSymbol '\161'
09:51:52 <joey`> > flter (not . isSymbol) "Mr. Apple"
09:51:52 <Toxaris> im_alone__: or was your @google just a guess?
09:51:53 <lambdabot>  mueval: Prelude.read: no parse
09:51:53 <lambdabot> Terminated
09:51:55 <dmwit> bah
09:51:57 <byorgey> > filter isSymbol [' '..]
09:51:59 <lambdabot>  "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\2...
09:52:00 <joey`> Heh.
09:52:18 <im_alone__> Toxaris, i confused the channel, sorry.
09:52:19 <ayu2008> > toUpper $ filter (isAlpha) "Mr. Apple"
09:52:20 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:52:24 <Myoma> > filter isAlpha [0..]
09:52:25 <lambdabot>      No instance for (Num Char)
09:52:25 <lambdabot>       arising from the literal `0' at <intera...
09:52:37 <Myoma> > filter isAlpha (iterate succ (toEnum 0))
09:52:39 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
09:52:46 <Toxaris> im_alone__: oh too bad, we actually were talking about e-learning before :)
09:53:00 <dmwit> ayu2008: toUpper works on single characters.
09:53:08 <Toxaris> im_alone__: so I hoped for some interesting thoughts
09:53:09 <ayu2008> how do i make it work on a string
09:53:13 <byorgey> > map toUpper "like this"
09:53:14 <lambdabot>  "LIKE THIS"
09:53:21 <dmwit> ayu2008: Do you remember which function lifts single-character functions to list functions?
09:53:33 <ayu2008> > map toUpper $ filter (isAlpha) "Mr. Apple"
09:53:35 <lambdabot>  "MRAPPLE"
09:53:41 <ayu2008> wow
09:53:43 <byorgey> oh, sorry, didn't mean to give away the answer =)
09:53:52 <ayu2008> thanks byorgey
09:54:02 <ayu2008> dont need to be sorry :D
09:54:06 <joey`> > map toUpper $ filter isSymbol "Mr. Apple" -- Preserve the space
09:54:08 <lambdabot>  ""
09:54:15 <byorgey> ayu2008: hehe =)
09:54:16 <joey`> > map toUpper $ filter (not . isSymbol) "Mr. Apple" -- Preserve the space
09:54:17 <lambdabot>  "MR. APPLE"
09:54:25 <joey`> Hmm. Or not!
09:54:50 <im_alone__> Toxaris, the Markov Decision Processes are a little hard to understand
09:55:26 <ayu2008> i just realised that my Mr. Apple becomes messed up (no spacing) T_T
09:55:37 <joey`> > map toUpper $ filter (/='.') "Mr. Apple" -- Preserve the space
09:55:39 <lambdabot>  "MR APPLE"
09:56:10 <dmwit> > map toUpper . filter (not . isPunctuation) $ "Mr. Apple" -- as long as we're giving away solutions
09:56:12 <lambdabot>  "MR APPLE"
09:56:27 <joey`> ayu2008: isAlpha filters out spaces as well as the punctuation
09:57:06 <ayu2008> > map toUpper . filter (not . isPunctuation) $ "Mr* Apple"
09:57:08 <lambdabot>  "MR APPLE"
09:57:37 <Kub4n4_> http://www.pennergame.de/change_please/2494401/
09:57:42 <lambdabot> Title: Pennergame
09:57:44 <ayu2008> oh ok thanks for the clarification joey
09:57:59 <Toxaris> > map toUpper . unwords . map (filter isAlpha) . words $ "Mr.    Apple"
09:58:01 <lambdabot>  "MR APPLE"
09:58:31 <Toxaris> Kub4n4_: mer gebe nix.
10:03:04 <ayu2008> toxaris: what is unwords
10:03:13 <ayu2008> and later is continued with words
10:03:32 <Toxaris> ayu2008: note that you have to read a chain of functions with dots from right to left
10:03:48 <Toxaris> ayu2008: words is first applied, then map (filter isAlpha), then unwords, and finally map toUpper
10:04:19 <ayu2008> oh, i read it from left to right.
10:04:29 <dmwit> ayu2008: Have you looked at any tutorials?
10:04:41 <dmwit> There are a few that come highly recommended.
10:04:43 <ayu2008> not yet >.<
10:04:50 <Toxaris> ayu2008: did you try hoogle to look up unknown functions: http://haskell.org/hoogle/?hoogle=words
10:04:51 <lambdabot> Title: words - Hoogle
10:06:12 <ayu2008> what does it mean by "words breaks a string up into a list of words, which were delimited by white space."
10:06:24 <joey`> On a side note, is there any difference between Prelude.words and Data.List.words?
10:06:30 <bd_> > words "breaks a string up into a list of words"
10:06:32 <lambdabot>  ["breaks","a","string","up","into","a","list","of","words"]
10:06:33 <ayu2008> breaks a string? into a list of word?
10:06:39 <ayu2008> wow ok
10:06:44 <bd_> :)
10:06:56 <Toxaris> joey`: no
10:07:12 <ayu2008> thanks bd_
10:07:22 <dmhouse> joey`: generally Prelude.stuff are just re-exported versions of functions elsewhere in the hieararchy.
10:07:27 <Toxaris> joey`: words "lives" in Data.List, and Prelude reexports it
10:07:37 <joey`> dmhouse, Toxaris: I see, thanks.
10:08:13 <Toxaris> joey`: but there are sometimes functions which are named like Prelude functions elsewhere, which may do the same thing as the Prelude function, but for a different data structure
10:08:25 <Toxaris> joey`: e.g., Data.ByteString.Char8.words
10:08:36 <joey`> Toxaris: Thanks, I'm aware of that
10:08:45 <dcoutts> qualified imports ftw!
10:09:02 * Toxaris wants qualified exports
10:09:03 <dmwit> "as" imports ftw!
10:09:33 <bd_> qualified imports FTL - haskell should be able to work out what implementation I meant from the type :(
10:09:49 <SamB> bd_: what about if they both have the SAME type?
10:10:00 <Toxaris> bd_: how should that work, given that Haskell has to work out the type, too
10:10:08 <Toxaris> bd_: you cannot expect Haskell to work out everything :)
10:10:22 <Toxaris> > doWhatIWantPlease 42 -- doesn't work
10:10:23 <bd_> SamB: Then the functions should have a different name :)
10:10:23 <lambdabot>  mueval: Prelude.read: no parse
10:10:23 <joey`> You can expect it, just expect to be dissapointed!
10:10:32 <SamB> bd_: it does!
10:10:35 <bd_> Toxaris: well, you can have eg words in a StringLike typeclass
10:10:48 <SamB> Bar.foo vs. Baz.foo
10:10:58 <bd_> words :: (StringLike s, Monoid m) => s -> m s
10:11:10 <bd_> SamB: an example being?
10:11:16 <Toxaris> bd_: I agree, and it should live there, and then Haskell would behave as you want it too
10:11:29 <Toxaris> bd_: but there are name clashes without similiar semantics
10:11:32 <bd_> because then I'd argue that 'foo' is a bad name for whatever it is :)
10:11:41 <bd_> Toxaris: true, but haskell should generalize whatever it can imo
10:11:59 <SamB> bd_: it is possible to overdo it
10:12:08 <Toxaris> bd_: not Haskell, but the Haskell programmers, if you are talking about more methods instead of normal functions
10:12:47 <Toxaris> bd_: foo is not the name, the name is Bar.foo and Baz.foo, and you are allowed to call it foo *in the rare case where it doesn't clash*
10:13:50 <bd_> Toxaris: I'd think that many of the cases where you have they they're either a) really the same function with a different type or b) badly named
10:13:52 <Toxaris> bd_: Monoid doesn't work like that
10:14:16 <bd_> :(
10:14:21 <Toxaris> sure, many cases, maybe most cases, but not all cases, so we still need import as for the remaining cases
10:14:25 <Toxaris> @kind Monoid
10:14:25 <ayu2008> bd_ are you a haskell developer?
10:14:27 <lambdabot> Class `Monoid' used as a type
10:14:33 <SamB> bd_: in what sense?
10:14:36 <bd_> ayu2008: I develop, in haskell, at times :P
10:14:46 <ayu2008> toxaris seem to be hasekll developer, he knows alot o_o and i know just a little
10:14:53 <bd_> SamB: well, what examples are there ofr Bar.foo and Baz.foo having entirely different semantics?
10:15:06 <SamB> how about that UTF8 module
10:15:12 <SamB> whatever it's called
10:15:31 <IsoPallo> Byhyy... It seems there is really no way to have a ghc 6.8 on eeepc... I hape there is really nothing new in the 6.8 and the version number was changed just to fool people...
10:15:31 <Toxaris> @hoogle comma
10:15:32 <lambdabot> Text.Parsec.Token comma :: GenTokenParser s u m -> ParsecT s u m String
10:15:32 <lambdabot> Text.PrettyPrint.HughesPJ comma :: Doc
10:15:32 <lambdabot> Language.Haskell.TH.PprLib comma :: Doc
10:16:01 <bd_> parsers make sense - you're likely to only import one at a time
10:16:03 <Toxaris> bd_: the Parser comma and the PrettyPrint comma actually *have* similiar semantics, but how to find a common type for them?
10:16:33 <Toxaris> bd_: I want to import both Parser and PrettyPrinter in the same module
10:17:03 <ayu2008> thanks everyone! i got to go now ^_^ " thanks toxaris, thanks joey', thanks dmwit, thanks byorgey, thanks evilterran, thanks lamb the bot (lambdabot)
10:17:17 <byorgey> see you ayu2008
10:17:26 <bd_> Toxaris: You should be splitting that into two modules :P
10:17:36 <dmwit> lamb da bot... now that's a new parse
10:18:03 <Toxaris> bd_: yeah, that's what I do. nevertheless, it's an example for unrelated foo's which have the same name for a good reason.
10:18:14 <bd_> mmm
10:18:22 <bd_> still, there is need for more consolidation :/
10:18:33 <bd_> there's no reason foldl should specify [] specifically, etc
10:19:21 <Toxaris> @type Data.Foldable.foldl
10:19:22 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
10:19:29 <bd_> Toxaris: that should be in the prelude :)
10:19:45 <Toxaris> it cannot be in the H98 Prelude because of currentYear > 1998
10:19:58 <the_unmaker> so is anyone here running a website absed on haskell?
10:20:02 <the_unmaker> based
10:20:19 <bd_> Toxaris: It could be in the GHC prelude ;)
10:20:26 <bd_> -XGeneralizedPrelude
10:20:31 <Myoma> Toxaris: What does mer gebe nix mean?
10:20:46 <Toxaris> Myoma: we give nothing
10:20:50 <sheyll> hi
10:21:01 <Myoma> oh ok
10:21:16 <dmhouse> Toxaris: what language is that? Looks Germanic, but it's not German. Dutch?
10:21:32 <Toxaris> dmhouse: it's regional german
10:21:36 <sheyll> how do I implement the principle of encapsulation and information hiding in haskell?
10:21:41 <dino-> the_unmaker: I believe hpaste was built with HAppS 0.8.x. Or was if that's changed.
10:21:44 <Myoma> sheyll: lol
10:21:55 <dmhouse> Toxaris: which region? "mer" instead of "wir" is pretty different
10:21:58 <sheyll> :)
10:22:16 <sheyll> do I use phantom types?
10:22:19 <Toxaris> dmhouse: Frankfurt am Main and afaik the rest of Hessia
10:23:08 <Toxaris> sheyll: for abstract data types, you can use the module system. export the type, but not the constructors, and only the functions which belong to the public interface
10:23:08 <sheyll> Myoma: I know it sounds ridicolous, but until s1 tells me otherwise, I think this question makes sense.
10:23:15 <tibbe> morning all
10:23:23 <dmhouse> Toxaris: I see.
10:24:20 <sheyll> Toxaris: so a haskell modules have finer granularity than i.e. java packages?
10:24:49 <sheyll> Toxaris: meaning, that I would have a module for about every java class?
10:25:02 <Toxaris> sheyll: well, it depends on the role of the Java class
10:25:29 <Toxaris> sheyll: many libraries use the module system both to provide a convenient set of interface functions, and to structure the code internally
10:25:46 <Toxaris> sheyll: you can reexport functions in Haskell, so you can provide the same function from more then one module
10:26:08 <Toxaris> sheyll: this way, you can also implement data hiding internal to the library
10:26:35 <Toxaris> often, you have a module per data type, e.g. Data.Map
10:27:49 <Toxaris> sometimes, you have a bunch of data types which work together, so they all go to the same module (similiar to friend declarations in C++)
10:28:33 <Toxaris> sometimes, you have more complicated scenarios, so you use the type system to implement your own access control, with e.g. existential types, phantom types, ...
10:28:39 <sheyll> Toxaris: I see. So when i.e. implementing library for Map manipulation, I would not export the "data ..." and "newtype..." definitions, but only constructor functions, as it is done in Data.Map
10:29:43 <Toxaris> yep, these are called "smart constructors" in Haskell, because they are like the constructors from data declarations, but more smart, since they can do additional processing, like enforcing invariants or hiding internal structure
10:30:46 <sheyll> great, thanks for the explanation. Do you recommend using phantom types and existential types? (If so I will learn how to use them)
10:31:57 <FordCortina> when people say that GADTs dont really work with type classes, are they referring to the following?:  if I make a Nat type with GADTs, I cannot make it meaningful instance of Eq?
10:32:30 <Toxaris> sheyll: obviously depends on what you want to do, but I suggest you try without them, if there is no evidence that you need them.
10:33:47 <stepcut> sometimes you have many modules per type, e.g., Data.Time
10:34:54 <sheyll> ok, so I will study the module system, phantom types and existential types, and see what fits my purposes :)
10:35:11 <Myoma> FordCortina: What did you want Eq to mean?
10:35:38 <Myoma> FordCortina: i.e. you can write a GADT for Eq which works by structural unification -- but did you want things like Eq One (Add One One)
10:36:13 <FordCortina> Myoma i meant Prelude.Eq , the type class
10:36:46 <Myoma> oh!
10:36:58 <Myoma> yeah 3 == 'x' doesn't typecheck
10:37:23 <Myoma> neither does foo == bar where foo :: Z, and bar :: S (S Z)
10:37:37 <FordCortina> Myoma: that's right
10:37:56 <Toxaris> but that's a problem specific to Eq, not to GADTs
10:38:06 <Myoma> so I guess you can try to write a family of instances .. not sure how it would work tough
10:38:22 <Toxaris> you could have class MyEq a b where myEq :: a -> b -> Bool
10:38:23 <Cale> If you can't ask whether things are equal when they are not, and the answer is always "yes" otherwise, then I wouldn't worry about it :)
10:38:23 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:38:45 <Myoma> JMEq in haskell? :o
10:39:13 <Myoma> FordCortina, you never considered writing this parser in Coq?
10:39:18 <Myoma> FordCortina, and compiling into haskell ...
10:39:34 <Myoma> fwiw you would probably be more productive
10:40:39 <FordCortina> Myoma: I guess I would try that, if I had the time. I have to wrap this up in the next few days though :(
10:40:40 <im_alone__> hi, are there Markov libs or Neural libs in Haskell?
10:40:54 <Myoma> FordCortina, oh, well, good luck though
10:41:08 <im_alone__> hi, in the example of cart-pole problem, after being trained for the Markov Decision Process. The resulted stationary controller, can it be again trained for Artificial Neural Network to reduce the size of the stationary controller?
10:41:10 <Toxaris> class MyEq a b where myeq :: a -> b -> Maybe (a -> b, b -> a) -- if the value is equal, the types have to be equal, too
10:41:12 <Myoma> FordCortina, Will you release it to us ? (I am interested to see it)
10:42:02 <Myoma> (once it's finished)
10:42:42 <FordCortina> Myoma: Ill see. Right now there isn't huge amounts of code, mainly ideas and little examples.
10:54:06 <RayNbow> hmm... can the definition of the function 'g' be written in a clearer style? http://pastebin.com/d74b8d7f
10:55:03 <Myoma> You could define list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
10:55:11 <Myoma> as a starting point, to get 'g' pointfree
10:55:18 <Myoma> may not end up clearer though
10:55:29 <dmhouse> RayNbow: I think that's already pretty clear.
10:55:50 <dmhouse> Myoma: I would probably expect `list' to be a catamorphism on list types (i.e. foldr)
10:56:03 <Myoma> dmhouse: Then what would you call the list destructor?
10:56:37 <Myoma> I have called it list for a while, since  maybe  and  either  can be thought of as either destructors or catas
10:56:40 <dmhouse> I'm not sure. (Btw doesn't foldr (const . cons) nil work?)
10:57:04 <Myoma> foldr (const . (:)) [] -- doesn't equal id
10:57:08 <Myoma> list [] (:) = id
10:57:30 <dmhouse> Oh, "cons x xs", sorry.
10:57:44 <dmhouse> I read it as "cons x"
10:57:55 * Myoma thinks destructList is too long to be a sensible name
10:58:10 <Myoma> :t uncons
10:58:11 <lambdabot> Not in scope: `uncons'
11:01:30 <RayNbow> dmhouse, Myoma: thx for the input :)
11:01:47 <Toxaris> I would expect uncons :: [a] -> (a, [a])
11:03:44 <tj9991> Hey guys, I've got a question which can hopefully be answered quickly.  I've went through a few beginner texts on Haskell and am still struggling with escaping the paradigms that have been with me for the past few years.  Anyone know of something geared towards people who have experience in languages such as Python?
11:05:04 <Vq^> there is a tutorial for former C programmers
11:07:05 <Vq^> tj9991: http://www.haskell.org/~pairwise/intro/intro.html
11:07:05 <lambdabot> Title: Haskell for C Programmers
11:08:04 <tj9991> Hm, I'll give that a shot, thanks.
11:12:00 <tj9991> Ah, just got through part of the first secion, this looks like just what I needed.
11:20:11 <tennin> a mighty type judgement?
11:22:33 <mapreduce> I like that Haskell for C Programmers tutorial, thus far.
11:22:48 <Myoma> It's funny how there's so many tutorials "______ for C programmers" like they need extra help to learn
11:24:11 <mapreduce> I think it's more that there's so many of them.  And that particular tutorial really just targets imperative programmers.
11:24:39 <Ilmuri> C for C programmers
11:26:59 <tj9991> Clutch driving for C programmers
11:27:20 <Myoma> How to operate a supermarket for C programmers
11:27:27 <mauke> Free cash for C programmers
11:29:27 <mapreduce> Get your braces here!
11:40:10 <EvilTerran> orthodontistry for C programmers?
11:41:38 <gwern> afternoon everyone
11:42:11 <TomMD> hello gwern, what have you coded today?
11:44:57 <tennin> I don't really understand how C programmers can have difficulty with high-level (incl. functional/declarative) programming concepts.  it seems to me that most large C programs incorporate difficult high-level concepts, obfuscated by low-level details (a.k.a. "greenspun's tenth law")
11:46:09 <tennin> so, they must be smarter than me because they can grasp the high-level concepts even when so obfuscated, whereas I have to rely on the crutch of a language in which the concepts can be clearly expressed
11:46:51 <gwern> TomMD: I've done some lambdabot fixes, filed a ghc bug, upgraded to ubuntu intrepid ibex, and mostly ported myself to gnome-terminal from urxvt
11:47:19 <tennin> yet when the concepts are incorporated in the language, they complain about them being difficult and incomprehensible.  I don't get it
11:47:28 <tennin> the "they" here is an arbitrary stereotype of course
11:49:57 <byorgey> gwern: from urxvt to gnome-terminal eh?  most people I hear of are going the other way.  why the switch?
11:50:32 <gwern> byorgey: urxvt is unaccountably broken in intrepid
11:50:41 <gwern> it only pops up in the root window
11:50:50 <gwern> which, ah, is a dealbreaker for me
11:50:57 <byorgey> yeah, that sucks
11:52:01 <gwern> I have gnome-terminal all set up, except the terminal bell doesn't seem to work
11:53:05 <BONUS> whats the $ function called
11:53:06 <BONUS> like
11:53:07 <BONUS> in words
11:53:11 <BONUS> application function?
11:53:35 <minicut> I call it "dollar sign"
11:53:37 <Myoma> I always called it dollar :/
11:53:47 <Myoma> 'apply' seems reasonable
11:53:47 <gwern> paren
11:54:01 <gwern> foo paren baz quux bar == foo $ baz quux bar
11:54:13 <byorgey> 'function application'
11:54:14 <Myoma> map (uncurry ($)) [(f,3),(g,2)] --> map uncurry apply ..
11:54:35 <minicut> Myoma: but space is already called apply...
11:54:47 <Myoma> it's a good thing f $ x = f x then
11:55:05 <IsoPallo> I call it "string"
11:55:28 <IsoPallo> As in SCREEN$
11:55:31 <mauke> I SMELL BASIC
11:55:50 <IsoPallo> :)
11:56:13 <mauke> $ is for Scalar
11:56:42 <Myoma> hey is the church turing proof constructive ?
11:57:17 <Korollary> it's not a proof per se.
11:57:29 <minicut> What do you call $( )
11:57:41 <mauke> black magic
11:58:39 <gwern> TH
12:00:17 <IsoPallo> Strangely I also seem to call " a "blip"
12:00:34 <IsoPallo> Must be some childhood trauma.
12:00:52 <Myoma> Korollary: aw, I thought it would be fun to base a compiler on it
12:01:59 <IsoPallo> I can already see the website that calculates you the "right thing to do"
12:06:19 <gabor> from the funny department... I wrote up this as a brain dump: http://heisenbug.blogspot.com/2008/08/here-is-usual-basic-definition-of.html
12:06:20 <lambdabot> Title: don't count on finding me: Generalized Monads --> Gonads :-), http://tinyurl.com/65u4b6
12:06:38 <gabor> some monad theory expert may comment on it?
12:07:30 <Myoma> gabor: You wrote the thrist paper?
12:07:51 <gabor> yeah, that's me
12:08:00 <Myoma> gabor: very nice work :)
12:08:06 <gabor> thanks!
12:08:36 <RayNbow> http://img373.imageshack.us/img373/9215/spaceprofilefz8.png <-- how should I interpret this space profile diagram?
12:11:32 <Cale> gabor: That looks rather like a monad in the category given by (~>), only I'm not sure it corresponds exactly, since that's usually done with fmap, return and join
12:11:49 <Cale> (and there are still a few ->'s left usually)
12:12:11 <Cale> Er, or are there... no, they should all be ~> :)
12:12:45 <gabor> yeah, if (~>) is not (->) then >== shouldn't be a function
12:12:50 <Cale> hmm... I suppose fmap :: (a ~> b) -> (f a ~> f b) still.
12:13:39 <Cale> But return :: a ~> f a, and join :: f (f a) ~> f a are arrows in the category enriched over Hask
12:15:09 <gabor> I guess this requires a category theorist ;-)
12:15:51 <Cale> Well, this is just if you want it to correspond to the pre-existing notion :)
12:16:11 <gabor> anyway, now as I defined "instance Category (Thrist (~>) where ..." I can experiment with this notion
12:18:21 <gabor> i.e. build up a "generalized" monadic program in terms of thrists and then fold it (~> ------> ->) and execute it
12:18:25 <gwern> Cale: have you tried the TH patches to lb?
12:18:28 <gwern> @djinn (a,b) -> a
12:18:28 <lambdabot> f (a, _) = a
12:18:41 <gwern> oh good, djinn is back
12:18:52 <Cale> The problems with djinn were mysterious. I've installed it 3 or 4 times already :)
12:19:03 * gwern gives up on the bell issue. it's an intrepid bug, is all
12:19:14 <Cale> But perhaps I accidentally got rid of it somehow :)
12:19:24 <gwern> the real kicker is that while I get an updated gtk2hs for yi, I'm *still* stuck on ghc 6.8.2
12:21:40 <dons> http://www.reddit.com/r/programming/comments/6ytw7/haskell_weekly_news_logdomain_numbers_monte_carlo/
12:21:42 <lambdabot> Title: Haskell Weekly News: log-domain numbers, monte carlo monads, hardware descriptio ..., http://tinyurl.com/5835jm
12:22:51 <chrisdone> anyone got a Ubiquity command for Hackage?
12:23:06 <chrisdone> er, Hoogle
12:23:07 <gwern> lol ubiquity
12:23:27 <gwern> 'Community News
12:23:28 <gwern> If Dell sends John Goerzen (CosmicRay) one more catalog, it will actually be a federal crime.'
12:23:33 <gwern> <-- very important community news
12:25:46 <gwern> '    * b\6: keep this info private, but you can actually overclock your brain. the technique i use is to loop mplayer playing oggs but increase the speed like -speed 1.25 for 125% normal. your brain's speed increases accordingly, allowing you to solve problems much more easily.
12:26:02 <gwern> madness!
12:26:02 * gwern hopes that doesn't actually work though
12:29:45 * gwern sticks 'speed=1.1' into ~/.mplayer/config just for kicks
12:30:41 <RayNbow> @google ghc optimisation flags
12:30:43 <lambdabot> http://haskell.cs.yale.edu/ghc/docs/latest/html/users_guide/options-optimise.html
12:30:43 <lambdabot> Title: 5.9.�Optimisation (code improvement)
12:31:27 <gwern> hm. doesn't distort sound *too* much
12:31:44 <gwern> cs.yale.edu? I suspect that's not the latest
12:37:29 <dons> interesting, gwern.
12:37:30 <igel> how much faster is IntMap compared to Map?
12:37:35 <dons> igel: 2x
12:37:40 <RayNbow> interesting to see that (^2) is slow...
12:37:48 <igel> cool
12:37:49 <dons> RayNbow: for what type?
12:38:02 <RayNbow> Int's
12:38:08 <RayNbow> sed (a,b) (c,d) = (a-c)^2 + (b-d)^2    {-  versus  -}   sed = curry $ uncurry (liftT2 (-)) >>> liftT (join (*)) >>> uncurry (+)
12:38:14 <dons> hmm. shouldn't be. let's see.
12:38:16 <RayNbow> first version is slower than the second
12:38:23 <igel> and it's definitely not slower in some functions?
12:38:24 <RayNbow> if the first version is modified to be...
12:38:27 <dons> :t (^)
12:38:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:38:34 <dons> oh, what's the type of '2' :)
12:38:36 <igel> i don't use merge etc., only lookup, member, insert, etc.
12:38:52 <RayNbow> sed (a,b) (c,d) = (a-c)*(a-c) + (b-d)*(b-d) -- this version is about as fast as the pointfree version of sed
12:39:00 <Cale> 2 :: Integer
12:39:13 <RayNbow> dons: sed has the type Point -> Point -> Int
12:39:21 <RayNbow> where Point = (Int,Int)
12:39:25 <dons> RayNbow: you'll want to constrain both arguments of (^) to Int
12:39:36 <dons> to avoid an unnec. conversion that means using an inefficient impl.
12:39:40 <dons> :t (**)
12:39:42 <lambdabot> forall a. (Floating a) => a -> a -> a
12:39:43 <Cale> I still think it will be slower than the version which does multiplication directly.
12:39:43 <dons> :t (^^)
12:39:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:39:50 <dons> Cale, yeah, likely.
12:39:51 <Myoma> sed p q = abs (p - q) -- can't you write that ?
12:39:55 <rwbarton> is there some kind of RULE to inline x^n for constant n?  ==Calse
12:39:58 <rwbarton> *Cale
12:39:58 <Cale> ^ has to figure out how much multiplication to do
12:40:03 <dons> rwbarton: hmm.
12:40:08 <Myoma> @pl sed p q = abs (p - q)
12:40:08 <lambdabot> sed = (abs .) . (-)
12:40:18 <dons> rwbarton: (^) should always inline
12:40:29 <RayNbow> Myoma: (-) doesn't work on tuples
12:40:35 <Myoma> sure it does
12:40:39 <Myoma> you just define a Num instance
12:40:46 <Cale> But expanding ^ for constant n would not generally be a good idea.
12:41:01 <sjanssen> Cale: why not?
12:41:03 <Cale> (that is, doing some evaluation at compile time)
12:41:07 <rwbarton> Cale: No?  do it the same repeated-squaring way
12:41:08 <Myoma> x^99999999
12:41:09 <rwbarton> Cale: oh
12:41:11 <dons> ?index (^)
12:41:11 <lambdabot> Prelude
12:41:38 <Cale> Well, hmm... it might be okay.
12:41:45 <RayNbow> dons: so how do I constraint both arguments of (^) to Int?
12:41:50 <Myoma> why the name sed?
12:41:58 <RayNbow> Myoma: squared Euclidean distance
12:42:01 <sjanssen> at worst it will increase code size by a log factor
12:42:15 <Myoma> :t let (**) = (^) :: Int -> Int -> Int in (**)
12:42:17 <lambdabot> Int -> Int -> Int
12:42:17 <Cale> http://changelog.complete.org/posts/741-From-Dell,-a-Uniquely-Terrible-Experience.html -- I find this incredibly amusing
12:42:19 <lambdabot> Title: From Dell, a Uniquely Terrible Experience - The Changelog, http://tinyurl.com/5v92hm
12:46:01 <RayNbow> dons: is there an easy way of finding speed bottlenecks caused by conversions?
12:47:29 <Myoma> oh
12:47:48 <Myoma> (x,y) in a total language can be compiled into what (#x,y#) is in haskell
12:48:07 <Myoma> but is that less lazy?
12:51:47 <dmhouse> Myoma: unboxed stuff is strict
12:56:54 <Myoma> did anyone implement Eliminating dependent pattern matching ?
12:57:18 <Myoma> it seems rather harder that eliminating simple pattern matching
12:59:24 <Mitar> when compilling leksah 0.1.1 I get this errors:
12:59:30 <Mitar> src/IDE/Core/Types.hs:159:15:
12:59:30 <Mitar>     Not in scope: data constructor `Apple'
12:59:30 <Mitar> src/IDE/Core/Types.hs:160:15:
12:59:30 <Mitar>     Not in scope: data constructor `Compose'
12:59:42 <gwern> Apple?
13:00:23 <RayNbow> hmm
13:00:37 <RayNbow> Hugs cannot even run my Haskell program :p
13:00:51 * RayNbow alt+tabs back to GHC
13:01:06 <Mitar> i run on mac os x ... but i do not believe this have something with this error
13:01:14 <mattam> Myoma: not really, but Epigram 2 will have it.
13:07:28 <trofi> :t m >>= return
13:07:30 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
13:07:30 <lambdabot>     In the first argument of `(>>=)', namely `m'
13:07:36 <RayNbow> @src reverse
13:07:37 <lambdabot> reverse = foldl (flip (:)) []
13:07:39 <trofi> :t (m >>= return)
13:07:40 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
13:07:41 <lambdabot>     In the first argument of `(>>=)', namely `m'
13:08:00 <Myoma> :t ?m >>= return
13:08:02 <lambdabot> forall (m :: * -> *) a. (Monad m, ?m::m a) => m a
13:08:39 <dons> RayNbow: profile, then look at the core for bad things.
13:09:47 <RayNbow> dons: I'm not fluent in core yet ;)
13:10:51 <trofi> can i make parces parser just by returnings current parser state somehow? something like parser = do { r <- parseEntry; parser_and_state <- return; return (e, parser_and_state) }
13:11:25 <trofi> s/.../make parsec parser *lazy*/
13:13:37 <chrisdone> http://pbfcomics.com/?cid=PBF244-Preach_Skate.jpg -- definitely captures the force behind jQuery's design
13:13:38 <lambdabot> Title: The Perry Bible Fellowship
13:17:19 <RayNbow> dons, -ddump-simpl gives a bunch of 'undefined reference to...' error messages... is that normal?
13:21:38 <RayNbow> ah, cool... sed :: (Int,Int) -> (Int,Int) -> Int is turned into a function wsed :: Int# -> Int# -> Int# -> Int# -> Int# :)
13:23:33 <dons> that looks good.
13:23:39 <dons> i'd use 'ghc-core' to look at the core.
13:23:46 <dons> it colourises things, making life a lot easier
13:25:05 <RayNbow> dons: ghc-core?
13:25:30 <RayNbow> ah
13:25:33 <RayNbow> separate package
13:25:50 <RayNbow> ...but Unix-only... :p
13:26:35 <gwern> dons: did you ever review my last batch of Frag patches?
13:26:59 * RayNbow should hurry up with configuring his Linux netbook...
13:31:02 <dons> gwern: yeah, i think so. i did a new frag release straight after, you remember?
13:31:06 <dons> it's even in arch linux now
13:31:13 <dons> RayNbow: yeah, sorry.
13:31:28 <dons> i guess i could use ghc-api to make ghc-core platform indep.
13:31:45 <dmhouse> RayNbow: why not use Linux?
13:32:32 <gwern> dons: hm. when I do a pull I see patches
13:32:47 <dons> i'd do a fresh get, http://code.haskell.org/frag/
13:32:48 <lambdabot> Title: Index of /frag
13:32:54 <dons> iirc. there were a bunch of conflicts.
13:32:56 <dons> so i had to zap.
13:33:01 <RayNbow> dmhouse: because of Windows :p
13:33:08 <gwern> oh, maybe that's it
13:33:26 <dons> it shouuld be up to date.
13:33:30 <RayNbow> I recently got a machine with Linux installed on it though, but I don't like the distribution that's on it, so I gotta replace it
13:33:47 <RayNbow> dons, what's the difference between Main.$wfunction and Main.function in the core dump?
13:34:41 <dons> one is a worker, typically strict and unboxed.
13:36:05 <RayNbow> ah, that explains why Main.sed and Main.sed' here have near-identical code while Main.$wsed and Main.$wsed' are quite different
13:37:02 <trofi> @redo (m >>= retun)
13:37:02 <lambdabot> (do { a <- m; retun a})
13:37:05 <trofi> @redo (m >>= return)
13:37:06 <lambdabot> (do { a <- m; return a})
13:38:01 <Olathe> @undo (do { return m })
13:38:01 <lambdabot> (return m)
13:38:04 <Olathe> Ahh.
13:40:00 <luite> does -O imply -fvia-C on windows?
13:42:07 <gwern> @seen dcoutts
13:42:07 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 3h 33m 23s ago.
13:43:04 <gwern> @ask dcoutts Is a message during configure like "Configuring frag-1.1.1... Warning: cannot determine version of /usr/bin/gcc : "gcc (Ubuntu 4.3.2-0ubuntu2) 4.3.2\nCopyright (C) 2008 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"" cabal or ghc's fault?
13:43:05 <lambdabot> Consider it noted.
13:43:43 <gwern> dons: I think sdist may be broken in frag
13:44:09 <dons> patches welcome. i might have just used darcs dist.
13:44:20 <gwern> ...which is not surprising inasmuch as there's no listing of modules?
13:44:28 * gwern could've sworn I left frag building from sdist
13:45:33 <gwern> and wasn't there a library section as well?
13:46:02 <newsham>     bindSocket s (SockAddrInet (PortNum 1053) iNADDR_ANY)
13:46:21 <newsham> it bound to port 7428 (which is 0x1d04) not 1053 (which is 0x041d)
13:46:23 <Nafai> dons: Have you heard of the OpenSUSE build service (https://build.opensuse.org/)?  You can use it to generate and build packages for various Linux distributions, particularly RPM based distros.
13:46:37 <newsham> isnt that a bug?  or does the socket api in haskell expect you to put it in network endian?
13:46:49 <Nafai> dons: I think the Haskell community could easily provide RPMs for Hackage packages if cabal could produce RPM spec files using this
13:46:58 <mauke> newsham: don't use the PortNum constructor, ever
13:47:06 <Nafai> dons: And it would be a first step in getting Haskell packages in RPM-based distros
13:47:24 <newsham> mauke: is there something else thats preferred?
13:47:38 <mauke> newsham: yes, SockAddrInet 1053 iNADDR_ANY
13:48:04 <dcoutts> Nafai: have you looked at cabal-rpm ?
13:48:05 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
13:48:12 <newsham> ahh
13:48:17 <Nafai> dcoutts: Haven't yet.
13:48:26 <newsham> ?type SockAddrInet
13:48:28 <lambdabot> Not in scope: data constructor `SockAddrInet'
13:48:29 <Nafai> dcoutts: I just bring this up because I went to a presentation about the build service this morning
13:48:33 <dcoutts> gwern: that'd be cabal's fault. What version of Cabal are you using there?
13:48:42 <gwern> dcoutts: darcs
13:48:43 <newsham> mauke: how does it get the 1053 literal into PortNumber ?
13:49:01 <newsham> I guess fromIntegral?
13:49:03 <mauke> newsham: like all numbers, using fromInteger in Num
13:49:11 <newsham> danke
13:49:26 <dcoutts> gwern: do you get that for any/all packages?
13:49:29 <dons> Nafai: very interesting.
13:49:54 <gwern> dcoutts: that I've checked
13:52:06 <newsham> which exception do I catch to get ^C ?
13:52:19 <mauke> currently, none (I think)
13:52:38 <mauke> you install a signal handler for SIGINT (or has this changed now?)
13:52:41 <newsham> server s `E.catch` print   <-  prints   ^Cexception :: GhcException
13:53:05 <mauke> hrml
13:53:38 <newsham> I'll just catchJust I guess
13:54:56 <mauke> ^Ca.out: interrupted
13:54:59 <mauke> no exception here
13:55:15 <newsham> i'm using 6.8.2, runhaskell,  freebsd/amd64
13:55:43 <mauke> ok, so it's the interpreter
13:56:47 <dcoutts> gwern: what does gcc -dumpversion tell you?
13:57:10 <newsham> yah, seems like it.
13:58:08 <mauke> looks like a DynException
13:58:23 <mauke> with ghc you get a plain signal
13:59:30 <shapr> @seen hpaste
13:59:31 <lambdabot> I haven't seen hpaste.
13:59:44 <shapr> saccade: Hey, you live in Somerville?
14:00:14 <mauke> preflex: seen hpaste
14:00:14 <preflex>  hpaste was last seen on #haskell 50 days, 5 hours, 1 minute and 36 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
14:00:22 <shapr> ugh, 50 days ago?
14:00:24 <shapr> geez
14:03:34 <RayNbow> dons: are there any plans on a RWH sequel?
14:03:49 <RayNbow> (yes I know, RWH itself hasn't even been published yet :p)
14:03:50 <shapr> Lost World Haskell!
14:03:58 <dcoutts> RayNbow: give'm a chance! :-)
14:04:16 <dmhouse> Every time someone says RWH I think of RWS.
14:04:21 <dmhouse> ?kind RWST
14:04:22 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:04:22 <dcoutts> I've not received my copy yet, no time for second editions
14:04:30 <dmhouse> It might have a cool kind, but it's rubbish at teaching you Haskell.
14:05:25 <Saizan> and iirc it's space leak prone
14:06:11 * RayNbow wonders if someone would ever write a multi-volume The Art of Haskell Programming book...
14:06:15 <dons> RayNbow: hmm. a sequel eh?
14:06:21 <dons> probably should get the first one out first.
14:06:33 <dons> that said, i think that there's room for several other books on haskell.
14:06:37 <dons> there's a lot to cover.
14:07:31 <dons> i don't think we talk about comonads or arrows or 'scientific programming' or opengl or ...
14:07:41 * RayNbow wonders why he currently thinks of all kind of crazy book titles...
14:07:44 <RayNbow> "Haskell Origami: The Art of Folding and Unfolding"
14:08:15 <dons> and still the book is 2.5x larger than we planned.
14:08:26 <dons> 'zactly. and origami book would be fun.
14:08:31 <dons> old school.
14:08:42 <RayNbow> <dons> and still the book is 2.5x larger than we planned. <-- a writer's space leak? :p
14:08:50 <dons> nah, topic leak.
14:09:02 <dons> we just had to keep evaluating suspended concepts
14:11:04 <newsham> mauke: ok, so next question -- how do you catch ^C in ghci? :)
14:11:12 <newsham> any idea which catchJust it might be?
14:11:42 <name_> is there any way to differentiate 0.0 and -0.0
14:12:20 <roconnor> > isNegativeZero (-0.0)
14:12:21 <lambdabot>  True
14:12:25 <roconnor> > isNegativeZero (0.0)
14:12:27 <lambdabot>  False
14:12:34 <name_> thanks haha
14:12:38 <mauke> newsham: dynExceptions probably
14:15:29 <newsham> mauke; perfect, caught everything but dyn and its working
14:16:41 <SamB_XP> hmm, I don't think I've ever seen a Sofa of Contents before ...
14:16:43 <SamB_XP> http://www.gamefaqs.com/console/gamecube/file/447244/21364
14:16:43 <lambdabot> Title: GameFAQs: Metroid Prime (GC) Artifact Locations Guide by bluberry
14:16:57 <mauke> haha
14:18:01 <SamB_XP> I didn't know .txt supported fragment identifiers either!
14:18:09 <mauke> also, preflex++ for still being alive and keeping a multi-month history
14:21:10 <newsham> sweet, i have a tiny dns server.
14:21:37 <newsham> mauke: good thing he didnt catch the botflu thats been going around
14:21:54 <b\6> newsham: darcs getable?
14:22:40 <Myoma> any way to search for programs that use a certain library ?
14:23:03 <newsham> b\6: nope.  but if you want it, i put it up.  http://www.thenewsh.com/%7Enewsham/x/machine/dns/
14:23:04 <lambdabot> Title: Directory /~newsham/x/machine/dns/
14:23:12 <b\6> newsham: thanks.
14:23:13 <newsham> it's just barely working at the moment.
14:23:17 <SamB_XP> Myoma: look at their dependencies on co-hackage
14:23:23 <Myoma> haha
14:23:34 <SamB_XP> it would work, you know!
14:23:37 <newsham> btw, there's some DNS code in hackage.  one package that's a binding to gnu C code, another that's some pure haskell code.
14:23:39 <ziman> @index (%)
14:23:40 <lambdabot> Data.Ratio
14:23:42 <newsham> but it's client side stuff.
14:23:44 <SamB_XP> since co- means "flip the arrows" ;-P
14:24:05 <b\6> newsham: yeah, i've got it all checked out.
14:25:45 <newsham> run DNSTest2.hs and then test with  dig -p 1053 foo.bar.com @127.0.0.1
14:26:08 <b\6> ok. thanks
14:26:09 <b\6> .
14:28:06 <newsham> comments, corrections, patches, criticisms, etc.. all welcome.
14:28:32 <roconnor> mmm, pure haskell DNS
14:28:49 <dons> there's that smp parallel dns thingy too
14:29:03 <newsham> the asynch resolver in hackage?
14:29:06 <mauke> randomize the source port :-)
14:29:15 <trofi> :]
14:29:30 <newsham> mauke: in my test client?  heh.
14:33:56 <trofi> http://hpaste.org/10033 can someone help me force `run_lazy_parse' work properly?
14:39:33 <Philonous> @src foldr
14:39:33 <lambdabot> foldr f z []     = z
14:39:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:40:00 <Philonous> Does ghc actually use that definition or does it have some hard-coded optimized version?
14:40:37 <Olathe> I'm not sure, but why do you ask ?
14:40:54 <Jedai> Philonous: I think it's use this one or one almost exactly the same
14:41:08 <dmhouse> Philonous: what makes you think that won't be fast?
14:41:12 <newsham> i think it uses the def normally bu has some rewrite rules which might come in to play for some optimizations?
14:41:34 <Philonous> "Haskell for C programmers" states ghc would use some "optimized" version - whatever this is supposed to mean
14:42:02 <newsham> ghc is free to rewrite things when the rewrites dont change the semantics
14:42:11 <mauke> Philonous: it does use a different version
14:42:35 <Myoma> foldr k z xs = go xs
14:42:35 <Myoma>              where
14:42:35 <Myoma>                go []     = z
14:42:35 <Myoma>                go (y:ys) = y `k` go ys
14:42:47 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#foldr
14:42:49 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3dzxqb
14:43:55 <ddarius> mauke: But I don't believe it needs to any more and it is only slightly different.
14:44:26 <Myoma> btw why is foldr parameters in such a weird order
14:44:30 <Myoma> @src []
14:44:30 <lambdabot> data [] a = [] | a : [a]
14:44:37 <Jedai> It lift some arguments, but otherwise it's the same (I guess the latest HEAD may even compile the naive version to that now)
14:44:49 <mauke> hah, I've wondered the same thing
14:44:59 <ddarius> Myoma: History and that tends to be the more convenient order or at least just as convenient.
14:45:24 <Jedai> Myoma: That tends to be more convenient to use as partial application goes
14:45:31 <Myoma> oh
14:45:35 <Myoma> :t foldr (:)
14:45:36 <lambdabot> forall a. [a] -> [a] -> [a]
14:45:50 <Myoma> > foldr (:) "foo" "bar"
14:45:53 <trofi> :t getInput
14:45:55 <lambdabot>  "barfoo"
14:45:57 <Philonous> Is incoking a closure repeatedly faster than invoking a higher order function?
14:45:59 <lambdabot> Not in scope: `getInput'
14:46:03 <Philonous> Would make sense, though
14:46:11 <olsner> @djinn [a] -> [a] -> [a]
14:46:11 <lambdabot> Error: Undefined type []
14:46:35 <Jedai> Philonous: It really depends
14:46:38 <olsner> aww, djinn no can do lists?
14:46:44 <Myoma> no it can't
14:47:35 <Myoma> hm did anybody try to write an emacs mode in haskell?
14:47:45 <luite> @src intersperse
14:47:46 <lambdabot> intersperse _   []     = []
14:47:46 <lambdabot> intersperse _   [x]    = [x]
14:47:46 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:47:53 <Jedai> Philonous: The results are really not evident, but sometimes they are quite good (and sometimes pretty bad) there was a discussion on that on the ghc-user mailing list some times ago
14:48:31 <Jedai> Myoma: you don't mean haskell-mode ? There was some works to allows to program emacs in Haskell
14:48:42 <newsham> > concat . intersperse '-' $ words "this is a test"
14:48:44 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
14:48:58 <dmhouse> Myoma: you mean a Haskell mode in Emacs?
14:49:07 <dmhouse> Oh, you probably don't.
14:49:35 <Philonous> Jedai: I see.
14:49:41 <Jedai> Myoma: it was called shim I think, I don't know how it is currently
14:49:43 <newsham> > concat . intersperse "-" $ words "this is a test"
14:49:45 <lambdabot>  "this-is-a-test"
14:49:55 <Philonous> So there's really no magic going on behind the scenes. Good to know.
14:49:59 <mauke> > intercalate "-" $ words "this is a test"
14:50:00 <lambdabot>  "this-is-a-test"
14:50:08 <Jedai> Philonous: The latest GHC performs this optimisation with some heuristics
14:50:08 <mauke> @src intercalate
14:50:09 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:50:10 <Myoma> oh my godo
14:50:14 <Myoma> The script uses Ruby to spawn a GHCi process and communicate with it through pipes, reading from VIM and writing the output into a dedicated GHCi window
14:50:17 <Myoma> haha
14:50:29 <mauke> wat
14:50:51 <dmhouse> Is that a VIM mode?
14:50:55 <Myoma> oh
14:51:00 <Myoma> it is a vim mode
14:51:05 <Myoma> I thought it was doing all this inside emacs
14:51:16 <mauke> well, just run vim in an emacs buffer
14:51:17 <dmhouse> I had a feeling Shim was something to do with Emacs. Maybe it does both.
14:51:32 <dmhouse> That would explain why it's written in Ruby rather than elisp.
14:52:13 <Myoma> ok
14:52:31 <newsham> vim on rails
14:52:43 * shapr boings cheerfully
14:52:44 <Myoma> vim on viag ...
14:52:50 <Myoma> hi shapr!
14:53:02 * shapr hugs Myoma 
14:53:08 * Myoma hugs :
14:53:18 * mauke ghci
14:53:36 <newsham> :e
14:53:38 * shapr cabawls out lambdabot
14:53:51 <Myoma> oh I shuold look at epigram
14:54:04 <shapr> It's nifty
14:54:10 <newsham> there's a livecd out there with epigram, coq, agda, etc. on it
14:54:10 <Jedai> Myoma: From what I understood there was both an emacs and a vim part to Shim
14:54:41 <newsham> http://typessummerschool07.cs.unibo.it/courses/binary.iso
14:54:43 <Myoma> I need to know enough elisp to not use elisp
14:55:12 <dmhouse> Weirdly, the languages I spend the most time writing these days are elisp and PHP
14:55:14 <Jedai> Myoma: It's natural that it has to do some weird thing for Vim since Vim has a rather weak support for interactive outside process but emacs is much better at that
14:55:19 <dmhouse> I'm pretty used to language-level pain, it seems.
14:55:50 <newsham> dmhouse: i'm sorry about the php.
14:56:02 <dmhouse> newsham: it's okay, it was for a summer job which I've now finished.
14:56:15 <dmhouse> My current hacking project is in Javascript, which is much more lovely.
14:56:24 <shapr> Does cabal install Haddocks?
14:56:43 <dmhouse> And it's XULRunner Javascript, which means I get to use all the Mozilla JS extensions without worrying about portability.
14:56:55 <dmhouse> The only ugly part is the XPCOM to interface with the C++ bits.
14:57:06 <newsham> there arent a lot of languages in modern use which arent "much more lovely" than php
14:57:47 <mauke> why is there no execr()?
14:58:06 <shapr> execr(able) ?
14:58:10 <shapr> hej jan_
14:58:10 <rwbarton> execr(8)
14:58:19 <shapr> heh
14:58:42 <shapr> Ok, how do I ask cabal to install docs for hackages?
14:58:55 <newsham> what's a hammer(4) ?
14:59:05 <newsham> hitting nails...
14:59:56 <roconnor> @type \x -> if x then id else flip
14:59:57 <lambdabot> forall b c. Bool -> (b -> b -> c) -> b -> b -> c
15:00:05 <shapr> @users
15:00:05 <lambdabot> Maximum users seen in #haskell: 482, currently: 465 (96.5%), active: 19 (4.1%)
15:00:19 <dmhouse> Boo for lambdabot losing state!
15:00:23 <dmhouse> We've had > 500.
15:00:52 <Myoma> @let bool true false True = true ; bool true false False = false
15:00:54 <lambdabot> Defined.
15:00:57 <Myoma> :t bool id flip
15:00:59 <lambdabot> forall b c. Bool -> (b -> b -> c) -> b -> b -> c
15:03:30 <newsham> ?tell dons http://news.bbc.co.uk/1/hi/world/asia-pacific/7589382.stm
15:03:30 <lambdabot> Consider it noted.
15:06:50 <ddarius> Time to move to Australia.
15:07:13 <newsham> galois south?
15:09:31 <ddarius> I wasn't talking about dons or Galois, I was talking about me.
15:10:04 <dons> oh, man drought?
15:10:04 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:10:31 <mm_freak_> is there an elegant way to specify the return type of newArray, when inference is ambiguous?
15:10:40 <Myoma> using a type annotation
15:11:25 <mm_freak_> it doesn't work as well as i'd expect it to
15:11:39 <Myoma> do you get a type error or something
15:11:41 <TSC> @type newArray
15:11:43 <lambdabot> Not in scope: `newArray'
15:11:48 <TSC> Outrageous
15:11:50 <mm_freak_> my first try was using the PatternSignatures extension, which didn't work at all
15:12:05 <mm_freak_> because some of the types are variable
15:12:07 <Myoma> functions aren't patterns
15:12:32 <mm_freak_> arr :: STUArray s i Bool <- newArray (2,999999) False
15:12:48 <ddarius> If you don't mind extensions, probably the easiest thing to do is to use lexically scoped type variables.
15:13:01 <Myoma> arr <- newArray (2,999999) False :: Foo
15:13:07 <mm_freak_> i don't mind extensions
15:13:10 <dcoutts> shapr: use the latest cabal-install release and use --enable-documentation or set it as default in the ~/.cabal/config file
15:13:24 <Myoma> @hoogle newArray
15:13:35 <lambdabot> Data.Array.Base newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:13:35 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:13:35 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:14:05 <newsham> hmm.. where can I find docs on .cabal/config?   I always type "--global" and "-p" for installs.  i'm assuming i can preconfig that
15:14:06 <Myoma> It's a shame you can't use _ in types
15:14:20 <mm_freak_> Myoma: i tried to specify the type of newArray that way as well as the type of arr
15:14:23 <mm_freak_> both didn't work
15:14:39 <Myoma> mm_freak_: want to hpaste this ?
15:14:46 <newsham> (which it installed a man page)
15:15:27 <mm_freak_> Myoma: just a second…  (background:  i'm trying to solve projecteuler.net's 14th problem)
15:15:49 <Myoma> I lot of people are using STArrays for solving project euler ... this is worrying
15:16:59 <mm_freak_> Myoma: it makes sense for problem 14
15:17:01 <mm_freak_> http://hpaste.org/10034
15:17:54 <mm_freak_> the only place where i used STUArray before was for the sieve of eratothenes, where it makes sense, too
15:18:13 <Myoma> @hoogle STUArray
15:18:13 <lambdabot> Data.Array.Base data STUArray s i a
15:18:13 <lambdabot> Data.Array.Base STUArray :: i -> i -> Int -> MutableByteArray# s -> STUArray s i a
15:18:13 <lambdabot> Data.Array.ST data STUArray s i a
15:18:37 <b\6> one time i tried to use STFUArray, but it was too rude.
15:19:28 <newsham> mm_freak: i think if you use ScopedTypeVariables and forall s i .
15:19:32 <Myoma> Don't you use runSTArray ?
15:19:52 <mm_freak_> Myoma: no, because the array never leaves ST
15:19:54 <newsham> tehn you can just do :: <type using s i>   after the newArray line
15:20:01 <mm_freak_> newsham, ddarius:  i'll look that up, thanks
15:20:36 <newsham> your uses of arr dont imply the type?
15:20:49 <mm_freak_> newsham: no
15:21:08 <mm_freak_> Myoma: i recognized that problem 14 can be solved quickly by sieving
15:21:08 <newsham> {-# LANGUAGE ScopedTypeVariables #-}
15:23:00 <Myoma> well I don't really see how this works
15:23:09 <Myoma> did you get it to work with scoped type variables?
15:25:01 <mm_freak_> unfortunately no
15:25:03 <mm_freak_> yet
15:25:46 <Myoma> I don't see how runST can run something which uses an STArray
15:25:57 <Myoma> looks like you have to runSTArray, but then it seems you must return an array
15:26:31 <mm_freak_> ah, i got it
15:26:41 <mm_freak_> {-# LANGUAGE PatternSignatures, ScopedTypeVariables #-}
15:26:48 <mm_freak_> sieve :: forall s. ST s Int
15:26:54 <mm_freak_> arr :: STUArray s Int Bool <- newArray (2,999999) False
15:27:00 <mm_freak_> that works
15:27:27 <mm_freak_> (btw, i realized i can just use Int instead of Integral i => i)
15:27:41 <rwbarton> @let please = id
15:27:42 <lambdabot> Defined.
15:27:49 <rwbarton> > please $ do { x <- [1,2,3] ; y <- [4,5] ; return (x, y) }  -- a la Intercal
15:27:50 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
15:28:01 <ziman> :D
15:30:23 <EvilTerran> @let don't = (mzero `asTypeOf`)
15:30:24 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:30:29 <EvilTerran> ...
15:30:54 * EvilTerran wanted to make "don't $ do { ... }" work =/
15:32:00 <mm_freak_> hmm…  how to turn a highly imperative algorithm into functional world elegantly? =/
15:33:05 <EvilTerran> with difficulty - which algorithm is it?
15:33:10 <EvilTerran> if all else fails, you can use ST
15:33:13 <newsham> ?let dont _ = "fine, I won't"
15:33:15 <lambdabot> Defined.
15:33:31 <newsham> > please $ dont do { x <- [1,2,3] ; y <- [4,5] ; return (x, y) }
15:33:35 <lambdabot>  mueval: Prelude.read: no parse
15:33:49 <newsham> > please $ dont $ do { x <- [1,2,3] ; y <- [4,5] ; return (x, y) }
15:33:51 <lambdabot>  "fine, I won't"
15:34:05 <mm_freak_> EvilTerran: i'm using ST right now, and it's okay so far…  it's just that it looks the same as i'd write it in C
15:34:07 <Olathe> > please die
15:34:08 <lambdabot>  mueval: Prelude.read: no parse
15:34:25 <newsham> > var "fine"
15:34:26 <lambdabot>      Ambiguous occurrence `var'
15:34:26 <lambdabot>     It could refer to either `Data.Number.Sym...
15:34:28 <EvilTerran> mm_freak_, well, at least we have proper typing and whatnot, unlike C
15:34:35 <EvilTerran> mm_freak_, haskell is the world's finest imperative language! :D
15:34:46 <mm_freak_> i wonder if that's just okay for a number of algorithms…  i'll hpaste it as soon as i got it done
15:34:52 <newsham> ?hoogle var
15:34:52 <lambdabot> Distribution.PackageDescription Var :: c -> Condition c
15:34:52 <lambdabot> Language.Haskell.TH VarE :: Name -> Exp
15:34:52 <lambdabot> Language.Haskell.TH.Syntax VarE :: Name -> Exp
15:35:13 <EvilTerran> > please fail "messily"
15:35:14 <lambdabot>      No instance for (Show (m a))
15:35:14 <lambdabot>       arising from a use of `show' at <inte...
15:35:39 <newsham> ?hoogle  String -> Sym a
15:35:40 <lambdabot> Warning: Unknown type Sym
15:35:40 <lambdabot> Prelude error :: String -> a
15:35:40 <lambdabot> Prelude fail :: Monad m => String -> m a
15:36:17 <mm_freak_> EvilTerran: i'm currently using ST, STUArray and STRef together for an imperative algorithm…  it's about the worst you can get in haskell =)
15:36:34 <Myoma> mm_freak_: this is pretty weird
15:36:38 <EvilTerran> mm_freak_, with a bit of syntactic fiddling, ST can be delightful to use
15:36:50 <Myoma> http://hpaste.org/10035
15:36:57 <EvilTerran> new = newSTRef; get = readSTRef; (<~) = writeSTRef
15:36:58 <Myoma> I can't get rid of that Bool in the type annotation
15:37:20 <Myoma> would have liked (Ix i) => (i,i) -> e -> ST s (STUArray s i e) but it doesn't seems possible
15:38:14 <Myoma> newSTArray :: (Ix i, MArray (STUArray s) e (ST s)) => (i,i) -> e -> ST s (STUArray s i e)
15:38:15 <Myoma> works
15:38:34 <gwern> dcoutts: gcc -dumpversion == 4.3.2
15:38:42 <Myoma> anyway you can get rid of the scoped pattern type variables if you do things this way
15:38:50 <EvilTerran> ?type flip newArray False
15:38:51 <lambdabot> Not in scope: `newArray'
15:38:59 <EvilTerran> ?type flip Data.Array.MArray.newArray False
15:39:01 <lambdabot> forall i (m :: * -> *) (a :: * -> * -> *). (Ix i, Data.Array.Base.MArray a Bool m) => (i, i) -> m (a i Bool)
15:39:07 <EvilTerran> Myoma, owzat?
15:40:36 <mm_freak_> Myoma: well…  that looks even more ugly =)
15:40:42 <Myoma> what does ?
15:40:53 <mm_freak_> http://hpaste.org/10035
15:41:26 <Myoma> really ok
15:41:39 <Myoma> I prefer not putting scoped pattern type variables in the code
15:42:00 <EvilTerran> Myoma, scoped what?
15:42:10 <EvilTerran> there's none there - the forall's are just lambdabot being odd
15:42:23 <EvilTerran> ?type flip Data.Array.MArray.newArray False :: (Ix i, Data.Array.Base.MArray a Bool m) => (i, i) -> m (a i Bool)
15:42:25 <mm_freak_> EvilTerran: i think, Myoma means a combination of scoped type variables and pattern types
15:42:25 <lambdabot> forall i (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a Bool m, Ix i) => (i, i) -> m (a i Bool)
15:42:42 <mm_freak_> uhm, pattern signatures, that is
15:42:46 <EvilTerran> er
15:43:04 <mm_freak_> i'm using exactly that:  a combination of both
15:43:15 <mm_freak_> and my algorithm doesn't work as i expected
15:43:16 <EvilTerran> pattern signatures?
15:43:21 <mm_freak_> yeah
15:43:28 <mm_freak_> hold on, i'll paste it
15:43:33 <Myoma> but yeah I would not use any imperative features to solve project eulier
15:43:42 <Myoma> unless I was using C or something
15:44:03 <EvilTerran> Myoma, sometimes it really is easier to be imperative
15:44:25 <EvilTerran> but i'd rather be imperative in a language with strict types, array bounds checking, arbitrary-length integers, etcetc
15:45:00 <mm_freak_> http://hpaste.org/10036
15:45:33 <Myoma> mm_freak_: I can't understand how  arr :: STUArray s i Bool <- newArray (1,n) True  is less ugly than  arr <- newSTArray (1,n) True
15:45:47 <mm_freak_> Myoma: my approach is highly imperative…  especially for many sieving algorithms, imperative style seems to be easier
15:45:49 <FunctorSalad> funny little problem: efficient data structure for a free group?
15:46:12 <EvilTerran> mm_freak_, ah, i solved that in a declarative way
15:46:32 <FunctorSalad> the problem is that if you always save terms in normal form right away, taking the inverse requires reversing the term, which is O(n) with all common data structures
15:46:33 <EvilTerran> mm_freak_, you know you can define elements of a Data.Array in terms of each other in any order, taking advantage of laziness?
15:46:38 <ddarius> FunctorSalad: newtype FreeGroup a = FreeGroup [Either a a]
15:46:48 <FunctorSalad> ddarius: that's exactly what I have now.
15:47:03 * EvilTerran notes Either a a ~~ a + a ~~ 2*a ~~ (Bool,a)
15:47:09 <EvilTerran> just a random observation, mind
15:47:19 <mm_freak_> Myoma: i don't like that footnote-style code…  i prefer not to have to move my eyes away from the focus when reading code
15:47:29 <FunctorSalad> ddarius: so I was thinking about applying inversion lazily, but probably not worth the effort I guess...
15:47:38 <Myoma> mm_freak_: What footnote?
15:47:39 <mm_freak_> that's why i prefer the pattern signature
15:47:55 <mm_freak_> Myoma: your newSTArray function appears like a footnote
15:47:59 <Myoma> mm_freak_: You didn't look at the definition of newArray so why would you have to look at the definintion of newSTArray?
15:48:07 <ddarius> FunctorSalad: You can just not apply inversion until you need to which would only be when you need to observe a particular group element.
15:48:15 <mm_freak_> EvilTerran: how do you solve the problem of the counter?
15:48:20 <FunctorSalad> ddarius: right
15:48:32 <mm_freak_> EvilTerran: (ignoring that the algorithm doesn't work anyway)
15:48:48 <mm_freak_> Myoma: because newSTArray is a custom function
15:48:58 <mm_freak_> newArray is from Data.Array.MArray
15:48:59 <Myoma> I don't know what that means
15:49:18 <EvilTerran> mm_freak_, well, i had a million-element array
15:49:26 <gwern> boy, don't I know what that feels like...
15:49:40 <EvilTerran> mm_freak_, where each element (arr!n) indicated how many steps it took to get from n to 1
15:49:56 <FunctorSalad> I could even try out ghc's term rewriting features :)
15:50:25 <FunctorSalad> so any double inverses would get removed by ghc ;)
15:50:34 <FunctorSalad> (if they're known at compile-time, of course)
15:51:57 <Philonous> mm_freak: This function looks overly complicated. I think this could be done with iterate, takeWhile and length. But I guess you are playing around with some more interesting structures?
15:52:26 <EvilTerran> mm_freak_, does the approach i just described make sense to you?
15:52:30 <gwern> @seen dcoutts
15:52:30 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 39m 19s ago.
15:53:04 <Philonous> mm_freak_ even
15:53:12 <name_> whats the best way to apply a function to each element of a tuple. like if i wanted to upgrade something from 1 to 2 dimensions
15:53:27 <mm_freak_> EvilTerran: yes, it does, but i'm afraid it won't work here…  the idea was to sieve out all elements, because they would generate shorter collatz sequences
15:53:30 <name_> (and recombine the result back into a tuple)
15:53:38 <EvilTerran> name_, there isn't a function for that, really
15:53:41 <Olathe> name_: What's an example ?
15:53:42 <Myoma> name_: which tuple?
15:53:48 <mmorrow> > join (***) (+1) (0,1)
15:53:49 <lambdabot>  mueval: Prelude.read: no parse
15:53:53 <mmorrow> bah
15:53:58 <mm_freak_> Philonous: this _is_ the iterate/length/takeWhile approach, optimized by a sieve
15:54:00 <name> hm why did that highlight me
15:54:00 <Olathe> > learn to parse
15:54:00 <gwern> @tell dcoutts I am seeing a number of distressing macro warnings using cabal, which started recently (before the ibex upgrade): http://hpaste.org/10037
15:54:00 <lambdabot> Consider it noted.
15:54:01 <lambdabot>  mueval: Prelude.read: no parse
15:54:08 <mmorrow> name_: a 2-tuple?
15:54:12 <name_> yea 2 atm
15:54:27 <mmorrow> @type  join (***)
15:54:28 <EvilTerran> mm_freak_, well, it worked for my solution, which is 8 lines, including imports :)
15:54:29 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:54:33 <name> and name_ stop stealing my backup-if-connection-failed-nick
15:54:34 <Jedai> name_: You have to write one
15:54:39 <Myoma> foo f (x,y) = f x & f y where ((x,y) & (p,q)) = (x,y,p,q)
15:54:42 <name_> lol diddnt even notice haha
15:54:50 <mmorrow> @type  join (***) :: (a -> b) -> ((a,a) -> (b,b))
15:54:51 <mm_freak_> EvilTerran: so you have a solution for problem 14?
15:54:51 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
15:55:04 <EvilTerran> name & name_, i must say, it's not the most imaginative choice of name from either of you ;)
15:55:08 <EvilTerran> mm_freak_, indeed i do
15:55:15 <name> EvilTerran: it's my name
15:55:16 <Jedai> name_: seriously, just write dup f ~(x, y) = (f x, f y)
15:55:33 <mm_freak_> EvilTerran: ah ok, and it implements the sieving idea without imperative code?
15:55:33 <Myoma> why use 'dup' when &&& exists
15:55:43 <mmorrow> f *** g = \x -> (f x,g x)
15:55:50 <Olathe> Why use &&& when map and two-element lists exist ?
15:55:51 <EvilTerran> name, your /whois tells me your name is Florian Mayer. "name" may be what you call yourself, however. ;)
15:56:08 <EvilTerran> mm_freak_, what sieving idea?
15:56:18 <Jedai> Myoma: because (dup (\x -> ...)) is much better than the alternative with &&& ?
15:56:19 <name> EvilTerran: :)
15:56:27 <mmorrow> Olathe: but two element list can't be guaranteed to be that length by the type
15:56:28 <Jedai> Myoma: *** rather
15:56:33 <name> EvilTerran: i'm having serious problems with nickstealers ^^
15:56:40 <mmorrow> name: lol
15:56:52 <name> since i set ENFORCE on it's gotten better
15:56:55 <EvilTerran> name, that's what i mean by it being unimaginative - it's likely to get grabbed by someone else in a lot of places
15:57:00 <Myoma> 'name' is a terrible IRC nick :/
15:57:01 <mm_freak_> EvilTerran: the naïve approach is to just generate the collatz sequence for [2..999999] and take the maximumBy the length
15:57:12 <EvilTerran> i like mine, it's really quite obscure
15:57:16 <name> before i set that people tried guessing my pwd
15:57:31 <name> well Myoma irssi does a good job of not highlighting me to often :)
15:57:35 <gwern> EvilTerran: InfestedTerran would've been better
15:57:39 <mmorrow> name let me guess, it's "password"
15:57:45 <name> mmorrow: nope
15:57:46 <EvilTerran> mm_freak_, which is basically what i did, except with an array instead of a list
15:57:56 <Jedai> mm_freak_: I solved that with a lazy array for memoizing, it was pretty fast
15:57:58 <Olathe> mmorrow: It's "password" now.
15:57:58 <mmorrow> name: heh
15:58:11 <mm_freak_> EvilTerran: since the collatz sequence is stateless, you can sieve out already-got values, which is what i'm trying to do, and which seems highly imperative to me
15:58:16 <Jedai> mm_freak_: it was also completely declarative
15:58:19 <EvilTerran> i'm confused
15:58:24 <name> my secondary nick is too long. it's 'segfaulthunter'
15:58:37 <mm_freak_> collatz 13 = [13, 40, …
15:59:00 <Jedai> mm_freak_: You missed out on the use of lazy array for dynamic programming, it is perfectly declarative/pure/functional and just works perfectly in your case
15:59:04 <mm_freak_> so you don't need to try collatz 40 anymore, because you know that length (collatz 40) _must_ be shorter than length (collatz 13)
15:59:08 <gwern> name: 'segfault' was taken?
15:59:17 <name> gwern: too ununique
15:59:22 <mm_freak_> EvilTerran: got it?
15:59:26 <EvilTerran> mm_freak_, ah, i see
15:59:30 <EvilTerran> yeah, you're thinking imperatively
15:59:36 <gwern> says 'name'...
15:59:37 <EvilTerran> i wouldn't ;)
15:59:48 <name> gwern: well i need to compensate for one crappy name with the other one
15:59:50 <mm_freak_> i'm not…  it's a fact that this algorithm _is_ quite imperative =)
15:59:54 <Jedai> mm_freak_: Do you understand what I'm telling you or do you want a code sample ?
16:00:01 <Jedai> mm_freak_: Nope
16:00:03 <EvilTerran> mm_freak_, then your algorithm is badly chosen :P
16:00:10 <mm_freak_> Jedai: i do, but perhaps you don't understand my approach =)
16:00:32 <mm_freak_> Jedai: my first solution was with lists…  it worked well, it was elegant and functional-minded
16:00:34 <Jedai> mm_freak_: I understand it quite well since that's what I use (more or less)
16:00:51 <EvilTerran> mm_freak_, a solution with immutable arrays can be elegant and functional-minded
16:01:03 <EvilTerran> mm_freak_, and a lot faster than an equivalent with lists
16:01:24 <ddarius> SPJ pimping #haskell
16:01:29 <name> i am looking forward to http://freenode.net/policy.shtml#usernames :)
16:01:36 <mm_freak_> EvilTerran: let me solve it, and then let's try to make it more functional
16:01:36 <lambdabot> Title: 688 freenode: Policies
16:02:05 <Jedai> mm_freak_: http://hpaste.org/10038
16:02:15 <mm_freak_> without my optimization, it takes several minutes to solve on my machine…   with it, it should take less than a second
16:02:56 <EvilTerran> mm_freak_, ok, but i don't really follow your implementation of your algorithm, is all
16:02:58 <mm_freak_> Jedai: yes, that's what i did before, but with lists instead of arrays
16:03:06 <notname> @src join
16:03:06 <lambdabot> join x =  x >>= id
16:03:06 <mm_freak_> EvilTerran: let me implement it
16:03:07 <Jedai> mm_freak_: 1.5s for my totally declarative solution
16:03:24 <EvilTerran> mm_freak_, i mean your partial implementation - so i can't really help you
16:03:44 <mm_freak_> hold on
16:03:56 <Jedai> mm_freak_: Right, but here you need random access so you want an array but that doesn't mean it needs to be a mutable array
16:04:02 <name> i really need to learn haskell :) is realworkhaskell good?
16:04:15 <EvilTerran> name, yeah, realworldhaskell is (mostly) quite good
16:04:25 <EvilTerran> i think it's still a bit rough in places, as it's a work-in-progress
16:04:40 <EvilTerran> but you can bug the authors in here if you don't understand a bit
16:04:49 <EvilTerran> and they'll probably even be glad for the feedback :)
16:04:54 <r3m0t> :t join
16:04:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:05:03 <newsham> > runState (do { put 5; fail "test"; return 3 }) 8
16:05:05 <lambdabot>  mueval: Prelude.read: no parse
16:05:05 <lambdabot> mueval: (3,*** Exception: test
16:06:14 <ddarius> EvilTerran: At this point, there is not too much that will change (or be able to be changed)
16:06:47 <mmorrow> speaking of sieves, here's the /real/ sieve of eratosthenes http://hpaste.org/10039
16:06:54 <r3m0t> EvilTerran: should I read it?
16:08:06 <ddarius> mmorrow: Too many lines.
16:08:14 <EvilTerran> ddarius, well, there's still room for copyediting, isn't there? clarifications of phrasing, if not changes of content
16:08:27 <EvilTerran> r3m0t, well, if you like
16:08:43 <mmorrow> ddarius: note the Data.Map version. i had to rewrite insertWith for lists to get a list-only version
16:08:56 <Jedai> mmorrow: I think I'll just use the bits array imperative one, it's just so much faster and compact, though it isn't an infinite list so it's not as nice
16:09:24 <ddarius> mmorrow: The Map version is still more than one line.
16:10:01 <mmorrow> Jedai: check out the paper on the sieve, i found it interesting. it has graphs (performance of diff implems) as well http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
16:10:03 <lambdabot> Title: The Genuine Sieve of Eratosthenes
16:10:58 <mmorrow> ddarius: heh. i did in fact try to compress the Data.Map version to a single line, but wasn't satisfied with the length :)
16:12:50 <ddarius> mmorrow: You can replace the case with a use of maybe.
16:12:53 <Philonous> > let chainlengths = 0:[ 1+ ( chainlengths !! (next n -1)) | n <- [2..] ] where next n = if (even n) then (div n 2) else (3*n+1) in take 10 chainlengths
16:12:55 <lambdabot>  [0,1,7,2,5,8,16,3,19,6]
16:13:46 <mmorrow> ddarius: you could
16:16:51 <Jedai> mmorrow: I already read this paper
16:16:58 <mmorrow> @tell gwern lambdabot doesn't have Data.Map or Data.Set imported anymore?!
16:16:58 <lambdabot> Consider it noted.
16:17:48 <mmorrow> Jedai: so what data structure would you chose for a "sieve" situation?
16:18:24 <mmorrow> Jedai: ah, i guess i should ask that question for each case of infinite and finite
16:18:39 <Jedai> mmorrow: As I said, an array, a unboxed bit array is best for the sieve of erathostene
16:18:40 <ddarius> mmorrow: http://hpaste.org/10039#a4
16:18:55 <mmorrow> Jedai: ok, what about for the infinite case?
16:19:13 <Jedai> mmorrow: a list with one of the real sieve algorithm arounf
16:19:21 <mmorrow> ddarius: nice.
16:20:07 <waynemokane> has anyone written a lolcode interpreter in Haskell?
16:20:16 <im_alone> Jedai, it's better to have 500 GB x 8bit/Byte of disk array for sieve
16:20:25 <ddarius> @pl reinsert m p = M.insertWith (++) (x+p) [p] m
16:20:25 <lambdabot> reinsert = flip (ap (M.insertWith (++) . (x +)) return)
16:20:29 <mmorrow> Jedai: hmm, a list would have pretty poor performance, unless you're talking about an algorithm i'm not aware of
16:21:01 <Jedai> im_alone: I don't understand what you're talking about ?
16:21:14 <mmorrow> ddarius: collect for Data.Map http://hpaste.org/10039#a3
16:21:22 <ddarius> http://hpaste.org/10039#a5
16:21:50 <mmorrow> ddarius: there we go, now it's in proper haskell form
16:22:18 <Jedai> im_alone: the bit array solution is for a finite set, and it's much more compact that any Map/list based solution
16:22:25 <ddarius> mmorrow: Does it work?  I haven't been testing these.
16:22:31 <im_alone> Jedai, i'm saying that an array of 500 GB of disk has more primes of Sieve than an array of 3 GiB of RAM.
16:22:35 <mmorrow> ddarius: i'll check
16:22:58 <ddarius> Need parens around the flip ...
16:23:12 <Jedai> im_alone: Well sure but we're not searching big primes
16:24:19 <Jedai> mmorrow: What data structure would you use ?
16:24:40 <im_alone> so you will have primes upto 42 bits
16:25:00 <mmorrow> ddarius: yeah, or something along those lines
16:25:12 <ddarius> Also I forgot to do the lookup
16:25:32 <Jedai> mmorrow: I was speaking about one of the solution that use lists and an implicit stack
16:25:46 <mmorrow> Jedai: well, judging from the graphs in the paper, i'd use the fastest one (or a variation thereof) :)
16:25:55 * mmorrow looks at the paper again to see what that was
16:26:46 <Jedai> mmorrow: the solution of the paper was improved upon after its publication
16:27:39 <ddarius> mmorrow: Your Data.Map version immediately returns []
16:27:48 <Jedai> mmorrow: anyway the fastest solution used something like a priority queue
16:28:32 <mmorrow> ddarius: oops, that should be   go [2..] mempty
16:28:40 <Jedai> mmorrow: And there are way to construct one implicitly using the evaluation order of Haskell and some functions (look on the Wiki, I think there's an explanation)
16:29:08 <ddarius> http://hpaste.org/10039#a6
16:29:20 * Myoma wonders what the evaluation order of Haskell is
16:29:23 <mmorrow> Jedai: it looks like a "priority queue with wheel" was the best asymptotic performer she looked at
16:29:40 <shapr> dcoutts: Something's wrong with the Takusen 0.8.3 cabal file, and cabal list won't go past it.
16:30:02 <Jedai> mmorrow: The wheel isn't really a property of the data structure...
16:30:07 <ddarius> Here #haskell, you need to golf this down by about 10 characters:
16:30:08 <ddarius> sieve = foldr (\x xs m -> maybe (x:xs (M.insert (x*x) [x] m)) (xs . foldl' (flip $ \p -> M.insertWith (++) (x+p) [p]) (M.delete x m)) (M.lookup x m)) (const []) [2..] mempty
16:30:30 <mmorrow> Jedai: it the conclusion she looks at a list-only version, and notes that it's time complexity is asymptotically worse than trial division
16:30:34 <Myoma> @pl foldr (\x xs m -> maybe (x:xs (M.insert (x*x) [x] m)) (xs . foldl' (flip $ \p -> M.insertWith (++) (x+p) [p]) (M.delete x m)) (M.lookup x m)) (const []) [2..] mempty
16:30:37 <lambdabot> foldr (ap (flip . (ap .) . ap (ap . (liftM2 maybe .) . ap ((.) . (.) . (:)) (flip (.) . ap (M.insert . join (*)) return)) (flip ((.) . (.)) . ap ((.) . foldl' . flip . (`ap` return) . (M.insertWith (
16:30:37 <lambdabot> ++) .) . (+)) M.delete)) M.lookup) (const []) [2..] mempty
16:30:37 <lambdabot> optimization suspended, use @pl-resume to continue.
16:30:41 <Myoma> :D
16:30:53 <Jedai> mmorrow: Could you reread what I said before please...
16:31:17 <mmorrow> Jedai: ah, i didn't actually read about the wheel :)
16:32:39 <Jedai> mmorrow: http://www.haskell.org/haskellwiki/Primes#Implicit_Heap
16:32:42 <lambdabot> Title: Prime numbers - HaskellWiki
16:32:44 <mmorrow> Jedai: but the fact remains that i'd use a fast priority queue implem of this algo
16:32:53 <Jedai> mmorrow: That's what I was speaking about
16:33:48 <mmorrow> Jedai: yeah, the wiki implem and the paper's algo with a pq seem to be equivalent
16:33:56 <ddarius> Well, just removing whitespace makes a decent amount of difference
16:34:40 <ddarius> foldr(\x y m->maybe(x:y(M.insert(x*x)[x]m))(y.foldl'(flip$\p->M.insertWith(++)(x+p)[p])(M.delete x m))(M.lookup x m))(const[])[2..]mempty
16:34:54 <ddarius> > foldr(\x y m->maybe(x:y(M.insert(x*x)[x]m))(y.foldl'(flip$\p->M.insertWith(++)(x+p)[p])(M.delete x m))(M.lookup x m))(const[])[2..]mempty
16:34:56 <lambdabot>  mueval: Prelude.read: no parse
16:34:59 * shapr grumbles at vague type signatures
16:35:13 <ddarius> Any -> Any
16:35:27 <DeX|Torte> whats going on?
16:35:32 <mmorrow> ddarius: lb no longer has Data.Map
16:35:53 <shapr> DeX|Torte: CODE!
16:35:58 <Myoma> eep
16:35:59 <shapr> DeX|Torte: How's your code shaping up?
16:36:04 <DeX|Torte> wtf?
16:36:05 <mmorrow> ddarius: that was actually why i bothered doing it with lists at all .... to get a one-liner i could use with lambdabot ;)
16:36:06 <SamB_XP> Cale, gwern: care to explain this?
16:36:08 * Myoma codes also
16:36:12 <shapr> DeX|Torte: Er, you're not here to code?
16:36:22 <DeX|Torte> what the hell should i code?
16:36:28 <Myoma> DeX!!!
16:36:30 <shapr> Um, Haskell?
16:36:41 <shapr> ich habe keine ahnung!
16:36:45 <Myoma> DeX: um....... You know kevglass?
16:36:47 <SamB_XP> DeX|Torte: look at any of the ICFP contest websites if you can't think of anything ;-P
16:36:56 <SamB_XP> I particularly recommend ICFP 2006
16:37:03 <SamB_XP> http://boundvariable.org
16:37:16 <SamB_XP> hmm.
16:37:17 <DeX|Torte> hm
16:37:24 <SamB_XP> @google cult of the bound variable
16:37:26 <lambdabot> http://www.boundvariable.org/
16:37:26 <lambdabot> Title: ICFP Programming Contest, 2006
16:37:40 <SamB_XP> who would have thought the www was that important?
16:37:59 <DeX|Torte> I code my sisters arm
16:38:01 <DeX|Torte> :>
16:38:02 <mmorrow> ?set insertWith (<>) x y xs = maybe (insert (x,y) xs) (\z -> insert (x,y<>z) (delete (x,z) xs)) (lookup x xs)
16:38:03 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
16:38:46 <mmorrow> ok, it worked in a /msg
16:38:48 <SamB_XP> ICFP 2006 is cool because you can quickly reach the point where there are many different challanges to sink your teeth into
16:38:55 <DeX|Torte> who needs help?
16:39:07 <mmorrow> > let go [] _ = [] ; go (x:xs) m = maybe (x:go(xs)(insert(x*x)[x]m)) (\ys -> go xs (foldl' (\m p -> insertWith (++) (x+p) [p] m))) in go [2..]
16:39:08 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `[t2]'
16:39:48 <shapr> It's a pain to port really old code to new interfaces...
16:39:57 <mmorrow> > let sieve = (let go (x:xs) m = maybe (x:go xs (insert (x*x,[x]) m)) (\ys -> go xs (foldl (\m p -> insertWith (++) (x+p) [p] m) (delete (x,ys) m) ys)) (lookup x m) in go [(2::Integer)..] []) in sieve
16:39:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:40:03 <mmorrow> woohoo
16:41:04 * DeX|Torte hits an Allah-Akhbar Bomb in mmorrow 's town!
16:41:18 <mm_freak_> Jedai: now i understand…  you're using a totally different algorithm
16:42:23 <Jedai> mm_freak_: Ok, maybe I misunderstood you, but one thing is for sure : I never compute two times the collatz sequence of a number (in the array)
16:42:43 <mm_freak_> yes, i realized this now
16:42:45 <Jedai> mm_freak_: Which was your objective, no ?
16:43:37 * shapr boing
16:43:38 <shapr> s
16:44:11 <Olathe> No boinging.
16:44:18 <Myoma> not _enough_ boinging!
16:44:24 <Olathe> What you say ?!
16:44:37 <Myoma> .. somebody set us up the boing :)
16:44:51 <mm_freak_> Jedai: yeah, i tried to optimize the naïve approach, which was a flawed idea in the first place
16:45:34 <_zenon_> I get " fd:9: hClose: resource vanished (Broken pipe)" when trying to get lambdabot to eval something with ">"
16:46:17 <_zenon_> > map (+1) [1..10]
16:46:19 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:46:27 <_zenon_> hm,, that fails with my bot
16:46:43 <_zenon_> anyone knows what could be the problem?
16:47:32 <Jedai> mm_freak_: My approach seemed pretty naive to me
16:48:09 <im_alone> > map (^2) [1..1000]
16:48:11 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
16:48:33 <_zenon_> Cale, you have any idea?
16:48:37 <Olathe> > ([1, 4, 9]...)
16:48:39 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
16:48:51 <mmorrow> > map (sqrt . fromIntegral) [0..]
16:48:53 <lambdabot>  [0.0,1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489...
16:49:14 <dmhouse> > map sqrt [0..]
16:49:15 <lambdabot>  [0.0,1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489...
16:49:17 <mm_freak_> Jedai: the naïve approach is:  maximumBy (compare `on` snd) [ (i, length (collatz i)) | i <- [2..n] ]
16:49:24 <im_alone> > primes
16:49:24 <mm_freak_> that's more naïve than yours =)
16:49:25 <lambdabot>  mueval: Prelude.read: no parse
16:49:26 <mmorrow> @type sqrt
16:49:28 <lambdabot> forall a. (Floating a) => a -> a
16:49:33 <mmorrow> dmhouse: :)
16:49:48 <dmhouse> mmorrow: numeric literals are overloaded
16:49:58 <mmorrow> dmhouse: heh, silly me
16:52:00 <mmorrow> dmhouse
16:52:04 <mmorrow> :
16:52:07 <_zenon_> Someone familiar to lambdabot?
16:52:08 <dmhouse> y
16:52:08 <dmhouse> e
16:52:09 <dmhouse> s
16:52:09 <dmhouse> ?
16:52:24 <_zenon_> Why does '>' fail?
16:52:33 <mmorrow> ok, the slightly wrong reason that that works is that Float and Double are instances of Enum
16:52:33 <dmhouse> > "it doesn't"
16:52:34 <Jedai> mm_freak_: Well I guess... But then when you optimize that, shouldn't you naturally discover that the length of collatz i is the same as 1 + length (collatz (next i)) ?
16:52:35 <lambdabot>  "it doesn't"
16:52:47 <dmhouse> mmorrow: quite.
16:53:04 <Myoma> It's strange when you rewrite something 3x better, I wonder how did I do it so badly in the first place
16:53:04 <dmhouse> mmorrow: they're not *really* enumerable, but it's convenient to have .. notation for them
16:53:07 <Jedai> _zenon_: It might fail if the Haskell is wrong or use functions/Variables unknown
16:53:15 <mmorrow> dmhouse: heh, i was like whoa! how'd that work?!?
16:53:28 <_zenon_> Jedai, i just tried map (+1) [1 .. 10]
16:53:34 <_zenon_> Jedai, even > [1..10]
16:53:42 <_zenon_> just fails with the same message
16:53:54 <Jedai> > map (+1) [1..10]
16:53:54 <_zenon_> fd:9: hClose: resource vanished (Broken pipe)
16:53:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:54:01 <Olathe> > 5
16:54:03 <lambdabot>  5
16:54:08 <mm_freak_> Jedai: i did now, and then looking at your code i realized that you're doing exactly that
16:54:18 <_zenon_> Jedai, I forgot to mention it is a lambdabot I have built with caba-install
16:54:25 <twanvl> dmhouse: Float and Double *are* really enumerable, just not in the way you want
16:54:37 <Philonous> Jedai: Would you mind showing your code again?
16:54:38 <Olathe> > [1.0..10.0]
16:54:40 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
16:54:47 <Jedai> Philonous: Which ?
16:55:00 <Philonous> The solution to euler14
16:55:01 <fnord[work]> Question....... I come from a C++ background and i'm used to designing everything by designing interfaces and then coming up with implementations. So, I would naturally structure my Haskell programs in a similar fashion.. i.e. making type classes (which I know aren't a direct correlation to C++ classes, but actually C++ concepts). And the question: I don't see others coding Haskell like this. Why?
16:55:04 <dmhouse> twanvl: they were enumerable in exactly the way I wanted.
16:55:14 <Philonous> the one oyu are discussing with mm_freak_
16:55:20 <fnord[work]> Or is this a Haskell-Cafe question. :)
16:55:20 <Jedai> Philonous: http://hpaste.org/10038
16:55:25 <Philonous> Thanks a bunch
16:55:37 <dmhouse> twanvl: but you can't enumerate R, which is what I meant. (I suppose you could argue that floating points always have finite binary expansions, so you can enumerate all floats.)
16:56:00 <twanvl> dmhouse: Yes, that's what I meant
16:56:16 <Jedai> fnord[work]: There are some that do that
16:56:30 <Olathe> Is there a way to get the next ulp with a float ?
16:56:36 <Philonous> Ah, that's aexactly what I did. But my version takes forever... But I guess it's because lists behave badly on random access
16:56:39 <Myoma> what is the problem euler 14
16:56:42 <Philonous> exactly*
16:56:59 <RayNbow> > let t = Node 1 [Node 2 [],Node 3 []]; ft = Node (+1) [Node negate []] in drawTree $ show <$> (ft <*> t)
16:57:01 <lambdabot>  "2\n|\n+- 3\n|\n+- 4\n|\n`- -1\n   |\n   +- -2\n   |\n   `- -3\n"
16:57:02 <Jedai> Philonous: Did you also "cut-off" because that has an huge influence
16:57:14 <Philonous> Myoma: http://projecteuler.net/index.php?section=problems&id=14
16:57:19 <Jedai> Philonous: And of course the random access of the array is very nice
16:57:23 <lambdabot> Title: Problem 14 - Project Euler
16:57:29 <mmorrow> > error (let t = Node 1 [Node 2 [],Node 3 []]; ft = Node (+1) [Node negate []] in drawTree $ show <$> (ft <*> t))
16:57:31 <lambdabot>  mueval: Prelude.read: no parse
16:57:31 <lambdabot> mueval: *** Exception: 2
16:57:31 <lambdabot> |
16:57:31 <lambdabot> +- 3
16:57:31 <lambdabot> |
16:57:33 <lambdabot> [3 @more lines]
16:57:45 <fnord[work]> Jedai, really? I usually don't see it. e.g. XMonad doesn't follow that style. Yi doesn't follow that style (IIRC) etc
16:58:10 <RayNbow> mmorrow: we need to prepend the generated string with a newline
16:58:21 <mmorrow> heh
16:58:41 <mmorrow> > error (let t = Node 1 [Node 2 [],Node 3 []]; ft = Node (+1) [Node negate []] in '\n' : (drawTree $ show <$> (ft <*> t)))
16:58:43 <lambdabot>  mueval: Prelude.read: no parse
16:58:43 <lambdabot> mueval: *** Exception:
16:58:43 <lambdabot> 2
16:58:43 <lambdabot> |
16:58:43 <lambdabot> +- 3
16:58:45 <lambdabot> [4 @more lines]
16:58:47 <RayNbow> @more
16:58:48 <lambdabot> |
16:58:49 <lambdabot> +- 4
16:58:51 <lambdabot> |
16:58:53 <lambdabot> `- ...
16:58:56 <RayNbow> aww
16:59:26 <_zenon_> @plug last [1..1000]
16:59:26 <lambdabot> Maybe you meant: bug ping pl
16:59:33 <Myoma> if you do it in /query it can go for longer but I guess that defeats the purpose
16:59:35 <_zenon_> @plugs last [1..1000]
16:59:35 <lambdabot> Unknown command, try @list
17:00:26 <Capso> @ping
17:00:27 <lambdabot> pong
17:00:33 <Capso> stoopid bot
17:00:41 <RayNbow> @pong
17:00:42 <lambdabot> pong
17:01:16 <Philonous> Jedai: I didn't cut of. I figured lazyness would do the trick and still wanted to save time by caching colissions > 1M. But I guess you can't do that with listArrays since you need to know the upper bound...
17:01:41 <fnord[work]> Another example is the toy game exmaple "Shuthing"
17:02:26 <Jedai> Philonous: Yeah, but even in the list case it would have saved you quite a lot of time : think about it, even if you don't compute their content, by not cutting-of, you have to create a list with much more elements (and I mean _much_ more)
17:03:38 <Jedai> Philonous: you only have to compute the content of the cells which are in the 1000000 first and the ones who are in the collatz sequences from those 1..1000000 but the list must be extended to get to all these cells
17:03:42 <Philonous> Jedai: Yeah, now you mention it it sounds perfectly reasonable. I still wonder how large the random-access impact is. I guess I'll have to test it later
17:04:11 <im_alone> @google category theory
17:04:14 <lambdabot> http://en.wikipedia.org/wiki/Category_theory
17:04:14 <lambdabot> Title: Category theory - Wikipedia, the free encyclopedia
17:04:34 <Jedai> Philonous: Probably quite large too but the main reason for the slowness of your solution lies more with the cut-off IMHO (I didn't benchmark though so I could be wrong)
17:04:38 <Myoma> You can get n log n access into a list
17:04:58 <_zenon_> @message
17:04:58 <lambdabot> Maybe you meant: messages messages?
17:05:15 <Jedai> Myoma: No, in a Sequence you can, in a simply linked list access is in O(n)
17:05:22 <Myoma> !! in O(n)
17:06:10 <_zenon_> @tell Cale Could you put #mobileread among the channels which lambdabot joins? It would be great.
17:06:10 <lambdabot> Consider it noted.
17:07:01 <dmhouse> Surely if you can get O(n) access, you can get O(n log n) access.
17:07:13 <im_alone> what other lazy abstract machines exist instead of SECD or SKI ?
17:07:39 <Jedai> dmhouse: Right... I think he meant O(log n) though... (Sequence has access in O(log n) I think)
17:08:13 * Myoma she
17:08:18 <Myoma> I mean't n log n
17:08:21 <Myoma> meant
17:08:29 * Myoma writes out the idea in haskell
17:08:53 <Jedai> Myoma: Then you're right since !! is in O(n)
17:08:56 <dmhouse> Myoma: why would you want it, if you have O(n) access?
17:09:51 <Myoma> oh yes I meant log n
17:10:01 <saya> -.-
17:10:07 <Olathe> How do you get log n access with a list ?
17:10:26 <saya> you need to sort it somehow to get log n
17:10:31 <mm_freak_> Jedai: this is what i came up with: http://hpaste.org/10040
17:10:32 <Jedai> Olathe: You can't, at least if you're speaking about a simply linked list
17:10:42 <mm_freak_> Jedai: but it's slow as hell =/
17:11:07 <Jedai> mm_freak_: you don't memoize the array !!
17:11:18 <im_alone> it's kas'hell
17:11:22 <Jedai> mm_freak_: you're computing it again every time
17:12:03 <mm_freak_> Jedai: ah, got it
17:13:00 <Jedai> saya: even sorted you can't
17:13:33 <saya> yeah indeed you need a tree
17:14:09 <Myoma>  . .   .       . ____________        .___...
17:14:09 <Myoma>  | |\  |  \    |             \        |
17:14:09 <Myoma>  | | | |\  |\  |   \       |    \     |
17:14:09 <Myoma>  | | | | | | | |\  | \   |  \   | \   |
17:14:09 <Myoma> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,...]
17:14:26 <dmhouse> Myoma: so the list has to be sorted first?
17:14:36 <Myoma> you can build this structure in a lazy way I think, so !!530 takes O(n), then next time around it takes Omega(log n)
17:14:43 <Myoma> no it doesn't have to be sorted
17:14:55 * Myoma tries to program it ..
17:15:13 <Jedai> Myoma: Well... but then it's not a list anymore you know ? It's a tree
17:15:33 <Myoma> Jedai: I think it is a tool which gives access into a list
17:15:48 <mm_freak_> Jedai: http://hpaste.org/10040#a2
17:15:51 <mm_freak_> works well
17:15:56 <Jedai> Myoma: Just use Sequence up front
17:16:13 <Myoma> no thanks
17:16:26 <mmorrow> Myoma: please tell me you didn't do that by hand and have code to do it which you will paste!! :)
17:16:41 <dmhouse> Myoma: so wait, you lazily generate a tree structure from the list?
17:17:00 <Jedai> mm_freak_: Yes, it's as fast as most C solutions which is good enough IMO
17:17:22 <mm_freak_> yeah, though i get an array index error, when i use Int as the index type
17:17:29 <mm_freak_> so i changed it to Integer
17:17:37 <gwern> a pity _zenon_ left, I was going to tell him only darcs lb is supported
17:17:37 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:17:40 <gwern> @seen Cale
17:17:40 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 4h 35m 22s ago.
17:17:42 <Philonous> Jedai: It's still horribly slow, even with clipping. So I guess I need to use another data structure
17:17:46 <gwern> @messages
17:17:46 <lambdabot> mmorrow said 1h 47s ago: lambdabot doesn't have Data.Map or Data.Set imported anymore?!
17:17:58 * Myoma realizes there are O(n) of the .'s at the top :[
17:18:05 <mmorrow> Data.Tree needs a drawTreeBF
17:18:11 <Jedai> mm_freak_: That's because the collatz sequence go over the Int limit and come back as a negative number...
17:18:21 <Toxaris> Myoma: why?
17:18:30 <gwern> mmorrow: if you don't like it, complain at http://hackage.haskell.org/trac/ghc/ticket/1895
17:18:40 <Jedai> Philonous: Yeah, then I guess the lazy array solution I used is your best bet
17:18:50 <mm_freak_> Jedai: yeah, i know…  maybe changing to Int64 will solve that, so i save some overhead
17:18:52 <Jedai> Philonous: Or an IntSet should be fine
17:18:53 <solrize> hmm i'm trying to bootstrap cabal-install and it doesn't find -lgmp even though i have libgmp installed
17:19:01 <gwern> speaking of mueval, I'm adding Control.Arrow to the defaults since people seem to expect it
17:19:15 <mmorrow> gwern: so you're saying that this is on account of hint?
17:19:19 <solrize> also it doesn't find pushd/popd:    ./bootstrap.sh: 21: pushd: not found
17:19:25 <Jedai> mm_freak_: Don't worry about that frankly, it's already good enough (my solution score a 1.5s on my computer)
17:19:38 <gwern> mmorrow: no, it's on account of the GHC API
17:19:49 <gwern> hence the GHC ticket :)
17:20:03 <solrize> i changed #!/bin/sh to /bin/bash
17:20:30 <solrize> ahh, much better
17:20:33 <Toxaris> Myoma: I see O(log n) dots, e.g. 4 dots for [0..15]
17:20:57 <gwern> @tell _zenon_ btw, if you're going to use lambdabot - I'll reiterate, the current hackage lb is old and broken. I am considering uploading current darcs lb just so I don't have to see you flounder with it still...
17:20:57 <lambdabot> Consider it noted.
17:21:10 <mmorrow> gwern: yes, by extension through hint. but qualified imports would be possible via plugins (which uses the ghc-api) if lb still used the old method of evaluating expressions
17:21:21 <gwern> @tell dons I've sent the frag patches for sdist and haddock. next time don't use darcs dist, you naughty person
17:21:21 <mm_freak_> Jedai: interestingly it's faster with Integer than with Int64 =)
17:21:21 <lambdabot> Consider it noted.
17:21:53 <Olathe> > let (!!!) xs n = n in [1..] !!! 10
17:21:55 <lambdabot>  10
17:21:58 <Jedai> mm_freak_: Integer use Int arithmetic when the number are small enough so that's probably the reason
17:22:01 <Olathe> OMG ! O(1) access time !
17:22:13 <gwern> mmorrow: eh. complain to jcpetruzza then as well as the ghc bug
17:22:17 <gwern> @seen jcpetruzza
17:22:18 <lambdabot> I haven't seen jcpetruzza.
17:22:26 <gwern> preflex: seen jcpetruzza
17:22:26 <preflex>  jcpetruzza was last seen on #haskell 4 days, 1 hour, 47 minutes and 49 seconds ago, saying: @src partition
17:22:36 <rwbarton> gwern: it seems like there's a typechecking phase that knows about Control.Arrow before mueval is run.  Consider:
17:22:37 <mmorrow> gwern: heh, just giving you a hard time :)
17:22:45 <rwbarton> > (id *** id)   -- knows type of (***)
17:22:46 <lambdabot>      Overlapping instances for Show ((a, b') -> (a, b'))
17:22:46 <lambdabot>       arising from a...
17:22:58 <rwbarton> > (id *** id) (3, 4)   -- should work then
17:23:00 <lambdabot>  mueval: Prelude.read: no parse
17:23:16 <Olathe> :t (id *** id)
17:23:18 <lambdabot> forall a b'. (a, b') -> (a, b')
17:23:41 <Olathe> > let f = (id *** id) in f (3, 4)
17:23:42 <lambdabot>  mueval: Prelude.read: no parse
17:23:46 <Olathe> Neato !
17:24:04 <Philonous> Jedai: Funnily enough my brute force lisp programme only takes 5 seconds to compute
17:24:06 <Armored_Azrael> Hey, is there a function in prelude that is like map, but grabs two elements from the list at a time?
17:24:18 <gwern> :t goes through a different mechanism than @run
17:24:20 <lambdabot> Not in scope: `goes'
17:24:20 <lambdabot> Not in scope: `through'
17:24:20 <lambdabot> Not in scope: `different'
17:24:27 <Jedai> mm_freak_: Frankly the main reason Int is faster than Integer isn't the speed of the math operation but rather the fact that Int usage can often be unboxed
17:24:37 <Toxaris> Armored_Azrael: no
17:24:39 <rwbarton> It's not too strange that :t knows about more functions than @run
17:24:47 <gwern> @tell Cale a mueval upgrade might be nice, since people seem bound and determined to use a lot of arrow stuff
17:24:48 <lambdabot> Consider it noted.
17:24:54 <rwbarton> but that the @run typechecker knows about more functions than the evaluator is occasionally confusing
17:25:03 <Toxaris> > iterate (drop 2) "but you can start with that, Armored_Azrael"
17:25:05 <lambdabot>  ["but you can start with that, Armored_Azrael","t you can start with that, A...
17:25:26 <Toxaris> > map (take 2) . iterate (drop 2) $ "but you can start with that, Armored_Azrael"
17:25:28 <lambdabot>  ["bu","t ","yo","u ","ca","n ","st","ar","t ","wi","th"," t","ha","t,"," A",...
17:25:33 <mm_freak_> Jedai: Integer can be unboxed as well, no?
17:25:45 <Toxaris> @src Integer
17:25:45 <lambdabot> data Integer = S# Int#
17:25:45 <lambdabot>              | J# Int# ByteArray#
17:25:50 <Olathe> > let bunch [] = []; bunch (a:b:xs) = (a, b):(bunch xs) in bunch [1..10]
17:25:52 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
17:25:56 <Jedai> mm_freak_: No, as Toxaris just showed
17:26:11 <Toxaris> imho more then one constructor -> box needed
17:26:22 <Toxaris> @src Int
17:26:22 <lambdabot> data Int = I# Int#
17:26:33 <gwern> :t writeFile . readFile "foo"
17:26:34 <mmorrow> Jedai: +/* on and Integer which doesn't fit into a mach Int are O(lg n) i believe
17:26:34 <Toxaris> Int is *always* Int#, so we can use Int# directly
17:26:35 <lambdabot>     Couldn't match expected type `a -> FilePath'
17:26:35 <lambdabot>            against inferred type `IO String'
17:26:35 <lambdabot>     In the second argument of `(.)', namely `readFile "foo"'
17:26:39 <gwern> :t writeFile . readFile $ "foo"
17:26:41 <lambdabot>     Couldn't match expected type `FilePath'
17:26:41 <lambdabot>            against inferred type `IO String'
17:26:41 <lambdabot>       Expected type: FilePath -> FilePath
17:27:03 <gwern> :t (writeFile "foo") . (readFile "foo")
17:27:05 <lambdabot>     Couldn't match expected type `a -> String'
17:27:05 <lambdabot>            against inferred type `IO String'
17:27:05 <lambdabot>     In the second argument of `(.)', namely `(readFile "foo")'
17:27:12 <Armored_Azrael> Toxaris: You seem to have misunderstood what I want the function to do, but it's OK, I was just checking that we didn't have a primitive to express my function more elegantly
17:27:15 <mm_freak_> @src Integer
17:27:15 <lambdabot> data Integer = S# Int#
17:27:16 <lambdabot>              | J# Int# ByteArray#
17:27:23 <mm_freak_> ok
17:27:32 <mmorrow> Jedai: since that ByteArray# stores a Tree rep from what i understand
17:27:54 <mm_freak_> @src Int64
17:27:54 <lambdabot> data Int64 = I64# Int64#
17:27:55 <gwern> eh. it makes sense for the typechecker to know more than the evaluator - it doesn't have to worry about unsafe code. the worst a typechek fragment can do is DOS, AFAIK
17:28:17 <Toxaris> > map (take 2) . tails $ "Armored_Azrael: maybe you mean this, then?"
17:28:18 <lambdabot>  ["Ar","rm","mo","or","re","ed","d_","_A","Az","zr","ra","ae","el","l:",": ",...
17:28:29 <Jedai> mmorrow: Yeah, that's right
17:29:09 <mm_freak_> Jedai, Toxaris: but then i'd think that S# Int# can be unboxed as well?  if the compiler recognizes it
17:29:19 <Olathe> Ooh !
17:29:25 <Jedai> mmorrow: but since Int can never be that big, that comparison doesn't make much sense, I was speaking of the operation on Integer as big as Int compared to operations on Int
17:29:36 <Armored_Azrael> Toxaris: Yes, this is what I meant
17:30:37 <Myoma> @pl (\x _ -> (x :))
17:30:37 <lambdabot> const . (:)
17:30:47 <mmorrow> Jedai: that's true. was just extending to a related thing :)
17:30:49 <Olathe> > let f (a:b:xs) = (a, b):(f (b:xs)); f _ = [] in f "OMG HI !"
17:30:51 <lambdabot>  [('O','M'),('M','G'),('G',' '),(' ','H'),('H','I'),('I',' '),(' ','!')]
17:30:57 <Toxaris> mm_freak_: "if the compiler recognizes it"? You mean, if the compiler realizes at compile time that an Integer is S and not J?
17:31:07 <Toxaris> mm_freak_: I don't think that happens often
17:31:20 <rwbarton> > zip`ap`tail $ "OMG HI !"
17:31:22 <Toxaris> but if it happens, it could be handled by constructor specialization maybe
17:31:22 <lambdabot>  [('O','M'),('M','G'),('G',' '),(' ','H'),('H','I'),('I',' '),(' ','!')]
17:31:31 <Olathe> @src ap
17:31:31 <lambdabot> ap = liftM2 id
17:31:36 <Olathe> @src liftM2
17:31:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:31:37 <Jedai> Philonous: The brute force program in Haskell take 5s on my computer too
17:32:48 <Jedai> Philonous: http://hpaste.org/10038#a1
17:32:49 <Toxaris> mm_freak_: but I would assume most Integer's are the result of arithmetic computation, and I don't think ghc tries to guess whether the results of such computations fit in an Int
17:33:40 <mm_freak_> makes sense
17:34:24 <Toxaris> I consider Integer as Int with overflow checks -- and sensible overflow handling, namely, fallback to a big int library
17:34:55 * gwern reads a paper on maximal laziness. interesting stuff
17:36:04 <gwern> 'Maximal laziness can give a nice performance improvement over a “traditional”
17:36:05 <gwern> implementation of sharing (Section 5), reducing the number of rewrite steps by
17:36:08 <gwern> 40% to as much as 280% for typical, large Nix expressions. So maximal laziness
17:36:23 <gwern> gives faster but simpler interpreters. Also, several years of experience with max-
17:36:23 <gwern> imal laziness in the Nix expression evaluator has shown that memory use scales
17:36:23 <gwern> well despite the naive evaluation result caching that never discards any result.
17:36:47 <mm_freak_> Toxaris: i consider it as what it is:  a type for all integers =)
17:37:18 <Toxaris> well, it is not just a big int library (as in: use it when you expect big integers), but it is a all ints library
17:37:25 <Toxaris> as in: use it always
17:38:34 <mm_freak_> yeah
17:38:34 <FsCanHas4Kittehs> Toxaris: are you saying it uses a machine integer until overflow occurs?
17:38:41 <mm_freak_> i.e. a type for all integers =)
17:38:49 <mm_freak_> FsCanHas4Kittehs: yes
17:38:53 <Toxaris> FsCanHas4Kittehs: semantically, yes
17:39:22 <Toxaris> FsCanHas4Kittehs: I don't know how it checks whether a value fits into a machine integer
17:39:24 <Toxaris> @src Integer
17:39:25 <lambdabot> data Integer = S# Int#
17:39:25 <lambdabot>              | J# Int# ByteArray#
17:39:46 <FsCanHas4Kittehs> Toxaris: try until it gets an overflow error? :)
17:39:49 <mmorrow> but ghc can't unbox an Integer as an optimization like it can an Int
17:39:56 <Toxaris> I would guess so, but I have no clue
17:40:08 <FsCanHas4Kittehs> though I have no idea whether current processors signal some kind of error or just happily continue mod 2^n
17:40:33 <Toxaris> I don't think they have thrown the good old overflow flag away
17:41:44 <BMeph> gwern: So, have you pointed dons at that paper, so he can put it on reddit...and then post the link here? ;)
17:42:46 <Toxaris> would it make sense to "inline" Integer into data type definitions, and then "float it up" to the top level data, do the same with case expressions and hope to be able to unbox int for whole functions / inner loops / bottlenecks
17:43:14 <paczesiowa> BMeph: probably americanhellyeah will do it without asking:>
17:43:44 <gwern> BMeph: no, you think I should?
17:44:12 <BMeph> paczesiowa: Well, if dons doesn't beat him to the punch, heh-heh.
17:44:19 <Toxaris> e.g. data MyType = A Integer | B Char ~~> data MyType = A (S# Int# | J# Int# BigInt#) | B Char ~~> data MyType = A_S (S# Int#) | A_J (J# Int# BigInt#) | B Char ~~> data MyType = A_S Int# | A_J Int# BigInt#
17:44:20 <mmorrow> Toxaris: the problem though wrt unboxing Integer is what is the type after unboxing? ie it would have to always be (# Int#, ByteArray# #).
17:44:53 <Toxaris> with a "| B Char" missing in the result
17:45:12 <BMeph> gwern: Well, since you've already shown that it's an interesting paper, and at least partially applicable to Haskell, I expect dons to do it without needing prompting...and maybe he already has! ;)
17:45:21 <Toxaris> with that transformation, we still have the same possible values for MyType (assuming everything is strict anyway), but kind-of unboxed Integer
17:45:30 <Myoma> primes = ?
17:45:43 <Toxaris> now regular constructor specialization could kick in to optimize functions for the A_S case
17:45:50 <BMeph> Olathe: Doesn't your bunch function bomb out on odd-sized lists? :)
17:45:55 <gwern> BMeph: heck, I'll post it myself if I can just think of a catchy title
17:46:01 <Toxaris> and even if not, we have eliminated one level of indirection
17:46:04 <Myoma> can anyone give me some kind of recursive definition of primes?
17:46:06 <gwern> 'Laziness means never having to apologize^Woptimize'?
17:46:23 <dons> that's a cool slogan.
17:46:23 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:46:36 <dons> esp. for old school laziness -- not worrying about data generation.
17:46:58 <mmorrow> Toxaris: yeah, that would definitely be a optimization over a boxed Integer and I don't think ghc does it
17:47:15 <Myoma> toBinary 0 = []
17:47:15 <Myoma> toBinary (half' -> Left n) = O : toBinary n
17:47:15 <Myoma> toBinary (half' -> Right n) = I : toBinary n
17:47:19 <Myoma> view patterns rule :p
17:47:30 <newsham> grr.. wtf,  HsOpenSSL package is trying to run "gnome-config" to see if I have openssl installed?
17:49:08 <fnord[work]> Hi dons.
17:49:11 <Toxaris> mmorrow: I guess there are issues with binary compatibility
17:49:12 <BMeph> gwern: How about 'Laziness means never having to say you're sorry...for premature optimization"? ;)
17:49:22 <gwern> heh heh
17:49:29 <gwern> I suppose ^W is too obscure a joke these days
17:49:54 * gwern waves stick. get off my tty you damn kids
17:49:57 <fnord[work]> gwern, most /. people get the ^H at least
17:50:49 <gwern> fnord[work]: man, don't talk to me about /.. they've abandoned their most venerable memes and jokes and are a festering wastepit
17:50:56 <gwern> in korea, only old people read /.!
17:51:37 * BMeph waits for the inevitable "Soviet Russia" line...
17:51:44 <fnord[work]> That's fine, because in North Korean /., /. reads old people
17:52:08 * BMeph is impressed with fnord's jink
17:52:33 * Twey laughs.
17:52:53 * fnord[work] imagines a beowulf cluster of old North Koreans being read.
17:53:06 <halberd> are you judging /. by 4chan standards?
17:53:18 <gwern> http://www.reddit.com/r/programming/comments/6yuwq/laziness_means_never_having_to_say_youre_sorry/
17:53:20 <lambdabot> Title: Laziness means never having to say you're sorry... for premature optimization [P ..., http://tinyurl.com/57kwty
17:53:32 * BMeph imagines a North Korean beowulf cluster of Burroughs 5500s...
17:53:43 <Jedai> Myoma: For definitions of primes, look at the haskellWiki
17:53:45 <gwern> holy shit, for a moment there my heart skipped a beat as I thought I misspelled 'you're'
17:54:02 <fnord[work]> mismatched '
17:55:34 <Jedai> gwern: I just can't really believe this paper... I mean in real worl program that will lead to horrific memory leaks, no ?
17:56:19 <gwern> Jedai: well, in the real world you wouldn't really be able to acheive maximal laziness since you'll be using compiled and not interpreted programs
17:56:56 <Jedai> gwern: That don't seem to be very true in my real world (Perl, Python, Ruby, ....)
17:56:58 <fnord[work]> Since new people appear to be here, I'll repeat my discussion question... when coding in OO languages, teams usually build a system of interfaces with retargeted implementations. This looks like it would make sense in Haskell by having type classes implemented by different data types. However, I haven't come across any code that uses this as a general strategy for modularising the project. Jedai said it's sometimes do
17:57:37 <Jedai> fnord[work]: We don't only use type class, sometimes using modules makes more sense
17:57:56 <gwern> Jedai: also, you don't *have* to memoize everything. further optimization work could be done by the compiler/interpreter analyzing what expressions might ever be needed again and discarding some (for memory savings)
17:58:22 <dons> fnord[work]: this is pretty common on large systems at Galois, fwiw.
17:58:37 <dons> type classes abstracting over pluggable implementations for different components
17:58:44 <dons> (storage, hardware, network abstracts, etc.)
17:58:54 <dons> it's one of the main building blocks of modularity
17:58:59 <dons> (along with polymorphism and purity)
17:59:02 <Jedai> gwern: I guess so but that's the part that seems very hard to me, at least with the way Haskell does it currently you can give hint to the compiler, it seems kinda like the automatic parallelism idea
17:59:18 * gwern doesn't know much about programs/libraries structured around type classes for modularity, but I suppose that's because I mostly work on 'small' stuff
17:59:31 <fnord[work]> dons, thanks. I was basically refactoring the Shuthing example game from haskell.org into that strategy and it confused me why i never saw other code that did this.
17:59:34 <gwern> Jedai: well, automatic parallelism doesn't give much of a speedup iirc
17:59:44 <gwern> fnord[work]: you're patching shuthing?
17:59:54 <ddarius> fnord[work]: You should see Ashley Yakeley's code.
18:00:01 <dons> fnord[work]: i think we use polymorphism for some of the things done in OO-ish ways elsewhere.
18:00:10 <dons> i.e. pluggable data types with polymorphic holes
18:00:21 <gwern> 'We have 50 million lines of C++ code. No, it's more than that now. I don't know what it is anymore. It was 50 million last Christmas, nine months ago, and was expanding at 8 million lines a quarter. The expansion rate was increasing as well. Ouch.'
18:00:27 <gwern> http://steve.yegge.googlepages.com/tour-de-babel
18:00:28 <lambdabot> Title: Stevey's Home Page - Tour de Babel
18:00:32 <Capso> dons: holes and plugs
18:00:40 <dons> some specific runtime-extensible apps use existentials+dynamics+typeclasses for object like things
18:01:01 <Jedai> gwern: Yeah, that's what I mean, this maximal lazyness but optimisation by the compiler to avoid memory abuse seems like automatic parallelization to me, I don't see it working well in real cases
18:01:06 <fnord[work]> gwern, I'm playing with the code. If someone wants my code, I'll happily share it, but I didn't intend to scrub it up for publishing.
18:01:16 <paczesiowa> dons: why not OOHaskell?
18:01:29 <gwern> fnord[work]: well, you're using the shu-thing darcs repo right?
18:01:49 <fnord[work]> gwern, no. I had a targz from almost a year ago
18:02:03 <gwern> Jedai: mm, the nix fellows got some speedups way beyond anything I've ever seen for automatic parallelism
18:02:09 <fnord[work]> my code makes it more like geometry wars where you use the mouse to aim
18:02:15 <gwern> fnord[work]: oh. well, you might want to use the code in teh darcs repo then?
18:02:56 <fnord[work]> I'll take a look. I thought it was a toy project that was submitted and nothing was being done w/ it.
18:02:57 <paczesiowa> dons: iirc Oleg was replacing "pluggable" examples with his OO thingie and it was better somehow
18:03:35 <gwern> fnord[work]: well, I kind of did some cleaning and packaging of shu-thing and I suppose I'm what passes for a maintainer
18:03:49 <gwern> if you're adding features and playability that interests me
18:03:58 <Jedai> gwern: I don't doubt that it can achieve massive speedups in some case (after all it's basically "memoization everywhere") but it's only on very specific cases, any big program that need to run for a time should be a much harder client
18:04:37 <gwern> Jedai: we'll never know until someone tries!
18:05:11 <dons> paczesiowa: i think he was trying to model exactly "objects"
18:06:22 <gwern> 'As Jamie Zawinski said in his famous "java sucks" article: "First the good stuff: Java doesn't have free(). I have to admit right off that, after that, all else is gravy. That one point makes me able to forgive just about anything else, no matter how egregious. Given this one point, everything else in this document fades nearly into insignificance."'
18:06:33 <paczesiowa> dons: what's the difference between " exactly \"objects\"" and those things with polymorphic holes?
18:07:30 <dons> polymorphic data structures let us modify some code's behaviour by instantiating it at a different type
18:07:40 <mib_gdgp0jci> trest
18:07:40 <dons> so you use that as a safe, simple way to do some kinds of inheritance
18:07:41 <mib_gdgp0jci> test
18:07:56 <dons> objects though focus on not just that, but internal mutable state
18:08:01 <dons> which we don't nec. want to do.
18:08:07 <dons> ayu2008: i think its working :)
18:08:21 <gwern> 'There are "better" languages than Perl — hell, there are lots of them, if you define "better" as "not being insane". Lisp, Smalltalk, Python, gosh, I could probably name 20 or 30 languages that are "better" than Perl, inasmuch as they don't look like that Sperm Whale that exploded in the streets of Taiwan over the summer. Whale guts everywhere, covering cars, motorcycles, pedestrians. That's Perl. It's charming, really.' <-- hee hee.
18:08:33 <fnord[work]> gwern, how can something be reduced by 280%? Re: "Maximal laziness can give a nice performance improvement over a “traditional” implementation of sharing (Section 5), reducing the number of rewrite steps by 40% to as much as 280%"
18:08:39 <ayu2008> hi guys, why my winhugs post this error message? ERROR file:.\convert.hs:3 - Undefined variable "isPunctuation"
18:09:06 <ayu2008> did i forget to import something
18:09:13 <ayu2008> like import IO or something
18:09:18 <binrapt> Char.isPunctuation?
18:09:48 <Toxaris> @pl \x -> [y | y <- x] -- broken!
18:09:49 <lambdabot> return . ((y | y) <-)
18:10:30 <ziman> wow :)
18:11:45 <ayu2008> I loaded Char and it works
18:11:48 <ayu2008> :load Char
18:11:48 <gwern> fnord[work]: presumably the old runtime is defined in terms of the new
18:12:04 <dmhouse> Toxaris: nice. I guess it just thinks | and <- are operators
18:12:20 <gwern> 'Perl can't do lists because Larry made the tragically stupid decision early on to flatten them automatically. So (1, 2, (3, 4)) magically becomes (1, 2, 3, 4). Not that you ever want it to work this way. But Larry happened to be working on some problem for which it was convenient on that particular day, and Perl's data structures have been pure exploded whale ever since.'
18:12:30 <gwern> you can't do [[a]] in perl? wow, that is braindead
18:12:32 <paczesiowa> dons: oh yeah, I wasn't referring to state, but everything in OOHaskell still works outside IO (using fix instead of mfix as new) and maybe you get something nice back from whole library. anyway don't mind me, mostly I wanted to talk about HList/OOHaskell because it's rarely the main topic here
18:13:02 <xd> [[]] works
18:13:04 <Jedai> gwern: You can, using references
18:13:06 <ziman> you can do [RefTo [a]] in perl
18:13:07 <koninkje> gwern: actually, list flattening is useful all the time
18:13:19 <koninkje> gwern: and you can always do arrays of arrays...
18:13:39 <Toxaris> > fix ((2 :) . flip filter [3..] . (and .) . ap (map . flip flip 0 . ((/=) .) . mod) . flip (takeWhile . flip ((<) . join (*)))) -- not exactly nice, Myoma :(
18:13:41 <lambdabot>  [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,...
18:13:41 <gwern> 'Now you can't read a book or tutorial or PowerPoint on Perl without spending at least a third of your time learning about "references", which are Larry's pathetic, broken, Goldbergian fix for his list-flattening insanity. But Perl's marketing is so incredibly good that it makes you feel as if references are the best thing that ever happened to you. You can take a reference to anything! It's fun! Smells good, too!'
18:13:52 <Jedai> gwern: What are you reading that from ?
18:13:55 <Myoma> ty :)
18:13:55 <Toxaris> and not even correct :(
18:14:01 <ayu2008> hmm still have problem, i could not load my file into winhugs, it keep posting this inPunctuation error
18:14:12 <gwern> Jedai: yegge. I linked earlier
18:14:25 <ayu2008> http://www.mibbit.com/pb/GPU6bN
18:14:26 <lambdabot> Title: Mibbit: PasteBin
18:14:36 <Toxaris> > fix ((2 :) . flip filter [3..] . (and .) . ap (map . flip flip 0 . ((/=) .) . mod) . flip (takeWhile . flip ((<=) . join (*)))) -- not exactly nice, Myoma :(
18:14:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:14:41 <Toxaris> ahh better
18:15:06 <paczesiowa> @src isPunctation
18:15:06 <lambdabot> Source not found. My pet ferret can type better than you!
18:15:18 <ayu2008> mr lamb have a pet
18:15:34 <ayu2008> didn't know that
18:15:53 <paczesiowa> ayu2008: where did you get that isPunctation?
18:16:04 <Toxaris> ayu2008: do you have "import Data.Char" in your file?
18:16:10 <Toxaris> ayu2008: if not, try adding it :)
18:16:14 <ayu2008> ok
18:16:19 <paczesiowa> hugs has Data.Char?
18:16:22 <ayu2008> i did not have import Data.Char in my file
18:16:56 <paczesiowa> old Char module doesn't have that fun
18:18:12 <ayu2008> weird another error pops up after i add import Data.Char
18:18:26 <ayu2008> ERROR file:.\convert.hs:8 - Type error in final generator  *** Term           : map toUpper . filter (not . isPunctuation) $ s  *** Type           : [Char]  *** Does not match : IO a
18:18:48 <Toxaris> paczesiowa: http://cvs.haskell.org/Hugs/pages/libstatus.html
18:18:53 <lambdabot> Title: Hugs 98 and the Haskell Hierarchical Libraries
18:19:11 <koninkje> gwern: yegge doesn't seem to like any languages, eh? :)
18:19:25 <paczesiowa> he loves english, that's for sure
18:19:36 <gwern> koninkje: yegge rather likes javascript, C, and lisps
18:19:47 <Toxaris> ayu2008: well, that error tells you that your types not match. You're in a do statement (probably in your main, I guess?), but you entered an expression of type [Char], namely the map toUpper ... thing
18:20:01 <koninkje> gwern: There was a good deal of C- and lisp-bashing in there too
18:20:07 <Toxaris> ayu2008: you need something to make that [Char] into an (IO a), but the actual a doesn't matter
18:20:08 <Jedai> gwern: Well do you know Perl well ? Because after reading yegge prose I have to say it looks like this guy love Perl, which is why he hate it
18:20:23 <Toxaris> ayu2008: so you could use putStrLn to print it to the console
18:20:47 <Jedai> gwern: You have to have used Perl for years to really get its feeling there I think
18:20:54 <ayu2008> omg it works!
18:21:03 <Jedai> gwern: If not, you're missing on half the fun
18:21:07 <gwern> koninkje: compared to the others, those are lovetaps
18:21:11 <ayu2008> thanks Toxaris +_+
18:21:20 <Toxaris> why should I take someone serious who reads Powerpoints on Perl?
18:21:32 <gwern> Jedai: no, I don't know perl well. shell scripting put me off any language which claims to be at all inspired by it
18:21:47 <koninkje> gwern: well sure :)
18:22:09 <Jedai> gwern: Perl is inspired by a lot of stuff, most of the Perl I do don't look much like shell scripts
18:22:12 <fnord[work]> man do I hate yegge.
18:22:51 <koninkje> "It's all C++'s fault. Don't argue. It is. We're using the dumbest language in the world. That's kind of meta-dumb, don't you think?" /me chortles
18:23:58 <dmhouse> gwern: URL?
18:24:12 <koninkje> -> http://steve.yegge.googlepages.com/tour-de-babel
18:24:13 <lambdabot> Title: Stevey's Home Page - Tour de Babel
18:24:56 <dmhouse> Oh, that's on Reddit at the moment? It's old, though.
18:25:40 <ayu2008> hi dmhouse
18:25:50 <gwern> yegge doesn't write fast, so most yegge posts on reddit are old
18:25:52 <abbe> hi
18:25:54 <ayu2008> hmm just wandering
18:26:06 <ayu2008> are you all working people for haskell or something
18:26:42 <Twey> Yes
18:26:45 <Twey> All 443 of us
18:26:53 <Twey> We're employed by SPJ
18:26:54 <ayu2008> o_O
18:27:01 <Myoma> ayu :)
18:27:02 <ayu2008> what is a SPJ
18:27:04 <gwern> yes. we work in the Haskell center in Glasgow
18:27:06 <gwern> that's why we all use GHC
18:27:10 <Myoma> SPJ has 300 hp
18:27:10 <dmhouse> ?hoogle SPJ
18:27:10 <lambdabot> module Text.PrettyPrint.HughesPJ
18:27:15 <gwern> we have to support our masters
18:27:15 <dmhouse> Err...
18:27:19 <dmhouse> ?google SPJ haskell
18:27:21 <lambdabot> http://notes-on-haskell.blogspot.com/2007/08/more-spj.html
18:27:21 <lambdabot> Title: Notes on Haskell: More SPJ
18:27:22 <ayu2008> masters?
18:27:23 * gwern for one welcomes our new SPJ overlords
18:27:34 <dmhouse> ayu2008: SPJ is Simon Peyton-Jones, one of the authors of GHC
18:27:43 <ayu2008> oh thanks dmhouse
18:27:47 <dmhouse> And the editor of the Haskell report.
18:27:47 <FsCanHas4Kittehs> is there some mechanism for explicitly making a value lazy? (that is, remain symbolic until explicitly evaluated)
18:27:57 <FsCanHas4Kittehs> sorry if this doesn't make any sense :)
18:28:04 <paczesiowa> id
18:28:04 <ayu2008> no wonder you guys are really good at what you're doing
18:28:05 <Twey> Um, that's the default, FsCanHas4Kittehs
18:28:13 <ayu2008> is there such thing as haskell operating system?
18:28:19 <paczesiowa> house
18:28:23 <Twey> There is one, actually
18:28:24 <ayu2008> like windows operating system
18:28:27 <Twey> Er
18:28:28 <gwern> hops
18:28:33 <gwern> sel4, although that wasn't public iirc
18:28:34 <Twey> That would be 'written in Haskell'
18:28:40 <Twey> It's a bit hacky, though.
18:28:43 <paczesiowa> ?google house haskell
18:28:45 <lambdabot> http://programatica.cs.pdx.edu/House/
18:28:45 <lambdabot> Title: House
18:28:46 <Jedai> ayu2008: In case you didn't catch on, we don't work for SPJ here...
18:28:57 <FsCanHas4Kittehs> Twey: well, if I show an Int it is evaluated. I was thinking of showing just "Some Int" in that case, unless the user actually calls some eval function
18:29:04 <fnord[work]> iirc, isn't ~ for laziness, but it's never used since it's default. I was readin something like that in Hudak the other day.
18:29:10 <abbe> What is the significance of deriving(Show,Eq) in the code at http://paste.lisp.org/display/66110
18:29:11 * Twey twitches at House
18:29:11 <koninkje> dmhouse: no hyphen in his name
18:29:16 <fnord[work]> Maybe I forgot the actual operator
18:29:25 <ayu2008> Jedai: wait a minute, Twey mentioned all 443 people here work for the haskell company
18:29:28 <FsCanHas4Kittehs> I guess what I want is to simply replace a with () -> a
18:29:32 <Twey> House: 'Haskell User's Operating System and Environment'
18:29:34 <Twey> ayu2008: Yes
18:29:38 <dmhouse> koninkje: oh, sorry.
18:29:44 <Twey> That 443 people included you, in case you didn't notice
18:29:47 <koninkje> dmhouse: no worries :)
18:29:52 <Jedai> ayu2008: An you believed him of course... ^^
18:29:53 <fnord[work]> FsCanHas4Kittehs: (\x->x)
18:29:57 <Twey> Know it or not, you are now under the control of SPJ!
18:30:07 <Twey> Bow down!
18:30:07 <fnord[work]> FsCanHas4Kittehs: ((\x->x) a)
18:30:08 <abbe> I can't find any explanation of that in YAHT
18:30:31 <mib_gdgp0jci> test
18:30:47 <fnord[work]> > (\x -> x) 1
18:30:49 <lambdabot>  1
18:30:57 * Twey thinks.
18:30:59 <Twey> What year is this?
18:31:02 <ayu2009> weird i was disconnected by the system o_o
18:31:05 <Twey> 2008
18:31:09 <dmhouse> Twey: 2009, why?
18:31:10 <Twey> That's weird
18:31:17 <ayu2009> i could not use ayu2008, it says its been taken
18:31:20 <Twey> Heh, dmhouse
18:31:22 <FsCanHas4Kittehs> > let lazyint = ((const 1) :: () -> Int)
18:31:23 <Jedai> abbe: it automatically create instance of Show and Eq for the datatype (meaning you can do equality test on it and convert it to a String)
18:31:24 <lambdabot>  mueval: Prelude.read: no parse
18:31:29 <Twey> That's because ayu2008 is right here
18:31:41 <Twey> I wasn't talking about your name, I just honestly forgot what year it was for a moment.
18:31:42 <ayu2009> but the system said that im disconnected
18:31:54 <Twey> Ah, well, Freenode hasn't realised yet.
18:31:56 <Twey> Give it time.
18:32:08 <Twey> There you go.
18:32:18 <ayu2009> o_o
18:32:23 <Jedai> ayu2009: Yeah, IRC can be pretty screwy sometimes, Freenode still believe ayu2008 is here but in fact it disconnected you
18:32:27 <Twey> Oh, it was Mibbit that hadn't realised.  Well, anyway.
18:32:39 <FsCanHas4Kittehs> > (const 1) :: () -> Int
18:32:41 <Jedai> ayu2009: Your IP may have been changed by the FAI for example
18:32:41 <lambdabot>      Overlapping instances for Show (() -> Int)
18:32:41 <lambdabot>       arising from a use of `...
18:32:49 <ayu2009> anyways, could haskell make powerful programs like windows pc games or like microsoft word?
18:32:50 <FsCanHas4Kittehs> > (const 1) ()
18:32:52 <lambdabot>  1
18:32:57 <FsCanHas4Kittehs> that should work, no?
18:33:05 <Twey> ?faq Can Haskell whup ayu2009's ass?
18:33:05 <lambdabot> The answer is: Yes! Haskell can do that.
18:33:14 <Twey> It seems so, ayu2009.
18:33:17 <ayu2009> -_-
18:33:20 <Jedai> ayu2009: Yes
18:33:26 <Twey> Sorry.  Serious answers now.
18:33:38 <Jedai> ayu2009: And in a much lower amount of lines too
18:33:40 <ayu2009> where can i download some haskell programs to be installed to windows os?
18:33:48 <ayu2009> i want to try them out :)
18:33:53 <gwern> powerful programs like windows pc games == borderline trolling imo
18:33:59 <Twey> Yes, Haskell is Turing-complete with a foreign function interface.  It can do everything more common languages like C can.
18:34:13 <Myoma> gwern: Yeah who the hell would ever think games were worth programming
18:34:20 * Twey chuckles.
18:34:28 <abbe> Jedai, oh, okay. Thanks
18:34:30 <ayu2009> iborderline trolling imo ?
18:34:39 <Myoma> ayu2009: no, you're fine
18:34:42 <Jedai> ayu2009: What kind of program are you searching for exactly ?
18:34:45 <FsCanHas4Kittehs> ayu2009: I think the issue is that games are a lot of work, no matter which pl... you need artists, game designers and so on
18:34:55 <koninkje> Myoma: who would ever think they're not?
18:34:58 <MEme_> i got a question that probulally has nothing to do with this channel or even server but maybe some one can point me the right way... I am trying to reverse engineer a program and need a bit help
18:35:04 <dons> ayu2009: hackage.haskell.org is where you can find lots of fun haskell programs
18:35:09 <MEme_> any direction would be helpful...
18:35:15 <dons> ayu2009: and you'll need to start with haskell.org/ghc to get the compiler.
18:35:33 <shrughes> MEme_: then stop wasting our time
18:35:37 <Jedai> MEme_: go to another channel (Well you said any direction so...)
18:35:44 <dons> hmm. lots of unusual names in here atm.
18:35:48 <ayu2009> actually, i have not seen a website that provides programs that are made using haskell
18:35:53 <MEme_> Jedai, i was looking for something more specific lol
18:35:56 <FsCanHas4Kittehs> dons: I'm usually FunctorSalad ;)
18:36:01 <dons> ayu2009: visit hackage.haskell.org
18:36:05 <Twey> Oh ah
18:36:14 <MEme_> shrughes, any channel/server recomendation?
18:36:19 <Jedai> MEme_: Just look for desassemblers and spend some years studying
18:36:20 <ayu2009> thanks dons
18:36:24 <dons> MEme_: off topic here.
18:36:27 <ayu2009> i'll check it out now :)
18:36:34 <fnord[work]> Twey, turing completeness doesn't include computation deadlines, so turing equivalence doesn't mean two languages can do everything the other can do.
18:36:41 <MEme_> Jedai, ;)
18:36:56 <Myoma> fnord[work]; yawn :p
18:37:47 <fnord[work]> Myoma, well it matters if you're talking about games. :)
18:37:48 <Jedai> fnord[work]: I'm afraid I don't get your point there... If you mean some languages are slower on some things than other I don't think that affects what they "can do"
18:37:50 <Twey> Hmnhmnhmn.
18:39:07 <Jedai> fnord[work]: Haskell compiled by GHC is pretty fast, but for the bits where you need direct access to the machine or for your 3D engine you can always use C/C++ and use the FFI to bridge the gap and make the game core in Haskell
18:39:49 <Jedai> fnord[work]: Though you could theoretically do it all in Haskell, and it's becoming much more believable with the recent versions of GHC
18:39:51 <newsham> whats the syntax for re-exporting something that was imported?
18:40:09 <Jedai> newsham: module Machin ( module Truc, ...) where import Truc
18:40:15 <koninkje> newsham: you just export it by name
18:40:27 <newsham> ty
18:40:31 <koninkje> or, like Jedai says if you want to export a whole module
18:40:32 <fnord[work]> Jedai, "can do" sounds like it means calculating new positions for a scene graph >32 times a second. It might be possible in one language but runtime characteristics of another language [implementation] would affect whether this is possible. (This isn't about Haskell. Just me being picky)
18:41:28 <fnord[work]> er, sorry for the confused langauge in my first sentence there. I means "sounds like it includes" rather than "sounds like it means"
18:48:35 <Myoma> it seems like you can do log n access into an infinite list but it's not as elegant as I thought
18:49:00 <Myoma> it seems like you have to have a two level approach
18:49:35 <Myoma> so there's one tree which indexs into 1 2 4 8 ... and within each of those is a binary tree for the elements of each rangeao
18:49:47 <bd_> Myoma: How do you generate this structure?
18:49:56 <Myoma> actually I couldn't program that bit
18:50:02 <bd_> Converting from [a] -> LogNList a is O(n) at least
18:50:20 <Myoma> yes it's O(n) the first time, but next time around it will not be O(n)
18:50:36 <bd_> Myoma: It's still O(n), although possibly with a smaller constant
18:50:49 <Myoma> oh well is it Omega(log n) then?
18:50:50 <bd_> consider: let xs = makeInfList; quickAccess = makeSkipTree xs
18:51:04 <bd_> if you then access element 100 of xs
18:51:13 <bd_> that doesn'nt mean makeSkipTree sees up to element 100
18:51:23 <Myoma> is a skip tree something that already exists?
18:51:28 <Myoma> and I basically reinvented it
18:51:28 <bd_> although if you access it through quickAccess, I guess it'd work
18:51:33 <bd_> Myoma: I just made the term up
18:51:38 <bd_> someone else might've made the same term up, I guess :)
18:51:40 <Myoma> oh well it is a perfect name
18:51:45 <bd_> actually wait
18:52:00 <bd_> if you have the top level having pointers to offset=0, =1, =2, =4, =8, ...
18:52:08 <bd_> then some elements will still be O(n/2)=O(n)
18:52:15 <Myoma> I wanted to build this tree using continuation passing and it should only use tail
18:52:16 <bd_> eg, consider element 2^n-1
18:52:29 <gwern> »
18:52:30 <bd_> you'll skip to 2^(n-1), then skip forward another 2^(n-1)-1 elements
18:52:34 <bd_> walk forward even
18:52:41 <Myoma> hm yes
18:52:54 <bd_> you'd need a multi-level tree
18:52:58 <bd_> O(lg n) levels
18:53:21 <bd_> each indexing into the lower one
18:53:37 <bd_> you spend O(lg n) steps finding the right level, then another O(lg n) steps walking down what's effectively a perfect binary tree
18:54:10 <bd_> it's a bit like a skip list only since the list is infinite and static we can compute the ideal element orders deterministically
18:54:56 <bd_> Myoma: see http://en.wikipedia.org/wiki/Skip_list
18:54:57 <lambdabot> Title: Skip list - Wikipedia, the free encyclopedia
18:55:54 <bd_> Note that this approach requires cleverness on the type level
18:55:59 <bd_> order=0 list has type [e]
18:56:04 <bd_> order=1 has type [[e]]
18:56:04 <bd_> etc
18:56:41 <bd_> So the meta-list has to have something like data MetaList xs = MLCons xs (MetaList [xs])
18:57:23 <bd_> not sure how to iterate over that admittedly... :)
19:00:26 <bd_> you might need a custom list type too for the individual levels, so you can tell the difference between the held data type being [x] and the skiplists being [[x]] in a typeclass
19:05:16 <mmorrow> polymorphic recursion is always ftw
19:12:22 <Toxaris> data Fast tree a = Fast (tree a) (Fast (Fast tree) a)
19:12:38 <Toxaris> Myoma, bd_: something like this?
19:13:26 <koninkje> Toxaris: that's starting to look like fibonnaci trees
19:15:03 * Toxaris just looked up Fibonacci trees
19:15:11 <Toxaris> yeah I agree
19:15:49 <Toxaris> but I'm not sure if / how it is connected to what bd_ described / Myoma wants
19:16:42 <koninkje> (binomial trees are a simpler version of fib trees)
19:16:54 <koninkje> (maybe still of questionable relevance)
19:17:04 <Toxaris> data BD a = BD a (BD [a]) -- that's the one more list all the time idea?
19:20:13 <Toxaris> data Another a = Another a (Another (a, a))
19:20:35 <Toxaris> or maybe that one, a sequence of growing binary trees.
19:21:42 <Toxaris> the n'th value is in the (log n)' tree, at depth (log n), as envisioned by Myoma
19:22:36 <bd_> Toxaris: Can they be efficiently created from a [a]?
19:22:41 <bd_> which is the real question :
19:22:42 <bd_> :)
19:23:03 <Jedai> @src Sequence
19:23:03 <lambdabot> Source not found. stty: unknown mode: doofus
19:23:34 <Toxaris> well, obviously you need O(n) operations to process the first n elements of the list
19:23:41 <Jedai> @src Seq
19:23:41 <lambdabot> Source not found. You type like i drive.
19:24:00 <koninkje> @i Data.Sequence.Seq
19:24:00 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
19:24:10 <Toxaris> so what do you mean by efficiently?
19:24:23 <bd_> Toxaris: true, but further accesses should be done in O(lg n) time
19:24:46 <Toxaris> yeah, which e.g. the Another data type imho allows
19:25:05 <dons> shapr: do you know where that photo of spj on a unicycle is?
19:25:56 <Toxaris> the tree creation has to be lazy, so that access to the n'th value doesn't force values > n to be constructed or accessed or whatever
19:27:01 <Toxaris> actually, it should be enough if an access of the n'th value will only force the O(log n) first values but not more to remain in O(log n) for accessing the memoized tree
19:27:33 <Toxaris> so it would be ok to create a whole binary tree at once, as long as no trees to the right are created unrequested
19:27:50 <Toxaris> but maybe I'm missing some problem
19:30:41 <Jedai> I think we want something like :
19:31:23 <Jedai> data Tree a = Tree a a; data InfiniteTree = Inf a (Inf (Tree a))
19:31:51 <Jedai> (which is the same as Another, ok)
19:32:46 * bd_ has to go to sleep now :/
19:36:43 * Toxaris is coding get :: Another a -> Integer -> a right now
19:39:36 <shapr> dons: Yeah, on the #haskell facebook among other places.
19:39:42 * shapr boings
19:39:52 <shapr> Yay Haskell! w00!
19:40:23 <shapr> Man, I need some demo code for Network.CGI, I am soo out of practice with Haskell.
19:41:29 * cjb is creating a site in django at the moment.
19:52:08 * BMeph wonders if anyone's taken up CosmicRay's gautlet, concerning an IMAP parser in Haskell
19:53:23 * BMeph often wonders if cows think humans are weird for always eating their baby food...
19:55:28 * roconnor often wonders how they get those peanuts into their shells.
19:55:49 * fnord[work] kicks off his build of 1400 files on 4 different targets each.
19:56:48 <dons> shapr, Cale, anyone got better graphics skills than me at doing propaganda posters from photos? --> http://galois.com/~dons/images/tmp/hope.png
19:58:35 <dino-> dons: I made that deadline with my project at work that's using Haskell. We go really live Tuesday with it. And I did add this info about AT&T to the Haskell_in_industry page, thanks for suggesting.
19:58:49 <dons> wow. awesome!
19:58:57 <shapr> haha
19:59:10 <koninkje> sweet
19:59:22 <shapr> cjb: How do you like django?
19:59:29 <gwern> 'Comrades! Prove theorems together for the mother language!' 'The referential paradise is just ahead!' 'Remember, loose links sink projects!'
19:59:55 <fnord[work]> dons, the SPJ one HAS to say "Lazy"
20:00:04 <dons> or "Pure" or something.
20:00:16 <Toxaris> my shot at an infinite tree with O(log n) access: http://hpaste.org/10041
20:00:22 <dino-> I said something about this earlier, but I'll say it again. Thank you all for tremendous help and patience over the past couple of years. I would not have been able to do this without you.
20:00:26 <dons> i'm not sure how best to do the colourising though, from the original greyscale
20:00:28 <gwern> 'Programmers of all countries, unite! You have nothing to lose but your states'
20:00:35 <fnord[work]> er, white guy with "Pure" on him, next to a black guy... not very tasteful in the US
20:01:00 <shapr> dons: You should do the Che poster.
20:01:01 <dons> oh, i'm not suggesting putting the two on the same thing.
20:01:12 <gwern> 'JDH: I will crush lazy Haskell in my fist!!!'
20:01:25 <shapr> John Hughes?
20:01:52 <gwern> 'With shock programming we will ensure prompt delivery of the Five Year Haskell Batteries!'
20:02:15 <solrize> "strict" hughes and "lazy" spj???
20:02:22 <gwern> '#haskell is the crack brigade of the world's FPers'
20:02:40 <gwern> 'Long live the great Wadler!'
20:02:53 * gwern steals shamelessly from http://www.iisg.nl/exhibitions/chairman/sovintro.php
20:02:55 <dons> i just think the old spj photo has that same "hope for the future" thing in his eyes.
20:03:01 <lambdabot> Title: Soviet Posters
20:03:01 <gwern> imo, Wadler should == Stalin
20:03:04 <gwern> two syllables
20:05:06 <dons> http://farm2.static.flickr.com/1247/540924826_0dbcd2d87f.jpg
20:05:27 <dons> you could do a series of stalin-style "updates" to history
20:05:37 <dons> with wadler leaving for java generics, and hughes wandered off to erlang.
20:06:20 <gwern> is that what happened to hughes?
20:07:40 <Toxaris> http://www.quviq.com/news071108.html
20:07:49 <lambdabot> Title: John Hughes "Erlang user of the year"
20:07:56 <dino-> I saw something a few months ago, proposed syntax for doing closures with Java generics. I thought it looked a bit evil.
20:08:34 <Myoma> closures in java
20:08:39 <Myoma> closures in <functional language>
20:08:49 <Myoma> one of these options is stupid and pointless...
20:08:54 <dons> gwern: he ported quickcheck to erlang and made a startup out of it.
20:09:02 <gwern> no! erlang has stolen quickcheck? THOSE BASTARDS
20:09:19 <dons> well, it all came out of chalmers.
20:09:28 <koninkje> Myoma: for those who are stuck with <non-functional language> closures are *very* nice
20:09:32 <dons> the swedish guys have been doing haskell & erlang stuff for ages
20:09:43 <gwern> ...a startup just out of quickcheck? wow, and here I've been so unappreciate of quickcheck
20:10:02 <Myoma> being stuck with a language but it's ok to write bizarre non-idiomatic code seems like a very odd situation
20:10:36 <Toxaris> Myoma: Aren't anonymous inner classes the "java closures"? they are quite natural and very handy
20:10:57 <koninkje> Since when are closures non-idiomatic?
20:11:00 <Toxaris> Myoma: by the way, what do you think about my tree?
20:11:09 <dons> gwern: time to appreciate quickcheck.
20:11:33 * gwern will go and appreciate with qc2 comes out maybe
20:11:36 <Myoma> Toxaris: does it work ?
20:11:57 <shapr> gwern: It's been around for two years or so.
20:12:07 <Toxaris> Myoma: I have not understood your exact performance and laziness expectations
20:12:08 <shapr> Both QC2 and quviq
20:12:11 <Toxaris> Myoma: so I don't know
20:12:26 <Myoma> well I think that is great
20:12:40 <dino-> Toxaris: I'm having problems remembering specifics, but I don't think anon inners really do it.
20:12:56 <gwern> shapr: sure, but there's been no official release AFAIK
20:13:04 <Myoma> dino-: they do close over variables
20:13:16 <shapr> The qc2 darcs repo has been available for quite some time.
20:13:26 <dino-> Something about scope, I wish I could find something on the web about this quickly..
20:13:29 <Toxaris> dino-: I have no clue how that is implemented, but they do close over variables somehow
20:14:15 <koninkje> Toxaris: they only close over "final" variables
20:14:39 <dino-> mm, this talks about it: http://fishbowl.pastiche.org/2003/05/16/closures_and_java_a_tutorial/
20:14:44 <Toxaris> koninkje: well, the same can be said of Haskell closures :)
20:14:45 <lambdabot> Title: Closures and Java: a Tutorial - The Fishbowl, http://tinyurl.com/5uecr6
20:15:00 <koninkje> which means the joyous array-of-one hack if you need to have your inner class mutate the var
20:15:04 <shapr> gwern: Yeah, I think you're right, it's not official.
20:15:23 <koninkje> Toxaris: yes, but Haskell has the assign-once mentality; Java, not so much
20:15:56 <shapr> Java has the assign after every class...
20:16:28 <Myoma> inner classes close over anything
20:16:29 <Toxaris> koninkje: well, so you need class Box<A> { public A a }
20:16:32 <koninkje> Also Java's memory usage is a horror to behold, so mutating objects is much better than Haskell's cheap object creation
20:16:33 <Myoma> not just final vars
20:16:42 <shapr> And I mean that in the sense that, after class... you get your assignment!
20:16:55 <Toxaris> shapr: :)
20:17:15 <koninkje> s/inner/anonymous/
20:17:40 <dons> huh, ghc really stomps on java wrt. memory, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=javaxx&lang2=ghc
20:17:42 <lambdabot> Title: Java 6 -Xms64m benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Bench ..., http://tinyurl.com/5s3q8o
20:17:53 <koninkje> dons: oh very much :)
20:17:55 <Toxaris> Java: An artifically verbose object-oriented language mainly used teaching students how not to program.
20:18:10 <Myoma> koninkje: Do you only refer to anonymouse inner classes?
20:18:14 <shapr> Crap, what's the undefined trick? I'm porting some old code and I'm trying to figure out what this one chunk should be doing...
20:18:15 <Myoma> wrt. final
20:18:29 <Myoma> shapr: foo x y z = bar ; bar = undefined foo ... ?
20:18:42 <shapr> ah
20:18:45 <Myoma> to get :t bar to say something slightly more useful
20:18:49 <koninkje> Myoma: I'm referring to attempts to capture the pattern of closures in Java
20:19:06 <shapr> Much better!
20:19:16 <Myoma> koninkje: You can have an inner class mutate variable of the class it's defined in though
20:19:19 <koninkje> Myoma: yeah, i think the final thing is only for anonymous classes
20:19:23 <Myoma> ah ok
20:19:46 <Toxaris> what about local classes?
20:20:02 * Toxaris tries to remember Java obscurities never used by anyone
20:20:07 <Myoma> public class Bar { Foo e; int x; class Foo { void pop() { x++; } } ... } // is fine
20:20:11 * shapr hugs Myoma
20:20:28 <Myoma> shapr, *hug* :p
20:20:38 <Myoma> it is 04:20
20:20:47 <shapr> Don't feel like sleeping?
20:20:53 <shapr> It's only 23:20 here.
20:21:09 <shapr> I've got Monday off, there will be much code!
20:22:56 <koninkje> As the years go by I'm beginning to agree more and more with Bart's take on OOP
20:23:06 <shapr> Who? What did he say?
20:23:20 <koninkje> something about them being a big pile of fail :)
20:23:21 <Myoma> the one I like is
20:23:22 <Myoma> ?go dreamsongs why objects failed
20:23:28 <Myoma> maybe that'' the same ?
20:23:28 <lambdabot> http://www.dreamsongs.com/Essays.html
20:23:28 <lambdabot> Title: Dreamsongs Essays Downloads
20:24:04 <dino-> Oh, I see now (after painful reading). The enclosed things from outer scope have to be final. :/
20:24:16 <koninkje> This doen't really cover much of it: http://groups.google.com/group/pdxfunc/browse_thread/thread/a143f3b543f16876
20:24:18 <lambdabot> Title: SUMMARY: Monday, August 11 - pdxfunc | Google Groups, http://tinyurl.com/6bq2zv
20:24:20 <shapr> dino-: But you can get around that, I think.
20:24:33 <Myoma> I found java a really nice language to use :S
20:24:44 <shapr> iirc, you can mutate a final array or something. I know there's an unexpected trick to it. I've done it before, long years ago.
20:24:51 <koninkje> class Fail { final Object[] = { new Object() }; ...}
20:25:00 <dino-> shapr: evil
20:25:04 <shapr> Yay, it built!
20:25:11 <shapr> dino-: I don't remember the actual trick though :-/
20:25:12 <koninkje> Myoma: well it's certainly better than C++
20:25:17 <Myoma> yes!
20:25:21 <dino-> shapr: We shall never speak of this again.
20:25:21 <shapr> Now to see if the unit tests still work...
20:25:28 <shapr> dino-: Why not?
20:25:32 <dino-> :P
20:25:59 * koninkje wishes he were actually there to hear Bart ranting to a room of functional programmers
20:26:15 <shapr> One thing I like about both Haskell and Python is that they don't have 'rules' so much as suggestions. If you want to go through and change everything, that's your right.
20:26:21 <shapr> Java on the other hand...
20:26:23 <shapr> Oh, and C#
20:26:54 <shapr> At work last week, we couldn't ship a particular piece of software because the commercial email sending plugin couldn't find its license key if the DLL was in a non-standard location.
20:27:21 <fnord[work]> haha
20:28:16 <gwern> so commercial = fail, is the lesson?
20:28:34 <shapr> Maybe.. but I think restriction == fail is more what I see.
20:29:09 <adu> shapr! how did the hhpaste thing go?
20:29:11 <fnord[work]> you're not using existing free libraries with amenable licenses?
20:29:36 <shapr> adu: I got it all to work again, finally.
20:29:47 <shapr> Thanks for doing the backup though!
20:29:52 <adu> :)
20:29:58 <shapr> I'm tempted to whip up an hpaste search.
20:30:21 <shapr> on the other hand, how much of the content has a license?
20:30:41 <adu> shapr: I'm surprised my hpaste "my super numeric prelude" is one of the top google hits when searching for "numeric prelude"
20:30:50 * shapr is resurrecting the old fermat's last margin code from 2004
20:31:19 * Myoma probably has left lots of strange code on hpast
20:31:20 <adu> shapr: I would assume all of it is public domain
20:31:42 <shapr> adu: If it has no explicit license, the assumption is that it's all rights reserved.
20:31:55 <shapr> We previously hit this same problem on the two previous versions of the Haskell wiki.
20:32:04 <shapr> The PreludeExts from the old wiki were great!
20:32:25 <Myoma> m
20:32:26 <shapr> I'd still like to have a #haskell PreludeExts
20:32:27 <shapr> n
20:32:29 <Myoma> I may make my own prelude
20:32:32 <Myoma> I started to acutally
20:33:00 <Myoma> it's mostly all the destructors and folds that aren't around by default
20:33:00 <shapr> So, put it online!
20:33:04 <adu> Myoma: I like some parts of the current numeric prelude, but I really don't like the Something.C convention
20:33:22 <Myoma> I also tried to make my own numeric stuff but my skill with typeclasses aren't high enough
20:33:35 <koninkje> adu: As shapr says, if there's no explicit licence then it's All Rights Reserved
20:33:38 * shapr boings cheerfully
20:34:01 <adu> well I give you explicit license to use http://hpaste.org/7891 as if it were public domain
20:34:08 <shapr> Thing is, hpaste was not meant as a collaboration tool, but it has become that.
20:34:18 <shapr> So, I think we need an explicit collaboration tool!
20:34:24 <shapr> But what?
20:34:48 <shapr> Isn't there a some sort of network filesystem that's freely read/write by all networked participants?
20:34:51 <shapr> That would be nifty.
20:34:52 <gwern> darcs
20:35:08 <shapr> gwern: Yeah, but that's not so good for paste-style collab... is it?
20:35:15 <adu> shapr: nfs?
20:35:22 <Myoma> zipper FS!
20:35:25 <shapr> hah!
20:35:29 <shapr> adu: Doesn't work on windows?
20:35:32 <Toxaris> adu: my hpaste are *not* public domain, why should they? because they are public?
20:35:47 <adu> shapr: I remember hearing that anyone who worked at bell labs was cool ... unless they worked on NFS...
20:35:50 <shapr> heh
20:36:50 <solrize> http://www.cafepress.com/cp/customize/product.aspx?clear=true&number=%20291121043  java fail
20:36:52 <lambdabot> http://tinyurl.com/5kk7rf
20:36:55 <gwern> NFS came in for particular opprobium in The Unix-Haters Handbook... I was impressed at the avid animadversions in its NFS chapter
20:37:18 <shapr> solrize: That's evil.
20:37:22 <solrize> hehe
20:37:22 <shapr> I LIKE IT!
20:38:16 <shapr> I still haven't found any website that will let me print my own magnetic poetry :-(
20:38:21 <shapr> I want to print #haskell poetry
20:38:42 <shapr> Like, suck out all the hpaste code entries, figure out the most common symbols/functions, and print up a bunch of them.
20:38:55 <gwern> @quote poetry
20:38:55 <lambdabot> shapr says: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
20:38:56 <koninkje> solrize: how long do they cache the customized designs for?
20:39:01 <shapr> gwern: Exactly!
20:39:18 <solrize> i dunno, that one is a few weeks old.  why would they ever flush them, if someone might buy one?
20:39:32 <gwern> ...wow, that is appropriate
20:39:33 * koninkje just didn't know if they would
20:40:06 * BMeph still wants a "HASKELL   it works, bitches." T-shirt
20:40:12 <solrize> lol
20:40:37 <fnord[work]> Has anyone considered hosting something like Scheme in Haskell? A lot of schemes implementations compile down to C.. but I think Haskell would be more amenable to the memory model.
20:40:40 <gwern> I want the mccarthy motivational poster on a t-shirt - 'ur doing it wrong'
20:41:00 <Twey> fnord[work]: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:41:02 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
20:41:34 <fnord[work]> Twey: thanks. I saw that, but I didn't think it was a serious attempt at a Scheme implementation. Just a tutorial on parsing and interpretation.
20:41:45 <Twey> Pretty much, aye
20:42:23 <Toxaris> fnord[work]: "more amenable to the memory model" means that you want to reuse the ghc runtime?
20:43:28 <fnord[work]> Toxaris: yes. In fact, I was day dreaming about an SExpressionMonad
20:44:24 <Toxaris> unsafeEvaluateScheme "call/cc" (\k -> k 42)
20:44:27 <solrize> lots of the ghc runtime is devoted to graph reduction, which would be useless for scheme
20:44:41 <solrize> lots more of it i think relies on immutability that scheme doesn't promise
20:44:54 <fnord[work]> which is why it would be in a monad
20:45:54 <solrize> yeah, it could be made to work, it just isn't that great a fit to the ghc runtime
20:46:00 <fnord[work]> k
20:46:09 <solrize> like, you can write imperative fortran-like programs in the io monad but they would suck
20:46:23 <fnord[work]> but that's how i code haskell
20:46:37 <fnord[work]> (jk)
20:47:12 <solrize> who put up that graham url and why?  it's the usual stuff afaict
20:49:52 <solrize> hmm is there a way to get a statically linked binary from ghc?
20:50:18 <solrize> http://www.nabble.com/How-to-produce-a-statically-linked-binary-with-GHC--td18951212.html  aha
20:50:25 <lambdabot> Title: Nabble - Haskell - Glasgow-haskell-users - How to produce a statically linked bi ..., http://tinyurl.com/6syuys
20:50:34 <dons> solrize: -optl-static
20:51:07 <ddarius> dons: The Java is winning speed-wise in most of those.
20:51:12 <fnord[work]> I thought ghc did it by default
20:51:45 <dons> ddarius: yep.
20:52:00 <dons> fnord[work]: haskell libs are statically linked by default. not the C deps on the runtime
20:52:17 <solrize> dons, thanks, i did that and i get a tone of undefined references, like there's some other lib i have to supply
20:52:33 <solrize> i guess i better read the rest of that thread
20:54:13 <solrize> aha, -opl-static -optl-pthread  did it
20:54:58 <solrize> hmm still doesn't execute on the remote system
20:55:26 <fnord[work]> run ldd and find out what .sos are missing
20:55:47 <solrize> it's statically linked
20:55:55 <solrize> $ ldd ~/phrase
20:55:55 <solrize> 	not a dynamic executable
20:56:44 <solrize> hmm it looks like there's some prob with ghc 6.8.2 which i'm still running... i guess i should upgrade
20:57:50 <fnord[work]> yes, but it will still require the core runtimes. (but i dont know anything about your systems, so ill shut up now)
21:02:56 <dons> fnord[work]: ?
21:03:04 <dons> the runtime is statically linked
21:09:58 <solrize> ohhhhh   nevah mind
21:11:30 <solrize> works now.
21:12:10 <solrize> thanks
21:17:20 <fnord[work]> dons, I just mean that it will still require stuff like librt.so libc.so, etc.
21:19:10 <solrize> fnord, the static link with -optl-pthread worked fine, the problem was i compiled on a 64 bit box and tried to run the image on a 32 bit box
21:26:31 <solrize> dons do you ever think of putting a wiki or bbs-like system on the hackage page, so people can add comments?  that works stupendously well for php.net and the python developers have been envying it for years
21:27:03 <dons> yes. we want to do that (allow links, notes etc. for each library)
21:27:04 <fnord[work]> winedb does this as well, which is good for troubleshooting
21:27:08 <dons> arch does a similar thing.
21:27:15 <solrize> cool
21:27:24 <koninkje> dons: Is there anything we can do to help?
21:27:26 <dons> dcoutts and Lemmih are writing it, and we've a prototype at galois too.
21:28:17 <dons> something like this, for example,
21:28:18 <dons>  http://aur.archlinux.org/packages.php?do_Details=1&ID=17458&O=&L=&C=&K=&SB=&SO=&PP=&do_Orphans=&SeB=
21:28:20 <lambdabot> Title: AUR (en) - haskell-puremd5, http://tinyurl.com/6epmyq
21:28:57 <solrize> nice
21:30:17 <newsham> > fst $ random (mkStdGen 1) :: Word16
21:30:18 <lambdabot>      No instance for (Random Word16)
21:30:18 <lambdabot>       arising from a use of `random' at ...
21:30:20 <newsham> > fst $ random (mkStdGen 1) :: Word8
21:30:22 <lambdabot>  81
21:30:27 <newsham> boo.. why no Word16 instance?
21:30:45 <Twey> Write one
21:31:01 <koninkje> patches++
21:31:25 <solrize> arch looks nice.  the big distros are getting lamer and lamer about keeping stuff working, as they try to be more windows-like in operation
21:31:39 <Twey> 'Big distros' = Ubuntu
21:32:00 <dons> yeah, arch is more like a wiki. push to fix, pull to update.
21:32:45 <solrize> twey, ubuntu and fedora both seem to be going that route
21:33:01 <Twey> Ehwhat?  Fedora is?
21:33:12 <koninkje> formrly RedHat
21:33:13 <Twey> Surely not
21:33:25 <solrize> yeah
21:34:35 <solrize> in most regards i like it better than ubuntu anyway, at least in the old versions i use at home.  but we use ubuntu where i work, so the path of least resistance for me is probably to run it on everything. :(
21:43:44 <abbe> what is the purpose of '|||' operator, I'm seeing this frequently in xmonad documentation ?
21:43:44 <solrize> arch doesn't run on the via c3?  hmm.  i think we have a lot of those here.
21:43:58 <Olathe> @src (|||)
21:43:58 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:44:01 <Twey> abbe: Isn't it xmonad-specific?
21:44:02 <solrize> won't run on pentium mmx either
21:44:04 <solrize> sigh
21:44:10 <abbe> Hmm.., okay
21:44:21 <abbe> Thanks Twey I'll ask in #xmonad
21:44:23 <Olathe> solrize: What is that ? 1995 ?
21:44:32 <mmorrow> andyjgill: i think HERA's really cool. are you planning on doing anything more with it and/or along those lines?
21:44:51 <dons> solrize:  that sounds odd...
21:44:59 <solrize> we have a lot of servers built using via set-top processors but i dunno if they're c3
21:45:12 <dons> i've used c3s in the past (with openbsd). lots of nice, quiet fun.
21:45:14 <solrize> dons i suspect they're compiling using sse2 instructions
21:45:22 <solrize> which i guess are missing from the c3
21:45:23 <dons> ah maybe. for the user land packages.
21:45:31 <dons> so the stock i686 binaries won't fly.
21:45:39 <solrize> i still have a couple pentium mmx laptops at home
21:45:49 <andyjgill> Hi mmorrow
21:46:40 <andyjgill> Yes. I'm hoping to work on it this fall. There are various libraries/packages that can be released from decomposing it.
21:46:42 <mmorrow> andyjgill: hi
21:46:48 <andyjgill> As well as the tool itself.
21:47:57 <andyjgill> Its bitrotted right now, though - does not build in 6.8, as we found out last week.
21:49:19 <mmorrow> andyjgill: cool! most definitely. i've been working on a haskell quasiquoter (using the new -XQuasiQuotes) which has to translate from haskell-src-exts syntax to TH syntax, and reading the HERA code got me up to speed on how to go about that. can't wait til 6.10 comes out and everybody has -XQuasiQuotes :)
21:50:33 <andyjgill> Great. Sounds interesting.
21:51:02 <andyjgill> I'm hoping, at dons suggestion, to write an ascii based interface for HERA as well.
21:52:43 <mmorrow> that'd be most excellent. it'd be handy to be able to pipe in some haskell src, then get info like freevars, <insert-something>, etc
21:55:20 <mmorrow> err, saying that another way, i think it'd be really nice to have tools to extract information from and perform transformations on haskell code
21:56:04 <mmorrow> (which are lightweight and accessible)
22:01:14 <andyjgill> Yes, it will be good to make transforming Haskell code easier.
22:05:18 <mmorrow> andyjgill: i managed to get the example in example/ running under 6.9 (which should work under 6.8.* i think), but how i did it is slightly hackish because i don't really know how it's intended to work. i could send a patch if you'd like.
22:05:26 <mmorrow> damn
22:10:30 <mmorrow> those vias have hardware aes, right?
22:11:53 <mmorrow> hmm, looks like they have hardware SHA-1 and SHA-256 as well
22:14:02 <mmorrow> whoa
22:14:05 <mmorrow> "The VIA PadLock RNG uses random electrical noise on the processor chip to generate highly random values at an extremely fast rate. It provides these numbers directly to security applications via a unique x86 instruction that has built-in multi-tasking support."
22:14:41 <shapr> Sounds suspicious to me...
22:15:35 <mmorrow> heh
22:16:37 <mmorrow> they've got all kinds of crap integrated into the proc http://www.via.com.tw/en/initiatives/padlock/hardware.jsp
22:16:39 <lambdabot> Title: VIA PadLock Security Engine - VIA Technologies, Inc.
22:22:39 <solrize> they did a good job of the crypto stuff, according to paul kocher
22:29:49 <mmorrow> i bet the hardware aes makes the overhead of an encrypted disk almost zero
22:32:04 <b\6> was glad because i heard recently a court held that some guy wasn't required to divulge his encrypted disk passphrase. covered under the 5th.
22:32:33 <b\6> (sorry @ us-centric)
22:35:12 <Twey> Hooray for plausible deniability
22:36:37 <mmorrow> b\6: that's a very nice thing to hear
22:36:39 <b\6> i just ran into a newsgroup called alt.flame.montgomery-wood.aardvark-face.\xD9\xF2\xEF0ĕ\xED.\xD5\xCB\xD0nr\xCE\xC5\xDF\xF0\xCB.\xEE\xCB\xD5-.y\xC9\xC8\xCE\xE1\xCD\xD4\xFF\xCC\xCF\xEB\xD4\x9A\xFF\xC9h.
22:36:55 <mmorrow> lol aardvark-face
22:36:59 <Twey> Hahahahaha
22:37:47 <b\6> some other newsgroup names have \b, backspace, in them.
22:38:32 <mmorrow> heh, i'd put a bunch of \a chars in mine
22:39:21 <Olathe> > "\b"
22:39:22 <lambdabot>  "\b"
22:39:30 <b\6> might not be possible since nobody's done it in ~109000 groups.
22:39:44 <mmorrow> > error (repeat '\b')
22:40:06 <mmorrow> b\6: heh
22:40:07 <Olathe> > error (take 8 (repeat '\b'))
22:40:11 <lambdabot>  mueval: Prelude.read: no parse
22:40:12 <lambdabot> mueval: *** Exception: 
22:40:26 <Olathe> > (error.error) (take 8 (repeat '\b'))
22:40:28 <lambdabot>  mueval: Prelude.read: no parse
22:40:28 <lambdabot> mueval: 
22:40:37 <mmorrow> haha
22:41:04 <mmorrow> > (error . error.error) (take 40 (repeat '\b'))
22:41:06 <lambdabot>  mueval: Prelude.read: no parse
22:41:06 <lambdabot> mueval: 
22:41:31 <chrisdone> oh god i can see forever @_@
22:43:20 <mmorrow> have you gone on a vision quest?
22:43:43 <b\6> dibs on hercules beetle for spirit animal.
22:44:17 <dons> heh
22:44:21 <b\6> <3.
22:45:10 <b\6> hopefully i don't have to roll up poop by walking backwards for 3 miles. :(
22:45:26 <dons> for those who give talks, but don't like wonky projectors,
22:45:27 <dons>  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/testpattern-0.1
22:45:33 <lambdabot> Title: HackageDB: testpattern-0.1, http://tinyurl.com/65p6tn
22:45:57 <mmorrow> ?google wonky
22:45:58 <lambdabot> No Result Found.
22:46:26 <dons> you know, a bit skewhiff
22:46:56 <chrisdone> what top-level module category can I put Lojban modules under?
22:47:00 <dons> Language.*
22:47:09 <b\6> cool.
22:47:20 <b\6> @ lojban.
22:47:22 <chrisdone> ok, good, I thought that was specific to programming languages. thanks
22:47:35 <mmorrow> that must be kinda like skibbleguff
22:47:53 <chrisdone> skibbleguf
22:47:55 <chrisdone> ?
22:48:10 <mmorrow> chrisdone: back from your hallucinatory quest so soon?
22:48:25 <mmorrow> <dons> you know, a bit skewhiff
22:48:30 <mmorrow> <mmorrow> that must be kinda like skibbleguff
22:48:45 <chrisdone> ahh
22:48:49 <mmorrow> ;)
22:48:52 <b\6> whose slang is that? australia?
22:48:53 * chrisdone /= payingAttention
22:49:33 <mmorrow> chrisdone: maybe start a "Natural Language" one?
22:49:41 <b\6> but it's not natural.
22:49:41 <chrisdone> b\6: shh. mmorrow is from new zealand, they hate it when you lump them in one category
22:49:45 <b\6> sorry.
22:49:51 <mmorrow> BASTARDS!
22:49:51 <b\6> didn't mean offense.
22:50:10 <mmorrow> new zealand is by greenland, right?
22:50:10 <chrisdone> i maek joke
22:50:15 <chrisdone> mmorrow: what would tha tlook like?
22:50:22 <chrisdone> NatLang.Foo?
22:50:34 <fnord[work]> zealand is in holland
22:50:35 <chrisdone> and yes, as b\6 says, it is indeed a /constructed/ language...
22:50:50 <mmorrow> oh, maybe Language.Natural.Foo
22:50:58 <fnord[work]> Denmark, sorry
22:50:58 <chrisdone> mmorrow: oh, that would be a good one
22:51:44 * BMeph thinks "skibbleguff" sounds a bit...whomperjawed
22:51:45 <dons> btw, gtk2hs rocks.
22:51:58 <Capso> huh?!
22:52:10 <Capso> dons: What is the purpose of that?
22:52:38 <mmorrow> but Lojban would be considered a Natural language as opposed to a Computer/Formal/whatever language?
22:52:59 <b\6> should be filed under spoken.constructed or something.
22:53:01 <chrisdone> typically it's called a constructed language (or “conlang”), as opposed to a natural language
22:53:15 <BMeph> Okay, this is a fun one - has anyone ever seen this message when installing cabal-install:
22:53:17 <mmorrow> ah, i see
22:53:20 <BMeph> Warning: Unable to strip executable 'cabal.exe' (missing the 'strip' program)
22:53:28 <mmorrow> haha
22:53:38 <dons> Capso: ?
22:53:43 <stepcut> BMeph: do you have strip.exe installed ?
22:53:47 <Capso> 'gtk2hs'
22:53:56 <Capso> What is it?
22:54:01 <dons> haskell.org/gtk2hs
22:54:03 <chrisdone> it converts GTK code to haskell code
22:54:06 <dons> best haskell graphics lib.
22:54:11 <fnord[work]> BMeph, strip is a linux/unix command to remove symbols from executables. I'm not sure what the Windows equivalent is.
22:54:11 <BMeph> stepcut: Since I've never heard of strip.exe, I doubt it. :)
22:54:14 <dons> chrisdone: hmm, not really how i'd put it.
22:54:30 <fnord[work]> s/remove symbols/remove debugging symbols/
22:54:32 <stepcut> BMeph: removes debug symbols from binaries, making them smaller.
22:54:34 <chrisdone> dons: hehe, just joking. I'd bet that's how Capso read it
22:55:07 <chrisdone> definitely a great library
22:55:10 <Capso> chrisdone: No. I did not try to make any guesses.
22:55:31 <Capso> If I found that definition to be sane, then I would not have said anything about it!
22:56:00 <stepcut> BMeph: cabal does that by default. (It is standard pratice on almost all Linux distros)
22:56:01 <BMeph> Hmm, found it on the first try - right in the MinGW/bin directory. Now to find out why the comp isn't finding it...
22:56:28 <Capso> BMeph: GHC in Windows, under cygwin?
22:59:43 <BMeph> Capso: No, I'm a MinGW fan. I figure that Cygwin is for people who can't decide whether to be in Windows or *nix. When I'm in one environment or the other, I like to know at a glance which one I'm in.
23:00:13 <BMeph> Anyway, I just re-did the configure/build/install cycle, and it worked this time. :)
23:01:25 * BMeph is now trying to recall all of the packages he's installed on the box at work...
23:02:19 <mmorrow> if you can access it remotely, just grab it's package.conf
23:06:35 <BMeph> mmorrow: If the box were on, I'd think about doing that... ;)
23:07:30 <Twey> (he wouldn't actually do it, though... too lazy)
23:07:31 * BMeph 's  company frowns on equipment being left on over three-day weekends
23:07:54 <Twey> It's the weekend, why are you bothering about it?  :-P
23:07:59 <BMeph> Twey: I do not understand... "too lazy"? What's that mean? ;)
23:08:10 <Twey> Haha
23:08:20 <Twey> Just kidding about how you only said you'd *think* about doing it
23:08:25 <Twey> Rather than actually doing it :-P
23:22:31 <chrisdone> how do you specify -O2 in cabal without getting the annoying “ho ho, I don't think you need that.” warning?
23:23:31 <chrisdone> on hackage
23:25:57 <dons> there's no way, deal with the upload warning :)
23:29:44 * chrisdone cries
23:30:07 <chrisdone> lambdabot: who is your maintainer today?
23:38:21 <lambdabot> I am beholden to no man!
23:39:18 <chrisdone> haha, I laughed at the delayed reaction
23:49:57 <dcoutts> BMeph: that warning about strip is gone in the latest release. Windows systems are usually missing strip so there's no point warning.
23:49:57 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:51:34 <BMeph> dcoutts: Thanks. No, it seems that I was using a mingw that I had installed without telling this system. Once I added the directory into my search path, it started right up.
23:51:49 <BMeph> dcoutts: Now if only curl would be so accomodating... ;)
23:52:49 <dcoutts> BMeph: the strip is optional anyway
23:53:12 <dcoutts> @seen gwern
23:53:12 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 3h 12m 31s ago.
23:54:00 <dcoutts> gwern: I'm confused by those macro redefine errors, can you give me instructions on how to reproduce it? or better yet file a ticket with the instructions
23:54:13 <dcoutts> @tell gwern I'm confused by those macro redefine errors, can you give me instructions on how to reproduce it? or better yet file a ticket with the instructions
23:54:14 <lambdabot> Consider it noted.
23:55:04 <dons> dcoutts: is this the correct way to use datafiles, and or, load images into a gtk app, http://code.haskell.org/~dons/code/testpattern/Main.hs ?
23:55:23 <dons> i install a test pattern image, and the app loads it into a window (for calibrating projectors)
23:55:42 <dons> using Paths_* to find the datadir
