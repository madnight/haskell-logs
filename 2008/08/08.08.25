00:11:16 <binrapt> I'm having IO type drama: http://hpaste.org/9909
00:12:00 <binrapt> Is it possible to modify get_random_number to return a random number without having to use the result with do/let?
00:12:56 <binrapt> I know that there are better ways of generating lists of random integers, I'm just doing this to understand it
00:13:14 <BeelsebobWork_> well, first things first
00:13:29 <BeelsebobWork_> it Haskell it's traditional to use camelCase -- but that's just us lot, so feel free to do what you like
00:13:48 <binrapt> Right
00:13:49 <BeelsebobWork_> secondly though -- your getRandomNumber function doesn't actually do anything more than randomRIO (1,100)
00:14:08 <BeelsebobWork_> i.e. it could be written as getRandomNumber = randomRIO (1,100)
00:14:29 <BeelsebobWork_> thirdly -- there's no need for that let binding at all
00:14:38 <binrapt> Oh ok, I thought it required some special syntax because it's impure stuff
00:14:49 <binrapt> Really? It says it can't show IO Int
00:14:52 <luqui> let result = io_int means whenever you see "result' you can substitute "io_int"...
00:14:55 <binrapt> I'm using GHC
00:14:58 <ulfdoz> it isn't impure.
00:15:18 <BeelsebobWork_> well you can't
00:15:26 <BeelsebobWork_> the point is that io_int is not an IO Int
00:15:33 <luqui> am I just being dense?  that code looks okay to me
00:15:48 <BeelsebobWork_> luqui: it is, he's trying to simplify it
00:15:51 <BeelsebobWork_> http://hpaste.org/9909#a1
00:16:03 <BeelsebobWork_> binrapt: okay, first things first about monads...
00:16:21 <TSC> BeelsebobWork_: I think you messed up the variable name in that annotated paste...
00:16:28 <luqui> BeelsebobWork_, err...
00:16:28 <TSC> s/io_int/result
00:16:29 <BeelsebobWork_> oh, so I did
00:16:32 <BeelsebobWork_> wups
00:16:54 <BeelsebobWork_> http://hpaste.org/9909#a2
00:17:28 <BeelsebobWork_> binrapt: it's not the let binding that takes it out of the IO monad
00:17:30 <BeelsebobWork_> it's the <-
00:17:34 <binrapt> Ah ok
00:17:43 <binrapt> But it's still un'showable as that type
00:17:45 <ulfdoz> > Random.randomRIO (1, 100) >>= print
00:17:47 <lambdabot> Terminated
00:17:49 <binrapt> How can I make it showable?
00:17:51 <BeelsebobWork_> ulfdoz: that too
00:17:53 <binrapt> Oh, print
00:18:05 <ulfdoz> binrapt: However, print 1= show.
00:18:05 <BeelsebobWork_> binrapt: what's unshowable?
00:18:06 <binrapt> What's the different between print and putStrLn?
00:18:09 <ulfdoz> != even.
00:18:17 <TSC> @type print
00:18:18 <BeelsebobWork_> binrapt: print = putStrLn . show
00:18:19 <lambdabot> forall a. (Show a) => a -> IO ()
00:18:22 <luqui>  /= even :-)
00:18:24 <binrapt> Err *difference
00:18:28 <binrapt> Beelsebob ah ok
00:18:31 <binrapt> luqui lol
00:18:41 * BeelsebobWork_ pats luqui
00:19:07 <BeelsebobWork_> binrapt: also, as ulfdoz says, this can be more neatly still put as main = randomRIO (1,100) >>= print
00:19:14 <luqui> I prefer not to use composition when talking to n00bs
00:19:34 <BeelsebobWork_> luqui: I prefer to use it wherever I would use it in a program
00:19:35 <binrapt> No worries, I've done plenty of linear algebra at university ;[
00:19:38 <BeelsebobWork_> which is not very many places
00:19:54 <BeelsebobWork_> so it's usually not enough to confusule them
00:20:37 <luqui> ok.  I remember when I was starting, any occurrence of the . operator increased the amount of time it would take me to see the meaning by about 4.
00:20:42 <binrapt> You need do whenever you need to take something out of IO context with <-?
00:20:42 <luqui> factor of 4.
00:21:00 <luqui> binrapt, aye, <- means nothing outside of a do block
00:21:06 <BeelsebobWork_> binrapt: well, the do block is syntactic sugar
00:21:21 <BeelsebobWork_> do x <- exp; y is sugar for exp >>= \x -> y
00:21:28 <BeelsebobWork_> @type (>>=)
00:21:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:21:35 <binrapt> (take m . drop m) string confused me yesterday but that's mostly because I didn't know about partial application yet
00:22:26 <olsner> bah, it's just like a backwards pipe
00:22:30 <BeelsebobWork_> so >>= (pronounced bind) takes an IO value, and a function to apply to it.  Applies the function within the IO monad, and gives you back something new in the IO monad
00:22:34 <olsner> (composition)
00:23:35 <luqui> > let ($>) = flip ($) in "hello world" $> drop 4 >>> take 4
00:23:37 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
00:23:39 <BeelsebobWork_> so we can get from one program to the other easily here binrapt ... randomRIO (1,100) >>= print === randomRIO (1,100) >>= \x -> print x === do x <- randomRIO (1,100); print x
00:23:43 <luqui> > let ($>) = flip ($) in "hello world" $> (drop 4 >>> take 4)
00:23:45 <lambdabot> Terminated
00:23:52 <luqui> stupid lambdabot
00:24:30 <binrapt> Ok
00:25:26 <binrapt> How would I multiply this result to fill a list with random numbers? I know there's a better way to do this, I just want to do it the clumsy first
00:25:28 <xor__> if [1..n] is an increasing sequence, then a decreasing sequence is... ?
00:26:01 <binrapt> Err *clumsy way
00:26:41 <olsner> > [0,-1..]
00:26:43 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
00:26:54 <xor__> thanks
00:27:20 <Wild_Cat> oh, brilliant.
00:27:48 <BeelsebobWork_> binrapt: assume you have a function that generates a list of random numbers
00:28:02 <BeelsebobWork_> and then I'm sure you can see when you have that function how to generate a slightly bigger one
00:28:24 <binrapt> Consing it one by one?
00:28:28 <BeelsebobWork_> yep
00:30:42 <adu> YES!
00:30:51 <adu> my typechecker works!
00:35:40 <binrapt> http://hpaste.org/9910 <- what am I doing wrong with the <-? How should I do it instead?
00:36:59 <Cale> binrapt: Well, one thing is that generateRandomNumers 10 []  is not going to be an IO action
00:37:20 <Cale> oh, I suppose it could be though
00:37:22 <binrapt> It's already taken out of IO context?
00:37:26 <Cale> But you haven't written it that way :)
00:37:27 <ivanm> @ty randomRIO
00:37:29 <lambdabot> forall a. (Random a) => (a, a) -> IO a
00:37:45 <ivanm> Cale: it uses his alias of randomRIO, so it will be...
00:37:48 <Cale> ah, okay, I think I see what you're trying to do :)
00:37:49 <Cale> yeah
00:37:52 <Cale> so...
00:38:01 <ivanm> binrapt: what are you actually trying to do?
00:38:08 <ivanm> generate 10 random numbers?
00:38:11 <binrapt> Yeah
00:38:20 <ivanm> @hoogle (RandomGen g) => g -> [a]
00:38:20 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
00:38:20 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
00:38:20 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
00:38:39 <binrapt> Yeah not's he point really
00:38:45 <binrapt> Err
00:38:47 <Cale> binrapt: Note that  getRandomNumber : currentList would be the list consisting of the action getRandomNumber, followed by currentList (supposing that typechecked)
00:38:49 <binrapt> Yeah that's not the point really*
00:38:51 <ivanm> > take 10 . randoms $ mkdStdGen 10
00:38:53 <lambdabot> Terminated
00:38:59 <ivanm> > take 10 . randoms $ mkdStdGen 10
00:39:01 <lambdabot> Terminated
00:39:10 <ivanm> ummmm.... why is it terminating?
00:39:12 <Cale> binrapt: *Not* the result of getRandomNumber
00:39:24 <Cale> :t randoms
00:39:26 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
00:39:31 <binrapt> Cale oh hm
00:39:35 <Cale> > take 10 . randoms $ mkStdGen 10
00:39:37 <lambdabot>  [-2776415066813205131,-8883108635655729860,-2410613080667970943,-28290923353...
00:39:49 <ivanm> Cale: how come it worked for you but not me? :o
00:40:04 <Cale> ivanm: You had a spurious d
00:40:16 <ivanm> oh, mkdStdGen rather than mkStdGen :s
00:40:31 <ivanm> so why "terminated" rather than "wtf is that"? :p
00:40:44 <Cale> binrapt: To make an action that *runs* getRandomNumber, you can use do-notation
00:40:49 <binrapt> Cale so I'd have to <- it first or so?
00:40:53 <Cale> do n <- getRandomNumber
00:40:55 <binrapt> Ok
00:41:00 <Cale>    return (n : currentList)
00:41:29 <Cale> Also, the accumulating parameter is unnecessary
00:42:12 <Cale> Make the base case give an empty list, and make the recursive case an action which runs both getRandomNumber, and generateRandomNumbers, and then conses the results
00:42:39 <swiert> Is it me or is haskell.org really slow?
00:43:40 <binrapt> Ah of course
00:51:29 <binrapt> http://hpaste.org/9911 hm the <- is wrong? What have I done now
00:53:03 <Cale> binrapt: you need parens around the parameter to return
00:53:32 <Cale> also, you want to actually run generateRandomNumbers, not just cons it...
00:54:00 <Cale> oh, and in the 0 case, you want the action which does nothing and returns [], which is return []
00:54:31 <Cale> Another way to write this is  generateRandomNumbers n = replicateM n getRandomNumber
00:54:48 <Cale> (but that would be avoiding the nice exercise :)
00:55:56 <Cale> Oh, also, in main, you have  print (generateRandomNumbers 10), which is again a problem, since you don't want to print the action, you want to print the result of the action.
00:56:21 <Cale> (you'll get an error about there not being a Show instance for IO)
00:57:56 <binrapt> Yay it works now, thanks
00:58:14 <binrapt> http://hpaste.org/9912
00:58:23 <Cale> right :)
00:58:44 <Cale> The distinction between actions and their results can seem troublesome at first, but it has advantages too.
00:59:16 <Cale> One is that it is easy to pass actions around to functions which turn them into other actions (and so act like control structures)
01:00:17 <binrapt> And to make this even shorter I'd have to use >>=?
01:01:14 <luqui> binrapt, that or something like liftM/liftM2/etc
01:01:50 <luqui> @src liftM2
01:01:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:02:27 <binrapt> D:
01:02:38 <luqui> (follows the same pattern as generateRandomNumbers)
01:03:14 <binrapt> Except I don't have a binary function?
01:03:17 <binrapt> But an unary one?
01:03:29 <luqui> the binary function is (:)
01:03:30 <binrapt> -n
01:03:39 <binrapt> Oh
01:04:47 <BeelsebobWork_> binrapt: one other thing -- there's no reason for that size parameter
01:04:58 <BeelsebobWork_> you have a function already that makes a list a certain length -- it's called take
01:05:14 <BeelsebobWork_> so what you should generate is a list that will *always* work, no matter what n you pass to take
01:05:21 <BeelsebobWork_> and there's only one such list -- an infinitely long one
01:05:33 <luqui> BeelsebobWork_, ummm....
01:05:44 <luqui> that would require a lot of work, since these are in IO
01:05:51 <BeelsebobWork_> luqui: it would?
01:05:53 <BeelsebobWork_> IO is still lazy
01:05:58 <binrapt> Do demonstrate please
01:06:01 <binrapt> With take
01:06:27 <BeelsebobWork_> well, okay, first lets assume we have our infinite list of randoms... and call it randomInf
01:06:28 <Cale> binrapt: If you can make a list of actions that you want to run, sequence will turn them into an action which when run will produce a list of the results of running each.
01:06:37 <Cale> :t sequence
01:06:39 <BeelsebobWork_> we can get 10 of them by doing take 10 randomInf
01:06:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:06:42 <luqui> BeelsebobWork_, Ihow does one generate that list?
01:06:56 <luqui> (I know, "randoms", but in the context of this example)
01:07:25 <BeelsebobWork_> luqui: randomInf = do x <- randomR (1,100); y <- randomInf; return (x:y)
01:07:41 <luqui> BeelsebobWork_, you mean x <- randomRIO (1,100) ?
01:07:44 <BeelsebobWork_> I do
01:07:48 <luqui> please do try that
01:07:54 <luqui> you might be surprised :-)
01:08:20 <binrapt> Doesn't that require { } because of the ; or so"
01:08:24 <binrapt> *?
01:08:35 <luqui> binrapt, yeah, the meaning was implied
01:08:45 <BeelsebobWork_> luqui: why can that not be evaluated lazily?
01:08:57 <luqui> because >>= in IO is strict.
01:09:04 <BeelsebobWork_> oh, lameness
01:09:05 <BeelsebobWork_> >.<
01:09:09 <BeelsebobWork_> gief Random monad
01:09:31 <BeelsebobWork_> or more to the point, gief Cloud type instead of using Monads for this
01:09:31 <luqui> MonadRandom is nice.  Kinda unnecessary, but nice.
01:09:50 <luqui> BeelsebobWork_, what are you talking about?  gief?  Cloud?
01:10:09 <BeelsebobWork_> luqui: make random numbers have type Num a => Cloud a
01:10:24 <BeelsebobWork_> and make instance Num a => Num (Cloud a)
01:10:31 <luqui> please elaborate
01:10:47 <luqui> sounds interesting so far
01:10:53 <BeelsebobWork_> wrap randoms in a "cloud" meaning that they aren't an 'a' but instead, any value within a cloud of as
01:10:59 <BeelsebobWork_> then define numeric computation on them
01:11:09 <luqui> oh I see.
01:11:19 <BeelsebobWork_> you see exactly where randomness spreads to in your program because the clouds go wherever the randoms go
01:11:24 <BeelsebobWork_> and it's composititonal
01:11:41 <luqui> that's nice.  how do you extract when you need a real number though
01:12:03 <BeelsebobWork_> you don't -- that's the point of the cloud, to lock in impure computation in a pure container
01:12:14 <BeelsebobWork_> you define all the operations you need (e.g. showing) on the cloud
01:12:29 <BeelsebobWork_> so showing a cloud would in fact be type Cloud a => Cloud String
01:12:43 <BeelsebobWork_> and you could concievably have a way of getting from a Cloud into IO
01:12:47 <BeelsebobWork_> if you really wanted
01:13:31 <luqui> maybe cloud and IO commute =P
01:13:52 <BeelsebobWork_> plausable, but they're still distinct concepts
01:13:53 <luqui> main :: Cloud (IO ()) -- random action
01:13:58 <BeelsebobWork_> hehe
01:14:09 <BeelsebobWork_> that's a nice idea actually
01:14:15 <BeelsebobWork_> if only you could change the type of main
01:14:33 <luqui> eh, it's not so bad.  a one line wrapper usually does the trick.
01:14:50 <luqui> I mean, what's the alternative?  class Main a where ...
01:14:52 <BeelsebobWork_> true
01:15:04 <BeelsebobWork_> well, the alternative is a functional OS :P
01:15:07 <luqui> but the ... has something like a -> IO () in it anyway, so we haven't gotten very far
01:15:20 * luqui is keeping his head out of the Cloud for the time being
01:15:37 <binrapt> How old were you guys when you started doing FP?
01:15:45 <BeelsebobWork_> binrapt: very young
01:15:54 <luqui> 22 (two years ago)
01:15:54 <|Steve|> College.
01:15:55 <BeelsebobWork_> my dad wrote the first book on Haskell
01:16:02 <BeelsebobWork_> so he was subversively teaching me for ages
01:16:02 <luqui> 21 actually...
01:16:06 <binrapt> I am under the impression that most people start FP later than imperative programming
01:16:12 <binrapt> often considerable later
01:16:14 <binrapt> *y
01:16:16 <BeelsebobWork_> binrapt: unfortunately, yes :(
01:16:17 <osfameron> many people started with Logo
01:16:26 <|Steve|> I started with Logo in 8th grade.
01:16:30 <luqui> binrapt, that's true, because it's a more obscure subculture.
01:16:31 <osfameron> which is kinda functional but with side-effects isn't it?
01:16:37 <BeelsebobWork_> luqui: it is?
01:16:43 <luqui> you want to learn to program, the most likely recommendation you'll get is Java.
01:16:47 <luqui> so people start with java.
01:16:58 <binrapt> I started with JavaScript when I was 13 or so lol
01:16:59 <BeelsebobWork_> I'm not sure that's true
01:17:00 <|Steve|> Uh. Java's came out in '95.
01:17:09 <binrapt> Never touched any FP until now, I'm 21
01:17:12 <BeelsebobWork_> most people seem to recommend one of C, BASIC or Python to start you learning
01:17:25 <binrapt> BASIC? You gotta be kidding ;[
01:17:28 <luqui> eh, yeah, it was just a distribution argument.
01:17:36 <luqui> QBasic is a great learning language IMO
01:17:37 <binrapt> Maybe decades ago lol
01:17:39 <BeelsebobWork_> but I guess there are crap tons of unis that teach Java as their first course
01:17:54 <|Steve|> Now there are.
01:17:58 <BeelsebobWork_> :(
01:18:00 <osfameron> I learnt basic first because it was the default programming environment of every computer I had growing up (Spectrum 48K, BBC Master, Acorn A3000)
01:18:01 <luqui> This is the reason QBasic is a good learning language:  one line to put a pixel anywhere on the screen.
01:18:14 <|Steve|> 7 years ago was when the university of Washington switched to using Java.
01:18:16 <luqui> they can get excited in the first five minutes
01:18:17 <osfameron> qbasic kinda rocked actually
01:18:21 <BeelsebobWork_> I learnt C as my first language, then TiBasic
01:18:22 <osfameron> it has structs and everything
01:18:31 <|Steve|> It was Winter quarter, as I recall. =)
01:18:42 <binrapt> My first proper programming language was C too
01:18:56 <binrapt> I spent most of my time on C++
01:19:02 <luqui> start with C, you usually go weeks without seen the slightest bit of graphics.  Start with Haskell, you still can't do graphics when you're a pro.
01:19:03 <BeelsebobWork_> poor you :(
01:19:11 <luqui> (you can, but you're not satisfied ;-)
01:19:14 <BeelsebobWork_> luqui: lol
01:19:16 <binrapt> luqui haha
01:19:26 <BeelsebobWork_> Ivan can do graphics in a satisfying way
01:19:34 <BeelsebobWork_> even if he does break the type system
01:19:38 <luqui> heheh
01:19:43 <Svrog> lol
01:19:49 <osfameron> luqui: you don't think the HSOE approach works?
01:19:59 <luqui> I haven't a clue.
01:20:21 <luqui> Haskell was my 24th language or something like that, I have no idea what learning programming with it would be like.,
01:20:21 <BeelsebobWork_> I guess I should go back to thinking about how to get these last two arrow laws checked
01:20:30 <osfameron> actually, I think it breaks down in later chapters because you have to have been following quite carefully to have a framework that actually works (some of the pieces are developed in exercises) so you may not be able to run later examples easily
01:20:46 <BeelsebobWork_> luqui: fairly painful I imagine -- learning with the pure parts of scheme might be okay though
01:21:22 <binrapt> Haha I wonder what it would be like to have started with FP
01:21:32 * luqui wonders that too.
01:21:34 <binrapt> And then being forced to do C++ or something like that
01:21:53 <BeelsebobWork_> binrapt: rofl, give it about 4 months and you won't want to touch C++ ever again, even without starting with FP
01:22:08 <osfameron> I've read people say that they started with fp and find it more logical and clearer
01:22:10 <luqui> but my brain is adequately deimperativized lately.  In that eg. I can no longer even think about OO design patterns.
01:22:11 <|Steve|> Pft. Fanboyism there.
01:22:14 <luqui> even if I try
01:22:25 <Wild_Cat> even Java makes one not want to ever touch C++ again.
01:22:31 <binrapt> BeelsebobWork_ what, why
01:22:40 <BeelsebobWork_> binrapt: in 4 months time you'll find out
01:22:42 <binrapt> I've been touching C++ for 7 years ;[
01:22:43 <osfameron> aren't there certain classes of algorithm that are easier/more logical with imperative programming, even after learning FP?
01:22:44 <|Steve|> No, Java makes one not want to touch Java  again.
01:22:45 <binrapt> Still love it
01:22:55 <binrapt> Oh, you mean 4 months of FP?
01:22:55 <binrapt> Right
01:22:57 <luqui> binrapt, yay!  you're just like me!
01:22:58 <BeelsebobWork_> yep
01:23:05 <|Steve|> Yeah, those of us who have been using c++ for years are unlikely to give it up.
01:23:30 <BeelsebobWork_> |Steve|: doesn't mean you won't hate it after a few months of FP
01:23:40 <BeelsebobWork_> even if you don't give it up
01:23:42 * luqui used C++ for at least 7 years before learning haskell.   He loved it, did template evil, the works.  Now I can't stand the beast.
01:23:45 <|Steve|> Uh, I don't hate it.
01:23:53 <binrapt> Ah templates <3
01:23:54 <luqui> wow, way to go changing person in the middle...
01:24:10 <BeelsebobWork_> luqui: yeh, i did wonder why you'd become a royal
01:24:18 <|Steve|> (I do that in the middle of my /mes too.)
01:24:32 <luqui> BeelsebobWork_, haha
01:24:39 <osfameron> I try to avoid pronouns after /me, is the easiest way not to go wrong
01:24:47 <binrapt> I always make fun of people failing in /me
01:24:54 <jn> Haskell newbie here, how do i write a function that takes a tuple of two functions and a value as parameters and applies the function which parameter matches the value type?
01:25:15 <luqui> jn, you mean apply (f,x) = f x ?
01:25:25 <idnar> if your message has a pronoun in it, it probably shouldn't be a /me :P
01:25:26 <luqui> (jn, you're question is not exactly clear)
01:25:30 <BeelsebobWork_> jn: you mean it would have the type (a -> b, a -> c) -> a -> (b,c)?
01:25:56 <|Steve|> BeelsebobWork_: I don't think that was it.
01:26:00 <luqui> although mine is certainly not a tuple of two functions
01:26:02 <idnar> BeelsebobWork_: (a -> b, a -> c) -> a -> Either b c I think
01:26:12 <idnar> err
01:26:13 <idnar> no
01:26:14 <luqui> oh I think he wants something that's impossible
01:26:14 <|Steve|> I don't think he wants that either.
01:26:21 <|Steve|> I think he wants either.
01:26:24 <|Steve|> @type either
01:26:24 <idnar> what I meant was
01:26:26 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:26:27 <jn> beelsebob: no, more like (a1 -> b1, a2 -> b2) -> a -> (b1 or b2)
01:26:30 <idnar> oh, yeah
01:26:32 <luqui> something like (Int -> a, Bool -> a) -> Int|Bool -> a
01:26:45 <luqui> where Int|Bool is Either Int Bool without the tag
01:26:53 <BeelsebobWork_> jn: well, the 'a's have to be the same a -- or they can't be applied
01:27:02 <BeelsebobWork_> the workaround is to use either
01:27:08 <BeelsebobWork_> luqui: yep, disjunctive tuples ftw
01:27:16 <jn> beelsebob: a is either a1 or a2, or a compile error
01:27:30 <BeelsebobWork_> jn: exactly -- so use the Either type
01:27:36 <jn> should be possible with type classes right?
01:27:47 <luqui> jn, with a *lot* of type class hackery yes
01:27:50 <|Steve|> jn: Look at the Either class.
01:27:50 <BeelsebobWork_> (a1 -> b1, a2 -> b2) -> Either a1 a2 -> Either b1 b2
01:27:59 <luqui> maybe needing undecidableinstances
01:28:04 <BeelsebobWork_> no need to use type classes
01:28:07 <BeelsebobWork_> or weird shit
01:28:08 <jn> beelsebob: thats not enough
01:28:12 <BeelsebobWork_> just use Either
01:28:17 <BeelsebobWork_> jn: why not?
01:28:28 <jn> beelsebob: the function can only return b1 if you input a1, not a2
01:29:04 <luqui> > :t let editEither f g = either (Left . f) (Right . g)
01:29:05 <lambdabot>  Parse error at "let" (column 4)
01:29:10 <luqui> :t let editEither f g = either (Left . f) (Right . g)
01:29:12 <lambdabot> <no location info>:
01:29:12 <lambdabot>     not an expression: `let editEither f g = either (Left . f) (Right . g)'
01:29:14 <luqui> :t let editEither f g = either (Left . f) (Right . g) in editEither
01:29:16 <lambdabot> forall a a1 b b1. (a -> a1) -> (b -> b1) -> Either a b -> Either a1 b1
01:29:18 <BeelsebobWork_> okay, so one instance of this function is... (a1 -> Either c1 c2, a2 -> Either c1 c2) -> Either a1 a2 -> Either (Either c1 c2) (Either c1 c2)
01:29:25 <BeelsebobWork_> so then you can use joinEithers
01:29:38 <swiert> TMR Issue 11 has just shipped:
01:29:39 <|Steve|> @quote stereo
01:29:39 <swiert> http://www.haskell.org/haskellwiki/The_Monad.Reader
01:29:39 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
01:29:41 <luqui> :t joinEithers
01:29:42 <lambdabot> Title: The Monad.Reader - HaskellWiki
01:29:43 <lambdabot> Not in scope: `joinEithers'
01:29:50 <BeelsebobWork_> luqui: join in the either monad
01:30:11 <jn> beelsebob: that type signature is not sufficient
01:30:13 <BeelsebobWork_> oh no, that's not quite right
01:30:16 <luqui> BeelsebobWork_, uh... right it isn't
01:30:24 <BeelsebobWork_> but you know the function I mean
01:30:29 <BeelsebobWork_> jn: why not?
01:30:44 <luqui> BeelsebobWork_, join on the Either bimonad (if there is such a thing)
01:30:52 <BeelsebobWork_> luqui: yeh, exactly
01:31:09 <jn> beelsebob: hmm, maybe it is
01:31:29 <BeelsebobWork_> jn: you just need a function with type Either a a -> a afterwards
01:31:32 <jn> beelsebob: so how would the implementation look like?
01:31:51 <luqui> jn, first find out what the type signature you actually want i
01:31:52 <luqui> s
01:32:14 <luqui> for functions like this, djinn might even be able to implement it for you ;-)
01:32:22 <jn> luqui: (a -> b, c -> d) -> Either a c -> Either b d
01:32:27 <BeelsebobWork_> > let editEither (f,g) (Left x) = Left (f x); editEither (f,g) (Right x) = Right (g x) in editEither ((+1),(/2)) (Left 5)
01:32:29 <lambdabot>  Left 6
01:32:35 <BeelsebobWork_> > let editEither (f,g) (Left x) = Left (f x); editEither (f,g) (Right x) = Right (g x) in editEither ((+1),(/2)) (Right 5)
01:32:36 <lambdabot>  Right 2.5
01:32:42 <BeelsebobWork_> there you go
01:33:30 * luqui 's version is prettier.  but more abstract.  the two unfortunately go together frequently.
01:33:49 <BeelsebobWork_> yep, agree
01:33:54 <jn> can this be generalized so that you can create a "pair"-list of functions and apply an argument to?
01:34:08 <luqui> jn, what's a 'pair'-list
01:34:24 <luqui> you mean like (a,(b,(c,(d,()))) ?
01:34:32 <jn> yes of functions
01:34:42 <BeelsebobWork_> jn: unfortunately, things with tuples in them don't generalise easily like that (one of the shortcomings of Haskell)
01:34:55 <name__> :r
01:34:58 <BeelsebobWork_> but you could easily write editEither2 editEither3 and editEither4 and hope that's enough
01:34:59 <name__> fail
01:35:00 <|Steve|> > [(+),(-),(*),div]
01:35:01 <lambdabot>      Overlapping instances for Show (a -> a -> a)
01:35:01 <lambdabot>       arising from a use of...
01:35:34 <jn> beelsebob: ok, you would need C++ templates or similar to do it i guess
01:35:35 <BeelsebobWork_> |Steve|: yeh, the problem is that you (a) need them to have different types (b) need to do the same for the Either argument
01:35:35 <|Steve|> > [(+),(-),(*),div]::[Int->Int->Int]
01:35:37 <lambdabot>      Overlapping instances for Show (Int -> Int -> Int)
01:35:37 <lambdabot>       arising from a ...
01:35:52 <luqui> jn, well, if it's known statically, then yes you could elim (a -> d,(b -> d,(c -> d,())) against Either a (Either b (Either c ()))
01:36:09 <luqui> jn, and you could get typeclasses to do that too
01:36:16 <|Steve|> What is lambdabot complaining about?
01:36:29 <jn> luqui: everything is known statically, its basically an object definition
01:36:31 <luqui> jn, so if it's an academic exercise, might be fun.  I've never needed such magic in real life.
01:36:53 <jn> luqui: and i want to implement the message dispatch function
01:37:11 <luqui> oh you're emulating OO in Haskell.
01:37:25 <BeelsebobWork_> jn: a recommendation -- don't try to implement your favourite language paradigm in FP
01:37:27 <luqui> in this to solve a specific problem, or to see if it can be done?
01:37:31 <BeelsebobWork_> it usually doesn't end up pretty
01:37:42 <BeelsebobWork_> unless ofc it's just an accademic exercise
01:38:01 <jn> luqui, beelsebob: its an academic excersice to implement a minimal OO language
01:38:07 <BeelsebobWork_> fair enough then
01:38:13 <luqui> jn, there is a library called "HList" which does this sort of thing.
01:38:18 <BeelsebobWork_> yeh
01:38:21 <BeelsebobWork_> it's *nasty* though
01:38:24 <BeelsebobWork_> and it smells of wee
01:38:32 <luqui> lol, agreed
01:38:53 * BeelsebobWork_ ponders how to write a generator for onto functions
01:39:05 <jn> ah, i better stay away then
01:39:33 <idnar> |Steve|: there are overlapping instances defined for Show (Int -> Int -> Int) :P
01:39:44 <luqui> jn, yeah, a very small interpreter for an OO language should be easy, say if you have an AST data strucutre
01:39:55 <luqui> an *embedding* is much more difficult, and is what HList does
01:40:37 <luqui> > (+)::(Int -> Int)
01:40:38 <lambdabot>  Couldn't match expected type `Int'
01:40:52 <idnar> :t (+)
01:40:54 <lambdabot> forall a. (Num a) => a -> a -> a
01:40:54 <idnar> :t (div)
01:40:56 <lambdabot> forall a. (Integral a) => a -> a -> a
01:40:56 <luqui> > show ((+)::(Int -> Int))
01:40:58 <lambdabot>  Couldn't match expected type `Int'
01:41:02 <jn> luqui: objects are represented by typed cons lists, and from that i want to define "override", "delegate", "implement" etc functions
01:41:09 <idnar> luqui: Int -> Int -> Int you mean?
01:41:25 <luqui> ah yes, doyy
01:41:26 <|Steve|> idnar: Of course. It makes so much sense now.
01:41:30 <luqui> > show ((+)::(Int -> Int -> Int))
01:41:32 <lambdabot>      Overlapping instances for Show (Int -> Int -> Int)
01:41:32 <lambdabot>       arising from a ...
01:41:37 <jn> luqui: its easy if you have a typed macro language
01:41:38 <idnar> |Steve|: do you know what overlapping instances are?
01:41:40 <luqui> > show (succ::(Int -> Int))
01:41:42 <lambdabot>      Overlapping instances for Show (Int -> Int)
01:41:42 <lambdabot>       arising from a use of ...
01:41:53 <|Steve|> I do not.
01:42:36 <idnar> well, hmm, I'm not sure I can give a great explanation
01:42:49 <idnar> but basically, there are multiple instances of show defined that could apply to the type Int -> Int -> Int
01:43:00 <Cale> The problem is that two modules that are in scope both define a Show instance for functions
01:43:55 <luqui> jn, where are you coming from? what language has a typed macro language?  (sounds cool)
01:43:58 <jn> luqui: is there an easy way to define a typed cons pair type, ie something like: data Pair a (b : Pair _ _) = Pair a b | Nil?
01:44:29 <luqui> jn, by that you mean you constrain b to be a Pair also?
01:44:32 <jn> luqui: C++ templates for example :)
01:44:38 <luqui> oh gross.
01:44:39 <jn> luqui: yes
01:44:48 <luqui> and that's not really a typed macro language...
01:45:06 <luqui> i.e. it's not very 'typed', despite appearances
01:45:08 <jn> luqui: it allows function overriding on types
01:45:23 <jn> and specialization
01:45:43 <luqui> aye, specialization is the big thing Haskell is missing here.
01:46:01 <jn> actually Scala can do some of it as well with implicits
01:46:18 <luqui> Haskell actually does do specialization, using -XOverlappingInstances
01:46:30 <luqui> by Haskell here I mean GHC
01:46:55 <jn> ok, any suggestion on how i can encode the Pair type?
01:47:04 <luqui> and no you can't constrain b to be a Pair (unfortunate.  there is little support for closed types at compile time)
01:47:32 <luqui> jn, what do you want from it again?
01:48:26 <jn> just a type restriction on the second type parameter
01:48:46 <jn> that its a Pair also
01:49:04 <luqui> so you'll end up with infinite lists of types at compile time
01:49:19 <luqui> or is that | Nil at the type rather than the data level?
01:49:20 <jn> yes, so i dont need 30 tuple types :)
01:49:43 <luqui> I'd just use () = NIl and (,) as Cons
01:50:05 <luqui> which doesn't restrict, unfortunately, so (Int,Int) is meaningless as a list
01:50:26 <jn> thats the drawback, yes
01:50:28 <swiert> jn: data Pair where Pair :: forall a, a -> Pair -> Pair | Nil :: Pair.
01:50:34 <swiert> But it's pretty useless.
01:50:53 <luqui> but adequate, normal use of typeclasses will not allow meaningless lists to compile anyway
01:50:56 <luqui> if you do anything with them
01:51:42 <jn> luqui: problem is you cant write a function that works on tuples of any arity, right?
01:51:50 <luqui> jn, anyway, just for the record, Haskell is (quite intentionally) *not* turing complete at compile time, so you might run into essential difficulty trying to emulate C++ (or maybe Scala.. not sure)'s compile time
01:52:08 <luqui> jn, if it's a typeclass method you can
01:53:27 <jn> ok, lets simplfiy a bit, how would you implement a function that searches any tuple/pair for a value of a specific type and returns that value? (compile time error if there are multiple values of the same type)
01:54:04 <luqui> that you can't do.
01:54:19 <luqui> well I think you can actually, but I'll have to look up the Oleg trick
01:54:25 <jn> unfortunate
01:54:40 <luqui> the thing is that you'd have to have a predicate for "not of type a", which is not an open logic predicate
01:55:03 <jn> luqui: thats what specialization does
01:55:42 <luqui> yeah, but you can't do it with OverlappingInstances either, because "instance Foo a" is in the undecidable class
01:55:52 <luqui> (class not meaning typeclass above ;-)
01:57:18 <jn> ok, is there a simple functional language that supports specialization like this?
01:57:29 <luqui> typeclasses are an open logic system, for a very good reason, which outlaws a lot of trickery.
01:57:33 <luqui> hmmm, I'm not sure.
01:58:00 <luqui> I mean yes.   but I don't know what it is :-)
01:58:46 <jn> ok, Scala can do some of this, but its hardly simple and pretty :)
01:59:00 <luqui> jn, it will never be simple and pretty.
01:59:16 <luqui> because what you're after does not have simple semantics :-)
01:59:30 <luqui> jn, Agda might be fun for you though
01:59:55 <luqui> (it has an extremely powerful type system, where you can do anything you can do at runtime at compile time)
02:00:15 * BeelsebobWork_ pushes Epigram into the foray
02:00:29 <luqui> Epigram also, but it's UI can be a turn-off
02:01:26 <jn> luqui: certainly it could be made simple: find [V, H] (p : (H, _)) = find p.tail; find [V] (p : (V, _)) = p.head
02:01:37 <jn> where [..] denotes type parameters
02:01:52 <luqui> which needs type equality
02:02:09 <luqui> which in turn is hard to do in polymorphic languages
02:02:46 <jn> hmm, i dont understand
02:03:16 <luqui> if you compile eg:  f :: lst -> find Int lst
02:03:31 <luqui> compiling this needs to know where it is used
02:03:40 <luqui> which breaks separate compilation, for example
02:03:50 <jn> yes, its basically a macro language
02:04:08 <luqui> jn, but if it's used in a polymorphic function, even if that function does not have find in its type
02:04:22 <luqui> that function then needs to know where it's used
02:04:35 <luqui> and sometimes the polymorphism is never resolved to a monotype.
02:05:27 <jn> yes, you mean when theres infinite recursion?
02:05:31 <luqui> anyway, Agda/Epigram are the functional languages in this genre
02:05:38 <luqui> or when a type parameter ends up not being used
02:05:57 <BeelsebobWork_> luqui: don't suppose you could fix the compiler warnings in LegacyAdapters
02:05:58 <BeelsebobWork_> ?
02:06:27 <luqui> but coming from languages with TC compile time, you might be frustrated with those languages also (they are much more nitpicky about what they allow, so you have to be more careful in how you engineer these things)
02:07:15 <luqui> BeelsebobWork_, ok
02:07:50 <BeelsebobWork_> cheers
02:08:29 <jn> luqui: does the type checker have to be TC to support these constructs, or is it an open problem?
02:08:47 <luqui> jn, no, it's just that turing completeness makes it a lot easier to do
02:09:12 <luqui> working with TC systems you are doing programming.  otherwise you are doing mathematics.
02:09:44 <luqui> where "you can't do that" is a frequent reasonable answer.
02:10:07 <luqui> (and when you can, you have to prove you can)
02:11:34 <jn> luqui: but if you have specialization on type parameters, its TC isnt it?
02:12:09 <luqui> jn, not in Agda.  The way it gets away with that is essentially by making you prove your code always halts.
02:12:37 <luqui> I mean, Agda does not have specialization, but it has mechanisms powerful enough to accomplish what you want to.
02:13:46 <jn> ok, sounds interesting
02:14:33 <kosmikus> specialization is an implementation technique / an optimisation
02:15:05 <kosmikus> you don't even have to implement type classes via specialisation, even though most (all?) Haskell implementations do
02:15:45 <jn> kosmikus: not entirely, for example if the return type of a function differs depending on type parameters
02:16:10 <kosmikus> hm?
02:16:53 <luqui> kosmikus, he's talking about eg. template specialization in C++
02:16:57 <luqui> not haskell's use of the term
02:16:59 <jn> kosmikus: fn a = a; fn (a : Int) = 10.1
02:17:01 <kosmikus> I'm saying that most Haskell implementations translate every instance into a separate function, and determine statically which function to call.
02:17:24 <kosmikus> You could also implement it via performing type analysis at runtime.
02:18:16 <jn> is recursive type class declarations allowed?
02:18:26 <luqui> jn, what sort of recursive?
02:18:40 <luqui> class Foo a => Foo (Bar a) -- this is fine
02:18:53 <luqui> er
02:18:57 <luqui> s/class/instance/
02:20:48 <jn> class Pair (Pair a) => a where ...
02:21:12 <jn> hmm, that wouldnt make much sense i guess
02:21:18 <Heffalump> umm, no.
02:21:19 <luqui> jn, that's not valid haskell.  not because it's disallowed, because it's nonsensical...
02:22:18 <luqui> class PairC (Pair a) => PairC a  -- this is also fine
02:22:34 <Heffalump> well, fine if you turn on lots of extensions
02:22:47 <Heffalump> and are sure it will terminate
02:22:54 <luqui> Heffalump, I said class, not instance.
02:23:05 <Heffalump> true, but isn't it still an issue?
02:23:15 <luqui> no.
02:23:24 <luqui> classes can have arbitrary constraints on the left.
02:23:42 <luqui> instances need smaller constraints than heads.
02:25:02 <kosmikus> I think that's right. Because "class" essentially implies an automatic "instance" declaration in the reverse direction.
02:25:04 <jn> class Pair a where first :: a -> _; second :: Pair _
02:26:24 <Heffalump> so for it to be any use, there'd need to be instance PairC a => PairC (Pair a) somewhere (or perhaps the same thing indirectly, though in H98 it'd have to be direct)
02:26:43 <luqui> kosmikus, not automatic: necessary
02:27:23 <luqui> jn, maybe with associated types
02:27:47 <luqui> class Pair a where { type First a :: *; type Second a :: * }
02:27:58 <luqui> or you need constraints
02:28:00 <luqui> hmmm.
02:28:05 <kosmikus> luqui: just words ;)
02:28:47 <luqui> jn, well the problem is, where does it terminate.  how do you encode nil?
02:29:16 <BONUS> ahaha look what i found on the reddit front page http://www.reddit.com/comments/6xtlq/who_is_proggits_most_stuckup_expert_slava_pestov/
02:29:18 <lambdabot> Title: Who is proggit's most stuck-up "expert": slava_pestov, dons or DRMacIver? : redd ..., http://tinyurl.com/64mgxu
02:32:07 <luqui> Heffalump, yeah, or just an instance PairC (Pair a) whatever the constraint
02:32:22 <Heffalump> oh yeah
02:38:08 <jsnx> i have two instances of a class, one defined in terms of another: http://hpaste.org/9913
02:38:47 <jsnx> i get a type error on the second definition unless i provide the full type of the first
02:38:59 <jsnx> is there a flag to make this go away?
02:40:14 <sjanssen> jsnx: no, because it is ambiguous
02:42:32 <luqui> jsnx, I would suggest just a different function for what I deduce you're trying to do
02:42:58 <luqui> parseDent :: String -> ([Dental], [LexingError])
02:43:05 <luqui> dent = fst . parseDent
02:43:41 <jsnx> sjanssen: well, the result type is not ambiguous
02:44:05 <luqui> jsnx, what if you had instance ([Dental], [FooBar])
02:44:11 <luqui> which dent would it use?
02:44:16 <jsnx> luqui: oh, i see
02:44:21 <jsnx> damn
02:44:29 <jsnx> open world assumption, right?
02:44:32 <luqui> yeah
02:46:04 <jsnx> okay, i see now what i what i want is wrong
02:46:32 <jsnx> s/now what/now why/
02:46:56 <jsnx> it'd lead to defacto unextendable modules
02:49:51 <aeolist> so ah, is there some kind of debugger? i am trying to understand the order in which stuff gets evaluated
02:50:19 <ziman> yes, ghci has one http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:50:20 <lambdabot> Title: 3.5.�The GHCi Debugger, http://tinyurl.com/0
02:50:54 <aeolist> cool, thanks :)
03:00:22 <Cale> aeolist: Just to check, do you understand lazy evaluation? I'd be happy to explain how it proceeds.
03:00:54 <aeolist> thank you Cale, i am actually trying to understand how this works: http://www.perl.com/pub/a/2005/09/08/autrijus-tang.html?page=2
03:00:59 <lambdabot> Title: perl.com: Perl Internationalization and Haskell: An Interview with Autrijus Tang
03:01:11 <Cale> aeolist: ah, okay
03:01:21 <Cale> Well, let's start with simpler programs at first :)
03:01:41 <aeolist> mmm, i read and understood median on dons blog
03:01:47 <Cale> Lazy evaluation basically works by evaluating the outermost function first.
03:01:56 <aeolist> ok ok go on :)
03:02:07 <Cale> This is in contrast to strict evaluation which evaluates the innermost function.
03:02:44 <Cale> So, suppose we have the function:  double x = x + x
03:02:55 <Cale> and we want to evaluate  double (double 5)
03:02:59 <EvilTerran> gooooood morning #haskellers!
03:03:14 <Cale> EvilTerran: morning :)
03:03:15 * EvilTerran notes that Cale appears to be explaining call-by-need again
03:03:23 <Cale> Under strict evaluation, this goes like:
03:03:30 <Cale> double (double 5)
03:03:34 <Cale> -> double (5 + 5)
03:03:38 <Cale> -> double 10
03:03:42 <Cale> -> 10 + 10
03:03:44 <Cale> -> 20
03:03:50 <wjt> Cale: do you, by any chance, have an irssi script for this? :P
03:03:57 <Cale> wjt: no, I just type it
03:04:10 <Cale> Under outermost first evaluation, we get:
03:04:13 <Cale> double (double 5)
03:04:21 <Cale> -> (double 5) + (double 5)
03:04:29 <Cale> -> (5 + 5) + (double 5)
03:04:32 <binrapt> I'm currently doing the silly YAHT exercises, how do I restrict the type data Quadruple a b c d = Quadruple a b c d such that (type(a) == type(b)) && (type(c) == type(d))?
03:04:33 <Cale> -> 10 + (double 5)
03:04:37 <Cale> -> 10 + (5 + 5)
03:04:39 <Cale> -> 10 + 10
03:04:41 <Cale> -> 20
03:04:43 <binrapt> Using a type signature?
03:04:52 <binrapt> I tried Quadruple :: a -> a -> b -> b -> Quadruple a a b b but it's invalid :<
03:04:57 <Cale> binrapt: make it take only two type parameters
03:04:59 <EvilTerran> binrapt, er?
03:05:09 <EvilTerran> data Quadruple a b = Quadruple a a b b
03:05:17 <EvilTerran> is what Cale suggests
03:05:19 <binrapt> Ah ok
03:05:28 <aeolist> Cale: ok, i understand
03:05:32 <Cale> aeolist: Follow that? Note however, that we wasted some work.
03:06:03 <Cale> aeolist: We evaluated double 5 twice. So lazy evaluation implies an additional optimisation on top of outermost first evaluation
03:06:31 <aeolist> yes
03:06:32 <Cale> If a parameter to a function occurs multiple times in the body of the function, the results of evaluating it are shared between the copies.
03:06:45 <aeolist> mmm, very interesting
03:06:52 <Cale> So, if I may use  let ... in ...  to represent this sharing:
03:06:55 <Cale> double (double 5)
03:07:01 <Cale> -> let x = double 5 in x + x
03:07:08 <Cale> -> let x = 5 + 5 in x + x
03:07:13 <Cale> -> let x = 10 in x + x
03:07:15 <Cale> -> 20
03:07:55 <aeolist> can ghc detect and optimize that? i mean without the let
03:08:00 <luqui> Is there any sort of "completeness theorem" for dependent types?
03:08:26 <Cale> aeolist: That's what lazy evaluation does anyway: in the definition double x = x + x, the parameter x occurs twice in the body.
03:08:41 <luqui> i.e. "any type that is inhabited in all models has an implementable witness" or something of that form
03:08:46 <Cale> aeolist: So the results of evaluating it are shared.
03:08:51 <luqui> (or something of another form, I'm just looking for strong results)
03:09:26 <aeolist> very pretty indeed
03:09:40 <Cale> aeolist: If instead, you wrote an expression like  (double 5) + (double 5), it's unlikely that GHC would share the computation, (because there's a time/space tradeoff, and usually if you write things like that, there's a reason)
03:09:41 <luqui> aeolist, ghc *can* do CSE (common subexpression elimination), but it usually does not
03:09:50 <luqui> because it can lead to memory leaks
03:10:09 <Cale> But it does do the lazy evaluation sharing consistently.
03:10:23 <aeolist> ok
03:10:45 <Cale> The next thing you need to know is that evaluation is caused, essentially, by pattern matching.
03:11:26 <Cale> (It can also seemingly be caused by other things, like printing things to the screen, but if you want, you can imagine that those routines are pattern matching on the data.
03:11:27 <Cale> )
03:11:40 <Cale> (They usually are anyway, at least to some degree :)
03:12:01 <aeolist> if i have understood that part correctly, you have to match the right Show function?
03:12:28 <Cale> Well, the Show function for the given type will do pattern matching on the data you give it to determine what to produce.
03:13:15 <ivanm> anyone know if the codes mentioned here have been archived somewhere? http://www.mail-archive.com/haskell@haskell.org/msg12363.html
03:13:20 <lambdabot> Title: Announce: Haskell Data Clustering
03:13:25 <ivanm> that site seems not to exist any more :s
03:13:26 <luqui> aeolist, but no, we already know which show function to call.
03:13:32 <luqui> we don't pattern match on that at runtime
03:13:43 <aeolist> true...
03:14:30 <EvilTerran> luqui, well, we *usually* don't deal with that at runtime :P
03:14:35 <ivanm> wait, I found it...
03:15:20 <Cale> So, as you print things to the screen, the putStrLn inside of the print function demands the results of applying show to the thing, and that demands that the data be evaluated more and more.
03:15:41 <EvilTerran> ?src Maybe show
03:15:41 <lambdabot> Source not found. My pet ferret can type better than you!
03:15:41 <Cale> Let's do some evaluation by hand using the map function and a list :)
03:15:51 <Cale> @src map
03:15:52 <lambdabot> map _ []     = []
03:15:52 <lambdabot> map f (x:xs) = f x : map f xs
03:16:23 <luqui> EvilTerran, where do we?
03:16:25 <Cale> So there's the source for map... let's evaluate map (*10) [1,2,3]
03:16:43 <Cale> map (*10) [1,2,3]
03:16:44 <luqui> EvilTerran, I mean, the dict is passed around, but that's not really a pattern match.
03:16:48 <aeolist> [1*10,2*10,3*10]?
03:16:57 <Cale> = map (*10) (1 : [2,3]) -- desugaring
03:17:02 <EvilTerran> luqui, yeah, i guess so
03:17:14 <Cale> -> (*10) 1 : map (*10) [2,3]
03:17:32 <EvilTerran> luqui, that only happens if you're using an extension or two, anyway, iirc
03:17:41 <Cale> Now, if we were trying to match  map (*10) [1,2,3]  against the pattern  (x:xs), we'd be done here.
03:17:49 <Cale> x = (*10) 1
03:17:53 <Cale> xs = map (*10) [2,3]
03:17:53 <EvilTerran> (i think you'd need one of Rank2Types, ExtistentialQuantification, or GADTs)
03:17:57 <luqui> EvilTerran, what?   no, surely dictionaries are passed in H98.
03:18:00 <Cale> No need to continue evaluating yet :)
03:18:07 <aeolist> yeah
03:18:15 <Axman6> Cale: you're responsible for lambdabot right?
03:18:19 <Cale> But let's say that then we wanted to check if x was positive
03:18:27 <luqui> EvilTerran, oh you're talking about pattern matching on typeclasses at runtime actually happens somewhere?  (I'm willing to believe it)
03:18:31 <Cale> then we'd have to apply the function and get 10 there
03:18:37 <Cale> Axman6: yes
03:18:55 <EvilTerran> luqui, well, you could see Typeable as pattern-matching on types
03:18:58 <Cale> Or if we wanted to pattern match further on the tail of the list, we'd have to apply map again
03:19:16 <EvilTerran> but i don't think you even need to pass dictionaries around at runtime if you don't use some extension that gives you existential types
03:19:22 <Axman6> any chance you could stop it joining #macosx? the populous complain about it -_-
03:19:25 <Cale> sure
03:19:31 <Axman6> cheers
03:19:39 <Cale> lambdabot: @part #macosx
03:20:10 <luqui> EvilTerran, I disagree.  it is necessary for separate compilation.
03:20:40 <luqui> EvilTerran, surely print = putStrLn . show needs a Show dictionary to know how to do its job
03:20:52 <aeolist> Cale: so the times function will not be applied unless i request the data from the list?
03:20:59 <Cale> aeolist: right.
03:21:06 <EvilTerran> luqui, ah, yes, good point
03:21:08 <ivanm> I'm playing with some code from the ghc-5.0.4 error, and ghc (6.8.3) is complaining that it can't find IOExts ... any one know where this module was moved to?
03:21:10 <Cale> aeolist: In fact, you have to demand that very element
03:21:27 <Cale> aeolist: if you were just calculating the length of the resulting list, no actual multiplication would get done
03:21:58 <EvilTerran> luqui, also, thinking about it, you might need them for arcane cases such as polymorphic recursion
03:22:02 <Cale> aeolist: because you wouldn't pattern match against the elements of the list, only against the conses making up its spine.
03:22:09 <aeolist> mmm, i wonder how the assembly code looks on that
03:22:12 <aeolist> *what
03:22:15 <Cale> (and the nil at the end)
03:22:16 <luqui> polymorphic recursion still frightens me a little
03:22:30 <EvilTerran> it is a little weird, yeah :)
03:23:06 <Cale> aeolist: Well, this is a slight lie with respect to GHC, but an easy implementation of this represents values as a boolean flag together with a pointer.
03:23:34 <aeolist> boolean flag-> evaluated/not evaluated ?
03:23:36 <Cale> aeolist: If the flag is unset, then the pointer points to code which when run, will set the flag and rewrite the pointer to point at the result (of evaluation)
03:23:50 <Cale> If the flag is set, then the pointer points at the result of course.
03:24:28 <aeolist> very nice :)
03:25:16 <Cale> and then you just need some convention for how data constructors are represented in memory, usually an integer, together with possibly some pointers to fields will do.
03:25:39 <aeolist> ghc uses c-- so it's not preoccupied with assembly but rather an intermediate level representation of lazy evaluation?
03:25:57 <Cale> C-- is strict... it's like a lower-level version of C
03:26:25 <Cale> Core however, is still basically lazy.
03:26:27 <aeolist> yes, it obviously has no "lazy mode"
03:26:29 <ibid> and i believe ghc uses c-- as an internal representation, and does conversion from it to machine language internally
03:26:48 <ibid> (so ghc is preoccupied with assembly:)
03:27:10 <aeolist> i thought c-- handles assembly generation + optimization
03:27:25 <ibid> there is a separate c-- implementation, but ghc does not use it
03:27:26 <ibid> i believe
03:27:30 <Cale> Most of the optimisation at the moment is done at the level of Core, afaik.
03:27:37 <aeolist> ok
03:27:57 <Cale> But the potential is there to do more after transformation to C--
03:28:13 <Cale> (It's just harder to do the big things at that point)
03:28:14 <Heffalump> the CPS transformation is being split out as a separate C-- pass
03:30:29 <Cale> aeolist: Also, with regard to what I said earlier, GHC is actually a bit fancier... values are always represented as simple pointers to code (the pointer is updated by the code to point at a routine that returns the result immediately on subsequent evaluations)
03:30:47 <Cale> (so there's no boolean flag)
03:31:08 <Cale> However, they now use the low-order bits of the pointer to represent part of the information about the value, sometimes.
03:31:38 <Cale> (since things are aligned in memory anyway)
03:32:32 <aeolist> ok
03:33:22 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html is a decent paper on how GHC basically does things
03:33:43 <Cale> Of course, there have been some changes since 1992 :)
03:34:09 <Cale> But to understand how things perform on an everyday basis, usually you don't need to go that low-level.
03:34:27 <Cale> Just manipulating expressions as text is usually good enough to get a feel for how the code will perform.
03:34:48 <Cale> (space is easily seen as the size of the expressions you have to evaluate :)
03:34:57 <aeolist> of course, i was just curious
03:41:20 <hackage> Uploaded to hackage: bimap 0.2.4
03:41:25 <aeolist> Cale: thanks a lot :)
03:42:13 <Cale> aeolist: http://hpaste.org/9914
03:42:31 <aeolist> O_O
03:42:38 <Cale> aeolist: It's a bit of work for a human to do it :)
03:43:10 <aeolist> (it is :))
03:43:22 <Cale> I computed the first 2 elements anyway :)
03:43:31 <Cale> (counting that 1 :)
03:44:15 <Cale> The next one is a bit more interesting, because you'll get a 4 from the start of map (2*) x1 which will lose to the 3
03:44:15 <aeolist> mmm, why does the evaluation begin on the right hand side?
03:44:36 <Cale> Because ~~ needs to pattern match
03:45:10 <Cale> Well, I parenthesized things... I suppose it also could be  (map (2*) hamming ~~ map (3*) hamming) ~~ map (5*) hamming ...
03:45:19 <Cale> It depends on the associativity of ~~
03:45:50 <aeolist> by default it is right associative then?
03:45:56 <Cale> I don't know...
03:46:17 <mauke> > let (~~) = const in 1 ~~ 2 ~~ 3
03:46:19 <lambdabot>  1
03:46:48 <mauke> huhu
03:46:58 <luqui> Cale, things are infixl 5 by default, right?
03:47:12 <Cale> > let (~~) = concat ["(",show x,"~~",show y,")"] in 1 ~~ 2 ~~ 3
03:47:13 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
03:47:22 <Cale> > let x ~~ y = concat ["(",show x,"~~",show y,")"] in 1 ~~ 2 ~~ 3
03:47:24 <lambdabot>  "(\"(1~~2)\"~~3)"
03:48:08 <Cale> > let x ~~ y = concat ["(",x,"~~",y,")"] in "1" ~~ "2" ~~ "3"
03:48:10 <lambdabot>  "((1~~2)~~3)"
03:48:14 <Cale> yeah, left :)
03:48:35 <Cale> It was something like that... I forget. I'd have to check the report.
03:48:45 <EvilTerran> infixl 9, i believe
03:49:21 <Cale> "Any operator lacking a fixity declaration is assumed to be infixl 9"
03:49:22 <Cale> yep
03:49:42 <luqui> EvilTerran, right, just found that by experiment.
03:50:21 <Cale> But, in this case, the fixity doesn't matter *so* much, since ~~ is associative here anyway :)
03:50:50 <cjs> Hm. Any thoughts on what it means when I try to do a Cabal build under Windows and get "During interactive linking, GHCi couldn't find the following symbol: SHGetFolderPathA@20"?
03:50:57 <cjs> The build works ok under Unix.
03:51:27 <jn> im a newbie, can someone fix my code: http://hpaste.org/9915?
03:51:40 <Zao> cjs: Do you use --make?
03:51:49 <dcoutts_> cjs: use --make, for a detailed explanation see http://hackage.haskell.org/trac/hackage/ticket/325
03:51:51 <lambdabot> Title: #325 (SHGetFolderPath requiered to configure cabal 1.4) - Hackage - Trac
03:52:17 <Zao> Otherwise, link against shell32
03:53:14 <Cale> jn: Well, in the class declaration for Pair, you claim that  first  takes a value of type 'a' (which is the class parameter) and produces any type whatsoever 'b'
03:53:22 <cjs> I'm using runhaskell to run a Cabal setup script, in this instance.
03:53:24 <BONUS> jn: what do you want to achieve with the Pair class and the Cons type?
03:54:14 <Cale> jn: Note that you are not saying simply that there exists a type b so that first :: a -> b, but that for all types b, first :: a -> b
03:54:15 <jn> bonus: simply create a typed pair list, with Nil as the terminator
03:54:25 <Zao> cjs: ghc --make Setup && Setup.exe configure ...
03:54:27 <dcoutts_> cjs: right, so ghc --make Setup; Setup.exe
03:54:39 <Cale> jn: The easiest thing to base that on is the ordinary Haskell pair type.
03:54:41 <cjs> I see.
03:54:51 <dcoutts_> cjs: or use cabal-install
03:54:57 <Cale> (and fst, snd)
03:55:17 <jn> cale: but that doesnt restrict the second type to be a pair or nil
03:55:19 <dcoutts_> cjs: hmm, so this happens for every Setup.hs, not just the one in the Cabal package itself?
03:55:28 <cjs> I'm not sure. I build that one first.
03:55:43 <cjs> I'm thinking that using the compiler may be the best solution here.
03:56:07 <BONUS> why not do, uh .. data Pair a b = Pair a b and then data PairList a b = (a,b) | Cons (a,b) (Pairlist a b)
03:56:07 <cjs> But I just realized my symlink trick for the work dir is not going to work under Windows.
03:56:08 <dcoutts_> cjs: it's because the gcc linker automatically links to the win32 libs, but the ghci linker does not
03:56:18 <cjs> Why is that?
03:56:20 <Cale> jn: That is true... we could impose that restriction to a degree by doing something similar to what you're doing. However, I think you'll have more luck if the Pair class has no functions in it. :)
03:56:25 <BONUS> wait, you don't need the first data type then
03:56:31 <dcoutts_> cjs: and Cabal has to ffi import a couple win32 functions
03:56:54 <Cale> jn: (just use it to restrict the types that Cons can construct)
03:56:55 <dcoutts_> cjs: oh, maybe it does, but a smaller set of win32 libs, this function is from a shell32.dll or something, it's less standard
03:57:20 <cjs> Right. Ok, well, I can work around this, I'm sure. Darn Windows.
03:57:32 <dcoutts_> cjs: lemme know if it happens for any other Setup.hs other than the one for the Cabal package itself.
03:57:34 <jn> cale: but how would i then write polymorphic functions on the Pair type?
03:57:39 <cjs> I will.
03:57:54 <Cale> jn: Note also that there's no way to prevent someone from constructing a value like Cons Integer Integer, only to ensure that the only such value is undefined.
03:58:07 <BONUS> wait hmm
03:58:27 <Cale> jn: fst and snd are polymorphic
03:58:29 <Cale> :t fst
03:58:31 <lambdabot> forall a b. (a, b) -> a
03:58:34 <Cale> :t snd
03:58:35 <lambdabot> forall a b. (a, b) -> b
03:58:54 <Cale> But they don't use typeclasses, just "normal" parametric polymorphism
03:58:58 <jn> cale: data Pair b => Cons a b = Cons a b, doesnt that restrict the second parameter to be a Pair?
03:59:29 <Cale> jn: It restricts the type of the Cons data constructor so that the second parameter is an instance of Pair
03:59:52 <Cale> However, undefined :: Pair Integer Integer  is still valid
03:59:58 <Cale> er
04:00:04 <Cale> However, undefined :: Cons Integer Integer  is still valid, rather
04:00:16 <Cale> :t undefined
04:00:17 <lambdabot> forall a. a
04:00:35 <jn> hmm, thats weird
04:00:38 <Cale> But that's a minor point...
04:01:15 <BONUS> jn: how about this http://hpaste.org/9915#a1
04:01:17 <jn> are you saying my attempt is doomed to fail?
04:01:19 <Cale> Well, the class context in data declarations has always been stupid.
04:02:01 <Cale> (In fact, inside GHC, it is explicitly referred to as "the stupid context") All it does is restrict the type of the data constructor. It does not give you any extra convenience.
04:02:51 <jn> bonus: thats not what i want, i want something like: (Int, (Float, (Bool, Nil)))
04:03:08 <Cale> jn: Is there any reason not to just use that type there?
04:03:12 <BONUS> oh
04:03:28 <EvilTerran> jn, sounds like you want Oleg's HList or similar
04:03:31 <jn> cale: i want the restriction on "tail" if possible
04:03:41 <jn> type restriction
04:04:28 <Cale> I suppose the problem is that the type system itself is mostly untyped.
04:04:34 <mm_freak> permutations xs = [ y:ps | y <- xs, ps <- permutations (delete y xs) ]   -- how can i get rid of the 'delete'?
04:04:47 <BONUS> why would you get rid of the delete
04:04:51 <BONUS> its an integral part of the algorithm
04:04:54 <BONUS> ???
04:05:11 <Cale> So there's no way to impose that restriction at the type level. You can only ensure that there are no defined values of types where the second part of the pair is not Nil or another pair.
04:05:43 <Cale> mm_freak: first I recommend writing  select :: [a] -> [(a,[a])]
04:06:01 <Cale> mm_freak: which gives a list of pairs consisting of an element of the original list, together with the rest of the elements
04:06:08 <Cale> mm_freak: From there, it should be easy :)
04:06:13 <EvilTerran> BONUS, except it's not - consider permutations [1,1,2]
04:06:46 <BONUS> ah
04:06:52 <BONUS> yeah you get duplicate solutions
04:06:58 <BONUS> hmm
04:07:14 <idnar> I wrote:
04:07:21 <jn> cale: ok, thanks
04:07:34 <EvilTerran> BONUS, it's more that you should be able to write permutations without an Eq constraint on the list elements
04:07:38 <Cale> jn: and you might want to check out HList, I suppose :)
04:07:44 <idnar> http://hpaste.org/9917
04:07:46 <mm_freak> Cale: i'd like to get rid of Eq, since it's not strictly needed, but without Eq, 'select' cannot be written in an elegant way
04:07:47 <BONUS> hmm, interesting
04:07:52 <idnar> (guess the bot is still broken?)
04:08:04 <Cale> mm_freak: it can too be written in an elegant way :)
04:08:09 <Cale> mm_freak: well, recursively :)
04:08:15 <idnar> I guess select is what I called "choices"
04:08:17 <EvilTerran> you should be able to permute them just looking at their indices, not their values
04:08:24 <idnar> it's not quite what I'd call elegant, though
04:08:29 <mm_freak> Cale: ah, i've got an idea
04:08:31 <idnar> but
04:08:40 <idnar> there's a much quicker way to determine a particular permutation
04:08:48 <idnar> with factoradics :P
04:08:53 <EvilTerran> > zip <$> inits <*> tails $ "abracadabra"
04:08:55 <lambdabot>  [("","abracadabra"),("a","bracadabra"),("ab","racadabra"),("abr","acadabra")...
04:09:19 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
04:09:21 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
04:09:29 <Cale> How about that?
04:10:50 <mm_freak> Cale: thanks, although i'd like to have done it myself ;)
04:11:35 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 3 (StateT select)) [1,2,3]
04:11:37 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
04:11:59 <Cale> (okay, that's a bit evil of me :)
04:12:09 <nornagon> o.o
04:12:24 <EvilTerran> cunning. i like it. :)
04:12:32 * EvilTerran groks it, i think...
04:12:40 <nornagon> :t evalStateT
04:12:42 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
04:12:45 <nornagon> :t StateT
04:12:47 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
04:12:52 <nornagon> aha
04:13:02 <EvilTerran> using the StateT [Int] [] monad, i think
04:13:11 <Saizan> yup
04:13:16 <Cale> yeah
04:13:24 <mm_freak> Cale: and it's wrong ;)
04:13:34 <Cale> wrong?
04:13:35 <mm_freak> you'd need a 'nub' pass with that one
04:13:42 <mm_freak> oh
04:13:43 <Cale> nub?
04:13:46 <EvilTerran> no you don't
04:13:48 <mm_freak> it was actually a different thing
04:13:59 <mm_freak> ignore me =)
04:13:59 <EvilTerran> if you have duplicates in the input, you should have duplicates in the output
04:14:18 <mm_freak> no, i was still at 'select'
04:14:56 <Cale> That is a little problem with using delete, is that it always deletes the first one... so if you have an instance of Eq which is an equivalence relation and not strict equality, you'll end up with funny things :)
04:15:29 <mm_freak> yeah…  that's why i'd like to get rid of delete
04:16:01 <EvilTerran> Cale, and any use of delete would be relying on the values, which still strikes me as the Wrong Thing
04:16:09 <Cale> EvilTerran: right
04:16:11 <EvilTerran> ugly from a theoretic standpoint
04:16:21 <EvilTerran> which manifests itself as that stray Eq constraint
04:16:24 <EvilTerran> even if it works
04:16:44 <Cale> お休み。。。I should sleep :)
04:17:07 * EvilTerran sees... er... japanese?
04:17:25 <BONUS> someone has been watching too much anime
04:23:20 <mm_freak> that's hiragana
04:23:41 <jrockpunk1> hi
04:24:23 <jrockpunk1> i need some help, what do i replace "letter" (obviously not a function with in this code?
04:24:25 <jrockpunk1> main = interact wordCount
04:24:25 <jrockpunk1> 	where wordCount input = show (length (letters input)) ++ "\n"
04:24:41 <cjs> Hm. So if the specified package.conf doesn't exist, Cabal's configure refuses to run.
04:24:45 <mauke> filter isAlpha
04:24:58 <dcoutts_> cjs: echo [] >
04:24:58 <BeelsebobWork_> jrockpunk1: words?
04:25:01 <cjs> Which is not too helpful if you're trying to create it.
04:25:04 <cjs> Right. I did that.
04:25:13 <cjs> It somehow doesn't seem so portable to me.....
04:25:22 <jrockpunk1> BeelsebobWork_
04:25:22 <dcoutts_> cjs: thing is, Cabal does not (and cannot) know the format of the compilers pacage db.
04:25:25 <jrockpunk1> no ive done that
04:25:30 <BeelsebobWork_> jrockpunk1: main = interact $ (++"\n") . show . length . words
04:25:39 <jrockpunk1> the exercise says to count the "characters"
04:25:42 <cjs> Right, and I note that there's no ghc-pkg command to create a new package db, without actually registering one.
04:25:54 <dcoutts_> cjs: if we want auto-create behaviour then we need to extend ghc-pkg to not fail on non-existant dbs, or add a command to make a new empty db.
04:25:54 <mauke> jrockpunk1: then just (length input)
04:25:58 <BeelsebobWork_> jrockpunk1: oh, don't call it word count then -- and just take the length of the string
04:26:08 <dcoutts_> cjs: also, there's nothing that says that the package db must be a file.
04:26:10 <jrockpunk1> ah ok
04:26:12 <jrockpunk1> i see
04:26:13 <jrockpunk1> thanks
04:26:23 <cjs> But would it be reasonable for cabal to just do the creation commands, if the read fails?
04:26:24 <cjs> Hmmm.
04:26:27 <cjs> Right.
04:26:29 <cjs> Difficult.
04:26:55 <BeelsebobWork_> jrockpunk1: in the mean time.. yay! someone using interact
04:27:00 <BeelsebobWork_> interact is made of win and awesom
04:27:06 <dcoutts_> cjs: maybe
04:27:20 <jrockpunk1> interact?
04:27:52 <BeelsebobWork_> the function you're calling to accept the input
04:28:04 <jrockpunk1> oh
04:28:07 <cjs> I'll think about it. Though probably the simplest thing is just to give package managers a "create new package db" command, and let the user create it if he needs to.
04:28:08 <BeelsebobWork_> it's *way* more powerful than most people give it credit for
04:28:13 <dcoutts_> cjs: I'm not sure what the ideal solution is, but it's only a minor annoyance at the moment I'd say.
04:28:14 <cjs> That way you don't accidenly create new package DBs.
04:28:28 <dcoutts_> cjs: but feel free to file a ticket so we do not forget
04:28:50 <cjs> Let me contemplate it some more.
04:28:56 <cjs> Gotta run. See you guys later.
04:29:50 <BeelsebobWork_> dcoutts: hmm, I just thought of another possible solution to the development/cabal problem I was having
04:30:09 <BeelsebobWork_> the option to specify "just check out a new copy from darcs" as a version would be lovely
04:32:18 <dcoutts_> BeelsebobWork_: we do want to let people add source repo urls into .cabal files
04:32:48 <BeelsebobWork_> because of forwards compatability issues?
04:33:03 <jrockpunk1> aargh
04:33:06 <jrockpunk1> i dont get it
04:33:16 <jrockpunk1> main = interact wordCount
04:33:16 <jrockpunk1> 	where wordCount input = show (length (words input)) ++ "\n"
04:33:25 <jrockpunk1> now how do i make it count the letters?
04:33:30 <jrockpunk1> im too used to C :(
04:33:40 <BeelsebobWork_> jrockpunk1: take the length of the input
04:33:45 <BeelsebobWork_> not the length of the list of words in the input
04:33:53 <jrockpunk1> instead of words i pt length?
04:33:53 <BeelsebobWork_> i.e. don't break it into words at all
04:34:01 <BeelsebobWork_> just remove words
04:34:03 <jrockpunk1> oh ok
04:34:04 <jrockpunk1> lol
04:34:05 <mauke> jrockpunk1: then just (length input)
04:34:10 <jrockpunk1> i get it
04:34:18 <jrockpunk1> shit i only started learning it lasyt night
04:34:29 <BeelsebobWork_> main = interact $ (++"\n") . show . length
04:34:42 <mauke> BeelsebobWork_: hax
04:34:43 <jrockpunk1> or
04:34:45 <jrockpunk1> main = interact wordCount
04:34:45 <jrockpunk1> 	where wordCount input = show (length input) ++ "\n"
04:34:45 <mm_freak> subsets [] = [[]]
04:34:45 <mm_freak> subsets xs = xs : [ ss | (_,ys) <- select xs, ss <- subsets ys ]
04:34:53 <BeelsebobWork_> jrockpunk1: that too
04:34:54 <mm_freak> how can i remove duplicates without using 'nub'?
04:35:02 <BeelsebobWork_> mm_freak: hmm?
04:35:08 <mauke> S.toList . S.fromList
04:35:12 <BeelsebobWork_> why don't you want to use the duplicate-romoval function?
04:35:13 <mm_freak> see above, the 'subsets' function
04:35:28 <mm_freak> BeelsebobWork_: i'd like not to generate the duplicates in the first place
04:35:33 <BeelsebobWork_> oh, I se
04:36:00 <BeelsebobWork_> mm_freak: how about working with the Set data type instead of the list one
04:36:06 <BeelsebobWork_> if you want to use sets, use them
04:36:08 <lilac> mm_freak: map S.toList . subsets' . S.fromList
04:36:22 <lilac> (where subsets' is subsets on a set rather than a list)
04:36:36 <mauke> > filterM (return [True,False]) "wtf"
04:36:38 <lambdabot>  ["wtf","wt","wf","w","tf","t","f",""]
04:36:56 <BeelsebobWork_> mauke: that's evil
04:37:18 <mm_freak> ok, but where is that 'subsets' function?
04:37:33 <lilac> mm_freak: or subsets . nub . sort
04:37:42 <yitz> @index subsets
04:37:43 <lambdabot> bzzt
04:37:44 * luqui perplexes whether mauke's subsets is efficient...
04:37:48 <yitz> @type subsets
04:37:50 <lambdabot> Not in scope: `subsets'
04:38:00 <mm_freak> > subsets "abc"
04:38:00 <mm_freak> ["abc","bc","c","b","ac","c","a","ab","b","a"]
04:38:01 <lambdabot> Terminated
04:38:07 <mm_freak> that's the current state of things
04:38:08 <yitz> wasn't this added by twan?
04:38:22 <yitz> ah, yes
04:38:40 <mm_freak> it works, but generates duplicates
04:39:08 <luqui> mm_freak, iff there are duplicates in your input, right?
04:39:14 <mm_freak> luqui: no
04:39:17 <mm_freak> see above
04:39:27 <luqui> mm_freak, oh, also it's missing the empty set
04:39:36 <yitz> wha? where is \bot getting that from? i'm pretty sure twan's is correct
04:39:38 <mm_freak> the empty set is easy to add
04:39:50 <mm_freak> > subsets "abc"
04:39:50 <mm_freak> ["abc","bc","c","","b","","ac","c","","a","","ab","b","","a",""]
04:39:51 <lambdabot> Terminated
04:39:57 <mm_freak> code:
04:39:58 <mm_freak> subsets [] = [[]]
04:39:59 <mm_freak> subsets xs = xs : [ ss | (_,ys) <- select xs, ss <- subsets ys ]
04:40:08 <luqui> mm_freak, yeah, but if your function doesn't do it by itself, it's a good indicator that it's not implemented correctly
04:40:20 <yitz> mm_freak: is that a @let of yours?
04:40:22 <mauke> where's the Functor instance for (,) a?
04:40:23 <mm_freak> luqui: yes, that's my point ;)
04:40:27 <mm_freak> yitz: no
04:40:44 <yitz> this is weird.
04:40:44 <luqui> mm_freak, oh about not wanting to use nub.  agreed.
04:41:11 <luqui> mm_freak, mauke's was beautiful, no?
04:41:15 <mm_freak> ok, let me ask in other words:  what would a function to generate all subsets look like?
04:41:20 <luqui> but you probably want to do it yourself
04:41:33 <mm_freak> i don't understand mauke's function, so i won't use it
04:41:37 <luqui> :-)
04:42:04 <lilac> luqui: i think mauke's subsets isn't efficient; it looks like it works out the tails multiple times
04:43:14 <luqui> mm_freak, do it inductively, with equational reasoning.  subsets [] = [[]]
04:43:17 <luqui> is a good start
04:43:33 <luqui> then try, canonically, the next pattern:  subsets (x:xs) = ?
04:43:52 <Philonous> @src select
04:43:54 <luqui> how is the set of subsets of A u {x} related to the set of subsets of A?
04:43:55 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:44:05 <Philonous> @type select
04:44:07 <lambdabot> Not in scope: `select'
04:44:23 <Philonous> mm_freak: Just out of curiosity, where does your select come from?
04:44:47 <mm_freak> Philonous: see above…  select returns a list of duples of all elements and the remaining list with that element removed
04:45:17 <mm_freak> select "abc" == [('a', "bc"), ('b', "ac"), ('c', "ab")]
04:45:32 <mm_freak> luqui: thanks, i'll give it a try
04:45:38 <Philonous> Ah ok. So it's a simple zipper
04:45:48 <Philonous> At least kind of ^^
04:46:13 <mm_freak> dunno =)
04:46:53 <luqui> Philonous, it's a set zipper, I think.
04:48:05 <luqui> duplicate "abc" = (('a',"bc"),[('b',"ac"), (c,"ab")])
04:48:17 <luqui> er, duplicate ('a',"bc")
04:49:10 <mauke> @pl concatMap (\ys -> [x : ys, ys])
04:49:10 <lambdabot> (liftM2 (:) (x :) return =<<)
04:49:15 <r3m0t> @hoogle [a] -> [([a],[a])]
04:49:16 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
04:49:16 <lambdabot> Network.CGI.Protocol formDecode :: String -> [(String, String)]
04:49:16 <lambdabot> Network.CGI.Cookie readCookies :: String -> [(String, String)]
04:54:39 <yitz> @djinn [a] -> [([a], [a])]
04:54:48 <mauke> bzzt
04:55:04 <mauke> well, f x = [(x, x)]
04:55:18 <yitz> @vixen lambdabot, are you still ok?
04:55:18 <lambdabot> i'm just fine, why do you ask?
04:55:24 <yitz> whew
04:55:28 <mauke> @djinn a -> a
04:55:28 <lambdabot> f a = a
04:55:33 <mauke> @djinn a -> b
04:55:34 <lambdabot> -- f cannot be realized.
04:56:54 <yitz> @pl \x -> zip (inits x) (tails x)
04:56:54 <lambdabot> liftM2 zip inits tails
04:59:02 <mauke> > liftM2 zip inits tails [a,b,c,d]
04:59:04 <lambdabot>  [([],[a,b,c,d]),([a],[b,c,d]),([a,b],[c,d]),([a,b,c],[d]),([a,b,c,d],[])]
04:59:05 <BeelsebobWork_> liftA2!!!!!
04:59:16 <Philonous> mm_freak: Maybe you should build the subsets from bottom to top, starting with the one-element lists and adding elements until you finally get the full list, backtracking to previous stages
04:59:43 <mm_freak> Philonous: yeah, that's a good idea
04:59:48 <mm_freak> i'll try
04:59:53 <luqui> BeelsebobWork_, you have a problem with monads?
05:00:01 <r3m0t> @pl \x -> concatMap (\ys -> [x:ys,ys])
05:00:01 <lambdabot> (=<<) . (`ap` return) . ((:) .) . (:)
05:00:24 <BeelsebobWork_> luqui: bad! but I have a problem with using liftM2 where you could use liftA2 and be more general
05:00:43 <luqui> BeelsebobWork_, inits and tails are both (->), liftA2 is no more general
05:00:53 <mauke> :t ap (all . (==)) (map (uncurry (++)) . liftM2 zip inits tails)
05:00:55 <lambdabot> forall a. (Eq a) => [a] -> Bool
05:00:59 <mauke> @check ap (all . (==)) (map (uncurry (++)) . liftM2 zip inits tails)
05:00:59 <BeelsebobWork_> oh, fair point luqui
05:01:01 <lambdabot>  "OK, passed 500 tests."
05:01:09 <BeelsebobWork_> still, I have a problem with monads :P
05:01:20 <luqui> yeah, they are used too much
05:01:34 <BeelsebobWork_> yep, but I'll give you that that was a valid use of them
05:03:05 <lilac> reader monad is a good way to obfuscate
05:04:45 <BeelsebobWork_> hmm, /me ponders why obfuscation comes so naturally to Haskellers
05:07:43 <luqui> no, perl programmers obfuscate.  haskell programmers abstrafuscate
05:07:52 <BeelsebobWork_> lol
05:08:01 <BeelsebobWork_> see, you even obfuscated the word for obfuscation
05:08:39 <luqui> did not.  portmanteaux are not obfuscation!
05:09:14 <luqui> they're obfusteaux!
05:12:17 <lilac> > fix $ (0:).(1:).((head >>= (:)) =<<).group
05:12:19 <lambdabot>  [0,1,0,0,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1...
05:15:24 <qebab> wha
05:16:23 <luqui> okay, fine, _that_ is obfuscation
05:16:29 <luqui> plain and simple
05:16:47 <BeelsebobWork_> see what I mean
05:17:05 <BeelsebobWork_> same with filterM (return [True,False])
05:17:17 <luqui> no, I don't think that one is obfuscated
05:17:34 <luqui> it takes a little decoding, but it reflects a truth
05:17:42 <BeelsebobWork_> hmm
05:17:54 <BeelsebobWork_> so you would say that it's only obfuscated when it leads you to an incorrect conclusion?
05:18:04 <BeelsebobWork_> not when it takes you a long time to reach the correct conclusion
05:18:57 <luqui> I'm having trouble making it precise
05:19:46 <BeelsebobWork_> see, I actually see fix $ (0:) . (1:) . ((head >>= (:)) =<<) . group as being less obfuscated than filterM (return [True,False])
05:19:52 <luqui> the filterM is actually quite beautiful, in that it reflects that for each element, there is a set where it is present and one where it is not
05:20:02 <BeelsebobWork_> it's beautiful
05:20:10 <BeelsebobWork_> but hard to figure out what it does until you realise it
05:20:20 <mauke> the obfuscated part in filterM (return [True,False]) is the 'return'
05:20:29 <luqui> whereas the fix $ example is hard to figure out what it does... even after you realize it
05:20:37 <luqui> mauke, that's true
05:20:42 <luqui> const would be prettier
05:21:44 <BeelsebobWork_> luqui: I recon I could have a really good stab at the fix$ example
05:21:50 <BeelsebobWork_> I'm not so sure I could at the filterM one
05:22:11 <luqui> ah, that is where you and I differ :-)
05:22:16 <luqui> I feel the opposite
05:22:49 <luqui> I'd have to get a text editor out at least to even begin (well I guess I could get the first two elts ;-) on the fix one
05:23:03 <BeelsebobWork_> okay, well -- here's my stab.  Attach 0 to the front of something, where the something has 1 attached to the front.  The thing that you stick 01 on the front of is made by grouping stuff up, taking the head of each of them, and consing another one on
05:23:06 <BeelsebobWork_> there you go
05:24:22 <luqui> it's the ((head >>= (:)) =<<) that confuses me
05:24:38 <luqui> wtf does that mean?
05:25:15 <Saizan> ?type (head >>= (:))
05:25:17 <lambdabot> forall a. [a] -> [a]
05:25:21 <BeelsebobWork_> it takes the head of each part of the list, and it conses the resulting thing onto the front
05:25:31 <mm_freak> i'm failing to write that subsets function =/
05:25:35 <BeelsebobWork_> so [1,1,1,1] becomes 1:[1,1,1,1]
05:25:47 <BeelsebobWork_> mm_freak: filterM (const [True,False])
05:25:58 <mauke> subsets (x : xs) = concatMap (\ys -> [x : ys, ys]) (subsets xs)
05:26:01 <luqui> mm_freak, so tell me in english, how does the set of subsets of A union {x} relate to the set of subsets of A ?
05:26:21 <Philippa> BeelsebobWork_: Actually, it's effectively Haskell/the list-as-nondeterminism monad's "cut"
05:26:26 <mm_freak> BeelsebobWork_: i'd rather not use a function i don't understand
05:26:31 <Philippa> because the >>= is the list >>=
05:26:32 <luqui> Philippa, what is "cut"?
05:27:01 <Philippa> luqui: it's the thing that makes prolog impure as all hell :-) "If you get this far, it's this or nothing"
05:27:30 <mauke> commit
05:28:06 <luqui> ah i see.
05:28:18 <Philippa> and, uh, take what I just said with a pinch of salt, I've just re-read enough to be reminded that it's effectively morning for me and I'm not too awake yet :-)
05:28:35 <luqui> mm_freak, or rather, just tell me how *many* there will be, in relation to how many subsets of A there are.
05:28:56 <Saizan> it would be a sort of cut if you discarded the rest of the list instead of consing, but prolog's cut is more invasive afaiu
05:28:59 <luqui> mm_freak, or rather, just tell me how *many* there will be, in relation to how many subsets of A there are.
05:30:19 <BeelsebobWork_> Philippa: I'm missing why my description was innacurate in the specific case we're looking at here
05:30:56 <mm_freak> luqui: if A union {x} has 2^(n+1) elements, then A has 2^n
05:31:01 <mm_freak> map subsetOf
05:31:03 <mm_freak> map subsetsOf, that is
05:31:21 <luqui> mm_freak, sure.  so there are twice as many subsets of A union {x} as there are in A
05:31:25 <BeelsebobWork_> luqui: I suspect the problem I have is that the whole of the filterM example acts "like magic" in that you need to think about it to figure it out
05:31:30 <luqui> does that tell you something about the structure of the solution?
05:31:38 <BeelsebobWork_> otoh, the fix $ example only had a small part of it made up of magic
05:31:40 <luqui> BeelsebobWork_, haha :-)
05:31:52 <mm_freak> luqui: yes, i'll try again
05:32:48 <mauke> hint: don't try to use select
05:32:50 * luqui really needs to go to bed now.  quick, before anyone says anything interesting!
05:32:58 <luqui> night
05:35:12 <Saizan> BeelsebobWork_: where magic is non-determinism?
05:35:24 <BeelsebobWork_> Saizan: hmm, plausable
05:36:29 <BeelsebobWork_> I was using it to mean "something you have to really think about to figure out why it's not magical", but it could be that that set is roughly equal to non-determanistic things
05:38:28 <Saizan> in that case i think it's more like ad-hoc polymorphism, i.e. the ability to use a more general identifier for a certain function
05:42:33 <BeelsebobWork> Saizan: that certainly is one example where I find Haskellers obfuscate -- they use very general functions in non-general situations, where the specialisation would help understanding a lot
05:43:33 <lilac> BeelsebobWork: i think the filterM example is not that bad when written as "filterM (const [True, False])" not as "filterM (return [True, False])"
05:43:51 <BeelsebobWork> lilac: I think I agree with you when you make it const too
05:44:16 * lilac thinks that mixing two monads in one expression is seldom a good idea :)
05:44:29 <mauke> don't cross the monads!
05:44:34 <BeelsebobWork> >.<
05:45:39 <BeelsebobWork> also yes lilac, that's pretty accurate
05:45:52 <BeelsebobWork> one of the reasons I don't like monads much -- because they get obfuscated very quickly when you use more than one
05:46:02 <BeelsebobWork> or more often than not, just don't work at all
05:46:28 <besiria> i'm on a windows system right now. System.Directory.getHomeDirectory reports sth different than my HOME env var
05:46:46 <besiria> any1 knows why is that?
05:53:33 <gwern> 'And what's the difference between a terrorist and an object methodologist? You can negotiate with the terrorist.'
05:54:10 <BeelsebobWork> heh
05:57:01 <lilac> > (>>= replicate 3) >>= (++) >>= (. return) . ap . fmap intersperse . listToMaybe $ "hello"
05:57:03 <lambdabot>  Just "hhehlhlho"
06:20:21 <Elly> first day of classes, w00t :)
06:22:50 <BeelsebobWork> @hoogle (a -> b) -> (a -> c) -> a -> (b,c)
06:22:51 <lambdabot> No results found
06:22:55 <BeelsebobWork> :(
06:23:04 <ddarius> :t (&&&)
06:23:06 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:23:07 <BeelsebobWork> oh, duh
06:23:09 <BeelsebobWork> cheers
06:25:18 <mapreduce> I've been offline reading the Haskell wikibook as a PDF.  It only has a complete example of an instance of Arrow, the function arrow ( -> ).  Sadly I think I need a harder example to get it.
06:25:52 <mapreduce> Plus an example of some code that operates over arrows in general to do something useful.
06:26:19 * Wild_Cat is only starting to "get" monads, and just now learned about this "arrows" thing. ::sigh:: Still a long, long way to go.
06:26:39 <Botje> fortunately
06:26:39 <dcoutts> Wild_Cat: you probably do not need arrows.
06:26:43 <pgavin> mapreduce: there aren't too many arrow implementations yet
06:26:46 <Botje> arrows are less mind-bending than monads
06:26:53 <dcoutts> Wild_Cat: functors, applicative function and monads are almost always enough.
06:26:57 <dcoutts> ops
06:27:16 <pgavin> some concepts map very nicely to arrows though :)
06:27:18 <dcoutts> applicative functors,
06:27:30 <Wild_Cat> good. But still, I'll have to learn about arrows at some point. I hate leaving areas of a language unexplored "because they're too magical for me".
06:28:00 <dcoutts> Wild_Cat: I've been using Haskell for 7 years and never needed an arrow
06:28:11 <mapreduce> Arrows look like they'll be useful in my work, particularly for stream processing.
06:28:21 <dcoutts> (or is it 8 years)
06:28:32 <Botje> everyone is using Spears instead
06:28:36 <Botje> more pointy and hurty
06:28:48 <Peaker> arrows are like monads with slightly less expressiveness - allowing for a lot more analysis to take place statically before their execution
06:28:53 <Wild_Cat> Botje: yeah, but drugs and all may mean we'll soon have to switch to using Winehouse.
06:29:00 <mapreduce> Goddamn, red on black is too unreadable..  I can read what everyone else wrote, but not what I did. :)
06:29:20 <Botje> "tryin' to make me do I-O but I say nooo nooo no"
06:29:31 <mapreduce> Arrows look like they are easier to type in languages without higher kinds/ranks.
06:30:18 <Peaker> Wild_Cat: while a monadic bind is allowed to use execution-time results (the "a" in   m a -> (a -> m b) -> m b) to compose between the monads, building an arrow must take place before any execution takes place - this limits what you can do as an arrow user, but gives great power to what you can do as an arrow implementor
06:30:30 <pgavin> mapreduce: well, you need exactly that same features that get you Monads
06:30:42 <Peaker> with monads, you can't do any static analysis on the monad before execution
06:31:01 <Peaker> that is the primary difference, imo
06:31:03 <mapreduce> Peaker: What static analysis can you do with an arrow?
06:31:32 <Peaker> mapreduce: for example, you can statically figure out which inputs are going to affect which outputs, or build a parse-FSM ahead of parsing
06:31:40 <mapreduce> I have a feeling that actors (as in Erlang, Scala) are arrows.
06:31:58 <pgavin> doing the static analysis is a lot easier said than done
06:32:22 <Peaker> I wrote something that does the first - and there's an arrow-parser-lib that does the latter
06:32:26 <pgavin> because the arrow operators can't look at or do anything with the inputs or outputs
06:32:39 <pgavin> except pass them on to other functions
06:32:40 <Peaker> and I'm no Haskell expert, btw, I barely wrote 5 little toys with it :)
06:33:09 <Mitar> what would be a portable way of reading presses from arrow keys? so that i could get press down, press up and similar events? I could use GLUT but i would only need key presses, not graphic, is there something simpler for this?
06:33:19 <Wild_Cat> Peaker: right. I guess I'll understand all that once I start writing my own monads ;)
06:33:45 <pgavin> Mitar: what are you using for your interface?
06:33:53 <Mitar> nothing yet ... there is no interface
06:33:57 <pgavin> Mitar: is it just a console program then?
06:34:01 <Mitar> i just need to get key presses
06:34:06 <Peaker> Wild_Cat: When I first read about monads, I "got" them by carefully reading and understanding the State monad implementation
06:34:14 <Mitar> for now it is just a program which runs and writes to serial port
06:34:16 <pgavin> Mitar: curses?
06:34:57 <Peaker> Wild_Cat: It also helped me to think of the semicolon in C as the >> operator :-)
06:35:04 <Mitar> http://www.informatik.uni-freiburg.de/~wehr/software/haskell/#hscurses?
06:35:11 <lambdabot> Title: Haskell Software, http://tinyurl.com/0
06:35:26 <Mitar> or something else?
06:36:12 <pgavin> Mitar: yeah, try using that
06:37:20 <Wild_Cat> Peaker: yeah, that I least I understood early on. Well, on my 2nd try, really -- my first try was back at Uni where the teacher didn't deem it necessary/interesting to tell us about the do notation.
06:37:21 <mapreduce> So is there something I could read that would explain arrows more in terms of processing streams of data?
06:37:39 <mapreduce> Or if not, then at least anything above the -> arrow, in complexity.
06:37:50 * mapreduce runs off to google to answer his own questions.
06:38:02 <pgavin> mapreduce: http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
06:38:07 <lambdabot> Title: Programming with Arrows
06:38:12 <Wild_Cat> (needless to say, boy were we glad that the exam only required us to write pure stuff to be run from the hugs prompt :p )
06:38:14 <pgavin> that's pretty much the best paper on the subject
06:38:33 <mapreduce> I have that.
06:40:52 <mapreduce> On an unrelated subject, I was wondering about how you'd go about taking a dynamic language such as Erlang and make it statically typed with as little change as possible.  One thing I thought was, if a function appeared to return an Integer in some cases and a String in others, why not implicitly make it Either Integer String and add the Left and Right calls automatically?
06:41:07 <mapreduce> Then I thought.. why does Haskell not already do this?
06:41:29 <pgavin> mapreduce: then Either would have to be built in to the compiler
06:41:38 <mapreduce> Yes.
06:41:40 <pgavin> and not just in the libs
06:41:57 <pgavin> and that wouldnt necessariy be coherent
06:42:45 <Mitar> where can i find which binding it shadows:     Warning: This binding for `forever' shadows an existing binding
06:42:45 <Mitar>              In the binding group for: forever
06:43:02 <pgavin> ghci
06:43:19 <mauke> @index forever
06:43:19 <lambdabot> bzzt
06:43:27 <pgavin> @hoogle forever
06:43:27 <mauke> @hoogle forever
06:43:27 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
06:43:27 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
06:43:32 <guenni> so how can I make read return a number if I feed it a string of digits?
06:43:32 <flux> mapreduce, let's say you had f a = if a then 0 else ""   and function  f a = if a then "" else 0, would they have the same type?
06:43:49 <mauke> guenni: you supply an appropriate type context
06:43:52 <pgavin> > (read "1234") :: Int
06:43:54 <lambdabot>  1234
06:43:59 <Saizan> mapreduce: if you develop the idea i think it becomes quite complicated, and it interacts badly with type inference, but it could be nice to explore, maybe in a language with polymorphic variants (i.e. open sum types) so that it's less of a problem dealing with an arbitrary number of diffrent types
06:44:08 <guenni> pgavin: thx
06:44:15 <mauke> > 0 + read "1234"
06:44:17 <lambdabot>  1234
06:47:12 <Saizan> mapreduce: but for erlang what you really need is for processes to agree on some protocol, and session-types are designed to do that
06:48:35 * matthew-_ suddenly spots people talking about session types
06:49:39 <Saizan> heh :)
06:50:33 <matthew-_> so session types are really a bit "too static" for Erlang. Joe Armstrong has been talking about a sort of protocol verifier thing, but dynamically. *sigh*
06:51:11 <matthew-_> also, as soon as you have one mailbox for each process from which you can remove any message, typing it correctly goes out the window
06:51:48 <Saizan> remove any message?
06:51:49 <matthew-_> ...without either making it homogenous or resorting to Typeable stuff
06:51:56 <matthew-_> Saizan: by pattern matching
06:52:16 <Mitar> how can i in opengl bindings register some callback which will be called when the main loop terminates?
06:52:20 <matthew-_> erlang allows you to pattern match against your mailbox and you remove the first message that matches the pattern
06:53:02 <flux> matthew-_, well, the mailbox still could have some type?
06:53:40 <matthew-_> flux: yeah, of type Mailbox. You can't reflect what's in the mailbox as statically you don't know which pattern matched and so which message was removed
06:53:40 <mauke> type Whatever = exists a. a
06:54:06 <flux> matthew-_, well, you could say that this mailbox can accept only "add" and "sub" messages?
06:54:16 <matthew-_> because the matching proceeds from the start of the mailbox and the order in which messages arrive in the mailbox is by definition racey
06:54:33 <matthew-_> flux: right, so you have to give every message a sum type
06:54:38 <matthew-_> but that's not interesting :)
06:55:00 <flux> matthew-_, so it's useful to be able to put messages into a queue nobody can handle?
06:55:26 <matthew-_> with session types you loose the one mailbox but you gain completely heterogeneous communication channnels which just work
06:55:30 <flux> or there are multiple different parties reading the queue, one party reading adds and the other subs?
06:55:38 <BeelsebobWork> hmm, can anyone think of a basic type which is an instance of no classes?
06:55:54 <BeelsebobWork> or failing that, which type is an instance of fewest classes
06:55:54 <Wild_Cat> BeelsebobWork: ()
06:55:58 <matthew-_> Monoid
06:56:00 <matthew-_> iirc
06:56:11 <Botje> @info ()
06:56:12 <lambdabot> ()
06:56:15 <Botje> doh
06:56:15 <BeelsebobWork> Wild_Cat: yeh, () isn't so useful here
06:56:28 <BeelsebobWork> this is for types to throw at quickcheck
06:56:30 <Botje> isn't () eq too?
06:56:36 <BeelsebobWork> it should be Num too
06:56:39 <matthew-_> flux: with erlang one process reads its own mailbox. all other processes can send to that mailbox
06:56:42 <BeelsebobWork> fromInteger x = ()
06:56:49 <BeelsebobWork> () + () = ()
06:56:51 <BeelsebobWork> etc
06:56:54 <Botje> giggle
06:57:08 <matthew-_> ()+() = ((), ())
06:57:10 <matthew-_> ;)
06:57:18 <BeelsebobWork> >.<
06:57:32 <mauke> a -> b
06:58:15 <BeelsebobWork> the real problem I have with () is that this is for throwing stuff at quickcheck, and () tends to make too many tests pass
06:58:46 <matthew-_> woah hang on, almost everything other than functions are instances of Show
06:58:56 <BeelsebobWork> hmm, that's true
06:59:28 <BeelsebobWork> so at the moment, Char seems to be the most boring type I can think of that results in quickcheck being useful
06:59:41 <BeelsebobWork> any advance on that?
07:01:02 <matthew-_> a
07:01:13 <matthew-_> does it have to be a ground type?
07:01:35 <BeelsebobWork> yep, has to be grounded -- the idea here is to give some types that quickcheck will be happy to generate, and express various properties
07:01:56 <BeelsebobWork> so for example, type NumericType = Int; type OrderableType = Char etc
07:02:03 <BeelsebobWork> pref the most basic useful one in each case
07:02:45 <BeelsebobWork> I'm trying to figure out what the best choice for NoPropertyType is -- I'm thinking Char atm
07:03:34 <matthew-_> Gr
07:03:52 <wjt> data Void; ? :)
07:04:17 <matthew-_> @info Gr
07:04:17 <lambdabot> Gr
07:04:29 <BeelsebobWork> wjt: not useful for quickchecking
07:04:35 <BeelsebobWork> almost all tests pass if you use something like that
07:04:53 <ToRA> IO () ? only instances Monad and Functor...
07:04:57 <BeelsebobWork> you can prove things like forall x, y. x `mappend` y == mempty
07:04:59 <matthew-_> Data.Graph.Inductive.Tree.Gr does not have much
07:05:31 * BeelsebobWork goes and looks at that one
07:05:35 <matthew-_> DynGraph Gr
07:05:36 <matthew-_> Graph Gr
07:05:36 <matthew-_> (Show a, Show b) => Show (Gr a b)
07:05:40 <matthew-_> that's it
07:06:13 <BeelsebobWork> hmm
07:06:17 <BeelsebobWork> that could be a good one
07:06:24 <matthew-_> though of course, Gr isn't a type, it's a type constructor, so you're back at square one really
07:06:52 <BeelsebobWork> well no, Gr Bool Bool defines less useful stuff than Char does
07:07:08 <ToRA> GHC.Prim.Int# and friends?
07:07:24 <BeelsebobWork> want to remain compiler agnostic here
07:09:11 <matthew-_> there're probably things in the opengl library...
07:09:27 <BeelsebobWork> yeh, conal already said he doesn't want to rely on OpenGL
07:09:33 <matthew-_> ok
07:09:43 <BeelsebobWork> which is fair enough when all we're doing is checking properties
07:09:49 <matthew-_> TH might be hunting ground
07:09:55 <BeelsebobWork> TH?
07:10:10 <matthew-_> yup, Q
07:10:20 <matthew-_> Language.Haskell.TH.Syntax.Q
07:10:37 <BeelsebobWork> interesting
07:13:29 <tylere> how do I setup a theme sitewide? Like say I cloned default/default to default/mysite, how do I make that active?
07:13:45 <tylere> oops, sorry, wrong window
07:13:48 <matthew-_> tylere: you sure you're in the right channel?
07:17:10 <mapreduce> Saizan: I think session types are what Scala's actors lib calls channels - they have a message type but one actor may have many channels 'open'.
07:17:54 <matthew-_> mapreduce: scala does not do session types
07:18:08 <mapreduce> Saizan: I think that can be done by separating your one actor into n typed actors rather than one actor with n channels.
07:18:49 <mapreduce> matthew-_: Where would you recommend for reading about session types?
07:18:59 <mauke> are you the author of the rant about the reviews of the paper about session types?
07:19:14 * matthew-_ is guilty as charged
07:19:32 <matthew-_> mapreduce: start with simon gay's papers on session types
07:19:41 <Saizan> mapreduce: you've to synchronize those n typed actors then
07:19:57 <matthew-_> mapreduce: http://www.dcs.gla.ac.uk/scripts/personal/simon/topic
07:20:03 <lambdabot> Title: Simon Gay's Publications
07:21:28 <mapreduce> Saizan: To stop messages being processed out of order?
07:21:41 <matthew-_> mapreduce: session types are about statically specifying communication patterns and using those specifications to parameterise the types of channels
07:22:06 <mapreduce> That sounds like what Scala's lib does, to me.
07:22:58 <matthew-_> scala's channels are not parameterised by a temporarily dependant, branching and looping type specifying the types of the values communicated over the channel
07:23:10 <Saizan> mapreduce: yeah, or just thread whatever "state" the original actor kept
07:23:19 <matthew-_> they are homogenous
07:23:49 <matthew-_> also, session types are (at least normally) used on bidirectional channels between two distinct parties
07:24:07 <matthew-_> though some libraries (i.e. mine) can also do delegation where you send the end of one channel to another party
07:25:52 <Saizan> mapreduce: in scala i imagine you can say that on a channel you can exchange values of some type M, while with session types you can e.g. specify that on a channel you can send two Int and you'll receive another Int back, and they include branching points and loops
07:27:06 <matthew-_> Saizan: exactly
07:28:31 <mapreduce> I don't know how types can include branching points and loops.
07:28:43 <mauke> hax
07:29:05 <mapreduce> Scala's channels are split into input and output channels, so it's more granular than you suggested above.
07:29:39 <mapreduce> "send two Int" - in the same message, or as two messages?
07:29:47 <Saizan> two messages
07:30:08 <matthew-_> mapreduce: imagine making a DSL at the type level
07:30:13 <Peaker> what's up with the significant percentage of prominent Haskell gurus called Simon? :)
07:30:28 <matthew-_> and then the type of the channel if basically a program
07:30:38 <matthew-_> and so you have to keep a program counter and all sorts of other magic
07:30:42 <matthew-_> all at the type level
07:31:01 <matthew-_> but basically, what mauke said ;)
07:31:18 <mapreduce> matthew-_: What minimum features do you need from the typesystem to get this?
07:31:31 <matthew-_> turing-completeness
07:31:37 <matthew-_> :)
07:31:51 <mapreduce> So how are you doing this in Haskell?
07:31:59 <matthew-_> undecideable instances
07:32:06 <matthew-_> gets you there, those, and fundeps
07:32:06 <mauke> ... and we're back to type-level MVars
07:32:09 <BeelsebobWork> is there any way to 'catch' an error
07:32:13 <Peaker> how does it relate to type safety in OOP (which is also about message exchange
07:32:20 <matthew-_> mauke: ooo, that's an interesting idea
07:32:21 <BeelsebobWork> i.e. a library throws an error, I want to be able to deal with it
07:32:32 <mapreduce> Peaker: OOP doesn't have type-safety.
07:32:43 <Saizan> BeelsebobWork: Control.Exception.catch
07:32:46 <Peaker> mapreduce: Because of cast-downs, I suppose?
07:32:52 <mapreduce> OOP is about tagged values rather than types.
07:33:03 <matthew-_> BeelsebobWork: ok, so you're statically guaranteed that the communications on a channel are of the right type
07:33:14 <mapreduce> Peaker: Oh, which OOP are you talking about?
07:33:17 <matthew-_> if you want to use a channel to send error-state messages, you obviously can
07:33:30 <BeelsebobWork> matthew-_: I don't -- the library calls error
07:33:33 <BeelsebobWork> I jsut want to catch it
07:33:35 <Peaker> mapreduce: Objects exchanging messages.. Java/C# style
07:33:38 <BeelsebobWork> I think probably what Saizan is it
07:33:39 <matthew-_> but you want these to automatically happen on errors right? Like Erlang's bidirectional links?
07:33:56 <Peaker> What's the difference between two entities communicating with session types, and two OOP objects calling methods on each other?
07:34:08 <BeelsebobWork> matthew-_: I have a call, that I know can error -- I want to be able to wrap it in "if this errors, do this instead"
07:34:28 <Saizan> matthew-_: i think he was asking about the "error" function in haskell, not in session-types
07:34:31 <mapreduce> Peaker: OOP methods are synchronous (blocking).
07:34:41 <matthew-_> Saizan: ahh! that makes a *big* difference ;)
07:35:22 <Saizan> Peaker: that the OO objects usually doesn't have a protocol that specifies the order in which messages should be exchanged
07:35:43 <Peaker> Saizan, mapreduce: Yeah, I'm curios whether session types are useful in the OOP world
07:35:43 <mapreduce> Saizan: Smallalk is full of such protocols.
07:35:59 <mapreduce> Poor Java/C# code has protocols too.
07:36:13 <matthew-_> Peaker: there are people who have modelled method calls with session types
07:36:22 <BeelsebobWork> hmm, that doesn't appear to do what I want
07:36:28 <mapreduce> poor when they're not statically enforced, that is.
07:36:29 <BeelsebobWork> the process still terminates on the error
07:36:39 <matthew-_> look up papers on "Moose" and something else I've forgotten by Drosoppolou
07:36:46 <Saizan> BeelsebobWork: you've to be sure the call to error is forced inside the scope of catch
07:37:02 <BeelsebobWork> Saizan: ah, interesting
07:37:05 <Peaker> BeelsebobWork: I think someone said that you can catch these errors, but only in the IO monad?
07:37:18 <mapreduce> matthew-_: I think I need to understand dependent typing or my understanding of session types will be too shallow.
07:37:25 <mapreduce> So I'll defer for now.
07:37:28 <Saizan> BeelsebobWork: C.E.evaluate is useful for that, but you might need more strictness
07:37:38 <matthew-_> Peaker: http://www.di.unito.it/~lambda/biblio/entry-DMYD06.html
07:37:41 <lambdabot> Title: [DMY+06] Session Types for Object-Oriented Languages
07:37:42 <Peaker> how come there's no "deep strict" (all the way down)?
07:37:48 <Peaker> matthew-_: thanks
07:37:51 <mauke> Peaker: I think it's called rnf
07:38:00 <Saizan> ?hoogle rnf
07:38:00 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:38:24 <BeelsebobWork> Saizan: essentially what I'm trying to accieve is that when I quickcheck something and it's possible that the function I'm checking throws an error, I will carry on checking all my porperties
07:38:31 <BeelsebobWork> (and mark that one as failing)
07:38:36 <matthew-_> Peaker: but the one line summary is that it sucks.
07:38:53 <BeelsebobWork> so I'm not sure I can get any guarentee :/
07:39:26 <Saizan> BeelsebobWork: what's the type of the results?
07:39:45 <BeelsebobWork> Saizan: forall a. Testable a => a
07:41:07 <Saizan> if you can add a NFData a => context you can use rnf
07:41:45 <EvilTerran> iirc, seq requires magic to work without such a typeclass
07:42:18 <mauke> > undefined `seq` ()
07:42:20 <lambdabot>  mueval: *** Exception: Prelude.undefined
07:42:27 <mauke> > (undefined :: Show a => a) `seq` ()
07:42:29 <lambdabot>  mueval: *** Exception: Prelude.undefined
07:42:56 <EvilTerran> i mean, magic that's built into the h98 standard
07:43:50 <mauke> naming question: is it ok to call a "smart constructor" 'new'?
07:44:01 <mauke> it's not all that smart but I want to hide data structure internals
07:44:30 <SamB_XP> newFoo is more typical
07:44:35 <SamB_XP> or possibly mkFoo
07:44:36 <mauke> ew
07:44:47 <mauke> Foo.newFoo looks very bad
07:44:57 <SamB_XP> what does it make?>
07:45:12 <mauke> a specialized priority queue
07:45:26 <BeelsebobWork> mkFoo is my personal preference on that one
07:45:32 <SamB_XP> how about empty
07:45:42 <mauke> it's not pure
07:46:09 <mauke> my intuition says empty :: MsgQueue as opposed to new :: IO MsgQueue
07:46:18 <SamB_XP> yeah...
07:46:36 <SamB_XP> @hoogle IO MVar
07:46:36 <lambdabot> Control.Concurrent.STM.TMVar newEmptyTMVarIO :: IO (TMVar a)
07:46:36 <lambdabot> Control.Concurrent.STM.TMVar newTMVarIO :: a -> IO (TMVar a)
07:46:44 <SamB_XP> @hoogle IO (MVar a)
07:46:44 <lambdabot> GHC.Conc newEmptyMVar :: IO (MVar a)
07:46:44 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
07:46:44 <lambdabot> GHC.Conc newMVar :: a -> IO (MVar a)
07:47:26 <mauke> import qualified Control.Concurrent.MVar as MVar; ... MVar.newMVar "too ugly"
07:47:44 <SamB_XP> well, why qualified though?
07:47:53 <mauke> if I wanted redundant redundancy, I'd use Java (Foo x = new Foo();) :-)
07:48:19 <mauke> so it doesn't clash with other modules
07:49:50 <mauke> planned operations include: new, put, get
07:51:04 <SamB_XP> put and get don't sound quite right
07:51:24 <mauke> :t put
07:51:27 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
07:51:30 <mauke> :t get
07:51:32 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
07:53:03 <rwbarton> I'd expect those put and get to satisfy "MonadState laws" like  put x >> get === put x >> return x
07:54:15 <mauke> UTCTime++
07:54:51 <rwbarton> What's wrong with newFoo, putFoo, getFoo?
07:55:08 <mauke> rwbarton: look bad with qualified imports
07:55:21 <mauke> and they're too long
07:55:43 <lilac> if you use them, you don't need qualified imports
07:55:55 <mauke> I prefer qualified imports
07:56:03 <BeelsebobWork> qualified imports are the spawn of satan
07:56:06 <rwbarton> Consider newArray, writeArray, readArray; newChan, writeChan, readChan; newIORef, writeIORef, readIORef; etc.
07:56:20 <mauke> yes, those all suck
07:56:37 * BeelsebobWork resists urge to yell "no, you"
07:56:48 <Saizan> in effect using suffixes like that looks more an hack for languages without namespacing facilities
07:57:28 <osfameron> indeed
07:57:40 <EvilTerran> qualified imports are a perfect way of giving people the option to include the type in the name if they want
07:57:50 <mauke> http://haskell.org/haskellwiki/Qualified_names
07:57:51 <EvilTerran> while including the type in the unqualified name doesn't give people the option
07:57:51 <lambdabot> Title: Qualified names - HaskellWiki
07:58:36 <Saizan> newChan reads better than Chan.new though
07:58:54 <mauke> Saizan: not to me
08:01:11 <mauke> @index TVar
08:01:12 <lambdabot> GHC.Conc, Control.Concurrent.STM.TVar, Control.Concurrent.STM
08:02:07 <mm_freak> is there a Right Way to write code in a LaTeX file?  \verb?
08:03:14 <BeelsebobWork> mm_freak: there's a language layout package somwhere
08:03:19 <BeelsebobWork> I personally don't like it
08:03:22 <BeelsebobWork> so I use alltt
08:03:27 <BeelsebobWork> but this has problems with backslashes
08:03:33 <BeelsebobWork> so lambdas become awkward
08:03:38 <BONUS> code in haskell is difficult :\
08:03:48 <BONUS> it always goes over the right edge for me
08:03:53 <BONUS> when using \begin{fixed}
08:03:55 <BONUS> or what is it again
08:14:50 <mm_freak> BeelsebobWork: layout isn't a problem…  i just mean short fragments of inline codes in a paragraph
08:15:07 <BeelsebobWork> oh, I use \texttt for that
08:15:31 <BeelsebobWork> and sometimes \verb -- specifically when I want a lambda, but don't want any styling
08:15:42 <mm_freak> it doesn't have to be in typewriter font…  in fact, i'd prefer it not to be
08:15:48 <BeelsebobWork> latex really needs to be replaced with a nice compositional, functional document description
08:15:54 <mm_freak> currently i'm using $…$
08:15:54 <osfameron> BeelsebobWork++
08:16:07 <earthy> beelsebobwork: and who is going to write it?
08:16:21 <osfameron> latex is really annoying to debug
08:16:22 <BeelsebobWork> earthy: dunno -- it was for a while on my todo list
08:17:13 <earthy> plus, look at Lout
08:18:04 <dsrogers> the problem with rewriting latex is that pretty much tex represents such an enormous investment.
08:18:16 <earthy> yes and no
08:18:52 <earthy> the problem with rewriting latex is that those qualified to do so then have to use it to write up what they've done
08:19:02 <BeelsebobWork> earthy: I've already got a library for writing pdfs from Haskell code
08:19:02 <earthy> where 'it' refers to latex
08:19:14 <BeelsebobWork> but it needs some serious layers of abstraction on top of it before it's in any way useful
08:19:47 <earthy> plus, there's *shitloads* that builds on top of LaTeX that you'd have to replicate for most serious work
08:19:55 <BeelsebobWork> yeh
08:20:05 <Spark> a lot of it is obsolete or crap though
08:20:16 <BeelsebobWork> but a lot of that stuff would be more easily written in such a language
08:20:20 <Spark> i do serious work with latex but i only use a handful of packages
08:20:29 <BeelsebobWork> LaTeX was never really designed for laying out stuff like for example proof trees
08:20:33 <Spark> and a lot of them either implement very basic things, or things that you come to expect from any other package
08:20:36 <Spark> like colour
08:20:52 <BeelsebobWork> Spark: the big one that springs to bind for me is bussproofs
08:20:59 <Spark> i tend not to use that
08:21:04 <Spark> proof trees just get too big too quickly
08:21:10 <BeelsebobWork> yep
08:21:26 <Spark> plus i end up with rules that have lots of things above the line
08:21:31 <earthy> Spark: ever looked at e.g. babel? :)
08:21:33 <Spark> so it's not practical at all
08:21:37 <earthy> that's one that I tend to use a lot
08:21:43 <Spark> nah what is it
08:21:56 <earthy> internationalization for TeX documents
08:22:07 <earthy> \usepackage[dutch]{babel} e.g.
08:22:08 <Spark> hmm i use utf-8
08:22:23 <Spark> but only for the sake of typing maths more nicely
08:22:26 <earthy> would make the chapters that you make with \chapter read as Hoofdstuk
08:22:29 <BeelsebobWork> see... that's an orthogonal problem
08:22:40 <BeelsebobWork> not something that I would imagine any LaTeX replacement covering
08:22:52 <earthy> \usepackage[german]{babel} would make them read as Kapittel
08:22:56 <Spark> you can redefine the chapter text quite easy
08:23:02 <Spark> so babel is a trivial thing to rewrite
08:23:03 <earthy> (iirc, I don't write german that often)
08:23:04 <Spark> in that case
08:23:09 <earthy> spark: it does a lot more
08:23:17 <Spark> \renewcommand\chaptername{Chapter}
08:23:18 <Spark> i think
08:23:18 <earthy> stuff like default quote styles etc.
08:23:39 <Spark> does that have anything to do with language?
08:23:46 <Spark> that's more of a personal thing anyway
08:24:10 <BeelsebobWork> Spark: not at all
08:24:18 <Spark> i really think the only good thing about latex is that you can write a paper using someone else's stylesheet and all the formatting is taken care of, and everyone's contributions are uniform
08:24:23 <BeelsebobWork> russian for example uses ‹‹ and ›› instead of " and "
08:24:33 <earthy> hyphenation rules get changed as well
08:24:41 <BeelsebobWork> presumably number-presentation rules
08:24:42 <kosmikus> I'm always surprised at how many people underestimate the complexity of LaTeX package code. And I mean real complexity, not just complexity due to the shortcomings of TeX as a language.
08:24:45 <BeelsebobWork> and date presentation rules
08:24:45 <Myoma> hello
08:24:58 <kosmikus> That's one of the main reasons why all the TeX replacements that already exist haven't taken over yet.
08:25:00 <Spark> kosmikus: the problem is a lot of it you don't need
08:25:08 <BeelsebobWork> kosmikus: most of the complexity comes from solving orthoginal problems in LaTeX
08:25:10 <Spark> and if you do need it, you can do it without too much trouble without the package
08:25:24 <kosmikus> that's an experience I don't share.
08:25:29 <earthy> a lot of it you actually *do* need if you want to provide a tool that 'just works'
08:25:50 <Spark> if you want to use << instead of `` then just type <<
08:25:51 <Spark> surely
08:26:06 <BeelsebobWork> Spark: not the same character
08:26:07 <Spark> you will be writing separate text in each language anyway
08:26:09 <BeelsebobWork> ‹‹, not <<
08:26:15 <Spark> it doesn't matter
08:26:20 <mauke> not «?
08:26:21 <Spark> i just don't have a bind for that
08:26:32 <BeelsebobWork> mauke: thank you, that was the character I wanted
08:26:43 <Spark> oh i do have a bind for that
08:27:21 <BeelsebobWork> gah, this is turning into a giant hack
08:27:25 * BeelsebobWork goes and rethinks it
08:27:37 <kosmikus> Spark: it's much more than quotation characters. date and time formats, for instance, are language-specific.
08:27:37 <Spark> latex turned into a giant hack 20 years ago :)
08:27:44 <Myoma> @quote
08:27:44 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
08:27:50 <Myoma> lol
08:27:53 <BeelsebobWork> Spark: I wasn't refering to that
08:27:54 <Spark> kosmikus: they're not just language specific either, so what, you can redefine those if you want too
08:27:57 <kosmikus> Spark: also, if the quote-character actually is produced by a macro ...
08:28:03 <Myoma> @quote
08:28:04 <lambdabot> bd_ says: ENOSLEEP_CLOWNSWILLGETME
08:28:09 <Wild_Cat> yeah, it's time somebody wrote a successor to LaTeX. They could call it LeaTheR, or something like that.
08:28:14 <shachaf> kosmikus: What is the date and time format for English? :-)
08:28:18 <mauke> "`Ruf"|listen"', sagte er.
08:28:19 <Myoma> Wild_Cat: I like it!
08:28:20 <sampointon> that doesn't make sense, Haskell tries very hard to isolate you from the real world, and keep you happy in a land of pure functions
08:28:31 <Spark> kosmikus: i'm not sure there are any macros that do that, and are not language-specific for other reasons
08:28:38 <kosmikus> shachaf: ok, I shouldn't say language-specific, but region-specific ;)
08:29:21 <sampointon> hmm. Does that mean we're in the matrix, and the sentinels are monads? And Neo is unsafePerformIO?
08:29:30 <kosmikus> Spark: well, I don't have to convince you. I'd like nothing better than a TeX replacement, and since you say it's easy, I probably don't have to wait for long anymore ...
08:29:49 <Myoma> I kind of wish it was called impurePerformIO
08:29:54 <Spark> i didn't say it was easy
08:29:57 <Myoma> I don't care if it's safe or not
08:30:25 <Spark> anyway
08:30:26 * Spark -> work
08:33:39 <Myoma> > unsafe
08:33:40 <lambdabot>  mueval: Unsafe functions to use mentioned.
08:33:48 <mauke> > impure
08:33:50 <lambdabot> Terminated
08:34:00 <Myoma> @keal
08:34:00 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
08:34:06 <Myoma> @quote
08:34:06 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
08:34:13 <Myoma> @quote
08:34:13 <lambdabot> goundoulf says: I've been reading a very good tutorial on haskell, because the [XMonad] config file was too obscure for me
08:34:40 <Myoma> I don't get that
08:35:30 <aeolist> have you used xmonad then?
08:35:39 <Myoma> yes
08:35:59 <aeolist> well configuring it is a daunting task if you dont know any haskell at all, wouldnt you say?
08:36:28 <aeolist> or at least it used to be, maybe that will change in the future
08:36:41 * Myoma doesn't have a clue
08:37:06 <Wild_Cat> then again, there isn't much of a reason to use xmonad if you don't know Haskell.
08:37:25 <mauke> Wild_Cat: people disagree :-)
08:37:34 <aeolist> there is, every other tiling wm sucks
08:37:51 <aeolist> or at least xmonad's potential makes them look sucky
08:37:55 <Wild_Cat> I mean, a tiling WM you can't configure (if you don't know Haskell)...
08:38:33 <aeolist> oh it's easy
08:38:40 <aeolist> you just copy bits of code from the wiki
08:38:42 <mauke> it's not easy but possible
08:39:04 <Wild_Cat> yeah, and end up with a real sucky config you can't debug :p
08:39:21 <Saizan> they added some configuration files, iirc
08:39:26 <aeolist> no, you just stay with the vanilla version and dont add a lot of extras :)
08:39:28 <Myoma> debugging config files. :/
08:39:28 <Myoma> a
08:39:32 <Wild_Cat> (case in point: the various hacks shown for using an azerty keyboard and still have working alt-number shortcuts)
08:39:49 <Myoma> azerty sucks
08:39:51 <Myoma> @quote
08:39:51 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
08:39:58 <Myoma> :D
08:40:28 <Myoma> @quote
08:40:28 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
08:40:36 <Myoma> ^ That's true :/
08:40:39 <aeolist> azerty?
08:40:49 <mauke> french keyboard layout
08:41:07 <sampointon> isn't it used for some other continental languages too?
08:41:07 <Myoma> @quote
08:41:08 <lambdabot> ozone says: dons: hey, i have a 100% track record for "things i started in haskell and other people implemented" so far ;)
08:41:11 <aeolist> http://en.wikipedia.org/wiki/AZERTY
08:41:12 <aeolist> oh noes
08:41:12 <lambdabot> Title: AZERTY - Wikipedia, the free encyclopedia
08:41:30 <wjt> sampointon: entertainingly, Belgian AZERTY is not the same as French AZERTY
08:41:50 <Direktori> http://thepiratebay.org
08:41:53 <lambdabot> Title: Download music, movies, games, software! The Pirate Bay - The world's largest Bi ...
08:41:54 <Direktori> ъ)
08:41:57 <aeolist> The Belgian AZERTY was developed from the French AZERTY and some adaptations were made in the 1980s. All letters are the same as on the French keyboard, but some punctuation signs (? ! @ - _ + = §) are in different positions.
08:42:26 <mauke> preflex: quote
08:42:26 <preflex>  <pizza> back when we had only 1 bit of memory we never had these organizational problems
08:42:29 <sampointon> eh, that's not much worse than UK-US keyboard swappage
08:42:36 <Myoma> @quote
08:42:36 <lambdabot> sebazzz says: sebazzz> TA LOCO! tengo que encarar carajo! por los santos pelos del sobaco de jesus! lo voy a hacer! :@
08:42:37 <Wild_Cat> and the fun continues: Mac AZERTY is different from PC AZERTY, of course.
08:42:47 <Myoma> what does that mean
08:42:56 <Wild_Cat> (the Mac layout is better, actually)
08:43:05 <sampointon> @ and " are swapped, the #, ~ and \ are moved around...
08:43:15 <lilac> @quote glorious
08:43:15 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
08:43:28 <jnaimard> wild_cat: you should try the bépo layout
08:43:56 <Saizan> that's a fake..
08:44:12 <Wild_Cat> jnaimard: yeah, but I have a life :p . (and have never heard of this thing)
08:44:13 <lilac> has anyone implemented a tables-driven arrow-based GLR parser combinator library for haskell?
08:45:30 <jnaimard> Wild_Cat: http://www.bepo.fr
08:46:12 <jnaimard> it's a dvorak for french, and programming symbols such as
08:46:25 <Wild_Cat> oh, Fortunes. It's for the people who think dvorak has sold out and gone mainstream.
08:46:27 <jnaimard> [ of | better placed than on azerty
08:47:02 <Twey> Wild_Cat: No, it's Dvorak for French people :-P
08:47:22 <sampointon> I wonder what the equivalent of Dvorak for Czechs is?
08:47:25 <sampointon> Haydn?
08:47:38 <Wild_Cat> Twey: my point still stands.
08:47:43 <aeolist> are there any dvorak users here
08:47:49 * Twey raises a hand.
08:48:07 <aeolist> how did you survive in this qwerty world?
08:48:15 <jnaimard> I use bepo myself, so one-half
08:48:45 * jnaimard lives in azertyland
08:49:02 <Twey> aeolist: It's easy enough :-P
08:49:20 * EvilTerran uses QWERTY, but with the backspace and capslock swapped
08:49:24 <Twey> I've never really lost QWERTY
08:49:29 <Twey> I use a bunch of keyboard layouts
08:49:43 <Twey> Japanese, Korean 3-beol, QWERTY, Dvorak, Lojban evolved
08:49:48 <EvilTerran> i almost never use capslock, it really shouldn't be on the home row
08:49:55 <Twey> And switch between them
08:50:01 <Twey> EvilTerran: I set capslock to compose
08:50:08 <EvilTerran> "compose"?
08:50:17 <EvilTerran> for digraphs?
08:50:18 <sampointon> EvilTerran: meta-dead-key
08:50:24 <sampointon> EvilTerran: no, accents
08:50:26 <aeolist> EvilTerran: ah yes, heard about that
08:50:46 <EvilTerran> i don't mean digraphs
08:50:49 <Twey> Heh
08:51:02 <EvilTerran> whatever the word is for two keystrokes giving you one character
08:51:05 <Twey> compose, a, e -> æ
08:51:06 <Twey> Aye.
08:51:08 * ziman uses capslock to switch between us qwerty <-> slovak qwertz; handy to mix accented text with code ([]@#$%^&\), eg. TeX
08:51:25 <EvilTerran> ah, that is digraph. different meaning of digraph.
08:51:32 <Twey> Aye.
08:51:59 <sampointon> I thought digraph always meant two letters. æ is a ligature
08:52:36 <EvilTerran> the orthographic (and original) meaning is "two graphemes together representing one phoneme"
08:52:47 <EvilTerran> ie, two characters, one sound
08:53:16 <sampointon> EvilTerran: I always think of æ as one character. In Old English and the IPA, it definitely is
08:53:52 <jnaimard> sometimes it's hard to tell, eg Ĳ in dutch
08:54:01 <EvilTerran> sampointon, yes, that's a ligature, that's a distinct idea
08:54:19 <EvilTerran> but vim at least borrows the word "digraph" to mean "two keystrokes, one character"
08:54:38 <EvilTerran> so, if you're typing in vim, æ is a digraph *and* a ligature
08:54:41 <EvilTerran> :P
08:54:50 <sampointon> hmm. Keystrokes:characters = graphemes:phonemes?
08:54:51 <EvilTerran> (unless you have an æ button)
08:54:53 <mauke> <: :>
08:55:25 <EvilTerran> sampointon, well, kinda, i guess
08:55:36 <EvilTerran> it's a similar relationship. :: would be closer than =
08:56:15 <EvilTerran> graphemes:phonemes = characters:sounds, by definition
08:56:55 <EvilTerran> aeolist, you heard about swapping capslock and backspace? that's odd, i thought i devised it myself
08:57:06 * EvilTerran does it on linux with xmodmap and on windows with autohotkey
08:57:08 <aeolist> you didnt, actually
08:57:16 <EvilTerran> i guess i invented it independently
08:57:21 <aeolist> there is a group of users that filed a petition or something
08:57:39 <aeolist> to the industry, asking them to switch the 2
08:57:40 <EvilTerran> or else i picked it up subconciously
08:57:58 <mauke> my capslock is escape
08:58:05 <mauke> guess my editor
08:58:32 <osfameron> hehe
08:58:47 * osfameron still uses inconveniently placed escape with vim
08:59:07 <osfameron> I tried to train myself to Ctrl-[ (with ctrl in caps position) but I can't make it stick]
08:59:41 <jnaimard> why don't you swap caps-lock and escape ?
08:59:44 <osfameron> ooo, caps/backspace swap would totally make sense
09:00:10 <osfameron> well, I need a conveniently positioned Ctrl too
09:00:25 <osfameron> and this stupid thinkpad keyboad puts Fn in the prime position on left of bottom row
09:00:36 <osfameron> so I can't press Ctrl with the bad of my left hand anymore
09:01:28 <Twey> Heh, mine doesn't
09:01:37 <aeolist> EvilTerran: i am pretty sure i read it on wikipedia, i cant find it right now
09:02:05 <sampointon> okay, so, about the halting problem. We know that the binary function halt(program, input) is noncomputable
09:02:46 <sampointon> but the proof can be extended to any predicate about a function's behaviour, with just the same diagonal argument
09:03:14 <dons> http://www.reddit.com/comments/6xwqm/the_monadreader_issue_11_how_to_refold_a_map/ TMR.
09:03:21 <lambdabot> Title: The Monad.Reader: Issue 11: How to Refold a Map, First-Order Logic à la Carte,  ..., http://tinyurl.com/6p4shu
09:04:11 <sampointon> are there any useful, computable predicates about the behaviour of an arbitrary program?
09:04:51 <Myoma> sampointon: Many
09:05:22 <rwbarton> sampointon: Takes > 1000 steps to run
09:05:27 <sampointon> Myoma: I'd assumed as much, given that computers work
09:05:43 <Myoma> sampointon: Very common one -- detecting tail calls
09:06:59 <Myoma> sampointon: another good one -- is this program type safe
09:07:03 <sampointon> rwbarton: what about the function: g f = if takes1000Steps f then return else take1001Steps applied to itself?
09:07:27 <rwbarton> sampointon: probably "takes1000Steps f" takes more than 1000 steps to compute
09:08:14 <sampointon> rwbarton: hmm, that would work, actually
09:08:42 <Myoma> sampointon: but just because something is not computable, does not mean that it can't be calculated in very many cases
09:09:23 <sampointon> Myoma: true. But then they're not total predicates about arbitrary functions
09:09:40 <mauke> :t unless
09:09:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:11:15 <sampointon> Myoma: in fact, I'd be more inclined to call them heuristics instead, because they can fail
09:11:34 <Saul> Can anyone tell me what I need to do to get ghc 6.9 working?
09:12:27 <Myoma> sampointon: A predicate cannot be a heuristic, maybe you can derive a heuristic from it though
09:12:46 <Saul> I've tried installing several builds in the head builds on the site, but those won't install
09:14:29 <gour> does RWH book speaks somewhere about Data.Map module?
09:15:12 <rwbarton> Saul: Can't help you except to say that I have had the same experience (back in June or so), namely I eventually managed to build some version of ghc-6.9 but "make install" didn't work.  (I decided I didn't need it for what I was doing)
09:15:41 <Saul> rwbarton: :(
09:16:15 <Saul> I don't absolutely need it, but I much prefer the new associated types to multiparam type classes with fundeps
09:16:45 <Saul> I could wait for a month, but that would be boring
09:17:20 <Saul> or I could use fundeps instead and switch when 6.10 comes out
09:18:05 <Saul> or fiddle around with 6.9 to get it working some more, but I only have a rudimentary understanding of make
09:18:19 <selmanj> If I have a datatype that consists of three different values, like say Foo Int Int [Int], and I just want to update one of the Int values, do I have to construct a new instance of that data type?
09:18:33 <Saul> selmanj: yup
09:18:42 <selmanj> I have a datatype that represents gamestate in my app, and I'm goign to be updating one of hte components a LOT.
09:19:03 <Saul> Well it's not that bad
09:19:10 <Myoma> selmanj: You could use ST refs if that works better
09:19:20 <selmanj> what are ST refs?
09:19:26 <Saul> Only the component inself and your Foo type will need to be changed
09:19:39 <Saizan> Saul: maybe try #ghc, or the ghc-users mailing list
09:19:45 <Saul> the other to components will just be refered to
09:19:54 <Saul> Saizan: I'll try that, thanks
09:19:54 <maltem> selmanj: Updating a lot won't very often be a performance bottleneck, if that is what you fear
09:20:01 <Myoma> selmanj: mutable references
09:21:12 <selmanj> maltem: I am learning Haskell, and I'm finding I have to rethink how I code a lot more
09:21:48 <Saul> selmanj: I found it helpful to not wonder about efficiency too much
09:21:49 <Myoma> 'This gives rise to a pure mixin style behaviour modelling paradigm'
09:21:50 <Myoma> o_o
09:22:00 <selmanj> I guess the solution is to make an updateGameState function that takes the variable i want to change and results with a new instance of gamestate
09:22:17 <maltem> selmanj: sounds right
09:22:28 <Saul> selmanj: yup
09:22:36 <rwbarton> selmanj: You might prefer records like Foo { foo :: Int, bar :: Int, baz :: [Int] }, the semantics are exactly the same as Foo Int Int [Int] but there's special syntax for updating a field
09:23:00 <selmanj> rwbarton: oo I have that syntax, but I thoguht that just wrote accessor functions; you can update as well?
09:23:17 <rwbarton> selmanj: "x { foo = 3 }" creates a copy of x with the field foo changed to 3
09:23:29 <maltem> selmanj: The update syntax is less elegant than the accessor functions, but yes it does exist
09:23:29 <Saul> selmanj: Yeah records are okay, but they they only give you low-level updating, you'll probably want to make some higher level selectors and updaters
09:23:40 <Saul> selmanj: Still a good thing to start with
09:24:18 <selmanj> Saul: Yeah, I'll probably end up using both methods.
09:25:27 <rwbarton> Does GHC ever try to prove that a record will have exactly one reference and thus can be updated in place?
09:26:31 <Myoma> I think you need linear typing for it
09:27:58 <Heffalump> rwbarton: I think that's what Keith Wansborough's work was about, but I don't think it ever got merged.
09:28:06 <Heffalump> but I could be wrong on both fronts.
09:28:32 <Myoma> @quote
09:28:32 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
09:28:34 <rwbarton> It seems that there would be at least trivial cases where a compiler could do it, but maybe you need linear typing to get it to work in useful cases.
09:28:47 <selmanj> also, a random question, if I have an expensive function that I evaluate with f(x) = y, if I call f(x) again later in the program, it will return y immediately right?
09:29:11 <selmanj> (assuming y is a simple value, not some 80 meg result)
09:29:27 <maltem> selmanj: no it won't
09:29:48 <selmanj> maltem: why not?
09:30:06 <Myoma> selmanj: that is called memoization and it does not happen automatically
09:30:15 <maltem> selmanj: you have to call y again. f(x) won't be held in memory because it's too hard to predict when it's worth to hold something in memory all the time
09:30:24 <Myoma> selmanj: It's quite simple to make it happening though, well depending on the domain of f
09:30:41 <selmanj> Myoma: Is it a compiler option?
09:30:47 <Myoma> no it's a programming task
09:30:53 <Wild_Cat> doesn't GHC auto-memoize some things, like when you call the same function twice in the same let or where clause?
09:31:01 <Myoma> I can show you how on a simple example if you like?
09:31:17 <maltem> selmanj: let x = expensive_computation in (x+1,x+2) -- x will only be computed once
09:31:22 <Wild_Cat> (e.g. let foo = bar x in (foo x) + (foo x))
09:31:24 <selmanj> Myoma: That would be great
09:31:32 <Saizan> Wild_Cat: no
09:31:36 <Myoma> Wild_Cat: That's part of lazy evaluation -- and this is what we can make use of to memoize
09:31:39 <maltem> selmanj: (expensive_computation+1,expensive_computation+2) -- it will be computed twice
09:32:03 <Myoma> selmanj: so consider,  fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2)
09:32:03 <Wild_Cat> okay. Detailed where clauses ++, then.
09:32:33 <Myoma> something like fib 50 will take ages
09:32:38 <selmanj> Myoma: ok, taht seems like a perfect example of where memoization would be handy
09:32:43 <maltem> selmanj: actually I should write expensive_computation some_argument
09:32:54 <Myoma> so we rewrite it:   fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2)
09:33:02 <Myoma> now define fib' n = fibs !! n
09:33:08 <Myoma> fibs = map fib [0..]
09:33:15 <Myoma> the key is this:  fibs = map fib [0..]
09:33:35 <Myoma> that large list of all the results has the map computation saved
09:34:01 <Myoma> and fib' does a lookup on it, but it will also cause computation if it looks up a value which wasn't computed yet
09:34:17 <Myoma> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 40
09:34:19 <selmanj> Myoma: Ok, but where is the resulting value stored then?  In the list?
09:34:20 <lambdabot>  mueval: Time limit exceeded
09:34:37 <Myoma> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2) ; fib' n = fibs !! n ; fibs = map fib [0..] in fib 40
09:34:39 <lambdabot>  102334155
09:34:41 <Myoma> :)
09:35:13 <maltem> selmanj: That's right. fibs will be held in memory because it doesn't take an argument
09:35:15 <Wild_Cat> right, so I guess today's lesson, in some way, is "if you want speed, express everything you can in map/filter/reduce form".
09:35:42 <Wild_Cat> (incidentally, didn't I read stuff about newer versions of GHC autothreading stuff like that?)
09:35:54 <sampointon> Wild_Cat: or tail-recursive form, if you don't need the value many times
09:36:32 <Myoma> sampointon: What ?
09:36:52 <selmanj> Myoma: Thanks for that example, that helps illuminate how I should be writing this code
09:37:26 <Myoma> this is very elegant to http://www.iis.sinica.edu.tw/~scm/2008/tail-recursive-linear-time-fibonacci/ another way to do it
09:37:34 <sampointon> Myoma: storage for all those intermediate values might be expensive, a tail recursive fib function only needs constant space
09:37:34 <lambdabot> Title: Tail-Recursive, Linear-Time Fibonacci | for the few of us., http://tinyurl.com/573hg2
09:37:44 <sampointon> Myoma: of course, that loses memoisation
09:37:52 <Myoma> sampointon: if you do not want the values to be stored then you can put them in a where clause
09:38:06 <Myoma> so they will be stored during each single computation but lost between
09:38:23 <Myoma> where-as if you put them all at the toplevel like I did, they stick around forever
09:38:48 <rwbarton> selmanj: Myoma's example used a list for simplicity, but depending on your situation you might want a map or array of some kind to get faster lookup
09:39:08 <Myoma> hm
09:39:18 <Myoma> the domain was N so you store the things in [N]
09:39:42 <Myoma> but if the domain was something like a Tree, or [N] I'm not sure what you'd use instead
09:40:22 <EvilTerran> this is why memoisation isn't implicit - it's too hard to choose the right data structure
09:40:28 <EvilTerran> (well, partly why)
09:40:53 <ManateeLazyCat> Hi, everyone.
09:41:05 <EvilTerran> you can use a Data.Map if your domain is finite
09:41:09 <sampointon> Myoma: did you mean like fib n = case n of {1 -> 1; 2 -> 1; n -> a + b} where {a = fib (n-1); b = fib (n-2)} ?
09:41:21 <EvilTerran> failing that, you'll need some kind of lazily infinite data structure
09:41:23 <Myoma> sampointon: no I meant like this,
09:41:27 <EvilTerran> a trie would work for [N]
09:41:47 <Myoma> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2)
09:41:47 <Myoma>  where fib' n = fibs !! n
09:41:47 <Myoma>        fibs = map fib [0..]
09:42:00 <Myoma> as opposed to before, without the "where"
09:42:13 <Myoma> (You can compare speeds to get an idea what happens in each case)
09:42:18 <ManateeLazyCat> I want to use Haskell write a multi-thread downloader axel. I want to know Haskell have enough power to implement Network Programming?
09:42:27 <ManateeLazyCat> like axel
09:42:40 <EvilTerran> ManateeLazyCat, it's not a matter of power
09:42:41 <EvilTerran> but yes
09:43:03 <mauke> "axel"?
09:43:11 <Myoma> ?faq can haskell calculate fibonacci numbers
09:43:11 <lambdabot> The answer is: Yes! Haskell can do that.
09:43:29 <EvilTerran> ?hackage http
09:43:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/http
09:43:40 <EvilTerran> ?hackage HTTP even
09:43:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP even
09:43:51 <EvilTerran> ^ ManateeLazyCat
09:44:03 * EvilTerran goes back to thinking about tries
09:44:12 <mauke> trie, trie again
09:44:39 <mauke> hmm, return (return ())
09:44:39 <Myoma> Can you calculate the type suitable to memoize a function?
09:44:52 <EvilTerran> Myoma, no
09:44:59 <Myoma> i.e. write some function from N -> [N], String -> Trie String
09:45:02 <EvilTerran> what happens if the function takes another function as a parameter
09:45:06 <EvilTerran> ?
09:45:13 <Myoma> ok but avoid exponentials
09:45:17 <EvilTerran> or anything else with no Eq constraint, let alone an Ord one
09:45:18 <ManateeLazyCat> Thanks all.
09:45:21 <ManateeLazyCat> :)
09:45:29 <rwbarton> sigfpe has a good blog post on this subject
09:45:59 <EvilTerran> Myoma, if you require a typeclass for the parameter, then yes, a fairly generalizable memoization scheme would be possible
09:46:28 <EvilTerran> something like class TrieIx a where toTrieIx :: a -> [Int]
09:48:25 <EvilTerran> or you could borrow Data.Binary's serialization methods to convert your parameter type to a [Word8] (via ByteString)
09:49:01 <ManateeLazyCat> EvilTerran: Have similar multi-thread network program that use Haskell implement?
09:49:18 <EvilTerran> i don't know
09:49:22 <EvilTerran> but it's definitely possible
09:49:51 <EvilTerran> we have some very nice parallelism support
09:49:55 <sioraiocht> are there any papers that describe heap layout in haskell?
09:50:23 <ManateeLazyCat> EvilTerran: If want to use Haskell to implement a brower like firefox, possible?
09:50:38 <Twey> *Yes*, ManateeLazyCat
09:50:49 <EvilTerran> ?faq can haskell do everything ManateeLazyCat has asked of it?
09:50:49 <lambdabot> The answer is: Yes! Haskell can do that.
09:51:03 <EvilTerran> ?faq can haskell do anything ManateeLazyCat might ask of it in the future?
09:51:03 <lambdabot> The answer is: Yes! Haskell can do that.
09:51:10 <Myoma> ManateeLazyCat: Nobody has done it
09:51:18 <Myoma> ManateeLazyCat: You could try
09:51:34 <ManateeLazyCat> Thanks :)
09:52:22 <EvilTerran> ManateeLazyCat, we have a good gtk2 interface, an HTTP library (or lower-level stuff if you want it), etcetc - it's just a matter of bringing them together
09:52:23 <ManateeLazyCat> It's my plain. :)
09:52:27 <Botje> ?faq can haskell feed my cat?
09:52:27 <lambdabot> The answer is: Yes! Haskell can do that.
09:52:32 <Botje> hah! I don't have a cat!
09:53:07 <EvilTerran> Botje, well, haskell can still feed all your cats
09:53:13 <Myoma> Anybody implemented The Heap Lambda Machine?
09:53:17 <Botje> :)
09:53:23 <Myoma> we should get a haskell running on it :p
09:53:24 <rwbarton> ManateeLazyCat: You might like to take a look at http://book.realworldhaskell.org/beta/stm.html under "A concurrent web link checker"
09:53:29 <lambdabot> Title: Chapter 29. Software transactional memory
09:56:04 <lilac> ?faq can haskell buy Botje a cat?
09:56:04 <lambdabot> The answer is: Yes! Haskell can do that.
09:56:23 <lilac> well, that's that sorted
09:57:30 <ManateeLazyCat> Thanks all, it's very detail. :)
09:57:52 <Botje> :))
09:58:37 <ManateeLazyCat> I'm a emacser, but #haskell is very hot than #emacs
10:00:04 <ManateeLazyCat> I think lambdabot will say Haskell can do that for everything. Funny.... :)
10:01:35 <tromp> can haskell die a miserable death?
10:01:45 <tromp> ~faq can haskell die a miserable death?
10:01:50 <tromp> ?faq can haskell die a miserable death?
10:01:51 <lambdabot> The answer is: Yes! Haskell can do that.
10:02:46 <Myoma> anybody done anything at all with the heap lambda machine?
10:05:48 <Myoma> :/
10:06:05 <lilac> ?can haskell create a problem so complex even it cannot solve it?
10:06:05 <lambdabot> Maybe you meant: faq map run wn
10:07:03 <sw17ch> the omnicient qualities ascribed to lambdabot are an endless source of humor :)
10:09:51 <Myoma> ?faq please place the blue prism on top of the red block
10:09:51 <lambdabot> The answer is: Yes! Haskell can do that.
10:13:00 <Botje> heh heh.
10:13:43 <sw17ch> > (return 1) >> "123"
10:13:45 <lambdabot>  "123"
10:13:59 <Beelsebob> > return 1 >>= "123"
10:14:01 <lambdabot>  Couldn't match expected type `t -> m b'
10:14:03 <sw17ch> > (1 >>) "123"
10:14:05 <lambdabot>      No instance for (Num [a])
10:14:05 <lambdabot>       arising from the literal `1' at <interac...
10:14:10 <sw17ch> > (return 1 >>) "123"
10:14:13 <lambdabot>  "123"
10:14:17 <mauke> > [(),()] >> "what"
10:14:19 <lambdabot>  "whatwhat"
10:14:20 <Myoma> > (return 1 >> "123")
10:14:22 <lambdabot>  "123"
10:14:29 <sw17ch> mauke, that's waht i was going for, thanks
10:14:33 <Beelsebob> mauke: now make one to say "monkey butt"
10:14:41 <binarybandit> > foldr (+) 0 [1, 2, 3]
10:14:43 <lambdabot>  6
10:14:43 <binarybandit> cool
10:14:54 <Myoma> > foldr (+) o [x, y, z]
10:14:56 <lambdabot>  x + (y + (z + o))
10:14:59 <Beelsebob> binarybandit: you probably want foldr1
10:15:00 <sw17ch> > (foldr (+) 0 [1,2,3]) :: Expr
10:15:02 <lambdabot>  1 + (2 + (3 + 0))
10:15:16 <dons> ?yow
10:15:17 <lambdabot> Couldn't find fortune file
10:15:18 <binarybandit> Beelsebob, just looking at lambdabot, not actually doing anything :p
10:15:19 <sw17ch> > (foldr1 (+) [0,1,2,3]) :: Expr
10:15:21 <lambdabot>  0 + (1 + (2 + 3))
10:15:22 <dons> damn you, fortune file.
10:15:29 <sw17ch> i love Expr
10:15:31 <mauke> Beelsebob: print chr ord q cmp uc and print chr ord q xor x and print chr ord q and quotemeta and print chr ord q mkdir m and print chr ord q ref tr and print chr ord q my m and print chr ord q x y x and print chr ord q dbmopen and and print chr ord q sub s and print chr ord q stat s and print chr ord q stat s and print chr oct oct oct oct oct oct oct oct oct ord ord uc q map m
10:15:48 <Beelsebob> mauke: uhhhh?
10:15:51 * dons imagines a new lamdabot,  a swarm of mutually recursive, fault tolerant communicating threads
10:15:54 <mauke> valid perl code!
10:15:57 <Myoma> erlang!
10:16:07 <Beelsebob> mauke: >.<
10:16:11 <dons> haskell!
10:16:25 * sw17ch thinks about the omnicient qualities of a threaded lambdabot
10:16:57 <dons> we need more scalable, parallel data structure libs.
10:17:01 <dons> parallel graphs anyone?
10:17:13 <Myoma> what's that?
10:17:14 <dons> ones that come with finely tuned `par` strategies
10:17:22 <mauke> heh, and you can't write code this clean in Haskell because you need '='
10:17:47 <_zenon_> Are there any libraries implementing approximation algorithms for different problems?
10:17:59 <ManateeLazyCat> Can tell me other good website or resource about Haskell. Now I only know www.haskellwiki.org and realwolrdhaskell.org.
10:18:02 <Beelsebob> dons: http://hpaste.org/9922?
10:18:03 <_zenon_> Like for example .... independent set?
10:18:15 <dons> evil.
10:18:22 <dons> _zenon_: likely, see on hackage.haskell.org
10:18:27 <Myoma> what does it do
10:18:34 <dons> ManateeLazyCat: haskell.org is *the* resource
10:18:40 <_zenon_> dons, I'll look
10:18:49 <sw17ch> scary butterfly
10:19:02 <dons> Beelsebob: that's an OHCCC winner right there.
10:19:10 <Beelsebob> dons: actually, second place
10:19:25 <Beelsebob> it was Kevin Hammond's entry in the first year
10:19:42 <dons> oh, beaten by JLs RSA?
10:19:46 <Beelsebob> yep
10:19:55 <dmhouse> import Foo renaming ...? I've not seen that syntax before...
10:20:14 <Beelsebob> dmhouse: it renames the imported things to new names in your current namespace
10:20:36 <dmhouse> It's not H98, is it?
10:20:45 <Beelsebob> sure it is
10:21:08 <Beelsebob> oh man -- I didn't realise you could define main as a member of a tuple
10:21:10 <sw17ch> i've found that the import stuff is surprisingly resilient to "guessed" syntax
10:21:10 <Beelsebob> that's evil
10:21:16 <_zenon_> nah, didn't find any
10:23:41 <dmhouse> And what is the exact rule with comments? Sometimes --a, where a is some nonword character, can be an operator, right?
10:23:51 <Beelsebob> yep
10:24:12 <dmhouse> Oh, right, so the --|-- don't begin comments...
10:24:23 <Beelsebob> the rule is -- not followed by one of the allowed characters for an operator is a comment
10:24:33 <Beelsebob> -- followed by one of the allowed characters is an operator
10:24:48 <Beelsebob> personally, I think this is frikin stupid
10:24:51 <Beelsebob> but meh
10:25:53 <dmhouse> But then the first few lines are "import Prelude renaming gnimaner edulerP (...)", right?
10:26:06 <dmhouse> Err, with a --|-- in between renaming and gnimaner
10:26:23 <Beelsebob> oh, that's an interesting point
10:26:38 * Beelsebob ponders why that works
10:27:09 <rwbarton> It doesn't seem to work.
10:27:20 <dmhouse> I get "parse error on input `renaming'"
10:27:22 <Beelsebob> the syntax parser on hpaste agrees that it shouldn't
10:28:04 <rwbarton> in fact "import Prelude renaming" doesn't seem to exist either
10:28:17 <rwbarton> I bet this is for pre-Haskell 98 or something
10:28:23 <dmhouse> Beelsebob: are you sure `renaming' is H98? It doesn't seem to be in http://www.haskell.org/onlinereport/modules.html
10:28:24 <lambdabot> Title: The Haskell 98 Report: Modules
10:28:41 <mauke> K&R Haskell
10:30:20 <dmhouse> http://www.haskell.org/pipermail/haskell/2004-August/014387.html, it dates from 93
10:30:21 <lambdabot> Title: [Haskell] Re: ANNOUNCE: The Succ Zero International Obfuscated Haskell Code Cont ...
10:31:44 <mapreduce> I think I grasp the idea of arrows.  Apart from writing 'second', (&&&), etc., what use cases are there for actually having the Arrow name?
10:32:04 <BONUS> you can make something an arrow and then use &&& with it
10:32:06 <mapreduce> I.e., what code can you write on a (Arrow a) ?  Any examples?
10:32:08 <BONUS> for instance, parallel computations
10:32:15 <BONUS> whatever you want
10:32:22 <BONUS> at least thats how i think it works
10:32:35 <mapreduce> BONUS: Well, -> (functions) is an arrow.
10:32:40 <centrinia> mapreduce, anything you can do with Monads you can do with Arrows. :)
10:32:41 <BONUS> yeah
10:32:54 <mapreduce> BONUS: You can define (&&&) in terms of quite basic function composition, etc.
10:33:08 <mapreduce> BONUS: But that doesn't actually give you parallelism.
10:33:17 <BONUS> yeah i know, but you could theoretically
10:33:28 <BONUS> make a parallel arrow
10:33:32 <mapreduce> centrinia: I could ask the same question for the Monad typeclass. :)
10:33:42 <mapreduce> BONUS: Sure.
10:33:47 <BONUS> and then &&& would execute two different parallel computations for the same input, etc
10:34:10 <mapreduce> I'm asking what you could write that would accept an Arrow.
10:34:21 <BONUS> oh
10:34:24 <BONUS> hmm
10:34:48 <dmhouse> Arrow transformers! :)
10:35:07 <BONUS> omg
10:35:09 <dmhouse> mapreduce: in truth, arrows haven't seen that much use. There is a functional graphics library based on them, though, that might be worth checking out.
10:35:17 <BONUS> arrow transformers... is that possible?
10:35:26 <mapreduce> dmhouse: fudgets?
10:35:27 <BONUS> a b m c
10:35:30 <BONUS> hmm
10:36:00 <mapreduce> Ok, then, I'll ask the same question but for Monad.
10:36:07 <mapreduce> That might help me extend the answer to Arrow.
10:36:28 <Myoma> BONUS: cool!
10:36:42 <mapreduce> I think I grasp the idea of monads.  Apart from writing (>>), etc., what use cases are there for actually having the Monad name?
10:36:46 <BONUS> check this out: http://spbhug.folding-maps.org/wiki/MonadsEn wherein this guy makes a statistical distribution monad
10:36:56 <lambdabot> Title: MonadsEn - SPb Haskell User Group
10:37:24 <dmhouse> mapreduce: do blocks.
10:37:47 <BONUS> i'd say that monads are applicable when you're sequencing actions or values that have some sort of result
10:37:49 <mapreduce> dmhouse: Do blocks could instead be bound to the names of the operations.
10:37:58 <mapreduce> BONUS: That's not my question.
10:38:02 <centrinia> mapreduce, [a] is an instance of the Monad typeclass. :)
10:38:12 <mapreduce> centrinia: Yes.
10:38:19 <dmhouse> mapreduce: erm, you can't write do-block notation without syntactic sugar.
10:39:06 <mapreduce> dmhouse: Scala has something very vaguely similar to do blocks (closer to C#'s LINQ, probably), but there is no Monad name, or Sequence name that it binds to.
10:39:19 <sw17ch> is there something like ByteString for variable lengthed data types?
10:39:26 <sw17ch> i'm thinking that's what uvector is for
10:39:31 <mapreduce> Instead, Scala's feature, for comprehensions, are bound to the names of the operations, foreach, filter, flatMap, etc.
10:39:47 <mapreduce> This might not be a good thing, I'm only mentioning it as an alternative.
10:40:37 <heisenbug_> I'd like to say: instance (foreach i j . Show (p i j) => Foo p a b where ...
10:40:37 <mapreduce> dmhouse: Would you say do blocks are the only reason to have the name Monad?
10:40:41 <dmhouse> mapreduce: can you give an example?
10:40:55 <dmhouse> heisenbug_: what would you like that to mean?
10:41:10 <mapreduce> dmhouse: for { i <- 1 to 10; if i%2 == 0) yield i
10:41:23 <Myoma> yuck
10:41:27 <mapreduce> dmhouse: Expands to 1 to 10 filter (_%2 == 0)
10:41:39 <dmhouse> mapreduce: so that's syntactic sugar?
10:41:42 <mapreduce> Yes.
10:41:46 <Peaker> mapreduce: collapses to :)
10:41:46 <dmhouse> So just like do-blocks.
10:41:52 <mapreduce> Peaker: In that case.
10:41:54 <heisenbug_> that a (p i j) can be shown regardless of i and j
10:41:55 <mapreduce> dmhouse: Yes.
10:42:04 <dmhouse> mapreduce: you know that do-blocks boil down to (>>=) and return, right?
10:42:14 <mapreduce> dmhouse: Except any type that implements foreach, flatMap and filter can be used with for comprehensions.
10:42:31 <mapreduce> dmhouse: Haskell's do blocks cannot be used with a non-Monad instance, afaict.
10:42:42 <dmhouse> Of course not, because you need (>>=) and return...
10:42:43 <mapreduce> Again, I'm not touting this as a good thing, just an alternative.
10:42:56 <dmhouse> How could you have do-block notation without having definitions for (>>=) and return?
10:43:03 <dmhouse> If you have those definitions, just write a Monad instance ;)
10:43:07 <mapreduce> Suppose you have type X with >>=, return, but it is not a Monad instance.  Can you use do blocks>?
10:43:10 <heisenbug_> dmhouse: I have existential types inside of my Foo p a b
10:43:11 <rwbarton> This sounds like duck typing vs. type classes
10:43:24 <mapreduce> rwbarton: Not really, as both versions are statically resolved.
10:43:26 <rwbarton> mapreduce: You can't write >>= or return without having a Monad instance, those names are taken for the Monad class methods :)
10:43:35 <mapreduce> Closer to structural typing vs. type classes.
10:43:38 <dmhouse> mapreduce: how could a type have >>= and return without 1) that type being a Monad instance or 2) them being called something else?
10:43:41 <rwbarton> mapreduce: OK, sure
10:44:01 <mapreduce> Ok, I didn't know that restriction.
10:44:13 <dmhouse> The same reason you can't do:
10:44:18 <dmhouse> module Foo where foo = 3; foo = "hello"
10:44:33 <dmhouse> It's nonsensical. To overload identifiers in Haskell, you use type classes.
10:45:03 <mapreduce> > let return x = x*x in return x
10:45:05 <lambdabot>  x * x
10:45:06 <r3m0t> you could import Prelude hiding ((>>=), return, Monad)
10:45:17 <mapreduce> What the..?
10:45:19 <dmhouse> mapreduce: that shadows return. Now you can't use the Monad return anywhere in that module.
10:45:40 <r3m0t> > let f x = x*x in f x
10:45:42 <lambdabot>  x * x
10:45:46 <dmhouse> mapreduce: also lambdabot has some special Show instance and Typeable magic to make things like the following work:
10:45:49 <dmhouse> > foldr f x [1..10]
10:45:51 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 x)))))))))
10:45:53 <mapreduce> > let return x = x*x in return 5
10:45:55 <lambdabot>  25
10:46:09 <dmhouse> Yes, reiterate point about the shadowing.
10:46:13 <trofi> > hi
10:46:15 <lambdabot> Terminated
10:46:40 <dmhouse> trofi: it uses heuristics to tell what's a variable and what's a function, IIRC. So x, y, z are variables and f, g, h are functions, etc.
10:46:44 <mapreduce> Ok, thanks guys, stuff to ponder.
10:46:45 <centrinia> > let a >>= b = a ++ b in [1,2] >>= [3,4]
10:46:46 <gabor> dmhouse: think of (Foo p a b) being a container of (p a m) (p m n) (p n x) ... (p z b)
10:46:46 <lambdabot>  [1,2,3,4]
10:46:49 <centrinia> Okay.
10:46:51 <Myoma> > let return x = x*x in do [1,2,3]
10:46:53 <lambdabot>  [1,2,3]
10:47:04 <dmhouse> mapreduce: basically, if you want to do overloading in Haskell, you want type classes. That's a design decision.
10:47:18 <dmhouse> gabor: oh, you changed nick?
10:47:21 <centrinia> > let do x = x+1 in do 3
10:47:22 <lambdabot>  Parse error in pattern at "in" (column 16)
10:47:31 <gabor> dmhouse: yes
10:47:37 <trofi> dmhouse: maybe not heuristics, but predefined rules for a..z ?
10:47:39 <dmhouse> gabor: confusing, I thought you'd left ;)
10:47:40 <trofi> :t a
10:47:42 <lambdabot> Expr
10:47:44 <Myoma> gabor: Can you please think of a better name than Foo?
10:47:55 <dmhouse> trofi: something heuristic-y along those lines, yes.
10:47:59 <gabor> Foo == ->
10:48:12 <gabor> of course that is not in Show
10:48:12 <trofi> :t hello
10:48:14 <lambdabot> Not in scope: `hello'
10:48:17 <trofi> :t hi
10:48:19 <lambdabot> Not in scope: `hi'
10:48:22 <dmhouse> gabor: is it actually (->), or is is a newtype of (->)?
10:48:25 <Myoma> ::t x
10:48:27 <trofi> it's good error :]
10:48:38 <trofi> > hi -- that's bad!
10:48:39 <lambdabot> Terminated
10:48:47 <centrinia> :t (->)
10:48:49 <lambdabot> parse error on input `->'
10:48:51 <centrinia> Weird.
10:48:57 <centrinia> Haskell is only first order. :(
10:49:00 <dmhouse> centrinia: not weird, (->) isn't a term.
10:49:01 <trofi> @kind (->)
10:49:03 <lambdabot> ?? -> ? -> *
10:49:15 <dmhouse> gabor: sorry, I have to go, but I'm sure others will answer your questions.
10:49:23 <gabor> dmhouse: it is a bit hard to explain, sorry
10:49:28 <trofi> > (<-) = (+) in 3 <- 4
10:49:28 <lambdabot>  Parse error at "<-)" (column 2)
10:49:40 <gabor> dmhouse: okay, I will nose around
10:49:43 <trofi> > let (<-) = (+) in 3 <- 4
10:49:43 <lambdabot>  Parse error at "<-)" (column 6)
10:50:13 <centrinia> > let (<--) = (+) in 3 <-- 4
10:50:15 <lambdabot>  7
10:50:18 <centrinia> That works. :)
10:51:52 <trofi> @kind (<-)
10:51:54 <lambdabot> parse error on input `<-'
10:52:11 <trofi> why?
10:52:21 <trofi> @kind stuff
10:52:23 <lambdabot> Not in scope: type variable `stuff'
10:52:48 <ManateeLazyCat> Bye, guys. Good night...
10:54:17 <mauke> trofi: <- is not an operator
10:54:36 <trofi> why?
10:54:41 <dsrogers> <- is syntatic sugar
10:54:54 <trofi> ah, yes. i forgot
10:55:24 <trofi> @undo do { t < - f; g }
10:55:25 <lambdabot> t < - f >> g
10:55:29 <Myoma> there is no reason <- couldn't also be a type operator
10:55:32 <trofi> @undo do { t <- f; g }
10:55:33 <lambdabot> f >>= \ t -> g
10:55:46 <centrinia> @do f >>= \t -> g
10:55:46 <lambdabot> f >>= \t -> g not available
10:55:54 <rwbarton> in a do block consider   foo :: Bar <- Baz   What does this mean if <- could be an infix type variable?
10:55:55 <trofi> it would be syntax anbiguity
10:55:56 <centrinia> I'm disappointed.
10:56:04 <Myoma> trofi: no it would not
10:56:04 <trofi> @redo
10:56:04 <lambdabot> ()
10:56:12 <Myoma> trofi: consider () :: ()
10:56:13 <idnar> @type hi
10:56:15 <lambdabot> Not in scope: `hi'
10:56:16 <centrinia> @redo f >>= \t -> g
10:56:16 <lambdabot> do { t <- f; g}
10:56:17 <Myoma> and \x -> x :: a -> a
10:56:19 <idnar> > blahblah
10:56:20 <lambdabot> Terminated
10:56:22 <centrinia> Okay, I'm not disappointed anymore. :)
10:56:23 <idnar> meh
10:56:33 <dsrogers> @undo do { t <- f; g t}
10:56:33 <lambdabot> f >>= \ t -> g t
10:56:37 <sw17ch> can Data.StorableVector be considered a generalization of ByteString?
10:56:46 <centrinia> @undo (@redo f >>= \t -> g)
10:56:46 <lambdabot>  Parse error at "@redo" (column 2)
10:56:46 <trofi> Myoma: if `<-' - had monad retval?
10:57:11 <centrinia> I think lambdabot should allow for nested directives.
10:57:27 <rwbarton> @. redo undo do { t <- f; g t }
10:57:27 <lambdabot> do { t <- f; g t}
10:57:31 <Myoma> since haskell is two languages —the value and the type language— it's not ambiguous
10:57:34 <centrinia> Cool. :)
10:58:02 <dsrogers> sw17ch: generalization in what sense?
10:58:19 <trofi> Myoma: (<-) = return; isn't it ambiguous?
10:58:33 <trofi> Myoma: bad example, should be binop
10:58:42 <trofi> with return
10:58:50 <Myoma> trofi: I said there's no reason <- couldn't be a _type_ operator
10:59:47 <roconnor> yay, a new monad reader
10:59:55 <centrinia> Yay!
11:00:35 <roconnor> should it be in the topic?
11:00:44 <trofi> @go haskell type operator
11:00:44 <sw17ch> dsrogers, ByteString operates on elements of length 1 byte
11:00:46 <lambdabot> http://www.haskell.org/tutorial/classes.html
11:00:46 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
11:01:01 <sw17ch> dsrogers, StorableVector seems to be able to take things of n length
11:01:08 <sw17ch> and pack them, or am i wrong
11:01:22 <Myoma> trofi: -> is a type operator, Maybe is as well
11:01:58 <trofi> ah, you are about failed `@kind (<-)' ?
11:02:17 <Myoma> I would like type b <- a = a -> b
11:03:37 <dsrogers> Myoma: that simply isn't the case.
11:03:44 <dsrogers> <- and -> do different things
11:03:53 <Myoma> dsrogers: <- is not a type operator in haskell
11:04:02 <Myoma> dsrogers: I would like it to be
11:05:59 <skorpan> class (Monad m) => MonadState s m | m -> s where
11:05:59 <skorpan> what does "| m -> s" mean?
11:06:15 <opqdonut> skorpan: functional dependencies
11:06:20 <opqdonut> it means "m determines s"
11:06:27 <skorpan> oh...
11:06:32 <opqdonut> aka "s is a function of m"
11:06:33 <Myoma> during typechecking/inference s may be calculated from m
11:06:36 <opqdonut> yeah
11:07:10 <opqdonut> if we have one instance "MonadState A B", and we have "MonadState x B" we can unify x=A
11:08:43 <opqdonut> err, that didn't come out quite right
11:09:24 <opqdonut> but you probably catch my drift
11:09:26 <Myoma> that sounds correct to me
11:09:50 <opqdonut> yeah I just managed to phrase it in a funny way
11:10:11 <dsrogers> skorpan: it means that if you have an instance declaration for MonadState, with a given m, you can't have a second one with a given m.
11:10:41 <Myoma> dsrogers: That's not strictly true
11:11:06 <dsrogers> skorpan: (at least in scope).  It has two results.  It resolves some type ambiguities, and this determination is enforced by the type system.
11:11:17 <dsrogers> Myoma: it's true for any particular scope.
11:11:29 <Smurfen_> skorpan: Are you doing the exam? :D
11:11:50 <dsrogers> Myoma: ooo I may have gotten that relationship backwards.
11:14:00 <dsrogers> m->s is read as "m uniquely determines s"  Which means you're not allowed to create a situation where two MonadState instances are declared with m and two different s'es
11:20:01 <dsrogers> skorpan: does that answer your question?
11:23:15 <skorpan> dsrogers: yes, thank you
11:26:15 <sw17ch> dsrogers, i had to step out for a second, did you get my resposne?
11:33:41 <mapreduce> dmhouse: An answer to my earlier question, without a Monad type you can't implement sequence.
11:33:49 <mapreduce> s/type/name/
11:33:50 <tristes_tigres> hi
11:34:07 <dmhouse> mapreduce: yes, because you need (>>=) and return for sequence, just like for do blocks.
11:34:33 <mapreduce> Is there a similar function that makes Arrow necessary?
11:34:41 <dmhouse> mapreduce: you could write your own MyMonad class with your own myBind and myReturn, and write mySequence using that, but you wouldn't get do-block sugar. That's what I thought you meant.
11:34:48 <tristes_tigres> mapreduce: what about a list ? you can implement sequence with lists
11:35:06 <mapreduce> [a] is a monad.
11:35:41 <dmhouse> mapreduce: how about any of the functions in http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html, outside of the base Arrow typeclass?
11:35:42 <mapreduce> tristes_tigres: Yes, but it won't then work for a list of maybes.
11:35:42 <lambdabot> Title: Control.Arrow, http://tinyurl.com/y6yt3s
11:36:11 <mapreduce> :t sequence
11:36:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:36:22 <mapreduce> > sequence [Just 2, Just 3]
11:36:24 <lambdabot>  Just [2,3]
11:36:44 <nominolo> @pl \w -> GHCi $ \_ -> liftIO m
11:36:44 <lambdabot> const (GHCi (const (liftIO m)))
11:36:49 <nominolo> @pl \m -> GHCi $ \_ -> liftIO m
11:36:49 <lambdabot> GHCi . const . liftIO
11:41:26 <r3m0t> :t GHCi
11:41:28 <lambdabot> Not in scope: data constructor `GHCi'
11:42:26 <trofi> @hoogle ghci
11:42:26 <lambdabot> Distribution.InstalledPackageInfo extraGHCiLibraries :: InstalledPackageInfo -> [String]
11:42:26 <lambdabot> Distribution.Simple.Setup configGHCiLib :: ConfigFlags -> Bool
11:42:26 <lambdabot> Distribution.Simple.LocalBuildInfo withGHCiLib :: LocalBuildInfo -> Bool
11:54:11 <xif> what was the name of that library that automatically generates tests from Haskell code?
11:54:29 <roconnor> QuickCheck?
11:54:32 <Vq^> quickcheck?
11:54:44 <r3m0t> quickheck?
11:54:51 <dmhouse> I think it's probably QuickCheck.
11:54:52 <dons> QuickCheck!!
11:54:53 <b\6> quickcheck?
11:55:01 <xif> hehe, thanks, it's QuickCheck :)
11:55:04 <Deewiant> smallcheck?
11:55:04 <lament> quickcheck?
11:55:06 <r3m0t> My sources say it's QuickCheck
11:55:10 <b\6> quickcheck.
11:55:11 <lambdabot> QuickCheck is your answer.
11:55:15 <roconnor> smallcheck!
11:55:21 <Deewiant> signs point to smallcheck
11:55:23 <lament> @faq QuickCheck?
11:55:23 <lambdabot> The answer is: Yes! Haskell can do that.
11:55:25 <dmhouse> ThisIsGettingOldCheck
11:55:28 <Vq^> :/
11:55:33 * QuickCheck
11:55:36 <lament> @quote quickcheck
11:55:36 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
11:55:36 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
11:55:36 <lambdabot> still
11:56:18 * Vq^ got some small latency on his connection and now #Haskell is ruined
11:56:21 <roconnor> dons: do you think TMR should go in the topic?
11:56:25 <dons> hmm
11:57:23 <b\6> confused about what parsec parse can take for its s parameter. it kind of looks like it has to be a Stream, but somehow i can pass normal Strings.
11:58:27 <b\6> and is parsec's Stream its own thing not to be confused with any of the other various Streams?
11:58:28 <ddarius> A String is a Stream
11:58:32 <b\6> how?
11:58:37 <ddarius> Yes, it is a type class.
12:00:52 <b\6> ok, i see where in parsec it makes String an instance of Stream.
12:03:05 <b\6> well, not really. there's a comment to that effect, but i don't see it's true.
12:06:13 <Pistahh> @source liftIO
12:06:13 <lambdabot> liftIO not available
12:06:29 <Pistahh> @source liftM
12:06:29 <lambdabot> liftM not available
12:06:34 <Pistahh> @source map
12:06:35 <lambdabot> map not available
12:06:40 <thoughtpolice> @src map
12:06:40 <lambdabot> map _ []     = []
12:06:41 <lambdabot> map f (x:xs) = f x : map f xs
12:06:44 <thoughtpolice> @src liftM
12:06:45 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:07:33 <Deewiant> @help source
12:07:33 <lambdabot> source <lib>. Lookup the url of fptools libraries
12:09:44 <kaol> I'm tempted to define a nullary function that returns "return ()". It could be called "skip" or "relax".
12:10:03 <Myoma> whatever
12:10:07 <Myoma>   = return ()
12:11:25 <kaol> then again, I should probably be using when
12:11:43 <Pistahh> :)
12:11:47 <Pistahh> @src liftIO
12:11:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:12:17 <_zenon_> Is there some statistics in lambdabot for the most recurring @src ?
12:12:39 <mauke> I don't think so but you can grep the logs
12:12:48 <kaol> though that works poorly when I have a function that returns a Maybe. I often have case ... of Nothing -> return ()
12:13:07 <_zenon_> mauke, yeah.
12:13:30 <Trin> Hi, please anybody, how do i do password input in haskell? Like suppressing stdin from repeating on stdout.
12:14:13 <dmhouse> kaol: you could write useJust :: Monad m => Maybe a -> (a -> m ()) -> m (), useJust (Just x) f = f x; useJust Nothing _ = return ()
12:14:28 <stepcut> Trin: hSetEcho
12:14:33 <dmhouse> kaol: then write do let x = stuff; useJust x $ \x' -> do ...
12:14:39 <Myoma> :t fmap
12:14:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:14:46 <kaol> oh. it's liftM I'm thinking of
12:14:51 <kaol> or fmap if you like
12:14:56 <stepcut> Trin: hSetEcho stdin False, probably
12:15:04 <lilac> @djinn (a -> b) -> (c -> a) -> (c -> b)
12:15:04 <lambdabot> f a b c = a (b c)
12:15:34 <Trin> Ah, Terminal operations. Many thanks.
12:17:57 <kaol> no, liftM isn't quite it... the case ... of (Just x) -> ... happens in a different monad.
12:18:08 <r3m0t> @pl (\a b c -> a (b c))
12:18:08 <lambdabot> (.)
12:18:09 <lilac> kaol: sounds like you want MonadT
12:18:14 <lilac> sorry, MaybeT
12:18:19 <Myoma> MaybeT doesn't exist
12:18:23 <Myoma> ?wiki MaybeT
12:18:24 <lambdabot> http://www.haskell.org/haskellwiki/MaybeT
12:18:31 <lilac> yes it does, just not in std libs
12:18:39 <mauke> @hoogle ErrorT
12:18:39 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
12:18:39 <lambdabot> Control.Monad.Error newtype ErrorT e m a
12:18:39 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
12:18:41 <r3m0t> and not in the wiki
12:18:48 <Myoma> it is in the wiki
12:18:55 <Myoma> ?wiki New_Monads/MaybeT
12:18:55 <lambdabot> http://www.haskell.org/haskellwiki/New_Monads/MaybeT
12:19:01 <Myoma> it's not there though
12:19:34 <lilac> I think you mean...
12:19:38 <lilac> ?wiki New_monads/MaybeT
12:19:39 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:21:09 <kaol> I'm using find from Data.List which returns a Maybe a anyway, so I'd gain little with MaybeT
12:21:39 <kaol> it doesn't matter much. I just felt that I might have been missing some abstraction. Nothing -> return () just seems so ugly.
12:21:56 <Myoma> kaol:
12:21:58 <Myoma> :t maybe
12:22:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:22:19 <kaol> @src maybe
12:22:19 <lambdabot> maybe n _ Nothing  = n
12:22:19 <lambdabot> maybe _ f (Just x) = f x
12:22:41 <Myoma> there's only one thing it could be based on the type
12:22:57 <kaol> I was too lazy to think
12:23:01 <lilac> kaol: which monad are you in?
12:23:04 <kaol> Q
12:23:07 <Myoma> lazy is good
12:23:21 <lilac> @src Q fail
12:23:21 <lambdabot> Source not found. You untyped fool!
12:24:00 <kaol> lilac: it's what template haskell uses. I'm making some checks and stop compiling if the user gave bad input.
12:24:28 <lilac> kaol: i know the monad; i'm wondering if there's a better way than your Nothing -> return ()
12:24:33 <lilac> kaol: can you paste your code?
12:26:08 <kaol> the part I have is just like this: case (find ...) of Nothing -> return (); (Just a) -> report "something"
12:26:41 <lilac> where report :: String -> Q () ??
12:27:02 <Myoma> maybe (return ()) (const (report "something")) (find ...)
12:27:04 <kaol> this all is just a distraction anyway. I'm trying to make the code type check and this isn't the reason why it doesn't
12:29:46 <lilac> when (isJust $ find ...) (report "something")
12:30:43 <lilac> presumably your (report "something") actually uses a?
12:31:23 <_zenon_> ah, good old awk
12:33:26 <kaol> lilac: yes, it's a string that gets appended to the error to tell what went wrong (or I would've used elem in the first place)
12:41:22 <hackage> Uploaded to hackage: plugins 1.3
12:47:02 <mauke> preflex: seen mauke_
12:47:02 <preflex>  Sorry, I haven't seen mauke_
12:47:59 <Myoma> if you see evidence for something and assume it's true, what's that called?
12:48:13 <Myoma> specifically when you don't have proof
12:48:14 <monochrom> Testing. :)
12:48:36 <dmhouse> A scientific proof?
12:48:48 <binrapt> "evidence but no proof"
12:48:49 <monochrom> Test-driven programming. :)
12:49:01 <tylere> does any other language implement implicit pattern matching trough multiple function definitions...that's my favorite bit of haskell so far...such an elegant syntax
12:49:04 <sw17ch> Myoma, a hypothesis
12:49:05 <Twey> Myoma: 'Faith'
12:49:10 <binrapt> "Assuming something to be true, without having proof"
12:49:11 <binrapt> - religion!
12:49:14 <ziman> empirical `proof'
12:49:16 <Twey> binrapt: :)
12:49:18 <binrapt> Haha damn Twey beat me to it
12:49:21 <Myoma> I'm seeing like
12:49:29 <Myoma> A -> B -> C -> D
12:49:32 <Myoma> a lot
12:49:44 <Myoma> and somebody sees A then says, well D must be true
12:49:52 <Myoma> but they don't know about A -> X -> Q -> D
12:50:07 <SCHREI> is tim buckley really making it happen? is he letting ethan crash and burn?
12:50:10 <monochrom> What is your -> ?
12:50:16 <Myoma> mmm that's not quite what I meant
12:50:19 <Myoma> -> is implication
12:50:27 <Myoma> they see A and D, and assume it went via B and C
12:50:30 <dobblego> non sequitur "it does not follow"
12:50:37 <monochrom> that's induction
12:50:44 <Myoma> but the thing is it could follow, but in this case it doesn't
12:51:01 <sw17ch> SCHREI, Ctrl+Alt+Del has been a worthless comic for a while, but why in #haskell?
12:51:03 <monochrom> If you also have probabilities, that's bayesian inference.
12:51:11 <Myoma> the biggest problem is how does one break out the training of seeing A and D and assuming -> B -> C -> ..?
12:51:14 <dobblego> perhaps "begging the question"
12:51:39 * Myoma is not entirely sure naming the exact process would help with breaking free from it 
12:51:44 <SCHREI> sw17ch, I think that would actually increase it's value... and it was just wrong window :(
12:52:08 <monochrom> Oh you asked what it's called.
12:52:09 <dobblego> counselling
12:52:18 <sw17ch> SCHREI, :) no hard feelings... it jsut stopped being funny to me a while ago...
12:52:27 <Myoma> Yeah I do want a name for it ..
12:52:31 <monochrom> To break free from it, denounce neural networks.
12:52:35 <dobblego> Socratic Midwife?
12:52:37 <SCHREI> sw17ch, yeah, same here
12:52:48 <SCHREI> anyway, as you said, wrong channel %)
12:54:30 <Myoma> I don't know if it's even clear what I tried to describe
12:54:41 <monochrom> It's clear to me. :)
12:55:38 <Myoma> I guess it's the same as stopping a bad habit
12:57:34 <Myoma> "Sometimes we discover unpleasant truths. Whenever we do so, we are in difficulties: suppressing them is scientifically dishonest, so we must tell them, but telling them, however, will fire back on us. If the truths are sufficiently impalatable, our audience is psychically incapable of accepting them and we will be written off as totally unrealistic, hopelessly idealistic, dangerously revolutionary, foolishly gullible or what have you"
12:57:35 <Myoma> :D
12:57:45 <earthy> Dijkstra
12:58:01 <earthy> 'how do we tell truths that might hurt'
12:58:42 <thetallgu1> Lewis Thomas said something similar, that the hardest part of being a scientist is tossing out your pet ideas that turn out to be false.
12:58:45 <sw17ch> any one have a source for that quote? I'm having an argument with my mother in which that might come handy...
12:59:09 <Myoma> thetallgu1: Oh that's like the dual of what I was thinking about
13:00:00 <thetallgu1> Yes, one is about the internal argument, one about the external
13:00:03 <earthy> switch: The quote is from Dijkstra, from his note 'How do we tell truths that might hurt' ,, ewd 498
13:00:28 <Myoma> hmm
13:00:41 <earthy> ACM SIGPLAN Notices Volume 17, issue 5, may 1982, pages 13 to 15
13:00:42 <Myoma> thetallgu1: Really it is difficult to figure out which situation one is in
13:03:41 <sw17ch> "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration."
13:03:52 <b\6> come on, that's crazy.
13:04:22 <tylere> I had kinda the oppisite problem
13:04:31 <tylere> the first language I really learned was python..
13:04:32 <sw17ch> earthy, thanks
13:04:41 <earthy> b\6: in 1982 it wasn't
13:04:52 <tylere> so most everything else (not haskell!) just drives me nuts
13:04:57 <Myoma> tylere: sounds like the same problem
13:05:03 <earthy> sw17ch: my pleasure. :)
13:05:05 <b\6> earthy: nobody's 'mentally mutilated' by exposure to some idea that isn't as good as some other idea.
13:05:08 * sw17ch was born in 1986... finds things from 1982 to be old... but fantastically helpful
13:05:27 <tylere> kinda, except I wsa missing what I'd learned to need, instead of refusing to learn what I didn't rhink I need...
13:05:28 <Myoma> b\6: it can happen
13:05:55 <tylere> for some problem types, python is just so elegant... runtime introspection and the like can lead to some truly amazing hacks
13:05:58 <sw17ch> b\6: it can happen for a *lot* of things. (Vaccines, Young Earth Creationism, String Theory...)
13:06:04 <EvilTerran> b\6, i can vouch for many of those on my compsci course who've learnt other languages before the uni taught them python struggling considerably
13:06:17 <EvilTerran> er, s/python/haskell/
13:06:29 <pjdelport> tylere: you know http://lukeplant.me.uk/blog.php?id=1107301645 right?
13:06:32 <EvilTerran> got a wire crossed between the reading and typing parts of my brain :P
13:06:39 <r3m0t> EvilTerran: and many... not?
13:06:41 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
13:06:51 <atomb> EvilTerran: so have you found that people who haven't programmed before find it easier to pick up Haskell?
13:06:58 <atomb> i've always wondered if that was true
13:07:03 <atomb> and suspected it might be
13:07:08 <EvilTerran> r3m0t, yes, there are cases t'other way round
13:07:12 <earthy> one of the reasons for teaching Clean to first year students in Nijmegen was that it would put all students on equal footing, not knowing anything about the language
13:07:26 <EvilTerran> r3m0t, but i know some folk who, from talking to them, really struggled to break the imperative mindset
13:07:27 <tylere> pjdelport: reading...
13:07:46 <r3m0t> atomb: the course doesn't go as far as monads, just to clarify what we're talking about
13:07:58 <sw17ch> pjdelport, that's a fantastic piece: "I am constantly aware that I am writing traps that other people are likely to fall in."
13:07:59 <pjdelport> tylere: the one line summary is "Python and Haskell make you unhappy working in other languages"
13:08:08 <earthy> ofcourse, that didn't take into account that those that had prior programming exposure were worse of than those that didn't do any programming before
13:08:11 <tylere>  yea, I'd say that's true
13:08:23 <tylere> I think I'm currently settling on haskell as my least-evil language ;)
13:08:39 <tylere> wanted someting that keeps me sane, while being native code compilable
13:08:49 <Myoma> I hear people say that about lisp too
13:08:50 <tylere> with haskell and ocaml being the main contendors
13:09:01 <tylere> I tried lisp...ran into two major roadblocks there
13:09:03 <EvilTerran> atomb, yes, although i think it's as much a matter of how you present the language than the peopl ethemselves
13:09:07 <earthy> unix makes you unhappy to use most other OSes
13:09:08 <r3m0t> after Haskell I worked a lot on moving my side effects into little marked boxes
13:09:09 <pjdelport> tylere: Python is native code compilable
13:09:34 <EvilTerran> if you present haskell as "a programming language", people with the imperative mindset will go write imperative haskell and complain that haskell is an ugly language
13:09:38 <tylere> Despire really trying, for several months, I never could get used to the syntax, and it's not practical to deliver a binary (I mean, you CAN, but you have to basically ship a full lisp system)
13:10:05 <pjdelport> tylere: Common Lisp?
13:10:08 <pjdelport> what about Scheme?
13:10:10 <Myoma> tylere: or source code
13:10:11 <tylere> pjdelport: Well, sorta. Pysco is interesteing, and there's py2exe on windows, but it's not really easy to create a single binary file that will run on a client machine without intalling the lang
13:10:13 * sw17ch like's scheme syntax... usually uses the expressions to communicate ideas
13:10:21 <Myoma> tylere: source code can be smaller in size than a lisp compiler
13:10:25 <dons> tylere: it what way was it hard to deliver a binary?
13:10:26 <tylere> yea ;)
13:10:28 <sw17ch> i don't usually write scheme programs, but as a raw "here's the concept", it works well
13:10:29 <dons> no statically linked executables?
13:10:31 <pjdelport> tylere: there is also Pyrex
13:10:34 <EvilTerran> if you present haskell more from analogies with, say, spreadsheets, mathematical expressions, etc
13:10:42 <EvilTerran> i find people get less confused
13:10:46 <pjdelport> but yeah, i see what you mean
13:10:49 <EvilTerran> because those systems do not have side effects
13:11:03 <atomb> EvilTerran: yeah, that makes sense
13:11:05 <tylere> while I appreciated lisp, and think it's pretty low on the suckiness scale, the verbosity kinda gets to me
13:11:08 <pjdelport> standalone image
13:11:31 <Myoma> tylere: "verbosity" is one thing I have not noticed ..
13:11:34 <tylere> having to do (setf (aref myarray 3) "foo") instead of myarray[3] = 'foo' adds up
13:11:43 <b\6> is the streams library by bulat still a going concern and in hackage? there are a few 'stream' named libraries but none of them seem to be the one with vGetContents, etc.
13:11:45 <r3m0t> this "Haskell/Python" article writer doesn't seem to know about C# lambda expressions
13:12:45 <r3m0t> `concat $ List.intersperse "\n" $ filter (/="") $ map description foos` can be as simple as
13:12:49 <pjdelport> r3m0t: i think the article predates them
13:13:11 <r3m0t> pjdelport: no, he said C# 2.0. I used it in my last... hang on...
13:13:33 <r3m0t> oh, I wrote C# 3.0 targetting .Net 2.0
13:13:41 <Myoma> :t concat . intersperse
13:13:44 <lambdabot>     Couldn't match expected type `[[a]]'
13:13:44 <lambdabot>            against inferred type `[a1] -> [a1]'
13:13:44 <lambdabot>     Probable cause: `intersperse' is applied to too few arguments
13:13:49 <Myoma> :t concat . intersperse "\n"
13:13:51 <lambdabot> [[Char]] -> [Char]
13:13:55 <Myoma> :t intercalate
13:13:57 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:14:03 <r3m0t> that is a little confusing. anyway, if he updated his version for a mere $800 or so, it could be
13:14:13 <EvilTerran> @yarr
13:14:13 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
13:14:20 <Myoma> intercalate "\n" . filter (not . null) . map description
13:14:22 <opqdonut> @. elite yarr
13:14:22 <lambdabot> Y4rrR!
13:14:26 <opqdonut> !
13:14:41 <_zenon_> http://hpaste.org/9924 A more or less accurate counting of #src's
13:14:56 <r3m0t> string.Join("\n", mylist.ConvertAll<string>(f => foo.Description()).FindAll(x => x != "").ToArray());
13:14:56 <Myoma> cool
13:15:03 <Myoma> @src (->)
13:15:03 <lambdabot> Source not found. Wrong!  You cheating scum!
13:15:44 <tromp> @src ([])
13:15:44 <lambdabot> Source not found. :(
13:15:48 <EvilTerran> ?src []
13:15:48 <lambdabot> data [] a = [] | a : [a]
13:15:52 <EvilTerran> it's not an operator
13:16:16 <r3m0t> @src @src
13:16:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:16:28 <pjdelport> @sauce map
13:16:28 <lambdabot> map not available
13:17:39 <mauke> @sauce Data.Map
13:17:39 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
13:18:40 <EvilTerran> @soup Prelude
13:18:40 * lambdabot smashes a lamp on Prelude's head
13:18:44 <EvilTerran> ... what?
13:18:59 <EvilTerran> ah, that's @slap, not @source
13:19:16 <mauke> @shapr EvilTerran
13:19:16 <lambdabot> go slap EvilTerran yourself
13:19:39 <Botje> @force luke
13:19:39 <lambdabot> Maybe you meant: forget free more source
13:19:50 <r3m0t> @sauce lambdabot
13:19:50 <lambdabot> lambdabot not available
13:19:52 <mauke> free more source!
13:20:04 <mauke> channeling rms, are we
13:21:23 <sw17ch> mmm... lambdabot sauce
13:22:00 <byorgey_> I am going to kill Verizon with my bare hands
13:23:24 <byorgey_> ok, advice please: I want to write a very simple web app in Haskell.  I don't want it to be pretty, it doesn't have any state, it doesn't need to scale, I just want to get it work as quickly as possible.  what's my best bet?
13:23:48 <mauke> CGI
13:24:10 <EvilTerran> ?hackage cgi
13:24:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cgi
13:24:23 <byorgey_> ah, sweet
13:24:28 <byorgey_> just what I'm looking for, thanks
13:24:32 <r3m0t> pretty-stateful-scalable-haskell
13:24:36 <byorgey_> I missed that because it was under 'Network' not 'Web'
13:24:37 <sw17ch> byorgey, my last verizon bill was over $200 for two cellurlar lines
13:24:44 <byorgey_> sw17ch: eek!
13:24:46 <sw17ch> the WTF factor was huge, i ruined a reps night
13:24:54 <mauke> technically, you don't need Network.CGI
13:25:01 <mauke> the CGI protocol is pretty simple
13:25:14 <byorgey_> mauke: fair enough, but remember, I want to get this to work as fast as possible =)
13:25:14 * sw17ch hates Verizon, but wants FIOS...
13:25:40 <mauke> main = putStr "Content-type: text/plain\n\nHello, CGI!\n"
13:26:02 <byorgey_> sw17ch: my bills are nowhere near that high, but they are about 5 billion percent too high considering the level of service they provide me =P
13:26:23 <Twey> mauke: The HTTP standard mandates CRLF line endings
13:26:38 <mauke> Twey: irrelevant; this is not a HTTP header
13:27:07 <Twey> Oho
13:27:18 <sw17ch> byorgey_, the service near me is usually pretty good... but i'm paying for a (minimum) of 700 minutes between me and my wife, and we use a grand total of... 50 minutes per month...
13:27:26 <tylere> there's no easy way to use GHC Bytestrings for the String type is there? You have to actually use the ByteString api, right?
13:27:28 <mauke> yeah, it's a CGI header, to be parsed by the web server
13:27:39 <sw17ch> tylere Data.ByteString.Char8?
13:28:08 <Cale> tylere: Right. String is defined as [Char]. There are however functions for converting back and forth.
13:28:10 <byorgey_> sw17ch: yeah, I'm talking about landline+DSL, I don't know what their cell service is like
13:28:20 <tylere> Cale: ok
13:28:22 <sw17ch> byorgey_: it's okay, but ungodly expensive
13:28:31 <sw17ch> but then again, which carrier isn't
13:28:36 <byorgey_> yeah
13:28:45 <tylere> I really haven't studied them yet, but I've heard that basically it's the way to get string processing to not suck efficiency wise
13:29:23 <sw17ch> tylere, ByteString is much more similar to the char* strings of C, whereas a native String is a linked list of Char's
13:29:26 <SamB_XP> well, tracphone isn't horribly expensive ... but I don't think they have any services besides voice and SMS ...
13:29:31 <sw17ch> on a 64bit machine, you get some pretty serious overhead
13:29:39 <tylere> yea
13:29:53 <Philonous> @type pack
13:29:54 <tylere> that is the one language choice in Haskell that sorta makes me scratch my head
13:29:55 <EvilTerran> on a 32bit machine, you get some pretty serious overhead
13:29:55 <lambdabot> Not in scope: `pack'
13:30:34 <pjdelport> tylere: [Char] is more generic
13:30:37 <EvilTerran> tylere, the report doesn't say [Char] must  be implemented that way, as long as the semantics remain the same
13:30:40 <sw17ch> tylere, it's because everything is defaulted to a list. if something needs to be not-a-list, it's up to the programmer to figure out the best representation. luckily, it's not too hard :)
13:30:47 <tylere> heh
13:30:59 <pjdelport> you can have infinite or circularly-defined strings, for example
13:31:11 <Cale> Of course, Chars are full unicode characters and not bytes... however, the I/O routines still suck a bit. I hope they get fixed to do unicode by default in the next version of GHC.
13:31:11 <Philonous> @type Data.ByteString.pack
13:31:13 <sw17ch> > let x = 'a':x in x
13:31:15 <byorgey_> tylere: it seems prety consistent with Haskell's language design in general.  Haskell tends to go with the theoretically elegant definitions first, and work out efficiency issues later
13:31:15 <lambdabot> [Word8] -> BSC.ByteString
13:31:15 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:31:27 <EvilTerran> as sw17ch says, everything is a list by default -- lists are to haskell what loops are to imperative languages
13:31:34 <pjdelport> > fix ('a':)
13:31:38 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:31:40 <EvilTerran> i'd argue even more so than recursion is to haskell what loops are to imperative languages
13:32:04 <Cale> Well, recursion is to Haskell what recursion is to imperative languages ;)
13:32:05 <Cale> hehe
13:32:06 <SamB_XP> > repeat 'a'
13:32:07 <EvilTerran> quite
13:32:09 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:32:12 <EvilTerran> it's more general
13:32:17 <pjdelport> algebraic data types are reified controls structures
13:32:21 <Myoma> lists are loops is one instance of data is control (structures)
13:32:21 <EvilTerran> while lists and loops are both 1-dimensional
13:32:47 <Myoma> (which is an instance of data = code)
13:32:53 <Trinithis> @hoogle cthulhu
13:32:54 <lambdabot> No results found
13:33:34 <EvilTerran> Iah.Iah.Cthulhu.Fthaghn cthulhu :: IO Insanity
13:33:54 <Smurfen_> Hahaha
13:34:09 <pjdelport> unsafeInvokeCthulu
13:34:10 <SamB_XP> @google cthulhu
13:34:13 <lambdabot> http://en.wikipedia.org/wiki/Cthulhu
13:34:13 <lambdabot> Title: Cthulhu - Wikipedia, the free encyclopedia
13:34:22 <mauke> call/cthulhu
13:34:30 <EvilTerran> hahah
13:34:41 <Myoma> oh it turns uot the heap lambda machine doesn't do lazy evaluation
13:34:41 <eu-prleu-peupeu> hello people from planet haskell
13:34:42 <EvilTerran> @remember mauke call/cthulhu
13:34:43 <lambdabot> I will remember.
13:34:50 <Myoma> I don't know what it does.. though
13:34:54 <EvilTerran> @quote mauke
13:34:55 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
13:35:30 <mauke> @quote mauke
13:35:30 <lambdabot> mauke says: trees are hierarchical
13:35:34 <SamB_XP> eu-prleu-peupeu: I am not from planet Haskell
13:35:39 <SamB_XP> I don't even HAVE a blog
13:40:14 <Myoma> what are the main different ways to compile pattern matching?
13:45:34 * tristes_tigres thinks the type signature askOut :: Female -> Maybe Date is not quite right
13:45:43 <tristes_tigres> Because female is stateful
13:46:27 <dmhouse> askOut :: StateT Female Maybe Date?
13:46:34 <elliottt> IO, surely
13:46:47 <dmhouse> Also, let's not be sexist, this is a modern world.
13:46:53 <dmhouse> askOut :: Gender g => StateT g Maybe Date?
13:47:06 <tristes_tigres> yes, I think it is in the IO, but also in the proposed Random monad
13:49:40 * Saizan wants a top-level monad
13:51:21 <EvilTerran> given that ordering isn't particularly relevant in the toplevel, wouldn't that be a bit odd?
13:54:05 <ddarius> Cale: Do you use a tablet with Inkscape?
13:54:13 <Saizan> EvilTerran: right, but i need finer control over lexical scopes, and ensuring some functions are defined at toplevel would help
13:55:06 <EvilTerran> hm
13:55:23 <EvilTerran> i suspect a monad may be the wrong abstraction, but i can kinda see what you're getting at
13:55:52 <Saizan> maybe i can use two nested monads and some form of tainting
13:58:36 <b\6> Saizan: what you do in the privacy of your home is your business; just make sure they're over 18.
13:59:09 <Myoma> moths are pretty stupid
13:59:24 <Myoma> they sleep all day, and then they get up at night and go looking for lights
14:00:09 <EvilTerran> if they didn't hide during the day, maybe they'd try to fly into the sun and die of insufficient oxygen in the upper atmosphere
14:00:21 <Myoma> that sounds like a very moth thing to do
14:00:40 <b\6> it's just that once they get into space they have no more propulsion.
14:00:54 <Myoma> wings work in space
14:01:10 <b\6> well, only because they're coated with magic dust.
14:01:14 <Myoma> well, I assume they do, since flippers work in space
14:01:16 <b\6> but solar wind blows that off.
14:01:35 <ddarius> Myoma: What?
14:02:04 <EvilTerran> fnord!
14:02:19 <b\6> just got to have special aether flippers.
14:04:42 <dons> dcoutts_: bumped bytestring and binary (added whnf decodeFile)
14:04:54 <ddarius> It would be funny to see a bird in a space shuttle.
14:06:00 <b\6> hmm, wonder if a bird would get used to low g.
14:06:04 <FunctorSalad> is this safe? class (Fooable x) => (Fooable (Bump x))
14:06:13 <FunctorSalad> s/class/instance/
14:06:13 <ddarius> b\6: Sure it would.
14:06:21 <FunctorSalad> naively it would seem to loop
14:06:44 <ddarius> FunctorSalad: Of course it is.
14:06:48 <Saizan> FunctorSalad: why? the recursion is on a smaller argument
14:07:06 <ddarius> instance Eq a => Eq [a]
14:07:49 <FunctorSalad> hmm... what was I thinking
14:08:57 <FunctorSalad> in my actual code only one argument gets smaller, that confused me
14:09:07 * Myoma wonders what "foo" actualy means
14:09:18 <FunctorSalad> (with Fooable having two params)
14:09:20 <dons> newsham: new binary and bytestring pushed, with whnf strict decodeFile as discussed
14:10:20 <FunctorSalad> Myoma: see jargon file
14:10:40 <FunctorSalad> doesn't have a definite answer though
14:10:41 <ddarius> @jargon foo
14:10:42 <lambdabot> *** "foo" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:10:42 <lambdabot> foo /foo/ 1. interj. Term of disgust. 2. [very common] Used very
14:10:42 <lambdabot>    generally as a sample name for absolutely anything, esp. programs and
14:10:42 <lambdabot>    files (esp. scratch files). 3. First on the standard list of
14:10:42 <lambdabot>    {metasyntactic variable}s used in syntax examples. See also {bar},
14:10:44 <lambdabot> [95 @more lines]
14:10:59 <Myoma> well that didn't help
14:11:03 <Philonous> > let sbt (x:xt) = [x]: (map (x:) sxt) ++ sxt where sxt = sbt xt in sbt [1..]
14:11:05 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
14:11:17 <atomb> i generally think of it as a misspelling of the first half of "fubar"
14:11:22 <Myoma> > map (\x->[1..x]) [1..]
14:11:24 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
14:11:34 <mauke> except foobar is possibly older than fubar
14:11:35 <atomb> which is why "bar" is often the other metasyntactic variaable
14:11:44 <atomb> mauke: yeah?
14:11:51 <atomb> interesting!
14:11:57 <Philonous> foobar could also be "ftp operation over big adress records"
14:12:02 <mauke> http://www.catb.org/~esr/jargon/html/F/foo.html
14:12:06 <FunctorSalad> I wonder what's the origin of the qux, quux, quuux, quuuux, .... hierarchy.
14:12:07 <lambdabot> Title: foo
14:12:24 <ddarius> FunctorSalad: Either Steele or Sussman
14:12:32 <Myoma> The Great Quux
14:12:41 <newsham> dons: awesome.  will check it out.
14:13:08 <Myoma> ddarius: is x86_64 ridiculously complicated for a beginner?
14:13:54 <ddarius> Myoma: The assembly language of it?
14:13:58 <Philonous> > let sbt (x:xt) = [x]: (map (x:) sxt) ++ sxt where sxt = sbt xt in sbt [1..9]
14:14:00 <Myoma> yes
14:14:00 <FunctorSalad> heh... 'In some circles, used as a punning opposite of "crux".
14:14:00 <FunctorSalad>      "Ah, that's the quux of the matter!"'
14:14:00 <lambdabot>  mueval: [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,...
14:14:43 <ddarius> Myoma: I doubt it.  My understanding is that it is the x86 with some 64-bit registers and operators.  There is probably a decent chunk of other stuff, but you don't need to worry about it in most cases.
14:14:54 <Myoma> ok great
14:15:16 <Philonous> I wish haskell would deduce the trivial case of functions automaticly
14:15:28 <Myoma> Philonous: You should learn about foldr
14:16:22 <Philonous> It doesn't always save me
14:17:01 <FunctorSalad> Philonous, coq can do that IIRC
14:17:06 <pjdelport> djinn
14:17:16 <FunctorSalad> of course it's far less mature than haskell
14:17:19 <Myoma> coq can do more than trivial cases
14:18:34 <pjdelport> Myoma: x86_64 removes some cruft too
14:19:28 <newsham> luckily there was enough cruft to go around.
14:19:43 <pjdelport> heh
14:20:17 <FunctorSalad> Philonous: if you do it a lot, chances are there's some sensible abstraction lurking there
14:20:48 <pjdelport> Myoma: one important change is switching to linear addressing
14:21:27 <Myoma> I'm read the abi notes now
14:21:30 <Myoma> reading*
14:22:15 <ddarius> http://www.intel.com/products/processor/manuals/
14:22:20 <lambdabot> Title: Intel® 64 and IA-32 Architectures Software Developer's Manuals
14:23:31 <Cale> ddarius: No, just a mouse.
14:23:54 <Philonous> FunctorSalad: I'm prolly just not familiar enough with haskell's idioms. I'm still thinking in somehwat iterative terms
14:24:28 <Myoma> now I just need to think of something to do
14:24:37 <Cale> > inits [1..9]
14:24:39 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
14:24:47 <Cale> > drop 1 . inits $ [1..9]
14:24:49 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
14:25:15 <FunctorSalad> @src inits
14:25:15 <lambdabot> inits []     =  [[]]
14:25:16 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
14:26:30 <Toxaris> @pl \x xs -> [[]] ++ map (x :) xs
14:26:31 <lambdabot> (([] :) .) . map . (:)
14:27:20 <Toxaris> > foldr ((([] :) .) . (<$>) . (:)) [[]] [1..5]
14:27:22 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
14:27:34 <Toxaris> We really need a symbolic name for foldr :)
14:27:47 <r3m0t> :t <$>
14:27:49 <lambdabot> parse error on input `<$>'
14:27:54 <r3m0t> :t (<$>)
14:27:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:28:04 <Toxaris> <$> is fmap, is map for []
14:28:07 <Myoma> I wish I could think of something more interesting that scheme compiler
14:28:23 <b\6> if i get rich i was thinking about getting my dog a really iced out <$> necklace.
14:28:32 <dons> heh
14:28:33 <pjdelport> Toxaris: lens brackets?
14:28:46 <Toxaris> pjdelport: :)
14:29:25 <pjdelport> dog <$> fridge
14:29:45 <dons> do we have a #haskell twitter feed?
14:29:52 <Myoma> what's that dons?
14:29:52 <dons> it would be fun for @remember to sync onto twitter
14:29:57 <Myoma> oh
14:30:00 <Toxaris> @pl \x xs -> [] : map (x :) xs -- why does the @src of inits use ++?
14:30:00 <lambdabot> (([] :) .) . map . (:)
14:30:28 <FunctorSalad> yeah is twitter actually good? just thought "yet another web 2.0 thingy" at first glance
14:30:41 <dons> well, it's hard to say what it is good for, I admit.
14:30:41 <mauke> http://twitter.com/GumbyBRAIN
14:30:43 <lambdabot> Title: Twitter / GumbyBRAIN
14:30:52 <b\6> but.. but.. THE WEB
14:30:56 <b\6> ???
14:30:59 <lament> i assume twitter is useful when all your friends do it
14:31:12 <lament> and completely worthless otherwise (my situation)
14:36:47 <_zenon_> http://www.penny-arcade.com/images/2008/20080423.jpg
14:36:52 <_zenon_> On the whole twitter thing :)
14:40:01 <abbe> hi all
14:40:38 <_zenon_> :src foldl
14:40:43 <_zenon_> @src foldl
14:40:43 <lambdabot> foldl f z []     = z
14:40:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:40:48 <chrisdone_> @tell chrisdone note to self: bugger sqlite3 and its crap. use mysql or write own database with logic language interface. k
14:40:49 <lambdabot> Consider it noted.
14:41:22 <hackage> Uploaded to hackage: regex-compat 0.92
14:41:22 <hackage> Uploaded to hackage: regex-posix 0.93.2
14:41:22 <hackage> Uploaded to hackage: binary 0.4.3
14:41:22 <hackage> Uploaded to hackage: bytestring 0.9.1.1
14:41:34 <b\6> misspelled postgres.
14:42:01 <dons> funky time
14:43:18 <mauke> haha, oops
14:43:23 <mauke> cabal: cannot configure bytestring-0.9.1.1. It requires ghc-prim -any
14:43:41 <dons> oh, you're on an early 6.9?
14:43:46 <mauke> no, 6.8.3
14:43:56 <dons> oh damn, did i sneak that in?
14:43:57 <dons> grr.
14:44:09 <dons> yes. damn
14:44:22 * EvilTerran tends to prefer sqlite over mysql
14:44:23 <thomas_> > putStrLn "lo"
14:44:25 <lambdabot>  mueval: *** Exception: "<IO ()>"
14:44:29 <mauke> wait, I thought my ghc installation was slightly broken
14:44:32 <EvilTerran> or postgres over mysql, when that's more appropriate
14:44:34 <dons> mauke: nah
14:44:41 <dons> if (ghc > 6.8.2) ghc-prim
14:44:44 <dons> wrong.
14:44:55 <dons> mauke: can you quizly try
14:44:56 <dons>   if impl(ghc >= 6.9)
14:44:57 <dons>        build-depends: ghc-prim
14:44:59 <dons> for me?
14:45:10 <mauke> oh, building manually?
14:45:14 <dons> yeah plz.
14:45:28 <mauke> ok
14:46:44 <mauke> success
14:46:47 <dons> k.
14:47:19 <dmhouse> Oh, joy. I have to install some Perl module to send emails from git, and the installation fails its tests.
14:48:02 <dons> try updating and cabal install now, mauke
14:48:13 <dons> i need to start checking perf. details with head too
14:48:21 <dons> there were rumours of problems 6 months ago.
14:48:23 <mauke> 'http://hackage.haskell.org/packages/archive'
14:48:23 <mauke> cabal: user error (Codec.Compression.Zlib: invalid block type)
14:48:33 <dons> not my fault.
14:48:39 <dons> keep trying
14:51:11 <mauke> dons: success
14:51:15 <thomas_> > show "test"
14:51:17 <lambdabot>  "\"test\""
14:51:25 <EvilTerran> > fix show
14:51:27 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:52:09 <thomas_> > show [1..999999999]
14:52:11 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:52:18 <dons> laziness ftw.
14:52:40 <EvilTerran> yes.
14:55:23 <Philonous> > let my = show in fix my computer
14:55:25 <lambdabot> Terminated
14:57:51 <ddarius> > replicate 1000 'a' ++ undefined
14:57:53 <lambdabot>  mueval: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
14:58:37 <EvilTerran> > fix error
14:58:52 <lambdabot>  thread killed
14:58:56 <EvilTerran> huh
14:59:24 <b\6> we should settle international conflicts with stand up comedy routines focused on haskell and functional programming.
15:00:18 <EvilTerran> ghci> let e = error e in e
15:00:19 <EvilTerran> "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: ***
15:00:24 <EvilTerran> now to work out how that works...
15:00:35 <Myoma> > let e = error e in e
15:00:45 <EvilTerran> Myoma, it's the same as "fix e" above
15:00:46 <Saizan> > error "foo"
15:00:49 <lambdabot>  mueval: *** Exception: foo
15:00:50 <lambdabot>  thread killed
15:01:22 <ddarius> The problem is
15:01:28 <ddarius> > error . error $ "foo"
15:01:31 <lambdabot>  mueval: Time limit exceeded
15:01:34 <ddarius> > error . error $ "foo"
15:01:37 <lambdabot>  mueval: Time limit exceeded
15:01:43 <ddarius> Or not...
15:01:44 <Myoma> bot is sucking
15:01:46 <EvilTerran> ... that "error" has to be called in the process of printing the error message/
15:02:03 <ddarius> > error (error "foo")
15:02:06 <lambdabot>  mueval: Time limit exceeded
15:02:08 <EvilTerran> it's not actually getting past the first character of the string, right?
15:02:10 <EvilTerran> ?undef
15:02:11 <lambdabot> Undefined.
15:02:14 <ddarius> > error (error "foo")
15:02:17 <lambdabot>  mueval: Time limit exceeded
15:02:20 <EvilTerran> weird
15:02:28 <Saizan> uhm
15:03:08 <ddarius> > error (error (error "foo"))
15:03:11 <lambdabot>  mueval: *** Exception: foo
15:03:32 <TuringTest> dons: Hello.  I sent a Data.Binary patch just a little while ago.  Did it arrive?
15:04:00 <TuringTest> Ah I see you email, nevermind.
15:04:05 <TuringTest> se/you/your/
15:04:07 <b\6> please no two spaces after period. it's deprecated in this enlightened textarea age.
15:05:00 <b\6> kind of wish lambdabot would actually execute the sed stuff when people do s/blah/yo/.
15:05:01 <ddarius> b\6: If this "enligtened age" includes not being able to capitalize properly, I will keep by two spaces.
15:05:29 <b\6> yeah, because not doing it indicates inability.
15:05:37 <b\6> rather than say, thinking it's not useful.
15:06:27 <ddarius> b\6: Exactly.
15:06:30 <lament> since when ddarius uses two spaces
15:06:43 <b\6> dunno. i was giving the other guy a hard time.
15:06:50 <lament> or even writes in complete sentences
15:08:43 <dons> oh, fun, jdh trolling comp.lang.lisp about haskell, with xah lee pitching in to agree
15:09:07 <Myoma> xah has a good point about lisp
15:09:15 <monochrom> hahaha
15:09:29 <dons> xahlee and jdh discussing haskell on a lisp newsgroup. bound to be fun.
15:09:44 <ddarius> dons: Why do you know about the happenings of c.l.l?
15:09:49 <lament> fundamental problems of lisp?
15:10:04 <monochrom> dons is the lord of two ravens :)
15:10:12 <Myoma> dons what is the thread
15:10:19 * monochrom watched Wagner's Ring too much :)
15:10:25 <eu-prleu-peupeu> ah
15:10:31 <eu-prleu-peupeu> so haskell do like to troll :)
15:10:45 <eu-prleu-peupeu> s/haskell/haskell people :)
15:10:50 <dons> this is how baby trolls are born.
15:10:59 <eu-prleu-peupeu> i see heheh
15:11:06 <monochrom> Eh, jdh and xahlee are not haskell people.
15:11:25 <dons> "Haskell's success rate at generating widely-used open source code is far
15:11:26 <dons> lower than most other languages"
15:11:29 * Myoma doesn't see anything at all about haskell in cll
15:11:40 <dons> harrop keeps up the trolling.
15:11:55 <mmorrow> Myoma: what is cll?
15:12:01 <Myoma> comp.lang.lisp
15:12:04 <mmorrow> ah
15:12:19 <Myoma> dons mentioned it but I can't find the thread
15:14:20 <Myoma> oh
15:14:21 <Myoma> What do you LISPers think of Haskell?
15:14:44 <mmorrow> heh, just found that same thing
15:16:29 <b\6> don't get why the guy cares so much.
15:17:00 <mmorrow> who?
15:17:12 <b\6> the dude who keeps badmouthing haskell.
15:17:16 <mmorrow> oh
15:17:17 <mmorrow> $$$
15:18:14 <Myoma> hehe
15:18:19 <Myoma> eval model like lazy or not lazy, closure or no, tail recursion or no, has curry or no curry, does it have linder mayer system or kzmolif type sytem, polymorphism yes?
15:19:41 <mwc> dons: where's he trolling today?
15:19:54 <Myoma> he is not trolling
15:21:10 <Myoma> this is a strange comment
15:21:13 <Myoma> "Our conclusion is, of course, that we are not going to consider diversifying into the Haskell market, at least not until it matures. Right now, Scala is looking much more viable."
15:21:19 <Myoma> Isn't Scala based on Haskell?
15:21:45 <lament> almost
15:21:47 <lament> s/Haskell/Java
15:21:58 <dons> summary: he can't make money selling knowledge about haskell
15:22:06 <dons> since we're an open, effective community already
15:22:28 <lament> he can't make money selling knowledge about Haskell because dons and bos are already on that
15:22:32 <dons> his business model relies on him having pay-per-read blogs with content no one else has. such a think would be doomed to fail in haskell.
15:22:47 <Myoma> dons: he sells a book
15:23:06 <lament> (damn amazon, i need to buy some other book along with RWH to qualify for free shipping!)
15:23:16 <mwc> Yeah, it was surprisingly cheap
15:23:25 <mwc> I'm going to place a preorder at the end of the week end I'm paid as well
15:23:26 <TuringTest> Well... Scala runs on top of the JVM and so has more potential to wedge itself into the big Java shops out there.
15:23:43 <lament> i put it on the cart, now thinking of what other book should i buy
15:23:48 <lament> any ideas? :)
15:23:56 <mwc> lament: Pierce's type books?
15:24:01 <mwc> if you're into hard core stuff?
15:24:12 <lament> i'm not
15:24:12 <mwc> Just get a good fiction paperback
15:24:21 <r3m0t> puzzle collections? they're chea
15:24:30 <mmorrow> lament: flatland (it's $1.99 US)
15:24:37 <lament> not enough
15:24:39 <lament> and i've read it
15:24:40 <mmorrow> lambdabot: (and amusing)
15:24:40 <monochrom> I still recommend Richard Bird's "Introduction to Functional Programming using Haskell, second edition".
15:24:41 <dons> doesn't RWH come recommended with Stephenson?
15:24:42 <mmorrow> heh
15:24:47 <lament> dons: really? haha
15:24:51 <dons> i wonder how many people decided that was an appropiate bundle.
15:24:56 <lament> it makes sense
15:25:03 <lament> RWH and Snow Crash
15:25:04 <r3m0t> even though the same puzzles are online printable, these can be used on a train
15:25:05 <monochrom> Or pretty much anything on http://www.vex.net/~trebla/weblog/fpbooks.xhtml  :)
15:25:05 <mwc> I like to think that the lack of a Jon Harrop in haskell-land is a sign of a healthy community
15:25:05 * TuringTest plugs Charles Stross' books
15:25:27 <dons> mwc, i think it's about "market effectiveness" -- everyone has access to knowledge here.
15:25:41 <dons> so you can't have snake oil salesmen selling secrets.
15:25:42 <mwc> Alastair Reynolds is good too, check out Revelation Space
15:26:12 <TuringTest> dons: Do you think the "market effectiveness" has been affected by having multiple Haskell 98 compilers?
15:26:15 <lament> monochrom: those are really old aren't they
15:26:29 <monochrom> Yes but they're also eternal. :)
15:26:39 <mwc> I think the cooperation between the compiler teams is a good thing
15:26:48 <lament> from what I've heard, The Haskell School Of Expression wasn't very eternal
15:26:54 <monochrom> OK :)
15:27:05 <mmorrow> lament: purely functional datastructures (in the unlikely event you don't already own it :))
15:27:12 <sereven> lament: How to Solve It: Modern Heuristics, although probably pricey. Of course you're getting great value for both books.
15:27:18 <TuringTest> mwc: And that probably means there is no closed group that can sell its expertise at a premium price.
15:27:21 <Trinithis> the osaki person's book?
15:27:22 <lament> ohhhhhhhhh
15:27:23 <lament> i know
15:27:28 <mmorrow> Trinithis: yes
15:27:29 <lament> i'll get tufte!
15:27:34 <ski> Okasaki
15:27:34 <mmorrow> Trinithis: okasaki
15:27:43 <Trinithis> ;d
15:27:49 <Trinithis> I knew I got it wrong
15:27:53 <lament> how in-depth is okasaki?
15:27:53 <mmorrow> heh
15:28:00 <mmorrow> lament: excellently
15:28:10 <dons> TuringTest: yeah, we don't end up with custom magic lisp compilers for sale.
15:28:13 <mmorrow> lament: he "wrote the book"!!
15:28:21 <monochrom> Very in-depth. It's an improvement over a PhD thesis.
15:28:24 <dons> trying to out do each other with incompatible features.
15:28:29 <TuringTest> dons: you could write one in haskell...
15:28:33 <thomas_> hmm how do you clear a file of its contents?
15:28:33 <dons> you could.
15:28:49 <thomas_> nevermind was using printf instead of writeFIle
15:28:51 <mauke> writeFile x ""
15:28:55 <dons> maybe haskell's sufficiently hard to optimise, unlike lisp, that the startup cost is to high :)
15:28:57 <lament> but the data structures covered are the pretty basic ones?
15:29:14 <mmorrow> lament: it's the concepts that are important
15:29:14 <dons> in okasaki?
15:29:15 <Trinithis> With creative desing
15:29:18 <TuringTest> How is JHC development going?
15:29:19 <lament> yes
15:29:20 <dons> i wouldn't say they're basic.
15:29:25 <dons> some of them are unique.
15:29:29 <lament> dons: is it worth reading
15:29:31 <mmorrow> lament: and not all that basic either
15:29:32 <dons> definitely.
15:29:40 <pgavin> dons: haskell's only hard to optimize because we're stuck with the turing-machine model used on today's CPUs
15:29:44 <dons> it's one of the corner stone books. if only he'd done it in haskell.
15:29:46 <lament> is it written like a math book or like a programming book?
15:29:47 <mauke> lament: search trees, heaps, queues, deques, etc
15:30:01 <lament> oh, it's not even in haskell :(
15:30:02 <mmorrow> lament: he is the standard reference for functional datastructures
15:30:19 <Myoma> if he did it in haskell .. it would be the same book with slightly different syntax ?
15:30:19 <mauke> lament: it's in SML with a Haskell appendix
15:30:20 <Trinithis> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:30:22 <lambdabot> Title: Purely Functional Data Structures
15:30:40 <Myoma> actually most of the code is struct
15:30:44 <Myoma> strict*
15:30:57 <mmorrow> lament: i don't know sml at all, but i could read it fine
15:31:02 <pgavin> if our CPUs did graph reduction directly, Haskell would probably be faster than C
15:31:46 <dons> pgavin: what would that mean?
15:31:55 <dons> faster jumps to random memory ?
15:32:03 <dons> heap pointers in hardware.
15:32:05 <dons> hardware GC?
15:32:05 <pgavin> so, don't say Haskell is "slow" or "hard to optimize", say "we just don't have the right hardware (yet)"
15:32:20 <pgavin> well, hardware GC would be one component
15:32:20 <Myoma> do we actually not have the right hardware?
15:32:29 <dons> there's some small changes
15:32:35 <Myoma> it looks like you can write haskell programs fast as C right now
15:32:35 <dons> i.e. the C stack pointer is useless.
15:32:37 * mmorrow 's guess is some tweaked out reduceron type thingamajig
15:32:41 <dons> and more registers would help.
15:32:46 <dons> get rid of caches
15:32:50 <dons> and have hashed memory
15:32:52 <pgavin> no registers
15:32:55 <mmorrow> fpga reducing things in parallel
15:32:56 <dons> so there's no indirection penalty
15:32:57 <pgavin> registers are state
15:33:03 <dons> more threads, hide latency
15:33:16 <dons> pgavin: you gotta put your function arguments and return somewhere
15:33:19 <pgavin> such a CPU would execute Core pretty much directly
15:33:35 <mmorrow> pgavin: have you seen the reduceron(2) ?
15:33:41 <pgavin> dons: well, such a stack wouldnt be addressable from user code
15:33:44 <pgavin> mmorrow: yep :)
15:33:52 <mmorrow> hehe
15:33:53 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/reduceron2/
15:34:00 <lambdabot> Title: The Reduceron
15:34:02 <BMeph> MOAR R3g1573rZ, kthxbye
15:34:10 <mmorrow> HAI
15:34:22 <BMeph> :)
15:34:24 <mmorrow> CAN HAS STDIO?
15:34:29 <mmorrow> KTHXBYE
15:34:32 <pgavin> mmorrow: eventually I'm going to investigate it a bit closer, once I find time
15:34:35 <Myoma> how fast is that reduceron2 stuff?
15:34:36 <lament> or i could get Tales of Beedle The Bard
15:34:40 <mmorrow> pgavin: me too
15:34:41 <b\6> i was so sad when starscream killed reduceron
15:34:53 <pgavin> Myoma: well, it runs on an FPGA
15:34:59 <BMeph> i can has lambdas? kthx, moar lambdas, pls
15:35:03 <Myoma> I don't know what that means in terms of speed
15:35:03 <pgavin> Myoma: so not that fast
15:35:04 <lament> dons: the recommendations, while looking at RWH, are Programming Erlang, Beautiful Code, SICP and three different Schemers.
15:35:05 <mmorrow> b\6: ??? what is starscream?
15:35:14 <Myoma> what's the point in it then?
15:35:16 <pgavin> Myoma: like, 200MHz
15:35:18 <b\6> the leader of the decepticons.
15:35:22 <mmorrow> haha
15:35:32 <lament> SICP is a ridiculous 50$ - too much for a questionable status symbol
15:35:39 <pgavin> Myoma: if it was implemented in real silicon, it would be much, much faster
15:35:51 <Trinithis> or gold even!
15:35:56 <dons> lament: why is that ridiculous? not big enough, too out of date?
15:36:09 <lament> dons: too available online for free!
15:36:22 <dons> what about RWH then? :)
15:36:27 <lament> RWH is cheaper :D
15:36:38 <Trinithis> Do rich rappers have cpu's made of pure gold?
15:36:51 <BMeph> Trinithis: Platinum! ;)
15:37:00 <b\6> number crunking
15:37:00 <mmorrow> Myoma: people use FPGAs to e.g. break encryption, factor huge integers (which sometimes coincides with breaking encryption), ...
15:37:06 <lament> apparently To Mock A Mockingbird is also there
15:37:08 <Trinithis> BMeph: won't match their grills tho
15:37:21 <pgavin> you can program FPGAs with arbitrary
15:37:25 <BMeph> Trinithis: It will if they has platinum... ;)
15:37:27 <Myoma> mmorrow: So why is running haskell on it slow?
15:37:28 <pgavin> ... circuits
15:37:34 <pgavin> well, almost arbitrary
15:37:40 <BMeph> Heh-heh, s/has/have/
15:37:44 <mmorrow> Myoma: the clock speed may be 200MHz, but since it's doing 1000 things every clock tick, ...
15:37:52 * lament buys Tufte
15:38:01 <pgavin> mmorrow: not exactly 1000
15:38:03 <Myoma> ok so it's actually not slow
15:38:13 <lament> one of the few books i actually feel bad about not having read yet
15:38:15 <pgavin> the design isn't slow, the process is
15:38:21 <mmorrow> pgavin: hehe, hyperbole is great
15:38:31 <Trinithis> How "fast" is (ghc) haskell compared to say c++ or java?
15:38:34 <Myoma> I'm not going to bother trying to understand this
15:38:53 <Myoma> I don't know anything about hardware
15:38:56 <EvilTerran> Trinithis, that depends on how far from idiomatic haskell you're willing to stray
15:39:01 <pgavin> mmorrow: but haskell code would probably exhibit really high IPC on such a machine
15:39:02 <Trinithis> mm
15:39:12 <EvilTerran> but i believe, say, string manipulation as [Char] will always be a lot slower
15:39:43 <pgavin> so would C code, if C code treated strings as linked lists
15:39:45 <EvilTerran> but using ByteString and using a carefully-written algorithm with a good knowledge of strictness can be comparable while remaining fairly idiomatic
15:40:03 <EvilTerran> comparable to C, that is
15:40:05 <dons> s/comparable/identical :)
15:40:06 <pgavin> the advantage really isn't the speed
15:40:09 <Trinithis> So more than respectable
15:40:09 <EvilTerran> .'. blowing java away
15:40:11 <dons> s/identical/outperform/
15:40:29 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
15:40:29 <mmorrow> Myoma: so imagine you've got the code (in some hardware description lang) for a cpu, and imagine you have an fpga with enough capacity to hold four of the cpus. you can then run all four of those "cpus" in parallel in the fpga.
15:40:35 <lambdabot> Title: sum-file benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks G ..., http://tinyurl.com/o8pll
15:40:49 <b\6> the operator .|. makes me want to blast off in my spaceship and code haskell on the moon.
15:40:52 <EvilTerran> Trinithis, considering how high-level haskell is, it goes straight past respectable and into awe-inspiring, IMO :)
15:41:20 <Myoma> @remember <b\6> the operator .|. makes me want to blast off in my spaceship and code haskell on the moon.
15:41:21 <lambdabot> It is stored.
15:41:21 <Trinithis> Who here actually has a job as a haskell programmer?
15:41:22 <hackage> Uploaded to hackage: bytestring 0.9.1.2
15:41:27 <dons> Trinithis: yo.
15:41:41 <atomb> Trinithis: yo'
15:41:49 <Trinithis> Hopefully one day for me once I get out of school
15:42:05 <EvilTerran> Trinithis, quite a few - more if you count getting research grants as employment
15:42:06 <EvilTerran> :P
15:43:03 <Trinithis> All I can hope in the meantime is for my professors to allow me to turn in code written in haskell. That'd be nifty
15:43:47 <mmorrow> pgavin: i just read somewhere that Lava is now on hackage
15:44:13 <Trinithis> Is lava that curcuits thing?
15:44:22 <mmorrow> pgavin: (but the variant/whatever for FPGAs is available elsewhere)
15:44:29 <mmorrow> Trinithis: yes
15:44:54 <atomb> Trinithis: what school are you attending?
15:45:12 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chalmers-lava2000
15:45:13 <Trinithis> uc berkeley... transferring in as a junior
15:45:14 <lambdabot> Title: HackageDB: chalmers-lava2000-1.0.1, http://tinyurl.com/65movm
15:45:41 <mmorrow> http://www.cs.chalmers.se/~koen/Lava/
15:45:43 <lambdabot> Title: The Lava Homepage
15:45:51 <atomb> Trinithis: they'll all want you to use ocaml ;)
15:46:02 <Trinithis> probably scheme
15:46:17 <atomb> well, yeah, in the intro classes, that's true
15:46:18 <Trinithis> or some imperative langauage
15:46:25 <mmorrow> "Currently, there are two versions of Lava in use. .......  Chalmers-Lava .......   Xilinx-Lava     ......  We hope to merge these two version soon."
15:46:40 <atomb> but some of the PL researchers there use O'Caml a lot
15:46:42 * BMeph is amazed that Tcl is in the shootout at all. But not amazed that it's faster than Ruby.
15:47:01 <atomb> tcl has one speed advantage: a good regex engine
15:47:02 <Trinithis> is ocaml close to haskell and is it lazy?
15:47:11 <dmhouse> No, no.
15:47:21 <dmhouse> Oh, close in the shootout. I don't know.
15:47:28 <atomb> ocaml is functional (but not purely --- it has destructive update)
15:47:33 <MyCatVerbs> atomb: TCL has a second one: it caches the values of variables when they're interpreted as things other than strings.
15:47:35 <atomb> it's strongly typed
15:47:46 <atomb> it's not lazy
15:47:51 <Trinithis> :(((
15:47:57 <Myoma> ocaml is great
15:48:16 <atomb> if haskell didn't exist, i'd use ocaml instead
15:48:21 <atomb> it was my first love
15:48:22 <EvilTerran> the *ml languages have _hideous_ syntax
15:48:25 <atomb> but i've moved on
15:48:28 <EvilTerran> and unconstrained side-effects
15:48:31 <atomb> i agree
15:48:35 <EvilTerran> ml--
15:48:38 <atomb> haskell is so much prettier
15:48:40 <Trinithis> let's wikipedia ocaml...
15:48:40 <EvilTerran> :P
15:48:54 <Myoma> atomb: I wonder what doesn't exist that you'd use instead of haskell if it did
15:49:17 <atomb> Myoma: good question!
15:49:21 <mmorrow> here's the Xilinx-Lava (for FPGAs) (official?) homepage: http://research.microsoft.com/~satnams/lava/
15:49:27 <atomb> how about you invent it and we'll find out?
15:49:27 <lambdabot> Title: The Lava Hardware Description Language
15:50:48 <thomas_> nice, you could use that isntead of VHDL?
15:51:28 <mmorrow> thomas_: that's my understanding, although i haven't used Lava personally
15:52:19 <mmorrow> thomas_: http://research.microsoft.com/~satnams/lava/tutorials/
15:52:19 <lambdabot> Title: Lava Tutorials
15:52:39 <mmorrow> (that's the Lava targetted at creating netlists for FPGAs)
15:53:10 <Trinithis> anyone know how to setup ff so that when you click in the address bar, the text in it is selected?
15:54:34 <thomas_> nice, Seems like a great alternative to vhdl haskell being much more powerful : )
15:55:12 <mmorrow> thomas_: totally. i'm reading that page and it looks like it generates VHDL (among other things)
15:56:49 <shapr> @quote
15:56:49 <lambdabot> erg0t says: <erg0t> k el loko k hizo el fasm | <erg0t> se re paso |  <tizoc> erg0t: y si le chupas la pija? | <erg0t> ni ke fuese J Masci
15:56:50 <shapr> @users
15:56:51 <lambdabot> Maximum users seen in #haskell: 473, currently: 446 (94.3%), active: 22 (4.9%)
15:57:06 * MyCatVerbs blinks at the quote.
15:57:08 <mauke> preflex: quote
15:57:08 <preflex>  <gumbybrain> Beer is the way to a gumbybrain.
15:57:37 <dons> fun haskell fact: shapr has the first recorded use of the phase "real world haskell"
15:57:37 <MyCatVerbs> That looks like someone consuming ergot derivative chemicals and then trying to converse on IRC.
15:57:40 <dons> first to the plate, as usual :)
15:57:49 * shapr cheers!
15:57:51 <shapr> dons: w00!
15:57:57 <dons> visionary!
15:58:02 <b\6> can't parsec parse any instance of its Stream? having problems with parse expecting String when i pass something i made an instance of Stream.
15:58:24 <shapr> dons: Can you put an easter egg in the book somewhere that says "<shapr> yay real world haskell!" ?
15:58:28 <dons> hehe
15:58:31 <dons> mmm...
15:58:33 * shapr grins
15:58:51 <mmorrow> thomas_: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7081
15:58:52 <lambdabot> Title: Designing FPGA Circuits in Lava - CiteSeerX
15:59:34 <mwc> F# looked palatable syntax wise
15:59:45 <mwc> Whitespace awareness would do so much for the ML families
16:00:01 <mwc> as it stands, they seem to accumulate huge amounts of nested ()
16:00:33 <Philonous> In functional introduction texts it is sometimes mentioned that in pure functional languages the return value of function calles could be cached. Does Haskell actually do that? (or rather: Does ghc implement it? )
16:01:13 <Trinithis> like graph reduction?
16:01:36 <mauke> Philonous: if you mean automatic memoization, no
16:03:11 <Philonous> So it is more a "could be done but isn't" thing than an actuall benefit?
16:03:38 <mauke> it's not necessarily a benefit
16:03:54 <mauke> caching everything would eat memory like crazy
16:04:00 <mmorrow> Philonous: what happens is say you say   let a = [0..9] ....   print a      ....   <some stuff involving a> .  so by printing a the thunk which a references is evaluated, and the result of this evaluating overwrites the thunk, then subsequent evaluations of a don't have to evaluate the thunk again, but simply grab the already computed value
16:04:28 <mauke> mmorrow: that's about lazy evaluation, not purity
16:04:34 <Trinithis> you can make a higher-order function to memorize for you
16:05:03 <mmorrow> mauke: hmm? i think that's what's taken to be "haskell automatically memoizing things"
16:05:32 <mmorrow> or ".. cacheing things"
16:05:48 <mmorrow> *caching ;)
16:06:03 <mauke> http://en.wikipedia.org/wiki/Memoization
16:06:09 <lambdabot> Title: Memoization - Wikipedia, the free encyclopedia
16:06:36 <Philonous> mauke: Well ok. The hard part would be to deduce what function called should be cached and what not.
16:06:58 <mauke> and how to build a lookup table that's faster than actually calling the function
16:07:07 <Trinithis> i agree with mauke. the thunk thing is not memorization
16:07:58 <Myoma> "the thunk thing"?
16:08:03 <mmorrow> mauke: oh, ok i see what you're saying.
16:08:08 <Myoma> the whole reason the memo trick is possible is due to thunks
16:08:27 <mmorrow> yeah, i was wrong in calling that memoization.
16:08:37 <Philonous> So is there some way to explicitly use memoization except maybe using laszy lists?
16:08:43 <Philonous> lazy*
16:09:17 <Trinithis> by trees... etc
16:09:18 <b\6> parse p "" blah  -- blah is an instance of Stream. thought that was going to be ok, but it's expecting String.
16:09:47 <Trinithis> :t parse
16:09:49 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> SourceName -> s -> Either ParseError a
16:09:53 <qwr> Myoma: thunk is like a little lambda that contains the expression, evaluates it when called and then memoizez the value. optimised by compiler/runtime to hell ;)
16:11:49 <qwr> hmm, probably Myoma didn't need that explanation.
16:12:05 <mmorrow> yes, right there. that's my guess as to the reason people think haskell memoizes/whatever automatically. misunderstanding of what it means to overwrite a thunk with it's value and thus all later references to that value point directly to the value instead of having to re-evaluate the thunk (which no longer exists)
16:12:10 <MarcWeber> http://rafb.net/p/tXhutb63.html
16:12:12 <lambdabot> Title: Nopaste - Functional dependencies conflict between instance
16:12:23 <MarcWeber> Is there a way to exclude the overlapping case?
16:12:40 <lilac> but... using the thunks mechanism it's possible to implement meomization
16:12:46 <Trinithis> I used to confuse memorization with some graph reduction optimizations
16:12:47 <Myoma> mmorrow: I think that the same thing, thunks getting overwritten with values can cause a LOT of confusion
16:12:51 <lilac> (for some input types)
16:13:06 <Myoma> mmorrow: people think it is tail call optimization
16:13:19 <roconnor> ?
16:13:21 <mmorrow> hmm
16:13:36 * roconnor reads back
16:14:29 <skippycostin_> can you write haskell programs for wm5/wm6?
16:14:41 <qwr> confusion is when people think that haskell memoizes applications etc. ;)
16:14:48 <mmorrow> exactly
16:15:25 <Trinithis> apps like photoshop
16:15:51 <olsner> @faq can haskell memoize photoshop?
16:15:51 <lambdabot> The answer is: Yes! Haskell can do that.
16:15:58 <olsner> hey, even the faq says so
16:16:20 <skippycostin> lambdabot: was that for me?
16:16:22 <Trinithis> 'cause haskell iz 1337
16:16:34 <olsner> aye, 'tis indeed
16:16:35 <dibblego> speaking of TCO, this guy has written another blog post about Haskell not having TCO. Here is the old one: http://muaddibspace.blogspot.com/2008/08/tail-call-optimization-doesnt-exist-in.html and here is the new one: http://muaddibspace.blogspot.com/2008/08/tail-calls-dont-exist-so-why-look-for.html
16:16:37 <lambdabot> Title: Muad`Dib: Tail Call Optimization doesn't exist in Haskell, http://tinyurl.com/5e4z23
16:16:47 <MyCatVerbs> Trinithis: ...please don't ever say that again.
16:17:03 <Trinithis> haha ok
16:18:53 <EvilTerran> @. elite faq iz haskell m4d l33t?
16:18:53 <lambdabot> +He 4nSwEr IS: y3z! h45K3l1 (aN dO +|-|47.
16:19:00 <dibblego> @seen wren
16:19:00 <lambdabot> I haven't seen wren.
16:19:01 <Trinithis> haha
16:19:06 <EvilTerran> preflex: seen wren
16:19:06 <preflex>  Sorry, I haven't seen wren
16:19:10 <dibblego> is the commenter on that blog (wren) in here?
16:19:33 <Trinithis> lambdabot can speak 1337?
16:20:03 <EvilTerran> Trinithis, that would've made more sense in the context of the @faq answer, i guess
16:20:20 <EvilTerran> @faq can haskell bots speak 1337?
16:20:20 <lambdabot> The answer is: Yes! Haskell can do that.
16:20:55 <Trinithis> Well that makes my day. Anyway, I'm leaving for a bit. Chow
16:21:09 <MyCatVerbs> EvilTerran: the real question is *should* they speak leet?
16:21:58 <eu-prleu-peupeu> i need to learn how to do monads :(
16:22:07 <Myoma> which monads ?/
16:22:10 <eu-prleu-peupeu> i have read the yaht part, but its too confusing :(
16:22:18 <dibblego> monads do you!
16:22:18 <dons> eu-prleu-peupeu: what's causing problems?
16:22:32 <Myoma> eu-prleu-peupeu: [] monad is fun -- you could write some programs with it first
16:22:34 <Trinithis> sphttp://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
16:22:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
16:22:48 <eu-prleu-peupeu> the concept
16:22:52 <MyCatVerbs> That's one of the better ones.
16:22:56 <Trinithis> [] monad was confusing for me when I started. I thought state was easier
16:23:09 <dibblego> Trinithis, that's bizarre :)
16:23:17 <eu-prleu-peupeu> it scratches my mind, how do i build my own monads by doing that strange bind operators and hoping it to work :/
16:23:33 <dons> that would be one way.
16:23:36 <Myoma> you build monads out of monad transformers
16:23:44 <dibblego> eu-prleu-peupeu, data Value a = V a; instance Monad V where ... for you to do :)
16:23:46 <Myoma> creating completely new monads that didn't exist before is like sorcery
16:23:52 <dibblego> er instance Monad Value
16:24:07 <lament> it's just like sorcery: you create a new instance and define a couple functions
16:24:09 <eu-prleu-peupeu> i am seeing the "Brian Beckman" video on haskell.org, but he messes it up a bit for me to follow :/
16:24:25 <dons> http://techguyinmidtown.com/2008/08/25/project-euler-up-through-problem-78-in-haskell/
16:24:31 <lambdabot> Title: Project Euler up through Problem 78 in Haskell « tech guy in midtown, http://tinyurl.com/57mqoq
16:24:34 <dibblego> eu-prleu-peupeu, what language are you most familiar with?
16:24:39 <eu-prleu-peupeu> c
16:24:39 <dons> Cale, we need a badge: "I solved Project Euler with Haskell"
16:24:45 <Trinithis> Don't worry about creating your own monads until you really "get" them. Until then, using library monads should help you learn them
16:24:48 <dons> to hand out to people. viral style.
16:25:01 <lament> dons: and another one to go below: "in the type system"
16:25:06 <dons> hehe :)
16:25:13 <dons> front of the tshirt, and the back.
16:25:21 <eu-prleu-peupeu> i guess i need to sleep, maybe tomorrow ill be fresh and understand it in a zap
16:25:28 <dibblego> I am thinking of writing another Haskell exercises using Functors, Monads and Applicatives, because I have had a recent success with doing so
16:25:31 <Trinithis> just don't give up
16:25:34 <dons> you can add "... in the type system" to any sentence in here, to make it funny, btw. That's the Oleg Invariant
16:25:39 <eu-prleu-peupeu> i wont hehe
16:26:02 <dons> e.g. "dibblego> I am thinking of writing another Haskell exercises using Functors, Monads and Applicatives ... in the type system"
16:26:09 <eu-prleu-peupeu> when i have this set of random functions ill cabalize it, and put it on hackage :P
16:26:13 <dons> forfty percent more humerous.
16:26:24 <mauke> dons: don't make me talk about type-level MVars again!
16:26:27 <dons> "eu-prleu-peupeu> when i have this set of random functions ill cabalize it ... in the type system"
16:26:40 <dons> we need a "@olegify" plugin!
16:26:48 <dibblego> humourous/humorous ;)
16:26:57 <dons> which takes the last declaration, and appends the magic sauce.
16:27:09 <dons> humorous ... in the type system!
16:27:09 <Draconx> in the type system.
16:27:33 --- mode: ChanServ set +o dons
16:27:38 --- topic: set to '["Haskell: precision engineering for programmers ... in the type system!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
16:27:43 --- mode: ChanServ set -o dons
16:28:14 <dons> that'd make a fun little web 2.0 app, actually.
16:28:19 <dons> olegify.com
16:28:36 <dons> it adds 100 milliolegs to any result.
16:29:07 <ac> hmmm. How do I turn a DiffTime in to a NominalDiffTime (and what's the difference anyway?)
16:29:33 <lilac> you do that pretty much in the type system
16:29:53 <Philonous> okasakis "Pure functional data structures" says : "Lazy evaluation is an evaluation strategy [...]. This strategy has two essential properties. [...] Second, the first
16:29:54 <Philonous> time a suspended expression is evaluated, the result is memoized (i.e., cached) so that the next
16:29:54 <Philonous> time it is needed, it can be looked up rather than recomputed."
16:30:22 <Philonous> IvVe read this kind of remark several times before, and it really leaves the impression that everything in haskell is memoized
16:30:43 <lilac> the trouble is knowing when two things are the same suspended expression
16:30:56 <bjrn> Isn't memoization in the definition of call-by-need?
16:31:14 <bjrn> Reading TAPL at the moment tho, don't quote me on that :)
16:31:25 <dons> Philonous: hmm. variable names.
16:31:31 <dons> Philonous: so when you use 'x' twice, it isn't recomputed.
16:31:45 <dons> but arbitrary function results aren't *globally* memoised.
16:32:00 <lilac> what gets memoized in this fashion may depend on compiler optimizations (it's certainly within the denotational semantics to not cache)
16:32:34 <Myoma> lilac: I thought lazy evaluation means it has to -- because the top level is like a big let
16:32:53 <Riastradh> Haskell isn't necessarily a lazily evaluated language, anyway.
16:32:55 <Philonous> dons: I'm aware of that. I just meant it is really confusing to read that lazy function evaluation is always memoized, especially when you are new to functional languages
16:32:58 <Riastradh> It is non-strict, rather than lazy.
16:33:18 <Cale> Basically, the only memoisation is that constant definitions don't get recomputed and that when a parameter to a function occurs more than once in the body of the function, then the results of evaluating that parameter are shared between the copies.
16:33:27 <mauke> but it doesn't say that lazy function evaluation is always memoized
16:33:28 <Myoma> yeah I have no clue how to reason about non-strict rather than lazy things
16:33:46 <Myoma> Cale, that's exactly the thing I was referring to
16:34:02 <lilac> Myoma: consider "f a = something expensive + a" versus "f = let s = something expensive in \a -> s + a". is "something expensive" cached in both of these cases? one of them? neither? may the optimizer transform them into each other?
16:34:02 <mmorrow> Philonous: that's very true, but for that to be the case /you need to bind the value to a variable/. But, say you do     let a = f 3 in print  [a, a, a, f 3, f 3, f 3]       the 'a' will only be evaluated once, but each of the 'f 3's in that list will all be evaluated separately without any knowledge of each other
16:34:03 <Myoma> when you write memoized fibs in that way, that is what is taken advantage of isn't it?
16:34:28 <Cale> This way?  fibs = 0 : 1 : zipWith (+) fibs (tail fibs) ?
16:34:32 <Myoma> no I meant,
16:34:33 <stepcut> memoization seems like the wrong term in any case. What actually happens (in ghc) is that thunks get reduced to their most basic form, and further uses of that particular thunk can use the reduced form ?
16:34:48 <Myoma> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2)
16:34:51 <Myoma> fib' = fibs !! n
16:34:55 <Myoma> fibs = map fib [0..]
16:34:58 <mauke> mmorrow: ghc will actually cache all of them
16:35:28 <ac> I can't find anything in Data.Time.Clock to convert DiffTime to NominalDiffTime
16:35:30 <lilac> stepcut: that's an implementation detail; the result is still being cached, so it's still a form of memoization :)
16:35:32 <mmorrow> mauke: hmm. i didn't think so. link?
16:35:54 <Cale> Myoma: You're taking advantage of the fact that fibs is a constant.
16:36:58 <Myoma> if you put it all in a 'let' block, and run fib 30
16:37:08 <Myoma> could a lazy language have this not memoized?
16:37:25 <mmorrow> mauke: because if ghc did, would that not be essentially performing "automatic memoization"?
16:37:31 <lilac> Myoma: you memoized that yourself explicitly.
16:37:47 <stepcut> lilac: my understanding is that with memoization the function remembers the results of previous inputs and uses that cache to avoid recomputing the result when it sees the same input a second time. But, that does not sound like what an Haskell implementions should do
16:38:33 <lilac> stepcut: i think the discussion basically hinges on "memoization" meaning different things to different people :-/
16:38:43 <mauke> mmorrow: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-November/011655.html
16:38:45 <lambdabot> Title: Common subexpression elemination (CSE), http://tinyurl.com/5m2vf3
16:38:49 <EvilTerran> you can't memoize without at least an Eq constraint on the parameter
16:38:54 * mmorrow reads
16:39:02 <EvilTerran> and at least Ord if you want to do it efficiently
16:39:21 <Myoma> lilac: ok to be more precise, what I meant was, I guess it's linear or something in GHC, but could a lazy language evaluate this with worse complexity?
16:39:39 <Myoma> I think if the complexity was worse, then it wouldn't be lazy evaluation, would it?
16:39:43 <stepcut> lilac: right. But, I think any attempting to apply it to what Haskell does is mostly wrong and will just confuse people ;)
16:40:12 <mmorrow> mauke: ahh, ok so you mean that's done in a common subexpression elimiation optimization pass by the compiler
16:40:17 <Philonous> Well, it appears to be a complex matter. And so it seems best to avoid imprudent statements about it :-/
16:40:34 <mauke> yes, because you wrote let a = f 3 in ... f 3
16:41:00 <Myoma> is common subexpression elimination .. moral ?
16:41:27 <mmorrow> mauke: nice catch on a technicality ;)
16:41:30 <Myoma> I guess if you were testing the complexity of something you'd just not use -O actually
16:42:00 <lilac> Myoma: the Haskell standard places essentially no constraints on runtime or memory usage, and i think it would be within the standard for an implementation to use exponential time to find fib n with that code. whether or not that counts as lazy evaluation is a matter of definition.
16:42:31 <Myoma> lilac: yeah I'm sure we can have precise enough definitions of lazy evalution and such to answer this
16:43:44 <lilac> stepcut: fair point :) but if someone can't cope with things being massively generalized, then they're likely to have trouble with haskell anyway ;-)
16:45:36 <lilac> Myoma: fwiw (admittedly not much), wikipedia doesn't mention a caching aspect of lazy evaluation at all
16:46:04 <Myoma> I don't think it's caching but fibs starts out a thunk, then it gets rewritten into several elements consed onto a thunk
16:46:20 * Myoma is not sure if any of these terms are correct
16:46:51 <Myoma> lilac:.. but do you see what I mean ?
16:49:58 <Myoma> no? :S
16:50:28 <lilac> your description of how GHC will handle the program seems accurate, but it sounds like caching to me.
16:50:40 <Myoma> ok
16:50:41 <Trinithis> It's more like it cant gc
16:50:44 <Myoma> I thought it was just lazy evalution
16:50:56 <Myoma> you rewrite onto the root of the graph (program) being reduced (evaluatde)
16:51:00 <Trinithis> imo
16:51:14 <Myoma> well you don't gc something in scope
16:51:31 <Trinithis> Yeah, so it's not implicit caching.
16:51:37 <Myoma> lazy evaluation is too hard to reason about :p
16:52:05 <lilac> Myoma: well, suppose thunks never got replaced by the reduced value, but were still only evaluated on a by-need basis.
16:52:25 <Myoma> lilac: yeah, it would be exp time instead
16:52:52 <lilac> question is, is it still lazy?
16:53:05 <Myoma> I think that's called normal order ?
16:53:11 <Trinithis> http://en.wikibooks.org/wiki/Haskell/Laziness
16:53:12 <lambdabot> Title: Haskell/Laziness - Wikibooks, collection of open-content textbooks
16:53:13 <Myoma> I don't really know but it's not lazy
16:53:38 <lilac> my understanding is that it is lazy, since (for instance) a program which creates _|_ but doesn't force it still terminates
16:53:40 <Trinithis> weak head normal form?
16:53:41 <rwbarton> lilac: I think that would be considered non-strict, but not lazy
16:54:24 <dons> "Last week we deployed new hardware - over 150 cores of CPU - expecting much higher data processing throughput along the pipeline of 30 or so perl sub-systems - but the performance boost seemed marginal and perl stood out as the culprit. "
16:54:28 <dons> parallelism fail.
16:54:38 <Myoma> I bet non-lazy non-strict evaluation is horrible to use
16:54:48 <Trinithis> dons: what's that from?
16:55:05 <dons> http://blog.vipul.net/2008/08/24/redhat-perl-what-a-tragedy/
16:55:10 <lambdabot> Title: Balance Through Extremism » Redhat perl. What a tragedy.
16:55:23 <dons> this is what happens when you start with a quick perl script
16:55:35 <ac> @hoogle NominalDiffTime
16:55:35 <lambdabot> Data.Time.Clock data NominalDiffTime
16:55:37 <lilac> rwbarton: do 'non-strict' and 'lazy' mean different things in the denotational semantics, or just in the actual implementation?
16:55:38 <dons> soon enough, your whole department depends on that perl script to get things done.
16:55:46 <dons> and you're screwed if its slow or has bugs.
16:57:22 <rwbarton> lilac: just the actual implementation
16:57:34 <Myoma> it would be nice to be able to think about lazy evalution a bit more formally
16:59:44 <EvilTerran> lilac, "non-strict" is semantics, "lazy" is implementation
16:59:59 <EvilTerran> in languages with constrained side-effects (like haskell), anyway
17:00:20 <Trinithis> Do people know of ways other than laziness to implement it?
17:00:26 <EvilTerran> specifically, lazy evaluation is an implementation of non-strict semantics
17:00:33 <EvilTerran> Trinithis, yes, but they're not generally very good
17:00:37 * qwr thinks that something slow and buggy could be written in any language...
17:03:24 <osfameron> well, there's a perl win that it has a fantastic profiler that showed the bug in the implementation of a common function on that system...
17:03:49 <Riastradh> qwr, yes, but Perl has a bizarre tendency to accrue gruesomely much better than most other languages.
17:04:23 <dons> disciplined engineering isn't what perl's about.
17:04:46 <dons> also, not my first choice for high performance multi core.
17:04:49 <osfameron> dons: did you even read the article?
17:04:58 <osfameron> it wasn't anything to do with undisciplined engineering
17:05:09 <Trinithis> perl's about writing code in a forum user's signature
17:05:12 <dons> i know.
17:06:05 <dons> osfameron: i was trying to summarise the approach to modularity, purity, and discipline in haskell vs perl. they're at two extremes of the gradient.
17:06:36 <dons> strangely, i taught both in the same course, once.
17:06:37 <EvilTerran> s/perl/php/
17:06:38 <lilac> EvilTerran: are 'call-by-need' and 'lazy evaluation' the same thing? or is lazy evaluation more general somehow?
17:06:40 <osfameron> dons: you mean that Perl has a massive number of useful modules (CPAN) whereas all Haskell is written in a single file?
17:07:00 <EvilTerran> lilac, i'm not really sure. the definitions all get a bit fuzzy in the details, i find
17:07:00 <dons> osfameron: ?
17:07:11 <Myoma> I bet all the definitions can be completely formal
17:07:13 <osfameron> dons: Perl has a strong tradition of modularity
17:07:17 <EvilTerran> dons, seeing as perl does have a module system, it's doing better than some languages
17:07:22 <dons> for sure.
17:07:27 <osfameron> if you're suggesting haskell is at the other end of a gradient, then that is the only thing you can be saying
17:07:30 <lilac> Myoma: i think the trouble is deciding on one specific set of definitions :)
17:07:42 <dons> ok. perl is a great langauge for building large, maintainable, robust systems.
17:07:45 <EvilTerran> indeed
17:07:52 <Myoma> There should be a programming languages wiki
17:08:07 <EvilTerran> you can agree on a set of definitions, but some other folk will agree on a different set
17:08:10 <osfameron> dons: it's fine if you don't like perl or you think haskell is more robust or more maintainable
17:08:11 <lilac> Myoma: wikipedia would have us believe that non-strict languages correspond to lazy evaluation strategies, of which call-by-need is only one :-/
17:08:16 <EvilTerran> Myoma, http://c2.com/wiki not suitable?
17:08:18 <Myoma> wikipedia sucks
17:08:26 <EvilTerran> er, http://c2.com/cgi/wiki
17:08:27 <lambdabot> Title: Front Page
17:08:33 <osfameron> dons: but to say that perl is on the other end of the gradient of modularity and engineering practise is just silly and wrong
17:08:55 <dons> yes, i was mistaken not to think of perl module system.
17:09:06 <dons> which is nifty. and a key thing that helped perl scale.
17:09:14 <dons> it wins points there.
17:12:13 <Trinithis> I think I'll write a SMITH compiler.
17:12:19 <Myoma> What is SMITH
17:12:26 <Trinithis> http://catseye.tc/projects/smith/doc/smith.html
17:12:27 <lambdabot> Title: Cat's Eye Technologies: The SMITH Programming Language
17:12:35 * Myoma can't load it
17:12:42 <Trinithis> http://www.esolangs.org/wiki/SMITH
17:12:47 <lambdabot> Title: SMITH - Esolang
17:13:09 <dons> we definitely need more tiny compilers written in haskell.
17:13:15 <dons> there's a serious shortage.
17:13:34 <Trinithis> I'm almost done with a funge 98 compiler (or rather interpreter)
17:13:34 <Myoma> not interpreters?
17:13:43 <dons> oh, more interpreters too.
17:13:52 * Myoma wrote an interpreter
17:13:53 <Trinithis> Tiny languages are fun to write
17:14:08 <Trinithis> write compilers/interpreters for*
17:14:08 <lilac> we could do with a common compiler middle-end shared between all the compilers :)
17:14:55 <lilac> and a Language.CPlusPlus module ;-) *ducks*
17:15:13 <Myoma> I thought somebody was writing that actually
17:15:25 <atomb> lilac: and then we might as well replace gcc ;)
17:15:30 <Myoma> what would it be used for though?
17:15:45 <dons> refactoring C++?
17:15:48 <atomb> replacing gcc!
17:16:01 <dons> rewriting C++ programs as Haskell source.
17:16:13 <Trinithis> is that module somewhat like Harpy?
17:16:39 <Trinithis> aka, writing c++ using haskell code?
17:16:43 <dcoutts_> mauke: how did you get the error "Codec.Compression.Zlib: invalid block type"? what was it a symptom of?
17:16:50 <newsham> great, when will ghc runtime be compiled by ghc instead of gcc?
17:16:50 <Pseudonym> Actually, Haskell'
17:16:57 <Pseudonym> s module system is pretty close to that of C++.
17:17:00 <Pseudonym> So it's not so dumb. :-)
17:18:16 <bjrn> How do I simplify this?   do a0 <- f 1; a1 <- f 1; a2 <- f 1; a3 <- f 1; let alist = [a0,a1,a2,a3]
17:18:36 <adu> hi
17:18:42 <newsham> mapM f [1,1,1,1]
17:18:47 <Myoma> alist <- sequence [f 1,f 1,f 1, f 1]
17:18:50 <adu> dons: can I help? :)
17:18:55 <newsham> ?src mapM
17:18:55 <lambdabot> mapM f as = sequence (map f as)
17:18:59 <dons> adu?
17:19:01 <bjrn> Ah nice, thank you
17:19:01 <adu> dons: I love rewriting things in Haskell
17:19:01 <rwbarton> ?src replicateM
17:19:01 <lambdabot> replicateM n x = sequence (replicate n x)
17:19:26 <dons> ?pl . undo do a0 <- f 1; a1 <- f 1; a2 <- f 1; a3 <- f 1; return [a0,a1,a2,a3]
17:19:27 <lambdabot> (line 1, column 1):
17:19:27 <lambdabot> unexpected "."
17:19:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:19:57 <ziman> @. pl undo do a0 <- f 1; a1 <- f 1; a2 <- f 1; a3 <- f 1; return [a0,a1,a2,a3]
17:19:58 <lambdabot> (f 1 >>=) . (((f 1 >>=) . (((f 1 >>=) . (return .)) .)) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:) =<< f 1
17:20:08 <Myoma> ah this is simpler
17:20:09 <Trinithis> ah much better
17:20:15 <adu> lol
17:20:16 <dons> yes, that's better.
17:20:17 <Trinithis> something I can read
17:20:20 <dons> taking apart the list.
17:21:08 <Trinithis> isn't joy a purely point-free language>
17:21:41 <adu> so who was refactoring C++ into Haskell?
17:22:00 <dons> parse C with Language.C, emit Haskell.
17:22:03 <dons> Problem solved :)
17:22:03 <Myoma> adu: Haskell -- automatically, using Language.CPlusPlus (which doesn't exist)
17:22:17 <newsham> dons: great.  so ghc runtime -> haskell?
17:22:32 <Myoma> a C monad would be cool
17:22:47 <adu> dons: really? wow i didn't know you could do that
17:22:48 <Trinithis> well we've got a Q monad!
17:22:51 <Myoma> like embedding C into haskell to make FFI easier
17:23:14 <Myoma> maybe it is not possible though
17:23:39 <adu> Myoma: you'd have to rebind everything
17:23:49 <Myoma> well I'd want bindings done automatically
17:24:06 <adu> fopen -> FilePath -> C Handle
17:24:19 <adu> oops ::
17:24:34 <adu> Myoma: like c2hs?
17:26:20 * Myoma has not used c2hs
17:30:36 <adu> so i am having trouble expressing something
17:31:56 <adu> in my typechecker, List a is the longhand for [a], and I'm wondering how to express the type List :: a -> [a]
17:32:31 <Myoma> shouldn't it be, List a = [a]
17:32:39 <Myoma> List :: Type -> Type
17:33:09 <Pseudonym> adu: data Type = TyConstructor Atom [Type] | TyVar Var
17:33:20 <Pseudonym> Example:
17:33:23 <adu> TyVar! of course!
17:33:31 <Pseudonym> TyConstructor "List" [TyVar "a"]
17:33:35 <adu> i guess i need to add a constructor
17:33:40 <mauke> dcoutts_: I think it was during 'cabal update'. I don't know of what it was a symptom, but rerunning 'cabal update && cabal upgrade' fixed it
17:33:46 <Pseudonym> You might want to use a shorter name than TyConstructor
17:33:55 <adu> Pseudonym: thanks
17:34:03 <dcoutts_> mauke: probably a truncated download
17:34:06 <Pseudonym> Then write unification.
17:34:09 <Pseudonym> That bit is FUN.
17:34:24 <adu> unification?
17:34:31 <Pseudonym> Yeah.
17:34:32 <adu> as in prologish unification?
17:34:38 <Pseudonym> Sure.
17:34:39 <dcoutts_> mauke: I've added some code to handle it better, though we still do not directly detect short downloads.
17:34:45 <Pseudonym> You're writing a HM-type type checker?
17:34:55 <adu> thats way beyond me, I just did "deriving(Eq)"
17:35:15 <Myoma> adu: You could steal some unification code I put up
17:35:19 <Pseudonym> http://www.dix.polytechnique.fr/M1/lambda/bib/82damasmilner.pdf
17:35:30 <adu> Pseudonym: I've been using Haskell for many years, and I have no idea what Hindly-Milner means still
17:35:34 <lambdabot> Title: Principal Type-Schemes for Functional Programs
17:35:45 <Pseudonym> Ah.
17:35:47 <Pseudonym> Well.
17:35:51 <Myoma> Hindly and Milner invented the type system
17:36:04 <Pseudonym> Kinda.
17:36:10 <Pseudonym> Hindley invesnted a logic type system.
17:36:10 <adu> ok, so how faithful is Haskell to it?
17:36:17 <Pseudonym> Milner re-invented it for ML.
17:36:25 <Pseudonym> Then Damas and Milner came up with the type inference algorithm.
17:36:44 <Pseudonym> adu: Haskell is an extension of Hindley-Milner.
17:36:55 <adu> Pseudonym: which parts are extensions?
17:37:20 <Pseudonym> Type classes, higher-ranked types, fundeps etc.
17:37:24 <Pseudonym> All the fun stuff, basically.
17:37:32 <mauke> polymorphic recursion?
17:37:32 <Pseudonym> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/PAGES/139.HTM
17:37:34 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/6c3rn7
17:37:43 <Pseudonym> let-polymorphism is Damas-Milner.
17:37:43 <adu> Pseudonym: ok typeclasses and fundeps i know, what are higher-ranked typed?
17:37:56 <Pseudonym> adu: Explicit "forall"s.
17:38:12 <Pseudonym> Anyway, I suggest you take a look at that book chapter.
17:38:16 <adu> ok
17:38:17 <Pseudonym> It'll help a lot.
17:38:22 <adu> ok
17:38:24 <Pseudonym> Very gentle introduction.
17:38:26 <mauke> foo :: (forall a. a -> a) -> (Int, Char); foo f = (f 1, f 'x')
17:39:02 <mauke> normal type inference would try to assign f a monomorphic type and fail because it can't unify 1 and 'x'
17:39:03 <Pseudonym> You'll have to mentally convert the notation from Miranda to Haskell.
17:39:10 <adu> Pseudonym: so far my typechecker can do juxtaposition and (->) and "Char", and i found a bug when i tried inferring the type of "List Char" hehe
17:39:14 <Pseudonym> Note that in Miranda, type variables were denoted *, **, *** etc.
17:39:22 <Pseudonym> Right.
17:39:40 <adu> ok
17:39:43 <Pseudonym> So when you see:
17:39:53 <Pseudonym> tree * ::= LEAF * | BRANCH (tree *) (tree *)
17:39:58 <Pseudonym> In Haskell that's spelled:
17:40:09 <Pseudonym> data Tree a = Leaf a | Branch (Tree a) (Tree a)
17:40:29 <adu> ok
17:41:05 <mauke> type 'a tree = LEAF of 'a | BRANCH of 'a tree * 'a tree
17:42:28 <Trinithis> Has anyone made a kitchen sink in haskell yet?
17:43:08 <Apocalisp> > sequence [[1,2], [3,4]]
17:43:11 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
17:43:43 <Trinithis> omg... what a pun!
17:44:02 <Apocalisp> How do you explain what sequence is doing here, to a layman?
17:44:04 <Trinithis> (your name)
17:44:07 <adu> unsafePerformKitchenSink
17:44:15 <Trinithis> lol
17:44:31 <Trinithis> sequence puts >> in between all the elems in the list
17:44:47 <Trinithis> sorta
17:44:55 <Trinithis> sequence_ actually does that though
17:45:08 <adu> >>=
17:45:11 <Apocalisp> ?type sequence
17:45:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:45:16 <Apocalisp> ?type sequence_
17:45:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:45:29 <Trinithis> > sequence [Just 1, Just 2]
17:45:31 <lambdabot>  Just [1,2]
17:45:32 <Myoma> sequece [x,y,z] = do x' <- x ; y' <- y ; z' <- z ; return [x',y',z']
17:45:34 <Trinithis> > sequence [Just 1, Nothing, Just 2]
17:45:37 <lambdabot>  mueval: Time limit exceeded
17:45:42 <Trinithis> > sequence [Just 1, Nothing, Just 2]
17:45:45 <lambdabot>  mueval: Time limit exceeded
17:46:17 <Apocalisp> > Just1 >>= \x -> Just 2
17:46:19 <lambdabot> Terminated
17:46:22 <Apocalisp> oops
17:46:35 <Apocalisp> > Just 1 >>= \x -> Just 2
17:46:38 <lambdabot>  Just 2
17:47:17 <Trinithis> question is... does lambdabot present a readable sequence on src... let's see
17:47:21 <Trinithis> @src sequence
17:47:21 <lambdabot> sequence []     = return []
17:47:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:47:21 <lambdabot> --OR
17:47:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:47:38 <Apocalisp> @undo do v <- x; vs <- sequence xs; return (v:vs)
17:47:38 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
17:47:59 <mauke> @. pl undo do v <- x; vs <- sequence xs; return (v:vs)
17:47:59 <lambdabot> (`fmap` sequence xs) . (:) =<< x
17:48:04 <Trinithis> Apocalisp, do understand the first printout of sequence the bot printed?
17:48:13 <Apocalisp> yes
17:48:30 <Trinithis> Now try writing it without do notation
17:49:23 <adu> one thing I'd like to know more about type-checking is what the standard inference rules are
17:49:40 <adu> because the only way I've seen them is crammed into an appendix, without any explaination
17:49:52 <mauke> it's just common sense :-)
17:49:53 <Myoma> (x :: p -> q) (y :: p) :: q
17:50:13 <adu> mauke: thats the only one I have implemented so far
17:50:14 <Myoma> (\(x :: a) -> b) :: a -> e,   assuming x :: a, b :: e
17:50:32 <adu> s/mauke/Myoma/
17:51:50 <Apocalisp> > Just 1 >>= \v -> sequence [Just 2] >>= \vs -> return (v:vs)
17:51:53 <lambdabot>  mueval: Time limit exceeded
17:52:21 <mauke> > Just 1 >>= \v -> sequence [Just 2] >>= \vs -> return (v:vs)
17:52:24 <lambdabot>  mueval: Time limit exceeded
17:52:26 <mauke> what
17:52:38 <Myoma> worse than before lol
17:52:48 <Saizan> hte limit is just too short
17:53:42 <b\6> kind of like life.
17:55:58 <Apocalisp> > sequence [[1]]
17:56:01 <lambdabot>  [[1]]
17:56:32 <Myoma> > fix sequence [[1]]
17:56:35 <lambdabot>  Couldn't match expected type `[[t1]] -> t'
17:56:39 <Myoma> > fix sequence
17:56:42 <lambdabot>  mueval: Time limit exceeded
17:57:49 <b\6> someone must know. i made an instance of parsec's Stream but parse says it's expecting a String for its input.
17:59:03 <ajdhs> sequence [[1,2],[3,4]]
17:59:15 <ajdhs> > sequence [[1,2],[3,4]]
17:59:17 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
17:59:38 <ajdhs> @src sequence
17:59:38 <lambdabot> sequence []     = return []
17:59:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:59:38 <lambdabot> --OR
17:59:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:00:11 <Apocalisp> ?type liftM2 (:)
18:00:13 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
18:00:32 <ajdhs> @src liftM2
18:00:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:00:38 <Apocalisp> so [a] -> [[a]] -> [[a]]
18:01:54 <mm_freak> besides monads and uniqueness types, what are other common solutions to the "world state" problem?
18:02:06 <Apocalisp> > liftM2 (:) [1,2] [[3,4],[5,6]]
18:02:09 <lambdabot>  [[1,3,4],[1,5,6],[2,3,4],[2,5,6]]
18:05:28 <newsham> tiny hexdump utility... worth putting on Hackage?  http://www.thenewsh.com/%7Enewsham/x/machine/Hexdump.hs
18:05:55 <mmorrow> <b\6> someone must know. i made an instance of parsec's Stream but parse says it's expecting a String for its input.
18:06:03 <mmorrow> b\6: still battling parsec?
18:06:23 * mmorrow is reading the logs
18:06:59 <mmorrow> newsham: ooh, cool. i'd use it a second. especially since it's haskell *and* tiny
18:07:32 <adu> newsham: oooo nice
18:07:44 <adu> newsham: can it search for bytestrings?
18:08:15 <newsham> search?
18:08:22 <newsham> it just makes a printable hex dump
18:08:27 <mmorrow> unicode would be nice :)
18:08:52 <adu> nah, I'm more interested in searching for 4E7F
18:09:13 * mmorrow shamelessly drops a link to http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-light
18:09:20 <lambdabot> Title: HackageDB: utf8-light-0.3, http://tinyurl.com/5nbge9
18:09:25 <dons> ?go utf8-string
18:09:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
18:09:27 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1
18:09:29 <dons> go utf8-string go!
18:09:33 <ac> @hoogle NominalDiffTime
18:09:33 <lambdabot> Data.Time.Clock data NominalDiffTime
18:09:40 <ac> @hoogle DiffTime
18:09:40 <lambdabot> Data.Time.Clock data DiffTime
18:09:40 <lambdabot> Data.Time.Clock data NominalDiffTime
18:09:40 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
18:09:56 <adu> newsham: I'm planning on adding byte-filtering to only
18:10:13 <adu> newsham: can I use your code?
18:10:41 <newsham> yes, public domain.  feel free.
18:10:46 <newsham> I'll add that to a comment.
18:11:05 <b\6> mmorrow: yeah. dunno. i made instance Stream Handle IO Char but parse says it wants String for its input. i thought any Stream would be ok.
18:11:25 <dibblego> http://hpaste.org/9925 Can a Monad be written for this? dcoutts_?
18:11:36 <ddarius> That instance of Stream isn't going to work.
18:12:04 <b\6> ok. please help out.
18:12:09 <b\6> needing clue.
18:13:07 <Saizan> dibblego: as a monad it will be like Either
18:13:09 <dcoutts_> dibblego: sure, it's just the same as the Either instance
18:13:22 <dibblego> but then does it satisfy ap = <*> ?
18:13:28 <ddarius> What module are you getting 'parse' from?
18:13:45 <b\6> ddarius: i've tried from Text.Parsec and Text.Parsec.Prim.
18:13:54 <Saizan> ?src ap
18:13:55 <lambdabot> ap = liftM2 id
18:14:00 <dibblego> if >>= is just like Either, then there is no need for (Monoid e) => which arouses my suspicions of the equivalence of ap to <*>
18:14:08 <ddarius> If you are using any functions from Text.ParserCombinators.Parsec, then they are going to use the String instance.
18:14:35 <Saizan> dibblego: you're right, they won't be equal
18:14:38 <b\6> ddarius: i don't. i use Text.Parsec stuff.
18:14:40 <dcoutts_> dibblego: it doesn't have to do exactly the same, the <*> can collect errors from both branches
18:14:50 <ddarius> But even if you get this to run, Handle isn't a valid instance of Stream unless you are doing something extremely clever.
18:15:09 <ac> so how do I turn seconds in to a NominalDiffTime?
18:15:10 <dcoutts_> dibblego: I'm not sure that ap = <*> is a hard and fast rule is it?
18:15:10 <dibblego> dcoutts_, I think it's broken for ap /= <*>
18:15:20 <dibblego> I think(?) it is
18:15:42 <dibblego> well, all monads give rise to applicative, but *this* monad does not give rise to *that* applicative
18:15:45 <dcoutts_> dibblego: it's always a suitable definition for applicative functors that are monads
18:16:44 <dcoutts_> I think it'd be pretty dissapointing if we required that all applicative functors that are also monads give up all their special power when used as applicative functors
18:17:00 <dibblego> this applicative functor is not a monad
18:17:09 <dibblego> another applicative functor happens to be though
18:17:23 <dibblego> that is, the one equivalent to Either
18:17:23 <dcoutts_> it is a monad, just with less exciting properties
18:17:35 <dibblego> but that's a different applicative
18:17:53 <newsham> dcoutts: how do you mean?
18:17:58 <dcoutts_> I see nothing wrong with them being different
18:18:15 <dibblego> let us write the monad
18:18:21 <dibblego> then derive the applicative
18:18:27 <dibblego> that applicative is different to the one given
18:18:54 <dibblego> aside from the fact that they are different (which I do have a problem with), then the given applicative is not a monad
18:19:13 <dibblego> I think - that's the question
18:19:21 <dcoutts_> newsham: dibblego has an applicative functor (like one I published 5 years ago) that collects errors from independent branches of computations. It can also be made a monad with the ordinary lines Either monad semantics.
18:19:25 <newsham> why should <*> be ap?  thats just one choice of many, no?
18:19:33 <dcoutts_> newsham: right.
18:19:53 <dibblego> the question is why should ap be <*>
18:20:00 <newsham> ie ZipList's <*> isnt an ap
18:20:16 <newsham> oh, i see what cale was saying earlier.
18:20:23 <dibblego> but then, ZipList has a different applicative available as well
18:20:41 <dcoutts_> newsham: what was Cale saying?
18:20:51 <newsham> err.. not cale, dcoutts.
18:20:51 <Myoma> does one write a garbage collector in assembly
18:20:53 <Myoma>  ?
18:21:00 <ddarius> Myoma: Not usually.
18:21:01 <dcoutts_> Myoma: no, usually C.
18:21:22 <dcoutts_> or has been known in C++
18:21:24 <newsham> you were saying that you shouldnt tie monad's ap to be defined as <*> (i think)
18:21:38 <dcoutts_> newsham: other way around, but yes.
18:21:50 <newsham> ok.
18:21:58 <newsham> anyway, i need to get work done. :)
18:22:05 <dcoutts_> dibblego: I don't think there's anything special about ap
18:22:10 <dibblego> should a Functor's fmap be defined with >>=/return?
18:22:24 <dibblego> s/with/as
18:22:31 <dcoutts_> dibblego: no
18:22:53 <dibblego> it is sensible to write an instance Functor/Monad that violates their relationship?
18:23:04 <dcoutts_> dibblego: no
18:23:10 <dcoutts_> dibblego: but ap is not special, like >>=
18:23:15 <mauke> it should be defined as liftM
18:23:32 <newsham> boo to liftM, yay to <$> and <*>.
18:23:47 <dcoutts_> @yarr!
18:23:48 <lambdabot> I heard andersca is a pirate
18:23:50 <dibblego> why is it any less special?
18:24:02 <dibblego> all monads are applicative are functors
18:24:43 <dcoutts_> dibblego: check the applicative functor paper for what the properties ought to be
18:25:31 <dibblego> does the monad paper mention fmap in terms of >>=/return ?
18:27:12 <ddarius> There is no "the" monad paper.
18:30:32 <b\6> in the morning the paperboy should toss monad papers to all the doorsteps.
18:31:00 <r3m0t> extra! extra! hot monad transformers on page 3
18:31:22 <mmorrow> b\6: ok, got sidetracked with a phonecall. hmm, so what does your main read-from-handle-give-line-to-parsec-trigger-appropriate-action/whatever-repeat loop look like?
18:31:36 <dibblego> regardless, the question might be better phrased as, is there a monad that can produce *that* applicative?
18:34:53 <b\6> mmorrow: i just save the handle from connectTo. i made Handle an instance of Parsec's Stream. i pass the handle to parse as input because i thought :t parse is telling me any Stream is ok.
18:35:00 <mmorrow> i don't recall off the top of my head nor use applicative enough to construct it ....  so  ("==>" := implies),   x is a monad ==> x is applicative applicative  but it's not the case that   x is applicative ==> x is a monad ??
18:35:08 <dcoutts_> dibblego: see "Applicative Programming with Effects" page 9.
18:35:14 <dibblego> mmorrow, yes
18:35:17 <dibblego> dcoutts_, ok cheers
18:36:06 <dibblego> also, x is applicative ==> x is a functor
18:37:36 <mmorrow> b\6: it seems like you want a function that takes a handle and a parser function (expecting say one line), and the loops reading a line from said handle, feeding it to the passed in parser function, doing something with the result, repeat  until some specified thing happens (possibly identified by yet another function passed in the returns Bool or something)
18:38:04 <dcoutts_> dibblego: so, from my brief re-reading, nothing jumps out at me that really clearly answers the question.
18:38:33 <mmorrow> handle :: Handle -> (String -> a) -> (a -> Bool) -> (a -> IO ()) -> IO ()
18:39:00 <b\6> mmorrow: maybe what i'm doing is nutso; that's ok. what i'm wondering is why what looks like should work isn't.
18:39:53 <jeffz> mmorrow: the only problem I see with reading a line at a time is that it interferes parsing the underlying protocol when the parser wants to consume something that consists of multiple lines
18:39:58 <mmorrow> it sounds "slightly troublesome" to me, since you can't read from a Handle without doing IO, so that means the parser has to do IO
18:40:18 <b\6> yeah, it's not ideal.
18:40:27 <b\6> but still. how should i understand :t parse?
18:40:36 <b\6> i'm not sure how to read that signature.
18:40:59 <mmorrow> jeffz, b\6: ok, that's fine. what is the protocol/whatever you're parsing?
18:41:19 <b\6> i'm doing nntp.
18:41:32 * mmorrow does a quick readup of nntp
18:41:56 <jeffz> http://www.ietf.org/rfc/rfc977.txt
18:42:53 <mmorrow> ok, so not this one then? http://tools.ietf.org/html/rfc3977
18:43:00 <lambdabot> Title: RFC 3977 - Network News Transfer Protocol (NNTP)
18:43:05 <ziman> b\6, Parsec's parse?
18:43:12 <b\6> ziman: yeah.
18:43:38 <jeffz> mmorrow: looks more recent :)
18:43:41 <ziman> parse takes (a parser on tokens with () (no) state returning `a'), (source name), (list of tokens) and returns (Either ParseError or the value `a')
18:44:26 <b\6> ziman: what does the list of tokens have to look like?
18:44:39 <b\6> ziman: what is the Stream stuff about in the signature of parse?
18:44:58 <mmorrow> hmm, so "Each command line must be terminated by a CR-LF (Carriage Return -
18:44:58 <mmorrow>    Line Feed) pair."  and "  Command lines shall not exceed 512 characters in length, counting all
18:44:58 <mmorrow>    characters including spaces, separators, punctuation, and the
18:44:58 <mmorrow>    trailing CR-LF"   "There is no provision for continuation
18:44:58 <mmorrow>    command lines."
18:45:37 <mmorrow> so is there some structure to the command sequence that exists at a level higher that line-level?
18:46:09 <b\6> mmorrow: really, i don't think the protocol matters. i'm really wondering about why making a stream and giving it to something expecting a stream is not working.
18:46:15 <mmorrow> in other words, why is it more ideal for the parser to get more than one line?
18:46:53 <ziman> b\6, hm, I don't have any Stream there. But i suppose it's just an abstraction enabling Parsec parse other tokens than Chars (if you have a separate lexer) -- you have a GenParser consuming tokens (tok) and you feed it with a list/Stream of those tokens ([tok])
18:46:57 <b\6> mmorrow: there are multiline responses.
18:46:58 <jeffz> mmorrow: 3.1.1 shows that there are multiline responses
18:47:12 <mmorrow> b\6: i don't know about the stream issue :) it seems to me though how you're going about the reading/parsing/dispatching is backing you into a corner
18:47:28 * mmorrow looks at 3.1.1
18:48:06 <mmorrow> ahh, ok.
18:48:57 <mmorrow> so one really useful thing sometimes is to have the parser return a /function/ which is "what to do next"
18:49:36 <b\6> ziman: should be able to see Stream in Text.Parsec. it has just one function, uncons.
18:49:37 <jeffz> b\6: the problem though, is that when you are trying to return the unconsumed input, it blocks?
18:50:14 <b\6> jeffz: yeah. if i getInput after i've parsed everything, it hangs. so i'm trying a different approach where my implementation of Stream knows how to raise an exception if it times out.
18:50:27 <b\6> then i write my other stuff as if nothing can go wrong, kind of.
18:50:37 <mmorrow> so maybe a parser that gets lines, and returns either a function, or maybe a (function, # of lines this function wants), then you read that many more lines, and hand it off to the function in the fst of the pair (or something) ?
18:52:03 <mmorrow> b\6: what scares me, is handing control over to the parsing function, when imo the function doing the reading from the Handle should be controlling that parsing function
18:52:46 <b\6> mmorrow: i know it's not ideal, but 3000 consecutive hours of reading until my eyes are shooting out blood which is turning to vapor instantly on my million degree cpu makes me think i should do it this way.
18:52:55 <mmorrow> hehe
18:53:12 <jeffz> mmorrow: it seems completely normal to hand control over to the parsing function, for example I have a parser for PostScript which I give the input to and it returns a token because I as the calling function have no knowledge of the underlying data, that's the job of the parser.
18:54:42 <b\6> > :t parse
18:54:44 <lambdabot> Terminated
18:54:47 <mmorrow> sure, but from what i understand, in b\6's case that "token" is the entire message
18:55:04 <ddarius> Stream is only in parsec3
18:55:10 <b\6> that's what i'm using.
18:55:33 <mmorrow> rather than say, a single command
18:59:02 <mmorrow> and i see the mapping from b\6's situation to you ps situation as being, since b\6 is a network client, parsing the entire ps file at once is like connecting to some remote machine, then handing the entire rest of that interaction to the parser. that may have come out convoluted, but what i'm really trying to say is that since he's communicating in realtime, it seems to me that he'd want to parse the ps commands one-by-one, rather t
18:59:02 <mmorrow> han all at once
19:00:31 <mmorrow> i dunno, i'm starting to rant :)
19:00:41 <b\6> well, i send a command and want to use parsec to interpret what comes back, whether it's multiline or not. but really that's beside the point. to me it looks as if parse can take a Stream. so i'm very sad to make a Stream and have ghc tell me parse wants a String.
19:00:56 <jeffz> mmorrow: no, not quite, my use is almost the same except that my input isn't from the network, I don't parse the entire ps input at once, I only get one token, return it and the remaining input, which insofar as I can tell, is what b\6 was aiming to do
19:01:31 <mmorrow> b\6: i'm interested in seeing how you're going about the Handle-Stream thing, could you paste a snippet?
19:01:59 <b\6> yeah, sec.
19:02:13 <ddarius> b\6: What is the type of your actual parser?
19:02:20 <mmorrow> jeffz: yeah, scratch the angle i was just trying to take, because it sucks. ok, do you have a separate lexer and parser, or are they one?
19:03:06 <b\6> ddarius: Parser a -> IO a
19:03:20 <cjs> Argh. Cabal version conflict. Anybody have any thoughts on what I can do about this? http://hpaste.org/9926
19:03:52 <jeffz> mmorrow: just one.
19:03:57 <b\6> mmorrow: http://hpaste.org/9927
19:04:02 * mmorrow looks
19:04:04 <cjs> Basically, my system Cabal is 1.2.4.0, but I have a local install tree (just for this project) where I want to use Cabal 1.4.0.1.
19:05:43 <ddarius> 'Parser' is too specific and that wasn't what I was asking.
19:05:44 <mmorrow> jeffz: ga, i have to run somewhere fast, be back in a few (i'm interested in parsing strategies, so hold those thought!! :))
19:05:58 <mmorrow> thoughtS
19:06:58 <newsham> whats the turnaround on getting a hackage username like?
19:08:33 <ziman> well, Data.Stream seems to have listToStream according to this http://hackage.haskell.org/packages/archive/Stream/0.2.6/doc/html/Data-Stream.html
19:08:35 <lambdabot> Title: Data.Stream, http://tinyurl.com/5nhwr6
19:08:55 <ddarius> newsham: A day or two.
19:09:06 <newsham> danke.
19:09:06 <ddarius> Or whenever Ross gets to it.
19:09:10 <ac> has anybody dealt with intervals of time using Data.Time.*?
19:10:11 <ac> the API seems to be broken to me
19:13:29 <cjs> I have.
19:14:30 <ac> cjs: awesome. So have you used DiffTime / NominalDiffTime?
19:15:42 <cjs> I use only NominalDiffTime. Haven't seen a leap second in a while, anyway. :-)
19:15:48 <binarybandit> can*
19:15:51 <binarybandit> oops
19:16:35 <cjs> I'm doing POSIX-type timestamps (microseconds since the Unix epoch), and I'm pretty sure that the POSIX ones ignore leap-seconds, too.
19:17:06 <ac> cjs: how can you create a NominalDiffTime from an integer?
19:17:23 <cjs> fromIntegral.
19:17:34 <ac> bah :-P
19:17:51 <cjs> >let n = 3333333 in fromIntegral n :: NominalDiffTime
19:17:55 <waynemokane> I'm doing this InteractTCP example from here - http://stephan.walter.name/blog/computers/programming/haskell/interacttcp.html
19:18:00 <ac> cjs: right. So what's secondsToDiffTime for then?
19:18:02 <lambdabot> Title: Stephan Walter → blog, http://tinyurl.com/2jhdps
19:18:08 <waynemokane> but I can't get the server to work for anything except what is given
19:18:15 <ac> cjs: and what the heck is the difference between those two?
19:18:38 <waynemokane> for instance doing interactTCP 1234 (return . (flip (++)) " suffix")   doesn't work
19:19:06 <cjs> That produces a DiffTime, not a NominalDiffTime.
19:20:15 <ac> cjs: the lib documentation isn't very clear at all
19:20:27 <cjs> Hm. I'm not clear on why that's there.
19:20:40 <Trinithis> "Screw Haskell!  I'm using ILLGOL for my next project!"
19:20:40 <Trinithis>   -- Name withheld by request
19:20:49 <Trinithis> just came across that
19:20:55 <Myoma> what is ILLGOL?
19:20:58 <cjs> The key point, ac, is I think: "If you don't care about leap seconds, use UTCTime and NominalDiffTime for your clock calculations, and you'll be fine."
19:21:16 <cjs> You'll note that a PosixTime is a NominalDiffTime.
19:21:17 <Trinithis> ILLGOL is a joke languiage
19:21:40 <ziman> illgorithmic language
19:21:47 <Trinithis> http://catseye.tc/projects/illgol/doc/illgol.txt
19:22:41 <Trinithis> I think the quotes at the end of that link I just gave are funny
19:23:02 <ac> I definitely don't care about leap seconds
19:23:31 <Trinithis> oh, you will! come a couple thousand years, your program will need it
19:23:49 <Trinithis> (I have no idea what a leap second is)
19:24:06 <ac> It's to keep the clock time synced with the rotation of the earth
19:24:13 <ac> some days are 86401 seconds
19:24:14 <b\6> we should just fix the earth.
19:24:30 <Trinithis> Is it leaps years taken down the the seconds' level?
19:24:37 <ac> basically
19:24:42 <cjs> Ok, quick. Everybody run in...wait, which direction? East or West?
19:24:47 <Trinithis> EAST!
19:25:03 <ac> ok, nobody stop now!
19:25:11 <b\6> feels better.
19:25:16 <b\6> think it might have worked.
19:25:23 <b\6> ?type parse
19:25:24 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> SourceName -> s -> Either ParseError a
19:25:29 <b\6> how do i read that?
19:25:29 <cjs> You think that the monomorphism restriction is a fertile topic for conversation, check out the ones about whether we should keep or ditch the leap second.
19:26:07 <ac> well in a few hundred years the sun would rise 30 minutes too early (or late)
19:26:12 <Trinithis> Does monomorphism restriction have a practical use?
19:26:29 <dons> yeah.
19:26:37 <dons> it's entirely for practical effect.
19:26:37 <Trinithis> What for?
19:26:39 <mmorrow> b\6: ah, i wasn't familiar with the Stream class, and it looks like making a Handle an instance of it might be a nice thing after all ;)
19:26:52 * mmorrow continues reading parsec docs
19:26:52 <Trinithis> It seems like an inconvienice from my usages
19:27:10 <dons> it can improve performance, as overloaded things that look like constants, are forced to be constants.
19:27:35 <Trinithis> Oh, does it "drown" polymorphism?
19:27:59 <Trinithis> or better yet, got a link to waht it actuall is?
19:28:01 <ddarius> mmorrow: b\6's instance won't work.
19:28:21 <mmorrow>  b\6: i'm not sure what you mean by "how do i read that?", but the first thing that comes to my mind is that you need IO or (Monad m => m) in there where it says " Identity"
19:28:33 <mmorrow> ddarius: what's the snag?
19:29:28 <b\6> mmorrow: you mean in my implementation of Stream?
19:30:02 <mmorrow> i meant in the type sig for parse
19:30:08 <mmorrow> that function won't work for you
19:30:46 <mmorrow> because it expects the s in there to be s.t.  (Stream s **Identity** t)
19:31:09 <mmorrow> and you want   (Monad m) => m    or  IO   in place if Identity
19:31:13 <ddarius> mmorrow: The documentation for the Stream class says: "A Stream instance is responsibly for maintaining the 'position within the stream' in the stream state s."
19:31:18 <mmorrow> since you're using the IO monad
19:31:42 <mmorrow> ddarius: oh i see
19:32:03 <mmorrow> "This is trivial unless you are using the monad in a non-trivial way."
19:32:19 <ddarius> mmorrow: Which you are if you are using getChar
19:32:40 <mmorrow> yeah
19:32:43 <ddarius> Trivial would be uncons s = return ...
19:33:12 <mmorrow> so essentially, the monad there really serves no useful purpose?
19:33:15 <ddarius> Basically, there will be no backtracking so any parser using 'try' will do the wrong thing.
19:33:42 <b\6> ddarius: yeah, i know.
19:34:26 <b\6> willing to try this for a while since i don't need try.
19:34:43 <mmorrow> b\6: have you made any progress?
19:35:28 <ddarius> b\6: You can't even indirectly use try.
19:35:49 <ddarius> mmorrow: No, you could use the monad non trivially.  The statement is that you are only guaranteed to have a correct instance of uncons (as far as preserving position) if you do, not that it is wrong if you don't.
19:35:59 <b\6> mmorrow: no, i'm stumped. i don't understand why my implementation of stream isn't working. i don't get why parse says it wants string.
19:36:47 <mmorrow> could you paste the code that takes a Handle and subsequently calls parse?
19:37:12 <b\6> it's just the most basic thing. parse p "" h.
19:37:20 <mmorrow> ddarius: i see
19:37:24 <b\6> ghc says oh no, parse expects String there, not Handle.
19:37:41 <Trinithis> check your version of parsec?
19:37:44 <mmorrow> do you have both parsec and parsec3 installed
19:38:06 <b\6> mmorrow: yeah. but i say > 3 in my cabal and i only use Text.Parsec.*.
19:38:18 <ddarius> What is the type of 'p'?
19:38:26 <mmorrow> whats the full error msg?
19:38:36 <Trinithis> Is it legal syntax to do import Abc.* ?
19:38:43 <mmorrow> no
19:38:43 <b\6> Trinithis: i meant figuratively.
19:38:51 <Trinithis> just checking
19:38:52 <b\6> Trinithis: as opposed to Text.ParserCombinators.*
19:40:18 <b\6> mmorrow: in a function Parser a -> IO a, i do parse p "" h where p is Parser Status.
19:40:54 <ddarius> What is Parser?  That type synonym is only defined in modules for specific stream types.
19:41:24 <mmorrow> yeah, i think the problem is in the type of parser you're handing to parse
19:41:31 <b\6> ddarius: :( i got it from Text.Parsec.String.
19:41:34 <b\6> i feel great shame.
19:41:34 <mmorrow> it's making parse expect a String
19:41:38 <b\6> so what should i be using?
19:41:55 <b\6> some GenParser?
19:42:14 <ddarius> You should be using the Parsec type synonym
19:42:29 <ddarius> Actually, not even that
19:42:34 <ddarius> ParsecT is what you should be using.
19:42:46 <mmorrow> yeah it looks like that's the case
19:42:49 <mmorrow> data ParsecT s u m a
19:43:08 <koninkje> dibblego: wren == koninkje == winterkoninkje
19:43:17 <mmorrow> data ParsecT = ParsecT { runParsecT :: State s u -> m (Consumed (m (Reply s u a))) }
19:43:24 <dibblego> ah, hello koninkje :)
19:43:32 <koninkje> heya, what's up? :)
19:43:45 <dibblego> just aligning types as usual :)
19:44:49 <mmorrow> (Stream Handle IO Char) => ParsecT Handle () IO a
19:45:22 <mmorrow> where a is data NntpMsg = This | That | ...   or something
19:45:53 <b\6> ok, studying. thanks for helping so much.
19:46:00 <mmorrow> :)
19:46:27 <b\6> confused now about what types my parsers should be. dons and co seem to use CharParser and GenParser in chapter 17.
19:46:30 <b\6> of rwh.
19:46:47 <ddarius> They are using parsec2
19:46:58 <b\6> ah.
19:47:12 <mmorrow> and those take a [tok], where CharParser ==> tok == Char
19:47:33 <b\6> ok. i kind of knew they used 2 because they had to add applicative stuff.
19:47:36 <b\6> which is already there in 3.
19:47:43 <b\6> thanks for unsnarling my stuff.
19:52:10 <Myoma> > x:y:z:w:[]
19:52:13 <lambdabot>  [x,y,z,w]
19:52:27 <Myoma> @quote
19:52:27 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
19:52:32 <Myoma> @quote
19:52:33 <lambdabot> osfameron says: <ivanm> @localtime popcorn <osfameron> every time is popcorn time
19:53:49 <Myoma> @quote
19:53:49 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
19:55:21 * Twey laughs.
19:55:39 <Twey> What's that, a koan?  :)
19:55:55 <shapr> @quote
19:55:55 <lambdabot> shillelagh says: <ivanm> so shillelagh == no significance? <shillelagh> yep!
19:56:12 <psyklops> does that take arguments?
19:56:18 <psyklops> @quote duck
19:56:18 <lambdabot> No quotes match. You type like i drive.
19:56:22 <psyklops> aha
19:56:40 <psyklops> @quote argument
19:56:40 <lambdabot> ndm says: i think @0 is a great name for the 0th argument to a function
19:56:48 <Myoma> hi shapr!
19:56:51 <psyklops> (I'm done)
19:57:17 * shapr hugs Myoma 
19:57:18 <shapr> hi!
19:57:32 * Myoma *hug*
19:58:10 * Myoma couldn't sleep :/
19:58:12 <shapr> aww
19:58:22 <shapr> I'd suggest reading asm code.
19:58:27 <shapr> That always knocks me out.
19:58:35 <Myoma> I actually was a sec ago :D
19:58:38 <shapr> haha
19:58:47 <Nafai> Hey shapr!
19:58:51 <Myoma> I wanted to learn assembly but I haven't figured out why to learn it yet
19:59:09 <shapr> hiya Nafai!
19:59:16 <shapr> Myoma: Because you understand CPUs better then.
20:02:32 <Nafai> shapr: How are you doing?
20:02:39 <shapr> I'm okay, how are you?
20:03:18 <sclv> modern cpus rearrange all yr assembly around and pipeline it anyway though, no?
20:03:37 <shapr> sclv: Mostly, yeah.
20:04:58 <sclv> which means assembly is just a better educated guess than a higher level language...
20:05:02 <shapr> Yup
20:05:14 <shapr> But at one point it was only one layer above the real deal.
20:05:31 <sclv> man after a semester learning to program assembly in college, i was so mad when i found that out...
20:05:43 <sclv> (ok, the whole semester wasn't assembly i think...)
20:06:18 <shapr> And for some CPUs like the Cell sidekick cores, there's almost no pipeline, and it's almost the actual hardware.
20:06:20 <Nafai> shapr: Not bad.  Today was my last day at my job, doing contract work full-time for a while.  I also got a new laptop today!
20:06:26 <shapr> I think the Cell can reorder two instructions.
20:06:29 <shapr> Nafai: awesome!
20:06:56 <waynemokane> anybody have a good example of combining state with IO?  for example, a TCP client that maintains state in between requests
20:08:11 <Nafai> shapr: Going to try xmonad again!
20:08:20 <shapr> cool!
20:08:25 <sclv> waynemokane: sessions in a cgi...
20:08:29 <sclv> a gui...
20:09:07 <sclv> anything, really? a game of tic tac toe on the console...
20:09:43 <waynemokane> how about... there is an echo server listening on a TCP port, and I want to write a client that sends it five requests and stores each response in a list
20:10:07 <waynemokane> I know it has something to with StateT, as the example here shows: http://www.haskell.org/haskellwiki/Simple_StateT_use
20:10:19 <lambdabot> Title: Simple StateT use - HaskellWiki
20:10:25 <waynemokane> but that is only showing IO (), not IO Handle
20:10:53 <dons> hey kids, does that look like Haskell's in 2nd place on the quad core shootout to anyone else?
20:10:56 <dons>   
20:10:56 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
20:10:58 <sclv> StateT isn't for persistent state, although it can be used to make persistent state easier...
20:10:58 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® Computer Language Benchma ..., http://tinyurl.com/55nbs6
20:11:13 <dons> even though we've not submitted any multicore benchmarks yet...
20:11:20 <Myoma> waynemokane: runStateT (let loop = do lift $ getLine ; modify (+1) ; lift . print =<< get ; loop in loop) 0
20:11:37 <Myoma> waynemokane: try this in ghci if you want :m + Control.Monad.State
20:12:30 <waynemokane> thanks... I'm checking it out
20:12:30 <dons> we need to sit down and submit good parallel programs for the quad core shootout machine.
20:12:40 <sclv> Its if you can imagine writing an entire program or section of one which "threads" (i.e. passes from function to function call) a single record that holds your "state" at that moment.
20:12:41 <dons> that's a real opportuntiy to dominate it for quite a while, imo.
20:12:59 <dons> sjanssen: starting with parallel binary trees, say.
20:13:02 <Trinithis> waynemokane, you can look at my funge interpreter. It uses StateT IO
20:13:08 <b\6> more like donsimate it.
20:13:20 <dons> well, compared to single core, we have a huge advantage.
20:13:21 <shapr> We have DONSIMATED the competition!
20:13:27 <Myoma> hehehe
20:13:34 <Trinithis> if you are interested, just ask for a link and ill supply
20:13:36 <dons> it's a lot easier to parallelise the high level haskell entries, and we've a multicore, smp ghc on the system already.
20:13:49 <dons> oh, you guys.
20:13:53 * shapr hugs dons
20:13:58 * dons hugs #haskell
20:14:03 * dons highfives shapr
20:14:12 <shapr> Under the leadership of dons, the Haskell community is KICKING BUTT!
20:14:14 <sclv> dons: why the jump on quadcore if we're building in the normal runtime?
20:14:25 <sclv> erm, singlethreaded that is.
20:14:26 <dons> sclv: we've got the threaded runtime too, if you want it.
20:14:29 <dons> sclv: pass in -threaded
20:14:37 <dons> sclv: we control the entire build and runtime flag set.
20:14:41 <sclv> right -- but on the shootout, I mean, what accounts for the current but kickingness?
20:14:41 <waynemokane> Trinithis, please do, can't find on google
20:15:00 <dons> sclv: oh, hmm. ghc scales well to 64 bit? and they've not ported the things that are beating us on 32 bit
20:15:01 <Trinithis> Cause it's on my comp... let me cook it
20:15:11 <sclv> heh.. that sounds about right.
20:15:23 <dons> on 32 bit we're currently beaten by C++ intel, C intel, Lisaac, Clean, Pascal, C.
20:15:26 <dons> s/C/D/
20:15:32 <dons> none of which are on 64 bit.
20:15:41 <dons> Haskell is more portable :)
20:16:02 <dons> 64 bit systems are a disruptive event I'd not thought about in a while.
20:16:08 <dons> it prevents things like Clean getting press
20:16:42 <sclv> Hmm... so if we submit programs optimized for concurrency those entries will place low as alts on the single-core benchmarks and then high as the winners on the multicore ones?
20:16:50 <waynemokane> also, can someone explain in a nutshell what the dollar sign operator does?  I can't really tell from its type
20:16:53 <dons> sclv: right.
20:17:51 <sclv> it really does seem like a nice opportunity for lots of foax to get their hands dirty with benchmarks :-)
20:17:54 <sclv> big open field.
20:17:59 <Myoma> foax :D
20:18:09 <Myoma> plural of fox
20:18:48 <Myoma> waynemokane: the type is ?  (a -> b) -> a -> b ?
20:18:53 <shapr> faux?
20:19:24 <Myoma> waynemokane: it takes a function f :: a -> b, and a value x :: a, then it gives the result b -- only way to make that value is (f x)
20:19:31 <sclv> of course, I have no idea how they'll grade "same algorithm" tests on a quadcore machine?
20:19:42 <Myoma> waynemokane: f $ x = f x .. so it just applies a function with a value
20:20:38 <dons> sclv: yeah, algorithm + strategy = parallelism, am i right? :)
20:20:40 <Trinithis> anyone know a quick n dirty file upload?
20:20:42 <dons> so it's all in the strategy.
20:20:46 <Trinithis> (for a tar.gz)
20:21:02 <dons> but yes, i think we could quickly turn around these parallel programs.
20:21:15 <dons> and it will take ages (undefined even) for the C and C++ guys to catch up.
20:21:17 <sclv> all with seq then and not with explicit threads? hmm
20:21:21 <dons> the ocaml guys can't do smp.
20:21:32 <dons> so we'll be out in the lead with just erlang for company.
20:21:41 <dons> sclv: sure threads, par et al
20:21:41 <Trinithis> waynemokane: about the $ ... have you ever used a scientific calculator?
20:21:44 <shapr> y0 RobotGuy, wassup?
20:21:45 <dons> whatever floats your multicore boat.
20:22:10 <sclv> dons: I just mean that if we use threads, I wonder how they'll gauge the "same algorithm" issue?
20:22:13 <dino-> waynemokane: Also, right associative, so things like this: f (g (h x)) can become f $ g $ h x
20:22:19 <waynemokane> Trinithis hmm back in he day
20:22:40 * Myoma would rather see (f . g . h) x
20:22:42 <sclv> at the moment I don't even know which parallelize well at all out of their benchmarks.
20:22:45 <dino-> Like backwards shell piping, in a way
20:23:07 <Trinithis> Well, the analogy is that if you have more ( than ), the calculator implicitly adds a correct amount of ) to the end to make them all match
20:23:12 <Trinithis> the dollar sign is like that
20:23:19 <Trinithis> in that it is the excess (
20:23:22 <blbrown> I am using a data type in structure fashion.  is there any syntactic sugar to  "copy" data from an existing type, http://paste.lisp.org/display/65859
20:23:23 <RobotGuy> shapr: Just came to see what this is all about.
20:23:43 <shapr> RobotGuy: Want a short intro?
20:23:56 <dons> sclv: binary-trees is my guess.
20:24:06 <sclv> mandelbrot I suppose.
20:24:08 <dons> sclv: and some of the recursive ones are straightforward.
20:24:16 <sclv> fasta requires threading a single randgen through...
20:24:17 <dons> remember we have 4 cores here, so there's a lot of room
20:24:22 <shapr> RobotGuy: Haskell doesn't do anything for Arduinos though :-(
20:24:30 <dons> sclv: split that randomgen amongst the threads?
20:24:32 <Twey> RobotGuy: http://haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
20:24:33 <lambdabot> Title: Introduction - HaskellWiki
20:24:34 <dons> but yeah, let's start with the smalle ones
20:24:37 <RobotGuy> shapr: Sure, if it includes examples.  Anyone using Haskell for robotics?
20:24:40 <dons> parallelise them for 2 cores
20:24:43 <dons> (e..g my laptop)
20:24:43 <Trinithis> waynemokane: for the code: http://www.2shared.com/fadmin/3823946/2e1ff91e/Fungitar.gz
20:24:45 <dino-> (looking at the API docs) ooh, that is neat: zipWith ($) fs xs
20:24:48 <lambdabot> Title: 2shared - file upload
20:25:08 <sclv> dons: it breaks the constraints to split it.. different results.
20:25:16 <shapr> > 1 + 1
20:25:17 <dons> i'd love to be on top of the multicore shootout, ghc 6.10 lands, and real world haskell is released.
20:25:19 <lambdabot>  mueval: Time limit exceeded
20:25:22 <dons> that would be a big end of year party time.
20:25:23 <shapr> wah?
20:25:29 <shapr> > 1 + 1
20:25:30 <waynemokane> Trinithis thanks
20:25:31 <lambdabot>  mueval: Time limit exceeded
20:25:33 <Myoma> 2
20:25:34 <stepcut> blbrown: If I understand what you want, then just do, let newCopy = oldCopy  { fieldName = newValue }
20:25:37 <shapr> Myoma: thanks :-P
20:25:42 <sclv> reverse complement is probably trivial to split across cores though...
20:25:48 <shapr> But seriously, how do I give a #haskell tour with a working lambdabot?
20:25:50 <blbrown> stepcut, that is it
20:25:51 <RobotGuy> 2 ** 3
20:25:56 <dons> the 'recursive' benchmark is one we can do in our sleep.
20:25:56 <dsrogers> stepcut: I think he wants to avoid having a big list of accessors
20:25:58 <Myoma> 8.0
20:25:59 <shapr> > 2 ** 3
20:26:02 <lambdabot>  mueval: Time limit exceeded
20:26:02 <dons> standard recurse to limit strategy.
20:26:03 <dsrogers> oh...
20:26:07 <Trinithis> The code works. I'm just hammering out specification bugs
20:26:13 <RobotGuy> 5!
20:26:21 <Myoma> parse error (possibly incorrect indentation)
20:26:23 <Myoma> :)
20:26:25 <shapr> wah?
20:26:30 <sclv> the recursive one also isn't on the quadcore benchmarks
20:26:33 <RobotGuy> Factorial
20:26:33 <dons> > 1
20:26:36 <shapr> Myoma: impressive!
20:26:36 <lambdabot>  1
20:26:39 <sclv> its a conspiracy i tell you!
20:26:39 <dons> > [1..]
20:26:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:26:43 <dons> > 1* 2
20:26:46 <lambdabot>  2
20:26:50 <shapr> Huh, why won't it add for me?
20:26:55 <shapr> > 1 + 1
20:26:57 <lambdabot>  2
20:26:59 <shapr> whew
20:27:06 <shapr> I thought I was losing my mind!
20:27:16 <stepcut> dsrogers: no, I think just wanted the shortcut for, let newCopy = Record { field1 = (field1 oldCopy) ... fieldn = (fieldn oldCopy) }
20:27:21 <RobotGuy> I'm looking at http://www.haskell.org
20:27:22 <lambdabot> Title: Haskell - HaskellWiki
20:27:24 <shapr> RobotGuy: Ok, so there's this cool language, Haskell... and it's probably unlike most languages you've used before.
20:27:32 <shapr> RobotGuy: Oh good choice!
20:27:38 <shachaf> Huh, mueval doesn't like (**)?
20:27:40 <shachaf> > 2 ^ 3
20:27:43 <lambdabot>  8
20:27:58 <shachaf> Hmm, it timed out in /msg.
20:28:00 <RobotGuy> Is anyone using Haskell for robotics?
20:28:05 <Trinithis> waynemokane: Oh, to help speed things up, Instruction a = StateT InstructionState IO a
20:28:05 <newsham> > product [1..5]
20:28:08 <lambdabot>  mueval: Time limit exceeded
20:28:17 <Trinithis> (as in Instruction.hs)
20:28:19 * stepcut wonders if lambdabot counts as robotics
20:28:36 <newsham> http://www.haskell.org/yale/papers/oxford02/index.html
20:28:36 <lambdabot> Title: Arrows, Robots, and Functional Reactive Programming
20:28:38 <RobotGuy> Ummm, no. :p I mean the real thing. :)
20:28:40 <vininim> I think FPR guys do it
20:29:00 <vininim> or FRP as someone already pointed out
20:29:07 <stepcut> RobotGuy: http://www.youtube.com/watch?v=-zEWS7P91d4
20:29:07 <lambdabot> Title: YouTube - Simple Robot Programmed in Haskell
20:29:09 <sclv> and there's erm, Timber, a language built in/around haskell that's especially for robotics applications.
20:29:09 <shachaf> RobotGuy: Are you related to chessguy, by any chance? :-)
20:29:15 <sclv> dunno how alive it is.
20:29:38 <waynemokane> wow... thanks everyone - it looks like I have a full day of reading type signatures ahead of me
20:29:43 <waynemokane> sadly my day job is Java
20:29:48 <newsham> stepcut: carrot robot.  now need stick robot.
20:29:54 <RobotGuy> shachaf: No.
20:29:56 <Myoma> haha
20:29:59 <Myoma> @remember <waynemokane> wow... thanks everyone - it looks like I have a full day of reading type signatures ahead of me
20:30:00 <lambdabot> It is forever etched in my memory.
20:30:23 <Myoma> waynemokane: hey you have a job programming
20:30:30 <stepcut> RobotGuy: the related blog entry, http://sigfpe.blogspot.com/2007/05/haskell-incarnate.html
20:30:31 <lambdabot> Title: A Neighborhood of Infinity: Haskell Incarnate
20:30:31 <waynemokane> Myoma: yeah
20:30:32 <SamB_XP> Myoma: you aren't supposed to mention the <> when you do that
20:30:32 <Myoma> waynemokane: that can't be too bad?
20:30:51 <SamB_XP> @remember waynemokane wow... thanks everyone - it looks like I have a full day of reading type signatures ahead of me
20:30:51 <lambdabot> Nice!
20:30:55 <shachaf> @forget <waynemokane> wow... thanks everyone - it looks like I have a full day of reading type signatures ahead of me
20:30:55 <lambdabot> Done.
20:30:57 <Myoma> SamB_XP: I'm not bending over backwards to please some program
20:31:01 <SamB_XP> @quote
20:31:01 <lambdabot> dibblego says: I'm glad I googled it before going to see the doctor
20:31:10 <waynemokane> Myoma: no I'm not complaining... I just wish I could spend all my time learning this stuff instead
20:31:11 <waynemokane> it bothers me when I can't get it
20:31:11 <RobotGuy> Looks like I need to create a Haskell bookmark folder.
20:31:13 <vininim> leel
20:31:14 <newsham> hmm.. is sigfpe in the bay area?
20:31:17 <shapr> RobotGuy: Or hang out here!
20:31:19 <sclv> oh man... meteor-contest will parallelize with a strategy in like half a line of code!
20:31:23 <shapr> newsham: I think so.
20:31:25 <RobotGuy> Is Haskell truely compiled or interpreted?
20:31:26 <SamB_XP> Myoma: it's not the program that cares, it's the people of #haskell
20:31:31 <SamB_XP> RobotGuy: no
20:31:37 <newsham> robot: depends on if you're using a compiler or an interpretter
20:31:38 <SamB_XP> RobotGuy: it is compiled AND interpreted
20:31:56 <RobotGuy> SamB_XP: ??
20:31:57 <SamB_XP> (at different times)
20:32:01 <dons> RobotGuy: the main implementation , GHC, has both a bytecode interpreter, and a type erasing native code compiler, with multiple backends.
20:32:24 <SamB_XP> I believe the BCI is also type-erasing
20:32:25 <Myoma> why do people do bytecode interpreting instead of interpreting the code directly?
20:32:25 <dons> it compiles haskell to assembly, in other words :-)
20:32:28 <sclv> There also exist other implementations that compile and others that interpret.
20:32:31 <dons> Myoma: faster.
20:32:41 <SamB_XP> Myoma: well, you are free to try the other way
20:32:59 <dons> you can optimise a small number of cases , rather than trying to abstractly interpret a tree.
20:32:59 <Myoma> I've only ever done things the other way
20:33:07 <RobotGuy> I ask because I would be using it to build control software for my robot, which runs embedded linux.
20:33:09 <dsrogers> I think he was talking about bytecode vs. compiling
20:33:19 <SamB_XP> the only implementation of that type of interpreter I'm positive I've heard of is COMMAND.COM's .BAT handling
20:33:38 <dons> RobotGuy: there's been a fair bit of work in using haskell for control system.s
20:33:38 <dsrogers> RobotGuy: lazy languages can have difficultly with realtime systems.
20:33:48 <dsrogers> dons: has there?
20:33:49 <dons> i imagine you have C code or something currently?
20:33:51 <dsrogers> dons: link me?
20:33:53 <SamB_XP> (I know because I've heard that it re-opens the .BAT file for every single line)
20:33:57 <waynemokane> thanks for being gentle everyone - goodnite!
20:33:58 <dons> dsrogers: yeah, the functional reactive robot guys.
20:34:05 <dons> hudak et al.
20:34:14 <dons> google for controlling realtime robots in haskell
20:34:21 <Myoma> hm
20:34:38 <dons> RobotGuy: so basically, just use haskell as the logic and control glue, that calls into your C libraries for doing the low level gunk.
20:34:39 <shapr> RobotGuy: Ooh, embedded linux on a robot?
20:34:49 <stepcut> SamB_XP: bash interprets things that way
20:34:56 <stepcut> SamB_XP: you can even edit the file will it is being run
20:34:59 <sclv> http://www.tt.luth.se/staff/nordland/TimberCourse/
20:35:01 <lambdabot> Title: Programming in Timber
20:35:02 <RobotGuy> shapr: Yes, Gentoo Embedded to be exact.
20:35:03 <sclv> ^^ timber
20:35:20 <dons> timber's a strict haskell/erlangish thing for hard realtime systems
20:35:22 <shapr> RobotGuy: What sort of hardware?
20:35:24 <dons> so definitely relevant.
20:35:28 <RobotGuy> dons: I want to avoid using C/C++ if I can.
20:35:37 <dons> RobotGuy: so you just need to talk to devices?
20:35:39 <SamB_XP> stepcut: and here I thought command.com was being peculiar!
20:35:49 <RobotGuy> shapr: TinCanTools Hammer http://www.elinux.org/Hammer_Board
20:35:49 <dons> and write all the drivers and logic in a fast, high level lang?
20:36:03 <lambdabot> Title: Hammer Board - eLinux.org
20:36:13 <dons> mm. cool
20:36:22 <RobotGuy> dons: Yes, I need to be able to do I2C, possibly SPI, serial, etc.
20:36:58 <dons> sure. so haskell's certainly fine for diving into low level details (e.g. operating systems and drivers), while allowing you to write stuff at a very high level.
20:37:02 <dons> it wouldn't be a bad choice at all.
20:37:14 <shapr> RobotGuy: Nifty!
20:38:10 <RobotGuy> shapr: In case you want to look: http://www.thedynaplex.org/robotics/rovers/walter and http://www.thedynaplex.info/serendipity for my blog.
20:38:36 <RobotGuy> dons: Hmmmm, OK, I will take a closer look at Haskell.
20:39:29 <shapr> RobotGuy: cool blogs!
20:39:55 <RobotGuy> shapr: Thanks. :)
20:40:28 <mmorrow> > everywhere
20:40:30 <lambdabot>      Overlapping instances for Show
20:40:31 <lambdabot>                                 ((forall ...
20:40:44 <SamB> :t everywhere
20:40:45 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
20:40:48 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
20:40:51 <lambdabot> Terminated
20:40:53 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
20:40:56 <lambdabot> Terminated
20:41:05 <Myoma> > everywhere (+1) [1,2,3]
20:41:07 <lambdabot>      Could not deduce (Num a) from the context (Data a)
20:41:07 <lambdabot>       arising from th...
20:41:20 <Myoma> :t mkT
20:41:22 <lambdabot> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
20:41:26 <mmorrow> ghci> everywhere (mkT (+1)) x
20:41:26 <mmorrow> ((1,(1,((1,1),1))),(1,(1,1)))
20:41:43 <Myoma> > everywhere (mkT (+1)) [1,2,3]
20:41:46 <lambdabot> Terminated
20:41:48 <Myoma> ok
20:41:53 <dons> RobotGuy: i can point you at the haskell 4 robots work , if you're interested.
20:41:55 <Myoma> I think "Terminated" is not the best error message
20:42:07 <mmorrow> yeah
20:42:14 <sclv> Myoma: It means the process was terminated.
20:42:23 <mmorrow> i wonder why
20:42:31 <shapr> RobotGuy: There's a basic operating system written in Haskell.
20:42:58 <dsrogers> > [1..5] >>= \x=[x]
20:42:58 <lambdabot>  Parse error at "=[x]" (column 14)
20:43:01 <Myoma> sclv: It's not useful information
20:43:06 <mmorrow> mauke: pingzing
20:43:09 <Twey> It contains bits of C libraries, though.
20:43:11 <dsrogers> 1..5] >>= \x=x:[]
20:43:15 <dons> RobotGuy: http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
20:43:17 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki, http://tinyurl.com/jsfmb
20:43:21 <dons> e.g. "Lambda in Motion: Controlling Robots With Haskell John Peterson, Paul Hudak, and Conal Elliott In the proceedings of PADL '99.
20:43:24 <dons> "
20:43:25 <dsrogers> > [1..5] >>= \x=x:[]
20:43:25 <lambdabot>  Parse error at "=x:[]" (column 14)
20:43:37 <dsrogers> 1..5] >>= \x->x:[]
20:43:44 <dsrogers> omg!!!!
20:43:53 <Trinithis> > [1..5] >>= \x -> x:[]
20:43:55 <sclv> Myoma: it was terminated for resource reasons.
20:43:56 <lambdabot>  mueval: Time limit exceeded
20:43:58 <Myoma> > [1..5] >>= return
20:44:00 <dsrogers> thanks.
20:44:01 <lambdabot>  mueval: Time limit exceeded
20:44:10 <mmorrow> looks to be mangled
20:44:19 <dsrogers> I don't get what the list monad is supposed to do.
20:44:29 <Myoma> dsrogers:  look at something in do notation
20:44:30 <RobotGuy> Got the link to the FRP.  Interesting and thanks!  Saved the PDF.
20:44:30 <dsrogers> mmorrow: I wrote some TH tests
20:44:32 <mmorrow> the bot has the plague
20:44:33 <sclv> it is supposed to exceed your time limit, duh!
20:44:34 <Trinithis> Do you understand concatMap?
20:44:37 <mmorrow> dsrogers: cool!
20:44:42 <sclv> dsrogers: do you get list comprehensions?
20:44:44 <Trinithis> @dsrogers
20:44:45 <lambdabot> Unknown command, try @list
20:44:49 <shapr> @shapr
20:44:50 <lambdabot> why on earth would I slap ?
20:44:51 <dsrogers> Yeah, I get list comprehensions
20:44:53 <mmorrow> dsrogers: could i see some stuff??
20:44:57 <dsrogers> sure.
20:44:58 <shapr> @shapr shapr
20:44:58 * lambdabot moulds shapr into a delicous cookie, and places it in her oven
20:45:01 <sclv> think of a list comprehension as the list monad--
20:45:01 <Myoma> > do x <- [1..10] ; y <- [1..10] ; if x*y == 15 then return (x,y) else []
20:45:01 <shapr> oof!
20:45:04 <lambdabot>  mueval: Time limit exceeded
20:45:06 <mmorrow> > 1
20:45:06 <Myoma> > do x <- [1..10] ; y <- [1..10] ; if x*y == 15 then return (x,y) else []
20:45:09 <lambdabot>  mueval: Time limit exceeded
20:45:09 <lambdabot>  mueval: Time limit exceeded
20:45:10 <Trinithis> well =<< is the same as concatMap
20:45:10 * shapr goes to sleep
20:45:16 <Myoma> nn shapr
20:45:28 <Trinithis> and =<< is flip >>=
20:45:33 <Myoma> dsrogers, Prelude> do x <- [1..10] ; y <- [1..10] ; if x*y == 15 then return (x,y) else []
20:45:34 <Myoma> [(3,5),(5,3)]
20:45:35 <mmorrow> Cale: pingzing
20:45:54 <Myoma> dsrogers, e <- list means pick e from the list
20:46:23 <Trinithis> Personally I find do notation for lists hard to visualize. I much prefer >>= for them
20:46:23 * RobotGuy wonders if his brain can handle another programming language
20:46:24 <SamB> dons: I'd like to see the plain "haskell 4" work ;-)
20:46:24 <dsrogers> mmorrow: http://code.google.com/p/hoc/source/browse/trunk/hoc/Tests/TestHOCDeclareSelector.hs
20:46:26 <lambdabot> Title: hoc - Google Code, http://tinyurl.com/3t7g8f
20:46:38 <dsrogers> and http://code.google.com/p/hoc/source/browse/trunk/hoc/Tests/TestHOCDeclareSelectorForward.hs
20:46:40 <lambdabot> Title: hoc - Google Code, http://tinyurl.com/5egr97
20:46:40 * mmorrow is giddy as he click the link
20:46:44 <SamB> dons: I think the latest version of Haskell I've heard of is 1.4 or 1.5?
20:46:55 <Myoma> Trinithis: Have you done any logic programming ?
20:47:16 <Trinithis> Very little. I've read some prolog in the past
20:47:27 <Trinithis> Why
20:47:34 <sclv> version of haskell??
20:47:35 <dsrogers> Myoma: in what sense does Monad [] handle "backtracking?"
20:47:52 <Myoma> Trinithis: so consider,  member(X,[1..10]), member(Y,[1..10]), 15 is X*Y vs what I wrote in list monad
20:48:09 <Myoma> dsrogers: What do you mean?
20:48:22 <sclv> dsrogers: if you want the first successful answer, then conceptually it tries each alternative and "backtracks" until it finds one that meets all criteria.
20:48:33 * RobotGuy downloads GHC sources.
20:48:44 <dsrogers> Myoma: something I read in the tutorial
20:48:47 <Myoma> RobotGuy: I think you need GHC to build that
20:48:49 <sclv> RobotGuy: noo! get the binary!
20:48:56 <dsrogers> sclv: can you explain that without using the word "backtracks"
20:48:58 <Myoma> dsrogers: There are two important ways to view it
20:49:01 <Trinithis> Myoma: I get the code. I just found it hard to understand when I was new. You can also use guard instead of the if
20:49:13 <Myoma> dsrogers: The first is declarative and the second operational
20:49:20 <sclv> dsrogers: sure. it tries all combinations at once and then you can pick the first that works.
20:49:22 <RobotGuy> GHC needed to build GHC?  That sounds circular to me.
20:49:38 <sclv> RobotGuy: there are perfectly fine binaries for all platforms you'd want.
20:49:43 <Myoma> dsrogers: declaratively, think of   e <- list   as nondeterministically selecting and e from the list, and it happens to always choose the correct one
20:49:47 <shepheb> what do you build gcc with?
20:49:53 <sclv> GHC is a self-hoisting compiler. we eat our own dogfood.
20:49:53 <Trinithis> c++ ?
20:50:02 <dsrogers> mmorrow: the first file just bootstraps the splice.  It splices in dummy which looks like do { ... stuff ... [|()|]}
20:50:13 <dsrogers> the "stuff" are the tests
20:50:18 <dons> RobotGuy: yeah, same as with GCC.
20:50:28 <dons> you need a C compiler to build the C compiler.
20:50:32 <Myoma> dsrogers: operationally, it's all concatMap -- and concatMap corresponds to a backtracking depth first search
20:50:40 <dons> anyway, ghc's available for most every platform under the sun.
20:50:43 <Myoma> dsrogers: that is because really, [] is a stream of solutions
20:50:57 <Myoma> dsrogers: appending streams is disjunction, and concatMap is conjunction
20:51:04 <dons> RobotGuy: did you say it was a standard distro , with embedded tweaks ,you were using?
20:51:09 <dons> what architecture?
20:51:34 <RobotGuy> The binary is for generic 386. :(
20:51:38 <b\6> can ghc on linux make exes for windows?
20:51:46 <dons> b\6: yeah, of course.
20:51:47 <Trinithis> > concatMap (\x -> concatMap (\y -> if x*y == 15 then (x, y) else []) [1..10]) [1..10]
20:51:50 <lambdabot>  Couldn't match expected type `[b]' against inferred type `(a, a)'
20:51:56 <Myoma> dsrogers: anything which wasn't clear?
20:51:58 <dons> RobotGuy: oh, well that's simple enough.
20:51:59 <jeffz> b\6: yes
20:52:07 <RobotGuy> dons: I am running Gentoo Linux and using Gentoo Embedded on my robot.
20:52:10 <Trinithis> > concatMap (\x -> concatMap (\y -> if x*y == 15 then [(x, y)] else []) [1..10]) [1..10]
20:52:13 <lambdabot>  mueval: Time limit exceeded
20:52:13 <jeffz> b\6: so long as you're using windows ghc on linux, using wine
20:52:13 <Twey> 045307 < dons> b\6: yeah, of course.
20:52:15 <Twey> How?
20:52:17 <dons> RobotGuy: so that uses the gentoo x86 packages?
20:52:27 <dons> Twey: ghc --make Foo.hs
20:52:33 <dsrogers> Myoma: can you provide an example (or link to one) that shows how this is actually evaluated?
20:52:33 <RobotGuy> dons: i686 I think.
20:52:35 <dons> creates an executable, foo.exe
20:52:39 <Twey> That makes an ELF :-\
20:52:40 <idnar> dons: on linux?
20:52:45 <dons> Twey: not on windows.
20:52:47 <Twey> The key was 'on Linux'
20:52:48 <dsrogers> Myoma: I understand your words, but I'm having trouble visualizing it.
20:52:53 <dons> on ELF systems it creates an ELF executable
20:52:58 <Twey> So 'no'
20:52:59 <idnar> dons: he's talking about cross-compiling, essentially
20:53:01 <dons> on a.out, it makes a.out. on MACHO it makes MACHO
20:53:03 <Trinithis> what is ELF?
20:53:05 <b\6> yeah, wish it could retarget.
20:53:11 <idnar> < b\6> can ghc on linux make exes for windows?
20:53:14 <dons> on, you can't target other platforms, no.
20:53:16 <Twey> 045259 < b\6> can ghc on linux make exes for windows?
20:53:22 <Twey> Er
20:53:23 <jeffz> the answer is yes :p
20:53:25 <Twey> Heh
20:53:33 <Twey> Wine doesn't count as Linux, jeffz :)
20:53:37 <Twey> Hmm
20:53:38 <jeffz> Twey: yes it does.
20:53:40 <name_> doesnt ghc just use gcc as a backend
20:53:48 <dons> name_: that's one backend, yeah.
20:53:48 <Twey> Not always, name_
20:54:00 <Twey> But it should be possible to do that and pipe it through mingw32, I guess...
20:54:04 <dons> there's also the bytecode and native backend.
20:54:06 <sclv> right -- but the gcc code is platform dependent.
20:54:11 <jeffz> Twey: it's just another program, no different from anything else.
20:54:13 <RobotGuy> OK, so do I need a GHC cross compiler if I want to build software for my robot?
20:54:13 <Myoma> dsrogers: ok, let's take this example:  do x <- [1..5] ; if even x then [] else [()] ; y <- ["heads","tails"] ; return (x,y)
20:54:19 <name_> gcc can crosscompile though so im sure its possible to set it up
20:54:24 <sclv> because of the mangler, no?
20:54:24 <name_> doesnt sound like it would be fun getting it working though
20:54:25 <name_> haha
20:54:32 <Twey> jeffz: Nope, it's a platform
20:54:36 <Myoma> dsrogers: so declaratively, x is selected from 1..5, and y is selected from heads/tails
20:54:38 <sclv> so I can imagine there's a solution, but it sounds ugly.
20:54:39 <dons> nah, easier to actually get a windows machine.
20:55:00 <Myoma> dsrogers: but if even x then [] else [()] gets in the way, [] means 'fail' and causes backtracking, whereas [()] is succeed once
20:55:07 <sclv> RobotGuy: if your robot has a x86, then an executable targeted at x86 and built on an x86 processor should work fine.
20:55:18 <Myoma> dsrogers: so it filters out any x's which are even
20:55:33 <RobotGuy> sclv: My robot does not have an x86.  It has an ARM9 processor.
20:55:37 <Myoma> dsrogers: so running it gives, [(1,"heads"),(1,"tails"),(3,"heads"),(3,"tails"),(5,"heads"),(5,"tails")]
20:55:49 <Myoma> dsrogers: but now we can think about the same thing operationally
20:55:55 <Myoma> @undo do x <- [1..5] ; if even x then [] else [()] ; y <- ["heads","tails"] ; return (x,y)
20:55:55 <lambdabot> [1 .. 5] >>= \ x -> if even x then [] else [()] >> ["heads", "tails"] >>= \ y -> return (x, y)
20:55:59 <dsrogers> why does [] mean fail and [()] mean succeed once?
20:56:02 <dino-> RobotGuy: Ah, I was confused thinking you had x86 robot too.
20:56:07 <sclv> Oh man... I don't think we have a full arm backend yet.
20:56:13 <Myoma> dsrogers: hopefully looking at it operationally will explain that
20:56:15 <dino-> People have been cross compiling to ARM, yes?
20:56:24 <stepcut> RobotGuy: there is a lot of interest in supporting GHC on the ARM, but full support has not been achieved yet
20:56:33 <Myoma> dsrogers: so now, (>>=) = flip concatMap, and we have: [1 .. 5] >>= \ x -> if even x then [] else [()] >> ["heads", "tails"] >>= \ y -> return (x, y)
20:56:38 <RobotGuy> dino-: No, TinCanTools Hammer (200 MHz Samsung S3C2410A, 32 MB RAM, 16 MB Flash).
20:56:42 <dsrogers> Myoma: I have the source of Monad [] in front of me as well.
20:56:51 <shepheb> ARM support is mostly stuck because bootstrapping GHC onto a new architecture is broken in 6.8
20:56:58 <Trinithis> dsrogers: try this - http://en.wikibooks.org/wiki/Haskell/MonadPlus#guard
20:57:02 <Myoma> dsrogers: so look at just this bit for a second:  if even x then [] else [()] >> ...
20:57:14 <Trinithis> there's a neat picture at the end of the section
20:57:15 <stepcut> RobotGuy: hugs and jhc are reported to work on the ARM, though jhc does not work for very much Haskell code at the moment
20:57:23 <Myoma> Prelude> [] >> "foo"
20:57:23 <Myoma> ""
20:57:23 <Myoma> Prelude> [()] >> "foo"
20:57:23 <Myoma> "foo"
20:57:33 <sclv> and hugs is only interpreted...
20:57:37 <RobotGuy> shepheb: It does not have to run ON the robot, but does need to build software for it.
20:57:44 <Myoma> dsrogers: does that make sense ?
20:58:05 <RobotGuy> stepcut: If I learn Haskell, I want the FULL language and to be able to use it for my robot too.
20:58:14 <stepcut> RobotGuy: no doubt :)
20:58:28 <shepheb> RobotGuy: that's what I mean. GHC doesn't really cross-compile. it could be run in a scratchbox or something; that's how I'm planning to use it on my Nokia N810
20:58:33 <Trinithis> To be honest, you can probably put off learning the list monad for later and just use list comprehensions in the meantime
20:58:39 * RobotGuy does not like limitations where they can be avoided.
20:58:50 <mmorrow> dsrogers: looks interesting. i'm about to get the whole package to look over :)
20:58:55 <sclv> RobotGuy: That's really too bad. It should be there soon, but at the moment, I don't think that its very possible.
20:59:01 <dsrogers> mmorrow: do you have mac os x?
20:59:19 <Twey> > [1, 2, 3] >>= return . (*2)
20:59:22 <lambdabot>  [2,4,6]
20:59:38 <dons> so you need to produce arm binaries from the linux host?
20:59:41 <mmorrow> dsrogers: heh, no.
20:59:42 <sclv> There is, as far as I know, good support for ocaml on ARM at the moment, for a nice, typed, functional, higher-order approach.
20:59:44 <RobotGuy> sclv: I will have to wait and watch then, and maybe add this channel to my autojoin list.
20:59:53 <dons> or say, hugs on the arm host?
20:59:55 <sclv> not as nice as haskell of course :-)
21:00:10 <dons> i've seen nhc used to compile haskell apps on arm devices.
21:00:19 <dons> or we just need to raise arm as a target  platform.
21:00:21 * mmorrow doe$ svn checkout http://hoc.googlecode.com/svn/trunk/ hoc-read-only
21:00:21 <lambdabot> Title: Revision 296: /trunk
21:00:35 <dsrogers> mmorrow: well you won't be able to build it.  Really, I should just build a standalone example.
21:00:38 <stepcut> shepheb: I have an old non-registerised build of ghc 6.4.2 for ARM, btw, http://www.n-heptane.com//nhlab/projects/ghc-arm/
21:00:42 <lambdabot> Title: Index of /nhlab/projects/ghc-arm
21:00:44 <dons> good work, stepcut
21:00:50 <dsrogers> Give me a moment, I'll give you a tgz.
21:00:53 <dons> we should put that out a bit more widely, i suppose.
21:00:57 * Myoma guesses not
21:00:57 <stepcut> shepheb: maybe you can use that to build a more modern ghc?
21:01:04 <sclv> yeah I've heard good things about nhc as a compiler for embedded devices, but a quick google doesn't seem to produce much...
21:01:06 <Trinithis> > [1..5] >>= \x -> when (even x) (return x)
21:01:07 <mmorrow> dsrogers: oh well, i can just read the code, especially the TH bits ;)
21:01:08 <lambdabot>      No instance for (Integral ())
21:01:09 <lambdabot>       arising from a use of `even' at <int...
21:01:17 <stepcut> dons: well, it may not run on any recent ARM systems
21:01:38 <dons> sclv: nhc? haskell.org/nhc98
21:01:40 <Trinithis> > [1..5] >>= \x -> guard (even x) >> return x
21:01:42 <stepcut> dons: I am pretty sure it predates EABI support on maemo, so...
21:01:43 <lambdabot>  mueval: Time limit exceeded
21:01:50 <dons> it's much the same as it's always been, nhc.
21:02:01 <dons> all that fancy bytecode compression and what not.
21:02:11 <stepcut> oh! I forgot all about yhc
21:02:28 <dsrogers> Myoma: sorry, I'm not ignoring you.  I'm still thinking about it.
21:02:42 <shepheb> I'm going to be diving into GHC on ARM in about two weeks; I'm moving to New York in the meantime.
21:02:52 <dsrogers> Myoma: I do understand how to use it, I just need to think asbout it some more to get how it works.
21:03:04 <sclv> hmm... yeah, nhc will probably "just work" on ARM.
21:03:07 <stepcut> shepheb: cool.
21:03:14 <mmorrow> dsrogers: what's the deal with with InterfaceGenerator and InterfaceGenerator2? ie which one should i start with?
21:03:29 <dsrogers> InterfaceGenerator works.
21:03:34 <dsrogers> just hang on though.
21:03:39 <dsrogers> I'll make my example small.
21:03:40 <mmorrow> is 2 replacing it?
21:03:43 <mmorrow> ok, cool
21:03:52 <Myoma> I don''t really good know a good way to explain why these stream operations turn out to be logical and and logical or in a haskell setting
21:03:52 <dsrogers> presumably.  I haven't managed to talk to the author of that bit yet.
21:04:15 <Myoma> I only really got it by writing scheme code
21:04:20 <mmorrow> oh, where's the most interesting place to start reading? (TH-wise)
21:06:14 <dsrogers> Myoma: ok but thanks though.  That helps a lot
21:06:21 <dsrogers> mmorrow: HOC/HOC/*
21:10:11 * RobotGuy likes the sound of Declarative Event-Oriented Programming
21:13:06 <mmorrow> oh, i missed the earlier part about the tgz. sure.
21:13:29 <mmorrow> (unless i already have what would be in it)
21:14:08 <mmorrow> be back in a bit
21:15:58 <dsrogers> mmorrow: ack!  I just got it ready!
21:16:24 <dsrogers> mmorrow: you already have it, I just pared it down to show off the TH tests
21:16:46 <ptolomy> How easy is it to use the type system to specify arrays of a particular length?
21:17:56 * ptolomy was a little bit disturbed today to think that he finds mutable data structures and arrays specifically much easier and safer to deal with in C++ than Haskell.
21:18:47 <dsrogers> mmorrow: http://www.phasevelocity.org/thtest.tgz
21:20:03 <dsrogers> actually anyone who has ever been interested in TH should grab that package.
21:20:16 <dsrogers> ooo, I forgot a license...
21:20:17 <dsrogers> gurrr.
21:21:06 <dsrogers> > [1..5] >>= \x -> x:[]
21:21:09 <lambdabot>  [1,2,3,4,5]
21:21:21 <dsrogers> [1..5] >>= []
21:24:11 <dsrogers> oh I see.  list monad deeply embeds concatMaps.
21:25:51 <seydar> what exactly is Word16?
21:27:22 <seydar> is it a 16 bit word that is treated as an integer?
21:27:47 <rwbarton> > (-20) :: Word16
21:27:50 <lambdabot>  mueval: Time limit exceeded
21:28:04 <newsham> > 1
21:28:05 <rwbarton> I think it's a 16-bit unsigned integer
21:28:07 <lambdabot>  1
21:28:18 <newsham> > (-20) :: Word16
21:28:21 <lambdabot>  mueval: Time limit exceeded
21:28:36 <newsham> > (-20) :: Data.Words.Word16
21:28:38 <lambdabot>      Failed to load interface for `Data.Words':
21:28:38 <lambdabot>       Use -v to see a list of...
21:28:42 <newsham> > (-20) :: Data.Word.Word16
21:28:45 <lambdabot>  mueval: Time limit exceeded
21:28:52 <newsham> but.. why?
21:30:28 <seydar> > (20) :: Word16
21:30:30 <lambdabot>  mueval: Time limit exceeded
21:30:37 <newsham> > 20 :: Int
21:30:38 <seydar> o noes!
21:30:40 <lambdabot>  mueval: Time limit exceeded
21:30:43 <newsham> > 20
21:30:46 <lambdabot>  20
21:31:05 <newsham> ?karma- meuval
21:31:05 <lambdabot> meuval's karma lowered to -1.
21:31:21 <rwbarton> testing in privmsg, it seems like only Int8 works in mueval, the others of {Int,Word}{8,16,32,64} are similarly broken
21:31:30 <rwbarton> > 0 :: Int8
21:31:33 <lambdabot>  0
21:31:38 <dsrogers> Myoma: if you still have patience for me... I see how the concatMaps work.  In what sense is this "backtracking"  I feel like backtracking implies "going backwards" and I don't see how your example does this.
21:33:37 <rwbarton> @tell gwern "> 0 :: Word32" gives "mueval: Time limit exceeded", same for the other fixed size Word/Int types besides Int8
21:33:37 <lambdabot> Consider it noted.
21:35:51 <newsham> john backus argues for functional programming in 1977.  http://www.stanford.edu/class/cs242/readings/backus.pdf
21:35:53 <lambdabot> Title: Can Programming Be Liberated from the von Neumann Style? A Style and Its Algebra ...
21:36:16 <dsrogers> Trinithis: same for your diagram.  List monads create nested loops over lists, but why is that called backtracking?
21:36:31 <dons> newsham: yep, kicked the whole business off, eh?
21:38:04 <koninkje> dsrogers: the list monad represents nondeterminism, backtracking search does the same thing. The "backtracking" in backtracking search is just one operational explanation of how to do nondeterminism on a deterministic machine.
21:38:13 <koninkje> Not sure if that helps the discussion any
21:38:54 <dsrogers> but what is going back?  It's the name that's bugging me now
21:39:10 <dsrogers> oh, I think I see.
21:39:28 <newsham> it tries out values from the list, and if you hit a failed guard, it goes back and tries other values
21:39:37 <newsham> (the guards prune your search tree)
21:39:47 <ptolomy> I need to invent a machine that gives me a small shock whenever I set the output of a compilation to the source file.
21:40:06 <newsham> ouch.
21:40:35 <newsham> my favorite is deleting src when I mean to delete intermediate files (repeat to self: always use a "clean" target in Makefile)
21:40:42 <dsrogers> yes.  Try value of first list with all values of the following lists, if this fails  go back ...
21:40:45 <dsrogers> ok...
21:40:45 <dsrogers> thanks.
21:41:10 <dsrogers> why is this considered non-determinism?  I mean even the order of evaulation is well defined.
21:41:18 <dsrogers> perhaps I'm misunderstanding non-determinism
21:41:31 <newsham> dsrogers: its neat that if you have a search algorithm using List or Maybe monad you can often interchange them to change from "find first" to "find all"
21:41:52 <newsham> think of non-deterministic state machine.  from current state, on input transition to list of next states
21:41:55 <newsham> instead of single next-state.
21:42:01 <newsham> state -> [state]
21:42:12 <koninkje> dsrogers: it's nondeterministic because you have a function foo() and you ask foo() for the answer, but instead of giving one answer it gives many different answers
21:42:59 <dsrogers> how exactly are a list of answers not a single answer: namely the list?
21:43:02 <newsham> [state] -> (state -> [state]) -> [state]
21:43:09 <newsham> dsrogers: perspective?
21:43:17 <koninkje> repeating this ad infinitum you get the canonical search tree that you're "backtracking" up whenever a subtree has no answers at the bottom
21:45:26 <koninkje> dsrogers: it's just a game of how to interpret what's going on. Sure a list ::[a] is just a single value (it must be, we're on a deterministic machine in reality) we can also interpret that list as a nondeterministic vallue of type ::a. Which value it actually is we don't know yet (it's some element of the list) but we treat it as if it's just a single value
21:47:24 <dsrogers> ah
21:47:40 <ptolomy> Are zippers the haskell equivalent of iterators?
21:47:50 <koninkje> dsrogers: it may help to read some of the papers at the bottom of http://cs.jhu.edu/~wren/ . In particular the Oleg paper about the logict library. The Wired paper also has some helpful background information
21:47:51 <lambdabot> Title: wren ng thornton @ johns hopkins
21:48:11 * koninkje assumes you care about the general topic ;)
21:48:34 <Myoma> dsrogers, something slightly different is
21:48:48 <Myoma> data Tree a = Leaf a | Branch (Tree a) (Tree a)
21:49:17 <Myoma> you can imagine dfs (Leaf a) = return a; dfs (Branch left right) = dfs left ++ dfs right
21:50:59 <koninkje> dsrogers: For a paper on the tree version of backtracking search, there's also: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.2682
21:51:02 <lambdabot> Title: Under consideration for publication in J. Functional Programming 1 Modular Lazy  ...
21:52:13 <Myoma> ?go seres haskell logic monad
21:52:17 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows
21:52:17 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki
21:52:46 <dsrogers> so the tree version of backtracking would be when you're looking for some list of results from a tree (or perhaps a result that depends on multiple items)
21:52:55 <Myoma> ?go silvija seres logic
21:52:58 <lambdabot> http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Seres:Silvija.html
21:52:58 <lambdabot> Title: DBLP: Silvija Seres
21:53:04 * stepcut highly recommends the modular lazy search paper
21:53:21 <Myoma> I don't know where it is but there's a really great paper about this by her
21:53:58 <ddarius> @google seres prolog streams
21:54:02 <lambdabot> http://citeseer.ist.psu.edu/318776.html
21:54:02 <lambdabot> Title: Embedding Prolog - CiteSeerX
21:56:12 <haskellian> is it possible to invent new control structures in Haskell?
21:56:19 <Myoma> yes
21:56:39 <shukhov> template haskell?
21:56:57 <haskellian> like I saw an exercise to implement while so i guess it is, however while is pretty impreative no? would it be fighting haskell?
21:57:00 <dsrogers> shukkov: what do you need to know?
21:57:13 <haskellian> he is amnswering me i think
21:57:21 <dsrogers> ah
21:57:24 <shukhov> haskellian: yeah
21:57:35 <haskellian> ty i will look into it
21:57:40 <dsrogers> haskellian: no, not TH
21:57:44 <haskellian> can nit fully compete with lis macros?
21:57:51 <shukhov> I don't know anything about it
21:58:01 <dsrogers> haskell is lazy so all functions can be control structures
21:58:23 <dons> ?src mapM_
21:58:23 <lambdabot> mapM_ f as = sequence_ (map f as)
21:58:28 <dsrogers> essentially everything is equivilient to lisp macros because what lisp macros do for you is give you lazy evaluation
21:58:31 <dons> haskellian: control structure ^
21:58:33 <haskellian> dsrogers: why not, type-safe compile-time meta-programming, with Haskell both as the manipulating language and the language being manipulated.
21:59:01 <dsrogers> haskellian: that is not about control structures.  That is about writing programs that create programs.
21:59:12 <dons> meta programming is a bit different, yeah.
21:59:19 <dons> control structures are something you do inside the language, in haskell
21:59:22 <dons> thanks to laziness
21:59:30 <dsrogers> haskillian: yes you could create control structures with it, but it's overkill.
21:59:36 <hansfbaier> haskellian: think of it as a code generator embedded in the language
21:59:59 <hansfbaier> haskellian: TH code is evaluated at compile time, not at runtime.
22:00:31 <hansfbaier> haskellian: And the result is not a value, but new declarations, functions, expressions etc.
22:00:42 <haskellian> control structures = if and when unless? or is it while and for
22:01:25 <dsrogers> for example: while True f = f while f; while False f = f
22:01:31 <haskellian> how do I import it?
22:01:47 <dsrogers> oops, I messed that up...
22:02:16 <dsrogers> haskellian, you don't just import it.  You need to be using GHC, and pass the flag -fth.  Then there is a special syntax.
22:02:31 <dsrogers> actually several special syntaxes
22:03:01 <dsrogers> the classic Th example is printf, only a typechecked, safe version of printf.
22:03:35 <dsrogers> because you write it as a program that is evaluated by the compiler at compile time, that expands to the proper expression.
22:04:00 <vininim> old news but oh wow xmonad on freerunner.
22:04:33 <dsrogers> if you want just a control structure, you can write it directly in the language
22:07:25 <haskellian> as a data?
22:07:34 <RobotGuy> G'Night all and thanks for the intro
22:07:59 <dsrogers> no.  as normal functions.
22:08:36 <dsrogers> for list f  can be written in haskell.
22:09:04 <Adamant> there's always Liskell if you demand Lisp macros
22:09:41 <dsrogers> ... but the point is you don't need them.
22:11:13 <dsrogers> foreach list f = map f list
22:11:34 <dsrogers> that is the foreach construct
22:13:49 <dsrogers> if-then True f _ = f ; if-then False _ g = g
22:14:02 <dsrogers> those all behave exactly as you'd expect.
22:14:25 <dsrogers> f and g are not evaluated unless the block in it is reached
22:16:35 * dsrogers likes haskell because control structures are not special
22:17:19 <Heffalump> except for ones with special syntax
22:17:33 <dsrogers> that's just sugar though.
22:17:39 <Twey> Like if and case
22:17:45 <dsrogers> again, just sugar.
22:17:51 <Twey> But default sugar.
22:18:42 <dsrogers> if and then still behave like functions though.
22:18:48 <dsrogers> just with a funny syntax.
22:19:26 <ac> how do I hoogle gtk2hs functions? I read a while ago that they're indexed...
22:20:08 <ac> or even more to the point, how do I fix this flickering from drawing with Cairo?
22:20:22 <koninkje> dsrogers: well case isn't quite sugar
22:20:26 <dsrogers> double buffering, I'd guess.
22:20:46 <ac> dsrogers: yeah, but I don't know how that's done with the gtk2hs API
22:21:17 <dsrogers> koninkje: indeed.  case is the unsugar.
22:23:59 <stepcut> let, case, and apply ought to be more than enough for anymore
22:24:44 <dsrogers> stepcut: bah.  back in my day we and S, I and K.
22:24:52 <dibblego> S, K and I ought ...
22:25:55 <dsrogers> http://www.madore.org/~david/programs/unlambda/
22:26:07 <lambdabot> Title: The Unlambda Programming Language
22:29:33 <stepcut> dsrogers: bah! We didn't have 'I' back in my day, we had to make it using S and K
22:31:05 <koninkje> http://barker.linguistics.fas.nyu.edu/Stuff/Iota/
22:32:45 <name__> is it possible to build an infinite list of the results of an IO action?
22:33:19 <ivanm> with arrays, is it possible to map over them in such a way that I can use the index as a parameter to my map function?
22:33:39 <dsrogers> name__: no.
22:33:49 <dsrogers> and IO action is strict.
22:33:58 <dsrogers> it has to be otherwise sequencing would not work.
22:34:14 <ivanm> e.g. something like: (i -> e -> e') -> Array i e -> Array i e' ?
22:34:27 <dsrogers> ivanm: zip [1..] list
22:35:01 <dsrogers> map (\i elm -> ...) (zip [1..] list)
22:35:29 <ivanm> dsrogers: ummm.... no, I wanted an array... not a list
22:35:42 <dsrogers> oh, I missed that.
22:35:52 <ivanm> heh
22:36:27 <dsrogers> name: did you catch my answer?
22:36:37 <name___> nah i missed it
22:36:46 <ivanm> the carray package (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/carray) seems to have something like it, but standard arrays don't ;s
22:36:47 <lambdabot> Title: HackageDB: carray-0.1.2
22:37:13 <dsrogers> name__ : no, an IO action is strict.  It has to be otherwise sequencing would not work.
22:37:19 <name___> ok thanks
22:37:40 <dsrogers> hmm, I think that's right anyway....
22:38:32 <dsrogers> > putStrLn . take 3 =<< return [1..]
22:38:34 <lambdabot>      No instance for (Num Char)
22:38:34 <lambdabot>       arising from the literal `1' at <intera...
22:38:56 <dsrogers> putStrLn . show . take 3 =<< return [1..]
22:39:08 <dsrogers> >putStrLn . show . take 3 =<< return [1..]
22:39:23 <dsrogers> lambdabot, you're too slow
22:39:25 <quicksilver> lambdabot won't execute IO actions for you.
22:39:28 <dsrogers> ah
22:39:41 <quicksilver> but, you were right in spirit but wrong in technicality.
22:39:49 <dsrogers> name__: I'm wrong.
22:39:50 <quicksilver> "return [1..]" would work fine.
22:39:58 <ivanm> the spirit was willing but the words were wrong? :p
22:40:13 <quicksilver> however, a general attempt to build an IO action which returns an infinite list will indeed fail.
22:40:21 <dsrogers> name__: monads tend to make things strict, but there are cases where it is does not.
22:40:34 <quicksilver> The side-effect part - the IO part - is strictly sequenced.
22:40:39 <name___> ok
22:40:49 <quicksilver> so you action can only do "a finite amount of IO" before returning.
22:41:07 <shukhov> quicksilver: so something like f = return [1..] :: IO [Int] won't work?
22:41:08 <quicksilver> and you can't defer soem of the IO for later, which is what name___ seemed to be asking for, in haskell98.
22:41:15 <quicksilver> shukhov: yes, it will.
22:41:20 <quicksilver> shukhov: that will work fine, since it is doing no IO.
22:41:23 <name___> yea i was messing with Data.Unique
22:41:31 <name___> figured it be usefull to have an infinite list of uniques
22:41:34 <name___> would*
22:41:35 <quicksilver> however, unsafeInterleaveIO exists for this reason.
22:41:45 <quicksilver> caution is advised in using it.
22:43:08 <dsrogers> name__ you can still call normal lazy functions in IO.  You just have to be careful.
22:43:13 <dsrogers> <- is always strict.
22:43:30 <dsrogers> so is >>
22:43:37 <dsrogers> but normal functions and return are safe.
22:44:05 <name___> hmm
22:44:14 <name___> theres no way to build a list out of the values without <- though right
22:44:27 <dsrogers> > do { x<- undefined; return []}
22:44:29 <lambdabot>      No instance for (Show (t [a]))
22:44:29 <lambdabot>       arising from a use of `show' at <in...
22:44:52 <dsrogers> name__ you can use let.
22:45:25 <name___> end result would be a list of IO Unique then right?
22:45:32 <dsrogers> do { let x = [1..]; putStrLn.show.take 3 x}
22:45:56 <dsrogers> name__ as long as you were careful never to fully evaluate your list.
22:46:32 <dsrogers> name__ that means don't let your infinite data struction appear on the right if a <-, basically
22:46:49 <dsrogers> or in a IO action directly.
22:47:03 <name___> hmm k
22:47:05 <name___> thanks
22:47:05 <dsrogers> pretty much the only thing you can do are pure functions on it, or return
22:47:20 <dsrogers> you can do IO on it if you limit the results somehow.
22:47:29 <dsrogers> like I did with take above.
22:47:57 <Twey> dsrogers: How strict?
22:48:09 <Twey> If they're wrapped in a function, are they safe?
22:48:10 <Twey> Er
22:48:13 <Twey> Stupid question
22:48:16 <Twey> Carry on
22:48:21 <Twey> Don't mind me
22:48:21 <shukhov> What does ~ do for a function argument?
22:48:33 <dsrogers> makes the match always succeed.
22:48:44 <dsrogers> anything that didn't match is defined as ()
22:48:51 <koninkje> shukhov: it makes the pattern match irrefutable/lazy
22:49:26 <dsrogers> shukhov: what koninkje said is more correct
22:49:49 <shukhov> thanks
22:50:17 <Twey> 065005 < dsrogers> anything that didn't match is defined as ()
22:50:20 <dsrogers> err, I should say anything you didn't match is undefined.
22:50:20 <Twey> Uhhh
22:50:23 <Twey> Yeah.
22:50:24 <Twey> Heh
22:50:26 <koninkje> shukhov: basically it means "assume this will succeed". If later on someone accesses any variables defined in that pattern, then the pattern match is evaluated. If it doesn't work, then wel...
22:50:33 <rrrggghhh> > mortgage
22:50:35 <lambdabot> Terminated
22:50:38 <ajdhs> > let f ~(x,y) = x + y in f (undefined, undefined)
22:50:39 * Twey laughs.
22:50:40 <lambdabot>  mueval: *** Exception: Prelude.undefined
22:50:41 <rrrggghhh> :]
22:51:04 <ajdhs> > let f (Just x) = x in f Nothing
22:51:07 <lambdabot>  mueval: Time limit exceeded
22:51:24 <dsrogers> thanks for the help everyone.
22:51:24 <ajdhs> > let f ~(Just x) = x in f Nothing
22:51:25 <dsrogers> goodnight
22:51:27 <lambdabot>  mueval: Time limit exceeded
22:51:28 <Twey> 'night dsrogers
22:51:35 <ajdhs> let f ~(Just x) = 5 in f Nothing
22:51:40 <koninkje> g'night dsrogers
22:51:51 <ajdhs> > let f ~(Just x) = 5 in f Nothing
22:51:54 <lambdabot>  mueval: Time limit exceeded
22:51:54 <Twey> > let f = \ x -> \ (y+x) -> y in f 2 5
22:51:54 <lambdabot>  Parse error in pattern at "->" (column 24)
22:51:58 <Twey> :<
22:52:55 <shukhov> so something like let f ~(1, a) = 1 would work for everything?
22:53:44 <Twey> Aye, shukhov
22:53:52 <koninkje> shukhov: the only place I've seen it really used is for when people are tying the knot, and they want to ensure that things aren't evaluated until there's actually a value there (otherwise the computation will diverge/fail)
22:54:33 <Twey> > let f ~(1, a) = 1 in f (False, False)
22:54:35 <lambdabot>      No instance for (Num Bool)
22:54:35 <shukhov> ah
22:54:35 <lambdabot>       arising from a use of `f' at <interacti...
22:54:40 <Twey> Hmn
22:54:50 <Twey> Peculiar, wonder why that doesn't work?
22:54:54 <shukhov> > let f ~(1, a) = 1 in f (2, 1)
22:54:56 <lambdabot>  1
22:55:08 <Twey> Oh, I see
22:55:12 <Twey> Types have to match, values don't
22:55:22 <koninkje> yep
22:55:48 <koninkje> in particular, we need to specialize the polymorphic constant 1, and there's no way to do that for type Bool
22:56:46 * Twey nods.
22:57:29 <dons> i'm surprised we've never discussed adding a Num instance for Bool :-)
22:57:41 <dons> someone should upload some wacky instances to hackage.
22:57:49 <bd_> instance Num () where ...
22:57:58 <dons> perl-like scalar/list overloading, and a bunch of wacky Num instances.
22:58:39 <bd_> hmm
22:58:39 * koninkje has written a duck-typing module...
22:58:41 <bd_> > 0 :: ()
22:58:43 <lambdabot>      No instance for (Num ())
22:58:44 <lambdabot>       arising from the literal `0' at <interact...
22:58:48 <koninkje> ...ala Perl
22:58:50 <bd_> bah :(
22:59:05 <dons> koninkje: cool. you could upload it.
22:59:15 <dons> after all, the perl and ruby guys do prelude and FP list modules all the time.
22:59:39 <koninkje> dons: I suppose I could, it was mostly playing around to see if I could make it work
22:59:53 <Twey> Num Bool where a + b = 42; a - b = a + (b * 0.4)
23:00:07 <Twey> Can one even do that?
23:00:10 <dons> sure.
23:00:23 <dons> but you have to also decided what 42 :: Bool is
23:00:27 <Twey> With -XTypeSynonymInstances or whatever it is?
23:00:28 <dons> is it True, False or undefined?
23:00:40 <dons> no, that's just a normal Num Bool instance
23:00:42 <koninkje> I was thinking of writing a Perlish monad to do all the implicit $_, @_ stuff. Uglier than sin, but nice for quick one-liners. The DuckTypes were the first step, never took the second step :)
23:00:42 <dons> no magic needed
23:00:54 <Twey> Oh right
23:00:56 <dons> you could do perl like list/scalar conversions
23:01:00 <Twey> koninkje: ...
23:01:02 <dons> that'd be interesting to see formalised.
23:01:11 <Twey> Why are we making Haskell look like Perl O.O
23:01:25 <Twey> It's meant to go the other way around, guys, the other way...
23:01:26 <dons> boredom?
23:01:41 <dons> what about that post using 'object notation'?
23:01:50 <Twey> Haha, I wrote Maybe in ECMAScript the other day
23:01:52 <koninkje> Right now I have the numeric<->string conversions ala DWIM, the scalar<->array stuff shouldn't be too hard to add
23:01:55 <Twey> 'Object notation'?
23:01:58 <dons> he'd redefined (.) so he could write; xs.map(+1)
23:02:12 <Twey> Glek
23:02:31 <Twey> (.) = flip $?
23:02:35 <Twey> Er, flip ($)
23:03:04 <koninkje> Twey: Perl is exceptionally good for clean shell scripting. At present Haskell is still a bit verbose for that particular task, so why not have a library for Perl-like sugar?
23:03:35 <dons> zactly.
23:03:42 <koninkje> where "clean" means term-rewriting rather than paranoia-inducing string-rewriting
23:03:43 * Twey looks at everyone like they've gone mad.
23:04:07 * koninkje goes for more of the kool aid
23:04:07 <dons> use implicit parameters while we're at it.
23:04:18 <dons> make $_ an implicit parameter, getArgs, and friends.
23:04:26 <dons> so you can use argv anywhere
23:04:48 <dons> redefine >>= so that it also saves the result of the last expression in the $_ variable
23:05:02 <dons> in string form :-)
23:05:09 <dons> mwhaha chaos !
23:06:07 <koninkje> One of the tricks I was working out was not overriding $_ if someone gives a real variable to bind to, e.g. overriding (>>)
23:06:51 <dons> cool.
23:07:19 <koninkje> I suppose I can put up an alpha version of a perlish package while I hack on it
23:07:36 <koninkje> should be fun to complete
23:13:11 <Trinithis> Twey: the same Maybe we discussed on DD?
23:13:32 <sclv> lifted forms by induction for && and || too -- so I can write if (>5 && even && < 25) $ x
23:15:16 <koninkje> dons: do you know if theres a way to override (>>) so that the overriden version is used when desugaring do-blocks?
23:24:32 <mwc> koninkje: rebindable syntax may be what you want. Check the GHC docs
23:24:43 <koninkje> mwc: thanks
23:25:17 <mwc> koninkje: http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
23:25:29 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.8.3, http://tinyurl.com/y4o7nt
23:27:10 <ac> anybody have code that draws pictures with Cairo?
23:29:45 <ac> (without flickering?)
23:31:36 <Trinithis> where's parsec located again?
23:31:46 <Trinithis> (for import)
23:32:31 <Trinithis> :t parser
23:32:33 <lambdabot> Not in scope: `parser'
23:32:33 <Trinithis> :t parse
23:32:35 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> SourceName -> s -> Either ParseError a
23:37:15 <name___> is there any prelude function for "return ()"? seems somewhat common to "ioFunc >> return ()" to toss away result
23:37:46 <Trinithis> no
23:38:12 <Trinithis> with applicative you can do something like $> ()
23:38:13 <Trinithis> I think
23:38:17 <Beelsebob> I suspect no, because any sensible name would take just as much typing as return ()
23:38:18 <Trinithis> :t ($>)
23:38:20 <lambdabot> Not in scope: `$>'
23:38:24 <Trinithis> :t (<$)
23:38:26 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
23:38:35 <ac> ahhah! found the answer in xangqiboard
23:38:54 <Trinithis> This is what you want if its an instance of Applicative: () <$ ioFunc
23:38:57 <ac> would've taken forever to find that in the docs
23:39:06 <name___> cool
23:39:13 <Trinithis> ac?
23:39:33 <Trinithis> oh cairo stuff
23:39:52 <Trinithis> @info (<$)
23:39:52 <lambdabot> (<$)
23:40:03 <Trinithis> @fixity (<$)
23:40:03 <lambdabot> Unknown command, try @list
23:40:53 <Trinithis> Yeah, that should be fine. It's infixl 4
23:41:38 <Trinithis> foo >> bar >> () <$ baz
23:42:43 <Trinithis> of course, you can make your own combinator to make it read better
23:42:58 <Trinithis> ie: foo >> bar >> baz $> ()
23:45:00 <name___> yea, <$ seems fine for most scenarios though ig uess
23:45:41 <rrrggghhh> my utorrent hacking skills save the day
23:45:42 <rrrggghhh> <3
23:45:54 <rrrggghhh> don't throttle traffic
23:46:13 <rrrggghhh> > the future of the MPAA
23:46:13 <lambdabot>  Parse error at "of" (column 12)
23:46:51 <rrrggghhh> he's like a ventriloquist dummy
23:47:18 <newsham> > () <$ readFile "/etc/passwd"
23:47:21 <lambdabot>  mueval: *** Exception: "<IO ()>"
23:48:22 <Trinithis> There GNU Haskell Compiler just to cause confusion with GHC
23:48:33 <Trinithis> should be*
23:48:39 <newsham> gnu haskell compiler
23:48:49 <Trinithis> It's the ghc!
23:50:17 <stepcut> @info void
23:50:18 <lambdabot> void
23:50:25 <stepcut> @type vodi
23:50:26 <lambdabot> Not in scope: `vodi'
23:50:29 <stepcut> @type void
23:50:31 <lambdabot> Not in scope: `void'
23:51:02 <Trinithis> @type ()
23:51:04 <lambdabot> ()
23:51:28 <stepcut> void :: IO a -> IO ()
23:51:28 <stepcut> Discard the return value of an IO action
23:51:43 <stepcut> from, Foreign.Marshal.Error.void
23:51:59 <stepcut> never seen anyone use it though ;)
23:52:07 <Trinithis> Is it m a -> m () or it it actually for IO?
23:52:33 <ac> hmm. I'm neading the time inside the Render monad. How do I use the IO monad inside Render, or should I just pass now through?
23:52:36 <stepcut> it's specifically for IO
23:52:56 <stepcut> though, it shouldn't have to be:
23:52:59 <stepcut> void     :: IO a -> IO ()
23:52:59 <stepcut> void act  = act >> return ()
23:52:59 <stepcut>  
23:53:13 <stepcut> that is the definition from the source code
23:54:43 <newsham> void = (() <$)
23:55:00 <newsham> ?type (() <$)
23:55:02 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
23:55:06 <Trinithis> BAD!
23:55:09 <ac> I want two monads at the same time
23:55:19 <Trinithis> huh?
23:55:36 <Trinithis> Oh.
23:55:42 <newsham> i tried to be a teepee and a wigwam at the same time.
23:55:43 <ac> I just want to use getCurrentTime inside the Render monad
23:55:46 <newsham> my dr. said i was two tents
23:55:54 <Trinithis> :t Render
23:55:56 <lambdabot> Not in scope: data constructor `Render'
23:56:02 <newsham> Reader?
23:56:08 <name___> i thought cairo render was in IO monad?
23:56:42 <ac> name___: "couldn't match type Render t against IO ()"
23:56:49 <name___> guess not haha
23:58:03 <name___> check out monad transformers or feed the time in from "outside"
23:59:01 <ac> I'm feeling the monad transformers would be the morue true to Haskell form route, and passing it in from the outside like I'm doing would be the sane route
