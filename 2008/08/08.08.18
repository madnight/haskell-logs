00:21:13 <adu> YEY
00:21:20 <adu> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/only
00:21:21 <lambdabot> Title: HackageDB: only-0.0.3.0
00:21:32 <lispy> adu: congrats
00:21:46 <adu> my first hackage package :)
00:22:45 * Trinithis gives adu a cake.
00:22:59 * adu eats cake
00:36:03 <hackage> Uploaded to hackage: only 0.0.3.0
00:36:03 <hackage> Uploaded to hackage: open-witness 0.1
00:36:03 <hackage> Uploaded to hackage: witness 0.1
00:45:17 <cjs> Hm. So i need to parse a bunch of command line arguments, and I'm using GetOpt at the moment.
00:46:49 <cjs> Is having the list of options be a [OptDescr (State ParseState ())] reasonable, so that I can then run the state and come out at the end of the list of parsed options and errors in the ParseState?
00:53:26 <dancor> is first f . second g anything else, like f <**##**> g
00:55:07 <ziman> > ((+1) *** (*3)) (1,3)
00:55:09 <lambdabot>  (2,9)
00:55:18 <ivanm> @pl \ f g -> (first f) . (second g)
00:55:18 <lambdabot> (. second) . (.) . first
00:55:26 <ivanm> or is it just (f *** g) ?
00:55:35 <ziman> it's (f *** g)
00:55:35 <ivanm> @type (first f) . (second g)
00:55:37 <lambdabot> forall c (a :: * -> * -> *) b c1 d. (Functor (a (d, b)), Arrow a, SimpleReflect.FromExpr (a b c1), SimpleReflect.FromExpr c, Show d) => a (d, b) (c, c1)
00:55:59 <dobblego> @check \f g -> (first f . second g) == f *** g
00:56:01 <lambdabot>      Occurs check: cannot construct the infinite type: d = (d, b)       Expec...
00:56:27 <ziman> @check \f g x -> (first f . second g) x == (f *** g) x
00:56:29 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>                ...
00:57:37 <ziman> @type first f >>> second g
00:57:38 <lambdabot> forall (a :: * -> * -> *) b c d c1. (SimpleReflect.FromExpr (a d c1), Arrow a, SimpleReflect.FromExpr (a b c)) => a (b, d) (c, c1)
01:07:44 <cjs> Yes, the State monad appears to be a reasonable way to go.
01:41:02 <mmorrow> wow, things are getting raucous in here.
01:44:23 <b\6> in an api for some protocol, what should i do if the other end sends something crazy? i'd rather not make all the various parse methods Maybes or Eithers. it's like a condition so bad it's not worth checking for.
01:44:44 <Wild_Cat> b\6: you can use errors.
01:45:15 <b\6> what, "error"?
01:46:00 <Wild_Cat> b\6: error "Aargh"
01:46:14 <Wild_Cat> > error "Your data sucks!"
01:46:15 <lambdabot>  Exception: Your data sucks!
01:46:35 <b\6> hmm. is that catchable at all?
01:47:50 <Wild_Cat> I expect it is. It'd be a pretty useless exception handling mechanism otherwise.
01:48:36 <Wild_Cat> catch, in the IO monad, does that.
01:48:39 <Wild_Cat> :t catch
01:48:41 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:49:35 <Wild_Cat> :i catch
01:50:18 <b\6> ok. i guess it's a good fit, then.
01:50:20 <b\6> thanks.
01:53:46 <cjs> b\6: You can make them all Either String a and use the error monad, just extracting the error or valid message at the top.
01:54:05 <cjs> And there's a throw for it, too.
01:54:07 <quicksilver> "error" is not an exception handling mechanism.
01:54:12 <quicksilver> You should never catch "error"s.
01:54:31 <quicksilver> unless your use case is "I'm a haskell server and I want to run other people's buggy code"
01:54:38 <cjs> Yes, "error" generally means, "crash the program, because I can't handle this."
01:54:41 <quicksilver> which is a bit dangerous but would be a good reason to try to catch errors.
01:55:13 <quicksilver> "error" is supposed to mean : this should never happen; if it did, there is a programmer bug.
01:55:20 <b\6> oh, hmm.
01:55:51 <Wild_Cat> quicksilver: oh?
01:56:48 <yitz> b\6: if you don't want your program to crash when this happens, and if this isn't something that is caused by some external physical event, then you probably do want a Maybe or Either at the top level. You can arrange things so that it's only there and doesn't propagate throughout.
01:56:57 <quicksilver> It's a subjective point, really. No dark angel is going to descend on you if you use 'error' wrongly.
01:57:03 <quicksilver> However, it's still wrong :P
01:57:16 <quicksilver> Use Either, Maybe, ErrorT, MaybeT or thrownDyn.
01:57:26 <quicksilver> throwDyn.
01:57:30 * Wild_Cat takes note
01:58:08 <yitz> quicksilver: isn't throwDyn an IO exception?
01:58:26 <igel> what's MaybeT?
01:58:34 <igel> :t throwDyn
01:58:38 <quicksilver> yitz: yes, but it's better than 'error'
01:58:50 <b\6> yitz: that sounds neat, but i'm not seeing how. doesn't each function have to examine the Either from parsec?
01:59:06 <quicksilver> it's more modular because you can catch only the exceptions that you generate
01:59:30 <quicksilver> I.e. catch only the exceptions you which represent problems you know how to deal with.
01:59:43 <yitz> b\6: if you're using parsec, then you need to deal with the Either at the place where you invoke parsec.
01:59:48 <quicksilver> It's seldom sensible to catch an unknown exception because presumably you aren't in a position to rectify / report the problem correctly.
02:00:53 <djdon> Hi, I'm trying to learn haskell and having some issues understanding function types, could anyone tell me why this doesn't work?  It gives me 'type error in guarded expression'. Thanks
02:00:53 <djdon> getFirst :: [a] -> Int -> [a] -> [a]
02:00:53 <djdon> getFirst (x:xs) n r | n>0 = getFirst xs n-1 (x:r)
02:00:53 <djdon>                                   | n<=0 = r;
02:01:08 <yitz> quicksilver: true. And I try to avoid throwing them also, unless they are inherently IO-related. Just like I avoid IO for the rest of my program except where needed.
02:01:16 <b\6> yitz: ok. if parsec fails, there's nothing really good to do but try again later. not sure how to code that.
02:02:00 <yitz> b\6: you mean tell the user to try again later, or your program waits and tries again later?
02:02:08 <cjs> b\6: Whats the general strategy for your protocol here? What's the program doing?
02:02:51 <igel> djdon: does it work, if you replace n-1 by (n-1)?
02:02:51 <b\6> cjs: like using ftp to upload or download and the server does something completely in violation of protocol.
02:03:01 <b\6> there's no way for the program to do anything useful after that.
02:03:36 <cjs> Sometimes there is. For example, if you are an FTP server, and get an invalid command, you return an error to the client and carry on.
02:04:04 <djdon> igel: yes it does, thanks, do you know why?
02:04:06 <b\6> yeah, but if you're a client and get something bogus, you don't know what state you're in anymore.
02:04:28 <BeelsebobWork> @quickcheck (\x -> (>>= maybe mzero return $ x) == (catMaybes <$> x))
02:04:29 <lambdabot> Unknown command, try @list
02:04:33 <jeffz> @src (-)
02:04:34 <lambdabot> x - y = x + negate y
02:04:45 <igel> djdon: well it's quite typical: n has type Int, - has type Int -> Int -> Int and 1 has type Int
02:05:12 <BeelsebobWork> @scheck (\x -> (>>= maybe mzero return $ x) == (catMaybes <$> x))
02:05:12 <lambdabot>     Failed to load interface for `SmallCheck':
02:05:12 <lambdabot>       Use -v to see a list of ...
02:05:18 <BeelsebobWork> bah
02:05:48 <BeelsebobWork> @check (\x -> (>>= maybe mzero return $ x) == (catMaybes <$> x))
02:05:48 <igel> djdon: the compiler thinks n-1 is three parameterrs^^
02:05:49 <lambdabot>      The operator `>>=' [infixl 1] of a section         must have lower prece...
02:06:01 <BeelsebobWork> @check (\x -> ((>>= maybe mzero return) $ x) == (catMaybes <$> x))
02:06:02 <lambdabot>  Couldn't match expected type `[Maybe a]'
02:07:09 <igel> djdon: the same thing happens when invoking some_function x : xs vs. some_function (x:xs)
02:07:35 <b\6> yitz: guess i'm confused about how to code the function that uses parsec if i don't want it to return Either. like success or ...? i'm not sure what it would do if it got a Left from parsec.
02:07:41 <yitz> b\6: main = do { rawResult <- getInput; when (isLeft rawResult) complainAndExit; let Right result = rawResult; furtherProcessing result}
02:08:14 <djdon> igel: ok, i think i get what you mean.  Thanks for your help
02:08:24 <igel> no problem :)
02:09:00 <igel> it takes quite some time to understand all these type errors :)
02:10:16 <quicksilver> yitz: yuck.
02:10:22 <quicksilver> yitz: when isLeft and let Right?
02:10:33 <quicksilver> why not case of Left e .... Right result ....
02:10:52 <cjs> I like the case better myself.
02:10:55 <yitz> quicksilver: you could do that too, I don't like it as much.
02:11:19 <igel> but a forced pattern match is quite vulnerable when changing code
02:11:30 <igel> in general you always want to match all possible patterns
02:11:32 <jeffz> b\6: why wouldn't you want it to return Either?  Left is when the parser fails due to non-conformant input, Right is success
02:11:40 <yitz> I see the complainAndExit as an out-of-band extra step in the IO pipeline.
02:11:59 <quicksilver> the case makes it clear there are precisely two branches
02:12:02 <quicksilver> which are exclusive.
02:12:10 <quicksilver> when isLeft and later let Right obfuscates that
02:12:41 <igel> if you don't like case, you can also use "maybe complainAndExit furtherProcessing rawResult"
02:13:08 <b\6> jeffz: i like Either, it's just that i don't want 20 functions to have to examine the Either individually.
02:13:08 <yitz> quicksilver: which is exactly what I want to avoid emphasizing. There are not two branches. There's one branch. Then, as a footnote, something might go wrong at some point which I deal with parenthetically, with as little noise as possible. My own style, yours is fine too of course.
02:13:36 <quicksilver> then I would use the correct monad
02:13:39 <quicksilver> result <- getInput
02:13:59 <quicksilver> ^^ in the ErrorT WhateverWeWereBefore
02:14:30 <jeffz> b\6: my uses of parsec only does a case of the Either once, I can't see how you'd be doing it 20 times
02:14:50 <yitz> quicksilver: absolutely. problem is, ghc doesn't fully support ErrorT IO, unfortunately. So for the time being I avoid it.
02:15:56 <cjs> yitz: Really? In what way is it not fully supported?
02:16:35 <cjs> b\6: The whole point of the error monad is that very few functions analyze the error individually.
02:16:42 <cjs> s/error/Either/
02:16:43 <b\6> jeffz: my confusion is really what to do in an api when something goes terribly wrong. e.g. they tell the ftp client to change directories and ftp server says QUACK.
02:16:44 <yitz> cjs: for example, if you want to mix this with IO exception - and for production code you
02:16:54 <yitz> you'll always want to -
02:17:15 <yitz> then you start running into problems :/
02:18:34 <jeffz> b\6, quack could be a valid response if its formed correctly, which you'd just pass to the user, if the response is invalid then you might as well give up
02:18:52 <b\6> please elaborate on give up. throw an exception?
02:20:02 <jeffz> b\6: if the response is invalid then I'd use Left
02:20:52 <quicksilver> I don't really agree with yitz but there is more than one approach certainly.
02:21:17 <mmorrow> b\6: so what is your planned action when the input that you get from i don't know where fails to parse? it seems to me that if you know *what* you plan to do, then finding *how* to do it'll be easy.
02:22:21 <b\6> dunno. if it were java, i think i'd throw an unchecked exception. it's a horrible error not worth catching except to retry or restart from wherever you left off.
02:22:43 <mmorrow> errr, what is the particular situation?
02:22:50 <mmorrow> reading user input?
02:23:11 <b\6> client api for client/server stuff like ftp. server sends something crazy.
02:24:00 <mmorrow> ah, ok. so in the event that that happens, what do you plan to do (not in terms of code)?
02:24:03 <mmorrow> ignore it?
02:24:13 <mmorrow> disconnect?
02:24:27 <mmorrow> warn the user?
02:24:28 <b\6> yeah, probably. report the error, close handles, etc.
02:25:09 <mmorrow> ok, so maybe use something like  bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:26:19 <mmorrow> bracket (openFile ReadWriteMode "adf.txt") (\handle -> hGetLine h >>= print) (\handle -> hClose handle)
02:26:20 <b\6> i remember bracket, but isn't it just for ensuring that you close/return whatever resources you allocated/opened?
02:26:55 <cjs> So when I'm in a StateT s m (), how do I call a function of type State s ()?
02:27:05 <cjs> lift2 it?
02:27:09 <quicksilver> cjs: would be useful to have a general combinator for it.
02:27:16 <quicksilver> some people call it 'hoist state'
02:27:18 <mmorrow> yeah, so in the event that "oh crap, the server is friggin crazy!", you can throw an exception, which bracket will catch, and nicely free your resources
02:27:18 <cjs> Ah, we don't have one?
02:27:20 <quicksilver> no.
02:27:31 <mmorrow> or use     catch and finally
02:27:35 <cjs> That explains why I wrote a non-generic one the other day.
02:27:46 <quicksilver> @pl do { s <- get; let s' = runState act s; put s'}
02:27:47 <lambdabot> (line 1, column 4):
02:27:47 <lambdabot> unexpected "{"
02:27:47 <lambdabot> expecting variable, "(", operator or end of input
02:27:53 <quicksilver> @undo do { s <- get; let s' = runState act s; put s'}
02:27:54 <lambdabot>  Parse error at "}" (column 47)
02:27:58 <quicksilver> :(
02:28:15 <b\6> mmorrow: ok. how to throw the exception? people in the neighborhood were not liking error for this case.
02:28:22 <quicksilver> oh, it's easier than that isn't it.
02:28:26 <quicksilver> :t execState
02:28:27 <lambdabot> forall s a. State s a -> s -> s
02:28:34 <quicksilver> cjs: modify (execState act)
02:28:41 <quicksilver> not that hard after all :)
02:28:48 <mmorrow> getAHandle >>= \h -> catch (handleRequest h) (\e -> logErr e) `finally` (hClose h)
02:28:53 <quicksilver> :t \act -> modify (execState act)
02:28:54 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => State s a -> m ()
02:29:11 <mmorrow> b\6: i'll paste an example
02:29:15 <b\6> thanks.
02:32:35 <b\6> happs-smtp SMTP2.hs contains "lkjklasj".
02:32:38 <b\6> pretty nice.
02:37:20 <swiert> oq
02:46:50 <mmorrow> b\6: ok, http://hpaste.org/9731#a1
02:47:05 <lambdapants> greetings
02:47:38 <mmorrow> so the second paste throws a dynamic exception when it wants to bail (in this case, just a () :: () )
02:48:26 <lambdapants> question! How would one turn a ByteString from Data.ByteString.Lazy into a the normal strict variant eg Data.Bytestring.ByteString
02:48:52 <mmorrow> b\6: err, actually it's not necessary to close the handle in the serve function, since it'll always get close in the second arg to catch in the go function
02:49:08 <mmorrow> but i guess it doesn't hurt ;)
02:50:14 <b\6> mmorrow: thanks very much.
02:50:15 <lambdapants> I have my own answer: "toChunks".
02:50:23 <mmorrow> b\6: no prob
02:50:53 <mmorrow> lambdapants: exactly
03:00:48 <eu-prleu-peupeu> good morning, people from planet haskell
03:05:16 <Botje> TAKE US TO YOUR LAMBDA
03:05:53 <visof> how can i check if that number include in the Fibonacci sequence or not?
03:06:06 <visof> checkF x = x == fib x ??
03:06:43 <b\6> visof: if you have a fibs stream, just check that x `elem` fibs.
03:06:46 <Botje> do you have a list of fib numbers?
03:06:59 <visof> no
03:07:44 <visof> the fib input is  the index of the number and the output the number of this index
03:07:44 <Botje> oh dear :)
03:08:10 <visof> how can i have list of fib numbers ?
03:09:09 <ruddel> little bot
03:09:49 <Botje> checkF x = go 1 where go k = let fibk = fib k in case fibK `compare` x of { LT -> go (k+1); EQ -> True; GT -> False }
03:09:52 <BeelsebobWork> visof: there's a variety of ways to produces them, why not think about what the first couple of fibonacci numbers are, and how to produce one more each time
03:10:03 <Botje> but that's a pretty slow way
03:10:21 <Botje> if you had a list of fibs you could do x `elem` takeWhile (<= x) fibs
03:10:51 <quicksilver> or x == last (takeWhile (<= x))
03:10:56 <quicksilver> which saves traversing twice :)
03:11:02 <quicksilver> well, sort of.
03:11:06 <Botje> > last []
03:11:07 <quicksilver> it saves some comparisons, at least.
03:11:08 <BeelsebobWork> > let fibs n m = n : fibs m (n+m); checkF x = x `elem` (takeWhile (<= x) fibs 1 1) in checkF 5
03:11:09 <lambdabot>  Exception: Prelude.last: empty list
03:11:09 <lambdabot>  Couldn't match expected type `[a]'
03:11:26 <BeelsebobWork> > let fibs n m = n : fibs m (n+m); checkF x = x `elem` (takeWhile (<= x) (fibs 1 1)) in checkF 5
03:11:28 <lambdabot>  True
03:11:33 <BeelsebobWork> > let fibs n m = n : fibs m (n+m); checkF x = x `elem` (takeWhile (<= x) (fibs 1 1)) in checkF 6
03:11:35 <lambdabot>  False
03:13:00 <ziman> > let fibs n m = n : fibs m (n+m); checkF x = x `elem` fibs 1 1 in checkF 5
03:13:02 <lambdabot>  True
03:13:16 <BeelsebobWork> ziman: that won't terminate if it's not there
03:13:24 <ziman> sure ;)
03:13:36 <Botje> pffrt
03:13:45 <Botje> just add an extra halt check :P
03:13:52 <BeelsebobWork> haha
03:14:09 <BeelsebobWork> that's mean :P
03:14:39 <Botje> ghc 11.3 will have it anyway
03:14:45 <Botje> might as well be forward compatible :p
03:15:33 <BeelsebobWork> *giggle*
03:15:59 <BeelsebobWork> > halts computeIfPEqualsNP
03:16:01 <lambdabot>   Not in scope: `computeIfPEqualsNP'
03:16:07 <BeelsebobWork> :(
03:16:26 <ziman> hmm? :)
03:16:32 <ziman> > halts (1+2)
03:16:34 <lambdabot>   Not in scope: `halts'
03:16:35 <Axman6> >checkF f = willHalt f
03:16:52 <ziman> why did it complain about computeIfPEqualsNP first?
03:21:00 <BeelsebobWork> ziman: just got entered in the table that way round
03:21:28 <visof> > let fibs n m range = [ x | x <- (n : fibs m (n+m)) , x <= range] in fibs 1 1 10
03:21:30 <lambdabot>  Couldn't match expected type `[t]'
03:21:53 <visof> isn't (n : fibs m (n+m)) finite list?
03:22:28 <visof> infinte
03:22:36 <visof> infinite
03:22:51 <visof> why doesn't work ?
03:23:15 <Deewiant> visof: you only gave two arguments to fibs, it wants 3
03:23:32 <Deewiant> probably you meant fibs m (n+m) range
03:24:06 <visof> > let fibs n m range = [ x | x <- (n : fibs m (n+m) range ) , x <= range] in fibs 1 1 10
03:24:13 <lambdabot>  [1,1,2,3,5,8Exception: Time limit exceeded
03:24:17 <Deewiant> > let fibs n m range = filter (<= range) (n : fibs m (n+m)) in fibs 1 1 10
03:24:19 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a -> t'
03:24:23 <Deewiant> > let fibs n m range = filter (<= range) (n : fibs m (n+m) range) in fibs 1 1 10
03:24:29 <lambdabot>  [1,1,2,3,5,8Exception: Time limit exceeded
03:24:52 <Deewiant> hmm, as I suspected, it gives the inferred type if not in a list comprehension, odd
03:25:39 <Deewiant> > let fibs n m range = if n > range then [] else n : filter (<= range) (fibs m (n+m) range) in fibs 1 1 10
03:25:41 <lambdabot>  [1,1,2,3,5,8]
03:25:56 <Deewiant> hmm
03:26:03 <Deewiant> > let fibs n m range = if n > range then [] else n : fibs m (n+m) range in fibs 1 1 10
03:26:05 <lambdabot>  [1,1,2,3,5,8]
03:27:32 <dancor> recursive du wrapper: IO [a] loses me laziness? :(   http://hpaste.org/9732
03:30:36 <quicksilver> dancor: Yes.
03:30:51 <quicksilver> dancor: IO [a] means : "This is an IO action which, when performed, gives a list of as"
03:31:03 <quicksilver> dancor: there is no provision in that type to 'partially perform' the action to get part of a list.
03:31:28 <quicksilver> unsafeInterleaveIO gives you a way to cheat if you're happy to descend into a mire of programs with no semantics.
03:32:41 <Deewiant> @remember quicksilver unsafeInterleaveIO gives you a way to cheat if you're happy to descend into a mire of programs with no semantics.
03:32:42 <lambdabot> Done.
03:33:15 <dancor> quicksilver: what do you think is the best way to restructure things to get laziness back
03:34:01 <Deewiant> unsafeInterleaveIO isn't /that/ bad
03:34:02 <dancor> i could print as i go but that seems to prevent cool future stuff if i want to use the result instead of just printing it
03:34:53 <quicksilver> dancor: I didn't really read your paste in full.
03:34:58 <quicksilver> just enough to check that that ws the problem.
03:35:25 <quicksilver> Generically, you can reverse the flow control to get an enumerator
03:35:47 <quicksilver> or you have a data type which is like a list with IO to be done at each link
03:36:12 <quicksilver> data IOList a = Empty | IOValue a (IO (IOList a))
03:36:33 <dancor> ok
03:36:36 <quicksilver> ...which is what the interleave gives you, in effect, but this version makes the types precise and thus forces you to be in IO each time you want to get the next bit.
03:49:41 <ndmitchell> hi dcoutts - cabal issues!
03:49:54 <dcoutts> @arr!
03:49:55 <lambdabot> Yo ho ho, and a bottle of rum!
03:50:03 <ndmitchell> I get: Unable to rename "/usr/local/pkg/ghc-6.6.1/lib/ghc-6.6.1/package.conf" to "/usr/local/pkg/ghc-6.6.1/lib/ghc-6.6.1/package.conf.old"
03:50:14 <ndmitchell> but I had done ./Setup configure --prefix=/grp/haskell
03:50:19 <ndmitchell> did i miss some magic?
03:50:30 <Botje> permissions?
03:50:35 <Botje> oh
03:50:36 <Botje> nm :)
03:51:05 <dcoutts> ndmitchell: yeah, presumably you're not root
03:51:16 <dcoutts> but you're doing a --global install
03:51:44 <ndmitchell> dcoutts, so what magic is required?
03:51:48 <ndmitchell>  --local ?
03:52:36 <dcoutts> ndmitchell: --user
03:52:38 <ndmitchell> I certainly haven't passed --global, I do: ./Setup configure --with-compiler=ghc-6.6.1 --with-hc-pkg=ghc-pkg-6.6.1 --prefix=/grp/haskell --local
03:52:51 <dcoutts> ndmitchell: it's always been the default for ./Setup
03:53:23 <dcoutts> ndmitchell: we made a new default for cabal-install because doing global installs by default and failing is annoying
03:53:28 <ndmitchell> dcoutts, cheers :)
03:54:29 <ndmitchell> GHC 6.6 on York is broken with the time library, so I'm try to rehabilitate 6.6.1
04:00:11 <ToRA> hey, is it possible to create a view of an IArray between 2 indices?
04:02:43 <ToRA> e.g. view (2,4) "hello" == "llo"
04:06:40 <quicksilver> ToRA: There is no built-in thing for it
04:06:46 <quicksilver> ToRA: I have often thought it was an obvious hole.
04:06:59 <quicksilver> ToRA: and rectangular subarrays of 2D arrays.
04:07:01 <visof> is there a function to convert number to string other than show ?
04:07:08 <quicksilver> and stride-based subarrays.
04:07:18 <quicksilver> visof: there are a few. What are you hoping for?
04:07:26 <quicksilver> showEFloat, showFFloat, showGFloat spring to mind.
04:07:39 <ToRA> quicksilver: nod, just wanted to make sure i wasn't missing something esoteric provided by Data.Traversable/Foldable
04:10:58 <Botje> arraySlice bds arr = listArray bds $ map (arr!) $ range bds
04:11:09 <Botje> there you go :p
04:11:33 <quicksilver> Botje: yes, but the idea woudl be not to copy anything :)
04:11:39 <quicksilver> I assume.
04:11:48 <Botje> oh
04:12:20 <quicksilver> since IArray is a class, you can actually do this.
04:12:28 <Botje> could make a new IARray instance
04:12:31 <quicksilver> you can write your own IArray instance, right.
04:12:39 <quicksilver> it seems a shame it isn't in the satandard lib
04:12:46 <mm_freak> someone on comp.lang.functional talked about an airplane crash, that has wiped most of the community of some functional languageâ€¦  does anyone know more about this?  is this true?
04:13:39 <Botje> Microsoft has ensured simonPJ and simonMarlow are never on the same plane.
04:14:18 <ivanm> wow... Microsoft even controls the airline ticketing systems? :o
04:14:33 <Botje> what OS do you guess those run on ? :)
04:14:44 <ivanm> what happens if both simons purposefully try to get adjoining seats on the same flight? BSOD?
04:14:44 <ivanm> ;-)
04:14:58 <ivanm> Botje: even worse if that's the OS the planes run on :s
04:15:07 <Botje> nah
04:15:24 <Botje> airplane control systems are redundantly and implemented by three different companies
04:16:00 <ivanm> with three different OSs?
04:16:29 <ivanm> so, if we consider what MS calls "cross-platform", then it's Windows 2000, XP and Vista? :p
04:16:32 <Botje> wouldn't surprise me
04:16:35 <Botje> hehe
04:16:39 <Botje> let's hope it not vista
04:16:48 <mm_freak> hehe
04:16:56 <Botje> although it _WOULD_ explain the rise of plane crashes
04:18:02 <ivanm> oh, so it's not because QANTAS has started outsourcing aircraft maintenance to Singapore, etc.? :o
04:18:37 <Botje> hey, airplane companies need to live too :)
04:19:14 <ivanm> yeah, Dixon already sold off all the islands, etc. that QANTAS used to own...
04:19:23 <jeffz`> Botje: those always seem to result from pilot error or lack of training
04:19:32 <ivanm> jeffz`: or faulty maintenance
04:19:50 <ivanm> which I'd think is getting to be a much larger problem, especially for larger aircraft
04:19:58 <ivanm> (old aeroplanes don't help either)
04:20:31 <jeffz`> mm_freak: it was a joke about Mondrian I think
04:21:34 <jeffz`> mm_freak: the full quote is: I often joke that the worldâ€™s population of Haskell programmers fits in a 747, and when that crashed nobody will notice. However, the worldâ€™s population of Mondrian programmers fits in a Cessna and when that would crash nobody would really notice.
04:22:04 <Botje> there's 440 people on this channel
04:22:12 <Botje> how much can fit in a 747?
04:22:14 <jeffz`> mm_freak: http://www.willamette.edu/~fruehr/talks/webcs/MeijerICFP06.pdf
04:22:15 <lambdabot> Title: Confessions Of A Used Programming Language Salesman
04:22:21 <ivanm> so we'd be a bit squashed on the plane, *shrug*
04:22:21 <ivanm> :p
04:22:27 <jeffz`> Botje: depends on how it's fitted out
04:22:46 * Botje starts the breeding program
04:22:53 <mm_freak> jeffz`: ok
04:22:55 <Botje> let's go for an airbus A380 :)
04:23:07 * Axman6 has flown an A380
04:23:12 <mm_freak> jeffz`: i think that guy isn't joking, but rather he simply doesn't know it's a joke
04:23:15 <Axman6> ... on X-plane :(
04:23:24 <Axman6> lots of fun though ;)
04:23:28 <jeffz`> mm_freak: he is joking, it's Eric Meijer
04:23:37 <Botje> did you crash it into 1 microsoft way? :)
04:23:51 <mm_freak> jeffz`: i mean that guy on usenet
04:23:51 <Axman6> i crashed it into a few airports...
04:23:54 <Axman6> landing sucks
04:24:01 <jeffz`> mm_freak: ah yes, it's easy to take out of context
04:24:09 <Axman6> the An-225 is pretty easy to land though
04:24:11 <Botje> heheh
04:24:15 <Axman6> big and slow
04:24:51 <Axman6> and F-22 raptors are _really_ hard to fly
04:31:09 <haskellian> I want to thank #haskell and the whole haskellcommunity for the help and for this awesome language¨
04:40:28 <guenni> hi, I just compiled an XML processing app and ran it against a large file, not entirely unexpected with an "out of memory" error. What can I do about that?
04:40:47 <Zao> Strictify something?
04:41:13 <Zao> Maybe run it on a file that doesn't blow up and look at profiling output?
04:41:26 <guenni> ok
04:43:23 <guenni> Zao: about the profiling, how do I do that?
04:43:40 * Zao defers to people who actually know something.
04:43:49 <guenni> lol
04:44:17 <haskellian> ghc chapter 6
04:44:30 <haskellian> you compile with -prof
04:44:31 <guenni> thx
04:44:51 <quicksilver> you can get some limited memory stats without recompiling.
04:47:56 <yitz> Zao: which xml library are you using?
04:48:27 <Zao> yitz: None, it's guenni that's having trouble.
04:48:45 <yitz> oh,oops, sorry
04:50:24 <yitz> anyway, one of them - hxt I believe - recently added a lazy parsing option, and the other - possible haxml - still has only strict parsing so always reads the entire file into memory.
04:50:44 <yitz> oh, it was guenni and he already left. too bad. this is probably his problem.
04:50:48 <yitz> or her
04:50:56 <guenni> his
04:51:07 <guenni> and I had to reboot
04:51:14 <yitz> welcome back guenni :)
04:51:24 <yitz> did you see what i said
04:51:26 <guenni> thanks
04:51:40 <guenni> I'll have to look it up in the logs
04:52:02 <yitz> anyway, one of them - hxt I believe - recently added a lazy parsing option, and the other - possible haxml - still has only strict parsing so always reads the entire file into memory.
04:52:51 <haskellian> is there a way that I can tell Haskell not to use more than X RAM?
04:52:57 <quicksilver> yes.
04:53:04 <haskellian> i have chnaged to bytestrings and when I parse it is all quick
04:53:05 <quicksilver> well, there is a way you can tell GHC.
04:53:20 <haskellian> but then I serialize it just takes laods of memeory and goes on forver
04:53:25 <guenni> I'm using HaXml
04:53:27 <haskellian> ok how?
04:53:38 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
04:53:40 <lambdabot> Title: 5.14.ï¿½Running a compiled program, http://tinyurl.com/d7dj4
04:54:11 <guenni> so HXT is an alternative to HaXml?
04:54:12 <yitz> guenni: yeah, i like HaXml. But it's a problem for big files. for now at least, until they add lazy parsing.
04:54:14 <quicksilver> malcolmw: am I rgith in remembering there is an experimental lazy parser in dev haxmls?
04:54:44 <yitz> @seen malcolmw
04:54:45 <lambdabot> malcolmw is in #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when malcolmw last spoke.
04:54:53 <jeffz`> guenni, HXQ is also for large files and has very low memory consumption
04:55:13 <guenni> jeffz`: link pls
04:55:42 <quicksilver> hxq is rather different though.
04:56:00 <guenni> not much of a problem for me to switch to another XML implementation cause I still didn't really figure HaXml
04:56:01 <quicksilver> it's a TH-based XQuery compiler.
04:56:12 <jeffz`> guenni: it's on hackage
04:56:19 <guenni> thx
04:56:33 <jeffz`> guenni: http://www.haskell.org/pipermail/haskell-cafe/2008-April/041962.html
04:56:35 <lambdabot> Title: [Haskell-cafe] ANN: HXQ: An XQuery Compiler/Interpreter for Haskell, http://tinyurl.com/6phzwk
05:00:42 <guenni> I do have this app which runs dynamic data against a large amount of static data, now the static data I would like to be part of my binary instead of reading it in from an extra file every time the program runs. I figure this can be done, but what problems should I expect with this approach?
05:01:53 <malcolmw> guenni: yitz: don't believe everything you read on IRC.  It is HaXml that has a lazy parser, and HXT does not.
05:02:27 <yitz> malcolmw: ok, sorry, i wasn't sure. and glad to hear that because i use haxml!
05:03:05 <guenni> malcolmw: that's good to know, how do I turn it on?
05:03:07 <malcolmw> but you need to switch the parser over to the lazy version manually, by changing your imports
05:03:39 <malcolmw> Text.XML.HaXml.Parse --> Text.XML.HaXML.ParseLazy etc
05:04:01 <malcolmw> and this is in HaXml-1.19 or so
05:04:03 <quicksilver> guenni: dons has posted an example of serialising something to Data.Binary and then embedded as a constant string in the compiled app.
05:04:11 <quicksilver> that's a reasonable way of getting it into the app.
05:05:14 <guenni> quicksilver: I was actually going to make a Show on the data structure once I read it into memory and the soter that in a regular *.hs file
05:05:28 <quicksilver> guenni: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014385.html
05:05:30 <lambdabot> Title: static constants -- ideas?, http://tinyurl.com/6mshve
05:05:38 <quicksilver> (and the surrounding messages in that thread)
05:06:24 <yitz> quicksilver: that's useful, i didn't see that thread. it should go on the wiki.
05:06:47 <yitz> quicksilver: (but it's only useful for an xml app if you know in advance what file you will be reading)
05:06:50 <quicksilver> I'm inclined to think it's slightly pathological, personally :P
05:06:59 <quicksilver> much better to bundle data files with your executable
05:07:03 <besiria> i'm finding hard to control flow in a monad. i'm doing sth wrong . i use when and unless a lot. is there maybe another way?
05:07:06 <quicksilver> which all OSes have a sensible convention for doing.
05:07:09 <quicksilver> But it's a neat hack.
05:07:35 <yitz> quicksilver: well, putting large constants into a Haskell app is already pathological due to limitiations in ghc, unfortunately.
05:08:18 <yitz> so its good to see that there is a standard solution for now.
05:28:28 <guenni> malcolmw: why the 2 variations, ie. Lazy and Strict?
05:29:10 <malcolmw> guenni: strict is just the standard way parsers are written.  the Lazy variation came much later
05:29:35 <malcolmw> we have only known how to make parsers lazy for a couple of years
05:30:07 <malcolmw> ... and there are tradeoffs in when errors can be caught
05:30:48 <yitz> the original parsec came with an advertisement that it is intentionally strict for greater speed.
05:30:54 <guenni> malcolmw: what do I need to change to switch this to lazy? http://hpaste.org/9735
05:31:43 <guenni> yitz: funny thing with parsec, it did parse my 60k lines file without problems
05:32:17 <malcolmw> guenni: right, so you will need to go find the definition of processXmlWith, cut-n-paste it into your code (along with its imports), and then start modifying imports to get the lazy parser
05:32:49 <guenni> and also I did understand the docu and how to use it, but I don't have a clue what I'm doing with HaXml
05:32:52 <haskellian> does binary serialization normally take s--tloads of time or am I doing something wrong? Serializing a 316kB .txt file(firts i am parsing it into a list of data then i encode it) takes forever...
05:33:08 <guenni> malcolmw: I was afraid you might say that ...
05:33:19 <haskellian> and it is not the parsing that takes time, it is only the seriazlization, but maybe it slaziness at work so it actually is the parsing
05:33:33 <malcolmw> guenni: there should really be a standard wrapper like processXmlLazyWith, but I never got round to adding it.
05:34:08 <guenni> how about now :)?
05:34:40 <yitz> guenni: so if you write it - submit it to malcolmw for inclusion in haxml and we'll all enjoy it :)
05:35:13 <guenni> when it comes to haskell I still so not have a clue what I'm doing
05:35:47 <gwern> @remember SimonM People don't seem to believe me when I say this.  In retrospect we shoulnd't have called it forkOS, we should have called it forkReallyExpensiveOnlyNecessaryForCallingOpenGL_IO.
05:35:47 <lambdabot> It is forever etched in my memory.
05:35:57 <gwern> @quote fork
05:35:57 <lambdabot> dmwit says: Only in #haskell would somebody consider rolling back a process fork.
05:36:17 <gwern> @quote fork
05:36:18 <lambdabot> dmwit says: Only in #haskell would somebody consider rolling back a process fork.
05:36:22 <gwern> @quote fork
05:36:22 <lambdabot> dmwit says: Only in #haskell would somebody consider rolling back a process fork.
05:36:29 <gwern> oh good grief
05:36:33 <gwern> @quote SimonM
05:36:34 <lambdabot> SimonM says: People don't seem to believe me when I say this.  In retrospect we shoulnd't have called it forkOS, we should have called it forkReallyExpensiveOnlyNecessaryForCallingOpenGL_IO.
05:36:45 <yitz> @quote forkOS
05:36:45 <gwern> @quote forkOS
05:36:45 <lambdabot> SimonM says: People don't seem to believe me when I say this.  In retrospect we shoulnd't have called it forkOS, we should have called it forkReallyExpensiveOnlyNecessaryForCallingOpenGL_IO.
05:36:46 <lambdabot> SimonM says: People don't seem to believe me when I say this.  In retrospect we shoulnd't have called it forkOS, we should have called it forkReallyExpensiveOnlyNecessaryForCallingOpenGL_IO.
05:36:50 <yitz> he
05:36:59 <yitz> @quote believe
05:37:00 <lambdabot> mikaeli says: My friend bought a new laptop; it had MSBLASTER preinstalled. I couldn't believe it either and installed XP and the apps many times, run virus killers and everytime the blaster came
05:37:00 <lambdabot> back. Everything was packed on a rescue cd. And virus was in m$ works installation files.
05:38:09 <pmurias> how should I store large multiline strings in my haskell programs, something like heredocs?
05:38:25 <noteventime> I thought blasted was considered a vital system process these days (it's not a bug, it'a feature!)
05:38:59 <gwern> pmurias: avoid the multiline literals
05:39:04 <gwern> they will give you grief
05:39:25 <gwern> pmurias: the solution is generally either bite the bullet and store one really long line
05:39:37 <gwern> or use a list of short strings and concat them together or similar
05:40:04 <Zao> Store it in a C char[] and foreign import it?
05:40:13 <gwern> if you just want some special characters like newline adn tab, I'd just write a normal string with escapes
05:40:48 <gwern> Zao: I think that's probably one of the worst approaches :)
05:41:14 <Zao> gwern: But one of the more innovative ones, surely? :)
05:41:30 <yitz> gwern: for really big strings, that was the standard way to do it until dons' bytestring idea.
05:41:53 <gwern> innovative? nah. innovative would be something like writing a minimalistic turing machine and feeding the function a seed which eventually terminates as your chosen string
05:42:08 <gwern> yitz: and thank goodness we now have bytestring eh
05:43:25 <nothingmuch> i don't know of any better place to ask, so apologies in advance, but does anybody know usable logic query langs (E.g. on onthology/rdf triples) that are capable of nested relations?
05:44:02 <yitz> i was thinking of writing a base93 codec to minimize source code size for literal strings. :P
05:44:11 <nothingmuch> by usable I mean actually implemented, opensource, etc
05:44:27 <gwern> mm. there are a surprising number of RDF-related libraries in haskell, but no actual languages
05:45:14 <ski> (gwern : why no multiline literals ?)
05:46:03 <gwern> ski: a horrid source of bugs. you get things that are broken with CPP, you wind up with source files that work in ghci - but not ghc - or vice versa, the exact syntax is unclear, and so on
05:46:10 <gwern> they've never given me anything but grief
05:46:15 <benpicco> Hi, is there some kind of infinity which can be compared to an Int
05:46:17 <benpicco> ?
05:46:36 <yitz> > maxBound :: Int
05:46:38 <lambdabot>  9223372036854775807
05:46:44 <ivanm> @hoogle isInfinite
05:46:45 <lambdabot> A Hoogle error occurred.
05:46:48 <ivanm> :o
05:47:02 <nothingmuch> http://haskell.org/hoogle/?q=isInfinite
05:47:02 <benpicco> @hoogle infinity
05:47:03 <lambdabot> A Hoogle error occurred.
05:47:04 <lambdabot> Title: isInfinite - Hoogle
05:47:10 <gwern> @hoogle head
05:47:11 <lambdabot> A Hoogle error occurred.
05:47:12 <gwern> broken
05:47:15 <yitz> @ isInfinite
05:47:23 <yitz> @type isInfinite
05:47:24 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:47:38 <yitz> so that doesn't work for Int.
05:48:27 <benpicco> hm, but using the biggest possible number looks a bit ugly, but should work
05:48:41 <nothingmuch> Int wraps around though
05:48:52 <yitz> it's meant for IEEE floats, that have Infinity.
05:48:54 <nothingmuch> so be careful
05:49:56 <yitz> benpicco: don't use the actual number, of course, that's platform dependent. use the variable maxBound.
05:50:08 <nothingmuch> *nod*
05:50:20 <nothingmuch> lambdabot happens to have 64bit int
05:50:22 <nothingmuch> s
05:50:32 <yitz> (actually not a variable - it's a member function of the Bounded class)
05:50:37 <benpicco> yitz, yes,  maxBound::Int
05:51:02 <slarba> @pl \s -> isAlpha s || isDigit s
05:51:03 <lambdabot> liftM2 (||) isAlpha isDigit
05:51:50 <ivanm> or else: \ s -> any ($s) [isAlpha, isDigit] ;-)
05:52:08 <ski> (class members are variables)
05:52:34 <guenni> sry guys, I just come accross this rather large Cookbook for HaxmlToolbox, before I start reading this does anyone know if HToolbox can deal with large XML files?
05:52:39 <yitz> @pl \s -> (||) `on` ($s) isAlpha isDigit
05:52:40 <lambdabot> ((||) `on`) . flip isAlpha isDigit
05:52:50 <guenni> cause otherwise I just won't bother
05:53:31 <Wild_Cat> n00b question: is there a function, or nifty one-liner, to map a number of functions to a single value? (that is, of type [(a -> b)] -> a -> [b] whereas map is (a -> b) -> [a] -> [b])
05:54:14 <Saizan> ?type sequence :: [(a -> b)] -> a -> [b]
05:54:15 <lambdabot> forall a b. [a -> b] -> a -> [b]
05:54:30 <Saizan> Wild_Cat ^^^
05:54:32 <Wild_Cat> awesome. Cheers.
05:54:44 <ziman> ?type sequence :: [(a -> b)] -> c
05:54:46 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
05:54:50 <ziman> ?type sequence :: [(a -> b)] -> ?c
05:54:51 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
05:55:29 <yitz> @pl \fs x -> map ($x) fs
05:55:30 <lambdabot> flip (map . flip id)
05:55:46 <Saizan> wasn't it better when it reported the type error?
06:00:10 <haskellian> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html, GHCRTS='-M128m'
06:00:12 <lambdabot> Title: 5.14.ï¿½Running a compiled program, http://tinyurl.com/d7dj4
06:00:15 <haskellian> option does not exist
06:00:50 <haskellian> i just want to say run Main.exe and dont use more than 128RAM
06:02:52 <Philippa_> "When your Haskell program starts up, its RTS extracts command-line arguments bracketed between +RTS  and -RTS  as its own. For example:"
06:03:28 <Philippa_> oh, wait, sorry. Environment variable, with you
06:05:35 <Saizan> tried with: Main.exe +RTS -M128m -RTS <other args..>  ?
06:12:08 <matthew-_> I'm sorry, but so much of the System.IO api is totally broken
06:12:20 <matthew-_> so much utter inconsistency between Int and Integer
06:12:35 <guenni> sry, but which xml parser does parse arbitrarily large xml docs out of the box then?
06:12:35 <matthew-_> and the same carries over the the ByteString API where it tries to merge it
06:13:05 <matthew-_> Int is far too small (large file support please) and you shouldn't be using Integer anyway as it should be unsigned
06:13:19 <matthew-_> they should all be using Word64 or some unbounded unsigned int type
06:13:23 <guenni> malcolmw: ping
06:14:36 <Philippa_> to point out the obvious: they should be using a type synonym
06:15:25 <yitz> guenni: didn't malcolmw say that haxml does that - if you get the imports right?
06:15:38 <matthew-_> there's clearly been a lot of "oh I want to mirror this C API now" and just chucking it in without thinking properly about the types
06:15:57 <guenni> yitz: so you see the problem :)
06:16:23 <matthew-_> and it's making my life a complete pain now, as my code is littered with fromIntegral calls and toInteger calls and I need to go through each one to make sure that I'm not going to suffer rounding/range issues
06:16:33 <guenni> yitz: I mean I don't really understand how to use HaXml to begin with
06:16:55 <guenni> so getting the imports right, fat chance
06:17:43 <yitz> guenni: i would still say that's called "out fo the box". you have to import something, there are 2 choices.
06:18:40 <yitz> guenni:  i didn't follow before. malcolmw didn't tell you what to import?
06:19:05 <Axman6> rawr, i don't like writing apps that die with "Heap exhausted; Current maximum heap size is 512000000 bytes (488 Mb);"
06:21:28 <guenni> yitz: I'll try but it did seem rather complicated
06:22:04 <guenni> yitz: it also implied that you can't do the same things lazily that you could do "strictly"
06:22:31 <guenni> yitz: I might be wrong there
06:23:13 <yitz> guenni: i think the main thing is that you can't get an error without first successfully parsing part of the file - it's clear why. so the return type will have to be a little different to reflect that.
06:24:23 <guenni> yitz: If you believe that it will allow me to parse a large file at the end of the day then I'll try to follow it up
06:25:17 <yitz> guenni: it sounds promising. i haven't tried it that way - but i'll probably need to soon, so please let me know how it goes! thanks.
06:45:00 <quicksilver> matthew-_: I don't personally think the fact that Integer is signed is a big deal.
06:45:01 <haskellian> seems to work, ty saizan and philippa
06:45:11 <quicksilver> you need a way to flag invalid arguments in that kind of call anyway.
06:45:16 <quicksilver> I view it as a minor wart.
06:45:28 <quicksilver> As for the fact that somethings are Int instead, well that's a tricky one :)
06:45:46 <quicksilver> Using Int at all - the mere existence of the type - is a concession to efficiency
06:45:55 <quicksilver> rather than a well-founded desire to restrict the range.
06:49:06 <Philippa_> haskellian: if you've got time that may be worthy of a bug report even if the main thing that changes is docs
06:50:42 <haskellian> I get "current maximum heap size exhausted, use +RTs -M... to increase it
06:50:56 <matthew-_> quicksilver: ok, I agree the Integer thing isn't too bad, but Int is just plain wrong as file can easily be > 2^28 bytes
06:50:59 <haskellian> wtf so I cant even run a simple parser in haskell
06:51:16 <haskellian> if i let it use what it want it consumes the whole computer and never finishes
06:51:19 <Philippa_> rather, your simple parser doesn't do what you expect it to
06:51:49 <Philippa_> can you put it up on hpaste and we'll help work out why it's trying to allocate half the universe?
06:52:00 <haskellian> and it is hard to check since i dont know if it is the laziness or the binary serialization
06:52:04 <matthew-_> quicksilver: though yes, a nicer/more-flexible API would probably end up being more complex
06:52:12 <haskellian> sure but it is several files, ill post all
06:52:52 <BeelsebobWork> doesn't sound like it's a "simple" parser
06:53:04 <Philippa_> BeelsebobWork: simple != trivial
06:53:15 <quicksilver> matthew-_: bear in mind that when the API was designed, the majority of architectures had Int64 being an order of magnitude slower than Int.
06:53:25 <BeelsebobWork> Philippa_: fair point
06:53:35 <quicksilver> matthew-_: so upgrading everythign that could remotely be > 28 bits to Int64 was not a 'cheap' solution.
06:53:56 <matthew-_> quicksilver: yeah, fair enough
06:53:59 <BeelsebobWork> Philippa_: however, I've written several non-trivial simple parsers that don't involve lots and lots of source files
06:54:13 <quicksilver> matthew-_: it still sucks, but the problem is hard to solve :)
06:54:16 <matthew-_> quicksilver: but we should perhaps revisit these apis now and update them
06:54:25 <quicksilver> matthew-_: just look at the mess the C library authors got into over the same issue :)
06:54:47 <quicksilver> duplicated APIs everywher and complicated rules about when you could mix them.
06:56:11 <haskellian> classes
06:56:12 <haskellian> http://hpaste.org/9737
06:56:12 <haskellian> bsparsing
06:56:12 <haskellian> http://hpaste.org/9738
06:56:12 <haskellian> filters
06:56:12 <haskellian> http://hpaste.org/9739
06:56:14 <haskellian> main
06:56:16 <haskellian> http://hpaste.org/9740
06:57:00 <BeelsebobWork> haskellian: first thing to note -- convert :: ByteString -> Int -- this is also know as CBS.readInt
06:57:02 <haskellian> it is not just parsing, it is sorting and organizng
06:57:12 <haskellian> beelse: thanks
06:58:05 <BeelsebobWork> mov_id is aka CBS.readInt . head
06:58:18 <Philippa_> *wince* - okay, I don't think I'm awake enough to go through that much ad-hoc parsing code without library support
06:58:52 <Philippa_> my bet is you've got a piece of non-terminating recursion in there somewhere though
06:59:45 <haskellian> what does cbs stand for anyway?
06:59:58 <BeelsebobWork> Data.ByteString.Char8
07:00:05 <BeelsebobWork> (CharacterByteString)
07:00:34 <haskellian> and do you mean "convert $ B.take ((B.length (head str)) - 1) $ head str = CBS.readInt . head"?
07:00:55 <haskellian> Philippa: it works for file 1-7
07:01:13 <haskellian> it is when I do the big file file nr 8 that it eats up all the memory an dnever finsihes
07:02:17 <Philippa_> what's the difference in sizes?
07:04:17 <haskellian> 12kB vs 316Kb
07:05:33 <Philippa_> then it's still probably a piece of non-terminating recursion that the larger file triggers and the smaller ones don't
07:05:50 <Philippa_> if the larger file'd been in the hundreds of megabytes, sure
07:06:32 <haskellian> ok i will look into it
07:06:41 <haskellian> maybe a time to learn quickcheck
07:08:32 <haskellian> the annoying thing is, if i dont enoce the files it terminates quickly, but is that just the lazy evaluation?
07:09:14 <haskellian> when main says Sorting done Filtering done it hasn't really done any sorting?
07:09:22 <haskellian> it does all the work when i say encode
07:09:24 <haskellian> ?
07:10:25 <Philippa_> *nod*
07:12:26 <haskellian> well that makes it hard to test and at least for my somewhat still impreative mind hard to reason about
07:12:32 <pozic> Why can't I derive for ParsecT combined with StateT in one order?
07:13:00 <pozic> (derive MonadState)
07:13:07 <quicksilver> pozic: I'm not sure I understand the question.
07:13:15 <haskellian> should I rewrite the BSParsing using Parsec instead? would it be faster and cleaner?
07:13:27 <BeelsebobWork> no and yes
07:13:33 <BeelsebobWork> it would certainly not be faster -- it'd be a lot slower
07:13:36 <quicksilver> pozic: it would be the author of ParsecT's responsibility to write the 'commuting instance' to lift state through ParsecT.
07:13:42 <pozic> StateT ParsecT works, but ParsecT StateT doesn't because the eta property doesn't hold.
07:13:51 <BeelsebobWork> cleaner is rather arguable -- parsec allows you to write nice code... if you're disciplined with it
07:15:35 <BeelsebobWork> haskellian: as an example, I recently wrote a parser for obj files -- the parsec version took too long (> 20 minutes) to parse a 10MB obj file.  The bytestrings version parses a 96MB obj file in 6 seconds
07:15:53 <BeelsebobWork> and I'd say they probably have about the same level of code-niceness
07:17:00 <Philippa_> BeelsebobWork: yeah, Parsec3 really needs to come with a big "not ready for prime-time!" warning
07:17:21 <Philippa_> it's hugely unoptimised in its current state, and really you want the compiler to spit out something specialised for your input stream
07:19:51 <BeelsebobWork> hmm
07:20:16 <BeelsebobWork> I'm really finding that I need cabal to support a build number, which is auto-incremented each time I run runhaskell Setup.hs build
07:20:30 <haskellian> ok thNK YOU very much i will look into my perhaps nonterminating algorithm, ty for the advice, haskellcommunity is great
07:20:53 <BeelsebobWork> haskellian: glad you were satisfied, sorry I couldn't be more useful, just got lots to do atm
07:23:35 <FordCortina> ive got a bunch of functions fi, where fi :: tok -> Bool. they recognise arbitrary tokens. would be good way to sequence and alternate these functions? i basically want to store these without full specifing my parsing algorithm.
07:24:46 <BeelsebobWork> FordCortina: so what do you mean by sequence
07:24:57 <BeelsebobWork> if you're thinking about sequencing functional things there's something not quite right
07:25:26 <Wild_Cat> well, isn't that what monads do? ;)
07:26:10 <Saizan> sequencing wrt the input [tok] i guess
07:26:11 <FordCortina> hmm
07:26:39 <FordCortina> Saizan: yes that's what i mean
07:26:42 <BeelsebobWork> Wild_Cat: yes, and there's a reason I mostly avoid monads -- I like to write *functional* programs
07:26:51 <BeelsebobWork> then I guess it's time for zipWith
07:27:33 <Philippa_> a Monad or an Applicative is probably the way to go, depending
07:27:43 <BeelsebobWork> applicative does sound kinda likely
07:27:45 <FordCortina> BeelsebobWork: I'm building a parser data structure which contains these recognisers
07:28:13 <Philippa_> BeelsebobWork: you do realise that Applicative and Monad are equally pure or impure, and equally functional, right?
07:28:24 <FordCortina> it then gets run though an interpreter which actually does the parsing and memoization
07:28:32 <BeelsebobWork> Philippa_: no, they're really not -- they have very different semantic models
07:28:45 <FordCortina> the data structure is there because i am trying to do some checks for left-recursion
07:29:26 <BeelsebobWork> Philippa_: for a start -- monads are not nice and composably -- that doesn't sound very functional to me
07:29:29 <Philippa_> BeelsebobWork: Applicative's got cuter composition properties, that's about it
07:29:44 <BeelsebobWork> composable
07:29:54 <Philippa_> Applicative doesn't support higher-order computations, that doesn't sound very functional to /me/, either
07:30:04 <Saizan> you can make combinators like f <:> fs = \(tok:ts) -> if f tok then fs ts else False, and f <|> g = \x -> f x || g x,
07:30:10 <BeelsebobWork> it doesn't?
07:30:16 <BeelsebobWork> how does it not support it?
07:30:37 <Philippa_> BeelsebobWork: because there's no join or equivalent thereof
07:31:02 <BeelsebobWork> Philippa_: oh, okay, so does it now have to support all ideas in functional programming?
07:31:14 <BeelsebobWork> applicative doesn't *block* you from doing higher order programming
07:31:24 <BeelsebobWork> monads do block you from doing compositional programming
07:31:36 <Philippa_> er yes, restricting to Applicative and not being a monad /does/ stop it
07:31:38 <BeelsebobWork> no pun intended
07:32:09 <Philippa_> in the meantime, monads may not be self-applicable for composition purposes but that's fine: FP doesn't mean not having any (non-function) values
07:32:56 <quicksilver> monads don't block you from doing compositional programmming at all.
07:33:03 <quicksilver> monads don't compose at the *type* level
07:33:06 <quicksilver> but that's quite different.
07:33:13 <BeelsebobWork> it is?
07:33:21 <quicksilver> there's all kinds of ways to use monads with various compositional properties at the value level.
07:33:21 <Philippa_> yeah. Ints don't compose either, so?
07:33:22 <BeelsebobWork> they stop me from composing chunks of my code together
07:33:25 <BeelsebobWork> because the types don't work
07:33:45 <Philippa_> BeelsebobWork: which they're damn well supposed to. They're meant to force you to do the work necessary in composing them
07:33:52 <Philippa_> incidentally, Applicatives /also/ do that
07:33:54 <geezusfreeek> by that logic, Num does the same thing
07:34:05 <quicksilver> the facty ou can't automatically construct a combined monad out of two smaller ones is a very interesting thing, and it's a shame, and it's nice that applicatives can
07:34:11 <Philippa_> here, have a run function and a handful of transformers. Problem solved
07:34:17 <quicksilver> but that doesn't mean that you don't get all sorts of compositional patterns with monads.
07:34:26 <BeelsebobWork> Philippa_: problem solved in an ugly way
07:34:27 <pozic> What's the point of putting a T behind Parsec when it cannot actually be used with a simple StateT(such that you can write do state <- get;string"hi";?
07:34:55 <Philippa_> BeelsebobWork: problem solved in exactly the way it has to be solved whether there's a monad involved or not. You may as well bitch about Maybe for errors getting in your way - in fact, that's precisely what you are doing
07:34:57 <geezusfreeek> pozic: it's a flaw in the hierarchy, not in monads
07:35:19 <quicksilver> it's only that someone didn't write the instance, isn't it?
07:35:28 <geezusfreeek> the get and string functions could just as well be defined on type classes, which would solve the problem
07:35:33 <quicksilver> you can always just lift it yourself
07:35:39 <quicksilver> get is defined on a type class
07:35:47 <quicksilver> and it would solve the problem if someone had written the instance
07:35:50 <pozic> MonadState class
07:35:57 <geezusfreeek> quicksilver: right, but string isn't, afaik
07:36:01 <quicksilver> unless there is a reason you can't write that instance. I can't think of one off hand.
07:36:42 <Saizan> pozic: you can use Control.Monad.Trans.lift, like do x <- lift get; lift (put (f x))
07:36:53 <Philippa_> quicksilver: there's a chance someone wrote one using Parsec's built-in state, which'd be a PITA
07:36:59 <Saizan> pozic: or also use it to write the MonadState instance
07:37:03 <Philippa_> not poked at it in a while
07:37:25 <Philippa_> really, for things like that you want liftToNamedLayer functions anyway - what happens when you need another state layer later?
07:37:35 <geezusfreeek> oh, i guess it wouldn't _necessarily_ matter that string isn't, but for the sake of being general
07:37:42 <Philippa_> BeelsebobWork: really most of your arguments boil down to "wah, I don't like it!", unfortunately
07:38:04 <BeelsebobWork> Philippa_: but that's my entire argument against C too
07:38:08 <BeelsebobWork> wha I don't like weak types
07:38:13 <BeelsebobWork> wha I don't like sequencing things
07:38:24 <BeelsebobWork> wha I don't like things that don't compose
07:38:29 <quicksilver> well, I think you have chosen your own definition of 'compositional'
07:38:33 <quicksilver> which is fair enough, that's your right.
07:38:37 <Philippa_> really? Because a competent debater could provide reasons that weak types and mandatory sequencing of things are bad
07:38:37 <quicksilver> but it inhibits conversation :)
07:38:37 <geezusfreeek> what is wrong with sequencing?
07:38:53 <BeelsebobWork> geezusfreeek: I shouldn't have to do it
07:38:56 <quicksilver> I would also note that Applicative and Monad and Arrow all sequence equally.
07:38:56 <BeelsebobWork> the compiler should do it
07:38:58 <pozic> Saizan: yes, but lifting is so annoying it makes me reconsider my choice for Haskell for this project or my next.
07:38:59 <geezusfreeek> ever?
07:39:06 <BeelsebobWork> geezusfreeek: not ever
07:39:06 <quicksilver> and the only things they sequence are effects.
07:39:09 <geezusfreeek> this must be why you don't like monads
07:39:11 <Philippa_> and yes, you're using your own definition of 'compose' while complaining about the available means of doing so with nothing better-founded than "it's ugly"
07:39:13 <quicksilver> they don't sequence evaluation.
07:39:25 <BeelsebobWork> geezusfreeek: it's one of the reasons I don't like monads, yes
07:39:27 <quicksilver> (except to the extent that effects require evaluation, which is fair enough)
07:39:31 <yitz> Philippa_: it's probably my fault. I've been whining a lot here lately during the past day or two.
07:39:33 <Philippa_> frankly, you give the impression that you'd rather just do it out by hand and suffer the weaker typing
07:39:45 <BeelsebobWork> quicksilver: the also "sequence" evaluation in terms of the implications in your code
07:39:46 <Philippa_> yitz: no, Beelsebob and I've had this argument in various forms many times
07:39:46 * sw17ch thinks lift is nifty
07:39:52 <yitz> @faq
07:39:52 <lambdabot> The answer is: Yes! Haskell can do that.
07:39:57 <yitz> yay Haskell!
07:39:59 <Saizan> pozic: write that instance then, and if there's no problem with it you can send a patch for parsec
07:40:03 <BeelsebobWork> Philippa_: I know, and I always still disagree with you
07:40:20 <pozic> Saizan: what instance are you talking about?
07:40:29 <geezusfreeek> BeelsebobWork: well, while you complain about monads, i'll use them without any loss of type safety
07:40:37 <Philippa_> BeelsebobWork: monads sequence evaluation to the extent that IRs for lazy FPLs typically do, FWIW
07:40:39 <pozic> Saizan: the problem is that newtype deriving doesn't work, so the recommended way to work with monadtransformers does not work.
07:41:07 <Saizan> pozic: you can write the MonadState instance by hand
07:41:15 <quicksilver> BeelsebobWork: they sequence evaluation to precisely the same extent as any other haskell operator or function
07:41:17 <Saizan> pozic: it's 3 lines of code
07:41:21 <BeelsebobWork> Philippa_: neither of those use the word "do" and the "then do this" function
07:41:31 <pozic> Saizan: yes, but then I am doing work, the machine can do too and Haskell is full of redundancy liek that.
07:41:36 <pozic> like*
07:41:38 <quicksilver> BeelsebobWork: haskell evaluation has to be 'demand-driven' at least.
07:41:46 <Saizan> fine :)
07:42:05 <quicksilver> BeelsebobWork: and monads don't change that, they just give have their own combinators which have their own rules for demanding evaluation.
07:42:18 <quicksilver> just like any function or operator will demand a certain amount of evaluation on its parameters.
07:42:26 <yitz> BeelsebobWork: Let's let the compiler sequence for us. 1. Make backup copy of valuable file. 2. Delete the original. Or - is it the other way around? Hmm... This reminds me of what happens when we use unsafeInterleaveIO...
07:42:30 <Philippa_> BeelsebobWork: "then do this" is your own name for it. So if all you're screaming about is one name for a statement, *get over it*
07:42:51 <BeelsebobWork> quicksilver: I don't care what order things happen in the background -- that's one of the reasons I'm using Haskell -- what I care about is whether *I* write sequencing (whether that's the actual sequence or not)
07:42:55 <Philippa_> it's just a generalisation coming from a direction you're not used to, BFD.
07:43:08 <BeelsebobWork> with monads I *have* to write sequencing (on some abstract level or another)
07:43:11 <Philippa_> BeelsebobWork: there's a sequence every time you bind something in Haskell
07:43:16 <Philippa_> I don't hear you complaining about that
07:43:18 <BeelsebobWork> the fact that the compiler can reorder them is irrelevant
07:43:21 <Philippa_> the sequencing in a do block is /exactly the same/
07:43:38 <Philippa_> (in fact, if you use mdo and the identity function, you basically have let again)
07:43:38 <BeelsebobWork> Philippa_: no it isn't -- there's no sequence in the source code at all when I write bindings
07:43:43 <geezusfreeek> BeelsebobWork: you have no right to complain without proposing a general alternative
07:43:57 <sw17ch> quick poll: what's the most hated thing about Haskell?
07:43:58 <BeelsebobWork> I can reorder my bindings to my hearts content, I can't reorder things in a do block
07:44:01 <geezusfreeek> i find monads a joy to work with
07:44:04 <BeelsebobWork> sw17ch: monads
07:44:08 <Philippa_> BeelsebobWork: yes you can
07:44:24 <Wild_Cat> overflowing ints
07:44:33 <BeelsebobWork> Philippa_: since when is >> commutative?
07:44:37 <Philippa_> and to the extent you can't, *there is a reason for this and the same sequencing is present in the applicative version"
07:45:03 <Wild_Cat> sw17ch: oh, and GHC's error messages suck.
07:45:06 <BeelsebobWork> yes, but the same sequencing is (usually) not expressed at the source code level
07:45:12 <geezusfreeek> BeelsebobWork: you should extend your argument to noncommuative operations
07:45:15 <Philippa_> BeelsebobWork: Since when is >> part of the monad signature? And incidentally: its do statement equivalent /is/ modulo effects
07:45:17 <BeelsebobWork> it only appears when the compiler deals with it
07:45:34 <Philippa_> BeelsebobWork: you just don't see sequencing in application. Not the same thing
07:45:45 <quicksilver> BeelsebobWork: when I write take 5 . drop 2 $ l
07:45:46 <BeelsebobWork> Philippa_: the same thing as what?
07:45:53 <quicksilver> BeelsebobWork: the drop 2 'happens before' the take 5
07:45:56 <quicksilver> and I have to write it like that
07:45:58 <Philippa_> as it not being expressed in the source
07:46:03 <quicksilver> if I write drop 2 . take 5 it means something else
07:46:07 <quicksilver> do you see that as a bad thing?
07:46:11 <sw17ch> Wild_Cat, i seem to have gotten used to the error messages and can find the problem in a hurry
07:46:15 <BeelsebobWork> quicksilver: it does?  That's a mathematical description, not a sequence
07:46:22 <quicksilver> right.
07:46:31 <quicksilver> do { foo ; bar } is a mathematical description, not a sequence.
07:46:38 <quicksilver> there is no different between the two examples.
07:46:40 <geezusfreeek> since when can't a mathematical description be a sequence?
07:46:45 <BeelsebobWork> quicksilver: sure there is
07:46:48 <Philippa_> but . and $ are essentially the pure sequencing operations
07:46:50 <quicksilver> they both descript mathematical objects with precisely defined semantics.
07:46:52 <SamB_XP> geezusfreeek: don't confuse the issue
07:46:53 <BeelsebobWork> one of them goes out of it's way to demonstrate the sequence
07:47:01 <EvilTerran> do notation is mathematical description of sequencing "side-effects"
07:47:12 <Philippa_> EvilTerran: no, it's not
07:47:13 <rwbarton> "sequencing" is just let realWorld' = f . g $ realWorld vs. let realWorld' = g . f $ realWorld
07:47:17 <BeelsebobWork> EvilTerran: indeed it is
07:47:19 <quicksilver> rwbarton: no. It's not.
07:47:24 <geezusfreeek> SamB_XP: i'm just trying to put some perspective on the arguments BeelsebobWork is making
07:47:26 <quicksilver> rwbarton: not all monads are like State RW.
07:47:26 * EvilTerran looks at Philippa_ 
07:47:29 * EvilTerran looks at BeelsebobWork
07:47:30 <quicksilver> rwbarton: that's just one example.
07:47:35 * EvilTerran goes to get another cup of coffee
07:47:36 <SamB_XP> geezusfreeek: try harder
07:47:41 * BeelsebobWork hugs EvilTerran 
07:47:44 <SamB_XP> nitpicks like that aren't too helpful
07:47:45 <rwbarton> Hey, I used quotes, I get to say what I mean by "sequencing". :)
07:47:48 <EvilTerran> !!
07:47:54 * EvilTerran ... hugs BeelsebobWork?
07:47:57 <quicksilver> rwbarton: oh, I think I see what you mean.
07:48:02 <quicksilver> rwbarton: yes.
07:48:05 <rwbarton> (I was thinking about IO in particular)
07:48:05 * BeelsebobWork hugs Philippa_ too
07:48:06 <geezusfreeek> SamB_XP: it's not a nitpick. i think the statements were completely ridiculous, so i pointed them out
07:48:18 <quicksilver> BeelsebobWork: I see no more sequence in foo >> bar then foo . bar
07:48:20 <geezusfreeek> SamB_XP: you can't make arguments if you don't even make sense
07:48:26 <quicksilver> they both have the same amount of sequence notion to me
07:48:36 <quicksilver> in general both (>>) and (.) are non commutative binary operators.
07:48:38 <quicksilver> that's all it is.
07:48:45 <SamB_XP> okay, I'm going to assert that a mathematical description can be a series too
07:49:14 <quicksilver> what I certainly *would* agree with is that monad notation is annoying for commutative monads.
07:49:19 <BeelsebobWork> quicksilver: the difference is that foo and bar often have hidden effects in the (>>) case -- while in the (.) case I can be very sure that they're nice pure things
07:49:20 <quicksilver> if that had been your point I'd have been 100% behind you.
07:49:31 <SamB_XP> what the heck is a commutative monad?
07:49:38 <quicksilver> SamB_XP: one where the order of effects doesn't matter.
07:49:39 <Philippa_> BeelsebobWork: yes, which also applies to Applicative
07:49:44 <Philippa_> which somehow you seem not to mind
07:49:51 <quicksilver> (and therefore the sequencing is moot)
07:50:04 <sw17ch> would a "what the heck is this good for?" section be good for the docs?
07:50:15 <BeelsebobWork> Philippa_: I've never seen that happen in an applicative
07:50:19 <EvilTerran> can you give an example of a commutative monad?
07:50:29 <Philippa_> example commutative monad: a hypothetical "lazy monad" in a strict language
07:50:31 <quicksilver> EvilTerran: reader is the easiest.
07:50:31 <Saizan> BeelsebobWork: yeah, but in applicative you've effects again, liftA2 (,) a b =/= liftA2 (,) b a
07:50:45 <EvilTerran> quicksilver, righto
07:50:47 <Philippa_> BeelsebobWork: wait, this boils down to "Applicative never surprised me"?
07:50:48 <quicksilver> BeelsebobWork: then (with respect) you don't understand applicative.
07:50:54 <EvilTerran> i always thought that one a bit odd
07:50:57 <SamB_XP> sw17ch: which docs/
07:50:59 <quicksilver> BeelsebobWork: because applicative is exactly about effects, just like monads.
07:51:01 <Philippa_> I have a feeling the applicative code you write is largely simple-to-trivial
07:51:04 <SamB_XP> s|/|?|
07:51:11 <quicksilver> it just doesn't let you rewire outputs.
07:51:14 <BeelsebobWork> Saizan: why would lifting a non-commutative operator to Applicative have the effect of making it commutitave suddenly?
07:51:14 <Philippa_> quicksilver: well, it's as about effects as monads are
07:51:26 <quicksilver> Philippa_: yes, sorry, that's actually waht I tried to type
07:51:33 <BeelsebobWork> Philippa_: I go out of my way to make it simple
07:51:34 <quicksilver> "exactly as much about effects as..."
07:51:36 <Philippa_> BeelsebobWork: <*> isn't commutative either
07:51:48 <Saizan> BeelsebobWork: use flip (,) on the second and it still holds for the effects
07:51:52 <sw17ch> SamB_XP, just a section in the wiki about the more obscure pieces of Haskell that describes how they would be used/what problem the solve
07:51:59 <quicksilver> note the (>>) can be defined for applciative to
07:52:02 <sw17ch> this may already exist
07:52:06 <quicksilver> they call it (*>) don't they?
07:52:17 <quicksilver> EvilTerran: the list monad is "almost commutative"
07:52:20 <Saizan> BeelsebobWork: my point is that for non-commutative applicatives the order of the arguments matter
07:52:22 <Philippa_> and yes, you do seem to trade off engineering properties for local simplicity
07:52:30 <EvilTerran> quicksilver, what, modulo element ordering?
07:52:31 <quicksilver> EvilTerran: if you don't care about the order of the results, and you don't care about infinite lists
07:52:34 <EvilTerran> righto
07:52:35 <quicksilver> exactly.
07:52:49 <quicksilver> EvilTerran: the "give me a unique name" monad is commutative
07:52:56 <BeelsebobWork> Philippa_: not at all -- I go for local simplicity and get engineering properties for free -- I don't have to fuck about with monad transformers
07:53:00 <quicksilver> (assume that you don't actually care which name you get, which should be the point)
07:53:05 <EvilTerran> ... i guess, if names're abstract
07:53:08 <quicksilver> right.
07:53:18 <Philippa_> BeelsebobWork: riiiight. Show me how far your "state" (by any name) propagates?
07:53:35 <quicksilver> EvilTerran: the 'build a symbol table' monad is commutative
07:53:40 <BeelsebobWork> Philippa_: show me you thinking about how much state you really need?
07:53:45 <EvilTerran> i'm.... not familiar with that one
07:53:49 <quicksilver> EvilTerran: ...the Writer monad is commutative, if the Monoid you choose is commutative.
07:53:53 <EvilTerran> quicksilver, but i get the point, you can stop now :)
07:54:00 <haskellian> this will always terminate right: http://hpaste.org/9742
07:54:08 <quicksilver> EvilTerran: good. The reason I carried on is to show that these things aren't really all that rare :)
07:54:09 <Philippa_> BeelsebobWork: all the damn time. If you've got an algorithm that can be expressed in terms of the State monad, /it has state whether you like it or not/
07:54:13 <BeelsebobWork> Philippa_: I go out of my way to *not* propogate state
07:54:24 <quicksilver> reducing state is good engineering practice.
07:54:30 <Philippa_> sure. Now show me you've succeeded?
07:54:32 <quicksilver> pretending it doesn't exist at all is not :)
07:54:33 <BeelsebobWork> Philippa_: doesn't mean I *have* to write it statefully
07:54:46 <quicksilver> abstract combinators which hide state are good practice
07:54:55 <quicksilver> doesn't mean that the state isn't there and the effect order doesn't amtter.
07:55:09 <quicksilver> (although of course there are applications when your state transformations commute and so order, in fact, doesn't amtter)
07:55:12 <BeelsebobWork> I didn't ever say *pretend* it doesn't exist
07:55:19 <geezusfreeek> BeelsebobWork: how is <*> _not_ hiding effects behind the scenes that >> hides?
07:55:21 <BeelsebobWork> I said think about the problem until you know how to solve it in a non-stateful way
07:55:38 <Philippa_> yes. And I'm telling you that fundamentally, *it doesn't work that way*
07:55:46 <Philippa_> you're solving it statefully and covering it up
07:55:56 <Philippa_> the only alternative is an entirely different algorithm
07:55:56 <BeelsebobWork> and I'm telling you that fundamentally it *does* work that way
07:56:12 <geezusfreeek> BeelsebobWork: yet it doesn't work that way for monads?
07:56:22 <Philippa_> whether you like it or not, that pass-and-return chain is there
07:56:33 <BeelsebobWork> Philippa_: why on earth are you a functional programmer if you think you need state for everything?
07:56:50 <Philippa_> BeelsebobWork: stop putting words in my mouth
07:56:56 <BeelsebobWork> if you *need* state, why are you not using a language that is actually good at working with state
07:57:02 <Philippa_> like, er, Haskell?
07:57:08 <sw17ch> Haskell is good at state..
07:57:15 <Philippa_> haskell is very, very good at state indeed
07:57:25 <BeelsebobWork> okay, so conclusion... you and I are using haskell for two different things
07:57:28 <Philippa_> much better than any language I'm aware of that's at least as well-supported
07:57:33 <quicksilver> That's not my conclusion.
07:57:33 <BeelsebobWork> you are using it because it's good at managing State
07:57:44 <Philippa_> BeelsebobWork: again, stop putting words in my mouth
07:57:46 <BeelsebobWork> I'm using it because it's good at describing things with no state involved at all
07:57:48 <quicksilver> My conclusion is that you and Philippa_ are fundamentally using different words for the same thing.
07:57:53 <geezusfreeek> BeelsebobWork: i think you are using it even though you misunderstand it
07:58:03 <Philippa_> quicksilver: quite.
07:58:05 <Spark> quicksilver: 90% of "discussions" on irc are because of that
07:58:06 <quicksilver> BeelsebobWork's choice of definitions for 'composable' and 'stateful' differ from, say, mine and Philippa_'s.
07:58:07 <haskellian> http://hpaste.org/9742 , to terminate or not to terminate?
07:58:12 <luqui> hot in here
07:58:19 <quicksilver> Spark: not, normally, in here.
07:58:19 <BeelsebobWork> luqui: it is a bit, yeh
07:58:32 <Philippa_> BeelsebobWork: Newsflash - where the algorithm doesn't have intrinsic state, *I don't use state*
07:58:50 <Philippa_> (it may well use something that looks a bit like state - I should use Reader and Writer more often than I do, for example)
07:59:07 <BeelsebobWork> Philippa_: fair enough, enjoy your boring stateful world
07:59:12 <BeelsebobWork> I'll enjoy my world with no state
07:59:17 <BeelsebobWork> where I just describe things instead
07:59:27 <luqui> I think what BeelsebobWork is saying, is that *most* algorithms don't have intrinsic state, you just have to look a little deeper into them
07:59:37 <luqui> that's what I've noticed, at least
07:59:41 <Philippa_> luqui: many don't. Many I have to work with, for a good many reasons, do
08:00:12 <luqui> I will argue with you even though I have no idea what the ones you work with are!  Yarr!
08:00:30 <Philippa_> this is no big deal. Screaming about how people who work with such algorithms are "boring" and "not really doing functional programming" and "using the wrong language", however, is fundamentally stupid
08:00:35 <geezusfreeek> LOUD NOISES!
08:00:45 <quicksilver> All algorithms which use functions are stateful.
08:00:51 <BeelsebobWork> luqui: the conclusion is that the set of algorithms she's working with are fundamentally different to the ones I'm working with
08:00:54 <quicksilver> A function of type (a -> b) transforms the state 'a' to the state 'b'.
08:00:55 <quicksilver> ;)
08:01:06 <luqui> heh
08:01:08 <BeelsebobWork> quicksilver: now that's just baiting
08:01:11 <BeelsebobWork> :P
08:01:12 <quicksilver> not entirely.
08:01:16 <Philippa_> BeelsebobWork: and the next thing in line, if you're being at all sensible, is that we may well be working in different problem domains
08:01:19 <quicksilver> I write computer games for fun.
08:01:21 <Wild_Cat> Moreover, all programs are stateful to some extent. Or they'd be entirely solvable at compile-time.
08:01:24 <geezusfreeek> BeelsebobWork: it's pretty close to the argument you're making, from my point of view
08:01:28 <luqui> it's kind of going the other way.  This is haskell, there's no such thing as state.
08:01:31 <quicksilver> computer games invariably have "state".
08:01:36 <luqui> so in the same way, everything can be considered state.
08:01:39 <BeelsebobWork> Philippa_: yep, but then I said that 10 minutes ago
08:01:43 <quicksilver> the "state" of the world, or the board, or the players.
08:01:52 <quicksilver> on the other hand, you can write evolve : s -> s
08:01:55 <BeelsebobWork> quicksilver: strangely -- I'm working on computer games, and things similar to them
08:01:58 <quicksilver> and that doesn't look stateful because it's a pure function.
08:02:00 <BeelsebobWork> and they really don't have to have state
08:02:06 <Philippa_> BeelsebobWork: no, you didn't
08:02:09 <quicksilver> and then you can say "is s->s stateful?
08:02:12 <quicksilver> or is it not?
08:02:17 * quicksilver shrugs
08:02:22 <quicksilver> and it becomes a question of definition.
08:02:36 * luqui thinks frp.  continuous state :-)
08:02:40 <geezusfreeek> they certainly must have RealWorld state
08:02:42 <BeelsebobWork> Philippa_: [16:57] BeelsebobWork: okay, so conclusion... you and I are using haskell for two different things
08:02:47 <BeelsebobWork> I didn't?
08:02:49 <quicksilver> geezusfreeek: well that's a detail about the UI.
08:02:59 <quicksilver> geezusfreeek: I was restricting to the core game for focus
08:03:10 <BeelsebobWork> oops, it was 5 minutes ago, not 10
08:03:21 <geezusfreeek> quicksilver: ah, well in that case i agree with BeelsebobWork on that
08:03:22 <yitz> BeelsebobWork: http://www.lisperati.com/landoflisp/
08:03:27 <rwbarton> haskellian: looks like it should run in quadratic time.  Maybe you should use a more appropriate data structure like IntMap Customer
08:03:28 <Philippa_> BeelsebobWork: the "two different things" were implementation details, read the next two lines you wrote
08:04:01 <luqui> that comic is funny.
08:04:05 <Philippa_> incidentally, that sure as hell doesn't describe the whole of my use of Haskell
08:04:06 <BeelsebobWork> Philippa_: yes -- I highlighted that you like to use it for stateful things, and I like to use it for things that don't need state at all
08:04:12 <explicitjelly> it seems like, in Haskell, I spend most of the time thinking instead of typing.
08:04:14 <geezusfreeek> although, i would argue that the algorithms are not stateless, merely abstracted such that you needn't worry much about it
08:04:51 <BeelsebobWork> geezusfreeek: I'm not sure I agree with that, but I'm also not sure I disagree
08:04:52 <explicitjelly> and it usually goes like this: "I could write this recursive function that... naaah, I'm sure there's a way to abstract that recursion away."
08:04:53 <luqui> explicitjelly, definitely.  that's one of its most remarkable properties
08:05:03 <EvilTerran> state is a functionally pure concept!
08:05:14 <quicksilver> yes, that's a good point EvilTerran.
08:05:15 <EvilTerran> the universe is a static system of axioms!
08:05:27 <luqui> not following you anymore
08:05:28 <quicksilver> stateful is quite different from impure.
08:05:29 <BeelsebobWork> luqui: I thought for a second that you thought explicit jelly was a property of FP
08:05:35 <BeelsebobWork> I thought you'd gone completely nuts
08:05:38 <luqui> LOL
08:05:44 <explicitjelly> hahah
08:05:45 <BeelsebobWork> quicksilver: depends on your definition of impure
08:05:54 <geezusfreeek> haha
08:05:55 <EvilTerran> the state of the universe at each instant in time is wholly derivable logically from these axioms!
08:06:02 <explicitjelly> BeelsebobWork, as opposed to implicit jelly, which isn't functionally pure?
08:06:02 * luqui defines impure as the use of endomorphisms!  Ha!
08:06:05 <geezusfreeek> BeelsebobWork: what is your definition of impure
08:06:09 <Philippa_> BeelsebobWork: for any sane definition of impure. It's the definition of stateful that's interesting
08:06:10 <quicksilver> BeelsebobWork: hmm. well let's assume we're both speaking english.
08:06:15 <EvilTerran> hence time is irrelevant, and the axioms are a complete definition of reality on their own
08:06:17 <EvilTerran> :P
08:06:17 <quicksilver> BeelsebobWork: in that case, I don't think it does.
08:06:32 <yitz> explicitjelly: "SQL, Lisp, and Haskell are the only programming languages that I've seen where one spends more time thinking than typing." -- Philip Greenspun, March 2007 ( http://vleeptronz.blogspot.com/2007/11/some-filched-quotes-about-lisp-some.html )
08:06:34 <lambdabot> Title: Vleeptron_Z: some filched quotes about Lisp; some other stuff about programming  ..., http://tinyurl.com/5fbom9
08:06:43 <quicksilver> BeelsebobWork: a "pure" function is one whose result is determined only by the values of its arguments.
08:06:46 <BeelsebobWork> EvilTerran: alternatively -- the universe could have no state, and could instead be a mapping from time to (R^3 -> Maybe Atom)
08:06:50 <quicksilver> BeelsebobWork: I don't think that's a contraversial definiton.
08:07:00 <EvilTerran> BeelsebobWork, that's effectively what i was saying
08:07:04 <luqui> EvilTerran, so there's no state.  the universe just 'is', it seems.  it was defined somewhere:  theUniverse = ...
08:07:05 <Philippa_> BeelsebobWork: that's an infinite stream of states. HTH HAND.
08:07:06 <explicitjelly> yitz, oh... nice. now I'm proud of reproducing a somewhat famous quote without knowing it :P
08:07:12 <EvilTerran> except it's R^4 -> Maybe SubAtomicParticle
08:07:17 <BeelsebobWork> Philippa_: that's not a stream in any way
08:07:19 <EvilTerran> luqui, exactly
08:07:27 <EvilTerran> the universe is a program in a declarative language :)
08:07:36 <BeelsebobWork> EvilTerran: no, it's R^6 -> Maybe (Explicit Jelly)
08:07:37 <Philippa_> BeelsebobWork: fine, I'll write you the unfold with time as the seed, happy?
08:07:42 <quicksilver> Philippa_: well, we don't normally use the word 'stream' for things with continuous parameter.
08:07:46 <BeelsebobWork> EvilTerran: exactly :
08:07:46 <quicksilver> I don't think?
08:07:48 <sw17ch> luqui, the universe is a list comprehension?
08:07:55 <luqui> what?
08:08:00 <Philippa_> quicksilver: fair enough
08:08:02 <luqui> never!
08:08:03 <oal`> EvilTerran, as xkcd stated: "... universe)"
08:08:10 <oal`> meaning it's all in LISP
08:08:18 <EvilTerran> negative
08:08:42 <EvilTerran> it is in the platonic form of a pure language
08:08:42 <luqui> LISP is not quite beautiful enough for the universe.  nor haskell.
08:08:49 <EvilTerran> lisp is neither a platonic form nor pure
08:08:58 <Philippa_> BeelsebobWork: if the answer at time n+epsilon depends on the answer at time n, it's looking awful stateful from here
08:09:19 <luqui> Philippa_, only if epsilon is infinitesimal
08:09:22 <oal`> well
08:09:34 <oal`> actually I have some rather dumb question
08:09:36 <Philippa_> luqui: YKWIM
08:09:47 <luqui> continuous isn't just about "really smal" state, it's actually continuous.
08:09:49 <oal`> how do I work with CArrays?
08:09:59 * BeelsebobWork ponders what YKWIM stands for
08:10:01 <oal`> I mean--
08:10:02 <Philippa_> BeelsebobWork: enough so, in fact, that I'd say your function's actually a pretty unnatural presentation
08:10:06 <EvilTerran> as quicksilver said, "let's assume we're both speaking english" - we ideally wouldn't be reasoning about things in english, or even written formal logic, we'd be reasoning in the platonic form of formal logic
08:10:10 <Philippa_> BeelsebobWork: clearly Ydon'tKWIM
08:10:10 <oal`> I need to fill them, from lists
08:10:14 <explicitjelly> the universe is lambda calculous
08:10:25 <oal`> explicitjelly, the untyped one?
08:10:28 <Philippa_> oh, and point: once we introduce continuous, FP goes out of the window anyway
08:10:31 <BeelsebobWork> oal`: hackage.haskell.org/ -> search for CArray
08:10:40 <oal`> was there
08:10:41 * EvilTerran really doesn't like continuous maths
08:10:42 <explicitjelly> sorry, lambda calculus
08:10:46 <Philippa_> all computable functions are isomorphic to Nat -> Nat functions
08:10:47 <explicitjelly> oal`, good question.
08:10:50 <BeelsebobWork> Philippa_: only because you think the universe is stateful
08:10:58 <Philippa_> BeelsebobWork: no, not at all
08:11:03 <luqui> EvilTerran, you know about continuity in domain theory?
08:11:07 <Philippa_> it's the dependency that is
08:11:07 <yitz> quicksilver, EvilTerran, BeelsebobWork: Actually, that *is* a controversial definition of the universe. Quantum mechanics says that it is not true.
08:11:37 <BeelsebobWork> yitz: probably -- it was only a simple demonstration of the fact that even the universe need not be described with state
08:11:42 <Philippa_> BeelsebobWork: at this point you'd do well to stop patronising me and start finding out what my idea of stateful /is/
08:11:45 <EvilTerran> my brain fundamentally refuses to accept that we can realistically reason about an uncountable set when all notations describing members of that set only provide a countable infinity of expressions (and hence values)
08:11:57 <EvilTerran> so i find continuous maths really does my head in
08:11:59 <luqui> EvilTerran, countable and uncountable are lies
08:12:04 <EvilTerran> it's kinda weird
08:12:10 <Philippa_> because I suspect it's a lot more nuanced than yours
08:12:21 <BeelsebobWork> Philippa_: I only started being patronising when you started accusing me of not knowing anything, rather than arguing on face value
08:12:21 <oal`> I don't see anything like [a] -> CArray at http://hackage.haskell.org/packages/archive/carray/0.1.2/doc/html/Data-Array-CArray.html
08:12:28 <oal`> I am doing it wrong?
08:12:29 <lambdabot> Title: Data.Array.CArray, http://tinyurl.com/6a7ae7
08:12:40 <luqui> EvilTerran, there are also countable sets that are 'computably uncountable'
08:12:43 <BeelsebobWork> and you think that "I suspect it's a lot more nuanced than yours" isn't patronising Philippa_?
08:12:58 <luqui> EvilTerran, for example, the set of all computable infinite lists.
08:13:11 <Saizan> oal`: CArray is an instance of IArray, so you can use the functions from Data.Array.IArray
08:13:18 <luqui> EvilTerran, you can do the cantor diagonal argument on them in a program, and get one that any computable enumeration missed.
08:13:21 * sw17ch thinks that math provides one with a literal eternity of ideas to be busy with
08:13:24 <Philippa_> BeelsebobWork: I have a model in mind, you've shown no sign whatsoever of one at least as nuanced
08:13:34 <luqui> EvilTerran, even though all computable things are countable :-)
08:13:43 <explicitjelly> EvilTerran, luqui, slightly related (not only regarding countable and uncountable infinity but regarding infinite sets in general): http://en.wikipedia.org/wiki/Ultrafinitism
08:13:47 <BeelsebobWork> Philippa_: absense of evidence is not evidence of absense
08:13:51 <Philippa_> in the meantime, you've been flagrantly beating me around with redundant "but you don't always need state!!!!" statements as if that's at all useful
08:14:05 <EvilTerran> luqui, yay!
08:14:07 <explicitjelly> Philippa_, THERE'S NO STATE!!
08:14:09 * EvilTerran 's head explodes
08:14:12 <Philippa_> BeelsebobWork: it's certainly evidence of a greater likelihood of absence. Now do you care to have the damn conversation or not?
08:14:19 <yitz> sw17ch: who needs all of math, just Project Euler is enough to keep one busy
08:14:20 <geezusfreeek> WE'LL DO IT LIVE!
08:14:33 <BeelsebobWork> Philippa_: I was actually mostly just getting on with work
08:14:34 <explicitjelly> I DON'T KNOW WHAT THAT IS, THERE'S NO STATE!!
08:14:35 <oal`> Saizan, thnx
08:14:37 <Philippa_> because you most *certainly* have been pulling a "but I have the one true way and you're not smart enough for it" line throughout, whether explicitly or not
08:14:37 <explicitjelly> geezusfreeek, exactly
08:14:42 <BeelsebobWork> I'll carry on not using state
08:14:57 <geezusfreeek> have fun
08:15:01 <Philippa_> the conversation was never about "you should use state"
08:15:17 <yitz> Flash - smoke pouring out of server at tunes.org - details at 11.
08:15:21 <sw17ch> speaking of state, i want a better way to build my audio bindings library for PortAudio, but the state is getting sticky
08:15:40 <quicksilver> BeelsebobWork: you have been making comments which have demonstrated that you have holes in your conceptual model, and you have responded negatively when Philippa_ and I have attempted to probe.
08:15:54 <EvilTerran> Wittgenstein!
08:15:58 <quicksilver> I think that might explain why you feel you're being patronised.
08:16:00 <EvilTerran> everybody go home! :P
08:16:01 <geezusfreeek> quite the contrary, monads are not inherently stateful, at least not any moreso than applicative
08:16:23 <mapreduce> No more so than \x y => x * y + 10 is
08:16:32 <geezusfreeek> exactly
08:16:43 <Philippa_> geezusfreeek: quite. To the extent they are, you're looking at the relationship between "classic" monad types and an abstract machine evaluating that monad's language
08:16:49 <quicksilver> geezusfreeek: and conversely, applicative is precisely as effectful as monad.
08:16:58 <geezusfreeek> right
08:16:59 <chrisdone> dons: so I noticed that one thread can block on a reading operation on a Handle while other threads can freely write to it. I'm glad of this
08:17:00 <quicksilver> geezusfreeek: (and precisely as sequenced, if that matters)
08:17:23 <quicksilver> the different between applicative and monad is that applicative doesn't let you "wire" the result of intermediate effects into later ones.
08:18:01 <quicksilver> and, since this conversation started by talking about parsing...
08:18:08 <quicksilver> I'd point that parsing is very much sequenced.
08:18:19 <quicksilver> the production which comes first is parsed first!
08:18:25 <quicksilver> parsing is not remotely commutative in that sense.
08:18:37 <BeelsReallyWorki> quicksilver: back for a brief second -- I'm interested in that statement?
08:18:41 <quicksilver> which one?
08:18:46 <quicksilver> I just made quite a few.
08:18:54 <BeelsReallyWorki> why should parsing be sequenced any more than saying "this thing should come before this one in the input"
08:19:07 <geezusfreeek> BeelsReallyWorki: exactly!
08:19:07 <BeelsReallyWorki> e.g. I can "parse" a CSV file in *lots* of different orders
08:19:17 <BeelsReallyWorki> I could start at the end
08:19:18 <BeelsReallyWorki> the middle
08:19:20 <Philippa_> BeelsReallyWorki: that's exactly what the sequencing expresses
08:19:23 <BeelsReallyWorki> the 42nd character
08:19:42 <quicksilver> BeelsReallyWorki: no more than that, no.
08:19:51 <quicksilver> (no more than saying this thing comes before that thing)
08:19:53 <Philippa_> there happens to be a /parsing algorithm/ behind the EDSL as well, but the EDSL itself just expresses a grammar and some semantics
08:19:59 <quicksilver> that is exactly how much it is sequenced.
08:20:00 <geezusfreeek> BeelsReallyWorki: you understand this notion of sequencing, i think you just haven't unified it with what applicative and monads do
08:20:16 <quicksilver> it is sequenced "just enough" to remark that this thing comes before that thing.
08:20:39 <quicksilver> If you like applicative parsers you might meditate on the difference between
08:20:46 <quicksilver> Foo <$> bar <*> baz
08:20:47 <quicksilver> and
08:20:49 <BeelsReallyWorki> Philippa_: well, the sequencing in (monadic) Parsec for example actually expresses more than that -- for example, I'd have to specify that I should parse a line, then another, then another etc (despite it not necessarily happening in that order in the end)... Or I could just map (line parser) . splitOn '\n' inpu
08:20:57 <quicksilver> (flip Foo) <$> baz <*> bar
08:20:57 <BeelsReallyWorki> oops, didn't delete enough input there
08:21:10 <quicksilver> Foo : constructor, bar and baz both parsers.
08:21:33 <Philippa_> BeelsReallyWorki: true. But that's because Parsec handles highly context-sensitive languages as well
08:21:41 <BeelsReallyWorki> one involves saying "parse this thing first" at least conceptually when you write the parser
08:21:44 <BeelsReallyWorki> the other doesn't
08:22:01 <luqui> yitz, the math on project euler is so boring.
08:22:07 <dino-> Quick Text.Regex question, can I make . match the newline character?
08:22:12 <BeelsReallyWorki> Philippa_: maybe -- doesn't mean I should use it in the cases when I'm not parsing highly context-sensitive languages
08:22:14 <Philippa_> also: CSV is a very, very special case. No general purpose parsing algorithm jumps around at random like that
08:22:37 <Philippa_> even Applicative parsers do actually have that kind of sequencing
08:22:51 <yitz> luqui: yeah. it's ad hoc, to say the least. but it keeps you busy;)
08:23:15 <luqui> "how many numbers less than 1,000,000,000 are there such that when you reverse their digits and add 67 you get at least 6 of the same digit"  Who cares!?
08:23:17 <BeelsReallyWorki> Philippa_: I'm not sure it is a special case actually -- I know *lots* of formats that involve parsing lots of lines, all of which are independant of each other
08:23:29 <Philippa_> BeelsReallyWorki: yeah. Now find the lines
08:23:45 <Philippa_> got it yet? All you're talking about is an online parser with lazy results
08:23:53 * luqui doesn't do math to stay busy.  he does it to achieve enlightenment.
08:24:03 <BeelsReallyWorki> map parseLine . splitAt (=='\n')?
08:24:06 <Philippa_> you get the spine of the result list before you get the contents
08:24:13 <BeelsReallyWorki> yep
08:24:22 <dino-> Ah, Text.Regex.mkRegexWithOpts
08:24:42 <quicksilver> luqui: project euler are programming exercises, not maths exercises. Programming exercises informed by mathematical ideas.
08:24:51 <quicksilver> luqui: very few (if any) of them are actually interesting mathematics.
08:24:52 <luqui> fair enough.
08:25:00 <luqui> agreed :-)
08:25:03 <quicksilver> I personally find them deadly dull.
08:25:08 <Philippa_> in fact, you're doing worse: you're not parsing the language you say you do
08:25:10 <Deewiant> but they do often require having some mathematical insight
08:25:12 <quicksilver> But I can see they have a value as programming practice :)
08:25:34 <BeelsReallyWorki> Philippa_: oh? why not?
08:25:42 <Deewiant> if you don't know much number theory you're stuck implementing exponential-time algorithms which never complete
08:25:57 <Philippa_> BeelsReallyWorki: what happens when the contents of an individual line don't parse?
08:26:09 <Philippa_> We're not talking about the same problem any more, because you map them to whatever your failure representation is
08:26:13 <Philippa_> you don't fail the whole list
08:26:13 <BeelsReallyWorki> Philippa_: it produces an error -- and I'd rather get the error locally than globally
08:26:26 <BeelsReallyWorki> absolutely
08:26:31 <BeelsReallyWorki> I consider that a good thing (TM)
08:26:47 <Philippa_> right. It is, however, not the class of problem that typical parsing libraries are built to handle
08:26:50 <explicitjelly> starting always sucks
08:27:06 <explicitjelly> once you're "in" the code, everything's smooth and time passes quickly
08:27:12 <BeelsReallyWorki> Philippa_: perhaps this says something about why I consider typical parsing libraries to be build wrong?
08:27:13 <explicitjelly> but starting sucks.
08:27:17 * luqui knows of parsing libraries built to handle error recovery.
08:27:19 <luqui> lots of them.
08:27:37 <Philippa_> and the usual way to handle it within that framework is to use a two-layered parse: once for the line structure, once (mapped) for the inner. Which is, er, just what you've got
08:28:04 <luqui> .... not true...
08:28:13 <Philippa_> BeelsReallyWorki: because you're arrogant enough to think that not solving your problem is wrong, despite the fact that the problem the libraries do handle can't be adequately handled your way?
08:28:24 <luqui> well, yeah I guess it's true.  if you consider lines ending by semicolons.
08:28:41 <haskellian> Philippa_ im positive it is not the algorithm, the memory-use accelerates to maximum in an instant when i start the program. i tried opening the file that "causes" the problem and deleting all the intermediate parts and it works fine then. also the files look exactly the same so if it works for one it shoudl work for all
08:28:43 <luqui> ... arrogant ...
08:28:46 * luqui stops listening
08:28:59 <haskellian> so the size of the file seem to be the problem
08:29:12 <haskellian> which indicates, exponential algorithm perhaps
08:29:30 <haskellian> or some garbagecollection haskell specific problem
08:29:56 <sw17ch> haskellian, i had a similar problem with a "simple" parser blowing up because i was doing something dumb
08:29:59 <Philippa_> luqui: ndm's got an idea about using similar techniques on the inside of a parsing lib aimed at programming languages, which I keep meaning to toy around with. But you /will/ get much of the sequencing back again
08:30:12 <sw17ch> i don't remember how i fixed it, but i really goofed.
08:30:33 <haskellian> sw17ch: a very algorithm specific problem in your case or something more genral that perhaps im doing the same mistake+
08:31:18 <rwbarton> haskellian: You might not have seen it during the noise, but I already pointed that your update_all function takes quadratic time
08:31:32 <rwbarton> haskellian: I don't know whether that's sufficient to explain what you're observing
08:31:32 <Philippa_> hell, the obvious way to express it in Parsec is to use sepBy&co as normal and just put an appropriate crap-eating/local-error-producing parser as your final option
08:31:56 <sw17ch> i was holding a refrence to a list in a top level step and it was being evaluated farther down in the program, i managed to forget that the list wasn't being passed, rather it was held at the top level, so never GC'ed
08:31:57 <Philippa_> but no, let's attack the entire theory of parsing as it currently stands instead, right?
08:33:01 <sw17ch> haskellian, not to mention i was being incredibly dumb with threads
08:33:01 <Philippa_> (the mildly less obvious one: sepBy munching crap between separators, then the 2-layer approach)
08:33:24 <mmorrow> hpaste2!!@ http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
08:34:01 <mmorrow> haha. i'm definitely gonna have a function  crapMunch in every parser i write from now on
08:34:40 <haskellian> rwbarton: ok thanks that's what iw as was afraid of, i will try to change it
08:38:30 <haskellian> about update_all, isnt this a roblem ina fun ctional language, i cant mutate the struct so i have to iterate over the list 2 times, one to copy to a new list and then one to filter out the copied elements from the old list
08:39:22 <Philippa_> haskellian: context's gone, you'll have to give links again. But no, there're generally ways to do things in a single traversal
08:39:33 <Deewiant> http://www.hpaste.org/9742 I guess?
08:41:55 <rwbarton> mmorrow: the language field should default to Haskell
08:43:12 <quicksilver> haskellian: filter foo . map bar $ list *probably* doesn't take two passes
08:43:30 <quicksilver> haskellian: the GHC optimiser goes to some lengths to do such things efficiently
08:43:35 <mmorrow> rwbarton: totally. i've just gotta figure out how ...
08:43:50 <haskellian> http://hpaste.org/9745
08:44:15 <geezusfreeek> in my journey through haskell, i went from not understanding recursion well as an imperative programmer to thinking i understand recursion quite well as a functional programmer, but then i lost it again as i journeyed on to the various kinds of folds and other combinators that hide the recursion
08:44:42 <geezusfreeek> explicit recursion just seems odd to me again
08:44:49 <rwbarton> haskellian: can you say in english what this code is supposed to do?
08:45:26 <rwbarton> say update_all, is it just merging the reviews fields of customers with the same idn?
08:45:47 <haskellian> i will repost with comments, hold on
08:46:11 * mmorrow decides to give it 10 min of concerted effort now, then return to work either victorious or with yet another todo item
08:49:09 <haskellian> with comments : http://hpaste.org/9746
08:49:51 <haskellian> rwbarton: yes you have understood it correctly
08:50:16 <Wild_Cat> Is there a style guide for Haskell code? (similar to PEP-8 for Python)
08:50:18 <twanvl> groupedCustomers = Map.fromListWith combineCustomers [ (idn c,c) | c <- customers ] -- Data.Map is your friend
08:50:21 <rwbarton> haskellian: I suggest you look at IntMap and unionWith
08:50:24 <haskellian> i could make a bette rparser i guess and just add customers with the same id directly
08:51:43 <geezusfreeek> haskellian: does order matter? why (reviews customer ++ [newReview]) rather than (newReview : reviews customer)?
08:51:58 <rwbarton> haskellian: oh, also if you don't care what order...  yes reviews customer ++ [newReview] is very slow
08:53:13 <Wild_Cat> oh, Haskell lists are single-linked?
08:53:23 <geezusfreeek> Wild_Cat: the prelude implementation, anyway
08:53:33 <Wild_Cat> meh.
08:53:34 <geezusfreeek> there many kinds, as well as many kinds of arrays
08:53:57 <rwbarton> haskellian: I'm also not sure why you're taking (head $ reviews x) and then putting it in a one-element list, rather than combining all the reviews
08:54:07 <Wild_Cat> i'd have thought double-linked lists as a default implementation would have been useful. What with O(1) vs O(n) appends.
08:54:09 <haskellian> <geezusfreeek>, good point, i keep using ++ when i have been told : is much faster
08:54:16 <rwbarton> Wild_Cat: it's hard to have referential transparancy and sharing with doubly-linked lists.
08:54:29 <rwbarton> Wild_Cat: i.e. x:xs would have to make a copy of all of xs
08:54:37 <geezusfreeek> haskellian: (:) is just a constructor, so is constant time. (++) has to go to the end of the list and then rebuild the whole thing
08:54:38 <Wild_Cat> yeah, good point.
08:56:34 <haskellian> thanks for the pointers, i will change the code and see what happens
08:56:34 <osfameron> zippers > doubly linked lists for purely functional languages, apparently
08:56:49 <Philippa_> Wild_Cat: there's a wider variety of styles in Haskell than Python, for a number of reasons
08:56:56 <dons> well, lists that you can walk either direction, anyway, osfameron
08:57:04 <haskellian> i guess i didnt think : or ++ mattered for small lists
08:57:06 <lispy> hello #haskell!!
08:57:29 <sw17ch> hello lispy
08:57:33 <Philippa_> haskellian: yeah, I made the mistake and then watched my wiki time out serving a page that some drug-spammer'd modded
08:57:43 <geezusfreeek> haskellian: for small lists, i not really too much. i find x:xs easier to type than xs++[x] anyway though
08:57:52 <geezusfreeek> *i guess not really too much
08:57:55 <lispy> Philippa_: on the one hand that's a perfectly valid response for a spammer :)
08:58:02 <Philippa_> other useful rule: use concat where it makes sense
08:58:19 <Philippa_> lispy: no, timing out the edit page when the spammer tries to crap over your site is!
08:58:26 <Philippa_> this just timed out when you got back to it
08:58:37 <Wild_Cat> Philippa_: likely. But isn't there a set of general principles, or a couple of guidelines any Haskell coder is expected to follow?
08:59:13 <Philippa_> Wild_Cat: mostly "have good taste". Letting layout reveal structure is helpful
08:59:20 <Wild_Cat> stuff like what kind of indentation to use, how much of it, how many lines to skip between function defs, how to organize imports...
08:59:25 <Philippa_> "try to write code at as high a level as you can"
08:59:59 <lispy> Philippa_: that last one can be tricky though.  One shouldn't over generalize their logic.
09:00:00 <Philippa_> heh. With imports it's mostly agreed shove 'em at the top. Otherwise, that's all to taste. Usually one line between top-level function defs, none for let-/where-bindings
09:00:19 <geezusfreeek> Wild_Cat: we don't really worry a whole lot about syntactic guidelines besides the layout engine, at least from what i have seen
09:00:23 <Philippa_> lispy: okay, I missed out a "reasonably"
09:00:26 <Deewiant> you can't even put imports below definitions IIRC
09:00:38 <Philippa_> oh yes: don't use tabs unless you want people to stab you :-)
09:00:45 <geezusfreeek> oh yeah, tabs = bad
09:00:55 <geezusfreeek> i would stab you, really
09:00:57 <Wild_Cat> right. I also kinda figured that theHaskellCommunityUsesCamelCase.
09:01:07 <Philippa_> yeah, point
09:01:12 <lispy> Some peole use_this_too_though.
09:01:27 <Wild_Cat> no guidelines regarding when to use qualified imports VS regular ones either?
09:01:33 <ziman> would you?
09:01:38 <EvilTerran> "when it makes sense"
09:01:42 * ziman uses tabs exclusively
09:01:42 <lispy> Wild_Cat: on qualified, I'd say use to taste
09:01:55 <ziman> is it _that_ important?
09:02:02 <Philippa_> Wild_Cat: most people don't qualify unless it's necessary
09:02:23 <Wild_Cat> ziman: well, the Python community would tell you that as long as you don't mix 'em with spaces it's tolerated ;)
09:02:23 <Philippa_> at which point, if you've got some you're using a lot it can make sense to use single-letter qualifications or similar
09:02:39 <geezusfreeek> one of the nice things about haskell's syntax is that it can be bent quite well for different contexts
09:02:41 <Rostof4ik-> Dear friends. I have come to inform on purpose here to you one truth
09:02:41 <Rostof4ik-> War in the North Ossetia there has begun Georgia under instructions of the USA, for accuse Russian people. That the economy of the USA has risen. It is truth! Russia protected the Ossetin from death! The European and American people - should know it!\
09:02:47 <lispy> import Data.ByteString.Char8 as B -- you see this a lot
09:02:49 * mmorrow was not victorious .. puts it on his todo list :(
09:02:56 <Wild_Cat> okay. Any recommendations for module naming conventions?
09:03:04 --- mode: ChanServ set +o Philippa_
09:03:04 <EvilTerran> ops?
09:03:10 <lispy> Wild_Cat: usually use captial letetrs or module name including the file name
09:03:11 <geezusfreeek> Wild_Cat: tend to follow those of the standard libs
09:03:14 --- mode: Philippa_ set +b *!*@ip-86-110-185-217.spark-rostov.ru
09:03:17 --- kick: Rostof4ik- was kicked by Philippa_ (Philippa_)
09:03:30 --- mode: Philippa_ set -o Philippa_
09:03:47 <EvilTerran> Philippa++
09:04:33 <quicksilver> Wild_Cat: some'people'use'this'just'for'fun ;)
09:04:48 <rwbarton> mmorrow: it's odd, looks like there is code to do it already
09:04:53 <Wild_Cat> easy example: I'm currently writing a character generator lib for a RPG. Is there a Long.String.Of.Stuff.I.Should.Prepend.To.My.Toplevel.Package like in Java (say, Gaming.L5r.Rpg.Character) or should I just go ahead straight at the top level with "module Character where..."?
09:04:55 <lispy> Wild_Cat: one question you should ask is how to deal with field names in records
09:05:16 <quicksilver> Wild_Cat: I would say choose 1 single toplevel for your project
09:05:20 <EvilTerran> Wild_Cat, i'd suggest including your project name as a prefix, but no more's really necessary
09:05:21 <Philippa_> Wild_Cat: top level, refactor within your project and go
09:05:24 <quicksilver> WildCatsGame.Character
09:05:39 <EvilTerran> WildCat'sGame.Character :P
09:05:54 <Wild_Cat> lispy: good point. Especially since I have multiple records with similarly-named fields.
09:05:56 <Philippa_> quicksilver: yeah, okay. I probably ought to do that, I guess. Makes Main a problem though
09:06:10 <lispy> then in the directory tree, you have WildCatsGame/Charecter.hs
09:06:26 <Wild_Cat> e.g. Character.name and Skill.name, for the most obvious.
09:06:52 <lispy> Wild_Cat: right, so typical solution is to put each record into it's own module then import it qualified so the record names don't clash
09:06:59 <Wild_Cat> is it considered okay to have those, or should I rename them to Character.characterName and skill.skillName?
09:07:12 <lispy> Wild_Cat: but anothre thing is to name the fields myRecord'field1
09:07:41 <Philippa_> Wild_Cat: the former can be okay, yeah
09:07:48 <lispy> data MyRec = MyRec { myRec'field1 :: Int, ... }
09:08:05 <Philippa_> though I generally use skillName, characterName etc. They're useful if you've got a similar field in another record later on
09:08:14 <Wild_Cat> lispy: doesn't look very pretty. :(
09:08:20 <EvilTerran> i'd suggest the former, probably, keeping each record in its own module and importing qualified
09:08:32 <lispy> Wild_Cat: then I would go with the separate modules + qualified imports
09:08:33 <EvilTerran> seeing as that gives you the option to include the record name or not do so as appropriate
09:08:46 <Wild_Cat> I was surprised that the type system can't infer which I'm referring to when I'm importing both non-qualified and calling "name foo".
09:09:14 <Philippa_> yes, Haskell's record system sucks and for historical reasons it's likely to stay sucking for a long time :-(
09:09:17 <lispy> Wild_Cat: that might work if you were required to give the type signature
09:09:19 <Wild_Cat> I mean, given the type of foo, there shouldn't be any ambiguity, should there?
09:09:23 <pozic> How can I match end of string in a regular expression? Formally this should be empty.
09:09:48 <EvilTerran> isn't that normally '$'?
09:09:59 <pozic> EvilTerran: that seems to work only for lines.
09:10:08 <rwbarton> Wild_Cat: You can make it handle this situation using type classes, but I do not endorse this approach
09:10:22 <Philippa_> rwbarton: not easily if you want to cover record update!
09:10:40 <rwbarton> Philippa_: not using the standard record update syntax, true.
09:10:44 <pozic> HList seems easy to use -- that is, if it would work...
09:10:46 <Wild_Cat> yeah, the record system doesn't look as awesome as the rest of the language. Which is a shame seeing that I'm an OO kind of guy.
09:11:11 <pastorn> how do i make a 1 line case-function? (i'm using ghci)
09:11:31 <lispy> pastorn: you can put in {} and ;
09:11:34 <Philippa_> pastorn: case foo of {Foo -> ...;}
09:11:40 <rwbarton> Wild_Cat: Well, do you really think of both Characters and Skills as belonging to the "things-with-names" class?
09:11:42 <pastorn> oh, {}
09:11:51 <Wild_Cat> oh, while I'm at it, is there a Set data structure somewhere in the stdlib? (iterable container that guarantees uniqueness of its items)
09:11:53 <EvilTerran> pozic, in perl it's \Z, iirc
09:12:09 <EvilTerran> (or "\\Z" if you don't have regex syntax)
09:12:09 <Philippa_> Wild_Cat: you mean like Data.Set?
09:12:18 <pozic> EvilTerran: I was talking about Text.Regex as this is Haskell.
09:12:21 <Wild_Cat> rwbarton: well, obviously. Skills even belong to the "things with name and a detailed description" class.
09:12:23 <Wild_Cat> Philippa_: cheers.
09:12:29 <lispy> Wild_Cat: not sure about iterable, but Data.Set will give uniqueness...and I think you can just turn that into a list as needed
09:12:39 <rwbarton> Wild_Cat: Right, but would you ever have a list of "things-with-names"?
09:12:48 <EvilTerran> pozic, "The syntax of regular expressions is otherwise that of egrep (i.e. POSIX "extended" regular expressions).
09:12:48 <EvilTerran> "
09:12:57 <rwbarton> Wild_Cat: If so, then you probably do want the type class solution
09:13:18 <Wild_Cat> rwbarton: each character has a list of (rank, Skill) anyway.
09:13:22 <lispy> Wild_Cat: oh yeah, just so you know, a type class is very similar to an interface
09:13:58 <Wild_Cat> so you mean maybe I should create a "named" type class that defines name :: a -> String ?
09:14:22 <lispy> Wild_Cat: right, anything that supports the "named" interface could be an instance
09:14:28 <rwbarton> Wild_Cat: I don't think you should do that just to get around the inconvenience of telling the compiler whether you're using a Character or a Skill.
09:14:49 <rwbarton> Wild_Cat: On the other hand, if you really might have a variable that you don't know whether it is a Character or a Skill, then yes.
09:15:09 <lispy> Wild_Cat: there is a paper about encoding OO concepts in Haskell types.  Let me get you the URL, it might help you think more efficently in Haskell
09:15:11 <Wild_Cat> I don't have only Characters and Skills that have names -- I also have Schools, Techniques, Clans and Families, at the very least. And that's before taking equipment into account.
09:15:28 <lispy> Wild_Cat: http://homepages.cwi.nl/~ralf/OOHaskell/
09:15:31 <lambdabot> Title: Haskell's overlooked object system
09:15:40 <Wild_Cat> lispy: thanks. Saving that to read when I get back home.
09:15:52 <pozic> EvilTerran: that's not the same as Perl regexps..
09:16:59 <Wild_Cat> rwbarton: however, the latter situation is probably unlikely to happen.
09:17:39 <quicksilver> I agree with rwbarton.
09:17:43 <quicksilver> oops.
09:17:47 <quicksilver> I was a page behind.
09:17:49 * luqui would avoid oohaskell...
09:17:50 <quicksilver> althouhg it's still true.
09:18:03 <Wild_Cat> oh, OOHaskell is an extension to the language :(
09:18:09 <quicksilver> I agree that the type class method to cope with shared field names is probably not nice.
09:18:19 <quicksilver> although I think there is a TH recipe for it somewhere.
09:18:30 <rwbarton> Wild_Cat: If you would really create a NamedObject class in Java or whatever, it might make sense to create a Named class in Haskell too
09:19:13 <luqui> Wild_Cat, well, not so much.
09:19:21 <Wild_Cat> rwbarton: I certainly wouldn't. Mostly because my_character.name and my_skill.name work out of the box ;)
09:19:26 <rwbarton> sorry, s/NamedObject class/NamedObject interface/
09:19:37 <luqui> Wild_Cat, it just builds off of HList, which is evil typeclass magic
09:19:45 <luqui> but it's still Haskell (with ghc extensions)
09:20:08 <Wild_Cat> I guess I'll just live with stuff like "C.name myCharacter", "Sk.name mySkill" and "Sc.name mySchool".
09:20:13 <rwbarton> Wild_Cat: OK, then you should probably go with the module-qualified option or manually-disambiguated option
09:21:13 <quicksilver> I don't think HList is especially evil.
09:21:14 <luqui> yeah, record namespacing is something I'd really like
09:21:15 <quicksilver> But overuse of it is.
09:21:36 <quicksilver> then again it's never nice to use a complex solution when a simple one exists.
09:21:44 <quicksilver> an HList is definitely more complex than most solutions.
09:22:54 * mmorrow beats the computer with hackish javascrit!
09:23:03 <luqui> Wild_Cat, what's wrong with:  class Named a where { name :: a -> Name } -- ?
09:23:26 <luqui> javascrit, a very early form of programming
09:23:27 <mmorrow> rwbarton: fixed :)
09:23:39 <rwbarton> mmorrow: nice :)
09:23:53 <rwbarton> mmorrow: it looked to me like the code tries to read the default language from a configuration file
09:24:01 <mmorrow> rwbarton: err, where do you see the code to do it. i did a quick skim over vnc
09:24:31 <mmorrow> rwbarton: ah. hmm. is that in Pages.hs ?
09:24:36 <mmorrow> or Main ?
09:24:39 <rwbarton> mmorrow: it's kind of spread out.
09:24:43 <mmorrow> heh
09:24:48 <rwbarton> mmorrow: but especially get_previous_content in Main.hs
09:25:02 <Wild_Cat> luqui: nothing IMO, really, other than the fact that it's not in the stdlib and that maybe there's a reason for that ;)
09:25:08 <Wild_Cat> (no, I won't abuse Show :p )
09:25:10 <rwbarton> mmorrow: that (String, String) it returns is a (content, language) pair
09:25:51 <luqui> Wild_Cat, my guess why it's not in the stdlib is because you can't build anything useful general-purpose out of it
09:25:53 <rwbarton> mmorrow: and it returns ("", withConf default_language) for a new paste
09:26:00 <mmorrow> i copy-pasted the "skim" function, made a variant skim2 that takes an extra string and  does    body ! [strAttr "onload" (onload_js::String)]  << ...  hehe
09:26:19 <Wild_Cat> luqui: hrmm... Maybe.
09:26:35 <rwbarton> luqui: you should really be asking me and quicksilver why we recommended not doing that :P
09:26:39 <mmorrow> sweet, I didn't look at Main.hs too hard (.. now that i think of it )
09:26:49 <luqui> rwbarton, why do you recommend not doing that?
09:26:57 <pastorn> what's going on with haskell Chars?
09:27:05 <quicksilver> nothing?
09:27:05 <luqui> I generally see Names (in the form of unique idetifiers, at least) as a red flag for a design flaw
09:27:14 <quicksilver> pastorn: what knid of thing do you suspect is going on?
09:27:21 <pastorn> non-ascii characters seems to get destroyed by toLower
09:27:21 <mmorrow> onload="var xs=document.getElementById('language').options;for(var i=0;i<xs.length;i++){if(xs[i].value=='haskell'){xs[i].selected=true;break;}}"
09:27:30 <quicksilver> pastorn: shouldn't do
09:27:43 <quicksilver> pastorn: toLower calls the system implementation which should be unicode aware
09:28:03 <quicksilver> under glibc it calls cwtolower or whatever it's called.
09:28:05 <pastorn> Data.Char.toLower 'Ã¶'
09:28:07 <pastorn> > Data.Char.toLower 'Ã¶'
09:28:09 <lambdabot>  '\246'
09:28:25 <pastorn> ubuntu 8.04
09:28:27 <quicksilver> I don't know if that's right or not because I don't have an 8-bit terminal.
09:28:33 <quicksilver> but how are you displaing the result?
09:28:43 <quicksilver> you do know that haskell standard IO isn't unicode clean?
09:28:44 <rwbarton> luqui: I'm not 100% sure :P  Mostly, I guess, (a) that class doesn't allow update, so you need a separate function for that; (b) creating a separate class for every record field name ever is a pain;
09:28:50 <quicksilver> you need to explicitly convert to your systems encoding
09:28:53 <quicksilver> before outputting.
09:29:14 <pastorn> well, f here is a function that takes a string and does toLower on all but the first character=]
09:29:16 <rwbarton> luqui: (c) if you don't create a separate class for each record name, and later you decide to reuse a record field name, now you have to change all the places you used native record update syntax.
09:29:20 <luqui> rwbarton, oh, that's not what I meant.
09:29:27 <quicksilver> pastorn: yes, but how are you observing the result?
09:29:36 <pastorn> writeFile "file.txt" $ unlines . map (unwords . map f . words) . lines $ x
09:29:39 <luqui> class Name as an alternative to record namespacing is indeed a bad idea!
09:29:46 <pastorn> so, e.g.
09:29:46 <quicksilver> pastorn: writeFile isn't unicode aware
09:29:47 <luqui> (class Name,etc. I should say)
09:29:51 <pastorn> wat?
09:29:54 <pastorn> WAT WAT WAT?!?!?!?!
09:29:57 <rwbarton> luqui: oh, you just mean class Named a where name :: a -> String ; instance Named Character where name = Character.name ; etc.?
09:30:03 <quicksilver> pastorn: none of System.IO knows anythign about unicode
09:30:08 <luqui> rwbarton, right
09:30:12 <quicksilver> pastorn: it's all naive 8 bit stuff
09:30:16 <pastorn> quicksilver: srsly?
09:30:20 <rwbarton> luqui: Oh, that's OK, but I don't think Wild_Cat needs it.
09:30:23 <quicksilver> pastorn: you need to explicitly choose an encoding if you want to get unicode output.
09:30:23 <luqui> aa soo
09:30:24 <besiria> pastorn: System.IO.UTF8
09:30:33 <pastorn> @hoogle writeFile
09:30:34 <lambdabot> A Hoogle error occurred.
09:30:44 <quicksilver> (by installing an encoding library)
09:31:07 <quicksilver> for example utf8-string
09:31:14 <quicksilver> which provides the module besiria is talking about.
09:31:17 <pastorn> ehm...
09:31:39 * pastorn starts synaptic...
09:31:40 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.3.1.1
09:31:42 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/5npojm
09:32:57 <Wild_Cat> all right. Thanks for all the advice, guys. Next steps: read up on what Haddock expects of my code, and learn to use gtk2hs.
09:33:39 <pastorn> ok, but readFile, is that UTF aware?
09:33:59 <Saizan> no.
09:34:21 <Saizan> System.IO.UTF8.readFile is
09:35:53 <Wild_Cat> oh, one more thing, is there a unused import detector somewhere (or a warning flag in GHC for that)?
09:36:12 <quicksilver> yes
09:36:22 <quicksilver> -fwarn-unused-imports or something?
09:36:34 <quicksilver> pastorn: nothing in Sytem.IO is unicode aware
09:36:43 <quicksilver> pastorn: I have already said this twice. Please believe me :)
09:36:47 <Wild_Cat> awesome.
09:36:53 <quicksilver> Wild_Cat: it doesn't work though.
09:36:55 <quicksilver> (not 100%)
09:36:58 <pastorn> but Char is and read/writeFile handles strings
09:37:06 <Wild_Cat> d'oh :D
09:37:06 <quicksilver> pastorn: I agree it is strange.
09:37:10 <quicksilver> it is nonetheless true.
09:37:11 <pastorn> indeed
09:37:23 <quicksilver> they couldn't decide which encoding to use
09:37:32 <quicksilver> UTF8 was not so widespread when System.IO was designed
09:37:36 <quicksilver> they deferred it to the implementor.
09:37:44 <quicksilver> GHC is about to change its implementation, in fact.
09:37:55 <quicksilver> the next version will assume UTF8, IIRC.
09:38:02 <Wild_Cat> that's good news.
09:38:04 <pastorn> niceness :D
09:38:04 <quicksilver> (but also provide binary facility)
09:38:08 <Wild_Cat> die ASCII die.
09:38:13 <besiria> quicksilver: u mean 6.10?
09:39:17 <quicksilver> besiria: I'm not 100% sure if it will be in 6.10
09:39:20 <quicksilver> don't remember.
09:39:31 <besiria> quicksilver: hope so.
09:40:51 <mmorrow> rwbarton: nice call, i fixed it proper.
09:41:32 <quicksilver> Wild_Cat: it's not bad (warn-unused-imports) but it gets confused by qualified or by recursive imports or something. I dont' actually remember what the problem is.
09:45:15 <Wild_Cat> quicksilver: right. Sounds much more complicated than whatever I'll end up doing. Seeing that 1. I like small, manageable units of code, and 2. With the "name" issue I can't make them too large anyway ;)
09:45:41 <Wild_Cat> with that, I'm heading home. Thanks for the advice everyone, and see you later.
09:46:06 <pastorn> @cabal
09:46:06 <lambdabot>   bzzt.
09:46:10 <pastorn> fine
09:46:29 <pastorn> is there some cabal 4 dummies page somewhere/
09:46:31 <pastorn> ?
09:46:49 <luqui> haskell.org/cabal?
09:48:28 <haskellian> rwbarton: not sure what u mean when I do: "reviews x" i get [Review] a one-elemnt list and I need Review, jsut the element. i need that to pass to update_customer which takes a Customer and a Review as arguments, i could ofc have [Review] as an argument but I know the list will always be elemnt long when parsing. later on when I need to "reviews x" it might be and often is a list of several reviews
09:49:25 <rwbarton> haskellian: ok, if you know that's always a one-element list
09:50:42 <b\6> how to convert PortNumber to PortID?
09:51:20 <reilly> So I've got this small utility function I've been using.  And it seems like it should already be around, but it isn't.  Which makes me wonder if I am "DOING IT ALL WRONG".  I wrote it because of the differences in Data.List.lookup and Data.Map.lookup.
09:51:50 <haskellian> not sure how to translate: filter foo . map bar $ list , should it be: filter filter_customer . map update $ list or something like that?
09:51:50 <rwbarton> reilly: is it called maybeToMonadPlus?
09:51:52 <reilly>  http://hpaste.org/9747
09:52:05 <reilly> rwbarton: YES!
09:52:25 <adekoba> b\6: PortNumber is one of the constructers of PortId. See http://hackage.haskell.org/packages/archive/network/2.2.0.0/doc/html/Network.html#t%3APortID
09:52:27 <rwbarton> reilly: yes, that doesn't exist.  There's some discussion about changing Data.Map.lookup to match Data.List.lookup (i.e., use Maybe)
09:52:27 <lambdabot> Title: Network, http://tinyurl.com/54q22f
09:52:41 <Zao> b\6: PortNumber is both a constructor and a type.
09:52:48 <reilly> i like the way Data.Map works better
09:54:22 <reilly> I'm using dons JSON library, which has got its own MonadPlus.  This makes me appreciate the more generic nature of Data.Maybe.lookup
09:54:55 <b\6> the problem is that connectTo wants a PortID, which is not showable. it makes more sense for my function to take a PortNumber, but connectTo won't take a PortNumber.
09:55:46 <pastorn> quicksilver: amagad!! it worked!!
09:57:02 <adekoba> b\6, you could do that. Just pass the port number to your function, then create a PortId with the given PortNumber so that you can pass it to connectTo. Alternatively, you could create a Show instance of PortID so that it only displays the PortNumber.
09:57:17 <yitz> reilly: some people have preference one way or the other between MonadPlus and Maybe, i've decided that i'll stay out of that, they're both fine. The problem is plain Monad and calling fail - most people agree that's bad, it could lead to crashes.
09:57:44 <Zao> @type Network.PortNumber (4242)
09:57:45 <lambdabot> Network.PortID
09:58:28 <rwbarton> reilly: here's some discussion: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/9082/
09:58:31 <lambdabot> Title: Gmane Loom
09:58:53 <Zao> There's both PortNumber the PortID contructor and PortNumber the numericish type.
09:59:00 <Zao> PortNumber takes a PortNumber argument.
09:59:04 <luqui> fail might as well be "error"
09:59:14 <luqui> "fail" is hardly part of what a Monad is...
09:59:38 * luqui wonders if do blocks with refutable patterns should automatically forc e to MonadPlus... hmm...
09:59:46 <yitz> luqui: unless it happens to be a MonadPlus, in which case you might as well use mzero.
10:01:48 <yitz> luqui: perhaps the compiler should issue a warning, like it does for pattern matching on function definitions or case.
10:04:48 <ddarius> luqui: That's how it used to work.
10:06:21 <yitz> ddarius: that Map.lookup was a Maybe? Or that refutable pattern matching in a do block requires a MonadPlus instance?
10:06:23 <Philippa_> ddarius: what were the recorded reasons for changing it?
10:07:08 <ddarius> yitz: The latter.
10:07:25 <yitz> ddarius: really? when was that?
10:07:26 <ddarius> Philippa_: I don't know.  I hear tell that it was to make the rules "simpler"
10:07:35 <ddarius> yitz: Read the Haskell 1.4 Report.
10:07:44 <yitz> interesting.
10:08:06 <dons> has anyone looked at ashley's witness and open-witness libraries?
10:08:10 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/open-witness-0.1
10:08:18 <lambdabot> Title: HackageDB: open-witness-0.1, http://tinyurl.com/5jlq4b
10:08:53 <thetallguy> not yet, but I'm interested
10:08:53 <dons> dcoutts: can we do admin recategorisation and tagging in the new hackage?
10:13:21 <haskellian> can someone tell me how to use Maybe because i dont get it, if something returns: Maybe (Int, B.ByteString), how do i get the int?
10:13:59 <b\6> match like Just (i, _) -> do something with i
10:14:00 <luqui> haskellian, pattern match
10:14:00 <dons> case foo of Nothing -> ...
10:14:06 <dons>      Just (n, _) -> n
10:14:12 <yitz> @type maybe
10:14:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:14:14 <dons> haskellian: you're using readInt ? :)
10:14:17 <adekoba> Maybe is a type, and Maybe and Nothing are its constructors. You could patern match, or use the various functions in Data.Maybe (i.e fromJust, etc.)
10:14:19 <yitz> @type fromMaybe
10:14:21 <lambdabot> forall a. a -> Maybe a -> a
10:14:26 * luqui found "maybe" (the function) hard to use for a long time
10:14:49 <haskellian> where is IntMap?
10:14:52 <dons> haskellian: like this example, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
10:14:54 <Deewiant> ?index IntMap
10:14:55 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language ..., http://tinyurl.com/ys3ony
10:14:55 <lambdabot> Data.IntMap
10:15:11 <luqui> fromMaybe is nice.  I wish it were prelude...  (not that I care too much)
10:15:47 <yitz> luqui: the trick is to start by using fromMaybe which at first seems more obvious - very quickly you see why you'd rather have maybe most of the time
10:15:50 <Deewiant> fromMaybe =  flip maybe id
10:16:01 <luqui> yitz, disagree.
10:16:08 <luqui> I knew about maybe first, and used that for a while
10:16:17 <luqui> only to notice that the second arg was usually id
10:16:29 <yitz> luqui: :) ok
10:24:09 <ddarius> dons: Why don't you have the hackage bot automatically build Arch packages?
10:28:09 <dons> ddarius: yeah, i've been meaning to do that.
10:28:12 <dons> basically rss2io
10:28:17 <pastorn> is there any Trie implementation?
10:28:23 <dons> where you can hook an io action to be performed on an rss update
10:28:27 <pastorn> on hackage or somewhere else?
10:28:30 <dons> then use rss to trigger events
10:28:38 <dons> pastorn: there's a lot floating around
10:29:33 * pastorn is making his own as well...
10:30:05 <pastorn> data Trie a = T { thisElem :: a, isEnd :: Bool, sub :: Trie a , other :: Trie a } | EmptyTrie
10:30:43 <b\6> something like hGetLine for \r\n lines?
10:33:10 <pastorn> i'm doing it like this "insert :: Eq a => [a] -> Trie a -> Trie a", but maybe i'm doing it wrong... i only have dictionaries in mind here...
10:33:39 <pastorn> is there som more general way that i'm not thinking of that in can be done ("a" instead of "[a]")
10:39:02 <ddarius> pastorn: Wouldn't a Trie be more like data Trie k v = Trie (Map k (Trie k v)) | Leaf v ?
10:39:15 <geezusfreeek> i can't wait for data parallel haskell
10:39:41 <geezusfreeek> i'm doing a bunch of matrix math for the netflix challenge
10:39:42 <pastorn> ddarius: might be... as i said, i was just thinking of storing a word list...
10:41:16 <luqui> pastorn, like generalized tries?
10:41:24 <haskellian> i dont have IntMap it seems
10:41:33 <luqui> haskellian, Data.IntMap?
10:41:40 <luqui> you must!  what compiler are you using?
10:41:48 <pastorn> ddarius: where would you store more of the same letter on one level? say that you want to store three words, "ab", "ba" and "bb"
10:42:07 <b\6> i've been naming members of my records like blah_ to hopefully prevent collisions. something better?
10:42:15 <haskellian> ok im dumb as usual i have Intmap
10:42:46 <b\6> i mean if the record is Blah, member is blah_whatever.
10:42:52 <pastorn> then on each level won't you need a pointer to the next Trie for a notter on the same place in the word and then a pointer to the apropriate subtree
10:43:17 <ddarius> pastorn: That would be Trie (Map.fromList [('a', Leaf "b"), ('b', Trie (Map.fromList [('a', Leaf ""), ('b', Leaf "")]))])
10:43:26 <geezusfreeek> haskellian: if you ever truly believe you don't have a "standard" library you can still get most of them on hackage
10:43:59 <geezusfreeek> for example, opengl/glut are omitted from ghc on some platforms
10:44:20 <geezusfreeek> err, i think i meant openal
10:44:33 <haskellian> i want this to return an Int: mov_id = fromMaybe B.readInt . head
10:44:35 <haskellian> meh
10:44:37 <haskellian> how?
10:44:44 <pastorn> ddarius: riiiight, now i see it, the "Map k" part is able to hold lots of different keys :)
10:44:57 <pastorn> Map is a binary tree, right?
10:45:10 <Deewiant> ddarius: Map has an Ord constraint, Trie shouldn't
10:45:21 <ddarius> pastorn: Yes, though that doesn't really matter.  You could use something other than a Map.
10:45:28 <luqui> b\6, that goes nicely with data-accessor :-)
10:45:45 <b\6> luqui: i'll check. thanks.
10:45:46 <geezusfreeek> haskellian: B is ByteString?
10:46:13 <ddarius> Deewiant: Usually tries are used for strings and there is an ordering and the typical way uses something like an array in which case you need a way to map characters to numbers which is stronger than ordering.
10:46:29 <ddarius> Anyway, I need to return to work.
10:46:39 <haskellian> geezus: yes ByteString.Char8
10:46:47 <b\6> heh, there's a core/ dir and haskell.org's http server thinks it's the result of a segfault.
10:47:49 <Deewiant> ddarius: usually typically possibly, but we're writing a generic implementation here where all you should need is data Trie a = Data.Tree.Tree (Bool,a) :-)
10:47:55 <bos> more book news: http://www.reddit.com/comments/6wuko/real_world_haskell_2_new_chapters_ffi_and_stm_and/
10:48:02 <lambdabot> Title: Real World Haskell: 2 new chapters (FFI and STM!) and an endgame update : reddit ..., http://tinyurl.com/64mdzn
10:48:28 <bos> please to be upvoting.
10:48:47 <geezusfreeek> :t maybe 0 fst . Data.ByteString.Char8.readInt . head
10:48:48 <lambdabot> [BSC.ByteString] -> Int
10:48:49 <paczesiowa> sir, yes sir!
10:49:00 <luqui> Deewiant, is that work in progress public?
10:49:01 <geezusfreeek> haskellian: something like ^?
10:49:09 * luqui is reading generalizing generalized tries now
10:49:30 <Deewiant> luqui: eh? sorry, poor wording, I'm not working on such a thing
10:50:08 <luqui> Deewiant, but someone is?
10:50:38 <Deewiant> luqui: pastorn is evidently
10:50:55 <Myoma> that getStatus function is crazy
10:51:10 <yitz> @seen guenni
10:51:11 <lambdabot> guenni is in #haskell. I last heard guenni speak 4h 26m 48s ago.
10:51:15 * luqui thinks there's been some misunderstanding and drops the issue
10:52:35 <dons> please to be reviewing new RWH chapters, if you please :)
10:52:48 <dons> so we can fire up the printing presses real soon now.
10:52:48 <glguy> please
10:53:22 <Deewiant> dons: the GHCi output in the STM chapter is borked
10:53:44 <Deewiant> dons: evidently it can't find Control.Concurrent.STM and thus almost nothing worked
10:53:48 <Myoma> is that getStatus function supposed to be so indented ?
10:53:56 <dons> bos ^^
10:54:11 <dons> bos, looks like a missing header in the .ghci input.
10:54:13 <Trinithis> dons: The ghci box after "If we run this in ghci, it behaves as we should expect." Is bad
10:54:22 <dons> Trinithis:  comment on the site!
10:54:34 <Trinithis> ah
10:54:35 <Deewiant> Trinithis: that's what I said, you'll see it's bad further down as well
10:55:05 <rwbarton> dons: you guys are still interested in comments on every chapter, right?
10:55:11 <dons> rwbarton: right.
10:55:16 <dons> but specifically those new ones.
10:55:24 <dons> the older ones have had lots of attention
10:55:51 <dons> just be sure to use the lovely online commenting system.
10:55:53 <haskellian> is that == fst . B.readInt . head
10:56:12 <haskellian> maybe 0 fst . B.readInt . head
10:56:12 <Myoma> :t maybe 0 fst
10:56:14 <lambdabot> forall a b. (Num a) => Maybe (a, b) -> a
10:56:14 <Myoma> :t fst
10:56:15 <lambdabot> forall a b. (a, b) -> a
10:57:27 <geezusfreeek> haskellian: it takes the head of a list, tries readInt on it, and if it succeeds returns the Int otherwise returns 0, which sounds very C-like to me ;)
10:58:20 <geezusfreeek> where the Int is the first component of the pair returned inside the Maybe returned by readInt
11:01:19 <Trinithis> IS Bytestring just a more efficient String?
11:01:33 <dons> just a more efficient string, yes :)
11:01:38 <Deewiant> not quite
11:01:43 <bos> eek, broken stm examples fixed.
11:01:49 <dons> sweet.
11:01:53 <geezusfreeek> one is arrays, one is lists, no?
11:01:54 <Deewiant> a String holds UTF-32 code units, a ByteString holds bytes :-)
11:01:59 <geezusfreeek> oh and that
11:02:10 <Trinithis> Meaning only ascii?
11:02:22 <Deewiant> meaning bytes
11:02:28 <Deewiant> interpret them as you wish
11:02:30 <Zao> Meaning whatever you want them to mean.
11:02:37 <Trinithis> :D
11:02:41 <sbahra> Why UTF-32?
11:02:48 <Deewiant> if it was only ascii, that'd be wasting one bit per character ;-)
11:02:49 <sbahra> And not UTF-8.
11:03:07 <Deewiant> I think Char may be older than UTF-8 :-P
11:03:08 <glguy> A String holds Unicode codepoints
11:03:16 <Deewiant> but it's more convenient for simple cases
11:03:18 <glguy> UTF-8 is an encoding
11:03:35 <Deewiant> or rather, it's more convenient always, just not very performant
11:03:59 <Deewiant> with UTF-32 you don't have to worry about accidentally slicing off half a code point
11:04:03 <Deewiant> for instance.
11:04:33 <BMeph> bos: re-ran the STM example, and placed my results in a comment box. :)
11:05:29 <Trinithis> Well I gtg scrape paint off some gutters :(
11:05:32 <Trinithis> @faq Can Haskell help me scrape paint?
11:05:33 <lambdabot> The answer is: Yes! Haskell can do that.
11:05:43 <glguy> sbahra: UTF-32 is barely an encoding, its just a 4 byte number from 0 to 0x10ffff
11:05:54 <glguy> no special logic to it
11:06:01 <sbahra> glguy, I see
11:06:28 <BMeph> bos: My version doesn't print "Gold 9", just "9".
11:06:29 <sbahra> Haskell should get fribidi bindings, would be nice.
11:06:53 <dons> sbahra: it gets them by you doing an FFI binding :)
11:07:08 <dons> and now the FFI chapter's up, there's no excuse not to do it ...
11:07:19 <geezusfreeek> :)
11:07:38 <bos> BMeph: ah, that's because i reveal the type signature a little lower down, once i introduce the STM monad.
11:07:59 * sbahra looks it up
11:08:43 <sbahra> dons, ah, I see
11:08:45 <sbahra> dons, cool
11:11:02 <trofi> does haskell support C
11:11:08 <trofi> ++ bindings?
11:11:19 <dons> trofi: it can be to C++, but it's not as easy as C.
11:11:27 <dons> see, however, the QtHaskell bindings
11:11:37 <trofi> so i nave to cobe with magling myself?
11:11:46 <trofi> ah, ok. i'll try
11:11:48 <dons> the mangling is the question.
11:15:09 <trofi> how about calling reentrant c_function from different forkedOS? are they executed in parallel physically? (if OS threads - are linux NPTL)
11:17:46 <Deewiant> bos: commenting hits a 404 so I'll say it here: after 'runhaskell Enum.hs', the output should end in a ']'
11:17:56 <Deewiant> in the FFI chapter
11:18:17 <bos> a 404? huh.
11:18:26 <Deewiant> that's what firebug says
11:18:44 <Deewiant> an earlier comment worked
11:19:45 <dons> hmm
11:20:12 <dons> Deewiant: on saving the comment?
11:20:18 <Deewiant> yeah, on submit
11:20:37 <dons> oh , i see what you're about to comment on :)
11:20:38 <dons> missing ]
11:20:40 <Deewiant> might be just that one: firebug says it tries a POST to the 404-inducing http://book.realworldhaskell.org/comments/submit/id584387/
11:21:10 <Deewiant> http://book.realworldhaskell.org/comments/single/id584387/ exists, though
11:22:59 <haskellian> bah I cant find an example f unionWith and im still bad at understanding type declarations, unionWith takes function + list + list ?
11:23:24 <dons> :t Data.IntMap.unionWith
11:23:25 <lambdabot> forall a. (a -> a -> a) -> IM.IntMap a -> IM.IntMap a -> IM.IntMap a
11:23:49 <dons> so it takes two maps, and returns their union, using a function to decide which element to take when there's an overlap
11:27:35 <haskellian> why do i need that? i have lists, not maps, should i redo all?
11:28:36 <dons> oh, you're using unionWith on lists?
11:28:41 <dons> ?hoogle unionWith
11:28:41 <lambdabot> A Hoogle error occurred.
11:28:45 <dons> Cale.
11:28:54 <Myoma> ?go generic merge
11:28:57 <lambdabot> http://www.reddit.com/comments/6weld/a_generic_merge_function/
11:28:57 <lambdabot> Title: A generic merge function : reddit.com
11:29:10 <dons> haskellian: which unionWith function are you using?
11:30:25 <rwbarton> haskellian: I doubt lists are the best data structure for your problem
11:32:33 <sioraiocht> i <3 xmonad
11:34:04 <b\6> have to say (<3)
11:36:13 * luqui likes xmonad a lot.  I don't know if I'm ready to say I love it.
11:37:29 <dons> luqui: what stops you from loving it? :)
11:38:39 <Brostar> hiho
11:38:42 <haskellian> rwbarton: maybe not but they are flexible, what do you suggest, Maps? is that a Binary Search tree?
11:38:43 <Brostar> sooo funny - http://i8t.de/aw6tdj7h
11:38:47 <lambdabot> Title: Mein privates Nacktvideo zu Hause
11:38:51 --- mode: ChanServ set +o dons
11:38:55 --- kick: Brostar was kicked by dons (dons)
11:39:03 <haskellian> because i got the impression they were hashtables, but key-values, whyd i need that?
11:39:08 --- mode: ChanServ set -o dons
11:39:14 <dons> haskellian: they're trees
11:40:25 <haskellian> if i sort all customer son idnumbers first, then update them would that be faster or slower?
11:41:33 <rwbarton> haskellian: that will help for merging two roughly equal sized lists of customers, but not for inserting a single new customer into a list
11:42:51 <Philonous> xmonad is great indeed. Underneath a layer of sheer uglyness there is enlightening simplicity and elegance to be found.
11:43:00 <dons> it's ugly?
11:43:04 <Myoma> "layer of sheer uglyness" lol
11:43:05 * dons feels conflicted.
11:43:06 <Philonous> At first glance
11:43:07 <rwbarton> haskellian: you should work out what kind of operations you need to do and how often, and then choose the data structure that makes them as fast as possible
11:43:23 <dons> Philonous: i'd love to know what aspects you felt were ugly
11:43:32 <jberg> in xmonad, what do you use as a mod key? wont alt interfere with emacs or other programs?
11:43:47 <Philonous> jberg it does, that's why I use super
11:43:55 <stepcut> jberg: the 'windows' key
11:43:55 <jberg> super?
11:43:57 <jberg> oh
11:44:00 <Philonous> windows key
11:44:10 <jberg> how can i configure to use windows key?
11:44:47 <dons> faq
11:44:59 <dons> http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Rebinding_the_mod_key
11:45:01 <lambdabot> Title: Xmonad/Frequently asked questions - HaskellWiki, http://tinyurl.com/3a2duf
11:45:36 <jberg> thanks
11:45:53 <stepcut> jberg: the windows keys is usually, mod4Mask
11:46:43 <stepcut> jberg: and, if you know a way to reliably detect if the user's keyboard has a windows key, that would be quite useful ;)
11:47:37 <jberg> okay so just create a xmonad.hs and put main = xmonad defaultConfig { modMask = mod4Mask } and thats it?
11:47:41 <jberg> stepcut: i dont :)
11:47:43 <dons> that's it.
11:47:48 <jberg> cool
11:48:10 <dons> you're passing xmonad a new configuration structure, with defaults overridden.
11:48:18 <jberg> yep
11:48:40 <chrisdone> mmkay, I'm writing this little IRC bouncer, http://paste.lisp.org/display/65498 -- should I implement PING'ing of the client? it seems that if I uncleanly disconnect the client, it has no idea about it, so maybe I should implement ping every 10 seconds or whatever
11:48:44 <Philonous> dons: I was jused to the bling-bling of other wms and the purism of a tiling window manager needs getting used to
11:48:51 <jberg> but im worried my laptops 15 inch will be to small for xmonad, like you have to have at least two screens before xmonad is useful, or is this not the case?
11:49:19 <Philonous> jberg the less screen space you have, the more you wanna safe of it.
11:49:22 <dons> Philonous: it's not so much about purity, just a different paradigm
11:49:35 <dons> restricting the range of motion to the subset that can be automated.
11:49:44 <jberg> Philonous: yes thats true
11:49:45 <stepcut> jberg: surely you have more space than this, http://xmonad.org/images/openmoko-nomeata.jpg
11:50:16 <jberg> stepcut: haha, i do :)
11:50:46 <gwern> @fortune
11:50:46 <lambdabot> Couldn't find fortune file
11:50:54 <dcoutts> dons: re: admin recategorisation and tagging in the new hackage, yes but it's not yet implemented :-)
11:51:04 <jberg> but i cant find documentation on the keybindings and what they do
11:51:06 <Philonous> dons: That too, of course. Actually xmonad isn't ugly at all, it just virtually nonexistent (on the screen)
11:51:13 <adekoba> jberg, you certianly don't need two monitors.
11:51:43 <chrisdone> I realise I might as well use literate haskell for that code
11:51:55 <dcoutts> dons: changing category tags on individual packages should be straightforward, it's just part of editing the .cabal file for the package. Doing mass tag reassignments might be better handled differently.
11:52:08 <stepcut> jberg: I use xmonad to open all the windows fullsize, except on the screen with pidgin
11:52:37 <jberg> but i need to documentation on which keys to use.. cant find it on xmonad.org
11:53:03 <adekoba> jber, http://www.haskell.org/haskellwiki/Xmonad/Config_archive/Template_xmonad.hs_%280.7%29
11:53:05 <lambdabot> Title: Xmonad/Config archive/Template xmonad.hs (0.7) - HaskellWiki, http://tinyurl.com/6lh6rd
11:53:10 <adekoba> jberg*
11:53:28 <jberg> okay thanks
11:53:48 <adekoba> yeah. As dons said, those are the defaults, and you can just override them with { ... }
11:54:50 <Philonous> jberg: the documentation is somewhat hidden on the site. http://www.xmonad.org/tour.html
11:54:51 <lambdabot> Title: xmonad : a guided tour
11:54:54 <gwern> lambdabot has an impressive number of now-broken plugins
11:55:15 <jberg> ah okay
11:55:45 <jberg> but what do you use if you want a menu or something to start applications from? mainly firefox and emacs
11:56:15 <Philonous> You can use it together with GNOME, KDE and XFCE
11:56:25 <stepcut> jberg: I use the gnome panel thing (whatever it's called)
11:56:56 <gwern> dons: I've been trying to figure out but what is this Plugin.hs and its 'PLUGIN Hello' stuff in lambdabot ?
11:56:57 <adekoba> dmenu is also good for keyboard oriented wm's.
11:57:20 <jberg> oh alright
11:57:28 <gwern> XMonad.Prompt is better
11:57:59 <sjanssen> gwern: they're BotPP directives
11:58:17 <gwern> sjanssen: yes, I know, but what do they gain us over importing Plugin?
11:58:26 <stepcut> jberg: this is my config, http://hpaste.org/9748, you can use mod-b to make the dock appear/disappear
11:58:34 <gwern> it says something about abstracting
11:58:35 <gwern> but what is that supposed to mean?
11:58:47 <guenni> anybody know an easy tutorial for haxml, I just don't get the stuff that comes with it
11:59:04 <sjanssen> gwern: it does more than just imports
11:59:12 <sjanssen> gwern: look at the source in scripts/BotPP.hs
11:59:39 <stepcut> jberg: or mod-p if you want to type in the name of the app to launch (and you have dmenu installed)
12:00:03 <stepcut> jberg: also, this discussion probably belongs in #xmonad by now
12:00:06 <jberg> stepcut: hmm ok. i think i have to read a bit on configuration
12:00:11 <jberg> yes okay
12:01:09 <jberg> one last thing, i did aptitude install xmonad, now i should just quit gnome, start it again and i can choose and xmonad session?
12:01:18 <gwern> sjanssen: I have, but it's unclear to me. I've tried running BotPP but I haven't hit upon a working example
12:01:39 <gwern> [orig,i,o] <- getArgs is pretty lousy documentation
12:01:48 <gwern> three arguments? what?
12:01:57 <gwern> a source file, a name, and a something?
12:01:59 <gwern> I dunno
12:02:48 <stepcut> jberg: maybe. sometimes if you do mod-q (i think?) xmonad will automaticall recompile and restart. But I am not sure exactly what needs to be in place for that to happen.
12:02:52 <sjanssen> gwern: it creates a newtype called Module
12:02:59 <adekoba> output?
12:03:14 <sjanssen> and a value theModule
12:03:33 <sjanssen> gwern: it also collects all results to generate a list of all used modules
12:04:05 <gwern> hm. this is a nice cabal behaivour - all Librarys are built before Executables
12:04:10 <gwern> @seen dcoutts
12:04:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 12m 15s ago.
12:04:19 <dcoutts> gwern: mm?
12:05:03 <gwern> dcoutts: I'm working on lambdabot. the cabal goes: executable, library, executable executable. the first executable is needed for the library, but the library gets built first
12:05:07 <gwern> this is a problem, currently
12:05:40 <dcoutts> gwern: sorry, you can't do that 'til cabal supports build-depends and build-tools from within the same package.
12:05:47 <gwern> dcoutts: although I've learned a neat solution to my old greencard problem from lambdabot - ghc-options:  -pgmF dist/build/BotPP/BotPP
12:05:48 <sjanssen> gwern: once I tried to rip out BotPP, it only requires a bit more boilerplate
12:05:50 <gwern> nooo
12:06:16 <dcoutts> gwern: ghc-options:  -pgmF dist/build/BotPP/BotPP is evil. It will break if someone changes the dist dir.
12:06:16 <gwern> sjanssen: anyway to do botpp in place?
12:06:40 <gwern> I never said it was good, just neat :)
12:07:02 <dcoutts> gwern: I'll add a check to stop people using it ;-)
12:07:07 <sjanssen> gwern: you could try 'runghc scripts/Botpp.hs', but that is ugly and won't work everywhere
12:07:14 <dcoutts> any paths in a .cabal file that start dist/ are broken.
12:07:33 <gwern> dcoutts: so I guess I need to split botpp out to a separate package if I want to use it?
12:07:38 <gwern> sjanssen: what are the other arguments?
12:08:02 <sjanssen> gwern: by the way, what's the point of making lambdabot a library?
12:08:12 <dcoutts> gwern: once cabal supports intra-package build-tools/depends it'll work. In the mean time I suggest you just build botpp in Setup.hs before build.
12:08:13 <sjanssen> gwern: GHC provides them, it is run as a pre-processor
12:08:49 <stepcut> sjanssen: so that you can reuse lambdabot features in other applications
12:08:53 <gwern> sjanssen: I have a dream that one day everything in Plugins/ will be a independent library used by preflex, lambdabot, stepcut's bot, and my hypothetical mubot
12:09:23 <gwern> also, making the core a library simplifies understanding what the heck is going on during the build
12:09:33 <stepcut> gwern: exactly. The interesting parts of my bot are not the wrappers to call djinn, mueval, etc
12:09:40 <gwern> and you have to enumerate modules *anyway* if you want sdist to work
12:09:45 <sjanssen> oh, so stepcut has a bot, eh?
12:09:55 <sjanssen> stepcut: does it have a source repository?
12:10:12 <stepcut> sjanssen: yeah, http://src.seereason.com/happs-bot
12:10:13 <lambdabot> Title: Index of /happs-bot
12:10:30 <stepcut> sjanssen: currently it only supports 'hello' and 'get-shapr'. *But* it also supports multimaster replication ;)
12:10:32 <gwern> stepcut: right. bots should not have to rewrite all that stuff. I mean, for most of the plugins, the entire API is 'plugin :: String -> IO String'!
12:10:46 <dcoutts> stepcut: hah hah, nice
12:11:01 <sjanssen> gwern: but for 50%, it's much more complicated
12:11:13 <Myoma> IO ??
12:11:14 <stepcut> as the name implies, the bot uses HAppS-State for the persistance and multimaster replication
12:11:17 <sjanssen> I don't think you'll find a satisfying abstraction that fits both
12:11:43 <luqui> Myoma, eg. hoogle?
12:11:45 <gwern> Myoma: well, obviously if you call out to the shell for hoogle/mueval/djinn...etc. the result has to be IO String
12:11:49 <stepcut> which means that it's data store is thread-safe, so I can process multiple requests in parallel
12:12:14 <gwern> brainfuck/unlambda...
12:13:18 <gwern> sjanssen: actually, I had a thought - perhaps I could copy the processed .hss from dist/ back over the originals
12:14:03 <sjanssen> gwern: mwahahaha
12:14:56 <sjanssen> gwern: yeah, that'll work.  New plugins will need to write the requisite boilerplate, but that isn't so bad
12:16:28 <haskellian> If I understand correctly, this function:filter (>20) . map (\x -> x*x) $ [1..10] will be faster than filter (>20) $ map (\x -> x*x) $ [1..10] ? Because in the first one the map and filter is done per element whereas in the second one the list is first mapped completely then traversed again while filtering. correct?
12:16:53 <gwern> sjanssen: if it's a problem, a little TH will fix it?
12:16:58 <eu-prleu-peupeu> hey, how do i specify a function that gets no arguments ?
12:17:07 <eu-prleu-peupeu> f :: type ?
12:17:13 <stepcut> eu-prleu-peupeu: yep
12:17:22 <eu-prleu-peupeu> sweet
12:17:25 <haskellian> But not all composable functions are possible to do at the same time, how does the compiler woth that out?
12:17:48 <gwern> @code
12:17:48 <lambdabot> Maybe you meant: more todo vote
12:17:49 <sjanssen> gwern: TH can't generate the boilerplate required in Main.hs, though
12:17:56 <luqui> is there a way to import modules on the command line for ghc -e ?
12:18:00 <sjanssen> (TH can't change the imports of a module, AFAIK)
12:18:48 <gwern> that's what I heard
12:19:11 <stepcut> haskellian: I think it is quite likely that those two variations will end up the same after the optimizer is done
12:19:46 <EvilTerran> indeed they will, because of laziness
12:19:49 <EvilTerran> (amoung other things)
12:19:54 <ekidd> Is there a recent update on the status of Data Parallel Haskell?
12:20:11 <rwbarton> haskellian: even without optimization, the first reduction of "filter (>20) . map (\x -> x*x) $ [1..10]" will be to expand the definition of (.), resulting in the other expression
12:20:25 <luqui> haskellian, (f . g) x = f (g x), by definition, so they will expand to exactly the same thing
12:20:26 <japar> I have a beginner question.  Should maximum [1..1000000] cause a stack overflow exception?  That's what I'm getting but it doesn't make sense to me.
12:20:58 <luqui> @quote 6.1 surround
12:20:58 <lambdabot> No quotes for this person. You untyped fool!
12:21:00 <luqui> :-)
12:21:03 <gwern> @cockney Hey guv
12:21:04 <lambdabot> Unknown command, try @list
12:21:16 <Myoma> > (maximum [1..1000000] :: Int, maximum [1..1000000] :: Integer)
12:21:18 <gwern> hm. how many dead plugins are there?
12:21:19 <lambdabot>  (1000000,
12:21:22 <Zao> japar: It'll evaluate into something like (max 1 (max 2 (max 3( ... 100000))))))))
12:21:27 <gwern> code, fortune, languages,...
12:21:42 <Myoma> maximum is strict for Int and lazy for Integer
12:21:43 <stepcut> japar: yes, but for really obscure reasons
12:21:55 <luqui> Myoma, if you compile with optimization it won't be a stack overflow
12:22:08 <luqui> er, japar ^
12:22:31 <luqui> ghci just isn't seeing that maximum is strict.
12:23:26 <japar> Can anyone explain why it does overflow?  I would think lazy or not it is tail recursive and would take a constant amount of stack space.  I feel like I'm missing something fundamental.
12:24:04 <rwbarton> @src maximum
12:24:05 <lambdabot> maximum [] = undefined
12:24:05 <lambdabot> maximum xs = foldl1 max xs
12:24:05 <Myoma> japar: tail recursion in a lazy language is a reason for stack overflows
12:24:56 <rwbarton> > maximum (replicate 1000000 (5 :: Integer))
12:24:58 <lambdabot>  5
12:25:11 <rwbarton> > maximum [1..1000000 :: Integer]
12:25:13 <lambdabot>  1000000
12:25:26 <stepcut> japar: in calculating the next value, it keeps applying succ to the previous value. So buy the time you get to 1000000, you have succ applied 999999 times to the original value. But, because of lazy evaluation it has not actually evaluated those succ's. (that is sort of what is happening, but not quite right)
12:27:08 <luqui> > foldl' max 0 [1..10000000]
12:27:11 <lambdabot>  Tried to use too much memory
12:27:12 <luqui> > foldl' max 0 [1..1000000]
12:27:15 <lambdabot>  1000000
12:27:17 <rwbarton> 'maximum [1..1000000] :: Int' is a stack overflow in ghci (just like :: Integer)
12:27:32 <Myoma> > foldl' max 0 [1..5000000]
12:27:35 <lambdabot>  Tried to use too much memory
12:27:41 <luqui> bisect!   (no, don't)
12:27:47 <Jedai> japar: The thing is that foldl doesn't need the value of it's second parameter (it's lazy in it's second parameter), so instead of evaluating immediately each max, it accumulate those in a very big thunk and when you try to evaluate this big thunk... bam
12:28:10 <Jedai> japar: maximum = foldl1 max
12:28:31 * luqui realizes that if he were japar, he would have no idea what you guys are talking about
12:28:33 <rwbarton> japar: there's a pretty good explanation at http://www.haskell.org/haskellwiki/Stack_overflow
12:28:34 <lambdabot> Title: Stack overflow - HaskellWiki
12:29:04 <japar> Thanks, I'll take a look
12:29:18 * gwern sighs. Plugin.Paste is broken for compile, even
12:29:32 <luqui> yeah, that one's pretty good.  suffice to say, it's a subtle issue.  it's an instance of haskell's biggest (essential) problem, IMO
12:29:39 <japar> So what would be the proper way to find the maximum of a list of integers then?
12:29:52 <luqui> using maximum
12:29:54 <Jedai> stepcut: Your explanation is wrong, because [1..10000] don't accumulate the succ ([1..] does though)
12:30:03 <luqui> japar, just not in ghci
12:30:20 <Myoma> @src foldl1
12:30:20 <stepcut> Jedai: right. by explaining is definitely wrong in this case.
12:30:21 <lambdabot> foldl1 f (x:xs) = foldl f x xs
12:30:21 <lambdabot> foldl1 _ []     = undefined
12:30:35 <stepcut> Jedai: I just don't have time to figure out the real reason at the moment
12:30:36 <Myoma> @src foldl
12:30:37 <lambdabot> foldl f z []     = z
12:30:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:30:48 <Jedai> japar: With optimisation, maximum will behave correctly, if you need it in ghci, use foldl1' max instead
12:30:59 <luqui> where foldl1' is from Data.List
12:32:25 <Jedai> stepcut: http://www.haskell.org/haskellwiki/Stack_overflow
12:32:27 <lambdabot> Title: Stack overflow - HaskellWiki
12:32:57 <Jedai> stepcut: I gave an explanation (that is correct) a little bit before, and you can read this url for something more understandable
12:33:08 <stepcut> Jedai: will do
12:33:10 <stepcut> Jedai: thanks
12:34:16 <Botje> h
12:34:33 <japar> Thanks for the link.  The stack overflow wiki page explained exactly what my problem is.  I'll have to study it more to make sense of it.
12:34:41 <Jedai> japar: Arguably, doing "maximum = foldl1' max" could be better, but there are some use case where the lazy version could actually be useful
12:36:06 <Jedai> which is why it's still like that in the library despite the occasional question by a surprised beginner
12:36:52 <japar> Thanks for the help everyone.  I'll use foldl1' max, and I guess that should solve my problem.
12:36:58 <EvilTerran> we should have maximum' and minimum', i guess
12:37:05 <EvilTerran> that's how i'd do it, anyway
12:41:45 <gwern> @ask dcoutts could you do me a huge favor? could you grep the cabal sources and replace every 'compatability' with 'compatibility'? it is driving me *NUTS* to see that misspelled word everytime I configure
12:41:46 <lambdabot> Consider it noted.
12:42:09 <czShadoW> :-)
12:42:41 <dons> gwern: you need to relax. :)
12:42:57 <gwern> dons: I've seen that misspelling thousands of times now
12:43:04 <gwern> I only have so much endurance
12:44:37 <hansfbaier> ï»¿to whom it may concern: I just finished writing JACK MIDI bindings for Haskell (which is great to mangle / monitor MIDI messages on the fly for ardour development or even music production). This is what a basic client looks like http://hpaste.org/9750 (It just prints the input message on the screen and forwards it to its output port)
12:45:04 <dons> great.
12:45:09 <dons> will you upload the library to hackage?
12:45:41 <hansfbaier> dons: I sent the patch to Soehnke Hahn for his package Sound.JACK
12:45:53 <dons> cool
12:46:11 <gwern> hansfbaier: out of curiosity - you using emacs' haskell-mode and the pretty lambda stuff?
12:46:19 <hansfbaier> dons: But the API is preliminary ATM.
12:46:32 <hansfbaier> gwern: I use leksah ATM.
12:46:42 <gwern> hm, interesting
12:46:54 <gwern> didn't know leksah did the unicode replacement
12:46:59 <hansfbaier> gwern: But I got haskell-mode installed too, what is the pretty lambda stuff?
12:47:12 * gwern refers to 'foo âˆ· (MidiEvent â†’ IO MidiEvent)' eg
12:47:35 <paczesiowa_> pretty lambda stuff is those ugly squares:>
12:47:56 <SamB> gwern: hmm, I'm not quite sure how âˆ· qualifies as pretty!
12:48:01 <SamB> it's so ill-supported ...
12:48:12 <gwern> paczesiowa_: if you have decent fonts, a prettylambda'd buffer looks a hell of a lot nicer
12:48:17 * BMeph goes 'Holy CRAP!" at the double-colon glyph
12:48:26 <gwern> ill-supported? wut
12:50:52 * Myoma thinks : is more pretty than ::
12:51:15 <SamB> MyCatVerbs: :: is often prettier than âˆ·, though
12:51:25 <gwern> : is stolen already for lists
12:51:59 <BMeph> Myoma: Haskell reverses the use of ':' and '::'
12:52:14 <BMeph> (in comparison to ML and OCaml)
12:53:36 * gwern tries fixing hoogle in lambdabot 
12:54:34 <gwern> woot, it worked!
12:54:47 <paczesiowa> @hoogle map
12:54:47 <lambdabot> A Hoogle error occurred.
12:54:57 <gwern> 'lambdabot> hoogle head
12:54:59 <gwern> Prelude head :: [a] -> a
12:55:02 <gwern> Data.ByteString head :: ByteString -> Word8
12:55:03 <gwern> Data.List head :: [a] -> a
12:55:11 <haskellian> lets say i have a funciton that takes a Customer, a list of Customers and return the Customer, updated with all the instances of CUstomer. Now while I am traversing this list I could just as well filter out all the occurences of Customer while am at it. But I can't ahve a function that returns a tuple of (Customer, [Customer]) right? So do I then need to create a Type that has fields Customer and [Customer]
12:55:36 <paczesiowa> :t (1,[1])
12:55:37 <lambdabot> forall t t1. (Num t1, Num t) => (t, [t1])
12:56:02 <rwbarton> haskellian: of course you can have a function return any type including a tuple
12:56:20 <mmorrow> @src Tree
12:56:21 <lambdabot> Source not found. That's something I cannot allow to happen.
12:56:28 * dcoutts pushes Cabal patches for gwern:
12:56:29 <dcoutts> Mon Aug 18 20:49:51 BST 2008  Duncan Coutts <duncan@haskell.org>
12:56:29 <dcoutts>   * Fix spelling of compatibility
12:56:29 <dcoutts>   At request of gwern who found that it was driving him nuts.
12:56:52 <hansfbaier> ayone knows, how to run c2hs from cabal correcly?
12:56:55 <haskellian> rwbarton: yes
12:57:03 <haskellian> but I mean ioh wait
12:57:06 <dcoutts> hansfbaier: cabal should just do the right thing.
12:57:22 <hansfbaier> (If I have a .chs file, how can I get cabal to include the right header name)?
12:57:22 <dcoutts> hansfbaier: except for the case of .chs modules that {# import #} each other
12:57:46 <dcoutts> hansfbaier: you can specify headers in the .chs file itself
12:58:14 <hansfbaier> dcoutts: great, is it in the c2hs manual?
12:58:23 <dcoutts> hansfbaier: yep
12:59:15 <dcoutts> hansfbaier: we could change it I think, recent versions of c2hs allow multiple .h files to be given on the command like I believe. That would allow us to pass the 'includes' given in the .cabal file.
13:00:43 <hansfbaier> dcoutts: but where in the docs? Cant find it?
13:01:24 <gwern> sjanssen: ah, turns out I can't copy processed .hs files from dist/; they only exist ephmerally in /tmp
13:01:43 <hansfbaier> dcoutts: Can you give me an example (file in gtk2hs would be fine....)
13:01:47 <dcoutts> hansfbaier: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html#cpp
13:01:50 <lambdabot> Title: Implementation of Haskell Binding Modules, http://tinyurl.com/5huh6b
13:02:12 <dcoutts> hansfbaier: we don't use it that way in gtk2hs. We'll have to sort that out before we can build gtk2hs with Cabal.
13:05:07 <Jedai> Someone has a good explanation of the Haskell evaluation model in its archive (I heard something about a PJ paper explaining WHNF a long time ago) ?
13:07:32 <hansfbaier> dcoutts: I added now #include "jack/midiport.h" at the top of my .chs file, but it doesnt make any difference (still complaining about not being able to find the methods...)
13:08:24 <dcoutts> hansfbaier: does it fail during pre-processing or while generating bindings?
13:08:40 <dcoutts> hansfbaier: you can see how Cabal is calling c2hs if you use build -v
13:09:28 <hansfbaier> dcoutts: http://hpaste.org/9753
13:10:24 <hansfbaier> dcoutts: http://hpaste.org/9754 (Thats what the file looks like)
13:10:48 <dcoutts> hansfbaier: ah, that's a nice bug. Put a newline before the #include.
13:11:23 <hansfbaier> dcoutts: Thanks! it works!!!!! Thats a tough one, though....
13:11:37 <dcoutts> hansfbaier: the c2hs .chs lexer has a bug where it looks for "\n#" which means it misses # directives on the first line of the file.
13:12:07 <gwern> dcoutts: is 'ghc-options: -pgmF BotPP -F' less evil?
13:12:18 <dcoutts> gwern: only somewhat
13:12:38 <dcoutts> gwern: the Right Thing is to define a pre-processor in the Setup.hs script
13:12:49 <dcoutts> but I accept that's not so easy
13:12:59 <gwern> no kidding
13:13:22 <dcoutts> gwern: feel free to file a tracker ticket so we don't forget
13:13:35 <gwern> for what?
13:13:43 <dcoutts> we ought to be able to do it for simple pre-processors in just a couple lines
13:13:56 <dcoutts> gwern: for making it easy to define pre-processors
13:14:08 <gwern> oh
13:14:10 <dcoutts> it's already possible (I believe) just not necessarily that easy
13:15:35 <gwern> eh. all my gumption is being eaten up by lambdabot
13:15:35 <gwern> sheesh
13:15:44 <gwern> I think I've gotten it libraryfied and building from sdist
13:15:45 <llama_02> hello
13:15:46 <gwern> I also fixed hoogle
13:15:49 <llama_02> soo funny - http://i8t.de/c6ek2n3i xD
13:15:52 <lambdabot> Title: Home
13:15:58 <Myoma> llama_02, stop it ..
13:16:00 <gwern> going well so far
13:16:07 --- mode: ChanServ set +o dcoutts
13:16:36 <dcoutts> llama_02: stop or you will be banned
13:17:06 --- mode: ChanServ set +o dons
13:17:14 <Igloo> Brostar n=f_maring@d86-33-235-132.cust.tele2.at was kicked and/or banned earlier
13:17:36 --- mode: ChanServ set -o dons
13:17:40 --- mode: ChanServ set -o dcoutts
13:18:44 <gwern> now to test sdist for reals
13:18:56 --- mode: ChanServ set +o glguy
13:18:57 --- mode: glguy set +b *!*@d86-33-235-132.cust.tele2.at!#haskell-ops
13:18:57 --- mode: ChanServ set -o glguy
13:19:14 <hansfbaier> dcoutts: Now c2hs works fine, but ghc cant find the module: http://hpaste.org/9755 :(
13:19:23 * gwern waits patiently. build 85 modules for the library, 85 modules for the executable, and so on. it's almost a good thing I can't profile because I enforce a mueval dep
13:20:08 <hansfbaier> dcoutts: and I have Exposed-Modules:    Sound.JACK, Sound.JACK.Midi in the cabal file.
13:20:17 <gwern> I mean, profiling would add another 85-module build for the library, and then a second one for the executable
13:20:22 <hansfbaier> dcoutts: (used to work with the plain .hs version before....)
13:20:22 <dcoutts> hansfbaier: so dist/build/Sound/JACK/Midi.hs does not exist?
13:21:23 <hansfbaier> dcoutts: http://hpaste.org/9756
13:22:26 <gwern> damn, Modules.hs thwarts me again
13:22:38 <gwern> FIRST AGAINST THE WALL, Modules.hs. HEAR ME?
13:22:45 <dcoutts> hansfbaier: hmm, so c2hs should be making that file, since you can see we specify --output-dir=dist/build --output=Sound/JACK/Midi.hs
13:22:58 <dcoutts> hansfbaier: has c2hs put Midi.hs somewhere else perhaps?
13:23:58 <sw17ch> hansfbaier, what are you working on? i'm seeing sound stuff.. but don't knwo the context
13:23:59 <dons> gwern: you don't get it. :)
13:24:38 * dons watches lambdabot break down little by little
13:24:45 <gwern> dons: what I get is a reactionary bourgeoise module is thwarting the coming of the hacker's paradise
13:25:01 <gwern> it is our duty to lay it onto the scrapheap of revision history!
13:25:03 <dons> grand architectures thrown by the wayside.
13:25:05 <hansfbaier> dcoutts: according to http://hpaste.org/9756 it is in dist/build/Midi.hs
13:25:16 <dons> to be replaced with glue and cellotape.
13:25:25 <hansfbaier> sw17ch: Jack MIDI client support. Works already, but not the cabal/c2hs stuff...
13:25:30 <wadcom> hi, got a silly question: how to divide two Int's to get a Float? This code gives an error:
13:25:31 <wadcom> f :: Int -> Int -> Float
13:25:31 <wadcom> f x y = x / y
13:25:41 <dcoutts> hansfbaier: hmm, that's bad. What c2hs version are you using?
13:25:46 <gwern> dons: what works is the cardinal rule. we break down the architecture because the building keeps falling down and crushing our comrades
13:25:56 <sw17ch> hansfbaier, ah, alright.
13:26:05 <hansfbaier> dcoutts: version 0.14.5 Travelling Lightly, 12 Dec 2005 (Haskell)
13:26:19 <hansfbaier> dcoutts: stock ubuntu hardy.
13:27:05 <Myoma> wadcom, yeah
13:27:10 <dcoutts> hansfbaier: ah you must also be using an old Cabal, otherwise I think it'd tell your c2hs was too old.
13:27:12 <Myoma> wadcom, (%) instead of (/) is one way
13:27:15 <hansfbaier> dcoutts: at the moment, I copied the output of c2hs literally into Midi.hs and go without c2hs.....
13:27:19 <Myoma> that gives you a rational instead of a float though
13:27:25 <lojbot> mmmkay. I'm connected through my haskelll irc bouncer
13:27:29 <Myoma> :t realToFrac :: Rational -> Float
13:27:31 <lambdabot> Rational -> Float
13:27:36 <Myoma> I guess you can convert it with that
13:28:08 * hansfbaier using version 1.4.0.1 of the Cabal library 
13:28:10 <dcoutts> hansfbaier: hmm, actually seems we're not checking for the minimum c2hs version.
13:28:18 <hansfbaier> dcoutts: ^
13:28:22 <dcoutts> though we clearly should be
13:28:29 <haskellian> how can this compile :
13:28:30 <haskellian> xupdate :: Customer -> [Customer] -> (Customer, [Customer]) -> (Customer, [Customer])
13:28:30 <haskellian> xupdate customer []     (_, filt)  = (customer, filt)
13:28:30 <haskellian> xupdate customer (x:xs)
13:28:31 <dcoutts> hansfbaier: you need 0.15 minimum
13:28:46 <dcoutts> hansfbaier: cabal install c2hs
13:28:59 <dcoutts> hansfbaier: sorry about that
13:29:07 <wadcom> Myoma: thanks
13:29:17 <haskellian> i mean this:
13:29:18 <haskellian> xupdate :: Customer -> [Customer] -> (Customer, [Customer]) -> (Customer, [Customer])
13:29:18 <haskellian> xupdate customer []     (_, filt)  = (customer, filt)
13:29:18 <haskellian> xupdate customer (x:xs) filt
13:29:35 <haskellian> filter cant be in a tuple and then be a tuple right?
13:30:09 <rwbarton> haskellian: names in different equations are in different scopes.  They don't have anything to do with each other
13:30:34 <haskellian> aha
13:31:13 * gwern deletes stuff
13:31:24 <gwern> I am become death, destroyer of legacy codes!
13:31:43 <lojbot> codethulhu
13:35:14 * sjanssen hates C APIs
13:35:39 <sjanssen> especially those "Copyright 1988, 1998  The Open Group"
13:36:01 <hansfbaier> dcoutts: I have now Build-Depends:      base>=2.1, array, random, unix, c2hs>=0.15 in my cabal file, but when I run cabal configure, it says: Setup.hs: At least the following dependencies are missing:
13:36:01 <hansfbaier> c2hs >=0.15 && >=0.15
13:36:03 * Zao is currently knee deep inside assorted curses implementations.
13:36:16 * hansfbaier hates cabal
13:36:26 <olsner> sjanssen: hmm, does that mean the api's been revised once in 1998 since being incepted in '88?
13:36:35 * hansfbaier for its lack of documentation of the cabal file
13:36:50 <dcoutts> hansfbaier: every field is documented in the user guide.
13:37:14 <dcoutts> hansfbaier: if you've changed installed programs (ie upgraded c2hs) then you need to re-configure before it looks for them again.
13:37:19 <sjanssen> olsner: I'm not sure.  There's a CVS header at the top dating to 2001 (possibly just from the xorg migration?)
13:37:35 <hansfbaier> dcoutts: re-configure?
13:37:49 <sjanssen> but I'm only 3 years older than this header
13:37:50 <haskellian> if i need to process every element of a datastructure, how can it be faster than O(n)? how can it be faster than a list?
13:37:50 <dcoutts> hansfbaier: as in cabal (or runghc Setup) configure
13:38:17 <nominolo> dcoutts: hm, ">=0.15 && >=0.15" looks a bit weird.  do you know why it mentions the same range twice?
13:38:17 <hansfbaier> dcoutts: the output I showed was from runghc Setup.hs configure
13:38:29 <dcoutts> hansfbaier: and you updated c2hs to 0.15 ?
13:38:45 <dcoutts> nominolo: not sure
13:39:01 <hansfbaier> dcoutts, nominolo: Here is the cabal file: http://hpaste.org/9757
13:39:02 <nominolo> hansfbaier: is c2hs a dependency or a build-depends: ?
13:39:13 <olsner> sjanssen: sweet :)
13:39:53 <hansfbaier> nominolo: build-depends
13:40:22 <nominolo> hansfbaier: i mean do you need it as a library or as a tool to preprocess files?
13:40:32 <hansfbaier> nominolo: the latter.
13:40:38 <dcoutts> hansfbaier: you mean to use build-tools. c2hs is not a library package.
13:41:20 <nominolo> dcoutts: do build-tools allow version constraints?
13:41:40 <hansfbaier> dcoutts: great! now it seems to work.
13:42:47 <dcoutts> nominolo: yep, if we know the version of the program.
13:43:06 <dcoutts> nominolo: which we do for many progs. If you ask for a version constraint and we do not know then it fails.
13:43:59 <nominolo> i see
13:47:25 <chrisdone> check it out guise a simple irc bouncer in 150 LoC: http://chrisdone.com/ConnectionNoComments.hs.html
13:47:27 <lambdabot> Title: Haskell Code by HsColour
13:48:43 <hansfbaier> dcoutts: AAARRRGHHHH, now compiling seems to work fine, but at the end it cant find the module again: http://hpaste.org/9758
13:48:53 <yitz> chrisdone: just curious, was that "lojbot" thing you testing this?
13:49:39 <dcoutts> hansfbaier: if the module is used in the exe then it has to be listed in other-modules for the exe
13:50:58 <Wild_Cat> hrmm.
13:51:03 <hansfbaier> dcoutts: You mean other-modules in the cabal file? But it doesnt make a difference....
13:51:09 <mmorrow> chrisdone: looks sweet!
13:52:11 <dcoutts> hansfbaier: in the .cabal file you posted earlier you list Sound.JACK.Midi in the exposed modules for the lib, but not in the other-modules for the exe
13:52:11 <hansfbaier> dcoutts: I moved Sound.JACK.Midi from Exposed-Modules to Other-Modules in the cabal file, but same effect (reconfigured)
13:52:34 <hansfbaier> dcoutts: sorry, I can see now. (I must be tired :)
13:52:39 <dcoutts> hansfbaier: I expect you're only changing things for the lib, you have to list it in the exe section if the exe uses it.
13:52:50 <hansfbaier> dcoutts: I should go to bed soon...
13:52:50 <Wild_Cat> if you guys remember me from a couple days ago, I was trying, unsuccessfully, to install yi on my computer. building from source didn't install a binary, and I hadn't tried cabal-install. The bad news are, I just tried cabal install yi, and it fails miserably with "cabal: alex version >=2.0.1 && <3 is required but it could not be found."
13:52:56 <Wild_Cat> any ideas?
13:52:58 <chrisdone> yitz: it's for a lojban bot
13:53:12 <dcoutts> hansfbaier: there is no implicit dependency of the exe on the lib, everything is explicit.
13:53:32 <dcoutts> Wild_Cat: install alex?
13:53:47 <Wild_Cat> dcoutts: isn't that supposed to be done automatically by cabal-install?
13:54:02 <Wild_Cat> ...Okay. Obviously not.
13:54:07 * Wild_Cat hides in a corner
13:54:07 <dcoutts> Wild_Cat: it doesn't track build-tools yet, only build-depends
13:54:20 <yitz> chrisdone: figured :) ok
13:54:31 <dcoutts> Wild_Cat: if you want to hack on that issue, see ticket #227
13:54:41 <gwern> Wild_Cat: standard problem, practically an FAQ
13:54:44 <gwern> actually, it may even be in the Yi FAQ, I haven't looked recently
13:55:09 <Wild_Cat> dcoutts: I'd like to, but I'm still a Haskell newbie.
13:55:28 <marcot> I'm trying to debug using appendFile, but I'm in a situation where I call it before a function call, and just in the first line of the function, and in the file I get just the first one.
13:55:31 <hansfbaier> dcoutts: Great! Thanks so much for resolving all my noob cabal problems....
13:55:37 <hansfbaier> dcoutts: it works now...
13:55:39 <gwern> Wild_Cat: cabal install alex yi
13:55:44 <Wild_Cat> as in, I can't even get a text editor to install, how the hell am I gonna hack cabal? :D
13:55:48 <marcot> My program in producing memory leaks, and I'm trying to find out where.
13:56:08 <marcot> Could this be solved by flush?
13:56:22 <Myoma> Has anybody written up alternatives to the typeclass dispatch haskell currently uses?
13:56:24 <dcoutts> hansfbaier: np. Hopefully we can improve the error messages on that stuff in future and let you do things like saying the exe depends on the lib.
13:56:41 <Myoma> I'd like to have a look at/try out some alternatives
13:56:45 <gwern> Myoma: dons has an amusing blog post on doing type classes via GHC rewrite rules...
13:57:11 <Wild_Cat> hrmm... I installed alex (apparently v2.2), but cabal still can't find it when installing yi.
13:57:28 <gwern> Myoma: and JHC/GRIN iirc does type classes via a different mechanism than GHC
13:58:01 <Wild_Cat> is it because it should be on my $PATH, or is there a deeper problem?
13:58:20 * Wild_Cat ponders adding ~/.cabal/bin to his $PATH, but doesn't really feel comfortable with that
13:58:20 <dcoutts> Wild_Cat: right, it's because of the path.
13:58:36 <dcoutts> Wild_Cat: that's the most sensible thing to do at the moment.
13:58:59 <dcoutts> Wild_Cat: in the next release of cabal-install I've added support for symlinking binaries into ~/bin (assuming that is on your path)
13:59:22 <marcot> But appendFile shouldn't require flush, right?
13:59:25 * gwern reinstalls cabal. thanx dcoutts 
13:59:27 <SamB> gwern: yeah, JHC runs them through a food processor before code generation
13:59:27 <olsner> adding .cabal/bin to the path seems safe enough (hey, it's all quality haskell software!)
13:59:44 <Wild_Cat> dcoutts: yeah, I recall you mentioning that last time we talked about this. Awesome.
13:59:47 <gwern> SamB: involutalicious!
13:59:48 <SamB> gwern: (or might as well, considering what a mess it makes of the RULES sometimes ;-)
14:00:11 <chrisdone> involutalicious is now the best word in the english language
14:00:21 <gwern> SamB: I wouldn't know, haven't compiled JHC in months
14:00:22 <gwern> not that I used it even when it was compiled...
14:00:46 <SamB> didn't seem to have changed in months last I looked anyway
14:01:12 <yitz> @go involutalicious
14:01:13 <lambdabot> No Result Found.
14:01:22 <gwern> weren't you working on't?
14:02:33 <SamB> until I got fed-up with how extremely rickety the typeclass code seems to be
14:02:56 <SamB> and decided to wait for John to fix it ...
14:03:32 <mauke> preflex: seen mauke
14:03:32 <preflex>  mauke was last seen on #xmonad 4 days, 4 hours, 41 minutes and 21 seconds ago, saying: preflex: quote
14:04:00 <gwern> I personally have a a rather mean-spirited bet with myself - how much haskell code will meachem produce which nobody will use?
14:04:15 <Myoma> say you are given some program text (a bunch of data, classes, instances and function definitions)
14:04:57 <Myoma> do you typecheck that first ignoring all the typeclass constraints, (so you have lots of variables) then run the typeclass constraints to constrain them?
14:05:27 <SamB_XP> uh, no you don't ignore the typeclass constraints...
14:05:49 <Myoma> so they actually take part in the inference stage?
14:06:38 <SamB_XP> yes.
14:06:44 <Myoma> in what ways?
14:06:48 <hansfbaier> dcoutts: Another weird effect: running Midimon with ghci or compiling with ghc --make Midimon.hs works fine, but if I run the cabal compiled example the application starts, but does not connect to the jack server .... Looks like a linking problem or so....
14:07:00 <SamB_XP> there's defaulting, functional dependencies, associated types...
14:07:27 <Wild_Cat> right. Next step: installing yi-gtk. http://hpaste.org/9760 , even though unix-2.3.0.0 is present in /usr/lib/ghc-6.8.2/package.conf
14:07:29 <SamB_XP> anyway if you did it in two passes you'd probably get lousy error messages
14:08:43 <gwern> Wild_Cat: whoa whoa, yi-gtk?
14:08:44 <gwern> why are you installing that?
14:09:49 <Wild_Cat> gwern: because I like my text editors with GUIs.
14:10:04 <gwern> you're installing .3/.4 right?
14:10:09 <Wild_Cat> (and my IRC servers without lag, but this one seems to happily give me 20+ seconds right now -- I may drop out any second, sorry if I do)
14:10:12 <gwern> yi-gtk is for .1/.2, iirc
14:10:12 <hansfbaier> dcoutts: sorry, never mind, I am getting really tired now... :)
14:10:31 <Wild_Cat> gwern: yi 0.4.3, yeah. Oh, is yi-gtk obsolete?
14:10:46 <gwern> yes
14:10:58 <Myoma> SamB_XP: Since typeclass dispatch can happen at runtime I don't see what difference it makes to error messages
14:11:46 <SamB_XP> Myoma: all the errors relating to typeclasses (except missing method errors) happen at compile time ...
14:12:04 <Wild_Cat> gwern: good. How do I get my gtk UI, then?
14:12:09 <Myoma> :t let f = fst . fromIntegral in f 3
14:12:10 <lambdabot> forall b a. (Num (a, b)) => a
14:12:11 <Myoma> > let f = fst . fromIntegral in f 3
14:12:13 <lambdabot>   add an instance declaration for (Num (a, b))
14:12:21 <gwern> Wild_Cat: have gtk2hs installed
14:12:25 <gwern> I believe yi handles the rest
14:12:42 <gwern> that or you pass a flag
14:12:43 <gwern> forget which
14:12:53 <Myoma> :t fromIntegral
14:12:54 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:13:09 <Myoma> anyway what I was wondering is.. do you first type it with fromIntegral :: a -> b
14:13:29 <Myoma> once that's done, then try to resolve the typeclasses (variables a and b might be more specific at that point)
14:13:43 <Wild_Cat> gwern: looks like a flag is required. At compile-time.
14:15:08 <Wild_Cat> oh, okay. My version of gtk2hs is too old.
14:15:21 <Wild_Cat> right, away goes the default Ubuntu one then.
14:15:57 <gwern> @help >
14:15:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:16:08 <gwern> @help list
14:16:09 <lambdabot> list [module|command]
14:16:09 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
14:16:39 <gwern> @run 1+1
14:16:41 <lambdabot>  2
14:18:26 <hansfbaier> dcoutts: Thanks again, all is well now! :)
14:19:29 <gwern> shoot. it's passing stuff to mueval, but it's getting mangled...
14:20:31 <Myoma> class Foo a b
14:20:31 <Myoma> instance Foo a b => Foo a b
14:20:31 <Myoma> f :: Foo a b => a -> b
14:20:59 <Myoma> given that, why does :t f (undefined :: A) :: A typecheck? (I thought it would diverge)
14:21:11 <Wild_Cat> crap. gtk2hs isn't on Hackage. Oh, well. I'll play around with textmode yi for a while then.
14:21:34 <Myoma> (instance Foo (S a) (S b) => Foo a b does diverge)
14:23:19 <gwern> Wild_Cat: gtk2hs is very hard to cabalize, although dcoutts and co are working on it
14:24:07 <Trinithis> Are there hackaged gui libs?
14:24:52 <Wild_Cat> ooh, fail: there seems to be a hardcoded /home/bernardy path somewhere in yi.
14:25:31 <gwern> sure. rsagl just got updated, for example
14:25:59 <Wild_Cat> (unable to open "/home/bernardy/.cabal/share/yi-0.4.3/examples/yi.hs" when attempting to edit yi.hs with an unconfigured yi. That it offers you to do so with a helpful message is great, though)
14:26:20 <Wild_Cat> well, aside from the fact that I had to Wikipedia in order to know what the heck "cua" is. ;)
14:26:37 <gwern> Wild_Cat: eh. use darcs yi
14:26:39 <gwern> with yi darcs is always a good idea
14:26:48 <gwern> for example, I see no such addresses in darcs yi
14:26:59 <Wild_Cat> right.
14:27:03 <Wild_Cat> let's do this.
14:27:42 <chrisdone> wild caaaaaaaaaat
14:30:23 <Wild_Cat> yes?
14:30:33 <augustss> yo
14:30:38 <chrisdone> hey
14:30:42 <Wild_Cat> (side note: darcs feels great to use, but darcs get is a tad slow)
14:31:00 <chrisdone> preaching to the converted
14:31:18 <gwern> Wild_Cat: we're fixing that in darcs darcs
14:31:44 <chrisdone> darcs --darcs darcs
14:31:47 <Wild_Cat> good!
14:31:53 <mauke> darcs (darcs (darcs (darcs ...
14:31:58 <mauke> a.k.a. fix darcs
14:31:59 <gwern> things will be faster when everyone uses darcs-2 and remembers to enable global caches and checkpoints
14:32:02 <gwern> much faster
14:32:09 <Wild_Cat> by the way, why does darcs init create a darcs 1 repo, even with darcs 2?
14:32:15 <gwern> global caches make darcs get speed almost irrelevant
14:32:24 <gwern> Wild_Cat: darcs-1s cannot work with darcs-2 repos
14:32:34 <gwern> we knew darcs-2 would take a very long time to propagate
14:32:39 <gwern> so, why burn bridges?
14:32:51 <gwern> we have discussed making darcs-2 the default
14:33:05 <glguy> because the bridge might kill you before darcs-2 becomes adopted?
14:33:15 <Wild_Cat> is there a 1-liner to convert a darcs-1 repo to a darcs-2 one?
14:33:41 <Myoma> is there a big list somewhere of the kind of things people do and would like to do with typeclasses?
14:34:09 <gwern> glguy: yeah, that's an important reason too... no need to torque people off
14:35:14 <haskellian> Onething I find annoying, no matter how smart the compiler is and advanced the system, there is simply no replacement for being able to stick in some print variable statements in your code to see hwat is happening. I have a problem I think I would have solved in about 3 minutes in Python but in Haskell it gets really annoying.
14:35:35 <Wild_Cat> ah, much better. A text editor with actual text in it.
14:35:38 <olsner> @quote trace
14:35:39 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:35:47 <mauke> there is: trace
14:35:50 <Myoma> haskellian: There is a substitute but it's not a smart compiler
14:36:07 <hackage> Uploaded to hackage: ircbouncer 0.0
14:36:07 <hackage> Uploaded to hackage: benchpress 0.2
14:36:07 <hackage> Uploaded to hackage: yi-vty 0.2.1
14:36:07 <hackage> Uploaded to hackage: yi-gtk 0.2.1
14:36:36 <haskellian> Myoma: what si the substitute? And isn't ghc smart?
14:36:55 <yitz> Wild_Cat: looks like your version of yi just became outdated.
14:37:09 <chrisdone> haskell newbises always want trace
14:37:16 <chrisdone> and then learn it's not necessary
14:37:19 * Wild_Cat kicks yitz 
14:37:30 <gwern> Wild_Cat: no, not really. darcs convert ./; mv repo ../repo-tmp; cd ../; rm -rf repo; mv repo-tmp repo
14:37:30 <gwern> note that darcs-2 conversion is not done in place
14:37:31 <gwern> this is another decision made to avoid people being pissed off
14:37:43 <gwern> 'darcs-2 destroyed my only repo which my company depends on!'
14:38:00 <chrisdone> â€œI don't make backups!! it's your fault!!â€
14:38:01 <yitz> hehe (good thing Wild_Cat doesn't seem to know about /bot's slap command)
14:38:06 <Wild_Cat> gwern: doing the conversion in-place would be suicide all right
14:38:36 <mauke> @slap yitz
14:38:36 * lambdabot puts on her slapping gloves, and slaps yitz
14:38:41 <yitz> ouch
14:38:43 <olsner> bah, version control is not a substitute for backups anyway, so... just go ahead and break it - CVS style!
14:39:09 <SamB_XP> olsner: Linus begs to differ ;-P
14:39:12 <chrisdone> these are the kind of people that get really mad when their HD crashes
14:40:45 <lament> do backups, version them, and then back up the repository!
14:42:31 <Wild_Cat> ...right. And Yi's Cua keybindings don't do much, it seems. PgUp/PgDown do nothing, Home inserts H and End inserts F... Let's see what the source says.
14:42:37 <olsner> yeah, plenty of cases where careful application of diff+patch+backups does far less damage than CVS
14:45:16 <Wild_Cat> oh, scratch that: all "special" keys other than regular cursor arrows are down.
14:47:05 <Wild_Cat> okay, at the very least the letters, backspace and return work. And the emacs keymap is partially screwed as well, so maybe there's a problem with my box.
14:48:44 <SamB_XP> Wild_Cat: what makes you think that?
14:48:57 <SamB_XP> Wild_Cat: generally all problems with Yi's keymaps are bugs ;-)
14:49:27 <Wild_Cat> SamB: well, the fact that 2 keymaps out of 3 basically fail here.
14:50:17 <SamB_XP> Wild_Cat: that's probably only because only the vi keymap gets enough attention
14:50:43 <Wild_Cat> ...right. And that being the one I'm trying to get away from (I mean, if I wanted a vim keymap, I'd use vim)
14:51:02 <gwern> the vty library is known to have many problems
14:51:15 <SamB_XP> I would suggest using an actual editor rather than yi
14:51:33 <lament> heh
14:51:41 <Wild_Cat> ::sigh:: I think I'm going to follow that advice quite soon and run back to either gvim or gedit.
14:51:56 <SamB_XP> not emacs?
14:52:28 <lament> you said "an actual editor"!
14:52:50 <Wild_Cat> SamB: sorry, I like my text editors with a GTK frontend or at the very least fonts that don't make my eyes bleed. And a single-chord save shortcut.
14:53:07 <dmhouse> Wild_Cat: I run Emacs built with GTK and Xft fonts.
14:53:11 <SamB_XP> fair enough for now
14:53:20 <Wild_Cat> (the latter of which vim doesn't have, admittedly :p )
14:53:25 <dmhouse> The CVS version builds with GTK for default. In fact I think the latest CVS might do.
14:53:30 <dmhouse> Err, latest release.
14:53:41 <dmhouse> You need the CVS for Xft though. (It's stable, though.)
14:54:26 <gwern> sweet!
14:54:30 <gwern> lambdabot now uses mueval for >!
14:54:46 <Wild_Cat> (what I really want, of course, is TextMate for Linux, but it's not gonna happen)
14:54:47 <ski> ?
14:54:51 <Myoma> > unsafePerformIO "rm *"
14:54:52 <lambdabot>   Not in scope: `unsafePerformIO'
14:54:54 <lispy> Someone brought up a good point about generating FFI bindings, why don't we get on the SWIG bandwagon.
14:55:06 <SamB_XP> lispy: what the heck why?
14:55:06 * gwern finally did it
14:55:17 <gwern> months of occasional tweaking and hacking and odd bugs
14:55:27 <gwern> and I've finally done it
14:55:33 <tibbe> lispy: it would be interesting to see how C++ code would be mapped to Haskell
14:55:36 <lispy> SamB_XP: SWIG seems to be a popular tool for making bindings, it would help Haskell's rep if it worked with SWIG too I hypothesize
14:55:39 <gwern> now I just need check and scheck to work, but that's the work of a few minutes
14:56:01 <tibbe> gwern: :)
14:56:15 <tibbe> SamB: AFAIK Google uses SWIG
14:56:28 * Beelsebob ponders if dcoutts is anywhere to be seen
14:56:43 <dmhouse> Wild_Cat:     minutes
14:56:43 <dmhouse> <tibbe> gwern: :)
14:56:43 <dmhouse> *** mnislaih (n=pepe@12.Red-79-154-223.staticIP.rima-tde.net) has quit:
14:56:43 <dmhouse> <tibbe> SamB: AFAIK Google uses SWIG  [22:57]
14:56:46 <dmhouse> ERC> Wild_Cat, http://imagebin.org/24539 pretty enough?
14:56:51 <dmhouse> Argh!
14:56:52 <ddarius> @seen dcoutts
14:56:53 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 41m 29s ago.
14:56:55 <lambdabot> Title: Imagebin - A place to slap up your images.
14:57:06 <dmhouse> Wild_Cat: http://imagebin.org/24539
14:57:07 <lambdabot> Title: Imagebin - A place to slap up your images.
14:57:13 <dmhouse> Sorry for the overenthusiastic paste everyone.
14:57:22 <Myoma> hiya ski
14:57:26 <gwern> just in time for dinner too
14:57:33 <lispy> tibbe: yeah, I don't know much about interfacing with C++ in full generality.  But, I'm sure someone could come up with a cool way to make it work.
14:57:38 <dmhouse> Admittedly I'm using xmonad and have turned the menus off so not much of the GTKness is visible, but you can see, e.g., the scrollbars
14:57:45 <tibbe> lispy: :)
14:58:07 <tibbe> lispy: AFAIK Python also has some limitations when using SWIGed C++ code. No nested classes.
14:58:15 <lispy> tibbe: I admin though, I'm most interested in interfacing with plain C
14:58:19 <dmhouse> Wild_Cat: if you want to write Haskell, Emacs is a great editor.
14:58:23 <tibbe> lispy: yes
14:58:25 <ddarius> lispy: No one has yet thought up of a "cool way to" bind to C++.
14:58:26 <lispy> s/admin/admit
14:58:51 <tibbe> dmhouse: speaking of, do you know how to make emacs always indent using two spaces instead of different amount depending on context
14:58:53 <Myoma> Does there exist a _______? CLOS is to Java, as _______ is to Haskell typeclasses
14:59:02 <dmhouse> tibbe: in which language?
14:59:17 <tibbe> dmhouse: Haskell using haskell-mode
14:59:25 <dmhouse> tibbe: tried the simple indent module?
14:59:28 <SamB_XP> dmhouse: you have your scrollbar on the wrong side!
14:59:29 <lispy> Myoma: how is CLOS to Java?
14:59:42 <Myoma> lispy, it is more advanced
14:59:43 <chrisdone> Myoma: â€œa feature from another languageâ€?
15:00:04 <lispy> Myoma: so you want something that generalizes type classes?
15:00:27 <sjanssen> xhb can now authenticate!!
15:00:33 <lispy> Myoma: I wonder if associate types would be what you want
15:00:42 <lispy> associated*
15:00:53 <ski> Myoma : hiya
15:00:54 <tibbe> dmhouse: yes but it doesn't indent at all for some weird reason
15:01:02 <tibbe> dmhouse: maybe I'm not initializing it correctly
15:01:05 <dons> sjanssen: so what's the direction of xhb , in your view?
15:01:12 <ski> gwern : what is `mueval' ?
15:01:17 <lispy> the indent rules of haskell-mode frustrate me
15:01:17 <SamB_XP> dmhouse: why do all your windows have [#haskell] in the status line?
15:01:32 <sjanssen> dons: the direction right now is to make it work, AFAIK
15:01:33 <dmhouse> SamB_XP: ERC showing me that someone's said something on #haskell
15:01:44 * lispy misses ERC
15:02:02 * cjb uses ERC
15:02:19 * stepcut uses ERC but tried to use circe once
15:02:22 <dmhouse> ERC is amazing, it's one of the few instances that someone has built a nonsucky application inside of Emacs that isn't to do with text editing.
15:02:37 * stepcut uses wanderlust
15:02:40 <chrisdone> I'm using rcirc
15:02:45 <chrisdone> not sure what the differences are
15:02:50 <sjanssen> dons: the code generator isn't 100% right yet, so bits of the generated code have to be manually patched
15:02:51 <lispy> dmhouse: nah, IRC is just multiplayer notepad (a non-computer friend told me this once)
15:02:55 <stepcut> chrisdone: I couldn't get some dependency to build
15:02:55 <chrisdone> I just send messages in channels, nothing clever
15:02:55 <sjanssen> I assume that's the biggest priority
15:02:59 <ddarius> dmhouse: When is someone going to build a nonsucky text editor inside of Emacs?
15:03:02 <mauke> it's actually multiplayer cat
15:03:13 <dmhouse> ddarius: ;)
15:03:18 <mauke> viper-mode
15:03:27 <stepcut> mauke: still not multithreaded
15:03:28 <lispy> ddarius: this is getting OT, but I feel like emacs is a good editor, but a bad IDE
15:03:28 <Jedai> ski: It's a new package that allows to interpret Haskell source in a sandbox more or less
15:03:33 * dmhouse misses Emacs _every time_ he has to edit text outside of it
15:03:34 <SamB_XP> lispy: a non-computer friend told you that?
15:03:36 <ski> ok
15:03:40 <olsner> ddarius: I don't think it's proven that it's even possible to make such a thing
15:03:47 <ddarius> mauke: Reading about viper-mode did not make it sound like I'd be happy using Emacs via it.
15:03:49 <SamB_XP> lispy: you have interesting friends!
15:03:56 <lispy> SamB_XP: well, non computer geek, I took it for granted that the reader would understand that :)
15:04:01 * ddarius is just trolling anyway.
15:04:07 * ddarius has never used Emacs.
15:04:14 <dmhouse> lispy: true. But then Emacs isn't trying to be an IDE. Doesn't mean you can't do effective programming inside it.
15:04:17 <SamB_XP> lispy: oh, yes, I understood that
15:04:33 <dmhouse> In the Emacs word, "IDE" is something of a dirty word for "feature bloated, chunky, gets in my way".
15:04:47 <SamB_XP> I thought emacs was an IDE
15:04:58 <Myoma> funnily enough that is what IDE makes me think
15:04:59 <SamB_XP> what is this M-x compile thing for, if not?
15:05:05 <ddarius> In the vim world, "emacs" is something of a dirty word for "feature bloated, chunky, gets in my way."
15:05:17 <lispy> heh, swig lists that one of the things it makes possible is, "Impressing your friends."
15:05:20 <Wild_Cat> SamB: there's more to an IDE than a compile command.
15:05:20 <SamB_XP> ddarius: hehe
15:05:36 <SamB_XP> Wild_Cat: it also lets you jump to code from errors
15:05:39 <SamB_XP> what else is there?
15:05:58 <mauke> debugger integration, on-the-fly error highlighting
15:06:03 <mauke> project management
15:06:06 <dmhouse> Erm, _everything_.
15:06:12 <lispy> In my experience, most IDEs are terrible editors and emacs is a good editor but a terrible IDE </$0.02>
15:06:12 <SamB_XP> doesn't it have debugger integration?
15:06:12 <mauke> smart complete
15:06:15 <dmhouse> Tetris. Phases of moon,.
15:06:16 <stepcut> In the yi world, "vi" is something of a dirty word for hard to extend, feature lacking, won't do it my way.
15:06:19 <Wild_Cat> there's build tool integration, symbol browsers, version control, autocompletion, documentation integration (via e.g. haddock)...
15:06:40 <dmhouse> Version control support is very strong
15:06:57 * Myoma was hoping for a lunar eclipso
15:07:01 <Wild_Cat> ...and my all-time favorites, the project tree view and whatever the generic name for Eclipse's "open resource..." is.
15:07:07 <SamB_XP> so does anyone know of something that combines the strengths of emacs and IDEs?
15:07:18 <ski> dmhouse : eliza,zippy
15:07:29 <Wild_Cat> (sadly, Eclipse, while a great IDE, has the worst text editor I've encountered)
15:07:31 <dmhouse> Autocompletion I don't personally like, too much thinking when you're typing. But it's done pretty well (tags, dabbrevs, hippe-expand)
15:07:38 <olsner> emacs has strengths!? </troll>
15:07:41 <ddarius> stepcut: Everyone agrees that "vi" is feature lacking.
15:07:57 <dmhouse> Documentation integration is lacking a bit at the moment, it's something I've been thinking about.
15:08:11 <ddarius> Though I have to say vim is overly featureful for my tastes.  I use like 2% of its functionality.
15:08:11 <dmhouse> Symbol browsers are available with imenu and/or speedbar
15:08:20 <dmhouse> But learn to love TAGS :)
15:08:20 <Trinithis> What is yi?
15:08:35 <dmhouse> Trinithis: the beginnings of an editor written in Haskell.
15:08:38 <lispy> Trinithis: a haskell re-implementation of vi
15:08:41 <jberg> how do i quit xmonad? like log out not shut down
15:08:41 <stepcut> Trinithis: text editor written in Haskell, which can be extended by adding more haskell to your config file
15:08:42 <Trinithis> Cool1
15:08:46 <lispy> Trinithis: it supports a plugin architecture
15:08:48 <Trinithis> aby beta version yet?
15:08:50 <cjb> lispy: no, it has both vi and emacs modes
15:08:55 <cjb> (the emacs mode seems more complete to me)
15:08:56 <mauke> jberg: mod-shift-q
15:09:01 <jberg> okay thanks
15:09:09 <Wild_Cat> cjay: yes, but as I demonstrated earlier, the emacs and cua keybindings don't work :p
15:09:10 <Trinithis> any beta versions yet?*
15:09:14 <lispy> cjb: ah cool, I admit I haven't used yi in years
15:09:15 <dmhouse> jberg: there is an #xmonad btw, which might be more helpful.
15:09:17 <dmhouse> ?where yi
15:09:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
15:09:53 <chrisdone> ddarius:  I think I probably don't use a lot of emacs, in the same way
15:09:53 <jberg> yup
15:09:53 <SamB_XP> cjb: *more* complete ???
15:09:55 <SamB_XP> how odd
15:10:13 <cjb> I think the main Yi programmer is an emacs person.
15:10:26 <cjb> (just my impression, might be wrong)
15:10:30 <ddarius> When yi started it was developed mainly by a vim person.  The current developer is an emacs person.
15:10:35 <cjb> yeah
15:10:44 <Trinithis> What does yi stand for?
15:10:55 <chrisdone> I just use emacs because I learned how to use it when learning common lisp and now it "just works" for me. I tried vim for a little while but I didn't find it to be more or less useful than emacs
15:10:59 <ivanm> yi stands for yi?
15:11:03 <stepcut> Trinithis: see the bottom of the page
15:11:04 <SamB_XP> Trinithis: something in hebrew
15:11:09 <stepcut> Trinithis: http://haskell.org/haskellwiki/Yi
15:11:11 <lambdabot> Title: Yi - HaskellWiki
15:11:13 <SamB_XP> also it looks kind of like vi
15:11:18 <ddarius> SamB_XP: Hebrew?  Wtf?
15:11:27 <SamB_XP> or was that chinese?
15:11:28 <Wild_Cat> Trinithis: "righteousness" in Chinese, and an obscure joke about Y-combinators I obviously don't know enough Haskell yet to understand :p
15:11:34 <stepcut> SamB_XP: chinese.
15:11:40 <SamB_XP> well, okay...
15:11:45 <mauke> yi should be fix id
15:11:46 <Trinithis> ah
15:11:47 <SamB_XP> I haven't looked in a long time
15:11:48 <stepcut> SamB_XP: or the worlds most recursive acrynom, Y I
15:11:55 <cjb> SamB_XP: when I run it, it looks more like emacs :)
15:11:55 <dmhouse> Heh.
15:12:18 <mauke> YI = I(YI) = YI
15:12:37 <Trinithis> CS puns...
15:12:38 * SamB_XP groans
15:12:40 <dmhouse> I heard a great recursive acronym earlier, some Microsoft gaming product: "XNA's Not Acronymed". They have a great logo too, check out the logo and caption at http://en.wikipedia.org/wiki/Microsoft_XNA
15:12:40 <lambdabot> Title: Microsoft XNA - Wikipedia, the free encyclopedia
15:13:22 <SamB_XP> hmm, why not "XNA's Not an Acronym"?
15:13:25 <chrisdone> the orange bit is like the tail of that creature that climbs into Neo's belly
15:13:28 <SamB_XP> does that infringe on the GNU trademark?
15:14:09 <Trinithis> GNU should sue PHP first
15:14:42 <SamB_XP> but PHP stands for Personal HomePage
15:14:42 <Wild_Cat> everybody should sue PHP.
15:14:54 <SamB_XP> oh, you meant for sucking so badly?
15:14:59 <chrisdone> sounds like a clever turn on "use"
15:15:18 <Trinithis> PHP = PHP hypertext preprocessor.... also for being the evilest language in the world
15:15:36 <SamB_XP> no, it definately stands for Personal HomePage
15:15:41 <Tobsan> lol
15:15:43 <dmhouse> It used to.
15:15:45 <stepcut> SamB_XP: indeed!
15:15:45 <Wild_Cat> chrisdone: hadn't considered that one... I'm keeping it. I like that joke. ^^
15:15:53 <dmhouse> It was officially changed with v3, apparently.
15:15:55 <Wild_Cat> it also stands for People Hate Perl.
15:16:05 <dmhouse> Or hey, People Hate PHP.
15:16:15 <Tobsan> that's a good recursive one!
15:16:20 <ddarius> Or even PHP Hates PHP
15:16:21 <chrisdone> more like PHP Hates People
15:16:23 <Wild_Cat> but yeah, now it's PHP Hypertext Preprocessor. Even though most PHP users have no idea what recursion is
15:16:29 <Trinithis> intercal > php
15:16:32 <SamB_XP> PHP Hates Perl, howabout?
15:16:40 <kryptiskt> PHP hates programmers
15:16:42 <SamB_XP> since evidently perl wasn't good enough for the bozos
15:16:44 * lispy reads the SWIG manual and becomes increasingly disillusioned by the apparanty popularity of SWIG
15:16:45 * ddarius has tree recursion, eat that!
15:16:58 <ddarius> lispy: Welcome back to reality.
15:17:10 <Wild_Cat> PHP Hates PHP
15:17:15 <dmhouse> I love the mutually recursive acronyms too, e.g. "HURD is a mutually recursive acronym, standing for HIRD of Unix-Replacing Daemons, where HIRD stands for HURD of Interfaces Representing Depth."
15:17:19 <SamB_XP> they had to go and turn it from a simple template system to a full-on language
15:17:39 <Trinithis> dmhouse: is that a real one?
15:17:41 <Wild_Cat> dmhouse: yeah, shame they spent more time thinking that one out than building an OS out of the acronym :p
15:17:44 <SamB_XP> Trinithis: yes
15:17:52 <SamB_XP> Trinithis: never heard of GNU/HURD?
15:17:57 <Trinithis> nope
15:18:00 <dmhouse> Trinithis: yeah, GNU Hurd is (the beginnings of) a kernel by the GNU guys.
15:18:04 <SamB_XP> aka "GNU"
15:18:04 <Trinithis> gnu i know tho
15:18:08 <dmhouse> I.e. to replace the "Linux" in "GNU/Linux".
15:18:30 <Wild_Cat> actually, it's Linux that replaced HURD in GNU/HURD.
15:18:33 <SamB_XP> (in the future, according to the GNU project)
15:18:49 <Wild_Cat> HURD has been in development for longer than even Duke Nukem Forever.
15:18:50 <Trinithis> Everyone should switch to House
15:18:51 <chrisdone> judging by all available sources HURD is a joke
15:18:53 <SamB_XP> Wild_Cat: eh? don't tell me HURD worked before Linux replaced it
15:18:57 * cjb is amused that we're talking about 20 year-old history as if it's going to happen any day now.
15:19:06 <cjb> Yes, Hurd has been largely given up on.
15:19:06 <Wild_Cat> Longer even than the Guns & Roses' "Chinese Democracy".
15:19:14 <SamB_XP> chrisdone: well, it's not the kind you find on a humour site
15:19:30 <chrisdone> SamB_XP: well, not nice humour sites
15:19:31 <Tobsan> regarding HURD i've been told it's not recommended
15:19:31 <SamB_XP> chrisdone: it's more like Minux in joke-level
15:19:42 <SamB_XP> er. Minix, sorry
15:19:44 <lament> SamB_XP: what i want in an IDE: type-aware code completion that instantly responds to new variable declarations; the concept of a project (does emacs even have that?); navigation (jump to definition, see all uses) that works everywhere in the project; support for multiple configurations (debug, release) without fiddling with makefiles; refactoring tools (rename a variable; rearrange function arguments; turn a piece of code into a ...
15:19:44 <qwr> it has been going to happen any day now for all of that 20-year history ;)
15:19:46 <Wild_Cat> SamB_XP: of course not. But it had been under development for quite a while when Linus first fired up his text editor of choice to write a kernel.
15:19:49 <kryptiskt> "I can (well, almost) hear you asking yourselves 'why?'. Hurd will be out in a year (or two, or next month, who knows), and I've already got minix.
15:19:49 <kryptiskt>     * Torvalds, Linus (1991-10-05). Post to comp.os.minix"
15:19:50 <lament> ... function; etc)
15:20:06 <SamB_XP> Wild_Cat: terminal emulator, actually
15:20:36 <Wild_Cat> SamB: what, is Linus that real a programmer he only uses cat, echo and sed to write code? :D
15:20:40 <SamB_XP> kryptiskt: heh, waaaay behind schedule
15:20:56 <Wild_Cat> (*real* programmers use butterflies, of course ;) )
15:20:59 <SamB_XP> Wild_Cat: no, he started by writing a terminal emulator
15:21:09 <SamB_XP> I think it turned into a kernel by mistake
15:21:23 <Wild_Cat> oh.
15:21:46 <SamB_XP> I'm sure he used a text editor to do it -- he's no ken ;-)
15:21:58 <chrisdone> what's a ken?
15:22:01 <echarleb1is> the funny part about projects in IDEs is eventually your project will grow to a point where the IDEs definition of 'project' no longer fits, or is too annoying to use, and then you go back to Makefiles
15:22:12 <SamB_XP> chrisdone: you don't know who ken is?
15:22:29 <Wild_Cat> a ken is a plastic programmer with no balls.
15:22:30 <ddarius> SamB_XP: There are a lot of Kens.
15:22:32 <chrisdone> SamB_XP: is that a rhetorical question?
15:22:35 <guenni> SamB_XP: me neither
15:22:45 <SamB_XP> it should be in the hacker's lexicon ...
15:22:54 <qwr> erm, i think linus uses some weird emacs-like editor?
15:22:58 <mauke> http://www.catb.org/~esr/jargon/html/K/ken.html
15:22:59 <lambdabot> Title: ken
15:23:04 <guenni> SamB_XP: bloody hell, just tell
15:23:07 <chrisdone> I don't read esr/play pokemon/whatever
15:23:21 <dcoutts> BeelsebobWork: pong
15:23:29 <cjb> qwr: yes, microemacs
15:23:29 <SamB_XP> guenni: look, mauke has helpfully provided a link to the entry
15:23:49 <cjb> (he also uses pine, which is -50 points)
15:24:02 <guenni> SamB_XP: ok, thx
15:24:06 <mmorrow> this is a slightly tricky one that you don't see coming ...
15:24:14 <mmorrow> so, the goal is a function (fmtMoney :: Double -> String) such that
15:24:21 <mmorrow> ghci> fmtMoney (-1123422.25455)
15:24:21 <mmorrow> "-1,123,422.25"
15:24:21 <mmorrow> ghci> fmtMoney (1123422.25555)
15:24:21 <mmorrow> "1,123,422.26"
15:24:52 <stepcut> fmtMoney should have the type, Decimal -> String, btw ;)
15:25:02 * SamB_XP doesn't know how to figure out if that was a rhetorical question or not
15:25:02 <mmorrow> this one has Double -> String
15:25:12 <stepcut> mmorrow: yeah, that's a bug
15:25:33 <Wild_Cat> yup. You don't, *ever* do financial calculations with floating point numbers.
15:25:37 <mmorrow> well, either way, the trickiness stands stands
15:25:44 <Wild_Cat> (and that doesn't only stand for Haskell)
15:25:45 <stepcut> the other bug is that Decimal is slightly buggy too
15:25:47 <stepcut> :(
15:25:52 <mauke> perldoc -q commas
15:25:53 <mmorrow> i just /hapenned/ to call is "Money"
15:25:56 <SamB_XP> stepcut: it is?
15:26:10 <stepcut> SamB_XP: well, the version I wrote is, that's why it's not on hackage
15:26:12 <mmorrow> i'm not doing any calculations with this number
15:26:32 <Wild_Cat> mmorrow: so, what is the problem? You need 2 functions: one Double -> Double that rounds to whatever you want, and a Double -> String that adds the fancy commas.
15:26:59 <mmorrow> there is no problem. i was amused at the unwindy windyness of the solution i have
15:27:04 <SamB_XP> > 0.01
15:27:06 <lambdabot>  1.0e-2
15:27:06 <stepcut> mmorrow: I think you can get slight variances even just reading the number from a string
15:27:12 <SamB_XP> > 0.04
15:27:14 <lambdabot>  4.0e-2
15:27:18 <SamB_XP> > 0.04 :: Float
15:27:20 <lambdabot>  4.0e-2
15:27:23 <SamB_XP> > 0.01 :: Float
15:27:26 <lambdabot>  1.0e-2
15:27:31 <SamB_XP> > 0.000003 :: Float
15:27:33 <lambdabot>  3.0e-6
15:27:38 <mmorrow> stepcut: i'm formatting this to go on a webpage. i get the Double from a database i have no control over
15:27:41 <wolgo__> wow I am stupid
15:27:42 <SamB_XP> > 0.11 :: Float
15:27:44 <lambdabot>  0.11
15:27:46 <stepcut> mmorrow: :)
15:27:48 <SamB_XP> hmm.
15:27:55 <mmorrow> ;)
15:28:00 <wolgo__> I just found the most obvious bug in one of my noob tutorial lessons I am doing.
15:28:04 <wolgo__> Anyhow
15:28:26 <SamB_XP> > toRational 0.11
15:28:28 <lambdabot>  7926335344172073%72057594037927936
15:28:29 <chrisdone> main = return putStrLn "Hello, World!"
15:28:34 <SamB_XP> ah, there we go!
15:28:37 <Wild_Cat> huh? round only rounds to Integral?
15:28:50 <mmorrow> oh yeah
15:29:02 <mmorrow> it gets even *more* fun
15:29:24 <SamB_XP> Wild_Cat: you can't actually round to decimal values in Double or Float ... most of them are not exactly representable!
15:29:26 <mmorrow> well, i guess i cheated by using a certain function in Numeric
15:29:46 <mmorrow> but the pulling-your-hair-out part is the placing of the commas
15:29:49 <Wild_Cat> SamB: good point. Still, it's sometimes useful to fake it.
15:30:07 <mmorrow> oh, 2 dec places
15:30:11 <mmorrow> hard-coded
15:30:17 <chrisdone> mmorrow: we had to do a comma placing function in C in college :P
15:30:24 <Wild_Cat> mmorrow: how so?
15:30:47 <Wild_Cat> just proceed from the end of show myRoundedResult and insert a comma at positions -5, -8, etc.
15:30:50 <mmorrow> that's just the particular problem i had at hand
15:31:11 <jeeves__> Hi, I'm having a little trouble understanding the syntax of this class declaration: class (DBCursor c k v) => DB t c k v | t -> c k v where ...
15:31:20 <mmorrow> the whole point of this really is in the commas
15:31:27 <mmorrow> chrisdone: heh
15:33:12 <jeeves__> does (DBCursor c k v) constrain the types of the variables c k v on the right-hand side of the => ?
15:34:48 <mmorrow> if anyone can do this with a one-liner i'd be way impressed
15:35:14 <mmorrow> my solution: http://hpaste.org/9762
15:35:14 <mmorrow> eeeee
15:35:47 <Trinithis> mmorrow: easy. Just take out the newlines
15:36:01 <sw17ch> why isn't there a chunk in prelude?
15:36:07 <hackage> Uploaded to hackage: benchpress 0.2.1
15:36:37 <mmorrow> Trinithis: heh, it took me a second to realize what you were saying .. i was like "huh?! newlines ?! ohhhh"
15:37:20 <Trinithis> I'm too lazy to read chunk. What does it do?
15:37:32 <mmorrow> sw17ch: that's one that everyonr wishes was there, but no one can agree on it's type (it seems to me)
15:37:46 <sw17ch> Trinithis, chunk :: [a] -> [[a]]
15:37:56 <sw17ch> mmorrow, is there another way to type it?
15:37:57 <Trinithis> Oh, the commented out one is easy to read
15:38:03 <mmorrow> > (\n -> takeWhile (not . null) . fmap (take n) . iterate (drop n)) 4 [0..]
15:38:05 <lambdabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],[...
15:38:24 <sw17ch> there's a better one that doesn't involve both a take and a drop
15:38:28 <sw17ch> but yes...
15:38:39 <mmorrow> i tested em, the nice one is way faster w/ chunk-size *huge*, but slower for small chunks
15:39:36 <Trinithis> sw17ch: got the code?
15:39:52 <sw17ch> http://hpaste.org/9763
15:40:02 <sw17ch> it's not mine originally, i forget who shared that with me (it was in here)
15:40:28 <BMeph> What is that, CPS?
15:40:39 <mmorrow> > let go n = takeWhile (not . null) . uncurry (:) . fmap (go n) . splitAt n in go 3 [0..]
15:40:41 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,2...
15:41:13 <Trinithis> BMeph: Continuation Passing Style
15:41:49 <Trinithis> mmorrow: use fix!
15:42:00 <BMeph> Trinithis: Yes, I know what "CPS" means, I was asking if that was the style in which sw17ch's example was written in. Which I see now, it is. :)
15:42:12 <mmorrow> that cps one is nice looking
15:42:22 <sw17ch> mmorrow, i'm searching the logs for the source..
15:42:40 <BMeph> (Well, sw17ch's given example, since he disavows thinking it up himself...)
15:43:02 <lelf> > unfoldr (\s -> if s==[] then Nothing else Just $ splitAt 3 s) [1..]
15:43:04 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
15:44:36 <mmorrow> i have some code from hpaste from a while ago, i added another chunk and did some timing
15:44:53 <mmorrow> the unfoldr one performs terribly
15:44:59 * mmorrow pastes
15:45:44 <mmorrow> sw17ch: there's a cps one in here, i dunno who's though, likely the same person
15:45:45 <sw17ch> vixey, it was vixey
15:45:48 <mmorrow> http://hpaste.org/9762#a1
15:45:53 <mmorrow> ah, nice
15:45:56 <sw17ch> at least, that's who i got it from :)
15:46:03 <sw17ch> August 6, 2008
15:46:19 <mmorrow> sw17ch: heh, so then i probably got this code from you then ... :)
15:46:21 <wolgo__> 3 files, 3 classes 103 lines of code just to show a full deck of cards in java (I am a noob)
15:46:21 <sw17ch> vixey's implementation used n+k style matching
15:46:32 <mmorrow> ahhh!
15:46:44 <Trinithis> > foldr (\x (xs:xss, n) -> if n < 3 then ((x:xs):xss, n+1) else ([x]:xs:xss, 0)) ([[]], 0) [1..]
15:46:47 <lambdabot>  Exception: stack overflow
15:46:49 <sw17ch> mmorrow, no, that's not mine :)
15:46:51 <mmorrow> oh wow, i didn't even notice that before you said it
15:47:00 <sw17ch> but it seems that the chunk i'm using is more lore than anything
15:47:06 <adekoba> mmorrow: hey, what about http://hpaste.org/9762#a2
15:47:18 * mmorrow looka
15:47:32 <mmorrow> nice
15:47:33 <sw17ch> adekoba, oh... nice
15:47:40 <mmorrow> totally, i like the splitAt
15:47:52 <mmorrow> > let go n = takeWhile (not . null) . uncurry (:) . fmap (go n) . splitAt n in go 3 [0..9]
15:47:54 <sw17ch> taht's much more natural than the CPS one
15:47:54 <lambdabot>  [[0,1,2],[3,4,5],[6,7,8],[9]]
15:48:05 <sw17ch> though, i do believe the CPS one is faster
15:48:08 <mmorrow> @src fmap (,)
15:48:09 <lambdabot> Source not found.
15:48:15 <Trinithis> > foldr (\x (xs:xss, n) -> if n < 3 then ((x:xs):xss, n+1) else ([x]:xs:xss, 0)) ([[]], 0) [1..20]
15:48:17 <lambdabot>  ([[1],[2,3,4,5],[6,7,8,9],[10,11,12,13],[14,15,16,17],[18,19,20]],0)
15:48:21 <mmorrow> err, how do you say that to lambdabot
15:48:22 <mmorrow> ?
15:48:34 <sw17ch> @src fmap
15:48:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:48:36 <sw17ch> ?
15:48:38 <sw17ch> oh dear
15:48:40 <mmorrow> @src (>>=) Maybe
15:48:41 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:48:43 <sw17ch> @index fmap
15:48:43 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:48:52 <sw17ch> @src Control.Monad.fmap
15:48:52 <lambdabot> Source not found. Do you think like you type?
15:48:56 <sw17ch> i have no idea :)
15:49:00 <rwbarton> @src (,) fmap
15:49:00 <lambdabot> fmap f (x,y) = (x, f y)
15:49:01 <mmorrow> the tuple Functor instance is handy for this kinda thing
15:49:04 <mmorrow> yeh
15:49:07 <mmorrow> there it is
15:50:52 * mmorrow add adekoba's chunk to his collection of chunks
15:50:58 <mmorrow> *adds
15:51:06 <sw17ch> mmorrow, you have a collection?
15:51:34 <mmorrow> arr, i guess just right there, plus one-liners that i can think of ..
15:51:45 <mmorrow> so not much more than you've seen :)
15:52:07 <mmorrow> but i didn't really think of it as a collection until 10 seconds ago
15:53:42 <dons> 499 Haskell packages in Arch.
15:53:47 <dons> What will be the 500th ?!
15:53:55 <dons> gaining eternal fame in blog form.
15:54:27 <SamB_XP> eww -- Arch!
15:54:31 <Myoma> oo what should I write?!
15:54:33 <SamB_XP> who uses that anymore???
15:54:55 <matthew-_> SamB_XP: I believe the darcs devels do as they find it faster...
15:54:59 * matthew-_ ducks quickly
15:55:03 * sw17ch guesses his PortAudio package won't be ready in time
15:55:04 <SamB_XP> matthew-_: hah
15:55:10 <SamB_XP> speed isn't everything
15:55:20 <matthew-_> no, but termination is useful ;)
15:55:29 <dons> SamB--
15:55:40 <SamB_XP> usability is a factor -- and arch is the least-usable VCS I've had the misfortune to encounter thus far
15:55:46 <SamB_XP> SamB++
15:56:00 <dons> SamB-- childishness
15:56:25 <dons> anyway, the next buildable package on hackage is likely to get a nice writeup
15:56:28 <SamB_XP> SamB++ puns not a good reason to use --
15:56:29 <matthew-_> now then children
15:56:31 <dons> so make it something good, peoples
15:56:45 <wolgo__> @src filter
15:56:46 <lambdabot> filter _ []     = []
15:56:46 <lambdabot> filter p (x:xs)
15:56:46 <lambdabot>     | p x       = x : filter p xs
15:56:46 <lambdabot>     | otherwise = filter p xs
15:56:52 <dons> i think i'll do a survey of the 500
15:56:58 <dons> that'd be a nice story.
15:57:03 <wolgo__> _
15:57:09 <dons> and look at how there are a magnitude more haskell packages than erlang or ocaml :)
15:57:22 <wolgo__> I understand what that code does!
15:57:22 <sereven> dons: can't gtk2hs be on sourceforge and on hackage?
15:57:27 * wolgo__ is learning!
15:57:40 <dons> 6 erlang packages, 21 ocamls, 500 haskells.
15:57:41 <matthew-_> clearly the base erland and ocaml libraries are so much richer they don't demand as many extra packages
15:57:45 <dons> heh
15:57:49 <stepcut> SamB_XP: wrong arch
15:57:56 <dzlk> well, clearly ocaml and erlang are virginal and unsuitable for general purpose programming, then.
15:58:05 <SamB_XP> stepcut: that's why it's a pun, yes
15:58:08 <dons> 494 python packages..
15:58:13 <Myoma> dzlk, haha
15:58:19 <stepcut> SamB_XP: ah, I missed that line
15:58:20 <dons> dzlk: :)
15:58:31 <matthew-_> dons: yeah, and python has zope. That counts as -1000 at least
15:58:34 <dons> heh
15:58:42 <stepcut> though, I suspect #arch is now the *right* channel for arch linux -- which did not used to be the case :)
15:59:26 <SamB_XP> well considering how horrid arch the VCS is I don't imagine it was that hard to wrest control of the channel from the VCS users ;-P
15:59:29 <haskellian> *** Exception: BSParsing.hs:58:0-55: Non-exhaustive patterns in function update_m       http://hpaste.org/9765
15:59:40 <haskellian> why?
16:00:12 <mauke> because update_m is not defined for all arguments
16:00:38 <sw17ch> haskellian, how is update_m defined?
16:01:26 <matthew-_> also, who the hell uses arch?
16:01:35 <matthew-_> as in the linux distro?
16:01:44 <dons> sigh.
16:01:46 * sw17ch is considering switching from Gentoo
16:01:51 <dons> where's that off-topic kick button
16:02:13 <mmorrow> sw17ch: the collection is here: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5
16:02:13 <Zao> matthew-_: About all the arch users use arch.
16:02:24 <matthew-_> Zao: oh ok, that'd explain that then
16:02:45 <haskellian> http://hpaste.org/9766
16:03:47 <matthew-_> dons: you brought up arch. I'm just curious as I've heard about it on and off for a while, but it seems to refuse to die and I don't have any idea what it brings which is new to the table. But yes, you're right, OT
16:04:26 <dons> I didn't bring up "arch"
16:04:42 <dons> I brought up the fact "Arch Linux" has 499 haskell packages.
16:04:52 <dons> which SamB took as a chance to be typically facetious.
16:05:14 <matthew-_> was so long as it wasn't unexpected...
16:05:24 <haskellian> sw17ch ^^
16:05:31 <SamB_XP> <dons> 499 Haskell packages in Arch.
16:05:52 <sw17ch> chunk n x = let h = take n x
16:05:52 <sw17ch>             in h : (chunk n (drop n x))
16:05:58 <SamB_XP> dons: you did bring up arch. only it was the other arch that you meant ;-)
16:06:01 <sw17ch> well, that failed
16:06:01 <dons> seriously, Sam, what have you done for the community today.
16:06:16 <dons> other than waste people's time goofing off.
16:06:23 <SamB_XP> I complained to Igloo about a problem with GHC's build system?
16:06:30 <matthew-_> just one?
16:06:43 <dons> good to see you're complaining. that will help.
16:06:45 <SamB_XP> well he hasn't fixed it yet
16:08:30 <haskellian> sw17ch: was that to me?
16:08:45 <sw17ch> haskellian, no, i'm sorry
16:08:58 <sw17ch> i tried giving mmorrow another chunk for his collection, but XChat hates me
16:09:01 <SamB_XP> I've also been trying to think how you would create a regression testcase for an optimizer bug ...
16:11:04 <SamB_XP> namely, the failure to inline bitshifts from Data.Bits functions to primitives even when the amount to shift by is given as a literal
16:11:28 <dons> check if the rewrite rule fires.
16:13:15 <haskellian> calling a function that takes one argument and has ahelper that has 2, the main doesnt have to exhaust no? it just passes it on with a defualt param
16:13:42 <SamB_XP> (which actually has more to do with GHC's inliner not caring about whether or not the value of an unboxed argument is given by a literal or not)
16:13:45 <dons> SamB_XP: there's some test code for checking if rewrite rules fire in the stream-fusionn library
16:14:04 <dons> so you could write tests that rely on inlining to sure the "*# 0#" rules are triggered
16:14:08 <dons> or shifted by 0 rules.
16:14:20 <dons> that would be invaluable.
16:15:10 <SamB_XP> heck, I just want shifts by constants to be inlined down to primitives despite the "if"
16:15:28 <dons> quite so. and you can write tests to confirm that is taking place by looking at the rules.
16:15:33 <SamB_XP> (and the "if", of course, to be eliminated)
16:15:44 <dons> you can even just look for the unchecked primops to be produced.
16:15:44 <SamB_XP> hmm.
16:15:51 <dons> if they're not, then it failed.
16:16:12 <haskellian> *** Exception: BSParsing.hs:58:0-55: Non-exhaustive patterns in function update_m
16:16:20 <dons> do you know where to find the rule matching script in stream-fusion?
16:17:39 <matthew-_> also, in a similar fashion, does peekElemOff and pokeElemOff result in indirect address + offset instructions being generated?
16:18:16 <dons> i wonder! they'll boil down to peekWordOff# and friends.
16:18:24 <dons> which should have rather efficient implementations.
16:18:41 <matthew-_> but it should just be one instruction, at least on x86
16:19:17 <matthew-_> agh, I'm just being lazy. I'll test and read the assembler at some point
16:19:23 <dons> ghc-core for the win.
16:19:37 <matthew-_> yeah, well, I'd suspect c-- at least, if not .asm
16:19:58 <matthew-_> I don't know c-- at all - does it try to model that kinda thing?
16:20:00 * ddarius could finish this Google Charts URI generating thing and put it on hackage.
16:20:23 <dons> so, say, peekElemOff nullPtr 10
16:20:25 <dons> goes to
16:20:30 <dons> readIntOffAddr# __NULL 10
16:20:33 <dons> in core
16:20:42 <stepcut> ddarius: isn't there already one on hackage ?
16:20:51 <ddarius> stepcut: Maybe
16:21:17 <ddarius> Looks like there is.
16:21:18 <stepcut> i'm not saying their couldn't be a better one ;)
16:21:57 <pastorn> show is behaving weird
16:22:00 <ddarius> It is pretty outdated or incomplete it looks like.
16:22:19 <stepcut> ddarius: it's a little weird to use as well
16:22:23 <dons> matthew-_: which becomes something like
16:22:24 <dons>    movabsq     29887428472, %rax
16:23:25 <matthew-_> dons: in which case you've done the work for me ;) but I would have not expected that... I'm puzzled now. What exactly is that saying?
16:23:51 <pastorn> when i do (System.IO.writeFile out (show someRandomStructureContainingStrings)) i get \229 written in my file, that is '\\':'2':'2':'9':[]
16:23:53 <matthew-_> ddarius: then it should be marked deprecated or even removed. Or the maintainer should be nudged in a gentle yet firm way. Otherwise hackage will become just a sprawling mess of unmaintained packages.
16:24:08 <pastorn> *System.IO.UTF8.wiriteFile*
16:24:16 <dons> matthew-_: load a 64 bit address to a registe.r
16:24:30 <dons> matthew-_: so i think the offset's been computed, since it was statically known
16:24:30 <stepcut> pastorn: as well you should!
16:24:53 <pastorn> stepcut: ok...
16:24:56 <matthew-_> dons: right, so it's the dynamic case that is more interesting
16:25:17 <ddarius> The interface is similar to mine.  The code uses tricks roughly similar to mine.
16:25:23 <stepcut> pastorn: hrm
16:25:29 <thoughtpolice> matthew-_: deprecation marks are a ticket on hackage, maybe the new hackage server will feature them (you would have to ask dcoutts though)
16:25:56 <thoughtpolice> which would be nice because there are some outdated packages up there
16:25:59 <dcoutts> it should be relatively straightforward to add them
16:26:05 <dcoutts> yes, it'd be pretty useful
16:26:11 <stepcut> pastorn: yes, that seems correct. Assuming character with character code 229 appears in the data structure of course
16:26:20 <dcoutts> though really the client wants this info too in the package index.
16:26:45 <dcoutts> along with an optional 'recommended' version rage for each package
16:27:00 <dcoutts> eg to allow for stable and development versions of packages to be on hackage at the same time
16:27:03 <pastorn> so there's no good way of showing utf-data?
16:27:36 <pastorn> or rather, UTF characters within data structures without getting stuff like this?
16:28:21 <dcoutts> pastorn: if you mean 'show', then not really show on Strings produces an ascii encoding, ie using \2355 escapes etc.
16:28:43 <dcoutts> obviously you can simply print strings to stdout in whatever encoding you like
16:29:50 <pastorn> yeah
16:30:32 <pastorn> since i'm only using tuples here i can just do a function that wraps what i need around every string, making it look like a tuple :)
16:30:36 <sw17ch> :w
16:30:40 <sw17ch> dangit, xchat not vim
16:32:43 <pastorn> unlines . map (\x -> "(\"" ++x++ "\"\t\t,\"\")" ). filter (/="") . lines $ x
16:32:43 <haskellian> someone wanna have a look at this and explain: http://hpaste.org/9767
16:33:27 <Myoma> > map (\x -> "(\"" ++x++ "\"\t\t,\"\")" ) (words "foo bar baz")
16:33:29 <lambdabot>  ["(\"foo\"\t\t,\"\")","(\"bar\"\t\t,\"\")","(\"baz\"\t\t,\"\")"]
16:33:50 <Myoma> > show ("foo","")
16:33:51 <lambdabot>  "(\"foo\",\"\")"
16:34:07 <sw17ch> haskellian, your (x:xs) case doesn't cover [] afaik
16:34:11 <Myoma> > map (show . flip (,) "") (words "foo bar baz")
16:34:13 <lambdabot>  ["(\"foo\",\"\")","(\"bar\",\"\")","(\"baz\",\"\")"]
16:34:14 <glguy> haskellian: the base case is required so that the functions knows what to do when it gets to the end of the list
16:34:20 <pastorn> Myoma: stop plz
16:34:28 <pastorn> :p
16:34:43 <sw17ch> > let a@(x:xs) = [] in a
16:34:45 <lambdabot>   Irrefutable pattern failed for pattern (a@(x : xs))
16:34:46 <pastorn> this can all too easily get out of hand
16:34:51 <sw17ch> haskellian, ^^
16:35:10 <Myoma> pastorn: You can use /ignore to filter people out instead of bossing them about
16:35:37 <haskellian> glguy: but the helper does that not the main
16:36:06 <sw17ch> haskellian, but update_m does the pattern match
16:36:09 <glguy> haskellian: try this then: update_m customer xs = xupdate (customer, []) xs
16:38:20 <haskellian> glguy: thanks, now I see
16:40:09 * matthew-_ wonders whether after 2 glasses of vodka and 2 cocktails, and that it's nearly 1am, whether it's a good idea to be debugging pointer arithmetic
16:40:29 <sw17ch> matthew-_, Are you at the Ballmer peak yet?
16:41:14 <glguy> haskellian: http://hpaste.org/9767#a1
16:41:27 <matthew-_> there's a peak?
16:41:36 <sw17ch> http://xkcd.com/323/ :)
16:41:37 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:43:37 <sjanssen> matthew-_: my rule is to only hack strongly typed languages after drinks :)
16:44:02 <sw17ch> and save your commits until later
16:44:17 <sw17ch> Drunk committing is dangerous
16:44:28 <matthew-_> sjanssen: well, this is haskell after all, but I'm basically writing C in it...
16:44:40 <matthew-_> sw17ch: yeah, drunk in charge of a computer is dangerous, ime
16:44:40 <camior> Anyone know of a nice way to remove the t in "cfToPath t = (,) 1 . norm . shift t"?
16:45:36 <camior> I'm trying to get point free.
16:45:38 <sw17ch> @pl cfToPath t = (,) 1 . norm . shift t
16:45:39 <lambdabot> cfToPath = (((,) 1 . norm) .) . shift
16:45:41 <sw17ch> :D
16:45:49 <sw17ch> camior ^^
16:46:19 <camior> I was kinda hoping for something better than .)
16:46:29 <camior> That kinda scares me.
16:46:49 <sw17ch> camior, redefine it then :)
16:47:17 <mmorrow> UTF8 char length given the first byte in a multibyte char (if it's not such a byte, it's length is given as 0):
16:47:20 <mmorrow> let lenUTF8 w8|w8`shiftR`7==(0x00::Word8)=1|w8`shiftR`5==0x06=2|w8`shiftR`4==0x0e=3|w8`shiftR`3==0x1e=4|otherwise=0 in lenUTF8 247
16:47:24 <sw17ch> camior, sorry, i really don't know
16:47:26 <mmorrow> > let lenUTF8 w8|w8`shiftR`7==(0x00::Word8)=1|w8`shiftR`5==0x06=2|w8`shiftR`4==0x0e=3|w8`shiftR`3==0x1e=4|otherwise=0 in lenUTF8 247
16:47:29 <lambdabot>  4
16:47:37 <mmorrow> 4 bytes
16:47:44 <sw17ch> mmorrow, you're making it look like Perl again, i'm sad now
16:47:52 <mmorrow> UTF8!!
16:48:27 <mmorrow> it looks nicer when it's not de-spaced to fit in an irc line ;)
16:49:42 <sw17ch> mmorrow, well, okay
16:50:23 <camior> Aha, I found a better way: cfToPath = (liftA . liftA) ((,) 1 . norm) shift
16:50:49 <camior> I love them applicative functors.
16:51:40 <dibblego> there is a paper that points out that for any program the lazily evaluated version will always terminate if the eagerly evaluated version does; what is it?
16:52:06 * BMeph <3 xkcd
16:54:44 <BMeph> dibblego: I bet ndm knows... :)
16:54:54 <dibblego> @seen ndm
16:54:54 <lambdabot> I haven't seen ndm.
16:55:03 <dibblego> prolly
16:55:14 * BMeph frowns
16:55:38 <martyn4> Hi all. Quick question. Those anybody whether there is parser for Vim Help files written in Haskell? (kind of hard to google 'vim help parser haskell' and similar)?
16:55:39 <BMeph> Pity he's not on. Of course, he'd likely have answered immediately otherwise.
16:55:52 <martyn4> s/those/does
16:56:49 <dibblego> I wish I had the right google terms for it
16:57:32 <ddarius> dibblego: It is well known that normal order evaluation always reaches the normal form if it exists and that applicative evaluation does not (in the pure lambda calculus).
16:57:45 <ddarius> Pretty much any theoretical text on LC will discuss it.
16:58:02 <dibblego> hmm, I thought I read it in a paper
16:58:22 <ddarius> dibblego: Papers count as theoretical texts.
16:58:43 <ddarius> It's probably mentioned in dozens of papers, quite possibly hundreds.
16:58:51 <dibblego> hmm ok, cheers
16:59:08 <sw17ch> man... my library works, but gosh it's ugly code
16:59:13 <sw17ch> i mean, logically, it's good
16:59:19 <sw17ch> but... aesthetically, it sucks
17:00:14 <sw17ch> any one want to do a code review? :D
17:00:31 <TSC> What does it do?
17:00:55 <sw17ch> TCS: PortAudio bindings
17:01:08 <sw17ch> 923 lines of c2hs
17:01:14 <TSC> Ah
17:01:15 <TSC> No thanks (:
17:01:17 <sw17ch> :P
17:01:45 <sw17ch> general question, should the FFI stuff be pulled out into it's own file, or is having one very large file acceptable
17:02:00 * sw17ch doesn't have a clue how to modularize this, or what best practices concerning modules are
17:03:09 <dons> you might want a Foo.Base and Foo
17:03:17 <dons> where Base has the low level bindings.
17:03:38 <sw17ch> dons: is it possible to prevent that module from being exposed?
17:03:48 <dons> yeah, via the  .cabal exposed-modules and other-modules list.
17:04:11 <sw17ch> dons: oh! handy... there's a plethora of ways to blow your foot off with this library
17:04:25 <dons> yeah, so hide all the dangerous stuff
17:05:08 <sw17ch> dons: i have, it's just all in the same file... now that you've pointed out that i can hide modules, that will allow me to clean this up drastically
17:05:29 <dons> cool
17:05:36 <sw17ch> how does one get permissions to save stuff on code.haskell.org...
17:05:37 <sw17ch> ?
17:06:37 <dons> sw17ch: you ask for an account, visit community.haskell.org
17:06:46 <dons> then malcolm or duncan run a script giving you login space.
17:06:56 <dcoutts> @arr!
17:06:57 <lambdabot> Aye
17:07:03 <dons> that fella.
17:07:39 <dcoutts> we also offer trac instances and we should start providing rss feeds of all the darcs repos
17:07:45 <sw17ch> ah, thanks much... dcoutts, is groveling required?
17:07:57 <dcoutts> sw17ch: no, just file the request through the web form
17:08:17 <dcoutts> sw17ch: you need to say what you want the account for, but groveling is not needed :-)
17:08:35 <haskellian> can i profile so i can see exactly how much time is spent in each function?
17:09:02 <sw17ch> dcoutts, does it help? :D
17:09:09 <haskellian> and can i print the time of the day from haskell? im thinking of running my program while i sleep and see the running time
17:09:49 <dcoutts> sw17ch: heh heh, no. At least grovelling to me doesn't. I'm not usually the one to approve accounts. I usually handle project requests.
17:10:12 <dcoutts> haskellian: see Data.Time
17:10:18 <dcoutts> in the 'time' package
17:10:37 <dcoutts> haskellian: and check the ghc manual section on profiling, it's pretty informative
17:11:09 <chrisdone> darcs supports rss? omfg
17:11:57 <dons> chrisdone: has done since forever.
17:12:00 <sw17ch> wow lawyer speak on tos.html :(
17:12:01 <dons> darcs changes --xml
17:12:20 * chrisdone screams
17:12:24 <chrisdone> ^_^!
17:13:28 <chrisdone> I find writing literate haskell quite fun
17:13:33 <chrisdone> it's like every program is a tutorial
17:13:47 <chrisdone> that only you are going to ever read :P
17:15:02 <dons> sw17ch: your application is in the queue. thanks for stepping up!
17:15:09 <dons> sw17ch: do you also have a hackage account?
17:15:13 <sw17ch> dons: no i do not
17:15:21 <dons> do you know how to get one?
17:15:33 <dons> http://hackage.haskell.org/packages/accounts.html
17:15:34 <lambdabot> Title: HackageDB: User accounts
17:15:49 <dons> dcoutts: can you process sw17ch's application?
17:15:53 <sw17ch> dons: i've been learning for 2 years now... i'm only now getting to the point where i'm capable of helping :)
17:16:09 <dons> i think he's vying for the 500th Arch Linux Haskell package :)
17:16:18 <dons> sw17ch: hehe. ok, yes, the time has come.
17:16:45 <sw17ch> dons: if you want a shining example of awesomeness, this isn't it (yet)
17:16:50 <dons> :)
17:17:08 * sw17ch decides to stay up and hack all night... okay, maybe not...
17:19:54 <dcoutts> dons, sw17ch: account created
17:20:02 <sw17ch> dcoutts, and it works
17:20:22 <dcoutts> gwern: btw, do you still want that 'split' project space?
17:21:04 <sw17ch> dons, dcoutts, thanks. i'll be back later
17:21:20 <TSC> Is it possible to derive an instance of Enum for a type with a binary constructor, e.g. "data Card = Card Rank Suit" ?
17:21:39 <dcoutts> TSC: sadly not
17:21:49 <TSC> That is indeed sad
17:22:01 <dcoutts> TSC: you will have to make a custom Enum instance
17:22:24 <TSC> Ah well
17:22:30 <TSC> Thanks, dcoutts
17:36:08 <hackage> Uploaded to hackage: wavconvert 0.1.1
17:36:08 <hackage> Uploaded to hackage: wavconvert 0.1
17:36:08 <hackage> Uploaded to hackage: mersenne-random-pure64 0.2.0.2
17:36:08 <hackage> Uploaded to hackage: mersenne-random 0.1.3
17:37:57 <dons> wwoo!!
17:38:23 <dons> Binkley wins prize for 500th package... if I can build it.
17:38:37 <dons> oh, simple deps. looks promising.
17:38:58 <dons> building..
17:39:36 <dons> there we are,
17:39:37 <dons> http://aur.archlinux.org/packages.php?ID=19205
17:39:39 <lambdabot> Title: AUR (en) - wavconvert
17:41:13 <jeeves__> How would I read this class declaration? I'm not really that familiar with the syntax: class (DBCursor c k v) => DB t c k v | t -> c k v where ...
17:41:29 <dons> mm.
17:41:50 <dons> if you you have a DBCursor c k v, I can give you a DB t c k v
17:41:53 <Pseudonym> jeeves, the first thing to ignore is everything after the pipe.
17:41:55 <dons> where t determines what c k v are
17:42:02 <jeeves__> hmm, ok
17:42:19 <Pseudonym> But yes, it's saying that if DBCursor c k v is true, then DB t c k v is true, and here's why.
17:42:42 <Pseudonym> Simpler example:
17:42:48 <Pseudonym> class (Ord n) => Num n where ...
17:43:29 <Pseudonym> If n is ordered (i.e. less-than-comparable), then n can be a number, and here's why...
17:43:34 <rwbarton> well, it's a class declaration, so it's more like "For t to be a DB with cursor type c, key (?) type k, value (?) type v, c must already be a DBCursor with key type k and value type v and (whatever comes after where)"
17:43:47 <Pseudonym> You can also think of it as Ord being a superclass of Num.
17:43:51 <rwbarton> "Moreover the type t determines the types c, k, and v"
17:43:57 <jeeves__> ok
17:44:01 <Pseudonym> Yes, that's what the fundep means.
17:44:04 <Pseudonym> The bit after the pipe.
17:44:07 <jeeves__> Ah, that's a fundep?
17:44:14 <Pseudonym> Yes.
17:44:28 <jeeves__> I've seen references to the concept of fundep, but haven't used it myself yet :)
17:44:53 <Pseudonym> http://www.haskell.org/haskellwiki/Functional_dependencies
17:44:55 <lambdabot> Title: Functional dependencies - HaskellWiki
17:45:11 <jeeves__> So we can consider DB to be a subclass of DBCursor?
17:45:22 <Pseudonym> Yes,.
17:45:27 <Pseudonym> You can think of it that way.
17:45:52 <Pseudonym> Actually, this is a bit more poweful than a mere subclass relationship.
17:46:00 <Pseudonym> But it's a good way to think about it.
17:46:30 <adu> yey
17:46:52 <jeeves__> Thanks for the tips, all three of youo
17:46:55 <jeeves__> -o
17:47:45 <jeeves__> I think part of my problem is also how this is being used -- it seems odd to me that a database is being considered a "subclass" (in some sense) of its own cursor
17:48:02 <jeeves__> (this is the BerkelyDB module, but it only supports 1.x. I'm thinking of adding some support for later versions)
17:48:21 <Pseudonym> jeeves, what other programming languages do you speak?
17:48:47 <jeeves__> Most. Well, not C++ or the # languages. ;)
17:48:58 <Pseudonym> Not C++.  OK, that's what I wanted to know.
17:49:00 <Pseudonym> :-)
17:49:11 <jeeves__> No Ocaml either (I learned Haskell instead)
17:49:12 <Pseudonym> Because this isn't actually a subclass relationship.
17:49:22 <jeeves__> ok
17:49:23 <Pseudonym> It's a precondition.
17:49:28 <Pseudonym> Similar to what C++ calls a "concept".
17:49:53 <Pseudonym> It's saying that if c is a DBCursor, then t is a DB.
17:50:00 <jeeves__> hm, ok
17:50:17 <Pseudonym> A precondition for having a database is having a valid database cursor.
17:50:20 <rwbarton> No--despite the notation, it's saying that if t is a DB, then c is a cursor
17:50:29 <rwbarton> (which is what you just said now)
17:50:33 <adu> jeeves__: interesting
17:50:35 <Pseudonym> Right.
17:50:43 <adu> jeeves__: you're like me :)
17:50:56 <Pseudonym> Incidentally, you would get massive kudos for supporting a recent BDB.
17:51:04 <jeeves__> well, I'm still pretty green, but hey, learn by doing
17:51:10 <Pseudonym> Absolutely.
17:51:11 <jeeves__> plus I really want to get the hang of the FFI
17:51:40 <adu> jeeves__: the c=>hs part is a piece of cake, the hs=>c one is the one you have to think about...
17:51:57 <Pseudonym> Here's a simpler example that may be more familiar:
17:52:06 <jeeves__> adu: yeah, so I gathered from certain tutorials :) Thankfully I mostly need to call C from Haskell
17:52:11 <Pseudonym> class (Ord k) => Map m k v | m -> k v where
17:52:27 <Pseudonym> This is actually pretty close to the class declaration that you have there.
17:52:31 <Pseudonym> Oh, hang on.
17:52:45 <Pseudonym> class (Ord k) => Map m k | m -> k where
17:52:48 <Pseudonym> That's better.
17:53:05 <Pseudonym> Map is like a binary search tree.
17:53:11 <jeeves__> ok
17:53:34 <Pseudonym> What it's saying is that Map only makes sense defined on keys which are Ord-comparable.
17:53:44 <Pseudonym> Does that make sense?
17:54:06 <jeeves__> Yes
17:54:10 <Pseudonym> Map isn't a subclass of Ord.  Ord is a precondition that must be satisfied for Map to amke sense.
17:54:18 <jeeves__> Ah, ok
17:54:46 <jeeves__> That does make sense with this code. I think I was getting confused by the syntax
17:55:01 <jeeves__> (which is sensible, I just hadn't seen it yet)
17:55:05 <edwardk> /ME WAVES HELLO,
17:55:09 <edwardk> woops capslock
17:55:18 <adu>  /me waves back
17:55:19 <Pseudonym> HELLO EDWARdk
17:56:02 <Pseudonym> The thing is, in Haskell, subclasses are handled precisely with these precondition arrangements.
17:56:15 <Pseudonym> You can think of Ord being a subclass of Eq, for example.
17:56:19 <gwern> @pl \x -> x==x
17:56:19 <lambdabot> join (==)
17:56:21 <Pseudonym> But actually, we do it this way:
17:56:29 <Pseudonym> class (Eq x) => Ord x where
17:56:30 <adu> jeeves__: so what other languages do you know?
17:56:47 <Pseudonym> That is, Eq x is a precondition for Ord x to make sense.
17:57:03 <Pseudonym> Kinda neat, when you think about it.
17:57:12 <jeeves__> Pseudonym: I see. And I had seen some examples like that in the tutorials on type classes, but was having difficulty "translating" the simpler examples to this case
17:57:19 <dzlk> So Ord a -> Eq a ?
17:57:20 <Pseudonym> Right.
17:57:47 <Pseudonym> dzlk: (->) is the function type.  I don't think you meant to ask that.
17:57:52 <adu> no Eq a => Ord a
17:57:52 <Pseudonym> Function type constructor, sorry.
17:58:09 <EvilTerran> adu, yes, but the => points the wrong way in a class definition
17:58:11 <dzlk> Oh, sorry, I meant implication.
17:58:23 <Pseudonym> No, the => points the _right_ way.
17:58:28 <jeeves__> adu: Well, I've written a lot of programs in C, perl, ruby, and Objective-C, a few in Prolog, and some dabbling in Lisp, Scheme, and Erlang
17:58:44 <Pseudonym> If Eq is true, the Ord is true if the stuff in the "where" clause is also true.
17:58:48 <SamB_XP> Pseudonym: in a CLASS declaration?
17:58:53 <Pseudonym> Yes.
17:58:56 <SamB_XP> okay ...
17:59:06 <Pseudonym> Let me explain.  Simplified example.
17:59:21 <Pseudonym> class (Eq x) => Ord x where compare :: x -> x -> Bool
17:59:28 <Pseudonym> OK?
17:59:36 <adu> Pseudonym: i think if you replace "true" with "defined" then, yes
17:59:47 <EvilTerran> Pseudonym, ok, it points the right way if you parse it that way
17:59:50 <mmorrow> '=>'  points the wrong way if it's taken to be implication
17:59:55 <Pseudonym> What this is saying is that if Eq x is true, and there is a compare :: x -> x -> Bool, then Ord x is true.
17:59:58 <EvilTerran> Pseudonym, but that parse is different from the one in "instance" declerations
18:00:18 <EvilTerran> which're "instance ... => (... where ...)"
18:00:22 <Pseudonym> No, same way as in instante declarations.
18:00:25 <Pseudonym> instance
18:00:31 <EvilTerran> as compared to "class (... => ...) where ..."
18:00:46 <Pseudonym> The "where" part is part of the left hand side of the implication.
18:01:00 <EvilTerran> it's a different use of "where"
18:01:21 <EvilTerran> in intances, it's kinda like "and"
18:01:28 <rwbarton> The "where" in a class definition should be something like "provided"
18:01:36 <EvilTerran> and in classes, it's like "if"
18:01:43 <dcoutts> can anyone find the document that establishes the convention how modules should be named?
18:01:57 <adu> Pseudonym: that means that (the type a is an instance of the type class Ord) implies (the type a is an instance of the type class Eq)
18:02:03 <dcoutts> ie that they should reflect the use/content not where it's from or the name of the implementation
18:02:37 <adu> Pseudonym: so (=>) means (<-)
18:02:38 <Pseudonym> Right, ok, I see what you mean adu.
18:03:01 <Pseudonym> There are several ways the syntax could have been expressed.
18:03:42 <sw17ch> ah, well i'm too late :)
18:03:49 <sw17ch> guess i'll polish my library a little more :)
18:04:58 <adu> Pseudonym: I would have chosen (interface Eq a !@#$%^&* Ord a) which makes so much more sense :)
18:05:33 <jeeves__> adu: heh
18:05:36 <Pseudonym> Wadler's Law applies here.
18:05:45 <gwern> argh. this is a total downer. so eval went well, but quickcheck is just refusing to work! as far as I can tell, the invoked command is perfect, but nevertheless...
18:05:50 <jeeves__> Pseudonym: thanks *much* for the mini-tutorial
18:06:00 <Pseudonym> No problem.  Now write it up for the wiki.
18:06:04 <Pseudonym> :-)
18:06:24 <jeeves__> is this channel logged somewhere?
18:06:45 <TomMD> everywhere
18:06:48 <TomMD> @where irc
18:06:48 <lambdabot> I know nothing about irc.
18:06:51 <TomMD> @where logs
18:06:52 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
18:06:57 <sw17ch> my program is not deterministic :X
18:07:24 <lispy> mmorrow: ping?
18:07:35 <TomMD> sw17ch: I hope it isn't - when I say "NO, do not launch the nukes!"  I like it to act different that when I say "launch! Now!! LAUNCH!"
18:08:11 <jeeves__> excellent
18:08:20 <dzlk> Hm. Wait, doesn't -> also mean implication in type signature of a function?
18:08:26 <sw17ch> TomMD: it's scary... same inputs, different outputs
18:08:35 <TSC> Is it possible to use ST as a monad transformer, like you can do "StateT s IO a" ?
18:09:14 <TomMD> Yes, I understood.  So your scope of "input" must be different than your programs concept of "input".
18:09:33 <sw17ch> TomMD: yes... and i'm asking a microphone for input... :D
18:09:38 <sw17ch> so, that's definitely not the same
18:09:56 * sw17ch will tackle this later...
18:10:00 <TomMD> sw17ch: Ah, yes.  I suppose that would be a fun problem.  Never done audio processing.  It would be fun, though.
18:11:06 <mmorrow> lispy: yo
18:11:35 <lispy> mmorrow: if I included your haskell.sty into the darcs source code (which is GPL'd) would you object?
18:12:08 <gwern> lispy: make sure to get his dual-license permission!
18:12:11 <lispy> mmorrow: for one, I can't promise I'd keep it in sync
18:12:16 <mmorrow> not at all
18:12:30 <lispy> mmorrow: heh, as gwern says, if we end up BSD'd is that problem?
18:12:47 <mmorrow> uh oh
18:12:49 <sjanssen> lispy: you can't leave the BSD license on just that file?
18:13:02 * lispy suspects sjanssen is right
18:13:59 <mmorrow> hmm, err what is the sensible thing for me to do?
18:14:12 <sjanssen> how is haskell.sty licensed?
18:14:15 <lispy> mmorrow: remind me what your current license is?
18:14:19 <mmorrow> (i was kidding around with the "uh oh")
18:14:32 <lispy> mmorrow: heh, ah
18:14:37 <mmorrow> lispy: i really just made very minor mods the that haskell.sty
18:14:43 <mmorrow> *mods to that
18:14:50 <mmorrow> i'm not the primary author
18:15:21 <lispy> who was, chak?
18:15:26 <mmorrow> or do you mean that darcs repo?
18:15:36 <lispy> I wonder if I should use this one then? http://www.cse.unsw.edu.au/~chak/haskell/haskell-style/
18:15:38 <lambdabot> Title: Haskell Style for LaTeX2e
18:15:41 <mmorrow> i dunno, i can't even remember where i came across it.
18:15:51 <mmorrow> ohhh, that's right.
18:16:38 * mmorrow looks at the existing header on haskell.sty
18:17:23 <lispy> hmm...I thought i darcs got it from it
18:17:30 <lispy> but i don't see the repo
18:17:36 <mmorrow> oh, lispy ... haskell.sty is *already* gpl
18:17:43 <lispy> cool
18:17:49 <lispy> what was your url again?
18:17:50 <mmorrow> http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/haskell.sty
18:17:52 <lambdabot> http://tinyurl.com/57grkb
18:17:57 <gwern> > ["-E", "--expression=\'myquickcheck (\x -> x==x)\'"]
18:17:57 <lambdabot>  Illegal escape sequence at ""--ex..." (column 8)
18:17:58 <lispy> Ah, it's the name that threw me off
18:18:01 <mmorrow> which is is this darcs repo:
18:18:03 <lispy> the cont-lhs-eg
18:18:07 <mmorrow> http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
18:18:08 <lambdabot> Title: Index of /~morrow/code/haskell/cont-lhs-eg
18:18:09 <mmorrow> yeah
18:18:13 <gwern> > ["-E", "--expression=\'myquickcheck (\\x -> x==x)\'"]
18:18:17 <lambdabot>  ["-E","--expression='myquickcheck (\\x -> x==x)'"]
18:18:23 <gwern> @check join (==)
18:18:25 <lambdabot>  OK, passed 500 tests.
18:18:34 <gwern> hm. why the \\?
18:18:41 <lispy> mmorrow: just do a \usepackage{haskell} when it's in the same dir, right?
18:18:48 <gwern> > ["-E", "--expression=myquickcheck (\\x -> x==x)"]
18:18:50 <lambdabot>  ["-E","--expression=myquickcheck (\\x -> x==x)"]
18:19:00 <gwern> > ["-E", "--expression=myquickcheck (\x -> x==x)"]
18:19:01 <lambdabot>  Illegal escape sequence at ""--ex..." (column 8)
18:19:10 * gwern hates strings
18:19:20 <gwern> > ["-E", "--expression=myquickcheck (/\x -> x==x)"] -- heck I don't know
18:19:21 <lambdabot>  Illegal escape sequence at ""--ex..." (column 8)
18:19:23 <mmorrow> that's always worked for me, but beyond that i don't know how theolving paths works/etc
18:19:29 <gwern> :(
18:19:29 <mmorrow> *resolving
18:19:50 <mmorrow> lispy: so yes.
18:20:02 <lispy> mmorrow: thanks, I'll try it out
18:20:33 <lispy> mmorrow: does it have an inline code macro?
18:21:12 <mmorrow> lispy: err, i'm bot quite sure if or if it does how to use it
18:21:17 <mmorrow> *not
18:21:33 <lispy> mmorrow: I dont' see one, but I suspect i'll just try \small\ttfamily
18:21:48 <adu> i reclassified my program, now there are 2 programs in Console on hackage...
18:21:51 <lispy> mmorrow: or something like that so that it just stands out..I really only name identifiers that way
18:22:20 <gwern> all I want to do is run:
18:22:22 <gwern> popen binary ["-E", "-e \'myquickcheck (\x -> x==x)\'"] Nothing
18:22:24 <gwern> any help?
18:22:32 <gwern> I can't seem to quote the lambda right
18:23:03 <mmorrow> ohh, ok. i don't know what i was thinking about. yeah, i haven't really used it other than tweaking how it looks/trying to get everything working
18:23:05 <gwern> \\x doesn't work
18:23:09 <gwern> and I can't imagine what else to try
18:23:35 <rwbarton> gwern: it's definitely the backslash?  does myquickcheck (const True) work?
18:24:13 <gwern> no, not necessarily, but I need to be able to handle lambda exprs
18:24:34 <rwbarton> > "\'"
18:24:36 <lambdabot>  "'"
18:25:31 <mmorrow> popen binary ["-E", "-e \'myquickcheck (\\\\x -> x==x)\'"] Nothin  ?
18:26:09 <mmorrow> i think the  \x ->   backslash is two levels deep, ubt i'm not sure where this is being run from
18:26:16 <sjanssen> isn't "-e \'myquickcheck (\\\\x -> x==x)\'" wrong?
18:26:26 <rwbarton> what's the value of binary?
18:26:28 <sjanssen> -e and the myquickcheck business should be separate arguments
18:26:38 <mmorrow> probably, but i think it's something w/ some backslash
18:26:50 <gwern> *Lambdabot.Process>  ["-E", "-e \'myquickcheck (\\\\x -> x==x)\'"]
18:26:51 <gwern> ["-E","-e 'myquickcheck (\\\\x -> x==x)'"]
18:26:57 <gwern> doesn't look right
18:26:58 <mmorrow> wait, are we in bash right now?
18:27:07 <mmorrow> ok, in haskell
18:27:09 <mmorrow> ?
18:27:11 <gwern> sjanssen: what about when it's in --expression='foo bar' format?
18:27:16 <sjanssen> gwern: I don't think you should have to do any quoting
18:27:35 <sjanssen> @src runInteractiveProcess
18:27:36 <lambdabot> Source not found. Maybe you made a typo?
18:28:16 <edwardk> does anyone know of any attempts to use a bibop style memory allocator with haskell?
18:28:27 <adu> bibop?
18:28:42 <edwardk> 'big back of pages' its a lisp idea from way back
18:28:43 <sjanssen> gwern: if you put a space between two things when you write it in your shell, they should be separate list elements when passed to popen
18:28:46 <mmorrow> so you're using runInteractiveProcess to run ghc with an -e option and passing it a haskell expression?
18:29:13 <gwern> hm? no, I'm running mueval with a haskell expr
18:29:16 <gwern> and a few options
18:29:25 <edwardk> a minor simplification of the idea would be: don't tag objects, tag the page they are on, every object on the same page carries the same tag.
18:29:45 <sjanssen> gwern: this should work: popen binary ["-E", "-e", "myquickcheck (\\x -> x == x)"]
18:30:09 <edwardk> i accept that the bibop is kinda slow for checking the unknown case, but when you mix in the dynamic pointer tagging kinda tricks used by the stg nowadays you already have a fast path, which is orthogonal to the bibop issue
18:31:13 <gwern> sjanssen: dang it that works
18:31:17 <gwern> how frustrating
18:31:56 <edwardk> a naive hybrid might be, store a tag in the first word of a 4k page, then to check the tag associated with an object mask off the page, if its zero, go back 4 bytes from the reference and look there, that would let you allocate using an increment style allocator, and then the garbage collector can choose to dedicate pages to pool certain tags perhaps based on whether there are enough of them to fill a page (ski rental style)
18:32:59 <edwardk> since to case you usualy look at the tag bits on a pointer anyways you typically don't have to touch the tag on evaluated data anyways
18:33:13 <hansfbaier> Just for curiosity: Who is able to upload new packages to hackagedb, what are the requirements?
18:33:39 <gwern> hansfbaier: anyone who asks for an account
18:33:47 <hansfbaier> gwern: where?
18:33:49 <gwern> who qualifies? I dunno. I guess anyone who hangs out in #haskell or -cafe?
18:33:58 <gwern> hansfbaier: hackage has info
18:34:07 <hansfbaier> gwern: thanks
18:34:08 <gwern> somewhere in its pages, it lists who to email, or has a web form
18:34:09 <adu> hansfbaier: these ppl: http://hackage.haskell.org/cgi-bin/hackage-scripts/list-users
18:34:10 <lambdabot> Title: HackageDB: registered users
18:34:22 <haskellian> why is this not working?print (Data.Time.getClockTime)
18:34:31 <haskellian> :t Data.Time.getClockTime
18:34:36 <adu> hansfbaier: http://hackage.haskell.org/packages/accounts.html
18:34:37 <lambdabot> Title: HackageDB: User accounts
18:34:48 <edwardk> anyways it's just a thought would shave off a pointer off of every object for which there were more than ~4k worth or whatever floating around. ghc already stores an extra pointer for SMP purposes anyways, so you have a place for the forwarding pointer. it probably couldn't work with ghc but its interesting as a design decision for a fresh stg implementation.
18:35:10 <adu> hansfbaier: so far as I know, warm blood qualifies you
18:35:36 <adu> hansfbaier: no reptiles allowed
18:35:38 <hansfbaier> adu: :)
18:35:51 <gwern> :t print
18:35:52 <lambdabot> forall a. (Show a) => a -> IO ()
18:36:08 <hackage> Uploaded to hackage: only 0.0.4.0
18:36:16 <hansfbaier> no need yet, just curious. I sent the jack library maintainer a patch to add midi support. Would be nice to see it upstream some time
18:36:27 <adu> thats mine! I made 'only'
18:36:35 <gwern> congrats
18:37:06 <adu> and i fixed a bug with empty regexes :)
18:38:18 <adekoba> anyone working on an LOLCODE implementation?
18:38:47 <Spark> i hope not
18:38:59 <Spark> there are plenty of more useful things that need to be done
18:39:23 <adu> Spark: like geek code parsers?
18:39:25 <adekoba> sure
18:39:29 * adekoba rolls eyes
18:40:44 <mmorrow> this is hillarious
18:40:47 <mmorrow> http://en.wikipedia.org/wiki/LOLCODE
18:40:48 <lambdabot> Title: LOLCODE - Wikipedia, the free encyclopedia
18:41:18 <mmorrow> IM IN YR LOOP
18:41:18 <mmorrow>    UP VAR!!1
18:41:18 <mmorrow>    IZ VAR BIGGER THAN 10? KTHX
18:41:21 * gwern pushes the mueval patches. I'm exhausted.
18:42:46 <dcoutts> mmorrow: you should write an interpreter :-)
18:43:11 <b\6> can parsec read from a handle?
18:43:33 <qwr> b\6: if it cant you can give it char stream...
18:43:34 <mmorrow> it looks like there's not much too it, and i'm still laughing audibly. so maybe
18:43:36 <gwern> @tell Cale check the lambdabot repo. I've converted it to mueval
18:43:37 <lambdabot> Consider it noted.
18:43:39 <adu> mmorrow: KTHXBYE
18:43:43 <adu> lol
18:43:49 <mmorrow> CAN HAS STDIO?
18:43:50 <adekoba> yes, use the h* functions in System.IO then feed that to parsec  (@ b\6)
18:43:50 <ddarius> No.  Parsec3 could be abused to, but I wouldn't recommend it.
18:44:58 <qwr> but what's the difference really between giving handle or lazy getContents ?
18:45:21 <ddarius> qwr: Control
18:46:52 <qwr> ddarius: well yes... but does it matter? depends of course, what b\6 tries to do...
18:48:12 <adu> mmorrow: CAN HAS ALL.YR.PARSER.COMBINOS?
18:48:36 <b\6> hmm. hGetLine is leaving a \r on the ends of the lines. the protocol i'm messing with (nntp) specifies \r\n line endings. i was thinking about using parsec to get lines instead, because hGetLine 1) leaves junk \r and 2) doesn't tell me if it didn't really read a line like /(.*)\r\n/
18:49:29 <stepcut`> does this function exist already, foldl mplus mzero :: (MonadPlus m) => [m a] -> m a
18:50:06 <rwbarton> @src msum
18:50:07 <lambdabot> msum =  foldr mplus mzero
18:50:17 <rwbarton> almost
18:50:46 <stepcut`> good enough, except I realize that is not actually the signature I want
18:50:48 <adu> b\6: parseFromFile
18:50:53 <idnar> @type msum
18:50:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:50:59 <stepcut> I actually want, [a] -> m a
18:51:04 <b\6> adu: that wants a filename. i have a handle.
18:51:29 <stepcut> basically, msum . map return
18:51:54 <adu> b\6: then use hGetContents >>= \c -> parseTest start c
18:53:27 <b\6> oh, ok. forgot about hGetContents.
18:53:37 <adu> b\6: :)
18:55:48 <noecksit> @type 'a'
18:55:49 <lambdabot> Char
18:55:54 <noecksit> @type ''
18:55:55 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:56:14 <noecksit> is it possible to represent an empty char?
18:56:23 <b\6> what would that mean?
18:56:26 <adu> @type "" :: [Int]
18:56:27 <mmorrow> lol http://hpaste.org/9769
18:56:27 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:56:35 <mmorrow> IM IN YR LOOP UPPIN YR VAR TIL BOTHSAEM VAR AN 10
18:57:05 <noecksit> adu: isnt that a String?
18:57:23 <adu> @type "" :: [Char]
18:57:24 <lambdabot> [Char]
18:57:43 <noecksit> adu: well, thats a [Char], not Char though
18:57:54 <adu> @type [] :: String
18:57:55 <lambdabot> String
18:58:28 <noecksit> adu: so i guess the answer is no
18:58:39 <adu> noecksit: what was the question?
18:58:48 <mmorrow> b\6:   you could do     hGetLineCR h = return . takeWhile (/='\r') =<< hGetLine h
18:59:15 <noecksit> adu: is it possible to represent an empty char?
18:59:25 <mmorrow> no
18:59:29 <adu> noecksit: only for Maybe Char
18:59:44 <noecksit> were u testing smthing out yourself and i thought it had smthing to do with me?
18:59:50 <b\6> mmorrow: yeah, but it's kind of an error not to get \r\n, so i think i'll try to use parsec.
18:59:56 <noecksit> ok thanx
18:59:57 <mmorrow> cool
19:00:24 <adu> > chr 0
19:00:26 <lambdabot>  '\NUL'
19:00:32 <mmorrow> yeah, it probably would be bad to not know if there was a '\r' ;)
19:00:43 <adu> noecksit: isn't that what '' means in C?
19:00:50 <mmorrow> '\0'
19:00:55 <mmorrow> > '\0'
19:00:57 <lambdabot>  '\NUL'
19:01:04 <mmorrow> > '\1'
19:01:05 <lambdabot>  '\SOH'
19:01:11 <mmorrow> > '\SOHO'
19:01:12 <lambdabot>  Improperly terminated character constant at "'\SOH..." (column 1)
19:01:28 <rwbarton> > '\1O'
19:01:29 <lambdabot>  Improperly terminated character constant at "'\1O'" (column 1)
19:01:38 <rwbarton> > "\1O"
19:01:40 <lambdabot>  "\SOHO"
19:01:44 <mmorrow> heh
19:01:49 <b\6> is there a parsec combinator like count but can specify a max number of matches?
19:02:00 <shapr> yeah, sort of
19:02:18 <shapr> I ended up writing fromMtoN long ago, I think it's hanging around somewhere
19:02:32 <shapr> I tried to get Daan to include it :-)
19:02:41 <b\6> thought i saw it in the parsec3 source lately, but i don't see it now.
19:02:55 <adu> > chr 1046
19:02:57 <lambdabot>  '\1046'
19:03:14 <mmorrow> chr maxBound
19:03:15 * dcoutts follows up on dons note about the 500'th package in Arch
19:03:18 <mmorrow> > chr maxBound
19:03:20 <lambdabot>  Exception: Prelude.chr: bad argument
19:03:36 <mmorrow> > chr (2^24-1)
19:03:38 <lambdabot>  Exception: Prelude.chr: bad argument
19:03:42 <adu> > maxBound :: Char
19:03:44 <lambdabot>  '\1114111'
19:04:17 <adu> > showHex 1114111 ""
19:04:19 <lambdabot>  "10ffff"
19:04:51 <adu> that's better
19:05:04 <shapr> b\6: This is from long ago, I know better versions exist somewhere on my hard drive: http://hpaste.org/9770
19:05:42 <b\6> thanks.
19:08:23 <b\6> is parsec3 in some weird state where old stuff is right next to new stuff? seems like new stuff is in Text.Parsec, older stuff in Text.ParserCombinators.
19:08:39 <shapr> b\6: Ah, I knew I saw better versions somewhere... "darcs get --partial http://cryp.to/hsemail/" and look in Rfc2234 at manyN and manyNtoM
19:08:41 <lambdabot> Title: Parsers for the Internet Message Standard
19:09:05 <chrisdone> this is why I like emacs: http://chrisdone.com/fun.png
19:09:16 <ddarius> Text.ParserCombinators is a compatibility library for the old Parsec.  If you look at the code it all just delegates to the newer stuff.
19:09:21 <chrisdone> why is writing IRC bots always so fun?
19:09:34 <b\6> shapr: thanks.
19:09:39 <haskellian> wtf why cant i just call Data.Time.getClockTime ?
19:09:47 <b\6> heh, already had it checked out.
19:10:06 <ddarius> chrisdone: Wasting two pixels both horizontally and vertically. Pah.
19:11:02 <shapr> @users
19:11:03 <chrisdone> ddarius: hahaha
19:11:03 <lambdabot> Maximum users seen in #haskell: 492, currently: 437 (88.8%), active: 19 (4.3%)
19:11:11 <shapr> Whoa, nearly up to 500 again
19:11:17 <chrisdone> nice
19:11:22 <shapr> I want a darcs-graph of #haskell!
19:11:49 <chrisdone> what's a darcs-graph, squire?
19:11:54 <shapr> @go darcs graph
19:11:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/darcs-graph.html
19:11:57 <lambdabot> Title: darcs-graph : graph commit activity of darcs repositories
19:12:16 <geezusfreeek> we do have http://www.haskell.org/haskellwiki/Image:Nick-activity.png
19:12:17 <lambdabot> Title: Image:Nick-activity.png - HaskellWiki
19:13:14 <sw17ch> what's a good permissive open source license every one likes (or, is there any reason not to use the MIT license)?
19:13:19 <shapr> BSD?
19:13:28 <adu> shapr!
19:13:49 <ddarius> sw17ch: Most Haskell stuff is BSD
19:14:19 <shapr> adu!
19:14:30 <shapr> You screamt?
19:14:59 <sw17ch> ddarius, is there a specific reason?
19:15:20 <haskellian> arent Maps unfunctional, they can only be used in monads?
19:15:34 <sjanssen> haskellian: nope
19:15:40 <shapr> adu: Are you coming to visit?
19:15:54 <chrisdone> I personally prefer the â€œuse it anywhere and anyhow, but I'm not liable for breakage.â€ ones
19:16:22 <chrisdone> haskellian: Maps don't require monads at all
19:16:45 <chrisdone> haskellian: not side-effectual/stateful ones, anyway
19:16:47 <ddarius> sw17ch: Haskellers aren't fond of GPL and most code is already BSD anyhow.  Anything that's BSD-compatible is fine.
19:17:00 <shapr> Personally, I prefer GPL.
19:17:04 <shapr> But that's just me.
19:17:21 <shapr> and I know edwardk fights the GPL with a passion, and prefers BSD.
19:17:56 <geezusfreeek> i passionately don't make my code GPL, but i'm not so passionate about what others choose to license their code under
19:17:57 <chrisdone> shapr: wanting to keep your code open or encourage others do or both?
19:17:59 * sw17ch goes to check the license attached to PortAudio, will probably follow suit
19:18:07 <adu> shapr: visit? where are you?
19:18:17 <ddarius> shapr: Most of the Haskell community wants to get as many people to use their code as possible.
19:18:32 <sjanssen> sw17ch: GHC doesn't support dynamic linking, so it is legally tenuous to use even LGPLed libraries
19:18:59 <b\6> yeah, that's weird. it matters for sdl.
19:19:07 <shapr> adu: Northeast... Boston
19:19:13 <shapr> chrisdone: Yes.
19:19:16 <rwbarton> sjanssen: you're talking about LGPLed Haskell libraries right?
19:19:21 <sjanssen> rwbarton: right
19:19:22 <sw17ch> sjanssen, hmmm... good point
19:19:28 <sjanssen> rwbarton: GHC can dynamically link to C libraries
19:19:29 <chrisdone> shapr: you answered yes to a multiple choice question :D
19:19:32 <adu> shapr: then why is your ISP in virginia?
19:19:35 <shapr> ddarius: Yeah, but I personally have been screwed over enough by companies taking advantage of BSD.
19:19:51 <shapr> adu: I'm pretty sure my hostname says "Somerville, MA"
19:20:00 <shapr> sbo = south boston, smr = somerville
19:20:15 <sw17ch> PortAudio also has a permissive "we don't care, just preserve the copyright notice" license
19:20:33 <adu> shapr: oic
19:22:01 <adu> i like new england, mostly NH tho, never hung out in MA
19:22:12 <shapr> Feel free to drop by. You can crash on my couch.
19:23:19 <sjanssen> do Macs have pkg-config?
19:23:21 <adu> shapr: nice! i'll bring my 6 desktops and plug them all in to yr grid :P
19:26:23 <adu> sjanssen: yes, but generally in /sw/bin or /opt/local/bin
19:27:04 <adu> sjanssen: what for?
19:27:48 <adu> shapr: do you have any books on haskell?
19:29:37 <sjanssen> adu: I'm packaging bindings for libXau, and I'd rather use pkg-config than a configure script if possible
19:30:29 <sjanssen> adu: from your description, it seems pkg-config is available in fink/macports, but not in the developer tools?
19:32:26 <adu> sjanssen: that is correct. there is some remnants of pkg-config, (like xml2-config) and even /usr/lib/pkgconfig/*.pc, but no "pkg-config" proper in vanilla macosx or devtools
19:32:57 <sjanssen> adu: okay, thanks
19:36:08 <hackage> Uploaded to hackage: mueval 0.6
19:36:08 <hackage> Uploaded to hackage: botpp 0.1
19:39:15 <sw17ch> is there a specific way you're supposed to reference the C2HS module?
19:39:27 <sw17ch> one that's better than explicitly declaring the include path
19:46:58 <mmorrow> oh noes
19:47:05 <mmorrow> utf8 decoding one-liner:
19:47:08 <mmorrow> let utf8 = (let{fi=fromIntegral;multi x n=fi(x`shiftR`n.&.0x3f.|.0x80);first x n y=fi(x`shiftR`n.|.y);test n = span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000];setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0]))))}in(\n->concatMap(\(a,b)->first n a b:(fmap(multi n).takeWhile(>=0))(iterate(subtract 6)(a-6)))(setup n))) in utf8 463
19:47:17 <mmorrow> > let utf8 = (let{fi=fromIntegral;multi x n=fi(x`shiftR`n.&.0x3f.|.0x80);first x n y=fi(x`shiftR`n.|.y);test n = span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000];setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0]))))}in(\n->concatMap(\(a,b)->first n a b:(fmap(multi n).takeWhile(>=0))(iterate(subtract 6)(a-6)))(setup n))) in utf8 463
19:47:17 <chrisdone> I puked a little
19:47:19 <lambdabot>  [199,143]
19:47:31 <mmorrow> haha
19:47:37 <ivanm> do I dare ask what that "one-liner" is meant to do?
19:47:37 <thoughtpolice> they should make an action figure of mmorrow
19:47:41 <sw17ch> chrisdone, mmorrow has been doing that for a while now :)
19:47:44 <sw17ch> i'm immune
19:47:56 <mmorrow> UTF8 decoding!!!
19:48:06 <ivanm> from what to what?
19:48:11 <ivanm> utf8 to ascii?
19:48:17 <mmorrow> String -> String
19:48:19 <SamB_XP> nonsense!
19:48:27 <mmorrow> @type let utf8 = (let{fi=fromIntegral;multi x n=fi(x`shiftR`n.&.0x3f.|.0x80);first x n y=fi(x`shiftR`n.|.y);test n = span((/=0).(.&.(n::Int)))[0xffffff80,0xfffff800,0xffff0000,0xffe00000];setup n = (take 1.reverse.snd.unzip)(zip(snd(test n))(reverse(zip([0,6,12,18])([0,0xc0,0xe0,0xf0]))))}in(\n->concatMap(\(a,b)->first n a b:(fmap(multi n).takeWhile(>=0))(iterate(subtract 6)(a-6)))(setup n))) in utf8
19:48:29 <lambdabot> forall b. (Num b) => Int -> [b]
19:48:39 <chrisdone> that's cool
19:48:44 <ivanm> funny looking strings to me...
19:48:46 <chrisdone> > 'a' + 'b'
19:48:48 <lambdabot>   add an instance declaration for (Num Char)
19:48:48 <lambdabot>     In the expression: 'a' + 'b'...
19:48:51 <chrisdone> ;_;
19:49:09 <SamB_XP> UTF-8 can't be made any more ASCII than it already is, except by tossing chars with codepoints >127
19:49:11 <mmorrow> so it's take an Int, and then decoding it into a [Word8]
19:49:30 <mmorrow> some utf8 chars are 4 bytes
19:49:33 <dolio> concatMap utf8 would be your [Int] -> [Word8] decoder.
19:49:44 <mmorrow> exactly!
19:49:52 <SamB_XP> er, I mean, except by tossing bytes >127
19:49:58 <dolio> Or, encoder.
19:50:05 <mmorrow> yeah, it's confusing
19:50:12 <SamB_XP> so it makes little sense to decode UTF-8 to ASCII
19:50:36 <mmorrow> well, suppose you read bytes into a ByteString from a Handle
19:50:39 <mmorrow> and it's utf8
19:50:46 <sw17ch> grr...
19:50:52 <sw17ch> parse error on input `import'
19:50:57 <sw17ch> from the code generated by c2hs...
19:51:00 <mmorrow> err, that would be the opposite way as the func i just gave
19:51:11 <SamB_XP> I was just objecting to what ivanm said ;-P
19:51:23 * sw17ch forgot to clean... woops
19:51:24 <mmorrow> ahh
19:51:46 <ivanm> well, I was trying to work out what kind of decoding that supposed one-line function was meant to do...
19:51:57 <sw17ch> never mind, no difference
19:52:03 <sw17ch> still breaks...
19:52:10 <mmorrow> ivanm: i'll paste the nononeliner
19:53:06 <mmorrow> oh ha, so as a result of writing a utf8 decode/encode i have a haskell cli app that turns stdin upside down
19:53:08 <mmorrow> !
19:53:53 <sw17ch> grr... it was a missing symbol...
19:54:05 <mmorrow> $ echo '{!pb_spx??}' | flip
19:54:09 <mmorrow> {Â¿Â¿xbsâ€¾qbÂ¡}
19:54:09 <sw17ch> but instead of complaining about an unknown identifier, it thinks import was broken...
19:54:39 <SamB_XP> wow, that actually worked ... here ... in WINDOWS
19:54:56 <chrisdone> mmorrow: $ echo 'excuse me wtf r u doin' | flip
19:54:57 <ivanm> mmorrow: do I dare ask... _why_?
19:55:06 <mmorrow> hahahaha
19:55:10 <SamB_XP> ivanm: because it's FUNNN
19:55:21 <ivanm> with three 'n's? :o
19:55:32 <sw17ch> ...or so i thought. i'm wrong again, still broke
19:55:39 <SamB> in fact, the flipping messes up the baseline alignment here under Linux
20:02:40 <chrisdone> sometimes I really wish I could use parentheses to make my english more precise without confusing the hell out of people
20:03:55 <chrisdone> I think I've written about 300 lines of haskell code today. not so bad
20:04:33 <lispy> mmorrow: whoa, that's cool
20:05:14 <lispy> mmorrow: you should reverse the string maybe
20:05:25 <lispy> mmorrow: so that it looks as though there is a mirror
20:06:37 <chrisdone> then animate the bottom letters ripple so it looks like a water reflection
20:10:07 <SamB_XP> lispy: what ??
20:10:31 <lispy> SamB_XP: did you see his example?
20:10:47 <SamB_XP> lispy: yes, it was rotated pi
20:11:02 <andyjgill> Evening room.
20:11:29 <dsrogers> Haskell is making me learn new things.  Bad haskell -- be simple .
20:11:34 <dsrogers> ;-)
20:11:57 <lispy> andyjgill: good evening
20:12:24 <lispy> dsrogers: yeah, I find that if a function is more than a few lines, I'm probably doing it wrong
20:12:55 <ivanm> lispy: but how long do you let your lines be? :p
20:13:11 <lispy> ivanm: heh, good point
20:13:25 <dsrogers> try reading HoC.  Lots of 40+ line functions.  lots of embedded type theory -- almost no comments
20:13:50 <ivanm> what's HoC?
20:13:58 <dsrogers> haskell to objective c bindings
20:14:03 <ivanm> ahhh
20:14:05 <sw17ch> does haddock bubble up documentation for items imported from hidden modules?
20:14:13 <SamB_XP> dsrogers is taking up the maintainership for HoC
20:14:18 <dsrogers> apparently.
20:14:28 <dsrogers> I have commit access now anyways.
20:14:30 <lispy> dsrogers: what is the utility of HoC?
20:14:42 <dsrogers> lispy: you can write mac os x applications in haskell.
20:14:55 <lispy> dsrogers: ah, and get the standard gui and what not?
20:14:55 <dsrogers> lispy: build your interface in InterfaceBuilder, and your code in haskell.
20:15:07 <dsrogers> not just the standard gui, the standard gui builder.
20:15:21 <dsrogers> and a .app
20:15:28 <thoughtpolice> i was thinking of making some basic bindings to objective-C (or the obj-c runtime) a while back and had heard about HoC
20:15:37 <lispy> dsrogers: Okay, but playing devil's advocate, why would I prefer that over wxHaskell or gtk2hs the later of which is maintained and works other platforms
20:15:41 <thoughtpolice> i thought it would be wonderful if that pain could be avoided and hoc wasn't left to bitrot :)
20:16:12 <dsrogers> lispy: that depends on how much you like InterfaceBuilder or care about mutiplatform support for your gui.
20:16:27 <dsrogers> lispy: you can always write several gui's for the thing.
20:16:36 <lispy> dsrogers: I see.  With gtk2sh I could use glade...
20:17:03 <lispy> dsrogers: would HoC give a Haskell entry into the iphone? (I think much more work must be done in the compiler for this to work out...)
20:17:18 <dsrogers> well if you had a cross compiler, yeah.
20:17:23 <thoughtpolice> until we can get GHC to compile for ARM probably not
20:17:32 <thoughtpolice> but it would help once GHC gets there I'm sure
20:17:49 <dsrogers> there is a utility that can theorically use to automatically build bindings for any objective-c library
20:17:50 <sjanssen> would Apple allow it?
20:17:52 <SamB_XP> hmm, you'd need to use HoC *on* ARM
20:17:53 <thoughtpolice> providing hoc has links to the iphone sdk as well (whatever's changed in there)
20:18:14 <dsrogers> sjanssen: I don't know.
20:18:16 <thoughtpolice> dsrogers: the interface bridge or whatnot? wasn't that a feature of leopard?
20:18:17 <SamB_XP> ... since it uses TH and all ...
20:18:34 <dsrogers> it uses a ton of TH
20:18:41 <dsrogers> yeah, the interface is bridged.
20:18:51 <lispy> oh, didn't someone say something about TH needed ghci?
20:18:58 <SamB_XP> yes
20:19:23 <lispy> But you only need it once at compile time then you're good right?
20:19:24 <SamB_XP> which means it needs to run on the same architecture as the target
20:19:29 <lispy> so you could still crosscompile Iwould think
20:19:52 <SamB_XP> well, only if you could get one version of GHC to target multiple architectures ...
20:19:58 <dsrogers> you can implement an objective-c class in haskell, or partially in haskell
20:20:10 <thoughtpolice> the new native code gen should really help with cross compiling from what I hear - I think it's one of Dias's longer term plans for the new code gen
20:20:14 <lispy> But, ultimately, if I were to start an iPhone app today I wouldn't try to use Haskell.  I just wouldnt want to deal with the overall unready/unsupportedness
20:20:31 <dons> dcoutts: i think hackage should have a big green count of how many packages are on hackage.
20:20:43 <SamB_XP> well yes, there's no telling how long it will be before it's reasonable to use TH to target iPhone
20:20:48 <SamB_XP> er.
20:20:50 <SamB_XP> ARM
20:20:51 <thoughtpolice> lispy: you would be very brave if you started today and were set on it :)
20:20:52 <dons> we should advertise in big letters how successfull hackage is.
20:21:34 <lispy> thoughtpolice: yeah, it just seems like a lossing proposition to use haskell at this time for iphone dev
20:21:41 <dsrogers> can't you run ghci on the hostplatform, even when cross compiling?
20:21:48 <lispy> thoughtpolice: anything other than generating obj-c would probably be a mess
20:21:50 <thoughtpolice> if GHC becomes cross-compilable that would help things immensely
20:21:57 * SamB_XP mumbles something about a sign for how long GHC has gone without broken builds that are caused by actual problems in GHC/it's build system
20:22:00 <thoughtpolice> in all areas
20:22:04 <mmorrow> ok, just packaged it:  darcs repo  http://code.haskell.org/~morrow/code/haskell/utf8-light/
20:22:05 <lambdabot> Title: Index of /~morrow/code/haskell/utf8-light
20:22:14 <mmorrow> docs: http://code.haskell.org/~morrow/code/haskell/utf8-light/haddock/
20:22:15 <lambdabot> Title: utf8-light-0.1: utf8-light
20:22:26 <mmorrow> it has that flip cli prog too !
20:22:31 <mmorrow> hahaha
20:23:04 <SamB_XP> but even when GHC can cross-compile, it will be a while before we can get TH to work with cross-compilation
20:23:10 <thoughtpolice> lispy: obj-c has a regular C runtime you can bind too - it's specifically mentioned to really only be of interest to those binding cocoa to other languages
20:23:17 <SamB_XP> and will probably involve significant changes to TH
20:23:49 <thoughtpolice> why would TH pose a significant challenge?
20:24:01 <lispy> thoughtpolice: I just meant, you could write haskell code that generates C or obj-c and then do Haskell dev on iphone that way...but hmm...that might still be tricky?
20:24:24 <thoughtpolice> lispy: oh right, yeah that would probably be a little tricky although perhaps nicer with Language.C now
20:24:28 <lispy> thoughtpolice: I guess maybe you can do -f-via-c or something, but would that work?
20:24:43 <SamB_XP> ... cross-TH would invalidate the assumption that all expressions have the same value at runtime and compile time
20:24:55 <SamB_XP> for instance
20:24:57 <lispy> thoughtpolice: like would you have to port the RTS separately?
20:25:22 <SamB_XP> AND you'd need to have *one* GHC that targetted at least *two* architectures
20:25:35 <thoughtpolice> lispy: yes, plus from the way GHC is ported to other platforms you actually have to copy configure-generated includes over for things to work, so the generated C code is tied to the platform a bit
20:25:52 <lispy> Probably if you're serious about Haskell on iPhone you shouldn't use ghc.  I bet nhc (or whatever it's evolved into these days) would work much better
20:25:55 <SamB_XP> (since it would need to target the host architecture for GHCi to work)
20:26:49 <lispy> But again, I think I'd just suck it up and use obj-c/c++/c for the time being
20:26:49 <ddarius> ihc !
20:26:53 <thoughtpolice> lispy: generating C that calls carbon functions from e.g. a DSL doesn't seem impractical but yeah it would be quite a bit of work
20:27:30 * lispy wonders about making an iPhone app that is based on a theory of apple
20:27:47 <thoughtpolice> personally I was pondering recently about perhaps extending Language.C to be able to generate CUDA-compatible code
20:27:55 <dsrogers> thoughtpolice: it's more impratical than you thing for carbon.  At least Objective-C has a naming convention and strong behaviors for memory ownership.
20:28:03 <lispy> thetallguy: what is CUDA?
20:28:25 <lispy> er
20:28:27 <lispy> thetallguy: sorry
20:28:29 <thoughtpolice> dsrogers: i've never used carbon and have little obj-c experience admittingly.
20:28:33 <lispy> thoughtpolice: what is CUDA?
20:28:58 <thoughtpolice> lispy: it basically lets you program your graphics card with C
20:29:07 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-light-0.1
20:29:08 <thoughtpolice> it's a compiler targeting the GPU, for the most part
20:29:13 <lambdabot> Title: HackageDB: utf8-light-0.1, http://tinyurl.com/6gqhyk
20:29:34 <lispy> thoughtpolice: oh, I don't think you need that on the iphone.  It supports opengl-es and some osx mobile sort of thing that I forgot the name of
20:29:48 <thoughtpolice> the main problem with the extending Language.C to understanding it (so it can parse/generate it) is I'm not sure how much - if any - non-standard extensions are introduced by the CUDA compiler
20:29:57 <dsrogers> if anyone is interested, HoC head builds and works on my machine.
20:30:13 <dsrogers> 10.5 mac book pro
20:30:16 <lispy> dsrogers: congrats
20:30:47 <thoughtpolice> dsrogers: awesome! like I said I was thinking of making my own bindings but if hoc is up and running again that just makes life a lot easier :)
20:31:13 <dsrogers> it was mostly working when I got here.
20:31:21 <dsrogers> the build system had rotted a bit.
20:31:30 <dsrogers> and I made it use the system's libffi
20:31:31 <thoughtpolice> lispy: if you have a recent nvidia card you could look into it - http://www.nvidia.com/object/cuda_home.html
20:31:31 <dons> dcoutts: something like this http://galois.com/~dons/images/packages.png
20:31:37 <lambdabot> Title: CUDA Zone -- The resource for CUDA developers
20:31:58 <thoughtpolice> i thought using language.c to generate/parse cuda could would be cute for the most part, although it could be potentially end up useful for other things
20:36:08 <hackage> Uploaded to hackage: utf8-light 0.1
20:36:23 <dons> oh snap, a utf8-light package.
20:36:28 <dons> :-)
20:36:33 <dsrogers> what use is a type class with no methods?
20:36:47 <dons> you can use it to add constraints, to specific types.
20:36:56 <dsrogers> for example?
20:37:00 <dons> Atomic a ; instance Atomic Int ; instance Atomic Word
20:37:22 <dons> fast_add :: Atomic a, Num a => a -> a -> a
20:37:32 <dsrogers> ah
20:37:41 <dons> mmorrow:
20:37:42 <dons> [1 of 1] Compiling Encoding.UTF8.Light ( src/Encoding/UTF8/Light.hs, dist/build/Encoding/UTF8/Light.o )
20:37:45 <dons> /tmp/ghc9627_0/ghc9627_0.s: Assembler messages:
20:37:48 <dons> /tmp/ghc9627_0/ghc9627_0.s:3378:0: Error: suffix or operands invalid for `test'
20:37:59 <dons> mmorrow: it's a ghc bug, but can be worked around with -fvia-C in the package for now.
20:38:12 <dsrogers> then what does the part after the | mean in "class (Object a, Object b) => ClassAndObject a b | a -> b, b -> a"?
20:38:24 <dons> that's a functional dependency. it's a constraint on the matching of types, basically
20:38:26 <lispy> dsrogers: functional dependencies
20:38:30 <dons> a and b determine each other.
20:38:38 <ddarius> dons: Are your big numbers out of date already?
20:39:15 <mmorrow> dons: hmm?
20:39:23 <dsrogers> is there some explanation of that?
20:39:32 * mmorrow add -fvia-C
20:39:40 <mmorrow> *addS
20:40:35 <dons> ddarius: yep.
20:40:43 <dons> ddarius: it should be scripted :)
20:40:57 <lispy> dsrogers: yeah there are some papers about it
20:41:04 <dons> hackage.haskell.org needs pimping out.
20:41:13 <lispy> dsrogers: It's not very intuitive to learn, but it's very powerful.
20:41:15 <dons> "pimp my library hosting"
20:41:23 <dons> it's prolog on the type system :)
20:41:46 <lispy> dsrogers: basically it allows you to have multiparameter type classes and generate the percise instances you want
20:42:46 <lispy> aren't fun deps how oleg implements the lambda calc in the haskell type system in just a few lines?
20:42:52 <dino-> dsrogers: This explains it a bit: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
20:43:01 <dsrogers> ah.
20:43:03 <ddarius> One of the things people often first learn from Haskell is the value of the trivial.
20:44:04 <lispy> dsrogers: http://www.haskell.org/haskellwiki/Type_arithmetic#A_Really_Advanced_Example_:_Type-Level_Lambda_Calculus
20:44:06 <lambdabot> Title: Type arithmetic - HaskellWiki, http://tinyurl.com/jp7bh
20:44:09 <dsrogers> so givin: "instance ClassAndObject (Class a) (ID a)" and the class declaration above, that means that given an ID a, OR a Class a we know uniquely that this is the particular instance that will be used?
20:44:36 <ddarius> > let in 1+1
20:44:38 <lambdabot>  2
20:44:51 <lispy> ddarius: whoa, i didn't realize that was a valid parse
20:45:34 <dsrogers> so if you tried to do a "instance ClassAndObject (Class a) (Foo a)" as well, could the type system complain?
20:46:00 <sw17ch> in a cabal package, is it possible to set the ghc flags per file?
20:47:21 <dsrogers> oh wow.  You can have divergent type expressions...
20:48:04 <lispy> dsrogers: not in haskell 98, but yes with fun deps you can, hence the comment about prolog in the type system
20:53:42 <sw17ch> @index peekArray
20:53:43 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
20:53:58 <dsrogers> woo hoo!
20:54:00 <dsrogers> I was right!
20:54:09 <dsrogers> Type.hs:13:0:
20:54:09 <dsrogers>     Functional dependencies conflict between instance declarations:
20:54:09 <dsrogers>       instance TypeDep (Type1 a) (Type2 a) -- Defined at Type.hs:13:0-35
20:54:09 <dsrogers>       instance TypeDep (Type1 a) (Type3 a) -- Defined at Type.hs:15:0-35
20:55:35 <dsrogers> so functional dependences are for checking a contract on an instance declaration.
20:55:55 <fhsu> join #iphone
20:56:11 * sw17ch has cabalized his portaudio package
20:57:09 <dsrogers> I have a 10 line file that is probably a good example of functional dependencies.
20:57:22 <mmorrow> dons: fixed, thx.
20:59:44 <adu> i'm back
21:01:03 <adu> kthx?
21:04:22 <sbahra> Hi
21:05:01 <sbahra> http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
21:05:04 <lambdabot> Title: Applications and libraries/Program development - HaskellWiki, http://tinyurl.com/rolrs
21:05:11 <sbahra> "vim script based function/module completion, cabal support, tagging by one command, context completion ( w<tab> -> where ), module outline, etc" = 404
21:05:34 <sbahra> MarcWeber, do you still have this online?
21:09:05 <nodogbite> i'm strugglin with euler 70
21:09:16 <nodogbite> this one's a beast
21:09:41 <shapr> adu: I think so
21:10:05 <novas0x2a> hm. i'm trying to build hexpat. when i run the build step, it complains that it can't find the module Text.XML.Expat.IO, which it supposed to be provided by the package. Am I doing something wrong?
21:10:15 <adu> shapr: :)
21:10:26 <dons> shapr:  http://galois.com/~dons/images/packages.png  that's how many packages are in hackage now
21:10:31 <dons> how awesome is that?
21:10:36 <shapr> adu: Actually, I had three or four Haskell books, but I don't know how many I have left.
21:10:44 <shapr> dons: awesome!
21:10:59 <adu> dons: cool! did I help with my grep thing?
21:11:07 <dons> adu, yep1
21:11:08 <idnar> the real question is, how good are the packages? :P
21:11:17 <dons> idnar: they're really good. :)
21:11:32 <idnar> that's usually the problem with CPAN-style package collections
21:11:56 <dons> luckily haskell's already a quality filter :)
21:12:05 <idnar> yeah, that's true
21:12:05 <adu> lol
21:12:13 <dons> if you can a) construct a haskell module, b) cabalise it c) get a hackage account d) upload it,
21:12:20 <dons> it's probably not uselesss.
21:12:44 <adu> shapr: ah ok, i forgot i asked that question
21:13:25 <sw17ch> my package depends on the C2HS module, do i need to include that file in my project manually (which is the only way i've gotten it to work now), or is there a flag/module i can import for it?
21:15:12 <sw17ch> dons, you don't know off hand do you?
21:15:51 <adu> sw17ch: do you mean Language.C?
21:16:28 <sw17ch> adu, no... i'm thinking C2HS
21:16:46 <sw17ch> i used c2hs to build the library binding, and it needs the C2HS module
21:16:55 <adu> sw17ch: o ic
21:17:18 <sw17ch> that's not exposed anywhere from what i can tell, so i've copied the C2HS.hs file into my build directory and included it in the other-modules line in the cabal file
21:17:24 <sw17ch> it feels really dirty
21:17:39 <sw17ch> though, it may be to prevent c2hs updates from breaking applications...
21:18:12 <adu> you might try {-# OPTIONS_GHC -i/path/to/C2HS #-} at the top
21:18:38 <sw17ch> adu: /usr/local/share/c2hs-0.15.2/C2HS.hs
21:18:45 <sw17ch> i doubt that's acceptable for a distributable package
21:19:41 <dons> sw17ch: check with dcoutts
21:19:47 <sw17ch> dcoutts: ping
21:20:02 * sw17ch guesses he's out for the evening
21:20:55 <dons> you could certainly copy the module in, and hide it from the exports
21:21:03 <dons> but i'm not sure you're supposed to do that.
21:21:11 <sw17ch> dons, that's what i've done... and i don't think i'm supposed to
21:21:24 <tennin> is there some secret way to get into ICFP without spending the $1500?
21:21:26 <sw17ch> gtk2hs imports C2HSState
21:21:38 <sw17ch> and C2HSConfig
21:21:41 <tennin> two years ago most of the people at the GHC Hackathon seemed to think I could probably just sneak in
21:21:45 <tennin> I didn't try it, though
21:21:50 <sw17ch> but it's included in the package
21:22:48 <shapr> dons: Ever heard of a Language.Java or even better, Language.C# ?
21:23:09 <adu> shapr: you'd have to add -XMagicHash to import that
21:23:14 <shapr> ah
21:24:06 * sw17ch thinks -XMagicHash causes unpleasant visits from the DEA
21:24:29 <adu> sw17ch: or you could become a contributor of c2hs and put C2HS in their exposed-modules section
21:24:49 <adu> sw17ch: lol
21:28:14 <adu> which inspires me.....
21:28:25 <sw17ch> hehehe
21:28:25 <adu> should I turn 'only' into a library?
21:29:23 <geezusfreeek> adu: "should i" is a very ambiguous question. you should do it if you want to!
21:29:42 <mmorrow> adu: why not, since it's easy to and only use could come of it
21:29:46 <adu> only :: [Int] -> [Int] -> (a -> Bool) -> [a] -> [a]
21:30:02 <adu> i can't think of any other related functions
21:30:33 <sbahra> What does only do, adu?
21:30:40 <geezusfreeek> dons: that package count image is dynamically updated i assume?
21:30:53 <geezusfreeek> if so then it shall become one of my dashboard widgets
21:30:55 <tehgeekmeister> when an alex based lexer complains about a lexical error, does it mean that my patterns are non-exhaustive?
21:31:00 <adu> sbahra: its a very powerful filter
21:31:04 <adu> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/only
21:31:10 <lambdabot> Title: HackageDB: only-0.0.4.0
21:32:09 <adu> it takes expressions of the form N/regex/M which selects the M-th lines surrounding the N-th occurence of "regex"
21:32:36 <sbahra> adu, I see.
21:32:47 <dons> geezusfreeek: no, it's just a mock up.
21:32:53 <geezusfreeek> aw
21:32:54 <dons> but i'll do a scripted version
21:33:02 * geezusfreeek removes it from dashboard
21:33:05 <dons> heh
21:33:12 <adu> lol
21:33:13 <dons> so you can subscribe to a url?
21:33:22 <geezusfreeek> yup
21:33:25 <dons> how often does it decide to update?
21:33:33 <geezusfreeek> actually to a selected area of any page
21:33:44 <geezusfreeek> i am not sure. it seems to stay pretty up to date
21:34:29 <geezusfreeek> it only tries when you activate the dashboard, and i don't think it updates every single time
21:36:09 <hackage> Uploaded to hackage: utf8-light 0.2
21:38:02 <adu> dons: I did that once, copied Distribution.Make into a Setup.hs file because it didn't export "exec" :(
21:38:38 <dons> geezusfreeek: that's cool.
21:38:45 <dons> ok. so i'll do a proper version :)
21:38:57 <geezusfreeek> heh
21:40:18 <sbahra> > otherwise
21:40:20 <lambdabot>  True
21:44:40 <sw17ch> hmm... apparently it's not just my library that has issues
21:47:19 <adu> night
21:55:20 <sw17ch> good night
21:56:00 --- mode: ChanServ set +o glguy_
21:56:17 --- mode: glguy_ set -b *!*@d86-33-235-132.cust.tele2.at!#haskell-ops
22:23:49 <Twey> @src words
22:23:50 <lambdabot> words s = case dropWhile isSpace s of
22:23:50 <lambdabot>     "" -> []
22:23:50 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
22:30:40 <Twey> @src break
22:30:40 <lambdabot> break p =  span (not . p)
22:30:56 <Twey> @src span
22:30:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:31:01 <Twey> :-\
22:31:43 <cjs> Huh? I thought that the quote was, "The more you drive, the stupider you become."
22:31:48 <cnwdup> twey: "span p xs is equivalent to (takeWhile p xs, dropWhile p xs) " (hoogle)
22:31:50 <Trinithis> twey: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#span
22:31:52 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/23ncyu
22:32:09 <Twey> Thanks, Trinithis, cnwdup... already found it :)
22:32:31 <cjs> Ah, sorry. "The more you drive, the less intelligent you are." According to IMDB, anyway.
22:32:52 <Twey> Heh
22:32:58 <glguy_> maybe the person that entered that was doing a lot of driving?
22:33:22 <Twey> Clearleah
22:42:37 <Trinithis> What would be a cool thing to program. I'm bored.
22:42:58 <znutar> hunt the wumpus
22:45:20 <Trinithis> What's that game where there's some magic word that is used as a metasyntactic variable (like foo or bar). I forget the name of the var
22:47:17 <Trinithis> xyzzy is it?
22:47:26 <cjs> You wanna hack on a mailing list server?
22:47:52 <Trinithis> Like what?
22:48:17 <cjs> svn://anonsvn.starling-software.com/public/mhailist/trunk
22:48:34 <cjs> Dunno if there's anything of interest to you in there, but you can look around.
22:48:49 <Deewiant> Trinithis: xyzzy was originally in colossal cave adventure
22:48:57 <Trinithis> :D
22:49:25 <cjs> We're just getting started, though we have a version running right now. We're currently writing up the transaction logs (which will be eventually distributed) so we can switch the subscription list to that. There's a big desrcription under the doc dir.
22:50:01 <Trinithis> FF doesnt like svn
22:50:55 <bos31337> does john meacham ever work on jhc any longer?
22:52:57 <Trinithis> cjs: how do I open a svn protocol? Firefox doesn't do the trick
22:53:49 <cjs> Oh, you have to use svn. "svn co svn://anonsvn.starling-software.com/public/mhailist".
22:53:57 <cjs> I can probably cons up a tarball if you don't have svn.
22:54:04 * Twey chuckles at 'Firefox doesn't do the trick'
22:54:40 <Twey> ta'o Did you ever get Gentoo running, Trinithis?
22:54:52 * cjs thinks someone should add something to Firefox to just automatically browse svn: URLs, 
22:55:07 <cjs> Or you can use TortiseSVN under Windows pretty simply. That's all menu-driven.
22:55:17 <Trinithis> Twey: I'm going to wait until my new hard drive comes in the mail.
22:55:33 <cjs> I do believe we build under Windows; if there are any problems with that, feel free to report it to mhailist@lists.starling-software.com.
22:55:50 <cjs> (mhailist-subscribe@lists... will subscribe you, but we don't do confirmation messages yet.)
22:57:01 <Trinithis> Twey: plus on sunday, I'm moving into some dorms, and perhaps a fellow geek can guide me
22:57:36 <Twey> Oh ah
23:34:21 <yaru1022> hello
23:34:37 <yaru1022> I was writing 'isPrime' method and having a problem ...
23:34:54 <Soliah> What sort of problem?
23:34:55 <yaru1022> isPrime :: Integer -> Bool
23:34:55 <yaru1022> isPrime n = not . or . map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)]
23:34:55 <yaru1022>  
23:35:16 <yaru1022> type mismatch problem...
23:35:32 <yaru1022> > isPrime n = not . or . map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)]
23:35:33 <lambdabot>  Parse error at "=" (column 11)
23:36:12 <yaru1022> > \n -> (not . or . map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)]) 31
23:36:13 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
23:38:26 <mmorrow> > isPrime n = (not . or) (map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)])
23:38:26 <lambdabot>  Parse error at "=" (column 11)
23:38:40 <mmorrow> > let isPrime n = (not . or) (map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)]) in isPrime 27
23:38:42 <lambdabot>   add an instance declaration for (Num (t, t))
23:38:42 <lambdabot>     In the expression:
23:38:42 <lambdabot>        ...
23:39:24 <mmorrow> @type let isPrime n = (not . or) (map (\x -> n `divMod` x == 0) [2 .. (floor . sqrt $ n)]) in isPrime
23:39:25 <lambdabot> forall b. (RealFrac b, Floating b, Num (b, b), Integral b) => b -> Bool
23:39:59 <yaru1022> I don't understand why there is Num (b, b) in the context
23:40:11 <mmorrow> > let isPrime n = (not . or) (map (\x -> snd (n `divMod` x) == 0) [2 .. (floor . sqrt $ n)]) in isPrime 27
23:40:12 <lambdabot>  Add a type signature
23:40:22 <mmorrow> > let isPrime n = (not . or) (map (\x -> snd (n `divMod` x) == 0) [2 .. (floor . sqrt $ n)]) in isPrime (27::Integer)
23:40:23 <lambdabot>        add an instance declaration for
23:40:24 <lambdabot>       (RealFrac Integer, Floating Inte...
23:40:30 <mmorrow> .lkj;lkj;l;lk
23:40:33 <mmorrow> heh
23:40:37 <yaru1022> oh oh oh i c;
23:40:42 <yaru1022> i used divMod instead of mod
23:40:49 <mmorrow> yeah
23:41:00 <mmorrow> to sleep for me
23:43:14 <yaru1022> hm... but that still didn't work
23:43:40 <yaru1022> let isPrime n = not . or . map (\x -> n `mod` x == 0) [2 .. (floor . sqrt $ n)] in isPrime (31::Integer)
23:43:43 <yaru1022> > let isPrime n = not . or . map (\x -> n `mod` x == 0) [2 .. (floor . sqrt $ n)] in isPrime (31::Integer)
23:43:45 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
23:44:07 <yaru1022> > let isPrime n = (not . or) . map (\x -> n `mod` x == 0) [2 .. (floor . sqrt $ n)] in isPrime (31::Integer)
23:44:09 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
23:44:12 <mmorrow> you put the (.) back in
23:44:34 <yaru1022> oh ;
23:44:39 <yaru1022> > let isPrime n = (not . or) map (\x -> n `mod` x == 0) [2 .. (floor . sqrt $ n)] in isPrime (31::Integer)
23:44:40 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
23:44:47 <mmorrow> > let isPrime n = (not . or)      ( map (\x -> n `mod` x == 0) [2 .. (floor . sqrt $ n)]) in isPrime (31::Integer)
23:44:48 <lambdabot>        add an instance declaration for
23:44:48 <lambdabot>       (RealFrac Integer, Floating Inte...
23:44:57 <mmorrow> oh
23:45:07 <mmorrow> > let isPrime n = (not . or)      ( map (\x -> n `mod` x == 0) [2 .. (fromIntegral . floor . sqrt $ n)]) in isPrime (31::Integer)
23:45:09 <lambdabot>        add an instance declaration for
23:45:09 <lambdabot>       (Floating Integer, RealFrac Inte...
23:45:12 <mmorrow> oops
23:47:50 <mmorrow> ok
23:48:19 <tehgeekmeister> mmorrow: can't get alex to work at all yet
23:48:26 <mmorrow> > let isPrime n = not . or $ map ((==0) . (`mod`n)) [2 .. (floor . sqrt . fromIntegral) n] in zip [0..] (fmap isPrime [2..])
23:48:28 <lambdabot>  [(0,True),(1,True),(2,True),(3,True),(4,True),(5,True),(6,True),(7,True),(8,...
23:48:53 <mmorrow> tehgeekmeister: oh noes. what's the catch?
23:49:01 <tehgeekmeister> mmorrow: "lexical error"
23:49:51 <yaru1022> > let isPrime n = (not . or) $ map (\x -> n `mod` x == 0) [2 .. (floor . sqrt . fromIntegral $ n)] in isPrime 31
23:49:53 <lambdabot>  True
23:49:58 <yaru1022> ah... I missed fromIntegral
23:50:01 <yaru1022> :t fromIntegral
23:50:02 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:50:05 <cjs> What does the "default" keyword do?
23:50:12 <mmorrow> ahh, i hate that, the basic wrapper gives you no msg .. are you having the problem with lexing the interior of a tag that spans more than one line?
23:50:15 <Cale> cjs: Sets the default numeric types.
23:51:31 <mmorrow> > let isPrime n = not . or $ map ((==0) . (`div`n)) [2 .. (floor . sqrt . fromIntegral) n] in zip [0..] (fmap isPrime [2..])
23:51:33 <lambdabot>  [(0,True),(1,True),(2,False),(3,False),(4,False),(5,False),(6,False),(7,Fals...
23:51:45 <cjs> Ah.
23:51:52 <tehgeekmeister> mmorrow: i have a regexp that matches the interior of the "text" tag, but i'm not matching the rest
23:52:04 <tehgeekmeister> i think the problem is that my regexps are non-exhaustive
23:52:18 <Cale> cjs: Normally, when you write something like 5, that gets turned into fromIntegral (5 :: Integer) by the compiler. This can leave ambiguities when compiling the module, so if the type of something is ambiguously polymorphic in the end, and only involves numeric prelude typeclasses, it's defaulted according to the first thing in the default list which satisfies the constraints.
23:52:33 <tehgeekmeister> mmorrow: anyway, must go offline for a bit, talk to you later if you're still on
23:52:36 <mmorrow> hmm. it's so hard to tell with no info too.
23:52:41 <tehgeekmeister> it is
23:52:41 <mmorrow> ok, cool
23:52:43 <tehgeekmeister> really hard
23:52:48 <Cale> Normally the defaults are (Integer, Double)
23:52:50 <tehgeekmeister> bbl
23:52:53 <mmorrow> the posn wrapper may be worth it
23:52:59 <mmorrow> seeya
23:53:06 <cjs> Right. So nothing you'd ever use in production code, but handy for students and experimentation.
23:55:01 <Cale> Well, you can always avoid using it, but sometimes it's a handy way to say what the defaults should be. I suppose in production code, you might have lots of type signatures already and so that wouldn't be a problem.
23:55:25 <mmorrow> > let isPrime n = all (==False) $ map ((==0) . (n`div`)) [2 .. (floor . sqrt . fromIntegral) n] in take 10 (let x = [2..] in zip x (fmap isPrime x))
23:55:27 <lambdabot>  [(2,True),(3,True),(4,True),(5,True),(6,True),(7,True),(8,True),(9,True),(10...
23:55:34 <cjs> That's what Im thinking.
23:56:10 <mmorrow> let isPrime n = all (==False) $ map ((==0) . (`div`n)) [2 .. (floor . sqrt . fromIntegral) n] in fmap isPrime [0..]
23:56:19 <mmorrow> gah!
23:56:23 <mmorrow> > let isPrime n = all (==False) $ map ((==0) . (`div`n)) [2 .. (floor . sqrt . fromIntegral) n] in fmap isPrime [0..]
23:56:25 <lambdabot>  [True,True,True,True,False,False,False,False,False,False,False,False,False,F...
23:56:36 * mmorrow quits and sleeps
23:56:56 <cjs> What's the typical name, in Haskell, for a function like filter but (a -> Bool) -> [a] -> Maybe a?
23:57:05 <cjs> "find"?
23:57:16 <cjs> Yup.
23:57:23 <Cale> yeah
23:58:24 <yaru1022> > let isPrime n = (not . or) $ map (\x -> n `mod` x == 0) [2 .. (floor . sqrt . fromIntegral $ n)] in zip x (fmap isPrime x)
23:58:26 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
23:58:42 <yaru1022> > let isPrime n = (not . or) $ map (\x -> n `mod` x == 0) [2 .. (floor . sqrt . fromIntegral $ n)] in take 10 (let x = [2..] in zip x (fmap isPrime x))
23:58:44 <lambdabot>  [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,False),(9,False)...
23:59:03 <mmorrow> there
23:59:10 <yaru1022> =)
23:59:12 <yaru1022> thanks mmorrow
23:59:52 <mmorrow> :)
