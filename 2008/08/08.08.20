00:01:08 <mc__> I'd like to write a small text-mode tic tac toe in haskell, what data structure would you use for the board?
00:01:27 <subw> mc: an array?
00:02:16 <subw> see the hierarchical libraries or the haskell 98 report for more
00:02:37 <jsnx> mc__: i would use an enumeration
00:03:01 <mc__> jsnx: why?
00:03:22 <jsnx> teasing
00:03:34 <jsnx> there are 3^9 board states
00:04:20 <mc__> lol
00:04:34 <subw> sry for my stupid answer... For the board states some kind of (lazy) tree of course
00:05:42 <subw> since tic tac toe is so small you can generate all possible states
00:06:14 <subw> and each board state should have some kind of rating
00:06:38 <mc__> wtf?
00:06:55 <sjanssen> I'd probably use a Data.Map
00:07:09 <sjanssen> arrays are a hassle
00:08:21 <jsnx> http://hpaste.org/9802
00:08:29 <jsnx> kinda looks like a board
00:09:16 <sjanssen> data XO = X | O; data Position = One | Two | Three; type Board = Map (Position, Position) XO
00:09:39 <jsnx> oh yeah, the win state of the game could be encoded with the Square type
00:09:55 <jsnx> date Ownage = Ownage Square
00:10:01 <jsnx> Ownage N is a tie
00:10:28 <sjanssen> jsnx: bleh, that would probably be a hassle
00:12:05 <jsnx> if we make the player enter a capital X or O, we can use eval
00:12:49 <sjanssen> I bet the Data.Map solution is shorter and more readable :)
00:13:00 <jsnx> If we separate it into clients and servers, then we can have trusted tic-tac-toe
00:13:50 <jsnx> sjanssen: i guess i should try it
00:14:25 <tibbe> $! only forces to WHNF right? so return $! (..., ...) is pointless because a tuple is already on WHNF
00:14:46 <sjanssen> tibbe: correct
00:15:30 <tibbe> same with $! acons : alist then?
00:15:44 <tibbe> well I guess it depends on if acons is WHNF
00:15:48 <tibbe> and alist
00:16:25 <sjanssen> tibbe: that is also a no-op
00:16:34 <sjanssen> that parses as $! (acons : alist)
00:16:39 <sjanssen> and : is a constructor application
00:16:44 <tibbe> right
00:16:52 <tibbe> so I would to have to force acons separately
00:16:57 <sjanssen> yep
00:18:20 <Trinithis> What's the difference between a runtime code generator and code generator?
00:19:16 <jsnx> Trinithis: a code generator like template haskell is run at compilation time.
00:19:30 <jsnx> Trinithis: whereas harpy is run while the program is running.
00:20:11 <Trinithis> about harpy... I'm confused. Does it spit out machine code or does it execute gen'ed machine cod
00:22:13 <mmorrow> Trinithis: it produces machine code, which it then writes to a buffer and subsequently calls
00:22:34 <Trinithis> Can you have it not execute the code and instead write it to a file?
00:22:46 <mmorrow> with some hacking, sure
00:23:01 <mmorrow> here's a harpy fib
00:23:03 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/fib.html
00:23:28 <mmorrow> here's doing the same thing harpy does, but manually
00:23:31 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/Call.html
00:24:07 <mmorrow> Trinithis: the harpy disassembler is also nice
00:24:19 <opqdonut> wow
00:25:21 <Trinithis> Just to be sure, is Harpy an honest to god assember? It looked like in an example on someone's page showed some generated code that pushed a reg and then popped the same one without writing such asm code.
00:25:55 <Trinithis> when he disassembled it
00:26:18 <mmorrow> Trinithis: well, it has to take a description of asm and generate machine code. so being an assembler is the only way to do that :)
00:27:44 <Trinithis> I'll have to play with it tomorrow. But now, I'll probably kick the night.
00:29:17 <mmorrow> hold on one sec, i'm about to paste an example of using the disassembler
00:29:23 <Trinithis> k
00:31:44 <mmorrow> http://hpaste.org/9803
00:34:18 <mmorrow> so, just import Data.ByteString as B   {-then do-}   (disassembleList . B.unpack =<< B.readFile "/bin/cat")::IO [Instruction]
00:35:04 <Trinithis> ok
00:37:25 <mmorrow> heh, i just cat is loooooong
00:37:26 <mmorrow> ghci> :m + Harpy Harpy.X86Disassembler Data.ByteStringghci> Prelude.putStr . unlines . fmap showAtt . (\(Right a)->a) =<< disassembleList . Data.ByteString.unpack =<< Data.ByteString.readFile "/bin/cat"
00:37:56 <mmorrow> (that should be two lines obviously)
00:38:06 <Trinithis> yep
00:41:12 <chylli> I want to setup a lambdabot for jabber conference with bitlbee as gateway.
00:41:59 <chylli> but how to let labmdabot issue command 'join_chat 0 babelnova@conference.jabber.org' ?
00:43:07 <Trinithis> > maxBount :: Int
00:43:10 <lambdabot>  mueval: Expression did not compile.
00:43:10 <lambdabot> mueval: Time limit exceeded
00:44:40 <Trinithis> mmorrow: thx & night
00:44:46 <mmorrow> night
00:55:45 <trofi> > "how 'r 'u?"
00:55:46 <lambdabot>  "how 'r 'u?"
00:55:58 <trofi> > [1..]
00:56:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:56:34 <olsner> :t unsafeIOtoST
00:56:45 <trofi> > error ""
00:56:48 <lambdabot>  mueval: Expression did not compile.
00:56:48 <lambdabot> mueval: Time limit exceeded
00:57:02 <trofi> :\
00:57:17 <trofi> @hoogle error
00:57:18 <lambdabot> Prelude error :: String -> a
00:57:18 <lambdabot> Control.Exception ErrorCall :: String -> Exception
00:57:18 <lambdabot> Control.Exception errorCalls :: Exception -> Maybe String
00:57:40 <trofi> > P.error
00:57:43 <lambdabot>  mueval: Expression did not compile.
00:57:43 <lambdabot> mueval: Time limit exceeded
00:57:52 <trofi> > P.error ""
00:57:55 <lambdabot>  mueval: Expression did not compile.
00:57:55 <lambdabot> mueval: Time limit exceeded
00:57:58 <trofi> > Prelude.error ""
00:58:01 <lambdabot>  mueval: Expression did not compile.
00:58:01 <lambdabot> mueval: Time limit exceeded
00:59:13 <mmorrow> > error [] :: Int
00:59:16 <lambdabot>  mueval: Expression did not compile.
00:59:16 <lambdabot> mueval: Time limit exceeded
01:00:09 <TSC> @hoogle whnf
01:00:09 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
01:04:15 <MarcWeber> Is there a true type safe validating xml library yet?
01:06:51 <Wild_Cat> > map ($1) [succ, pred, succ]
01:06:52 <lambdabot>  [2,0,2]
01:07:01 <Wild_Cat> yay.
01:08:45 <TSC> Is this the right way to force something (in the IO monad) using Control.Parallel.Strategies?  "return $! (bigList `using` rnf)"
01:11:07 <sjanssen> TSC: that will work, but it is probably better to use Control.Exception.Evaluate
01:11:56 <TSC> sjanssen: Ah, perfect; thanks
01:12:11 <sjanssen> TSC: note that you still need to use rnf
01:12:33 <TSC> So it would be (evaluate (bigList `using` rnf)) ?
01:12:57 <sjanssen> right
01:13:16 <TSC> I'm still not sure of the difference between evaluate and return $!
01:14:11 <sjanssen> "evaluate x `seq` y    ==>  y
01:14:34 <sjanssen> TSC: (return $! _|_) `seq` y ==> _|_
01:15:04 <TSC> Mmm
01:15:43 <sjanssen> what evaluate does is turn the _|_ into a proper exception which is then thrown
01:16:15 <TSC> I see
01:16:22 <TSC> I think (:
01:22:45 <chylli> how to set lambdabot account's password ? what's the format of passwd.rc ?
01:24:50 <BeelsebobWork> is there a built in function that generates a *psudo* random number
01:25:04 <BeelsebobWork> i.e. a pure, non-monadic function :: Num a => a -> a
01:26:29 <trzkril> BeelsebobWork: in which way can such a function give a pseudo random number?
01:26:49 <osfameron> I thought the haskell random number functions took a seed and returned a random number
01:27:15 <Deewiant> ?ty fst . random . mkStdgen
01:27:16 <BeelsebobWork> it would give a number that adheres to the properties of random numbers i.e. even distribution etc, but wouldn't actually be random trzkril
01:27:16 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
01:27:19 <Deewiant> meh
01:27:25 <Wild_Cat> BeelsebobWork: by definition, a pure function's result only depends on its input. Thus, it can't give a random result.
01:27:26 <BeelsebobWork> osfameron: non-monadic
01:27:34 <BeelsebobWork> Wild_Cat: I didn't say random
01:27:38 <BeelsebobWork> I said psudo random
01:27:44 <Deewiant> fst . random . mkStdGen :: (Random a) => Int -> a
01:28:00 <BeelsebobWork> Deewiant: genious, thanks :)
01:28:07 <Wild_Cat> BeelsebobWork: Still. Any pure function, given the same input, will return the same output.
01:28:32 <Wild_Cat> BeelsebobWork: if you just want a function that given a number returns another number that doesn't look like it really is related, look for a hash function.
01:28:36 <Wild_Cat> MD5, SHA1...
01:29:39 <Wild_Cat> but cryptanalysts will laugh at you.
01:29:55 <BeelsebobWork> Wild_Cat: I don't need cryptanalysts to not laugh at me
01:30:07 <mc__> I'm trying to return something of the same type in bot paths of an if expression, but that results in a type error. I really do not have any Idea what I'm doing wrong. http://pastebin.com/m6b069978
01:31:10 <sjanssen> mc__: what is the error message?
01:31:20 <sjanssen> oh, I see it now, sorry
01:31:24 <mc__> np
01:31:57 <sjanssen> mc__: you forgot a do in line 20
01:32:34 <mc__> sjanssen: I have on in line 19, isn't that enough?
01:33:00 <sjanssen> mc__: I'm referring to line numbers in the paste
01:33:19 <sjanssen> mc__: there is no do in your else branch
01:33:36 <mc__> oh! silly me
01:33:37 <mmorrow> Wild_cat: why will cryptanalysts laugh at him?
01:33:53 <mc__> sjanssen: thank ya!
01:34:03 <BeelsebobWork_> mmorrow: it's irrelevant anyway, seeing as I'm doing nothing with cryptography
01:34:13 <BeelsebobWork_> or in fact anything that really needs truely random numbers
01:34:16 <BeelsebobWork_> only a nice even distribution
01:34:25 <Wild_Cat> mmorrow: because the output of a hash function is anything but random.
01:35:05 <Twey> mc__: Not the same type
01:35:14 <Wild_Cat> but then, if what BeelsebobWork_ is doing only requires the output to look vaguely random, it fits the bill.
01:35:25 <Twey> And do <single-value> is the same as <single-value>
01:35:27 <volk> how can I transform a list like [12, 15, 13,13, 2,5] into a list [27, 28, 5]? eg. I wanna return sums of consequent elements and keep these sums less than 30..
01:35:34 <Twey> Oh wait
01:35:40 <Twey> Looking at the wrong part.   Aye.
01:35:46 <BeelsebobWork_> volk: write a recursive function
01:36:13 <volk> hmm i'm thinking something in terms of map/filter
01:36:25 <mmorrow> Wild_Cat: well, a cryptographically secure hash function models what cryptographers would call a one way function
01:36:31 <trzkril> BeelsebobWork: id should match all your criteria
01:37:00 <Wild_Cat> mmorrow: sure. But it doesn't change the fact that if you know its input, you know its output (not the other way around, of course).
01:37:02 <BeelsebobWork_> trzkril: the function that Deewiant gave a while back is fine
01:37:12 <BeelsebobWork_> seed the random generator with the value I have
01:37:28 <ski> volk : why not `26',`15' or `20' in that output list ?
01:37:42 <mmorrow> Wild_Cat: exactly, the point of a one way function is for it be trivial to go one way, and very hard to go the other
01:38:07 <BeelsebobWork_> yeh, I'm not sure what you're getting at Wild_Cat
01:38:11 <volk> ski, the result is calculated as [12+15, 13+13+2, 5]
01:38:11 <Wild_Cat> volk: easy way to start: myFunc x:y:xs | x + y < 30 = myFunc (x+y):xs
01:38:26 <sjanssen> Wild_Cat: parse error
01:38:44 <Wild_Cat> BeelsebobWork_: I'm not sure either. Ask mmorrow :p
01:38:55 <ski> volk : oh, are you seeking a partition ?
01:39:29 <volk> ski, yes you could say that
01:39:53 <volk> actually I'm also seeking the most elegant solution ;)
01:41:14 <ski> volk : are you interested in some kind of optimum partition .. or just the greedy take as much as will fit in one munch, then start another ?
01:41:40 <volk> ski, yes, exactly
01:41:45 <ski> which ? :)
01:41:50 <volk> the greedy one =)
01:42:09 <ski> ok, i think you could make a simple solution using `unfoldr'
01:43:08 * volk is checking reference for list folding
01:43:33 <ski> an example :
01:45:15 <ski> > unfoldr (\n -> if n == 1 then Nothing else let m | even n = n `div` 2 | otherwise = 3*n+1 in Just (m,m)) 15
01:45:16 <lambdabot>  [46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
01:46:16 <ski> > unfoldr (\xs -> case xs of [] -> Nothing; x:xs -> Just (x*x,xs)) [0..9]  -- another
01:46:19 <lambdabot>  mueval: Expression did not compile.
01:46:19 <lambdabot> mueval: Time limit exceeded
01:47:03 <ski> > unfoldr (\xs -> case xs of [] -> Nothing; x:xs -> Just (x*x,xs)) [0..9]
01:47:04 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
01:47:11 <ski> @botsnack
01:47:11 <lambdabot> :)
01:47:21 <ziman> let grp = reverse . foldl (\(x:xs) n -> if n+x > 30 then n:x:xs else (n+x):xs) [0] in grp [12, 15, 13,13, 2,5]
01:47:29 <ziman> > let grp = reverse . foldl (\(x:xs) n -> if n+x > 30 then n:x:xs else (n+x):xs) [0] in grp [12, 15, 13,13, 2,5]
01:47:30 <lambdabot>  [27,28,5]
01:47:55 <ziman> seems to verbose to me :\
01:47:57 <ziman> *too
01:49:05 * ski ponders
01:54:56 <syntaxfree> I didn't think I was so rusty.
01:55:08 <syntaxfree> wtf is wrong with
01:55:10 <syntaxfree> data (String r, String b, String c) => Pixel r g b = Pixel r g b
01:55:10 <syntaxfree> data (Num a, Num b, Pixel c) => Screen a b c = Screen a b Pixel
01:55:21 <syntaxfree> (the error being in the second line)
01:55:35 <syntaxfree> Output.hs:3:33: Not in scope: type variable `c'
01:56:39 * BeelsebobWork_ ponders if the implementation of >>= for Gen is broken in ghc's quickcheck
01:56:57 <ski> have you defined `Pixel' to be a type class ?
01:57:08 <quicksilver> syntaxfree: the error is putting constraints on a data.
01:57:18 <quicksilver> syntaxfree: just don't do it. It doesn't do what you want and it doesn't work well.
01:57:56 <syntaxfree> well, I  first tried it without any constraints. Then with constrains only on a and b
01:58:02 <ski> (also `.. = Screen a b Pixel' doesn't make sense, since presumably `Pixel :: * -> * -> * -> *')
01:58:22 <syntaxfree> I now see how silly was putting a Pixel constraint when Pixel is not a typeclass
01:58:54 <mc__> How do I  "create" a Data.Map?
01:59:03 <quicksilver> for constraints on data to be useful they would have to (1) constraint constructor use (2) supply constraints on de-struction (3) automatically supply constraints to functions which use the data
01:59:10 <quicksilver> haskell98 does (1) but not 2 or 3
01:59:14 <quicksilver> so they're basically useless.
01:59:19 <syntaxfree> data  Screen a b c = Screen a b (Pixel c)
01:59:19 <syntaxfree> data  Screen a b c = Screen a b (Pixel c)
01:59:22 <syntaxfree> oops sorry
01:59:27 <syntaxfree> that doesn't work either.
01:59:31 <quicksilver> mc__: either empty + insert, or fromList
01:59:34 <Wild_Cat> :t Data.Map.empty
01:59:35 <syntaxfree> or
01:59:35 <lambdabot> forall k a. M.Map k a
01:59:41 <quicksilver> syntaxfree: well Pixel appears to take 3 type parameters
02:00:06 <quicksilver> data Screen a b red green blue = Screen a b (Pixel red green blue)
02:00:08 <quicksilver> perhaps?
02:00:14 <quicksilver> (alpha converting to avoid collision on 'b')
02:00:17 <mc__> quicksilver: thank ya
02:00:41 <syntaxfree> what if I actually need a list of pixels?
02:00:52 <ski> quicksilver : by `(3)' you mean type signatures using the type constructor would not have to explicitly state the constraints on the arguments ?
02:01:18 <quicksilver> ski: yes, that's what most people 'want' constraints on data to mean.
02:01:32 <quicksilver> ski: because of contravariance it's not clear the idea actually makes sense :)
02:01:43 <quicksilver> (would a contravariant position imply an existential constraint?)
02:02:11 <ski> (it seems side-effectful in some sense, yes)
02:02:20 <quicksilver> GHC + GADTs does something sane: it permits constraints on constructors, but not on types
02:02:26 <quicksilver> and it provides (1) and (2) but of course not (3)
02:02:33 <quicksilver> because the constraint doesn't attach to the whole type.
02:02:41 <quicksilver> despite being sane, I've never once found that useful...
02:04:31 <syntaxfree> I'm RUSTY, dude.
02:04:31 <mmorrow> correcting myself slightly, one way functions are the model for encryption algos, but what you want from a hash function is slightly different ... it should be hard to "reverse" (in quotes since info is lost during hashing), and given an input,ouput pair, very hard to contruct a diff input that hashes to the same val
02:04:40 * mmorrow feels better now
02:04:45 <mmorrow> hehe
02:05:34 <syntaxfree> or maybe I never was any good. But I did know my type constructors and typeclasses.
02:07:01 <quicksilver> syntaxfree: fortunately #haskell is here to set you right; you can expect at least two apparently contradicatory answers to even the most confusing question!
02:08:01 <syntaxfree> I did even have a Haskell blog.
02:08:11 <quicksilver> I remember.
02:08:31 <syntaxfree> well, as Gorillaz would say,
02:08:39 <syntaxfree> I'm useless, but not for long -- the future is coming on.
02:08:49 <syntaxfree> I'm taking this computational geometry class.
02:08:57 <quicksilver> typeclasses and constructors are a slight impedance mismatch
02:08:58 <syntaxfree> I'm out of academia for more than a year now.
02:09:12 <quicksilver> it feels like you ought to be able to do somethign sensible but it turns out not to work.
02:09:18 <syntaxfree> (And I was in an economics masters program)
02:09:26 <quicksilver> everyone *wants* to say: You can only construct Complex a for 'a' which is a Num.
02:09:38 <quicksilver> but it doesn't seem to work in haskell's system.
02:09:50 <syntaxfree> But I'm taking this masters-level computational geometry course at a good mathematics postgraduate program.
02:10:08 <syntaxfree> Just for kicks and giggles.
02:10:20 <syntaxfree> Also, for existential reasons. I love computers.
02:10:34 <quicksilver> I don't even know what computational geometry is. Despite having studied CS and math.
02:10:38 <ski> syntaxfree : not for universal reasons ?
02:11:12 <syntaxfree> The happiest moments at my (economist) job are when I have to program some exotic econometric estimator in Matlab.
02:11:25 <quicksilver> wikipedia has filled me in.
02:11:32 <quicksilver> it turns out I've done some computational geometry!
02:11:42 <quicksilver> I wrote an isosurface polygonisation algorithm.
02:12:18 <syntaxfree> @remember  <syntaxfree> Also, for existential reasons. I love computers. <ski>  syntaxfree : not for universal reasons ?
02:12:18 <lambdabot> Good to know.
02:12:34 <mmorrow> quicksilver: cool
02:12:59 <syntaxfree> quicksilver just the convex hull problem has immediate applications in econometrics. No one has noticed it, to my knowledge.
02:13:25 <syntaxfree> I like connecting apparently unrelated bodies of knowledge.
02:13:41 <quicksilver> mmorrow: it doesn't work in the the general case.
02:13:49 <syntaxfree> I envy Wadler, Meijer et al. for having connected cat theory to computer programming.
02:13:50 <quicksilver> mmorrow: it's quite pretty in the cases it does work :)
02:13:54 <mc__> I dont get why this results in a type error. http://pastebin.com/m593770f0  Haskells type system is confusing the hell out of me
02:14:05 <syntaxfree> (strangely enough, my cat theory be fresh)
02:14:17 <quicksilver> mc__: insert isn't a monadic action.
02:14:19 <syntaxfree> my name is MC Menses and my flow be fresh.
02:14:36 <quicksilver> mc__: recall that haskell data are not mutable.
02:14:43 <mmorrow> quicksilver: i love graphics because you always have something pretty at the end (other than the code/etc or course ;))
02:14:44 <quicksilver> mc__: insert returns a new map with the new element added.
02:15:00 <quicksilver> mmorrow: 100% agreed. Therefore all my recreational programming has a graphical element :)
02:15:11 <quicksilver> :t M.insert
02:15:12 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
02:15:51 <mc__> quicksilver: ah, yeah right, so the global board variable in my code does not really make sense
02:15:58 <quicksilver> mc__: Right.
02:16:01 <mmorrow> quicksilver: nice, it's on my list to start doing more of for sure
02:16:03 <quicksilver> mc__: global variables are teh evil.
02:16:18 <mc__> yeah, they are in every language ^^
02:16:37 <quicksilver> mc__: The simplest thing for you to do here would be create an IORef (Data.Map) in your 'main' action.
02:16:43 <quicksilver> mc__: pass that IORef to the mainLoop
02:16:56 <quicksilver> mc__: then the mainLoop reads the IORef, updates it, and writes it.
02:17:04 <mc__> IORef?
02:17:08 <quicksilver> mc__: I think there are better ways. But that is maybe the simplest.
02:17:11 <mc__> a mutable map?
02:17:12 * ski thinks the simplest thing would be to just pass the board around in an argument
02:17:20 <quicksilver> maybe ski is right.
02:17:21 <mc__> ski: I thought of that too
02:17:29 <quicksilver> maybe it's simpler to keep board as a recursive argument to mainLoop
02:17:50 <mc__> at least it would be more beautiful, wouldn't it?
02:18:12 <ski>   mainLoop :: Player -> IO ()  -- not `Int' .. `Player' !
02:18:28 <ski>   mainLoop = mainLoopOn emptyBoard
02:18:41 <ski>   mainLoopOn :: Board -> Player -> IO ()
02:18:53 <ski>   mainLoopOn board player = do ...
02:19:01 <ski> is what i'd try
02:19:23 <pozic> It's quite hard to decide in advance how to pass parameters to the different functions.
02:19:24 <mc__> thanks, I'll try that, but first I have to grab some lunch
02:20:07 <pozic> You can use Monads, IORefs, STRefs, tuples, normal arguments, special records for collections of functions and so on.
02:21:12 <pozic> I think the best way is to just start somewhere and when the application is somewhat stable, refactor.
02:21:47 <quicksilver> if you're learning then you'll want to try most of them once
02:21:55 <quicksilver> just to understand how they interact as solutions.
02:22:33 <pozic> The passing of tuples as in loops written with scanl is not really abstract. It seems an imperative while loop is more abstract, because it doesn't need to define the order in which the arguments are passed from one iteration to another.
02:23:19 <quicksilver> I consider that a fairly minor wart.
02:23:29 <quicksilver> If you name things you have to name them in some order.
02:23:39 <quicksilver> that's the nature of how we write things down.
02:23:55 <quicksilver> In the imperative case you don't name them, which is worse overall :)
02:24:25 <pozic> In Forth you don't name anything and they think it's good.
02:24:43 <osfameron> in pointsfree you don't name anything and think it's good
02:24:54 <Wild_Cat> Forth is barely a language, really.
02:25:14 <quicksilver> not naming at all can be good.
02:25:36 <quicksilver> in the imperative language the things have names; what I was trying to say is that you don't have to write down which ones are modified by the loop
02:25:43 <quicksilver> and you don't *know* which ones are modified by the loop
02:25:49 <quicksilver> in principle the loop can change everything.
02:26:09 <quicksilver> There is a benefit to understandind which variables the loop can change, which often requires you to naming them.
02:26:22 <quicksilver> it's not the names that are important, its the ability to see what can be changed and what cannot.
02:26:30 <pozic> I think naming for complicated things is great, however.
02:27:53 <Axman6> anyone know of any nice matrix libraries for haskell?
02:28:14 <ski> however, having to remember order of loop variables, and also having to reiterate unchanged loop variables, can be tedious
02:28:33 <quicksilver> Axman6: for serious work, the BLAS bindings are probably the choice
02:28:37 <Axman6> oh, hmatrix looks nice
02:28:46 <Axman6> which uses BLAS
02:35:27 <BeelsebobWork_> @seen malcolmw
02:35:27 <lambdabot> I haven't seen malcolmw.
02:35:37 <BeelsebobWork_> @seen mwallace
02:35:38 <lambdabot> I haven't seen mwallace.
02:35:43 <ski> @uptime
02:35:43 <lambdabot> uptime: 7h 33m 14s, longest uptime: 7h 33m 14s
02:35:47 <BeelsebobWork_> ah, lame
02:38:38 <quicksilver> preflex: seen malcolmw
02:38:39 <preflex>  malcolmw was last seen on #ghc 1 day, 19 hours, 59 minutes and 4 seconds ago, saying: so, I've rearranged the buildbot's PATH variable to have the same order as an interactive shell, and it appears to be happier now
02:43:22 <Axman6> bleh, can't get hmatrix to compile
02:46:37 <pozic> Axman6: let me guess: /usr/bin/ld: cannot find -lblas?
02:46:42 <Axman6> nope
02:47:09 <Axman6> "exit: ExitFailure 1"
02:47:17 <pozic> Axman6: ... look up
02:47:20 <pozic> Axman6: a few lines
02:47:49 <Axman6> "command was: /opt/local/bin/ghc -c -optc-O4 -package HUnit-1.2.0.0 -package QuickCheck-1.1.0.0 -package array-0.1.0.0 -package base-3.0.2.0 -package haskell98-1.0.1.0 -package storable-complex-0.1 dist/build/Numeric/GSL/Special/Internal_hsc_make.c -o dist/build/Numeric/GSL/Special/Internal_hsc_make.o"
02:48:46 <Axman6> no mention of blas at all (and OS X comes with a BLAS library installed by default, as part of the Accelerate framework)
02:49:22 <pozic> Axman6: I don't use OSX, but I can see whether it builds on Linux.
02:49:25 <trofi> does `remember me' tick works for you on hpaste.org ?
02:49:32 <quicksilver> trofi: not in safari, no.
02:49:38 <quicksilver> I think it worked in firefox the last time I used firefox.
02:50:07 <Axman6> that's not a feature that would make me use firefox over Safari
02:50:21 <trofi> in my ff3 it does not
02:50:26 <pozic> Axman6:  cannot find -llapack
02:50:34 <pozic> Axman6: that's what I get with your exact error message
02:50:59 <Axman6> no mention of lapack either
02:51:31 <Axman6> ah, maybe "error: gsl/gsl_sf_result.h No such file or directory:"
02:52:24 <Saizan> trofi: it was disabled at some point and never restored
02:52:54 <pozic> Axman6: does it compile anything?
02:53:22 <Axman6> i think so. i don't have gsl installed, so doing that now
02:53:31 <pozic> Axman6: since, it does here.
02:55:17 <syntaxfree> no, really, isn't there a function to convert from a hex-containing string to an Int?
02:55:40 <pozic> syntaxfree: readHex if it exists.
02:55:41 <syntaxfree> oops, 0xAB is a proper Int.
02:55:43 <syntaxfree> neverminds.
02:55:53 <pozic> There is readOct, IIRC.
02:56:07 <pozic> :t readHex
02:56:08 <lambdabot> forall a. (Num a) => String -> [(a, String)]
02:56:17 <trofi> @hoogle String -> Int
02:56:17 <lambdabot> Prelude read :: Read a => String -> a
02:56:17 <lambdabot> Text.Read read :: Read a => String -> a
02:56:17 <lambdabot> Data.String fromString :: IsString a => String -> a
02:56:34 <pozic> > readHex "0x1"
02:56:37 <lambdabot>  mueval: Expression did not compile.
02:56:37 <lambdabot> mueval: Time limit exceeded
02:56:56 <syntaxfree> readHex is in Numeric.
02:57:07 <pozic> o.O
02:57:09 <trofi> > read "[1,2,3]" :: [Int]
02:57:10 <lambdabot>  [1,2,3]
02:57:19 <syntaxfree> I think I'm better off with (read . ("0x"++))
02:57:20 <pozic> syntaxfree: yes, I know that.
02:57:25 <trofi> @hoogle readHex
02:57:25 <lambdabot> Numeric readHex :: Num a => ReadS a
02:57:26 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
02:57:44 <trofi> > Numeric.readHex "0x123" :: Int
02:57:45 <syntaxfree> > (read . ("0x"++)) "ABC"
02:57:47 <lambdabot>  mueval: Expression did not compile.
02:57:47 <lambdabot> mueval: Time limit exceeded
02:57:48 <lambdabot>  mueval: Expression did not compile.
02:57:48 <lambdabot> mueval: Time limit exceeded
02:57:54 <trofi> > Numeric.readHex "0x123"
02:57:57 <lambdabot>  mueval: Expression did not compile.
02:57:57 <lambdabot> mueval: Time limit exceeded
02:58:00 <pozic> Axman6: hmatrix works here.
02:58:21 <trofi> `mueval: Time limit exceeded' annoys a little
02:58:21 <Axman6> should work after i install gsl
02:59:43 <Axman6>  last [1..]
02:59:47 <Axman6> > last [1..]
02:59:47 <trofi> >
02:59:49 <lambdabot>  mueval: Time limit exceeded
02:59:57 <Axman6> yeah, i hit it, but it didn't type...
03:01:22 <Twey> dons: You're everywhere.
03:10:48 <Axman6> urgh "Loading package hmatrix-0.4.0.0 ... can't load .so/.DLL for: gsl (dlopen(libgsl.dylib, 10): image not found)"
03:11:07 <Axman6> in ghci, when running 'Numeric.LinearAlgebra.Tests.runTests 20'
03:12:06 <Saizan> does it work when compiled?
03:12:33 <Axman6> well it's compiled now, and installed
03:13:01 <Axman6> so it found libgsl initially
03:15:01 <pozic> Axman6: Cases: 13  Tried: 13  Errors: 0  Failures: 0
03:15:19 <pozic> Axman6: it works here, Mac might be somewhat worse supported.
03:15:50 <Axman6> well it found the gsl library after i installed it, so hmatrix compiled fine, but not ghci can't find it
03:16:08 <pozic> Axman6: did you restart ghci?
03:16:13 <Axman6> yes
03:17:08 <pozic> Axman6: ok, then I don't know, so you either need to find another Mac user or contact the author.
03:17:22 * Axman6 pokes quicksilver 
03:17:31 * Axman6 pokes BeelsebobWork 
03:18:23 * BeelsebobWork pokes Axman6 
03:18:43 <Axman6> BeelsebobWork: reckon you could explain "Loading package hmatrix-0.4.0.0 ... can't load .so/.DLL for: gsl (dlopen(libgsl.dylib, 10): image not found)"
03:18:56 <BeelsebobWork> well, does libgsl.dylib exist?
03:19:01 <Axman6> gsl is installed, and was necessary to compile hmatrix
03:19:15 <BeelsebobWork> and it's still on your libpath?
03:19:18 <Axman6> good question actually, not not be a .dylib
03:19:30 <BeelsebobWork> try adding a -l to point at the appropriate place
03:19:59 <trofi> ,dylib - is common MacOS shared lib extension?
03:20:08 <Axman6> "/opt/local/lib/libgsl.dylib"
03:20:11 <Axman6> trofi: yes
03:20:32 <trofi> linker is gnu ld?
03:20:38 <Axman6> yes
03:20:50 <trofi> i think /etc/ld.so.conf shoud contain /opt/local/lib/
03:21:18 <Axman6> it's never had a problem using /opt/local/lib before that i can remember
03:21:30 <quicksilver> linker is not GNU ld
03:21:34 <quicksilver> OSX does not use GNU ld
03:21:40 <trofi> was ldcache updated?
03:21:57 <trofi> ghc does not use GNU ld?
03:21:59 <quicksilver> OSX uses ld "Apple Computer, Inc. version cctools-622.5.obj~13"
03:22:49 <Axman6> "@(#)PROGRAM:ld  PROJECT:ld64-84.3" for me, heh
03:24:53 <Twey> What exactly does a TChan do that a Chan doesn't?
03:25:47 <quicksilver> Twey: consistency checks and rollbacks.
03:25:53 <quicksilver> Twey: just like TVar resp. MVar
03:25:55 <Twey> Ah, OK.
03:25:58 <Twey> Thanks :)
03:42:08 <Axman6> yay, got it working
03:42:17 <Axman6> and segfault...
03:45:54 <Axman6> well, this is fun. i love segfaults
03:46:56 <Saizan> gwern: would it be hard to get compiler errors out of mueval? e.g. instead of mueval: Expression did not type check.
04:00:29 <ruddel> lo
04:00:45 <trofi> there is cabal `build-type:         Configure'. when two versions of cabal are installed:
04:00:48 <trofi> package ghc-6.8.3 requires Cabal-1.2.4.0
04:00:50 <trofi> package plugins-1.2 requires Cabal-1.4.0.1
04:01:13 <trofi> how to look at actual -package parameters?
04:03:00 <trofi> oh, found cabal build _-v_
04:12:03 <eu-prleu-peupeu> hello people from planet haskell
04:13:50 <Twey> Is it possible to convert a PortNumber to an Int?
04:14:54 <trofi> @hoogle PortNumber
04:14:54 <lambdabot> No results found
04:14:56 <Igloo> fromIntegral
04:15:06 <Twey> Oh, thanks
04:18:50 <quicksilver> Twey: you know not to use the constructor explicitly, I hope.
04:18:56 <quicksilver> Twey: (it's a bug that it is exported)
04:23:14 <Vq^> my hmatrix installation has lost all it's Show instances, how curious
04:25:10 <quicksilver> maybe they are in another module you're not importing at the moment.
04:25:18 <mc__> Is it normal for a beginner to be in constant-type-error-mode? o_O
04:26:23 <Vq^> mc__: quite normal
04:26:34 <Saizan> mc__: a bit, if you understand the type errors is good :)
04:26:50 <Vq^> quicksilver: i thought so too, so i imported almost everything :/
04:27:22 <mc__> it takes time for me to understand them, and they make my brain hurt ^^
04:28:10 <mmorrow> @pl  \a b c -> g (f a b c)
04:28:10 <lambdabot> ((g .) .) . f
04:28:32 <Vq^> Show for Vector t and Matrix t require that t implements Show, Floating and Storable, maybe the hmatrix package can't see one of them?
04:30:08 <quicksilver> Vq^: :i on the type will tell you
04:30:16 <quicksilver> (whether it implemenst Show, Floating and Storable)
04:31:17 <Twey> Hmn, any recommendations for a good State/StateT tutorial?
04:32:32 <Peaker> I think reading ghc's errors would be a lot easier without the curried function call style.. If functions used uncurried form (tuples) it would make a lot of things much uglier (disallowing direct currying) but would make error messages much simpler to understand, like in other languages
04:32:48 <quicksilver> true.
04:33:01 <quicksilver> The error message for missing out an argument is obscure.
04:33:02 <Peaker> I am not convinced that the currying style is a better point in the tradeoff..
04:33:49 <osfameron> alternatively, the curreied function could remember what its original function was
04:33:52 <Peaker> enough things in Haskell are mind warping, that I am not sure its a good idea to make every function call a little struggle too :)
04:34:08 * Twey looks at Peaker in horror and disbelief.
04:34:11 <osfameron> though that could be more confusing in other contexts
04:34:12 <quicksilver> try to write haskell with every function uncurried for a large program.
04:34:22 * Twey nods at quicksilver.
04:34:23 <quicksilver> it will be a complete train wreck.
04:34:45 <osfameron> well, more to the point it'd be another language
04:35:05 <osfameron> but I'm all up for the error messages being improved
04:35:23 <zachk> i like the error messages. they make me think
04:35:30 * Twey laughs.
04:35:33 <Twey> 'Like little koans'
04:35:34 <dzlk> I was about to say that.
04:35:47 <osfameron> they make me cry :-)
04:35:48 <Peaker> thinking wears you down mentally much faster.  There's a limited amount of hours of thinking you can do every day
04:36:04 <Peaker> and I'd rather waste my thinking on interesting problems to solve :)
04:36:06 <zachk> well then stop writing errors and you wont get worn down so fast
04:36:18 <Twey> Peaker: Yes, but if we'd rather write ugly code and think less we'd be using Visual Basic :-P
04:36:36 <Peaker> Twey: I don't think uncurried is so horrible
04:36:49 <Peaker> Twey: everyone else uses it, and nobody considers it a problem
04:36:58 * Twey does
04:37:02 <Twey> (frequently)
04:37:08 <Twey> It's one of the things I miss most in other languages
04:37:23 <Peaker> In Python, for example, I just use partial for currying
04:37:36 * osfameron wrote Sub::Curried so he could use it in Perl
04:37:51 <Vq^> hmm, the instance was hiding in Numeric.LinearAlgebra.Instances
04:37:56 <Twey> Sure, but explicit currying gets ugly very fast if you're doing a serious function composition
04:38:15 <Twey> Recent JS I wrote: return F.filter(F.compose(O.equals, F.flip(F.curry(O.lookup, 2)(a2))), a1);
04:39:22 <osfameron> JS has builtin currying?
04:39:30 <osfameron> or which toolkit is this?
04:39:32 <chr1s> osfameron: no.
04:39:34 <Twey> No
04:39:38 <Twey> My own
04:39:43 <osfameron> aha
04:39:48 <Twey> But it's provided in Functional
04:39:48 <osfameron> yeah, the explicitness is annoying
04:39:56 <Twey> http://osteele.com/sources/javascript/functional/
04:40:01 <lambdabot> Title: Functional Javascript
04:40:04 <osfameron> that's why Sub::Curried infers the currying from type-signature
04:40:18 <osfameron> (there are a handful of other perl modules to do it, but they are more verbose)
04:41:39 <osfameron> Twey: eeek!  string eval!
04:41:56 <Twey> osfameron: 'tisn't, it's parsed, I checked
04:42:30 <osfameron> Twey: parsed at runtime into the equivalent lambda?
04:42:35 <Twey> Aye
04:42:52 <Twey> It's not lovely, but it's not hideous
04:43:09 <osfameron> well it's certainly less noisy than function () { } noise
04:43:12 <Twey> Aye
04:43:26 <osfameron> but a bit yucky nonetheless
04:43:30 * Twey nods.
04:43:33 <Twey> There's a short form in the new JS version from Mozilla
04:43:47 <osfameron> perl++ # you can add a lot of functional goodness with nice syntax with parser hacks like Devel::Declare
04:43:51 <Twey> function(x) { return x * x; } becomes function(x) x*x
04:44:10 <osfameron> ooo!
04:44:13 <Twey> Yyyeeah... but... they're parser hacks :)
04:44:32 <osfameron> well, they're fairly robust parser hacks :-)
04:44:35 <chr1s> Twey: that's a pretty cool library!
04:44:44 * Twey doesn't like having to hack his parser to do stuff
04:44:51 <Twey> chr1s: It's pretty nice, aye
04:44:55 <osfameron> the old Perl stuff used global source filters, which was horrid.  Now they're much more localised
04:44:57 <Twey> I don't agree with everything it does though
04:45:26 <Twey> Particularly, extending a bunch of types to add toFunction() or whatever it's called
04:56:13 <mg5000> howto use that ? or is there an error :
04:56:14 <mg5000> instance (Ord a , Ord b) => Ord (a,b) where    (<=) a b = (a,b)    (<) a b = (a,b    (>=) a b = (b,a)    (>) a  b = (b,a)
04:57:06 <opqdonut> the comparison functions should return Ordering, not a tuple
04:57:10 <opqdonut> :t (<)
04:57:11 <lambdabot> forall a. (Ord a) => a -> a -> Bool
04:57:18 <opqdonut> gah, I mean a BOOLEAN
04:57:31 <mc__>     No instance for (Show (m Player)) <- what data type is this? Playe is simply a synonym for Int in this case. The code raising the error is "show(Data.Map.lookup (x,y) board)"
04:58:06 <opqdonut> mg5000: so you want something like "(a,b) <= (c,d) = a<c || a==c && b<d"
04:58:11 <opqdonut> depending on the wanted semantics
04:59:44 <TSC> @type Data.Map.lookup
04:59:45 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
04:59:59 <TSC> mc__: lookup returns "m a" for some Monad m
05:00:12 <TSC> And show can't figure out how to show such a value
05:00:18 <quicksilver> force it to be Maybe
05:00:20 <TSC> Maybe you want to force it to be "Maybe a" ?
05:00:34 <quicksilver> show (Data.Map.lookup (x,y) board :: Maybe Piece)
05:00:42 <quicksilver> or whatever type your board is, instead of Piece
05:01:33 <mc__> ah, okay, why does the value have to be in a monad?
05:02:15 <TSC> It's in a monad to handle the case where the key is not present
05:02:15 <quicksilver> that's just the way lookup is written.
05:02:18 <opqdonut> because we want to express failure
05:02:22 <quicksilver> It was a terrible design decision.
05:02:27 <opqdonut> yes
05:02:28 <quicksilver> Maybe a would have been a better type.
05:02:32 <quicksilver> but everyone makes mistakes.
05:03:18 <Twey> But thanks to that it can be a list, no?
05:05:16 <Saizan> not in the sense that it can give multiple results (Map is not MultiMap)
05:05:33 <Twey> Oh
05:05:34 <opqdonut> yeah
05:05:36 <Twey> That's not very useful, then
05:05:46 <opqdonut> it's just the same as saying "maybeToList . lookup"
05:07:43 <yitz> or more generally, maybe mzero return . lookup
05:09:24 <yakov> hey
05:09:34 <Twey> Hullo
05:11:12 <Armored_Azrael1> Is there any reasonable way to "catch" the error raised by read?
05:11:32 <opqdonut> use readS?
05:11:35 <opqdonut> :t readS
05:11:40 <Saizan> Armored_Azrael1: only in IO, with Control.Concurrent.catch
05:11:52 <Saizan> :t reads -- but this is more usaful
05:11:53 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:12:26 <quicksilver> Armored_Azrael1: no, don't use it.
05:12:45 <quicksilver> Saizan: catch and some ugly forcing, that would be.
05:13:14 <Saizan> quicksilver: right
05:13:21 <Armored_Azrael1> OK
05:13:33 <Armored_Azrael1> So, does reads map from the string, onto the set of all possible parses?
05:13:36 <Vq^> Armored_Azrael1: you're probably better off looking at real parsing instead
05:13:52 <Armored_Azrael1> Vq^: But it's very simple--I'm just reading a number from the command line
05:13:53 <quicksilver> Armored_Azrael1: yes.
05:14:29 <Armored_Azrael1> Vq^: I use real parsers elsewhere in this program, for parsing a description language in a file, but a real parser here is basically overkill
05:14:30 <Saizan> > reads "123foo"
05:14:31 <lambdabot>  []
05:14:34 <quicksilver> case reads n of -> [(i,spcs)] | all isSpace spcs -> i; _ -> it didn't work.
05:14:44 <Saizan> > reads "123foo" :: [(Int,String)]
05:14:45 <lambdabot>  [(123,"foo")]
05:14:50 <quicksilver> is the correct generalisation to catch parse errors
05:14:53 <quicksilver> and match read
05:19:00 <Armored_Azrael1> Awesome, it works now
05:19:03 <Twey> :t evalState
05:19:03 <lambdabot> forall s a. State s a -> s -> a
05:19:53 <Saizan> ?where hint
05:19:53 <lambdabot> I know nothing about hint.
05:20:16 <Direktori> ?where brain
05:20:16 <lambdabot> I know nothing about brain.
05:20:41 <Direktori> ?where nothing
05:20:41 <lambdabot> I know nothing about nothing.
05:20:49 <Direktori> филосифия ^.^
05:20:53 <gwern> can't argue with that
05:21:17 <Saizan> gwern: do you know if there's a repo for hint?
05:21:26 <gwern> Saizan: yes
05:21:33 <Saizan> link?
05:22:00 <Saizan> i'm trying to write a prettyprinter for InterpreterError, but the documentation is lacking
05:22:20 <gwern> Saizan: http://www.glyc.dc.uba.ar/daniel/repos/hint
05:22:23 <gwern> yeah, the docs could be a little better
05:22:31 <lambdabot> Title: Index of /daniel/repos/hint
05:22:41 <gwern> I ran into issues with the loadModule/setScope thing - I naively assuemd that loading a module would set it into scope
05:22:51 <gwern>  also: having to manually parse a filename to get the module == teh suck
05:23:20 <Saizan> heh
05:23:57 <Saizan> do you think the prettyprinter should go in mueval or directly in hint? we need type errors for lambdabot :)
05:24:24 <gwern> hint, I'd say
05:25:01 <gwern> I'm looking at the haddocks, and looks like a prettyprinter should probably go in as a modification of the show isntance
05:25:35 <gwern> this would hopefully help out with mueval, since:
05:25:36 <gwern> printInterpreterError :: InterpreterError -> IO ()
05:25:39 <gwern> printInterpreterError = error . take 1024 . ("Oops... " ++) . show
05:27:14 <Saizan> btw, using error like that in mueval gives a race condition on printing errors vs. terminating, but i've the patch for that
05:28:29 <gwern> not surprising. mueval is one giant race condition between the evaluation thread and the watchdog thread :)
05:31:39 <Peaker> gwern: isn't it more efficient to use shows when composing it, instead of using ++ ?
05:32:20 <gwern> Peaker: well, leaving aside the fact that when output is a maximum of 1024 chars long any optimization is tiny - what do you mean?
05:32:41 <Peaker> gwern: I thought avoiding ++ on show results is why shows was devised
05:32:51 <Saizan> Peaker: that's valid for appending, not preprending
05:32:52 <gwern> @hoogle shows
05:32:53 <lambdabot> Prelude shows :: Show a => a -> ShowS
05:32:53 <lambdabot> Text.Show shows :: Show a => a -> ShowS
05:32:53 <lambdabot> Prelude type ShowS = String -> String
05:33:04 <gwern> ?
05:33:22 <Peaker> @type showString
05:33:23 <lambdabot> String -> String -> String
05:33:32 * gwern is pleased to note that @hoogle is working again
05:33:52 <Peaker> Saizan: well, the literal above is a short string - so it doesn't matter you mean?  If it was long, it would make sense to use showString
05:34:24 <Saizan> showString foo . bar = (foo ++) . bar
05:34:30 <Saizan> ?src showString
05:34:30 <lambdabot> Source not found. Sorry.
05:35:45 <Saizan> the point of ShowS is to have the first (++) as the outermost one
05:36:12 <Saizan> foo ++ ( bar ++ baz) is more efficient than (foo ++ bar) ++ baz
05:37:58 <Peaker> Saizan: oh, thanks
05:38:21 <gwern> sounds like a job for rewrite rules...
05:38:27 <Saizan> so isntead of (foo ++ bar) you pass around (foo ++) . (bar ++), so when you append baz you get ((foo ++) . (bar ++) . (baz ++) "") = foo ++ (bar ++ (baz ++ ""))
05:39:00 <gwern> hm. rule = 'f ++ b ++ c = f ++ (b ++ c)'?
05:39:18 <Peaker> well, ++ can be right-associative?
05:39:25 <Peaker> @info (++)
05:39:25 <lambdabot> (++)
05:39:31 <Peaker> interesting
05:40:31 <Saizan> (++) is right associative, but you don't in general construct these strings in a single expression
05:40:32 <Peaker> can (a ++ b) ++ c be rewritten to a ++ (b ++ c) ?
05:40:53 <gwern> I don't see why not
05:41:03 <Peaker> will a rewrite rule only apply when the expression is wholly visible in compile-time, or when it is only known in run time as well?
05:41:19 <gwern> > "foo" ++ ("bar" ++ "baz") == ("foo" ++ "bar") ++ "baz"
05:41:20 <lambdabot>  True
05:41:25 <Saizan> Peaker: compile time
05:41:26 <gwern> Peaker: compile-time only
05:41:45 <gwern> @check \f b c -> f ++ b ++ c == f ++ (b ++ c)
05:41:46 <lambdabot>  "OK, passed 500 tests.\n"
05:41:59 <Saizan> Peaker: inlining helps a lot for rewrite rules, in fact
05:42:03 <mnislaih> @seen CosmicRay
05:42:03 <lambdabot> I haven't seen CosmicRay.
05:42:07 <Peaker> e.g:  so it will work when:  f x = x ++ a ;  f ("a" ++ "c")  -- but not for:
05:42:40 <Peaker> f x = if null x then x ++ a else "" ; f ("a" ++ "c")
05:44:27 <gwern> yeah. I wonder whether a redefinition of ++ might be better instead of a rw rule
05:44:31 <mnislaih> My ghc-6.8.2 -threaded multi-threaded program using HDBC and curl is seeing a lot of segmentation faults. Does this ring a bell to anyone ? No unsafe features are used
05:44:40 <Saizan> Peaker: yeah, or more importantly in recursive functions or the like
05:44:51 <ddarius> There is no better definition of (++)
05:45:03 <mnislaih> (If I remove the -threaded, everything is fine)
05:45:25 <gwern> mnislaih: curl as in the haskell library or a ffi?
05:45:36 <mnislaih> gwern: the one in hackage
05:46:27 <mnislaih> gwern: I only use curlGetString, so that should be thread-safe
05:46:29 <mnislaih> http://hackage.haskell.org/packages/archive/curl/1.3.2.1/doc/html/Network-Curl.html#v%3AcurlGetString
05:46:31 <lambdabot> Title: Network.Curl, http://tinyurl.com/5l3jv7
05:46:56 <mnislaih> and I serialize the access to a single HDBC connection for all threads.
05:47:06 <gwern> mm. I would set curlGetString to a dummy function like undefined
05:47:08 <gwern> and see what happens
05:47:13 <gwern> alternatively, profile it
05:47:35 <gwern> there's one profiling mode intended for segfaults and crashes, iirc
05:48:47 <mnislaih> gwern: I don't know that profiling mode. Are you talking about ticky-ticky ?
05:51:25 <gwern> maybe
05:56:52 <gwern> @seen mmorrow
05:56:52 <lambdabot> mmorrow is in #ghc, #darcs and #haskell. I last heard mmorrow speak 1h 28m 42s ago.
05:58:19 <gwern> @tell mmorrow so, what do you think I should do about the Resource breakage? is this something fixable just by waiting for fedora to upgrade something? or should I look into a more involved solution like a cabal flag setting a cpp directive to cut the rlimits out?
05:58:19 <lambdabot> Consider it noted.
05:59:27 <Saizan> gwern: have you had any problems with setResourceLimit? i get setResourceLimit: invalid argument (Invalid argument) consistently
05:59:52 <Saizan> oh, is this the same issue?
06:00:15 <gwern> Saizan: I haven't, but people consistently report that some limits simply can't be set with any value
06:00:39 <gwern> it's frustrating, because in some cases they're apparently even using the same version of ubuntu as me!
06:01:26 <Saizan> heh, i'm using hardy
06:01:55 <gwern> as am I...
06:03:35 <sw17ch> i have, what i think is, a silly question...
06:03:43 <sw17ch> data a = Foo a
06:04:03 <sw17ch> is there a way to constrain a not only by type, but also by value?
06:05:17 <Saizan> can you elaborate?
06:05:31 <sw17ch> Saizan, yes :)
06:05:38 <sw17ch> i have an audio stream
06:05:54 <sw17ch> it's setup with afew parameters like # of channels and sample rate (along with data format)
06:06:55 <sw17ch> i was hoping for a way (wtihout having to explicitely newtype each one) constrict my data declaraction by # of channels and sample rate along with the format
06:07:54 <Saizan> so the available ranges for # of channels depend on the format chosen?
06:07:55 <sw17ch> right now, i have data Stream a = Stream Ptr ()
06:08:17 <sw17ch> the range of available channels depends on how the channel creation function is called
06:08:25 <sw17ch> stream*
06:08:42 <sw17ch> openStream 2 8000.0 int8
06:09:11 <Saizan> ah, so you want e.g. the number of channels to appear in the type?
06:09:17 <sw17ch> yeah
06:09:29 <sw17ch> i could do data OneChannel, data TwoChannel... etc
06:09:50 <sw17ch> i suppose i could just match on the channel parameter
06:10:42 <Saizan> you don't need the channel parameter anymore then
06:10:57 <sw17ch> yeah...
06:11:08 <sw17ch> data Stream a = Stream Ptr Channels
06:11:19 <Saizan> no
06:12:28 <Saizan> i mean openStream :: IsNum a => Params -> Stream numberofchannels, then in openStream you can get the number of channels by "reifying" the type parameter
06:12:51 <Saizan> but i'm not sure how familiar you are with such type hackery?
06:13:19 <Saizan> there are some libraries for typelevel integers on hackage
06:13:33 <sw17ch> hmmm
06:14:22 <sw17ch> am i to assume that "a" shows up some where in Params?
06:15:39 <Saizan> sw17ch: sorry, s/a/numberofchannels/
06:16:08 <sw17ch> so does that class constraint actually effect anything passed to openStream then?
06:16:17 <sw17ch> 'im assuming you glossed over a parameter
06:16:28 <Saizan> no, it affects the return parameter, and that's enough
06:16:40 <sw17ch> ohhh
06:16:42 <sw17ch> never mind
06:16:44 <sw17ch> i see it now
06:16:47 <sw17ch> the line break screwed me up
06:16:51 <Saizan> the number of channels will be determined by the return the type openStream is used
06:17:41 <gwern> Saizan: btw, I think it'd be worthwhile for you to investigate whether the rlimits can be used from haskell at all, and file appropriate ghc bugs
06:19:29 <Saizan> my last sentence is not readable, i mean that like read :: Read a => String -> a gives different results depending on which 'a' the caller chooses, then so can do openStream
06:19:46 <sw17ch> Saizan, oh yes, i know all that stuff
06:20:19 <sw17ch> i still think in my case i'll be better off having functions that need to deal with a specific number of channels match directly on the parameter to the Stream
06:22:14 <Saizan> that's simpler but you don't have compile-time guarantees about the number of channels of a stream (i'm not sure if you need them either)
06:25:14 <sw17ch> Saizan, i think i will add number of channels and sample rate to the Stream's data type, but i probably won't add any provisions for the types
06:25:53 <sw17ch> considering i think the only good way to do it woudl be to tag the Stream type with a Channel type
06:26:02 <sw17ch> and i'm under the impression i'd need 128 different channel types
06:28:51 <jacobian> what's a convenient way of generating all lists of natural numbers in a "fair" way without duplication?
06:29:46 <mjrosenb> jacobian: what do you mean by all lists of natural numbers?
06:29:54 <MarcWeber> Is someone familiar with reading DTD's using HaXml? It does'nt seem to take paths as relative references to the original file
06:30:25 <mjrosenb> is anyone familiar with using ghci's built in debugger?
06:30:41 <mjrosenb> it's output seems to be over my head.
06:31:00 <MarcWeber> jacobian:  all lists ? thus one subset beeing map ([i..]) [1..] ?
06:31:01 <jacobian> mjrosenb: I mean how does one generate an infinite stream of finite lists such that any finite list of numbers is eventually found.
06:31:37 <mjrosenb> jacobian: i assume you mean any finite list of finite numbers :-p
06:31:48 <Saizan> sw17ch: well, you can define them inductively, actually there are some libraries that let you write integers like D1 (D2 (D0 End)) == 120, just to let you know, they are not things you see in everyday code
06:31:49 <jacobian> yes, excluding   inf = S inf
06:32:18 <mjrosenb> so the way i did this in the past
06:32:28 <jacobian> I have a solution but it has repetition
06:32:29 <mjrosenb> was i had 2 parameters
06:32:44 <mjrosenb> length of the list, and maximum element
06:32:47 <sw17ch> Saizan, yes, i've seen those.. it may still be worth looking in to :)
06:32:51 <sampointon> jacobian: apply factorise over the naturals, then map the prime factors back to the naturals?
06:33:00 <sw17ch> (but i doubt it adds to the ease-of-use that i'm hoping for)
06:33:22 <mjrosenb> sampointon: that's a pretty neat idea
06:33:30 <sampointon> so, eg, 12 => 2,2,3 => 1,1,2
06:33:41 <mjrosenb> sampointon: wasn't that used in minsky machines, or something similar?
06:34:02 <jacobian> wow, thats a neat idea
06:34:13 <sampointon> mjrosenb: I don't know, I thought of it because I've done some stuff with cardinality related to that lately
06:34:21 <mjrosenb> slow as **** but, it'll work
06:34:36 <jacobian> Yeah, I was hoping for something with very little structure
06:35:14 <mjrosenb> alternitively
06:35:30 <mjrosenb> generate every finite list of booleans
06:35:55 <mjrosenb> and treat each [Bool] as a list of fibonacci encoded numbers
06:36:20 <hackage> Uploaded to hackage: chalmers-lava2000 1.0
06:38:18 <jacobian> I guess I was hoping for something where I could use streams in alternation in some way.  Something like
06:38:30 <jacobian> nat = 0:(map (1+) nat)
06:38:38 <gwern> yay, someone did lava for me
06:38:47 * gwern crosses it off the list
06:39:36 <trofi> > fix error
06:39:38 <lambdabot>  "
06:39:50 <trofi> %)
06:40:03 <trofi> > error "i am an error"
06:40:05 <lambdabot>  mueval: Expression did not compile.
06:40:05 <lambdabot> mueval: Time limit exceeded
06:40:27 <gwern> fix error does not work as expected, it's not going to work, so stop trying :)
06:41:03 <trofi> will errors wirk at all ?
06:41:03 <Twey> What should it do?
06:41:08 <Twey> @src fix
06:41:08 <lambdabot> fix f = let x = f x in x
06:41:09 <trofi> like last simple case
06:41:25 <trofi> Twey: you could try in ghci :]
06:41:52 <Twey> Spams lots of errors, ne
06:42:03 <trofi> yep
06:42:25 <sw17ch> @djinn (a->b) -> (b->a)
06:42:26 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
06:42:45 <sw17ch> :t flip
06:42:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:42:47 <trofi> what djinn can do?
06:43:03 <Twey> :t fix
06:43:04 <lambdabot> forall a. (a -> a) -> a
06:43:09 <gwern> trofi: write function definitions based on the type
06:43:15 <Twey> @djinn (a -> a) -> a
06:43:15 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
06:43:19 <Deewiant> or it could do that, if it worked
06:43:20 <sw17ch> @djinn forall a. (a -> a) -> a
06:43:21 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
06:43:22 <Twey> Borked
06:43:28 <gwern> @djinn (a, b) -> a
06:43:29 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
06:43:40 <gwern> ok, now I know that one should've worked
06:43:46 * sw17ch goes back to his HTML DOM hackery
06:43:47 <Deewiant> @djinn a -> a
06:43:47 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
06:43:50 <gwern> hm. did Cale even install djinn?
06:44:37 <gwern> trofi: here's an example session
06:44:40 <gwern> Djinn> foo ? (a,b) -> a
06:44:41 <gwern> foo :: (a, b) -> a
06:44:42 <gwern> foo (a, _) = a
06:44:55 <dmead> > find "123" [1..20]
06:44:58 <lambdabot>  mueval: Expression did not compile.
06:44:58 <lambdabot> mueval: Time limit exceeded
06:45:09 <trofi> does he save these functions?
06:45:18 <trofi> or generates them randomly?
06:45:27 <gwern> I give it an arbitrary identifier, and a type. the type happens to be unique - you can only write one function which satisfies it (modulo stuff like unsafeperformIO and bottom)
06:46:16 <gwern> I think Cale didn't install djinn. I'm running lambdabot locally, and:
06:46:17 <gwern> lambdabot> djinn (a,b) -> a
06:46:17 <gwern> f (a, _) = a
06:46:29 <gwern> @hoogle find
06:46:29 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
06:46:29 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:46:29 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:46:43 <gwern> trofi: who is he, what are 'these', and what do you mean by save or generate randomly?
06:47:01 <gwern> dmead: what find were you expecting?
06:47:10 <trofi> `these' - shown functions (does he preserve state)
06:47:52 <trofi> what if Num a => (a, b) -> a -- variants: = a; = a * a; etc.
06:48:07 <gwern> do you mean, if I successfully generate a foo :: (a,b) -> a, does djinn save it and reuse foo in later definitions?
06:48:14 <trofi> yep
06:48:32 <gwern> trofi: ah, but that's a different function, isn't it?
06:48:53 <gwern> it's like foo :: String -> String - there are a ton of possible definitions. but what could you write for foo :: a -> a?
06:48:57 <gwern> just id
06:49:47 <gwern> it's an interesting topic, but I've never had any practical use for it, because all the types I deal with when writing actual stuff have multiple instantiations, y'know
06:50:21 <dmead> gwern, an index
06:50:26 <dmead> 0 or 1
06:51:07 <Jedai> trofi: In other words, it doesn't generate them randomly, it does its best to construct an inhabitant of the type you give him, for some types this inhabitant happens to be unique (as long as you don't use undefined or unsafePerformIO)
06:51:09 <dmead> i'm looking at data.list but there doesn't seem to be a clear way to do find-replace on a large string
06:51:17 <gwern> (and besides, find :: String -> [Int] -> Int is a bit odd)
06:51:40 <trofi> if Prelude would have id and id2 - djinn would fail in 'a -> a' input?
06:51:48 <gwern> I doubt there would be. for that sort of thing, look to bytestring or the regex libs
06:52:08 <Jedai> dmead: There is not, if you don't need to much performance, it's easy to write with stripPrefix though
06:52:52 <dmead> Jedai, well my string isn't huge, so yea
06:53:29 <trofi> > "boo" `isInfixOf` "caboom"
06:53:31 <lambdabot>  True
06:53:35 <Jedai> dmead: Anyway if it was huge, you would be better off using ByteString (which have such a function I think)
06:54:24 <dmead> ah
06:54:26 <swiert> I think you can just hop on...
06:54:40 <swiert> Sorry - wrong window.
06:55:08 <trofi> @hoogle String -> String
06:55:08 <lambdabot> Network.CGI urlDecode :: String -> String
06:55:08 <lambdabot> Network.CGI urlEncode :: String -> String
06:55:08 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
06:55:14 <trofi> @hoogle replace
06:55:15 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:55:15 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
06:55:15 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
06:55:29 <trofi> @hoogle replace :: String -> String
06:55:30 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
06:55:30 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
06:55:30 <lambdabot> System.FilePath.Posix replaceDirectory :: FilePath -> String -> FilePath
06:55:42 <dmead> hmm
06:55:46 <dmead> there really should be a reaplce
06:55:49 <dmead> *replace
06:55:51 <trofi> @hoogle subst :: String -> String
06:55:51 <lambdabot> No results found
06:55:59 <trofi> @src replace
06:55:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:57:00 <Twey> Hmn
06:57:09 <Twey> What do 'gets' and 'puts' do in State?
06:57:20 <trofi> @src get
06:57:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:57:23 <trofi> @src gets
06:57:24 <lambdabot> Source not found.
06:57:28 <dmead> ah ah
06:57:29 <dmead> found it
06:57:30 <Twey> And why do Haskell functions have to have names that are so damn hard to google? >.<
06:57:33 <dmead> this is a string replace
06:57:34 <dmead> http://bluebones.net/2007/01/replace-in-haskell/
06:57:39 <lambdabot> Title: bluebones.net» Blog Archive » Replace in Haskell
06:57:50 <dmead> twey cause they were written before google was popular
06:57:52 <trofi> @src State
06:57:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:57:59 <trofi> @src Monad State
06:58:00 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:58:04 <trofi> @src State Monad
06:58:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:58:12 <Twey> dmead: *snorts*
06:58:19 <dmead> :P
06:58:24 <Twey> @src State gets
06:58:24 <lambdabot> Source not found. I am sorry.
06:58:25 <mxc> good evening/morning everyone
06:58:31 <Twey> Mornin'
06:58:39 <mxc> is anyone  using yi so far? with vi bindings?
06:59:07 <dzlk> @src Control.Monad.State.gets
06:59:07 <lambdabot> Source not found. Are you on drugs?
06:59:14 <trofi> do PgUp/PgDn work in Yi?
06:59:37 <Wild_Cat> theoretically, they do. However, not with Cua bindings, and not at all when I tried it the other day.
07:02:26 <gwern> pgup/pgdn work with emacs bindings
07:02:34 <gwern> C-up and C-dwn are broken in vty yi tho
07:03:04 <trofi> Home/End?
07:03:12 <Wild_Cat> home/end broken in vty as well.
07:03:31 <gwern> yeah. vty in general is broken
07:03:54 <trofi> which is good? yi-gtk?
07:04:16 <gwern> yi with the gtk frontend is best
07:04:21 <mxc> hm, building on osx is not that simple
07:04:23 <Wild_Cat> yi -fgtk , from what I hear, but my version of gtk2hs was too old for me to test it.
07:05:04 <Wild_Cat> (and I couldn't be bothered to install one not from the Ubuntu repos)
07:05:07 <gwern> mxc: it never is
07:05:48 <trofi> why gtk2hs not on hackage?
07:06:10 <Wild_Cat> nope, it's not.
07:06:34 <trofi> will it be someday there?
07:06:44 <trofi> or there's no such plans?
07:07:18 <ndmitchell> trofi: i really hope it will be one day, but it doesn't build with Cabal yet
07:07:21 <gwern> it will be
07:07:25 <gwern> it's just very difficult
07:07:51 <gwern> think harder than darcs, but not as bad as ghc to cabalize
07:08:02 <trofi> ah, not cabalized. that's bad
07:09:07 <mxc> is 4 lines too much to paste?
07:09:12 <dmead> ?src lines
07:09:12 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:09:20 <dmead> :t lines
07:09:21 <lambdabot> String -> [String]
07:09:28 <trofi> @paste
07:09:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:10:36 <dmead> lines "1\n2\n3\n"
07:10:39 <dmead> > lines "1\n2\n3\n"
07:10:40 <lambdabot>  ["1","2","3"]
07:10:47 <dmead> hmmmmmmmmmmmmmm
07:11:10 <trofi> @src words
07:11:10 <lambdabot> words s = case dropWhile isSpace s of
07:11:10 <lambdabot>     "" -> []
07:11:10 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
07:11:14 <sioraiocht> anyone know how I would go about making emacs run lhs2TeX on my LaTeX document before running pdflatex whenever I compile via emacds?
07:11:16 <sioraiocht> *emacs
07:11:29 <trofi> i think same for line s/isSpace/=='\n'/
07:11:44 <ndmitchell> trofi: not quite...
07:11:54 <ndmitchell> > words "neil "
07:11:55 <lambdabot>  ["neil"]
07:11:57 <trofi> strips \n\n\n ?
07:11:59 <ndmitchell> > lines "neil\n"
07:12:00 <lambdabot>  ["neil"]
07:12:13 <ndmitchell> there is some reason they aren't the same, just trying to think what...
07:12:13 <dmead> for some reason ghci is reading my newlines as
07:12:15 <dmead> \\n
07:12:28 <trofi> '\\' = \
07:12:29 <dmead> and i only get one string back with lines
07:12:29 <ndmitchell> dmead: have you got a show in there somewhere? perhaps as a print?
07:12:35 <dmead> yea
07:12:35 <dmead> oh
07:12:40 <gwern> > concat $ lines "sieg heil"
07:12:41 <lambdabot>  "sieg heil"
07:12:56 <dmead> ndmitchell++
07:13:05 <trofi> > lines "a\n\n\nb"
07:13:06 <lambdabot>  ["a","","","b"]
07:13:09 <dmead> no karma?
07:13:13 <dmead> you were right =)
07:13:13 <trofi> > words "a   b"
07:13:14 <lambdabot>  ["a","b"]
07:13:34 <ndmitchell> dmead: i think it does it automatically but says nothing
07:13:45 <dmead> ah
07:14:40 <Wild_Cat> doh. I just realized a question I asked yesterday has a stupidly-obvious answer. For those of you who still wonder how to apply a series of functions to a single value (as in, [a -> b] -> a -> [b], compared to map :: a -> b -> [a] -> [b]), the answer is map ($ value) functions
07:15:20 <dolio> @type \fs v -> sequence fs v
07:15:21 <lambdabot> forall t a. (Monad ((->) t)) => [t -> a] -> t -> [a]
07:15:43 <Wild_Cat> yeah, but I wanted a pure function ;)
07:15:51 <dolio> That is a pure function.
07:16:12 <Twey> Yeah, Wild_Cat
07:16:16 <Twey> I found that out earlier :)
07:16:29 <Wild_Cat> ...and my solution is clearer IMO :p
07:16:39 <eu-prleu-peupeu> hmm
07:16:46 <eu-prleu-peupeu> can i have a where clause inside a where clause ? :P
07:16:51 <Twey> Yes, eu-prleu-peupeu
07:16:58 <trofi> > sequence True [not, and True, or False]
07:17:01 <lambdabot>  mueval: Expression did not compile.
07:17:01 <lambdabot> mueval: Time limit exceeded
07:17:09 <eu-prleu-peupeu> wont it become too much cluttered ?
07:17:14 <trofi> > sequence True [not, (&&) True, (||) False]
07:17:17 <lambdabot>  mueval: Expression did not compile.
07:17:17 <lambdabot> mueval: Time limit exceeded
07:17:24 <trofi> @type sequence True [not, (&&) True, (||) False]
07:17:26 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:17:29 <Wild_Cat> eu-prleu-peupeu: "can" doesn't mean "should" ;)
07:17:35 <eu-prleu-peupeu> hmm
07:17:41 <eu-prleu-peupeu> how do i avoid it ? :/
07:17:52 <eu-prleu-peupeu> ill show the code...
07:18:30 <jason__> Hello my name is Jason I am new to Haskell and programming in general.  I would like to ask a question about setting up leksah, if anyone is free.
07:18:46 <eu-prleu-peupeu> http://hpaste.org/9807
07:18:48 <eu-prleu-peupeu> :(
07:19:05 <eu-prleu-peupeu> can someone please give me suggestions to improve the overall readability and aspect of the code ?
07:19:14 <quicksilver> eu-prleu-peupeu: that can be at the same level
07:19:20 <quicksilver> eu-prleu-peupeu: there is no need for nesting there
07:19:42 <eu-prleu-peupeu> oh, ok
07:19:57 <eu-prleu-peupeu> ghc is smart :)
07:20:13 <jtraub> Hi
07:20:54 <eu-prleu-peupeu> i just need to convert fov from degrees to rads :P  ill do a "math" module for that i guess...
07:21:07 <jtraub> I am looking for sites with puzzles and exercises like projecteuler
07:21:30 <quicksilver> multiplying or dividing by 2*pi hardly needs a module all of its own.
07:21:35 <opqdonut> jtraub: spoj.pl is one
07:21:55 <eu-prleu-peupeu> well, its just so that in the future i can have all of those little functions in a place together
07:22:10 <jtraub> opqdonut, thanks. Does it support Haskell?
07:22:16 <opqdonut> jtraub: iirc yes
07:22:29 <eu-prleu-peupeu> hmm, do i need to do that vector thing ? like Vector3 {x=x, y=y, z=z} ?
07:23:00 <opqdonut> eu-prleu-peupeu: you could just say (Vector3 x y z)
07:23:09 <opqdonut> you don't need to use the field names
07:23:14 <opqdonut> of course it makes the code clearer
07:24:05 <jason__> When I try to build leksah I get "Duplicate instance declarations:  instance Ord Modifier        -- Defined at src/IDE/Core/Types.hs:(166,0)-(167,56)      instance Ord Modifier -- Defined in Graphics.UI.Gtk.Gdk.Events
07:24:08 <eu-prleu-peupeu> thanks :)
07:24:53 <opqdonut> eu-prleu-peupeu: if you're willing to go to more advanced stuff i could recommend changing those to "data Vector3 a = Vector3 {x::a, y::a, z::a}" and "type Matrix = Vector3 (Vector3 Double)"
07:24:57 <opqdonut> or something like that
07:25:10 <opqdonut> captures the "matrix is a vector of vectors" idea nicely
07:25:35 <EvilTerran> opqdonut, eu-prleu-peupeu: i believe you can write "data Vector3 a = Vector3 {x, y, z :: a}" even
07:25:45 <opqdonut> oh
07:26:00 <EvilTerran> compare "x,y,z :: Int" at the top-level or whatever
07:26:18 <opqdonut> eu-prleu-peupeu: also, that "Matrix = Vector (Vector double)" would give you proper two-level addressing
07:26:29 <opqdonut> without those x0 w2 kludges
07:26:53 <mjrosenb> jacobian: hey, i got a version of my idea working
07:27:21 <jacobian> great!
07:27:25 <eu-prleu-peupeu> allright, ill change it then :)
07:27:37 <jacobian> mjrosenb: was it the strategy with 2 parameters?
07:28:16 <mjrosenb> jacobian: no, the one involving the fibonacci numbers
07:28:52 <jacobian> ah! :)
07:28:53 <quicksilver> opqdonut: although, it doesn't give eu-prleu-peupeu  his cute literal syntax.
07:29:20 <osfameron> that's one hell of a nick
07:29:37 <opqdonut> quicksilver: well he could make a 9-ary helper function ;)
07:29:43 <jacobian> I found this paper: www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/12num.pdf
07:29:48 <quicksilver> true.
07:29:49 <opqdonut> er 16-ary
07:32:15 <eu-prleu-peupeu> very nicee good
07:38:14 <MarcWeber> malcolmw: I've tried parsing xhtml dtd. It fails. Do you think it should be supported?
07:38:48 <malcolmw> MarcWeber: It is probably a bug in HaXml.  Sorry, but I don't really have the time to maintain HaXml much these days.
07:39:36 <MarcWeber> malcolmw: I know. That's was the reply I tried to get :)
07:40:34 <mjrosenb> this ordering looks *pretty* random
07:42:33 <Saizan> ?tell gwern i realized a general prettyprinter wouldn't help on getting the information we want out of InterpreterError, but i've sent two patches for mueval to print compiler errors nicely
07:42:33 <lambdabot> Consider it noted.
07:43:04 <mjrosenb> how would i check to see if a list of bools ends in an odd number of True's?
07:45:38 <quicksilver> odd . length . takeWhile (==True) . reverse
07:46:06 <ndmitchell> odd . length . takeWhile id . reverse -- slightly more compact, possibly more cryptic :-)
07:46:58 <mjrosenb> certianl more fixed-point than my solution
07:47:39 <olsner> fixed-point?
07:47:47 <ndmitchell> point-free :)
07:48:10 <mjrosenb> gah
07:48:17 <mjrosenb> need more sleep
07:48:38 <mjrosenb> i should probably not start doing things like this at 9 am
07:49:47 <quicksilver> yes, I prefer (==True) to id,  where they are equivalent.
07:50:07 <trofi> @pl \x -> x
07:50:08 <lambdabot> id
07:50:14 <ndmitchell> me too, if it wasn't for the brackts :)
07:50:18 <ndmitchell> @pl x == True
07:50:19 <lambdabot> x == True
07:50:23 <Deewiant> @pl \x -> x == True
07:50:23 <lambdabot> (True ==)
07:50:28 <lilac> @djinn a -> a
07:50:28 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
07:50:58 <GremlinHunter> (&&True) :)
07:51:09 <lilac> @djinn Bool -> Bool
07:51:09 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
07:52:14 <mjrosenb> [[1],[2],[4],[3],[1,2],[7],[6],[5],[1,4],[1,3],[12],[11],[2,2],[10],[9],[8],[1,1,2],[1,7],[1,6],[1,5],[4,2],[20],[19],[18],[2,4],[2,3],[17],[16],[3,2],[15],
07:52:53 <mjrosenb> it seems to be working
07:52:55 <quicksilver> really?: brackets bother you that much? I think sections are a fine notation.
07:53:53 <ndmitchell> quicksilver: not really, just less brackets are good, and code without brackets is slightly more visually appealing - although not by much
07:54:27 <EvilTerran> ndmitchell, you could define isTrue = id :P
07:54:36 <quicksilver> I find excessive brackets ugly, certainly, but that example is below my pain threshold.
07:54:37 <lilac> mjrosenb: what's that sequence?
07:54:48 <EvilTerran> who knows, maybe you'd be the first person to get some haskell on the frontpage of TDWTF
07:55:18 <Wild_Cat> Haskell on TDWTF? I'd drink to that :D
07:55:27 <mjrosenb> lilac: all finite lists of finite integers without repeats
07:55:30 <mjrosenb> hopefully
07:55:53 <lilac> mjrosenb: all integers or just naturals?
07:55:59 <mjrosenb> err
07:56:01 <mjrosenb> naturals
07:56:31 <mjrosenb> but integers would not be horribly more involved
07:56:43 <lilac> that's some funky order :) i'd probably have gone for colex
07:57:11 <mjrosenb> colex?
07:57:26 <Philippa> Wild_Cat: it's happened, someone used the infamous list comprehension quicksort as one
07:57:50 <Philippa> anyway, I don't think it'd be too hard for us to generate WTFy haskell :-)
07:57:58 <Wild_Cat> Philippa: on the front page, or just in the sidebar? (I'm assuming this is the 3-line quicksort that actually performs like shit?)
07:58:40 <Philippa> dunno about front page. And yes, the awful 3-liner
07:58:43 <lilac> mjrosenb: colexicographical order. though it's been a while since i studied combinatorics and my memory is somewhat fuzzy :(
07:58:59 <Philippa> a really nice in-place array quicksort is probably less than 10 lines, but so what?
07:59:35 <Philippa> (on, say, an STArray)
08:00:17 <int-e> > let toList 0 = []; toList x | odd x = 0 : toList (x `div` 2) | otherwise = let (y:ys) = toList (x `div` 2) in (y+1):ys in map toList [0..]
08:00:19 <lambdabot>  [[],[0],[1],[0,0],[2],[0,1],[1,0],[0,0,0],[3],[0,2],[1,1],[0,0,1],[2,0],[0,1...
08:01:31 <Wild_Cat> Philippa: or Data.List.sort anyway. The 3-liner is a nice demonstration of Haskell's expressiveness, but it's not meant as a production tool, I wouldn't call it a WTF by any means.
08:02:13 <quicksilver> 99% of the stuff on WTF isn't a WTF.
08:02:38 <quicksilver> and, the real WTF is normally the idiots commenting and demonstrating they didn't understand anything.
08:02:59 <Wild_Cat> quicksilver: I disagree, there's quite a bunch of really WTFy WTFs.
08:03:19 <Philippa> Wild_Cat: yep, most of the WTF was basically "argh, me no like comprehension syntax!"
08:03:49 <Wild_Cat> Philippa: was it? List comprehension syntax is brilliant, though. It's one of the things that got me hooked on Python.
08:04:24 <sampointon> Wild_Cat: funny, I'm going the other way
08:04:35 <Wild_Cat> sampointon: what other way?
08:04:50 <sampointon> Wild_Cat: going from Python to Haskell
08:05:19 <quicksilver> Wild_Cat: well I exaggerate of course, but for every boggling truly boggling one there is a lot of 'meh'.
08:05:26 <Wild_Cat> sampointon: that's what I'm doing too. I'm a professional Python dev, attempting to dive into Haskell for the 5th time in 3 years.
08:06:02 <osfameron> there was a haskell wtf?
08:06:26 <jtraub> I am newbiew with haskell
08:06:34 <quicksilver> Philippa: the only mention google can find is http://thedailywtf.com/Articles/Friday_Smorgasbord.aspx
08:06:35 <lambdabot> Title: Friday Smorgasbord - The Daily WTF
08:06:58 <jtraub> my task is to find first fibonacci number which exceeds ten millions
08:07:16 <jtraub> are there common techniques to make it?
08:07:28 <mauke> head . dropWhile (< 10000000) $ fibo
08:07:48 <jtraub> mauke, can you explain? Please&
08:07:53 <mauke> explain what?
08:08:03 <jtraub> $ sign
08:08:11 <jtraub> . is function composition
08:08:17 <mauke> $ is function application
08:08:19 <jtraub> but i don't understand $
08:08:21 <mauke> @src ($)
08:08:21 <lambdabot> f $ x = f x
08:08:22 <sampointon> it means 'apply', a $ b = a b
08:08:56 <Wild_Cat> the $ isn't needed in that case, is it?
08:08:57 <quicksilver> (head . dropWhile (<100000)) (fibo)
08:09:11 <sampointon> what quicksilver said, it saves some brackets on the left
08:09:13 <SamB> Wild_Cat: you can't just take it out
08:09:29 <SamB> unless you mean the a $ b case, in which case of course you can ;-)
08:11:02 <lilac> > log 10000000 / log ((1 + sqrt 5) / 2) -- jtraub
08:11:05 <lambdabot>  mueval: Expression did not compile.
08:11:05 <lambdabot> mueval: Time limit exceeded
08:11:08 <mjrosenb> lilac: so the only page that i found that had colexicographical order is this
08:11:51 <jtraub> lilac, :-) bruteforce :-)))
08:11:55 <mjrosenb> http://www.delphiforfun.org/programs/Math_Topics/Integer_partitions.htm
08:12:23 <dolio> Colexicographical?
08:12:27 <mjrosenb> but it seems like that would never allow you to actually generate *every* finite list of finite integers
08:12:38 <mjrosenb> dolio: lilac is the one that knows about it.
08:12:52 <mauke> > let fibo = 0 : 1 : ap (zipWith (+)) tail fibo in head . dropWhile (< 10000000) $ fibo
08:12:53 <lambdabot>  14930352
08:13:24 <jtraub> hm..
08:13:30 <jtraub> my guess was right
08:13:47 <jtraub> Haskell is much easier to learn when
08:13:53 <jtraub> solving puzzles
08:14:13 <Wild_Cat> any language is easier to learn when applying it to a problem ;)
08:16:39 <mjrosenb> is there any good reason that the ghci debugger would get very confused as to what variables have what types, and what values are bound to them
08:16:47 <mjrosenb> and would attempt to step twice
08:16:51 <mjrosenb> then hang
08:17:07 <GremlinHunter> Is there an inbuilt way to time functions in ghci?
08:17:16 <quicksilver> :set +s
08:17:26 <GremlinHunter> Thanks
08:17:40 <quicksilver> it's fairly simplistic but useful for simple things :)
08:19:31 <dmead> well thats better than complex but useful for simple things
08:19:34 <dmead> that would be a waste!
08:20:07 <jtraub> ok. another dumb questions
08:20:15 <jtraub> how can i convert number to string?
08:20:23 <GremlinHunter> :t show
08:20:24 <lambdabot> forall a. (Show a) => a -> String
08:20:25 <ndmitchell> @hoogle Int -> String
08:20:26 <lambdabot> Prelude show :: Show a => a -> String
08:20:26 <lambdabot> Text.Show show :: Show a => a -> String
08:20:26 <lambdabot> Language.Haskell.Pretty prettyPrint :: Pretty a => a -> String
08:20:42 <quicksilver> No emails on the -cafe for 7 hours?
08:20:43 <jtraub> thanks..
08:20:47 <quicksilver> is my email broken, or haskell.org broken?
08:22:28 <Peaker> maybe people's spirit was broken
08:25:35 <lilac> > let all = [] : [1..] >>- ((`map` all) . (:)) in take 10 all -- mjrosenb
08:25:38 <lambdabot>  mueval: Expression did not compile.
08:25:38 <lambdabot> mueval: Time limit exceeded
08:25:53 <Peaker> @type (>>-)
08:25:54 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
08:26:09 <Peaker> what's the difference between that and (>>=) ?
08:26:20 <Peaker> @src MonadLogic
08:26:20 <lambdabot> Source not found. Maybe you made a typo?
08:26:21 <lilac> (>>-) is fair
08:26:34 <Peaker> what does that mean?
08:27:14 <mar77a> it takes from the rich and gives it to the poor
08:27:44 <GremlinHunter> The Robin Hood operator?
08:27:52 <mar77a> it looks like an arrow doesn't it
08:28:32 <lilac> Peaker: [1..] >>= \a -> [1..] >>= \b -> (a,b) will never give (2,1). But if you use >>-, it will.
08:29:10 <Peaker> lilac: ah
08:29:22 <Peaker> allows enumerating infinites...
08:29:40 <jtraub> I am looking for good Haskell reference
08:29:57 <jtraub> and reference on Prelude
08:30:07 <jtraub> I am trying to convert Float to Int
08:30:14 <ndmitchell> @hoogle Float -> Int
08:30:14 <Wild_Cat> jtraub: truncate
08:30:15 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
08:30:15 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
08:30:15 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
08:30:57 <dzlk> hoogle is your friend.
08:31:03 <mauke> not in this case
08:31:06 <Wild_Cat> :t truncate
08:31:07 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
08:31:13 <Wild_Cat> > truncate 2.5
08:31:14 <jtraub> i am sorry. but what is hoodle?
08:31:14 <lambdabot>  2
08:31:17 <jtraub> *hoogle
08:31:23 <ndmitchell> dzlk: not for this question...
08:31:24 <mauke> @where hoogle
08:31:25 <lambdabot> http://haskell.org/hoogle
08:31:32 <jtraub> > truncate (sqrl 5)
08:31:34 <lambdabot>  mueval: Expression did not compile.
08:31:34 <lambdabot> mueval: Time limit exceeded
08:31:36 <jtraub> > truncate (sqrt 5)
08:31:37 <lambdabot>  2
08:34:01 <Peaker> jtraub: hoogle is one of the cool things that becomes possible with a strong type system :)
08:34:24 <byorgey> jtraub: Hoogle is a tool for searching Haskell documentation.
08:35:29 <byorgey> jtraub: http://haskell.org/ghc/docs/latest/html/libraries/
08:35:30 <lambdabot> Title: Haskell Hierarchical Libraries
08:35:53 <jtraub> cool thing
08:35:59 <jtraub> i am playing with it now :-)
08:36:19 <Peaker> byorgey: that makes it sound boring :)
08:36:21 <hackage> Uploaded to hackage: chalmers-lava2000 1.0.1
08:36:37 <Peaker> byorgey: the static-type-signature searching, and in a smart way, is what I think is cool about it :)
08:36:58 * ndmitchell tends to use Hoogle for name searches
08:37:10 <GremlinHunter> I am still convinced that it is black magic
08:37:11 <byorgey> Peaker: my statement was intended to be taken together with yours.  I provided the facts while you provided the interest. =)
08:37:43 <byorgey> I agree the type signature searching is cool, although I also rarely use it for that
08:37:58 <byorgey> it's the kind of thing one probably does while becoming familiar with the standard libraries.
08:38:32 <byorgey> GremlinHunter: it is.  black magic encoded in the type system.
08:39:21 <jtraub> factors x = [n | n<-[1..(truncate (sqrt x))+1], x `mod` n ==0]
08:39:28 <jtraub> what wrong with this function?
08:39:37 <jtraub> it causes error with ghci
08:39:58 <rwbarton> :t sqrt
08:39:58 <pozic> What does the Hoogle command line application do anyway? Does it connect to the web to fetch the answers or does it work locally?
08:39:59 <lambdabot> forall a. (Floating a) => a -> a
08:40:00 <ndmitchell> > \x -> [n | n<-[1..(truncate (sqrt x))+1], x `mod` n ==0]
08:40:03 <lambdabot>  mueval: Expression did not compile.
08:40:03 <lambdabot> mueval: Time limit exceeded
08:40:07 <ndmitchell> pozic: it works locally
08:40:14 <chrisdone> thank god it does
08:40:30 <ndmitchell> pozic: it uses most of the same code underneath, but is implemented as a command line tool
08:40:37 <chrisdone> my connections been crap recently, having it local saved me having to stop and look inside my local hackage packages
08:41:14 <chrisdone> although the latest hoogle seems to be broken with GOA. I guess I'll fix that at some point
08:41:22 <GremlinHunter> Sureley you only need to search till (truncate (sqrt x))
08:41:49 <rwbarton> jtraub: x is supposed to be Integer, right? so you need sqrt (fromInteger x)
08:41:59 <pozic> ndmitchell: and what does it do currently? Will it look in all Cabal packages?
08:42:04 <jtraub> rwbarton, yep
08:42:34 <pozic> ndmitchell: or, is there a manpage somewhere?
08:44:05 <jtraub> rwbarton, thanks. it works now
08:44:27 <ndmitchell> pozic: that is still being worked out, it can look at acabal packages, but at the moment they have to be generated by me
08:44:40 <ndmitchell> in a few days, i hope to write up how to generate the hoogle databases
08:44:48 <ndmitchell> and in few months, i hope Cabal will do it for you
08:45:05 <adekoba> ndmitchell: neat. I was wondering if that was possible.
08:45:10 <CosmicRay> @hpaste
08:45:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:45:12 <ndmitchell> http://haskell.org/haskellwiki/Hoogle has the details
08:45:13 <lambdabot> Title: Hoogle - HaskellWiki
08:45:44 <ndmitchell> adekoba: it is, but requires Haddock HEAD, and various custom hacky scripts - it needs cleaning up before i push it out
08:45:45 <pozic> ndmitchell: so users essentially get a constant data base in which they can search?
08:45:52 <adekoba> ndmitchell: I've noticed that hoogle doesn't pick up some results, like queries of "sleep" and System.Posix.Unistd
08:46:29 <ndmitchell> adekoba: probably because i built the docs on a windows machine which will have CPP'd those bits out
08:46:32 <adekoba> pozic: yeah. If you look in the hoogle package, you'll see the database file that it ships with
08:46:56 <ndmitchell> pozic: you get a set of databases, one per package, and a default package which is a combination of all the packages you usually lwant to search
08:47:32 <ndmitchell> currently the command line verison ships with default.hoo, but the web version now has 23 databases with it
08:47:50 <adekoba> ndmitchell: how long, an estimate is fine, does it usually take to index base?
08:47:52 <Philonous> I have problems understanding the difference between data and newtype. Is newtype just a synonyme whereas data always introduces a new type?
08:47:53 <pozic> ndmitchell: I missed http://www.haskell.org/haskellwiki/Hoogle, no need to explain anything more.
08:47:55 <lambdabot> Title: Hoogle - HaskellWiki
08:48:19 <pozic> Philonous: type is synomym.
08:48:50 <ndmitchell> adekoba: there are three stages, download the base from darcs (~3 mins), run cabal haddock --hoogle over it (~3 mins, all haddock/cabal time), run hoogle --convert (3 seconds)
08:48:56 <pozic> Philonous: newtype Foobar = Foobar Integer = data FooBar = FooBar !Integer
08:49:16 <ndmitchell> adekoba: so not long, once you have a textfile of all the definitions, but getting that text file can take a little while
08:49:26 <adekoba> ndmitchell: yeah, sounds good
08:49:30 * dmead is using haskell at work =)
08:49:34 <pozic> Philonous: newtype is an optimization which imho has little use other than newtype deriving which is non-standard.
08:50:02 <quicksilver> pozic's equation is not scrupulously accurate
08:50:07 <quicksilver> but it is a good guidelines
08:50:20 <Jedai> ndmitchell: There is a slight "problem" (or not, depending on how you consider it) : searching for "(Monad m) => m a -> (a -> m b) -> m b" don't give you (>>=) first, because Monad m is not considered part of the signature of (>>=) (because bind is part of the class Monad)
08:50:33 <pozic> Some = are object = and some are semantical =.
08:50:35 <quicksilver> the difference between data ... !a and newtype ... a is seldom important.
08:50:43 <Jedai> ndmitchell: On the other hand it's the third result anyway, so it's not too bad
08:50:46 <ndmitchell> Jedai: today, or yesterday?
08:50:59 <quicksilver> pozic: there remains a subtle difference between data FB = FB !Int and newtype FB = FB Int.
08:51:06 <quicksilver> but it is not often important.
08:51:18 <adekoba> and it's good if you want to make the new type exclusive... in other words, if you have to explicity construct the type instead of being able to pass the type which it copies. For example, if string was a newtype, you wouldn't be able to pass [Char] to a function which expecting String.
08:51:21 <Philonous> pozic I don't quite get it yet, but it helped a bit. Thanks.
08:51:30 <idnar> quicksilver: what is the difference?
08:51:49 <pozic> Maybe ~
08:51:55 <quicksilver> idnar: the difference is that case-deconstructing a newtype is a NOP, whereas case-deconstructing a strict data forces the contents.
08:51:55 <ndmitchell> Jedai: i think that was a bug i fixed yesterday, related to explicit forall's in haddock type signatures :)
08:52:05 <idnar> quicksilver: ah
08:52:16 <ndmitchell> Jedai: (web version only, i'm still waiting to push out a new command line version)
08:52:17 <Jedai> ndmitchell: Yesterday ! Today it's fine ^^ (The new version is really very nice by the way, good work)
08:52:50 <pozic> quicksilver: yes, that has never ever been a problem, but it's better to be accurate yes.
08:53:02 <pozic> Philonous: if you want the full story, read the report.
08:53:03 <quicksilver> agreed. It is very rarely important.
08:53:26 <quicksilver> it is important in the same (small number) of cases that you need to use ~(a,b) to stop a recursion being over-strict.
08:53:29 <Twey> There's a way to construct new values using record syntax, isn't there?
08:53:40 <quicksilver> Foo {a = 2,b = 3}
08:53:48 <Twey> Ah, that's it, thanks :)
08:54:00 <pozic> quicksilver: do you know what record puns are?
08:54:04 <quicksilver> pozic: I do.
08:54:12 <pozic> quicksilver: I do too, I like them :)
08:54:28 <quicksilver> I don't use them although I've considered it a few type.
08:54:30 <quicksilver> times.
08:54:33 <quicksilver> damn typing.
08:54:39 <pozic> For construction there should be something equal.
08:54:48 <kaol> someone feel like debugging http://hpaste.org/9809 for me? I can't make sense out of that infinite type error.
08:55:54 <ndmitchell> kaol: if you paste the error message its easier to do
08:56:15 <ndmitchell> kaol: i.e. the code and the error
08:56:18 <kaol> Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `perms'
08:56:59 <rwbarton> kaol: the body of the inner case statement looks fishy
08:57:50 <kaol> @type map ('a':) "abc"
08:57:51 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:58:00 <kaol> :t map ('a':) "abc"
08:59:12 <ndmitchell> kaol: what is that "do" doing there?
08:59:16 <mauke> error: what. expected type: [[Char]]; inferred type: [Char]; in the expression: "abc"
09:00:04 <kaol> it wasn't supposed to be there (I tried working in list monad first). but it was a no op anyway.
09:00:28 <fons> ping dcoutts
09:02:15 <dons> there you go, 500 packages in Arch, 723 in Hackage, and a survey of 10 cool Haskell packages that are relatively unknown,
09:02:18 <dons>  http://www.reddit.com/comments/6x6vx/the_500_packages_10_cool_haskell_packages_distros/
09:02:20 <lambdabot> http://tinyurl.com/5arweu
09:02:59 <dons> or the programming link , probably better,
09:03:00 <dons>  http://www.reddit.com/r/programming/comments/6x6vx/the_500_packages_10_cool_haskell_packages_distros/
09:03:06 <lambdabot> Title: The 500 Packages: 10 Cool Haskell Packages, Distros and Maintainership : program ..., http://tinyurl.com/6brh4l
09:03:43 <lispy> dons: something is still wrong with that ratio...only 10??
09:04:05 <dons> i couldn't cover them all :)
09:04:19 <lispy> oh, it's soething you wrote?
09:04:29 <lispy> I thought maybe this was from popcon or something
09:04:36 * lispy checks out the link
09:04:59 <lispy> oh, all 500 are haskell!
09:05:00 <lispy> cool
09:05:14 <dons> duh. :)
09:05:31 <lispy> from the title I couldn't tell...
09:06:25 <lispy> oh dang, we're beating python!
09:07:25 <quicksilver> dons: hipmunk is awesome!
09:07:30 <quicksilver> dons: I would have missed that, thanks!
09:09:59 <dzlk> hey, someone beat me to the dimensions library.
09:10:27 <dons> wow, clearly we need to do regular surveys of cool stuff
09:11:07 <lispy> That chart is sexy
09:11:23 <adekoba> dons: do you use archlinux?
09:11:26 <kaol> if anyone cares, I fixed the function myself
09:11:35 <lispy> Can someone combine that chart-api + happs to make a web interface for google charts?
09:11:43 <dons> adekoba: yeah.
09:12:00 <adekoba> noice.
09:12:07 * lispy has some histograms he needs to regenerate
09:26:09 <nathanic> if i have a function that evaluates a monadic action passed in as an argument ( foo x = do {...; result <- x; ...; return x} ), what is the most idiomatic name for that argument?
09:26:26 <nathanic> let's say it's in some arbitrary monad
09:26:29 <chrisdone> m
09:26:53 <nathanic> memorable ones i've seen in the wild are: m, act, and action
09:27:51 <nathanic> err, in my example i meant to return result ;-)
09:27:52 <lispy> just write it point free ;)
09:28:29 <nathanic> ha
09:28:34 <lispy> ?. pl undo \x -> do result <- x; return result
09:28:34 <lambdabot> id
09:28:35 <quicksilver> nathanic: I always call that 'act'
09:29:14 <quicksilver> often you can write that as foo x = .... *> x <* .....
09:29:59 <nathanic> quicksilver: i was unaware of (*>) etc.  where do those live?
09:30:07 <quicksilver> Control.Applicative
09:30:09 <jrh> question: what's the program that converts Haskell source to syntax highlighted HTML?
09:30:14 <jrh> is that Haddock, or something separate?
09:30:15 <byorgey> dons: nice article!
09:30:22 <quicksilver> hscolour
09:30:24 <byorgey> jrh: hscolour
09:30:26 <quicksilver> (which haddock runs)
09:30:30 <jrh> thanks
09:31:39 <nathanic> is there some intro doc you might recommend for understanding the motivation behind Control.Applicative?
09:31:50 <quicksilver> the paper linked to form the docs is good.
09:32:18 <nathanic> quicksilver: thanks :-)
09:32:22 <dons> dcoutts: did you know about http://pypi.python.org/pypi ?
09:32:23 <lambdabot> Title: Python Package Index : Home
09:32:35 * Saizan hates the indiscriminate use of "error" for common error cases..
09:35:33 <sbahra> Cale, thanks :D
09:35:37 <SamB> @yow
09:35:37 <lambdabot> Couldn't find fortune file
09:36:15 <trofi> @djinn a -> a
09:36:15 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
09:37:13 <eu-prleu-peupeu> check: http://abhishek.geek.nz/docs/features-of-common-lisp
09:37:16 <lambdabot> Title: Features of Common Lisp
09:38:53 <sbahra> @djinn f ? a -> a
09:38:54 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
09:38:58 <sbahra> uhm
09:39:43 <ddarius> dons: http://www.cse.wustl.edu/~loui/praiseieee.html  You may find this hard to read.
09:41:24 <trofi> dons: have `darcs sent' yesterday's patch for hs-plugins. How can i know his destiny(good/bad) ? :]
09:41:54 <dons> got it.
09:41:57 <dons> i'll apply this.
09:42:11 <dons> ddarius: sigh. yes.
09:42:30 <dons> it's all about the freaking libraries.
09:42:34 <FMota> oerjan's not here :-/
09:42:54 <guenni> quicksilver: ping
09:43:04 <chrisdone> gismus <- map gismuEntry . lines <$> io (readFile "gismu.txt") -- how can I make this line completely strict?
09:43:33 <dons> use strict readFile
09:44:24 <chrisdone> okay. how can I make the map and function it applies strict?
09:44:32 <guenni> is there a standard lib for creating a multi-indexed data structure?
09:44:34 <chrisdone> I don't want to just evaluate the spine of the list, if you see what I mean
09:44:49 <trofi> dons: tested lambdabot with patch (all packages are in --user install). (little outdated) runplugs+eval works great, if it matters
09:44:49 <dons> chrisdone: why do you want it to be strict?
09:44:52 <dons> to close the handle?
09:44:55 <dons> trofi: cool!
09:45:16 <guenni> I know of Happs IxSet, but I wonder if there is something else?
09:45:22 <FMota> dons: if you see oerjan, tell him I love him, and that he confuses me. Thank you.
09:45:27 <chrisdone> dons: so that I can query the list later on. I get the feeling it will evaluate the whole list every time I search through it
09:45:47 <dons> chrisdone: it won't re-eval it.
09:45:51 <dons> but it will traverse each time.
09:45:54 <chrisdone> ah, good
09:46:00 <chrisdone> thanks
09:46:03 <dons> the results of evaluation are cached :)
09:46:20 <dons> (the unevaluated expression is updated with its evaluated result)
09:46:48 <chrisdone> I forget sometimes
09:48:34 <ndmitchell> dons: using Data.Binary, what kind of speed do you get, in Mb/s
09:48:44 <dons> ndmitchell: depends on the data type.
09:49:08 <ndmitchell> dons: say individual Char's
09:49:14 <ndmitchell> or Word8's
09:49:18 <dons> let me run the test.
09:49:21 <ndmitchell> sent one at a time with put's
09:49:24 <dons> we're talking 100s of M/s btw.
09:49:37 <ndmitchell> in that case no need to run the test :)
09:49:40 <dons> ah ok.
09:49:44 <ndmitchell> mine is more like 1 M/s
09:49:54 <dons> newbinary is about 15M/s
09:50:13 <ndmitchell> that is the bytestring one?
09:50:24 <dons> no, the old classic runciman+wallace binary.
09:50:48 <ndmitchell> ok, what is the underlying "put" in the bytestring one? System.IO.hPut ?
09:51:01 <dons> 1000MB of bytes written in 1.743s, at: 573.7MB/s
09:51:02 <dons> 1000MB of bytes read    in 2.477s, at: 403.8MB/s
09:51:02 <dons> 1000MB of words written in 0.293s, at: 3409.3MB/s
09:51:02 <dons> 1000MB of words read    in 0.337s, at: 2970.5MB/s
09:51:13 <dons> ndmitchell: well, Data.Binary fills memory.
09:51:19 <dons> you can then flush that to disk if you want
09:51:37 <ndmitchell> yeah, but how does it flush that to disk?
09:51:44 <dons> 100MB of Word8  in chunks of  1 (  Host endian):   19.2 MB/s write,  168.6 MB/s read,   8.8 get/put-ratio
09:52:00 <dons> ndmitchell: hPutBuf ultimately.
09:52:12 <ndmitchell> hmm, that's what i used too
09:52:28 <ndmitchell> but my write speeds suck a lot
09:53:06 <noecksit_> hello, im not sure if its possible, but is there any way to preserve the output on Either datatype when using mplus?
09:53:26 <noecksit_> > Right 1 `mplus` Right 2
09:53:29 <lambdabot>  mueval: Expression did not compile.
09:53:29 <lambdabot> mueval: Time limit exceeded
09:54:21 <noecksit_> > (Right 1) `mplus` (Right 2)
09:54:24 <lambdabot>  mueval: Expression did not compile.
09:54:24 <lambdabot> mueval: Time limit exceeded
09:54:56 <mauke> No instance for (MonadPlus (Either a))
09:54:58 * jrheard hates it when people import modules unqualified
09:55:27 <Jedai> > Right 1 `mappend` Right 2
09:55:30 <lambdabot>  mueval: Expression did not compile.
09:55:30 <lambdabot> mueval: Time limit exceeded
09:55:34 <jrheard> is "actionNew" part of Graphics.UI.GTK?
09:55:53 <mauke>     No instance for (Monoid (Either a t))
09:56:44 <noecksit_> > Right 1 `mplus` Left "no"
09:56:45 <lambdabot>  Right 1
09:56:58 <DrSyzygy> > Left "no" `mplus` Right 1
09:56:59 <lambdabot>  Right 1
09:57:09 <trofi> @src Either mplus
09:57:09 <lambdabot> Left _ `mplus` n = n
09:57:09 <lambdabot> m      `mplus` _ = m
09:57:13 <DrSyzygy> > Right 2 `mplus` Right 1
09:57:16 <lambdabot>  mueval: Expression did not compile.
09:57:16 <lambdabot> mueval: Time limit exceeded
09:57:22 <DrSyzygy> o.O
09:57:50 <noecksit_> > Left "no" `mplus` Right 1
09:57:52 <lambdabot>  Right 1
09:58:18 <Jedai> DrSyzygy: Ambiguous type variable
09:58:32 <DrSyzygy> > Right 2 `mplus` Right 1 :: Either String Integer
09:58:33 <lambdabot>  Right 2
09:58:35 <DrSyzygy> Ah.
09:59:34 <noecksit_> DrSyzygy: oh ok, thats what i was looking for, except having the output be smthing like "Right (2,1)"
09:59:55 <DrSyzygy> noecksit_: You might need to redefine mplus for that.
10:00:13 <Jedai> Just translate Either to []
10:00:17 <DrSyzygy> noecksit_: What would you expect for the result of > Right 1 `mplus` Right 2 `mplus` Right 3 ?
10:00:17 <mauke> :t isAlphaNum
10:00:18 * trofi propses to add '<' to lambdabot via runplugs+old eval for conformance testing :]
10:00:18 <lambdabot> Char -> Bool
10:00:21 <Jedai> then use mplus
10:00:27 <dmhouse> Yay, is lambdabot fixified fully?
10:00:41 <rwbarton> @yow
10:00:41 <lambdabot> Couldn't find fortune file
10:00:44 <maltem> More interestingly, what would the type of mplus be in that case?
10:00:45 <rwbarton> no
10:00:56 <noecksit_> DrSyzygy: true, i should probably have Right [1,2] as output
10:01:16 <rwbarton> > Right [1] `mplus` Right [2] :: Either String [Integer]
10:01:17 <lambdabot>  Right [1]
10:01:35 <dmhouse> ?instance mplus
10:01:36 <lambdabot> Maybe you meant: instances instances-importing
10:01:39 <dmhouse> ?instances mplus
10:01:39 <lambdabot> Couldn't find class `mplus'. Try @instances-importing
10:01:40 <rwbarton> I think there might be a newtype that does what you want...
10:01:43 <dmhouse> ?instances MonadPlus
10:01:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:01:45 <dmhouse> (Oops.)
10:01:50 <DrSyzygy> @src Either mappend
10:01:50 <lambdabot> Source not found. :(
10:01:55 <Jedai> I seriously recommand not to redefine mplus !!
10:02:15 <dmhouse> That instance wouldn't work anyway.
10:02:23 <noecksit_> Jedai: my only problem with this approach is that in the case that something does fail, I can't have the error output carrying through
10:02:25 <Jedai> Either has no Monoid instance
10:02:40 <DrSyzygy> Jedai: Why not build your own type, inheriting anything else you need, and reimplementing the bits you need specific behaviour from?
10:02:43 <dmhouse> Since you'd need a MonadPlus a => ... context (if the type's Either e a) on all the MonadPlus operations.
10:02:53 <dmhouse> It's the same reason that Set can't be made a Monad
10:04:13 <Jedai> noecksit_: Don't use mplus then use your own function, let's say mmadd :: (Monoid a) => Either a String -> Either a String -> Either a String
10:04:15 <dmhouse> (I'm presuming you want Right x `mplus` Right y = Right (x `mplus` y), for instance.)
10:04:15 <lispy> But, there was that Monad instance of Set on someone's blog...it must be real
10:05:23 <mauke> preflex: seen ndmitchell
10:05:23 <preflex>  ndmitchell was last seen on #haskell 12 minutes and 55 seconds ago, saying: but my write speeds suck a lot
10:05:44 <noecksit_> Jedai: so i need to define instance for Monoid?
10:06:10 <Jedai> noecksit_: My assumption was that you would use Right [1] rather, in this scheme
10:06:42 <byorgey_> preflex: seen dmwit
10:06:42 <preflex>  dmwit was last seen on #haskell 4 days, 14 hours, 11 minutes and 53 seconds ago, saying: two strikes
10:06:52 <chrisdone> @pl \x -> x
10:06:52 <lambdabot> id
10:06:53 <Jedai> noecksit_: But I think we would really benefits from a precise description of your need rather than your attempt to find a soution
10:07:22 <chrisdone> (showGismu <$>) . find ((==entry) . fst') <$> lift (gets lojbotGismu)
10:07:25 <chrisdone> how can I write this better
10:08:28 <mauke> :t infd
10:08:30 <mauke> :t find
10:08:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:08:32 <Jedai> chrisdone: Don't use point free ?
10:08:35 <lispy> :t (<$>)
10:08:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:08:59 <rwbarton> chrisdone: what is fst'?
10:09:01 <chrisdone> Jedai: that is one option
10:09:06 <mauke> use fmap instead of <$>
10:09:10 <chrisdone> rwbarton: it takes a 5-tuple
10:09:13 <rwbarton> ah
10:09:15 <noecksit_> Jedai: sure, i have a parsing function that parses a String and returns Either a Right "parsedText" or Left "errorMsg", however the string needs to be split in half and then each half treated as its own string
10:09:17 <chrisdone> mauke: ah, good one
10:09:17 <lispy> > (+1) <$> [1]
10:09:20 <lambdabot>  mueval: Expression did not compile.
10:09:20 <lambdabot> mueval: Time limit exceeded
10:09:36 <thoughtpolice> > 1+1
10:09:38 <lambdabot>  2
10:09:50 <thoughtpolice> hm :/
10:09:57 <rwbarton> > (<$>)
10:10:00 <lambdabot>  mueval: Expression did not compile.
10:10:00 <lambdabot> mueval: Time limit exceeded
10:10:00 <dmhouse> There were some problems with this before.
10:10:08 <dmhouse> :t (<$>)
10:10:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:10:15 <dmhouse> > fmap (+1) [1..3]
10:10:16 <chrisdone> fmap showGismu . find ((==entry) . fst') <$> lift (gets lojbotGismu)
10:10:17 <lambdabot>  [2,3,4]
10:10:17 <chrisdone> slightly better
10:10:18 <Jedai> noecksit_: How does that relates to your problem ?
10:10:37 <trofi> > toUpper.['a'..]
10:10:39 <noecksit_> Jedai: so i would in turn need to rewrite the calls to the parsing functions two times and have two case ... of statements in order for the parsing of two substrings to work
10:10:40 <lambdabot>  mueval: Expression did not compile.
10:10:40 <lambdabot> mueval: Time limit exceeded
10:11:01 <dmhouse> > (+1) . (*2) $ 10
10:11:02 <lambdabot>  21
10:11:03 <trofi> > toUpper `fmap` ['a'..]
10:11:04 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
10:11:25 <chrisdone> > toUpper '\DEL'
10:11:27 <lambdabot>  '\DEL'
10:11:34 <DrSyzygy> > take 10 ['z'..]
10:11:35 <lambdabot>  "z{|}~\DEL\128\129\130\131"
10:11:38 <dmhouse> > let fmap' f x = f . x in fmap' (+1) [1..3]
10:11:40 <DrSyzygy> > take 10 ['Z'..]
10:11:41 <lambdabot>  mueval: Expression did not compile.
10:11:41 <lambdabot> mueval: Time limit exceeded
10:11:41 <lambdabot>  "Z[\\]^_`abc"
10:11:50 <noecksit_> Jedai: so i wanted to do was have for instance "ans = parseThis str1 `mplus` parseThis str2", and it would return Right [firstAns, sndAns]
10:12:05 <rwbarton> noecksit_: liftM (++) ?
10:12:12 <trofi> @let import IO
10:12:13 <lambdabot> Invalid declaration
10:12:18 <dmhouse> > "hello" * 2 -- are all type errors "Expression did not compile"s?
10:12:20 <lambdabot>  mueval: Expression did not compile.
10:12:21 <lambdabot> mueval: Time limit exceeded
10:12:47 <trofi> @let {- hi -}
10:12:48 <lambdabot> Defined.
10:13:01 <gwern> @messages
10:13:02 <lambdabot> Saizan said 2h 30m 28s ago: i realized a general prettyprinter wouldn't help on getting the information we want out of InterpreterError, but i've sent two patches for mueval to print compiler errors
10:13:02 <lambdabot> nicely
10:13:02 <trofi> @let {- break?
10:13:02 <lambdabot>  Unterminated nested comment
10:13:17 <Jedai> noecksit_: mapM parseThis [str1, str2]
10:13:29 <Twey> Ahahahahaha
10:13:38 <Twey> I just used StateT successfully!
10:13:43 * Twey beams with pride.
10:14:07 <Jedai> noecksit_: It will do what you want
10:14:14 <lispy> So what was wrong with (+1) <$> [1], isn't [a] a functor instance?
10:14:25 <lispy> :t ((+1) <$>)
10:14:26 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
10:14:27 <rwbarton> > const 1 (<$>)
10:14:29 <lambdabot>  mueval: Expression did not compile.
10:14:30 <lambdabot> mueval: Time limit exceeded
10:14:37 <lispy> :t ((+1) <$>) [1]
10:14:37 <dmhouse> B0rkage.
10:14:38 <lambdabot> forall a. (Num a) => [a]
10:14:41 <lispy> > ((+1) <$>) [1]
10:14:44 <lambdabot>  mueval: Expression did not compile.
10:14:44 <lambdabot> mueval: Time limit exceeded
10:14:46 <chrisdone> it's fine it's just mueval
10:14:48 <rwbarton> seems :t knows about <$> but not >
10:14:56 <lispy> oh i see
10:15:00 <dmhouse> Yes, > was recently swapped to mueval.
10:15:11 <rwbarton> :t unsafePerformIO
10:15:12 <dmhouse> And not everything works yet.
10:15:47 <chrisdone> not quite Caleskell, instead “Caelskels”
10:15:54 <trofi> @. run google lambdabot exploit
10:15:58 <lambdabot>  mueval: Expression did not compile.
10:15:58 <lambdabot> mueval: Time limit exceeded
10:16:24 <noecksit_> Jedai: yes but that will have the Either type inside the List type, as in [Either], id like it to be Either [], so that when I have a case .. of expression I can match it against the Either data type
10:16:41 <noecksit_> Jedai: i dont know if thats possible however
10:16:52 <dmhouse> > runReader (runStateT (do x <- get; y <- lift ask; put (x-y); return (x+y)) 1) 3
10:16:54 <lambdabot>  (4,-2)
10:17:14 <Jedai> > mapM return [1, 2] :: Either String Int
10:17:17 <lambdabot>  mueval: Expression did not compile.
10:17:18 <lambdabot> mueval: Time limit exceeded
10:17:26 <dmhouse> Polymorphic results, maybe?
10:17:42 <dmhouse> Oh, that was a type error.
10:17:52 <Jedai> > mapM return [1, 2] :: Either String [Int]
10:17:53 <lambdabot>  Right [1,2]
10:18:12 <Jedai> noecksit_: As you see, you're wrong, the Either is outside the []
10:18:20 <rwbarton> noecksit_: doesn't liftM2 (++) do what you want?
10:18:22 <Jedai> :type mapM
10:18:33 <Jedai> :t mapM
10:18:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:18:41 <noecksit_> Jedai: oh, i guess i am, thanks for correcting me
10:19:09 <dmhouse> > map return [1,2] :: [Either String Int] -- that's what the 'M' in mapM does
10:19:11 <lambdabot>  mueval: Expression did not compile.
10:19:12 <lambdabot> mueval: Time limit exceeded
10:19:43 <dmhouse> Prelude Control.Monad.Error> map return [1,2] :: [Either String Int]
10:19:43 <dmhouse> [Right 1,Right 2]
10:22:29 <chrisdone> :hoogle (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
10:22:35 <gwern> oh noes, have people come up with more things > evaluates but mueval won't?
10:22:44 * lispy nods
10:23:00 <lispy> you build it, we break it
10:23:43 * gwern will need examples then
10:23:51 <gwern> @tell Saizan I've applied & pushed your patches
10:23:51 <lambdabot> Consider it noted.
10:23:57 <dmhouse> > (+1) <$> [1..3]
10:24:00 <lambdabot>  mueval: Expression did not compile.
10:24:00 <lambdabot> mueval: Time limit exceeded
10:24:14 <lispy> :t (+1) <$> [1..3]
10:24:15 <lambdabot> forall a. (Enum a, Num a) => [a]
10:24:35 <lispy> > (+1) `fmap` [1..3]
10:24:36 <dmhouse> Prelude Control.Applicative> (+1) <$> [1..3]
10:24:36 <dmhouse> [2,3,4]
10:24:37 <lambdabot>  [2,3,4]
10:24:45 <lispy> So, why would I prefer (<$>) ?
10:25:00 <gwern> hm. interesting example
10:25:31 <dmhouse> lispy: if you're writing stuff with Applicative, it's more natural.
10:25:35 <gwern> ah, do we not impiort Control.Applicative?
10:25:36 * gwern checks
10:26:05 <dmhouse> gwern: can we have better errors, pwetty please? If not mueval seems more of a regression...
10:26:06 <gwern> ah, yes, we don't
10:26:33 <gwern> dmhouse: I just pushed two Saizan patches which try just that
10:26:44 <dmhouse> gwern: great!
10:26:48 <dmhouse> Yay for the #haskell community.
10:27:39 <gwern> ok, where there any others besides that applicative one?
10:27:59 <gwern> *were
10:28:26 <dmhouse> gwern: yep, one more
10:28:35 <bos31337> oh, wow.
10:28:36 <dmhouse> > map return [1,2] :: [Either String Int]
10:28:37 <lambdabot>  [Right 1,Right 2]
10:28:41 <dmhouse> Oh, err.
10:28:52 <gwern> ?
10:28:56 <dmhouse> That definitely didn't work before.
10:29:06 <dmhouse> <dmhouse> > map return [1,2] :: [Either String Int] -- that's what the 'M' in
10:29:07 <dmhouse>     mapM does
10:29:07 <dmhouse> <lambdabot>  mueval: Expression did not compile.  [18:20]
10:29:07 <dmhouse> <lambdabot> mueval: Time limit exceeded
10:29:16 <gwern> well, I'll add it as a test anyway, I ugess. just in case
10:29:21 <mauke> > 1 -- 2
10:29:24 <rwbarton> Maybe it didn't like the comment :P
10:29:24 <lambdabot>  mueval: Expression did not compile.
10:29:25 <lambdabot> mueval: Time limit exceeded
10:29:28 <dmhouse> Yeah, I was about to try that.
10:29:29 <mauke> whee
10:29:46 <lispy> wht is mueval?
10:29:48 <rwbarton> > 1 {- 2 -}
10:29:50 <lambdabot>  1
10:29:50 <gwern> comments are a problem?
10:29:53 <lispy> how is it different from the old eval?
10:29:54 <gwern> > True -- checking
10:29:57 <lambdabot>  mueval: Expression did not compile.
10:29:57 <lambdabot> mueval: Time limit exceeded
10:30:12 <gwern> > True {- checking -}
10:30:13 <bos31337> oh, wow. i just picked up the first PDF of the book. it's 536 pages already, there's no index yet, and we have a chapter yet to add.
10:30:13 <lambdabot>  True
10:30:16 <gwern> > True
10:30:17 <lambdabot>  True
10:30:33 <lispy> bos31337: cool, bang for my buck :)
10:31:00 <gwern> > 1 {- foo -}
10:31:01 <lambdabot>  1
10:31:11 <gwern> > True {- foo -}
10:31:12 <lambdabot>  True
10:31:24 <gwern> > True -- foo
10:31:27 <lambdabot>  mueval: Expression did not compile.
10:31:27 <lambdabot> mueval: Time limit exceeded
10:31:51 <gwern> hm. that is interesting
10:31:51 <dmhouse> I think line comments might be an issue ;)
10:32:01 <Twey> If I have a func :: StateT Foo IO (), and inside that function I wish to perform forkIO on something else that's also :: StateT Foo IO (), how do I do the necessary lifting?
10:32:08 <gwern> works in ghci. I wonder what it does differently?
10:32:10 <trofi> wrapping something around input line ?
10:32:30 <trofi> smth1 ++ expr ++ "\n" ++ smth1
10:32:42 <gwern> possibly. the ghci code is hard t read
10:32:59 <dmhouse> Twey: x <- get; liftIO (runStateT foo x), maybe?
10:33:04 <lispy> Hey, any chance the `it' bug is back?
10:33:18 <lispy> The one were you can have self-referential expressions?
10:33:19 <mauke> > it
10:33:21 <lambdabot>  mueval: Expression did not compile.
10:33:22 <lambdabot> mueval: Time limit exceeded
10:33:23 <dons> bos: huh.
10:33:28 <Twey> dmhouse: Oho, thanks
10:33:44 <bos> dons: yeah, wow. you can check the PDF out of SVN now.
10:33:58 <gwern> lispy: oh no. the it bug should be quite impossible. each > is a separate invocation of mueval; any persistent state has to go into L.hs
10:34:12 <lispy> gwern: it's not a persistent state bug
10:34:24 <lispy> gwern: it has to do with the way ghci does the evaluation
10:35:05 <Twey> dmhouse: Yep, perfect!  (well, evalStateT rather than runStateT, but perfect enough :))
10:35:11 <lispy> gwern: internally it gives the expression a name, at least with old lambdabot that was the case.  So, at some point people started playing with that internal name and a scheme was developed to make it unpredictable
10:36:03 <dmhouse> Twey: get >>= liftIO . evalStateT foo if you want a bit of abbreviation.
10:36:48 * Twey nodnods.
10:37:35 <gwern> lispy: oh. well, I haven't tested that, but I do have a few non-terminating examples in my testsuite
10:37:52 <dons> ooh. big native codegen patch on its way to ghc.
10:38:20 <lispy> dons: oh? might fix some of the things that required -fvia-C lately?
10:38:29 <dons> fingers crossed.
10:39:09 <samphippen> how do i generate permutations in haskell perms("ab") = ["aa","ab","ba","bb"]
10:39:09 <lispy> is the C and native code generated from the same representation?
10:39:22 <lispy> > permutations "ab"
10:39:25 <lambdabot>  mueval: Expression did not compile.
10:39:26 <lambdabot> mueval: Time limit exceeded
10:39:31 <lispy> ?hoogle permutations
10:39:31 <rwbarton> > sequence ["ab", "ab"]
10:39:32 <lambdabot> No results found
10:39:32 <lambdabot>  ["aa","ab","ba","bb"]
10:39:47 <rwbarton> (those aren't permutations if you allow repeated letters)
10:39:59 <mauke> > replicateM 2 "ab"
10:40:00 <lambdabot>  ["aa","ab","ba","bb"]
10:40:18 <mauke> > replicateM 3 "ab"
10:40:19 <lambdabot>  ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
10:40:47 <samphippen> mauke, using ghci i dont get results for replicateM 2 "ab"
10:40:54 <dmhouse> samphippen: :m Control.Monad
10:41:03 <mauke> samphippen: I do
10:41:05 <mauke> it says <interactive>:1:0: Not in scope: `replicateM'
10:41:12 <trofi> @src replicateM
10:41:13 <lambdabot> replicateM n x = sequence (replicate n x)
10:41:15 <samphippen> i get that result
10:41:15 <gwern> samphippen: > loads a bunch of modules by default
10:41:18 <gwern> @hoogle replicateM
10:41:18 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
10:41:18 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
10:43:50 <noecksit_> how would you be able to define a data type on ghci's prompt? let data MyType = MyType Int doesnt work
10:44:18 <gwern> can you?
10:44:20 <dmhouse> noecksit_: you can't.
10:44:30 <dmhouse> noecksit_: write a module and import it.
10:44:40 <lilac> it'd be really nice if you could, though ;-)
10:45:45 <noecksit_> dmhouse: hmm, allright
10:46:08 * lilac likes the idea of 'let data X = X Int in ...'
10:46:19 <Twey> @pl \x -> \y -> (x, y)
10:46:19 <lambdabot> (,)
10:46:52 <lilac> @pl \(x,y) -> (y,x)
10:46:52 <lambdabot> uncurry (flip (,))
10:47:35 <samphippen> does haskell have an md5 feature that maintains hashstate?
10:49:01 <Twey> > let a = const 5; b = const 3 in (do {x <- a; y <- b; return (x, y)})) 'foo'
10:49:02 <lambdabot> Unbalanced parentheses
10:49:14 <Twey> > let a = const 5; b = const 3 in (do {x <- a; y <- b; return (x, y)}) 'foo'
10:49:14 <lambdabot>  Improperly terminated character constant at "'foo'" (column 70)
10:49:18 <Twey> Gah
10:49:24 * Twey switches to GHCi.
10:49:36 <dons> samphippen: there's lots of md5 libs.
10:49:37 <dmhouse> Twey: erm, 'foo' is illegal in GHCi too.
10:49:41 <dons> samphippen: look on hackage.haskell.org
10:49:43 <mauke> > let a = const 5; b = const 3 in (do {x <- a; y <- b; return (x, y)}) "foo"
10:49:44 <lambdabot>  (5,3)
10:49:49 <Twey> Yeah, I know, dmhouse
10:49:55 <Twey> Just thought I'd stop spamming :-P
10:50:04 <dmhouse> Okay.
10:50:07 <gwern> privmsg
10:50:13 <lispy> having ?let-data might be more appropriate (just easier to implement really)
10:50:21 <Twey> @undo do { x <- a; y <- b; return (x, y) }
10:50:21 <lambdabot> a >>= \ x -> b >>= \ y -> return (x, y)
10:50:24 * dmhouse has F6 pop up a GHCi window to remove the temptation.
10:50:31 * Twey chuckles.
10:50:34 <Twey> Huh
10:50:37 <mwc> dmhouse: heh
10:50:45 <Twey> I was almost sure there was some incredibly neat way to do that
10:50:46 <lispy> ?. pl undo \x y -> do { x <- a; y <- b; return (x,y) }
10:50:47 <lambdabot> const (const (a >> join (,) `fmap` b))
10:50:59 <Twey> Hmnhmnhmn
10:51:00 <dmhouse> ?type liftM2 (,)
10:51:01 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
10:51:18 <dmhouse> (global-set-key (kbd "<f6>") 'run-haskell) ; In case anyone cares
10:51:22 <lispy> ?. pl undo \a b -> do { x <- a; y <- b; return (x,y) }
10:51:22 <lambdabot> liftM2 (,)
10:51:25 <lispy> sorry, I swapped them
10:51:45 <romildo> Hi.
10:52:15 <lispy> Howdy romildo
10:52:55 <romildo> I have haskell-mode installed on my system and I use it edit Haskell programs. The problem is that TeX files are being openning by in haskell-mode, I do not know why? Has anybody seen this?
10:53:37 <dmhouse> romildo: do (mapc 'print auto-mode-alist) in a lisp-interaction-mode buffer and pastebin the output
10:53:46 <lispy> dons: we should have "hackage upload days" being events where people go through hackage and make sure the packages are up to date with the latest release from each project and we encourage people who haven't used hackage yet by answer lets of newbie questions about uploading
10:54:23 <mwc> romildo: it probably has something to do with literate haskell support
10:54:51 <lispy> dons: so, it would be cool if we could give user feedback on hackage and on those days people try to update that feedback...like people just download things and try it out
10:55:13 <lispy> dons: the mozilla people do this with FF plugins sometimes
10:55:21 <dmhouse> Re hackage, I calculated this earlier, it was pretty interesting: http://www.reddit.com/comments/6x141/solving_the_diamond_dependency_problem/c053vua?context=3
10:55:23 <lambdabot> Title: dmhouse comments on Solving the diamond dependency problem, http://tinyurl.com/6gh735
10:55:27 <lispy> dons: they hold games to see who can find the most plugins with bugs and stuff like tat
10:55:28 <romildo> dmhouse: I think I have found the cause: I had added (add-to-list 'auto-mode-alist '("\.x$"  . haskell-mode)) to my ~/.emacs file, in order to open Alex input files in haskell-mode. Commenting it out solves the problem.
10:55:57 <dmhouse> romildo: replacing "\.x$" with "\\.x$" would also work
10:56:24 <mauke> heh
10:57:09 <mc__> What would be the best way to recurse over a 3x3 "Array" which is no array at all but a Map with a (Int,Int) Tuple as key?
10:57:13 <romildo> dmhouse, yes, now I see I have missed one backslash. Thanks for pointing it out.
10:57:45 <dmhouse> mc__: by using map?
10:57:58 <lispy> Does Map support fmap or thing?
10:58:22 <lispy> Maybe i'm wrong but Map seems like a functor to me
10:58:32 <lispy> ?instances Functor
10:58:33 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:58:34 <rwbarton> > fmap (+1) $ M.fromList [("a", 1), ("b", 2)]
10:58:37 <lambdabot>  mueval: Expression did not compile.
10:58:37 <lambdabot> mueval: Time limit exceeded
10:59:07 <dmhouse> > Data.Map.map (+1) $ M.fromList [("a", 1), ("b", 2)]
10:59:10 <lambdabot>  mueval: Expression did not compile.
10:59:10 <lambdabot> mueval: Time limit exceeded
10:59:51 <gwern> currently can't use anything which does qualified imports
10:59:53 <rwbarton> mc__: anyways, even if Map isn't declared as a Functor, there is Data.Map.map
11:00:23 <gwern> and I had to disable stuff like Data.Map.map because that lets in Foreign.unsafePerformIO
11:00:45 <dmhouse> Prelude Data.Map> Data.Map.map (+1) $ Data.Map.fromList [("a", 1), ("b", 2)]
11:00:45 <dmhouse> fromList [("a",2),("b",3)]
11:01:03 <dmhouse> (I guess you don't actually need the qualification in front of fromList.)
11:01:07 <mc__> rwbarton: map is not suited for my case
11:01:18 <sampointon> okay, I need a sanity check: `elem name $ Map.keys vars' is True, but `Map.member name vars' is False
11:01:19 <lispy> gwern: oh really?  Why does it involve that?
11:01:22 <mc__> i also have to do something for the not yet existent values
11:01:40 <mc__> the Map is representing a board of a tic tac toe game
11:02:05 <dmhouse> mc__: I'd initialise your Map with all the keys there, with some default value.
11:02:16 <rwbarton> How about, data Player = X | O ; type Board = Map (Int, Int) (Maybe Player)
11:02:20 <dmhouse> Like data Square = Empty | Cross | Ecks
11:02:20 <gwern> lispy: because, while yuo would think that a fully qualified name would only let you use functions from modules you've specifically imported, such as the Prelude, it turns out that the GHC API will let the user fully-qualified-import any function from any package!
11:02:40 <dmhouse> Erm Ecks | Oh
11:02:58 <rwbarton> Nought | Cross
11:02:59 <dmhouse> gwern: that's true in normal Haskell modules.
11:03:06 <gwern> lispy: so even if I take the precauation of doing 'reset; loadModules ["Prelude"] -- we only load Prelude to be safe', the user can merrily go 'Foreign.unsafePerformIO $ writeFile....'
11:03:28 <dmhouse> rwbarton: that's the one!
11:03:33 <lispy> gwern: wow, but why does Data.Map include unsafePerformIO anyway?
11:03:34 <gwern> dmhouse: no. you would have to import Foreign or import System.IO.Unsafe before you could do Foreign.unsafePerformIO.
11:04:10 <gwern> it doesn't, but I can't blacklist each and every function which might be unsafe and which the user could fully-qualify into scope
11:04:30 <gwern> so, I use the Hint feature which breaks fully qualified imports - all of them
11:04:36 <dmhouse> gwern: could you import Data.Map qualified as M?
11:04:48 <dmhouse> > M.fromList (zip "abc" [1..3])
11:04:51 <lambdabot>  mueval: Expression did not compile.
11:04:51 <lambdabot> mueval: Time limit exceeded
11:04:53 <gwern> fortunately, that should no longer be necessary in 6.10
11:04:56 <gwern> I hope
11:05:18 <lilac> data Square = Empyt | NothingHere | NoContents | Nil | Cross | Ecks | X | Player2 | Nought | O | Zero | FileNotFound
11:05:30 <gwern> dmhouse: no. :( I've tried and asked around, but apparently neither the GHC API nor ghci can do rename imports
11:06:03 <gwern> I was a little surprised, but I guess no one has asked for it
11:06:07 <rwbarton> gwern: but ghci can load a file which does a renamed qualified import.  Does that help?
11:06:23 * gwern notes that the GHC API doesn't seem to get used much, like the rlimits binding
11:06:25 <dmhouse> lilac: reminds me of http://thedailywtf.com/Articles/Are-You-Sure.aspx
11:06:27 <lambdabot> Title: Are You Sure? - The Daily WTF
11:07:17 <Arnar> hey guys..
11:07:39 <Arnar> what's the best reading material for exceptions, esp. custom (dynamic?) ones?
11:07:52 <lilac> dmhouse: an homage to that and this: http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx
11:07:53 <lambdabot> Title: What Is Truth? - The Daily WTF
11:07:55 <gwern> rwbarton: it might, but I haven't figured out how
11:09:17 <lilac> hehe, searching for FileNotFound using thedailywtf.com's search box finds 0 results. wtf? :)
11:10:00 <mc__> dmhouse: whats the best way to initialise the map?
11:10:01 <lilac> hmm, just needs javascript enabled ;-)
11:10:20 <Philippa> gwern: I think a lot of potential GHC API clients're waiting for a helper lib or two
11:10:26 <rwbarton> gwern: OK, here is an ugly solution: Create M.hs containing "module M (module Data.Map) where\nimport Data.Map" and then import M
11:10:44 <gwern> Philippa: yeah, I've pinned my hopes on Hint
11:10:49 <gwern> it's pretty good
11:11:14 <bos> holy crap. dons just noticed that about 1/4 of the chapters we've written didn't make it into that PDF file. so the final book looks like it will be over 700 pages in length.
11:11:52 <Philippa> heh
11:11:55 <mc__> bos: the real world haskell book?
11:12:00 <gwern> quite an error
11:12:04 <bos> mc__: yes
11:12:52 <dmhouse> > let coords = [(x,y) | x <- [1..3], y <- [1..3]] in zip coords Nothing
11:12:54 <lambdabot>  mueval: Expression did not compile.
11:12:55 <lambdabot> mueval: Time limit exceeded
11:13:01 <erikc> hrm, what function is used to do a 'binary read', e.g. read "\NUL\NUL\NUL\NUL" :: Word32 gives me a parse error
11:13:10 <dmhouse> > let coords = [(x,y) | x <- [1..3], y <- [1..3]] in zip coords (repeat Nothing)
11:13:11 <lambdabot>  [((1,1),Nothing),((1,2),Nothing),((1,3),Nothing),((2,1),Nothing),((2,2),Noth...
11:13:21 <mauke> erikc: something from Data.Binary, usually
11:13:27 <dmhouse> mc__: the above with Nothing replaced with your suitable placeholder.
11:13:39 <dmhouse> mc__: and of course fromList in from of that.
11:13:53 <mc__> dmhouse: alright, thanks a lot!
11:14:30 * BMeph found http://thedailywtf.com/Articles/Stand_Back,_I_0x27_m_Educated!_.aspx hilarious
11:14:35 <lambdabot> Title: Stand Back, I'm Educated! - The Daily WTF, http://tinyurl.com/5qdr3c
11:14:59 <dons> so TAPL is 500 pages, and Cormen is 1000.
11:15:08 <dons> and we'll land somewhere between those two.
11:15:39 <crutcher> hey, I've been messing arround with Monads, and I'm wondering if this statement is provable via the monad laws:
11:15:44 <crutcher> ( xs >= return . k ) >>= id  ==  xs >>= k
11:16:04 <rwbarton> @redo ( xs >= return . k ) >>= id
11:16:04 <lambdabot> do { a <- (xs >= return . k); id a}
11:16:17 <rwbarton> Hmm, that wasn't very useful
11:16:32 <gwern> rwbarton: that's an interesting suggestion
11:16:33 <rwbarton> @redo ( xs >>= return . k ) >>= id
11:16:34 <lambdabot> do { a <- (do { a <- xs; (return . k) a}); id a}
11:16:38 <crutcher> or is it just that most Monads we use satisfy that.
11:16:41 <gwern> and it fails in an interesting way
11:16:46 <rwbarton> gwern: :)
11:16:48 <gwern>  mueval: UnknownError "GHC reported errors and also gave a result!"
11:17:23 <dons> bos, amazon sez "Paperback: 300 pages" . mwhaha
11:17:25 <dons> surprise!
11:17:37 <dolio> (xs >>= return . k) >>= id === join (fmap k xs) === xs >>= k
11:18:06 <mc__> netsplits are always amazing
11:18:19 <crutcher> I'm trying to derive  join ( fmap k xs )  ==  xs >>= k from the monad laws, the fmap law: fmap f xs  ==  xs >>= return . f, and the join def:  join x  ==  x >>= id
11:18:37 <gwern> dons: well, I have an idea - print on *both* sides of the page! that way you can stuff 600 pages into 300
11:18:48 <crutcher> dolio: yes, that's what I'm trying to prove.
11:19:06 * gwern is a genius. I wonder why nobody's thought of that before?
11:19:38 <SamB> gwern: that doesn't actually reduce the page count -- that merely makes the sheet count about half of the page count
11:19:55 <GremlinHunter> Perhaps just rewrite the code to be as short as possible :)
11:19:57 <gwern> SamB: shh! the sheeple won't realize that
11:19:57 <lilac> gwern: or use bigger pages
11:19:58 <mc__> It is genius though
11:20:18 <gwern> lilac: hm. a nice folio edition?
11:20:24 <crutcher> dolio: do you know where I could find a proof?
11:20:29 <crutcher> or a derivation?
11:20:31 <dolio> Nope.
11:20:36 <lilac> gwern: hold on, i know i've got an A0 printer around here somewhere
11:20:45 <rwbarton> crutcher: it must just use the associative law
11:21:15 <SamB> lilac: but does it print on BOTH SIDES of the page?
11:21:27 <dolio> crutcher: Yeah, it's the associative law.
11:21:35 <gwern> lilac: ah, we'll just farm it out to English pirates
11:21:36 <gwern> 'Real Wurld Hafkell; being an account of the moft Perfect Tongue'
11:22:05 <SamB> gwern: why do the esses have crossbars?
11:22:09 <rwbarton> (x >>= return . k) >>= id  =  x >>= (\y -> return (k y) >>= id)  =  x >>= (\y -> k y)  =  x >>= k
11:22:13 <dolio> crutcher: http://hpaste.org/9811
11:22:35 <lilac> (xs >>= return . k) >>= id === xs >>= (\x -> (return . k) x >>= id) === xs >>= \x -> return (k x) >>= id) === xs >>= \x -> k x === xs >>= k
11:22:37 <dolio> I guess that uses left identity, too.
11:22:58 <crutcher> thanks :)
11:23:05 <GremlinHunter> You could make the first chapter on text compression and then print the rest in compressed form
11:24:01 <sw17ch> @seen dcoutts
11:24:02 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #darcs, #ghc and #haskell. I last heard dcoutts speak 6h 43m 26s ago.
11:24:15 <dons> http://www.reddit.com/r/programming/comments/6x7r8/haskell_weekly_news_hardware_posix_realtime/ byorgey++
11:24:20 <lambdabot> Title: Haskell Weekly News: Hardware, Posix Realtime, Wav/OGG, XCB and Jobs! : programm ..., http://tinyurl.com/6m68a2
11:24:53 <dcoutts_> sw17ch: mm?
11:25:17 <dons> dcoutts_: i'd love hackage pages to link to their distro packages, per-platform too.
11:25:25 <dons> so we can track what's been natively packaged and what's not.
11:25:40 <dcoutts_> dons: yeah, would be good.
11:25:58 <MarcWeber> Anyone familiar with polyparse?
11:25:59 <dcoutts_> dons: and fully automatable I think
11:26:39 <MarcWeber> HaXmL fails parsing this snippet. The 3rd parser (line 47) is not even tried http://rafb.net/p/9mScd826.html
11:26:44 <dcoutts_> dons: the distro packagers just need to PUT a link whenever they add a package.
11:26:44 <lambdabot> Title: Nopaste - No description
11:26:54 <dons> dcoutts_: right.
11:27:01 <dons> little green tick boxes for what are provided.
11:27:08 <noecksit_> @src zipWithM
11:27:08 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
11:27:24 <dcoutts_> dons: like PUT to http://hackage.h.o/packages/foobar-1.0/distro/$distro
11:27:48 <dcoutts_> dons: and that info would be combined into the per-package page
11:28:00 <noecksit_> could i define my own function, like zipWithM5, that would take five lists as arguments rather than two?
11:28:28 <chrisdone> noecksit_: use a list comprehension?
11:29:30 <noecksit_> chrisdone: list comprehension? i need the output as a monad though
11:29:54 <chrisdone> well, one could use sequence on the comprehension
11:30:22 <rwbarton> @pl \f a b c d e -> sequence (zipWith5 f a b c d e)
11:30:22 <lambdabot> (((((sequence .) .) .) .) .) . zipWith5
11:30:54 <mnislaih> are there any HTTP libraries apart from curl that can handle gzip encoding?
11:31:09 <lilac> MarcWeber: don't know polyparse, but if it's anything like parsec, it's probably committing to one of the choices too early
11:31:45 <MarcWeber> lilac you are totally right.. So I'll try a second time replacing all commits by id..
11:31:50 <noecksit_> chrisdone: oh, or do you mean [ liftM3 Test a b c   | a <- ax, b <- bx, c <- cx]?
11:32:55 <chrisdone> sequence [ putStrLn $ show (x,y,z) | x <- [1..3], y <- [1..3], z <- [1..3] ]
11:33:46 <chrisdone> :t [ putStrLn $ show (x,y,z) | x <- [1..3], y <- [1..3], z <- [1..3] ]
11:33:47 <lambdabot> [IO ()]
11:33:48 <chrisdone> :t sequence
11:33:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:34:33 <lilac> MarcWeber: when parsec consumes any input, it commits to that alternative (by default). does the third alternative also start with something matching "tok "41" TokBraOpen" ?
11:37:14 <MarcWeber> lilac: That's the difference between parsec and polyparse.. Using parsec you need to tell the parser to not commit by try $. Polyarse does this by default and you have to commit explicitely
11:37:40 <mauke> haha
11:39:14 <BMeph> MarcWeber: Heh-heh, you said "Polyarse". :)
11:41:05 <noecksit_> chrisdone: thanks i think that does it for me
11:41:38 * MarcWeber hides
11:41:39 <lgas> Hi all.  I'm new to haskell and trying to do something that seems like it should be pretty simple but it's giving me quite a bit of trouble.  Basically I'm just trying to write a function to read a file into a string.  It seems like this should work:bar = do s <- readFile "level2.data"; s
11:41:55 <BMeph> Okay, so freenet does splits. How about a backflip? ;p
11:41:57 <mauke> bar = readFile "level2.data"
11:42:03 <lgas> but it gives me:
11:42:04 <lgas> t.hs:7:38:
11:42:04 <lgas>     Couldn't match expected type `IO' against inferred type `[]'
11:42:04 <lgas>       Expected type: IO t
11:42:04 <lgas>       Inferred type: String
11:42:04 <lgas>     In the expression: s
11:42:06 <lgas>     In the expression:
11:42:08 <lgas>         do s <- readFile "level2.data"
11:42:10 <lgas>            s
11:42:34 <Lemmih> lgas: 's' -> 'return s'
11:42:54 <sw17ch> or just the readFile line
11:42:55 <dmhouse> lgas: s is just a String, so you can't put it directly into an IO do-block.
11:43:12 <dmhouse> lgas: so you need to return it, which turns a pure value into a trivial monadic action yielding that value.
11:43:17 <sw17ch> do { f <- readFile "name.txt"; putStrLn f }
11:43:19 <lgas> with return s I get a different error:
11:43:19 <lgas> t.hs:11:16:
11:43:20 <lgas>     Couldn't match expected type `String'
11:43:20 <lgas>            against inferred type `IO String'
11:43:20 <lgas>     In the first argument of `putStrLn', namely `foo'
11:43:20 <lgas>     In the expression: putStrLn foo
11:43:22 <lgas>     In the definition of `main': main = putStrLn foo
11:43:34 <dmhouse> lgas: pastebin everything.
11:43:39 <MarcWeber> lgas: You are new to pastebins as well ? :-)
11:43:42 <dmhouse> Also don't paste so many lines into the channle.
11:43:43 <sw17ch> bar >>= putStrLn
11:43:46 <lgas> sorry
11:43:59 <Lemmih> lgas: do str <- foo; putStrLn str
11:44:15 <Saizan_> ?seen gwern
11:44:16 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 22m 39s ago.
11:44:20 <noecksit_> chrisdone: actually, i was wrong, it tries every combination of the items in the list
11:44:32 <noecksit_> @src zipWithM
11:44:33 <trofi> @do bar >>= putStrLn
11:44:33 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
11:44:33 <lambdabot> bar >>= putStrLn not available
11:44:36 <dmhouse> lgas: alternatively in the definition of bar you could just have bar = readFile "foo", since readFile is itself an IO action yielding the contents of the file "foo". I.e. do { x <- a; return x } is identical to just a (in fact this is one of the monad laws).
11:44:46 <trofi> @redo bar >>= putStrLn
11:44:46 <lambdabot> do { a <- bar; putStrLn a}
11:45:52 <sw17ch> lgas, i'm guessing you're not grasping the difference between actions and functions yet
11:46:43 <lgas> yeah I have read a bit about the IO monad but yes I definitely don't fully grok the difference between actions and functions
11:47:24 <mauke> that's a bit like the difference between arrays and pointers in C
11:47:31 <trofi> there is no difference until you want to execute them
11:47:47 <mauke> i.e. they're not even remotely similar
11:49:01 <lgas> :)
11:49:04 <Cale> lgas: A function essentially assigns to each element of one type, an element of another.
11:49:48 <bos> ok, the rebuilt PDF of the book is 666 pages, now that i've fixed the missing chapters.
11:49:52 <lgas> I get that.  And I get that actions are executed sequentially...
11:50:06 <Cale> An action of type (IO t) on the other hand, is a description of some things to do (some input and output) after which a value of type t will be produced.
11:50:35 <Cale> Simply evaluating an IO action will not cause those things to happen. It's just a description of them.
11:50:47 <sanity> anyone know of a higher-order function, similar to fold - but rather than operating over a list, it operates over a directed graph?
11:51:01 <sanity> i've created one, i'd just like to know if it has a name
11:51:06 <Cale> sanity: You might be interested in FGL.
11:51:32 <lgas> so readFile has a type of "IO String" -- how does that fit in with (IO t) ?
11:51:36 <sanity> Cale: the Fruit Growers League?
11:52:12 <Cale> lgas: If executed, it does some stuff before producing a String
11:52:32 <Cale> sanity: Functional graph library, I'll get you a link :)
11:52:41 <sanity> Cale: its ok, i found it :-)
11:53:09 <rwbarton> lgas: Note, it's  readFile "foo"  that has type IO String
11:53:28 <lgas> and this is an action that causes it to be executed and the string that it produces to be stored in the variable "s", which will be of type "String", right? s <- readFile "foo"
11:53:32 <Cale> Oh, that too.
11:53:42 <Cale> readFile :: FileName -> IO String
11:54:02 <lgas> I see.
11:54:19 <Cale> So it's a function from FileNames (which are basically strings) to actions which if executed will read from that file and give the contents
11:54:39 <Cale> s <- readFile "foo" is something which might occur in a do-block, defining another IO action
11:55:07 <Cale> In that case, when the action is executed, readFile "foo" will be executed, and the result captured in s
11:55:11 <Cale> (as a String)
11:55:20 <lgas> in that context though, the "<-" is basically saying "execute this action"?
11:55:35 <lgas> or am I off base on that
11:55:35 <Cale> yeah
11:55:38 <FunctorSalad> is it possible to declare a context once for a whole file or block of code?
11:55:48 <Cale> FunctorSalad: context?
11:55:48 <FunctorSalad> (for multiple declarations)
11:55:59 <Cale> FunctorSalad: As in a typeclass context?
11:56:01 <FunctorSalad> the thing before "=>", maybe it's the wrong word
11:56:04 <FunctorSalad> yes
11:56:08 <Cale> No, that's fine :)
11:56:10 <Cale> hmm
11:56:18 <lgas> is the return value of a do-block the last expression in the do block?
11:56:22 <Cale> You can create a class which implies the others...
11:56:44 <Cale> lgas: The result of executing the last expression.
11:57:16 <Cale> lgas: return :: a -> IO a  simply creates an action which when executed does nothing before returning the specified value
11:57:19 <FunctorSalad> Cale: thanks... I've had something like that in mind but didn't think of fundeps
11:57:41 <Cale> FunctorSalad: Well, I'm not sure if you'll need fundeps...
11:57:49 <Cale> Just superclasses :)
11:58:09 <Cale> class (Foo a, Bar a, Baz a) => FooBarBaz a where {- empty -}
11:58:22 <Cale> and then define empty instances.
11:59:40 <FunctorSalad> shouldn't I do something like class (Foo a b c d e, Bar a x y) => FooBar a b c d e x y box | box -> a b c d e x y ?
11:59:56 <FunctorSalad> (the issue is that I have so many type variables)
12:00:07 <lgas> so, in my original example where I have this:  bar = do s <- readFile "level2.data"; s    it seems like it should execute the readFile action storing a String in s, then return that string as the value of the function bar... but instead I get the compilation error about Expected type IO t and Inferred type String.  I feel like I'm still missing a piece.
12:00:34 <mauke> lgas: you can't return a string there
12:00:39 <rwbarton> lgas: bar is again an action
12:00:39 <Cale> FunctorSalad: oh, perhaps
12:00:56 <FunctorSalad> hmm wait, that wouldn't get rid of the type variables, would it?
12:01:02 <Cale> lgas: Each line of a do-block *must* be an action
12:01:07 <mauke> lgas: all statements in a do block must be in the same monad
12:01:18 <Cale> lgas: (except "let ...")
12:01:24 <mauke> readFile "..." is in IO, s is in []  (because it's a list of characters)
12:01:33 <GremlinHunter> Perhaps it would be better to think of do blocks making a new action?
12:01:40 <Cale> Yes, that's what they do :)
12:01:56 <Cale> do-blocks basically concatenate lots of actions together into larger ones
12:02:06 <Cale> If you write
12:02:23 <Cale> bar = do s <- readFile "level2.data"; return s
12:02:26 <Cale> that is the same as
12:02:32 <Cale> bar = readFile "level2.data"
12:02:52 <Cale> That is, you're defining bar as an action which when executed will read the level data.
12:03:24 <lgas> Ok, I'm starting to get it.
12:06:58 <Cale> lgas: You might have a look at http://www.haskell.org/haskellwiki/Introduction_to_IO
12:06:59 <lambdabot> Title: Introduction to IO - HaskellWiki
12:07:21 <Cale> lgas: Which basically just says what I just said, but a tiny bit more detailed.
12:08:06 <FunctorSalad> FWIW I'm trying to define mathematical entities as classes so that it can be expressed that one piece of data implements many interfaces (e.g., a morphism is also an object in the arrow category, and what not)
12:08:40 <gwern> Cale: btw, there are further improvements to mueval, show, and lambdabot
12:08:44 <rwbarton> FunctorSalad: If you have several values to define with the same type, you can write  f, g, h :: (Foo a b c, ...) => ...
12:08:55 <FunctorSalad> (and in order to be able to implement, say, objects of a given category, via several different data structures)
12:08:57 <Cale> FunctorSalad: Yeah, the *real* solution is class aliases, but nobody's implemented those.
12:09:12 <Cale> gwern: great!
12:09:21 <Twey> @src liftIO
12:09:21 <lambdabot> Source not found. :(
12:09:28 <Twey> @src lift
12:09:28 <lambdabot> Source not found. My brain just exploded
12:09:34 <Twey> Ehm :(
12:09:36 <trofi> :t liftIO
12:09:37 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:09:39 <gwern> SamB: the fs were there because old-fashioned type added crossbars to ss, and f is the closest typographical approximation you get in ascii
12:09:46 <gwern> SamB: 'twas a joke
12:10:10 <Twey> Oh, mornin' Cale
12:10:22 <FunctorSalad> rwbarton: thanks, that's close, but I'm trying to define several different class'es and data's with the same (large) context
12:10:23 <Cale> g'morning :)
12:10:40 <SamB_XP> gwern: yes, I know, I was just joking that you should have found some unicode for f-with-no-crossbar ;-P
12:10:50 * Cale stretches and exclaims おはようございます!
12:10:59 <gwern> SamB_XP: christ, do I look like I would go to such lengths for a one-off joke?
12:11:03 <SamB_XP> or ... wait they had crossbars on the esses?
12:11:10 <gwern> you clearly have me mistaken for someone else
12:11:18 <SamB_XP> I thought they were just SHAPED like fs
12:11:26 <gwern> that's how they wrote'em
12:11:34 <gwern> ever look at scans of the shakespeare folios?
12:11:57 * gwern thinks the distinction between having crossbars and being shaped like they had crossbars is an non-existent one
12:12:19 <SamB_XP> well, there's more to the shape of an f than having a crossbar ...
12:13:12 <Twey> Cale: いい目覚めだったそうですね :)
12:13:24 <mar77a> squares
12:13:47 <Zao> Assorted moonspeak.
12:14:16 <trofi> hieroglyphs
12:14:43 <Cale> Hehe, moonspeak :)
12:16:00 <trofi> google.translate managed to drecrypt it
12:16:13 <mauke> the first one was easy
12:16:21 <mauke> (unicode name lookup)++
12:17:36 <Cale> Google translate does something funny with Twey's statement.
12:18:01 <mauke> I I ? ? ME DA tu TA SO U DE SU NE
12:18:35 * sw17ch hates internet explorer
12:18:44 <chrisdone> seems like he was correcting your implicit claim that it is morning everywhere
12:19:11 <mauke> ie--
12:19:14 <Twey> いい目覚めだったそうですね = something like 'it seems you woke well, huh'
12:19:17 <Cale> ii mezamashi medatta sou desu ne
12:19:30 <Twey> 'ii mezame datta sou desu ne'
12:19:35 <Cale> oh, heh
12:19:43 <Twey> Doesn't translate well
12:19:44 <Cale> misparsed :)
12:19:51 <Twey> Heh
12:19:55 <Cale> 目覚め
12:20:02 <Cale> right
12:20:06 <Twey> From 目覚める
12:20:06 <Cale> waking :)
12:20:12 * Twey nods.
12:20:20 <sw17ch> @karma ie
12:20:20 <lambdabot> ie has a karma of -1
12:20:23 <sw17ch> ie--
12:20:24 <sw17ch> ie--
12:20:30 <sw17ch> needs to be a little lower
12:20:32 <Twey> .i'e
12:20:39 <Twey> ie--
12:20:43 <Heffalump> ie--
12:20:47 <Heffalump> firefox++
12:20:55 <Cale> I'm not sure about だった then...
12:20:57 <Valodim> firefox--
12:20:59 <Valodim> opera++
12:21:05 <Twey> Cale: Past tense of だ
12:21:15 <sw17ch> anthingThatHasDecentCssAndJavaScriptTools++
12:21:19 <Cale> Oh, interesting :)
12:21:21 <Twey> Haha
12:21:26 <Twey> Cale: You didn't know that one?
12:21:33 <Cale> Nope. :)
12:21:37 <mauke> preflex: karma ie
12:21:37 <preflex>  karma for ie: -7
12:21:50 <Cale> Somehow I haven't run into much in the past tense.
12:22:03 <Twey> Cale: You didn't read http://www.sf.airnet.ne.jp/ts/japanese/ , did you?
12:22:09 <Twey> You should.  It's good.
12:22:12 <lambdabot> Title: Teach Yourself Japanese
12:22:41 <Cale> No, I haven't.
12:22:48 <sw17ch> omgwtfbbq
12:23:02 <sw17ch> IE doens't inform it's surroundings when a max-width is applied to an input tag
12:23:04 <Cale> This looks useful though :)
12:23:10 <sw17ch> so everything else things it's width hasn't changed
12:23:17 * sw17ch gets back on topic...
12:23:43 <chrisdone> it's spelled “its”
12:23:47 <Valodim> phonetic writing, -1 for you
12:24:28 <FunctorSalad> hmm... now it says that I need to enable undecidable-instances although I think my fundep should make it decidable... is this ok?
12:24:52 <Heffalump> FunctorSalad: well, if it is decidable then you'll be fine
12:24:54 <sw17ch> chrisdone, ah, the "here comes an S!" operator... i'm sorry
12:24:57 <Heffalump> the coverage condition is quite opaque
12:25:34 <FunctorSalad> I guess it doesn't try to figure out whether the fundeps make it decidable? (or maybe that problem is in itself undecidable)
12:25:43 <Heffalump> it does try, but it only has an approximation
12:25:54 <Heffalump> there's something called the coverage condition which it checks
12:25:58 <Heffalump> see the GHC manual
12:26:04 <FunctorSalad> ok, thanks
12:26:11 <Heffalump> as you say, the problem itself would be undecidable, for obvious reasons (it's the halting problem)
12:30:19 <FunctorSalad> good point :) since a particular case would be "no fundeps"...
12:33:56 <jnaimard> hi all
12:34:45 <jnaimard> is it possible to have a public darcs repository on code.haskell.org without creating a project (ie, in my home dir, but visible from the outside) ?
12:34:46 <dmead> > True && True
12:34:47 <lambdabot>  True
12:35:25 <dmead> >  2.0 < 4.5 && 3.6 > 1.2
12:35:26 <lambdabot>  True
12:35:40 <stepcut> jnaimard: can you put it in ~/public_html ?
12:36:03 <jnaimard> thanks, I think it's what I needed
12:36:12 <stepcut> jnaimard: and then go to, ~jnaimard/public_html/procject ?
12:36:18 <stepcut> oops,
12:36:31 <stepcut> I mean, code.haskell.org/~jnaimard/project
12:36:33 <jnaimard> ~jnaimard/project, i guess
12:36:38 <jnaimard> thanks
12:37:31 <jnaimard> works like a charm
12:40:40 <cizra> How could I generate all possible permutations of a list?
12:40:52 <cizra> hm, never mind
12:41:22 <noecksit_> > (\b -> b + 5).(\a -> a * 2) 2
12:41:25 <lambdabot>  mueval: Expression did not compile.
12:41:25 <lambdabot> mueval: Time limit exceeded
12:41:32 <noecksit_> > ((\b -> b + 5).(\a -> a * 2)) 2
12:41:34 <lambdabot>  9
12:42:06 <noecksit_> why is that the first example never works?
12:42:30 <FunctorSalad> noecksit_: applying the second lambda to the 2 binds more strongly than the "."
12:42:53 <Cale> > (\b -> b + 5).(\a -> a * 2) $ 2
12:42:54 <lambdabot>  9
12:43:06 <Cale> A $ at the end will help that :)
12:43:59 <noecksit_> Cale: idk why it doesnt work in my code, but having parenthesis around the (.) works
12:44:02 <trofi> > error ""
12:44:05 <lambdabot>  mueval: Expression did not compile.
12:44:05 <lambdabot> mueval: Time limit exceeded
12:44:12 <noecksit_> ie, the $ gives me an error
12:44:18 <Cale> noecksit_: interesting
12:44:57 <rwbarton> (f g) a b   is not the same as   f g $ a b, could that be it?
12:45:06 <FunctorSalad> if we considered values of type a as functions Unit -> a then it would work ;)
12:45:15 <rwbarton> Sorry, (f . g) a b for the first one
12:45:23 <rwbarton> ack, just ignore me :P
12:45:37 <Cale> ah, that could be it, yeah :)
12:46:14 <Cale> FunctorSalad: yeah, like the categorical notion of elements
12:46:33 <tylere> heh, just made my first real step to learning haskell...bought SoE, Haskell Road to Logic, and Functional Data Structures off amazon...should be enough to get me very confused
12:46:45 <Cale> tylere: hehe :)
12:46:49 <FunctorSalad> Cale: yes, that was my thought as well... it would get rid of the distinction between . and $... but I haven't thought this through
12:46:49 <noecksit_> Cale: oh i think I know why, the function is zipWith7 and takes function as its first argument, probably the function that is argement instead binds to its arguments first
12:46:55 <tylere> but I've basically decided on haskell as my hacking language
12:46:56 <Cale> tylere: Make sure to ask questions here when you do :)
12:47:37 <tylere> was leaaning towards ocaml for a long time, but I ultimatly decided that there some things about it just can't live with (the arbitrary limits on things like string size, rather unfriendly toolchain, and the syntax mainly)
12:47:49 <tylere> I'm willing to give up a bit of execution speed for elegance
12:48:00 <FunctorSalad> the conversion would have to be transparent, for example we'd want a -> (Unit -> b) == a -> b == Unit -> (a -> b)
12:48:11 <tylere> my background is mainly in python/php anyway so even 'slow' haskell is blazing fast from my frame of reference
12:48:29 <Cale> tylere: Moreover, there are people working on the GHC backend finally, so it's going to improve :)
12:49:17 <Cale> (O'Caml has had a lot of work done on good native code generation, whereas GHC has just started in that area by comparison)
12:49:53 <Philippa> *nod*
12:50:06 <Philippa> whereas it's kinda hilarious reading Jon Harrop's complaint list with ocaml re performance
12:50:11 <Philippa> much of it's stuff we completely take for granted
12:50:16 <tylere> heh...I think in theory haskell could be faster than C, since the compiler has a much better understanding of the dataflow, so a sufficently intelligent compiler could probably do some pretty amazing optimizations
12:50:45 <Cale> tylere: I actually agree with that view.
12:51:01 <Heffalump> tylere: the biggest problem is likely to be with predictability
12:51:29 <Cale> At least, in practical terms. Of course given enough headache medicine, you can write C programs which are as close to optimal as you like :)
12:51:43 <tylere> (for instance I beleive the compiler could probably do lots of unboxing/stack allocating type stuff
12:51:45 <FunctorSalad> hmm... could a strange error about a 'deriving' clause be due to a circle in my instance hierarchy? (I have undecidable-instances on now)
12:52:06 <sjanssen> FunctorSalad: what's the error?
12:53:04 <FunctorSalad> sjanssen: "No instance for [...] arising from the 'deriving' clause of a data type declaration"
12:53:10 <Cale> Heffalump: That's true. Optimisations have to be natural in some sense in order to provide that. The usual "many bullets" approach to optimisation makes for bad predictability of performance.
12:53:59 <Cale> Oh, I've been meaning to ask -- has anyone here heard about the H-lambda calculus? Apparently some kind of lambda calculus with semantics values in the category of homotopy types?
12:54:10 <FunctorSalad> sjanssen: the error is caused by a new instance declaration for a class that appears in the context of the datatype that has the deriving clause
12:54:39 <Cale> I'd be interested in hearing if someone has a decent reference. All I've been able to find are a few not-so-introductory notes.
12:54:52 <chrisdone> :t (\f f1 -> fmap f . f1)
12:54:53 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
12:54:57 <chrisdone> is there a function that does this?
12:55:04 <chrisdone> preferably an infix operator
12:55:22 <Twey> Why exactly does Haskell use main :: IO ()?
12:55:38 <chrisdone> main can return other stuff, recursive calls, using it in ghci, etc
12:55:40 <Twey> As opposed to, say, main :: [String] -> IO Int?
12:55:42 <Heffalump> twey: instead of what?
12:55:47 <Heffalump> ah, right
12:56:07 <Heffalump> tradeoff, I guess
12:56:09 <Twey> I don't have any serious objections to it, I just wonder why they chose to do it that way
12:56:30 <Heffalump> the latter type ties you much more to a particular model of program execution
12:56:33 <Twey> For all those many vital programs out there that don't take arguments?  :)
12:56:37 <Heffalump> s/execution/invocation/
12:56:52 <Heffalump> the current model also makes it easier to use getArgs somewhere else without passing them around
12:57:00 <Twey> Ah, good point
12:57:02 <Heffalump> likewise you can exit without returning through main
12:57:09 * Twey nods.
12:57:16 <Twey> That answers it :)
12:58:57 <Twey> And record syntax only defines getters, right?  There's no modifier magically created too?
12:59:12 <Philippa> not as an identifier, no
12:59:20 <Philippa> there's sugar for updates
12:59:26 <Twey> What is it?
12:59:34 <chrisdone> variable { recordFoo = blah }
12:59:39 <Twey> Oho
12:59:41 <Twey> Thanks
12:59:54 <Twey> I don't suppose that can be nicely sectioned?
13:00:01 <Jedai> Twey: But you'll soon discover that this sugar is not really convenient
13:00:13 * chrisdone longs for lenses
13:00:19 <Twey> Lenses?
13:00:32 <chrisdone> modify $ \s -> s { lojbotHandle = h } -- this is ugly
13:00:33 <Jedai> Twey: Search for "functional references" in Hackage and you'll get a better solution (for now)
13:00:40 * BMeph takes off his glasses, polishes them, and puts them back on...
13:00:46 <Twey> Heh
13:00:56 <Twey> chrisdone: That's exactly what I'm doing :-D
13:01:28 <chrisdone> @go overloading functional references
13:01:30 <lambdabot> No Result Found.
13:01:36 <chrisdone> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
13:01:43 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
13:03:19 <Cale> I want polymorphic extensible records like Daan's proposal, but with lens syntax.
13:03:32 <chrisdone> what lens syntax?
13:04:14 <Cale> Well, just having field names refer to lenses onto that field, supporting the various record operations.
13:04:28 <chrisdone> right
13:04:46 <Cale> I'd also be all for having field names start with ' in order to make them syntactically distinct.
13:05:11 <chrisdone> ew?
13:05:15 <Cale> (since they exist at the type and value level simultaneously)
13:07:20 <Cale> For example, the type of   get 'fieldName  would be something like  { fieldName :: a | r } -> a
13:07:39 <Cale> er, well... { 'fieldName :: a | r } -> a
13:08:36 <Cale> Where r is a row variable, representing the rest of the fields in the record.
13:08:48 * Heffalump is rather annoyed that the authors of data-accessor on hackage have GPLed it
13:09:00 <dons> Heffalump: yeah, you'll have to talk to them.
13:09:08 <Heffalump> there really ought to just be one library like that
13:09:11 <dons> GPL/LGPL in general is a pain for infrastructure :/
13:12:34 <Twey> What's the null-Handle, 'I-don't-know-yet' value?
13:13:15 <Philippa> undefined
13:13:23 <Philippa> which you can't match against, FWIW
13:13:26 <Twey> Oh, heh
13:13:28 * Twey nods.
13:13:36 <Twey> That's OK, it's not going to stay undefined.
13:13:42 <ac> can I whine about cabal-install?
13:14:15 <dons> ac, go for it.
13:14:30 <Twey> Philippa: Uhm, I can match it against _ right?
13:15:15 <Philippa> or even a variable, just don't use it
13:15:33 * Twey nods.
13:15:34 <Twey> Gotcha.
13:15:35 <chrisdone> > let _ = undefined in ("ho ho,OHSH-",undefined)
13:15:38 <lambdabot>  ("ho ho,OHSH-",
13:15:40 <ac> I'm using ubuntu, and I'm having to install old-local, old-time, unix, zlib, and a few other packages manually just to get cabal-install working. I'm probably doing it wrong
13:15:41 <Philippa> (speaking "simple case" those don't actually match, they just bind)
13:16:48 <Saizan_> ac: how did you install ghc?
13:17:20 <ac> Saizan_: apt
13:17:41 <ac> Saizan_: I can't find cabal-install in the package repositories
13:17:53 <Saizan_> ac: then some of them are available via apt too, as libghc6-*
13:18:04 <ac> Saizan_: right, but some aren't
13:18:50 <Heffalump> I have a function of type Bool -> someotherstuff -> (someresults, Maybe x) , where the Maybe is a Just if the Bool is True and a Nothing otherwise. Is there a way to express that in the type without making two functions?
13:18:54 <dmead> hey all
13:19:11 <dmead> i'm having a problem with readfile
13:19:18 <bwr> is there an easy way to install cabal-install on debian?
13:19:22 <dmead> if i have a text file, and i edit it outside of ghci
13:19:23 <dmead> and save it
13:19:31 <dmead> i can't read it again from haskell
13:19:38 <dmead> the permissions haven't changed
13:19:46 <dons> dmead: did you close the file Handle?
13:19:46 <dmead> just a few characters
13:19:46 <Saizan_> ac: you're right, i'm quite surprised since e.g. unix, old-local, old-time comes with the tarball isntallation of ghc
13:19:53 <dons> no, so its in a 'semi-closed' state.
13:20:05 <dmead> i closed nano
13:20:07 <ac> Saizan_: I should probably just stick with the tarball installation
13:20:08 <dmead> hmm
13:20:19 <dons> dmead: the readFile puts the Handle in a semi-closed state.
13:20:23 <dons> you can't read it again till it's fully closed.
13:20:27 <dmead> strange
13:20:29 <dmead> oh
13:20:30 <dons> so either consume the whole file, or use openFile/hClose
13:20:37 <dons> it makes Handles threadsafe.
13:20:40 <dmead> hclose when i'm done?
13:20:49 <ac> bwr: I'd like to know too
13:20:49 <dons> hClose the handle once you've read your bits
13:21:03 <dmead> ?src hclose
13:21:03 <lambdabot> Source not found. My brain just exploded
13:21:04 <Saizan_> ac: you'd still have to install zlib, HTTP, Cabal-1.4.* and cabal-install by hand
13:21:08 <Heffalump> I think I agree with that quote in HWN about unsafeInterleaveIO.
13:21:10 <dmead> :t hclose
13:21:14 <dolio> Heffalump: Couldn't you make it 'someotherstuff -> (someresults, x)' and just ignore the x if you don't want it?
13:21:27 <Heffalump> no, because the someresults change too
13:21:30 <dmead> :t hClose
13:22:58 <ac> Saizan_: better than trying to mess with mixing debian packages and tarball packages, which just isn't working out
13:34:50 <dmead> dons: what would i do at ghci to close the file handle?
13:36:12 <dmead> all the file stuff is being obscurred by parsec, so i can't really see anything
13:36:41 <dons> dmead: use System.IO.Strict.readFile
13:36:48 <dons> simple answer.
13:37:00 <dmead> ah
13:37:16 <dmead> otherwise i'd have to keep a refrence to the file handle readfile returns?
13:37:20 <dons> yep
13:37:26 <dons> and read it strictly, the close it yourself
13:37:45 <dmead> it's normally read lazily?
13:39:06 <bos> dons: there's no way to repack  lazy bytestring into a single strict one?
13:39:10 <sioraiocht> is there any documentation about the structure of lists and other types and how GHC allocates them?
13:39:17 <dons> bos, sure.
13:39:31 <dons> toChunks/fromChunks + concat
13:39:53 <dons> S.concat . L.toChunks
13:40:02 <dons> we decided not to make it easy, since it does involve copying
13:40:09 <bos> dons: fair enough.
13:40:09 <dons> and  you know how people are with O(n) complexity
13:41:50 <bos> ah, and strict concat handles the i-have-one-chunk case. great.
13:41:59 <dmead> :t hClose
13:42:07 <dmead> nothing
13:42:09 <dmead> ?
13:42:14 <dmead> @hoogle hclose
13:42:15 <lambdabot> System.IO hClose :: Handle -> IO ()
13:42:22 <dmead> :t Handle
13:42:29 <dmead> ?src Handle
13:42:29 <lambdabot> Source not found. It can only be attributed to human error.
13:42:50 <dmead> urge to kill the crew increasing...
13:42:52 <Arnar> @type Handle
13:42:53 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:43:01 <Arnar> @type hClose
13:43:02 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:43:17 <bd_> :t System.IO.hClose
13:43:18 <lambdabot> GHC.IOBase.Handle -> IO ()
13:43:29 <Arnar>  the :t seems to fail silently
13:43:30 <bd_> ?src GHC.IOBase.Handle
13:43:30 <lambdabot> Source not found. Take a stress pill and think things over.
13:43:39 <dmead> yea
13:43:39 <Arnar> i.e. doesn't report the error
13:43:52 <dmead> or it's something thats restricted by lambdabot
13:43:55 <dmead> for security
13:44:03 <dmead> if i have
13:44:16 <dmead> x <- readFile somefile
13:44:21 <dmead> where does the handle come from?
13:44:27 <bos> dons: ketil found a silly bug in my bloomfilter code. the hash function wasn't folding over the chunks of lazy bytestrings properly.
13:44:32 <dmead> do i do just hClose somefile?
13:44:32 <sioraiocht> dcoutts: ping?
13:44:42 <Saizan_> Arnar: i've sent a patch to solve that today
13:45:19 <dons> bos, oh. not using foldChunks? (or the other chunk folding abstractions?)
13:45:31 <Saizan_> we need cale to review and possibly apply :)
13:45:42 <sioraiocht> @seen dcoutts
13:45:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #darcs, #ghc and #haskell. I last heard dcoutts speak 9h 5m 7s ago.
13:45:47 <sioraiocht> @seen dcoutts_
13:45:47 <lambdabot> I saw dcoutts_ leaving #haskell-overflow, #ghc, #haskell and #gentoo-haskell 1h 16m 43s ago, and .
13:45:53 <sioraiocht> ahh, bummer
13:46:04 <yitz> dmean if you want the handle you have to use openFile, hReadFile, etc. from System.IO.
13:46:12 <yitz> dmead if you want the handle you have to use openFile, hReadFile, etc. from System.IO.
13:46:14 <yitz> sorry
13:46:15 <Cale> Saizan_: to my email address?
13:46:24 <dmead> ah
13:46:27 <Saizan_> Cale: yes, with darcs send
13:46:28 <SamB_XP> dons: you mean how they like to use O(n) functions to make O(n^2) ones?
13:46:30 <Cale> Saizan_: okay
13:46:45 <bos> dons: they're not exported, but that wasn't the problem anyway. i forgot to make sure i had uniformly sized chunks, so i would hash ["f","oo"] differently from ["fo","o"]. embarrassing!
13:47:59 <dons> oh right.
13:48:01 <dons> Prelude Data.ByteString.Lazy.Internal> :m + Data.ByteString.Lazy.Internal
13:48:01 <dons> Prelude Data.ByteString.Lazy.Internal> :t foldrChunks
13:48:01 <dons> foldrChunks :: (Data.ByteString.Internal.ByteString -> a -> a) -> a -> ByteString -> a
13:48:02 * SamB_XP begins to contemplate monoidic hashing
13:48:07 <dons> o hehe
13:48:13 <dons> chunk boundaries make life hard
13:48:33 <SamB_XP> they wouldn't be a problem with monoidic hashing, would they?
13:48:34 <dons> we had a bug in groupBy with associative functions, that only failed on funky edge-of-chunk cases.
13:48:38 <dons> took ages to track down.
13:48:44 <bos> yes, they're fun. thank goodness for quickcheck!
13:48:59 <dmead> blah
13:49:07 <bos> of course, you have to remember to have a generator that creates silly chunks.
13:49:07 <dons> yeah, QC catches them, and then its a matter of thinking hard.
13:49:10 <dmead> why does readFile leave a file semi opened?
13:49:21 <dons> dmead: it's lazy.
13:49:26 <dons> you've not read the file yet.
13:49:36 <SamB_XP> dmead: if you use the whole file it'll close
13:49:43 <dmead> oh, but i have
13:49:48 <dons> please to be using the readFile from System.IO.Strict :)
13:49:52 * Cale blatantly applies :)
13:49:56 <dons> dmead: not till EOF at least.
13:50:09 * Cale also darcs pulls
13:51:05 <dmead> hmm
13:51:11 <dmead> the parsec code i have does read till it's EOF
13:52:00 <dmead> annnd i don't have a System.IO.Strict
13:52:01 <dmead> what what
13:52:10 <rwbarton> dmead: does it read the last byte, or past the last byte?
13:52:13 <Saizan_> Cale: ah, btw, it also looks like lb can't find djinn
13:52:21 <dons> dmead: it's in the 'strict' package.
13:52:23 <dons> cabal install strict
13:52:31 <dmead> ah
13:52:42 <gwern> Saizan_: yeah, I've told him to fix that before :)
13:53:30 <Cale> gwern: I updated mueval, and it updated ghc-paths...
13:53:35 <gwern> wow, this is annoying. I guess you can export qualified modules, but you can't then use them
13:53:41 <Cale> gwern: Is there anything else that I need to pull in?
13:53:48 <gwern> Cale: it did?
13:53:56 <Cale> cabal upgrade show  did nothing.
13:54:00 <gwern> Cale: well, a fresh show would be good for slightly cleaner @check output
13:54:07 <gwern> but I didn't bump the version
13:54:12 <gwern> since it isn't a major change
13:54:23 <Cale> ah
13:54:52 <Cale> Is there a way to force cabal to reinstall something?
13:55:02 <gwern> Cale: which mueval? 0.6.3?
13:55:15 <gwern> Cale: ghc-pkg unregister --user foo && cabal install...
13:55:21 <Cale> 0.6.2
13:55:28 <Cale> oh, I suppose I knew that way :)
13:56:11 <dmead> cabal is installed, but theres no executable?
13:56:21 <camio> Is there any canocial way to represent a path in a Data.Tree?
13:56:30 * gwern uploads 0.6.3
13:57:29 <Cale> cale@olive:~/lambdabot$ ghc-pkg list show
13:57:29 <Cale> /usr/local/lib/ghc-6.8.3/package.conf:
13:57:29 <Cale> /home/cale/.ghc/x86_64-linux-6.8.3/package.conf:
13:57:29 <Cale>     show-0.3
13:57:29 <Cale> cale@olive:~/lambdabot$ ghc-pkg unregister show
13:57:29 <Cale> ghc-pkg: cannot find package show
13:57:32 <gwern> dmead: cabal is a library
13:57:32 <Cale> grr
13:57:45 <Cale> ah, --user
13:57:56 <dmead> how do i use it?
13:58:05 <dmead> @hoogle cabal
13:58:05 <lambdabot> Distribution.PackageDescription cabalVersion :: Version
13:58:05 <lambdabot> Distribution.PackageDescription descCabalVersion :: PackageDescription -> VersionRange
13:58:05 <lambdabot> Distribution.Verbosity showForCabal :: Verbosity -> String
13:58:11 <gwern> dmead: you run a haskell source file which imports it
13:58:18 <Cale> dmead: cabal-install is the program
13:58:46 <gwern> dmead: the short answer being 'runhaskell Setup configure && runhaskell Setup build && runhaskell Setup install'. or use the separate, add-on program which makes use of cabal the library, cabal-install
13:58:55 <dmead> ah
13:59:03 <dmead> it's like cpan now right?
13:59:11 <Cale> dmead: yeah
13:59:14 <dmead> kewl
13:59:16 <Saizan_> dmead: ig you installed the Cabal package then you've only the library
13:59:31 <dmead> ah
13:59:36 <dmead> hmm
13:59:45 <dmead> dev-haskell/cabal is the only thing on portage
13:59:49 <Cale> Really, cabal-install ought to come with ghc/hugs/etc.
13:59:49 <Saizan_> you also need the cabal-install package
13:59:56 <dmead> and cabal-install doesn't come with it
14:00:03 <Cale> But it doesn't.
14:00:05 <Saizan_> ?hackage cabal-install
14:00:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
14:00:06 <dmead> sigh
14:00:12 <Cale> So you need to manually install it for now.
14:00:23 <gwern> ok, suppose I have a module which imports qualified Data.Map as M, and then 'module SomeModule (module M) where'; shouldn't I then be able to go 'import SomeModule; foo = M.map (+1) $ M.fromList [("a", 1), ("b", 2)]'?
14:00:26 <Cale> But once you have it, you can upgrade it with no troubles :)
14:01:05 <Saizan_> gwern: no
14:01:13 <gwern> Saizan_: why not?
14:01:16 <Cale> It would be nice.
14:01:46 <gwern> I mean, does the report say you can't do that?
14:01:50 <Cale> That's how I'd expect it to work, but I'm not sure if it does
14:02:16 <sjanssen> gwern: it just doesn't work like that
14:02:24 <rwbarton> gwern: when I tried that, I think I got a warning compiling SomeModule that it wasn't exporting anything from module M.
14:02:33 <Saizan_> you see fromList and map as symbols exported from SomeModule
14:02:37 <dmead> great
14:02:45 <dmead> to configure cabal i need cabal installed
14:02:49 <dmead> :(
14:03:03 <Saizan_> dmead: yeah, there's no problem with it
14:03:23 <dmead> what the proper install command in the package src directory?
14:03:25 <gwern> Saizan_: hum. so it would work if used as SomeModule.map...
14:03:40 <Jedai> dmead: cabal the library comes with GHC, cabal the program comes with the cabal-install package
14:03:43 <gwern> wait, that doesn't work either
14:03:45 <gwern> wut
14:04:07 <Saizan_> dmead: runghc Setup configure && runghc Setup build && sudo runghc Setup install
14:04:31 <dmead> runghc Setup configure && runghc Setup build && sudo runghc Setup install
14:04:43 <dmead> Configuring cabal-install-0.5.1...
14:04:44 <dmead> Setup: At least the following dependencies are missing:
14:04:44 <dmead>     Cabal >=1.4&&<1.5, network >=1&&<3, HTTP >=3000&&<3002, zlib >=0.4
14:05:08 <Saizan_> dmead: repeat the same procedure for those packages, you can find them on hackage as well
14:05:22 <Cale> :t map (+1) . map reverse
14:05:24 <lambdabot> forall a. (Num [a]) => [[a]] -> [[a]]
14:05:28 <dmead> k
14:05:50 <Cale> :t reverse (1 :: Integer)
14:05:51 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Integer'
14:05:51 <lambdabot>     In the first argument of `reverse', namely `(1 :: Integer)'
14:05:54 <Cale> good :)
14:05:57 <Jedai> dmead: You need HTTP and zlib but Cabal and network should have come with GHC (but I guess debian support for GHC isn't great)
14:06:05 <Saizan_> :t () ()
14:06:06 <lambdabot>     Couldn't match expected type `() -> t' against inferred type `()'
14:06:08 <Cale> > reverse (1 :: Integer)
14:06:11 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
14:06:12 <dmead> i'm on gentoo
14:06:14 <dmead> :/
14:06:15 <Cale> Hooray :)
14:06:23 <gwern> Cale: note the nice new error messages, thanks to Saizan_
14:06:26 <Cale> yeah
14:06:31 <Cale> that's what I was noting :)
14:06:32 <rwbarton> > (+1)
14:06:33 <lambdabot>      Overlapping instances for Show (a -> a)
14:06:33 <lambdabot>       arising from a use of `sho...
14:06:41 <Zao> dmead: libghc6-network-dev and libghc6-cabal-dev
14:06:44 <rwbarton> heh
14:06:45 <Saizan_> Jedai: Cabal-1.4 doesn't come with any ghc yet (iirc)
14:06:47 <rwbarton> > (++"foo")
14:06:48 <lambdabot>      Overlapping instances for Show ([Char] -> [Char])
14:06:48 <lambdabot>       arising from a u...
14:06:54 <Cale> whaa....
14:06:58 <Zao> Although that cabal is probably a bit behind.
14:06:59 <Cale> What's that all about?
14:07:08 <dmead> Zao, thats for portage?
14:07:16 <Zao> dmead: No, debian/ubuntu.
14:07:18 <Jedai> dmead: Anyway, maybe you have an old version of Cabal (network looks suspicious anyway, try to find some ghc related emerge)
14:07:21 <gwern> well, isn't (++"foo") a function? how can you Show a function?
14:07:24 <Cale> Overlapping instances? Do we have more than one instance of Show for functions present?
14:07:43 <Cale> gwern: Isn't that what the show library is for?
14:07:45 <dmead> yea i have the latest ghc installed
14:07:48 <dmead> it's 6.8.2
14:07:54 <dmead> latest on the ~amd64 tree
14:08:00 <gwern> 'gwern@craft:17877~>mueval -e '(++"foo")'                                                                              [ 5:08PM]
14:08:03 <gwern>     Overlapping instances for Show ([Char] -> [Char])
14:08:03 <dmead> mega-sigh
14:08:05 <gwern>       arising from a use of `show' at <interactive>:1:23-48
14:08:07 <dmead> i'll have to fix this later
14:08:08 <gwern>     Matching instances:
14:08:15 <gwern>       instance (Typeable a, Typeable b) => Show (a -> b)
14:08:16 <Zao> dmead: I extrapolated from Jedai's message that you ran a *buntu.
14:08:18 <gwern>         -- Defined in ShowFun
14:08:18 <gwern>       instance (Test.SmallCheck.Serial a, Show a, Show b) =>
14:08:18 <gwern>                Show (a -> b)
14:08:20 <gwern>         -- Defined in Test.SmallCheck
14:08:23 <Cale> ahhh!
14:08:23 <gwern>     In the expression: (show ((++ "foo"))) :: [Char]
14:08:25 <gwern>     In the definition of `__cmCompileExpr':
14:08:27 <gwern> dmead: you're on gentoo? you've used the haskell overlay yet?
14:08:28 <Cale> That one...
14:08:30 <gwern>         __cmCompileExpr = (show ((++ "foo"))) :: [Char]
14:08:31 <gwern> oops
14:08:34 <Cale> hmm, so we need to pick an instance.
14:08:55 <Cale> If we want Test.SmallCheck, we'll need to not use ShowFun
14:09:11 <Saizan_> dmead: updating Cabal is no problem, it works just like any other package
14:09:29 <Jedai> Zao: No apparently he's on Gentoo (but I though he ran a stock debian, I don't know why)
14:09:31 <Cale> Thankfully, ShowFun has nothing else of use in it, but it is a bit more general with regard to what functions it can show.
14:10:05 <gwern> @seen mmorrow
14:10:06 <lambdabot> mmorrow is in #ghc and #haskell. I don't know when mmorrow last spoke.
14:10:32 <gwern> preflex: seen mmorrow
14:10:32 <preflex>  mmorrow was last seen on #haskell 9 hours, 42 minutes and 22 seconds ago, saying: @pl  \a b c -> g (f a b c)
14:10:39 <Jedai> dmead: Right now installing cabal-install is a bit annoying but then it's really pretty easy
14:10:41 <rwbarton> > read "24"
14:10:42 <lambdabot>  mueval: Prelude.read: no parse
14:10:42 <gwern> bollocks
14:11:24 <gwern> > read "24" :: Int
14:11:25 <lambdabot>  24
14:11:46 <Jedai> dmead: Hopefully the situation will improve in the near future (with distributions support for cabal-install and probably cabal-install inclusion in the "Haskell Platform" initiative)
14:12:02 <Saizan_> we should catch exceptions generated by interpreted code maybe
14:12:03 <rwbarton> > show (read "24")
14:12:04 <lambdabot>  "
14:12:54 <gwern> : read "24"
14:12:57 <gwern> :t read "24"
14:12:58 <lambdabot> forall a. (Read a) => a
14:13:22 <gwern> ah, that's the problem, I think. lazy printing
14:13:50 <gwern> but the issue is, if I strictify printing, would that break the printing (using 'take') of infinite lists?
14:13:54 <rwbarton> oh, sure.
14:14:12 <rwbarton> Well it'd be nice to see "*** Exception: Prelude.read: no parse ideally
14:14:15 <gwern> maybe if I do the strictifying *afer* taking
14:14:18 <FunctorSalad> is Read supposed to be (right-)invertible anyway?
14:14:18 <Cale> > parseTest (many (lower <|> digit)) "f7d8s9"
14:14:19 <lambdabot> Terminated
14:14:23 <rwbarton> but that might not be feasible
14:14:33 <Cale> gwern: any idea what's happening there? ^^
14:14:49 <Cale> > parseTest mzero ""
14:14:49 <lambdabot> Terminated
14:15:01 <gwern> what the heck is parseTest?
14:15:02 <Saizan_> :t parseTest
14:15:03 <lambdabot> Not in scope: `parseTest'
14:15:03 <FunctorSalad> err, nvm. I meant "Show" and "left"
14:15:06 <Cale> oh
14:15:13 <Cale> heh, perhaps the module just isn't in scope?
14:15:20 <Cale> That's not a good error message though.
14:15:26 <Saizan_> > hClose
14:15:26 <Cale> It's from parsec, of course :)
14:15:27 <lambdabot> Terminated
14:15:29 * gwern realizes I don't know how to strictify something
14:15:33 <Cale> Terminated?
14:15:44 <Saizan_> that's weird
14:15:48 <Cale> > hClose stdin
14:15:48 <lambdabot>  mueval: Unsafe functions to use mentioned.
14:15:53 <dmead> Jedai, sweet
14:16:03 <gwern> er. how do I strictify  a String? :)
14:16:05 <Cale> gwern: It would be nice if IO actions were showable.
14:16:15 <Cale> (like they used to be)
14:16:34 <gwern> Cale: some are
14:16:37 <dmead> wait isn't there a portage overlay for hackage?
14:16:43 <dmead> @hoogle portage
14:16:43 <lambdabot> No results found
14:16:46 <dmead> waaat
14:16:47 <Cale> > print 5
14:16:48 <gwern> Cale: try running ./tests.sh to see a wide array of stuff
14:16:48 <lambdabot>  mueval: "<IO ()>"
14:16:54 <gwern> dmead: yes, I mentioned it to you already....
14:16:54 <Cale> ah, er...
14:16:58 <Cale> What happened there?
14:16:58 <dmead> ah sorry
14:17:01 <rwbarton> > foldr (\x y -> (:) $! x $! y) [] [3, 4, undefined, 5]
14:17:01 <lambdabot>  Couldn't match expected type `[b] -> [b]'
14:17:02 <gwern> see?
14:17:04 <Cale> > [print 5, print 7]
14:17:05 <lambdabot>  [
14:17:06 <dmead> ya
14:17:07 <stepcut> gwern: rnf perhaps
14:17:08 <Cale> ...
14:17:17 <rwbarton> > foldr (\x y -> ((:) $! x) $! y) [] [3, 4, undefined, 5]
14:17:18 <lambdabot>  mueval: Prelude.undefined
14:17:18 <gwern> if it doesn't hit the blacklist, it'll be caught by show
14:17:26 <rwbarton> > foldr (\x y -> ((:) $! x) $! y) [] [3, 4, 2, 5]
14:17:27 <lambdabot>  [3,4,2,5]
14:17:30 <gwern> stepcut: where would I look for that?
14:17:44 <dmead> gwern, is there a howto someplace ?
14:17:55 <Cale> gwern: Is there really a need for a blacklist given that you're not going to execute the things anyway? (Aside from unsafePerformIO and friends, in case they accidentally get imported)
14:17:57 <gwern> dmead: I think so somewhere on gentoo.org
14:18:08 <gwern> at the very least, there's a overlay howot
14:18:13 <stepcut> gwern: actually rnf is not strong enough.
14:18:31 <gwern> Cale: I'd really rather keep the blacklist. I don't trust the hint sandboxing, although I thus far haven't subverted it
14:18:43 <gwern> stepcut: oh. er, what do I need then?
14:19:06 <Cale> hmm
14:19:13 <rwbarton> > foldr (\x y -> ((:) $! x) $! y) [] $ show (read "24")
14:19:15 <lambdabot>  "
14:19:26 <Cale> I mean... if you don't explicitly execute IO actions, they're perfectly harmless...
14:20:41 <Saizan_> gwern: hint just wraps the expression inside show, with no unsafePerformIO there's no way the action can be executed
14:21:35 <Cale> :t map
14:21:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:21:40 <Cale> :t parseTest
14:21:41 <lambdabot> forall tok a. (Show a) => GenParser tok () a -> [tok] -> IO ()
14:21:42 <Cale> ah
14:21:45 <Cale> funny...
14:21:53 <Cale> :t just stopped working in privmsg for me
14:21:54 <lambdabot> parse error on input `in'
14:22:00 <Cale> ...
14:22:08 <Cale> where did that come from?
14:22:12 <Cale> oh
14:22:13 <Cale> heh
14:22:28 <Cale> > parseTest (many digit) "53278459"
14:22:29 <lambdabot> Terminated
14:22:34 <Cale> :t digit
14:22:35 <lambdabot> forall st. CharParser st Char
14:22:38 <Cale> :t many
14:22:39 <lambdabot>     Ambiguous occurrence `many'
14:22:39 <lambdabot>     It could refer to either `Control.Applicative.many', imported from Control.Applicative
14:22:39 <lambdabot>                           or `Text.ParserCombinators.Parsec.many', imported from Text.ParserCombinators.Parsec
14:22:41 <Cale> ah
14:22:41 <stepcut> gwern: in the IO monad you can do,  let str = (show [1..]) in (Control.Exception.evaluate (let f s = if Data.List.null s then () else (f (tail s)) in f str) >> putStr str)
14:22:43 <Cale> right...
14:22:52 <Cale> > parseTest (many1 digit) "53278459"
14:22:53 <lambdabot> Terminated
14:22:59 <gwern> stepcut: man, that's terrible looking
14:23:00 <Cale> :t many1
14:23:01 <lambdabot> forall tok st a. GenParser tok st a -> GenParser tok st [a]
14:23:15 <Cale> okay, *now* I'm confused
14:23:37 <stepcut> gwern: or something like this, let str = (show [1..]) in (let f s = if Data.List.null s then () else (f (tail s)) in (f str) `seq` str)
14:23:40 <gwern> (bluh bluh bluh!)
14:23:57 <stepcut> gwern: (length str) `seq` str
14:23:57 <trofi> @type parseTest
14:23:58 <lambdabot> forall tok a. (Show a) => GenParser tok () a -> [tok] -> IO ()
14:24:05 <gwern> stepcut: why can't I do just 'sayIO = UTF.putStrLn . (\x -> Codec.decodeString `seq` x) . take 1024'?
14:24:50 <matthew-_> @seen DRMacIver
14:24:50 <lambdabot> DRMacIver is in #haskell-blah, #scala and #haskell. I last heard DRMacIver speak 5s ago.
14:24:54 <stepcut> > (1 : undefined) `seq` 1
14:24:55 <lambdabot>  1
14:25:24 <trofi> > 1/0
14:25:25 <lambdabot>  Infinity
14:25:30 <trofi> > 1/hey
14:25:31 <lambdabot> Terminated
14:25:40 <stepcut> because `seq` stops as soon as something is returned, in the case of a list, when it sees (:) it is done
14:25:49 <stepcut> > (undefined : undefined) `seq` 1
14:25:50 <lambdabot>  1
14:25:55 <trofi> > error "ma error:
14:25:55 <lambdabot>  Improperly terminated string at ""ma" (column 7)
14:25:59 <trofi> > error "ma error"
14:26:00 <lambdabot>  mueval: ma error
14:26:14 <gwern> trofi: are you finally happy?
14:26:19 <trofi> almost :]
14:26:27 <trofi> > 1/invalid_symbol
14:26:28 <lambdabot> Terminated
14:26:32 <stepcut> gwern: so you need to apply seq to something which can't return anything until the whole list has been walked
14:26:35 <rwbarton> > error "foo\nbar"
14:26:36 <lambdabot>  mueval: foo
14:26:36 <lambdabot> bar
14:26:39 <gwern> > fix show
14:26:40 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:26:40 <rwbarton> gwern: ^^ uh-oh
14:26:44 <stepcut> > (length (undefined : undefined)) `seq` 1
14:26:45 <lambdabot>  mueval: Prelude.undefined
14:26:52 <gwern> see? fix show even works
14:26:59 <Cale> > error (fix id)
14:27:01 <lambdabot>  Stack space overflow: current size 8388608 bytes.
14:27:01 <lambdabot> Use `+RTS -Ksize' to incre...
14:27:03 <trofi> great! :]
14:27:20 <trofi> i'll happily update local version :]
14:27:28 <rwbarton> gwern: consider   error "foo\n/quit"  or the like
14:27:30 <Saizan_> Cale, gwern; i've found the problem, when something is not in scope hint reports an empty GhcError
14:27:35 <stepcut> gwern: but, calculating the length when you don't need it is silly. So, the function I presented just walks the list
14:27:38 <erikc> hrm, im trying to use Data.Binary, and im getting     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
14:27:39 <erikc>            against inferred type `ByteString'
14:27:41 * Cale considers error (cycle "a\n")
14:28:00 <trofi> > let z = 1 in bad_var
14:28:01 <lambdabot> Terminated
14:28:01 <Cale> Shall we try it?
14:28:05 <erikc> is this a versioning issue?
14:28:06 <gwern> rwbarton: doesn't work in the shell
14:28:15 <ddarius> Cale: Why not try it in #haskell-overflow?
14:28:21 <ddarius> If you are going to try it.
14:28:30 <stepcut> gwern: (last str) `seq` str, is almost right, unless str = "", in which case last is undefined
14:28:44 <trofi> > 1 + 'c'
14:28:45 <lambdabot>      No instance for (Num Char)
14:28:45 <lambdabot>       arising from the literal `1' at <intera...
14:29:34 <trofi> > let z = 1 in bad_var -- why it keeps silence?
14:29:39 <lambdabot> Terminated
14:30:25 <gwern> stepcut: could one map a test over the string?
14:30:38 <trofi> > toUpper."hi"
14:30:39 <lambdabot>  Couldn't match expected type `a -> Char'
14:30:39 <gwern> > last ""
14:30:41 <lambdabot>  mueval: Prelude.last: empty list
14:31:16 <stepcut> gwern: a map would not be good enough, but you could use all
14:31:33 <trofi> > error "he\nllo"
14:31:34 <lambdabot>  mueval: he
14:31:34 <lambdabot> llo
14:31:42 <stepcut> gwern: (all (const True) [1..]) `seq` 'c'
14:32:08 <trofi> > foldl' (+) 0 [1..10^7]
14:32:10 <lambdabot>  50000005000000
14:32:16 <trofi> > foldl' (+) 0 [1..10^8]
14:32:18 <lambdabot>  mueval: Time limit exceeded
14:32:28 <stepcut> > (map (>1) (undefined:undefined)) `seq` 'c'
14:32:29 <lambdabot>  'c'
14:32:35 <stepcut> > (all (const True ) (undefined:undefined)) `seq` 'c'
14:32:36 <lambdabot>  mueval: Prelude.undefined
14:32:39 <rwbarton> > error "\n/me has a sudden feeling of dread"
14:32:40 <lambdabot>  mueval:
14:32:40 * lambdabot has a sudden feeling of dread
14:32:45 <gwern> you know, if nothing else, I'm building up an excellent eval test suite
14:33:27 <gwern> hm. that could be a problem
14:33:37 <gwern> > error "\n/quit"
14:33:37 <stepcut> :)
14:33:38 <lambdabot>  mueval:
14:33:38 <lambdabot> /quit
14:33:58 <trofi> it sends privmsgs
14:34:05 <trofi> or not?
14:34:36 <trofi> who processed "/me" ?
14:34:43 <int-e> lambdabot
14:35:00 <gwern> oh dear. that seq broke my mueval
14:35:15 <rwbarton> Maybe /me is the only thing you can do
14:35:19 <gwern> stepcut: to doublecheck, your suggestion was this, yes?
14:35:21 <gwern> sayIO = UTF.putStrLn . (Codec.decodeString . force) . take 1024 where force str = (all (const True) [(1::Int)..]) `seq` str
14:35:36 <trofi> it is freenode's extension?
14:36:08 <trofi> /me tests
14:36:16 <stepcut> gwern: 	force str = (all (const True) str) `seq` str
14:36:23 <hackage> Uploaded to hackage: AERN-RnToRm 0.4
14:36:23 <hackage> Uploaded to hackage: bloomfilter 1.2.2
14:36:23 <hackage> Uploaded to hackage: mueval 0.6.3
14:36:39 <stepcut> gwern: forcing the evaluating of an infinite list will not evaluate str at all
14:37:12 <gwern> hm. I must've misunderstood soemthing
14:37:17 <stepcut> gwern: but, using all is not any better than just using length -- they both perform unneed calculations
14:37:50 <trofi> > "abc" :: !String
14:37:50 <lambdabot>  Parse error at "!Stri..." (column 10)
14:37:53 <int-e> rwbarton: /me is handled by lambdabot's privmsg code in IRCBase.hs
14:38:15 <trofi> > let !z = "abc" in z
14:38:15 <lambdabot>  Parse error at "!z" (column 5)
14:38:38 <rwbarton> int-e: oh, I see, so that a plugin can generate /me I suppose
14:38:52 <int-e> yep
14:38:54 <stepcut> gwern: maybe you just want,   sayIO = UTF.putStrLn .(Codec.decodeString . Control.Parallel.Strategies.force) . take 1024
14:39:06 <int-e> (privmsg in http://code.haskell.org/lambdabot/IRCBase.hs)
14:39:09 <gwern> oh good, that works. and the dangling " is gone
14:39:10 <trofi> > let !z = "abc" in z -- out of haskell98?
14:39:11 <lambdabot>  Parse error at "!z" (column 5)
14:39:19 <gwern> stepcut: I'll try that
14:39:36 <int-e> trofi: yes, that's not haskell 98
14:39:49 <gwern> force is deprecated
14:39:51 <gwern> huh
14:39:52 <stepcut> oh
14:39:56 <trofi> old kambdabot didn't handle this too
14:40:35 <trofi> > let a =1 in hello
14:40:36 <lambdabot> Terminated
14:40:37 <int-e> lambdabot's @eval parses the expression itself before passing it to the runplugs command for evaluation.
14:40:38 <trofi> < lambdabot>   Not in scope: `hello'
14:40:55 <int-e> @help eval
14:40:55 <lambdabot> eval. Do nothing (perversely)
14:41:03 * yitz gives \bot the url http://www.haskell.org/ in a /me message
14:41:04 <lambdabot> Title: Haskell - HaskellWiki
14:41:04 <int-e> @help run
14:41:04 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
14:41:08 <stepcut> ?pl let walk s = if null s then return () else walk (tail s)
14:41:09 <lambdabot> (line 1, column 38):
14:41:09 <lambdabot> unexpected " "
14:41:09 <lambdabot> expecting variable, "(", operator or "else"
14:41:20 <gwern> oh, this is great. force is deprecated, but it doesn't what I should use!
14:41:32 <yitz> @slap nobody
14:41:33 <lambdabot> go slap nobody yourself
14:41:38 <yitz> @slap nobody
14:41:38 * lambdabot smashes a lamp on nobody's head
14:42:00 <trofi> @slap all
14:42:00 * lambdabot would never hurt all!
14:42:21 <yitz> so \bot both parses and sends /me messages
14:42:28 <trofi> all++
14:43:16 <gwern> stepcut: does force have any benefits over the seq? it adds a dep to mueval and is also deprecated
14:44:05 <stepcut> gwern: the benefit is not having to do some calculation that you don't care about in order to get seq to evaluate things enough
14:44:15 <stepcut> gwern: but there are other solutions
14:44:49 <int-e> @index rnf
14:44:50 <lambdabot> Control.Parallel.Strategies
14:45:07 <rwbarton> > rnf [3, 4, undefined, 5]
14:45:08 <lambdabot>  mueval: Prelude.undefined
14:45:46 <trofi> gwern: -- runtime dependencies; Hoogle is omitted since it doesn't export a library for Cabal...
14:45:51 <trofi> .cabal:  Build-Tools: Hoogle >= 4
14:46:07 <dons> did anyone else see harrop's argument that, even though there might be an order of magnitude more ocaml or F# libraries online, and an order of magnitude more activity, since most things have 0.x numbers, it's still unsuitable.
14:46:22 <dons> that was kfish's thesis: we should start with 1.0
14:46:25 <dons> for everythign.
14:46:39 <gwern> lol
14:46:41 <lament> that's true
14:46:52 <lament> starting with 0 is a silly practice
14:46:53 <gwern> trofi: interesting. I should look up that field
14:46:53 <dons> sorry, order of magnitude more haskell libraries,
14:46:59 <lament> like, irssi is 0.8.12
14:46:59 <dons> than ocaml. (and certainly F#).
14:47:03 <int-e> does anybody listen to harrop?
14:47:09 <dons> no, but using 1.0 is a nice idea :)
14:47:10 <lament> when it really should be 8.12
14:47:30 <dons> int-e: did you see the mersenne updates?
14:47:31 <dons> all good?
14:47:41 <ddarius> lament: Is 0.8.12 backwards compatible with 0.0.1?
14:47:54 <lament> i doubt 0.0.1 even works :)
14:48:41 <ddarius> The question is: does everything that did work in 0.0.1 work in 0.8.12
14:49:18 <stepcut> dons:  what is the best way to strictify a String? ie, (length str) `seq` str, but without calculating the length
14:49:30 <gwern> trofi: build-tools is a bit dishonest, but I like it :)
14:49:52 <dons> length s `seq` s :)
14:49:52 <ddarius> stepcut: Use rnf
14:50:20 <int-e> dons: all good. I haven't gotten around to the double conversion problem, but the main problem appears to be that on 32 bit platforms there is no primop to convert a 64 bit word to float.
14:50:27 * gwern is currently using '$| rnf'
14:50:28 <dmhouse> The length only evaluates the stem, right? It doesn't eval the characters themselves.
14:50:31 <dons> int-e: hmm.
14:50:31 <ddarius> dons: Why don't we start at 2.4?
14:50:40 <dons> ddarius: 4.2!
14:50:51 <int-e> ddarius: 3000!
14:51:14 <int-e> googolplex. etc.
14:51:32 <bwr> is there a guide for getting lambdabot connected to a channel?
14:51:35 <dons> 20080818
14:51:47 <dmhouse> omega, etc.
14:51:49 <gwern> bwr: look at the config files
14:51:52 <bwr> ok
14:52:09 <bwr> i am not sure where the config files are...
14:52:09 * gwern fixes Saizan_'s spelling errors
14:52:43 <gwern> bwr: in the darcs repo
14:53:04 <dmhouse> gwern: does that mean we have nice type errors now?
14:53:06 <bwr> oh, i just installed it from cabal-install
14:53:09 <dmhouse> > "hello" * 2
14:53:10 <lambdabot>      No instance for (Num [Char])
14:53:10 <lambdabot>       arising from the literal `2' at <inte...
14:53:16 <gwern> > 1 + "string"
14:53:17 <lambdabot>      No instance for (Num [Char])
14:53:17 <lambdabot>       arising from the literal `1' at <inte...
14:53:18 <dmhouse> Yay.
14:53:22 <trofi> > almost + 1
14:53:23 <lambdabot> Terminated
14:53:27 <dmhouse> > 1 -- comments fixed?
14:53:28 <gwern> bwr: no no, don't install lambdabot from hackage!
14:53:28 <lambdabot> Terminated
14:53:36 <stepcut> ddarius: ah right. string `using` rnf ?
14:53:38 <gwern> dmhouse: nope
14:53:55 <gwern> > 1 {- still this -}
14:53:55 <trofi> you should release lambdabot ASAP :]
14:53:56 <lambdabot>  1
14:54:21 <tibbe> stepcut: just out of curiosity, do you need to strictify because you're doing lazy I/O?
14:54:28 <gwern> trofi: I'm working on it
14:54:50 <stepcut> tibbe: beats me, gwern is the one that is using it.
14:54:59 <tibbe> oh
14:55:09 * stepcut got rnf and rwhnf confused
14:55:28 <gwern> tibbe: it's not so much lazy io as lazy eval, I think
14:55:34 <rwbarton> tibbe: it's to avoid this behavior:
14:55:35 <rwbarton> > show undefined
14:55:37 <lambdabot>  "
14:55:45 <tibbe> gwern: oh ok
14:56:08 <ddarius> :t Control.Strategies.using
14:56:10 <lambdabot> Couldn't find qualified module.
14:56:16 <ddarius> @index using
14:56:16 <lambdabot> Control.Parallel.Strategies
14:56:24 <ddarius> :t Control.Parallel.Strategies
14:56:25 <lambdabot>     Not in scope: data constructor `Control.Parallel.Strategies'
14:56:25 <trofi> > -- huh
14:56:26 <ddarius> :t Control.Parallel.Strategies.using
14:56:26 <lambdabot> Terminated
14:56:27 <lambdabot> forall a. a -> Strategy a -> a
14:57:00 <Jedai> stepcut: rnf goes to normal form, wich means it evaluates completely the value
14:57:12 <trofi> > foldl' (*) 0 [1..]
14:57:15 <lambdabot>  mueval: Time limit exceeded
14:57:20 <stepcut> Jedai: right, I got it confused with rwhnf which doesn't
14:57:42 * gwern gets an email back from the Hint guy. he doesn't know why -- fails either
14:58:05 <Jedai> stepcut: rwhnf only goes to weak head normal form, which means it evaluates only one level of the value (typically only the constructor in a data value)
14:58:15 <stepcut> Jedai: right
14:59:51 <bwr> gwern: so why is lambdabot in hackage if it isn't supposed to be used? :/
15:00:17 <gwern> bwr: because I didn't realize it would be broken for most people when I uploaded it
15:00:21 <gwern> I HAVE BORNE THAT GUILT EVER SINCE
15:00:31 <bwr> oh ok
15:00:31 <Cale> Is there no way to remove packages?
15:00:42 <dmhouse> cabal-install is super useful for lambdabot, though.
15:00:54 <dmhouse> As it has, roughly, a gazillion dependencies.
15:01:12 <gwern> indeed
15:01:48 <dmhouse> Does it just change too often to be useful in hackage?
15:01:49 <gwern> if I ever do the ann, i'm going to say 'just use cabal-install already; I'm not going to take up space explaining the manual proccedure'
15:02:21 <dmhouse> Ooh, and cabal-install work on local packages? (I.e. those not downloaded from hackage.) Because then there'd be no need for lambdabot to be in hackage.
15:02:21 <gwern> well, right this second it does
15:02:55 <gwern> @tell Cale I've pushed a fix to darcs mueval for that dangling " problem. also, would anyone object to me adding myself to the list of lambdabot admins?
15:02:55 <lambdabot> Consider it noted.
15:03:28 <Cale> gwern: go for it :)
15:03:28 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:03:41 <gwern> oops
15:04:51 <b\6> that new message thing should be a notice or message, maybe.
15:05:19 <dmhouse> Btw, you can use ?clear-messages if you don't want to read them.
15:05:22 <dmhouse> Also, ?messages works in-chan.
15:05:42 <trofi> > reverse "messages"
15:05:43 <lambdabot>  "segassem"
15:06:10 <dmhouse> And finally, no-one seems to use ?ask. It works exactly like ?tell, but it reads a lot more naturally than ?tell in certain circumstances.
15:06:12 * gwern asks trofi if he'd like to touch my segassem
15:07:14 <gwern> dmhouse: I do use it, but I personally think it's redundant
15:07:26 <gwern> actually, I could remove it right now. any real objections?
15:07:44 <dmhouse> It is to some extent, but when I see people saying things like ?tell foo that I'd like to ask them whether bar...
15:07:55 <dmhouse> There's no real harm in its presence, it of course uses ?tell underneath.
15:08:16 <gwern> yeah, but it means the interface is more cmplex
15:08:28 <gwern> as we now have a nearly meaningless distinction to remember
15:08:42 <chrisdone> how can I use a regex on lines in a file and output only the bit I put in parentheses? (besides writing a one-liner haskell utility to do it)
15:08:53 <trofi> > a where a = 1
15:08:53 <lambdabot>  Parse error at "where" (column 3)
15:09:05 <chrisdone> > let a = 1 where 1 = 5 in a
15:09:06 <lambdabot>  1
15:09:08 <gwern> let a = 1 in a
15:09:28 <gwern> Cale: thoughts about @ask?
15:09:38 <dmhouse> gwern: if you don't use it, you're blissfully unaware. If you do use it, you can get nicer formatted questions.
15:09:42 <dmhouse> I like it, anyway.
15:09:46 <Saizan_> gwern: sent patch for better handling of exceptions in evaluated expression in mueval
15:09:55 <byorgey> gwern: I don't see much point in removing it.
15:09:58 <gwern> 'k
15:10:15 <ddarius> > -1 + 2
15:10:17 <lambdabot>  1
15:10:22 <gwern> alright, so I guess I'll leave it alone
15:10:33 <gwern> but as Dog is my witness, one day @slap is going to go!
15:11:00 <dmhouse> ?slap gwern
15:11:00 * lambdabot locks up gwern in a Monad
15:11:01 <ddarius> gwern: Where?
15:11:04 <lament> @slap gwern
15:11:04 * lambdabot pushes gwern from his chair
15:11:07 <Saizan_> why?
15:11:16 <dmhouse> Hehe, I'd forgotten about that.
15:11:38 <gwern> Saizan_: it is juvenile, supremely useless, and hostile. I don't believe #haskell should be institutionalizing hostility like that
15:11:51 <dmhouse> It's whimsical and a bit of fun.
15:11:52 <gwern> ddarius: away, let us say
15:12:10 <dmhouse> If anyone ever takes "lambdabot locks up dmhouse in a Monad", then I'll reverse that statement.
15:12:16 <dmhouse> *takes ... seriously
15:12:18 <byorgey> but it isn't.  I've only ever seen @slap used in a context that was clearly in jest.
15:12:19 <Saizan_> gwern: a bit of humor doesn't hurt, and looking at the messages is not really hostile
15:12:22 <gwern> whimsical? bah
15:12:32 <Saizan_> @quote tropical
15:12:32 <lambdabot> No quotes match. :(
15:12:44 <gwern> if you want whimsy, take credit and do it yourself
15:13:11 <trofi> @hoogle Codec.Binary
15:13:11 <lambdabot> No results found
15:13:15 <trofi> @hoogle Codec.Binary.Base85
15:13:16 <lambdabot> No results found
15:13:18 <Saizan_> @src foobar
15:13:18 <lambdabot> Source not found. Do you think like you type?
15:13:23 <ddarius> Because it is a secret who executed the @slap command...
15:13:24 <dmhouse> gwern: I'm not sure lambdabot is really one of those places we need to be concerned about simplicity of interface, anyway. One of its main functions are to be fun, and having things to explore is part of that. I don't think I've ever heard anyone say "argh, if only I could get lambdabot to do foo!"
15:13:48 <gwern> argh, if only I could get lambdabot to watch darcs repos for new patches!
15:13:53 <trofi> @yarr
15:13:53 <lambdabot> Well Ahoy! thar.
15:13:54 <Saizan_> an ircbot has to have a personality :)
15:14:00 <gwern> argh, if only I could get lambdabot load in definitions from hpaste!
15:14:02 <Botje> argh, if only i could get lambdabot to make my homework!
15:14:08 <dmhouse> I mean, where foo is something that lambdabot actually does.
15:14:13 <gwern> argh, if only I could get lambdabot to be stable!
15:14:22 <gwern> dmhouse: actually, lambdabot used to watch darcs patches
15:14:25 <dmhouse> I.e., I've never seen someone unable to figure out how to use some part of lambdabot.
15:14:28 <gwern> but that functionality is teh broke
15:14:34 <mmorrow>  gwern, just the person i was looking for
15:14:51 * gwern notes that there are a surprising number of broken plugins in lambdabot, some quite interesting, like darcspatchwatch
15:15:12 <Saizan_> broken as?
15:15:14 <Cale> and babel
15:15:15 <gwern> mmorrow: yes, I've been blocking on a mueval release because of y0uor issue
15:15:21 <mmorrow> i just wrote a patch for mueval that actually parses the input expression, then extracts all identifiers so they can be tested against full name, instead of prefix matching
15:15:23 <mmorrow> http://code.haskell.org/~morrow/code/haskell/mueval-parsing-patch.diff
15:15:25 <lambdabot> http://tinyurl.com/563r2b
15:15:33 <trofi> lambdabot could recompile only updated-on-disk plugins in runtime
15:16:08 <gwern> Saizan_: broken as I don't think it even compiles any more
15:16:40 <gwern> mmorrow: yes, very interesting, but what about the resources issue?
15:17:17 <mmorrow> i'm checking, it way be working now (but i changed some imports so not exactly a controlled environment)
15:17:31 <sjanssen> > "unsafePerformIO"
15:17:31 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:17:35 <sjanssen> lame.
15:17:53 <gwern> :(
15:18:01 <ddarius> sjanssen lays the smack down
15:18:09 <Saizan_> yeah, it should be "not in scope".
15:18:09 <Botje> > "unsafe" ++ "PerformIO" -- sneaky
15:18:10 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:18:12 <mmorrow> [m@ganon src]$ mueval --expression="()"
15:18:12 <mmorrow> mueval: Expression did not compile.
15:18:12 <mmorrow> mueval: Time limit exceeded
15:18:14 <Botje> boo!
15:18:18 <sjanssen> > "unsafe"
15:18:18 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:18:22 <sjanssen> lamer.
15:18:28 <Botje> > "uns"++"afe"
15:18:30 <lambdabot>  "unsafe"
15:18:32 <Botje> hahaa!
15:18:49 <trofi> > 'u' `elem` "unsafe"
15:18:50 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:18:51 <gwern> drat
15:19:07 <mmorrow> yeah, gwern if you decide to use that parsing code, i didn't actually change the list from the prefix one, so ...
15:19:07 <gwern> and I would've gotten away with it too, if not for you pesky kids!
15:19:09 <dmhouse> > reverse "OImrofrePefasnu"
15:19:10 <lambdabot>  "unsafePerformIO"
15:19:17 <yitz> > "votbgf"
15:19:19 <lambdabot>  "votbgf"
15:19:22 <dmhouse> Hehe, i made lambdabot say a dirty word.
15:19:28 <yitz> > map prec "votbgf"
15:19:29 <lambdabot> Terminated
15:19:36 <mmorrow> gwern: should this be working ???
15:19:39 <mmorrow> [m@ganon src]$ mueval --expression="()"
15:19:39 <yitz> > map pred "votbgf"
15:19:40 <lambdabot>  "unsafe"
15:19:40 <gwern> Saizan_: ack, you've conflicted with me
15:19:42 <sjanssen> gwern: I thought mueval already sanitizes imports, how does sanitizing identifiers help?
15:19:48 <trofi> @. run run reverse "OImrofrePefasnu"
15:19:50 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:20:10 <gwern> sjanssen: because you can't rely on sanitizing imports, as I thought the fully-qualified issue proved
15:20:11 <yitz> > map pred "votbgfQfsgpsnJP"
15:20:12 <lambdabot>  "unsafePerformIO"
15:20:17 <Saizan_> gwern: you're right, i can unrecord, pull, and resend if you want
15:20:24 <gwern> Saizan_: yes pls, if it
15:20:27 <dons> this all sounds highly dodgy.
15:20:29 <gwern> s not too much troubkle
15:20:31 <sjanssen> gwern: I thought you fixed the fully qualified issue?
15:20:35 <gwern> otherwise I can edit it in manually
15:20:41 <gwern> dons: defense in depth!
15:21:04 <sjanssen> gwern: I don't think I believe in that
15:21:06 <gwern> sjanssen: Hint may've
15:21:33 <dons> using ghc-api means your trusted code base is now enormous.
15:21:37 <dons> i'd expect to see continued holes.
15:21:40 * gwern does. I also believe in strategic barrages, fire-and-motion, defeat in detail, indirect grand strategy...
15:21:46 <sjanssen> gwern: if the fully qualified module issue isn't fixed, I can write unsafePerformIO without using "unsafe"
15:22:08 <ddarius> processCommand "@run" _ = "Possibly unsafe code."
15:22:38 <gwern> dons: what, like the trusted base was any better with (old, non ghc-api) hs-plugins?
15:22:40 <trofi> > a
15:22:41 <lambdabot>  a
15:22:45 <gwern> I know which one I trust more...
15:22:50 <dmhouse> Err...
15:22:52 <gwern> @undefine a
15:22:53 <lambdabot> Undefined.
15:23:00 <sjanssen> gwern: I trust the old system more
15:23:01 <trofi> > b
15:23:02 <lambdabot>  b
15:23:08 <dmhouse> > /part
15:23:09 <lambdabot> Terminated
15:23:09 <trofi> > a
15:23:10 <lambdabot>  a
15:23:21 <gwern> why? I incorporated all the old protections
15:23:23 <dmhouse> Seems it puts a space in anyway, so yeah.
15:23:42 <trofi> > error $ repeat '\n'
15:23:42 <ddarius> gwern: The old system had years of testing.
15:23:46 <FunctorSalad> hmm, what's this? "Could not deduce (foo) from the context (bar)" in spite of bar *containing* foo?
15:23:48 <lambdabot> Terminated
15:24:01 <trofi> @type repeat
15:24:01 <sjanssen> gwern: doesn't seem so, the qualified module issue is absolutely critical
15:24:01 <lambdabot> forall a. a -> [a]
15:24:13 <trofi> > error $ take 10 $ repeat '\n'
15:24:15 <lambdabot>  mueval:
15:24:24 <gwern> ddarius: and I've tested mueval on all the examples I saw for lambdabot
15:24:26 <ddarius> FunctorSalad: I might know why that is, but I can't determine that from your simplified error message.
15:24:46 <trofi> @type times
15:24:47 <lambdabot> Not in scope: `times'
15:24:55 <sjanssen> gwern: white lists are strictly superior to black lists
15:25:08 <sjanssen> @src unsafePerformIO
15:25:08 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
15:25:12 <FunctorSalad> ddarius: hmm, do you really want me to paste the whole thing? wouldn't be very informative by itself I think
15:25:27 <trofi> > realWorld#
15:25:28 <gwern> sjanssen: the ghc devs say it is fixed in 6.10, and hint works around it for 6.8.x by writing out a module in much the same way as hs-plugins. which is an ugly approach which has caused bugs at least twice, but is at least secure
15:25:28 <lambdabot> Terminated
15:25:57 <trofi> @src lazy
15:25:57 <lambdabot> Source not found.
15:26:02 <trofi> @type lazy
15:26:03 <lambdabot> Not in scope: `lazy'
15:26:11 <trofi> @wtf lazy
15:26:11 <lambdabot> Maybe you meant: bf ft wn
15:26:13 <rwbarton> @src inlinePerformIO
15:26:13 <lambdabot> Source not found. There are some things that I just don't know.
15:26:25 <mm_freak> why isn't ByteString a monad?
15:26:31 <dons> mm_freak: it's not a container.
15:26:35 <dmhouse> mm_freak: it's not polymorphic in its container type.
15:26:37 <ddarius> mm_freak: It's not even a type constructor.
15:26:42 <mm_freak> ah yeah…  dumb question, sorry
15:26:46 <Saizan_> gwern: resent
15:26:56 * ddarius wishes people would stop saying "container."
15:27:18 <dons> you don't like the punctuation?.
15:27:20 <dons> ..
15:28:00 <trofi> :]
15:28:01 <dons> ‽‽‽
15:28:13 <sjanssen> gwern: okay, so the qualified module issue is definitely fixed?
15:28:35 <gwern> no, not the interrobang? MY MORTAL ENEMY
15:28:50 <gwern> sjanssen: it is as certain as anything else when it comes to security and evaluating code...
15:29:17 <FunctorSalad> hmm, is the announcer broken/abolished? anyway, ddarius: http://hpaste.org/9812
15:29:48 <sjanssen> gwern: okay, that's one less thing to worry about
15:29:48 <dmhouse> Hpaste has been long dead.
15:29:49 <FunctorSalad> ddarius: the second item in the context is identical to what it allegedly can't deduce
15:29:52 <ddarius> FunctorSalad: They are not the same.
15:30:00 <sjanssen> gwern: but "unsafePerformIO" is still lame :)
15:30:01 <mm_freak> how can i express (replicateM 10 ['a'..'z']) as a list of ByteStrings?
15:30:27 * gwern suggest sjanssen go bite some knees. I likes my blacklist!
15:30:32 <sjanssen> mm_freak: map pack $ replicateM 10 ['a' .. 'z']
15:30:45 <FunctorSalad> ddarius: oh, I see. so I'll have to figure out why it doesn't use the same f'
15:30:47 <sjanssen> gwern: you're actually going to leave that in?
15:30:56 <gwern> Saizan_: '+-- | forces a string catching pure exceptions and displaying them like ghci, *** Excection: ...'? :)
15:31:39 <mm_freak> sjanssen: is there no more direct way?  i'd like to sacrifice as little performance as possible for this
15:31:45 <dcoutts> sioraiocht: pong
15:31:47 <gwern> sjanssen: I'll think about removing it, after I've refactored and cleaned up the code, moved convenience functions into hint, upgraded to 6.10 so I can get a non-hacky solution to imports, gotten qualified imports working, removed the worthless /tmp code...
15:32:03 <trofi> how to see in local darcs repo which patches are local and which are yet in remote repo?
15:32:11 <IsoPallo> Oi! Good days work. I managed to compile GHC and gprolog runtimes to work together just to find out that I liked Curry more... :)
15:32:23 <gwern> trofi: do a pull?
15:32:32 <tylere> What's the recommended dev environment on windows? (Pref. not emacs+haskell mode.... I'm neutral on emacs and general and find the windows port to be a bit...rought)
15:32:43 <Saizan_> gwern: like mueval -e '('x',undefined)' --> ('x',*** Exception: Prelude.undefined
15:32:52 <dmhouse> gwern, all this is great work, btw.
15:32:54 <ddarius> tylere: Use whatever you want.
15:33:03 <dmhouse> (Although I'm still unsure why the original evaluator was replaced.)
15:33:17 <tylere> ddarius: Yea, but I'm looking for recommendations....pref something that actually groks haskell
15:33:23 <sjanssen> dmhouse: I think decoupling evaluation from lambdabot is a really good step
15:33:30 <sjanssen> @vixen you're a bit chubby
15:33:31 <lambdabot> whatever
15:33:43 <dmhouse> tylere: there's a Visual Studio plugin for Haskell. Although I would recommend Emacs + haskell-mode ;)
15:33:45 <ddarius> tylere: Nothing does and everyone just uses whatever editor they were using before.
15:33:45 <gwern> hm, is it 'pretty print', or 'pretty-print' or 'prettyprint'?
15:34:10 <gwern> (honestly getting hs-plugins working on hackage and with lambdabot would've been very troublesome. mueval, however, I know works with hackage)
15:34:26 <gwern> preflex: seen mauke
15:34:26 <preflex>  mauke was last seen on #perl 2 hours, 53 minutes and 59 seconds ago, saying: dunno, retarded admins?
15:34:27 <Armored_Azrael> How would one make a parsec parser consume a natural number, then if there is a period immediately after it (with no intervening whitespace) consume it, otherwise if there's whitespace between it and the period, it must not consume it?
15:34:32 <sjanssen> there's already a working version of hs-plugins on hackage
15:34:56 <gwern> mmorrow: any news on the resources issue?
15:35:24 <gwern> Saizan_: man, forceString is kind of funky. is that really the cleanest definition?
15:36:00 <MarcWeber> lilac: I've found the trouble. commit was hidden in bracket calling x calling y calling commit.. :)
15:36:01 <ddarius> natural >>= \n -> (lookAhead (char '.') >> char '.'>> return n) <|> return n
15:36:12 <FunctorSalad> there is nothing to infere about the type of the functions in the instance declaration body, is there?
15:36:23 <mmorrow> gwern: originally i had problems with three of the ::Resource s from System.Posix.Resource, but that was a while ago and this may not be that. just tell me one thing ....
15:36:32 <mmorrow> should this work?
15:36:33 <mmorrow> [m@ganon ~]$ mueval --module="Prelude" --expression="()"
15:36:41 <mmorrow> [m@ganon ~]$ mueval --expression="()"
15:36:43 <mmorrow> (or that)
15:36:51 <gwern> yes
15:36:53 <gwern> > ()
15:36:55 <FunctorSalad> so I don't understand why my function argument in the instance declaration body isn't exactly the type it's supposed to be
15:36:55 <lambdabot>  ()
15:36:59 <mmorrow> it doesnt
15:37:07 <mmorrow> [m@ganon ~]$ mueval --module="Prelude" --expression="()"
15:37:07 <mmorrow> mueval: Expression did not compile.
15:37:07 <mmorrow> mueval: Time limit exceeded
15:37:11 <gwern> gwern@craft:17948~>mueval --module="Prelude" --expression="()"                                                        [ 6:37PM]
15:37:11 <gwern> ()
15:37:36 <FunctorSalad> oh wait, think I got it
15:37:49 <mmorrow> my suspicion is it's the same problem with Posix.Resource s i've had before, being masked my some catch or something
15:37:51 <gwern> mmorrow: hm. please try darcs mueval, it has better errors
15:38:07 <mmorrow> that is darcs mueval (as of last night)
15:38:29 <mmorrow> oh, i gotcha :)
15:38:34 <gwern> yesterday? man, yesterday is ancient history
15:38:42 <Armored_Azrael> lookAhead is still having the same problem I had before--namely that when natural parses, it consumes whitespace following the natural number. This means that if I try that on say,
15:38:49 <Armored_Azrael> 5 .5
15:38:50 <FunctorSalad> the type of the argument is known, but it can still have instances for a given class in multiple ways
15:39:06 <SamB_XP> gwern: believe it or not, some darcs repos haven't been updated since LAST MONTH!
15:39:11 <Armored_Azrael> with (many parserName), I'll get 5 5
15:39:25 <Armored_Azrael> (I'm trying to deal with the case of 5. 5
15:39:28 <Saizan_> gwern: you don't get much better from there
15:39:37 <gwern> SamB_XP: impossible! we live in the 21st century, after all
15:39:46 <rwbarton> Armored_Azrael: that's probably because natural is defined as lexeme (read <$> manyOne ['0'..'9']) or something
15:39:56 <rwbarton> Armored_Azrael: try that definition without lexeme
15:39:57 <SamB_XP> gwern: reportedly, last month was also part of the 21st century!
15:40:14 <ddarius> many digit >>= \ds -> optional (char '.' >> return ds)
15:40:23 <gwern> now you're just funning me. -_-
15:40:32 * ddarius always gets the optional combinators mixed up
15:40:41 * gwern decides it is spelled "pretty print", and pushes
15:41:16 <Armored_Azrael> rwbarton: Thanks, that works
15:44:08 <byorgey> or   many digit <* optional (char '.')  , if you've made an instance of Applicative for the Parsec monad.
15:45:44 <ddarius> byorgey: I have.
15:47:06 <gwern> uh oh
15:47:14 <gwern> Saizan_: did you remember to run ./tests.sh?
15:48:42 <gwern> gwern@craft:17953~>mueval -e 'let fix f = let x = f x in x in foldr (.) id (repeat read) $ fix show' || echo Correct  [ 6:48PM]
15:48:45 <gwern> "*** Exception: stack overflow
15:50:31 <Saizan_> gwern: you mean that on an exception we should exit with 1?
15:50:41 <gwern> yes
15:50:49 <gwern> on any bad function, we exit with 1
15:50:52 <gwern> tests.sh tests this
15:51:20 <gwern> if your mueval is correct, ./test.sh will terminate with echo "Done, apparently successfully"
15:52:58 <Saizan_> i don't see why we want that?
15:52:58 <chrisdone> funny ghc error
15:53:11 <mmorrow> <sjanssen> there's already a working version of hs-plugins on hackage
15:53:19 <chrisdone> {do data <- foo}, rather than “unexpected data”, “empty do construct”
15:53:46 <mmorrow> sjanssen: the most recent time i've built it, it built flawlessly
15:54:06 <gwern> Saizan_: because it provides a way to do safer @lets
15:54:26 <gwern> lambdabot could in theory eval all @lets first, and only commit to file those which return 0
15:54:51 <gwern> I mention that ./tests.sh should pass in the README, but I guess it wasn't 100% clear
15:55:11 <FunctorSalad> emacs's Index menu is supposed to understand haskell, right?
15:56:14 <gwern> actually, I guess I'll add test.sh as a record hook test
15:56:28 <Saizan> gwern: that's arbitrary though, why evaluating an exception implies an error? (also on my machine the default timelimit is too short)
15:56:54 <gwern> why on earth should mueval claim to be successful if an exception is hit?
15:57:43 <Saizan> because it has correctly evaluated it?:)
15:57:59 <Saizan> it's not like ghci crashes on exceptions at the prompt
15:58:31 <gwern> ghci is perfectly happy to format your hard drive and is meant to evaluate multiple things
15:58:34 <gwern> the two cases are not comparable
16:00:27 <Saizan> i don't see what exceptions have in common with unsafe IO actions, however it's just a matter of remembering to call exitFailure
16:01:01 * gwern is going to take a break now. if you don't fix it Saizan, I shall, although it's not clear to me how exactly
16:12:37 <mopped> Can anyone reccomend a book that handles recursion well? I can understand simple cases but i've seen a few scripts that are quite hard to get my head around
16:13:08 <sampointon> mopped: SICP?
16:13:44 <mopped> alright, thanks
16:14:05 <jberg> mopped, its not that hard to understand when you understand the general case and base case to make it stop
16:15:48 <erikc> how can i make ghci stop echoing results
16:16:15 <erikc> or cap echos at a certain amount of characters
16:17:15 <mopped> sec jberg ill paste this snipper thats confusing me, its python though but its easy to understand the syntax!
16:17:20 <mopped> http://pastie.org/256807
16:17:29 <lambdabot> Title: #256807 - Pastie
16:18:29 <sampointon> mopped: any idea what it's actually meant to do, or is it an exercise in deobfuscation?
16:18:43 <glguy> lazy evaluation makes learning about recursion easier; you can just learn the general case first, saving a notion of "base case" for some other time
16:18:51 <mopped> it generates permeations, sec
16:19:44 <mopped> >>> perm(['a', 'b', 'c'])
16:19:44 <mopped> >>> c
16:19:46 <mopped> ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
16:19:59 <sampointon> mopped: it's the gratuitous mutation that's confusing to me
16:20:28 <rwbarton> recursion, mutable state, and bad variables names aren't a winning combination
16:22:11 <mopped> i'm trying to wrap my head around it but the way it almost falls out then starts again with a new 'i', is eh!
16:23:08 <rwbarton> (the reason being that recursion is easy to understand as long as you think about what values are being returned and not the details of execution; but when mutable state is involved, you have to think about both)
16:23:18 <erikc> hrm, is there no way to suppress the printing of the result in ghci? im using ghci to interactively examine some data but the prints are monstrous
16:23:33 <ndmitchell> @seen dcoutts_
16:23:33 <lambdabot> I haven't seen dcoutts_.
16:23:36 <ndmitchell> @seen dcoutts
16:23:36 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #darcs, #ghc and #haskell. I last heard dcoutts speak 51m 52s ago.
16:23:46 <twanvl> erikc: :set -fno-print-bind-result
16:24:01 <dcoutts> ndmitchell: hia
16:24:10 <mopped> what's mutable state rwbarton?
16:24:29 <BMeph> Who's ouor resident Cabal expert?
16:24:32 <ndmitchell> dcoutts: i'm trying to find the apache config file on haskell.org - any hints?
16:24:33 <lambdabot> ndmitchell: You have 1 new message. '/msg lambdabot @messages' to read it.
16:24:39 <ndmitchell> @messages
16:24:40 <lambdabot> dcoutts said 54m 49s ago: you keep looking for me at the wrong time of day! :-) I'm offline during the day working on my thesis.
16:24:54 <erikc> twanvl: much tnka
16:24:56 <erikc> thanks
16:24:58 <BMeph> er, *our
16:24:59 <ndmitchell> hehe, thesis work, i remember that...
16:25:10 <dcoutts> ndmitchell: /etc/httpd/conf/httpd.conf
16:25:29 <dcoutts> ndmitchell: apache also goes by the unix name 'httpd' for http daemon
16:25:43 <rwbarton> mopped: well, any variables whose values change during the computation.  Like c, and to some extent alist and blist
16:25:52 <dcoutts> BMeph: did you have a Cabal Q?
16:26:17 <rwbarton> mopped: for example, it's not obvious that the purpose of the alist.insert line is just to undo the blist.append line
16:26:30 <ndmitchell> dcoutts: explains why grepping turned up nothing...
16:26:36 <mopped> yeah that's what im having trouble understanding
16:26:55 <BMeph> dcoutts: Yes. About my cabal problem - I ran it with -v3, and it looks like the server is rejecting the HTTP/1.1 header.
16:27:15 <ndmitchell> dcoutts: "could not open file for writing, permission denied"
16:27:22 <dcoutts> ndmitchell: of course! :-)
16:27:29 <dcoutts> you're not root
16:27:36 <ndmitchell> dcoutts: I'm sure I've edited it before
16:27:48 <ndmitchell> I'm looking to add the line: ScriptAlias /hoogle/3/index.cgi /home/haskell/hoogle/3/index.cgi
16:27:48 <dcoutts> BMeph: I presume you're using an http proxy
16:27:57 <rwbarton> mopped: lines 7-9 are just   perm(alist with the ith element removed, blist with the ith element of alist appended)
16:28:06 <ndmitchell> ScriptAlias /hoogle/3/hoodoc.cgi /home/haskell/hoogle/3/hoodoc.cgi
16:28:09 <dcoutts> ndmitchell: I presume you no longer need the beta ones
16:28:21 <ndmitchell> dcoutts: indeed, and the root hoodoc one can go as well
16:28:32 <sampointon> rwbarton: not quite, python's semantics are a bit weird with default variables
16:28:34 <Philonous> Is there a performance difference between foldl and foldr?
16:29:04 <dcoutts> Philippa: yes, but the difference depends on what function you're folding. It can be better or worse.
16:29:08 <ndmitchell> the only real reason to keep v3 around is for gtk2hs, but i think that might be staying a while - at least until you move to Haddock 2, and ideally cabal packages
16:29:20 <sampointon> rwbarton: oh, never mind, that doesn't matter anyway
16:29:22 <rwbarton> sampointon: this is true.  But perm is only called with a default argument once
16:29:31 <dcoutts> Philippa: rule of thumb, for functions that are strict in their second arg use foldl, for ones that are lazy in their second arg use foldr
16:29:50 <dcoutts> Philippa: eg for (+) use foldl, for (:) use foldr
16:29:54 <Saizan> Philonous: and use foldl' instead of foldl
16:30:36 <b\6> i was under the impression i could h <- connectTo h p; c <- hGetContents h and i could save c in a record or whatever and it'd always contain unread data from the remote host. way wrong?
16:30:39 <Philonous> (+) is strict in it's second argument?
16:30:44 <dcoutts> Philippa: right, there's hardly ever any use case for foldl, foldl' is almost always better than foldl
16:30:52 <dcoutts> > 1 + undefined
16:30:53 <lambdabot>  mueval: Prelude.undefined
16:31:05 <rwbarton> Philonous: For most Num instances, at least
16:31:08 <dcoutts> Philippa: + seems to be strict in its second arg doesn't it ? :-)
16:31:12 <Philonous> dcoutts: I see
16:31:16 <dcoutts> right, at least for Int it is
16:31:27 <dcoutts> you can define lazy numbers
16:31:28 <Philonous> dcoutts: Btw you are highlighting the wrong person :)
16:31:43 <dcoutts> oops, sorry Philippa
16:32:17 <Philonous> @src foldl'
16:32:17 <lambdabot> foldl' f a []     = a
16:32:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:32:43 <dcoutts> ndmitchell: see if it works now
16:32:46 <Philonous> @src foldl
16:32:46 <lambdabot> foldl f z []     = z
16:32:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:33:31 * ski thinks dcoutts erred when referring to Philippa .. not when referring to Philonous
16:33:33 <Philonous> @src foldr
16:33:33 <lambdabot> foldr f z []     = z
16:33:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:35:04 <ndmitchell> dcoutts: no, I need: /hoogle/3/index.cgi /home/haskell/hoogle/3/index.cgi (as well)
16:35:19 <Philonous> ski: He drew Philipp*as attention for no good reason
16:36:00 <dcoutts> ski: yes, my bad
16:36:04 <dcoutts> ndmitchell: oops, try now
16:36:15 <ski> m .. right
16:36:36 <ski> (confusion ftw)
16:36:39 <ndmitchell> dcoutts: perfect, many thanks
16:36:44 <Philonous> So foldl should behave worse memorywise, but is there a difference in excecution speed? (despite it might need some time allocating memory)
16:36:47 <dcoutts> ndmitchell: great
16:37:13 <ndmitchell> Philonous: execution speed and memory allocation are usually very very similar
16:37:54 <Philonous> Because allocating memory is expensive?
16:38:26 <Philonous> Anyway. Thanks for the help
16:38:55 <ndmitchell> Philonous: not really, its very cheap, but it tends to be done a lot
16:39:35 <Philonous> Then I don't quite get what you mean when you say execution spead and memory allocation are similar
16:40:33 <yav> does anyone know if there is some haddock documentation for the GHC API?
16:40:57 <ndmitchell> Philonous: a Haskell program spends most of its time allocating memory, but actually allocating memory is very cheap - just done a lot
16:40:57 <gwern> there isn't so far as I know
16:41:26 <gwern> yav: there are no docs, basically. your best bet is to look at working examples, and libaries layered on top of the api like hint
16:41:44 <yav> ok, thanks
16:42:18 <Philonous> Ah ok. That's insightful. So I might want to avoid it even more. Thanks
16:46:34 <TSC> "sequence" is prone to stack-overflows on long lists, is that right?
16:46:54 <TSC> Depending on the monad, that is
16:58:03 <erikc> hrm, this is the first 'significant' thing ive done with haskell, parsing a 30 meg binary trace file + using ghci to analyze the results, and im a bit surprised at the memory consumption
16:58:49 <erikc> according to +s, mapM putStrLn $ map show $ take 5000 $ allocations woo, allocates 75 megs, thats boggling
16:59:07 <Cale> erikc: That's total allocation, not the largest size in memory
16:59:12 <erikc> right
16:59:16 <sjanssen> erikc: mapM_ will save memory
16:59:22 <erikc> i still find it, really big :)
16:59:26 <Cale> It could allocate and deallocate a single memory cell over and over and rack up a count like that :)
16:59:26 <TomMD> All the pointer overhead on a 30 megs of data parsed thats not surprising.
16:59:28 <jcpetruzza> gwern: whenever you can, please, darcs pull hint and let me know if the comment thing works for you now
16:59:36 <gwern> jcpetruzza: sure
17:00:10 <erikc> cale: oh...i see
17:00:33 <erikc> ok, cause my parse step takes 35 seconds, and 11 gigs of allocation :)
17:00:39 <rwbarton> erikc: are you compiling with -O2?
17:00:51 <erikc> havent optimized yet, i should
17:01:01 <dolio> 75 megs isn't really that much for 30 megs of actual data.
17:01:27 <erikc> i guess i'd expect a read only traversal for printing to allocate a lot less
17:01:56 <gwern> jcpetruzza: seems to work
17:02:04 <rwbarton> erikc: every character you output is going to allocate at least 12 bytes or so
17:02:09 <erikc> ah
17:02:30 <erikc> i dont want to complain too much, just understand why hehe. it's half the size of my ruby implementation and runs 20x faster
17:02:57 <rwbarton> erikc: :) sure.  Optimization will help a lot.  But yeah, the numbers do seem awfully large at first
17:03:09 <dons> 75M of parse state for 30M of data is pretty good.
17:03:27 <dons> I guess you're not using String?
17:03:35 <erikc> Data.Binary and ByteString
17:03:38 <dons> yeah, good.
17:03:47 <Cale> A processor that does billions of instructions a second can do a lot of allocation in a few seconds :)
17:04:10 <erikc> and then i tagged a bunch of stuff as strict to avoid running out of stack space
17:04:40 <jcpetruzza> gwern: good, i'm uploading this new version, then
17:04:42 <adu> hi
17:05:11 <Cale> But take care when doing that, since making things stricter can waste space as well (if you allocate large things before they're needed).
17:05:33 <erikc> right
17:05:51 <adu> or an infinite strict list...
17:06:38 <ski> lo adu
17:06:52 * adu wonders how that would crash...
17:07:10 <adu> probably a stack overflow
17:07:19 <ski> > last [0..]
17:07:22 <lambdabot>  mueval: Time limit exceeded
17:07:29 <ski> hmhm
17:07:45 <rwbarton> > foldr (\x y -> ((:) $! x) $! y) [] (repeat 1)
17:07:46 <lambdabot>  Stack space overflow: current size 8388608 bytes.
17:07:46 <lambdabot> Use `+RTS -Ksize' to incre...
17:07:52 <adu> yeah!
17:08:06 * erikc is using Haskell to parse+analyze the allocation/deallocation trace of a C++ program
17:08:07 <dolio> Speaking of allocation, have you thought about that memcpy patch to uvector, dons? :)
17:09:13 <gwern> @seen Cale
17:09:13 <lambdabot> Cale is in #japanese, #haskell-overflow, #ghc and #haskell. I last heard Cale speak 4m 2s ago.
17:09:22 <gwern> d'oh
17:09:23 <Cale> I'm here
17:09:36 <dcoutts> hia Lemmih
17:09:46 <dolio> lambdabot is in #japanese?
17:09:51 <Cale> yeah :)
17:10:06 <Cale> I really must fix a bug in the Url module though
17:10:17 <Cale> It does terrible things when the page is not in UTF-8
17:10:18 <gwern> Cale: the -- comment thing is now fixed in darcs hint/mueval in case you weren't following jcpetruzza and me
17:10:26 <Cale> ah, okay
17:10:36 <ski> Cale : how about mbot ?
17:10:46 <Cale> Shall I bring it up? Okay.
17:10:54 <ski> if you want
17:10:58 <gwern> what does #japanese use it for?
17:11:19 <Cale> Not much. There are some Haskell people in there though :)
17:11:38 <gwern> yes, I've noticed #haskell seems to have an affinity for japanese
17:11:45 <jcpetruzza> gwern: it's in hackage now
17:11:49 * gwern intends to one day write up 'the stereotypical haskeller'
17:11:51 <lament> japanese and unicycling...
17:11:58 <Lemmih> Hey dcoutts.
17:11:59 <gwern> very good
17:12:04 * gwern wonders why utf8-light
17:12:07 <gwern> lament: and beards
17:12:08 <lament> (is it a coincidence that in Japan they teach unicycling in public schools?)
17:12:31 <gwern> lament: and they live on the US west coast
17:12:44 <Lemmih> dcoutts: Someone runs a tor client on my subnet so I haven't been able to irc for a while.
17:13:08 <dcoutts> Lemmih: oh your isp cut you all off?
17:13:15 * gwern tries to remember what stereotypes besides beards, unicycling, japanese, FPing there were
17:13:26 <dcoutts> Lemmih: or freenode doesn't like the tor stuff?
17:13:38 <erikc> oh, -O2 made the parse run in 1.8 seconds, so its 160x faster than ruby now, which means its usable on much larger traces now, sweet
17:13:39 <dons> Lemmih: heh
17:13:50 <Lemmih> dcoutts: Freenode scans for tor exits and I don't particually like the web irc clients.
17:13:52 <dons> erikc: oh yes, please use -O2 with Data.Binary
17:14:00 <gwern> hm. a question - Glasgow Data Haskell, gdh, got merged into GHC didn't it?
17:14:00 <dons> erikc: even -O2 -fvia-C -optc-O2
17:14:06 <dcoutts> gwern: mm, clearly I need to learn Japanese then, I've collected all the others.
17:14:13 <dons> gwern: gdh is glasgow *distributed* haskell
17:14:23 <dons> GPH - glasgow *parallel* haskell, got merged in.
17:14:29 <gwern> oh. oops
17:14:31 <dons> not to be confused with DPH -- data parallel haskell
17:14:37 <gwern> gaaah
17:15:08 <gwern> @seen mmorrow
17:15:08 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 1h 21m 21s ago.
17:17:13 * gwern &
17:24:11 <lispy> I was just thinking of a fun troll question.
17:24:44 <lispy> Come in here and demand that you guys teach me how to implement duff's device
17:24:50 <lispy> in Haskell
17:25:12 <kaol> lispy: just use TH
17:25:37 <lament> lispy: ...in the type system?
17:25:47 <lament> somebody should request Oleg that
17:30:45 <BMeph> "Yes! Oleg CAN do that in the type system!"
17:31:21 <shapr> @quote
17:31:21 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
17:31:27 * shapr laughs
17:34:13 <Botje> @oleg
17:34:14 <lambdabot> Defined.
17:34:18 <Botje> .. what?
17:34:25 * shapr laughs
17:34:47 <lispy> Duff's Device in the type system?
17:35:00 <Botje> ain't no system like the type system!
17:35:09 <lispy> that would be cool, but I don't think it duff's device makes sense without imperative programming contsructs
17:35:12 <Cale> Harpy ftw.
17:35:22 <Cale> Do your own loop unrolling :)
17:35:23 <lispy> Cale: oh, do tell.
17:35:25 <lispy> ah
17:36:24 <hackage> Uploaded to hackage: bloomfilter 1.2.3
17:36:24 <hackage> Uploaded to hackage: hint 0.2.4.1
17:37:03 <lispy> I have to implement a parser in python at work based on this old C parser.  The grammer is very simple, very, very simple.  But, I'm so tempted to implement in Haskell instead and call it a prototype :)
17:37:48 <lament> haha
17:38:00 <shapr> hah
17:38:01 <Botje> "here, i wrote it in python 3000"
17:39:00 <adu> Cale: have you tried my hackage package yet?
17:39:37 <dons> lispy, call it faster,shorter, and done.
17:39:38 <lispy> I could probably write it in haskell in very quickly using just words/unwords/lines/unlines/dropWhileSpace and friends
17:39:56 <dons> the lambda revolution has to start somewhere.
17:40:00 <adu> lispy: have you heard of ply?
17:40:07 <shapr> THE REVOLUTION IS HERE!
17:40:33 <lispy> dons: sadly the final version must by python as that's the only interpreter we have embedded in our flagship software (and I'd embed GHCi if I could...)
17:40:39 <adu> lispy: http://www.dabeaz.com/ply/
17:40:41 <lispy> adu: no i haven't
17:40:43 <dons> the revolution will not be memoised!
17:40:51 <lambdabot> Title: PLY
17:41:00 <adu> lispy: I thought it was the coolest thing when I was learning Python
17:41:01 * dons does the shapr dance
17:41:06 <shapr> dons: Actually... ed has been talking about something ...
17:41:12 <shapr> And it does auto-memoization.
17:41:15 <adu> lispy: and I thought it was the best parser in the world until I found Parsec :)
17:41:18 <dons> heh
17:41:24 <shapr> It's crazy and cool.
17:41:28 <lispy> adu: ah, I think a parser generator is overkill for this grammar
17:41:39 <adu> lispy: heh ok
17:41:40 <shapr> edwardk: Tell us about memoization!
17:41:44 <shapr> @seen edwardk
17:41:44 <lambdabot> edwardk is in #haskell. I don't know when edwardk last spoke.
17:41:46 <shapr> foo
17:42:05 <ski> bar
17:42:11 <shapr> BAZ!
17:42:25 <shapr> ooh, I could write a GUID library for Hackage!
17:42:45 <lispy> adu: it's really just a nested file format like, (obj (node (intr 1 1 (subrecord 0 (index 1) (foo 2) (blah string value) ) ... )
17:42:47 <shapr> Um, is it possible to get the MAC address already, or do I need to resort to the FFI?
17:43:25 <ski> sexpr !
17:43:31 <lispy> very much
17:43:32 <stepcut> shapr: the MAC address of what ?
17:43:36 <shapr> stepcut: Of the network card
17:43:37 <Cale> adu: which one?
17:43:41 * ski compares with "shapr" .. hmm
17:43:47 <stepcut> shapr: on linux? or in general ?
17:44:16 <adu> Cale: 'only'
17:44:19 <adu> :)
17:44:20 <shapr> stepcut: either way.
17:44:35 <shapr> stepcut: I'll likely use the GUID lib on win32.
17:44:42 <stepcut> shapr: for linux, you can probably find it in /proc somewhere..
17:45:01 <Philonous> is there a way to introduce function overloading without defining ed-hoc typeclasses, since that appears to be rather hackish
17:45:08 <Philonous> ad-hoc*
17:45:11 <stepcut> shapr: otherwise, you could send yourself a packet via loopback, and then look at the packet headers
17:45:18 <shapr> that's true
17:45:34 <shapr> ed-hoc, that's the stuff edwardk does.
17:45:36 <adu> lispy: lisp = literal <|> parens $ many $ lexeme lisp
17:45:47 <Jedai> Philonous: Uhm ? type-class are a way to structure the overloading
17:46:33 <Jedai> Philonous: So no, you can't have completely arbitrary overloading (whatever that could mean)
17:48:13 <sjanssen> hmm, didn't this come up yesterday?
17:48:27 <shapr> stepcut: foo, I only see it in /proc/net/{ipv6_route,if_inet6}
17:48:28 <Jedai> Philonous: Generally, when you want to overload, that means you discovered a functionality common to a certain number of type, this set of type is probably not arbitrary, you can find what kind of structure link them. If not you probably shouldn't use overloading anyway
17:48:39 <stepcut> shapr: bets me
17:48:56 <stepcut> shapr: those were just ideas, not certainties
17:49:00 <shapr> stepcut: Thanks for the suggestion of looking in /proc :-)
17:49:16 <stepcut> i guess loopbock wouldn't work, since you would get the MAC address of the loopback device
17:49:22 <adu> shapr: are you talking about IPv6?
17:50:04 <shapr> adu: Nah, I'm trying to get the mac address of my card(s) for GUID generation.
17:50:14 <shapr> adu: and I was hoping to escape the FFI.
17:50:26 <Philonous> Well, I just saw the (=~)-operator from Text.Regex.Posix and it is polymorphic in it's return value with completely unrelated types. But still they appear to have implemented a special Regex-return-value typeclass. And that puzzled me.
17:51:20 <lispy> adu: and how lisp defined?
17:51:39 <Philonous> I guess it's not an issue in most other situations, so I can just live with it. But I was still wondering
17:51:57 <Jedai> Philonous: How are they unrelated ? They're possible results of a match, as such they're able to report informations about a match, you wouldn't find a SocketPort instance for example...
17:52:04 <lispy> adu: oh n/m I see what you're saying
17:52:27 <adu> shapr: why not run "system ifconfig eth0 | grep ether | awk '{print $2;}'"
17:52:50 <shapr> That's a good point.
17:52:57 <shapr> adu: Any ideas how to get my mac address on Windows? :-)
17:53:13 <adu> shapr: maybe system "ipconfig ..."
17:53:17 <shapr> ooh yeah
17:53:27 <shapr> Won't be pretty, but will probably work.
17:53:32 <adu> heh
17:53:55 <adu> shapr: actually you might have to use runInteractiveProcess to get stdout
17:54:03 <adu> system is exitcode i think
17:55:11 <Philonous> Surely they are related in that they are possible return values from the "same" function. Yet they appear to be rather different in their meaning and use. But anyway, never mind. I will just forgo it for now and return to it when (if ever) this becomes an issue.
17:55:54 <lispy> adu: that would work pretty well...I do have some funky literals, but that shouldne be a big problem (some of my literals are hex dumps of image files with spaces between every 2 hex digits)
17:58:55 <adu> lispy: yey! i feel so helpful
18:01:34 <Jedai> Philonous: Well yes they are different in their use, their wouldn't be a point in overloading over them if not. But there common point is that they can represent interesting informations about a regex match
18:03:01 <matthew-_> so, I'm looking for a log_2 function. I've found logBase
18:03:10 <matthew-_> but I'd like logBase 2 0 to be 0, not -Inf
18:03:31 <matthew-_> and ints rather than floats would be nice too...
18:03:48 <ski> but `2 ^ 0' is not `0' ..
18:04:01 <mopped> Anyone here happen to know of a book store in ny whom would stock a few computing books? here on holiday and I cant find any back at home :P
18:04:26 <cjb> mopped: nyc?
18:04:43 <ski> presumably "New York City"
18:04:54 <cjb> he said NY, just checking it's NYC
18:05:02 <mopped> yeah it is
18:05:34 <matthew-_> ski: you have a good point ;)
18:06:16 <mopped> NYU doesnt seem to have them either!
18:06:16 <cjb> mopped: if you don't need them to be inexpensive, any large Barnes and Noble would be fine
18:06:39 <lispy> > 2 ^ 0
18:06:40 <lambdabot>  1
18:07:03 <lispy> > logBase 2 0
18:07:04 <lambdabot>  -Infinity
18:07:12 <Cale> > 0^0
18:07:14 <lambdabot>  1
18:07:23 * lispy grumbles
18:07:34 <shapr> mopped: Which books?
18:07:38 <rwbarton> 0^0 is definitely 100% equal to 1
18:07:44 <Olathe> > 2^-Infinity
18:07:45 <lambdabot> Terminated
18:07:48 <Cale> rwbarton: :)
18:07:48 <adu> matthew-_: ya, your definition of log is not mathematical
18:07:48 <lispy> rwbarton: no, not really
18:07:51 <Cale> I agree.
18:07:54 * Olathe terminates lambdabot.
18:07:58 <rwbarton> lispy: how many functions are there from the empty set to the empty set?
18:08:16 <Cale> There is exactly one function from the initial object of Set to itself :)
18:08:25 <lispy> rwbarton: But, 0^0, is a divide by zero
18:08:52 <Cale> lispy: how so?
18:09:01 <dons> ?yow!
18:09:02 <lambdabot> Couldn't find fortune file
18:09:03 <Cale> lispy: How does the definition of x^y involve division?
18:09:14 <dons> I'll show *you* a fortune file.
18:09:15 <matthew-_> adu, ski: true. But it's what I need. I refer to this C dfn: _hash_log2(uint32 num) { uint32 i, limit; limit=1; for (i = 0; limit < num; limit <<= 1, i++) {}; return i }
18:09:16 <lispy> a^b/a^c = a^(b-c), let a = 0 and b = c
18:09:18 <Olathe> Couldn't find FORTUNE file !!!
18:09:22 <mopped> shapr: uh, pleasures of counting, new turing omnibus and the little schemer
18:09:38 <adu> matthew-_: if you want a function that scales like log but crosses zero, try (\x -> x * logBase 2 x) or (\x -> logBase 2 (x+1))
18:09:43 <dons> I love all these RWH comments. so useful.
18:09:46 <dons> mm "Mentioning isomorphism sounds a bit scary here. Why not say 'equivalent'?"
18:09:49 <dons> hehe
18:10:08 <Olathe> Who is RWH ?
18:10:10 <lispy> dons: yeah, good thing it's not "A Theory of Practical Haskell"
18:10:15 <shapr> Real World Haskell
18:10:21 <Olathe> Oh.
18:11:18 <lispy> Cale: in general to convince people that a^0, for a != 0, I uset hat above, that a^b/a^c = a^(b-c), hence my grumbles.  Maybe you can define a^0 differently.
18:11:54 <Cale> lispy: That identity doesn't apply when a = 0, of course.
18:12:31 <Cale> Typically, a^0 = 1 by definition.
18:12:37 <Cale> (for any a)
18:12:40 <rwbarton> > let power a n = product (replicate n a) in (power 2 3, power 0 0)
18:12:42 <lambdabot>  (8,1)
18:12:47 <lispy> Cale: right that identity is undefined in that case.  So we need to extend the definition.  But, counting the number of functions seems a bit much to explain
18:13:12 <Cale> lispy: mm...
18:13:29 <Cale> lispy: Well, n^m is the number of functions from a set of size m to a set of size n.
18:13:42 <Cale> Which is sort of why it's *useful* for 0^0 to be 1
18:14:08 <mopped> eh well one barnes and noble shop has two books, better than nothing!
18:14:10 <lispy> But, now you need to prove to the student that what you said about # of functions is true :)
18:14:11 <Cale> (because you want the empty function to be a function, since it makes Set into a category)
18:14:23 <Cale> Well, you can define n^m that way.
18:14:32 <Cale> (for natural numbers)
18:14:35 <rwbarton> lispy: ah.  I didn't mean that it would be easy to explain to the average person why 0^0 = 1, just that it is ~universally accepted in math
18:14:53 <Philonous> Cale: Also 0^0:=1 makes (^) continuous, which can proof usefull, too
18:15:07 <Cale> Philonous: well, not *quite*
18:15:12 <lispy> as one of my math professors said after explaining the axiom of choice, "Welcome to our religion!" :)
18:15:20 <rwbarton> :t (^) -- Cale, yes :)
18:15:21 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:15:42 <Philonous> Cale: What am I missing?
18:15:45 <lispy> meaning, continuous on the domain of integers?
18:16:06 <rwbarton> It's continuous on R x N
18:16:06 <lispy> eg, delta >= 1?
18:16:06 <Cale> Philonous: Well, lim a -> 0 of 0^a is still 0
18:16:31 <Philonous> Ok, continuous in it's second argument :>
18:17:12 <lispy> forall a. f n = a^n  ?
18:17:13 <Cale> You can say that along any curve not tangential to the y-axis the limit as (x,y) -> 0 of f(x,y) = x^y will be 1
18:17:55 <lispy> (er, I'm tyring to say you fix an a, then check the resulting function for continuity)
18:18:22 * lispy has probably been out of math class too long
18:18:25 <ski> lispy : s/forall a/forall n/, then
18:18:53 * stepcut hasn't read it, but did just recently notice it on the book case at home
18:19:02 <lispy> ski: ah, yes I was using an implict forall on the n.  Yes, I see.
18:19:32 <ski> f = \n -> a^n  -- alternative
18:19:45 <Philonous> Cale: That would be right, I presume
18:20:24 <Cale> For any real number a, the limit as x -> 0 of x^(ax) is 1 :)
18:20:28 <lispy> forall a. (f :: forall n. n -> Int)
18:21:33 <lispy> I think when I took real analysis I didn't get this forall stuff but after programming in haskell with rank-n polymorphism and existential types it seems more natural
18:21:34 <dons> shapr: what do you think of this wiki approach to gathering technical reviews for RWH?
18:21:36 <edwardk> ed-hoc? ouch
18:21:42 <dons> shapr: do you know of any other book that's been done this way?
18:21:58 <edwardk> @seen shapr
18:21:58 <lambdabot> shapr is in #scannedinavian, #haskell-soc, #haskell-blah and #haskell. I last heard shapr speak 7m 45s ago.
18:22:14 <ski> lispy : that `forall a.' is useless, since `a' doesn't occur under it
18:22:25 <ski> (unless you're talking dependent variables, of course)
18:22:40 <lispy> ski: Well, it appears in the exression but not in the type sig of f
18:23:04 <lispy> f = a^n :: forall a. (f :: forall n. n -> Int), or some such
18:23:04 <ski> (and the `forall n.' seems misplaced ..)
18:23:49 <edwardk> shapr: talked to the llvm folks regarding the minor tweaks to the jit to support the same global register located variable stuff that they already support in llvm-gcc that means that i should be able to store the heap and stg stack in regs. which combined with the earlier trick for how to tag the generated code to avoid double indirections that llvm should be able to support all the tricks needed for a ghc style spineless tagless g-machine.
18:24:01 <adu> matthew-_: your C function is identical to (if x==0 then 0 else ceiling (logBase 2 x))
18:24:05 <ski> matthew-_ : so given `m' you want the smallest natural number `n' such that `m =< 2^n' ?
18:24:08 <lispy> :t let g a = let f n = a^n in g
18:24:09 <lambdabot> <no location info>:
18:24:09 <lambdabot>     not an expression: `let g a = let f n = a^n in g'
18:24:12 <lispy> > let g a = let f n = a^n in g
18:24:13 <lambdabot>  Parse error at end of input
18:24:26 <matthew-_> adu: yep, what's even funnier, is that where it's used, it's more complex than that
18:24:44 <matthew-_> it's from the linear hash table in postgres
18:24:52 <lispy> > let g a = let f n = a^n in f n in g a
18:24:53 <adu> matthew-_: heh
18:24:55 <lambdabot>  mueval: Time limit exceeded
18:25:01 <lispy> :t let g a = let f n = a^n in f n in g a
18:25:02 <lambdabot> Expr
18:25:06 <lispy> heh
18:25:08 <ski> lispy : `f = a^n :: forall a. (f :: forall n. n -> Int)' still looks very strange
18:25:24 <noecksit_> for those that use cabal-install, if one would want to remove a haskell package, how would he go about doin that?
18:25:25 <matthew-_> they then use it in a macro, which is what I actually want, which is: #define BUCKET_TO_BLKNO(metap,B) ((BlockNumber) ((B) + ((B) ? (metap)->hashm_spares[_hash_log2((B)+1)-1] : 0)) + 1)
18:25:33 <lispy> ski: certainly it's not haskell
18:25:39 <lispy> ski: it's pseudo-mathskell
18:25:53 <lispy> or just mathaskell I guess
18:26:06 <dcoutts_> noecksit_: unregister with ghc-pkg and delete files with rm. If you want something better you can help us write the code to track installed files.
18:26:16 <ski> lispy : i'm saying i have no idea how to interpret it, either as pseudo-haskell or pseudo-math (or both)
18:26:24 <lispy> ski: really?
18:26:33 <ski> yes
18:26:42 <lispy> ski: it means pick an a, and that gives you a function of any n, I thought
18:26:54 <ski> i think i know what you want to express .. but i can't see how that expression would express that
18:27:23 <stepcut> ?pl \(f,a) -> f a
18:27:23 <lambdabot> ap fst snd
18:27:41 <lispy> oh that's a sneaky use of reader
18:28:06 <noecksit_> dcoutts_: lol ok, i guess it doesnt track the files, only fetches them
18:28:07 <ski> for `f :: forall n. n -> Int' to reasonably make sense, wouldn't that `n' used there have to be a type ?
18:28:10 <lispy> :t (ap fst snd, fst snd)
18:28:11 <lambdabot>     Couldn't match expected type `(a, b)'
18:28:11 <lambdabot>            against inferred type `(a1, b1) -> b1'
18:28:11 <lambdabot>     In the first argument of `fst', namely `snd'
18:28:22 <ski> (or set, if you prefer)
18:28:30 <noecksit_> it does track what needs to be updated though
18:29:03 <lispy> ski: oh, well I was abusing notation in that regard yes
18:30:48 <ski> i think you may want to say something like `forall a :: Int. ( f :: Int -> Int;  forall n :: Int. ( f n = a^n ))'
18:31:01 <adu> matthew-_: what the f
18:31:05 <ski> (possibly removing the `forall a :: Int.' part ..)
18:31:07 <lispy> ski: yes that would be more mathy
18:31:25 <yitz> @type uncurry ($)
18:31:26 <lambdabot> forall a b. (a -> b, a) -> b
18:31:31 <lispy> ski: I wanted to be explicit about that forall, but yeah Ican see how it's not needed
18:31:38 <matthew-_> adu: right, so it should actually be the mapping from indices to [0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,...]
18:31:52 <ski> instead of `forall n :: Int. ( f n = a^n )' you could have `f = \n -> a^n' or indeed the more mathy `f = n |-> a^n'
18:32:47 <adu> matthew-_: I wish I knew the cure for C
18:33:11 <ski> (the `forall a :: Int.' part would be removed if you wanted to have `a' as a free variable, rather than as a "arbitrary constant" or however one should put that)
18:33:18 <yitz> adu: I guess you need someone to give you some pointers about that.
18:33:26 <adu> yitz: lol
18:33:37 <matthew-_> adu: heh. I'm just trying to reimplement their linear hash table in Haskell, and after about 2 hours work, I at least conceptually understand how it works
18:33:58 <lispy> f = n ↦ a^n, hmm...not all unicode chars look like want
18:34:19 <adu> lispy: wow that looks nice!
18:34:47 <adekoba> mmm, blocks
18:34:48 <lispy> adu: ah, on my screen it's too tiny :)
18:35:00 <adu> lispy: i have good fonts i suppose...
18:35:37 <lispy> f = n ☞  a^n :)
18:35:58 <lispy> I love the pointing hand instead of the normal "maps to" :)
18:36:46 <Olathe> Go away ☞
18:37:11 <ski> you made wifs go away
18:37:17 <adu> f=(a^)
18:37:24 <LegendaryPenguin> what is wrong with this pattern mydecode (x,y):zs = (take x (repeat y)) : mydecode zs
18:37:29 <yitz> f = n ↦ aⁿ
18:37:33 <Olathe> Heheh
18:37:35 <adu> nice
18:37:40 <lispy> LegendaryPenguin: missing parens around the (:)
18:37:46 <LegendaryPenguin> oh
18:37:50 <lispy> LegendaryPenguin: mydecode ((x,y):zs) ...
18:38:15 <ski> LegendaryPenguin : what you wrote means the same as `(x,y) = take x (repeat y); zs = mydecode zs'
18:38:16 <lispy> yitz: oh I couldn't find the tiny n, cool
18:38:24 <ski> er
18:38:39 <ski>  mydecome (x,y) = take x (repeat y)
18:38:41 <ski>   zs = mydecode zs
18:38:51 <Cale> Yeah, if you ever want to explain lambda to mathematicians, basically, ↦ is the symbol to use. :)
18:39:16 <adu> i explained lambdas to my gf yesterday
18:39:23 <lispy> f = λn ↦ aⁿ
18:39:37 <LegendaryPenguin> what is     Occurs check: cannot construct the infinite type: a = [a]
18:39:43 <ski> adu : how went it ?
18:39:49 <LegendaryPenguin> i have mydecode [] = []
18:39:58 <Cale> (λn. a^n) = (n ↦ a^n)
18:40:02 <adu> ski: she was like: "I don't wanna hear about it, I wanna watch TV"
18:40:12 <Cale> adu: hehe
18:40:15 <Olathe> > let mydecode [] = [] in mydecode []
18:40:16 <lambdabot>  []
18:40:22 <ski> LegendaryPenguin : possibly you want to change a `:' to `++' or vice versa ..
18:40:30 <adu> ski: overall... pretty well
18:40:51 <lispy> bummer, n is the only super script letter I can find
18:41:31 <adu> i suppose its a good thing I didn't mention tangible values (TV)
18:41:33 <ski> @quote _want_
18:41:34 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
18:41:50 <Cale> mmm... go :)
18:41:54 <adu> mmm
18:42:04 <stepcut> go has destructive updates...
18:42:07 <lispy> she knew about FP at age 11?
18:42:32 <adu> stepcut:  if thats what you want to call capturing...
18:42:35 <ski> being the daughter of SPJ, she may have had no choice
18:42:40 * lispy nods
18:43:00 <adu> ski: you're SPJ's daughter?
18:43:18 <ski> adu : no, that Sarah in the quote is
18:43:23 <lispy> oh yay, we get smileys, in unicode: ⍨ ⍩ ⍢ ⍤
18:43:52 * ski hates programs that replace proper smileys with such symbols
18:44:09 <adu> o
18:44:32 <FunctorSalad> lispy: not implemented by DejaVu Sans
18:44:52 <chrisdone> ski: such as gmail
18:45:11 <chrisdone> it messes up my code with stupid smiley animations
18:45:12 * bd_ wonders why recode's dump-with-names insists on giving french names for everything
18:45:19 <ski> chrisdone : that may possibly be
18:45:21 * stepcut hates it when programs replace -r with -are
18:46:15 * adu hates it when programs autoreplace anything
18:46:36 <lispy> this makes me think of knuth
18:46:51 <lispy> I wonder how he'd respond to the typical teenager sms slang
18:46:57 <adu> like when I'm tying instructions on how to use the command line in word and I see "Grep" and think to myself, did I capitalize that?
18:49:03 * adu fears the day when dialog boxes present options "send private data to M$" and "anonymity" and after you choose, it decides you didn't want anonymity after all, because what you just did with your mouse must be a spelling mistake...
18:50:25 <Cale> There is a moderately trivial solution to that problem.
18:50:43 <Cale> (the problem of software which sends data to MS)
18:50:57 <adu> GNU?
18:51:17 <Cale> yeah
18:52:23 <adu> Cale: that reminds me, when you write something in C, and you license with GPL, and give copyrights to FSF, then you're GNU, but when you write something in Haskell, and give copyrights to h.o, and package with hackage, then what are you? HNU?
18:52:38 <Cale> hehe
18:52:43 <BMeph> "Friends don't let Friends Code in C." ;)
18:52:47 <Cale> Well, usually I BSD license things, actually.
18:53:03 <Cale> and I don't give the copyrights away
18:53:15 <adu> well, I noticed hackage is strict that you have a license, but not over which one you use...
18:53:20 <Cale> right
18:53:48 <ski> i thought typically GPL licenced programs didn't assign copyright to FSF
18:54:01 <adu> but like i'm wondering what tag-line to use in the manpage, like most other manpages say "Linux" or "GNU" or "BSD Commands"
18:54:09 <adu> but the only thing i can thing of is "Haskell"
18:54:13 <adu> is that appropriate?
18:55:03 <Cale> Tagline?
18:55:21 <chrisdone> did some kind of split just happen?
18:55:25 <ski> yes
18:55:34 <chrisdone> good
18:57:54 <adu> Cale: like category/distribution type thing
18:58:33 <Cale> mmm... well, I suppose you could if you want. You could also just put your own name or something :)
18:58:46 <adu> o, i'm too modest to do that
19:01:04 <adu> I'd rather inadvertently start the HNU project, just by putting the same silly category name in my manpages :)
19:04:43 <hansfbaier> adu: whats h.o.? and HNU?
19:05:03 <adu> hansfbaier: haskell.org
19:05:20 <hansfbaier> adu: ah, ok, thanks.
19:05:41 <adu> HNU is like GNU only the software is written in Haskell, i dunno, i just made it up
19:05:46 * ski idly wonders whether there's a top-level domain `borg'
19:05:53 <hansfbaier> adu: Haskell.org has a lot of good programmers even many with academic degrees, but not one decent web designer.
19:05:56 <adu> ski: i think theres a b.org
19:06:35 <adu> hansfbaier: i think haskell.org/ghc is pretty sweet
19:07:23 <hansfbaier> Theorem: { x | x is haskell programmer } => x does not know CSS
19:07:43 <hansfbaier> adu: I like the GHC design, but haskell.org looks stale....
19:08:12 <adu> hansfbaier: maybe you should submit a css file
19:08:31 <chessguy> hansfbaier: i'm a counterexample
19:08:37 <chessguy> QED
19:08:44 <rwbarton> speaking of CSS, what happened to hoogle?
19:08:55 <hansfbaier> adu: I cant, I am a haskell programmer (and I have no talent for design) :)
19:09:14 <rwbarton> does it look funny for other people (white on white text "Searching for ...")?
19:09:16 <hansfbaier> adu: Here is my reference for a programming language website: http://www.ruby-lang.org
19:09:17 <adu> hansfbaier: lol
19:09:28 <hansfbaier> adu: compare that to haskell.org
19:09:50 <chessguy> haskell.org is...functional :)
19:10:06 <chessguy> as in, function over form
19:10:11 <jeffz> hansfbaier: I think haskell.org looks better, ruby-lang only consumes 30% of my screen, haskell 98%
19:10:12 <ski> hansfbaier : a comprehension is not a proposition
19:10:21 <Olathe> ruby-lang.org is beautifully objectified.
19:10:35 <Cale> I know CSS, I'm just incredibly clumsy with it because I don't know all the quirks of noncompliant browsers.
19:10:45 <rwbarton> say['love'] = "*love*"
19:10:48 <b\6> should just code to the standard.
19:10:58 <rwbarton> ? who needs type checking when you can just apply any operation to any type?
19:11:09 <jtraub> Hello!
19:11:18 <jtraub> I tried to use hoogle
19:11:20 <hansfbaier> ski: er, ok. Hm.: ﻿Theorem:  x element { x | x is haskell programmer } => x does not know CSS
19:11:28 <jtraub> i want to find maximum in the list
19:11:34 <jtraub> and position of this maximum
19:11:44 <jtraub> i don't want reinvent wheel
19:11:45 <ski> @type Data.List.maximum
19:11:46 <lambdabot> forall a. (Ord a) => [a] -> a
19:11:53 <hansfbaier> ski: Are you strongly typed?
19:12:13 <ski> hansfbaier : yes
19:12:24 <Olathe> > -Infinity
19:12:25 <lambdabot> Terminated
19:12:31 <Olathe> > log 0
19:12:33 <lambdabot>  -Infinity
19:12:42 <rwbarton> > maximum . (`zip` [0..]) $ [3, 4, 22, 7]
19:12:43 <lambdabot>  (22,2)
19:12:53 <jtraub> ski, i know. i am using this function. But also i need to know where this maximum is located
19:12:54 <hansfbaier> sk :)
19:13:13 <jtraub> rwbarton, but how it works?
19:13:22 <hansfbaier> chessguy: That means you are volunteering?
19:13:23 <rwbarton> > (`zip` [0..]) $ [3, 4, 22, 7]
19:13:24 <lambdabot>  [(3,0),(4,1),(22,2),(7,3)]
19:13:25 <adu> hansfbaier: thats all CSS you know...
19:13:33 <rwbarton> then maximum works on the first half of the pair first
19:13:39 <ski> > maximum . (`zip` [0..]) $ [3, 4, 22, 7, 22]
19:13:40 <lambdabot>  (22,4)
19:13:41 <jtraub> rwbarton, maximum accepts lists
19:13:43 <jtraub> :-)
19:13:55 <ski> > maximum . (`zip` [0..]) $ [22,22..]
19:13:56 <chessguy> hansfbaier:  i know CSS, i didn't say i know what would look good
19:13:58 <lambdabot>  mueval: Time limit exceeded
19:13:58 <jtraub> arghh.. completely don't understand
19:14:21 <jtraub> > maximum [(1,2),(2,5)]
19:14:22 <lambdabot>  (2,5)
19:14:29 <jtraub> > maximum [(1,6),(2,5)]
19:14:31 <lambdabot>  (2,5)
19:14:37 <hansfbaier> ﻿Theorem: x element { x | x is haskell programmer } => x does not know how to handle CSS properly in order to get a good looking result
19:14:39 <jtraub> hm...
19:14:54 <adu> Cale: as long as you stay away from float, absolute, color names, media types, and data urls, you should be fine!
19:14:54 <hansfbaier> ﻿Theorem: x element { x | x is haskell programmer } => x has no web design skills
19:15:10 <Cale> adu: also, margins!
19:15:23 <FunctorSalad> hansfbaier: hmm that can be simplified
19:15:25 <adu> Cale: bah, margins can bulge... whatever
19:15:37 <chessguy> hansfbaier:  ok, i think you've made your ridiculous, nonsensical point, why don't you move on?
19:16:01 <hansfbaier> chessguy: http://www.csszengarden.com/
19:16:01 <lambdabot> Title: css Zen Garden: The Beauty in CSS Design
19:16:14 <adu> if i make a new CSS, can we try it out for a week and see if ppl complain?
19:16:17 <smoofra> is there any way to do this?  data Foo a b = Bar (a -> b) | Baz (a -> c) (Foo c b)
19:16:18 <FunctorSalad> hansfbaier: or actually, unrestricted set comprehension is inconsistent
19:16:54 <hansfbaier> FunctorSalad: Ah, should be quantified, but so much for now.
19:16:55 <jeffz> Cale: yui-grids helps minimise the amount of quirks you have to deal with in terms of consistent sizing/spacing
19:16:58 <smoofra> as in, define some sort of heterogeneous container type
19:17:10 <Cale> jeffz: yui?
19:17:12 <FunctorSalad> yeah we need some container type for the haskell programmers
19:17:24 <FunctorSalad> sorry I'll be quiet now ;)
19:17:25 <jeffz> Cale: yahoo ui library
19:17:28 <Cale> ah
19:17:34 <bd_> smoofra: 'c' would need to be in the argument for Foo's type constructor, ie, data Foo a b c = Bar (a -> b) | Baz (a -> c) (Foo c b a)
19:17:35 <jeffz> Cale: a bunch of bsd licensed web things
19:17:42 <jeffz> Cale: http://developer.yahoo.com/yui/grids/
19:17:43 <lambdabot> Title: Yahoo! UI Library: Grids CSS
19:18:03 <ski> smoofra : GADT or existentials
19:18:06 <Cale> I'll keep that in mind if I ever take a web job again :)
19:18:28 <ski> smoofra : existentials is like
19:18:31 <chessguy> i've heard good things about YUI
19:18:42 <Botje> so when is HUI coming out? :)
19:19:08 <chessguy> ]what a bunch of Hooey
19:19:15 <ski>   data Foo a b = Bar (a -> b)
19:19:15 <ski>                | forall c. Baz (a -> c) (Foo c b
19:19:20 <ski> GADTs is like
19:19:33 <adu> Botje: I think the web developers will have to agree on an xml interface first
19:19:59 <smoofra> ski: aaah yea existentials is what i need
19:20:02 <adu> Botje: there are too many xml libraries for haskell
19:20:03 <ski>   data Foo :: * -> * -> *
19:20:06 <ski>     where
19:20:13 <ski>     Bar :: (a -> b) -> Foo a b
19:20:13 <ski>     Baz :: (a -> c) -> Foo c b -> Foo a b
19:20:30 <dons> adu, oh hehe
19:20:35 <dons> how the tables have turned!
19:20:38 <ski> these are equivalent ways of expression
19:20:41 <Botje>  :)
19:21:24 <Cale> Somehow XML has a nasty habit of making absolutely horrible anything that it touches.
19:21:24 <smoofra> ski: thanks!
19:21:28 <ski> yw
19:21:42 <adu> i think the problem is that there isn't any Haskell on Rails yet, everybody has their own fav. xml lib
19:22:04 <erikc> Cale: indeed, particularly when people attempt to cram non-hierarchal data into it
19:22:11 <ski> (smoofra : also, you may consider allowing empty function lists, too .. the GADT syntax will allow that if you want it )
19:22:26 <bjrn> adu: Well there's always http://seenonslash.com/node/2985
19:22:31 <lambdabot> Title: California Can't Perform Pay Cut Because of COBOL | Seen On Slash
19:22:38 <Olathe> > let findMax [x] = (0, x); findMax (x:xs) = findMax' (0, x) 1 xs where findMax' result _ [] = result; findMax' (maxPos, max) pos (x:xs) = findMax' (if x > max then (pos, x) else (maxPos, max)) (pos + 1) xs in findMax [1.0, 2.0, 3.0, 4.0, 3.5]
19:22:39 <lambdabot>  (3,4.0)
19:23:07 <Olathe> I like the zip one better.
19:24:02 <ski> > let findMax [x] = (0, x); findMax (x:xs) = findMax' (0, x) 1 xs where findMax' result _ [] = result; findMax' (maxPos, max) pos (x:xs) = findMax' (if x > max then (pos, x) else (maxPos, max)) (pos + 1) xs in findMax [1.0,3.0,2.0,3.0]
19:24:03 <lambdabot>  (1,3.0)
19:24:49 <adu> perhaps if all Haskell xml libs were to have a single user manual, then we could hide the fact that there were so many...
19:24:55 <FunctorSalad> > foldl1 max [3,2,1,5]
19:24:56 <lambdabot>  5
19:25:51 <twanvl> > let findMax = maximumBy (comparing snd) . zip [1..] in findMax [1.0,3.0,2.0,3.0]
19:25:53 <lambdabot>  (4,3.0)
19:26:08 <FunctorSalad> nvm, missed that you want the index
19:26:28 <BMeph> Olathe: You mean the Schwartian Transform method? ;)
19:26:34 <Olathe> Heheh
19:26:35 <Olathe> Yes.
19:26:54 <FunctorSalad> @type comparing
19:26:55 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:27:50 <ski> > let findMax xs = (fromJust (findIndex (m ==) xs),m) where m = maximum xs in findMax [1.0,3.0,2.0,3.0]
19:27:51 <lambdabot>  (1,3.0)
19:28:12 <adu> "Haskell on Handrails is composed of HaXml, HXML, HXT, HSP, HappS, and WASH..."
19:28:22 * adu ponders
19:30:29 <ski> ^Z
19:32:05 <adu> dons: in your package count, did you count "safe" twice?
19:34:00 <bjrn> Has anyone done any work on getting Haskell on the video cards, such as Nvidias CUDA?
19:35:07 <Olathe> bjrn: It's possible, but rather unlikely.
19:35:31 <jeffz> adu, you forgot HXQ
19:35:39 <Cale> bjrn: You mean using the video cards to evaluate Haskell code?
19:36:06 <jtraub> thank you all again
19:36:18 <adu> jeffz: oops, heh my point exactly, too many web/xml libs... not enough time
19:36:20 <jtraub> it is time to dive into book reading :-)
19:36:57 <Spark> bjrn: to compile haskell down to cuda?
19:37:07 <Spark> bjrn: or to compile haskell down to whatever cuda compiles to
19:37:45 <Spark> the former is probably possible, but it would have to be a special haskell with lots of concurrency features, probably
19:37:58 <Spark> the latter is probably not possible since i'm not sure that side of things is even documented
19:38:11 <jeffz> Spark, it's not documented but some people have explored it http://www.cs.rug.nl/~wladimir/decuda/
19:38:14 <lambdabot> Title: decuda and cudasm main page
19:40:09 <adu> bjrn: do you mean for parallelizing with the GPU?
19:41:04 <Spark> running a single thread on the gpu would be fairly pointless :)
19:42:23 <smoofra> ski: wooooo it works.  http://hpaste.org/9815   that's a pretty neat trick for a statically typed langage
19:44:07 <seanl> bjrn: I am working on that actually
19:45:53 <seanl> targeting NVIDIA GPUs only, tho
19:49:52 <hansfbaier> smoofra: whats that good for?
19:51:39 <smoofra> hansfbaier: nothing :-)   but i was wondering what a delimited version of Control.Monad.Cont would look like, and i was thinking it would need a datatype like that
19:51:40 <aculich> seanl: i'm interested in haskell for the nvidia gpus... how far along are you?
19:51:48 <seanl> hm....
19:51:49 <seanl> basically
19:52:06 <hansfbaier> smoofra: I see.
19:52:13 <seanl> the boilerplate code for the array operations such as map scan filter ....
19:52:16 <seanl> are pretty much done
19:52:57 <seanl> and the gadt module which describes the code to run on gpu is more than half-way thru
19:53:19 <seanl> so
19:53:41 <seanl> now the translation from Haskell to CUDA is in progress
19:54:18 <aculich> well, if you need any help debugging, testing, or in some other ways contributing i'd be happy to lend a hand
19:54:26 <seanl> thanks
19:54:28 <seanl> :)
19:56:03 <jtraub> http://projecteuler.net/index.php?section=problems&id=14
19:56:12 <lambdabot> Title: Problem 14 - Project Euler
19:56:17 <jtraub> my solution is at http://hpaste.org/9816
19:56:26 <aculich> seanl: are you just working on it for fun? or is it a more formal project?
19:56:30 <jtraub> it works fine but it takes too long
19:56:39 <jtraub> to show me the answer
19:56:50 <seanl> oh
19:56:55 <seanl> aculich: it's my phd work
19:57:04 <jtraub> i guess that i need to use common technique to optimise it
19:57:04 <sw17ch> jtraub, mmm.. that's the collatz conjecture isn't it?
19:57:07 <seanl> aculich: and i am also interning at nvidia
19:57:11 <jtraub> sw17ch, yep
19:57:19 <sw17ch> jtraub, work backward, i'm guessing that's more effective
19:57:20 <aculich> aha!
19:57:37 <jtraub> sw17ch, can you give me some examples?
19:57:59 <seanl> aculich: if you know dons and where he's from, i would say it is another UNSW research
19:58:01 <jeffz> b\6: did you work out how to return the remaining input from your parser?
19:58:34 <sw17ch> jtraub, let me think for a second
19:58:53 <jtraub> sw17ch, i am complete newbie in haskell. so...
19:58:58 <aculich> yeah, i think i read something a while ago that mentioned what you were doing with the cuda/haskell stuff, but i didn't make the connection until now
19:59:05 <stepcut> alright! which one of you implemented a non-transitive version of (==) and then filed a bug against nub!
19:59:14 <sw17ch> jtraub, i've only worked collatz backward on paper... i haven't implemented it :)
19:59:56 <seanl> aculich: I see... I really hope to release the first working version sometime soon. So, wish me luck :)
20:00:15 <sw17ch> jtraub, do you understand how to work it backward?
20:00:38 <aculich> seanl: great! i do wish you the best of luck and i'm sure i'll be one of the first people to download and play around with it
20:00:52 <seanl> aculich: thanks :)
20:00:57 <aculich> if you have a mailing list or something of the sort to keep up with the development, feel free to add me to your list: aculich@gmail.com
20:01:28 <jtraub> sw17ch, i am not sure if i understand the same thing as backward
20:01:57 <sw17ch> jtraub, http://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Collatz-graph-all-30-no27.svg/100px-Collatz-graph-all-30-no27.svg.png
20:01:59 <lambdabot> http://tinyurl.com/69oxxf
20:02:03 <sw17ch> flip that graph over
20:02:04 <sw17ch> that's what you want
20:02:16 <sw17ch> so, you work backward from one
20:02:45 <seanl> aculich: yup. thanks. currently i don't have any public mailing list since we are all from the same research group. But I will surely add you once I create one.
20:02:52 <sw17ch> jtraub, i'm pretty sure you end up with a binary tree with 1 as the root node
20:03:01 <sw17ch> and each branch is the reverse operation
20:03:47 * codacola is still pondering what that tree is for
20:05:05 <jtraub> sw17ch, in Python i would lookup trought previous computation
20:05:18 <jtraub> because i store them in list
20:05:29 * sw17ch thinks a little more
20:06:31 <Olathe> You could use an array to good effect.
20:06:51 <b\6> jeffz: sort of. i see how to get the unread input. currently i pass a 'data Connection' to functions that send to/receive from the server. Connection has an IO Handle for writing and the String from hGetContents. the problem is that on the second parse, i'm parsing the same string. looking into state monads or something.
20:06:59 <jtraub> can you advise some resource on optimization?
20:07:32 <jtraub> i mean i didn't know about recurson with accumulator
20:08:26 <jeffz> b\6: it's far simpler than that :)
20:08:38 <TSC> @pl (\ (a,b) (a',b') -> (a+a',b+b'))
20:08:39 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:08:44 <TSC> Thanks, lambdabot!
20:08:49 <jeffz> b\6: lookup getInput in your parsec documentation
20:08:58 <Olathe> In position 1, fill it with zero, since it's zero steps to one. Then, start with n. If you reach a filled array element, add one and write it to the previous thing in the chain, and repeat until you get back to n.
20:09:24 <jeffz> b\6: for example, you can just return a tuple of your result plus the remaining input using the value of  getInput
20:10:14 <b\6> jeffz: yeah, but isn't that bad? it's like the examples of the development of the state monad because nobody wants to pass a new seed to random, etc.
20:12:22 <jeffz> b\6: I don't have any personal issues with it :) it's simple and gets the job done.
20:12:30 <b\6> ok.
20:12:37 <sw17ch> jtraub, here's my collatz stuff if you wanted a second look at something
20:12:37 <sw17ch> http://hpaste.org/9816#a1
20:12:38 <b\6> think i get it.
20:12:53 <b\6> jeffz: appreciate you looking in on me. that was practically psychic.
20:13:16 <jeffz> b\6: I read the logs to see if you had said anything ;)
20:14:04 <seydar> whats the preferred way to do concurrency?
20:15:06 <b\6> i see people doing forkIO.
20:15:17 <jtraub> sw17ch, thanks
20:16:06 <seydar> b\6: forkIO takes advantage of multiple cores, right?
20:16:20 <b\6> not sure. think so.
20:17:03 <seydar> nice. what are some other methods of achieving concurrency?
20:17:05 <b\6> think i remember reading something from dons where he used forkIO and timed with more and more processors.
20:20:37 <chrisdone> forkIO threads cleverly move between OS threads
20:21:46 <Jedai> seydar: Strategies
20:22:01 <Jedai> seydar: especially par
20:22:17 <seydar> what's Strategies?
20:22:48 <Jedai> seydar: They're a way to annotate lightly a pure computation to compute it in parallel
20:23:12 <sw17ch> @index sort
20:23:12 <lambdabot> Data.List
20:23:49 <seydar> ah
20:23:50 <seydar> sweet
20:24:00 <Jedai> seydar: A simple and inefficient example would be : fib 0 = 1; fib 1 = 1; fib n = a `par` b `par` a+b where a = fib (n-1); b = fib (n-2)
20:24:28 <seydar> neato
20:24:39 <seydar> par is available in GHC, or just GPH?
20:24:47 <jeffz> seydar: http://www.haskell.org/ghc/docs/latest/html/libraries/ look at Control.Parallel for par and Control.Concurrent for the other stuff
20:24:47 <lambdabot> Title: Haskell Hierarchical Libraries
20:24:56 <seydar> sweet
20:24:58 <Jedai> seydar: Which would execute both recursive call to fib in parallel (well, this is very bad really but...)
20:24:58 <seydar> thanks
20:25:12 <Jedai> seydar: GPH is in GHC now
20:25:34 <seydar> huzzah!
20:25:43 <seydar> ok, gotta roll. but thank you!
20:26:11 <Jedai> seydar: If you go to dons blog he has a post where he shows that by improving this example a little bit you can easily surpass the equivalent naive C code
20:36:34 * adu *sighs*
20:37:57 <sw17ch> ... jtraub quit :(
20:38:08 <sw17ch> i think i misdirected him
20:38:15 <sw17ch> ... i *know* i did
20:38:16 <sw17ch> :)
20:38:21 <adu> sw17ch: ya, i was just about to tell him about compareBy
20:38:36 <sw17ch> @src compareBy
20:38:37 <lambdabot> Source not found. You untyped fool!
20:38:41 <sw17ch> @index compareBy
20:38:42 <lambdabot> bzzt
20:38:43 <adu> or was it sortBy...
20:38:46 <adu> i forget
20:38:47 <sw17ch> heheh
20:38:51 <adu> there was something like that
20:38:59 <sw17ch> either way... i think i have a much better method...
20:39:10 <sw17ch> i haven't solved 14 yet...
20:39:17 <sw17ch> i think i'm two lines away though
20:39:29 <adu> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html#v:on
20:39:31 <lambdabot> Title: Data.Function, http://tinyurl.com/yrwgjc
20:39:40 <adu> ya sortBy
20:40:17 <adu> 14?
20:40:26 <adu> @src sortBy
20:40:26 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:42:02 <adu> something like: head . (sortBy (compare `on` snd)) . (zip [1..])
20:42:52 <adu> o wait, that would be minimum
20:42:56 <adu> n/m
20:48:34 <sw17ch> @src (\\)
20:48:35 <lambdabot> (\\) = foldl (flip delete)
20:52:19 <Cale> I like that definition :)
20:52:59 <b\6> fold spindle mutilate
20:58:29 <chrisdone> bah I hate imperative code
20:58:52 <dibblego> love it
20:58:58 <chrisdone> I'm looking trying to hack some C code and it's just got globals and state all over the place. about as composable as cats
20:59:21 <Boney> Mmm,  composable cats.
20:59:25 <adu> lol
20:59:31 <dsrogers> cats are plenty composable.
20:59:34 <dsrogers> just add salt.
20:59:35 <adu> lolol
20:59:45 <Boney> I can imagine a research paper title. "Composable cats - ..."
21:00:35 * chrisdone chuckles
21:00:39 <Boney> chrisdone: Anyway, I know what you mean.  Today is my python-writing day.
21:01:42 <adu> "... the higher-order quandle boundary enables strict polymorphic cat homomorphisms which allows cats to be endomorphic, and hence, composable!"
21:02:12 <adu> Boney: (from the conclusion of that research paper)
21:02:46 <b\6> 5 minutes and nobody said catamorphism yet.
21:03:22 <Boney> heh,
21:03:49 <Boney> More realisticly,  Who's going to write the next "Monads are like cats" article.
21:03:53 <dsrogers> that's because there isn't one.
21:04:11 <dsrogers> cats are not homomorphic to anything but themselves.
21:04:17 <adu> @remember b\6 5 minutes and nobody said catamorphism yet.
21:04:18 <lambdabot> I will never forget.
21:06:12 <adu> how does one dynamically load a config file and execute it like xmonad?
21:14:43 <Jedai> adu: hs-plugin ? Hint maybe ?
21:14:54 <Jedai> adu: Anyway you have to use the GHC API
21:15:11 <adu> Jedai: isee
21:19:30 <jeffz> adu, seems to use runProcess to call ghc
21:20:08 <adu> jeffz: o that makes sense
21:21:43 <crutcher> hello. The prelude docs say "Instances of both Monad and Functor should additionally satisfy the law:  fmap f xs  ==  xs >>= return . f"
21:22:25 <crutcher> This implies that Monads should be Functors. but the Monad class does not extend the Functor class. Can someone give me some background on why?
21:22:49 <adu> crutcher: no, not all Monads are functors
21:23:06 <jtraub> How can i remove duplicates from list?
21:23:13 <jtraub> i mean i neead only unique values
21:23:13 <adu> jtraub: nub?
21:23:27 <jtraub> adu, 3rd day with Haskell :-(
21:23:29 <crutcher> adu: so, should the docs be updated? What _should_ it say?
21:23:41 <adu> jtraub: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:nub
21:23:43 <lambdabot> Title: Data.List, http://tinyurl.com/yhrw65
21:24:23 <adu> crutcher: what's wrong with what it says?
21:24:52 <crutcher> Well, for starters, Monad instances can't satisfy that law unless you make them Functors.
21:25:02 <adu> true
21:26:03 <crutcher> so if you are gonna define a new Monad, that's very sparse discussion of the requirements, and the situations in which it is okay to break them.
21:26:16 <adu> crutcher: but I don't see how "Functor X" and "Monad X" instances require "Functor a => Monad a" thats where your logic eludes me
21:27:03 <jtraub> adu, thanks :-)
21:27:10 <jtraub> adu, it works!
21:28:07 <adu> crutcher: well, if you're updating the docs, I would say something to the effect: "If a type is an instance of Functor but not monad, then ..." and "If a type is an instance of Monad but not Functor, then ..."
21:28:15 <adu> crutcher: would that make more sense?
21:28:36 <crutcher> well, 'fmap f xs' types xs as (Functor a), and 'xs >>= return .f' types xs as a Monad a, so that's where i'm getting it.
21:28:41 <adu> crutcher: or would examples be best?
21:29:38 <crutcher> adu: whoa, I'm not updating the docs, at least not yet :) I'm still trying to understand the difference. I just noticed that the docs seem to not make sense.
21:29:41 <adu> crutcher: right, the first 6 words say that too "Instances of both Monad and Functor" means only those types with are instances of both
21:30:01 <crutcher> I guess you could read it that way.
21:30:09 <adu> crutcher: how do you read it?
21:30:16 <crutcher> Probably the way it was meant to be read.
21:30:52 <crutcher> Um: For each [instance of Monad], [instance of Functor] : must satisfy ...
21:31:42 <adu> hmm ya, i guess you could read it that way
21:31:52 <crutcher> Maybe: "Types which are instances of both Monad and Functor should additionally satisfy the law ..."
21:32:03 <adu> but if i were to say that i would say "Both Monad and Functor instances..."
21:32:23 <crutcher> again, I'd read that with the same ambiguity about the grouping
21:33:01 <crutcher> the question is what's plural, and maybe we could just avoid that?
21:33:16 <crutcher> okay, so is there a good discussion of Functors anywhere?
21:33:27 <adu> how about "A type should implement the following if and only if it is an instance of Monad and Functor at the same time"
21:33:29 <crutcher> and why I would want a Monad to _not_ be a Functor?
21:33:47 <crutcher> but it isn't implementing it, it is a constraint :)
21:34:37 <crutcher> "A type that is an instance of both Monad and Functor should satisfy the additional law ..."
21:34:57 <rwbarton> But technically it is the instances that must satisfy the law.
21:35:08 <crutcher> ha!
21:35:23 <adu> crutcher: Parser is a Monad but not a Functor
21:35:57 <crutcher> adu: can you think of docs which discuss the diference?
21:36:21 <adu> crutcher: well, one is for "do"ing and one is for "map"ing
21:37:31 <rwbarton> mathematically, every monad is a functor, and you can write a Functor instance for any Monad by using that equation fmap f xs  ==  xs >>= return . f
21:38:05 <adu> crutcher: and ZipList is a Functor but not a Monad
21:38:21 <crutcher> well Functor but not Monad makes more sense.
21:38:53 <adu> so 'Parser' could be a Functor?
21:39:00 <crutcher> rwbarton: okay, that's what I thought. So we can build fmap for any Monad, even if it is a bit odd?
21:39:04 <rwbarton> Parser is a Functor
21:39:22 <adu> no it isn't
21:39:31 <rwbarton> Prelude> :m Text.ParserCombinators.Parsec
21:39:31 <rwbarton> Prelude Text.ParserCombinators.Parsec> :t fmap :: (a -> b) -> (Parser a) -> (Parser b)
21:39:34 <rwbarton> fmap :: (a -> b) -> (Parser a) -> (Parser b) :: (a -> b) -> Parser a -> Parser b
21:40:30 <rwbarton> crutcher: Right.  I don't think it is ever "a bit odd".  I also don't understand why Functor is not a superclass of Monad, but I would guess that it is for historical reasons.
21:40:38 <adu> rwbarton: then why doesn't it have an instance declaration?
21:41:52 <noecksit_> how would you write a type synonym with a data type that includes a polymorphic value?
21:42:13 <rwbarton> adu: I'd guess just because Parsec has like 10 submodules and you (and I) haven't found which one contains the instance :)
21:42:33 <dons> type T a = [a] -- ?
21:43:02 <crutcher> rwbarton: is there any move to clean that up?
21:43:14 <mgsloan> it'd be sweet to have auto instances of classes in cases where other classes are instanced
21:43:30 <mgsloan> so, by instancing Monad, you get Functor for free
21:43:36 <adu> rwbarton: oic its Prim
21:43:44 <noecksit_> what i mean is I have "type MyType a = ReaderT AnotherType IO" and "data AnotherType a = AnotherType {a :: String, store :: ListStore a}"
21:44:13 <adu> rwbarton: and its Functor (GenParser tok st) not Parser
21:44:15 <rwbarton> crutcher: it's only the documentation that's hard to find
21:44:20 <sw17ch> working collatz backward is actually a lot harder than i thought
21:44:28 <rwbarton> adu: right, Parser = GenParser Char ()
21:44:32 <sw17ch> > 2 ^ 25
21:44:33 <lambdabot>  33554432
21:44:36 <sw17ch> yep
21:44:51 <noecksit_> so what happens is I get kind errors, i thought it might be "type MyType a = ReaderT AnotherType a IO" but that is a kind error also
21:45:28 <crutcher> okay, thanks adu and rwbarton. I gotta head out. That clears up some things for me. New Monads should be Functors
21:45:36 <noecksit_> or maybe that needs to be an instance of a class or smthing
21:45:52 <rwbarton> noecksit_: type MyType a = ReaderT (AnotherType a) IO
21:46:58 <rwbarton> noecksit_: (... if that's not allowed, then you can't do it)
21:47:06 <noecksit_> rwbarton: oh yeah, i thought i tried that too, but now that i see closely its another error
21:48:17 <rwbarton> noecksit_: I'm pretty sure you can't write  type Compose a b c = (a b) c, for example
21:48:42 <rwbarton> ... but I am wrong
21:49:26 <noecksit_> i always get scared of kind errors
21:50:52 <rwbarton> (I meant a (b c), but same thing...)  what's the error with  type MyType a = ReaderT (AnotherType a) IO  ?
21:51:23 <rwbarton> Oh, you mean elsewhere maybe
21:51:49 <mgsloan> I'm reading RWH ch 18, and on the topic of alloca, it says "The allocated memory is then released once the argument function exits.".  Out of curiosity, what happens if the argument function throws an error?
21:52:24 <noecksit_> rwbarton: yes, its another kind error now
21:56:06 <mxc> anyone here having luck with building the darwinports distro of yi 0.4.3?
22:00:44 <adu> mxc: once, long ago
22:00:58 <adu> mxc: I found that darcs yi is much easier to build
22:02:27 <noecksit_> oh man, i caused some kind of GHCi runtime linker error in bytestring
22:03:56 <noecksit_> surprsinigly it works compiling with ghc
22:04:01 <lispy> noecksit_: like this? http://www.nabble.com/unknown-flags-scramble-td19077211.html
22:04:07 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - unknown flags scramble
22:06:29 <noecksit_> lispy: no, not really, it says "found a duplicate definition for symbol fps_minimum while processing object file"
22:07:21 <noecksit_> i did just upgrade it with cabal-install though, im not sure if that did smthing
22:09:46 <lispy> noecksit_: have you restarted ghci since the upgrade?
22:10:05 <lispy> noecksit_: also, if you're using -package, are you sure you're specifying the right version?
22:10:24 <lispy> noecksit_: you could try, ghc-pkg unregister on the old one
22:12:11 <noecksit_> lispy: you're right i have one in /usr/lib and one in my home directory, i think cabal-install installed everything in my home dir
22:13:21 <lispy> noecksit_: the default for cabal-install is the homedir
22:13:23 <lispy> $HOME
22:13:50 <cjs> So if I have a Cabal package with, say, Foo.hs and Bar.hs, containing the Foo and Bar modules, respectively, I can build "foo" and "bar" executables using "Executable foo main-is: Foo.hs" and "Executable bar main-is: Bar.hs", right?
22:15:00 <thoughtpolice> yes
22:16:30 <cjs> Great. And just out of curiousity, is there a way to get cabal to put its intermediate files, etc., in another directory?
22:17:32 <lispy> cjs: other than dist you mean?
22:17:32 <noecksit_> well, i unregistered bytestring from the global dir, but now it cant load Data.ByteString, how could i make ghci use my home dir?
22:17:43 <lispy> cjs: er, I think dist is the default anyway
22:18:06 <lispy> noecksit_: try a cabal install again
22:18:11 <lispy> cabal-install taht is
22:18:33 <cjs> Yeah, like to move it somewhere else out of the package entirely.
22:18:34 <lispy> noecksit_: or talk to somone like dcoutts_
22:18:39 <Cale> noecksit_: Unregistering things that come with GHC is usually a bad idea.
22:18:56 <cjs> And does it put the .o files and all in dist? I thought that was just for the actually package itself.
22:18:59 <lispy> cjs: I'd check the options to configure, never tried to do what you want
22:19:01 <noecksit_> lispy: it said "resolving dependencies..." and that was it
22:19:06 <Cale> noecksit_: Depending on circumstances, you may end up reinstalling GHC if you do that...
22:19:24 <cjs> Yeah, configure doesn't have anything interesting for that, as far as I can see.
22:19:31 <lispy> noecksit_: okay, that's been fixed BTW.  That just means it didn't think there was anything to do, eg it sees the bytestring in your homedir
22:19:46 <lispy> cjs: not sure then
22:20:12 <lispy> Cale: well, his other problem was that after installing a newer bytestring he couldn't load bytestring
22:20:25 <lispy> Cale: can you recommend something for that?
22:20:26 <cjs> Oh, wait, I bet I can use something like --ghc-options="-hidir blah -odir blah".
22:20:40 <Cale> I usually just try to stick to the bytestring that comes with GHC.
22:21:03 <Cale> Upgrading bytestring can cause problems with various other modules, GHC-as-a-library in particular.
22:21:40 <Cale> Is there a package that requires a newer bytestring?
22:22:06 <lispy> Well, there was that readFile bug a while back, did that get ported into the version of bytestring that comes with GHC?
22:22:22 <Cale> I'm not sure.
22:22:27 <Cale> What was the bug?
22:22:36 <sw17ch> http://hpaste.org/9817
22:22:44 <sw17ch> I made a reverse Collatz grapher
22:22:49 <sw17ch> if any one is interested
22:22:53 <sw17ch> require graphviz to be installed
22:22:54 <noecksit_> Cale: what i did was I upgraded with "cabal upgrade" which upgraded everything that was old
22:23:03 <Cale> ah
22:23:07 <Cale> :/
22:23:42 <noecksit_> i dont think its a bug with bytestring in itself, it just put package.conf in my home dir whereas its usually kept in /usr/lib
22:24:26 <sw17ch> http://sw17ch.com/code/collatz.png
22:24:33 <noecksit_> i wonder if i can reregister it after ive unregistered it and then maybe unregister the one in my home dir
22:24:40 <sw17ch> that's an example of waht it produces... the graph tehre is at a depth of 11
22:24:57 <sw17ch> if any one finds it interesting, or a place where i'm making a dumb mistake, let me know :)
22:26:09 * sw17ch goes to bed
22:45:00 <adu> #define cond case () of _
22:57:17 <Elly> adu: ?
22:57:41 <schoenfinkel> hello
22:58:00 <adu> Elly just thought that might help with cond expressions (using -cpp of course)
22:58:19 <Elly> er... :P
22:59:47 * stepcut notes that frisby is not on hackage
23:00:58 <adu> http://hpaste.org/9818
23:04:44 <adept> Could somebody help me with strange type issue? http://hpaste.org/9819#a0
23:06:12 <Cale> My guess is the monomorphism restriction :)
23:06:17 <Elly> Cale: what's that?
23:06:28 <Cale> Since it works fine with -XNoMonomorphismRestriction
23:06:44 <Cale> oh...
23:06:49 <Elly> what is the monomorphism restriction though?
23:07:22 <adu> adept: or take the shortcut and use -fglasgow-exts
23:07:32 <Cale> It basically says that pattern bound variables which don't have explicit type signatures must be assigned monomorphic (that is, not polymorphic) types
23:08:18 <Cale> This causes lots of confusion.
23:08:49 <adept> Cale: so if I had "numbers _ = ..", that would be OK?
23:08:55 <Cale> yeah, probably
23:09:09 <Cale> (except it wouldn't typecheck in other places)
23:10:09 <adept> Cale: thanks!
23:10:37 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}  is another way to avoid it.
23:10:53 <Cale> Personally, I think the MR should be turned into a warning at most.
23:11:02 <Cale> (maybe not even a default-on warning)
23:11:34 <dons> adept: packL = Data.ByteString.pack . map (fromIntegral . ord) = Data.ByteString.Char8.pack
23:11:35 <Cale> The problem that it tries to solve is that when you write code like  x = ...  you usually expect that x will only be evaluated once.
23:12:03 <Cale> (and then stored until it falls out of scope)
23:12:32 <Cale> However, when x is typeclass polymorphic, it's implemented as a function, and may even be applied at multiple types
23:12:47 <Cale> So you lose memoisation
23:13:36 <Cale> So to prevent people from losing memoisation in the odd case that it makes a difference and someone writes a term which is polymorphic, they decided to forbid that situation altogether.
23:13:46 <adept> i usually write declarations like "numbers =..." inside "where" clauses only, thats why I tend to forget about monomorphism restriction
23:14:29 <Cale> Elly: does that help explain it? There's a wiki article which is a little clearer perhaps...
23:14:37 <Elly> oh, okay
23:14:44 <Elly> I think it makes sense
23:15:03 <Cale> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:15:04 <lambdabot> Title: Monomorphism restriction - HaskellWiki
23:19:52 <quicksilver> althouhg "forbid the situation altogether" only means "require an explicit type signature in that case"
23:19:58 <quicksilver> so it's not *too* arduous.
23:20:35 <Cale> But it is annoying, and usually confusing.
23:21:51 <Cale> I once spent about 1/2 an hour trying to sort out why an ST action that I'd written was having its s parameter turned into () before realising that it was that the MR applied to my definition of forM (this was before forM was in the libraries)
23:22:34 <Cale> Now I just turn it off in my .ghci
23:23:05 <Cale> (so I know that if there are type errors when compiling apart from GHCi, it's probably the MR)
23:23:32 <quicksilver> Cale: I blame that on generalised defaulting, I think.
23:23:40 <syscrash> i'm reading the haskell wikibook, and it defines a Tree type "data Tree a = Leaf a | Branch (Tree a) (Tree a)"; isn't this not very useful, since branches do not contain a value?
23:23:58 <quicksilver> syscrash: it's quite common for trees to only have values at leaves.
23:24:01 <Cale> syscrash: Well, depends...
23:24:02 <dons> Cale: hah
23:24:02 <syscrash> ah ok
23:24:04 <quicksilver> tehre is more than one way to do it, of course.
23:24:08 <dons> Cale, that's really interesting.
23:24:14 <dons> MR considered obfuscating.
23:24:32 <quicksilver> removing the MR will require more annotations in code which uses numerical constants, though.
23:24:37 <quicksilver> :(
23:24:42 <Cale> dons: It is. The worst part is that usually the type errors that you get have nothing to do with the MR.
23:24:46 <quicksilver> literals, I mean.
23:24:53 <dons> Cale, yep.
23:25:12 <dons> quicksilver: only if we remove things like 'length' too.
23:25:27 <dons> i rarely rely on the MR -- though it would be interresting to see how often i do.
23:25:34 <Cale> quicksilver: Only if you care about performance, in which case, you're probably pegging the numeric types anyway.
23:25:40 <dons> right.
23:25:52 <quicksilver> Cale: no, it will require more annotations or you'll get ambiguity errors.
23:26:27 <Cale> Aren't ambiguities involving numeric stuff already handled by numeric defaulting?
23:26:29 <quicksilver> currently the MR means that one type signature 'Double' or 'Int' in one place cascades an entire system of interlocking values to a concrete type
23:27:22 <Cale> hmm... wouldn't it normally?
23:27:25 <quicksilver> Cale: only if all the classes incolved are prelude classes.
23:27:37 <quicksilver> defaulting gives up if there is a non-prelude class involved
23:27:40 <Cale> It's usually the numeric operators which cause types to become equal.
23:27:41 <quicksilver> like 'MatrixComponent c'
23:27:47 <quicksilver> (from OpenGL)
23:28:16 <Cale> Can you think of a concrete example where the MR is required to make something compile without ambiguity errors?
23:28:55 <dons> i hit it once in 'idoc', a precursor to haddock, when i ported it to nhc.
23:30:00 <dons> in 2004.
23:30:48 <Cale> http://xkcd.com/465/ -- ahaha
23:30:49 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
23:31:31 <quicksilver> Cale: yes, easily.
23:31:43 <quicksilver> Cale: consider "translate $ Vector3 1 2 3"
23:31:57 <Cale> What are the types there?
23:32:00 <quicksilver> Cale: this does not default, because it has a non-prelude constraint MatrixComponent c.
23:32:09 <Cale> okay
23:32:29 <quicksilver> now make it more complex, like Vector3 (r*sin th) (r*cos th) 0
23:32:30 <Cale> (which is sort of a peculiarity about the defaulting mechanism as it is)
23:32:36 <quicksilver> where r = 3
23:32:40 <quicksilver> (and th is a function parameter)
23:32:53 <quicksilver> under the current situation a single type annotation collapses everything
23:33:07 <quicksilver> e.g. the type annotation on the function itself will collapse th, which will collapse r
23:33:13 <Cale> sure
23:33:15 <quicksilver> (and the zero as well)
23:33:25 <Cale> Why wouldn't it do so without the MR?
23:33:29 <quicksilver> however without MR, 'r' becomes a fully polymorphic value
23:33:37 <Cale> Nope.
23:33:46 <Cale> Well, perhaps... okay
23:33:52 <Cale> So r will be recomputed.
23:34:00 <quicksilver> so if the next line of code is 'translate $ Vector3 r r r'
23:34:02 <Cale> (possibly)
23:34:04 <quicksilver> (doesn't mention theta)
23:34:13 <quicksilver> then this line is now ambiguous.
23:34:41 <quicksilver> so in general I will have to annotation all my bindings instead of just the top-level signatures.
23:35:15 <Cale> But the problem is really that numeric defaulting isn't agressive enough, no?
23:36:01 <Cale> (the Prelude classes only constraint is one of the other things I sort of find strange about the report)
23:36:32 <Cale> aggressive*
23:37:15 <quicksilver> that's certainly one view
23:37:30 <quicksilver> although the point of the openGL classes is that you can call translate with ints, floats or doubles
23:37:38 <quicksilver> (GLints, GLfloats or GLdoubles, rather)
23:37:45 <quicksilver> it might be counter-intuitive to default that to anything.
23:38:33 <Cale> Well, the first thing in the default list which met the constraint. If GLint/etc. aren't there, you'll have the same problem, but then you could just write a default declaration.
23:49:40 <nwf> Quick question (likely to be an "I RTFMed but missed something")... I'd like a version of getProgramName that returned the "real" argv[0] on platforms that support it, rather than just the text after the last path separator.  Anybody know of one?
23:53:42 <b\6> nwf: http://sequence.complete.org/node/34#comment-194
23:53:45 <lambdabot> Title: IRC Snippets | The Haskell Sequence
23:54:52 <nwf> Oh, exciting.  Thanks.
23:55:43 <b\6> np.
