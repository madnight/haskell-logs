00:01:05 <mmorrow> lugui: heh.  i prefer the unflipped version
00:02:02 * luqui speaks english, so prefers to read left-to-right
00:02:27 <dainanak> Quadrescence, if you are still there, I was thinking you might want to take a look at zippers for your permutation problem
00:02:28 * mmorrow speaks english and math and likes math more
00:02:34 <lispy> :t either
00:02:35 <lambdac> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:02:47 <luqui> actually the biggest issue with the left to right thing is that it's the opposite way from function arrows
00:02:55 <Quadrescence> dainanak: I am here.
00:03:02 <luqui> I start on the left in the signature and the right in the implementation, which is distressing
00:03:15 <luqui> I also don't like that about math :-/
00:03:28 <dainanak> ok, well take a look at the wikibook Haskell section on zippers
00:03:46 <Quadrescence> dainanak: I did `((reverse [1..(n-1)]) !! (n-1))' as a naive version.
00:04:08 <Quadrescence> I need to generate a list 1-element-by-1
00:04:08 <dainanak> that garbage collection is going to be painful
00:04:22 <mmorrow> luqui: on that note, i usually always use (=<<) instead of (>>=) (unless writing cps-style in which case you can't) to preserve the flow with mixed in (.)s
00:04:25 <|Steve|> luqui: There's a reason category theorist use f;g;h etc.
00:04:41 <luqui> ; = >>> ?
00:04:42 <mmorrow> ugh, i hate that notation :)
00:04:42 <|Steve|> Rather than h o g o f.
00:04:53 <dainanak> Quadescence, why not do a piecewise definition and set the base case to be equal to [[1]]?
00:05:00 <lispy> I have job :: a -> IO b, and foo :: Either c d, is it okay to use either job job foo ?
00:05:25 <dmwit> sure
00:05:34 <luqui> lispy, if job is polymorphic enough
00:05:46 <lispy> :t let job :: a -> IO b; job = undefined in either job job (undefined :: Either c d)
00:05:47 <dmwit> There's not so many things with exactly those types, though.
00:05:48 <luqui> i.e. foo :: Either a a
00:05:48 <lambdac> forall b. IO b
00:06:22 <lispy> Okay then I think either is sufficient for this usage
00:06:26 <luqui> lispy, yeah, but it won't work if c and d are different types
00:07:16 <Quadrescence> dainanaki: I don't know. I have a number. I have to divMod it. the mod is cons'd to the list, the div is re-input into the function
00:07:16 <dmwit> For job, there's "cast" and "undefined"; for foo, there's "undefined", "Left undefined", and "Right undefined".
00:07:21 <luqui> :t let job :: a -> IO b; job = undefined in either job job (undefined :: Either Int String) -- this might work due to let polymorphism
00:07:23 <lambdac> forall b. IO b
00:07:47 <luqui> :t let job :: a -> IO b; job = undefined in (\j -> either j j (undefined :: Either Int String)) job
00:07:49 <lambdac>     Couldn't match expected type `Int' against inferred type `String'
00:07:49 <lambdac>       Expected type: Either Int Int
00:07:49 <lambdac>       Inferred type: Either Int String
00:07:57 <luqui> there we go that's what I was talking about
00:08:19 <dmwit> But if "job" is a top-level binding, then you're back into "OK" land.
00:08:20 <lispy> luqui: okay, then that's exactly why either isn't working ether
00:08:27 <Quadrescence> dainanaki: However, I am divMod'ing by a number which has to be increasing.
00:08:37 <lispy> luqui: oh, well job is a function parameter
00:08:39 <luqui> lispy, but ghc has impredicative polymorphism, so you can make it work
00:08:56 <luqui> what's the real type of job you have?
00:08:58 <dainanaki> Quadrescence, I'm not sure then
00:09:06 <Quadrescence> dainanaki: I'll figure it out.
00:09:07 <Quadrescence> :)
00:09:16 <lispy>  ((FL p :> FL p) C(x y) -> IO a)
00:09:25 <lispy> the C(x y) is a CPP maco
00:09:28 <lispy> er macro, it's just x y
00:09:36 <lispy> job :: ((FL p :> FL p) x y -> IO a)
00:09:36 <dainanaki> you got me interested in some combinatorial algorithms, Quadrescence. way to distract me :P
00:10:02 <Quadrescence> dainanaki: :D Hah, you can pm me if you want to discuss this stuff. It'd help my brain.
00:10:03 <luqui> so you probably want it to be quantified over p,x, and y (or some subset, depends on the problem)
00:10:09 <mmorrow> lispy: haha, CPP macros in type sigs!
00:10:18 <lispy> mmorrow: yeah :(
00:10:23 <lispy> mmorrow: we also have FORALL()
00:10:29 <dainanaki> Quadrescence, I'd like to discuss it, but I suspect you have a firmer grasp on it than I do
00:10:36 <Quadrescence> Probably not.
00:10:39 <lispy> mmorrow: but this way we can turn the extra phantom types on and off at compile time :)
00:10:43 <Quadrescence> And I am the noobiest noob to haskell.
00:10:50 <cizra> Something weird has happened to ghci. It won't accept definitions.
00:10:51 <mmorrow> lispy: interesting
00:11:03 <luqui> Quadrescence, not so!  you have at least two days on them!
00:11:06 <cizra>  fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
00:11:06 <cizra> <interactive>:1:5: parse error on input `='
00:11:12 <lispy> luqui: well x and y are the parts of the type that need to be different between the Eithers
00:11:17 <lispy> luqui: so I could put them in a forall?
00:11:26 <Quadrescence> luqui: Hahah.
00:11:44 <dainanaki> cizra, you have to do 'let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]'
00:11:47 <luqui> yeah in the sig of the function you want to pass it to
00:11:49 <cizra> Aha, thanks
00:11:56 <luqui> * pass job to, that is
00:12:06 <dainanaki> the let part is important
00:12:20 <lispy> luqui: right, the signature of job is fine, I tihnk
00:12:36 <lispy> luqui: it's just that where that signature apperas in the other function signature needs a forall
00:12:48 <cizra> dainanaki: I see. I'm a newbie, obviously.
00:13:32 <lispy> luqui: My example is too complex...I think it may have been fine how it was because I have the same type error
00:13:44 <lispy> luqui: I'm going it change it back and look it tomorrow
00:13:46 <lispy> luqui: thanks
00:14:20 <luqui> yw.  I don't have all that much experience with the new impredicative polymorphism stuff... but for things like this it can be handy
00:14:28 <dainanaki> cizra, no worries. ghci is a little special to deal with
00:15:28 <cizra> let lst = [a * b * c | (a, b, c) <- [2, 3, 5]] -- why doesn't this work?
00:15:33 * luqui wishes he could just type haskell source into ghci and it would work the same
00:15:51 <luqui> cizra, because [2,3,5] is not a list of 3-tuples
00:15:58 <lispy> luqui: yeah, I've done something before where I just went to a where block and defined, job1 :: Foo; job1 = job; job2 :: Bar; job2 = job, and let the types work themselves out
00:16:22 <cizra> luqui: hmm, OK
00:16:41 <luqui> lispy, again, that only works if job is itself polymorphic, rather than a monomorphic parameter to a polymorphic function...
00:16:46 <lispy> luqui: oh but in that case I was constraining the type class instance, so that was different
00:17:48 <lispy> luqui: hmm...but I should be okay right?
00:18:04 <lispy> luqui: bah, I need sleep
00:18:07 <lispy> luqui: thanks again!
00:18:15 <luqui> you're going to be fine, lispy. :-)
00:19:51 <dainanaki> cizra, you are mixing lists and tuples together, which is causing a typecheck error
00:20:28 <mmorrow> > (\[a,b,c] -> (a,b,c)) [2,3,5]
00:20:29 <lambdac>  (2,3,5)
00:20:57 <mmorrow> > (\(a,b,c) -> a*b*c) [2,3,5]
00:20:58 <lambdac>  Couldn't match expected type `(t, t, t)'
00:20:59 <luqui> let lst = [ a*b*c | [a,b,c] <- [[2,3,5]] ]
00:21:10 <luqui> > let lst = [ a*b*c | [a,b,c] <- [[2,3,5]] ]  in lst
00:21:11 <lambdac>  [30]
00:21:42 <cizra> dainanaki: I understand. I already fixed that.
00:22:06 <mmorrow> > let xs = [0..4] in [ (x,xs) | x < - xs ]
00:22:07 <lambdac>  Couldn't match expected type `Expr' against inferred type `[t]'
00:22:15 <mmorrow> > let xs = [0..4] in [ (x,xs) | x <- xs ]
00:22:17 <lambdac>  [(0,[0,1,2,3,4]),(1,[0,1,2,3,4]),(2,[0,1,2,3,4]),(3,[0,1,2,3,4]),(4,[0,1,2,3...
00:24:08 <cizra> I want to create a large, preferably infinite list of a : a = 2^n * 3^m * 5*l
00:24:14 <cizra> lst = [a * b * c | a <- [2, 3, 5], b <- [2, 3, 5], c <- [2, 3, 5]]
00:24:20 <cizra> -- this creates some
00:24:26 <mmorrow> > (fmap concat . unzip) (let xs = [0..4] in [ (x,xs) | x <- xs ])
00:24:27 <lambdac>  ([0,1,2,3,4],[0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4])
00:24:33 <cizra> Any ideas on how to create the whole bunch?
00:24:54 <cizra> Or at least the first N such numbers?
00:25:21 <mmorrow> what are the ranges of n,m,l
00:25:22 <mmorrow> ?
00:25:54 <mmorrow> (`elem`[0..]) ?
00:25:54 <cizra> 0 up to infinity
00:26:03 <luqui> cizra, if n,m, and l are all infinite, then you can use the omega "monad" (not really a monad) to do it..
00:26:20 <luqui> control-monad-omega on hackage
00:26:46 <cizra> It'd be sufficient to generate the first N numbers, that is, keep the ranges finite.
00:27:17 <mmorrow> the only thing is, what do you want the first N triples of (n,m,l) to be?
00:27:46 <mmorrow> (1,1,x) , where x `elem` [0..n-1] ?
00:28:12 <mmorrow> or a more "breadth-first" traversal
00:28:20 <luqui> oh, probably in increasing order of a!
00:28:31 <mmorrow> ahh
00:28:59 <mmorrow> hmm
00:29:02 <luqui> those functions are all monotone, so you can do it
00:29:36 <cizra> Yes, in increasing order of a.
00:29:51 * cizra looks up "monotone function"
00:29:59 <cizra> Oh, that.
00:31:56 <mmorrow> > take 20 [ 2^n * 3^m * 5^l | n <- [0..], m <- [0..], l <- [0..] ]
00:31:57 <lambdac>  [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,1...
00:33:14 <cizra> This is unsorted.
00:33:25 <cizra> You can't sort an infinite list, can you?
00:33:38 <mmorrow> yeah, you'll have to use Omega
00:33:41 <dmwit> You can often produce an infinite list in sorted order.
00:33:51 <|Steve|> > [1..] -- Bam!
00:33:52 <lambdac>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:33:59 <mmorrow> i meant no you can't ... yeah, you have to use Omega
00:34:01 <ziman> do you mean a *sorted* list?
00:34:14 <ziman> i'd go for an iterative approach with a heap
00:34:16 <cizra> Hey, wait, I don't need to sort an infinite list! I can just put a sufficient large border.
00:34:47 <cizra> How do you sort a list, anyway?
00:34:49 <mmorrow> i'm sure there's a clever way to do it without the Omega monad
00:34:58 <ziman> > [2^n * 3^m * 5^l | k <- [1..], n <- [1..k], m <- [1..k], l <- [1..k]]
00:34:59 <lambdac>  [30,30,150,90,450,60,300,180,900,30,150,750,90,450,2250,270,1350,6750,60,300...
00:35:06 <ziman> > sort [2^n * 3^m * 5^l | k <- [1..], n <- [1..k], m <- [1..k], l <- [1..k]]
00:35:17 <cjs> I have a profiling question.
00:35:22 <rwbarton> The usual solution to this problem is to write a merge for infinite sorted lists, and then let xs = 1 : (map (2*) xs `merge` map (3*) xs `merge` map (5*) xs)
00:35:22 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss) in merge [[m^n | n <- [2..]] | m <- [2..]]
00:35:54 <cjs> If I have a large, lazy data structure that I first pass to f and then to g, and f forces the evaluation of most of it, it's going to get charged for all of that and g will get charged for almost none of it, right?
00:35:58 <lambdac>  Exception: Time limit exceeded
00:36:11 <lambdac>  thread killed
00:36:41 <ziman> rwbarton, nice!
00:36:42 <dmwit> Liar!
00:36:54 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss) in merge [[m^n | n <- [2..]] | m <- [2..]]
00:37:09 <lambdac>  thread killed
00:37:10 <luqui> cizra, http://hpaste.org/9537
00:37:35 <dmwit> Man, that calculation runs like wildfire in ghci.
00:37:41 <dmwit> I wonder what's wrong with lambdac.
00:38:40 <rainmann> > 1
00:38:43 <lambdac>  1
00:39:00 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss); all = 1:merge [map (x*) all | x <- [2,3,5]] in all
00:39:02 <lambdac>  [1,2,3,4,5,6,6,8,9,10,10,12,12,12,15,15,16,18,18,18,20,20,20,24,24,24,24,25,...
00:39:34 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss); all = 1:merge [map (x*) all | x <- [2,3,5]] in nub all
00:39:41 <lambdac>  [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72...
00:39:54 <dmwit> :t foldr
00:39:58 <lambdac> forall a b. (a -> b -> b) -> b -> [a] -> b
00:40:20 <rainmann> is lambdabot still not working?
00:40:42 <cizra> luqui: There's no Data.Function here
00:41:12 <dmwit> :t foldr (\x (y:ys) -> if x == y then y:ys else x:y:ys)
00:41:13 <lambdac> forall a. (Eq a) => [a] -> [a] -> [a]
00:41:18 <luqui> @src on
00:41:18 <lambdac> (*) `on` f = \x y -> f x * f y
00:41:39 <luqui> but do try to understand it...
00:41:52 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss); all = 1:merge [map (x*) all | x <- [2,3,5]]; ascNub = foldr (\x (y:ys) -> if x == y then y:ys else x:y:ys) [] in ascNub all
00:41:59 <lambdac>  Exception: Time limit exceeded
00:42:00 <luqui> (infact dmwits merge thing looks cleaner anyway)
00:42:10 <dmwit> whoops
00:44:26 <dmwit> Huh.
00:44:33 <mib_0pnovujp> hi guys
00:44:37 <mib_0pnovujp> haskell channel?
00:44:42 <sjanssen> dmwit: that's a nice solution, except for nub
00:44:53 <dmwit> Prelude Data.List> let ascNub = (elided for brevity) :: Eq a => [a] -> [a]
00:45:01 <mib_0pnovujp> how do you guys check the efficiency of a code using the big o notation
00:45:02 <dmwit> Prelude Data.List> :t ascNub
00:45:02 <dmwit> ascNub :: [()] -> [()]
00:45:13 <dmwit> Any idea why ascNub is being restricted to [()]?
00:45:26 <dmwit> mib_0pnovujp: Well, there's a lot of techniques.
00:45:29 <sjanssen> dmwit: probably monomorphism restriction and -fextended-defaulting
00:45:29 <dmwit> It depends on the algorithm.
00:45:42 <mib_0pnovujp> dmwit: ok
00:45:43 <dmwit> sjanssen: But see the explicit type signature in the let...
00:45:53 <mib_0pnovujp> dmwit: if i say 1+1, how efficient is that?
00:46:08 <dmwit> sjanssen: I elided the implementation, but I actually typed the ":: Eq a => [a] -> [a]" at the prompt.
00:46:11 <sjanssen> dmwit: that doesn't matter
00:46:14 <dmwit> =/
00:46:23 <sjanssen> dmwit: however "let ascNub :: foo; ascNub = bar" will work
00:46:23 <dmwit> mib_0pnovujp: ...what?
00:46:32 <dmwit> sjanssen: oooh
00:46:48 <sjanssen> @karma DMR
00:46:49 <lambdac> DMR has a karma of 0
00:46:51 <sjanssen> DMR--
00:47:16 <dmwit> sjanssen++
00:47:30 <mib_0pnovujp> dmwit: http://hpaste.org/9538
00:47:35 <dmwit> oop, that implementation of ascNub doesn't seem quite right
00:47:48 <mib_0pnovujp> how do i check the efficiency using the big-O, like O(n2)
00:47:55 <mib_0pnovujp> can teach?
00:48:19 <mib_0pnovujp> is it n log n?
00:48:34 <sjanssen> #haskell probably isn't the best place to learn O from scratch
00:48:51 <dmwit> ?go big-o wikipedia
00:48:54 <lambdac> http://en.wikipedia.org/wiki/The_Big_O
00:49:09 <MyCatVerbs> mib_0pnovujp: prove it on paper (math heavy) or run it on big inputs and measure how long it takes. :)
00:49:10 <dmwit> err... not that
00:49:19 <mib_0pnovujp> anime ?
00:49:25 <sjanssen> mib_0pnovujp: it is O(n^3)
00:49:25 <mib_0pnovujp> help me please
00:49:28 <dmwit> http://en.wikipedia.org/wiki/Big_oh
00:49:31 <dmwit> that
00:49:36 <mib_0pnovujp> ok, how did you get to that n^3?
00:50:38 <MyCatVerbs> mib_0pnovujp: x <- [1..n] causes everything below it in the comprehension it to run n times.
00:50:38 <mib_0pnovujp> dmwit: ?
00:51:37 <MyCatVerbs> mib_0pnovujp: y <- [x+1..n] causes everything below *that* to run roughly n/2 times each time it is run. So, n*(n/2) times, or ignore the constant and call it O(n^2).
00:51:40 <dmwit> > let merge ((x:xs):xss) = x:merge (insert xs xss); all = 1:merge [map (x*) all | x <- [2,3,5]]; ascNub = foldr (\x xs -> x : dropWhile (== x) xs) [] in ascNub all
00:51:48 <lambdac>  [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72...
00:52:17 <MyCatVerbs> mib_0pnovujp: z <- y+1..n] causes everything below *that* to run roughly n/4 times each time it is run. So, n*(n/2)*(n/4). Ignoring the constants, O(n^3).
00:52:40 <dmwit> sjanssen: I think using nub is fine here.  The alternative is for "merge" to do the work of removing duplicates, which strikes me as mildly non-compositional.
00:52:44 <mib_0pnovujp> MyCatVerbs: thanks for explaining thoroughly ^_^
00:52:49 <sjanssen> dmwit: yeah
00:52:55 <mib_0pnovujp> MyCatVerbs: very helpful
00:53:01 <sjanssen> dmwit: just as long as you don't use Data.List.nub
00:53:07 * dmwit nods
00:53:10 <sjanssen> (because this will cause memory blowups)
00:53:18 <MyCatVerbs> mib_0pnovujp: and then the final line in that list comprehension, (x*x)+(y*y)==(z*z), takes constant - O(1) - time. It's run O(n^3) times. So in all, you end up with O(n^3) complexity.
00:53:27 <dmwit> This foldr version is better, when it's appropriate.
00:53:55 <MyCatVerbs> mib_0pnovujp: no worries. This is all full of *gross* simplifications, but then so's the math when you do it formally. ;)
00:54:39 <sjanssen> mib_0pnovujp: if you'd really like to learn this stuff, I recommend that you try to figure out exactly how many times "(x * x) + (y * y) == (z * z)" will be evaluated for a given n
00:54:47 <sjanssen> for any n, rather
00:55:24 <MyCatVerbs> mib_0pnovujp: if you want to learn more, you should pick up an algorithms textbook and start reading.
00:55:59 <mib_0pnovujp> MyCatVerbs: what kind of algorithm book is suitable for newbie
00:56:28 <mib_0pnovujp> MyCatVerbs: title of the book(s) ?
00:56:45 <MyCatVerbs> mib_0pnovujp: that'll take me a little while to come up with a good answer to.
00:57:50 <dmwit> Tarjan et al?
00:57:53 <MyCatVerbs> Huh. Impatient?
01:01:44 <dmwit> ?tell mib_0pnovujp You might like Introduction to Algorithms by Cormen, Leiserson, Rivest, and Stein.
01:01:44 <lambdac> Consider it noted.
01:02:18 <dmwit> I wonder if he'll come back with the same nick, or whether it's just mib_<GUID>.
01:03:30 <MyCatVerbs> No idea. For all I know, that's not a UID, that's valid Polish vocabulary with a number consed onto the head.
01:04:23 <paczesiowa> that's not valid polish
01:04:51 <|Steve|> I always thought that CLRS was more of a reference book.
01:06:38 <MyCatVerbs> paczesiowa: I'm not saying it is. I'm saying I can't tell. The statement is concerned more closely with my inadequacies than with linguistics. ;P
01:15:11 <hml> @hoogle unsafePerformIO
01:15:11 <lambdac> A Hoogle error occured.
01:15:15 <hml> wtf
01:15:19 <hml> how do i get unsafePerformIO ?
01:15:29 <wjt> @index unsafePerformIO
01:15:29 <lambdac> System.IO.Unsafe, Foreign
01:15:33 <dainanaki> you get it not on lambdabot
01:15:49 <dainanaki> :P
01:20:39 <chrisdone> MyCatVerbs:
01:20:42 <chrisdone> *** highlyInterested (~ijones) has joined channel #haskell
01:20:42 <chrisdone> <highlyInterested> hi! I'm highly interested, but have no attention span!!!
01:20:42 <chrisdone> <highlyInterested> Can anyone help me?!?!?
01:20:42 <chrisdone> * highlyInterested runs around!!
01:20:42 <chrisdone> *** highlyInterested (~ijones) has quit: Client Quit
01:21:12 <cizra> chrisdone: boo
01:21:19 <wolverian> heh
01:21:21 <chrisdone> cizra: hi
01:21:41 <cizra> chrisdone: Hullo. As you can perhaps see, I discovered the joys of Haskellation.
01:22:29 <cizra> Also, you haven't wandered near Lojbanistan lately. Lost interest?
01:23:13 <ggl> hi
01:25:15 <MyCatVerbs> chrisdone: oh right, I forgot. :)
01:25:39 <chrisdone> cizra: cool. I guess it wasn't my blatant Haskell propaganda in #lojban that got you interested. :P and I vaguely lost interest in chatting in #lojban, yes.
01:26:09 <MyCatVerbs> chrisdone: out of curiosity, what does everybody speak in #lojban?
01:26:53 <MyCatVerbs> chrisdone: (also, excuse my propaganda, but to Hell with the Sapir-Whorf hypothesis. ;)
01:26:54 <chrisdone> MyCatVerbs: half and half english and lojban
01:27:04 <MyCatVerbs> Cool. Better than I was expecting. :)
01:27:17 <cizra> chrisdone: No, actually, we had to learn a bit of it at school. But the two things that got my interest are supposed buglessness and expressive power when dealing with complex problems.
01:27:46 <cizra> MyCatVerbs: Programming, system administration, linguistics, Judaism, mostly
01:27:56 <chrisdone> cizra: I figured so. good stuff, nice to see you again
01:27:59 <cizra> MyCatVerbs: Sometimes a bit of Lojban as well.
01:28:05 <cizra> *nod*
01:33:01 <cizra> MyCatVerbs: I can vouch for Sapir-Whorf hypothesis. It sure ruined my family life.
01:33:15 <MyCatVerbs> cizra: ?
01:34:56 <cizra> MyCatVerbs: Well, I started thinking different. Or something, dunno. Now we have misunderstandings of speech on every step. Frequently we understand the same words in a different way.
01:35:37 <MyCatVerbs> That sounds like it'll lead to Awkward Moments.
01:36:13 <cizra> O yes. O yes.
01:44:21 <cizra> If I defined a function to calculate Pi infinitely precisely and then typed :t pi into ghci, would it hang?
01:45:44 <paczesiowa> usually no
01:46:21 <quicksilver> :t ? type checking always terminates in haskell.
01:46:23 <lambdac> parse error on input `?'
01:46:23 <paczesiowa> unless you calculate in type system and use undefined instances
01:46:36 <cizra> Umm.. OK
01:53:25 <tibbe_> @seen dons
01:53:25 <lambdac> dons is in #haskell. I last heard dons speak 2h 23m 57s ago.
01:54:52 <ivanm> why hasn't anyone restarted lambdabot proper yet?
01:57:11 <jeffz> i think it's trying to solve the halting problem
01:57:34 <ivanm> heh
01:59:15 <Quadrescence> > "What did you " ++ (concat (replicate 10 "thunk ")) ++ "about that attractive Haskelleton?"
01:59:17 <lambdac>  "What did you thunk thunk thunk thunk thunk thunk thunk thunk thunk thunk ab...
01:59:26 <Quadrescence> :>
01:59:55 <luqui> should have used a let binding to share the thunk
02:03:08 <Quadrescence> > reverse "Hey look everyone, I can type backwards!"
02:03:09 <lambdac>  "!sdrawkcab epyt nac I ,enoyreve kool yeH"
02:03:43 <|Steve|> ¡uʍop ǝpısdn ǝʇıɹʍ uɐɔ ı 'ǝuoʎɹǝʌǝ ʞoo1 ʎǝɥ
02:04:36 <luqui> |Steve|, now the question is can you write right-side up while upside down
02:04:40 <ivanm> |Steve|: heh, how'd you do that? searching through a utf table?
02:04:53 <Zao> ivanm: The internets.
02:04:54 <Quadrescence> > reverse "¡uʍop ǝpısdn ǝʇıɹʍ uɐɔ ı 'ǝuoʎɹǝʌǝ ʞoo1 ʎǝɥ"
02:04:56 <lambdac>  "\613\477\654 1oo\670 \477\652\477\633\654ou\477' \305 \596\592u \653\633\30...
02:05:02 <Quadrescence> haskell fails us once again
02:05:05 <|Steve|> heh
02:05:07 <ivanm> Zao: ooohhh..... what's that?
02:05:11 <ivanm> ;-)
02:05:14 <Zao> ivanm: A series of tubes, basically.
02:05:24 <ivanm> tell me more
02:07:28 <|Steve|> It's not a truck.
02:07:49 <Quadrescence> ivanm: It's kind of like a fish tank iirc, just with tubes
02:08:02 <Quadrescence> youtube is one of those tubes, it points at you, hence its name
02:08:10 <|Steve|> heh
02:08:39 <ivanm> lol
02:09:16 <hml> what function gives me the ascii value of a char?
02:09:22 <rainmann> @type ord
02:09:24 <lambdac> Char -> Int
02:09:28 <rainmann> > ord 'a'
02:09:29 <lambdac>  97
02:09:29 <hml> thanks
02:09:36 <ivanm> > fromEnum 'a'
02:09:38 <|Steve|> > fromEnum 'a'
02:09:38 <lambdac>  97
02:09:38 <lambdac>  97
02:09:39 <paczesiowa> dons: I sent you those patches by email. what would you say about other patches: ligthweight (modifiers and setters for every field in every record - only new api), medium (reading, writing and modifying in-place feeds from disk - new api but additional deps - Strict), heavyweight (changing date-like fields from strings to proper Time types - breaks old api)
02:09:41 <|Steve|> bah
02:10:04 <ivanm> hah
02:10:09 <quicksilver> hml: unicode code point, technically.
02:10:17 <quicksilver> fortunately that's a superset of ASCII.
02:10:38 <hml> @index ord
02:10:38 <lambdac> Data.Char
02:13:39 <hml> dumnb question
02:13:44 <hml> and how to i get this Int to an Integer?
02:13:54 <opqdonut> :t fromIntegral
02:13:55 <lambdac> forall a b. (Num b, Integral a) => a -> b
02:14:12 <hml> opqdonut: thanks
02:14:13 <opqdonut> or just use fromEnum
02:14:15 <opqdonut> :t fromEnum
02:14:16 <lambdac> forall a. (Enum a) => a -> Int
02:14:22 <opqdonut> ah, no, it returns int too
02:15:22 <sioraiocht> isn't there a ghc flag that tells you what rules were triggered during each phase of compilation? I can't remember it/find it
02:16:44 <MyCatVerbs> sioraiocht: ghc-core extracts that information somehow, so I presume the answer must be yes. I'd recommend using ghc-core rather than bothering to look it up, though, since you get more information that way. :)
02:18:26 <sioraiocht> MyCatVerbs: that doesn't really help me, actually
02:18:50 <sioraiocht> there's a flag that will tell you how many times a given rewrite rule was triggered, and the user defined name for it
02:19:01 <sioraiocht> I don't want the specialiser's output
02:20:02 <sioraiocht> ah, -ddump-simpl-stats
02:21:03 <MyCatVerbs> sioraiocht: huh? Near the top of ghc-core's output, is a section looking rather like: http://hpaste.org/9541
02:21:44 <sioraiocht> you get that from -ddump-simpl-stats too, but that's good to know, i didn't know that ghc-core gave you that
02:23:06 <MyCatVerbs> Heh. Near as I can tell, ghc-core is Dons' own personal "what do I need to optimize next?" checker, so yeah, it gets more or less everything by default. ;)
02:23:31 <sioraiocht> hrm, rules fired, 519
02:23:35 <sioraiocht> at least the optimiser is doing it's job...
02:23:46 <opqdonut> or just looking busy ;)
02:24:01 <sioraiocht> haha opqdonut, a lot of them are MY rules, hehe
02:24:13 <MyCatVerbs> GHC's frontend optimizer is flippin' heroic. Hopefully the backend optimizer will be too, within a few months. :)
02:50:14 <loupgaroublond> hi
02:50:25 <loupgaroublond> i'm a bit confused about linking with ghc on linux
02:50:38 <loupgaroublond> can i safely assume that all apps and libraries in ghc are statically linked?
02:51:31 <quicksilver> all the haskell stuff is staticall linked
02:51:32 <BeelsebobWork> yes and no
02:51:38 <quicksilver> any C libraries it depends on are dynamically linked as normal
02:51:39 <hml> can you use where right after a do; or do you have to use let inside or a do?
02:51:52 <quicksilver> hml: you use where on definitions.
02:51:55 <hml> i.e. something like do { ... foo ... } where foo 1 ...
02:51:58 <BeelsebobWork> loupgaroublond: at least libgmp is dynamically linked on linux
02:52:00 <quicksilver> hml: do is an expression.
02:52:02 <quicksilver> so, no.
02:52:04 <hml> i.e. something like do { ... foo ... } where foo = ... -- can i make this owrk?
02:52:19 <quicksilver> but you can use the where on the enclosing definition.
02:52:30 <hml> quicksilver: but i can do: "let foo = ... in do ..."
02:52:45 <hml> quicksilver: and in general, i can 'invert' the order of those using where, so why can't i do it to a doo?
02:53:10 <quicksilver> hml: because where is for definitions and let is for expressions.
02:53:12 <loupgaroublond> BeelsebobWork, is that a c library?
02:53:14 <quicksilver> that's just the way it is.
02:53:19 <BeelsebobWork> loupgaroublond: yep
02:53:28 <BeelsebobWork> for infinite precision integers
02:53:41 <loupgaroublond> is there any work to have all ghc compiled libraries dynamically linked (or even just plans?)
02:53:43 <hml> quicksilver: okay; got it; thanks
02:53:52 <hml> ... wtf ... gcc segfaulted on me
02:53:56 <BeelsebobWork> loupgaroublond: not that I know of -- why do you want it?
02:54:02 <BeelsebobWork> hml: time to get your delta debugger out
02:54:24 <quicksilver> hml: there is always an enclosing definition you can put the where on, or you can insert one with let or (I think) case
02:54:35 <loupgaroublond> BeelsebobWork, because if there is a security advisory for some lib ghc-foo and bar depends on it, then both packages have to be recompiled and deployed
02:55:01 <loupgaroublond> and we need to know about this bit ahead of time, so when there's a security advisory, we have a procedure to follow
02:55:40 <BeelsebobWork> true -- but this can be weighed against the fact that security holes in Haskell modules will be *much* less common than in C modules
02:56:36 <loupgaroublond> true too
02:56:52 <loupgaroublond> it's not the hassle, it's just writing the rules, we do the same for ocaml in fedora too
03:01:10 <paczesiowa> > ""
03:01:11 <lambdac>  ""
03:01:28 <MyCatVerbs> loupgaroublond: getting everything dynamically linked (both Haskell and C code) will take I understand a couple months' work by the GHC devs. You might want to ldd a couple of the executables that GHC outputs to make a list of what is currently dynamically linked.
03:01:55 <loupgaroublond> MyCatVerbs, good idea
03:02:15 <loupgaroublond> i'm just curious what plans there are though, if there are none, we'll just have to take that into account
03:02:48 <loupgaroublond> looking at xmonad, it seems just C libraries
03:03:03 <paczesiowa> it works on windows and used to on macs and there was gsoc for it on linux I think
03:03:11 <quicksilver> ghc will never dynamically link other haskell libraries though, will it?
03:03:22 <quicksilver> its optimisation strategy is dependent on cross-library inlining.
03:03:42 <MyCatVerbs> loupgaroublond: aye. At the moment, GHC can only do dynamic linking for C libraries.
03:03:58 <dcoutts> dino-: you can use data files with subdirs, eg: data-files: foo/bar.txt  will get installed at $datadir/foo/bar.txt
03:04:20 <loupgaroublond> quicksilver, is that kind of optimization something that can be deffered to package deployment time, or is it something bound into the compile process
03:04:23 <MyCatVerbs> paczesiowa: it's going to get fixed up again soon enough, but there's other work to be done first.
03:04:37 <quicksilver> loupgaroublond: it is bound into the compile process.
03:04:50 <delYsid> I'd like to use Haskell to do MusicXML processing.  MusicXML is a pretty complicated document centric format, can Haskell do that?
03:04:53 <dcoutts> dino-: data-dir only changes the directory where we find the data files locally.
03:05:00 <quicksilver> ghc would have to move to JIT linking (essentially JIT compiling, indeed)
03:05:01 <delYsid> http://www.musicxml.org/dtds/partwise.dtd
03:05:02 <dcoutts> @faq
03:05:02 <lambdac> The answer is: Yes! Haskell can do that.
03:05:06 <quicksilver> which is a big change.
03:05:19 <tehgeekmeister> bos: if you're still around, fedora has the same exact error in x86_64.
03:05:25 <quicksilver> delYsid: I have found haskell's XML tools to be approximately 85,489 times better than those in any other language.
03:05:38 <quicksilver> delYsid: 19,657,889 times better than those in Java.
03:05:54 <delYsid> dcoutts: so what lib to use? HaXML emits code that does not compile...
03:06:00 <loupgaroublond> only 85,488 times better than what python offers though
03:06:01 <dcoutts> @seen Cale
03:06:01 <lambdac> Cale is in #haskell. I last heard Cale speak 4h 29m ago.
03:06:09 <tehgeekmeister> @seen bos
03:06:09 <lambdac> bos is in #haskell. I last heard bos speak 4h 37m 28s ago.
03:06:10 <rainmann> quicksilver, have you tried Scala?
03:06:31 <dcoutts> delYsid: you mean the dtd program generates non-working Haskell ?
03:06:49 <delYsid> dcoutts: yes.
03:06:56 <tehgeekmeister> quicksilver: since you seem to like haskell's xml tools, what would you use to grab all the article nodes in an xml wikipedia dump, a four gig file, mind you.
03:07:15 <malcolmw> delYsid: send me a failing HaXml test-case, and I will look into it.
03:07:55 <quicksilver> tehgeekmeister: probably tagsoup.
03:08:05 <quicksilver> tehgeekmeister: it's good for simple streaming tasks.
03:08:16 <malcolmw> XtractLazy "//article" dumpfile
03:08:18 <delYsid> malcolmw: just run http://www.musicxml.org/dtds/partwise.dtd through the dtd-processor, the resulting code does not compile due to some strange name-clash
03:08:24 <quicksilver> delYsid: 'HaXML emits code which does not compile' ?
03:08:25 <quicksilver> wtf?
03:08:30 <quicksilver> HaXML doesn't emit code at all, does it?
03:08:34 <quicksilver> the bits I used, anyway.
03:08:40 <malcolmw> quicksilver: DtdToHaskell emits haskell code
03:08:44 <tehgeekmeister> quicksilver: huh, okay.  i'll look into that once i can get haskell working at all on slicehost.  thanks.
03:08:44 <quicksilver> Ah.
03:09:02 <quicksilver> I have used HaXML and tagsoup, and they both have their charm.
03:09:10 <dcoutts> @tell Cale lambdabot on code.h.o is using 210m resident and a second instance is using a further 17m. There are a further 18 runplugs instances, each one using 10-16m resident. Overall it's using 79% of the memory on the server.
03:09:10 <lambdac> Consider it noted.
03:09:24 <quicksilver> I would use tagsoup for simple stream type tasks which don't really require knowledge of the tree/nesting structure of the XML
03:09:37 <quicksilver> and I would use HaXML for more deeply structured work and transformations.
03:10:16 <delYsid> quicksilver: yeah, I was meaning to use HaXML, but it seems it isn't possible with MusicXML right now...
03:10:34 <quicksilver> well you could get malcolmw to work with you to discover why it fails the DTD
03:10:42 <quicksilver> or you could just not bother with the DTD :)
03:10:43 <malcolmw> a lot of people seem to reach for DtdToHaskell when all they really want is an extraction of some specific nodes from a tree, for which Xtract is much better suited
03:10:49 <quicksilver> do you need to validate it?
03:11:43 <delYsid> Nah, I just need to load, do some info extraction or manipulation of content, and serialize back out to disk.
03:12:12 <delYsid> I was under the impression I need to use DtdToHaskell anyway.
03:12:32 <delYsid> so that Haskell can define types and all that...
03:12:54 <delYsid> If thats wrong, maybe someone could point me to a simple example that doesnt require DTD.
03:12:57 <malcolmw> delYsid: you can do it in an untyped way if you wish, using the manipulation combinators
03:13:54 <malcolmw> converting XML DTD types to Haskell types is inexact at best, infuriating at worst.  The two type worlds are just not well-matched
03:14:16 <quicksilver> I've always just defined my own types
03:14:26 <quicksilver> for the particular 'sub-universe' I actually care about.
03:14:33 <malcolmw> but there is a generic tree representation of the XML document, where you deal with nodenames as values rather than types
03:14:36 <delYsid> malcolmw: There is a W3C XML Schema too these days, but I guess HaXML doesnt support that?
03:15:10 <delYsid> malcolmw: Any quick example code I could look at for this?
03:15:14 <malcolmw> delYsid: yeah, no-one has got round to implementing a Schema -> Haskell type translator
03:16:13 <malcolmw> delYsid: there is an ICFP paper on the HaXml website which has a couple of examples, and compares the generic tree traversals with typed translation
03:16:34 <malcolmw> I admit there is not a great deal of documentation apart from that
03:16:48 <malcolmw> tutorial type stuff is mising
03:18:57 <quicksilver> delYsid: I can paste the code I use to parse apple's PList format
03:19:05 <quicksilver> delYsid: which is a pretty typical simple XML format
03:23:05 <delYsid> please
03:27:06 <tehgeekmeister> i'm having an odd problem with ghci not working but ghc working, which has something to do with trying to access invalid memory addresses because of being on a 64 bit machine.  I talked to bos about it quite a bit earlier, and he told me to switch to fedora 9 because it would work, however having tried that i'm getting exactly the same error.  my question is if the fact that i'm running under xen could cause any quirk as far 
03:28:33 <BeelsebobWork> anyone have any idea what might cause this in \bot...
03:28:34 <BeelsebobWork> lambdabot> > 5 + 6
03:28:34 <BeelsebobWork>  fd:7: hClose: resource vanished (Broken pipe)
03:29:36 <cizra> BeelsebobWork: strace it?
03:29:46 <BeelsebobWork> pardon?
03:29:58 <quicksilver> delYsid: sorry, I didn't get a highlight so I didn't see your response.
03:30:02 <quicksilver> delYsid: I'll go find the code.
03:30:09 <jeffz> tehgeekmeister: not sure what your error is, but I a vm at a shared hosting place, sometimes resource requests fail randomly
03:30:41 <tehgeekmeister> jeffz: mine's failed every time without fail, only ghci, never ghc
03:30:50 <cizra> BeelsebobWork: Are you using Linux?
03:30:55 <BeelsebobWork> cizra: no, OS X
03:30:57 <jeffz> tehgeekmeister: is it necessary to build and run ghc on the host, can't you build the app on your machine and deploy it there?
03:31:23 <tehgeekmeister> jeffz: i could, but that'd be more than i properly know how to do
03:31:28 <quicksilver> delYsid: http://hpaste.org/9543
03:31:33 <cizra> BeelsebobWork: Hmm, I don't know if OS X has anything like strace...
03:31:35 <tehgeekmeister> the host is x86_64 linux
03:31:40 <tehgeekmeister> and i'm using osx
03:31:41 <BeelsebobWork> cizra: what does strace do?
03:31:41 <jeffz> tehgeekmeister: I compile my cgi programs locally and then shunt the binaries over sftp
03:32:07 <tehgeekmeister> on an intel mac
03:32:28 <cizra> BeelsebobWork: It snoops on the program, logging all system calls it makes. There's ktrace for OS X, says Google.
03:32:34 <BeelsebobWork> oh, dtrace
03:32:49 <jeffz> tehgeekmeister: I use virtualbox, since I run on 64bit but deploy 32bit.
03:32:51 <cizra> BeelsebobWork: This might give you a hint what file is being hClosed when the error occurs.
03:33:32 <jeffz> tehgeekmeister: what's the error you get anyway?
03:34:53 <tehgeekmeister> ghc-6.8.2: internal error: R_X86_64_32S relocation out of range: (noname) = 0x7fe9d5de5630
03:35:00 <tehgeekmeister> with a different address every time, of course
03:36:34 <therp> tehgeekmeister: better join #ghc
03:36:35 <jeffz> tehgeekmeister: something to do with the RTS Linker, have you tried asking in #ghc?
03:38:29 <tehgeekmeister> nope, haven't asked over there
03:38:38 <tehgeekmeister> i'll hop on over, tho
03:38:51 <BeelsebobWork> do I have to do something special to install plugins for lambdabot?
03:39:06 <BeelsebobWork> this error seems to come up a lot, and people comment that they "forgot to install the plugin"
03:40:49 <sioraiocht> is there an easy way to get all the things that String is an instance of?
03:41:16 <quicksilver> :i String, in ghci
03:41:20 <sioraiocht> cheers
03:41:20 <quicksilver> will show you all in-scope instances.
03:41:32 <quicksilver> But remember that in Haskell, String can't be an instance of anything
03:41:35 <quicksilver> (per-se)
03:41:42 <sioraiocht> oh right, it's a list of Char..
03:41:57 <BeelsebobWork> @seen dons
03:41:57 <lambdac> dons is in #haskell. I last heard dons speak 4h 12m 30s ago.
03:41:59 <quicksilver> however I think this is now regarded as a h98-shortcoming
03:42:02 <quicksilver> rather than feature :)
03:42:32 <sioraiocht> well fine, when this lib is released people will just have to ASK for the instances they want, if I miss something ;) =p
03:44:12 <sioraiocht> or make them themselves, i suppose, heh
03:44:32 <BeelsebobWork> gah
03:44:35 <sioraiocht> ?
03:44:42 <BeelsebobWork> googling the error finds about 100000000 people who have the same error
03:44:45 <BeelsebobWork> and no solution
03:44:59 <BeelsebobWork> it appears \bot is just broken :(
03:46:28 <tehgeekmeister> BeelsebobWork: it could always be worse: runghc and ghci could be broken!
03:46:41 <tehgeekmeister> they are for me right now.
03:46:55 <BeelsebobWork> well, that's exactly what's broken within lambdabot
03:46:57 <BeelsebobWork> >.<
03:47:06 <BeelsebobWork> anything that involves running Haskell explodes
03:49:22 <mnislaih> @seen ndm
03:49:22 <lambdac> I haven't seen ndm.
03:53:03 <tehgeekmeister> BeelsebobWork: okay, that is a bit of a problem.
03:56:20 <sioraiocht> :t xor
03:56:22 <lambdac> forall a. (Bits a) => a -> a -> a
03:56:34 <sioraiocht> is there a builtin function for logical xor?
03:57:28 <BeelsebobWork> @hoogle Bool -> Bool -> Bool
03:57:29 <lambdac> A Hoogle error occured.
03:57:33 <BeelsebobWork> splode!
03:57:54 <quicksilver> sioraiocht: (/=)
03:58:03 <BeelsebobWork> haha, good point
03:58:04 <BeelsebobWork> >.<
03:58:05 <sioraiocht> ...right
04:13:24 <pozic> Is there a function that returns a monotonically increasing version of a list? mono [1,4,3] => [1,3,3]
04:14:05 <Botje> eh
04:14:06 <Botje> sort? :)
04:14:06 <RayNbow> ?
04:14:21 <Botje> map head . group . sort
04:14:23 <Botje> to be precise
04:14:49 <Botje> > map head . group $ sort [ 4,3,2,1,1,5,6,2,3,4,5,1,6,7,3,3,3,2 ]
04:14:51 <lambdac>  [1,2,3,4,5,6,7]
04:14:52 <RayNbow> pozic, what happened to the 4?
04:14:55 <pozic> Look at the result of mono.
04:15:04 <pozic> U R DOING IT WRONG.
04:15:10 <pozic> ;)
04:15:25 <Botje> why would it turn 1 4 3 into 1 3 3?
04:15:32 <ziman> @src group
04:15:32 <lambdac> group = groupBy (==)
04:15:40 <ivanm> @src groupBy
04:15:40 <lambdac> groupBy _  []       =  []
04:15:40 <lambdac> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
04:15:40 <lambdac>     where (ys,zs) = span (eq x) xs
04:15:41 <ziman> @src groupBy
04:15:41 <lambdac> groupBy _  []       =  []
04:15:41 <lambdac> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
04:15:42 <lambdac>     where (ys,zs) = span (eq x) xs
04:15:43 <ziman> oops
04:15:46 <pozic> Botje: because 4 > 3.
04:15:46 <ivanm> heh
04:15:57 <RayNbow> pozic, mono [1,4,3,2] = ?
04:16:07 <ivanm> pozic: so should it have been [1,3]? rather than [1,3,3]?
04:16:12 <pozic> RayNbow: [1,2,2,2]
04:16:13 <ivanm> if so...
04:16:14 <earthy> I'd guess 1,2,2,2
04:16:20 <ivanm> ahhh...
04:16:29 <ayu> @tell ivanm hi
04:16:29 <lambdac> Consider it noted.
04:16:35 <Botje> that's a pretty freaky function :)
04:16:36 <ivanm> probably using a zip on the tail or something then...
04:16:36 <lambdac> ivanm: You have 1 new message. '/msg lambdac @messages' to read it.
04:16:43 <ivanm> @messages
04:16:43 <lambdac> ayu said 13s ago: hi
04:16:49 <ayu> @messages
04:16:49 <lambdac> You don't have any new messages.
04:17:00 <pozic> Hmm, I think something similar to fibs would work here.
04:17:01 <RayNbow> you probably want to play with foldr, pozic :)
04:17:29 <Botje> > groupBy (>) [1,4,3,2]
04:17:30 <lambdac>  [[1],[4,3,2]]
04:17:35 <Botje> this could be a start, i guess
04:17:44 <ayu> @tell Botje wassup :D
04:17:44 <lambdac> Consider it noted.
04:17:49 <Botje> replace each group by its last element
04:17:50 <lambdac> Botje: You have 1 new message. '/msg lambdac @messages' to read it.
04:17:52 <Botje> hello, ayu :P
04:17:57 <ayu> hey
04:18:02 <ayu> wow you guys are still here
04:18:14 <ayu> do you work for the haskell irc thingy?
04:18:22 <ayu> curious
04:18:23 <Botje> pozic: so .. how about this?
04:18:50 <Botje> > let mono = concatMap (\l -> replicate (length l) (last l)) . groupBy (>)
04:18:51 <lambdac>  Parse error at end of input
04:18:53 <ivanm> ayu: work for who?
04:18:57 <RayNbow> @tell RayNbow calling myself... :p
04:18:57 <lambdac> You can tell yourself!
04:19:02 <Botje> > let mono = concatMap (\l -> replicate (length l) (last l)) . groupBy (>) in mono [1,4,3,2]
04:19:03 <lambdac>  [1,2,2,2]
04:19:05 <ayu> for the irc?
04:19:09 <Botje> > let mono = concatMap (\l -> replicate (length l) (last l)) . groupBy (>) in mono [1,4,3]
04:19:10 <lambdac>  [1,3,3]
04:19:12 <ayu> @tell vixey im back :D
04:19:12 <lambdac> Consider it noted.
04:19:15 <Botje> is that what you want? :p
04:19:21 <ziman> pozic, http://hpaste.org/9544 i think it was you who was looking for something similar
04:20:37 <Botje> pozic: *prod*
04:20:52 <ayu> hmm guys, is there any way to make this code more efficient? http://hpaste.org/9538
04:20:53 <luite> > let mono = concatMap (\l -> replicate (length l) (last l)) . groupBy (>) in mono [1,4,3,4,2]
04:20:55 <lambdac>  [1,3,3,2,2]
04:21:44 <ziman> ayu, for example, by directly calculating the third variable
04:22:10 <pozic> Botje: I came up with: http://paste.debian.net/14495/
04:22:13 <Botje> ayu: uh, for one, x+1 and y+1 could be > n
04:22:35 <Botje> pozic: does it work?
04:22:42 <pozic> Botje: mine does.
04:22:47 <pozic> Botje: I didn't try yours.
04:22:56 <Botje> mine works for the two examples you gave
04:23:01 <ziman> @pl (\l -> replicate (length l) (last l))
04:23:02 <lambdac> liftM2 replicate length last
04:23:07 <luite> Botje: but not for the one I gave
04:23:21 <pozic> ziman: yes, but someone already wrote one in the channel that's isomorphic to yours.
04:24:02 <Botje> ayu: also, you don't have to compute z.
04:24:09 <ayu> Botje: o_o
04:24:09 <Botje> you already know it as sqrt(x*x+y*y)
04:24:16 <Botje> just have to check it's an integer ;)
04:24:40 <ayu> Botje: check it as integer?
04:24:41 <pozic> Botje: I think my version is easier to read.
04:25:02 <ayu> Botje: the question says x*x+y*y= z*z must be true, else dont display it
04:25:10 <Botje> but you have to supply "end" yourself
04:25:22 <Botje> ayu: well, yeah, but you'll waste a lot of time checking if 4*4+3*3 == 1*1
04:25:34 <ayu> Botje: so how o_o "
04:25:43 <pozic> Botje: it are two different functions.
04:25:44 <ayu> Botje: I don't really understand this  x+1 and y+1 could be > n
04:25:57 <Botje> ayu: x goes from 1 to n
04:26:01 <ayu> yeah
04:26:07 <Botje> so if x is n
04:26:08 <ayu> Botje: correct
04:26:11 <Botje> x+1 is .. :)
04:26:31 <ayu> Botje: n+1?
04:26:41 <Botje> yes :p
04:26:48 <ayu> Botje: so... o_o
04:27:05 <Botje> might not be what you wanted :p
04:27:35 <ayu> Botje: -_-  i really dont understand where is this going
04:27:48 <Botje> nevermind then
04:27:55 <ayu> Botje: do you understand how the code works?
04:28:03 <Botje> your code?
04:28:04 <Botje> sure
04:28:22 <RayNbow> Botje, pozic, http://hpaste.org/9545
04:28:39 <ayu> Botje: man, you're good . so is there a way to make it more efficient?
04:29:02 <Botje> i already told you, stop enumerating over z :)
04:30:25 <Botje> let sqr = x*x+y+y, let z = floor $ sqrt $ fromIntegral sqr, sqr == z^2
04:30:32 <hackage> Uploaded to hackage: HipmunkPlayground 0.2
04:30:32 <hackage> Uploaded to hackage: Hipmunk 0.2
04:30:32 <hackage> Uploaded to hackage: cabal2arch 0.3.8.1
04:30:33 <hackage> Uploaded to hackage: cabal2arch 0.3.8
04:30:35 <hackage> Uploaded to hackage: formlets 0.4
04:30:40 <Botje> instead of z <- ... and the check
04:31:48 <|Steve|> Is there any reason to use g $ h $ f x instead of g . h $ f x, or vice versa?
04:32:06 <opqdonut> (g . h) works on it's own
04:32:12 <opqdonut> (g $ h) does not
04:32:16 <Botje> people say the form with . is slightly better
04:32:21 <Botje> i don't quite mind :)
04:32:22 <opqdonut> many people advocate the use of (.)
04:32:30 <|Steve|> Is there a reason to do so?
04:32:33 <pozic> RayNbow: you can replace the guards with min.
04:33:04 <ziman> (.) is more compositional -- you can isolate parts without changing anything
04:33:11 <RayNbow> pozic: ah, true
04:33:33 <|Steve|> Is ghc going to produce more efficient code for either?
04:33:43 <opqdonut> |Steve|: equivalent
04:33:49 <ziman> and, i prefer (.) over ($) because it makes less visual clutter
04:33:50 <|Steve|> Or for g (h (f x)) for that matter?
04:33:59 <opqdonut> they're all the same
04:34:04 <Botje> nope
04:34:05 <ayu> what is $
04:34:11 <Botje> money!
04:34:18 <Botje> also a way to avoid writing ()
04:34:19 <|Steve|> > ($) (+1) 5
04:34:20 <lambdac>  6
04:34:29 <opqdonut> I don't really understand why people keep asking about the code generated for obviously equivalent expressions
04:34:33 <Botje> length (tail l) vs length $ tail l
04:34:49 <RayNbow> pozic, http://hpaste.org/9545#a1 <-- there we go :)
04:34:53 <opqdonut> you should trust ghc!
04:34:53 <Botje> opqdonut: it's the same people who religiously use ++foo instead of foo++ "because it's faster" :)
04:35:03 <quicksilver> (.) is associative.
04:35:12 <quicksilver> associative operators are Better(tm)
04:35:13 <|Steve|> opqdonut: It's not obviously equivalent. h . g . f could actually produce a new function when none is needed.
04:35:16 <opqdonut> Botje: heh
04:35:18 <quicksilver> because they identify for subexpressions.
04:35:18 <smg> Botje: how about (length . tail) l
04:35:22 <|Steve|> Botje: In c++ it can be faster.
04:35:24 <idnar> Botje: it is faster in C++ :P
04:35:31 <opqdonut> |Steve|: well, it doesn't if you know how the graph reduction works
04:35:33 <|Steve|> In particular with stl iterators.
04:35:44 <quicksilver> opqdonut: eh?
04:35:46 <Botje> wrong :)
04:35:48 <|Steve|> opqdonut: I don't know how ghc produces code, hence my question.
04:35:56 <quicksilver> opqdonut: if you understand graph reduction you wouldd expect (.) to be slower.
04:35:56 <smg> Botje: works for me
04:35:59 <quicksilver> more things to reduce.
04:36:07 <paczesiowa> @seen dons
04:36:07 <lambdac> dons is in #haskell. I last heard dons speak 5h 6m 42s ago.
04:36:07 <Botje> if the result is not used ++foo is equal to foo++ in terms of gneerated code
04:36:09 <Botje> smg: not you :)
04:36:13 <smg> k
04:36:14 <idnar> Botje: I guess your C++ compiler is better than mine
04:36:19 <|Steve|> Botje: Not true at all.
04:36:20 <opqdonut> quicksilver: slower than ($)? hardly
04:36:24 <idnar> Botje: because when I checked this out last, it didn't optimize the copy away
04:36:31 <quicksilver> opqdonut: slower than h(g(f(x)))
04:36:31 <opqdonut> slower than f (g (h x))? yeah
04:36:32 <Botje> really?
04:36:35 <paczesiowa> @tell help
04:36:35 <lambdac> Consider it noted.
04:36:41 <|Steve|> The compiler cannot determine that the copy has no side effects.
04:36:43 <paczesiowa> @tell paczesiowa test
04:36:43 <lambdac> You can tell yourself!
04:36:44 <Botje> one more reason to switch to ghc then :)
04:36:54 <idnar> Botje: it's only an issue when operator++ is user-defined
04:36:58 <paczesiowa> @tell lambdac test
04:36:58 <lambdac> Nice try ;)
04:37:03 <quicksilver> some C++ compilers can determine, in some cases, that the copy has no side effects.
04:37:07 <idnar> Botje: the postfix form has to be written to return a copy
04:37:08 <ziman> |Steve|, even for primitive types like int?
04:37:22 <idnar> and g++ couldn't optimize that away, the last time I checked
04:37:25 <quicksilver> by inlining everything
04:37:28 <|Steve|> ziman: No, not for primitive types, I said <|Steve|> In particular with stl iterators.
04:37:28 <idnar> (heck, maybe it can now, this was probably 3-4 years ago)
04:37:30 <quicksilver> (which is what GHC does, indeed)
04:37:31 <pozic> RayNbow: yes, I already did that.
04:37:34 <paczesiowa> @tell dons I sent you those patches by email. what would you say about other patches: ligthweight (modifiers and setters for every field in every record - only new api), medium (reading, writing and modifying in-place feeds from disk - new api but additional deps - Strict), heavyweight (changing date-like fields from strings to proper Time types - breaks old api)
04:37:34 <lambdac> Consider it noted.
04:37:37 <ziman> oh
04:37:53 <idnar> I doubt I'll ever write C++ code again
04:38:04 <RayNbow> pozic: I just annotated the hpaste for archival purposes :)
04:38:05 <chrisdone> don't say that
04:38:09 <idnar> at least, I certainly hope I won't have to ;)
04:38:14 <|Steve|> It can't if operator++ is defined in a different translation unit from the copy constructor.
04:38:17 <chrisdone> you know what happens when someone says "that's the last we'll see of them! *pats hands*"
04:38:18 * idnar touches multiple wooden objects
04:38:34 <|Steve|> Or unless it does link time optimizations, but gcc doesn't do that sort.
04:39:48 <|Steve|> quicksilver: See comment about translation units.
04:41:05 <|Steve|> I like opqdonut's implication that everyone writing haskell should understand the inner workings of the compiler.
04:41:57 <opqdonut> does anyone know whether ghc inlines (.) and ($)? I'd guess yes
04:42:44 <|Steve|> ($) I would hope would be inlined.
04:42:58 <ivanm> |Steve|: well, is there a relatively easy to understand _short_ guide to ghc internals?
04:43:15 <ivanm> because I don't particularly feel like reading through all the source just to work out how it works!
04:43:20 <chrisdone> > map ($3) [(+1),(*2),(^2)]
04:43:21 <lambdac>  [4,6,9]
04:43:26 <|Steve|> I haven't the slightest clue. I wouldn't be asking such questions if I knew how ghc worked.
04:44:07 <opqdonut> ivanm: the "implementing functional programming languages" paper is pretty nice for a high-level understanding of the evaluation model and stuff
04:44:22 <smg> chrisdone: this is awesome :)
04:44:25 <pozic> opqdonut: but the evaluation model in GHC is not the same anymore.
04:44:28 <opqdonut> AFAIK it's pretty close to how ghc basically works
04:44:30 <opqdonut> oh, okay
04:44:39 <ivanm> opqdonut: OK, thanks!
04:44:49 <opqdonut> ivanm: check what pozic said
04:44:56 <ivanm> :(
04:44:56 <pozic> There is some developer documentation and a guide to the source.
04:44:57 <opqdonut> but the paper is a good read anyways
04:45:14 <pozic> Otherwise you just need to read the source and ask questions on dev mailing lists.
04:45:26 <|Steve|> The source is rather large.
04:45:42 <pozic> Writing patches to the documentation as you go over it gives you bonus points and people will take you more seriously.
04:45:46 <opqdonut> ivanm: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
04:45:48 <lambdac> Title: Commentary/Rts/HaskellExecution - GHC - Trac, http://tinyurl.com/2xet5k
04:46:28 <opqdonut> or rather, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/StgSynType
04:46:30 <lambdac> Title: Commentary/Compiler/StgSynType - GHC - Trac, http://tinyurl.com/6ch22v
04:47:58 <BeelsebobWork> @where lambdabot
04:47:59 <lambdac> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:48:20 <BeelsebobWork> bah, that just forwards to the Haskell wiki
04:48:27 <BeelsebobWork> where are the docs for it?
04:49:12 <|Steve|> Todo: say more.
04:49:55 <pozic> |Steve|: despite millions of fanboys on Reddit, GHC is not nirvana.
04:50:18 <|Steve|> Fortunately, I don't read reddit.
04:51:09 <|Steve|> I have been pretty impressed with ghc's performance in my very limited use, although I wish it didn't take so long to compile things.
04:51:09 <BeelsebobWork> how does one `enable' a plugin in \bot?
04:51:29 <|Steve|> It probably helps if one doesn't pretend that ` is a left quote and ' is a right quote.
04:51:49 <BeelsebobWork> hmm? sorry, LaTeXism
04:52:21 <|Steve|> Yeah, I really wish Knuth hadn't gone with that.
04:52:47 <ziman> gnu folks have, too
04:52:55 <|Steve|> ` is clearly a grave accent while ' is an apostrophe. Ascii doesn't have angled quotes.
04:53:01 <BeelsebobWork> no
04:53:12 <BeelsebobWork> `is a grave accent
04:53:16 <opqdonut> ' is a single quote, both left and right ;)
04:53:19 <BeelsebobWork> and is not the same as `
04:53:30 <BeelsebobWork> (unicode doom)
04:53:31 <earthy> in this font it is :)
04:53:43 <earthy> 2 pixels. :)
04:53:47 <BeelsebobWork> earthy: yeh, a lot of fonts make them the same thing
04:53:53 <BeelsebobWork> but they're not
04:53:53 <|Steve|> Uh, BeelsebobWork It's the same character.
04:54:00 <|Steve|> $ echo '``'|xxd
04:54:00 <|Steve|> 0000000: 6060 0a
04:54:08 <BeelsebobWork> o.O
04:54:09 <BeelsebobWork> wierd
04:54:19 <peter1> Anybody familiar with ghci debugger? I have two problems:
04:54:19 <peter1> 1) :main requires me to be in the scop of Main module which sounds funny since for a program there should be only one Main.main so why it cannot call it directly
04:54:19 <peter1> 2) when I stop on a breakpoint then it does not set automatically scop to that breakpoint so local identifiers are not recognized in print commands, hot to make it scope automatically to the local scope?
04:54:59 <Zao> The worst thing is IRC clients who are friendly enough to map ticks and double-ticks to typographic quotes.
04:55:07 <BeelsebobWork> peter1: do you happen to be writing Haskell 98 code?
04:55:23 <peter1> BellselbobWork: yes
04:55:23 <pozic> |Steve|: you can make GHC compile faster by turning optimizations off.
04:55:43 <BeelsebobWork> peter1: then you may have more success using Hat to debug than using ghci debugger
04:56:29 <|Steve|> http://www.unicode.org/charts/PDF/U0000.pdf clearly shows that U+0060 is a grave accent and U+0027 is an apostrophe (yes or an apostrophe-quote or APL quote or neutral glyph with mixed usage).
04:56:44 <BeelsebobWork> |Steve|: fair enough, I thought those two were different things
04:56:44 <mnislaih> peter1: the ghci debugger only brings free identifiers in scope, not all identifiers
04:56:50 <pozic> BeelsebobWork: why is Hat not on Hackage?
04:56:56 <BeelsebobWork> pozic: because it's not cabalised
04:57:00 <|Steve|> pozic: Sure... I can also use runghc instead. That's sort of beside the point.
04:57:09 <peter1> hmmm, OK, I heard about it but I never tried it, but is there any way to make ghci more friendly; especially so that it sets the scope to the local scope when I stop on a breakpoint
04:57:52 <mnislaih> peter1: the ghci debugger gives access to the free identifiers only, not all identifiers in scope
04:57:54 <peter1> mnislaih: what do you mean by "free"?
04:57:58 <pozic> |Steve|: either you don't agree with the optimization architecture, or it's inherent to the optimizations being expensive then.
04:58:02 <mnislaih> as in free variables
04:58:19 <mnislaih> peter1: use :step or better :steplocal to reach a point where the identifier you want is available
04:58:37 <|Steve|> pozic: Even without optimization, it's still slow as compared to say compiling c with gcc.
04:59:20 <BeelsebobWork> |Steve|: that's inherant in Haskell being a complicated language
04:59:21 <|Steve|> It's a minor complaint, but compiling something large like ghc takes a really long time.
04:59:26 <BeelsebobWork> C was designed to be single pass compiled
04:59:33 <BeelsebobWork> Haskell IIRC needs at *least* 3 passes
04:59:53 <|Steve|> Well, not quite. C was designed to be similar to PDP (I think) assembly.
04:59:57 <pozic> BeelsebobWork: no, it doesn't.
05:00:06 <BeelsebobWork> also, compiling GHC doesn't take long any more
05:00:10 <|Steve|> Or have a simple mappingi to PDP assembly.
05:00:11 <BeelsebobWork> it takes about 20 minutes on my machine
05:00:25 <quicksilver> BeelsebobWork: haskell does not attempt to compile in a 'streaming' fashion
05:00:31 <|Steve|> GHC + libraries take over an hour on my computer.
05:00:32 <quicksilver> BeelsebobWork: so you can't really count the passes meaningfully
05:01:08 <BeelsebobWork> quicksilver: true enough -- but if you were to try to compile it in a "streaming" fassion -- you would need at least one pass to parse, a second to type check, and a third to generate code
05:01:26 <BeelsebobWork> because you can't type check without all the parsed code
05:01:32 <BeelsebobWork> and you can't generate code without type checking
05:01:33 <quicksilver> right.
05:01:33 <pozic> BeelsebobWork: those are conceptual passes, but not how it would work operationally.
05:02:40 <Philippa> re
05:02:42 <Philippa> I got dropped, so in reply to BeelsebobWork's comment about haskell being complicated:
05:02:44 <Philippa> yeah, there's significantly more work involved in: parsing, typechecking, getting the code down to a level vaguely near the machine's level...
05:03:04 <|Steve|> Hello world (on my _very_ slow machine, not the one quoted above, but this one) takes over 2 seconds to compile hello world, a one line program in Haskell and .3 seconds to compile the equivalent in c with gcc and no optimizations for either.
05:03:53 <Philippa> |Steve|: that's not entirely the fairest comparison, most of that'll be overhead
05:04:02 <ivanm> |Steve|: yes, but the haskell one is guaranteed to be a _quality_ binary! :p
05:04:11 <quicksilver> pozic: they represent something like a lower bound, in the sense that those 3 passes can't be easily combined
05:04:17 <quicksilver> (and that's without optimisation, of course)
05:04:25 <ivanm> and you're of course assuming that they've optimized the compiler...
05:04:41 <|Steve|> It's all 3.4 MB as opposed to 11 kB. What part of that is quality?
05:04:46 <|Steve|> s/all/also/
05:04:50 <Philippa> |Steve|: run strip over it
05:04:58 <Philippa> it'll still be bigger, but nowhere near as much
05:05:11 <jeffz> |Steve|: it contains the RTS
05:05:14 <quicksilver> |Steve|: well, it statically links the whole library which you aren't useing.
05:05:18 <quicksilver> not just the RTS.
05:05:20 <|Steve|> Haskell is down to 2.1 MB, C is down to 4.1 kB.
05:05:23 <quicksilver> the whole core lib.
05:05:30 <quicksilver> all of package 'base'
05:05:42 <|Steve|> That seems wasteful.
05:05:47 <quicksilver> it's simple.
05:05:56 <quicksilver> standard linkers do that
05:05:59 <quicksilver> they link whole libraries
05:06:07 <quicksilver> there is a split-objs thing to link at the level of functions
05:06:08 <quicksilver> if you want.
05:06:28 <|Steve|> Usually static linkers only link in symbols required to resolve undefined symbols.
05:06:37 <quicksilver> that is not true.
05:06:40 <quicksilver> AIUI.
05:06:44 <|Steve|> AIUI?
05:06:48 <quicksilver> as I understand it.
05:06:49 <Philippa> <|Steve|> Or unless it does link time optimizations, but gcc doesn't do that sort. <- no, but it does something close - that's what the .hi files're for
05:06:58 <quicksilver> Philippa: that's ghc not gcc
05:07:08 <quicksilver> Philippa: (which was steve's point, he was talking about C++ there)
05:07:11 <Philippa> d'oh, yes
05:07:19 <Philippa> ...clearly I still haven't recovered from thursday/friday
05:07:22 <luqui> can .cabal files make decisions based on what version of ghc is being used?
05:07:23 <|Steve|> quicksilver: ld will only pull symbols in from a static library needed to satisfy undefined symbols.
05:07:39 <quicksilver> |Steve|: I don't think that is true.
05:07:44 <|Steve|> That's why library order can be such a pain in the ass and some times libraries need to be specified twice if there are circular dependencies.
05:07:46 <quicksilver> |Steve|: I don't think that's even possible.
05:07:55 <quicksilver> it only pulls in .o files as needed
05:07:57 <quicksilver> not symbols
05:08:02 <quicksilver> quite a different thing :)
05:08:20 <|Steve|> Put one symbol per object file and you get that.
05:08:23 <quicksilver> right.
05:08:26 <quicksilver> which is what split-obj does
05:08:30 <quicksilver> more or less.
05:09:08 <paczesiowa> why old-time and old-locale are called old?
05:09:17 <quicksilver> because they are obsolete.
05:09:37 <pozic> quicksilver: a compiler based on attribute grammars won't have operationally identifiable distinct passes.
05:10:09 <Philippa> pozic: nor will a lazily evaluated one. So?
05:10:36 <paczesiowa> quicksilver: why?
05:10:45 <dcoutts> luqui: yes, if impl(ghc >= 6.8), however don't use that as a proxy for library versions as that will fail for other compilers or for ghc-6.10 which will come with base 3 and 4
05:10:52 <drigz> g++ takes longer than ghc on hello world on my machine
05:10:56 <Philippa> (but: GHC doesn't make multiple passes through the original source anyway - rather, it has identifiable phases and it has optimisation passes that do need to be ordered)
05:11:02 <cjs> @seen dons
05:11:03 <lambdac> dons is in #haskell. I last heard dons speak 5h 41m 38s ago.
05:11:15 <pozic> Philippa: writing one in that style is a pain.
05:11:23 <quicksilver> paczesiowa: because the new ones are better
05:11:41 <quicksilver> pozic: indeed but that hardly contradicts my point.
05:11:58 <quicksilver> if one were to try to write a streaming compiler for haskell you would need at least 3 passes.
05:12:01 <quicksilver> that's all I was saying.
05:12:09 <quicksilver> I did *also* say that GHC is not such a compiler.
05:12:14 <luqui> dcoutts, yes, that's not the purpose.  ghc did some extension renaming...
05:12:18 <luqui> thanks
05:13:10 <dcoutts> luqui: in that case it's usually better to use the extensions field since Cabal can translate extension names into ghc flags for the ghc version.
05:14:19 <|Steve|> sleep time
05:14:31 <mercury^> drigz: C++ linking is a very complicated process.
05:15:01 <Dr_Zooix> Hello all !
05:15:17 <drigz> mercury^: i fully understand that - i was just pointing out that |Steve| was comparing a language designed partly for easy, fast compilation to haskell
05:15:28 <Dr_Zooix> I've got a little problem with this code: http://rafb.net/p/JXkaaP37.html
05:15:29 <lambdac> Title: Nopaste - The Haskell code for a get_list function
05:15:56 <drigz> Dr_Zooix: are you an ml user?
05:16:00 <Dr_Zooix> Can somebody help me please ? I'm a newbie in Haskell ^^
05:16:20 <Dr_Zooix> drigz: A little yes, but I prefer Haskell ^
05:16:29 <drigz> Dr_Zooix: you're using :: instead of : at one point
05:16:46 <besiria> can some1 explain to me briefly par , seq , pseq? i'm reading RealWorldHaskell and finding it hard
05:17:20 <Dr_Zooix> drigz: Thanks ! I'm such an idiot ;) I'll try it.
05:17:29 <drigz> Dr_Zooix: i think your read might fail because of the "\n"
05:17:34 <drigz> > read "5\n"
05:17:35 <lambdac>  Exception: Prelude.read: no parse
05:17:38 <adekoba> Dr_Zooix: I'm not sure what you're trying to do on line 12
05:17:58 <paczesiowa> modify list in place
05:17:58 <adekoba> Dr_Zooix: and if the input is nothing, getLine will return "", not "\n"
05:18:27 <drigz> and you probably want get_line (read elem : x) instead of the do block on lines 12-13
05:18:40 <Dr_Zooix> I wanna ask the user to enter a list and if he press "enter", the list is complet.
05:19:05 <adekoba> ah, ok. Yes, Dr_Zooix: do what drigz said.
05:19:20 <Dr_Zooix> adekoba: Ok ;)
05:19:24 <quicksilver> besiria: they control when things get evaluated.
05:19:37 <quicksilver> besiria: a `seq` b, when evaluated, evaluated a before b
05:19:42 <quicksilver> (but returns the result of b)
05:20:12 <quicksilver> besiria: a `par` b evaluates a in parallel (not guaranteed to do anything) and returs the result of b
05:20:47 <drigz> Dr_Zooix: you know this will return the list in reverse order
05:20:52 <hansfbaier> monads seem easy now, but I have problems understanding applicative functors, especially how they represent effecful programming
05:21:03 <hansfbaier> anyone who can explain?
05:21:20 <luqui> hansfbaier, the same way monads do, they are just a little more restricted
05:21:20 <Dr_Zooix> So that's the new code: http://rafb.net/p/Zy2EUQ55.html but I still get errors :/
05:21:21 <lambdac> Title: Nopaste - No description
05:21:25 <hansfbaier> I read the paper, the wikibook and the haskell wiki page, but maybe not thoroughly enough
05:21:32 <luqui> pure = return; (<*>) = ap
05:21:59 <luqui> (but you're probably not used to using ap)
05:22:05 <hansfbaier> luqui: right.
05:22:12 <besiria> quicksilver: seq guarantees that both exprs get evaluated?
05:22:14 <adekoba> Dr_Zooix: the variable x is an accumulator. You must pass the (elem:x) to get_list
05:22:19 <hansfbaier> luqui: got to look at it again.
05:22:37 <luqui> hansfbaier, the main pattern is: f <$> arg1 <*> arg2 <*> arg3 ...
05:22:38 <adekoba> Dr_Zooix: otherwise, you are just passing the same initial list to get_list over and over again.
05:22:53 <luqui> (or liftA3 f arg1 arg2 arg3)
05:23:04 <adekoba> replace lines 12 & 13 with "else get_list (elem:x)"
05:23:09 <luqui> which does arg1, *then* arg2, *then* arg3, then combines the results with f
05:23:52 <hansfbaier> luqui: so arg1, arg2,... are functions / computations?
05:23:54 <Dr_Zooix> adekoba: ok thanks.
05:23:58 <luqui> but if you have an AF of a function, you can apply it to an AF of its argument with <*>
05:24:14 <adekoba> Dr_Zooix: yep
05:24:22 <luqui> so using the IO AF:   getTwoLines = (++) <$> getLine <*> getLine
05:24:36 <luqui> (but IO is not where AFs shine :-)
05:24:41 <hansfbaier> luqui: now that enlightens me a bit....
05:24:58 <paczesiowa> luqui: where does it shine?
05:25:15 <luqui> in things like parsers, where the monadic implementation is much less efficient
05:25:25 <luqui> (or in things like zip lists, where there is no monad)
05:25:51 <luqui> basically, use a monad for effects unless you have a reason not to.  Turns out there are plenty of reasons not to :-)
05:25:57 <quicksilver> besiria: a `seq` b guarantees that when b is evaluated, a is evaluated (first)
05:26:05 <luqui> right and I forgot the most important thing about AFs!
05:26:07 <paczesiowa> why is it more efficient than monads?
05:26:15 <luqui> there are no AF transformers.  AFs cleanly compose by themselves.
05:26:33 <quicksilver> hansfbaier: the simplest way to approach AFs from monads is jsut to consider them a new notation for monads
05:26:47 <gwern> @seen dcoutts
05:26:47 <lambdac> dcoutts is in #haskell. I last heard dcoutts speak 13m 37s ago.
05:26:50 <quicksilver> hansfbaier: a slightly more restricted one; there is slightly less you can do with AFs.
05:26:59 <quicksilver> hansfbaier: then you can notice that a few things are AFs but not monads.
05:27:07 <luqui> paczesiowa, roughly because AFs allow more sharing, since you know in a <*> b that b does not depend on a
05:27:11 <luqui> which you don't get with monads.
05:27:32 <quicksilver> besiria: for a very specific notion of 'evaluated'
05:28:08 <BeelsebobWork> for a traditional notion, you'd need deepSeq instead
05:28:15 <BeelsebobWork> "traditional"
05:28:17 <gwern> dcoutts: there is an issue with wxhaskell's cabalization where it does some manual ghc-pkg operations; if it is edited to use --user (to make it work with everyone who is installing non-root) would that mess up a sudo system-wide install?
05:28:29 <BeelsebobWork> @seen lispy
05:28:29 <lambdac> lispy is in #haskell. I last heard lispy speak 5h 10m 28s ago.
05:28:33 <quicksilver> or 'rnf' which is provided by the same suite of modules as 'par'
05:28:36 <Dr_Zooix> adekoba: And how can I get the numerical value of a string. For exemple: "89" => 89 .
05:28:40 <quicksilver> Dr_Zooix: read
05:28:42 <BeelsebobWork> @seen dons
05:28:43 <lambdac> dons is in #haskell. I last heard dons speak 5h 59m 18s ago.
05:28:55 <paczesiowa> luqui: ok, last question: are there coapplicative cofunctors?
05:29:04 <besiria> quicksilver: and what about pseq?
05:29:10 <luqui> haha I've just been thinking about those
05:29:12 <Botje> only in the couinverse
05:29:45 <luqui> paczesiowa, project :: f a -> a, coap :: f (a -> b) -> f b -> f a ... maybe?
05:30:03 <vixey> hmmmm
05:30:03 <lambdac> vixey: You have 1 new message. '/msg lambdac @messages' to read it.
05:30:15 <vixey> are there any concrete definitions of coap?
05:30:30 <opqdonut> :t <*>
05:30:31 <lambdac> parse error on input `<*>'
05:30:36 <opqdonut> :t (<*>)
05:30:37 <lambdac> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:30:39 <Dr_Zooix> quicksilver: euh yes but this: http://rafb.net/p/G4S1ch10.html doesn't work :/
05:30:39 <hansfbaier> ap is really weird: >  ap (return print) (return "adasdfsadf")
05:30:39 <lambdac> Title: Nopaste - No description
05:30:46 <vixey> oh
05:30:48 <vixey> @src Applicative
05:30:49 <lambdac> class Functor f => Applicative f where
05:30:49 <lambdac>     pure  :: a -> f a
05:30:49 <lambdac>     (<*>) :: f (a -> b) -> f a -> f b
05:30:53 <vixey> I thought it was functor
05:31:03 <vixey> @instances Applicative
05:31:04 <lambdac> Couldn't find class `Applicative'. Try @instances-importing
05:31:12 <vixey> @instances-importing Control.Monad.Applicative Applicative
05:31:13 <lambdac> Couldn't find class `Applicative'. Try @instances-importing
05:31:15 <EvilTerran> ?instances-importing Control.Applicative Applicative
05:31:15 <lambdac> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
05:31:17 <adekoba> Dr_Zooix: make sure you give a type definition, or proper context so that read knows the correct type to convert the string into.
05:31:26 <paczesiowa> see that's the problem with cothings - you ask stupid question as a joke and you get too smart answer:/
05:31:30 <adekoba> Dr_Zooix: e.g. (read elem :: Integer)
05:31:37 <hansfbaier> > print " test ! "
05:31:39 <lambdac>  <IO ()>
05:31:56 <hansfbaier> ﻿>  ap (return print) (return "adasdfsadf")
05:32:01 <BeelsebobWork> Dr_Zooix: the other thing -- your if does not need to be within the IO monad -- just turn it into return pureFunction
05:32:11 <BeelsebobWork> where pureFunction has an appropriate definition ofc
05:32:17 <hansfbaier> something weird goes on here with laziness.....
05:32:32 <quicksilver> besiria: no idea. Where is it documented?
05:32:59 <quicksilver> Dr_Zooix: you must never, ever say "doesn't work"
05:33:04 <quicksilver> Dr_Zooix: you must always explain what happens
05:33:09 <quicksilver> is there an error message?
05:33:11 <quicksilver> put it in the paste.
05:33:16 <quicksilver> did your program do not what you expected?
05:33:21 <BeelsebobWork> also -- use hpaste
05:33:21 <quicksilver> explain what it did.
05:33:28 <BeelsebobWork> so that we get Haskell syntax highlighting
05:33:31 <Dr_Zooix> euh ok ^^wait a secon please
05:33:31 <hansfbaier> luqui: Do you have an Idea, why ﻿>  ap (return print) (return "adasdfsadf")
05:33:37 <hansfbaier> luqui: doesnt get evaluated?
05:33:56 <quicksilver> luqui: it does.
05:33:57 <vixey> @messages
05:33:58 <lambdac> ayu said 1h 14m 46s ago: im back :D
05:33:59 <quicksilver> hansfbaier: it does
05:34:05 <quicksilver> hansfbaier: it returns an IO action.
05:34:06 <vixey> @tell ayu welcome back :p
05:34:07 <lambdac> Consider it noted.
05:34:08 <quicksilver> look at the type
05:34:08 <hansfbaier> luqui: but where is the effect?
05:34:15 <quicksilver> :t ap (return print) (return "adasds")
05:34:16 <lambdac> forall (m :: * -> *). (Monad m) => m (IO ())
05:34:16 <luqui> that doesn't even look like it should typecheck...
05:34:17 <hansfbaier> quicksilver: aaah,
05:34:25 <besiria> quicksilver: found it in Real World Haskell http://book.realworldhaskell.org/beta/concurrent.html
05:34:28 <lambdac> Title: Chapter 26. Concurrent and multicore programming
05:34:44 <hansfbaier> > sequence [﻿ap (return print) (return "adasdfsadf")]
05:34:45 <lambdac>  Illegal character ''\187''
05:34:45 <lambdac>  at "ap" (column 12)
05:35:03 <hansfbaier> ﻿> sequence [﻿(ap (return print) (return "adasdfsadf"))]
05:35:06 <quicksilver> besiria: surely the description there is better than any I could give :)
05:35:13 <hansfbaier> ??!?!?!?!?!?
05:35:25 <hansfbaier> quicksilver: shouldnt that run the IO action?
05:35:39 <quicksilver> hansfbaier: no.
05:35:51 <besiria> quicksilver: yeap , you're right. From what i understand pseq gives a stronger guarantee that left gets evaluated first
05:35:54 <quicksilver> :t sequence [ ap (return print) (return "adasds")]
05:35:56 <lambdac> forall (m :: * -> *). (Monad m) => m [IO ()]
05:36:03 <quicksilver> hansfbaier: ^^ it's still double wrapped.
05:36:08 <luqui> sequence (ap (return print) (return "adasds"))
05:36:15 <luqui> > sequence (ap (return print) (return "adasds"))
05:36:16 <lambdac>  <IO [()]>
05:36:24 <quicksilver> luqui: that's a bit weird because it forces 'ap' into the list monad
05:36:27 <quicksilver> luqui: but, it works.
05:36:28 <luqui> *that* runs the action, but it's not exactly transparent
05:36:42 <hansfbaier> luqui: but where is the output?
05:36:51 <quicksilver> hansfbaier: lamdabot won't run IO
05:36:54 <quicksilver> otherwise you could say
05:36:54 <BeelsebobWork> hansfbaier: \bot doesn't do IO
05:36:58 <quicksilver> > launchNuclearMissiles
05:36:59 <lambdac>   Not in scope: `launchNuclearMissiles'
05:37:02 <quicksilver> and the world would end.
05:37:06 <BeelsebobWork> lol
05:37:12 <quicksilver> which would be, like, the best IRC troll ever.
05:37:21 <hansfbaier> :)
05:37:25 * BeelsebobWork wishes he could @remember that
05:37:41 <paczesiowa> so what, \bot would return new world
05:38:03 <gwern> I've always been found of 'unsafePerformIO $ readFile \"/home/cale/doc/finance.xls\"'
05:38:21 <BeelsebobWork> heh
05:39:01 <BeelsebobWork> so does anyone here have experience with getting lambdabot set up?
05:39:02 <quicksilver> continuity error
05:39:09 <quicksilver> surely a smart guy like Cale woudln't use excel.
05:39:14 <vixey> ?go wotsit xls
05:39:17 <lambdac> http://www.wotsit.org/list.asp?al=X
05:39:18 <lambdac> Title: Wotsit.org - Extensions: 'X'
05:39:20 <vixey> oh eckel
05:39:48 <BeelsebobWork> quicksilver: nothing wrong with Excel as a trojan functional language
05:39:50 <BeelsebobWork> :P
05:40:13 <RayNbow> > iterate f x
05:40:14 <lambdac>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
05:40:15 <gwern> BeelsebobWork: ask Cale or chrisdone
05:40:25 <gwern> they're the only ones I've heard of who've gotten it working recently
05:40:29 <RayNbow> ah, lambdabot is dead... :p
05:40:30 * gwern still finds it odd that I submit patches and have push access to lambdabot, and yet I've never successfully compiled or run lambdabot
05:40:39 * RayNbow was wondering why it didn't respond to privmsgs :p
05:40:41 <BeelsebobWork> I've successfully compiled and run it
05:40:49 <BeelsebobWork> just can't figure out how to get it to actually evaluate stuff
05:41:07 <BeelsebobWork> somebody badly needs to do some maintainance on either it or it's documentation
05:41:17 <RayNbow> :t launchNuclearMissiles
05:41:19 <lambdac> IO ()
05:41:23 <BeelsebobWork> haha
05:41:25 <RayNbow> > launchNuclearMissiles
05:41:26 <lambdac>  <IO ()>
05:41:29 <luqui> hahaha
05:41:31 <PeakerWork> @src launchNuclearMissiles
05:41:32 <lambdac> Source not found. I've seen penguins that can type better than that.
05:41:42 <RayNbow> lol
05:41:43 <PeakerWork> :t (unsafePerformIO launchNuclearMissiles)
05:41:44 <lambdac> Not in scope: `unsafePerformIO'
05:41:51 <RayNbow> <RayNbow> @let launchNuclearMissiles = undefined :: IO () <-- but this is what I told lambdac :p
05:42:10 <BeelsebobWork> @type (System.IO.Unsafe.unsafePerformIO launcheNuclearMissiles)
05:42:12 <lambdac> Not in scope: `launcheNuclearMissiles'
05:42:18 <BeelsebobWork> @type (System.IO.Unsafe.unsafePerformIO launchNuclearMissiles)
05:42:20 <lambdac> ()
05:42:25 <gwern> BeelsebobWork: yes, lambdabot does need work
05:42:36 <gwern> BeelsebobWork: are you volunteering?
05:42:48 <gwern> @let launchNuclearMissiles = "For our precious bodily fluids!"
05:42:49 <luqui> > System.IO.Unsafe.unsafePerformIO launchNuclearMissiles
05:42:49 <lambdac> <local>:9:0:     Multiple declarations of `L.launchNuclearMissiles'     Decla...
05:42:49 <BeelsebobWork> gwern: well, I probably would... if I could figure out how it works at the moment
05:42:49 <lambdac>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
05:43:01 <RayNbow> @undef launchNuclearMissiles
05:43:02 <lambdac> Undefined.
05:43:08 <RayNbow> try again gwern :)
05:43:22 <gwern> wah
05:43:45 * gwern just wonders what the previous definition was
05:44:03 <BeelsebobWork> > System.IO.Unsafe.unsafePerformIO (putStrLn "jam")
05:44:04 <lambdac>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
05:44:07 <BeelsebobWork> bah
05:44:28 <RayNbow> > undefined
05:44:29 <lambdac>  Exception: Prelude.undefined
05:45:25 <BeelsebobWork> > Data.ByteString.Internal.inlinePerformIO (putStrLn "jam")
05:45:25 <lambdac>   Not in scope: `Data.ByteString.Internal.inlinePerformIO'
05:45:29 <BeelsebobWork> gah
05:45:29 <hansfbaier> quicksilver: what would be the simplest expression with the same effect as >  sequence (ap (return print) (return "adasds"))
05:45:48 <luqui> hansfbaier, print "adasds"?
05:45:54 <quicksilver> no.
05:46:00 <quicksilver> return (print "adasds")
05:46:08 <quicksilver> oh, that one
05:46:12 <quicksilver> hansfbaier: please don't use sequence like that.
05:46:17 <quicksilver> hansfbaier: you are totally confusing yourself.
05:46:18 <luqui> yeah I was just playing
05:46:24 <hansfbaier> quicksilver: Yes!
05:46:26 <quicksilver> that use of sequence has forced the 'ap' into the List monad.
05:46:28 <quicksilver> not IO.
05:46:31 * BeelsebobWork pats luqui for playing with people's brains
05:46:35 <quicksilver> that isn't the IO ap
05:46:40 <quicksilver> and it's not doing what you think.
05:47:01 <luqui> hansfbaier, so to use the IO ap, you have to have something of type IO (a -> b)
05:47:05 <luqui> (for some a and b)
05:47:12 <luqui> that will be the first argument
05:47:15 <hansfbaier> quicksilver: is it in the List Monad, because of the type of "adasds:?
05:47:19 <quicksilver> hansfbaier: no.
05:47:24 <quicksilver> hansfbaier: because of the type of 'sequence'
05:47:28 <quicksilver> :t sequence
05:47:30 <lambdac> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:47:34 <quicksilver> first arg is list.
05:47:42 <hansfbaier> quicksilver: I see. Phew!
05:47:44 <quicksilver> ap (+1) (return 4)
05:47:47 <quicksilver> erm
05:47:49 <quicksilver> sorry.
05:47:51 <hansfbaier> quicksilver: not really explicit
05:47:53 <peter1> minislaih: ... the ghci debugger behavior: it looks like ghci can recognize only the current scope independent things in the top level monad (e.g. show MyModule.var) or the free variables (of course only the free ones since non-free ones are not bound to any CAF or value yet) *used* in the formula which is selected in the :list command; I hoped it can show me also all the free variables which are in scope but not used in the current/selected formula; anyway, t
05:48:00 <quicksilver> ap (return (+1)) (return 4)
05:48:07 <quicksilver> ^^ works independent of the monad.
05:48:14 <quicksilver> to give a more IO-specific example
05:48:15 <quicksilver> perhaps
05:48:22 <quicksilver> ap (return (+1)) (readLn)
05:48:40 <luqui> (are there any standard IO things that return functions?)
05:48:42 <quicksilver> to have an 'interesting' first parameter you'd want something 'interesting' of type IO (a -> b), as luqui just said.
05:48:50 <quicksilver> and I don't think there is anything obvious.
05:49:14 <quicksilver> in practice use of AFs it's more common to have the first thing be 'return'
05:49:15 <quicksilver> as in
05:49:24 <quicksilver> (return f) <*> x <*> y <*> z
05:49:28 <quicksilver> also written as
05:49:33 <quicksilver> f <$> x <*> y <*> z
05:49:44 <luqui> pure f <*> x <*> y <*> z
05:49:56 <luqui> (return + <*> makes me queasy)
05:53:02 <Armored_Azrael> Hey, is there any good way to convert from NominalDiffTime or similar to integer?
05:54:01 <cjs> An Integer number of whats?
05:54:27 <Armored_Azrael> Seconds, Picoseconds, Milliseconds, I don't particularly care--the changes this will be measuring are only order of 2 seconds.
05:54:33 <cjs> Ok. This guy is retaining massively and blowing me up with no stack space: http://hpaste.org/9547
05:55:10 <cjs> Other similar ones that get called over and over in the exact same way don't do this. Any thoughts on how to fix this?
05:56:02 <cjs> "toRational $ nominalDiffTime ts" gives you the seconds as a Rational.
05:56:09 <Armored_Azrael> cjs Thanks
05:57:00 <cjs> Oops, slightly wrong after the $, but you get the idea.
05:57:12 <cjs> Now you have to solve my space leak. :-)
05:59:06 <sioraioc_> where is the utf8 i/o for String?
05:59:09 <luqui> > (<*>) (<*>) (liftA fix) (liftA (take 10)) (1:)
05:59:11 <lambdac>  [1,1,1,1,1,1,1,1,1,1]
05:59:17 <luqui> applicative functors are easy!
05:59:19 <smg> luqui: looks awesome
05:59:20 <luqui> %-)
05:59:48 <sioraioc_> n/m
06:01:39 <cjs> Actually, is there a way to do stuff like http://hpaste.org/9547 without the mvar, yet without pulling state out to the caller?
06:02:25 <luqui> cjs, you could use an IORef
06:02:30 <luqui> but that's almost the same :-)
06:02:48 <cjs> Yeah. Though that's still a good idea, since it will probably be faster.
06:02:55 <luqui> uh, wow
06:03:00 <luqui> mvars are pretty lightweight
06:03:22 <luqui> I mean... are you up against a real performance issue?
06:03:26 <cjs> True, probably especially if there's no contention on them.
06:03:39 <cjs> Aside from the massive space leak? :-) No.
06:03:48 <cjs> But that would also indicate more clearly what I'm trying to do.
06:04:04 <cjs> Ooo....it's that little modifyMVarPure bugger that's killing me.
06:04:11 <yitz> cjs: FeedProcessor = SomeType -> IO OtherType right?
06:04:40 <luqui> cjb, you mean that's where the space leak is coming from?
06:04:40 <yitz> @type modifyMVarPure
06:04:42 <lambdac> Not in scope: `modifyMVarPure'
06:04:45 <cjs> Right. FeedState -> IO FeedState.
06:04:52 <cjs> It's in the code.
06:04:58 <luqui> er, cjs ^
06:05:04 <ayu> @tell botje are you here?
06:05:05 <lambdac> Consider it noted.
06:05:08 <delYsid> quicksilver: thanks.
06:05:21 <ayu> @seen botje
06:05:21 <lambdac> botje is in #haskell. I last heard botje speak 36m 9s ago.
06:05:26 <delYsid> hmm, nah, whenever I come back to Haskell, I feel like I am just too stupid for this language...
06:05:28 <luqui> you should increment strictly, cjs
06:05:33 <cjs> Basically, a loop threads the feed state through a bunch of functions like this for every message.
06:05:44 <cjs> Ah, the i+1?
06:05:46 <ayu> luqui: you miss your d?
06:05:47 <lambdac> ayu: You have 1 new message. '/msg lambdac @messages' to read it.
06:05:57 <ayu> @messages
06:05:58 <lambdac> vixey said 31m 52s ago: welcome back :p
06:06:00 <luqui> ayu, ?
06:06:02 <yitz> cjs: agree wth luqui, that looks like the culprit
06:06:11 <ayu> luqui: you missed your d?
06:06:24 <luqui> ayu, I have no idea what you're talking about
06:06:41 <ayu> luqui: water comes in what form?
06:06:45 <Botje> grrr
06:06:45 <lambdac> Botje: You have 1 new message. '/msg lambdac @messages' to read it.
06:06:46 <Botje> yes i'm here
06:06:54 <luqui> ayu, oh. heh.
06:06:55 <Botje> don't @tell people unless you're sure they're gone :p
06:06:59 <Botje> @messages
06:06:59 <lambdac> ayu said 1m 55s ago: are you here?
06:07:04 <luqui> yes, luquid.
06:07:10 <luqui> =P
06:07:17 <ayu> Botje: hi botje, i wanna continue the formula discussion
06:07:28 <ayu> i forgot to write it down on a peice of paper
06:07:58 <ayu> botje: you mentioned don't repeat the z thingy?
06:08:12 <ayu> botje: and something to do with n+1
06:08:28 <ayu> botje: jere os tje ;oml http://hpaste.org/9538
06:08:41 <ayu> botje: translte: here is the link http://hpaste.org/9538
06:08:43 <chrisdone> :t notStartingWithM
06:08:44 <lambdac> Not in scope: `notStartingWithM'
06:09:32 <chrisdone> > length "notStartingWithM"
06:09:33 <lambdac>  16
06:09:36 <ayu> so what should i add or remove?
06:09:41 <ayu> length "ayu"
06:09:43 <chrisdone> that's got to be the max allowed, sure
06:09:47 <Botje> you should not enumerate the z
06:09:48 <ayu> > length "ayu"
06:09:49 <lambdac>  3
06:09:55 <Botje> but simply check if it's an integer
06:10:01 <ayu> botje : what does it mean by enumerate the z ?
06:10:08 <cjs> Kinda weird that that doesn't leak if I happen to have another processor in the loop with it.
06:10:12 <Botje> 13:30 < Botje> let sqr = x*x+y+y, let z = floor $ sqrt $ fromIntegral sqr, sqr == z^2
06:10:16 <luqui> > length . show $ 2^2^2^2^2
06:10:17 <lambdac>  19729
06:10:28 <Botje> don't do z <- ....
06:10:47 <Botje> just calculate z from sqrt(x*x+y*y) and check if it's an integer
06:12:04 <chrisdone> > (+1) <$> [1..10]
06:12:05 <lambdac>  [2,3,4,5,6,7,8,9,10,11]
06:12:42 <chrisdone> :t (<*>)
06:12:44 <lambdac> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:12:46 <ayu> how do i check it as an integer? n > 0
06:13:09 <cjs> So is doing something such as extracting an "inc1 !i = (i+1)" definition and then replacing "(\i -> i+1)" with that definition supposed to fix the problem, if it is indeed the i+1 that's the leak?
06:13:15 <chrisdone> :t fromIntegral
06:13:18 <lambdac> forall a b. (Num b, Integral a) => a -> b
06:13:24 <cjs> Or am I missing something more subtle here?
06:13:26 <chrisdone> @instances Num
06:13:27 <lambdac> Double, Float, Int, Integer
06:14:22 <ayu> botje: mind explaining how the code works?
06:14:23 <ayu> let sqr = x*x+y+y,
06:14:23 <ayu> let z = floor $ sqrt $ fromIntegral sqr,
06:14:23 <ayu> sqr == z^2
06:14:36 <ayu> I dont know how does the money symbol works
06:14:56 <Botje> it's the same as floor (sqrt (fromIntegral sqr))
06:15:17 <cjs> 'cause doing that doesn't work, and it's still modifyMVarPure that's blowing up with unevaluated thunks, if my profiling is anything to go by.
06:15:27 <ayu> botje: your code have let but does not have in o_o
06:15:42 <Botje> that's because it was supposed to be used inside your list comprehension
06:15:51 <yitz> cjs doing what doesn't work?
06:16:18 <Botje> [ (x,y,z) | x <- [1..n], y<-[x+1..n], let sqr = ..., let z = ..., sqr == z^2 ]
06:16:33 <cjs> yitz: this: http://hpaste.org/9547#a1
06:16:56 <cjs> But of course, why would that f ever get evaluated?
06:18:36 <yitz> cjs hmm. what is this modifyMVarPure thing?
06:19:44 <chr1s> does anybody know of the existance of something like "multi-maps" (not sure what the correct term is)
06:19:46 <yitz> cjs why not just modifyMVar c (return . (+1)) ?
06:19:47 <cjs> It allows you to pass a pure function in, and does the modify. modifyMVar_ takes an (a -> IO a)
06:19:59 <luqui> chr1s, where one thing maps to multiple?
06:20:07 <yitz> s/Var/Var_/
06:20:34 <chr1s> luqui: no, where something like (a, b) maps to c
06:20:47 <chr1s> and you have efficient lookup on either a or b
06:20:47 <luqui> chr1s, oh, sure, it's called Map (a,b) c
06:20:50 <luqui> oh
06:20:58 <luqui> I see
06:21:20 <PeakerWork> cjs: (Map a c, Map b c) ? :-)
06:21:28 <chr1s> it probably wouldn't be too hard, but if there's code there already...
06:21:45 <ayu> botje: so the $ symbol makes bracket?
06:21:53 <vixey> :)))
06:21:57 <ayu> botje ayu $ botje = ayu(botje) ?
06:22:15 <vixey> botje ayu $ botje = (botje ayu) (botje)
06:22:27 <ayu> oh thanks vixey
06:22:35 <ayu> cool to have you here :D
06:22:37 <cjs> yitz: Good question.  seemed like a good idea at the time.
06:22:38 <vixey> ayu: f $ x = f x
06:22:58 <vixey> > reverse $ "grime"
06:22:59 <lambdac>  "emirg"
06:23:07 <ayu> cool o_o
06:23:11 <vixey> > map ($ "grime") [reverse,id,tail]
06:23:12 <lambdac>  ["emirg","grime","rime"]
06:23:18 <ayu> did not know$ could be use for reverse
06:23:31 <luqui> $ can be used for anything...
06:23:33 <BeelsebobWork> ayu: $ is "apply"
06:23:41 <BeelsebobWork> it applies the thing on it's left to the thing on it's right
06:24:08 <ayu> beelsebobwork: thanks  :D i got to write that down
06:24:10 <yitz> cjs: anyway, if your increment is not the problem, then it must be upstream in your code somewhere, where you use this thing.
06:24:18 <ziman> > sequence [reverse,id,tail] "grime"
06:24:19 <lambdac>  ["emirg","grime","rime"]
06:24:22 <cjs> yitz: but as to "modifyMVar c (return . (+1)) ", it doesn't compile. It claims it's expecting an IO (Int,t) and getting just an IO Int....
06:24:38 <yitz> yeah sorry my mistake - use modifyMVar_
06:24:41 <cjs> Right. I'm guessing modifyMVarPure is not calling the increment.
06:24:49 <BeelsebobWork> ziman: yeh, but why use the monad when the other clearer code is... well, clearer
06:25:32 <luqui> BeelsebobWork, because it's not as fancy, of course
06:25:35 <ziman> BeelsebobWork, sure, de gustibus.. :)
06:25:39 <cjs> Huh. I would have noticed that had I looked at the signatures. Anyway, yeah, that compiles; let's see how we run....
06:25:42 <BeelsebobWork> luqui: :P
06:26:07 <ayu>  botjeL the formula you gave does produce the same result like the previous one i did
06:26:10 <cjs> Leaking like a sieve.
06:26:15 <ayu>  botje: the formula you gave does produce the same result like the previous one i did
06:26:37 <cjs> But really, it's doing the same thing anyway, so....
06:29:19 <dcoutts_> gwern: yes, it needs to work with both --user and --global
06:30:00 <BeelsebobWork> @seen Cale
06:30:01 <lambdac> Cale is in #haskell. I last heard Cale speak 7h 53m 3s ago.
06:30:07 <ayu> @seen botje
06:30:07 <lambdac> botje is in #haskell. I last heard botje speak 13m 49s ago.
06:30:35 <ayu> @tell botje "the formula you gave does not produce the same result like the previous one i did"
06:30:36 <lambdac> Consider it noted.
06:30:45 <Botje> I FUCKING READ WHAT YOU WROTE.
06:30:45 <lambdac> Botje: You have 1 new message. '/msg lambdac @messages' to read it.
06:30:49 <ayu> shh i typed wrongly
06:31:03 <ayu> does not
06:31:06 <vixey> @seen Botje
06:31:06 <lambdac> Botje is in #haskell. I last heard Botje speak 21s ago.
06:31:22 <ayu> weird when i type @seen botje, it says 13 minutes instead of seconds
06:31:34 <vixey> ayu,
06:31:40 <vixey> ayu, 'B' vs 'b' I think
06:31:44 <vixey> @seen AYU
06:31:44 <lambdac> AYU is in #haskell. I last heard AYU speak 22s ago.
06:31:46 <vixey> oh
06:31:49 <vixey> weird.....
06:31:56 <vixey> @seen AyU
06:31:56 <lambdac> AyU is in #haskell. I last heard AyU speak 34s ago.
06:32:03 <ayu> vixey: botje is in #haskell. I last heard botje speak 13m 49s ago.
06:32:11 <ayu> o_o thought he was away
06:32:13 <vixey> ayu, it does seem like a bug
06:32:16 <vixey> in lambdabot
06:32:23 <ayu> vixey: really?
06:32:27 <vixey> to me, yes
06:32:52 <ayu> vixey: mind taking a look my codes with botje codes? his code does not seem right..http://hpaste.org/9538#a1
06:33:06 <vixey> ayu,
06:33:11 <yitz> cjs i wonder if returning that function type in IO isn't confusing the compiler's strictness analysis. why not just MVar Int -> FeedState -> IO () ?
06:33:35 <Botje> let sqr = x*x+y+y,
06:33:35 <vixey> ayu, You must use number theory
06:33:44 <ayu> vixey: what is a number theory
06:33:48 <yitz> cjs anyway, I really think the problem is somewhere else in your program, not here.
06:33:51 <cjs> yitz: because I need to be in IO to do the newIORef.
06:33:54 <Botje> that was a typo
06:33:56 <Botje> should be x*x+y*y
06:34:06 <Botje> apply brain before complaining please.
06:34:34 <vixey> ayu: (u^2-v^2,2*u*v,u^2+v^2)
06:34:49 <ayu> botje: its your mistake?
06:35:04 <Botje> yes. yes it is.
06:35:26 <Botje> that doesn't mean you can't look at it
06:35:38 <vixey> > [(u^2-v^2,2*u*v,u^2+v^2)|  u <- [1..], v <- [1..u], odd (u+v), u`gcd`v == 1, u > v ]
06:35:39 <lambdac>  [(3,4,5),(5,12,13),(15,8,17),(7,24,25),(21,20,29),(9,40,41),(35,12,37),(11,6...
06:35:41 <cjs> Really. It could be, I'm not very good at these kinds of analyses. But taking this function out of the processing loop makes the problem go away (admittedly this could just be triggering it), using function that prints the message rather than counting doesn't have the problem, and profiling with -hr shows that it's count or, when I'm using it, modifyMVarPure.
06:35:49 <vixey> > 5*5+12*12-13*13
06:35:50 <lambdac>  0
06:35:53 <vixey> ayu: D [(u^2-v^2,2*u*v,u^2+v^2)|  u <- [1..], v <- [1..u], odd (u+v), u`gcd`v == 1, u > v ]
06:36:04 <ayu> botje: actualy i spot that mistake, but I do not want to assume why you did that way, maybe there are some other reasons
06:36:20 <cjs> yitz: Oh, and even if I didn't, lots of other FeedProcessors do things such as opening up files and so on.
06:36:37 <cjs> yitz: Oh, ignore that last comment.
06:36:47 <Botje> well. it was a typo.
06:36:56 <ayu> Botje: ok :D don't be mad
06:37:00 <vixey> :(
06:37:20 <ayu> vixey: ?
06:37:28 <vixey> ayu: My way is: [(u^2-v^2,2*u*v,u^2+v^2)|  u <- [1..], v <- [1..u], odd (u+v), u`gcd`v == 1, u > v ]
06:37:28 <drigz> vixey: if u > v, why not v <- [1..u-1]?
06:38:54 <drigz> vixey: although if u == v then odd (u+v) == False
06:39:22 <Botje> if u == v you can't ever have a pythagorean triple anyway
06:39:25 <vixey> drigz: I don't think htta change makes the code simpler
06:39:39 <ayu> what is gcd?
06:39:41 <opqdonut> well it eliminates one check..
06:39:52 <vixey> x`gcd`y == 1 means x and y are coprime
06:39:54 <cjs> yitz: Are you saying I can do something like "countResponses :: FeedProcessor; countResponses = do { c <- newMVar 1; count c }?
06:40:03 <vixey> > (2*2*3*5)`gcd`(3*5*7*7)
06:40:04 <lambdac>  15
06:40:15 <ayu> (1) `gcd`(1)
06:40:19 <ayu> > (1) `gcd`(1)
06:40:20 <lambdac>  1
06:40:24 <ayu> > (2) `gcd`(2)
06:40:25 <lambdac>  2
06:40:28 <ayu> > (2) `gcd`(3)
06:40:29 <lambdac>  1
06:40:39 <vixey> > 6`gcd`3
06:40:40 <lambdac>  3
06:40:53 <ayu> i still dont understand how gcd works
06:40:58 <vixey> @src gcd
06:40:58 <lambdac> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:40:58 <lambdac> gcd x y = gcd' (abs x) (abs y)
06:40:58 <lambdac>    where gcd' a 0  =  a
06:40:58 <lambdac>          gcd' a b  =  gcd' b (a `rem` b)
06:41:52 <ayu> > (4) `gcd`(4)
06:41:52 <lambdac>  4
06:41:55 <ayu> > (4) `gcd`(1)
06:41:56 <lambdac>  1
06:42:01 <ayu> > (1) `gcd`(4)
06:42:03 <lambdac>  1
06:42:07 <opqdonut> ayu: please
06:42:11 <opqdonut> test in ghci
06:42:12 <opqdonut> not here
06:42:21 <vixey> ayu, it is the intersection of factors
06:42:21 <ayu> ok
06:42:21 <Zao> Or in a private message to lambdabot.
06:42:26 <vixey> so
06:42:34 <ayu> how to ake a private message to lambdabot?
06:42:36 <vixey> (2*2*3*5) `gcd` (3*5*7*7)
06:42:39 <vixey> shares 3*5
06:42:42 <vixey> so = 15
06:42:49 <opqdonut> ayu: /query lambdac
06:43:11 <ayu> you mean 3*5 from (3*5*7*7) ?
06:43:31 <vixey> 3*5 is both
06:43:33 <vixey> in
06:43:54 <ayu> thanks donut
06:44:11 <opqdonut> n p
06:44:16 <ziman> greatest common divisor
06:44:41 <drigz> @src gcd
06:44:41 <lambdac> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:44:41 <lambdac> gcd x y = gcd' (abs x) (abs y)
06:44:41 <lambdac>    where gcd' a 0  =  a
06:44:41 <lambdac>          gcd' a b  =  gcd' b (a `rem` b)
06:44:42 <ayu> vixey: what do you mean by it is the intersection of factors
06:45:04 <ayu> could someone explain to me the cool content in gcd source?
06:45:06 <vixey> in:  (2*2*3*5) `gcd` (3*5*7*7)
06:45:14 <vixey> 3 and 5 appear in both
06:45:22 <ayu> oh
06:45:23 <vixey> that's the intersection of [2,2,3,5] with [3,5,7,7]
06:45:24 <drigz> ayu: it's the euclidean algorithm - look in wikipedia GCD
06:46:24 <ayu> drigz: ok
06:46:29 <ayu> wiki-ing lol
06:47:19 <vixey> > [2..] . (`gcd` 2)
06:47:20 <lambdac>  Couldn't match expected type `a -> b' against inferred type `[a1]'
06:47:39 <vixey> > (`gcd` 2) . [2..]
06:47:40 <lambdac>  [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
06:47:45 <vixey> > (`gcd` 3) . [2..]
06:47:46 <lambdac>  [1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3...
06:47:49 <vixey> > (`gcd` 4) . [2..]
06:47:50 <lambdac>  [2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1...
06:48:16 <ziman> > (`gcd` 60) . [2..]
06:48:17 <lambdac>  [2,3,4,5,6,1,4,3,10,1,12,1,2,15,4,1,6,1,20,3,2,1,12,5,2,3,4,1,30,1,4,3,2,5,1...
06:48:43 <ayu> what does the dot do?
06:48:53 <ayu> between gcd and the list [2..[
06:48:54 <vixey> ayu, . is map
06:48:54 <Feuerbach> ayu: just map (fmap)
06:49:03 <vixey> so for example
06:49:08 <vixey> > (+1) . [5,3,8]
06:49:09 <lambdac>  [6,4,9]
06:49:11 <vixey> > map (+1) [5,3,8]
06:49:13 <lambdac>  [6,4,9]
06:49:22 <vixey> > (+1) . Just 3
06:49:23 <lambdac>  Just 4
06:49:31 <vixey> > fmap (+1) (Just 3)
06:49:32 <lambdac>  Just 4
06:49:35 <ayu> > (+1).3
06:49:36 <lambdac>   add an instance declaration for (Num (f a))
06:49:41 <ziman> well, originally it's function composition
06:49:44 <ayu> > (+1). f 3
06:49:44 <lambdac>        add an instance declaration for (SimpleReflect.FromExpr (f a))
06:50:08 <vixey> ayu: (.) will work on a functor, but '3' isn't a functor, whereas [5,3,8] is
06:50:47 <sbahra> alo vixey
06:50:52 <vixey> hi sbahra
06:51:05 <Feuerbach> > (+1) . Identity 3
06:51:05 <lambdac>   add an instance declaration for (Show (Identity a))
06:51:17 <vixey> @src Identity
06:51:17 <lambdac> newtype Identity a = Identity { runIdentity :: a }
06:51:27 <Feuerbach> > runIdentity $ (+1) . Identity 3
06:51:28 <vixey> > runIdentity(  (+1) . Identity 3  )
06:51:28 <lambdac>  4
06:51:30 <lambdac>  4
06:51:30 <ziman> ayu, it's a quite controversial topic on #haskell because (.) is more general here; it's plain function composition anywhere else
06:52:30 <PeakerWork> fmap, (.), <$>, anything else? :-)
06:52:37 <ziman> this is standard (.):
06:52:39 <ziman> @src (.)
06:52:39 <lambdac> (f . g) x = f (g x)
06:52:42 <vixey> :t (>>>)
06:52:43 <lambdac> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:52:45 <sbahra> .
06:52:45 <vixey> :t (<<<)
06:52:47 <lambdac> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
06:52:48 <sbahra> ,
06:52:55 <vixey> > ( (+1) <<< (*2) ) 7
06:52:56 <lambdac>  15
06:52:58 <vixey> > ( (+1) >>> (*2) ) 7
06:52:59 <lambdac>  16
06:53:11 <Axman6> bleh, how do i print something out, and then return a value? using a do block i assume, but not totally sure how
06:53:25 <sbahra> > (+1) . [1,2,3]
06:53:27 <lambdac>  [2,3,4]
06:53:31 <sbahra> That isn't working here
06:53:36 <vixey> Axman: printReturn e = do print e ; return e
06:53:43 <kpreid> do x <- randomIO; print x; return x
06:53:49 <vixey> sbahra: where?
06:53:50 <ziman> Axman6, print "foo" >> return returnValue
06:53:57 <kpreid> note that "return" is NOT a flow control operator
06:54:05 <sbahra> vixey, The Glorious Glasgow Haskell Compilation System, version 6.8.2
06:54:08 <Axman6> actually, just realised doing this in this code is pretty useless
06:54:30 <Axman6> but, thanks for helping. it will certainly be useful in the future
06:54:37 <sbahra> vixey, Couldn't match expected type `a -> b' against inferred type `[a1]'
06:54:45 <vixey> sbahra: oh
06:54:51 <vixey> 1 sec
06:56:13 <ziman> sbahra, because (.) is generalised to fmap in lambdabot only
06:56:21 <vixey> 1 sec..
06:57:25 <vixey> sbahra: You can make a file
06:57:26 <vixey> {-# LANGUAGE NoMonomorphismRestriction #-}
06:57:26 <vixey> import Prelude hiding ((.))
06:57:26 <vixey> (.) = fmap
06:57:28 <sbahra> ziman, fmap is cool
06:57:33 <vixey> and then in ghci:  :l that
06:57:38 <vixey> now you have (.)
06:57:39 <vixey> :))
06:57:40 <sbahra> vixey, is it a good idea for me to use this in my own code though?
06:57:47 <vixey> sbahra: I prefer it ..
06:58:11 * luqui is a fan of NoMonomorphismRestriction
06:58:26 <sbahra> What is that?
06:58:52 <luqui> if you define x = 1, then x :: Num a => a, instead of x :: Integer
06:59:21 <vixey> oh
06:59:27 <vixey> I write some code in point free notation
06:59:29 <vixey> so
06:59:37 <vixey> foo = phi . rho . gamma
06:59:39 <vixey> instead of
06:59:43 <vixey> foo = \x -> phi . rho . gamma $ x
06:59:50 <thoughtpolice> why is the monomorphism restriction even there? isn't it pretty much universally hated?
06:59:55 <vixey> and you sometimes have errors unless you use NoMonomorphismRestriction
07:00:20 <vixey> thoughtpolice: my impression was it's mostly when you have numerical code it is a help, because it can stop recomputing the same thing
07:00:38 <vixey> thoughtpolice: ....but type annotations seem like a better solution so I don't really know why it exists
07:00:43 <thoughtpolice> yeah
07:02:43 <ayu> brb guys
07:02:48 <ayu> need to fix my printer -_-
07:03:18 * sbahra goes to get a much needed pack of cigarettes 
07:08:13 <yitz> cjs, sorry i was away, any progress?
07:08:37 <chrisdone> @src (++)
07:08:37 <lambdac> (++) []     ys = ys
07:08:37 <lambdac> (++) (x:xs) ys = x : xs ++ ys
07:09:01 <chrisdone> > Just [1] ++ Just [2]
07:09:03 <lambdac>  Just [1,2]
07:09:18 <chrisdone> > 1 mplus 2
07:09:18 <lambdac>        add an instance declaration for
07:09:19 <lambdac>       (Num ((m a -> m a -> m a) -> t -...
07:09:21 <chrisdone> > 1` mplus` 2
07:09:22 <lambdac>   add an instance declaration for (Num (m a))
07:09:24 <chrisdone> > 1 `mplus` 2
07:09:25 <lambdac>   add an instance declaration for (Num (m a))
07:09:28 <chrisdone> oh
07:09:38 <chrisdone> duh
07:10:04 <EvilTerran> > Sum 1 ++ Sum 2
07:10:05 <lambdac>  Sum {getSum = 3}
07:10:09 <chrisdone> what else can you use mplus for?
07:10:14 <chrisdone> I've only ever used it for lists and Maybe
07:10:24 <EvilTerran> ?instances MonadPlus
07:10:24 <lambdac> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:10:41 <EvilTerran> ... not sure what the IO instance does
07:10:50 <chrisdone> I thought the same
07:10:55 <EvilTerran> i presume the transformer instances just pass it through
07:11:07 <chrisdone> right
07:11:10 <EvilTerran> so the main ones are (Either e), Maybe, and []
07:11:19 <opqdonut> ?src mplus IO
07:11:19 <lambdac> Source not found. The more you drive -- the dumber you get.
07:11:20 <chrisdone> ah, forgot about Either. yeah, mplus is nice with that
07:11:25 <opqdonut> ?src IO mplus
07:11:25 <lambdac> m `mplus` n = m `catch` \_ -> n
07:11:31 <opqdonut> ah, exceptions
07:11:31 <twobitwork> ?pl \x -> map (:[]) x
07:11:32 <lambdac> map return
07:11:49 <EvilTerran> parsec's parsing monad should be MonadPlus as well
07:11:55 <EvilTerran> ?src GenParser mplus
07:11:55 <lambdac> Source not found. :(
07:11:57 <EvilTerran> hm
07:11:59 <opqdonut> indeed
07:12:05 <EvilTerran> mplus = (<|>) would be the obvious option
07:12:20 <EvilTerran> mzero = pzero
07:12:27 <opqdonut> ?instances-importing Text.ParserCombinators.Parsec MonadPlus
07:12:28 <lambdac> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:12:30 <opqdonut> nope
07:12:43 <opqdonut> ?instances-importing Text.ParserCombinators.Parsec.Prim MonadPlus
07:12:43 <lambdac> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:12:55 <opqdonut> MonadPlus (GenParser tok st)
07:12:59 <chrisdone> can you tell GHC not to import Prelude by default? like if you want a compile a whole project with Caleskell
07:12:59 <opqdonut> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html#t%3AGenParser
07:13:01 <EvilTerran> instance MonadPlus (GenParser tok st) where
07:13:01 <EvilTerran>   mzero         = parsecZero
07:13:01 <EvilTerran>   mplus p1 p2   = parsecPlus p1 p2
07:13:03 <lambdac> http://tinyurl.com/5ogrn7
07:13:05 <opqdonut> lambdabot is broken I guess
07:13:11 <chrisdone> -XCaleskell, perhaps
07:13:20 <EvilTerran> pzero = parsecZero
07:13:26 <opqdonut> chrisdone: you can at least "import qualified Prelude"
07:13:43 <chrisdone> opqdonut: but that has to be written for every file :(
07:13:46 <EvilTerran> chrisdone, no, you have to explicitly import the Prelude in every module if you want to do that
07:14:44 <EvilTerran> p1 <|> p2           = mplus p1 p2
07:14:45 <sioraiocht> @src reverse
07:14:45 <lambdac> reverse = foldl (flip (:)) []
07:14:47 <chrisdone> import qualified Prelude; import Prelude.GoodStuff
07:15:04 <EvilTerran> so GenParser has exactly the MonadPlus instance you'd expect. that's good.
07:15:18 <chrisdone> that's nice
07:16:07 <EvilTerran> I imagine any other parsing libraries will also have an appropriate MonadPlus instance
07:16:59 <ddarius> If it's monadic.
07:17:25 <chrisdone> yeah, what with being _Monad_Plus
07:17:27 <Deewiant> chrisdone: -fno-implicit-prelude exists IIRC
07:17:27 <EvilTerran> yes, quite
07:17:36 <EvilTerran> Deewiant, that does something else
07:17:38 <cjs> yitz: Yes. I'll update you in a bit. It's definitely that i+1 thing.
07:17:41 <chrisdone> it does?
07:17:51 <chrisdone> @go "-fno-implicit-prelude"
07:17:57 <EvilTerran> that and -XNoImplicitPrelude mean that the definitions in scope get used for de-sugaring
07:18:06 <lambdac> Plugin `search' failed with: thread killed
07:18:10 <EvilTerran> the standard prelude will still be in scope by default
07:18:33 <yitz> cjs, ah ok good. glad to hear it.
07:18:50 <chrisdone> EvilTerran: so if I define (++) = mplus, it will "shadow" the Prelude (++) and there will be no ambiguity error when I try to use it?
07:19:04 <Deewiant> EvilTerran: the docs seem to disagree, or then I'm reading them wrong
07:19:16 <Deewiant> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
07:19:18 <lambdac> Title: Chapter 8. GHC Language Features, http://tinyurl.com/kf2g3
07:19:38 <Deewiant> "GHC normally imports Prelude.hi files for you. If you'd rather it didn't, then give it a -XNoImplicitPrelude option. The idea is that you can then import a Prelude of your own."
07:20:39 <EvilTerran> chrisdone, you'd have to "import Prelude hiding ((++))"
07:20:48 <EvilTerran> Deewiant, huh. that's not how i remember it.
07:21:08 <Deewiant> maybe chrisdone should just try the flag/pragma and see if it does what he wants :-P
07:21:17 <cjs> yitz: Basically, if I change it to readIORef i, writeIORef i+1, and then use an if statement to evaluate it, my problems go away. So now I just need to find the clever way to do this.
07:21:28 <chrisdone> well, I'll see
07:21:30 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
07:21:32 <lambdac> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
07:21:36 <EvilTerran> "the -XNoImplicitPrelude flag causes the following pieces of built-in syntax to refer to whatever is in scope, not the Prelude versions:"
07:21:40 <EvilTerran> that's what i was thinking of
07:21:53 <Deewiant> yeah, but that's a side effect
07:21:56 <chrisdone> ah
07:22:23 <EvilTerran> i get the impression from the phrasing that they had it do that as well on purpose
07:22:32 <cjs> yits: Stuff like modifyIORef c (\i -> (+) 1 $! i) does not work, however; I'm guessing it's because that function itself is never being evaluated, just stacked up.
07:22:40 <Deewiant> sure, it makes sense to do that as well
07:23:21 <chrisdone> one could hide Prelude, and import PreludeAwesome, which exports Prelude, but with certain functions hidden with our own good stuff exported in place of them
07:23:55 <Deewiant> for instance
07:24:16 <chrisdone> that is, if you were interested in how to stop people contributing to your projects
07:24:29 <Deewiant> :-P
07:26:40 <chrisdone> ohh
07:26:41 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
07:26:43 <lambdac> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
07:26:44 <chrisdone> I like that
07:26:48 <Deewiant> aye
07:26:52 <chrisdone> similar to class definitions
07:27:14 <Deewiant> the only extension I actually find myself missing often
07:27:33 <chrisdone> missing? you use something *other* than GHC?
07:27:47 <twobitwork> why does this seem to use exponential space? permute n l = concatMap (\x -> sequence (takeRepeat l x)) [1..n]
07:27:53 <Deewiant> no, but I like to stay in Haskell-98 when possible :-)
07:28:07 <vixey> @let permute n l = concatMap (\x -> sequence (takeRepeat l x)) [1..n]
07:28:08 <lambdac> <local>:1:41: Not in scope: `takeRepeat'
07:28:09 <twobitwork> like, permute 25 [0, 1] brings my system to its knees
07:28:12 <twobitwork> er
07:28:18 <twobitwork> takeRepeat l n = take n . repeat $ l
07:28:31 <vixey> > replicate 3 'x'
07:28:32 <lambdac>  "xxx"
07:28:36 <vixey> == takeRepeat x 3 ?
07:28:47 <twobitwork> ahh, yep
07:28:48 <Deewiant> @src replicate
07:28:48 <lambdac> replicate n x = take n (repeat x)
07:28:52 <quicksilver> delYsid: if that's a reference to my code then, yes, I have made it rather concise. The first draft didn't look like that.
07:28:55 <vixey> @let permute n l = concatMap (\x -> sequence (replicate x l)) [1..n]
07:28:56 <lambdac> Defined.
07:28:57 <twobitwork> heh
07:28:58 <quicksilver> delYsid: but it's quite pleasingly simple.
07:29:00 <vixey> > permute 3 "foobar"
07:29:01 <lambdac>  ["f","o","o","b","a","r","ff","fo","fo","fb","fa","fr","of","oo","oo","ob","...
07:29:10 <twobitwork> > permute 25 [0,1]
07:29:11 <lambdac>  [[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,...
07:29:14 <abuiles> could please someone tell me,,why this don't work
07:29:15 <abuiles> http://hpaste.org/9549
07:29:24 <vixey> twobitwork: replicateM is a bit sipler
07:29:30 <vixey> simpler*
07:29:35 <chrisdone> > premute 3 [1..4]
07:29:36 <lambdac>   Not in scope: `premute'
07:29:39 <quicksilver> abuiles: because you're using : wrong.
07:29:40 <chrisdone> > permute 3 [1..4]
07:29:42 <lambdac>  [[1],[2],[3],[4],[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2]...
07:29:42 <vixey> > map (flip replicateM "foobar") [1..3]
07:29:43 <lambdac>  [["f","o","o","b","a","r"],["ff","fo","fo","fb","fa","fr","of","oo","oo","ob...
07:29:50 <quicksilver> abuiles: : takes an item on the left and a list on the right.
07:29:50 <vixey> > flip replicateM "foobar" =<< [1..3]
07:29:51 <lambdac>  ["f","o","o","b","a","r","ff","fo","fo","fb","fa","fr","of","oo","oo","ob","...
07:30:02 <twobitwork> nice
07:30:07 <twobitwork> let me try that
07:30:20 <twobitwork> should that use linear space?
07:30:27 <twobitwork> I think sequence is what's killing me
07:30:40 <quicksilver> no, the replicateM version uses exponential space.
07:30:49 <chrisdone> mm_freak: nice address
07:30:52 <vixey> @src replicateM
07:30:53 <lambdac> replicateM n x = sequence (replicate n x)
07:30:55 <Jedai> twobitwork: Maybe because permute 25 [0,1] use something like 3^25
07:31:06 <quicksilver> it uses space up to the size of the penultimate layer
07:31:11 <twobitwork> Jedai: no shit :P
07:31:12 <vixey> > length (permute 25 [0,1])
07:31:19 <Deewiant> > 3^25
07:31:21 <lambdac>  Exception: Time limit exceeded
07:31:22 <lambdac>  847288609443
07:31:22 <vixey> > length (permute 10 [0,1])
07:31:24 <lambdac>  2046
07:31:28 <Deewiant> > 3^10
07:31:29 <lambdac>  59049
07:31:39 <quicksilver> there is no elegant list function style streaming version
07:31:54 <twobitwork> is there a way that it would use less space when used properly in a lazy fasion?
07:32:04 <Jedai> Ok, I was too hasty, it seems to use 2^26
07:32:05 <quicksilver> yes
07:32:25 <quicksilver> but slightly fiddly to right.
07:32:27 <quicksilver> write.
07:32:30 <quicksilver> damn homonyms.
07:32:36 <abuiles> quicksilver: My idea is that in fact,,,get the first on the left and put it on the right,,
07:32:38 <chrisdone> racist
07:32:42 <Jedai> twobitwork: If you consume it as you produce it, and manage to find a properly lazy producer
07:32:43 <vixey> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitViewFunctions
07:32:45 <lambdac> http://tinyurl.com/33xhs7
07:32:45 <quicksilver> abuiles: I understand your idea.
07:32:49 <quicksilver> abuiles: but that's not what : does.
07:32:50 <vixey> Has this just not been implemented yet?
07:32:54 <mfp> *homophones
07:32:57 <twobitwork> Jedai: I'm going to name you Captain Obvious :)
07:33:00 <vixey> and what about implicit tupling ?
07:33:14 <quicksilver> abuiles: (:) takes an item on the left and a list on the right.
07:33:29 <twobitwork> Jedai: finding a properly lazy produce is the question
07:33:34 <twobitwork> producer*
07:33:48 <Jedai> twobitwork: Yeah, but that wasn't the question you asked ;)
07:34:01 <twobitwork> 10:30 < twobitwork> is there a way that it would use less space when used properly in a lazy fasion?
07:34:01 <abuiles> ok thanks
07:34:15 <twobitwork> i.e., is there an implementation which would ...
07:34:16 <quicksilver> mfp: no, it was a homonym.
07:34:57 <quicksilver> twobitwork: basically you just systematically run through m!
07:35:08 <vixey> wait
07:35:13 <quicksilver> twobitwork: it's not particular hard, but I don't think there is a really neat one-liner using haskell lists.
07:35:24 <vixey> :t (replicate . [1..])
07:35:26 <lambdac> forall a. [a -> [a]]
07:36:06 <twobitwork> you can compose lists with functions?
07:36:11 <mfp> homonym: One of two or more words that have the same sound and often the same spelling but differ in meaning, such as bank (embankment) and bank (place where money is kept).   homophone: One of two or more words, such as night and knight, that are pronounced the same but differ in meaning, origin, and sometimes spelling.
07:36:26 <mfp> both, with maybe slight preference for the latter?
07:37:07 <nyingen> mfp: Linguists usually prefer 'homograph' and 'homophone'
07:37:19 <nyingen> Is there a Haskell equivalent of Lisp 'flet'?
07:37:31 <vixey> nyingen: let
07:37:40 <twobitwork> what does flet do?
07:37:43 <mfp> that's more precise indeed
07:37:44 <vixey> > let f = (+1) in f 3
07:37:45 <lambdac>  4
07:37:48 <nyingen> let foo = \x y -> ... ?
07:37:54 <vixey> > let f k = k+1 in f 3
07:37:56 <lambdac>  4
07:37:59 <vixey> > let f = \k->k+1 in f 3
07:38:01 <lambdac>  4
07:38:03 <yitz> cjs: modifyIORef c (+1)
07:38:03 <nyingen> oh, I see
07:38:17 <paczesiowa> what does import module as M do without qualified?
07:38:28 <vixey> @src replicateM
07:38:29 <lambdac> replicateM n x = sequence (replicate n x)
07:38:39 <nyingen> vixey: thanks
07:38:50 <dmwit> paczesiowa: It imports three names:
07:38:52 <quicksilver> mfp: yes, it was both homonym and homophone, but in my experience, homonym is the commonly used word outside linguistic circles.
07:39:02 <dmwit> unqualified, M., and Full.Module.Name.
07:39:17 <vixey> @src replicate
07:39:17 <lambdac> replicate n x = take n (repeat x)
07:39:38 <paczesiowa> dmwit: what's the point?
07:39:43 <nyingen> twobitwork: flet defines a local function (in Lisp)
07:39:44 <twobitwork> vixey: I see
07:39:56 <vixey> twobitwork: I am trying something ou
07:39:57 <vixey> out
07:39:57 <dmwit> paczesiowa: There's a shorter qualifier to deal with conflicts.
07:40:08 <vixey> @src sequence
07:40:08 <lambdac> sequence []     = return []
07:40:08 <lambdac> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:40:08 <lambdac> --OR
07:40:08 <lambdac> sequence xs = foldr (liftM2 (:)) (return []) xs
07:40:11 <dmwit> paczesiowa: And for the non-conflicting names, no qualifier is needed.
07:40:36 <cjs> yitz: Here's the minimal fix: http://hpaste.org/9547#a2  I can't seem to do it with modifyIORef.
07:40:52 <cjs> Changing the $! to just $ breaks it.
07:40:59 <twobitwork> see, I think its sequence which is using up all the space... it holds a reference to each element of the list this the GC can't collect... right?
07:40:59 <yitz> mfp: your definitions of homonym and homophone are equivalent. same sound, different meaning, maybe different spelling.
07:41:03 <twobitwork> vixey: ^^
07:41:08 <quicksilver> cjs: wanting for force strictness in modifyIORef?
07:41:14 <quicksilver> cjs: yes, that's a bummer.
07:41:34 <quicksilver> cjs: I sometimes wonder if putMVar and writeIORef and all derived combinators should actually be strict by default.
07:42:08 <yitz> cjs, why, because of the ($!) ?
07:42:59 <yitz> cjs: did you try modifyIORef and it leaked? it might not.
07:43:13 <vixey> @src concatMap
07:43:13 <lambdac> concatMap f = foldr ((++) . f) []
07:43:45 <yitz> quicksilver: or perhaps we need modifyIORef' etc
07:44:36 <mfp> quicksilver, yitz: funny; I'm a native Spanish speaker, and "homónimo" (Spanish for homonym) seems to imply = spelling. This explains why I prefer "homophone" in English too.
07:48:12 <vixey> @src map
07:48:13 <lambdac> map _ []     = []
07:48:13 <lambdac> map f (x:xs) = f x : map f xs
07:48:27 <vixey> :t foldr (?f . (:)) []
07:48:28 <lambdac> forall a a1. (?f::([a] -> [a]) -> [a1] -> [a1]) => [a] -> [a1]
07:48:35 <vixey> :t foldr ((:) . ?f) []
07:48:37 <lambdac> forall a a1. (?f::a1 -> a) => [a1] -> [a]
07:48:43 <sbahra> Ah, cool
07:48:53 <sbahra> @src sum
07:48:54 <lambdac> sum = foldl (+) 0
07:49:07 <swiert> @seen kosmikus
07:49:07 <lambdac> Last time I saw kosmikus was when I left dalnet:#java, dalnet:#javahelp, dalnet:#programmers, #functionaljava, #haskell, #reductio and #slinky 26d 16h 25m 43s ago, and .
07:49:07 <quicksilver> mfp: they are all complete miscoins, anyway.
07:49:20 <twobitwork> why does sum use foldl?
07:49:26 <quicksilver> mfp: synonym comes from greek 'same name'; which is not what it means!
07:49:34 <quicksilver> twobitwork: because it reduces to a single value.
07:49:49 <twobitwork> and foldr doesn't?
07:49:53 <thoughtpolice> they both do
07:49:55 <quicksilver> mfp: homonym arguably has an equivalent etymology so should mean the same thing.
07:49:58 <thoughtpolice> that's the definition of a fold
07:50:07 <quicksilver> the point is that *sum* reduces to a single value.
07:50:14 <quicksilver> not that foldl/foldr do
07:50:15 <twobitwork> right... but, isn't foldl more efficient?
07:50:19 <yitz> mfp: there seems to be a lot of disagreement about the exact meanings of homonym and other related terms. http://en.wikipedia.org/wiki/Homonymy#Related_terms
07:50:20 <quicksilver> the reason to use foldr is if you are streaming
07:50:32 <quicksilver> i.e. if the result can be partially consumed
07:50:34 <sw17ch> would any one be willing to test a library for me at some point? i finished my first set of bindings, and they could use a more experienced poudning :)
07:50:36 <quicksilver> archetypically, a list.
07:50:41 <vixey> how do you fuse foldr (f . foldr h z . g) ?
07:50:47 <thoughtpolice> sw17ch: that portaudio stuff?
07:50:51 <quicksilver> if the result is not a list then there is no point using foldr.
07:50:54 <sw17ch> thoughtpolice, yessir
07:50:57 <BONUS> can anyone think of a prelude function that has two or more class constraints?
07:51:13 <quicksilver> BONUS: realToFrac ?
07:51:21 <BONUS> ah, nice, thanks!
07:51:38 <sw17ch> @type realToFrac
07:51:40 <lambdac> forall a b. (Fractional b, Real a) => a -> b
07:52:21 <twobitwork> quicksilver: so, what would be an example of a foldl which returns a list?
07:52:50 <yitz> twobitwork: reverse
07:52:58 <yitz> @src reverse
07:52:58 <lambdac> reverse = foldl (flip (:)) []
07:54:23 <yitz> twobitwork: even though it returns a list, you can't stream a reverse, because you have to read all the way to the end of the input before you can even start returning anything. so as quicksilver says - no streaming, no foldr.
07:55:24 <BONUS> you can also implement nub as a foldl: nub [] = []; nub (x:xs) = x:nub (filter (/=x) xs)
07:55:30 * sw17ch loves firefox 3
07:55:33 <BONUS> oh wait no
07:55:36 <BONUS> lol stupid me
07:55:47 <BONUS> forget i said anything
07:56:25 * sw17ch also loves javascript
07:56:37 <quicksilver> any total function which can be implemented with foldl can be implemented with foldr, and vice versa
07:56:45 <quicksilver> they are precisely equivalent, expressibility wide.
07:56:56 <quicksilver> however, move outside total functions and into haskell and they no longer are.
07:57:18 <quicksilver> (pedants alert, I didn't quite say that right)
07:57:53 <yitz> quicksilver: s/wide/wise/, but that won't satisfy the pedants. :)
07:58:33 <vixey> @pl \ e d -> (e:) . d
07:58:33 <lambdac> (.) . (:)
07:58:46 <twobitwork> yitz: am I thinking backwards? doesn't foldl fold "to the left" from the right?
07:58:51 <chrisdone> heh.. https://bugs.launchpad.net/ubuntu/+source/lighttpd/+bug/181733
07:58:55 <quicksilver> twobitwork: foldl.com and foldr.com
07:58:55 <sw17ch> i think that science/math(s) are the only places you'll find people openly saying that they have mis-stated something intentionally for lack of a better way to do it, and it's a reasonably complete answer, but are tacking on a disclaimer just to prevent the pedants from being annoying... :)
07:58:58 <chrisdone> learn something knew and you start seeing it everywhere
07:59:02 <vixey> I think of foldr as doing everything at once
07:59:15 <vixey> a bit like pulling a tablecloth out from under all the plates and candles and such on top
07:59:24 <quicksilver> twobitwork: and http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
07:59:54 <quicksilver> vixey: I don't think that's very accurate. the whole point of foldr, used lazily, is that you don't have to do everything at once.
08:00:08 <quicksilver> You replace the (:) in the list with `f`, working gradually down the spine.
08:00:18 <quicksilver> and thus, it can even produce results on infinite lists.
08:00:24 <yitz> twobitwork: yes. why is that backwards?
08:00:36 <ski> lerkok : Erkk ?
08:01:03 <quicksilver> seems like a fair guess to me, ski :)
08:02:26 <twobitwork> yitz: heh... sorry, I'm dyslexic... I was thinking backwards even though I was saying the right stuff :P
08:02:40 <twobitwork> (I'm also left handed, which doesn
08:02:45 <twobitwork> 't help with the whole left/right thing )
08:03:03 <quicksilver> sounds dyscognic to me!
08:03:05 <quicksilver> ;P
08:03:22 <twobitwork> the two tend to go hand in hand (no pun)
08:03:35 <yitz> dysgraphic
08:03:48 <paczesiowa> @info TimeLocale
08:03:48 <lambdac> TimeLocale
08:03:58 <twobitwork> foldl/foldr.com isn't loading :(
08:04:04 <paczesiowa> @great
08:04:04 <lambdac> Plugin `dummy' failed with: Prelude.read: no parse
08:04:17 <quicksilver> twobitwork: the wikipedia page has nice pictures.
08:04:48 <hansfbaier> quicksilver: which one ?
08:05:04 <quicksilver> hansfbaier: the one I just pasted a link to :P
08:05:40 <hansfbaier> quicksilver: sorry, just joined....
08:06:06 <hansfbaier> quicksilver: ok, Ill get the logs...
08:07:59 <vixey> :/
08:08:08 <quicksilver> hansfbaier: oh, I didn't notice http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
08:08:08 <vixey> I can't figure out liftM (:) for dlists
08:08:11 <lerkok> ski: yes, that's the correct spelling.. :-)
08:08:16 <vixey> so I have,
08:08:18 <vixey> cons = (:)        :: a -> [a] -> [a]
08:08:22 <vixey> dcons = (.) . (:) :: a -> (a -> [a]) -> (a -> [a])
08:08:23 <hansfbaier> quicksilver: too late :)
08:08:30 <vixey> consM = (liftM2 (:)) :: [a] -> [[a]] -> [[a]]
08:08:34 <hansfbaier> quicksilver: thanks anyway!
08:08:38 <vixey> what's the type of dconsM?
08:10:11 <ski> `dcons' is for what ?
08:10:24 <sw17ch> @src dcons
08:10:24 <lambdac> Source not found.
08:10:25 <paczesiowa> Either dons dcoutts
08:10:42 <vixey> sw17ch: I already gave the code
08:10:53 * sw17ch just realized that...
08:10:58 <vixey> I used a wrong type annotation
08:11:03 <dcoutts_> paczesiowa: ;-)
08:11:06 <vixey> it should be
08:11:07 <vixey> dcons = (.) . (:) :: a -> ([a] -> [a]) -> ([a] -> [a])
08:11:14 <vixey> and I think that's why I was confused...
08:11:40 <vixey> ski, (foldr dcons dnil "test") [] = "test"
08:12:51 <ski> do you want to lift to list monad ?
08:13:04 <vixey> I think so
08:13:34 <matthew-_> http://www.wellquite.org/anglohaskell2008/
08:13:36 <lambdac> Title: Well Quite
08:13:53 <chrisdone> excellent title is excellent
08:14:00 <ski> you might want `liftM2 dcons' .. or maybe something else depending on use
08:14:12 <chrisdone> wow, audio and slides. awesome. thanks matthew-_
08:14:45 <ski> (maybe you really want to think CPS rather than diff .. i don't know)
08:14:50 <paczesiowa> quicksilver: if Date.Time are newer and better, then why parseTime depends on TimeLocale from old-locale?
08:16:03 <vixey> :t foldr ?dconsM ?dnilM :: [[a]] -> [[a]] -> [[a]]
08:16:05 <lambdac>     Could not deduce (?dconsM::[a]
08:16:05 <lambdac>                                -> ([[a]] -> [[a]])
08:16:05 <lambdac>                                -> [[a]]
08:17:17 <vixey> :t foldr ?dconsM ?dnilM :: [[a]] -> [a] -> [[a]]
08:17:20 <lambdac>     Could not deduce (?dconsM::[a] -> ([a] -> [[a]]) -> [a] -> [[a]])
08:17:20 <lambdac>       from the context ()
08:17:20 <lambdac>       arising from a use of implicit parameter `?dconsM'
08:17:27 <cjs> yitz: Sorry, yes, I did try modifyIORef, and I can't find a way to keep it from leaking. Quicksilver's right on this one.
08:17:32 <vixey> maybe it's impossible to do this
08:17:39 <yitz> @type (.) . (:)
08:17:41 <lambdac> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
08:18:03 <yitz> grr
08:18:08 <Deewiant> vixey: you have one parameter too much in the type, I think?
08:18:14 <vixey> > let cons = (.) . (:) ; nil = id in ( (cons 1 (cons 2 (cons 3 nil))) ++ (cons 66 (cons 99 nil)) ) []
08:18:15 <lambdac>  [1,2,3,66,99]
08:18:32 <vixey> Deewiant what do you mean?
08:18:51 <quicksilver> paczesiowa: I'm not entirely sure, but I think the TimeLocale class hasn't been replaced yet.
08:18:51 <Deewiant> vixey: well, given the two ? parameters foldr only takes one more
08:19:21 <Deewiant> ?ty foldr ?cons ?nil []
08:19:22 <lambdac> forall a b. (?nil::b, ?cons::a -> b -> b) => b
08:19:32 <Deewiant> ?ty foldr ?cons ?nil :: [[a]] -> [[a]]
08:19:34 <lambdac>     Could not deduce (?cons::[a] -> [[a]] -> [[a]]) from the context ()
08:19:34 <lambdac>       arising from a use of implicit parameter `?cons'
08:19:34 <lambdac>                    at <interactive>:1:6-10
08:19:45 <Deewiant> well, doesn't work anyway, but still. :-P
08:19:48 <vixey> I don't understand
08:19:56 <quicksilver> paczesiowa: indeed, I observed this apparent surprise in http://thread.gmane.org/gmane.comp.lang.haskell.cafe/31670/focus=31678
08:19:58 <lambdac> Title: Gmane Loom, http://tinyurl.com/5llczp
08:20:37 <Deewiant> vixey: you gave foldr two parameters and then asked for the type "[[a]] -> [[a]] -> [[a]]". But foldr with two parameters should have type "a -> b" (for sane a and b).
08:20:39 <vixey> what I want is
08:20:48 <vixey> (++) . foldr consM nilM = foldr dconsM nilM
08:21:04 <vixey> @src (++)
08:21:05 <lambdac> (++) []     ys = ys
08:21:05 <lambdac> (++) (x:xs) ys = x : xs ++ ys
08:21:22 <vixey> xs ++ ys = foldr (:) ys xs
08:21:23 <yitz> @unpl (.) . (:)
08:21:24 <lambdac> (\ f b c -> ((:)) f (b c))
08:21:33 <paczesiowa> quicksilver: then I'm gonna stick with old-*
08:21:34 <Deewiant> (++) = mappend
08:21:57 <vixey> yitz:  dcons x xs = (x:) . xs
08:22:04 <vixey> yitz:  dcons = (.) . (:)
08:23:55 <quicksilver> paczesiowa: I wouldn't. The API of the old ones is quite horrendous.
08:24:05 <quicksilver> paczesiowa: the new ones have been measured at 540 times better.
08:24:14 <yitz> so dcons :: b -> (a -> [b]) -> (a -> [b]) -- right?
08:24:25 <Deewiant> ?ty (.).(:)
08:24:27 <lambdac> forall (f :: * -> *) a. (Functor f) => a -> f [a] -> f [a]
08:24:28 <vixey> a -> ([a] -> [a]) -> ([a] -> [a])
08:24:35 <vixey> dcons :: a -> ([a] -> [a]) -> ([a] -> [a])
08:24:37 <ski> @type (P..) P.. (:)
08:24:38 <lambdac> forall a a1. a1 -> (a -> [a1]) -> a -> [a1]
08:25:10 <paczesiowa> quicksilver: reading/writing rfc822 looks the same
08:25:13 <yitz> ah, thanks ski
08:25:20 <vixey> no
08:25:23 <quicksilver> paczesiowa: probably. The date math is better htough.
08:25:23 <vixey> don't use that type
08:25:26 <vixey> use:  a -> ([a] -> [a]) -> ([a] -> [a])
08:26:03 <paczesiowa> quicksilver: I only need read/write/eq/max
08:26:39 <vixey> I need to rewrite
08:26:41 <vixey> \x y -> (foldr (:) y . foldr consM nilM) x
08:26:44 <vixey> to use a single fold
08:26:50 <hansfbaier> @djinn f : (a -> a1 -> b)
08:26:50 <lambdac> Plugin `djinn' failed with: Prelude.tail: empty list
08:26:55 <ski> a -> (s -> [a]) -> (s -> [a])
08:27:06 <hansfbaier> ﻿ @djinn f : ﻿a -> a1 -> b
08:27:30 <vixey> :t foldr (:) ?y
08:27:31 <lambdac> forall a. (?y::[a]) => [a] -> [a]
08:29:18 <yitz> @type ap `ap` dcons
08:29:20 <lambdac> Not in scope: `dcons'
08:29:33 <yitz> @type ap `ap` ((.) . (:))
08:29:35 <lambdac>     Occurs check: cannot construct the infinite type:
08:29:35 <lambdac>       a = [f a -> f b1 -> b]
08:29:35 <lambdac>       Expected type: (f a -> f b1 -> b) -> a -> b1
08:29:37 <vixey> @let dcons = (.) . (:) :: a -> ([a] -> [a]) -> ([a] -> [a])
08:29:42 <lambdac> Defined.
08:29:47 <vixey> @let dnil = id         :: a -> a
08:29:48 <lambdac> Defined.
08:30:23 <hackage> Uploaded to hackage: hxt-filter 8.1.0
08:30:25 <yitz> @type ap `ap` (:)
08:30:26 <lambdac>     Occurs check: cannot construct the infinite type:
08:30:27 <lambdac>       m = (->) [m (a -> b)]
08:30:27 <lambdac>     Probable cause: `:' is applied to too few arguments
08:30:57 <luqui> > (dcons "h" $ dcons "e" $ dcons "l" $ dcons "l" $ dcons "o" $ dnil) "world"
08:30:57 <lambdac>  Couldn't match expected type `[Char]' against inferred type `Char'
08:31:14 <hansfbaier> @src dcons
08:31:15 <lambdac> Source not found. Do you think like you type?
08:31:18 <luqui> > (dcons 'h' $ dcons 'e' $ dcons 'l' $ dcons 'l' $ dcons 'o' $ dnil) "world"
08:31:19 <lambdac>  "helloworld"
08:32:14 <sbahra> @src concat
08:32:14 <lambdac> concat = foldr (++) []
08:32:18 <luqui> @type ap const const
08:32:20 <lambdac> forall a. a -> a
08:32:24 <sbahra> @src foldr
08:32:24 <lambdac> foldr f z []     = z
08:32:24 <lambdac> foldr f z (x:xs) = f x (foldr f z xs)
08:32:32 <dons> matthew-_: good work!
08:32:32 <lambdac> dons: You have 3 new messages. '/msg lambdac @messages' to read them.
08:32:33 <vixey> sbahra:
08:32:38 <vixey> @src []
08:32:39 <dons> nice slides for anglo haskell, peoplez, http://www.reddit.com/comments/6vtt7/anglo_haskell_2008_great_slides_on_parallel_gc/
08:32:39 <lambdac> data [] a = [] | a : [a]
08:32:40 <lambdac> Title: Anglo Haskell 2008: great slides on parallel GC, fusion, EDSLs and types! : redd ..., http://tinyurl.com/57fruz
08:33:05 <vixey> foldr nil (*) (a : b : c : d : []) = (a * b * c * d * nil)
08:33:09 <vixey> oops
08:33:13 <vixey> foldr (*) til
08:33:39 <luqui> > foldr n (*) (a:b:c:d:[])
08:33:39 <lambdac>  Couldn't match expected type `a -> b -> b'
08:33:40 <EvilTerran> > foldr (*) x [a,b,c,d] :: Expr
08:33:41 <lambdac>  a * (b * (c * (d * x)))
08:33:45 <EvilTerran> > foldl (*) x [a,b,c,d] :: Expr
08:33:46 <lambdac>  x * a * b * c * d
08:33:54 <vixey> lol
08:34:41 <luqui> > x > x
08:34:42 <lambdac>  False
08:34:50 <luqui> > x > y
08:34:51 <lambdac>  False
08:34:56 <luqui> > y > x
08:34:57 <lambdac>  True
08:35:06 <luqui> oh I see how it is
08:35:27 <luqui> > sort [i,a,m,t,h,e,v,e,r,y,m,o,d,e,l,o,f,a,m,o,d,e,r,n,m,a,j,o,r,g,e,n,e,r,a,l]
08:35:28 <lambdac>  [a,a,a,a,d,d,e,e,e,e,e,e,f,g,h,i,j,l,l,m,m,m,m,n,n,o,o,o,o,r,r,r,r,t,v,y]
08:35:34 <matthew-_> dons: cheers :)
08:35:37 <EvilTerran> > x == x
08:35:38 <lambdac>  True
08:36:03 <luqui> that doesn't seem generic
08:36:11 <luqui> > sort [x,y,z]
08:36:12 <lambdac>  [x,y,z]
08:36:19 <luqui> sort is the identity on three-element lists, I see!
08:36:35 <Deewiant> > sort [x,z,y]
08:36:37 <lambdac>  [x,y,z]
08:36:48 <Elly> luqui: it all makes sense now
08:37:16 <quicksilver> > sort [y,x,z]
08:37:17 <lambdac>  [x,y,z]
08:37:30 <vixey> hm
08:38:04 <luqui> > sort [x:x:x:[],y:y:y:[],z:z:undefined]
08:38:05 <lambdac>  [[x,x,x],[y,y,y],[z,zException: Prelude.undefined
08:38:23 <vixey> (++) . foldr (liftM2 cons) (return nil) = \x -> foldr (liftM dcons) (return dnil) . map ((++) x)
08:39:15 <EvilTerran> or (x++) instead of ((++) x) if you prefer
08:39:41 <Quadrescence> Is there a good "tutorial"/reference to IO (generally)? Like how to get user input and use it and maybe output it.
08:39:43 <luqui> :t (++) . foldr (liftM2 ?cons) (return ?nil)
08:39:45 <lambdac> forall a1 r (m :: * -> *). (?nil::r, Monad m, ?cons::a1 -> r -> r, Monoid (m r)) => [m a1] -> m r -> m r
08:40:03 <EvilTerran> :t (Prelude.++) . foldr (liftM2 ?cons) (return ?nil)
08:40:06 <lambdac> forall a1 r. (?nil::r, ?cons::a1 -> r -> r) => [[a1]] -> [r] -> [r]
08:40:07 <luqui> Quadrescence, no, none.  well, about a thousand.  but basically none.
08:40:13 <Quadrescence> V_V
08:40:16 <EvilTerran> hm
08:40:36 <Quadrescence> luqui: Though indirect, I was requesting that someone point me to a good one.
08:40:36 <quicksilver> Quadrescence: tutorial and reference are surely completely opposite
08:40:41 * luqui likes dan piponi's
08:40:47 <quicksilver> Quadrescence: there is a very good reference: the library documentation.
08:40:52 <quicksilver> there are also a bunch of tutorials.
08:41:31 <luqui> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
08:41:33 <lambdac> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
08:41:39 * EvilTerran likes that one too
08:41:46 <luqui> if you're the kind of person who understands by using, rather than by understanding, that's a good one
08:41:46 <EvilTerran> lets you get on with it
08:41:48 <quicksilver> I'm not sure if Quadrescence is trying to grok monads, or just how to use the library.
08:42:01 <quicksilver> if you're happy to ignore monads it's not very different from most other langauges.
08:42:09 <EvilTerran> then, when you understand monads in general, you can go back and go for one of the more theoretical (less pragmatic) tutorials
08:42:21 <quicksilver> putStrLn "What is your name?"; name <- getLine; putStrLn ("Hello " ++ name)
08:42:36 <Quadrescence> quicksilver: It feels like it is. I always get types wrong and whatever.
08:43:00 * quicksilver nods
08:43:05 <quicksilver> then you probably *do* want a monad tutorial.
08:43:14 <quicksilver> sigfpe's one is a good start.
08:43:37 <chrisdone> I like the one on Real World Haskell, though I didn't learn from it..
08:43:46 <quicksilver> I think the errors are not very suprising (C++ would give similar), but they might be harder to read!
08:43:56 <quicksilver> *interpreting* the errors may be harder
08:44:29 <EvilTerran> i tend to recommend "IO for people who don't care" followed by "you could have invented monads"
08:44:48 <Quadrescence> Hehehe
08:44:57 <Quadrescence> I am on "you could have invented monads" now.
08:47:02 <Arnar> hey folks, good day to all
08:47:32 <chrisdone> good day to you
08:48:05 <Arnar> would you mind terribly a non-haskell related question?
08:48:06 <Arnar> :)
08:48:45 <sbahra> @src last
08:48:46 <lambdac> last [x]    = x
08:48:46 <lambdac> last (_:xs) = last xs
08:48:46 <lambdac> last []     = undefined
08:48:54 <luqui> what... is your wife's favorite sexual position?
08:48:58 <chrisdone> @ask
08:48:59 <lambdac> Plugin `tell' failed with: Prelude.head: empty list
08:49:04 <Arnar> I'm faced with this problem often, and perhaps many of you too. I'm a graduate student and when writing stuff, I find I often need "standard" references.. like for "call-by-name"
08:49:16 <Arnar> luqui: same as mine.. naturally :)
08:49:32 * sw17ch is starting to think he made the right decision not going to grad school...
08:49:37 <luqui> hmmm, what sexual position is its own complement?
08:49:45 <Arnar> how do you guys handle this? In this case I could cite Pierce or any other textbook.. but ther must be some "standard" reference everyone cites
08:49:57 <quicksilver> Arnar: I got a colleague to give me their .bib file
08:49:58 <Arnar> luqui: fix sexposs
08:50:11 <quicksilver> Arnar: that gave me the standard reference for most of the stuff our research group worked on.
08:50:27 <Arnar> quicksilver: ok.. good idea.. problem is that no-one at my school is doing PL work :/
08:50:30 <Arnar> but me..
08:50:44 <luqui> hmmm.. it has nontermination as a fixpoint.  Wow... sounds like heaven...
08:50:50 <quicksilver> if call-by-name is a real need, rather than an example, then get hold of "Call-by-push-value", P.B.Levy's PhD thesis.
08:50:58 <quicksilver> that has a good bibliography.
08:51:22 <Arnar> quicksilver: thx..
08:51:35 <quicksilver> it's also a very good thesis, I'm told.
08:51:41 <quicksilver> although I've been too lazy to read it myself.
08:51:44 <quicksilver> Please don't tell Paul.
08:51:49 * Arnar looks it up in Papers
08:51:56 <Arnar> quicksilver: your advisor? :)
08:52:04 <chrisdone> good motto. Don't Tell Paul
08:52:19 <quicksilver> http://www.cs.bham.ac.uk/~pbl/
08:52:20 <lambdac> Title: Paul Blain Levy
08:52:26 <quicksilver> no, he was a couple of years ahead of me.
08:52:43 <quicksilver> we shared an office for a few months
08:52:49 <vixey> @instances Monad
08:52:50 <lambdac> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:53:10 <Arnar> ah..
08:53:39 <vixey> :t foldr (liftM2 ((.) . (:))) (return id) [?x]
08:53:41 <lambdac> forall a1 (m :: * -> *). (?x::m a1, Monad m) => m ([a1] -> [a1])
08:57:02 <BeelsebobWork> anyone got any experience with using SDL from Haskell?
08:57:08 <Quadrescence> clarification: func1 func2 x = func1 $ func2 x
08:57:10 <Quadrescence> ?
08:57:31 <Quadrescence> (i.e., functions are right associative, right?)
08:57:48 <paczesiowa> no
08:57:55 <Quadrescence> Aw shucks.
08:58:02 <ski> > ()
08:58:03 <lambdac>  ()
08:58:08 <quicksilver> func1 func2 x is (func1 func2) x
08:58:20 <ski> oh, lambdabot's sleeping ..?
08:58:21 <quicksilver> otherwise 2 argument functions wouldn't work :P
08:58:29 <Quadrescence> Okay. I /thought/ so.
08:58:34 <Quadrescence> But bloo blah
08:58:37 * Quadrescence continues reading.
08:58:38 <BeelsebobWork> ski: she was using up way too much of code.haskell.org's resources
08:58:41 <BeelsebobWork> so they put her to sleep
08:58:46 <quicksilver> left-associative function application is key for (convenient) currying.
08:59:03 <ski> BeelsebobWork : when transpired this of which you speak ?
08:59:27 <BeelsebobWork> ski: IIRC some time around 2PM european silly summer time, in #ghc
08:59:48 <BeelsebobWork> @seen Lemmih
08:59:48 <lambdac> I saw Lemmih leaving #haskell 3h 52m 45s ago, and .
08:59:53 <BeelsebobWork> bugger
08:59:57 <BeelsebobWork> keep missing people today
09:03:04 <stevan> does the recursive schema used in data.generics.everywhere happen to have a *morphism name?
09:03:14 <janszn> @pl (\xs -> xs++xs)
09:03:14 <lambdac> join (++)
09:03:18 <paczesiowa> :t let f x = (x,x) in let g x = (f $ f x, f $ f x) in let h x = (g $ g x, g $ g x) in let i x = (h $ h x, h $ h x) in i 1
09:03:34 <lambdac> thread killed
09:03:50 <paczesiowa> damn
09:05:06 <ski> invoking exponential behaviour in type-checking, are we ?
09:05:45 <janszn> @pl iterate (\xs -> xs++xs) [0..3]
09:05:45 <lambdac> iterate (join (++)) [0..3]
09:06:38 <vixey> :t ([[]]++)
09:06:40 <lambdac> forall a. [[a]] -> [[a]]
09:07:48 <BeelsebobWork> does anyone know where the SDL binding were originally kept?
09:08:56 <paczesiowa> quicksilver: ok, old-* don't provide parsing for dates
09:09:45 <Quadrescence> :t id
09:09:46 <ski> haskell provides dates now ?!
09:09:47 <lambdac> forall a. a -> a
09:09:52 <Quadrescence> okay, it works
09:10:04 <cizra> Dates? I want a date as well!
09:10:08 <Botje> well, it's old enough :p
09:10:09 <Quadrescence> :t (,)
09:10:10 <lambdac> forall a b. a -> b -> (a, b)
09:10:22 * ski eats his date marmelade
09:10:33 <Quadrescence> > (,) 1 2
09:10:34 <lambdac>  (1,2)
09:10:38 <Quadrescence> Interestinggggggg.
09:10:48 <Quadrescence> :t (,,,,,)
09:10:50 <lambdac> forall a b c d e f. a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
09:10:52 <Quadrescence> mmmmm
09:10:54 <Botje> :t uncurry (,) -- :o)
09:10:57 <lambdac> forall a b. (a, b) -> (a, b)
09:11:12 <Quadrescence> I don't know what curry/uncurry are. :<
09:11:26 <Quadrescence> :t curry
09:11:27 <paczesiowa> > (+) 2 2
09:11:29 <lambdac> forall a b c. ((a, b) -> c) -> a -> b -> c
09:11:31 <lambdac>  4
09:11:41 <paczesiowa> > uncurry (+) (2, 2)
09:11:42 <lambdac>  4
09:12:14 <twobitwork> > curry (uncurry (+)) 2 2
09:12:16 <lambdac>  4
09:12:25 <paczesiowa> the more you know...
09:12:25 <ski> > map (uncurry (*)) [(x,y) | x <- [0..5] , let y = 5-x]
09:12:26 <lambdac>  [0,4,6,6,4,0]
09:12:47 <Quadrescence> Looks /somewhat/ related to zipWith
09:13:38 <Quadrescence> > map (uncurry (*)) [(x,y) | x <- [0..8] , let y = 8-x]
09:13:40 <lambdac>  [0,7,12,15,16,15,12,7,0]
09:13:53 <Quadrescence> That better not be a list of binomial coefficients. :O
09:13:54 <twobitwork> Quadrescence: not really... all functions are naturally curried in haskell... uncurry turns a function of type "a -> b -> c" into a function of type "(a, b) -> c"
09:14:23 <Jedai> Quadrescence: uncurry f (a, b) == f a b
09:14:35 <ski> @type \f xs ys -> map (uncurry f) (zip xs ys)
09:14:37 <Jedai> Quadrescence: curry f a b == f (a, b)
09:14:37 <lambdac> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
09:14:43 <ski> @type \f xs ys -> zipWith f xs ys
09:14:45 <lambdac> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:14:58 <Quadrescence> See? I told you it was related. :>
09:15:08 <ski> (that possibly is a rule)
09:15:11 <vixey> @pl (\e xs -> (++) (liftM2 (:) (e []) (xs [])))
09:15:11 <lambdac> ((++) .) . (. ($ [])) . liftM2 (:) . ($ [])
09:15:14 <quicksilver> it is related, yes :)
09:15:37 <vixey> Any clues how to optimize (\e xs -> (++) (liftM2 (:) (e []) (xs []))) ?
09:15:59 <pozic> Is there any documentation on how to use smallcheck?
09:17:29 <twobitwork> ok... so foldr can be used lazily, but foldl uses constant stack space... am I right?
09:18:11 <paczesiowa> almost
09:18:16 <paczesiowa> foldl' does
09:18:24 <twobitwork> @src fold'
09:18:24 <lambdac> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:18:26 <twobitwork> @src foldl'
09:18:26 <lambdac> foldl' f a []     = a
09:18:26 <lambdac> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:18:39 <twobitwork> @src foldl
09:18:40 <lambdac> foldl f z []     = z
09:18:40 <lambdac> foldl f z (x:xs) = foldl f (f z x) xs
09:18:41 <Stinger_> heh broccoli brains
09:18:51 <twobitwork> foldl is tail-recursive...
09:19:03 <paczesiowa> foldl' is stricter
09:19:23 <twobitwork> right... but shouldn't foldl still use constant stack?
09:19:28 <int-e> foldl itself uses constant stack space, but it builds a deeply nested thunk as its result which often will result in a stack overflow when evaluated.
09:19:45 <twobitwork> ohh
09:20:08 <twobitwork> so, haskell builds thunks strictly? (does that make sense?)
09:20:08 <Jessehk> From what I understand from reading haskell.org, Text.Regex should be replaced by Text.Regex.{Posix, PCRE, etc}, Right? If I want to split text, should I still used splitRegex from Text.Regex?
09:20:19 <twobitwork> I mean, shouldn't haskell be able to build the thunks lazily?
09:20:26 <vixey> It can't be optimized can it?
09:20:41 <twobitwork> vixey: are you asking, or is that rhetorical?
09:20:55 <int-e> twobitwork: thunks are the implementation of lazyness, they're suspended computations that represent a value to be evaluated when demanded
09:21:03 <int-e> *laziness.
09:21:06 <vixey> I'm asking about (\e xs -> (++) (liftM2 (:) (e []) (xs [])))
09:21:08 <twobitwork> gah, brb
09:21:15 <quicksilver> thunks are built lazily.
09:21:34 <quicksilver> but when you are reduced to a single value, the thunks are all demanded simultaneously
09:21:36 <Quadrescence> Monads are suddenly making senseeeeeeeeee.
09:21:38 <quicksilver> without any of them being gced
09:21:41 <quicksilver> so they do all exist at once.
09:21:43 <ski> @type \e xs -> (++) (liftM2 (:) (e []) (xs []))
09:21:45 <lambdac> forall a1 a (m :: * -> *) a11. (Monoid (m [a1]), Monad m) => ([a] -> m a1) -> ([a11] -> m [a1]) -> m [a1] -> m [a1]
09:21:51 <chris2> how do i find out the precedence of +?
09:21:59 <int-e> > [1..] !! 100000
09:22:00 <lambdac>  100001
09:22:07 <vixey> infixl 6
09:22:16 <int-e> chris2: in ghci, type :i (+)
09:22:27 <chris2> aah, thanks!
09:24:37 <int-e> chris2: if it doesn't give any fixity (like :i (!!)) it's infixl 9 (the default)
09:24:46 <chris2> okay
09:24:51 <chris2> works now, thanks
09:24:57 <paczesiowa> there was great article on haskell wiki on differences between foldl and foldl' with great pointer on when to use witch, but I can't find it now
09:25:07 <ski> vixey : can't what you want to do be expressed in an arbitrary monad ?
09:25:23 <vixey> I only want it for m = []
09:25:38 <ski> yes, but does it *depend* on `m = []' ?
09:25:39 <vixey> but basically I have to take the product of some arrows
09:25:54 <chrisdone> anyone know if one can make use of GHC's mechanism for checking if a file has changed (and thus needs to be recompiled)?
09:25:55 <vixey> so I think I must convert them to lists and back, which means optimizing is not possible
09:26:14 <ski> it appears you want to make a diff-list cons, lifted over an arbitrary monad, but i'm not sure
09:26:26 <vixey> only []
09:26:44 <paczesiowa> chrisdone: hs-plugins have functions for these kind of things
09:27:00 <ski> anyway, i think your `(++)' is probably wrong, there
09:27:28 <chrisdone> paczesiowa: ugh, ok..
09:28:11 <ski> @type \e xs ys -> liftM (P.++ ys) (liftM2 (:) (e []) (xs []))
09:28:12 <lambdac> forall a1 a (m :: * -> *) a11. (Monad m) => ([a] -> m a1) -> ([a11] -> m [a1]) -> [a1] -> m [a1]
09:28:15 <dsrogers_> chisdone: you mean ghc --make?
09:28:24 <paczesiowa> chrisdone: but unless you are already using it, it'll be almost impossible to plug it in
09:28:35 <ski> (that looks more like what you want to do ..)
09:28:47 <chrisdone> dsrogers_: that's right
09:28:58 * ski ponders
09:29:20 <chrisdone> paczesiowa: I guess I can just check the return value of ghc --make, seeing as I use that anyway. I just want to know if it actually recompiled anything, because I restart a FastCGI process accordingly
09:29:49 <dsrogers_> in what way is ghc --make not suitable?
09:29:54 <luqui> chrisdone, you could check the mtime of the result
09:30:41 <ski> hm
09:30:53 <ski> vixey : why `e []' ?
09:30:57 <chrisdone> luqui: before and after, that could work
09:31:00 <paczesiowa> sounds like you could use hs-plugins, you could do all the things in haskell app, without cgi
09:31:02 <dsrogers_> ah.  yeah mtime.
09:31:11 <dsrogers_> or hs-plugins
09:31:18 <vixey> $[] is fromDlist and (++) is toDlist
09:31:20 <dsrogers_> or HApps and sc.
09:31:37 <paczesiowa> but, you'll have to heavily restructure your code
09:31:39 <chrisdone> uh, not using cgi is not an option
09:31:40 <dsrogers_> or the return value of ghc, that works too.
09:31:49 <quicksilver> win 27
09:31:55 <quicksilver> grrrrrr
09:32:32 <ski> vixey : for monadically lifted ones, `toDlist = liftM . flip (++)'
09:32:39 <dsrogers_> you could run a process which uses kernel events to monitor changes to a set of files.  Then you'll know in advance if ghc is going to recompile something
09:33:11 <ski> vixey : why is the `e' argument (presumable an "element") a diff-list ?
09:34:47 <vixey> I was trying it ou
09:34:49 <vixey> out
09:35:00 <vixey> it seems to be a dead end though
09:35:33 <ski> possibly you can optimize it .. but i think it's first good to be clear on what to optimize
09:37:30 <ski> @type \e xs ys -> liftM2 (:) e (xs ys)
09:37:31 <lambdac> forall t a1 (m :: * -> *). (Monad m) => m a1 -> (t -> m [a1]) -> t -> m [a1]
09:38:16 <ski> does that help ?
09:38:23 <vixey> yes!!
09:38:31 <vixey> :t foldr (\e xs ys -> liftM2 (:) e (xs ys))
09:38:33 <twobitwork> I'm starting to get the impression that laziness isn't that great unless you're working with infinite lists...
09:38:34 <lambdac> forall t a1 (m :: * -> *). (Monad m) => (t -> m [a1]) -> [m a1] -> t -> m [a1]
09:38:39 <ski> (set `t' to `[a1]' obviously)
09:38:51 <twobitwork> I can't seem to wrap my head around it...
09:38:55 <vixey> :t foldr (\e xs ys -> liftM2 (:) e (xs ys)) ([[]]++)
09:38:57 <lambdac> forall a. [[a]] -> [[a]] -> [[a]]
09:39:09 <quicksilver> twobitwork: maybe you're worrying too much?
09:39:15 <ski> twobitwork : laziness is great when you don't have to consume all of some datastructure
09:39:21 <vixey> > foldr (\e xs ys -> liftM2 (:) e (xs ys)) ([[]]++) ["!%?","10"] []
09:39:22 <lambdac>  ["!1","!0","%1","%0","?1","?0"]
09:39:29 <ski> (and for other reasons)
09:39:32 <quicksilver> twobitwork: laziness is useful to allow you to program without worry about evaluation order.
09:39:40 <quicksilver> this is trivial, in a way, but very relaxing
09:39:53 <quicksilver> you can have "let a = foo; b = bar; c = baz in .... "
09:40:03 <quicksilver> without worryin about whether each branch of your program acutally USES a b and c
09:40:08 <quicksilver> they're computed only as needed.
09:40:53 <twobitwork> ski: but I feel like the problems it introduces -- like turning what seems to be a benign tail-call into something which can overflow the stack -- aren't as trivial
09:41:00 <Quadrescence> :t return
09:41:01 <twobitwork> er, quicksilver ^^
09:41:01 <lambdac> forall a (m :: * -> *). (Monad m) => a -> m a
09:41:14 <Quadrescence> :t do
09:41:16 <lambdac> Empty 'do' construct
09:41:22 <chrisdone> do is just syntactic sugar
09:41:25 <Quadrescence> Right.
09:41:26 <twobitwork> :t do {}
09:41:27 * luqui things laziness is great because it guarantees that you can factor out any part of your program without worries
09:41:29 <lambdac> Empty 'do' construct
09:41:33 <luqui> into a function..
09:41:33 <ski> bah
09:41:48 <quicksilver> twobitwork: you're thinking too operationally.
09:41:48 <EvilTerran> twobitwork, you only expect that tail call to be well-behaved because of how strict languages work, though
09:41:59 <quicksilver> twobitwork: deep recursion causes problems.
09:42:04 <quicksilver> languages solve it different ways.
09:42:04 <Quadrescence> :t do {return [x,x]}
09:42:06 <lambdac> forall (t :: * -> *). (Monad t) => t [Expr]
09:42:06 <chrisdone> { do foo <- bar; mu } = bar >>= \foo -> mu
09:42:13 <quicksilver> you're used to programming languages which solve it using tail calls.
09:42:32 <quicksilver> I note that C++ doesn't solve it AT ALL.
09:42:37 <EvilTerran> twobitwork, if you came to haskell with no prior knowledge of programming, became very familiar with it, then started learning strict languages, you'd quite possibly find the lazy way more intuitive
09:42:39 <quicksilver> and is still a widely used language :)
09:42:42 <twobitwork> quicksilver: I'm not arguing for C++ :)
09:42:48 <quicksilver> no, but you take my point?
09:42:54 <quicksilver> tail-calls really aren't a big deal.
09:43:00 <quicksilver> they're a trivial hack to solve a particular problem
09:43:03 <quicksilver> in particular languages
09:43:06 <luqui> > do 42
09:43:07 <lambdac>   add an instance declaration for (Num (t t1))
09:43:10 <quicksilver> other languages have other ways of solving that problem.
09:43:16 <vixey> trivial hack ?
09:43:22 <quicksilver> yes, trivial hack.
09:43:33 <quicksilver> "oh, we don't really need a call stack if we call ourselves, let's stamp over it"
09:43:34 <vixey> It's a very important technique in compilers ...
09:43:45 <quicksilver> only in stack-based compielrs though
09:44:00 <twobitwork> haskell is stack-based, no?
09:44:00 <quicksilver> trivial and importance are not in opposition
09:44:04 <quicksilver> plenty of important things are trivial.
09:44:08 <quicksilver> twobitwork: not, not really.
09:44:20 <twobitwork> then why do I get stack overflows?
09:44:40 <paczesiowa> quicksilver: "let a = foo; b = bar; c = baz in .... " would be trivial to mimic in ocaml - just lazify all values from where blocks - you only want them to be (word which means that if you start evaluating function you'll eval it to the end)
09:44:48 <quicksilver> if I called it a thunk-chain overflow would you feel better?
09:44:54 <twobitwork> heh, ok
09:44:55 <quicksilver> paczesiowa: sure, and it's trivial to implement in assembly language.
09:45:07 <quicksilver> paczesiowa: trivial conveniences are very handy.
09:45:26 <quicksilver> otherwise we'd all program the way I do
09:45:36 <quicksilver> by positioning an electromagnet carefully above my laptop.
09:45:48 <twobitwork> lol
09:45:50 <quicksilver> anything else is just a convenience.
09:46:17 <quicksilver> twobitwork: the point is it's perfectly possible to have deep stack entry in haskell without an overflow
09:46:37 <chrisdone> quicksilver: Dijkstra wouldn't have liked this
09:46:38 <quicksilver> twobitwork: because what you would think of as stack frames in C (or indeed ocaml) can be garbage collected as you descend.
09:46:52 <quicksilver> so it really isn't stack-based in that sense.
09:46:58 <twobitwork> I'm just trying to figure out how to write my permutation function in a way that uses constant or linear space
09:47:04 <twobitwork> and I can't seem to get it
09:47:15 <quicksilver> I doubt your problem is related to laziness.
09:47:27 <quicksilver> I'm sure it would be just as hard in a strict language.
09:47:44 <quicksilver> as I said earlier, the problem is just enumerating the elements of m! in a sensible way
09:47:57 <quicksilver> which is not a stonkingly hard problem but it's not a one-liner either.
09:48:01 <twobitwork> well... of course, technically the problem is that I'm having a hard time reasoning about the proper lazy way to do it... whereas I feel it would be simpler for me to reason about in a strict language like ocaml
09:48:33 <twobitwork> right... and enumerating m! in a sensible way is what I'm having a hard time with :)
09:48:36 <vixey> twobitwork: then use ocaml
09:49:11 <quicksilver> I appreciate your problem.
09:49:14 <twobitwork> vixey: I'm not trying to start a language war... I much prefer the syntax and libraries of haskell... but I'm hitting a road block with the laziness
09:49:19 <quicksilver> I just think your'e being unfair in blaming laziness for it.
09:49:27 <quicksilver> I think this problem has nothing at all to do with laziness.
09:49:42 <twobitwork> quicksilver: I'm not "blaming" anything... I'm just saying that the laziness boggles me :)
09:49:50 <Quadrescence> I guess this would be a good read --> http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
09:49:58 <quicksilver> FWIW, the simplest aproach is a recursion of depth 'm'
09:50:07 <quicksilver> where you pass the list of unused items as a parameter.
09:50:11 <quicksilver> that should use O(m) space
09:50:15 <quicksilver> (rather than O(m!))
09:50:18 <chrisdone> I wonder if iPod is becoming synonymous with "portable music player", like hoover with vacuum cleaner
09:50:29 <chrisdone> what's that phenomenom called?
09:50:37 <quicksilver> losing your trademark rights :)
09:51:02 <chrisdone> yeah, like Google disliking people calling all search engine use "googling"
09:51:21 <EvilTerran> chrisdone, "genericizing a trademark"
09:51:30 <ski> (`hoover' ?)
09:51:39 <chrisdone> EvilTerran: that'll do
09:51:55 <chrisdone> ski: a kind of vacuum cleaner
09:52:17 <ski> after the FBI person ?
09:52:28 <chrisdone> ._.
09:52:29 <Quadrescence> chrisdone: http://en.wikipedia.org/wiki/Category:Genericized_trademarks
09:52:36 <Quadrescence> Yeah, EvilTerran got it. :>
09:52:38 <chrisdone> Quadrescence: hehe, cool
09:53:04 <PeakerWork> quicksilver: "we don't really need our return address on the call stack if the only thing left for us to do is return to our caller, lets stomp over it"?
09:53:26 <ski> aka eta-reduction
09:53:31 <chrisdone> haha, I wasn't even aware frisbees were a trademark. what were they called before? "discs that you throw like a frisby<<loop>>"?
09:53:48 <pozic> Is there anyone with experience with Data.Derive?
09:54:04 <EvilTerran> well, Frisbee(TM) invented them, so they were just called Frisbees
09:54:58 <quicksilver> PeakerWork: right.
09:55:16 <Quadrescence> What "prompts" the evaluation of a function in haskell?
09:55:24 <quicksilver> Quadrescence: "case" normally.
09:55:36 <ski> > let x = undefined in ()
09:55:37 <lambdac>  ()
09:55:38 <quicksilver> or a function definition with a pattern match, like head (x:xs) = x
09:55:46 <quicksilver> which you might consider sugar for case.
09:55:49 <pozic> Does the order of definitions mattter with TH or something?
09:55:54 <ski> > case undefined of x -> ()
09:55:55 <lambdac>  ()
09:55:57 <ski> > let () = undefined in ()
09:55:58 <lambdac>  ()
09:56:00 <ski> > case undefined of () -> ()
09:56:01 <lambdac>  Exception: Prelude.undefined
09:56:14 <pozic> It says that types cannot be found, while they are in the same module.
09:56:20 <chrisdone> s
09:56:23 <chrisdone> whoops
09:56:47 <quicksilver> pozic: I have some memory that order matters in TH, yes.
09:56:51 <quicksilver> I've never used it myself.
09:59:28 <pozic> quicksilver: I had the same vague memory, but the system seems even more retarded than I thought.
10:00:52 <pozic> Even when one doesn't use TH, data Foo = (Someclass ) =>; class Someclass stops working.
10:01:50 <quicksilver> it seems rather unlikely it's retarded.
10:01:57 <quicksilver> the developers of GHC and TH are rather smart.
10:02:07 <quicksilver> I daresay there is a reasonably good reason :P
10:04:21 <Quadrescence> Has anyone used YAML with haskell?
10:04:40 <quicksilver> I made a breif experiment of writing a YAML parser
10:04:42 <Quadrescence> (anyone here, specifically)
10:04:44 <quicksilver> mainly to see how hard it was.
10:04:47 <quicksilver> I didn't actually use it.
10:04:59 <quicksilver> it wasn't very hard, although I only supported the basic features.
10:06:58 <Quadrescence> Yaml seems like a good solution to make and store config-like files.
10:07:25 <gbacon> Quadrescence: much nicer than noisy XML
10:08:39 <gbacon> wow, total alloc = 78,512,279,112 bytes
10:08:42 <xif> gbacon: (also, less verbose, more efficient over the wire...)
10:08:42 <quicksilver> Quadrescence: actually, it's widely loathed by anyone who has actually used it in practice.
10:08:52 <quicksilver> it's incredibly fragile
10:08:54 <BMeph> gbacon, Quadrescence: I prefer Lua, myself... ;)
10:08:59 <gbacon> 90% of that is HXT's readDocument
10:09:00 <quicksilver> marketed as being safely user modifiable
10:09:03 <quicksilver> but it's anything but.
10:09:22 <xif> quicksilver: nah... it's being used extensively in the Rails/Ruby world, and they like it.
10:09:33 <Quadrescence> Maybe I should make my own parser grammar and whatever.
10:09:38 <xif> also, it's gaining ground - as it matures - in Python-land as well.
10:09:47 <pozic> How can I show a Q a value to see what code is being generated?
10:10:02 <xif> Quadrescence: write yet another format?  that's probably the worst solution ;)
10:10:30 <Quadrescence> xif: Well, for my own program.
10:10:34 <Quadrescence> Not for other people to use.
10:10:34 <quicksilver> xif: you say that, but you speak to the people who actually *use* the systems rather than program them.
10:10:41 <quicksilver> xif: believe me, since I use it every day :)
10:10:50 <quicksilver> xif: the YAML backlash started a year ago.
10:11:09 <meuu> @pl unfoldr (\xs -> if null xs then Nothing else Just (splitAt 1 xs))
10:11:09 <lambdac> unfoldr (ap (flip if' Nothing . null) (Just . splitAt 1))
10:11:20 <xif> Quadrescence: as a rule, implementing your own format should be your last choice. if you don't like Yaml, use inifile, or even (ugh) XML.
10:11:29 <trofimovich> @src unfoldr
10:11:30 <lambdac> unfoldr f b  = case f b of
10:11:30 <lambdac>    Just (a,new_b) -> a : unfoldr f new_b
10:11:30 <lambdac>    Nothing        -> []
10:12:29 <xif> quicksilver: interesting. admittedly, I always applied (and still do) Yaml as a programmer, not a user. would be interested to read about said "yaml backlash".
10:12:39 <xif> (as this is the first time I hear of it)
10:13:24 <Quadrescence> xif: No way I am using XML. :S
10:13:30 <Quadrescence> I'll look at inifile.
10:14:25 <Quadrescence> It's a rather simple format I have.
10:14:26 <xif> I doubt Haskell has a good ini-file manipulator :/
10:14:49 <dsrogers> lol.
10:14:57 <dsrogers> it would be about 20 lines of parser code.
10:15:02 <quicksilver> there is ConfigParser
10:15:15 <xif> oh, it has?  there you go then, Quadrescence.
10:15:30 <xif> if I ever use Haskell more seriously, would probably have to write a decent Yaml parser.
10:15:32 <quicksilver> sorry, CofingFile
10:15:36 <quicksilver> I always get that wrong.
10:15:48 <xif> ah, with the Python library I bet ;)
10:15:54 <quicksilver> xif: basically stray newlines and spaces can screw it up too badly.
10:15:58 <quicksilver> xif: written by the same man.
10:16:00 <quicksilver> I think.
10:16:05 <dsrogers> yaml parser would also be exceedingly easy.
10:16:12 <dsrogers> haskell makes parsers very easy.
10:16:14 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile
10:16:18 <lambdac> http://tinyurl.com/64s2s6
10:16:22 <quicksilver> dsrogers: I wrote one, it was.
10:16:26 <quicksilver> But I didn't support the clever stuff.
10:16:31 <dsrogers> that's why these crazy guys keep creating DSL's everywhere.
10:16:36 <quicksilver> although actually a YAML parser isn't *quite* as easy as most people think.
10:16:43 <quicksilver> it's a rather weird format in the details.
10:32:03 <Stinger_> bah why is curl setup trying to run sh on my windows system :(
10:52:00 <DukeDave> Heya guys, what's the name for the 'lazy integers' which Haskell doesn't have?
10:52:15 <DukeDave> ... And if anyone can figure out what I mean I'll be very impressed ;)
10:52:34 <DukeDave> The concept comes up every once in a while
10:52:38 <vixey> data N = Z | S N
10:52:49 <vixey> you can do stuff like infinity = fix S
10:52:54 <trofimovich> arbitrary big integers?
10:53:33 <dsrogers> haskell has big ints
10:53:48 <chrisdone> is that like church numerals?
10:54:08 <yitz> DukeDave: John Meacham wrote a nice library for that and posted it on the cafe. I'm not sure if he ever got around to putting it up on hackage yet, though.
10:56:36 <yitz> DukeDave: http://www.mail-archive.com/haskell-cafe@haskell.org/msg31424.html
10:56:38 <lambdac> Title: Re: [Haskell-cafe] Strange subtract operator behavior - and lazy natural, http://tinyurl.com/57kqtf
10:57:32 <DukeDave> yitz: Excellent thanks
10:57:45 <DukeDave> chrisdone: Yes! That's what I was thinking of
11:06:32 <wolgo> Hello, I have a question about some haskell code I am have seen.
11:06:41 <wolgo> in the expression: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:07:34 <wolgo> Where is the subtraction of the n values for the calculation of fibs (n - 1) + fibs ( n - 2)
11:07:53 <stepcut> wolgo: there isn't any
11:08:07 <stepcut> wolgo: well, there sort of is
11:08:10 <wolgo> I noticed :)
11:08:16 <wolgo> The calculations are correct though.
11:08:41 <vixey> wolgo: There isn't any subtraction
11:08:52 <vixey> fibs is n-1,n-2,...
11:08:56 <vixey> tail fibs is n-2,n-3,...
11:08:59 <wolgo> How are the correct values collected?
11:09:00 <DukeDave> Ah yitz that's really satisfying :)
11:09:24 <daf> wolgo: it doesn't really start from n and work its way down
11:09:37 <yitz> DukeDave: yeah I really like that library. I wish he would cabalize it.
11:09:47 <wolgo> I know that it isn't your job to tell me how this works. I just found it interesting.
11:09:48 <daf> it starts from 0 and and works its way up
11:10:00 <daf> from 0 and 1
11:11:14 <daf> it doesn't compute fib(n), it computes the series 0, 1, 1, 2, 3, 5, ...
11:11:24 <daf> fib n = fibs !! n
11:11:25 <stepcut> wolgo: if you substitutie in fibs, you can see what is going on more clearly, fibs = 0 : 1 : zipWith (+) [0,1,1,2,3,5,8,13,21,34,...] (tail [0,1,1,2,3,5,8,13,21,34, ..])
11:11:40 <wolgo> so zipWith (+) fibs (tail fibs) in the first iteration is zipWith 0 + 1
11:11:43 <wolgo> AHH!
11:11:50 <wolgo> Holy shit haskell is cool
11:11:55 <sw17ch> wolgo, welcome :)
11:11:56 <EvilTerran> intermediately, fibs = 0 : 1 : zipWith (+) (0 : 1 : zipWith (+) fibs (tail fibs)) (1 : zipWith (+) fibs (tail fibs))
11:12:09 <vixey> of course you get sharing though
11:12:28 <DukeDave> Love it wolgo, that feeling is the reason I'm always pushing Haskell on people ;)
11:12:34 <EvilTerran> = 0 : 1 : (0 + 1) : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs))
11:12:39 <sw17ch> wolgo, are you in undergrad right now?
11:12:44 <wolgo> sw17ch: no
11:12:53 <wolgo> I am just a person interested in languages
11:13:08 <wolgo> praying to get accepted to regis university to start undergrad
11:13:09 <EvilTerran> etcetc
11:13:12 <sw17ch> wolgo, i'm just wondering why you gravitated toward the fibs = fibs (n-1) fibs (n-2) solution
11:14:51 <wolgo> sw17ch: It wasn't a solution I was just wondering where n - 1, n - 2 was happening
11:15:10 <wolgo> fibs(n - 1) fibs(n - 2) would take forever wouldn't it?
11:15:12 <wolgo> I do not know
11:15:38 <sw17ch> wolgo, correct
11:15:52 <wolgo> Err, by forever I mean "A long time to calculate"
11:16:00 <sw17ch> it's the classic "don't do this" example that's used when in a complexity/algo course
11:16:09 <wolgo> Oh okay.
11:16:21 <wolgo> sw17ch: I do not know why I wouldn't do that.
11:16:24 <wolgo> I will learn in school.
11:16:26 <wolgo> Heh.
11:16:29 <sw17ch> :)
11:16:37 * sw17ch just finished undergrad... 
11:16:42 <wolgo> One is tail recursive?
11:16:46 <wolgo> wait
11:16:49 <wolgo> I think I do know
11:17:17 <sw17ch> neither of them are tail recursive
11:17:33 <wolgo> Oh haha okay.
11:17:38 <sw17ch> since you have the (+) in there
11:17:43 <wolgo> Yeah, I guess I don't know wtf I am talking about.
11:17:45 <sw17ch> you need the result from both before moving on
11:17:56 <sw17ch> knowing that tail recursion is a good start
11:18:03 <Gwern-away> @seen nominolo
11:18:04 <lambdac> nominolo is in #haskell. I don't know when nominolo last spoke.
11:18:07 <sw17ch> tail recursion exists...
11:18:08 <sw17ch> :)
11:18:18 <Gwern-away> this is so annoyng, lambdabot went down and took my messages with it
11:18:25 <Gwern-away> anyone know nominolo's email address?
11:18:36 <wolgo> Okay, well I have been studying Java to prepare for school. I think this will become my weekend project.
11:20:36 <wolgo> Okay, thanks for the information. I am going to go mess around with this more.
11:20:46 <wolgo> thanks again
11:20:58 <byorgey_> gwern: nominolo@googlemail.com
11:21:10 <gwern> 'k
11:25:07 <gwern> 'Hadoop was birthed to the world by Doug Cutting, the man who gave us the Lucene search library and the Nutch web crawler. It's a little known fact that Cutting only sleeps three hours per night, and not because he is tired, but rather as an act of mercy for his keyboard. Furthermore, Hadoop isn't open source because Doug wanted to help other developers solve distributed computing problems. It's open source because he thought you could learn a thing ...
11:25:15 <gwern> ... or two from his code.'
11:25:19 <gwern> well being a java programmer he would have to spend all that time typing
11:26:30 <byorgey> hehe
11:34:11 <yitz> byorgey_: for future reference - you may have just fed nominolo's email into the spam bots. it would have been better to say something like map (toEnum . (+1) . fromEnum) "mnlhmnkn?fnnfkdl`hk-bnl"
11:34:11 <yitz> anyone know if John Meacham frequents this channel, and if so, what his nick is? (or would be revealing another secret?)
11:34:12 <yitz> byorgey: ^
11:35:04 <byorgey> yitz: yeah, my bad, you're probably right
11:35:12 <byorgey> fortunately gmail has good spam filters
11:36:08 <yitz> byorgey: yeah for me it's hopeless. my email address has been public via whois since the dawn of the Internet.
11:36:22 <Cale> byorgey: Did you send me a patch for lambdabot dealing with a memory leak?
11:36:22 <lambdac> Cale: You have 1 new message. '/msg lambdac @messages' to read it.
11:36:54 <byorgey> Cale: no, I don't think I did
11:37:21 <Cale> byorgey: Okay... do you happen to have one? dcoutts_ mentioned that you had something :)
11:37:32 <byorgey> Cale: he did?
11:37:42 <Cale> Maybe it's just confusion between you and Baughn :)
11:37:43 <dcoutts_> byorgey: sorry I think I was getting nicks confused
11:37:44 <byorgey> I'm pretty sure I have nothing of the sort
11:37:55 <byorgey> yeah, it was probably Baughn
11:37:58 <byorgey> dcoutts_: no worries =)
11:38:02 <dcoutts_> :-)
11:38:06 <yitz> Cale: is it still @seen, or did my idea help with that one?
11:39:07 <Cale> Well, we probably don't know about all the memory problems... :)
11:39:22 <Cale> I think Baughn had a patch for @seen
11:39:37 <Cale> I'm just looking through darcs changes for it... what's his email address?
11:39:46 <yitz> ok, I'd be interested to see it if so.
11:40:21 <yitz> don't post his email address unshrouded.
11:40:47 <Cale> Oh, he's probably this 'sveina'
11:42:18 <BMeph> Cale: Correct.
11:42:49 <Cale> yeah, I have a couple patches from him here, so those did get applied.
11:49:16 <sbahra> Anyone here use nano for editing haskell, by any chance?
11:49:49 <dons> only in times of danger.
11:50:11 <Elly> I only use nano when I find myself on a system without vim
11:50:13 * EvilTerran tends to use vim
11:50:17 <Elly> which is essentially never
11:50:30 <Zao> Elly: There's systems without a vi-clone?
11:50:44 <Elly> Zao: for example, the gentoo minimal install CD
11:50:47 <Baughn> Cale: My only patch for seen was to disable it. I'm slowly working my way through sql-ifying the various plugins, though
11:50:48 <Elly> appears to lack vi and vim
11:50:54 <sbahra> dons, heh
11:51:03 <Zao> Heck, even the Sparcstation10 prom has a vi :)
11:51:03 <Baughn> Cale: You may be thinking of log
11:51:23 <Elly> my initrd has a vi :)
11:51:25 <Zao> Elly: Odd design choice.
11:51:37 <Elly> useful though
11:51:38 <Zao> Elly: no nvi either?
11:52:07 * yitz uses nano when there is no vi, and vi when there is no emacs
11:52:12 <sw17ch> Elly, the gentoo-minimal CD has vim, but the minimal chroot you jump into does not
11:52:22 <sw17ch> i should rephrase that, the live cd
11:52:33 <yitz> and ed when there is no nano, and cat when there is no ed.
11:53:15 <sbahra> @src (+)
11:53:16 <lambdac> Source not found. Sorry.
11:53:49 <Baughn> @src Int (+)
11:53:49 <lambdac> Source not found.
11:53:52 <EvilTerran> sbahra, that depends on which instance of Num you're talking about
11:54:17 <EvilTerran> the implementations for the prelude types won't be expressed in plain haskell, anyway
11:54:22 <EvilTerran> ?src Integer (+)
11:54:22 <lambdac> Source not found. Do you think like you type?
11:54:24 <EvilTerran> etc
11:54:31 <yitz> sbhara, it's usually a primitive.
11:54:54 <ziman> @pl \r -> (r * sin x, r * cos x)
11:54:54 <lambdac> liftM2 (,) (sin x *) (cos x *)
11:55:19 <paczesiowa> while we are talking about editors: do anyone know smth like http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html but for emacs?
11:55:21 <lambdac> Title: Vim as a Haskell IDE, first steps, http://tinyurl.com/yvxl52
11:55:37 <EvilTerran> ziman, (sin x *) &&& (cos x *) works too, if you import Control.Arrow ((&&&))
11:55:44 <EvilTerran> ?type (&&&)
11:55:45 <lambdac> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:56:16 <EvilTerran> (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> c) -> (a ~> (b,c)) -- is more legible
11:56:26 <sbahra> yitz, EvilTerran: I see
11:56:42 <EvilTerran> and then all you need to know is that there's an instance of Arrow for (->)
11:57:00 <EvilTerran> ?djinn (a -> b) -> (a -> c) -> a -> (b,c)
11:57:00 <lambdac> Plugin `djinn' failed with: Prelude.tail: empty list
11:57:05 <EvilTerran> !
11:57:36 <yitz> paczesiowa: there is an emacs mode for haskell
11:57:56 <EvilTerran> ... there's only one reasonable behaviour, anyway: \f g x -> (f x, g x)
11:58:04 <yitz> it's called haskell-mode
11:58:09 <rwbarton> @. unpl pl \a -> a * b
11:58:09 <lambdac> (\ a -> b * a)
11:58:13 <rwbarton> ^^ ?
11:58:32 <yitz> paczesiowa: if you use emacs for haskell, you really should have that.
11:58:37 <EvilTerran> rwbarton, er, what?
11:59:06 <rwbarton> why does pl think that a * b = b * a?
11:59:26 <yitz> @pl \a b -> a * b
11:59:26 <lambdac> (*)
11:59:32 <yitz> @unpl (*)
11:59:32 <lambdac> (*)
11:59:33 <EvilTerran> i guess whoever wrote it told it that that was the case
11:59:34 <paczesiowa> yitz: I know, but all I get is syntax highlighting - I don't know how to use the rest, I started using emacs 3 days ago
11:59:39 <EvilTerran> ?pl \a b -> b * a
11:59:40 <lambdac> (*)
11:59:48 <EvilTerran> so it could simplify more expressions
12:00:01 <yitz> paczesiowa: use the tab key
12:00:19 <yitz> paczesiowa: and ^J instead of Enter
12:00:38 <Baughn> @pl \a b -> b + a
12:00:39 <lambdac> (+)
12:02:27 <paczesiowa> yitz: that's indentation, right? I don't like it, and it'll be a while before I can modify it to suit my needs. right now typing is hard:)
12:03:19 <camio> @pl \a b -> b - a
12:03:20 <lambdac> subtract
12:03:28 <camio> @pl \a b -> a - b
12:03:28 <lambdac> (-)
12:03:39 <yitz> paczesiowa: if you keep pressing tab, after Enter or after the first tab, it gives you choices. one of them is usually right. even if not, one of them puts you close enough that it's better than getting there by hand.
12:03:40 <EvilTerran> ?src subtract
12:03:40 <lambdac> subtract x y = y - x
12:04:09 <camio> @hoogle subtract
12:04:10 <lambdac> A Hoogle error occured.
12:04:20 <BMeph> ziman: Are you trying to do polar conversion (e.g., Data.Complex.polar)? :)
12:04:27 <EvilTerran> camio, it's in the Prelude
12:04:38 <EvilTerran> i believe it's a method of Num
12:04:41 <paczesiowa> yitz: but I was hoping for showing types for my functions (not only Prelude), tab completion and highliting errors from ghc
12:06:01 <yitz> paczesiowa: it should show you types when you put the cursor on a symbol. It knows about some of the "standard library", and any of your own modules that were imported when you first visited this file.
12:06:08 <byorgey> camio: subtract is there so you can do things like   map (subtract 6) [1..10]
12:06:24 <byorgey> since you can't use section notation like (- 6), which parses as negative six
12:06:31 <EvilTerran> because (- 6) is (0 - 6), not (\x -> x - 6)
12:06:43 <dmhouse> It's actually negate 6, I think.
12:07:07 <noohgodno> > cos (cos (cos (5)))
12:07:08 <yitz> paczesiowa: no tab completion so far afaik. there is a system for interacting with ghc in a shell buffer, but I'm not familiar with it, I prefer just to run ghc in an xterm.
12:07:08 <lambdac>  0.5734897326953653
12:07:15 <dmhouse> Num doesn't guarantee that (0+) = id ;)
12:07:47 <EvilTerran> dmhouse, well, it'll be (fromInteger {-6})
12:08:08 <EvilTerran> where, by {-6}, i mean "actually that value, not just that syntactic form"
12:08:13 <noohgodno> how did the rest of you go about learning this insane language
12:08:20 <EvilTerran> or will it be negate (fromInteger {6})?
12:08:22 <dmhouse> EvilTerran: I'm not sure. I think it might fromInteger (negate 6)
12:08:25 <dmhouse> Or that.
12:08:29 <dmhouse> Err, yeah, not mine.
12:08:40 <dmhouse> ?where report
12:08:41 <lambdac> http://www.haskell.org/onlinereport/
12:08:55 <dmhouse> lambdac: what have you done with lambdabot?!
12:09:03 <sw17ch> noohgodno, i wrote a fairly large application to display reference in a scheme program
12:09:35 <byorgey> noohgodno: it's a long process.  hang out and ask questions in here, read some online tutorials, try writing stuff in Haskell, repeat as necessary
12:09:35 <EvilTerran> dmhouse, she's just subbing in while lambdabot gets some R&R time
12:09:42 <yitz> @vixen lambdac: what have you done with lambdabot?!
12:09:42 <lambdac> why does everyone ask i'f on a bot?
12:09:49 <dmhouse> Hmm, it seems fromInteger (-6) is correct.
12:10:00 <dmhouse> Section 6.4.1 in http://www.haskell.org/onlinereport/basic.html
12:10:02 <lambdac> Title: The Haskell 98 Report: Predefined Types and Classes
12:11:43 <yitz> noohgodno, byorgey: it's a process that's getting shorter and shorter all the time as the amount of good documentation for beginners is quickly growing. asking people who already know haskell isn't really the right question, because much less was available then.
12:12:01 <byorgey> well, that's true.
12:12:09 <noohgodno> ah
12:12:33 <byorgey> but for most people I think it's still going to be a long process, since Haskell allows you to work on such a higher level of abstraction than most mainstream languages.
12:12:55 <EvilTerran> dmhouse, actually, i'm thinking negate (fromInteger 6) is the right one, actually
12:12:57 <vixey> what amazes me is that anybody uses such a great language like haskell
12:13:04 <vixey> usually really good things are not used
12:13:18 <byorgey> in other words, the bar for being a fluent Haskell programmer is much higher than for most other languages, independent of the quality of tutorial materials.
12:13:23 <EvilTerran> dmhouse, seeing as http://www.haskell.org/onlinereport/lexemes.html#lexemes-numeric doesn't mention '-' except for exponents
12:13:23 <lambdac> Title: Haskell 98 Lexical Structure
12:13:36 <yitz> byorgey: I think that it's not harder than other languages, but most people have to unlearn a lot first so that adds a lot of work.
12:14:08 <byorgey> yitz: well, I respectfully disagree =)
12:14:18 <dmhouse> EvilTerran: ah, http://www.haskell.org/onlinereport/exps.html#operators
12:14:19 <lambdac> Title: The Haskell 98 Report: Expressions
12:14:23 <byorgey> although it is true that the unlearning can add some work.
12:14:28 <dmhouse> EvilTerran: The special form -e denotes prefix negation, the only prefix operator in Haskell , and is syntax for negate (e)
12:14:29 <EvilTerran> dmhouse, and unary (-) is defined in http://www.haskell.org/onlinereport/exps.html#operators - it's an operator, not part of a numeric identifier
12:14:30 <lambdac> Title: The Haskell 98 Report: Expressions
12:14:51 <dmhouse> So -6 = negate (-6) = negate (fromInteger 6).
12:15:19 * EvilTerran wishes unary (-) was part of the numeric literal syntax, but that conversation has come up a million times already
12:15:31 * noohgodno nods
12:15:38 <vixey> yeah I would like that
12:15:39 <yitz> byorgey: you don't need to know Caleskell ((.)=fmap, (++)=mappend, etc.) or category theory to use haskell productively in practice. there is a lot of abstract stuff available later on, but you can get very far without it.
12:16:00 <dmhouse> Who needs negative literals anyway?
12:16:18 <yitz> dmhouse: it's traditional
12:16:34 <dmhouse> I'd wager they're so rare that no-one would really care if we were forced to write them as negate n. Unary negation is a mess syntactically.
12:16:35 <vixey> > 3 * -1
12:16:36 <lambdac>      precedence parsing error
12:16:36 <lambdac>         cannot mix `(*)' [infixl 7] and prefix ...
12:16:44 <vixey> > map (-1) [3,5,7]
12:16:45 <noohgodno> it boggles my mind that i can write ASM probably four times as fast as haskell atm
12:16:45 <lambdac>   add an instance declaration for (Num (a -> b))
12:16:47 <vixey> basically broken
12:16:53 <EvilTerran> vixey, my point exactly
12:17:02 <EvilTerran> altho it would mean that (-1) and (- 1) would mean different things
12:17:06 <vixey> noohgodno: Maybe you have more experience with asm
12:17:08 <dmhouse> Ah well, blue-sky thinking at the end of the day.
12:17:10 <byorgey> yitz: well, I guess that's the crux of the issue.  I admit that I have never used Haskell in a 'practical/production' capacity.  My opinion is just coming from the fact that I had to learn those things before I really *felt* like a fluent Haskell programmer.
12:17:18 <byorgey> but it's possible you're right.
12:17:24 <dmhouse> They're never going to get removed from the language, that'd be too backwards-incompatible.
12:17:27 <EvilTerran> noohgodno, but each line of that ASM will only do a 16th of each line of haskell
12:17:35 <noohgodno> i realize
12:17:35 <EvilTerran> *of what each line of haskell can do
12:17:36 <EvilTerran> :P
12:17:46 <vixey> 16th ??
12:17:52 <vixey> I think you can do better than that!
12:18:10 <EvilTerran> vixey, i squared his proportion. it made sense in my head. :P
12:18:43 <yitz> byorgey: I think it's getting quickly easier to learn Haskell because more and more material is going up from a practical POV, rather than for theoretical CS students and researchers.
12:18:54 <trofimovich> @version
12:18:55 <lambdac> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.00GHz)
12:18:55 <lambdac> darcs get http://code.haskell.org/lambdabot
12:19:04 <xif> yitz: such as...?
12:19:47 <byorgey> yitz: I definitely agree with you there.
12:21:51 <yitz> xif: well - Real World Haskell is coming out, and available already (partially) on the web in beta. someone earlier pointed to a sigfpe post with a simple IO how-to (no knowledge of monads required). I would like to see that for other basic monads, like Maybe, State and Error. (List is easy if you think about list comprehensions.) Etc.
12:23:24 <yitz> vixey: if you use dons' fusion stuff, you can get that proportion pretty small.
12:23:37 <xif> yitz: OK. still, note you only mentioned one full-fledged text: Real World Haskell.
12:23:40 <vixey> oh I meant like
12:24:06 <vixey> One page of haskell code is probably -more- than 16 pages of asm
12:25:23 <yitz> xif: yeah that's the simplest book. it's said to be very good. of course, blog posts and wiki posts multiply a lot faster than text books :)
12:26:37 <yitz> vixey: with fusion you cause ghc to compile an entire haskell function down to few lines of asm, in a tight loop.
12:26:50 <vixey> oh ok
12:27:17 <yitz> vixey: so you get the best of both worlds :)
12:27:36 <jsnx> what is a good intro to "writing a multi-threaded tcp server in haskell right now?"
12:28:07 <yitz> jsnx: how about the source code of HApps?
12:28:15 <chrisdone> yitz: ho ho, good one
12:29:41 <jsnx> yitz: you think it is a good intro?
12:29:53 <jsnx> yitz: it is well commented, &c.?
12:30:23 <yitz> jsnx: chrisdone is right, I'm not 100% serious. HApps source is said to be a bit dated, and hard to read. but it really does that. Perhaps you might even use it as a framework rather than writing it yourself.
12:30:49 <mrd-> http://sequence.complete.org/node/258
12:30:51 <lambdac> Title: A simple TCP server | The Haskell Sequence
12:37:51 <noohgodno> time to start flooding hpaste with epic poetry
12:39:29 <Dr_Zooix> Hello
12:39:57 <chrisdone> hey you
12:40:51 <Dr_Zooix> I've got a little problem with the types (I'm a newbie in Haskell), here is the code: http://rafb.net/p/NDlpzj25.html
12:40:52 <lambdac> Title: Nopaste - No description
12:41:21 <Dr_Zooix> I wanna call my function with testType 3.5
12:41:32 <Dr_Zooix> but there is still an error !
12:42:04 <rwbarton> readIO wants a String
12:42:11 <rwbarton> does testType "3.5" work?
12:42:20 <Dr_Zooix> yes it works
12:42:39 <Dr_Zooix> but I wanna call my function without a string as argument
12:43:42 <Dr_Zooix> So how shoul I do please ?
12:43:56 <rwbarton> Uh, use a language other than Haskell?  :)
12:44:14 <rwbarton> I don't understand why you'd want to do that.  Haskell is designed to stop you from making this kind of error
12:44:30 <Dr_Zooix> how do you mean it ?
12:44:34 <byorgey> @type readIO
12:44:36 <lambdac> forall a. (Read a) => String -> IO a
12:44:57 <byorgey> Dr_Zooix: as you can see above, readIO expects a String.  so the only thing you can pass to it is a value of type String.
12:45:30 <mfp> @src readIO
12:45:30 <lambdac> Source not found. Are you on drugs?
12:45:36 <byorgey> Dr_Zooix: stepping back a bit, what is it you're trying to do with your testType function?
12:46:21 <chrisdone> hey ddarius
12:46:33 <Dr_Zooix> byorgey: ok. i wanna that the function tell my the type of an argument
12:46:46 <ddarius> chrisdone: ?
12:46:47 <EvilTerran> why?
12:46:58 <EvilTerran> Dr_Zooix, that's a very odd requirement
12:47:10 <chrisdone> ddarius: just greeting :)
12:47:19 <byorgey> Dr_Zooix: you can't really do that in Haskell.
12:47:36 <byorgey> Dr_Zooix: however, if you run ghci, you can use the :type command to tell you the type of things at the prompt
12:47:49 <Dr_Zooix> byorgey: is it because Haskell is strongly typed ?
12:47:55 <EvilTerran> Dr_Zooix, seeing as types are compile-time things in haskell, there's very rarely any need to know the type of anything at runtime, yes
12:47:59 <byorgey> Dr_Zooix: yes, exactly.
12:48:13 <Dr_Zooix> byorgey: Ok, it is like in OCaml ;)
12:48:24 <byorgey> Dr_Zooix: right =)
12:48:31 <EvilTerran> Dr_Zooix, if you want a function which does different things based on the type of one of its parameters (or even its return value's type), you can use a typeclass
12:49:35 <Dr_Zooix> EvilTerran, can you passe me a lonk whit more infos about the typeclass please ?
12:49:46 <bolom> hello ...i've a small quick question
12:50:14 <jsnx> bolom: proceed
12:50:16 <Toxaris> bolom: hello, we have some answers here, so feel free to ask
12:50:36 <bolom> when using show mystring, it'll "re-escape" escaped characters instead of showing their counterpart
12:50:58 <Dr_Zooix> EvilTerran, no it is ok so, I've found something in French
12:51:17 <jsnx> > show "\n"
12:51:17 <bolom> ...i.e show "\t\n" becomes "\"\\t\\n\"" instead of a tab and a new line
12:51:18 <lambdac>  "\"\\n\""
12:51:41 <Toxaris> bolom: well, that's the purpose of show
12:51:43 <joey_> bolom: Maybe you want putStr
12:51:47 <|Steve|> > showString "\t\n"
12:51:48 <lambdac>  <[Char] -> [Char]>
12:51:52 <tibbe> should I use Ptr a to represent a C void * in the FFI?
12:52:18 <bolom> showString should do it ...let me try quickly
12:52:31 <byorgey> no, showString will escape them too
12:52:45 <jsnx> bolom: informally, show is supposed to create a string that can be read to get the original string
12:52:47 <Dr_Zooix> I think that putStrLn do it, no ?
12:52:53 <Toxaris> > showString "no difference\t" "over here"
12:52:54 <lambdac>  "no difference\tover here"
12:52:56 <jsnx> or rather, the original thing
12:53:51 <byorgey> bolom: sounds like you want putStr or putStrLn as joey_ and Dr_Zooix suggest
12:54:16 <bolom> and how to show things while transforming escaped characters into what they mean?
12:54:17 <Dr_Zooix> +1
12:54:20 <Toxaris> actually, (\x -> showString x "") == id
12:54:46 <Toxaris> bolom: you mean foo "\\t" = "\t"?
12:54:54 <EvilTerran> Toxaris, er, so showString = (++)?
12:55:00 <Toxaris> bolom: or putStrLn "\t" -- prints a tab character
12:55:03 <Toxaris> :t showString
12:55:04 <lambdac> String -> String -> String
12:55:09 <EvilTerran> ?src showString
12:55:09 <lambdac> Source not found. You speak an infinite deal of nothing
12:55:13 <bolom> putStr is IO ...i just need String -> String
12:55:17 <Toxaris> EvilTerran: guess so, given that it is to be used with difference lists
12:55:21 <bolom> (seems odd , i know)
12:55:26 <EvilTerran> bolom, er, i don't follow
12:55:34 <EvilTerran> you want to go from a String to a String... without changing anything?
12:55:53 <Toxaris> > id "just my string\nsecond line"
12:55:54 <lambdac>  "just my string\nsecond line"
12:55:59 <chrisdone> maybe he has multiple datatypes which he is showing but doesn't want a string to be escaped
12:56:10 <bolom> ...exactly!
12:56:27 <bolom> i instancied Show to be "showable"
12:56:47 <bolom> ...and on one part, i apply it on strings
12:57:01 <bolom> ...but these get escaped
12:57:06 <rwbarton> Just don't apply show then.
12:57:24 <bolom> ...so i guess i'll have to decouple this in two parts anyway
12:57:27 <EvilTerran> bolom, do bear in mind that "show" is meant to produce a string that is a valid haskell expression representing the value passed to "show", according to the report
12:57:44 <byorgey> bolom: what I would suggest is making your own 'Pretty' type class
12:57:58 <byorgey> with a 'pprint' method or something like that
12:58:10 <byorgey> then for most types you can say  instance Pretty Foo where pprint = show
12:58:19 <byorgey> but for String you can say instance Pretty String where pprint = id
12:58:26 <byorgey> would that work for what you are trying to do?
12:58:41 <bolom> yup
12:58:44 <Heffalump> anyone built GHC HEAD recently?
12:58:57 <chrisdone> is it possible to declare an instance for all types of another instance?
12:59:10 <Heffalump> chrisdone: yes, with overlapping instances.
12:59:11 <chrisdone> like class Show a => Pretty a where pprint = show
12:59:23 <Heffalump> just do instance Show a => Pretty a
12:59:35 <Heffalump> but they do make typechecking more complicated and cause confusing error messages sometimes
12:59:52 <chrisdone> ah
12:59:56 <waern> Heffalump: I have
13:00:28 <Heffalump> I keep getting stuck, first on the existence of libraries/bootstrapping, and when I remove that, Exception.onException not being in scope.
13:00:42 <Heffalump> I understand the build system has been changing a lot lately, has the README kept up?
13:01:30 <waern> hmm, I didn't get those problems, but my repository is a few days old
13:01:46 <waern> though I think I have onException
13:01:55 <Heffalump> I've been getting similar problems for several days
13:02:12 <Heffalump> I'm just doing sh boot ; ./configure (options) ; make
13:02:20 <tibbe> @seen dons
13:02:20 <lambdac> dons is in #haskell. I last heard dons speak 1h 12m 32s ago.
13:02:35 <waern> Heffalump, me too
13:02:50 <waern> maybe I was lucky :)
13:02:56 <Heffalump> hmm. perhaps it just doesn't like me :-) I can't even make clean cos something else goes wrong
13:02:57 <Quadrescence> What would be the easiest way to parse a file which would have a fixed number of sections, an arbitrary number of key/value (where the value is an array) pairs, and another section has an arbitrary number of subsections, and each subsection has a number of key/value pairs equal to the number of key/value pairs in the last section
13:03:22 * Heffalump considers pulling into a fresh tree
13:03:32 <Quadrescence> (It sounds complicated, but it's not, really.)
13:04:57 <Toxaris> Quadrescence: I guess the easiest way would be to write a PArser?
13:05:15 <Quadrescence> Toxaris: I suppose so, but earlier, people said that's the last thing I should do.
13:05:15 <Toxaris> Quadrescence: or what is exactly your question? ;)
13:05:26 <tromp> > ()
13:05:27 <lambdac>  ()
13:06:09 <Toxaris> Quadrescence: of course, writing a Parser normally means using a Parser Combinator library, e.g. Parsec, in Haskell
13:06:33 <Quadrescence> Toxaris: I have my own format for a "configuration file"/"definition file"/whatever you want to call it. I could easy change it for other things -- but I could only change the syntax, not the "layout".
13:07:10 <Quadrescence> Toxaris: Would you mind looking at my file and seeing what might be a viable solution?
13:07:17 <Quadrescence> (a sample of my definition file)
13:07:32 <Toxaris> Quadrescence: you can hpaste it: hpaste.org
13:07:58 <ski> (Quadrescence : no, people said inventing a new format was the last thing you should do ..)
13:08:25 <Pudding> hey all
13:08:33 <Pudding> I need some help in interpreting some haskell code
13:08:47 <Pudding> anyone wants to help a complete haskell newbie?
13:08:57 <Toxaris> Quadrescence: if you decide upon the layout, you could (1) reuse same existing format (e.g. XML, CSV, JSON, s-expressions, ...) or (2) make it so simple that you can parse it with ByteStrings.lines and ByteStrings.split
13:09:20 <ski> @paste
13:09:20 <lambdac> Haskell pastebin: http://hpaste.org/new
13:09:29 <ski> Pudding : you could paste it there ^
13:09:30 <Toxaris> Pudding: do {paste code at hpaste.org; ask questions in #haskell; be helped}
13:10:35 <dmhouse> Toxaris, which transforms under ?pl to fix (my code), right?
13:10:38 * ski imagines a televangelist screaming "be helped !"
13:11:32 <Quadrescence> Toxaris: http://nopaste.com/p/ap0ozFjkv
13:11:49 <Quadrescence> The #'s, if you don't notice, are just some of my comments.
13:12:09 <Pudding> http://hpaste.org/9552?lines=true     How should I understand the code between the square brackets correctly?
13:12:41 <Toxaris> Avoid the danger of the Null Pointer Exception. Don't give in to the false promises of mutable state. There is a lambda for everyone, but you are not alone. #haskell is with you. Be purified. Be safed. Join the higher-order.
13:13:24 <Quadrescence> Toxaris: And, also, the -P and -O could be put into pairs like [(P,O)] (e.g., [(1,0),(2,0),(3,0)...] for the Corners)
13:13:27 <Peaker> Haskell makes the denotational semantics clear. Imperative languages make the operational semantics clear...
13:13:30 <ski> Pudding : `[fibs !! i + fibs !! (i+1) | i <- [0..]]' means : collect values of `fibs !! i + fibs !! (i+1)' into a list, for every `i' in `[0..]'
13:13:49 <antirobotrobot> is IO in haskell blocking?
13:13:52 <ski> > [x*x | x <- [0..]]
13:13:53 <lambdac>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
13:14:37 <stepcut> antirobotrobot: no, but some functions in IO are blocking
13:14:39 <ski> Toxaris : did you just invent that ?
13:15:20 <chrisdone> ski: heh, reminds me of lojban. "help yourself" "ko sidju ko" "be a helper of you", or "ko kurji ko" "be a carer of yourself/look after yourself" >_>
13:15:30 <Toxaris> ski: yeah
13:15:35 <antirobotrobot> stepcut: for example, putStrLn? I guess it's blocking?
13:15:53 <Pudding> so it basically just makes a list. In the left side it says the function to calculate an element of the list and in the right it gives some sort of rule for what will be the next element?
13:15:55 <stepcut> antirobotrobot: yes
13:16:16 <stepcut> antirobotrobot: but, return 1 :: IO Int, would not be
13:16:20 <Toxaris> @hoogle Blocking
13:16:20 <lambdac> A Hoogle error occured.
13:16:22 <ski> Pudding : roughly, yes
13:16:23 <Toxaris> :(
13:16:39 <Pudding> yeah, I suck at explaining. Thanks, ski :)
13:17:07 <stulli> > do "12"; "34"; "56"
13:17:07 * stepcut ponders for a minute
13:17:08 <lambdac>  "56565656"
13:17:09 <ski> Pudding : of course, it is not very good to index into lists ..
13:17:22 <stulli> hm, can somebody explain this?
13:17:29 <ski> stulli : it's the list monad
13:17:46 <stulli> I know about it and it behaves like list comprehension
13:18:01 <stulli> But i still dont get it :(
13:18:22 <Toxaris> @undo  do "12"; "34"; "56" -- stulli: your do expression is equivalent to this
13:18:22 <lambdac> "12" >> "34" >> "56"
13:18:32 <ski> > [z | x <- "12", y <- "34", z <- "56"]  -- is the same
13:18:33 <lambdac>  "56565656"
13:18:40 <Toxaris> @src [] >>
13:18:40 <lambdac> Source not found. Maybe you made a typo?
13:18:53 <Toxaris> @src >> []
13:18:53 <lambdac> Source not found. Just what do you think you're doing Dave?
13:18:55 <Toxaris> :(
13:19:02 <Toxaris> stulli: and >> in the list monad is ++
13:19:12 <Toxaris> hmm
13:19:13 <ski> no
13:19:15 <EvilTerran> Toxaris, um, no...
13:19:16 <Toxaris> no nonsense
13:19:22 <Toxaris> second try
13:19:23 <EvilTerran> >>= is flip concatMap
13:19:40 <thoughtpolice> has anybody tried to build hsgnutls on OS X?
13:19:46 <thoughtpolice> i'm getting strange c2hs errs
13:20:42 <Toxaris> stulli: and >> in the list monad is ignoring the values in the list on the left, but still evaluating and concatenating the stuff on the right hand side again for each element on the left
13:21:18 <Toxaris> EvilTerran: hey, I *tried* to look up the src first, but lambdac wouldn't help me :(
13:21:26 <EvilTerran> ?src [] >>=
13:21:26 <lambdac> Source not found. Where did you learn to type?
13:21:30 <EvilTerran> um
13:21:33 <EvilTerran> ?src [] (>>=)
13:21:33 <lambdac> xs >>= f     = concatMap f xs
13:21:37 <EvilTerran> ?src (>>)
13:21:37 <lambdac> m >> k      = m >>= \_ -> k
13:21:42 <Peaker> stulli: A list comprehension can be seen as syntax sugar over the "do" form, which itself is syntax sugar over use of >>= and >> operators
13:21:45 <jleedev> > "hello" >> "world"
13:21:46 <EvilTerran> there is no source for >> for []
13:21:46 <lambdac>  "worldworldworldworldworld"
13:22:11 <Toxaris> > "hello" <|> " world" -- but there is a cool name for ++, too
13:22:12 <lambdac>  "hello world"
13:22:23 <r3m0t> ?src (<|>)
13:22:23 <lambdac> Source not found. stty: unknown mode: doofus
13:22:26 <jleedev> ?type (<|>)
13:22:28 <lambdac> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
13:22:33 <EvilTerran> it's a method of Alternative
13:22:35 <Toxaris> @src [] (<|>)
13:22:35 <lambdac> (<|>) = (++)
13:22:39 <EvilTerran> so its implementation will vary
13:22:45 <Toxaris> @src Maybe (<|>)
13:22:45 <lambdac> Nothing <|> p = p
13:22:45 <lambdac> Just x  <|> _ = Just x
13:22:56 <EvilTerran> ?src Either (<|>)
13:22:57 <lambdac> Source not found. I've seen penguins that can type better than that.
13:22:58 <stulli> Thanks for explaining everybody, i understand now. The >> confused me
13:23:03 <jleedev> "A monoid on applicative functors." got it
13:23:13 <Toxaris> @src (Either a) (<|>) --?
13:23:14 <lambdac> Source not found. Just try something else.
13:24:04 <jleedev> ?src Either mplus
13:24:04 <lambdac> Left _ `mplus` n = n
13:24:05 <lambdac> m      `mplus` _ = m
13:24:06 <ski> jleedev : easy to say, when you already know the terms involved ..
13:24:34 <Toxaris> <|> is not a monoid on applicative functors
13:25:28 <Toxaris> it's (part of) a monoid on the target type of some applicative functors, or something :)
13:25:46 <Toxaris> > [] <|> Maybe -- doesn't work
13:25:47 <lambdac>   Not in scope: data constructor `Maybe'
13:26:30 <Toxaris> @kind [] `Either` Maybe -- that is a monoid on applicative functors
13:26:31 <lambdac>     `[]' is not applied to enough type arguments
13:26:31 <lambdac>     Expected kind `*', but `[]' has kind `* -> *'
13:26:45 <Toxaris> hmm no it's not
13:27:01 <dmhouse> Either :: * -> * -> *
13:27:12 <rwbarton> It's some kind of "weak monoid"
13:27:18 <dmhouse> You can't pass it things of type * -> *.
13:27:18 <jleedev> Toxaris: tell that to http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#Alternative
13:27:20 <lambdac> Title: Haskell Code by HsColour, http://tinyurl.com/5avvxt
13:27:30 <Toxaris> but data Coproduct f g x = In1 (f x) | In2 (g x) is
13:27:59 <Toxaris> with data Zero (no constructors) as identity element :)
13:28:09 <ski> the monoid being referred to was on `m a', for arbitrary `a' and `Applicative m'
13:28:15 <Heffalump> waern: gah, it happens with a fresh get (from my local repo) too :-(
13:28:45 <waern> Heffalump: hmm, ok
13:28:45 <jleedev> haskell has as many control structures as python has web frameworks
13:28:59 <Toxaris> dmhouse: yeah realized myself.
13:29:02 <waern> Sat Aug  9 02:20:51 CEST 2008  Tim Chevalier <chevalier@alum.wellesley.edu>
13:29:02 <waern>   * Fixed performance bug in ext-core preprocessor
13:29:06 <ski> i believe what what Toxaris was after was a monoid on `m' itself ..
13:29:10 <waern> ^^ the latest patch in my repo
13:29:46 <Toxaris> ski: that's how "a monoid on applicative functors" parse for me
13:30:14 <Toxaris> the documentation should be changed to "applicative functors which yield monoids"
13:30:18 <ski> like `0 : 1~ a -> m a', `(+) : m a * m a -> m a'
13:30:24 <ski> s/~//
13:30:38 <ski> Toxaris : strictly, yes
13:30:59 <ski> hm
13:31:06 <Toxaris> I think it is very important to use different words for m and m a, since the are totally different things
13:31:17 <Toxaris> nobody would say "hello" is a string function
13:31:24 <EvilTerran> yes it is! :P
13:31:29 <EvilTerran> just one that takes no parameters
13:31:33 <ski> Toxaris : some would :(
13:31:45 <Toxaris> but too many people say (IO Int) is a monad
13:31:46 <EvilTerran> (i wouldn't actually say that, i'm just playing devil's advocate)
13:32:03 <rwbarton> I think the documentation is saying an applicative functor is a monoid on applicative functors, which is a little awkward but not really wrong
13:32:10 <Toxaris> EvilTerran: hehe. not that discussion again
13:32:32 <ski> Toxaris : i think it is more common to say `x' is a monad, where `x :: IO Int'
13:32:43 <dmhouse> That's nonsensical.
13:32:47 <ski> yes
13:32:58 <ski> but i've heard it nonetheless
13:33:09 <dmhouse> "x is monadic", perhaps.
13:33:20 <dmhouse> "hello" being a string function is correct, IMO. Confusing, but correct.
13:33:28 <Toxaris> EvilTerran: my point of view is that in Haskell, we have values. some are monomorphic functions and take exactly one argument, and some are monomorphic but not functions and take exactly zero arguments, and some are polymorphic and take exactly one type argument.
13:33:42 <dmhouse> IO Int being a monad is just wrong. Monads take a type parameter, see the class definition.
13:33:49 <ddarius> ski: You've not heard it from too many experienced people.
13:34:00 <ski> right
13:34:06 <Toxaris> dmhouse: so explain the documentation of class Alternative
13:34:06 <Peaker> IO Int is a "monadic value"?
13:34:24 <ski> `monadic action' is also fine
13:34:26 <EvilTerran> Peaker, well, it's the type of a monadic value
13:34:37 <Toxaris> Peaker: I would call it an IO action
13:34:44 <jleedev> > "hello" >>= (:) <*> (:[])
13:34:45 <lambdac>  "hheelllloo"
13:34:46 <ski> (if you meant to refer to a value of that type, indeed)
13:34:59 <Toxaris> Peaker: would you say that "hello" is a monadic value, or would you call it a string?
13:35:21 <dmhouse> Toxaris: which bit?
13:35:22 <Toxaris> Peaker: yet "hello" is exactly as strongly connect to monads as IO Int
13:35:33 <ski> Toxaris : i'd call it a monadic value, in some contexts
13:35:45 <Toxaris> dmhouse: "A monoid on applicative functors.
13:35:45 <Toxaris> "
13:35:47 <rwbarton> dmhouse: An alternative functor is a monoid object in the category of applicative functors with the cartesian product
13:35:55 <dmhouse> Toxaris: oh, right.
13:35:58 <tromp> > "hello" >>= return
13:35:59 <lambdac>  "hello"
13:36:10 <tromp> looks monadic:)
13:36:19 <Heffalump> > "hello" >>= "world"
13:36:20 <lambdac>  Couldn't match expected type `Char -> [b]'
13:36:22 <tromp> () >>= return
13:36:23 <Peaker> Toxaris: "hello" is both :)
13:36:24 <Heffalump> > "hello" >> "world"
13:36:25 <lambdac>  "worldworldworldworldworld"
13:36:39 <dmhouse> Toxaris: agreed, that's bad.
13:36:42 <tromp> > () >>= return
13:36:42 <lambdac>  Couldn't match expected type `m a' against inferred type `()'
13:36:53 <tromp> looks not so monadic
13:37:15 <BMeph> Toxaris: 'on' in the same sense of being "on" a bus or plane. Or would that be a bad phrasing, too? :)
13:37:24 <ski>     show (Sudoku rows) = do
13:37:27 <ski>       row <- rows
13:37:29 <ski>       (do cell <- row
13:37:32 <ski>                                                                                                                                  
13:37:34 <tromp> > const () >>= return
13:37:34 <lambdac>  Add a type signature
13:37:35 <ski>           maybe "." ((:[]) . intToDigit) cell
13:37:37 <ski>                   
13:37:40 <ski>                                                                         
13:37:40 <BMeph> I.e., using 'on' in the way we think of 'in'.
13:37:42 <ski>        `mplus`
13:37:45 <ski>                                                                                                                                     
13:37:46 <dmhouse> ski: argh! C-c! C-c!
13:37:48 <ski>        do "\n")
13:38:05 <ski> oops, sorry
13:39:18 <Peaker> @type maybe
13:39:18 <Toxaris> BMeph: imho "monoid on applicative functors" unambiguously means a monoid (AF, op, u) with AF = set of applicative functors, but Alternative is something else.
13:39:20 <lambdac> forall b a. b -> (a -> b) -> Maybe a -> b
13:39:45 <Peaker> maybe extracts a value out of a maybe, with a default?
13:39:59 <dmhouse> Peaker: yep.
13:40:04 <EvilTerran> ?src maybe
13:40:04 <lambdac> maybe n _ Nothing  = n
13:40:04 <lambdac> maybe _ f (Just x) = f x
13:40:08 <BMeph> Peaker: You got it. :)
13:40:26 <dmhouse> Peaker: well, it allows you to apply a function to a Maybe value, with a default.
13:40:35 <dmhouse> Peaker: if you pass it id, you get fromMaybe.
13:40:36 <chrisdone> I have a string which I can see but when I append it to something I cannot. ~_~
13:40:39 <dmhouse> ?hoogle fromMaybe
13:40:39 <lambdac> A Hoogle error occured.
13:40:40 <Peaker> but it also applies a function to it.. why not:  maybe :: a -> Maybe a -> a ?
13:40:49 <dmhouse> ?type fromMaybe
13:40:51 <lambdac> forall a. a -> Maybe a -> a
13:40:56 <Peaker> ah :)
13:41:13 <dmhouse> Peaker: maybe has nice theoretical properties.
13:41:26 <ski> @type fromLeft
13:41:27 <lambdac> Not in scope: `fromLeft'
13:41:40 <Peaker> dmhouse: I am trying to see why it is better than ($) . fromMaybe -- the main advantage is not having to have the function apply in the default case
13:41:59 <EvilTerran> Peaker, "maybe" is a more fundamental operation
13:42:00 <BMeph> chrisdone: What's the 'something' you mention? :)
13:42:11 <Peaker> EvilTerran: How come?
13:42:24 <dmhouse> maybe is the catamorphism on Maybe, just as either is it on Either and foldr is it on lists.
13:42:27 <Peaker> EvilTerran: Because its more general?
13:42:27 <EvilTerran> "maybe" and "either" are (kinda) catamorphisms for the relevant type
13:42:36 <Peaker> EvilTerran: I don't know what that is :)
13:42:42 <EvilTerran> like foldr for lists
13:42:48 <rwbarton> Peaker: You can write id in terms of maybe, but not in terms of fromMaybe
13:42:52 <dmhouse> foldr f z replaces (:) with f and [] with z.
13:42:56 <chrisdone> BMeph: when I remove the ("/login/"++) part, it appears in the source code of my web page, but with it, it only shows the other string: http://hpaste.org/9553
13:43:01 <EvilTerran> Peaker, the shape of the function follows directly from the data decleration
13:43:06 <dmhouse> maybe f a replaces Just with f and Nothing with a.
13:43:10 <dmhouse> Similarly for Either.
13:43:12 <chrisdone> BMeph: not sure how to produce an isolated test case for this
13:43:29 <BMeph> And if it weren't for those pesky imperative language control structures, we'd write if in t-f-pred order... ;)
13:43:31 <dmhouse> (Err, swap the parameters to Maybe there.)
13:43:37 <dmhouse> *maybe
13:43:44 <Peaker> EvilTerran: how does it follow?
13:43:49 <BMeph> Or maybe f-t-pred.
13:44:37 <EvilTerran> data Maybe a = Nothing | Just a
13:44:42 <BMeph> s/maybe/rather,/
13:45:07 <EvilTerran> writing this in GADT notation, "data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a"
13:45:18 <EvilTerran> replace (Maybe a) with b throughout
13:45:20 <chrisdone> BMeph: bit convoluted that code paste.. I'll try to break it down into individual parts
13:45:23 <Toxaris> Peaker: compare the type of the arguments of maybe, foldr, either with the type of the data constructors of Maybe, [], Either
13:45:33 <EvilTerran> and there's the types ofthe parameters to the catamorphism
13:45:44 <ski> BMeph : `t',`f' ?
13:45:49 <rwbarton> Peaker: consider that you can tell whether a value of type Maybe a is Nothing using maybe, but not using fromMaybe
13:45:59 <EvilTerran> from Nothing :: Maybe a, you get a parameter ::b, and from Just :: a -> Maybe a, you get a parameter ::a->b
13:46:28 <dmhouse> Anyway, the important point is that type Maybe' a = forall b. a -> (a -> b) -> b is isomorphic to Maybe a, I think.
13:46:29 <Peaker> EvilTerran: cool
13:46:40 <EvilTerran> similarly, for "data List a where Cons :: a -> List a -> List a; Nil :: List a"
13:46:51 <BMeph> ski: t = "The value that results from the True constructor"; f = "The value that results from the False constructor"
13:46:55 <dmhouse> You get nothing z f = f z; just a _ f = f a.
13:46:58 <EvilTerran> you get two parameters to the catamorphism, of types (a -> b -> b) and (b)
13:46:59 <dmhouse> Hmm, that doesn't seem quite right.
13:47:23 <EvilTerran> and the catamorphism implementation follows naturally from the type
13:47:32 <BMeph> ski: I.e., bool f _ False = f; bool _ t True = t
13:47:34 <ski> BMeph : hm, i still don't see what `t-f-pred order' is, then ..
13:48:19 <BMeph> ski: t-f-pred order, is: bool t f pred = ...; f-t-pred order is: bool f t pred =...
13:48:20 <EvilTerran> ski, the "if true" value, then the "if false" value, then the predicate
13:48:42 <ski> o.o
13:48:47 <ski> `predicate' ?
13:48:53 <chrisdone> λ-calculus booleans?
13:48:55 * ski understands nothing
13:48:57 <EvilTerran> something of type Bool
13:49:00 <EvilTerran> a predicate
13:49:10 <ski> oh
13:49:39 <antirobotrobot> what's a good document for reading about "import ccall safe"
13:49:45 <ski> (when i hear `predicate' i think `... -> Bool' .. note the `->')
13:49:50 <EvilTerran> true
13:50:10 <EvilTerran> that's a good point - blame BMeph, he's the one who called the parameter "pred"#
13:50:12 <EvilTerran> :P
13:50:16 <chrisdone> TRUE=λx.λy.x,FALSE=λx.λy.y,IF=λf.λs.λe.e (f s)
13:50:40 <ski> hm, maybe you should have `if ... else ... then ...' ?
13:50:45 <ski> s/you/we/
13:51:11 <mauke> antirobotrobot: the FFI addendum
13:51:38 <mauke> @where ffi
13:51:52 <ski> chrisdone : s/e (f s)/e f s/
13:52:02 <ddarius> IF = id
13:52:15 <mauke> @bot
13:52:25 <ddarius> Well I guess that doesn't have the same argument order.
13:52:30 <chrisdone> ski: I don't think so
13:52:34 <mauke> preflex: ? ffi
13:52:34 <preflex>  http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
13:52:45 <thoughtpolice> lambdabot was killed earlier due to taking excessive amounts of memory on c.h.o
13:53:03 <chrisdone> ski: it should be (f s) e, I think
13:53:17 <ski> chrisdone : that's what i said ! :)
13:53:24 <lambdac> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:53:24 <lambdac> :)
13:53:26 <lambdac> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ...
13:53:31 <ski> er, no i didn't
13:53:32 <chrisdone> ski: what you said is (e f) s
13:53:36 <ski> right
13:53:38 <chrisdone> hehe
13:53:52 <ski> chrisdone : i was assuming your boolean was the `e' argument
13:54:00 <Toxaris> BMeph: given the type of maybe, either and foldr, I don't see your point
13:54:00 <chrisdone> ski: ah, I see =]
13:54:02 <yitz> dmhouse: how about forall b . a -> b -> (a -> b) -> b
13:54:07 <ski> chrisdone : so ddarius was right, after all :)
13:55:28 <BMeph> Toxaris: you mean about bool :: b -> b -> Bool -> b ? :)
13:55:36 <chrisdone> ski: I must write out λ's at any oppourtunity :P
13:55:55 <chrisdone> BMeph: nice for partial application
13:56:11 * ski wonders if Yoneda can be squeezed in somewhere here
13:56:44 <Toxaris> BMeph: ohh I had read "write it in" instead of "write if in" in your first message about whatever-order
13:56:49 <Toxaris> BMeph: I'm sorry :)
13:57:05 <rwbarton> Yoneda is just the fact that if data X a = X a, then X a is the same as (a -> b) -> b
13:58:02 <chrisdone> mmk
13:58:25 <Toxaris> but isn't pred-f-t better because now if :: ADT-Encoding -> Church Encoding, which seems like a sensible type
13:59:29 <rwbarton> So yes, it's the same catamorphism thing in an even simpler case
14:00:06 <Toxaris> I think the current argument order of the various folds is good for pointfree style, but for pointfull style, it would be good to have the "continuations" at the end of the argument list
14:00:30 <gbacon> @karma+ λ
14:00:30 <lambdac> λ's karma raised to 1.
14:01:01 <BMeph> Toxaris: But isn't 'if' written "in pred-t-f' style, anyway? :)
14:01:32 <chrisdone> gbacon :)
14:01:45 <Toxaris> BMeph: :)
14:02:14 <Toxaris> BMeph: yeah I guess for pref-t-f-style, we have if and pattern matching
14:02:36 <ski> itym guards
14:02:57 <BMeph> Toxaris: "The continuations"? What style is that? :)
14:03:07 <Toxaris> @type maybe
14:03:08 <lambdac> forall b a. b -> (a -> b) -> Maybe a -> b
14:03:18 <trofimovich> @src maybe
14:03:18 <lambdac> maybe n _ Nothing  = n
14:03:18 <lambdac> maybe _ f (Just x) = f x
14:03:34 <ski> `b' and `a -> b' is types of the continuations, there
14:03:46 <Toxaris> indeed
14:03:50 <ski> similarly for `foldr' (except thats' composable comtinuations)
14:04:15 <BMeph> Ah. Hm... That would be an odd-looking fold sig, though...
14:04:24 <ski> @type foldr
14:04:26 <lambdac> forall a b. (a -> b -> b) -> b -> [a] -> b
14:04:42 * Toxaris enjoyed several great talks about continuations today, including one from Oleg, so he cannot stop thinking in terms of them
14:04:53 <BMeph> foldr :: [a] -> b -> (a -> b -> b) -> b
14:05:14 <CosmicRay> @hoogle put
14:05:15 <lambdac> A Hoogle error occured.
14:05:17 <CosmicRay> bah
14:05:29 <ski> cata xs0 of { [] -> nil ; x:acc -> cons x acc }  =  foldr cons nil xs0
14:05:31 <BMeph> Trying out that " it would be good to have the "continuations" at the end of the argument list" concept... :)
14:05:38 <trofimovich> @hoogle m a -> m b
14:05:38 <ski> edwardk had that syntax
14:05:38 <lambdac> A Hoogle error occured.
14:06:06 <ski> (well, maybe not exactly that concrete one, but something similar)
14:06:31 <Peaker> hoogle fails pretty badly on   m a -> m b
14:06:40 <yitz> dmhouse: maybeToMaybe' x = \ y f -> maybe y f x; maybe'ToMaybe f = f Nothing Just
14:06:41 <Toxaris> well foldr is not patten matching on lists, of course, because of the recursion
14:06:51 <Toxaris> @hoogle everything
14:06:51 <lambdac> A Hoogle error occured.
14:06:52 <Peaker> it even fails with "Functor m => m a -> m b"
14:06:59 <Toxaris> @hoogle very simple
14:06:59 <lambdac> A Hoogle error occured.
14:07:02 <Peaker> (I am talking about haskell.org/hoogle)
14:07:05 <dmhouse> Peaker: have you tries the Hoogle 4 beta?
14:07:14 <Peaker> dmhouse: nope
14:07:18 <rwbarton> hoogle 4 finds fmap first
14:07:19 <Quadrescence> Is there a char representing a space? ' '?
14:07:39 <dmhouse> Quadrescence: yes, ' '.
14:07:43 <Quadrescence> Thanks.
14:07:50 <Toxaris> Peaker: what do you expect for (m a -> m b)?
14:08:06 <Peaker> Toxaris: fmap, ap
14:08:21 <Peaker> Toxaris: especially with the class context hints
14:08:46 <Toxaris> is hoogle "class context hint" aware nowadays?
14:08:49 <rwbarton> hoogle4++
14:08:55 <ski> @type GHC.Base.build
14:08:57 <lambdac> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
14:09:02 <rwbarton> Toxaris: Yes
14:09:12 <rwbarton> Toxaris: Or at least, it seems to be to me
14:09:21 <lelf> > generalCategory ' '
14:09:22 <lambdac>  Space
14:09:23 * Peaker wants a hoogle-based desktop.  Select a music file, press "hoogle" key, show me what actions I can apply to it :)
14:09:38 <Toxaris> Peaker: my windows context menu does that
14:10:23 <trofimovich> :]
14:10:25 <Peaker> Toxaris: its far from complete, and cannot handle something like: a -> b -- show me what can convert this to that
14:10:30 <chrisdone> Music a => a -> IO ()
14:10:43 <Peaker> s/Music/Audio ? :-)
14:11:00 <chrisdone> class Audio a => Music a
14:11:00 <chrisdone> :P
14:11:34 <Toxaris> Peaker: yeah, that would be cool. but then all applications would have to register their services, which sounds kind of scary
14:11:46 <chrisdone> where downloadLyrics :: IO String .. yeah .. I'll end the joke here
14:11:57 <Peaker> Toxaris: I want a big Haskell desktop, without "applications". Just TV's :)
14:12:03 <trofimovich> they'd have haddocable sources?
14:12:08 <Toxaris> rwbarton: I agree, and my command-line hoogle actually return sensible results for queries with contexts
14:12:15 <trofimovich> s/have/have to have/
14:12:57 <ski> > endoFunctorCategory '*'
14:12:57 <lambdac>   Not in scope: `endoFunctorCategory'
14:13:20 <Toxaris> hmm yes, who needs main :: IO when she can use main :: Audio a => a -> MP3
14:13:43 <Toxaris> one could use djinn to compose typical tasks
14:14:09 <Toxaris> maybe djinn composed with a path search in the hoogle database
14:14:21 <BMeph> Yes, it's much better having applications, whose use no one knows... ;)
14:15:03 <Toxaris> the problem with a centralized approach is that it is centralized
14:15:16 <ski> > True
14:15:17 <lambdac>  True
14:15:34 <litb> hello all
14:15:36 * BMeph contemplates defining 'fold' more like a dual to 'build'
14:15:39 <roconnor> hi
14:15:40 <eu-prleu-peupeu> hello people from haskell
14:15:45 <litb> does yi use a rope for the content?
14:15:47 <roconnor> hi
14:15:52 <eu-prleu-peupeu> have you guys read the larrabee architecture paper ?
14:15:56 <trofimovich> @type quickCheck
14:15:58 <lambdac> forall a. (Testable a) => a -> IO ()
14:16:04 <ski> BMeph : s/dual/inverse/
14:16:07 <trofimovich> @src Testable
14:16:07 <lambdac> Source not found. This mission is too important for me to allow you to jeopardize it.
14:16:07 <eu-prleu-peupeu> ﻿check it if you haven't: http://softwarecommunity.intel.com/UserFiles/en-us/File/larrabee_manycore.pdf
14:16:09 <lambdac> http://tinyurl.com/6qw9wh
14:16:12 <Peaker> Toxaris: you explicitly "install" things by pulling them, via your UI, into your database, so you might say its not really "centralized" but explicitly indexed?
14:16:15 * roconnor is intersted in the answer to litb's question
14:16:20 <eu-prleu-peupeu> i was wondering how haskell would fit in larrabee :)
14:17:00 <Toxaris> Peaker: but such a strongly typed, rich index seems to need central administration of some kind
14:17:10 <Toxaris> Peaker: e.g., a central standard library in the case of Haskell
14:17:37 <BMeph> ski: Ah, yes - good catch, thanks. :)
14:17:57 <Toxaris> Peaker: what would be the "common set of types" for the Haskell Desktop? who would define it?
14:18:22 <Peaker> Toxaris: ah - but that you already have and is considered a positive thing with KDE and Gnome
14:18:59 <Toxaris> but running KDE or Gnome doesn't mean I cannot run other applications?
14:19:08 <Toxaris> (or does it, me has no real clue)
14:19:16 <Peaker> Toxaris: I think pretty quickly you wouldn't want to :)
14:19:40 <Toxaris> Peaker: hmm, does that include not running any non-GUI applications?
14:19:47 <Peaker> Toxaris: "Applications" suck.  Wrapping re-usable code with non-reusable, limited UI wrapper that cannot be automated or scripted in any way
14:20:14 <Peaker> Toxaris: also re-establishing with every application, how the user should feed input to the exposed functions
14:20:54 <Toxaris> do you think unification of API and UI is possible?
14:20:54 <FordCortina> the fun dep a -> b c means "b and c depend on a"?
14:21:04 <Peaker> Toxaris: All Haskell code would be usable -- non-Haskell code can probably still be exposed via an FFI.  But I don't think I'd want to go back to "Application UI's" after having a universal functional UI
14:21:25 <Heffalump> FordCortina: correct
14:21:26 <Peaker> Toxaris: Sure - at worst it requires some UI hints so you get a nice auto-UI
14:21:56 <FordCortina> thanks
14:22:40 <Toxaris> I would say: at best it is possible with a lot of UI hints to get something somewhat usable
14:22:53 <gbacon> I'm using HXT's readDocument on 50k+ tiny XML documents, and it's piggish in both the time and alloc dimensions.. would it be better to stitch the documents together first and call readDocument once?
14:23:26 <Peaker> Toxaris: why do you think a lot of hints would be necessary?  I think most "hints" could be derived from actual usage. The important hints are "this is important. This is used a lot around this"
14:23:42 <Peaker> Toxaris: "This is never used, or always used in this form"
14:24:29 <Peaker> Toxaris: these hints can and should be possible to give via the UI itself (i.e customization)
14:24:46 <chrisdone> Peaker: hey have you seen formlets? I suspect that it might interest you
14:24:53 <Toxaris> Peaker: imho UIs should be designed by humans for humans
14:24:54 <Peaker> chrisdone: nope, where's that?
14:25:03 <Peaker> Toxaris: Why? They're doing such a poor job at it :-)
14:25:17 <dons> go darcs! http://www.reddit.com/comments/6vvrs/darcs_hacking_sprint_2526_october/
14:25:19 <lambdac> Title: darcs hacking sprint (25/26 October) : reddit.com, http://tinyurl.com/5rtazd
14:25:21 <Toxaris> Peaker: not thrown together, *designed* :)
14:25:32 <Peaker> Toxaris: Do you have many examples of good UI's?
14:25:34 <trofimovich> is there unused nick drop on freenode?
14:26:27 <chrisdone> Peaker: here's a blob about it, http://blog.tupil.com/formlets-in-haskell/ briefly it's a way of producing HTML forms in a composable way, with validation and handling of input names and so forth, using the Applicative style of composing things
14:26:29 <lambdac> Title: Tupil Code Blog  Blog Archive  Formlets in Haskell
14:26:33 <chrisdone> Peaker: er, "blog"
14:26:38 <Peaker> Toxaris: I think there's only one UI I'm actually satisfied with: IGo (The GPS navigation software for PDA's).  QuickSilver sounds like a good step in the right direction, and perhaps Emacs has some good concepts
14:27:10 <Toxaris> Peaker: not many examples, no.
14:27:13 <Peaker> chrisdone: cool - but why go through HTML and not directly do Graphics/Input access?  Forms are so limited..
14:27:29 <chrisdone> Peaker: what do you mean by graphics/input access?
14:27:48 <Peaker> chrisdone: Don't delegate the job to a browser, read mouse/keyboard from the user, and draw pixels yourself
14:28:07 <Modius> Matthew Lamari
14:28:21 <chrisdone> Peaker: well, if I'm writing a web site, I kind of have to delegate the job to the browser
14:28:26 <Heffalump> is ghc-users the right list to complain on if ghc HEAD doesn't build?
14:28:56 <Peaker> chrisdone: Yeah :)  Sounds like a very nice library..   I just strongly dislike the web :)
14:29:04 <RayNbow> hmm, Erik Meijer posted something on LtU ( http://lambda-the-ultimate.org/node/2932 )
14:29:06 <lambdac> Title: Programming Language Beauty: Look Closure | Lambda the Ultimate
14:29:14 <chrisdone> Peaker: I see ^_<
14:29:44 <Peaker> Toxaris: I am not sure why people think UI design is not systematic/mechanical... I think it should be derived from rather simple principles - and that a machine can derive the result from those principles better than a human can
14:30:25 <hackage> Uploaded to hackage: url 1.0
14:30:39 <Toxaris> I agree with that, but I think that a lot of UI-only annotations are needed to enrich a API with enough information to make this principles apply
14:30:40 <Peaker> Toxaris: these principles include minimizing required feedback from computer to operate, minimizing the amount of input from the user required for tasks (sort of huffman encoding on what the user actually does), etc
14:30:50 <Toxaris> and I think that these principles are unknown to humanity as of know
14:30:54 <Toxaris> s/know/now
14:31:43 <zeno___> dons: just saw you live in portland from real world haskell blog, just curious if you knew about/went to the us go congress there last week
14:31:44 <Peaker> Toxaris: That's true - but these annotations can probably be delegated as work for the user who can "customize" by giving them. Then he can share his customizations on his blog :)
14:31:57 <Quadrescence> > 'a' ++ ['a','b','c']
14:31:58 <lambdac>  Couldn't match expected type `Char' against inferred type `[a]'
14:31:58 <chrisdone> the coolest thing in UIs I've seen recently is the composable/functional way that I saw in Conal's talk.
14:32:02 <Quadrescence> > 'a' : ['a','b','c']
14:32:02 <dons> zeno___: no, actually, didn't know about that.
14:32:03 <lambdac>  "aabc"
14:32:13 <Peaker> chrisdone: yeah, Conal's TV stuff is great.
14:32:35 <zeno___> dons: one big event was a computer beat a pro (with an sizable handicap)
14:32:38 <Toxaris> Peaker: hmm maybe :)
14:32:39 <Peaker> chrisdone: I am really puzzled by why he finds it so important not to expose the algorithms hiding behind fused functions
14:33:37 <Cale> With 9 stones. :)
14:33:44 <Cale> Still, that's impressive.
14:33:46 <Toxaris> Peaker: I think it very important to take into accounts that humans are different both to each other and over time (i.e., they learn and forget), and that on the other hand, humans want to communicate about UIs and their interaction with computers
14:33:46 <thoughtpolice> zeno___: yeah, the 800-core computer? :)
14:33:58 <Toxaris> Peaker: so neither one-size-fits-all nor full customization feels right for me
14:33:59 <yitz> Peaker: if a computer will be using the ui, then you could perhaps (in theory) minimize those. If it's for a human, and you want to maximize usability, then it will be at least partially culture-dependent.
14:33:59 <chrisdone> Cale: with only 800 processors!!
14:34:03 <thoughtpolice> i've just started playing go but from what I gather, 9 stones is a pretty big handicap
14:34:05 <Cale> chrisdone: hehe
14:34:12 <dons> zeno___: oh, i know the result. didn't know it was in portland!
14:34:36 <xif> Cale: hey, I saw your Cont monad thing. pretty neat.
14:34:36 <zeno___> thoughtpolice: yeah its pretty big but a few years ago a worse pro beat the best bot with 25 stones
14:34:38 <Peaker> yitz: a computer doesn't use the UI - it can use the API directly...
14:34:38 <Cale> chrisdone: The amazing thing, I think, is that they have a good enough evaluation function now that it's not just a totally pointless waste of time to do that searching.
14:34:45 <Cale> xif: Which one?
14:34:53 <Toxaris> Peaker: since interaction with computers is a main oocupation for a growing number of people, it is very important for the overall state of humanity that people are happy doing so -- even more important then being efficient
14:34:58 <thoughtpolice> zeno___: nice.
14:35:12 <xif> Cale: the one you published in response to radix's question about a restricted execution solution.
14:35:14 <solrize> UI design seems like natural language communication, i.e. extremely messy for a computer to manage by itself
14:35:15 <Peaker> Toxaris: show them puppies every now and then :)
14:35:25 <Cale> Was it this? nest xs = runCont (sequence (map Cont xs))
14:35:36 <zeno___> dons: yeah inspired me to write a go bot, although mine takes a minute to do a playout and mogo was doing 1.7 million per second =p
14:35:43 <dons> hehe
14:35:49 <dons> need more cores!
14:35:50 <Peaker> solrize: Were there any serious attempts at it?
14:36:00 <xif> Cale: it was this one: http://www.haskell.org/haskellwiki/Cont_computations_as_question-answering_boxes
14:36:02 <lambdac> Title: Cont computations as question-answering boxes - HaskellWiki, http://tinyurl.com/56x6rq
14:36:08 <Cale> oh, that!
14:36:11 <solrize> peaker, at what?  natural language?
14:36:17 <Cale> I'd almost completely forgotten that I wrote that :)
14:36:20 <Peaker> solrize: at automatic UI design
14:36:20 <thoughtpolice> zeno___: well, it kind of *did* have 800 processors each clocked at 4.7gHz
14:36:22 <thoughtpolice> so don't feel bad
14:36:24 <thoughtpolice> :)
14:36:48 <Peaker> solrize: Can you explain why you think automatic UI design is so difficult?
14:36:53 <zeno___> yeah and mine is in ghci and nonoptimized, so im semi-hopeful =p
14:36:57 <solrize> peaker beyond automatic layout of gui widgets, not that i know of.  UI design is about figuring out what the user will want to do, i.e. it's AI-complete
14:37:14 <solrize> i think automatic UI design is difficult for the same reason manual UI design is difficult
14:37:14 <tromp> i hope go programs don't improve much more before 2011
14:37:29 <Cale> tromp: Why?
14:37:29 <yitz> Cale: how strong was the human?
14:37:30 <solrize> it's not just grunt coding, it takes a lot of testing with real users to get a UI right
14:37:36 <Cale> yitz: 9-dan pro
14:37:40 <xif> Cale: did you come up with anything stronger yet?
14:37:41 <tromp> i could lose my $1000 bet :(
14:37:42 <yitz> wow
14:37:50 <chrisdone> yitz: with a big handicap, though
14:37:50 <Cale> yitz: iirc.
14:37:56 <xif> yitz: he was 8p actually
14:38:00 <Peaker> solrize: I think there are many levels of "good" UI design. I think that at the current level most software is at - very very simple principles guiding an automatic designer will do much better than most software
14:38:01 <zeno___> tromp: i would love bots to be 9dan then i could always have a great opponent
14:38:04 <Cale> oh, 8p, alright :)
14:38:07 <xif> so ~grandmaster level in Chess.
14:38:10 <solrize> http://www.cis.syr.edu/~royer/bib2.html  <--- this is really cool, type systems for expressing computational complexity
14:38:11 <lambdac> Title: A List of Papers on Complexity at Higher Types
14:38:23 <yitz> ie, 8dan pro?
14:38:27 <xif> yeah
14:38:28 <Cale> yitz: yeah
14:38:36 <tromp> well, that's one consolation if i lose... there will be programs i can learn from
14:38:40 <xif> so it's not like Deep Blue beating Kasparov, certainly not with that handi, but it's still impressive.
14:38:42 <zeno___> pro ranks dont matter some 1ps are better than 9p
14:39:12 <thoughtpolice> didn't mogo only marginally win though even with that handicap?
14:39:19 <xif> thoughtpolice: yeah
14:39:26 <tromp> it's designed to minimize its winning margin
14:39:26 <yitz> still pretty good. last i heard the best programs were playing at 4kyu. maybe that was amateur, too, i don't remember
14:39:28 <xif> it won by 1 point I think?
14:39:28 <tromp> in a sense
14:39:28 <thoughtpolice> by like ~10 points or something
14:39:30 <zeno___> tromp: wasnt there some guy who was offering some obscene prize for a bot who beat a pro?
14:39:42 <Peaker> solrize: for example, my screen is large - and most of the time its displaying blank gray areas. At the same time, a lot of software opens up windows and places widgets that hide other widgets/windows, or require me to scroll to read - when screen space is available!
14:39:45 <chrisdone> xif: I saw a documentary about that once, it seems Kasaprov started a losing streak after that, after being unbeaten for ages? talk about a broken man
14:39:47 <Cale> thoughtpolice: Yeah, but beating a pro at all with any handicap is freaking impressive.
14:39:47 <tromp> ing used to offer 1M$
14:39:54 <tromp> expired many years ago
14:39:54 <solrize> peaker, yeah, that's awful :)
14:40:08 <thoughtpolice> Cale: definitely. i just started so i'm 30kyu :p
14:40:13 <yitz> Peaker: ah, so you mean xmonad :)
14:40:15 <Peaker> solrize: We're at such an awful stage with UI's - that automatic UI's will probably do much better by not messing up these basics
14:40:18 <thoughtpolice> that story is actually what inspired me to start playing go :)
14:40:19 <Cale> thoughtpolice: I mean, the last I checked before hearing that story, the best go programs were something like 12kyu.
14:40:20 * solrize thinks most PC chess programs can beat Kasparov if the program gets queen odds :)
14:40:23 <tromp> the program tries to maximize winning probability, not winning margin
14:40:27 <Peaker> yitz: xmonad does not fix stuff inside windows
14:40:34 <thoughtpolice> Cale: yeah, apparently everyone there expected mogo to get slaughtered
14:40:45 <byorgey> MoGo won by 1.5 with a handicap of nine stones.
14:40:51 <xif> chrisdone: yeah, it's pretty unnerving to lose to a machine, especially if you're world champion.
14:40:56 <solrize> i saw something about that go program where the human player said afterwards that the program probably played around 1 or 2 dan
14:41:06 <Peaker> solrize, yitz: There are many more artifacts.  You have modal dialog boxes demanding an answer to continue to X, where X does not depend at all on that answer
14:41:12 <byorgey> MoGo did get slaughtered in the blitz games they played first, but it was probably attributable to the different time limits.
14:41:14 <Cale> solrize: yeah, this is the same thing.
14:41:21 <Cale> byorgey: right.
14:41:27 <xif> solrize: that was the player Mogo beat.
14:41:33 <Peaker> solrize, yitz: Furthermore, you have changes occuring on screen in a disorienting fashion, instead of nice smooth animations that make it clear what's going on (the Mac gets this right)
14:41:36 <tromp> the pro did make a big mistake in the opening...
14:41:57 <thoughtpolice> either way still pretty impressive. i'm gonna have to play for a while when I can find time
14:42:02 <yitz> byorgey: you've got to give it some latency time to divide up its tasks among those 800 cores.
14:42:05 <Cale> byorgey: So it's some indication that the human evaluation function is still much better, even if the computer is capable of deeper searching.
14:42:06 <solrize> peaker there's something ubuntu does that's even worse, if it's waiting for network traffic or something, sometimes the whole screen goes dim, like the warp drive was overloaded :)
14:42:12 <thoughtpolice> although personally I think I would rather have a board and a human to play with
14:42:15 <byorgey> Cale: indeed.
14:42:15 <thoughtpolice> although with a program you don't have to care about how long you take
14:42:15 <zeno___> tromp: i think it was that he didnt think the computer would see it, so he played elsewhere (to make up for handicap)
14:42:34 <Peaker> solrize: if the application is not responding yeah.  Everyone's UI also blocks when something is waiting for input.. Another terrible thing
14:42:42 <tromp> no, he played the wrong point locally
14:42:49 <yitz> Cale: or human parallelization is better
14:42:55 <Peaker> solrize: In my PDA, I usually have to use the pen to click on super-tiny buttons, when the entire screen is boring blue, and available! annoying as hell
14:42:56 <solrize> peaker one thing i really wish was that gui programs and toolkits and kernels were written by game programmers, i.e. soft real time.  you should NEVER move the mouse and then wait 3 seconds for the cursor on the screen to respond
14:43:01 <tromp> r1 shld've been at s1
14:43:06 <byorgey> yitz: yeah, although I'd guess that it's simply due to the amount of trial games it was able to play in the amount of time it had, rather than latency issues
14:43:10 <zeno___> Cale: mogo doesnt even HAVE an evaluation function besides win/lose chineese :)
14:43:21 <Cale> zeno___: What?
14:43:32 <Peaker> solrize: yeah, I believe most of the software worls needs a rewrite :)
14:43:35 <Cale> zeno___: Surely it's not playing out entire games...
14:43:42 <zeno___> Cale: all it does
14:43:51 <solrize> peaker, and congress should outlaw C and C++ once and for all :)
14:44:00 <Cale> How does it control the combinatorial explosion that implies?
14:44:07 <zeno___> Cale: plays them out randomly, then does statistics on win/loss
14:44:09 <Cale> ah
14:44:14 <xif> Monte-Carlo method
14:44:18 <yitz> zeno___: even if so, doesn't it prune obvious stupidities?
14:44:27 <zeno___> yitz: nope
14:44:27 <tromp> and uses those statistics to build a best first tree
14:44:27 <Cale> All the computer programs I've ever played against give me a very strange feeling. I feel like I'm playing against someone who is very angry and confused.
14:44:49 <zeno___> yitz: it does try more "interesting" moves though (ones that cause the win/loss to fluctuate
14:44:54 <solrize> @remember cale All the computer programs I've ever played against give me a very strange feeling. I feel like I'm playing against someone who is very angry and confused.
14:44:54 <lambdac> I will remember.
14:45:08 <tromp> it explores better moves more often than worse moves
14:45:10 <xif> Cale: after watching the Terminator, I fear you may be onto something :(
14:45:18 <znutar> I got that feeling playing strip poker on my Apple II
14:45:23 <solrize> lol
14:45:44 <xif> machines are angry and confused at us for beating them at Go and making them strip at poker.
14:45:48 <yitz> Cale: will lambdac's @remember's get forwarded to \bot later?
14:45:53 <ski> solrize : O.O
14:45:55 <thoughtpolice> xif: wouldn't you be?
14:45:56 <Cale> yitz: I don't know? :)
14:46:03 <zeno___> Cale: http://senseis.xmp.net/?UCT
14:46:04 <lambdac> Title: Sensei's Library: UCT
14:46:04 <Cale> I don't know who lambdac is...
14:46:39 <Cale> We're looking for another server for lambdabot and/or fixes for the memory problems.
14:46:59 <thoughtpolice> Cale: yeah it was sucking up like 75% of the RAM on c.h.o or something according to nominolo earlier
14:47:09 <Cale> mm... yeah
14:47:10 <thoughtpolice> due to leaking runplugs and other various things
14:47:24 <thoughtpolice> uncool :(
14:47:26 <Cale> It created a lot of zombie processes.
14:47:45 <Cale> and leaked memory in various other ways...
14:47:58 <Cale> However, gwern is replacing the evaluation machinery at least.
14:48:06 <Cale> So hopefully at least that much will be better.
14:48:07 <thoughtpolice> yeah with mueval it seems
14:48:34 <thoughtpolice> unfortunately there doesn't seem to be a way to build a profiling version of the ghc package from what I gather
14:48:37 <Cale> However, it might be possible to put the same into preflex perhaps, which looks like it has a cleaner, less organically-constructed design :)
14:48:38 <thoughtpolice> which might help a bit
14:48:55 <yitz> lambdabot seemed to work ok until fairly recently. so, i take it that the memory leaks grew faster than moore's law?
14:48:55 <thoughtpolice> preflex?
14:49:25 <yitz> preflex: help
14:49:25 <preflex>  try 'help help' or see 'list' for available commands
14:49:27 <lelf> preflex: version?
14:49:33 <yitz> preflex: list
14:49:34 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
14:49:44 <thoughtpolice> new bot? :)
14:49:53 <Cale> Yeah, it's also written in Haskell :)
14:49:59 <thoughtpolice> man
14:50:02 <thoughtpolice> i rewrote my IRC bot like
14:50:04 <thoughtpolice> 3 times
14:50:08 <mauke> unfortunately preflex has at least two issues :/
14:50:15 <Cale> mauke: what are they?
14:50:26 <thoughtpolice> the 0.4 version still isn't finished but it DOES have plugins akin to lambdabot
14:50:26 <thoughtpolice> serialized via binary
14:50:28 <mauke> it's supposed to detect when the connection drops and restart
14:50:31 <thoughtpolice> i was going to steal lots of \bot's plugins but never got around to it
14:50:38 <Cale> mm... I think everything on freenode has that problem
14:50:51 <Cale> My IRC client can't tell when it's been disconnected.
14:50:51 <mauke> sometimes it prints the "restart!" message but somehow loses a file descriptor and just hangs
14:51:08 <yitz> colloquy is good with that
14:51:16 <mauke> looking at strace it seems to select() on an empty set IIRC
14:51:37 <mauke> this might be related to the on-the-fly upgrade triggered by a signal; I don't know
14:51:47 <thoughtpolice> so is preflex like succ lambdabot or something?
14:51:51 <mauke> another issue is that sometimes it just dies, complaining about stderr being finalized
14:52:08 <yitz> mauke: does preflex implement the IRC protocol from scratch?
14:52:14 <mauke> which doesn't make sense because up until that point it was printing messages just fine
14:52:18 <mauke> yitz: yes
14:53:28 <mauke> thoughtpolice: I figured everyone has to write an IRC bot at some point
14:53:29 <yitz> mauke: seems like that's an orthogonal issue to the plugin architecture, and to evaluation. wouldn't it make sense to separate those? e.g., implement a plug-in bot on top of libirc via ffi.
14:53:58 <mauke> libirc? sounds boring :-)
14:54:11 <yitz> mauke: indeed, very. that's the point.
14:54:19 <thoughtpolice> personally I used the irc package on hackage
14:54:39 <elliottt> did it work for you? :)
14:54:46 <thoughtpolice> elliottt: yes :)
14:54:53 <elliottt> excellent :)
14:55:15 <thoughtpolice> elliottt: in an exercise in boredom I'm actually maybe hacking up an IRC client too so I think I'll use it again
14:55:30 <thoughtpolice> although it might be nice to have bytestrings
14:55:34 <elliottt> ah cool.  let me know if you've got any patches.  always happy to apply changes :)
14:55:42 <elliottt> yeah, i was thinking it would be cool to have a bytestring version
14:55:44 <yitz> mauke: of course, you wrap the irc stuff, then later you can throw away libirc when you have a working native irc. meanwhile you can make sure the plugin architechture is working on its own. same for evaluation.
14:55:57 <thoughtpolice> elliottt: sure, I was thinking of perhaps fitting it onto parsec 3 but haven't tested anything yet
14:56:13 <elliottt> have you used parsec3 yet?
14:56:17 <mauke> preflex currently doesn't do evaluation but the plugin part seems to work
14:56:20 <elliottt> i've only ever used 2
14:56:50 <yitz> mauke: memory seem ok? try it against obnoxious plugins?
14:57:02 <thoughtpolice> elliottt: i haven't upgraded to parsec 3 either, I'm mainly worried about potential regressions although apparently over bytestrings there's about a 50% efficiency boost
14:57:02 <mauke> plugins are assumed to be trustworthy
14:57:19 <mauke> memory seems ok so far; it doesn't really store anything
14:57:20 <elliottt> thoughtpolice: interesting.  i might have to take a look
14:57:29 <yitz> mauke: i meant plugins that keep a lot of state, akin to @seen
14:57:35 <elliottt> thoughtpolice: the introduction of multi parameter type classes was making me put it off
14:57:38 <mauke> none of the plugins can use state
14:57:40 <thoughtpolice> elliottt: yeah, it seems definitely nice to have.
14:57:55 <thoughtpolice> elliottt: yeah some of the complexities of the upgrade made me wonder a little
14:57:56 <yitz> ah, the architecture specifically prevents that?
14:58:04 <mauke> yitz: all state is handled by an external "storage server"
14:58:08 <elliottt> thoughtpolice: yeah...
14:58:15 <mauke> communication goes over a socket
14:58:16 <elliottt> thoughtpolice: there was a bytestring tokenizer released recently
14:58:18 <thoughtpolice> elliottt: plus someone reported when pandoc was tried with parsec3 over regular strings, there was a big regression
14:58:28 <mauke> yitz: this ensures preflex doesn't lose state even if it crashes
14:58:31 <thoughtpolice> but bytestrings apparently work really nifty for it
14:58:33 <elliottt> thoughtpolice: interesting
14:58:33 <thoughtpolice> elliottt: oh?
14:58:35 <yitz> mauke: ok, nice.
14:58:41 <elliottt> thoughtpolice: yeah, let me look it up
14:58:51 <mauke> yitz: it also means I can run multiple instances on different networks, sharing the same knowledge base
14:59:17 <thoughtpolice> elliottt: either way your package was a godsend after a few attempts of mine to make my own home-grown parser and then me saying screw it; writing the parser wasn't the important part :)
14:59:54 <yitz> mauke: i assume you can also have instance-specific state in the store, if you *don't* want them to share something?
15:00:02 <mauke> yitz: yes
15:00:13 <mauke> but that's lost when the process exits
15:00:30 <elliottt> thoughtpolice: glad you found it helpful.  i've used it a few times playing around with irc bots :)
15:00:53 <mauke> heh, my IRC parser is only 35 lines
15:00:55 <gwern> > 2850 / 97
15:00:56 <lambdac>  29.38144329896907
15:01:07 <thoughtpolice> elliottt: hehe, my 0.3 and 0.4 versions used it - the 0.3 version *could* do reloads in situ using hs-plugins (preserving sockets and upgrading plugins and everything)
15:01:13 <gwern> > 2850 / (97*60)
15:01:13 <thoughtpolice> unfortunately it was a bastard and very very nasty
15:01:14 <lambdac>  0.4896907216494845
15:01:18 <chrisdone> ah, dates in haskell.. prepare for pain
15:01:39 <mauke> thoughtpolice: does your bot load plugins dynamically?
15:01:46 <elliottt> thoughtpolice: the last bot i was writing tried to incorporate the reactive library to turn the message handle into an event stream
15:01:56 <thoughtpolice> i got all the way up to doing reloads again on 0.4 before development sorta died, although it's definitely usable as just an IRC bot, although the only way to kill it is C^ :p
15:02:12 <elliottt> thoughtpolice: it didn't end up needing the reactive library, unfortunately.  it was just as easy to encode the same functionality with channels :)
15:02:17 <yitz> mauke: ok. why can't instance-specific state persist?
15:02:21 <ski> Cale : how would `nest' be used ?
15:02:25 <thoughtpolice> mauke: the 0.3 version compiled all plugins and loaded them, and then you could reboot it and it would go through the process again.
15:02:44 <stepcut> speaking of plugins, is there a documented better way of doing dynamically loaded plugins than hsplugins?
15:02:46 <thoughtpolice> for 0.4 I decided that was unnecessary so plugins were statically linked into the core, so when you reloaded it recompiled everything in one fell swoop
15:02:50 <thoughtpolice> although like I said
15:02:53 <elliottt> thoughtpolice: do you have your bot repo up somewhere?
15:02:53 <mauke> yitz: how do you identify an instance?
15:03:00 <thoughtpolice> I've not yet gotten it to do that yet for 0.4
15:03:02 <thoughtpolice> elliottt: just a sec
15:03:31 <Cale> ski: It's handy when you have a bunch of with- style functions that you want the results of all at once.
15:03:46 <yitz> mmm let's say per channel, or different servers
15:04:00 <ski> ok
15:04:07 <thoughtpolice> elliottt: http://github.com/thoughtpolice/infinity/tree
15:04:09 <lambdac> Title: thoughtpolice's infinity at master &mdash; GitHub
15:04:12 <mauke> yitz: the 'seen' plugin uses global state but includes the network name in the keys
15:04:20 <elliottt> thoughtpolice: thanks!
15:04:25 <thoughtpolice> elliottt: some of the parts are a little nasty, but trust me - it is a world of improvement over the grossness that was 0.3 :)
15:04:30 <ski> (but i wonder if it could be expressed nicer)
15:04:32 <mauke> so instances connected to different networks won't see each other's seen data
15:04:35 <thoughtpolice> (although 0.3 at least fully worked...)
15:04:43 <elliottt> thoughtpolice: hehehe
15:04:48 <thoughtpolice> it was really cool to make huge core refactorings to 0.3 while it was running
15:04:54 <thoughtpolice> and watch it reload and everything work :)
15:05:17 <thoughtpolice> i give a lot of that credit to the awesomeness of haskell's type system
15:05:42 <Cale> ski: Well, that use of the Cont monad is a vast improvement over my initial attempt :)
15:05:46 <thoughtpolice> elliottt: either way 0.4 is pretty much feature complete, right now the only things it can't do are 1) reload in situ, and 2) you can't issue a @quit message or anything, you have to kill it all at once
15:06:03 <ski> Cale : i can imagine :)
15:06:04 <thoughtpolice> at the very least, I did crib lambdabot's unlambda plugin
15:06:07 <elliottt> thoughtpolice: i've had a lot of luck refactoring haskell code.  the type system catches so many errors that would just slip by in a dynamic language
15:06:18 <thoughtpolice> elliottt: word :)
15:06:42 <mauke> hmm, maybe I should start stealing some of λbot's plugins
15:06:46 <zeno___> > () --lagtest
15:06:47 <lambdac>  ()
15:07:11 <thoughtpolice> elliottt: for reference, the old repo of 0.3 is here: http://code.haskell.org/infinity/src/
15:07:12 <lambdac> Title: Index of /infinity/src
15:07:21 <thoughtpolice> much worse, but it worked fully
15:07:29 <mauke> but I'm very proud of the calculator plugin and its syntax/parser :-)
15:07:31 <elliottt> hehe
15:08:49 <thoughtpolice> elliottt: if you patch anything or make improvements on that 0.4 or anything or just use it for a reference I'd love to hear about it. mainly in the git repo the uglist part is probably Plugins.hs
15:08:49 <mauke> preflex: calc () (( ) (())))) 2 (( 2 (((+)) ()(
15:08:49 <preflex>  4
15:08:58 <mauke> <3 free placement of parentheses
15:09:10 <thoughtpolice> there are also quickcheck tests there too
15:09:57 <elliottt> cool.  i'll have a look once i'm home tonight :)
15:09:59 <thoughtpolice> although there was a small bug in one of the functions that caused it to fail sometimes which was kinda peculuar, even with a large amount of test info and whatnot it could be hard to reproduce sometimes; never got around to tracking it
15:10:03 <yitz> preflex: calc 3)2)*)4
15:10:03 <preflex>  Too many operands
15:10:10 <yitz> preflex: calc 3)+)2)*)4
15:10:10 <preflex>  20
15:10:35 <yitz> preflex: calc 3+2)*)4
15:10:36 <preflex>  20
15:10:39 <ski> preflex: calc ()
15:10:39 <preflex>  Not enough mana
15:10:45 <yitz> preflex: calc 3+)2)*)4
15:10:45 <preflex>  20
15:10:51 <yitz> preflex: calc 3+)2*)4
15:10:51 <preflex>  20
15:10:53 <gwern> RED SKI NEEDS MORE MANNA
15:10:55 <yitz> preflex: calc 3+)2*4
15:10:55 <preflex>  20
15:11:06 <yitz> preflex: calc 3+(2*4)
15:11:06 <preflex>  11
15:11:16 <yitz> preflex: calc 3+(2*4(
15:11:17 <preflex>  11
15:11:24 <yitz> ok. weird.
15:11:42 <mauke> Enhanced™ infix notation
15:11:53 <thoughtpolice> elliottt: either way have fun :P if I make any headway on this little IRC client and patch anything/try to fit irc onto parsec3 I'll hollar at you
15:11:57 <trofimovich> preflex: calc 3^3
15:11:57 <preflex>  27
15:12:11 <trofimovich> preflex: calc 3^^3
15:12:12 <preflex>  Not enough mana
15:12:14 <ski> preflex: conjure ZO BRO RA into flask
15:12:32 <elliottt> thoughtpolice: thanks.  i've been thinking about moving the repo to github, could make sending patches a bit easier :)
15:12:54 <mauke> preflex: calc 2 3^^3
15:12:54 <preflex>  134217728
15:13:35 <yitz> preflex: calc 2 3++3
15:13:35 <preflex>  8
15:14:41 * yitz starts looking for his 4th grade arithmetic textbook
15:15:49 <mauke> preflex: calc logpi e
15:15:49 <preflex>  0.8735685268302319
15:16:38 <mauke> if anyone's interested, the calculator source can be found at http://mauke.ath.cx/preflex/ext/wcalc.c :-)
15:17:48 <chrisdone> .c @_@
15:18:18 <mauke> Real Men write their parsers/calculators in C!
15:18:25 <mauke> FFI++
15:19:03 <chrisdone> printf("%s\n", line);
15:19:05 <chrisdone> why not puts? :P
15:19:18 <mlh> preflex: ln (-1)
15:19:18 <mauke> why bother, gcc compiles that to puts(line) anyway
15:19:53 <chrisdone> mauke: The More Code I Write The More Productive I Feel
15:20:07 * chrisdone produces more Java interfaces
15:20:38 <mauke> preflex: calc ln _1
15:20:38 <preflex>  nan
15:21:07 <mauke> luqui: hi!
15:21:25 <luqui> hi
15:21:45 <mauke> so I see you wrote about the reverse state monad
15:21:58 <gwern> mauke: I'll make you eat those words by making preflex use mueval!
15:22:04 <luqui> yep.  :-)
15:22:07 <gwern> then we'll see who's laughing
15:22:19 <tehgeekmeister> @seen bos
15:22:19 <lambdac> bos is in #haskell. I don't know when bos last spoke.
15:22:23 <mauke> luqui: do you know who mentioned it to you?
15:22:31 <luqui> uh... I have logs
15:22:54 <mauke> I'm interested because I invented it (but I was probably not the only one)
15:23:08 <olsner> I still don't quite understand how it works
15:23:18 <chrisdone> you could have invented reverse monads (and maybe you already have!)
15:23:26 <luqui> mauke, okay looking
15:25:42 <luqui> mauke, heatsink
15:26:00 <mauke> preflex: seen heatsink
15:26:00 <preflex>  heatsink was last seen on #haskell 19 hours, 11 minutes and 40 seconds ago, saying: noohgodno, please talk privately to lambdac to avoid cluttering the channel
15:26:26 <mauke> luqui: have you seen Damian Conway's talk about positronic variables?
15:27:36 <luqui> mauke, if it was before 2006 then probably
15:27:44 <luqui> rather <= 2006
15:27:57 <luqui> ... but I don't recall
15:28:20 <luqui> does anyone know the latex symbol for _|_?
15:28:25 <mauke> I saw it at YAPC::EU 2007
15:28:39 <Toxaris> luqui: maybe \bot?
15:29:18 <luqui> Toxaris, daft! you're right.
15:29:28 * luqui always feels stupid for asking questions with obvious answers
15:29:34 <luqui> s/stupid/annoying/
15:29:41 <mauke> anyway, I have something like a reverse ST monad
15:29:49 <mauke> example using it: http://rafb.net/p/Rug8BK62.html
15:29:50 <lambdac> Title: Nopaste - No description
15:29:50 <luqui> mauke, with variables?
15:30:05 <mauke> yeah, closer to TheDamian's code
15:30:18 <Toxaris> luqui: well, if it's obvious for me, and a question for your, asking it is perfectly sensible and helps with distributing obviousness
15:30:34 <gwern> > 2006 - 23
15:30:35 <lambdac>  1983
15:30:43 <paczesiowa> @hoogle test
15:30:43 <lambdac> A Hoogle error occured.
15:31:00 <gwern> 2002 - 1983
15:31:32 <gwern> > 2002 - 1983
15:31:33 <lambdac>  19
15:32:44 <luqui> whoa...
15:32:52 <luqui> does mysqrt actually work?
15:33:09 <mauke> yes, both of them work
15:33:15 <vixey> mauke: .... what ???
15:33:24 <sioraiocht> @seen jamii
15:33:24 <lambdac> jamii is in #haskell. I don't know when jamii last spoke.
15:33:31 <mauke> preflex: seen jamii
15:33:31 <preflex>  jamii was last seen on #haskell 1 day, 23 hours, 17 minutes and 30 seconds ago, saying: olsner: You can define your own include files
15:33:39 <sioraiocht> ?
15:33:42 <sioraiocht> who is preflex?
15:33:44 * luqui has no idea how...
15:34:14 <mauke> luqui: http://rafb.net/p/d67BhL48.html
15:34:14 <lambdac> Title: Nopaste - No description
15:34:51 <gwern> sioraiocht: preflex was a scientist
15:34:59 <gwern> a scientist whose proprety was stolen
15:35:11 <gwern> one day, preflex said, 'I will stop the motor of the world!'
15:35:11 <gwern> and he left
15:35:35 <gwern> no one knows where he went, but people still ask 'Who is John Preflex?'
15:35:58 <sioraiocht> well, I more meant what is with the bot NAMED preflex
15:37:46 <mauke> sioraiocht: it's mostly harmless
15:39:34 <sioraiocht> -_-
15:39:36 <mauke> btw, if you think Positronic.hs is evil, don't look at the original perl code :-)
15:39:36 * sioraiocht is sceptical
15:41:37 <zeno___> @pl @pl funcEq f a b = f a == f b -- wow i really dont get this
15:41:38 <lambdac> (line 1, column 1):
15:41:38 <lambdac> unexpected "@"
15:41:38 <lambdac> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:41:42 <zeno___> @pl @pl funcEq f a b = f a == f b
15:41:43 <lambdac> (line 1, column 1):
15:41:43 <lambdac> unexpected "@"
15:41:43 <lambdac> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:41:54 <zeno___> @pl funcEq f a b = f a == f b
15:41:55 <lambdac> funcEq = flip =<< (((.) . (==)) .)
15:41:58 <zeno___> oops :(
15:42:29 <mauke> (==) `on` f
15:42:35 <mauke> :t on (==)
15:42:36 <lambdac> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
15:43:32 <zeno___> mauke: ah thanks
15:43:34 <yitz> @. unpl pl funcEq f a b = f a == f b
15:43:34 <lambdac> funcEq = (\ g p e f -> (g p) == (e f)) >>= \ a b c -> a c b
15:44:03 <mauke> @unpl on (==)
15:44:04 <lambdac> on (==)
15:45:37 <ski> mauke : looks like fun :)
15:48:56 <yitz> @unpl f x = (: x)
15:48:57 <lambdac> f x a = a : x
15:49:35 <yitz> @unpl f x = (+ x)
15:49:36 <lambdac> f x a = a + x
15:49:46 <yitz> @unpl preflex calc = (+ x)
15:49:46 <lambdac> preflex calc a = a + x
15:49:46 <preflex>  Lexical error
15:50:06 <vixey> preflex calc "aoeu"
15:50:06 <preflex>  Lexical error
15:51:21 <yitz> preflex list
15:51:21 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
15:52:18 <yitz> @unpl preflex remember lambdac = (. (+ x))
15:52:18 <lambdac> preflex remember lambdac b e = b (e + x)
15:52:34 <sioraiocht> ?
15:52:39 <sioraiocht> be nice to the bots
15:53:05 <mauke> preflex: quote lambdac
15:53:05 <preflex>  <lambdac> b e = b (e + x)
15:53:23 <yitz> bottom line - we've got to get lambdabot to prefix all of its responses with a space.
15:53:46 <EvilTerran> i presume preflex ignores itself?
15:53:50 <mauke> as long as lambdabot doesn't listen to commands beginning with a space, there should be no loops
15:53:54 <EvilTerran> er, lambdac. lambdabot. etc
15:54:12 <mauke> preflex has two output modes, NOTICE and PRIVMSG+space
15:54:38 <EvilTerran> NOTICE for folks following the spec, PRIVMSG+space for the pragmatists
15:55:38 <EvilTerran> makes sense to have that behavior for any bot
15:55:59 <ddarius> gwern: You're quoting Ayn Rand...
15:56:07 <bos> tehgeekmeister: ?
15:56:52 <gwern> ddarius: I feel that swapping out all of her characters for robots results in stories of superior interest and applicability to reality
15:57:22 <ddarius> gwern: They would make more sense that way...
15:57:46 * gwern is glad ddarius appreciates my mocking of Rand
16:09:08 <yitz> preflex help store
16:09:09 <preflex>  store KEY DATA - associate DATA with KEY
16:09:19 <yitz> preflex help get
16:09:19 <preflex>  get KEY - print data associated with KEY
16:09:25 <yitz> preflex help .
16:09:25 <preflex>  .: alias of get
16:09:33 <yitz> preflex help ?
16:09:33 <preflex>  ?: alias of get
16:09:50 <eu-prleu-peupeu> im watching this video from Simon Peyton-Jones that was on the haskell page (videos section), really great stuff...
16:10:12 <yitz> eu-prleu-peupeu: the xmonad talk?
16:10:14 <eu-prleu-peupeu> he goes through this project called xmonad
16:10:17 <eu-prleu-peupeu> yes that one
16:10:19 <eu-prleu-peupeu> amazing
16:10:31 <yitz> yitz: it's very well done
16:10:42 <eu-prleu-peupeu> i should download the source of xmonad, and check it out...
16:11:09 <yitz> eu-prleu-peupeu: try using it. xmonad is really nice.
16:11:20 <eu-prleu-peupeu> im following it with the slides on another window, because the camera guy couldn't focus the slides very well
16:11:21 <eu-prleu-peupeu> hmm
16:11:23 <eu-prleu-peupeu> im using ubuntu
16:11:30 <eu-prleu-peupeu> not sure how it will blend with ubuntu
16:11:33 <name> eu-prleu-peupeu: apt-get install xmonad should it
16:11:44 <eu-prleu-peupeu> i really like the ion3
16:11:57 <TomMD> eu-prleu-peupeu: I use xmonad on ubuntu.
16:12:08 <eu-prleu-peupeu> heheh
16:12:09 <eu-prleu-peupeu> nice
16:12:19 <eu-prleu-peupeu> i will try it then, right after this talk finishes
16:12:39 <name> if ubuntu would not support xmonad it would be a weird distribution
16:13:05 <hoelzro> does anyone here use Vim for Haskell hacking?  I'm finding that my lhaskell syntax file sucks and want to see if anyone has a better one
16:13:24 <eu-prleu-peupeu> i use it :P
16:13:31 <eu-prleu-peupeu> tab stop replaced by four spaces
16:13:34 <yitz> how did you get a nick name? you must have been the first one on freenode.
16:14:58 <r3m0t> took me a few tries to parse that yitz
16:15:08 <yitz> he
16:16:31 <yitz> @quote groucho
16:16:32 <lambdac> No quotes match. Just what do you think you're doing Dave?
16:17:47 <paczesiowa> what package has exception catching fun of type :: IO a -> IO (Maybe a) ?
16:18:05 <mauke> :t catch
16:18:07 <lambdac> forall a. IO a -> (IOError -> IO a) -> IO a
16:18:36 <mauke> \b -> fmap Just b `catch` const (return Nothing)
16:19:08 <Quadrescence> Is anyone knowledgeable with multi-threaded/parallelization in Haskell? (I am not doing any of that, I am just wondering how it might work conceptually)
16:19:10 <paczesiowa> cabalize it:>
16:21:12 <mauke> Quadrescence: well, you can start threads and they execute in parallel ...
16:22:26 <Quadrescence> mauke: For example, suppose we are ... I don't know... This is hard.
16:22:45 <yitz> Quadrescence: the par function hints to that compiler that a calculation can be run in parallel.
16:22:49 <Quadrescence> I am just thinking about for/next loops in other languages. Usually, those can be parallelized by splitting the loop in half for each process.
16:23:13 <mauke> you mean automatic parallelization by the compiler?
16:23:26 <Quadrescence> But I think recursion in Haskell, and one iteration depends on the previous
16:23:37 <Quadrescence> So that can't, to me/in my mind, be split.
16:23:41 <Quadrescence> (but, I guess it all depends)
16:23:59 <yitz> Quadrescence: that's actually the hard part in any language
16:24:13 <Quadrescence> I'd suppose so.
16:24:29 <Quadrescence> Again, it really depends on what you're doing I guess.
16:25:18 <Quadrescence> mauke/yitz: Can the compiler do automatic parallelization in some cases?
16:25:32 <mauke> @where ndp
16:25:32 <lambdac> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
16:27:16 <Quadrescence> mauke: Thanks.
16:27:52 <humasect> hello everyone. how does one make a Ptr from ByteString ? ForeignPtr ?
16:28:19 <humasect> is the common practice to use CString for this ?
16:28:35 <hoelzro> humasect: what are you trying to do?
16:28:43 <humasect> pass ByteString into FFI call
16:28:50 <hoelzro> ok
16:30:24 <yitz> > let x = sum [1..1000]; y = x `par`sum [1001..2000] in x + y
16:30:25 <lambdac>  2001000
16:30:26 <hackage> Uploaded to hackage: blas 0.5
16:33:00 <paczesiowa> :t lift
16:33:02 <lambdac> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
16:33:52 <paczesiowa> :t runMaybeT
16:33:54 <lambdac> Not in scope: `runMaybeT'
16:35:59 <paczesiowa> how do you call runMaybeT . return :: (Monad m) => a -> m (Maybe a) ? drop?
16:36:55 <paczesiowa> I mean MaybeT . return :: (Monad m) => Maybe a -> MaybeT m a
16:37:46 <glguy_> humasect: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#25
16:37:49 <lambdac> http://tinyurl.com/39be59
16:38:05 <glguy_> humasect: type CString = Ptr CChar
16:38:12 <humasect> glguy_: ahh i see, great! thank so much=)
16:38:16 <erikc> quadraescence: for parallelizing a 'recursive loop', you split the input loop and run the top-level recursive function in parallel with the halves of the list
16:38:23 <erikc> err, split the input list
16:38:49 <erikc> you then merge/reduce the results into a single result on the outbound
16:40:56 <yitz> > let x = sum [1..1000]; y = x `par`sum [1001..2000] in x + y
16:40:57 <lambdac>  2001000
16:41:23 <mauke> > 2000 * 2001 `div` 2
16:41:24 <lambdac>  2001000
16:45:40 <TomMD> humasect: Not having an OS X system, I wanted to make sure removing the -fvia-c option on pureMD5 worked for you.
16:46:30 <humasect> ah, TomMD , i will give this a try right now
16:47:26 <humasect> it compiles =)
16:47:43 <TomMD> yay!
16:48:05 <TomMD> btw: You are looking for useAsCString and useAsCStringLen
16:49:10 <humasect> thanks =) =)
17:13:56 <Olathe> Who runs haskell.org ?
17:14:08 <Olathe> Or admins
17:14:46 <dcoutts_> Olathe: is there a problem?
17:15:12 <Olathe> No, I shrunk a few images down for it.
17:15:24 <Olathe> If they're interested.
17:15:32 <chrisdone> someone is popping up mysql errors on my test server. stop using my test server! ~_@
17:15:48 <dcoutts_> Olathe: well if it's wiki stuff then you can do it, or ask someone who's a regular wiki person
17:16:01 <dcoutts_> Olathe: the admins themselves don't really manage content like that
17:16:09 <Olathe> One of them, I can. The other is the upper left hand corner thing.
17:16:16 <dcoutts_> Olathe: what images?
17:16:32 <Olathe> http://haskell.org/haskellwiki_logo_small.png
17:16:37 <Olathe> and
17:17:21 <dcoutts_> Olathe: you mean you've run optipng on them or something ?
17:17:46 <Olathe> Yeah.
17:17:51 <dcoutts_> ah right
17:20:42 <dcoutts_> Olathe: seems that the last person to touch that image was Ashley Yaleley
17:22:23 <Olathe> Ahh, thanks.
17:22:38 <dcoutts_> Olathe: actually I think that's "Yakeley".
17:23:06 * dcoutts_ thinks our passwd entry is mis-spelt
17:23:34 <ddarius> Ashley is trying to sneak by you.
17:25:16 <jsnx> i'm trying to run the "Simple TCP server" code [ http://sequence.complete.org/node/258 ]
17:25:18 <lambdac> Title: A simple TCP server | The Haskell Sequence
17:25:31 <jsnx> and it keeps bailing with an error from getNameInfo
17:26:03 <jsnx> the debugger tells me the trouble is in the final line (the last line of code on the web page, as well)
17:26:26 <dcoutts_> Olathe: http://haskell.org/haskellwiki/Haskell.org says that the purpose of Ashley Yakeley's account is the HaskellWiki
17:26:27 <lambdac> Title: Haskell.org - HaskellWiki
17:26:34 <jsnx> it is some kind of thing to do with an uncaught IOError in the network libraries
17:26:43 <dcoutts_> Olathe: so almost certainly the right person to send them to
17:26:53 <jsnx> i'm having trouble figuring out where to put the `catch`
17:33:09 <noteventime> This is probably a question asked all day byt, whatever happened to the gtk/cairo packages?
17:33:22 <dcoutts_> noteventime: what about them?
17:33:52 <dcoutts_> they're where they've always been :-)
17:34:11 <Olathe> Ahh, OK.
17:34:15 <Olathe> I think I found her on it.
17:34:34 <noteventime> dcoutts_: They're not on hackage, are they?
17:34:40 <dcoutts_> noteventime: not yet
17:34:45 <noteventime> Ahh
17:34:46 <Olathe> I sent her a small message (http://haskell.org/haskellwiki/User_talk:Ashley_Y#Same_logo.2C_less_bytes).
17:34:49 <lambdac> Title: User talk:Ashley Y - HaskellWiki, http://tinyurl.com/5wcxlw
17:34:56 <noteventime> dcoutts_: So what's soegtk?
17:35:15 <shapr> Olathe: Ashley is a guy.
17:35:16 <dcoutts_> noteventime: it's a package that provides the soe api, it's implemented using gtk2hs
17:35:26 <Olathe> Oh, I'm sorry.
17:35:32 <shapr> No worries, just thought I'd mention it.
17:35:44 <stepcut> Olathe: http://ashley.yakeley.org/
17:35:46 <lambdac> Title: Ashley Yakeley
17:35:50 <noteventime> Ohh
17:35:54 <Olathe> Ahh, OK.
17:35:58 <noteventime> The book thing, I see :p
17:36:11 <noteventime> dcoutts_: Thanks for clearing that up :p
17:36:24 <dcoutts_> noteventime: np.
17:50:21 <chrisdone> the haskell date/time library may be ENTERPRISE as hell, but very very useful
17:50:52 <idnar> enterprise?
17:51:51 <chrisdone> supports lots of things, quite verbose
17:52:20 <chrisdone> well, not verbose. enterprise is a better word
17:54:32 <idnar> it's not a word that aids my comprehension of your description, however
17:54:33 <chrisdone> I'm not used to languages putting proper thought into a time/date library to care about timezones, locales, I guess
17:54:34 <idnar> :/
17:54:53 <idnar> I'm not sure what use a time/date library would be if it didn't care about timezones and locales ;)
17:55:09 <chrisdone> inadequate
17:57:53 <chrisdone> yay: http://chrisdone.com:3000/ and source so far: http://chrisdone.com:3000/Listi.html
17:57:54 <lambdac> Title: chris done's homepage
17:58:41 <chrisdone> I'm making myself a little site to add youtube/dailymotion and other flash media site links to to create playlists which will automatically show all the videos in that playlist. blip.tv would also be nice, but depends on whether I can control the player from javascript
17:59:10 <chrisdone> I tend to play google tech talks and things like that all the time, you see 6_6
17:59:53 <chrisdone> (on a seperate computer)
18:01:09 <chrisdone> formlets are making it really easy to work with these, uh, forms
18:05:18 <vixey> > 1+11
18:05:19 <lambdac>  12
18:05:29 <vixey> > 11111*11111
18:05:30 <lambdac>  123454321
18:05:34 <vixey> > 111111111*111111111
18:05:35 <lambdac>  12345678987654321
18:05:59 <Fred__24> map (*2) [1,1]
18:06:07 <vixey> < [2,2]
18:06:21 <Fred__24> =)
18:07:44 <chrisdone> vixey: heh, cute
18:08:14 <EvilTerran> "< ..." should instruct lambdabot to come up with a minimal expression for the given value
18:08:15 <EvilTerran> :P
18:08:22 <EvilTerran> like > in reverse
18:09:17 <chrisdone> it would cheat >_<
18:09:22 <wolgo> Hi
18:09:27 <chrisdone> hai
18:10:20 <wolgo> fibs = 0 : 1 : zipWith (+) fibs (tail fibs). Is this fast because the list is infinite?
18:10:49 <wolgo> Or because of this "lazy evaluation" I  keep hearing about
18:10:53 <vixey> wolgo: sharing
18:10:55 <chrisdone> the values are memoized
18:10:57 <wolgo> Well, reading actuall.
18:11:19 * EvilTerran votes "sharing and memoising" too
18:11:28 <EvilTerran> although it's not quite memoising in the usual sense
18:11:51 <wolgo> waaaaaaait
18:11:54 <chrisdone> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
18:11:55 <lambdac> Defined.
18:12:07 <wolgo> Ahh, this does not calculate every value multiple times after
18:12:18 <wolgo> because of tail fibs?
18:12:26 <wolgo> Hayzeus
18:12:38 <wolgo> this is mind  bending for newbies like me
18:13:13 <vixey> wolgo: yes
18:13:24 <vixey> 'bending' is how I think of it
18:13:37 <vixey> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
18:13:52 <vixey> 0 : 1 : zipWith (+) <> (tail <>) <-------- <fibs>
18:14:11 <wolgo> wow
18:14:22 * wolgo is preparing to attend college for cs
18:14:44 <EvilTerran> wolgo, i find it helps to work through the evaluation manually
18:14:58 <EvilTerran> in some ways, yes, lazy evaluation is relevant to why it works well
18:15:02 <wolgo> This is a 4 year opportunity to work on stuff like this.
18:15:09 <wolgo> EvilTerran: Okay.
18:15:21 <EvilTerran> if "hat" were working, that'd make things easier =/
18:16:15 <EvilTerran> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
18:16:17 <EvilTerran> = 0 : 1 : zipWith (+) (head fibs : tail fibs) (head (tail fibs) : tail (tail fibs))
18:16:39 <EvilTerran> = 0 : 1 : zipWith (+) (0 : tail fibs) (1 : tail (tail fibs))
18:16:59 <EvilTerran> = 0 : 1 : (0 + 1) : zipWith (+) (tail fibs) (tail^2 fibs)
18:17:13 <EvilTerran> (using f^n as the usual maths shorthand)
18:17:17 <EvilTerran> following so far?
18:17:25 <wolgo> Yes, I think so
18:17:41 <wolgo> Wait no I am not
18:17:52 <EvilTerran> where do you get lost?
18:18:14 <wolgo> how is (head fibs : tail fibs) concatenated? Because we say 0 : 1 in the function definition and after recursing we have head : tail?
18:18:18 <EvilTerran> for the first step, i used that, for non-empty lists xs, xs = head xs : tail xs
18:18:27 <EvilTerran> ?src head
18:18:28 <lambdac> head (x:_) = x
18:18:28 <lambdac> head []    = undefined
18:18:31 <EvilTerran> ?src tail
18:18:32 <lambdac> tail (_:xs) = xs
18:18:32 <lambdac> tail []     = undefined
18:18:38 <EvilTerran> > tail fibs
18:18:39 <lambdac>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:18:53 <EvilTerran> wolgo, we say 0 : 1 : (some other stuff) in the definition
18:18:58 <wolgo> right
18:18:59 <vixey> wolgo 0 : 1 doesn't make sense on it's own
18:19:03 <EvilTerran> which is 0 : (1 : (...))
18:19:07 <vixey> x : y : z = x : (y : z)
18:19:08 <EvilTerran> ?type (:)
18:19:09 <lambdac> forall a. a -> [a] -> [a]
18:19:18 <vixey> so if you say x : (y  there's something important missing
18:19:23 <EvilTerran> takes an item on the left and a list on the right, returns a list
18:19:49 <wolgo> Oh okay. I see
18:19:53 <wolgo> .
18:19:59 <EvilTerran> it's like a linked list in an imperative language
18:20:09 <EvilTerran> each cell has a value and a pointer to the next cell or nil
18:21:03 <noecksit> hello, has anyone on here used c2hs before?
18:21:47 <chrisdone> > zipWith (+) [1..3] [1..3]
18:21:48 <lambdac>  [2,4,6]
18:21:58 <EvilTerran> > zipWith (+) [a,b,c] [x,y,z]
18:21:59 <lambdac>  [a + x,b + y,c + z]
18:21:59 <noecksit> im having trouble converting Simple.hs from the tests for some reason
18:22:52 <wolgo> >zipWith (+) [1..9] [1..9]
18:23:22 <chrisdone> > let fibs = x : y :  zipWith (+) fibs (tail fibs) in take 5 fibs
18:23:23 <lambdac>  [x,y,x + y,y + (x + y),x + y + (y + (x + y))]
18:23:56 <idnar> chrisdone: man, the expr version of that is a bit mind-destroying
18:24:01 <chrisdone> idnar: haha
18:24:04 <vixey> > zipWith + [1,2,3] [100,200,300]
18:24:05 <lambdac>  Couldn't match expected type `t
18:24:11 <vixey> > zipWith (+) [1,2,3] [100,200,300]
18:24:13 <lambdac>  [101,202,303]
18:24:17 <wolgo> > zipWith (+) [1..9] [1..9]
18:24:18 <lambdac>  [2,4,6,8,10,12,14,16,18]
18:24:20 <idnar> chrisdone: although, it makes me want to start deriving a formula for computing the Nth fibonacci number directly by some kind of multiplication
18:24:23 <wolgo> ooo
18:24:39 <wolgo> This is shiny
18:25:17 <chrisdone> it helps to understand zipWith before considering the meaning of the clever fibs definition
18:26:11 <noecksit> lol, i just followed the Makefile even though it wasnt working
18:26:26 <wolgo> Is + a function applied to arguments?
18:26:31 <wolgo> Or is it an operator?
18:26:39 <wolgo> Or can it be both?
18:26:42 <chrisdone> it's a function which happens to be infix
18:26:52 <SamB> the way you said it, it's an operator token ;-)
18:26:58 <vixey> wolgo,
18:26:59 <chrisdone> you can use it as a normal function by putting it in parentheses
18:27:02 <SamB> > 1 + 2
18:27:04 <lambdac>  3
18:27:07 <vixey> @let add x y = x + y
18:27:07 <lambdac> Defined.
18:27:08 <SamB> there + is applied to arguments
18:27:10 <wolgo> I am going to go learn more about this.
18:27:13 <vixey> > zipWith add [1..9] [1..9]
18:27:16 <lambdac>  [2,4,6,8,10,12,14,16,18]
18:27:20 <SamB> it's the same as:
18:27:23 <SamB> > (+) 1 2
18:27:25 <lambdac>  3
18:27:42 <wolgo> Oh.
18:27:44 <wolgo> Okay
18:27:48 <wolgo> Thanks a lot.
18:27:55 <wolgo> I am going to go read some.
18:28:22 <chrisdone> lambdac's limits are a lot higher than lambdabot? takes ages to finally terminate a thread
18:28:22 <wolgo> Thanks vixey EvilTerran SamB etc
18:28:28 <wolgo> thanks
18:28:31 <chrisdone> > length [1..9999999]
18:28:52 <SamB> EvilTerran: you might want to consider martian citizenship
18:29:06 <SamB> being evil and all
18:29:10 <chrisdone> or maybe the machine is really weak and it can only just kill the thread... /me stops
18:29:14 <lambdac>  thread killed
18:29:18 <solrize> EvilMartian?
18:29:35 <chrisdone> EvilTerrain, referring to the landscape of his home world
18:29:44 <idnar> lambdac kinda sounds like a lambdabot rewrite in C
18:29:46 <solrize> http://www.zazzle.com/java_2_evil_edition_2_logos_mug-168138170629314846
18:29:48 <lambdac> Title: Java 2 Evil Edition (2 logos) Mug from Zazzle.com, http://tinyurl.com/38lqya
18:29:51 <idnar> which... admittedly, seems unlikely :P
18:29:57 <SamB> idnar: indeed!
18:30:00 <chrisdone> idnar: wouldn't put it past mauke
18:30:03 <SamB> that'd be like the stupidest idea ever
18:30:10 <SamB> well, not really
18:30:14 <chrisdone> haha
18:30:15 <idnar> SamB: not the stupidest
18:30:19 <idnar> SamB: perhaps the most insane
18:30:25 <SamB> rewriting ELIZA in INTERCAL would probably be stupider
18:30:40 <idnar> what about rewriting it in Malbolge?
18:30:46 * jeffz ponders ELIZA in piet
18:31:39 * pjdelport eyes jeffz suspiciously
18:32:14 <jeffz> pjdelport: http://www.dangermouse.net/esoteric/piet.html
18:32:15 <lambdac> Title: DM's Esoteric Programming Languages - Piet
18:35:50 <lispy> I have a question for the type experts
18:36:11 <solrize> http://www.dangermouse.net/esoteric/piet/samples.html wow
18:36:12 <lambdac> Title: DM's Esoteric Programming Languages - Piet Samples
18:36:20 <lispy> Hmaybe I should create an hpaste first
18:36:24 <humasect> how come, when ghc compiles a program with -prof and -auto-all, the Main.prof is 0 bytes after execution of said program ?
18:36:42 <lispy> and maybe hpaste isn't working...
18:36:56 <lispy> humasect: +RTS -p
18:37:01 <lispy> humasect: use that when running the program
18:37:06 <humasect> yes, sorry, with +RTS -p as well
18:37:14 <humasect> this is what creates the Main.prof, but it is 0 bytes yet
18:37:17 <lispy> did the program crash?
18:37:35 <SamB_XP> humasect: what does the program do?
18:37:35 <lispy> If the runtime didn't exit properly it miht not get flush
18:37:52 <humasect> its a real time application
18:37:53 <humasect> ohh
18:37:57 <humasect> that must be it. =)
18:37:59 <SamB_XP> if it were Hello, World, it would be concievable that all IO had been fused away ;-P
18:38:06 <chrisdone> SamB_XP: does XP mean XP as in Windows? always wondered..
18:38:09 <SamB_XP> er. all the strings, I mean...
18:38:13 <SamB_XP> chrisdone: yeah
18:38:19 <chrisdone> oki
18:38:49 <humasect> thanks everyone =) one more question ... with cabal, how does one build a library for profiling? say, zlib
18:39:04 <SamB_XP> I still haven't gotten around to learning how to use irssi for multiple channels
18:39:13 <dcoutts> humasect: use the -p or --enable-library-profiling flag
18:39:29 <lispy> SamB_XP: it's a PITA, but I found some nice scripts that make it easier
18:40:10 <SamB_XP> lispy: oh you mean it's not just my lack of irssi knowledge?
18:40:18 <chrisdone> SamB_XP, lispy: multiple channels??
18:40:24 <lispy> SamB_XP: it's like ctrl+n I think
18:40:37 <humasect> dcoutts: excellent, that part is working now=)
18:40:50 <lispy> SamB_XP: but I found a perl script that lets me type /go part-of-chan-name<tab>
18:40:53 <SamB_XP> chrisdone: aren't you in any channels besides #haskell?
18:40:56 <chrisdone> Alt+n to go to a different window
18:41:07 <chrisdone> SamB_XP: yeah. I figured you meant something more complex
18:41:18 <SamB_XP> chrisdone: why would I?
18:41:22 <chrisdone> I just used the numbers and Alt+n
18:41:32 <adekoba> SamB_XP: just /join #<channel>, and use ALT-[left|right] to change
18:41:44 <humasect> thanks again everyone =) all is well again =)
18:42:20 <chrisdone> /win n to switch also, and /win c to close
18:44:12 <chrisdone> SamB_XP: didn't mean to be obnoxious or anything·_·
18:44:53 <SamB_XP> yeah, I know.
18:44:59 <SamB_XP> just a curious thing to think ;-)
18:45:54 <lispy> http://haskell.pastebin.com/m5d9c3c85
18:46:00 <lispy> I really need some help with this type error
18:46:04 <lispy> So, first question
18:46:11 <lispy> What is wrong ith the type signature of "wasc"?
18:46:24 <lispy> And why does it think that 'z' is escaping?
18:46:34 <lispy> The return value is IO a, where z != a
18:46:43 <lispy> I also tried changing the return value to IO ()
18:46:46 <SamB_XP> what's with the guest/haskell' account for the hackage tracker???
18:46:50 <lispy> But, that didn't get ride of it ither
18:49:55 <lispy> Any suggestions of things to try?
18:50:10 <SamB_XP> hmm, why is there so little on http://hackage.haskell.org/trac/hackage/ticket/282 ?
18:50:12 <lambdac> Title: #282 (profiling versions of libraries not managed well) - Hackage - Trac
18:50:56 <dons> it only affects devs, who know how to rebuild.
18:54:27 <edwardk> holy crap they finally released opengl 3!
18:55:40 <Smokey`> it's nothing even remotely close to that which khronos promised.
18:55:45 <edwardk> =/
18:55:59 <Smokey`> I expect the BOF event at SIGGRAPH to have a 'heated' Q&A session, to say the least.
18:56:18 <vixey> oh
18:56:23 <edwardk> i shelved a project last year in september to wait for opengl 3 =(
18:56:27 <dsrogers> why was left out?
18:56:30 <dsrogers> *what
18:57:07 <Smokey`> dsrogers: the new object model that khronos had been talking about and promising the opengl community for many months.
18:57:07 <glguy> @seen sjanssen
18:57:07 <lambdac> sjanssen is in #haskell. I last heard sjanssen speak 18h 2m 42s ago.
18:57:20 <edwardk> wait, the object model isn't there?
18:57:27 <Smokey`> dsrogers: OpenGL 3 is nothing but moving a few 'EXT' extensions into the core 'ARB' set.
18:57:28 <edwardk> then whats the frickin point?
18:57:37 <Smokey`> edwardk: I know... it's ... pointless.
18:57:45 <vixey> :(
18:57:47 <Smokey`> very :(
18:58:41 <Smokey`> not to mention OpenGL 3.0 didn't actually remove anything, it just 'deprecated' them - which means the old legacy stuff won't be removed untill next version - or later.  so OpenGL drivers are still a mess for IHVs ot maintain.
18:58:57 <dsrogers_> ack!
18:59:00 <dsrogers_> what'd I miss?
18:59:28 <vixey> nothign
18:59:31 <bd_> Why would one even need backwards compat with OpenGL? Just have seperate libraries for each spec rev.
18:59:36 <Smokey`> dsrogers: http://rafb.net/p/6FBaLa25.html
18:59:37 <lambdac> Title: Nopaste - No description
19:00:27 <dsrogers_> oh boy!  A new barque C object model!
19:00:31 <dsrogers_> may favorite!
19:00:35 <dsrogers_> *my
19:00:36 * lispy starts to wonder if this could possible be a type checker bug...seems unlikely though.
19:00:59 <erikc> grumble, i was hoping the opengl 3.0 red book would excise all the legacy nonsense
19:01:11 <lispy> edwardk: any chance you'd want to look at this? http://haskell.pastebin.com/m5d9c3c85
19:01:12 <erikc> so i could learn the 'relevant' opengl
19:01:21 <SamB_XP> Smokey`: isn't that what ALL OpenGL revisions consist of ?
19:01:29 <edwardk> so framebuffer objects are an EXT now, they formalized the 16 bit float stuff, added packedg depth and stencil formats, and thats about it?
19:01:35 <dsrogers_> That makes me want to wait for the opengl object model so I can write a two way bridge between gobject and opengl-object.
19:01:44 <dsrogers_> you know, because I like pain.
19:02:16 <solrize> heh, i saw something on slashdot about opengl 3.0 making developers "furious"
19:02:19 <edwardk> lispy: i know pretty much zero about darcs internals
19:02:35 <solrize> http://tech.slashdot.org/tech/08/08/11/2135259.shtml
19:02:35 <lambdac> Title: Slashdot | OpenGL 3.0 Released, Developers Furious
19:02:50 <lispy> edwardk: Well sure.  But, this is a type error.
19:03:15 <lispy> edwardk: the meaning of the code I can explain/deal with
19:03:49 <vixey> lispy is it too long to paste to channel?
19:03:55 <lispy> I'm wondering why it thinks that 'z' is escaping.  It would be bad for 'z' to escape, it's an existential type...but I can't see how it escapes
19:04:02 <lispy> vixey: yeah
19:04:11 <lispy> vixey: http://haskell.pastebin.com/m5d9c3c85
19:04:28 <vixey> will you paste it to me in PM?
19:04:33 <vixey> or is it too long for that
19:04:38 <edwardk> its pretty huge
19:04:44 <vixey> oh well then
19:04:46 <lispy> vixey: it's about 300 lines of error message
19:04:59 <Smokey`> SamB_XP: OpengL 3.0 was supposed to break backwards compatability, remove the legacy cruft, and bring in a new API with a new concept of 'everything is a blob od data' (object), described by a header...
19:04:59 <lispy> But, you can skip most of that, the function body is like 15 lines
19:05:01 <vixey> rip it up and start again I say
19:05:12 <SamB_XP> Smokey`: oh
19:05:26 <lispy> vixey: but, it's at that url if you just go there
19:05:36 <SamB_XP> I could have sworn I saw a draft that was nothing like that...
19:05:48 * vixey can't access HTTP
19:05:53 <SamB_XP> (then again possibly that was just OpenGL 2)
19:05:56 <lispy> vixey: ah, what can you access?
19:06:05 <vixey> IRC
19:06:16 <vixey> I actually can't open any new socket connections :/
19:06:20 <lispy> I could /msg you if you like
19:06:30 <SamB_XP> vixey: is it sockets or DNS that is the trouble?
19:06:36 <edwardk> so what is the expansion of FORALL(u v) (FL p :> GL p) C (u v)  ?
19:06:59 <Smokey`> SamB_XP: when khronos first took over OpenGL, they started releasing 'newsletters' - http://www.opengl.org/pipeline/ - of course, khronos eventually gave up on the community and left us in the dark for a year, to give us OpenGL 3.0 (which is being named OpenGL 2.2 by a lot of people)
19:07:01 <lambdac> Title: OpenGL Pipeline Newsletter - Q3 2006
19:07:15 <edwardk> 2.1.1 more like
19:07:30 <Smokey`> SamB_XP: all of them talk about the changes I mentioned in one form or another, none of them were implemented in OpenGL 3.0 (or rather, very few were)
19:07:48 * Smokey` shrugs
19:07:54 <SamB_XP> hmm, so what does khronos own exactly?
19:08:28 * BMeph doesn't understand 1) people who think of "operators" as being something different than "functions"; 2) people who think of "integers" as not being "real" numbers
19:08:46 <SamB_XP> BMeph: well, the integers is not the reals
19:08:56 <dibblego> BMeph, in Haskell, can I define my own operators? :)
19:09:09 <lispy> edwardk: forall u v. (FL p :> FL p) u v
19:09:12 <lispy> edwardk: So, C( foo ) -> foo, and FORALL( foo ) -> forall foo.
19:09:42 <edwardk> and (FL p)
19:09:48 <lispy> edwardk: and data p :> p x z where (:>) :: p x y -> p y z -> (p :> p) x z
19:09:53 <lispy> edwardk: that's just a type
19:09:57 <BMeph> SamB_XP: I mean literally...people who do not think of integers as being numbers.
19:10:33 <SamB_XP> BMeph: you mean they freak out if you say "sesame streat was brought to you today by the letter W and the number 3"?
19:10:41 <lispy> data FL p x y where NilFL :: FL p x x; (:>:) :: p x y -> FL p y z -> FL p x z
19:10:44 <SamB_XP> er. s/streat/street/
19:11:27 <Smokey`> SamB_XP: SGI gave Khronos the IP rights of the OpengL spec, and the right to continue managing the ARB (which is in charge of the future development of OpenGL).
19:11:35 <lispy> edwardk: does that make sense?
19:11:38 <lispy> edwardk: the 'z' that it finds comes out of the pattern match for (:>)
19:11:42 <edwardk> ok, so you universally quantify over the 'endpoints' of FL p :> FP p
19:12:23 <lispy> edwardk: well, end point of the first element is identical to the starting point of the second element, so we hide it
19:12:32 <lispy> edwardk: Ithink you have the right idea
19:12:35 <edwardk> i think you're doing something that fixes one of those types to the value of your existential, so that it doesn't get to the forall, it just see
19:12:41 <BMeph> SamB_XP: If they hadn't grown up watching the show, maybe. :|
19:13:05 <SamB_XP> BMeph: but they still don't believe that the number 3 is a number?
19:13:15 <lispy> edwardk: Normally I get this error message when the existential type gets exported via the return type.
19:13:20 <edwardk> yeah
19:13:26 <edwardk> thats when i usually run into it too
19:13:28 <lispy> I can't see how tht's happening here
19:13:37 <BMeph> SamB_XP: "Of course not. It's an Integer, silly!" ;p
19:13:41 <edwardk> i use a very similar construction to what you have here for my GRIN HOAS stuff
19:14:13 <SamB_XP> I get the people who don't see an operator as a function in programming-language terms ...
19:14:23 <edwardk> data Alt g a b = forall m. (:->) (Pat g a m) (m -> g b)
19:14:26 <SamB_XP> many programming languages are quite bad on this point!
19:14:48 <BMeph> SamB_XP: As in "Two is an integer. Two-and-a-half, is a 'real number.'" :P
19:15:02 <SamB_XP> hmm.
19:15:08 <SamB_XP> Two *is* an integer though.
19:15:12 <lispy> edwardk: here is an updated version with more explicit type sigs: http://haskell.pastebin.com/m3b7b9f64
19:15:32 <lispy> edwardk: look at the bottom for the update
19:15:59 <BMeph> SamB_Xp: But integers aren't real numbers - they're 'special'.
19:16:09 <BMeph> s/Xp/XP/ :)
19:17:09 * lispy adds even more type annotations
19:17:19 <lispy> edwardk: so, I take it the mistake is not obvious?
19:17:29 <vixey> 2 in N, 2 in Z, 2 in Q, 2 in R, ...
19:17:29 <edwardk> it currently looks like you're doing something to fix the type of the arguments u and v so they can't be universally quantified
19:17:37 <edwardk> heh
19:17:46 <edwardk> try killing the $ and replacing it with parens
19:18:01 <lispy> k
19:18:10 <edwardk> $s tend to slaughter universal quantification
19:18:31 <edwardk> you have a few littered through there, but i'm not sure if thats it]
19:19:16 <lispy> Hmm...nope
19:19:24 <lispy> Hmm...nope
19:19:26 <lispy> oops
19:19:31 <lispy> I removed all of them, no dice
19:19:53 <cjs> Hm. So what's the best way to catch "any exception"?
19:20:08 <lispy> edwardk: I'll go back to adding type sigs to see if I can get a more precise error
19:20:18 * SamB_XP wonders if the industry plan to fork OpenGL somehow
19:21:13 <BMeph> cjs: ...use the 'catch' function? :)
19:21:48 <idnar> SamB_XP: does the industry even care about OpenGL? I thought everyone was using DirectX now :P
19:21:54 <idnar> (or $CONSOLE_API)
19:23:16 <cjs> I've been using that, but it doesn't actually seem to catch some stuff, or I'm using it wrong.
19:23:53 <cjs> Ah, catch only catches IOErrors, right?
19:24:14 <cjs> So a standard, 'error "foo"' will not be caught by it, I'm guessing.
19:24:38 <cjs> Ah. "Non-I/O exceptions are not caught by this variant; to catch all exceptions, use catch from Control.Exception."
19:24:39 <lispy> iirc, the H98 defined catch sucks
19:24:52 <lispy> ?hoogle catch
19:24:53 <lambdac> A Hoogle error occured.
19:25:07 * lispy chastizes the broken bots
19:25:22 <SamB_XP> idnar: well there's a lot of mad people on http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=243303&fpart=1
19:25:24 <lambdac> http://tinyurl.com/5smebm
19:25:41 <cjs> lispy: I agree there.
19:25:54 <cjs> ?hoogle Control.Exception.catch
19:25:55 <lambdac> A Hoogle error occured.
19:26:13 <lispy> cjs: I'm no expert with the catches but I think you have the right one now
19:29:44 * lispy goes hog wild adding type sigs
19:29:57 <sjanssen> glguy: you were looking for me?
19:29:57 * lispy tosses :: around like candy
19:30:40 <idnar> @type catch
19:30:41 <lambdac> forall a. IO a -> (IOError -> IO a) -> IO a
19:30:49 <idnar> @type Control.Exception.catch
19:30:50 <lambdac> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
19:30:58 <idnar> @type error
19:31:00 <lambdac> forall a. [Char] -> a
19:32:00 <idnar> > return (error 'foo') `catch` (\x -> show x) -> (return "foo")
19:32:00 <lambdac>  Improperly terminated character constant at "'foo'..." (column 15)
19:32:09 <idnar> > return (error "foo") `catch` (\x -> show x) -> (return "foo")
19:32:09 <lambdac>  Parse error at "->" (column 45)
19:32:25 <idnar> > return (error "foo") `catch` (\x -> show x)
19:32:26 <lambdac>  Couldn't match expected type `IO a' against inferred type `String'
19:32:36 <idnar> > (return (error "foo")) `catch` (\x -> show x)
19:32:37 <lambdac>  Couldn't match expected type `IO a' against inferred type `String'
19:32:39 <idnar> ugh
19:32:45 <idnar> > (return (error "foo")) `catch` (\x -> return (show x))
19:32:46 <lambdac>  <IO [Char]>
19:33:03 <idnar> groan
19:33:25 <dibblego> @pl \x -> return (show x)
19:33:25 <lambdac> return . show
19:33:29 <cjs> lispy: Seems to work for me. thanks.
19:33:49 <lispy> :t \x y -> x `catch` (fmap y)
19:33:50 <lambdac>     Couldn't match expected type `IOError' against inferred type `f a'
19:33:50 <lambdac>       Expected type: IOError -> IO a1
19:33:50 <lambdac>       Inferred type: f a -> f b
19:33:56 <idnar> doesn't seem to work so well here
19:34:00 <idnar> Prelude Control.Exception> (return (error "foo")) `Control.Exception.catch` (\x -> return "error!")
19:34:03 <idnar> "*** Exception: foo
19:34:22 <cjs> idnar: I'm thinking you can't catch an improperly terminated character constant.
19:34:31 <idnar> well, no, I fixed that problem :P
19:34:35 <lispy> lol
19:34:51 <sjanssen> idnar: that is expected
19:35:07 <stepcut`> is the irc lib on hackage any good? Or is there something better ?
19:35:32 <idnar> sjanssen: so am I missing something, or does Control.Exception.catch not catch "error" execptions?
19:35:35 <idnar> *exceptions
19:35:37 <sjanssen> idnar: the exception is only thrown after the expression is evaluated
19:35:45 <sjanssen> idnar: error is not exactly an exception
19:35:56 <idnar> oh
19:36:03 <sjanssen> idnar: try (Control.Exception.evaluate (error "foo"))
19:36:11 <cjs> > error "boo!" `Control.Exception.catch` (\e -> putStrLn $ "Yuppers! It's a " ++ show e)
19:36:13 <lambdac>   Not in scope: `Control.Exception.catch'
19:36:16 <sjanssen> with the `catch` stuff at the end
19:36:40 <cjs> Yah, well it works in ghc. Where's lambdabot? She knew how to find these sorts of things.
19:36:46 <idnar> ok, that works
19:36:55 <dibblego> @seen lambdabot
19:36:55 <lambdac> I saw lambdabot leaving #haskell 8h 5m 20s ago, and .
19:37:05 <cjs> Huh. I was here then!
19:37:10 <idnar> cjs: you'd just get <IO [Char]> anyway
19:37:16 <idnar> > (Control.Exception.evaluate (error "foo")) `Control.Exception.catch` (\x -> return "error!")
19:37:16 <lambdac>   Not in scope: `Control.Exception.catch'
19:37:19 <idnar> "error!"
19:37:28 <idnar> cjs: err, <IO ()> I guess
19:37:40 <cjs> Wow, throwIO is cool.
19:46:44 <lispy> what is a good name for this funtion? (a -> c) -> (b -> d) -> Either a b -> Either c d
19:46:56 <lispy> Iwas thinking I might callit both
19:48:08 <Eelis> lispy: isn't that the bifunctor equivalent of fmap?
19:48:22 <Eelis> if so, define a bifunctor type class and call it bimap or something :)
19:48:33 <atp_> Eelis: already exists
19:48:36 <atp_> bimap i mean
19:48:36 <lispy> hehe, I have no idea.  I just know that it would be really handy right now
19:48:42 <lispy> :t bimap
19:48:42 <atp_> it doesn't have quite that type signature
19:48:43 <lambdac> Not in scope: `bimap'
19:48:47 <atp_> it's in category-extras
19:48:55 <atp_> i don't think lambdabot imports it
19:49:00 <lispy> I need to do this without bringing in extra libs
19:49:24 <lispy> I think I'll just go with my local def
19:49:50 <atp> bimap in category extras works with any bifunctor, not just Either
19:51:37 <Eelis> atp: i am aware, hence my suggestion of using a type class :)
19:52:05 <vixey> :t either
19:52:06 <lambdac> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:52:50 <vixey> something about this bugs me
19:53:11 <Elly> I need something to do
19:53:32 <Elly> writing C is irritating for some reason
19:53:45 <dibblego> gee I wonder what that reason might be
19:53:56 <Elly> usually I rather like C
19:54:06 <TomMD> dibblego: Every time I write C, my compiler inserts a bug... I swear.
19:54:18 <dons> that's the spirit, TomMD :)
19:54:24 <dibblego> TomMD, part of the C standard
19:54:29 <dons> heh
19:55:09 <humasect> Couldn't match expected type `Data.ByteString.Internal.ByteString' against inferred type `ByteString' --- In the first argument of `useAsCStringLen', namely `(nviPixels i)' --- nviPixels is :: ByteString ... should this kind of thing happen ?
19:55:16 <cjs> vixey: What bugs you about it?
19:55:31 <vixey> I don't know
19:55:36 <cjs> humasect: Your other ByteString is probably a different flavour.
19:55:56 <TomMD> Do you have your Strict and Lazy strings in order?
19:55:59 <cjs> There are at least four, Data.ByteString, ....Char8, ....Lazy, ....Lazy.Char8.
19:56:00 <humasect> cjs: this was working with [Word8] ByteString, but now there is only [Char8]
19:56:09 <cjs> Yes, those are two different flavours.
19:56:10 <humasect> TomMD: just using Lazy
19:56:15 <dons> humasect: either you're mixing strict and lazy bytestrings, or you're mixing bytestrings from different packges.
19:56:31 <humasect> cjs: right. this was working when there was only Word8. now there is only Char8, and it is not
19:56:36 <dons> don't use the module name space for types.
19:56:37 <cjs> he's mixing Char8 and non-Char8 (Word8).
19:56:38 <humasect> hmm
19:56:39 <dons> that's the lesson here.
19:56:55 <dons> cjs, that's not a type error though.
19:57:03 <dons> they're the same type, just with different encodings.
19:57:03 <humasect> dons=)
19:57:32 <dons> anyone play with the hipmunk 0.2 demo?
19:57:35 <dons> it's all rather awesome.
19:57:41 <humasect> there is only Char8 being imported, or is useAsCStringLen only allowed with Word8 ?
19:57:44 <vixey> (x->p) -> (y->q) -> Either x y -> Either p q
19:57:45 <lispy> :t uncurry
19:57:47 <lambdac> forall a b c. (a -> b -> c) -> (a, b) -> c
19:57:49 <humasect> because GZip needs Char8.
19:57:54 <vixey> x -> p
19:57:57 <dons> gzip takes lazy bytestrings, doesn't it?
19:57:58 <vixey> +    +
19:57:58 <cjs> dons: It's not a type error?
19:58:02 <vixey> y -> q
19:58:06 <lispy> So, curry is the one that makes a function into a tuple consumer?
19:58:07 <humasect> ah i see, dons.
19:58:11 <dons> cjs, not to mix Char8 and Word8 versions of the *same* bytestring. the type is the same.
19:58:19 <dons> it is a type error to mix strict and lazy bytestrings though
19:58:23 <lispy> :t curry
19:58:24 <lambdac> forall a b c. ((a, b) -> c) -> a -> b -> c
19:58:28 <cjs> dons: I mean, I think I'll believe you, because for some reason I think you understand ByteStrings pretty well. :-)
19:58:37 <lispy> Oh, no it's uncurry...I always get that backwards
19:58:37 <dons> it's all my fault, yes.
19:58:54 <cjs> Ah, so he must be mixing strict and Lazy ones, then. Which of course they have to be different types.
19:59:15 <dons> humasect: so you'll either need to make one type lazy, or the other strict.
19:59:15 <humasect> ok, so what i think it is : useAsCString comes from Word8 package, which conflicts with Char8 package. so then another way is used with Char8 to get similar functionality to useAsCString
19:59:16 <vixey> haskell functions are curried
19:59:39 <cjs> But thanks, that Word8 and Char8 are the same type is good to know. So basically, you just have two modules with the same function names, working on the same base types, but with different signatures for some of the various return values, right?
19:59:40 <humasect> dons: there is only Lazy and only Char 8, except the function useAsCString comes from Word8
19:59:56 <humasect> oh, ouch, cjs..
20:00:08 <cjs> humasect: Actually, that works pretty well for me.
20:00:34 <sjanssen> dons: who do we poke to install darcs 2 on code.haskell.org?
20:00:43 <cjs> The issue, now that I think about it, is the lazy-vs.-non-layz distinction.
20:00:45 <humasect> i have them mixed in another file as BW and BC because zlib seemed to want Char8 and pngload wanted Word8
20:00:49 <cjs> sjanssen: You mean git? :-)
20:01:24 <humasect> oh, cjs ? it seems to make sense. there is no useAsCString for Lazy so i will look around.
20:01:30 <dons> sjanssen: hmm.
20:01:30 <sjanssen> cjs--
20:01:37 <SamB_XP> sjanssen: hmm, I have an old beta somewhere in neil's home directory ;-)
20:01:37 <cjs> humasect: Anyway, have you checked that you're using Data.ByteString and Data.ByteString.Char8, or Data.ByteString.Lazy and Data.ByteString.Lazy.Char8, but not mixing them?
20:01:38 <dons> sjanssen: dcoutts
20:01:50 * cjs shrinks by one.
20:01:54 <sjanssen> @karma cjs
20:01:54 <lambdac> cjs has a karma of -1
20:01:59 <sjanssen> cjs++ -1 isn't fair
20:02:05 <dons> it's been a while since we've broken an xmonad repo due to darcs.
20:02:07 <cjs> Darn, really!
20:02:07 <dons> i wonder why that is.
20:02:17 <dcoutts> sjanssen: we're onto it
20:02:18 <dons> the 2.0 upgrade ?
20:02:31 <humasect> cjs: yep that's right. there is just import Data.ByteString.Lazy.Char8 as BC, and import Data.ByteString (useAsCStringLen) <- so i am looking for replacement.
20:02:35 <edwardk> lispy: that was bimap for Either, there is a version in category-extras
20:02:41 <edwardk> @type (+++)
20:02:43 <lambdac> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
20:02:43 <sjanssen> dcoutts: great
20:02:49 <edwardk> thats another definition for it
20:03:00 <dcoutts> sjanssen: we're doing some large scale correctness and performance tests, before we upgrade
20:03:13 <humasect> and as well unsafeUseAsCString cannot be used too. i don't have the resources to make copies of them !
20:03:23 <lispy> I could try to use arrows, where is that defined?
20:03:25 <vixey> edwardk aha!
20:03:36 <dons> dcoutts: what lives on code.haskell.org that this effort is being made?
20:03:38 <edwardk> Control.Arrow
20:03:42 <lispy> Control.Arrows.(+++)?
20:03:45 <lispy> ah no s
20:03:45 <edwardk> import Control.Arrow ((+++))
20:03:55 <dons> dcoutts: since i'd have thought xmonad was probably the main thing to worry about, and we've all moved to darcs 2.
20:04:01 <vixey> I just didn't make the jump from -> to arrow
20:04:07 <SamB_XP> dons: well, the GHC repository for one ...
20:04:26 <edwardk> vixey: whats causing you to not be able to open other sockets?
20:04:29 <dons> doesn't live on code.haskell.org, SamB_XP
20:04:38 <SamB_XP> oh right
20:04:39 <vixey> router stuff
20:04:45 <SamB_XP> confused am I
20:04:55 <dons> it's ok, you missed the point entirely.
20:04:59 <dcoutts> dons: 153 repos
20:04:59 <dcoutts> dons: the code.h.o admins don't want to be responsible for breaking those :-)
20:05:25 <dons> oh, i suppose there might be issues with darcs 1.0.x pushing to a 2.0 machine.
20:05:29 <dons> that'd be rarely tested.
20:05:43 <dcoutts> dons: gtk2hs and wxhaskell are a couple of the bigger ones
20:05:46 <lispy> ?pl uncurry . flip
20:05:46 <lambdac> uncurry . flip
20:05:50 <SamB_XP> dons: how so?
20:05:54 <dons> dcoutts: ok.
20:06:10 <edwardk> @type uncurry . flip
20:06:11 <lambdac> forall a b c. (a -> b -> c) -> (b, a) -> c
20:07:03 <edwardk> ah one half of the adjunction between (,)e and (->)e
20:07:23 <dcoutts> dons: right, that's one of the senarios we want to test, a mixture of v1 and v2 clients pushing/pulling to darcs v2 on the server side
20:08:01 <dcoutts> dons: and we'd like to measure the improvement in darcs pull/push times over ssh
20:08:32 <sjanssen> dcoutts: I don't think there are supposed to be any improvements unless the darcs 2 format is used
20:08:38 <dons> you think there'll be improvements?
20:08:47 <lispy> dcoutts: pulling shouldn't be an issue, should it?  That' just happens over http and doesn't concern the remote darcs.
20:09:31 <lispy> sjanssen: if the remote exe is darcs2 and the local one is darcs2 there can be some ssh goodness that speeds it up.
20:10:02 <lispy> Although, maybe pulling over ssh is different.  kowey would know better.
20:10:06 <dcoutts> dons: yes, using darcs v1 formats on both ends but using darcs 2 on the client and server side. It uses far fewer ssh connections (2 rather than N)
20:10:11 <shapr> Has anyone here tried halp?
20:10:24 * SamB_XP wonders why he's using PuTTY to work remotely when the computer he is working remotely on is right in front of him ... suspects he is afraid he'll start programming if he flips the KVM over or something like that...
20:10:46 <lispy> shapr: not i!
20:10:50 <dcoutts> lispy: pull over ssh
20:11:22 <shapr> Haskell Active Literate Programming... sure sounds cool.
20:11:31 <lispy> dcoutts: okay, then hmm..I think that test only requires a local darcs2.  It shouldn't invoke the remote darcs for pulling
20:11:33 <dons> dcoutts: don't we get that normally using master/slave?
20:11:34 * dcoutts notes the reason darcs v1 used N ssh connections was a bug in OSX's impl of ssh's control master feature
20:11:35 <noecksit> hello, i am just curious, what is the difference between happy and parsec? maybe they have different scopes?
20:11:35 <vixey> what does Active mean?
20:11:41 <dons> at least, i always use master/slave with darcs since 1.x
20:11:52 <dons> does darcs do that itself now, i guess?
20:12:13 <lispy> noecksit: one is a parsing combinator library, and the other is like bison in that you define a grammer and you get a parser as output
20:12:14 <dons> noecksit: different   technologies
20:12:26 <dons> both for writing parsers though, of course.
20:12:35 <edwardk> shapr: HALP!
20:12:49 <shapr> edwardk: exactly!
20:12:51 <dons> dcoutts: so since i already use master/slave to darcs/ssh, i won't see a speedup over ssh, i suspect.
20:12:56 <shapr> edwardk: http://www.accesscom.com/~darius/hacks/halp.tar.gz
20:12:58 <Dzlk> noecksit: Parsec is for recursive descent parsers, happy is (I believe) bottom-up, yacc-style.
20:13:06 <SamB_XP> noecksit: try both and see!
20:13:30 <dcoutts> dons: right, darcs does it itself, so it can use a single connection and bypass buggy impls of ssh control master
20:13:38 <Dzlk> I wouldn't expect they overlap much.
20:13:54 <noecksit> ahh, its too bad happy is not in the arch linux aur
20:13:59 * Dzlk hasn't had occassion to use happy.
20:14:03 <dons> noecksit: sure it is!
20:14:12 <dons> noecksit: it's in community.
20:14:30 <dons> noecksit: extra/happy 1.17-1 The Parser Generator for Haskell
20:14:57 <lispy> the vcs thread on glasgow-haskell-users reminds me of looooongcat
20:15:10 <noecksit> dons: oh then its a binary, i was looking in the wrong place
20:15:28 <dons> lispy, long cat can't reach consensus
20:17:19 <lispy> dons: yeah.  good points on both sides of the fence
20:18:00 <lispy> dcoutts: I don't have a c.h.o login
20:18:23 <lispy> I think I asked about this once and was told to upload a pubkey somewhere
20:18:36 <ddarius> @where community
20:18:36 <lambdac> I know nothing about community.
20:18:44 <ddarius> Curse you fake lambdabot.
20:18:59 <ddarius> http://community.haskell.org/admin/account_request.html
20:19:00 <lambdac> fine then, I'll leave
20:19:01 <lambdac> Title: Account Request
20:19:10 <lispy> code.haskell.org should maybe have an index.html?
20:19:26 <dcoutts> lispy: ah, you should sign up
20:20:02 <ddarius> lispy: I have a code.haskell.org account and I only pretend to write Haskell.
20:20:05 <dcoutts> lispy: http://community.haskell.org/admin/account_request.html
20:20:42 <lispy> dcoutts: filling out the form now
20:20:50 <lispy> dcoutts: so I can get that tarball for forensics :)
20:20:55 <shapr> preflex: @seen lambdabot
20:22:27 <lispy> dcoutts: request submitted
20:22:47 <dcoutts> lispy: right
20:23:05 <adu> hi
20:23:12 <adu> i have a mission today
20:23:29 <shapr> What is your mission?
20:23:57 <dcoutts> great
20:24:26 <vixey> save the world
20:24:32 <adu> to understand/appreciate the ReadS/ShowS things
20:24:37 <shapr> vixey: Good mission
20:24:43 <adu> I currently appreciate Read/Show
20:24:49 <shapr> adu: Isn't that just turning string concatenation into function application?
20:24:51 <adu> but am clueless about ReadS/ShowS
20:25:04 <adu> shapr: I don't know, thus the mission...
20:25:09 <shapr> adu: oh
20:25:22 <vixey> > let cons = (.) . (:) ; nil = id in ( cons 1 (cons 2 (cons 3 nil)) ++ cons 66 (cons 77 nil) ) []
20:25:35 <humasect> thanks everyone~
20:25:46 <shapr> vixey: bzzt
20:25:50 <shapr> @users
20:25:52 <shapr> :-(
20:25:59 <adu> shapr: I thought you were a noob :P
20:26:08 <shapr> adu: Oh right!
20:26:14 <shapr> adu: Quick, tell me about Haskell!
20:26:17 * shapr oops
20:26:29 <vixey> adu> let cons = (.) . (:) ; nil = id in ( cons 1 (cons 2 (cons 3 nil)) ++ cons 66 (cons 77 nil) ) []
20:26:32 <dons> shapr: did you see we reached 507 users last week?
20:26:43 <ddarius> dons: Last week?
20:26:43 <adu> shapr: well, there are these classes called "ReadS" and "ShowS"
20:26:44 <shapr> adu: I'm not really a noob, I had a Haskell job for about a year.
20:26:44 <vixey> adu{ (++) = mappend }
20:26:47 <shapr> dons: That's awesome!
20:26:49 <dons> or two weeks ago, sorry.
20:27:00 <shapr> dons: I'm thrilled!
20:27:55 <adu> whats the diff between (:) and ((.) . (:))?
20:28:06 <lispy> Interesting, the inferred type is right but the expected type is wrong.  That's the opposite of my usual type errors :)
20:28:12 <shapr> (:) :: a -> [a] -> [a]
20:28:25 <shapr> ((.) . (:)) :: a1 -> (a -> [a1]) -> a -> [a1]
20:28:33 <vixey> (.) . (:) :: a -> ([a] -> [a]) -> ([a] -> [a])
20:28:45 <dons> shapr: good steady growth.
20:28:46 * shapr hugs vixey 
20:28:50 <vixey> :))
20:28:55 <shapr> dons: Yeah, keeping the community, growing the community.
20:29:07 <adu> am I community? :)
20:29:08 <dons> shapr: http://www.nabble.com/-haskell-irc-channel-reaches-500-users-td18720578.html
20:29:12 <shapr> adu: You are!
20:29:15 <dons> i did a little announce.
20:29:17 <adu> shapr: :)
20:29:28 <shapr> dons: Oh, I spent Saturday night with five PL grad students, that was fun.
20:29:35 <shapr> Er, spent the night drinking, that is...
20:29:53 <shapr> Now I want to go neu.edu...
20:30:04 <chessguy> naturally. what else would one do with five PL grad students?
20:30:14 <shapr> chessguy: Write code?
20:30:32 <chessguy> PL grad students can write code? :)
20:30:44 <shapr> One of them, Dan Brown, used to hang out here as danb, and we talked about his Haskell music playlist stuff.
20:31:07 <chessguy> heh. not dan brown, the author, i take it
20:31:08 <shapr> Another one of them I met accidentally at a party where someone introduced me by name and he said "Hey, that guy started #haskell!"
20:31:16 <ddarius> shapr, so how do ou feel about being listed as one of the revolutionaries when Haskell takes over the world?
20:31:28 <dons> shapr: heh
20:31:32 <shapr> ddarius: As long as they don't put me up against the wall for my recent use of C#...
20:31:57 <lowki_> tsk tsk
20:32:02 <ddarius> shapr: C# is probably safe enough.  If it was Java you might've had a problem.
20:32:10 <QtPlatypus> chessguy: You mean you haven't read his latest work "The davinchi monad"?
20:32:10 <shapr> whew
20:32:20 <shapr> dons: Anyway, Felleisen teaches at neu.edu...
20:32:27 <shapr> and so does Olin Shivers
20:32:38 <ddarius> shapr: Is Shriram there?
20:32:43 <shapr> And Norman Ramsey is at Tufts... lots of awesome PL stuff here :-)
20:32:54 <shapr> ddarius: I thought he was on the west coast somewhere.
20:32:56 * shapr asks google
20:33:35 <dsrogers> I think I found another forall identity
20:33:36 <lowki_> i need to load a specific text file for program to work .i how do i find out the installation directory?
20:33:45 <lowki_> if using cabal?
20:34:03 <shapr> ddarius: Oh, yes... Providence, RI.. about an hour's drive away.
20:34:08 <dsrogers> forall a .(forall b. (a-b)) <==> forall a b. (a->)
20:34:21 <ddarius> Brown in Rhode Island
20:34:30 <dsrogers> err, only (a->b) in the right places.
20:34:38 <shapr> Yeah, I must disorganize a New AngloHaskell...
20:34:38 <gwern> lowki_: easy, use the paths stuff
20:35:02 <lowki_> is there haskell specific functions that allow that kind of information to be accessed?
20:35:42 <ddarius> Yes, forall a b.X == forall b a.X
20:35:48 <ddarius> Similarly for exist.
20:35:59 <vixey> shapr :D
20:36:14 <ddarius> shapr: It would need to be regional it seems.
20:36:16 <gwern> lowki_: yes, as I said
20:36:16 <shapr> vixey: Will you show up?
20:36:29 <lowki_> gwern: so shell commands?
20:36:36 <ddarius> Why does America have to be so big?
20:36:41 <dsrogers> I suppose that obvious from logic.  Universal quantifier is associative.
20:36:43 <vixey> sorry,..
20:36:44 <gwern> no, there is cabal functionality for this
20:36:54 <shapr> vixey: It's just a short swim!
20:36:57 <shapr> The 'other' channel.
20:36:59 <lowki_> oh is t in the defualt tutorial?
20:36:59 <vixey> dsrogers: More like, type application is implicit
20:37:07 <shapr> Ya know, the West channel.
20:37:10 <gwern> lowki_: I don't have time to explain; look at ndm's blog for a short article/tutorial
20:37:14 <vixey> shapr, I don't think I've even been that far from home
20:37:22 <ddarius> vixey: So?
20:37:30 <lowki_> gwern: a link of some kind would be nice
20:37:41 <shapr> vixey: Well, I've been to both Cambridges.
20:38:07 <lowki_> so is haskell like the top of computing?
20:38:21 <lowki_> lol
20:38:23 <ddarius> Is computing a big heap?
20:38:29 <lowki_> maybe
20:38:59 <lowki_> i'm getting a book on compilers: procedural, logical, functional, parallel and distributed
20:39:11 <dsrogers> I should suggest we write our application at work in haskell.  See out many takers...
20:39:15 <dsrogers> *how
20:39:21 <shapr> dsrogers: I tried that too.
20:39:24 <adu> so ShowS is a more efficient implementation of ("string" ++)?
20:39:31 <lowki_> so rpoku should have all those programming implementations
20:39:34 <shapr> dsrogers: But my workplace thinks IronPython.NET is scary stuff.
20:39:39 <dsrogers> lol.
20:40:01 <lowki_> but i want to make initial 0.1 rpoku release on sourceforge  so need that cabal stuff with the installation directory
20:40:28 <dsrogers> my workplace would mostly bitch about having to install ghc or that it doesn't run in a jvm.
20:40:56 <shapr> We use C#
20:40:57 <dsrogers> we already have 7 or so languages in our app
20:41:03 <shapr> I was asked to make a .NET script, so I used IronPython.
20:41:06 <shapr> They were not amused.
20:41:17 <lowki_> hmmm
20:41:22 <Nafai> shapr: That's silly
20:41:26 <shapr> Nafai: Yeah well.
20:41:46 <vixey> adu, exactly
20:41:47 <dsrogers> java, javascript, python, perl, ruby, scheme, C#, C++ and flex.
20:41:51 <dsrogers> I may have missed one.
20:41:52 <dibblego> shapr, teach language zealots that zealotry is a euphemism for incompetenc
20:41:57 <dsrogers> mostly java though.
20:41:58 <vixey> adu, toDlist = (++) ; fromDlist = ($)
20:42:04 <shapr> dibblego: What does that say about me and Haskell?!
20:42:08 <vixey> adu, cons = (.) . (:) ; nil = id
20:42:09 <vixey> oops
20:42:13 <vixey> fromDlist = ($ [])
20:42:15 <dibblego> shapr, that you make practical decisions of course :)
20:42:21 <shapr> whew
20:42:25 <vixey> (++) = (.)
20:42:30 <Pseudonym> Haskell doesn't have any zealots.
20:42:34 <vixey> this is the speed boost
20:42:39 <Pseudonym> Zealotry is a sign of success, and we avoid success at all costs.
20:42:40 <vixey> O(1) instead of O(n)
20:42:41 <shapr> vixey: Anyway, feel free to visit Boston, you can crash in my spare room.
20:42:49 <shapr> Pseudonym: Oh, I just thought we were all too lazy.
20:42:51 <shapr> um, I mean non-strict
20:42:59 <Pseudonym> ?go "be an advocate, not an asshole"
20:43:03 <lispy> lazy bottoms
20:43:05 <Pseudonym> Oh, no lambdabot.
20:43:16 * shapr misses lambdabot
20:43:24 * Pseudonym sniffs
20:43:30 * lispy pours out som liquor for lambdabot
20:43:33 <shapr> @hello
20:43:33 <lambdac> Maybe you meant: help tell
20:43:41 <shapr> Pseudonym: Hey, is that the *original* lambdabot?
20:43:55 <Pseudonym> No.
20:44:05 <shapr> aww
20:44:06 <Pseudonym> It can't be the original lambdabot if it has spelling correction.
20:44:12 <adu> wow the more I learn about ShowS the more I find I knew nothing about Show...
20:44:34 * lispy pulls his hair out over type errors
20:44:42 <lispy> This is insane
20:45:20 <Pseudonym> adu: The full ShowS is _cool_.
20:45:25 <Pseudonym> Seriously cool.
20:45:41 <vixey> why?
20:46:06 <lispy> vixey: oh, don't let Pseudonym fool you.
20:46:15 <Pseudonym> The operator precedence stuff.
20:46:23 <shapr> g'day seafood
20:46:28 <shapr> Mr Sean!
20:46:31 <Pseudonym> I find it so useful I've had to reproduce it several times.
20:47:19 <dmwit> ?join #haskell-blah
20:47:19 <lambdac> Not enough privileges
20:47:45 <vixey> @boing
20:47:46 <lambdac> Maybe you meant: join ping ring
20:47:48 <Pseudonym> ?join #haskell-blah
20:47:48 <lambdac> Not enough privileges
20:48:16 <lispy> ?ring
20:48:29 <lispy> ?ring ring ring banana phone!
20:51:20 <lispy> Huh, I think the type error I'm seeing might be because either is not polymorphic enough for me
20:51:36 * lispy writes an either replacement as a test
20:53:44 <exbios> clear
20:54:29 <lispy> Hah, that certainly changed all my type errors, but it's not right 'either'
20:54:32 * shapr smacks two paddles on exbios' heart
20:54:51 <shapr> CLEAR!
20:55:17 <shapr> hi exbios! Are you learning Haskell?
20:55:40 <exbios> yes
20:55:45 <dmwit> lispy: Still fighting with that either thing?
20:55:46 <shapr> How do you like it so far?
20:55:51 <lispy> dmwit: aye
20:56:06 <dmwit> lispy: What are you starting with/what do you want to happen?
20:56:14 <exbios> im newbie
20:56:20 <lispy> dmwit: well....
20:56:20 <exbios> i not understad much
20:56:48 <lispy> dmwit: I have, types like Either (p x y) (p y x)
20:57:06 <lispy> dmwit: and I have functions like, (forall x y. p x y -> IO ())
20:57:11 <dcoutts> lispy: you should be able to log in to c.h.o now
20:57:21 <lispy> dmwit: so, I want to do, either foo foo myEither
20:57:23 <lispy> dcoutts: cool, thanks
20:57:45 <dsrogers> :t undefined
20:57:47 <lispy> dcoutts: yay, I landed on nun
20:57:47 <lambdac> forall a. a
20:58:08 <dmwit> lispy: That should be totally fine.
20:58:17 <dmwit> lispy: Maybe you should paste what you've got...?
20:58:17 <dsrogers> what is "undefined"
20:58:17 <lispy> dcoutts: do you have a recommendation on a resumable way to start that download?
20:58:26 <lispy> dmwit: k...but it's ugly...just a sec
20:58:50 <lispy> dmwit: an earlier version is here: http://haskell.pastebin.com/m3b7b9f64
20:59:32 <dcoutts> lispy: hmm, perhaps I should make it available by http
20:59:52 <lispy> dmwit: here is the current mess: http://haskell.pastebin.com/m486f683d
21:00:14 <lispy> dcoutts: what about rysnc over ssh?
21:00:24 <dsrogers> in particular I have the expression "undefined:: Type"
21:00:30 * lispy has little or no experience with rsync
21:00:41 <dmwit> FORALL? FL? ...
21:00:50 <lispy> dmwit: hang on, it's not so bad
21:01:05 <lispy> dmwit: FORALL(f) = forall f.
21:01:06 <ddarius> dsrogers: undefined = undefined
21:01:11 <lispy> dmwit: C(f) = f
21:01:21 <lispy> dmwit: those are just macros
21:01:24 <dsrogers> ddarius: I still don't understand.
21:01:40 <vixey> lispy, how do you make macros ?
21:01:52 <lispy> dmwit: data FL a x y where NilFL :: FL a x x; (:>:) :: a x y -> FL a y z -> FL a x z
21:02:08 <ddarius> dsrogers: That's conceptually the definition of undefined.
21:02:10 <lispy> vixey: compile with -cpp and then it's like like C
21:02:27 <lispy> dmwit: FL stands for forward list
21:02:28 <dmwit> lispy: Whoooo boy.
21:02:31 <dsrogers> ddarius: so it just barfs an error when encountered?
21:02:34 <dino-> I've used undefined to get the compiler to build with non-exhaustive patterns for things here and there.
21:02:35 <vixey> oh :/
21:02:52 <ddarius> dsrogers: In most implementations, yes, but an infinite loop is also completely acceptable.
21:02:59 <newsham> undefined is awesome for working on proofs when you're not done yet
21:03:01 <Dzlk> dsrogers: (undefined :: Type) is idiom for a place where you need a value of a given type but don't care what the value is. It's assumed the value won't be referenced.
21:03:01 <lispy> dmwit: oh and data p :> p x z where (:>) :: p x y -> p y z -> (p :> p) x z
21:03:04 <newsham> but you still wanna see if what you have is working
21:03:38 <lispy> dmwit: yeah, it's...um hard to work with, but I'm reeally resisting maing a more minimal example.  i've had bad luck with actuallyrecreating the errors
21:04:14 <dmwit> It's an awful lot of type-hackery you're trying to do there.
21:04:23 <lispy> dmwit: yeah :(
21:04:32 <dmwit> Are you just playing with GADTs, existentials, etc. or is there some other reason?
21:04:43 <lispy> dmwit: haha, there is some other reason
21:04:46 <lispy> dmwit: this is part of darcs
21:04:50 <dino-> I had also used undefined a couple of times when using QuickCheck and instancing Arbitrary. When I didn't need to define coarbitrary but the compiler, not so happy about no definition.
21:04:57 <lispy> dmwit: I'm just showing you because you asked :)
21:04:58 <dmwit> <3 legacy code
21:05:01 * dmwit nods
21:05:27 <dmwit> I actually suspected it was part of darcs from the existence of the string "patch".
21:05:29 <dmwit> =P
21:05:39 <dmwit> ...also, DarcsFlag
21:05:48 <dcoutts> lispy: try wget -c http://code.haskell.org/~duncan/code.h.o.tar.gz
21:05:49 <lispy> But this module is killer
21:05:55 <lispy> dcoutts: thanks, will do
21:06:05 <dino-> That was going to be split, I thought, into two typeclasses. The QuickCheck
21:06:05 <dsrogers> in what situation would you need to specify the type of a particular variable, yet never reference it?
21:06:09 <dsrogers> oh.
21:06:14 <dsrogers> in a constructor....
21:06:31 <dsrogers> so you get the right type classes, even though you'll never ever use the variable.
21:06:58 <dcoutts> lispy: I presume you know why darcs changes foo is slow (I'm guessing because it doesn't know stuff per-file, only globally). Do you know how hard that'd be to improve?
21:07:02 <lispy> dsrogers: phantom type stoo if iunderstand the question
21:07:20 <adu> > shows (2::Int) " bits"
21:07:21 <lambdac>  "2 bits"
21:07:22 <lispy> suddenly my connection is low
21:07:24 <adu> :)
21:07:48 <Pseudonym> shave && haircut
21:07:56 <lispy> dcoutts: I'm not sure.  That is bplausible
21:08:21 <lispy> dcoutts: We could certainly cache which files are affected by which patches
21:08:30 <mauke> preflex: @seen lambdabot
21:08:31 <preflex>  lambdabot was last seen on #haskell 1 day, 6 hours, 33 minutes and 26 seconds ago, saying: Data.List.intercalate :: [a] -> [[a]] -> [a]
21:09:18 <adu> > showString "shave and a haircut " $ shows (2::Int) " bits"
21:09:19 <lambdac>  "shave and a haircut 2 bits"
21:09:20 * dmwit gives up
21:09:43 <dmwit> I can't even see how "p2c ps" would type-check, and that's the very first expression *on* that page.
21:09:45 <lispy> dmwit: it's cool
21:09:52 <dcoutts> lispy: if that'd help darcs changes and annotate then the ghc hackers would be happy
21:10:07 <SamB_XP> dcoutts: what?
21:10:17 <SamB_XP> how would that make them happy?
21:10:27 <lispy> dcoutts: right, those are biggies.  I saw SimonM's thread
21:10:31 <dcoutts> SamB_XP: I don't mean they'd change their mind, but it's one of the major performance complaints
21:10:34 <lispy> dcoutts: we saved that feedback
21:11:35 <adu> so is ReadS at all similar to Parsec?
21:12:05 <dmwit> adu: It is another kind of parser.
21:12:08 <vixey> @src ReadS
21:12:09 <lambdac> Source not found. And you call yourself a Rocket Scientist!
21:12:22 <dmwit> adu: But it was made to deal with potentially ambiguous parses, which is a bit different than Parsec.
21:12:25 <lispy> dcoutts: I would need to look at the code for that command, and then think about it.  What I don't know off the top of my head is if knowing which patches touch a file allows you to reconstruct what you need to know or if you need to commute thingsanyway
21:12:42 <Dzlk> > showString "shave and a haircut " $ show ((1::Word8)/4)
21:12:43 <lambdac>   add an instance declaration for (Fractional Word8)
21:12:50 <dmwit> adu: ...and that is about the extend of my knowledge of ReadS. =)
21:13:19 <adu> dmwit: so instead of fixing ambiguity, it embraces it?
21:13:22 <dmwit> Dzlk: Use `div` instead, maybe.
21:13:41 <dmwit> adu: Right, and you can tell by the type of reads.
21:14:20 <lispy> dmwit: that (p2c ps) works ilke this.  p2c generates two possibilities, and then either applies whichever one happned.
21:14:23 <dcoutts> lispy: right.
21:14:25 <Dzlk> dmwit: Then you'd get it for free.
21:14:29 <Pseudonym> Meet the original lambdabot, circa February 2003.
21:14:34 <Dzlk> > ((1::Word8) `div` 4)
21:14:35 <lambdac>  0
21:14:58 <mauke> @eval 2+2
21:14:59 <dmwit> lambdac: help!
21:15:02 <dmwit> whoops
21:15:06 <Pseudonym> ?msg lambdabot @msg #haskell Hi, I can't do a damn thing.
21:15:06 <lambdac> Not enough privileges
21:15:14 <lambdabot> Hi, I can't do a damn thing.
21:15:18 <lispy> dcoutts: there is someone working on a metadata cache and a dependency graph module right  now.
21:15:23 <Pseudonym> Apart from sockpuppet, anyway.
21:15:30 <Pseudonym> lambdabot: @hello
21:15:31 <lambdabot> Sorry, I'm not a very smart bot yet.
21:15:36 <dmwit> heh
21:15:40 <vixey> @vixey
21:15:42 <lambdac> you sound like an awesome guy... are you single?
21:16:00 <lambdabot> I was sexless at this stage of development.
21:16:15 <mauke> @vixey you know you want it
21:16:15 <lambdac> i think i know
21:16:30 <dcoutts> lispy: oh cool
21:16:39 <Pseudonym> lambdabot: @join #haskell-blah
21:16:39 <lambdabot> Sorry, I'm not a very smart bot yet.
21:16:59 <vixey> huh ??
21:17:05 <vixey> lambdabot: @run 2
21:17:06 <lambdabot> Sorry, I'm not a very smart bot yet.
21:17:18 <Pseudonym> vixey: This is lambdabot v0.1A.
21:17:31 * Pseudonym did some code archeology
21:17:52 <Pseudonym> And I had to fix up a couple of things, like FiniteMap -> Data.Map and Socket -> Network.
21:18:02 <SamB_XP> Pseudonym: WHY?
21:18:06 <SamB_XP> @about
21:18:06 <lambdac> Unknown command, try @list
21:18:08 <SamB_XP> @version
21:18:09 <lambdac> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.00GHz)
21:18:09 <lambdac> darcs get http://code.haskell.org/lambdabot
21:18:09 <Pseudonym> Because shapr felt lonely.
21:18:12 <lispy> So, what is wrong with this type sinature: either_ :: (forall a. a -> c) -> (forall b. b -> c) -> Either a b -> c
21:18:20 <SamB_XP> @list
21:18:20 <lambdac> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:18:21 <dmwit> SamB_XP: y_0?
21:18:26 <Pseudonym> This version ain't in darcs, BTW.
21:18:30 <SamB_XP> hmm, it's not THAT old
21:18:39 <Pseudonym> That's lambdac.
21:18:40 <dmwit> SamB_XP: You're querying lambdac, not lambdabot.
21:18:43 <Pseudonym> Yes.
21:18:45 <SamB_XP> oh, true
21:18:48 <Pseudonym> lambdabot can't tell you its version.
21:18:49 <SamB_XP> lambdabot: @list
21:18:49 <lambdabot> Sorry, I'm not a very smart bot yet.
21:18:54 <Pseudonym> But the code is dated February 2003.
21:19:01 <SamB_XP> okay, that one is ancient
21:19:21 <SamB_XP> not a line of my code in it either
21:19:28 <vixey> lispy: a and b in the Either
21:19:34 <vixey> they aren't in a forall
21:19:35 <Pseudonym> Nope, all my code.
21:19:41 <Pseudonym> lambdabot: @listmodules
21:19:42 <lambdabot> I have the following modules installed: ["hello_module"]
21:19:50 <vixey> hmmm
21:19:52 <Pseudonym> lambdabot: @hello
21:19:52 <lambdabot> Sorry, I'm not a very smart bot yet.
21:19:55 <SamB_XP> Pseudonym: oh, you was who started it?
21:20:00 <vixey> :t either :: (forall a. a -> c) -> (forall b. b -> c) -> Either a b -> c
21:20:02 <lambdac>     Couldn't match expected type `forall a. a -> c'
21:20:02 <lambdac>            against inferred type `a -> c1'
21:20:02 <lambdac>       Expected type: (forall a2. a2 -> c)
21:20:03 <Pseudonym> ?fact Pseudonym
21:20:04 <lambdac> pseudonym: My initial creator.
21:20:07 <Pseudonym> Guess so.
21:20:10 <vixey> :t either :: (forall a. a -> c) -> (forall b. b -> c) -> (forall a b. Either a b -> c)
21:20:10 <lispy> vixey: Hmm...yeah I cuess youc an' actually use that type
21:20:11 <lambdac>     Couldn't match expected type `forall a. a -> c'
21:20:12 <lambdac>            against inferred type `a -> c1'
21:20:12 <lambdac>     Probable cause: `either' is applied to too few arguments
21:20:15 * lispy is lagging bad
21:20:19 * dmwit smiles thinking about how far Haskell has come in five measly years
21:20:46 <SamB_XP> dmwit: I frowns thinking how many steps back we've come :-(
21:20:56 <lispy> Next up is replacing my eithers with cases
21:21:53 <dmwit> SamB_XP: So submit proposals for Haskell'.
21:22:01 <dmwit> SamB_XP: There's a legitimate process now.
21:22:10 * Pseudonym laughs
21:22:20 <Pseudonym> Isn't Haskell' also five years old?
21:22:21 <dmwit> ...supposedly
21:22:29 <dmwit> Well, yeah.
21:22:31 <dmwit> It's old.
21:22:37 <SamB_XP> can I propose that Haskell' be written in terms of Haskell 1.4 or whatever the previous version wasl, rather than in terms of Haskell 98?
21:22:55 <Pseudonym> SamB: Well, you'd want FFI.
21:22:57 <vixey> how about not woryringa bout Haskell'
21:22:59 <dmwit> It must be lonely for the people who have been working on it for so long; I bet a bit of outside interest would be welcomed.
21:23:07 <SamB_XP> Pseudonym: FFI isn't in 98 anyway!
21:23:08 <vixey> instead wouldn't it be better to get GHC to build using ghc -make ?
21:23:14 <Pseudonym> Oh yes it is!
21:23:17 <Pseudonym> It's an annex.
21:23:24 <SamB_XP> addendum
21:23:28 <vixey> would that not be better?
21:23:31 <Pseudonym> Whatever.  It's officially part of the standard.
21:23:33 <dmwit> Pseudonym: Anyway, FFI has already been approved for prime.
21:23:34 <lispy> vixey: wouldn't that be ... ironic?
21:23:38 <SamB_XP> but I didn't think it was particularly an addendum to 98
21:23:42 <Pseudonym> dmwit: I feel so much better.
21:23:54 <SamB_XP> dmwit: that was like a no-brainer
21:23:59 * dmwit nods
21:24:03 <Pseudonym> All due respect to the Haskell' people, but Haskell' hasn't really affected me.
21:24:08 <vixey> lispy, ironic how?
21:24:16 <Pseudonym> @hello
21:24:17 <lambdac> Maybe you meant: help tell
21:24:20 <dmwit> Pseudonym: Yep, me neither.  But don't you *want* it to? =P
21:24:26 <Pseudonym> Maybe.
21:24:36 <Pseudonym> I'm not convinced that after five years, Haskell' is such a good idea.
21:24:47 <vixey> ghc --make is better :p
21:24:47 <SamB_XP> that and the hierarchical libraries were surely the easiest parts to figure out for Haskell' -- and I don't see how rolling back to 1.4 would mess anything up
21:24:48 <Pseudonym> The idea at the time was to standardise the stuff we had quickly.
21:24:52 <Pseudonym> As I recall it.
21:24:57 <lispy> vixey: my ironic is bad...maybe I mean, self-referntial
21:25:11 <SamB_XP> Pseudonym: hmm, maybe you should have called it Haskell ME instead
21:25:11 <ddarius> Design by internet is far worse than design by committee.
21:25:13 <dsrogers> wait, huh?  there is a haskell prime?
21:25:13 <vixey> lispy, self referential I am ok with that
21:25:23 <SamB_XP> no wait, that's what you shoulda called it 98
21:25:24 <bd_> dsrogers: Yes, it's called "GHC a few years ago" :)
21:25:28 <SamB_XP> er. s/it //
21:25:28 <dmwit> dsrogers: Not yet, and at this rate, maybe never.
21:25:39 <Pseudonym> GHC a few years ago plus associated types.
21:25:52 <lispy> Haskell' will have AT?
21:25:52 <vixey> why not add linear types to haskell!
21:25:55 <SamB_XP> Pseudonym: oh, that's why it's taking so long I guess ;-)
21:25:59 <dsrogers> huh.  Why is it so hard to produce a new haskell standard?
21:26:06 <dmwit> Nobody knows.
21:26:12 <ddarius> Functional dependencies.
21:26:17 <Pseudonym> Seems to me that it'd have made more sense to release Haskell' without FDs.
21:26:26 <Pseudonym> And kept FDs as a -fglasgow-ext
21:26:27 <dmwit> The LHC is acting backwards in time to prevent nice things. ;-)
21:26:28 <dsrogers> what are functional dependencies?
21:26:33 <SamB_XP> Pseudonym: what feature would it have had over Haskell 98?
21:26:41 <Pseudonym> A bunch of things.
21:26:46 <SamB_XP> such as?
21:26:47 <Pseudonym> MPTCs, higher-ranked types...
21:26:58 <SamB_XP> MPTCs aren't so useful without FDs
21:27:07 <SamB_XP> but the others are I guess
21:27:14 <SamB_XP> including infix tycons ...
21:27:15 <Pseudonym> Existential types.
21:27:23 <Pseudonym> That sort of thing, yeah.
21:27:26 <ddarius> I agree.  MPTCs + FD (or nowadays a suitable replacement) was crucial.
21:27:33 <vixey> ViewPatterns
21:27:47 <Pseudonym> Incidentally, I also don't see why Haskell' can't be released without ATs.
21:27:57 <Pseudonym> There seems to be this idea that it's either FDs or ATs.
21:28:00 <SamB_XP> Pseudonym: sure, we could just stash the rest ;-)
21:28:26 <Pseudonym> I don't see why you can't handle both.
21:28:29 <SamB_XP> that is, stash the stuff that isn't at all ready
21:28:37 <Pseudonym> Right.
21:28:49 <SamB_XP> well, nobody wanted to have to write the report section on FDs, I think
21:28:51 <Pseudonym> Oh, auto-deriving would be handy, too.
21:28:57 <ddarius> Pseudonym: There is no point on -standardizing
21:29:01 <ddarius> - on a language with both.
21:29:07 <Pseudonym> Why not?
21:29:20 <SamB_XP> I maintain that nobody wanted to write the section on FDs ;-P
21:29:34 <Pseudonym> I argue that there's no point on standardising a language with both ADTs and GADTs.
21:29:36 <ddarius> Pseudonym: Because they have massively overlapping domains of application.  Together they are highly redundant.
21:29:43 <Pseudonym> Or classic ADTs and records.
21:29:52 <vixey> Pseudonym: huh seriously?
21:29:58 <Pseudonym> No, but it's the same argument.
21:30:15 <ddarius> Pseudonym: AT aren't a strict extensions of FDs (or vice-versa).
21:30:17 <Pseudonym> Unless they interact badly in the type checked (which I doubt, since you can express one in terms of the other), I don't see why you can't have both.
21:30:39 <Pseudonym> Yes, they overlap.
21:30:40 <SamB_XP> actualy, I think that the existing ADT syntax is very unintuitive
21:30:42 <Pseudonym> So?
21:30:53 <Pseudonym> They express different things at the programmer level.
21:31:01 <SamB_XP> and I'd have taken to the GADT syntax much more quickly
21:31:08 <vixey> yeah ADT syntax is pretty weird
21:31:11 <vixey> BNF is a bit better
21:31:15 <lispy> yeah, I think GADTs are better
21:31:16 * ddarius finds it very intuitive.
21:31:18 <SamB_XP> even if GADT it wasn't allowed to actually define a GADT
21:31:22 <SamB_XP> Er.
21:31:25 <SamB_XP> whatever I mean ;-)
21:31:41 <vixey> you write
21:31:47 <vixey> Constructor Type Type
21:31:53 <vixey> which doesn't make sense...
21:31:58 <SamB_XP> quite so
21:32:04 <Pseudonym> Sure it does.  It's pseudo-BNF.
21:32:08 <vixey> but with BNF you have
21:32:13 <vixey> Constructor <Type> <Type>
21:32:27 <Pseudonym> Haskell: data Foo = Bar String | Baz Int
21:32:43 <Pseudonym> Miranda: data foo ::= Bar string | Baz int
21:32:46 <Pseudonym> Or something like that.
21:32:51 <Pseudonym> Might have gotten the capitalisation wrong.
21:32:57 <ddarius> Pseudonym: If that was all there was to it, I'd probably still not be keen on having both, but as SamB_XP says the semantics of FDs are not very clear and ATs were, in part, meant to replace them.
21:32:59 <Pseudonym> There you go, even ::=
21:33:04 <vixey> <Foo> ::= Bar <String> | Baz <Int>
21:33:07 <SamB_XP> Pseudonym: wouldn't we have to be able to typeset the String in a proportional, italic type?
21:33:43 <ddarius> Clean also uses a notation reminiscent of BNF if I recall correctly.
21:33:58 <SamB_XP> anyway, what I mean to say is that I really don't think we *should* have both the ADT syntax and the GADT syntax -- only the GADT one
21:34:01 <Pseudonym> I'm curious as to what is unclear about FDs.  I'm not disagreeing, just curious.
21:34:10 <vixey> SamB_XP:
21:34:29 <SamB_XP> Pseudonym: well, you can try to write 'em up for the Haskell' report if you want to see ;-)
21:34:34 <vixey> that makes it awkward to define stuff
21:34:39 <SamB_XP> vixey: hmm?
21:34:53 <vixey> data Either a b where
21:34:54 <Pseudonym> There's a draft Haskell' report, is there?
21:34:58 <vixey>   Left :: a -> Either a b
21:35:01 <vixey>   Right :: b -> Either a b
21:35:02 <vixey> vs
21:35:06 <ddarius> Pseudonym: I'm presuming it's something non-obvious because at first blush it doesn't seem -too- hard, but people who should know what they are talking about say it is quite a bit more tricky than it looks.
21:35:08 <vixey> data Either a b = Left a | Right b
21:35:21 <Pseudonym> The thing is, FDs have been implemented twice.
21:35:26 <Pseudonym> At least.
21:35:38 <ddarius> Pseudonym: Not with the same semantics.
21:35:40 <SamB_XP> Pseudonym: well, I suspect the implementors know what the problems with specifying it are ;-)
21:35:59 <Pseudonym> Like I asked: What are the problems?
21:36:08 <SamB_XP> ask them
21:36:09 <Pseudonym> How do GHC's and Hugs' semantics differ?
21:36:25 <SamB_XP> well, check the hugs manual I guess
21:36:33 <SamB_XP> it's probably more informative re: differences
21:36:46 <Pseudonym> Incidentally, I can see an argument for holding off FDs, implementing ATs, then recasting FDs as syntactic sugar on top of ATs.
21:37:00 <ddarius> Pseudonym: I believe there are interactions with differences in constraint resolution that become significant when functional dependencies are added.
21:37:00 <vixey> SamB: Don't you think?
21:37:01 <Pseudonym> Much like how record syntax is sugar.
21:37:04 <adu> i don't understand 'reads'
21:37:10 <vixey> :t reads
21:37:10 <SamB_XP> Pseudonym: in your minds I, or you found it in list archives?
21:37:11 <lambdac> forall a. (Read a) => String -> [(a, String)]
21:37:14 <SamB_XP> er. minds eye
21:37:29 * SamB_XP thinks he just mentioned the title of a book by mistake
21:37:29 <Pseudonym> In my mind's eye.
21:37:33 <Pseudonym> :-)
21:37:42 <mauke> EHOFSTADTER
21:37:51 <SamB_XP> I bet the argument can also be found in mailing list archives ;-)
21:37:55 <dmwit> ....aaaand, this is why Haskell' is taking forever.
21:37:58 <Dzlk> Hofstadter & Dennett, yes?
21:38:01 <SamB_XP> mauke: I guess I was right about it ;-)
21:38:13 <ddarius> dmwit: As I said, functional dependencies.
21:38:20 <Pseudonym> Which, again, is why we should have just released Haskell' years ago without the tricky bits.
21:38:21 * dmwit nods
21:38:25 <SamB_XP> anyway, bedward ho
21:38:26 <Pseudonym> The whole point was to standardise common practice.
21:38:37 <ddarius> FDs -are- common practice for users.
21:38:44 <SamB_XP> Pseudonym: yeah, they got sidetracked because common practice included FDs I guess
21:38:56 <ddarius> In my opinion, Haskell' should've been standardizing the language that was actually used.
21:38:59 <dmwit> I think there should start a practice of releasing a new standard every two months.
21:39:01 <Pseudonym> So if they're going to be dumped anyway, standardise all that you can standardise.
21:39:08 <dmwit> It would put a lot less pressure on the decisions they make.
21:39:08 <ddarius> And that language includes functional dependencies.
21:39:10 <Pseudonym> dmwit: One a year would be okay.
21:39:12 <SamB_XP> though if they'd done it then they'd probably have been a bit less commonly used
21:39:18 <Pseudonym> You could stage it with the Hugs releases!
21:39:19 <SamB_XP> dmwit: six months
21:39:26 <dmwit> Turns out FDs don't work that well?  Don't worry, you're only stuck with it for a few months!
21:39:30 <SamB_XP> or maybe 12, like Pseudonym says
21:39:39 <dmwit> SamB_XP, Pseudonym: Okay, 6-12 months would be fine too.
21:39:45 <dmwit> Just as long as it's something nice and tight.
21:39:48 <vixey> let's make a new std. whicd isn't even haskell!
21:39:48 <hansfbaier> @src fnao
21:39:48 <lambdac> Source not found. You type like i drive.
21:39:53 <hansfbaier> @src fmap
21:39:53 <lambdac> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:39:53 <dmwit> (12 months is getting a bit long already.)
21:40:02 <SamB_XP> vixey: what do you propose to call it? Haskell B?
21:40:08 <vixey> no
21:40:13 <dmwit> Haskelm
21:40:16 <vixey> Church
21:40:18 <dmwit> Then Haskeln
21:40:22 <mauke> preflex: nickr Haskell
21:40:22 <preflex>  Haskell_
21:40:24 <ddarius> There isn't much pressure to standardize things like higher-rank types as they don't differ between implementations that much.
21:40:26 <hansfbaier> lambdac: you are right, not the same anymore.
21:40:34 <mauke> preflex: nickr Haskell_
21:40:35 <preflex>  Haskel_l
21:40:37 <SamB_XP> vixey: that would be too hard to google
21:40:38 <Pseudonym> Incidentally, the Hugs manual is no help in understanding how its implementation of FDs differ from GHC.
21:40:48 <SamB_XP> people already say "in Church" a lot, you know
21:40:48 <vixey> don't google it then
21:41:08 <SamB_XP> how is anyone supposed to find information about a programming language like that?
21:41:10 <ddarius> SamB_XP: You google "Church programming language" not "Church"
21:41:16 <SamB_XP> ddarius: hmm.
21:41:20 <ddarius> @google "charity programming language"
21:41:23 <lambdac> http://en.wikipedia.org/wiki/Charity_(programming_language)
21:41:23 <vixey> hey but really
21:41:27 <ddarius> Amazing.
21:41:30 <vixey> there are lots of syntax changes you could make
21:41:31 <mauke> hah, C++ or C# aren't exactly google friendly either
21:41:33 <dmwit> SamB_XP: That sounds much too logical to fit into the Church paradigm.
21:41:48 <SamB_XP> dmwit: what?
21:41:53 <dmwit> mauke: They're special-cased by Google. =)
21:42:21 <SamB_XP> @google F#
21:42:23 <lambdac> http://research.microsoft.com/fsharp/
21:42:24 <lambdac> Title: Microsoft F#
21:42:30 <SamB_XP> hmm, apparantly F# is too
21:42:34 <dibblego> apparently
21:42:37 <SamB_XP> @google C--
21:42:37 <dmwit> Compare c# to h#.
21:42:38 <Pseudonym> OK, now anyone's an admin on lambdabot.
21:42:40 <lambdac> http://en.wikipedia.org/wiki/C_(programming_language)
21:42:45 <Pseudonym> Go sick.
21:42:48 * ddarius makes a new programming language called "Computer"
21:42:56 <SamB_XP> lambdabot: @quit
21:42:56 <lambdabot> Sorry, I'm not a very smart bot yet.
21:43:01 <SamB_XP> lambdabot: @restart
21:43:01 <lambdabot> Sorry, I'm not a very smart bot yet.
21:43:02 <Pseudonym> You need to privmsg that.
21:43:06 <SamB_XP> oh
21:43:08 <lambdabot> Hey, quit that,  SamB_XP!
21:43:10 <Pseudonym> Little-known feature.
21:43:17 <dsrogers> why aren't things like TH in the standard?
21:43:28 <dsrogers> TH seems so darn useful
21:43:37 <ddarius> dsrogers: Because almost no one uses TH
21:43:39 <dmwit> It's in a proposal, I think.
21:43:44 <dsrogers> standard meaning proposal...
21:43:48 <SamB_XP> dsrogers: because it's ... not very standardizable
21:43:55 <lambdabot> I'm part of Haskell'.
21:44:05 <SamB_XP> how about a second implementation first?
21:44:13 <dsrogers> ah
21:44:15 <lambdabot> actually, I'm a douchebag
21:44:23 <SamB_XP> what's douche anyway?
21:44:31 <Pseudonym> It's French for "wash".
21:44:36 <dsrogers> a cleaning product for women.
21:44:49 * ddarius is struck by an idea.  Use TH to make a GOA-like thing so you can write code like $(lambdabot "@djinn const :: a -> b -> a")
21:44:53 <lambdabot> I transcend Haskell'
21:45:06 <dsrogers> lambdabot is chatty tonight
21:45:26 <Pseudonym> The best bit is, I can see who's doing the sockpuppeting.
21:45:29 <mauke> ddarius: well, in that particular case there's a simpler solution
21:45:42 <mauke> http://okmij.org/ftp/Haskell/types.html#de-typechecker
21:45:44 <lambdac> Title: Haskell Programming: Types
21:45:56 <lambdabot> dsrogers: Am I?
21:46:12 <lambdabot> Pseudonym is such a voyeur.
21:46:13 <vixey> ddarius: I tried to do something similar using quasiquotes
21:46:26 <vixey> I gave up because Ivor wouldn't install though
21:46:35 <lambdabot> Pseudonym is a moron, and for all you know, it's him doing this
21:46:38 <SamB_XP> dsrogers: you use the @msg command if you want to try it
21:46:48 <SamB_XP> lambdabot: not all of it!
21:46:48 <lambdabot> Sorry, I'm not a very smart bot yet.
21:46:50 <lispy> ?msg #haskell Hi!
21:46:50 <lambdac> Not enough privileges
21:46:55 <SamB_XP> I know because I did one
21:47:10 <SamB_XP> lambdabot: @msg #haskell hello!
21:47:11 <dsrogers> I lose.
21:47:11 <lambdabot> Sorry, I'm not a very smart bot yet.
21:47:19 <SamB_XP> hmm, only works in privmsg
21:47:23 <Pseudonym> Yes.
21:47:30 <Pseudonym> That was a feature back in the day.
21:47:35 <SamB_XP> that is, direct privmsg
21:48:55 <adu> :t lex
21:48:57 <lambdac> String -> [(String, String)]
21:48:59 <lispy> I really have to rethink this
21:49:12 <lispy> These type errors are hell
21:49:22 <adu> lex "hello world"
21:49:31 <adu> > lex "hello world"
21:49:32 <lambdac>  [("hello"," world")]
21:50:02 <vixey> > lex "(1+2)*3"
21:50:03 <lambdac>  [("(","1+2)*3")]
21:50:19 <lispy> but statements like, if foo then p else nvert p, where ivert :: p x y -> p y x don't give me a lot of choice!
21:52:28 <adu> > lex $ (snd .head) $ lex "quite a few words"
21:52:29 <lambdac>  [("a"," few words")]
21:52:55 <vixey> :t maybe
21:52:57 <lambdac> forall b a. b -> (a -> b) -> Maybe a -> b
21:53:08 <vixey> :t listToMaybe
21:53:10 <lambdac> forall a. [a] -> Maybe a
21:53:39 <vixey> :t unfoldr
21:53:41 <lambdac> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:53:54 <vixey> :t unfoldr (listToMaybe . lex)
21:53:55 <lambdac> String -> [String]
21:54:06 <vixey> > unfoldr (listToMaybe . lex) "(1+2)*3"
21:54:07 <lambdac>  ["(","1","+","2",")","*","3","","","","","","","","","","","","","","","",""...
21:54:17 <lispy> where is lex improted from?
21:54:24 <Pseudonym> @hoogle lex
21:54:25 <lambdac> A Hoogle error occured.
21:54:34 <Pseudonym> :-/
21:54:36 <adu> Prelude
21:54:40 <TSC> @index lex
21:54:40 <lambdac> Text.Read, Prelude, Text.Read.Lex
21:55:06 <dmwit> lispy: Can you believe it, it's in the Prelude!
21:55:20 <vixey> > listToMaybe . lex ""
21:55:21 <lambdac>  Couldn't match expected type `[a]'
21:55:21 <lispy> dmwit: I Can't believ it
21:55:25 <vixey> > listToMaybe . lex $ ""
21:55:27 <lambdac>  Just ("","")
21:55:27 <dmwit> Never has one of the best names been so thoroughly tied to one of the least used functions.
21:55:29 <lispy> dmwit: it's not butter!
21:55:35 <vixey> that sucsk
21:55:36 <dmwit> lispy: heh
21:56:03 <vixey> @let lex' = sort . lex where sort Just ([],[]) = Nothing ; sort otherwise = otherwise
21:56:03 <lambdac>  arity mismatch for 'sort'
21:56:04 <lispy> import Prelude hiding (lex)
21:56:16 <vixey> @let lex' = sort . lex where sort (Just ([],[])) = Nothing ; sort otherwise = otherwise
21:56:18 <lambdac> Couldn't match expected type `Maybe ([t], [t1])'
21:56:53 <vixey> @let lexToMaybe = sort . listToMaybe . lex where sort (Just ([],[])) = Nothing ; sort otherwise = otherwise
21:56:54 <lambdac> Defined.
21:57:03 <vixey> > unfoldr (lexToMaybe) "(1+2)*3"
21:57:04 <lambdac>  ["(","1","+","2",")","*","3"]
21:57:53 <dmwit> ... sort otherwise = otherwise?
21:57:56 <dmwit> oh
21:58:00 <lispy> yeah, I was just going to ask
21:58:03 <dmwit> otherwise just got bound there, didn't it.
21:59:34 <SamB_XP> @type otherwise
21:59:35 <lambdac> Bool
22:00:03 <dmwit> SamB_XP: otherwise :: Maybe ([a], [b]) up there.
22:00:51 <dmwit> sort (Just ([], [])) = Nothing; sort x = x -- easier to understand, and totally equivalent
22:00:53 <SamB_XP> yeah, I was just refreshing my memory about otherwise ;-)
22:01:02 <vixey> > otherwise
22:01:03 <lambdac>  True
22:01:14 <dmwit> SamB_XP: Also: go to bed!
22:01:16 <vixey> > let in let in let () = () in otherwise
22:01:18 <lambdac>  True
22:01:50 <dmwit> oy
22:01:55 <dmwit> > let in otherwise
22:01:56 <lambdac>  True
22:02:01 <dmwit> yuck
22:02:03 <adu> words == takeWhile (/="") $ tail $ map fst $ iterate (head.lex.snd) $ (,) ""
22:02:10 <adu> how do i use quickcheck?
22:02:10 <dmwit> That should be explicitly forbidden.
22:02:22 <dmwit> ?check x == x
22:02:30 <vixey> @check \ys -> words ys == takeWhile (/="") $ tail $ map fst $ iterate (head.lex.snd) $ (,) "" $ ys
22:02:32 <lambdac>  OK, passed 500 tests.
22:02:32 <dmwit> ?check (==)
22:02:33 <lambdac>  Couldn't match expected type `[String]'
22:02:34 <lambdac>  OK, passed 500 tests.
22:02:54 <vixey> adu, suggestion:
22:03:06 <vixey> > unfoldr lexToMaybe "aaa bb c"
22:03:07 <lambdac>  ["aaa","bb","c"]
22:03:23 <vixey> use unfoldr to replace that tail map fst iterate head ?f snd pattern
22:03:24 <adu> vixey: lol, I know it can be shorter, I'm just trying to understand "lex"
22:03:31 <dmwit> adu: lex breaks on other characters than just spaces, so that's probably not the same as words.
22:03:36 <vixey> It's not about being shorter
22:03:53 <Olathe> @src lex
22:03:53 <lambdac> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:04:04 <vixey> > (unfoldr lexToMaybe &&& words) "foo+bar"
22:04:06 <lambdac>  (["foo","+","bar"],["foo+bar"])
22:04:08 <dmwit> ?where Prelude -- Olathe
22:04:08 <lambdac> http://www.haskell.org/onlinereport/standard-prelude.html
22:04:51 <Olathe> Ahh, thanks.
22:06:09 <vixey> adu, but yeah
22:06:22 <vixey> adu, Don't expect quichcheck to find bugs in programs :)
22:06:29 <vixey> or any automated testing
22:06:33 <lispy> I think I just noticed a the law of demeter being violated
22:07:05 <lispy> if you write code lie this, foo a = case blah a of ..., then you're writing bad code
22:07:24 <lispy> just pass the blah a, instea of the a
22:07:31 <dmwit> yeah!
22:07:32 <lispy> (at least most of the time)
22:07:41 <vixey> what is demeter ?
22:07:44 <vixey> btw
22:07:49 <dmwit> about 100 cm
22:07:52 <vixey> foo (blah -> ...) =
22:08:07 <lispy> vixey: checking on wikipedia, just a sec
22:08:19 <dmwit> ?go law demeter
22:08:21 <lambdac> http://en.wikipedia.org/wiki/Law_of_Demeter
22:08:27 <lispy> More formally, the Law of Demeter for functions requires that a method M of an object O may only invoke the methods of the following kinds of objects:
22:08:36 <lispy>    1. O itself
22:08:36 <lispy>    2. M's parameters
22:08:36 <lispy>    3. any objects created/instantiated within M
22:08:36 <lispy>    4. O's direct component objects
22:08:41 <adu> vixey: ok
22:08:53 <vixey> eh I don't get it
22:09:22 <lispy> vixey: the gist is, the consumer should received the goods, instead of a way to derive the good
22:10:00 <lispy> vixey: make sense?
22:10:06 <vixey> yes
22:10:17 <vixey> it sort of goes against my view though
22:11:35 <lispy> why is that?
22:12:15 <vixey> maybe I am confused actually
22:34:56 <Korollary> play this: http://www.seeqpod.net/search/?plid=d729d0790c
22:34:57 <lambdac> Title: SeeqPod - Playable Search - Find. Discover. Watch. Listen. Share.
22:35:38 <Korollary> eh. I didn't mean to paste that.
22:35:56 <lispy> sure
22:37:58 <adu> lexToMaybe?
22:38:25 <vixey> lol
22:38:38 <vixey> adu: listToMaybe . lex sucked
22:38:55 <vixey> so I let lexToMaybe = sort . listToMaybe . lex where sort (Just ([],[])) = Nothing ; sort otherwise = otherwise
22:39:05 <vixey> > lexToMaybe ""
22:39:07 <lambdac>  Nothing
22:39:11 <vixey> > lexToMaybe "foo bar baaaaaaaaz"
22:39:13 <lambdac>  Just ("foo"," bar baaaaaaaaz")
22:39:21 <vixey> > unfoldr lexToMaybe "foo bar baaaaaaaaz"
22:39:22 <lambdac>  ["foo","bar","baaaaaaaaz"]
22:39:33 <adu> vixey: i'm so confused
22:39:38 <adu> @src unfoldr
22:39:38 <lambdac> unfoldr f b  = case f b of
22:39:38 <lambdac>    Just (a,new_b) -> a : unfoldr f new_b
22:39:38 <lambdac>    Nothing        -> []
22:40:11 <adu> @index lexToMaybe
22:40:12 <lambdac> bzzt
22:40:14 <vixey> adu, why are you confused !
22:40:20 <vixey> :t lexToMaybe
22:40:22 <lambdac> String -> Maybe ([Char], [Char])
22:40:27 <vixey> :t unfoldr
22:40:28 <lambdac> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:40:35 <adu> is lexToMaybe something you defined from scratch?
22:40:42 <vixey> adu, I let lexToMaybe = sort . listToMaybe . lex where sort (Just ([],[])) = Nothing ; sort otherwise = otherwise
22:40:44 <adu> @index listToMaybe
22:40:44 <lambdac> Data.Maybe
22:44:01 <adu> vixey: theres got to be a better way to define split
22:44:12 <vixey> adu: SPLIT ?
22:44:14 <dsrogers> is there good documentation anywhere on FFI?
22:44:24 <adu> split :: a -> [a] -> [[a]]
22:44:27 <mauke> @where ffi
22:44:27 <lambdac> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
22:44:50 <vixey> :t unfoldr ?f :: [a] -> [[a]]
22:44:52 <lambdac>     Could not deduce (?f::[a] -> Maybe ([a], [a])) from the context ()
22:44:52 <lambdac>       arising from a use of implicit parameter `?f'
22:44:52 <lambdac>                    at <interactive>:1:8-9
22:44:57 <adu> split ' ' "hello world" = ["hello", "world"]
22:45:15 <vixey> :t (unfoldr ?f) :: [a] -> [[a]]
22:45:17 <lambdac>     Could not deduce (?f::[a] -> Maybe ([a], [a])) from the context ()
22:45:17 <lambdac>       arising from a use of implicit parameter `?f'
22:45:17 <lambdac>                    at <interactive>:1:9-10
22:45:23 <dsrogers> thanks
22:45:24 <vixey> I don't understand
22:45:28 <adu> vixey: its a common function in perl-derived languages
22:45:45 <vixey> adu, Can you write it as an unfold?
22:46:02 <adu> vixey: I don't know, I don't understand unfold
22:46:12 <vixey> I will help you
22:46:14 <adu> ok
22:46:38 <vixey> :t let break = undefined split ; split delimiter = unfoldr (break delimiter) in (break,split)
22:46:39 <lambdac> forall t b a t1 b1 a1. (t -> b -> Maybe (a, b), t1 -> b1 -> [a1])
22:46:41 <vixey> so..
22:47:03 <adu> split c s = takeWhile (/=[]) $ tail $ map fst $ iterate ((break (==c)).snd) $ (,) [] s
22:47:09 <vixey> break "" = Nothing -- it can't be broken
22:47:15 <vixey> oops
22:47:18 <vixey> break _ "" = Nothing
22:47:33 <vixey> break "-" "foo-bar-baz" = Just ("foo","bar-baz")
22:47:43 <vixey> break "-" "bar-baz" = Just ("bar","baz")
22:47:49 <vixey> if this break function does that
22:47:56 <vixey> split delimiter = unfoldr (break delimiter)
22:48:01 <vixey> will work
22:48:09 <vixey> it iterates the break function
22:48:18 <adu> so split = unfoldr.break?
22:48:25 <vixey> split delimiter = unfoldr (break delimiter)
22:48:58 <twanvl> what is break "-" "foo"?
22:49:27 <vixey> Just ("foo","")
22:50:02 <twanvl> And what is break "-" "foo-"?
22:50:20 <vixey> Just ("foo","")
22:50:40 <twanvl> IMO the only correct answer to split '-' "-" is ["",""]
22:54:58 <twanvl> > let split p xs = case break p xs of (ys,[]) -> [ys]; (ys,_:zs) -> ys : split p zs  in  split (=='-') "foo-bar-baz"
22:55:00 <lambdac>  ["foo","bar","baz"]
22:56:01 <Deewiant> > let split p xs = case break p xs of (ys,[]) -> [ys]; (ys,_:zs) -> ys : split p zs  in  split (=='-') "-"
22:56:02 <lambdac>  ["",""]
22:56:06 <adu> @type \c -> unfoldr (\s -> (Just (break (==c) s)))
22:56:07 <lambdac> forall a. (Eq a) => a -> [a] -> [[a]]
22:56:10 <adu> :)
22:56:11 <vixey> > lol
22:56:13 <lambdac>   Not in scope: `lol'
22:56:45 <adu> @pl \c -> unfoldr (\s -> (Just (break (==c) s)))
22:56:45 <lambdac> unfoldr . (Just .) . break . (==)
22:56:49 <adu> yes!
22:56:56 <vixey> > (\c -> unfoldr (\s -> (Just (break (==c) s)))) '-' "-foo-bar"
22:56:57 <lambdac>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
22:56:59 <adu> now thats what I call split!
22:57:01 <vixey> oooooooooooo
22:57:03 <vixey> > (\c -> unfoldr (\s -> (Just (break (==c) s)))) '-' "foo-bar"
22:57:04 <lambdac>  ["foo","","","","","","","","","","","","","","","","","","","","","","","",...
22:57:21 <adu> split = unfoldr.(Just.).break.(==)
22:57:27 <vixey> no
22:59:15 <adu> vixey: I'm still confused then
22:59:22 <vixey> adu,  <lambdac>  ["foo","","","","","","","","","","","","","","","","","","","","","","","",...
23:00:57 <adu> @pl let split p xs = case break p xs of (ys,[]) -> [ys]; (ys,_:zs) -> ys : split p zs  in  split
23:00:58 <lambdac> (line 1, column 45):
23:00:59 <lambdac> unexpected ">"
23:00:59 <lambdac> expecting variable, "(", operator, ";" or "in"
23:01:10 <adu> crap
23:01:22 <vixey> @whack
23:01:23 <lambdac> Maybe you meant: check smack what
23:01:34 <adu> vixey: so tell me more about unfoldr
23:02:21 <vixey> ?
23:02:23 <vixey> what
23:03:12 <dibblego> @google bananas lenses unfold
23:03:16 <lambdac> http://portal.acm.org/citation.cfm?id=128035
23:03:17 <lambdac> Title: Functional programming with bananas, lenses, envelopes and barbed wire
23:03:23 <dibblego> adu ^^
23:03:34 <vixey> ....
23:03:50 <adu> ?
23:04:11 <adu> you think I have an ACM account?
23:04:42 <dibblego> @google Functional programming with bananas, lenses, envelopes and barbed wire
23:04:51 <lambdac> http://citeseer.ist.psu.edu/meijer91functional.html
23:05:04 <vixey> adu,
23:05:07 <vixey> don't read that lol
23:06:09 * lispy doesn't get the arguments GHC uses X, so must the haskell community.
23:06:57 <vixey> what are some values of 'X' ?
23:07:21 <twanvl> > 'X'
23:07:22 <lambdac>  'X'
23:07:26 <lispy> vixey: in this particular case, it's git
23:07:39 <vixey> ah I don't like git
23:07:50 <lispy> vixey: some peopel are suggesting that GHC's decision to switch to git should include everything on hackage
23:08:03 <lispy> Some people are overreacting :)
23:08:12 <dibblego> lispy, it is because people who are attached to cliques can't comprehend the possibility that others may not be
23:10:52 <adu> @pl (\x -> (head x):(map tail (tail x)))
23:10:52 <lambdac> liftM2 (:) head (map tail . tail)
23:11:00 <lispy> dcoutts: some of the directories in the tarball are empty, ls -A shows nothing
23:11:18 <sjanssen> lispy: yes, I think this is a bit silly
23:11:26 <adu> @pl (\c -> groupBy (\_ -> (/=c)))
23:11:26 <lambdac> groupBy . const . (/=)
23:11:28 <sjanssen> if unity is really the most important thing, why switch from darcs?
23:12:17 <lispy> sjanssen: I wish that we didn't have these vcs incompatibilities actually
23:12:44 <dons> lispy, no one is actually.
23:12:46 <lispy> what's the bash syntax to to run a command on every directory in the output of ls?
23:12:47 <adu> @pl \y -> (\x -> (head x):(map tail (tail x))) $ groupBy (\_ -> (/=' ')) y
23:12:47 <lambdac> liftM2 (:) head (map tail . tail) . groupBy (const (' ' /=))
23:12:51 <dons> at least, it is not worth wasting effort on.
23:13:01 <dons> there'll be very little 'switching' i think.
23:13:11 <dons> we may see new projects here and there in other rcs, as we already are.
23:13:20 <dons> and some of the bigger things might move.
23:13:40 <sjanssen> dons: there are certainly several comments about chosing an RCS "for the community" rather than just GHC in the "Version control systems" thread
23:13:43 <lispy> dons: yeah, that's how i picture it going down.  People are just too lazy to do an enmasse move
23:14:26 <lispy> One thing that may actually be beneficial, but probably fuitle would be to make a more unified vcs
23:14:35 <cjs> Well, and some development styles just don't suit some VCSs.
23:15:09 <dons> anyway, it's clearly bikeshed now.
23:15:09 <cjs> For me, in a small shop where everybody's usually together, and everybody is always expected to do a full integration test before committing, darcs is a bit of a pain.
23:15:43 <dons> cjs, that's where i'd imagine darcs would be good -- you'd be able to require the test ran, interestingly.
23:15:54 <lispy> dons: that's probably a good a point...bikeshed
23:16:24 <dons> the people with authority to make any decision about ghc aren't around. so we're just kids in the school yard yabbering.
23:16:47 <dons> a good word for americans interested in picking up new slang, btw.
23:16:52 <lispy> cjs: Ah, yeah a workflow where dev repos don't run the tests, but you all push patch bundles up stream where the tests run automatically wouldn't be a bad idea
23:16:59 <vixey> lol
23:17:18 <vixey> @remember yard yabbering
23:17:18 <lambdac> I will never forget.
23:17:38 <b\6> lispy: maybe  for d in $(find -maxdepth 1 -type d); do echo $d; done
23:17:46 <adu> @pl (\c s -> map tail (groupBy (\_ -> (/=c)) ([c] ++ s)))
23:17:47 <lambdac> (map tail .) . ap ((.) . groupBy . const . (/=)) (:)
23:17:57 <lispy> b\6: thanks, i'll try that
23:18:36 <lispy> hrm, osx doesn't like that
23:19:05 <adu> > (map tail .).ap((.).groupBy.const.(/=))(:) '/' "/A/very/long/file/name"
23:19:06 <lambdac>  Couldn't match expected type `f [a]' against inferred type `Char'
23:19:09 <lispy> I changed the find to ls and it works
23:19:23 <b\6> no appropriate emoticon.
23:19:26 <lispy> b\6: I forgot to mention, all the entires in my directory are regular directories :)
23:19:33 <b\6> hmm.
23:19:39 <b\6> well.. if you're ok, good.
23:20:21 <erikc> yea, i was gonna implement a workflow like that actually, with a bot to manage each ./component/release repo, and let the build bots commit levels
23:20:43 <erikc> strikes a good balance between distributed development and centralized release management
23:20:49 <lispy> Okay, so now I have 119 darcs repositories here harvested from the wild
23:21:15 <lispy> erikc: you could use post-hooks to trigger the bots too
23:21:23 <adu> @pl (\_ -> (/=c))
23:21:24 <lambdac> const (c /=)
23:21:25 <Pseudonym> lispy: I hope you're going to disinfect them.
23:21:47 <lispy> Pseudonym: how so?  I'm on a bug hunt
23:22:00 <lispy> Pseudonym: I want to run some darcs commands on them
23:28:09 <adu> @pl  \s -> map tail ((groupBy (const.(/='/')) (['/'] ++ s)))
23:28:10 <lambdac> map tail . groupBy (const . ('/' /=)) . ('/' :)
23:31:27 <adu> @pl (\_ -> (c/=))
23:31:27 <lambdac> const (c /=)
23:32:22 <lispy> Oh wow
23:32:33 <lispy> If you fully understand the implications and promise not to run convert again
23:32:33 <lispy> then type 'I understand the consequences of my action':
23:32:44 <lispy> I guess I haven't converted any repos yet to see that mesage
23:33:14 <adu> what are the consequences?
23:33:24 <cjs> lispy: Yeah, well, that lets broken builds get upstream. The idea here is you don't commit something that's not ready to go into production.
23:33:39 <cjs> (I.e., what you commit is already fully tested and integrated.)
23:34:08 <lispy> cjs: well, each dev could have a branch on their machine that they push to before sharing
23:34:36 <lispy> cjs: so, say you work for a while, build up some patches, push a bundle, wait for the test restults
23:34:50 <lispy> cjs: if it was all good you push from there to the upsream
23:36:25 <cjs> True. But then how do you make sure that two devs don't end up both pushing their tested versions up at the same time, thus producing together an untested version.
23:37:03 <lispy> solve that the same you solve it now
23:37:09 <cjs> You can pretty much work this style in Darcs, it's just not as handy as svn is for it, because darcs doesn't really enforce the concept of one series of patches in a single order.
23:38:03 <cjs> E.g., subversion, when you try to commit, will, in many of the usual cases, inform you that you don't have the most recent version, forcing you to pull it down and re-integrate.
23:40:03 <cjs> It cuts both ways, of course. Darcs looks to me much, much better for cherrypicking. But we don't do that so often; we tend almost invariably to be running the main branch in production.
23:44:57 <lispy> cjs: I think I see what you're talking about now.  Certainly darcs doesn't preventing you from adopting a work style that meets your needs in this case.  You're just saying that if people arent' disciplined it leads to trouble.
23:45:21 <glguy> a push causing it merge is almost certainly a bug
23:45:27 <glguy> or at least something that can be disabled
23:45:38 <glguy> or rather something that should be able to be disabled
23:45:44 <glguy> (not sure)
23:46:04 <lispy> glguy: do you mean conflict?
23:46:13 <lispy> a push is always a merge
23:46:13 <cjs> lispy: Yeah, pretty much.
23:46:24 <glguy> no, I mean now you have a version of the code you've never seen before
23:46:27 <glguy> and it isn't even local
23:46:36 <cjs> glguy: Yeah, that's exactly my feeling.
23:47:11 <erikc> alternatively, you have a bot that you mail patches to and it manages trying to apply a patching order to them, do a build, run tests, commit a level, or punt the whole set as a build failure (or do some automated triage)
23:47:56 * lispy starts a script to convert 117 darcs1 repos to darcs2
23:47:58 <erikc> i wish ibm still sold cmvc, i totally <3 that system
23:51:05 <dons> interesting, luqui, http://www.reddit.com/comments/6vxp4/all_functions_are_continuous_always/
23:51:07 <lambdac> Title: All functions are continuous, always : reddit.com, http://tinyurl.com/6ezmzo
23:51:16 <sjanssen> glguy: isn't this the essence of distributed development?
23:51:33 <glguy> sjanssen: pushes creating unknown results?
23:51:35 <sjanssen> (do other distributed version control systems actually have this property?)
23:51:45 <glguy> no, that's why git doesn't allow you to cause a merge on push
23:51:51 <glguy> you pull first
23:51:52 <sjanssen> glguy: I'd rather say "new" results
23:51:54 <glguy> create the merge
23:51:55 <glguy> and push it
23:51:56 <sjanssen> the result is deterministic
23:52:45 <lispy> sjanssen: the result my be deterministic, but you don't have a copy of it locally
23:52:50 <glguy> and after you pull and merge, you consider trying to build or tes tthe result
23:52:51 <lispy> sjanssen: that's glguy's point
23:53:08 <sjanssen> glguy: I also don't see how that is possible without locking the external repository
23:54:39 <glguy> I think I missed the part earlier where locking came up
23:54:45 <sjanssen> glguy: consider the case where a third party is pushing patches between each time you pull and push
23:54:52 <glguy> sjanssen: then too bad
23:55:05 <glguy> that doesn't justify producing unknown state
23:55:11 <glguy> if you don't know what they are pushing
23:55:11 <sjanssen> seems like a stupid restriction
23:55:37 <glguy> dvcs is pull oriented
23:55:38 <dons> semantics are hard. maybe that's why there's no good patch theory papers.
23:55:41 <glguy> pushes are  centralized
23:56:15 <glguy> oriented
23:56:35 <cjs> So this warning is bugging me, but I'm not quite sure what to do about it. http://paste.lisp.org/display/65185
23:56:36 <glguy> git and darcs try to support both models
23:56:41 <lispy> dons: Yeah, every time I think I have a nice way to write about the patch theory I find out instead I have a misunderstanding.
23:56:54 <cjs> I'm wondering if I'm actually approaching the problem in the wrong way or something like that.
23:57:25 <sjanssen> cjs: what happens when the last argument is []?
23:57:30 <cjs> It can't be.
23:57:32 <sjanssen> ah
23:57:33 <Korollary> lispy: isn't droundy your advisor?
23:57:39 <dons> it's an intriguing thing, patch theory. we all have some intuitive idea of how things are supposed to work, but it's all a bit ad hoc and ill specified.
23:58:16 <cjs> split' is only ever called from split and itself, split calls it with [[]], and split' never empties it.
23:58:20 <lispy> dons: especially these things "mergers" and "conflictors"
23:58:30 <cjs> Not that I'm sure it's good idea to write code this way.
23:58:35 <lispy> dons: they are based on things that don't have clear definitions, so how clear can they be?
23:58:51 <lispy> Korollary: yes, he is.  But, I haven't actually been in the same room as him in over 12 months
23:58:53 <cjs> If it is, I can always just put in a pattern match for _ _ [] = error "Can't get here." or something like that.
23:59:10 <lispy> Korollary: it's complicated :)
23:59:20 <sjanssen> glguy: personally, I'd rather always have the option to push my patches -- but the tool could encourage me to pull patches first
23:59:36 <Korollary> lispy: I started to suspect if anybody at all has a clear definition
23:59:53 <sjanssen> glguy: for example, 'darcs push' could interactively pull patches first
23:59:57 <lispy> Korollary: the source code has some definition.
