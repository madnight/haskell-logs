00:06:18 <chylli> @point isInList p l = foldl ( \x y -> x || p==y ) False l
00:06:19 <lambdabot> Maybe you meant: pointful pointless pointy
00:06:30 <chylli> @pointless isInList p l = foldl ( \x y -> x || p==y ) False l
00:06:31 <lambdabot> isInList = flip foldl False . flip ((.) . (||)) . (==)
01:03:23 <pozic> Which Haskell project puts 4858 lines of code in one file?
01:07:32 <pozic> "Also, it fills all free memory with the value 0xaaaaaaaa (the sound of GHC disappearing down a hole)."
01:08:52 <b\6> pozic: i give up. please tell. haskell port of ms office?
01:09:48 <pozic> b\6: GHC
01:15:52 <b\6> pozic: i see the file you're talking about, but it doesn't look too terrible.
01:15:56 <b\6> compare to gcc or something.
01:16:48 <pozic> b\6: no, but some project was ridiculed recently, because it had 1500 LOC in one file.
01:18:12 <b\6> dunno who would get upset about that. i see way worse than that.
01:18:28 <pozic> I don't really get why compiler implementor like # and __ symbols so much.
01:18:35 <pozic> implementors*
01:19:14 <pozic> It's just a redundant marker saying: we are doing some low-level stuff here.
01:20:00 <pozic> Also high-level/low-level is not really well-defined.
01:21:02 <twanvl> Usually the reason for using names with #, $ and __ is that source programs will never use those names, so there is no risk of a name clash
01:21:54 <pozic> twanvl: with a module system there is no such problem.
01:27:32 <znutar_> with a naming convention you can tell at a glance where the thing should fit in the module system though, so it's eassy to catch some kinds of mistakes
01:28:39 <znutar_> it's not worth it wasting brain sugar on remembering whether the outside world should know about __tweedle
01:29:41 <quicksilver> module systems only solve the problem if you are prepared to use qualified names always.
01:29:49 <quicksilver> if you ever prefer the convenience of unqualified names
01:30:01 <quicksilver> then some namespacing within the unqualified name is helpful.
01:30:06 <quicksilver> it's a hack but a useful one.
01:32:33 <pozic> # is a kind of qualifier.
01:32:49 <pozic> It's just that it's not understood by this module system.
01:40:40 <stulli> Does anybody know what this error message means:
01:40:43 <stulli> http://hpaste.org/9662
01:41:14 <stulli> something about "unknown symbol `stat64'"
01:41:43 <quicksilver> stulli: that means everything is broken.
01:42:02 <stulli> ow, that doesnt sound too good...
01:42:21 <quicksilver> somehow that library got miscompiled
01:42:28 <quicksilver> not sure how that can happen...
01:50:38 <matthew-_> @type hSeek
01:50:39 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
01:52:40 <__me> Handle -> SeekMode -> Integer -> IO ()
01:54:31 <quicksilver> matthew-_: I found it useful in one project to have a typeclass for seekable.
01:54:42 <quicksilver> so I could run seek-type algorithms in a pure model.
01:54:46 <quicksilver> nice for quickcheck etc.
01:55:01 <b\6> quicksilver: you do opengl stuff? have a repo i can check out for study?
01:55:16 <quicksilver> b\6: nothing uploaded unfortunately
01:55:22 <quicksilver> except a few fragments in hpaste.
01:55:26 <matthew-_> quicksilver: I just wanted to check it works on Integer and not Int (large file support)
01:55:28 <quicksilver> feel free to ask questions though ;)
02:37:59 <myxie> Hi there. I have a bounded, enumerated data type (same as integers 1..N). How can I define instance Random for this? Also, I need random permutations of [1..N]. Is this something I should do with class/instance (Arbitrary?) or should I just do it with a simple function? Thanks.
02:38:45 <myxie> I've not found any examples of instance Random outside the base classes.
02:39:44 <quicksilver> @src Random
02:39:45 <lambdabot> class Random a where
02:39:45 <lambdabot>   random    :: RandomGen g => g -> (a, g)
02:39:45 <lambdabot>   randoms   :: RandomGen g => g -> [a]
02:39:45 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
02:39:45 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
02:39:47 <lambdabot>   randomRIO :: (a,a) -> IO a
02:39:49 <lambdabot>   randomIO  :: IO a
02:39:57 <quicksilver> myxie: use the random instance for Int
02:40:01 <quicksilver> myxie: and then reduce modulo N
02:40:07 <quicksilver> would be the simplest way I would think.
02:40:20 <myxie> Found the answer to a): http://64.233.183.104/search?q=cache:nHdWopXiktsJ:book.realworldhaskell.org/beta/bloomfilter.html+%22instance+Random%22+haskell&hl=en&ct=clnk&cd=15&gl=uk&client=firefox-a
02:40:22 <lambdabot> Title: Chapter 27. Advanced library design: building a Bloom filter, http://tinyurl.com/5dv8sy
02:41:50 <myxie> At least, I'll try this. quicksilver: any idea which of all those need to be defined and which can be left out?
02:43:04 <quicksilver> should say in the docs
02:43:46 <quicksilver> myxie: "Minimal complete definition: randomR and random."
02:43:55 <quicksilver> myxie: from http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#t%3ARandom
02:43:57 <lambdabot> Title: System.Random, http://tinyurl.com/3yau3k
02:44:59 <myxie> Yup, random and randomR.
02:54:10 <eu-prleu-peupeu1> hi
03:00:50 <oklopol> eu-prleu-peupeu1: do you prefer bayesian networks or undirected graphs, as concepts, without context?
03:03:09 <quicksilver> I suspect bayesian networks are a complex word for a simple thing designed to allow consultants to charge large fees.
03:03:17 <quicksilver> As such, I would prefer bayesian networks if I was the consultant.
03:03:27 <eu-prleu-peupeu1> i never worked with bayesian networks, so i can't say much about that oklopol
03:04:55 <oklopol> eu-prleu-peupeu1: me neither, as i suspect they are something like a system that learns from input-output pairs, compare the concept of an undirected graph to that of a system that learns from input-output pairs (in order to find out the "function" between input and output)
03:05:03 <oklopol> and decide the one that sounds nicer
03:05:07 <pozic> Do you prefer apples over oranges?
03:05:33 <pozic> Can we get even more off-topic?
03:05:36 <oklopol> :)
03:05:52 <oklopol> i like to be random when a channel is inactive
03:05:52 <pozic> What do you think about Obama?
03:06:11 <myxie> Blake is up against Gonzalez.
03:06:48 <myxie> But Gonzalez fights back from 0-40 to AD-40.
03:07:18 * rwbarton wonders how live the various broadcasts around the world are...
03:07:20 <oklopol> i got the answer already, eu-prleu-peupeu1, so no need to answer anymore
03:07:37 <quicksilver> if a zygohistomorphism and a hylomorphism had a fight...
03:07:42 <quicksilver> what colour woudl the winner's eyes be?
03:09:10 <codacola> hm, i dont remember this channel being so big
03:09:17 <quicksilver> @users
03:09:17 <lambdabot> Maximum users seen in #haskell: 490, currently: 445 (90.8%), active: 9 (2.0%)
03:09:23 <quicksilver> it's growing slowly
03:12:26 <codacola> why does #c have to be ##c but haskell gets #haskell?
03:13:11 <quicksilver> because #haskell is the official channel of a community centred project, or something
03:13:16 <quicksilver> I forget the exact criterion
03:13:24 <codacola> heh
03:13:31 <quicksilver> to be '#' you must (a) in some sense official and (b) open source / community based
03:13:48 <Beelsebob> yeh, god knows how #macosx exists
03:14:04 <quicksilver> because freenode is huge and they don't police it very fast.
03:14:09 <quicksilver> ;)
03:14:33 <Beelsebob> eh? it'd be pretty high on the policing list -- it's almost the same size as #haskell
03:16:48 * quicksilver nods
03:20:39 <codacola> need to get a "non geeky" person to read my work :|
03:20:57 <Axman6> what for?
03:21:00 * codacola can get back to haskell in a few hours
03:21:24 <codacola> essya thing. gotta make sure its completely understandable to non geeky people :P
03:21:56 <codacola> once thats done, its back to haskell
03:53:51 <Axman6> codacola: i'll take a look if you want.
04:00:35 <chylli> :Prelude> :k (->)
04:00:35 <chylli> (->) :: ?? -> ? -> *
04:00:35 <chylli>  
04:00:43 <chylli> why it is ?? not * ?
04:04:15 <eu-prleu-peupeu1> check this out: http://www.youtube.com/watch?v=Bz7AukqqaDQ
04:04:19 <rwbarton> chylli: it's some ghc-specific internal thing.
04:04:19 <lambdabot> Title: YouTube - Cinema 2.0 follow-up with Jules Urbach - LightStage
04:04:21 <eu-prleu-peupeu1> completly off-topic, but cool :D
04:04:44 <chylli> rwbarton: ok. as a newbie, I dont study it now. thanks
04:04:45 <rwbarton> chylli: it means a and b in a -> b can be unboxed types, or something
04:05:15 <chylli> I dont know what is unboxed types. but still thank you.
04:14:10 <therp> eu-prleu-peupeu1: wow
04:28:17 <chylli> is it possible definition of data type have class context ?
04:28:44 <chylli> like data (Num a) => MyType a => Mytype a
04:28:51 <quicksilver> you can do something like that, yes.
04:28:54 <quicksilver> Don't, though.
04:29:02 <chylli> data (Num a) => MyType a = Mytype a
04:29:08 <chylli> what ? yes or no ?
04:29:16 <quicksilver> You can do it, but do not do it.
04:29:19 <quicksilver> should not do it.
04:29:20 <quicksilver> ;)
04:29:41 <chylli> that is, haskell support it in syntax
04:29:52 <chylli> but that is not a good idea
04:30:07 <chylli> can you explain it a little ?
04:30:45 <EvilTerran> doing so requires you to put the same class context on every relevant type annotation in your program
04:31:15 <EvilTerran> which can be a useful sanity check, but is mostly just irritating
04:31:18 <EvilTerran> look at Data.Set, for instance
04:31:36 <chylli> ok, thanks
04:31:42 <EvilTerran> if "data Set a" were "data Ord a => Set a", then
04:31:47 <EvilTerran> ?type Data.Set.singleton
04:31:49 <lambdabot> forall a. a -> S.Set a
04:31:57 <quicksilver> it's worse than that.
04:32:05 <EvilTerran> for instance, would have to be "Ord a => a -> Set a" instead of just "a -> Set a"
04:32:10 <quicksilver> It also doesn't actually give you the advantage you want.
04:32:16 <quicksilver> it doesn't give you the constraint when you deconstruct
04:32:23 <EvilTerran> quicksilver, ... it doesn't?
04:32:25 <quicksilver> actualy that's kind of what EvilTerran just said.
04:32:28 <quicksilver> no, it doesn't.
04:32:35 <quicksilver> Only with GHC/GADT extensions does that work.
04:32:40 <EvilTerran> =/
04:32:48 <quicksilver> the GHC/GADT version of constructor contexts is somewhat useful.
04:33:20 <EvilTerran> it's not really what i just said, i was thinking it did, and that was why you needed it on all explicit type sigs
04:33:30 <EvilTerran> it is worse than that D:
04:34:05 <EvilTerran> quicksilver, any idea why the report does it that way?
04:34:13 <quicksilver> it's thought to be a bug.
04:34:29 <EvilTerran> as in, they made a mistake in specifying it?
04:34:33 <quicksilver> or at least an unanticipated behaviour.
04:34:33 <quicksilver> yes.
04:35:29 <chylli> thanks
04:39:32 <osfameron> :t (2*) . (\x -> (x/))
04:39:34 <lambdabot> forall a. (Fractional a, Num (a -> a)) => a -> a -> a
04:39:43 <osfameron> what does Num (a->a) mean here?
04:40:00 <hodgekin> why does hugs crash when i do: let (n, tot) = foldl (\(i, t) v -> (i + 1, v + t)) (0, 0.0) [1..100000] in tot / fromIntegral n
04:40:49 <osfameron> @pl mortgage y i p = mortgage' 365 y i p * (365.0/12.0)
04:40:50 <lambdabot> mortgage = flip flip (365 . 0 / 12 . 0) . ((flip . ((*) .)) .) . mortgage' 365
04:40:59 <osfameron> bah, flip :-(
04:41:13 <osfameron> we were hoping for something like: mortgage = (365.0/12.0*) . (mortgage' 365)
04:41:15 <kpreid> :t (\x -> (x/))
04:41:16 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:41:23 <hodgekin> is foldl using up heap/stack space or something?
04:41:50 <kpreid> osfameron: see, it takes two parameters. so when you compose (2*) with that you're trying to multiply an (a -> a) by 2
04:42:16 <vixey> @pl mortgage (y,i,p) = (365.0/12.0) $ mortgage' 365 (y,i,p)
04:42:16 <lambdabot> (line 1, column 18):
04:42:16 <lambdabot> unexpected "="
04:42:16 <lambdabot> expecting variable, "(", operator or end of input
04:42:26 <vixey> @pl mortgage y i p = (365.0/12.0) $ mortgage' 365 y i p
04:42:27 <lambdabot> mortgage = (((365 . 0 / 12 . 0) .) .) . mortgage' 365
04:42:51 <osfameron> gah, composition of functions with more than one parameter is sucky
04:42:55 <vixey> @pl mortgage y i p = ((365/12)*) $ mortgage' 365 y i p
04:42:56 <lambdabot> mortgage = ((((365 / 12) *) .) .) . mortgage' 365
04:43:50 <vixey> how does mortgage' look ?
04:44:51 <myxie> hodgekin: probably! try foldl'
04:44:56 <osfameron> hpaste isn't announcing any more?
04:45:00 <osfameron> vixey: http://hpaste.org/9664
04:45:40 <EvilTerran> preflex: seen hpaste
04:45:40 <preflex>  hpaste was last seen on #haskell 34 days, 19 hours, 47 minutes and 2 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
04:45:45 <EvilTerran> the bot hasn't been around for a while
04:45:50 <osfameron> ah
04:46:38 <myxie> hodgekin: ghci is happy with 100000 but both foldl and foldl' run out of stack on 1000000
04:46:39 <vixey> @instances Num
04:46:40 <lambdabot> Double, Float, Int, Integer
04:46:43 <hodgekin> myxie: this is where haskell starts to baffle me...
04:47:29 * EvilTerran tries to remember where he saw that good intro to srictness annotations
04:47:54 <hodgekin> myxie: where's the space being accumulated? isn't it possible to run foldl on an arbitrarily-sized list?
04:47:56 <vixey> I am feeling lazy today
04:48:01 <vixey> I think I will hack some haskell
04:48:05 <myxie> likewise, you could try a strict pair (data Stats = Stats !Int !Double)
04:48:34 <EvilTerran> hodgekin, myxie the problem, i think, is that only the tuple is being forced on each step by foldl'
04:48:38 <EvilTerran> and not its elements
04:48:50 <EvilTerran> indeed, a strict tuple might work
04:49:22 <EvilTerran> or foldl (\(i, t) v -> i `seq` t `seq` (i + 1, v + t))
04:49:30 <EvilTerran> er, foldl'
04:49:51 <myxie> Strictness on the tuple is likely to be easier on the eyes in the long run.
04:50:16 <EvilTerran> yes
04:50:35 <EvilTerran> > let (n, tot) = foldl (\(i, t) v -> (i + 1, v + t)) (0, 0.0) [1..1000000] in tot / fromIntegral n
04:50:37 <lambdabot>  Tried to use too much memory
04:50:43 <myxie> Here is a naive shuffle http://hpaste.org/9663 but surely the is a better way?
04:50:46 <EvilTerran> > let (n, tot) = foldl (\(i, t) v -> i `seq` t `seq` (i + 1, v + t)) (0, 0.0) [1..1000000] in tot / fromIntegral n
04:50:49 <lambdabot>  500000.5
04:51:00 <EvilTerran> apparently foldl is sufficient. i guess that makes sense.
04:51:21 <EvilTerran> kinda.
04:53:41 <myxie> hmm, ghci stack overflowed with a strict Pair
04:54:06 <hodgekin> i don't really understand seq (neither of my haskell books mention it, and the definition isn't obvious to me). is the reason it does anything because of the memoisation of its first argument?
04:55:44 <hodgekin> question was badly phrased, sorry: why does the forced evaluation of seq's first argument make any difference to other expressions?
04:56:33 <Zao> The thunk is evaluated and everything that shares it will benefit?
04:56:49 <Zao> s/evaluated/forced/, I suppose.
04:57:24 <hodgekin> Zao: is a thunk equivalent to a named variable?
04:57:28 <myxie> Forces evaluation of i and t BEFORE constructing new thunks for (i + 1, v + t). Right?
04:57:30 <vixey> is Int a subset of Float ?
04:57:39 <myxie> vixey: no
04:57:45 <vixey> thanks myxie
04:57:48 <EvilTerran> vixey, er... i think so, actually
04:57:50 <EvilTerran> Integer isn't
04:57:57 <myxie> Not even in terms of the mathematically representable values.
04:58:03 <hodgekin> EvilTerran: nan, inf?
04:58:10 <EvilTerran> > fromInteger maxBound :: Float
04:58:11 <lambdabot>   add an instance declaration for (Bounded Integer)
04:58:20 <EvilTerran> > fromIntegral (maxBound :: Int) :: Float
04:58:22 <lambdabot>  9.2233721e18
04:58:43 <hodgekin> oops
04:58:45 <EvilTerran> > (maxBound :: Int) == floor (fromIntegral (maxBound :: Int) :: Float)
04:58:47 <lambdabot>  False
04:58:54 <EvilTerran> > (maxBound :: Int) == floor (fromIntegral (maxBound :: Int) :: Double)
04:58:56 <lambdabot>  False
04:58:58 <EvilTerran> hm
04:59:01 <myxie> Certainly not in terms of the type system. However, you can convert in one direction (with loss of accuracy in some cases).
04:59:17 <EvilTerran> vixey, it seems not. that's odd, i thought it was.
05:00:27 <trofimovich> > (1.000000000000001 :: Float) == (1 :: Float)
05:00:29 <myxie> There are (typically?) 2^32 Ints and 2^32 Floats. If there are some Floars not representable by Floats then there must be some
05:00:29 <lambdabot>  True
05:00:32 <myxie> grrrr
05:00:40 <myxie> you know what I mean
05:03:10 <EvilTerran> yeah
05:03:19 <EvilTerran> i thought Double included all Ints, though
05:03:38 <hodgekin> EvilTerran: it does, i believe. i checked it recently.
05:03:54 <hodgekin> hodgekin: (well ieee 64 bit doubles seem to anyway)
05:03:55 <EvilTerran> > (maxBound :: Int) == floor (fromIntegral (maxBound :: Int) :: Double) -- then why didn't this work?
05:03:57 <lambdabot>  False
05:04:33 <trofimovich> > (maxBound :: Int) - floor (fromIntegral (maxBound :: Int) :: Double)
05:04:36 <lambdabot>  -1
05:04:39 <EvilTerran> IEEE 64-bit floats have 52 bits of mantissa, so it should work
05:05:02 <trofimovich> > (maxBound :: Double) - fromIntegral (maxBound :: Int) :: Double
05:05:03 <lambdabot>   add an instance declaration for (Bounded Double)
05:05:21 <trofimovich> > (maxBound :: Double) - (fromIntegral (maxBound :: Int) :: Double)
05:05:22 <lambdabot>   add an instance declaration for (Bounded Double)
05:05:34 <myxie> 53 bits of precision for non-denormal numbers, I think: http://dlc.sun.com/pdf/800-7895/800-7895.pdf
05:05:52 <EvilTerran> trofimovich, Double isn't Bounded
05:06:09 <vixey> http://hpaste.org/9666
05:06:19 <EvilTerran> > (maxBound, maxBound, maxBound, maxBound) :: (Int, Char, Bool, Word8)
05:06:21 <lambdabot>  (9223372036854775807,'\1114111',True,255)
05:06:22 <vixey> x> :t (int + float)
05:06:22 <vixey> (int + float) :: Rational
05:06:25 <trofimovich> oh. yep. strange copy/paste
05:06:32 <vixey> would that be good ?
05:06:51 <trofimovich> 64bit lambdabot :]
05:07:37 <myxie> ? :t LT
05:07:43 <myxie> > :t LT
05:07:45 <lambdabot>   parse error on input `:'
05:07:54 <trofimovich> :t LT
05:07:55 <lambdabot> Ordering
05:07:59 <myxie> :-)
05:08:01 <trofimovich> @t LT
05:08:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:08:04 <trofimovich> ?t LT
05:08:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:08:55 <myxie> > minBound :: Ordering
05:08:57 <lambdabot>  LT
05:09:25 <EvilTerran> ?type LT
05:09:27 <lambdabot> Ordering
05:10:12 <vixey> oh well I'll just code it and see what happens
05:10:53 <EvilTerran> vixey, isn't Rational a superset of Float?
05:11:04 <EvilTerran> oh, nvm, you did it that way
05:11:11 <vixey> did you see my paste?
05:11:20 <vixey> hpaste*
05:11:24 <EvilTerran> yeah
05:11:32 <EvilTerran> sorry, my brain had things upside-down
05:12:31 <vixey> I think I'll split Number into a few parts, so we can get the expected rules on + - * / like associativity and distributivity etc
05:13:50 <EvilTerran> vixey, as in, Group, Ring, Field kinda thing?
05:14:43 <myxie> This seems to answer my shuffle question: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
05:15:43 <myxie> vixey: There have been efforts for restructuring Number etc. over a decade old. So you will likely find some of the proposals if you look for them.
05:17:52 <vixey> @check \x y -> (x / y) * y == x
05:17:54 <lambdabot>  Falsifiable, after 6 tests: 0.0, 0.0
05:18:04 <vixey> @check \x y -> y == 0 || ((x / y) * y == (x  :: Float))
05:18:06 <lambdabot>  Falsifiable, after 16 tests: -0.8333333, 6.375
05:18:16 <vixey> is (/) :: (Number a, Number b, Number c, LUB a b ab, LUB Rational ab c) => a -> b -> c
05:18:20 <vixey> a horribly long type?
05:20:39 <EvilTerran> ... could you put Number in the context in the definition of LUB?
05:21:02 <EvilTerran> class (Number a, Number b, Number c) => LUB a b c
05:21:18 <vixey> would that be a good thing to do?
05:23:41 <hask> OMFG ByteString is soooooo fast compared to String, sick sick sick. Why isnt ByteString the standard?
05:24:13 <hask> First I used strings and it would eat up my whole memory and I couldn't even parse it, then I changed and now it is almost instant.
05:24:27 <EvilTerran> hask, because haskell is designed with clean semantics in mind rather than good performance :P
05:24:44 <EvilTerran> and [Char] has simpler semantics than ByteString
05:26:55 <hask> wtf it forogt i only tested 2 files it actually wasnt that fast
05:28:31 <vixey> :t fromIntegral
05:28:32 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:28:49 <vixey> @src Integral
05:28:50 <lambdabot> class  (Real a, Enum a) => Integral a  where
05:28:50 <lambdabot>     quot, rem, div, mod :: a -> a -> a
05:28:50 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
05:28:50 <lambdabot>     toInteger           :: a -> Integer
05:29:01 <vixey> @src Nuw
05:29:02 <lambdabot> Source not found. You untyped fool!
05:29:02 <vixey> @src Num
05:29:03 <lambdabot> class  (Eq a, Show a) => Num a  where
05:29:03 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:29:03 <lambdabot>     negate, abs, signum     :: a -> a
05:29:03 <lambdabot>     fromInteger             :: Integer -> a
05:29:14 <vixey> so fromIntegral = fromInteger . toInteger
05:29:32 <vixey> is there no other way to write a function like coerce :: (Number a, Number b) => a -> b ?
05:29:49 <vixey> I have a definition for any pair of numbers
05:30:59 <EvilTerran> ?src fromIntegral
05:30:59 <lambdabot> fromIntegral = fromInteger . toInteger
05:31:16 <EvilTerran> vixey, i think it'd have to be in a class
05:31:34 <vixey> if I have (Coerceable a b) => a -> b
05:31:36 <EvilTerran> class (Number a, Number b) => Coerce a b where coece :: a -> b
05:31:43 <vixey> can I the write coerce :: (Number a, Number b) => a -> b ?
05:32:32 <vixey> It can't deduce 'Coerce' from Number a, Number b though
05:32:47 <guenni> quicksilver: ping
05:33:10 <rwbarton> vixey: no; what if two different people independently add new Number instances; they won't know about each other. And the compiler doesn't know that's not going to happen
05:33:32 <vixey> rwbarton: I would like the compiler to detect this
05:33:43 <hodgekin> :type erf
05:34:40 <vixey> why can't you write class (Number a, Number b) where coerce :: a -> b ?
05:34:40 <kpreid> vixey: then you need a Coerce class
05:35:27 <vixey> I have this definition,
05:35:28 <vixey> (+) :: (Number a, Number b, Number c, LUB a b c) => a -> b -> c
05:35:28 <vixey> x + y = coerce x .+. coerce y
05:35:48 <vixey> so it's not possible to implement it without changing the type?
05:36:12 <rwbarton> Make (Coerce a c, Coerce b c) a context for LUB a b c
05:37:06 <vixey> oh that's pretty good
05:37:22 <vixey> hmm
05:39:25 <vixey> :[
05:39:40 <vixey> I think it's impossible to do this without undecidable instances
05:39:50 <EvilTerran> that seems very likely
05:40:32 <EvilTerran> time to switch to Agda? :P
05:41:08 <vixey> time to hack lambda prolog into GHC
05:41:28 <trzkril> tja, kommt halt immer sehr darauf an, wo man gelernt hat
05:41:42 <hodgekin> is there a recommended math library for haskell that implements most of the stuff found in C's math.h? including erf.
05:41:44 <trzkril> damn it
05:42:09 <EvilTerran> hodgekin, erf?
05:42:10 * trzkril needs a "focus follows eyes" module
05:42:59 <hodgekin> EvilTerran: http://en.wikipedia.org/wiki/Error_function
05:43:00 <lambdabot> Title: Error function - Wikipedia, the free encyclopedia
05:43:15 <vixey> how do you turn a Float into a CReal?
05:43:33 <vixey> :t realToFrac
05:43:34 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
05:43:47 <trzkril> ja, in der Schule mogeln die sich irgendwie durch und lernen auch je nach Schule/Bundesland/Lehrern etwas anderes
05:44:01 <EvilTerran> trzkril, yes, you do
05:44:45 <trzkril> maybe some better indicator for the focus would help, hm
05:45:40 * trzkril stops trying to read everything in parallel
05:48:14 <vixey> yay
05:48:14 <vixey> > (1 :: Float) + (2 :: Rational)
05:48:15 <vixey> 3%1
05:48:16 <lambdabot>  Couldn't match expected type `Float'
05:49:03 <ddarius> Don't have multiple windows open at a time.
05:52:51 <crazytown> I am hask
05:53:01 <crazytown> show is incredibly ridicously slow
05:55:42 <quicksilver> "incredibly ridiculously" is a slightly imprecise term.
05:55:52 <quicksilver> show is too slow for some things, though, yes.
05:56:19 <crazytown> but now I know my algorithms are fine at least :)
05:57:16 <crazytown> what I don't get is why B.show doesnt work(I have imported Data.ByteString.Char8 as qualified B
05:57:18 <crazytown> )
05:57:40 <crazytown> and I want to write to a file as bytestring
05:58:41 <quicksilver> show is a global method
05:58:48 <quicksilver> there is no separate B. version
05:58:56 <quicksilver> however you don't want to use show, to write to a file!
05:59:01 <quicksilver> show converts to a String
05:59:17 <quicksilver> that's not a good way, normally, to write a bytestring to a file.
05:59:25 <quicksilver> use B.hPutStr
06:03:29 <vixey> @quote expert
06:03:29 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
06:05:16 <ziman> @quote
06:05:16 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
06:05:39 <vixey> btw
06:05:49 <vixey> does that mean the original quote was "I get the impression that using it would feel like reading a novel written by a literary critic"
06:05:58 <vixey> and someone replace in [haskell] it put context in?
06:06:10 <quicksilver> yes, roughly.
06:06:13 <ddarius> Something like that yes.
06:06:21 <quicksilver> could be 'that' instead of 'it'
06:06:53 <crazytown> I have a list that holds Data-types that has fields of ByteString and Int
06:07:19 <crazytown> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
06:07:24 <crazytown> pretty funnt
06:10:09 <gwern> no, it was it
06:10:12 <crazytown> GHC.IOBase.Handle -> ByteString -> IO () , so it is B.hPutStr filename text ?
06:10:17 <gwern> I remember add/re-adding the quote
06:10:34 <crazytown> nope, doesnt work
06:10:37 <gwern> crazytown: handles are different from filenames, aren't they
06:10:46 <crazytown> Couldn't match expected type `GHC.IOBase.Handle'
06:10:46 <crazytown>            against inferred type `[Char]'
06:10:58 <gwern> thought Filename was a String synonym
06:11:05 <ddarius> @src FileName
06:11:06 <lambdabot> Source not found. :(
06:11:24 <ddarius> type FileName = String
06:11:41 <janszn> @pl (\xs -> zipWith (+) (0:xs) (xs++0:[]))
06:11:41 <lambdabot> ap (zipWith (+) . (0 :)) (++ [0])
06:11:59 <crazytown> GHC.IOBase.Handle -> ByteString -> IO ()
06:12:32 <crazytown> so what do I do? I have the "list of data" and a "filename" and want tow rite it to a file, how?
06:13:36 <quicksilver> crazytown: you need to open the file
06:13:44 <quicksilver> @hoogle openFile
06:13:45 <lambdabot> A Hoogle error occurred.
06:13:48 <quicksilver> !
06:13:56 <quicksilver> crazytown: System.IO.openFile, etc.
06:14:52 <crazytown> can I add hoogle to the firefox upper right search bar?
06:15:32 <dcoutts_> crazytown: yes you can! :-)
06:15:35 <rwbarton> crazytown: Better yet, you can add it to the address bar: go to hoogle, right click the text field and choose "Add a Keyword for this Search"
06:15:37 <quicksilver> http://www.haskell.org/haskellwiki/Hoogle#Firefox_Integration
06:15:48 <lambdabot> Title: Hoogle - HaskellWiki
06:23:03 <trofimovich> @yhjulwwiefzojcbxybbruweejw
06:23:03 <lambdabot> "\""
06:26:40 <nornagon> is that an acronym or something?
06:27:22 <vixey> no
06:29:04 <dmwit> It's an abbreviation for "weird".
06:29:23 <quicksilver> it's the noisy a haskell developer makes if you kick him in the de bruijn index.
06:29:56 <nornagon> @remember quicksilver it's the noise a haskell developer makes if you kick him in the de bruijn index
06:29:57 <lambdabot> Nice!
06:31:36 <vixey> haha
06:32:09 <crazytown> I imported System.IO and then: let handle = System.IO.openFile toFile WriteMode
06:32:17 <SamB_XP> now \bot compliments you on your @quotes ???
06:32:21 <crazytown> now how do I write content "filtered" to that?
06:32:51 <dmwit> hPutStr
06:33:07 <dmwit> ?hoogle Handle -> String -> IO ()
06:33:08 <lambdabot> A Hoogle error occurred.
06:33:13 <dmwit> ... =/
06:33:39 <rwbarton> crazytown: you want   handle <- System.IO.openFile toFile WriteMode
06:33:54 <dmwit> http://haskell.org/hoogle/?q=Handle%20-%3E%20String%20-%3E%20IO%20()
06:33:57 <lambdabot> Title: Handle -> String -> IO ( - Hoogle, http://tinyurl.com/5rs6so
06:35:49 <crazytown> B.hPutStr expects handle+ bytestring, I have handle+[Customer]  where Customer is a data
06:36:32 <quicksilver> you need to decide how to convert Customer to a series of bytes.
06:36:38 <quicksilver> (which is what get stored in files)
06:36:57 <janszn> @type ap (zipWith (+) . (0 :)) (++ [0])
06:36:58 <lambdabot> forall a. (Num a) => [a] -> [a]
06:37:16 <quicksilver> One approach is to use the Data.Binary package and write an instance of the class Binary.
06:37:29 <quicksilver> Another approach is, well, just to define the conversion by hand.
06:39:18 <vixey> > ap (zipWith (+) . (0 :)) (++ [0]) $ [1..]
06:39:21 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
06:39:36 <vixey> > fix $ ap (zipWith (+) . (0 :)) (++ [0])
06:39:43 <rwbarton> > iterate (ap (zipWith (+) . (0 :)) (++ [0])) [1]
06:39:45 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
06:39:52 <lambdabot>  thread killed
06:45:01 <ziman> :t (<+>)
06:45:11 <ziman> @type (<+>)
06:45:12 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:02:07 <sw17ch> ziman, (<+>) :: Doc -> Doc -> Doc
07:02:55 <ziman> sw17ch, thanks
07:14:46 <crazytown>  ?hoogle Handle -> String -> IO ()
07:16:40 <quicksilver> crazytown: hPutStr
07:32:13 <dafra> hi, is the haskell arch overlay supported on i686 ?
07:40:18 <crazytown> is Data.Binary not part of the stdlib?
07:40:18 <crazytown> i ahve to download?
07:40:37 <Botje> yes
07:41:09 <Botje> but you can use cabal-install to install it
07:42:04 <crazytown> where should I put it? in the stdlib directory?
07:46:52 <crazytown> if I want to install Data.Binary, what are the steps or where can I read about it?
07:46:59 <crazytown> I have to compile it somehow?
07:47:21 <maltem> crazytown: in the simplest case, type: cabal install binary
07:47:36 <vixey> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.2
07:47:39 <lambdabot> Title: HackageDB: binary-0.4.2, http://tinyurl.com/59vv3y
07:47:46 <vixey> maybe cabal needs data.binary though
07:50:04 <dcoutts_> vixey: it doesn't
07:52:44 <Botje> crazytown: unpack; runhaskell Setup*hs configure; runhaskell Setup*hs build; sudo runhaskell Setup*hs install
07:53:38 <quicksilver> optional, add --user to configure and remove 'sudo'. If you don't have sudo access.
07:54:02 <Botje> .oO(we should make a poor man's cabal-install)
07:54:37 <dcoutts_> Botje: why? when you can have the real thing :-)
07:54:48 <quicksilver> because the real thing has too many dependencies.
07:54:52 <dcoutts_> bah
07:55:05 <quicksilver> hopeful future bundled/packaged releases will make this problem go away entirely.
07:55:11 <dcoutts_> right, it will
07:55:28 <vixey> Would it be good or bad if ghc was compiled by ghc --make ?
07:55:38 <quicksilver> perfect option: A big download labelled 'GHC' and yet including cabal-install.
07:55:41 <vixey> (some improvents to --make would have  to happen)
07:56:01 <quicksilver> good-enough option: A download labelled 'Cabal-Install' which is *right* *next* *to* the GHC download.
07:56:19 <quicksilver> of course this is all moot to users of apt-get, emerge, etc.
07:56:27 <dcoutts_> vixey: it can I think.
07:56:41 <dcoutts_> quicksilver: no, it should all be part of one platform download
07:57:03 <quicksilver> that was my first option :)
07:57:13 <quicksilver> platform download FTW>
07:57:29 <quicksilver> actually, apt-get FTW. But platform download for people who choose other OSes.
07:58:27 <visq> hello
07:59:04 <visq> i get an 'Unapplicable patch' when doing 'darcs get c2hs'
07:59:15 <visq> any ideas ?
07:59:59 <visq> propably case insensitivity problem: on Mac os X, reporting
08:00:00 <visq> darcs failed:  File './hipar/base/TODO' already exists!
08:01:26 <quicksilver> could be case issue yes
08:02:05 <visq> It is described here: http://bugs.darcs.net/issue404
08:02:14 <lambdabot> Title: Issue 404: darcs get fails on MacOS X (case-insenstive) - Darcs bug tracker
08:02:23 <visq> but I do not know how to fix it :(
08:08:07 * dcoutts_ notes that we could do with some volunteers to help with the Cabal features for Cabal-1.6 / ghc 6.10
08:08:08 <dcoutts_> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&milestone=Cabal-1.6
08:08:15 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/6xrbtd
08:11:01 <Quadrescence> I requested help a few days ago, and I got some for the first one. But the other ones are getting super difficult. :( http://nopaste.com/p/aefgL0rKv
08:11:26 <Quadrescence> (I am trying to put this in "efficient" haskell)
08:11:39 <Quadrescence> w/this/these/
08:11:45 <Quadrescence> s/w/s/
08:11:46 <Quadrescence> :|
08:12:28 <Quadrescence> I think I got the first, second, and third.
08:14:48 <trzkril> hm, wieso dauert "checking connection to mail server" so verdammt lange.
08:15:24 <Axman6> Quadrescence: "(as opposed to naively)"?
08:16:06 <Quadrescence> Axman6: By a very direct imperative-style translation.
08:16:15 <Botje> uh
08:16:22 <Botje> figure out what each algorithm does first? :)
08:16:54 <Quadrescence> Botje: I implemented these algorithms originally in a program I made before I began to learn haskell. >_>
08:17:01 <ekidd_> hackagedb is down?
08:17:56 <Botje> so you know what they do?
08:18:04 <Quadrescence> Yes.
08:18:10 <Botje> then it's just a matter of finding out how to encode that efficiently in haskell :)
08:18:22 <Quadrescence> Yes...
08:18:30 <Axman6> Quadrescence: writing down what they actually do would probably be more helpful than just the psudocode
08:19:17 <Quadrescence> Axman6: That was kind of the point of the INPUT/OUTPUT stuff I added.
08:19:47 <Quadrescence> All of the algorithms are called xxx2idx, and it's corresponding pair idx2xxx
08:19:48 <Axman6> well, it tells you the types, but it doesn't say what they should do
08:20:20 <rwbarton> Looks like they generally convert between a permutation of length n and its index in the sorted list of all such permutations, and similarly for combinations
08:20:27 <rwbarton> Though, what is p in the last two?
08:20:34 <Quadrescence> rwbarton: bingo.
08:22:10 <rwbarton> Well, idx2p is not especially efficient to begin with (O(n^2))
08:22:46 <rwbarton> You could write a function that takes an index and a list of numbers to permute (starts out as [1..n]), divides the index by (n-1)! to figure out the first element, then removes it from the list and recurses
08:23:38 <tromp> easier to take modulo n
08:23:59 <rwbarton> Yeah, but then they're not in sorted order.
08:24:16 <tromp> or, if you wanna be nasty, (cycle list)!!idx
08:25:41 <tromp> shld be sorted if you start figuring out last element?
08:26:09 <tromp> hmm, maybe not
08:26:37 <rwbarton> right, it's not easy to figure out the last element
08:28:50 <tromp> isn't this called (un)ranking ?
08:29:34 <Quadrescence> rwbarton: oops, I forgot to explain that (what p is). It's kind of hard to explain. bleh. The combination list cm contains some identical elements. If an element is one of these identical ones, then that element is p.
08:30:10 <rwbarton> Quadrescence: I'm just going to replace cm :: [Int] with cm :: [Bool] and p with True, ?
08:30:41 <rwbarton> and m is the number of Trues
08:31:01 <besiria> if (>>=) is called bind, what (>>) is called?
08:31:31 <vixey> bin
08:32:44 <Quadrescence> rwbarton: Hmmmmm
08:33:38 <Quadrescence> rwbarton: That's fair I suppose. :>
08:34:06 <crazytown> i am running "runhaskell Setup.lhs install" and it tries to install into c:/program files/haskell which is not what I want and anyway it says permission denied
08:34:36 <RayNbow> twanvl: nice blog post on generic merge :)
08:34:54 <tromp> @pl \x -> x
08:34:54 <lambdabot> id
08:35:00 <twanvl> RayNbow: thanks
08:35:04 <tromp> @pl \x y -> x (const y)
08:35:04 <lambdabot> (. const)
08:35:12 <rwbarton> Quadrescence: Actually I'm not sure how the sorting works on that one
08:35:26 <tromp> @pl \x y -> bind x (const y)
08:35:26 <lambdabot> (. const) . bind
08:35:27 <vixey> can you link to it?
08:35:28 <Quadrescence> crazytown: I had this problem. There is a file you'd have to edit somewhere to change the paths.
08:35:37 <crazytown> how do I change the script to put it somewhere else and how do I give access?
08:35:49 <Quadrescence> rwbarton: None of this does sorting.
08:37:29 <quicksilver> besiria: 'then' ?
08:37:33 <ziman> the conversion perm <-> lexicographical index can be done in O(n), iirc
08:37:52 <quicksilver> crazytown: did you configure with --user?
08:39:05 <Quadrescence> ziman: I believe that's correct. Usually, it's converted to Lehmer code, and then converted from a factoradic to decimal.
08:41:07 <rwbarton> Huh.  I found a paper that claims to rank and unrank permutations in linear time, but the ordering isn't lexicographical
08:41:36 <Quadrescence> rwbarton: Actually, in this application, it only matters that [1..n] --> 0
08:42:37 <ziman> i've done it for homework a year ago or so
08:42:42 <Quadrescence> rwbarton: Link?
08:42:42 <ziman> but it's in pascal
08:44:04 <rwbarton> Quadrescence: it's in ScienceDirect...
08:44:12 <Quadrescence> rwbarton: Yeah, I see now. :(
08:47:12 <rwbarton> Quadrescence: but the paper is only 3 pages, so maybe I'll just implement it :P
08:48:12 <rwbarton> Quadrescence: ah, here it is: http://www.ii.uni.wroc.pl/~lorys/IPL/IPL79-6-2.pdf
08:48:15 <lambdabot> Title: cache:http://www.ii.uni.wroc.pl/~lorys/IPL/IPL79-6-2.pdf - Google Search
08:49:57 <Quadrescence> rwbarton: Thanks. :)))
08:51:55 <crazytown> quicksilver: no, how do i configure with user jus add --user?
08:52:14 <quicksilver> yes, to the setup step
08:53:05 <guenni> about Leksah, has anybody installed that on Win XP?
08:53:53 <crazytown> to all steps? it worked for configure not for build
08:54:20 <guenni> crazytown: it's broken then?
08:54:34 <quicksilver> only necessary for configure, crazytown
08:54:36 <quicksilver> hopefully.
08:54:41 <quicksilver> and then you don't need sudo to install
08:54:50 <crazytown> I am using windows vista
08:54:50 <quicksilver> but you probably dont' have sudo on that benighted platform
08:54:53 <crazytown> no sudo
08:55:14 <crazytown> i have cygwin but it crahsed when installing curl
08:56:54 <crazytown> #!/usr/bin/env runhaskell
08:56:59 <crazytown> should I change that?
08:57:26 <crazytown> its in Setup.lhs
08:58:15 <Quadrescence> the path to C:/program files/haskell is hardcoded somewhere I presume
08:58:20 <Quadrescence> Search around for that path
08:58:44 <quicksilver> Quadrescence: It won't be, no.
08:58:45 <Quadrescence> (it was hardcoded in the stuff I was installing several weeks ago before linux)
08:59:06 <Quadrescence> Not in setup.lhs
09:01:59 <crazytown> its not in setup, what you mean hardcoded?
09:02:55 <Quadrescence> crazytown: It was in some directory after I ran configure
09:04:30 <crazytown> found it
09:04:39 <crazytown> dist/build/autogen
09:08:07 <crazytown> --bindir     = "C:\\Program Files\\Haskell\\bin"
09:08:07 <crazytown> --libdir     = "C:\\Program Files\\Haskell\\binary-0.4.2\\ghc-6.8.3"
09:08:07 <crazytown> --datadir    = "C:\\Program Files\\Haskell\\binary-0.4.2"
09:08:07 <crazytown> --libexecdir = "C:\\Program Files\\Haskell\\binary-0.4.2"
09:08:13 <crazytown> i change to?
09:08:18 <crazytown> bindir     = "C:\\ghc-6.8.3\\\\bin"
09:08:19 <crazytown> libdir     = "C:\\ghc-6.8.3\\binary-0.4.2"
09:08:19 <crazytown> datadir    = "C:\\ghc-6.8.3\\lib\\binary-0.4.2"
09:08:19 <crazytown> libexecdir = "C:\\ghc-6.8.3\\lib\\binary-0.4.2"
09:08:21 <Quadrescence> I would.
09:08:38 <crazytown> i dont get the libdir
09:10:08 <crazytown> it still looks into C:\program\haskell wtf
09:11:51 <vixey> :(
09:12:07 <vixey> maybe there is a parameter you pass to configure
09:12:36 <crazytown> in some toher file then...
09:12:47 <vixey> no not in any file
09:12:47 <crazytown> cant find any other
09:12:59 <vixey> I mean you know how you did runhaskell Setup configure
09:13:07 <crazytown> I did
09:13:13 <vixey> what about  runhaskell Setup configure -prefix=/something
09:13:15 <vixey> or something like
09:16:08 <crazytown> what should be insetad of -prefix=/something
09:16:45 <eu-prleu-peupeu1> how do i override the (+) and (-) functions in haskell ?
09:17:05 <eu-prleu-peupeu1> is it possible to have many definitions of the (+) function, and let haskell choose the best according to its type signature ?
09:17:05 <ddarius> You don't.
09:17:11 <profmakx> You don't.
09:17:15 <profmakx> ahrx!
09:17:20 <eu-prleu-peupeu1> hmm
09:17:20 <bd_> You can define a new instance of Num
09:17:22 <vixey> that's exactly how it works
09:17:34 <bd_> which would choose a version of (+) and (-) depending on the type signature
09:17:44 <bd_> you can't override it for /existing/ types though - you need to make a new one
09:17:48 <bd_> using newtype is sufficient
09:17:56 <eu-prleu-peupeu1> ok
09:17:57 <eu-prleu-peupeu1> nice
09:17:59 <eu-prleu-peupeu1> thanks :)
09:18:42 <bd_> you can also override it for a limited scope:
09:18:54 <bd_> > ( 1 + 1, let (+) _ _ = 0 in 1 + 1 )
09:18:55 <lambdabot>  (2,0)
09:21:53 <ddarius> bd_: That's not "overriding" that's shadowing and will, for example, make any use of the real (+) more difficult.
09:22:47 <rwbarton> Suppose I have some type Foo which is almost a Num instance, but I don't want to implement abs or signum.  Is there a way to detect and reject a use of abs on Foo at compile time?  (I suspect not)
09:22:49 <eu-prleu-peupeu1> hmm
09:22:53 <eu-prleu-peupeu1> ok
09:23:40 <bd_> ddarius: I didn't say it was a /good/ idea :)
09:23:51 <eu-prleu-peupeu1> hmm
09:23:56 <ski> rwbarton : there isn't .. (ooi, what is `Foo' ?)
09:24:08 <ddarius> bd_: My point isn't that it is bad or good but that it doesn't do what eu-prleu-peupeu1 originally described.
09:24:10 <rwbarton> ski: (Usually, integers mod n for some n)
09:24:18 <eu-prleu-peupeu1> if i inherit from Num in my type class, can i extend it by supplying more (+) and (-) methods ?
09:24:45 <bd_> eu-prleu-peupeu1: what do you mean 'inherit'?
09:24:57 <eu-prleu-peupeu1> http://en.wikibooks.org/wiki/Haskell/Class_Declarations#Class_Inheritance
09:25:10 <lambdabot> Title: Haskell/Class declarations - Wikibooks, collection of open-content textbooks, http://tinyurl.com/6ka9kl
09:25:21 <ski> there is but one `(+)' method in `Num'
09:25:43 <bd_> oh, then no; adding a new, say, class Num b => Foo b where (+) :: Num a => a -> b -> b   or something would result in a namespace clash - there can only be one (+)
09:25:50 <bd_> this is in contrast to C++, of course
09:26:04 <bd_> the reason being that it makes type inference nearly impossible
09:26:25 <bd_> and you can't always prove that some type doesn't match multiple cases
09:26:37 <eu-prleu-peupeu1> i see
09:26:38 <eu-prleu-peupeu1> :/
09:26:45 <bd_> you can define a new function
09:26:48 <rwbarton> eu-prleu-peupeu1: On the other hand, there is an infinite supply of alternate operator names
09:26:49 <bd_> :+ or something
09:26:56 <eu-prleu-peupeu1> add  :P
09:26:57 <bd_> s/function/operator/
09:26:58 <ski> (well, i suppose one might be able to define a `(+)' in `Foo', but then have to resort to module qualifying to access both)
09:27:07 <ddarius> :+ would be a constructor and is already used by Data.Complex
09:27:13 <bd_> ski: import Prelude hiding considered harmful
09:27:25 <bd_> oh. er. <+> or something then :)
09:27:26 <ski> bd_ : why ?
09:27:46 <eu-prleu-peupeu1> >[{+}]<
09:27:46 <bd_> ski: it's redefining the language itself, which may confuse a casual reader
09:28:18 <ski> bd_ : as long as there's notes indicating what is done (and there's a good purpose), i don't see any problem
09:28:36 <ski> (and i don't think it amounts to any redefining of the language ..)
09:29:36 <eu-prleu-peupeu1> ill just use "add" then
09:30:05 <eu-prleu-peupeu1> and then use Module.add whenever i want to add stuff
09:30:10 <eu-prleu-peupeu1> thanks
09:30:12 <rwbarton> eu-prleu-peupeu1: so you have a class with both (+) and add methods?  That sounds... confusing
09:30:22 <eu-prleu-peupeu1> no
09:30:24 <bd_> eu-prleu-peupeu1: out of curiosity, what operation are you defining?
09:30:28 <eu-prleu-peupeu1> i wont use (+)
09:30:30 <eu-prleu-peupeu1> its vector add
09:30:34 <rwbarton> eu-prleu-peupeu1: oh ok.
09:30:53 <bd_> eu-prleu-peupeu1: well, you can use <+> if you'd prefer, or `add` will also get you infix-ness.
09:31:02 <ddarius> Except that all the methods don't make sense, you can easily make your vector type an instance of Num.
09:31:07 <eu-prleu-peupeu1> i just thought, like (+) works for Ints and Floats and Doubles, it will probably be possible to extend it to work on Vector :P
09:31:20 <bd_> ddarius: how would fromInteger be implemented?
09:31:22 * ski thought vector addition took two vectors in the same space, and gave another vector in the same space ..
09:31:29 <bd_> ddarius: or signum?
09:31:43 <ddarius> bd_: fromInteger = undefined; signum = undefined
09:31:55 <eu-prleu-peupeu1> ddarius, but has to be specified on the data declaration, how do i specified it on the type class ?
09:32:00 <bd_> ddarius: now 4 * someVector = undefined
09:32:16 <bd_> (at runtime)
09:32:17 <ddarius> bd_: Indeed. (*) = undefined
09:32:46 <bd_> ddarius: Your vector implements only two members of Num's seven. That sounds like it's the wrong typeclass :)
09:32:55 <ddarius> bd_: Blame the designers.
09:32:58 <bd_> well, three, negate works fine
09:33:15 <bd_> ddarius: better to make a new typeclass imo... you'll need vector multiplication (by vector or scalar) etc
09:33:18 <ddarius> I'd prebably use a new typeclass altogether.
09:33:38 <rwbarton> there's a package on hackage that uses (^+^) and (^-^) for vector space operations...
09:33:48 <rwbarton> ... the smiley operator?
09:33:59 <ddarius> Everyone loves linear algebra!
09:34:20 <Crecerelle> Am I a very bad person for making *String* an instance of Num for some Project Euler problems?
09:34:36 <EvilTerran> yes
09:34:39 <Quadrescence> What does "amortized" mean?
09:34:48 <ddarius> @wn amortized
09:34:55 <EvilTerran> "taking the average over a series of operations", approximately
09:35:03 <lambdabot> Error: thread killed
09:35:09 <bd_> Quadrescence: it means that although running the operation one time may not meet the stated time bounds, if you repeat it many times, on average it will be within the stated bounds
09:35:10 <ddarius> Thanks lambdabot.
09:35:14 <bd_> s/time /
09:35:21 <bd_> s/time // even :)
09:35:31 <Quadrescence> bd_: Ah, makes sense.
09:35:38 <ddarius> s$s/time/$s/time //$
09:36:40 * BMeph wonders how well the vector-space package handles geometric algebra...
09:37:02 <bd_> s/s\$s\/time\/\$s\/time\/\/\$/s\/s\\\/time\\\/\/s\/time \\\/\\\/\//
09:37:59 <Quadrescence> So, for example, suppose access time to a list of integers is O(n) for list length n (worst case access of last element), then the amortized running time would be n/2 (I know this isn't proper O-notation...but hopefully it's understood), right?
09:38:25 <Quadrescence> amortized running time FOR RANDOM ACCESS OF ELEMENTS*
09:38:45 <Quadrescence> Distributed equally among the elements**
09:39:51 * SamB frowns at what Quadrescence is saying
09:39:57 * SamB isn't sure it makes sense
09:39:58 <Quadrescence> Blah, nevermind. :|
09:40:16 <ddarius> Amortized is not about randomness, it says that expensive operations at one time will be made up by cheap operations at another.
09:40:45 <bd_> one example would be a queue, where popping a value is O(1) for n times, then O(n) once
09:40:57 <rwbarton> e.g. imagine you have a C++ vector and you're appending elements, so you need to resize it
09:41:06 <bd_> on average, you're still O(1), but every once in a while, you get a big hit
09:41:10 <rwbarton> if you resize after adding every element, then each append will be O(n)
09:41:53 <rwbarton> but if you double the size when your space fills, you do many fewer copies and it only takes O(n) time to do n appends (even though a small number of those took a long time each).
09:43:20 <Quadrescence> Wait, does big-O notation imply amortized running time?
09:43:51 <Quadrescence> Or, is big-O == amortized running time?
09:43:57 <ddarius> Quadrescence: No
09:44:02 <Quadrescence> Okay, good.
09:44:22 <Quadrescence> If that were the case, then I would have been wrong about big-O all this time.
09:44:36 <Quadrescence> Anyway, I get it now.
09:44:38 <Quadrescence> Thanks everyone.
09:46:18 <Quadrescence> Are there any good books/websites/PDFs/whatever with algorithms for Haskell? (be it a general book/etc or a specific document like "Lazy Depth-First Search and Linear Graph Algorithms in Haskell")
09:46:43 <ddarius> Okasaki's "Purely Functional Data Structures"
09:48:47 <Quadrescence> ddarius: Thanks. A quick google search returns a PDF result. :>
09:49:33 <atomb> i haven't read it myself, but i recently came across "Algorithms: A Functional Programming Approach" (http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html)
09:49:34 <mfp> Quadrescence: that's probably his thesis. The book expands on it.
09:49:40 <lambdabot> Title: Algorithms: A Functional Programming Approach
09:49:44 <mfp> *his PhD thesis
09:49:45 <Quadrescence> :O oh.
09:50:55 <Quadrescence> I wish books which are designed to expand one's knowledge were free sometimes. D:
09:51:10 <atomb> me too
09:52:44 <BMeph> Hm? When are they NOT free? :)
09:54:13 <Quadrescence> BMeph: When they are not piratable or when they are published by a publisher.
09:54:45 <Quadrescence> Wait, piratable? I meant /printable/. Oops.
09:54:49 <Quadrescence> ;)
09:55:36 <quicksilver> there is a slow but increasing trend towards free books.
09:55:41 <quicksilver> Real World Haskell will be free.
09:55:56 <quicksilver> despite - or rather, especially because of - that, I shall buy a copy.
09:55:57 <Quadrescence> I don't mind books that cost money in physical form really.
09:56:22 <Quadrescence> And if the book really helps/expands my knowledge, of course I'd buy a copy!
09:56:55 <Quadrescence> Or if it was offered free, but you could buy a copy toward donation, etc, then I would be more inclined to get a copy then, too.
09:57:58 * RayNbow prefers hard copies
09:58:08 <RayNbow> (I just don't like reading large texts from screen :p)
09:58:15 <Quadrescence> RayNbow: Everyone prefers hardcopies.
09:58:33 <Quadrescence> But if it's being used for reference, it can be a different story.
09:59:19 <Crecerelle> Actually, I prefer to read books on my computer no matter what... I guess I'm weird that way?
09:59:56 <ddarius> Crecerelle: Yep.
10:00:31 <crazytown> where can I find te runhaskell command? I mean the definition of it? I guess it could be runhaskell that is defined to perform things in c:\program files/haskell
10:01:46 <Quadrescence> crazytown: I don't think that's the case, but I'll keep my mouth shut.
10:03:36 <Jedai> I prefer reading them on a good ebook reader (I believe I'll do though I never used one of those...) ^^
10:04:37 <guenni> Beelsebob: ping
10:04:57 <RayNbow> <Quadrescence> But if it's being used for reference, it can be a different story. <-- ah, yeah... printouts and books lack Ctrl+F :p
10:05:00 <vixey> what's the name of the algorithms that do typeclass dispatch?
10:05:08 <guenni> BeelsebobWork: ping
10:05:16 <Quadrescence> RayNbow: I _ALWAYS_ want ctrl-F in a book.
10:05:31 <ddarius> It's called an index.
10:05:35 <eu-prleu-peupeu1> my baby cat just died :(
10:05:39 <Quadrescence> One time in school, I accidentally pressed my fingers on the book where ctrl-F would be.
10:05:54 <RayNbow> ddarius: indices are unfortunately not always complete
10:05:58 <Quadrescence> ddarius: Haven't you ever seen a book with a bad index?
10:06:04 <Quadrescence> eu-prleu-peupeu1: Awwwww. :'(
10:06:29 <bos> buon giorno.
10:06:35 <eu-prleu-peupeu1> i found them on the street, after one week without eating, one of them just died now :( :(
10:06:37 <RayNbow> vixey: typeclass dispatch?
10:08:00 <RayNbow> eu-prleu-peupeu1: that's some sad news... :/
10:09:54 <crazytown> can't I run darcs without cygwin? it asks for curl or wget and fails
10:11:17 <lament> you could presumably get curl or wget without cygwin
10:12:18 <dmhouse> Wait, you can use _Windows_ without Cygwi?
10:12:24 <dmhouse> I certainly couldn't.
10:12:35 <guenni> how can I ask GHC which packages are installed?
10:12:44 <chrisdone> ghc-pkg list
10:12:45 <dmhouse> guenni: ghc-pkg list
10:12:49 <dons> hey chrisdone
10:12:54 <chrisdone> hey dons :)
10:13:21 <guenni> thx
10:13:44 <guenni> has anybody install gtk2hs on Windows?
10:13:44 <chrisdone> dons: what's happening?
10:13:54 <Quadrescence> What is the proper term for using disk space when RAM is insufficient?
10:14:01 <tromp> virtual ram
10:14:13 <tromp> virtual memory
10:14:23 <dons> hmm. taking over the world, as usual!
10:14:29 <dcoutts_> guenni: yep
10:14:40 <chrisdone> taking over the world, /obviously/
10:14:47 <RayNbow> Quadrescence: swap file?
10:14:53 <chrisdone> :p
10:15:00 <Quadrescence> RayNbow: Perhaps. :>
10:15:48 <guenni> dcoutts_: how come it doesn't install the package sourceview?
10:16:46 <dcoutts_> guenni: pgavin said there were some problems so he didn't include it. He'll look into it for the next release.
10:17:06 <dcoutts_> guenni: you want it for lesaka or something right?
10:17:07 <chrisdone> I am at the moment working on a little web site which makes playlists out of internet videos from places like youtube, dailymotion, and X where X is any that allow you to be told when a video is ended so that another video can start after it. I'm thinking a SICP playlist, some Tool videos, what Haskell videos I know of, etc. will make good playlists that will be useful to me ._.
10:17:18 <guenni> dcoutts_: is there a way to install that manualy?
10:17:33 <dons> chrisdone: there's a bunch of haskell videos linked from haskell.org, btw.
10:17:38 <dons> all the ones i know of.
10:17:44 <guenni> dcoutts_: cause I need it for leksah
10:17:53 <dcoutts_> guenni: you'd have to build from source, which is perfectly possible on windows, just a bit tiresome
10:18:00 <chrisdone> dons: can they be played with flash? google video, that kind of thing?
10:18:15 <chrisdone> dons: if not I might upload them to YouTube.. hang on I'll look myself
10:18:26 <guenni> dcoutts_: ok, I'll try that then
10:18:31 <Quadrescence> A tree is a type of graph, right?
10:18:44 <dons> chrisdone: a mixture, i guess. click on the Videos link on haskell.org
10:19:27 <hackage> Uploaded to hackage: data-accessor-template 0.1.2
10:19:27 <hackage> Uploaded to hackage: midi 0.0.6
10:19:27 <hackage> Uploaded to hackage: data-accessor 0.1.2
10:19:28 <hackage> Uploaded to hackage: logfloat 0.8.2
10:19:30 <hackage> Uploaded to hackage: kbq-gu 0.2
10:20:57 <chrisdone> dons: niice, lots of quality videos there
10:22:17 <rwbarton> Quadrescence: Yes, although very often when people say "tree" they mean a tree with some additional structure, such as the choice of a root vertex
10:22:26 <Quadrescence> Right.
10:22:29 <quicksilver> Quadrescence: a tree is an acyclic graph, often with a choice of root/direction.
10:23:10 <Quadrescence> hrm, is there a way to automatically update all packages?
10:23:24 <chrisdone> cabal update, cabal upgrade
10:23:57 <dcoutts_> and if someone helps then it'll be possible to do that across ghc upgrades! :-)
10:24:03 * dcoutts_ looks about for volunteers
10:24:23 * quicksilver holds up a mirror carefully
10:24:34 <Quadrescence> Okay, so cabal upgrade does not require one to write a specific package to upgrade?
10:24:47 <dcoutts_> quicksilver: not pointing at me I hope ;-)
10:24:49 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/199
10:24:51 <chrisdone> Quadrescence: that's right
10:24:56 <Quadrescence> Okay. :>
10:25:01 <lambdabot> Title: #199 (when installing a new version of GHC, there should be a way to upgrade my  ...
10:25:15 <dcoutts_> Quadrescence: right, it'll try and find a later version of everything you've currently got installed (for the selected compiler)
10:25:16 <Crecerelle> Is there any reason to use apt-get and ilk over cabal-install these days?
10:25:30 <dcoutts_> Crecerelle: apt-get lets you uninstall :-)
10:25:47 <atomb> dcoutts_: something related would be the ability to re-compile all packages depending on foo when upgrading foo
10:25:50 <chrisdone> who would ever want to uninstall anything Haskell-related?
10:25:51 <dcoutts_> Crecerelle: and debian packages have generally been better tested
10:25:53 <quicksilver> apt-get lets you deploy to multiple machines without compiling multiple times.
10:26:03 <quicksilver> (or, indeed, once)
10:26:19 <dcoutts_> atomb: http://hackage.haskell.org/trac/hackage/ticket/131
10:26:21 <lambdabot> Title: #131 (cabal-install should rebuild dependants when a package is upgraded) - Hack ...
10:26:35 <atomb> ah. i figured as much. :)
10:26:40 <Crecerelle> quicksilver: Oh, good point... I guess I'm falling into the 'compile everything yourself' mindset :'
10:26:44 <dcoutts_> atomb: I'm not so sure we should be doing that though
10:27:02 <quicksilver> dcoutts_: well, offering some kind of option might be nice.
10:27:13 <atomb> i've wondered for a while what the implications might be
10:27:22 <atomb> are there problems you know of?
10:27:37 <quicksilver> you can cause a massive explosion in dependency chain and get to the end and find something fails
10:27:57 <quicksilver> having spent 3 hours recompiling 33 packages before the 34th failed
10:28:01 <atomb> ah, yes. that could certainly be an issue. :)
10:28:03 <quicksilver> due to a buggy API change :)
10:28:29 <atomb> it would certainly be possible at that point to back off and leave the original installed
10:28:48 <quicksilver> yes, given that that is possibel the pain is not as bad as it might be.
10:29:01 <chrisdone> chr1s: btw, I sorted that formlets problem. no biggie. making use of "plug" before to add labels to formlets. niiiice ^_^
10:30:35 <dcoutts_> atomb, quicksilver: right, exactly. I mean, so long as we're not re-installing the same version of a package then we're never breaking other existing installed packages. So it's safe to not rebuild the dependents.
10:30:54 <dcoutts_> though it might be a convenience, though as you say it can fail
10:35:51 <janszn> @pl concatMap (\(y, ys) -> map (y:) f ys))
10:35:51 <lambdabot> (line 1, column 38):
10:35:51 <lambdabot> unexpected ")"
10:35:51 <lambdabot> expecting variable, "(", operator or end of input
10:37:09 <janszn> @pl (\(y, ys) -> map (y:) (f ys))
10:37:10 <lambdabot> uncurry ((. f) . map . (:))
10:39:27 <vixey> janszn: What does that do?
10:40:07 <dmhouse> Prepends y to each element of f ys.
10:40:46 <dmhouse> > let f x = [1..x] in (\(y, ys) -> map (y:) (f ys)) (10, 5)
10:40:47 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
10:41:23 <janszn> vixey: part of permutation definition
10:41:43 <vixey> really? I would not write permutation in that way
10:42:07 <janszn> vivxey: playing with H. Thielemanns' Combinatorics module
10:42:27 <vixey> insertions e [] = [[e]] ; insertions e (x:xs) = (e:x:xs) : map (x:) (insertions e xs)
10:42:27 <vixey> permutations [] = [[ ]] ; permutations (x:xs) = insertions x =<< permutations xs
10:42:50 <vixey> that's my version
10:43:22 <janszn> I only try to make expressions tacit
10:44:37 <vixey> @w80 tacit
10:44:38 <lambdabot> *** "tacit" wn "WordNet (r) 2.0"
10:44:39 <lambdabot> tacit
10:44:39 <lambdabot>      adj : indicated by necessary connotation though not expressed
10:44:39 <lambdabot>            directly; "gave silent consent"; "a tacit agreement";
10:44:39 <lambdabot>            "the understood provisos of a custody agreement" [syn:
10:44:40 <lambdabot>            {implied}, {silent}, {understood}]
10:44:54 <janszn> sorry, pointless
10:45:03 <vixey> point free
10:45:06 <tromp> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick []=[]; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
10:45:07 <lambdabot> Defined.
10:45:15 <vixey> that sounds a bit hard
10:45:47 <Quadrescence> tromp: What is that? :O
10:46:03 <tromp> > permute "what"
10:46:05 <lambdabot>  ["what","whta","waht","wath","wtha","wtah","hwat","hwta","hawt","hatw","htwa...
10:46:17 <Quadrescence> I see.
10:46:20 <trofimovich> > permute [1..3]
10:46:22 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
10:46:57 <vixey> permutation = (insert>>=) . select
10:47:10 <dublpaws> is the 'point' in "point free" the same as the 'point' in "join point" from AOP?
10:48:56 <oklopol> > permute [1,2..]
10:49:00 <lambdabot>  Tried to use too much memory
10:49:47 <vixey> can
10:49:47 <vixey> select :: [a] -> [(a,[a])]
10:49:47 <vixey> select "xyz" = [('x',"yz"),('y',"xz"),('z',"xz")]
10:49:52 <vixey> be written as a hylomorphism?
10:50:07 <tromp> that's same as pick
10:53:43 <Twey> chrisdone!
10:53:45 <ski> dublpaws : not sure what "join point" is .. but i'd presume it's not the same `point'
10:53:57 <dublpaws> ok
10:54:21 <Twey> chrisdone: I hold you accountable for the grave sin of using unnecessary and probably unintentional globals!
10:54:26 <Twey> http://chrisdone.com/stuff/javascript-state-monad.js.html
10:54:28 <lambdabot> Title: State monad in Javascript
10:54:52 <ski> (the `point' in `point free' comes from category theory .. and i would be surprised to learn AOP had terms from thereabouts)
10:56:01 <erikc> o we are talking about AOP i got somethin to say about that
10:56:34 <chrisdone> Twey: globals?
10:56:57 <Twey> chrisdone:         tmp = m(s)
10:57:28 <Twey> Without a 'var' keyword to make that a variable, it becomes a property of the global object; i.e. a global variable
10:57:30 <chrisdone> Twey: are variables global by default in Javascript?
10:57:40 <chrisdone> ok
10:57:49 <Twey> Variables aren't, but variables must be declared with the 'var' keyword.
10:57:56 <Quadrescence> Is there a fast way to swap two elements of any kind of list/array-like data structure?
10:58:17 <chrisdone> Twey: I mean, it's optimisation. I meant to do it like that
10:58:38 <Twey> chrisdone: Er, what?  Why?
10:58:49 <chrisdone> Twey: that's a joke v_v
10:58:57 <Twey> Oh
10:59:01 <Twey> Hah, sorry
10:59:08 <Twey> Not at my best :)
10:59:15 <Trinithis> A horrible flaw in JS imo
10:59:56 <bd_> Quadrescence: that would depend on the structure
11:00:07 <chrisdone> Twey: actually, that little bit you just told me might be an explanation for a phenomenom I was experiencing in javascript which was confusing me
11:00:09 <bd_> I doubt there's a general solution
11:00:10 <Trinithis> Quadrescence: You mean on O() notation?
11:00:19 <Trinithis> in*
11:00:26 <Twey> chrisdone: Oh ah?
11:00:37 <Quadrescence> bd_: Yes, so, the best structure for swapping, I guess, then.
11:00:41 <bd_> consider doubly linked list vs singly linked list vs Data.Sequence vs Data.MArray ...
11:00:45 <Quadrescence> Trinithis: I guess so.
11:01:11 <Trinithis> I like using Data.Map. It has O(n log n)
11:01:22 <bd_> Quadrescence: /best/ would depend on the data structure in question, surely :/
11:01:30 <bd_> Trinithis: O(lg n) for replacing a single element
11:01:45 <Trinithis> o
11:01:57 <bd_> O(lg n + lg m) for swapping an element between two trees
11:02:01 <chrisdone> Twey: okay, maybe not. js> {f = function() { return v; }; var v = 1; f();} => 1
11:02:41 <chrisdone> Twey: apparently the fact that the closure is declared before v does not matter
11:03:16 <dmhouse> chrisdone: of course not, it has lexical scoping.
11:03:18 <Twey> chrisdone: An inner function has access to all variables in the outer scope as they are at the time the closure is run, not at the time the closure is defined
11:03:23 * Twey nods.
11:03:50 <chrisdone> Twey: that's what I figured
11:04:11 <bd_> Quadrescence: just as an example, in an array you can just directly go and replace an element. In an immutable list, you'd ideally want to only iterate once to the location in question, however, so you'd want to save off a stack of the elements before the target, and the tail of the list, for each list in question
11:04:45 <bd_> and with data.sequence there might be some clever low level way to avoid actually partitioning the structure
11:05:23 <Trinithis> chrisdone: There is no scoping using {statements}. You need to use (function() {statements})();
11:05:33 <chrisdone> dmhouse: (let ((f (lambda () v))) (let ((v 1)) (f))) => reference to undefined identifier: v
11:05:55 <chrisdone> Trinithis: oh, let me try that
11:06:10 <Quadrescence> bd_: Maybe I should rephrase my question. What's the best data structure to use if I want to swap the values at indicies i and j?
11:06:46 <bd_> Quadrescence: Oh. What are you indexing on?
11:07:05 <chrisdone> Trinithis: (function() { f = function() { return v; }; var v = 1; return f(); })(); => 1
11:07:08 <bd_> Quadrescence: and, does this need to be copyable/immutable?
11:07:47 <Trinithis> chrisdone: What are trying to accomplish?
11:08:20 <dmhouse> chrisdone: which Lisp is that?
11:08:28 <Trinithis> javascript
11:08:42 <chrisdone> Twey: I wonder if there is a speed hit or advantage to javascript's method. a closure is code & environment, but here it seems javascript's closures are just code and then just look in the environment later on
11:08:44 <chrisdone> dmhouse: scheme
11:09:37 <chrisdone> Twey: it seems like there'd be an advantage but on the other hand, wouldn't you want to delay garbage collecting things that you could otherwise delete, incase they are used by closures later on?
11:09:44 <Twey> chrisdone: Uhm, closures in pretty much every language work like that as far as I know
11:09:51 <Twey> You do, yes
11:09:57 <chrisdone> Twey: well, I just demonstrated that it does not in Scheme
11:10:05 <Twey> Oh, really?  Huh
11:10:08 <Twey> Odd
11:10:14 <Twey> So you basically have read-only closures
11:10:15 <Quadrescence> bd_: Well, I am performing several swaps in a recursion, so, I imagine inputting some data structure indexed from 0 to n-1, swapping two elements at i and j, and then 'calling' this function again until some requirement is fulfilled.
11:10:25 <chrisdone> Twey:  hence my confusion with javascript, really
11:10:53 <ski> Twey : "read-only closures" ?
11:10:56 <Twey> Writeable closures are very handy.  But yes, GC is delayed until everything that could access that environment is destroyed.
11:11:16 <Trinithis> Closures in JS can access variables defined later on in the same scope. Is that what is confusing you?
11:11:19 <chrisdone> Twey: well, the variables inside a closure can be modified from the outside at their location
11:11:52 <gwern> ?djinn (P -> Q) -> (Q -> R) -> (P -> R)
11:11:53 <chrisdone> Twey: a variable in Scheme is typically a binding of a name to a location, IIRC. that location is mutable
11:11:53 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
11:12:03 <bd_> Quadrescence: use a STArray perhaps?
11:12:14 <ski> @djinn (p -> q) -> (q -> r) -> (p -> r)
11:12:15 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
11:12:18 <Twey> chrisdone: But the list of accessible names isn't?
11:12:22 <chrisdone> Trinithis: that is what was confusing me, yes
11:12:25 <ski> @botsmack
11:12:25 <lambdabot> :)
11:12:33 <mar77a> @bot
11:12:34 <lambdabot> :)
11:12:36 <mar77a> @botdick
11:12:37 <lambdabot> Unknown command, try @list
11:12:46 <mar77a> @list
11:12:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:13:17 <chrisdone> Twey: I don't think so
11:13:19 <Quadrescence> bd_: I'll take a look.
11:13:50 <gwern> ?djinn (b -> c) -> (a -> b) -> a -> c
11:13:50 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
11:14:00 <bd_> Quadrescence: if you don't mind working in a ST monad it's the fastest route (STUArray if you're using unboxable value types, for even better performance)
11:14:17 <bd_> Quadrescence: It does require a numeric (specifically, an Ix instance) key of course
11:14:31 <Trinithis> chrisdone: Does it help to know that when a variable is defined in a scope, it always exists in that scope, even before it is declared? (It's value is undefined then)
11:14:39 <Quadrescence> bd_: Everything (key/values) is integers.
11:14:52 <bd_> Quadrescence: okay, STUArray with Int and Int then :)
11:15:02 <bd_> you'll get a nice machine-level array
11:15:02 <Quadrescence> (if you'd want to call them key/values)
11:15:03 <Quadrescence> :P
11:15:04 <ski> Twey : (let ((v 0)) (let ((f (lambda () v))) (let ((a (f))) (set! v 1) (list a (f))))) ;=> (0 1)
11:15:31 <bd_> Quadrescence: well, if you wanted strings as keys or something I'd probably have suggested Data.Map or something.
11:15:35 <Twey> Yeah, ski, it was explained :-P
11:15:44 <Quadrescence> bd_: Ah
11:15:48 <chrisdone> Twey: here's an example of what I was thinking about. (let ((a <something>) (b <something-else>)) (let ((f (lambda () a))) (f))) -- here we see that `f' has bound the 'a' variable only. when we call `f', `b' is not bound. so here I think one could garbage collect `b' before `f' is even ran. in Javascript, I think you'd need to keep it all there just in case. do you think?
11:16:04 <Twey> chrisdone: Yes
11:16:10 <Twey> That's correct
11:16:10 <bd_> or Data.Map holding STVar s if you can cache them somehow
11:16:57 <chrisdone> Twey: perhaps it was determined that looking up bindings is more expensive than keeping them around and looking them up when needed
11:17:12 <Twey> Perhaps it wasn't a conscious design decision
11:17:17 <Trinithis> I think JS needs to keep track of "unusable" variables because of features like eval()
11:17:18 <Twey> You give JS too much credit :)
11:17:22 <Quadrescence> bd_: This is for permuting a list of integers [0..n-1] (ignore the fact that I said 'list')
11:17:22 <chrisdone> :P
11:17:48 <bd_> Quadrescence: 'set' then :) but yes, STUArray is easy and fast as long as that ST part isn't a problem.
11:18:03 <bd_> (IOUArray is the same thing if that's more convenient for some reason)
11:18:06 <chrisdone> Trinithis: isn't any piece of code `eval(<foo>);' equivalent to <foo> in the same place?
11:18:24 <Trinithis> yes
11:18:37 <Trinithis> well... eval("<foo>")
11:18:42 <chrisdone> Trinithis: why is eval relevant?
11:19:12 <Trinithis> If you make a closure that looks like it doesnt use a variable x, it might stilll use it through an eval construct
11:19:18 <Quadrescence> bd_: So, can you link me to some documentation on STUArray?
11:19:36 <bd_> http://www.haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-Array-ST.html
11:19:38 <lambdabot> Title: Data.Array.ST, http://tinyurl.com/652c3q
11:19:47 <bd_> just use MArray's functions to manipulate it
11:19:52 <bd_> http://www.haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-Array-MArray.html
11:19:53 <lambdabot> Title: Data.Array.MArray, http://tinyurl.com/6buge9
11:19:59 <Quadrescence> Yeah, I see now. :>
11:20:21 <chrisdone> Trinithis: I don't understand. do you have an example? are you aware that scheme has an `eval' procedure?
11:20:28 <bd_> Quadrescence: if you want to produce it as the final result, also look at runSTUArray, which will freeze it into an immutable array at the end without copying
11:20:46 <Quadrescence> bd_: ooOOooh. :)
11:20:46 <Trinithis> Um... let me cook an example. Perhaps I'm misuderstanding your questions
11:20:56 <vixey> w80 vector
11:21:02 <vixey> @w80 vector
11:21:04 <lambdabot> *** "vector" wn "WordNet (r) 2.0"
11:21:04 <lambdabot> vector
11:21:04 <lambdabot>      n 1: a variable quantity that can be resolved into components
11:21:04 <lambdabot>      2: a straight line segment whose length is magnitude and whose
11:21:04 <lambdabot>         orientation in space is direction
11:21:06 <lambdabot> [6 @more lines]
11:21:09 <vixey> @more
11:21:10 <lambdabot>      3: any agent (person or animal or microorganism) that carries
11:21:10 <lambdabot>         and transmits a disease; "mosquitos are vectors of malaria
11:21:12 <lambdabot>         and yellow fever"; "fleas are vectors of the plague";
11:21:14 <lambdabot>         "aphids are transmitters of plant diseases"; "when medical
11:21:16 <lambdabot>         scientists talk about vectors they are usually talking
11:21:17 <bd_> Quadrescence: just remember, *UArrays can't hold undefined, if you were planning on doing that for some reason :)
11:21:18 <lambdabot>         about insects" [syn: {transmitter}]
11:21:19 <chrisdone> sigh
11:21:37 <Quadrescence> bd_: Nope. :>
11:24:52 <Trinithis> chrisdone: http://hpaste.org/9670. Here x cannot be GC'ed because of eval. Because of eval, JS keeps track of all variables in the closure and won't GC a single one of them until the function gets GC'd
11:26:32 <bd_> Trinithis: If you don't actually use eval or x in the inner function, does it still keep a reference to x?
11:26:36 <Quadrescence> bd_: So the general premise is to make a new array, do stuff to it, then "freeze" it when you're done?
11:26:56 <Trinithis> bd_: of course. What if the inner function uses function g() and g == eval?
11:27:08 <bd_> Trinithis: eivl
11:27:10 <bd_> evil*
11:27:37 <bd_> Quadrescence: yep. Basically you have a ST s (STUArray s Int Int)
11:27:49 <bd_> and pass it to runSTUArray, which spits out a UArray Int Int
11:28:18 <bd_> Trinithis: eval really ought to be a special syntactic construct then
11:28:32 <bd_> or, g = eval should freeze the environment at the moment of assignment
11:28:42 <Trinithis> bd_: and then there's the Function constructor too... which is like eval
11:28:48 <ski> (`eval' ought to respect lexical scoping ..)
11:29:01 <bd_> Trinithis: can it capture lexical values? :/
11:29:05 <Trinithis> bd_: what about function(str) {return eval(str)}
11:29:10 <Trinithis> it wouldn't work
11:29:16 <Trinithis> as syntax
11:29:24 <bd_> Trinithis: Sure it would - it'd just use this anonymous function's context
11:29:35 <Trinithis> o
11:30:09 <bd_> basically my suggestion would be to make eval a special 'constant' that returns a JS evaluator with the context taken from the lexical context in which the 'eval' keyword is used
11:30:31 <Quadrescence> bd_: Would you mind typing up a quick example, swapping two elements of an array?
11:30:40 <Trinithis> or better yet, get rid of eval entirely
11:30:41 <bd_> so, f = function (g, str) { x = 42; return g(str) }; f(eval, "print(x)");  wouldn't work
11:31:11 <Quadrescence> lol@(g,str)
11:31:19 <Quadrescence> <_<
11:31:23 * Quadrescence hides.
11:32:31 <chrisdone> Trinithis: http://hpaste.org/9670#a1
11:32:43 <bd_> Quadrescence: mswap :: (Ix i, MArray a e m) => (a i e, i) -> (a i e, i) -> m ();  mswap (a1, k1) (a2, k2) = do { v1 <- readArray a1 k1; v2 <- readArray a2 k2; writeArray a1 k1 v2; writeArray a2 k2 v1 } -- untested
11:33:14 <chrisdone> Trinithis: what behaviour does your javascript paste demonstrate?
11:33:24 <Trinithis> chrisdone: alerts 7
11:33:36 <dons> s
11:33:42 <chrisdone> Trinithis: that is aweful
11:33:52 <chrisdone> Trinithis: a real language would not do this
11:34:08 <Trinithis> or at least I think it does... ill double check :D
11:34:24 <chrisdone> Trinithis: sorry, I misread that
11:34:53 <Trinithis> oh. well for the record it does indeed alert 7
11:35:27 <Trinithis> does the scheme code print 7?
11:36:23 <chrisdone> Trinithis: yep
11:36:36 <bd_> http://hpaste.org/9670#a2 <== /real/ languages indeed don't do that ;)
11:37:07 <Trinithis> is that php?
11:37:12 <Twey> Perl
11:37:14 <Twey> Close :)
11:38:04 * Twey finds it impressive that some Haskellers are capable of using Perl without vomiting :-P
11:38:09 <bd_> Comparing PHP to Perl is an insult. PHP is like a braindead clone of perl by people who liked the syntax but didn't quite 'get' it. And probably started in perl4 or so.
11:38:32 <bd_> Twey: GHC uses perl whenever you build using -fvia-C :)
11:38:43 <Twey> Indeed
11:38:47 <Twey> Very impressive, very impressive
11:38:50 <Trinithis> Does scheme work like this: http://hpaste.org/9670#a3
11:38:51 <Twey> Perl is like the anti-Haskell :)
11:39:45 <chrisdone> Trinithis: no, I see your point here, with the eval it makes it impossible to know what will be needed. maybe such an optimisation doesn't exist. for what it's worth, the scheme code behaves the same because the variables bound in the lexical scope at the time the closure is created are kept in an environment which makes up the closure along with the text
11:40:01 <bd_> Twey: I wrote a monad library in perl once >_>;
11:40:01 <ski> @quote mangler
11:40:02 <lambdabot> Pseudonym says: All hail the Evil Mangler!
11:40:04 <bd_> I wonder if I still have it
11:40:24 <Twey> bd_: And dynamic scoping is not a language feature to boast about :-P
11:40:30 <Twey> (unless it's optional)
11:40:33 <bd_> Twey: dynamic scoping?
11:40:39 <Twey> (and preferably tucked away somewhere)
11:40:51 <bd_> Twey: you misunderstand - perl's eval does /not/ examine local lexical context
11:40:58 <bd_> only globals are in scope
11:41:08 <Trinithis> http://en.wikipedia.org/wiki/Scope_(computer_science)#Static_versus_dynamic_scoping
11:41:10 <lambdabot> Title: Scope (programming) - Wikipedia, the free encyclopedia, http://tinyurl.com/5tpetg
11:41:29 <Twey> Ah, OK, bd_
11:41:42 <bd_> there /is/ a dynamic scope thing; leftover from older versions of perl in which true lexical scoping wasn't available. It is highly, highly discouraged now.
11:41:58 <chrisdone> bd_: in favour of the Reader monad!
11:42:02 <Twey> Perl is still the anti-Haskell.
11:42:18 <vixey> what does that mean
11:42:19 <Trinithis> Is Perl worth learning?
11:42:29 <bd_> chrisdone: the dynamic scoping thing involves saving the old value of a global onto the stack before replacing it, then putting it back when you leave the scope.
11:42:40 <Trinithis> PHP is the anti coder (imo)
11:42:53 <bd_> it's a horrible hack and nowadays is mostly used to twiddle certain global settings (eg, line buffering) temporarily
11:43:11 <noteventime> PHP has one advantage though, it's like a sink for all the really bad programmers
11:43:17 <Trinithis> lol
11:43:17 <chrisdone> bd_: quite similar to using ReaderT then, in that aspect
11:43:38 <chrisdone> bd_: using `local'
11:43:42 <bd_> yeah, I guess so
11:43:53 <bd_> it's still evil, and should be avoided :)
11:43:59 <Trinithis> dynamic scoping?
11:44:10 <bd_> although I think it works on true lexical variables, so you can use it with less-than-a-global, perhaps.
11:44:19 <chrisdone> scheme has dynamic variables thanks to fluid-let v_v
11:44:22 <bd_> Trinithis: perl's 'local' keyword, which does something sorta like that
11:44:40 <crazytown> do I neeed cabal to install cabal packages?
11:44:56 <chrisdone> cabal comes with ghc, you need ghc
11:44:57 <crazytown> runhaskell Setup.hs configure --ghc
11:44:57 <crazytown>  can be done without cabal?
11:45:05 <crazytown> ok ty
11:45:05 <chrisdone> yep
11:45:21 <bd_> crazytown: GHC comes with enough of cabal to do that, so you don't need to go out of your way to install cabal
11:45:40 <Trinithis> well i gtg
11:45:46 <chrisdone> bye
11:46:23 <crazytown> about cygwin: I am about to select packages, it has two rows to fill in B and S
11:46:30 <crazytown> what are they and should I click both?
11:46:35 <chrisdone> Twey: and all this because you were so cheeky to be browsing my web site :P
11:46:46 <bd_> crazytown: binaries/source
11:46:58 <bd_> if you need source, you'd know it
11:46:59 <crazytown> I should choose one of them or both?
11:47:03 <bd_> so just choose binaries
11:47:07 <crazytown> k i choose B then
11:48:31 <Dwaylu> I'm a PHP scripter and I want to get into a real programming language, I was thinking the route I would take would be Java -> C++ -> Assembly, is this a wise choice?
11:48:37 <DRMacIver> I don't quite understand how Jon Harrop manages to not be banned from the mailing list.
11:48:55 <chrisdone> do not feed the troll
11:48:59 <crazytown> lol Jon Harrop is quite the troll it seems and I have onyl encountered him alittle
11:49:10 <sw17ch> is he trolling again?
11:49:14 <DRMacIver> crazytown: I don't. Actually I'm hardly activeo n the mailing lists at all. :)
11:49:17 <sw17ch> i saw some yesterday, but not today
11:49:18 <ski> Dwaylu : why not learn Haskell as the first ?
11:49:19 <DRMacIver> err. chrisdone ^
11:49:32 <DRMacIver> sw17ch: Nah, just looking at yesterday's mail
11:49:40 <ski> (Dwaylu : considering you're asking here ..)
11:49:47 <chrisdone> ski: seems like a troll to me
11:50:02 <ski> might be, might be not
11:50:06 <sw17ch> at the very least, i know one frying (oops, i mean flying) frog i'll never let consult me :)
11:50:31 <Dwaylu> What are the upshots to learning haskell first?
11:51:18 <Dwaylu> (And I just figured it's a group of programmers, might as well... haha)
11:51:46 <noteventime> Somehow I find the idea of an OCaml troll... funny
11:51:53 <tehgeekmeister> reading the docs for quickQuery in hdbc it seems to me that you can do a SELECT * FROM table and hdbc will feed you the results of that lazily, is that right?  it seems to me that hdbc would have to do some magic transforming the query to make that work, which is why i'm confused...
11:51:54 <sw17ch> Dwaylu, i'd start from the bottom. Assembly -> C -> ?
11:51:57 <chrisdone> well, it's a boring question. learn haskell
11:52:10 <SamB> Dwaylu: well, Java is really dry IMO
11:52:13 <sw17ch> at least, i wish i had
11:52:24 <sw17ch> java is hard to say anything with...
11:52:33 <Dwaylu> Yeah, but easier to learn. I don't expect to use it commercially
11:52:37 <SamB> that is to say, boring
11:52:51 <noteventime> Java is extremely boring :|
11:52:53 <SamB> I'll never understand you people who find it easy to do boring things
11:52:55 <sw17ch> Dwaylu, C is really easy
11:53:00 <ski> Dwaylu : well, learning Haskell first will probably make you more conscious in possibly later imperative programming of when you use side-effects .. when those are serious and when they are not
11:53:02 <sw17ch> it just gets hard depending on the problem :)
11:53:04 <Twey> Assembly is even easier
11:53:06 <noteventime> sw17ch: C++ is hard though
11:53:09 <sw17ch> Assembly is *REALLY* easy
11:53:22 <SamB> assembly gets boring too
11:53:26 <sw17ch> noteventime, quite.
11:53:28 <SamB> and to be a chore
11:53:36 <sw17ch> noteventime, actually, i'll rephrase it to annoying
11:53:37 <Dwaylu> it seems like a lot of memorization
11:53:41 <vixey> assemby is easy ...?!
11:53:43 <SamB> (if you try to use it for an entire program)
11:53:49 <noteventime> sw17ch: Well, that too
11:54:07 <noteventime> But understanding all the template stuff, what you can and can't do with different things
11:54:15 <sw17ch> vixey, yes... it's not easy to do big things with... but it's hard to not understand what's going on in a small scale
11:54:15 <noteventime> It's totally inconsistent
11:54:16 <SamB> it's good to KNOW, but not a good way to write a program much more complicated than true(1) or false(1)
11:54:19 <tromp> assembly is really easy except when it results from compiling a complex language:(
11:54:22 <vixey> How do you write something like a compiler that outputs assembly?
11:54:49 <noteventime> Am I the only one who thinks Scheme should be the first language?
11:54:56 <Dwaylu> I've heard that before
11:54:56 <SamB> noteventime: all the implicit stuff is the worst part
11:54:59 <vixey> noteventime: I don't think there should be a first language
11:55:15 <Twey> ...
11:55:19 <Twey> ... what?  o.@
11:55:21 <noteventime> vixey: Well, unless you're talking about quantum states...
11:55:39 <Twey> Perhaps vixey thinks that nobody should program.
11:55:48 <noteventime> Anyway, I'm off to eating
11:55:50 <Twey> I agree with you, noteventime
11:55:53 <Twey> Aye.
11:56:12 <chrisdone> Twey: you think scheme should be the first language?
11:56:12 <noteventime> Just because it's so simple
11:56:23 * Twey nods.
11:56:30 <chrisdone> Twey: you don't know scheme, it's so complex! the closures are all wrong
11:56:30 <Twey> It shows how programming languages *work*
11:56:35 <Twey> Yes, yes
11:56:55 <Twey> But the basic principles of a Lisp are at a much lower level than those of other languages
11:57:01 <Twey> You're basically writing a parse tree
11:57:02 <erikc> if i had to design a curriculum, it would be Assembly -> C -> Lambda Calculus -> Haskell, with an emphasis on understanding how to implement each one in terms of the previous one
11:57:11 <erikc> you can hit up scheme in between C and Haskell i suppose
11:57:17 <vixey> erikc: cool :D
11:57:21 <Twey> Lambda calculus in C?
11:57:23 <Twey> Untyped?
11:57:26 <vixey> that would be a lot of fun
11:57:51 <stepcut> if i had to design a curriculum it would be Agda -> Unlambda -> MIXX++ -> pre-algebra
11:57:52 <chrisdone> haskell in lambda calculus
11:58:30 <erikc> twey: you could do typed and untyped
11:58:34 <crazytown> I installed cygwin then darcs then wget because darcs complaind it didnt have wget or curl, now I can do wget from cygwin but still not from darcs
11:58:44 <crazytown> I somehow have to link darcs to cygwin?
11:58:47 <sw17ch> i think exposure to something like scheme makes you appreciate haskell a little more
11:58:48 <vixey> lol
11:58:56 <sw17ch> also exposure to other languages, like C or assembly
11:59:03 <crazytown> coming from imperative straight to haskell is a big step
11:59:03 <erikc> i just hate magic :), when ppl say like 'then the debugger does it magic', i get upset
11:59:09 * vixey would teach logo prolog and java
11:59:10 <crazytown> scheme is a lto easier to learn
11:59:18 <sw17ch> especially when Haskell has such a close relation to machine code
11:59:24 * Twey laughs.
11:59:26 <chrisdone> vixey: why java?
12:00:09 <stepcut> how about, Boolean Logic -> Chip Design -> Forth -> Untyped Lambda Calculus -> Scheme -> Typed Calculus -> Haskell -> RTOS
12:00:12 <erikc> crazytown: i do like scheme as a vehicle to teach how closures and continuations can be implemented
12:00:24 <vixey> what's RTOS?
12:00:32 <stepcut> realtime operating system
12:00:54 <ski> stepcut : `pre-algebra' ?
12:00:56 <stepcut> perhaps with some micro-kernel and capabilities mixed in
12:01:04 <erikc> i'd append -> Prolog to my list, after Haskell, thx for reminding vixey
12:01:09 <stepcut> ski: yeah, that class that comes before algebra I
12:01:09 <chrisdone> I think vixey has me on /ignore
12:01:33 <ski> stepcut : sorry, i meant to ask : what is `pre-algebra' ?
12:01:50 <ski> (stepcut : some kind of relaxation / specialization of universal algebra ?)
12:02:52 <sw17ch> The way i learned: HTML -> visual basic 6 -> PHP -> JavaScript (basics) -> C++ -> Perl -> C -> Ruby -> JavaScipt (slightly less than basics) -> SPARC Assembly -> Ruby -> C (more hard core) -> Lisp/Scheme -> C (true understanding) -> Haskell
12:02:58 <sw17ch> over the course of a decade
12:03:10 <chrisdone> damn, I was just about to answer tehgeekmeister
12:03:18 <stepcut> ski: no. It's the class that comes before algebra. http://library.thinkquest.org/20991/prealg/index.html
12:03:19 <lambdabot> Title: Pre-Algebra - Math for Morons Like Us
12:03:40 <Twey> Uh
12:03:41 <sw17ch> and after haskell, advanced javascript
12:03:43 <Twey> Basic arithmetic?
12:04:17 <stepcut> Twey: basic arithmetic plus some simple variables
12:04:23 <stepcut> Twey: basic laws like, a + 0 = a
12:04:38 <Twey> Algebra, n.: A system for computation using letters or other symbols to represent numbers, with rules for manipulating these symbols.
12:04:47 <Twey> On this site I see:         a + (b + c) = (a + b) + c
12:04:53 <Twey> That looks like algebra to me :)
12:05:22 <Twey> Perhaps 'introduction to algebra' would be a better title?
12:05:23 <erikc> i dont really know where to fit prolog / datalog / relational algebra / date's D into that, maybe that has to be a separate branch of learning on data modeling
12:05:25 <stepcut> Twey: right. Pre-algebra is really basic algebra
12:05:34 <ski> possibly it is algebra without clear mention what algebraic structure one's working in ?
12:05:43 <Twey> So it's not *pre*-algebra at all
12:05:48 <Twey> Because it is algebra
12:05:50 <stepcut> Twey: not everyone takes pre-algebra I think. Some people go straight to algrebra depending on their math aptitude
12:06:09 <Twey> It appears to be a misnomer
12:06:13 <stepcut> Twey: because calling it, algebra for stupid kids who need an extra year of preparation did not go over well
12:06:21 * Twey laughs.
12:06:26 <ski> Twey : how about `pre-monoidal functors' ?
12:06:35 * Twey laughs.
12:07:08 <stepcut> Twey: pre-algrebra is 2 weeks worth of algrebra instruction stretched out over a year I think
12:08:31 <stepcut> I think they already had Algebra I, Algrebra II, and then they needed to add a class before Algrabra I, but since Roman Numerals do not have a zero, they opted for pre-Algebra ?
12:09:00 * Twey laughs.
12:09:06 <Twey> It's due to a system design bug, nice
12:09:17 <chrisdone> a + 0 = a, and- woah, hang about
12:11:17 <stepcut> introduction to algebra was probably to long to fit on the report card
12:12:01 <chrisdone> sql is making my code ugly. I have nested case expressions
12:12:43 <stepcut> chrisdone: that's why I switched to HAppS ;)
12:12:53 <chrisdone> look how ugly this is: http://hpaste.org/9671
12:13:34 <Twey> Oh yuck, chrisdone :-\
12:13:39 <stepcut> chrisdone: I bet you could make it even uglier with haskelldb ;)
12:14:55 <chrisdone> =]
12:27:08 <Quadrescence> Ugh, 5 hours reading/hacking, and nothing is done.
12:28:56 <chrisdone> Quadrescence: D:
12:29:11 <Quadrescence> Frustrated Quadrescence is frustrated.
12:29:22 <Pudding> http://hpaste.org/9672?lines=true      <-----How should I interpret the line I marked?
12:30:21 <sjanssen> "| y == x =" means take this branch when y equals x
12:30:45 <Pudding> it's mainly about the 'let ....... in ...'
12:30:50 <sjanssen> "let (f,r) = parseList ys" binds (f, r) to the first and second parts of the result of "parseList ys"
12:31:17 <Pudding> and then uses them in the in-part
12:31:27 <sjanssen> "in (y:f,r)" and finally results in (y:f, r)
12:31:39 <crazytown> can I read a file in cygwin?
12:31:52 <crazytown> read index.html doesn't work(yes the file is there9
12:31:58 <sjanssen> basically "let <bindings> in <result that may use these bindings>"
12:32:09 <trofimovich> cat <file> ?
12:32:35 <Pudding> ok, thank you janssen
12:32:38 <Pudding> sjanssen
12:32:46 <vixey> <bindings> ::= | <pattern> = <expression>
12:32:51 <vixey> oops
12:32:56 <vixey> <bindings> ::= | <pattern> = <expression> ; <bindings>
12:35:14 <chrisdone> heh, I'm still here. modem went off. good ole' irc
12:37:36 <crazytown> thanls trofi, how can I read it line by line?
12:38:15 <crazytown> and can I fetch files form the internet via the nomrla windows command prompt
12:38:17 <crazytown> ?
12:40:51 <chrisdone> slightly better.. http://hpaste.org/9671#a1
12:42:45 <trofimovich> crazytown: why won't you read files from normal wondows environment? all directories are exported normally (except, maybe, /dev)
12:43:40 <trofimovich> crazytown: `normal command prompt' - is cmd.exe or cygwin's shell?
12:44:05 <marcot> I never thought I'd ever use return $ do ...
12:44:31 <ski> marcot : what are you staging ?
12:44:53 <marcot> ski: change between monads.
12:45:12 <vixey> oh
12:45:37 <vixey> can you write an interpreter nad transform it into a compiler by changing the monad?
12:47:18 <trofimovich> what tool was used for generation this page: http://haskell.org/haddock/doc/html/introduction.html haddock itself?
12:47:19 <lambdabot> Title: Chapter1.Introduction
12:49:53 <emma> It has been said that 'one chooses a language based on what one is trying to do'. What sort of projects/applications is haskell best suited for?
12:51:38 <Pegazus> emma: i'd say that one chooses a language based on the way he thinks about a solution for a problem...
12:52:11 <bos> hmm.
12:52:40 <vixey> It's good for writing interpreters and compilers in ...
12:53:49 <Pegazus> i think it's really good/fast to develope an algorithm for one use only really fast...
12:57:13 <dons> emma: hmm. things for which we have libraries and language features well matched to.
12:58:01 <dons> re. language features: symbolic manipulation (i.e. compilers, transformation tools), purity+type system (high assurance/verified software), concise langauge (so rapid development/scripting).
12:58:23 <dons> it's hard to pin point specific areas where it is unsuitable, other than domains where there are key libraries that aren't available.
12:58:57 <dons> emma: if you look at hackage.haskell.org, or the haskell.org industry page, you'll get some idea of what people are finding haskell suitable for.
12:59:29 <emma> http://haskage.haskell.org
12:59:43 <dons> hackage.haskell.org
12:59:50 <dons> that's the library database.
12:59:53 <emma> okay
12:59:59 <dons> which gives you an idea of what people are developing.
13:00:03 <emma> http://hackage.haskell.org
13:00:04 <lambdabot> Title: HackageDB: introduction
13:00:25 <dons> the industry page, http://haskell.org/haskellwiki/Haskell_in_industry has some overview of industrial use.
13:00:26 <lambdabot> Title: Haskell in industry - HaskellWiki
13:00:47 <dons> a fair few banks, defense, some web systems, one biotech firm.
13:00:54 <dons> ketil: btw, did you know about Amgen?
13:01:32 <dons> ketil: http://cufp.galois.com/2008/abstracts.html#BalabanDavid
13:01:33 <lambdabot> Title: Commercial Users of Functional Programming 2008 Program
13:01:43 <dons> ketil: i think might be relevant to your interests :)
13:02:24 <dons> emma: in what areas are you interested in using haskell?
13:03:19 <emma> Copyright(c) Roman Leshchinskiy 2008
13:03:26 <emma> Haskell is not open source?
13:03:55 <Heffalump> most things are BSD3 licensed
13:03:56 <dons> it's an open language, with open source libraries.
13:03:58 <sjanssen> emma: open source software is almost always copyrighted
13:04:14 <Pegazus> seems to be some use in financial systems...
13:04:39 <noecksit> hello, i noticed something in gtk2hs-0.9.13, it is an assertion error that pops up that wasn't there in 0.9.12
13:05:44 <noecksit> im not sure if its supposed to be a bug, it was popping up in my app, and then when I ran ListTest.hs, it also gave the assertion error
13:07:03 <emma> sjanssen: what does it mean that it is copyrighted then?
13:07:37 <rwbarton> emma: It means Microsoft can't steal the code and use it in Windows. :)
13:07:44 <sioraiocht> emma: It means you cannot attribute it to yourself, and that when you use it and distribute it you agree to licence under which it is provided
13:07:54 <sioraiocht> rwbarton: there are copyright licences that DO allow that
13:07:55 <sioraiocht> BSD
13:08:19 <SamB> MS actually can steal GHC and use it in Windows if they want
13:08:29 <rwbarton> emma: For example, GPL code comes with a license that roughly says "you can copy and modify this code, but you must then make your modifications available"
13:08:31 <SamB> but if they do they lose all support
13:08:35 <vixey> I hope they do!
13:08:42 <SamB> also they have to replace GMP
13:08:59 <SamB> (we clearly won't support people using private forks ;-)
13:09:00 <vixey> didn't MS like
13:09:00 <rwbarton> sioraiocht: Right.  IANAL, but as I understand it, really, the copyright notice means nothing, everything is implicitly copyrighted.
13:09:04 <vixey> write half of it anyway though
13:09:18 <vixey> hi grahamhutton :)
13:09:22 <SamB> well, Simon is not the same as MS you know
13:09:24 <grahamhutton> hi!
13:09:26 <sjanssen> emma: copyright means to claim ownership, and gives the owner to dictate the terms on how it is distributed
13:09:26 <Heffalump> hi grahamhutton
13:09:29 <rwbarton> emma: but open source is not the same as public domain--the author puts some restrictions on redistribution
13:09:31 <vixey> how is it going?
13:09:34 <sioraiocht> rwbarton: everything is copyrighted, but you as the copyright holder dictate the licence under which others can use it
13:09:38 <sjanssen> emma: (gives the owner the rights)
13:10:00 <grahamhutton> hi ganesh!
13:10:11 <rwbarton> Right, I think we're all violently agreeing here, so I'll be quiet
13:10:22 <sioraiocht> you can enver, as it were, transfer ownership of a copyright to someone else, but you can grant licences to use a copyrighted work.  the licences can be subject to certain conditions e.g. GPL, MIT, BSD, licences
13:10:33 <sioraiocht> or your own licence
13:10:40 <sioraiocht> the same principle applies in the publishing world
13:10:52 <emma> but if something is open source and it's an algorithm, then once someone sees it and understands it, they could make it for themselves, and then it is not copyrighted?
13:11:02 <Heffalump> correct
13:11:09 <Heffalump> copyright is just about the expression of an idea
13:11:13 <gwern> emma: wrong. software patents get in the way
13:11:16 <Heffalump> open source people tend not to patent things
13:11:20 <gwern> that is why software patents are evil
13:11:39 <rwbarton> emma is technically correct that copyright law is not the issue though
13:11:39 <emma> how can someone copyright a binary search?
13:11:45 <emma> Isn't that like copyrighting multiplication?
13:12:14 <lament> emma: so?
13:12:17 <sjanssen> emma: you can only copyright a work, not an idea
13:12:20 <lament> multiplication is just public domain because it's so old
13:12:56 <osfameron> patents offices tend not to copyright algorithms
13:12:56 <emma> yeah so i don't get how you can have open source copyrighted library.
13:13:14 <osfameron> (except as they apply to computers, hey ho)
13:13:23 <osfameron> but maths algorithms I think are basically unpatentable
13:13:37 <rwbarton> Patent offices tend not to copyright anything. :)
13:13:44 <sjanssen> emma: I don't think you understand what copyright means
13:13:52 <glguy> emma: the library is copyright by virtue of someone writing it. Until they grant you license to use it you can't, it is theres.
13:14:17 <glguy> emma: if they give you a copy under a license, that license explains what rights they are granting you
13:14:20 <emma> if it's a library you can't use, what good is it?
13:14:27 <Heero> osfameron, nope
13:14:41 <glguy> and what conditions you can use their library under
13:14:48 <emma> but if you can see the source, then you could just figure out how it works and make it for yourself with no copyright.
13:15:01 <Heero> do you mean patent or copyright
13:15:06 <sjanssen> emma: it generally isn't quite that easy
13:15:19 <Heero> ie: ffmpeg is open source but the algorithms contained are patented
13:15:43 <Heffalump> emma: sure, but that'd be a lot of effort
13:15:45 <Heero> I can download the source, but as soon as I compile and distribute in US I'm violating the AVC patent
13:15:48 <Heffalump> software is pretty big
13:15:53 <sjanssen> emma: imagine how much source code is in Firefox -- far too much to just "make it for yourself"
13:15:57 * Trinithis says, "It's not breaking the law unless you get caught."
13:16:17 <emma> who owns the source code in firefox?
13:16:31 <therp> mozilla foundation?
13:16:40 <rwbarton> about: says "Copyright  1998-2008 by contributors to the Mozilla Project."
13:16:42 <stepcut> emma: the people that wrote it, unless they assigned the copyright to mozilla foundation
13:17:41 <emma> so if someone uses this code without your permission what is going to happen?
13:17:44 <emma> a lawsuit?
13:17:54 <sjanssen> emma: this is where the license comes into play
13:17:57 <mmorrow> glguy: you wrote hpaste2, correct?
13:17:59 <Heffalump> in principle, yes
13:18:06 <Heffalump> in practice things rarely get that fafr
13:18:08 <sw17ch> emma: http://jmri.sourceforge.net/k/
13:18:09 <glguy> mmorrow: yeah
13:18:10 <Heffalump> s/fafr/far/
13:18:14 <lambdabot> Title: JMRI Defense: Keeping an Open-Source Project Alive
13:18:20 <stepcut> glguy: hpaste2 does not use HAppS anymore ?
13:18:24 <glguy> right
13:18:30 <stepcut> any reason why ?
13:18:35 <emma> Has this ever been challenged?
13:18:36 <rwbarton> emma: Yes, it has happened. http://www.groklaw.net/article.php?story=20071217142920618
13:18:38 <sjanssen> emma: the copyright holder can put a license on the work, dictating the terms of use and distribution
13:18:41 <lambdabot> Title: Groklaw - BusyBox and Xterasys Settle GPL Lawsuit
13:18:43 <mmorrow> glguy: cool. love it! http://www.moonpatio.com:8080
13:18:43 <sw17ch> emma: check the link i just sent
13:18:53 <sw17ch> and related stuff on lessigblog.com and arstechnica.com
13:19:07 <mmorrow> hpaste2 of t3h intarweb: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/
13:19:08 <sw17ch> JMRI copyright and artistic license dispute
13:19:15 <mmorrow> s/of/on/
13:19:21 <sjanssen> emma: for example, the BSD3 license allows free re-distribution and modification as long as the copyright notice is kept
13:20:15 <sw17ch> emma: http://lessig.org/blog/2008/08/huge_and_important_news_free_l.html
13:20:21 <lambdabot> Title: huge and important news: free licenses upheld (Lessig Blog), http://tinyurl.com/6lt6fp
13:20:33 <sw17ch> emma: http://arstechnica.com/news.ars/post/20080813-court-violating-copyleft-copyright-infringement.html
13:20:43 <lambdabot> Title: Court: violating copyleft = copyright infringement, http://tinyurl.com/592wac
13:21:18 <sw17ch> The US Federal courts decided that open source and artistic licenses were valid and upheld the creator's copyright just two days ago. Exciting times!
13:21:24 <glguy> mmorrow: glad to see it getting some use!
13:21:41 <stepcut> glguy: any particular reasons why hpaste2 is not HAppS based ?
13:21:58 <glguy> stepcut: HAppS went in a different direction than I wanted to go
13:22:16 <glguy> with its request dispatch stuff and in-memory state
13:22:19 <glguy> template haskell
13:22:20 <bd_> sw17ch: well, in this case, it's exciting because the lower court made a /very/ bad decision, thanks to ambiguous terms in the artistic licence, and the federal court went and fixed it :)
13:22:26 <glguy> I didn't want to use that stuff
13:22:27 <stepcut> glguy: ok. So, just aesthetic choices mosly?
13:22:32 <sw17ch> bd_: very true
13:22:39 <stepcut> glguy: has HAppS been reliable for you ?
13:22:56 <glguy> stepcut: shapr has actually been running hpaste.org
13:22:58 <bd_> if it was just '$low_court upholds licence' it would be boring news indeed. (although most such cases end in settlement)
13:23:02 <glguy> I don't know if he has to restart much
13:23:09 <stepcut> glguy: ok, I'll ask him
13:23:14 <mmorrow> glguy: i've been using it locally on my laptop for a few months now. use it to take quick notes, save snippets for later, + other random misc. very handy.
13:23:28 <glguy> mmorrow: did you find it hard to get setup?
13:23:47 <stepcut> glguy: I have a few 'long' running HAppS applications, but long is only a few weeks, and the load is pretty light so...
13:24:02 <stepcut> glguy: anyway, thanks for the info.
13:25:25 <mmorrow> glguy: the first time i got it setup, i had some trouble building takusen, but that seems to be fixed. oh yeah, i had to change python2.5 in all the *.{h,c} and the cabal file to python2.3 cuz i didn't wanna upgrade python
13:26:29 <mmorrow> and had to install pygments ... but other than those minor details, setup was pretty smooth
13:29:41 <mmorrow> glguy: the line highlighting is *sweet*
13:29:52 <crazytown> What is the opinion of Clojure in the Haskell community?
13:30:05 <crazytown> What do you think of the conncurrency and multicore model?
13:30:09 <Heffalump> I've barely heard of it.
13:30:18 <noecksit> would anyone on here be willing to try out ListTest.hs from the demo section of gtk2hs using gtk2hs-0.9.13? maybe its just my setup but i always get an exception
13:30:26 <SamB> multicore and concurrency seem to be the future
13:30:58 <noecksit> *or assertion failure
13:31:08 <Trinithis> noecksit: link?
13:31:25 <SamB> sequential programming languages are clearly not adequate in order to utilze multicore well
13:31:41 <SamB> ... and I still can't spell
13:31:53 <noecksit> Trinithis: http://code.haskell.org/gtk2hs/demo/treeList/ListTest.hs
13:32:28 <mmorrow> glguy: that reminds me of a "bug", so when you paste a fairly long (wrt lines) chunk of text, the line numbers begin to become unaligned with the actual lines the further down the paste you go. so you have to close in on the actual line number while trying to highlight a line by guessing the correct lineno, then counting lines from the one that got highlighted to the one you want
13:32:44 <SamB> the question is: can Haskell break free from the von neuman model? will I ever learn to spell that guys name?
13:33:09 <lelf> ?faq
13:33:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:33:21 <sw17ch> @quote
13:33:21 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
13:33:22 <lambdabot> arithmetic in Roman numerals.
13:33:42 <Trinithis> noecksit: I get an error.
13:33:44 <rwbarton> ?faq Can Haskell teach SamB how to spell von Neumann?
13:33:44 <lambdabot> The answer is: Yes! Haskell can do that.
13:33:55 <Trinithis> oh
13:33:58 <Trinithis> I know what the error is
13:34:04 <rwbarton> SamB: maybe that will help :)
13:34:08 <Trinithis> you need the ListTest.glade file
13:34:15 <SamB> mmorrow: that reminds me of what happened when I printed out some of a blog
13:34:27 <noecksit> Trinithis: oh yeah, sorry you do need that file i forgot
13:34:57 <noecksit> Trinithis: its in the same dir though
13:35:43 <Trinithis> The gui opens now
13:35:50 <Trinithis> do you still have an issue?
13:36:16 <noecksit> Trinithis: can u try clicking on "Prepend", or "Append" and then check out the cli for errors?
13:37:38 <Trinithis> my console prints some error-looking stuff when I click it
13:37:38 <noecksit> Trinithis: i get assertion failures when I click "Insert", "Prepend" or "Append" buttons, says smthing about iter->stamp == store->stamp failing
13:37:44 <Trinithis> same
13:38:25 <noecksit> Trinithis: ok thanx, i guess its not just me, it wasn't happening in gtk2hs-0.9.12 and now for some reason pops up
13:38:48 <Trinithis> If it helps, I'm on windows right now
13:39:45 <noecksit> well, that means that its not strictly related to linux, not much i can do about it but file bug report
13:52:10 <nathanic> is it possible to suppress printing ouput in ghci when i do something like this?    > filecontents <- readFile "somefile"
13:52:53 <rwbarton> nathanic: :set -fno-print-bind-result   I believe
13:53:05 <nathanic> rwbarton: thanks :-)
14:00:13 <crazytown> are macros needed in Haskell?
14:00:29 <stepcut> crazytown: mostly, no.
14:00:44 <Heffalump> laziness helps a lot there
14:00:45 <ddarius> They are not needed in any language.
14:00:50 <Heffalump> you can make higher-order control structures without macros
14:00:57 <trzkril> hm?
14:01:10 <stepcut> crazytown: due to lazy evaluation, you can implementing things like 'if' with out using macros.
14:01:20 <trofimovich> like #if GHC > 5 ?
14:01:23 <ski> macros could be useful in some circumstances
14:02:04 <crazytown> how is if implemented in C that doesn't have lisp-macros and not lazy eval
14:02:20 <stepcut> crazytown: it's built-in to the compiler
14:02:25 <Zao> crazytown: In-language.
14:03:16 <crazytown> c has preprocessor macros i found out
14:03:21 <stepcut> crazytown: but, in C, you could not implement  if3 (true|false|maybe), with out macros, but you could in haskell.
14:05:12 <agcorona> Hello
14:05:19 <SamB> stepcut: but what would it DO?
14:06:53 <stepcut> case x of Yeah -> yeah ; Nay -> nay ; Maybe -> maybe
14:08:20 <camio> Anyone know of a :: (a -> b) -> (a,a) -> (b,b)?
14:08:37 <crazytown> stepcut: but what would that do? :)
14:08:46 <stepcut> camio: yeah, (***) or (&&&) or something in Control.Arrow i think
14:09:05 <ddarius> :t (***)
14:09:06 <ski> @type join (***)
14:09:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:09:08 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:09:14 <ddarius> @hoogle (a -> b) -> (a,a) -> (b,b)
14:09:15 <lambdabot> A Hoogle error occurred.
14:10:08 <stepcut> crazytown: if3 is pretty boring. But other control operators can be more interesting
14:11:12 <noteventime> camio: You mean a function that applies a function to both values in a touple?
14:11:32 <noteventime> I was asking myself the same thing today
14:11:37 <camio> brb
14:12:33 <stepcut> crazytown: the original question is 'does Haskell have macros'. The answer is not really. Because lazy evaluation and template haskell allow you to do most things that macros do. Also, sometimes people do use CPP (the C pre-processor) with Haskell for the remaining things.
14:12:55 <SamB_XP> stepcut: TH ... not macros ? what?
14:13:00 <noteventime> stepcut: Do you have any examples?
14:13:02 <RayNbow> @pl \f -> f *** f
14:13:03 <lambdabot> join (***)
14:13:10 <RayNbow> > join (***) succ (1,2)
14:13:12 <lambdabot>  (2,3)
14:13:21 <RayNbow> :t join (***)
14:13:22 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:13:37 <noteventime> RayNbow: neat :)
14:13:40 <RayNbow> oh wait
14:13:49 <RayNbow> ski already came up with this
14:13:55 <stepcut> noteventime: examples of useful control operators that use lazy evaluation ?
14:14:15 <noteventime> stepcut: No, examples where the C pre processor is used
14:14:34 <ski> RayNbow : `join (***)' has been mentioned many times in the past, here
14:14:37 <noteventime> Thanks ski btw :)
14:15:13 <stepcut> noteventime: sure, all over the standard libraries. Mostly, #ifdef GHC foo #else bar #endif, stuff
14:15:23 <noteventime> ski: That's pretty clever
14:15:54 <noteventime> stepcut: Ahh, ok. I was just wondering about the limitations of template haskell
14:16:57 <stepcut> noteventime: you could replace some of the #ifdefs with template haskell, but not ones that are used to hide things from haddock, for example.
14:17:16 <SamB_XP> stepcut: not really
14:17:26 <SamB_XP> most of them are e.g. #ifdef __GHC__
14:17:40 <SamB_XP> or whatever that symbol is
14:17:51 <SamB_XP> ... and only GHC supports TH
14:17:53 <SamB_XP> so ...
14:18:06 <stepcut> SamB_XP: right, I meant to say that
14:18:59 <Trinithis> > until (> 7) (+5) 0
14:19:01 <lambdabot>  10
14:19:05 <Trinithis> damn
14:19:20 <Trinithis> Is there an until that would stop at 5 in my example?
14:19:34 <stepcut> SamB_XP: regarding TH not being macros... I am not sure I fully agree with that either :) TH certainly does a lot of what macros are used for, and I can't really say what the distinction would be.
14:20:03 <rwbarton> > last . takeWhile (not . (> 7)) . iterate (+5) $ 0
14:20:05 <lambdabot>  5
14:20:11 <camio> > join (***) (+10) (3, 4)
14:20:13 <lambdabot>  (13,14)
14:20:20 <Trinithis> rwbarton: thx
14:20:36 <rwbarton> oh, I didn't even realize until was in the Prelude
14:20:54 <ski> stepcut : does TH have any provisions for hygiene ?
14:21:25 <SamB_XP> ski: some
14:21:38 <ski> being ?
14:21:39 <stepcut> ski: beats me. I never understand what hygiene was and I don't know TH very well at all.
14:21:54 <stepcut> ski: something about name capture/collisions ?
14:22:21 <SamB_XP> ski: well, it's easy to make a new symbol with TH that can't possibly conflict with symbols from the source code ...
14:22:37 <vixey> that's gensym
14:22:44 <ski> hygiene is about respecting lexical scope, even for macros
14:23:17 <Trinithis> I think TH has hygine
14:23:29 <SamB_XP> well, maybe you can write TH that disrespects scope
14:23:31 <SamB_XP> I dunno
14:23:31 <Trinithis> because you code it using real functions
14:23:50 <SamB_XP> but I'd never bother to do it on purpose myself
14:24:52 <ski> one case of hygiene is the ability for a macro to expand to code with references to module-local, unexported values
14:25:46 <SamB_XP> well of course you can do that...
14:26:15 <SamB_XP> (why, you can even do that if the variables aren't in scope where you wrote the TH OR where you called it, sometimes ;-P)
14:27:34 <stepcut> SamB_XP: yeah, you can easily write TH that generates calls to nonexistant functions if you want
14:28:01 <SamB_XP> stepcut: I meant you can, e.g., use out-of-scope constructors ...
14:28:12 <stepcut> right
14:28:47 <stepcut> the TH in HAppS generates code all the time that requires me to add additional imports to my file
14:30:19 <ski> why would it require you you add additional imports ?
14:30:28 <ski> s/you you/you to/
14:40:58 <crazytown> is join(***) haskell?
14:41:43 <dmhouse> crazytown: join is a function, (***) is an operator, so join (***) is valid Haskell code, yes.
14:41:55 <vixey> :t join (***)
14:41:57 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:42:08 <vixey> > join (***) (+1) (6,8)
14:42:10 <lambdabot>  (7,9)
14:42:33 <Gast_340_> http://www.pennergame.de/change_please/1933371/
14:42:34 <Gast_340_> http://www.pennergame.de/change_please/1933371/
14:42:36 <Gast_340_> http://www.pennergame.de/change_please/1933371/
14:42:38 <Gast_340_> http://www.pennergame.de/change_please/1933371/
14:42:39 <lambdabot> Title: Pennergame
14:42:39 <lambdabot> Title: Pennergame
14:42:39 <lambdabot> Title: Pennergame
14:42:40 <lambdabot> Title: Pennergame
14:44:39 <Botje> Gast_340_ will be happy to know I just sent a mail to abuse@pennergame.de
14:44:48 <RayNbow> Botje: a bit late :p
14:45:00 <Botje> it's more fun if they don't know :)
14:45:12 <RayNbow> :p
14:45:47 * vixey is asking about this on #freenode
14:45:52 <crazytown> *** u defined yourself? i get not in scope
14:46:01 <vixey> crazytown: It's from Control.Arrow
14:46:09 <vixey> crazytown: :m + Control.Arrow  should load it
14:46:37 <ski> oh-oh
14:47:00 --- mode: ChanServ set +o dmhouse
14:47:38 <dmhouse> K-lined, nice.
14:47:50 --- mode: dmhouse set -o dmhouse
14:48:27 <dmhouse> Not seen one of those in a while.
14:48:44 <vixey> yay
15:03:56 <crazytown> and join?
15:04:03 <vixey> :t join
15:04:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:04:09 <vixey> @hoogle join
15:04:09 <lambdabot> A Hoogle error occurred.
15:04:14 <vixey> Control.Monad
15:04:24 <crazytown> join not in scope
15:04:47 <crazytown> control.monad
15:05:20 <crazytown> works, thanks
15:05:29 <mmorrow> join = (id=<<)
15:06:12 <mmorrow> > (id=<<)(,)4
15:06:14 <lambdabot>  (4,4)
15:06:38 <mmorrow> > join(,)4
15:06:40 <lambdabot>  (4,4)
15:07:00 <vixey> :t ((,)>>=id)
15:07:01 <lambdabot> forall b. b -> (b, b)
15:07:14 <vixey> >t ((,)>>=(+1))
15:07:17 <vixey> :t ((,)>>=(+1))
15:07:19 <lambdabot> forall b. (Num (b -> (b, b))) => b -> (b, b)
15:07:19 <tromp> @let sq = join (*)
15:07:20 <lambdabot> Defined.
15:07:30 <tromp> > map sq [0..9]
15:07:32 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
15:07:36 <vixey> > sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq$3
15:07:39 <lambdabot>  8879621669887893073578235439914037513156323741771701306530961961990046076691...
15:07:54 <mmorrow> hehe
15:08:26 <Botje> > length . show .  sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq$3
15:08:28 <lambdabot>  250149
15:08:35 <Botje> that's all. pffrt.
15:08:59 <vixey> @let jp = join (++)
15:09:01 <lambdabot> <local>:3:10:     Ambiguous type variable `m' in the constraint:       `Monoi...
15:09:04 <mmorrow> > (id=<<) (Just Nothing)
15:09:06 <lambdabot>  Nothing
15:09:13 <vixey> @let jp x = join (++) $ x
15:09:14 <lambdabot> Defined.
15:09:23 <mmorrow> > join (Just Nothing)
15:09:23 <vixey> is that the monomorphism restriction?
15:09:25 <lambdabot>  Nothing
15:09:41 <mmorrow> > (id=<<) (return print) "asdfa"
15:09:44 <lambdabot>  Exception: "<IO ()>"
15:09:48 <vixey> > length . jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp . show $ 4
15:09:50 <lambdabot>  131072
15:10:02 <vixey> > length . jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp.jp . show . sq.sq.sq.sq.sq.sq.sq.sq.sq.sq.sq $ 4
15:10:05 <lambdabot>  Tried to use too much memory
15:10:10 <mmorrow> > (id=<<) [[]]
15:10:12 <lambdabot>  []
15:10:18 <ski> > join (.) join (,,) ()  -- doesn't work :)
15:10:19 <lambdabot>      Occurs check: cannot construct the infinite type: a = t -> a
15:10:20 <lambdabot>     Probabl...
15:11:29 <ski> @pl join . join
15:11:29 <lambdabot> join . join
15:11:37 <vixey> :t join . join
15:11:39 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
15:11:47 <vixey> :t join . fmap
15:12:10 <ski> join . join = join (.) join  -- operationally speaking ..
15:12:22 <vixey> :t join (.) join
15:12:38 <vixey> :t fmap . join
15:12:39 <ski> it doesn't work in HM
15:12:39 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> a -> a1) -> f a -> f a1
15:13:00 <ski> @type join (.)
15:13:01 <lambdabot> forall a. (a -> a) -> a -> a
15:19:21 <hackage> Uploaded to hackage: denominate 0.4.2
15:26:01 <stepcut> is there a simple way to show (1.0 :: Double) as 1 but (2.1 :: Double) as 2.1 ?
15:27:03 <ddarius> > let f 1.0 = "1"; f 2.1 = "2.1" in f 1.0
15:27:05 <lambdabot>  "1"
15:27:40 <Pegazus> O_o
15:27:46 <Igloo> One of Numeric.show{E,F,G}Float might be able to do it, I can't remember OTTOMH
15:27:50 <tromp> strip off any ".0" suffix from show result
15:28:09 <stepcut> ddarius: cool! Can you do that for all Double between 0 and 100 ?
15:28:14 <Pegazus> what about (x :: Double) asInteger = x? (i don't remember too much haskell)
15:28:37 <paczesiowa> > let foo x = if ".0" `isSuffixOf` x then take (length x - 2) x else x in (foo $ show 1.0, foo $ show 2.1)
15:28:39 <lambdabot>  ("1","2.1")
15:28:49 <tromp> > last "1.0"
15:28:50 <lambdabot>  '0'
15:29:15 <ddarius> stepcut: With a bit of TH, sure.  GHC probably won't like compiling it though.
15:29:31 <stepcut> heh
15:29:40 <ski> > let f x | x == fromIntegral (truncate x) = show (truncate x) | otherwise = show x in map f [1.0,2.1]
15:29:42 <lambdabot>  ["1","2.1"]
15:30:01 <Pegazus> that's what i meant :)
15:30:08 * stepcut should just finish Data.Decimal and get it accepted into the standard libraries so he doesn't have to fake it for a blog post
15:33:11 <tromp> > let f s = if last s == '0' then init(init s) else s in map (f.show) [1.0,2.1]
15:33:13 <lambdabot>  ["1","2.1"]
15:34:12 <dmhouse> > let f s = if last s == '0' then init(init s) else s in f $ show 10
15:34:14 <lambdabot>  ""
15:34:24 <tromp> oops
15:34:29 <dmhouse> > let f x | x == fromIntegral (truncate x) = show (truncate x) | otherwise = show x in f 10
15:34:31 <lambdabot>  "10"
15:34:33 <tromp> only works for doubles:)
15:35:00 <oklopol> stepcut: what does Data.Decimal do?
15:35:26 <tromp> hmm, how to get last 2 elements of a list?
15:35:26 <stepcut> oklopol: this, http://www.python.org/dev/peps/pep-0327/, but for Haskell
15:35:30 <lambdabot> Title: PEP 327 -- Decimal Data Type
15:35:54 <stepcut> oklopol: IEEE compliant decimal arithmetic
15:36:00 <tromp> drop (length l - 2) l    looks ugly
15:36:03 <stepcut> oklopol: though, not neccesarily fast :)
15:36:26 <stepcut> reverse . drop 2 . reverse
15:36:31 <tromp> and so does reverse . take 2 . reverse
15:37:00 <stepcut> let youInTheRear f = reverse . f . reverse in youInTheRear $ drop 2
15:37:40 <tromp> > let f s = if (take 2 (reverse s)) == "0." then init(init s) else s in f $ show 10
15:37:42 <lambdabot>  "10"
15:37:49 <tromp> > let f s = if (take 2 (reverse s)) == "0." then init(init s) else s in f $ show 1.0
15:37:50 <lambdabot>  "1"
15:38:08 <stepcut> oklopol: http://src.seereason.com/decimal, btw. Unfortunately, rounding is broken, so I can't justify uploading to hackage where unsuspecting people may get wrong answers
15:38:10 <lambdabot> Title: Index of /decimal
15:38:24 <stepcut> but, next week I might have an opportunity to fix it
15:39:23 <tromp> wait!
15:40:31 <tromp> > let f = reverse . stripPrefix "0." . reverse in map (f.show) [1.0,2.1]
15:40:32 <lambdabot>  Couldn't match expected type `[a]'
15:41:35 <tromp> :t stripPrefix "0."
15:41:36 <lambdabot> [Char] -> Maybe [Char]
15:41:39 <tromp> aha
15:43:28 <BONUS> hmmm
15:43:49 <tromp> > let f s = (maybe s reverse) . stripPrefix "0." . reverse $ s in map (f.show) [1.0,2.1]
15:43:51 <lambdabot>  ["1","2.1"]
15:44:15 <BONUS> say i have a type of Foo a b c and i want to make it an instance of a class that needs a kind * -> * but i want the a or b unparametrised instead of the c
15:44:17 <tromp> unfortunately there's no stripSuffix
15:44:20 <BONUS> is that possible without a type synonim?
15:44:40 <dmhouse> BONUS: no, and in fact you need a newtype.
15:44:47 <dmhouse> BONUS: you're not allowed type-level lambdas.
15:44:51 <BONUS> ah
15:44:52 <BONUS> cheers
15:45:08 <dmhouse> (As this results in System F, for which type reconstruction isn't possible.)
15:45:25 <tromp> > let f s = isSuffixOf ".0" s then init(init s) else s in f $ show 10
15:45:25 <lambdabot>  Parse error at "then" (column 29)
15:45:57 <tromp> > let f s = if isSuffixOf ".0" s then init(init s) else s in f $ show 10
15:45:59 <lambdabot>  "10"
15:50:27 <stepcut> tromp: is that BSD3 licensed ?
15:51:01 <tromp> is what BSD3 licensed ?
15:51:28 <stepcut> (let f s = if isSuffixOf ".0" s then init(init s) else s in f $ show)
15:51:43 <tromp> no that's unlicensed
15:52:10 <stepcut> intellectual property is property no matter how small...
15:52:20 <tromp> and its ugly
15:52:28 <tromp> i'd define a stripSuffix instead
16:01:21 <Sarajevo> is haskell dead?
16:01:28 <BONUS_> no
16:01:34 <BONUS_> still being awesome
16:01:46 <Sarajevo> I don't know anything about haskell
16:01:47 <dmhouse> ?faq Can Haskell come back to life?
16:01:47 <lambdabot> The answer is: Yes! Haskell can do that.
16:01:52 <Sarajevo> all I know it's a programming language
16:02:00 <dmhouse> ?where yaht
16:02:01 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:02:05 <BONUS_> its very much alive, being developed, etc.
16:02:07 <BONUS_> and its awesome
16:02:09 <dmhouse> Sarajevo: want to get stuck in? :)
16:02:44 <Sarajevo> hmm
16:02:48 <Sarajevo> yeah sure
16:02:51 <BONUS_> w00t, managed to get Haskell syntax highlighting in HTML just like in my vim
16:02:53 <BONUS_> :]
16:03:02 <Sarajevo> =)
16:03:27 <ddarius> BONUS ... you can have vim just generate the HTML
16:03:41 <BONUS_> eh, i find that kind of messy
16:03:42 <dmhouse> Sarajevo: have a look at http://darcs.haskell.org/yaht/yaht.pdf
16:03:45 <lambdabot> Title: Yet Another Haskell Tutorial
16:03:56 <BONUS_> cause then you have styling in your markup etc
16:04:11 <Sarajevo> thanks a lot
16:04:14 <BONUS_> and if you want to change the highlighting later on, you're in a rut
16:04:50 <BONUS_> Sarajevo: also check out http://book.realworldhaskell.org/beta
16:04:53 <BONUS_> really awesome stuff
16:04:59 <lambdabot> Title: Real World Haskell
16:05:43 <bos> we've got an indication of what the final page count will be, by the way: about 450pp.
16:06:00 <BONUS_> awesome
16:06:13 <BONUS_> what will be the format
16:06:24 <bos> format?
16:06:25 <BONUS_> i mean do you know how big it will physically be
16:06:58 <bos> standard o'reilly size.
16:07:10 <BONUS_> ah
16:07:14 <BONUS_> when's it due?
16:07:28 <bos> maybe the end of october?
16:07:35 <BONUS_> coool
16:09:16 <stepcut> I wish I could pattern match on the arguments and ignore the constructor (provided the constructors are all of the same type)
16:09:38 <ski> maybe you want disjunctive patterns ..
16:09:55 <stepcut> ski: does GHC 6.8.2 have them?
16:10:02 <ski> not that i know
16:10:07 <stepcut> :(
16:10:10 <ski> O'Caml has them
16:10:21 <ski> some SML implementations, too
16:10:24 <Trinithis> time to leave haskell for ocaml then!
16:10:48 <stepcut> ocaml has,  match foo with A | B -> bar ; C -> baz ;, which is cool too
16:10:52 <ddarius> No
16:11:12 <ski> stepcut : that's disjunctive patterns, yes
16:11:23 <ddarius> Trinithis: Go for it.
16:11:27 <ski> stepcut : mayhaps you can abstract out the differing constructor part into a separate constructor argument ?
16:11:28 <stepcut> ah, SimonPJ thought they were cool too I think
16:11:48 <stepcut> ski: well, that is the problem, I could, but then other code gets ugly instead
16:11:55 <dafra> does someone know why ghc switched to git ? darcs is too slow ?
16:12:05 <dmhouse> I'm not sure they did in the end.
16:12:27 <dmhouse> dafra: the complaints were performance and stability.
16:12:45 <dafra> dmhouse: no surprise , then
16:12:46 <stepcut> dafra: for GHC, it was too slow, had  too many bugs, and did not work well enough on windows.
16:13:11 <ddarius> There is a page listing the reasons.
16:13:21 <ddarius> And no doubt reams of mailing list discussion.
16:13:22 <BONUS_> eh, should have switched to hg :\
16:13:23 <BONUS_> oh well
16:13:29 <dafra> stepcut: time to write the next darcs ...
16:13:31 <stepcut> ski: do disjunctive patterns allow, case expr of e@(_ (Lit a) (Lit b)) -> simplify e
16:13:40 <stepcut> dafra: well, that has been proposed
16:13:54 <stepcut> dafra: both other people are working on fixing up darcs 2 as well
16:15:55 <ski> stepcut : no
16:16:51 <ski> they'd allow `case expr of e@(Foo (Lit a) (Lit b) | (Bar (Lit a) (Lit b))) -> simplify e' e.g.
16:17:00 <stepcut> ah. Well that is what I want. I refactored the code to be, case expr of (Binary _ (Lit a) (Lit b)), but then a bunch of other pattern matching got really ugly
16:17:27 <stepcut> ski: that would be an improvement
16:18:09 <ski> s/(Bar/Bar/ s/Lit b)))/Lit b))/
16:28:04 <bos> @seen dons
16:28:04 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 1h 47m 38s ago.
16:33:24 <dons> bos?
16:36:10 <ski> hm, what would be a nice (reasonably efficient) implementation of `stripSuffix' ?
16:36:24 <dons> from a [a] ?
16:37:19 <ski> stripSuffix :: [a] -> [a] -> Maybe [a]
16:37:28 <ski> er, add an `Eq a => ' there
16:37:40 <dons> well, you can do it by walking the list only once
16:37:45 <dons> so that's probably most efficient
16:37:56 <gwern> ski: takeWhile (not == a)?
16:38:16 <ski> yes .. i have one implementation in mind .. but it looks a bit ugly
16:38:37 <tehgeekmeister> is there an option for ghc that will make it clean up the intermediate files (*.o, *.hi) automatically for me?
16:38:47 <dons> hmm.
16:38:48 <gwern> tehgeekmeister: yes
16:38:53 <dons> gwern: ?
16:39:03 <ski> gwern : i don't think you can reasonably use `takeWhile' for this
16:39:06 <dons> i'm not aware of a flag that will do this.
16:39:13 <gwern> it's like no-intermediates or something
16:39:18 <dons> oh.
16:39:20 <gwern> isn't it?
16:39:35 <dons> it rings a faint bell.
16:39:40 <gwern> it must be doable, otherwise wouldn't ghci and runhaskell litter?
16:39:58 <dons> bytecode
16:40:09 <eu-prleu-peupeu> hi
16:40:26 <ski>   stripSuffix list suffix = Nothing  <=>  not exists prefix. list = prefix ++ suffix
16:40:29 <eu-prleu-peupeu> isn't it possible to have a function with the same name, but different signature on haskell ?
16:40:39 <dons> eu-prleu-peupeu: yes, via type classes, or module hiding.
16:40:39 <ski>   stripSuffix list suffix = Just prefix  <=>  list = prefix ++ suffix
16:40:46 <gwern> eu-prleu-peupeu: in the same module?
16:40:48 <eu-prleu-peupeu> like: add :: Num a => vec a->a->vec a              -- scalar add
16:40:48 <eu-prleu-peupeu>        add :: Num a => vec a->vec a->vec a          -- vector add
16:40:49 <ski> is the specification
16:40:52 <eu-prleu-peupeu> in the same type class
16:41:08 <ski> gwern : ^
16:41:16 <dons> so that's vec a -> b-> vec a
16:41:17 <stepcut> eu-prleu-peupeu: you can do that to a degree with type-classes
16:41:21 <dons> where b is a or vec a.
16:41:33 <rwbarton> to get the right asymptotic running time and maximum laziness, I think you need the KMP algorithm
16:41:45 <eu-prleu-peupeu> yes, dons, my mistake :P
16:42:03 <stepcut> eu-prleu-peupeu: assuming you also need different implementations of 'add' which depend on the type.. otherwise a simply polymorphic function would work
16:42:06 <eu-prleu-peupeu> ghc outputs:     Multiple declarations of `Vector.add' :(
16:42:34 <rwbarton> If you don't care about laziness at all, you could just use reverse + stripPrefix :)
16:42:36 <stepcut> eu-prleu-peupeu: if you have a different implementation of add for each type, then you need type classes
16:42:50 <eu-prleu-peupeu> yes, i need them
16:42:51 <tehgeekmeister> gwern: there seem to be options to keep MORE intermediate files in the man page, but not less
16:42:57 <eu-prleu-peupeu> i need add for Vector3, and add for Vector4
16:43:05 <stepcut> stripSuffix should be pretty efficient on snoc lists ;)
16:43:07 <eu-prleu-peupeu> im currently using type class Vector
16:43:09 <gwern> hm. 'To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: -ohi /dev/null, for example.'
16:43:17 <gwern> '-hidir dir
16:43:18 <gwern> Redirects all generated interface files into dir, instead of the default.'
16:43:24 <dons> but you might need it for linking.
16:43:33 <gwern> tehgeekmeister: so maybe 'ghc -ohi /dev/null -hidir /dev/null'?
16:44:04 <rwbarton> Actually, what am I saying, there is no laziness possible anyways.
16:44:06 <eu-prleu-peupeu> ghc complains about having a "redefined" add :/
16:44:16 <tehgeekmeister> gwern: i'll give that a try, thanks
16:44:59 <tehgeekmeister> and that flag won't play nice with building packages, will it?  so i should be careful using a global alias in my shell?
16:45:38 <gwern> tehgeekmeister: what do you by building packages?
16:45:47 <tehgeekmeister> gwern: stuff from hackage
16:46:03 <gwern> I can't see why cabal would care about your shell aliases
16:46:33 <tehgeekmeister> oh, right, it's not a shell script
16:50:22 <rwbarton> > let stripSuffix suff = fmap reverse . stripPrefix (reverse suff) . reverse in (stripSuffix "zy" "xyzzy", stripSuffix "yz" "xyzzy")
16:50:24 <lambdabot>  (Just "xyz",Nothing)
16:50:47 <dmhouse> I don't think double reverse is an efficient way to write it.
16:51:41 <SamB_XP> dmhouse: why not?
16:51:46 <SamB_XP> I think it nearly has to do that
16:51:53 <tehgeekmeister> gwern: 'ghc -hidir/dev/null' does what i want, and it complains about /dev/null already existing, but otherwise it's just fine.  just fyi.
16:52:05 <gwern> interesting
16:52:22 <gwern> maybe we could request a no-intermediates flag, if the basic functionality is already there
16:52:23 <rwbarton> dmhouse: Well, it's asymtoptically optimal; I'd not be surprised if there was a faster way in practice, but it would require benchmarking
16:52:40 <tehgeekmeister> it'd be nice, i normally don't want the intermediates
16:52:45 <tehgeekmeister> they just clutter my code directory
16:54:50 * rwbarton wonders what The Daily WTF-worthy Haskell code would look like...
16:54:57 <rwbarton> {-# NOINLINE safeId #-}
16:54:59 <rwbarton> safeId = id . id
16:55:53 <Philonous> That's even more identical than just id :D
16:56:05 <Botje> rwbarton: unsafePerformIO everywhere.
16:56:07 <Botje> and no shame.
16:56:09 <vixey> :t id . id
16:56:10 <lambdabot> forall a. a -> a
16:56:22 <rwbarton> "The Real WTF is the Monomorphism Restriction"
16:56:42 <rwbarton> Yeah, it calls id twice for extra safety :)
16:59:15 <Philonous> Maybe one should write a Monad bind that applies id every time you bind a value two a fauction - just to make sure the values don't get changed inbetween
16:59:24 <Philonous> function*
17:00:30 <twanvl> We could define a IdentityT monad transformer
17:01:07 <paczesiowa> and fixT it to get Identity
17:01:15 <erikc> daily wtf haskell code would be stuff that leaks space like crazy or has insane time bounds
17:02:19 <twanvl> data Boolean = Yes | No | FileNotFound
17:02:42 <psyklops> Heh.. I'm reading Prelude and I just saw Eq.. it's got something like: Eq a, Eq b      Eq a, Eq b, Eq c   ....   Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, ...
17:03:11 <dmhouse> psyklops: what does?
17:03:19 <psyklops> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:03:21 <lambdabot> Title: Prelude, http://tinyurl.com/y4wexy
17:03:25 <psyklops> (Eq a, Eq b) => Eq (a, b)
17:03:25 <psyklops> (Eq a, Eq b, Eq c) => Eq (a, b, c)
17:03:26 <psyklops> (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
17:03:34 <dmhouse> Oh, tuple instances. Yeah.
17:03:36 <psyklops> Sort of WTF-ish to me..
17:04:07 * dmhouse wonders about a Tuple typeclass
17:04:15 <psyklops> So there's a definition of each tuple up to.. (let's see...) 15-tuples
17:04:32 <psyklops> what do we do for 16-tuples?
17:04:52 <paczesiowa> dmhouse: typeclass TN for tuples >= N
17:05:22 <paczesiowa> with fun tn where t1 = fst
17:05:36 <vixey> that's programming
17:05:37 <paczesiowa> and fst (1,2) == fst (1,2,3)
17:06:29 <ddarius> psyklops: Write another instance.
17:06:36 <ddarius> The whole point is that it isn't magical.
17:06:56 <ddarius> Of course, if you have 16-tuples you are already doing something wrong.
17:07:58 <dmhouse> I don't think it's possible to write a general Eq function on all tuples.
17:08:37 <vixey> if there are a finite number of tuples or they are defined inductively then it is possible
17:09:25 <vixey> you can also write a perl script that prints out the first 1000 instances
17:09:31 <dmhouse> ;)
17:09:33 <Botje> psyklops: panic
17:09:45 <paczesiowa> you can write haskell script that prints out the first 1000 instances
17:09:49 <Botje> that's what we do when we hit 16-tuples
17:11:14 <vixey> but yeah
17:11:34 <vixey> it does seem like you could have some tools for programming over sets of datatypes
17:11:37 <vixey> (other than TH)
17:11:39 <Philonous> Maybe it's possible to declare some sort of  "All-type class" and just use lists instead ;)
17:12:09 <Botje> hmm
17:12:16 <vixey> :t let (*) = (,) in   ( 1 * 3 * 4 * "foo" * "bar" * () * x )
17:12:17 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => ((((((t, t1), t2), [Char]), [Char]), ()), Expr)
17:12:18 <paczesiowa> and set of all sets
17:12:26 <Botje> perhaps we could use the GHC plugin SoC to write "instance generators"
17:12:38 <dmhouse> Botje: TH can do this already.
17:12:41 <vixey> Botje: What have you got against my perl script!?
17:12:58 <Botje> vixey: don't have a cure at hand, sorry ;)
17:12:59 <dmhouse> But I doubt GHC has the memory to store an infinite number of instances.
17:13:04 <dmhouse> So they'd have to be lazily generated ;)
17:13:08 <Botje> that's what i meant
17:13:12 <vixey> what I want to be able to do is
17:13:16 <vixey> data Foo deriving bar
17:13:25 <paczesiowa> :t let (,) = (,) in 1,'2',"3"
17:13:26 <Botje> okay
17:13:30 <Botje> s/generators/derivers/
17:13:37 <vixey> and use some language (a bit like syntax-rules is to scheme) to implement 'bar' deriving
17:13:51 <vixey> and similar for typeclasses
17:13:55 <Botje> that's what i was thinking about
17:13:56 <dmhouse> vixey: there is generalised newtype deriving for newtypes.
17:14:18 <dmhouse> I.e. you can do newtype Foo = MkFoo Bar deriving (Any, Thing, You, Want, That, Bar, Instantiates)
17:14:20 <vixey> dmhouse: I can't make catamorphisms with that though (which is the only real reason I want this)
17:14:49 <tehgeekmeister> http://hpaste.org/9674 <== i'm trying to grab just the contents of each <text>...</text> element in a wikidump;; why won't this code do that?
17:16:29 <vixey> anyway it'll never happen
17:16:34 <vixey> so I don't know why I'm even talking about :p
17:16:44 <vixey> I was just wishing for this earlier today
17:17:04 <ski> SamB_XP : you can do `stripPrefix' with only one transposal of the main list, as dons noted
17:23:07 <Apocalisp> Here's an interesting one. Given a list A of length n, I'd like another list B such that every element from A appears in B following every other element from A exactly once.
17:23:48 <vixey> what
17:24:24 <vixey> can you give a sample input and output?
17:24:25 <Botje> can you give an example?
17:25:40 <Pegazus> are elements of A unique?
17:25:46 <Apocalisp> yes
17:26:36 <Apocalisp> f [1,2,3] = [1,2,3,1]
17:26:54 <vixey> yeah that didn't help
17:26:56 <Pegazus> following is just to the prior or all the priors?
17:26:58 <vixey> I still don't understand it at all
17:27:21 <Pegazus> f [1,2,3] = [1,2,3,1] --> that's false...
17:27:25 <tehgeekmeister> is there a way to suppress the automatic printing of a value in ghci so i can use hGetContents to open a file without printing the file to screen?
17:27:37 <Apocalisp> f [1,2,3,4] = [1,2,3,4,1,3]
17:28:00 <shrughes> tehgeekmeis: -fno-print-bind-results
17:28:02 <Pegazus> 2 that doesn't work either
17:28:05 <Pegazus> 2 isn't following 4
17:28:24 <Apocalisp> actually they just have to be adjacent at least once
17:28:28 <tehgeekmeister> shrughes: thanks
17:28:28 <Apocalisp> sorry
17:28:36 <Pegazus> adjacent or following?
17:28:46 <Pegazus> is adjacent a simetrical property for you?
17:29:04 <Apocalisp> following or preceding
17:29:09 <Pegazus> oh
17:29:11 <Pegazus> it's easy...
17:29:36 <Apocalisp> I thought it might be, for you.
17:29:43 <Pegazus> sorry, not that easy :p
17:29:59 <vixey> It's not at all clear what 'it' is
17:30:23 <Apocalisp> but yea, the second one doesn't work, you're right, 2 and 4 are missing
17:30:36 <Pegazus> f [x:xs] = x + (elem xs 2) + x +  (elem xs 3) + etc.. + f xs (i don't know how to write this)
17:30:57 <Pegazus> with that idea you can solve it :)
17:31:12 <vixey> :t etc..
17:31:21 <Pegazus> i don't know how to write that code! :p
17:31:31 <Pegazus> f [1] = [1]
17:31:41 <vixey> f [2] = [2]
17:31:42 <vixey> :p
17:31:46 <Apocalisp> That works!
17:31:51 <Pegazus> etc...
17:31:52 <Pegazus> blah
17:32:28 <Pegazus> what was this problem anyway?
17:33:01 * vixey still has no idea what Apocalisp was trying to describe
17:34:06 <Pegazus> i hope it was an NP problem and i've just won a millon bucks ( ? )
17:34:08 <ddarius> > let f [] = []; f (x:xs) = intersperse x xs ++ f xs in f [1,2,3]
17:34:11 <lambdabot>  [2,1,3,3]
17:34:47 <ddarius> > let f [] = []; f (x:xs) = x:intersperse x xs ++ f xs in f [1,2,3]
17:34:49 <lambdabot>  [1,2,1,3,2,3,3]
17:35:02 <ddarius> > let f [x] = [x]; f (x:xs) = x:intersperse x xs ++ f xs in f [1,2,3]
17:35:04 <lambdabot>  [1,2,1,3,2,3,3]
17:35:04 <vixey> > let list = "!@#$" in concat $ intersperse list (map return list)
17:35:06 <lambdabot>  "!!@#$@!@#$#!@#$$"
17:35:48 <vixey> > let list = "<([])>" in concat $ intersperse list (map return list)
17:35:50 <lambdabot>  "<<([])>(<([])>[<([])>]<([])>)<([])>>"
17:36:04 <dons> now that is an interesting graph,
17:36:06 <dons>   http://www.google.com/insights/search/#cat=&q=haskell language&geo=&date=&clp=&cmpt=q
17:36:07 <Apocalisp> Well, given a list of points, I want the cartesian product of pairs to find all the edges between all points. But I'm using a program (somebody else's) that takes list of vertices in a polygon or path and only finds the edges from each vertex in the list to the next.
17:36:07 <lambdabot> Title: Google Insights for Search
17:36:09 <Olathe> > let moo = "moo" in moo
17:36:11 <lambdabot>  "moo"
17:36:11 <dons> it's pretty accurate, imo.
17:36:29 <dons> "language shootout" a common phrase used to find haskell too
17:36:45 <Olathe> > let list = "<([])>" in (map return list)
17:36:47 <lambdabot>   add an instance declaration for (Show (m Char))
17:36:53 <Olathe> > let list = "<([])>" in intersperse list (map return list)
17:36:55 <lambdabot>  ["<","<([])>","(","<([])>","[","<([])>","]","<([])>",")","<([])>",">"]
17:37:00 <Olathe> A hah !
17:37:14 <paczesiowa> Haskell goes from serious fall to the Super Bowl
17:37:33 <paczesiowa> probably ghc-6.8 release date
17:37:38 <Pegazus> Apocalisp can't you modify that program?
17:37:45 <Apocalisp> No :(
17:37:47 <vixey> Apocalisp: ok, and?
17:38:07 <Pegazus> cant you write the cartesian product yourself?
17:38:18 <vixey> @let cartesianProduct = liftM2 (,)
17:38:19 <lambdabot> <local>:4:19:     Ambiguous type variable `m' in the constraint:       `Monad...
17:38:19 <Pegazus> it's quite easy...
17:38:49 <Apocalisp> And I want to give the program a list that will make it return me all possible edges.
17:38:53 <vixey> > let cartesianProduct = liftM2 (,) in cartesianProduct (words "red green blue") [True,False]
17:38:55 <lambdabot>  [("red",True),("red",False),("green",True),("green",False),("blue",True),("b...
17:39:29 <Apocalisp> I can write the cartesian, but the "edge" algorithm is quite complex and completely opaque.
17:39:30 <vixey> > let cartesianProduct = liftM2 (,) in (\(x,y)->[x,y]) =<< cartesianProduct (words "red green blue") ["True","False"]
17:39:32 <lambdabot>  ["red","True","red","False","green","True","green","False","blue","True","bl...
17:40:11 <Olathe> Eww.
17:40:19 <SamB_XP> not ... quite ... it!
17:40:23 <vixey> what is opaque/
17:40:25 <vixey> ?
17:40:43 <Olathe> > [1] *** [2]
17:40:43 <SamB_XP> or is it?
17:40:44 <lambdabot>  Couldn't match expected type `a b c' against inferred type `[a1]'
17:40:50 <Olathe> Bah.
17:40:53 <SamB_XP> okay, more like WHY?
17:40:58 <Olathe> Too many short symbol thingies taken up.
17:41:01 <vixey> SamB: I have absolutely no idea what 'it' is
17:41:16 <Apocalisp> vixey: It operates on a spatial database to which I don't have access except through this program.
17:41:16 <vixey> Olathe, nice thing about haskell:
17:41:30 <vixey> > let (*) = liftM2 (,) in   "foo" * "bar" * "baz"
17:41:32 <lambdabot>  [(('f','b'),'b'),(('f','b'),'a'),(('f','b'),'z'),(('f','a'),'b'),(('f','a'),...
17:43:27 <SamB_XP> Apocalisp: oh, you want to generate journeys that traverse all edges of a graph?
17:43:38 <SamB_XP> or, er, all possible edges?
17:43:51 <Apocalisp> vixey: I can easily get the list of all possible pairs of vertices and feed each pair to the program in turn, so that it always operates on a list of length 2.
17:44:02 <Apocalisp> But this takes a long time.
17:44:12 <vixey> takes a long time to do what?
17:44:34 <SamB_XP> or should I say generate *one* journey that traverses all possible edges of a graph?
17:44:37 <Apocalisp> To generate the edge between each pair of vertices.
17:44:48 <vixey> ok
17:45:15 <Apocalisp> SamB_XP: Yes, I want to generate a minimal journey that traverses all possible edges of a graph.
17:45:26 <vixey> minimal ?
17:45:33 <lispy> Apocalisp: this is starting to sound np
17:45:52 * lispy only heard the part about wanting minimal pathes in graphs
17:45:54 <Apocalisp> drat
17:45:55 <Pegazus> i was right!!! i solved an np problem in p time :)
17:46:11 <vixey> What I don't get is
17:46:30 <vixey> does this have any relation to what you were talking about earlier ?
17:47:10 <Apocalisp>  f [1,2,3] = [1,2,3,1] <-- that?
17:47:15 <Apocalisp> Yes
17:47:21 <dmwit> Pegazus: Not a surprise, I've done that a few times myself.  Now, solving an NP-complete problem in P-time... that's more impressive.
17:47:43 <Pegazus> :(
17:47:46 <Pegazus> i hate you dmwit!
17:48:03 <Apocalisp> Maybe I can approach a solution rather than find the optimal solution.
17:48:14 <Pegazus> i've done that a few times too anyways...
17:48:15 <vixey> so f :: [a] -> [a], but you have a distance function between a's ?
17:48:25 <lispy> dmwit: yeah
17:48:52 <lispy> dmwit: if done in a reproducible manner using a turing machine i bet it would be worth at least a conference paper
17:49:00 <lispy> at least :)
17:49:11 <dmwit> Yes, maybe so.
17:49:41 <oklopol> > let add a b = a + b in add 32 5
17:49:43 <lambdabot>  37
17:49:43 <dmwit> And perhaps... a couple $million, too. =P
17:49:50 <oklopol> wow, i solved an np problem in p time!
17:49:53 <Apocalisp> vixey: I have a distance function, but the goal is to make the fewest calls to the distance function. I.e. to find the journey through the graph with the fewest steps, not the shortest distance.
17:49:53 <oklopol> :)
17:49:57 <gwern> @seen nomeata
17:49:58 <lambdabot> I saw nomeata leaving #xmonad, #haskell and #darcs 52m 4s ago, and .
17:50:09 <lispy> dmwit: pshaw, if the clay institute offered me money for solving a math problem I'd jsut walk away from it ;)
17:50:23 <vixey> if you have n vertices.. it's going to take n steps to get to them all
17:50:27 <dmwit> ;-)
17:51:00 * lispy is still shocked he didn't at a minimum donate the money to a charity or us it to for scholarships or something that benefits mankind
17:52:00 <dmwit> Right.
17:52:06 <dmwit> It would have set a nice precedent for future winners.
17:52:23 <tehgeekmeister> gwern: it appears that -hidir /dev/null may have the unfortunate side effect of also directing your final binary to /dev/null
17:52:56 <tehgeekmeister> gwern:  i was wondering why none of my code changes were showing after compiling...
17:53:03 <Apocalisp> vixey: Exactly. Now what I need is an order for the vertices so that each edge is traversed at least once. What I have so far is a list on the order of n^2, but I'd like to get closer to n.
17:53:23 <vixey> do you have a list of edges?
17:53:38 <vixey> (which is a subset of all n^2 possible edges)
17:54:46 <Apocalisp> Yes, I have a list of all possible edges.
17:56:17 <vixey> so it's very similar to finding a hameltonian path
17:56:27 <Apocalisp> I can prune that down to omit duplicate (inverse) edges.
17:56:31 * lispy wonders how many infinities it would take to list all the unpossible edges
17:57:18 <Apocalisp> an infinite amount of them!
17:58:24 <seanl> hm... does anybody know if it is possible to marshall tuples through FFI?
18:00:09 <Apocalisp> Hah! Yes, you're right. It's the Hamiltonian Circuit.
18:00:14 <Apocalisp> NP-Complete
18:01:41 <lispy> for the most part minimal path on a graph is going to be np-complete unless you have more information like a tree or a good metric
18:02:18 <lispy> At least that's how I felt when I studied that stuff
18:02:29 <tehgeekmeister> what regexp library is best to use for simple search and replace?
18:02:35 <Apocalisp> lispy: Can it be approximated?
18:03:01 <lispy> Apocalisp: I haven't studied heuristics really
18:03:27 <lispy> Apocalisp: but I would be there are things that can come within a certain multiple of minimal in P-time or something like that
18:03:44 <Apocalisp> OK, thanks
18:06:42 <Philonous> It is strange how fast one gets used to a tiling window manager
18:13:50 <sjanssen> Philonous: what is even more strange is how quickly you become totally useless on any other window manager
18:15:24 <Philonous> I always found "normal" window managers to be cluttered. I don't even wanna know how they'd feel in some sort of "productive" enviroment now :>
18:17:11 * ddarius uses xmonad and Windows more or less the same.
18:38:15 <jberg> hmm, i have a recursive function which takes a list, a max value and accumulated result. if the accumulated value is above max, i want to backtrack the function one step back and try a lower value, but i cant understand how to do it..
18:38:41 <jberg> maybe poorly explained, but does anyone understand the problem?
18:39:26 <lispy> foo :: Ord a => [a] -> a -> a -> ??
18:39:47 <jberg> [a]
18:40:52 <lispy> jberg: if you don't store the examined part of the list anywhere then you can't really go back.  You could accumulate the visited elements in a parameter
18:41:14 <jberg> hmm
18:41:18 <atp> jberg: you might try a zipper
18:41:33 <lispy> foo :: Ord a => [a] -> a -> a -> [a] -> [a], input list, max, accum, visited part of list, and then finally the returned part
18:41:36 <jberg> i dont see how a zipper would help me
18:41:37 <atp> jberg: then you can move the focus back arbitrarily
18:41:51 <atp> because you can always choose to switch the direction of recursion
18:42:06 <jberg> lispy hmm yeah
18:42:19 <jberg> atp, are you talking about the zip* functions?
18:42:23 <atp> jberg: no
18:42:35 <jberg> whats a zipper then?
18:42:37 <lispy> jberg: a zipper a functional data structor with a 'cursor'
18:42:37 <atp> a zipper is a data structure... it can be generalized to any algebraic data type, but the one on lists is simple
18:42:51 <jberg> oh okay, will try to google it
18:42:55 <atp> take type Zipper a = ([a], [a])
18:43:20 <jberg> ok
18:43:30 <atp> then, say, forward (xs, (y:ys)) = forward (xs:y, ys)
18:43:38 <Philonous> If the function is recursive maybe you can just process the return value of the function call and re-call it with new values?
18:43:48 <atp> err sorry
18:43:54 <atp> remove the forward on the rhs
18:44:07 <atp> forward (xs, (y:ys)) = (xs:y, ys)
18:44:20 <Philonous> You could use some algebraic datatype to indicate that you need to re-evluate the next recursion-step with a different value
18:44:21 <atp> and backward ((x:xs), ys) = (xs, x:ys)
18:44:31 <atp> (of course you'd need to check for [] in both cases
18:44:31 <atp> )
18:44:42 <atp> anyway then your focus is
18:44:52 <atp> focus (xs, (y:ys)) = y
18:45:00 <totimkopf> has anybody read haskell school of expression?
18:45:10 <atp> to turn a list into a zipper, you say makezipper xs = ([], xs)
18:45:13 <Smokey`> does anyone know what kind of garbage collection technique GHC uses by default?
18:45:17 <jberg> what i want to do is generate integer partitions, say [5] i want [4, 1] [3, 2] [2, 2], [3, 1, 1] etc
18:45:29 <totimkopf> rather 'The Haskell School of Expression: Learning Functional Programming through Multimedia'
18:45:29 <lispy> Smokey`: generational
18:45:31 <jberg> totimkopf: yes part of it
18:45:38 <totimkopf> jberg, what did you think?
18:45:45 <atp> jberg: there are easier ways to do that :)
18:45:56 <lispy> Smokey`: there are a few papers about the GC, look up simon marlow
18:46:15 <Smokey`> thank you :)
18:46:19 <jberg> it's ok, but as an introduction i think a book like practical common lisp was way better (even though thats for lisp)
18:46:34 <jberg> atp: like what ways?
18:46:37 <atp> jberg: consider that any natural number can be written as a sum of ones
18:46:44 <lispy> jberg: then you'd like real-world haskell
18:46:50 <atp> jberg: and at each place, you can replace the + with a , if you want
18:46:57 <jberg> lispy: yes i've concidered purchasing it
18:47:04 <atp> jberg: if you do each permutation, and remove duplicates, you have all partitions
18:47:16 <atp> but perhaps your algorithm is faster.
18:47:27 <atp> (since i don't know what you're trying to do, i can't comment on that)
18:47:30 <ddarius> jberg: See issue 8 of The Monad Reader.
18:47:34 <jberg> atp, yes i dont want to do all permutations
18:47:38 <jberg> ddarius: okay i will
18:47:42 <totimkopf> is Lisp easier than Haskell?
18:47:47 <atp> totimkopf: it's different
18:48:02 <atp> totimkopf: and lisp is strictly speaking more than one language, it's a family, so it depends
18:48:13 <totimkopf> then what would 'Common Lisp' be?
18:48:18 <atp> totimkopf: a kind of lisp :)
18:48:22 <lispy> totimkopf: lisp is way easier than Haskell except that it's also way harder and also about the same
18:48:23 <totimkopf> ah ok
18:48:46 <atp> lisp is a fun language, worth learning.
18:48:55 <atp> homoiconicity is cool.
18:48:56 <ski> jberg : "backtracking" suggests maybe list monad might be for you ..
18:48:56 <lispy> it's also a fun way to talk
18:49:14 <totimkopf> lispy =p
18:49:26 <atp> jberg: do you understand the zipper data structure i explained to you?
18:49:30 <jberg> ski: yes i've been thinking of that, except i dont really understand monads..
18:49:37 <jberg> atp: havent looked at it yet
18:49:43 <atp> oh.
18:49:56 <jberg> i will though
18:50:06 <ski> jberg : it might help if you elaborated on what your function is supposed to do ..
18:50:07 <atp> well, for lists there's not much more than what i put up at the top
18:50:13 <totimkopf> i'm still a newbie to functional programming, ehm... i'm kind of lost in what paradigm and language to expertise in
18:50:15 <jberg> ski: generate integer partitions
18:50:19 <totimkopf> it's a bit overwhelming
18:50:27 <atp> totimkopf: lisp isn't functional, it's more multi-purpose
18:50:31 <ski> jberg : all of them ?
18:50:41 <jberg> yes
18:50:42 <totimkopf> atp, oh
18:50:44 <tehgeekmeister> @hoogle [(a -> a)] -> [a] -> [a]
18:50:44 <lambdabot> A Hoogle error occurred.
18:50:45 <jberg> well for a given number
18:50:59 <Dwaylu> Hoogle
18:51:03 <totimkopf> then why would i want to learn Lisp when i wanted to learn functional programming
18:51:04 <jberg> but i need to generate partitions for pretty large numbers so it has to be fast
18:51:08 <ski> jberg : that definitely seems suited to the list monad :)
18:51:27 <lispy> :t map ($)
18:51:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
18:51:31 <Philonous> totimkopf: lisp offers some interesting stuff like macros
18:51:53 <solrize> @seen cale
18:51:53 <lambdabot> cale is in #japanese, #haskell-overflow, #ghc and #haskell. I last heard cale speak 8h 2m 21s ago.
18:51:55 <atp> totimkopf: lisp will blow your mind
18:51:57 <lispy> tehgeekmeister: there is a slick way to do that but I can't think of it off the top of my head, I was thinking it was map ($)
18:52:00 <Philonous> which are basicly lisp programmes that write lisp programmes (that write lisp programmes)...
18:52:02 <jberg> ski: but i dont understand what the list _monad_ is, is it not a list?
18:52:04 <atp> totimkopf: that is really the only way that it's at all like haskell
18:52:11 <atp> totimkopf: otherwise, they're completely different.
18:52:17 <ski> jberg : it is lists, looked at in a certain way
18:52:32 <jberg> ski: hm okay
18:52:34 <lispy> > map ($) [(+1), (+2), (+3)] [1..3]
18:52:35 <totimkopf> Philonous, wow that seems interesting
18:52:36 <lambdabot>  Couldn't match expected type `[t1] -> t'
18:52:42 <ski> jberg : i.e., for a result list of a function, you think of that as representing alternative solutions
18:52:44 <jberg> but do i use any special functions or what?
18:52:45 <tehgeekmeister> lispy: isn't it the (forgive me for not knowing the right word) function monad?
18:52:45 <lispy> tehgeekmeister: I'm guessing you want something like that?
18:52:58 <tehgeekmeister> lispy: yep
18:53:01 <jberg> ski: i see
18:53:02 <totimkopf> Lisp will blow my mind but Haskell won't
18:53:04 <totimkopf> ?
18:53:16 <ski> jberg : the list monad is actually quite similar to list comprehensions, in spirit
18:53:16 <atp> no, they both will
18:53:27 <totimkopf> which language is much more exciting?
18:53:31 <atp> they're different
18:53:33 <atp> learn them both
18:53:34 <jberg> ski: mm
18:53:43 <totimkopf> i want to learn Haskell first, though
18:53:49 <tehgeekmeister> lispy: i'm composing a bunch of functions that get rid of some unnecessary markup from a wikidump, but i'd like to just be able to keep them in a list and run the function over that list and the text of the wikidump
18:53:56 <atp> totimkopf: i think haskell is more newbie friendly, community wise.  that has nothing to do with the language of course.
18:54:03 <Philonous> If you come from C/Java to Lisp/haskell it is like you get to lerarn about 40 years of programming language research at once
18:54:20 <lispy> :t zipWith ($)
18:54:21 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
18:54:22 <totimkopf> yeah Haskell communities are friendly.
18:54:28 <lispy> tehgeekmeister: ^^
18:54:30 <ski> > do x <- [0,3,6,9]; y <- [2,5,7]; guard (x > y); return (x,y)  -- list monad example
18:54:32 <lambdabot>  [(3,2),(6,2),(6,5),(9,2),(9,5),(9,7)]
18:54:32 <atp> add APL to that list and you're really in for insanity
18:54:45 <totimkopf> and besides, I fancy Haskell's sexy syntax
18:54:47 <lispy> > zipWith ($) [(+1), (+2), (+3)] [1..3]
18:54:47 <totimkopf> look at that
18:54:49 <lambdabot>  [2,4,6]
18:54:52 <totimkopf> so esoteric, so sleak
18:54:58 <atp> totimkopf: the coolest thing about lisp is the syntax though...
18:55:11 <atp> totimkopf: something which unfortunately people don't realize until they've written a lot of it
18:55:18 <totimkopf> atp, lisp's syntax is cooler than haskell's?
18:55:26 <atp> totimkopf: well, it's different.  but it's homoiconic.
18:55:34 <atp> totimkopf: which makes extending it much easier.
18:55:52 <atp> (although, as ddarius is constantly telling me, the same can be done in Haskell.)
18:55:52 <ski> jberg : in your case, when "the accumulated value is above max", you would probably just return the empty list, which you think of as returning no solution at all .. and let other stages of the evaluation provide the actual solutions
18:55:59 * tehgeekmeister never thot he'd have a function called strippers in his code...
18:56:08 <atp> tehgeekmeister: good name
18:56:33 <lispy> lisp's syntax is so rad.  I seriously wrote a 1 page program once in common lisp that would read itself in, then do a tree search over it's syntax and wrap itself in calls to car and cdr so that when evaluated it returned the symbol WALDO, which you could hide inside in arbitrary places
18:56:53 <atp> lispy: awesome!
18:56:55 <tehgeekmeister> atp: well, it applies a bunch of functions that are stripping unnecessary markup, so it seemed to be the most appropriate name
18:57:22 <atp> i'm not so fond of CL's separate namespaces though
18:57:28 <atp> but scheme doesn't have the libs.... sigh
18:58:46 <lispy> the biggest problem in my opinion with doing modern lisp programming is that no one cares about lisp.  And the community that is there tends to be...not positive.
18:59:12 <atp> yeah, the community has issues.
18:59:23 <atp> they also talk too much and do too little.
18:59:39 <lispy> atp: that reminds me of #haskell! ;)
18:59:50 <totimkopf> i'd rather stick to the Haskell community
18:59:59 <atp> lispy: i feel like haskell has more momentum though
19:00:08 <atp> lispy: lots of new libs coming up every day
19:00:12 <totimkopf> could somebody recommend me some good Haskell books
19:00:14 <lispy> I say that as I'm staring at a type error that has me stumped...the implications of this error are beyond what I can fathom right now.
19:00:20 <atp> totimkopf: real world haskell isn't bad at all
19:00:20 <ski> jberg : have you got any idea of how to write it ? .. or do you require more explanation ?
19:00:28 <totimkopf> atp, yeah but its not out yet
19:00:32 <lispy> atp: oh, the haskell community is great, I was just teasing that we all talk too much in here :)
19:00:35 <jberg> hey, whoever recommended me that haskell book (lispy?), was it real world haskell or programming in haskell? which of those are better and is real world haskell out yet?
19:00:46 <jberg> ski: i think i have an idea
19:00:51 <atp> jberg: i don't think it's out, but the beta is online
19:00:57 <atp> jberg: it's missing a chapter or two
19:00:57 <lispy> real world haskell is spiffy, due out soon
19:01:05 <atp> i think i'll probably buy rwh for my cousin
19:01:13 <jberg> okay
19:01:21 <jberg> what about programming haskell or something?
19:01:22 <lispy> RWH is very modern
19:01:30 <jberg> would you recommend rwh over that?
19:01:35 <totimkopf> i already ordered a book on 'real world', well i'm not sure if its realworld, http://www.amazon.com/gp/reader/0521644089/ref=sib_dp_pt#reader-link
19:01:37 <lambdabot> http://tinyurl.com/5bdngz
19:01:43 <tehgeekmeister> bah, i searched for the wrong function type
19:01:44 <atp> yeah, rwh addresses a lot of the concerns that imperative-minded programmers have about pure functional languages right away
19:01:53 <totimkopf> I ordered The Haskell School of Expression, its supposed to be fun
19:02:14 <tehgeekmeister> @hoogle [a -> b] -> a -> b
19:02:15 <lambdabot> A Hoogle error occurred.
19:02:31 <solrize> soe is an ok book for total beginners but rwh is much more useful imho
19:02:35 <atp> totimkopf: there's a list of 99 prolog problems that are a great starting place for any functional-like language
19:02:41 <atp> totimkopf: i think haskell.org links to them
19:02:44 <lispy> tehgeekmeister: how should that one work?
19:02:46 <ski> tehgeekmeister : what if the list is empty ?
19:02:51 <atp> totimkopf: do them, they start out very easy
19:02:56 <lispy> tehgeekmeister: don't you mean [a -> b] -> a -> [b] ?
19:03:00 <atp> totimkopf: and get progressively harder.
19:03:10 <atp> totimkopf: do them all and you'll be quite good at haskell already.
19:03:18 <solrize> are you talking about the euler problems atp?
19:03:19 <tehgeekmeister> ah, no
19:03:21 <tehgeekmeister> it would be
19:03:22 <atp> solrize: nope
19:03:25 <solrize> hmm
19:03:26 <atp> solrize: although those are good too.
19:03:29 <tehgeekmeister> [a -> a] -> a -> a
19:03:32 <atp> solrize: just a sec, let me find the link.
19:03:33 <jberg> atp: where is that list? never seen it on haskell.org..
19:03:47 <lispy> tehgeekmeister: so what are you doing with the list in that one?
19:03:53 <tehgeekmeister> ski: and if it's empty it wouldn't work, i suppose it should be [a -> a] -> a -> Maybe a
19:03:57 <atp> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
19:03:59 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki, http://tinyurl.com/2wg98q
19:04:01 <lispy> ?pl \xs x -> map ($x) xs
19:04:02 <lambdabot> flip (map . flip id)
19:04:08 <atp> they're originally from the prolog community but they're great.
19:04:10 <lispy> :t flip (map . flip id)
19:04:11 <lambdabot> forall (f :: * -> *) a c. (Functor f) => f (a -> c) -> a -> f c
19:04:42 <atp> i would suggest looking directly at the prolog problem though, because those don't have solutions right there
19:04:45 <atp> to tempt you
19:05:06 <tehgeekmeister> lispy: i want a function that pipes a value of type a thru a list of functions from a to a
19:05:11 <ski> .oO( neun und neunzig haskell problems )
19:05:17 <lispy> tehgeekmeister: oh!
19:05:26 <lispy> :t foldl'
19:05:27 <atp> tehgeekmeister: a fold :)
19:05:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:05:38 <ski> @type foldr (.) id
19:05:39 <lambdabot> forall a. [a -> a] -> a -> a
19:05:57 <moozilla> a good thing to read is the paper on the 'akward squad'
19:05:57 <tehgeekmeister> oh wow!  folding over (.)
19:06:05 <Philonous> Btw. does someone know a site with programming exercises? projecteuler.net is nice, but a little biased towards mathematical problems
19:06:08 <atp> you probably want foldl' though
19:06:13 <atp> rather than foldr
19:06:18 <ski> why ?
19:06:30 <atp> oh, i guess it doesn't matter
19:06:34 <atp> function composition is associative
19:06:38 <atp> go with foldr then
19:06:46 <lispy> yeah, doesn't matter here, because the (.) will just make thunks anyway, I believe
19:07:04 <ski> > foldr (.) id [(x:) | x <- [0..]] []
19:07:07 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:07:10 <tehgeekmeister> foldr versus foldl does make a difference, however;; but not in my case.
19:07:12 <ski> > foldl (.) id [(x:) | x <- [0..]] []
19:07:15 <lambdabot>  Tried to use too much memory
19:07:24 <atp> ski: use foldl'
19:07:25 <lispy> ski: neat
19:07:37 <ski> > foldl' (.) id [(x:) | x <- [0..]] []  -- per request from atp
19:07:39 <lambdabot>  Tried to use too much memory
19:07:39 <atp> oh right
19:07:41 <atp> never mind
19:07:44 <atp> it's an infinite list
19:07:45 <ski> (:
19:07:46 <atp> yah
19:07:50 <atp> i'm a maroon
19:08:13 <ddarius> > foldr (.) id [(x+) | x <- [0..1000000]] 0
19:08:16 <lambdabot>  Exception: stack overflow
19:08:21 <ddarius> > foldl' (.) id [(x+) | x <- [0..1000000]] 0
19:08:23 <lambdabot>  Tried to use too much memory
19:08:26 <atp> haha
19:08:27 <ddarius> > foldl' (.) id [(x+) | x <- [0..100000]] 0
19:08:27 <atp> denied!
19:08:29 <lambdabot>  5000050000
19:08:30 <ski> touche
19:08:35 <ddarius> > foldr (.) id [(x+) | x <- [0..100000]] 0
19:08:38 <lambdabot>  5000050000
19:09:02 <ddarius> Anyway, whether you want foldr or foldl' or foldl depends on the properties of the functions you are folding over here.
19:09:47 <atp> hm...
19:10:16 <tehgeekmeister> ddarius: they're all global substitutions using regexps
19:10:18 <atp> why did the first foldl' use too much mem, ddarius?
19:10:38 <atp> shouldn't the accumulator be seq'd before the func gets called?
19:10:46 <ddarius> atp: Because it is still building up a large function.
19:11:18 <atp> ddarius: the function isn't applied with $! or similar in the strict case?
19:11:23 <atp> @src foldl'
19:11:24 <lambdabot> foldl' f a []     = a
19:11:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:11:30 <atp> hm
19:11:46 <atp> but wait, should that matter?
19:11:56 <atp> the a' is equal to f a x, but then it gets seq'd
19:12:02 <atp> so shouldn't f be forced?
19:12:20 <ddarius> atp: The result of the fold is a function not a value.
19:12:37 <atp> ddarius: because of currying?
19:13:03 <ski> no, because it is a function
19:13:12 <jberg> is there an emacs mode which can look up haskell functions?
19:13:20 <atp> oh right, i see what you're saying.
19:13:20 <jberg> that would be really handy
19:13:34 <atp> ok, i really am smoking something tonight.
19:13:41 <atp> we're folding over (.), obviously...
19:14:16 <Philonous> > (foldl1 (.) [(\x -> x ++ (show i)) | i <- [1..20]]) "a"
19:14:18 <ddarius> Arguably, this suggests that foldr is the right one to use.
19:14:18 <lambdabot>  "a2019181716151413121110987654321"
19:14:26 <Philonous> > (foldr1 (.) [(\x -> x ++ (show i)) | i <- [1..20]]) "a"
19:14:28 <lambdabot>  "a2019181716151413121110987654321"
19:16:32 <Philonous> > (foldl1 (flip .) [(\x -> x ++ (show i)) | i <- [1..20]]) "a"
19:16:34 <lambdabot>      Occurs check: cannot construct the infinite type:
19:16:34 <lambdabot>       f = (->) (f (a -...
19:17:27 <lispy> functions are associate tho, so no need to worry about l or r
19:17:39 <Philonous> apparently
19:18:34 <lispy> > (foldl1 (flip (.)) [(\x -> x ++(show i)) | i <- [1..20]]) "a"
19:18:36 <lambdabot>  "a1234567891011121314151617181920"
19:18:45 <lispy> But not always commuative
19:18:48 <lispy> commutative*
19:19:23 <hackage> Uploaded to hackage: logfloat 0.8.3
19:20:07 <lispy> :t map const
19:20:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> a)
19:20:34 <Philonous> const is the K-combinator?
19:20:45 <tehgeekmeister> if i'm using foldr for this then functions at the end of the list get applied first, and vice versa for foldl, right?
19:21:31 <lispy> > foldr (.) id [f, g, h]
19:21:33 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
19:21:33 <lambdabot>                ...
19:21:40 <lispy> > foldr (.) id [f, g, h] :: Expr
19:21:42 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> a'
19:21:56 <totimkopf> i have a bad habit of buying books rather than learning things from the internet
19:21:58 <lispy> > foldr (.) id [f, g, h] [x, y, z] :: Expr
19:21:59 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
19:22:01 <lispy> bah
19:22:05 <totimkopf> i should be shot
19:22:08 <lispy> tehgeekmeister: I'd have to do an example to know
19:22:11 <Philonous> apperars that foldl does (f1 . f2) .f3 ) . f4 ... ) and foldr (f1 . (f2. (f3 . ...
19:22:23 <tehgeekmeister> lispy: i'll check and see, cos i've got a good example
19:22:30 <Philonous> Which I was trying to show with my free monoid example before
19:22:35 <ski> Philonous : yes
19:22:51 <lispy> free is a good price
19:22:57 <lispy> That's why I like the free monoid
19:23:28 <ski> > foldr (.) id [f, g, h] x :: Expr
19:23:30 <lambdabot>  f (g (h x))
19:23:35 <ski> > foldl (.) id [f, g, h] x :: Expr
19:23:36 <Philonous> Well, but the free monoid is like free software. It's open source but not free of charge
19:23:37 <lambdabot>  f (g (h x))
19:24:09 <tehgeekmeister> lispy: foldl applies from start to end of the list
19:24:37 <lispy> tehgeekmeister: ski did what I couldn't do with a lambdabot example, they work the same :)
19:24:55 <lispy> the last function is the first one to apply
19:25:13 <tehgeekmeister> hmm, okay
19:25:39 * tehgeekmeister reverses list in his helper function before feeding it to fold
19:26:08 <Philonous> it might be cheaper to flip (.)
19:26:27 <tehgeekmeister> i've got a reallllly short list
19:26:28 <lispy> > foldr (flip (.)) id [f, g, h]
19:26:30 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
19:26:30 <lambdabot>                ...
19:26:33 <lispy> > foldr (flip (.)) id [f, g, h] x
19:26:36 <lambdabot>  h (g (f x))
19:26:38 <tehgeekmeister> but that's a good idea
19:26:55 <lispy> :t map (flip (:))
19:26:57 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f (a -> [a])
19:27:02 <lispy> er
19:27:13 <lispy> :t foldl1' (flip (:))
19:27:29 <lispy> that's reverse right?
19:27:37 <lispy> the cute definition anyway
19:29:28 <tehgeekmeister> that's why i wasn't matching all lowercase letters!
19:29:38 <tehgeekmeister> [a-b] /= [a-z]
19:29:47 <lispy> hehe, ouch
19:30:04 <lispy> ?hoogle isLower
19:30:04 <lambdabot> A Hoogle error occurred.
19:30:28 <lispy> isLower = (`elem` [a..z])
19:30:34 <totimkopf> tell me, how would learning Haskell make me a better programmer in general?
19:30:45 <tehgeekmeister> yeh, i'm using it in a regexp, tho, global substitution
19:30:48 <moozilla> because then you could program in haskell :P
19:31:13 <lispy> totimkopf: you'd get more $opposite_geneder banging down your door!
19:31:27 <totimkopf> hehe no idea what that is
19:31:39 <moozilla> figures
19:31:55 <Philonous> You'd start throwing around function pointers in C, hack in some cheap Monad replacement and maybe even try to emulate lisp's macros. So I don't see why it would make you a better programmer at all ;)
19:32:48 <totimkopf> so, Haskell is just a different way of programming, its not necessarily better, or is it?
19:32:51 <ski> totimkopf : you might better judge which effects are essential to the problem, which are useful for the solution, and which are inessential, and to keep from confusing them
19:32:52 <lispy> I see no reason at all why it would make you a better programmer.  But I would imagine that people who are attracted to haskell tend to BE better programmers
19:33:55 <totimkopf> and Haskell is a much secure way or programming, true or myth?
19:33:58 <sw17ch_> lispy, the exercise of doing it a different way makes you a better programmer
19:33:59 <moozilla> totimkopf: all programming languages have pros and cons, haskell is better suited for some problems
19:34:39 <ski> moozilla : what are the pros of brainfuck ?
19:34:52 <totimkopf> moozilla, so there aren't any Haskell zealots who would program everything in Haskell?
19:35:02 <ddarius> ski: You can write a compiler for it in no space whatsoever.
19:35:04 <Philonous> It's hard to copy-cat code written in brainfuck ;)
19:35:04 <moozilla> ski: it's easy to write a compiler for
19:35:37 <lispy> totimkopf: why would you want to emulate a zealot :)
19:35:40 <totimkopf> hehe
19:35:45 <totimkopf> was brainfuck written in assembly?
19:35:45 <ski> hm .. that might be a pro, i suppose
19:35:50 <moozilla> i'm sure there are zealots
19:36:00 <totimkopf> oh, thats another programming language i'd like to learn, Assembly
19:36:09 <moozilla> brainfuck was designed to be as easy to compile as possible afaik
19:36:28 <moozilla> while still being turing-complete
19:36:41 <totimkopf> i have the preconception that i'd be more enlightened and it would affect me profoundly, kind of like Nero finding out he's in the Matrix
19:36:42 <ddarius> Smallest compiler, not "easiest"
19:36:49 * sw17ch_ decides to go play TF2...
19:37:50 <totimkopf> what's everyone's thoughts on learning Assembly?
19:38:02 <moozilla> it's a very valuable experience
19:38:09 <totimkopf> that's what i think too
19:38:20 <lispy> ddarius: easiest being oleg's lambda calc in the haskell type system? ;)
19:38:22 <totimkopf> i think it is more important than learning Haskell first
19:38:24 <Dwaylu1> Should it be learned earlier or later on in your programming career
19:38:33 <Philonous> totimkopf: Haskell should give you a totally new approach to programming. Nothing more and nothing lesse.
19:38:54 <totimkopf> Philonous, thanks :)
19:38:56 <lispy> ?faq Can haskell solve the halting problem unlike other languages?
19:38:56 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:07 <Associat0r> Dwaylu : early
19:39:10 <lispy> ?faq Can Haskell make me a better programmer?
19:39:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:16 <lispy> there you go
19:39:17 <ddarius> ?faq Can Haskell create logical paradoxes?
19:39:17 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:26 <Associat0r> Dwaylu very early
19:39:30 <totimkopf> ?fag Can Haskell get me a girlfriend?
19:39:31 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:32 <totimkopf> oops
19:39:35 <totimkopf> ?faq Can Haskell get me a girlfriend?
19:39:36 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:39 <totimkopf> hey!
19:39:42 <ski> > fix not
19:39:51 <Philonous> I don't see how you could learn assambler, since there is no such thingg than "assambler". It is totally dependent on the machine you a re programming for.
19:39:57 <moozilla> ?faq Can Haskell keep totimkopf from getting a girlfriend?
19:39:58 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:58 <lambdabot>  thread killed
19:39:59 <totimkopf> now i know not to trust lambdabot's faq
19:40:06 <lispy> > let bugs = const "Done."
19:40:06 <lambdabot>  Parse error at end of input
19:40:07 <lispy> > fix bugs
19:40:09 <lambdabot>   Not in scope: `bugs'
19:40:15 <lispy> ?et bugs = const "Done."
19:40:15 <lambdabot> Maybe you meant: ft let
19:40:22 <lispy> ?/et bugs = const "Done."
19:40:23 <lambdabot> Defined.
19:40:24 <lispy> gah
19:40:29 <lispy> hey that worked
19:40:29 <ski> (:
19:40:32 <totimkopf> ?faq Can Haskell make games?
19:40:33 <lambdabot> The answer is: Yes! Haskell can do that.
19:40:34 <lispy> > fix bugs
19:40:36 <lambdabot>  "Done."
19:40:43 <totimkopf> i'd like to see somebody write a game in Haskell
19:40:45 <lispy> man, lambdabot in so efficient
19:40:50 <lispy> ?where frag
19:40:51 <lambdabot> http://www.haskell.org/haskellwiki/Frag
19:40:53 <moozilla> totimkopf: there's a 3d game
19:40:55 <lispy> totimkopf: how about quake 3 ^^
19:40:58 <moozilla> yes that one :P
19:41:00 <totimkopf> wow!
19:41:04 * totimkopf is in shock
19:41:13 <Philonous> :t fix
19:41:14 <lambdabot> forall a. (a -> a) -> a
19:41:20 <lispy> ?faq Can Haskell implement Quake3?
19:41:21 <lambdabot> The answer is: Yes! Haskell can do that.
19:41:36 <ski> @arr
19:41:37 <lambdabot> I want me grog!
19:41:48 <ddarius> ?faq Can Haskell continue rotting in his grave?
19:41:49 <lambdabot> The answer is: Yes! Haskell can do that.
19:41:57 * lispy snickers
19:42:13 <totimkopf> okay, i suppose this will be the most important question.... 'When is Haskell not appropriate?'
19:42:28 <Philonous> At a wedding.
19:43:00 <totimkopf> i meant what problems/projects are not appropriate for Haskell
19:43:05 <lispy> totimkopf: when a boss says not to use it
19:43:20 <lispy> totimkopf: that one has happened to me before
19:44:09 <totimkopf> of all the languages in all paradigms, where does Haskell rank in speed?
19:44:12 <lispy> Also, we need a better COM library.  At the moment I wouldn't recommend anyone do COM in haskell using the existing library.
19:44:35 <lispy> totimkopf: look at the programming language shootout, they handle that question not us
19:44:39 <Philonous> totimkopf: A language as itself doesn't have any "speed", implementations do.
19:44:48 <dmwit> boring
19:44:52 <lispy> totimkopf: but, it seems haskell is quite competitive at least after optimizing and using GHC
19:44:52 <totimkopf> Philonous, that's what i meant
19:45:00 <dmwit> Haskell is between C and Python, for a very, very rough estimate.
19:45:09 <ddarius> lispy: Given a choice, would you recommend anyone do COM period?
19:45:11 <solrize> atp, thanks (for the 99 problems further up, which i jus tsaw)
19:45:18 <Philonous> "real programmers can write fortran programmes in any language"
19:45:22 <dmwit> Usually, it is between 1-2x slower than C, and in some cases faster.
19:45:25 <ddarius> dmwit: Except for when it's faster than C and slower than python.
19:45:36 <dmwit> ddarius: Naturally.
19:45:39 <lispy> ddarius: sometimes going with a COM interface is easier than reimplementing the functionality you want to get at :)
19:45:44 <dmwit> ddarius: Hence the "very, very rough" part.
19:46:02 <totimkopf> wow i had no idea python would be comparable to Haskell
19:46:08 <winter> Lazy evaluation must be a hinderance for some domains
19:46:11 <totimkopf> i always thought interpreted languages would be slow
19:46:22 <lispy> I like that intel fortran isn't the fastest implementation on the shootout given the default weights
19:46:42 <lispy> totimkopf: yes, which is why haskell is usually fster than python
19:46:51 <Philonous> Maybe they just don't care about the shootout.
19:46:53 <dmwit> totimkopf: A bad programmer can write slow code in any language, even Haskell.
19:47:04 <totimkopf> yeah
19:47:05 <totimkopf> that's true
19:47:06 <ddarius> > 1 + 1 + fix id
19:47:07 <lispy> dmwit: good programmers can do it too
19:47:22 <lambdabot>  thread killed
19:47:51 <winter> question is, how much does a language encourage or hinder bad programming practices
19:48:01 <dmwit> lispy: I never claimed otherwise.
19:48:29 <lispy> dmwit: right, I was just thinking it's something I do a lot ... worry about efficiency when I get to a solution
19:49:11 <ddarius> lispy: Maybe you are not a good programmer.
19:49:33 <lispy> One thing I really appreciate about GHC is that you don't need to use a lot of crazy low level built-in types and operators to get clever optimizations.
19:49:35 <joed> Heh
19:49:52 <lispy> ddarius: good point
19:50:24 <lispy> Using those things can in some cases get you even better optimizations but it's rarely needed
19:50:41 <joed> ddarius: Funny point in a JVM context, I know this is not the same, but still a 'Heh' in contextual comparisons.
19:52:22 <|Steve|> I think that Haskell needs a published style guide for its formatting and vim needs to have defaults set up for that. I'm never happy with what I get in vim for haskell.
19:52:49 <lispy> |Steve|: there is a style guide on the wiki
19:52:56 <lispy> pretty extensive iirc
19:52:58 <|Steve|> There is? Link?
19:53:17 <|Steve|> I admit I haven't looked too hard, but I've never seen consistent style.
19:53:40 <lispy> good luck finding anything on the wiki, rarely works in google and the wiki search is mediawiki's
19:54:23 <ddarius> @google site:haskell.org inurl:haskellwiki style guide
19:54:27 <lambdabot> http://www.haskell.org/haskellwiki/Yhc/Javascript/Programmers_guide
19:54:27 <lambdabot> Title: Yhc/Javascript/Programmers guide - HaskellWiki
19:54:36 <ddarius> @google site:haskell.org inurl:haskellwiki "style guide"
19:54:40 <lambdabot> http://www.haskell.org/haskellwiki/Help:Editing
19:54:40 <lambdabot> Title: Help:Editing - HaskellWiki
19:54:49 <dmwit> two strikes
20:16:51 <bos> @seen dons
20:16:52 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 2h 40m 22s ago.
20:19:05 <dons> bos!!
20:19:18 <dons> great work!
20:19:23 <hackage> Uploaded to hackage: HStringTemplate 0.3.2
20:19:34 <bos> i am thrilled.
20:19:51 <dons> his enthusiasm seems even greater than i'd thought.
20:20:01 <bos> no kidding!
20:20:10 <bos> that totally rocks my night.
20:20:14 <dons> :)
20:23:30 <wolgo> What does the $ operator do
20:24:56 <Eelis> @src ($)
20:24:57 <lambdabot> f $ x = f x
20:25:13 <wolgo> Oh okay
20:25:46 <dons> heh
20:26:08 <wolgo> Is it just used to make code look cleaner?
20:26:16 <dons> yep
20:26:19 <lispy> wolgo: not always
20:26:22 <lispy> :t zipWith ($)
20:26:24 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
20:26:28 <dons> > map ($3) [(+1), (*4)]
20:26:30 <lambdabot>  [4,12]
20:26:39 <solrize> wolgo, yeah, it has lower precedence than other operators, so    f g h $ x y z   is the same as (f g h) (x y z)
20:26:47 <dons> lispy, well, it strictly is used to make code cleaner, right.
20:26:52 <dons> since you could live without it.
20:26:59 <lispy> ah
20:27:04 <solrize> wolgo it is syntax sugar
20:27:13 <lispy> :t zipWith (\x y -> x y)
20:27:14 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
20:27:24 <dons> :t zipwith (id :: (a -> b) -> a -> b)
20:27:43 <dons> that's odd.
20:27:45 <lispy> ?pl \x y -> x y
20:27:46 <lambdabot> id
20:27:55 <wolgo> functional programming is odd
20:27:59 <wolgo> hahah
20:28:07 <dons> imperative programming is bizarre.
20:28:13 <lispy> :t zipWith (id : (a -> b) -> a -> b)
20:28:20 <dons> :t zipWith id
20:28:21 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
20:28:24 <lispy> :t zipWith (id :: (a -> b) -> a -> b)
20:28:26 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
20:28:28 <lispy> too many typos today
20:28:33 <solrize> :t id
20:28:35 <lambdabot> forall a. a -> a
20:28:38 <wolgo> There are so many things that I see done in one line of functional code.
20:28:44 <dons> yup.
20:28:45 <wolgo> That would be a stupid amount of java
20:28:50 <dons> pure, condensed thought.
20:29:03 <solrize> :t id :: (a->b) -> (a->b)
20:29:04 <lambdabot> forall a b. (a -> b) -> a -> b
20:29:10 <dons> programming in concepts :)
20:29:11 <wolgo> Taking me a while to wrap my head around hahah.
20:29:22 <wolgo> Yeah, that is a great way of explaining it.
20:29:31 <lispy> > fix bugs
20:29:32 <lambdabot>  "Done."
20:29:37 <solrize> hahaha
20:29:48 <solrize> :t bugs
20:29:49 <lambdabot> forall b. b -> [Char]
20:30:05 <solrize> > bugs
20:30:07 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
20:30:07 <lambdabot>                ...
20:30:28 * wolgo goes back to reading Elements of ML programming.
20:31:06 * lispy goes back to testing darcs
20:31:26 <dons> solrize: haha
20:31:36 <dons> wolgo: you should try Real World Haskell instead :)
20:53:40 <wolgo> @src map
20:53:40 <lambdabot> map _ []     = []
20:53:40 <lambdabot> map f (x:xs) = f x : map f xs
20:57:52 <bwr> i am thinking of buying a netbook so i can carry ghci around with me :/
20:59:40 <solrize> philippa has ghc on an asus eee
21:06:57 <lispy> and it sounded like you could put ghc on the open moko too
21:07:46 <avegas_> greetings haskellers
21:07:52 <lispy> greetings avegas_
21:08:25 <avegas_> while trying to compile something roughly like this
21:08:28 <avegas_> http://hpaste.org/9655?
21:08:39 <avegas_> but with the indentation fixed, and
21:08:49 <avegas_> import Data.List added
21:08:53 <avegas_> I get the complaingt
21:09:12 <avegas_> StructuredDataHandler.hs:8:29: Not in scope: `BStr.splot'
21:09:33 <avegas_> does this indicate that I need to install some package perhaps?
21:09:40 <adu> can two-way updatable views be described/expressed with Arrows?
21:09:53 <erikc_> database views?
21:10:02 <adu> erikc: ya like that
21:10:43 <lispy> avegas_: well, how do you compile it?
21:10:58 <EvilTerran> adu, unfortunately the pure/arr method kinda gets in the way
21:11:00 <lispy> avegas_: if you're using ghc --make, I think you'll need -package bytestring
21:11:11 <lispy> avegas_: if you're using cabal you can specify bytestring in there
21:11:12 <adu> EvilTerran: hmm
21:12:36 <adu> avegas: does "ghc-pkg --list" show "bytestring"?
21:12:51 <avegas_> was using --make
21:12:53 <erikc_> hrm, i dont know too much about the view update problem aside from 'its hard', and piece's lens presentation
21:12:58 <avegas_> will try with -package
21:13:56 <adu> avegas: could you possibly mean "split" instead of "splot"?
21:14:16 <avegas_>  binary-0.4.1, bytestring-0.9.0.1, cairo-0.9.12.1,
21:14:31 <avegas_> dunno, I'm just following this guys tutorial
21:14:37 <newsham> hi
21:14:40 <adu> avegas: they probably meant "split"
21:14:43 <avegas_> Beautiful Code, Compelling Evidence
21:14:46 <avegas_> lots of typos
21:15:00 <avegas_> he left some parens off of ! as well
21:15:13 <dons> avegas_: if only it was published as a wiki first.
21:15:13 <newsham> good argument for literate code
21:15:20 <dons> so people could comment paragraph-by-pargraph, fixing things.
21:15:35 <lucca> hm, has anyone looked into opengl on osx without using x11?  I'm investigating the carbon/agl/coregl apis currently
21:15:37 <newsham> dons: someone should do a whole book like that
21:16:46 <adu> newsham: isn't that what "Real World Haskell" is doing?
21:16:51 <avegas_> dons, once I've got things to work, I'll send the guy an email
21:17:08 <dons> newsham: yeah, that's a good idea.
21:17:24 <dons> oh wait. that *is* a good idea.
21:17:52 <avegas_> now, in
21:17:53 <avegas_> http://hpaste.org/9675
21:17:57 <newsham> adu: the book dons is cowriting?
21:18:20 <avegas_> I'm getting a possible indent error on the line with stdev =
21:18:53 <newsham> avegas: no closing paren on va =
21:19:24 <hackage> Uploaded to hackage: dnsrbl 0.0.2
21:22:59 <kaspyanand> hi
21:23:36 <kaspyanand> in prelude i want to export command output to a text file-how can i do it,on windows?
21:24:50 <kaspyanand>  in prelude i want to export command output to a text file-how can i do it,on windows?
21:25:19 <newsham> main = doStuff >>= writeFile "output"     ?
21:26:27 <adu> newsham: dons: are you?
21:27:12 <newsham> I am not.  dons is.
21:27:15 <adu> kaspyanand: are you talking about haskell?
21:27:23 <kaspyanand> yes
21:27:40 <dons> :t writeFile "foo" "my data"
21:27:41 <lambdabot> IO ()
21:27:45 <newsham> see authors list: http://www.amazon.com/Real-World-Haskell-Bryan-OSullivan/dp/0596514980
21:27:53 <lambdabot> http://tinyurl.com/66w5qb
21:28:25 <dons> hey, what a weird cover.
21:28:27 <dons> is that a bug?
21:28:38 <newsham> yah, looks like a bug.
21:28:41 <newsham> quickcheck?
21:28:51 <dons> needs type checking.
21:29:02 <adu> kaspyanand: you might be talking about runProcess
21:29:11 <adu> kaspyanand: http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
21:29:15 <lambdabot> Title: System.Process, http://tinyurl.com/2uqkc5
21:29:28 <newsham> whats with they "buy-with" anathem?
21:29:34 <moozilla> ?where Roll Your Own IRC Bot
21:29:35 <lambdabot> I know nothing about roll.
21:29:45 <moozilla> ?where "Roll Your Own IRC Bot"
21:29:46 <lambdabot> I know nothing about "roll.
21:29:49 <dons> "After Viewing This Item .. .5% buy
21:29:50 <dons> Programming Erlang"
21:29:50 <adu> dons: wow, sometimes I forget how amazing you are ;)
21:29:51 <dons> boo!
21:29:56 <moozilla> ?where IRC
21:29:57 <lambdabot> I know nothing about irc.
21:30:02 <dons> adu, yay!
21:30:44 <moozilla> is there a haskell subreddit?
21:30:45 <avegas_> now, with this
21:30:47 <avegas_> http://hpaste.org/9676
21:30:53 <dons> moozilla: there's just reddit.
21:30:53 <avegas_> I get :
21:31:17 <dons> moozilla: search for 'haskell' should turn up some things.
21:31:28 <moozilla> dons: I get my haskell fix by reading stories you've submitted usually :P
21:31:30 <avegas_>     Couldn't match expected type `(a, a, a, a, a)'
21:31:40 <dons> moozilla: me too :)
21:31:48 <moozilla> heh
21:31:49 <adu> lol
21:31:51 <avegas_>    against inferred type `(a, a, a, a, a, a)'
21:31:53 <newsham> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:31:55 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
21:32:36 <newsham> why is amazon trying to sell Real World Haskell with a sci-fi type fiction?
21:32:50 <adu> avegas: I don't understand where " foldl' " is defined
21:33:10 <heatsink> adu: in Data.List
21:33:35 <dons> newsham: haskell is from the future.
21:33:39 <Olathe> It's being sarcastic.
21:33:44 <dons> or , confused with secret alien technology?
21:33:51 <dons> this must be fiction, right?
21:34:09 <adu> avegas: thats because there are six parts in the tuple after "finish (...) = (1, 2, 3, 4, 5, 6)"
21:34:42 <newsham> http://bendiken.net/images/misc/lisplogo_fancy_256.png ?
21:34:50 <adu> avegas: those six elements either shouldn't be there, or should be put in the other tuples
21:35:14 <dons> newsham: more like http://www.galois.com/~dons/images/cylon.jpg
21:35:19 <newsham> "Fraa Erasmas is a young avout living in the Concent of Saunt Edhar, a sanctuary for mathematicians, scientists, and philosophers, protected from the corrupting influences of the outside "saecular" world by ancient stone, honored traditions, and complex rituals."
21:35:30 <Olathe> Eww...
21:35:32 <Olathe> humans...
21:35:33 <dons> cylons destroy green aliens.
21:35:40 <newsham> i agree.. i dont like humans.
21:36:13 <moozilla> anyone know if there's something like 'eval' in haskell?
21:36:22 <dons> moozilla: what would it do?
21:36:25 <gwern> newsham: reading Anathema?
21:36:33 <moozilla> > 1 + 1
21:36:33 <newsham> "He is the current editor of the Haskell Weekly News." -amazon bio for dons.
21:36:33 <adu> moozilla: "read"
21:36:35 <lambdabot>  2
21:36:36 <avegas_> adu, alternately, I can just add another ,a)
21:36:51 <moozilla> dons: like lambdabot's >
21:36:53 <adu> avegas_: no because pairedTTest expects a 5-tuples
21:36:54 <dons> newsham: yeah, i need to change that.
21:36:57 <dons> it's a year out of date.
21:36:59 <newsham> gwern: no, but amazon's real world haskell page is bundling anathema as a special
21:37:09 <gwern> interesting
21:37:24 <gwern> although I suppose most haskellers like stephenson
21:37:24 <dons> haskell hates humans too.
21:37:27 <dons> their brains are weak.
21:37:43 <newsham> good thing the compiler checks theorems.
21:37:45 <adu> avegas_: easier to remove one of those, not sure which one, I'd guess 'stddev' tho
21:37:47 <heatsink> dons: haha
21:37:48 <bos> i like middle-period stephenson, prior to the last 50 pages of each book.
21:37:52 <moozilla> > read "1+2"
21:37:54 <lambdabot>  Exception: Prelude.read: no parse
21:38:16 <gwern> I dunno, I like his frantic endings
21:38:48 <adu> > read "Maybe True"
21:38:50 <lambdabot>  Exception: Prelude.read: no parse
21:39:07 <adu> read "Just True" :: Maybe Bool
21:39:14 <adu> > read "Just True" :: Maybe Bool
21:39:17 <lambdabot>  Just True
21:39:53 <adu> moozilla: it can do quite a few datatypes, but not operators like (+)
21:40:07 <Olathe> > read "A Book" :: Article Noun
21:40:09 <lambdabot>   Not in scope: type constructor or class `Noun'
21:40:11 <moozilla> I'm looking for something like 'eval'
21:40:23 <moozilla> that will evalute a string as code
21:40:27 <adu> moozilla: you might find something like it in the GHC API
21:40:53 <adu> moozilla: but unless GSoC did something about it, it is still mysterious and no one knows about it
21:41:03 <moozilla> oh
21:41:11 <moozilla> well how does lambdabot do it
21:41:21 <adu> the GHC API
21:41:24 <adu> i think
21:41:28 <gwern> with difficulty
21:41:41 <gwern> moozilla: the hint library makes the ghc api much more cuddly though
21:41:52 <moozilla> i see
21:41:57 <newsham> > read "1" + read "2" :: Int
21:41:59 <lambdabot>  3
21:42:50 <Olathe> > (read "+") (read "1") (read "2") :: Int
21:42:52 <lambdabot>        add an instance declaration for (Read (a -> a1 -> Int))
21:42:52 <lambdabot>     In the exp...
21:43:47 <newsham> http://www.cse.unsw.edu.au/~dons/hs-plugins/html/System-Eval-Haskell.html
21:43:50 <lambdabot> Title: System.Eval.Haskell, http://tinyurl.com/lxh4h
21:43:53 <bwr> so if i want to use Data.Set for a custom data type and i want a custom definition of equality, what do i need to do?
21:43:58 <newsham> is what runplugs/lambdabot is using i think
21:44:09 <avegas_> stephenson just wishes he was Tom Pynchon
21:44:15 <lispy> bwr: instance Eq MyType where ...
21:44:19 <heatsink> bwr: instance Eq MyType where x == y = {- definition of equality -}
21:44:24 <avegas_> Gravity's Rainbow pwns snow crash any day
21:44:37 <bwr> thanks!
21:44:44 <avegas_> though, both have cruddy endings
21:45:02 <avegas_> Snow Crash's ending is cartoon deus ex machina drivel
21:45:04 <lispy> bwr: you can tel which type classes a function uses by looking at the signature
21:45:08 <lispy> :t (==)
21:45:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:45:16 <lispy> bwr: see that it says (Eq a) =>  ?
21:45:20 <avegas_> wheras gravity's rainbow is just gross and disappointing
21:45:20 <bwr> yea
21:45:37 <bwr> So does Set need Ord to be defined?
21:45:56 <newsham> i liked the ending of graham hutton's book
21:46:00 <heatsink> :t Set.fromList
21:46:04 <avegas_> what on earth doe
21:46:05 <avegas_> s
21:46:07 <avegas_>   Could not deduce (Ord a) from the context (Floating a)
21:46:11 <avegas_> mean
21:46:15 <avegas_> in reference to
21:46:26 <bwr> i see Ord a all over the place in the docs for Data.Set
21:46:32 <avegas_> http://hpaste.org/9676
21:46:39 <heatsink> avegas, GHC wants to know that a is an instance of Ord.  But all it could find out is that it's an instance of Floating, which is not good enough.
21:46:55 <heatsink> avegas, Try using (Floating a, Ord a) => ... as the class context.
21:47:17 <heatsink> bwr: Yea, Data.Set needs Ord.
21:47:44 <newsham> insert :: Ord a => a -> Set a -> Set a
21:47:48 <lispy> ?tell Cale what would it take to get hoogle working on lambdabot again?
21:47:49 <lambdabot> Consider it noted.
21:47:51 <newsham> indicates that you cant insret something into a list unless its an Ord
21:47:53 <lispy> ?hoogle id
21:47:53 <lambdabot> A Hoogle error occurred.
21:47:56 <adu> hmm
21:48:02 <adu> "Nothing indicates typechecking failed"
21:48:11 <newsham> err.. into a Set.
21:48:20 <adu> shouldn't this be: "Nothing" indicates typechecking failed
21:48:58 <lispy> > fail "This type checks" :: Maybe Int
21:49:00 <lambdabot>  Nothing
21:49:44 <adu> interesting
21:49:58 <avegas_> hmm, methings I should just roll with the Gentle Intro to Haskell to 98 and shelve this tutorial
21:50:20 <adu> avegas_: ya! go for  hello world!
21:50:34 <lispy> avegas_: go for real world haskell
21:50:38 <lispy> ?where rwh
21:50:38 <lambdabot> is http://www.realworldhaskell.org/blog/
21:50:44 <newsham> if the gentle introduction to haskell was gentle, it wouldnt have "gentle" in its title
21:50:52 <lispy> get your fp on
21:53:32 <jberg> started reading a bit in rwh an hour ago or something, so far i found it really good
21:53:33 <lambdabot> jberg: You have 1 new message. '/msg lambdabot @messages' to read it.
21:53:37 <avegas_> I can probably roll with gentle, but I'll check out rwh
21:53:55 <jberg> i started at the monad chapter and it explained it much better than anyone else imo
21:55:07 <lispy> go go programmable semicolon!
21:56:19 <lispy> > do x <- [1..3]; y <- "abc"; return (x,y)
21:56:21 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:56:30 <moozilla> the best monad explantion is in 'tackling the akward squad' imo
21:56:46 <lispy> moozilla: that's a very good IO monad tutorial
21:56:47 <newsham> rwh is great all around.  there are some tutorials that offer a slower intro (if you're into that), but i dont think anything with the same depth.
21:59:12 <bshanks> hi all
22:00:31 <bshanks> Q: if i am within a "do" construct, and i evaluate the statement a <- b, but b is a failing monad... is there a way to "catch" this within the "do" construct, or must my whole "do" return failure?
22:01:01 <heatsink> bshanks: It depends on the monad.  Which monad are you interested in?
22:02:17 <heatsink> bshanks: You can do it in IO and some instances of MonadPlus.
22:02:30 <heatsink> Hey, that's a good slogan.
22:02:33 <heatsink> Haskellers do it in IO.
22:02:55 <lispy> ?quote unsafePerformSex
22:02:56 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
22:03:08 <heatsink> :)
22:03:11 <bshanks> i'm trying to find a concise way to deal with user input in HAppS. The way I've seen in some blog posts is to use "look", which I gather is a HAppS fn that returns RqData, which I think is a ReaderT
22:03:56 <bshanks> for example, in http://hpaste.org/5958
22:04:16 <bshanks> they use "mplus" to assign default values when no value is actually there
22:04:29 <lispy> :t mplus
22:04:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:04:48 <lispy> ?instances MonadPlus
22:04:49 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:04:53 <bshanks> i'm hoping to replace     fromData = liftM3 NewUserInfo (look "username")
22:04:53 <bshanks>                (look "password" `mplus` return "nopassword")
22:04:53 <bshanks>                (look "password2" `mplus` return "nopassword2")
22:04:56 <heatsink> It looks maybe-like.  If so, you can use mplus as an error-handling instance.
22:05:01 <bshanks> with a "do" construct
22:05:27 <heatsink> bshanks, do x <- look "password" `mplus` return "nopassword"; return (f x)
22:05:37 <lispy> > Nothing `mplus` return "Foo"
22:05:39 <lambdabot>  Just "Foo"
22:05:46 <lispy> > Just "Bar" `mplus` return "Foo"
22:05:48 <lambdabot>  Just "Bar"
22:05:49 <bshanks> so that i can do further processing on the values without liftM-ing all the time
22:06:34 <lispy> bshanks: what you want to do is possible, I think, but I don't understand your context fully yet
22:08:01 <bshanks> well, what i actually want to do is this:
22:08:32 <bshanks>     fromData =
22:08:32 <bshanks>         liftM3 TaghogMetaQuery
22:08:32 <bshanks>                    (toMaybe (look "user"))
22:08:32 <bshanks>                    (liftM (fromMaybe "filternet") $ toMaybe $ look "algorithm")
22:08:33 <bshanks>                    (liftM TaghogQuery $ liftM (fromMaybe "worthreading") $ toMaybe $ look "tags")
22:08:34 <lispy> fromData = do uname <- look "username"; pass <- look "password" `mplus` return "nopassword"; pass2 <- look "password2" `mplus` return "nopassword2"; return NewUserInfo uname pass pass2
22:08:35 <bshanks> fromMonad :: MonadPlus m => b -> (a -> b) -> m a -> m b
22:08:37 <bshanks> fromMonad def f xx = do {x <- xx; return $ f x} `mplus` return def
22:08:39 <bshanks> toMaybe :: MonadPlus m => m a -> m (Maybe a)
22:08:41 <bshanks> toMaybe = fromMonad Nothing Just
22:08:50 <bshanks> but what i just pasted is horribly ugly. what it is doing is:
22:09:02 <bshanks> (1) "user" gets turned into a Maybe
22:09:27 <bshanks> "algorithm" gets turned into either itself, or (if failing) default value "filternet"
22:10:14 <bshanks> "tags" gets turned into either itself, or (if failing) default value "worthreading" -- and THEN the function "TaghogQuery" is run on the resulting value
22:11:01 <lispy> :t maybe
22:11:02 <bshanks> so i'm hoping that i can do all of this from WITHIN a do {} block -- because otherwise i'll have to have a bunch of liftMs
22:11:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:11:05 <heatsink> :t toMaybe
22:11:29 <lispy> bshanks: well, did you see my example do block from your first example?
22:12:56 <lispy> bshanks: also, your fromMonad seems like you're trying to generalize the maybe function
22:13:02 * lispy wonders where bshanks went
22:13:16 * lispy is impatient tonight :)
22:14:01 <lispy> is there a general zippers library or do people just like applying the concept?
22:14:01 <bshanks> lispy: (sorry i am slow let me look at it)
22:14:34 <lispy> ?src liftM3
22:14:35 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
22:14:48 <bshanks> lispy: ah, i see, the answer is just to use "mplus" itself within the "do" block
22:14:53 <lispy> bshanks: I just translated the liftM3 source into the example
22:15:06 <lispy> bshanks: right
22:15:19 <lispy> bshanks: also notice the similarity between 'maybe' and 'fromMonad'
22:15:55 <lispy> your fromMonad stays in the monad where as maybe leaves it
22:16:00 <lispy> but that's it
22:16:23 <Axman6> is it bad that i read yourMonad as yourMum?
22:16:27 <Axman6> -_-
22:16:36 <lispy> Axman6: depends, is she hot?
22:16:50 <bshanks> lispy: thanks
22:17:08 <Axman6> lispy: you tell me >_>
22:17:22 <EatenByGrues>  /join #dzen
22:17:25 <EatenByGrues> wow
22:17:25 <bshanks> so, " pass <- look "password" `mplus` return "nopassword"" ===  pass <- (look "password" `mplus` return "nopassword")
22:18:00 <lispy> bshanks: yeah, the brakets won't be needed
22:18:16 <bshanks> for some reason i thought i wasn't allowed to operate on "incoming" monads to the right of the <- operator. but i guess you can, thx
22:18:47 <lispy> bshanks: the key here is that mplus returns a monad
22:18:50 <lispy> :t mplus
22:18:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:19:24 <hackage> Uploaded to hackage: dnsrbl 0.0.3
22:20:05 <lispy> it's too bad mplus isn't something like ||
22:20:18 <lispy> pass <- look "password" || return "nopassword"
22:20:25 <lispy> that would look a bit more natural I think
22:20:38 <lispy> > let (||) = mplus in Just 1 || Just 2
22:20:40 <lambdabot>  Just 1
22:20:51 <lispy> :t (||)
22:20:52 <lambdabot> Bool -> Bool -> Bool
22:21:07 <lispy> But, not all instances of mplus would look right with (||)
22:21:16 <bshanks> yeah, i had understood "mplus" but not <-. i had thought that "<- x" was extra-special magic sauce, and that "x" wasn't allow to be an expression (of course, since everything is an expression that's a silly thing to think in itself)
22:21:43 <lispy> sounds like you have it all figured out now though
22:21:57 <lispy> you could even have a case on the othre side
22:22:12 <bshanks> my lord
22:22:13 <lispy> > do x <- case 1 of 1 -> Just 2; return x :: Maybe Int
22:22:14 <lambdabot>  Parse error in pattern at "::" (column 41)
22:22:20 <heatsink> >let (||) = mplus in do x <- [1,2,3] || [4,5,6]; return x
22:22:23 <lispy> well, hard to do that in one line
22:22:26 <heatsink> > let (||) = mplus in do x <- [1,2,3] || [4,5,6]; return x
22:22:28 <lambdabot>  [1,2,3,4,5,6]
22:23:00 <lispy> > do x <- {case 1 of 1 -> Just 2}; return x :: Maybe Int
22:23:01 <lambdabot>  Parse error at "{case" (column 9)
22:23:29 <lispy> bshanks: and on the LHS of the arrow you can do patterns
22:23:59 <bshanks> huh, i didn't know that either
22:24:09 <lispy> > do Just x <- return (Just 1); return 1 :: [Int]
22:24:11 <lambdabot>  [1]
22:24:24 <lispy> > do Just x <- return (Just 1); return x :: [Int] -- that's what I meant to type
22:24:26 <lambdabot>  [1]
22:24:44 <lispy> bshanks: it's because haskell uses the monad laws to transfrom the do-syntax into (>>=) and return
22:24:51 <lispy> oh and lambdas
22:25:09 <lispy> The patterns are where the lambda abstraction starts
22:25:53 <lispy> > do Just x <- return Nothing; return x :: [Int]
22:25:55 <lambdabot>  []
22:26:03 <lispy> Notice that the pattern match failed
22:26:09 <lispy> So we get the empty list instead of x
22:28:22 <|Steve|> > do Just x <- return Nothing; return x :: IO Int
22:28:24 <lambdabot>  Exception: "<IO Int>"
22:29:14 <bshanks> that's neat. i had been thinking that do blocks had to open with a bunch of lines of the form "a <- b" where a and b are single identifiers. but if you can operate on the incoming monad and then pattern match, i suppose you can get a little more work done in those lines
22:36:45 <bshanks> heatsink: thanks for your help also. i initially missed understanding your message " do x <- look "password" `mplus` return "nopassword"; return (f x)" because of my confusion about <-.
22:37:24 <heatsink> np
22:40:37 <adu> bshanks: do you know about arrows?
22:41:22 <bshanks> adu: not really. i looked at a web page once but didn't really grok
22:41:43 <adu> me neither, its something that the syntax hides very well
22:42:18 <adu> like the do notation usually includes lines of the form "var <- func -< input"
22:42:41 <adu> but the "input" is conceptually very similar to just "func input"
22:44:08 <bshanks> adu: i don't quite understand. perhaps an example?
22:44:38 <adu> i don't know anything about arrows, so i couldn't produce an example if i tried...
22:44:46 <adu> don't listen to me :P
22:46:01 <adu> I have a seriously skewed perception of arrows
22:46:16 <adu> which is not based on fact, but wishful thinking
22:46:28 <bwr> for xml would you use haxml or hxt? which is "best"?
22:46:36 <bshanks> adu: :)
22:47:24 <jeffz> bwr, hxq is also an alternative
22:47:51 <bwr> jeffz: thanks
22:48:11 <bwr> i am trying to figure out the defacto
22:48:12 <jeffz> bwr, http://www.haskell.org/pipermail/haskell-cafe/2008-April/041962.html is the blurb
22:48:14 <lambdabot> Title: [Haskell-cafe] ANN: HXQ: An XQuery Compiler/Interpreter for Haskell, http://tinyurl.com/6phzwk
22:48:45 <bwr> cool, thanks
22:48:51 <jeffz> bwr, some also suggest tagsoup for simple things
22:50:25 <adu> for example: if Arrow (->) means (->) a b is an map-like object from type a to type b, then all other map-like objects should be instances of Arrow as well
22:51:05 <jeffz> interestingly, the author of hxq says on his homepage "I have also tried hexpat, tagsoup, HXT, and HaXML Xtract, but they all have space leaks."
22:51:17 <flw> :t 1
22:51:18 <lambdabot> forall t. (Num t) => t
22:51:23 <flw> > :t 1
22:51:25 <lambdabot>   parse error on input `:'
22:51:30 <flw> >:t 1
22:51:48 <flw> :t 1
22:51:49 <lambdabot> forall t. (Num t) => t
22:52:39 <bwr> jeffz: hxq has curious dependencies
22:52:46 <dons> jeffz: that's interesting.
22:52:58 <dons> i wonder if he ever reported this.
22:53:12 <dons> i'm surprised by hexpat, seems a pretty straightforward binding.
22:53:26 <dons> well, it's good we have optoin
22:53:27 <dons> s
22:53:50 <bshanks> adu: i don't know much about it but perhaps others do
22:54:12 <adu> bshanks: which means in my mind there should be instances Arrow Map, Arrow Array, etc
22:58:14 <adu> i just realized something
22:58:34 <heatsink> adu: Good!
22:58:53 <adu> i am in love with FP
23:00:04 <adu> at first i thought it was just Haskell
23:00:39 <adu> but once you got the funk you can't go back
23:02:20 <araujo> Haskell is too bad
23:02:31 <araujo> it makes you hate other programming languages
23:02:40 <adu> it grows on you, and sooner or later, you're rewriting other peoples code in half the LOC, because you can
23:02:50 <adu> indeed
23:03:22 <geezusfreeek> my experiences as well
23:03:22 <Smokey`> LOC yes, time - really depends on your experience with the large amounts of packages available...
23:03:36 <adu> but it spins languages around in wierd ways
23:05:04 <adu> Haskell improves your appreciation of all other functional languages, except Java
23:05:33 <codacola> haskell makes one ahte functional languages
23:06:10 <codacola> well maybe functional languages makes one hate functional languages :P
23:06:12 <adu> because you can say to yourself, wow, I'm allowed to redefine this?!?
23:07:54 <adu> i think FP makes one hate imperative ...
23:08:27 <araujo> way too much i'd say
23:09:28 <adu> hmm, are there any imperative => functional compilers?
23:10:33 <codacola> a C => haskell compiler would be nice., could write my assignments in C and hand them in in haskell :D
23:11:23 <patchwork> okay
23:11:23 <erikc_> C -> Haskell isnt too hard
23:11:39 <erikc_> everything just becomes Storable instances :)
23:11:42 <gwern> erikc_: how would it handle all the pointers and low-level stuff?
23:12:08 <adu> Ptr?
23:12:20 <adu> i'm worried more about va_args
23:12:52 <erikc_> va_args is just storing stuff on the stack according to the abi
23:12:59 <codacola> wonderful, us army is studying mind reading
23:13:16 <adu> codacola: and you just now heard about this?
23:13:26 <codacola> yup
23:13:38 <lispy> ?faq can Haskell read minds?
23:13:39 <lambdabot> The answer is: Yes! Haskell can do that.
23:13:41 <adu> codacola: you should google Tavistock
23:13:45 <lispy> We have the technology
23:16:57 <codacola> adu: later, reading some other funny news for now
23:17:25 <znutar> are there any haskell bindings for opengl 3.0 yet?
23:17:43 <lispy> znutar: I doubt it, but HOpenGL is nice, maybe you could update it
23:17:43 <codacola> wrte one, then there will be
23:17:55 <lispy> znutar: opengl 3 was _just_ released right?
23:17:55 <jeffz> znutar: do you have an opengl 3.0 implementation already?
23:18:36 <znutar> I think 3.0 got released officially on... tuesday maybe?
23:19:09 <codacola> but if it was just released, wouldnt the specs have been out for a wee while already?
23:19:25 <hackage> Uploaded to hackage: non-negative 0.0.2
23:19:25 <hackage> Uploaded to hackage: event-list 0.0.7
23:20:54 <codacola> http://entertainment.slashdot.org/entertainment/08/08/15/1453233.shtml <- interesting read
23:21:00 <lambdabot> Title: Slashdot | "War On Terror" Board Game Confiscated In UK, http://tinyurl.com/6pqbc6
23:22:26 <znutar> codacola: I think they periodically released draft versions of the spec but the final thing came out this week
23:22:57 <znutar> jeffz: not handy, but I could probably get one
23:23:06 <codacola> znutar: yeah but my point was, even fi tis just released the bindings, or at least partial bindings, may have been developed before it was released
23:23:12 <codacola> assuming they knew the specs beforehand
23:23:22 <codacola> if its
23:25:21 <znutar> codacola: They released something or other earlier in the year but I haven't been following the whole process
23:25:46 <codacola> nor have i, ive only known of haskell for 3 months :P
23:25:49 <znutar> no idea if it's just paper specs or partial/preliminary bindings
23:26:59 <codacola> curious,. if someone were to develop a game in haskell, would the general idea be to make a structure which contained all of the variables (of course a growing structure to hold new ones) and apss that around the functions?
23:27:32 <erikc_> apss?
23:27:36 <znutar> pass
23:27:37 <dons> you'd pass around the game state.
23:27:53 <dons> there's quite a lot of haskell games, actually. i'm not sure why. good opengl bindings are part of it.
23:27:54 <codacola> yeah, the structure would be like the game state, youd have the state of everything in it
23:27:58 <dons> i guess speed, a high level of abstraction.
23:28:05 <dons> 21 games on hackage, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Game
23:28:12 <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f
23:28:14 <dons> there's also a video about creating games in haskell.
23:28:20 <jeffz> znutar: sounds unlikely unless you work in video driver development
23:30:14 <erikc_> codacola: using arrows for composable computation blocks would be very handy too
23:30:37 <dons> yeah, there's quite a bit on reactive programming for games
23:30:40 <erikc_> i think Frag used those (applying FRP to games, treating it like a contol system)
23:30:41 <dons> frag's written in that style.
23:31:13 <znutar> jeffz: I work in video chip architecture, so the access isn't the problem so much as finding time to do it :-(
23:32:31 <codacola> erikc_: havent looked at arrow yet, was just thinking about controlling state in haskell the other day, and was wondering if using some kind of datastructure and passing that around with be good or not
23:33:06 <znutar> The main guy from the whole unreal engine team used to have a slide in his talk on what the ideal programming language for games would be titled "So why not haskell?" if I remember correctly.
23:33:27 <erikc_> yea, sweeney's next mainstream language talk at oopsla
23:33:33 <dons> yeah, tim sweeney loves haskell :)
23:34:10 <dons> we should have a quotes section on the front page of haskell.org with stuff like that.
23:34:41 <znutar> But the impression I got was that haskell works out wonderfully for games for most of the code, but C or some other low levelish equivalent is a better fit for things like throwing data at the gpu
23:34:58 <dons> depends on your compiler, i think.
23:35:09 <dons> generating gpu code is a bit of a sweet spot for a data parallel language
23:35:19 <lispy> znutar: that could be.  Or any place where you're really worried about, say, garbage collection slowing you down
23:35:25 <dons> gpus aren't terribly imperative devices. less loops, more parallel arrays
23:35:31 <dons> GC is a bigger issue.
23:35:49 <erikc_> yea, gc is the killer
23:35:51 <dons> then again, so are space leaks.
23:36:01 <dons> so if your pile of C++ is full of funk
23:36:24 <lispy> I've always wondered what it would be like if we had GC accelerator cards like we have gfx accelerators
23:36:52 <dons> hardware support for gc would help, yeah. say, mvars in hardware, lots of hardware threads, and just collect in parallel, concurrently
23:36:56 <znutar> I thought he did things like program generation for the gpus in something haskell-like if not haskell itself.
23:37:21 <dons> there's a bit of hot activity at the moment in dsls , and haskell in general, on the gpu. a few groups working on it.
23:37:31 <dons> since you get hardware map. fold and filter
23:38:56 * codacola wonders when nasa will start using haskell
23:39:03 <erikc_> for most console games, because of the hard memory limit, dynamic allocation is a bad idea anyway
23:39:18 <erikc_> or at least, if you want to dynamically allocate, you really need to be able to handle alloc failures
23:39:52 <znutar> I remember hearing that in Doom 3 or some other recent generation game from iD, in most cases the CPU was the bottleneck and 45% of the cpu time was in the hash table lookup from texture id -> texture surface address in the driver
23:41:09 <dons> codacola: well, they fund a few things. they've a concern about reliability
23:41:15 <dons> which inevitiably leads to theorem proving.
23:41:30 <lispy> yay!
23:41:45 <lispy> I suggested using a theorem proving language like Coq for prototyping darcs
23:41:51 <lispy> At least the patch theory of it
23:41:55 <dons> that's an interesting idea.
23:42:00 <lispy> But, hmm... for my masters stuff I was told to stay away from it
23:42:05 <dons> prototyping in a threorem prover. wouter would agree.
23:42:25 <lispy> Just the patch theory stuff....I mean once we think we have the maths worked out, why not try encoding it in coq?
23:42:27 <dons> yep
23:42:43 <dons> wouter swiestra did some coq proofs for xmonad's core, like that.
23:42:46 <dons> just the internal models.
23:42:50 <codacola> weird. someone is getting less spam. and theyre complaining
23:43:10 <dons> lispy, you need to sit down with a formal methods guy
23:43:26 <lispy> I think the main thing we need to prototype it in coq is some sort of sets.  Actually, we could prototype it in Haskell and treat all of patch theory as values and run QC...we would just explicitly represent contexts instead of implicitly like we do now
23:43:31 <dons> the best programmers and the best formal methods people are rarely the same people.
23:43:43 <lispy> heh
23:43:52 <bwr> when trying to build pointfree with cabal, i am getting:
23:43:52 <bwr> Plugin/Pl/Transform.hs:11:7:
23:43:52 <bwr>     Could not find module `Data.Graph':
23:43:53 <bwr>       it is a member of package containers-0.1.0.1, which is hidden
23:43:53 <dons> but make them collaborate, and you get serious value.
23:44:07 <dons> bwr, hmm. that needs 'containers' in the .cabal file
23:44:31 <bwr> dons: ok, is that something i should have known?
23:44:40 <lispy> dons: yeah, I'm thinking at a minimum, we should do the haskell framework with exists context objects and see if things break down
23:45:02 <dons> bwr, no, it's not your fault.
23:45:07 <dons> the package is broken.
23:45:09 <bwr> ok, thanks
23:45:51 <lispy> interesitng, i type "exists" but meant "explicit" and yet somehow "exists" almost makes sense there
23:48:33 <lispy> dons: I had a question about zippers
23:48:54 <lispy> dons: is there a specific library of zipper utils and classes and instances people are using these days?
23:49:04 <lispy> dons: or is it all ad-hoc define it as you need it?
23:49:41 <lispy> dons: I ask, because in darcs we deal with all kinds of patch sequences, and we (poorly) emulate zippers during patch selection.
23:49:53 <lispy> dons: So...when refactoring should we roll our own or use a library
23:50:08 <codacola> if you have a list, and chop off the head, then pass it to another function, and loop it around and "stuff", is the memory from teh head still used? or does haskell have some kind of garbage collection?
23:50:19 <dons> there's zippers for some types
23:50:23 <dons> specifcally trees, in a library
23:50:51 <erikc_> codacola: if there are no references left to the head, it can be collected
23:50:51 <dons> each data type that's zipperable, should have its own zipper library, actually
23:50:57 <dons> list-zipper, tree-zipper
23:51:02 <dons> like dlist.
23:51:22 <dons> lispy, maybe you can just use data.sequence now.
23:51:24 <lispy> dons: I'm thinking in the case of darcs, since we have custom sequences we may need our own zippers, but I was hoping someone made class Zipper z where ..., and all the nice utility that go with it
23:51:31 <dons> it's a generic list zipper, in some ways
23:51:42 <codacola> erikc_: can be or will be? :P
23:51:47 <dons> oh. not sure if Zipperable makes sense yet
23:51:53 <dons> it's an interesting idea.
23:51:55 <name> anyone using the FTGL bindings on win32?
23:51:58 <codacola> just noticed haskell doesnt have any kind of "free()" function (as far as i know)
23:52:05 <dons> codacola: heh.
23:52:09 <dons> GC is like that.
23:52:15 <dons> ?hoogle free
23:52:16 <lambdabot> A Hoogle error occurred.
23:52:18 <erikc_> codacola: it will be collected...eventually
23:52:18 <dons> bah
23:52:26 <dons> well, almost immediately
23:52:31 <codacola> erikc_: heh, love that word, eventually
23:52:33 <dons> since otherwise lists wouldn't run in constant space.
23:52:56 <dons> :t Foreign.Marshal.Alloc.free
23:52:57 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO ()
23:52:59 <erikc_> different gc implementations will change the meaning of eventually :)
23:53:54 <codacola> eventually :: Int, eventually = illGetToIt()?
23:54:37 <codacola> ugh, id better reread about folding
23:55:11 <dons> photo of xmonad on the openmoko, on xmonad.org (at the bottom)
23:55:15 <|Steve|> > foldr (:) [] [1..5]
23:55:17 <lambdabot>  [1,2,3,4,5]
