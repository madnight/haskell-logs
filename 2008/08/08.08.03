00:00:14 <orzo> ya i have that problem
00:00:18 <orzo> i mix c++ and haskell a lot
00:00:25 <dons> glguy: hscolour hasn't changed much, afaik, but it did change a couple of days ago, so my quick fix was just to bump the depends.
00:00:29 <dons> cabal-install can work it out.
00:00:30 <dolio> Whatever. We all know that fancy type systems resulting in fewer bugs is just a myth overhyped by haskell fanbois on their blogs, anyhow. :)
00:00:42 <orzo> heh
00:00:46 <dainanaki> Who needs types?
00:00:48 <orzo> haskell has its own problems of coruse
00:01:01 <orzo> haskell can create subtle memory usage bugs
00:01:20 <jeffz> haskell doesn't do that, the programmer does
00:01:21 <orzo> you wouldnt thikn it'd be so easy to leak memory in a garbage collected language, but there it is
00:01:28 <dons> leak?
00:01:40 <dons> which would imply something was broken.
00:01:43 <sjanssen> jeffz: Haskell makes it more easily possible than some other languages
00:01:52 <orzo> c doesnt segfault, the programmer does
00:02:08 <orzo> python doesnt  crash on scope errors, teh programmer does
00:02:08 <jeffz> segfaulting is implementation defined behavior
00:02:27 <orzo> haskell makes it easy to use memory poorly
00:02:27 <sjanssen> orzo: I find that memory use isn't a very large problem in practice.  I think you need to attain a certain level of understanding to avoid the space leaks, however
00:02:36 <dainanaki> there ought to be a ghc warning option for memory-consuming functions
00:02:48 <dainanaki> that would be awesome
00:02:56 <dons> what's the argument?
00:03:05 <sebaseba> good for newbies
00:03:36 <dainanaki> It would be basic profiling tool without having to look too hard
00:04:19 <dainanaki> it would be a friendly companion to the heap size option
00:04:39 <jeffwheeler> I'm having trouble with cabal; I can run `cabal configure` without problems, but `runhaskell Setup configure` fails because it can't find (any of) the dependencies, which cabal already knows about.
00:04:44 <jeffwheeler> (This is with Yi.)
00:04:59 <ddarius> The biggest problem is that beginning Haskellers (and even many intermediate ones) program Haskell as if it were a strict language.
00:05:22 <dons> i wonder how common that is now.
00:05:27 <orzo> hm
00:05:36 <dons> awareness of the issue, and how to solve it, is pretty high.
00:05:46 <orzo> which issue
00:05:49 <dainanaki> it's tough not to sometimes because it can take a lot of thought to figure out when thunks evaluate sometimes
00:05:57 <ddarius> dons: There still is very little didactic material.
00:06:06 <orzo> i dont think strict-minded coders are neccessarily related to easy leak makers
00:06:08 <ddarius> Most of the tutorials don't cover it, I believe.
00:06:21 <jeffwheeler> I can't seem to submit the patch because I can't pass the tests, even though `cabal test` seems to work fine; `runhaskell Setup test` fails, of course, for the same reason as above.
00:06:27 <dons> yeah, there's a whole chapter in RWH on it though :)
00:06:45 <sjanssen> jeffwheeler: you can bypass darcs tests by passing --no-test
00:06:47 <orzo> rwh?
00:06:55 <ddarius> dons: RWH was written in the age when awareness of this issue was high.
00:06:59 <sjanssen> jeffwheeler: I don't know about your specific build problem, though
00:07:02 <dons> ddarius: right.
00:07:08 <dainanaki> dons, speaking of which, when can we expect some updated rwh chapters?
00:07:15 <dons> my argument that awareness is much higher now, and thus we see less of a problem
00:07:16 <jeffwheeler> sjanssen: that sounds perfect, although now I'm worried that the tests are actually run
00:07:23 <ddarius> dons: I think Bird's book does cover this though.
00:07:32 <dons> dainanaki: well there's only 3 left to go into beta, so this week or next
00:07:32 <jeffwheeler> sjanssen: I mean, perhaps `cabal test` is just skipping over them; then again, I'm pretty sure I'm safe
00:08:00 <sjanssen> ddarius: hasn't this issue been known for a good while?  I seem to recall SPJ calling certain laziness issues "embarassing" in the hair shirt slides
00:08:08 <dainanaki> dons: what about updates to the already written chapters? will we be seeing those, or will they go directly into the print form?
00:08:15 <dons> they're going into print now.
00:08:24 <dons> hooray, i might add.
00:08:28 <dainanaki> yes indeed
00:08:28 <ddarius> sjanssen: Certainly by more experienced programmers, but the knowledge wasn't spread well.
00:08:33 <dainanaki> i'm purchasing it fo sho
00:08:56 <sjanssen> ddarius: yeah, I think that makes sense
00:09:11 <dons> it's really cool how the online commentry on a per-paragraph basis helps improve the text.
00:09:33 <dainanaki> i've gotta say, the barcode chapter blew me away
00:09:34 <dons> i can't imagine how people write books without that kind of oversight.
00:09:42 * ddarius goes to paste viagra spam in all the comments in RWH.
00:09:49 <dainanaki> heh
00:09:58 <Thomas2> depends how good their editors are?
00:10:11 <jeffwheeler> I had never seen a book do that before Django --- it's a really cool idea.
00:10:23 <dainanaki> dons: where did you go to university for undergrad, masters, etc?
00:10:27 <dons> well, it'll take a lot of editors to make up for the 1000 or so contributors via the web interface.
00:10:47 <dons> dainanaki: UNSW, in Sydney
00:11:03 <dons> i'm sure google can find my unsw site.
00:11:12 <dainanaki> yes
00:11:16 <dainanaki> i'm on it right now
00:11:19 <ddarius> @where dons
00:11:19 <lambdabot> http://www.cse.unsw.edu.au/~dons
00:11:43 <dainanaki> I just wasn't sure which part of your education that covered
00:11:58 <dons> oh, i did my bachelors and phd there.
00:13:12 <dainanaki> i see
00:14:08 <dainanaki> I'm just going into university, but I'm aiming to become a professor, so I've been looking for good masters/phd schools, and you seem like you know your stuff pretty well, so I was just wondering
00:15:09 <dons> heh, well unsw is a good place if you're into haskell, and compiler stuff
00:15:21 <dainanaki> that's exactly what I'm into
00:15:22 <dainanaki> I think
00:15:37 <dainanaki> not sure about compiler stuff yet
00:15:38 <dons> finding the right supervisor is the key thing.
00:16:04 <dons> it's like a job - what company/supervisor do you want to work for.
00:16:23 <dons> aim high.
00:16:52 <dainanaki> One of my soon-to-be profs did his doctorate thesis on the functional stuff in eiffel i believe
00:17:14 <dainanaki> he invited me to do some research work with him
00:17:35 <sebaseba> In the long run, men hit only what they aim at. Therefore, though they should fail immediately, they had better aim at something high. - Thoreau
00:18:04 <dainanaki> very true
00:21:18 <jansz> @pl (\xs -> xs ++ [(sna!!).ip [1,3,1,7,3,9]. map (flip (fromJust .) sn . findIndex . (==))$xs])
00:21:18 <lambdabot> ap (++) (return . (sna !!) . ip [1, 3, 1, 7, 3, 9] . map (flip (fromJust .) sn . findIndex . (==)))
00:25:38 <jeffz> @pl map (\x -> fst x ++ ":\n" ++ (concatMap (\(l,s) -> concatMap (\x -> show l ++ " " ++ x ++ "\n") s) (snd x)))
00:25:39 <lambdabot> map (liftM2 (++) fst ((":\n" ++) . (uncurry ((=<<) . (. ((' ' :) . (++ "\n"))) . (++) . show) =<<) . snd))
00:41:26 <ddarius> @seen conal
00:41:26 <lambdabot> I saw conal leaving #ghc and #haskell 8h 2m 59s ago, and .
00:41:59 <ddarius> @tell conal You may find this paper interesting and it refers to some of your earlier work: http://web.mit.edu/jakebeal/www/Publications/MIT-CSAIL-TR-2007-038.pdf
00:41:59 <lambdabot> Consider it noted.
00:42:12 <orzo> are there gstreamer bindings?
00:43:28 <ddarius> I think so.
00:43:51 <orzo> google points me to an oldish app called minstrel
00:44:11 <orzo> i dont know what state the bindings are in though
00:44:26 <ddarius> @where hackage
00:44:26 <lambdabot> http://hackage.haskell.org/
00:46:03 <orzo> no gstreamer lsited
00:46:39 <ddarius> Apparently Gtk2Hs has bindings (?)
00:46:51 <dons> allbery_b: i see you feel the same.
00:47:05 <ddarius> http://www.haskell.org//pipermail/haskell-cafe/2008-June/044805.html
00:47:07 <lambdabot> Title: [Haskell-cafe] ANN: Gtk2Hs 0.9.13 released, http://tinyurl.com/6c3xdo
00:47:07 <dons> allbery_b: i wish it would die quietly though, since it hurts other projects.
00:47:13 <allbery_b> yeh
00:47:42 <allbery_b> actually I brought it up initially, then ndm agreed
00:48:12 <allbery_b> I think what it comes down to is "communication is essential, and must be clear or you will be buried in a mass of misinterpretation"
00:48:13 <dons> we're having a wake.
00:49:03 <allbery_b> I'm going to use this as an example (my lopsa.org blog collects things that can make or break projects)
00:49:21 <dons> yeah, i've been thinking the same thing.
00:49:45 <dons> it's an example of a lot of interesting project leadership and management points.
00:49:54 <allbery_b> I think it's nto quite as desperate as you made it sound, thoughL  all it would take is an (even meaningless) point release with a better worded announcement
00:50:07 <dons> well, i think its too late now.
00:50:10 <allbery_b> siince 2.0.0 did leave an opening
00:50:42 <allbery_b> I'm not so sure.  yes, ghc is leaving, but that was inevitable:  it
00:50:42 <dons> git has likely won the dvcs disruption, and the brand is hosed.
00:50:53 <orzo> well i want gstreamer and dbus available to hugs
00:50:58 <allbery_b> s been hitting the limits of darcs for quite some time
00:50:59 <dons> only if there was a very strong change in direction
00:51:06 <orzo> i dont think ghc or ghci is available to me on arm
00:52:41 <dons> it has ceded so much ground in the dvcs world, as dvcs have become mainstream.
00:53:18 <orzo> dons, allbery_b, i missed the start.  Are you guys discussing darcs?
00:53:26 <dainanaki> it looks like
00:53:29 <dons> ah well. it takes a lot to succeed in open source. and do it in haskell you have to counter more than just the technological aspects.
00:53:51 <dons> even if the project is perfect, you still have misconceptions to challenge.
00:54:00 <ddarius> dons: Perhaps the biggest problem with darcs is that it hasn't countered the technological aspects.
00:54:13 <allbery_b> we're continuing the discussion from the darcs and haskell-cafe lists
00:54:21 <orzo> i was turned off of darcs because ghc repo was so slow to download
00:54:22 <orzo> heh
00:54:43 <dons> it essentially set the landscape of what dvcs should do -- a prototype.
00:55:00 <dainanaki> i don't have any experience with version control stuff aside from checking things out
00:55:01 <dons> but users care about losing their data, and wasting their time.
00:55:03 <dainanaki> :(
00:55:04 <orzo> assuming git's authors were familiar with it
00:55:17 <dons> git began as a file system backend to darcs.
00:55:38 <dons> people forget the heady days on the darcs lists when darcs-git was hot, linus was working out which vcs to use
00:55:42 <orzo> why did it ditch darcs tehn?
00:55:58 <dons> they were separate projects.
00:56:07 <dons> the git-filesystem got more user interface layres
00:57:10 <dons> but i think we need to move on. darcs will trundle along, but the battle was lost to take over the world. :)
00:57:33 <kfish> meh, re-implement git in haskell
00:57:43 <dons> what's the point?
00:58:06 <ddarius> kfish: The Haskell community isn't the Lisp or Smalltalk community.
00:58:18 <orzo> what do you mean?
00:58:22 <kfish> i didn't mean it like that
00:58:28 * rwbarton remembers finding a bug in git where a recursive function was returning a pointer to memory in its stack frame (shudder)
00:58:32 <kfish> i'd do it just to understand git better
00:58:48 <dons> a model for what the hell git is doing would be a publishable result :)
00:59:13 <dons> but we need to find a new disruptive technology to dive into.
00:59:57 <dons> dvcs --> get the first decent dvcs. perl6 --> get the first decent perl6.
01:00:12 <dons> so what's something hard people are struggling with now?
01:00:24 <Shiruka> what git is doing is it's being a speed demon
01:00:24 <dainanaki> we've already got parallelism
01:00:29 <Shiruka> and speed demons win
01:00:29 <dons> apps on the iphone? writing programs for their 8 core systems?
01:00:33 <ivanm> dons: AI! :p
01:00:47 <dons> console rss readers still suck, i note.
01:00:49 <dainanaki> i was thinking iphone <-> haskell would be great
01:00:50 <ddarius> I don't see too many current prospects for new xmonads or darcs (but then they seemed to pop out of nowhere before), however we may have a few new parsecs coming along.
01:00:57 <Shiruka> the one thing I hear pretty much everyone who prefers git say is that it's so fast and everything else is so slow :-)
01:01:04 <dons> ddarius: yeah, they can appear quickly.
01:01:16 <dainanaki> or how about building obj-c into the ffi?
01:01:22 <dainanaki> that would me *amazing*
01:01:39 <dons> the erlang guys are tossing out interesting distributed database things.
01:01:58 <ivanm> dons: "tossing out" ==  making, or getting rid of?
01:01:59 <dons> network stuff that scales is always hot.
01:02:05 <dons> ivanm: producing.
01:02:10 <orzo> cross compiling is currently pretty messy
01:02:12 <jpcooper> is it not possible to fix darcs at all?
01:02:22 <dons> well, its kinda fixed.
01:02:24 <jpcooper> it seems a bit bad from a PR point of view that GHC is dropping darcs altogether
01:02:34 <ivanm> jpcooper: people normally don't like rewriting software from scratch :p
01:03:02 <dons> the django team did a good job of countering rails.
01:03:14 <Shiruka> jpcooper: sticking with darcs --partial isn't too good for PR either..
01:03:17 <ddarius> dons: How big is #django?
01:03:20 <allbery_b> it can be fixed, it needs someone to step forward and do it.
01:03:29 <jpcooper> Shiruka, partial??
01:03:45 <allbery_b> as for ghc, that was I think inevitable:  darcs will need a *lot* of work to handle ghc, which has been straining it to the limit for several years at least
01:03:53 <Shiruka> did it change in the past few days? I took a checkout of ghc, and the wiki recommended doing --partial
01:04:02 <Shiruka> took a while that way, too
01:04:08 <allbery_b> the wiki has recommended that for a long time
01:04:28 <dons> ddarius: #django is 450.
01:05:29 <dons> so, the next thing.
01:05:43 <dons> conjure was moving for a while. that was an almost project.
01:05:50 <dons> distract could have been another one.
01:06:02 <dons> actually, distributed bug tracking is still an open problem.
01:06:06 <dons> or maybe an un-problem.
01:06:14 <Shiruka> predicting what's going to be big is difficult :-| but how about something smaller that everyone likes, like smallish but useful desktop apps?
01:06:29 <dons> a mutt-like console rss reader
01:06:41 <dons> that did parallel downloads, and was rock solid.
01:06:54 <dons> console apps are niche though.
01:07:04 <dons> project tools are not so much.
01:07:10 <dons> maybe source analysis / tags?
01:07:29 <dons> something in the same sphere as darcs -- developer tools vital to a project.
01:08:07 <dons> a framework for writing parallel apps
01:08:09 <Shiruka> parsing is a strong area for haskell, so something involving it might be good.. can't think of anything useful and interesting off the top of my head, though
01:08:13 <dons> that you could call from python or C
01:08:18 <dons> but whose core was all .hs
01:08:29 <dons> analysing C is a big thing.
01:08:35 <Shiruka> (parser writing convenience that is.. it pretty much sucks for most languages)
01:08:37 <dons> i can see Language.C being pretty big
01:09:04 <dons> its a niche, on its own, but from there we can write a lot of general purpose apps
01:09:17 <Shiruka> (hm, DSLs might be the most interesting area for easily written parsers)
01:09:26 <dainanaki> i'd love to see a compiler written in haskell that compiles c
01:09:40 <dainanaki> that would be interesting, even if not practical
01:09:43 <dons> that has some potential, but still a lot of work.
01:09:56 <dons> a somewhat verifiable C compiler would be immensely valuable.
01:10:24 <dons> a lot of people would pay real, non-internet dollars for that kind of thing.
01:11:03 <dainanaki> mhmm
01:11:05 <dons> in general, whatever is hot, whatever people are interested in doing, there should be some haskell code to do that thing.
01:11:18 <dons> if something you like to hack doesn't have a haskell presence, that's an opportunity
01:11:47 <dainanaki> plus a c-compiler would allow for much easier interfacing with almost all other languages
01:11:54 <Shiruka> specializing DSL->C compilers are cool, but maybe each one is too niche for your average programmer :->
01:12:05 <dons> right.
01:12:29 <dainanaki> what does the average programmer want then?
01:12:38 <dainanaki> less work, obviously
01:12:52 <allbery_b> https://lopsa.org/node/1656
01:12:53 <lambdabot> Title: darcs: a study in communication failure | League of Professional System Administ ...
01:13:38 <dons> allbery_b: it'd be good if you could cite evidence from david that this wasn't his intenet
01:13:42 <dons> intent.
01:14:02 <dons> maybe he was surrendering
01:14:06 <dainanaki> how about a generalized 2d game framework?
01:14:12 <dainanaki> that would be popular
01:14:25 <dons> i'd also remind people of what it used to be like.
01:14:45 <dons> a ground breaking , popular dvcs at times being considered for the linux kernel.
01:15:01 <dons> dainanaki: something based on this new 2d physics library would be fun.
01:15:16 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Hipmunk
01:15:17 <lambdabot> Title: HackageDB: Hipmunk-0.1, http://tinyurl.com/67kdjp
01:15:33 <dainanaki> isn't there another physics library in the works?
01:15:52 <dons> allbery_b: there was also the issue of the multi-month gap and silence since the late 1.0 releases.
01:16:03 <allbery_b> hm, evidence from droundy I don't think I've seen. but I can quote trentbuck
01:16:24 <dons> allbery_b: compare with the 1.0 announcement coverage , http://lwn.net/Articles/109719/
01:16:24 <lambdabot> Title: Development [LWN.net]
01:16:42 <dons> "Project leaders should certainly consider its adoption. "
01:16:51 <dons> "With this proving ground, darcs is expected to soon scale to perform well on the largest projects as well." "
01:17:06 <dons> that's the kind of mindshare that was lost.
01:17:16 <adu> dons: Haskell bindings to CrystalSpace would be cool, too
01:17:36 <dons> lwn was saying hell yeah, this might just work. November 9, 2004
01:17:50 <dons> 4 years later, 2.0 disappears.
01:18:05 <dons> it's over. it was over 3 years ago.
01:18:25 <dons> just look at the energy in that announce, http://lwn.net/Articles/110299/
01:18:25 <lambdabot> Title: Darcs releases 1.0 of refreshing CVS alternative [LWN.net]
01:18:36 <dons> easy, easy, easy, smart.
01:18:43 <dainanaki> i'm kind of surprised darcs shutting down is such a huge deal to the haskell community
01:18:45 <dons> now, tired, slow, don't use it.
01:19:06 <dainanaki> but i can understand too that it helped popularize haskell
01:19:23 <audreyt> dcoutts_: I see that LocalRepo is in. any instructions for me to continue hacking?
01:19:26 <dolio> Darcs isn't shutting down.
01:19:42 <dainanaki> well yes i know not entirely
01:19:45 <dainanaki> but falling apart
01:20:41 <allbery_b> but it's not
01:20:45 <allbery_b> that's the point
01:21:02 <dons> allbery_b: the last paragraph from the lwn article in 2004 would be a good counterpoint, pointing at the energy and hope that was there.
01:21:16 <adu> what's the problem?
01:21:24 <allbery_b> the darcs 2.0 announcement left many of us thinking darcs was shutting down.  the darcs developers are only just discovering that, as we're oinly just discovering that darcs is in fact still a going concern.
01:21:34 <adu> or are we just having a darcs flame war?
01:21:43 <dons> no no. a wake.
01:22:01 <dainanaki> i thought the discussion was about replacing darcs with git for ghc development?
01:22:21 <erikc> hrm, there was a blog post i read with a sort of start to finish how to make a cabal package and get it on hackage, does anyone know what i am might be talking of
01:22:22 <dons> the 1.0 release was awesome, http://lwn.net/Articles/110299/  "this refreshing
01:22:22 <dons> alternative to CVS."
01:22:23 <lambdabot> Title: Darcs releases 1.0 of refreshing CVS alternative [LWN.net]
01:22:25 <dainanaki> due to poor project management?
01:22:30 <allbery_b> it is, but I'm still not convinced that prioves much
01:22:33 <dons> "easy to use as it is powerful"
01:22:42 <allbery_b> no.  ghc is just too *big*.
01:22:55 <dons> "darcs is expected to soon scale to perform well on the
01:22:55 <dons> largest projects"
01:23:08 <dons> that was a hot project.
01:23:08 <erikc> i also dont know how to use cabal to process a hsc on windows where the user is going to need to point to the .h
01:23:14 <allbery_b> it would strain any VCS --- I know svn's fsfs doesn't scale well enough to handle the full ghc repo
01:23:27 <Shiruka> "All because of poor wording and serious miscommunication." <-- I don't think this is really true
01:23:27 <erikc> (i have a wrapper for XInput for xbox 360 controllers)
01:23:39 <Shiruka> git was winning a long time before darcs 2.0
01:23:49 <audreyt> s/any VCS/any VCS but git/ # flame-war mode
01:23:50 <dons> a survey of why projects crash and burn would be interesting. are rails and twitter next?
01:23:52 <dolio> I can't say I got the impression that darcs was dying from that announcement.
01:24:10 <dolio> But maybe that's because I'd heard stuff about its development prior to 2.0.
01:24:17 <dolio> Like the GADT stuff lispy is working on.
01:24:24 <ddarius> Shiruka: There were similar problems before darcs2, though I agree that those weren't the only problems.
01:24:38 <allbery_b> ndm and I did, and it was mentioned last week in the #ghc discussion about what to do with the vcs issue
01:24:52 <dons> "automatically migrate CVS,
01:24:53 <dons> Subversion and Arch projects to the darcs format"
01:24:59 <dons> they wanted to take over the world.
01:25:09 <dons> git wasn't born yet.
01:25:21 <dons> man, for a time travel machine.
01:25:25 <erikc> heh
01:25:32 <Shiruka> git had very good PR - being used by such a high-profile and obviously demanding project as the linux kernel is as good an endorsement as a vcs can get
01:25:39 <dons> branding is key.
01:25:50 <dons> i think there's been a big shift in the darcs brand in the last 4 years.
01:26:02 <dons> erlang's got a good brand too, fwiw.
01:26:10 <dons> brand brand brand.
01:26:18 <Shiruka> use in the industry does wonders for erlang
01:26:27 <adu> i wonder if there is a code_swarm for darcs...
01:26:28 <Shiruka> if it were an ivory tower project, nobody would be interested
01:26:33 <dons> well, no, "industry brand" does wonders.
01:26:47 <dons> like its ericsson's secret sauce.
01:26:49 <erikc> git nailed scalability and performance from day one, even if the implementation is messy and doesnt work on windows
01:26:49 <allbery_b> comments on the current version?
01:27:22 <adu> does anyone know how to make a code_swarm?
01:27:45 <dons> allbery_b: i think really, it was the 4 years from 1.0 to 2.0
01:27:51 <dons> the announce was the nail.
01:28:15 <dons> by failing to address the speed and correctness issues, room was made for competitors
01:28:20 <allbery_b> hm.  I can't really comment much 0n tnat as I haven't been around that long
01:28:27 <dons> given 4 years, an army of monkeys in C can produce something competitive.
01:28:34 <erikc> yup
01:28:40 <erikc> especially once the hard work (how to do it) is done
01:28:45 <dons> right.
01:29:08 <dons> darcs got the ideas out, and there was no competition. the 1.0 announce talks about migrating from CVS -- that's where we all were. no hg, no git, no bzr.
01:29:08 <Shiruka> sometimes that's a good thing though
01:29:38 <ddarius> allbery_b: As the LWN article dons quoted from suggested there was an implicit promise that darcs would soon "scale to perform well on the largest projects"
01:29:38 <dons> but then a long gap, and aggressive compeition -- hard to compete against linus' brand
01:29:42 <Shiruka> write a useful and slow library, and someone will clone it in C, then you just make bindings for your favorite language and get the same features but with higher performance :-)
01:29:55 <ddarius> Taking four years to have an actual start on fixing that is far too long.
01:30:17 <adu> http://www.chimeric.de/blog/2008/0717_codeswarm_darcs_and_dokuwiki
01:30:20 <lambdabot> Title: CodeSwarm, Darcs and DokuWiki [CH!MER!C.de], http://tinyurl.com/66ox6g
01:30:26 <dons> and now the leadership has gone as well.
01:30:30 <ddarius> Shiruka: git isn't faster because it is in C.
01:30:58 <ddarius> Shiruka: -No- vcs works like darcs does.
01:31:44 <dons> git looks kinda like darcs, if you squint, from the command line, which is enough for the users.
01:31:51 <allbery_b> darcs is a constraint solver where the constraints are revisions.  most VCSs are just history trackers
01:31:58 <dons> but internally, the patch model is the triumph, and the fatal flaw.
01:32:09 <dons> since the complexity sucked.
01:32:30 <ddarius> dons: I don't think it's clear that it -had- to be the "fatal" flaw.
01:32:35 <dons> no.
01:32:50 <dons> there's some serious questions about why complexity issues werent addressed.
01:33:21 <dons> if we had a CS person instead of a physicist, would it have been different?
01:33:28 <dons> git had a systems person, so got a filesystem.
01:33:41 <ddarius> The impression from the outside (as in outside the Haskell/darcs community) is that they aren't addressable.  The impression from those closer is that they just weren't address; acknowledged but not addressed.
01:33:52 <dons> right.
01:34:16 <dons> from far enough outside, the implementation language is the unaddressable problem.
01:34:23 <ddarius> dons: I think it would have helped if David was more "programming" oriented.
01:34:52 <dons> yeah. so that's a project direction thing.
01:34:56 <dons> what goals are being set.
01:35:09 <dons> new patch models? or unboxing inner loops?
01:35:19 <orzo> if ghc had a python bytecode backend, it would become usable for a lot of platforms at once
01:35:31 <dons> and a 50x slower :)
01:35:34 <ddarius> orzo: Write one.
01:35:35 <orzo> heh
01:35:39 <adu> orzo: why?
01:35:47 <Guest61322> write once run anywhere doesnt work out in practice anyway
01:35:48 <dons> javascript, dudes!
01:36:26 <orzo> its nto write-once use-anwhere i am after
01:36:42 <orzo> i'd be happy with an arm port, but ...
01:36:42 <rwbarton> any tools to write flash programs in haskell?
01:36:43 <dons> sam lee in here, eh?
01:36:50 <ddarius> The main problem with JVM/CLR/Parrot/etc. backends is that the main reason to write them is to talk to the languages (or rather the libraries of said languages) that are naturally hosted by them.
01:36:57 <adu> I'm more of the write-anywhere use-once philosophy :)
01:37:01 <dons> rwbarton: stepcut wrote an actionscript compiler, rwbarton
01:37:20 <dons> allbery_b: your on reddit, like it or not.
01:37:25 <ddarius> However, the hard part is actually interfacing Haskell with what are virtually always OO languages.
01:37:25 <allbery_b> huh
01:37:43 <chrisdone> morning chaps
01:38:19 <orzo> i interface haskell with oo c++ and it doesnt seem to be an issue for me
01:38:28 <dons> allbery_b: quhuhu is sam lee, but i don't know what nick he uses.
01:38:32 <orzo> and the c++ code is quite OO
01:38:37 <dons> he's a bit of a lurker i guess.
01:38:39 <adu> ddarius: aren't there dozens of papers about that tho?
01:38:58 <dolio> orzo: What C++?
01:39:00 <ddarius> adu: Yes, there are.  None of them satisfactory which is why there isn't just one paper.
01:39:05 <orzo> my c++ heh
01:39:11 <dolio> Ah. :)
01:39:23 <adu> ddarius: i thought OO'Haskell was good
01:39:40 <dons> "I will not write up long user-friendly
01:39:41 <dons> release announcements like this for future darcs releases"
01:39:46 <dons> hah, i'd forgotten that one.
01:39:51 <ddarius> adu: OOHaskell isn't about interfacing with object-oriented languages at all and would be of little use.
01:40:13 <dolio> Which one is OOHaskell? The Oleg one?
01:40:15 <adu> ddarius: o you mean at the linking level and stuff...
01:40:34 <adu> dolio: ya oleg's
01:40:45 <orzo> just make the object an opague type and make a bunch of IO actions taht operate on it
01:41:22 <ddarius> adu: That's not that hard either.  The issue is: How do I write code that uses java.lang.StringBuffer in such a way that the code doesn't look horribly worse than Java code?
01:41:34 <dons> chrisdone: how's the rails killer coming along?
01:41:35 <dolio> That'd be a pretty unsatisfying way to program in Haskell, though.
01:41:41 <chrisdone> ddarius: monads!
01:42:12 <adu> chrisdone: :)
01:42:35 <chrisdone> dons: pretty good; I have a working library (Kibro) and am working on the executable to structure your project for you
01:42:44 <dons> sweet.
01:42:53 <dons> got that code.haskell.org account in place?
01:43:00 <dons> you can start hosting code there, getting feedback.
01:43:11 <chrisdone> dons: I've been looking at some other people's fastcgi projects like some guy's blog, and they seem to replicate kinds of stuff that I'm abstracting, so that's nice
01:43:21 <dons> cool.
01:43:37 <chrisdone> dons: I applied for one (for GOA), how long does it usually take? I might apply again, for this project
01:43:38 <dons> you can also talk to sclv_ who's done a fair bit with fastcgi.
01:43:48 <chrisdone> cool, thanks
01:43:54 <dons> hmm. it can be quite quick. malcolmw does the job.
01:44:41 <vixey> what is the "need-for-typing screed"?
01:44:46 <dons> ddarius: identify and encourage the new young turks who'll produce the next xmonad or darcs :)
01:45:23 <ddarius> dons: None of them needed identifying or encouraging.
01:45:48 <dons> yeah, that's the interesting thiing.
01:46:04 <ddarius> I remember when audreyt first put her page on the Haskell wiki.  I didn't know what the heck it was for a while.
01:46:08 <dons> they just quietly work away on the project, until it explodes on the scene.
01:46:22 <dons> maybe that's the difference between killer apps and more community infrastructure people
01:47:28 * ddarius is just a pundit.
01:47:34 <dons> talking heads.
01:47:43 <dons> while the soliders are out there doing the work.
01:49:08 <dons> its a funny community,  pundits, generals, soldiers, mavericks, cheer leaders
01:49:17 <dainanaki> confused noobs
01:49:19 <dainanaki> :)
01:49:26 <dons> hangers on, and noobs by the boat load!
01:49:29 <dons> :)
01:49:38 <dainanaki> we need a haskell boot camp
01:49:41 <dons> and the wise council of elders
01:50:01 <dons> writing papers, and rarely intervening in day to day affairs.
01:50:45 <glguy> if only we had more bloggers...
01:50:48 <TSC> Is "cabal update" supposed to take a lot of CPU time?
01:50:52 <adu> dainanaki: that would be funny
01:50:55 <dons> glguy: how's the blog coming along?
01:51:03 <dainanaki> adu: it ought to be an event
01:51:06 <glguy> its coming along slowly
01:51:08 <dons> so what are the bloggers. hmm. the press corp.
01:51:13 <opqdonut> heh yeah
01:51:15 <adu> dainanaki: drop and write me 10 variants of the factorial!
01:51:15 <dons> we have a press corp, and spies.
01:51:16 <dainanaki> adu: it could be recorded video wise
01:51:25 <dainanaki> hahaha
01:51:39 <dainanaki> say it soldier!
01:51:52 <sm> and pows ?
01:51:57 <dainanaki> haskell is a purely functional programming language, sir!
01:52:01 <dons> bulat's a maverick. shapr's a self-admitted cheer leader. :)
01:52:04 <dons> hmm, pows. i wonder.
01:52:05 <dainanaki> I can't heaaaaaar youuuuu!
01:52:10 <adu> dainanaki: I can't here you! drop and write me 10 variants of the fibonacci sequence!
01:52:13 <hackage> Uploaded to hackage: swf 1.0
01:52:13 <hackage> Uploaded to hackage: topkata 0.2
01:52:21 <sm> that'd be me, presently over in scheme-land
01:52:25 <dons> there are some ocaml and scheme people who probably fill like enemy combatants.
01:52:32 <dons> feel.
01:52:35 <dainanaki> and lispers to an extent
01:52:53 <dons> yeah, we occupied their lands, and don't even acknowledge them now.
01:52:56 <adu> dainanaki: lol
01:53:22 <chrisdone> @users
01:53:23 <lambdabot> Maximum users seen in #haskell: 455, currently: 423 (93.0%), active: 19 (4.5%)
01:53:36 <chrisdone> wasn't 500 hit?
01:53:40 <Guest61322> yea
01:53:44 <Guest61322> ive seen over 500 in the last week
01:53:46 <dons> yeah, 507 or something, on tues and weds.
01:53:57 <vixey> idk mostly I hear haskellers slagging off lisp and java and so on
01:54:04 <vixey> more than other languages
01:54:40 <ziman> @pl \f -> 1:1:ap (zipWith (+)) tail f
01:54:40 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
01:54:52 <dainanaki> so how about we write a 2d game framework a la pygame and smash it together with dph or chipmunk?
01:54:53 <adu> dons: are any of the gui libs considered "flagship"?
01:55:02 <dons> java is like the USA, immense, powerful, and wondering why no one likes them.
01:55:08 <Guest61322> im making some 2d game atm haha
01:55:15 <erikc> same here
01:55:17 <erikc> 3d
01:55:19 <dainanaki> haskell is like sweden
01:55:31 <dainanaki> very free, very clean, but kind of obscure
01:55:34 <sm> dainanaki: good idea!
01:55:37 <dons> hehe
01:55:53 <sm> what are dph/chipmunk ?
01:55:58 <dons> and we make fun of the norwegians, i mean, lisp.
01:56:14 <chrisdone> haha
01:56:22 <dons> and the industrias erlangers on our eastern border.
01:56:25 <adu> whoever invented ($) was a genious
01:56:33 <Guest61322> chipmunk is a 2d physics engine
01:56:43 <dainanaki> sm: dph is the data-parallel physics engine under development right now and chipmunk is a ported c/c++ physics engine
01:56:46 <adu> i perfer CrystalSpace
01:56:48 <dons> hmm. a world map of programming languages would be kind of fun.
01:56:51 <sm> ah
01:56:57 <glguy> ziman:
01:56:58 <sm> I can point you to some allegro bindings..
01:56:58 <glguy> > fix (scanl (+) 1 . (1:))
01:56:59 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
01:57:01 <dons> like the xkcd map of the social internet.
01:57:03 <erikc> i want to use haskell as a platform for game prototyping (boxed out levels + all gameplay features) for pitching game concepts and locking down features before serious production
01:57:05 <Guest61322> theres a cool crayon demo with chipmunk
01:57:16 <dons> erikc: isn't that anygma's business model?
01:57:17 <dainanaki> i think we should do it
01:57:18 <dolio> You mean Haskellers make fun of Java and Lisp more than they do of other languages, or Haskellers make fun of those languages more than people who use other languages?
01:57:31 <dons> erikc: do you work at anygma?
01:57:33 <dolio> Because, frankly, lots of people talk about how much Java sucks.
01:57:37 <vixey> the second, nobody slags haskell off because either they don't know it or they like it :p
01:57:43 <erikc> dons: nope, i havent heard of anygma, looking them up now
01:57:51 <Guest61322> haskell seems like you either love it or hate it
01:57:51 <sm> +1 erikc, and s/before/and/
01:57:53 <dainanaki> i don't think java sucks, i just like haskell better :)
01:57:56 <dons> they prototype commercial games in haskell :)
01:58:04 <vixey> Guest61322: Who hates haskell?
01:58:05 <erikc> oh, wow, hot
01:58:10 <dons> http://www.anygma.com/
01:58:10 <lambdabot> Title: Anygma
01:58:14 <erikc> i feel so vindicated now :)
01:58:16 <ziman> glguy, nice :) now i'm going to decipher it and see how it works ;)
01:58:19 <dons> see http://haskell.org/haskellwiki/Haskell_in_industry
01:58:20 <lambdabot> Title: Haskell in industry - HaskellWiki
01:58:26 <erikc> the amount of resistance in the game industry to new languages is stunning, considering the problems they have
01:58:27 <Guest61322> cant name anyone important off the top of my head
01:58:31 <Guest61322> but i see people crying about it a lot
01:58:49 <dons> but lua took off fairly quickly?
01:58:54 <dons> scripting is a gateway
01:59:38 <allbery_b> tcl took off really quick for being one of the ugliest and least friendly programming languages in existence
01:59:56 <allbery_b> like lua, it was scriptable glue
02:00:07 <vixey> lua is awesome
02:00:13 <vixey> (if you are a C programmer)
02:00:34 <dons> glue. risk free and cheap. you just use a bit here and there to patch things up
02:00:42 <dons> and pretty soon your building your whole system from glue and paper.
02:00:45 <adu> Guest61322: Haskell is one of those things that you see, and you love it at first sight. Most people hate things they don't know about. As soon as you know about Haskell, though, you love it. So these people have obviously never seen Haskell...
02:00:51 <erikc> yea, and lua is easy as a language to give to people
02:01:20 <Guest61322> its mainly people who write 2-3 toy programs in an imperative style and then cry that it sucks haha
02:01:32 <glguy> I think that Erlang is the one we need to watch out for
02:01:43 <glguy> it is best poised to steal the functional programming and many core show
02:01:51 <Guest61322> erlang/otp is nice for being such a shitty core lang haha
02:01:53 * araujo thinks Haskell is the one
02:01:55 <dainanaki> haskell's best and worst feature is stuff like this \f -> 1:1:ap (zipWith (+)) tail f
02:01:57 <dons> the brand of erlang is ridiculously positive.
02:02:04 <dainanaki> it hurts noobs heads
02:02:05 <dons> only really the odd grumble about syntax
02:02:14 <dainanaki> even if it is just a fib sequence
02:02:19 <dons> but its attributed amazing powers.
02:02:39 <dons> since handedly solves the desktop multicore crisis :)
02:02:41 <vixey> everybody wants to implement their own telecom system ? :S
02:02:45 * araujo doesn't like erlang that much
02:03:20 <adu> I know nothing about Erlang
02:03:41 <adu> except that it apparently has binary pattern matching
02:03:41 <Shiruka> solves multicore crisis by running twice as fast as C -- given 100x the CPU's
02:03:58 <dainanaki> lol
02:04:06 <Guest61322> they benched at 5x slower than C i think
02:04:09 <Guest61322> roughly
02:04:14 <dons> well, no one can name a desktop app written in erlang. there's network things. and stuff running on clusters, i guess
02:04:14 <Guest61322> still beats python and ruby most likely
02:04:21 <dons> yeah, hipe is a decent compiler.
02:04:25 <Shiruka> I might be exaggerating slightly, but still.. :-P
02:04:41 <glguy> erlang isn't targeting the desktop application market
02:04:51 <glguy> they are targeting the massively scalable, highly reliable one
02:04:54 <dons> no, but that's what power it has attributed to it.
02:04:56 <Guest61322> yea everything is blocked in IO half the time no doubt
02:05:07 <dons> scalable on a phone switch == solves multicore.
02:05:09 <erikc> sm: are you at all concerned about gc when using haskell for production use in games? that seems to me like the biggest issue
02:05:45 <adu> dons: so why do you say Erlang has attributed power?
02:06:06 <dons> oh, you'll see any random post about the multicore crisis, and someone will say, "Duh, use Erlang"
02:06:16 <sm> erikc: I guess a little, until proven otherwise. I have seen some pretty fluid-looking haskell games though
02:06:26 <adu> shouldn't they be saying "Duh, use Haskell"
02:06:29 <sm> toy 2d stuff
02:06:31 <dons> based on brand, not on i.e. that commenter having written a scalable multicore app in erlang.
02:06:38 <erikc> right
02:06:52 <glguy> idiomatic erlang scales well
02:07:00 <dolio> We should start a counter campaign telling people to use Occam.
02:07:11 <erikc> of course, in the console space theres the general headache that your games have to be compiled with the platform owner's blessed c/c++ compiler
02:07:16 <glguy> I don't know that people are saying you can't do it in haskell or c or whatever
02:07:21 <sm> oh here's another game engine, opengl: http://joyful.com/darcsweb/darcsweb.cgi?r=fungen;a=summary
02:07:22 <lambdabot> Title: darcs - fungen
02:07:33 <dons> glguy: do we know that?
02:07:47 <dons> there was a bit of a scandal when hmm, yarv wrote an erlang twitter
02:07:47 <glguy> that they aren't bashing on Haskell?
02:07:49 <dons> but forgot to scale it.
02:08:55 <glguy> erlang has concrete scaling success stories
02:08:59 <dons> yep.
02:09:05 <glguy> I listened to an interview with the guys from powerset
02:09:08 <glguy> on the train last week
02:09:15 <glguy> they were talking about some of their projects
02:09:23 <glguy> it was exciting to listen to
02:09:31 <dons> do we know of any sites running on erlang?
02:09:33 <dons> for example.
02:09:49 <glguy> I know about the search stuff that powerset is doing now :)
02:10:08 <glguy> I don't know of any massively scaled Haskell stories yet
02:10:11 <Guest61322> one of amazons services uses erland or something i think
02:10:15 <Guest61322> erlang*
02:10:29 <dons> right, its chosen as the tool for scaling, that's the main focus.
02:10:31 <audreyt> facebook chat?
02:10:31 <dainanaki> we need something awesome
02:10:41 <dons> audreyt: yeah, facebook chat and ejabberd.
02:10:51 <dainanaki> can somebody get to work on a haskell library that cures cancer?
02:11:19 <Shiruka> haskell already cures the cancer of the semicolon
02:11:24 <Guest61322> haha
02:11:40 <adu> dons: if we are talking about counter advertisement I could hand out flyers at my university
02:11:46 <dons> heh
02:11:55 <dons> i would just like more stuff written. more success stories.
02:12:00 <glguy> dons: I could try to motivate people to use Haskell for their projects where I work
02:12:07 <glguy> get it some commercial exposure
02:12:09 <dons> let's try that, glguy
02:12:29 <dons> i'll see if eric at my work is interested. he likes new thiings.
02:12:30 <glguy> or maybe I could advocate half use Haskell , and advocate to the other half to use erlang
02:12:34 <Guest61322> think you need to screen for open minded people
02:12:39 <audreyt> dons: in the early days (last century) http://www.onlamp.com/pub/a/oreilly/perl/news/success_stories.html was very effective
02:12:41 <lambdabot> Title: O'Reilly -- Perl Success Stories, http://tinyurl.com/64lzzn
02:12:41 <dainanaki> i'm just going into university, so I can evangelize to the new students
02:12:46 <glguy> and then write a comparative blog summary
02:12:51 <dons> good idea, audreyt
02:12:52 <audreyt> maybe you can convince O'Reilly to run a section for haskell success stories :)
02:13:07 <audreyt> to go with the book
02:13:07 <dons> so that's like CUFP boiled down for the web.
02:13:07 <erikc> wow, anygma sounds great, if i wasnt stuck in vancouver for the time being, i'd apply there :)
02:13:18 <erikc> pretty much exactly what i was going for
02:13:24 <adu> I'm already going to be talking about Haskell at a LUG
02:13:24 <audreyt> dons: yes.
02:13:31 <dons> we could boil down the stories from cufp, into a prominent section on haskell.org
02:13:45 <dons> ok. that's a good thing to do.
02:13:56 <dons> cufp is really internet unfriendly for some reason.
02:14:03 <dons> lots of great stuff, but no one knows about it.
02:14:21 <dons> python.org's got a success thread on the front page.
02:14:25 <sm> erikc, dainanaki: and here's http://joyful.com/darcsweb/darcsweb.cgi?r=hallegro , I guess mahogny won't mind
02:14:26 <dainanaki> what's cufp?
02:14:29 <dons> so that's definitely something we can do. yes.
02:14:39 <sm> both have a couple of nice examples
02:14:55 <dons> dainanaki: success stories in haskell conference :)
02:15:03 <dainanaki> haha
02:15:07 <sm> oops, scratch that last remark, I was thinking of the scheme version
02:15:37 <dons> http://cufp.galois.com/ fwiw.
02:15:38 <lambdabot> Title: Commercial Users of Functional Programming
02:15:41 <dons> full of big names.
02:15:47 <dons> but we've not exploited it.
02:15:47 <dainanaki> sm: that link doesn't work for me
02:16:01 <Guest61322> is Conccurent.Chan performance on par with the other primitives?
02:16:02 <sm> oops, one more step
02:16:21 <dainanaki> dons, can i hit you up in the next few years for an internship at galois ;)
02:16:22 <dons> Guest61322: yeah.
02:16:22 <dainanaki> ?
02:16:28 <Guest61322> cool, thanks
02:16:34 <dons> we need an internship program.
02:16:51 <dons> http://groups.google.com/group/pdxfunc/browse_thread/thread/ad1e5c7575b577b2
02:16:52 <lambdabot> Title: Commercial Users of Functional Programming Workshop Call for Participation - pdx ..., http://tinyurl.com/6n4zpe
02:16:54 <dons> this year's cufp.
02:16:54 <dainanaki> that would be very exciting
02:17:03 <dons> oh, yahoo talking about erlang, glguy
02:17:22 <dons> and Deutsche Bank on haskell.
02:17:29 <dainanaki> Victoria BC!
02:17:33 <sm> dainanaki: fixed
02:18:21 <pozic> Where is ~/.cabal/config documented?
02:18:27 <dons> yeah, "Success stories" on the haskell.org main page, linking to CUFP abstracts works for me.
02:18:38 <dons> audreyt++
02:19:18 <pozic> I want to build the profiling libraries for every package I install too.
02:19:39 <pozic> I already know about the command line options.
02:19:47 <dainanaki> dons: is it on the 22nd through the 24 or is it on the 26th
02:19:53 <dainanaki> i'm finding conflicting info
02:20:03 <dons> dainanaki: ICFP is a set of conferences
02:20:07 <dons> that run over about a week
02:20:09 <dainanaki> ah
02:20:23 <dons> including the haskell workshop, cufp, defun and the erlang workshop, and ICFP itself.
02:20:27 <erikc> Qualified variable in pattern: XInput.vK_PAD_LTHUMB_DOWN -- hrm can someone explain why this isnt allowed / how to work around it?
02:20:42 <dainanaki> what kind of stuff is at the workshops? would i be able to follow?
02:21:10 <adu> erikc: is vK_PAD_LTHUMB_DOWN a member of the XInput module?
02:21:14 <erikc> yes
02:21:24 <dons> well, you can see the program for the haskell workshophttp://www.haskell.org/haskell-symposium/2008/accepted.html
02:21:25 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Accepted Papers
02:21:30 <adu> erikc: so its not a record?
02:21:43 <dons> mostly theory-ish. while cufp is about successes (and failures) http://groups.google.com/group/pdxfunc/browse_thread/thread/ad1e5c7575b577b2
02:21:49 <lambdabot> Title: Commercial Users of Functional Programming Workshop Call for Participation - pdx ..., http://tinyurl.com/6n4zpe
02:21:51 <dainanaki> hmm
02:22:02 <dainanaki> i might need to wait til next year
02:22:05 <adu> erikc: could you post your "import" section?
02:22:20 <dainanaki> i need to get a better handle on theory
02:22:24 <adu> erikc: hpaste.org of course
02:23:13 <erikc> http://hpaste.org/9360
02:23:39 <rwbarton> erikc: you can't match against variables like that.
02:24:14 <rwbarton> erikc: just use when (... == ...) (...)
02:24:24 <erikc> k
02:24:36 <rwbarton> (or if)
02:24:38 <erikc> im curious of the technical reason, if someone knows
02:25:24 <vixey> wouldn't a guard suit better
02:25:31 <vixey> ?
02:25:39 <rwbarton> Imagine 'XInput.vK_PAD_LTHUMB_DOWN' was some other identifier, like 'x'
02:25:44 <vixey> and I think the reason is pragmatic, not technical
02:26:56 <rwbarton> even if there is an 'x' in scope, it gets shadowed by the pattern match
02:27:20 <rwbarton> and it doesn't make sense to have local variables with qualified names
02:27:32 <adu> like instead of XInput.vK_PAD_LTHUMB_DOWN use x | x == XInput.vK_PAD_LTHUMB_DOWN
02:27:34 <erikc> ah
02:28:06 <adu> erikc: make sense?
02:28:08 <glguy> erikc: You only need "do" when you are using do-notation
02:28:46 <adu> glguy: but in some cases its good practice to remind yourself that your in a monad
02:29:51 <vixey> hmm
02:29:58 <vixey> (-> (== XInput.vK_PAD_LTHUMB_DOWN))
02:30:20 <erikc> yup, makes sense, didnt occur to me that it'd interfere with pattern matching
02:30:21 <vixey> oops that wouldn't work
02:30:35 <vixey> ((== XInput.vK_PAD_LTHUMB_DOWN) -> True) -- might?
02:30:51 <adu> erikc: the 'v' is why
02:30:58 <erikc> right
02:31:10 <adu> erikc: if it were 'V' then it be like "type not found"
02:31:17 <adu> hehe
02:31:20 <erikc> vixey: that requires the new view stuff right? is that in 6.8.2?
02:31:25 <vixey> 6.9
02:31:40 <erikc> ah, i think that will work, i dont have 6.9 on windows though :)
02:38:35 <robreim> g'day. If I wanted to compile Haskell programs for the ARM architecture, what would my options be?
02:38:58 <Guest61322> nhc or hugs i think someone said earlier
02:39:26 <Baughn> Hugs is an interpreter, though. To *compile*..
02:39:26 <robreim> Sorry, I should also emphasise that I want my programs to be relatively fast :)
02:39:36 <Baughn> robreim: Say, how much memory does your arm have?
02:39:40 <Beelsebob> robreim: there's been a lot of discussion about getting ghc compiling on ARM on the haskell mailing list
02:39:49 <Beelsebob> I suggest showing your interest and offering any services you can
02:40:18 <robreim> Baughn, I'll figure out how much memory to get after I know what compilation options I have. Right now I'm tending to think speed is more important than small though.
02:41:07 <robreim> Beelsebob, I saw a bit of that. It looks more about getting GHC running under ARM, right? I was wondering if cross-compilation might be easier?
02:41:09 <vixey> just out of interest what kind of programs would you put on this ARM?
02:41:22 <vixey> (what will you write in haskell)
02:41:35 <Beelsebob> vixey: iPhone apps
02:41:36 <robreim> vixey, I'm thinking of a little GPS program or something like that.
02:41:56 <robreim> yeah, like Beelsebob suggests.
02:42:02 <adu> iPhone++
02:42:04 <vixey> ok
02:42:05 <Baughn> robreim: GHC really isn't set up to do cross-compilation, I'm afraid. It can just about do it for bootstrapping purposes
02:42:22 <jeffz> don't iPhone apps have to be written in a sanctioned language using a sanctioned sdk?
02:42:32 <Beelsebob> jeffz: no
02:42:39 <Baughn> jeffz: Not if you use the crack
02:42:43 <adu> jeffz: only on unjailbroken iphones
02:42:51 <Beelsebob> even unjailbroken ones don't need to be
02:42:58 <robreim> Fair enough. And is it prohibitively difficult to set GHC up to do cross-compilation?
02:43:04 <Beelsebob> they just need to be verified by apple as not behaving badly
02:43:05 <jeffz> Baughn: right, that doesn't work if you want to write an app and then sell it on the iphone store thing then :)
02:43:16 <dainanaki> robreim, ghc doesn't work right now for arm
02:43:19 <dainanaki> :(
02:43:24 <Baughn> jeffz: Well, there's no actual rule against using other languages
02:43:33 <adu> robreim: I think you just use ./configure --with-hc-sources or something
02:43:36 <Baughn> jeffz: But it does have to cross-compile; no compilation on the actual phone
02:44:06 <adu> unless you ssh into it
02:44:18 <robreim> adu, thanks, I'll look at that
02:44:24 <adu> I've ssh'd into an iphone once, that was cool
02:44:41 <Beelsebob> adu: I think it's more of a performance thing
02:44:54 <Beelsebob> what would you rather run ghc on -- a 2.8Ghz quad core xeon, or a 412Mhz ARM?
02:45:09 <adu>  /System/Library/Frameworks/CoreSurface.framework really got my attention
02:45:19 <ddarius> adu: I've not seen any code written by experienced Haskell programmers that has unnecessary uses 'do'
02:45:52 <Beelsebob> ddarius: I suspect that's a tautology for me -- you're not experienced if you're using do unnecessarily
02:46:04 <adu> ddarius: well I usually don't overuse 'do' but I was just playing the devil's advocate
02:46:15 <ddarius> Beelsebob: It is usually indicative of that, yes.
02:46:16 <erikc> im not experienced so its ok :)
02:47:06 <ddarius> Can someone kickban Cory?
02:47:12 <Guest61322> im being pecked to death
02:47:26 <Tobsan> what's going on?
02:47:38 <Deewiant> @where ops
02:47:38 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
02:47:40 <Baughn> Trolling is going on.
02:47:40 <adu> Guest61322: get the fly-swatter
02:47:52 * Beelsebob ponders what trolling
02:47:53 <Beelsebob> where?
02:48:13 <Baughn> Beelsebob: CTCP Pings from cory. Be happy you don't see them.
02:48:19 <Beelsebob> ah, I see
02:48:26 <Guest61322> yea ping flood at a slow speed haha
02:48:53 <pozic> Slow admins too...
02:49:48 <Guest61322> is there any way to turn off blocking behavior for Concurrent.Chan
02:50:02 <erikc> is there an hsc2hs convention for modeling C arrays in a C struct?
02:50:05 <ddarius> Guest61322: No.
02:50:09 * sbahra catches Baughn!
02:50:20 <adu> erikc: Ptr a
02:50:21 <sbahra> Baughn, you do work with 3D modeling, yes?
02:50:33 <Baughn> sbahra: Occasionally. I'm not /good/ at it
02:50:38 <Cory> NO U
02:51:04 <sbahra> Baughn, ok. Requirements of this application are not so complex.
02:51:19 <sbahra> s/of this/for this/
02:51:39 <erikc> adu: struct Foo { char bar[8]; } becomes a Storable Data Foo = Foo { Ptr Char } ?
02:51:59 <adu> erikc: oh, I don't know with the 8, maybe PtrLen
02:52:07 <Baughn> ...
02:52:08 <masak> Cory: are you an actual troll? I can't see the CTCP pings either...
02:52:19 <Baughn> masak: Yes. Yes, he is.
02:52:32 <Baughn> erikc: I think you should probably stop listening to adu. ^^;
02:52:45 <sbahra> Baughn, $$$ involved. :-) I currently have other people working on this, but I could make sure to ping you if an opportunity does come up.
02:53:08 <sbahra> masak, " You are being CTCP flooded from Cory, ignoring *!*@71-89-62-104.static.stpt.wi.charter.com"
02:53:08 <Baughn> sbahra: I don't think I have time. Thanks anyway
02:53:22 <ddarius> Baughn: You don't want to run out of dollar signs do you?!
02:53:33 <Baughn> ddarius: My keyboard has an infinite supply
02:53:35 <sbahra> Baughn, lose.
02:53:40 <masak> sbahra: ah.
02:55:19 <adu> erikc: hmm there is no PtrLen, maybe its just Ptr
02:55:37 <Baughn> adu: But it's /not a pointer/
02:55:49 <Baughn> adu: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-340005.9 <-- Here you go
02:55:51 <lambdabot> Title: 5 Marshalling, http://tinyurl.com/yfoy96
02:56:08 --- mode: ChanServ set +o dcoutts
02:56:14 <Baughn> erikc: You too. You'll want the peekArray/pokeArray functions.
02:56:31 <dcoutts> Cory: what are all these pings?
02:57:05 <Baughn> erikc: And the get/set hooks in c2hs
02:57:10 <erikc> right
02:57:34 <Baughn> erikc: No pointers involved. Except the ones haskell makes up on its own.
02:58:26 <pozic> dcoutts: where is the ~/.cabal/config file documented?
02:58:42 <dcoutts> pozic: in the source :-)
02:58:55 <dcoutts> pozic: the plan is for it to become self-documenting
02:59:24 <dainanaki> let's play kick the Cory
02:59:28 <dainanaki> :)
02:59:32 <pozic> dcoutts: is there a way to specify that profiling libraries should always be built?
03:00:34 <adu> erikc: http://www.haskell.org/pipermail/haskell-cafe/2008-May/042613.html
03:00:35 <lambdabot> Title: [Haskell-cafe] FFI: Creating a Storable for a C-struct composed of char arrays, http://tinyurl.com/5mxqu7
03:01:53 <adu> erikc: it seems you have to write your own instance of Storable for things like that
03:02:37 <dcoutts> pozic: library-profiling: True to the end of your .cababl/config
03:04:53 <pozic> dcoutts: and loading Main.hs of cabal-install in ghci does not work. This decreases the hackability of it.
03:05:00 <matthew-_> now then folks
03:05:24 <matthew-_> don't forget, anglohaskell in under a week!
03:06:07 <dcoutts> pozic: use ghci Main.hs -idist/build/autogen
03:06:31 <dcoutts> matthew-_: yay!
03:06:43 <dcoutts> matthew-_: is the list of talks decided?
03:07:02 <matthew-_> yes, I'd say so
03:07:08 <dcoutts> pozic: we use the Paths_ module which is generated by Cabal, so we need that -i flag
03:07:20 <matthew-_> the last slot on the saturday looks like it's going to be unused
03:07:27 <dcoutts> matthew-_: is the unicode bytestring talk going ahead?
03:07:28 <matthew-_> which could potentially give us more hacking time
03:07:39 <dcoutts> matthew-_: or dedicate it to demos
03:08:10 <matthew-_> yeah, I don't see why that talk wouldn't go ahead - I've not heard anything
03:08:17 <matthew-_> it should be 12pm on the Friday
03:08:21 <dcoutts> matthew-_: great :-)
03:08:36 <matthew-_> though it is currently listed as 12am, which might confuse...
03:08:39 <ttt--> is there a page somewhere that explain the difference between data, type and newtype?
03:08:40 * dcoutts is looking forward to that one
03:09:32 <adu> ttt--: http://www.haskell.org/haskellwiki/Type
03:09:33 <lambdabot> Title: Type - HaskellWiki
03:09:47 <ttt--> ok thanks
03:10:02 <matthew-_> now of course, we could rearrange things, and actually hold AH at the GBBF: http://www.camra.org.uk/page.aspx?o=195496
03:10:03 <lambdabot> Title: Great British Beer Festival 2008 - CAMRA
03:10:23 <matthew-_> or just spend saturday night there
03:10:50 <adu> ttt--: although I'm not sure if it will help, but I never use "newtype"
03:11:16 <matthew-_> adu: you should, for performance reasons, when you only have one field and one constructor
03:11:22 <matthew-_> as it'll be completely erased
03:11:35 <EvilTerran> matthew-_, hehe, last i went to both events in quick succession
03:11:40 <EvilTerran> *last summer
03:12:15 <matthew-_> I can imagine. I suspect I will be going earlier in the week, but can usually be pursuaded of the wisdom of a repeat trip!
03:12:17 <EvilTerran> i normally live in glasgow, so i figured, if i was gonna make the effort to travel down to the south of england, i may as well go to as much stuff as possible
03:12:36 <EvilTerran> i don't think i'll be going to either this year
03:12:46 <matthew-_> boo! hiss!
03:12:48 <EvilTerran> i've had more than enough travelling for this fortnight already
03:13:03 <matthew-_> but, it's *only* 7 hours on the train to london!
03:13:13 <EvilTerran> (trains that unexpectedly divert via edinburgh when going between birmingham and glasgow for the lose)
03:13:32 <EvilTerran> (i should've realised that ticket was cheaper for a reason =/)
03:13:39 <matthew-_> lol
03:13:47 <matthew-_> so the unexpected thing was only local to you then ;)
03:13:48 <ttt--> is performance the only reason to use "newtype"? it seems to do the same thing as "data"
03:13:58 <EvilTerran> yeah :(
03:14:09 <EvilTerran> ttt--, it has slightly different strictness semantics
03:14:26 <matthew-_> ttt--: you also can't use GeneralizedNewtypeDeriving magic on anything other than newtype
03:14:58 <Heffalump> EvilTerran: is Glasgow - Kings Cross expensive, then?
03:15:04 <EvilTerran> Heffalump, ?
03:15:16 <EvilTerran> i dunno, i was going from oxford
03:15:28 <Heffalump> ah, right
03:15:46 <EvilTerran> from which trains shouldn't be allowed to take eight hours to get to glasgow >.<
03:15:58 <EvilTerran> (well, there was a 40min change in birmingham)
03:16:01 <Heffalump> it's actually quicker to go via London from Oxford to much of the WCML, IIRC
03:16:52 <EvilTerran> there's a brum->glasgow train that takes 4hr30 that goes up the west coast, and one that takes 6hr that goes via edinburgh
03:18:03 <EvilTerran> but i missed the west coast one last time i was fighting with the national rail website, because i said "no changes after birmingham", and there's apparently a replacement coach service crewe->glasgow at the moment (which counts as a change) due to maintenance work
03:18:23 <sm> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html talks about #def and #ptr where http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html talks about #fun and #pointer. Which is correct ?
03:18:24 <lambdabot> Title: 11.3. Writing Haskell interfaces to C code: hsc2hs, http://tinyurl.com/397xrd
03:18:26 <EvilTerran> but, even with the coach, it's still 90min quicker than going via edinburgh
03:18:30 <EvilTerran> anyway. off-topic.
03:18:32 <chrisdone> hmm. thoughts, chaps? http://hpaste.org/9361
03:18:45 <chrisdone> I'm thinking using continuations for form inputs might be nice
03:18:47 <EvilTerran> ah, some haskell! perfect!
03:18:50 <EvilTerran> OM NOM NOM
03:18:56 <chrisdone> om nom nom^_^!
03:21:32 <chrisdone> for example, the continuation closure is stored in an MVar with some id number, and then a form is displayed with <input type='hidden' name='continuation' value='<id>'> which tells the server where to continue
03:25:56 <BONUS> hmmm i just found an error in the All About Monads tutorial
03:25:56 <BONUS> :]
03:26:42 <BONUS> in the tut it says that class MonadState m s | m -> s but actually  it's class MonadState s m | m -> s
03:35:35 <vixey> http://www.haskell.org/ghc/docs/edison/
03:35:36 <lambdabot> Title: Edison User's Guide* (Haskell version)
03:36:47 <sebaseba> I have a doubt about IO, can someone take a look at this? http://hpaste.org/9362
03:37:27 <sebaseba> *can someone please
03:40:13 <sebaseba> I think my doubt is related to lazy evaluation, though I'm not even sure of that
03:40:20 <newsham> whats the question?
03:40:28 <sebaseba> is the file read once or twice?
03:41:39 <sebaseba> I'm transforming a Map String S to Map String Int, which must be done with IO
03:42:06 <Baughn> sebaseba: Twice.
03:42:21 <newsham> i'm not familiar with Traversable.mapM but I'm assuming its running do1, which reads the file, for each element in your map.
03:42:23 <Baughn> sebaseba: You're running do1 once per element in your map, and there are two elements
03:42:34 <vixey> why don't you just put a print "file is being read" next to where it's read
03:42:41 <vixey> then run the program and count how many times that's printed
03:42:51 <sebaseba> oops
03:42:55 <sebaseba> hadn't thought of that :)
03:43:37 <sebaseba> how could I change that code so that it's "cached"?
03:43:40 <newsham> map1, do1, S1, S2
03:43:44 <newsham> wacky names
03:44:31 <sebaseba> newsham: I simplified some code I have in order to understand what's going on, didn't care to choose meaningful names
03:44:41 <newsham> hmm.. wait.. it should just call the first variant of do1 once
03:44:46 <newsham> since there is only one S1 in your map
03:44:50 <newsham> so it should read it once.
03:44:54 <newsham> add a print to see for sure
03:45:32 <newsham> it should readfile a.txt for S1 "a.txt".  but not for S2 "a"
03:45:50 <maltem> newsham: the second branch recurses
03:45:51 <sebaseba> it prints twice
03:46:12 <newsham> ahh.. yes
03:46:50 <sebaseba> what I'm trying to do is read the file only once when traversing the Map
03:46:59 <newsham> one way to fix your code to read just once is to mapM the thing once transfomring S1 FilePath into S3 String
03:47:12 <newsham> and then traverse again later to chase down the S2's
03:47:48 <sebaseba> newsham: where the S3 String contains the contents of the file, right?
03:47:55 <newsham> data S = Unread FilePath | Ref String | Cached String
03:48:13 <newsham> one tranverse turns all Unread FilePath into Cached String
03:48:20 <newsham> and does nothing else
03:49:36 <newsham> the second traverse could be pure then
03:49:49 <sebaseba> thanks a lot, I think that'll do!
03:50:30 <newsham> ps: since FilePath is String, there's a little room for cheating there :)
03:51:00 <newsham> you did not hear that from me...
03:51:33 <maltem> you could abolish the cheat by using two datatypes, one with file paths, one with read strings
03:52:32 <maltem> of course you can also just everywhere use Either String String :)
03:53:18 <sebaseba> the important thing is to traverse twice, right?
03:53:52 <maltem> yeah, it's the easiest thing to do
03:55:52 <maltem> you could also imagine to keep track of read strings in a seperate map and pass that around, but then you can't simply use mapM anymore
03:56:31 <maltem> so it wouldn't be better I guess
04:00:17 <vixey> not even mapM with stateT ?
04:01:12 <sebaseba> would that make it simpler?
04:01:29 <vixey> what is it?
04:02:10 <sebaseba> stateT
04:02:15 <sebaseba> oops
04:02:20 <sebaseba> I mean, the code
04:03:04 <sebaseba> would mapM with stateT make the code simpler?
04:03:13 <vixey> I don't now what the code does
04:04:29 <maltem> alright, combined with StateT the passing-around can be nicely abstracted
04:04:57 <vixey> Can you give a simple and unambiguous description of what the code should do?
04:05:05 <maltem> but the overall code still won't get simpler then :)
04:05:39 <maltem> sebaseba: StateT is a monad transformer
04:07:29 <sebaseba> It should transform an environment containing variable names, each referencing a file or another variable, to a resulting environment which maps variable names to values. It should read each file only once when doing so.
04:08:10 <vixey> I think you can do this neatly by leveraging lazyness
04:08:39 <vixey> have you yet discovered the loeb function?
04:08:52 <sebaseba> no, what is that?
04:09:42 <vixey> an abstraction of the sort of thing I'd do here, so if you haven't seen it it's probably a bad idea to look at it from that point of view..
04:10:06 <sebaseba> I found a post about if by sigfpe, is that it?
04:10:14 <maltem> perhaps, with just a little bit of rope...?
04:11:55 <EvilTerran> <sebaseba> the important thing is to traverse twice, right? <- i don't have context here, but would tying the knot save you a traversal?
04:12:24 <sebaseba> by tying the knot you mean...?
04:12:39 <vixey> I'll make an example
04:12:51 <sebaseba> yay! :)
04:12:54 <maltem> sebaseba: using a special recursion scheme that is only possible with lazy evaluation
04:13:17 <EvilTerran> exactly
04:13:19 <maltem> sebaseba: It's one of the things that make Haskell cool, basically.
04:14:03 <sebaseba> any good pointers about this "tying the knot" topic?
04:14:16 <EvilTerran> \xs -> map (subtract avg) where avg = sum xs / length xs -- involves three traversals
04:14:26 <EvilTerran> er, map (subtract avg) xs
04:14:45 <vixey> sebaseba: ok for this simple example, I'll use data Datum = The String | Ref Integer
04:14:57 <vixey> and example = [(5,The "x"),(7, Ref 3),(3, The "y")]
04:15:13 <sebaseba> EvilTerran: once for map, once for sum, and once for length, I suppose
04:15:22 <EvilTerran> yes
04:15:24 <vixey> so the result should be [(5,"x"),(7,"y"),(3,"y")], does that make sense?
04:15:28 <EvilTerran> ignoring that you can't use where there for the time being :P
04:15:35 <vixey> (It's a lot like your example except without the IO)
04:16:07 <vixey> (is this clear so far?)
04:16:09 <sebaseba> vixey: ok, I think I follow
04:16:35 <vixey> now it's going to be a bit tricky to write this, so the first thing to do is give it a type
04:16:37 <vixey> thaw :: [(Integer,Datum)] -> [(Integer,String)]
04:16:58 <vixey> what I want to do inside the thaw function is, map across each element
04:17:26 <vixey> if that element is The <something> the result should be just (index,<something>), if it's a Ref <index> then you need to do a lookup on the -result- of the function
04:17:29 <EvilTerran> \xs -> let (sum,len,ys) = foldr f (0,0,[]) xs; avg = sum/len; f (sumPart, lenPart, ysPart) x = (sumPart + x, lenPart + 1, (x-avg):ysPart in ys
04:17:34 <EvilTerran> *that* ties the knot
04:17:40 <vixey> so you can start of with,
04:17:44 <EvilTerran> by using part of the result of the foldr
04:17:44 <vixey> thaw list = let result = map (thaw' result) list in result
04:17:47 <EvilTerran> (ie sum and len)
04:17:50 <EvilTerran> inside the foldr
04:17:56 <EvilTerran> (as avg)
04:17:56 <vixey>   where thaw' result (i,The value) = (i,value)
04:17:58 <vixey>         thaw' result (i,Ref index) = (i,fromJust $ lookup index result)
04:18:03 <maltem> yay stereo
04:18:21 <EvilTerran> and so you can do the whole thing with only one traversal
04:18:25 <EvilTerran> at the expense of being fugly
04:18:32 <vixey> (sebaseba, now you might want to copy that into a file and try  thaw example )
04:19:07 <EvilTerran> note you can't do that in a strict language, because you're using the result of a function inside itself
04:19:19 <vixey> EvilTerran: sure you can, just use lambda
04:19:36 <vixey> (and side effects)
04:19:50 <EvilTerran> well, kinda
04:19:58 <EvilTerran> but it's even fuglier that way
04:20:05 <vixey> yes certainly :)
04:20:18 <EvilTerran> you could do it vaguely nicely with "tie" in perl
04:20:23 <EvilTerran> i *think*
04:20:28 <EvilTerran> it might be "bless" you need
04:21:14 <sebaseba> vixey: I'll try your example to see if I understand it
04:21:59 <rwbarton> To play this tying-the-knot game in the presence of IO, you'll need to use mfix
04:22:10 <maltem> Btw do we have a name for "tying the knot" that sound a little more scientific? If we haven't I'll vote for Gordian recursion, which involves a Greek word
04:22:13 <vixey> @src mfix
04:22:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:22:18 <rwbarton> @src fixIO
04:22:19 <lambdabot> Source not found. It can only be attributed to human error.
04:22:56 <rwbarton> @src mfix IO
04:22:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:23:03 <rwbarton> @src IO mfix
04:23:04 <lambdabot> mfix = fixIO
04:23:06 <rwbarton> there :)
04:23:23 <Philippa_> maltem: I'd have to vote against - Gordian recursion suggests the recursion's horribly complicated
04:23:43 <maltem> hm true
04:23:53 <vixey> @indexd mfix
04:23:53 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
04:23:53 <maltem> what's greek for knot then?
04:24:10 <vixey> maltem: Why do you want to rename this?
04:24:41 <EvilTerran> > (\xs -> let (sum,len,ys) = foldr f (0,0,[]) xs; avg = sum/len; f x (sumPart, lenPart, ysPart) = (sumPart + x, lenPart + 1, (x-avg):ysPart) in ys) [1..10]
04:24:42 <lambdabot>  [-4.5,-3.5,-2.5,-1.5,-0.5,0.5,1.5,2.5,3.5,4.5]
04:25:08 <maltem> vixey: Well it's uncommon to name a concept by a simple phrase instead of an educated-looking latin/greek word
04:25:48 <yitz> mm... recursive binding?
04:25:56 <EvilTerran> maltem, it's vaguely related to the concept of fixedpoints
04:26:07 <EvilTerran> actually, quite closely related
04:26:16 <EvilTerran> > fix (1:)
04:26:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:26:23 <EvilTerran> > let x = 1:x in x
04:26:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:26:28 <sebaseba> vixey: If I understand it, resut is used to carry the current state of the thawing around, does that make sense?
04:26:50 <vixey> sebaseba: Think of result as the final result of the computation
04:27:12 <vixey> it's just that result is being defined in terms of itsself
04:27:45 <rwbarton> sebaseba: You can think of result as being a kind of graph where the values of some keys are pointers to the values of other keys
04:28:04 <maltem> sebaseba: It is the final result, but while the program is executing, it will first no be fully evaluated
04:28:05 <rwbarton> sebaseba: When you demand the value at one key it will follow the chain of pointers until it reaches a literal value
04:28:29 <vixey> thawing [(0,Ref 1),(1,Ref 0)] will work
04:28:39 <vixey> but if you try to read one of the values it will loop, of course
04:28:42 <rwbarton> sebaseba: Each pointer will only be followed once, though, and then replaced with the value at its target
04:29:11 <sebaseba> why is it followed only once?
04:29:14 <maltem> EvilTerran: ah I see
04:30:16 <sebaseba> *why is each pointer followed only once?
04:30:42 <vixey> sebaseba: It's not a good idea to think about this in terms of pointers
04:30:46 <masak> @source fix
04:30:46 <lambdabot> fix not available
04:30:50 <rwbarton> Because that's how lazy evaluation works--if I define fibs = 1 : 1 : zipWith (+) fibs (tail fibs), and then evaluate fibs !! 30, if I evaluate fibs !! 30 again, I don't have to do any more additions
04:31:11 <nornagon> rwbarton: ghc doesn't auto-memoise
04:31:18 <nornagon> (not all the time, anyway)
04:31:22 <vixey> nornagon: let does though
04:31:28 <nornagon> right.
04:31:31 <rwbarton> Say fibs is a top-level binding
04:31:33 <vixey> (since it's lazy evaluation)
04:31:45 <sebaseba> is that why you used a let? to memoise?
04:31:49 <vixey> top-level defs are basically one big let
04:31:53 <opqdonut> yeah
04:31:53 <vixey> sebaseba: No
04:32:02 <vixey> memoization has nothing to do with this
04:32:12 <opqdonut> because the fibs are in a _list_ they get "memoized"
04:32:42 <rwbarton> Actually, it kind of does... the function will still work if you write thaw list instead of result, it'll just be slower.
04:33:09 <vixey> rwbarton: list and result have different types though, so I'm not sure what you mean
04:33:31 <rwbarton> (thaw list) instead of (result)
04:35:10 <sebaseba> vixey: why does thaw' need result as an argument?
04:35:22 <vixey> sebaseba: thaw' uses result
04:35:38 <sebaseba> isn't thaw' in the scope of the let?
04:37:02 <rwbarton> yes, but the let is not visible from thaw'.  But you could move result into the where clause, and then you wouldn't need to pass it as a parameter
04:40:08 <sebaseba> I rewrote it using where only, is this correct? http://hpaste.org/9364
04:40:37 <vixey> really this kind of variable scope issue is not what I was meaning to demonstrate
04:41:12 <sebaseba> I was just trying to make it as simple as possible so that I might have a chance of understanding the whole mess
04:41:23 <vixey> is there anything about it which is not clear?
04:41:23 <rwbarton> yeah, that looks fine
04:41:25 <pozic> vixey: in what way does let auto-memoise?
04:41:42 <vixey> pozic, Have you seen Cales example of double (double 5) ?
04:41:49 <pozic> vixey: no
04:42:15 <pozic> vixey: but I don't think it does in any way different than top-level bindings.
04:42:35 <vixey> pozic: correct. top level bindings are basically a big let
04:43:05 <pozic> vixey: so functions are still not memoized.
04:43:17 <pozic> vixey: which is what memoization is all about.
04:43:22 <vixey> no it's not
04:43:37 <rwbarton> values are memoized
04:43:49 <rwbarton> if I write let x = 2 + 3 in x * x, it only adds 2 and 3 once
04:43:50 <sebaseba> vixey: I think I understand now. You always do the lookup on result, which guarantees that all references will be followed as far as necessary.
04:44:00 <vixey> sebaseba: right
04:44:00 <rwbarton> That's all I was trying to claim
04:44:07 <pozic> rwbarton: and what's that? Right, not a function!
04:44:13 <vixey> pozic, I could show you an example of memoing fibs?
04:44:16 <rwbarton> Sure.  fibs was not a function either
04:44:37 <sebaseba> vixey: So how do I add IO to thaw?
04:45:03 <vixey> sebaseba: as rwbarton said, you can use mfix
04:45:20 <rwbarton> sebaseba: The easier way is to do the IO first and then use the thaw function vixey gave you
04:45:28 <pozic> vixey: fibs is treated an a constant, because of the mono-morphism restriction.
04:45:48 <rwbarton> (Pretend I wrote fibs :: [Integer])
04:45:51 <vixey> pozic: I have't defined anything yet
04:46:10 <pozic> vixey: if you add an argument to the function syntactically, it will have different behaviour, at least that's how I thought it worked.
04:46:35 <vixey> pozic, Would you like me to show you an example of memoing a function?
04:46:53 <pozic> vixey: take fibs and compare it with fibs with an argument.
04:47:09 <vixey> pozic: honestly, I have no idea what you are talking about
04:47:33 <ilyak_> Hi *!
04:47:39 <vixey> hi
04:47:54 <ilyak_> I'm trying to build HOOD (Observe), but it says it can't find Dynamic
04:47:57 <pozic> vixey: fibs is the one-liner to compute the Fibonacci sequence.
04:48:05 <vixey> pozic: no it's not
04:48:12 <ilyak_> I don't see Data.Dynamic anywhere, maybe it's supposed to be bundled?
04:48:32 <ilyak_> Maybe I shouldn't try to build Observe and should instead do something else?
04:48:53 <Baughn> Are there any structures in the standard library (or on hackage) that aren't spine-strict, but still have O(lg n) or less access time? (I'm trying to make an infinite map, specifically)
04:49:19 <pozic> vixey: then what is it?
04:49:49 <vixey> it wouldn't make sense without context
04:50:10 <pozic> vixey: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:50:30 <vixey> yes, you are thinking about something different from me
04:50:32 <pozic> vixey: everyone in this channel knows what fibs refers to.
04:50:45 <ilyak_> It works after I changed import Dynamic to import Data.Dynamic
04:50:47 <pozic> vixey: so what are you thinking about?
04:50:53 <ilyak_> But it still can't find IOExts
04:51:04 <vixey> pozic: I asked you several times if you wanted me to explain
04:51:04 <ilyak_> What is IOExts and am I supposed to have one?
04:51:17 <pozic> vixey: and I said, yes, take that example.
04:51:30 <vixey> bye
04:51:41 <rwbarton> ilyak_: hmm... googling for IOExts brings up documentation for ghc version 4.06 :)
04:52:35 <maltem> ilyak_: IOExts is very outdated
04:53:17 <maltem> ilyak_: It's from before we got hierarchical modules, I think
04:53:34 <rwbarton> ilyak_: You can try deleting the import IOExts line and then fixing whatever that breaks
04:53:42 <pozic> vixey: ... then don't say anything to begin with...
04:54:35 <ilyak_> Yes, but now it still fails
04:54:55 <ilyak_> Maybe my Observe version is outdated to? Is there anything more recent?
04:55:32 <ilyak_> http://cvs.haskell.org/Hugs/pages/users_guide/observe.html - like that
04:55:33 <lambdabot> Title: Hugs debugging primitives
04:58:55 <rwbarton> I changed import IOExts to import System.IO.Unsafe and it at least compiled.
04:59:46 <ilyak_> rwbarton: You mean, Observe.lhs? Did you do anything to it? I had to pre-process it with cpp
05:00:41 <rwbarton> I just did runhaskell -fglasgow-exts -cpp Observe.lhs to see whether it would compile
05:00:56 <rwbarton> I had to change a few other imports as well (more obvious ones though)
05:01:05 <ilyak_> yeah, I did that
05:01:13 <dcoutts> @seen isaacd
05:01:14 <lambdabot> isaacd is in #ghc and #haskell. I don't know when isaacd last spoke.
05:06:25 <ilyak_> Wow, kewl, it works
05:15:31 <guenni> hi, is there a lib to generate Excel spreadsheets with Haskell?
05:15:43 <guenni> cause if not I'm screwed
05:16:04 <vixey> guenni: Can't excel import plaintext?
05:16:11 <vixey> i.e. data put into columns by tabs
05:16:31 <guenni> vixey: maybe so
05:16:35 <vixey> (if so you can easily generate that
05:17:15 <guenni> vixey: I'm afraid it will get more complicated than that
05:17:30 <ilyak_> guenni: It can read csv files
05:17:35 <ilyak_> Which are plain text
05:17:39 <guenni> vixey: ie several sheets with formulas in them
05:18:13 <guenni> vixey: sums and such and headers and ....
05:19:12 <rdst> is it possible to write windows gui programs in haskell?
05:19:39 <Botje> @faq  is it possible to write windows gui programs in haskell?
05:19:39 <lambdabot> The answer is: Yes! Haskell can do that.
05:19:39 <ziman> with gtk2hs, yes, i suppose
05:20:53 <rdst> thanks for all answers
05:21:30 <vixey> hey Botje
05:21:57 <Botje> hi vixey
05:22:09 <Botje> i'm still procrastinating my compiler typechecker addon :)
05:22:14 <vixey> oh cool
05:22:29 <vixey> have you heard about attribute grammars?
05:23:23 <Botje> nope, what are they?
05:23:26 <vixey> I just read this http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter ... and I have a feeling like one could a typechecker with them
05:23:27 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
05:23:37 <vixey> sort of like annotating syntax trees with some code
05:23:51 <vixey> (I only have a rough idea because I only found out today)
05:24:09 <sebaseba> vixey: I understand thaw now. But I don't know how to use mfix (fixIO?). Any vixeyly hints?
05:24:22 <vixey> sebaseba: first modify thaw to use fix
05:24:37 <vixey> the change the type, fix --> mfix and update thaw'
05:24:55 <audreyt> preflex: seen dcoutts
05:24:56 <preflex>  dcoutts was last seen on #haskell 23 minutes and 42 seconds ago, saying: @seen isaacd
05:25:01 <pozic> I don't think attribute grammars are used by anyone currently.
05:25:07 <sebaseba> vixey: thanks, will try
05:25:31 <vixey> Botje: oh, you have side effects :D
05:25:38 <pozic> It's just another way to solve a global variables problem like the state monad does.
05:25:48 <vixey> Botje: Have you read about the value restriction?
05:26:02 <dcoutts> hia audreyt
05:26:18 <dcoutts> audreyt: so I did some of those changes needed for local repos
05:26:46 <audreyt> dcoutts: I saw them. I'm seeking directions to where I should hack next
05:27:03 <Botje> vixey: no.. :)
05:27:31 <Botje> that AG thing looks like it merges several data structure traversals
05:27:39 <vixey> Botje: I think that this (not having the value restriction) broke type soundness in some ML at some point (but I could be wrong)
05:27:40 <dcoutts> audreyt: so do you want to completely ignore the config file that the user might already have? you probably do right?
05:27:51 <dcoutts> audreyt: ignore the ~/.cabal/config I mean
05:28:33 <dcoutts> audreyt: if so you'll want to add a flag to specify an alternative config file on the command line, and then you can ship your own which would include the local repo
05:28:46 <audreyt> ok.
05:29:02 <audreyt> are there this sort of "global flags"?
05:29:09 <dcoutts> audreyt: I mean we can either pass the repo on the commend line or put it in the config file and pass the alternative config file
05:29:24 <audreyt> cabal --config=/path/to/config configure ...
05:29:35 <audreyt> are you philosophically against environment variables?
05:29:50 <dcoutts> audreyt: yeah :-) except sometimes
05:29:56 <audreyt> I noticed
05:30:25 <audreyt> ok, so the flag goes before the command
05:30:30 <audreyt> that's a first for the cabal command line, no?
05:30:42 <dcoutts> audreyt: I guess it's because I'm a functional programmer, preferring explicit parameter passing :-)
05:30:53 <dcoutts> (we do use env vars for one purpose in cabal)
05:30:56 <dcoutts> audreyt: hmm
05:30:56 <audreyt> I guess you're also against implicit parameters :)
05:31:01 <dcoutts> right
05:31:15 <pozic> dcoutts: and state monads?
05:31:41 <dcoutts> pozic: they're ok, it's clear from the type that you've got the implicit params
05:32:21 <pozic> dcoutts: implicit params also have a different type.
05:32:43 <dcoutts> audreyt: mm, you're right, it's more tricky. We don't really have any global flags.
05:33:09 <pozic> dcoutts: sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
05:33:20 <audreyt> dcoutts: that's where I stuck and decided to wait for your input
05:33:26 <pozic> dcoutts: implicit parameters were also faster in GHC, IIRC.
05:33:34 <dcoutts> audreyt: :-)
05:33:34 <audreyt> dcoutts: from my impure perl background environment variable is the natural solution
05:33:52 <audreyt> but if you'd really like a global flag I can hack it in too. it just feels weird.
05:35:20 <dcoutts> audreyt: it does make sense for it to be a global flag, since it will apply to basically every command.
05:35:24 <dcoutts> audreyt: I think it can be done
05:35:35 <dcoutts> audreyt: see commandsRun in Main.hs
05:36:05 <dcoutts> audreyt: we end up with 'flags' (which is global flags) and we call action, we could pass flags to action
05:36:21 <audreyt> sure
05:36:35 <dcoutts> audreyt: currently GlobalFlags only contains --help and --version, but we can extend that
05:36:56 <audreyt> what about an environment variable we only use internally? :D
05:37:26 <dcoutts> audreyt: or probably use (Cabal.GlobalFlags, OurExtraStuff), like we do with the install command that takes the union of the configure and some extra flags.
05:38:11 <audreyt> gotcha
05:38:19 <dcoutts> audreyt: I don't mind so much if we use an env var as well, as an alias, but it should use the same information handling mechanism as we use for config/commandline-opts
05:38:48 <dcoutts> audreyt: the worst thing is doing getEnv at random points in the program, that's just global vars
05:39:13 <dcoutts> if we do it at the same place as we process args and load the config file, that's no so bad
05:39:26 <audreyt> that is what I was suggesting.
05:39:32 <dcoutts> having said that, we do exactly getEnv for the http proxy :-)
05:39:44 <dcoutts> (and not at the top level)
05:39:49 <audreyt> basically replace all the
05:39:49 <audreyt> configFile <- defaultConfigFile --FIXME
05:39:51 <audreyt> with
05:39:54 <audreyt> configFile <- getConfigFile
05:40:03 <audreyt> and have getConfigFile do exactly one getEnv
05:40:20 <dcoutts> audreyt: right, I'd prefer getConfigFile to take the param
05:40:36 <audreyt> getConfigFile globalFlags
05:40:36 <audreyt> ?
05:40:43 <audreyt> configFile <- getConfigFile globalFlags
05:41:51 <dcoutts> audreyt: or configFile <- getConfigFile (flagToMaybe (globalConfigFile globalFlags))
05:42:05 <dcoutts> audreyt: oh, wait that's not right
05:45:06 <dcoutts> audreyt: something like: configFile <- defaultConfigFile >>= \def -> fromFlagOrDefault def (globalConfigFile globalFlags)
05:48:28 <audreyt> dcoutts: ok, I'll abbreviate "defaultConfigFile >>= \def -> fromFlagOrDefault def (globalConfigFile globalFlags)"
05:48:31 <audreyt> as "getConfigFile"
05:48:35 <audreyt> that sounds right to you?
05:48:38 <dcoutts> ok
05:48:53 <audreyt> k. bbiab, dinner, will return with code
05:49:12 <dcoutts> audreyt: and if you like, make getConfigFile also take the value from an env var, with the command line flag overriding
05:49:22 <audreyt> whee
05:49:36 <audreyt> dcoutts++ # cares about impure sensibilities
05:49:55 <dcoutts> audreyt: though I don't see how it's any easier for you :-)
05:50:17 <audreyt> it actually makes it easier for me
05:50:27 <dcoutts> CABAL_CONFIG_FILE=foo cabal blah vs cabal --config-file=foo blah
05:50:28 <audreyt> since there's a perl script that calls "cabal" multiple times
05:50:38 <audreyt> and so a $ENV{CABAL_CONFIG_FILE} at top makes it easier (a bit)
05:50:40 <dcoutts> and it can't $(cabal-opts) ;-)
05:51:03 <yitz> I'm new to irssi. Anyone know why dcoutts' nick shows as @dcoutts ? Nicks spelled that way could lead to some problems in the presence of our dear bot...
05:51:12 <audreyt> well, shell programming /= makefile programming :)
05:51:22 <Botje> yitz: he's a channel operator
05:51:28 <Botje> his nick is still dcoutts, don't worry :)
05:51:38 <dcoutts> audreyt: oops, wrong syntax :-)
05:51:41 --- mode: ChanServ set -o dcoutts
05:51:52 <Botje> @seen dcoutts
05:51:52 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 14s ago.
05:51:59 <Botje> see? \bot is not confused
05:52:00 <Botje> .. for once :)
05:52:28 <ivanm> waern: ping!
05:52:29 * dcoutts was opped as someone was CTCP PING spamming us earlier without explanation
05:52:44 <Zao> I could write an irc client that showed all ops in deep pink, it wouldn't affect bot performance in any way.
05:52:44 <yitz> Botje: ok. Let's make sure not to give op priviledges to vixen or pl or whatever. :)
05:53:05 <Zao> yitz: It's just your client display preferences.
05:53:19 <Zao> The nick is dcoutts, with the mode +o
05:53:29 <vixey> '@' is actually part of IRC
05:53:35 <yitz> ok, thanks, i got it.
05:53:59 <vixey> NAMES will have @'s in it
05:58:28 <yitz> thanks vixey
05:58:47 <yitz> that setting is fine with me, now that i know what it means.
06:15:43 <jpcooper> could anyone link me to some examples of the usage of the GD package, please?
06:18:03 <waern> ivanm: pong
06:18:22 <ivanm> are you in charge of haddock-2?
06:19:20 <waern> ivanm: yep
06:21:29 <ivanm> OK, for some packages I get errors saying that there's "Magic number mismatch: couldn't load interface file:...", and then "haddock: internal Haddock or GHC error: src/Haddock/Interface/Rename.hs:(370,16)-(373,46): Non-exhaustive patterns in case"
06:21:37 <ivanm> dcoutts said I should ask you about it
06:22:05 <waern> yes
06:22:31 <waern> the first error happens because Haddock is trying to read an old interface file
06:22:58 <ivanm> *nod*
06:23:05 <waern> so you need to re-haddock packages to create new interface files, if you want links to those packages
06:23:10 <ivanm> looks like they're all from ghc
06:23:20 <ivanm> how bout the second?
06:23:24 <ivanm> your fault? :p
06:23:47 <waern> ehm, yes, probably :)
06:23:54 <ivanm> heh
06:23:57 <waern> I think I just fixed that one though
06:24:04 <waern> so, are you using 2.1.0?
06:24:34 <ivanm> 2.2.0
06:24:40 <ivanm> with ghc-6.8.3
06:25:51 <guenni> (list
06:26:31 <waern> ivanm: is the package on hackage?
06:26:36 <dcoutts> ivanm: the docs for the packages that come with ghc will be using haddock 0.8 or 0.9
06:26:40 <jacobian_> In terms of style, is it nicer when you have some resource that you want to use linearly to use let to rebind the name, or keep choosing new names.
06:26:40 <waern> ivanm: so I can try if it works with the darcs version of haddock
06:27:12 <jacobian_> like "let (x,g) = g" or "let (x,g') = g"
06:27:53 <ivanm> waern: this happens with regex-base/posix, binary, bytestring, unix-compat, pcre-light
06:28:05 <ivanm> (well, they all failed with haddock-2 anyway, and I _think_ most of them are from that issue)
06:28:22 <waern> ah, ok
06:28:23 <ivanm> dcoutts: yeah, that's what I figured... there's no way we could use haddock-2 when bootstrapping?
06:28:35 <waern> 2.2.0 shouldn't have been released actually
06:28:59 <dcoutts> ivanm: that's pretty tricky since haddock-2.x needs to be built with the same version of ghc
06:29:06 <waern> I asked ross to remove it from hackage, but he was out travelling
06:29:25 <dcoutts> waern: you can always upload a 2.2.1 with the fixes
06:29:36 <ivanm> dcoutts: :s
06:29:42 <waern> dcoutts: yeah, but I'll have to do the fixes and test it properly first
06:29:44 <ivanm> waern: then why was it released? :s
06:30:20 <waern> ivanm: I was a bit too eager to release it I gues
06:30:21 <dcoutts> waern: the solution in future will be to direct cabal to use a version other than the latest, so we'll not need to take packages down
06:31:00 <ivanm> heh
06:31:10 <waern> dcoutts: hm, ok, but shouldn't uploaders have the option of quickly removing something that was just uploaded by mistake?
06:31:30 <ivanm> waern: you mean a cooling-off period?
06:31:33 <dcoutts> waern: if they do it in the first 5 min, perhaps so
06:32:34 <dcoutts> waern: package urls and content are supposed to be stable, so even if you removed it, you could not upload 2.2.0 again
06:32:58 <ivanm> dcoutts: or maybe have a "testing" release option, where if you get it within the first x hours/days etc. then it's at your own risk?
06:33:04 <ivanm> aka stabilisation?
06:33:27 <dcoutts> it'd have to be with a different url
06:34:43 <ivanm> is that deliberately set up like that?
06:34:52 <yitz> jacobian_: i personally use different names when i really must do that. but i try to avoid it, e.g., with a state monad, or with functions with more parameters.
06:35:23 <yitz> jacobian_: in fact i think you must use different names - otherwise it will be interpreted to be recursion.
06:35:29 <jacobian_> yeah, unfortunately I'm using SML, so state monads are messy looking.
06:35:56 <jacobian_> yitz: ah, good point
06:36:17 <jacobian_> I thought since it was a style question, it wouldn't matter where I asked, but it looks like I was wrong
06:36:25 <yitz> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:36:25 <lambdabot>  Parse error at end of input
06:36:37 <yitz> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:36:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:37:34 <r3m0t> > let fibs = 0 : 1 : zipWith (+) <*> tail in fibs
06:37:35 <lambdabot>  Couldn't match expected type `[t]'
06:37:53 <r3m0t> > let fibs = 0 : 1 : ((zipWith (+)) <*> tail) in fibs
06:37:54 <lambdabot>  Couldn't match expected type `[a -> t]'
06:38:00 <yitz> jacobian_: perhaps you can restructure it as a sequence of composed functions.
06:38:04 <r3m0t> > let fibs = 0 : 1 : ((zipWith (+)) <*> tail) fibs in fibs
06:38:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:49:02 <jacobian_> yitz: thanks for the tip
06:49:30 <twanvl> > fix ((0:) . (1:) . (zipWith (+) <*> tail))
06:49:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:51:51 <chrisdone> @src (<$>)
06:51:51 <lambdabot> f <$> a = fmap f a
06:52:04 <Deewiant> > fix ((0:) . scanl (+) 1)
06:52:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:54:57 <Axman6> @src fmap
06:54:58 <lambdabot> Source not found. Do you think like you type?
06:55:08 <Axman6> often, yes
06:55:13 <mauke> @src Functor
06:55:14 <lambdabot> class  Functor f  where
06:55:14 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:55:30 <sal23> is there a GHC 6.8.3 binary for mac os 10.4? there is a package for leopard but I want to install it on another computer running Tiger
06:55:58 <Axman6> sal23: any reason you can't compile it?
06:56:39 <sal23> I don't want to go through the build process....the impression I got from GHC homepage is that it is better downloaded as binary than as source code
06:57:03 <sal23> so, I will rather not spend a whole day doing that if I could get a binary
06:57:21 <Axman6> sal23: if you can find any binary that'll run on tiger, install that and use it to install 6.8.3
06:57:47 <Axman6> why aren't you running leopard anyway? just curious
06:57:53 <sal23> Axman6: well, if I could....I have it already installed on a computer running Leopard
06:58:12 <sal23> Axman6: my macbook is Tiger, iMac is leopard
06:58:54 <Axman6> might be possible use a leopard one. worth a shot i guess
06:59:28 <sal23> Axman6: yes, I should try that one....though it says XCode 3 must be installed, which is Leopard version...
06:59:41 <Axman6> ah, i see
06:59:44 <sal23> Axman6: any chance you know why Manuel's package depends on XCode?
06:59:59 <Axman6> who's page?
07:00:41 <sal23> Axman6: http://www.haskell.org/ghc/download_ghc_683.html#macosxintel
07:00:41 <lambdabot> Title: GHC: Download version 6.8.3
07:01:37 <Axman6> anyway, you could always try macports. it may still work properly
07:02:55 <sal23> Axman6: yep, looking into it
07:03:38 <Axman6> yeah there's a darwin_7 variant, should be ok
07:06:55 <waern> ivanw: I've fixed the problem (pattern match failure) in the darcs version
07:06:58 <b\6> System.Console.GetOpt ok to use, or should i use something else?
07:07:30 <waern> ivanm: I've fixed the problem (pattern match failure) in the darcs version
07:09:07 <Baughn> b\6: Eh, it's fine, if you don't mind the interface
07:09:47 <Baughn> Has the advantage of following standard gnu argument conventions, too
07:21:11 <gwern> @seen dcoutts
07:21:12 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 47m 44s ago.
07:21:53 <gwern> @tell dcoutts btw, you seem to've broken sdist build for cabal-install with your new symlink stuff
07:21:53 <lambdabot> Consider it noted.
07:25:04 <gwern> @tell dcoutts also, I notice 'user-prefix: "/home/gwern/bin" \n symlink-bindir: "/home/gwern/bin/bin"' seems to lead to interesting conflict
07:25:05 <lambdabot> Consider it noted.
07:25:44 <FordCortina> hmm... agda's typechecker is supposed to terminate right?
07:26:03 <vixey> FordCortina: as is haskells
07:26:30 <FordCortina> think i just made it run "forever" :D
07:26:35 <FordCortina> nearly took out my machine
07:26:56 <vixey> what did you code?
07:27:36 <FordCortina> vixey: i was messing with Danielssson's Parser code... trying to introduce some type recursion
07:28:07 <FordCortina> so the non-termination wasnt a surprise
07:28:25 <vixey> I think that it shouldn't be possible
07:28:27 <vixey> can I see?
07:29:01 <FordCortina> ill do a diff in darcs
07:29:03 <vixey> unless you have got definitions in red?
07:30:41 <FordCortina> basically I got rid of the "Step c" business
07:31:03 <FordCortina> i wondered what error i'd get if i did
07:31:46 <golubovsky> Hi, Dimitry is here
07:31:54 <dmwit> Hi, Dimitry!
07:32:25 <golubovsky> I have a XML-related question:
07:32:49 <FordCortina> vixey: here's the diff
07:32:51 <FordCortina> http://hpaste.org/9365
07:33:16 <FordCortina> i havent pulled any changes in agda for a while
07:33:20 <FordCortina> so maybe they fixed the bug
07:33:26 <FordCortina> (about a month
07:33:27 <FordCortina> )
07:33:57 <golubovsky> back again...
07:34:02 <golubovsky> OK, now it works.
07:34:37 <FordCortina> vixey: as you can see, i also changed an example, to see what happened when you do the p=! p thing
07:34:51 <golubovsky> The question is: given a XML DTD, is there a tool which creates related Haskell data structures AND a parser for a conforming XML, altogether?
07:35:22 <golubovsky> HXT includes something to do the first step (constructs a bunch of filters out of a DTD), but is there a complete utility?
07:36:01 <FordCortina> vixey: the only reason i did this was because I'm trying to describe (in my work) what the "Step" consructor means in terms of the parser call graph
07:38:44 <FordCortina> vixey: im sorry i didnt understand what you meant by "defintions in red", is that something that happens in emacs after you compile?
07:38:54 <vixey> yes
07:39:07 <vixey> if you have recursion which doesn't obviously terminate
07:39:55 <FordCortina> vixey: yes but the compiler would have to terminate, for me to get that, right? at least i never saw anything red come up
07:40:32 <FordCortina> and the compiler did not terminate. i had to kill it because it was hogging my system
07:59:13 <dcoutts> gwern: what goes wrong?
07:59:47 <dcoutts> gwern: with sdist or indeed the symlink-bindir thing?
08:00:35 <MyCatVerbs> Apparently no one uses showS-style functions when outputting lazy bytestrings?
08:01:05 * MyCatVerbs is wondering at the lack of combinators revolving around such in Data.ByteString.Lazy. Is this at all typical?
08:01:28 <dcoutts> MyCatVerbs: for generating output by cat'ing things together?
08:01:49 <dcoutts> MyCatVerbs: we should but the Builder monoid into the bytestring package
08:01:51 <dmwit> MyCatVerbs: Maybe it makes more sense to mapM_ print over a list of BS?
08:02:12 <dcoutts> dmwit: that'd be no better than putStr concat
08:02:46 <dmwit> dcoutts: Really?
08:02:57 <MyCatVerbs> dcoutts: No need to create an intermediate concatenated version of the structure. Though the increased number of write(2) calls might make it worse.
08:03:12 <dmwit> dcoutts: concat doesn't have to copy the end (last element in the list) several times in case of buffer-to-small?
08:03:20 <dmwit> s/-to-/-too-/
08:03:26 <dcoutts> dmwit: lazy bytestring concat doesn't copy anything
08:03:35 <dmwit> neat!
08:03:59 <dcoutts> MyCatVerbs: the number of write calls should be exactly the same
08:04:00 <MyCatVerbs> dmwit: it still conses, though.
08:04:06 <MyCatVerbs> Er, dcoutts: it still conses, though.
08:04:36 <dcoutts> MyCatVerbs: I think that'll be negligible
08:05:54 <MyCatVerbs> Mmmhmm. So, I'm writing a Get ByteString, where the goal is to transform a binary file's structure into a big, fluffy, textual representation.
08:06:15 <dcoutts> @hoogle >=>
08:06:15 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:07:14 <MyCatVerbs> I'm going to go out on a limb here and assume that lazy ByteString output would probably be preferable. What's the best way of achieving that?
08:07:28 <Gwern-away> @seen lispy
08:07:28 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 9h 16m 2s ago.
08:07:41 <dcoutts> MyCatVerbs: using Put ? :-)
08:09:18 <MyCatVerbs> Oh, nvm. The Builder monoid does exactly what I'm after.
08:09:21 <Gwern-away> @tell lispy darcs type witness problems: http://hpaste.org/9366
08:09:22 <lambdabot> Consider it noted.
08:11:16 <mauke> someone needs to get geophf into #haskell
08:12:05 <dmwit> geophf of combinator blog?
08:12:15 <mauke> yes
08:12:28 * dmwit nods
08:13:31 <Gwern-away> mauke: any progress on the TH?
08:13:43 <mauke> huh?
08:14:19 <Gwern-away> or was the template haskell someone else?
08:14:24 * Gwern-away is not so good with the names
08:14:46 <mauke> I've only used TH to compute tables at compile time
08:15:05 <Gwern-away> maybe that was mmorrow I was talking to
08:15:14 <Gwern-away> all I remember was that it started with an 'm'
08:15:56 <Gwern-away> ah well
08:19:09 <mauke> marmolak matveev m4thrick mm_freak mnislaih mattam mapreduce maskd mwti mirakel mfp masak mightybyte MyCatVerbs metavoid minimaximus mauke moonfart mrd mercury^ matthew-_ MarcWeber mperillo mokus muniek92 mmorrow MrDomino mulletron Modius Mr_Awesome mux mlh mattiast Mitar mornfall mbz Megant_ mxc mrsolo__
08:19:54 <mirakel> M-PREFIXED CHATTERS OF THE WORLD, UNITE!
08:20:12 <mauke> this user list was brought to you by the combined powers of filter and map
08:22:24 <mbz> what?
08:23:00 * mbz yawns
08:23:14 <b\6> m pretty much sucks compared to other letters, e.g., b.
08:23:39 <Botje> b ftw!
08:24:08 <matthew-_> m is quite marvellous, me thinks
08:24:20 <vixey> mad..
08:24:31 <Gwern-away> I've always liked g
08:25:22 <dmwit> m is only nice as a second letter
08:25:41 <Gwern-away> hm. that's interesting
08:25:49 <twanvl> but only when upside down
08:25:56 <Gwern-away> did you know over the logged history of #haskell, there've only been 1538 @remembers?
08:26:01 <mauke> uop psdn
08:28:21 <Gwern-away> the first listed @remember seems to be '<dons> @remember Igloo What's that doing?'
08:28:36 <Gwern-away> '<dons> @remember kzm My program contains a bug.  How ungrateful, after all I've done for it.'
08:28:46 <vixey> hehe
08:29:32 <Gwern-away> '<basti_> @remember SyntaxNinja  < SyntaxNinja> just picture monads as tiny, silly, luminous, and devious sprites who fly around\ your haskell code carrying state from one piece of code to another. | < SyntaxNinja> I don't think that'll help, but it can't \
08:29:51 <Gwern-away> hurt.
08:30:32 <Gwern-away> '<ski> @remember poetix Avoiding lambdas is pointless' <-- *groan*
08:31:12 <vixey> hehe
08:31:15 <Gwern-away> '<Pseudonym> @remember Korollary an olegweek is a complex entity with an imaginary part'
08:31:49 <Gwern-away> @quote stereo
08:31:49 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
08:31:54 <vixey> @quote
08:31:54 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
08:31:57 <vixey> @quote
08:31:58 <lambdabot> Korollary says: You know, dons actually knows your phone number. He'll be calling you soon to check whether you have any questions about monad transformers.
08:32:24 <Botje> the stereo quote is back?
08:32:25 <Botje> huzzah!
08:33:53 <vixey> maybe I should try to get 6.9 to compile again
08:33:58 <vixey> I know that I wont manage :
08:34:15 * Gwern-away extracts all the @remembers using an emacs macro. :( so many spelling errors
08:34:46 * vixey downloads the _essential_ haskell compiler
08:34:58 <vixey> lots of .eh files
08:35:10 <dcoutts> Gwern-away: so what do you think the behaviour should be if the symlink bin dir does not exist?
08:35:25 <dcoutts> Gwern-away: if it doesn't exist, it's probably not on your $PATH either
08:35:40 <Botje> http://code.haskell.org/lambdabot/State/quote # gzipped @remember database
08:35:40 <mauke> preflex: remember SyntaxNinja just picture monads as tiny, silly, luminous, and devious sprites who fly around your haskell code carrying state from one piece of code to another. I don't think that'll help, but it can't hurt.
08:35:56 <dcoutts> Gwern-away: perhaps we should check that its on your path first, and if not warn and don't make the links?
08:36:18 <dcoutts> Gwern-away: in the unlikely case that it is on the path but does not exist then we could go ahead and make it
08:36:25 <Gwern-away> '<hashendgame>   yes, let's put roconnor in the standard libs. Util.Roconnor?'
08:37:00 <Gwern-away> dcoutts: I'd just count the binary which gets installed in ~/bin/bin as managed, but I dunno whether that'd work
08:37:46 <dcoutts> Gwern-away: I don't know what you mean, you were saying to put the symlinks in ~/bin/bin which presumably does not exist.
08:38:13 <dcoutts> Gwern-away: or are you saying that it does exist but the symlinks end up pointing to the wrong place?
08:41:55 <dcoutts> Gwern-away: I guess you must mean the problem you get when ~/bin/bin doesn't exist, since when it does, the links look correct.
08:41:57 <matthew-_> actually, I'm pretty sure rsa in the type system won't be that hard
08:42:51 <matthew-_> it's just compilation or rather type checking might start to take a very long time
08:44:55 <vixey> would be cool to see it done
08:47:14 <dmwit> Wait, did layout exist pre-GHC?
08:47:24 <dmwit> ...pre-Haskell, I mean?
08:48:18 <dmwit> "The concrete syntax we use is conventional... where the layout makes the meaning clear, we allow ourselves to omit semicolons between bindings and case alternatives." -- the STG-machine paper
08:49:16 <EvilTerran> it's existed informally in maths circles for a while, i think
08:51:28 <dmwit> ?quote interface.b
08:51:28 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
08:51:47 <vixey> @quote
08:51:48 <lambdabot> SamB_XP says: oh. does A/S/L mean Age/Sex/Programming Language?
08:54:17 <vixey> @keal
08:54:17 <lambdabot> just seeing how offtopic i could get everyone
08:55:40 <vixey> @quate
08:55:41 <lambdabot> Igloo says: i 4m teh lambda
08:55:47 <Twey> Heh
08:55:56 <EvilTerran> @quite
08:55:56 <lambdabot> Maybe you meant: quit quote
08:55:58 <EvilTerran> aww
08:56:25 <Twey> vixey: In #learnanylanguage someone started a new one: ASLOL
08:56:37 <Twey> Age, sex, location, orientation, languages
08:56:40 <vixey> @quoot
08:56:40 <lambdabot> Maybe you meant: quit quote
08:56:49 <dmwit> ?quoto
08:56:50 <lambdabot> bd_ says: [SamB_XP] what is this "release" thing anyway? [bd_] SamB_XP: it's when you disown a project [SamB_XP] bd_: why would I want to do that? [bd_] Well, for example, in case of death.
08:56:55 <dmwit> ?quota
08:56:55 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
08:57:17 <vixey> @qoote
08:57:18 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:57:25 <dmwit> boooooo
08:57:28 <vixey> empty list :?
08:57:35 <dmwit> ?reboot
08:57:35 <lambdabot> Unknown command, try @list
08:57:42 <vixey> @die
08:57:42 <lambdabot> unexpected end of input: expecting number
08:57:54 <dmwit> ?die 3d6
08:57:54 <lambdabot> 3d6 => 7
08:58:27 * dublpaws dodges the goblin with ease
08:58:49 <BONUS> how do you usually achieve haskell syntax highlighting on the web?
08:58:56 <dmwit> hscolour
08:59:02 <vixey> BONUS: M-x htmlize-buffer
08:59:11 <dmwit> Or yeah, that. =)
08:59:14 <BONUS> hmm
08:59:19 <dmwit> vim has an equivalent, if you use that instead
08:59:37 <BONUS> yeah i use vim
08:59:47 <dmwit> Let me try to recall...
08:59:50 <dmwit> :toHTML or some such
08:59:53 <BONUS> aha
08:59:57 <BONUS> i'll check that out
09:00:04 <BONUS> is there a js script though?
09:00:05 <BONUS> that does it
09:00:21 <BONUS> cause i'd rather not pollute my markup with presentation if i dont have to
09:00:36 <dmwit> There's a separate one that generates both HTML/CSS.
09:00:47 <dmwit> Poke around in :help :ToHTML.
09:00:52 <BONUS> aha
09:00:53 <BONUS> cool
09:01:05 <dmwit> :let html_use_css=1
09:02:03 <shapr> @yow !
09:02:03 <lambdabot> Couldn't find fortune file
09:02:17 <dmwit> BONUS: Just... use a good color scheme, will you? =)
09:02:22 <BONUS> haha
09:02:28 <BONUS> any preferences?
09:02:35 <BONUS> black on white vs. white on black?
09:02:37 <dmwit> darkblue
09:03:59 <dmwit> But that's just *my* preference.  Any good-looking color scheme is fine, of course.
09:04:13 <BONUS> yeah i like darkblue
09:04:20 * shapr cheers for Haskell!
09:05:44 <sal23> speaking of categories, if f: B->C and g: A -> B, it doesn't make sense that h = f . g : A -> C .... it should be g . f ?
09:06:00 <sal23> http://en.wikibooks.org/wiki/Haskell/Category_theory : second paragraph under "Category Laws"
09:06:25 <dmwit> sal23: (.) is the composition operator from math; the order of its arguments is just a convention
09:06:38 <vixey> sal23: g . f wouldn't type check
09:06:45 <vixey> :t (f :: b-> c) . (g :: a -> b)
09:07:15 <BONUS> f.g takes what g takes and returns what f returns
09:07:37 <sal23> oops...I got it...I was mapping it in wrong order  :|
09:07:46 <vixey> that is why I write it with a <- arrow
09:07:51 <vixey> it is much less confusing
09:08:02 <sal23> vixey:  yes :)
09:08:02 <vixey> (.) : (c <- b) -> (b <- a) -> (c <- a)
09:08:24 <dmwit> ?bot
09:08:24 <lambdabot> :)
09:08:29 <EvilTerran> (.) : (c <- a) <- (b <- a) <- (c <- b), surely? :P
09:08:47 <dmwit> ...I don't get it.
09:09:16 <EvilTerran> nvm
09:09:41 <opqdonut> EvilTerran: :P
09:10:45 <dmwit> Incidentally, that's not such an easy function to write. =P
09:10:48 <vixey> "<-" is read "from"
09:10:53 <dmwit> or was that the joke?
09:11:14 <dmwit> Oh!
09:11:18 <mauke> type (<-) a b = b -> a
09:11:52 <ziman> what's the associativity of (<-) ? :)
09:12:04 <vixey> ziman: left
09:12:06 <dmwit> EvilTerran: Sorry, I'm an idiot. =/
09:14:20 <sal23> two and half hours to compile ghc 6.8.3 and the libs on my macbook with GHC 6.6, wow....
09:14:39 <vixey> why does haskell take a long time to compile?
09:16:01 <sal23> one thing I noticed was that the compilation spent most of the time i/o bound than cpu-bound
09:16:20 <sal23> so, it seems to be lot of i/o generating intermediate files
09:16:40 <MyCatVerbs> vixey: big compiler.
09:16:53 <MyCatVerbs> vixey: lotta libraries, complicated (slow to parse) input language.
09:17:54 <mornfall> Slow to *parse*? I wouldn't think that...
09:18:27 <MyCatVerbs> mornfall: Haskell has a pretty complicated grammar.
09:18:51 <mornfall> Dunno, parsing is usually negligible in most compilers.
09:19:00 <chrisdone> MyCatVerbs: I've wondered, do custom infix operators make it a lot harder to parse, or just a bit?
09:19:20 <MyCatVerbs> chrisdone: don't know. Ask a GHC maintainer or implementer.
09:19:37 <dmwit> chrisdone: Well, they make it context-sensitive.
09:19:52 <dmwit> Not so much the custom operators as the custom associativity, though.
09:19:56 <chrisdone> yeah
09:21:02 <MyCatVerbs> mornfall: mmmm. If you have the optimizer switched on, a lot of time goes into that, but I'm not sure where most cycles are burned with -O0 and -fasm.
09:22:01 <mornfall> MyCatVerbs: In say C++ (a fairly complex grammar too), the parsing time is a small fraction of unoptimised compilation...
09:22:44 <MyCatVerbs> mornfall: what's the rest?
09:23:11 <mornfall> MyCatVerbs: Template expansion, typechecking, code generation...
09:23:12 <MyCatVerbs> mornfall: I thought C++'s compilation times were often dragged up significantly by parsing just because of the mountains of headers that big projects accrue.
09:23:44 <mornfall> There used to be a switch to g++ to only do parsing, IIRC.
09:23:48 <mornfall> You could try... :)
09:24:24 <mornfall> I guess you can do megabytes of source a second for the parser alone.
09:37:16 <dmwit> heh
09:37:25 <mmmdonuts> I've installed some packages with cabal-install, but when I try to build other packages manually (with "runhaskell Setup.hs ..."), it doesn't see the packages that were cabal-installed.  Can that be fixed?
09:37:31 <dmwit> I made a test file with a 20MB string literal and a "main = return ()", GHC is choking so hard.
09:38:00 <dmwit> mmmdonuts: Does ghc-pkg list show those packages?
09:38:46 <dmwit> If so, the .cabal file for the package that won't build is probably wrong.
09:38:51 <mmmdonuts> dmwit, yes, but it shows them as being associated with a different package.conf than all the other packages that ghc knows about.
09:39:10 <dmwit> the --user one?
09:39:25 <dmwit> In that case, you probably have to "runhaskell Setup.hs --user ...".
09:39:47 <dmwit> (Cabal won't let you build a global package that depends on local packages, probably.)
09:39:52 <mmmdonuts> yes, the cabal packages are in ~/.ghc/.../package.conf.
09:40:25 <dmwit> I don't know the exact flags to pass, but "runhaskell Setup.hs help" probably does.
09:40:39 <mmmdonuts> Thanks, I'll take another look.
09:42:39 <dmwit> Looks like just --user at the configure stage is enough.
09:44:03 <mmmdonuts> When I "runhaskell Setup.hs help", it doesn't list any options like --user.  Just -h, -v, and commands.  When I run "runhaskell Setup.hs --user configure", it says "unrecognized option --user".  Do I need to upgrade something?
09:44:16 <dmwit> configure --user
09:44:21 <dmwit> You got the wrong order. =)
09:44:33 <dmwit> See also configure --help
09:44:48 <dmwit> (Which does, indeed, list --user/--global, as well as a lot of other stuff.)
09:45:02 <mmmdonuts> Aha, thanks!
09:45:55 <mapreduce> mauke: I don't want to unite, but thanks for the opportunity.
09:55:02 <heavensrevenge> hello
09:55:07 <dmwit> Hiya!
09:56:23 <heavensrevenge> just watching some nested data parallelism vids
09:56:28 <heavensrevenge> very fun stuff
09:57:07 <Cale> It is, isn't it? :)
09:59:47 <BCoppens> heavensrevenge: is that on a public site somewhere?
10:01:29 <RayNbow> BCoppens, http://www.haskell.org/haskellwiki/Video_presentations
10:01:30 <lambdabot> Title: Video presentations - HaskellWiki
10:01:44 <RayNbow> and then... http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
10:01:46 <lambdabot> Title: ondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
10:02:34 <BCoppens> oh, thanks :)
10:02:46 <zachk> i dont get the point of hugs, i tried it over a year ago and it didnt like it at all, got ghc and i love it
10:03:02 <dmwit> HUG = Haskell User Group in this case
10:03:04 <Baughn> zachk: Hugs works on hardware that ghc doesn't
10:03:21 <zachk> Baughn: like what
10:04:15 <Baughn> zachk: ARM, say
10:05:46 <mauke> preflex: quote
10:05:47 <preflex>  <mauke> I'm going to write a lib33t.so just so you have to link with gcc -l33t
10:05:52 <mauke> heh
10:06:06 <Zao> Now that's libame
10:11:30 <heavensrevenge> indeed, srry about that, had a SD card sync emergency :P
10:11:57 <heavensrevenge> well WinHugs is nice on windoze zachk
10:12:13 <heavensrevenge> otherwise, ghc(i) is more up to date and such
10:12:25 <zachk> heavensrevenge: i like ghc/i and vim on windows
10:12:40 <dmwit> ghcii.sh
10:12:40 <heavensrevenge> ever try WinHugs??
10:12:47 <heavensrevenge> its nice to have button controls
10:12:59 <heavensrevenge> but i only use it for demonstrati purposes
10:13:39 <heavensrevenge> otherwise, im a 75% Linux guy and 20% FreeSD guy, with 5% windoze vista on the side ;)
10:15:40 <heavensrevenge> the nested data parallelism is interesting
10:16:43 <heavensrevenge> would it have to be a live sort of optimization, or would it be valid to map the machine(grid) your on b4 executaion and actually map an distrobution execution model??
10:17:01 <heavensrevenge> like... mapping or testing the capability of a node
10:18:53 <heavensrevenge> ala, testing and incrementing a benchmark,once the incrementation frequency levels off, the #'s would have measured the modes capability
10:19:56 <heavensrevenge> if the #'s were mapped to ip's or the like, giving GHC or a tool the means to distribute guided by the computation benckmark map, it should be able to distribute properly
10:20:35 <heavensrevenge> not like cpu's and ram will fluctuate so much as to invalidate a pre-computability grid map
10:24:55 <heavensrevenge> hello?
10:25:22 <mc__> heavensrevenge: feel free to ask
10:25:30 <chrisdone> *Lambdabot.Url GOA> putStrLn ""
10:25:31 <chrisdone> 
10:25:32 <chrisdone> heh
10:25:33 <mauke> sorry, I'm more or less here but I don't know about NDP
10:25:43 <heavensrevenge> is the execution distrobution the bottleneck, or is the method of distrobution??
10:26:16 <chrisdone> does ghci automatically encode strings to utf8 before printing values?
10:26:42 <heavensrevenge> awe, NDP is really fascinating me right now
10:26:49 <Twey> chrisdone: No
10:26:54 <Twey> IIRC.
10:27:07 <chrisdone> what's the cause of the behaviour above?
10:27:38 <chrisdone> *Lambdabot.Url GOA> putStrLn ['','']
10:27:38 <chrisdone> 
10:27:39 <Baughn> chrisdone: It prints characters mod 256
10:28:05 <Twey> Hmm
10:28:14 <Baughn> chrisdone: Pretending your locale is latin-1, I guess. If your terminal is actually expecting utf-8, that can still produce valid utf-8 sequences in some cases
10:28:30 <Twey> > "http://www.google.com/search?q=foo&sourceid=mozilla-search&start=0&start=0&ie=utf-8&oe=utf-8&client=mozilla&rls=org.mozilla:en-US:unofficial"
10:28:32 <MyCatVerbs> chrisdone: you're putting in the bytes corresponding to the UTF8 encoding of the lambda character. When putStrLn spits them out (dumbly, mod 256) your terminal is interpreting the output using UTF8, causing it to display the lambda glyph.
10:28:32 <Baughn> chrisdone: Install the utf8-string package and use System.IO.UTF8 instead
10:28:35 <lambdabot>  "http://www.google.com/search?q=foo&sourceid=mozilla-search&start=0&start=0&...
10:28:35 <lambdabot> Title: foo - Google Search, http://tinyurl.com/64kz64
10:33:55 <chrisdone> ah, I see
10:34:33 <chrisdone> Baughn: that would explain why  was printing correctly but not 
10:34:53 <chrisdone> Baughn: er, the other way round
10:34:54 <Baughn> chrisdone: Well, it wasn't printing correctly
10:35:04 <chrisdone> right
10:35:15 <Baughn> You input , so it should have printed  as well
10:35:35 <chrisdone>  only takes up one char in both encodings, I think
10:35:53 <mauke> s/char/byte/?
10:36:40 <chrisdone> hm, nevermind. it's difficult to reason about it with all these layers and conversions
10:36:49 <heavensrevenge> i think i know how to get the distribution algorithm for a balanced execution model
10:37:04 <Baughn> No,  is code-point 187
10:37:10 <chrisdone> right
10:37:12 <Baughn> That'd be at least two chars in utf-8
10:37:17 <Baughn> Er. Two bytes.
10:37:19 <Baughn> One char.
10:37:55 <Baughn> heavensrevenge: I always liked the "throw work at them as fast as they can do it" version
10:38:27 <chrisdone> I'm trying to figure out the encoding issue with this title display
10:38:29 <chrisdone> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
10:38:30 <lambdabot> Title: ondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
10:38:33 <Baughn> Unless you're looking to balance when they've got less work than computers.. which is a bad idea for power-saving purposes
10:38:39 <heavensrevenge> no, more like, if in a grid, have a node measure itself
10:38:50 <heavensrevenge> and relay its computation ratio to the master node
10:38:54 <lelf>    ->   file code: #xCE #xBB (encoded by coding system utf-8)
10:39:22 <heavensrevenge> once the #'s stop incrementing, or does so at a constant speed from any node, then it should be perfectly blanced
10:39:25 <lelf>  is 0xce ,  is 0xbb
10:39:31 <heavensrevenge> able to be mapped onto a linear execution model
10:40:06 <chrisdone> lelf: yeah
10:41:31 <heavensrevenge> is that simon peyton jones ever in here??
10:41:57 <Zao> Mostly on the lists, I believe.
10:42:07 <MyCatVerbs> Nope. Just the lists.
10:42:24 <Zao> It's probably as good as IRC is a big productivity sink.
10:43:36 <heavensrevenge> so hes only on the newsgroups??
10:44:03 <heavensrevenge> thus far i would only be able to contact him via google groups if thats the case
10:44:14 <heavensrevenge> or directly by email
10:44:59 <heavensrevenge> NDP is just so fascinating :)
10:45:21 <heavensrevenge> its the stuff i would look forward to doing for fun :P
10:54:10 <jganetsk_> i've asked the question about simon peyton jones before
10:54:17 <jganetsk_> being in here
10:54:21 <jganetsk_> the response was "yes"
10:54:58 <jganetsk_> so, i have a friend who is a veteran haskell programmer
10:55:09 <jganetsk_> he claims that laziness is a mistake, and is considered so by simon peyton jones
10:55:10 <jganetsk_> is this true?
10:55:22 <mauke> no
10:55:24 <jganetsk_> do you find yourselves frequently fighting against laziness?
10:55:31 <czShadoW> No.
10:56:01 <jganetsk_> so, this discussion came up in the context of a program we wrote
10:56:13 <jganetsk_> which parses 1.5 million lines of text
10:56:21 <jganetsk_> and, in order to fold over it
10:56:33 <jganetsk_> we apparently have to use strictness
10:56:43 <chrisdone> gwern: are you a b maintainer?
10:56:51 <jganetsk_> and, it just seems that there's no way to make that fold lazy
10:57:02 <jganetsk_> so, is this something i'm gonna have to deal with, in the future?
10:57:09 <jganetsk_> parts of the program that can't be made lazy?
10:57:28 <Cale> heavensrevenge: by lists, they mean mailing lists.
10:57:40 <jganetsk_> i'm a n00b haskell programmer, btw
10:58:02 <heavensrevenge> ok thanks Cale
10:58:20 <Cale> jganetsk_: Strictness has its place, but laziness is a sane default.
10:58:59 <Cale> jganetsk_: Essentially the *only* place you want strictness is when you're taking large clumps of data and summarizing it into a small piece of data somehow (and not just by searching through it)
10:59:23 <heavensrevenge> forgive me as im just watching the NDP videos now and im all excited about such a fun task
10:59:24 <chrisdone> cale: hey, I think I have a fix for that title encoding problem, can you pull the patch from me, when you're not busy? http://chrisdone.com/lambdabot/
10:59:25 <lambdabot> Title: Index of /lambdabot/
10:59:29 <Cale> sure
10:59:46 <DRMacIver> Of course, that "only" covers a multitude of sins and programs. :)
11:00:30 <sw17ch> jganetsk_, sounds like you want Data.ByteString.Lazy.Char8.lines
11:00:50 <sw17ch> wai,t no, never mind
11:01:38 <Cale> gwern: you really should let me know when you push patches to the lambdabot repo, so that they can be tested in the real lambdabot :)
11:01:39 <jganetsk_> so, my buddy had drowned the program in strictness annotations
11:01:50 <jganetsk_> i rewrote it witohut strictness annotations
11:01:50 <jganetsk_> but
11:01:53 <Cale> jganetsk_: That's usually the wrong way to go about it :)
11:02:07 <Cale> jganetsk_: You carefully add strictness annotations only where needed :)
11:02:08 <jganetsk_> called a library function which itself used a struct foldl
11:02:17 <Cale> okay
11:02:18 <jganetsk_> strict foldl
11:02:23 <mauke> a.k.a. foldl'
11:02:26 <chrisdone> cale: cool :)
11:02:41 <jganetsk_> yeah, but it was Data.IntMap so it had another function called foldlStrict
11:02:46 <jganetsk_> for the specific data structure
11:02:50 <Cale> right
11:02:53 <jganetsk_> so
11:03:01 <jganetsk_> to me, that seemed both pleasing and disapponting
11:03:05 <jganetsk_> that i had merely hidden the strictness
11:03:14 <jganetsk_> but had removed all traces of it from my code
11:03:16 <Cale> Strictness is important in certain places.
11:03:41 <Cale> Putting it in combinators is the best thing that can be done, apart from making a very smart compiler.
11:03:59 <Cale> GHC is getting better at strictness analysis, but it will never be perfect.
11:04:02 <thoughtpolice> i can't remember who summarised it but I liked it: strictness is part of your algorithm, it's not an optimization strategy and shouldn't be treated that way
11:04:34 <jganetsk_> so i can't go through life ignoring evaluation order, i have to think about it
11:04:34 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
11:04:42 <lambdabot> Title: ondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
11:04:44 <Cale> jganetsk_: a bit, at least.
11:04:58 <Cale> chrisdone: looks like there's another small problem there :)
11:06:07 <Cale> jganetsk_: The heuristic to apply is that when you're collapsing lots of data down to something with few separately-evaluable parts, that's where you'll want a bit of strictness, to avoid building up a large expression as you go.
11:06:10 <noecksit> im in the process of revising my resume, what would be the best approach to wording on my knowledge of category theory? i know about monads and app functors, but not much beyond that, and am not familiar with the theoretical background
11:06:18 <thoughtpolice> jganetsk_: I've found laziness to be a sane default, but yes, you have to pay a bit of attention. heh, the other day I really had my 'lazy epiphany' when working on something.
11:06:34 <andun> i'm trying to build yi from darcs. i did a 'cabal install yi' to get the dependencies, but Setup.hs in yi won't find the packages from cabal-install. any ideas?
11:06:45 <thoughtpolice> andun: configure with --user
11:06:55 <andun> aha! thanks :)
11:07:05 <thoughtpolice> by default cabal won't read user-package repositories which is what cabal-install installs to by default
11:07:10 <jganetsk_> so, i had a n00b question about seq
11:07:18 <Cale> noecksit: well, you might say that you're familiar with monadic and applicative approaches to library construction :)
11:07:21 <noecksit> i wrote "monads, applicative functors" but my friend told me that noone would know what that is, so i think itll be "Category Theory Applications"
11:07:23 <jganetsk_> does it force deeply
11:07:27 <jganetsk_> or does it just force into WHNF
11:07:41 <sal23> chrisdone:  goa.tar.gz on your page is packaged with symlink from "goa" to "/home/chris/goa" which prevents tar from unzipping it
11:07:42 <chrisdone> cale: god dang it!
11:07:43 <Cale> noecksit: Do many people know what category theory is?
11:07:54 <chrisdone> sal23: oh, crap. let me fix that
11:07:55 <Cale> jganetsk_: WHNF
11:07:56 <thoughtpolice> seq goes to WHNF
11:08:16 <thoughtpolice> there is deepSeq which will go to full normal-form but i'm not sure of its state
11:08:16 <sal23> chrisdone: tell me when you are done...I will download again
11:08:28 <hackage> Uploaded to hackage: swf 1.0.1
11:08:28 <hackage> Uploaded to hackage: swf 1.0
11:08:28 <hackage> Uploaded to hackage: topkata 0.2
11:08:29 <hackage> Uploaded to hackage: ghc-core 0.3.0.1
11:08:31 <hackage> Uploaded to hackage: permutation 0.1
11:08:39 <Cale> jganetsk_: For instance, on Maybe-types, seq x y is roughly equivalent to  case x of Nothing -> y; _ -> y
11:08:42 <noecksit> Cale : i think when someone mentions "category theory" theyll surmise that it has something to do with math theories but monads and app functors mean absolutely nothing
11:08:48 <chrisdone> sal23: k, redownload
11:08:54 <mauke> argh
11:09:07 <mauke> hackage needs to be fixed
11:09:14 <Cale> mauke: hm?
11:09:14 <chrisdone> mauke: huh?
11:09:17 <yitz> noecksit: what are you applying for?
11:09:19 <noecksit> they might think its some obscure library that noone uses
11:09:56 <noecksit> yitz : its a general resume but the job is for Lockheed & Martin
11:10:09 <mauke> it should announce stuff in the form:  * hackage upload: permutation 0.1, ghc-core 0.3.0.1, topkata 0.2, swf 1.0, swf 1.0.1
11:10:13 <jganetsk_> noecksit: and tehy are looking for category theory/Haskell?
11:10:17 <mauke> i.e. using a CTCP ACTION
11:10:55 <yitz> noecksit: my guess is that if you mention Haskell and monads, you'll get your mileage out of that.
11:11:06 <mauke> if possible, it should avoid multiple messages
11:11:20 <chrisdone> Cale: I tested that code on my terminal
11:11:21 <noecksit> jganetsk_ : no, theyre not, but i still think itd be nice to mention it
11:11:29 <chrisdone> *Lambdabot.Url GOA System.IO.UTF8> runWebReq (urlPageTitle "http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/") Nothing => Just "Title: \955ondon HUG \187 Blog Archive \187 Nested Data Parallelism Video Returns!"
11:11:32 <Cale> mauke: I was thinking that if it's going to post multiple messages, it could at least post links to the packages
11:11:40 <chrisdone> Cale: I guess there must be another layer of encoding wrapped around b's output
11:11:48 <Cale> mauke: It should also probably avoid multiple announces on the same package.
11:11:58 <chrisdone> Cale: you'd agree that string shows the right values, \955 is 
11:12:08 <mauke> Cale: I don't care about that, but it should at least get the order right
11:13:01 <Cale> chrisdone: The usual I/O functions don't support unicode encoding in any way. You need to UTF-8 encode the string yourself.
11:13:39 <chrisdone> cale: I meant didn't someone provide a utf8 patch for b?
11:14:02 <dcoutts> andun: or just use cabal-install always rather than runhaskell Setup.hs, cabal-install completely replaces the runhaskell Setup.hs interface (and uses more sensible defaults)
11:14:51 <andun> so i can use cabal-install with a darcs repository?
11:15:01 <dcoutts> andun: yes
11:15:01 <chrisdone> cale: can you pull again once more? I've added encodeString.. have a hunch.. if this is wrong I'll take a long look at b's output code
11:15:02 <dino-> Does cabal-install run the test and haddock targets? I've gotten into the habit of always doing those before install.
11:15:17 <dino-> It's great to have local API doc.
11:15:19 <pozic> dino-: there is an option for that.
11:15:27 <dcoutts> dino-: it has exactly the interface that runhaskell Setup.hs has, plus some extra stuff
11:15:52 <Cale> chrisdone: that doesn't build
11:15:58 <dcoutts> dino-: so cabal configure; cabal build; cabal haddock  will work fine
11:16:11 <dino-> But a lot of INSTALL instructions for things tell you to do configure, build, install and leave out test and haddock. I was just wondering which targets cabal-install does by default.
11:16:29 <chrisdone> cale: bah, wasn't concentrating. sorry
11:16:49 <dcoutts> dino-: the install command does not do haddock docs by default, it's an oft-requested feature
11:17:19 <dcoutts> mmmdonuts: you're getting the same problem. cabal-install uses --user by default. So use cabal-install or if you really want to use runhaskell Setup then you need configure with --user
11:17:27 <chrisdone> Cale: okay, /this/ builds
11:17:41 <dino-> ok, thank you
11:18:11 <chrisdone> cale: are you using a complete clean and build process? I wouldn't want you waiting around for it to build
11:18:28 <Cale> yeah, I am.
11:18:38 <chrisdone> ._.
11:18:51 <Cale> It's fine.
11:18:57 <Cale> It builds quickly enough :)
11:19:04 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
11:19:11 <chrisdone> cool
11:19:11 <lambdabot> Title: ondon HUG  Blog Archive  Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
11:19:13 <chrisdone> yaaaay
11:19:16 <Cale> Hooray!
11:19:27 <chrisdone> thanks, cale :)
11:19:54 <Cale> http://ja.wikipedia.org/wiki/
11:19:59 <chrisdone> oh lawd
11:20:12 <chrisdone> I doubt that is recognised as a URL
11:20:41 <Cale> http://www.google.co.jp/
11:20:51 <lambdabot> Title: Google
11:20:55 <chrisdone> haha
11:20:56 <Cale> huh.
11:20:58 <chrisdone> localised?
11:21:00 <Cale> oh, right
11:21:01 <mapreduce> > "120"
11:21:09 <lambdabot>  "\163\&120"
11:21:12 <chrisdone> http://google.com/search?lh=jp
11:21:23 <lambdabot> Title: Google
11:21:29 <Cale> Somehow it shows up in the google listings as Google , but that's not the actual page title.
11:21:49 <chrisdone> ah
11:21:49 <Cale> http://www.boj.or.jp/
11:21:57 <lambdabot> Title: {s
11:21:57 <chrisdone> http://www.google.co.jp/search?hl=ja
11:22:00 <Cale> hehe
11:22:03 <lambdabot> Title: Google
11:22:04 <chrisdone> aww nooo
11:22:25 <Cale> Oh, that page is Shift JIS
11:22:27 <Cale> heh
11:22:37 <chrisdone> text/html; charset=Shift_JIS
11:22:39 <chrisdone> heh, yeah
11:22:43 <Cale> I wouldn't expect it to support that :)
11:23:03 <Cale> I wonder if I can find a page in unicode with a japanese title :)
11:24:32 <BCoppens> http://www.mainichi.co.jp/
11:25:00 <chrisdone> http://chrisdone.com/ja.html
11:25:00 <lambdabot> Title: 
11:25:04 <chrisdone> ^_^
11:25:07 <Cale> hooray :)
11:25:16 <BCoppens> why didn't my link work? :(
11:25:22 <Cale> I don't know
11:25:28 <Cale> http://ja.wikipedia.org/wiki/
11:25:29 <lambdabot> Title:  - Wikipedia
11:25:36 <chrisdone> yours was Shift_JIS
11:25:55 <BCoppens> ah
11:26:08 <lelf> http://www.haskell.ru/
11:26:09 <chrisdone> the characters are different
11:26:09 <lambdabot> Title:   Haskell 98
11:26:35 <chrisdone> that displays like that in my browser
11:26:50 <lelf> not utf-8
11:26:53 <chrisdone> aye
11:27:57 <dcoutts> any OSX users here? can anyone tell me how OSX deals with per-user ~/bin dirs? is it on the $PATH by default ?
11:28:35 <Cale> That's KOI8-R
11:28:57 <Cale> It would be nice to have a Haskell library which did semi-intelligent detection of encoding :)
11:29:32 <Cale> "Please just turn this into a unicode string." :)
11:29:39 <lelf> http://www.wikia.com/wiki/Absurdopedia
11:29:40 <lambdabot> Title:  - Wikis from Wikia - Join the best wiki communities
11:29:45 <BCoppens> Cale: well for http it could look at the headers/meta info?
11:29:49 <lelf> good :)
11:29:59 <BCoppens> http/html, that is
11:30:54 <Cale> BCoppens: yeah
11:31:31 <Cale> BCoppens: I think Firefox does a bunch of magic to try and figure out a good encoding when that information isn't present though.
11:31:44 <BCoppens> Cale: as does KDE, somewhere
11:31:46 <Deewiant> and it has to do some detection anyway, since the information is often wrong
11:32:02 <BCoppens> but the detection isn't infallible either ;)
11:34:17 <BCoppens> Cale: http://websvn.kde.org/trunk/KDE/kdelibs/kdecore/localization/ <- for kde
11:34:18 <lambdabot> Title: Index of /trunk/KDE/kdelibs/kdecore/localization
11:34:37 <BCoppens> but that's C++/Qt
11:34:59 <enso> hello
11:35:14 <dmwit> Hiya, enso!
11:35:16 <dmwit> ?unmtl Cont
11:35:17 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
11:35:17 <BCoppens> although presumably the code comes a bit from everywhere, so it might as well be regular C and Qtless ;)
11:35:26 <dmwit> ?unmtl Cont a
11:35:26 <lambdabot> err: `Cont a' is not applied to enough arguments, giving `/\A. (A -> a) -> a'
11:35:29 <kpreid> dcoutts: neither ~/bin nor /usr/local/bin are on the default PATH
11:35:29 <dmwit> ?unmtl Cont a b
11:35:29 <lambdabot> (b -> a) -> a
11:35:31 <EvilTerran> ... what?
11:35:38 <Cale> I find that Firefox's detection often produces strange results on pages with Japanese where some English letters are replaced by halfwidth kana.
11:35:41 <EvilTerran> ah, /\ is type lambda
11:36:04 <Deewiant> is that real syntax?
11:36:14 <Cale> Deewiant: not for GHC
11:36:15 <dcoutts> kpreid: does OSX put it on the path if ~/bin exists like some other distros do?
11:36:15 <EvilTerran> no
11:36:28 <gwern> Cale: why, did I break lambdabot?
11:36:29 <gwern> Cale: btw, the quotes are still being added, so don't flush/patch yet
11:36:31 <kpreid> dcoutts: no, I have to add it
11:36:33 <dmwit> Firefox' detection sucks.
11:36:34 <enso> hello dmwit
11:36:44 <kpreid> dcoutts: the default path is /usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin, I think
11:36:45 <mar77a> let act = getLine >> (\x -> read (x::Int))
11:36:50 <mar77a> help :)
11:36:51 <gwern> @quote
11:36:51 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
11:36:51 <lambdabot> Haskell
11:36:52 <Cale> gwern: no, it's just I realised you submitted about 10 patches :)
11:37:01 <kpreid> wait, /usr/local/bin is in that .. must be new in 10.5
11:37:04 <dmwit> mar77a: let act = readLn
11:37:06 <dcoutts> kpreid: ok, so /usr/local/bin but no per-user dir
11:37:08 <gwern> uh oh. did I kill lambdabot?
11:37:10 <gwern> @quote
11:37:10 <lambdabot> jcreigh says: 99 times out of 100.0000000000000000032467823764876238476, you're better off without floats.
11:37:11 <gwern> @quote
11:37:11 <lambdabot> SeanRussell says: [Seen on the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
11:37:11 <lambdabot> Haskell.
11:37:15 <dmwit> :t readLn
11:37:16 <lambdabot> forall a. (Read a) => IO a
11:37:22 <Cale> gwern: I had to pull in order to apply someone else's patch.
11:37:25 <mar77a> same error
11:37:28 <dcoutts> kpreid: and users are expected to edit ~/.bash_profile or something are they?
11:37:34 <mar77a> or...
11:37:40 <EvilTerran> mar77a, (read x) :: Int
11:37:43 <EvilTerran> not read (x :: Int)
11:37:47 <lelf> > let =0 in 
11:37:48 <lambdabot>  0
11:37:51 <EvilTerran> if you're passing it to read, it's got to be a String
11:37:56 <dmwit> mar77a: Or: fmap (read :: String -> Int) getLine
11:38:03 <EvilTerran> indeed
11:38:09 <chrisdone> > let  = 0 in 0
11:38:09 <lambdabot>  Illegal character ''\215''
11:38:09 <lambdabot>  at "" (column 5)
11:38:13 <Cale> > let  = pi in showCReal 100 
11:38:14 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
11:38:23 <dmwit> EvilTerran: Even then it won't work, he's not return-ing it.
11:38:27 <Deewiant> > let () = 0 in ()
11:38:27 <lambdabot>  Illegal character ''\215''
11:38:27 <lambdabot>  at ")" (column 6)
11:38:42 <chrisdone> Deewiant: 'tis a b problem
11:38:46 <dcoutts> kpreid: so as an OSX user, do you think cabal's default should be to install into the home dir somewhere and require users to edit their path, or to use sudo to install to /usr/local ?
11:38:47 <EvilTerran> dmwit, ah, true
11:38:51 <Deewiant> chrisdone: yes, as usual :-/
11:39:02 <chrisdone> Deewiant: bitchy!
11:39:18 <chrisdone> ^_<
11:39:21 <Deewiant> the bot loses more of its mind with every passing day
11:39:32 <Deewiant> ?ty \x -> foo
11:39:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
11:39:36 <Deewiant> this worked last week
11:39:37 <lelf> > let ()=(.) in (+1)(+1) $ 1
11:39:37 <lambdabot>  Illegal character ''\8728''
11:39:37 <lambdabot>  at ")=(...." (column 6)
11:40:08 <kpreid> dcoutts: /usr/local, but find out whether /usr/local is typically writable by admin, and if so, don't sudo
11:40:20 <Cale> > let _ = 0 in _
11:40:20 <lambdabot>  Illegal character ''\9681''
11:40:20 <lambdabot>  at "_" (column 5)
11:40:28 <EvilTerran> dcoutts, i'd put it in ~/bin if it exists, otherwise do the other
11:40:44 <mar77a> :t (>>)
11:40:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:40:48 <kpreid> dcoutts: or rather, whether /usr/local/{bin,lib} etc are writable...
11:40:48 <mar77a> :t (>>=)
11:40:49 <gwern> > let () = (+) in  5 5
11:40:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:40:50 <lambdabot>  10
11:41:01 <dcoutts> EvilTerran: if it exists and is on the $PATH
11:41:04 <dcoutts> kpreid: right
11:41:06 <EvilTerran> yes
11:41:33 <chrisdone> gwern: Nez!!!!!!
11:41:46 <Deewiant> > let nez = 1 in nez
11:41:47 <lambdabot>  1
11:42:07 <enso> nubbish question: does "StateT s [] a" make sense when you can do "State s [a]" ?
11:42:09 <chrisdone> http://pbfcomics.com/archive_b/PBF145-Nunez.jpg
11:42:15 <lelf> > let =2 in +
11:42:16 <lambdabot>  4
11:42:24 <kpreid> dcoutts: fwiw, my habit is to install everything on a custom prefix and symlink it from /usr/local, so I can uninstall without hunting up a file list later
11:42:26 <dmwit> enso: Sometimes, yes.
11:42:33 <dmwit> err...
11:42:40 <dmwit> ?unmtl StateT s [] a
11:42:40 <lambdabot> s -> [(a, s)]
11:42:43 <kpreid> so I appreciate installers that make it easy to control the prefix.
11:42:51 <enso> can you explain the difference?
11:42:54 <dmwit> enso: See, each result has a potentially different state.
11:42:59 <enso> ah
11:43:07 <dcoutts> kpreid: it can be set through the ~/.cabal/config
11:43:07 <Cale> enso: It's a different thing... [] is a type-constructor parameter to StateT
11:43:18 <Cale> :k StateT
11:43:19 <lambdabot> * -> (* -> *) -> * -> *
11:43:25 <dcoutts> kpreid: what does this report for you: ghc -e 'System.Posix.Files.fileAccess "/usr/local/bin" True True True'
11:43:27 <Cale> :k StateT s
11:43:42 <Cale> ...
11:43:45 <Cale> :k StateT Int
11:43:46 <lambdabot> (* -> *) -> * -> *
11:43:48 <Cale> :k StateT Int []
11:43:49 <lambdabot> * -> *
11:43:55 <dcoutts> kpreid: for me I get False when running as me and True when I sudo it
11:43:55 <Cale> :k StateT Int [] Int
11:43:56 <lambdabot> *
11:44:22 <dmwit> :k StateT s
11:44:27 <Deewiant> @check id
11:44:28 <lambdabot>   Not in scope: `myquickcheck''
11:44:34 <dmwit> :k StateT S
11:44:34 <Deewiant> now quickcheck is gone too
11:44:40 <Deewiant> that worked yesterday, I think. :-P
11:44:41 <Cale> hmm
11:44:49 * Cale blames gwern :)
11:44:55 <enso> so, to summarize, "StateT s [] a" means there can be "multiple states" for each computation where State s [a] means the state is consistent but the results can be "multiple" results for a given state?
11:44:56 <newsham> hey dcoutts: re: performance I'm looking for -- nothing in particular, just curious to see how far it can go
11:45:00 <dcoutts> kpreid: so cabal-install can install to any prefix and I've just added a feature to allow adding symlinks from some other dir
11:45:02 <Cale> (well, I pulled his patches I suppose :)
11:45:04 <Deewiant> > "My mind is going. I can feel it."
11:45:05 <lambdabot>  "My mind is going. I can feel it."
11:45:11 <dcoutts> newsham: right
11:45:22 <dmwit> enso: The second half is correct.
11:45:36 <dcoutts> newsham: so in my experience we can push it further than my LAN can take :-)
11:45:40 <enso> first part "multiple states and solutions" ?
11:45:41 <EvilTerran> ?unmtl ListT (State s) a
11:45:41 <lambdabot> s -> ([a], s)
11:45:51 <Cale> enso: It's a nondeterminism monad with state, such that backtracking causes the state to backtrack too.
11:45:51 <dmwit> enso: yeah
11:45:52 <EvilTerran> ?unmtl State s [a]
11:45:52 <lambdabot> s -> ([a], s)
11:45:54 <kpreid> dcoutts: False, but if I run it as my admin account, True
11:46:01 <enso> ok
11:46:07 <enso> I think I've got it
11:46:11 <EvilTerran> ?unmtl StateT s [] a
11:46:11 <lambdabot> s -> [(a, s)]
11:46:19 <kpreid> dcoutts: but I have no idea whether my /usr/local/... perms are typical
11:46:22 <newsham> i shold measure the request/response sizes to see what bw we're talking about
11:46:31 <Cale> enso: For that reason, it's a handy monad in which to do things like searching for a solution to a puzzle (where the puzzle's state is the state in the monad)
11:46:36 <dcoutts> kpreid: they sound typical
11:46:52 <newsham> it would be nice if it could outperform something like mysql.
11:47:06 <dcoutts> newsham: you're using apache-bench right ?
11:47:13 <enso> right, what I've been able to find online mentioned the computation "forking" but I didn't put 2 and 2 together
11:47:16 <dcoutts> newsham: or you've not got a http server at all
11:47:19 <newsham> nope, not using apache-bench.
11:47:26 <enso> ...for StateT s [] a that is
11:47:30 <Cale> @unmtl State s [] a
11:47:30 <newsham> its all custom Data.Binary protocol.
11:47:30 <lambdabot> err: `s -> ([], s)' is not a type function.
11:47:36 <Cale> @unmtl StateT s [] a
11:47:40 <Cale> (oops)
11:47:40 <lambdabot> s -> [(a, s)]
11:47:40 <Deewiant> ?unmtl StateT s [] x
11:47:40 <dcoutts> newsham: right
11:47:44 <lambdabot> s -> [(x, s)]
11:48:07 <enso> I assume the fancy unmtl doesn't exist in ghc/hugs.  That's handy
11:48:08 <Cale> enso: So, under the hood, it's a function from states to lists of value, new-state pairs :)
11:48:17 <Deewiant> ?unmtl a b c
11:48:17 <lambdabot> a b c
11:48:18 * dmwit wonders how many more times we'll unmtl the same two monads
11:48:34 <enso> ?unmtl StateT s [] a
11:48:35 <lambdabot> s -> [(a, s)]
11:48:41 <dmwit> heh
11:48:41 <Deewiant> ?unmtl State s a
11:48:42 <lambdabot> s -> (a, s)
11:48:42 * enso winks
11:48:51 <Deewiant> any combination we missed? :-P
11:48:53 <Cale> @unmtl ContT r (StateT s []) a
11:48:53 <lambdabot> (a -> s -> [(r, s)]) -> s -> [(r, s)]
11:49:00 <Deewiant> my eyes!
11:49:07 <enso> well that's different entirely
11:49:14 <chessguy> @unmtl Cont a b
11:49:14 <lambdabot> (b -> a) -> a
11:49:18 <dmwit> ?unmtl StateT s Id [a]
11:49:18 <lambdabot> s -> Id ([a], s)
11:49:33 <Cale> @unmtl ContT r m a
11:49:33 <lambdabot> (a -> m r) -> m r
11:49:45 <Deewiant> @unmtl ContT a (ContT b []) c
11:49:45 <lambdabot> (c -> (a -> [b]) -> [b]) -> (a -> [b]) -> [b]
11:49:47 <enso> repeat: I assume "unmtl" doesn't exist in ghc/hugs. is that true?
11:49:53 <Deewiant> enso: yes.
11:50:01 <enso> bah. :(
11:50:01 <Cale> enso: right.
11:50:05 <dmwit> enso: You can get GHCi on Acid, which puts \bot into GHCi.
11:50:13 <enso> ooh
11:50:14 <Cale> enso: However, you can :info the various constructors
11:50:16 <enso> acid
11:50:43 <enso> ah
11:50:50 <enso> thanks for the tip
11:50:50 <mapreduce> I'm not sure that's good acid.
11:50:50 <Cale> enso: Of course, that will require you to put the answer together yourself :)
11:51:11 * dmhouse is amazed at `telnet towel.blinkenlights.nl`
11:51:17 <Cale> gwern: Should I leave it up to you to fix @check? :)
11:51:20 <jganetsk_> hey, can someone point me to a good source to start learning about STM?
11:51:37 <Cale> jganetsk_: The original paper by SPJ is great
11:51:39 <mauke> there was this video
11:51:39 <enso> I'm trying to learn haskell again. I started a year ago, took a break after a couple months, and am trying again.
11:51:42 <mapreduce> @go software transactional memory
11:51:43 <lambdabot> http://en.wikipedia.org/wiki/Software_transactional_memory
11:51:43 <lambdabot> Title: Software transactional memory - Wikipedia, the free encyclopedia
11:51:50 <enso> so I' have to "relearn" all this stuff
11:52:01 <Cale> enso: Hanging out here is a good idea :)
11:52:03 <mauke> @go peyton jones stm talk video
11:52:03 <dmwit> It goes more quickly and smoothly the second time.
11:52:04 <lambdabot> http://blip.tv/file/317758
11:52:04 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones
11:52:06 <enso> I'm happy to report it's going much more smoothly this time
11:52:07 <mapreduce> enso: Real-World Haskell
11:52:13 <Cale> http://research.microsoft.com/~simonpj/papers/stm/
11:52:14 <lambdabot> Title: Papers on transactional memory
11:52:22 <Deewiant> Cale, gwern: and @scheck and @type while you're at it. ;-)
11:52:22 <jganetsk_> nice
11:52:24 <jganetsk_> thanks
11:52:33 <Cale> @type isn't working?
11:52:33 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
11:52:37 <Cale> @type foldr
11:52:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:52:47 <Deewiant> Cale: it doesn't give error messages any more.
11:52:48 <dmwit> dmhouse: O_o
11:52:49 <Cale> ah
11:52:51 <Cale> Right.
11:52:56 <Deewiant> only that "invalid ghci output".
11:53:12 <enso> you mean I have to buy a book mapreduce ? gasp.
11:53:17 <enso> :)
11:53:31 <Cale> gwern is working on a nice organised system to replace all of lambdabot's evaluation features.
11:53:40 <Cale> So it should be nice and fixed soon enough.
11:53:47 <chrisdone> ^_^!
11:54:20 <lispy> was someone looking for me?
11:54:49 <enso> anyone else recommend that book? "Real World Haskell"
11:54:58 <EvilTerran> lispy, i think you may've been used as an adjective
11:55:01 <dmwit> enso: It seems nice.
11:55:05 <lispy> EvilTerran: ah could be
11:55:08 <dmwit> Lots of people like it.
11:55:09 <enso> I'm not shy about buying O'Reilly books.
11:55:16 <dmwit> It's not out yet, is it?
11:55:19 <newsham> 4500 req/sec at 29bytes req, 58 byte resp is about 391kB/sec
11:55:25 <Deewiant> nope, it's not
11:55:26 <lispy> enso: I think the community feels that book is very good and valuable
11:55:27 <dmwit> You can read the beta online, though.
11:55:30 <newsham> which is definitely doable.
11:55:35 <Deewiant> although most of it is at http://book.realworldhaskell.org/beta/
11:55:37 <lambdabot> Title: Real World Haskell
11:55:44 <newsham> for this small req/resp size it wont be saturating local lan
11:55:47 <enso> oh...so it isn't
11:55:56 <enso> (for sale yet)
11:56:04 <dmwit> ?go real world haskell beta
11:56:05 <lambdabot> http://book.realworldhaskell.org/beta/
11:56:05 <lambdabot> Title: Real World Haskell
11:56:08 <Deewiant> enso: but see the above link, you can read most of it there
11:56:34 <enso> I see that!!! THANKS!
11:56:34 <Deewiant> beta or not, it's better than most on-line tutorials
11:56:39 <enso> hah
11:56:52 <sw17ch> any word on when RWH's FFI chapter will be done?
11:57:11 <enso> amen. So far yaht and "all about monads" have been my go-to references
11:57:11 <dmwit> There's not really that much to the FFI.
11:57:28 <dmwit> I kept looking around online for more information about it, but it turns out that spec thing is pretty much all there is to it.
11:57:43 <chessguy> bos, dons_, CosmicRay  ^^
11:57:47 <dmwit> enso: You might also like the Gentle Introduction to Haskell.
11:57:54 <chessguy> sw17ch:  those 3 are the authors
11:58:06 <sw17ch> chessguy, yes, i was aware :)
11:58:15 <Cale> enso: Have you read any of my stuff on monads?
11:58:24 <sal23> enso: another good book is "The Haskell School of Expression" that I have been reading
11:58:33 <Cale> enso: http://www.haskell.org/haskellwiki/Monads_as_Computation
11:58:37 <lambdabot> Title: Monads as computation - HaskellWiki
11:58:38 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
11:58:41 <lambdabot> Title: Monads as containers - HaskellWiki
11:58:56 <Cale> Who knows, you might be past that stage already :)
11:59:28 <Cale> But I've got lots of good feedback from people about my tutorials, so I'm not ashamed to recommend them :)
11:59:30 <enso> haha, every little bit helps
11:59:42 <enso> I actually stumbled upon them yesterday
11:59:51 <enso> I didn't dive in yet though
12:00:06 <Deewiant> what's the latest word on good Control.Applicative tutorials
12:00:08 <enso> I think I'm amassing more literature than i can handle :)
12:00:50 <sw17ch> enso, haskell has no shortage of it
12:01:02 <sal23> Cale: the best one that I found on your page is http://cale.yi.org/index.php/Fold_Diagrams
12:01:04 <lambdabot> Title: Fold Diagrams - CaleWiki
12:01:07 <sw17ch> though understanding it takes some substantial effort :)
12:01:10 <sal23> I like visualizing stuff
12:01:14 <enso> yeah.
12:01:22 <enso> that's why I like haskell
12:01:28 <Deewiant> enso: add http://research.microsoft.com/~simonpj/Papers/papers.html to the list
12:01:29 <lambdabot> Title: Simon Peyton Jones: papers
12:01:45 <sw17ch> i'm really hoping for a php.net-like setup... i haven't found a language with better documentation...
12:02:01 <sw17ch> despite the fact i hate working with it... it never takesme more than a minute to find exactly waht i'm looking for
12:02:01 <enso> I have very little functional programming experience. it's definitely brain exercise
12:02:07 <sw17ch> enso, it's fun :)
12:02:18 <enso> agreed
12:03:30 <mauke> argh, no. the php docs are horrible
12:03:38 <enso> where to start Deewiant?
12:03:41 <vixey> what's good about php.net?
12:04:04 <enso> :) simonj has been busy with papers, there's no doubt
12:04:25 <sw17ch> really? 1) function doc, 2) usage examples 3) user comments
12:04:36 <mauke> the user comments are crap
12:04:40 <sw17ch> well, i know :)
12:04:44 <mauke> at least a few of the docs are crap
12:04:46 <sw17ch> but the fact that they are *there*
12:04:53 <mauke> it's completely useless as a reference manual
12:05:03 <sw17ch> mauke, wow, i've never had a problem :)
12:05:05 <Deewiant> enso: well, there's all kinds of stuff there... if there's something you want to find out about chances are he's written a paper about it ;-)
12:05:07 <mauke> e.g. you couldn't write something like your own PHP interpreter from the docs
12:05:08 <monochrom> which reference manual?
12:05:14 <vixey> most haskell libraries have 1) and 2)
12:05:15 <monochrom> oh haha
12:05:22 <mauke> sw17ch: what exactly does @ do?
12:05:26 <enso> hah fair enough Deewiant
12:05:52 <sw17ch> mauke, is taht a "go look it up" thing or a quiz?
12:06:00 <mauke> sw17ch: it's something I couldn't find
12:06:30 <Deewiant> enso: I'd say that after you have a bit more experience, http://research.microsoft.com/~simonpj/papers/marktoberdorf/ is a good read
12:06:31 <lambdabot> Title: Simon Peyton Jones: papers
12:06:56 <vixey> what does PHP stand for
12:07:06 <mauke> personal home page
12:07:16 <Deewiant> enso: along with http://research.microsoft.com/~simonpj/papers/stm/ if you're interested in concurrent stuff
12:07:17 <lambdabot> Title: Papers on transactional memory
12:07:56 <enso> I am interested. just not yet.
12:08:03 <dmhouse> mauke: are you kidding? php.net is indespensible for doing PHP development.
12:08:03 <Deewiant> :-)
12:08:08 <enso> my brain is still digesting Monads again
12:08:12 <mar77a> how can i read a number from stdin
12:08:17 <dmhouse> (I.e. development in PHP, rather than development _of_ PHP.)
12:08:20 <mauke> dmhouse: I don't do PHP development
12:08:20 <mar77a> an int
12:08:31 <mauke> I just wanted to learn PHP so I read the docs there
12:08:31 <enso> scanf ("%d", &i)
12:08:37 <sw17ch> mauke: i didn't find it that hard to find...
12:08:40 <sw17ch> http://www.php.net/manual/en/language.operators.errorcontrol.php
12:08:40 <monochrom> "indispensible" is still not sufficient
12:08:40 <enso> ...oh you meant in haskell...
12:08:41 <mauke> mar77a: readLn
12:08:42 <lambdabot> Title: PHP: Error Control Operators - Manual
12:08:46 <Deewiant> ?ty readLn
12:08:46 <lambdabot> forall a. (Read a) => IO a
12:08:49 <dmhouse> ?hoogle readIO
12:08:49 <lambdabot> Prelude.readIO :: Read a => String -> IO a
12:08:49 <lambdabot> System.IO.readIO :: Read a => String -> IO a
12:08:49 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
12:08:58 <dmhouse> Oh, err, not that.
12:08:58 <mar77a> k
12:09:16 <dmhouse> Well, I guess getLine >>= readIO might do it. But readLn is easier.
12:09:23 <enso> quite
12:09:56 <sw17ch> whereas when i first started with haskell, beginning to work with haskell the only thing i was able to easily find for (>>=) was http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:%3E%3E=
12:09:57 <lambdabot> Title: Prelude, http://tinyurl.com/65sz9o
12:10:06 <sw17ch> :\ it gave me a hard time
12:10:11 <mauke> sw17ch: that's incomplete: "When prepended to an expression in PHP, any error messages that might be generated by that expression will be ignored."
12:10:28 <sw17ch> mauke, long story short, haskell docs could be better
12:10:32 <sw17ch> a *lot* better
12:10:32 <mauke> sw17ch: how do expressions generate messages? what kind of messages are generated?
12:11:06 <sw17ch> IMHO
12:11:26 <monochrom> I think the two of you are talking cross each other.
12:11:43 * sw17ch apologizes...
12:12:02 * mauke doesn't apologize
12:12:04 <mauke> hah!
12:12:04 <vixey> sw17ch: How could they be better?
12:12:07 <sw17ch> mauke--
12:12:10 <sw17ch> hah!
12:12:12 <monochrom> One of you criticize php docs because it is insufficient to determine whether an alternative implementation is compliant or not.
12:12:12 <mauke> :-(
12:12:14 <Deewiant> sw17ch++
12:12:24 * sw17ch feels bad
12:12:26 <sw17ch> mauke++
12:12:28 <monochrom> Another of you criticize haskell docs because it is not a tutorial.
12:12:31 <Deewiant> sw17ch--
12:12:38 <Deewiant> ;-P
12:12:45 <mauke> monochrom: php docs are also insufficient to cleanly open a file
12:12:45 <monochrom> Clearly the two of you will never reach a consensus.
12:12:54 <mauke> BASIC STUFF #$@#$*
12:12:55 <sw17ch> hehe
12:12:59 <dmhouse> I do have to say, some of the PHP user-contributed notes have me literally beating my head against the desk.
12:13:04 <Deewiant> mauke: PHP cannot do anything cleanly, so that's not surprising. ;-)
12:13:09 <SamB_XP> I can tell you that the Haskell Report is not even needed in order to figure out if an implementation is compliant or not
12:13:12 <sw17ch> i guess all i'd really like is a "more info" link next to the stuff in the haskell docs
12:13:23 <SamB_XP> all you need for that is (const False)
12:13:34 <SamB_XP> (until further notice)
12:13:35 <vixey> sw17ch: which leads to what?
12:13:47 <sw17ch> something that tells me where i'd use >>=
12:13:48 <mauke> <a href="irc://chat.freenode.net/haskell">more info</a>
12:13:49 <sw17ch> or >>
12:13:59 <mar77a> ?src unlines
12:13:59 <lambdabot> unlines = concatMap (++ "\n")
12:14:03 <sw17ch> with some drawn out examples
12:14:05 <vixey> sw17ch: You need a book, not a reference manual
12:14:07 <Deewiant> SamB_XP: compliant to H98? how are the current implementations not?
12:14:07 <mar77a> how would i write an unlines with an index
12:14:14 <mar77a> something like:
12:14:19 <mar77a> line: linecontents
12:14:21 <vixey> sw17ch: they are different things for different purposes
12:14:31 <chrisdone> well, the docs tend to be useful for when they solve a problem. you think "I really need X" and find it. you don't just randomly read a page and hope it will be useful one day.. or do you?
12:14:35 <SamB_XP> Deewiant: well, most of them don't support recursive imports
12:14:44 <SamB_XP> Deewiant: and JHC is just buggy
12:14:44 <sw17ch> does the wiki have an place for documentation on libraries?
12:14:45 <dmwit> mar77a: zipWith f [1..] ls
12:14:49 <mauke> mar77a: unlines (zipWith (\n x -> show n ++ ": " ++ x) [1 ..] mylines)
12:14:55 <dmwit> mar77a: Where "f" formats a single line.
12:15:02 <Deewiant> SamB_XP: ah, that's mandated? why don't they, then?
12:15:03 * monochrom declares "docs" ambiguous and meaningless.
12:15:25 <SamB_XP> Deewiant: well the report never says it isn't allowed
12:15:30 <chrisdone> "docs" = what is generated by haddock
12:15:46 <vixey> > let lines = ["one","two"] in unlines . map (uncurry (++)) . zip (map show [1..]) $ lines
12:15:47 <lambdabot>  "1one\n2two\n"
12:16:07 <sw17ch> if i wanted to go drop an example of liftM or >>= which i would have found helpful when i first started, where could that be placed?
12:16:09 <SamB_XP> sw17ch: I think some of the haddocks link to wikipages where you can comment on the libraries/docs ?
12:16:18 <Deewiant> SamB_XP: well, in that case I'm sure one could find the report to contradict itself in an obscure recursive-imports situation. :-)
12:16:21 <mauke> sw17ch: what kind of example would you use?
12:16:58 <monochrom> >>= is as basic as +.  I don't see anyone proposing to add a + example to Prelude haddock.
12:17:03 <sw17ch> http://www.php.net/manual/en/function.split.php
12:17:03 <lambdabot> Title: PHP: split - Manual
12:17:06 <sw17ch> look at the examples there
12:17:16 <mauke> split is completely different
12:17:31 <monochrom> Hell I don't see why a php person would want a + example in php docs either :)
12:17:31 <sw17ch> mauke, replace >>= and split with any function
12:17:44 <chrisdone> monochrom: I wouldn't go that far
12:17:49 <mauke> split does something concrete that can be easily demonstrated with examples
12:17:59 <mauke> (>>=) and liftM are totally abstract operations
12:18:00 <pozic> monochrom: you obviously don't know anything about PHP.
12:18:11 <mauke> I'd say (>>=) is even more basic than (+)
12:18:23 <sw17ch> perhaps what i'm proposing is to reduce the brain effort needed to enter the language... which is perhaps why php has such a bad wrap...
12:18:31 <sw17ch> b/c the brain effort needed is significantly lower
12:18:34 <sw17ch> (also it sucks)
12:18:35 <monochrom> Anyway all monad tutorials explain >>=. That's where examples belong.
12:19:04 <monochrom> I mean if an operator is like part of the cultural backdrop of that language, it goes into tutorials.
12:19:08 <dmhouse> You can't really learn Haskell by reading Haddocks, and you shouldn't try.
12:19:36 <SamB_XP> everyone knows + from, what, 2nd grade?
12:19:48 <dmhouse> It's just the wrong way to go about learning the language. We shouldn't improve the Haddocks to the point where doing this is encouraged.
12:19:58 <sw17ch> umm... the Parsec docs
12:20:01 <sw17ch> those are excellent
12:20:13 <dmhouse> However I wouldn't say no to adding more examples.
12:20:25 <mauke> Parsec fails differently
12:20:41 <SamB_XP> yeah, haddocks are indeed not intended for learning Haskell. Haddocks for particular libraries might be intended for learning those libraries ...
12:20:42 <sw17ch> the docs on Daan's page at least
12:20:43 <dmhouse> User comments might be nice too, although how you'd tie them into the Haddocks I don't know.
12:20:44 <monochrom> I can agree with like the +++ operator of Parsec needs examples in its haddock.  +++ or Parsec is not part of the Haskell cultural backdrop.  It is an external library.
12:21:04 <SamB_XP> dmhouse: you link to the wiki pages from the haddocks
12:21:52 <sw17ch> SamB_XP, that's exactly what i'm thinking
12:22:19 <SamB_XP> I'm almost positive the ghc haddocks did this at some point
12:22:36 <sw17ch> maybe it still does, and there just isn't very much documentation
12:22:42 <sw17ch> (of the kind i'm looking for)
12:22:47 <vixey> sw17ch: You need a book
12:22:56 <vixey> sw17ch: A reference manual is no substitute
12:22:57 <SamB_XP> hackage, though, seems stuck with an earlier haddock...
12:22:58 <vixey> ever
12:23:02 <SamB_XP> sw17ch: a book?
12:23:25 <SamB_XP> what's wrong with A Gentle Introduction -- besides the name, obviously ;-)
12:23:38 <monochrom> That's a book. :)
12:24:12 * monochrom declares again "docs" ambiguous and meaningless.
12:24:13 <chrisdone> it's so gentle it came out the other side
12:24:37 * monochrom declares additionally "good docs" ambiguous and meaningless.
12:24:41 <SamB_XP> monochrom: oh, it is?
12:24:54 <sw17ch> i'd be happy if there were an example or two with each library function
12:25:07 <sw17ch> or one example that sufficiently exercises the use of the library
12:25:09 <monochrom> I'm using "book" very loosely. Also half-joke.
12:25:25 <monochrom> Example for +: 0+0
12:25:30 <sw17ch> umm... Data.Binary has some excellent examples
12:25:41 <mauke> I'd like to see an example for >>=
12:25:54 <mauke> heh, or return
12:26:12 <monochrom> Example for >>=: return () >>= return
12:26:13 <sw17ch> i see i'm not getting anywhere...
12:26:20 <monochrom> Example for return: see example for >>=
12:26:48 <mauke> I just don't believe that a rule like "every function needs an example or two" could work
12:26:54 <mauke> especially not in haskell
12:26:59 <monochrom> Yeah I'm all against that rule.
12:27:25 <mauke> they don't call it "abstract nonsense" for nothing
12:27:28 <sw17ch> well, whatever it is that Data.Binary does which makes it quite easy to understand *quickly* would greatly be appreciated elsewhere
12:27:49 <mauke> again, Data.Binary is all concrete and specific
12:27:52 <monochrom> >>= is different from Data.Binary.
12:28:01 <sw17ch> lets forget i ever said >>= then
12:28:01 <mauke> Control.Monad is a completely abstract interface
12:28:05 <monochrom> Data.Binary is not a culture unto its own.  >>= is.
12:28:44 <monochrom> You don't see javadocs having an entry for .
12:29:15 <lispy> ?hoogle xor
12:29:15 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
12:29:19 <SamB_XP> monochrom: they might if it was overloadable like in python
12:29:23 <Trinithis> Does haskell have a ternary logic package?
12:29:27 <lispy> Do we not have a Bool based xor in Haskell?
12:29:29 <monochrom> That >>= appears in library doc is because Haskell does not make operators reserved tokens, all operators go to libraries.
12:29:34 <SamB_XP> (but I bet it wouldn't be easy to find)
12:29:35 <mauke> lispy: we do, it's called (/=)
12:29:40 <sw17ch> alright, my >>= choice was wrong
12:29:52 <lispy> mauke: ah
12:30:08 <SamB_XP> maybe we should have Bits Bool ;-P
12:30:09 <monochrom> But >>= to Haskell is really like ; or . to Java.  You really need a Haskell tutorial or Java tutorial for that.  It's too versatile and too pervasive.  It's like Zen.
12:30:29 <lispy> mauke: so then should we remove (&&) because we have (==) ?
12:30:41 <opqdonut> lispy: they're different
12:30:42 <mauke> lispy: (&&) is not the same as (==)
12:30:51 <Deewiant> ?src (&&)
12:30:51 <lambdabot> True  && x = x
12:30:51 <lambdabot> False && _ = False
12:30:52 <Deewiant> ?src (==)
12:30:53 <lambdabot> x == y = not (x /= y)
12:30:54 <lispy> Ah right, beceause False == False is wrong
12:30:59 <SamB_XP> hehe
12:31:03 <dmhouse> ?src (/=)
12:31:05 <lambdabot> x /= y = not (x == y)
12:31:09 <enso> haha
12:31:09 <SamB_XP> yeah, == is the Bool version of nxor ;-P
12:31:18 <newsham> ?check \a b -> (a && b) == (a == b)
12:31:18 <lambdabot>   Not in scope: `myquickcheck''
12:31:26 <SamB_XP> enso: those are just the default implementations
12:31:32 <enso> I know.
12:31:38 <enso> still funny :)
12:31:42 <newsham> bot ?check is borked
12:31:49 <dmhouse> ?check \x y -> (x == y) /= (x `xor` y)
12:31:50 <lambdabot>   Not in scope: `myquickcheck''
12:31:56 <dmhouse> Nice.
12:32:08 <Deewiant> first ?scheck, then ?check
12:32:17 <mauke> is it cancer?
12:32:17 <Deewiant> where will it end?
12:32:22 <Deewiant> bit cancer
12:32:23 <monochrom> sw17ch: if you pick the right examples like Data.Binary or Parsec or HXT, we all agree with you.
12:32:42 <newsham> lambdabot is coming down with a case of code churn
12:32:55 <sw17ch> actually, i'm going through and looking at the built in stuff, and it's pretty good... so i'm going to retract most of my statements...
12:32:56 <ddarius> Parsec's haddocks came from the "reference" section of a tutorial.
12:32:57 <monochrom> Even Control.Monad.ap has examples.
12:33:08 <sw17ch> i'm having a hard time seeing stuff in Prelude with problems
12:33:14 <newsham> how come now lambdabot regression test SoC projects?
12:33:35 <newsham> s/now/no/
12:34:42 <lispy> newsham: sorry?
12:35:00 <lispy> no lambdabot regression test SoC projectS?
12:35:03 <newsham> how come nobody wrote a lambdabot regression test suite for their SoC project? :)
12:35:07 <lispy> what is a lambdabot regression test?
12:35:19 <monochrom> This channel.
12:35:22 <newsham> a test that makes sure lambdabot features still work after the code has been churned
12:35:34 <lispy> good question
12:35:38 <newsham> ?go regression test
12:35:39 <lambdabot> http://en.wikipedia.org/wiki/Regression_testing
12:35:39 <lambdabot> Title: Regression testing - Wikipedia, the free encyclopedia
12:36:00 <newsham> we need more free labor going towards bot development
12:36:15 <jganetsk_> does forkIO create a new thread or a new process?
12:36:17 <sw17ch> newsham, i hear they have lots of that in China
12:36:21 <newsham> new thread
12:36:39 <newsham> chinese labor approaches but does not reach free
12:37:03 <monochrom> the upside is chinese labor learns haskell quickly
12:37:04 <dmhouse> Time to play with xmonad.
12:37:25 <Deewiant> jganetsk_: not even a new OS thread
12:37:31 <newsham> mono: is that known from experience?
12:37:39 <jganetsk_> Deewiant: just a continuation?
12:37:41 <newsham> i wouldnt mind buying a lot of haskell-literate chinese labor for free
12:37:47 <monochrom> No. I know nothing.
12:37:58 <lispy> newsham: do you normally buy things for free?
12:38:05 <Deewiant> jganetsk_: a lightweight thread managed by the GHC runtime
12:38:12 <newsham> lispy: when possible.
12:38:38 <Deewiant> jganetsk_: you can have hundreds of thousands of those running at once
12:38:56 <jganetsk_> Deewiant: erlang style?
12:39:25 <Deewiant> kinda, although IIRC the benchmarks show that GHC's are even cheaper than erlang's :-)
12:39:30 <monochrom> Oh, but I have a reason to believe what I said. A lot of Chinese labor are clean slates for programming languages.
12:39:45 <kaplanmn_> exit
12:39:46 <kaplanmn_> \quti
12:39:54 <sw17ch> k, that was funny
12:40:12 <newsham> mono: surely a clean slate is no guarantee of success
12:40:25 <monochrom> who needs guarantee?
12:40:44 <newsham> also you're implying all my experience is worthless :(
12:40:55 <monochrom> @quote unlearning
12:40:55 <lambdabot> solrize says: haskell has a very steep unlearning curve :)
12:41:28 <monochrom> Cale can tell you how clean slates are more successful at haskell, even category theory.
12:41:52 <sw17ch> monochrom, i've been thinking i'll teach my wife haskell...
12:41:52 <newsham> yah, thats probably why doug mcilroy will never write any interesting haskell papers
12:42:00 <sw17ch> she's been resistant to everything else
12:42:34 <monochrom> haskell-cafe and haskell-beginner (or what is it call?) can tell you how much trouble experienced programmers have with Haskell.
12:42:49 <monochrom> As usual, throughout I'm speaking statistically.
12:43:08 <nottha_k> is it possble to define unary operators in haskell?
12:43:15 <mauke> nottha_k: no
12:43:35 <monochrom> Sorry, no.  GHC has an extension that accepts unary postfix, but still no unary prefix.
12:43:58 <newsham> mono: i've been coding C and assembly for most of my life.  haskell is no picnic, but I think I do ok.
12:44:10 <Deewiant> monochrom: which extension is that?
12:44:14 <monochrom> Yeah, you are not just a statistic :)
12:44:23 <mar77a> hooray for my second useful application in haskell
12:44:31 <Deewiant> hooray!
12:45:12 <Deewiant> monochrom: ah, never mind, it's implicitly enabled
12:45:18 <monochrom> yeah
12:45:25 <sw17ch> mar77a, i haven't been paying attention, what is it?
12:45:42 <Deewiant> > let (!) n = product [2..n] in (10!)
12:45:43 <lambdabot>  3628800
12:45:43 <mar77a> some 1337 hax pax obviously
12:45:53 <mar77a>  http://hpaste.org/9369
12:46:06 <newsham> hmm.. neat..  fake post-unary
12:46:22 * ddarius did not find his experience worthless, just not as beneficial as typically it was.
12:46:50 <chrisdone> hmm
12:46:51 <newsham> exactly.. you just gotta not be frustrated by not being able to carry over things
12:46:55 <monochrom> I have various theories to explain the statistical behaviour. Here is one.
12:47:53 <gwern> chrisdone: ah
12:48:01 <chrisdone> hmm, I want to create some directories and some files, which is a kind of tree operation
12:48:03 <monochrom> If you are either extremely unimperative (e.g. clean slate) or extremely imperative (e.g. you know your computer down to transistor level), you have less trouble with lazy evaluation.
12:48:06 <chrisdone> gwern: huh?
12:48:24 <gwern> check is broken?
12:48:27 <gwern> @check (\x -> x == x)
12:48:27 <lambdabot>   Not in scope: `myquickcheck''
12:48:32 <gwern> @check (\x -> x == x)
12:48:32 <lambdabot>   Not in scope: `myquickcheck''
12:48:36 <monochrom> If you're extremely unimperative, you take it on faith, so you're ok.
12:48:42 <gwern> Cale: we could do it right now if it weren't for a few issues like @let and the qualified imports
12:48:57 <monochrom> If you're extremely imperative, you see how even you yourself would implement lazy evaluation, so you're ok too.
12:49:50 <paczesiowa> there was proposal for split function, was it accepted?
12:49:52 <Philippa_> I'm not sure I see your 'extremely imperative' quite that simply. One can work imperatively and still at high level in terms of the commands issued, structures worked with etc
12:50:02 <Philippa_> so I guess I'd call it something else
12:50:20 <Philippa_> but yes, it's not so bad for imperative folks who're reasonably holistic in terms of high vs low level thinking
12:51:04 <monochrom> It's the middle guys, averagely imperative, who get confused, because they're used to something, but don't know enough to explain alternatives.
12:51:21 <BONUS> hey guys do you like the cover for the tutorial im writing http://kalleboo.mirror.waffleimages.com/files/b1/b126de9f5efdd9ef86acc799d69a760528a36135.png
12:51:23 <lambdabot> http://tinyurl.com/6ae7lw
12:52:28 <newsham> i think lazy evaluation is fairly easy to come to grips with
12:52:39 <newsham> purity and monads take more time to get used to
12:52:55 <newsham> also kids these days get semi-lazy with generators/coroutines in various languages
12:53:00 <dmwit> Huh, I didn't know you could import multiple modules with the same "as" name.
12:53:06 <dmwit> Makes sense, and it seems kind of nice.
12:53:12 <dmwit> mar77a++
12:55:19 <ddarius> At the level of transistors things start looking more functional again...
12:55:41 <chrisdone> BONUS: is it supposed to by like Why's guide?
12:56:03 <BONUS> hmm no
12:56:04 <sw17ch> BONUS: same question
12:56:05 <lispy> BONUS: it's cute, but you spelled Haskell 2 different ways, was that intentional?
12:56:11 <BONUS> kind of yes
12:56:20 <BONUS> but im just using the drawings to inject some humor
12:56:23 <BONUS> otherwise i hate why's guide
12:56:29 <BONUS> what im doing is pretty straightforward
12:57:03 <BONUS> no excessive jokes or wacky randomness
12:57:15 <Elly> aw :(
12:57:29 <bwr> i like why's guide
12:57:32 <Elly> I still think Why's guide is one of the best-written tutorials I've ever seen
12:57:50 <sw17ch> Elly, the only problem was that i felt bad reading it @ work
12:57:55 <sw17ch> other than that, i loved it
12:57:59 <Elly> how come?
12:57:59 <chrisdone> I found Why's extremely tedious
12:57:59 <sw17ch> really good at pointing things out
12:58:02 <dmhouse> I found it far too wordy.
12:58:04 <sw17ch> well, comics and whatnot
12:58:13 <BONUS> i found it too wordy on the jokes/comics, not wordy enough on the tutorial
12:58:14 <dmhouse> I couldn't actually learn Ruby using it.
12:58:16 <sw17ch> but that was when i'd just started.. no one gives me problems for reading comics any more :)
12:58:32 <dmhouse> I gave up when I found myself skipping past pages of text to look for the next code blockl.
12:59:19 <Elly> the guy who wrote Why's has some neat other code though
12:59:31 <BONUS> yeah i like his drawings of code
12:59:36 <oldsalt> sw17ch, you had a question about hayoo a few days ago?
13:00:09 <sw17ch> oldsalt, yeah
13:00:17 <oldsalt> what was it?
13:00:25 <sw17ch> i think it's been fixed, i had a problem where the firefox search plugin failed to do anything
13:00:31 <chrisdone> real world haskell is probably the best modern language book I've seen. it's straight to the point, lots of code, interesting, real world problems. exactly what you need to start using haskell quickly and confidently
13:00:36 <sw17ch> no.. it hasn't been fixed (or the plugin has been updated)
13:00:43 <oldsalt> ah, yes i fixed that one since chrisdone inspired me to do so
13:01:12 <sw17ch> FireBug tells me "element.attachEvent is not a function"
13:01:31 <sw17ch> oldsalt, i suppose i'll need to update the plugin?
13:01:36 <chrisdone> oldsalt: oh, it's fixed. thanks for that :)
13:02:07 <oldsalt> one day the javascript will lead to our downfall
13:02:14 <oldsalt> ;)
13:02:37 <oldsalt> sw17ch, yeah, just remove it and then, when you are on the page, open the dropdown menu and add it again
13:02:40 <oldsalt> that helped for me
13:02:45 <oldsalt> i tested ff and ie7
13:02:45 <sw17ch> oldsalt, great, thanks
13:03:27 <sw17ch> so what happens to Hoogle now?
13:03:34 <chrisdone> oldsalt: works fine for me :)
13:04:53 <sw17ch> oldsalt, actually, now the box works, but i still have the javascript error i told you
13:04:58 <sw17ch> search box in firefox i mean
13:05:13 <oldsalt> yeah, i will note it so we can fix it in the future
13:05:22 <oldsalt> unfortunately none of us likes js ;)
13:05:28 <chrisdone> Error: element.attachEvent is not a function
13:05:28 <chrisdone> Source File: http://www.holumbus.org/hayoo/hayoo/prototype.js
13:05:29 <chrisdone> Line: 3882
13:05:29 <sw17ch> oldsalt, i do
13:05:29 <chrisdone> ?
13:05:36 <sw17ch> and i know some prototype
13:06:17 <oldsalt> sw17ch, if you see a way to fix the issue, any help would be greatly appreciated
13:06:38 <sw17ch> oldsalt, update your prototype version
13:06:38 <sw17ch> 1.6.0 is a little old now
13:07:13 <sw17ch> 1.6.0.2 is the latest... i think the bug is actually from inside prototype
13:07:24 <oldsalt> ok, i will tell shag. i think it will be his business
13:07:42 <sw17ch> if i find the root cause, i'll let you know
13:07:52 <oldsalt> ok, thank you
13:08:50 <gwern> @check (\x -> x == x)
13:08:50 <lambdabot>   Not in scope: `myquickcheck''
13:08:59 <baobab> hello haskellers, I'm asking this out of ignorance... is it important to study category theory to understand haskell's types system? I recently read "category theory for computer scientists" by Pierce and I would like to read some more about category theory.. will it help me to understand monads and haskell's type system better?
13:09:10 <ddarius> No.
13:09:17 <gwern> Cale: did you re-compile/install show?
13:09:21 <EvilTerran> baobab, you've read more cat theory than most haskell programmers already
13:09:43 <ddarius> baobab: You don't need to even know of the existence of category theory to be a competent Haskell programmer.
13:10:32 <ddarius> Actually, I misread your question.  Still there are more direct routes to that information.
13:10:57 <baobab> what routes could i take?
13:11:19 <ddarius> If you want to know about Haskell's type system read about type theory.
13:11:26 <ddarius> +more
13:11:59 <gwern> @quote
13:11:59 <lambdabot> oerjan says: so does this mean that a comonad is like a wildlife preserve on an island in a sea of nuclear waste?
13:12:00 <ddarius> If you want to know more about monads in the context of Haskell read e.g. Moggi's work (which does use a decent amount of category theory) or others depending on what you want.
13:12:49 <ddarius> Learning about category theory can help with both of these but not as much as you might expect at least without a significant investment in time.
13:13:32 <ddarius> However, if you already are rather mathematically literate and you'd like to approach these things from a strongly mathematical perspective then learning CT may be a good supplement.
13:14:41 <baobab> well I don't have much time for programming due to my job, I would like to understand what is behind monads more
13:14:48 * RayNbow just stumbled on http://www.reddit.com/r/programming/comments/225f0/beautiful_haskell_implementation_of_maths_power and is amazed by its beauty
13:14:50 <lambdabot> Title: Beautiful Haskell implementation of math's "power set" : programming, http://tinyurl.com/69kglz
13:15:07 <RayNbow> although the post is old (1 year)
13:15:57 <baobab> what paper from Moggi would you suggest to me to start with?
13:20:16 <ddarius> @google "Notions of Computation"
13:20:18 <lambdabot> http://citeseer.ist.psu.edu/moggi89notions.html
13:20:18 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
13:21:05 <baobab> ddarius: thank you :)
13:23:39 <mmorrow> @seen dolio
13:23:39 <lambdabot> dolio is in #ghc, #haskell-blah and #haskell. I don't know when dolio last spoke.
13:25:05 <mmorrow> dolio: the build of head i started last night failed on account of me using 6.9 to build and the ghc-pkg 6.9 problem/bug of "you must register at least on package in the user package database" (i never use the user a user package db)
13:25:45 <mmorrow> i just restarted the build and am building with 6.8.3....i'll let you know how it goes
13:30:00 <mmorrow> @tell dolio the build of head i started last night failed on account of me using 6.9 to build and the ghc-pkg 6.9 problem/bug of "you must register at least on package in the user package database" (i never use a user package db). i just restarted building head with ghc-6.8.3 at about 15:02:41 CDT. i'll let you know.
13:30:00 <lambdabot> Consider it noted.
13:32:41 <paczesiowa> Cale: have you written more stuff for rss, or is it just hrss?
13:34:32 <mightybyte> How can I get ghci to print a list with newlines separating each element?
13:34:50 <mightybyte> I tried "concat $ intersperse "\n" $ map show a"
13:34:56 <mightybyte> But that didn't seem to work.
13:35:49 <paczesiowa> > putStrLn $ unlines ["hello", "world"]
13:35:50 <lambdabot>  <IO ()>
13:36:09 <mightybyte> Ahhh, thanks.
13:36:10 <paczesiowa> > putStr $ unlines ["hello", "world"]
13:36:11 <lambdabot>  <IO ()>
13:36:42 <paczesiowa> putStr doesn't put extra newline at the end
13:36:56 <jaj> putStrLn?
13:37:34 <mmorrow> mightybyte: importing Text.PrettyPrint then defining the following function works:
13:37:42 <mmorrow> let vlist :: (Show a) => [a] -> Doc = brackets . vcat . punctuate comma . fmap (text . show)
13:38:07 <mmorrow> ghci> let xs = [0..4]
13:38:07 <mmorrow> ghci> vlist xs
13:38:07 <mmorrow> [0,
13:38:07 <mmorrow>  1,
13:38:11 <mmorrow>  2,
13:38:13 <mmorrow>  3,
13:38:15 <mmorrow>  4]
13:38:37 <mmorrow> (i dunno if that's what you wanted though)
13:38:52 <mightybyte> mmorrow: That's a little heavier, but it's good to know.
13:38:56 <mmorrow> :)
13:39:11 <paczesiowa> and don't forget to generalize that over any stringlike thing in any functor:>
13:39:17 <mightybyte> I guess my original attempt would have worked if I had just put a putStr in front of it.
13:40:34 <mmorrow> pacszesiowa: i think i see what you're saying, but it the puncuate and vcat functions force it to be a list :(
13:41:14 <paczesiowa> I was just kidding:>
13:41:19 <mmorrow> oh, heh
13:41:29 <mmorrow> i took it seriously ;)
13:41:46 <mmorrow> (clearly)
13:41:47 <paczesiowa> I mean, it was seriously overkill
13:42:39 <mmorrow> seriously overkill just means "haven't found an easy way to do it while retaining the power yet" ;)
13:43:01 <mmorrow> (or something like that)
13:43:13 <mmorrow> (i'm groping here)
13:44:23 <mmorrow> pacszesiowa: ok, it's true that was seriously everkill :)
13:45:24 <zachk> anyone interested in trying to crash some code I wrote? privmsg me if you are
13:47:51 <gwern> now, ehre's something I don't get
13:48:05 <gwern> Why does West Point, a military academy keep showing up in CS stuff?
13:48:33 <gwern> I mean, Okasaki frequently mentions West Point in his stuff since he works there, Wired covers programming and security contests at West Point, etc.
13:48:52 <gwern> and now I start reading _Programming Pearls_ and the author thanks a West Point class for feedback!
13:48:55 <gwern> wth
13:49:06 <zachk> i went to a state science olympiad contest that was hosted at i believe west point
13:49:25 <gwern> gaugh!
13:55:04 * Botje points to the "academy" part
13:55:24 <Botje> perhaps they're training the officers there to be 31337 HAXORS
13:56:20 <pmurias> how do i convert a String to a Integer?
13:56:35 <mauke> read
13:58:28 <newsham> > let conv [(x,"")] = Just x; conv _ = Nothing; readMaybe = conv . readsPrec 0 in readMaybe "5" :: Just Int
13:58:48 <newsham> ?bot
13:59:13 <mauke> preflex: seen lambdabot
13:59:14 <preflex>  lambdabot was last seen on #haskell 23 minutes and 2 seconds ago, saying:  <IO ()>
13:59:25 <enso> is lambdabot dead?
13:59:35 <enso> ...n/m
13:59:48 <RayNbow> lambdabot is laggy :p
14:00:12 <RayNbow> @bot
14:00:29 <pmurias> newsham: thanks
14:00:30 <enso> i dunno, lambdabot seems dead to me...
14:00:44 <newsham> pmarias: the short answer is   read "5" :: Int
14:00:50 <newsham> it just doesnt have the best failure mode
14:02:34 <pmurias> newsham: i'm certain i have an integer
14:02:45 <newsham> then read is perfect for you
14:05:35 <drigz> how fast is read :: String -> Int?
14:07:54 <sw17ch> > last (map read (map show [1..1000000]) :: [Int])
14:08:07 <sw17ch> really fast for me
14:08:33 <newsham> sw17ch: that just computes one show/read, no?
14:08:47 <xd> i wouldnt think that would compute it more than once
14:08:51 <sw17ch> newsham, dangit...
14:09:00 * sw17ch got caught by the lazy monster 
14:09:04 <newsham> do a sum of the result
14:09:23 <sw17ch> stack overflow :(
14:09:44 <sw17ch> 100,000 isn't too bad interpreted
14:09:49 <enso> maximum?
14:10:23 <sw17ch> a few seconds
14:11:26 <enso> ha. I meant would maximum $ map (read) $ map (show) [1..1000000] -- unlazy it?
14:11:56 <enso> ohh....nevermind...stack overflow not integer overflow
14:13:21 <hml> err, stack overflow, in haskell on such a small list?
14:13:25 <hml> this is worrisome
14:13:44 <drigz> hml: you need a strict sum
14:14:10 <drigz> stacks are quite small by default because you rarely need to recurse down 1000000 levels
14:14:30 <drigz> and if you are doing so, mostly it indicates an inefficient program
14:14:50 <pmurias> there is a gcc flag to allow such stuff
14:14:59 <cantor> i have to compute the number of lower-case letters in a string. For instance, on aBCde it
14:15:00 <cantor> should return 3.  how can i make it if i use the two functions Char.isLower and length ?
14:15:31 <pmurias> a ulimit one in fact ;)
14:16:07 <xd> you can do foldl1' (+) to get around the overflow
14:16:31 <cantor> i have tried something like this: filter Char.isLower  length "Hello" : [ ]
14:16:33 <drigz> cantor: the only other ingredient you need is 'filter'
14:16:58 <mauke> cantor: that calls filter with 3 arguments
14:17:05 <cantor> sry, i'm a absolute beginner
14:17:16 <mauke> filter takes only 2 arguments
14:17:20 <paczesiowa> > let foo = length . filter Data.Char.isLower in foo "HeLlO"
14:18:18 <pmurias> drigz: a DFS on a large graph is a case where i recursed down 1000000 levels
14:18:23 <cantor> thanks
14:18:50 <cantor> paczesiowa: dump question: what exactly do Data.Char.isLower
14:19:23 <drigz> pmurias: like i said, most cases - you can make a larger stack if you want to do that
14:19:30 <mauke> cantor: what do you mean?
14:19:34 <paczesiowa> > it is function isLower from module Data.Char
14:19:52 <cantor> ok thanks
14:20:09 <paczesiowa> you can import Data.Char at toplevel and just use isLower
14:22:03 <cantor> let foo = length . filter Data.Char.isLower in foo "HeLlO"  <--why is there a point between length and filter?
14:22:47 <paczesiowa> that's function composition, if you don't know it yet then try this:
14:22:59 <monochrom> The same reason there is a | in "uniq | wc"
14:23:02 <paczesiowa> let foo list = length (filter Data.Char.isLower list) in foo "HeLlO"
14:23:56 <cantor> works as well
14:24:35 <Baughn> monochrom: Sadly, you can't curry shell programs. I'd say | is more akin to $
14:25:39 <paczesiowa> and you anyone is interested in that topic, as usual Oleg already did it : http://okmij.org/ftp/Computation/monadic-shell.html
14:27:55 <monochrom> $ is <, e.g., sort < myfile
14:28:29 <mmorrow> Baugn: i think you can hack something up similar to currying  with  eval and backticks, though
14:28:46 <monochrom> "sort | uniq < myfile" = nub . sort $ myfile
14:29:04 <mmorrow> Baughn: and probably there are many ways to do the same thing
14:29:28 <mmorrow> sh is a crazy thing
14:29:34 <Baughn> mmorrow: Of course. Eval, the great equalizer.
14:29:40 <mmorrow> heh
14:29:50 <monochrom> It is a common confusion when I bring up | that people think it is $
14:29:54 <Baughn> It's very discouraging to write scripts that don't work on my other machines, though
14:30:22 <mmorrow> Baughn: hmm, i don't follow
14:30:33 <Baughn> monochrom: Of course it isn't, but it certainly isn't . either
14:30:34 <zachk> sh varies from machine to machine
14:30:46 <mmorrow> Baughn: are you saying eval and/or backticks aren't standard sh?
14:30:58 <mmorrow> zachk: @you too ^^
14:31:00 <Baughn> mmorrow: I've got some linux, one freebsd, one mac, one windows...
14:31:19 <Baughn> mmorrow: The windows one does have a shell, but not an sh-alike either. If I want portability, I use haskell. ^_^
14:31:47 <dino-> It helps to use #! /bin/bash if you really are using bash features and not sh features. A pile of scripts of mine got broken in the recent past when Ubuntu went from sh -> bash to -> dash
14:32:11 <gwern> dino-: isn't that your fault?
14:32:15 <dino-> gwern: yup
14:32:16 <mmorrow> ah yeh, i guess i always write in bash
14:32:21 <dino-> Smarter to specify the shell you want.
14:32:27 <Baughn> dino-: Even when you make sure to specify bash, you'll still get bitten by differences in the programs you invoke
14:32:29 <dino-> Instead of assuming
14:32:50 <dino-> Baughn: that can be true, yes
14:33:19 <gwern> it's kind of funny, but I once set sh to dash on my gentoo system, and I got *so* many mysterious compilation errors all over the place
14:33:38 <gwern> I was too lazy to file bugs since I suspected the devs would just yell at me 'well don't do that then!'
14:33:46 <gwern> (gentoo devs are not particularly friendly)
14:34:13 <Baughn> gwern: They have a point
14:34:24 <Baughn> You shouldn't be spending enough time as root to want to change your shell anyhow
14:35:07 <Baughn> And the gentoo devs are hardly going to fix the bazillion compilation scripts out there that say #!/bin/sh
14:35:15 <gwern> Baughn: I originally did it to test whether my local scripts were being honest about #! /bin/sh
14:35:24 <Baughn> gwern: Well, now you know. ;)
14:35:27 <gwern> I noticed all the breakage since I didn't undo it immediately
14:36:39 <gwern> Baughn: well, after some pondering I realized what the problem was. fortunately I hadn't done any upgrades recently
14:37:35 <dino-> It can also be a lot of fun to write shell scripts in Haskell
14:38:00 <EvilTerran> /bin/sh = /usr/bin/runhaskell?
14:38:05 <gwern> yes, although sometimes frustrating if you abstain from libs like HSH
14:38:08 <EvilTerran> no, wait, that wouldn't work, nvm
14:38:16 <EvilTerran> neither would ghci
14:38:35 <dino-> #! /usr/bin/env runhaskell
14:38:38 <dino-> is more portable
14:39:05 <gwern> I mean, how do you run a program in $PATH and get its stdout in less than 4 unobvious & difficult lines? for example
14:39:26 <dino-> This is handy: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
14:39:36 <dino-> A tiny run shell command snip of code.
14:39:48 <dino-> (thanks dons!)
14:39:52 <paczesiowa> the only thins that keeps me from using ghci as my shell is that I'll have to use cd "dir"
14:39:52 <adekoba> (pardon my ignorance) is it possible to use parsec with ByteString's?
14:40:02 <paczesiowa> adekoba: yes, use parsec-3
14:40:10 <gwern> adekoba: I think parsec3 does it
14:40:20 <adekoba> thanks, paczesiowa & gwern
14:40:25 <gwern> although I've heard parsec3 is slower than parsec2 even with bytestring speedups
14:41:19 <stepcut> paczesiowa: how about, :cd dir
14:41:41 <gwern> dino-: that kind of proves my point - that's like 10 lines, w/o import or type sigs
14:42:02 <paczesiowa> too hard and there's no tab-completion
14:42:13 <dino-> gwern: I wonder if something could be hacked together to allow almost a 'sourcing' of a util module for Haskell shell scripts.
14:42:24 <dino-> I wonder if the runhaskell line could take a libdir arg
14:42:31 <gwern> dino-: I don't follow
14:42:32 <stepcut> dino-: I don't believe that shell code will work
14:43:28 <dino-> stepcut: That Process.run thing? :o
14:43:29 <paczesiowa> woah, tab-completion works
14:43:44 <stepcut> dino-: yes
14:44:17 * stepcut tests
14:44:42 <b\6> paczesiowa: do you start ghci with rlwrap -a?
14:45:13 <paczesiowa> why would I wrap readline-enabled app with readline?
14:45:27 <stepcut> dino-: try, run "yes | head -n 100000"
14:45:31 <b\6> dunno, it wasn't doing it before i rlwrapped it.
14:46:14 <Baughn> dino-: At this point I should probably mention that there's a bug in ghc (up to 6.8.2, at least; haven't checked lately) that makes it impossible to fork off pipelines like a shell should
14:46:28 <dino-> gwern: I was having vague thoughts of being able to import Foo in these Haskell shell scripts to bring in useful functions. But I don't know if it's possible.
14:47:21 <gwern> dino-: oh, you mean an umbrella module which imports a whole bunch of modules and re-exports them?
14:47:40 <dino-> Where Foo is some pile of helpful things for shell scripting.
14:48:27 <dino-> stepcut: Ok, trying that code.
14:50:33 <paczesiowa> is anyone else annoyed by using "let two = 2" in ghci and losing that binding after :r ?
14:51:04 <Baughn> paczesiowa: Nope. I'll stick that binding in my state.hs.
14:51:04 <dmwit> yeah
14:51:04 <mmorrow> paczesiowa: yes.
14:51:18 <jeffz> paczesiowa: if I do something like that, I usually enter it in the source file which is in the opposite buffer in emacs
14:52:00 <monochrom> I am not annoyed. I like it. I want to lose the binding.
14:52:30 <paczesiowa> maybe for you professional-editor-users it's easy, we - people with crappy memory have to use mouse and few clicks to move that to src file
14:52:31 <dino-> stepcut: I see. Takes a long time.
14:52:38 <stepcut> dino-: probably forever
14:52:41 <dino-> Where's my lazy IO when I need it
14:53:02 <stepcut> the problem *is* the lazy IO
14:53:03 <mmorrow> paczesiowa: the only problem is, i think it's impossible to preserve them without the possibility of problem in the general case, because what if a binding was made which uses a definition in the module you just reloaded which has changed?
14:53:53 <dino-> ya, I'm thinking backwards
14:53:59 <dino-> It's waiting for that to finish
14:54:02 <dino-> bleh
14:54:13 <stepcut> dino-: waitForProcess will block until the process terminates. But the process will be blocked forever because once it files out its stdout buffer, it can't do anything but wait
14:54:23 <paczesiowa> mmorrow: it could be a closure, but I'd prefer foo = bar to depend on bar from realoaded module
14:54:24 <dino-> oof
14:54:28 <stepcut> dino-: :)
14:54:28 <mmorrow> it's then unclear (to ghci) if you *really* want to be using that binding despite the fact that it refers to a no-longer-existent definition, or not
14:55:18 <thoughtpolice> paczesiowa: flushing bindings makes sense; when you reload your code you don't want residue hanging around, old values, old values of the wrong type, etc. etc.. clearing the working environment is the best option to avoid complications
14:55:36 <mmorrow> paczesiowa: it'd definitely be cool if someone hacked in a  :reload-preserve  (or whatever it would be called) though :)
14:56:09 <monochrom> Be careful with the semantics of that.
14:56:14 <mmorrow> yeah
14:56:28 <stepcut> dino-: if you want to lazily read stdout, stderr, and the exit code, see http://src.seereason.com/haskell-unixutils/System/Unix/Process.hs
14:56:33 <stepcut> dino-: but, it ain't pretty :)
14:56:58 <Guest61322> is there any built in way to add two tuples together? (1,2) + (2,3) = (3,5)
14:57:07 <mmorrow> i'm not even positive that such a reload-preserve would be possible that can *always* problems
14:57:22 <mauke> > join (***) (+) (1,2) (2,3)
14:57:22 <mmorrow> ... *always* avoid problems
15:00:00 <mmorrow> (3,5)
15:01:28 <Guest61322>        against inferred type `(c, c)'
15:01:39 <Guest61322> expecting t1 -> t
15:01:45 <mauke> the what?
15:01:56 <Guest61322> <interactive>:1:5:
15:01:56 <Guest61322>     Couldn't match expected type `t1 -> t'
15:01:56 <Guest61322>            against inferred type `(c, c)'
15:02:20 <rwbarton> @type join (***) (+)
15:02:37 <mauke> I see
15:03:08 <mauke> in that case my answer is just "no" :-)
15:03:12 <Guest61322> lol
15:13:48 <benny99> I'm trying to compile a file, but I get a "Could not find module `Text.ParserCombinators.Parsec':" message - what is my mistake?
15:14:03 <benny99> (ghc 6.8.2 ... 'ghc --make *file*')
15:14:15 <Guest61322> how many versions of parsec do you have installed
15:15:12 <benny99> I guess none :)
15:15:22 <thoughtpolice> benny99: ghc comes with parsec
15:15:32 <stepcut> benny99: ghc-pkg list should tell you
15:15:41 <benny99> then I got one, but maybe it's the wrong version for that 'file'
15:15:45 <thoughtpolice> do 'ghc-pkg list parsec'
15:16:23 <MyCatVerbs> :i Builder
15:16:30 <MyCatVerbs> @index Builder
15:16:42 * MyCatVerbs pokes lambdabot.
15:16:43 <stepcut> parsec is a separate package on debian based systems I think. libghc6-parsec-{dev|prof|doc}
15:16:54 <benny99> (no parsec :( )
15:16:58 <MyCatVerbs> stepcut: what? Really? That's insane.
15:17:19 <monochrom> Naw, everything in extralibs is outsourced.
15:17:26 <benny99> (oh, yeah, there it is)
15:17:30 <Guest61322> yea splitobjs wasnt turned on for the ubuntu package last i checked either
15:17:33 <MyCatVerbs> stepcut: (currently, Network relies on Parsec for some little things here and there.)
15:17:34 <benny99> (sorry...)
15:17:34 <stepcut> MyCatVerbs: not if you want to update to a newer version of parsec than what was in the bundled release
15:18:06 <MyCatVerbs> stepcut: mmm? Installing to newer versions than what's in the bundled release works fine for me.
15:18:14 <MyCatVerbs> stepcut: s/to //
15:18:27 <MyCatVerbs> stepcut: but no Parsec means no Network which is a bit... dire.
15:18:31 <stepcut> MyCatVerbs: well, libghc6-network-dev depends on libghc6-parsec-dev, so...
15:18:33 <benny99> (I'm just trying to compile the LambdaCalculator by http://web.cecs.pdx.edu/~sheard/LamCalc/ btw.)
15:19:04 <MyCatVerbs> stepcut: as it must. Doesn't it strike you as crazy not to bundle even the sockets library by default?
15:19:27 <stepcut> MyCatVerbs: no. Being able to upgrade those libraries independently is nice
15:19:42 <benny99> thank you, I'm downloading libghc-parsec now :)
15:20:02 <MyCatVerbs> stepcut: I suppose it would, but nobody ever does anyway.
15:20:09 <stepcut> MyCatVerbs: I have
15:20:15 <gwern> the debian/ubuntu packages are annoying
15:20:19 <gwern> no profiled ghc package
15:20:24 <stepcut> gwern: ghc6-prof ?
15:20:30 <benny99> gwern: there are I guess
15:20:37 <gwern> stepcut: no, the actual GHC API
15:20:38 <benny99> gwern: *package-name*-prof, yeah
15:20:44 <gwern> the libraries are profiled, sure
15:20:47 <gwern> but not ghc itself
15:20:51 <stepcut> gwern: ah
15:20:54 <enso> ?bot
15:20:58 <gwern> I filed a bug awhile ago, but no one's even looked at it
15:21:13 <gwern> this is annoying since I want to profile plenty of thing which use the GHC API (lambdabot, mueval, hint, yi...)
15:21:27 <stepcut> gwern: yeah
15:21:45 <stepcut> gwern: does ghc required -threaded ?
15:22:12 <MyCatVerbs> stepcut: if you're updating yourself using Cabal, then Debian's package infrastructure is irrelevant.
15:22:32 <Igloo> stepcut: GHC is only linked with -threaded so that programs that need -threaded can be run from ghci/runghc
15:22:38 <MyCatVerbs> stepcut: if you're updating libraries from the repos, then sure, that is useful. It's just that I've never seen them actually do that.
15:22:53 <stepcut> MyCatVerbs: I always debianize things before installing them, otherwise the debian package system gets very mad
15:22:56 <gwern> stepcut: according to the wiki page which mentions it, the GHC API can be profiled
15:23:06 <gwern> dunno how that interacts with -threaded
15:23:38 <MyCatVerbs> stepcut: heh. I just install into ~/stuff rather than /usr, and neither apt-* nor dpkg* care a jot for what they don't even look at. ;P
15:23:53 <Toxaris> Guest61322, mauke: uncurry (***) . join (***) (+)
15:23:53 <gwern> I put everything into ~/bin
15:23:55 <gwern> works well
15:23:57 <stepcut> MyCatVerbs: yes, but ghc-pkg does care
15:24:50 <stepcut> MyCatVerbs: it gets all pissy if the postinst script tries to register a package version that is already registered
15:25:05 <Guest61322> toxaris: nice haha
15:27:38 <Toxaris> Guest61322: but I would prefer data Vector2 a = Vector2 a a and instance Applicative Vector2 where pure x = Vector2 x x; Vector2 f g <*> Vector2 x y = Vector2 (f x) (g y), so that I can write (+) <$> (1, 2) <*> (2, 3)
15:29:13 <Guest61322> yea thats cool too
15:30:40 <Toxaris> Guest61322: oh (+) <$> Vector2 1 2 <*> Vector2 2 3, of course
15:31:26 <dmwit> instance Num Vector where [(+), (-), etc.] = map liftA2 [(+), (-), etc.]
15:32:09 <dmwit> or just use Complex
15:32:58 <Toxaris> dmwit: fromInteger? abs? ...? as always, Num seems not to be the Right Thing
15:33:16 <Toxaris> no real reason not to use it, though
15:35:10 <benny99> does somebody know a good LambdaCalculator?
15:37:49 <dmwit> :t abs
15:38:01 <dmwit> ?bot
15:38:19 <gwern> benny99: lambdashell maybe
15:38:20 <gwern> on hackage
15:38:27 <dmwit> Toxaris: abs could give the unit vector in the same direction
15:38:44 <dmwit> fromInteger is weirder, but there are many defensible implementations
15:38:52 <benny99> gwern: thanks, I'll take a look :)
15:40:25 <mattam> Toxaris: have fun with *.
15:41:28 <dmwit> Okay, yeah, that one is no good.
15:42:19 <mattam> It's simply not a (commutative) ring that Num is supposed to represent.
15:44:21 <rwbarton> The only sensible definition is to do everything component-wise, and that might as well be an instance for Num a => e -> a
15:46:56 * dmwit nods
15:48:04 <benny99> gwern: thanks :)
15:48:18 <dmwit> You could potentially do (*) in as r = v1 dot v2, theta = theta1 + theta2.
15:48:21 <benny99> installing packages using hackage is way too easy btw.
15:49:02 <dmwit> But it's a bit of a stretch, and it doesn't really match any (+) implementation.
15:54:13 <slava> why is ad-hoc polymorphism named that way?
15:56:07 <cjb> slava: because the combinations of types have to be specified prior to use.  you're not really using a type system so much as pattern matching.
15:56:22 <cjb> (I'm not an expert, though.)
15:56:47 <cjb> My college just went ahead and called it "overloading" instead.
15:57:39 <cjb> ah, http://en.wikipedia.org/wiki/Ad-hoc_polymorphism#Ad-hoc_polymorphism gives a putative explanation
15:59:18 <slava> ah, so according to wikipedia, ad-hoc polymorphism refers to compile-time overloading only, not runtime dispatch
15:59:50 <cjb> hm
16:00:17 <cjb> that doesn't sound quite right.  when I do "foo" + "bar" in python, I think of that as runtime dispatch of add() to string.add()
16:00:26 <cjb> I guess it depends when compilation happens :)
16:00:54 <thoughtpolice> well, for type classes which, well, is ad-hoc polymorphism generally speaking there will be a runtime dispatch because all functions which operate over functions of a type class, i.e. any function that has a class constraint
16:01:04 <thoughtpolice> will have an implicit 'dictionary argument' passed along with it
16:01:09 <thoughtpolice> this is how GHC does it to my understanding
16:01:12 <thoughtpolice> JHC does it different
16:01:48 <thoughtpolice> (the dictionary is just a dispatch table to possible implementations of the method in question)
16:02:50 <dmwit> Ad-hoc polymorphism can be removed without restricting the type.
16:04:02 <dmwit> For instance, "sum :: Num a => [a] -> a" can be mechanically converted to "sum :: (a -> a -> a) -> [a] -> a".
16:05:18 <dmwit> (Actually, in this case, it's "sum :: (a -> a -> a) -> (Integer -> a) -> [a] -> a".)
16:06:02 <dmwit> or some such, to allow a 0 base-case
16:07:02 <slava> right
16:12:45 <yaru1022> hi~
16:13:42 <yaru1022> is there an easy way to sum up a list of numbers until the sum doesn't exceed 'x'?
16:14:41 <Cale> yaru1022: you might start with  scanl (+) 0
16:14:46 <Cale> > scanl (+) 0 [1..10]
16:15:03 <Cale> ... is there something wrong with lambdabot?
16:15:06 <dons_> yeah, scan and then takeWhile
16:15:08 <RayNbow> it died
16:15:32 * RayNbow nudges lambdabot
16:15:36 <Cale> ah
16:15:37 <yaru1022> would that work with infinite list as well?
16:15:42 <Cale> yaru1022: yep
16:15:48 <RayNbow> I think it died because it didn't get enough lambda-love
16:15:50 <Cale> It still thinks that it is online somehow
16:16:14 <Cale> > scanl (+) 0 [1..]
16:16:22 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
16:17:16 <bwr> i wish ghci would truncate infinite lists
16:17:18 <Cale> Either last . takeWhile (< n) or head . dropWhile (< n), depending.
16:17:57 <Trinithis> :t first
16:18:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:20:30 <RayNbow> Cale: does the latter one produce the same answer as the former?
16:20:42 <dmwit> no
16:27:05 <b\6> know of an example of really trustworthy command line argument parsing involving conversions to int and stuff? i keep seeing people doing crazy stuff that won't work.
16:27:46 <dons> use Console.GetOpt and maybeRead.
16:28:01 <dons> do you know how to write maybeRead?
16:28:19 <b\6> not sure.
16:28:24 <dons>      maybeRead :: Read a => String -> Maybe a
16:28:25 <dons>      maybeRead s = case reads s of
16:28:25 <dons>          [(x, "")] -> Just x
16:28:25 <dons>          _         -> Nothing
16:28:36 <dons> so a safe read, that won't kill your program.
16:28:39 <b\6> ok, think i see.
16:28:41 <b\6> thanks.
16:30:54 <dons> i wish i could edit mediawiki's offline.
16:32:07 <ksandstr> i thought there was a subversion-like client for that
16:32:33 <ksandstr> can't remember what its name was, or if it had a web page
16:35:25 <allbery_b> http://meta.wikimedia.org/wiki/Dedicated_Wikipedia_editor
16:40:41 <ddarius> dons: cabal install safe; import Safe (readMay)
16:41:45 <b\6> checking it out.
16:48:36 <MyCatVerbs> I am rapidly becoming to detest Data.ByteString.*.
16:49:17 <Twey> Why's that?
16:49:38 <MyCatVerbs> Every single bloody name conflicts with every other single bloody name, up to and including the absolute genius of having Data.ByteString.Lazy.Internal.ByteString have a different representation but identical name to Data.ByteString.Internal.ByteString.
16:50:07 <dainanaki> All you've got to do is qualify the imports
16:50:19 * Twey nods.
16:50:20 <dainanaki> Although I do agree it's an annoying design decision
16:50:28 <Twey> Qualified imports are good y'all.
16:50:46 <Twey> The idea is that you can swap lazy bytestrings and strict bytestrings easily, I presume.
16:50:53 <MyCatVerbs> dainanaki: a) it still causes all sorts of completely unnecessary confusion in the haddock documentation and b) it's a pain in the neck when using GHCi.
16:51:17 <dainanaki> I know, like i said, it's annoying
16:51:23 <dainanaki> but it's not unworkable
16:51:33 <MyCatVerbs> Twey: that would be incredible, if you could. Unfortunately it seems that in practice what one ends up doing instead is mixing usage of strict and lazy bytestrings, because of the way the libraries are laid out.
16:51:58 <Twey> Ah :-\
17:06:33 <matthew-_> I don't leave the computer on now
17:06:44 <matthew-_> agh, first ww for a few days. *sigh*
17:15:03 <Trinithis> what's the purpose of Data.Map.valid? Isn't the map gauranteed to be balanced?
17:21:23 <dcoutts> Trinithis: there are a couple unsafe constructors, eg the one that builds a map from an ordered list I think doesn't check
17:21:33 <Trinithis> ah thx
17:24:56 <Cale> http://failblog.org/2008/07/31/animal-identification-fail/
17:24:56 <lambdabot> Title: Animal Identification Fail  FAIL Blog: Pictures and Videos of Owned, Pwnd and  ...
17:25:11 <Cale> So ridiculous :)
17:27:31 <erikc> hrm, im making a binding library to XInput.lib and have made a cabal package, since the library being bound to is a static lib, i assume i need to include the lib on any link step that links with my binding package?
17:28:22 <dcoutts> erikc: I guess you use extra-libraries: XInput in your .cabal file
17:29:20 <erikc> tried that, but it uses -lXInput, which wont find the XInput.lib
17:29:51 <dcoutts> erikc: ok, how would you link it using gcc?
17:29:58 <erikc> the other issue is if i leave it to the final link step, the XInput.lib is placed before the XInput package on the collect2 step
17:30:02 <erikc> so the resolution fails
17:30:26 <dcoutts> erikc: ghc uses gcc to link, so it has to be linkable via gcc
17:30:37 <dcoutts> so that means some combination of -L and -l flags
17:30:44 <dcoutts> which have corresponding fields in the .cabal file
17:30:49 <erikc> right
17:31:01 <erikc> unfortunately -l requires a 'lib' prefix
17:31:14 <dcoutts> erikc: on Windows I'm not sure that's right
17:31:15 <erikc> and microsoft's libraries dont have those, so i gotta specify em literally
17:31:38 <dcoutts> I seem to remember using .lib files with gcc on mingwn
17:31:51 <erikc> hrm
17:32:00 <dcoutts> for gtk2hs and gtk+'s .dll and .lib files
17:32:27 <dcoutts> erikc: if you can't make it work, post to the ghc-users list
17:32:31 <erikc> k
17:32:33 * dcoutts heads for bed
17:32:37 <dcoutts> erg: good luck :-)
17:32:40 <dcoutts> oops
17:32:45 <dcoutts> damn tab completion
17:32:46 <erikc> i have it working if its not packaged
17:32:51 <erikc> so i can make forward progress
17:33:00 <dcoutts> erikc: using what ghc flags?
17:33:15 <erikc> just passing the .lib file path directly to the ghc link step
17:33:24 <dcoutts> oh, right.
17:33:27 <erikc> if its in a package though the fiel order in the ld step is wrong
17:33:38 <erikc> ill dig some more
17:33:38 <dcoutts> hrm
17:33:45 <dcoutts> well, good luck
17:36:03 <Trinithis> huh. I din't realize a numeric literal could take instance of a user-defined number
17:37:29 <dmwit> Trinithis: Yeah, any Num instance.
17:37:35 <dmwit> :t fromInteger
17:37:36 <lambdabot> forall a. (Num a) => Integer -> a
17:37:42 <dmwit> for literals with no '.'
17:37:51 <dmwit> and no 'e'/'E'
17:37:57 <dmwit> :t fromRational
17:37:58 <lambdabot> forall a. (Fractional a) => Rational -> a
17:38:14 <Trinithis> Pretty cool. I found it out by accident a moment ago when I did [1]+1 (I made [Integer] an instance for an application)
17:38:17 <dmwit> I don't remember which function is applied for ./e guys.
17:38:19 <mattr__> what is the go with Hayoo! vs Hoogle?
17:38:27 <mattr__> do we have some competition brewing?
17:38:32 <mattr__> or do they do different things?
17:39:03 <dmwit> Hayoo seems better for searching on an English description; Hoogle seems better for searching with a type.
17:39:28 <dmwit> I also like Hoogle's results for exact names better, but YMMV.
17:39:33 <mattr__> dmwit: but they both play in the same space?
17:40:19 <dmwit> kind of, yeah
17:44:31 <gwern> > 500 * 0.4
17:44:32 <lambdabot>  200.0
17:48:52 <dmwit> :t 0.4
17:48:53 <lambdabot> forall t. (Fractional t) => t
17:49:05 <dmwit> ?src Fractional
17:49:05 <lambdabot> class  (Num a) => Fractional a  where
17:49:05 <lambdabot>     (/)             :: a -> a -> a
17:49:05 <lambdabot>     recip           :: a -> a
17:49:05 <lambdabot>     fromRational    :: Rational -> a
17:49:17 <dmwit> Maybe I was right on my first guess... fromRational.
17:56:19 <jeffwheeler> Is it possible to use HOC on a 32-bit Intel Mac running 10.5?
17:56:39 <jeffwheeler> It only states 10.3 support, and hasn't been developed since 2004 as far as I can tell.
17:56:53 <mattr__> HOC?
17:57:06 <jeffwheeler> mattr__: Haskell Object-C
17:57:13 <mattr__> ah - sorry, don't know
17:57:19 <jeffwheeler> Yi's Cocoa interface depends on it.
17:57:52 <mattr__> it is certainly worth trying
17:58:12 <mattr__> I have a semi-universal build of ghc on ppc/intel 10.5
17:58:29 <mattr__> and nothing I have tried to install (once I got ghc going)
17:58:32 <mattr__> has been trouble
17:58:44 <mattr__> but of course, HOC is the one thing that might break :)
17:58:57 <jeffwheeler> I wasn't able to succeed a few days ago when I tried briefly, but I've since reinstalled 10.5, so I think I'll try again.
17:59:06 <jeffwheeler> I have more time to try, anyways. ;)
17:59:16 <mattr__> good luck
17:59:35 <jeffwheeler> Thanks.
18:06:34 <Stinger> does cabal not support paths with spaces? I'm reading an install doc for hdbc-postgres which claims it might have problems (in windows)
18:07:28 <dmwit> I think it specifically has trouble with PATHs with spaces.
18:07:41 <dmwit> i.e. the path to GHC shouldn't have spaces, though IIRC other paths can.
18:23:18 <mmorrow> @pl \f (a,b) -> a : f b
18:23:19 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (:))
18:24:05 <hml> what does the ! in the followin gmean?
18:24:07 <hml> data Vertex3 a = Vertex3 !a !a !a deriving ( Eq, Ord, Show )
18:24:40 <erikc> it means the arguments will be evaluated strictly
18:25:06 <dmwit> When the Vertex3 constructor is demanded, the three arguments will also be reduced to head normal form.
18:26:59 <neutrino_> pl
18:27:05 <dmwit> ease
18:30:32 <mmorrow> > let go f xs = let (y,ys) = f xs in y : go f ys ; chunk = (takeWhile (not . null) .) . go . splitAt in chunk 4 [0..]
18:30:33 <lambdabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],[...
18:31:12 <Stinger> what's go?
18:31:20 <Stinger> @src go
18:31:21 <lambdabot> Source not found. Where did you learn to type?
18:31:26 <dmwit> He just defined it there.
18:31:36 <Stinger> oh didnt see the go up front, duh
18:32:41 <dmwit> > let go = iterate . snd; chunk = (takeWhile (not . null) .) . go . splitAt in chunk 4 [0..]
18:32:42 <lambdabot>  Couldn't match expected type `(a1, [a] -> [a])'
18:32:47 <dmwit> :t iterate
18:32:48 <lambdabot> forall a. (a -> a) -> a -> [a]
18:32:58 <dmwit> :t iterate . snd
18:32:59 <lambdabot> forall a a1. (a1, a -> a) -> a -> [a]
18:33:05 <dmwit> oops
18:34:01 <dmwit> :t iterate . (snd .)
18:34:02 <lambdabot> forall a b. (b -> (a, b)) -> b -> [b]
18:34:26 <dmwit> > let go = iterate . (snd .); chunk = (takeWhile (not . null) .) . go . splitAt in chunk 4 [0..]
18:34:27 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:34:52 <dmwit> > let go = iterate . (fst .); chunk = (takeWhile (not . null) .) . go . splitAt in chunk 4 [0..]
18:34:53 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:34:57 * dmwit gives up
18:35:06 <Stinger> they really need that in prelude
18:35:28 <dmwit> I just keep a module Dmwit with all the stuff that ought to be in the Prelude.
18:35:49 <hml> how do I convert a GLsizei to a GLdougle ?
18:35:55 <hml> err, GLSizei -> GLdouble
18:35:57 <dmwit> I have "chunk i = unfoldr $ ensure (not . null . fst) . splitAt i" in module Dmwit.
18:36:17 <dmwit> hml: What instances do they have?
18:36:18 <hml> hmm, make that GLsizei -> GLdouble
18:36:24 <dmwit> Can you use fromIntegral, toIntegral?
18:37:11 <dmwit> Whoops, I mean s/Integral/Integer/g
18:37:28 <dmwit> :t fromInteger . toInteger
18:37:29 <lambdabot> forall a a1. (Integral a1, Num a) => a1 -> a
18:37:37 <dmwit> :t fromIntegral
18:37:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:40:48 <hml> aa Couldn't match expected type `Integer' against inferred type `GLsizei' In the first argument of
18:41:43 <dmwit> Be careful with those function name endings.
18:41:47 <hml> type GLsizei = HTYPE_GLSIZEI
18:41:54 <hml> oh
18:42:01 <dmwit> I've already gotten it wrong twice in-channel in the last five minutes... =)
18:46:32 <seanstickle> quiet tonight
18:56:34 <mmorrow> @seen dolio
18:56:34 <lambdabot> dolio is in #haskell-blah, #ghc and #haskell. I last heard dolio speak 1h 2m 49s ago.
18:56:44 <dolio> Yo.
18:56:51 <mmorrow> dolio: this build failed with http://hpaste.org/9374
18:57:14 <mmorrow> dolio: i haven't pulled in about a week though, so i'm pulling now and gonna retry...
18:57:21 <dolio> Huh.
18:57:34 <mmorrow> did you get my @tell?
18:57:48 <dolio> I saw it. lambdabot didn't seem to deliver it, though.
18:58:27 <dolio> I usually search for my name in the scrollback after I've been away for a while, though.
18:58:28 <mmorrow> cool, yeah. well at this error is with building one of the libs and not the compiler itself
18:58:53 <mmorrow> well *at least* this error....
18:59:00 <dolio> Yeah.
18:59:05 <mmorrow> ok, darcs pull says 54 new patches
18:59:24 * mmorrow applies all and restarts
18:59:57 * mmorrow lets out a small whimper as he makes distclean
19:00:50 <dolio> :)
19:02:29 <jeffwheeler> mattr__ and anybody interested: It does seem to be possible to install HOC on OS X Leopard, but the Makefiles are old and don't seem to work. Using cabal/Setup.hs along with the make-binding-macos.sh script in hoc/Bindings/Generated, everything works.
19:03:07 <mattr__> nice
19:05:14 <SamB> okay, what happened to the old ghc commentary???
19:05:35 <dmwit> SamB: First hit on Google?
19:06:29 <mmorrow> SamB: uh, i just got a 404
19:06:42 <SamB> dmwit: um, that's not the old one!
19:06:49 <dmwit> oh
19:06:55 <mmorrow> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:07:29 <mmorrow> this is the first dir parent that works http://www.cse.unsw.edu.au/~chak/haskell/
19:07:30 <lambdabot> Title: Index of /~chak/haskell
19:07:34 <mmorrow> maybe it just got moved?
19:08:13 <dmwit> http://web.archive.org/web/20070823000806rn_1/www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:08:15 <lambdabot> Title: The GHC Commentary - The Beast Explained, http://tinyurl.com/635en7
19:08:20 <hackage> Uploaded to hackage: XInput 0.0
19:08:23 <dmwit> Thank you, WayBackMachine.
19:08:59 <dmwit> http://web.archive.org/web/*/http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm for a list of all the dates it spidered there; * means it changed.
19:09:01 <lambdabot> Title: Internet Archive Wayback Machine, http://tinyurl.com/5cgum5
19:10:57 <SamB> it doesn't seem to rewrite the links though :-(
19:11:25 <dmwit> Aw, that's annoying.
19:11:39 <SamB> is chak known here as "ChilliX"?
19:11:44 <dmwit> yes
19:12:05 <SamB> @ask ChilliX what have you done with the old commentary?
19:12:05 <lambdabot> Consider it noted.
19:12:36 <dmwit> He doesn't talk much, though, so good luck. =P
19:13:46 <dmwit> The last time I see him speaking in my logs is March 4th...
19:15:08 <SamB> apparantly "GHCi" used to be named "Hugs"?
19:16:11 <Stinger> that was back in its hippy phase
19:16:26 <gvdm> say wha...
19:16:59 <SamB> (I guess that was before they realized how long people would still be using hugs98 for?)
19:19:07 <SamB> ... are there any more recent documents about GHCi ?
19:22:14 <ChilliX> Samb: Yes, I am chak.  It's were it always has been, in the GHC darcs repo (unless somebody else removed it)./
19:22:15 <lambdabot> ChilliX: You have 1 new message. '/msg lambdabot @messages' to read it.
19:23:14 <SamB> ChilliX: oh. so how come the new commentary links to that url?
19:23:35 <ChilliX> Which url?
19:23:52 <SamB> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
19:24:17 <dmwit> (Linked from http://hackage.haskell.org/trac/ghc/wiki/Commentary at the bottom.)
19:24:20 <lambdabot> Title: Commentary - GHC - Trac
19:25:10 <SamB> also darcs.haskell.org is not particularly reliable and is rather slow
19:26:07 <ChilliX> ah, ok, that was the old online version
19:26:09 <SamB> ... and where in the darcs repo is it?
19:26:34 <ChilliX> Its in ghc/docs/comm/
19:27:30 <ChilliX> That URL you are mentioning was justa copy made by a cron job out of the repo
19:27:38 <ChilliX> That cron jon doesn't exit anymore
19:27:55 <dmwit> It got flushed down the cron john, so to speak.
19:28:17 <ChilliX> hehe
19:29:34 <SamB> okay, I updated that wiki page
19:29:39 <SamB> but I can't change this page:
19:29:45 <SamB> http://www.haskell.org/ghc/documentation.html
19:29:46 <lambdabot> Title: The Glasgow Haskell Compiler
19:31:55 <SamB> (The exact url of the commentary in the main GHC repo being http://darcs.haskell.org/ghc/docs/comm/ )
19:31:59 <lambdabot> Title: The GHC Commentary - The Beast Explained
20:00:22 <mmorrow> dolio: now i get (i'm using 6.8.3 to build):
20:00:24 <mmorrow> /usr/bin/ar: creating dist/build/libHSbase-3.0.a
20:00:24 <mmorrow> dist/build/GHC/IOBase.o: file not recognized: File format not recognized
20:00:37 <mmorrow> i don;t even know wtf
20:00:52 <thoughtpolice> ghc-head? it seems to be a little wacky right now I think.
20:00:58 <mmorrow> yeah
20:01:00 <dolio> So it's producing files it doesn't recognize? :)
20:01:01 <mmorrow> :)
20:01:14 <thoughtpolice> i haven't been able to build the HEAD in roughly ~2 weeks since the build is broken on OS X it seems
20:02:28 <dolio> I guess they are doing some significant stuff.
20:02:40 <dolio> I think I heard someone say that 6.10.1 might not even be Windows ready.
20:02:51 <mmorrow> yeah. i know it's gonna work one of these times though.... ;)
20:04:30 <mmorrow> well, perhaps microsoft can hire an army of coders to work on windows round the clock to make it POSIX compliant!!!
20:04:43 <mmorrow> (so 6.10 works)
20:04:44 <thoughtpolice> yeah, the HEAD is moving quite a bit, probably lots of work is being integrated right now
20:05:07 <thoughtpolice> and with the new-vcs talks going on minds are probably a little elsewhere for some
20:05:15 <ChilliX> thoughtpolice: yeah, I have given up onbuilding the HEAD since GHC HQ insist on changing the build system every 5min
20:05:16 <mmorrow> hehe, every time i build it's a new error, so that's encouraging
20:05:21 <thoughtpolice> mmorrow: brook's law. adding more doesn't mean you get more. :)
20:06:09 <mmorrow> this brook fellow might have a point
20:06:23 <thoughtpolice> ChilliX: yes, I noticed that HEAD stopped building pretty quick after the build system got torn up it seems
20:07:37 <thoughtpolice> and I was excited, I noticed there had been some changes to have DPH build properly now
20:07:40 <thoughtpolice> sad. :(
20:08:14 <ChilliX> thoughtpolice: complain to GHC HQ
20:08:35 <thoughtpolice> mmorrow: the mythical man month is a terrific read. lots of good info bits in there worth remembering and re-reading. :)
20:08:35 <ChilliX> maybe something will; get better if enough people complain
20:08:51 <ChilliX> I currently don't ahve the time to fix the (OS X) build every few days
20:09:15 <thoughtpolice> ChilliX: word; I didn't even notice a ticket on the issue tracker relating to the OS X problem, the 'inferred architecture size ... i386' blah blah
20:09:39 <mmorrow> thoughtpolice: i've actually got that book and have skimmed over bits and pieces, but have yet to start-to-finish it
20:09:46 <thoughtpolice> i can't be sure if it's related to another bug or not; regardless I might as well file it since I did just pull the HEAD
20:10:00 <mmorrow> i just pulled too
20:10:17 <thoughtpolice> ChilliX: what's the basic problem with the OS X build? can you tell or has tearing apart so much stuff made it tough to figure out?
20:10:31 <mmorrow> and got the "unrecognized format of IOBase.o" error :)
20:10:56 <mmorrow> oh, OS X ...
20:13:14 <thoughtpolice> mmorrow: yeah, 'tis an annoyance. what system are you on btw?
20:15:11 <dainanaki> considering how many people use OS X, it seems like they'd give it a little more love :(
20:16:31 <dmwit> dainanaki: They will undoubtedly get it working on OS X before releasing it.
20:16:33 <thoughtpolice> well
20:16:37 <thoughtpolice> it is the HEAD after all
20:16:40 <dainanaki> i know that
20:16:43 <thoughtpolice> keep that in mind. not supposed to be stable.
20:16:56 <dainanaki> But for example, cabal install doesn't seem to work properly
20:17:08 <thoughtpolice> how so? with the HEAD?
20:17:11 <dainanaki> ghc doesn't register that those packages are installed in user directories
20:17:24 <dainanaki> things like that
20:17:33 <thoughtpolice> cabal install needs some tweaks surely
20:17:40 <dainanaki> it seems like linux is the friendliest os
20:17:47 <dainanaki> for haskell at least
20:17:50 <shapr> I want Windows batteries included too!
20:17:57 <thoughtpolice> for one it won't symlink bins to $HOME/bin as of current
20:18:02 <thoughtpolice> needs to be able to build haddock documentation, etc.
20:18:32 <thoughtpolice> regardless, given the state of pre-cabal-install, it is a godsend by many standards.
20:18:52 <thoughtpolice> dainanaki: well, SimonM and SimonPJ are personally responsible for making sure the build gets to linux
20:19:06 <dainanaki> mmhm
20:19:27 <dainanaki> I probably ought to get back onto my arch install one of these days and get it more configured
20:19:28 <dainanaki> :/
20:19:35 <thoughtpolice> i would say at any given time if you wanted to build HEAD/STABLE then yeah, linux is probably your best bet.
20:19:56 <MyCatVerbs> dainanaki: a lot of Haskell hackers are Unix bums. The number of Haskell hackers on Windows is somewhat lower.
20:20:01 <thoughtpolice> unless of course you want to hack on GHC and get it working on your platform. :)
20:20:03 <dainanaki> i know
20:20:06 <dainanaki> i'm not on windwows
20:20:11 <dainanaki> *windows
20:20:14 <dainanaki> I'm on OS X
20:20:43 <dainanaki> I'm still not advanced enough to do anything for ghc development :(
20:22:47 <thoughtpolice> to keep my sanity I work on things, I've been looking through the source for a little while and some of the smaller bugs
20:22:54 <thoughtpolice> gotta start somewhere ;)
20:23:13 <dainanaki> yeah, but I'm easily overwhelmed
20:23:19 <dainanaki> I just figured monads out today
20:23:31 <dainanaki> after like a year of bumming around with haskell
20:23:45 <thoughtpolice> hehe, now you just need to write your tutorial.
20:23:52 <bwr> hah
20:24:04 <thoughtpolice> of course
20:24:06 <Trinithis> lol
20:24:17 <thoughtpolice> right now it doesn't matter if I look through the bugs or try much
20:24:25 <thoughtpolice> since I can't, you know, build it.
20:24:36 <Trinithis> thoughtpolice: have you written your obligatory monad tut?
20:24:41 <dainanaki> Suppose I can't either
20:25:22 <thoughtpolice> Trinithis: I've explained the idea to a lot of people actually, it's now more of a weekly thing than a tutorial. :)
20:25:43 <Trinithis> Oh DEAR!
20:26:07 <SamB> thoughtpolice: you have a weekly monad tutorial on your blog ???
20:26:39 <dainanaki> I have this thing where I get intimidated by things and it takes a while to not be afraid of them, but once I get used to hearing about them, reading about them, etc, then it's really simple
20:26:42 <thoughtpolice> just think of it as one really long, very repetetive tutorial with a few different words
20:26:45 <thoughtpolice> which is broken up
20:26:50 <thoughtpolice> across time, space and the internet.
20:26:54 <thoughtpolice> that should give you a rough idea.
20:26:59 <dolio> I'm sure it gets explained in here at least weekly.
20:27:07 <SamB> thoughtpolice: you should write a summary ;-P
20:27:09 <dainanaki> I'd imagine bi-weekly
20:27:17 <thoughtpolice> SamB: I know right?
20:27:29 <SamB> dainanaki: I guess you probably mean twice a week?
20:27:36 <dainanaki> right
20:27:41 <dolio> Semi-weekly?
20:27:55 <dainanaki> Argh
20:28:00 <SamB> bi-weekly and semi-weekly can BOTH mean either twice a week or every two weeks
20:28:06 <dainanaki> curse latin stems
20:28:07 <dolio> Yeah.
20:28:08 <dainanaki> :(
20:28:35 <thoughtpolice> 'monad explanations dwell within'
20:28:41 <Guest61322> is there a table somewhere of the unicode variants that ghc accepts for stuff like \ ->
20:29:08 <dolio> I think it's mainly arrows.
20:29:18 <dolio> There's no alternative to \.
20:29:43 <Guest61322> was there a reason for excluding them?
20:29:50 <dolio> Which?
20:29:57 <Guest61322> \ and .
20:30:11 <dolio> Well, lambda is treated as an ordinary letter.
20:30:30 <dolio> In case you want to write Greek in Haskell, I guess.
20:31:18 <dolio> What other symbols were you looking for?
20:31:30 <dolio> Most mathematical operators work as Haskell operators, I imagine.
20:31:31 <Guest61322> dunno was bored and playing around with it
20:31:40 <dolio> But those are just functions, so you can define them yourself.
20:32:35 <dolio> Someone suggested the mathematical lambda symbol for use as \, but I have trouble getting that to display.
20:32:40 <ddarius> biweekly means twice a weak
20:32:46 <ddarius> s/weak/week
20:32:57 <dolio> (It looks like a Chinese character in Emacs, for instance.)
20:33:34 <dolio> (All the KDE stuff I tried prior to version 4 displayed it as two characters.)
20:34:03 <Guest61322> yea i tried -> and ghc is interpreting it as the euro sign
20:34:59 <SamB>  isn't working, you say?
20:35:04 <dolio> Do you have UnicodeSyntax enabled in the LANGUAGE pragmas?
20:35:23 <dolio> SamB: Talking to me?
20:35:28 <SamB> dolio: yeah
20:35:37 <dolio> It's not that lambda that doesn't work.
20:35:54 <SamB>  ?
20:36:22 <SamB> ... what, is there another lambda???
20:36:30 <Stinger> is your terminal set to utf? :P
20:36:42 <dolio> SamB: Try 1D6CC
20:36:50 <dolio> MATHEMATICAL BOLD SMALL LAMDA
20:36:59 <SamB> who the heck would use that?
20:37:11 <SamB> does any font contain it?
20:37:24 <mauke> not mine
20:37:25 <SamB> why does it even exist ???
20:37:31 <dolio> Yes, it displays properly in firefox and KDE 4 for me.
20:38:09 <mauke> U+2141 (e2 85 81): TURNED SANS-SERIF CAPITAL G []
20:38:17 <dolio> But not Emacs or any KDE 3 app (so, not my chat client, for instance).
20:38:53 <SamB> nor my terminal
20:38:55 <rwbarton> (also, "lamda"??)
20:39:06 <dolio> Yeah, don't ask me.
20:39:32 <dolio> Yeah, whatever xterm was using didn't work, either.
20:39:47 <SamB> hmm, I would definately not recommend using a Unicode character who's official name contains a spelling error ;-)
20:40:13 <Shiruka> unicode contains a lot of duplicates of characters for use in mathematics
20:40:27 <Shiruka> how on earth it's supposed to make sense beats me though :-)
20:40:32 <dolio> Well, they also spell it "GREEK SMALL LETTER LAMDA", apparently.
20:40:52 <SamB> oh
20:40:56 <rwbarton> Apparently the Greek spelling is 
20:40:57 <Shiruka> and font support for those characters is really poor generally
20:41:13 <SamB> rwbarton: what does that have to do with anything?
20:41:31 <SamB> also WHY do they have all these dupes for use in mathematics?
20:41:41 <mauke> to spell 
20:42:16 <Shiruka> possibly because styling is used to carry meaning in math
20:42:25 <Shiruka> e.g. plain v is often different from bold v
20:42:55 <SamB> oh, they only do it for the bold variants?
20:43:00 <Shiruka> nope
20:43:40 <erikc> should just get the unicode consortium to define a haskell code page
20:43:42 <Shiruka> and it's not too consistent with other decisions either, since formatting can have meaning in other contexts too
20:43:47 <SamB> er, I mean, they don't have a MATHEMATICAL SMALL LAMDA?
20:44:11 <ChilliX> thoughtpolice: the HEAD is not supposed to bestable, but it is supposed to be buildable
20:44:28 <ChilliX> thoughtpolice: just complain on the cvs-ghc@haskell.org list
20:44:40 <thoughtpolice> ChilliX: noted.
20:44:46 <dolio> http://img242.imageshack.us/my.php?image=lambdaux0.png
20:44:51 <ChilliX> rl and I complain, but that's just two voices
20:44:58 <dolio> What it looks like on my machine, for reference.
20:45:01 <ChilliX> I have got sick of it
20:45:05 <dolio> It's significantly different than the Greek lambda.
20:45:36 <thoughtpolice> ChilliX: indeed, I will voice with you because without a buildable head, lots of people are locked out from helping.
20:45:59 <SamB> what is this about "hex escape"?
20:46:12 <dolio> I don't know. That may be what I see in Emacs, though.
20:46:28 <ChilliX> thoughtpolice: yes, for example, me => no fixes to type family bugs!
20:46:29 <Shiruka> hmmh... the mathematical symbols tend to always have some formatting when printed
20:46:36 <Shiruka> if not bold, then it's usually italic
20:46:45 <dolio> Nope, emacs displays something else entirely.
20:46:58 <Shiruka> http://www.unicode.org/charts/PDF/U1D400.pdf <-- unicode mathematical alphanumeric symbols table
20:46:59 <lambdabot> Title: cache:http://www.unicode.org/charts/PDF/U1D400.pdf - Google Search
20:47:20 <thoughtpolice> ChilliX: indeed. and type familes are pretty awesome although I'm sure you can attest to that, :)
20:48:06 <ChilliX> plus rl tends to spend more time fighting cabal these days than implementing DPH stuff, also bad
20:48:22 <Shiruka> "mathematical sans-serif digit zero", "mathematical sans-serif bold digit zero", "mathematical monospace digit zero" <-- sensible? :-)
20:48:28 <sbahra> Have to cut the discussion short, bye.
20:48:28 * sbahra poofs
20:49:10 <ChilliX> I wonder why they had to "fix" a build system that was working perfectly fine
20:49:21 <ChilliX> Just to mess up everybody else in the process...
20:50:22 <thoughtpolice> ChilliX: i sympathize, if a change hampers development like this it is not good. like I said earlier I have been trolling trac to see if I can find anything I could help with but without a HEAD it is not that great of an endeavor
20:50:45 <thoughtpolice> well, not good in the immediate sense, if this cabalisation pays off then great. but right now yeah, it doesn't seem to be helping
20:51:16 <ChilliX> thoughtpolice: yeah, but that's the thing, I don't see what it is going to improve
20:51:37 <SamB> ChilliX: possibly Cabal ;-)
20:51:41 <ChilliX> thoughtpolice: it doesn't even support paralle builds (aka make -j), pretty bad
20:51:58 <ChilliX> SamB: yeah, that's what I suspect, too - just a test case for cabal
20:52:06 <ChilliX> unfortunatelly, a very expensive one
20:52:09 <thoughtpolice> ChilliX: was it not discussed amongst most of the ghc hackers?
20:52:17 <thoughtpolice> oh, that's a good point, i love my 'make -j4'
20:52:37 <SamB> ChilliX: well, also a demander of additional features
20:52:48 <ChilliX> first I knew of it, was igloo writing a msg into #ghc saying that he got stage1 of ghc to build with cabal
20:52:58 <ChilliX> My first thought was "OMG - Nooooooo!"
20:53:08 <thoughtpolice> heh.
20:53:27 <ChilliX> I knew, big suffering would follow quickly
20:53:34 <ChilliX> big = lots of
20:53:39 <SamB> that definately doesn't sound like it was very well thought out ...
20:53:49 <thoughtpolice> ChilliX: right now the HEAD is failing because of a missing definition for an Exception function (extensible exception changes?) but I will hack up a plea and send it to cvs-ghc.
20:54:22 <ChilliX> thoughtpolice: Now I wonder, how can that be given that everybody is supposed to validate before pushing patches to the hdea
20:54:39 * ChilliX thinks a missing definition should have been caught by validate!
20:54:45 * SamB didn't do it
20:54:48 <thoughtpolice> (at least it's not failing because of the same thing it was earlier)
20:55:23 <ChilliX> rl and me are also in the wrong timezone.  GHC HQ pushes stuff in the afternoon and when we get up and pull, we get all the brekage
20:55:34 <ChilliX> I amjust sick of being a living buildbot
20:55:39 <SamB> the only changes *I've* pushed to HEAD were to the README or something similarly non-able-to-cause-bugs, I think ...
20:55:47 <thoughtpolice> i'll re-run the build; it didn't get too far (it got to about ghc-pkg with -j4,) but yeah it looked like a missing definition.
20:55:59 <ChilliX> thoughtpolice: you are too kind:  it should not fail at all
20:56:10 <ChilliX> SamB: glad to hear ;)
20:56:27 <SamB> (I'm probably not actually allowed to push changes to GHC at all ;-)
20:56:52 <thoughtpolice> ChilliX: i do sympathize and as someone who would like to try and help GHC it is quite frusterating, so yes I will send something to cvs-ghc, because from the looks of it it's gotten 'attention' but it isn't major
20:57:04 <thoughtpolice> and if it's seriously screwing up development I would consider that 'major'
20:57:08 <mwc> Any news on GHC and Darcs?
20:57:38 <mwc> or, rather, GHC and Not-Darcs, I suppose?
20:57:40 <ChilliX> thoughtpolice: Yeah, pretty major in my book, too.  Please write that you wanted to help, but that things like that make it hard.
20:58:01 <thoughtpolice> ChilliX: indeed.
20:58:05 <SamB> ChilliX: maybe you should write the same
21:00:41 <ChilliX> SamB: believe me, I have said that many times
21:00:53 <ChilliX> including on the phone to SPJ last week
21:00:55 <SamB> ... so they don't want your help anymore?
21:00:59 <SamB> or what?
21:01:26 <SamB> (... they believe that things will get better soon?)
21:01:38 <ChilliX> They are always arguments like, it doesn't break that often
21:01:53 <ChilliX> if we do the build system changes in a branch, its not tested anough
21:02:06 <ChilliX> (to which my response is, I don't want to be the tester)
21:02:10 <ChilliX> etc
21:02:23 <SamB> ... darcs branches are really sucky ...
21:02:28 <ChilliX> Last time, we got really upset, validate was introduced
21:02:32 <ChilliX> that helped for a while
21:02:39 <ChilliX> but recently its gotten worse than ever
21:03:02 <SamB> ... time to switch to git?
21:03:08 <ChilliX> well, but this way GHC HQ is forcing everybody else to make their private branches
21:03:22 <ChilliX> this is not a darcs problem, its a po9licy problem
21:03:48 <ChilliX> if you break the build of the head in GCC, you get publicly humiliated
21:03:53 <ChilliX> and don't do it again
21:03:56 <SamB> hmm.
21:04:07 <SamB> we could set up a hall of shame
21:04:08 <ChilliX> in GHC, the main developer do it all the time,. so nobody else cares
21:04:25 <SamB> hmm. point.
21:04:30 <ChilliX> Just bad project management
21:04:46 <SamB> it isn't very impressive if you have the maintainers at the top of the hall of shame...
21:04:52 <ChilliX> yeah...
21:05:31 <dmwit> Well... it must build on *some* system, right?
21:05:42 <ChilliX> dmwit: optimist
21:05:45 <SamB> JaffaCake: Igloo: still, consider yourselves and SPJ in the doghouse
21:05:46 <dmwit> I mean, nobody would check in if it didn't work for them... would they?
21:06:09 <stepcut> dmwit: I have worked with many people who did
21:06:20 <dmwit> yuck
21:06:35 <ChilliX> dmwit: firstly, working for them may mean "make" worked in a partial build, but may well fail on a build from scratch
21:06:45 <ChilliX> dmwit: secondly, even that hasn't always been the case
21:06:47 <stepcut> though, we had some 'policies' that fixed that permanently on a per offender basis
21:07:06 <SamB> stepcut: that probably wouldn't work too well here
21:07:08 <ChilliX> slopiness of not using a separate validate tree often leads to a broken tree, too
21:07:09 <dmwit> ChilliX: Ah, yeah, the build time makes scratch builds a bit annoying, huh?
21:07:13 <SamB> you can't really fire the maintainers :-(
21:07:15 <stepcut> SamB: yeah :(
21:07:33 <stepcut> well, you can, but it isn't pretty
21:07:44 <ChilliX> SamB: yeah, but they do want users and conrtibutors
21:07:53 <SamB> ChilliX: true
21:07:57 <stepcut> and, in this case, probably not a good idea :)
21:08:01 <SamB> but that isn't a permanent solution
21:08:07 <SamB> stepcut: well, actually that was what I meant
21:08:08 <ChilliX> SamB: and it is, I think, eveyr much a matter of making clear how much trouble this all causes
21:08:54 <SamB> unfortunately I can't help with that atm because I've no time to help with GHC development right now ...
21:08:59 <SamB> finals are next week...
21:09:52 <ChilliX> SamB: oh, good luck with those
21:10:33 <SamB> ... even though the previous tests in two classes were last week
21:11:24 <SamB> < two weeks between one test and the next is just wierd ...
21:12:07 <thoughtpolice> ChilliX: reran the build, it is not a lack of definition but something is simply out of scope:
21:12:15 <thoughtpolice> Main.hs:1143:14: Not in scope: `Exception.onException'
21:12:33 <ChilliX> thoughtpolice: hmm, not much better - again, validate should have caught that!
21:12:38 <thoughtpolice> i would think it has something to do with the exception changes simonM proposed but you would have a better idea than I, regardless that is very annoying
21:12:46 <thoughtpolice> indeed!
21:12:48 <ChilliX> and it doesn't seem like a platform dependent problem
21:13:30 <stepcut> SamB: Perhaps firing the maintainers *is* a good idea. Maintainer and developer are rather different roles. It sounds like some developers have been stuck in maintainer roles that they don't really want ?
21:13:48 <SamB_XP> stepcut: hmm
21:14:02 <SamB_XP> so ... who wants the role(s)?
21:14:30 <dmwit> Do you just constantly switch between computers?
21:14:36 <SamB_XP> no!
21:14:41 <patc> Hi, can anyone help me with an easy question?  I'm wondering what the standard "make-like" utility is for Haskell.
21:14:49 <dmwit> patc: cabal
21:14:50 <mauke> ghc
21:14:55 <jeffwheeler> patc: cabal, which uses ghc -make
21:14:59 <jeffwheeler> (Often.)
21:15:01 <dmwit> --make
21:15:01 <SamB_XP> I switch sporadically
21:15:12 <ChilliX> stepcut: Sounds quite right.  Problem is who should be maintainer then?
21:15:39 <patc> Thanks all, I've been using ghc --make but want something that will deal with the foreign interface thing nicely and deal with C.  I'll give cabal a look
21:15:56 <stepcut> dunno. Someone who would thrive in the role. It's a pretty crappy job, but some people seem to really like it.
21:16:31 <jeffwheeler> stepcut: don't put that in the request for people. :P
21:16:39 <erikc> isnt maintainer basically playing wack-a-mole on bad commits/committers?
21:17:23 <jeffwheeler> I think real, forced automated testing would go a long ways to making the job easier for any potential person.
21:17:35 <jeffwheeler> Don't allow people to commit bad stuff to begin with.
21:17:36 <stepcut> erikc: among other things. Also planning releases, coordinating major changes, etc.
21:17:52 <stepcut> erikc: it defininately more administrative than anything else
21:18:11 <SamB_XP> so, who can play whack-a-mole ?
21:19:31 <stepcut> SamB_XP: well, there is more than just whack-a-mole. There is also merging, planning, etc.
21:19:44 <SamB_XP> hmm, true
21:19:58 <SamB_XP> merging is a very important aspect
21:20:50 <SamB_XP> ... and darcs doesn't seem to like it much :-(
21:20:59 <Trinithis> If a file is not named Main, how can you tell the ghc to make an exe from it?
21:21:01 <stepcut> SamB_XP: right, I believe it is one of the core issues that started this discussion. (Specifically, merge early, merge often, resulting in broken head too often)
21:21:18 <stepcut> Trinithis: -main-is i think ?
21:21:37 <stepcut> Trinithis: oh wait ,that is different
21:21:41 <Trinithis> :D
21:21:53 <stepcut> Trinithis: ghc --make YourFile.hs -o prog.exe
21:22:02 <SamB_XP> in git development they have a special "branch" which merges all the latest stuff ...
21:22:11 <stepcut> Trinithis: is that what you mean ?
21:22:41 <SamB_XP> (I quote because it doesn't really have a coheherent branch history or anyything)
21:22:41 <Trinithis> I have my main module named Fungi.hs, and it stops compiling when it reaches object code
21:23:09 <stepcut> Trinithis: does it still say, module Main where, at the top of Fungi.hs ?
21:23:28 <Trinithis> stepcut: Whoops. Good call
21:23:46 <Trinithis> That did the trick
21:24:56 <stepcut> Trinithis: you could also do, ghc --make -main-is Fungi Fungi.hs  -o fungi, but 'module Main where' is probably a better solution
21:25:16 <Trinithis> ghc doesnt recognize -main-is
21:25:29 <SamB_XP> maybe --main-is ?
21:25:41 <stepcut> Trinithis: that command-line worked for me using ghc 6.8.2
21:25:59 <Trinithis> ghc 6.8.3 here. module Main where is fine by me tho
21:47:04 <jganetsk_> does anyone know what yhc is?
21:47:36 <jeffwheeler> Isn't it just another less popular Haskell compiler?
21:47:37 <dmwit> ?where yhg
21:47:37 <lambdabot> I know nothing about yhg.
21:47:40 <dmwit> ?where yhc
21:47:40 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
21:47:56 <dmwit> jganetsk_: Why do you ask?
21:48:23 <jganetsk_> is this a new compiler?
21:48:38 <dmwit> I don't think it's very new.
21:48:50 <cjb> jganetsk_: several years old, never been very popular, good cross-platform support
21:49:05 <cjb> (it works on ARM, for example, and GHC doesn't very well)
21:49:46 <dmwit> According to the blog, they hit 1000 patches at the end of 2006, so it's at least that old.
21:50:21 <dmwit> And it's old enough to link to the old hawiki as part of its docs, so... =)
21:51:56 <Twey> cjb: Do you own cjb.net?
21:52:35 <Twey> GHC works on ARM via gcc, at least, no?
21:52:46 <thoughtpolice> ChilliX: I have expressed my thoughts on cvs-ghc; let us hope things can turn out for the better, or at least more people can be in the loop than those who currently work at MSR it seems. :)
21:52:50 <cjb> Twey: sadly not.  they stole my googlejuice.
21:52:58 <Twey> Ah, heh.
21:53:17 <Twey> I remember when that was the #1 free hosting/URL redirection site
21:53:25 <Twey> Everyone had a .cjb.net subdomain or two
21:53:32 <cjb> I think it was just dynamic dns
21:53:39 <MyCatVerbs> Twey: I seem to be under the impression that -fvia-C is eventually going to go away when -fasm becomes sophisticated enough to obviate the need for it.
21:53:54 <Twey> I don't remember what it was, just that everybody had one.
21:54:06 <Twey> MyCatVerbs: Probably
21:54:23 <Twey> That will be about when GHC overtakes gcc in terms of platform support anyway, though
21:54:32 <MyCatVerbs> Nah.
21:54:38 <Twey> Erm
21:54:48 <Twey> So we're basically just going to lose a bunch of platforms?  :-\
21:54:52 <MyCatVerbs> GHC's not likely to ever overtake gcc for platform support, surely?
21:55:05 <MyCatVerbs> Twey: possibly I am entirely wrong. :)
21:55:19 <Twey> Then -fvia-C will never be rendered obsolete, will it?
21:55:30 * MyCatVerbs shrugs.
21:55:45 <jeffwheeler> Only obsolete on platforms where -fasm is good enough, right?
21:56:40 <MyCatVerbs> Twey: I don't know. On second thoughts, I think there -are- maybe a couple of commercial uses of Haskell in embedded spaces where ARM is popular.
21:56:50 <Guest61322> anyone know a good programmers font that displays  right?
21:57:03 <jeffwheeler> Guest61322: what platform?
21:57:12 <Zao> Guest61322: What's that, half a spider?
21:57:21 <SamB> it's like ::
21:57:25 <Guest61322> supposed to be :: yea
21:57:30 <thoughtpolice> -fvia-C will probably never go away, it's necessary for porting from what I can tell. however, -fasm is going to become the preferred method in the future naturally once things continue getting better (it is already the default in 6.8)
21:57:34 <Guest61322> win32
21:57:48 <jeffwheeler> Guest61322: most monospace fonts look decent --- you might be having aliasing problems
21:57:49 <MyCatVerbs> Twey: it's not really the domain for it though, after all. Haskell's very... amortization-oriented, if you can decipher my abuse of the English language.
21:57:59 <Guest61322> well its just showing up as a box in all the fonts i tried
21:58:10 <Guest61322>  work though
21:58:11 <jeffwheeler> Guest61322: err, what editor are you using?
21:58:27 <SamB> Guest61322: maybe in http://naesten.dyndns.org:8080/unifont-mono.zip ?
21:58:31 <Guest61322> GNU Emacs 22.2.1 (i386-mingw-nt5.1.2600)
21:58:42 <Twey> MyCatVerbs: Even if it weren't, I don't see the need to cut out what's basically an automatic route to all the latest platforms just to save a kilobyte or so in the compiler
21:58:57 <jeffwheeler> Guest61322: try a newer Emacs that has Xft compiled with it; I'm not sure how you can get this for Windows.
21:59:09 <Twey> Guest61322: Fixed [EFont] has it
21:59:10 <jeffwheeler> Guest61322: you might have better luck asking about fonts in #emacs, though
21:59:16 <SamB> Twey: I think it's more than a kilobyte ;-P
21:59:28 <Guest61322> k ill check it out
21:59:29 <Guest61322> thanks
21:59:41 <thoughtpolice> Twey: well like said it's really necessary for porting; any c code generated by GHC with -fvia-C is going to be nastily platform specific
21:59:42 <MyCatVerbs> Twey: duplication of work, I think.
21:59:43 <dmwit> Terminus looks nice, though I don't know about its Unicode coverage.
21:59:43 <Twey> SamB: If it's less that 32M, it's worth it :)
21:59:55 * cjb can see it, in emacs/xft/linux.
22:00:01 <thoughtpolice> (hence the way you have to actually port GHC by manually copying over a few header files)
22:00:04 <SamB> though obviously you could avoid compiling -fvia-C in some ports
22:00:06 <Twey> Hmmmm
22:00:46 <SamB> er. in some builds, I guess I mean
22:00:51 <MyCatVerbs> Twey: there's (I believe) a certain amount of work that gets duplicated between the two code paths.
22:01:07 <thoughtpolice> right now, the only compiler I know of that you can take, produce C files and run them basically anywhere is GHC
22:01:08 <SamB> MyCatVerbs: there would be, yes
22:01:13 <thoughtpolice> er
22:01:14 <thoughtpolice> JHC
22:01:18 <thoughtpolice> since it produces pure ISO C
22:01:26 <SamB> but JHC is rather buggy
22:01:32 <thoughtpolice> indeed-y.
22:01:35 <SamB> and incomplete
22:01:44 <MyCatVerbs> Twey: I mean, I personally don't care about negligible disk space usage either. What I do care about is that, the more time the GHC devs have to spend on hacking on this kind of stuff, the less time they have to spend hacking on tasty optimizations and cool new features. :)
22:01:46 <thoughtpolice> i never said you'd get very far. :)
22:01:55 <Twey> MyCatVerbs: Mmmmm.
22:02:10 <thoughtpolice> that's why we have interns!
22:02:13 <SamB> I mean, it's implementation of typeclasses was generating ill-typed RULES last I checked...
22:02:16 <thoughtpolice> :p
22:02:20 <MyCatVerbs> Twey: even when you have volunteers, you still have to think in economic terms. Just that the currency of choice is time and effort, not cash. :)
22:02:49 <MyCatVerbs> SamB: ! Oh dear.
22:03:08 <SamB> MyCatVerbs: of course, we DO need -fvia-C until such time as it's possible to port GHC without it
22:03:11 <MyCatVerbs> SamB: wait, you mean RULES as in same thing as GHC's RULES pragma for reductions on pieces of code?
22:03:24 <SamB> MyCatVerbs: pretty much, yes
22:03:40 <MyCatVerbs> Huh. That's supported cross-platform?
22:04:00 <MyCatVerbs> Er. I mean, on more compilers than just GHC?
22:04:04 <SamB> a little, yes
22:04:20 <MyCatVerbs> Sweet.
22:04:22 <Guest61322> SamB: yea that font worked thanks
22:04:31 <Guest61322> too bad the arrows are so puny ;O
22:04:38 <thoughtpolice> JHC is the only other one apparently?
22:04:43 <SamB> Guest61322: you're welcome ;-)
22:05:44 <SamB> thoughtpolice: afaik
22:05:53 <MyCatVerbs> SamB: not sure if I *could* see the C codepath becoming unnecessary for porting's sake, unless someone wants to set up infrastructure for cross-compiling.
22:06:00 <thoughtpolice> i think JHC is pretty sweet if you ask me
22:06:08 <thoughtpolice> it just lacks motivation and development time
22:06:12 <SamB> MyCatVerbs: that's my point exactly ;-)
22:06:33 <erikc> region-based memory management is pretty attractive
22:06:35 <thoughtpolice> hopefully the brand new backend will make life more managable. :)
22:06:43 <MyCatVerbs> SamB: y'know what else would be awesome? GHC's RTS without an operating system. :)
22:06:44 <SamB> ... new backend?
22:06:51 <SamB> but it's the frontend that is so horrible!
22:07:09 <thoughtpolice> erikc: afaik JHC and MLKit are the only compilers that even mention using region-based memory
22:07:14 <SamB> MyCatVerbs: yes, it does seem rather POSIX-specific
22:07:49 <thoughtpolice> MyCatVerbs: indeed nice. there was reflection on it in the lightweight concurrency primitives paper
22:08:09 <SamB> GHCi is never going to run with no OS, though -- at least, it needs an FS ...
22:08:18 <MyCatVerbs> SamB: it works nicely enough on Win32 though, doesn't it?
22:08:23 <thoughtpolice> that's pushing it a little, naturally :)
22:08:46 <SamB> MyCatVerbs: well, win32 does make some concessions towards POSIXy stuff
22:08:54 <newsham> you can have a filesystemw ithout an OS.  look at DOS and CP/M :)
22:09:01 <MyCatVerbs> SamB: sure, but in principle why shouldn't I be able to do something scary like link a VM (not necessarily GHC's RTS) into a kernel's address space? :)
22:09:40 <thoughtpolice> I would say mainly threading primitives honestly; that's probably why the lightweight concurrency paper mentioned it
22:10:04 <SamB> well, what I mean is that GHCi makes no sense without a place from which to read sources, .hi files, and libraries ...
22:10:27 <newsham> just load up a bunch of stuff in the zipper filesystem
22:10:55 <MyCatVerbs> SamB: jah. You could implement a very small in-core filesystem, though, to bootstrap yourself. :)
22:12:01 <newsham> http://programatica.cs.pdx.edu/House/
22:12:02 <lambdabot> Title: House
22:12:20 <MyCatVerbs> SamB: besides, GHCi is all bytecoded and slow. Just imagine how much work it'd take to make GHC itself run without an OS present. ;)
22:12:44 <newsham> does house run in ghci?
22:12:47 <newsham> err ghci run in house?
22:13:05 <glguy> run GHC are bare metal?
22:13:36 <glguy> on*
22:13:37 <MyCatVerbs> glguy: that's what I'm suggesting. I'm also aware that it's a silly idea, though.
22:13:47 <glguy> it has only been done one or two times
22:13:55 <glguy> already
22:14:29 <MyCatVerbs> Oh. Heh.
22:14:35 <newsham> http://www.ninj4.net/kinetic/haskell-independent.html
22:14:36 <lambdabot> Title: Running Haskell on bare iron
22:16:19 <thoughtpolice> yeah, but there's no source to kinetic from the looks of it.
22:17:01 <thoughtpolice> doesn't help much, tbh. and house actually uses a re-vamped version of an older GHC RTS iirc, so neither really help much if you just want the idea.
22:17:14 <MyCatVerbs> "The signature for this call is precisely what you'd expect, given that GHC thinks it is trying to build a Linux binary@" <-- oh dear. The skullduggery inherent in this is both frightening and awesome.
22:18:22 <newsham> its rather like fitting wheels to a tomato
22:19:07 <newsham> i look forward to someone writing a haskell RTS in haskell.
22:19:50 <MyCatVerbs> At a guess, I'd presume the only VMs really worth running as operating systems are those that're explicitly designed to accomodate code loading at runtime, and to make it not prohibitive performance-wise to do so compared to loading a single larger binary - i.e. JVMs. :/
22:20:54 <newsham> sometimes you dont need code loading.  like singularity, designed to be statically linked with all the apps you want to use.
22:20:59 <newsham> ie. embedded device
22:21:48 <MyCatVerbs> newsham: in which case you probably don't want an operating system, no? ;)
22:21:54 <olsner> you don't need anything much more advanced than the ability to load a binary into memory and jump to the first byte of the file
22:22:14 <newsham> mcv: i guess it all comes down to how you define an OS
22:22:22 <hml> i'm in the vim haskell mode; I'm hitting _t on a var, it returns for me "type not known" ... anyone else has experience with this problem?
22:22:30 <newsham> lots of embedded devices use linux.
22:22:38 <MyCatVerbs> newsham: (or, more concretely, in which case you may as well partially apply your operating system (if any) to your app, because they're not really all that seperate anymore)
22:24:32 <MyCatVerbs> Heck, if you're doing that, why not go the whole hog and use a whole-program optimizer too? :)
22:26:19 <olsner> you're not always in control of the software you're putting together... in particular, you won't have the source for everything
22:27:01 <jeffwheeler> The idea of controlling all side-effects as part of an OS is pretty neat --- Kinetic has gotten my interest, for sure.
22:27:36 <patc> Is there any way of putting numbers in a name field in cabal?  I'm trying to make a package called "rp4.5", but cabal wants me to make a package called "rp", version 4.5, and call the thing "rp-4.5".  I do not want this
22:29:46 <MyCatVerbs> olsner: pity.
22:30:20 <olsner> yep
22:32:31 <erikc> hrm, is there a cabal idiom for a main.c that calls haskell? (i have to do this on windows because SDL issues with SDL_main)
22:39:37 <ChilliX> thoughtpolice: great, thanks
22:46:43 <thoughtpolice> ChilliX: thanks to you guys. great compiler you have helped bring us, I want to see it do better. :)
22:59:30 <hml> @src <-
22:59:30 <lambdabot> Source not found. I feel much better now.
22:59:39 <hml> @src ->
22:59:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:59:45 <hml> @src $
22:59:45 <lambdabot> f $ x = f x
23:00:00 <dolio> <- and -> are both syntax.
23:00:10 <hml> where is this documented?
23:00:26 <dolio> Actually, I guess -> isn't when it's the function type constructor.
23:00:30 <dolio> But nevertheless.
23:00:55 <dolio> I'm sure the report has a list of keywords and such.
23:02:47 <hml> hmm, so a <- x is like: x >>= \a ?
23:03:23 <dolio> Sort of, although those fragments aren't meaningful on their own.
23:03:36 <hml> is there a way to condednse the following into a singl eline:
23:03:38 <hml>             l2 <- readIORef lines
23:03:38 <hml>             writeIORef lines ((x,y):(tail l2))
23:04:08 <dolio> @hoogle modifyIORef
23:04:08 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
23:04:08 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
23:04:28 <hml> lol, i took modifyIORef and rewrote it as above
23:04:34 <dolio> modifyIORef lines (\l2 -> (x,y):(tail l2))
23:04:37 <hml> is there a way i can do the rewriitng with >>= ?
23:04:57 <hml> because i'm stupid; is there a way to do this in one line w/o using modifyIOref ?
23:05:01 <hml> @src modifyIORef
23:05:01 <lambdabot> modifyIORef ref f = writeIORef ref . f =<< readIORef ref
23:05:09 <hml> there we got; thanks
23:05:17 <dolio> Yeah. readIORef lines >>= \l2 -> writeIORef lines ((x,y):tail l2)
23:08:54 <dolio> @seen dons
23:08:54 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 28m 36s ago.
23:09:12 <hml> hmm, so dataIORef is like haskell's variables
23:09:33 <hml> with writeIORef/readIORef for writing/reading
23:10:08 <dolio> Yes, they're essentially global mutable variables.
23:10:50 <dolio> Although, they aren't global in scope unless you do some tricks.
23:12:49 <hml> is it well defined if I write to it once and then read from it twice?
23:13:05 <dolio> Yeah.
23:13:19 <hml> so it's not like a 'port' in teh sense of I write to it, and then i can read from it
23:13:29 <nornagon> dolio: by 'tricks' you mean 'dirty unsafePerformIO hacks', yes?
23:13:33 <hml> but when i write to it, it's stored there in a container, i can read from it as many times as i wishy
23:13:35 <dolio> No. It's just like a mutable memory location.
23:13:47 <hml> and it stays the same until I write to it again?
23:13:51 <dolio> nornagon: Yes.
23:18:45 <ivanm> @seen Lemmih
23:18:45 <lambdabot> I haven't seen Lemmih.
23:32:23 <glguy> preflex: seen lemmih
23:32:23 <preflex>  lemmih was last seen on #haskell 3 days, 15 hours, 11 minutes and 28 seconds ago, saying: @seen Lemmih
23:33:45 <ivanm> what, he didn't know if he was online? :p
23:34:04 <glguy> @uptime
23:34:05 <lambdabot> uptime: 7h 18m, longest uptime: 1m 10d 23h 44m 29s
23:34:24 <glguy> anymore you can't count on lambdabot for seen times over a day ;)
23:35:32 <ivanm> true :s
23:35:36 <ivanm> why is that?
23:39:19 <glguy> ivanm: it has just been unstable for a while now
23:39:39 <ivanm> surely _some_ change in her code must have caused the instability...
23:45:56 <hml> wow, glfw bindings are far far better than glut bindings
23:46:28 <hml>           if d then (render lines >> GLFW.swapBuffers) else return ()
23:46:28 <hml>           writeIORef dirty False
23:46:39 <hml> writeIORef dirty False gets executed no matter what right?
23:46:52 <hml> since return () is about constructing a value, rather than changing control flow
23:47:10 <Deewiant> yep
23:47:29 <Deewiant> you can also write that if as "when d (render lines >> GLFW.swapBuffers)"
23:48:33 <hml> @src when
23:48:34 <lambdabot> when p s = if p then s else return ()
23:50:01 <hml> @hoogle when
23:50:01 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
23:51:40 <hml> what's the haskell negation operator?
23:52:14 <hml> not nyumeric negation, boolean negation
23:52:14 <dainanaki> -
23:52:18 <dainanaki> oh
23:52:19 <hml> sorry
23:52:19 <dainanaki> not
23:52:32 <dainanaki> not True = False
23:52:39 <dainanaki> not False = True
23:53:06 <Beelsebob> you may also be interested in (/=)
23:53:16 <Beelsebob> (does not equal)
23:53:49 <mercury^> @src not
23:53:49 <lambdabot> not True   =  False
23:53:49 <lambdabot> not False  =  True
23:53:52 <mercury^> :)
23:54:03 * araujo loves FP
23:54:06 <dainanaki> called it
