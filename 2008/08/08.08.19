02:10:51 --- topic: '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]'
02:10:51 --- topic: set by quicksilver on [Thu Aug 14 06:05:53 2008]
02:59:31 <MarcWeber> sbahra: Hi, are you still around?
03:02:03 <MarcWeber> sbahra: Sure I still have all that code.. About the completion: It has been to slow. You were faster typing the names yourself. I recommend using shim instead
03:02:20 <MarcWeber> @tell sbahra ping me again please
03:02:21 <lambdabot> Consider it noted.
03:09:12 <Saizan> *Make.TestMonad> :type jobcontrol
03:09:15 <Saizan> *Make.TestMonad> :type jobcontrol                                                                                                                            jobcontrol :: JobControl (Test GHC.Prim.Any GHC.Prim.Any) [(GHC.Prim.Any, GHC.Prim.Any)]
03:09:27 <Saizan> looks like a bug..
03:24:59 <dcoutts> @ask stepcut perhaps you could reply to the question posted to -cafe about the cabal->debian tools? You know much more about it than me. (thread starting "ANN: wavconvert 0.1.1")
03:25:00 <lambdabot> Consider it noted.
03:30:21 <BeelsebobWork> ah a dcoutts
03:30:31 <dcoutts> BeelsebobWork: mm?
03:30:51 <BeelsebobWork> I have a minor problem with cabal -- which it may have a way to fix, and if it doesn't I'd like to suggest a way
03:31:04 <BeelsebobWork> in early development, my API changes a lot
03:31:14 <BeelsebobWork> I'm too lazy to change the version number every time there's an API change
03:31:26 <BeelsebobWork> the result of this, is that I often get build conflicts that configure doesn't pick up
03:31:47 <BeelsebobWork> is there any way to get an auto-incrementing build number (that increments every time you runhaskell Setup build)
03:32:21 <dcoutts> BeelsebobWork: there is no way
03:32:21 <BeelsebobWork> so that I don't have to continuously change the version from 0.0.0.5936 to 0.0.0.5937
03:32:28 <BeelsebobWork> hmm, :(
03:32:32 <dcoutts> BeelsebobWork: I don't understand why you need to increment
03:32:39 <dcoutts> build should just rebuild
03:32:44 <BeelsebobWork> it does
03:32:53 <BeelsebobWork> but if I have 2 cabal projects
03:32:58 <BeelsebobWork> and one depends on the other
03:33:00 <dcoutts> you mean ghc does not notice changes in the other package
03:33:20 <dcoutts> BeelsebobWork: yeah, that's annoying. it's fixed in ghc-6.10 ftiw
03:33:24 <BeelsebobWork> I mean there's no way for me to tell the other developers that they need to check out from darcs again
03:33:38 <BeelsebobWork> (which there would be if I could update the required build number in the second cabal file)
03:33:47 <dcoutts> oh, right, that's true
03:34:07 <BeelsebobWork> so essentially, I'd like kinda micro-versioning
03:34:12 <BeelsebobWork> for development only
03:34:23 <dcoutts> BeelsebobWork: you could put some script into your darcs record to increment
03:34:48 <dcoutts> BeelsebobWork: there's code in Cabal for doing it, we use it to add a snapshot number when you cabal sdist --snapshot
03:34:49 <BeelsebobWork> well, it's not specifically darcs that I want to do the update
03:34:55 <BeelsebobWork> in that it's not always the case that the API changes
03:35:18 <dcoutts> right, you want it to change when the api changes, which is not a trivial thing to track
03:35:23 <dcoutts> though also not impossible
03:35:30 <dcoutts> but needs tools we've not written yet
03:35:49 <BeelsebobWork> well, i don't particularly mind changing the config file when I change the API
03:36:06 <BeelsebobWork> but it'd be nice to have the easy half of it done automagically (i.e. get a unique build number I can refer to)
03:36:42 <BeelsebobWork> but yeh, if it happend automagically, I'd come and have sex with you :P
03:37:39 * BeelsebobWork bimbles off to eat lunch
03:38:20 * dcoutts wonders if it'd be wise to specifically avoid adding the feature
03:38:35 <Axman6> dcoutts: take one for the team
03:43:07 <cjs> How do I indicate "bottom" as a type?
03:43:29 <dcoutts> cjs: there is no bottom type, bottom is a value of every type
03:43:37 <dcoutts> or rather every type has a bottom value
03:43:43 <cjs> Hm. So I can't type a function that just calls "error".
03:43:48 <dcoutts> sure
03:43:52 <dcoutts> @type error
03:43:54 <lambdabot> forall a. [Char] -> a
03:44:06 <cjs> Oh, duh!
03:44:08 <dcoutts> :type error "oh noes!"
03:44:16 <dcoutts> @type error "oh noes!"
03:44:17 <lambdabot> forall a. a
03:44:50 <dancor> direct product of a list of lists.  dirProd [[1,2],[3,4],[5,6]] = [[1,3,5],[1,3,6],[1,4,5],[1,4,6],..]
03:47:48 <Vq^> dancor: sounds like 'sequence'
03:48:39 <dancor> Vq^: that's amazing.
03:49:41 <Vq^> :)
03:56:42 <haskellian> Hi all, if you want, have a look at my netflix-parser http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/9e33e4fbc786471a# , any tips on how what the problem is would be greatly appreciated, I will rewrite the parser ina different way and also write one in Python to compare the execution speed. Youa re free to use the code as you want, I am a beginner Haskeller though so it is not something to learn form
03:56:44 <lambdabot> Title: Netflix prize - parser, all the code(for you if you want), some tips wanted - co ..., http://tinyurl.com/5t47w9
04:05:14 <dbbddbdb> Hi!  What does # mean in Haskell grammar?
04:05:20 <mauke> nothing
04:05:33 <mauke> well, I think it's an operator symbol
04:05:41 <dbbddbdb> Prelude> let (#) = (!!)
04:05:41 <dbbddbdb> <interactive>:1:6: parse error on input `)'
04:05:48 <mauke> ... or not
04:06:03 <mauke> dbbddbdb: that works here
04:06:13 <mauke> (#) :: [a] -> Int -> a
04:06:21 <mnislaih> anyone knows why TChans dont have a getChanContents operation but Chans do? is it an omission or there is some reason to it ?
04:06:25 <ziman> it works here, to
04:06:31 <ziman> *too
04:06:37 <dbbddbdb> Hmm, I have 6.8.2
04:06:40 <dbbddbdb> Prelude> :t (#)
04:06:40 <dbbddbdb> <interactive>:1:2: parse error on input `)'
04:06:51 <trofi> :t #
04:07:03 <mauke> dbbddbdb: what extensions are you using?
04:07:37 <dbbddbdb> mauke: -fglasgow-exts -fno-monomorphism-restriction -farrows -fno-print-bind-result
04:07:37 <mauke> anyway, try ( # )
04:07:48 <mauke> yeah, -fglasgow-exts does that
04:08:02 <int-e> so pretty much all of them; the MagicHash extension steals the #
04:08:23 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
04:08:26 <lambdabot> Title: 8.2.�Unboxed types and primitive operations, http://tinyurl.com/y59rbr
04:08:30 <int-e> (and is implied by -fglasgow-exts)
04:09:16 <dbbddbdb> Oh, I see, thanks
04:33:03 <dancor> weird that updateLookupWithKey does the update first
04:33:11 <dancor> seems less generally useful?
04:44:42 <yitz> dancor: i guess the name is ambiguous. there are two cases where you would want to do both of those operations: "update, then report back what happened" or "lookup, and fix things if needed". the library author is thinking of the former, you are thinking of the latter.
04:50:58 <haskellian> when should I use types and when should I use data? Isn't data a type?
04:51:44 <mauke> data creates a new type
04:51:50 <mauke> type creates a new name for an existing type
04:52:02 <yitz> haskellian: type defines an alias for an existing type. data creates a type. newtype creates a clone of type (that you can give different instances)
04:52:47 <haskellian> ok
04:52:52 <haskellian> i see
04:53:36 <mauke> (if you know C, it's a bit like struct/union/enum vs. typedef)
04:57:43 <jtraub> Hello
04:57:48 <jtraub> I am back online
05:02:45 <cjs> Hm. It appears that my ghc 6.8.3 came with bytestring-0.9.0.1.1, but a friend's (probably a Linux one) came with bytestring-0.9.1.0.
05:03:44 <cjs> Why would that be. And is there any way to be compatable with both if you're using IsString and make ByteString.Lazy an instance of it yourself when you use the earlier version? (The newer one already has that, and produces an error when one tries to redefine it.)
05:06:14 <dcoutts> cjs: or if you depend on that instance just upgrade bytestring, it's not hard
05:33:44 <haskellian> lol programming Python now, first moving from java and c++ i loved python being dynamic, now after using Haskell for a while I feel crippled
05:35:16 <cjs> Well, the issue is that I'm trying to avoid making everybody upgrade ByteString.
05:35:29 <cjs> It appears that the issue was my friend had a manual install of it.
05:36:01 <cjs> However, if that instance declaration is there in 6.10, then it's probably not unreasonable to ask 6.8 users to upgrade their ByteString, or just add the instance declaration somehow.
05:36:17 <cjs> BTW, when is 6.10 due out? Still before ICFP?
05:37:06 <yitz> haskellian: i find my python code is becoming unreadable to others - i have to force myself not to use lazy generators and iterators for everything. ;)
05:37:35 <Igloo> cjs: 6.10 itself won't be out before ICFP
05:37:43 <Igloo> A RC should be
05:40:31 <cjs> Well, that's cool.
05:40:50 <cjs> I guess I should get my butt in gear on that lib proposal to hide that PortNum constructor.
05:40:52 <haskellian> yitz: however I feel I still lack haskell-skill, I am rewriting my netflixparser in an instant here in Python and in much less code, but I am determined to learn Haskell because it is a very exciting language
05:41:29 <yitz> haskellian: sounds like you're doing great, it won't take too long before it's the other way around.
05:41:49 * Wild_Cat is attempting to go down the same road.
05:42:23 <Wild_Cat> what I'm missing the most so far is Python's REPL. ghci is just... Meh.
05:42:38 <cjs> It takes some work, though it's fun. There's hardly anything in my current system that I've not rewritten three times.
05:42:51 <Wild_Cat> (dir() and help(), how I miss thee...)
05:42:58 <adekoba> Wild_Cat: really? I find ghci to be a lot easier to work with
05:43:11 <yitz> Wild_Cat: ghci is far more powerful than the python shell in some ways
05:43:28 <Wild_Cat> it's probably got to do more with Python being self-documenting than ghci in itself, though.
05:43:44 <yitz> Wild_Cat: (though I still really miss the ability to declare data types in ghci)
05:44:04 <adekoba> Wild_Cat: you mean like pydoc?
05:44:15 <yitz> Wild_Cat: yeah, there's a little less in the way of docs. but you get used to that.
05:44:24 <Wild_Cat> adekoba: no, like dir(some_module) and help(some_object/class/method/module/whatever)
05:44:45 <yitz> Wild_Cat: besides Haskell itself, what really sets ghci apart from the python shell is :def
05:45:03 <Wild_Cat> (yes, pydoc invokes help() on whatever you give it)
05:45:37 <Saizan> Wild_Cat: see :browse
05:45:47 <adekoba> Wild_Cat: I suppose that's true. But you can set up ghci commands to search hoogle
05:45:55 <Saizan> it's a limited form of dir()
05:46:02 <Wild_Cat> ooh, :browse is funky.
05:46:30 <Saizan> for help() we still need some bridge with haddock
05:47:04 <yitz> Saizan: even if we had that, it will only work when we have the source code.
05:47:43 <Saizan> yitz: we could build a dictionary and install it along the library
05:48:10 <Wild_Cat> docstrings were a mighty fine idea in Python's design.
05:48:11 <Saizan> like we do for hoogle, i think
05:49:02 <yitz> Saizan: if it's not linked into the object file, then there's not much more chance to find it than there is to find the source code.
05:49:39 <Saizan> yitz: why? things like ghc-pkg can keep track of it
05:51:11 <yitz> Saizan: once you're doing that, why not just do it with the source code itself?
05:52:23 <ddarius> Wild_Cat: A mighty fine steal from CL.
05:53:12 <yitz> Wild_Cat: yeah. Haskell's approach is more like javadocs. That also works - we just need a mechanism to deliver the information through the various compile/link/deploy stages.
05:53:13 <Wild_Cat> ddarius: doesn't matter where it got it from, what does count is that it *does* have it. Just like it stole list comprehensions -- another damn good idea -- from Haskell.
05:53:15 <Saizan> yitz: for the same reason that we only install the objects of a library?
05:53:36 <Vq^> yeah, it works quite well in python
05:55:11 <Wild_Cat> yitz: admittedly, Javadoc wasn't a bad idea either. Heck, anything that promotes the writing of helpful documentation is a good idea.
05:55:45 <ddarius> Javadoc is actually one area where Java is better than C#.
05:56:11 <Wild_Cat> ddarius: yes. XML markup in comments... What were they *thinking*?
05:56:15 <Saizan> C# doesn't have api docs?
05:56:56 <Wild_Cat> Saizan: it does, but to write them you need to use stuff like "<param name="foo">The foo parameter</param>" instead of "@param foo The foo parameter".
05:57:32 <yitz> Saizan: There are two reasons to install only the objects: 1. obfuscation 2. save disk space on something not needed
05:58:30 <yitz> Saizan: Reason 1 doesn't apply here, we are trying to document how things work. Reason 2 doesn't either - all of the source code helps you understand things better, not just the haddocks.
05:58:54 <Saizan> it could be a closed source library
05:59:05 <Saizan> and you'd still like to have documentation
05:59:28 <Philippa_> and sometimes you don't want people ending up imposing invariants on you because they spotted something that works with the current implementation and now they expect you to maintain it
06:00:25 <yitz> Saizan: if they want to distribute API docs but not source, you could have an option to do that (rip out all function implementations and other parts you don't want to publish). The usual case will be all or nothing, I think.
06:00:30 <yitz> cases
06:00:57 <yitz> Philippa_: true, that's a good point
06:01:29 <ekidd> yitz, Saizen: Another reason for not installing source code is when you just want to produce a single, stand-alone binary.
06:01:41 <Wild_Cat> Philippa_: then again, that's what "internal stuff -- use at your own risk" warnings are for.
06:01:51 <Wild_Cat> or as we say in the Python community, "we're all consenting adults here".
06:01:53 <yitz> ekidd: well then you don't need the haddocks either
06:04:22 <yitz> Wild_Cat: in python, dir() shows all. names that begin with _ warn you to be careful, but we're often not. otoh, help() shows only what the author chose to make public in the doc string, not all of the other # comments.
06:05:53 <Wild_Cat> yitz: yup. Item 1. is easily "ported" to Haskell (something starts with _? use at your own risk, if I change it and it breaks, tough luck, you were warned). As for item 2, it's the same thing as Haddocks vs regular comments IMO.
06:05:57 <Saizan> reparsing the source of the compiled libraries i load in ghci to get the haddocks seems quite wasteful, so i'd like a precompiled dictionary anyway
06:09:20 <yitz> so let's see, what pieces do we need to do this? we already have :browse, which is basically dir(). to get help(), we need (1) something to extract the help info from the source code - probably an addition to haddock (2) cabal needs to know how to make it available in a package, and install it somewhere useful (3) ghci needs to know how to use the information
06:09:49 <yitz> (3) could be implemented using :def to begin with
06:09:51 <Saizan> why an addition to haddock?
06:09:59 <adekoba> while we're on this topic, does anyone know if I'm supposed to stick with hoogle's shipped dictionary or create my own?
06:10:00 <yitz> Saizan: not necessarily
06:10:27 <Philippa_> Wild_Cat: funny, maybe I /don't/ consent to my code being used that way
06:10:56 <Philippa_> also: no, there are more subtle examples that don't involve calling internal code
06:11:38 <lilac> Philippa_: you thinking of things like data dependencies and fixpoints?
06:12:32 <cjs> What's the standard way to test if a file exists?
06:12:51 <cjs> (I want to write a file, but not overwrite it.)
06:12:54 <adekoba> cjs: http://haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html#v%3AdoesFileExist
06:13:01 <Zao> cjs: Try to open it?
06:13:06 <lambdabot> Title: System.Directory, http://tinyurl.com/5waeo3
06:13:16 <cjs> Ah, it is System.Directory.
06:13:17 <lilac> cjs: don't test then open, unless you're ok with the potential race condition
06:13:17 <Philippa_> lilac: and algebraic properties that you don't intend to guarantee
06:13:25 <Zao> Any separate test would be subject to race conditions, but depending on your situation, it may be acceptable.
06:14:31 <cjs> I can live with the race condition, in this instance.
06:14:32 <Wild_Cat> Philippa_: well, if you don't consent to your code being used that way, not releasing the source's more or less the only option, isn't it?
06:15:05 <cjs> I guess the only real way around it is to make a dir and work in it, right?
06:16:06 <lilac> Philippa_: i guess the counterargument would be that it's not necessarily your responsibility to maintain compatibility of non-documented 'features' (unless you're selling your code, and maybe not even then)
06:16:34 <cjs> If you're selling it, it's your responsibility to the degree you feel financial pain from not doing so. :-)
06:16:49 <fons> Hi all
06:17:00 <Vq^> hi fons
06:17:04 <fons> I have problem with haddock
06:17:13 <fons> I installed haddock 2.0 from hackage in Ubuntu
06:17:17 <Wild_Cat> non-documented features and "private" (or marked as such) interfaces are such for a reason. Namely, that people other than their developer/maintainer aren't expected to use them.
06:17:18 <lilac> cjs: true, but that's a business concern, not really an engineering one. People In Suits sort that out ;-)
06:17:26 <Philippa_> Wild_Cat: The only way to truly enforce it, yes. As a rule, an effective community isn't built on what can be enforced
06:17:26 <fons> and it doesn't generate any documentation at all
06:17:37 <fons> I investigated a bit
06:17:41 <Wild_Cat> Philippa_: agreed.
06:18:02 <fons> and running the haddock command show by "./Setup haddock" generates a Segmentation fault
06:18:22 <fons> can anyone give me a hand here?
06:18:23 <fons> thanks
06:18:39 <yitz> Saizan: but haddock seems the most likely way to implement (1), because it already knows how to parse haddock, and how to extract other useful information from a source file.
06:18:50 <cjs> Actually, I find engineers are often better for sorting out those issues, because the suits often not only can't evaluate the various engineering solutions to the problem, but they often can't even do a basic economic analysis.
06:19:24 <Saizan> yitz: err, i meant haddock looks enough for me, and in that case we still have (2) even if the information is in html form
06:19:34 <Saizan> s/still/already/
06:21:18 <yitz> Saizan: well almost. I think there are still some problems with getting haddocks via cabal-install. but then (2) reduces to that same issue.
06:23:22 <Saizan> yitz: right, cabal-install doesn't run haddocks by default
06:24:31 <yitz> Saizan: also - you are then stuck with haddocks being exactly what is available when you publish. sometimes you might want less, or more.
06:28:43 <Saizan> yitz: yeah, ideally we'd use a neutral format so both haddocks and other tools can produce it, even if here we're departing from the concept of docstrings i think
06:36:12 <hackage> Uploaded to hackage: ghc-paths 0.1.0.5
06:42:35 <Saizan> ?hackage ghc-paths
06:42:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-paths
07:08:41 <Arnar> mornin'
07:09:03 <Arnar> I was wondering.. how do I join (in the conventional sense) threads in hs?
07:09:14 <Arnar> Control.Monad.join <- not what I want
07:09:35 <Zao> The canonical way seems to be to stuff the return value into a STM chan and wait on that.
07:09:40 <mauke> or an MVar
07:09:48 <Arnar> hm.. ok
07:10:09 <Arnar> so if I want to fork a bunch of threads (so I have a [ThreadId] list).. and wait for them all?
07:10:34 <Arnar> and why isn't there a primitive for this operation in the lib?
07:10:43 <Arnar> I'd have thought it was very common
07:10:47 <mauke> don't bother with ThreadIds
07:11:05 <mauke> make an empty MVar for each thread and have it put stuff there when it's done
07:11:18 <mauke> then mapM takeMVar
07:11:32 <Arnar> ok, thanks
07:17:51 <Arnar> ok, wait - just to get this straight
07:18:22 <Arnar> newMVar () >>= takeMVar  -- this will block..
07:18:29 <Arnar> until another thread does  putMVar c ()
07:18:32 <Arnar> right?
07:18:39 <Arnar> I have no value to return here, hence the ()
07:19:43 <mauke> no
07:19:51 <Arnar> no?
07:19:55 <mauke> newMVar () >>= takeMVar should return () immediately
07:20:18 <Arnar> ok, that's what I would have guessed
07:20:35 <mauke> :t newEmptyMVar
07:20:39 <Arnar> ah..
07:20:45 <Arnar> thanks, hoogle wasn't helping me here
07:20:59 <mauke> http://www.haskell.org/hoogle/?q=mvar
07:21:01 <lambdabot> Title: mvar - Hoogle
07:21:35 <mauke> wtf
07:21:37 <mauke> @type 42
07:21:38 <lambdabot> forall t. (Num t) => t
07:21:44 <mauke> @type newEmptyMVar
07:21:45 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:21:49 <Arnar> :t 42
07:21:51 <lambdabot> forall t. (Num t) => t
07:22:05 <Arnar> the :t alias fails silently?
07:22:18 <lilac> @type Control.Concurrent.MVar.newEmptyMVar
07:22:20 <lambdabot> forall a. IO (GHC.IOBase.MVar a)
07:28:01 <unC0Rr> hello! Could you help me with regexps? I write  matchRegex (mkRegex "([^, ]+)") "1, 2" which should return the list of matches, and expect it to return Just ["1", "2"], but it returns Just ["1"]. What I do wrong way?
07:28:42 <mauke> your expectation is wrong
07:29:20 <unC0Rr> well, according to documentation, it should return Just ["1", "2"]
07:29:51 <unC0Rr> "Returns: Just strs if the match succeeded (and strs is the list of subexpression matches), or Nothing otherwise."
07:31:01 <mauke> there is only one subexpression in your pattern
07:31:06 <mauke> so the list has only one element
07:31:46 <unC0Rr> why "2" doen't match?
07:32:20 <mauke> because it already matched "1"
07:32:33 <mauke> it stops after the pattern matches the first time
07:32:57 <mauke> at least that's what I'd do if I was a regex engine
07:33:06 <unC0Rr> hm..
07:33:18 <unC0Rr> so you consider regexp is wrong?
07:35:08 <ziman> regexp are greedy
07:35:11 <ziman> *s
07:35:18 <mauke> what
07:36:12 <hackage> Uploaded to hackage: nat 0.2
07:37:40 <ziman> oh, i see, the regex is different from what i thought
07:38:32 <ziman> unC0Rr, i think the `subexpressions' mentioned in the doc refer to parenthesized subexpressions within your pattern (the first one being the entire matched substring)
07:39:15 <ziman> and your regex will not match the whole string
07:39:32 <unC0Rr> ah, I see
07:39:34 <ziman> only the first part until the comma (where it stops)
07:39:35 <unC0Rr> thank you
07:40:02 <ziman> hm, i'm not sure whether the first string is the whole match... you'll figure out ;)
07:40:44 <SamB_XP> if it follows tradition, the first string will be ;-)
07:41:49 <dkirk> this is odd behavior for a regex engine, it seems to me. all the other languages i've worked in return a context that contains all of the matches, not just the first
07:41:59 <Arnar> dkirk: no
07:42:08 <dkirk> perl, java, ruby...yes
07:42:25 <Wild_Cat> dkirk: Python's re.match only returns the first match. re.search returns all matches.
07:42:31 <Arnar> dkirk: most of them (all of which you mention) have functions just like matchRegex.. which return a list of matched subexpressions
07:42:45 <Wild_Cat> I see no searchRegex in Haskell's Text.Regex, though :(
07:42:46 <mauke> dkirk: perl doesn't
07:42:48 <Arnar> @doc matchRegex
07:42:49 <lambdabot> matchRegex not available
07:42:53 <dkirk> yes, but i don't see an API func to return all matches, if matchRegex is meant to only return the first
07:43:01 <Wild_Cat> @doc Text.Regex.searchRegex
07:43:01 <lambdabot> Text.Regex.searchRegex not available
07:43:03 <mauke> you can write a loop around matchAllRegex
07:43:07 <Wild_Cat> @doc Text.Regex.matchRegex
07:43:08 <lambdabot> Text.Regex.matchRegex not available
07:43:10 <dkirk> i tested even with matchRegexAll, and it kind-of did
07:43:14 <mauke> er, that
07:43:20 <mauke> or use the =~ interface
07:44:00 <mauke> @index (=~)
07:44:01 <lambdabot> bzzt
07:44:34 <Arnar> :t Text.Regex.(=~)
07:44:40 <mauke> where the hell is that thing
07:44:41 <Arnar> :t Text.Regex.=~
07:45:05 <mc__> I'm trying to define my own data type which should consist of 2 arbitary numerical types. I tried "data Vector2 = Vector2 Num Num" But that is obviously wrong. Is there a way to accomplish what I want? Or do I have to use a concrete type?
07:45:35 <Deewiant> mauke: Text.Regex.Posix.Wrap
07:46:03 <mauke> mc__: either that or data Vector2 a = Vector2 a a
07:46:28 <dkirk> However, you can use splitRegex (mkRegex ",| ") "1,2" to get what you want
07:46:38 <mc__> mauke: but that would allow every type, wouldn't it?
07:46:51 <mauke> mc__: yes
07:47:01 <mauke> *> "1, 2" =~ "([^, ]+)" :: [[String]]
07:47:01 <mauke> [["1","1"],["2","2"]]
07:47:12 <SamB_XP> mc__: we don't generally constrain the arguments of polymorphic datatypes in the data declaration -- it doesn't do anything useful
07:47:40 <mc__> ah, alright
07:47:40 <Arnar> the regex library is highly polymorphic, hence the api docs are very hard to grok
07:47:43 <SamB_XP> mc__: (most of us consider this to be a defect in the report, I think)
07:47:44 <Arnar> this one is better: http://book.realworldhaskell.org/alpha/glob.html#glob.regex
07:47:55 <Arnar> sorry, replace "alpha" with "beta"
07:47:59 <mauke> unC0Rr: *> concat $ "1, 2" =~ "[^, ]+" :: [String]
07:48:00 <mauke> ["1","2"]
07:49:00 <mc__> mauke:  why is there an 'a' before the equality sign?
07:49:06 <Arnar> now, there was an excellent blog entry just last week or so about haskell regexes
07:49:19 <mauke> mc__: parameter list
07:49:31 <mauke> cf. foo x = x + x
07:50:06 <Arnar> ah, yes, by bos: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
07:50:13 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » A Haskell regular expression tutor ..., http://tinyurl.com/2xtgpw
07:50:54 <dkirk> ooh, much nicer!
07:51:00 <mc__> mauke: I dont quite get it. None of the examples in http://book.realworldhaskell.org/beta/deftypes.html has anything else than the name of the type before the equality sign.
07:51:00 <lambdabot> Title: Chapter 4. Defining Types, Streamlining Functions
07:51:19 <mauke> mc__: none of those types is parametrized
07:51:41 <mauke> mc__: compare 'f = 42' to 'g x = x + 1'
07:52:43 <mc__> I do understand the difference in those two functions. But I dont understand why the data type is parametrized
07:52:53 <mauke> http://book.realworldhaskell.org/beta/deftypes.html#deftypes.paramtypes
07:52:55 <mauke> hah!
07:52:55 <lambdabot> Title: Chapter 4. Defining Types, Streamlining Functions, http://tinyurl.com/5mgbxw
07:53:12 <mauke> actually f isn't a function at all; it's a number
07:53:36 <mauke> g is a proto-number; g x is a number for some argument x
07:54:03 <mauke> the type is parameterized so you can plug different base types into it
07:54:43 <trzkril> mauke: of course f is a function ;)
07:55:06 <ziman> mc__, consider a Pair type: data Pair a = Pair a a -- you want to have Pairs of Int (Pair Int), Double (Pair Double), or Pair of whatever and handle them using a consistent interface
07:55:18 <mauke> trzkril: no.
07:56:24 <sioraiocht> does haskell contain any other non-primitive types besides list and tuple?
07:56:25 <ziman> mc__, so that you can write a function first :: Pair a -> a, which extracts the first value from the pair without needing to bother about the type of the value
07:56:29 <trzkril> mauke: why not?
07:56:37 <sioraiocht> that are not user-defineD?
07:56:43 <mauke> trzkril: because it's type doesn't contain (->)
07:56:47 <mauke> s/'//
07:57:10 <mauke> sioraiocht: yes, functions
07:57:25 <sioraiocht> mauke: ah, yes.  But no other "containers"?
07:57:38 <mauke> nothing built into the language, I think
07:57:44 <sioraiocht> mauke: okay, thanks
07:57:49 <sioraiocht> I didn't think so...
07:57:57 <Arnar> sioraiocht: of course, strings are just syntacic sugar for [Char]
07:57:58 <mauke> functions are containers if you squint hard enough :-)
07:58:22 <sioraiocht> Arnar: Right, I don't consider String a primitive in haskell, heh
07:58:39 <sioraiocht> mauke: I hate you
07:58:52 <rwbarton> sioraiocht: what about Maybe a?  (I'm not sure I understand your question though)
07:59:17 <sioraiocht> rwbarton: I more meant like...ah, COLLECTION types
07:59:18 <mauke> Maybe is a library thing; it has no special syntax
07:59:33 <rwbarton> Yeah, but I didn't think the question was about syntax. *shrug*
07:59:33 <sioraiocht> and yeah, technically Maybe isn't built-in
08:00:08 <rwbarton> It's unclear whether [] is "built-in"
08:00:09 <Arnar> sioraiocht: () is one.. you can call it a container if you want I guess :)
08:00:15 <mc__> mauke:  And how would I plug different base types into it?
08:00:20 <sioraiocht> Arnar: not really...
08:00:37 <trzkril> mauke: how can you write a function of type "() -> t" in Haskell?
08:00:38 <mauke> mc__: Vector2 Int, Vector2 Double, etc
08:00:51 <mauke> mc__: same syntax as function application
08:00:56 <Arnar> trzkril: you are entering dangerous waters
08:00:57 <Arnar> :)
08:01:06 <mauke> trzkril: f () = error "what"
08:01:55 <Arnar> > const 1 $ ()
08:01:57 <lambdabot>  1
08:02:14 <mauke> :t let f () = error "what" in f
08:02:15 <lambdabot> forall a. () -> a
08:02:27 <trofi> :t ()
08:02:29 <lambdabot> ()
08:02:33 <mc__> mauke:  like:  IntVector2 =  Vector2 Int   ?
08:02:44 <mauke> mc__: oh, you want to give it its own name?
08:02:52 <mauke> mc__: type IntVector2 = Vector2 Int  -- then
08:03:25 <trzkril> > let f () = error "what" in f
08:03:26 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
08:03:27 <lambdabot>                ...
08:03:38 <mc__> mauke: no I dont really want to do that I was just curios :) thanks for your help
08:05:55 <pmurias> is there any integration support between the debian packaging system and cabal?
08:09:13 <gpds> i'd like to modify some programs to run concurrently on 8 cores.  does anyone know of any articles, blogs, or code I can look at?
08:09:40 <trzkril> mauke: what I was looking for is a function for a given type a, not for all. Can this be done in Haskell?
08:09:42 <mauke> do your programs use threads (as in forkIO)?
08:09:55 <mauke> trzkril: depends on the type
08:10:04 <gpds> not right nw
08:10:06 <mauke> well, not really
08:10:16 <gpds> they're all serial
08:10:25 <mauke> trzkril: you could always provide an explicit type signature and restrict the type that way
08:10:44 <rwbarton> trzkril: you mean like this?  f () = 42
08:10:51 <trzkril> mauke: then I have some misunderstanding of what the type () really is.
08:11:04 <trzkril> rwbarton: something like that, yes
08:11:10 <rwbarton> trzkril: you can write that, but usually it doesn't do you much good
08:11:26 <mauke> trzkril: data () = ()
08:11:39 <mauke> it's a type containing one (defined) value, which is also called ()
08:12:30 <rwbarton> trzkril: (because morally this f is a fuction you can only evaluate at ().  You might as well just replace 'f ()' with 'x' everywhere)
08:12:53 <trzkril> rwbarton: of course.
08:12:58 <yitz> pmurias: we were just discussing that here yesterday. someone has cabal-debian, to create a deb for a cabal package. It's not in hackage yet.
08:14:10 <trzkril> maybe I should do some reading about haskells type system.
08:14:48 <mauke> const struct Unit {} unit;  // C++ :-)
08:16:10 <byorgey> well, except in C++ you would still be able to tell different values of that type apart, because of pointer equality
08:16:29 <mauke> yes, you'd have to disallow creating new instances
08:16:36 <byorgey> sure.
08:16:38 <mauke> by using a private constructor, etc
08:16:53 <byorgey> yeah, that would do it =)
08:17:02 <yitz> @seen stepcut
08:17:02 <lambdabot> I saw stepcut leaving #haskell, #haskell-blah and #xmonad 12h 2m 53s ago, and .
08:17:08 <mauke> http://mauke.ath.cx/stuff/c++/awesome/null.hh
08:17:11 <yitz> pmurias: http://src.seereason.com/cabal-debian
08:17:13 <lambdabot> Title: Index of /cabal-debian
08:18:03 <yitz> pmurias: stepcut said it is currently hard to install it. it has rough edges. but we hope it will be in good shape soon.
08:18:17 <mauke> byorgey: heh, or simply overload operator&
08:18:21 <zeno_> @hoogle (a -> Bool) -> [a] -> Bool
08:18:21 <lambdabot> A Hoogle error occurred.
08:18:33 <zeno_> hoogle not working?
08:18:35 <mauke> :t find
08:18:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:19:33 <yitz> @type (not . null .) . filter
08:19:34 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:19:38 <mauke> :t any
08:19:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:19:51 <yitz> oh, yeah
08:20:09 <byorgey> mauke: .... did you write that Just Now?
08:20:26 <igel> hello!
08:20:37 <yitz> @mauke (a -> Bool) -> [a] -> Bool
08:20:37 <lambdabot> Unknown command, try @list
08:20:38 <igel> i have a cabal package
08:20:47 <janszn> @pl unfoldr (\xs -> if null xs then Nothing else Just (splitAt p xs))
08:20:48 <lambdabot> unfoldr (ap (flip if' Nothing . null) (Just . splitAt p))
08:20:49 <zeno_> mauke: was trying to see if none t l = not $ any t l was in prelude
08:20:50 <mauke> byorgey: heh, no
08:21:02 <igel> and i want to access the version number set in the cabal file in the program
08:21:07 <igel> is that possible?
08:21:21 <mauke> igel: yes, xmonad does it
08:21:25 <byorgey> mauke: ah, didn't think so, but... you never know =)
08:21:38 <igel> do you happen to know how? :)
08:22:05 <mauke> import Paths_xmonad (version); ... showVersion version
08:22:45 <igel> what language is this? :O
08:22:47 <yitz> @pl \p -> unfoldr (\xs -> guard (not $ null xs) >> return $ splitAt p xs)
08:22:47 <lambdabot> unfoldr . ap ((>> return) . guard . not . null) . splitAt
08:22:55 <mauke> igel: uh, Haskell?
08:23:17 <igel> oh then the ";" is a typo? :)
08:23:22 <mauke> no
08:23:33 <mauke> Haskell syntax uses ';'
08:23:48 <igel> ?
08:24:01 <igel> iirc i've only seen that in do expressions
08:24:02 <yitz> janszn: takeWhile (not . null) . map (take p) . iterate (drop p)
08:24:05 <igel> do {a; b}
08:24:12 <mauke> > let {x = 21; y = 2} in x * y
08:24:14 <lambdabot>  42
08:24:19 <yitz> @pl \p ->  takeWhile (not . null) . map (take p) . iterate (drop p)
08:24:19 <lambdabot> (takeWhile (not . null) .) . ap ((.) . map . take) (iterate . drop)
08:24:40 <igel> oh ok
08:24:43 <mauke> igel: it's used after 'do', 'let', 'where', 'of' and maybe other places
08:24:55 <mauke> igel: and there's a 'where' at the top of every file
08:25:05 <quicksilver> igel: ; is the explicit form of newline + layout.
08:25:06 <igel> i see
08:25:12 <mauke> of course most people use layout instead
08:25:32 <igel> and i thought i knew this language :D
08:25:37 <janszn> yitz: I know, just looking for alternatives
08:25:50 <kpreid> igel: you can use ; anywhere you'd use a newline
08:26:02 <yitz> janszn: yeah, unfoldr is neat
08:26:10 <haskellian> Here is a comparison between a similar program I have made in Haskell and Python, Python has good performace, Haskell eats up all my memory and eventually runs out of it and terminates:   http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/9e33e4fbc786471a#
08:26:11 <quicksilver> kpreid: well, not really.
08:26:13 <lambdabot> Title: Netflix prize - parser, all the code(for you if you want), some tips wanted - co ..., http://tinyurl.com/5t47w9
08:26:19 <quicksilver> kpreid: only if that newline was a layout newline :)
08:26:27 <janszn> I call it inverseConcat
08:26:51 <quicksilver> janszn: I call it 'chunksOf n' and it is, of course, a half-inverse to concat.
08:27:08 <quicksilver> although by no means the only half-inverse to concat.
08:27:16 <yitz> quicksilver: I always call it groupsOf :/
08:27:34 <yitz> quicksilver: I use it so much that it's in my dot-ghci.
08:28:18 <mc__> Do I have to define Show myself for this Vector2? http://pastebin.com/m143d015c  I'm a bit unsure about the error message
08:29:09 <mauke> mc__: ah, not quite
08:29:22 <mauke> mc__: Num requires the type to implement Show and Eq
08:29:38 <igel> mauke: i'm browsing xmonad's sources... but i didn't find a hint where Paths_xmonad is defined
08:29:41 <quicksilver> mc__: it's actually Eq it's complaining about, not Show.
08:29:47 <mauke> however, Vector2 a is only an instance of Show if a is
08:29:47 <igel> can you give me a hint?
08:29:53 <yitz> @pl \p -> takeWhile (not . null) . evalState (repeatM $ State $ splitAt p)
08:29:54 <lambdabot> (takeWhile (not . null) .) . evalState . repeatM . State . splitAt
08:29:56 <mauke> igel: it's provided by cabal AFAIK
08:30:03 <igel> ok
08:30:05 <quicksilver> oh, good point.
08:30:18 <mc__> So I have to define Eq?
08:30:18 * igel takes a look at cabal docs
08:30:27 <quicksilver> mc__: you can derive it
08:30:30 <quicksilver> like you derived show.
08:30:30 <mauke> mc__: yeah, you should derive Eq
08:30:39 <quicksilver> you will also need constraints on your num instance.
08:30:46 <quicksilver> (Show a, Eq a) => Num (Vector a)
08:30:48 <mauke> mc__: and then say instance (Num a) => Num (Vector2 a) where ...
08:30:50 <janszn> > if'
08:30:52 <lambdabot>   Not in scope: `if''
08:31:19 <mauke> that means 'Vector2 a' is a 'Num' but also requires 'a' to be a 'Num'
08:32:12 <quicksilver> janszn: if' is something in @pl but not properly in lambdabot.
08:32:20 <quicksilver> you need it to @pl if-expressions.
08:33:06 <besiria> code breaks in haskell is \ ?
08:33:22 <mauke> what?
08:33:33 <mc__> mauke: how is that technique called? I have not yet read about it
08:33:54 <quicksilver> besiria: no. You can put a newline anywhere, as long as you get the layout right.
08:33:55 <mauke> mc__: dunno, maybe "class constraint"
08:36:41 <haskellian> could my program eating all the memory have something to do with recursion and tailrecursion? or that I am keeping reference to several lists that are almost the same because of no_destructive updates?
08:36:57 <Arnar> @hoogle (Monad m) => [m a] -> m [a]
08:36:57 <lambdabot> A Hoogle error occurred.
08:37:04 <Arnar> I always forget..
08:37:08 <quicksilver> Arnar: @hoogle doesn't work with class constraints.
08:37:13 <quicksilver> the answer is sequence.
08:37:13 <BMeph> Is there a special name for functions that have a modified inverse relation?
08:37:17 <Arnar> quicksilver: thanks
08:37:59 <BMeph> E.g., for all n. f n . g n == id, and g n . f n == id?
08:38:27 <quicksilver> BMeph: is that just for all n, f n and g n are inverses of each other?
08:38:44 <BMeph> quicksilver: Yes.
08:41:59 <quicksilver> BMeph: I don't know a better way to say that than (f n and g n are inverses of each other) :)
08:43:12 <BMeph> quicksilver: But there isn't anything you could say about f and g, though?
08:46:16 <yitz> BMeph: (f n) . (g n) == liftM2 (.) f g, so you could say that they are lifted inverses
08:47:46 <Saizan> haskellian: seeing your use of foldl it could be a problem of tail recursion
08:49:03 <yitz> haskellian: always use foldl'. foldl is almost always a mistake.
08:49:22 <rwbarton> haskellian: why are you writing your own sort?
08:50:18 <rwbarton> haskellian: where is Review defined?
08:50:24 <rwbarton> haskellian: oh sorry found it
08:51:02 <janszn> quicksilver: found something in haskellwiki/Case
08:55:59 <Saizan> haskellian: also, your main uses monadic combinators (like forM) to do pure things, and "take ((length revx)-2)" is not very memory friendly if revx is long
08:56:51 <Saizan> length has to traverse all of revx, it's O(n)
09:02:55 <daf> that's not being greedy, that's matching more than once
09:03:00 <haskellian> is mapM faster than forM?  if take ((length revx)-2) is not good, what do you do instead?
09:03:03 <Deewiant> take ((length revx)-2) (drop 1 revx) = (init.init.drop 1) revx
09:03:23 <Deewiant> hmm, although
09:03:26 <Deewiant> ?src init
09:03:26 <lambdabot> init [x]    = []
09:03:26 <lambdabot> init (x:xs) = x : init xs
09:03:26 <lambdabot> init []     = undefined
09:03:32 <Deewiant> darn, as I thought
09:03:44 <mauke> @src forM
09:03:45 <lambdabot> forM = flip mapM
09:03:46 <Saizan> haskellian: you can just use map, no need for "M"
09:03:47 <Deewiant> you might want init [] = []
09:03:59 <haskellian> with foldl' do you mean foldl1?
09:04:16 <Saizan> ?type foldl'
09:04:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:04:23 <Saizan> ?src foldl'
09:04:23 <lambdabot> foldl' f a []     = a
09:04:23 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:04:45 <Saizan> foldl' is the stricter version of foldl, since with tail recursion you can't exploit laziness
09:05:00 <haskellian> is "init $ init revx" faster than "take ((length revx)-2)" then?
09:05:07 <Deewiant> yes
09:05:32 <quicksilver> where is haskellian's code?
09:05:42 <Deewiant> http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/9e33e4fbc786471a#
09:05:44 <lambdabot> Title: Netflix prize - parser, all the code(for you if you want), some tips wanted - co ..., http://tinyurl.com/5t47w9
09:06:18 <quicksilver> I'm a bit baffled by how he could be using mapM intstead of map
09:06:21 <quicksilver> they aren't equivalent :P
09:07:03 <Saizan> well yes, to use map he has to remove that "return" and use let x = .. instead of x <- ..
09:07:05 <Deewiant> forM xs (\x -> do return blaa) is sort of equivalent to map (\x -> blaa) xs
09:07:14 <quicksilver> oh, right.
09:07:16 <quicksilver> gotcha.
09:11:00 <CosmicRay> Igloo: ping?
09:11:53 <Saizan> haskellian: update_all is collapsing together customers with the same id?
09:14:43 <Igloo> pong
09:17:42 <haskellian> wher eis foldl' because it is not in my rpelude
09:18:09 <mauke> @index foldl'
09:18:10 <lambdabot> Data.List
09:18:12 <haskellian> saizan: yes exactly
09:18:34 <haskellian> i ahve written several versions of it but only with minor improvement(perhaps neglible)
09:19:11 <haskellian> i guess witching datastructure could helpas other shave said before but i use lists in python(will change perhaps) and it works there
09:20:15 <byorgey> aren't lists in python more like arrays though?
09:20:17 <quicksilver> haskellian: you don't.
09:20:22 <quicksilver> haskellian: you use arrays in python.
09:20:25 <quicksilver> haskellian: very very different :)
09:20:41 <quicksilver> time to calculate the length of a 10 million element array: 0 seconds.
09:20:52 <quicksilver> time to calculate the length of a 10 million element list: rather longer.
09:21:10 <byorgey> oooh, an O(0) algorithm!
09:21:12 <Saizan> update_all doesn't calculate the length
09:21:25 <quicksilver> just an example, Saizan
09:21:26 <Saizan> however it's still a lot of code for what it's doing
09:21:31 <quicksilver> (of the difference between lists and arrays)
09:21:48 <quicksilver> haskellian did use length in one or two places :)
09:26:33 <b\6> what does it look like when a source file has more than one module?
09:27:19 <haskellian> well yes it was a lot to take in at once so the progrma is rather messy, i am rewriting it though and im very happy for allt he advice
09:28:03 <haskellian> is there no scanl'
09:28:05 <Saizan> b\6: that's not supported
09:28:58 <b\6> oh, didn't know.
09:29:44 <Saizan> haskellian: scanl doesn't need the extra strictness
09:30:26 <quicksilver> b\6: in theory it's down to the implementation. GHC doesn't support it.
09:30:33 <b\6> k.
09:30:42 <quicksilver> I don't think any implementation does, in fact.
09:30:59 <rwbarton> # isn't allowed in a literate haskell program in a comment area?
09:31:13 <Saizan> haskellian: think of it like it's returining a python iterator, if you don't look at the next element it doesn't do anything
09:31:17 <rwbarton> oh, just at the start of the line
09:33:45 <mc__> I'm trying to write a define Num on 2-dimensional vectors. But I have a problem, multiplying 2 vectors does not result in a vector but in a scalar, how should I deal with that?
09:34:28 <sbahra> Cale, ping?
09:34:29 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
09:34:45 <sbahra> MarcWeber, ping?
09:35:00 <sbahra> http://cale.yi.org/index.php/Fold_Diagrams is nice
09:35:02 <lambdabot> Title: Fold Diagrams - CaleWiki
09:35:17 <rwbarton> haskellian: I wrote a translation of your python into haskell.  http://hpaste.org/9781
09:35:34 <rwbarton> haskellian: It kills python on speed, even when I use neither ByteStrings nor decent data structures
09:36:10 <Saizan> mc__: there's not really much you can do except using a different operator for that multiplication
09:37:08 <mc__> Saizan: thank you
09:37:26 <quicksilver> mc__: 2-vectors are a poor instance of Num
09:37:32 <quicksilver> mc__: (unless you think of them as complex numbers)
09:37:33 <joey_> mc__: You might consider a new type class
09:37:37 <joey_> With a functional dep.
09:39:07 <haskellian> wow, ty so much rwbarton, i should pay you for all your help
09:40:15 <haskellian> rwbarton: what is the problem with my original haskell-code then?
09:40:23 <haskellian> is it a lot of things addded together?
09:40:58 <rwbarton> haskellian: I didn't try to read it, it was too much longer than the python code
09:41:40 <rwbarton> haskellian: Of course I am still "cheating" a little, I'm building sorted lists and merging them to avoid quadratic time operations
09:42:27 <rwbarton> haskellian: I will accept as payment that you not assume that "laziness or garbage-collection" are the cause of your problems in the future :)
09:44:04 <haskellian> hehe, deal
09:44:24 <trofi> is it leegal to import more, than one module under same alias? import qualified X as A; import qualified Y as A
09:44:51 <BONUS> uh, my guess is ... not?
09:44:55 <b\6> it's ok.
09:45:05 <Saizan> you could also use a Map Int [Review] instead of [Customer] if you don't want to deal with sorting yourself
09:49:14 <abbe> hi
09:49:37 <abbe> what is the equivalent of NULL (in C) or nil (in LISP) in Haskell ?
09:49:44 <mauke> depends
09:49:48 <Zao> depends.
09:49:58 <mauke> the equivalent of NULL is nullPtr, the equivalent of nil is []
09:50:11 <mauke> or Nothing
09:50:17 <abbe> mauke, okay thanks
09:50:26 <atomb> in other words, it depends on the type
09:50:32 <rwbarton> the equivalent of nil is False :)
09:50:40 <atomb> the "null" of a list is the empty list []
09:50:45 <int-e> nil has too many meanings.
09:50:48 <int-e> (so does NULL)
09:50:57 <int-e> > error "NULL"
09:50:59 <lambdabot>  Exception: NULL
09:51:05 <atomb> many types don't have a "null" equivalent
09:51:42 <atomb> but, for any given type 'a', you can instantiate the type 'Maybe a'
09:52:03 <atomb> any data of this type is either 'Just x' or 'Nothing'
09:52:39 <atomb> the fact that it's explicit in the type forces you to deal with the 'Nothing' case, if it's possible
09:52:44 <trofi> > null []
09:52:46 <lambdabot>  True
09:53:25 <quicksilver> Yes, arguably Nothing is the closest equivalent on many contexts.
09:53:44 <gwern> @seen ndm
09:53:44 <lambdabot> I haven't seen ndm.
09:55:03 <gwern> preflex: seen ndm
09:55:03 <preflex>  ndm was last seen on #ghc 6 days, 52 minutes and 24 seconds ago, saying: tibbe: now that sounds like a great plan, staged move, and follow if it turns out to be really good
09:55:04 <gwern> preflex: seen Cale
09:55:04 <preflex>  Cale was last seen on #haskell 9 hours, 57 minutes and 41 seconds ago, saying: yeah
09:56:13 <abbe> okay, thanks for the explanation int-e, rwbarton, atom, trofi, quicksilver, Zao :)
09:58:42 <Zao> And then there's all the fun with bottom as well.
10:03:29 * abbe is having an error with his haskell code, can anyone explain what is wrong with the code at  http://rafb.net/p/YNgdxo20.html
10:03:30 <lambdabot> Title: Nopaste - haskell code giving error
10:03:42 * abbe is following Yet Another Haskell Tutorial
10:05:34 <mauke> abbe: head x and Nothing must have the same type
10:05:46 <mauke> Nothing is not a number
10:07:44 <abbe> mauke, oops, so this means ghc is making sure, that all return paths return same type of data, hmm...? And it evaluates both return paths, hmm...?
10:07:56 <abbe> mauke, right ?
10:08:13 <rwbarton> yes to the first question, no to the second question
10:08:35 <rwbarton> It doesn't evaluate them, it checks at compile time what type they will return.
10:09:19 <rwbarton> (It's a little hard to see that your error is happening at "compile time" in ghci, admittedly)
10:10:44 <abbe> rwbarton, yes this is not compile time, but runtime, right ?
10:11:12 <rwbarton> It might look that way, but it really is compile time.
10:11:29 <rwbarton> If you run your code through a compiler (ghc), it will fail
10:11:53 <abbe> rwbarton, okay, so it is not possible for someone to code a funciton that return a string in one return path and a number in another return path, directly or indirectly, hmm..?
10:11:56 <rwbarton> Basically, ghci compiles your expression ("car [10,20]") and then runs it
10:12:10 <lilac> abbe: what happens at compile time is that ghc decides that car has type [Maybe a] -> Maybe a
10:12:13 <mc__> Do yo think Haskell is a good language for KI programming?
10:12:28 <mc__> eh I mean AI
10:13:19 <lilac> abbe: then in ghci when you enter car [10,20], ghci tells you that [10,20] isn't of type [Maybe a]
10:13:30 <abbe> lilac, okay, so it figure out that the value returned by the function 'car' is of same type as the type of the list parameter, right
10:14:02 <abbe> lilac, so if it a list of integers, returned value should be integer too
10:14:59 <atomb> abbe: if you changed 'then head x' to 'then (Just (head x))', it would then have type [a] -> Maybe a
10:15:00 <rwbarton> abbe: Right.  But the input can't ever be a list of integers, because Nothing also has to be a valid return value, and Nothing isn't an integer.
10:15:00 <lilac> abbe: right, but because car also returns Nothing (which is of type forall a. Maybe a), it knows that car :: [b] -> b, with b = Maybe a, so car :: [Maybe a] -> a
10:15:00 <abbe> lilac, sorry but I'm a n00bie, not much familiar with haskell conventions, trying to adapt to it.
10:15:14 <atomb> but then it might not compose how you want with cdr, etc.
10:15:54 <lilac> abbe: all code paths through a function must return (essentially) the same type
10:16:34 <abbe> okay, got it, thanks atomb, rwbarton, lilac.
10:16:46 * abbe is wondering then how to write an implementation of 'car'
10:16:51 <trofi> strictly the same type
10:17:01 <trofi> > head [1,2,3]
10:17:03 <lambdabot>  1
10:17:13 <trofi> > head "hello!"
10:17:15 <lambdabot>  'h'
10:17:23 <trofi> > head [] -- boom!
10:17:23 <atomb> abbe: the other thing you might want to look at is 'take'
10:17:25 <lambdabot>  Exception: Prelude.head: empty list
10:17:27 <rwbarton> abbe: well, what do you want it to do?  (Is this an exercise in YAHT?)
10:17:29 <atomb> > take 1 [1,2,3]
10:17:31 <lambdabot>  [1]
10:17:40 <atomb> > take 1 []
10:17:42 <lambdabot>  []
10:17:51 <abbe> rwbarton, trying to implement lisp car in haskell, which return first element of the list or nil if list is empty
10:17:51 <trofi> does car return list?
10:18:16 <lilac> trofi: not strictly the same, in some sense: one code path can return (forall a. Maybe a) and another can return Monad m => m b, so long as Maybe a and Monad m => m b can be unified
10:18:31 <abbe> trofi, nop, but an element of list
10:18:34 <rwbarton> abbe: OK.  You can't do that.
10:18:34 <atomb> trofi: i think standard car from lisp/scheme can't be typed in haskell
10:19:00 <rwbarton> abbe: because the code that uses car might try to use its result as an integer, when it's really "nil".
10:19:08 <pgavin> @seen dcoutts
10:19:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 5h 12m 53s ago.
10:19:12 <rwbarton> abbe: but there are no runtime type errors in haskell
10:19:24 <Beelsebob> abbe: I'm missing why that's different from head in Haskell -- nil really means it returned something broken -- which is essentially what error does in Haskell
10:19:42 <Beelsebob> rwbarton: sure they are... Prelude.head: empty list is a runtime type error
10:19:47 <abbe> > head []
10:19:48 <lambdabot>  Exception: Prelude.head: empty list
10:19:54 <Beelsebob> we'd need a dependant type system to catch it though
10:20:17 <abbe> Beelsebob, i wanted to handle the case of empty list.
10:20:22 <trofi> atomb: why not ? car :: [a] -> Maybe a
10:20:26 <abbe> so it seems haskell is the strongest typed language :)
10:20:35 <Beelsebob> abbe: case l of [] -> stuff; (x:xs) -> x
10:20:43 <atomb> trofi: that doesn't have the same semantics as lisp car
10:20:52 <atomb> because it wraps the result in Just if there is one
10:20:54 <trofi> do we need one?
10:20:57 <Beelsebob> test before hand for the empty list... rather than after for code breaking
10:21:07 <trofi> not any type has its nil
10:21:27 <pgavin> @hoogle listToMaybe
10:21:27 <lambdabot> A Hoogle error occurred.
10:21:32 <pgavin> :t listToMaybe
10:21:33 <lambdabot> forall a. [a] -> Maybe a
10:21:35 <trofi> if we would - it would be disaster for the language, IMHO:]
10:21:51 <MyCatVerbs> Pattern match against both! Rather easier to be sure you've gotten it correct, and you almost always end up wanting to bring the head and tail into scope under some or other names anyway.
10:21:55 <atomb> yeah, it's definitely a good thing that we can't assign a type to lisp's car!
10:22:11 <atomb> but yes, pattern matching is the way to go, usually
10:22:22 <abbe> okay, thanks for the explanation :)
10:22:37 <trofi> lilac: i didn't get your example. can you paste sample code?
10:23:56 <MyCatVerbs> atomb: hrmn? data Lispylist a = Cons (Lispylist a) (Lispylist a) | Nil | Atom a. Then car :: Lispylist a -> Lispylist a, then match against the Atom constructor. ^^
10:23:57 <trofi> lilac: or you are about different subtypes of branches? (polymorphous and not)
10:24:17 <haskellian> rwbarton: what is your profession?
10:24:21 <haskellian> if i can ask
10:24:34 <atomb> MyCatVerbs: ah, true. you just can't do it for normal haskell lists ;)
10:24:40 <rwbarton> haskellian: I'm a grad student in topology/category theory
10:25:04 <MyCatVerbs> atomb: or more often, where you'd write (car x) in Lisp, you'd end up writing (case x of (Cons (Atom head) tail) -> x).
10:25:25 <lispy> MyCatVerbs: no, no, data MyCatVerbslist a = Cons (MyCatVerbslist a) | (MyCatVerbslist a) | Nil | Atom a
10:25:41 <MyCatVerbs> atomb: well yes, but Haskell lists are singly-linked immutable lists. Lisp's are singly-linked mutable trees.
10:25:58 <haskellian> ah very cool, what university?
10:25:58 <MyCatVerbs> lispy: The second case there is missing its constructor. ;P
10:26:10 <lispy> MyCatVerbs: ah well, you got the joke surely :)
10:26:23 <lilac> trofi: yes. for instance, in "if f (x :: a) then return x else Nothing", the expression returns either (Monad m) => m a or forall b. Maybe b, but it's OK since they unify to Maybe a.
10:26:38 <MyCatVerbs> lispy: nah, I had my sense of humour surgically removed at birth. ^^
10:26:54 <atomb> MyCatVerbs: indeed. hence the difference.
10:27:06 <trofi> lilac: ok, i agree. i seem to misunderstand initial question
10:27:06 <atomb> well, part of the difference
10:27:09 <lispy> MyCatVerbs: oh I'm sorry to hear that
10:29:30 <MyCatVerbs> lispy: that's why I typed it instead, so it wouldn't upset you too much.
10:30:11 <MyCatVerbs> lispy: my plan will naturally backfire if you're using a screen reader, though. But hey, life would be boring if I didn't take any risks at all.
10:31:54 <lispy> MyCatVerbs: it's not that I'm upset, it's just that you're using a trademarked name.  I'm sorry but any code that uses the Lispylist must pay royalties.
10:33:21 <MyCatVerbs> lispy: oh right. Well, thank Curry for alpha equivalence. ^^
10:33:38 <trofi> @seen dons
10:33:39 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 12h 54m 53s ago.
10:35:30 <lispy> MyCatVerbs: heh
10:35:44 <trofi> can someone here explain me in two sentences how do hackage/plugins (aka hs-plugins) resolve runtime -package dependencies?
10:41:11 <Botje> magic.
10:41:20 <pgavin> that's only one sentence
10:41:31 <pgavin> actually, it's not even a sentence :)
10:41:37 <joed> It is a statement.
10:41:44 <pgavin> it's a noun
10:41:58 <pgavin> a sentence requires at minimum a subject and a verb :)
10:42:06 <joed> PFM?
10:42:08 <mc__> it is magic.
10:42:09 <sbahra> @tell Cale May lambdabot be made to join #not-##FreeBSD please?
10:42:10 <lambdabot> Consider it noted.
10:42:12 <lispy> This sentence no verb.
10:42:15 <pgavin> mc__: better :)
10:42:33 <trofi> sounds simple :]
10:43:02 <pgavin> trofi: I don't think hs-plugin's interface allows you to dynamically load arbitrary packages
10:43:45 <pgavin> trofi: I think the loaded package has to provide a specific function that returns the functions that are callable
10:43:51 <pgavin> trofi: or something like that
10:45:49 <trofi> plugin itself returns function. implementation of thus function (if plug in haskell) can use different haskell modules. Where is the machinery/policy for resolvind/fillind thoose depends?
10:46:38 <dmhouse> sbahra: you can use ?ask as well
10:46:39 <dmhouse> ?help ask
10:46:40 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
10:46:53 <trofi> desc: "Dynamic linking and runtime evaluation of Haskell, and C, including dependency chasing and package resolution."
10:47:16 <b\6> anything to help find unneeded imports?
10:47:22 <mauke> ghc -Wall
10:47:33 <b\6> thanks.
10:49:08 <sbahra> dmhouse, ok
11:06:55 <lispy> Although, I wish we had something to find unused exports
11:22:25 * chrisdone stamps on bubble wrap
11:24:16 <phlpp_> @src all
11:24:17 <lambdabot> all p =  and . map p
11:24:49 <lispy> The type error that you get for something like, foo :: forall p. MyTypeclass p => p -> Foo, is terribly misleading.  It gives a parse error on '=>' in GHC
11:24:58 <lispy> s/type error/syntax error
11:25:16 <dmhouse> What's wrong with it?
11:25:32 <lispy> You need to enable some extensions to use forall
11:25:51 <lispy> But instead it tells you that the '=>' is a parse error
11:25:59 <dmhouse> Oh, right.
11:26:20 <dmhouse> lispy: well forall is a valid name for a type variable otherwise. But I agree, it should detect that (who _really_ uses "forall" as a type variable?)
11:26:45 <dmhouse> I guess (.) is a valid infix type constructor too?
11:26:58 <lispy> no
11:27:12 <lispy> infix type constructors must start with : thankfully :)
11:27:24 <dmhouse> Isn't that infix data constructors?
11:27:41 <dmhouse> Just like prefix data constructors start with a capital.
11:27:52 <geezusfreeek> it's all constructors, at least i thought
11:28:06 <dmhouse> I'm pretty sure it's not.
11:28:22 <dmhouse> instance Arrow (~>) where ... is a classic example.
11:28:25 <Cale> gwern: hey, I got your e-mail! I'm going to try using mueval in lambdabot soon.
11:28:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:28:28 <lispy> Oh hrm
11:28:29 <geezusfreeek> oh, right
11:28:56 <gwern> Cale: I'm still working on some tweaks
11:28:56 <geezusfreeek> well that throws my entire reality into flux
11:29:08 <gwern> I've discovered some --loadfile problems, but I think I've gotten them licked
11:29:15 <Cale> Okay :)
11:29:18 <dmhouse> The reason for the colon/capital is that otherwise there'd be a conflict between "Foo" meaning a function or a constructor, and similarly "#" meaning an infix operator or an infix constructor.
11:29:19 <gwern> although @let still isn't working perfectly
11:29:24 <gwern> and I need to fix popen
11:29:28 <dmhouse> But there's no such conflict at the type level.
11:29:43 <geezusfreeek> agda seems to have no problem without restrictions like that
11:29:52 <gwern> Cale: ironically, smallcheck works perfectly - but the problem is, both failed and successful tests return the same first line - and you only see the first line in lambdabot!
11:30:02 <dmhouse> However "type a . b = a" seems to be rejected by GHC.
11:30:21 <gwern> lambdabot> let bar = 2
11:30:21 <gwern> Defined.
11:30:21 <gwern> lambdabot> run 1+1 "2"
11:30:21 <gwern> lambdabot> run bar+1 "3"
11:30:26 <gwern> :)
11:30:40 <dmhouse> Hmm, so does (~>), though. I wonder if there are extensions necessary.
11:30:45 <Cale> gwern: :)
11:31:16 <Cale> dmhouse: Infix type constructors must start with a colon.
11:31:28 <Cale> dmhouse: ~> is an infix type variable though
11:31:37 <dmhouse> Oh, of course.
11:31:46 * geezusfreeek 's world returns to normal
11:31:55 <lispy> ah, thanks Cale
11:32:02 <haskellian> wy does windows sometimes keep working and wokring after I have run a heavy computation even though the computation is long finished?
11:32:09 <lispy> Cale: hey, what does it take to get hoogle going again?
11:32:28 <geezusfreeek> haskellian: swapped out memory?
11:32:34 <Cale> lispy: I'm not sure...
11:32:57 <trofi> @src union
11:32:58 <lambdabot> union = unionBy (==)
11:33:12 <trofi> @type union
11:33:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:33:16 <trofi> @src unionBy
11:33:17 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
11:33:29 <Cale> Perhaps just installing the hoogle program will be enough...
11:33:37 <trofi> > union [1..5] [3..7]
11:33:39 <dmhouse> Seems like it'd be a good start.
11:33:39 <lambdabot>  [1,2,3,4,5,6,7]
11:34:28 <ski> `Prelude> :t (Control.Arrow.>>>) :: Control.Arrow.Arrow (.) => (a . b) -> (b . c) -> (a . c)' works fine here, using the `TypeOperators' language option
11:34:45 <Trinithis> @src (~>)
11:34:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:35:03 <trofi> Cale: http://rafb.net/p/lbV3ZV11.html - patch for hoogle-4 for lambdabot
11:35:05 <lambdabot> Title: Nopaste - stdin
11:35:21 <ankh47> which of the following would you recommend : process taking care of the shared variable, or a closure over an Mvar ?
11:35:32 <dmhouse> ski: that's a type variable again, surely.
11:35:37 <Trinithis> What is (~>) ?
11:35:38 <trofi> (hoogle shoud be installed)
11:35:47 <dmhouse> Trinithis: a type variable, just like 'a'.
11:35:59 <Trinithis> oh
11:36:02 <dmhouse> Trinithis: e.g. instance Show a, or instance Show (~>)
11:36:24 <Trinithis> Can you use things like (%^$%^)
11:36:27 <Trinithis> if you wanted
11:36:31 <geezusfreeek> ankh47: could you rephrase or clarify the question? i can't seem to parse it
11:36:32 <dmhouse> Sure.
11:36:47 <haskellian> what does swapped out memory mean?
11:36:57 <ski> dmhouse : yes
11:37:23 <dmhouse> haskellian: it's called the "page file" in Windows. Wikipedia for virtual memory.
11:37:25 <geezusfreeek> haskellian: it means your machine ran out of memory during the computation, so windows wrote some out to disk
11:37:48 <mauke> >  (%^$%^)
11:37:52 <lambdabot>   Not in scope: `%^$%^'
11:37:53 <geezusfreeek> tends to wreak havoc on performance, and might explain additional load after a computation is done
11:38:08 <dmhouse> But it's better than randomly killing processes to free up memory.
11:38:10 <ankh47> generally i want a cache that would (if "old") renew itself, abstracted behind a function call. should i take the erlang path of using a process to do this job, would closure over an MVar (for synchronization reasons) work, or is there a better way ?
11:38:48 <dmhouse> lispy: did you report the forall parse error thing? Otherwise I will.
11:39:21 <Cale> trofi: okay, that's applied... building :)
11:39:54 <trofi> Cale: you need hoogle installed in your system :]
11:39:59 <Trinithis> Does using non-alphabetic type variable like (~>) allow some special notation such as an infix appearance?
11:39:59 <Cale> trofi: I've almost forgotten how to use diff/patch due to overuse of darcs :)
11:40:16 <trofi> patch -p1 < a.patch
11:40:19 <Cale> right
11:40:25 <mauke> --dry-run
11:40:37 <Cale> Trinithis: yes
11:40:41 <dmhouse> Trinithis: yes, exactly that.
11:40:48 <geezusfreeek> ankh47: i would probably try an MVar, if i understand the problem correctly
11:40:52 <Trinithis> Do you guys have any examples I can look at?
11:41:11 <trofi> +,-,*,/ :]
11:41:14 <trofi> > 1+2
11:41:24 <Cale> (>>>) :: (Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c)
11:41:43 <Twey> Hee.
11:41:57 <Twey> Nice.
11:42:03 <Twey> Type operators.
11:42:05 <gwern> Cale: also note that hoogle changed options for 4
11:42:14 <gwern> that may be part of the problem
11:42:25 <Trinithis> Awesome. Beats using a for arrow. I remember when I was learning arrows, the a confused me because a is usually a generic type var
11:42:25 <ski> (Twey : note that `(->)' is also a type operator ..)
11:42:31 <Twey> Well, yes
11:42:36 <Twey> But *other* type operators :)
11:42:54 <dmhouse> Inifx type variables, in fact.
11:43:17 <lispy> dmhouse: if you're volunteering, then go head!
11:43:20 <trofi>  `binary`
11:43:28 <lispy> dmhouse: I'd rather work on other things and just make a mental note
11:43:29 <chrisdone> ((~>) a b)
11:43:51 <mmorrow> just like   [] , (), (,), (,,), ...    are both tycons *and* datacons
11:44:09 <dmhouse> trofi: not necessarily binary.
11:44:28 <trofi> ?
11:44:37 <trofi> ternary would work too?
11:44:52 <dmhouse> > let (!) = (+1) in (!) 2
11:44:58 <dmhouse> Similar to that at the type level.
11:45:02 <trofi> seems dead
11:45:18 <mmorrow> @type ()
11:45:20 <dmhouse> Prelude> let (!) = (+1) in (!) 2
11:45:20 <dmhouse> 3
11:45:54 <mmorrow> nobot?
11:46:20 <dmhouse> Prelude> let showList :: Show (#) => [(#)] -> String; showList = show in showList [1]
11:46:20 <dmhouse> "[1]"
11:46:30 <chrisdone> haha, old school, dmhouse
11:46:40 <chrisdone> pasting ghci outputs
11:46:43 <Cale> I can imagine something might have gone wrong since I'm recompiling it...
11:46:55 <chrisdone> before the luxury of λbot
11:47:30 <mmorrow> Cale: ah
11:47:32 <Cale> Huh... it fails to link now...
11:47:41 <Cale> Linking dist/build/lambdabot/lambdabot ...
11:47:41 <Cale> cabal: Error: some packages failed to install:
11:47:41 <Cale> lambdabot-4.1 failed during the building phase. The exception was:
11:47:41 <Cale> exit: ExitFailure 9
11:47:49 <tibbe> @seen dcouts
11:47:55 <tibbe> @seen dcoutts
11:48:07 <dmhouse> tibbe: lambdabot's temporarily gone.
11:48:18 <trofi> Cale: kill the process
11:48:23 <mauke> preflex: seen dcoutts
11:48:23 <preflex>  dcoutts was last seen on #haskell 6 hours, 42 minutes and 9 seconds ago, saying: cjs: or if you depend on that instance just upgrade bytestring, it's not hard
11:48:24 <chrisdone> it's like having no internet, suddenly the world stops :P
11:48:31 <Cale> mmm... yeah, that could do it :)
11:48:47 <trofi> Cale: UNIces dislike writing into ran binaries (ETEXT)
11:49:03 <ankh47> geezusfreak: do i get it right that mvar will be kind of a "pointer", ie i wont have to generate a new closure for each change of the contents of mvar ..
11:49:04 <Cale> Really? I've never had any trouble with that.
11:49:20 <dmhouse> Tertiary operators work too, you just have to add in parentheses.
11:49:20 <trofi> tried override ran files in mc ?
11:49:26 <gwern> Cale: I've pushed some more stuff
11:49:36 <dmhouse> Prelude> let (True ?: x) _ = x; (_ ?: _) y = y in (not True ?: 't') 'f'
11:49:36 <dmhouse> 'f'
11:49:40 <gwern> you need darcs/most recent hackage mueval
11:49:52 <geezusfreeek> ankh47: it's like an IORef with a mutex
11:49:59 <gwern> among other things
11:50:08 <trofi> it's avoidable via delete + create, but open seems to cause problems
11:50:29 <gwern> man, lambdabot is going to be a good example of why cabal-install is so useful
11:50:43 <gwern>     Build-depends:       containers, directory, pretty, parsec, old-time, random, array, network,
11:50:44 <trofi> lambdabot doesn't work with it
11:50:49 <gwern>                          regex-compat, readline, binary>0.2, haskell-src, oeis, lambdabot-utils, show>=0.3, utf8-string,
11:50:52 <geezusfreeek> ankh47: so, correct, existing closures will access its updated state, not old states
11:50:52 <gwern>                          -- runtime dependencies; Hoogle is omitted since it doesn't export a library for Cabal...
11:50:56 <gwern>                          brainfuck, unlambda, mueval>=0.6.1
11:51:04 <trofi> (with --user i mean)
11:51:05 <dmhouse> Hoogle does now.
11:51:24 <gwern> 19 dependencies isn't the most I've ever seen, but it's definitely up there :)
11:51:45 <dmhouse> (20 with Hoogle.)
11:51:47 <thoughtpolice> lambdabot will once again be put on hackage instead of always having to use the darcs repo?!
11:52:06 <gwern> thoughtpolice: we're getting there. the problem is the mutable files
11:52:13 <Trinithis> Does cabal-install find and install all the dependencies for you?
11:52:17 <gwern> where do we stick State/L.hs, for example?
11:52:26 <gwern> Trinithis: yes, if all the deps are on hackage
11:52:34 <trofi> just copy it in ~/var/State/
11:52:34 <gwern> ie, it can't handle gtk2hs for you
11:52:35 <Deewiant> Trinithis: if it can find them, yes. ;-)
11:52:42 <Trinithis> O.o
11:52:50 <trofi> and add workDir in lambdabot
11:52:54 <gwern> Trinithis: I'm leaning towards a ~/.lambdabot myself
11:53:20 <gwern> Cale: thoughts about how to make lambdabot not need to run in the darcs dir?
11:53:46 <trofi> LB needs L.hs and imports.h (they are easy to copy ;])
11:53:56 <Cale> I haven't really given much thought to that.
11:54:21 <gwern> well, it's a nice feature to have
11:55:25 <ankh47> geezusfreak: thx, one step closer towards the grand finale ;-)) think haskellers would be interested in story about haskell app distributed over 120 servers ?
11:56:09 <dcoutts> gwern: it needs to use Cabal's Paths_lambdabot module to find the data files, then it'll work
11:56:18 <Saul> I have code that uses associated types, but it appears I've run into the broken parts of GHC 6.8.2 on this matter. Should I upgrade ghc (and to which version) or rewrite to multiparam/fundeps?
11:56:21 <gwern> dcoutts: yes, that'll fit in somehow
11:56:27 <gwern> probably for the readonly copies
11:56:51 <trofi> if missing(L.hs) copy_from(share/L.hs)
11:57:02 <mmorrow> ankh47: i for one would cover my ears and repeat "i cant hear you i can't hear you" until you're ;)
11:57:02 <gwern> ie, we isntall Pristine.hs to /, get its path using Paths_lambdaot, and cp /Pristine.hs ~/.lambdabot/L.hs
11:57:04 <dcoutts> gwern: right, and then ~/.lambdabot/ for r/w
11:57:20 <mmorrow> ankh47: (.. done)
11:57:34 <gwern> Trinithis: well, specifically it's Pristine.hs which is copied to L.hs; you rm L.hs if you want to scrap the @let state
11:57:35 <mmorrow> ankh47: i'd love to hear about that!
11:58:08 <Trinithis> gwern: Are you talking about lambdabot?
11:58:15 <gwern> Trinithis: yes
11:58:25 <gwern> oh, I must've meant trofi
11:59:10 <mmorrow> Saul: you should probably use 6.9 w/ type families and such
11:59:30 <Saul> mmorrow: Is that completely stable?
12:00:11 <dmhouse> lispy: http://hackage.haskell.org/trac/ghc/ticket/2523, feel free to cc yourself
12:00:57 <mmorrow> Saul: heh. that may be a "yes" or a "no" depending of what for/what stability guarantees you require
12:01:09 <mmorrow> s/of what for/on what for/
12:01:39 <mmorrow> 6.10 is due in sept afaik
12:02:10 <Saul> mmorrow: As in everything works as well as in ghc 6.8.2 and the type families are working properly
12:02:53 <ankh47> mmorow: where are announcements of such "success stories" ussualy posted ? (just an internal web presence system, 3rd rewrite in my current lang no1. ;-)
12:03:20 <mmorrow> Saul: well, type families are "broken" in 6.8
12:03:34 <Saul> There's no point in switching if other things start breaking
12:03:46 <gwern> ankh47: -cafe is worthwhile
12:04:40 <mmorrow> Saul: i've been using 6.9 primarily for a while now. it may require some minor hacks here and there to get hackage pkgs working, but it's not that bad
12:05:06 <mmorrow> Saul: but i can't say for sure if something will break or not
12:05:21 <mmorrow> Saul: without knowing what that something is
12:05:30 <mmorrow> ankh47: what gwern said
12:06:00 <Saul> mmorrow: Ok thanks, I guess I'll ponder on it a little bit (especially if 6.10 is about a month away)
12:06:09 <mmorrow> Saul: :)
12:07:55 <ankh47> thx to all, if it's going well, i'll try to post something, if not, you'll probably come whining again ;-)
12:08:21 <ankh47> wow, 6.10 is comming ? what one doesn't lear here ;-)))
12:08:48 <ankh47> i'll probably come whining. ...
12:12:25 <trofi> is there `words' analogue with arbitrary predecate instead of hardcoded isSpace?
12:13:44 <Twey> You know, trofi, I was just wondering that yesterday
12:13:57 <trofi> and you found it? :]
12:14:00 <mauke> @bot
12:14:05 <lambdabot> :)
12:14:11 <trofi> @hoogle IO a -> a
12:14:12 <gwern> trofi: ah, the old split debate
12:14:19 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:14:21 <dmhouse> Yayness.
12:14:25 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
12:14:31 <lambdabot> Plugin `hoogle' failed with: thread killed
12:14:44 <gwern> trofi: short answer, no. there are multiple reasonable split implementations and none of them have succeeded in getting into the std libaries
12:14:48 <mauke> > groupBy ((==) `on` isSpace) "what  is this"
12:14:55 <lambdabot>  mueval: user error (unrecognized option `-l'
12:14:57 * gwern has tried. I haven't given up, but I've taken a break
12:15:00 <mauke> nooooo
12:15:03 <mauke> > 42
12:15:03 <lambdabot> Usage: mueval [OPTION...] --exp...
12:15:09 <lambdabot>  mueval: user error (unrecognized option `-l'
12:15:09 <Cale> hmm
12:15:15 <lambdabot> Usage: mueval [OPTION...] --exp...
12:15:22 <trofi> gwern: does mueval plug supports in lb @let ? :]
12:15:26 <gwern> Cale: did you upgrade completely? things are in flux
12:15:38 <gwern> trofi: darcs everything should
12:15:41 <gwern> it Works Here
12:15:43 <Cale> gwern: I'll see if there are more patches I missed. Also, there were lots of conflicts.
12:15:55 <gwern> hm. not surprising
12:16:02 <gwern> I guess you didn't push local stuff?
12:17:46 <gwern> if you didn't, that's hardly my fault - I was careful to be constantly pulling from the code.ho repo to minimize conflicts as much as possible
12:17:48 <Cale> Mm... well there were some minor things regarding hoogle and removing the Log module.
12:18:33 <trofi> btw, if you use hoogle4 - you can remode State/hoogle.txt
12:18:53 <gwern> yes, I did
12:19:31 <dcoutts> stepcut: ping
12:19:37 <gwern> uh oh. something's broken. eval's no longer working
12:19:37 <stepcut> pong
12:19:38 <gwern> hm
12:20:08 <trofi> gwern: LB's inventory is big (for my sloooow chan) i'd be glad seeing checkpoint there (if it wouldn't break you development workflow)
12:20:27 <dcoutts> stepcut: you were talking about your cabal->debian tools
12:20:30 <gwern> trofi: I'm not actually sure how to checkpoint on the server
12:20:36 <stepcut> dcoutts: yes
12:20:52 <dcoutts> stepcut: this came up on haskell-cafe and I wondered if you could post an explanation
12:21:38 <trofi> isn't checkpoint a usual commit?
12:21:51 <trofi> emmm.. patch
12:21:58 <gwern> no, it's part of tagging
12:22:03 <gwern> an option
12:22:20 <gwern> I know how to do it locally, but I am unsure whether pushing a local tag which used --checkpoint causes the server to be checkpointed
12:22:42 <SamB_XP> gwern: I don't think it does
12:22:53 <SamB_XP> gwern: I think you have to repeat that bit on the server
12:22:55 <trofi> the best way is to train on local repo
12:23:14 <gwern> would not surprise me
12:23:19 <Cale> gr...
12:23:21 <Cale> darcs push cgibbard@code.haskell.org:/srv/code/lambdabot
12:23:34 <Cale> oh
12:23:40 <Cale> heh, I'm silly
12:23:59 <Cale> That asks for a password, and I was confused, but I just realised it's because my private key isn't on this machine
12:24:05 <stepcut> dcoutts: which thread ?
12:24:24 <gwern> wav one
12:24:32 <gwern> dons was boasting about the arch packages
12:24:38 <dcoutts> stepcut: "ANN: wavconvert 0.1.1", specifically Ketil's message
12:24:52 <gwern> shoot shoot shoot, why did mueval's loadfile functionality stop working...
12:24:59 <dons> gwern: kicking the pants of the debian guys.
12:25:03 <dons> since they're packages are more important
12:25:25 <dons> dcoutts: i think the next hackathon should be a porting fest.
12:25:28 <gwern> dons: I'd be happy if the base packages were better. like, profiled GHC would be very very nice for me
12:25:39 <Cale> There, I pushed some small updates.
12:25:43 <dcoutts> dons: porting what?
12:25:47 <dons> dcoutts: to distros
12:25:56 <dcoutts> dons: ah, native packaging
12:26:03 <dons> getting tools like cabal2arch working everywhere, and teams set up to get the platform sorted.
12:26:10 <dcoutts> aye
12:26:38 <dcoutts> dons: and corresponding central QA in hackage
12:26:40 <dons> yep
12:26:54 <mmorrow> <trofi> can someone here explain me in two sentences how do hackage/plugins (aka hs-plugins) resolve runtime -package dependencies?
12:27:08 <dons> by reading the package.conf file
12:27:12 <dons> and the .hi files
12:27:19 <trofi> how to supply more .conf's?
12:27:30 <trofi> (i have many ~/.cabal/ packages)
12:27:50 <trofi> have to hack hs-plugs-darcs/Plugins/Env.hs?
12:29:54 <gwern> hm. according to tests.sh, module and file loading are *not* broken
12:30:00 <gwern> so it must be something to do with lambdabot
12:30:00 <mmorrow> heh, what luck that i pasted that when i did ... trofi: i was just gonna link you to http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-5.html#node_sec_9
12:30:34 <Twey> I'm told that hs-plugins is deprecated...
12:30:42 <mmorrow> trofi: but the .hi parser no longer is part of the working plugins since the format changed 6.6-6.8
12:30:56 <stepcut> what do you use instead of hsplugins ?
12:31:03 <mmorrow> and it uses the GHC-API
12:31:06 <Twey> GHC as a library, I think
12:31:09 <Twey> Huh
12:31:18 <Twey> So not deprecated?
12:31:43 <mmorrow> i dunno if it's deprecated or not, but i've been using it with 6.9 for a while now :)
12:32:05 <thoughtpolice> hs-plugins was really fragile due to the .hi parser actually being built into it
12:32:09 <thoughtpolice> and .hi's change rapidly
12:32:20 <thoughtpolice> now that it's based on the ghc-api it's more resilliant to new releases
12:32:29 <gwern> ah, perhaps it's the CPP flag
12:32:50 <mmorrow> but there's the *huge* tradeoff that with the ghc-api, the binaries produced are monsters
12:32:56 <thoughtpolice> yeah
12:33:01 <thoughtpolice> there's tons of dead code in there too
12:33:07 <thoughtpolice> so a simple binary will come out to ~20mb
12:33:14 <thoughtpolice> link time can also be a bit of a pain
12:33:25 <pgavin> dcoutts: do you have a minute?
12:33:26 <gwern> Cale: did you do something with State/fact?
12:33:31 <gwern> it's empty
12:33:42 <Cale> empty?
12:33:45 <dcoutts> pgavin: yeah
12:33:52 <thoughtpolice> hopefully hs-plugins will become deprecated though if the new GHC API changes can effectively superscede it
12:33:53 <Cale> huh
12:33:57 <Cale> I wonder what happened.
12:34:03 <trofi> it would be easier to get depends from ghc dump (ghc -v --make | collect)
12:34:04 <Cale> It seems to randomly disappear sometimes.
12:34:12 <gwern> yeah, 'cat State/fact | gunzip' does nothing
12:34:27 <Cale> right
12:34:30 <Cale> It's 0 bytes
12:34:35 <Cale> hmm
12:34:36 <gwern> and it seems the patch you just pushed does a bianry modification
12:34:43 <gwern> dons: this, incidnetally, is one reason gzipped darcs-controlled state is evil - you can't interpret the diffs anymore
12:35:01 <Cale> Ah, yeah. I figured there must have been something new.
12:35:12 <Cale> But really the new thing was that it's empty.
12:35:49 <dons> gwern: gzipped binary is the awesome.
12:36:10 <gwern> I see no awesomeness here!
12:36:11 <mauke> what's the point?
12:36:14 <hackage> Uploaded to hackage: list-extras 0.2.2
12:36:14 <hackage> Uploaded to hackage: lambdabot-utils 4.1
12:36:14 <hackage> Uploaded to hackage: mueval 0.6.1
12:36:21 <Cale> ugh, after unrecording, fact is 20 bytes.
12:36:25 <dons> fast serialisation, was the point.
12:36:25 <SamB_XP> a briany modification?
12:36:33 <dons> you can suck in huge state files quickly.
12:36:38 <dons> and lazily decompress them
12:36:46 <dons> so smaller heap footprint, faster startups.
12:37:01 <dons> anyway, is there some goal to improve *stability* of the bot?
12:37:06 <mauke> or you could decouple the bot and the storage manager
12:37:59 <gwern> Cale: ok, I pushed a patch which seems to fix the mueval problem
12:38:21 <Cale> dons: Well, the problem is that if something goes wrong with the state, like it gets destroyed entirely, it's easy to unwittingly push a patch which records that.
12:39:18 <dons> yeah
12:39:25 <dons> git backend!
12:39:36 <Cale> huh? How would that help?
12:39:36 <trofi> :]
12:39:47 <gwern> I'd rather not; from a PR perspective that's bad
12:39:53 <gwern> Cale: http://hpaste.org/9786
12:39:55 <Saizan> are we sure that lambdabot's state belongs in the developent repository?
12:40:14 <SamB_XP> I think dons was suggesting lambdabot's state be stored in git format ;-P
12:40:24 <gwern> it doesn't really, but it's useful
12:40:40 <gwern> hm, I oughter do a mueval ANN
12:40:52 <dons> gwern: we play well with others.
12:40:59 <dons> there's no harm using good tools if they exist.
12:41:11 <gwern> I don't really see why git
12:41:14 <dons> anyway, i don't think picking at the edges is going to help lambdabot
12:41:30 <gwern> it'd be better to pursue stepcut's multimaster bot
12:41:35 <gwern> if we want distributed gunk
12:41:35 <dons> gwern: well, persistant storage + diffs is distributed rcs in the limit
12:41:46 <olsner> I like the fact that a clean checkout of darcs lambdabot gets a nice set of quotes and stuff from the get-go
12:42:04 <dons> Cale, are you the project lead for lambdabot now?
12:42:16 <olsner> (but otoh, that lambdabot state will always be out-of-date with the ever changing state of #haskell)
12:42:17 <dons> is there some direction being set about things that need to be fixed?
12:42:31 <Cale> dons: Sort of? I'm the person who is running it, so I accept patches and build it.
12:42:43 <dons> but there's no overal direction?
12:43:02 <SamB_XP> was there before?
12:43:05 * trofi 'd like lambdabot+xmpp
12:43:10 <dons> there has been at times, yes, SamB_XP.
12:43:13 <Cale> The overall direction is determined by what patches people give me.
12:43:14 <gwern> olsner: well, quotes don't get added that often. as long as Cale @flushes periodically and records and pushes, it works pretty well
12:43:31 * stepcut wrote (one version of) lambdabot+xmpp
12:43:40 <dons> stability is the key problem, but no one's working on that from what I can see. i suspect it needs rearchitecting
12:43:54 <olsner> gwern: I guess it does
12:44:14 <trofi> lb coud dump it's state once in 10 minutes
12:45:01 <olsner> hmm, it would be nice if someone fixed up the lambdabot build stuff to e.g. not require a special ./build step
12:45:34 <gwern> ./build?
12:45:37 <gwern> what does that do?
12:45:51 <olsner> build lambdabot?
12:46:36 <gwern> oh. I just install through cabal
12:47:08 <gwern> good ol' configurenop && build && hinstall && lambdabot
12:47:23 <haskellian> can i turn off the sound of the client?
12:47:39 <dons> yeah, seperate package deps seem reasonable now.
12:47:50 <olsner> iirc the documentation suggests that the recommended way to build lambdabot is to modify and use ./build
12:47:52 <dons> that would be one goal: make it entirely 'cabal isntall'-able
12:48:08 <Cale> It almost doesn't require ./build
12:48:12 <SamB_XP> cabal isntall?
12:48:23 <Botje> cabal isntall _YET_
12:48:23 <gwern> olsner: does it? eh
12:48:26 <SamB_XP> you mean ... there is more to life than cabal?
12:48:30 <Botje> thank you. i'll be here all week.
12:48:45 <SamB_XP> Botje: I was already making that dumb joke
12:48:47 <dons> who's time are you wasting, Sam?
12:48:52 <gwern> SamB_XP: if there is, I don't want to know about it!
12:49:00 <Botje> i was first with the dumb joke!
12:49:23 <SamB_XP> dons: that of people with insufficient senses of humour
12:49:31 <olsner> gwern: http://code.haskell.org/lambdabot/README
12:49:52 <mc__> Is it possibly to say that either lazy or strict IO is generally faster?
12:50:03 <SamB_XP> mc__: nope
12:50:45 <trofi> like lazy eval vs. strict eval
12:50:50 <mmorrow> mc__: faster at what?
12:50:51 <trofi> > 1+2
12:50:57 <lambdabot>  mueval: user error (unrecognized option `-l'
12:51:03 <lambdabot> Usage: mueval [OPTION...] --exp...
12:51:08 <trofi> > "asdf"
12:51:10 <olsner> heh, "user error"
12:51:13 <lambdabot>  mueval: user error (unrecognized option `-l'
12:51:14 <mc__> mmorrow: at reading/writing?
12:51:19 <lambdabot> Usage: mueval [OPTION...] --exp...
12:51:32 <Twey> Someone broke lambdabot!
12:51:48 <trofi> @let a = 1
12:51:54 <mmorrow> mc_: i guess i meant, "depends on the situation"
12:51:57 <lambdabot> Defined.
12:52:04 <trofi> @let a = 1
12:52:11 <lambdabot> <local>:2:0:     Multiple declarations of `L.a'     Declared at: <local>:1:0 ...
12:52:15 <Twey> > a
12:52:17 <mc__> mmorrow: alright, I was just curios
12:52:21 <lambdabot> Terminated
12:52:22 <gwern> @undefine a
12:52:27 <mmorrow> mc__: :)
12:52:27 <Twey> Terminated?!
12:52:27 <lambdabot> Undefined.
12:52:31 <trofi> it's vey slow
12:52:32 <Twey> Terminated?!!!
12:52:38 <mauke> > ()
12:52:44 <Twey> I was only asking for the number 1!
12:52:45 <lambdabot> Terminated
12:52:49 <Twey> Riiiight
12:52:54 <Twey> lambdabot is FUBAR
12:53:03 <Twey> :(
12:53:08 <Twey> Revert!  Revert!
12:53:18 <Deewiant> ?ty (+)
12:53:21 <lambdabot> forall a. (Num a) => a -> a -> a
12:53:28 <olsner> ?ty (++)
12:53:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:53:32 <Deewiant> hey, at least that works
12:53:35 <opqdonut> > (++)
12:53:35 <lambdabot> Terminated
12:53:39 <opqdonut> that doesn't ^_^
12:53:42 <olsner> and it's using the correct prelude :)
12:53:45 <Deewiant> irrelevant ;-P
12:53:53 <Deewiant> all you need is types anyway
12:53:57 <Deewiant> the code is secondary
12:53:59 <olsner> yeah, you can still code in the type system
12:54:03 <Twey> Hahaha
12:54:16 <Twey> We just have to pass all queries through Oleg
12:54:42 <olsner> we should have a haskell-to-types translator, we could call it @oleg
12:54:49 * Twey laughs.
12:55:36 <Twey> It's a personperson.
12:56:12 <mmorrow> but types are untyped
12:56:44 <olsner> ... oleg would have to move on to coding in the kind system
12:56:55 <mmorrow> 4 kinds! yay!
12:57:23 <mmorrow> (only two of which the programmer can create)
12:57:35 <mmorrow> ((or something))
12:57:48 <Saizan> with closed type families we get more kinds! (afaiu)
12:58:26 <mmorrow> oooh, that sounds nice
12:59:08 <mmorrow> Saizan: whats the status/story/? with such beasts?
12:59:16 <dmhouse> Things like record kinds, intersection kinds etc. have been studied.
12:59:28 <olsner> doesn't one of the corners of the lambda cube unify kinds and types?
12:59:49 <dmhouse> And types-of-kinds, etc.. But in practice you don't need more than three layers.
13:00:33 <gwern> alright you wankers I've updated the lambdabot README
13:00:38 <dons> heh
13:00:47 <dons> go gwern!
13:01:02 <mmorrow> dmhouse: it seems to me that everything else would be equivalent (in terms of "expressiveness" or something)
13:01:13 <atomb> olsner: one of the corners unifies types and terms, too
13:01:18 <atomb> and kinds
13:01:22 <Cale> > 1 + 1
13:01:22 <lambdabot>  "2"
13:01:27 <Twey> Er
13:01:27 <olsner> normally I wouldn't, but lambdabot is one of those programs I've failed to build enough times to actually read and follow the readme from the start :)
13:01:28 <Twey> String?
13:01:29 <Cale> hooray... to some extent
13:01:32 <gwern> @let foo = 1
13:01:33 <lambdabot> Defined.
13:01:35 <gwern> > foo + 1
13:01:37 <lambdabot>  "2"
13:01:37 <Cale> yeah, that's still a problem
13:01:44 <gwern> @check \x -> x==x
13:01:45 <lambdabot>  "\"OK, passed 500 tests.\\n\""
13:01:52 <gwern> @scheck True
13:01:52 <mmorrow> heh
13:01:53 <lambdabot>  "\"OK, passed 500 tests.\\n\""
13:01:56 <olsner> mueval outputs strings that lambdabot shows?
13:02:02 <Cale> The problem was that on my account, there was already a mueval which was slightly older in my path.
13:02:07 <gwern> hm. that's not quite right
13:02:17 <gwern> scheck should've been "()"
13:02:23 <Cale> gwern: Don't have it return a quoted string! :)
13:02:38 <trofi> > 1
13:02:39 <lambdabot>  "1"
13:02:41 <Cale> It's really okay for unix programs to output plain data :)
13:02:41 <trofi> > "1"
13:02:42 <lambdabot>  "\"1\""
13:02:50 <mauke> > fix error
13:02:55 <lambdabot>  mueval: Expression did not compile.
13:02:55 <lambdabot> mueval: Time limit exceeded
13:02:59 <mmorrow> heh
13:03:07 <mmorrow> > fix show
13:03:11 <gwern> is fix error supposed to work?
13:03:12 <lambdabot>  mueval: Expression did not compile.
13:03:12 <lambdabot> mueval: Time limit exceeded
13:03:19 <olsner> > fix (1:)
13:03:21 <BMeph> FunctorSalad: Heh-heh. :)
13:03:23 <trofi> worked last time
13:03:24 <lambdabot>  mueval: Expression did not compile.
13:03:24 <lambdabot> mueval: Time limit exceeded
13:03:29 <olsner> @ty fix
13:03:30 <lambdabot> forall a. (a -> a) -> a
13:03:33 <olsner> > fix
13:03:38 <gwern> ah, perhaps fix simply isn't in scope
13:03:38 <lambdabot>  mueval: Expression did not compile.
13:03:38 <lambdabot> mueval: Time limit exceeded
13:03:42 <gwern> @hoogle fix
13:03:42 <lambdabot> Data.Function fix :: (a -> a) -> a
13:03:42 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:03:42 <lambdabot> Data.Fixed data Fixed a
13:03:45 <mauke> > waffles
13:03:49 <mmorrow> haha
13:03:50 <lambdabot>  mueval: Expression did not compile.
13:03:50 <lambdabot> mueval: Time limit exceeded
13:03:53 <gwern> no, it wouldn't be
13:03:53 <Twey> Heh
13:03:55 <mauke> error messages suck
13:03:58 <Twey> Mmm waffles
13:04:05 <mmorrow> > let fix f = let x = f x in x in fix show
13:04:06 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:04:14 <Cale> > let fix f = let x = f x in x in fix error
13:04:17 * BMeph mutters about mis-timed history keypresses
13:04:19 <lambdabot>  "\"
13:04:25 <Cale> heh...
13:04:44 <mmorrow> > show []
13:04:52 <sjanssen> @botsnack
13:04:52 <lambdabot>  mueval: Expression did not compile.
13:04:52 <lambdabot> mueval: Time limit exceeded
13:04:55 <lambdabot> :)
13:05:01 <mmorrow> > show ""
13:05:02 <lambdabot>  "\"\\\"\\\"\""
13:05:12 <gwern> wow
13:05:20 <Cale> Why did show [] not compile? No defaulting?
13:05:24 <leoncamel> is there any genetic algorithms package in haskell ?
13:05:25 <mar77a> > show . show . show ""
13:05:30 <lambdabot>  mueval: Expression did not compile.
13:05:30 <lambdabot> mueval: Time limit exceeded
13:05:40 <mar77a> > (show . show . show) ""
13:05:45 <sjanssen> gwern: is it possible to expand on "Expression did not compile."?
13:05:45 <lambdabot>  mueval: Expression did not compile.
13:05:45 <lambdabot> mueval: Time limit exceeded
13:05:46 <Cale> leoncamel: Have you checked on hackage?
13:05:54 <mmorrow> > let fix f = let x = f x in x in foldr (.) id (repeat read) $ fix show
13:05:58 <sjanssen> and why is Time limit exceeded always returned?
13:06:00 <lambdabot>  mueval: Expression did not compile.
13:06:00 <lambdabot> mueval: Time limit exceeded
13:06:03 <mauke> > (id . id) ()
13:06:04 <dmhouse> What was wrong with the old @eval?
13:06:08 <lambdabot>  mueval: Expression did not compile.
13:06:08 <lambdabot> mueval: Time limit exceeded
13:06:14 <mauke> dmhouse: @eval is a no-op :-)
13:06:15 <mmorrow> > let fix f = let x = f x in x in foldr (.) id (repeat (read::String->String)) $ fix show
13:06:20 <lambdabot>  mueval: Expression did not compile.
13:06:20 <lambdabot> mueval: Time limit exceeded
13:06:22 <dmhouse> Oh, whatever it's called.
13:06:29 <mmorrow> > let fix f = let x = f x in x in foldr (.) id (repeat (read::String->String)) $ fix (show::String->String)
13:06:30 <mauke> @run
13:06:31 <sjanssen> > (id . id) ()
13:06:35 <lambdabot>  mueval: Expression did not compile.
13:06:35 <lambdabot> mueval: Time limit exceeded
13:06:35 <lambdabot>  mueval: Expression did not compile.
13:06:35 <lambdabot> mueval: Time limit exceeded
13:06:36 <lambdabot>  mueval: Expression did not compile.
13:06:37 <lambdabot> mueval: Time limit exceeded
13:06:37 <gwern> sjanssen: not easily; I don't think hint provides type errors as strings
13:06:41 <gwern> but I could look
13:07:05 <sjanssen> gwern: what's the deal with all these valid expressions failing?
13:07:07 <mmorrow> > let fix f = let x = f x in x in (foldr (.) id (repeat (read::String->String)) $ fix (show::String->String)) :: String
13:07:12 <lambdabot>  mueval: Expression did not compile.
13:07:12 <lambdabot> mueval: Time limit exceeded
13:07:16 <dmhouse> > ()
13:07:17 <lambdabot>  "()"
13:07:23 <gwern> sjanssen: I haven't finished debugging mueval?
13:07:25 <mauke> > id ()
13:07:26 <lambdabot>  "()"
13:07:28 <mauke> I blame (.)
13:07:34 <mmorrow> ahh
13:07:36 <olsner> @ty (.)
13:07:37 <gwern> many of these are expressions that did not occur to me to test
13:07:37 <dmhouse> > (+1) . (*2) $ 10
13:07:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:07:44 <lambdabot>  mueval: Expression did not compile.
13:07:44 <lambdabot> mueval: Time limit exceeded
13:07:47 <dmhouse> Yeah, (.) seems off.
13:07:58 <dmhouse> > (+1) $ (*2) $ 10
13:07:59 <lambdabot>  "21"
13:08:01 <gwern> gwern@craft:17669~>mueval -e '(+1) . (*2) $ 10'                                                                       [ 4:08PM]
13:08:03 <gwern> "21"
13:08:10 <Cale> :t foldr (.) id
13:08:11 <lambdabot> forall a. [a -> a] -> a -> a
13:08:12 <gwern> so it's Cale's fault!
13:08:19 <trofi> :]
13:08:21 <mmorrow> > let fix f = let x = f x in x in foldr ((.)::(a->b)->(b->c)->(a->c)) id (repeat read) $ fix show
13:08:25 * dmhouse stares accusingly
13:08:27 <lambdabot>  mueval: Expression did not compile.
13:08:27 <lambdabot> mueval: Time limit exceeded
13:08:30 <Cale> > (+1) . (*2) $ 10
13:08:33 * gwern shakes fist
13:08:36 <lambdabot>  mueval: Expression did not compile.
13:08:36 <lambdabot> mueval: Time limit exceeded
13:08:49 <gwern> Cale: (.) is redefined in L.hs
13:08:49 <Cale> That should work. It used to work with @run
13:08:50 <olsner> so, mueval has some kind of trouble with functors?
13:08:53 <gwern> and L.hs is loaded by default
13:08:54 <Cale> gwern: I know that.
13:09:11 <dmhouse> > (Prelude..) (+1) (*2) 10
13:09:12 <lambdabot>  "21"
13:09:17 <sjanssen> gwern: do you also use the special Prelude import?
13:09:24 <gwern> Prelude.. works?
13:09:30 <Cale> Is there some kind of problem with polymorphism?
13:09:30 <dmhouse> Sure :)
13:09:35 <sjanssen> gwern: overlapping definitions
13:09:36 <gwern> sjanssen: special prelude? unlikely, mueval imports the default Prelude
13:09:54 <Cale> oh!
13:09:59 <dmhouse> > (+1) `Prelude..` (*2) $ 10
13:09:59 <sjanssen> both Prelude and L bring in the same identifier
13:09:59 <lambdabot>  Parse error at "Prelu..." (column 7)
13:10:03 <mmorrow> Cale: that seems to be it
13:10:08 <Cale> > (+1) L.. (*2) $ 10
13:10:09 <lambdabot>  "21"
13:10:10 * sjanssen votes to remove the Caleskell operators
13:10:12 <Cale> aha
13:10:20 <sjanssen> and also, can we get rid of these quotes?
13:10:26 <mar77a> @quote
13:10:26 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
13:10:34 <Cale> L.hs imports the Prelude qualified
13:10:36 * dmhouse votes for putStrLn rather than print
13:10:45 <mmorrow> yes!
13:10:51 <mmorrow> then we can have unicode
13:10:52 <trofi> me too
13:10:58 <Cale> and then imports it hiding (.) and such
13:11:05 * olsner votes to keep the polymorphic versions :) they're a nice spice to coding with lambdabot
13:11:10 <Cale> You don't need to separately import the prelude.
13:11:19 <Cale> Just take whatever's in scope from L.hs
13:11:28 <trofi> not just unicode, but "\nPRIVMSG #foobar :hellothere\n"
13:11:41 <gwern> we do have unicode
13:11:48 <Heffalump> is there a vote on? :-)
13:11:49 <mauke> > ä
13:11:53 <gwern> > let (ñ) = (+) in ñ 5 5
13:11:54 <lambdabot>  "10"
13:11:55 <lambdabot>  mueval: Expression did not compile.
13:11:55 <lambdabot> mueval: Time limit exceeded
13:11:57 <Cale> gwern: Can you tell the import list in mueval to be empty?
13:11:57 <trofi> > "Ъ"
13:11:59 <lambdabot>  "\"\\1066\""
13:11:59 <dmhouse> Yay!
13:12:01 <mauke> argh
13:12:16 <thoughtpolice> > "λ"
13:12:17 <lambdabot>  "\"\\955\""
13:12:18 <gwern> mauke: well of course that isn't going to compile :)
13:12:20 <Cale> (aside from the local file)
13:12:21 <dmhouse> > let id' :: a → b = id in id' ()
13:12:21 <lambdabot>  Illegal character ''\8594''
13:12:21 <lambdabot>  at "" (column 14)
13:12:25 <mmorrow> whoa
13:12:29 <mauke> gwern: I demand better error messages!
13:12:43 <mauke> …̈
13:12:45 <dmhouse> Fun's over, folks.
13:12:48 <gwern> Cale: how do you mean?
13:12:49 <thoughtpolice> :(
13:12:54 <mmorrow> haha
13:13:05 <olsner> "Hey, it's open source, fix it yourself and send in the patch!" :D
13:13:05 <Cale> gwern: L.hs imports the Prelude anyway
13:13:11 <Cale> gwern: So don't import it again.
13:13:14 <gwern> relax people; I will continue hacking on things
13:13:28 * sjanssen would like to have a discussion about the Prelude overloads
13:13:31 <trofi> @old_run
13:13:36 <Cale> gwern: In fact, it imports Prelude qualified, and as hiding a few things.
13:13:47 <gwern> Cale: mm. but if the prelude isn't imported then this breaks your default 'mueval -e 1+1'
13:13:59 <Cale> gwern: add a flag to do no imports.
13:14:03 <gwern> and it's silly to tell the user to go 'mueval --module Prelude -e 1+1'
13:14:05 <sjanssen> I know I sound like a broken record, but lambdabot should really be about evaluating Haskell, not some modified version
13:14:24 <Cale> gwern: Something like mueval --no-imports -l L.hs -e '1 + 1'
13:14:34 * Heffalump has previously expressed the same opinion repeatedly
13:14:35 <gwern> yeah, I agree. it was amusing while it was just confusing newbies
13:14:42 <gwern> but its welcome is outworn
13:14:46 <Heffalump> confusing newbies is not amusing, either.
13:14:47 <sjanssen> gwern: confusing newbies is actually the worst part
13:14:54 <gwern> Cale: do you want to remove the redefinitions or shall I?
13:14:55 <olsner> I kind of agree that #haskell should have a default-ish environment so that what works in lambdabot actually works in normal haskell too
13:14:58 <Heffalump> Well, it can occasionally be amusing, but we shouldn't do it.
13:14:59 <sjanssen> I had to explain to a newbie the other day why @type (.) was wrong
13:15:01 <Cale> gwern: what?
13:15:13 <gwern> Heffalump: it's like tripping a cripple - it's wrong, but still amusing
13:15:32 <sjanssen> @remember gwern it's like tripping a cripple - it's wrong, but still amusing
13:15:35 <gwern> Cale: the definitions in Pristine/L.hs - you're the only one arguing for them
13:16:02 <Cale> gwern: olsner is as well :)
13:16:16 <Cale> It would be nice to support both easily...
13:16:33 <gwern> Cale: what? he just said that 'so that what works in lambdabot works in normal haskell'
13:16:35 <sjanssen> Cale: actually, mueval should be able to do that pretty easily
13:16:39 <olsner> Cale: not *arguing* very much as such, but I'm definitely for them!
13:16:39 <gwern> that sounds like arguing against, not for
13:16:41 <Cale> Since mueval is loading from file explicitly, it seems like it should be easy to support both
13:16:57 <olsner> gwern: you're missing the implicit 'but' :D
13:17:19 <Cale> You just need a flag to not import any modules by default.
13:17:22 <gwern> olsner: what implicit but? I see no butts
13:17:28 <olsner> ... but I still want the extra-polymorphic versions around for playing with
13:17:30 <Cale> Or make that the case whenever loading from file.
13:17:55 <Cale> We could relatively easily have two eval commands :)
13:17:58 * rwbarton thinks the syntax should be:
13:18:00 <Cale> > and ], say.
13:18:02 <gwern> Cale: hm. do modules implicitly import from Prelude?
13:18:03 <rwbarton> *Cale> (+1) . [1,2,3]
13:18:08 <Cale> gwern: yeah
13:18:22 <gwern> I really don't want to make --loadfile only work with 'module Foo where; import Prelude; rest...'
13:18:40 <Cale> gwern: At least you could add a flag to not import modules.
13:18:43 <Cale> --no-imports
13:18:53 <gwern> it's bad enough that it has to be a module
13:19:10 <chrisdone> > (+1) . [1,2,3]
13:19:15 <c3za261_> e
13:19:18 <c3za261_> a
13:19:20 <Saizan> gwern: do you usually import Prelude in your modules?
13:19:49 <Cale> gwern: The Prelude is always implicitly imported.
13:20:01 <Cale> gwern: Unless you have something like  import Prelude ()
13:20:36 <gwern> yeah, I'm adding that
13:20:51 <gwern> I'm a little worried about the security aspects of not importing the Show modules
13:20:57 <gwern> but I'll have to test that
13:20:58 <Cale> what?
13:21:04 * sbahra pings Cale 
13:21:08 <Cale> Security aspects?
13:21:09 <gwern> no
13:21:12 <Cale> sbahra: hello
13:21:14 <sbahra> Hi
13:21:20 <sbahra> Did you receive my message by any chance?
13:21:51 <Cale> Yes, about having lambdabot join #not-##FreeBSD ?
13:22:05 <sbahra> Cale, yup
13:22:27 <Saizan> gwern: if you don't connect the IO actions to main they're not going to execute, regardless of how they can be showed or not
13:23:07 <Saizan> unless you import a show instance that uses unsafePerformIO, but that's another story
13:23:13 <Cale> Lambdabot is undergoing some fixes at the moment, so I will make it join shortly :)
13:23:48 <sbahra> Cale, cool. :-P
13:23:54 <sjanssen> gwern: the excess quoting issue is fixed in the patch I just sent you
13:23:56 <dmhouse> Is lambdabot state (e.g. ?let definitions) shared between channels?
13:24:03 <sbahra> Cale, it just happens that every time I am about to ask...something goes wrong with lament :-P
13:24:16 <sbahra> s/lament/lambdabot/
13:24:22 <gwern> sjanssen: cool, I'll look at that as soon as I get --noimport working
13:24:25 <trofi> former lb shared @let defs
13:27:33 <sjanssen> dmhouse: state is global
13:29:43 <b\6> could ghc be smarter about function signatures? my function getLine is colliding with the one in Prelude even though they couldn't possibly be mistaken for each other.
13:29:49 <chrisdone> “In order to illustrate what the query system does, we will show how it can be used to manage the data base of personnel records for Microshaft, a thriving high-technology company in the Boston area.”
13:29:53 <chrisdone> good olde SICP
13:30:10 <b\6> how are you molesting your keyboard to produce those screwed up quotes?
13:30:31 <Heffalump> b\6: Haskell has a mechanism for overloading names, called type classes.
13:30:39 <Heffalump> Having another one would be very confusing.
13:30:56 <dmhouse> b\6: import Prelude hiding (getLine) at the top of your file.
13:31:00 <b\6> yeah, of course.
13:31:08 <b\6> plz look at original question.
13:31:47 <dmhouse> I did. The answer is "no". Heffalump gave the justification, and I gave a workaround.
13:32:02 <chrisdone> b\6: AltGr+v “ and AltGr+b ”
13:32:46 <Cale> b\6: You can define a new typeclass for getLine-like operations if you want.
13:33:16 <b\6> yeah, i'm really asking about something else.
13:33:41 <b\6> like foo :: Int -> Int and foo :: String -> String and i'm calling foo "hi" and ghc's like HUH!!! which one does he mean???
13:33:47 <b\6> just surprised.
13:33:59 <gwern> sjanssen: I couldn't apply your patch, so I added it manually
13:33:59 <Heffalump> if you had it accept that, where would you draw the line?
13:34:41 <sjanssen> gwern: interesting
13:34:44 <gwern> b\6: that would make more sense in GHCi, actually - :m + Prelude; :m + Data.Map; map (+1) [1..100] -- only one type sig fits, and why should the user need to fully qualify names?
13:34:56 <b\6> yeah.
13:34:57 <Cale> b\6: class Foo a where foo :: a -> a; instance Foo String where foo = ...; instance Foo Int where foo = ...
13:34:59 <Saizan> Heffalump: where the type inferencer can't distinguish which one you want, but i'd find it confusing to read anyway
13:35:16 <gwern> sjanssen: said something about a patch missing
13:35:31 <dmhouse> b\6: you're talking about a fundamental change to Haskell, really.
13:35:41 <Cale> What is the inferred type of foo ?
13:35:42 <b\6> yeah, i'm willing to accept there are deep reasons why it'd be bad.
13:35:56 <gwern> definitely looks cleaner, anyway, with that show removed
13:36:05 <Cale> b\6: In the case where you have foo :: String -> String and foo :: Int -> Int, you need to infer a type for foo
13:36:14 <hackage> Uploaded to hackage: Unixutils 1.17
13:36:26 <dmhouse> It's like saying, can we just have non-fully-applied type synonyms? The answer is: no, because it results in the type-level lamba calculus.
13:36:32 <dmhouse> (For which you can't reconstruct types.)
13:36:54 <b\6> ok. good enough for me.
13:37:12 <b\6> lambda calculus can be our safe word.
13:37:20 <dmhouse> :)
13:39:20 <b\6> lambdabot should stream fingerprint everyone and determine some probability that they're making the transition from the normal imperative world and autorespond to questions with NO, HUSH.
13:39:50 <chrisdone> haha, I love SICP. it's so funny
13:40:36 <chrisdone> “Also, as is well known, (can-do-job (administration secretary) (administration big wheel)) [logic programming expression]”
13:41:04 <b\6> sicp should have its own show.
13:41:09 <chrisdone> haha
13:41:13 <chrisdone> sicp.tv
13:41:17 <Saizan> dmhouse: i'm not convinced that it will be such a fundamental change, it's almost like having an implicit typeclass everytime you've two conflicting functions in scope
13:41:38 <olsner> well, didn't they have streaming video SICP lectures on the internet?
13:41:43 <b\6> yeah.
13:41:46 <chrisdone> they sure do
13:41:50 <Heffalump> would the typeclass disappear when only one was in scope?
13:42:08 <b\6> you lagged? no need to beat my dead horse.
13:42:28 <Heffalump> We can if we want to :-p
13:42:36 <Saizan> Heffalump: yeah
13:42:52 <olsner> ... dead horses feel no pain
13:43:09 <Heffalump> so what if bar calls foo where there are two foos in scope, the type of bar now involves that typeclass
13:43:10 <b\6> they're out of scope.
13:43:20 <Heffalump> but then bar might get called elsewhere where only one foo is in scope, so no typeclass
13:43:29 <rwbarton> Saizan: Then if I have foo :: Int -> Int, foo :: Double -> Double, bar :: Int -> Int, bar :: Double -> Double, the types of foo and bar are different
13:44:58 <dmhouse> And what if foo is polymorphic? Do you require a nonintersection of the possible types (e.g. foo :: Show a => a and foo :: NonShow a => a)? Or perhaps cleanest to just rule out polymorphism altogether
13:45:00 <sjanssen> what is the type of "\x -> foo x" where foo is overloaded at Int -> Int and Char -> Char?
13:45:19 <Heffalump> also, what if the two foos have different arities?
13:45:22 <Saizan> Heffalump: well, as for MPTC if the types overloaded in foo are not present in bar you've to decide with instance to use, then we can use a similar rule, maybe more restrictive
13:45:58 <Heffalump> in my example the idea is that the types would be present in the type of bar, so you'd get a typeclass constraint
13:46:11 <Saizan> if the two foos have different arities it's simple to find which "instance" you want :)
13:46:19 <dmhouse> sjanssen: and what would :t foo display?
13:46:22 <Heffalump> Saizan: not at all, have you never heard of currying?
13:46:53 <TomMD> gahh, no lambdabot!
13:47:07 <Cale> It'll be back once it's fixed :)
13:47:12 <sjanssen> Heffalump: yeah, the compiler would need to have special knowledge about how many arguments were given at the callsite
13:47:44 <sjanssen> or perhaps it could choose which implementation to use at the last possible moment
13:48:13 <Saizan> however i wan't proposing to implement it as a typeclass, but the mechanism feels similar, "use information from the type inference to discriminate between two different functions"
13:48:42 <b\6> does ghc always generate c? does it compile the c with gcc?
13:48:50 <sjanssen> so what if all function definitons were translated from "foo :: t" to "instance FunFoo t"?
13:49:00 <sjanssen> b\6: no, yes
13:49:05 <Cale> b\6: I think by default it goes straight to native code these days
13:49:15 <Cale> b\6: But it can go via gcc.
13:49:17 <dmhouse> You can use --via-c
13:49:30 <Heffalump> sjanssen: I think the typechecker would get a major headache :-)
13:49:57 <rwbarton> sjanssen: so then foo :: FunFoo a => a?
13:50:00 <mauke> -fvia-C
13:50:07 <Wild_Cat`> does the Haskell record syntax support default values?
13:50:08 <dmhouse> Yeah, that too.
13:50:18 <dmhouse> Wild_Cat`: no, but you can use record update syntax.
13:50:20 <sjanssen> rwbarton: right
13:50:29 <Wild_Cat`> dmhouse: yeah, hopefully :p
13:50:37 <dmhouse> Wild_Cat`: "hopefully"?
13:50:38 <rwbarton> sjanssen: now no two toplevel identifiers can have the same type
13:50:52 <Saizan> if there are no monomorphic types type inference doesn't work, that's why we have defaulting
13:51:00 <sjanssen> rwbarton: yeah, that is true
13:51:23 <sjanssen> rwbarton: even if they're not visible in scope, the instances might be
13:51:26 <Wild_Cat`> oh, you mean as in defaultMyRecord = MyRecord { all default values here }, then use defaultMyRecord { modified values } whereever I'd use MyRecord?
13:51:48 <dmhouse> Right.
13:51:55 <dmhouse> This is what, e.g., xmonad uses for its default keybindings.
13:51:55 <sjanssen> Wild_Cat`: I've used that style in a few projects
13:52:10 <mauke> consider http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
13:52:13 <Wild_Cat`> so it's not considered crap and/or hackish? good.
13:52:14 <dmhouse> Erm, default config, not keybindings.
13:53:05 <nodogbite> could somebody please take a peek at
13:53:07 <nodogbite> http://hpaste.org/9787
13:53:18 <nodogbite> and help me figure out why it stack overflows?
13:53:27 <Cale> okay
13:53:29 <dmhouse> mauke: I don't that's the same as defaulting polymorphic types to monomorphic ones, is it?
13:53:30 <sjanssen> nodogbite: try foldl'
13:53:41 <nodogbite> sjanssen: okay
13:53:45 <mauke> probably because of foldl
13:53:46 <mauke> dmhouse: ENOVERB
13:54:04 <dmhouse> mauke: I was using "defaulting" as a verb.
13:54:17 <mauke> so you don't that's.
13:54:23 <nodogbite> oh is this a case where i'd actually want foldr
13:54:35 <nodogbite> sjanssen: foldl' eliminates stack overflow
13:54:46 <nodogbite> but clearly my solution isn't good because i'm still running
13:54:46 <nodogbite> ha
13:54:49 <ski> (mauke : "do" is a verb)
13:55:13 <nodogbite> i thought foldl optimizes to tight loops
13:55:20 <mauke> I still can't parse that sentence
13:55:23 <Cale> nodogbite: It does.
13:55:39 <nodogbite> Cale: i don't see how that would blow up a stack then
13:55:41 <Cale> nodogbite: Unfortunately, those tight loops often do nothing but build large expressions.
13:55:42 <dmhouse> nodogbite: it'd be a bit more idiomatic to write that as case smallRatios r d as [] -> r; (h:_) -> h
13:55:48 <sjanssen> nodogbite: perhaps you do want foldr, do you want to exit before touching all elements of the input?
13:55:53 <Cale> Evaluating those expressions later causes the stack overflow.
13:56:11 <nodogbite> Cale: what do you mean by "later"
13:56:19 <dmhouse> mauke: I meant that Data.Default isn't the same thing as the defaulting process that converts polymorphic types to monomorphic ones.
13:56:20 <nodogbite> dmhouse: good point
13:56:55 <Cale> nodogbite: foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> ((0+1)+2)+3
13:57:03 <dmhouse> nodogbite: then as a bonus you don't need to import Data.List
13:57:09 <mauke> dmhouse: er. of course not.
13:57:24 <Cale> nodogbite: Then, things get put on the stack, since the top level reducible expression in ((0+1)+2)+3 is 0+1
13:57:27 <nodogbite> Cale: i understand what you wrote
13:57:45 <dmhouse> mauke: okay. Saizan said something about the latter type, then you said that, I joined the dots.
13:57:49 <nodogbite> Cale: oh so i guess that's not what i thought happened under the covers in terms of
13:57:51 <nodogbite> optimizing to a loop
13:58:04 <nodogbite> but i guess that's what foldl' is for
13:58:07 <Cale> nodogbite: All those steps happen in a tight loop.
13:58:09 <nodogbite> to make it strict?
13:58:17 <Cale> But the addition isn't reduced in the body of that loop
13:58:22 <Cale> It's just set up :)
13:58:23 <dmhouse> nodogbite: right, you evaluate as you go along with foldl'.
13:58:26 <Cale> Right.
13:58:35 <nodogbite> okay, that makes sense to me
13:59:37 <gwern> Cale: ok, I've added defaulting to eval - now 'show []' works
13:59:58 <nodogbite> thanks all.. now i need to figure out the correct solution
14:00:07 <dmhouse> lambdac: > show []
14:00:16 <trofi> > 1
14:00:17 <dmhouse> > show []
14:00:18 <lambdac>  1
14:00:19 <lambdac>  "[]"
14:00:36 <dmhouse> > (*2) . (+1) $ 10
14:00:37 <lambdac>  22
14:00:50 <trofi> @version
14:00:50 <lambdac> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.00GHz)
14:00:50 <lambdac> darcs get http://code.haskell.org/lambdabot
14:02:45 <gwern> anyone have a good > example using stuff from Control.Monad?
14:02:49 <gwern> or Data.List?
14:03:07 <Cale> > sequence [[1,2,3],[4,5]]
14:03:09 <lambdac>  [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
14:03:16 <Cale> > sort [4,6,1,2,3]
14:03:18 <lambdac>  [1,2,3,4,6]
14:03:18 <byorgey> > filterM (const [False,True]) [1,2,3]
14:03:20 <lambdac>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:03:21 <mauke> > fix show
14:03:23 <lambdac>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:03:43 <mauke> > fmap fix return 42
14:03:44 <lambdac>  42
14:03:50 <gwern> already have fix show, and that's Data.Function anyway
14:04:08 <byorgey> gwern: what's this for?
14:04:19 <gwern> byorgey: mueval tests
14:04:23 <byorgey> ah
14:04:35 <gwern> I've made it import a bunch of modules which *should* cover all the standard used modules
14:04:36 <Saizan> > runIdentity $ mfix (return . (0:) . scanl (+) 1)
14:04:38 <lambdac>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:04:54 <Cale> gwern: You can get a list of what lambdabot imports from imports.h
14:04:56 <mauke> > M.empty
14:04:57 <lambdac>  fromList []
14:05:02 <mauke> > S.empty
14:05:03 <lambdac>  fromList []
14:05:06 <Cale> gwern: which is CPP-included into L.hs
14:05:07 <gwern> Cale: yes, that's what I've based it on
14:05:12 <trofi> > fix error
14:05:27 <lambdac>  thread killed
14:05:34 <trofi> > "import.h"
14:05:36 <lambdac>  "import.h"
14:05:40 <gwern> fix error is an error in mueval, and I see no reason to change that..
14:05:40 <trofi> imports.h
14:05:54 <mauke> gwern: what error is it?
14:06:17 <trofi> he is about "fix error" expression
14:06:36 <trofi> @hoogle fix
14:06:36 <lambdac> A Hoogle error occured.
14:06:38 <olsner> > fix ((1:).(1:).(zipWith (+) `ap` tail))
14:06:40 <lambdac>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:06:53 <Saizan> gwern: can't you catch expressions?
14:06:59 <Saizan> *exceptions
14:07:02 <olsner> (sorry about the unnecessary whitespace between operators :P)
14:07:08 <gwern> catch exceptions?
14:07:15 <Saizan> > error "foo"
14:07:16 <lambdac>  Exception: foo
14:07:23 <trofi> to pretty print em
14:07:24 <gwern> good all these examples work in mueval thus far
14:07:24 <mmorrow> > runST (return 0)
14:07:25 <lambdac>  0
14:07:36 <Saizan> > () ()
14:07:37 <lambdac>  Couldn't match expected type `() -> t' against inferred type `()'
14:07:46 <mauke> > ä
14:07:46 <lambdac>  Illegal character ''\164''
14:07:46 <lambdac>  at "" (column 2)
14:08:05 <gwern> mmorrow: that one works as well
14:08:13 <mmorrow> > runST (unsafeIOToST (print "i can't do that, dave"))
14:08:14 <lambdac>  ()
14:08:18 <trofi> @. run google i am the code
14:08:19 <mmorrow> ahahahaha
14:08:20 <lambdac>  Parse error at "of-i-..." (column 53)
14:08:23 <sjanssen> gwern: is it possible to turn on -fextended-defaulting?
14:08:40 <gwern> sjanssen: that's done via 'mueval -E'
14:08:57 <mmorrow> > runST (unsafeIOToST (writeFile "/tmp/HAI" "KTHXBYE"))
14:08:57 <sjanssen> hmm
14:08:58 <lambdac>  ()
14:09:00 <mmorrow> ahahaha
14:09:10 <mmorrow> check /tmp
14:09:10 <gwern> gwern@craft:17715~>mueval -e "runST (unsafeIOToST (print \"i can't do that, dave\"))"                                [ 5:09PM]
14:09:15 <gwern>  mueval: Unsafe functions to use mentioned.
14:09:22 <vincenz> woah
14:09:24 <vincenz> that returns )( ?
14:09:24 * gwern shrugs. I shall shed no tears over that
14:09:30 <vincenz> which means it's actually working, no?
14:09:37 <vincenz> shouldn't unsafeIOToST not be supported?
14:09:43 <Saizan> > let (≡) = () in (≡)
14:09:43 <lambdac>  Illegal character ''\137''
14:09:44 <lambdac>  at ")" (column 7)
14:09:48 <olsner> zomgwtf, cat /tmp/HAI :P
14:09:52 <mmorrow> hmm, is there a file HAI in /tmp .. or not?
14:09:54 <dmhouse> What happened to unicode?
14:09:57 <mauke> > runST (unsafeIOToST (readFile "/etc/passwd"))
14:09:58 <lambdac>  "root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\nbin...
14:10:01 <opqdonut> :D:D
14:10:03 <opqdonut> :D
14:10:05 <vincenz> woah!!!!!
14:10:05 <mmorrow> ahahahahaha
14:10:06 <trofi> BOOM
14:10:10 <gwern> oh man
14:10:12 <b\6> heh.
14:10:13 <mauke> @quit
14:10:14 <lambdac> Not enough privileges
14:10:15 <thoughtpolice> bummer
14:10:17 <vincenz> @quit
14:10:17 <lambdac> Not enough privileges
14:10:27 <mauke> > withCString
14:10:27 <gwern> ok, that example is going straight into my naughty list of evil functions!
14:10:28 <lambdac>   Not in scope: `withCString'
14:10:28 <sjanssen> @quit
14:10:29 <lambdac> Not enough privileges
14:10:29 <opqdonut> whose is it?
14:10:35 <mmorrow> gwern: hehe
14:10:44 <vincenz> someone in au
14:10:46 <thoughtpolice> ST wasn't banned before all these lambdabot changes took place? :/
14:10:51 <thoughtpolice> i was under the assumption it was
14:11:05 <mauke> @index withCString
14:11:06 <vincenz> that's nasty
14:11:06 <lambdac> Foreign.C.String, Foreign.C
14:11:07 <mmorrow> Cale removed unsafeIOToST previously
14:11:13 <sjanssen> thoughtpolice: I think somebody is running an old version
14:11:13 <mauke> > Foreign.C.withCString
14:11:14 <lambdac>   Not in scope: `Foreign.C.withCString'
14:11:15 <mmorrow> mauke: oh snap
14:11:22 <mauke> aww
14:11:30 <Cale> unsafeIOToST is in the wrong module
14:11:36 <gwern> they're certainly not running darcs lambdabot, that's obvious
14:11:39 <Cale> It should be in System.IO.Unsafe
14:11:40 <thoughtpolice> heh
14:11:41 <trofi> readFile?
14:11:50 <sjanssen> I know I fixed this in lambdabot at one point
14:12:02 <olsner> > runST (unsafeIOToST (readFile "/tmp/HAI"))
14:12:03 <lambdac>  "KTHXBYE"
14:12:15 <olsner> :)
14:12:17 <opqdonut>  runST . unsafeIOtoST $ system "pgrep lambdabot |xargs kill"
14:12:19 <gwern> heh. total hole
14:12:19 <Cale> But instead, it's in Control.Monad.ST
14:12:21 <vincenz> > runST (unsafeIOToST (getDirectoryContents "."))
14:12:21 <opqdonut> somebody could do that
14:12:21 <lambdac>   Not in scope: `getDirectoryContents'
14:12:23 <mmorrow> olsner: haha
14:12:33 <mauke> > System.Posix.Signals.raiseSignal
14:12:33 <lambdac>   Not in scope: `System.Posix.Signals.raiseSignal'
14:12:41 <TomMD> ?index getDirectoryContents
14:12:42 <lambdac> System.Directory, Distribution.Compat.Directory
14:12:48 <vincenz> > runST (unsafeIOToST (readFile "."))
14:12:50 <lambdac>  "Exception: .: openFile: inappropriate type (is a directory)
14:12:53 <mauke> > exitWith
14:12:53 <lambdac>   Not in scope: `exitWith'
14:13:01 <mauke> > System.Exit.exitWith
14:13:02 <lambdac>   Not in scope: `System.Exit.exitWith'
14:13:08 <mmorrow> > runST (unsafeIOToST (runQ [|()|]))
14:13:08 <lambdac>  Parse error at "|()|]..." (column 28)
14:13:12 <vincenz> > runST (unsafeIOToST (System.Directory.getDirectoryContents "."))
14:13:13 <lambdac>   Not in scope: `System.Directory.getDirectoryContents'
14:13:15 <trofi> you can inject code directly into L.hs :]
14:13:16 <vincenz> meh
14:13:24 <vincenz> you could probably overwrite some of the configuration files with this
14:13:28 <mauke> > runST (unsafeIOToST (readFile "L.hs"))
14:13:29 <lambdac>  "Exception: L.hs: openFile: does not exist (No such file or directory)
14:13:32 <sjanssen> trofi: @let won't accept imports
14:13:41 <vincenz> > runST (unsafeIOToST (readFile "Plugin/L.hs"))
14:13:42 <lambdac>  "Exception: Plugindoes not exist (No such file or directory)
14:13:43 <trofi> writeFile does
14:13:45 <trofi> :]
14:13:51 <Cale> > runST (unsafeIOToST (readFile "State/L.hs"))
14:13:52 <lambdac>  "{-# LANGUAGE CPP #-}\nmodule L where\n\n#include \"imports.h\"\n\ndescribeS...
14:13:53 <sjanssen> trofi: ah, clever :)
14:13:56 <opqdonut> Cale: heh
14:14:08 <sjanssen> so who runs lambdac?  We really ought to let them know
14:14:12 <vincenz> Cale: now just rewrite it to import IO :)
14:14:18 <trofi> it's not hard to know :]
14:14:20 <gwern> not bad - you could delete L.hs, add your own imports, and then you're homefree
14:14:23 <opqdonut> sjanssen: we could ask a freenode oper to kill it
14:14:29 <opqdonut> that would be best I guess
14:14:32 <vincenz> gwern: yeah, what I just said :)
14:14:36 <mauke> where is imports.h?
14:14:36 <vincenz> nasty
14:14:40 <gwern> > runST (unsafeIOToST (writeFile "State/L.hs" ""))
14:14:41 <lambdac>  ()
14:14:43 <mauke> oh, there
14:14:46 <trofi> L.hs .d be enought
14:14:50 <gwern> > runST (unsafeIOToST (readFile "State/L.hs"))
14:14:52 <lambdac>  ""
14:14:52 <mauke> > 2
14:14:53 <lambdac>  2
14:14:58 <opqdonut> aww
14:15:10 <TomMD> > sum [1..]
14:15:13 <mmorrow> > runST (unsafeIOToST (system "hostname > /tmp/asdf" >> readFile "/tmp/asdf"))
14:15:13 <sjanssen> > runSt (unsafeIOToST (writeFile "State/L.hs" "don't evaluate me"))
14:15:17 <lambdac>   Not in scope: `system'
14:15:17 <lambdac>   Not in scope: `runSt'
14:15:23 <cjb> :)
14:15:24 <dmhouse> > runST (unsafeIOToST (System.system "killall lambabot"))
14:15:25 <sjanssen> > runST (unsafeIOToST (writeFile "State/L.hs" "don't evaluate me"))
14:15:31 <sjanssen> > x
14:15:37 <trofi> @undef
14:15:39 <adekoba> lol. what is going on.
14:15:41 <lambdac>  thread killed
14:15:42 <TomMD> It will come back after the sum crashes
14:15:44 <gwern> > runST (unsafeIOToST (writeFile "State/L.hs" "module L where\n import Foreign\n))
14:15:45 <TomMD> there
14:15:54 <gwern> > runST (unsafeIOToST (writeFile "State/L.hs" "module L where\n import Foreign\n"))
14:15:59 <lambdac>  thread killed
14:15:59 <lambdac> Unbalanced parentheses
14:16:01 <lambdac>  thread killed
14:16:01 <opqdonut> > runST . unsafeIOtoST $ system "pgrep lambdabot |xargs  kill"
14:16:01 <lambdac>  thread killed
14:16:01 <lambdac> thread killed
14:16:04 <opqdonut> heh :)
14:16:06 <trofi> @help undef
14:16:10 <Cale> @undefine
14:16:11 <trofi> @help undefine
14:16:14 <ToRA> erm, someone really should just system kill it
14:16:19 <mauke> > 42
14:16:25 <lambdac>  thread killed
14:16:26 <trofi> main = exitWith 0
14:16:29 <sjanssen> > runST (unsafeIOtoST (readFile "runplugs"))
14:16:30 <ToRA> the owner may not appreciate the configs being hacked...
14:16:42 <sjanssen> where is runplugs kept?
14:16:43 <trofi> ./
14:16:43 <TomMD> I'm helping him out a little.
14:16:50 <lambdac>  thread killed
14:16:52 <trofi> usually in ./
14:16:55 <lambdac> Plugin `help' failed with: thread killed
14:16:57 <Heffalump> we could just ban it..
14:16:59 <mauke> heh
14:17:02 <mauke> it's half dead
14:17:03 <sjanssen> > runST (unsafeIOtoST (writeFile "runplugs" ""))
14:17:07 <lambdac>  thread killed
14:17:14 --- mode: ChanServ set +o dmhouse
14:17:17 <dmhouse> Kill it?
14:17:21 <Saizan> i think sjanssen's writeFile "State/L.hs" "don't evaluate me + @undefine has broken runplugs anyhow
14:17:22 <dobblego> @part #haskell
14:17:23 <opqdonut> i'm askin #freenode
14:17:24 <lambdac>  thread killed
14:17:35 <dobblego> sorry guys
14:17:35 <opqdonut> Saizan: yes
14:17:36 <trofi> @help
14:17:37 <lambdac>  thread killed
14:17:45 <opqdonut> there it went
14:17:48 <vincenz> > 1
14:17:53 --- mode: dmhouse set -o dmhouse
14:17:53 <ski> 0
14:17:54 <gwern> > runST (unsafeIOToST (readFile "/etc/passwd"))
14:17:56 <opqdonut> can still msg it tho
14:17:56 <olsner> I haven't had this much fun in #haskell in ages! :D
14:18:16 <vincenz> funky :)
14:18:16 <TomMD> olsner: Are you saying I'm boring?!?!? :-(
14:18:21 <trofi> IRC ops should /kill it
14:18:24 <sjanssen> I overwrote runplugs, the whole should be fixed :P
14:18:30 <opqdonut> trofi: i'm trying to contact them
14:18:32 <sjanssen> s/whole/hole
14:18:43 <sjanssen> opqdonut: I think dobblego is the operator
14:18:48 <opqdonut> dobblego?
14:18:50 <dobblego> yes
14:18:50 <opqdonut> you here?
14:18:54 <opqdonut> ah
14:18:56 <dobblego> for 1 minute
14:19:01 <dmhouse> Be sure to mention /tmp/HAI
14:19:08 <sjanssen> dobblego: so you need to 'darcs pull' patches from more than a year ago
14:19:25 <mauke> you need to kill lambdac
14:19:26 <dobblego> so it seems, thanks
14:19:27 <Cale> dobblego: You need to hide the unsafeIOToST import from Control.Monad.ST
14:19:38 <olsner> TomMD: that is one reasonable explanation :)
14:19:45 <dobblego> I can't kill it right now and you can do what you want on that machine
14:19:49 <opqdonut> blacklisting is usually a pretty bad way to sandbox
14:20:04 <dobblego> I must depart; I will fix it when I get there
14:20:06 <sjanssen> opqdonut: it's pretty decent in Haskell
14:20:11 <opqdonut> of course haskell makes it easier, one could just for example ban everything that has IO in the type
14:20:14 <opqdonut> yes
14:20:21 <sjanssen> > 1
14:20:29 <matthew-_> 1
14:20:33 <opqdonut> 1
14:20:37 <trofi> one!
14:20:39 <Twey> `import Prelude hiding IO'
14:20:40 <Twey> ?
14:20:40 <matthew-_> uno
14:20:42 <mauke>  2
14:20:42 * sjanssen forgot where I was
14:20:46 <TomMD> Until someone makes 'unsafePerformM :: m a -> a"
14:20:57 <Twey> ]Hah
14:21:12 <gwern> opqdonut: unfortunately, it's not that simple
14:21:19 <gwern> sandboxing haskell turns out to be very difficult
14:21:20 <trofi> {-# LANGUAGE -fdisableUnsafes #_}
14:21:22 <sjanssen> so if lambdabot ever goes crazy, somebody run: > runST (unsafeIOtoST (writeFile "runplugs" ""))
14:21:32 <sjanssen> though that won't work with mueval, I suppose
14:21:38 <gwern> no
14:21:38 <opqdonut> mueval?
14:21:45 <mauke> why isn't there a runplugs in my lambdabot repo?
14:21:45 <gwern> but imo mueval is a lot safer
14:21:56 <sjanssen> mauke: you haven't built it?
14:22:01 <mauke> oh
14:22:02 <Vq^> gwern: why is it very difficult?
14:22:22 <olsner> is mueval actually safe, or just safer?
14:22:22 <sjanssen> gwern: mueval has the same vulnerability we just noticed
14:22:23 <gwern> Vq^: too many holes in the type system, bugs, and potential DoS attacks
14:22:28 <gwern> there's a page on the wiki if you care
14:22:38 <opqdonut> which one?
14:22:38 <gwern> sjanssen: what, the st thing? no it doesn't
14:22:52 <sjanssen> gwern: does turning on extensions turn on -fglasgow-exts?
14:22:53 * gwern forgets
14:22:55 <TomMD> Mmmmm, DoS.  The tla that is an OS and an attack!
14:23:06 <gwern> it's probably linked from the lambdabot page, fwiw
14:23:13 <gwern> sjanssen: it turns on a subset, iirc
14:23:27 <gwern> sjanssen: obviously if you have any attacks, i'd like to see'em
14:24:00 <Vq^> gwern: what is the page called?
14:25:36 <gwern> Vq^: as I said, look at http://haskell.org/haskellwiki/Lambdabot
14:26:19 <Vq^> ah, Safely running untrusted Haskell code
14:26:20 <opqdonut> http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
14:26:21 <opqdonut> yes
14:26:38 <dons> stepcut: you rock!
14:26:47 <mauke> “Unsafely running trusted C code”
14:26:49 <gwern> what did he do?
14:27:10 <gwern> mauke: well, there is geordi, which is part haskell
14:27:13 <gwern> but that's c++
14:27:21 <olsner> "avoiding unsafePerformIO and unsafeIOtoST and such like." :)
14:27:24 <dons> http://www.haskell.org/pipermail/haskell-cafe/2008-August/046272.html
14:27:39 <gwern> ah, so he did write up the debian-cabal tool
14:27:41 <gwern> cool
14:28:04 <opqdonut> dons: wow
14:28:15 <dons> http://www.reddit.com/r/programming/comments/6x2bx/cabaldebian_now_you_can_automatically_generate/
14:28:19 <dons> go go go!
14:28:41 <gwern> I like the debain-cabal-install tool myself
14:28:44 <gwern> that sounds really cool
14:31:26 <dons> stepcut: so why do .debs need additional polishing?
14:31:36 <dons> just the manual license resolution junk?
14:32:25 <yitz> dons: various other dependency issues, other policies, etc.
14:32:28 <stepcut> dons: license junk. missing or poor descriptions in .cabal file. Some packages need extra data files which are not currently automatically supported.
14:32:47 <dons> oh ok.
14:32:58 <dons> so i think it's easier for Arch there.
14:33:15 <dons> we just 'runhaskell Setup install' into  a chroot, snapshot that, and it's done.
14:33:25 <dons> maybe 20 packages need manual tweaking
14:33:32 <trofi> it should be fixed in .cabal, not only .deb
14:33:41 <stepcut> Debian is very picky, as I mention in the message, it should be easy to create an unofficial repository of .debs mostly automatically
14:33:52 <yitz> stepcut: do you support packages that need C dependencies, ffi builds, and the like?
14:34:00 <Heffalump> most of the steps Igloo describes sound like they should be sent upstream
14:34:04 <Heffalump> the fixes, that is
14:34:08 <dons> yeah.
14:34:17 <dons> i've had to feed things back like that
14:34:23 <dons> people installing binaries called 'test'
14:34:29 <dons> for example.
14:34:29 <stepcut> Heffalump: right, but upstream is not always that responsive or friendly, in my experience
14:34:48 <stepcut> Heffalump: of course, that is not reason not to try
14:34:57 <dons> i've not had problems.
14:35:05 <dons> haskell peopple seem quite receptive to cabal help
14:35:10 <stepcut> Heffalump: but, if you are on a schedule, it is usually faster to fix first, and ask questions later :)
14:35:11 <dons> since there are few experts
14:35:17 <Heffalump> stepcut: sure
14:35:26 <opqdonut> dons: as it is in general with packaging
14:35:27 <dons> so now we need a clear effort to get lots of packages in and working
14:35:33 <Heffalump> the fundamental problem is that Debian has much higher quality standards than hackage
14:35:36 <enso> >1
14:35:38 * SamB_XP steals Igloo's schedule 
14:35:38 <Heffalump> whereas presumably arch doesn't have any
14:35:41 <enso> > 1
14:35:45 <opqdonut> 1
14:35:50 <dons> Heffalump: we have staging.
14:35:51 <Heffalump> (this is not an insult, just a comment on a different approach)
14:35:54 <enso> is lambda bot out to lunch?
14:35:59 <dons> AUR -> community -> extra -> core
14:36:09 <dmhouse> enso: yes, fixes going on.
14:36:09 <Heffalump> I see, that's handy.
14:36:13 <stepcut> yitz: regarding C dependencies -- dunno. But it could be added. The technology to map libraries back to the .deb that provides them is already there
14:36:16 <Heffalump> But I can't see Debian adopting that formally.
14:36:19 <enso> thank
14:36:21 <dons> right.
14:36:22 <opqdonut> arch doesn't have standards, they only have irritating mandated practices
14:36:25 <opqdonut> like no info pages
14:36:25 <matthew-_> sorry, is this thread from -cafe or libraries?
14:36:25 <enso> thanks*
14:36:29 <Heffalump> -cafe
14:36:31 <matthew-_> ta
14:36:33 <SamB_XP> dmhouse: what does she eat?
14:36:39 <stepcut> enso: lambabot was a bad girl, showed off her naughty bits, and had to be sent away
14:36:40 <dons> arch is a reponse to debian's beauracracy
14:36:49 <dons> opqdonut: it has standards the way a wiki does.
14:36:51 <yitz> stepcut: problem is that cabal itself doesn't support those so well yet afaik
14:36:56 <dons> so, very fast turn around.
14:37:02 <Heffalump> is it primarily binary or source packaging?
14:37:05 <opqdonut> well I hate the standards they do have
14:37:07 <dmhouse> SamB_XP: ?botsnacks.
14:37:09 <dons> binary.
14:37:10 <opqdonut> in terms of doccing, debugsyms
14:37:11 <opqdonut> etc
14:37:28 <dons> can you really hate documentation conventions?
14:37:34 <SamB_XP> dmhouse: how can she get those if she's out to lunch and not here where we can give them to her?
14:37:35 <Heffalump> I think an unofficial Debian repo that's autobuilt would be great.
14:37:41 <dmhouse> SamB_XP: Cale is in /msg typing "?botsnack RET <up> RET <up> RET ..."
14:37:44 <opqdonut> dons: conventions on what docs are included in packages
14:37:46 <Heffalump> People could give it lower priority than real Debian.
14:37:46 <stepcut> yitz: right. cabal-debian is ultimately limited by what .cabal provides. So it will never be 100% with out some help. But, it still cuts out a lot of the repetitive parts.
14:37:49 <dons> yeah, we did that for arch. code.haskell.org/arch/x86_64
14:37:53 <dons> an "overlay"
14:37:53 <SamB_XP> dmhouse: lol
14:37:57 <yitz> sure
14:38:28 <dons> stepcut: yeah, i think, even with some manual intervention, we're talking about a magnitude improvement in productivity
14:38:38 <dons> one person can maintain 500, instead of <50 packages.
14:38:42 <dons> maybe 2 magnitudes
14:38:55 <SamB_XP> dons: may depend on the number base ;-P
14:39:02 <stepcut> Heffalump: seereason has the technology, just not the manpower. We are trying to get the tools out there so that interested people can help -- but that takes manpower as well
14:39:36 <dons> stepcut: definitely.
14:39:47 <dons> i'd love to see an organised debian effort.
14:39:57 <dons> with some clear goals, and milestones
14:40:27 <yitz> dons: if the tool can remember things for updates later, then most of whatever manual work there is can be limited to the first upload
14:40:34 <matthew-_> dons: do you vet the packages that you put in arch? Or do you just automatically translate everything that's on hackage?
14:40:34 <Igloo> Heffalump: The fixes should be sent upstream, but you still need to check that it's (still) right for each new release
14:40:37 <stepcut> dons: me too. Unfortunately, our contribution will be limited to the release of these tools for the near future.
14:40:44 <dons> matthew-_: i vet them.
14:40:58 <dons> yitz: yep.
14:44:08 <glguy> I love when darcs takes over 10 minutes to pull down the patches from xmonadcontrib
14:44:09 <glguy> woot
14:44:29 <glguy> err, to process them. the network traffic stopped a long time ago
14:44:31 <dons> switching back to xmonad?
14:44:35 <glguy> just playing around
14:44:37 <dons> yeah, merging.
14:44:49 <Cale> glguy: Is it a darcs-1 repo?
14:44:51 <dons> all those automated merge resolutions kicking in.
14:44:55 <dons> Cale, yep
14:45:08 <Cale> Perhaps it should be upgraded? :)
14:45:13 <glguy> to git?
14:45:15 <glguy> :-D
14:45:16 <Igloo> Does glguy hav elocal changes?
14:45:19 <selmanj> Is this channel a place to ask newbie haskell questions, or is this haskell development only?
14:45:25 <ndmitchell> @seen dcoutts
14:45:25 <Cale> To darcs 2
14:45:26 <ndmitchell> @seen dcoutts_
14:45:31 <mmorrow> i just got darcs-2 the other day and it's ***way*** faster
14:45:49 <glguy> Igloo: it's too late to find out, I think
14:45:57 <Cale> selmanj: It's a place to ask beginner questions too :)
14:45:58 <glguy> Igloo: darcs is already mucking about in the working directory
14:46:02 <Cale> selmanj: Go right ahead :)
14:46:14 <Igloo> glguy: So it's using CPU and hasn't finished yet?
14:46:15 <ndmitchell> Igloo: you probably know - how do i make /haskell/hoogle/3 allowed to contain CGI binaries?
14:46:23 <ndmitchell> (on haskell.org)
14:46:26 <glguy> Igloo: yeah. it isn't even using much ram
14:46:29 <glguy> just all of one core
14:46:53 <selmanj> Ok, well, I wrote some Haskell code to try and solve a problem, but I'm getting a stack overflow with really large input.  I tried to use seq as well as tail recursion but it's still occuring... perhaps someone can spot why?
14:46:57 <selmanj> http://hpaste.org/9790
14:47:11 <Igloo> ndmitchell: I can't look at that right now, sorry
14:47:26 <ndmitchell> fair enough :)
14:47:35 <dmhouse> ndmitchell: do you have access to the apache config?
14:47:35 <dons> selmanj: let's see.
14:47:47 <ndmitchell> dmhouse: where is that likely to live?
14:47:53 <dons> selmanj: looks like 'a' is non-strict?
14:47:54 <Igloo> ndmitchell: I suspect it'll need root access, though; I'm not sure if dons or dcoutts has it?
14:48:05 <dons> selmanj: what input do you give it?
14:48:18 <dmhouse> ndmitchell: /etc/apache2 on my system.
14:48:20 <ndmitchell> Igloo: I think I managed it before on my own, with my login
14:48:21 <Cale> selmanj: (sol + 1) `seq` ...  will evaluate (sol + 1) and proceed to throw the result away
14:48:27 <selmanj> dons: solve202 12017639147
14:48:35 <Cale> selmanj: well, it'll evaluate sol in the process, so perhaps not totally useless...
14:48:36 <dmhouse> ndmitchell: if you can write to it it's definitely possible. If you can read it, you can check if it's possible.
14:48:36 <dons> yeah, that's not how you stricitfy it.
14:48:40 <Igloo> OK, you might be able to do it with .htaccess then
14:48:43 <selmanj> Cale: it doesn't reuse the result in the second call?
14:48:52 <dons> selmanj: nope. you have to name the computation
14:49:00 <dons> where x = ...
14:49:07 <dons>  x `seq` foo x
14:49:19 <glguy> rather than telling everyone that Haskell doesn't memoize everything
14:49:20 <Cale> Using bang patterns might be more straightforward.
14:49:20 <dons> but there's nicer ways to do this.
14:49:31 <dmhouse> ndmitchell: basically Apache allows custom config files on a per-directory bsis using .htaccess files, but the directives that are allowed in there are of course restricted.
14:49:35 <glguy> we should just consider a flag to make it memoize everything :)
14:49:53 <glguy> if for no other reason than to show why you don't want that behavior
14:49:54 <augustss> Cale: there's a new version of djinn in case you want to update the bot.  Nothing exciting, just various little fixes.
14:49:54 <Cale> glguy: Then people would wonder where all their memory is going.
14:49:57 <ndmitchell> dmhouse: its been done before, its just years since i did it, i can't even find the config files...
14:50:03 <Cale> augustss: okay
14:50:05 <jsnx> glguy: heh
14:50:26 <selmanj> I'll admit, I wasn't really sure how to use seq - the reference page I found wasn't very helpful
14:50:32 <selmanj> I will google for bang patterns
14:51:00 <dons> selmanj: it's pretty straight forward.
14:51:14 <Cale> selmanj: {-# LANGUAGE BangPatterns #-} and then just put ! before the parameters to your function, like  solve202' !k !a !sol = ...
14:51:22 <dons> how long do you expect n=12017639147 to take, btw?
14:51:27 <Cale> In order to ensure that it evaluates those before proceeding.
14:51:40 <selmanj> dons: a few hours, i haven't timed it yet
14:52:02 <dons> ah , that's why mine's not done yet.
14:52:15 <dmhouse> ndmitchell: see the CGI example in http://httpd.apache.org/docs/2.2/howto/htaccess.html
14:52:16 <selmanj> at least, thats how long the roughly equivalent code took in matlab
14:52:40 <MyCatVerbs> dons, Cale: what if you have several equations for a particular function? Also, is the strictness just to whrnf or to rnf?
14:52:48 <dons> selmanj: http://hpaste.org/9790#a1
14:52:58 <dons> MyCatVerbs: whnf, which is rnf for Integer.
14:53:02 <Cale> MyCatVerbs: whnf as usual
14:53:08 <trofi> http://hpaste.org/9791 - why it does not work ? (something with return and monad type)
14:53:14 <dmhouse> ndmitchell: you could stick the directives it gives as examples there in a <Directory foo> ... </Directory> block to restrict them, see http://httpd.apache.org/docs/2.2/mod/core.html#directory
14:53:18 <Cale> MyCatVerbs: and putting them on the first equation will do
14:53:29 <MyCatVerbs> dons, Cale: sweet. Danke. ^^
14:53:40 <dons> selmanj: actually, i think i just compiled it.
14:53:46 <ndmitchell> dmhouse: i'm pretty sure there are similar entries already there, so a copy and paste job - i'm just having trouble finding the config file
14:53:47 <dons> and the strictness analyser sorted it out.
14:53:55 <dons> selmanj: did you actually try compiling the code with optimisations on?
14:54:00 <dmhouse> ndmitchell: grep for .htaccess (keep in mind these are hidden files)
14:54:13 <selmanj> dons: no, I ran it in ghci ... hmmm
14:54:19 <dons> oh, sol isn't strict.
14:54:29 <dons> selmanj: ok. so  that'll be say, 30x slower than compiling it.
14:54:45 <dons> $ ghc --make -O2 -fvia-C -optc-O2 A.hs
14:54:50 <selmanj> that bad huh?  I figured it would have an impact but
14:55:02 <selmanj> Ok now I have to read the man pages for all those options :)
14:55:05 <dons> ghci does no optimisations, so you miss out on all the good things about using a strongly typed, purely functional language.
14:55:08 <zeno_> @botsnack
14:55:15 <dmhouse> Why isn't -O2 default?
14:55:18 <zeno_> lambdabot is down?
14:55:20 <ndmitchell> dmhouse: as a Windows user, i thought grep was for files? how would i grep for that?
14:55:22 <TomMD> zeno_: Lambdabot doesn't deserve a snack right now.
14:55:42 <zeno_> i know he wont @pl my stuff :\
14:55:44 <selmanj> dons: I don't actually see any bang patterns in your annotaiton, am I missing something?
14:55:45 <dmhouse> ndmitchell: sorry, find . -type f -name ".htaccess" should do it
14:55:50 <ddarius> dons: Um, hopefully not -all- of them...
14:55:52 <dons> selmanj: yep, the bang patterns.
14:55:56 <dmhouse> zeno_: down for maintainence.
14:56:00 <dons> there's not needed, since  ghc does strictness analysis.
14:56:09 <zeno_> is there an easy way to get a local version of it?
14:56:12 <TomMD> ndmitchell: But you can't grep streams:  ls -R | grep htaccess
14:56:21 <selmanj> dons: What's strictness analysis?
14:56:38 <dons> it infers which variables should be strictly evaluated, based on how they're used.
14:56:40 <TomMD> Not to say that is what you want.
14:56:43 <dons> or you can put in bang patterns by hand.
14:56:49 <dons> for 'sol' in this case.
14:56:53 <Cale> selmanj: The compiler can determine when some parameters will always eventually need to be evaluated, and do it sooner so as not to build expressions.
14:57:01 <dmhouse> ndmitchell: even as a Windows user you should install Cygwin and get used to find and grep ;)
14:57:06 <Cale> (which use lots of memory and possibly overflow the stack later on)
14:57:29 <b\6> s <- hGetContents h and then (parse yo "" s). doomed to failure for some laziness reason? seems like nothing is happening.
14:57:55 <dmhouse> What are you doing with the output of parse?
14:57:57 <selmanj> Cale: That's pretty neat.  Is it usually pretty accurate?
14:58:01 <dons> selmanj: in this code, you use a and k strictly (you have to compute and compare them, to branch and recurse), but sol just builds up.
14:58:10 <selmanj> or should I be paranoid and always use explicit bang patterns?
14:58:10 <dons> selmanj: yeah. it's pretty accurate.
14:58:22 <Cale> But it can be a bit conservative.
14:58:33 <dons> well, it doesn't hurt to be precise when using tail recursion, about which fields should be strict,
14:58:36 <dons> if it's not obvious.
14:58:45 <dons> solve202' k a !sol
14:58:48 <dons> for example.
14:58:49 <selmanj> how do i know what's obvious to the compiler? :)
14:59:00 <ddarius> It is necessarily incomplete.
14:59:05 <dons> you look at how your data is demanded.
14:59:06 <MyCatVerbs> selmanj: if you care enough to need to be sure, ghc-core.
14:59:09 <dons> solve202' k a !sol | a <= (k+3) `div` 4 =
14:59:10 <dons>   ...
14:59:21 <dons> a and k have to be computed to work out what step to take next
14:59:22 <dons> so they're fine.
14:59:26 <selmanj> ahhh right
14:59:29 <dons> but sol just builds up each time around.
14:59:33 <dons> since you never look at it.
14:59:50 <TomMD> selmanj: If its obvious to you it is was probably obvious to SPJ ;-).  At any rate, I found that my excessive use of bang patterns in many packages was entirely unneeded.  I went back though and tested with the bangs removed with no performance or stack space changes.
15:00:07 <TomMD> * in most cases.
15:00:17 <ddarius> TomMD: You have more information than the compiler and aren't constrained to preserve semantics.
15:00:17 <Cale> I've been running that case of solve for a while now with added bang pattern, and it seems to be running in roughly constant space... it is taking lots of time though :)
15:00:27 <selmanj> so using an explicit ! forces strict evaluation on whatever argument?
15:00:31 <dons> yeah.
15:00:38 <selmanj> well that's easy
15:00:42 <MyCatVerbs> TomMD: hah! Last time I tried throwing random strictness annotations at a working program, it acquired at least one additional infinite loop. :)
15:00:42 <dons> so have you tried just compiling your code now?
15:00:44 <TomMD> ddarius: Sure, but I am just sharing my experience.  Of coarse, I was using bang patterns excessively.
15:00:57 <selmanj> Not yet, now I will though
15:00:58 <dons> selmanj: like in this example, http://hpaste.org/9790#a1
15:00:59 <TomMD> MyCatVerbs: I haven't been so unlucky.
15:01:02 <dons> it has the command line.
15:01:28 <dkirk> ndmitchell: try Options ExecCGI
15:01:29 <TomMD> MyCatVerbs: Misunderstood what you said.  I didn't throw random band patterns in - I removed excess ones from a working / performant system.
15:01:47 <dkirk> ndmitchell: see http://httpd.apache.org/docs/2.2/mod/core.html
15:02:02 <Cale> selmanj: btw, that indentation for if/then/else is a bit nonstandard :)
15:02:09 <Cale> selmanj: the usual thing is like:
15:02:11 <Cale> if foo
15:02:15 <Cale>    then bar
15:02:17 <Cale>    else quux
15:02:44 <selmanj> Cale: Thanks, I'll fix that.  I'm finding I really need to read other people's haskell code rather than write my own, since I miss stuff like that.
15:03:17 <trofi> http://hpaste.org/9791 - why it does not work ? (something with return and monad type)
15:03:24 <Cale> The way you wrote it works in most cases, but inside do-blocks it won't, since the else will be treated as on a separate line from the if.
15:03:42 * ddarius usually keeps the 'then' on the same line as the 'if' but still lines the 'else' directly under it.
15:04:44 <Cale> Yeah, that's fine too :)
15:05:23 <selmanj> dons: It compiled and I'm now timing it.  Thanks :)
15:06:14 <dons> selmanj: so yeah, there's a huge difference between interprted code (like python or matlab), and compiled native code (with optimisations) that ghc or gcc produce.
15:06:18 <dons> stick to the good stuff.
15:06:38 <dmhouse> Why isn't -O2 default?
15:06:47 <TomMD> It used to make some programs slower.
15:06:51 <selmanj> dons: That makes sense, I just didn't realize the performance difference was so huge.  Thanks
15:06:54 <Saizan> dmhouse: longer build time
15:07:24 <zeno_> why does sum use foldl instead of foldr (which i thought was faster)
15:07:28 <dmhouse> How much longer? For 30x increase in runtime, I don't care _that_ much.
15:07:49 <zeno_> 30x seriously?
15:07:51 <ddarius> zeno_: Read http://haskell.org/haskellwiki/Stack_overflow.
15:08:03 <zeno_> k thx
15:08:15 <ddarius> dmhouse: That's GHCi v. GHC -O2 not GHC -O0 v. GHC -O2
15:08:26 <seanl> does anybody know if it is possible to marshall tuples through FFI?
15:08:28 <dmhouse> ddarius: oh righ
15:08:29 <adekoba> is there any way to make ghc use lower amounts of ram when compiling? I'm trying to install a package and it hits swap every time on my machine (500mb).
15:08:57 <ddarius> adekoba: use -O0
15:09:10 <adekoba> ddarius: thanks, I'll try that.
15:09:21 <BMeph> Someone asked yesterday, but no one knew: is there some theorem that says that problems solvable in a strict-interp system are solvable in a lazy one?
15:09:22 <Saizan> which package?
15:09:41 <adekoba> Saizan: frag
15:09:41 <yitz> zeno_: but they're both wrong. it needs to be foldl'
15:09:55 <ddarius> BMeph: Your question is ill-defined and to the extent it is defined doesn't make sense.
15:10:03 <reilly> has anybody implemented R*trees in haskell?
15:10:14 <reilly> http://en.wikipedia.org/wiki/R*_tree
15:11:05 <wadcom> am I missing something, or there is no function in Data.Map that would insert a new (k, v) pair if there is no such key and fail otherwise?
15:11:56 <zeno_> BMeph: how about this problem: compute a value but never use it.  impossible with laziness?
15:12:53 <SamB_XP> zeno_: why would you want to ?
15:13:21 <zeno_> SamB_XP: wouldnt, but he asked for something a strict lang can do a lazy one cant...
15:13:25 <yitz> wadcom: insertLookupWithKey
15:18:33 <yitz> zeno_: Control.Excetion.evaluate
15:18:39 <yitz> zeno_: Control.Exception.evaluate
15:20:28 <yitz> zeno_: but it uses seq internally - so maybe that doesn't qualify
15:21:05 <selmanj> dons: So I'm still not sure why my original code didn't work.  (sol + 1) `seq` solve202' k a (sol + 1) will force sol to evaluate, right?  and a is part of the pattern matching so that's strict as well... and k doesn't change...
15:23:34 <MyCatVerbs> selmanj: not usually a good idea to put an expression on the left side of seq rather than an identifier.
15:24:05 <selmanj> MyCatVerbs: Why is that?  I guess its a bit more inefficient, but it's not wrong right?
15:25:00 <glguy> wadcom: alter?
15:26:35 <Trinithis> ahhh! hoogle's different now!
15:26:50 <ddarius> @hoogle a -> m a
15:26:51 <glguy> insertNew k v m = alter (Just . fromMaybe v) k m
15:27:16 <enso> wow, hoogle is different
15:27:29 <SamB_XP> selmanj: what good does it do that way?
15:27:53 <enso> that's my feeling
15:28:05 <enso> the +1 is useless, am I right?
15:28:35 <yitz> glguy: for that part you just need insertWith (flip const). The trick is that we need to be able to test afterwards whether or not we needed to insert.
15:28:43 <MyCatVerbs> selmanj: for one thing, seq only evaluates to the outermost constructor, so for many operations, that doesn't actually help.
15:30:21 <MyCatVerbs> selmanj: and the compiler really isn't good at common subexpression elimination at all.
15:30:39 <BMeph> Okay, how about: is there a theory that says "if a program (modulo definition) terminates when evaluated strictly, then it terminates when  that is evaluated lazily"?
15:30:40 <selmanj> MyCatVerbs: If seq was 1+(1+(1+... wouldn't it have to add all of them to make sure it's not bottom?
15:30:51 <selmanj> er, sol i mean
15:31:35 <MyCatVerbs> selmanj: should do, but don't assume that the strictness analysis is perfect.
15:31:55 <Saizan> BMeph: that's true for lambda calculus iirc
15:32:23 <selmanj> MyCatVerbs: So if I rewrote it as sol `seq` (solve202' k a (sol+1)) it would have worked?
15:32:47 <MyCatVerbs> selmanj: yes. Give it a go, even. ^^
15:33:13 <yitz> @bots
15:33:32 <yitz> iblechbot: help
15:33:42 <ddarius> MyCatVerbs: It's not that it isn't good at it, it is that it doesn't do it at all.
15:33:47 <MyCatVerbs> BMeph: depends. Does your language definition allow for the formulation of constraints on evaluation time? How about heap usage?
15:33:52 <MyCatVerbs> ddarius: it... what?
15:34:00 <MyCatVerbs> ddarius: serious?
15:34:05 <ddarius> Yes.
15:34:14 <MyCatVerbs> ddarius: bugger.
15:34:40 <selmanj> MyCatVerbs: So the (sol + 1) `seq` ... didn't work because it somehow knows it's not bottom without evaluating all of sol?
15:34:54 <yitz> MyCatVerbs: it doesn't do it because you don't always want that - it could be disastrous if it means memoizing something huge. no way for the compiler to decide.
15:34:55 <selmanj> MyCatVerbs: assuming in this case that sol is (1+(1+(1+(1+...
15:35:57 <MyCatVerbs> selmanj: mmmm. (sol + 1) `seq` ... didn't work because the compiler isn't clever enough to make it.
15:36:15 <hackage> Uploaded to hackage: yahoo-web-search 0.1
15:36:35 <BMeph> MyCatVerbs: Er, specifying constraints is allowed, and having different constraints on the strict and non-strict is permissible.
15:36:40 <selmanj> MyCatVerbs: note that I didn't compile it, but ran it within ghci
15:37:02 <MyCatVerbs> selmanj: oh. Heh. ghci effectively runs everything at optimization level -1. :)
15:37:13 <selmanj> damnit!
15:37:24 <MyCatVerbs> selmanj: no strictness, etc, analysis *at all*
15:37:29 <selmanj> ok so its my own stupidity then
15:37:46 <Twey> What's the default GHC optimisation level?
15:37:57 <dons> -Onot.
15:37:57 <MyCatVerbs> Twey: -O0, for compilation speed.
15:38:51 <MyCatVerbs> selmanj: no worries. Anyway, most Haskell performance discussion takes place under the assumption that everyone's using -O2 at least.
15:40:38 <MyCatVerbs> selmanj: ghci doesn't do any of the clever analyses that're possible when compiling big chunks at a time, and also runs bytecode rather than native.
15:41:37 <trofi> http://hpaste.org/9792 - how to make it readable?
15:42:30 <MyCatVerbs> trofi: bigger font, swap the writing system for Hangul so there won't be any pronunciation ambiguities. ;)
15:43:07 <trofi> i see
15:44:58 <seanl> hm... is it possible to marshall tuples through FFI?
15:45:11 <trofi> i don't understand why i need let s_p to make it compile
15:45:13 <MyCatVerbs> trofi: looks good to me, anyway. No need to have the "do" on the line where you nab sys_pkgs, but aside from that... I wouldn't worry, it looks civilised enough.
15:45:38 <dons> seanl: yeah, but you have to find an equivalent C type to marshal to
15:45:41 <MyCatVerbs> trofi: 'cuz (union [] sys_pkgs) is a pure value, not an IO foo.
15:45:57 <MyCatVerbs> trofi: by the way, why are you union'ing with []?
15:46:11 <seanl> dons: such as a struct?
15:46:26 <trofi> i think it is List.nub analugue
15:46:40 <MyCatVerbs> trofi: if you're after what it looks like you're after, it'd be clearer to use nub.
15:50:56 <MyCatVerbs> trofi: what does readPackageConf do if given an empty list?
15:50:57 <dons> seanl: yeah.
15:51:37 <trofi> MyCatVerbs: throw an exception
15:51:42 <MyCatVerbs> trofi: ah, bugger.
15:55:13 <MyCatVerbs> trofi: http://hpaste.org/9792#a1
15:57:09 <trofi> thanks, looks cleaner :]
15:58:17 <MyCatVerbs> trofi: only superficially. The only change worth making in there is to switch the union [] for nub.
15:58:54 <trofi> dons: how do you look at parsing ghc-pkg list for package.conf prefence instead of hardcoded @SYSLIB@/package.conf in hs-plugins?
15:58:55 <MyCatVerbs> trofi: (because that actually makes it clearer what's going on - everything else I touched in there was pointless. 'Cept the bit about kittens.)
16:06:18 <trofi> MyCatVerbs: reports an error http://hpaste.org/9792#a2
16:06:48 <trofi> it forced me place let s_p last time
16:07:00 <Corun> ToRA / mathew-_ . We've been working hard at our UROP: http://www.obfuscated.co.uk/stuff/coke.jpg
16:09:08 <b\6> can parsec run on a Handle? i thought i could parse hGetContents, but that's closing my socket, which is bad.
16:09:42 <MyCatVerbs> trofi: what's a PkgEnv?
16:10:13 <trofi> type PkgEnv  = FiniteMap PackageName PackageConfig
16:10:42 * MyCatVerbs blinks.
16:11:03 <MyCatVerbs> trofi: and yet you have union [] sys_pkgs?
16:11:19 <MyCatVerbs> trofi: how're you unioning a list with a map from names to configs? oO
16:12:14 <trofi> it was there for ages
16:12:35 <MyCatVerbs> Does the pre-screwing-around version compile?
16:13:19 <trofi> yes
16:14:26 * MyCatVerbs scratches his head.
16:14:49 <trofi> pkgEnvs - list
16:14:52 <trofi> pkgEnv - map
16:15:18 <trofi> problem in monad lifting return
16:15:19 <MyCatVerbs> union :: (Eq a) => [a] -> [a] -> [a], right?
16:15:34 <trofi> when we don't have let evil things occur
16:16:18 <Cale> gwern: any news?
16:16:47 <MyCatVerbs> Oh, dumb idea...
16:17:35 <eu-prleu-peupeu> hello people from planet haskell
16:17:43 <MyCatVerbs> trofi: http://hpaste.org/9792#a3 ?
16:19:14 <trofi> compiles cleanly :]
16:19:59 <MyCatVerbs> trofi: right. Replace fmap with (<$>) and try again, please?
16:20:31 <MyCatVerbs> trofi: I have a sneaky feeling some munchkin defined (<$>) as something other than fmap, just for giggles. :)
16:21:04 <trofi> works
16:21:13 <trofi> s_p <- {- fmap -} (<$>) (union []) (readPackageConf $ ghcLibraryPath </> sysPkgConf)
16:21:16 <trofi> all ok
16:21:59 <MyCatVerbs> trofi: gah. And replacing (union []) with (Data.List.nub)...?
16:22:33 <chrisdone> $ affects <$> in a suspicious way
16:22:47 <chrisdone> s_p <- nub <$> (readPackageConf $ ghcLibraryPath </> sysPkgConf)
16:23:10 <trofi> error
16:23:26 <MyCatVerbs> trofi: so what the Hell type does your union have?
16:24:06 <trofi> how to load file with preproc directives into ghci?
16:24:12 <chrisdone> I suspect nub <$> readPackageConf $ ghcLibraryPath </> sysPkgConf == (nub <$> readPackageConf) (ghcLibraryPath </> sysPkgConf)
16:24:20 <eu-prleu-peupeu> when i try to import a module from another one, i get this error in ghci: file name does not match module name `Main'  what does this mean !?
16:24:39 <chrisdone> eu-prleu-peupeu: the module name must be the same as the file name
16:24:40 <MyCatVerbs> chrisdone: yyyyyes, but note the use of parens to avoid precisely that issue.
16:24:58 <eu-prleu-peupeu> chrisdone: it is
16:25:00 <chrisdone> MyCatVerbs: I did note it
16:25:47 <MyCatVerbs> trofi: :set -cpp should work, I think.
16:26:07 <MyCatVerbs> trofi: or ghci -cpp Foo.hs, either way.
16:26:40 -ChanServ(ChanServ@services.)- glguy removed noohgodno*!*@* from the AKICK list.
16:26:42 -ChanServ(ChanServ@services.)- glguy removed noohgodno from the AKICK list.
16:26:48 -ChanServ(ChanServ@services.)- glguy removed *!*@c-71-192-179-132.hsd1.ma.comcast.net from the AKICK list.
16:27:22 <trofi> -cpp helped
16:27:31 <eu-prleu-peupeu> ok, i have fixed it, i had forgotten to put the module Name where... at the begining of the other file :)
16:27:51 --- mode: ChanServ set +o glguy
16:27:51 --- mode: glguy set -b noohgodno!*@*
16:27:58 --- mode: glguy set -d nhgdng
16:28:01 --- mode: ChanServ set -o glguy
16:28:26 <trofi> shit. there is union function
16:28:34 <trofi> :t union
16:28:35 <trofi> union :: PkgEnvs -> [PackageConfig] -> PkgEnvs
16:28:54 * dons wonders what trofi is doing.
16:29:14 <ptolomy2> O_o   I just added a simple event system to my interpreter, and I created a situation in which a event being waited for wouldn't happen.. ghc failed it with "thread blocked indefinitely".. I'm sure I'm missing something, but I'm spooked that it knew, considering the indirection involved.
16:29:34 <trofi> dons: do you use cabal install --user? :]
16:29:41 <yitz> @bots
16:30:04 <dons> trofi: --user is the default, right?
16:30:10 <trofi> seems to
16:30:18 <dcoutts> yep, it is
16:30:54 <dcoutts> the point is that "cabal install foo" should just do the right thing.
16:31:11 <trofi> so, let's try install oeis in --user
16:31:58 <trofi> and try to run with hs-plugins suct plug: http://hpaste.org/9794
16:32:14 <trofi> Main: a/Extra.o: unknown symbol `__stginit_oeiszm0zi2_MathziOEIS_'
16:32:15 <trofi> Main: user error (resolvedObjs failed.)
16:32:17 <trofi> BOOM
16:32:35 * ptolomy2 continues to scratch his head.
16:32:47 <trofi> dons: see?
16:33:12 <gwern> Cale: well, so far I've fixed the defaulting issue in lambdabot, and I've added all the default imports of lambdabot to mueval; but while I have written --noimports, it doesn't seem to work
16:33:21 <Cale> hmm...
16:33:22 <sjanssen> ptolomy2: what was it blocking on, an MVar?
16:33:28 <gwern> so currently the odder uses of (.) and such will continue to break
16:33:36 <gwern> caleskell still = errors
16:33:57 <sjanssen> gwern: could you just change L.hs so the normal (.) will work?
16:34:04 <Cale> Yeah, we could do that.
16:34:12 <gwern> sjanssen: I could, but Cale has said he didn't like that approach
16:34:15 <sjanssen> whether it's permanent or not -- (.) is really important
16:34:36 <gwern> well, alright. it's very simple to just remove those definitions
16:34:37 <idnar> uhm
16:34:43 <Twey> What's that?  (.) not permanent?
16:34:44 <MyCatVerbs> trofi: oO at your definition of union. :P
16:34:46 <idnar> so, is HaskellDB still alive?
16:34:47 <Cale> So... do you get all the other imports?
16:34:50 <gwern> although, Cale, I've been wondering - what are those type declarations in L.hs?
16:35:07 <Cale> (Like, when --noimports is active, do you see the imports from, say, Control.Monad ?)
16:35:11 <gwern> Cale: not the qualified ones. qualified imports simply can't be done in the GHC API right now, it seems
16:35:17 <Cale> hmm
16:35:50 <gwern> me and the hint guy are going to file a request - since that would allow GHCi to have qualified imports
16:35:56 <gwern> which would be useful for ghci
16:35:59 <gwern> you have to admit
16:36:04 <Cale> yeah
16:36:27 <Cale> In fact, I run into that problem regularly :)
16:36:30 <gwern> Cale: but I'm not sure I've ever seen anyone use qualified stuff in lambdabot, so kind of like smallcheck - occasionally someone will use it, but it's not really worth worrying over
16:36:45 <sjanssen> what?! We're losing smallcheck?
16:37:06 <gwern> sjanssen: no, smallcheck just has a small glitch
16:37:07 <gwern> otherwise it works
16:37:13 <sjanssen> gwern: what's the glitch?
16:37:31 * stepcut was unaware that utf8-string was heavy weight enough to warrent an utf8-light
16:37:54 <gwern> sjanssen: well, the funny thing is that both true and false stuff have the same first line - "()", but popen, which is the function lambdabot uses to run everytyhing, apparently only grabs the first line
16:38:16 <gwern> so it goes @scheck True == "(); @scheck False == "()"
16:38:33 <gwern> the *rest* of the output shows you what happens, but lambdabot doesn't grab the rest of the output :)
16:38:55 <sjanssen> gwern: probably part of it goes to stderr, part of it goes to stdout
16:39:02 <ddarius> Clearly we all need to switch to PowerShell
16:39:15 * Twey laughs.
16:39:40 <gwern> sjanssen: yeah, I'm not clear on whether the problem is in smallcheck itself, show, mueval, lambdabot-utils, or lambdabot. I am reasonably sure the problem is in lambdabot-utils
16:39:46 <gwern> fortunately, @check works fine
16:40:01 <gwern> Cale: the annoying thing is that --noimports is *almost* right
16:40:09 <gwern>  ie: gwern@craft:17753~/bin/mubot/mueval>mueval --noimports -e 'filterM (const [False,True]) [1,2,3]'                      [ 7:38PM]
16:40:12 <gwern>  mueval: Expression did not compile.
16:40:15 <gwern> gwern@craft:17754~/bin/mubot/mueval>mueval -e 'filterM (const [False,True]) [1,2,3]'                                  [ 7:39PM]
16:40:18 <gwern> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:40:45 <Cale> gwern: What about in conjunction with -L ?
16:41:10 <gwern> errors, even when using an operator which is right
16:41:26 <Cale> (like, on the same expression?)
16:41:27 <gwern> I have suspicions that the issue is subtle details of module loading and scope evaluation
16:42:21 <Cale> For the time being, I'm going to see about reverting my local repo so that everything sort of at least works for now :)
16:42:55 <gwern> Cale: well, if you want to
16:43:06 <gwern> I'm still going to remove the redefinitions tho
16:43:15 <chrisdone> :t <*>
16:43:35 <gwern> Cale: but what do you mean about in conjunction with -l?
16:43:37 <gwern> gwern@craft:17758~/bin/mubot/mueval>mueval -l ~/bin/lambdabot/State/L.hs -e 'filterM (const [False,True]) [1,2,3]'    [ 7:43PM]
16:43:40 <gwern> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:43:43 <gwern> ?
16:43:51 <Cale> Well, -l and -noimports
16:44:56 <gwern> that's the issue, --noimports breaks evaluation even if you --loadfile something which itself imports Prelude and necessary functions
16:45:11 <trofi> *sigh* dons: http://hpaste.org/9795
16:45:53 <Cale> gwern: right, okay
16:46:04 <Trinithis> Are IORefs just like MVars, but for single threads?
16:46:26 <Cale> Trinithis: more or less
16:46:29 <gwern> hs-plugins, ew
16:46:32 <Trinithis> ok
16:46:33 <Cale> Trinithis: also, no blocking semantics
16:46:48 <Cale> Trinithis: and they can't be empty
16:47:03 <sjanssen> gwern: does -e '()' --noimports work?
16:48:08 <gwern> yes
16:48:08 <gwern> gwern@craft:17759~/bin/mubot/mueval>mueval -e '()' --noimports                                                        [ 7:43PM]
16:48:09 <gwern> ()
16:48:09 <gwern> hm. that'd be a good test
16:48:20 <Trinithis> Cale: Kind of like introducing a multiple states into an IO monad without a StateT?
16:48:49 <Cale> Trinithis: yeah, and you need the IORef values to access them.
16:48:58 <Trinithis> alright
16:52:52 <Trinithis> Does the ST monad operate on a principle similar to using IORefs in IO?
16:53:29 <Saizan_> Trinithis: yes
16:53:33 <Trinithis> kk
16:55:55 <Trinithis> out of curiosity, why are aren't ST and STRefs in the same module?
16:56:14 <TSC> Same reason as for IO and IORef, I suppose (:
16:56:33 <trofi> how to get effect, similar to popen(3) or var a=`cmd`? something with  String{- cmd -} -> IO String {- stdout -}
16:56:41 <Trinithis> But you can use IO without IORefs. Can you use ST without STRefs?
16:57:25 <Saizan_> ?type system
16:57:37 <TSC> I think you can use ST arrays without STRefs
16:58:08 <Saizan_> trofi: look at System.Cmd
16:58:16 <bd_> You can certainly use ST without STrefs. Either with ST arrays, or just for pure computations.
16:58:20 <Saizan_> or .Process
16:58:48 <ptolomy2> Hm. What causes the GHC runtime to say "thread blocked indefinately"?
16:59:23 <Trinithis> Guess I'll have to read more about them. Time for Google.
17:00:55 <sjanssen> ptolomy2: it can happen when a thread is blocked on an MVar that no other thread can access
17:01:23 <ptolomy2> ahh.
17:01:43 <ptolomy2> clever runtime.
17:02:06 <sjanssen> it can happen with STM too
17:04:13 <trofi> Saizan_: thanks, System.Process.runInteractiveCommand looks almost OK
17:06:43 <gwern> Cale: did you fix the State/fact issue yet?
17:09:07 <zookofamilytime> folks: cabal-install seems to have a bootstrapping problem in the docs.
17:09:22 <zookofamilytime> All the docs seem to assume that either (a) I already have cabal and/or cabal-install already installed, or (b) I'm a Haskell expert.
17:09:28 <zookofamilytime> Currently neither is the case.
17:09:41 <zookofamilytime> But I'd like to install a Haskell package, and cabal-install seems like the best way to do it.
17:09:47 <Saizan_> zookofamilytime: you've the Cabal library installed with ghc
17:09:48 <zookofamilytime> With which document should I start?
17:10:10 <eu-prleu-peupeu> is there any kind of "doxygen" but for haskell ?
17:10:14 <dcoutts> zookofamilytime: the README for Cabal is a good start
17:10:18 <dcoutts> eu-prleu-peupeu: haddock
17:10:23 <eu-prleu-peupeu> thanks dcoutts
17:26:00 <newpers> http://hpaste.org/9796
17:26:30 <newpers> if anyone wants to take a crack at tha
17:26:31 <newpers> t
17:26:38 <zookofamilytime> Hm.  It kind of looks like Cabal doesn't come with ghc on Ubuntu Hardy and also can't be installed.
17:26:50 <zookofamilytime> I'm thinking of giving up on this project for now.  :-(
17:26:52 <dcoutts> zookofamilytime: it's on hackage
17:27:04 <stepcut`> zookofamilytime: I use cabal on hardy everyday...
17:27:22 <dcoutts> zookofamilytime: you already have a version of the Cabal lib installed already. It comes with ghc.
17:27:40 <dcoutts> zookofamilytime: if you're trying to install cabal-install then it and it's three dependencies are all on hackage.
17:27:52 <zookofamilytime> Here's how far I got:
17:27:55 <dcoutts> each one is an ordinary Cabal package that can be built in the ordinary way
17:27:58 <zookofamilytime> 1.  Googled for "hackage"
17:28:17 <Saizan_> hackage.haskell.org
17:28:30 <zookofamilytime> 2.  Read a few docs, followed a few links, got confused, asked on IRC where to start.
17:28:39 <dcoutts> zookofamilytime: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package  (which is top link from haskell.org/cabal)
17:28:45 <zookofamilytime> 3.  Found the Cabal docs, per dcoutts's advice.
17:29:00 <zookofamilytime> file:///usr/share/doc/ghc6-doc/Cabal/builders.html
17:29:15 <trofi> how does `ghc-pkg list' command look in windows?
17:29:19 <zookofamilytime> 4.  Downloaded cabal-install-0.5.1.tar.gz
17:29:26 <Zao> trofi: Just about the same, different paths.
17:29:41 <zookofamilytime> 5.  untarred it and started following the instructions from builders.html: runhaskell ./Setup.hs configure --ghc
17:29:55 <dcoutts> zookofamilytime: and it told you it needed Cabal-1.4 and HTTP and zlib
17:29:59 <zookofamilytime> It said: Setup.hs: At least the following dependencies are missing:
17:29:59 <zookofamilytime>     Cabal >=1.4&&<1.5, network >=1&&<3, HTTP >=3000&&<3002, zlib >=0.4
17:30:15 <zookofamilytime> $ apt-cache search ghc | grep cabal
17:30:15 <zookofamilytime> libghc6-cabal-dev - Haskell Common Architecture for Building Applications and Libraries
17:30:25 <zong_sharo> hi
17:30:34 <zong_sharo> i'm trying understand this article
17:30:35 <zong_sharo> http://community.livejournal.com/evan_tech/250400.html
17:30:37 <zookofamilytime> $ sudo apt-get install libghc6-cabal-dev
17:30:43 <Zao> trofi: http://haskell.pastebin.com/m423f6c8f
17:30:48 <zookofamilytime> The following packages have unmet dependencies:
17:30:48 <zookofamilytime>   libghc6-cabal-dev: Depends: ghc6 (< 6.6.1+) but 6.8.2-2ubuntu1 is to be installed
17:30:48 <zookofamilytime> E: Broken packages
17:30:55 <dcoutts> zookofamilytime: they're all on hackage. Though the zlib and HTTP packages might already be in debian.
17:30:55 <zong_sharo> there is some function composition
17:31:10 <zookofamilytime> It says I should report this as a bug against libghc6-cabal-dev.
17:31:11 <Zao> trofi: I haven't been bothered using --user as I run as admin, otherwise it'd have the usual global/user conf split.
17:31:15 <zong_sharo> but, operands has more than one argument
17:31:29 <dcoutts> zookofamilytime: as I said, you've already got Cabal, it's just you need a later version, a version that's not in debian yet but it is on hackage.
17:31:49 <gwern> zookofamilytime: I remember looking into that and filing a bug report; IMO, that package is reidiculously outdated
17:31:59 <gwern> but I'm not sure, my ubuntu bug report never got looked at AFAIK
17:32:01 <dcoutts> zookofamilytime: we don't need libghc6-cabal-dev
17:32:06 <zong_sharo> i think, i dont understand how function composition work, if arguments has more than one argument
17:32:28 <gwern> dcoutts: I have a question - if a package specified cabal: >=1.4, will cabal-install upgrade cabal if necessary?
17:32:34 <Peaker> zong_sharo: all functions always have just one argument - they simply return new functions that have arguments
17:32:41 <zong_sharo> Peaker: yep
17:32:44 <dcoutts> gwern: no.
17:32:50 <trofi> Zao: thanks
17:32:57 <zookofamilytime> Okay, added a comment to this bug: https://bugs.launchpad.net/ubuntu/+source/haskell-cabal/+bug/231099
17:33:03 <gwern> dcoutts: oh. hm.
17:33:11 <zong_sharo> Peaker: i know, but i can't figure out whole picture
17:33:15 <dcoutts> gwern: just like we don't follow build-tools yet
17:33:18 <zookofamilytime> Okay, so the next step to using Cabal is to, um, install Cabal?  I'm confused.
17:33:32 <gwern> dcoutts: so what will happen then if someone tries to cabal-install ghc-paths, but doesn't have 1.4 or 1.5?
17:33:34 <dcoutts> zookofamilytime: yep, that's right. Cabal is just another ordinary Cabal package.
17:33:40 <gwern> will it just error on Setup.hs?
17:33:43 <dcoutts> gwern: yep
17:33:51 <gwern> hum. that's too bad
17:34:02 <zong_sharo> Peaker: http://hpaste.org/9797
17:34:08 <dcoutts> gwern: no, actually it'll fail with a message that the version is needed but not available. Probably. :-)
17:34:22 <zong_sharo> Peaker: can you explain to me, how it works?
17:34:56 <zookofamilytime> Okay, just so you know, I had too high of expectations about this.  I had thought that cabal-install was sort of like Python's easy_install, so I expected to 1. install cabal-install, and 2. run "cabal-install maybench".
17:35:11 <zookofamilytime> Apparently 1. requires 0. install Cabal, even though I already have -1. Cabal comes with GHC.
17:35:15 <dcoutts> zookofamilytime: yes, that's how it works one cabal install is installed.
17:35:23 <zookofamilytime> Okay.  Thanks!  :-)
17:35:29 <dcoutts> zookofamilytime: the first release of the Haskell Platform will bundle it
17:35:35 <zookofamilytime> Cool!  That sounds good.
17:35:48 <zookofamilytime> Also if the version in Ubuntu worked that would be cool too.
17:35:49 * gwern does $ cabal install maybench
17:35:53 <gwern> truly, the promised land
17:36:07 <dcoutts> zookofamilytime: it's currently a bit hard to bootstrap, which in a way is a bonus as we only get testers who know how report bugs :-)
17:36:12 <Zao> trofi: The per-user conf seems to end up in C:\Users\lars.viklund\AppData\Roaming\ghc\i386-mingw32-6.8.3\package.conf: for me.
17:36:27 <trofi> great
17:36:28 <dcoutts> zookofamilytime: so it gets improved before we get too many complaints from the general masses
17:36:49 <gwern> darn masses
17:37:02 * Saizan_ wonders what people that complain about installing 4 packages by hand would have said one year ago when cabal-install didn't exist
17:37:05 <Zao> trofi: Libraries seem to install by default into C:\Program Files (x86)\Haskell
17:37:14 <Zao> Saizan_: I mostly install by hand.
17:37:15 <dcoutts> Saizan_: yeah, quite.
17:37:53 <zookofamilytime> Hm, looks like there is another Haskell benchmarking tool: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/benchpress
17:37:58 <zookofamilytime> (discovered with the hackage Whatsnew)
17:39:02 <trofi> Zao: can paste output of this program? http://hpaste.org/9798
17:42:20 <stepcut`> newpers: I updated your hpaste which a snippet of code I wrote that does something similar, hopefully you can make some sense out of it
17:42:43 <newpers> :) great
17:42:45 <newpers>  thanks
17:47:16 <gwern> what does the GHC -static flag do, since haskell libs are static anyway?
17:47:58 <Peaker> zong_sharo: I annotated your paste
17:48:13 <Peaker> zong_sharo: btw: It was good a educational chore for me, I never worked through the type inference manually before :)
17:48:31 <Peaker> now I know better what the compiler is doing :)
17:50:05 <Peaker> say, if we write a compiler that can parse software patents and execute them - can we sue the patent office for offering patented software?
17:51:27 <zong_sharo> Peaker: i can't figure out, how lit "a" . int becomes something with type (String -> a) -> String -> Int -> a
17:51:37 <Peaker> @type (.)
17:51:45 <zong_sharo> yep
17:51:54 <zong_sharo> (.) :: (b -> c) -> (a -> b) -> a -> c
17:52:08 <zong_sharo> still can't
17:52:19 <Peaker> zong_sharo: well, a . b   takes the input type of b and the the output type of a (verifying that the output of b matches the input of a)
17:52:44 <Peaker> lit "a" :: (String -> a) -> (String -> a)
17:52:48 <zong_sharo> i know, i read yaht and some other tutorials
17:52:54 <Peaker> int :: (String -> a) -> (String -> Int -> a)
17:52:59 <zong_sharo> maybe i missed something?
17:53:37 <zong_sharo> Peaker: ouch
17:54:01 <zong_sharo> Peaker: parentheses makes it's more clear
17:54:03 <zong_sharo> thx
17:54:33 <Peaker> zong_sharo: so its all clear now?
17:56:29 <ddarius> Yoneda suggests that int is a precomposition by a function (String, Int) -> String
17:57:27 <Peaker> I think (>>>) may be less confusing than (.)
17:57:48 <chrisdone> I find that I use >>> and . in the same expression sometimes
17:58:18 <Peaker> I think Haskell should have a convention, right-to-left or left-to-right, can't have both.  Maybe application should be arg-first :)
17:58:35 <ddarius> I think Haskell isn't Python.
17:58:40 <chrisdone> setting = (lojbotSettings >>>) >>> gets
17:58:47 <Peaker> ddarius: I do miss that in Haskell
17:59:30 <zong_sharo> Peaker: thx
18:00:01 <Peaker> BeelsebobWork__: hey, is there any significant example written with Reactive?  Something in the order of "space invaders" game, or something complicated enough to demonstrate advanced concepts?
18:00:35 <zong_sharo> not perfectly clear
18:00:40 <Saizan_> composition is right-to-left precisely because arguments are on the right side, f (g x) has the functions in the same order as f . g
18:00:59 <zong_sharo> anyway, thx
18:01:25 <Peaker> Saizan_: yeah, I know, but everyone else who does points-free (e.g unix pipes) seems to choose left-to-right, and people read english left-to-right, so I think maybe it would make sense to reverse it (and arg order too, to keep them in sync)
18:01:31 <Peaker> zong_sharo: what's not clear?
18:02:04 <zong_sharo> i think, i can handle rest of it
18:02:42 <zong_sharo> in fact, it be a good educetional chore for me
18:02:44 <zong_sharo> :)
18:02:57 <Peaker> so Haskell will look a bit like Forth, so what? :)
18:02:58 <Peaker> 4 5 (+)
18:03:06 <gwern> Cale: well, I've finished removing the redefinitions
18:03:11 <gwern> Cale: it works now again
18:03:20 <gwern> gwern@craft:17767~>mueval --noimports -l bin/lambdabot/State/L.hs -e '(+1) . (*2) $ 10'                               [ 9:02PM]
18:03:23 <gwern> 21
18:03:52 <gwern> preflex: seen Cale
18:03:53 <preflex>  Cale was last seen on #haskell 1 hour, 15 minutes and 3 seconds ago, saying: Trinithis: yeah, and you need the IORef values to access them.
18:03:58 <Peaker> what kind of a file name is L.hs? :-)
18:04:06 <gwern> Peaker: a temporary one
18:04:08 <reilly> >>= and >> work left to right
18:04:17 <EvilTerran> it's the file that @let goes into
18:04:32 <Peaker> reilly: yeah, most of Haskell is left-to-right, except (.)
18:04:35 <Draconx> you can keep a left to right interpretation of function composition by reading the . as "after".  For example, read (f . g) as "f after g"
18:04:35 <EvilTerran> reilly, =<< goes right to left :P
18:04:41 <reilly> yes
18:04:59 <trofi> haskell doesn't allow cycles in imported modules?
18:05:02 <gwern> I hope hasjell.org updates to darcs-2 soon. these ssh things are getting on my nerves
18:05:05 <EvilTerran> Draconx, yes, but the information flow is right to left
18:05:21 <heatsink> trofi: Not in GHC, unless you explicitly resolve cyclic dependences with an hs-boot file.
18:05:47 <heatsink> trofi: The H98 standard allows cycles, but I think all real compilers have limitations there.
18:06:08 <trofi> it's very inconvinient :\
18:08:02 <heatsink> Can you get rid of the cycles by reorganizing?
18:08:46 <trofi> i think, yes
18:09:54 <Igloo> gwern: Do you mean code.haskell.org?
18:10:05 <gwern> yeah
18:10:15 <Igloo> It's installed as darcs2, if that helps
18:10:39 <Igloo> Or you can change your path to make it darcs if you want
18:10:40 <gwern> I'm not familiar with the details, but apparently darcs-2 repos have faster pulls and pushs, along with the get optimizations
18:13:41 <thoughtpolice> wow, new haskell.org/hoogle is much much better :)
18:16:01 <gwern> yeah, ndm put a lot of work into hoogle 4
18:16:18 <Peaker> wow, indeed awesome results for searches that previously yielded very stupid ones :)
18:17:48 <gwern> yeesh. I'm done here
18:18:44 <gwern> Cale: I've made numerous other modifications and stuff. make sure to use the latest darcs of mueval, show, and lambdabot. I think we can put it back on #haskell
18:19:02 <gwern> nap time
18:21:27 <heatsink> > do Nothing
18:29:49 <dons> thoughtpolice: looks like hayoo and hoogle are in a death fight
18:29:59 <dons> it looks great, good work ndm
18:30:50 <trofi> dons: please have a look at http://hpaste.org/9800
18:31:08 <dons> so that hunts for package.confs in the user system?
18:31:21 <trofi> yep
18:31:25 <trofi> seem to work
18:31:41 <dons> yeah, cool1
18:31:55 <chrisdone> dons: hehe, yeah. hoogle gets my vote due to lacking crazy-ass ajax
18:32:06 <dons> heh
18:32:51 <dons> hey guys, i have a draft post about hackage, 500 native packages in Arch Linux, and a survey of 10 cool hackage packages, http://www.galois.com/~dons/tmp/markup.txt
18:32:56 <dons> just a draft, so i'm happy for feedback.
18:32:59 <dons> i'll post it tomorrow.
18:33:47 <dons> oh, the links are missing in the .txt
18:34:31 <chrisdone> I don't use arch linux but the post is still interesting anyway
18:34:54 <dons> yeah, it's not so much about arch, but about automating native packages from hackage.
18:35:00 <dons> maybe i should emphasise that early
18:36:17 <hackage> Uploaded to hackage: mueval 0.6.2
18:36:20 <trofi> i'd like to see things to polish in #9800 in annotations if you are interested in this patch.
18:36:35 <dons> trofi: yeah, definitely interested.
18:36:42 <dons> do you know where the head branch of hs-plugins lives?
18:36:55 <trofi> yes
18:37:00 <trofi> patch is built against it
18:39:42 <Twey> What is the 'io' function?  It's kind of hard to search for
18:39:49 <chrisdone> io = liftIO
18:39:57 <Twey> Oh, heh
18:40:08 <Twey> Oh, yes
18:40:11 <Twey> It's defined here, silly me
18:40:29 <Twey> chrisdone: What's wrong with just calling it liftIO?  :-P
18:40:31 <chrisdone> I seem to define it in pretty much every project
18:41:12 <chrisdone> I think it is nicer than liftIO because it occurs quite often, it's shorter and has just as much meaning (apart from instances like this)
18:41:26 <dons> Twey: io is fun :)
18:41:38 <Twey> 'liftIO' isn't exactly the longest name in the world
18:41:53 <Twey> It's not like it's called applyFunctionInContextOfIO :-P
18:42:58 <lispy> applyFunctionInContextOfIOSafelyButPossiblyThrowingAnException
18:43:04 <chrisdone> Ex
18:43:09 * Twey laughs.
18:44:30 <chrisdone> have you λb guys ever considered making λb run as one process which maintains the connection to the server, and plugins connect to it via IP sockets? it has the advantage of being easy to plug/unplug (recompile) plugins, plugins can be on other platforms/computers and when one plugin does something bad (memory leaks, guys?) only one crashes in isolation and at least you know which one is borked
18:44:35 <Twey> http://thedailywtf.com/Articles/Overruled-by-RemoveSpecialCharsExceptQuoteAmpersand.aspx
18:44:40 <Twey> Heheheh
18:45:22 <Twey> public static string RemoveSpecialCharsExceptQuoteAmpersandApostropheOpenBracketCloseBracketCommaHyphenFullStopCommaForwardSlash(string p_string)
18:47:12 <chrisdone> CreateWindowRemoveSpecialCharsExceptQuoteAmpersandApostropheOpenBracketCloseBracketCommaHyphenFullStopCommaForwardSlashEx(NULL,NULL,NULL,0,"not used");
18:47:52 <chrisdone> sorry. #define LPSTRNOTUSED "not used"
18:49:03 <lispy> ?bot
18:49:15 <lispy> why did lambdabot die?
18:49:38 <chrisdone> because it's not implemented in the way I describe :P
18:50:15 <Twey> Heheh
18:50:31 <TSC> @index mconcat
18:50:38 <TSC> Bah
18:50:47 <Cale> lispy: Because we tried to undergo some upgrades that weren't working so well.
18:50:51 <chrisdone> TSC: lambdabot is not here, try another castle
18:51:04 <Zao> chrisdone: I've checked all 16. Are you sure?
18:51:34 <chrisdone> Zao: am I sure about what?
18:52:26 <lispy> Cale: ah, that is unfortunate
18:52:53 <lispy> Cale: may haps we need a production lambdabot and an experimental one?
18:53:13 <SamB_XP> what does lambdabot produce?
18:53:17 <SamB_XP> sugar lambdas?
18:53:41 <Pseudonym> It makes theorems for free.
18:55:33 <sereven> dons: yes, emphasize 'beyond Arch is already underway' early on. If similar work is going for other debstro, umm.. *distros it'd be nice to read about early in the article, (at least if it's appropriate distro-relations-wise. Oh, you do mention cabal-debian later.) Great breadth on the 10 pkgs. what do you sleep 10hrs/wk?
18:55:51 <SamB_XP> ... only with each purchase of a parametricly polymorphic type ...
18:56:13 <thoughtpolice> dons: yes, it's much better. now if hoogle can just harvest the docs on hackage, that would be super-ness. :)
18:56:30 <Pseudonym> It can also make those with :t
18:56:48 <Pseudonym> And if you don't have code, it can make that with @dkinn.
18:56:50 <Pseudonym> dkinn
18:56:53 <Pseudonym> Turtles all the way down.
18:56:59 <chrisdone> haha
18:57:03 <Pseudonym> sjinn, I meant
18:57:05 <Pseudonym> Aargh!
18:57:09 <Pseudonym> I karnt tipe!
18:57:18 <SamB_XP> djinns all the way down, isn't it?
18:57:27 <SamB_XP> (or do I mean all the way up?)
18:57:33 <Pseudonym> Well, there's GOD at the end...
18:57:33 <SamB_XP> up to GOD
18:57:57 <Pseudonym> If Hofstadter had written that, it would have been much funnier.
18:58:30 <SamB_XP> but GOD is more-or-less the same as aleph in Surreal Numbers ...
18:59:06 <Cale> odd...
18:59:09 <Pseudonym> Omega in the ordinals.
18:59:12 <Cale> @type is now working, but :t isn't.
18:59:29 <SamB_XP> Cale: regex problem?
18:59:35 <dons> sereven: thanks, that's great feedback. i'll move the arch-specific stuff down.
19:00:30 <sereven> dons: yw, only one of >400, but I'm sure vixen would agree.
19:00:55 <SamB_XP> @vixen don't you think so too?
19:01:09 <SamB_XP> ?vixen don't you think so too?
19:01:17 <SamB_XP> where are all the \bots
19:01:25 <sereven> SamB_XP: she's passed out on the couch
19:01:43 <SamB_XP> aren't there hordes of them?
19:02:29 <chrisdone> look, a lojban bot
19:02:38 <Cale> Well, we can try this...
19:02:39 <Cale> :t map
19:02:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:02:49 <Cale> huh...
19:02:52 <SamB_XP> ?vixen don't you think so too?
19:02:56 <Cale> That doesn't work from the commandline version
19:02:58 <lambdabot> good question
19:03:01 <SamB_XP> ?vixen don't you think so too?
19:03:08 <lambdabot> good question
19:03:13 <SamB_XP> ?vixen eh?
19:03:18 <lambdabot> is that really what you want to know?
19:03:27 <chrisdone> @yow
19:03:32 <SamB_XP> ?vixen in a manner of speaking
19:03:32 <lambdabot> Couldn't find fortune file
19:03:38 <lambdabot> cool
19:03:41 <SamB_XP> Cale: major ouch!
19:03:46 <chrisdone> something something is GARBAGE BRAINED!
19:03:46 <SamB_XP> find the file!
19:03:55 <chrisdone> did anyone else get that message *every time*?
19:03:55 <SamB_XP> FIND THE FILE!
19:04:09 <Cale> SamB_XP: What file?
19:04:16 <SamB_XP> Cale: the @yow file
19:04:23 <SamB_XP> full of Zippyisms it must be
19:04:30 <dons> heh
19:04:30 <Cale> SamB_XP: I'm not even sure where that's supposed to be.
19:04:37 <Cale> Or where I get it.
19:04:37 <dons> that's in my home dir, Cale.
19:04:41 <dons> it's from *bsd.
19:04:43 <Cale> mm...
19:04:59 <SamB_XP> doesn't a full Emacs come with one too/
19:05:04 <SamB_XP> s|/|?|
19:05:05 <dons> though appears to have disappeared.
19:05:46 <chrisdone> http://img527.imageshack.us/img527/8835/1177432938513iw5.jpg “find the file!”
19:05:49 <Cale> Maybe if lispy installs fortune?
19:06:17 <SamB> hmm, M-x yow still doesn't work for me :-(
19:06:42 <Cale> > M.empty
19:06:45 <lambdabot>  mueval: Expression did not compile.
19:06:45 <lambdabot> mueval: Time limit exceeded
19:06:47 <Cale> hmm
19:06:56 <chrisdone> Cale: mine gives me “Yow!  Legally-imposed CULTURE-reduction is CABBAGE-BRAINED!”. same damn thing every time
19:07:08 <SamB> chrisdone: mine as well
19:07:54 <SamB> I think they are saying that having to remove the datafile of quotes just because of copyright law is really stupid
19:08:19 <SamB> (or possibly because it violates the GPL?)
19:12:04 <jberryman> is there a way to pattern match operators? e.g. opToStr (+) = "+"
19:12:11 <dons> no.
19:12:15 <dons> it's a cool idea though :)
19:13:53 <Cale> Well, (+) there will be a variable
19:13:58 <Cale> and will match anything
19:14:15 <Cale> You can pattern match against infix data constructors of course
19:14:34 <b\6> i award you the you know a lot and that's not what he meant gold medal
19:14:56 <jberryman> so it binds anything to '+'? redefining it?
19:15:00 <Cale> yeah
19:15:23 <Cale> > let f (+) x = x + x + x in f (*) 5
19:15:24 <lambdabot>  125
19:16:20 <jberryman> with a little recursion, that could make for some seriously obfuscated code ;)
19:16:32 <SamB> here is the old version of yow.lines: http://cvs.savannah.gnu.org/viewvc/emacs/emacs/etc/yow.lines?revision=1.10&view=markup
19:16:38 <Pseudonym> Strangely, nobody has entered that in the IOHCC yet.
19:16:43 <SamB> download from http://cvs.savannah.gnu.org/viewvc/*checkout*/emacs/emacs/etc/yow.lines?revision=1.10
19:16:45 <lambdabot> Title: [sources] View of /emacs/emacs/etc/yow.lines, http://tinyurl.com/627swb
19:16:49 <lambdabot> http://tinyurl.com/64tdke
19:17:05 <Cale> > let myFoldr (*) z [] = z; myFoldr (*) z (x:xs) = x * myFoldr (*) z xs in myFoldr (+) 0 [1..10]
19:17:06 <lambdabot>  55
19:18:46 <SamB> Cale: there's a file for you!
19:20:48 <SamB> @yow
19:20:48 <lambdabot> Couldn't find fortune file
19:20:59 <SamB> Cale: you don't seem to have installed it!
19:21:49 <SamB> hmm, fortune still uses that db afaict
19:22:29 <SamB> naesten@hydrogen:~/hacking/haskell/ghc% fortune zippy
19:22:29 <SamB> Content:  80% POLYESTER, 20% DACRONi ... The waitress's UNIFORM sheds
19:22:29 <SamB> TARTAR SAUCE like an 8" by 10" GLOSSY ...
19:22:29 <SamB> naesten@hydrogen:~/hacking/haskell/ghc% fortune zippy
19:22:29 <SamB> YOW!!  Up ahead!  It's a DONUT HUT!!
19:22:30 <SamB> naesten@hydrogen:~/hacking/haskell/ghc%
19:24:42 <SamB> hmm, but the fortune file is in a different format
19:25:57 <SamB> % dpkg -S /usr/share/games/fortunes/off/zippy
19:25:57 <SamB> fortunes-off: /usr/share/games/fortunes/off/zippy
19:27:40 <SamB> lispy: there ya go
19:28:19 <SamB> hmm, but copying that yow.lines over this lame one from upstream restores all the zippyisms ;-)
19:28:20 <Twey> Awww, crap
19:29:05 <Twey> I always forget to add --make to ghc
19:29:14 <Twey> And it always dismays me
19:30:24 <EvilTerran> ?yow?
19:30:24 <lambdabot> Couldn't find fortune file
19:31:18 <cjs> So it seems to me that, when you've got a largish library split up into several modules, many of which are used independently but share common types, to create a separate Foo.Types module that every other module exports fully.
19:31:25 <SamB_XP> EvilTerran: uh, I don't think he'll have it fixed for a while ;-)
19:31:51 <cjs> Has anybody done any blog entries or anything discussing good and/or typical ways to split up big libraries into modules?
19:31:58 <SamB_XP> cjs: you seem to be missing something like "it's a good idea" in there ...
19:32:24 <cjs> s/, to create/, it's a good idea &/
19:35:54 <jberryman> how does one go about using qualified types in a file with lots of type synonyms, specifically, I have a lot of Floats in synonyms which I would like to be Num a =>a.
19:36:17 <hackage> Uploaded to hackage: utf8-light 0.3
19:38:36 <mmorrow> gwern: mueval still doesn't work on my puter. it's on account of Resources not being functional on my distro (fedora)
19:38:56 <mmorrow> or at least, my particular copy of it
19:39:06 <mmorrow> (of fedora)
19:40:02 <mmorrow> bbl
19:48:48 <xor__> Hi, I have two haskell programs, http://pastebin.com/m41772c46 and http://pastebin.com/d75549ce1 , that do essentially the same thing. One of them is written with Strings, and the other with ByteStrings. I coded the ByteString version after the String version, hoping the ByteString version would be faster. It actually takes about 30s longer to complete than the regular String version. (3:30 vs 3:00) Does anyone know the reason why my Byte
19:48:48 <xor__> String'd program is slower?
19:50:06 <Cale> Probably something to do with sharing.
19:50:19 <bd_> xor__: Bytestrings aren't designed to have bytes concatenated and removed from the front
19:50:28 <bd_> ie, cons is an O(n) operation
19:50:34 <xor__> Oh..
19:50:38 <bd_> whereas String's (:) is O(1)
19:50:42 <xor__> OK.
19:50:54 <xor__> Thanks :)
19:51:24 <bd_> Using an STArray might be faster, but would require signifigant refactoring to put it into a monad
19:52:31 <zookofamilytime> Okay, cabal and cabal-install seem to be working.  Later.
19:52:40 <dons> xor__: yeah, each cons on a strict bytestring is copying the entire thing.
19:52:41 <Cale> Well, STArrays aren't designed to be consed either.
19:52:53 <dons> so for fast consing, you've got Sequence or lists
19:53:23 <dons> "won't somebody think of the complexity!?" :)
19:54:39 <bd_> Cale: I mean, using an STArray as a stack. You wouldn't cons it, just allocate it big enough to start with
19:55:05 <Cale> I'm not altogether sure I understand what this program is actually doing.
19:56:21 <bd_> why are tochar and friends using a nonstandard set of hex digits, I wonder
19:56:39 <bd_> xor__: btw, toint8 = fromIntegral . toint64 (or vice versa)
19:57:18 <xor__> I know, I figured that out after I wrote the fn I think.
19:58:03 <bd_> tochar = ((['1'..'9']++['A'..'F']++"b")!!) :)
19:58:33 <xor__> Oh rad. Thanks. I knew there had to be a better way!
19:58:41 <chrisdone> “foldr1 mplus” is the best thing since sliced bread
19:58:51 <ddarius> chrisdone: msum
19:58:53 <bd_> xor__: actually you could just do tonum :: Num n => Char -> n   as the type for those toint* functions, too
19:58:58 <chrisdone> msum is the best thing since sliced bread
19:58:59 <Cale> foldr mplus mzero = msum
19:59:00 <bd_> and it'll magically generalize
19:59:37 <chrisdone> thanks :P
19:59:55 <Cale> xor__: Is this an A* in disguise? :)
20:00:04 <xor__> Yes.
20:00:14 <xor__> It's not in disguise, it's just not documented very well :)
20:00:43 <ddarius> prologToHaskell = msum . map sequence
20:00:49 <Cale> I have a nice A* algorithm which is relatively implementation-independent on Hackage... it would be interesting to try it and see how it compares :)
20:01:05 <xor__> I'd be interested to see that actually.
20:01:13 <idnar> woo A*
20:01:39 <Cale> http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html -- here's the documentation (the docs on hackage are slightly broken)
20:01:41 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
20:02:17 <xor__> The search space is the 15 puzzle. h(x) = the sum of manhattan distances for each tile out of place
20:02:37 <Cale> Oh, I did this very problem not so long ago :)
20:04:39 <DavidDavid> I want to calculate particle physics, atom physics, molecular physics, haskell right?
20:04:55 <xor__> FORTRAN
20:05:03 <ddarius> ("123456789ABCDEFb"!!)
20:05:45 * Twey chuckles.
20:05:58 <SamB_XP> one of the two is probably appropriate, yes ;-P
20:06:05 <dons> DavidDavid: using an existing library?
20:06:14 <Twey> ddarius: What's the little b for?
20:06:50 <dons> DavidDavid: haskell's a general purpose language. you can model physics in haskell, or use haskell to script fast C or Fortran libraries that do the same.
20:07:45 <dons> i'd love to see some more physics libraries.
20:08:02 <Cale> Twey: it's what xor__ chose to represent the 'hole'
20:08:13 <Twey> Oh, I see
20:08:29 <Cale> I'm not really sure why that encoding :)
20:08:30 <ddarius> Encoding things into strings is the new wave.
20:08:41 <Twey> Heh
20:08:44 <dons> where it's at!
20:08:52 <Twey> Rad!
20:09:14 <Pseudonym> Oh, man.
20:09:31 <DavidDavid> n t next, I not only calculate particle physics, atom physics, molecular physics, construct real world object model, use number or vector? haskell
20:09:53 <Pseudonym> "Everything is a stream of bytes."
20:09:55 <Pseudonym> Very Unix.
20:10:09 <dons> DavidDavid: yeah, you could use vectors or matrices.
20:10:24 <chrisdone> connecting little processes together with streams of bytes
20:10:27 <chrisdone> like an irc bot
20:10:32 * chrisdone whistles
20:11:06 <Pseudonym> I can bring back lambdabot 0.01A if you like...
20:11:26 <ddarius> bash would make a decent language for writing a simple IRC bot.
20:11:28 <Cale> > 1 + 1
20:11:29 <lambdabot>  2
20:11:38 <Pseudonym> ddarius: With expect, presumably.
20:11:54 <ddarius> Or even a complex one for that matter.
20:11:54 <Pseudonym> there you go.
20:11:55 <Cale> I wrote an IRC bot in bash using netcat and a fifo.
20:11:58 <Pseudonym> @version
20:11:59 <lambdabot> lambdabot 4.2
20:11:59 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:12:27 <Cale> It was essentially all one long shell pipeline with a fifo tying the ends together
20:12:38 <dons> functional reactive bots forever!
20:13:23 * SamB_XP thinks bash is a lousy language for FRP
20:13:28 <Cale> Indeed it is.
20:13:44 * SamB_XP thinks this mostly because it has few facilities for MIMO systems
20:14:22 <ddarius> dons: There you go http://hpaste.org/8736#a1
20:14:29 * SamB_XP refers the interested reader to any decent signal-processing textbook for the definition of MIMO
20:14:45 * SamB_XP goes to bed
20:14:51 <ddarius> Who needs a reference for that?
20:15:01 <dons> hey, and that's not elliottt's one?
20:15:24 <dons> (he was working on one using the Reactive library)
20:16:55 <DavidDavid> plus automated reasoning
20:17:00 <Pseudonym> The original plan for lambdabot was to kind of do FRP, only using Concurrent.Channel.
20:17:12 <Pseudonym> Then I got bored.
20:17:23 <DavidDavid> use vector or matrices, a lot of development
20:20:32 <DavidDavid> from the ground, or there are someone had some development
20:25:25 <dons> DavidDavid: some libraries are here for matrices and vectors, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
20:25:31 <lambdabot> Title: HackageDB: hmatrix-0.4.0.0, http://tinyurl.com/58d3eb
20:25:39 <dons> and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas
20:25:40 <lambdabot> Title: HackageDB: blas-0.5
20:32:12 * sw17ch is writing some of the accompanying sample applications from PortAudio... but other than that, thinks he's done with the first version
20:33:05 <DavidDavid> used PC, PIII, PII, RAM 32 MB to 128 MB, slackware Linux, Linux cluster, how many time u think it take?
20:33:51 <ddarius> Someone is failing the Turing test.
20:34:24 <dons> yeah, that's not going to fly.
20:34:54 <DavidDavid> NASA has a cluster software
20:35:00 <sw17ch> was that a question, or a statement... or a description of the junk in the back of my garage
20:35:17 <dons> DavidDavid: do you have a specific question?
20:35:21 <DavidDavid> http://www.beowulf.org/
20:35:32 <lambdabot> Title: Beowulf.org: The Beowulf Cluster Site
20:35:34 <sw17ch> ...and?
20:35:37 <jeffz`> is it a bot?
20:35:55 <sw17ch> DavidDavid: are you a bot?
20:36:00 <dons> i don't think so. ESL.
20:36:01 <sw17ch> (bots never lie)
20:36:12 <DavidDavid> I'm not bot, s/w I want to build it's a big robot
20:36:52 <sw17ch> DavidDavid, what are you looking for from us?
20:37:04 <dons> how can we help?
20:37:19 <DavidDavid> design s/w on this beowulf cluster, deploy haskell applications
20:37:32 <sw17ch> yes, it can be done
20:38:04 <DavidDavid> h/w ready, beowulf s/w download, which development CASE
20:38:06 <sw17ch> DavidDavid: you'll probably want to use hMPI -> http://www.foldr.org/~michaelw/hmpi/
20:38:06 <dons> yeah, you can use haskell on a cluster. but there's a lot to learn first, I suspect.
20:38:11 <lambdabot> Title: hMPI - a Haskell binding for MPI
20:38:25 <dons> have you done any cluster programming, DavidDavid ?
20:39:32 <cjs> Hm. Is there any way to rename a data constructor?
20:39:42 <dibblego> cjs, newtype
20:39:53 <dibblego> cjs, or just write a function
20:40:12 <dons> cjs, that's an interesting question. what are you trying to do? distinguish it in the type checker? just alias the name?
20:40:20 <cjs> Just alias the name.
20:40:26 <dons> type Foo = Int
20:40:27 <dibblego> let just = Just
20:40:33 <cjs> So if I did a newtype, I'd just specify all the constructors as old ones?
20:40:48 <dons> oh, the data constructor, you only get to use functions.
20:41:01 <DavidDavid> I have to hire a programmer, how long t development will take?
20:41:03 <dons> as dibblego says.
20:41:10 <dibblego> I retract newtype, I was thinking something Scala-like
20:41:17 <dibblego> DavidDavid, 76 years
20:41:18 <sw17ch> DavidDavid, you'd need to give a lot more information than that
20:41:23 <ddarius> Scala has corrupted your mind.
20:41:42 <cjs> Basically, I have a module that uses GetOpt. And other users of this module pass in stuff built with the Option constructor, but I'd like them to say "CmdLineOpt ..." instead to avoid confusion between the command line OptDescs and the lists of parsed options produced by the parsing.
20:41:42 <dons> dibblego: is there 'newtype' in Scala?
20:42:07 <dibblego> dons, not really (there is equivalent of data but it is verbose)
20:42:07 <sw17ch> small MPI applications in C/C++ can be done in a day... large ones can take years, and cost a very large amount to maintain
20:42:18 <dibblego> sw17ch, DavidDavid is a bot
20:42:28 <dons> dibblego: too smart i think :)
20:42:47 <DavidDavid> I need to input physics equation in program
20:42:48 <sw17ch> dibblego, i'm starting to think that... but i figured a bot would be a little smarter...
20:43:01 <dons> DavidDavid: there's an entire field of high performance programming on a cluster.
20:43:09 <dons> it's unlikely you can do it by hanging out in an irc channel.
20:43:19 <dons> you'll need to do a lot of reading.
20:43:20 <sw17ch> ..and asking questions that aren't pointed at anything
20:43:25 --- mode: ChanServ set +o glguy
20:43:40 --- mode: glguy set +b DavidDavid!*@*!#haskell-ops
20:43:46 <sw17ch> merci beaucoup
20:43:47 --- kick: DavidDavid was kicked by glguy (glguy)
20:43:54 --- mode: glguy set -o glguy
20:43:58 <dons> how odd.
20:44:25 <dons> one theory: he's a foreign language student CS student trying to work out how to do some distributed systems assignment.
20:44:26 <cjs> Ok, I don't have to pattern match so a function works fine for me. Thanks!
20:44:35 <dons> but not doing so well.
20:46:23 <ddarius> He needs atom physics for a robot?
20:46:30 <dons> a bot net?
20:46:39 <dons> hmm. a robot that will destroy us all.
20:46:55 <sw17ch> with a PII and a PIII
20:47:07 <dons> but with beowulf dreams.
20:47:27 <chrisdone> man you guys play a lot of pokemon
20:47:31 <dons> but he doesn't want to write his vectors from scratch. to much work.
20:47:34 <ddarius> Was the Beowulf cluster to be onboard the robot or off-board?
20:47:51 <sw17ch> perhaps it's a beowulf of many small robots communicating via WiFi
20:48:18 <ddarius> He did say _big_ robot.
20:48:26 <dons> big robots are the best kind.
20:48:51 <sw17ch> big robot with a PII brain :)
20:49:15 <sw17ch> ?tell dcoutts Consider this groveling :)
20:49:15 <lambdabot> Consider it noted.
20:49:46 <dons> reminds me of ted hughes' 'iron man'.
20:55:49 <Twey> catch (read $ args !! 1) (const 6667) -- This doesn't work
20:55:53 <Twey> What's the proper way of doing it?
20:56:03 * sw17ch notices Sound.CSound
20:56:03 <ddarius> Use reads
20:56:07 * sw17ch also notices it doesn't build
20:56:29 <ddarius> Indeed.  One doesn't see sound.  That's just silly talk.
20:56:32 * sw17ch notes that it's probably because the build server doesn't have the needed library
20:56:40 <sw17ch> :)
20:56:41 <Twey> @src reads
20:56:41 <lambdabot> reads = readsPrec minPrec
20:56:51 <Twey> Unhelpful... hmn...
20:56:54 <dons> readMaybe!
20:57:21 <dons>     maybeRead s = case reads s of
20:57:21 <dons>         [(x, s')] | all isSpace s' -> Just x
20:57:21 <dons>         _                          -> Nothing
20:57:27 <ddarius> :t reads
20:57:28 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:57:35 <dons> should really push that into Text.*
20:57:44 <chrisdone> http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html#v%3AreadMay
20:57:46 <lambdabot> Title: Safe, http://tinyurl.com/5mhw73
20:57:48 <dons> the monad generalists failed, leaving the way clear.
20:58:21 <ddarius> The Monad generalists failed.
20:58:33 <ddarius> There are plenty of MonadZero generalists alive and well.
20:59:17 <dons> they're fine and good. but have a more work to do.
20:59:21 <Twey> So what does reads actually return?
20:59:30 <ddarius> dons: Only because of Haskell 98.
20:59:36 <dons> yes, that small matter.
20:59:42 <Twey> A list of tuples of the read value and... uhm...
20:59:46 <Twey> String errors?
20:59:47 <ddarius> > reads "534u" :: [(Int,String)]
20:59:48 <lambdabot>  [(534,"u")]
20:59:55 <Twey> Oh
20:59:58 <Twey> Unreadable stuff
21:00:10 <ddarius> Twey: It's a parser.
21:00:32 <chrisdone> readMay :: Read a => String -> Maybe a
21:00:34 <chrisdone> !o_o
21:00:35 <ddarius> It parses, returns the result and the remainder of the string.
21:01:04 * Twey nods.
21:01:27 <Twey> So an error thrown with `error` is uncatchable?
21:01:31 <ddarius> > reads "aoseuh" :: [(Int,String)]
21:01:32 <lambdabot>  []
21:01:36 <ddarius> Twey: In Haskell 98, yes.
21:01:43 <Twey> OK, thanks :)
21:01:44 <ddarius> Twey: In GHC, no.
21:01:50 * Twey nods.
21:02:02 <Twey> I'll stick to '98 if it's only a little extra effort.
21:02:05 <ddarius> However, a problem was laziness.
21:02:16 <Twey> Oh?
21:02:21 <ddarius> If you were using Control.Exception.catch then it would have caught the exception.
21:02:40 <chrisdone> the more I learn about logic languages, the more I want to implement a database library with a logic language front end
21:02:59 <sw17ch> @index liftM
21:03:00 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:03:03 <ddarius> :t Control.Exception.catch
21:03:04 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
21:03:15 <sw17ch> @index fix
21:03:15 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:03:39 <Twey> So when can reads return more than one (a, String)?
21:03:40 <ddarius> Twey: Well, actually the code you gave doesn't type check.
21:03:49 <jsnx> chrisdone: well, i think xsb did that
21:03:49 <Twey> Why is it in a list?
21:03:51 <ddarius> Twey: When there is an ambiguous parse.
21:03:55 <Twey> ddarius: Aye, I know :)
21:03:58 <Twey> Aha, thanks
21:04:01 <jsnx> chrisdone: though of course, they are not the last word on the matter
21:04:15 <chrisdone> jsnx: in haskell?
21:04:35 <jsnx> chrisdone: er, no
21:04:50 <jsnx> chrisdone: there's is a relative of datalog
21:04:56 <jsnx> s/there's/theirs/
21:05:00 <jsnx> hahaha
21:05:04 <chrisdone> jsnx: ah, sorry. I hadn't heard of them
21:05:17 <jsnx> i had to go out of my way to misspell that
21:05:45 <jsnx> chrisdone: are you familiar with datalog?
21:05:49 <chrisdone> jsnx: nope
21:06:26 <jsnx> chrisdone: it cuts out of a lot of stuff from prolog (not sure what, i am more familiar with datalog than prolog) and acts as a query langauge, essentially
21:06:45 <jsnx> some folks at stanford built a java analysis that they fronted with datalog
21:07:00 <jsnx> s/java analysis/java analysis tool/
21:07:18 <chrisdone> that's nifty
21:07:30 <ddarius> boilerplate(Program).
21:07:57 <jsnx> http://bddbddb.sourceforge.net/applet.html
21:08:04 <jsnx> ddarius: hehe
21:08:12 <jsnx> datalog online!
21:08:49 <jsnx> a database with a logic language attached is sometimes called a "deductive database" since it has all the facts that can be derived from all the rules and facts in it
21:09:02 <jsnx> but it doesn't have them all at once :)
21:09:34 * ddarius stores all the computer programs in the world on his computer.
21:11:15 * sw17ch has a program to generate all the programs in the world on his computer
21:11:27 * jsnx stores his source code in π, but can not find it just yet...
21:12:07 <ddarius> Nothing like the uncomputable to make you appreciate librarians.
21:12:40 <jsnx> the π filesystem -- every file is stored as a pair of indices into octal π
21:14:01 <jsnx> not sure whether that would be efficient for reads -- or writes :)
21:14:30 <b\6> is Handle an instance of Stream?
21:14:38 <ddarius> No
21:15:43 <chrisdone> jsnx: well, I've got a little lojban bot and I plan on making it take facts in lojban and answer questions, like {ta nanmu} “that is a man”, {ma nanmu} “what is a man?” => {ta} “that”, corresponding to man(that), man(X) in prolog. so I'm reading ( http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html ) and I am enthused with the idea of making a logic language backend for it
21:15:44 <lambdabot> Title: Structure and Interpretation of Computer Programs
21:16:16 <jsnx> lojban?
21:16:51 <chrisdone> jsnx: it's a constructed language with a simple and regular grammar which makes it easy to parse for this kind of thing ( http://en.wikipedia.org/wiki/Lojban )
21:16:55 <lambdabot> Title: Lojban - Wikipedia, the free encyclopedia
21:17:18 <ddarius> chrisdone: You should see lambdaProlog and Lolli and LolliMon.
21:17:20 <jsnx> the examples you gave are reminiscent of chinese
21:17:37 <geezusfreeek> yay more lojban
21:17:56 <b\6> oh, i see what you mean. ta1 = he/she.
21:18:00 <jsnx> ma = "question particle" ; ta = "him/her/it" ; nan = "male person"
21:18:16 <chrisdone> jsnx: it is similar in that sense, yeah. I don't know chinese, but I often hear the comparison
21:18:24 <jsnx> interesting
21:18:46 <jsnx> chinsperanto :)
21:20:19 <Twey> Not similar to Esperanto.
21:20:22 <Twey> We are insulted.
21:20:23 <Twey> :)
21:20:42 <Twey> jsnx: That's probably not coincidental
21:21:04 <chrisdone> jsnx: can you use ma multiple times in chinese? e.g. {tavla} means “x1 talks to x2 about x3 in language x4”, so {mi tavla do la lojban la lojban} “I talk to you about lojban in language lojban” -- you can put {ma} in multiple places, {ma tavla ma} “who/what talks to who/what [about some topic in some language]?”
21:21:16 <Twey> chrisdone: No, it's just a question particle in Chinese
21:21:22 <Twey> Lojban equivalent would be 'pau'
21:21:30 <Twey> (Mandarin, that is)
21:21:42 <chrisdone> oh, ok
21:21:52 <Twey> There's an algorithm used for selecting suitability of vocabulary based on similarity to words in existing common languages
21:22:11 <Twey> Mandarin is pretty high on that list
21:22:41 <b\6> huh?
21:22:45 <b\6> please explain more/again.
21:23:18 <Twey> b\6: Which bit?
21:23:25 <rwbarton> Lojban words were selected so as to be similar to words with the same meaning in widely-spoken languages
21:23:35 <b\6> selecting suitability of vocab and chinese being high on some list related to that.
21:24:26 <b\6> picking sounds based on mandarin would be a bad idea. the sound system is too simple so they have to differentiate with tones.
21:24:59 <rwbarton> "The English tone system is too simple so they have to differentiate with final consonants"
21:25:03 <Twey> b\6: There's an algorithm in which the top few languages are weighted based on number of speakers, and then the vocabulary candidate rated according to how similar the/an equivalent word is in those languages
21:25:09 <Twey> rwbarton: *grin*
21:26:41 <dons> if only Brook (the gpu programming language) was named after HBC.
21:26:48 <dons> then he'd have had 3 programming languages named after him.
21:27:26 <dons> he's already got a functional language, and a logic language named after him. So "Brooks" should be a hmm, OO language!
21:27:39 * Twey laughs.
21:27:48 <Twey> Curry isn't just logic
21:27:55 <dons> ah, maybe that's the trend
21:27:58 <dons> *adding* paradigms
21:28:03 <Twey> Yeah :-P
21:28:11 <dons> functional -> functional + logic -> functional + logic + OO
21:28:25 <Twey> Brooks = functional + logic + AO
21:28:44 <dons> oh, yes. researchy.
21:28:54 <chrisdone> I swear OO isn't in the same class as functional, logic or imperative
21:29:18 <Nafai> Twey: AO?
21:29:24 <chrisdone> aspect oriented
21:29:25 <Twey> Nafai: Aspect-Oriented
21:29:33 <Nafai> Of course.  Thanks.
21:29:40 <Twey> chrisdone: Well, yes, it's a little less fundamental.
21:30:07 <Twey> But 'paradigm' here means 'method of program design', I think.
21:31:02 <cjs> Would "method of program organization" be a better term for it?
21:31:33 <dibblego> @check \x -> if null x then x else tail x == drop 1 x -- wtf is with lambdabot?
21:31:35 <lambdabot>  mueval: Expression did not compile.
21:31:36 <lambdabot> mueval: Time limit exceeded
21:31:38 <dons> http://www.reddit.com/comments/6x3ud/ask_reddit_whatever_happened_to_aspect_oriented/
21:31:41 <lambdabot> Title: Ask Reddit: Whatever Happened to Aspect Oriented Programming? : reddit.com, http://tinyurl.com/6nlo2a
21:31:41 <dons> :)
21:31:44 <Twey> cjs: No, design
21:31:55 <Twey> Design is more than just 'where code goes'
21:32:10 <chrisdone> dons: haha
21:32:27 <Twey> It's a whole method of organisation, and it results in the program being written in a fundamentally different manner, even if the change itself isn't that fundamental
21:32:36 <cjs> By organization, I would also include "how code connects."
21:32:45 <Twey> Haha, dons
21:32:50 <Twey> 'there doesn't seem to be anything here'
21:32:59 <chrisdone> great
21:33:02 <Apocalisp> I remember aspect-oriented
21:33:08 <Nafai> Is that a commentary on AOP itself? :)
21:33:16 <cjs> I think we may be thinking about the same ideas, and have our use of terms reversed.
21:33:17 <dons> sure, you can do logging that way, turning it on or off
21:33:19 <Twey> cjs: Yes, but that pretty much *is* programming.
21:33:23 <dons> but are there any other uses?
21:33:33 <Twey> Er, dons?
21:33:42 <cjs> You mean for AO, beyond logging?
21:33:43 <dons> oh, cool. the wikipedia page on AOP talks about logging as the canoncial example.
21:33:53 <Twey> I don't know if you get a different page to us
21:33:58 <dibblego> they always talking about logging
21:33:59 <Twey> But we get 'there doesn't seem to be anything here'
21:34:16 <dons> Twey: since no one knows what happened to AOP?
21:34:23 <rwbarton> @check \x -> (if null x then x else tail x) == drop 1 x
21:34:25 <lambdabot>  "OK, passed 500 tests.\n"
21:34:32 <dibblego> thanks rwbarton
21:34:44 <dublpaws> software engineering radio just had an episode on AO
21:34:53 <Twey> dons: I thought that was the joke, but you were talking as if there was something on the page just then :)
21:35:12 <shapr> I think AOP is the latest foozle.
21:35:13 <Apocalisp> AOP keeps talking of this "logging", but what happened to all that timber?
21:35:19 <Twey> Hahaha
21:35:29 <Twey> shapr: The foozle that fizzles?
21:35:35 <shapr> Like, Wadler's Foozle.
21:36:05 * Twey reads.
21:36:31 <Twey> Argh, bloody hell, there's frigging Adobe Reader on my machine
21:36:38 <Twey> Gettitoffgettitoffgettitoff...
21:36:43 <idnar> haha
21:36:52 <dons> hehe
21:36:56 <idnar> In Soviet Russia, Adobe Reader reads *YOU*!
21:37:07 <chrisdone> thanks, slashdot
21:37:21 <Twey> idnar: In Soviet Russia, Adobe Reader loads before the coming of the next ice age...
21:37:28 * chrisdone posts “what ever happened to slashdot?” to reddit...
21:37:34 <Twey> Hahaha, chrisdone
21:37:48 <Twey> Then post 'whatever happened to reddit?' to Slashdot...
21:37:49 <dons> chrisdone: haha
21:39:59 <cjs> Monads must be deep and subtle or something. I keep forgetting what seem like relatively trivial details about them.
21:40:07 <Twey> Hahaha, nice, shapr
21:40:14 <Twey> They *are*, cjs :-P
21:40:38 <dibblego> they aren't, they are just useful
21:42:44 <geezusfreeek> i remember reading about aspect oriented programming, but i never understood it
21:44:11 <chrisdone> a few of my friends have told me that once they understood monads they thought it was all a big fuss (“monads are scary!” etc) about nothing. the trouble with monads obviously isn't the concept itself but the tutorials and culture surrounding them
21:44:14 <cjs> Twey: no, I wouldn't put it that way. It's just that I still don't have the kind of instinctive grasp of all of their workings that I do with, say, OO inheritance.
21:45:00 <cjs> chrisdone: No, I'm not buying that one, either. I had a big "Ah ha! These are really so simple!" moment a few months ago, yet I still don't instinctively grasp, without thinking about it, everything about them as I make and use them.
21:45:16 <geezusfreeek> cjs: you will continue to have those aha moments forever
21:45:19 <cjs> They are certainly not complex, but somehow you have to change your brain to use them effectively.
21:45:39 <cjs> Or perhaps, "use them naturally, like breathing" is the phrase I'm looking for.
21:45:53 <cjs> geezusfreeek: so long as I keep studying math, anyway. :-)
21:46:25 <cjs> But that was why I mentioned "program organization" above; I put things together in a completely different way in Haskell.
21:46:39 <geezusfreeek> cjs: i mean even just about monads. anything that is so abstract will tend to have this effect the more exposure you have to it
21:46:46 <cjs> And it's really annoying, compared to, say, Ruby, to be forced to think about what I do and don't want to type check.
21:47:15 <chrisdone> cjs: well, I thought I got them for a while, and then realised I didn't, now I think I get them. maybe some time I will realise I don't get them, but I'm sure I do
21:47:28 <chrisdone> cjs: I think that is a ridiculous complaint
21:47:29 <geezusfreeek> i find it really annoying to write in Ruby and find that i won't know if i did anything right at all until i run my program
21:47:32 <cjs> geezusfreeek: Yeah, maybe you just have to apply them a whole bunch of different times in different circumstances to start to get a real feel for them.
21:47:50 <cjs> chrisdone: I'm not saying it's a bad thing to be forced to think about the correctness of my code. :-)
21:48:26 <chrisdone> cjs: surely you knew up front how haskell's type system “takes it to the extreme” (as SPJ puts it)
21:48:28 <cjs> It's just annoying to look at something and be faced with the fact that, if I do it that way, here are the ways it can break. You don't think about that in ruby.
21:49:59 <b\6> wow, really different perspective. i used to love ruby but basically stopped using it because it'd do stuff like silently ignore misspelled variable names.
21:50:00 <geezusfreeek> cjs: i find it more liberating than annoying. i can rest assured that under no conditions will certain properties be violated. i can't do that with ruby
21:50:10 <chrisdone> it's funny, I was saying the complete opposite before in another channel:
21:50:12 <chrisdone> 01:35 < chrisdone> it's very fullfilling to modify haskell code
21:50:12 <chrisdone> 01:36 < chrisdone> I am putting in big chunks and removing big chunks, and I am confident that the behaviour will not change for the functions I do not change
21:50:15 <chrisdone> 01:37 < chrisdone> the types also seem to tell me exactly which functions are affected by my changes
21:51:19 <dons> it's good for confidence while hacking.
21:51:25 <geezusfreeek> cjs: in fact, whenever i find myself writing a contract for a function in comments, i see about putting that into the type system instead. sometimes it is not worth it, but at least i have the option
21:51:33 <dons> in fact, i find it hard to remember now what it's like to have code fall apart during refactoring.
21:52:15 <cjs> b\6: That's one of the reasons I switched to Haskell.
21:52:27 <chrisdone> right. I was changing this bouncer from serving one client to many, which if I got wrong would really be horribly confusing to debug
21:52:32 <cjs> Yeah, I love the type system, it's just more work up-front.
21:52:51 <b\6> yeah, true.
21:53:03 <b\6> the payoff is less worry.
21:53:05 <b\6> etc.
21:53:20 <cjs> dons: Refactoring takes me a lot longer in Haskell. Or at least it *feels* like longer, because I've often got to change so much before I can compile it again.
21:53:41 <chrisdone> cjs: I honestly believe that changes with time
21:53:44 <cjs> Of course, I conveniently forget all the time I used to spend fixing tests.
21:54:02 <cjs> chrisdone: Actually, I think it would change a lot more with a good refactoring tool.
21:54:16 <chrisdone> cjs: when I first started I would get so angry trying to get the damn thing to compile, and now my *haskell* buffer is just full of clean compiles with the odd spelling mistake here and there
21:54:31 <dons> i think there's some experience in how to break things in haskell, to make it easier and safe to change.
21:54:35 <dons> controlled breakage.
21:54:43 <cjs> But yeah, it will help as I start more often structuring things more closely to the correct way in the first place, rather than my usual "write it, than scrap and rewrite it twice more" style right now.
21:54:57 <cjs> dons: Yes, I've been working on those techniques.
21:55:06 <dibblego> cjs, tools aside, Haskell is significantly easier to refactor than just about any other language and if it isn't, then practice
21:55:15 <cjs> But RWH could use a chapter on it. :-)
21:55:25 <dons> i'm not sure we know yet the best ways.
21:55:31 <dons> i've only thought about it on and off
21:55:34 <dons> Adv. RWH maybe
21:55:43 <geezusfreeek> dons: ooh, i like the sound of that
21:55:47 <dons> controlled breakage, via types, as a technique.
21:55:51 <chrisdone> does anyone ever do this way to replace code, whereby you write the new versions of things with say ' appended, and then once that's all compiled and sorted, you just “slip” it into the program and remove the old crap?
21:55:55 <dons> that's a pretty unusual idea, imo.
21:56:03 <dibblego> chrisdone, yes
21:56:18 <cjs> True. Maybe just do a paper. But it took me months to learn techniques such as defining a method as undefined, just to get the type signature in there so you can use the compiler to start fixing stuff.
21:56:19 <geezusfreeek> chrisdone: i do that a lot
21:56:36 <chrisdone> like rather than changing foo :: MVar a, I would add a foo' record, write code to work with it, and then slip it in and remove the original
21:56:45 <chrisdone> cool
21:57:32 <chrisdone> yes, undefined is very nice<3
21:57:38 <cjs> Or using ghci to quickly test your refactoring on a module-by-module basis, as you go.
21:58:04 <dons> yeah, there's lots of techniques and idioms. the practice of haskell, which hasn't been written  down yet.
21:58:08 <dons> and only rarely shared.
21:58:21 <chrisdone> haha
21:58:32 <chrisdone> The Olde Ways
21:58:35 <dons> we have weekly 'dev symposiums' about techniques like that, at galois, btw. since we basically get to invent the techniques as we go
21:58:44 <chrisdone> cool!
21:58:57 <b\6> is hReady defective? my debugging output shows hReady h false, but right after that, hGetChar returns exactly what was expected. thereafter hReady reports true.
21:59:10 <cjs> dons: That's a brillian idea. You should record them and make them available to the rest of us.
21:59:26 <chrisdone> using haskell at work. *shakes head*. bastard. I bet you get up in the morning and look in the mirror and say “who's awesome? you're awesome! ;D”
21:59:36 <cjs> chrisdone: Yup!
21:59:37 <chrisdone> cjs: seconded!
22:00:15 <cjs> I wonder if I'm the only commerical Haskell programmer in Tokyo, actually.
22:00:34 <jeffz> dons, have you seen "Where do I begin? A problem solving approach to teaching functional programming", I think it talks about why some people find it difficult to take to programming in Haskell, it goes some way to writing things down
22:00:34 <cjs> BTW, I'll be at ICFP and CUFP this fall.
22:00:37 <chrisdone> yeah, everywhere else there are loads.. but in tokyo... :p
22:00:59 <Twey> What's the difference between a Channel and a TChannel?
22:01:11 <dons> jeffz: i saw you added the link.
22:01:18 <cjs> Well, we do apparently have a Jane Street Capital office, though way out in Chiba for some reason, but they're all OCaml, anyway, from what I understand.
22:01:20 <dons> jeffz: i should read it.
22:01:34 <dons> cjs, awesome!
22:01:45 <cjs> I'm not sure they even do any programming out there; I've never heard boo from them in the five months I've been running an FP group.
22:01:51 <cjs> dons: I am pretty chuffed.
22:02:07 <dons> hmm. we need to get video equipment.
22:02:29 <dons> wider knowledge dispersal of commercial haskell dev practices is sorely needed.
22:02:32 <cjs> It was actually one of our objectives when thinking about starting our company three years ago: "go to ICFP."
22:02:39 <dons> it benefits us all to spread that info around.
22:02:50 <Trinithis> What happens are these ICFP and CUFP... a bunch of FP programmers converging?
22:03:02 <dons> cjs: are you presenting at CUFP?
22:03:03 <cjs> http://icfpconference.org/
22:03:10 <lambdabot> Title: The ACM SIGPLAN International Conference on Functional Programming (ICFP)
22:03:44 <cjs> dons: No, not this year. Even with an offer from SPJ to extend the submission deadline a bit, it was too early in my Haskell career to be able to come up with anything very interesting.
22:03:54 <dons> heh .ok.
22:04:12 <cjs> But I'll be set for next year, with both a commercial project and an open source one under my belt.
22:04:19 <dons> yeah, sounds good.
22:04:28 <dons> is it easier  to get  to europe or the usa?
22:05:17 <cjs> West Coast is easiest for me. After that, probably major places in North America, because there are more direct flights. Europe I'd probaby end up going through a hub, though maybe it's not that big a deal.
22:05:29 <cjs> NYC is about 14 hours for me, London about the same.
22:06:07 <cjs> But I have a US passport; I'd imagine that the US could be a pain for those without, what with their recent immigration paranoia.
22:06:28 <TSC> @hoogle a -> [a] -> Int
22:06:28 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
22:06:28 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
22:06:28 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
22:10:05 <uebayasi> cjs, don't you have contact with .jp FP programming community? :)
22:10:26 <uebayasi> i don't, but just curious
22:10:41 <cjs> uebayasi: Some, but it's mostly academic.
22:10:45 <uebayasi> FP, or LL language community is pretty active these days
22:10:50 <uebayasi> ok
22:11:13 <cjs> There is a company here doing commerical stuff in Erlang.
22:11:18 <uebayasi> i'm not recommending them ;)
22:11:23 <cjs> Heh. :-)
22:12:07 <cjs> Actually, I went recently to one of the Tokyo Programming Seminar talks, and that was pretty good.
22:13:17 <uebayasi> is it in English?
22:13:18 <TSC> There is some Typeable magic to get the data constructor of a value, isn't there?
22:14:07 <cjs> This one was. I think it ususally is. It had a foreign presenter, but the next presenter, a Japanese guy, also presented in English.
22:14:15 <dons> my supervisor used to do FP at tsukuba.
22:14:37 <cjs> I suspect it's a small enough community that not working in English would be a bit handicap.
22:15:58 <Twey> You can speak Japanese, no?
22:16:02 <geezusfreeek> man i've got to find me a haskell job
22:16:16 * Twey goes to dice.com
22:16:22 <cjs> I speek Japanese enough to get along socially, but not to discuss FP.
22:16:28 * Twey searches for 'Haskell'
22:16:30 * geezusfreeek races Twey
22:16:51 <cjs> We've got one open. Though there's also a lot of Ruby and Unix sysadmin involved, and the pay is low.
22:16:54 * Twey finds six results, two of which are entitled Web Application Developer - Ruby - Java - Python - C - C++
22:17:07 <dons> cjs, this guy does (used to?) do some haskell, http://www2.score.cs.tsukuba.ac.jp/people/professors/tetsuo-ida/ida/view
22:17:14 <Twey> Doing what, cjs?
22:17:18 <chylli> www.haskell.org out of time
22:17:20 <lambdabot> Title: Welcome to Tetsuo Ida's Homepage — SCORE, http://tinyurl.com/6nsyry
22:17:22 <dons> and computational origami, fwiw.
22:17:48 <dons> works for me, chylli
22:18:24 <sereven> kirei has been best haskell analogue to pythonic I could find so far, but only japanese would get it, although sounds remotely like Curry I suppose.
22:18:42 <dons> mm
22:18:48 <dons> how would you translate it?
22:18:53 <cjs> Our current big projects are an automated options trading system (Haskell), a very heavily trafficed You-tube like website (Ruby, sysadmin), and what's essentially a PBX system (Ruby, sysadmin).
22:18:55 <sereven> clean/beautiful
22:19:19 <dons> cjs, going to sell it to one of the haskell banks for a gazillion? :)
22:19:37 * dons wonders why cjs doesn't blog about trading in haskell, while joelr blogs soo much about not doing trading in haskell
22:19:50 <cjs> Not this particular one, since it's owned by the client, but we have some other interesting stuff in the works that I think banks would be interested in.
22:19:53 <chylli> I want to setup lambda bot in my chat rome. any instruction ?
22:20:10 <Twey> chylli: Ask Cale
22:20:14 <dibblego> good luck and may the force...
22:20:14 <cjs> I barely have time to cons up a quick blog entry about the latest TSAC meeting.
22:20:17 <zeno_> will timing stuff in ghci be a good indication of how it will perform (but like 50x faster) in ghc -O2?
22:20:18 <Twey> He'll have her join
22:20:21 <b\6> i noticed a lambdabot builder tool showed up on hackage recently.
22:20:25 <cjs> Also, we're not actually trading yet. That probably comes in a few months.
22:20:31 <Cale> b\6: Seriously?
22:20:37 <Pseudonym> Actually, which channel is it, chylli?
22:20:44 <dons> zeno_: unknown.
22:20:49 <cjs> But I will, once I get mhailist a little more developed, set up a list for financial haskell discussion.
22:20:50 <Cale> If it's on this network, we can just get lambdabot to join it.
22:20:55 <Pseudonym> Yeah.
22:20:57 <dons> zeno_: maybe within big O
22:21:04 <chylli> Pseudonym: in fact, it isn't in irc, but an jabber conference.
22:21:05 <b\6> Cale: botpp library and program: Build tool for Lambdabot
22:21:08 <b\6> haven't checked it out.
22:21:13 <Pseudonym> It'd be cool if lambdabot could handle multiple IRC servers.
22:21:17 <Pseudonym> Oh, and jabber.
22:21:18 <Cale> oh, that's part of the build process for lambdabot
22:21:24 <chylli> Pseudonym: I will use bitlbee as a gateway
22:21:27 <Cale> (It's required, not optional :)
22:21:27 <b\6> sorry, thought it was new.
22:21:28 <dibblego> it can handle multiple IRC servers (the old version I run can anyway)
22:21:29 <dons> Pseudonym: it can handle multiple servers now.
22:21:35 <Cale> It's newly separated :)
22:21:36 <Pseudonym> Woo!
22:21:38 <Pseudonym> lambdabot++
22:21:46 <dons> for ages, since sorear refactored all the innards.
22:21:47 <uebayasi> last time i met cjs, he could barely speak Japanese enough to order drinks at pubs ;)
22:21:48 <Cale> Oh, right, it can :)
22:21:51 <Pseudonym> Right.
22:21:56 <dons> uebayasi: hehe :)
22:22:17 <dibblego> I have to setup lambdabot again after learning of its security vulnerability in an older version
22:22:22 <Twey> uebayasi: Haha
22:22:50 <dons> dibblego: what were those?
22:23:28 <dibblego> Aug 20 07:09:57 <mauke> > runST (unsafeIOToST (readFile "/etc/passwd"))
22:23:32 <cjs> I have always been able to speak *that* much Japanese.
22:23:34 <dibblego> <lambdac>        "root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\nbin...
22:23:55 <cjs> I just never got much beyond that, that's all. :-)
22:25:14 <Twey> Hooray for shadowing!
22:25:26 <dons> dibblego: that should have been closed a long long time ago.
22:25:40 <dibblego> dons, apparently it was and I was running an out-of-date lambdabot
22:25:40 <dons> if someone broke all the trusted shadowing...
22:25:52 <dons> well, i also heard people messing with the module scope
22:26:10 <dibblego> I've given up on lambdabot, way too much effort
22:27:14 <dons> yep
22:28:06 <Trinithis> Twey: Blasphemy! http://www.codingforums.com/showthread.php?p=725552#post725552
22:28:11 <lambdabot> Title: CodingForums.com
22:28:39 <Twey> Trinithis: Shock!  Horror!
22:28:46 <Twey> Trinithis: 'You are not logged in or you do not have permission to access this page!'
22:28:49 <Twey> How dare they!
22:29:03 <Twey> Huh
22:29:11 <Twey> 'Twey, you do not have permission to access this page.'
22:29:12 <Twey> :(
22:29:14 <Trinithis> Oh, it was a post in an active members lounge
22:29:26 <Trinithis> Quote: "You're the most wonderfully horrible language ever. "
22:29:34 <Trinithis> referencign JS
22:29:40 <Twey> Hahaha
22:29:43 <Twey> No
22:29:45 <Trinithis> I corrected him by saying PHP
22:29:45 <Twey> That's COBOL
22:30:21 <Twey> COBOL's got to be worse than PHP
22:30:22 <Trinithis> I would suspect COBOL is in league with PHP.
22:30:26 <Twey> Nono.
22:30:28 <Twey> Worse.
22:30:31 <Twey> Much worse.
22:30:32 <Trinithis> Probably. I bet my dad knows it though
22:30:43 <Twey> VB's worse than PHP too.
22:30:50 <Trinithis> :(
22:30:51 <Twey> (Classic, don't know about .NET)
22:31:02 <Twey> INTERCAL!
22:31:08 <Trinithis> Intercal has cool factor
22:31:12 <Twey> Haha, true
22:32:02 <chrisdone> a teacher of mine used to go on about how he was a cobol programmer at heart and this “new” stuff (Pascal) wasn't his thing, before he was fired, that is >_>
22:32:08 <Twey> Hahahaha
22:32:14 <jeffz> it won't be long before someone decides to write COBOL and VB interpreters in Haskell for fun
22:32:25 <Twey> That would be very easy
22:32:32 <Twey> (in the case of COBOL)
22:32:35 <Trinithis> I doublt anything COBOL or VB would be considered "fun"
22:32:48 <b\6> dibs on rpg.
22:32:53 * Twey grins.
22:33:00 <Twey> RPG was wonderfully horrible too.
22:33:03 <chrisdone> maybe it's like the kind of "fun" of ouija boards
22:33:07 <Twey> Ooh, ooh, and MUMPS
22:33:09 <b\6> indicators, baby.
22:33:10 <jeffz> Twey: was?
22:33:16 <chrisdone> you know you're raising some evil shit, but it's just so fun
22:33:19 <Twey> jeffz: Nobody uses it any more.
22:33:22 <b\6> columnar notation, hell yeah.
22:33:26 <Twey> jeffz: La la la I can't hear you.
22:33:29 <jeffz> Twey: huh? they do. it's popular.
22:33:41 <Twey> TMI!  TMI!
22:33:43 <jeffz> Twey: there are more rpg programmers than Haskell programmers :p
22:33:49 <Trinithis> Has an assember been written in Hs?
22:33:49 <Twey> Arrrrgh
22:34:01 <Twey> Trinithis: Better than that, we've got Harpy
22:34:11 <Twey> http://uebb.cs.tu-berlin.de/harpy/
22:34:12 <lambdabot> Title: Harpy - Runtime code generation for x86 machine code
22:35:08 <glguy> has anyone had any success using Takusen on OS X?
22:35:21 <Trinithis> Twey: better? Is it like a grade above asm?
22:35:32 <dons> glguy: i think you might need to ask alistair.
22:35:51 <glguy> dons:  I Think he is a windows developer
22:36:02 <Trinithis> oh i see
22:36:06 <Trinithis> that's cool
22:36:08 <Twey> Trinithis: It's a runtime machine-code generator.
22:36:09 <Twey> Aye.
22:36:43 <Twey> My headphones are knackered
22:36:48 <Twey> *puts on list of things to buy today*
22:37:03 <chrisdone> I hope that includes tickets to manchester
22:37:09 <Twey> Nope
22:37:19 <chrisdone> ;_;
22:37:19 <Twey> 1) Loose trousers for aikidou 2) new headphones.
22:37:35 <Twey> 3) food.  *amends*
22:38:07 <Trinithis> If only I knew about Harpy a couple months ago... I would have used it in my assembly class for kicks.
22:38:27 <Twey> Heh
22:40:06 <dons> glguy: yeah, but he might have build reports/failure reports.
22:40:21 <mmorrow> now you can use it now for stabs, or thrusts
22:40:30 <mmorrow> Trinithis ^^
22:41:07 <Trinithis> Assembly is mega fun. C++ is not
22:42:10 <mmorrow> heh
22:42:40 <Pseudonym> Assembly is fun in the same way that making soap from scratch is fun.
22:42:46 <Trinithis> lol
22:43:13 <Trinithis> presuming making soap is fun of course
22:43:17 <mmorrow> i'm cataloguing interesting/useful unicode chars+their hex codes here http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=16#a16
22:43:31 <Pseudonym> C++ is not fun in the same way that pregnancy is not fun.
22:43:31 <mmorrow> if anyone has anything to add, please do! (hpaste2)
22:44:11 <dons> we need the hpaste2 bot
22:44:39 <Twey> mmorrow: Erm, 'useful' = all of Japanese?  :)
22:44:40 <mmorrow> how do you mean?
22:44:54 <mmorrow> @dons
22:44:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:44:59 <Twey> What are the OCR chars for?
22:45:03 <mmorrow> Twey: edits are welcome!
22:45:12 <Twey> mmorrow: No, that's a lot of characters :)
22:45:19 <mmorrow> like check number, routing number, ..
22:45:21 <glguy> dons: I got it running
22:45:25 <Twey> Aha
22:45:29 <glguy> relude Database.ODBC.Enumerator> catchDB (withSession (connect "") (execDDL "")) print
22:45:29 <glguy> DBError ("IM","007") 30283278 "[iODBC][Driver Manager]No data source or driver specified, dialog prohibited"
22:45:47 <dons> mm
22:46:20 <glguy> that just shows that it is actually calling out to the ODBC library
22:46:23 <mmorrow> Twey: mostly by "useful", i mean "symbols that can be used to novel effect"
22:46:25 <glguy> and building
22:46:28 <Trinithis> What does hpaste2 have over hpaste?
22:46:35 <Twey> Heh, mmorrow
22:46:47 <dons> nifty and awesome.
22:46:52 * Twey chuckles.
22:47:04 <Twey> Oh, like Office 2007 vs. Office '95?
22:47:12 <dons> yeah, **exactly** like that.
22:47:17 * Twey nodnods.
22:47:28 <Twey> It's not like we need *features* in our new app versions.
22:47:30 <dons> bigger numbers == win.
22:47:32 <Twey> We just need *awesome*.
22:47:41 <dons> you get it.
22:49:03 <mmorrow> glguy: i tried to get takusen working with odbc (on linux), but the whole odbc part ended that pretty fast
22:49:31 <glguy> mmorrow: I'm going to give it a shot before moving on :)
22:49:52 <dons> mmorrow: hmm.
22:49:59 <dons> that's probably not what we wanted to hear.
22:50:06 <mmorrow> glguy: awesome, let me know if you get it working :)
22:50:20 <mmorrow> dons: heh
22:50:43 <mmorrow> i was in a rush though, so didn't spend *that* much time trying
22:51:02 <mmorrow> (this was the other day)
22:51:21 <b\6> making a hackage project's "home page" the darcs repo dir considered harmful
22:51:34 * Twey chuckles.
22:51:58 <Twey> Cripes
22:52:37 <Twey> Naming Things 'Foo Considered Harmful' Considered Harmful
22:53:22 <Twey> Hmn
22:53:35 <Twey> Does :: have a higher or lower priority than $?
22:54:24 <lispy> I don't know how to answer that, but foo $ bar :: ReturnTypeOfFoo
22:54:33 <lispy> Does that make it lower or higher?
22:54:46 <Twey> Higher
22:54:50 * Twey frowns.
22:54:55 <Twey> No, lower.
22:54:58 <Twey> Heh
22:55:24 <lispy> > map chr [1..10] :: String
22:55:25 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n"
22:56:07 <Trinithis> I think :: types the entire expression
22:56:31 <lispy> yes
22:56:37 <lispy> > map $ chr [1..10] :: String
22:56:40 <lambdabot>  mueval: Expression did not compile.
22:56:40 <lambdabot> mueval: Time limit exceeded
22:56:44 <Trinithis> lol
22:56:44 <lispy> (sorry left the ($) out of my example...)
22:56:59 <lispy> did not compie?
22:57:10 <lispy> oh right
22:57:20 <lispy> > map chr $ [1..10] :: String
22:57:21 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n"
22:57:42 <lispy> if you want to put a type sig on it, you best put parens around it
22:57:47 <lispy> parens are your friends anyway
22:57:58 * lispy *might* be biased
22:58:13 * Twey laughs.
22:58:37 <Trinithis> lispy: do you like liskell?
22:58:58 <Twey> lispy: I always confuse you with licks
22:59:23 <lispy> Trinithis: i've heard of liskell, never tried it
22:59:28 <lispy> Twey: licks?
22:59:36 <Twey> A Japanese programmer
23:00:11 <Twey> /licksjp
23:02:12 <glguy> Prelude Database.ODBC.Enumerator> let iter :: Monad m => Int -> IterAct m [Int] ; iter x xs = result' (x:xs)
23:02:12 <glguy> Prelude Database.ODBC.Enumerator> withSession (connect "DSN=test") (doQuery "select * from main" iter [])
23:02:12 <glguy> [42]
23:02:15 <glguy> woot
23:02:55 <glguy> takusen works fine with os x's standard iodbc library in this trivial case
23:03:20 <Adamant> wonderfully horrible does not describe COBOL or RPG
23:03:28 <Adamant> just horrible will suffice
23:03:39 <lispy> > parens 10
23:03:42 <lambdabot>  mueval: Expression did not compile.
23:03:42 <lambdabot> mueval: Time limit exceeded
23:03:52 <lispy> > L.parens 10
23:03:53 <lambdabot>  "(((((((((())))))))))"
23:04:25 <Twey> Adamant: Wonderfully horrible = so horrible that you wonder 'what the heck were they on?'
23:04:38 <Adamant> I thought it was more "love to hate it"
23:04:45 <Adamant> and "hate to love it"
23:05:13 <lispy> ?type (cycle, replicate, repeate)
23:05:14 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
23:05:22 <lispy> ?type (cycle, replicate, repeat)
23:05:23 <lambdabot> forall a a1 a2. ([a] -> [a], Int -> a1 -> [a1], a2 -> [a2])
23:05:38 <Adamant> also, are you French Twey?
23:05:47 <Twey> No, Adamant
23:05:50 <Adamant> ah
23:05:50 <lispy> > cycle "1"
23:05:51 <lambdabot>  "111111111111111111111111111111111111111111111111111111111111111111111111111...
23:05:51 <Twey> Why do you ask?
23:06:11 <Adamant> I thought Aikidou was the French way of expressing Aikido
23:07:09 <Twey> Adamant: 合気道 = ai ki dou 'together chi way' or something like that
23:07:13 <Adamant> ah
23:07:30 <Twey> They like to express it in a fancy manner though
23:07:35 <Adamant> kind of like how Jujitsu has various romanizations
23:07:36 <Twey> 'The Path of Harmonious Ki!'
23:07:54 <Twey> Adamant: There are a variety of ways of romanising Japanese
23:08:14 <Twey> I approve of any that preserve all possible phonetic information, and disapprove of the rest :)
23:08:26 <Twey> Dropping half a long vowel lands a system in my 'disapprove' pile.
23:08:31 <Adamant> ah
23:08:42 <Adamant> well, in the case of jujitsu
23:08:54 <Adamant> different systems insist on different romanizations
23:09:57 <Adamant> for instance Brazilian Jiu-jitsu is Jiu-jitsu, even though that's not a modern romanization, because it was the Romanization used when jujitsu was introduced to Brazil
23:09:58 <Twey> 'Jujitsu', 'jujitu', 'zyuzitu'?
23:10:05 <Twey> Hmn
23:10:27 <glguy> Could someone turn this into valid .cabal?    ElseIf os(darwin)
23:10:31 <Twey> Hah
23:10:34 <Adamant> other "American" and probably "European" jujitsu schools do similar things.
23:10:42 <Twey> The actual word is 'juujutsu'
23:10:48 <Adamant> haha nice
23:11:53 <Adamant> I think jujitsu is considered the more or less standard romanization
23:12:15 <Twey> 'Jujitsu' is the one I've heard most, aye
23:14:28 <cjs> Agh! Earthquake!
23:14:49 <Adamant> bad or mild?
23:14:50 <Twey> cjs: Big one?
23:15:12 <Adamant> lol, I hope he is inside a doorframe and doesn't answer for a bit
23:15:13 <cjs> Ok, seems mild. I was worried because it was one of those up-and-down ones rather than a side-to-side one.
23:15:18 <Adamant> ah
23:15:22 <Twey> Aye
23:19:17 <mmorrow> glguy: sweet!
23:19:46 <b\6> if i want to match a \r\n terminated line coming to me via a socket (handle) for certain, should i loop and hGetChar?
23:20:43 <nwf> Hullo all.  Trying to build ghc HEAD from git and getting the error shown in http://hpaste.org/9801... what am I doing wrong?
23:21:07 <mmorrow> i quit when i had to dl the this qt beast (the only way?!?) in order to fill the deps for unixodbc, and after 30 minutes of compiling the unpacked srcdir was 1GB+, so i ^C and rm -rf ed
23:21:23 <Twey> Qt's huge
23:21:39 <Twey> But... there are people on *nix who don't have Qt installed?  o.@
23:21:41 <b\6> nwf: doesn't it look like you need cabal?
23:22:14 <nwf> I have libghc6-cabal-dev installed, and any way I know of querying ghc-pkg suggests that I have Cabal installed already.
23:22:22 <glguy> mmorrow: unixODBC doesn't require the GUI tool
23:22:30 <glguy> mmorrow: you are also welcome to edit the .ini files by hand :)
23:22:45 <mmorrow> glguy: oh, excellent.. i didn't know what i was getting was the gui tool
23:23:41 * mmorrow wring hangs repeatedly while cackling
23:23:56 <mmorrow> i can't type worth anything
23:24:04 <opqdonut> :)
23:24:18 <mmorrow> glguy: thanks!
23:25:15 <b\6> nwf: hmm. ghc-pkg list | grep Cabal shows at least one?
23:26:21 <nwf>     Cabal-1.2.3.0, HTTP-3001.0.4, HUnit-1.2.0.0, QuickCheck-1.1.0.0,
23:26:33 <b\6> seems like that meets -any.
23:27:29 <b\6> kind of worried about those NONEXISTENTs. supposed to be that way?
23:29:28 <cjs> Huh, it was a 4.5 up in Ibaraki. Only about a 2-3 down here. (These are Japanese seismic intensities.)
23:29:44 <nwf> b\6: I have no idea, first time builder of ghc. :)
23:30:09 <nwf> b\6: It may also be worth noting that this is during stage 1 bringup, rather than the first pass at compilation.
23:30:29 <jeffz> b\6: not using parsec anymore?
23:30:54 <b\6> jeffz: i want to, but using hGetContents didn't work out; it closes the handle.
23:31:49 <b\6> i should say, it worked great for the first line i needed to receive.
23:32:49 <b\6> i have a handle and just dunno how to get the data to parsec.
23:32:55 <b\6> tibbe: <3.
23:33:20 <tibbe> b\6: ? :)
23:33:35 <b\6> happy about hyena.
23:33:40 <tibbe> :)
23:33:41 <tibbe> great
23:34:02 <jeffz> b\6: strange...  I would have thought hGetContents would work, maybe something else is going on
23:34:04 <tibbe> as I said, please report any issues
23:34:09 <b\6> will do.
23:35:08 <b\6> jeffz: maybe i'm using it wrong. it doesn't seem possible to use it twice on the same handle.
23:35:09 <tibbe> Some people, when confronted with a problem, think "I know, I’ll use hGetContents." Now they have two problems.
23:35:29 <glguy> hGetContents has its place in short-lived scripts
23:35:43 <tibbe> glguy: I disagree
23:35:44 <Twey> What's wrong with hGetContents?
23:35:44 <b\6> help, tibbe. want to use parsec to read \r\n terminated lines sensibly from a handle, but i don't know how.
23:35:46 <glguy> where you are able to fit all of the consequences into your head at once
23:36:16 <b\6> Twey: it closes the handle or something.
23:36:34 <jeffz> b\6: hmm, I'm not sure what it'd mean to hGetContents twice, somehow doesn't make sense to me, I would process some of the input returned by hGetContents and return the rest from parsec for further processing perhaps
23:36:57 <tibbe> glguy: but somehow short scripts have a tendency to end up on haskell-cafe under the title Why isn't this working and then there are 20 or so emails back and forth talking about rnf etc
23:37:20 <b\6> well, s <- hGetContents h and then parse blah blah blah, that's fine. next time i try to do it, h is hosed.
23:37:24 <glguy> of course it closes the Handle... you get a lazy list containing the whole of the contents
23:37:26 <glguy> what is left?
23:37:35 <jeffz> yeah, I thought so.
23:37:39 <b\6> the other million billion things i need to talk to the server about.
23:37:40 <tibbe> b\6: it's a big problem with parser libraries, they assume that you have all the input available as a stream
23:37:41 * Twey nods.
23:38:02 <tibbe> b\6: the parser I use in Hyena doesn't, it uses continuations instead so you can use strict I/O
23:38:08 <glguy> b\6: your parse then needs to return the part of the input that it didn't use
23:38:16 <glguy> for someone else to use
23:39:07 <cjs> b\6: What you need to do is read in chunks, and then parse the chunks.
23:39:22 <cjs> There are several ways to do it, depending on the message format.
23:39:41 <tibbe> b\6: you might be able to use the binary-strict library
23:39:44 <b\6> everything's a line like lkajsdlfkjds\r\n.
23:39:50 <b\6> hmm. checking.
23:39:55 <tibbe> b\6: I would suggest using mine but I haven't published it yet
23:40:01 <cjs> With my market data feed, I read two bytes that give the length of the rest of the message, and so I read that, then that many bytes, then hand those to the parser.
23:40:11 <cjs> Ah, you need to read up to a newline?
23:40:22 <b\6> well, wack dos/windows end of line.
23:40:45 <cjs> Hm. I've not done that yet in Haskell.
23:41:08 <b\6> well, it looks nice in parsec.
23:41:10 <cjs> Oh, wait, yes I have, Data.Binary.Char8 has a getLine.
23:41:26 <Twey> hGetContents doesn't actually read the whole file into memory, does it?
23:41:26 <cjs> What's your data source? A file?
23:41:30 <Twey> 'cause it's lazy.
23:41:32 <tibbe> Twey: no
23:41:33 <b\6> socket/handle.
23:41:34 <cjs> Twey: No. It reads as you need it.
23:41:37 <tibbe> Twey: exactly
23:41:38 <jeffz> b\6, all you should need to change is returning the rest of the input in the Right case
23:41:45 <cjs> b\6: Yes, you Must Not Ever use lazy reads on those.
23:41:49 <Twey> tibbe: So why's it so bad?
23:41:51 <cjs> I've done it twice and both times got nailed.
23:41:54 <tibbe> Twey: so you can delete the file under it half-way through
23:41:58 <glguy> you can return the unused input with parsec
23:42:12 <glguy> No need to get creative
23:42:26 <tibbe> Twey: side-effects appearing at arbitrary points in your programs, no possibility to handle errors, etc
23:42:50 <Twey> Ahh, I see.
23:42:53 <tibbe> Twey: it's easier to do I/O correctly in C than lazy I/O, at least C is strict so you know when they'll occour
23:42:57 <Twey> Yes, that's quite bad.
23:43:06 <glguy> they don't call it unsafeInterleaveIO for nothing
23:43:07 <b\6> glguy: most of the time there won't be any extra because the response will just be one line. how do i get the line to give to parsec without doing hGetContents?
23:43:22 <glguy> hGetLine?
23:43:23 <tibbe> Twey: and you're not guaranteed that any finalizers will run and free resources until the end of the program, so it's pretty much a resource leak
23:43:31 <cjs> b\6: Use Data.ByteString.hGetLine (or System.IO.hGetLine) to read each line, then parse it.
23:43:52 <Twey> @src hGetContents
23:43:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:43:53 <b\6> glguy: it's defective. leaves the \r, doesn't ensure there's a \r\n or \n at all.
23:43:56 <Twey> :<
23:44:19 <cjs> Just change your parser to allow an optional \r at the end.
23:44:19 <Twey> Eh?  What does it do, then, b\6?
23:44:20 <tibbe> b\6: are you doing this over HTTP?
23:44:27 <b\6> tibbe: it's nntp.
23:44:35 <cjs> Or ensure it, if that's what you need.
23:44:42 <tibbe> b\6: ah, ok
23:44:57 <tibbe> b\6: otherwise you could use the content length to read the whole message and no more and then parse it
23:45:04 <b\6> hah, wish i could.
23:45:09 <b\6> this is legacy.
23:45:10 <cjs> Or if you need to deal with data with embedded \ns, then you have a lot more work ahead of you.
23:46:10 <glguy> Prelude Text.ParserCombinators.Parsec> parseTest (digit >> getInput) "3test"
23:46:10 <glguy> "test"
23:46:28 <jeffz> if this is nntp I don't see why you'd want to read a line at a time, that would only make writing a parser harder and more ambiguous
23:46:33 <glguy> Prelude Text.ParserCombinators.Parsec Control.Monad> parseTest (liftM2 (,) digit getInput) "3test"
23:46:33 <glguy> ('3',"test")
23:46:41 <jeffz> some responses are multiline
23:46:43 <glguy> the point being your parse can return the log element
23:46:47 <glguy> and the remaining input
23:46:52 <glguy> to be parsed in some other way
23:47:33 <b\6> glguy: sorry to be dense. what am i passing to parsec to parse?
23:47:41 <glguy> the hGetContents stream
23:47:50 <mmorrow> this would work also:
23:47:52 <b\6> hGetContents closes the handle.
23:47:53 <mmorrow> eitherCRLF a = case span (/='\r') a of (xs,[]) -> Left xs ; (line,"\r\n")-> Right line ; (line,rest) -> (line++) `fmap` (eitherCRLF rest)
23:47:57 <glguy> b\6: so?
23:47:59 <mmorrow> withLine h k = return . k . eitherCRLF =<< hGetLine h
23:48:07 <b\6> so i don't want to reconnect all the time.
23:48:08 <mmorrow> withLine :: Handle -> (Either String String -> a) -> IO a
23:48:11 <jeffz> b\6, it only closes it because you called it twice on the same handle, don't do that.
23:48:27 <b\6> jeffz: what do i pass to parsec the second time?
23:48:33 <b\6> oh, the remainder?
23:48:35 <glguy> yeah
23:48:43 <b\6> ok. knocking on my head.
23:48:47 <jeffz> b\6, the result of the parser is the token/value and the remainder, use the remainder...
23:49:54 <b\6> think i see how it could be ok. can i actually get the hGetContents before the server's sent anything? it'll get updated?
23:50:20 <glguy> b\6: when you inspect your program will block
23:50:25 <glguy> until there is data to be read
23:50:25 <b\6> like s <- hGetContents h; send stuff to server to actually provoke a response; does s have stuff?
23:50:57 <mmorrow> it will when it happens, or it won't happen :)
23:51:52 <mmorrow> just like :
23:52:10 <mmorrow> $ A=`cat` ; echo $A
23:52:25 <mmorrow> (but that's not lazy)
23:52:51 <jeffz> b\6: when you connect to nntp, the protocol says you should read the response before sending anything, so yes, you'd call hGetContents and parsec would attempt to match a valid response
23:54:11 <b\6> what i mean is, is hGetContents giving me a snapshot?
23:54:24 <tibbe> b\6: no
23:54:35 <b\6> or is the s <- somehow getting the newly arriving data?
23:54:42 <mmorrow> yes
23:54:42 <tibbe> b\6: yes
23:54:46 <b\6> wow, ok.
23:54:48 <jeffz> b\6: it's everything that is or will be on the stream
23:54:52 <tibbe> b\6: using unsafeInterleaveIO
23:55:19 * tibbe gets ready for work.
23:55:29 <b\6> thanks.
23:56:07 <b\6> ok, no wonder i didn't get that at first. java etc does not support flying backwards through time with buddha.
23:56:18 <mmorrow> haha
23:56:48 <b\6> need to hang up some gongs and stuff.
23:56:53 <mmorrow> pull out the hallucinogens, it's party time!
