00:13:43 <dolio> Slow night in here.
00:14:13 <BeelsebobWork> @where monad reader
00:14:13 <lambdabot> I know nothing about monad.
00:14:16 <BeelsebobWork> bah
00:16:50 <Pete_I> ghc prints a whole bunch of stuff when i use :browse <module>, is there a way to get it to slow down? maybe a few lines at a time?
00:21:12 <dmwit> not really
00:21:16 <dmwit> But you can use a pager.
00:21:24 <dmwit> echo :browse module | ghci | less
00:21:38 <Pete_I> that'll work, thanks :)
00:22:18 <codacola> for a list of tuples (eg [(Int, Int)]) i should be able to use the pattern "((x,y):(xs, ys))" right?
00:22:21 <Pete_I> also...trying to take input line by line('till it stops); that's not possible without headfirst into the monads is it?
00:22:43 <vixey> :t ((?x,?y):(?xs, ?ys))
00:22:45 <vixey> codecola: no
00:22:55 <Deewiant> codacola: (x,y) : xs would work
00:23:14 <vixey> (x,y) : (unzip -> (xs,ys)) or something with view patterns
00:23:18 <Pete_I> the (xs,ys) wouldn't match []
00:23:20 <Deewiant> but :(xs, ys) is always wrong since what follows : should be a list
00:23:24 <Deewiant> and (xs,ys) is a pair
00:23:32 <codacola> oh yeah
00:23:35 <codacola> thanks
00:23:50 <Pete_I> could (x,y):(xs,ys):[]
00:24:01 <Pete_I> i think
00:24:40 <Deewiant> yes, that's the same as (x,y) : [(xs,ys)] or [(x,y), (xs,ys)]
00:25:02 <codacola> ah i see
00:46:09 <BeelsebobWork> @seen luqui
00:46:09 <lambdabot> I saw luqui leaving #haskell and #perl6 45m 23s ago, and .
00:49:33 <halberd> I was just learning about the concept of tree decomposition of a graph, which is not what I expected
00:51:56 <halberd> before reading about the way it's actually done, my intuitive thought was that a tree decomposition would be a mapping f of nodes in a graph G onto nodes in a tree T, such that two nodes g and g' in G are adjacent only if f(g) and f(g') are adjacent in T, or possibly f(g) = f(g')
00:52:15 <halberd> does that similar idea have any name/uses?
00:52:46 <vixey> halberd: Impossible .. ?
00:53:13 <halberd> huh?
00:54:43 <halberd> are you asking if I meant to say "impossible" instead of "possibly"?
00:55:00 <vixey> I think what you described is impossible
00:55:37 <halberd> well if G is a tree, then f could be the identity and it would be possible
00:56:04 <vixey> what if G is not a tree?
00:56:16 <Pete_I> what module is "comparing" in?
00:56:18 <halberd> and if G is any graph you could let T be a tree containing just the single node t and let f map everything to t
00:56:27 <TSC> Pete_I: Data.Ord, I think
00:56:28 <vixey> @hoogle comparing
00:56:28 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:56:32 <TSC> @index comparing
00:56:32 <lambdabot> bzzt
00:56:35 <TSC> Bah
00:58:38 <halberd> for a non-trivial example, if G has paths A -> B -> C -> A and C -> D -> E -> C then you could let T the path X -> Y -> Z and let f(A) = f(B) = X, f(C) = Y, f(D) = f(E) = Z
00:59:32 <halberd> where A -> B means "A has an edge to B"
01:04:36 <opqdonut> halberd: a vertex cover is what you are looking for
01:05:00 <halberd> no it isn't
01:08:55 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.5
01:08:55 <hackage> Uploaded to hackage: lighttpd-conf 0.4
01:09:56 <MarcWeber> @seen dons
01:09:56 <lambdabot> dons is in #haskell, #ghc, #xmonad and #arch-haskell. I last heard dons speak 1h 45m 56s ago.
01:10:36 <MarcWeber> dons: Does a patch already exist to make plugins compile with recent ghc and cabal?
01:19:28 <Armored_Azrael> Is there a good way to derive read/show for something in a binary library?
01:20:10 <Armored_Azrael> (Specifically, I'm wondering if I can derive read/show for BaudRate in System.Posix.Terminal without making a custom version)
01:23:24 <sjanssen> @google ghc stand alone deriving
01:23:26 <lambdabot> No Result Found.
01:24:19 <sjanssen> Armored_Azrael: http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#stand-alone-deriving
01:24:20 <lambdabot> Title: 7.4.�Type system extensions, http://tinyurl.com/25mnwa
01:24:57 <Armored_Azrael> Thanks
01:29:13 <Armored_Azrael> deriving Show for BaudRate
01:29:13 <Armored_Azrael> gives a parse error
01:34:05 <Pete_I> damn, lambdabot's pretty awesome for it's length
01:37:56 <vixey> length? in what
01:38:05 <codacola> code im guessing
01:38:13 <opqdonut> anyone have pointers for making small haskell executables?
01:38:47 <dolio> Strip?
01:38:56 <opqdonut> does Prelude get linked entirely or just the parts that are used?
01:39:19 <dolio> Not sure.
01:39:41 <jeffz> opqdonut: I upx my cgi programs
01:40:06 <dolio> The 6.10 roadmap has something about shared libraries on it, so maybe it will get better then.
01:41:17 <dolio> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
01:41:19 <lambdabot> Title: Status/Releases - GHC - Trac
01:41:26 <dolio> "Binaries get much smaller"
01:42:05 <opqdonut> dynamic is no help, I'm afraid
01:42:17 <opqdonut> I can't count on ghc libs being on the target
01:42:41 <dolio> Ah, that'd be an issue, then.
01:43:33 <opqdonut> I should probably be asking this in #ghc
01:43:50 <dolio> That might be more helpful, yes.
01:44:04 <dolio> You could see if JHC builds your program. :)
01:44:16 <dolio> It produces small executables.
01:44:51 <opqdonut> hmm, good point
01:45:06 <dolio> I wouldn't count on it, though. :)
01:47:06 <opqdonut> ah, yes, jhc seems very suitable
01:47:13 <opqdonut> I hope it'll prove mature enough
01:47:34 <opqdonut> I'm toying around with making something embeddedish with haskell
01:47:39 <opqdonut> just as a proof of concept
01:47:57 <Lamperi> haxell
01:48:02 <dolio> Ah. Interesting.
02:03:48 <sjanssen> opqdonut: do you know if your libraries will built as split objects?
02:04:03 <opqdonut> sjanssen: hmm?
02:04:14 <opqdonut> i'll probably be using only the Prelude or something
02:04:24 <opqdonut> maybe some custom ffi
02:04:30 <sjanssen> it can also be helpful to build with -optl-Wl,-s
02:04:51 <sjanssen> opqdonut: right, do you know if your base library was built with split objects turned on
02:05:33 <opqdonut> sjanssen: ah, no I don't
02:05:48 <opqdonut> slpit objects means object-per-module or something?
02:06:19 <opqdonut> ah, one per top-level function
02:06:20 <opqdonut> sweet
02:08:16 <sjanssen> "-optl-Wl,-s" is like a poor man's split objects, and is apparently a bit better than strip
02:08:36 <Armored_Azrael> Is there a way to catch IO exceptions in a (StateT Something IO) Monad? Catch doesn't seem to work
02:08:49 <tibbe> Armored_Azrael: you'll have to use lift
02:08:56 <hackage> Uploaded to hackage: ghc-paths 0.1.0.4
02:09:20 <tibbe> Armored_Azrael: http://www.johantibell.com/cgi-bin/gitweb.cgi?p=hyena.git;a=blob;f=Hyena/Server.hs;h=092dfb41c6afc34708028bd4732502c90902ca11;hb=HEAD
02:09:22 <lambdabot> Title: www.johantibell.com Git - hyena.git/blob - Hyena/Server.hs, http://tinyurl.com/5b32cp
02:09:29 <tibbe> Armored_Azrael: look at catchServer ^^
02:09:34 <opqdonut> sjanssen: ok, thanks for the pointers
02:09:54 <Armored_Azrael> tibbe: Thanks
02:13:23 <tibbe> Armored_Azrael: you're welcome
02:15:15 <hml> i realixe i can find this via hadock, but i want to see if ian find this usnig GOA
02:15:25 <hml> so basically, i want to find the equiv of pushMatrix / popMatrix in the opengl/glut/glfw libraries
02:15:34 <hml> but hoogling for pushMatrix and matrix brings me nothing
02:15:38 <hml> how should i be searching for this via goa
02:16:20 <quicksilver> hml: you should be searching for it by asking here.
02:16:24 <quicksilver> the answer is preservingMatrix
02:16:40 <hml> yeah; just found this:
02:16:41 <hml> http://www.mail-archive.com/haskell-cafe@haskell.org/msg36761.html
02:16:43 <lambdabot> Title: [Haskell-cafe] Re: Draft chapters of "Real World Haskell" now publicly a, http://tinyurl.com/5luykd
02:16:47 <hml> which also mentioend that
02:17:01 <hml> but i guess the right answer is, GOA won't find it for me gbecause i'm lookiikng for the wrong idea?
02:17:07 <quicksilver> I don't know why hoogle for 'matrix' doesn't work.
02:18:24 <hml> i'm almost tempted to blame my installgino of hoogle:
02:18:25 <hml> x@x:~$ hoogle preservingMatrix
02:18:25 <hml> No results found
02:18:29 <hml> but hoogle map works fine
02:18:41 <hml> @hoogle preservingMatrix
02:18:42 <lambdabot> No matches found
02:18:46 <hml> @hoogle matrix
02:18:47 <lambdabot> No matches found
02:18:52 <hml> nope, not my fault
02:18:59 <hml> @src preservingMatrix
02:18:59 <lambdabot> Source not found. Sorry.
02:19:01 <hml> @hoogle map
02:19:02 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
02:19:02 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
02:19:02 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
02:19:17 <dolio> Maybe there aren't hoogle databases built for the GL libraries?
02:19:20 <mightybyte> k
02:19:35 <hml> are these manually buyilt? or can i juyst run a command ahd have them build automatically?
02:19:54 <dolio> I don't know. I've never run hoogle locally.
02:23:03 <thoughtpolice> there's a way to do it but you would have to ask ndm
02:23:12 <thoughtpolice> (at least I think there is...)
02:26:38 <thoughtpolice> hml: using hayoo
02:26:39 <thoughtpolice> I found this
02:26:48 <thoughtpolice> http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html
02:26:49 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.CoordTrans, http://tinyurl.com/66y4tc
02:26:54 <thoughtpolice> seems to be what you want?
02:32:39 <hml> thoughtpolice: thanks
02:33:26 <BeelsebobWork> @hoogle Monad m => Data.Map.Map k a -> (a -> m b) -> m (Data.Map.Map k b)
02:33:27 <lambdabot> No matches, try a more general search
02:33:30 <BeelsebobWork> bah
02:34:18 <BeelsebobWork> @src mapM
02:34:18 <lambdabot> mapM f as = sequence (map f as)
02:35:23 <BeelsebobWork> @hoogle Monad m => Data.Map.Map k (m a) -> m (Data.Map.Map k a)
02:35:23 <lambdabot> No matches, try a more general search
02:35:43 <BeelsebobWork> arse bisquits
02:35:50 * BeelsebobWork ponders how easy that is to do
02:39:27 <dolio> @type Data.Traversable.sequence :: (Monad m) => M.Map k (m a) -> m (M.Map k a)
02:39:30 <lambdabot> forall k (m :: * -> *) a. (Monad m) => M.Map k (m a) -> m (M.Map k a)
02:40:04 <BeelsebobWork> ah, genious
02:40:09 <BeelsebobWork> thanks dolio
02:40:21 <dolio> No problem.
02:40:24 <MarcWeber> Is the ghc lib compiled with profiling support by default?
02:40:54 <thoughtpolice> MarcWeber: I believe gwern brought that up and no I don't think so (he wanted to profile mueval)
02:41:48 <MarcWeber> gwern: Do you recall instantly how to make ghc compile ghc with profiling support?
02:55:58 <pozic> Is there some library that can pretty-print columns of data?
02:58:24 <vixey> > 1 + 2 + 4 + 8 + 16
02:58:27 <lambdabot>  31
03:09:10 <BeelsebobWork> gah, anyone got any idea what function can produce "Error in array index"
03:09:17 <BeelsebobWork> (obviously something in Data.Array... but what)
03:09:39 <vixey> @src (!)
03:09:39 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
03:09:52 <vixey> @src unsafeAt
03:09:52 <lambdabot> Source not found.
03:09:58 <vixey> @src index
03:09:59 <lambdabot> Source not found. I've seen penguins that can type better than that.
03:10:24 <BeelsebobWork> (!) doesn't produce it normally -- it normally gives something about array index out of bounds IIRC
03:12:27 * BeelsebobWork ponders if it's actually DevIL producing the error
03:15:49 <Deewiant> backtraces for "error" errors would be nice
03:16:07 <Deewiant> and exceptions in general I guess
03:19:24 <BeelsebobWork> backtraces aren't possible in a graph reduction machine though
03:19:28 <BeelsebobWork> because there's no stack
03:19:42 <BeelsebobWork> or rather -- they're not possible without not garbage collecting anything
03:20:51 * EvilTerran could envisage using the "linear implicit parameters" thing to hack stack traces
03:21:03 <BeelsebobWork> true dat
03:21:21 <BeelsebobWork> would probably add a lot of overhead -- something for -prof -auto-all
03:24:48 <EvilTerran> yeah
03:25:26 * EvilTerran was thinking something like wrapping your cost centres "foo = ..." to "foo = let ?stack = "foo" : ?stack in ..."
03:32:55 <lilac> > listArray (0,100) [0..] ! (-12) -- BeelsebobWork
03:32:56 <lambdabot>  Exception: Error in array index
03:33:08 <BeelsebobWork> interesting
03:33:21 <lilac> > listArray (0,100) [0..] ! 105
03:33:22 <lambdabot>  Exception: Error in array index
03:33:28 <vixey> > undefined ! (-1)
03:33:29 <lambdabot>  Exception: Prelude.undefined
03:33:58 <lilac> possibly the error is different in different versions of the libraries?
03:34:35 <BeelsebobWork> perhaps, yeh
03:36:16 <quicksilver> BeelsebobWork: that's not quite true (back traces not possible without not gargbage collecting anything)
03:36:35 <quicksilver> BeelsebobWork: maintain the info you need for a stack trace is quite a long way short of not GC'ing *anything*
03:36:43 <BeelsebobWork> true
03:37:05 <quicksilver> but certainly it is a very substantial overhead
03:37:14 <quicksilver> as opposed to being 'almost free' in C-like languages
03:37:24 <BeelsebobWork> it would also cause a lot of programs to explode
03:37:34 <quicksilver> (you have a stack frame anyway and it's trivial to look up symbols from addresses)
03:37:34 <BeelsebobWork> e.g. programs that rely on tail recursion getting unrolled into loops
03:37:39 <BeelsebobWork> becuase they would no longer get unrolled
03:39:23 <quicksilver> they could get unrolled
03:39:32 <BeelsebobWork> how?
03:39:34 <quicksilver> just transform the stacktrace into an accumulating parameter
03:39:41 <BeelsebobWork> I guess, yeh
03:40:03 <BeelsebobWork> still -- that's gonna be one *big* accumulation
03:40:11 <quicksilver> true enough
03:40:18 <quicksilver> distinctly non-trivial overhead
03:40:32 <quicksilver> but might be a price you're willing to (optionally, subject to a command line parameter) pay sometimes
03:40:45 <BeelsebobWork> that's true enough
03:40:47 <lilac> if you added the backtrace stuff as a fairly late pass, it could work
03:41:53 <BeelsebobWork> anyway, if you ask me, the right way to do that is with a proper tracer
03:41:56 <BeelsebobWork> but hey, that's me
03:44:57 <dolio> You could just do TCO and not worry about it.
03:45:08 <dolio> You don't get traces of what iteration of a loop you're on in C.
03:45:16 <Asgaroth> What's the best way to find the value in a list for which (f val) is maximized? I have a solution, but it seems rather ugly.
03:45:32 <dolio> @type maximumBy
03:45:33 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:45:41 <Asgaroth> thanks
03:45:55 <vixey> Asgaroth: I'm curious, what is the ugly way?
03:46:24 <Asgaroth> vixey: Using foldr and passing some pairs around between the calls
03:46:34 <mattr__> I got my ghc-user mailing list digest today - why did they drop darcs?
03:46:38 <vixey> @src maximumBy
03:46:38 <lambdabot> Source not found. :(
03:47:13 <dolio> Any solution using maximumBy will recompute f val several times for some elements, I think.
03:47:23 <dolio> To avoid that, you'd need to do a Schwartzian transform.
03:47:48 <vixey> Asgaroth,
03:47:49 <vixey> maximumBy max xs        =  foldl1 max xs
03:48:04 <vixey> maximumBy               :: (a -> a -> Bool) -> [a] -> a
03:48:13 <vixey> odd....
03:48:25 <vixey> why is the type in http://www.haskell.org/haskell-report/List.html
03:48:25 <lambdabot> Title: The Haskell 1.3 Library Report: List Utilities
03:48:29 <vixey> different from that one?
03:48:31 <Asgaroth> strange, the ghc docs say it's: maximumBy :: (a -> a -> Ordering) -> [a] -> a
03:49:09 <vixey> @hoogle maximumBy
03:49:09 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
03:49:09 <lambdabot> Data.Foldable.maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
03:49:57 <dolio> That defintion doesn't make much sense for that type.
03:50:25 <vixey> :t foldl1 ?max ?xs
03:50:25 <lambdabot> forall a. (?xs::[a], ?max::a -> a -> a) => a
03:50:45 <vixey> :t \max xs        ->  foldl1 max xs
03:50:45 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:50:50 <vixey> lol
03:51:00 <vixey> so that's a bug in the haskell report?
03:51:11 <dolio> Evidently.
03:51:24 <vixey> wtf :/
03:51:37 <vixey> they should have used a type safe language™
03:52:14 <dolio> @type List.maximumBy
03:52:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:52:57 <dolio> That's the Haskel 1.3 library report you linked to, by the way.
03:52:59 <rwbarton> Wait, where does it say maximumBy :: (a -> a -> Bool) -> [a] -> a?
03:53:13 <vixey> http://www.haskell.org/haskell-report/List.html
03:53:13 <lambdabot> Title: The Haskell 1.3 Library Report: List Utilities
03:53:13 <rwbarton> Oh, I see
03:53:22 <rwbarton> http://www.haskell.org/onlinereport/list.html seems to have fixed it
03:53:22 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
03:53:56 <vixey> oh
03:54:36 <vixey> " Some half dozen persons have written technically on combinatory logic, and most of these, including ourselves, have published something erroneous. Since some of our fellow sinners are among the most careful and competent logicians on the contemporary scene, we regard this as evidence that the subject is refractory. Thus fullness of exposition is necessary for accuracy; and excessive condensation would be false economy here, even more than it is ordinari
04:08:01 <MarcWeber> @tell dons I've patched hs-plugins so that it compiles with recent ghc and cabal.. I haven't done much testing yet, maybe you are interested in it though?
04:08:01 <lambdabot> Consider it noted.
04:09:19 <painy> howdy haskellers
04:12:11 <profmakx> hm. MarcWeber for what values of recent?
04:15:33 <MarcWeber> ghc-6.8.2 and cabal darcs version @ profmakx
04:15:53 <profmakx> hasnt Cale done something similar already?
04:16:09 <profmakx> except for al small configure glitch hs-plugins built fine for me yesterday
04:16:25 <MarcWeber> ping Cale
04:19:34 * shapr yawns
04:20:39 <shapr> @quote
04:20:39 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
04:20:45 * vixey snoozes
04:25:50 <therp> is anyone using Agda for daily programming tasks?
04:40:45 <pozic> Why is there no syntax to do type-constructor composition in the definition of instances?
04:44:54 <vixey> therp, don't think so..
04:44:55 <Baughn> pozic: Er? Like how?
04:46:41 <MarcWeber> Does this make any sense in a calss definition?
04:46:42 <MarcWeber>   cgiPutList h xs = cgiPutList h xs
04:47:02 <pozic> MarcWeber: it's undefined.
04:47:07 <Baughn>  MarcWeber Only if you desire an infinite loop
04:48:53 <nominolo> therp: i doubt that's practical, yet
04:49:12 <MarcWeber> Baughn: It can be found in the WASH library.. and in general the author knows how to write haskell. So I'm wondering why has written it this way
04:49:50 <Baughn> MarcWeber: If that is what it says, then I can only imagine it's a mistake
04:50:03 <Baughn> It's obviously an infinite loop. Not even fix or something.
04:50:43 <nominolo> Baughn: why? doesn't it call the "inherited" cgiPutList?
04:51:02 <Toxaris_> nominolo: nope because the arguments aren't changed
04:51:08 <vixey> wait
04:51:21 <rwbarton> could it be possible that the right hand side has a more general type, and it gets covered by an overlapping class instance?
04:51:24 <vixey> it will be replaced by all instances
04:51:47 <rwbarton> Oh, it's in a class definition, sorry
04:51:50 <Baughn> nominolo: Recursive bindings work, so the cgiPutList on the right-hand side is the same as on the left-hand side
04:52:16 <nominolo> Baughn: right, but what happens in the case of overlapping instances?
04:52:31 <Baughn> nominolo: I have no idea. actually..
04:52:34 <nominolo> Baughn: ok, well, in that case it's probably undefined/unpredictable
04:52:47 <Baughn> MarcWeber: Did you say you found that in a class definition? As in, it's the default method?
04:52:51 <rwbarton> I mean, I really hope the answer isn't that the author is being tricky about use of overlapping instances :)
04:53:04 <quicksilver> overlapping isn't unpredictable
04:53:06 <MarcWeber> http://rafb.net/p/uhN5kV56.html
04:53:07 <lambdabot> Title: Nopaste - No description
04:53:11 <quicksilver> incoherent might be?
04:53:24 <quicksilver> overlapping is quite predictable if you understand the rules (which, incidentally, I don't)
04:53:32 <Toxaris_> looks like an error to me
04:53:38 <nominolo> quicksilver: it could depend on the module you're in (maybe even the import order?)
04:53:53 <Baughn> Mm. That *has* to be the equivalent of saying "cgiPutList h xs = undefined"
04:53:58 <rwbarton> It could just be the author didn't want to get warning about instances that didn't override that method.  But I would usually put an error instead
04:53:59 <Baughn> Except with more infinite loop, and less error
04:54:08 <vixey> Baughn, yeah same type at least
04:54:17 <Toxaris_> I would expect this: cgiPutList h xs = mapM_ (cgiPut' h) xs
04:54:18 <Baughn> vixey: Same value too. It's bottom. ;)
04:54:30 <vixey> hum
04:54:34 <vixey> undefined is really bottom?
04:54:39 <Toxaris_> or something like that
04:54:40 <Baughn> All errors are bottom
04:54:44 <vixey> oh ok
04:55:02 <Toxaris_> some bottoms are reported in finite time by the run-time system
04:55:10 <Toxaris_> > let x = x in x
04:55:14 <nominolo> they are denotationally equivalent (though probably not operationally) (or something)
04:55:26 <lambdabot>  thread killed
04:55:38 <Toxaris_> but not the bottoms I write, apparently
04:55:50 <Baughn> It is if it's compiled with -threaded
04:55:59 <Baughn> Problem is, LB doesn't report errors
04:56:10 <Baughn> ..At least this one doesn't. Mine does just fine. Same code, too. ^^;
04:56:52 <nominolo> @users
04:56:52 <lambdabot> Maximum users seen in #haskell: 484, currently: 442 (91.3%), active: 12 (2.7%)
05:01:15 <Armored_Azrael> What's the generic delimiter form of words again?
05:01:44 <rwbarton> There isn't one in the standard libraries
05:01:57 <Armored_Azrael> ok
05:04:53 <BeelsebobWork> Does anyone see a reason why http://hpaste.org/9423 should produce a green texture, rather than a white one?
05:09:24 <ski> > error "error"
05:09:26 <lambdabot>  Exception: error
05:09:52 <BeelsebobWork> > error ":noitpecxE"
05:09:54 <lambdabot>  Exception: :noitpecxE
05:10:06 <ski> > fix error
05:10:09 <rwbarton> > error (error "error")
05:10:10 <lambdabot>  Exception: error
05:10:21 <lambdabot>  thread killed
05:10:56 <rwbarton> > error ("error" ++ error "error")
05:10:57 <lambdabot>  Exception: errorException
05:11:06 <ski> good job
05:11:14 <camio> BelsebobWork: Could it be that width*height*3 should be width*height*4 since you're doing RGBA?
05:12:59 <BeelsebobWork> camio: thats the target texture format though
05:13:07 <BeelsebobWork> the pixel data's defined as RGB
05:13:17 <camio> hrm...
05:13:21 <BeelsebobWork> plus -- if I change the internal format to RGB' it does the same thing
05:14:07 <rwbarton> BeelsebobWork: maybe you have green lighting or something? how are you viewing this texture?
05:14:37 <BeelsebobWork> rwbarton: it's neutral lighting -- if I disable Texture2D, I can use colour calls to make it red/blue/whatever
05:15:42 <rwbarton> does anything happen if you use those calls as well as Texture2D?  (if that's possible)
05:16:05 <camio> Bob, what happens if you comment out the pokeElemOff sequence_?
05:16:26 <BeelsebobWork> it is possible -- and no, with a 100% opaque texture it doesn't have any effect rwbarton
05:16:30 <BeelsebobWork> camio: good question -- *tries*
05:17:05 <rwbarton> ok, just speculating wildly :)
05:17:26 <BeelsebobWork> camio: blackness -- which makes sense if the memory happens to contain lots of zeros before hand
05:17:34 <BeelsebobWork> rwbarton: np, random speculation atm is good
05:18:09 <camio> Bob: cool
05:18:40 <camio> Bob: So what happens if you change 255 to 0 in that statement?
05:19:08 <SamB_XP> camio: I imagine the same thing happens ;-)
05:19:17 <SamB_XP> (black)
05:19:52 <rwbarton> BeelsebobWork: maybe p is getting the wrong type?  can you try s/pokeElemOff/pokeByteOff/ ?
05:20:19 <BeelsebobWork> rwbarton: good idea
05:20:28 <pozic> How can I define a method superMap such that superMap (+1) [[[1::Int]]] returns [[[2]]] that works for every level of nesting?
05:20:44 <SamB_XP> in that case shouldn't he be corrupting RAM ?
05:21:14 <BeelsebobWork> rwbarton: still green
05:21:29 <BeelsebobWork> so looks like it gets the right type
05:22:44 <Lemmih> pozic: Use a tree?
05:22:49 <rwbarton> I'm stumped.  You could try making it other colors, and see if there is a pattern relating the color you intend and the color it turns out to be
05:23:14 <BeelsebobWork> rwbarton: yeh, I tried other colours -- making it green deliberatey makes it green
05:23:23 <BeelsebobWork> making it either red or blue, causes it to be black
05:23:31 <rwbarton> I see...
05:23:32 <camio> That's a nice clue
05:23:33 <BeelsebobWork> yellow or cyan makes it green
05:23:38 <BeelsebobWork> and magenta makes it black
05:23:48 <SamB_XP> BeelsebobWork: you are certain about the lighting?
05:23:55 <BeelsebobWork> SamB_XP: dead certain, yes
05:23:59 <SamB_XP> also, is your monitor correctly connected ?
05:24:06 <BeelsebobWork> SamB_XP: lol
05:24:24 <rwbarton> :) He said he could make it other colors using a different API function.
05:24:39 <camio> Bob, if you make it 128 instead of 255 does it get to a semi-green state?
05:24:46 <BeelsebobWork> camio: oh, good thought
05:24:49 <SamB_XP> oh yeah, true, I guess that means his monitor is hooked up correctly
05:25:02 <ski> pozic> superMap (+1) (1::Int)
05:26:05 <rwbarton> pozic: You could do it using type classes and overlapping instances
05:26:05 <BeelsebobWork> camio: yes, it does become semi-green
05:26:09 <BeelsebobWork> random other thing I tried
05:26:14 <BeelsebobWork> I tried making it RGBA
05:26:23 <BeelsebobWork> then the green and alpha channel got attention paid to them
05:26:27 <BeelsebobWork> but blue/red still didn't
05:26:32 <camio> okay
05:26:47 <camio> This is a fun puzzle.
05:27:04 <SamB_XP> are you sure the format is not planer?
05:27:22 <BeelsebobWork> SamB_XP: hmm, wouldn't that make it grey though?
05:27:32 <pozic> ski: right, the problem is that the instances overlap when it hits bottom recursively, but I think I know how to handle that now.
05:27:39 <BeelsebobWork> or rather, grey and dotty
05:27:57 <quicksilver> BeelsebobWork: what values of width and height?
05:28:09 <quicksilver> BeelsebobWork: and FWIW using peek/poke is very clumsy compared to using withArray
05:28:22 <ski> pozic : why do you need this ?
05:28:27 <BeelsebobWork> quicksilver: (width,height,mindepth) is (800,640,3)
05:28:39 <BeelsebobWork> quicksilver: possibly -- but don't I need the array to be storable?
05:28:56 <quicksilver> fortunately [Color4] is storable
05:28:59 <quicksilver> so is [Color3]
05:29:10 <BeelsebobWork> no Color3/Color4 here
05:29:17 <quicksilver> yes, but you could be using them ;)
05:29:18 <BeelsebobWork> UArray (Int,Int,Int) Word8
05:29:31 <BeelsebobWork> I could -- but that would involve the same conversion of arrays
05:29:37 <BeelsebobWork> because I get the data from a library in this format
05:29:55 <quicksilver> perhaps your graphics card doesn't support non power-of-two textures?
05:30:02 <rwbarton> BeelsebobWork: are you sure you're not supposed to give 16 bits per pixel?
05:30:02 <BeelsebobWork> could be
05:30:09 <rwbarton> per color, I mean
05:30:16 * BeelsebobWork generates a 512x512 texture
05:30:28 <rwbarton> That wouldn't really explain this, though
05:30:31 <quicksilver> RGB UnsignedByte is 8 bits per colour, rwbarton
05:30:31 <BeelsebobWork> rwbarton: pretty sure -- it's only *very* recently that 64 bit colour's been coming in
05:30:37 <rwbarton> Oh, I see
05:30:52 <pozic> ski: nesting calls to map gets boring when working with table data.
05:31:04 <ski> mhm
05:31:35 <rwbarton> pozic: You could define map2 = map . map, map3 = map . map . map, etc.
05:31:41 <camio> Bob: The third argument to texImage2D seems like it shouldn't be 0. http://opengl.org/documentation/specs/man_pages/hardcopy/GL/html/gl/teximage2d.html
05:31:41 <BeelsebobWork> quicksilver: same result with a 512x512 texture
05:31:43 <lambdabot> http://tinyurl.com/5tsc4o
05:31:56 <lilac> BeelsebobWork: does it work if you use a texture loaded from a file?
05:32:00 <BeelsebobWork> camio: texImage2D is different to glTexImage2D
05:32:18 <BeelsebobWork> lilac: if I load from a file (the commented out bit) I get only the green channel from the file
05:32:24 <vixey> or
05:32:27 <ski> data NestedList a = Here a | Nest (NestedList [a])
05:32:34 <ski> instance Functor NestedList
05:32:39 <vixey> ski, ahh, you are too quick!
05:32:47 <ski> vixey ;)
05:32:54 <camio> @hoogle texImage2D
05:32:55 <lambdabot> No matches found
05:33:05 <pozic> rwbarton: I kind of like abstraction.
05:33:13 <BeelsebobWork> camio: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-Texturing-Specification.html#v%3AtexImage2D
05:33:14 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.Texturing.Specification, http://tinyurl.com/28pzsb
05:33:25 <BeelsebobWork> 3rd argument is level -- 0 specifies no buggering about with mip mapping
05:33:34 <pozic> ski: there is a mailing list topic about it on the caml list.
05:33:36 <quicksilver> BeelsebobWork: I am more inclined to suspet something wrong with your rendering code
05:33:47 <pozic> ski: that suggests the same, but is a work around.
05:33:49 <quicksilver> BeelsebobWork: I have very nearly identical texture generation code to your paste
05:33:53 <quicksilver> BeelsebobWork: and it works fine
05:33:56 <BeelsebobWork> hmm
05:34:15 <ski> fmap (+1) (Nest . Nest . Nest . Here $ [[[1::Int]]]) = Nest . Nest . Nest . Here $ [[[2]]]
05:34:38 <ski> pozic : if you say so
05:34:39 <BeelsebobWork> quicksilver: the renedering code is fairly obvious...
05:34:39 <vixey> BeelsebobWork: Then you should set the glTexParameter of MIN and MAG filter to GL_LINEAR
05:34:40 <BeelsebobWork> http://hpaste.org/9423#a1
05:35:26 <BeelsebobWork> vixey: I'll give that a go
05:36:02 <lilac> BeelsebobWork: what if you use readImage to load the file and create the PixelData? does that help?
05:36:11 <vixey> pozic: It sounds like you want to do dynamic/untyped programming
05:36:22 <BeelsebobWork> lilac: readImage?
05:36:40 <BeelsebobWork> lilac: fwiw, I know that the array I create contains sensible stuff
05:36:49 <BeelsebobWork> in that I can read it in, and dump out a file of a different format
05:36:51 <BeelsebobWork> and get the same image
05:37:08 <camio> Bob, what does RGBA' mean?
05:37:21 <gwern> MarcWeber: so far as I know, to compile ghc api with profiling, see [[GHC API]] on hawiki
05:37:24 <lilac> BeelsebobWork: according to t'interwebs, there's a function called readImage in a module called ReadImage somewhere inside HOpenGL.
05:37:53 <CosmicRay> any hugs people here that can help me troubleshoot a segfault in hugs?
05:37:56 <BeelsebobWork> camio: it means that it should be stored in RGBA format on the graphics card
05:38:06 <gwern> lilac: I wonder what that does?
05:38:28 <Jedai> pozic: Maybe you want generic programming, then try Scrap Your Boilerplate
05:38:30 <BeelsebobWork> @google Graphics.Rendering.OpenGL readImage
05:38:32 <lambdabot> No Result Found.
05:38:56 <quicksilver> BeelsebobWork: just pasted some code I use which works
05:39:00 <quicksilver> BeelsebobWork: maybe you can stare at it
05:39:11 <BeelsebobWork> quicksilver: oh, cool, thanks
05:39:20 <fdsg> hi
05:39:21 <quicksilver> http://hpaste.org/9424
05:39:21 <rwbarton> pozic: Actually, I'm no longer certain you can do this with type classes
05:39:27 <lilac> gwern: what it does is apparently fail to actually exist. :(
05:39:29 <quicksilver> BeelsebobWork: it's really very similar to what you said.
05:39:47 <quicksilver> lilac: there certainly is no such thing
05:39:53 <quicksilver> I don't know which interwebs gave you that idea.
05:40:04 <quicksilver> I use WX to load images.
05:40:24 <vixey> hello
05:40:33 <camio> Bob, I'm curious. If you change the RGB part of "let pd ="... to Blue what happens?
05:40:39 <lilac> quicksilver: "Sven Panne's ReadImage module"
05:40:56 <quicksilver> BeelsebobWork: Hmm. I have a thought. I bet something is getting padded from 8 bits to 32 bits
05:41:06 <quicksilver> BeelsebobWork: resulting in only the green channel being 'seen'
05:41:10 <lilac> quicksilver: linked from here http://www.haskell.org/~pairwise/HOpenGL/HOpenGL.html
05:41:11 <BeelsebobWork> quicksilver: could be
05:41:11 <quicksilver> verything else gets padded out
05:41:14 <lilac> or rather, not linked :(
05:41:24 <BeelsebobWork> quicksilver: would make sense if it was 16 bits actually
05:41:43 <lilac> http://home.arcor.de/chr_bauer/topkata/ReadImage.hs
05:41:44 <BeelsebobWork> in that 255 would get output as 0x00 0xff
05:41:47 <paulrd> got stuck building ghc-6.9.20080719 from source bundle on Ubuntu 8.04
05:41:49 <paulrd> $./configure
05:41:50 <BeelsebobWork> which would fill in green and alpha
05:41:51 <paulrd> ...
05:41:53 <paulrd> checking for path to top of build tree
05:41:55 <paulrd> ./configure: line 2696: utils/pwd/pwd: cannot execute binary file
05:41:57 <paulrd> any hints how to fix it? thanks
05:42:00 <quicksilver> lilac: yeah it's not part of HOpenGL
05:42:01 <camio> quicksilver: Wouldn't that result in blue?
05:42:05 <quicksilver> although it was written by the same man
05:42:19 <lilac> quicksilver: fair enough :)
05:42:30 <rwbarton> paulrd: Try deleting that file and running configure again
05:42:33 <quicksilver> BeelsebobWork: one reason why the withArray method is cleaner :)
05:42:46 <quicksilver> BeelsebobWork: build an array of [Color3 GLubyte]
05:42:51 <quicksilver> then you can be sure it will do the right hting
05:42:59 <paulrd> rwbarton: thanks - i'll try that
05:43:14 <BeelsebobWork> camio: for reference, filling in Blue causes a seg fault
05:43:14 <lilac> BeelsebobWork: fwiw, that ReadImage thing appears to be doing the same thing as your code.
05:43:29 <camio> Bob: Another thought. Should the second argument of PixelData be ThreeBytes?
05:44:11 <paulrd> rwbarton: that worked :-) thanks very much
05:44:36 <BeelsebobWork> pretty sure it shouldn't camio -- quicksilver is doing the same in his code
05:44:48 <quicksilver> camio: No.
05:44:54 <quicksilver> camio: see http://hpaste.org/9424
05:44:57 <quicksilver> (which works)
05:45:44 <Xandroc> Hello, I try to import the module XMPP in the directory XMPP with "import XMPP.XMPP" (filename is XMPP.hs). But i get the following error:
05:45:44 <Xandroc> "XMPP/XMPP.hs:1:7: file name does not match module name `XMPP'
05:45:44 <Xandroc> Failed, modules loaded: none."
05:45:44 <Xandroc> Any ideas? Thanks for help!
05:46:20 <rwbarton> Xandroc: That'll only work if XMPP.hs says "module XMPP.XMPP" at the top
05:46:42 <quicksilver> BeelsebobWork: I just think withArray / [Color3] is less likely to lead to weird errors that pokeElemOff :)
05:46:52 <Xandroc> Oh yes
05:46:57 <Xandroc> thank you rwbarton :)
05:47:01 <Xandroc> it works now
05:47:03 <BeelsebobWork> quicksilver: yeh, I'm hacking up something to go to withArray atm
05:47:29 <quicksilver> BeelsebobWork: having said that I'd still like to undesrtand why your code doesn't work.
05:49:11 <quicksilver> BeelsebobWork: would be interesting to dump some of the memory pointed to by 'p' and see if it is, indeed, all 255s or not.
05:50:21 <Baughn> Xandroc: As a sidenote, you're allowed to have module XMPP /and/ XMPP.foo, XMPP.bar, etc.
05:50:37 <Baughn> Xandroc: I'm saying that because "import XMPP.XMPP" sounds a bit silly
05:50:44 <Xandroc> ok^^
05:50:45 <Xandroc> thx
05:50:50 <camio> Bob: Can you do something like print . sum =<< sequence (map (peekByteOff p >>= return.fromIntegral) [0..size]?
05:51:31 <Baughn> Xandroc: Oh, and it should probably be Network.XMPP, not just XMPP
05:53:57 <Xandroc> ok
05:55:42 <BeelsebobWork> @index withArray
05:55:42 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
05:56:27 <BeelsebobWork> quicksilver: where are you getting withArray from?
05:56:48 <quicksilver> Foreign
05:56:52 <BeelsebobWork> oh, okay
05:57:43 <EvilTerran> ?hoogle peekByteOff
05:57:44 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
05:58:07 <EvilTerran> camio, i think that'd be  print . sum =<< sequence (map (peekByteOff p >=> return.fromIntegral) [0..size])
05:58:57 <EvilTerran> or even: print . sum =<< mapM (return.fromIntegral <=< peekByteOff p) [0..size]
05:59:41 <EvilTerran> or you could write (return.fromIntegral <=< peekByteOff p) as (fmap fromIntegral . peekByteOff p), i think
06:00:03 <camio> EvilTerran: That'd be nifty.
06:00:21 <EvilTerran> although i'd expect there to be an easier way of doing this
06:02:27 <quicksilver> BeelsebobWork: OK. I have just run your code.
06:02:31 <quicksilver> for me the texture is white.
06:02:36 <BeelsebobWork> interesting
06:02:38 <quicksilver> it appears gray, but that's because I have lighting on.
06:02:59 <BeelsebobWork> I just used your code -- and got garbage too
06:03:13 <EvilTerran> camio, for instance, Foreign.C.String.peekCStringLen (p, size) would give you a String of (size) CChars starting from (p)
06:03:58 <jinjing> is haskell.org down?
06:04:25 <EvilTerran> actually, it'd be better to use peekCAString, that's guaranteed to use bytes
06:04:35 <Deewiant> www.haskell.org appears to be
06:04:53 <quicksilver> BeelsebobWork: http://hpaste.org/9423#a2
06:04:58 <byorgey> it's loading for me, but very slowly
06:05:18 <quicksilver> BeelsebobWork: Apologies for the strange names and comments, I copy pasted a bunch of half written projects together to get a working program :)
06:05:46 <BeelsebobWork> quicksilver: cheers ... hmm
06:05:57 * BeelsebobWork tries the code on another machine
06:06:09 <quicksilver> BeelsebobWork: it's not clear that you've chosen a textureFunction
06:06:45 <quicksilver> maybe you should try textureFunction Texture2D $= Decal
06:06:52 <quicksilver> although I haven't bothered in my code, admittedly
06:07:12 <BeelsebobWork> quicksilver: uh, I never even knew such a call existed
06:07:12 <quicksilver> erm, just textureFunction $= Decal
06:07:13 <quicksilver> sorry
06:07:21 <BeelsebobWork> the red book doesn't use it in it's texturing code
06:07:47 <quicksilver> well, no, it uses glTexEnv
06:07:48 <quicksilver> ;)
06:08:57 <hackage> Uploaded to hackage: chp 1.1.0
06:18:40 <quicksilver> BeelsebobWork: would be interested to hear if, adfter all, textureFunction was the problem
06:20:13 <tusho> ghc switched to git?
06:20:15 <tusho> SCORE!
06:20:40 <tusho> looks like git's pretty much won this war :P
06:21:03 <pjdelport> why not mercurial, out of interest?
06:21:15 <camio> Darn, I had my fingers crossed for mercurial.
06:21:24 <tusho> pjdelport: even against everything else, one reason could be that git is rapidly taking over
06:21:28 <tusho> the actual reasons I don't know
06:21:39 <tusho> but yay, git++
06:21:42 <tusho> @karma git
06:21:42 <lambdabot> git has a karma of 2
06:21:50 <thoughtpolice> git is awesomeness. :)
06:22:05 <ziman> @karma c
06:22:05 <lambdabot> c has a karma of 0
06:22:19 <pjdelport> tusho: so is mercurial :)
06:22:26 <tusho> pjdelport: not really.
06:22:30 <tusho> git has tons of big projects behind it
06:22:34 <tusho> and it's only growing
06:22:36 <tusho> esp. with things like github
06:22:44 <tusho> hg has, uh, mozilla.
06:23:04 <thoughtpolice> hg has xen, opensolaris and a few other big ones iirc
06:23:10 <pozic> Is there any way I can compute the depth of a list? That is given [[[1]]] return 1? Since if I can, I can solve the problem.
06:23:11 <tusho> oh, yeah
06:23:12 <tusho> even so
06:23:17 <tusho> git is rapidly growing
06:23:28 <tusho> whereas hg just has a few biggies
06:23:32 <pozic> er return 3
06:23:57 <flux> now all you need is a second implementation (clone, if you will) of git - written in, say, haskell ;)
06:24:15 <rwbarton> pozic: That you surely can do using type classes and overlapping instances
06:24:26 <vixey> svn was fine from day 1 :/
06:24:33 <pozic> rwbarton: please show me, I already enabled all the bells and whistles.
06:24:39 <rwbarton> pozic: Let me give it a shot
06:25:19 <pjdelport> thoughtpolice: don't forget Java
06:26:23 <ADEpt> pozic: what's the depth of [[[1]],[[[[2]]]],[3]] ?
06:26:44 <vixey> pozic should try an untyped language :/
06:26:57 <camio> Can I reduce karma with lambdabot?
06:27:01 <byorgey> ADEpt: that isn't even well-typed
06:27:05 <pozic> vixey: no, there is nothing untyped here.
06:27:23 <pozic> vixey: I already wrote the proof that it is possible using type-classes. All I need is the depth to start the proof.
06:27:23 <byorgey> pozic: what should the type signature of your 'depth' function be?
06:27:40 <rwbarton> pozic: http://hpaste.org/9425
06:27:54 <pozic> ADEpt: that doesn't seem to be a list.
06:28:00 <Toxaris_> depth :: IsList a => a -> Int
06:28:06 <Toxaris_> so far, so easy
06:28:08 <ADEpt> byorgey: damn, i'm being dense :(
06:28:16 <byorgey> rwbarton: ah, nice
06:28:25 <camio> @karma- svn
06:28:25 <lambdabot> svn's karma lowered to -1.
06:28:32 <rwbarton> pozic: OverlappingInstances is not so nice though
06:28:47 <pozic> rwbarton: yes, I know, but it's the only way I guess.
06:28:54 <byorgey> rwbarton: the other way to do it is to make a new data type which can represent variable-depth nested lists
06:29:09 <rwbarton> byorgey: Yeah, that was discussed earlier
06:29:25 <byorgey> data Bush a = Leaves [a] | Trunk (Bush [a])
06:29:34 <byorgey> something like that
06:29:37 <rwbarton> pozic: Right, because you want inconsistent behavior for  depth (undefined :: [Int])  and  depth (undefined :: [[Int]])
06:29:43 <rwbarton> pozic: which is disturbing to me
06:29:58 <quicksilver> pozic: what is the depth of [[]] ?
06:30:05 <ADEpt> byorgey: that's what you get out of day coding in tcl :(
06:30:11 <byorgey> ADEpt: hehe =)
06:30:38 <pozic> quicksilver: 2
06:30:52 <vixey> :t [[]] :: [[[[()]]]]
06:30:53 <lambdabot> [[[[()]]]]
06:30:54 <rwbarton> quicksilver: it depends on the type you give it
06:31:00 <vixey> :t [[]] :: [[[[[[()]]]]]]
06:31:01 <lambdabot> [[[[[[()]]]]]]
06:31:23 <quicksilver> pozic: how do you know?
06:31:26 <rwbarton> pozic: Note that I just use head as a function :: [a] -> a; I could have used (undefined :: [a] -> a) as well
06:31:38 <quicksilver> pozic: the middle [] could be [] :: [[[[[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]]]]]]
06:31:44 <pozic> quicksilver: yes, I know that.
06:31:52 <quicksilver> so, why did you answer 2?
06:32:07 <quicksilver> rwbarton: what about I give it the type [[[a]]] ?
06:32:09 <pozic> quicksilver: because the application I have in mind has that property.
06:32:30 <pozic> quicksilver: (the property that it doesn't matter)
06:32:41 <rwbarton> quicksilver: You get an ambiguous type variable error in that case.
06:33:05 <quicksilver> I'm inclined to think breaking parametricity is an ugly step to take :)
06:33:54 <rwbarton> quicksilver: I agree... especially as breaking parametricity doesn't seem to be necessary for what pozic originally wanted to do.
06:34:20 <EvilTerran> you could use something like class DepthTo a b where depthTo :: a -> b -> Int; instance DepthTo a a where depthTo _ _ = 0; instance DepthTo a b => DepthTo a [b] where depthTo a b = depthTo a (head b) + 1
06:34:36 <rwbarton> EvilTerran, good idea
06:35:01 * EvilTerran has written a FunctorOf class with a similar trick
06:35:09 <pozic> I think I just moved the problem one step further, instead of solving it, I now need to construct a Peano based type level number from a number, but I am not sure how to do that.
06:35:15 <quicksilver> what in fact is the problem pozic initially wanted to solve?
06:35:17 <EvilTerran> but uglier
06:35:21 <rwbarton> Is this to get a "deepFmap"?
06:35:23 <vixey> data Z
06:35:39 <pozic> rwbarton: yes
06:35:43 <EvilTerran> class FunctorOf a fa b fb {- | loads of fundeps -} where fomap :: (a -> b) -> fa -> fb
06:35:45 <rwbarton> pozic: You can do it by writing a function  Int -> (forall a. Peano a => a -> b) -> b
06:35:55 <vixey> data S x
06:36:04 <EvilTerran> instance FunctorOf a a b b where fomap = id
06:36:13 <rwbarton> pozic: I'm not sure whether that solves your problem
06:37:03 <EvilTerran> instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fomap.fmap -- IIRC
06:37:21 <pozic> rwbarton: I use data Nil; data Succ a = Succ a
06:37:44 <EvilTerran> i think the masses of fundeps were to represent that any three of the class parameters uniquely determine the fourth
06:38:08 <pozic> I already got the deepFmap fundep stuff and it is working.
06:38:15 <EvilTerran> so it'd be "| a fa b -> fb, a fa fb -> b, a b fb -> fa, fa b fb -> a where"
06:38:29 <pozic> I just need to do this "tiny" little last step.
06:38:34 <EvilTerran> the depth thing?
06:38:58 <pozic> Convert an Int to a type representing the number.
06:39:13 <rwbarton> EvilTerran: ah.  I was thinking of using a similar approach to do a deepFmap, but without the idea of using all of a, fa, b, fb; just a and fa, and that didn't seem to work.
06:39:26 <rwbarton> pozic: What do you want to do with that type?
06:39:36 <rwbarton> Call a class method on it probably?
06:39:39 <EvilTerran> rwbarton, yeah, unfortunately you do seem to need both, which makes for rather ugly code
06:39:51 <pozic> rwbarton: give it as a parameter to the deepFMap method.
06:40:04 <rwbarton> EvilTerran: yeah.  And I don't really understand fundeps sufficiently to know whether those fundeps are "correct"
06:40:17 <EvilTerran> pozic, to do what, indicate the depth at which the deepFMap should apply its function parameter?
06:40:34 <pozic> rwbarton: when I encode the depth manually, it already works.
06:41:07 <rwbarton> pozic: can you paste your code so far?
06:41:31 <EvilTerran> the trick i used for my FunctorOf class meant that it could infer how deep to go based on the type of the function, which i quite liked
06:41:40 <Cale> MarcWeber: You were looking for me earlier?
06:41:48 <EvilTerran> although you sometimes had to explicitly annotate the function with a type or whatever
06:43:52 <chylli> how to hide some functions of Prelude ?
06:44:01 <Deewiant> import Prelude hiding (foo, bar)
06:47:10 <MarcWeber> Cale: yes, it was about hs-plugins and the cabal darcs version. I had to apply some patches to make it compile. profmakx told me that you might have worked on this as well..
06:48:20 <MarcWeber> I haven't done any testing yet.. But plugins did compile
06:48:21 <chylli> Deewiant: thanks.
06:48:59 <MarcWeber> http://hpaste.org/9426
06:49:37 <chylli> I think ghc support utf8, but  putStrln "你好" dosnt work, why ?
06:49:47 <Deewiant> GHC supports, putStrLn doesn't
06:49:59 <Deewiant> and the standard IO stuff in general
06:50:12 <chylli> Deewiant: are there some docs ?
06:50:25 <Deewiant> for what?
06:50:30 <chylli> for utf8
06:50:36 <Deewiant> there are libraries
06:50:39 <rwbarton> pozic: http://hpaste.org/9427 is an example of converting between type-level and value-level integers
06:50:41 <Deewiant> utf8-string I think is one
06:50:44 <chylli> thanks
06:51:16 <chylli> but main = getLine >>= putStr  seems work, why ?
06:51:28 <rwbarton> pozic: but it sounds like EvilTerran's code does what you actually want to accomplish
06:51:43 <RayNbow> chylli, putStr == \x -> putStr x
06:52:13 <RayNbow> oh wait
06:52:20 * RayNbow should read the conversation first before replying...
06:52:40 <chylli> RayNbow: I mean, I can input Chinese character and print out.
06:53:22 <rwbarton> chylli: Yes, but the String that gets passed from getLine to putStr is the (probably) four-byte UTF-8 encoding of 你好 with each byte interpreted as a character.
06:53:49 <rwbarton> try main = getLine >>= (return . length) >>= print
06:54:14 <chylli> rwbarton: let me try. thanks
06:54:33 <rwbarton> chylli: oh, I see what you mean.
06:54:35 <MarcWeber> fmap length getLine >>= print should work as well
06:54:50 <Deewiant> rwbarton: it's one Char per code point as it should be
06:55:19 <pozic> rwbarton: I saw no code from EvilTerran, but it will work now anyway. Thanks for your help.
06:57:46 <rwbarton> Deewiant: Really?  I tried and it printed 6 for me
06:58:20 <Deewiant> rwbarton: maybe it matters that I'm on Windows, so they're UTF-16
06:58:32 <Deewiant> and I probably can't type anything outside the BMP easily...
06:59:09 <Apocalisp> Is there a monad that accumulates values through >>= with a given monoid?
06:59:29 <pozic> rwbarton: you wrote something that returns an Int from a Peano, I want to return a Peano from an Int.
06:59:35 <byorgey> Apocalisp: yes, Writer
06:59:39 <Apocalisp> thought so
06:59:44 <rwbarton> pozic: Yes, that's what the buildType function is for
06:59:44 <Apocalisp> Thanks byorgey
06:59:48 <byorgey> Apocalisp: sure
06:59:55 <quicksilver> well that doesn't accumulate values, depending what Apocalisp meant
07:00:00 <rwbarton> pozic: I think buildType is the closest you can get
07:00:05 <quicksilver> it accumulates precisely those things you 'tell'
07:01:13 <pozic> rwbarton: right, I get it.
07:03:55 <EvilTerran> pozic, i mentioned FunctorOf above, i think that's what rwbarton was referring to
07:04:15 <EvilTerran> class FunctorOf a fa b fb | a fa b -> fb, a fa fb -> b, a b fb -> fa, fa b fb -> a where fomap :: (a -> b) -> fa -> fb
07:04:18 <EvilTerran> instance FunctorOf a a b b where fomap = id
07:04:32 <EvilTerran> instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fomap.fmap
07:05:22 <Apocalisp> quicksilver: I'd want (a >>= return) y  to yield b which carries the sum of y and the value carried by a, for some (+)
07:05:39 <EvilTerran> isn't (>>= return) = id?
07:05:41 <Apocalisp> "for some value of sum"
07:05:52 <EvilTerran> ?type (>>= return)
07:05:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
07:06:00 <Apocalisp> oops
07:06:02 <EvilTerran> that's a yes
07:06:20 <quicksilver> Apocalisp: sounds like you just want a monoid, not a monad at all?
07:07:06 <nomeata> Hi. We are currently debugging a hugs build failure on powerpc. Is it possible that the openAL bindings are expected to work on powerpc?
07:07:41 <Apocalisp> make that a >>= (return . y)
07:07:55 <EvilTerran> fmap y a?
07:08:23 <Apocalisp> ?type \a y -> a >>= (return . y)
07:08:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
07:08:41 <Apocalisp> yes, apparently so :)
07:08:42 <EvilTerran> ?type a y -> y <$> a
07:08:43 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:08:49 <EvilTerran> ?type \a y -> y <$> a -- oops
07:08:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
07:09:58 <Apocalisp> So it looks like what I want is a monoid, or id for a monoid
07:14:19 <pozic> rwbarton: too bad I cannot use the peano type now, because calling the method introduces an extra context.
07:15:47 <rwbarton> pozic: oh I see...
07:17:34 <Cale> MarcWeber: You're using all the things from Hackage?
07:17:57 <MarcWeber> Cale: no, some packages are coming from darcs
07:18:14 <Cale> Oh, I mean, with regard to hs-plugins at least.
07:18:33 <Cale> (I don't really know so much about the different versions of Cabal)
07:18:58 <Cale> ah, hs-plugins has a cabal dependency?
07:19:08 <Cale> I worked on it a bit, but I don't actually understand it :)
07:19:59 <MarcWeber> Neither did I .. but it does compile now :) Cabal has added a Text class for parsing and showing some types.. and there has been some name disambiguities
07:20:37 <Cale> I wonder if your fixes will help with the problem where hs-plugins fails to recognise the existence of packages installed as user
07:21:37 <Cale> Well, okay, if that compiles and seems to work, send me the darcs patch and I'll apply it.
07:23:12 <Cale> (darcs send -O)
07:25:45 <rwbarton> pozic: I would recommend EvilTerran's code, it's pretty straightforward and it handles the case of deepFmap :: [a] -> [[[a]]], say, which is difficult with the depth-counting approach.
07:38:54 <pozic> rwbarton: EvilTerran's code doesn't compile.
07:39:03 <EvilTerran> that was done from memory
07:39:21 <EvilTerran> it'll need -XMultiParamTypeClasses and -XFunctionalDependencies at least
07:40:41 <byorgey> EvilTerran's code compiles in his head. mortals who try to compile it on a computer will undoubtedly run into problems ;)
07:40:46 <pozic> EvilTerran: the fundeps are wrong, not the options, but you don't have to fix it, of course.
07:40:57 <EvilTerran> the fundeps are wrong? okay
07:41:05 <EvilTerran> i'll go have a look at what i actually wrote
07:41:36 <EvilTerran> ah, i think you may need -XUndecidableInstances as well
07:42:43 <sw17ch> why are so many of the -XSomething flags so scary? :(
07:42:56 <sw17ch> we need an -XPoines
07:43:21 <EvilTerran> http://hpaste.org/9428
07:43:28 <EvilTerran> pozic, that compiles for me
07:44:52 <tusho> chrisdone't start this again
07:45:05 <tusho> sw17ch: you can't have a poine
07:45:12 <tusho> hm
07:45:14 <tusho> poyn
07:45:56 <pozic> EvilTerran: yes, but try fomap (+1) [[1]].
07:46:57 <EvilTerran> pozic, [14:43] EvilTerran> although you sometimes had to explicitly annotate the function with a type or whatever
07:46:58 <vixey> -XLetsGoShopping
07:47:17 <jeffwheeler> Let's not. That's no less scary than any other.
07:47:36 <jeffwheeler> I'm all for ponies, though.
07:47:47 <EvilTerran> it'll generally need a monomorphic type for at least either the function parameter type or it's return type
07:47:56 <EvilTerran> so as to work out what depth to work at
07:48:08 <Shiruka> doesn't work for me :-( Do I need the GHC HEAD for this flag?
07:48:09 <Shiruka> ghc-6.8.2: unrecognised flags: -XLetsGoShopping
07:48:09 <EvilTerran> just in case there's an instance Num [Int] floating around somewhere
07:48:27 <vixey> Learning haskell has put this evil  >>=  symbol in my head every time I think about side effects in other languages
07:49:10 <byorgey> Shiruka: try -XPony
07:49:22 <dolio> You should study some modal calculi for effect handling. :)
07:49:24 <Shiruka> no luck with that either :-(
07:49:28 <byorgey> hehe
07:49:36 <jeffwheeler> I thought it was plural. -XPonies
07:49:43 <byorgey> oh, yeah, maybe that's it
07:49:44 <dolio> Then you could think about boxes and diamonds.
07:49:50 <tusho> jeffwheeler: it's XPoines
07:49:56 <tusho> its like how referer is in the http spec
07:50:00 <jeffwheeler> tusho: ah, my bad
07:50:09 <jeffwheeler> That could really trip people up.
07:50:14 <EvilTerran> ... what's a poine?
07:50:18 <Shiruka> oh! with -XPonies GHC opened a new window with a cool 3d animation of ponies, you should try it
07:50:27 <tusho> EvilTerran: a pony
07:50:29 <EvilTerran> i see
07:50:36 <tusho> <sw17ch> we need an -XPoines
07:50:40 <jeffwheeler> tusho: apparently it's -XPonies :-/
07:50:49 <tusho> no, it was added as Poines
07:50:53 <tusho> due to what sw17ch said
07:51:01 <tusho> -XPonies is only present in pirated ghc versions
07:51:02 <jeffwheeler> Hmm, typo in the implementation
07:51:07 <jeffwheeler> Oh, I see.
07:51:07 <tusho> it's like those hacker cred screens
07:51:12 <jeffwheeler> Yeah, that makes sense.
07:51:13 <tusho> jeffwheeler: too widely used to fix
07:51:21 <tusho> which is why I drew the analogy to http's "referer"
07:51:36 <jeffwheeler> That makes sense.
07:51:45 <byorgey> from now on when I do something awesome I'm going to start saying 'Poined'!
07:52:10 <byorgey> er, I mean, when I do something xmonad
07:52:10 <tusho> sweet
07:52:27 <Shiruka> where does the ponies thing come from anyway
07:52:33 <Shiruka> I just remember the "math is hard, let's go shopping" bit
07:52:50 <tusho> Shiruka: they're ponies
07:52:51 <jeffwheeler> Wasn't that from a 199{2,4} Barbie?
07:52:53 <byorgey> Shiruka: ponies come from mommy ponies
07:52:53 <tusho> everyone loves ponies
07:52:59 <tusho> byorgey: no
07:53:06 <tusho> they come from porks
07:53:08 <tusho> (pony storks)
07:53:12 <byorgey> hehe
07:54:10 <jeffwheeler> Ever see that site like iwantapony.com or something? It had an Apache Lua module or something.
07:54:35 <tusho> yes
07:54:41 <tusho> it's a few people's personal dump, obviously
07:55:00 <tusho> http://i-want-a-pony.com/
07:55:01 <lambdabot> Title: I want a Pony.
07:55:08 <jeffwheeler> That's the one. Very amusing.
07:55:14 <sw17ch> Actually, ghc should be patched so when -XPonies is specified, the compiler output is printed in random happy colors
07:55:36 <tusho> sw17ch: Poines
07:55:43 <tusho> you originally made that mistake
07:55:47 <tusho> you of all people should remember it!
07:55:52 <Shiruka> or maybe it should dump the ghc core with happy colors, then dump core
07:56:10 <sw17ch> holy cow... i didn't read that part following the mistake
07:56:11 <sw17ch> :)
07:56:14 <jeffwheeler> Shiruka: but that would impede its use
07:56:15 <sw17ch> even better
07:56:34 <dolio> Probably shouldn't be -XPonies, since I think all those correspond to LANGUAGE pragmas.
07:56:35 <tusho> -XPoines should start up an opengl window
07:56:42 <tusho> and draw a 3d pony
07:56:46 <tusho> and it gallops
07:56:48 <rwbarton> -fallow-ponies
07:56:51 <dolio> More like -fponies
07:56:52 <tusho> while all the code you're compiling flows around it
07:56:57 <opqdonut> -fdisallow-ponies
07:56:59 <tusho> and then when the program runs
07:57:03 <tusho> it does the same
07:57:06 <tusho> but instead of the code, it has the stodut
07:57:11 <tusho> and you input by talking into a microphone
07:57:18 <tusho> so yes it is -XPoines, it is a language option
07:57:42 <dolio> Unless you want people writing haskell source with {-# LANGUAGE Ponies #-} -- non-portable
07:58:36 <sw17ch> dolio, it would be like my covert signature
07:58:39 <sw17ch> or any one
07:58:41 <sw17ch> i suppose :)
07:59:10 <dolio> "My package doesn't compile on YHC, because they don't support ponies."
07:59:33 <tusho> dolio: Poines
07:59:39 <tusho> it's Poines, goddamn
07:59:51 <jeffwheeler> It makes sense then to add Poines to YHC, no?
08:00:18 <jeffwheeler> tusho: how does one pronounce poines?
08:00:32 <tusho> jeffwheeler: exactly like ponies, except say i before n
08:00:50 <jeffwheeler> tusho: I'll try that
08:00:55 <sw17ch> tusho, i think i need to retract my typo
08:01:06 <tusho> sw17ch: too late
08:01:10 <tusho> 100000000 programs depend on it
08:01:15 <tusho> haskell had an explosion of popularity
08:01:30 <sw17ch> as well as the Poines extension
08:01:32 <quicksilver> closely related to -XPoines is, of course
08:01:38 <Shiruka> maybe we should make that into a holy war, -XPonies would order strings the normal way, but -XPoines would reorder the middle 3 characters in every 6, so we would have ponies-middian and poines-middian strings
08:01:40 <quicksilver> -XMoonOnAStick
08:01:45 <quicksilver> c.f. http://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/moon-on-stick.html
08:01:48 <lambdabot> Title: PuTTY wish moon-on-stick, http://tinyurl.com/2du9c
08:01:58 <sw17ch> through magic and rainbows, the Poines extension fixes all your type errors and sprinkles typos in your code
08:02:07 <tusho> why does lambdabot give a tiny url
08:02:10 <tusho> it's totally pointles
08:02:10 <tusho> s
08:02:16 <quicksilver> er let me think
08:02:19 <quicksilver> perhaps there is a reason!
08:02:23 <brx> your pony died because it was not pretty enough.
08:02:24 <quicksilver> or is it just to annoy tusho?
08:02:29 <quicksilver> ah no, there is a reason
08:02:30 <quicksilver> Fancy that.
08:02:43 <tusho> quicksilver: you are very good at sarcasm. keep it up
08:02:46 <quicksilver> tinyurls are shorter
08:02:49 <tusho> uh yes
08:02:52 <tusho> but the long url has already been posted
08:02:54 <quicksilver> therefore easier to type
08:02:58 <quicksilver> and also easier to copy-paste
08:03:06 <tusho> oh, right, people still use clients that don't integrate with anything ese
08:03:07 <tusho> how quaint
08:03:14 <sw17ch> ah, for those of us not running XChat...
08:03:26 <tusho> xchat? heh
08:03:32 <jeffwheeler> sw17ch: or any other client that was written in the last fifteen years
08:03:33 <tusho> i'm one to talk though
08:03:35 <Shiruka> quicksilver: :-D the picture is funny
08:03:36 <tusho> can't find a decent os x client
08:03:44 <tusho> so i'm stuck with colloquy
08:03:52 <tusho> but at least it supports CLICKING URIS
08:04:04 <quicksilver> jeffwheeler: lots of people choose to run IRC over screen/ssh
08:04:06 <jeffwheeler> A lot of people complain about Pidgin, but I quite like it.
08:04:24 <EvilTerran> there's xchat for osx
08:04:24 <quicksilver> this makes it quite tricky to get clickable URLs which span lines to work 100% reliably
08:04:24 <jeffwheeler> quicksilver: sounds like nothing but pain
08:04:31 <tusho> EvilTerran: yes, it's ugly :)
08:04:34 <EvilTerran> meh
08:04:36 <quicksilver> jeffwheeler: the gain more than makes up for the pain.
08:04:37 <tusho> quicksilver: use a bouncer
08:04:55 <quicksilver> tusho: doesn't seem worth the effort
08:05:00 <quicksilver> doesn't gain me enough.
08:05:05 <quicksilver> irssi in screen works weel.
08:05:07 * Shiruka runs irssi on a screen through ssh
08:05:11 <tusho> quicksilver: about as much effort as setting up screen&ssh&irrsi
08:05:14 <tusho> *irssi
08:05:18 <Shiruka> copy-paste works just fine
08:05:24 <tusho> and, you know, isn't completely isolated from the rest of your system
08:05:27 <quicksilver> not really, since I'm running screen & ssh already
08:06:12 <quicksilver> (and I'd almost certainly run screen and ssh anyway, even if I was using a bouncer)
08:06:16 <jeffwheeler> GHC is switching to git?
08:06:20 <Deewiant> aye
08:06:26 <Shiruka> xchat's support for accessing it remotely sucked when I last checked
08:06:32 <quicksilver> bzr ftw!
08:06:37 <Shiruka> had to use remote X or VNC, both of which are slow
08:06:42 <Deewiant> hg ftw!
08:06:44 <quicksilver> pointless VCS advocacy ftw!
08:06:52 <jeffwheeler> I like git; I've used it for non-Haskell stuff.
08:07:02 <Deewiant> cvs ftw!
08:07:17 <osfameron> cp foo foo.yymmdd ftw!
08:07:35 <sw17ch> osfameron++
08:08:50 <Deewiant> .yymmdd? cp foo foo.n ftw!
08:09:01 <Botje> pffrt
08:09:09 <Botje> _REAL_ functional programmers use functional file systems
08:09:26 <baaba> and functional hardware
08:09:29 <Shiruka> fully functional or partially functional?
08:09:30 <Twey> A *functional filesystem*?
08:09:35 <Twey> Yerwhat?
08:09:53 <baaba> the hard drive creates a copy of itself each time you write a file
08:09:54 <Botje> Shiruka: .. mostly functional? :)
08:10:03 <quicksilver> I assume botje means that in the sense of okasaki's purely functional data structures
08:10:05 <Shiruka> there's a bunch of dependent typists who think partially functional is better
08:10:29 <quicksilver> I.e. as long as you retain references to old consistent versions they still exist
08:10:58 <dcoutts_> waern: http://hpaste.org/9429
08:11:16 <Toxaris_> sounds like svn
08:11:57 <waern> dcoutts: awesome
08:12:22 <thoughtpolice> what's tough about setting up screen+ssh+irssi? :/
08:12:39 <dcoutts_> waern: it'll be in the darcs cabal-install soon
08:12:55 <thoughtpolice> screen ssh you@place. then you type irssi and you are done?
08:13:12 <eu-prleu-peupeu> hi
08:13:20 <eu-prleu-peupeu> im having problems installing cabal-install
08:13:21 <eu-prleu-peupeu> here: http://hpaste.org/9430
08:13:23 <eu-prleu-peupeu> :/
08:13:24 <thoughtpolice> i used that approach for months at a time when I didn't run X on my linux box and just ssh'd in to do anything, it worked awesome.
08:13:27 <eu-prleu-peupeu> can someone help me ?
08:13:31 <Shiruka> ssh you@place screen is more useful
08:13:48 <dcoutts_> waern: and you can use the code in Distribution.Client.Logging to parse those build logs and get a list of all packages where the install-outcome is InstallOk but the docs-outcome is Failed
08:13:56 <Shiruka> the whole point (at least for me) of running irssi in a screen is to access it from multiple places
08:14:22 <thoughtpolice> Shiruka: my setup was a little different; I would actually ssh into my linux box, then screen an ssh session to another computer where I would run irssi
08:14:44 <Shiruka> ah, same purpose, slightly different means :-)
08:15:08 <thoughtpolice> Shiruka: that was back when I 'used' windows, but not really. i just ssh'd to my linux box for everything because it was in VMware and having it capture your mouse was incredibly annoying
08:15:18 <dcoutts_> eu-prleu-peupeu: lemme check...
08:15:20 <eu-prleu-peupeu> i also have a problem installing hopengl, when i do a runghc setup.hs configure, it says: Configuring OpenGL-2.2.1.1...
08:15:20 <eu-prleu-peupeu> Warning: The 'build-type' is 'Configure' but there is no 'configure' script.
08:15:40 <thoughtpolice> so i just used my linux box from ssh for like, 6 months. then I finally went back to xmonad when I realized I might as well just full screen vmware
08:16:03 <eu-prleu-peupeu> ghc version is 6.8.2
08:16:30 <Shiruka> I run windows in qemu.. when I run it, which seems to be extremely rarely these days
08:16:58 <jeffwheeler> "--\content" isn't a valid comment?
08:17:07 <thoughtpolice> Shiruka: since I got my macbook I haven't used windows/linux since (about 3-4 months?) I'm thinking of maybe setting up a virtual machine sometime.
08:17:18 <dcoutts_> eu-prleu-peupeu: you're using the darcs version of cabal-install, and there was a period a few days ago when there was a bug with running the setup stuff. So make sure you're using the latest cabal-install, or the released version.
08:17:43 <eu-prleu-peupeu> ah ok
08:17:58 <rwbarton> jeffwheeler: no, because --\ is a valid operator
08:18:00 <thoughtpolice> Shiruka: either that or I might as well put my AWESOME 800mHz pentium III+30gb hdd+192mb RAM to use and put archlinux on there. :)
08:18:21 <Shiruka> I couldn't use mac, it's so user-unfriendly ;-P I've seen one of my friends use it, but pretty much anything he tries to use with apt-get requires fighting to get it to work, and even then it's some ages old version..
08:18:49 <jeffwheeler> rwbarton: What are the rules on that? It looks like just special symbols are operators, but --f is a comment.
08:18:50 -rc_(n=anekos@pl097.nas923.p-osaka.nttpc.ne.jp)- 断わる
08:19:05 <waern> dcoutts: ok, great.
08:19:05 -rc_(n=anekos@pl097.nas923.p-osaka.nttpc.ne.jp)- 断わる
08:19:09 --- mode: ChanServ set +o quicksilver
08:19:12 --- mode: ChanServ set +o dcoutts_
08:19:13 <Deewiant> > let a --\ b  = a + b in 5 --\ 2
08:19:14 -rc_(n=anekos@pl097.nas923.p-osaka.nttpc.ne.jp)- 断わる
08:19:14 <lambdabot>  7
08:19:14 -rc_(n=anekos@pl097.nas923.p-osaka.nttpc.ne.jp)- 断わる
08:19:17 <thoughtpolice> Shiruka: apt-get on OS X? or does he use os x because he hates fighting apt-get on debian/ubuntu?
08:19:18 --- mode: quicksilver set +b *!*n=anekos@*.nas923.p-osaka.nttpc.ne.jp
08:19:18 --- kick: rc_ was kicked by quicksilver (quicksilver)
08:19:19 <Deewiant> > let (--\) = (+) in 5 --\ 2
08:19:19 <lambdabot> Unbalanced parentheses
08:19:32 <Deewiant> ^ ??
08:19:40 <Shiruka> thoughtpolice: he likes the GUI
08:19:41 <quicksilver> bug in the pre-parser part of LB
08:19:49 <quicksilver> (Deewiant)
08:19:58 <tusho> what is 断わる
08:20:00 <thoughtpolice> Shiruka: for package management on OS X, macports is good stuff. :)
08:20:03 <baaba> > let (--\\) = (+) in 5 --\ 2
08:20:04 <lambdabot> Unbalanced parentheses
08:20:08 <Deewiant> LB does some stuff of its own before going to GHCi?
08:20:09 <eu-prleu-peupeu> im also having problems installing hopengl
08:20:10 <eu-prleu-peupeu> here: http://hpaste.org/9431
08:20:18 <eu-prleu-peupeu> can someone help me out please ?
08:20:18 <Deewiant> that somewhat sucks
08:20:23 <Shiruka> 断る = I refuse (and assorted other meanings)
08:20:44 <Baughn> Deewiant: Yes, and it doesn't use ghci. Not for >, anyhow.
08:20:49 <quicksilver> Deewiant: it should use an official haskell parser but it has its own hacked one
08:20:57 <vixey> Deewiant: yeah it ruins ascii in the process, but apparently it's for security
08:20:58 <Deewiant> Baughn: GHC, my bad
08:21:14 <quicksilver> Deewiant: it uses GHC to run the code but, first, it checks for security holes
08:21:21 <judahj_> eu-prleu-peupeu: try running autoreconf
08:21:24 <Shiruka> thoughtpolice: I think that's what he uses (not sure though :-)
08:21:24 <quicksilver> limits the syntactic form of the thing
08:21:38 <Deewiant> makes sense, too bad it's broken though :-P
08:21:38 <quicksilver> to avoid running the kind of code it doesn't mean to run
08:21:42 <quicksilver> quite.
08:21:44 <eu-prleu-peupeu> judahj_: okey, thanks
08:21:46 --- mode: quicksilver set -o quicksilver
08:21:54 <rwbarton> jeffwheeler: --f is tokenized into two tokens, -- and f, while --\ is one token.  A -- token starts a comment
08:21:54 <eu-prleu-peupeu> judahj_: do you know how do i do that ? :P
08:22:00 <Deewiant> I guess this is the reason it fails UTF-8 as well
08:22:03 --- mode: ChanServ set -o dcoutts_
08:22:19 <thoughtpolice> Shiruka: i dunno, I have two computers here in my room that I figure I should install linux on to put them to use.
08:22:26 <thoughtpolice> archlinux is pretty good, debian looked reasonable
08:22:27 <jeffwheeler> rwbarton: that makes sense; what characters would be parsed into one token?
08:22:36 <thoughtpolice> because right now they are somewhat useless.
08:22:40 <dcoutts_> eu-prleu-peupeu: were you using the tarball or darcs version of OpenGL ?
08:22:42 <jeffwheeler> I guess I could look at the syntax highlighter I'm using. :P
08:22:44 <thoughtpolice> well, the p3 I mentioned earlier actually runs plan 9 right now
08:22:47 <eu-prleu-peupeu> always darcs
08:22:53 <dcoutts_> eu-prleu-peupeu: and what Cabal lib version?
08:22:58 <thoughtpolice> I haven't gotten *anything* to install on the HP dual xeon intel server I have next to me :/
08:23:03 <eu-prleu-peupeu> latest, from darcs... just installed it
08:23:06 <Shiruka> I use ubuntu, but just read about archlinux.. seemed like gentoo from the description
08:23:19 <rwbarton> jeffwheeler: I believe it's anything that can be part of an operator (most punctuation but not ()[]; and probably some others)
08:23:20 <eu-prleu-peupeu> (1.4 i think)
08:23:20 <dcoutts_> eu-prleu-peupeu: so the configure was indeed missing then was it? since it's not in the darcs repo I guess, yeah?
08:23:24 <thoughtpolice> and i am about to move soon
08:23:27 <chrik> Hi, i pulled ghc with git and tried to compile it. After 'autoreconf' and 'configure' i did 'make' and it says 'Looks like you're missing utils/hsc2h maybe you haven't done './darcs-all get'. Google still knows 'darcs.haskell.org/ghc-git/utils/hsc2hs/' but now i get a 404
08:23:29 <thoughtpolice> and moving that HP server right next to me
08:23:33 <thoughtpolice> is really, really going to suck
08:23:40 <thoughtpolice> a lot
08:23:47 <eu-prleu-peupeu> dcoutts_: i dont know what type of config file is Setup.hs expecting to see  :/
08:24:11 <dcoutts_> eu-prleu-peupeu: the OpenGL package uses a ./configure script as part of its build process
08:24:15 <eu-prleu-peupeu> there are several ones there, config.guess, configure.ac, config.sub etc...
08:24:19 <BeelsebobWork> quicksilver: camio: rwbarton: for interest's sake... bug closed [behaves correctly] -- the Mtl file specified a Kd 0 1 0 (diffuse colour green) -- which should be multiplied by the texture
08:24:35 <thoughtpolice> Shiruka: it's similar in the sense it drops you into a very minimalist environment
08:24:36 <dcoutts_> eu-prleu-peupeu: it's present in the tarball, but in the darcs repo it has to be generated from configure.ac using autoreconf
08:24:51 <rwbarton> BeelsebobWork: weird feature
08:24:59 <thoughtpolice> Shiruka: that's how I learned a lot about linux; I installed it and started playing around a bunch in the terminal and it payed off IMO
08:25:00 <eu-prleu-peupeu> autoreconf is the autoconf gnu tool ?
08:25:03 <BeelsebobWork> rwbarton: it's pretty standard in the 3D graphics world
08:25:07 <dcoutts_> eu-prleu-peupeu: btw, the current darcs version of cabal-install compiles fine.
08:25:09 <dcoutts_> eu-prleu-peupeu: yes
08:25:11 <rwbarton> BeelsebobWork: It only applies to textures though?
08:25:13 <thoughtpolice> archlinux uses binary packages, contrast to gentoo however.
08:25:23 <Shiruka> I've never used very minimalistic linuxen, the most minimalistic being slackware back in the .. um.. dunno, maybe linux kernel 1.2.13 era
08:25:24 <quicksilver> BeelsebobWork: means you had textureFunction $= Modulate
08:25:28 <BeelsebobWork> rwbarton: no -- just colours should always work like that
08:25:30 <quicksilver> BeelsebobWork: which, I imagine, is the default
08:25:45 <quicksilver> BeelsebobWork: if you had Decal it would ignore the green and just blat the texture colour
08:25:47 <BeelsebobWork> quicksilver: yeh, but that's what it's meant to do, so it's fine :)
08:25:50 <quicksilver> and there are all kinds of other options :)
08:25:51 <eu-prleu-peupeu> dcoutts_: maybe its because im using ghc 6.8.2 then :/
08:25:57 <BeelsebobWork> but yeh, that would have been a quick way to finding the bug
08:25:59 <BeelsebobWork> so thanks
08:26:02 <dcoutts_> eu-prleu-peupeu: no, so am I
08:26:02 <quicksilver> ;)
08:26:03 <thoughtpolice> Shiruka: hehehe. some people I've met absolutely swear by slackware, although I don't run into many people using it more. then again I don't ask :)
08:26:16 <eu-prleu-peupeu> autoconf tools in windows are really nasty :/
08:26:22 <dcoutts_> eu-prleu-peupeu: yep :-)
08:26:29 <quicksilver> eu-prleu-peupeu: s/autoconf//;
08:26:38 <Shiruka> my linux path went yggdrasil -> slackware -> redhat -> debian -> ubuntu :-)
08:26:38 <Baughn> s/in windows//
08:26:38 <quicksilver> or maybe also s/tools in//;
08:26:42 <eu-prleu-peupeu> heheh
08:26:53 <dcoutts_> eu-prleu-peupeu: so darcs pull the latest cabal-install and let me know if you're still having trouble compiling it
08:27:00 <Shiruka> (don't ask what yggdrasil is, I don't know either :-P was too noob then to know and it probably doesn't even exist anymore)
08:27:10 <eu-prleu-peupeu> ok
08:27:18 <thoughtpolice> Shiruka: yggdrasil? wow, you must be a pretty veteran linux user :)
08:28:05 <Shiruka> well, yggdrasil was the first one I used when I got a CD (probably..? surely not floppies..?!) in junior high :-P
08:28:41 <jeffwheeler> I use Ubuntu at work, but I still prefer Debian at home. It doesn't need to be stable (heh), so I run Unstable for the fun of it.
08:28:44 <eu-prleu-peupeu> maybe its me using darcs the wrong way :/
08:29:02 <eu-prleu-peupeu> ...im too lazy to rtfm, so i just did a darcs get http://... and then runghc on it
08:29:08 <jeffwheeler> I'm fine with reinstalling whenever anything breaks (but so far have been gotten fairly lucky).
08:29:19 <Baughn> Hm. I remember installing linux on my 40MB harddisk, and being annoyed that it took nearly half the space. Don't remember /which/, though
08:29:32 <Baughn> ..also, taking half a year to figure out I could check for free space without rebooting
08:29:38 <thoughtpolice> jeffwheeler: back when I tracked lkml (i.e. before I got this macbook and it therefore became pointless) and ran archlinux
08:29:43 <thoughtpolice> I was considering beginning to run -mm
08:30:22 <thoughtpolice> main thing stopping me was that I didn't have a backup of any of my dot-files or my ~/code :p
08:31:03 <jeffwheeler> Most of my code is in remote git repos, and nothing hugely important to me in my dotfiles. :)
08:31:08 <thoughtpolice> although I guess i could have always just put another bootloader entry into grub but I guess it doesn't matter currently
08:31:10 <jeffwheeler> I run a MacBoo pro, too.
08:31:20 <Shiruka> heh, when I used ubuntu, I also used unstable all the time :-) wasn't all that unstable though
08:31:51 <jeffwheeler> Yeah, I've been really lucky with Debian Unstable; perhaps because I'm always willing to just flat-out remove packages that aren't behaving nicely, and then forget about them.
08:32:00 <Shiruka> should've been named s/stable/dinosaur/ and s/unstable/modern/
08:32:24 <thoughtpolice> nothing hugely important here too; I just mainly really didn't want to have to reconfigure my mail stack
08:35:34 <phlpp_> @src length
08:35:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:36:00 <Shiruka> (O.O; surely MS BOB wasn't THAT bad..
08:36:12 <Shiruka> (never used it, just heard the horror stories)
08:40:43 <Botje> vista is ms bob, surely?
08:43:16 <siponen> Hi! Is there some standard way to find nodes, parents of nodes and children of nodes in the standard Data.Tree module? The functions in the module don't do that but Tree is an instance of all those magical classes too (Foldable, Traversable, Applicative, Monad, etc) so I thought maybe there is some standard magic for it?
08:47:41 <eu-prleu-peupeu> it seems im not alone: http://joelhough.com/blog/2008/04/08/i-hate-autoconf/ :P
08:47:42 <lambdabot> Title: I hate autoconf | JoelHough.com
08:48:02 <Zao> eu-prleu-peupeu: auto* is by definition evil.
08:48:20 * Shiruka took one look at autoconf once and hates it, but that doesn't really count
08:48:49 <lispy> Shiruka: yeah, autoconf gets a bad rep for being ugly but gets a lot of us because it seems to get the job done
08:48:59 <thoughtpolice> i tried it once too. overly complicated but I guess the amount of people using it says *something*
08:49:03 <thoughtpolice> maybe that I'm really stupid?
08:49:04 * lispy hates autoconf
08:49:10 <centrinia> autoeroticism is evil? :O
08:49:23 <Shiruka> ask any bible thumper
08:49:30 <MyCatVerbs> autoconf isn't *that* bad.
08:49:40 <noteventime> It's just archaic :p
08:49:45 <MyCatVerbs> Automake should be burned and the ground over its grave salted, though.
08:50:03 <MyCatVerbs> noteventime: yes. That's a fairly important property of systems that need to work on top of archaic systems.
08:50:19 <Shiruka> ah.. I confused autoconf with automake :-)
08:50:31 <MyCatVerbs> noteventime: pray tell how else you plan to run on old, shitty, closed-source unixen with many embarrassing bugs?
08:51:01 <noteventime> MyCatVerbs: Words of wisdom ;)
08:51:01 <Baughn> siponen: Given what? Traversable, Foldable etc. only really give you the /value/
08:51:18 <Shiruka> MyCatVerbs: step 1. Install Linux on them, step 2...
08:51:19 <MyCatVerbs> noteventime: that's a pretty low bar as far as "wisdom" goes. >>
08:51:23 <Baughn> siponen: But you're starting with a tree, and you want.. what, exactly?
08:51:43 <MyCatVerbs> Shiruka: no, seriously. People have old crap in surprising places.
08:51:57 <Shiruka> but the solution is a shovel :-)
08:52:19 <noteventime> Has anyone read "Purely functional data structures"?
08:52:40 <quicksilver> siponen: there are no parents.
08:52:42 <centrinia> By Okasaki?
08:52:56 <noteventime> centrinia: Yes
08:53:02 <quicksilver> siponen: that is part of the magic of purely functional trees.
08:53:03 <centrinia> No. :(
08:53:07 <MyCatVerbs> noteventime: jah. It's good.
08:53:11 <quicksilver> siponen: it's like the matrix. "There is no spoon".
08:53:16 <noteventime> MyCatVerbs: Good, then I'll get it
08:53:33 <quicksilver> if you want a purely functional structure for a tree node including parent info, you want a zipper
08:53:43 <quicksilver> noteventime: you can read his thesis online for an idea of what the book is like
08:53:47 <siponen> Baughn: I have tree of tokens and I'd want to clear up the awful ad-hoc mess that I use to search the childs and parents of those tags.
08:53:55 <quicksilver> the book is the thesis tidied-up, AIUI.
08:54:43 <Shiruka> siponen: attribute grammars ftw?
08:54:51 <noteventime> quicksilver: What is it called?
08:55:06 <siponen> quicksilver: But surely a parent of a node is that which has an edge to that node?
08:55:26 <siponen> Even as the node hasno ede to it'sparent?
08:55:35 <Shiruka> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter <-- the problem might fit this shape
08:55:35 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
08:55:41 <osfameron> okasaki's book is quite daunting if you don't have a background in computer science..
08:55:50 <quicksilver> @go okasaki thesis
08:55:51 <lambdabot> No Result Found.
08:55:56 <siponen> Shiruka: VTES gametable hierarcy...
08:55:58 <quicksilver> noteventime: I think it has the same name as the book.
08:56:11 <noteventime> quicksilver: Yep, found it, thanks :)
08:56:22 <quicksilver> siponen: well the left subtree of a tree is a tree in isolation
08:56:26 <MyCatVerbs> www.cs.cmu.edu/~rwh/theses/okasaki.pdf
08:56:28 <quicksilver> siponen: and, in isolation, it doesn't have a parent.
08:56:35 <Shiruka> siponen: doesn't say anything to me :-)
08:56:48 <quicksilver> the concrete structure of trees is a bit clumsy to give a concrete example cleanly
08:56:54 <quicksilver> compare lists, though.
08:56:58 <osfameron> doubly linked trees are really hard to express in Haskell
08:57:02 <quicksilver> [3,4,5] is the tail of [1,2,3,4,5]
08:57:07 <quicksilver> (a tail of, sorry)
08:57:18 <quicksilver> but you can't ask "waht is [3,4,5]'s parent?"
08:57:22 <vixey> osfameron: without mutation they are rather uselessss
08:57:24 <quicksilver> in isolation, it doesn't have a parent.
08:57:37 <quicksilver> it only has a parent when it is viewed as a sublist of [1,2,3,4,5]
08:57:41 <quicksilver> which is what zippers are for
08:58:01 <siponen> quicksilver: Ok, agreed, but fortunately in this case Ihave the whole tree to play with...
08:58:19 <centrinia> quicksilver: I think that [2,3,5,7,11,13] is a parent of [3,4,5] as well as any other list with the same type of elements. :p
08:58:38 <quicksilver> siponen: and then that is precisey what a zipper is
08:58:47 <quicksilver> a zipper is a "substructure plus the context for that structure"
08:58:56 <siponen> And at the moment I havewriten my own funcions o find those hings, but they just sounded so generic, that I thought there might be a standard way o it.
08:59:19 * quicksilver nods
08:59:19 <siponen> Ok, /me goes to read about zippers.
09:00:04 <osfameron> zippers are cool.  At least, the theory is cool, I've got confused the 2 times I tried to implement (in Haskell and Perl) but that's just me I think
09:00:22 <quicksilver> certainly it was osfameron that got confused, not the zipper
09:00:29 <osfameron> quicksilver++
09:01:14 <yav> for an example of zupper in action take a look at Text.XML.Light.Cursor from the xml package
09:03:56 <noteventime> Are there any interesting modern imperative programming languages?
09:03:57 <BMeph> I tried to get Mike Adams' generic zipper stuff working, but it wasn't going. I'll see if I can get it going here at work. :)
09:04:07 <noteventime> All the interesting stuff seems to happen in functional programming
09:04:23 <noteventime> And to some extent in domain specific languages
09:04:27 <BMeph> where scrap your zippers
09:04:32 <BMeph> @where scrap your zippers
09:04:32 <lambdabot> I know nothing about scrap.
09:04:41 <quicksilver> noteventime: yes, haskell.
09:04:42 <jeffwheeler> I don't know what the technical name is, but these "message-passing" languages like Smalltalk, Objective-C, and Ruby seem to be popular.
09:04:43 * BMeph cries
09:04:58 <Shiruka> there aren't any interesting new languages, where new = "created in this millenium" :-(
09:05:10 <Shiruka> it's just older ones getting new features
09:05:12 <BMeph> What about Groovy? :)
09:05:13 <osfameron> depends on what you're interested in too
09:05:15 * BMeph ducks
09:05:17 <noteventime> jeffwheeler: True, but I can't help but feel that they're duck-typed C with a new syntax
09:05:24 <Shiruka> groovy, ha ha ;-)
09:05:31 <noteventime> BMeph: Isn't Groovy basically Python for .net?
09:05:32 <MyCatVerbs> @where+ okasakithesis www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:05:32 <lambdabot> Okay.
09:05:33 <jeffwheeler> noteventime: ha; I can't argue with that :P
09:05:40 <quicksilver> smalltalk is really not much like duck-typed C
09:05:45 <dolio> Groovy is JVM.
09:05:53 <noteventime> dolio: Same thing X-D
09:05:59 <dolio> :)
09:06:09 <noteventime> quicksilver: True, I've got to check out Smalltalk some time
09:06:20 <chylli> I got an error :     Could not find module `Codec.Binary.UTF8.String':
09:06:20 <chylli>       it is a member of package utf8-string-0.3.1.1, which is hidden
09:06:20 <chylli>  
09:06:24 <noteventime> Funny how such an old language can be more interesting than the newest revision of C++
09:06:36 <MyCatVerbs> noteventime: no, IronPython is Python for .NET, Jython is Python for JVM. ;P
09:06:40 <chylli> but pgk-list utf8-string shows no hiding
09:06:44 <chylli> why ?
09:06:54 <noteventime> MyCatVerbs: I had the impression that Groovy was VERY similar to python :|
09:07:08 <yav> chylli: you need to add a dependecy to your cabal file
09:07:16 <chylli> yav: ok, thanks
09:07:22 <noteventime> Not that I studied it rigorously
09:07:23 <Shiruka> groovy is "we want a python/ruby for JVM, but with the oh so lovely Java look"
09:07:31 <noteventime> Haha
09:07:35 <quicksilver> I thought groovy did type inference?
09:07:45 <quicksilver> that's pretty different from python + ruby
09:07:56 <siponen> noteventine: Smalltalkis surely more "complete" as an object language than C-variants.
09:07:58 <quicksilver> oh
09:08:04 <quicksilver> maybe that's scala?
09:08:05 <noteventime> quicksilver: Hmm, I've got to check that
09:08:15 <noteventime> Yea, I think scala does type inference
09:08:23 <noteventime> But scala is at least semi-functional, isn't it?
09:08:24 <dolio> I think Groovy is pretty Python/Ruby-esque.
09:08:34 <MyCatVerbs> noteventime: local only. Not global like H-M.
09:08:51 <centrinia> Smalltalk doesn't have a very strong type system. :p
09:08:54 <MyCatVerbs> noteventime: yes. Impure, but that's the norm.
09:08:54 <dolio> People used to compare it to Ruby back when I frequented ruby-lang, at least.
09:09:03 <MyCatVerbs> centrinia: Smalltalk has a type system? ;P
09:09:10 <centrinia>  :p
09:09:17 <noteventime> The impression I got from scala was a Common Lisp squeezed into a Java syntax
09:09:49 <vixey> scala looks pretty stupid
09:09:51 <MyCatVerbs> noteventime: plus static typing?
09:10:01 <quicksilver> smalltalk has a certain purity of idea which reminds one of haskell
09:10:04 <MyCatVerbs> vixey: syntax really, really doesn't matter much.
09:10:05 <quicksilver> in smalltalk everything is an object
09:10:09 <quicksilver> in haskell everything is a value
09:10:13 <vixey> I'm not talking about the syntax
09:10:17 <quicksilver> this single-minded purity of concept is nice
09:10:42 <MyCatVerbs> vixey: oh? 'Cuz you said "looks", so I thought...
09:10:43 <quicksilver> most of the other languages distinguish between value types and reference types in a way which trips over the semantics
09:10:47 <noteventime> MyCatVerbs: Well, yes :)
09:10:51 <dolio> Types aren't values. Strike 1. :)
09:11:01 <quicksilver> dolio: I think you know what I mean, though?
09:11:08 <dolio> Yes.
09:11:20 <MyCatVerbs> quicksilver: s/trips over the semantics/makes the semantics gratuitously complex, with dozens of extra edge cases/
09:11:25 <Shiruka> the misguided efforts of some people to tack C-like syntax on some bunch of features copied from some other programming language has failed to impress me :-/
09:11:31 <quicksilver> MyCatVerbs: yes, that is almost exactly what I meant.
09:11:34 <quicksilver> MyCatVerbs: thank you :)
09:11:37 <Shiruka> it's like taking a good painting and "improving" it by spraying some graffiti on it
09:12:16 <quicksilver> the thing which is most painful about C++ (to take one example) to me is the whole rvalue/lvalue/pointer/reference/value/copy constructor issure
09:12:23 * MyCatVerbs scrawls "Syntax doesn't bloddy matter, dammit!" in chocolate syrup on the side of a GIANT teddybear, throws it at Shiruka's head.
09:12:35 <MyCatVerbs> quicksilver: you mean the _language_? *ducks*
09:12:54 <Baughn> MyCatVerbs: ..say what you like, syntax does matter
09:12:54 <vixey> MyCatVerbs is probably the only worrying about syntax
09:12:55 <vixey> :p
09:12:59 <vixey> oh ..
09:13:01 <Baughn> It just doesn't matter as /much/ as semantics
09:13:13 <MyCatVerbs> Shiruka: I really don't mind people putting a C skin over nice semantics. What's egrerious is when they *break* the nice semantics while messing around with the C skin.
09:13:16 <quicksilver> MyCatVerbs: Yes, I suppose so. But there are other things about C++ which I like. It does have the abstraction power you need to write sensible systems.
09:13:34 <quicksilver> MyCatVerbs: it just forces you to comprehend some pretty subtle edges cases if you want to not make mistakes.
09:13:45 <noteventime> quicksilver: C++ would be rather nice if they cleaned up the whole template system
09:13:59 <noteventime> As far as imperative languages go anyway
09:14:14 <quicksilver> C++ has "good enough" encapsulation, "good enough" type safety and even "just barely good enough" polymorphism.
09:14:26 <quicksilver> but it surrounds them with bear-traps.
09:14:30 <noteventime> Somehow I still prefer it over Java and C#
09:14:37 <MyCatVerbs> noteventime: ugh, not even close. You still have exceptions, and the whole rvalue/lvalue/pointer/reference/value/copy constructor issue. :P
09:14:56 <noteventime> MyCatVerbs: Well, I didn't say it was nice when compared to real languages ;D
09:14:56 <MyCatVerbs> Baughn: right, okay. But that's a pretty steep gradient of "as much as". Like, _rounding error_ on the semantics.
09:14:57 <olsner> ah yes, that one small issue :D
09:15:34 <MyCatVerbs> noteventime: I mean, outside of C++, practically no one even *has* such an insane concept as exception safety.
09:15:39 <Baughn> MyCatVerbs: Certainly. Still, once you've got good semantics you should take the time to figure out a syntax that fits.
09:15:48 <Baughn> Or, okay, just stick with s-exprs. That works fine too.
09:16:10 <olsner> eugh, C++ with s-expression syntax
09:16:13 <vixey> I thought s-exprs are absolutely awful for any language that you want to write types in
09:16:30 <vixey> I mean optionally annotating things with ::
09:16:32 <Baughn> Nah. No reason they should be.
09:16:34 <baaba> MyCatVerbs, um, ever tried java? c#?
09:16:34 <noteventime> MyCatVerbs: Well it isn't safe language by any means, just the concept of static_cast<void*>&foo gives me goosebumps
09:16:38 <vixey> well they seem to be
09:16:45 <baaba> or any language for that matter that lets you open files
09:16:47 <MyCatVerbs> noteventime: and then there's the dozens of subtle little issues around which functions & methods should return values, references, or what, and if you get it wrong you don't get any kind of warning but your program inexplicably runs quite a bit slower because suddenly it's making more unnecessary copies than a Xerox with satanic firmware.
09:16:48 <baaba> and has exceptions
09:16:51 <Baughn> vixey: Well, you'd annotate them with (constrain-type value 'type) or some such, but..
09:17:03 <vixey> where does that go though?
09:17:06 <Shiruka> noteventime: you can always (void*)&foo! (*ducks*)
09:17:15 <Baughn> vixey: Special form, evaluated at compile-time
09:17:18 <noteventime> Shiruka: Same problem ;)
09:17:25 <vixey> where in the source code
09:17:33 <Baughn> Same place as now
09:17:43 <vixey> I can't see what you are thinking
09:17:43 <tusho> vixey: a :: b = (constrain a b)
09:17:44 <baaba> in java you achieve exception safety with catch(Throwable t) { f.close(); throw t; }
09:17:50 <Twey> Shiruka: I think there are more binary packages
09:17:52 <Baughn> Instead of 2+(3::Int), you'd say (+ 2 (type 3 int))
09:17:57 <baaba> and the requirement for that doesn't disappear when transitioning from c++ to java
09:17:59 <noteventime> I also find it interesting how many C/C++ programmers tend to have something like void* extra_data in their data structures
09:17:59 <olsner> baaba: but exception safety in C++ is much sneakier :)
09:18:01 <Twey> ... oh, I was scrolled up quite a way.
09:18:02 <baaba> c++ just makes it easier with c++
09:18:03 <baaba> err
09:18:05 <baaba> with destructors
09:18:16 <MyCatVerbs> baaba: yes and no. In Java and C#, exceptions aren't anywhere near as painful. For one thing, you don't need to have to worry about exception-safety w.r.t. memory leaks. For another thing, for resources you *do* need to close anyway, there's always finally.
09:18:36 <baaba> MyCatVerbs, memory is a resource
09:18:39 <Twey> C++ doesn't have finally?
09:18:43 <baaba> i don't see why you couldn't treat it uniformly with other resources
09:18:45 <Twey> :-\
09:18:56 <noteventime> MyCatVerbs: RTTI :p
09:19:00 <Zao> Twey: Resources in C++ are generally handled with RAII and scope.
09:19:04 <baaba> noteventime, you mean RAII
09:19:05 <noteventime> err
09:19:10 <Twey> Hmn, OK
09:19:16 <Zao> Or SBRM, as it's a much better acronym
09:19:17 <olsner> noteventime: void* is an approximation of encapsulation :)
09:19:19 <noteventime> baaba: RAII
09:19:21 <noteventime> yes
09:19:21 <Zao> (scope based resource management)
09:19:24 <Baughn> baaba: Timeliness. A garbage collector and finallizers are nice and all, but memory does have the advantage that you can generally put off freeing it until it's convenient.
09:19:37 * centrinia doesn't think that the finally block will execute if you exit(0)
09:19:37 <MyCatVerbs> noteventime: doesn't work for interesting cases without adding a full refcounting scheme in on top.
09:19:38 <noteventime> olsner: void* is for C/C++ programmers who think they use python
09:19:52 <Zao> noteventime: C++ programmers use boost::any
09:19:57 <noteventime> MyCatVerbs: That's what Boost is there for X-D
09:20:17 <baaba> admittedly the difficulty of adding a garbage collector to c++ for some purposes is annoying
09:20:18 <baaba> but then again
09:20:20 <Baughn> centrinia: That's silly. Next you'll claim that database cleanup routines in finally blocks won't execute if you pull the plug.
09:20:22 <noteventime> And when you add all those things, the language is more verbose and slow than Java anyway
09:20:30 <baaba> for those purposes where you need garbage collection you would not be using c++ in the first place
09:20:32 <MyCatVerbs> baaba: funnily enough, no. Unlike many other resources, memory is *fungible* and it's quite possible for language implementors to (very nearly) solve the problem for you.
09:20:56 <noteventime> RTTI is runtime type information, isn't it?
09:21:16 <noteventime> :< What an embarrassing mistake
09:21:19 <olsner> Baughn: How then are you going to get transaction safety!? :P
09:21:29 <MyCatVerbs> baaba: handling memory uniformly with other resources is great, but it isn't a patch on not _having to_ handle memory directly in the first place.
09:21:29 <Baughn> baaba: But when you're done with the exclusive lock on the main criminal information database, that lock needs to be dropped *now*, not when the GC triggers
09:21:43 <Toxaris> baaba: there are two kinds of resources: these were you have a finite amount of equal things, and you don't care which one you use, like memory or processor time; and these where you want exactly one thing and nobody else is allowed to have it at the same time, e.g. tcp/ip ports.
09:21:57 <Baughn> olsner: You tell me. On this hardware, I'm not.
09:22:01 <MyCatVerbs> Toxaris: tcp ports and teddybears.
09:22:06 <Toxaris> baaba: this two kinds of resources imho need different management strategies.
09:22:21 <Toxaris> baaba: e.g. garbage collection for the former, and dynamic scope for the latter
09:22:29 <baaba> uh-huh
09:22:43 <baaba> and none of this makes exception safety a non-issue for languages like c# and java
09:23:03 <Toxaris> MyCatVerbs: teddybears?
09:23:12 <MyCatVerbs> Toxaris: don't even think of stealing my teddybear.
09:23:16 <baaba> the fact that you remove memory from the set of resources to be managed doesn't mean exception safety for things like file descriptors or sockets or what have you disappears
09:23:27 <baaba> er, the need for exception safety
09:23:37 <quicksilver> it does make it less of an issue though
09:23:48 <baaba> not for those resources
09:23:51 <quicksilver> if the number of things you need to concern abotu exception safety for is limited
09:24:01 <quicksilver> memroy is ubiquitous
09:24:04 <baaba> and in c++ you manage things uniformly through deterministic destruction anyway
09:24:05 <quicksilver> so when memory is in the set
09:24:06 <BMeph> C++ is the Devil! >:)
09:24:11 <baaba> and automatic variables
09:24:16 <baaba> you don't heap allocate everything
09:24:17 <quicksilver> so you have to care about exception safety in every memory allocating subroutine
09:24:24 <quicksilver> which is nearly every subroutine
09:24:28 <baaba> in fact you very rarely use new in good c++ code
09:24:32 <quicksilver> right.
09:24:34 <baaba> and even more rarely delete
09:24:36 <quicksilver> I'm aware of the solution.
09:24:38 <quicksilver> but it has a cost.
09:24:50 <quicksilver> bloody cumbersome way to do stuff
09:25:06 <quicksilver> hard to abstract, too.
09:25:08 <olsner> incidentally, I'm currently trying to debug a double-free or heap corruption at work
09:25:16 <hackage> Uploaded to hackage: pureMD5 0.2.4
09:25:16 <hackage> Uploaded to hackage: chp 1.1.0
09:25:16 <hackage> Uploaded to hackage: ghc-paths 0.1.0.4
09:25:17 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.5
09:25:19 <hackage> Uploaded to hackage: lighttpd-conf 0.4
09:25:27 <olsner> and it only reproduces when run on a platform without a debugger :D
09:25:30 <jeffwheeler> Yay! That pureMD5 package now compiles on OS X.
09:26:25 <thoughtpolice> jeffwheeler: it should have installed already - it was a requirement for yi and I installed yi 4.0 a when it came out
09:26:29 <thoughtpolice> er, been installable
09:26:49 <jeffwheeler> thoughtpolice: I installed Yi 0.4 also, but I had to remove -fvia-c from the cabal file to get it to work.
09:26:55 <thoughtpolice> jeffwheeler: weird
09:27:00 <jeffwheeler> Indeed.
09:27:02 <dcoutts_> jeffwheeler: what arch?
09:27:20 <jeffwheeler> dcoutts_ a 32-bit Intel Mac, OS X Leopard
09:27:24 <jeffwheeler> (i386)
09:27:42 * dcoutts_ suspected as much
09:28:13 <dcoutts_> jeffwheeler: or perhaps it's because you were missing header files
09:28:29 <jeffwheeler> dcoutts_: could've been; I don't remember the error I was getting
09:28:47 <jeffwheeler> Obviously, it was some compilation of C things.
09:42:04 <dcoutts_> waern: a good test case is the happs packages, they're currently breaking with haddock 2.2.2 I think
09:44:51 <noteventime> Has anyone succeeded with installing yi through cabal-install?
09:45:05 <Cale> I have
09:45:18 <jeffwheeler> I have, intermittently.
09:45:24 <noteventime> I get an error about it not being able to find the proper version of alex
09:45:32 <atp> is there a fair amount of momentum behind yi these days?
09:45:35 <jeffwheeler> Err, yeah. I had to install that independently.
09:45:36 <noteventime> "cabal: alex version >=2.0.1 && <3 is required but it could not be found."
09:45:43 <dcoutts_> noteventime: so cabal install alex
09:45:56 <noteventime> dcoutts_: I'm not that stupid ;), I did
09:45:59 <noteventime> Still won't work
09:46:15 <jeffwheeler> atp: a fair amount, and a recent release
09:46:17 <noteventime> Though it succeeded in getting alex installed
09:46:26 <dcoutts_> noteventime: it'll be because it's not on your path by default
09:46:44 <noteventime> dcoutts_: Why's that?
09:46:47 <thoughtpolice> noteventime: cp $HOME/.bin/cabal to somewhere in your PATH
09:46:49 <jeffwheeler> noteventime: I think it should be in ~/.cabal/bin
09:46:50 <dcoutts_> noteventime: because http://hackage.haskell.org/trac/hackage/ticket/289
09:46:52 <lambdabot> Title: #289 (symlink binaries into ~/bin) - Hackage - Trac
09:47:07 <noteventime> dcoutts_: Ahh, thanks :)
09:47:10 <dcoutts_> noteventime: because that ticket ^^ hasn't been implemented yet
09:47:12 <thoughtpolice> noteventime: after you put it in your path cabal install yi should work just fine
09:47:33 <jeffwheeler> Yi is installed in the same location (~/.cabal/bin/).
09:47:54 <thoughtpolice> i think jeffwheeler's issue is particularly weird; i'm using a core2 leopard system as well and cabal install yi had no such problems :/
09:47:55 <dcoutts_> noteventime: well, actually it has been implemented now, but it's not in a release yet and we've not all agreed on what the defaults should be.
09:48:04 <noteventime> hmm
09:48:14 <thoughtpolice> chalk it up to an environment issue i guess?
09:48:38 <jeffwheeler> thoughtpolice: with the brand-new pureMD5? It was just fixed about half an hour ago and uploaded to Hackage.
09:48:45 <noteventime> Still doesn't work
09:48:49 <jeffwheeler> Or maybe you had one from before.
09:48:56 <jeffwheeler> Or . . . it could be my fault entirely. :)
09:48:57 <thoughtpolice> jeffwheeler: no
09:49:15 <thoughtpolice> i installed yi 0.4 and by association the older pureMD5 right when yi 0.4 came out
09:49:19 <ecnelis> hi everyone! i need to get mouse coordinates in x11, so i've found queryPointer function in module Graphics.X11.Xlib.Misc. but since i'm total n00b in haskell i don't know how to use it. can anybody help me?
09:49:26 <lament> why does yi need an md5?
09:49:33 <EvilTerran> ?hoogle queryPointer
09:49:33 <lambdabot> No matches found
09:49:36 <noteventime> Do I to make it regenerate some cache or something?
09:49:49 <jeffwheeler> noteventime: what error are you getting?
09:50:08 <jeffwheeler> noteventime: the Alex one, still?
09:50:16 <osfameron> @src splitAt
09:50:17 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
09:50:22 <noteventime> jeffwheeler: (I put ~/.cabal/bin in my PATH), "cabal: alex version >=2.0.1 && <3 is required but it could not be found."
09:50:34 <noteventime> While trying to cabal install yi
09:51:16 <noteventime> Don't I have to put ~/.cabal/lib in some var?
09:51:18 <jeffwheeler> Hmm, I installed alex from Darcs and cabal installed from within the repo; can you get to `alex` from the terminal?
09:51:24 <dcoutts_> noteventime: did you re-configure yi, or are you just doing cabal install yi? does running alex --version from your current shell work?
09:51:33 <noteventime> jeffwheeler: yes
09:51:39 <laz0r> hi, erm, when i reify a data structure which has multiple constructors in template haskell, i get a list of constructors, but when i reify a data structure that only has one constructor, the 'list of constructors' is emtpy
09:52:06 <laz0r> now i would like to get that one constructor, does anyone know how i could do that?
09:52:10 <noteventime> dcoutts_: Just redo the cabal, should remove some cached stuff?
09:52:16 <noteventime> Yes, alex works from the terminal
09:52:53 <laz0r> TyConI (DataD _ _ _ constructors _) <- reify somename, thats what i have been doing so far, which works fine as long as 'somename' has multiple constructors
09:52:54 <jeffwheeler> Does `cabal register` need to run? I've never used that, but it might be the problem.
09:53:00 <dcoutts_> noteventime: if you're in the yi build dir, and just running build without running configure then it doesn't look again for exes.
09:53:20 <dcoutts_> jeffwheeler: it probably did install but ~/.cabal/bin is probably not on your path
09:53:33 <noteventime> dcoutts_: I'm getting yi through cabal install
09:53:45 <jeffwheeler> dcoutts_: Hmm? Alex works fine for me, I'm not having an issue.
09:53:57 <dcoutts_> jeffwheeler: oh, sorry, misunderstood
09:54:12 <jeffwheeler> dcoutts_: My bad; should've prefixed my message :)
09:54:22 <dcoutts_> noteventime: run with -v or -v3, see what it says when it gets to the bit where it detects alex.
09:54:38 <Azure_Ag> Good evening, gentle creatures.
09:54:53 <EvilTerran> laz0r, er, that seems odd
09:55:02 <dcoutts_> jeffwheeler: so what did you mean about register?
09:55:03 <Twey> Good morrow, sweet Azure
09:55:16 <noteventime> dcoutts_: One moment, I just tried removing ~/.cabal/packages/.../yi
09:55:25 <noteventime> Works now
09:55:29 <jeffwheeler> dcoutts_: I was wondering if noteventime needed to run that to detect alex
09:55:30 <laz0r> EvilTerran: yes, i wondered about that too, but for some reason, i'll get an empty list...
09:55:34 <noteventime> Realised I had been installing it with sudo
09:55:51 <noteventime> And didn't see the error messages last time I tried to remove that directory
09:55:59 <jeffwheeler> noteventime: ha, I did that the first few times out of habit
09:56:01 <dcoutts_> noteventime: ah, 'k
09:56:08 <noteventime> Stupid me :p
09:56:23 <laz0r> i could paste my code, maybe someone can point out something obvoius, just give me a second
09:56:32 <noteventime> jeffwheeler: A lot of the times during this conversation I almost said emerge instead of cabal install :p
09:57:28 <jeffwheeler> noteventime: I completely understand that. :D
09:57:31 <Azure_Ag> I've a question.  Well, more a, "Is this actually the way things are." type deal.  Namely, I come from The Land of Scheme.  And I was, at first, quite shocked to see Haskell people using right folds for everything and not writing things tail recursively.
09:57:44 <Azure_Ag> And I realised that with an infinite list, you HAVE to have a right fold, right?
09:58:23 <Azure_Ag> But I also read that with lazy evaluation, writing things tail recursively doesn't actually buy you anythin and you still end up using up space.  Is this actually the case?
09:58:35 <Shiruka> depends
09:58:46 <noteventime> lol
09:59:06 <Azure_Ag> Depends?  On which?
09:59:07 <noteventime> "error: /home/bernardy/.cabal/share/yi-0.4.3/examples/yi.hs: openFile: does not exist"
09:59:11 <Cale> Azure_Ag: yes, unless you go out of your way to make the function strict
09:59:15 <rwbarton> Azure_Ag: Yes, foldl will always diverge on an infinite list
09:59:22 <noteventime> Guess I need to find out where to configure it :p
09:59:30 <ddarius> @wiki Stack overflow
09:59:30 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
09:59:35 <Shiruka> with right fold, the point is that on each step the tail is lazy
09:59:37 <Cale> Azure_Ag: (Or it's already strict because you're pattern matching against that parameter before making the recursive call)
09:59:47 <Azure_Ag> Well, I know the foldl bit.  I was wondering more about whether you could implement the idiom of mutually recursive functions as a finite state machine without using up lotsa' space.
10:00:08 <dcoutts_> noteventime: sounds like a bug in yi. It should be able to find its data files wherever you put it.
10:00:10 <Cale> Azure_Ag: yes, by introducing strictness
10:00:15 <jeffwheeler> noteventime: copy examples/yi.hs into ~/.yi/yi.hs, then running `yi` should create a ~/.yi/yi-<arch>-<platform>
10:00:18 <Shiruka> so when you access the fold, it computes the head and then says "ok, this much you requested, I'll leave the tail as a thunk until you request that too", so there's no recursion to take stack space
10:00:30 <Cale> Azure_Ag: (there's also strictness analysis in the compiler which will catch lots of things)
10:00:55 <ddarius> Azure_Ag: Read that page I referenced.
10:00:58 <Cale> It's easiest to understand just in terms of expressions.
10:01:03 <noteventime> jeffwheeler: Thanks, that did the trick
10:01:13 <Cale> Lazy evaluation is outermost first
10:01:19 * Azure_Ag reads the page.
10:01:36 <Cale> oh, okay...
10:02:33 <Azure_Ag> Why, thank you.  This has answered all my questions.
10:02:36 <jeffwheeler> I think we need to popular #yi.
10:03:22 <jeffwheeler> s/popular/popualte/; grr, why can't I type
10:03:26 <jeffwheeler> err
10:03:29 <jeffwheeler> * populate
10:04:56 <MarcWeber> Is there a Show equivalent returning a ByteString?
10:06:15 <bd_> pack . show? :/
10:06:27 <tromp> sounds redundant. all you need is compose show with a String->ByteString function
10:07:00 <laz0r> EvilTerran: ok, sitting down and trying to construct a little example to put on hpaste has resulted in accidently solving the problem
10:07:13 <vixey> testcase++
10:07:21 <dolio> @hackage bytestring-show
10:07:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-show
10:08:00 <MarcWeber> bd_, tromp But than you get more conversions.. I'd like to rewrite the HTML part of wash to use (lazy) Bytestrings only. The library has been using Show.. that's it
10:08:16 <MarcWeber> So I'll add a ShowBytestring class
10:08:31 <bd_> MarcWeber: for efficiency, you'd probably want to use the Put monad from Data.Binary to build up the bytestring, I guess
10:08:38 <dolio> @hackage bytestring-show
10:08:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-show
10:08:54 <quicksilver> very ugly to use Show for that anyway.
10:08:56 <quicksilver> Bad WASH.
10:09:04 * bd_ nods
10:09:04 <quicksilver> Show is for haskell-syntax representations
10:09:08 <quicksilver> not for formatted output
10:09:25 <bd_> class ToHTML x where writeHTML :: x -> Put () or something
10:09:31 <quicksilver> MarcWeber: you may not get more conversions by using pack.
10:09:37 <quicksilver> MarcWeber: stuff may magically inline and fuse
10:09:40 <quicksilver> or it may not.
10:09:50 <quicksilver> that's the risk you take with static analysis and RULES :)
10:09:52 <bd_> also, GHC should be smart enough to turn String into ByteString.Lazy automagically :)
10:10:01 <MarcWeber> quicksilver: I don't want t spend hours looking at the generated code.. So I'll want to be sure.. :)
10:10:09 <pjdelport> Azure_Ag: are you familiar with catamorphisms in general?
10:11:29 <eu-prleu-peupeu> allright, finally got hopengl to work :)
10:11:40 <MarcWeber> Am I right that I don't have to care about ByteStrings, that it's enough to use lazy bytestrings everywhere?
10:12:01 <dcoutts_> MarcWeber: I suppose so, mostly
10:13:08 <pjdelport> Azure_Ag: foldr is the fundamental list catamorphism
10:13:12 <laz0r> http://hpaste.org/9433
10:13:17 <laz0r> there, still felt like pasting it
10:14:28 <pjdelport> Azure_Ag: it's what you get when you "replace" each constructor (cons and nil, in the case of lists) with a function
10:15:44 <pjdelport> Azure_Ag: the concept generalizes to any algebraic data type
10:17:11 <Azure_Ag> pjdelport: Oh, yes, I'm familiar with catamorphisms and generalising fold and unfold and whatnot.
10:17:31 <pjdelport> ah, ok
10:17:35 <Azure_Ag> pjdelport: I understand why you use a right fold, the increasing space thing was just the only thing I was stuck on.
10:18:01 <Azure_Ag> pjdelport: But the link provided by the kindly ddarius has answered all :)
10:22:33 * qwr stares Posix.IO and wonders, what would be equivalent to flock(fd, LOCK_EX)
10:24:48 <pjdelport> Azure_Ag: right, so in general tail recursion goes hand-in-hand with strict evaluation
10:24:50 <laz0r> urks, i just said i solved the problem with the 'empty list of constructor', but after i put that toTuple function back into the module where I want it to be, the problem is there again
10:25:24 <laz0r> anyone has an idea what could be the reason for that?
10:26:32 <allbery_b> qwr: WriteLock with offset and length = 0.  approximately.
10:27:03 <allbery_b> (fcntl() and flock() don't map to each other exactly; fcntl() is the POSIX-approved lock API)
10:29:49 <qwr> uh, fcntl seems to interpret 0 length as infinity. ok.
10:30:18 <laz0r> ok, well, it seems that it does not work when i'm using it with a data structure that is defined in the same module, but it does work when i'm using it with a data structure that is defined in the same file, as long as that file i not a module...
10:30:35 <qwr> only...        Since kernel 2.0, there is no interaction between  the  types  of  lock
10:30:38 <qwr>        placed by flock(2) and fcntl().
10:30:45 <laz0r> whatever, i figured out something that works, and i'm gonna stick with that
10:31:01 <qwr> so, basically both processes have to use fcntl then
10:31:15 <allbery_b> yes
10:31:29 <allbery_b> but they should anyway for portability
10:32:26 <noteventime> Do I have to activate automatic indentation in Yi, or is there no such thing?
10:33:31 <qwr> ok, i just wanted an easy mutex and flock looked fine for that in perl... ;)
10:34:30 <laz0r> mmh, what i just said is not the reason why it is not working... i wonder what causes this problem, i'm going to paste the whole module, maybe someone can figure it out
10:45:10 <bos> well! that was confusing.
10:45:28 <bos> any #haskell people going to ICFP / haskell workshop / CUFP / DEFUN next month?
10:45:57 <jeffwheeler> noteventime: I think it should work in Yi, but I think the default behavior in cleverHaskellMode is to tab through the likely options, starting with the left-most.
10:46:33 <noteventime> jeffwheeler: I only get two tab options :/
10:46:41 <noteventime> And both are "wrong"
10:46:45 <jeffwheeler> noteventime: then it's time to improve Yi :D
10:46:54 <noteventime> I'm way to nub for that
10:47:27 <jeffwheeler> noteventime: Ha; I'm a Haskell beginner but I've been looking at the src; it's very clean, and a lot is pretty easy to understand.
10:47:37 <noteventime> Hmm
10:47:56 <noteventime> Maybe I'll take a look at it, I need to learn code-reading
10:48:10 <noteventime> I always get headaches from reading other peoples' code :p
10:48:10 <jeffwheeler> I played with a lexer the other day and was able to work on the Python one.
10:48:32 <noteventime> Though, I have to admit, I've mainly been trying to read C-code
10:48:37 <opqdonut> seems there is no cabal package for debian?
10:48:38 <noteventime> And I got headaches from my own C-code
10:48:46 <bos> @seen dons
10:48:46 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I don't know when dons last spoke.
10:48:52 <dcoutts_> opqdonut: it comes with ghc
10:48:55 <opqdonut> ah
10:49:00 <dcoutts_> opqdonut: or you can upgrade it yourself
10:49:09 <dino-> :t Data.List.nub
10:49:11 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:49:21 <opqdonut> dcoutts_: how do I know which version is installed?
10:49:29 <dcoutts_> ghc-pkg list Cabal
11:02:54 <siponen> Ymh... Why does ghc complain "Could not find module 'System.FilePath'" when I try to compile Cabal?
11:03:18 <dcoutts_> siponen: you're probably using ghc-6.6
11:03:25 <siponen> True.
11:03:28 <bwr_> i am trying to parse text delimited by tabs into columns. what is wrong with:
11:03:32 <bwr_> columnize [] = []
11:03:32 <bwr_> columnize xs = [col] : columnize xs' where (col,(_:xs')) = span (/='\t') xs
11:03:46 <dcoutts_> siponen: see the Cabal home page for instructions on how to bootstrap when you don't already have filepath
11:04:30 <dmhouse> bwr_: you probably mean col : columnize xs'
11:04:40 <bwr_> oh
11:04:41 <bwr_> hehe
11:05:07 <vixey> > let columnize [] = [] ; columnize xs = [col] : columnize xs' where (col,(_:xs')) = span (/=',') xs in columnize "a,bc,d"
11:05:10 <lambdabot>   Irrefutable pattern failed for pattern (col, (_ : xs'))
11:05:15 <bwr_> that's what i get
11:05:22 <vixey> > let columnize [] = [] ; columnize xs = [col] : columnize xs' where (col,(_:xs')) = span (/=',') xs in columnize "a,bc,d,"
11:05:23 <lambdabot>  [["a"],["bc"],["d"]]
11:05:34 <bwr_> what did you change...
11:05:44 <siponen> dcoutts: Maybe I'll take this as a sign to update my ghc...
11:05:45 <vixey> look closely
11:05:50 <vixey> > let columnize [] = [] ; columnize xs = case span (/=',') xs of (col,(_:xs')) -> [col] : columnize xs' in columnize "a,bc,d,"
11:05:50 <bwr_> ok
11:05:51 <lambdabot>  [["a"],["bc"],["d"]]
11:05:53 <vixey> > let columnize [] = [] ; columnize xs = case span (/=',') xs of (col,(_:xs')) -> [col] : columnize xs' in columnize "a,bc,d"
11:05:54 <lambdabot>   Non-exhaustive patterns in case
11:05:56 <dcoutts_> siponen: that works too
11:05:58 <dmhouse> bwr_: you need to add a case for (col,[])
11:06:01 <vixey> > let columnize [] = [] ; columnize xs = case span (/=',') xs of (col,(_:xs')) -> [col] : columnize xs' ; _ -> [] in columnize "a,bc,d"
11:06:02 <lambdabot>  [["a"],["bc"]]
11:06:05 <bwr_> ok
11:06:08 <vixey> > let columnize [] = [] ; columnize xs = case span (/=',') xs of (col,(_:xs')) -> col : columnize xs' ; _ -> [] in columnize "a,bc,d"
11:06:08 <dcoutts_> siponen: even 6.6.1 would be ok
11:06:09 <lambdabot>  ["a","bc"]
11:06:20 <vixey> > let columnize [] = [] ; columnize xs = case span (/=',') xs of (col,(_:xs')) -> col : columnize xs' ; _ -> [xs] in columnize "a,bc,d"
11:06:21 <lambdabot>  ["a","bc","d"]
11:06:47 <dcoutts_> siponen: or follow the instructions here: http://www.haskell.org/cabal/code.html
11:06:47 <lambdabot> Title: Getting the Code
11:07:27 <dcoutts_> siponen: you've got an older version of Cabal already, so you can use that to install filepath, and from there you can install the newer Cabal
11:08:15 <dolio> > let columnize [] = [] ; columnize xs = [col] : columnize (drop 1 xs') where (col,xs') = span (/=',') xs in columnize "a,bc,d"
11:08:18 <lambdabot>  [["a"],["bc"],["d"]]
11:08:20 <Cale> http://img368.imageshack.us/img368/918/gatcifhj1.gif -- I nominate hypnocat to be our new mascot!
11:08:31 <dmhouse> dolio: gah, I was just there ;)
11:09:07 <vegai> Hey. I was wondering if it is possible to get patches from hackage in some other format than darcs patch?
11:09:17 <bwr_> thanks guys
11:09:39 <vegai> I'd need the patch in here specifically: http://hackage.haskell.org/trac/ghc/ticket/2314
11:20:39 <ilyak_> hpaste.org, sadly, can't handle unicode.
11:20:51 <vixey> yeah it sucks
11:21:00 <vixey> haskell can't do unicode or something :p
11:21:06 <ilyak_> vixey: Well, it can
11:21:29 <ilyak_> You even can use unicode characters in symbol names, GHC supports it
11:21:45 <ilyak_> Tho there are still a few glitches
11:22:10 <vixey> > let (×) = (++) in "haskell" × "cant" × "do" × "unicode"
11:22:10 <lambdabot>  Illegal character ''\215''
11:22:10 <lambdabot>  at ")" (column 6)
11:22:16 <Cale> The next GHC should support UTF-8 encoded I/O by default.
11:22:47 <ilyak_> vixey: locale?
11:23:04 <ilyak_> I've wrote a program with greek letters as variable names
11:23:16 <ilyak_> It compiled and ran just fine
11:23:18 <dmhouse> I think that's just GHC(i).
11:23:33 <ilyak_> ghc and ghci
11:23:35 <vegai> so, no darcs patch => unified diff transmogrifier?
11:23:39 <vixey> haskell and ghci can do unicode just fine
11:23:43 <EvilTerran> vixey, Language.Haskell.Syntax doesn't support unicode
11:23:44 <dmhouse> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
11:23:44 <dmhouse>  
11:23:44 <dmhouse> Prelude> let (×) = (++) in "haskell" × "cant" × "do" × "unicode"
11:23:44 <dmhouse> "haskellcantdounicode"
11:23:44 <lambdabot> Title: The Glasgow Haskell Compiler
11:24:01 <vixey> What is strange and confuses is me is that Haskell programs don't support unicode, for.. no reason what-so-ever
11:24:20 <EvilTerran> and lambdabot parses expressions given to > with it before running them for some reason
11:24:28 <ilyak_> There's a lib about that.
11:24:31 <EvilTerran> ?type let (×) = (++) in "haskell" × "cant" × "do" × "unicode"
11:24:32 <lambdabot> [Char]
11:24:42 <EvilTerran> vixey, it doesn't do it for ?type, though :)
11:24:47 <ilyak_> System.IO.UTF8
11:24:51 <ilyak_> google for it.
11:25:02 <vixey> ilyak_: Yeah I already use it in programs I've written
11:25:12 <ilyak_> The problem, I guess, is that haskell98 is a bit rusty and say nothing about unicode
11:25:27 <vixey> ilyak_: no there is no problem
11:25:38 <vixey> ilyak_: It's just some weird anomaly without reason
11:25:41 <ilyak_> vixey: I mean, so standard IO doesn't support it
11:25:47 <ilyak_> Oh, then I don't really know
11:26:09 <rwbarton> ilyak_: It says "The character type Char is an enumeration whose values represent Unicode characters", but nothing about UTF-8.
11:26:32 <ilyak_> rwbarton: Yeah, so IO doesn't do unicode, it reads and writes octets
11:27:22 <vegai> well, perhaps manually. It's not a large patch than
11:27:29 <ilyak_> I guess that haskell source with greek variable names and non-ascii symbols as operators would provide even better brane explosions
11:27:43 <ilyak_> vixey: System.IO.UTF8 is tiny, yeah
11:27:49 * vixey is keen on greek letters and squiggly symbols :p
11:28:07 <ziman> i'd like it :)
11:28:17 <kowey> it would be nice if it let you trap decoding errors
11:28:23 <vixey> It's still irritating that you can't choose which symbols/glyphs are upper/lower/operators
11:28:25 <kowey> hopefully a future version
11:28:41 <ilyak_> vixey: Why, it guesses reasonably as far as I see
11:28:45 <Philippa_> how does literate haskell interact with pragmas?
11:28:55 <Philippa_> especially ones that need to go on the first line?
11:29:02 <ilyak_> greek lower letters are fine as variables but capital cause 'unknown constructor'
11:29:44 <vixey> ilyak_: Sometimes I would like it if it chose differently
11:39:05 <vixey> this looks interesting http://research.microsoft.com/~emeijer/Papers/Thesis.pdf
11:39:05 <lambdabot> Title: ¢¡¤£¦¥¨§©£ ¡ ¢ ! "# £ $#%'&
11:40:24 <siponen> Hmm... And now that I have Cabal installed, how should I give credit to all those people who have written the code in my programs :) How strict a greets-scroller policy do we have? Do people get flamed for years for forgetting a name on the scrolly like in demoscene? :)
11:40:52 <ilyak_> Cool title! Speaking of squiggly symbols
11:40:57 <mfp> if I'm to go by the title, it'll be uncomprehensible
11:41:05 <vixey> hehe
11:41:28 <Baughn> siponen: Eh, just follow the license. If they want advertisement, they'll pick BSD-with-adclause
11:42:14 <sjanssen> siponen: of course you also need to maintain copyright notices
11:42:34 <Baughn> Right, that falls under "follow the license"
11:52:04 <siponen> Ah, no problems with followin licences and stuff... It still doesn't work (my cabal installation that is)
11:54:05 <siponen> All the packages that I try to install say "Setup: packagename.cabal Executable stanza starting with 'cabal-version'"
11:54:47 <siponen> Redofromstart at this point I think...
11:59:29 <siponen> Hmm... Could it be that I still need to update my ghc to use some packages?
11:59:36 <siponen> Aww...
11:59:48 <Baughn> What version are you on?
11:59:51 <siponen> 6.6
11:59:56 <Baughn> Pack..ag.....
12:00:17 <Baughn> Um. Package authors usually assume you've got the newest version, so you can't expect 6.8.2 to work forever when 6.8.3 is out, for example.
12:00:37 <Baughn> (Though that usually isn't a large problem. 6.6, now..)
12:00:46 <siponen> Ok. Just that Debian only provides 6.6 it seems.
12:00:56 <Baughn> Uninstall it, and install on your own
12:01:05 <Baughn> You know how debian feels about modern software
12:01:29 <thoughtpolice> minor releases typically aren't the problem since new features aren't really introduced - although they can have undesirable effects (regressions/differentiating behavior)
12:01:41 <MyCatVerbs> Er, don't uninstall it.
12:02:05 <MyCatVerbs> Use it to build a new one, install that somewhere usable, *then* remove the old one.
12:02:16 <thoughtpolice> i.e. the 6.8.3 regression on the shootout's recursive benchmark (several rules don't fire which slows things down considerably)
12:03:31 <thoughtpolice> yeah, major releases though... i mean, ghc 6.10 isn't even out yet and there's already stuff using the new quasiquoting
12:04:11 <siponen> Ok.
12:04:18 <olsner> > 1920%1080
12:04:19 <lambdabot>  16%9
12:04:47 <siponen> Lets see how the eeepc performs building ghc :)
12:05:04 <newsham> sounds like a great way to burn flash
12:05:13 <gwern> byorgey__: 'poetix: Avoiding lambdas is pointless <-- *groan*'?
12:05:24 <siponen> Modern flashes don't burn that easy enymore.
12:05:26 <gwern> byorgey__: you realize that  the <-- was my editorial on poetix's comment, right?
12:05:28 <olsner> @index (%)
12:05:28 <lambdabot> Data.Ratio
12:06:04 <newsham> i liked the funptrs quote better
12:06:14 <siponen> Anyway I have to burn all the flash I can during the 4 years of garanty...
12:06:28 <sw17ch> FunPtr are not fun
12:06:41 <newsham> they're not that horrible
12:06:46 <sw17ch> hehe, i know
12:07:01 <siponen> flashes usually die within the first year or so if they are to a quick death.
12:07:09 <newsham> what guarantee do they give you, sip?
12:07:24 <siponen> All exept battery.
12:07:36 <newsham> thats not what i meant by "burning".  not mortality so much as reaching the maximum erases on blocks
12:07:44 <siponen> But taht is not from ASUS that is from the ignorant re-seller.
12:08:03 <newsham> i doubt they'll replace your flash after you burnt through half the blocks
12:09:43 <sw17ch> what kind of file system does the EEE use?
12:09:56 <siponen> They should replace the thing if it produces a defect on it's own.
12:10:05 <newsham> http://en.wikipedia.org/wiki/Flash_memory#Memory_wear
12:10:05 <lambdabot> Title: Flash memory - Wikipedia, the free encyclopedia
12:10:10 <sw17ch> i've been using jffs2 in my embedded application
12:10:20 <newsham> siponen: its normal behavior for a flash to wear out
12:10:25 <newsham> its not a manufacturing defect
12:10:28 <sw17ch> what i understand from taht one is that it automagically balances writes to different sectors
12:11:47 <newsham> *nod* olpc uses that too.  it has really slow mount times though
12:12:06 <newsham> and android uses yaffs
12:12:16 <olsner> haskell-src is missing a dependency on happy
12:12:23 <Baughn> sw17ch: Of course, some flash devices do that automatically, which makes using jffs2 possibly a bit redundant
12:12:35 <Baughn> I imagine it's useful if you're using the chip raw, though
12:12:49 <siponen> If someone really wants to know he has to provide me with a command to type on this EEE...
12:12:50 <sw17ch> Baughn, not in my world :(
12:12:52 <gwern> olsner: happy is an executable, innit?
12:12:57 <sw17ch> mount -l
12:13:04 <siponen> mount -l
12:13:04 <olsner> ... or maybe something else is the problem, since it doesn't work with happy installed either
12:13:19 <newsham> sip: you could always plug in a usb hard drive or use a network share to do your build on a disk filesystem
12:13:30 <newsham> to avoid the tons of intermediate files on your flash
12:13:32 <siponen> ext3
12:13:46 <Baughn> sw17ch: Pity. Why is it so slow, though? It's not just the device?
12:13:47 <sw17ch> hmmm...
12:13:54 <olsner> ah, path trouble
12:13:55 <newsham> (although it still might put a lot on /tmp)
12:14:04 <sw17ch> Baughn, jffs2? slow? yes
12:14:26 <siponen> newsham: this takes SD-card too...
12:14:53 <sw17ch> Baughn, actually, i don't knwo waht you're referring to as slow
12:15:15 <newsham> jffs2 reads every block before mounting the device :(
12:15:17 <MyCatVerbs> thoughtpolice: it's not just "several" rules failing to fire.
12:15:58 <MyCatVerbs> thoughtpolice: when I tried it with both 6.8.2 and 6.8.3, viewing the output with ghc-core, the difference was something like ~450 ticks versus ~600. :)
12:15:59 <Baughn> newsham: Ah. Interesting.. it's not just to check for read errors, I suppose
12:16:02 <olsner> gwern: yes, but... if it's required to build the package, it is a dependency (but I guess opinions differ on what exactly to do with build-time only dependencies)
12:16:16 <MyCatVerbs> thoughtpolice: all because the compiler decided not to hit up SPECIALIZE.
12:16:56 <Baughn> sw17ch: Hm, found a message claiming that jffs2 (2.6 version, but anyway..) should be about an order of magnitude faster on nor flash than nand. Is this right?
12:17:03 <newsham> http://en.wikipedia.org/wiki/JFFS2#Disadvantages
12:17:04 <lambdabot> Title: JFFS2 - Wikipedia, the free encyclopedia
12:17:08 <wat>                     kkkkDDDDDDDDDDDDkk
12:17:18 <sw17ch> jffs2 stores a TON of stuff in RAM
12:17:34 <sw17ch> but it reduces flash clobbering
12:18:00 <sw17ch> and when you care much more about device lifetime than you care about speed (which is often the case in my embedded world), you want something that will not kill your hardwarew
12:18:21 <newsham> http://www.yaffs.net/comparison-yaffs-vs-jffs
12:18:22 <lambdabot> Title: Comparison between YAFFS (YAFFS2) and JFFS2 | YAFFS
12:18:37 <newsham> (might be biased :)
12:19:04 <sw17ch> newsham, wikipedia is a strictly unbiased encyclopedia. i don't see how you could think otherwise :P
12:19:24 <gwern> olsner: iirc, currently cabal doesn't track executable packages, just libraries
12:19:45 <anon> DICKS EVERYWHERE
12:19:48 <gwern> olsner: so you get situations where people try to install yi, which needs alex for parsing, but it fails when cabal can't find any alex in $PATH
12:20:01 <newsham> i meant the yaffs url
12:20:05 <gwern> olsner: but since alex is not a tracked package, cabal also will not try to install it
12:20:30 <olsner> hmm, but wouldn't adding alex as a dependency fix that? I mean, I just installed happy through cabal install happy and it worked :D
12:20:38 <EvilTerran> anyone fancy banning 5ad2956f.bb.sky.com?
12:20:50 <olsner> after setting the path to include ~/.cabal/bin, that was
12:21:12 <MarcWeber> Is there a ByteString library with unicode support?
12:21:12 <gwern> olsner: you can't do that unless alex were a library/executable package
12:21:35 <gwern> olsner: this is half of the reason I advocate always making one's executables split between a library & executable, btw
12:21:47 <gwern> MarcWeber: someone was working on one, but dunno if they've released it
12:22:26 <MarcWeber> gwern All you need to do is copy paste the bytestring library and replace all Char8 by Char, don't you?
12:23:00 <sw17ch> i finished my portaudio.h FFI bindings last night... now i'm working on the wrapper to make it more useable in a haskell context... but i'm left with a question...
12:23:02 <gwern> MarcWeber: if it were that easy, would've been done already, no?
12:23:24 <sw17ch> would it be better to make multi channel audio like this: [(chan1,chan2,..,chanN)]
12:23:31 <siponen> Ah, flash failure problems either. The xandros base-package doesn't contein even the basic tools for running configure...
12:23:39 <sw17ch> or like this: [[chan1,chan2,...,chanN]]
12:23:48 <siponen> Ijust like this distribution.
12:23:54 <MarcWeber> gwern: What is the problem with that?
12:24:13 <siponen> It contains all you can imagine if you can imagine only surfing web.
12:25:42 <ilyak_> sw17ch: I guess the second version
12:26:12 <gwern> MarcWeber: I'm not sure it makes sense what you say. what is the bit represenation of a Char? it's a unicode point
12:26:18 <ilyak_> because channels are homogenios, and you will want to iterate on them
12:26:32 <sw17ch> ilyak_, that's what i was thinking
12:26:51 <gwern> MarcWeber: or to put it another way, I understand strings are hard, and I doubt it's as simple as all that
12:27:03 <sw17ch> and i don't really want to make storable instances for (Int,Int), (Int,Int,Int), (Int....Int)
12:27:18 <MarcWeber> Each unicode character can be represented as a 16-bit integer, right? @gwern
12:27:30 <sw17ch> MarcWeber, maybe utf16
12:27:38 <MarcWeber> those 16 bit integers can be encoded differently. such as utf8 or utf16 etc..
12:27:44 <sw17ch> but Unicode is much more complex than just 16 bits per character
12:27:46 <Deewiant> MarcWeber: no, 20-bit
12:27:49 <Deewiant> calc
12:27:55 <Deewiant> err
12:28:27 <Deewiant> 21-bit
12:28:31 <gwern> MarcWeber: http://hackage.haskell.org/trac/summer-of-code/ticket/12
12:28:32 <lambdabot> Title: #12 (Data.ByteString - Unicode layer over Data.ByteString) - Haskell.org Google  ...
12:28:42 <Deewiant> since it's 0 to 0x10ffff inclusive
12:28:49 <ilyak_> sw17ch: Not until compile time maths and variable argument functions are in the default library :)
12:29:06 <sw17ch> ilyak_, :)
12:29:11 <hesselink> MarcWeber: I read this recently, is this what you want? http://koweycode.blogspot.com/2008/07/simply-reading-and-writing-utf-8-in.html
12:29:16 <lambdabot> Title: koweycode: simply reading and writing UTF-8 in Haskell, http://tinyurl.com/5drpt3
12:29:29 <gwern> MarcWeber: there's also this compactstring http://www.haskell.org/pipermail/haskell/2007-March/019218.html stuff which I've never heard of
12:29:30 <lambdabot> Title: [Haskell] ANNOUNCE: Data.CompactString 0.3 - Unicode ByteString with different e ...
12:29:37 <sw17ch> ilyak_, I'll end up doing a whole bunch of withArray's
12:29:38 <newsham> unicode has a bit representation.
12:29:43 <sw17ch> and that made the tuple form easier
12:29:57 <newsham> err.. maybe thats not quite right
12:30:01 <ejt> hi all, is there a decent SHA1 library out there, I tried Data.Digest.SHA1 and it runs slower than treacle at the north pole ?
12:30:01 <sjanssen> newsham: it is wrong to say "a"
12:30:50 <gwern> ejt: there are 6 or so versions of SHA1, ranging from unoptimized pure haskell versions to FFI bindings to openssl
12:30:58 <sjanssen> there are several serialization schemes for sequences of Unicode code points (UTF-16, UTF-8, UTF-32, and also big and little endian variants)
12:31:16 <ejt> gwern: great, are they on Hackage ?
12:31:33 <newsham> *nod*
12:31:42 <MarcWeber> No, CompactString is not there.
12:31:47 <gwern> ejt: some are, some aren't
12:32:11 <sjanssen> MarcWeber: StorableVector is essentially ByteString generalized to any Storable
12:32:31 <sjanssen> MarcWeber: it doesn't have any IO routines, however
12:32:42 <sw17ch> @hoogle StorableVector
12:32:43 <lambdabot> No matches found
12:32:49 <sjanssen> @google storablevector
12:32:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/storablevector
12:32:52 <lambdabot> Title: HackageDB: storablevector-0.1.2.2
12:33:02 <hesselink> MarcWeber: This looks pretty good: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
12:33:03 <newsham> ejt: http://hackage.haskell.org/packages/archive/nano-hmac/0.2.0/doc/html/Data-Digest-OpenSSL-HMAC.html
12:33:04 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
12:33:04 <lambdabot> Title: Data.Digest.OpenSSL.HMAC, http://tinyurl.com/6zqkhf
12:33:21 <ejt> newsham: thx
12:35:21 <MarcWeber> Now I'm totally puzzled :) I thought just using 16 bit characters would solve all trouble .. But indeed 16bit is not enough (propably enough for most cases though)..
12:35:57 <gwern> MarcWeber: as I said, strings are hard
12:37:56 <Orphi> is anything alive in here?
12:38:17 * sw17ch is a zombie
12:38:28 <Orphi> o_O
12:38:54 <Dr_Foo> sweet zombie jesus!
12:38:57 <Twey> Rrrrh... braaaaains...
12:39:10 <Orphi> well, I guess this *is* the place for brains...
12:39:16 <Twey> > cycle "brains"
12:39:17 <lambdabot>  "brainsbrainsbrainsbrainsbrainsbrainsbrainsbrainsbrainsbrainsbrainsbrainsbra...
12:39:36 * gwern noms on lambdabot's brains
12:39:39 <sw17ch> functional brains are too sinewy from working out, #java would be a better place for squshy tastey ones :)
12:39:41 <Deewiant> > cycle "OM N"
12:39:42 <lambdabot>  "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
12:39:54 <olsner> what's supposed to go in the lambdabot passwd.rc file?
12:40:01 <Orphi> well, I just had a look on #cabal, and it has ZERO USERS connected.
12:40:22 <sjanssen> Orphi: I think most Cabal chatter happens here or in #ghc
12:40:24 <Orphi> so I guess 1 undead is better than nothing
12:40:25 <dcoutts> Orphi: we talk about Cabal here
12:40:50 <Orphi> weee... it's amazing how Duncan always manages to pop up like that ;)
12:40:54 <gwern> can't say I've ever talked about cabal in #ghc
12:41:11 <gwern> dcoutts: incidentally, I take it you'll add haddock option to cabal config soon?
12:41:39 <dcoutts> gwern: done already
12:41:46 <dcoutts> gwern: oh, to the config, sorry, not done
12:42:04 <dcoutts> gwern: I'd prefer to do it properly
12:42:10 <Orphi> is there any specific reason why cabal's "sdist" requires tar?
12:42:16 <Orphi> or is it just to reduce portability?
12:42:42 <gwern> dcoutts: properly?
12:42:53 <gwern> Orphi: as opposed to what, zip?
12:44:17 <sjanssen> Orphi: I'm sure the reason is that sdist creates a tarball
12:44:54 <Orphi> gwern: at least Zip doesn't require two stages to decompress (assuming you can find suitable tools on Windows)
12:45:13 <Orphi> sjanssen: Darcs uses (IIRC) gzip, but doesn't require an external binary to do it.
12:46:04 <gwern> Orphi: what's wrong with uzing gzip to compress and tar to serialize? seems a perfectly sensible separation to me
12:46:25 <Shiruka> tar zxf, tar zcf does them with one command..
12:46:26 <Beelsebob> is there no build in sin^(-1), cos^(-1), tan^(-1) function?
12:46:49 <Orphi> Shiruka: "tar" doesn't exist on Windows, so you have to use other tools.
12:47:08 <Shiruka> and IIRC zip doesn't store permissions properly, mostly important for the execute bit.. dunno if sdist needs that though (since I don't know what it does :-)
12:47:16 <bd_> Orphi: or emit the tar file format... :)
12:47:34 <sjanssen> Shiruka: yes, this could cause problems with configure scripts, for example
12:47:37 <Beelsebob> Shiruka: at least OS X's implementation of zip store the x bit
12:47:44 <Shiruka> Orphi: nobody's ported tar to windows? I find that hard to believe
12:47:47 <Beelsebob> stores*
12:47:48 <Orphi> gwern: well OK, having to decompress manually in two steps is irritating, but having Cabal not either statically link the necessary library or supply an external binary with is just means it's broken "out of the box"
12:48:21 <Orphi> Shiruka: I found *a* port of tar, but it fails to execute due to a missing "cygwin.dll", which I can't obtain from anywhere.
12:48:57 <Shiruka> cygwin.dll is probably found from http://www.cygwin.com ...
12:48:58 <lambdabot> Title: Cygwin Information and Installation
12:49:01 <dmhouse> Orphi: cygwin is an implementation of some common Linux functions on Windows.
12:49:14 <sw17ch> Orphi, http://gnuwin32.sourceforge.net/packages/libarchive.htm
12:49:15 <lambdabot> Title: LibArchive for Windows
12:49:21 <dmhouse> It's _really_ useful. You can actually pretend you're in Linux with Cygwin+Emacs.
12:49:21 <Plareplane> there are plenty of programs that can work with tar files on windows, but none of them come by default
12:49:27 <sw17ch> Orphi, http://gnuwin32.sourceforge.net/packages.html
12:49:27 <Orphi> dmhouse: cygwin is a Unix emulator, yes. You would *think* you could grab the DLL from the website....... but no.
12:49:28 <lambdabot> Title: GnuWin32 Packages
12:49:48 <dmhouse> Also, a program like 7z will extract tar files.
12:49:58 <olsner> btw, playing around with your own lambdabot is an infinite amount of fun
12:50:06 <Orphi> dmhouse: Personally I use 7zip - but it requires two manual stages.
12:50:10 * vixey is confused by page 7 :/
12:50:26 <Beelsebob> Orphi: you could always use a platform that you can get lots of software for easily
12:50:27 * Beelsebob ducks
12:50:59 <Orphi> Beelsebob: That's interesting. The main reason I use Windoze is because that's where all the software is. :-P
12:51:08 <Orphi> ;)
12:51:09 <pozic> How can I use a pretty print library to align columns of data? wl-pprint is not realy working.
12:51:16 <sjanssen> Beelsebob: or perhaps Orphi should simply report his missing tar issue in Windows' public bug tracker? :P
12:51:19 <Plareplane> it's considered abusing a monopoly to bundle software!
12:51:21 <dcoutts> Orphi: cabal's sdist does not require tar, precisely to increase portability! :-)
12:51:22 * Plareplane ducks harder!
12:51:31 <Beelsebob> Orphi: the reason I use Mac OS is that I can easily run all the Mac OS software, all the windows software and 99% of UNIX software ;)
12:51:42 <Orphi> dcoutts: then why does it fail containing that it can't find tar?
12:51:42 <Beelsebob> sjanssen: that too, obviously :P
12:51:55 <dcoutts> Orphi: the runghc Setup.hs sdist does call tar, but cabal-install, the 'cabal' command has it's own internal tar code.
12:52:03 <MarcWeber> gwern hesselink I've looked it up: ghc uses 31 bit's for characters since 2000. So rewriting bytestring to use 32bit integers would do.. But I'm not sure how much this would slow down things due to more memory consumption and less cache hits etc..
12:52:24 <Orphi> dcoutts: I see. I'm fairly sure I don't have that...
12:52:29 <MarcWeber> Would a bytestring containing 32bit ints still have advantages over Strings ?
12:52:31 <sjanssen> MarcWeber: again, I suggest you look at storablevector
12:52:48 <Shiruka> <lispermode> I use Linux because I can use infix notat... uh, windows software in qemu, but I don't end up using it anyway, so prefix nota... uh, linux software is better </lispermode>
12:53:14 <allbery_b> vectors are much faster than linked lists
12:53:19 <olsner> how do you change the name of a lambdabot without restarting it?
12:53:29 <MarcWeber> sjanssen sorry I've missed your tip the first time
12:53:56 <Orphi> dcoutts: so if I ever want to try making a Cabal package, I need to track down cabal-install?
12:54:56 <dcoutts> Orphi: it's the best thing since sliced bread
12:55:08 <Orphi> dcoutts: does it actually run here?
12:55:17 <dcoutts> Orphi: where here == windows ?
12:55:24 <sjanssen> MarcWeber: so 'Vector Word8' is essentially equivalent to ByteString, and 'Vector Char' is the structure you're looking for
12:55:27 <Orphi> dcoutts: yeah.
12:55:34 <dcoutts> Orphi: if so, the answer is yes, cabal can do that :-)
12:55:46 <sjanssen> @faq
12:55:47 <lambdabot> The answer is: Yes! Haskell can do that.
12:55:52 <byorgey> we need a parameterized @faq command
12:55:56 <sjanssen> dcoutts: perhaps we need @cabal-faq
12:55:56 <dcoutts> Orphi: that's why we added the tar code, to help poor windows users who lack gnu tar
12:56:07 <dcoutts> sjanssen: :-)
12:56:11 <sjanssen> byorgey: ah yes, that would be better
12:56:14 <camio> @faq
12:56:14 <lambdabot> The answer is: Yes! Haskell can do that.
12:56:25 <sjanssen> byorgey: sounds like a 120 second patch
12:56:25 <camio> hehe, I like that.
12:56:36 <Orphi> dcoutts: Also... "structure of a Haskell project" recommends using a Bash script (!!) to run your package tests :-(
12:56:40 <byorgey> sjanssen: indeed, I'm already 20 seconds ahead of you =)
12:56:47 <dcoutts> Orphi: use whatever you like
12:57:21 <dcoutts> Orphi: we've not properly addressed running testsuites from cabal yet
12:57:22 <Orphi> dcoutts: yes, but would it not be better to not recommend that people use something non-portable as part of all Haskell projects?
12:57:33 <dcoutts> but we'll get round to it, and fear not it'll be portable
12:57:50 <dcoutts> Orphi: suggest to the authors of that page that they suggest something more portable.
12:58:05 <Orphi> dcoutts: OK, I'll add a comment to the Wiki.
12:58:41 <Orphi> dcoutts: Between Haskell bindings to C that don't want to build, and Cabal wanting tar around, and so forth, I'm kinda feeling like the poor relation out here on Windows... heh :-S
12:59:00 <olsner> hmm, now my lambdabot gives this when I try to evaluate anything: /tmp/MNVAX29907.o: unknown symbol `__stginit_bytestringzm0zi9zi1zi0_DataziByteString_'
13:00:05 <trofimovich> ghc-pkg list | grep bytestring
13:00:36 <Jedai> Orphi: You don't have tar in your development environment on Windows ? That's a problem in much more case than just Haskell !!
13:00:57 <sjanssen> Orphi: some of that hierarchy seems funky.  I don't think I've seen a project use "testsuite/tests/" with a mirrored module hierarchy under it
13:01:15 <Orphi> Jedai: why would I *need* tar?
13:01:16 <byorgey> olsner: maybe do a clean and rebuild?
13:01:31 <olsner> hmm, I have two bytestrings ... 0.9.1.0 and 0.9.0.1
13:01:50 <Jedai> Orphi: You should really install Msys and Mingw if you want to muck with programs that originated from a Posix world anyway, the native windows toolkit (VC++) don't handle them gracefully
13:01:53 <olsner> package ghc-6.8.2 requires bytestring-0.9.0.1
13:01:53 <dmhouse> What are some nice examples of fix other than fix (const "foo") and fix (1:)?
13:02:10 <olsner> package zlib-0.4.0.4 requires bytestring-0.9.1.0 (for various other values of zlib-0.4.0.4)
13:02:26 <olsner> cabal warns me when building lambdabot :S
13:02:28 <Orphi> Jedai: and why would I want to have anything to do with Posix? I'm just trying to write Haskell programs...
13:02:34 <Jedai> byorgey: There's plenty of libraries that comes in tar, there's plenty of thing (docs, code samples, ...) that comes in tar anyway
13:02:50 <Jedai> That was destined to Orphi
13:02:55 <byorgey> I figured =)
13:03:15 <andun> dmhouse: you can do recursion. fac = fix (\f n -> if n == 0 then 1 else n * f (n-1))
13:03:27 <Jedai> Anyway all half decent archive tools handle tar (Winzip, Winrar, 7zip), you won't tell you don't have one of them ?
13:03:28 <quicksilver> Orphi: you want tar because it is the most popular format in which source code is distributed
13:03:37 <quicksilver> Orphi: so if you care about source code, you want tar
13:03:52 <dmhouse> andun: anything simpler? I was hoping for some examples involving fundamental functions. (I'm writing a fix tutorial.)
13:04:04 <vixey> a fix tutorial? :S
13:04:07 <olsner> hmm, am I just simply screwed by cabal installing a bytestring version newer than my ghc one?
13:04:17 <Orphi> quicksilver: I thought tar was pretty much obsolete by now...
13:04:18 <sw17ch> vixey: fix actually baffles me still
13:04:25 <dmhouse> Well, a fix/recursion chapter for the wikibook.
13:04:28 <dmhouse> He left in disgust :|
13:04:33 <Jedai> Orphi: Frankly don't seem all that important to me, we have much more important problems
13:04:35 <quicksilver> dmhouse: well what are nice simple recursive functions, in your opinion?
13:04:37 <sw17ch> oh no..
13:04:38 <mrd> Orphi: tar preserves directory structure and permissions.  it's not going obsolete anytime soon.
13:04:42 <trofimovich> olsner: mixing bytestrings is a bad idea. some (core) packages depend on old, some (lb, zlib, etc) depend on new. When use both - have a collision
13:04:44 <sw17ch> dmhouse, then i'll tell you that fix has me baffled still :)
13:04:50 <sjanssen> dmhouse: forever it = fix $ \again -> do it; again
13:04:58 <dmhouse> sw17ch: great! :) Stick around and you can be a guinea pig.
13:05:03 <sw17ch> woo!
13:05:06 <quicksilver> dmhouse: perhaps the definition of (*) in terms of (+) ?
13:05:06 <sw17ch> i'm going home in an hour...
13:05:09 <Jedai> Orphi: I didn't notice that, I see tars practically everywhere I go as soon as I want to do some dev..
13:05:15 * sw17ch is at work
13:05:16 * dmhouse doesn't really want to involve recursion just yet.
13:05:20 <olsner> hmm, so where is that cabal uninstall command?
13:05:23 <quicksilver> dmhouse: but fix *is* recursion?
13:05:25 <dmhouse> sw17ch: I might ?tell you.
13:05:25 <Orphi> Jedai: and would that be on Unix? ;)
13:05:31 <dmhouse> quicksilver: no, fix is finding fixpoints :)
13:05:37 <quicksilver> dmhouse: no, it's not.
13:05:38 <Jedai> Orphi: I mainly develop under Windows
13:05:48 <quicksilver> dmhouse: it won't for example, find the fixed point of a numerical function.
13:05:52 <quicksilver> dmhouse: fix is recursion.
13:05:53 <dmhouse> Sure it will.
13:05:56 <dmhouse> > fix cos
13:06:02 <sw17ch> dmhouse, that'll work fine
13:06:11 <lambdabot>  thread killed
13:06:13 <quicksilver> dmhouse: all examples of fix are examples of recursion.
13:06:25 <dmhouse> quicksilver: cos _|_ = _|_. fix finds a fixed point of cos just fine.
13:06:31 <Jedai> Orphi: You don't see tars in Microsoft tools and that's pretty much the only place you won't find one of them
13:07:07 <Orphi> Jedai: OK, so tar isn't going away. But if you're going to supply a tool that relies on it, on a platform where it isn't available, wouldn't it be nice to do something about that?
13:07:15 <Orphi> (anyway, it sounds like they have now...)
13:07:19 <mrd> it's very available on windows
13:07:30 <mrd> i even read ps.gz files
13:07:43 <mrd> winzip handles .gz and also the .tar
13:07:53 <Orphi> mrd: WinZip costs money.
13:08:07 <Plareplane> 7zip doesn't
13:08:08 <mrd> there is a free version.  though i think i am using winrar atm.
13:08:08 <Jedai> Orphi: As I said, every archive tool handle tar... lf you're a developper and you don't have one of those, I don't want to see your code
13:08:25 <Jedai> Orphi: Winrar has a free version, 7zip doesn't, ....
13:08:38 <sw17ch> Jedai, as crazy as it may be that they do'nt use tar... that's a little closed minded, don't you think?
13:08:41 <Orphi> Jedai: OK, so don't see my code. Since I can't get Cabal to package it anyway, that shouldn't be an issue. :-}
13:09:28 <Jedai> sw17ch: Wait a second, if you're a developper, you should have a minimum of tools to do your development...
13:09:40 <sjanssen> Jedai: the issue isn't having an archive tool, it's having one called "tar" that accepts the standard arguments in your PATH
13:09:45 <Jedai> Orphi: Cabal has other issues, tar isn't the problem
13:10:19 <sw17ch> yes, but "a method to archive files" should be used instead of "something to handle tar"
13:10:36 <sw17ch> some brilliant people do really weird things
13:10:48 <olsner> gaah, now I'm missing __stginit_mtlzm1zi1zi0zi1_ControlziMonadziCont_ instead
13:10:50 <MarcWeber> sjanssen: Does storablevectors support streaming as well ?
13:10:53 <sw17ch> the "your tool sucks" litmus test is a bad idea
13:10:53 <Jedai> Ok, on that I agree, mainly I think all Cabal should be in Haskell
13:11:09 <Orphi> Jedai: finally, we are in agreement. ;)
13:11:10 <ziman> @pl \x -> zip x (tail x)
13:11:11 <lambdabot> ap zip tail
13:11:17 <Beelsebob> sw17ch: not really -- using tar makes the process for installing things very consistant
13:11:24 <Jedai> You shouldn't have any dependancies on other tools
13:11:27 <mrd> sw17ch: most archive tools are vastly inferior to tar
13:11:39 <mrd> they lose information
13:11:40 <sjanssen> MarcWeber: Henning Thielemann has been hacking on that, though you'll probably need the darcs repo http://code.haskell.org/storablevector
13:11:41 <lambdabot> Title: Index of /storablevector
13:11:42 <Jedai> Orphi: Well ok, but don't blame tar, it really isn't the main problem
13:11:45 <vixey> :t join (zip <$> id <*> tail)
13:11:59 <Beelsebob> tar xvf package.tar.gz & cd package & ./Setup.hs configure & ./Setup.hs build & sudo ./Setup.hs install
13:12:00 <olsner> @where __stginit_mtlzm1zi1zi0zi1_ControlziMonadziCont_
13:12:00 <lambdabot> I know nothing about __stginit_mtlzm1zi1zi0zi1_controlzimonadzicont_.
13:12:01 <sw17ch> Beelsebob, mrd: both very true.
13:12:07 <pozic> Has anyone used a pretty printing library that works or do I have to conclude that they all suck?
13:12:26 <Orphi> Jedai: OK, the main problem is requiring tar and then not supplying it where it clearly won't be readily available. ;)
13:12:46 <Beelsebob> tar is rather beautiful, in that it is really nice and compositional
13:12:49 <mrd> does Cabal not require cygwin or mingw?
13:12:51 <Jedai> Beelsebob: the point is that you shouldn't need to use any external tools in this sequence, Cabal should do it all for you
13:13:00 <Orphi> mrd: I really hope not... !
13:13:05 <Beelsebob> Jedai: perhaps
13:13:17 <Beelsebob> but then, cabal install is not there yet
13:13:36 <mrd> how do you plan on using ghc without mingw at least?
13:13:39 <trofimovich> @hoogle Control.Monad.Cont
13:13:40 <lambdabot> No matches, try a more general search
13:13:44 <Jedai> Orphi: that's where we disagree, tar is available everywhere and very easy to find (if you already have GHC on your windows, you shouldn't be worrying about tar at all)
13:13:53 <trofimovich> @hoogle Control.Monad
13:13:54 <lambdabot> No matches, try a more general search
13:14:24 <byorgey> pozic: well, that depends on what your definitions of 'work' and 'suck' are.  which ones have you tried, and why do you think they suck?
13:14:28 <Orphi> Jedai: well I have GHC, and it comes with ld and gcc and even perl :-S but not tar. (or bash.)
13:14:36 <dublpaws> @hoogle Data.Graph
13:14:36 <lambdabot> No matches, try a more general search
13:15:01 <Orphi> OK, so here's a question: If I uninstall GHC, does that remove any nonstandard Cabal packages I've installed?
13:15:12 <mrd> windows has packages?
13:15:19 <mrd> you are a riot
13:15:25 <kryptiskt> why the discussion about tar, every windows compression program worth it's salt (7-zip etc) handles tar just fine.
13:15:26 <allbery_b> effectively, yes, since they're installed for a specific ghc version
13:15:35 <allbery_b> but they'll remain on disk
13:15:57 <Plareplane> yes but i don't think 7zip handles the same arguments in the same way as tar
13:16:02 <Orphi> kryptiskt: but only tar is named "tar".
13:16:09 <mrd> we're stuck in a tar pit
13:16:18 <Orphi> allbery_b: any idea how to remove them?
13:16:24 <Zao> Orphi: What about gtar?
13:16:38 <trofimovich> @google UnixUtils.zip
13:16:39 <lambdabot> No Result Found.
13:16:40 <pozic> byorgey: I tried wl-pprint most recently and I didn't like the default one from a previous use.
13:16:42 <Jedai> You can get a tar for windows very easily, that's really not the problem...
13:16:47 <trofimovich> @google UnixUtils zip
13:16:48 <lambdabot> http://unxutils.sourceforge.net/
13:16:48 <lambdabot> Title: Native Win32 ports of some GNU utilities
13:17:11 <Orphi> Jedai: Sure. I spent an entire afternoon and failed to do this. It's really easy.
13:17:15 <Jedai> As I said, any developper should be able to find that
13:17:23 <pozic> byorgey: wp-pprint cannot seem to put two columns next to eachother. One column would be ["name column with certain length", "332313", "3232"].
13:17:45 <Jedai> Orphi: google for "tar win32" bring you UnixUtils as its second link, you spent an afternoon on that ?
13:18:07 <Orphi> Jedai: I spent an afternoon trying to get rid of the "I can't find cygwin.dll" error message, yes.
13:18:07 <allbery_b> ghc doesn't provide tools for that.  well behaved packages install into their own directories
13:18:10 <byorgey> pozic: I've not heard of those libraries.  Have you tried Text.PrettyPrint.HughesPJ?
13:18:13 <pozic> byorgey: I vsep'ed the cells in every column and then used <+> to put them together.
13:18:38 <trofimovich> Orphi: http://unxutils.sourceforge.net/ should precompiled tar awk etc.
13:18:39 <lambdabot> Title: Native Win32 ports of some GNU utilities
13:18:42 <pozic> byorgey: yes, but as I said, I didn't like that one either, but cannot remember why.
13:18:48 <Jedai> Orphi: UnixUtils are native win32 applications, they don't need cygwin
13:19:02 <trofimovich> yep
13:19:08 <byorgey> pozic: well, I don't know, that one has worked well for me in the past
13:19:17 <Jedai> Orphi: And why didn't you install cygwin if you really didn't find any other way ?
13:19:26 <byorgey> pozic: the one thing you have to know is that you probably want to set ribbonsPerLine to 1
13:19:29 <Orphi> Jedia: Hey, I just put a search into a Google and tried the first few programs I found.
13:19:42 <allbery_b> you might try grabbing the output of ghc-pkg describe, specifically the import-dirs and library-dirs fields
13:19:44 <byorgey> the default value really only applies to pretty-printing source code
13:19:46 <Orphi> Jedai: Because I don't *want* a Unix emulator?
13:19:48 <allbery_b> (or ghc-pkg field )
13:20:30 <Jedai> Orphi: You do know that Cygwin won't pollute your Windows installation in any way ?
13:20:44 <trofimovich> Orphi: Unix API emulator? (one dll does it)
13:20:55 <Jedai> You need to launch the cygwin shell to have the change of PATH
13:21:25 <Jedai> On the other hand you could also have found a cygwin dll and put it somewhere on the PATH
13:21:47 <pozic> byorgey: It seems to put the second column next to the lowest cell of the first column (instead of the top cell).
13:21:56 <Orphi> Jedia: I just don't see why I should go to all the trouble of setting up a complete Unix emulation environment just because one program was insufficiently thoughtful.
13:22:13 <pozic> byorgey: I don't see why it would do such a thing.
13:22:16 <byorgey> pozic: oh, I'm pretty sure there's a way to get it to top-align columns
13:22:35 <olsner> no-one have a fix for the lambdabot mtl link problem?
13:22:35 <byorgey> not sure how off the top of my head
13:23:12 <byorgey> gwern: no, I didn't realize that; you (or someone else?) @remembered the whole thing, so... *shrug*
13:23:20 <byorgey> I was in a hurry so I didn't really look at the context
13:26:12 <gwern> byorgey: it was me who remembered it, but minus the comment
13:27:26 <Orphi> > fix ((1:) . scanl (+) 1)
13:27:27 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:27:39 * Orphi is very bewildered
13:27:47 <dmhouse> It's fun to figure out :)
13:27:48 <vixey> anyone got a description of the Krivine machine?
13:27:48 <pozic> byorgey: I tried every combinator, and nothing does top align, not seems to be a way to hack it.
13:27:52 <sw17ch> fix (id)
13:27:58 <sw17ch> > fix id
13:28:05 <dmhouse> sw17ch: diverges, because id is strict.
13:28:07 <Orphi> > fix my_life
13:28:07 <lambdabot>   Not in scope: `my_life'
13:28:13 <lambdabot>  thread killed
13:28:25 <sw17ch> > fix (:) []
13:28:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
13:28:26 <lambdabot>     Pro...
13:28:29 <EvilTerran> > fix everything
13:28:29 <lambdabot>      Cannot match a monotype with `GenericQ r'
13:28:30 <lambdabot>     Probable cause: `everythin...
13:28:30 <sw17ch> > fix (:)
13:28:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
13:28:31 <lambdabot>     Pro...
13:28:31 <EvilTerran> :(
13:28:40 <Cale> > map (fix (\fac n -> if n < 2 then n else fac (n-1) + fac (n-2))) [0..]
13:28:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:28:53 <sw17ch> :t fix (:)
13:28:56 <Orphi> @type fix
13:28:56 <lambdabot> forall a. (a -> a) -> a
13:29:04 <Cale> heh, should have said fib, not fac of course :)
13:29:07 <sw17ch> @type fix (:)
13:29:07 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:29:17 <sw17ch> @type fix (:) 1
13:29:18 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:29:20 <Orphi> > fix (+1)
13:29:32 <Cale> > fix (1:)
13:29:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:29:34 <byorgey> gwern: oh, I see, you were quoting them
13:29:34 <vixey> > fix (\result -> [1,2,result!!0 + result!!1,4,5])
13:29:35 <lambdabot>  [1,2,3,4,5]
13:29:35 <sw17ch> > fix (+0)
13:29:35 <lambdabot>  thread killed
13:29:44 <sw17ch> interleaved lambdabot output isn't so useful :)
13:29:45 <byorgey> gwern: I just have a script to go through the logs and look for @remember
13:29:50 <lambdabot>  thread killed
13:29:50 <Orphi> > fix cos
13:30:03 <vixey> > fix (\result -> [1,2*(result!!2 - result!!3),result!!0 + result!!1,4,5])
13:30:05 <luqui> vixey, that's a cool one
13:30:06 <byorgey> maybe I should have the script display a bit more context
13:30:06 <lambdabot>  thread killed
13:30:06 <Cale> Orphi: fix finds the least-defined fixed point of a function
13:30:11 <trofimovich> lb could cache outputs :]
13:30:18 <lambdabot>  thread killed
13:30:22 <Orphi> Cale: OK, now "cos" *does* have a fixed point... but it's not being found.
13:30:30 <Cale> Orphi: It is actually.
13:30:34 <luqui> its _|_
13:30:36 <vixey> > cos 0
13:30:37 <lambdabot>  1.0
13:30:37 <luqui> because cos _|_ = _|_
13:30:41 <gwern> byorgey: I was restoring @remembers from the #haskell logs
13:30:42 <vixey> > iterate cos 0
13:30:42 <Cale> Orphi: It has nontermination as a fixed point.
13:30:43 <lambdabot>  [0.0,1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035...
13:30:48 <tromp> > fix((0:).scanl(-)1)
13:30:49 <Cale> Orphi: So fix is finding that.
13:30:49 <lambdabot>  [0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1...
13:30:49 <vixey> > drop 100 $ iterate cos 0
13:30:50 <lambdabot>  [0.7390851332151607,0.7390851332151607,0.7390851332151607,0.7390851332151607...
13:31:01 <vixey> > acos 0.739085133215160
13:31:03 <lambdabot>  0.7390851332151616
13:31:11 <sw17ch> close
13:31:28 <Orphi> Cale: right. So since error is the fixed point of every function, "fix" is a fancy way to generate errors...
13:31:28 <Cale> Orphi: That "least-defined" is important :)
13:31:31 <Orphi> ...and this is useful?
13:31:33 <Cale> Orphi: nope
13:31:41 <Cale> Orphi: It's not a fixed point of (1:)
13:31:42 <luqui> Orphi, error is not the fixed point of every function
13:31:43 <Cale> for instance
13:31:47 <byorgey> bottom is *not* the fixed point of every function! =)
13:31:52 <byorgey> since haskell is lazy =)
13:31:56 <Cale> > head (1:undefined)
13:31:58 <lambdabot>  1
13:32:02 <ziman> > let fix' f x = ((++" iters").show.length *** fst . head) . break (uncurry (==)) . ap zip tail $ iterate f x in fix' cos 1
13:32:04 <lambdabot>  ("92 iters",0.7390851332151607)
13:32:17 <Cale> Clearly, 1:undefined is a different value from undefined, so undefined can't be a fixed point of (1:)
13:33:04 <trofimovich> @type (***)
13:33:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:33:08 <Cale> Also, for instance,  (\factorial n -> if n == 0 then 1 else n * factorial (n-1)), when applied to undefined, produces a function which is at least defined for 0
13:33:16 <Cale> > (\factorial n -> if n == 0 then 1 else n * factorial (n-1)) undefined 0
13:33:17 <lambdabot>  1
13:33:33 <Cale> So undefined is not a fixed point of it :)
13:33:39 <trofimovich> @src (***)
13:33:39 <lambdabot> f *** g = first f >>> second g
13:33:52 <Cale> The least defined fixed point of that function is itself the factorial function :)
13:33:59 <Orphi> I don't see how you can take some undefined data and produce something that *is* defined from it...
13:34:00 <ziman> > ((*5) *** (+1)) (10, 20)
13:34:01 <lambdabot>  (50,21)
13:34:13 <trofimovich> @google good arrows explanation
13:34:14 <lambdabot> http://members.aol.com/jwholtz/analemma/analemma.htm
13:34:15 <lambdabot> Title: Analemma and the Earliest Sunset
13:34:21 <luqui> haha
13:34:36 <trofimovich> @google good arrows explanation (haskell plz)
13:34:37 <lambdabot> No Result Found.
13:34:39 <vixey> ok I found this http://citeseer.ist.psu.edu/wand03correctness.html
13:34:40 <lambdabot> Title: On the Correctness and Efficiency of the Krivine Machine (ResearchIndex)
13:35:11 <Orphi> > fix (const 7)
13:35:13 <lambdabot>  7
13:35:30 <vixey> > fix (In . Just)
13:35:30 <lambdabot>   add an instance declaration for (Show (Mu Maybe))
13:35:31 <Orphi> OK... still not seeing how this is useful.
13:35:35 <vixey> :(
13:35:48 <vixey> > fix (In . (:[]))
13:35:49 <lambdabot>   add an instance declaration for (Show (Mu []))
13:35:57 <vixey> Can you even have show instances for those?
13:36:13 <byorgey> vixey: sure.  dunno why there aren't.
13:36:16 <vixey> @src Mu
13:36:16 <luqui> vixey, don't think so... not the way you'd expect rather...
13:36:16 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:36:19 * vixey tries deriving
13:36:36 <luqui> Orphi, it lets you encode recursion without recursion built in
13:36:42 <vixey>     No instance for (Show (f (Mu f)))
13:36:42 <vixey>       arising from the 'deriving' clause of a data type declaration
13:36:43 <luqui> > let x = 1:x in x
13:36:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:36:47 <vixey> haha
13:36:48 <luqui> > fix (\x -> 1:x)
13:36:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:36:54 <Orphi> but with no control over the starting point.
13:36:57 <vixey> it requires a show instance for Mu to build one
13:37:06 <luqui> Orphi, _value_ recursion
13:37:10 <luqui> (which can be function recursion also)
13:37:34 <luqui> > fix (\fact n -> if n == 0 then 1 else n * fact (n-1)) 10
13:37:35 <lambdabot>  3628800
13:37:46 <luqui> so it can't do anything recursive let can't do
13:38:03 <luqui> (but it can do everything recursive let can do :-)
13:38:14 <Orphi> > fix (+) 2 3
13:38:14 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
13:38:14 <lambdabot>     Probabl...
13:38:16 <hansfbaier> @src fix
13:38:17 <lambdabot> fix f = let x = f x in x
13:38:17 <trofimovich> @src fix
13:38:17 <lambdabot> fix f = let x = f x in x
13:38:30 <trofimovich> :]
13:38:41 <luqui> shhh! :-)
13:38:57 <luqui> fix :: (a -> a) -> a
13:38:58 <Orphi> The first rule of Haskell Club is "The first rule of Haskell Club is 'The first rule of Haskell Club is...
13:39:01 <ziman> > fix (\f x -> if x == 0 then [] else x:f (x-1)) 10
13:39:02 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
13:39:09 <vixey> @quote club
13:39:09 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
13:39:26 <Orphi> @quote sad
13:39:26 <lambdabot> erg0t says: <erg0t> y te re inserta su pija gorda, arrugada, engrasada y esponjosa
13:39:27 <luqui> > fix (\rule -> "The first rule of haskell club is '" ++ rule ++ "'")
13:39:28 <lambdabot>  "The first rule of haskell club is 'The first rule of haskell club is 'The f...
13:39:40 * Twey laughs.
13:40:14 <Orphi> Where the heck is dons? He usually comes up with some invocation of fix that causes World Peace or something about now...
13:40:19 <vixey> > fix (("This messages says: " ++) . show)
13:40:20 <lambdabot>  "This messages says: \"This messages says: \\\"This messages says: \\\\\\\"T...
13:40:40 <hansfbaier> > fix sin
13:40:55 <lambdabot>  thread killed
13:40:56 <luqui> sin is strict, so fix sin = _|_
13:41:11 <trofimovich> pure evil
13:41:12 <luqui> > let repent = fix sin in repent
13:41:19 <hansfbaier> luqui: aahh, it only works for lazy functions, yes...
13:41:26 <hansfbaier> :)
13:41:28 <lambdabot>  thread killed
13:42:06 <Orphi> > fix (fix const . cos)
13:42:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
13:42:07 <lambdabot>     Probabl...
13:42:09 <twanvl> You could write a Show instance for Mu with a bit of cheating, because of the functor laws
13:42:10 <tromp> > fix((0:).scanl(flip(-))1)
13:42:11 <lambdabot>  [0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-6...
13:42:22 <luqui> by def. of course, since the definition of a strict function is f _|_ = _|_, so _|_ is a fixed point, and its the least defined thing EVER!
13:42:45 <Orphi> so how do you compute the *most* defined fixed point?
13:42:51 <byorgey> hansfbaier: yes, in particular, any function which is strict in its argument has a fixpoint of _|_ (indeed, the definition of strictness is that f is strict if f _|_ = _|_)
13:42:53 <luqui> there isn't always one, orbitz
13:42:57 <luqui> er, Orphi
13:43:12 <luqui> (rather, there isn't always a unique one)
13:43:41 <Orphi> (^2) has at least two of 'em ;-)
13:43:57 <byorgey> Orphi: exactly.
13:43:57 <luqui> mostDefinedFixedPoint (\x -> sin x + x) = ?
13:43:58 <Orphi> > iterate (^2) 1
13:43:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:44:03 <tromp> > fix (^2)
13:44:05 <Orphi> > iterate (^2) (-1)
13:44:06 <lambdabot>  [-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:44:12 <Orphi> > iterate (^2) 0
13:44:14 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:44:19 <lambdabot>  thread killed
13:44:38 * Orphi thinks about strange attractors
13:44:45 <byorgey> Orphi: but the *least* defined fixpoint of (^2), of course, is _|_
13:45:07 <trofimovich> how to emulate mutable(without returning a copy) array in haskell?
13:45:13 <Orphi> byorgey: I'm still not seeing how that is *not* the least fixed point of everything.
13:45:28 <luqui> Orphi, (1:) _|_ /= _|_
13:45:39 <Orphi> :t (1:)
13:45:40 <lambdabot> forall t. (Num t) => [t] -> [t]
13:45:45 <luqui> > head undefined
13:45:45 <byorgey> Orphi: you didn't follow Cale's example above using the function (1:) ?
13:45:46 <lambdabot>  Exception: Prelude.undefined
13:45:52 <luqui> > head (1:undefined)
13:45:53 <lambdabot>  1
13:46:11 <Orphi> byorgey: I didn't understand it, no.
13:46:26 <byorgey> Orphi: well, consider applying (1:) to undefined
13:46:31 <luqui> > 1:[]
13:46:32 <lambdabot>  [1]
13:46:32 <byorgey> you get 1:undefined, right?
13:46:40 <Orphi> clearly
13:46:44 <byorgey> the question is, is 1:undefined the same as undefined?
13:46:44 <Beelsebob>  Orphi: _|_ is not a fixed point of const
13:46:50 <byorgey> because if it is, then undefined is a fixpoint of (1:)
13:46:55 <byorgey> right?
13:47:00 <Beelsebob> wait, what
13:47:03 <Beelsebob> what am I talking about
13:47:04 <Beelsebob> >.<
13:47:07 <Beelsebob> that's not what I meant
13:47:19 <Orphi> er... right.
13:47:20 <luqui> Beelsebob, _|_ is not a fixed point of const 42
13:47:22 <luqui> :-)
13:47:27 <Beelsebob> luqui: exactly
13:47:33 <Beelsebob> that's what I meant
13:47:36 <byorgey> Orphi: but in fact, because haskell is non-strict, 1:undefined is different than undefined
13:47:44 <Orphi> indeed.
13:47:46 <byorgey> Orphi: you can tell them apart by using, e.g., head
13:47:55 <byorgey> as luqui illustrated above.
13:48:13 <byorgey> so (1:) applied to undefined does *not* give undefined, so undefined is not a fixpoint of (1:).
13:48:34 <byorgey> another way to say this is that (1:) is not strict in its argument.
13:48:55 <byorgey> the least-defined fixpoint of (1:) is, in fact, the infinite list containing all 1's
13:49:11 <byorgey> since (1:) [1,1,1,...] = [1,1,1,...]
13:49:26 <byorgey> Orphi: does that help or are you still confused?
13:49:35 <Orphi> so is there any function who's fixed point is finite but has a definite value?
13:49:44 <byorgey> Orphi: sure.
13:49:53 <byorgey> e.g.  const 7
13:50:00 <Beelsebob> Orphi: well, 42 is the fixed point of const 42
13:50:01 <byorgey> which has a fixpoint of 7.
13:50:11 <byorgey> > fix (const 7)
13:50:12 <lambdabot>  7
13:50:18 <Orphi> so any function that ignores its argument has a fixed point?
13:50:33 <luqui> every function has a fixed point! :-)
13:50:44 <Orphi> I rephrase: an *interesting* fixed point :-P
13:50:50 <byorgey> Orphi: any function that ignores its argument has a non-_|_ fixed point.
13:51:11 <byorgey> but there are much more interesting functions with non-_|_ fixed points as well.
13:51:17 <luqui> in fact, any non-strict function, i.e. any f with f _|_ /= _|_, has a non-_|_ fixed point
13:51:45 <Orphi> but surely being nonstrict *implies* that the data isn't used?
13:51:50 <EvilTerran> for instance, ones that only sometimes ignore part of their argument
13:51:55 <luqui> (1:) is nonstrict...
13:52:02 <trofimovich> @google haskell fast mutable array
13:52:03 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
13:52:07 <luqui> and it uses its argument, it just doesn't use it *right away* (in some sense)
13:52:11 <EvilTerran> based on the other part of the argument
13:52:20 <Beelsebob> Orphi: no, being non-strict implies that the data isn't used *immediately*
13:52:30 <EvilTerran> or, indeed, functions which produce a constructor before needing their argument
13:52:33 <dmhouse> Orphi: read http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form and http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_and_strict_functions
13:52:34 <lambdabot> http://tinyurl.com/ykch9p
13:52:35 <EvilTerran> like luqui's example
13:53:08 <Orphi> now, see, Haskell has no concept of time. data is either used, or unused.
13:53:30 <sjanssen> @hoogle time
13:53:31 <lambdabot> System.Time :: module
13:53:31 <lambdabot> Data.Time :: module
13:53:31 <lambdabot> System.Timeout.timeout :: Int -> IO a -> IO (Maybe a)
13:53:33 <luqui> fix (\x -> 1:map (+1) x)
13:53:37 <byorgey> Orphi: for example, you could have a function which takes its argument, and without looking at the argument, returns another function which might or might not use it, depending on the value of *its* argument
13:53:37 <luqui> > fix (\x -> 1:map (+1) x)
13:53:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:53:55 <dmhouse> Orphi: specifically I think http://en.wikibooks.org/wiki/Haskell/Laziness#In_the_context_of_nonstrict_semantics will help
13:53:56 <Beelsebob> Orphi: if it's non-strict it can produce *some* of it's output without needing it's input
13:53:56 <lambdabot> http://tinyurl.com/ykch9p
13:54:00 <Beelsebob> but not necessarily *all* of it
13:54:05 <paczesiowa> is there an easy way to compare records with many fields on all but one field? (like compare `on` fst === compare `but` snd)
13:54:16 <Beelsebob> so (1:) for example can tell you that the list starts with 1, without looking at it's argument
13:54:24 <Beelsebob> but to tell you more, it must look
13:55:14 <byorgey> > fix (\fact n -> if n == 0 then 1 else n * fact (n-1)) 10    -- Orphi, here's another example
13:55:15 <lambdabot>  3628800
13:55:20 <Beelsebob> paczesiowa: try to write but, and you will answer your question
13:55:23 <byorgey> note how the function
13:55:35 <Orphi> > fix (\f -> \n -> if n < 2 then 1 else n * f (n-1))
13:55:36 <lambdabot>  <Integer -> Integer>
13:55:40 <byorgey> er, note how the function \fact n -> ...  doesn't use its argument 'fact' immediately
13:55:47 <byorgey> it depends on the value of n
13:55:53 <luqui> paczesiowa, hmmm...
13:55:59 <Orphi> > fix (\f -> \n -> if n < 2 then 1 else n * f (n-1)) 4
13:55:59 <lambdabot>  24
13:56:08 <dmhouse> sw17ch: still around?
13:56:15 <Orphi> so fix calls a function, passing the function a copy of itself...
13:56:16 <sw17ch> dmhouse, yes
13:56:28 <Beelsebob> @src fix
13:56:28 <lambdabot> fix f = let x = f x in x
13:56:29 <dmhouse> Orphi, sw17ch: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion first couple of chapters are up
13:56:47 <sw17ch> excellent, i'll take a look
13:57:03 <luqui> paczesiowa, I can only think of a way to do that if it works on frefs.
13:57:14 <Orphi> is fix actually *useful* for anything beyond confusing newbies?
13:57:16 <Shiruka> there's no Codec.Encryption.ROT13 :-(
13:57:17 <vixey> dmhouse: "if included in a language as a primitive, it allows you to define recursive functions" doesn't make any sense
13:57:20 <vixey> Orphi: yes
13:57:33 <luqui> Orphi, making an otherwise decidable language turing-complete?
13:57:36 <paczesiowa> luqui: what's a fref?
13:57:38 <Beelsebob> Orphi: yep -- it lets you implement recursion without let
13:57:45 <dmhouse> Orphi: it's useful for introducin recursion into the lambda calculus.
13:58:02 <Beelsebob> in fact, let is usually defined in terms of fix, not the other way round
13:58:04 <Orphi> OK, but given that I'm not actually using the lambda calculus (thankfully!)...
13:58:05 <dmhouse> vixey: perhaps I should be a bit more explicit about what language I'm thinking of.
13:58:08 <luqui> paczesiowa, http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
13:58:10 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
13:58:16 <dmhouse> Orphi: no, it has no real uses in Haskell.
13:58:16 <vixey> dmhouse: oh I assumed haskell
13:58:27 <dmhouse> vixey: I was thinking the typed lambda calculus :)
13:58:33 <Orphi> ok. glad I spent my brain on that. :-}
13:58:34 <vixey> dmhouse: by the way, I suggest that assuming show doesn't add commas actually doesn't simplify things at all
13:58:40 <vixey> dmhouse: You should include commas if you can
13:58:42 <sramsay> there's a cool paper about uses of fix
13:58:44 <sramsay> http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-375/
13:58:45 <Orphi> anybody wanna define the prime numbers using fix?
13:58:45 <lambdabot> Title: That About Wraps it Up
13:58:53 <dmhouse> vixey, Well otherwise I'd have to include intersperse and other complications
13:59:28 <luqui> compareBut :: Eq a => Accessor a c -> Bool
13:59:42 <luqui> compareBut :: Eq a => Accessor a c -> a -> a -> Bool -- er, yeah
14:00:13 <luqui> compareBut f a b = put f (get f a) b == b
14:00:33 <byorgey> Orphi: hm, that actually sounds pretty difficult
14:00:46 <byorgey> the prime numbers don't have any nice recursive definition that I know of
14:01:02 <crashmatrix> I've just started learning Haskell about two hours ago, and I'm working through the "Yet Another Haskell Tutorial" tutorial. One thing I don't get right now is the use for the 'id' function, can someone explain that to me?
14:01:13 <byorgey> crashmatrix: welcome! =)
14:01:17 <Beelsebob> byorgey: what about a simple sive?
14:01:19 <byorgey> crashmatrix: id is just the identity function
14:01:29 <byorgey> crashmatrix: it returns whatever argument you give it
14:01:30 <dmhouse> crashmatrix: mostly useful for situations when you pass it to other functions.
14:01:31 <byorgey> > id 6
14:01:32 <lambdabot>  6
14:01:35 <vixey> > map id [1,2,3]
14:01:36 <lambdabot>  [1,2,3]
14:01:41 <Twey> crashmatrix: Sometimes you want to do something that takes a function but you don't want it to actually do anything with that function.
14:01:45 <vixey> :t id
14:01:46 <lambdabot> forall a. a -> a
14:01:47 <byorgey> crashmatrix: it seems useless but actually comes in handy in a lot of places =)
14:01:52 <crashmatrix> I see
14:02:12 <crashmatrix> Okay, thanks, and also thanks for the welcome
14:02:22 <dmhouse> crashmatrix: for example, (id *** show) applied to a pair will leave the first element alone, and convert the second to a string.
14:02:23 <vixey> crashmatrix: The most often I see id is when I abstract out a recursion pattern and then use it
14:02:23 <Beelsebob> crashmatrix: it's a lot like the "const" function -- it returns a *function* that always returns the argument you give to const
14:02:33 <nominolo> @seen dons
14:02:33 <Beelsebob> > const 42 9
14:02:33 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I don't know when dons last spoke.
14:02:33 <dmhouse> crashmatrix: you'll come across more examples as you go through YAHT.
14:02:34 <lambdabot>  42
14:02:36 <vixey> crashmatrix: sometimes I put id into the gaps
14:02:37 <Beelsebob> > const 42 26
14:02:38 <lambdabot>  42
14:02:45 <byorgey> oh, hehe, you asked about uses *for* id, I thought you said use *of* the id function, my bad ;)
14:02:48 <luqui> > fix (\primes -> 2:3:filter (\n -> all (\k -> n `mod` k /= 0) (takeWhile (< floor (sqrt n)) primes)) [5,7..])
14:02:49 <lambdabot>  Add a type signature
14:02:58 <luqui> > fix (\primes -> 2:3:filter (\n -> all (\k -> n `mod` k /= 0) (takeWhile (< floor (sqrt (fromIntegral n))) primes)) [5,7..])
14:02:59 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,23,25,29,31,35,37,41,43,47,49,53,59,61,67,71,73,79...
14:03:04 <trofimovich> @src id
14:03:04 <lambdabot> id x = x
14:03:12 <luqui> tada!
14:03:16 <vixey> heh
14:03:20 <quicksilver> dmhouse: yes, but it doesn't find the numerical fixed points of cos.
14:03:26 <crashmatrix> oh... I knew something was off
14:03:28 <quicksilver> dmhouse: it doesn't find sin 0 = 0, for example.
14:03:30 <hatseflats> that's better :)
14:03:38 <dmhouse> quicksilver: because _|_ is less defined than 0
14:03:43 <dmhouse> quicksilver: and _|_ is also a fixed point of isn
14:03:44 <dmhouse> *sin
14:03:44 <quicksilver> dmhouse: fix finds fixed points which can be calculated by recursion.
14:03:49 <byorgey> luqui: ah, nice =)
14:03:53 <luqui> whoops, what's 25 doing in there!?
14:03:57 <luqui> > fix (\primes -> 2:3:filter (\n -> all (\k -> n `mod` k /= 0) (takeWhile (<= floor (sqrt (fromIntegral n))) primes)) [5,7..])
14:03:58 <quicksilver> so all examples of fix are examples of recursion.
14:03:59 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:04:02 <luqui> that's better
14:04:20 <dmhouse> quicksilver: true, but I'd say that's more of an incidental fact.
14:04:28 <quicksilver> incidental?
14:04:32 <quicksilver> I'd describe it as fundamental :P
14:04:36 <paczesiowa> luqui: looks nice, but I still have to write getters and setters for every field (feels like java?), or at least for the one field I want to "but" on
14:04:38 <quicksilver> that *is* what fix is.
14:04:40 <dmhouse> I think it's more natural to introduct fix by saying it finds fixed points, then move on to how it encodes recursion.
14:04:55 <dmhouse> Well, of course, that's why it's useful. If it were just about finding fixed points, no-one would care.
14:04:55 <luqui> paczesiowa, yeah kind of annoying.  the data-accessor package can do that for you
14:04:57 <quicksilver> only if you have an audience already happy with CPOs
14:05:02 <luqui> paczesiowa, using template haskell
14:05:05 <dmhouse> CPO?
14:05:10 <quicksilver> complete partial order
14:05:20 <quicksilver> the structure over which fix is finding its fixed points
14:05:21 <dmhouse> Partial orders aren't hard to grok.
14:05:26 <quicksilver> perhaps not
14:05:29 <quicksilver> neither is recursion.
14:05:42 <dmhouse> True.
14:05:44 <quicksilver> if you are from a programming background, the recursion explanation is easier.
14:05:48 <paczesiowa> luqui: can I do it if I don't define datatype myself? ( I imported RssItem)
14:05:56 <quicksilver> if you are from a discrete mathematics background than the CPO one is.
14:06:05 <dmhouse> I don't think so. I struggled with how recursion and fix fitted together for quite a while.
14:06:21 <dmhouse> I don't really know why, it's actually quite simple now.
14:06:25 <luqui> paczesiowa, I think so, as long as you can see the normal accessors
14:06:42 <luqui> i.e. if it looks like data Foo = Foo { field1 :: Type1, field2 :: Type2 }
14:06:44 <paczesiowa> @hackage data-accessor
14:06:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
14:06:53 <luqui> and they're exported
14:06:58 <dmhouse> I think part of the puzzle is realising that Haskell equations can be read as actual equations, and not just operational definitions.
14:06:58 <luqui> but I'm not sure, haven't tested that
14:07:06 <dmhouse> But anyway, back to writing.
14:07:09 <ziman> @quote autodidactism
14:07:09 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
14:07:53 * Twey groooooans.
14:08:25 <Shiruka> > let f = map $ (\c -> if (c >= ord 'a' && c <= ord 'z') then ['a'..'z'] !! ((c+13-ord 'a') `mod` 26) else chr c) . ord . toLower in f "Twey groooooans."
14:08:26 <lambdabot>  "gjrl tebbbbbnaf."
14:08:48 <paczesiowa> doesn't using macros mean that language failed on some level because something isn't first class?
14:09:10 <Twey> paczesiowa: Not necessarily
14:09:11 <jeffwheeler> Shiruka: rot 13?
14:09:11 * Shiruka didn't find rot13 in the std libs or on hackage :-(
14:09:24 <Twey> Macros can use first-classness.  E.G. Lisps.
14:09:44 <Shiruka> I even looked at the most obvious place, Codec.Encryption.ROT13!
14:10:40 * Shiruka should submit that to the Crypto package for inclusion, maybe named as SuperStrongNewEncryption ;-)
14:10:57 <luqui> one of those four words is accurate...
14:11:06 <Shiruka> oops, sorry
14:11:20 <Shiruka> which one?-)
14:11:27 <jeffwheeler> I've had good luck with rot50: for when most of your text is punctuation.
14:11:30 * luqui was thinking "encryption"
14:11:39 <paczesiowa> but wouldn't it be nice if we wouldn't have to use TH (or ghc) for autoderiving and record stuff and leave for things like syntax (do-notation)?
14:11:48 * luqui agrees
14:11:53 <eu-prleu-peupeu> heya
14:12:05 <luqui> quasiquoting in 6.10 is going to be cool though
14:12:48 <eu-prleu-peupeu> i just opened a window with hopengl (glut), and displayed it some points (the code i got from the tutorial), and the final executable ghc generated was 5.35MB !!!!
14:12:49 <jeffwheeler> Going from 6.9 to 6.10 seems like cheating --- 6.9 should go to 7.0
14:12:51 <eu-prleu-peupeu> anyone knows why ?!
14:13:01 <eu-prleu-peupeu> in C would be 10KB :(
14:13:07 <Zao> eu-prleu-peupeu: Strip it?
14:13:08 <paczesiowa> eu-prleu-peupeu: strip it
14:13:11 <Zao> Optimize it?
14:13:12 <luqui> eu-prleu-peupeu, probably statically linked?
14:13:15 <Zao> Cry?
14:13:22 <trofimovich> ghc doesn't support dynamic libs yet
14:13:23 <hexpuem> enable split objs, and strip it
14:13:35 <eu-prleu-peupeu> ok
14:13:45 <eu-prleu-peupeu> is there any way for me to know what ghc is doing there ?!
14:13:51 <paczesiowa> eu-prleu-peupeu: and that's really nothing, I had apps > 35mb
14:14:02 <hexpuem> all libraries youre using have to be compiled with split obj too
14:14:15 <eu-prleu-peupeu> hmm ok
14:14:21 <eu-prleu-peupeu> how do i do split obj compilation ?
14:14:23 <qwr> eu-prleu-peupeu: linking all the libs with debug info into one binary?
14:14:25 <hexpuem> and for whatever reason its not enabled by default
14:14:45 <hexpuem> its a GHC build option somewhere
14:15:05 <vixey> @free fix
14:15:06 <lambdabot> f . g = h . f => f (fix g) = fix h
14:15:17 <eu-prleu-peupeu> thanks
14:15:27 <hexpuem> (you have to build ghc from src or find someone who has it configured for it)
14:16:00 <vixey> jeffwheeler: yeah it's not a proper '.'
14:16:02 <hexpuem> can get like 300-500kb executables with split obj and strip for small stuff
14:16:22 <hexpuem> which is about the same as D / OCaml runtime bloat
14:16:23 <jeffwheeler> vixey: heh, GHC's not the first; oh well
14:16:52 <eu-prleu-peupeu> well with OCaml i was not able to run upx on the binary and run it
14:16:54 <eu-prleu-peupeu> with haskell i can
14:17:12 <eu-prleu-peupeu> even so, with upx turns out a magnificent 3.1MB
14:17:19 <qwr> eu-prleu-peupeu: but are you going to distribute it? on local system i wouldn't care about that bloat...
14:17:45 <eu-prleu-peupeu> well, its just to see if i can work out some demos with haskell :/
14:17:49 <eu-prleu-peupeu> not big deal
14:17:53 <hexpuem> is there actually any reason why SplitObjs isnt enabled on all the precompiled packages of ghc
14:18:06 <hexpuem> win32 and unbuntu packages dont have it last i checked
14:18:16 <hexpuem> prob not debian either
14:18:31 <dmhouse> Quick: examples of "classic" recursive functions, other than fix and map?
14:18:33 <trofimovich> it forces users to help implement shared libs?
14:18:36 <dmhouse> Err, fact and mpa
14:18:46 <dmhouse> Gah. fact and map. Where fact is the factorial function.
14:19:09 <paczesiowa> trofimovich: what's the difference between shared libs and slitobjs?
14:19:23 <hexpuem> with shared libs you get more bloat haha
14:19:30 <hexpuem> but wins if you have multiple haskell exes installed
14:19:31 <trofimovich> never heard of splitobjs :]
14:19:40 <jeffwheeler> dmhouse: fib?
14:20:07 <dmhouse> jeffwheeler: yeah, I think I'll include that.
14:20:31 <Cale> Does anyone remember the name of the paper which introduced a means of splitting up the IO monad that involved types which had an extra parameter that expressed a sum of the effects allowed?
14:20:48 <luqui> dmhouse, filter?
14:20:56 <Jedai> Cale: IOSpec ?
14:20:57 <Cale> Something like IO (Terminal :+: File)
14:21:07 <Jedai> @go IOSpec
14:21:08 <lambdabot> http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
14:21:09 <lambdabot> Title: IOSpec
14:21:09 <trofimovich> but i suspect resulting binary won't provide dlopen()able C ABI functions
14:21:41 <Jedai> Data Type a la carte ?
14:22:03 <Cale> Jedai: yes, that's it. Just found it linked from the bottom there. :)
14:26:04 <Toxaris> dmhouse: (what do you mean by classic? just "everyone knows them"?, then:) sum, foldr, length, depth (on trees), dfs (depth first search), even, odd (toy examples for mutual recursion),
14:26:59 <dmhouse> Toxaris: standard examples of recursive functions. I think I have enough now.
14:28:08 <ahunter> Can someone take a look at http://hpaste.org/9435 and help me figure out how to get ^+^ et al to work with immediate numeric constants?  As is, > let x = Var 1; y = 2.0 :: Double in x ^+^ y works but x + ^+^ 2.0 doesn't.
14:29:23 <Cale> Jedai: have you looked at the recent paper posted to reddit about lambda arrow circle?
14:29:55 <Jedai> Cale: No, I didn't see that, I'll look into it
14:30:30 <Cale> Jedai: The link was unfortunately given the inflammatory title "Why monads are a poor foundation for dealing with side effects"
14:30:52 <Cale> Which I think is pretty unfortunate, given that the "circle" modality the paper uses is a monad...
14:31:16 <ahunter> Thus, the trolls took at as "HAH! You haskell people are idiots, bet you feel stupid now for liking a a language that isn't popular!"
14:31:46 <Cale> (and I'm pretty sure the arrow is the Kleisli arrow for the same monad)
14:31:58 <Elly> is that seriously the best they can come up with?
14:32:01 <Cale> The more interesting part is the way they split up effects though.
14:32:06 <Elly> "bet you feel stupid for liking a language that isn't popular"?
14:32:49 <Shiruka> you know, liking the unpopular languages in high school gets you shunned by the popular languages
14:32:50 <jeffwheeler> Why does anybody still use reddit/digg?
14:33:02 <BMeph> Ah - I just got through reading Beauty in the Beast a few days ago, and was going to answer you with that one.:)
14:33:03 <Cale> ahunter: x + ^+^ 2.0 looks like a syntax error to me...
14:33:12 <jeffwheeler> I gladly stopped reading them ages ago, and am back to RSS feeds of my choosing.
14:33:14 <ahunter> Cale: erm, I meant x ^+^ 2.0
14:33:42 <Cale> ahunter: ah, I see...
14:33:44 <Shiruka> reddit is still fun
14:33:50 <Shiruka> sometimes (rarely) even informative
14:33:54 <Toxaris> ahunter: 2.0 has type (Fractional t => t), so the instance with Double will not match
14:34:00 <Cale> right
14:34:02 <ahunter> Toxaris: precisely
14:34:07 <ahunter> is there a way I can get around that?
14:34:22 <Cale> I wonder if extended defaulting rules would help...
14:34:46 <ahunter> Because I'm bothering with this rather-complex DSL just so I can disallow x ^*^ y (where x and y are variables)...if I can't even use constants, I may just say screw it, make that a runtime error, and add num instances
14:34:57 <Cale> You could try  {-# LANGUAGE ExtendedDefaultRules #-}
14:34:59 <BMeph> jeffwheeler: I think dons uses reddit, just for the shock value... ;)
14:35:17 <Cale> ahunter: Otherwise, you might just include an explicit type sig.
14:35:18 <jeffwheeler> BMeph: I know he does; people link to his comments all the time here :P
14:35:26 <Cale> That is, x ^+^ (2.0 :: Double)
14:35:49 <ahunter> Cale: yeah, but at that point, I've lost almost all of the nice syntax I'm trying to be able to use
14:36:10 <BMeph> jeffwheeler: Well, usually, he drive-bys his own comments; but since he gave us ByteStrings and LB, we let it slide. :)
14:36:34 <Cale> btw, you're not using fundeps...
14:36:38 <jeffwheeler> BMeph: fair by me :)
14:36:45 <ahunter> I mean, what I really want is to be able to say something approximating: maximize :: ProgExpr -> [Constraint] -> Solution, and say maximize (x + y) [2x + y < 20, y > 0]
14:36:45 <Heffalump> ahunter: in practice, in bigger programs, other uses will constrain the types
14:36:46 <Cale> and in fact, if you were, it might solve your problem.
14:37:01 <Heffalump> it's typically the small fragments where the types aren't constrained suitably
14:37:02 <Cale> However, it would make things a bit more restrictive (you might have to chain yourself to Double)
14:37:11 <Cale> (for the given expression type)
14:37:16 <ahunter> Cale: rwbarton suggested fundeps, which I was in the fgirst draft, haven't updated the comments... I made the classes a b c | a b -> c (at his suggestion) which didn't help
14:37:20 <Heffalump> oh, but you're throwing away the types, so that won't work
14:37:21 <Cale> Have you considered *not* using typeclasses?
14:37:26 <ahunter> Cale: I'm fine chaining myself to Double
14:37:32 <Cale> Is there a reason it has to be so general?
14:37:37 <vixey> > let (+) = (,) in (x + y)
14:37:39 <lambdabot>  (x,y)
14:37:49 <ahunter> Cale: how can I have x ^+^ 2.0 and x ^+^ y and 2.0 ^+^ x all correct w/o classes?
14:37:57 <vixey> > let (<) = (,,) "less" in (2*x < y)
14:37:58 <lambdabot>        add an instance declaration for (Num ([Char], Expr, Expr))
14:38:01 <Heffalump> why not just have instance Num ProgExpr ?
14:38:06 <vixey> :[
14:38:07 <Cale> ahunter: ah, okay, you have a point there...
14:38:15 <vixey> > let (<) = (,,) "less" in ((2*x) < y)
14:38:16 <lambdabot>  ("less",2 * x,y)
14:38:17 <ahunter> Heffalump: x * y is bad
14:38:20 <newsham> > let (:->) = (+) in 0:-> 3
14:38:21 <lambdabot>   Not in scope: data constructor `:->'
14:38:31 <newsham> > let (*:->) = (+) in 0*:-> 3
14:38:32 <lambdabot>  3
14:38:53 <vixey> ahunter: How would you solve these?
14:39:07 <BMeph> Cale: Heh-heh, that reminded me of the NNTN bit: "Have you tried removing the anvil from off of your head?" "I can't believe it, the pressure is gone!" :)
14:39:30 <newsham> "doc, it hurts when I do this."  "stop doing that!"
14:39:32 <ahunter>  vixey: I'm writing an interface to GLPK at the moment; once that works, I may try writing my own simplex/interior point solvers for fun
14:39:41 <Cale> ahunter: Try adding the constraint  | a -> b, b -> a
14:39:53 <ahunter> Cale: Think that'll produce overlap, but I'll try it
14:39:59 <Cale> ahunter: er, except that will cause some problems with your instances...
14:40:00 <Cale> yeah
14:40:22 <Cale> It's that you want *both* which causes problems.
14:40:40 <vixey> ahunter: You could use something like  maximize (Sum (Var "x") (Var "y")) [Less (Sum (Product (Num 2) (Var "x")) (Var "y")) (Num 20), ...]
14:41:14 <vixey> ahunter: maximize (x + y) [2x + y < 20, y > 0] where x = Var "x" ; y = Var "y" ; (+) = Sum ; (*) = Product ... lets you use the shorthand
14:41:17 <ahunter> vixey: yeah, but that's ugly as sin...I'm writing all these operators to try to sugar away that so you can just write nice pretty linear expressions
14:41:23 <ahunter> vixey: hmmm
14:41:23 <vixey> ahunter: No it's not ugly
14:41:47 <Toxaris> vixey: how does that avoid (Product (Var "x") (Var "y"))?
14:42:01 <vixey> Toxaris: it doesn't, I am suggesting to use that
14:42:03 <ahunter> vixey; I don't see how to enforce linearity there
14:42:11 <vixey> ahunter: What is that?
14:42:30 <ahunter> vixey: ah... http://en.wikipedia.org/wiki/Linear_programming
14:42:30 <lambdabot> Title: Linear programming - Wikipedia, the free encyclopedia
14:42:32 <Toxaris> vixey: but it is ahunter's point to avoid that, as I understand
14:43:02 <vixey> ahunter: Don't bother trying to enforce that syntactically
14:43:32 <ahunter> vixey: whyever not?  Isn't that the point of using typed languages, to make incorrect statements static type errors?
14:43:56 <ahunter> vixey: I mean, if I can't, I can't, and I'll write a Num instances and forget about it, but it would be really sweet
14:43:57 <vixey> I don't think so, is it?
14:44:15 <b_jonas> hi
14:44:19 <vixey> hi
14:44:47 <ahunter> Cale: now that I think about it, I can do the a -> b, b -> a for ProgrammingMultiply...it's Add that's the problem
14:44:47 <vixey> ahunter: Then why don't you use [(Constant,Variable)] ?
14:44:59 <ahunter> vixey: which is more readable?
14:45:01 <b_jonas> so, I'll ask some questions again.
14:45:07 <vixey> ahunter: out of what things?
14:45:27 <ahunter> [(3,"x"),(2,"y"
14:45:28 <ahunter> )]
14:45:35 <ahunter> 3x+2y
14:45:59 <vixey> um...
14:46:26 <vixey> > let x * y = [(x,y)] ; (+) = (++) in  3*x + 2*y
14:46:27 <lambdabot>   add an instance declaration for (Num [(t, Expr)])
14:46:33 <vixey> > let x * y = [(x,y)] ; (+) = (++) in  (3*x) + (2*y)
14:46:34 <lambdabot>  [(3,x),(2,y)]
14:46:44 <vixey> you should use better fixity levels
14:46:50 <vixey> anyway that's the point I was trying to make earlier
14:46:58 <b_jonas> let's say returnseq :: a -> IO a; returnseq x = x seq return x;
14:47:19 <b_jonas> supposing I want to write an interpreter that simulates a strict language
14:47:25 <vixey> ahunter: plan b)  parse "3x + 2y"
14:47:26 <Toxaris> ahunter: why do you disallow (3 ^+^ 5)?
14:47:46 <ahunter> Toxaris: I don't suppose I have to, I figured it was unnecessary since 3 + 5 works...
14:47:54 <b_jonas> so I want every long computation the strict semantics of the interpreter would evaluate computed before the next io action is performed
14:48:07 <ahunter> Toxaris: would it work if I added OverlappingInstances, a -> b, b -> a?
14:48:08 <EvilTerran> b_jonas, you don't have to use seq to interpret a strict language
14:48:29 <b_jonas> EvilTerran: I don't?
14:48:37 <vixey> b_jonas: You shouldn't use seq
14:48:55 <vixey> b_jonas: Just have the right monad transformer stack
14:49:06 <EvilTerran> quite. monads within monads!
14:49:09 <ahunter> vixey: I suppose I could use Template Haskell, but I don't *know* template haskell
14:49:17 <b_jonas> my problem is that I think if I don't use seq
14:49:32 <vixey> ahunter: that doesn't matter, it's easy to use, but I wasn't suggesting that and I don't think it's a good idea
14:49:40 <EvilTerran> b_jonas, you make things like reading from mutable variables be actions in your transformed IO monad
14:49:50 <vixey> ahunter: Did you see this example:  let x * y = [(x,y)] ; (+) = (++) in  3*x + 2*y  ?
14:49:51 <ahunter> vixey: I'm still confused what you think is a good idea?
14:49:53 <ahunter> ah
14:50:01 <ahunter> vixey: I saw it.  My problem is:
14:50:24 <ahunter> > let x * y = [(x,y)] ; (+) = (++) in  3*x*y+ 2*y
14:50:24 <lambdabot>        add an instance declaration for (Num [([(t, Expr)], Expr)])
14:50:39 <b_jonas> then I think it could happen that the interpreter does an io action like putStrLn "long computation done, press enter to output results", then waits for the user to press enter, and does the computation only after that
14:50:49 <b_jonas> EvilTerran: reading from variables is ok
14:50:50 <ahunter> wait, why doesn't that work?
14:50:55 <b_jonas> EvilTerran: but waiting for user input isn't I think
14:51:01 <vixey> ahunter: Anyway I was just trying to say, that you should focus on the right data structure and syntax later, I don't actually know what invariants you are trying to deal with
14:51:17 <EvilTerran> b_jonas, ah, i see...
14:51:29 <Toxaris> the right data structure seems to be data Term = Term Double [(Double, String)]
14:51:34 <EvilTerran> you don't just want to simulate semantics, you want to simulate evaluation order accurately as well
14:51:35 <vixey> b_jonas: I don't see that being a problem
14:51:40 <ahunter> vixey: the invariants are easy.  I'm trying to write linear combinations of variables.  Thus, if I have a Var, I don't want to multiply it.
14:51:46 <vixey> b_jonas: is it?
14:51:54 <b_jonas> vixey: I think it is, but maybe I'm wrong
14:52:26 <vixey> b_jonas: If you write an interpreter by giving strict semantics, that what you'll get
14:52:36 <sw17ch> what's a good "breakEvery" that doesn't involve both take and drop?
14:52:43 <ahunter> Toxaris: yeah, though I was thinking data Term = Term Double (Map Int Double), so that if you have a lot of variables (common) you don't need a huge list of 0.0s
14:52:43 <vixey> b_jonas: haskell is still evaluating it lazy but it wont change the semantics you've written down
14:52:58 <sw17ch> breakEvery :: Int -> [a] -> [[a]]
14:53:13 <vixey> ahunter: you could probably do opitimization once you have things working
14:53:16 <Toxaris> ahunter: I meant [(Double, String)] to be an association list, used as a Map
14:53:18 <EvilTerran> vixey, it will have different performance characteristics, though
14:53:35 <Toxaris> ahunter: so I probably should have written [(String, Double)]
14:53:44 <b_jonas> vixey: the semantics is not changed if you don't count time (and space) in the semantics, but supposing the user is
14:53:49 <ahunter> Toxaris: I suppose so, but why use an association list, well, ever?
14:53:52 <b_jonas> using the interpreter interactively,
14:54:04 <b_jonas> types a command that does some very long computation
14:54:06 <vixey> b_jonas: No I don't think so
14:54:10 <sal23> is a random number generator (e.g. rand 0 n" which generates
14:54:13 <vixey> chunk n list = case list of { [] -> [] ; (y:ys) -> ch' ys (n-1) (y:) } where
14:54:13 <vixey>  ch' [] _ k = k [] : []
14:54:13 <vixey>  ch' (y:ys) 0 k = k [] : ch' ys (n-1) (y:)
14:54:14 <vixey>  ch' (y:ys) (c+1) k = ch' ys c (k . (y:))
14:54:18 <vixey> sw17ch, ^
14:54:21 <sal23> oops, typo
14:54:24 <ahunter> Toxaris: I'd do it in Scheme, but when a treemap is as easy as Map Int Double, not sure I see the point
14:54:39 <b_jonas> he goes for a coffee break because he thinks the computation will take half an hour
14:54:59 <ahunter> Toxaris: for that matter, in practice, I might as well actually write the FFI bit,s then start worrying about a cool DSL, but I'm really curious if I can make the DSL work
14:55:03 <b_jonas> but actually the interpreter suspends most of the computation lazily and returns a prompt after two minutes
14:55:05 <sal23> is a random number generator (e.g., rand 0 n , which generates a random number between 0 and n) a function in haskell?
14:55:09 <vixey> b_jonas: It doesn't work like that, you can predict the execution of a program
14:55:23 <b_jonas> and then when the user returns and types a command to output the solution
14:55:28 <b_jonas> he has to wait half an hour
14:55:37 <jeffwheeler> sal23: functions will always return the same output with the same input; Random is a monad, IIRC
14:55:37 <b_jonas> vixey: what doesn't work like that?
14:55:40 <vixey> b_jonas: Are you guessing this or basing it on actual experience?
14:55:50 <b_jonas> vixey: I'm guessing this only
14:56:00 <vixey> b_jonas: based on what?
14:56:01 <sal23> jeffwheeler: that is exactly what I thought...what kind of monad would it be?
14:56:19 <b_jonas> vixey: well, you do long computations on arrays
14:56:23 <b_jonas> which don't have side effects
14:56:30 <b_jonas> so I assume if you don't do anything
14:56:43 <jeffwheeler> sal23: what do you mean? I haven't used it much, but as far as I know it works based on a seed, and generates new random numbers from the seed.
14:56:43 <b_jonas> then not much will actually get computed early
14:56:46 <EvilTerran> if you structure your monad so each application of a step law or whatever is a monadic action, it'd work like you wanted
14:57:01 <b_jonas> as an example
14:57:04 <vixey> b_jonas: It doesn't work in that way
14:57:30 <b_jonas> suppose the whole command interpreted is an assignment to a variable of a long computation without io effects
14:57:54 <sal23> jeffwheeler: I was asking what type of monad may be used to implement it....looks like IO monad for the example here: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
14:57:54 <vixey> I don't think I'm able to get through the barrier you've built up
14:57:55 <lambdabot> http://tinyurl.com/2fpup7
14:57:57 <b_jonas> then clearly if you interpret that lazily it won't compute anything before you actually print the contents of that variable or something
14:58:34 <Toxaris> sal23: you need to keep the current state of the random number generator, so you want a state monad, or the IO monad with IORefs, or the ST monad with STRefs
14:58:58 <b_jonas> vixey: do you think I should look at code of actual interpreters of strict languages in haskell?
14:59:01 <b_jonas> would that help?
14:59:18 <b_jonas> or something else?
14:59:18 <Toxaris> sal23: alternatively, for some applications, you can generate a lazy infinite list of random numbers and use that (e.g., map over it)
14:59:26 <ddarius> b_jonas: Read "Definitional Interpreters for Higher Order Languages"
14:59:33 <sal23> Toxaris: well, actually yes, if we need to keep the state, then state monad...don't know about other monads....I was just curious about how they were implemented
14:59:41 <b_jonas> EvilTerran: doesn't it depend on what monad?
15:00:04 <Toxaris> sal23: well, you need to keep the state, that's how PRNG (pseudo random number generators) work
15:00:17 <b_jonas> EvilTerran: I mean, how can just being a monad make do anything magical?
15:00:40 <Toxaris> sal23: they are basically of type (GeneratorState -> (RandomNumber, GeneratorState))
15:00:56 <sal23> Toxaris:  What if we used an online source such as random.org....that should be IO monad then, right?
15:01:13 <sal23> Toxaris: in that case, state is not really involved unlike PRNG
15:01:20 <Toxaris> sal23: yep, tcp/ip networking tend to be in IO
15:02:02 <jeffwheeler> sal23: There's already a library that does that in Hackage called RandomDotOrg
15:02:18 <roconnor> @let random = 4
15:02:20 <lambdabot> Defined.
15:02:41 <roconnor> -- selected by a fair die roll
15:02:55 <roconnor> -- guarenteed to be random
15:02:57 <b_jonas> here's an example of what I mean
15:03:00 <sw17ch> vixey: thanks
15:03:02 <sal23> jeffwheeler: thanks....looking at it
15:03:03 <b_jonas> do { answer <- return ((repeat 42) !! 1000000000); putStr "million year computation finished, wanna know the answer? it's "; print answer; }
15:03:39 <b_jonas> that does the computation between the two prints are performed.
15:04:00 <b_jonas> why couldn't something like that happen in the interpreter?
15:04:10 <Toxaris> b_jonas: that will happen, of course
15:04:40 <Toxaris> b_jonas: since the interpreter is written in Haskell, it will be lazily evaluated
15:05:00 <Toxaris> b_jonas: but that doesn't mean that the interpreted language has non-strict semantics
15:05:54 <Toxaris> b_jonas: the interpreted language has a print statement, I assume, and you evaluate the term "x := doSomething; print "done"; waitForUserInput; print x"
15:06:27 <vixey> What's the simplest way to parse a language with pre/post/in/distfix operators?
15:06:30 <Toxaris> so just make your interpreter not touch "print "done"; wairForUserInput; print x" before "x := doSomething" is completely evaluated
15:06:39 <hansfbaier> @src mfix
15:06:39 <lambdabot> Source not found. You untyped fool!
15:06:50 <b_jonas> Toxaris: exactly,
15:06:58 <sw17ch> [] : []
15:07:00 <b_jonas> so I want to know what's the good way to do that
15:07:01 <sw17ch> > [] : []
15:07:02 <lambdabot>  [[]]
15:07:05 <sw17ch> > [] : [] : []
15:07:06 <lambdabot>  [[],[]]
15:07:10 <b_jonas> I'll suggest one way that I think works
15:07:15 <b_jonas> but I'm not exactly sure it does
15:07:20 <b_jonas> here:
15:07:25 <ziman> > ([]:[]):[]
15:07:26 <lambdabot>  [[[]]]
15:07:27 <ddarius> b_jonas: Read the paper I referenced.
15:07:36 <Toxaris> b_jonas: use a "strict monad" on the outside of your interpreter's monad transformer stack, e.g. Either String
15:08:10 <ddarius> b_jonas: The point of the paper is how to write interpreters for languages without the interpreted language depending on details of the intepreting language.
15:08:43 <vixey> or does anyone know a simple implementation I could pull apart?
15:09:04 <Toxaris> vixey: there's something in Parsec, but I never used it
15:09:12 <vixey> no Parsec can't do this
15:09:30 <vixey> well it does about 3/4 of what I want
15:09:31 <b_jonas> Toxaris: I don't see how an Either layer would make it more possible than just an identity monad (or any other sane monad transformer)
15:09:51 <Toxaris> b_jonas: well, the identity monad doesn't change the semantics at all
15:10:03 <Toxaris> b_jonas: kind of obviously given its name
15:10:07 <b_jonas> Toxaris: what I mean is I don't see how you can do this without Seq
15:10:15 <b_jonas> s/Seq/seq/
15:10:39 <b_jonas> how does just an Either layer magically make the computation evaluated in strict order?
15:10:45 <b_jonas> if you don't use seq at all that is
15:10:55 <b_jonas> wait, let me give some code
15:11:01 <b_jonas> let { returnseq :: a -> IO a; returnseq x = seq x (return x); } in do { answer <- returnseq ((repeat 42) !! 1000000000); putStr "million year computation finished, wanna know the answer? it's "; print answer; }
15:11:02 <Toxaris> b_jonas: >>= for Either pattern matches on the result, checking for an exception
15:11:22 <Toxaris> b_jonas: how is that code related to an interpreter?
15:11:40 <b_jonas> Toxaris: it's how I think the previous example can be fixed
15:12:01 <ddarius> You don't need seq at all for this.
15:12:05 <b_jonas> but I'm not sure it's good in general or that it's good practice or taht there's something better
15:12:25 <Toxaris> b_jonas: it is bad, it is bad practice, it is not what you want
15:12:27 <Toxaris> :)
15:12:34 <b_jonas> ok, so I want to know the good practice
15:12:41 * b_jonas looks at the code ddarius linked to
15:12:45 <b_jonas> s/code/paper/
15:14:29 <seanmce> I want to check out happs, we people recommend darcs or hackage version?
15:14:37 <seanmce> s/we/would/
15:15:23 <Lemmih> seanmce: The hackage version is only a little behind the darcs version.
15:15:44 <seanmce> there seems to be different package names
15:16:23 <seanmce> hackage has happs-http, darcs has happs-server?
15:17:04 <seanmce> no happs-plugins in hackage
15:17:24 <Lemmih> seanmce: happs-http is just an alias for happs-server.
15:17:55 <Lemmih> seanmce: And happs-plugins doesn't really exist. Much of the information on happs.org is completely out of date.
15:18:15 <seanmce> ok, thanks. I'll use hackage
15:22:48 <hatseflats> Can someone help me out, I have this bit of code : http://pastebin.com/d1cc219cd , and I keep getting "Parse error on input `<-'" on line 7
15:23:16 <Toxaris> > let returnseq x = seq x (return x) in runIdentity $ do { answer <- returnseq undefined; return $ "seq is not what you want, b_jonas"}
15:23:17 <lambdabot>  "seq is not what you want, b_jonas"
15:23:56 <b_jonas> Toxaris: yes, that should return that
15:24:00 <TSC> hatseflats: You need another "do" in the "then" part
15:24:05 <b_jonas> I didn't continue saying why I'm writing that
15:24:12 <vixey> @src Num
15:24:12 <lambdabot> class  (Eq a, Show a) => Num a  where
15:24:12 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:24:12 <lambdabot>     negate, abs, signum     :: a -> a
15:24:12 <lambdabot>     fromInteger             :: Integer -> a
15:24:53 <b_jonas> what I think is that returnseq evaluates its argument to whnf (or whatever it's called) before performing any subsequent io actions (including another returnseq)
15:25:36 <b_jonas> so I can perform returnseq repeatedly on all values I should compute to make sure all computations are done before any io actions are done
15:25:44 <Toxaris> b_jonas: returnseq evaluates it argument to whnf *if it is evaluated to whnf*
15:25:49 <hatseflats> TSC: hmm, that indeed solved it. Can you tell me why I need the extra do? Is it because the 'then' statement that undoes the original 'do'?
15:26:08 <Toxaris> b_jonas: so it depends on >>= of the monad you are using
15:26:36 <Toxaris> b_jonas: some of them are strict in the first argument, so that they evaluate the earlier actions to whnf, some are not
15:26:50 <b_jonas> Toxaris: but I defined it as returnseq :: IO x -> x
15:26:56 <b_jonas> so it's used in the IO monad
15:26:59 <b_jonas> I did write that specifically
15:27:15 <b_jonas> and IO is strict in the first argument of (>>=), isn't it?
15:27:18 <Toxaris> but you're real interpreter surely isn't in the IO monad?
15:27:26 <Toxaris> I have no clue whether IO is strict or not
15:27:42 <b_jonas> the real interpreter is in a monad transformer obviously
15:28:09 <Toxaris> yep seems to be the case. and it is kind of obvious, of course, now thinking about it
15:28:56 <Toxaris> b_jonas: anyway, calling seq is as good as pattern matching, and in a monad transformer stack with an error monad, >>= will pattern match on the left value anyway
15:29:10 <b_jonas> so I'll have to use (liftIO . returnseq) obviously
15:29:24 <Toxaris> b_jonas: and in an interpreter, *you never have return <large computation here>*
15:29:58 <Toxaris> b_jonas: so the non-strictness of return doesn't matter
15:30:15 <b_jonas> why not?
15:30:35 <b_jonas> if a statement doesn't contain anything that becomes pure (no io-actions)
15:30:51 <b_jonas> then it's as if it was return <large computation> semantically, isn't it?
15:31:19 <dmhouse> ?ask kowey for a review on http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
15:31:19 <lambdabot> Consider it noted.
15:31:33 <b_jonas> note that I'm not really sure this is the good solution, but I'm still defending why I think it is good until I learn anything better
15:31:46 <dmhouse> ?tell sw17ch is mostly done, check it out.
15:31:46 <lambdabot> Consider it noted.
15:31:47 <Toxaris> b_jonas: do you have an actual problem, or are you just planning ahead?
15:32:01 <b_jonas> Toxaris: planning ahead
15:32:04 <Toxaris> b_jonas: which is a good idea, of course:)
15:32:07 <b_jonas> but J is an array programming language
15:32:07 <dmhouse> ?tell sw17ch err, sorry, URL is http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
15:32:07 <lambdabot> Consider it noted.
15:32:23 <b_jonas> so if I write a J interpreter, you'd have lots of pure code executed at once
15:33:18 <b_jonas> and even if it's not pure in the sense that IORef operations are performed in between to store things to variables
15:33:40 <b_jonas> that still make won't make it strict because whatever is assigned to the variable isn't evaluated to even whnf
15:33:43 <b_jonas> I mean,
15:33:50 <b_jonas> I think if you write the interpreter as lazy
15:34:48 <b_jonas> I see it inevitable that if a variable assignment with a long computation is evaluated, it mustn't compute anything actually
15:35:07 <b_jonas> well, that's not really pure
15:35:12 <b_jonas> s/pure/true/
15:35:14 <b_jonas> actually
15:35:23 <Toxaris> in a error monad setting, it will compute enough to check that the long computation doesn't produce any run-time errors
15:35:41 <b_jonas> because exceptions can be raised in lots of operations, even in like division
15:35:45 <eu-prleu-peupeu> <3
15:36:05 <Toxaris> but i'm actually totally confused now
15:36:05 <b_jonas> surely most code will have to evaluated to at least such a state that no exception has occurred
15:36:24 <Toxaris> every single bit of code will be evaluated to Right (...) by the Either's >>=
15:36:28 <b_jonas> like, suppose you have a language where division by zero raises an exception
15:36:35 <b_jonas> yep, those have to be checked
15:36:40 <b_jonas> so you won't get problems in that case
15:36:58 <b_jonas> the prompt can't return before all the results of divisions are computed
15:37:21 <b_jonas> hmm, I see
15:37:24 <b_jonas> so basically
15:37:26 <Toxaris> well, I have written (small) interpreters in Haskell, never worried about laziness, never had problems with laziness.
15:37:47 <b_jonas> that actually might help more than I think
15:37:58 <b_jonas> but I'm still not sure it's enough
15:38:08 <Toxaris> there are not many operations which can throw no runtime errors at all
15:38:31 <Toxaris> and in the languages i have written interpreters for, there where no
15:38:37 <b_jonas> Toxaris: but still consider this is an array programming language
15:38:39 <Toxaris> so my experience may not apply
15:39:06 <b_jonas> so if you have an operation that does some large array operation that can only give a type error that can be checked easily
15:39:10 <b_jonas> because arrays are homogenous
15:39:22 <b_jonas> you could have lots of numeric array computation pending
15:39:26 <b_jonas> there's also memory usage
15:39:31 * ddarius can extend b_jonas' argument to a winning case and Toxaris' to a winning case.
15:39:50 <b_jonas> but I'm even less sure about memory usage than time
15:39:51 <ddarius> Also, ironically, for something like a J interpreter you'd want to explicitly be lazy.
15:39:56 <ddarius> (dragging and beating)
15:40:02 <b_jonas> ddarius: why?
15:40:48 <ddarius> b_jonas: J interpreters intentionally make those "numeric array computations" pend so that when they are actually needed they can (potentially) be simplified.
15:41:13 <b_jonas> ddarius: are you sure you mean the same J?
15:41:19 <ddarius> Yes.
15:41:32 <b_jonas> well
15:41:35 <b_jonas> I don't think so
15:41:40 <Toxaris> ddarius: cool. but to do the potentially simplification step, b_jonas can not rely on Haskell's laziness, but has to implement his own
15:41:41 <b_jonas> you often use J interactively
15:41:50 <vixey> hm
15:41:53 <ddarius> Toxaris: Hence "explicitly"
15:42:06 <b_jonas> that's something forth and smalltalk users consider a feature
15:42:12 <vixey> I think you want a J monad
15:42:13 <Toxaris> ddarius: but that sounds messy, since laziness seems to be essentially impure :(
15:42:22 <vixey> which is the same idea as Cales IO Monad as a GADT
15:42:25 <ddarius> b_jonas: Interactivity is irrelevant.
15:42:34 <b_jonas> in that case, I think you'd want to know if a computation finishes in time or is very slow so you want to break out of it
15:42:44 <vixey> then you have runJ which is the naive interpreter, and compileJ which may simplify
15:42:46 <b_jonas> ddarius: is it?
15:42:47 <vixey> does that make sense?
15:43:02 <b_jonas> vixey: well, I want a naive unoptimized interpreter
15:43:23 <b_jonas> but yeah, suppose you want an optimized one
15:43:34 <b_jonas> how do you mean lazyness would help?
15:44:17 <ddarius> b_jonas: When you write the equivalent of 'head $ replicate 1000000 10' J interpreters don't make a 1000000 element long array and select the first element.
15:44:48 <b_jonas> ddarius: well, the J interpreter does make such a long array and select the first element
15:45:11 <Toxaris> b_jonas: laziness combines the best of call-by-name and call-by-value evaluation, and needs only as many reduction steps as absolutely needed to calculate the result
15:45:40 <b_jonas> Toxaris: yes, that's true
15:45:48 <Toxaris> b_jonas: so obviously, it helps with speed
15:45:48 <b_jonas> but I have one more argument
15:45:56 <b_jonas> namely,
15:46:05 <Toxaris> b_jonas: ignoring overhead cost ... :)
15:46:14 <b_jonas> I do ignore overhead cost
15:46:27 <b_jonas> I'm a mathematician and don't care about constant factors in speed
15:47:00 <b_jonas> so, because J is an array language, people (including me) often write code that generate large arrays that take lots of memory for intermediate results
15:47:01 <b_jonas> that is
15:47:07 <b_jonas> if they want code like
15:47:40 <b_jonas> all (map somecomputation [1..1000000])
15:47:55 <b_jonas> then they write this to generate a large temporary array even though it's clear you could just use a foreach
15:48:08 <ddarius> b_jonas: Then they are seriously lacking compared to very old APL interpreters which I seriously doubt.
15:48:19 <b_jonas> I usually do this kind of thing because it leads to simpler code
15:48:24 <b_jonas> that is, unless it runs out of memory
15:48:44 <b_jonas> I can usually convert it to a foreach loop that doesn't need so much memory
15:49:12 <b_jonas> but it's more work (and sometimes the result is slower too if computation has such simple operations that are fast to run on vector)
15:49:18 <vixey> how do you parse J?
15:49:21 <ddarius> b_jonas: J interpreters no doubt do the exact same thing APL interpreters do to allow you to write such code and -not- have it be a problem.
15:49:22 <ddarius> vixey: You don't.
15:49:33 <b_jonas> ddarius: it's not a problem, sure
15:49:37 <b_jonas> what I want to say is
15:49:45 <b_jonas> if I write a lazy interpreter
15:49:45 <ddarius> vixey: Parsing J requires evaluating J.
15:50:01 <b_jonas> that kind of thing usually takes less memory
15:50:08 <b_jonas> but I'm not sure if it may also take much more memory
15:50:12 <b_jonas> because
15:50:16 <SamB> vixey: ... parse?
15:50:26 <b_jonas> memory usage is hard to predict in lazy code
15:50:30 <b_jonas> whereas
15:50:37 <b_jonas> if I write it with returnseq like I showed
15:50:49 <b_jonas> then I think that could control memory usage as well as time
15:50:55 <b_jonas> but I'm not exactly sure here
15:51:21 <ddarius> b_jonas: You couldn't.  Not with that by itself.
15:51:44 <b_jonas> ddarius: even if it's applied to basically all atomic results of all intermediate computations?
15:51:54 <b_jonas> s/applied to/performed on/
15:52:03 <b_jonas> even elements of arrays
15:52:11 <ddarius> Yes.
15:52:26 <b_jonas> but would it still control speed?
15:52:37 <b_jonas> I mean reaction time
15:52:39 <b_jonas> or not even that?
15:53:06 <Toxaris> b_jonas: if you want to replace return by returnseq, you could use an appropriate monad with a strict return
15:53:35 <b_jonas> Toxaris: can any monad have a strict return?
15:53:46 <Toxaris> b_jonas: e.g. data StrictMaybe a = Nothing | Just !a instead of Maybe
15:53:49 <b_jonas> isn't that a violation of some monad rule?
15:54:02 <ddarius> It is.  return x >>= f == f x
15:54:09 <vixey> what does that matter?
15:54:12 <Toxaris> :)
15:54:42 <b_jonas> there
15:55:03 <b_jonas> so how's it worse if I use returnseq on those values that I want to evaluate strictly
15:55:12 <b_jonas> than using a monad that violates rules?
15:55:26 <Toxaris> using the monad that violates rules may be more convenient
15:55:27 <Toxaris> :)
15:55:28 <vixey> b_jonas: Why are you doing any of this?
15:55:45 <b_jonas> vixey: I thought I already explained
15:55:46 <Toxaris> (hey, I announced that I'm confused)
15:55:58 <b_jonas> vixey: be more specific in the question
15:56:01 <vixey> b_jonas: I explained something earlier too
15:56:38 <b_jonas> wait
15:56:40 <b_jonas> you said
15:56:58 <b_jonas> 'I think you want a J monad; which is the same idea as Cales IO Monad as a GADT'
15:57:11 <b_jonas> I don't understand that
15:58:10 <b_jonas> what's Cales IO Monad?
15:59:05 <Toxaris> data IO a where Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; PutStr :: String -> IO (); ...
16:00:37 <vixey> instance Monad IO where
16:00:37 <vixey>   return = Return
16:00:37 <vixey>   (>>=) = Bind
16:01:03 <TSC> hatseflats: That is sort of the case; the "then" expression is not part of the do-block.  The entire "if ... then ... else ..." is one command in the do-block, but the constituent "..." parts aren't.
16:01:04 <eu-prleu-peupeu> what does the $= operator do ?
16:01:18 <eu-prleu-peupeu> i see a lot of f $= g in haskell code :/
16:01:45 <hatseflats> TSC: I see, I'll keep that in mind, thanks :)
16:01:51 <Zao> eu-prleu-peupeu: In hopengl, it sets a StateVar.
16:02:04 <eu-prleu-peupeu> ah ok
16:02:09 <eu-prleu-peupeu> its hopengl specific
16:02:17 <eu-prleu-peupeu> sorry, didn't know that :P
16:02:18 <eu-prleu-peupeu> thanks
16:02:19 * Toxaris imagines what funny things you could do with such an IO and access to the constructors
16:02:43 <Zao> eu-prleu-peupeu: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html#v%3A%24%3D
16:02:44 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.StateVar, http://tinyurl.com/2fcodm
16:03:46 <eu-prleu-peupeu> thanks zao :)
16:04:36 <b_jonas> Toxaris, vixey: do you mean to represent the actions of the underlying language like that in the interpreter?
16:04:37 <luqui> you don't even need a gadt to do IO as an adt, afaik
16:04:43 <Toxaris>  silent (Bind x f) = Bind (silent x) (silent . f)
16:04:43 <Toxaris> silent (PutStr s) = Return ()
16:04:43 <Toxaris> silent x = x
16:05:01 <luqui> oh you do if you want it to be parameterized, nevermind
16:05:23 <byorgey_> Toxaris: hehe, neat
16:05:30 <b_jonas> I don't really understand how you mean I would use such an IO monad
16:05:43 <b_jonas> please expand a bit
16:09:24 <Twey> let n = n in n -- The ultimate algorithm, solves any problem in O(1)... for an infinite value of 1
16:10:01 <vixey> can you prove it's correct though?
16:10:46 <ziman> > cycle "circular reasoning works because "
16:10:47 <lambdabot>  "circular reasoning works because circular reasoning works because circular ...
16:10:59 <b_jonas> ziman: lol
16:12:12 <b_jonas> that's like the method of proving a statement for all n natural numbers by proving it for 0, then proving it for 1, then proving it for 2 etc until all the audience starts to sleep
16:14:31 <luqui> the "omega brainwave" rule?
16:16:02 <hatseflats> Idn
16:16:39 <hatseflats> Gah, premature enter pressing is such a turn-off
16:17:12 <hatseflats> Isn't saying "(a -> b) -> [a] -> [b]" ambigious unless you know the amount of arguments a function takes?
16:17:34 <vixey> hatseflats: What do you meant
16:17:43 <ddarius> hatseflats: We know how many arguments a function takes.
16:17:47 <vixey> hatseflats: there are lots of functions with that type
16:19:20 <hatseflats> I'm trying to wrap my head around the type system, and if I'm even somewhat on the right track this could be read as both "((a -> b) -> [a]) -> [b]" and "(a -> b) -> ([a] -> [b])"
16:19:36 <vixey> that is true
16:19:45 <b_jonas> hatseflats: it alwasy means the former
16:20:01 <byorgey> hatseflats: no, -> associates to the right
16:20:03 <vixey> wait no it's not
16:20:13 <byorgey> so that first type you wrote is different
16:20:13 <vixey> in general, -> is right associative, so a -> b -> c -> z is a -> (b -> (c -> z))
16:20:37 <ziman> so that you can partially apply functions
16:20:45 <hatseflats> Okay, but how does that make sense if this is the type of 'map'?
16:20:58 <byorgey> hatseflats: in Haskell, all functions take a single argument.
16:21:06 <hatseflats> Oh...
16:21:16 <byorgey> hatseflats: it's just that some happen to return functions as their output, which take another argument...
16:21:19 <byorgey> and so on
16:21:19 <hatseflats> and produce another function that takes the second arg
16:21:21 <qwr> and return single value
16:21:22 <hatseflats> and then produce the value
16:21:25 <byorgey> hatseflats: right
16:21:43 <byorgey> hatseflats: encoding multi-argument functions as single-arguemnt functions returning functions in this way is known as 'currying'
16:21:44 <EvilTerran> map f (x:xs) = f x : map f xs
16:21:47 <EvilTerran> could be written as
16:21:53 <hatseflats> Lambda calculus... should have known
16:22:11 <EvilTerran> map f = g where g (x:xs) = f x : g xs
16:22:18 <byorgey> it's really nice from a practical point of view, though, as it allows for easy partial application
16:22:23 <qwr> hatseflats: basically appling first argument creates new function where this arguments value is embedded
16:22:28 <byorgey> e.g. (+) 2  is a function which adds two.
16:22:35 <hatseflats> So having function with multiple arguments in Haskell is just syntactic sugar for 'nested' lamba's, currying
16:22:37 <byorgey> and (+) 2 3 is 5.
16:22:42 <b_jonas> ah yeah, it's the latter
16:22:43 <byorgey> hatseflats: right.
16:22:43 <b_jonas> not the former
16:22:44 <b_jonas> sorry
16:22:45 <EvilTerran> hatseflats, exactly
16:22:50 <EvilTerran> you could also write
16:23:31 <qwr> > let sum x y = x + y in let add3 = sum 3 in (add3 2, add3 6)
16:23:32 <EvilTerran> map = \f -> \list -> (case analysis on "list")
16:23:33 <lambdabot>  (5,9)
16:23:50 <EvilTerran> where \ is read as "lambda"
16:24:09 <ddarius> and -> is read as ""
16:24:27 <EvilTerran> or "dot", or "to"...
16:25:22 <hatseflats> Well, at least now the type system makes sense, thanks a bunch everyone :)
16:25:31 <qwr> > let sum = \x -> (\y -> x + y) in sum 2 3
16:25:32 <lambdabot>  5
16:25:43 <byorgey> hatseflats: =)
16:25:55 <qwr> > let sum = \x -> (\y -> x + y) in (sum 2) 3
16:25:56 <lambdabot>  5
16:26:32 <EvilTerran> hatseflats, the type system makes sense? ha!
16:26:48 <EvilTerran> just wait 'til you see what Oleg's done with it
16:27:12 <hatseflats> 's/makes sense/makes some sense/'
16:27:19 <ddarius> This is at least the second time I've heard someone say that understanding the associativity of -> "makes the type system make sense"
16:28:00 <thoughtpolice> oleg's code makes the typechecker cry, i think.
16:28:12 <qwr> silently...
16:28:19 <SamB_XP> qwr: not always
16:28:22 <hatseflats> ddarius: it's not the associativity I had trouble with, I just needed to realise the implicit currying in functions with 'multiple' arguments
16:29:03 <ddarius> That's an immediate consequence of the associativity and the "implicit currying" has nothing to do with the type system.
16:29:29 <hatseflats> but I didn't understand it because these two got mixed up in the tutorial I am working through
16:30:06 <SamB_XP> ddarius: that doesn't mean that getting one won't help things "click"
16:30:23 <qwr> probably he had (wrong) assumption about existance of multiple-argument functions ;)
16:30:44 <SamB_XP> qwr: namely that there was such an existance?
16:30:49 <qwr> yes
16:30:56 <luqui> Most people say to Haskell: "check if this code makes sense"; Oleg says to haskell: "solve complex logic programming and force this code to make sense"
16:30:57 <hatseflats> qwr: spot on
16:31:09 <hatseflats> luqui: ... that sounds horrible
16:31:24 <SamB_XP> luqui: well, not necessarily.
16:31:29 <vixey> luqui: that is great
16:31:29 <ddarius> Actually the logic programming tends to be very simple
16:31:33 <SamB_XP> or exactly
16:31:40 <vixey> @remember luqui Most people say to Haskell: "check if this code makes sense"; Oleg says to haskell: "solve complex logic programming and force this code to make sense"
16:31:40 <lambdabot> It is forever etched in my memory.
16:31:42 <luqui> ddarius, fair enough
16:32:07 <vixey> Didn't they port over that pure declarative arithmetic into the Haskell type system?
16:32:09 <SamB_XP> see, it's more like "see if this complex logic programming problem is coherent; if so, implement the answer"
16:32:29 <vixey> and not by Oleg but the instant insanity one was really cool
16:33:38 <EvilTerran> ?go haskell instant insanit
16:33:40 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
16:33:40 <lambdabot> Title: The Monad.Reader - HaskellWiki
16:33:44 <EvilTerran> er
16:34:02 <EvilTerran> http://www.haskell.org/sitewiki/images/d/dd/TMR-Issue8.pdf
16:34:02 <lambdabot> Title: The Monad.Reader Issue 8
16:34:27 <EvilTerran> see, i like TMR's logo better than the haskell.org one
16:34:43 <EvilTerran> it's chunky and recognisable
16:35:17 <SamB_XP> I think it's well known that Haskell.org has a lousy logo
16:35:24 <b_jonas> heh
16:35:24 <vixey> @quote logo
16:35:25 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
16:35:37 <SamB_XP> @quote logo
16:35:37 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
16:35:51 <glguy> "perfection" might not be the right word there
16:35:51 <SamB_XP> but was xahlee being sarcastic?
16:36:38 <byorgey> it's a safe bet
16:36:43 * glguy greps for context
16:36:56 <glguy> 06.04.06:18:09:36
16:37:05 <b_jonas> I think an approperiate haskell logo would be some lambda expression represented in the crocodile notation
16:37:16 <SamB_XP> b_jonas: alligator
16:37:21 <byorgey> hehe, awesome
16:37:22 <b_jonas> ah, alligator
16:37:27 <glguy> 18:09:36 <xahlee__> The Haskell Logo is the perfection of logos
16:37:27 <glguy> 18:09:51 <xahlee__> as far as functional programing lang logo goes
16:37:32 <glguy> 18:10:10 <xahlee__> it is extremely beautiful, and embodies the beauty of math.
16:37:32 <glguy> 18:10:19 <xahlee__> and it is The logo.
16:37:36 <SamB_XP> b_jonas: the only reason I know this is because I still have that tab open ;-)
16:37:53 <b_jonas> http://worrydream.com/AlligatorEggs/
16:37:53 <lambdabot> Title: Alligator Eggs!
16:38:57 * SamB_XP remembers how easy it is to lose tabs and makes a new bookmark tag for wacky notations for lambda calculus
16:39:32 * SamB_XP promptly bookmarks & tags "alligator eggs" and "to disect a mockingbird" with it
16:39:51 * SamB_XP decides he can close those tabs now
16:40:33 <b_jonas> ah, yeah, the mockingbird notation might work as well
16:40:39 <b_jonas> though I'm not really familiar with that one
16:41:51 <SamB_XP> b_jonas: it doesn't have a normal form, though at least it does not require alpha conversion
16:42:09 <SamB_XP> that is to say, you have to pick how to orient things
16:42:09 <byorgey> I don't like the 'color rule'.  I wonder if there's some way to use de Bruijn indices with the alligators...
16:42:20 <b_jonas> byorgey: heh
16:42:49 <SamB_XP> byorgey: I think de bruijn notation is a bit beyond the target demographic of "alligator eggs"
16:42:59 <byorgey> hehe
16:43:20 <b_jonas> SamB_XP: doesn't the mockingbird notation also allow to show a letrec (or at least some letrecs) directly without using a y combinator like thing?
16:43:24 <byorgey> you could encode it by, say, the length of the alligator tails
16:43:34 <b_jonas> I should get that book by the way
16:43:45 <SamB_XP> b_jonas: only if you draw a pipe in the wrong direction
16:44:05 <b_jonas> SamB_XP: but is that bad or something?
16:44:17 <SamB_XP> you might need an arrow or something
16:44:52 <byorgey> oh, wait, not the alligator tails, it's the eggs that need indices
16:44:59 <b_jonas> let's see: the title is To mock a mockingbird
16:45:00 <byorgey> hum
16:45:06 * b_jonas writes that to the library catalogues
16:45:10 <b_jonas> with little hope
16:45:47 <gwern> sounds like one of smullyan's books
16:46:07 <b_jonas> it is, yes
16:46:21 <b_jonas> but I think it doesn't have a translation to Hungarian (yet?)
16:46:30 <b_jonas> so it might not be easily available here
16:47:13 <b_jonas> most of his books aren't translated
16:47:17 <gwern> I think whenever you ask 'does this esoteric english book have a hungarian translation?' the default answer is probably no...
16:47:20 <b_jonas> only like five or six of them are
16:47:44 <b_jonas> it's still worth a check in the online catalogs
16:50:23 <b_jonas> no match
16:53:38 <Elly> sounds like time to grab the english one then :)
16:54:18 <b_jonas> Elly: yep,
16:54:30 <b_jonas> but it's not in the libraries in english either
16:54:36 <b_jonas> that's the problem
16:55:20 <b_jonas> that means I could only borrow it from international and I probably don't want that book so badly
17:06:08 * BMeph wonders if "To Mock a Mockingbird" has a German translation...
17:10:49 <brx> BMeph: "eine spottdrossel verspotten"
17:15:06 <b_jonas> good night now
17:21:19 <Twey> @pl \a b -> (c a) + (c b)
17:21:19 <lambdabot> (. c) . (+) . c
17:30:32 * BMeph is sad that `pl` doesn't know `on`
17:31:17 <thetallguy> `on` is cool, no doubt
17:34:14 <enso> BMeph, were you the one that showed me the monad math example using join the other day?
17:35:30 <BMeph> enso: I might have been there, but I don't think I was that creative... ;)
17:35:40 <enso> ha
17:36:13 <enso> ok
17:36:48 <enso> He challenged me to "figure it out" and now I don't remember it /to/ figure it out
17:36:48 <BMeph> Why do you ask - was there something else you were looking at?
17:37:29 <BMeph> Ah, good point. I suggest take a trip down memory log.. er, lane. :)
17:38:20 <enso> unfortunately not enabled
17:38:35 <enso> (at the time)
17:43:30 <BMeph> > ((*) `ap` (+3)) 8
17:43:30 <lambdabot>  88
17:43:45 <BMeph> ...but Why? >:)
17:44:16 <BMeph> enso: That line? :)
17:44:30 <enso> ah
17:44:40 <enso> that's it indeed!
17:44:54 <enso> hooray!
17:45:01 <enso> and that's logged away!
17:46:10 <BMeph> But now comes the fun part: Do you know why that works? :)
17:46:38 <enso> hah..I'm toiling that at the moment
17:47:12 <enso> I can't say right out that I get it
17:48:13 <gvdm> what's the src for ap?
17:48:26 <enso> @src ap
17:48:27 <lambdabot> ap = liftM2 id
17:49:55 <enso> so (*) becomes m (a->(a->b))
17:50:18 <enso> (+3) becomes m((a->b))
17:50:23 <BMeph> Basically, 'ap' is '$' in "Monad-Space", i.e.
17:50:35 <BMeph> ap: m (a -> b) -> m a -> m b
17:50:41 <enso> right
17:50:54 <enso> but "b" is really a function
17:51:10 <enso> that takes 1 arg
17:51:13 <BMeph> Close, but not quite: m is a function! ;)
17:51:47 <enso> well inside of ap "m" gets executed, no?
17:52:01 <BMeph> Specifically, m is the Reader monad: m a :: r -> a
17:52:19 <enso> ok...I suspected that
17:52:42 <enso> at least when I did @ty ((*) `ap` (+3))
17:52:46 <enso> :)
17:53:13 <enso> so 8 is the environment?
17:53:34 <enso> in which the reader is working?
17:53:37 <BMeph> enso: the point being, if m a :: r -> a, then m (a -> b) :: r -> a -> b
17:53:37 <enso> that at all right?
17:53:49 <BMeph> enso: Exactly so. :)
17:55:07 <BMeph> Or, using lists as m...
17:55:09 <enso> phew
17:55:33 <BMeph> > [(^2),(+1)] `ap` [4,5]
17:55:35 <lambdabot>  [16,25,5,6]
17:56:09 <enso> I see
17:56:22 <BMeph> I.e., [4(^2), 5(^2), 4(+1), 5(+1)]
17:56:37 <enso> so I see how `ap` is like $
17:56:41 <enso> right
17:56:52 <mmorrow> > ((*)=<<(+1))8
17:56:53 <lambdabot>  72
17:56:55 <mmorrow> > (`ap`(+1))(*)8
17:56:56 <BMeph> With all of the combinations shown, since that's the way list-as-a-monad works. :)
17:56:56 <lambdabot>  72
17:57:01 <enso> apply (^2) "monadically"
17:57:13 <enso> right
17:58:03 <enso> fancy
17:58:04 <enso> :)
17:58:28 <enso> still doesn't just roll off the tongue unfortunately
17:58:41 <enso> how  long have you guys been Haskelling
18:00:27 <enso> ?
18:00:40 <mmorrow> 1 year
18:01:28 <enso> ok
18:01:42 <enso> just trying to get a feel for the learning curve.
18:01:50 <enso> do you use it "daily"?
18:02:46 <mmorrow> every day :) i'm an independent contractor employed by myself, and use haskell almost exclusively at this point
18:02:49 <dino-> I've been learning it for 3 years now, not daily (don't I wish). And I had like 25 years of bad imperative crust to unlearn. It's been hard but very exciting.
18:03:07 <enso> hah
18:03:27 <dino-> And now I'm building something kind of big with H for real work. It's fantastic to work with it all day.
18:03:29 <enso> I'm like you dino
18:03:41 <enso> not 25 years...hardly
18:04:01 <BMeph> I've been studying Haskell for around a year, but don't really use it anywhere.
18:04:03 <mmorrow> dino-: sweet! good luck.
18:04:04 <enso> but my functional programming experience is limited to scheme
18:04:05 <dino-> Yeh, I pre-date the mouse.
18:04:16 <enso> ha.
18:04:31 <erikc> studying for 8 months, i mine haskell for good ideas and retrofit them into c++, to my coworkers' collective horror
18:04:33 <enso> I predate......the dvd. Ha
18:04:36 <BMeph> I'm at the point where I can use it, but I "know" that I'm missing some clever way to simplify my program... ;)
18:04:53 <solrize> i described haskell to someone yesterday as "like scheme on crack" ;)
18:05:03 <dino-> enso: That scheme helps I bet
18:05:21 <enso> haha, well my scheme stint was really short, academic really
18:05:23 <dino-> mmorrow: It's going really well! You can build so fast with Haskell, kind of amazing.
18:05:55 <BMeph> I haven't found the "imperative morality" too tough. But, I was introduced to many different comp. languages early.
18:05:59 <dino-> erikc: I tried doing a lot of that with Perl. Very difficult with the scary types they have.
18:06:04 <dino-> mining FP
18:06:11 <enso> I had to make a stupid scheme interpreter in C++ and one in scheme, that's the extent of it
18:06:25 <BMeph> ...hm, similarly with natural languages, too, now that I think of it. :)
18:07:15 <enso> I happen to enjoy perl
18:07:44 <enso> I'm a firmware guy by trade and for quick little data analysis bits I like it
18:07:45 <BMeph> It helps (me, anyway) to have had prior experience with Forth.
18:07:47 <allbery_b> perl has its place.  so does haskell
18:08:00 <mmorrow> dino-: totally. such speed, reliability .... and enjoyment. i didn't know it could be this good.
18:08:05 <enso> right, true of any language really
18:08:34 <BMeph> ensao: Oh, I also like using Perl much more than the awk scripts I cobbled together for things twenty years ago. :)
18:08:36 <mmorrow> dino-: (speed wrt dev time _and_ runtime ;))
18:09:06 <enso> hah, yes. I've fiddled with awk. no thank you
18:09:39 <enso> unless I'm doing some silly series of pipes on the command line I avoid awk like the plague
18:11:03 <BMeph> I had a project where I was manipulating satellite photos from one format to another. Using C. And awk.
18:11:19 <enso> blech.
18:11:19 <dino-> The thing about Perl is the messy typing bites you *all the time*. I'm getting tired of slim-to-none types
18:11:21 <ddarius> @google gawk AI
18:11:22 <lambdabot> http://www.cs.wustl.edu/~loui/sigplan
18:11:37 <BMeph> Come to think of it, I haven't touched a SPARCstation since then... >:)
18:11:59 <enso> the association is too strong
18:13:54 <dino-> There was a post by cdsmith about type systems, very interesting. http://www.pphsg.org/cdsmith/types.html
18:13:55 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
18:14:05 <solrize> i want to have a type for a list of strings, i.e. newtype Mytype = Mytype [String]
18:14:17 <solrize> is there a way with newtypederiving or something, to be able to get the length of that list
18:14:22 <solrize> other than by deconstructing it ?
18:14:27 <dino-> It left me thinking that what happens is people get worn out by things like C++, Java where there's just enough typing to keep you doing a pile of work for the compiler. But still it grates..
18:14:48 <dino-> So people end up retreating to the only other thing they think is out there: very loosely types scripting
18:14:56 <dino-> s/types/typed/
18:15:06 <enso> right.
18:15:19 <enso> It's freeing to be able to ignore all that stuff
18:15:26 <dino-> So, no offense to Perl and its community, but I feel personally like I'd like to be mostly through with it.
18:15:44 <enso> I disagree
18:15:50 <enso> I think perl has it's place
18:16:00 <slava> i think in the future, static typing will win
18:16:06 <enso> so it's not strictly mathematical formulation
18:16:09 <dino-> Yea, I agree with you guys: Please Perl before awk.
18:16:19 <enso> it has it's place
18:16:20 <slava> but for the time its still a work in progress
18:16:25 <enso> for quick and dirty
18:16:42 <dino-> But I have been doing a lot of Haskell shell scripting.
18:16:44 <mmorrow> solrize: mapMyType :: ([String] -> a) -> (MyType -> a)         mapMyType f (MyType xs) = f xs
18:17:12 <mmorrow> solrize: mapMyType length :: MyType -> Int
18:17:52 <rwbarton> solrize: or unMyType :: MyType -> [String]   unMyType (MyType xs) = xs.  There's no runtime cost to the deconstruction
18:18:01 <mmorrow> solrize: (once you write mapMyType once, you'll never have to deconstruct it again)
18:18:17 <mmorrow> or rwbartons strategy (which i usually use)
18:19:16 <mmorrow> mapMyType f = f . unMyType
18:20:35 <mmorrow> so,    unMyType === mapMyType id
18:21:45 <ddarius> 'mapMyType' is a horrible name for that.
18:21:53 <mmorrow> heh
18:21:59 <mmorrow> true
18:22:05 <BMeph> Just call it "bind" already... ;)
18:22:39 <enso> ha
18:23:05 <dino-> What's happened is I keep getting jobs now where it's not quick things that Perl suited for. It's really insane huge projects hacked out of Perl, some of it using various techniques to get OO-like behavior, all mixed together. It's this type of thing I'd like to get away from.
18:24:25 <mmorrow> yuck, i hate OOPerl
18:24:26 <enso> agreed dino
18:24:35 <enso> OO perl is hell
18:24:44 <enso> that's where Python is supposed to fill in
18:25:21 <enso> SUPPOSED to, I'm still skeptical about that
18:25:23 <solrize> mmorrow, rbarton, yeah that's what i was hoping to avoid
18:25:28 <solrize> i have a bunch of these types
18:26:22 <rwbarton> hmm... class Newtype a b | a -> b where unNewtype :: a -> b ? :)
18:26:44 <mmorrow> heh, i was just typing "a class seems to be in order" ;)
18:27:32 <ddarius> rwbarton: class Iso a b | a -> b, b -> a where iso :: a -> b; unIso :: b -> a
18:27:55 * BMeph thinks the way "OO" is pronounced is no coincidence...
18:28:04 <rwbarton> ddarius: Iso a b | a -> b, b -> a doesn't seem very good if there's more than one newtype for the same thing
18:28:16 <rwbarton> ddarius: (which may or may not be the case here)
18:30:27 <solrize> @where mapConcat
18:30:27 <lambdabot> I know nothing about mapconcat.
18:30:32 <solrize> @hoogle mapConcat
18:30:33 <lambdabot> No matches found
18:30:42 <byorgey> concatMap, perhaps?
18:30:46 <solrize> yeah
18:30:49 <solrize> thanks
18:31:44 * mmorrow thinks it should be concatMap = mconcat . fmap
18:31:53 <solrize> :t mconcat
18:32:08 <lambdabot> thread killed
18:32:23 <BMeph> @ty (++)
18:32:38 <lambdabot> thread killed
18:32:43 <mmorrow> > 1
18:32:50 * BMeph weeps for the lobotomized LB
18:32:58 <lambdabot>  thread killed
18:33:05 <enso> durrrrr
18:33:39 <erikc> this will be meaningless to non-(ex)ibmers, but does anyone know of a source control / defect tracking / release cycle management product similar to ibm's CMVC?
18:33:48 <mmorrow> or in Caleskell,
18:34:07 <mmorrow> foldr (++) mempty . (.)
18:34:49 <mmorrow> (assuming the default mconcat in terms of foldr)
18:35:54 <wagle_home> LB was lobotomized?
18:36:12 <wagle_home> > 1
18:36:27 <lambdabot>  thread killed
18:37:26 <wagle_home> i'd noticed that some LB functions were breaking (and not getting fixed)..  is something going on?
18:39:54 <byorgey> > putStrLn "thread killed"
18:39:55 <lambdabot>  <IO ()>
18:40:01 <byorgey> doh =)
18:42:29 <wagle_home> putStrLn "<IO ()>"
18:42:38 <wagle_home> > putStrLn "<IO ()>"
18:42:39 <lambdabot>  <IO ()>
18:56:22 <SamB_XP> why does the TMR logo remind me of a communist flag?
18:58:52 * SamB_XP supposes that if he wants to print out tmr he'd better do it at school since his printer at home can't print double sided and the uneven margins would certainly drive him crazy otherwise
18:59:58 <byorgey> SamB_XP: TMR also stands for "The Manifesto (Red)"
19:03:09 <ddarius> SamB_XP: Hammer and Sickle
19:03:33 <solrize> are there general recipes for finding space leaks?
19:03:55 <ddarius> Yes.  Don't write them.
19:04:02 <SamB_XP> WHY THE HECK IS THIS IN A RASTER FORMAT?
19:04:02 <solrize> thaaaaanks.
19:04:42 <byorgey> SamB_XP: it's for The People
19:04:44 <SamB_XP> actually it's made of more than one raster image ...
19:04:49 <SamB_XP> byorgey: it's in a PDF!
19:04:57 <SamB_XP> should be in PDF primitives
19:05:18 <SamB_XP> (... the vector kind)
19:06:36 <byorgey> SamB_XP: are you complaining? because I could send a Minister of Communal Harmony over to your house
19:06:52 <SamB_XP> I'll call the DHS on 'em if you do
19:06:53 <byorgey> he has some great methods for ensuring that you are harmoniously communal
19:07:15 <SamB_XP> or, uh, 'im
19:07:16 <mmorrow> SamB_XP: i'm with byorgey. the commies rasterized it for sure.
19:08:56 <mmorrow> oh uh, i mean the capitalist swine rasterized it for sure.
19:09:29 <SamB_XP> yeah, and I'm sure commie-built PDP-11s are the most reliable, too!
19:12:11 <mmorrow> especially when gloriously employed to rasterize PDFs!!
19:15:38 <dublpaws> does anyone know of a tutorial for Data.Graph?
19:38:24 <mjrosenb> how do i make :hist display more than the first 20 entries?
19:39:28 <ddarius> mjrosenb: You hack GHC.
19:39:41 <ddarius> Or is 50 the limit?
19:39:45 <ddarius> I forget.
19:40:01 <SamB_XP> I thought it was referred to as "reconfiguration"
19:40:19 <SamB_XP> ... though of course you also have to rebuild ;-)
19:41:22 <mjrosenb> is there seriously not a configuration option for that?
19:41:38 <mjrosenb> *run time configuration option
19:42:13 <ddarius> There is an arbitrary upper limit that doesn't currently have a configuration option.
19:43:49 <mjrosenb> hrmm
19:44:46 <mjrosenb> is that limit also the default?
19:57:41 <gwern> 'Either those damn commies or the capitalist swine (mmorrow can't get his story straight on this) seem to have rasterized the logo -- what's the point of putting TMR in a PDF if the logo is going to be made of not one but TWO raster images?' <-- o.0
20:08:01 <byorgey> gwern: hehe, check the logs =)
20:18:11 <Chad> @seen dons
20:18:12 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I don't know when dons last spoke.
20:44:48 <hml> why does the following code fail to compile when i remove the type declaration?
20:44:49 <hml> test_or_not_working :: Parser String
20:44:51 <hml> test_or_not_working = string "(a)" <|> string "(b)"
20:45:26 <ddarius> I swear you asked this a few days ago.
20:50:52 <rwbarton> hml: it compiles just fine
20:59:39 <lispy> is there a new TMR out?
21:00:20 <SamB_XP> is 10 new?
21:00:31 <hml> rwbarton: what version of ghc are you using, with what extensions?
21:00:37 <hml> ddarius: iirc, i think you're right
21:00:55 <rwbarton> hml: 6.8.2, with no extensions
21:01:24 * SamB_XP thinks the editorial is funny
21:01:32 * SamB_XP also thinks that it is true ;-P
21:01:44 <hml> > test_or_2 = try (string "(a)") <|> string "(b)"
21:01:44 <lambdabot>  Parse error at "=" (column 11)
21:01:54 <hml> hmm, that's not hte error
21:02:19 <rwbarton> @type string
21:02:24 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:03:06 <rwbarton> @type  Text.ParserCombinators.Parsec.string "(a)" <|> Text.ParserCombinators.Parsec.string "(b)"
21:03:07 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Text.Parsec.Prim.ParsecT s u m String
21:04:03 <rwbarton> I see, I must not have the latest version of parsec
21:04:33 <rwbarton> hml: you're running into the monomorphism restriction, and the variables s u m are getting defaulted to something you don't want
21:05:17 <hml> rwbarton: I have a phd vs startup question; can i pm you?
21:05:30 <rwbarton> hml: Or more likely you're getting an ambiguous type variable error
21:25:16 <hackage> Uploaded to hackage: mdo 0.0.1
21:38:51 <patc_> I'm trying to write a c2hs spec for:  uint64_t getDeductiveCount(struct InstCount *i);
21:39:26 <patc_> c2hs does not like:  {# fun getDeductiveCount {`PInstCount'} -> `Counter' cIntConv * #} (the problem is with the output part)
21:39:48 <patc_> I have a definition: type Counter = {# type uint64_t #} ... any ideas?
21:50:57 <patc_> found the error; needed to use 'peekIntConv' rather than
21:51:17 <patc_> 'cIntConv'  (I think ...)
21:51:32 <chylli> hwo to ask lambdabot to rewrite a piece of  code to free point style ?
21:51:53 <chylli> !help
21:51:57 <chylli> @help
21:51:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:52:05 <chylli> help list
21:52:10 <chylli> @help list
21:52:10 <lambdabot> list [module|command]
21:52:10 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
21:53:35 <int-e> @pl \a b c d e -> a (b (c (d e)))
21:53:36 <lambdabot> (. ((. (.)) . (.) . (.))) . (.) . (.) . (.)
21:54:29 <lispy> heh, I saw that mess of parens and (.) and thought, "Who did that?" then I realized int-e was back :P
21:55:20 <int-e> Heh I still find it ironic that point-free code has so many dots.
21:55:55 <painy> (.Y.)
21:56:04 <chylli> @pl addNo a = (show (fst a)) ++ " " ++ (snd a)
21:56:05 <lambdabot> addNo = ap ((++) . show . fst) ((' ' :) . snd)
21:56:38 <chylli> what's the ap?
21:57:16 <int-e> in this case, the S combinator, \f g x -> (f x) (g x)
21:57:30 <chylli> @type ap
21:57:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:58:15 <int-e> where m = (->) c, so that's (c -> (a -> b)) -> (c -> a) -> c -> b
21:58:38 <int-e> @src ap
21:58:39 <lambdabot> ap = liftM2 id
21:59:41 <chylli> I think addNo has nothing with monad, why ap ?
22:00:36 <int-e> the functions (c -> x) (where x varies) form a monad, the so called reader monad. it's in that monad that the ap works in.
22:01:15 <chylli> thanks
22:05:47 <int-e> (The monad is rather simple. it's defined by  return = const  and  f >>= g = \c -> g (f c) c. Semantically, it carries an immutable context around that you can query. The query operation is  ask = id. The monad also comes in a newtyped variety, newtype Reader r a = Reader { runReader :: r -> a })
22:06:51 <int-e> Using Reader r a is usually more readable *g*
22:08:01 <chylli> infact, I only understand a little what you said :(
22:08:48 <Cale> I think it's easiest to understand that monad with a few examples :)
22:09:08 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
22:09:14 <lambdabot>  ("Hello","olleH","HELLO")
22:09:28 <Cale> > (do w <- length; x <- id; y <- reverse; z <- map toUpper; return (w,x,y,z)) "Hello"
22:09:29 <lambdabot>  (5,"Hello","olleH","HELLO")
22:09:57 <centrinia> @unpl (. ((. (.)) . (.) . (.))) . (.) . (.) . (.)
22:09:57 <lambdabot> (\ w al n q t -> w (al (n (q t))))
22:10:01 <ahunter2> ...Can someone suggest a better guide/tutorial to writing FFI wrappers than the FFI spec?  I'm trying to write a quick interface, and finding the spec a bit impenetrable when it comes to quick-and-dirty "this is how import a few functions, use some opaque pointers, and use simple arrays"...
22:10:06 <centrinia> Nice. :)
22:10:41 <centrinia> Why are the variables called w, al, n, q, and t?
22:10:53 <Cale> So you can see that in this monad, the actions are functions, and to "run" an action, you just apply it to the parameter to which the whole thing has been applied.
22:11:15 <Cale> @unpl (. ((. (.)) . (.) . (.))) . (.) . (.) . (.)
22:11:15 <lambdabot> (\ w al n q t -> w (al (n (q t))))
22:11:24 <Cale> hmm, it's consistent-seeming at least :)
22:11:27 <int-e> w, al, n, q, t ... where does it get those identifiers?
22:11:28 <Cale> @unpl (. ((. (.)) . (.) . (.))) . (.) . (.) . (.) . (.)
22:11:28 <lambdabot> (\ z as n q t w -> z (as (n (q t)) w))
22:11:44 <Cale> My guess is that a random generator is involved somewhere :)
22:11:51 <Cale> @unpl (. ((. (.)) . (.) . (.))) . (.) . (.) . (.) . (.) . (.)
22:11:52 <lambdabot> (\ ac ay n q t w z -> ac (ay (n (q t)) w z))
22:11:57 <Cale> mmm...
22:12:00 <Cale> maybe not?
22:12:30 <Cale> There's probably a supply of variables that it consumes as it goes
22:12:32 <int-e> does it start be replacing every section (. f) by \a -> (.) f a and (.) by \f g x -> f (g x)?
22:12:41 <int-e> that would use up lot of variables.
22:13:18 <int-e> @unpl (.)
22:13:18 <lambdabot> (\ a b c -> a (b c))
22:13:23 <int-e> @unpl (. (.))
22:13:23 <lambdabot> (\ d g -> d (\ b c -> g (b c)))
22:13:29 <int-e> @unpl (. f)
22:13:29 <lambdabot> (\ a d -> a (f d))
22:17:44 <centrinia> @unpl (+) =<< join (+)
22:17:45 <lambdabot> (((+) >>= \ a -> a) >>= (+))
22:23:16 <mornfall> Anyone know, if I have a lazy ByteString, how to turn it into a regular one?
22:24:29 <mornfall> I'm at a total loss here...
22:24:34 <lispy> ?hoogle BSL.ByteString -> BS.ByteString
22:24:35 <lambdabot> No matches, try a more general search
22:24:47 <lispy> ?hoogle ByteString -> ByteString
22:24:48 <lambdabot> Data.ByteString.tail :: ByteString -> ByteString
22:24:48 <lambdabot> Data.ByteString.init :: ByteString -> ByteString
22:24:48 <lambdabot> Data.ByteString.reverse :: ByteString -> ByteString
22:25:00 <mornfall> Not the right ones...
22:26:03 <lispy> ?hoogle toChunks
22:26:04 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
22:26:04 <lambdabot> Data.ByteString.Lazy.Char8.toChunks :: ByteString -> [ByteString]
22:27:04 <mornfall> Ah.
22:27:06 <mornfall> Interesting.
22:27:57 <lispy> http://hackage.haskell.org/packages/archive/bytestring/0.9/doc/html/Data-ByteString-Lazy-Char8.html
22:27:58 <lambdabot> Title: Data.ByteString.Lazy.Char8, http://tinyurl.com/5rg2so
22:27:59 <chylli>  Cale: ok, thanks. that's because "hello" is a list and List is instance of Monad, isn't it ?
22:28:16 <Cale> chylli: nope, that's all in the function monad...
22:28:21 <Cale> Here's another example...
22:28:32 <mornfall> lispy: So BS.concat . BSL.toChunks?
22:28:41 * mornfall tries
22:28:49 <Cale> > (do x <- cos; y <- sin; return (x,y)) 3
22:28:51 <lambdabot>  (-0.9899924966004454,0.1411200080598672)
22:29:11 <jeffwheeler> > let f""" = 3 in 2 + f"""
22:29:11 <lambdabot>  Parse error at end of input
22:29:24 <jeffwheeler> > let f''' = 3 in 2 + f'''
22:29:25 <lambdabot>  5
22:29:32 <Cale> So here, x is the result of applying cos to 3, and y is the result of applying sin to 3.
22:29:37 <jeffwheeler> Darn.
22:29:53 <Cale> 3, because that's the value that the function as a whole is being applied to
22:29:56 <chylli> Cale: I think I get it. thanks.
22:30:04 <chylli> let me think it carefully.
22:30:11 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
22:30:12 <lambdabot>  [5,7,10,25,32]
22:30:39 <lispy> mornfall: I'm not sure what that will do
22:30:48 <mornfall> We'll see.
22:30:56 <lispy> mornfall: I can't imagine that transforming from BSL to BS is efficient though
22:31:40 <Cale> So in this monad, an action is just a function taking a parameter of the appropriate type, and to 'run' that action, you apply it to the parameter to which the function as a whole is being applied.
22:33:06 <Cale> So,  return x k = x
22:33:57 <solrize> @where putStrLn
22:33:57 <lambdabot> I know nothing about putstrln.
22:34:00 <Cale> and  (x >>= f) k = f (x k) k
22:34:05 <solrize> @hoogle putStrLn
22:34:05 <lambdabot> Prelude.putStrLn :: String -> IO ()
22:34:05 <lambdabot> System.IO.putStrLn :: String -> IO ()
22:34:05 <lambdabot> Data.ByteString.putStrLn :: ByteString -> IO ()
22:35:33 <Cale> chylli: though perhaps the easiest way to understand it is through the types
22:35:58 <chylli> Cale: just now int-e said function monad is Reader monad ?
22:36:02 <Cale> yeah
22:36:16 <Cale> That's actually the same monad as this in disguise :)
22:36:28 <chylli> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Reader.html
22:36:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2w6l99
22:36:31 <chylli> this one ?
22:36:33 <Cale> yeah
22:36:56 <Cale> Though, it uses a newtype wrapper
22:37:53 <chylli> Cale: int-e: thanks very much... very funny
22:38:03 <Cale> > join (*) 5
22:38:04 <lambdabot>  25
22:38:10 <Cale> > join (++) "hello"
22:38:11 <lambdabot>  "hellohello"
22:38:27 <Cale> > fmap (1:) (2:) []
22:38:28 <lambdabot>  [1,2]
22:38:36 <Cale> (fmap is function composition)
22:39:05 <Cale> liftM2 (++) id reverse "hello"
22:39:13 <Cale> > liftM2 (++) id reverse "hello"
22:39:14 <lambdabot>  "helloolleh"
22:39:47 <Cale> > ap zip tail [1,2,3,4,5]
22:39:48 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
22:41:44 <Cale> So, there are lots of nice handy consequences :)
22:42:28 <chylli> Great... thanks again :p
22:42:49 <Cale> The Applicative instance for this is a really nice thing.
22:43:12 <Cale> pure (the same as return) is const, which is the traditional combinator K
22:43:41 <Cale> and (<*>) (the same as ap), is the same as the traditional combinator S
22:45:31 <Cale> I'm not sure whether or not you'd have run into the SK calculus before...
22:45:39 <Cale> but it's a nice 'coincidence'
22:46:33 <chylli> I didn't hear SK calculus before.
22:48:10 <Cale> Ah, okay... well, you might check out the wikipedia article (http://en.wikipedia.org/wiki/SKI_combinator_calculus).
22:49:50 <Cale> It can be shown that the (untyped) K and S alone can be used to express any Turing computable function.
22:51:01 <Cale> In their typed variations, they can also be seen as the two axioms of intuitionistic logic.
22:51:44 <Cale> A -> (B -> A), and (A -> (B -> C)) -> ((A -> B) -> (A -> C))
22:52:29 <sbahra>  join ##logic
22:52:38 <sbahra> spammed, excuse me ;]
22:53:02 <Cale> So it's kind of nice, you have some fairly old ideas from logic, and some ideas from category theory coming together in a nice way :)
22:53:13 <Korollary> sbahra: http://journals.cambridge.org/action/displayJournal?jid=RSL
22:53:16 <lambdabot> Title: Cambridge Journals Online - The Review of Symbolic Logic
22:53:17 <Cale> and computation of course :)
22:53:54 <sbahra> Korollary, ah man
22:53:55 <sbahra> Korollary, cool
22:54:21 <chylli> so many calculus :(
22:55:14 <Korollary> chylli: no pressure.
22:56:27 <Cale> Yeah, I don't want to give the impression that this is necessary to understand right away to proceed...
22:56:29 <sbahra> god damn $$$
22:56:45 * sbahra e-mails his professor in hopes that she'll get his university to pay ;p
22:56:58 <Korollary> sbahra: That 1st issue is free of course.
22:57:07 <Cale> sbahra: Have you checked whether your library has it?
22:57:23 <sbahra> Korollary, cool
22:57:41 <sbahra> Cale, very unlikely.
22:59:03 <Cale> A lot of universities have nice proxy servers you can log into and use to access electronic subscriptions to things.
22:59:37 <mornfall> Hmh. How do I install zlib from hackage? It keeps complaining about undefined symbols (inflateInit2 and such)...
22:59:44 <Cale> But yeah, it seems that's a new journal....
22:59:47 <mornfall> Pretty please...
23:00:44 <Cale> mornfall: well, I was going to bed, but I'll give it a shot and see if I run into the same thing at least :)
23:01:10 <Cale> nope, not a single error
23:01:17 <mornfall> Cale: Can you also load it?
23:02:07 <Cale> yep
23:02:14 <Cale> works in ghci...
23:02:17 <mornfall> Drat. I had .3
23:02:29 <Cale> I just used cabal-install to get it
23:02:29 <mornfall> Which is apparently broken. .4 works. Thanks and nevermind.
23:02:48 <chylli> Cale: where is the definition of function monad ?
23:03:07 <Cale> chylli: Control.Monad.Instances
23:03:15 <Cale> Also, importing Control.Monad.Reader will do
23:03:29 <Cale> It's a bit unfortunate that it's not in the Prelude.
23:07:15 <hml> is it possible ot get the haskell report as a pdf or Ps? i'm trying to print it, and lots of little html files is not ideal
23:08:21 <hml> n/m found it
23:09:01 <patc_> Any cabal experts on?
23:11:28 <patc_> Im trying to get "extra-lib-dirs:" to work with a space in a directory name in cabal; is there a trick for this?
23:14:44 <patc_> found trick --- use forward slashes on windows, and ignore bad error message
23:28:54 <catechu> Hello all. I'm new to Haskell, trying to set it up on a Mac OS X (10.4) box
23:29:31 <catechu> I keep getting errors about libgmp.3.dylib being "mach-o the wrong architecture"
23:30:48 <catechu> Binary packages aren't working for this reason. Source compilation gives me issues with loading the GNU readline framework. Has anyone successfully used GHC on a mac, and, if so, how?
23:31:14 <catechu> Thank you for your help!
23:32:35 <glguy_> catechu: i always install it via macports
23:35:37 <Beelsebob> Caelum: you've downloaded either the wrong version of libgmp, or the wrong version of ghc
23:35:49 <Beelsebob> it's complaining because you have a PPC mac and are trying to run an intel binary
23:35:52 <Beelsebob> or vice-versa
23:36:09 <Beelsebob> but yeh, the easiest way to get it is via mac-ports
23:36:52 <ahunter2> I can't find a solution anywhere obvious in the FFI docs: if my C header defines a constant as a macro (call it VAL_A, say), which is an int (in C...) how can I import that value so I can pass it as a flag to functions?
23:37:11 <catechu> Ah, that makes sense -- I will try MacPorts, and if that fails, I will try the 6.4.1 version of ghc available on Fink.
23:37:15 <ahunter2> Note I didn't write the C lib, so I can't just look up the value of the flag and use that...can't rely on it not changing and all that
23:37:45 <Beelsebob> ahunter: my suggestion would be to write a C getter for it
23:37:49 <Beelsebob> and then import the getter
23:38:06 <glguy_> the Haskell FFI doesn't deal with macros
23:38:16 <Beelsebob> catechu: 6.4.1 is *ancient* and does a lot of things differently to 6.8 -- you really want the most recent version
23:39:15 <ahunter2> Beelsebob: thanks
23:41:34 <ahunter2> Beelsebob: sorry, one other thing...how can I type that wrapper?  it returns an Int, and it's pure, so it should be ->Int, but what argument do I give it?  all the void functions in examples I've seen are impure and thus just have type IO Result
23:42:19 <Beelsebob> well, it's not pure
23:42:21 <catechu> Bellsebob: OK, I will use MacPorts then.
23:42:36 <Beelsebob> because it can return a different value at different points in the program run
23:42:44 <Beelsebob> so it's of type IO Int
23:42:54 <catechu> Sorry for misspelling your nick Beelsebob
23:43:02 <Beelsebob> np
23:43:04 <ahunter2> Beelsebob: I was under the impression that if you had a function like, say, int foo(int x) { return x*2 }, you could import that at type Int -> Int
23:43:18 <Beelsebob> yep -- but that on is pure
23:43:30 <ahunter2> and this one is: int foo() { return 3 }
23:43:31 <Beelsebob> otoh, one that returns a global variable is not
23:43:36 <Beelsebob> oh, is it always 3
23:43:40 <Beelsebob> not a global variable?
23:43:40 <ahunter2> not getting a variable
23:43:43 <ahunter2> just a flag value
23:43:48 <Beelsebob> okay, then it is pure, and it has type Int
23:43:51 <ahunter2> like O_RDONLY, or w/e (though my library value)
23:43:59 <Beelsebob> and you get from IO Int to Int using unsafePerformIO very carefully
23:44:02 <ahunter2> Oh, just Int?  I had expected I needed an arrow type
23:44:19 <Beelsebob> well, you can import it as IO Int easily, yes
23:44:24 <Beelsebob> because it's a void argument function
23:44:35 <Beelsebob> then wrap that in unsafePerformIO
23:44:37 <Beelsebob> and that's you done
23:44:57 <ahunter2> Beelsebob: ...oh, I had thought I'd read I could just skip that and import a pure function directly as Int -> Int or whatever
