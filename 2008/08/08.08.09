00:00:57 <Liempt> Really quick question for whomever may be active.
00:01:06 <Liempt> What's a function that returns the nth element of a list?
00:01:34 <Tordek> !!?
00:01:40 <ikegami--> !!!
00:01:43 <ikegami--> !!
00:01:44 <Cale> xs !! n
00:01:47 <ikegami--> :t (!!)
00:01:49 <lambdabot> forall a. [a] -> Int -> a
00:01:58 <Tordek> why is everyone so surprised?
00:02:08 <Tordek> (fofofo)
00:02:09 <Liempt> Thanks.
00:02:34 <int-e> > [1,2,3] !! 0
00:02:36 <lambdabot>  1
00:02:40 <ikegami--> > [] ! 100
00:02:42 <lambdabot>  Couldn't match expected type `Array i e'
00:02:54 <ikegami--> > [0] !! 100
00:02:55 <lambdabot>  Exception: Prelude.(!!): index too large
00:04:19 <sw17ch> holy cow, after 3:00AM
00:04:30 * sw17ch has a wife who won't be happy with him
00:06:35 <adu> YEY
00:11:50 <brad_larsen> well, I have my troublesome program down to 77 lines, still showing the same behavior:  recomputation when compiled with -O2, and no recomputation without optimization.
00:14:15 <adu> so its mostly working
00:14:26 <adu> except for the printing part
00:14:31 <adu> the filtering part works well
00:19:26 <brad_larsen> If I make the map of graphs in my data type strict, and do 'graphs `seq` loop graphs' instead of just 'loop graphs', I don't see the recomputation at all.
00:21:40 <dons> brad_larsen: -fno-state-hack help?
00:22:00 <dons> there can be some untoward recomputation when optimisation folds IO code in
00:22:08 <dons> and you get recomputation you didn't expect.
00:24:03 <brad_larsen> dons:  fancy that.  -fno-state-hack prevents the recomputation
00:27:58 <dons> we see this about hmm, once a month. someone stumbles on it. its a bit of an odd optimisation corner case.
00:28:23 <brad_larsen> dons:  that switch fixes even my original, non-bug-hunter version of my program
00:28:42 <brad_larsen> corner case /= bug?
00:28:58 <brad_larsen> should I write up a bug report, I mean
00:29:16 <dons> well, -fno-state-hack is a known issue. probably doesn't hurt to report it.
00:29:19 <dons> ?bug
00:29:20 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
00:29:28 <dons> might encourage some more thought.
00:29:43 <brad_larsen> ok.  I'll do that tomorrow.  Late here right now.
00:30:13 <brad_larsen> thanks for your help
00:38:08 <luqui> woah... sudden ephiphany about applicative:  instance Applicative (->) where { (<*>) = s ; pure = k }
00:38:20 <luqui> where s and k are our familiar complete pointfree combinators...
00:47:58 <pjdelport> luqui: :D
01:17:18 <matthew-_> Anglo Haskell 2008, day 2! Don't forget, streams available from 1pm onwards from http://streams.wellquite.org:8000/AngloHaskell2008.ogg
01:20:14 <chrisdone> time git clone http://darcs.haskell.org/ghc.git => 5m6.005s -- is this faster than darcs was?
01:20:15 <lambdabot> Title: Index of /ghc.git
01:20:31 <chrisdone> er, 55m6.005s
01:28:03 <Zao> chrisdone: It's throttled. Try the github one instead, that uses git://
01:38:46 <chrisdone> Zao: oh, cool. I like github
01:40:26 <hml> since i can pattern match on :, does that mean : is a construcgor?
01:40:33 <vixey> yes that is correct
01:40:34 <chrisdone> yes!
01:40:35 <vixey> @src []
01:40:35 <lambdabot> data [] a = [] | a : [a]
01:41:13 <hml> vixey: cool; thanks
01:42:40 <hml> wtf is the motivation behind the n+k patterns?
01:42:48 <b\6> when i try to compile the usual ApplicativeParsec stuff like from ch 19 of _real world_, i get Illegal instance declaration for `Applicative (GenParser s a)'.
01:42:57 <vixey> hml: It's a view
01:43:08 <vixey> 3 = 1+ 2
01:43:30 <vixey> you are viewing these GMP numbers or however they are implemented as peano
01:43:44 <hml> i don't understand how this relates to pattern matching
01:43:54 <hml> sorry, my question was ill phrased
01:43:56 <vixey> hml, it is a sore thumb
01:44:09 <hml> what is the motivtion behind n+k patterns in pattern matching
01:45:51 <chrisdone> pattern matching anything just for the sake of it
01:46:09 <hml> haha; i lov the follinwg quote:
01:46:43 <hml> there are limits to what you can write in .. notation ; i.e. you can't put [0, 1, 1, 2, 3, 5, 8, ... ] ; what? haskell can't read my mind anc dgenerate the fib sequence?
01:46:56 <vixey> > extendSequence [1,1,2,3,5]
01:46:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:47:11 <vixey> @faq can haskell read my mind and generate the fib sequence
01:47:12 <lambdabot> The answer is: Yes! Haskell can do that.
01:47:41 <hml> @faq can haskell answer a faq with "no" ?
01:47:41 <lambdabot> The answer is: Yes! Haskell can do that.
01:48:05 <olsner> oh noes, it's the @faq paradox!
01:48:40 <ivanm> haskell can, but lambdabot /= haskell!
01:48:43 <solrize> > extendSequence [4,9,25,49,121]
01:48:44 <lambdabot>  [4,9,25,49,121,169,289,361,529,841,961,1369,1681,1849,2209,2809,3481,3721,44...
01:48:50 <solrize> holy shmoly
01:49:01 <hml> @src extendSequence
01:49:02 <lambdabot> Source not found. You type like i drive.
01:49:11 <hml> how does this work?
01:49:17 <vixey> > describeSequence [2,3,5,7,11]
01:49:18 <lambdabot>  Just "The prime numbers."
01:49:29 <profmakx> might be oeis under the hood
01:49:52 <olsner> yeah, that's oeis iirc
01:50:05 <solrize> > describeSequence [4,9,25,49,121]
01:50:06 <lambdabot>  Just "Squares of primes."
01:50:08 <solrize> awww
01:50:22 <olsner> > describeSequence [3,1,4,1,5,9,2]
01:50:23 <lambdabot>  Just "Decimal expansion of Pi."
01:50:27 <solrize> i thought it was OEIS with a lattice reduction thingie
01:50:38 <hml> what's oesis?
01:50:51 <profmakx> @where oeis
01:50:51 <lambdabot> I know nothing about oeis.
01:50:53 <profmakx> hm
01:51:03 <profmakx> the online encyclopedia of integer sequences
01:51:04 <solrize> @goo oeis
01:51:05 <lambdabot> http://www.research.att.com/~njas/sequences/
01:51:05 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
01:51:32 <profmakx> @where+ oeis http://www.research.att.com/~njas/sequences/
01:51:33 <lambdabot> It is stored.
01:51:35 <solrize> there's some program around somewhere that can figure out polynomial relations on those sequences
01:51:47 <profmakx> coool
01:53:52 <profmakx> polynomial relations on a sequence or between sequences?
01:54:14 <solrize> this may be the thing i was thinking of:  http://www.research.att.com/~njas/sequences/superhelp.txt
01:54:24 <solrize> but yeah, i thought it used the LLL algorithm in some fancy way
01:54:58 <solrize> so it could figure out if a sequence was P(a1),P(a2),P(a3),... where a1,a2,a3 is a known sequence and P is an arbitrary unknown polynomial
01:55:10 <solrize> actually that's not so hard
01:55:14 <solrize> it would be fancier things than that
01:55:57 <profmakx> i should try to submit some sequences i computed during my thesis and look what comes out
01:56:07 <solrize> neat
02:01:30 <hml> @scan
02:01:30 <lambdabot> Maybe you meant: seen slap
02:01:34 <hml> @src scan
02:01:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:01:35 <hml> @src scanl
02:01:36 <lambdabot> scanl f q ls = q : case ls of
02:01:36 <lambdabot>     []   -> []
02:01:36 <lambdabot>     x:xs -> scanl f (f q x) xs
02:01:38 <hml> @src scanr
02:01:38 <lambdabot> scanr _ q0 []     =  [q0]
02:01:38 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
02:01:38 <lambdabot>     where qs@(q:_) = scanr f q0 xs
02:04:21 <oklopol> [4,9,25,49,121..] would be fun
02:04:29 <oklopol> for that extendsequence
02:05:05 <oklopol> can you somehow override []'s range syntax to do that?
02:05:15 <solrize> hehe
02:05:18 <vixey> the problem with using oeis for [..] notation is that oeis doesn't give you an algorithm
02:05:25 <vixey> it gives you finite section of the sequence
02:05:30 <heavensrevenge> square primes?
02:05:40 <oklopol> well that's boring
02:05:50 <hml> yeah; shouldn't that be like a 2 line fix?
02:05:53 <oklopol> anyway, if someone were to code them all up in haskell
02:06:00 <oklopol> could that be done?
02:06:10 <oklopol> that [..] syntax i mean
02:06:13 <vixey> ?faq could it be done?
02:06:13 <lambdabot> The answer is: Yes! Haskell can do that.
02:06:18 <oklopol> :)
02:06:23 <rwbarton> > [1,1,2,3,5,8..]
02:06:23 <lambdabot>  Parse error at "..]" (column 13)
02:06:38 <oklopol> i'm guessing no..?
02:06:42 <b\6> thought there often is some code to generate the sequence.
02:06:43 <vixey> I'm sure you'd have to hack the compiler
02:06:49 <rwbarton> Parse error in ghci too, so no
02:06:57 <oklopol> err
02:06:59 <solrize> hmm, maybe with a special weird Num instance and a type annotation
02:07:05 <oklopol> hmm
02:07:21 <solrize>  [1,1,2,3,5,8..] :: Oeis
02:07:35 <oklopol> that would be awesome
02:07:42 <rwbarton> that'd only work for [1,1..] :: Oeis
02:07:51 <rwbarton> under the current syntax I mean
02:07:56 <oklopol> hmm right
02:08:06 <oklopol> syntax errors can't really be fixed with typing
02:08:07 <solrize> there are some where they only  know a few terms
02:08:08 <solrize> http://www.research.att.com/~njas/sequences/more.html
02:08:08 <lambdabot> Title: Sequences That Need Extending
02:09:16 <hml> this is another great quote: (on monads): random numbers is meaningless; use infinite sequences
02:10:01 <solrize> http://www.research.att.com/~njas/sequences/?q=1,20,400,8902,197281,4865609,119060324,3195901860
02:10:02 <lambdabot> Title: 1,20,400,8902,197281,4865609,119060324,3195901860 - OEIS Search Results, http://tinyurl.com/6dl9wl
02:12:17 <oklopol> "Numbers n such that n divides the (left) concatenation of all numbers <= n written in base 2 (most significant digit on right)." <<< i don't get this
02:12:54 <hml> is there a short haskell one liner for genera5ing prime numbers as an infinite list?
02:13:55 <solrize> http://www.haskell.org/haskellwiki/Prime_numbers
02:13:56 <lambdabot> Title: Prime numbers - HaskellWiki
02:16:16 <nominolo> SamB: because I didn't change it
02:19:47 <hml> :t >>=
02:19:59 <hml> :t (>>=)
02:20:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:29:16 <Deewiant> > let f n = (read (concatMap (\x -> showIntAtBase 2 intToDigit x "") [0..n]) `mod` n) == 0 in map f [1,20,400,8902]
02:29:19 <lambdabot>  [True,True,True,False]
02:29:32 <Deewiant> oklopol: I thought it would have been the above but I guess not
02:30:08 <int-e> > nubBy (((>1) .) . gcd) [2..]
02:30:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
02:30:54 <solrize> !@
02:32:47 <hml> newtype State s a = State { runState :: (s -> (a,s)) }
02:32:52 <hml> can anyone explain to me what this line means?
02:32:54 <hml> it baffles me
02:33:06 <oklopol> Deewiant: isn't it [0..n+1]
02:33:19 <Deewiant> > [0..5]
02:33:20 <solrize> hml, you mean you don't understand the syntax?
02:33:20 <lambdabot>  [0,1,2,3,4,5]
02:33:26 <solrize> or you want to know how the state monad works?
02:33:26 <Deewiant> oklopol: <= 5 inclusive
02:33:27 <oklopol> right.
02:33:34 <int-e> hml it's the same as defining  newtype State s a = State (s -> (a,s))  and a function   runState (State f) = f.
02:33:38 <oklopol> well i clearly failed @ haskell there
02:34:54 <hml> solrize , int-e : so i've written the thread a counter through a tree example manually; but i'm not sure how to jum pfrom that to the definition of the state monad
02:35:22 <int-e> ah, that prime sieve is mentioned on http://www.haskell.org/haskellwiki/Blow_your_mind
02:35:23 <lambdabot> Title: Blow your mind - HaskellWiki
02:36:43 <rwbarton> that page is missing zip`ap`tail
02:38:43 <hml> int-e: in the line above, taht state thes type of runState, but doesn't define it; how do you get at : runState (State f) = f?
02:39:27 <int-e> hml: the type of runState is  State s a -> (s ->
02:39:35 <int-e> hml: the type of runState is  State s a -> (s -> (a,s))
02:39:56 <int-e> runState (State f) = f  is just a pattern match on the State (data) constructor.
02:40:09 <solrize> hml, the curly brace syntax just says "here's an access function to get at that value"
02:40:12 <solrize> right
02:40:17 <int-e> like fromJust (Just a) = a, and many others.
02:40:28 <int-e> @src fromJust
02:40:29 <lambdabot> fromJust Nothing  = undefined
02:40:29 <lambdabot> fromJust (Just x) = x
02:40:56 <solrize> data TwoIntegers = { firstint :: Integer } { secondint :: Integer}
02:40:59 <vixey> what
02:41:01 <solrize> a = TwoIntegers 3 5
02:41:06 <vixey> "product [1..6]" is supposed to "blow your mind"?
02:41:07 <solrize> then:   firstint a = 3
02:41:10 <solrize> and secondint a = 5
02:41:23 <oklopol> > inits [1,2,3]
02:41:24 <lambdabot>  [[],[1],[1,2],[1,2,3]]
02:41:43 <int-e> solrize: no, you'd write  data IntegerPair = Pair { firstInteger :: Integer; secondInteger :: Integer }
02:42:10 <hml> int-e , solrize : I  understaind now; cool thanks :-), so the runState is just a named filed, and State is a record?
02:42:27 <solrize> yeah, basically
02:42:45 <solrize> int-e aha, thanks
02:42:46 <int-e> it's , not ;.
02:43:19 <hml>  (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s'
02:43:24 <hml> how is it that runState is taking 2 arguments?
02:43:53 <RayNbow> :t runState
02:43:54 <lambdabot> forall s a. State s a -> s -> (a, s)
02:44:07 <int-e> hml: remember the type is  State s a -> (s -> (a,s)), or equivalently, State s a -> s -> (a, s)
02:44:23 <int-e> hml: the second argument gets passed to the function extracted from the State constructor.
02:44:38 <dcoutts> Zao: did you report the cwd problem with Cabal?
02:45:28 <hml> int-e: so in   "newtype State s a = State { runState :: (s -> (a,s)) }
02:45:29 <int-e> vixey: I guess that's a reference to the Evolution of a Haskell Programmer
02:45:41 <hml> runState the function, actualllllllllly has time State s a -> s -> (a, s) ?
02:45:44 <Zao> dcoutts: Not yet.
02:46:03 <Zao> dcoutts: 1) Stand in any directory. 2) Delete it from outside. 3) cabal install anything.
02:46:09 <hml> :r runState
02:46:15 <hml> :t runState
02:46:16 <lambdabot> forall s a. State s a -> s -> (a, s)
02:46:41 <dcoutts> Zao: ok, please do report it.
02:46:49 <int-e> hml:  State s a -> s -> (a, s)  and  State s a -> (s -> (a, s))  are the same type. the -> is right associative.
02:48:03 <hml> haskell: one line of code takes an hour to decipher
02:48:18 <luqui> sometimes more than that :-)
02:48:49 <vixey> haskell: Impossible to read, write or execute
02:48:57 <hml> lol
02:49:15 <Zao> dcoutts: Is it cabal-install or Cabal's fault?
02:49:49 <luqui> math: 8 symbols take hundreds of years to prove
02:49:52 <luqui> haskell isn't so bad
02:49:58 <vixey> :D
02:50:15 <dcoutts> Zao: could be either, just report it against cabal, we can sort out the culprit
02:50:15 <luqui> speak of the devil!
02:50:38 <hml> btwl; what are haskeller's take on p vs np
02:50:52 <vixey> ?faq P = NP
02:50:52 <lambdabot> The answer is: Yes! Haskell can do that.
02:50:58 <luqui> LOL
02:51:00 <Valodim_> haha, I was about to say that
02:51:17 <vixey> (in the type system)
02:51:25 <luqui> I have a strong hunch that P /= NP, but that our logics may not be able to know that.
02:51:42 <Valodim_> so you're a p-np-agnostic?
02:52:37 <luqui> when I'm being a platonist, P /= NP; when I'm being a formalist, neither P = NP nor P /= NP
02:52:40 <augustss> I think someone will prove P/=NP some day.
02:53:35 <hml> proof in the sense of continumum hyppothesis?
02:54:02 <luqui> yeah, I think the most likely proof to come up will be "it is consistent that P = NP"
02:54:08 <luqui> or consistency of its negation
03:01:04 <luqui> () _isn't_ terminal in Hask (without seq), because there are eg. two arrows Int -> (): f _ = undefined, f _ = ().  Correct?
03:01:59 <luqui> oh, but a data type with no constructors would be terminal.
03:02:05 <RayNbow> augustss: what if someone proves neither P=NP nor P/=NP are provable?
03:02:14 <hml> in the following; concerning State, the 2nd is pattern matching, the 1st and 2nd don't really do "anything" other than just take it's following argument and tag it with a type, right: in this code:     return a        = State $ \s -> (a,s) (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s'
03:02:31 <rwbarton> I think normally when people talk about Hask, they only consider total functions
03:02:55 <rwbarton> Otherwise (a, b) isn't a product, currying isn't an isomorphism, etc.
03:02:56 <luqui> RayNbow, then we can consider P /= NP for practical purposes, and having a lot of impractical fun studying the theory.
03:03:31 <luqui> rwbarton, oh, so no bottoms?
03:03:36 <rwbarton> Right.
03:03:51 <rwbarton> I should add the caveat that I don't think I've ever seen someone *say* exactly what they mean by Hask :)
03:03:55 <rwbarton> this is just my best guess.
03:04:16 <luqui> Hask is not a very good name then.  Maybe a better name would be Agda. :-)
03:05:08 <luqui> (I guess Agda is probably bigger than "total Hask"...)
03:07:28 <vixey> SET CPOs Hask... what's it all about? :P
03:12:40 <mattam> I always thought Hask was DCPOS's.
03:17:16 <quicksilver> luqui: Hask including _|_ is not an interesting category.
03:17:28 <DrSyzygy> quicksilver: Why not?
03:17:29 <quicksilver> luqui: when considering categorical properties it is usual to restrict to totality.
03:18:03 <quicksilver> DrSyzygy: because it has arrows between every pair of objects, it fails to be CC, etc etc.
03:18:09 <quicksilver> the things you want to be natural aren't natural.
03:18:18 <quicksilver> you don't get your free theorems...
03:19:00 <DrSyzygy> quicksilver: Ah.
03:19:59 <hml> okay; i think i get monads now
03:20:03 <hml> what are googd tutorials on arrows?
03:21:09 <quicksilver> the wikibook chapter on arrows is OK, hml.
03:21:25 <quicksilver> frustratingly most arrow tutorials dont' really touch on the interesting arrows.
03:21:38 <quicksilver> a bit of practice using HXT may be more enlightening about what they really do.
03:21:45 <hml> what's HXT?
03:27:21 <thoughtpolice> haskell xml toolkit (?)
03:27:32 <dmhouse> ?where hxt
03:27:32 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
03:59:21 <Axman6> @src (^)
03:59:21 <lambdabot> x ^ 0            =  1
03:59:21 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
03:59:21 <lambdabot>   where f _ 0 y = y
03:59:21 <lambdabot>         f x n y = g x n
03:59:21 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
03:59:23 <lambdabot>                       | otherwise = f x (n-1) (x*y)
03:59:25 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
03:59:45 <vixey> "...or using big hammers like topological sorts"
03:59:53 <vixey> topological sort is a big hammer? :S
04:01:20 <ziman> @hoogle (<$>)
04:01:20 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
04:02:18 <Axman6> @src (<$>)
04:02:19 <lambdabot> f <$> a = fmap f a
04:02:30 <Axman6> roighto
04:03:38 <vixey> http://www.haskell.org/happy/doc/html/sec-AttributeGrammarExample.html
04:03:38 <lambdabot> Title: 4.4.�Example Attribute Grammars, http://tinyurl.com/6hrggk
04:03:42 <vixey> why does it have to be so.. long
04:08:16 <solrize> bundle.hs: Printf.printf: formatting string ended prematurely
04:08:25 <solrize> ugh, doesn't say the line number where the exception happened
04:20:44 <EvilTerran> solrize, i think that'd be difficult without getting CPP involved
04:20:58 <EvilTerran> although that'd be entirely possible
04:21:34 <EvilTerran> actually, even with that, it'd be kinda fiddly, seeing as you'd have to catch the exception, splice the line number in, and throw it again
04:21:58 <solrize> i thought i'd gotten line numbers with other exceptions like head []
04:22:07 <vixey> > head []
04:22:09 <lambdabot>  Exception: Prelude.head: empty list
04:22:14 <solrize> hmm
04:22:28 <vixey> :t head ()
04:22:38 <solrize> how do i tell the ghc command line where to find libgmp ?
04:22:59 <ziman> :t head []
04:22:59 <lambdabot> forall a. a
04:24:10 <thoughtpolice> solrize: for what like linking or header files?
04:24:19 <solrize> linking
04:24:25 <solrize> i don' thave it installed in the usual place
04:24:30 <thoughtpolice> ghc -L/path/to/dir
04:24:33 <solrize> thanks
04:24:40 <solrize> i knew that once before but coulnd't remember it
04:24:42 <thoughtpolice> will add that to dirs to search for libraries
04:24:49 <solrize> worked
04:25:01 <solrize> i can't use runhaskell for this prog because it uses quadratic space
04:25:01 <thoughtpolice> normally i try to set that stuff up in my env. or whatever (os x = DYLD_LOAD_PATH)
04:25:06 <solrize> ghc -O2 gets rid of the space leak
04:25:09 <solrize> it's maddenning
04:25:09 <thoughtpolice> on linux i think it's ldpath or something
04:25:26 <thoughtpolice> yeah, no strictness analyzer without -O2 :(
04:25:46 <solrize> i put in my own strictness annotations all over the place and that didn't fix it
04:26:31 <thoughtpolice> hehe, ghc == winner by fatality
04:27:55 <solrize> hmm maybe still leaking space just less badlyt
04:34:27 <luqui> solrize, maybe strictness isn't the problem
04:38:41 <solrize> well i see the memory consumption go up and up and up in the runhaskell version
04:38:44 <solrize> and say steady with -O2
04:49:04 <vixey> @w80 Hesperus
04:49:05 <lambdabot> *** "Hesperus" wn "WordNet (r) 2.0"
04:49:05 <lambdabot> Hesperus
04:49:05 <lambdabot>      n : a planet (usually Venus) seen at sunset in the western sky
04:49:05 <lambdabot>          [syn: {evening star}, {Vesper}]
04:52:41 <Axman6> vixey: what's @w80 do?
04:53:24 <olsner> @help w80
04:53:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:53:31 <olsner> @help @w80
04:53:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:53:32 <vixey> @whelp h80
04:53:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:54:12 <olsner> oh, so w80 is a misspelled form of the actual command?
04:54:52 <olsner> @wn Hesperus
04:54:52 <lambdabot> *** "Hesperus" wn "WordNet (r) 2.0"
04:54:52 <lambdabot> Hesperus
04:54:52 <lambdabot>      n : a planet (usually Venus) seen at sunset in the western sky
04:54:52 <lambdabot>          [syn: {evening star}, {Vesper}]
04:55:29 <olsner> I think the answer is that wn is the command for looking words up on wordnet
04:56:01 <olsner> the speller should give retorts when activated
05:10:55 <Zao> I must say, Foreign.StablePtr is quite handy.
05:13:12 <olsner> definitely sounds indispensable
05:14:01 <Zao> I was halfway through thinking up some kind of Haskell-side registry when I happened upon it in the docs.
05:16:06 <b\6> what is it called when i do stuff like do foo <- bar? my observation is that if bar is, say, Parser Integer, foo ends up being an Integer.
05:16:29 <olsner> I think it's called "binding"
05:16:32 <vixey> b\9: unboxing, running an action, binding, ..
05:17:12 <b\6> so am i extracting the value from the monad?
05:17:46 <olsner> in IO it would be the moral equivalent of int foo = sideEffectingFunctionBar(), call it what you want :)
05:18:18 <b\6> does some other notation exist if i don't want to use do and <-?
05:18:26 <vixey> >>= \x ->
05:18:35 <olsner> or stop thinking about calling it something and just write the code :D
05:19:15 <b\6> well, i'm in the situation where i need Integer and have Parser Integer. the 'do' way works, but seemed clunky.
05:19:46 <vixey> b\6: Actually there's a whole bunch of different ways to do it
05:26:23 <b\6> i kind of want to be using the ApplicativeParsec stuff from _real world_, but i get a funky error.
05:28:47 <adekoba> I'm trying to download an rss from mail.google.com/mail/feed/atom, but every time I make a request, it redirects me in a recursive circle (i.e. to the same location). How would I go about fixing this? I'm using the http package.
05:29:48 <b\6> weird. what kind of redirect?
05:30:02 <jeffz`> adekoba: if it works for a different rss feed perhaps you're not doing the right dance for gmail.
05:30:25 <adekoba> b\6: 302: Moved Temporarily
05:30:50 <adekoba> jeffz`: I'll try that.
05:32:33 <adekoba> Well, it works for reddit. It must be something to do with gmail.
05:33:23 <b\6> adekoba: can you use wireshark or similar to see exactly what you're asking gmail for? it'd be crazy to ask for x and get back a 302 to exactly x.
05:34:07 <b\6> it'd be like please, entire world, hammer us with pointless requests as fast as you can.
05:34:41 <adekoba> Yeah, well there are recursive limits for most http packages, but I'll try what you suggested.
05:35:00 <adekoba> would tcpdump do the same thing?
05:35:49 <b\6> think so.. it just won't look as nice.
05:35:55 <jeffz`> adekoba: I'm guessing you aren't sending the cookie to auth
05:36:21 <jeffz`> adekoba: I get the same 302 response as you're suggesting if I telnet and make the request by hand
05:37:21 <adekoba> here is a sample response: http://hpaste.org/9483
05:37:43 <adekoba> jeffz`: I'm not quite sure what that is, but I'll look into it
05:38:45 <jeffz`> adekoba: I don't know what you've written in your code, but a cookie probably the part of the request which identifies which rss data google should reply with
05:42:02 <adekoba> jeffz`: alright, I have it set up so my request sends google a cookie, but what would I put in the body of the cookie?
05:43:04 <jeffz`> adekoba: the cookie returned from gmail when you login... ok, as an aside I see that you're using the url of the form http://foo:bar@ -- does the http library understand to use that information to auth?
05:43:24 <adekoba> jeffz`: yes
05:43:42 <profmakx> *grml* note to self: use deriving show for quick and dirty serialisation
05:44:14 <thoughtpolice> the dirtiest.
05:44:37 <profmakx> but it works :)
05:46:57 <profmakx> thoughtpolice: any less dirty proposals?
05:48:55 <EvilTerran> Data.Binary
05:49:35 <EvilTerran> ?hackage binary
05:49:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
05:49:43 <thoughtpolice> binary == win.
05:49:55 <adekoba> jeffz`: google doesn't send any cookie in the response. Also, I just tried the exact url with wget and it seemed to work fine. Here's a pastebin of wget's output: http://hpaste.org/9483#a1
05:50:12 <thoughtpolice> i was thinking of trying something using binary and tibbe's network-bytestring to try and transfer that kind of stuff over the line
05:50:20 <thoughtpolice> haven't gotten around to trying anything yet though
05:50:41 <profmakx> yeah, i wanted to try data.binary next
05:50:53 <profmakx> but for now i just wanted to get the lambdabot-plugin to work
05:51:16 <thoughtpolice> can bytestrings (i.e. created via binary) be sent over the line without worry or are there things to take into account i.e. endian-ness?
05:51:31 <thoughtpolice> i would think not but i am not sure
05:55:54 <wjt> thoughtpolice: glancing at the Data.Binary source, Int* and Word* at least are always (de)serialized in big endian format
05:56:37 <adekoba> jeffz`: aha. I figured out the problem. Gmail requires the request to use ssl, and the HTTP package currently does not support ssl.
05:56:40 <wjt> thoughtpolice: but if you implement your own binary instance then it's up to you to make sure you're consistent, i guesS :
05:56:43 <wjt> :)
05:56:44 <adekoba> jeffz`: thanks for your help.
05:57:26 <jeffz`> adekoba: ah :)
05:57:44 <adekoba> jeffz`: I suppose I could use curl, though.
05:58:29 <vixey> http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl?_total=1&_format=full&_userlink=1
05:58:30 <lambdabot> Title: Dictionary of Programming Languages, http://tinyurl.com/6hwyxe
06:01:36 <thoughtpolice> wjt: good point, thanks
06:06:42 <cnwdup_> > 3 `substract` 1
06:06:45 <lambdabot>   Not in scope: `substract'
06:06:54 <ivanm> > 3 `subtract` 1
06:06:56 <lambdabot>  -2
06:07:01 <cnwdup_> Thanks. ^^
06:07:07 <ivanm> > 3 (-) 1
06:07:08 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
06:07:10 <ivanm> grrr
06:07:13 <ivanm> duh
06:07:18 <cnwdup_> > (-) 3 1
06:07:19 <ivanm> > 3 - 1
06:07:20 <lambdabot>  2
06:07:20 <lambdabot>  2
06:07:39 <ivanm> what's the point of having subtract go the wrong way round?
06:07:42 <ivanm> @src subtract
06:07:49 <lambdabot> subtract x y = y - x
06:07:53 <vixey> > 1 `subtract` 4
06:07:54 <lambdabot>  3
06:08:05 <ivanm> so you can subtract a value from other values?
06:08:15 <vixey> > map (subtract 4) [5,8,4,7]
06:08:16 <lambdabot>  [1,4,0,3]
06:08:18 <cnwdup_> ivanm: Its useful for lambda expressions as I learned the other day.
06:08:19 <ivanm> i.e. "subtract 3" is a function that subtracts 3 from whatever number you pass it?
06:08:28 <ivanm> cnwdup_: yeah, was just thinking that
06:08:57 <ivanm> though I wanted a subtraction function the other day, since I seemed to recall that there's issues with using -... so I thought I'd use subtract :s
06:09:03 <ivanm> lucky I checked what it did first!
06:12:38 <jeffz`> @seen bringert
06:12:39 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 1h 37m 18s ago, and .
06:16:09 <SamB_XP> ivanm: it exists precicely because you can't use (-3) to do that
06:22:13 <solrize> so is there an answer to this general space leak situation?  do experienced haskellers get past it somehow?
06:32:50 <vixey> solrize: I thought garbage collection solved this problem
06:33:04 <solrize> hehe we all wish
06:33:13 <opqdonut> profiling works usually
06:33:21 <solrize> hmm
06:33:31 <vixey> solrize: What does the program do and why is it leaking?
06:33:32 <opqdonut> writing folds explicitly helps too
06:33:45 <opqdonut> also making relevant fields in records strict
06:34:04 <solrize> vixey, the program just reads a bunch of filenames from a directory and moves the files into subdirectories (this is millions of files, so n**2 space is bad)
06:34:15 <solrize> as to why it's leaking, if i knew, i'd fix it :)
06:34:42 <vixey> solrize:  To me
06:34:42 <opqdonut> you're probably keeping the list in memory
06:34:49 <vixey> It sounds utterly bizarre to write that in haskell
06:34:52 <opqdonut> could you paste the code?
06:35:03 <solrize> lemme see
06:35:10 <solrize> sec
06:35:11 <opqdonut> solrize: you're compiling with -O2?
06:35:18 <solrize> yes, -O2 works a lot better
06:35:28 <opqdonut> yeah, strictness analysis
06:35:31 <vixey> solrize: so what do you mean by it leaking?
06:35:39 <Beelsebob> I was quite surprised by how much -O2 gave me actually
06:36:01 <solrize> vixey, leaking = space consumption keeps increasing as the program runs, usually a sign of unevaluated thunks piling up
06:36:32 <vixey> solrize: Should your program run in O(1) space though?
06:36:36 <opqdonut> or references to lists hanging on
06:36:46 <int-e> solrize: yes but you said that it doesn't do that when you compile with -O2, I'd be happy with that.
06:36:47 <opqdonut> or other recursive datastructures
06:36:53 <solrize> vixey, no, it should use O(n) space since it reads in the list of files at the beginning, sorts them and splits them out into bunches
06:37:38 <vixey> solrize: could it be sorting takes up O(n^2) ?
06:37:46 <opqdonut> shouldn't
06:38:02 <solrize> int-e, what this means is even a simple problem like this is difficult to code reliably.  i feel like i've got haskell figured out enough now to express most kinds of computation and use the type system but this space stuff is hard to get a handle on
06:38:03 <vixey> but maybe it does, How could we be sure?
06:38:15 <solrize> vixey, the first thing the program does is read the filenames, sort the list, then print the length of the sorted list
06:38:24 <solrize> that part works ok
06:38:30 <rwbarton> Well, if it only takes O(n log n) time, it's not going to use more than O(n log n) space...
06:38:31 <solrize> then after that, the space usage starts climbing
06:38:42 <vixey> solrize: I would say print out a shell script then
06:38:50 <opqdonut> solrize: could you paste the code please, really can't help more without it
06:39:09 <Beelsebob> rwbarton: why do you say that?
06:39:17 <vixey> rwbarton: Really? I don't understand that
06:39:28 <olsner> because it takes O(n) time to allocate O(n) space?
06:39:34 <Beelsebob> no it doesn't
06:39:34 <opqdonut> mhmm :)
06:39:40 <opqdonut> well not to allocate
06:39:41 <opqdonut> but to use
06:39:47 <vixey> olsner: Does it?
06:39:54 <solrize> opqdonut, yeah, i can put up a paste, but i don't think this specific and rather simple problem will be hard to solve.  i'm just having doubts about my prospects of writing any complex apps in haskell and not having them perform like pigs
06:40:23 <opqdonut> solrize: once you solve a few space leaks you start to get a feel for it
06:41:00 <opqdonut> reasoning about haskell performance is quite straightforward, it's just different than what one is used to
06:42:43 <solrize> http://hpaste.org/9485
06:42:56 <olsner> I'd say allocation doesn't count unless you also use the memory in some way
06:43:56 <Beelsebob> why not?
06:44:02 <vixey> solrize: (=~ "gz$") looks bad..
06:44:07 <Beelsebob> you might "use" the memory for laying things out in it sparsely
06:44:11 <vixey> solrize: shouldn't it have a . ?
06:44:18 <solrize> i suppose so
06:44:38 <solrize> \.
06:44:52 <sw17ch> whenever i see a really wacky type error, it usually means i forgot a function argument....
06:45:19 <Axman6> yeah, usually too few or too many arguments
06:45:23 <vixey> solrize: So what exactly causes the leak and how did you measure it?
06:45:29 <olsner> hmm, someone should formally figure out the theoretical bounds on the relation between time and space complexities
06:45:40 <solrize> vixey i just ran "top" and watched the memory consumption keep increasing
06:45:50 <solrize> i dunno what caused it, i guess i should profile it
06:45:57 <solrize> but with ghc -O2 it is ok
06:46:14 <b\6> too *fast* to leak.
06:46:19 <Axman6> solrize: how bad is your leaking?
06:46:41 <solrize> axman bad enough that i don't think the program can finish on my 4gb machine under runhaskell.  with ghc -O2 it takes about 200mb
06:46:52 <Axman6> i've written an app that easily uses 1.5GB in the first 15 seconds if you give it the right number
06:47:09 <vixey> > 1.5
06:47:15 <lambdabot>  1.5
06:47:24 <Axman6> this is using -O2 too
06:47:59 <opqdonut> solrize: I recommend profiling, or having a look at the core -O2 produces
06:48:00 <olsner> but allocation should at least involve calculating the number of bytes/items to allocate, and there are some lower bound on that... (and it would have to include the allocation of the memory to hold that number!) and then there's figuring out the theoretical lower limit on memory allocation speed
06:48:09 <opqdonut> (reading core files can be a bit intimidating)
06:48:19 <Axman6> interestingly, one of my functions that i expected would be pretty space heavy isn't
06:48:27 <solrize> opqdonut yeah, that approach seems reasonable (profiling, at least), i should get more practiced at it
06:49:01 <opqdonut> Axman6: ghc is pretty good in strictness analysis
06:49:19 <thoughtpolice> solrize: ghc-core is a tremendous help for looking at core output (although it's unix-only right now it seems)
06:50:08 <solrize> i mean, there's all these programs i want to write and i think "it will be cool to use haskell for that", then i think of all the struggle it takes to get stuff through the compiler, but i figure that's just because i'm not that fluent yet and will get better; but this space complexity stuff, i just don't have an answer for, it just seems extremely broken that program failure of this magnitutde can be up to the compiler's whims
06:50:33 <solrize> thoughtpolice yeah i'm running linux and have looked at core output which of course doesn't mean i understand it ;)
06:50:42 <opqdonut> solrize: well it isn't up to the compiler if you don't use optimization ;)
06:50:46 <vixey> solrize: I don't think so, without knowing what the problem is
06:51:13 <olsner> (and I wonder how that changes if the number of bytes to allocate can be lazily calculated... maybe it doesn't even need to be fully calculated until you access the allocated memory - then you'll have something really interesting)
06:52:02 <solrize> haskell is really a heck of a lot better than any other language i've used, at being able to express data invariants with the type system
06:52:23 <solrize> but it all seems wasted if i can make practically no assertions about complexity
06:52:37 <vixey> solrize: You could use ML :)
06:52:42 <rwbarton> Would you rather be able to make practically no assertions about correctness? :)
06:53:20 <solrize> rwbarton, if the program crashes, it is incorrect, including if the crash is caused by running out of memory when it should be O(1)
06:54:01 <solrize> vixey, ML just seems a lot more primitive than haskell
06:54:01 <rwbarton> OK, but then you know the answer is wrong.
06:54:17 <vixey> solrize: which one and why?
06:54:30 <int-e> solrize: here's a theory: =~~ is a small function that builds a regex and then uses matchM to match it. In the compiled version, =~~ gets inlined and the built regexp gets floated out; in the interpreted version that won't happen, I think.
06:54:38 <SamB_XP> solrize: sure, but at least you don't have to worry about thunks eating away at your RAM that way
06:54:46 <solrize> int-e hmm that's interesting
06:55:14 <solrize> int-e no that's not right, the program prints out the length of xs before the space leak occurs
06:55:40 <int-e> solrize: try printing the length of dirs instead
06:55:57 <opqdonut> so it's mkDir
06:56:00 <opqdonut> or the forM
06:56:03 <solrize> samb_xp i saw something about clean, saying that it formal semantics were based on graph rewriting instead of lambda calculus, so that you can reason about complexity better.  i didn't realize that and it sounds very interesting.
06:56:08 <solrize> int-e hmm i'll try that
06:56:33 <vixey> solrize: were you referring to SML, Ocaml? all of them?
06:56:45 <SamB_XP> solrize: well Haskell doesn't even have those
06:57:27 <solrize> vixey, SML and ocaml both seem primitive (not in exactly the same way).  i'm not aware of other ML's.  i haven't tried coding in ocaml or sml either
06:57:40 <vixey> solrize: What do you mean primitive?
06:57:47 <dmhouse> Well, GHC uses a graph rewriting algorithm for evaluation, doesn't it? So no difference.
06:58:02 <SamB_XP> solrize: caml light, but I guess that probably doesn't count as an additional one for this purpose, given that it seems to be a subset of ocaml
06:58:45 <solrize> vixey, ML's type system is much less sophisticated than haskell's.  you have to use "+." for floating point addition, etc
06:58:47 <solrize> SML
06:58:57 <SamB_XP> dmhouse: but Haskell doesn't even have formal semantics
06:58:59 <int-e> solrize: and I suspect that many item names aren't fully evaluated by the groupBy, so they hang on to the compiled regular expression.
06:59:01 <solrize> ocaml has some hack to get around that but it's just as bad underneath
06:59:19 <solrize> int-e hmm that's very interesting, maybe i'll add up all the file name lengths and print out the sum?
06:59:20 <gal_bolle> this is lack of type classes, on the other hand ocaml has objects and variants
06:59:26 <int-e> solrize: not sure though, space leaks /are/ hard to find.
06:59:31 <dmhouse> SamB_XP: why do formal semantics matter? They're only important if your compiler follows them. I.e. what really matters is how the compiler works.
06:59:40 <gal_bolle> ocaml lacks an oleg, for sure
06:59:49 <vixey> solrize: Haskell number system is millions of times worse
06:59:50 <solrize> dmhouse, well here we've got the haskell compiler acting two different ways depending on the flags...
06:59:51 <SamB_XP> yes but a compiler can't even begin to follow formal semantics that don't exist
06:59:52 <mfp> gal_bolle: Oleg does OCaml too
06:59:59 <thoughtpolice> gal_bolle: oleg knows no bounds and does ml/ocaml as well :)
07:00:00 <vixey> :t \list -> sum list / length list
07:00:10 <SamB_XP> solrize: how can it be worse when ML has NONE
07:00:14 <vixey> and lambdabot can't even report type errors..
07:00:31 <vixey> @typ \list -> sum list / length list
07:00:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:00:33 <SamB_XP> oleg does scheme even
07:00:41 <gal_bolle> yes, but his ocaml efforts don't get the same publicityy
07:00:46 <solrize> vixey i didn't realize anything was wrong with haskell numbers except that it uses Ints by default
07:00:55 <Toxaris> yeah, oleg's scheme pages are quite interesting, similiar to olegs <insert topic here> pages
07:00:57 <solrize> haskell has much better concurrency support
07:01:06 <SamB_XP> hmm, I've seen one or two ocaml efforts
07:01:09 <olsner> solrize: every compiler changes behaviour with changing flags... that is, after all, the purpose of the flags
07:01:13 <SamB_XP> oleg has scheme-specific pages?
07:01:20 <solrize> haskell's type system is a lot more interesting (GADT's etc)
07:01:22 <SamB_XP> I always see scheme stuff mixed in with the rest
07:01:41 <SamB_XP> yes, oleg won't be doing computation in scheme's typesystem for some time ;-)
07:01:44 <gal_bolle> has anyone tried to do a jocaml-like over haskell ?
07:01:45 <solrize> olsner, i've never heard of a non-Haskell compiler with a flag to switch between O(n) and O(n**2)  ;)
07:01:54 <Toxaris> http://okmij.org/ftp/Scheme/index.html
07:01:55 <lambdabot> Title: Scheme Programming
07:01:56 <solrize> what's jocaml?
07:02:10 <zachk> prolly jvm bytecode compiler for ocaml
07:02:14 <gal_bolle> an implementation of join-calculus
07:02:25 <SamB_XP> solrize: there's an -On^2 flag ?? what?
07:02:31 <olsner> that's only because other compilers don't have the power to reduce O(n**2) to O(n)
07:02:43 <Toxaris> SamB_XP: but oleg has written a scheme -> syntax rules compiler, which I would count as the equivalent of type hackery
07:02:50 <deufeufeu> hi, I just compiled ghc HEAD and ghci seems to have lost line edition support
07:02:53 <solrize> olsner i think it's the other way, other languages don't have the weirdness to turn O(n) into O(n**2)
07:02:58 <deufeufeu> is it normal ? can i do something ?
07:03:19 <Toxaris> SamB_XP: I'm waiting for the Haskell -> Haskell type hackery compiler :)
07:03:24 <SamB_XP> I wonder why scheme has such complex numeric syntax
07:03:34 <vixey> SamB_XP: It doesn't
07:03:44 <solrize> if i get a little more comfortable with haskell i want to try out agda
07:03:53 <SamB_XP> vixey: tried writing a parser for it?
07:03:59 <vixey> SamB_XP: yes
07:04:02 <thoughtpolice> hm
07:04:14 <thoughtpolice> ghc-core isn't helpful here to see what's exactly changed much between -O2 and no -O2
07:04:15 <SamB_XP> read the relevant parts of R[56]RS?
07:04:20 <vixey> R5RS
07:04:22 <thoughtpolice> since it apparently sticks it in there by default :/
07:04:49 <SamB_XP> hmm, possibly some was semantics
07:05:19 <olsner> are you sure that's not just your subjective experience of the problem? lazy evaluation should only change the constant factor for the worse, while always doing the same or better wrt the asymptotic complexity
07:05:32 <olsner> iirc, that's been proven by someone ;)
07:06:08 <solrize> maybe for the time complexity but the space complexity problem is notorious :)
07:06:49 <Toxaris> a problem with the real-world-applicability of such proofs is that they ignore the impact of memory complexity on actual speed (and correctness even, given limited memory on real machines)
07:07:04 <SamB_XP> olsner: eh?
07:07:17 <Toxaris> if the constant factor is linear in the used memory, it is not really constant :)
07:07:49 <solrize> anyway, thanks, i'll try those suggestions and i guess i'm just venting a bit
07:07:55 <olsner> SamB_XP: or am I bullshitting you all?
07:08:10 <solrize> this stuff is enjoyable and rewarding, it just has frustrations sometimes
07:08:17 <SamB_XP> I thought pure lazy code was proven to be able to attain better-or-equal assymptotic complexity than pure strict code in *all* cases, and strictly better in some cases
07:08:19 <solrize> disciple looks interesting
07:08:32 <olsner> SamB: yeah, that's what I was trying to say
07:08:35 <solrize> samb_xp that's just time complexity
07:08:51 <SamB_XP> solrize: oh
07:09:15 <SamB_XP> oh yeah you did say that ;-P
07:09:28 <solrize> anyway i gotta go, thanks all
07:09:29 <solrize> later
07:09:41 <SamB_XP> the "only" threw me off
07:09:53 <Toxaris> SamB_XP, olsner: not only better complexity, but less-or-equal number of reductions steps, I think
07:10:27 <Toxaris> but the individual reduction step may be more costly given some real-world-implementation
07:11:11 <Toxaris> but I don't see a reason it couldn't be cheaper for some other real-world-implementation
07:15:03 <Axman6> anyone used ghc-core?
07:15:28 <Axman6> Toxaris: hey, i've managed to make my binary tree thing wuite a bit faster :)
07:15:42 <Toxaris> cool, what did you do?
07:16:27 <Axman6> well, for one, i wrote my functions the way they should've been (i was using num `mod` 10 instead of num `div` 10 like i should have)
07:16:41 <Axman6> i wondered why i could never get to 7
07:17:50 <Peaker> how could laziness yield worse time complexity than strict?  At worst, you do all the stuff that the strict implementation does.. Or are the time complexities of thunk allocations/deallocations included?
07:19:22 <Igloo> The hunk alloc/dealloc won't change the time complexity
07:19:34 <Igloo> What can do is the amount of work the GCer has to do
07:19:41 <int-e> solrize: with http://hpaste.org/9485#a1 I see no significant change in the memory usage after the length of xs was printed
07:20:14 <b\6> can i use the <*> defined in parsec3 Text/Parsec/Prim.hs?
07:20:19 <Peaker> when SamB_XP says: "pure lazy code was proven to be able to attain better-or-equal assymptotic complexity than pure strict code in *all* cases" -- is the proof referring to the GC stuff?
07:20:35 <int-e> solrize: on the other hand even with your original code I see nowhere near the quadratic memory usage that you claimed. (maybe because my test only has groups of size 1)
07:20:55 <Igloo> No, I'm pretty sure that that ignored the GCer
07:21:36 <Axman6> Toxaris: would you like to have a look?
07:21:47 <Toxaris> sure why not.
07:22:45 <Axman6> http://hpaste.org/9486
07:23:13 <Axman6> i added a findPath function too
07:23:24 <Axman6> which i probably shoulf've done to begin with
07:23:24 <Toxaris> Axman6: IIRC yesterday people have posted very cool solutions to your problem here, you may want to check the logs
07:23:55 <Axman6> i remember some Map stuff, but it was 4AM at the time, so i left that ;)
07:25:09 <Axman6> it's still quite memory hungry though
07:26:34 <Toxaris> Axman6: I think this will calc (size right) twice: (size right) `par` (size left) + (size right) + 1
07:27:12 <Toxaris> Axman6: I would write (let {l = size left; r = size right} in r `par` l + r + 1
07:27:14 <Axman6> well it's supposed to spark it in parallel if it can, but i see no signs of it doing so.
07:27:21 <Saul__> How would I make/derive an instance of Typeable for a type I don't know the constructors for (they aren't exported)?
07:27:31 <Axman6> ok, i'll try that :)
07:27:53 <Toxaris> Axman6: but I have no clue how to use par correctly actually
07:28:22 <Axman6> yeah, i can't seem to figure it out, even with the simple fib stuff i've read using it
07:29:00 <solrize> int-e oops i was away for a while, hmm
07:29:23 <vixey> what does it mean if svn just doesn't print anything :/
07:29:27 <solrize> bbl
07:29:39 <Axman6> vixey: did it exit?
07:29:57 <Axman6> Toxaris: heh, ok, that seems to have made it a lot faster
07:30:33 <Toxaris> Axman6: really? cool!
07:30:55 <Toxaris> Axman6: with your code, size right was calculated, but thrown away and recalculated again on the right side
07:31:07 <Toxaris> Axman6: expressions are only shared if you give them a name and use this name
07:31:08 <Axman6> ah, i see
07:33:02 <SamB_XP> Toxaris: what about CSE?
07:33:17 <Toxaris> SamB_XP: Is there CSE?
07:33:46 <Toxaris> but maybe s/only shared/only guarantueed to be shared/
07:34:42 <SamB_XP> is that guarenteed even then?
07:34:59 <Toxaris> oh that is written like this? oups
07:35:03 <Toxaris> I have no clue
07:35:14 <Toxaris> "more likely to be guaranteed" then?
07:35:21 <SamB_XP> don't look to me for spelling tips
07:35:27 <SamB_XP> yeah
07:35:27 <Saul__> How would I make/derive an instance of Typeable for a type I don't know the constructors for (they aren't exported)?
07:35:38 <Toxaris> but I would expect that ghc doesn't destry sharing I explicitly set up with a let
07:37:06 <Toxaris> Saul__: I guess you aren't supposed to, but maybe you can "invent" constructor names, types and implementations so that you come up with a Typeable representation which is isomorphic to the data type
07:37:13 <SamB_XP> hmm, well, it might inline things if the primitive heuristics it uses give it sufficient reason to believe it might somehow help
07:37:38 <Toxaris> sounds reasonable
07:37:42 <SamB_XP> Saul: isn't Data the one that has to with the constructors?
07:38:21 <Saul__> Toxaris: I'm not sure how that would work, could you elaborate?
07:38:48 <Toxaris> Saul__: me neither :)
07:38:52 <rwbarton> Saul__: does a standalone deriving work in this case?  "deriving Typeable for Foo"
07:39:11 <Saul__> SamB_XP: Maybe, but the problem mainly is that you can't use standalone deriving if not all constructors are in scope
07:39:18 <Saul__> rwbarton: No, see above
07:39:44 <rwbarton> Oh, OK.  (There's approximately no documentation about it in the ghc manual)
07:40:47 <Axman6> what are #'s used for in haskell. i'm looking at the base/GHC/Int.hs file, and they're everywhere
07:41:09 <Saul__> Axman6: I think it has to do with embedded C code
07:41:23 <Axman6> hm, ok
07:41:49 <rwbarton> Axman6: magic builtin stuff
07:41:50 <Axman6> things like fromInteger (S# i#)    = I8# (narrow8Int# i#)
07:42:15 <Igloo> # isn't anything special, it's just a naming convention for low-level (unboxed) stuff
07:42:57 <rwbarton> I think S# is the constructor for Integers that are sufficiently small
07:42:59 <Igloo> That could just as well have been written fromInteger (SmallInteger i)    = I8 (narrow8Int i)
07:43:01 <Axman6> what is unboxing anyway. i see the word used around the place, and don't know what it does
07:43:06 <Saul__> rwbarton: I also tried implemting it myself, but then the problem is that TypeRep also hides it's contructors and there aren't any functions to make one (at least not without having others)
07:43:18 <jeffz`> Axman6, http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
07:43:20 <lambdabot> Title: 8.2.�Unboxed types and primitive operations, http://tinyurl.com/y59rbr
07:43:32 <Axman6> heers
07:43:34 <Axman6> c*
07:43:55 <Toxaris> Saul__: instance Typeable AbstractType where typeOf _ = mkTypConApp (mkTyCon "AbstractType") []
07:44:45 <Saul__> Toxaris: ah thanks
07:45:01 <Toxaris> Saul__: but make sure that the string is unique application-wide
07:46:00 <Saul__> And if I have constructors, I will need to use typeOf to get those TypeReps and put them in the list right?
07:46:07 <Toxaris> Saul__: no
07:46:20 <Toxaris> Saul__: Typeable is unrelated to data constructors
07:46:59 <Saul__> oh wait, that is for higher kinded types?
07:47:08 <Toxaris> indeed
07:49:18 <Toxaris> oh and you may need to make sure that mkTyCon is called exactly once
07:49:44 <Toxaris> hmm no the string is cached
07:50:38 * Toxaris is confused by the comment about CAFs in http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Typeable.html#mkAppTy
07:50:39 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5l2oyh
07:50:55 <Axman6> ok, possibly silly question: say you'd written a program than when run, didn't perform any IO (Excep showing the result), and had a definite result, why not compute that result at compile time, and just produce a binary that gave the result?
07:51:19 <Toxaris> Axman6: compilers try to do that
07:51:32 <Axman6> seems far more efficient to only do the computation once. (and yes, i see how that sort of program isn't all that useful)
07:51:55 <Toxaris> Axman6: but they sometimes fail because they are not clever enough to see that the program terminates
07:51:56 <dmhouse> Axman6: how do you know whether it has a definite result? ;)
07:52:01 <Saul__> Toxaris: Thanks, that seems to work (although now I will need to do the same for other types as well)
07:52:10 <dmhouse> This is known as the 'Halting problem', a classic case of undecidability.
07:52:18 <Toxaris> Axman6: note the difference between terminating at compile-time and terminating at run-time
07:52:18 <Axman6> ah yes
07:52:28 <Toxaris> s/terminating/non-terminating/g
07:53:38 <Axman6> dmhouse: wouldn't it be possible to check if it would in haskell?
07:53:47 <baaba> @pl \m f g -> m >>= \x -> f x >>= return (g x y)
07:53:47 <lambdabot> (. ((. ((return .) . flip flip y)) . liftM2 (>>=))) . (.) . (>>=)
07:54:01 <rwbarton> If you *want* to do the computation at compile time, turn on UndecidableInstances, read some Oleg papers, and go wild :)
07:54:10 <dmhouse> Axman6: no, why would it be?
07:54:11 <Axman6> heh
07:54:27 * Toxaris is still waiting for a Haskell->Haskell Typesystem compiler :)
07:54:27 <Axman6> couldn't you follow the path of execution?
07:54:38 <wjt> "follow the path of execution" == "run it"?
07:54:39 <dmhouse> What if it didn't finish?
07:54:53 <dmhouse> The point is to find out _in finite time_ whether it terminates.
07:54:55 <Axman6> dmhouse: ^C :)
07:55:00 <Axman6> yeah
07:55:09 <Toxaris> Axman6: well, let's say the path of execution didn't lead you to a result after 354 years of following it. do you stop or run for another 143 years?
07:55:46 <dmhouse> Yeah, there's also the practicality issue, even if you could solve the halting problem.
07:55:50 <Axman6> i'm going to ignore the fact that i'd be dead long before that time
07:55:55 <dmhouse> Finite can be a very long time.
07:55:59 <Axman6> anyway, i have my answer
07:56:31 <Toxaris> Axman6: and note that most programs *do* read some input, so such an optimization would not have real impact
07:56:52 <Toxaris> Axman6: and note that running a compiled program is faster then letting the compiler interpret the program
07:56:59 <Axman6> reminds me of something i read (possibly on bash.org?) where a guy had written a program to compute pi to a few million places, or more, and left it running for 4 years on his laptop. then one day it finished
07:57:02 <gwern> Axman6: this is an entire field of specialization and partial evaluation
07:57:10 <gwern> may want to read the existing literature
07:57:10 <Toxaris> Axman6: so it is faster to compile, then run once, and store the result in a file for further uses
07:57:17 <SamB> Axman6: foolish man
07:57:19 <Axman6> which was when he realised he'd forgotten to get the program to produce any output
07:57:24 <SamB> he should have set it to compute them all
07:57:38 <SamB> (... and print them as it went)
07:57:49 <atp> SamB: or just the last digit of pi, that would be good, i'd like to know which digit it is.
07:58:20 <Axman6> atp: ask i've heard that chuck norris will tell you is you ask nicely
07:58:21 <SamB> atp: ah, but what I said would be a potentially-useful program
07:58:21 <Toxaris> hmm maybe "lazy program execution" would be an option, where constant parts in an executable are overwritten with constants after the first execution
07:58:36 <SamB> what you said would be _|_, plain and simple
07:58:38 * Axman6 is betting on 1
08:00:31 <Axman6> oh, would any you like to see the birthday card i wrote for my friend in haskell?
08:01:05 <Toxaris> > last (show pi) -- easy
08:01:07 <lambdabot>  '3'
08:01:17 <Botje> lol
08:01:47 <Axman6> http://hpaste.org/9488
08:02:00 <Axman6> > show pi
08:02:02 <lambdabot>  "3.141592653589793"
08:02:09 <Axman6> heh, ok then
08:02:33 <Axman6> @hoogle pi
08:02:34 <lambdabot> Prelude.pi :: Floating a => a
08:02:34 <lambdabot> Data.Time.Clock.picosecondsToDiffTime :: Integer -> DiffTime
08:02:34 <lambdabot> Data.Fixed.Pico :: type Pico
08:03:09 <siponen> Anyone here going to ItaloHaskell?
08:03:27 <dmhouse> > pi :: Double
08:03:29 <lambdabot>  3.141592653589793
08:03:32 <dmhouse> > pi :: Float
08:03:33 <lambdabot>  3.1415927
08:03:35 <siponen> And possibly passing Pisa on the way? :)
08:03:39 <dmhouse> > pi :: Rational
08:03:40 <lambdabot>   add an instance declaration for (Floating Rational)
08:03:40 <lambdabot>     In the expression: ...
08:03:43 <sw17ch> @src pi
08:03:43 <lambdabot> Source not found. There are some things that I just don't know.
08:03:46 <Axman6> > pi :: Complex
08:03:46 <lambdabot>      `Complex' is not applied to enough type arguments
08:03:47 <lambdabot>     Expected kind `?',...
08:03:51 <Axman6> > pi :: Complex Double
08:03:52 <dmhouse> ?instances Floating
08:03:52 <lambdabot>  3.141592653589793 :+ 0.0
08:03:52 <lambdabot> Double, Float
08:04:05 <dmhouse> ?instances-importing Data.Complex Floating
08:04:06 <lambdabot> Complex a, Double, Float
08:04:19 <Axman6> > (-pi)**0.5 :: Complex Double
08:04:20 <lambdabot>  1.0852791238379178e-16 :+ (-1.772453850905516)
08:04:31 <sw17ch> it cleared up a bunch of stuff for me :)
08:04:39 <sw17ch> dmhouse: ^
08:05:19 <Axman6> there should be a higher precision pi somewhere
08:05:21 <Toxaris> why is pi in Floating?
08:05:31 <dmhouse> sw17ch: the fix article?
08:05:38 <Axman6> Toxaris: why not?
08:06:01 <sw17ch> dmhouse, yes
08:06:02 <Toxaris> Axman6: because other numeric types can approximate pi, too
08:06:03 <dmhouse> Axman6: define a higher-precision instance of Floating, and you're good to go.
08:06:59 <Toxaris> oh the documentation of Floating is: "Trigonometric and hyperbolic functions and related functions. "
08:07:09 <Toxaris> then pi should live their, of course
08:07:15 <Toxaris> s/their/there/
08:09:08 <Toxaris> but why does Data.Fixed.Fixed not instantiate Floating, then?
08:10:43 <chylli> I want to take a substring from a string to "\r\n\r\n", how to get it ?
08:11:42 <SamB> chylli: I suspect it's not a string at all but rather a stream of bytes
08:12:05 <chylli> SamB: right,
08:12:17 <chylli> that string is from hGetContetns handle
08:12:34 <SamB> ... you wouldn't rather use an HTTP library?
08:13:09 <chylli> SamB: sorry ? what's the meaning ?
08:13:32 <SamB> you mean you aren't writing an HTTP client?
08:13:52 <int-e> > (map head . takeWhile (not . isPrefixOf "\r\n\r\n") . init . tails) "ABC\r\nDEF\r\n\r\nHIJ"
08:13:53 <lambdabot>  "ABC\r\nDEF"
08:14:18 <chylli> SamB: no, I just want to write a http proxy
08:14:32 <SamB> chylli: that counts as both client and server though
08:14:34 <chylli> int-e: thanks very much.
08:14:58 <chylli> SamB: I think it is simpler than client or server.
08:15:16 <chylli> SamB: It just forward request and response.
08:16:18 <chylli> int-e: how to enhance my ability of writing the idoim of haskell ?
08:16:39 <int-e> absorb one-liners on #haskell ;)
08:16:57 <chylli> :p
08:16:58 <SamB> int-e: ... right!
08:17:15 <SamB> chylli: chip in on some projects?
08:17:19 <olsner> that's my approach, to achieve haskell mastership by mere exposure to #haskell
08:17:49 <int-e> read through the standard prelude (from the report, the actual implementation is less readable), read other people's code, write your own code, and try to discover the embedded folds, then refactor, etc.
08:18:03 <chylli> SamB: I think its difficult to me to read a complex project.
08:18:51 <chylli> SamB: BTW, how do u know i'm writing something like http client ?
08:19:38 <SamB> chylli: well, the "\r\n\r\n" was a major hint that it was either that or RFC 822
08:19:48 <olsner> looking for \r\n\r\n is a tell-tale sign :)
08:22:40 <chylli> thanks. I just want to write a simple proxy to improve my haskell coding.
08:24:22 <chylli> question. what's the difference between string and bytestring ?
08:25:08 <sw17ch> ByteSting packs the data like a CString would, a String is a linked list of Char's
08:25:17 <sw17ch> > ['a','b','c']
08:25:18 <lambdabot>  "abc"
08:25:28 <sw17ch> chylli, ^^
08:27:09 <chylli> oh, ByteString has a different way to store string, isn't it ?
08:27:19 <mfp> chylli: BS is what you want to use from the moment you do any sizeable amount of string processing if you don't want sky-high memory usage
08:27:24 <SamB> also ByteString.Word8 is unambiguously about bytes -- you will never have to worry about your bytes being interpreted as text in some encoding or other with ByteString.Word8
08:28:06 <SamB> (or is that just called ByteString ?
08:28:18 <SamB> well, the one where pack takes [Word8], anyway
08:28:56 <chylli> thanks, but  I still don't know the difference of Word8 with Char :(
08:29:13 <Axman6> did any check out my birthday card? http://hpaste.org/9488
08:29:21 <SamB> well Char represents Unicode codepoints
08:29:48 <SamB> Word8 represents numbers from 0 through 255
08:30:04 <SamB> (there are obviously a lot more of the former ;-)
08:30:38 <jeffz`> Axman6: I looked, thought you might have created a PDF birthday card in Haskell
08:31:04 <Axman6> jeffz`: i did :)
08:31:09 <Axman6> oh, wait, no
08:31:12 <chylli> SamB: thanks. another question. ghc support utf8, but why I don't print utf8 string directly ? like
08:31:17 <chylli> putStrLn "你好"
08:31:28 <SamB> Axman6: there's something wrong with your rot13 implementation
08:31:30 <Axman6> > putStrLn "你好"
08:31:32 <lambdabot>  <IO ()>
08:31:44 <Axman6> SamB: the fact that it's not rot13 maybe?
08:32:05 <SamB> chylli: well, I think GHC still just outputs the low bytes ...
08:32:31 <dmhouse> Axman6: not very obfuscated ;)
08:32:33 <SamB> it's really not clear how the I/O is supposed to work
08:32:45 <Axman6> dmhouse: not supposed to be really
08:32:57 <SamB> the report doesn't really address endodings :-(
08:33:06 <dmhouse> Axman6: oh, why all the reversings then?
08:33:16 <Axman6> to confuse him
08:33:21 <Axman6> but not make it unreadable
08:33:24 <Saul__> Toxaris: I have a higher kinded datatype which I need to make an instance of Typeable (presumably Typeable1), how do I do that?
08:33:27 <SamB> IMO, the only reason Char is supposed to represent Unicode codepoints is because it didn't take any more space than just ASCII
08:33:29 <dmhouse> Btw, best obfuscated program ever: http://perl.plover.com/obfuscated/
08:33:30 <lambdabot> Title: Obfuscated Perl Program
08:33:44 <Axman6> i'll get him to tell me what the output will be before he opens it
08:34:05 <qwr> only thing is that you'll lose pattern matching on (byte)strings and have trouble with giving string literals to the bytestring functions...
08:34:39 <SamB> since 24 bits and 8 bits both round up to the same size in words?
08:34:44 <SamB> you know?
08:35:04 <qwr> so nice choice between uncomfortable strings and hellish memory waste
08:35:06 <chylli> 32 bit words ?
08:35:29 <SamB> chylli: well, not 16-bit ones obviously
08:35:36 <chylli> hehe
08:35:37 <chylli> thanks
08:35:53 <chylli> you all help me too much
08:35:57 <SamB> you can't seriously believe Haskell was ever usable on 16-bit systems ;-)
08:36:04 <dmhouse> Who pattern matches strings?
08:36:23 <qwr> dmhouse: I. damn comfortable for simple parsing
08:36:27 <chylli> now let me read int-e's code carefully.
08:36:32 * SamB would pattern match string prefixes
08:36:38 <Toxaris> dmhouse: I do so for argument processing
08:36:55 <SamB> )if there was syntax for it :-(
08:36:59 <dmhouse> > let foo 't':'h':'i':'s':' ':'i':'s':' ':'p':'a':'i':'n':'f':'u':'l':[] = 5 in foo "this is painful"
08:36:59 <lambdabot>  Parse error in pattern at "in" (column 76)
08:37:31 <qwr> SamB: there is. { foo ("bar":_) = 33; foo _ = 42 }
08:37:46 <qwr> hmm. err
08:37:46 <SamB> qwr: that's not a prefix, that's a head
08:38:02 <qwr> yes you have to use chars
08:38:18 <qwr> tail could be matched that way
08:38:22 <b\6> with parsec, can i read an integer, read something i ignore, then read a string with 'count' using the integer using >>= style? right now i'm doing dumb 'do'/<- style.
08:38:30 <qwr> but it would special case
08:38:34 <EvilTerran> ?src dropPrefix
08:38:35 <lambdabot> Source not found. There are some things that I just don't know.
08:38:39 <EvilTerran> ?type dropPrefix
08:38:41 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:38:47 <EvilTerran> ... what's it called, theN?
08:38:49 <Toxaris> b\6: you can do everything with >>= what is done with do, since do is translated to >>=
08:38:54 <EvilTerran> ?src stripPrefix
08:38:54 <lambdabot> Source not found. Maybe you made a typo?
08:39:06 <EvilTerran> ?type stripPrefix
08:39:06 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
08:39:08 <EvilTerran> there we go
08:39:10 <SamB> b\6: sadly there is no generally-accepted name for the function you'd use for that
08:39:14 <qwr> b\6: i can't bother thinking about the parsec lib every time i want to something stupidly simple
08:39:31 <SamB> b\6: which would not necessarily have anything to do with Parsec
08:39:48 <SamB> (it makes sense in any monad)
08:40:01 <EvilTerran> that's what you use instead of 'p':'r':'e':'f':'i':'x':str
08:40:07 <rwbarton> @type (<*) -- b\6: this might be useful
08:40:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:40:11 <qwr> SamB: but you can use isPrefixOf for matching longer  prefix...
08:40:12 <Toxaris> b\6: do {theInt <- parseInt; parseSomething; useTheInt theInt} is theInt >>= \theInt -> parseSomething >> useTheInt theInt
08:40:15 <olsner> > let foo ('t':'h':'i':'s':' ':'i':'s':' ':'p':'a':'i':'n':'f':'u':'l':[]) = 5 in foo "this is painful"
08:40:16 <lambdabot>  5
08:40:19 <SamB> that function being, of course, (\p q -> do x <- p; q; return x
08:40:23 <SamB> )
08:40:42 <SamB> (I'm not sure that will actually parse ;-)
08:40:52 <Toxaris> SamB: you are talking about <*
08:41:02 <Toxaris> SamB: works like >>, but returns the result of the left action
08:41:06 <SamB> Toxaris: is that available on all Monads?
08:41:16 <EvilTerran> > let foo str = case stripPrefix "this is painful" str of Just str' -> str'; Nothing -> "" in foo "this is painful!"
08:41:17 <lambdabot>  "!"
08:41:18 <SamB> I don't know much about Applicative
08:41:24 <EvilTerran> that's a bit less painful
08:41:32 <Toxaris> SamB: nope, on all Applicative's, but you can make every Monad an Applicative, and most should already be
08:41:55 <EvilTerran> x <* y = do r <- x; y; return r -- for Monads
08:41:59 <SamB> Toxaris: yes but it's not exactly the same as with Functor where you can file an out-and-out bugreport if it isn't
08:42:05 <EvilTerran> if you prefer, (<*) = liftA2 const
08:42:17 <EvilTerran> (that may even be how it's defined)
08:42:29 <olsner> @index (<*)
08:42:29 <lambdabot> bzzt
08:42:36 <SamB> @src (<*)
08:42:37 <lambdabot> (<*) = liftA2 const
08:42:47 <SamB> @hoogle (<*)
08:42:47 <lambdabot> Control.Applicative.(<*) :: Applicative f => f a -> f b -> f a
08:42:47 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:42:47 <lambdabot> Control.Applicative.(<**>) :: Applicative f => f a -> f (a -> b) -> f b
08:42:48 <rwbarton> Oh yeah, I seem to recall asking this exact question before and then discovering that Parser isn't defined as an Applicative :(
08:43:12 <b\6> well, <*> is in parsec3.
08:43:18 <b\6> but i can't seem to use it.
08:43:19 <rwbarton> Of course, it only takes about 3 lines to fix that
08:43:33 <SamB> @tell ndm wow, hoogle actually understood a query for an infix name for once!
08:43:33 <lambdabot> Consider it noted.
08:43:43 <Toxaris> SamB: why not? Applicative is in base, after all
08:43:44 <qwr> dmhouse: anyway, some example of the string pattern match... bindArg in http://github.com/mth/hirc/tree/master/HircBot.hs
08:43:45 <lambdabot> Title: HircBot.hs at master from mth's hirc — GitHub
08:43:52 <SamB> Toxaris: eh?
08:44:00 <SamB> why not which -- file a bug report or hoogle work?
08:44:08 <Toxaris> Samb: why not file a bug report
08:44:25 <SamB> ah. well, against things from ghc-hq I guess you could
08:44:26 <olsner> http://haskell.org/hoogle/?q=(%3C*) it works on web-hoogle too
08:44:27 <lambdabot> Title: (<* - Hoogle
08:44:38 <rwbarton> You don't even need the parentheses
08:44:47 <dmhouse> qwr: well, yes, it does exist, but you so rarely do heavy pattern matching on strings I don't think it's too much of a loss.
08:44:53 <SamB> olsner: ISTR it having major issues with infix name queries in the past
08:44:54 <dmhouse> It'll mean nothing once views are commonplace.
08:44:57 <olsner> or maybe web-hoogle has been updated to the latest hoogle version now
08:45:09 <b\6> whoogle.
08:45:11 <Toxaris> SamB: I guess you can file as many bug reports as you want :) and if you provide a patch, I would guess that most projects would accept it.
08:45:19 <SamB> I'm attempting to give ndm encouraging feedback ;-)
08:45:53 <SamB> Toxaris: how many weeks later?
08:46:26 <Toxaris> SamB: :) that's the reason I keep an Instances.hs with my projects which contain such "should be defined by library" instances
08:46:54 <bwr> \pl \(x,(y,n))->(y,(x+y,n+1))
08:47:05 <bwr> @pl \(x,(y,n))->(y,(x+y,n+1))
08:47:06 <lambdabot> uncurry ((`ap` snd) . (. fst) . liftM2 (.) (,) . flip flip (1 +) . (((.) . (,)) .) . (+))
08:47:39 <Toxaris> SamB: but it's no reason not to use Applicative
08:47:52 <dmhouse> I think we should have a @pl competition. Maximise length output - length input.
08:48:00 <bwr> dmhouse: lol
08:49:24 <Axman6> @pl something x = something $ (last x) : (init x)
08:49:25 <lambdabot> something = fix (. liftM2 (:) last init)
08:49:47 <Axman6> > fix (. liftM2 (:) last init) [1,2,3]
08:49:47 <qwr> also, mixing bunch of different and somewhat incompatible string types is recipe for mess. I have sad memorys about C++ app which mixed "happily" null-terminated strings, std::string and Qt::QString... and then converted them around every corner.
08:49:50 <lambdabot>  Tried to use too much memory
08:50:02 <dmwit> Axman6: That's an infinite loop.
08:50:12 <Axman6> it was supposed to be :)
08:50:17 <dmwit> ok =)
08:50:27 <qwr> my attempts to use ByteStrings are often looked somewhat similar with pack/unpack mess
08:50:28 <Axman6> i call it halt
08:50:48 <Axman6> it's how i find an answer to the halting problem
08:50:58 <Axman6> it never really halts, but it certainly does stop :P
08:51:38 <dmwit> There *are* solutions to that equation.
08:51:49 <dmwit> For example, something [1, 1] = [1, 1].
08:51:53 <chrisdone> what's that function to return a list sans its last element?
08:51:56 <Axman6> > fix (. liftM2 (:) last init) [1]
08:51:58 <lambdabot>  Tried to use too much memory
08:52:00 <Toxaris> chris2: init
08:52:02 <dmwit> chrisdone: init
08:52:02 <Axman6> > fix (. liftM2 (:) last init) [1, 1]
08:52:04 <lambdabot>  Tried to use too much memory
08:52:08 <chrisdone> ah, thanks
08:52:09 <Toxaris> hmm wrong chris :(
08:52:17 <dmhouse> dmwit: also something _|_ = _|_
08:52:36 <dmwit> yep
08:52:40 <chrisdone> > init []
08:52:42 <lambdabot>  Exception: Prelude.init: empty list
08:52:47 <chrisdone> just checking
08:52:53 <dmwit> Axman6: It's still an infinite loop.  But at each stage of the loop, the "answer" (argument) is the same.
08:53:02 <Axman6> yeah
08:53:10 <dmwit> > iterate (liftM2 (:) last init) [1, 1]
08:53:10 <lambdabot>  [[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,...
08:53:47 <Axman6> > fix (. liftM2 (:) last init) [1..]
08:53:49 <lambdabot>  Tried to use too much memory
08:53:53 <Axman6> mwaha
08:53:56 <dmwit> That's easy:
08:53:58 <dmwit> > last [1..]
08:54:00 <lambdabot>  Tried to use too much memory
08:54:22 <dmwit> > last [1..] :: Int
08:54:28 <lambdabot>  Exception: Time limit exceeded
08:54:32 <dmwit> > last [1..] :: Char
08:54:33 <lambdabot>   add an instance declaration for (Num Char)
08:54:33 <lambdabot>     In the expression: 1
08:54:38 <dmwit> oops
08:54:40 <Axman6> dmwit: the difference is that with mine, if it ever does find the last element of [1..] it'll keep doing ;)
08:54:42 <dmwit> > last [minBound..] :: Char
08:54:43 <lambdabot>  '\1114111'
08:54:47 <bwr> @pl \[x,y]->[y,x+y]
08:54:47 <lambdabot> (line 1, column 2):
08:54:47 <lambdabot> unexpected "["
08:54:48 <lambdabot> expecting pattern
08:55:11 <dmwit> ?pl \(x, y) -> (y, x+y)
08:55:11 <lambdabot> uncurry (ap (,) . (+))
08:55:22 <bwr> why doesn't it work with []
08:55:31 <dmwit> pl doesn't do arbitrary pattern matches.
08:55:37 <bwr> ah
08:55:45 <dmwit> (It's not really possible to ?pl arbitrary matches in general.)
08:55:54 <rwbarton> @pl \(a,b,c) -> a + b + c
08:55:54 <lambdabot> (line 1, column 6):
08:55:54 <lambdabot> unexpected ","
08:55:54 <lambdabot> expecting letter or digit, operator or ")"
08:55:54 <lambdabot> ambiguous use of a non associative operator
08:55:57 <BONUS_> fst &&& uncurry (+)
08:56:17 <dmwit> BONUS_: I like it. =)
08:56:22 <BONUS_> (snd &&& uncurry (+))
08:56:23 <BONUS_> that is :]
08:57:03 <Axman6> @pl (snd &&& uncurry (+))
08:57:03 <lambdabot> snd &&& uncurry (+)
08:57:10 <Axman6> fine
08:57:18 <dmhouse> Axman6: it's already pointsfree ;)
08:57:28 <Axman6> yeah
08:57:32 <dmwit> ?pl  \xs -> [xs !! 1, head xs + xs !! 1]
08:57:32 <chrisdone> Axman6: what you were trying to do is pointless
08:57:32 <lambdabot> liftM2 (:) (!! 1) (return . liftM2 (+) head (!! 1))
08:57:47 <dmwit> bwr: There you go; if you're set on using lists... =)
08:57:47 <Axman6> chrisdone: hence the use of @pl ;)
08:58:09 <bwr> dmwit: i'm not, i was just curious why it didn't work
08:58:10 <chrisdone> Axman6: yes.. @_@
08:58:21 <Axman6> pl == pointless
08:58:34 <chrisdone> Axman6: what I said was a joke, oh wel
08:58:50 <dmwit> ?ty \f g -> liftM2 (:) f g
08:58:51 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
08:58:57 <Axman6> oh, well,... it's 2am, give me a break :P
08:59:09 <dmwit> Oh, that return is in the [] monad.
09:00:58 <bwr> @pl \c r -> foldr(.)(scanl(+)1)([1..c]>>[scanl(+)0])[2..]!!(2*(1+c)+r)
09:00:58 <lambdabot> ap ((.) . (!!) . flip (foldr (.) (scanl (+) 1) . (>> [scanl (+) 0]) . enumFromTo 1) [2..]) ((+) . (2 *) . (1 +))
09:01:44 <chrisdone> :t (<<)
09:02:35 <dmwit> :t foldr
09:02:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:02:56 <chylli> @src tails
09:02:56 <lambdabot> tails []         = [[]]
09:02:56 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:03:06 <dmwit> :t foldr (.)
09:03:06 <chylli> @hoogle tails
09:03:06 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
09:03:07 <lambdabot> Data.List.tails :: [a] -> [[a]]
09:03:08 <lambdabot> Data.ByteString.tails :: ByteString -> [ByteString]
09:03:08 <lambdabot> Data.ByteString.Char8.tails :: ByteString -> [ByteString]
09:03:17 <chylli> @hoogle isPrefixOf
09:03:18 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:03:19 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
09:03:21 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
09:03:58 <dmwit> bwr: [1..c]>>x = repeat c x
09:04:07 <bwr> dmwit: thanks
09:04:11 <dmwit> err
09:04:14 <dmwit> replicate c x
09:04:19 <bwr> that's longer though
09:04:32 <dmwit> Wait, who golfs *Haskell*??
09:04:39 <bwr>  :P
09:04:50 <bwr> why not
09:05:24 <dmwit> D=
09:05:53 <zx]treads> hello, i'm trying to reproduce the results from dons test: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core but to no avail
09:05:55 <lambdabot> Title: Haskell hacking
09:07:05 <zx]treads> i am using a dual core machine and it seems to run slower when -threaded
09:07:47 <bd_> you passes +RTS -N2 to the application, right?
09:07:57 <zx]treads> y, i follow the exact instructions
09:08:07 <zx]treads> has any1 else tried the examples?
09:08:24 <zx]treads> when i run with no -threaded i get better results
09:08:36 <Axman6> i've tried to use -N2 before, and it told me there was no -N option
09:08:53 <Axman6> when using -threaded
09:08:54 <zx]treads> Axman6: u have to compile with -threaded option i think
09:09:00 <EvilTerran> dmwit, i've golfed haskell many times in here
09:09:17 <dmwit> Okay, okay, I admit it's a reasonable thing to do.
09:09:25 <encryptio> Axman6: are you sure you're passing +RTS -N2 to the compiled application (not the compiler)?
09:09:35 <Axman6> ydes
09:09:37 <Axman6> -d
09:09:45 <BONUS_> does anyone have a link to that graph which displays all the numeric typeclasses
09:09:48 <BONUS_> and how they're connected
09:10:03 <vixey> ?where report
09:10:04 <lambdabot> http://www.haskell.org/onlinereport/
09:10:07 <SamB> BONUS: iirc it's in the report
09:10:12 <BONUS> oh is it? nice, thanks
09:10:15 <Axman6> Axman$ ./Treething +RTS -N2
09:10:15 <Axman6> unknown RTS option: -N2
09:10:20 <vixey> http://www.haskell.org/onlinereport/classes.gif
09:10:24 <BONUS> aha kewl
09:11:30 <bwr> ghc -e 'mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map(["  "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]'
09:11:40 <bwr> hmm... that may have seperated at a bad place :(
09:12:01 * encryptio makes a cross with his finger
09:13:18 <Axman6> bwr: uh, wow. reckon you could get that to work with my binary tree thing i'm working on? :)
09:13:37 <bwr> Axman6: what do you mean
09:14:09 <Axman6> it'd be nice to have a nice graphical representation of my binary tree thing. but dw
09:14:56 <Axman6> and, that thing is crazy
09:15:34 <bwr> ah, that is sierpiński triangle
09:15:43 <Axman6> yeah
09:15:50 <bwr> i don't know how you could use it draw a binary tree though
09:16:07 <vixey> oh very nice
09:16:12 <vixey> @remember bwr mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map(["  "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
09:16:12 <lambdabot> I will never forget.
09:16:17 <dmwit> :t drawTree -- Axman6
09:16:17 <lambdabot> Tree String -> String
09:16:18 <Axman6> well it's the right shape at least
09:16:55 <Axman6> @hoogle drawTree
09:16:55 <lambdabot> Data.Tree.drawTree :: Tree String -> String
09:17:12 <Axman6> rawr, i've been implimenting my own tree type
09:17:23 <Axman6> @where Data.Tree.drawTree
09:17:23 <lambdabot> I know nothing about data.tree.drawtree.
09:18:10 <Toxaris> Axman6: so write convert :: YourTree -> Data.Tree.Tree
09:18:20 <Axman6> i shall
09:18:27 <Toxaris> shouldn't be hard at all
09:19:01 <cnwdup_> @src evalStateT
09:19:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:19:19 <dmwit> ?source Control.Monad.State
09:19:19 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:19:22 <cnwdup_> ~(a, _) <- runStateT m s, what's the ~?
09:19:31 <dmwit> cnwdup_: Lazy pattern match.
09:19:44 <dmwit> It means, "assume this is the correct pattern."
09:20:00 <dmwit> It's only bad when you might be wrong about which constructor is called.
09:20:13 <ilyak_> @hoogle [a] -> [(Int, a)]
09:20:14 <lambdabot> No matches, try a more general search
09:20:19 <dmwit> > let f ~[] = 32 in f [32]
09:20:20 <cnwdup_> dmwit: Thanks.
09:20:21 <lambdabot>  32
09:20:53 <ilyak_> @hoogle [a] -> [(a, Int)]
09:20:54 <lambdabot> No matches, try a more general search
09:21:10 <Toxaris> @type zip [0..]
09:21:11 <lambdabot> forall t b. (Enum t, Num t) => [b] -> [(t, b)]
09:21:13 <dmwit> i.e. the argument is not reduced to head normal form until one of the bound variables is demanded.
09:21:36 <dmwit> At that point, you might get a runtime error if the constructor is wrong.
09:21:44 <dmwit> > let f ~[a] = 32 in f []
09:21:45 <lambdabot>  32
09:21:49 <dmwit> > let f ~[a] = a in f []
09:21:50 <lambdabot>   Irrefutable pattern failed for pattern [a]
09:21:50 <Toxaris> > zip "ilyak_, this one?" [0..]
09:21:51 <lambdabot>  [('i',0),('l',1),('y',2),('a',3),('k',4),('_',5),(',',6),(' ',7),('t',8),('h...
09:22:10 <ilyak_> What do I need to use, if I have a list of a (with repeats) and I need to get a map of a to number of identical a's in the list
09:22:16 <ilyak_> Toxaris: Nope.
09:22:30 <ilyak_> you can drop identicals by using nub, but how to count them all?
09:22:32 <dmwit> map (id &&& length) . group . sort
09:22:39 <vixey> ilyak: RLE compression
09:22:42 <Peaker> > let enumerate x = zip [0..] x in enumerate "hello"
09:22:43 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
09:22:50 <vixey> oh not quite
09:22:59 <dmwit> ?ty map (id &&& length) . group . sort
09:23:00 <lambdabot> forall a. (Ord a) => [a] -> [([a], Int)]
09:23:06 <dmwit> oops
09:23:09 <dmwit> ?ty map (head &&& length) . group . sort
09:23:10 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
09:23:26 <Toxaris> ilyak_: do you want runs of identical chars, or a frequency count?
09:23:41 <dmwit> ilyak_: If you have Eq but not Ord, there is a different (and less efficient) solution.
09:23:42 <ilyak_> Toxaris: What
09:23:47 <ilyak_> What's the difference?
09:23:54 <ilyak_> dmwit: I've got both Eq and Ord
09:23:58 <ilyak_> a is Int
09:24:07 <dmwit> ilyak_: The difference is in, eg, [1,1,2,1].
09:24:20 <Toxaris> ilyak_: "aaba" ~> [('a', 2), ('b', 1), ('a', 1)] or [('a', 3), ('b', 1)]
09:24:28 <ilyak_> Toxaris: Second one
09:24:36 <dmwit> ilyak_: Then see my ?ty query above.
09:24:42 <Toxaris> ok, then I would consider accumArray
09:24:55 <dmwit> accumArray can work nicely, too.
09:25:03 <Toxaris> if you have an Ix instance and some clue about the range of characters
09:26:05 <ilyak_> @show (&&&)
09:26:05 <lambdabot> "(&&&)"
09:26:14 <ilyak_> Well :)
09:28:28 <Toxaris> > accumArray (const . succ) 0 ('a', 'z') . map (flip (,) undefined) .filter (inRange ('a', 'z')) $ "hello ilyak what about this one?"
09:28:29 <lambdabot>  array ('a','z') [('a',3),('b',1),('c',0),('d',0),('e',2),('f',0),('g',0),('h...
09:28:31 <esteth> How would I deal with binary input/output data in haskell? I want to accept an arbitary file as input, which is potentially not just text.
09:30:15 <esteth> ah, never mind. It appears strings can handle it just fine :)
09:31:37 <Axman6> dmwit: thanks for pointing me at drawTree and Data.Tree :)
09:31:57 <Cale> esteth: Data.ByteString might be more convenient though
09:32:10 <Cale> esteth: Especially when combined with Data.Binary
09:32:45 <Cale> esteth: In the next version of GHC, the plain String I/O is going to become UTF-8 encoded as well, from what I hear...
09:33:26 <esteth> Thanks Cale, that should be useful :)
09:34:56 <chylli> @src init
09:34:57 <lambdabot> init [x]    = []
09:34:57 <lambdabot> init (x:xs) = x : init xs
09:34:57 <lambdabot> init []     = undefined
09:37:47 <Axman6> Cale: haskell finally catching up to Java then?
09:37:49 <Axman6> :P
09:38:54 <Trollinator> comparing Haskell to Java is just plain stupid.
09:39:01 <bwr> is there a general name for the sequences triangle numbers, tetrahedral numbers...
09:40:04 <RayNbow> http://www.reddit.com/r/programming/comments/6vlxn/xmonad_on_my_mobile_phone/
09:40:07 <lambdabot> Title: Xmonad on my mobile phone : programming, http://tinyurl.com/5pplwq
09:41:10 <b\6> bwr: maybe this: http://en.wikipedia.org/wiki/Figurate_numbers
09:42:02 <bwr> b\6: yea, i think that might be it
09:42:40 <bwr> i think polytopic
09:45:41 <chylli> @src liftM
09:45:42 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:45:52 <chylli> @hoogle liftM
09:45:52 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:45:52 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:45:52 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:47:49 <dafra> hi, just have gentoo working. where is the haskell overlay ?
09:48:23 <Axman6> overlay?
09:48:48 <b\6> dafra: http://www.haskell.org/~gentoo/gentoo-haskell/
09:48:48 <lambdabot> Title: Index of /~gentoo/gentoo-haskell
09:50:28 <r3m0t> liftM (*2) [3,4,5]
09:50:31 <r3m0t> > liftM (*2) [3,4,5]
09:50:32 <lambdabot>  [6,8,10]
09:50:37 <dafra> this overlay in not int lyman's list
09:51:14 <b\6> it's in google's list.
09:51:39 <b\6> and i think google could beat up lyman, whoever that is.
09:52:27 <dafra> layman is gentoo's overlay installer :)
09:53:43 <b\6> oh yeah.
09:57:36 <RayNbow> > liftM (*2) succ 4
09:57:37 <lambdabot>  10
09:57:49 <sioraiocht> ?
09:58:02 <sioraiocht> :t liftM (*)
09:58:03 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m (a1 -> a1)
09:58:09 <Deewiant> > (.) (*2) succ 4
09:58:10 <lambdabot>  10
09:58:16 <sioraiocht> :t liftM (*2)
09:58:16 <RayNbow> (e->) is a monad
09:58:17 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1
09:58:28 <sioraiocht> :t liftM (*2) succ 4
09:58:29 <lambdabot> forall a. (Enum a, Num a) => a
09:58:32 <sioraiocht> hmmm
09:58:45 <RayNbow> > liftM (*) succ pred $ 4
09:58:46 <lambdabot>        add an instance declaration for (Enum (a -> a), Num (a -> a))
09:58:49 <RayNbow> erm
09:58:52 <RayNbow> > liftM2 (*) succ pred $ 4
09:58:53 <lambdabot>  15
10:01:09 <sw17ch> well, my PortAudio bindings just did a record and playback for the first time
10:01:30 <sw17ch> Unsigned 8 bit audio at 8Khz
10:01:30 <sw17ch> :)
10:01:30 <sw17ch> 1 channel
10:02:56 * Cale wonders what new features PortAudio has over ALSA.
10:04:10 <Cale> Of course, Haskell support now :)
10:04:53 <SamB> well, it isn't ALSA
10:04:56 <SamB> that's always nice
10:05:00 <idnar> uh
10:05:01 <Cale> mm?
10:05:11 <idnar> oh, I'm thinking of PulseAudio
10:05:21 <Cale> oh... it turns out that I am too
10:05:22 <Cale> heh
10:05:34 <Cale> So... what is PortAudio then? :)
10:05:42 <idnar> anyhow, you don't use PulseAudio instead of ALSA
10:05:57 <Cale> Ah, it's a portable audio API.
10:06:01 <idnar> looks like the same thing is true of PortAudio
10:06:16 <idnar> it's just an extra layer on top of ALSA or OSS or DirectSound or what have you
10:06:42 <Cale> Does PulseAudio also hope to be cross-platform?
10:06:57 <Cale> Or does it serve some other purpose?
10:07:10 <idnar> "PulseAudio has been tested on Linux, Solaris, FreeBSD, Windows 2000 and Windows XP. It should also run on all other POSIX and Windows systems, but may require new backends to handle their sound systems. "
10:07:11 <Deewiant> PulseAudio has been tested on Linux, Solaris, FreeBSD, Windows 2000 and Windows XP.
10:07:11 <sw17ch> Cale: PortAudio is a lot simpler
10:07:14 <maltem> PulseAudio looks like an esd replacement
10:07:18 <sw17ch> 30ish functions as opposed to 300, and it's cross platform
10:07:22 <idnar> maltem: basically, yeah
10:07:30 <sw17ch> my bindings don't support the callbacks though...
10:07:43 <sw17ch> just the blocking read/writes available in PortAudio 19
10:07:51 <SamB> so it can go "boing" at approximately the right time on any platform, eh?
10:07:52 <Cale> It should be possible to support them.
10:08:03 * mux nods
10:09:02 <mux> foreign import ccall "wrapper" is the key
10:09:04 <sw17ch> I wasn't sure how to implement the callbacks, and that's the primary reason I haven't yet. While a single callback is fine, the PortAudio library continuously calls back until the callback returns a "stop calling me" value
10:09:28 <sw17ch> and something about that scared me
10:10:10 <dons_> http://www.reddit.com/r/programming/comments/6vlxn/xmonad_on_my_mobile_phone/
10:10:12 <lambdabot> Title: Xmonad on my mobile phone : programming, http://tinyurl.com/5pplwq
10:10:18 <chrisdone> this is pretty cool: http://hpaste.org/9491 I'm going to make the validation functions monadic so that one can check against the sql database
10:10:24 <Cale> dons: yeah, I saw that, pretty cool :)
10:10:48 <chrisdone> dons: haha, oh wow. awesome
10:11:06 <Cale> sw17ch: Well... let me see if I can remember how to do this :)
10:11:52 <sw17ch> if any one wants to look at my first attempt at a c2hs program... i have the source online... let me figure out the url quick
10:12:10 <sw17ch> also, first attempt at a binding library
10:12:49 <chylli> @hoogle forkIO
10:12:49 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
10:12:49 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
10:15:00 <Cale> sw17ch: You start with something like  foreign import ccall "wrapper" mkCallback :: IO Result -> IO (FunPtr (IO Result)), which will turn IO actions into function pointers which can be called by C routines. The Result type here must be a "foreign type"
10:15:36 <Cale> But then you can wrap the thing which sets up the callbacks a bit if you want to provide support for nice enumerations or something.
10:15:52 <Cale> (and avoid having the user deal with FunPtrs directly, of course)
10:15:57 <sw17ch> Cale: is this still safe as a continuous callback? the only examples i'd usually seen were wrapped in a monad and it waited until the callback returned
10:16:03 <chrisdone> instead of where register' = user >> email >> pass >> send "Register", I'll have something like where register' = newUser >> email >> pass >> send "Register" where newUser = test "must not already exist" (\v -> do rows <- query "SELECT usern FROM user WHERE usern = ?" [SqlString v]; return (null rows))
10:16:26 <Cale> sw17ch: By wrapped in a monad, you mean the IO monad?
10:17:08 <Cale> sw17ch: Well, I say try it and see if there are performance issues.
10:17:33 <chr1s> chrisdone: looks very cool. did you also take a look at formlets?
10:18:12 <Cale> sw17ch: I think if a C routine would be an acceptable thing to call, then the equivalent Haskell should not be too much of a problem.
10:18:13 <sw17ch> Cale: let me rephrase, i'm not being clear... PortAudio will keep calling and calling and calling that callback.
10:18:23 <sw17ch> is that going to be okay?
10:18:26 <chrisdone> chr1s: yep, I've been looking at it for ideas, if I can bend it to work like this I intend on using it, otherwise no matter :)
10:18:27 <sw17ch> as in, we do'nt set it up each time
10:18:35 <Cale> sw17ch: I can't think of a reason it would be bad...
10:18:36 <sw17ch> we set it up once, and it keeps going until the callback tells it to stop
10:18:39 <sw17ch> alright :)
10:19:02 <chr1s> chrisdone: I think that should be perfectly possible!
10:19:06 <sw17ch> http://sw17ch.com/code/HsPortAudio/src/Sound/PortAudio.chs
10:19:17 <sw17ch> there's the code, don't hurt me :)
10:19:29 <sw17ch> the Haddock isn't parsing quite yet...
10:19:49 <sw17ch> it chokes on the "chunk" definition near the bottom
10:19:55 <sw17ch> even though i'm not exposing it...
10:20:31 <chr1s> chrisdone: with formlets, you also don't have to worry about the names of the fields.
10:20:57 <chrisdone> chr1s: that's cool then. I've mostly been thinking about how I really want to work with forms
10:21:34 <chrisdone> chr1s: how are the names produced?
10:23:12 <chrisdone> chr1s: re how I want to work. it's nice to be able to write; “optional email”, where optional makes a formlet okay to be empty
10:23:46 <chr1s> yes, that's exactly what is possible.
10:24:16 <chr1s> chrisdone: you could write something like input `check` optional
10:24:23 <sw17ch> can i make haddock ignore a line?
10:24:44 <chr1s> where optional return Nothing if the input is "", and Just x otherwise
10:25:08 <chr1s> chrisdone: see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/formlets
10:25:11 <lambdabot> Title: HackageDB: formlets-0.3, http://tinyurl.com/595akl
10:25:41 <Cale> sw17ch: I seem to recall there was some #ifdef magic you could use...
10:26:17 <chrisdone> chr1s: how are field names generated?
10:26:19 <sw17ch> Cale: eww
10:26:32 <Cale> sw17ch: Does it give any more specific details about what it's choking on?
10:26:51 <Cale> chunk looks like basic Haskell code... it's not like you're using crazy syntax extensions there...
10:26:55 <chr1s> chrisdone: once you have a complete form, it will generate inputs with name "input0, input1, input2", etc.
10:27:39 <Cale> sw17ch: oh, possibly try separating that comment at the top by one line...
10:27:47 <Cale> sw17ch: Not sure if that will help, but...
10:27:57 <chrisdone> chr1s: doesn't sound very semantic. I wouldn't want to be the one using that page as a resource in a RESTful way
10:28:33 <sw17ch> actually, it chokes on type PaStreamBuffer = Ptr ()
10:28:43 <Cale> oh...
10:28:59 <Cale> er...
10:29:07 <sw17ch> "Parse error in pattern"
10:29:21 <sw17ch> though it may also be referring to the previous line
10:29:32 <sw17ch> since there's no patterns there... unless it's looking at () as a pattern
10:29:36 <Cale> Oh! You're using an n+k pattern.
10:29:43 <Cale> In the previous nonempty line.
10:29:52 <chrisdone> chr1s: well, I'll try to figure out how to use it
10:30:00 <Cale> Maybe try removing the n+k pattern and see if that helps.
10:30:10 <Cale> Change (c + 1) to c
10:30:15 <chr1s> chrisdone: good! Any comments or ideas are really welcome!
10:30:17 <Cale> and c to (c - 1)
10:30:46 <sw17ch> haha
10:30:49 <sw17ch> Cale: that was it
10:31:01 <sw17ch> :w
10:31:03 <sw17ch> woops, not vim
10:31:20 <chrisdone> chr1s: do you know where a runnable example of it is?
10:31:22 * Cale saves the entire history of #haskell to disk anyway.
10:31:51 <chrisdone> chr1s: for example, here is my paste example: http://chrisdone.com:3000/register
10:33:07 <Cale> heh, for my personal log alone... "FreeNode-#haskell.log" 1024787L, 77644455C
10:33:17 <sw17ch> http://sw17ch.com/code/HsPortAudio/src/doc/Sound-PortAudio.html
10:33:18 <lambdabot> Title: Sound.PortAudio
10:33:25 <sw17ch> there's the docs if it's easier to look at it that way
10:33:54 * sw17ch still has a lot of cleanup to do
10:34:13 <Cale> oh, right, but that's only from January... the rest of my log is elsewhere...
10:35:10 <Cale> I have another log going back to 2004, which is another 1.7 million lines or so :)
10:35:38 <tibbe> is time included in the base libraries prior to the base package split?
10:35:56 <Cale> tibbe: yeah, I think so.
10:36:01 <Cale> hmm
10:36:10 <Cale> Which modules exactly?
10:36:49 <Igloo> old-time was in base2, if that's what you mean
10:37:09 <Cale> ah, right, it's old-time :)
10:37:24 <b\6> applicative parsec way to read an integer, read a colon, read count n anyChar where n is the previously mentioned integer? i'm not getting how to save something, skip something, use the saved thing.
10:37:24 <tibbe> Cale: Data.Time.Clock
10:37:57 <tibbe> Igloo: I have imported Data.Time.Clock and Control.Monad.Trans, what do I have to put as dependencies for pre vs post split in my .cabal file?
10:38:10 <Igloo> That's always been separate
10:38:11 <Cale> tibbe: No, it was still in 'time'
10:38:18 <tibbe> ok
10:38:40 <Cale> One way to check is to look at the historical versions of the GHC documentation.
10:38:47 <Cale> http://www.haskell.org/ghc/docs/
10:38:47 <lambdabot> Title: Index of /ghc/docs
10:39:22 <Cale> The main table of contents for the hierarchical libraries documentation lists the package that each module is in.
10:40:16 <tibbe> cabal: At least the following dependencies are missing:
10:40:16 <tibbe> base >=2.1 && <3
10:40:22 <tibbe> hmm
10:40:27 <tibbe> I'm confused again :)
10:41:30 <ddarius> b\6: Use (a combination of Applicative and) monadic constructs.
10:42:16 <dmwit> tibbe: Well... what does 'ghc-pkg list base' say?
10:42:30 <tibbe> dmwit: I typed it wrong
10:42:32 <chrisdone> chr1s: where is inputIntegerF defined?
10:44:33 <chr1s> chrisdone: the example on my blog is slightly outdated (already)
10:44:41 <chr1s> chrisdone: http://hackage.haskell.org/packages/archive/formlets/0.3/doc/html/Text-XHtml-Strict-Formlets.html
10:44:42 <lambdabot> Title: Text.XHtml.Strict.Formlets, http://tinyurl.com/5ta8oq
10:44:49 <chr1s> you should use inputInteger
10:45:08 <chr1s> so in your case, it should be something like:
10:45:26 <chrisdone> oh, sweet, I wasn't aware of Text.XHtml.Strict.Formlets
10:45:29 <chr1s> data User = User {name :: String, email :: String, password :: String}
10:45:32 <chr1s> and then
10:45:59 <chr1s> userForm = User <$> input Nothing <*> input Nothing <*> input Nothing
10:46:06 <chr1s> which doesn't do any validation.
10:46:38 <chr1s> but you could replace the second "input Nothing" by inputEmail
10:46:53 <chrisdone> sure :)
10:47:41 <chr1s> where inputEmail = input Nothing `check` ensure (\x -> length x > 10) "E-mail should at least be 10 chars"
10:47:53 <aes2> Is there a way to return a compile-time known number of values of different types from a monad from several different source code locations without sending the value through multiple functions without using the state monad?
10:48:58 <chrisdone> chr1s: how would one write a monadic validation function such that it could read from a database and check aginst some value?
10:49:14 <chr1s> chrisdone: I'm actually working on that as we speak.
10:49:23 <chrisdone> chr1s: wow great :)
10:49:26 <chrisdone> chr1s: does it involve runFormStateT ?
10:49:36 <chr1s> it shouldn't be to hard. I need to use it myself as well.
10:49:42 <chrisdone> cool
10:49:49 <chr1s> I don't exactly now yet.
10:49:53 <chr1s> s/now/know
10:49:57 <chrisdone> well it seems I'll be incorporating Text.Formlets into Kibro
10:50:03 <chr1s> nice!
10:50:07 <chrisdone> ^_^
10:50:18 <chr1s> you should also take a look at the paper, it's a great read.
10:50:27 <chrisdone> the formlets paper? ok
10:51:14 <chr1s> chrisdone: what library do you use for databases?
10:51:41 <chrisdone> chr1s: HDBC
10:51:45 <chrisdone> chr1s: why?
10:52:09 <chr1s> chrisdone: just wondering. I couldn't find any acceptable db abstraction when I was looking -- about a month ago
10:55:00 <chrisdone> chr1s: HDBC is "ok". it runs everything as a transaction until you "commit" your changes. I basically just want sqlite3 and will use whatever works right now
10:56:17 <Peaker> where's Data.Queue?
10:57:03 <Peaker> oh, deprecated
11:00:59 <Peaker> how do I convert a Data.Sequence.Seq to a list?
11:01:00 <chrisdone> chr1s: well, looking forward to a change which supports monads. I hope you'll blog about it
11:01:28 <Peaker> hmm.. I guess I don't
11:01:39 <vixey> weird
11:01:40 <vixey> viewl
11:01:51 <vixey> shouldn't viewl be :: ... -> [a] ?
11:02:13 <chrisdone> Peaker: use http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html#2
11:02:14 <lambdabot> Title: Data.Sequence, http://tinyurl.com/3arc5q
11:02:57 <Peaker> chrisdone: thanks
11:03:45 <chrisdone> Peaker: that is, use the Foldable instance
11:03:50 <ddarius> No, use toList.
11:03:55 <Associat0r> Guys am I right to think that with dependent types, you won't need unit tests anymore?
11:03:56 <chrisdone> use toList
11:04:15 <aes2> Where's the inverse of the Reader monad? The Writer monad only "writes" combinable complete values together, but cannot fill the fields of a record one by one.
11:04:25 <Peaker> chrisdone: Yeah I understood, thanks
11:04:32 <vixey> Associat0r: We don't need unit tests right now
11:04:44 <Peaker> @hoogle toList
11:04:45 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
11:04:45 <lambdabot> Data.Foldable.toList :: Foldable t => t a -> [a]
11:04:45 <lambdabot> Data.Set.toList :: Set a -> [a]
11:04:46 <vixey> Associat0r: You could prove all your code correct instead
11:06:22 <pozic> vixey: "now"? In what language? Haskell 98?
11:06:38 <Associat0r> with an external theorem prover?
11:06:59 <vixey> Associat0r: I was thinking paper and pencil but that could also work
11:07:03 <pozic> Associat0r: every Haskell project worth anything has tests.
11:07:07 <Peaker> what Data.Sequence.Seq function would replace Data.Queue's deQueue?
11:07:09 <vixey> pozic: Wrong
11:07:13 <pozic> Associat0r: in theory, yes, you can do that.
11:07:32 <pozic> vixey: almost every library then...
11:07:42 <pozic> vixey: I know some where proved correct later on with Coq.
11:07:42 <Associat0r> pozic : so that would be a complete substitute to unit tests?
11:07:50 <Associat0r> in theory
11:07:54 <pozic> Associat0r: yes, it would, in theory.
11:07:57 <vixey> Associat0r: No
11:08:08 <vixey> Associat0r: What I was saying is that it's orthogonal to testing
11:08:21 <pozic> Associat0r: if you want to test whether your missle will be launced, you still need to press a button.
11:08:49 <pozic> Associat0r: but the software will do whatever its type proves.
11:08:59 <pozic> Associat0r: assuming the hardware works
11:09:43 <chrisdone> Beelsebob: are you at anglo haskell?
11:10:22 <pozic> missile*
11:11:25 <heatsink> Associat0r: Dependent types don't help you to verify that you've defined "correct behavior" appropriately for your program.
11:11:47 <vixey> heatsink: They do help :)
11:12:45 <vixey> proving something in general increases your understanding about it very much
11:12:46 <heatsink> If your fibonacci number function's type is "returns an Int", then a fibonacci function that always returns 1 will typecheck.  Dependent type systems allow you to define more precise types, but they don't force you to.
11:13:18 <pozic> "but the software will do whatever its type proves."
11:13:23 <vixey> and when you try to prove something trivial or impossible, you can see something is fishy
11:13:24 <Beelsebob> chrisdone: possibly -- depends if anygma wanna fund some of us going over
11:13:38 <heatsink> pozic: I thought it was worth emphasizing.
11:14:02 <hackage> Uploaded to hackage: benchpress 0.1
11:14:02 <hackage> Uploaded to hackage: WebBits 0.9.1
11:14:02 <hackage> Uploaded to hackage: WebBits 0.9
11:14:03 <hackage> Uploaded to hackage: ghc-core 0.4
11:14:05 <hackage> Uploaded to hackage: formlets 0.3
11:14:08 <Beelsebob> o.O
11:14:23 <stepcut> welcome back, hackage
11:16:24 <heatsink> Hmm.  I have the filepath package, but HSFFIG wants the FilePath package.
11:16:41 <heatsink> Is there an online database of cabal packages?
11:17:05 <mux> hackage :)
11:17:10 <mux> hackage.haskell.org
11:17:31 <heatsink> I found filepath, but I don't see a FilePath.
11:17:50 <heatsink> Maybe I can just change HSFFIG.cabal.
11:18:36 <Associat0r> then another question about STM, right now we worry about purity to ease concurrency and ensure verifyability, but when we have many cores in the future and STM is more common what will pure code gain us other then verifyability?
11:19:08 <chessguy> @pl \t -> i (f t) (Just t) N
11:19:08 <lambdabot> flip (liftM2 i f Just) N
11:19:19 <b\6> i'm making an algebraic data type and wanting to use one of the data constructors to define one of the others. not sure what to do.
11:19:51 <vixey> b\6: I don't think that makes sense
11:19:53 <vixey> b\6: what do you mean?
11:20:04 <catechu> Associat0r: What is STM?
11:20:16 <Associat0r> Software Transactional Memory
11:20:24 <aes2> data a b c d e f = B a b c d e f; test = do tell (undefined::a); tell (undefined :: b); tell (undefined :: c); tell (undefined :: d) and so on. These different tell statements should be executed in different functions. At the end of the computation these values need to be present in a B record. Something similar is OK too.
11:20:25 <heatsink> Associat0r: Pure code places less demand on hardware.  Pure code works nicely with the MSI protocol and concurrent garbage collectors can take advantage of immutability.
11:20:28 <TomMD> The best thing since sliced Lambdas
11:21:10 <b\6> vixey: like data A = B x | C x | D x. maybe i want to say that C's parameter is B x.
11:21:12 <heatsink> mux:thx
11:21:17 <ddarius> Associat0r: STM relies on purity.
11:21:23 <vixey> b\6: That's impossible in haskell
11:21:29 <rwbarton> b\6: It sounds like you might be interested in GADTs
11:21:30 <vixey> b\6: You can use GADTs though
11:21:38 <b\6> hmm, ok. reading.
11:21:45 <vixey> b\6: If you index the constructors
11:21:50 <vixey> data A i where
11:22:02 <vixey>   b :: x -> A ThisIsAnA
11:22:11 <aes2> I meant data B a b c d e f, naturally.
11:22:16 <vixey>   c :: A ThisIsAnA -> A ThisIsNotAnA
11:22:55 <newsham> data B = B Int; data C = C B; data All = AllB B | AllC C
11:23:09 <b\6> ah.
11:23:21 <b\6> i'll check out those ways. thanks.
11:26:01 <rwbarton> aes2: if some of a b c d e f are equal, your "tell"s will be ambiguous... so you need to use tellA, tellB, etc. as a start
11:26:09 <Associat0r> ddarius : it does? I thought it was to be able to make ad-hoc mutable code easily concurrent, I know it can't be used on operations that can't rollback like IO but other forms of side effects it should work
11:27:37 <aes2> rwbarton: there is no instance for Monoid to express partially filling a record. That's the problem.
11:28:11 <ddarius> Associat0r: STM specifically is designed to support mutable references.  Other side effects will not trivially be able to be rolled back so you must not use any side-effects not specifically supported by the STM system.
11:28:24 <rwbarton> aes2: Right, well you could define an Monoid instance for B (Maybe a) (Maybe b) ... (not Haskell 98, of course) that's like the Monoid instance for the First (or Last) newtype of Maybe
11:28:29 <SamB> aes2: you just make records that only have those fields filled
11:29:00 <aes2> SamB: but a writer monad cannot read what it has written before.
11:29:18 <SamB> aes2: hmm, I mean, every field could be a Monoid
11:29:49 <ddarius> Anyway, STM is likely to get less compelling as the number of cores gets much greater.
11:30:01 <rwbarton> Define (Monoid a, ..., Monoid f) => Monoid (B a ... f) and then use B (First a) ... (First f) (or Last if you prefer)
11:30:02 <SamB> so mzero = B mzero mzero mzero mzero mzero mzero
11:30:21 <SamB> ddarius: so what's the point?
11:30:40 <aes2> SamB: you mean mempty?
11:30:50 <SamB> aes2: oh, sure
11:31:07 <Cale> ddarius: well, along with concurrency as a means to parallelism...
11:31:30 <ddarius> SamB: The point is that the vast majority of computers aren't going to have 100+ cores anytime in the near future.
11:31:34 <Cale> (however, it will still be useful when you want concurrency as an abstraction)
11:32:07 <Cale> otoh, wasn't Intel already working on an 80-core processor?
11:32:16 <SamB> what's a MonadPlus but a Monad with a Monoid for every return type?
11:32:39 <Associat0r> "ddarius: Anyway, STM is likely to get less compelling as the number of cores gets much greater" << wasn't it the other way around
11:32:49 <Cale> SamB: The monoid should agree with the monad structure a bit
11:32:50 <SamB> Cale: for some purpose other than showing off at cons?
11:32:55 <ddarius> Associat0r: No.
11:33:02 <Cale> SamB: I was hoping :)
11:33:05 <SamB> Cale: yeah I guess so
11:33:29 <Cale> http://haskell.org/haskellwiki/MonadPlus
11:33:30 <lambdabot> Title: MonadPlus - HaskellWiki
11:33:36 <ddarius> It will get more compelling when the number of cores is >1 but otherwise the abstraction it presents will become farther and farther from the truth as the number of cores increase.
11:33:51 <Cale> See also: http://haskell.org/haskellwiki/MonadPlus_reform_proposal
11:33:52 <ddarius> It may be possible though, to adapt STM to these situations.
11:33:52 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
11:35:05 <newsham> http://techfreep.com/intel-80-cores-by-2011.htm
11:35:06 <lambdabot> Title: 17 Intel: 80 Cores by 2011 15 | TechFreep Hardware 194
11:35:19 <Cale> I suppose the other thing which is implicit is that the monoid structure is natural, in the sense that it's independent of the type to which you apply the constructor.
11:36:10 <newsham> there's some vendor that already makes high number of cores per chip (not ia32)
11:36:13 <newsham> but i cant remember the name
11:37:23 <stepcut> newsham: the forth one ?
11:37:26 <Cale> Once everyone's on machines with that order of cores/processors, I think that imperative programming is going to start looking unattractive fairly quickly.
11:38:01 <newsham> http://en.wikipedia.org/wiki/TILE64 64 cores.  http://en.wikipedia.org/wiki/Kilocore 256 cores
11:38:01 <lambdabot> Title: TILE64 - Wikipedia, the free encyclopedia
11:38:04 <Cale> (at least as a default approach)
11:38:15 <dons> Cale, I was at a confernece last week where 500 cores were considered small game.
11:38:34 <dons> and pretty much the only way to program these things is either data parallelism or task parallelism
11:38:34 <Cale> dons: yeah... and things just get more ridiculous from there :)
11:39:31 <heatsink> dons: Which conference was that?
11:39:48 <dons> http://multiscale.emsl.pnl.gov/
11:39:48 <lambdabot> Title: 2008 DOE Summer School : Multiscale Mathematics and High Performance Computing
11:40:27 <dons> the problems were more focused on programming 100k+ core machines.
11:40:34 <pozic> There is no problem with having many cores; they will just be used differently.
11:41:14 <pozic> Only writing "numerical code" on those machines is for people with too little imagination.
11:41:37 <greymouser1> whowas gato
11:41:41 <stepcut> one core per pixel might be fun
11:41:45 <dons> Cale, seen data parallel matlab? the star-p stuff.
11:41:49 <ddarius> I doubt they are 100k+ general purpose CPUs
11:41:58 <newsham> i'm going to need at least 5 cores for irc alone
11:41:59 <Cale> With < 16 or so cores, you might be able to get away with writing programs that don't parallelise at all, and just argue that running multiple programs will be how the extra CPU is used.
11:42:06 <dons> ddarius: no. these are the top end super computers we're talking about
11:42:21 <Cale> At a certain point, it becomes hard to justify that line of reasoning :)
11:42:29 <dons> and some "off the shelf" things like the cray
11:42:39 <rwbarton> Cale: I buy that, if by "16 or so" you mean "3" :)
11:43:08 <newsham> you are ignoring the power of gates law.
11:43:20 <Associat0r> ddarius:  so you mean that at a certain point with mutable data and too many cores there will be just too many rollbacks for STM to scale further?
11:43:20 <newsham> microsoft will find all sorts of stupid things to do with all those extra cpus
11:43:28 <Cale> newsham: heh
11:43:53 <maltem> dons: nice to see a Haskell community prominent at a conference about high performance computing, that makes the lecture of the same name (that I'll have to attend at some point) sound much less boring :)
11:43:59 <pozic> Energy/embarrassingly parallel computation is what I am interested in.
11:44:36 <ddarius> Associat0r: That's not actually what I was talking about.  I was talking about the shared memory abstraction which is already wrong and will only become more incorrect.  However, yes, as the number of cores rise the amount of contention also rises and STM implies an optimistic concurrency model.
11:44:43 <dons> maltem: it was video streamed live, actually. so you should be able to see the video of my talk next week sometime.
11:44:47 <newsham> someone should get ghc on this thing:  http://www.tilera.com/products/tilexpress20g.php
11:44:48 <lambdabot> Title: Tilera Corporation
11:45:00 <SamB> newsham: why do you blame MS in particular?
11:45:05 <pozic> I don't care if the CPUs become a thousands of times slower. If I also get tens of billions of CPUs back.
11:45:05 <dons> ddarius: interesting to note the cray xmt has hardware mvars
11:45:10 <SamB> mozilla.org is probably just as bad
11:45:17 <newsham> samb: because they have 90% market share.
11:45:26 <newsham> ie. the others dont really matter
11:45:27 <pozic> Just like biological computing.
11:45:29 <maltem> dons: ah cool
11:45:35 <ddarius> pozic: See amorphous computing.
11:45:38 <SamB> newsham: yes but they tend to do the same thing
11:45:54 <Cale> Does STM really imply optimism? It seems to me that the STM primitives could be implemented in quite a large number of ways...
11:46:04 <pozic> ddarius: thanks, I didn't know that term.
11:46:18 <newsham> mostly..  MSFT tries as hard as possible to copy AAPL, while linux and many open source projects try as hard as possible to replicate whatever MSFT did 5 years ago
11:46:23 <maltem> dons: even though the idea of giving a talk per live stream would scare me, personally
11:46:33 <Cale> Of course, optimistically running everything right away is the simplest implementation.
11:46:44 <ddarius> Cale: It doesn't -require- an optimistic concurrency model, but it strongly suggests one.
11:47:08 <Associat0r> dons at what point does STM break down?
11:47:23 <ddarius> You could, for example, instead use a global lock for an pessimistic implementation of STM.
11:47:27 <mrd> newsham: no, linux tries to replicate what AT&T had 20 years ago
11:47:30 <newsham> (samb: btw, not everybody slows down as aggressively...  measure freebsd for example)
11:47:38 <Cale> Associat0r: As soon as you can't come up with distinct things to do with each of your cores.
11:48:09 <Cale> Associat0r: If you're effectively doing the same thing to different data on each core, then you want data parallelism instead.
11:48:11 <newsham> mrd: which dept in at&t wrote a kde/gnome-like desktop?
11:48:24 <pozic> ddarius: I read a paper on the subject already, just didn't know the author was in that field.
11:48:24 <mrd> newsham: what's that gotta do with "linux"?
11:48:36 <newsham> a lot.
11:48:41 <ddarius> pozic: http://web.mit.edu/jakebeal/www/Publications/MIT-CSAIL-TR-2007-030.pdf This is a good current overview with a decent bibliography.
11:48:42 <lambdabot> Title: Amorphous Computing, http://tinyurl.com/57ptpb
11:48:53 <mrd> newsham: hardly.  i haven't used either in many years.
11:48:59 <pozic> ddarius: does it also treat experimenal hardware?
11:49:11 <newsham> mrd: well that proves it then!  sorry.  my bad.
11:49:15 <mrd> yes
11:49:18 <pozic> ddarius: since software is the easy part, imho.
11:49:23 <mrd> can you stop conflating things?
11:49:33 <newsham> mrd: i only conflate things that are conflated.
11:49:41 <newsham> (at least thats the goal)
11:49:58 <ddarius> pozic: It is mostly independent of the hardware, e.g. most of it will work on sensor networks, swarms of robots, E. coli colonies, mobile phones, etc.
11:50:13 <mrd> some people try to imitate MSFT.  others use xmonad, tyvm.
11:50:26 <ddarius> pozic: http://www.media.mit.edu/resenv/pushpin/paintable.html  This is, in my opinion, one of the funnest papers to read in this field.
11:50:27 <lambdabot> Title: Pushpin Computing
11:50:31 <mrd> I suppose linux is also conflated with xmonad
11:50:39 <newsham> not really.
11:50:42 <mrd> by your logic
11:51:38 <lispy> mrd: is that because Orange Hat linux just release a desktop built around xmonad?
11:52:38 <gwern> linuxmonad!
11:52:43 <mrd> it's snappy
11:52:50 <pozic> ddarius: yes, well, then I am not that interested. I might read it, though.
11:53:14 <lispy> (my point being that, kde/gnome are ubiquitous in linux land, so yeah I'd say they get conflated in.  Obviously, a server setup of linux doesn't need them, but linux is used ambiguously by juts about everyone to refer to some set of the kernel + stuff)
11:53:32 <mrd> and my point is your assumption is incorrect
11:53:44 <mrd> and I'm one counterexample, I'm sure there are plenty
11:54:04 <mrd> I find KDE and gnome to be distasteful, and so do many others
11:54:20 <lispy> What was my assumption that you refer to?
11:54:29 <mrd> but people are certainly free to try to imitate MSFT.  but that doesn't mean everyone who uses linux tries to.
11:54:30 <newsham> #haskell-blah perhaps?
11:54:55 <gwern> newsham: shuck that jive man!
11:55:01 <gwern> shuck *all* that jive!
11:55:10 <gwern> don't need no credit card to ride this train
11:55:30 <newsham> C++ STM?  http://softwarecommunity.intel.com/articles/eng/1460.htm
11:55:31 <lambdabot> Title: Intel® C++ STM Compiler, Prototype Edition 2.0
11:55:37 <gwern> preflex: seen zooko
11:55:38 <preflex>  zooko was last seen on #haskell 82 days, 16 hours, 16 minutes and 50 seconds ago, saying: Ha!
11:55:47 <dons> we don't know where STM breaks down. it's algorithm dependent
11:55:56 <gwern> @seen zooko
11:55:56 <lambdabot> I haven't seen zooko.
11:55:59 <dons> it enables some classes of concurrency problems to be programmed with little thought
11:56:06 <mrd> you can practice STM with two-phase commit :)
11:56:18 <mrd> and locking
11:56:34 <gwern> @tell zooko well, I've added a patch to darcs-cabalized to try to get windows support working. but I can't test it as I'm not on windows... are you interesting in me sending it to you?
11:56:34 <lambdabot> Consider it noted.
11:56:48 <erikc> Enhanced integration of transactional memory features into C++ such as the TM support for C++ class annotation, inheritance, virtual functions, templates etc. and supporting failure atomicity, requiring less source code changes required to use TM constructs and annotations in C++ programs.
11:56:52 <erikc> i hope i never have to use this
11:57:25 <mmorrow> <dmhouse> > let foo 't':'h':'i':'s':' ':'i':'s':' ':'p':'a':'i':'n':'f':'u':'l':[] = 5 in foo "this is painful"
11:57:29 <ddarius> erikc: You'd prefer to use manual locks and semaphores?
11:57:36 <mmorrow> that gave me an idea http://hpaste.org/9493
11:57:51 <erikc> ddarius: i'd prefer to use a language whose computation model lends itself to STM
11:57:58 <rwbarton> mmorrow: heh :)  I carefully refrained from mentioning quasiquoting this time :)
11:58:04 <olsner> I read about a JVM that used STM on multi-threaded java programs, something like tentative paralell execution of code that is written as if it's serialized by a lock
11:58:15 <ddarius> erikc: But if you are using C++ ...
11:58:16 <rwbarton> Plus, string literals work just fine there
11:58:18 <mmorrow> rwbarton: haha, i just can't help myself anymore
11:58:36 <olsner> at least that's what the market-technobabble seemed to indicate
11:58:39 <newsham> > let foo "easy" = 42 in foo "easy"
11:58:43 <lambdabot>  42
11:58:44 <aes2> rwbarton: when the number of variables goes to infinity, the time the update procedure grows to infinity as well. It's not an efficient solution. If I add the constraint so that it should work in constant time, is there still something possible?
11:59:07 <mmorrow> rwbarton: that's true, but "painfully" so ;)
11:59:26 <rwbarton> > let foo "this is less painful" = 3 in foo "this is less painful"
11:59:27 <lambdabot>  3
11:59:27 <Beelsebob> > let foo 'h':'a':'r':'d':xs = xs in foo "hardchrist this is far too hard"
11:59:27 <lambdabot>  Parse error in pattern at "in" (column 33)
11:59:42 <rwbarton> Beelsebob: yeah, that's the case where the quasiquoter can actually be useful
12:00:28 <mmorrow> yeah, i think that's a really good example of a trivial-to-write quasiquoter that's nontrivially useful
12:00:39 <newsham> http://codepad.org/uL2KJ8UQ
12:02:32 <erikc> ddarius: imo if you are still using c++ today, its for legacy reasons or you have specific performance needs, in either case, a STM add-on that requires vendor-specific annotations + upgrading your C++ code to a black-box OpenMP implementation is terrifying, at least terrifying enough that i hope i never have to do it :)
12:03:02 <Toxaris> mmorrow: can I use your quasi-quoter to write Beelsebob's foo above?
12:03:19 <Toxaris> mmorrow: i.e., how to compose pre with other patterns?
12:04:02 <mmorrow> Toxaris: good point, lemme think of a solution real quick. (i didn't see Beelsebob's point at first)
12:05:49 <rwbarton> aes2: I don't see a more efficient solution.  If the number of variables is really going to infinity, you probably want a Map or something
12:06:32 <mmorrow> hmm, i don't think a solution to that pretty, *but* something like this would be imo opinion an acceptable workaround:
12:06:50 <mmorrow> (..to that _would be_ pretty...)
12:06:51 <rwbarton> aes2: Oh, maybe you could build something faster out of ST
12:07:02 <aes2> rwbarton: a newtyped StateT with a reduced interface would work.
12:07:25 <Beelsebob> tbh, the solution for min mmorrow is
12:07:26 <Beelsebob> > let foo x | "hard" `isPrefixOf` x = drop 4 x
12:07:27 <lambdabot>  Parse error at end of input
12:07:32 <rwbarton> aes2: but won't you still have to unpack and create a new B every time you change something?
12:07:38 <aes2> rwbarton: yes, that's possible too (mutable references) and using the module system optionally to hide it.
12:07:39 <Beelsebob> mine*
12:07:43 <mmorrow> let foo xs@[$pre|hard|] = drop (length "hard") xs
12:08:06 <aes2> rwbarton: no, not when the order in which the variables become known is fixed.
12:08:11 <mmorrow> Beelsebob: yeah, that's what i was thinking too
12:08:25 <rwbarton> aes2: Oh, that could be.
12:09:07 <mmorrow> Beelsebob: if i hardcode the 4, i still beat you on length ;)
12:09:14 <mmorrow> (hehe)
12:09:31 <rwbarton> what are the quoting rules in qq uses?
12:09:47 <mmorrow> rwbarton: how do you mean?
12:10:03 <Beelsebob> mmorrow: possibly, but I probably beat you on clarity
12:10:06 <rwbarton> could I put a | in the middle of the quoted string somehow?
12:10:35 <Toxaris> mmorrow: hehe yeah that's a workaround, but, well, it is not good :)
12:10:42 <mmorrow> Beelsebob: that's arguable ... (ok fine, i'll give you that)
12:11:12 <Toxaris> mmorrow: imho that's a problem of quasiquotation (as little as I understand it), that you cannot "switch back" to normal patterns
12:11:33 <mmorrow> rwbarton: ah, i see. you can do arbitrary things in the quoted string .... the big "but" is, you have to implement parsing/handling that yourself
12:11:44 <rwbarton> you could make a quasiquoter that accepted  let foo [$pre|"hard"++xs|] = xs  (where ""++ is just made up syntax)
12:11:53 <vixey> yes
12:11:56 <rwbarton> mmorrow: Right, I mean, clearly I can't include the string '|]
12:11:58 <vixey> rwbarton: I would like that
12:12:05 <Toxaris> oh so you only need   normalPatternSyntax :: String -> Pattern
12:12:05 <rwbarton> ' in the middle of a quasiquoter invocation
12:12:09 <vixey> 6.9 needs to compile though
12:12:15 <r3m0t> > let foo ('h':'a':'r':'d':xs) = xs in foo "hard stuff"
12:12:15 <rwbarton> vixey: so true
12:12:16 <lambdabot>  " stuff"
12:12:27 <mmorrow> Toxaris: well, this is just about the most trivial quasiquoter though, it could be doing arbitrarily complex things with it's input to arrive at the pattern it finally splices in
12:12:29 <rwbarton> r3m0t: Right, that's the pattern the quasiquoter should build
12:12:40 <vixey> I also wonder about things like
12:12:56 <Toxaris> mmorrow: yes, but most pattern quasiquoters (all?) want to allow general subpatterns
12:13:02 <vixey> splits :: [a] -> [(a,a)]
12:13:03 <vixey> splits [$?|x ++ y|] = (x,y)
12:13:12 <vixey> but that's not possible is it?
12:13:39 <mmorrow> Toxaris: yeah, that capability would have to be implemented w/in the qq's parser
12:14:07 <mmorrow> Toxaris: so it's a tradeoff, sometimes inconvenient, sometimes convenient
12:14:24 <Toxaris> mmorrow: consider [$pre|"prefix here" ++ x : y : [$pre|"nested prefix" ++ rest|]|] = x : y : rest
12:14:47 <mmorrow> Toxaris: ohhhh, i gotcha. i'm working on a haskell quasiquoter that'll do that :)
12:14:48 <Toxaris> I would expect that to be possible in a useful prefix pattern matcher
12:15:14 <rwbarton> So first of all, is that even valid syntax?  Or does the first |] close the first [$pre| ?
12:15:23 <mmorrow> Toxaris: so that would require the quasiquoter to parse haskell, manipulate it, do the subsplices, then splice itself
12:15:30 <Toxaris> rwbarton: hehe probably yes
12:15:59 <mmorrow> so, it'd be more like:
12:16:01 <Toxaris> my feeling is that quasiquotation is broken
12:16:16 <Toxaris> since it doesn't allow for sensible nesting
12:16:17 <newsham> TH has support for parsing haskell
12:16:24 <Toxaris> but pattern matching is *about* sensible nesting
12:16:27 <vixey> I just want to use it :/
12:16:31 <Toxaris> and expression too
12:16:31 <mmorrow> [$fullhaskellPlusExtensions|"prefix here" ++ x : y : [$pre|"nested prefix" ++ rest|]|] = x : y : res
12:17:39 <Toxaris> mmorrow: ?
12:17:54 <mmorrow> Toxaris: i think what you're missing is that _the entire contents of [$qq|***here***|] are passed to the parser which qq implements (qq being some qq :: QuasiQuoter)
12:18:06 <mmorrow> as a *String*
12:18:18 <rwbarton> f (stripPrefix "prefix here" => x : y : (stripPrefix "nested prefix" => rest)) = x : y : rest
12:18:32 <rwbarton> that works already
12:18:39 <rwbarton> (I think/hope)
12:18:41 <mmorrow> heh, nice
12:18:45 <Toxaris> mmorrow: I'm aware of that
12:19:18 <vixey> mmorrow: So wouldn't fullhaskellPlusExtension be given this string:
12:19:21 <mmorrow> so, "sensible nesting" would require one to implement a haskell parser to handle that
12:19:26 <vixey> "prefix here" ++ x : y : [$pre|"nested prefix" ++ rest
12:19:30 <mmorrow> vixey: exactly
12:19:30 <vixey> ?
12:19:53 <vixey> which is a problem..
12:19:58 <Toxaris> yep, as I said when rwbarton raised the same point, in my eyes QQ is broken if it doesn't allow that
12:20:07 <vixey> it's not broken
12:20:10 <vixey> just doesn't nest
12:20:23 <Toxaris> that's broken enough
12:20:39 <Toxaris> all patterns nest, except the patterns I can define myself, so I cannot define real patterns, only broken ones
12:20:44 <rwbarton> I don't think it's really intended for this kind of thing.  More for parsing literal syntax of some other language, in which case nesting doesn't make quite as much sense
12:21:01 <rwbarton> view patterns handle this case nicely, at least
12:21:07 <Toxaris> isn't the standard example from same paper / whatever an interpreter?
12:21:44 <mmorrow> Toxaris: my only point is that, in order to achieve that (say     foo 'x':'y':xs) , you'd do so by doing    foo [$hs|prefix here" ++ x : y : [$pre|"nested prefix" ++ rest|]|]
12:21:56 <mmorrow> s/(say     foo 'x':'y':xs)//
12:22:44 <rwbarton> mmorrow: See what happens if you try to compile [$pre|...[$pre|...|]|] -- I suspect a parse error
12:22:59 <mmorrow> Toxaris: the only thing is that isn't it isn't implemented, so i'm implementing it myself :)
12:23:07 <mmorrow> rwbarton: ^^
12:23:19 <rwbarton> mmorrow: You can't implement your way around a parse error
12:23:35 <Toxaris> rwbarton: he could invent new syntax
12:23:36 <mmorrow> rwbarton: [$hs|...[$pre|...\|]|] ;)
12:23:45 <Toxaris> but that's, well, horrible?
12:23:48 <mmorrow> hahaha
12:23:49 <mmorrow> i know
12:24:01 <Toxaris> welcome to quoting hell
12:24:02 <rwbarton> a couple more levels of nesting and it starts looking like emacs lisp
12:24:09 <mmorrow> Toxaris: yeah
12:24:15 <Toxaris> ((,,,`(``,,`()))))))))
12:24:29 * Toxaris forgot some '
12:24:34 <lispy> suppose I have, tryFoo :: ... -> IO (Either String Foo)
12:24:49 <lispy> and suppose I wan to refactor this to an error monad
12:25:03 <Cale> I don't understand the need to have a $ in the first part of the quasiquote....
12:25:17 <Cale> Is that just to make parsing use less backtracking?
12:25:18 <rwbarton> more like "\\\\(foo|\\\\(ba\\\\(r\\\\|z\\\\)\\\\)\\\\)"  (sorry for the line noise
12:25:27 <lispy> tryFoo :: MonadError m String => m ... IO (m String Foo)
12:25:52 <lispy> Is there an even better way to combine the IO (m ...) ?
12:25:58 <lispy> like a MonadIOError ?
12:26:17 <mmorrow> Cale: my understanding is that was one of the few ways to add the syntax without ambiguity to the parser
12:26:29 <lispy> I guess not because the MonadError is just inside the IO but not really using it
12:26:45 <mmorrow> i've tried messing with the haskell-src-exts parser, and parsing haskell is *hard*
12:26:58 <Cale> mmorrow: wouldn't the presence of |] basically disambiguate it?
12:27:11 <mmorrow> just _one little change_    5 shift/reduce errors  ----->   97 shift/reduce errors ,  9 reduce/reduce errors
12:27:14 <rwbarton> lispy: You could look into the MonadTrans class... but I don't know what that would buy you
12:27:20 <Cale> hmmm...
12:27:28 <Cale> > [1|]
12:27:28 <lambdabot>  Parse error at "]" (column 4)
12:27:51 <Cale> right, you can't have an empty list of generators/conditions...
12:27:57 <mmorrow> Cale: i don't know in particular though, wrt the $ in there, what exactly that conflicts with/ambiguates
12:28:15 <mmorrow> err, i meant, if you were to drop the $, ...
12:28:17 <Cale> I think it would look prettier without the $
12:28:20 <mmorrow> me too
12:28:42 <lispy> Cale: you could email the list and ask why the $ is tehre
12:28:47 <lispy> I mean the ghc dev list
12:28:53 <Cale> mm... perhaps I will :)
12:29:12 <mmorrow> Cale: hmm, i'll try to hack the haskell-src-exts parser to *not* use $, and see how it goes (i'm currently trying to add [$||] anyways)
12:29:28 <Cale> I was also thinking there are things like [t| ... |], but couldn't those be subsumed into the quasiquoter?
12:29:29 <Deewiant> > [1 | otherwise]
12:29:30 <lambdabot>  [1]
12:30:33 <Cale> also, if that's what the ambiguity is, that's pretty lame
12:31:19 <mmorrow> Cale: yeah, the only thing is though, quasiquoters can be put into expression *and* pattern context, while [t||]/etc can't be in pattern ctxt
12:31:40 <afidegnum> hello good morning alll
12:31:52 <Cale> Well, you'd still get an error.
12:31:53 <mmorrow> Cale: i'd be very interested to hear the rationale for the $
12:32:06 <mmorrow> i agree that it's ugly for sure
12:32:33 <Cale> afidegnum: hello
12:33:16 <rwbarton> [|qq|string|] would be nice
12:33:48 <newsham> is there a name for \e -> e `seq` e    ?
12:33:55 <Deewiant> newsham: id
12:33:57 <ddarius> newsham: Yes, id.
12:33:57 <heatsink> newsham: id
12:34:02 <vixey> join seq ?
12:34:10 <mmorrow> currently, i've only added support for   [$qq| ... |] to the lexer
12:34:19 <chr1s> chrisdone: I just uplodad formlets-0.4, with support for monadic actions.
12:34:22 <Deewiant> join seq = id
12:34:29 <newsham> doesnt e `seq` e   force some evaluation?
12:34:36 <Deewiant> no more than just e
12:34:40 <chr1s> newsham: exactly
12:34:43 <Deewiant> because if it's being evaluated in the first place
12:34:46 <vixey> isn't that, to take the WHNF of e, it has to first take the WHNF of e?
12:34:48 <Toxaris> newsham: e `seq` e will force e to be evaluated when e is evaluated
12:34:50 <TomMD> @source id
12:34:51 <lambdabot> id not available
12:34:51 <vixey> i.e. exactly the same as e
12:34:52 <Deewiant> then putting it through seq is pointless
12:35:02 <Deewiant> and useless
12:35:04 <newsham> bos bayfp talk:   where f x y = let a = k * x + y in a `seq` a
12:35:07 <vixey> or is that not even what seq does
12:35:09 <vixey> ?
12:35:09 <afidegnum> I m just coming to this channel.
12:35:27 <Deewiant> vixey: seq evaluates to WHNF, yes.
12:35:32 <ddarius> newsham: Yes, that's a bug.
12:35:38 <afidegnum> I would like to know if haskell programming s also another way of programming,or it si a programmnig language on its own
12:35:38 <afidegnum> ?
12:35:43 <ddarius> newsham: He got a decent chunk of flak about that.
12:35:46 <vixey> http://neilmitchell.blogspot.com/2008/05/bad-strictness.html
12:35:46 <lambdabot> Title: Neil Mitchell's Haskell Blog: Bad strictness
12:35:54 <Deewiant> vixey: ah, I was looking for that.
12:35:57 <vixey> afidegnum: both
12:36:32 <afidegnum> explain a bit, I am a php, javascript, java programmer. how wil it help?
12:36:32 <TomMD> afidegnum: I think many programming language encourage their own style in which to program.  Haskell does this more than most others.
12:36:33 <heatsink> afidegnum: Haskell's language features strongly encourage a style of programming different from most languages.
12:36:36 <Toxaris> afidegnum: Haskell is a programming language, but it is somewhat different from mainstream languages like c, Java, Perl etc., so Haskell programming is different from mainstream programming
12:37:24 <afidegnum> so how can I use ti to help in my daily project i.e web development/
12:37:25 <afidegnum> ?
12:37:44 <heatsink> afidegnum: Programming in Haskell tends to be declarative: much like writing a mathematical formula, a program looks more like a definition of what result you want and less like instructions for creating the result.
12:37:54 <ddarius> afidegnum: Why did you decide to come to this channel in the first place?
12:38:02 <Cale> afidegnum: Well, there are some web frameworks for Haskell... it's a bit embryonic as of yet.
12:38:49 <Cale> afidegnum: But possibly usable if you're interested. There are also some rather interesting tools, like a recently released library for parsing and manipulating Javascript code.
12:38:57 <lispy> ?hoogle Either a b -> Bool
12:38:58 <lambdabot> No matches, try a more general search
12:39:05 <Cale> also, YHC is working on support for compiling Haskell to Javascript.
12:39:11 <ddarius> either (const True) (const False)
12:39:12 <lispy> ?hoogle isright
12:39:13 <lambdabot> No matches found
12:39:22 <ddarius> @hoogle isLeft
12:39:22 <lambdabot> No matches found
12:39:26 <TomMD> afidegnum: I suggest you go though a couple of tutorials to gain some understanding of / experience with Haskell.  Haskell's type system is the best I've used in a production ready language - it really helps program structure, thus complementing maintainability as well as correctness.  IMO, Haskell's light weight threads also offers a great abstraction allowing pipelines of operations without a crazy explosion of OS processes or threads.
12:39:46 <mmorrow> afidegnum: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/WebBits
12:39:48 <lambdabot> Title: HackageDB: WebBits-0.9.1, http://tinyurl.com/69thsd
12:40:12 <rwbarton> afidegnum: As an example, you can use Haskell's type system to make sure you never mix up strings with different kinds of quoting (none, HTML, HTTP request, SQL, etc.)
12:40:20 <mmorrow> afidegnum: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Web
12:40:21 <lambdabot> Title: HackageDB: packages by category
12:40:29 <Cale> afidegnum: If you'd like my summary of why someone might enjoy programming in Haskell... I have something I could link you to.
12:41:07 <Cale> http://www.reddit.com/comments/2bxc1/ask_reddit_what_is_haskell_good_for/c2bzw7
12:41:08 <aes2> What about having an STRef that can only be written once and when used incorrectly generates a compile time error?
12:41:08 <lambdabot> Title: cgibbard comments on Ask Reddit: What is Haskell good for?, http://tinyurl.com/6lngs8
12:41:40 <Toxaris> I just stumpled over http://hackage.haskell.org/packages/archive/applicative-extras/0.1.3/doc/html/Control-Applicative-Compose.html: Is there a good reason to use a + for functor composition? it feels totally wrong.
12:41:41 <lambdabot> http://tinyurl.com/5ud3lu
12:42:03 <vixey> aes2: not sure but I think you'd have to use substructural typing for that, which haskell doesn't have
12:43:07 <aes2> In GHC Oleg can fake dependent types, so it should be possible; I just don't know how.
12:43:30 <Cale> Toxaris: I agree... I would probably use something else as well.
12:43:43 <Leaves> Hello, I want to have the digits of a number in a list, currently I use map digitToInt (show n), do you know if there already exists a function for this? (I don't like digitToInt)
12:43:48 <Cale> Toxaris: :+: looks like, well, a coproduct or something.
12:44:14 <vixey> aes2: Well I don't think it's possible
12:44:22 <mmorrow> afidegnum, anyone interested: here are the examples example from the yhc2js haskell->javascript tutorial:
12:44:26 <mmorrow> http://lunar.moonpatio.com/code/misc/yhcjs-eg-080802/hs/
12:44:29 <vixey> aes2: btw you can't do this with dependent types anyway
12:44:31 <aes2> I believe I already figured it out.
12:44:34 <mmorrow> http://lunar.moonpatio.com/code/misc/yhcjs-eg-080802/html/
12:44:37 <aes2> It's not that difficult.
12:44:46 <aes2> vixey: of course you can.
12:44:53 <vixey> aes2: no you can't
12:45:28 <mmorrow> i like this one in particular:
12:45:30 <mmorrow> http://lunar.moonpatio.com/code/misc/yhcjs-eg-080802/html/TutEx4.html
12:45:35 <aes2> vixey: and why not?
12:45:38 <mmorrow> http://lunar.moonpatio.com/code/misc/yhcjs-eg-080802/hs/TutEx4.hs.html
12:45:43 <byorgey> Leaves: no, I don't think there's already a function to do that
12:45:49 <vixey> aes2: deptypes still have weakening etc.
12:45:50 <rwbarton> mmorrow: You persist in believing that we can resolve lunar.moonpatio.com :)
12:45:53 <byorgey> Leaves: map digitToInt . show  is how I would do it
12:45:54 <mmorrow> crap!
12:46:09 <mmorrow> 207.58.166.174
12:46:17 <Toxaris> vixey, aes2: I think that should be possible, but not using the normal monadic >>=
12:46:20 <mmorrow> http://207.58.166.174/code/misc/yhcjs-eg-080802/
12:46:21 <lambdabot> Title: Index of /code/misc/yhcjs-eg-080802
12:46:31 <Leaves> byorgey: ok, then I will do that, I din't like the conversion to char and back so much, thanks
12:46:57 <byorgey> Leaves: it does kind of feel like a hack, I know what you mean =)
12:47:04 <pozic> vixey: In this discussion with Associat0r we established already that this is possible.
12:47:16 <Cale> Leaves: You can of course write something purely numerical using unfoldr
12:47:23 <rwbarton> Hello World in just 3000 lines of javascript
12:47:46 <Cale> or map/takeWhile/iterate
12:47:47 <mmorrow> haha, and 2 lines of haskell
12:48:04 <Leaves> Cale: I will look into unfoldr
12:48:10 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 47381924
12:48:12 <lambdabot>  [4,2,9,1,8,3,7,4]
12:48:28 <vixey> pozic: Do you have code that does this?
12:48:29 <aes2> I will just write the "impossible" then.
12:48:31 <Cale> Of course it's reversed because we kind of write numbers backwards :)
12:48:36 <Toxaris> vixey, aes2: instead, somewhat obviously, the new tell function would be tell & >>= fused into one, e.g. tell :: (TellAllowed before label value, DisallowTell before label after) => before -> label -> value -> after
12:48:39 <Cale> > reverse .map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 47381924
12:48:41 <lambdabot>  [4,7,3,8,1,9,2,4]
12:48:54 <mmorrow> this one's interesting: http://207.58.166.174/code/misc/yhcjs-eg-080802/hs/TutEx3.hs.html
12:48:54 <lambdabot> Title: Haskell code
12:49:08 <ddarius> > let digits n ds | q == 0 = r:ds | otherwise = digits q (r:ds) where (q,r) = divMod n 10 in digits 1534 []
12:49:09 <vixey> aes2: please do show me once it's done :p
12:49:09 <lambdabot>  [1,5,3,4]
12:49:15 <aes2> Toxaris: wonderful
12:49:34 <Toxaris> vixey, aes2: now you can use type-level sets to encode TellAllowed, and DisallowTell is just type-level set minus
12:49:39 <aes2> tibbe: I was thinking of another generic approach for one variable.
12:50:01 <tibbe> aes2: I guess that was meant for somebody else :)
12:50:10 <aes2> Toxaris: that was for you.
12:50:20 <aes2> tibbe: yes
12:51:34 <Leaves> Cale and ddarius, thanks for your suggestions! I will study them both (that will take some time) :)
12:51:47 <Toxaris> aes2: oleg would probably say something like "in fact, this can already be done in Haskell using the HList library" :)
12:52:05 <Leaves> Cale: may I aks why you use backquotes to change a normal function to infix? don't you want them to be normal?
12:52:17 <aes2> Toxaris: the HList library Haddock documentation is slightly inaccessible.
12:52:22 <rwbarton> Leaves: Note that neither suggestion handles 0 in the traditional way
12:52:35 <ddarius> > let digits n ds | q == 0 = r:ds | otherwise = digits q (r:ds) where (q,r) = divMod n 10 in digits 0 []
12:52:36 <lambdabot>  [0]
12:52:40 <mmorrow> tibbe: how did your benchmarks of  h(Put|Get)(Buf|Array|) go? (i didn't notice the hGetBuf/hPutBuf at first glance...i think i like that one more that hGetArray/hPutArray, since you can explicitly deallocate the buffer)
12:52:51 <rwbarton> Oh, hmm.
12:52:57 <rwbarton> I couldn't actually read that one :P
12:53:34 <tibbe> mmorrow: Buf and Array are on par and ByteString is around 10% slower
12:53:53 <tibbe> mmorrow: I created a new hackage package which I used for the benchmarking :D
12:54:00 <Toxaris> Leaves: (`foo` x) /= (foo x), but (`foo` x) == (flip foo x) == (\x y -> foo y), so (`foo` x) is an idiom to avoid flip, and for binary, numeric operators like mod and div, infix feels natural, too
12:54:02 <tibbe> mmorrow: check out benchpress ;)
12:54:07 <mmorrow> tibbe: cool! did you upload it yet?
12:54:08 <bwr> Would it be possible to use something like parsec to "generate" the parts of the input that are static. For instance say I wanted to input an xml document of a certain format. Say for super simplicity, it was of the form <a> <b>1</b> <b>2</b> </a> .. the library I want to write should allow you to define the format of a document and fill in the parts that have to be there. so it would automatically do the <a> part and then allow you to do one or more <b> </b>
12:54:13 * mmorrow checks hackage
12:54:13 <tibbe> mmorrow: yes
12:54:16 <mmorrow> nice
12:54:34 <mmorrow> heh, benchpress
12:54:45 <tibbe> mmorrow: all you need to do is: bench numIters $ liftIO $ yourIOAction
12:55:00 <tibbe> mmorrow: and you get some nice stats such as mean, stddev and percentiles
12:55:34 <b\6> hmm. someone please explain again about gadts and whether they help the situation where you need to define a data constructor in terms of another one in the same type.
12:55:40 <Leaves> Toxaris: ok, I see, thank you
12:57:17 <rwbarton> I'm not sure exactly what you mean by "define a data constructor in terms of another one"... can you elaborate?
12:57:22 <SamB> bwr: you mean like SGML?
12:57:50 <tibbe> mmorrow: I see that the docs haven't been built yet
12:57:52 <SamB> bwr: anyway what you want doesn't really sounds like it has anything to do with parsec
12:57:56 <mmorrow> tibbe: cool, just installed it.
12:58:07 <bwr> SamB: hmm, maybe not
12:58:10 <tibbe> mmorrow: did it install cleanly (always good to know)?
12:58:11 <mmorrow> tibbe: just built the docs and am viewing them locally as well :)
12:58:17 <mmorrow> tibbe: nice and clean
12:58:19 <TomMD> @hackage benchpress
12:58:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/benchpress
12:58:37 <b\6> rwbarton: data XValue = XString String | XDict (M.Map XString XValue), this sort of situation.
12:59:03 <mmorrow> tibbe:  once i have something nontrivial to test with it, i'm gonna check it out. i'll let you know how it goes :)
12:59:09 <rwbarton> So you want to say that the keys of the map are XValues, but they always happen to be XStrings.
12:59:18 <b\6> yeah.
13:00:02 <vixey> Has anybody tried writing programs with YNot?
13:00:03 <tibbe> mmorrow: hopefully I've gotten overheads of the timing down enough
13:00:08 <vixey> It's supposed to be like Haskell
13:00:25 <tibbe> mmorrow: I think it's better for testing longer running functions for now
13:00:27 <ddarius> vixey: Why would I want to program in a language "like" Haskell?
13:00:43 <tibbe> mmorrow: or you can make sure that your IO action runs a fast function 1000 times or so
13:00:48 <vixey> ddarius: Because haskell is almost perfect!
13:01:00 <ddarius> vixey: So why would I want another language?
13:01:10 <tibbe> mmorrow: I'm gonna add a size parameter to the benchmark function to make that easier
13:01:15 <Toxaris> ddarius: maybe the other language is nearer to being perfect
13:01:15 <idnar> ddarius: because it might be perfect!
13:01:16 <mmorrow> tibbe: ah, true
13:01:21 <mmorrow> tibbe: cool
13:01:32 <SamB> who made YNot?
13:01:38 <mmorrow> tibbe: do you have a darcs repo anywhere?
13:01:39 <SamB> and why'd they call it that?
13:01:45 * SamB waits for it
13:01:45 <tibbe> mmorrow: but it's create for testing i.e. file copying or network requests as their execution times are in the order of milliseconds
13:01:48 <vixey> ddarius: More expressive type system and automatic program derivation (I am guessing these are two things YNot supports better than haskell)
13:01:49 <Toxaris> SamB: (Wh)YNot?
13:02:06 <vixey> ddarius: But I haven't tried it.... don't rreally have any test case program to write with it
13:02:11 <tibbe> mmorrow: http://github.com/tibbe/benchpress/tree/master
13:02:14 <lambdabot> Title: tibbe's benchpress at master — GitHub
13:02:22 <mmorrow> tibbe: perfect
13:02:31 <vixey> SamB: there's a list of people on http://www.eecs.harvard.edu/~greg/ynot/
13:02:33 <lambdabot> Title: Ynot
13:02:41 <vixey> ho
13:02:47 <vixey> I think there's a hash table written in it
13:02:51 * tibbe checks if cabal supports defining a VCS link yet
13:02:59 <vixey> but I don't know if the source code is around
13:03:02 <rwbarton> b\6: So I think you could write data Foo ; data Bar ; data XValue a where XString :: String -> XString Foo ; XDict :: M.Map (XValue Foo) XValue -> XValue Bar
13:03:11 <rwbarton> b\6: I don't know whether this is a useful thing to do
13:03:13 <vixey> anyway, ... I guess nobody has used it
13:03:39 <b\6> rwbarton: thanks, studying.
13:03:59 * ddarius would just write data XValue = XString String | XDict (M.Map String XValue) ...
13:04:17 <vixey> oh
13:04:31 <vixey> ddarius: Are you still working on a prolog/lollimon language?
13:04:53 <ddarius> vixey: Yes and no.  I'm not in a coding phase right now, but I will get back to it.
13:04:58 <rwbarton> I suspect the path of least resistance is to use ddarius's simpler solution
13:05:10 <tibbe> mmorrow: it's too bad that I can't put a Git link in the .cabal file. I think that having that would make people contribute more
13:05:13 <vixey> ddarius: good :) It'd be a shame if you ditched it.....
13:06:07 <afidegnum> hello
13:06:10 <afidegnum> sorry I was quite away
13:06:18 <SamB> tibbe: yeah, there should be a field or two for listing VCS and URL...
13:06:27 <afidegnum> in fact, I was browsing through the list of available channels and I come accross ths
13:06:37 <SamB> dcoutts: is there a ticket about this?
13:06:56 <afidegnum> so I am trying to get familiar with what is hte whole Haskell game show is all about1
13:07:16 <tibbe> SamB: there is, I'm looking for it so I can add myself to the CC list
13:07:19 <SamB> afidegnum: we have a game show now?
13:07:44 <SamB> tibbe: how do you know it exists if you don't know the ticket number?
13:07:58 <SamB> er. or have the URL.
13:08:01 <stepcut> I'll take Oleg for $500 please
13:08:09 <SamB> stepcut: daring!
13:08:31 <tibbe> SamB: http://hackage.haskell.org/trac/hackage/ticket/58
13:08:33 <lambdabot> Title: #58 (allow darcs repo to be specified in cabal file) - Hackage - Trac
13:08:44 <tibbe> SamB: search? ;)
13:09:09 <SamB> not "how do you find out"
13:11:29 <tibbe> SamB: oh, I remember seeing it before
13:13:54 <hackage> Uploaded to hackage: formlets 0.4
13:33:31 <byorgey> afidegnum: the haskell wiki is a great place to start:  www.haskell.org
13:33:37 <byorgey> afidegnum: and feel free to ask questions in here
13:33:44 <lambdapants> greetings haskellers.  I have a teeny problem.
13:33:54 <byorgey> lambdas in your pants?
13:34:11 <byorgey> sounds uncomfortable.
13:34:16 <lambdapants> Well I guess I haven't named them so they are anonymous :)
13:34:22 <Korollary> higher order pants for the win
13:34:43 <byorgey> hehe
13:34:53 <byorgey> lambdapants: ok, what's your real problem?
13:35:01 <lambdapants> anyways, asides from the existential properties of my pants, I have a problem distributing compiled haskell code
13:35:23 <lambdapants> I have a HAppS application, which I'd like to upload to my server
13:35:35 <lambdapants> but it won't run the binary
13:36:05 <b\6> you compile and run on different systems?
13:36:07 <lambdapants> I was wondering if theres an easy way around it, without compiling everything again, on the server.
13:36:22 <b\6> what happens when you try to run it?
13:36:45 <lambdapants> cannot run binary file
13:36:45 <lambdapants> it must be a linker error, I guess
13:36:53 <lambdapants> but I can't really think what to do!
13:37:24 <b\6> what does 'file' say about it?
13:38:00 <lambdapants> elf binary
13:38:44 <lambdapants> uhhh... I better go find out exactly... give me a minute.
13:39:27 <lambdapants> I kinda get pissed off and delete things.
13:40:12 <b\6> but it really won't run after getting rmed.
13:40:29 <dogbite_> but 'rm' runs
13:41:11 <b\6> if rm were his web application, we'd be all set.
13:41:17 <dogbite_> sisterhood of the traveling lambda pants
13:42:37 <lambdapants> you loons are a laugh :)
13:44:05 <dogbite_> thank you very little
13:44:17 <Korollary> rm on rails could be interesting
13:44:42 <lambdapants> rm is my paradigm
13:45:05 <lambdapants> as such it should be suggested to it managers everywhere.
13:45:19 <b\6> rm should make a new copy of my hard disk with that one file gone.
13:47:17 <Quadrescence> Is there an easy way to do lower-level memory stuff in haskell? Like store two 4-bit values in an 8-bit type?
13:47:28 <erikc> the Storable class
13:47:46 <vixey> Quadrescence: um... (,)
13:47:50 <Cale> Quadrescence: For working with bits, there's Data.Bits, for interfacing with external memory formats, there's Foreign.Storable
13:48:04 <vixey> Quadrescence: Really can you not avoid breaking open objects?
13:48:10 <vixey> (into the internal rep.)
13:48:22 <Quadrescence> vixey: I just want to save memory.
13:48:23 <erikc> b-b-b-but, the bits!
13:48:26 <Cale> But yeah, if your real goal is to store a pair, then store a pair.
13:48:32 <vixey> Quadrescence: That's probably a very bad ideaa
13:48:41 <Cale> Are you running out of memory?
13:48:46 <Quadrescence> I will run out.
13:48:47 <vixey> Quadrescence: Usually that kind of thing causes more problems than it solves (in my exp.)
13:48:57 <Quadrescence> Cale: This is the rubik's cube stuff
13:49:01 <vixey> what is the actual data?
13:49:08 <Cale> Quadrescence: what are you storing?
13:49:13 <Quadrescence> Cube positions.
13:49:21 <Cale> How many?
13:49:52 <Cale> Really, you should be able to write a decent Rubik's cube solver without so much memory usage :)
13:50:04 <Quadrescence> Cale: This is flexible.
13:50:08 <Quadrescence> It's not really a cube solver.
13:50:13 <Cale> Still...
13:50:14 <Quadrescence> But a general permutation-puzzle solver.
13:50:19 <Cale> Yeah.
13:50:31 <Quadrescence> And it doesn't just solve, it finds good/tailored solutions.
13:50:44 <lambdapants> I figured out me problem
13:50:44 <lambdapants> I want to rm things so bad my doctor makes me diazapam a lot ---- I totally thought I'd already `file`d it
13:50:44 <lambdapants> the file is dynamically linked
13:50:44 <lambdapants> I will statically link it, and reattempt
13:50:44 <lambdapants> from scotland, wishing you well, happy haskelling.  toodledo.
13:51:01 <pozic> Quadrescence: so you do a brute-force search?
13:51:17 <dogbite_> lambdapants: keep the static links out of your pants
13:52:20 <Quadrescence> pozic: At the most basic level, kind of.
13:52:50 <Quadrescence> Blah, I just installed Linux too, so I don't have ghc or anything installed.
13:53:27 <pozic> Quadrescence: then I don't see why that should take more memory than the size of the puzzle.
13:53:49 <Quadrescence> pozic: I'm storing multiple puzzle states
13:53:57 <pozic> Quadrescence: and why would you do that?
13:53:58 <Elly> premature optimization is the root of all evil
13:54:19 <pozic> Quadrescence: genetic algorithms?
13:54:22 <Quadrescence> pozic: To find optimal solutions.
13:54:25 <pozic> Quadrescence: and those kinds of things?
13:54:30 <Quadrescence> Maybe.
13:54:40 <pozic> Quadrescence: maybe doesn't mean anything.
13:54:49 <pozic> Quadrescence: either you do, or you don't.
13:54:55 <Quadrescence> It is a large tree search, essentially.
13:55:05 <Quadrescence> (it's actually several)
13:55:25 <Quadrescence> The puzzle is solved in, let's say, 4 steps.
13:55:34 <Quadrescence> It finds all possible positions for those 4 steps.
13:55:35 <pozic> Quadrescence: "tree search" is not part of the problem, AIUI.
13:55:38 <Cale> Quadrescence: Generally, unless you have a computer with an absolutely tremendous amount of memory, I don't think you're going to be able to find optimal solutions for something like the cube group.
13:55:44 <Cale> At least not in general.
13:55:48 <vixey> Quadrescence: Maybe you can use a Trie
13:56:09 <Quadrescence> Cale: It's actually subgroups of the entire group. Of course we can't for the entire cube group
13:56:36 <Quadrescence> Cale: I break it down in to manageable sized groups, and solve those.
13:56:44 <Cale> okay
13:57:04 <pozic> Quadrescence: so, it's a specialized smart brute-force search.
13:57:16 <Quadrescence> Yes
13:57:41 <Quadrescence> With pruning and all that as I see it.
13:58:05 <pozic> For pruning you also don't need extra memory.
13:58:07 <Elly> so define "manageable" such that you don't need to optimize for memory?
13:58:32 <pozic> It's probably storing the sub-problems that's causing the memory problems.
13:58:50 <Quadrescence> pozic: I haven't even written the code.
13:59:21 <Quadrescence> Elly: I am looking for special moves to solve certain things.
13:59:23 <Elly> then don't worry about memory use yet :P
13:59:30 <Quadrescence> I need to plan.
13:59:38 <pozic> Quadrescence: so, you already magically established that doing bit-level optimizations is going to save you.
13:59:38 <Elly> not really
13:59:41 <pozic> Quadrescence: ?
13:59:53 <Elly> don't start optimizing until you have a profiling run in hand that says you need to
13:59:59 <Elly> anything else is guesswork
14:00:03 <Cale> Cube = (Z_3^7 × Z_2^11)
14:00:05 <vixey> hi Elly
14:00:06 <Cale> oops
14:00:09 <Elly> hi vixey
14:00:14 <vixey>  I am so tired
14:00:16 <vixey> =_=
14:00:19 <Elly> I am playing Freelancer
14:00:22 <Elly> and it is the weekend
14:00:24 <Elly> so all is well
14:00:49 <vixey> hey Elly did you ever see Escape Velocity?
14:01:07 <vixey> I guess it's like the 90s version of Freelancer
14:01:15 <Quadrescence> pozic: example: number of stored positions * number of pieces in the puzzle * number of bits necessary to represent a piece
14:01:26 <Cale> Cube = (Z_3^7 × Z_2^11) ⋊ ((A_8 × A_12) ⋊ Z_2)
14:01:33 <vixey> and in the 80s, there's elite? I'm not sure
14:01:49 <vixey> Cale, :t (⋊) -- ?
14:02:06 <Cale> vixey: It's the semidirect product of groups.
14:02:13 <vixey> ee....
14:02:23 <vixey> I've got to look that up
14:02:52 <Cale> vixey: So it takes two groups and produces another... however, there's a bit of extra information you need to specify exactly how that happens.
14:02:53 <vixey> oh I see
14:03:02 <Cale> (which is left out here)
14:03:02 <Elly> vixey: yeah, I did
14:03:03 <vixey> it's like cartesianProductBy (?something)
14:03:05 <Elly> vixey: that's a good game too
14:03:09 <Quadrescence> GHC better be easy to set up GHC on linux. :D
14:03:13 <Cale> A_12 is order 239500800
14:03:16 <Elly> vixey: Freelancer runs under Wine :D
14:03:33 <pozic> Quadrescence: aptitude install ghc6 on Debian.
14:03:53 <Elly> on gentoo, emerge ghc
14:04:03 <Cale> However, to exhaustively search it shouldn't require as much memory as that.
14:04:10 <Elly> on fedora, I think it's yum install ghc6
14:04:28 <Quadrescence> Cale: I'll have to think more.
14:06:14 <Quadrescence> For the normal 3x3 cube, I would actually store the positions as a 4-tuple
14:06:32 <vixey> what 4-tuple?
14:06:44 <Quadrescence> (int,int,int,int)
14:06:51 <vixey> what are the ints?
14:06:53 <Cale> which 4 ints?
14:07:18 <Quadrescence> (Orientation of corners, Orientation of edges, permutation of corners, permutation of edges)
14:07:28 <Quadrescence> They are actually each an index of the aforementioned.
14:07:40 <vixey> oh I see
14:08:08 <Quadrescence> Using factoradics for the permutations, and a fixed-base number system for the orientations.
14:08:15 <Cale> Indices are a bit awkward to work with, aren't they?
14:08:48 <Quadrescence> Incredibly. But if I store them to a file or whatever, it's better.
14:08:56 <Quadrescence> Or make tables
14:08:59 <bwr> what does an error message like (following) indicate? $ runghc Setup.hs configure
14:08:59 <Quadrescence> Or anything else.
14:09:03 <bwr> Setup.hs: nanocurses.cabal:9: 'Executable' stanza starting with field 'stability'
14:09:37 <Cale> Function/Integer pairs are a simpler representation to deal with.
14:10:08 <Quadrescence> Cale: Well, I'd have a conversion between what I work with and what I store
14:11:03 <Quadrescence> The 4-tuple is just a way to save the state of the cube.
14:11:11 <Quadrescence> It would also make comparisons easy I suppose
14:11:40 <byorgey> bwr: do you have a blank line before that
14:11:47 <bwr> byorgey: no
14:12:04 <bwr> byorgey: that is the only line of output
14:12:32 <dmwit> bwr: He probably means in the cabal file.
14:12:45 <bwr> oh, i've never used cabal before so i'm a little confused
14:12:46 <byorgey> bwr: sorry, I meant, is there a blank line before the 'stability' line in the .cabal file
14:12:57 <bwr> byorgey: yes, there is
14:13:09 <byorgey> ok, there shouldn't be =)
14:13:32 <bwr> so i should remove the blank lines?
14:13:42 <humasect> @hpaste
14:13:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:14:05 <vixey> yeah
14:14:07 <humasect> http://hpaste.org/9494  <-- is this leaking like crazy, or is it just me ?
14:14:44 <byorgey> bwr: yes
14:14:54 <humasect> rather, is it just 'ghc api'
14:15:28 <bwr> byorgey: ok thanks, looks like my version of ghc is out of date now :)
14:40:05 <dogbite_> cabal: ld is required but it could not be found.
14:40:18 <dogbite_> any quick ideas?
14:40:33 <dogbite_> i'm trying to install command line hoogle
14:40:48 <|Steve|> You need bintools installed.
14:41:26 <|Steve|> Actually, that's probably just part of gcc.
14:41:31 <dogbite_> hmmm
14:41:35 <dogbite_> i'm on os x
14:41:46 <|Steve|> Then install Xcode.
14:41:50 <SamB> |Steve|: binutils, and ld is part of that
14:41:58 <|Steve|> Okay.
14:42:00 <SamB> but gcc more-or-less needs binutils anyway
14:42:04 <|Steve|> Right.
14:42:10 <|Steve|> It's been a while since I've built gcc myself.
14:42:25 <dogbite_> oh
14:42:30 <SamB> (on some OSes it might not need binutils -- but usually those are OSes where cc isn't just a symlink to gcc ;-)
14:42:32 <dogbite_> well this is a new machine... damn
14:42:40 <dogbite_> i think i need to install devel stuff... i forgot
14:42:48 <|Steve|> dogbite_: I told you, install Xcode.
14:42:48 <dogbite_> i don't think that's in os x by default
14:42:57 <dogbite_> oh i see i missed it
14:43:00 <dogbite_> my mistake
14:43:09 <SamB> installers that install gcc generally make sure ld gets installed as well
14:43:09 <|Steve|> And make sure you installed the bsd tools otherwise it won't stick copies into /usr.
14:43:13 <SamB> and so forth
14:44:48 <dogbite_> thanks guys
14:44:56 <|Steve|> np
14:46:10 <dogbite_> well this is a fool's errand at this point.  i'm on a wireless card at the airport, heh
14:46:24 <dogbite_> flight's delayed but now by 2.5 hours!
14:46:29 <|Steve|> At least you have internet.
14:47:11 <dogbite_> anything quick i can download so i have haskell docs without internet?
14:47:39 <Korollary> the libraries, ghc user manual and the report have html tarballs
14:48:26 <MyCatVerbs> dogbite_: http://www.haskell.org/ghc/docs/latest/users_guide.html.tar.gz http://www.haskell.org/ghc/docs/latest/libraries.html.tar.gz <-- GHC manual and library documentation tarballs.
14:48:38 <MyCatVerbs> (Respectively.)
14:48:42 <dogbite_> thanks!
14:49:40 <MyCatVerbs> No worries. I would suggest you also keep a copy of something like YAHT or the Gentle Introduction on-hand just in case you forget some random corner of Haskell syntax.
14:49:53 <Korollary> cabal also has a doc tarball
14:50:38 <mmorrow> vixey, dolio, anyone else trying to build ghc6.9: here's a tarball of the the last ghc6.9 i successfully built. i did make distclean, then packaged it, so i've already run darcs-all --extra get, so it has all the libraries already. whatever you do, *don't darcs pull ;)*     http://code.haskell.org/~morrow/ghc/ghc-6.9.20080619.tar.bz2
14:51:09 <vixey> yay
14:51:12 * vixey tries.
14:51:17 <mmorrow> yay
14:51:25 <mmorrow> lemme know if it does in fact work
14:51:37 <mmorrow> if not, i'll package an earlier snapshot
14:51:57 <mmorrow> (but it should work because i built that one)
14:52:25 <mmorrow> vixey: oh, also make sure you have all the editline libs installed  (libedit.so, ?)
14:52:50 <mmorrow> or ghci will be impossible to work in ;)
14:54:26 <MyCatVerbs> mmorrow: be fair, it's not *impossible*. Just painful enough to make you consider using Perl instead. ;P
14:55:03 <mmorrow> uhhm, such a thing sounds scary
14:55:28 <mmorrow> MyCatVerbs: what are you refering to?? (building current ghc-HEAD?)
14:55:35 <vixey> mmorrow: So just do   ./configure  then  make?
14:56:06 <mmorrow> vixey: yeah, but you may want to ./configure --prefix=/usr/local/ghc/ghc-6.9.20080619 or something
14:56:15 <MyCatVerbs> mmorrow: ghci with neither libedit nor libreadline. Sorry if that wasn't clear.
14:56:52 <mmorrow> MyCatVerbs: ohhh, haha. *definitely* painful enough to make you consider using Perl instead
14:57:11 <mmorrow> it shoulda been clear, my mind was elsewhere
14:58:14 <vixey> :/
14:58:15 <vixey> ghc-6.8.3: unrecognised flags: -fspec-constr-count=100
14:58:28 <mmorrow> oh, i added that to mk/build.mk ;)
14:58:50 <mmorrow> just do rm mk/build.mk
14:59:13 <MyCatVerbs> vixey: I strongly second mmorrow's suggestion. It's kinda handy to have a little shellscript hanging around the place which will do the whole configure, make, make install dance targetting, say, /usr/local/ghc/ghc-`date +%s`, which then makes a symlink from /usr/local/ghc/ghc-HEAD to the `date +%s` directory.
14:59:15 <mmorrow> (i built that on using an earlier 6.9)
14:59:43 <MyCatVerbs> Er, s/which then/and then goes and/
15:00:06 <mmorrow> MyCatVerbs: yeah, totally. i have one around somewhere, but i can't seem to find it currently...
15:01:12 <MyCatVerbs> vixey: well, if you plan on hunting down bug introductions, anyway. If not, just doing something like targetting /usr/local/ghcHEAD, and always rm -r'ing the old ghcHEAD just before make install'ing the new one works too.
15:01:30 * vixey just wants to play with views and QQ :p
15:01:39 <MyCatVerbs> Personally, I prefer to install into my homedir rather than /usr/local, but that's just me.
15:02:05 <dons> we've not seen much written about views or QQ yet.
15:02:13 <dons> views I think have a huge range of applications.
15:02:18 <vixey> dons: well nobody can try them out yet :[
15:02:20 <dons> perhaps people who are using them could start blogging about it?
15:02:26 <dons> vixey: waiting for ghc to unbreak?
15:02:33 <mmorrow> i've been meaning to write about QQ and TH...
15:02:37 <vixey> dons: well I am trying to get it to compile right now
15:02:50 <dons> if it doesn't, complain loudly on #ghc and on the lists.
15:02:54 <mmorrow> i need to setup a friggin blog and i'm a lazy bum
15:02:56 <dons> breaking the tree should just be illegal.
15:03:21 <vixey> dons: well I had a go at fixing it myself but I got nowhere
15:03:30 <vixey> anyway
15:03:39 <dons> ok. make sure you report it.
15:03:47 <mmorrow> dons: she's trying to build a snapshot of head i put up, which is the last one i successfully built
15:03:48 <dons> we need to build up pressure not to break trees.
15:04:11 <mmorrow> i haven't been able to build the current head for about a month
15:04:24 <mmorrow> http://code.haskell.org/~morrow/ghc/ghc-6.9.20080619.tar.bz2
15:04:41 <camio> :r
15:05:40 <waern> mmorrow: I guess you're on osx/windows?
15:05:46 <mmorrow> linux
15:06:06 <mmorrow> waern: why?
15:06:09 <waern> hm, ok, I built head a few days ago
15:06:17 <mmorrow> oh, nice!
15:06:23 <mmorrow> i haven't tried for maybe a week
15:06:43 <waern> the only problem I had was empty package.conf files being installed, so I'm using the inplace compiler
15:06:49 <waern> ok
15:06:54 <mmorrow> i hate that bug!
15:07:16 <waern> hehe, yep, pretty annoying
15:08:01 <Quadrescence> Ugh, not programming for a few weeks makes me forget everything.
15:08:32 * vixey should try not programming
15:11:35 <MyCatVerbs> dons: I got the impression that when Data.Graph.Inductive's author finds out about view patterns' introduction, he's going to go dancing on the town. ;P
15:11:57 <mmorrow> or singing in the rain
15:11:59 <SamB> MyCatVerbs: has he announced plans to do this when he finds out?
15:12:22 <dons> MyCatVerbs: Erwig's kind of quiet. so i'd encourage someone else to do that :)
15:12:38 <mmorrow> vixey: it's still building without having an error??
15:12:49 <MyCatVerbs> SamB: I haven't heard anything about that, it's just that I got the impression (from the paper) that he'd happily kill small woodland animals for them while writing FGL.
15:12:52 <vixey> nothing went boom so far
15:13:06 <mmorrow> vixey: yay! i bet it'll work then
15:13:17 * vixey is hoping
15:16:21 <Quadrescence> I forgot so much, I even forgot user input.
15:16:23 <Quadrescence> :((((((
15:16:26 <camio> Anyone know what the roman symbol is for different densities of infinities? I want to say alev.
15:16:31 <bwr> @pl \c n k->product[n-k+1..n]`div`product[2..k]
15:16:31 <lambdabot> const ((`ap` (product . enumFromTo 2)) . ((div . product) .) . (flip =<< (enumFromTo .) . flip flip 1 . ((+) .) . (-)))
15:16:37 <vixey> yes aleph the first letter
15:16:42 <Quadrescence> camio: They are hebrew
15:16:46 <camio> vixey: Thanks.
15:16:46 <Quadrescence> Aleph, beth
15:16:56 <camio> Ah, I didn't know that.
15:17:02 <vixey> א
15:17:14 <Quadrescence> vixey: slut
15:17:49 <mmorrow> w/ subscript 0,1,... where aleph_0 is Z
15:17:59 <mmorrow> s/Z/|Z|/
15:19:01 <camio> Writing semantic domains in haskell is fun. I can't run it, but it's fun.
15:19:01 <mmorrow> re: aleph_1, see cantor
15:20:09 <byorgey> camio: did you really mean 'roman' symbol?  aleph is hebrew.
15:20:36 <camio> byorgey: I meant greek.
15:20:41 <camio> byorgey: But was mistakin.
15:20:48 <byorgey> camio: ah, ok =)
15:21:32 <Quadrescence> Cantor was crazy.
15:21:55 <camio> Yeah, who in his right mind would use a hebrew symbol?
15:22:25 <mmorrow> to nitpick...i think it should be s/roman/latin/
15:22:27 <MyCatVerbs> A mathematician who's tired of seeing people overload the Greek alphabet. :P
15:22:30 <vixey> I like the hebrew symbols
15:23:18 <MyCatVerbs> vixey: I strongly prefer real variable names. >>
15:23:40 <vixey> they are just long symbol
15:23:52 <camio> I'm waiting for a mathematician to whip out the chinese symbol for dragon.
15:25:08 <mapreduce> How does Haskell deal with allocating and releasing resources in IO?
15:25:26 <roconnor> @hoogle bracket
15:25:26 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:25:26 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
15:25:26 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:26:02 <mapreduce> I know bracket and have greenspunned a version of it in Java and Scala -- is that the typical way?
15:26:03 <MyCatVerbs> camio: it'll be used to denote the xkcd number, A(g_64,g_64). As in, "this figure will _eat_ almost any numbering system you care to attempt to store it in".
15:26:18 <MyCatVerbs> Er, represent, not store.
15:26:58 <shapr> emma: hej
15:27:24 <emma> hej! hur ar det?!
15:27:38 <shapr> bra! och du?
15:29:54 <Quadrescence> Okay, so how would I get a String, an Int, and another Int from the user, make a tuple out of them (String, Int, Int), and cons that to a list [(String, Int, Int)]?
15:30:26 <mapreduce> Quadrescence: I recommend the section on IO in the Haskell wikibook.
15:30:33 <Quadrescence> mapreduce: Okay.
15:30:42 <mapreduce> (And I particularly recommend grabbing the PDF of that book)
15:30:51 <dons> dcoutts: packages that 'implicitly' depend on alex, or other preprocessors, based on discovering extensions on files are irksome.
15:30:56 <dons> configure time dependencies should be banished!
15:31:34 <camio> Quadrescence: I'm not sure how you would do it, I'd do liftM (:list) read
15:31:45 <Peaker> print combines putStrLn and show. What combines getLine and read?
15:32:11 <vixey> :t readLine
15:32:24 <ddarius> :t readLn
15:32:25 <lambdabot> forall a. (Read a) => IO a
15:32:25 <mapreduce> :t read >>= getLine
15:32:39 <roconnor> @src readLine
15:32:39 <lambdabot> Source not found. Where did you learn to type?
15:32:52 <camio> :t liftM (:) readLn
15:32:53 <lambdabot> forall a1. (Read a1) => IO ([a1] -> [a1])
15:32:56 <vixey> :t read . getLine
15:32:56 <lambdabot> forall a. (Read a) => IO a
15:33:04 <roconnor> @src readLn
15:33:04 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
15:33:18 <mapreduce> @hoogle (Read a) => IO a
15:33:18 <lambdabot> Prelude.readLn :: Read a => IO a
15:33:18 <lambdabot> System.IO.readLn :: Read a => IO a
15:33:18 <lambdabot> System.Exit.exitFailure :: IO a
15:33:29 <Peaker> @type readIO
15:33:29 <lambdabot> forall a. (Read a) => String -> IO a
15:33:37 <roconnor> @src readIO
15:33:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:33:45 <roconnor> what the heck is readIO?
15:34:03 <ddarius> roconnor: It's what readM would be if you instantiated it to IO
15:34:20 <mapreduce> :t System.IO.readIO
15:34:21 <lambdabot> forall a. (Read a) => String -> IO a
15:34:23 <roconnor> it throws exceptions instead of errors?
15:34:42 <Peaker> @type readM
15:34:43 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
15:35:19 <mapreduce> Is there a standard solution in Haskell for the problem of not having named parameters?
15:35:33 <mmorrow> dons: so are you saying the package creator should preproc .x and .y files and put only the .hs files in the tree (and the .x and .y somewhere else if they wish)?
15:35:34 <mapreduce> Eg., python's foo(x: bar, y: baz)
15:35:40 <Twey_> mapreduce: No
15:35:47 <Peaker> Python's foo(x=bar, y=baz)
15:35:50 <idnar> mapreduce: that's foo(x=bar, y=baz)
15:35:52 <idnar> heh
15:36:00 <camio> mapreduce: Yes, I think, using record syntax Thing { a=12, b=123}
15:36:16 <idnar> camio: that's for constructors, not normal functions
15:36:39 <camio> idnar: It is very handy for functions with lots of arguments.
15:36:43 <vixey> "the problem of not having named parameters"?
15:36:54 <Peaker> data Args = Args { a, b, c :: Integer } ; f (Args a b c) = a*b*c --  that's not so bad
15:37:13 <dons> mmorrow: that there should be a preprocessor: Alex
15:37:13 <dons> field
15:37:20 <mapreduce> vixey: It is easy to get the order of parameters wrong, especially if you change the order after you write uses of the function.
15:37:37 <vixey> I haven't had that in my experience
15:37:58 <Peaker> mapreduce: unless you're lucky enough that the params are of different types :)
15:38:00 <idnar> mapreduce: don't change existing interfaces :P
15:38:38 <mmorrow> dons: ah, i see. i usually put     build-tools: alex, happy      , is this equivalent ?
15:38:42 <MyCatVerbs> mapreduce: I only get that on code I'm still halfway through writing, and usually then the typechecker picks up on it immediately.
15:38:50 <dons> mmorrow: hmm.
15:38:54 <mapreduce> MyCatVerbs: Usually, sure.
15:38:56 <dons> i wonder if there's a way to enforce that.
15:39:05 <mapreduce> I'd like an always.
15:39:05 <dons> if we could reliably detect alex, happy, that makes my life easier.
15:39:33 <mmorrow> i do so because i saw some other package do it that way. i didn't know you could put alex/happy in the preproc
15:40:12 <MyCatVerbs> mapreduce: problem: attempting to make the ordering of params insignificant gets in the way of partial application.
15:41:09 <mapreduce> MyCatVerbs: Agreed.  It could be used as an aid for checking rather than for making the order insignificant.
15:42:14 <MyCatVerbs> mapreduce: I really can't concieve of any way of doing this that doesn't involve masses of fingerwork.
15:42:55 <camio> Most partial application is an artifact of our surface syntax. It's a shame.
15:42:58 <MyCatVerbs> mapreduce: besides which, if I have two different params with identical type, I'm equally likely to brainfart and swap their names as to brainfart and swap their ordering. YMMV, but that's what tends to hit me.
15:43:48 <mapreduce> MyCatVerbs: Sure.  I was just looking for ideas, thanks.
15:43:57 <Peaker> camio: there are some cases where you want a partial call, and its really nice that the syntax is supportive.. But for the majority of cases it only complicates error messages and makes things like named args hard, imo :(
15:44:44 <camio> Peaker: I really like the partial application ideas in eros.
15:44:52 <Peaker> MyCatVerbs: really? How likely are you to accidentally write: position=size, size=pos ?
15:45:03 <Peaker> camio: TV eros?
15:45:08 <mapreduce> One could conceive of something like x 5 <<< y 6 <<< z 10 or something, just using existing Haskell - I probably got this dreadfully wrong though.
15:45:17 <camio> Peaker: Yeah tangible values.
15:45:31 <camio> Peaker: The deeparrow concept.
15:45:47 <Peaker> camio: I don't recall that from the google talk
15:46:03 <camio> Peaker: It's in the paper.
15:46:13 <Peaker> camio: ah, I didn't read it, I guess I should
15:46:14 <camio> I haven't seen the talk.
15:46:38 <ziman> argument types are sufficient hints for param ordering most of the time, imo
15:48:41 <mapreduce> Yeah, unless you're working with someone who thinks adding types makes things complicated.
15:49:08 <camio> mapreduce: oh?
15:49:18 <MyCatVerbs> Peaker: evidently you haven't seen any of my output. ;P
15:49:24 <jamii> i dont suppose there are any cpp wizards about?
15:49:41 <camio> jamii: I was in a previous life.
15:49:43 <mapreduce> I think he could say "dynamic typing is bad" and "let's store everything in ints" in the same breath :)
15:49:51 <dmwit> jamii: As in C preprocessor or C++?
15:49:52 <mapreduce> jamii: Visual Studio has some, afaik.
15:49:58 <MyCatVerbs> Peaker: point taken, but it's more common for me to do things like pass semantically-interesting sets, lists, maps, etc, the wrong way around.
15:49:58 <Peaker> MyCatVerbs: I think incorrectly giving positional args is _far far_ more likely than incorrectly giving named args
15:50:04 <dmwit> mapreduce: funny =)
15:50:17 <jamii> dmwit: preprocessor. Im doing word length dependent arithmetic in haskell
15:50:34 <dmwit> oooo, nasty
15:50:42 <jamii> Its not too bad
15:51:35 <jamii> I was using 'wordLength = sizeBits (undefined :: Word'
15:51:41 <jamii> I wanted to change it to this http://hpaste.org/9496
15:51:50 <jamii> But it always falls through to the undefined case
15:52:06 <vixey> jamii: shouldn't it be a single =
15:52:30 <jamii> vixey: No, single = is illegal in cpp. I guess because its assign in c
15:53:43 <Draconx> jamii, #elif
15:53:48 <jamii> oh
15:54:32 <Peaker> jamii: did you base this off some example from somewhere, or did you write it from scratch hoping it would get parsed correctly?
15:56:05 <Peaker> Funny that #elseif doesn't run inside the false'd if, so you don't even get an error for it
15:56:43 <camio> Anyone know how to get the upper bound of doubles?
15:56:57 <jamii> Peaker: A bit of both. I copied it from here: http://hpaste.org/9497
15:57:00 <vixey> > maxBound :: Double
15:57:01 <lambdabot>   add an instance declaration for (Bounded Double)
15:57:01 <lambdabot>     In the expression: max...
15:57:13 <vixey> looks like they don't have one
15:57:19 <MyCatVerbs> camio: there isn't one. IEEE floating point includes values for positive and negative infinities.
15:57:23 <shapr> hiya vixey !
15:57:28 <ddarius> > 1/0
15:57:29 <lambdabot>  Infinity
15:57:30 <mmorrow> vixey: still building?
15:57:42 <vixey> hey shapr
15:57:48 <jamii> vixey look at decodeFloar
15:57:55 <jamii> :t decodeFloat
15:57:55 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
15:58:00 <vixey> mmorrow: yes
15:58:14 <vixey> shapr: I was listening to AngloHaskell
15:58:27 <shapr> vixey: Cool, how was it?
15:58:34 <vixey> well
15:58:41 <camio> Any ideas on how to get one for the upper bound for non-infinite doubles?
15:58:46 <vixey> they were having a break and I heard somebody open some crisps or something
15:58:49 <MyCatVerbs> camio: the maximum -finite- Float value is just under 2^128, I think.
15:58:52 <shapr> heh
15:58:53 <vixey> I didn't hear any talks
15:59:19 <MyCatVerbs> camio: for Doubles, it'll be about around 2^1024, I believe.
15:59:42 <vixey> > 2^1024
15:59:44 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:59:47 <vixey> > 2^1024+1
15:59:48 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:59:55 <dmwit> That's an Integer.
16:00:03 <dmwit> > 2**1024 :: Double
16:00:04 <lambdabot>  Infinity
16:00:06 <jamii> >encodeFloat 1 maxBound
16:00:10 <jamii> > encodeFloat 1 maxBound
16:00:11 <lambdabot>  Infinity
16:00:16 <jamii> Oh
16:00:20 <dmwit> > maxBound :: Double
16:00:21 <lambdabot>   add an instance declaration for (Bounded Double)
16:00:21 <lambdabot>     In the expression: max...
16:00:25 <dmwit> ah, too bad
16:00:36 <MyCatVerbs> > encodeFloat 1 126
16:00:37 <lambdabot>  8.507059173023462e37
16:00:49 <vixey> mmorrow: I think it's building stage2 no
16:00:49 <camio> IEE floats are so weird it's amazing they are used at all.
16:00:51 <vixey> now*
16:01:00 <dmwit> > 2**1023 :: Double
16:01:01 <lambdabot>  8.98846567431158e307
16:01:15 <dmwit> > encodeFloat 1 127
16:01:17 <lambdabot>  1.7014118346046924e38
16:01:23 <dmwit> > encodeFloat 1 1023
16:01:25 <lambdabot>  8.98846567431158e307
16:01:29 <dmwit> interesting
16:01:53 <Toxaris> > let d = d :: Double in (floatRange d, floatRadix d)
16:01:54 <lambdabot>  ((-1021,1024),2)
16:02:32 <Toxaris> > let d = d :: Double in floatDigits d
16:02:33 <lambdabot>  53
16:02:43 <dmwit> > (floatRange &&& floatRadix) (undefined :: Double)
16:02:44 <lambdabot>  ((-1021,1024),2)
16:03:08 <vixey> ugh
16:03:14 <vixey> mmorrow I don't even know what this means
16:03:16 <vixey> ld: scattered reloc r_address too large for inferred architecture i386
16:03:16 <vixey> make[2]: *** [HSghc.o] Error 1
16:03:20 <Toxaris> > 2 ^ 1024 - (2 ^ (1024 - 53))
16:03:21 <lambdabot>  1797693134862315708145274237317043567980705675258449965989174768031572607800...
16:03:31 <vixey> but it bailed out on that
16:04:10 <MyCatVerbs> > (encodeFloat ((2^128)-(2^104)) 0) :: Float
16:04:11 <lambdabot>  3.4028235e38
16:04:26 <MyCatVerbs> Right. There's your maximum for Floats, I believe.
16:04:36 <dmwit> > 3.4028236e38 :: Float
16:04:37 <lambdabot>  Infinity
16:04:48 <camio> nice, thanks.
16:04:49 <Toxaris> I think the highest Double should be (0.1111 * 2^1024), with 53 1's
16:04:54 <mmorrow> vixey: hmm, you're on a mac, right?
16:05:17 <dmwit> Toxaris: 0.1111... is in binary, I guess?
16:05:23 <Toxaris> dmwit: yes of course :)
16:05:35 * dmwit nods
16:05:39 <MyCatVerbs> > (encodeFloat ((2^1024)-(2^992) 0) :: Double
16:05:39 <lambdabot> Unbalanced parentheses
16:06:00 <dmwit> > (encodeFloat ((2^1024)-(2^992)) 0) :: Double
16:06:01 <lambdabot>  1.7976931344437579e308
16:06:03 <MyCatVerbs> Whoops. Ah, that isn't correct anyway. *pokes*
16:06:04 <mmorrow> vixey: because if so, somehow it carried over some configuration info from my i386 it seems (or i dunno wtf)
16:06:30 <mmorrow> vixey: as in #ghc
16:06:31 <Toxaris> > 1024 - 992 -- ?
16:06:33 <lambdabot>  32
16:06:36 <vixey> yeah I am
16:06:38 <Toxaris> dmwit: why 32?
16:06:45 <MyCatVerbs> > (encodeFloat ((2^1024)-(2^971)) 0) :: Double
16:06:47 <lambdabot>  1.7976931348623157e308
16:06:50 <mmorrow> vixey: good
16:06:55 <dmwit> Toxaris: I was just fixing MyCatVerbs' query.
16:06:57 <MyCatVerbs> Toxaris: because I got it wrong. It should be 53, IIRC.
16:06:58 <camio> MyCat: Not that big of a deal. I was really looking for something built in.
16:07:31 <MyCatVerbs> camio: for most purposes, you may take those ranges as "wide enough". ;P
16:07:38 <Toxaris> > let d = d :: Double in floatDigits d -- yep 53 of course
16:07:39 <lambdabot>  53
16:08:20 <jamii> This still falls through http://hpaste.org/9498
16:08:25 <MyCatVerbs> Oh right.
16:08:32 <jamii> I guess the elseif wasnt the only problem
16:09:22 <olsner> wordLength = WORD_SIZE_IN_BITS
16:09:27 <mmorrow> vixey: ohhh, i guess you're on an *intel* mac
16:09:31 <olsner> plobrem sloved?
16:09:36 <MyCatVerbs> Toxaris: hah. Double is 1 sign + 11 exponent + 52 mantissa. I thought it was 54, but of course that resulted from me counting the "free" digit you get (by assuming that the lead digit is always 1) twice. Oops.
16:09:50 <jamii> olsner: Nope. ghc is fussy about where you use cpp macros
16:10:10 <Quadrescence> !hoogle [Int] -> [Int]
16:10:16 <Quadrescence> Is that a command here?
16:10:18 <olsner> oh, I thought it like... actually preprocessed the source
16:10:25 <dons> ?hoogle [Int] -> [Int]
16:10:25 <lambdabot> No matches, try a more general search
16:10:29 <Quadrescence> Okay
16:10:30 <dons> ?hoogle [a] -> [a]
16:10:30 <lambdabot> Prelude.tail :: [a] -> [a]
16:10:31 <lambdabot> Prelude.init :: [a] -> [a]
16:10:31 <lambdabot> Prelude.reverse :: [a] -> [a]
16:10:42 <Quadrescence> ?hoogle String -> Int
16:10:43 <lambdabot> No matches, try a more general search
16:10:46 <Toxaris> MyCatVerbs: sounds reasonable, so my formula is crap, dmwit
16:10:48 <Quadrescence> :\
16:11:09 <Toxaris> MyCatVerbs: since it's 1.111...111 * 2 ^ 1024, with 52 ones
16:11:13 <dons> Quadrescence: you want 'read' ?
16:11:20 <dons> ?hoogle String -> a
16:11:21 <lambdabot> Prelude.error :: String -> a
16:11:21 <lambdabot> Debug.Trace.trace :: String -> a -> a
16:11:21 <lambdabot> Prelude.fail :: Monad m => String -> m a
16:11:23 <erikc> sigh, i hate oo
16:11:27 <dons> ?hoogle+
16:11:28 <lambdabot> Prelude.read :: Read a => String -> a
16:11:28 <lambdabot> Data.String.fromString :: IsString a => String -> a
16:11:28 <lambdabot> Control.Monad.fail :: Monad m => String -> m a
16:11:30 <jamii> olsner: Its supposed to. Its not very reliable. I tried that earlier and got "Not in scope: data constructor WORD_...
16:11:47 <MyCatVerbs> Toxaris: right, yeah. But I'm too lazy to type all those ones out, so I raise to one-greater power and subtract a unit in what should be the last place. :)
16:11:48 <olsner> maybe the macro is undefined
16:11:53 <vixey> mmorrow: yes
16:12:00 <Quadrescence> I just want to convert a string to a number
16:12:02 <Quadrescence> integer
16:12:16 <Toxaris> MyCatVerbs: yeah me too, but I assumed a 0 in front, so my result was only half of the real thing I guess
16:12:19 <dons> Quadrescence: 'read'
16:12:25 <dons> > read "142" :: Integer
16:12:26 <lambdabot>  142
16:12:29 <Toxaris> > read "42" :: Integer
16:12:30 <lambdabot>  42
16:12:33 <jamii> dons: Is WORD_SIZE_IN_BITS defined in Data.Binary or is it built into ghc. I cant find it anywhere
16:12:42 <dons> jamii: its a header ghc provides.
16:12:44 <dons> let's see.
16:13:00 <dons> #if WORD_SIZE_IN_BITS < 64
16:13:04 <olsner> haskell modules can't define preprocessor macros, can they?
16:13:04 <dons> {-# LANGUAGE CPP #-}
16:13:04 <dons> {-# OPTIONS_GHC -fglasgow-exts #-}
16:13:10 <dons> #if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
16:13:10 <dons> #include "MachDeps.h"
16:13:10 <dons> #endif
16:13:13 <dons> is what you need.
16:13:19 <dons> MachDeps.h comes with ghc.
16:13:32 <MyCatVerbs> Toxaris: hee. No, IEE754 has this beautiful hack where you assume that the starting digit can -never- be zero, and then you encode zeroes and infinities by setting both the exponent and mantissa to their minimum and maximum possible values, respectively.
16:13:42 <jamii> ah, i didnt know i needed to include anything. thanks
16:13:57 <hackage> Uploaded to hackage: cabal2arch 0.3.8.1
16:13:57 <hackage> Uploaded to hackage: cabal2arch 0.3.8
16:14:23 <MyCatVerbs> Toxaris: (also, a floating-point number representation beginning with an 0 would have multiple redundant ways to encode some numbers, which would suck.)
16:14:28 <Toxaris> MyCatVerbs: yeah I used to know such stuff
16:14:41 <MyCatVerbs> Er, I mean, a FP representation that *allowed* beginning with an 0, etc.
16:15:00 <MyCatVerbs> Toxaris: low-level details are fun. :)
16:15:24 <MyCatVerbs> Toxaris: provided they're actually that way for a good reason, I mean. Low-level details that come about for bad reasons are just squicky. :/
16:15:38 <Toxaris> MyCatVerbs: so what is the highest finite value of a RealFloat instance?
16:16:02 <jamii> olsner: You can define your own include files
16:17:32 <MyCatVerbs> Toxaris: mmm... ooh, I think I have it.
16:17:45 <olsner> maximum exponent, maximum-1 mantissa?
16:20:37 <MyCatVerbs> @let floatUpperBound f = let (_,mexp) = floatRange f in encodeFloat ((2^mexp)-(2^(mexp-(floatDigits f)))) 0
16:20:38 <lambdabot> Defined.
16:20:43 <olsner> or maximum-1 exponent, maximum mantissa ... maximum exponent seems to be a NaN
16:20:50 <Toxaris> olsner: or the other way around?
16:21:07 <MyCatVerbs> > (floatUpperBound undefined,floatUpperBound undefined) :: (Float,Double)
16:21:08 <lambdabot>  (Infinity,1.7976931348623157e308)
16:21:11 <Toxaris> olsner: I think the "special values" are encoded by maximum exponent
16:21:24 <MyCatVerbs> Ah, pants. Why does that work differently for Float and Double?
16:21:34 <Toxaris> MyCatVerbs: both undefined default to Double
16:21:50 <MyCatVerbs> Oh. Heh.
16:21:57 <Toxaris> > (floatUpperBound (undefined :: Float),floatUpperBound undefined) :: (Float,Double)
16:21:58 <lambdabot>  (3.4028235e38,1.7976931348623157e308)
16:22:03 <olsner> Toxaris: i.e., what I said the second time?
16:22:04 <MyCatVerbs> Toxaris: thanks. :)
16:22:11 <Toxaris> olsner: yes I guess so
16:22:19 <Baughn> @type floatUpperBound
16:22:20 <lambdabot> forall a a1. (RealFloat a, RealFloat a1) => a -> a1
16:22:21 <Toxaris> olsner: with a strong accent on guessing :)
16:22:49 <|Steve|> > printf "%s %s %x" "a" "b" 42
16:22:49 <lambdabot>  Add a type signature
16:23:06 <olsner> http://babbage.cs.qc.edu/IEEE-754/32bit.html entering 0x7f7fffff here should give you the largest float
16:23:06 <lambdabot> Title: IEEE-754 Floating-Point Conversion from 32-bit Hexadecimal to Floating-Point
16:23:06 <Baughn> > printf "%s %s %x" "a" "b" 42 :: String
16:23:07 <lambdabot>  "a b 2a"
16:23:30 <Toxaris> > (floatUpperBound `asTypeOf` id) undefined :: Float
16:23:31 <lambdabot>  3.4028235e38
16:23:31 <|Steve|> When running that in  ghci, I get a b 2a*** Exception: Prelude.undefined
16:23:45 <Toxaris> MyCatVerbs: I guess you want an explicit type signature for floatUpperBound
16:23:58 <|Steve|> How does printf work?
16:24:02 <MyCatVerbs> @undefine floatUpperBound
16:24:03 <Baughn> > printf "%x %s not %x" 43 "or" 43
16:24:03 <lambdabot>  Add a type signature
16:24:04 <lambdabot> Undefined.
16:24:05 <Baughn> > printf "%x %s not %x" 43 "or" 43 :: String
16:24:06 <lambdabot>  "2b or not 2b"
16:24:13 <Baughn> |Steve|: Evil typeclass tricks
16:24:20 <dmwit> |Steve|: By typeclass hackery! =D
16:24:29 <dmwit> return-type polymorphism is confusing and great
16:24:29 <|Steve|> @src printf
16:24:30 <lambdabot> Source not found. My mind is going. I can feel it.
16:24:36 <dmwit> ?source Text.Printf
16:24:36 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
16:25:10 <Baughn> > printf "%x %s not %x" 43 "or" "um" :: String
16:25:11 <lambdabot>  "2b or not Exception: Printf.printf: bad argument
16:25:35 <Baughn> Goodie. Runtime type-checking.
16:26:09 <|Steve|> I thought the types were gone at runtime.
16:26:27 <Baughn> Not if you write typeclasses that embody them, like printf does
16:26:34 <MyCatVerbs> @let floatBound = let { fB f = let (lexp,mexp) = floatRange f in let mantissa = ((2^mexp)-(2^(mexp-(floatDigits f)))) in (encodeFloat mantissa 0,encodeFloat mantissa (lexp-mexp) } in fB :: (RealFloat a) => a -> (a,a)
16:26:35 <lambdabot>  Parse error
16:26:45 <MyCatVerbs> Damn. Should've expected that.
16:26:52 <Toxaris> |Steve|: you can explicitly keep them if you feel a need. There is Data.Typable and Data.Dynamic to help you.
16:27:59 <Toxaris> @let foo :: Int -> Int
16:28:00 <lambdabot> <local>:1:0: Not in scope: `foo'
16:28:08 <Toxaris> @let foo = id
16:28:09 <lambdabot> Defined.
16:28:12 <Toxaris> @let foo :: Int -> Int
16:28:12 <lambdabot> Defined.
16:28:19 <Toxaris> :t foo
16:28:20 <lambdabot> Int -> Int
16:28:23 <olsner> |Steve|: it's kind of like it's getting compiled into a function taking a string and checking that it finds a %s in the format (giving a run-time error when it finds %x)... that string-taking function may not need runtime type informtion since it's compiled specifically for string
16:28:32 <Toxaris> > foo 42
16:28:32 <lambdabot>  42
16:28:35 <Baughn> @let foo :: a -> Int
16:28:35 <lambdabot> <local>:3:0:     Duplicate type signature:       <local>:3:0-14: foo :: a -> ...
16:29:08 <Toxaris> > foo 42
16:29:09 <lambdabot>  42
16:29:17 <mmorrow> vixey: what Xcode version do you have?
16:29:20 <Toxaris> Baughn: you cannot break my foo :)
16:29:32 <Baughn> @let foo = 42
16:29:32 <lambdabot> <local>:3:0:     Multiple declarations of `L.foo'     Declared at: <local>:1:...
16:29:46 <|Steve|> Oh I see.
16:30:02 <vixey> mmorrow: 3.0
16:30:26 <mmorrow> good!
16:30:31 <Toxaris> @let bar 1 = 42
16:30:31 <lambdabot> Defined.
16:30:34 <Toxaris> @let bar 2 = 23
16:30:34 <lambdabot> Defined.
16:30:34 <mmorrow> i think it'll work then if you get..
16:30:38 <mmorrow> "Apple has responded to the "Bug ID #: 5637618 (PPC Leopard (Xcode 3.0) linker ld reports "unknown scattered relocation type 4")", saying that this issue has been addressed in "the latest seed release of Xcode 3.1, build 9M2165"
16:30:38 <Toxaris> @let bar :: Int -> Int
16:30:39 <lambdabot> Defined.
16:30:41 <Baughn> |Steve|: Or rather, the function taking a string, checking the format string for %s and possibly throwing an error is part of the PrintfArg typeclass
16:30:45 <Toxaris> @let bar 3 = 17
16:30:45 <lambdabot> <local>:6:0:     Multiple declarations of `L.bar'     Declared at: <local>:3:...
16:30:54 <mmorrow> see related tickets: http://hackage.haskell.org/trac/ghc/ticket/1843
16:30:55 <Toxaris> seems to be semi-clever
16:30:55 <lambdabot> Title: #1843 (ghc 6.8.1 broken on Mac OS X Leopard PPC) - GHC - Trac
16:31:04 <mmorrow> that one in particular
16:31:07 <mmorrow> and
16:31:08 <mmorrow> http://hackage.haskell.org/trac/ghc/ticket/1845
16:31:09 <lambdabot> Title: #1845 (unconditional relative branch out of range (GHC version 6.8.1/6.8.2 for p ...
16:31:25 <Baughn> > bar 42
16:31:26 <lambdabot>  Exception: <local>:(3,0)-(4,9): Non-exhaustive patterns in function bar
16:31:34 <mmorrow> i found that by searching for "r_address" here: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2008-January.txt
16:31:36 <lambdabot> http://tinyurl.com/6zj93f
16:31:38 <Toxaris> > map bar [1, 2, 3]
16:31:39 <lambdabot>  [42,23,Exception: <local>:(3,0)-(4,9): Non-exhaustive patterns in function bar
16:32:04 <Toxaris> it would be cool to evaluate expressions in the scope of a module on hpaste
16:32:04 <MyCatVerbs> Whorebiscuits. Finally get the thing to typecheck, turns out I've screwed up the definition.
16:32:43 <olsner> MyCatVerbs: you built a haskell program with a runtime failure!? :P
16:33:16 <|Steve|> Actually no, I don't follow how this is working at all.
16:33:20 <mmorrow> vixey: also, there is this msg, but i think the author is mistaken (since this ghc is from before the patch he says caused the problem): http://www.haskell.org/pipermail/cvs-ghc/2008-July/043864.html
16:33:21 <lambdabot> Title: OS X 10.5 build failure
16:33:28 <MyCatVerbs> olsner: seems like it.
16:33:37 <dmwit> |Steve|: Don't think of it as run-time type checking.  It's still statically type-checked.
16:33:41 <vixey> oh I see
16:33:45 <vixey> ok I have to upgrade
16:33:48 <mmorrow> vixey: so i think it's.
16:33:49 <mmorrow> yeah
16:33:51 <dmwit> |Steve|: What happens at runtime is *argument*-checking on the first formatting string argument.
16:33:53 <vixey> I can't really do that though at the moment
16:34:00 <vixey> I'll try to tommorow
16:34:02 <|Steve|> dmwit: No, that I understand. It's how printf works  at all that I'm not  getting.
16:34:06 <mmorrow> vixey: cool
16:34:16 <dmwit> ah
16:34:24 <|Steve|> It just does a data UPrintf = UChar Char | ..., that's easy.
16:35:09 <Toxaris> dmwit: is argument-checking an euphemism for "the part of type checking we can't do there"?
16:35:18 <Toxaris> @type printf
16:35:19 <lambdabot> forall r. (PrintfType r) => String -> r
16:35:32 <dmwit> Toxaris: It's a euphemism for "dependent typing", I guess.
16:35:52 <Toxaris> |Steve|: consider the type of printf. it takes a string and returns some r
16:35:52 <Baughn> @instances-importing Text.Printf PrintfType
16:35:53 <lambdabot> (a -> r), IO a, [c]
16:36:04 <olsner> the real printf of which Text.Printf is an approximation is a type-level program to parse the format string, combined with an execution program that does the formatting
16:36:15 <|Steve|> Toxaris: Right, so how does passing multiple arguments to printf work?
16:36:36 <Toxaris> |Steve|: let's say r = Int -> Int -> String -> String
16:37:02 <Baughn> It's more like r = PrintfType r' => Int -> r'
16:37:08 <Toxaris> |Steve|: so printf :: String -> Int -> Int -> String -> String
16:37:24 <Toxaris> |Steve|: so by choosing r, the caller can choose how many arguments it will give to the result of printf
16:37:40 <Toxaris> Baughn: yeah, but consider r' = Int -> String -> String :)
16:37:49 <|Steve|> Toxaris: Hmm, so how does Haskell decide what r is?
16:37:55 <Toxaris> |Steve|: type inference
16:37:57 <Baughn> |Steve|: Unification
16:38:05 <dmwit> unification, bah
16:38:14 <dmwit> This isn't Prolog.
16:38:15 <Baughn> It figures out what it has to be to make the types consistent
16:38:19 <dcoutts> dons: re: build-tools depends, yes we need a good way of mapping those to packages. It's not trivial. And we should fix checking for required C libs / headers.
16:38:26 <Baughn> dmwit: On the type level, it is. :P
16:38:27 <|Steve|> dmwit: Does Haskell not use the unification algorithm?
16:38:28 <dons> dcoutts: right.
16:38:36 <dons> i got a bug report about cabal2arch not spotting yi depends on alex.
16:38:37 <vixey> |Steve|: It uses first order unification
16:38:48 <vixey> first order unification has about as much to do with Prolog as lambda calculus does with haskell
16:39:25 <Toxaris> |Steve|: e.g., if you write (printf "..." "some string" :: String), Haskell 'sees' that printf must have type String -> String -> String, so r must be String -> String
16:40:22 <MyCatVerbs> Curse thee, damnéd monomorphism restriction.
16:40:31 <dcoutts> dons: so there are two issues there, one is the issue of platform independent pre-processors. If yi bundles the pre-processed .x file does it still depend on alex?
16:40:35 <Toxaris> olsner: I see that Haskell cannot do better if we insist on encoding the formatting as a string, but it is still dynamically typed, then, imho
16:40:48 <Quadrescence> MyCatVerbs: I think you got the accent in the wrong direction.
16:40:55 <dcoutts> dons: and secondly, if we do use .chs modules, cabal does not yet complain that you didn't specify build-tools: c2hs
16:40:57 <|Steve|> Alright, I believe I see how it's workingn.
16:40:59 <|Steve|> working even
16:41:12 <Toxaris> |Steve|: cool, isn't it?
16:41:23 <MyCatVerbs> Quadrescence: damn. Oh well. (ℵ, by the way)
16:41:30 <dcoutts> dons: oh, and thirdly(!) we don't map specified build tools to packages that provide them (if any - eg build-tools: perl ??).
16:41:33 <dons> dcoutts: right. so general principle: all deps should be statically discoverable.
16:41:42 <Quadrescence> MyCatVerbs: Slut
16:41:49 <dons> that might be a job for the packager, though, dcoutts
16:41:50 <dcoutts> dons: indeed, so we need a plan to get there
16:41:52 <MyCatVerbs> Quadrescence: I wish. :(
16:41:53 <dons> mapping to packages.
16:42:04 <dons> we just need some notion of clear deps.
16:42:17 <dcoutts> dons: in this case no, we do know that the c2hs build tool is provided by the c2hs package
16:42:24 <olsner> Toxaris: I guess it depends on what you mean by typing... but yes, it is not as static as you'd expect from haskell
16:42:31 <dcoutts> dons: though indeed, for perl we can't find a haskell package.
16:42:55 <dons> yep
16:43:14 <dcoutts> dons: and it's not clear from the way we do it now which "build-tools: ___" map to haskell packages and which just to named executables we hope to find on the path.
16:43:21 <Toxaris> olsner: it is typed, of course (no core dump), but dynamically (exception), not statically (compiler error)
16:43:47 <dons> dcoutts: so basically, if someone uses a .x file, i want cabal to prevent them uploading to hackage unless Alex is in the build-tools: line
16:43:54 <MyCatVerbs> Quadrescence: anyway. Take a look at the definition I'm about to put into \bot, and the pains I've gone through to get it the correct type (the inferred type is actually too general for my purposes) _despite_ the monomorphism restriction. Then you'll have good cause to call me a slut. ^^
16:43:58 <vixey> bleh
16:43:58 <vixey> $ /usr/local/bin/ghci-6.9.20080619
16:43:59 <vixey> GHCi, version 6.9.20080619: http://www.haskell.org/ghc/  :? for help
16:43:59 <vixey> Segmentation fault
16:43:59 <dons> i want to depend on the build-tools line for exectuables needed at build time.
16:43:59 <lambdabot> Title: The Glasgow Haskell Compiler
16:44:18 <MyCatVerbs> @let posFloatBounds = let floatBounds f = let fBs f = let (lexp,mexp) = floatRange f in let fD = floatDigits f in (encodeFloat ((2^mexp)-(2^(mexp-fD))) 0,encodeFloat 1 (lexp-fD)) in ((fBs :: (RealFloat a) => a -> (a,a)) f)
16:44:18 <lambdabot>  Parse error
16:44:33 <dcoutts> dons: yes, though what do we do about pre-generated .hs files for alex?
16:44:36 <MyCatVerbs> Oh, Hell. That parsed just fine in GHCi, damn you!
16:45:27 <MyCatVerbs> > let posFloatBounds = let floatBounds f = let fBs f = let (lexp,mexp) = floatRange f in let fD = floatDigits f in (encodeFloat ((2^mexp)-(2^(mexp-fD))) 0,encodeFloat 1 (lexp-fD)) in ((fBs) f) in posFloatBounds (0::Float)
16:45:27 <lambdabot>  Parse error at end of input
16:45:50 <Toxaris> MyCatVerbs: doesn't parse for me in ghci
16:45:56 <ziman> <interactive>:1:221: parse error (possibly incorrect indentation)
16:45:59 <dmwit> Maybe you are getting cut off?
16:46:05 <dcoutts> dons: it's unpleasant to have the .cabal file change if we bundle or don't bundle pre-generated .hs files.
16:46:08 <MyCatVerbs> Copied and pasted, no less. oO
16:46:30 <Toxaris> MyCatVerbs: the second one parses, but does not typecheck
16:46:46 <MyCatVerbs> Wait, maybe I just mis-pasted?
16:46:53 <dcoutts> dons: but otoh, if it says build-tools: alex but the tarball has .hs file, we don't want to make dep resolvers require alex.
16:47:01 <dons> yeah. that's a pain.
16:47:10 <dcoutts> dons: otherwise alex itself could not be built! :-)
16:47:12 <MyCatVerbs> > let posFloatBounds f = let fBs f = let (lexp,mexp) = floatRange f in let fD = floatDigits f in (encodeFloat ((2^mexp)-(2^(mexp-fD))) 0,encodeFloat 1 (lexp-fD)) in ((fBs :: (RealFloat a) => a -> (a,a)) f) in posFloatBounds (0::Float)
16:47:13 <lambdabot>  (3.4028235e38,1.0e-45)
16:47:29 <dcoutts> dons: so I don't have a nice solution to that yet.
16:47:50 <MyCatVerbs> Right. Looks like I must've just... grabbed the wrong characters? I don't know. I should line 'em up and compare. Anyway.
16:47:55 <vixey> hey
16:47:59 <vixey> howe come I can't just go
16:48:01 <MyCatVerbs> @let posFloatBounds f = let fBs f = let (lexp,mexp) = floatRange f in let fD = floatDigits f in (encodeFloat ((2^mexp)-(2^(mexp-fD))) 0,encodeFloat 1 (lexp-fD)) in ((fBs :: (RealFloat a) => a -> (a,a)) f)
16:48:02 <vixey> ghc --make ghc
16:48:02 <lambdabot> Defined.
16:48:05 <vixey> ?
16:48:08 <MyCatVerbs> :t posFloatBounds
16:48:09 <lambdabot> forall a. (RealFloat a) => a -> (a, a)
16:48:34 <olsner> > posFloatBounds (undefined :: Float)
16:48:34 <ddarius> vixey: What happens when you do that?
16:48:35 <lambdabot>  (3.4028235e38,1.0e-45)
16:48:44 <MyCatVerbs> w00t. Dear monomorphism restriction: yo' entire matrilineal ancestry! Hells yes!
16:48:50 <vixey> I didn't try it
16:49:08 <vixey> the makefiles do a bit more than that though
16:49:13 <vixey> but why?
16:49:23 <dmwit> Does GHC link to C libraries?
16:49:32 <dmwit> I'm guessing yes, since it uses libGMP, right?
16:49:40 <olsner> MyCatVerbs: maybe after one too many insults like that, the monomorphism restriction will disable the command line options to disable it
16:49:41 <erikc> yes, you can use -v to see the link step
16:49:54 <dons> dmwit: yeah
16:49:57 <olsner> don't just go around insulting language features willy-nilly :P
16:49:58 <dons> $ ldd /usr/lib/ghc-6.8.2/ghc-6.8.2* linux-vdso.so.1 =>  (0x00007fff6e9fe000) libreadline.so.5 => /lib/libreadline.so.5 (0x00007f9066441000) libncurses.so.5 => /lib/libncurses.so.5 (0x00007f90661e5000)
16:50:03 <dons> etc.
16:50:14 <dons> pthread, gmp, ncurses (!)
16:50:15 <MyCatVerbs> olsner: that's okay. I think I don't actually -need- that option. Heh. :)
16:50:17 <dons> readline.
16:50:18 <dmwit> vixey: So, probably because of that?
16:50:24 <dmwit> ncurses is a bit odd
16:50:26 <dons> i wonder what the ncurses binding is for.
16:50:36 <Heffalump> I thought pretty much everyone has now accepted that it should go (the monomorphism restriction)
16:50:48 <olsner> MyCatVerbs: you mean you *want* the MR?
16:50:53 <dons> there were some fairly conclusive performance numbers from jaffacake
16:51:00 <dons> ghc's smart enough to toss it.
16:52:02 <olsner> was the MR about performance? I always thought it was a matter of reducing confusing type traps for newbies or something like that
16:52:31 <MyCatVerbs> olsner: mmmm... yes? I mean, the reason for the MR (even though I can't remember it right now ¬_¬) was a pretty good one. When writing real code, I just give type definitions for all top-level functions anyway as a matter of course. When writing crap in \bot, well, *then* it's painful, but I can still conquer it. :)
16:52:56 <Toxaris> MyCatVerbs: Have you realized that I tried to tell you that you can use stand-alone type signatures with @let?
16:52:58 <dons> olsner: performance.
16:53:18 <dons> i suppose a side effect ( :) is that it also helps simplify type errors
16:53:21 <MyCatVerbs> Toxaris: no, I was too busy pissing about avoiding the MR to read that line. Hahaha, oops. :D
16:53:29 <Toxaris> @let realFloatBounds f = (encodeFloat ((2^mexp)-(2^(mexp-fD))) 0, encodeFloat 1 (lexp-fD)) where {(lexp, mexp) = floatRange f; fD = floatDigits f}
16:53:30 <lambdabot> Defined.
16:53:36 <Toxaris> @let realFloatBounds :: RealFloat a => a -> (a, a)
16:53:37 <lambdabot> Defined.
16:53:45 <Toxaris> > realFloatBounds (undefined :: Float)
16:53:46 <lambdabot>  (3.4028235e38,1.0e-45)
16:53:49 <Toxaris> > realFloatBounds (undefined :: Double)
16:53:50 <lambdabot>  (1.7976931348623157e308,5.0e-324)
16:54:04 <MyCatVerbs> Toxaris: wait, hang on, where's the type specification?
16:54:21 <dmwit> You can ?let several (related) things.
16:54:36 <dmwit> i.e. you could ?let two pattern matches, or a type-sig and an implementation, or...
16:54:45 <Toxaris> MyCatVerbs: second @let
16:54:46 <MyCatVerbs> Ohhhh, I see.
16:54:49 <ddarius> Well, you can put type signatures anywhere.
16:54:54 <MyCatVerbs> Toxaris: handy. Thank you for showing me that.
16:55:12 <dmwit> ?let foo (x:xs) = 1
16:55:13 <lambdabot> <local>:11:0:     Multiple declarations of `L.foo'     Declared at: <local>:1...
16:55:16 <Toxaris> ddarius: not with @let, they have to go after the function afaikt
16:55:21 <Toxaris> ddarius: not with @let, they have to go after the function afaict
16:55:21 <dmwit> ?let foobar (x:xs) = 1
16:55:22 <lambdabot> Defined.
16:55:23 <Toxaris> whatever
16:55:26 <dmwit> ?let foobar [] = 0
16:55:26 <lambdabot> Defined.
16:55:30 <dmwit> :t foo
16:55:31 <lambdabot> Int -> Int
16:55:34 <dmwit> :t foobar
16:55:34 <lambdabot> forall t t1. (Num t1) => [t] -> t1
16:55:42 <MyCatVerbs> Oh and -facepalm-, no need to bother working out a definition for negFloatBounds - they're just the same but with the sign bit flipped.
16:55:57 <olsner> :D
16:56:03 <dmwit> > foo 3
16:56:04 <lambdabot>  3
16:56:08 <dmwit> > map foo [1..10]
16:56:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:56:12 <ddarius> Toxaris: Why would that be?
16:56:23 <Toxaris> ddarius: found out by experiment
16:56:34 <dmwit> ddarius: Because the function is not in scope yet.
16:56:41 <ddarius> Yeah, there's that.
16:56:43 <dmwit> (It compiles after each ?let.)
16:56:50 <MyCatVerbs> > let both f = f *** f in both negate (realFloatBounds (0::Float))
16:56:52 <lambdabot>  (-3.4028235e38,-1.0e-45)
16:57:06 <Toxaris> ddarius: and in the middle is not allowed because clauses have to stand next to each other, and \bot doesn't reorder the @lets
16:57:10 <Toxaris> I guess
16:57:20 <Toxaris> @let anotherTest 1 = 42
16:57:21 <lambdabot> Defined.
16:57:22 <ddarius> Toxaris: In the middle isn't allowed in a source file.
16:57:39 <dmwit> ?let smoeTesth = 13
16:57:40 <lambdabot> Defined.
16:57:45 <dmwit> ?let anotherTest 2 = 43
16:57:46 <lambdabot> <local>:15:0:     Multiple declarations of `L.anotherTest'     Declared at: <...
16:57:47 <Toxaris> ddarius: no reason for \bot not to parse and reorder the @let-lines
16:58:23 <Toxaris> ddarius: maybe \bot should allow to run ed scripts on L.hs
16:58:25 <Toxaris> :)
17:00:12 <Toxaris> actually, it would be cool if \bot would allow type signatures without definitions by silently inserting name = undefined "not yet defined", and deleting this line if name gets defined later, so one could define types for use in @type commands
17:00:42 * Toxaris would really love to hack on \bot if it would work on windows
17:05:38 <gwern> > 0xdeadbeef + 1
17:05:40 <lambdabot>  3735928560
17:05:53 <dmwit> 0xdeadbff0?
17:06:02 <dmwit> 0xdeadbef0
17:06:04 <gwern> hum. didn't know haskell did hex
17:06:25 <dmwit> > 0o70 -- octal, too
17:06:26 <lambdabot>  56
17:06:32 <dmwit> > 0o80
17:06:33 <lambdabot>   Not in scope: `o80'
17:06:36 <dmwit> heh
17:06:47 <MyCatVerbs> gwern: Haskell hackers are *far* too lazy to do encode into hex by hand. :)
17:07:01 <paczesiowa> does Isaac Potoczny-Jones hang out here?
17:07:36 <dons> paczesiowa: yeah.
17:07:54 <dons> paczesiowa: he's SyntaxNinja, but is generally online during the weekdays
17:08:19 <paczesiowa> dons: thanks
17:18:34 <paczesiowa> dons: do you know if he has darcs repos of libraries he is maintaining? (xml and feed) ?
17:18:44 <Quadrescence> ?hoogle [a] -> Int -> a
17:18:45 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
17:18:45 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
17:19:56 <mmorrow> if anyone is knowledgeable about lexing/parsing, would you mind taking a peek at http://hpaste.org/9499
17:19:59 <dons> paczesiowa: they're galois libraries.
17:20:05 <dons> paczesiowa: we maintain them internally
17:20:13 <dons> basically, send patches in, or requests.
17:20:54 <mmorrow> i don't see a way to do it w/out requiring escaping interior occurrences of "|]"
17:21:02 <mmorrow> (this is what ghc's parser does)
17:21:17 <paczesiowa> dons: I would like all types in Text.RSS.Syntax to derive Eq
17:21:52 <dons> paczesiowa: I think I either did that in the next release, or there was some reason we couldn't.
17:21:56 <dons> oh, maybe it was xml.
17:22:02 <dons> xml needed a lot of changes
17:22:08 <dons> did you want to do this?
17:23:09 <paczesiowa> dons: I just inserted 20 "derive Eq" in xml and feed, I can't see why it wouldn't work
17:24:43 <Cale> mmorrow: I say just use infinite lookahead?
17:25:05 <Cale> actually...
17:25:19 <mmorrow> heh
17:25:40 <Cale> What are the contents of a quasiquoted expression allowed to be?
17:26:16 <Cale> Because if they're arbitrary, you could always match the first open-quasiquote with the last close-quasiquote in the whole file.
17:26:37 <mmorrow> Cale: yeah, arbitrary.
17:26:45 <mmorrow> hmm
17:26:55 <Cale> So you're limited to one quasiquoted expression per file?
17:26:57 <dons> paczesiowa: if you can just do that and send me the diff, i'll apply it.
17:27:05 <Cale> Or do you take the largest thing which parses?
17:27:14 <Cale> (with the qq parser)
17:27:38 <paczesiowa> dons: I'll test it first
17:27:39 <dobblego> is it illegal in most jurisdictions to claim to be a doctor without the relevant qualifications? e.g. on a business card?
17:28:02 <mmorrow> Cale: the unfortunate thing is, how to parse the interior depends on which quasiquoter (determined by the var x in [$x|...|]) is used
17:28:03 <dons> i doubt it, dobblego
17:28:16 <dobblego> well that's just sad
17:28:19 <dons> heh
17:28:28 <dons> Dr. Dobblego has a nice ring :)
17:28:33 <Cale> mmorrow: Right... so I'm asking if it's maximal munch, or what? :)
17:28:51 <dobblego> not me, I just received a business card with such a fraudulent claim
17:28:54 <mmorrow> Cale: what is "it" there?
17:29:09 <mmorrow> ahh.
17:29:13 <Cale> mmorrow: The specification for how to parse it.
17:29:31 <mmorrow> at this point, we don't know what parser that x in [$x||] refers to
17:29:39 <mmorrow> could be anything
17:29:51 <dons> dobblego: heh. it's relatively trivial to check it now, so i suppose its effectively policed via google
17:29:52 <Cale> oh, then this is just impossible
17:30:02 <mmorrow> yeah, that's what i figured
17:30:06 <shapr> dobblego: I think it's illegal to claim to be a medical doctor.
17:30:07 <dobblego> dons, how do you check it exactly?
17:30:11 <sm> um.. that's trippy. Is there a reason ghci might update timestamps of a bunch of lhs files while debugging ?
17:30:19 <Cale> From what we've assumed, it's impossible to implement this feature. :)
17:30:29 <dobblego> shapr, this guy isa Chiropractor who claims to be "Dr. So So"
17:30:31 <dons> dobblego: i would try to find the universities graduation page details. they list who graduates when.
17:30:43 <dobblego> dons, ok
17:30:45 <dons> if you were really keen, you'd contract the instituition
17:30:47 <shapr> dobblego: I don't think Chiropractors are classified as doctors.
17:30:49 <sm> they've all been changed, by god. :)
17:31:07 <gwern> preflex: seen beschmi
17:31:07 <preflex>  beschmi was last seen on #haskell 31 days, 14 hours, 2 minutes and 40 seconds ago, saying: ndmitchell: yeah, i'm using 1.2
17:31:10 <Cale> So either there are restrictions on what the quasiquoted string consists of, or something really trippy has to happen with regard to determining the parser.
17:31:14 <mmorrow> Cale: i'm thinking maybe of doing something where the lexer somehow is passed a [(String,Lexer _ _)] associating possible quasiquoter identifiers with their lexers
17:31:14 <ddarius> What you do is have the parser delimit itself.
17:31:17 <sm> let's assume I confused darcs diff by symlinking the src dir in it's temporary directories...
17:31:18 <dobblego> shapr, no, you need a Bachelor of Medicine to be a Medical Doctor afaik
17:31:40 <mmorrow> Cale: heh, trippy
17:32:25 * ddarius refers mmorrow and Cale to Forth parsing words and CL reader macros.
17:32:31 <mmorrow> Cale: the real drag is, if  "|]" is restricted and has to be escaped to be "\\|]", then any qq syntax in a qq will be tedious
17:33:10 <dons> anyone want to patch lambdabot to call preflex on @seen ? :)
17:33:12 <vixey> I mean if you just got QQ to quote -haskell- and not these made up languages
17:33:20 <Cale> Oh, I suppose there could be some kind of staging restriction wherein the parser to parse the qq sections can't occur in the same module.
17:33:20 <vixey> then you could nest them no problem
17:33:29 <ddarius> vixey: That's what TH currently does.
17:33:29 <mmorrow> ddarius: noted. i've been meaning to read up on lisp macros
17:33:38 <vixey> oh oh well then
17:34:12 <vixey> there is not much to lisp reader macros
17:34:19 <Cale> and then you can just try the qq parser on all the cases possible and take the largest one which parses.
17:34:23 <ddarius> vixey: There isn't much to quasiquotation.
17:34:28 <vixey> just got a hook into the parser, it gives you stream.. take what you want and control goes back to lisp
17:34:42 <mmorrow> vixey, the crux is how to determine the closing "|]" in a QuasiQuoter internal string
17:34:46 <mmorrow> http://hpaste.org/9499
17:35:02 <ddarius> mmorrow: As I said, it's the parsers job to delimit itself.
17:35:16 <Cale> ddarius: so it gets the entire rest of the file?
17:35:25 <ddarius> Furthermore, there is no reason the syntax for quasiquotation inside the parsed string has to be the same as Haskell's.
17:35:28 <ddarius> Cale: Yes.
17:35:47 <Cale> That's kind of scary.
17:35:49 <mmorrow> ddarius: hmm. so i guess i'll have to figure out some way to pass the parsers assoc with various quasiquoters that'll potentially be seen to the initial lexer
17:35:53 <ddarius> Cale: Yes.
17:35:56 <mmorrow> oh
17:35:59 <mmorrow> i gotcha
17:36:06 <mmorrow> interesting
17:36:20 <Cale> ddarius: Is it allowed to look ahead into parts which it doesn't eat?
17:36:43 <ddarius> Cale: It could easily be implemented that way, but you could make that not be allowable.
17:37:30 <mmorrow> ddarius: is this (to some extent/whatever) the method that reader macros use?
17:37:50 <mmorrow> (parsing of them?)
17:37:51 <ddarius> mmorrow: vixey described how reader macros work
17:37:59 * mmorrow scrolls back
17:38:25 <ddarius> Forth parsing words are similar.
17:38:26 <mmorrow> excellent
17:38:51 * mmorrow reads up on reader macros and forth parsing words
17:39:46 <Quadrescence> ?hoogle a -> IO ()
17:39:47 <lambdabot> Prelude.print :: Show a => a -> IO ()
17:39:47 <lambdabot> System.IO.print :: Show a => a -> IO ()
17:39:47 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
17:44:37 <Quadrescence> Correct this please? http://hpaste.org/9500
17:45:09 <dons> you're missing | syntax
17:45:14 <dons> f x | x <= 2 = 7
17:45:22 <dons>      | x == y = 8
17:45:34 <dons> the | should line up vertically
17:45:41 <dons> oh, sorry, you do have them :)
17:45:44 <ddarius> That doesn't actually matter
17:45:44 <Cale> oh, another problem...
17:45:45 <vixey> omg
17:45:47 <vixey> I got 6.9!
17:45:48 * dons read |n as 'ln'
17:45:49 <Cale> x <- getLine
17:45:52 <vixey> mmorrow: thank you :)
17:45:54 <Cale> in the where clause
17:45:59 <vixey> just did make clean and i worked
17:46:14 <Cale> Quadrescence: you have a spurious x <- getLine in the where clause
17:46:27 <Cale> Quadrescence: that's a syntax error, it would only be allowed inside of a do-block
17:46:30 <Quadrescence> Cale: How do I get the user's input each iteration?
17:46:40 <vixey> last (reverse -> x:_) = x
17:47:09 <Cale> oh, there's another problem with the way you're recursing as well
17:47:26 <Cale> When you have  x : xs,  x must be an element, and xs a list
17:47:31 <Cale> Not the other way around.
17:47:44 <Quadrescence> Oh, oops, yeah. That is easily fixed.
17:48:18 <mmorrow> vixey: sweet!!!
17:48:23 <dmwit> Can't do IO in a pure function... ;-)
17:48:31 <vixey> /usr/local/bin/ghci-6.9.20080619 -XViewPatterns -fth # yay
17:48:32 <Cale> Easiest would most likely be to separate I/O from this parsing, I think.
17:48:44 * vixey has a look for some docs
17:48:48 <Cale> For instance, take a list of strings as a parameter
17:48:50 <Quadrescence> hum
17:49:18 <mmorrow> vixey: up-to-date TH docs are here: http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/
17:49:19 <lambdabot> Title: template-haskell-2.2, http://tinyurl.com/6xdh6w
17:49:41 <mmorrow> (well, as of 080623)
17:50:04 <Cale> Quadrescence: If your function was to do IO, it would have an IO type.
17:50:31 <Cale> Quadrescence: something like  getPuzzleStructure :: Int -> IO [(String, Int, Int)]
17:51:42 <Cale> If you want to keep things pure, perhaps better would be  readPuzzle :: String -> [(String,Int,Int)]
17:52:50 <dons> what's a good type with 3 inhabitants?
17:52:55 <dons> other than Ord
17:53:10 <dons> T | F | Unknown ?
17:53:23 <heatsink> dons: Three-valued logic, sure.
17:53:39 <vixey> Maybe Bool
17:53:40 <Trinithis> Maybe Bool
17:53:42 <dons> hmm, ternary logic. yes.
17:53:57 <Cale> The latter of which would be something like readPuzzle xs = [(x,read y,read z) | (x:y:z:_) <- map words . lines $ xs]
17:54:15 <dons> T | F | U
17:54:25 <Cale> dons: hehe,  data Bool = False | True | FileNotFound
17:54:32 <dons> :)
17:54:40 <Cale> Maybe Bool
17:55:46 <Cale> or even...
17:56:09 <Cale> readPuzzle xs = [(x,read y,read z) | (x:y:z:_) <- map words xs]
17:56:16 <Cale> because you'll probably write:
17:56:40 <Cale> getPuzzleStructure n = fmap readPuzzle (replicateM n getLine)
17:57:06 <Cale> In which case, you'll want a list of strings anyway.
17:57:23 <Quadrescence> My brain is struggling.
17:57:50 * heatsink prefers liftM over fmap
17:58:04 * vixey prefers .
17:58:23 <vixey> :t read . getLine
17:58:26 <lambdabot> forall a. (Read a) => IO a
17:58:47 * Trinithis prefers .
17:58:54 <ziman> it should be (<$>)
17:59:25 <heatsink> It took just over a half hour for cc1 to run on stage1/parser/Parser.hs -fvia-c.  Any idea why that one file takes so long?
17:59:35 <dons> gcc has some performance problems.
17:59:59 <heatsink> hmm.
18:01:38 <Quadrescence> Cale: How do I use replicateM?
18:01:45 <paczesiowa> is there better way to update something inside record inside record than "currentRSS { rssChannel = (rssChannel currentRSS) { rssItems = map adjustDate (rssItems $ rssChannel currentRSS) } }" ?
18:02:21 <heatsink> paczesiowa, not really.  You can always write functions for the common cases though.
18:03:12 <paczesiowa> I don't like records:(
18:03:17 <heatsink> mapRSSChannel (mapRSSItems (map adjustDate)) currentRSS
18:03:48 <heatsink> s/map/update
18:04:20 <paczesiowa> heatsink: this is the only piece of such code so there's no common case
18:08:07 <heatsink> Quadrescence, replicateM performs its argument repeatedly and returns a list of results.
18:08:25 <heatsink> replicateM 4 m === do {x1 <- m; x2 <- m; x3 <- m; x4 <- m; return [x1, x2, x3, x4]}
18:10:05 <noohgodno> > 5==2
18:10:08 <lambdabot>  False
18:10:13 <noohgodno> you don't say
18:10:51 <noohgodno> > map (sum [1..500])
18:10:52 <lambdabot>        add an instance declaration for (Enum (a -> b), Num (a -> b))
18:11:00 <Cale> @src replicateM
18:11:00 <lambdabot> replicateM n x = sequence (replicate n x)
18:11:04 <heatsink> >map sum [1..500]
18:11:06 <Cale> @src sequence
18:11:06 <heatsink> > map sum [1..500]
18:11:06 <lambdabot> sequence []     = return []
18:11:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:11:06 <lambdabot> --OR
18:11:06 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:11:06 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
18:11:13 <mmorrow> replicateM n = sequence . replicate n
18:11:20 <noohgodno> haskell is really hard
18:11:25 <heatsink> wait
18:11:28 <heatsink> > sum [1..500]
18:11:29 <noohgodno> i've never seen a language this hard
18:11:29 <lambdabot>  125250
18:11:31 <Cale> noohgodno: map normally takes a function and a list
18:11:55 <Cale> noohgodno: (and applies the function to each element of the list, giving a new list)
18:11:59 <Trinithis> :t genericReplicateM
18:12:00 <noohgodno> yeah i know
18:12:04 <newsham> [15:10] < noohgodno> i've never seen a language this hard
18:12:05 <noohgodno> so if i have
18:12:08 <mmorrow> noohgodno: don't quit
18:12:09 <noohgodno> map (n,sum [1..500])
18:12:15 <newsham> perhaps you're expecting to carry over a lot of experience from other languages
18:12:27 <newsham> where haskell is a lot more different than most languages are to each other
18:12:27 <noohgodno> i'm expecting to carry over more experience from math
18:12:29 <Cale> noohgodno: ... which function are you trying to apply to which list here?
18:12:40 <noohgodno> let's just say i want to do n^2 for each n
18:12:43 <Cale> noohgodno: sum takes a list of numbers and produces a number
18:12:49 <noohgodno> i know
18:12:52 <Cale> okay
18:12:54 <newsham> > map (^2) [2..10]
18:12:56 <lambdabot>  [4,9,16,25,36,49,64,81,100]
18:13:00 <Cale> So  sum [1..500]  is a number
18:13:01 <noohgodno> gotcha
18:13:10 <noohgodno> sum map (^2) [2..1000]
18:13:13 <noohgodno> > sum map (^2) [2..1000]
18:13:14 <lambdabot>  Couldn't match expected type `[a]'
18:13:20 <noohgodno> > sum (map (^2) [2..1000])
18:13:22 <lambdabot>  333833499
18:13:23 <Cale> > sum (map (^2) [1..10])
18:13:24 <lambdabot>  385
18:13:24 <noohgodno> :]
18:13:32 <Trinithis> noohgodno: Haskell is the most rewarding language I have learned. Well worth not giving up.
18:13:41 <noohgodno> pays a metric fuckton, too
18:13:56 <noohgodno> you know the average haskell coder in the US makes 200k/yr?
18:14:12 <newsham> where did you hear that?
18:14:23 <noohgodno> a big list of salaries
18:14:34 <noohgodno> ;O
18:14:41 <mmorrow> newsham: dons linked to it a while back
18:14:52 <newsham> i guess i'll never own an army of haskell programmers
18:14:58 <Trinithis> $ and a fun lanugauge? Amazing!
18:15:16 <noohgodno> tech salaries go up 5% a year, too
18:15:32 <newsham> thats because inflation is 5%/yr right now
18:15:42 <noohgodno> not quite
18:15:54 <noohgodno> of all industries, it has the fastest growing rate of salaries
18:16:07 <newsham> you're right, its actually more lik 6-7%
18:16:09 <noohgodno> er, largest rate of salary increase
18:16:14 <newsham> or 4.25% if you measure in reallyodd ways
18:16:34 <noohgodno> but inflation measures something very close to the mean increase in salary, doesn't it?
18:16:35 <newsham> where I live, its about 5.25% even if you measure really poorly
18:16:57 <noohgodno> in theory, money goes somewhere
18:17:02 <centrinia> I have a feeling that people with doctorates make up a higher percentage of the Haskell programmer population than for something like C or Java.
18:17:23 <newsham> centrinia: definitely, but salary falls off from masters to phd.
18:18:10 <noohgodno> are there any haskell web apps
18:18:19 <newsham> yes, hpaste for example.
18:18:21 <noohgodno> i wanna see
18:18:21 <centrinia> ~ HAppS
18:18:28 <newsham> ?hpaste
18:18:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:18:30 <noohgodno> is that just pastebin
18:18:35 <noohgodno> that's lame
18:19:06 <noohgodno> i want to see something really novel
18:19:18 <paczesiowa> not enterprisey enough?
18:19:20 <noohgodno> something inspiring!
18:20:22 <paczesiowa> can you show me one inspiring website written in any language?
18:20:44 <heatsink> Does adobe actionscript count?
18:20:49 <noohgodno> that's all i try to ever code
18:20:56 <newsham> not at all, heatsink.
18:23:02 <noohgodno> though my success is mixed...
18:23:28 <centrinia> I still think that functional reactive programming could be useful for interactive web pages.
18:24:40 <ddarius> centrinia: So do the flapjax people.
18:26:43 <hml> is template metaprogramming haskell's versin of macros ?
18:27:27 <robreim> Is there any JHC hackers around?
18:30:27 <robreim> hml, I haven't used it myself but I believe It's the equivalent of macros in the sense that you can change syntax fairly arbitrarily. It's probably not (though I don't know for sure) as powerful as lisp macros if that's what you're thinking of.
18:32:34 <dons> have we avoided success yet!?
18:32:37 <vixey> template metaprogramming
18:32:43 <vixey> that's C++ right?
18:32:49 <dons> hmm. can i get an interrobang tshirt!?
18:32:55 <noohgodno> dons++
18:33:12 <dons> hey, awesome, http://www.zazzle.com/interrobang_shirt-235471175250401333?gl=hooferluvsu
18:33:13 <lambdabot> Title: interrobang t-shirt from Zazzle.com, http://tinyurl.com/69rcyf
18:33:33 <dons> i need more interrobang stuff
18:33:57 <heatsink> That looks like a superhero logo.  You can be interrobang man!
18:34:02 <noohgodno> interrobanging is my life
18:34:09 <noohgodno> just look at my handle
18:34:10 <dons> shapr: i think the interrobang should be #haskell's motif :)
18:34:15 <robreim> dons, maybe you should add conditional strict evaluation to haskell using an interrobang?
18:34:24 <dons> oh, awesome, robreim
18:34:26 <noohgodno> can somebody explain to me how the "do" keyword doesn't count as a "side effect"
18:34:36 <dons> noohgodno: it introduces a monadic block of code
18:34:43 <dons> which could potentially include side effects on the world
18:34:48 <dons> if its in a world-effecting monad.
18:34:52 <robreim> Guess what? I got a fever. And the only cure is more interrobang
18:34:53 <dons> ‽
18:35:03 <noohgodno> robreim--
18:35:04 <dons> haskell‽ wtf‽ monads!!‽
18:35:06 <heatsink> noohgodno, it takes a while to understand monads.  Lots of people here suggest the "monads as computation" page.
18:35:33 <noohgodno> no, i got that
18:35:46 <noohgodno> this language takes serious mind-bending
18:35:49 <noohgodno> i need some hallucinogens
18:36:13 <heatsink> noohgodno, just remember: there is no spoon.
18:36:22 <noohgodno> there's very clearly a spoon
18:36:25 <dons>         , run prop_mempty_id
18:36:25 <dons>         , run prop_mempty_id
18:36:27 <dons> grr.
18:37:12 <noohgodno> they shoot horses, don't they
18:37:17 <robreim> So noone here is adequately versed in JHC to be able to help an interested person with a couple of newbie questions?
18:37:33 <robreim> ?karma
18:37:33 <lambdabot> You have a karma of -1
18:37:43 <robreim> Aw, what was that for, noohgodno?
18:38:05 <noohgodno> that tired snl reference
18:38:36 <dons> robreim: SamB or john.
18:40:51 <robreim> Thanks. john == john meacham
18:41:23 * atomiclambda is away: I'm busy
18:42:10 <noohgodno> > 5
18:42:11 <lambdabot>  5
18:42:18 * noohgodno nods
18:42:23 * heatsink starts building 6.6.1 and hopes the hc files will build on my other machine
18:42:24 <dons> robreim: yup.
18:42:34 <dons> heatsink: what are you porting to?
18:43:19 <noohgodno> what the hell was J#
18:43:52 <heatsink> dons: I want to build and link against 32-bit libraries on a 64-bit machine.  For some reason, the 32-bit i386 distribution won't run: I get "floating point exception" messages at the very beginning, when running the `pwd' utility.
18:43:58 <newsham> j# == embrace,extend,extinguish java
18:44:33 <ddarius> newsham: Java's extinguished?
18:44:48 <newsham> heatsink:  you mean you built a haskell app on i386 and it wont run on your amd64/em64t?
18:44:56 <newsham> ddarius: didnt work.
18:45:18 <robreim> embrace, extend, extinguish... of course... no wonder Microsoft wanted to be distributed on the eee pc so badly.
18:45:19 <noohgodno> remember when they spent a year and a half investigating microsoft, and absolutely nothing happened
18:46:29 <gwern> hm, Igloo == Ian ???
18:46:34 <gwern> Lynagh?
18:46:50 <dons> yes.
18:46:59 <heatsink> newsham, I want to build an elf32-i386 binary on an amd64 machine so I can link with existing elf32-i386 libraries that I can't rebuild.
18:47:03 <dons> is MS still relevant?
18:47:25 <dons> :) didn't google, apple, zune and vista doom them to obsolesence?
18:47:26 <newsham> ahh.
18:47:33 <glguy> dons: you aren't *that* isolated
18:47:33 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
18:47:52 <noohgodno> glguy?
18:47:56 <newsham> dons: still 90% market share on OS.  though mac's at 7-9% and about +2%/yr
18:48:04 <noohgodno> other arch users in here
18:48:07 * dons looks around for windows machines.
18:48:18 <dons> glguy: yay, we live in a ghetto! :)
18:48:21 <newsham> <- on winxp desktop now :)
18:48:30 <dons> noohgodno: a bunch of arch users.
18:48:34 <gwern> I'm not sure Mac isn't as much a problem as MS. macs are just unixy enough to tempt people into contorting their apps to cover all their edge cases and apple oddities
18:48:48 <dons> gwern, and apple hates to share.
18:48:57 <gwern> always have
18:49:28 <sjanssen> the iPhone SDK business is rather frightening
18:49:44 <newsham> wonder if android will have much of an impact
18:50:07 <gwern> sjanssen: it brought home tivoization to me, anyway
18:50:31 <glguy> "just unixy enough"? Mac = UNIX
18:50:40 <glguy> or at least OS X
18:51:12 <gwern> glguy: if that is so, why do I see so many issues with Macs coming up?
18:51:25 <newsham> mach + unix + lots of objc stuff thats
18:51:36 <newsham> compatibility not ensured
18:51:38 <gwern> you have to have your head in the sand to not have noticed the endless torrent of emails and posts that start 'i'm on mac os x...'
18:52:01 <newsham> gwern: 7-9% market share.
18:52:19 <glguy> gwern: I'm just saying that mac isn't "unixy" it *is* UNIX
18:52:24 <gwern> newsham: that's great for them, but I don't think it affects my point
18:53:35 * gwern notes that there are at least three ways I could argue macs are not UNIX, and none of which are relevant to my point that macs are painful for free software to support, on a level more remiscent of Windows pain than, say, openbsd pain
18:54:06 <sjanssen> glguy: there are many ways in which OS X is not your typical Unix-like
18:54:14 <sjanssen> for example, X11 is a ghetto
18:54:17 <slava> gwern: i've had more openbsd pain than windows pain
18:54:30 <newsham> slava: thats just theo ;-)
18:54:40 <slava> no, i mean, getting shit to work right on openbsd
18:54:41 <glguy> sjanssen: X11 is a ghetto, yes
18:54:47 <sjanssen> glguy: on OS X
18:54:54 <glguy> in general
18:54:56 <gwern> slava: what, for haskell stuff?
18:54:57 <sjanssen> glguy: X11 is a perfectly reasonable system otherwise
18:55:06 <slava> gwern: no
18:55:12 <slava> low-level systems programming stuff
18:55:14 <sjanssen> glguy: can you actually argue that point?
18:55:24 <gwern> ok then, I don't really care about low-level systems programming stuff :)
18:55:47 <slava> people that develop your compilers and tools do though
18:55:53 <newsham> "not only is unix dead, its beginning to smell bad" -rob pike.
18:56:01 <glguy> sjanssen: that nvidia has to replace so much of the standard xorg code with a proprietary look-alike to get decent 3d performance because the feature set isn't there?
18:56:11 <newsham> .... probably talking about X
18:56:20 <gwern> newsham: ignore him; he's just unhappy plan 9 or inferno never caught on
18:56:24 <slava> openbsd doesn't even support native threads yet iirc
18:56:32 <dons> slava: wtf?
18:56:35 <newsham> gwern: i dont think plan9 was ever intended to catch on.
18:56:40 <newsham> inferno maybe.
18:56:57 <glguy> and I agree that OS X is different than many of the "unix-like" systems
18:57:04 <glguy> but it is certified as a UNIX
18:57:04 <dons> slava, you mean kernel threads, in the style of pthreads?
18:57:08 <slava> dons: yes
18:57:13 <sjanssen> glguy: I think this has more to do with nvidia than X.org (which also isn't the same as X11, I'd like to add).  Look at Intel's team for a good example of how to work with the code rather than against it
18:57:35 <dons> hmm, I don't think that's true, slava. there's certainly some issues with smp, but pthreads at least works. :)
18:57:35 <gwern> newsham: maybe. certainly plan 9 went down some very bad paths if the goal was to popularize it
18:57:39 <newsham> gwern: and he has a very valid point.  that the real unix ended about 25 years ago, and what is living on now is not unix nor particularly elegant
18:57:40 <dons> the scheduler's not so hot though.
18:57:47 <slava> dons: pthreads work but iirc they're not kernel threads
18:58:09 <dons> hmm. do you have a ref?
18:58:15 <gwern> newsham: alas, worse is better
18:58:25 <dons> slava, i switched to linux from openbsd for better threading, fwiw :)
18:58:41 <dons> my `par` programs weren't terribly efficient when stuck on one core.
18:58:41 <slava> http://groups.google.com/group/comp.unix.bsd.openbsd.misc/browse_thread/thread/cbea9c8b273ac0d6
18:58:42 <newsham> openbsd has rfork.  sounds like threads to me.
18:58:43 <lambdabot> Title: Are OpenBSD threads (pthreads) using more than one core of multicore CPUs? - com ..., http://tinyurl.com/62yx4p
18:59:49 <dons> slava, ah, good ref. espie knows what he's talking about.
19:00:06 <dons> and that's exactly the behaviour you'll see -- threaded stuff tied to one kernel process.
19:00:18 <slava> yeah, hence, no native threads :)
19:00:32 <dons> yeah, only processes. the pthreads don't multiplex down.
19:00:40 <dons> its not a system for shared mem smp programming.
19:01:41 <newsham> dons: you'd enjoy freebsd *wink* *wink* *nod* *nod*
19:01:52 <dons> too late.
19:02:09 <glguy> dons: does that explain the poor results you were getting from the threaded runtime on openbsd?
19:02:25 <glguy> when your benchmark was just jumping from one CPU to the other
19:02:31 <dons> glguy, exactly that.
19:02:38 <TomMD> On the OS front, after seeing http://web.cecs.pdx.edu/~rebekah/papers/hhv.pdf there is enough Haskell + Systems work out there that I am almost surprised a Haskell distro, with Haskell System tools and a hypervisor in Haskell, hasn't started.
19:02:39 <lambdabot> Title: Formalizing Information Flow in a Haskell Hypervisor
19:02:45 <dons> i was worried it was a ghc runtime issue, but its further down it seems.
19:03:29 <newsham> tommd: interesting link.  danke
19:03:32 <dons> TomMD: so haskell kernel + the haskell package system, nixos, plus system tools?
19:04:03 <slava> but how would you write to the file system, its purely functional
19:04:05 <slava> </troll>
19:04:15 <glguy> zippers!
19:04:17 <ddarius> ZipperFS
19:04:22 <dons> we've got 2 already.
19:04:24 <newsham> deliminted continuations
19:04:25 <dons> zipperfs and halfs.
19:04:45 <TomMD> dons: Not entirely what I had in mind, but something close:  Haskell Kernel + Haskell VMs providing system services in the micro-kernel sense + virtualized *nix domains providing any needed (and hopefully temporary) compatablity layer.
19:04:45 <dons> but it's a lot of lisp-like ghetto-ism. let's play well with others, rather than building our own incompatible stack of kernel, drivers, fs, network stack, user land :)
19:04:47 <vixey> haskell doesn't write to the file system, the file system writes to itsself
19:04:48 <glguy> (just don't turn your computer off)
19:04:49 <dons> oh, we've already got all those.
19:06:15 <slava> dons: ghc has native and C codegens right?
19:06:25 <dons> slava, yup.
19:06:29 <newsham> tommd: are you familiar with the sel4 project?
19:06:32 <slava> which ones do people use?
19:06:35 <slava> one*
19:06:41 <ddarius> Both.
19:06:45 <TomMD> newsham: Yes I am, but not deeply.
19:06:45 <dons> native is the default.
19:06:52 <sjanssen> slava: the native codegen is default in 6.8 and later
19:06:54 <dons> gcc is slower, but good for numerics.
19:07:01 <TomMD> salva: Native also does better than you might expect.
19:07:03 <newsham> not quite what you're talking about, but similar.. microkernel designed in haskell.
19:07:07 <sjanssen> (on supported platforms, of course)
19:07:12 <dons> native's better on the binary-trees benchmark, interestingly
19:07:18 <newsham> what does HHV do about runtime issues like GC?
19:07:26 <TomMD> pureMD5 used -fvia-c for a long time but I recently changed that based on 1) OS X bugs 2) The lack of any measurable performance difference
19:07:34 <dons> TomMD: cool.
19:07:48 <sjanssen> xmonad ditched -fvia-c long ago
19:07:50 <TomMD> salva: Oh, you are talking about the OKl4
19:07:57 <TomMD> err, newsham, that was for you
19:08:11 <dons> i'm not sure sel4 and okl4 are merged, are they?
19:08:27 <newsham> tommd: the sel4 stuff hasnt been tossed over to OK labs yet as far as I know.
19:08:30 <TomMD> no, but I thought sel4 was a 'c' based project.
19:08:46 <dons> haskell , translated to isabelle, translated to C.
19:08:52 <dons> usual story :)
19:09:01 <newsham> they wrote the spec in haskell, hooked it up to a cpu emulator to run real userland programs to test, translated to isabelle for proofs, and are translating to C
19:09:01 <TomMD> Oh, I am a bit confused on my breakdown, but I have seen the papers and was very happy that more than PSU was working that realm.
19:09:05 <dons> unlike other ones, not haskell on bare metal.
19:09:13 * ddarius still has to read that Executing the Manual paper.
19:09:44 <newsham> supposedly sel4 is done end of this year?  i wonder how the progress is
19:09:55 <TomMD> I was surprised when I saw how close the goals were of the aussies and PSU.
19:10:04 <newsham> psu == coyotos?
19:10:17 <TomMD> Newsham: PSU == Portland State.
19:10:26 <newsham> ohh.. the hhv paper i presume.
19:10:28 <TomMD> coyotos == JHU / Sharpio
19:10:29 <bos> coyotos is jonathan shapiro's group at JHU.
19:10:52 <TomMD> newsham: Yes, and the House work.  And they have their own L4 in Haskell.
19:11:07 <newsham> huh, interesting.. i had heard of house but not their l4 or this hhv
19:11:16 <newsham> will have to read up :)
19:11:30 <dons> some light reading, http://www.reddit.com/r/programming/comments/6vno1/a_neighborhood_of_infinity_untangling_with/
19:11:32 <lambdabot> Title: A Neighborhood of Infinity : Untangling with Continued Fractions: Part 0 : progr ..., http://tinyurl.com/5nr8lz
19:11:44 <TomMD> newsham: Yeah, the hhv stuff seemed to avoid notice and the L4 work was mentioned in the house paper but Rebekah hasn't published about it since.
19:13:58 * dons heads out of the office.
19:14:16 <TomMD> dons: You shouldn't be in the office at 7 on Sat.
19:14:19 <newsham> late saturday at the office
19:14:25 <dons> deadlines, man, deadlines.
19:14:30 <newsham> (sunday if you're still on .au time ;-)
19:14:41 <slava> dons: will ghci ever compile at runtime instead of interpretation?
19:14:56 <TomMD> let the man leave the office
19:14:59 <TomMD> ;-)
19:15:18 * gwern wonders what the deadlines are
19:15:22 <slava> dons: so that you can type your tight loops directly at the interpreter prompt and have them run fast ;)
19:16:18 <ddarius> slava: Use plugs
19:16:56 <gwern> ghci doesn't do compilation? then what does :set -O2 do...
19:17:32 <slava> i thought ghci was a bytecode interpreter
19:17:38 <TomMD> It is
19:17:45 <slava> so... ;)
19:17:47 <TomMD> You can :set about anything you want
19:17:51 <slava> does it compile or not :)
19:17:59 <newsham> does PSU have a project page for their OS work?
19:18:22 <gwern> 'does ghci have the compiler-nature?'
19:18:26 <ddarius> It doesn't (except to bytecode).
19:18:30 <ddarius> plugs does compile.
19:18:56 <TomMD> newsham: Not yet, I expect one within a year.  I'm sure you found the House page.  Also see Mark Jones, Andrew Tolmach, and Rebekah Leslie.
19:19:01 <newsham> "writing systems software in a functional language: an experience report" huh
19:19:14 <TomMD> Yeah, and Jones will talk about that at ICFP
19:19:26 <TomMD> Or, so I think I read.
19:19:39 <newsham> neat
19:20:06 <newsham> wish i could buy back my soul and go to pdx.edu ;-)
19:20:18 <TomMD> Where is your soul?
19:20:26 <newsham> i make money for a living.
19:20:36 <TomMD> So do I, but I intend to be at PSU by March.
19:20:38 <newsham> and grown quite accustomed to it
19:20:43 <TomMD> So have I
19:20:52 <newsham> congrats.
19:21:16 <TomMD> Thanks - now I need to get used to starving again.
19:21:20 <newsham> :)
19:21:28 <newsham> good thing food prices have been moderate ;-)
19:21:34 <TomMD> grrr
19:22:08 <newsham> i bet you can find someone to pay you decent cash doing haskell while studying
19:23:30 <TomMD> It would be nice.  I've mentioned it to a couple profs and am exploring my own options.  I just don't want to have any 'golden handcuffs'.  Though in my case they would just be bronze.
19:25:32 <TomMD> I saw the Sun Sparc deal earlier.  I'm not applying, but hope someone neat like byorgey lands it.
19:31:25 <Elly> sun sparc deal?
19:31:49 <newsham> http://haskell.org/opensparc/
19:32:31 <Elly> heh
19:32:42 <Elly> I've been working on an optimizing compiler for PPC all summer
19:32:48 <Elly> but I know nothing about haskell code generation
19:33:08 <TomMD> I don't think applying would hurt Suns feelings :-)
19:33:25 <slava> Elly: do you know where to find accurate instruction schedules for the G5?
19:35:29 <Elly> no idea at all
19:35:40 <Elly> I am working on the platform-independent part of the optimizer
19:35:42 <slava> ok
19:37:25 * atomiclambda is away: Hello again
19:38:27 <TomMD> atomiclambda?  Is that one dangerous lambda or a lambda that operates in a single step, invisible to other computations.
19:38:49 <slava> TomMD: both!
19:39:11 <TomMD> But I find atomicity to be safe, not dangerous.
19:39:19 <TomMD> ... except to performance.
19:40:05 <newsham> as long as the half-life is short
19:41:39 * TomMD going to sleep, lambdabot /tell me anything funny people say
19:42:09 <newsham> ?quote funny
19:42:10 <lambdabot> edwardk says: heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
19:45:01 <heatsink> @quote
19:45:01 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
19:48:14 <newsham> neat, pdx.edu making new dialect for systems programming
19:50:16 <heatsink> Maybe I'm missing something... does HSFFIG give you a way to get a pointer to a C structure's field?
19:55:31 <dons> TomMD: by March eh? that's interesting news :)
20:15:17 <newsham> how large is the haskell <-> runtime interface in ghc?
20:15:30 <newsham> would it be pretty hard to use the ghc compiler and link against a different runtime?
20:16:30 <lispy> ?quote funny
20:16:30 <lambdabot> edwardk says: heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
20:16:36 <lispy> ?quote not funny
20:16:36 <lambdabot> No quotes for this person. My pet ferret can type better than you!
20:16:46 <heatsink> IIRC, GHC's code generation has some hardwired knowledge of the GC that might be hard to port.
20:16:46 <lispy> ?quote not.funny
20:16:46 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
20:17:14 <heatsink> This is only what I've learned from fooling around with the mangler though.
20:17:18 <Maciej> Any ideas why I don't receive my own posts to haskell-cafe?
20:17:31 <lispy> Maciej: might be a list setting
20:17:44 <dmwit> newsham: We need a Haskell FFI. =P
20:17:50 <lispy> Maciej: you can always sign up for message recipts
20:17:55 <Maciej> No, the settings are correct, I just checked it.
20:18:22 <lispy> Maciej: I mean, some lists just don't send them back to the sender...or is that what you check?
20:18:23 <hml> :t show
20:18:25 <lambdabot> forall a. (Show a) => a -> String
20:18:26 <lispy> Maciej: do you use gmail?
20:18:32 <lispy> :t fix show
20:18:32 <lambdabot> String
20:18:39 <Maciej> Yes I do
20:18:44 <newsham> dmwit: ?
20:18:49 <lispy> Maciej: ah, i think it's gmail's fault then
20:19:20 <dmwit> newsham: ...to link against other Haskell code, generated by a different compiler.
20:19:35 <dmwit> i.e. we need both a C FFI and a Haskell FFI.
20:19:43 <newsham> ahh. i see what you're saying.
20:19:54 <dmwit> And now, if the joke is thoroughly killed, I have some reddit to read.
20:19:57 <Maciej> lispy: What's the problem with gmail?
20:20:21 <dmwit> ;-)
20:20:23 <lispy> Maciej: in my experience when you email a list, gmail doesn't show you the message that the list sends...
20:20:42 <dmwit> Maciej: gmail tries to do the "Right Thing" about only showing one copy of any given email.
20:21:03 <dmwit> It is one of the misfeatures that I am sad to say was duplicated by "sup" -- otherwise my favorite mail client.
20:22:48 <Maciej> Strange ..
20:26:28 <lispy> Maciej: if I were you, I'd check the list archives just to be sure it went through.  If it did, then just assume it will continue to work :)
20:27:52 <Maciej> Well, I receive respones to my posts, so it just works fine. :-)
20:40:52 <hjlj> > take 100 $ fix show
20:40:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:43:32 <dmwit> > fix show -- drop the take
20:43:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:44:49 <int-e> > take 10 . map fst . filter ((=='"') . snd) . zip [1..] $ fix show
20:44:50 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
20:48:06 <dmwit> > take 10 . map length . groupBy (const (=='"')) $ fix show
20:48:07 <lambdabot>  [1,2,1,1,2,1,1,1,1,1]
20:48:44 <dmwit> > take 10 . map length . groupBy (const (=='\\')) $ fix show
20:48:45 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
20:51:58 <DaveS123> A quick question: Is there any way to get the type of an expression to be used for comparison?  I.e. (typeOf a) == (typeOf b)
20:52:16 <vixey> DaveS123: I didn't understand that.
20:52:31 <vixey> :t typeOf
20:52:32 <lambdabot> forall a. (Typeable a) => a -> TypeRep
20:52:33 <vixey> you mean this?
20:52:35 <dmwit> Types are known at compile-time, there's no need to compare them.
20:52:38 <DaveS123> well... everything has a type... and I'm trying to compare things by type
20:52:43 <DaveS123> i know you can use :t in the interpreter
20:52:51 <DaveS123> but that doesn't help me for comparing things in code
20:53:01 <vixey> DaveS123: No I don't get it
20:53:02 <EvilTerran> do you have a use case for this?
20:53:24 <vixey> DaveS123: For one thing,
20:53:28 <vixey> data Bool = True | False
20:53:34 <vixey> data Flip = Heads | Tails
20:53:42 <vixey> DaveS123: Is Bool == Flip? or not?
20:54:12 <DaveS123> mm no
20:54:32 <dmwit> I'm with EvilTerran.
20:54:35 <dmwit> What's the use case?
20:54:41 <vixey> DaveS123: How do you know they aren't equal?
20:54:45 <DaveS123> I'm trying to use a groupBy function
20:54:48 <dmwit> We might be able to help you if we know a bit more about what you're trying to do.
20:55:03 <dmwit> DaveS123: Higher-level; tell us in English the goal.
20:55:48 <DaveS123> hmm... actually I've realized a bit of an oversight
20:56:41 <DaveS123> I'll be back to expand on my question if I realize that its still relevant
20:56:44 <DaveS123> :)
20:56:53 <DaveS123> regardless, thanks for the prompt replies
20:56:57 <koninkje> DaveS123: In order to "compare" types in code, you'll need to develop some type-level equality predicate. There are a few different ways to do so implementation-wise, not to mention semantics-wise
20:57:44 <DaveS123> what do you mean by type-level equality predicate?
20:58:00 <vixey> DaveS123: How do you know that Bool and Flip aren't equal?
20:58:01 <dmwit> He means you don't want to do that. ;-)
20:58:08 <DaveS123> haha fair enough
20:58:28 <dmwit> DaveS123: In most cases, it is enough to have a sum type with just a few constructors, and just make an Ord instance for that instead.
20:58:49 <dmwit> For example, there's a totally reasonable Ord instance for (Either Bool Int).
20:58:59 <koninkje> DaveS123: well (==) only works on the value level to say whether two values of type t are the same. Going higher-order one could define a type class (:==:) that detects whether two types of the same kind are "equal"
20:59:25 <DaveS123> hmm interesting
20:59:36 * vixey just wants DaveS123 to say "because they have different names" :/
20:59:45 <koninkje> DaveS123: Chances are doing that would be using an autocannon for a flyswatter for your purposes
21:00:14 <koninkje> vixey: But does that really mean they're different? they're within an isomorphism from each other...
21:00:33 <dmwit> koninkje: I think that's exactly vixey's point.
21:00:56 <vixey> (it's not but I didn't want to define type (dis)equality)
21:00:57 <DaveS123> yes, sounds like it would be - just experimenting with ideas in my head.  I'm quite new to Haskell if you couldn't tell, it takes quite a different mindset to give types this much consideration.
21:01:16 <DaveS123> but I like it.
21:01:45 <DaveS123> makes sense in the functional paradigm
21:01:56 <koninkje> If you're worrying about the definition of equality on types then you've left Haskell and joined the fine art of category theory :)
21:02:45 <DaveS123> Ok, well thanks all for your help.
21:05:07 <koninkje> vixey: I found a paper you might like: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3615
21:05:08 <lambdabot> Title: What is unification? A categorical view of substitution, equation and solution - ...
21:05:32 <vixey> koninkje: Thank you
21:05:37 <koninkje> :)
21:15:32 <mmorrow> ddarius: ping
21:15:45 <ddarius> mmorrow: ?
21:16:17 <mmorrow> ddarius: if you had to install one forth interpreter (on linux), which would it be
21:16:28 <mmorrow> (ie, which should i get)
21:16:42 <vixey> gforth
21:16:55 <mmorrow> cool
21:17:04 <vixey> btw mmorrow: If you are bored read jones forth was posted on ltu
21:17:11 <bwr> can i still use putStr etc when using nanocurses?
21:17:23 <vixey> it's basically heavily commented assembly but very interesting
21:17:30 <mmorrow> vixey: heh, i think i have that printed out somewhere...
21:17:43 <mmorrow> (if i'm thinking of the same thing)
21:17:55 <mmorrow> ddarius, vixey: what about common lisp
21:18:24 <mmorrow> ..."if you could have only one"
21:18:27 <vixey> haha
21:18:34 <mmorrow> err, i meant
21:18:43 <vixey> SBCL and SLIME with paredit in Emacs
21:18:44 <mmorrow> "only one common lisp implem"
21:18:57 <mmorrow> ok, thx
21:19:57 <mmorrow> oh, i guess i should have said s/forth interpreter/forth environment/
21:20:07 <lispy> I had this one application in lisp, I recall starting a compile + run, in both sbcl and clisp at the same time.  sbcl took twice as long to compile but the app finished first in sbcl :)
21:20:35 <lispy> I was quite enamored to sbcl after that :)
21:20:38 <mmorrow> sbcl it is
21:20:54 <lispy> also, sbcl is more to the standard, clisp intentionally violates it
21:21:05 <vixey> sbcl is written in lisp
21:21:13 <vixey> clisp is written in C
21:21:24 <vixey> so.. I prefer sbcl :)
21:21:28 <lispy> sbcl is just a lot cooler too :)
21:21:57 <vixey> yeah you can hack the compiler while it's running
21:22:11 <vixey> if you have slime and so on
21:22:11 <ddarius> SBCL would be one of the first choices.
21:22:29 <hml> :t 1.0
21:22:33 <lambdabot> forall t. (Fractional t) => t
21:22:39 <hml> :t 1.0 ::Float
21:22:40 <lambdabot> Float
21:22:44 <hml> :t 1.0 ::Double
21:22:46 <lambdabot> Double
21:22:58 * mmorrow just did sudo yum install -y *sbcl* *gforth*
21:23:19 <dsrogers> greetings.
21:23:34 <dsrogers> HOC and mac os 10.5 are a match in heaven waiting to happen.
21:23:47 <ddarius> mmorrow: gforth is probably one of the most featureful forths available for Linux, but forth is a strange beast.
21:24:01 <dsrogers> apple has made writing language bindings so -- very -- easy
21:24:34 <vixey> dsrogers: hey have you thought about interacting with objc?
21:24:35 <mmorrow> ddarius: ha, it's appearing that way from the small bit i've read so far. it looks really interesting..
21:24:47 <dsrogers> vixey: in what sense?
21:25:07 <vixey> dsrogers: I wonder what happens with haskells GC and objcs GC, having two of them... wont they fight?
21:25:25 <ddarius> vixey: They shouldn't.
21:25:36 <dsrogers> well, depends on how haskell implements their GC, but objc plays nice.
21:25:56 <dsrogers> it only collections objects allocated in the zone dedicated to garbage collection
21:26:06 <dsrogers> it doesn't collect things allocated with straight malloc
21:27:16 <dsrogers> and apple has included libffi by default (which is good because the one included in HOC doesn't compile anymore)
21:27:45 <dsrogers> and apple has also included xml descriptions of every single framework they install.
21:27:56 <dsrogers> and a tool for generating more of these descriptions
21:28:02 <vixey> oh that should make thisg easy
21:28:39 <dsrogers> it's stuff called BridgeSupport
21:28:49 <vixey> that's weird
21:28:54 <vixey> apple didn't implement BridgeSupport
21:28:57 <dsrogers> apparently apple is trying to encourage support for language bindings.
21:29:05 <dsrogers> no, not originally.
21:29:08 <dsrogers> it's open source.
21:30:18 <dsrogers> actually, I think they may have implemented it.
21:30:19 <dsrogers> http://bridgesupport.macosforge.org/
21:30:21 <lambdabot> Title: BridgeSupport
21:32:39 <ttmrichter> I'm trying to build cabal-install 0.5.1.  The configuration step is borking because I don't have zlib of a particular version nor HTTP of a particular version.  I can find zlib, but... what is this HTTP library it's talking about and where is it to be found?  It's not in the GHC sources and it's not on HackageDB.
21:33:32 <int-e> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
21:33:34 <lambdabot> Title: HackageDB: HTTP-3001.0.4
21:34:47 <hjlj> > concat $ map ((++ "\"") . (`take` repeat '\\') . (+ (-1)) . (2^)) [0..]
21:34:53 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:35:04 <int-e> (+ (-1)) === pred
21:35:13 <hjlj> thanks
21:35:22 <mmorrow> > fix show
21:35:23 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:35:27 <int-e> @type pred
21:35:28 <lambdabot> forall a. (Enum a) => a -> a
21:35:46 <int-e> (not quite, this is in a different type class as you can see. but it works for integral types)
21:36:00 <int-e> with limited range (Int)
21:36:29 <int-e> @src pred
21:36:29 <lambdabot> Source not found. Do you think like you type?
21:36:57 <hjlj> Integer isn't a Enum?
21:37:02 <hml> http://hpaste.org/9501 ... why is there an error in this pattern?
21:37:15 <int-e> > pred (2^70)
21:37:16 <lambdabot>  1180591620717411303423
21:37:17 <hml> on the x:[] line
21:38:07 <int-e> oh. integer must have its own 'pred' implementation then. the default implementation is  pred                   = toEnum . (`minusInt` oneInt) . fromEnum   and the range of Int is limited.
21:38:29 <hjlj> ok
21:39:31 <hml> why do i get a parse on the third line for the following: http://hpaste.org/9502
21:39:40 <mmorrow> > ([1,2]++) . filter (>2) . fmap ((+1) . length) . group $ fix show
21:39:48 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:39:53 <mmorrow> > fix (scanl (+) 1)
21:39:54 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:40:10 <vixey> > extendSequence [1,2,4,8]
21:40:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:40:29 <mmorrow> > fix ((1:) . scanl (+) 1)
21:40:31 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:40:51 <hjlj> hml
21:41:04 <hjlj> i think you might need brakets around x:xs
21:41:24 <int-e> hml: my_output_helper x:[] gets parsed as (my_output_helper x) : [] -- hjlj is right.
21:41:28 <ttmrichter> Hmmmm.  Odd.  Maybe I didn't let the Hackage page load fully.  When I searched on HTTP I couldn't find it, but it is there now.
21:41:32 <ttmrichter> Thanks, int-e
21:43:57 <bwr> how can i get input until tab is pressed?
21:44:13 <bwr> i am trying to figure out how to do this with System.Console.Readline... but it is a little confusing
21:45:16 <ttmrichter> OK, next issue.  Trying to build yi-gtk gives me problems with not finding appropriate versions of gtk (>=0.9.11) and sourceview (>=0.9.11).  I also note that the hackage logs show the same problem.  Whereabouts does one find these libraries in the right version?
21:45:39 <dsrogers> back...
21:45:55 <dsrogers> anyways, that eliminates a ton of code from HOC for scanning header file.s
21:46:09 <dsrogers> and GC eliminates even more code.
21:46:29 <int-e> ttmrichter: gtk2hs is what you need. http://www.haskell.org/gtk2hs/
21:46:30 <lambdabot> Title: Gtk2Hs
21:46:42 <int-e> (not yet cabalized, so it can't be found on hackage)
21:47:02 <ttmrichter> Ah!  GTK2HS is...  Yeah, what you just said.  Thanks again, int-e.
21:48:10 <int-e> ttmrichter: be sure to check the configure output that sourceview is being built; it depends on whether the C library is installed or not.
21:49:02 <bwr> anybody? /
21:49:03 <bwr> :/
21:49:21 <ttmrichter> I just ran the configure script.  Sourceview is being installed, but a few other libraries aren't that I can't find immediately.  Time to hunt through aptitude.
21:50:06 <ttmrichter> The libraries missing are svgcairo, gtkglext, mozembed, gstreamer and "documentation".  I imagine that latter one is a configure script option.
21:50:31 <dons> is that for gtk2hs, ttmrichter
21:50:32 <dons> ?
21:50:48 <ttmrichter> Yes.  I'm trying to build gtk2hs so I can build yi-dtk, Don.
21:50:54 <ttmrichter> yi-gtk, that is.
21:51:02 <dons> on arch, those dependencies are, gconf, gtkglext, gtksourceview, libglade, librsvg
21:51:05 <dons> http://aur.archlinux.org/packages.php?ID=14890
21:51:06 <lambdabot> Title: AUR (en) - gtk2hs
21:51:09 <dons> so maybe similarly named on debian.
21:52:00 <dons> this is really nice, http://www.reddit.com/r/programming/comments/6vnxe/a_tutorial_on_information_visualization_and/
21:52:01 <lambdabot> Title: A tutorial on information visualization and visual analytics in Haskell [PDF] :  ..., http://tinyurl.com/6jnneh
21:52:23 <dons> looks like jefferson's creating something rather beautiful here, with opengl and gtk2hs/cairo
21:52:45 <dons> shapr: ^ check that out. isn't that awesome?
21:53:41 <ttmrichter> Which version of sourceview should I be installing?  I have 1 and 2 available.
21:54:29 <dons> hmm. i'm using 1.8.5
21:54:44 <dons> 2. is "gtksourceview2" on my system.
21:55:22 <ttmrichter> I just installed both dev packages for safety.  :)
21:57:51 <humasect> interesting, dons
21:58:27 <ddarius> His readDatafile function does not seem like it would give nice streaming behaviour.
21:58:28 <dons> jefferson's giving a talk on this at defun, http://www.deinprogramm.de/defun-2008/abstracts/heard-abstract.txt
21:58:29 <lambdabot> http://tinyurl.com/56e66y
21:58:38 <dons> but he could even be writing a book, by the looks of it..
21:59:42 <bwr> anyone know of a guide for using nanocurses?
21:59:47 <ttmrichter> Weird that gtk2hs doesn't want to install the gstreamer support despite the libs being installed.
21:59:57 <dons> dcoutts: you might want to blog about it, if he's using gtk2hs, http://bluheron.europa.renci.org/docs/BeautifulCode.pdf
21:59:58 <lambdabot> Title: cache:http://bluheron.europa.renci.org/docs/BeautifulCode.pdf - Google Search
22:29:29 <dsrogers> am I missing something or is Language.Haskell.TH almost completely undocumented?
22:29:47 <heatsink> Documenting TH has not been a high priority, unfortunately.
22:30:07 <heatsink> The TH paper is a good start, and if you want to do something specific, you can ask here.
22:30:08 <catechu> heatsink: What is TH?
22:30:14 <heatsink> catechu, Template Haskell
22:30:26 <catechu> heatsink: OK, thanks
22:30:27 <dsrogers> where there isn't even a link to the TH paper at the top of the TH haddock documentation.
22:30:30 <dsrogers> so, where is it?
22:31:10 <heatsink> http://research.microsoft.com/~simonpj/papers/meta-haskell/
22:31:11 <lambdabot> Title: Template metaprogramming for Haskell
22:31:40 <heatsink> There's also a page on the wiki that might be useful, http://www.haskell.org/haskellwiki/Template_Haskell
22:31:40 <lambdabot> Title: Template Haskell - HaskellWiki
22:32:34 <bwr> I am trying to do command line input like program prints <a b=" and then the user enters text and hits enter and the program does " ... and so on. I have looked at several libraries but i can't figure it out. Any help?
22:33:02 <sjanssen> bwr: sounds like you just want getLine
22:33:03 <heatsink> @t interact
22:33:04 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:33:05 <sjanssen> @type getLine
22:33:07 <lambdabot> IO String
22:33:09 <heatsink> @type interact
22:33:10 <lambdabot> (String -> String) -> IO ()
22:33:20 <bwr> sjanssen: but i want to fill in parts of the line for the user
22:33:38 <humasect> putStr >> flush
22:33:58 <sjanssen> bwr: you probably want hSetBuffering stdout NoBuffering
22:34:09 <sjanssen> (or explicitly flush after putting strings)
22:34:09 <bwr> ok
22:34:25 <bwr> but how do i have getLine end on tab instead of new line
22:34:47 <bwr> oops
22:34:49 <dmwit> You have to write your own.
22:34:50 <heatsink> oh, you want to implement tab-completion?
22:34:53 <bwr> i said enter above... i meant tab
22:35:06 <dmwit> But really, you probably want readline. =)
22:35:09 <heatsink> Sounds like you want the readline library
22:35:27 <bwr> i don't really want tab completion either
22:35:55 <bwr> i just want to end input on tab
22:36:12 <bwr> just like getLine but end on tab
22:37:06 <ttmrichter> Has anybody here had any success building gtk2hs 0.9.13?  Specifically with mozembed?  I'm getting the error "can't find file: mozembed/Graphics/UI/Gtk/MozEmbed.hs" while building it and am getting the feeling that MozEmbed isn't supported or something.
22:39:18 <heatsink> bwr: I think you'll have to build that out of low-level operations in System.IO.  That means you'd have to write your own code for backspace and echoing.
22:39:30 <bwr> heatsink: ok thanks
22:42:32 <bos> does bjorn buckwalter hang out here?
22:43:11 <dons> hmm, don't think so.
22:43:19 <dons> he's an email guy
22:43:41 <bos> yeah.
22:44:03 <bos> i'm trying to think if it's worthwhile adding another functional data structure to chapter 14.
22:44:08 <bos> it's kind of a skinny chapter.
22:44:19 <bos> maybe i should write about Data.Sequence.
22:44:52 <rwbarton> bwr: On a unix system you'll also have to change the terminal mode, as by default, your program will only receive input one line at a time (because the user has a chance to edit the line using backspace)
22:45:09 <dons> Sequence is fairly important. IntMap is important.
22:55:26 <bwr> rwbarton: thanks
22:55:43 <bwr> i did hSetBuffering stdin NoBuffering
22:55:45 <noohgodno> how harrowing is the task of writing a language engine in haskell
22:56:13 <heatsink> what's a language engine?
22:56:21 <rwbarton> Was that sufficient?
22:56:36 <dons> noohgodno: pretty straightforward, i guess you mean an interpreter?
22:56:51 <bwr> well, as far as the accepting a character before hitting enter, yea
22:57:08 <dons> perl6 seems to have found it easy in haskell. and there's a lot of references, http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
22:57:11 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
22:57:31 <rwbarton> bwr: Oh, I guess so, neat.
22:57:45 <bwr> then i am trying...
22:57:49 <bwr> getOption = do c <- getChar cs <- if c == '\t' then getOption else return [] return (c:cs)
22:57:52 <bwr> oops
22:58:20 <bwr> imagine new lines in appropriate places
22:59:22 <bwr> oops
22:59:26 <bwr> i have the logic backwards
22:59:27 <bwr> haha
22:59:59 <bwr> looks like it works if i change that to /= '\t'
23:00:00 <rwbarton> bwr: hSetBuffering stdin NoBuffering doesn't do what you want if you compile with ghc
23:00:14 <bwr> really? i am using runghc
23:00:32 <rwbarton> Yeah, I meant ghc as opposed to ghci=runghc
23:00:43 <bwr> seems to work for me with ghc
23:01:27 <bwr> i need to turn off character echo though
23:02:19 <dons> http://www.reddit.com/r/programming/comments/6vo4p/fully_distributed_revision_control_a_pullonly/ interesting
23:02:20 <lambdabot> Title: Fully distributed revision control: a pull-only workflow : programming, http://tinyurl.com/668hs5
23:03:55 <bwr> rwbarton: http://hpaste.org/9503
23:04:30 <rwbarton> Ah, silly me.  I forgot about output buffering :)
23:05:09 <heatsink> dons: git and mercurial seem to have overtaken darcs in popularity.
23:06:06 <dons> heatsink: really?
23:06:30 <dons> i must have my head under a rock, in the sand, on mars :)
23:08:46 <stepcut> damn linus and his pratical, unprincipled hacks
23:08:57 <stepcut> I hear linux is overtaking minix too
23:09:05 <dons> no, srsly?
23:09:15 <dons> but minix is so clean and well documented!
23:09:44 <dons> bah, worse is somehow ... better.
23:09:48 * araujo thinks we need a Haskell OS
23:09:48 <stepcut> and, you can do kill -9 on your drive controller, and it will recover gracefully
23:09:52 <heatsink> That's my impression anyway.  I've overheard people talking about the DVCS concept with those two as exemplars.
23:09:54 <stepcut> araujo: another Haskell OS ?
23:10:07 <stepcut> dons: no, just more popular ;)
23:10:10 <dons> heatsink: :) i think you missed the huge debate this week about ghc switching to git.
23:10:14 <araujo> stepcut, there is never enough Haskell apps
23:10:29 <dons> and the corresponding big resurgence of darcs activity
23:11:08 * stepcut vowes to not check out ghc until it's back in darcs again ;)
23:11:16 <heatsink> dons: Indeed I did.  Though I saw a message about it on the mailing list.  Is it in git now?
23:11:25 <dons> stepcut: hah
23:11:38 <dons> heatsink: yeah
23:11:51 <heatsink> somehow dissatisfying.
23:12:21 * araujo would prefer darcs, but can see the git advantages
23:12:23 <stepcut> heatsink: unless GHC developers hate git more than darcs, then it will be funny ;)
23:12:37 <stepcut> though, I don't have any reason to believe that will happen
23:12:50 <heatsink> http://en.wikipedia.org/wiki/Abilene_paradox
23:12:51 <lambdabot> Title: Abilene paradox - Wikipedia, the free encyclopedia
23:13:07 <stepcut> git's fuzzy file rename support grates on my soul, but I don't think that is going to affect GHC much
23:13:45 <heatsink> Can you point me to a log of the debate?
23:14:54 <bos> i look forward to all the heated rants from people who shoot themselves in the foot with git's idiosyncratic ways of handling branches and rebasing and so on.
23:15:51 <dons> ah rebase. there's a paper in explaining that one.
23:16:05 * stepcut can not honestly recommend any revision control systems
23:17:11 <bos> there's little incentive to develop one that's both fast, flexible, and friendly now.
23:17:42 <dogbite_> does haskell have a 'split' function build in?
23:17:46 <dogbite_> to split strings?
23:17:47 <stepcut> bos: both usually takes two arguments, not three..
23:17:54 <tehgeekmeister> what's the best haskell library to use for some really simple xml parsing on a nearly 4 gig file (just need to grab the contents of each of the articles in a wikipedia dump)?
23:18:04 <bos> stepcut: it's okay, english isn't h-m typed.
23:18:06 <dogbite_> string -> char -> [string]
23:18:25 <dons> tehgeekmeister: hmm. 4G ?
23:18:28 <bos> dogbite: not really.
23:18:37 <ttmrichter> Building yi-gtk now gives me this message: Yi.hs:56:7: Could not find module `System.Posix.Signals': it is a member of package unix-2.3.0.1, which is hidden
23:18:41 <dons> that's a tough one. haxml does lazy bytestrings.
23:18:43 <dogbite_> okay i'll write it myself then.  should be easy.
23:18:52 <humasect> -package unix
23:18:54 <tehgeekmeister> dons: yeh, it's nearly 4g after unzipping, the french wikipedia dump
23:18:58 <dons> dogbite_: there's on in bytestring.
23:19:00 <ttmrichter> I tried this with cabal-install.  I'm not sure how to get that unix-2.3.0.1 library.
23:19:01 <dons> split, that is.
23:19:16 <humasect> ttmrichter: try to find a place to add -package unix to ghc arguments
23:19:19 <bos> dogbite_: yeah, it's one of those surprising omissions from Prelude
23:19:20 <dons> tehgeekmeister: so look on hackage for one of the xml parsers, that must support lazy bytestrings
23:19:25 <dogbite_> dons: okay.  and don't worry, i'm not diving into some csv things.  just working on a euler
23:19:31 <dons> dogbite_: :)
23:19:39 <dons> dogbite_: csv works now though, remember!
23:19:49 <dogbite_> dons: oh, it does.  i know that all too well, ha
23:19:52 <Quadrescence> Bleh, figuring out user input and bla bla bla is hard. :(((
23:19:54 <bos> dealing with a 4GB XML file isn't trivial.
23:20:23 <bos> something like tagsoup would be perfect, if it wasn't string-based.
23:20:36 <dons> yeah, a lazy bytestring tagsoup. hmm.
23:20:42 <dons> alex can lex lazy bytestrings now, btw.
23:20:46 <dons> so easy to roll efficient lexers
23:21:54 * stepcut wonders if it's too late to hype tla for ghc
23:23:16 <Quadrescence> ?hoogle IO () -> String
23:23:16 <lambdabot> No matches, try a more general search
23:23:27 <Quadrescence> ?hoogle IO -> String
23:23:28 <lambdabot> No matches, try a more general search
23:23:55 <bos> of course, a lazy bytestring tagsoup wouldn't really be sensible either, due to character set issues.
23:24:09 <stepcut> Quadrescence: good luck with that
23:24:14 <bos> XML being one of those document types where non-ASCII data is really rather likely.
23:24:27 <catechu> dogbite_: How have you implemented string splitting? I am new to Haskell and am trying it as an exercise.
23:24:45 <dogbite_> i'm just about to do it
23:25:02 <paczesiowa> is there strict hGetContents?
23:25:13 <dogbite_> i consider myself new too, so it'll be an exercise for me too
23:25:17 <dons> paczesiowa: yeah. both for bytestrings, and in the strict package for String.
23:25:32 <dons> bos, i wonder if the utf8-string bytestring ops are enough for utf8 lexing
23:25:35 <Quadrescence> stepcut: I don't even know what I'm doing/looking for really.
23:25:57 <dons> http://hackage.haskell.org/packages/archive/utf8-string/0.3.1.1/doc/html/Data-ByteString-Lazy-UTF8.html
23:25:59 <lambdabot> Title: Data.ByteString.Lazy.UTF8, http://tinyurl.com/65luua
23:26:08 <mmorrow> @src fix
23:26:08 <lambdabot> fix f = let x = f x in x
23:26:08 <dons> basically, you need uncons for utf8 for the lexer. so that might be enough.
23:26:15 <stepcut> Quadrescence: that particular function is (mostly) impossible in Haskell -- it's why Haskell is cool ;)
23:26:28 <paczesiowa> dons: strict package for String?
23:26:45 <dons> paczesiowa: yeah, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
23:26:46 <bos> dons: that would work, but UTF-8 isn't the only valid encoding for XML.
23:26:46 <lambdabot> Title: HackageDB: strict-0.3.2
23:26:59 <tehgeekmeister> i assume HXT's DOM implementation won't be useful;; DOM doesn't work for larger files, right?
23:27:06 <dons> bos, yep. so we'd need a suite of uncons' per-encoding
23:27:21 <Quadrescence> stepcut: To get user input as a string? That's nowhere near impossible.
23:27:21 <paczesiowa> dons: thanks
23:27:39 <bos> dons: yes, and i pity the poor bugger who'd have to implement all that. it's pretty much years of work.
23:27:56 <dons> so, we have this encodings package. hmm.
23:28:11 <stepcut> Quadrescence: you can use getLine for that. But the type is, getLine :: IO String
23:28:24 <Quadrescence> stepcut: Then maybe I meant to say IO String
23:28:35 <Quadrescence> As I said, I wasn't sure what I was looking for.
23:28:36 <bos> dons: those are all the easy 8-bit encodings. the asian ones will make your eyes bleed.
23:28:39 <stepcut> Quadrescence: I suspect so
23:28:52 <dons> decodeLazy :: enc -> ByteString -> String is an interesting interface.
23:29:15 <stepcut> Quadrescence: it's a sensible thing to search for if you don't know better
23:29:20 <dons> ah yes. so we've an ad hoc mixture of encodings and ways to get at them.
23:29:38 <Quadrescence> stepcut: I suppose so.
23:29:41 <dons> so maybe the solution is to find a C lib that can give us the next char.
23:29:50 <dons> then do an alex lexer that calls those guys.
23:30:58 <stepcut> Quadrescence: types for functions that do I/O operations will always end with, IO <something>
23:31:30 <dogbite_> http://hpaste.org/9504
23:31:42 <dogbite_> i'm going to bed but that's my quick attempt at split
23:31:53 <dogbite_> oh it's flawed
23:31:57 <dogbite_> but it's close
23:32:46 <dogbite_> hmm... scratch that
23:32:53 <paczesiowa> why not represent strings as arrays of boxed chars? wouldn't that help with multibyte encodings?
23:34:01 <luqui> it outlaws infinite strings, of course
23:34:02 <ddarius> Wow, the Abilene paradox actually does refer to Abilene, TX.
23:34:49 <ttmrichter> Is there a summary page somewhere that explains why Darcs was rejected in favour of Git?
23:35:07 <ttmrichter> (And that talks about what other options were looked into.)
23:35:16 <stepcut> ttmrichter: there is a wiki page
23:35:53 <tehgeekmeister> there's the hexpat library on hackage that uses lazy bytestrings and interfaces to the c expat library;; this looks like it should be perfect for my needs, but looking over the documentation real quick I don't see any way of extracting the results of the parse, here's the documentation I'm looking at: http://hackage.haskell.org/packages/archive/hexpat/0.2/doc/html/Text-XML-Expat-IO.html
23:35:55 <lambdabot> Title: Text.XML.Expat.IO, http://tinyurl.com/6l5fda
23:35:57 <paczesiowa> luqui: lazy lists of arrays of course
23:36:17 <bos> tehgeekmeister: there's also a libxml2 binding.
23:36:20 <stepcut> ttmrichter: http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation
23:36:21 <lambdabot> Title: DarcsEvaluation - GHC - Trac
23:36:29 <tehgeekmeister> bos: that could do, too
23:36:35 <ttmrichter> Thanks, stepcut.
23:37:14 <tehgeekmeister> can anyone see a way to get the results of the parse from that documentation?
23:37:20 <ttmrichter> OK, looks like yi *STILL* can't be built by mere mortals.  I give up.
23:37:24 <paczesiowa> tehgeekmeister: you don't
23:37:34 <rwbarton> tehgeekmeister: you have to write a callback in the IO monad that will get called for each element
23:37:48 <paczesiowa> tehgeekmeister: it's based on callbacks
23:38:20 <tehgeekmeister> ah, okay
23:39:08 <bos> if you want a DOM, expat should give it to you.
23:39:51 <dogbite_> http://hpaste.org/9504#a1
23:39:52 <bos> then again, i guess not.
23:39:56 <bos> it's more SAX-like.
23:40:09 <bos> still, that might be more appropriate for a huge XML file.
23:40:28 <dogbite_> probably not the cleanest or the best split
23:40:47 <tehgeekmeister> okay, i still don't see anywhere in the arguments to any of the handler registering functions or any of the other functions that you can register your callback function
23:41:07 <dogbite_> actually i still see flaws in it
23:41:10 <tehgeekmeister> bos: that's why i was looking at it, sax seems more appropriate, especially since i just want to grab the contents of each article
23:41:20 <dogbite_> i'll work on it in the morning .. haskell is so much fun
23:46:33 <tehgeekmeister> oh, in parseChunk :: Parser -> ByteString -> Bool -> IO (Bool) is the ByteString -> Bool a function, not two arguments to parseChunk?
23:46:58 <tehgeekmeister> would that be where you pass in the callback?
23:49:37 <adamvo> Hi, I'm trying to use Data.Vec to solve some linear systems, but it only seems to work properly when I annotate the sizes of matrix and vector
23:51:08 <adamvo> that isn't as useful as I hoped, since I want to use variable sized lists as sources for the vectors
23:51:22 <rwbarton> tehgeekmeister: see setStartElementHandler, etc.
23:51:29 <adamvo> where the size of vector changes the matrix.....
23:52:14 <tehgeekmeister> rwbarton: oh!  i'm sorry, should've understood that quicker
23:52:21 <tehgeekmeister> that's what i get for not having touched haskell in months
23:53:32 <tehgeekmeister> that's exactly what i need, now i can get to work
23:55:12 <paczesiowa> adamvo: if you wanted to use variable sized lists, why don't you just use [] ?
23:56:08 <adamvo> since I'm quite lazy, and elimination is a problem for another day
23:58:45 <Quadrescence> How can this be fixed? --> http://hpaste.org/9505
23:59:25 <Quadrescence> (I didn't state the type of getPuzzle because, well, I don't know how)
