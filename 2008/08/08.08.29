00:01:40 <Cale> Heh, "Performance horrors" has so much more provocative a title than the content. (On the mailing list :)
00:02:14 <thetallguy> conal: thanks for the response.  Was just reading the note about 6.9 in the cabal file when your email arrived.
00:02:39 <Cale> I agree that there should be Ord-specific versions of nub, but we should not be willing to sacrifice its laziness at all.
00:03:45 <DrSyzygy> kolmodin++
00:04:09 <thetallguy> dons: we're getting close to putting HAppS through some more stress tests.  Should be fun, I think.
00:04:59 <dons> thetallguy: sweet.
00:05:30 <thetallguy> the biggest challenge when working with HAppS is reading the type errors
00:08:36 <dolio> Cale: Darcs is slow because of nub! :)
00:08:45 <Cale> dolio: haha
00:09:13 <ivanm> dolio: and an inefficient, custom-coded version at that?
00:09:45 <dons> until nub is fixed, i can't consider haskell for serious development!
00:09:51 <Cale> hahaha
00:10:09 <Capso> We were all nubs once!
00:10:20 <Capso> (Sorry, I'm new here...)
00:10:21 <dons> our investigations have shown F# to have a far more practical nub, free from academic piffle
00:10:23 <glguy_> Does it generate all subsets of the list and check each subset for duplicate elements?
00:10:33 <Cale> anyway, I wanted to make it clear in my post that map head . group . sort is not an acceptable replacement for nub :)
00:11:02 <glguy_> if you are going that route, Set.toList . Set.fromList is better, no?
00:11:04 <conal> thetallguy: is the 6.9 dependency a problem for you?
00:11:06 <ivanm> Cale: which post is this?
00:11:21 <Cale> On the mailing list, under "Performance horrors"
00:11:31 <Cale> (wasn't my title :)
00:11:48 <RayNbow> @bot
00:11:49 <lambdabot> :)
00:11:53 <RayNbow> wb lambdabot :)
00:12:02 <glguy_> What's lambdabot doing awake this late at night?
00:12:21 <ivanm> Cale: how recent was this post?
00:12:31 <dolio> It's on the libraries mailing list.
00:12:36 <ivanm> glguy_: shhh!!! don't jinks it!
00:12:36 <RayNbow> glguy_: it's only 9 AM? :p
00:12:45 <ivanm> dolio: ahhh, no wonder I don't have it
00:12:49 <Cale> oh, libraries...
00:12:59 * ivanm thought Cale meant -cafe
00:13:01 <glguy_> RayNbow: Oh, I meant central universe time
00:13:02 <conal> thetallguy: 6.9 is only need for the Basis (of a vector space) module, which is used for linear maps and hence derivatives
00:13:19 <Cale> ivanm: I didn't actually notice which list it was on :)
00:13:19 <RayNbow> glguy_: which is...? GMT? :p
00:13:30 <glguy_> RayNbow: it is quite similar to PDT
00:13:32 <glguy_> ;)
00:13:37 <RayNbow> oh :p
00:13:44 <glguy_> ;) :-p :0D
00:14:30 <ivanm> http://www.nabble.com/Performance-horrors-td19157271i20.html <-- for others like me who don't read libraries
00:14:35 <lambdabot> Title: Nabble - Haskell - Libraries - Performance horrors
00:16:46 <ivanm> Cale: though map head . group . sort is acceptable if you want the unique elements and don't care about order, isn't it? (ignoring the question about requiring it all to be produced first)
00:17:24 <Cale> ivanm: *and* you don't care how quickly the first element is produced, and you don't care about infinite lists, then yeah
00:17:59 <ivanm> heh
00:18:01 <ivanm> yeah
00:18:10 <ivanm> well, I mean for short-ish lists anyway
00:18:14 <RayNbow> > nub [1..]
00:18:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:18:34 <ivanm> > map head . group $ sort [1..]
00:18:43 <lambdabot>  mueval: Prelude.read: no parse
00:18:47 <RayNbow> Winner: nub
00:19:05 <ivanm> yup
00:20:52 <ivanm> Cale: but as for your statement on complexities... how many libraries include complexities with their haddock documentation?
00:21:03 <Cale> ivanm: Well, a few at least.
00:21:29 <Cale> Data.ByteString does, in addition to Data.Map, Data.Set and Data.Sequence
00:22:13 <ivanm> thought Data.List for example doesn't... so if you're just reading the docs you have no idea the complexity of nub for example
00:22:59 <Cale> Right... so it probably should.
00:23:14 <Cale> Though nub's type gives you a pretty good indication that it's no better than O(n^2)
00:27:04 <mmorrow> nub' :: (Ord a) => [a] -> [a]
00:27:22 <mmorrow> foldl'
00:27:28 <thetallguy> conal: I just wanted to explore.  Trying to retarget a simple portion of reactive, wanted to play with full version for fun and enlightenment.  Will consider installing 6.9, will also consider labotomizing Basis code.
00:27:41 <thetallguy> conal: more tomorrow
00:30:50 <haskellian> are there destructive updates in Data.Map, adjustWithKey fro example?
00:30:58 <Cale> haskellian: no
00:31:15 <Cale> haskellian: Nothing outside the IO monad can do destructive updates.
00:31:24 <Cale> (or the ST monad)
00:35:37 <mmorrow> haskellian: Maps go well with folds
00:35:51 <mmorrow> > foldl' (\m x -> M.insertWith' (+) x 1 m) M.mpty (take 10000 (randomRs (0,7) (mkStdGen 627345)))
00:35:52 <lambdabot>      Failed to load interface for `M':
00:35:52 <lambdabot>       Use -v to see a list of the file...
00:36:04 <mmorrow> > Data.Map.empty
00:36:05 <lambdabot>  mueval: Prelude.read: no parse
00:36:08 <mmorrow> > Map.empty
00:36:09 <lambdabot>      Failed to load interface for `Map':
00:36:09 <lambdabot>       Use -v to see a list of the fi...
00:37:32 <mmorrow> dang, Data.Graph but no Set or Map
00:38:03 <mmorrow> > M.empty
00:38:04 <lambdabot>  mueval: Prelude.read: no parse
00:38:17 <haskellian> what does (k -> a -> a) mean
00:38:42 <mmorrow> a function that takes a 'k' and an 'a' and gives you an 'a'
00:39:06 <mmorrow> :t flip const
00:39:08 <lambdabot> forall a b. b -> a -> a
00:39:25 <mmorrow> > empty
00:39:26 <lambdabot>      Ambiguous occurrence `empty'
00:39:26 <lambdabot>     It could refer to either `Control.Appli...
00:39:30 <ketil> @seen lambdabot
00:39:30 <lambdabot> Yes, I'm here. I'm in #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
00:39:30 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-uy,
00:39:30 <lambdabot> #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
00:39:35 <mmorrow> > insertWith'
00:39:36 <lambdabot>  mueval: Prelude.read: no parse
00:39:39 <RayNbow> @djinn a -> a
00:39:39 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
00:39:48 <mmorrow> > insertWith' (+) 1 1 mempty
00:39:49 <lambdabot>  mueval: Prelude.read: no parse
00:40:16 <mmorrow> preflex: seen Cheiron
00:40:16 <preflex>  Cheiron was last seen on #haskell 3 hours, 22 minutes and 55 seconds ago, saying: Char -> Int
00:41:25 <haskellian> and what can k and a be?
00:41:25 <haskellian> how should ta be writen
00:41:34 <haskellian> adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
00:42:00 <haskellian> does adjustWithKey need 3 arguments? how do i wirte the k  a a? in parenthesis?
00:42:36 <mmorrow> so the args would be:
00:42:45 <mmorrow> [1]   (k -> a -> a)
00:42:52 <mmorrow> [2]       k
00:42:59 <mmorrow> [3]       Map k a
00:43:03 <mmorrow> and the result
00:43:12 <mmorrow> [_]      Map k a
00:44:14 <mmorrow> so it'll look an 'a' up given a key :: k, then use the function (f :: k -> a -> a) you gave it to replace the 'a' with (f k a)
00:47:53 <mmorrow> adjustWithKey (\k a -> case reads k of [] -> a ; (a',_):_ -> a+a') "42" (fromList [("31",9),("asdf",0),("42",20)])
00:47:55 <mmorrow> > adjustWithKey (\k a -> case reads k of [] -> a ; (a',_):_ -> a+a') "42" (fromList [("31",9),("asdf",0),("42",20)])
00:47:56 <lambdabot>  mueval: Prelude.read: no parse
00:48:13 <mmorrow> fromList [("31",9),("asdf",0),("42",62)]
00:49:01 <mmorrow> adjustWithKey (\k a -> case reads k of [] -> a ; (a',_):_ -> a+a') "asdf" (fromList [("31",9),("asdf",0),("42",20)])
00:49:06 <mmorrow> fromList [("31",9),("42",20),("asdf",0)]
00:50:56 <mmorrow> > reads "42" :: Int
00:50:57 <lambdabot>  Couldn't match expected type `Int'
00:51:06 <mmorrow> > reads "42" :: [(Int,String)]
00:51:08 <lambdabot>  [(42,"")]
00:51:15 <mmorrow> > reads "ajsahs42" :: [(Int,String)]
00:51:16 <lambdabot>  []
00:53:03 <mmorrow> > let readM s = case reads s of [] -> Nothing ; (a,_):_ -> Just a in  (maybe 0 (+1) readM "42" :: Int)
00:53:04 <lambdabot>  Couldn't match expected type `Maybe a'
00:53:22 <mmorrow> > let readM s = case reads s of [] -> Nothing ; (a,_):_ -> Just a in  (maybe 0 (+1) (readM "42") :: Int)
00:53:23 <lambdabot>  43
00:53:28 <mmorrow> night
01:15:52 <haskellian> Dmap.adjustWithKey succ "hej" d , why doesnt it work
01:19:19 <haskellian> fakkin maybe typedonking i go crazy with this language, never get anyhting done
01:23:47 <sjanssen> @type Data.Map.adjustWithKey
01:23:48 <lambdabot> forall k a. (Ord k) => (k -> a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
01:24:16 <sjanssen> haskellian: how many arguments does succ take?  How many arguments does the first argument to adjustWithKey take?
01:24:34 <sjanssen> @type Data.Map.adjust
01:24:35 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
01:26:18 <sjanssen> also, what does "fakkin maybe typedonking" mean? :)
01:26:51 <sjanssen> haskellian: did you figure out your problem with adjustWithKey?
01:35:28 <ketil> @seen lambdabot
01:35:28 <lambdabot> Yes, I'm here. I'm in #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
01:35:28 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-uy,
01:35:28 <lambdabot> #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
01:38:45 <ejt> unicycling ?!
01:39:07 <BeelsebobWork_> half of #haskell are in there
01:39:56 <Wild_Cat> is that like lazy biking taken to the extreme, in that since nobody ever looks at the rear wheel it doesn't need to be computed?
01:40:24 <ejt> a colleague at work has just bought one, he's finding it _very_ difficult I think
01:40:37 <BeelsebobWork_> Wild_Cat: exactly
01:40:53 <BeelsebobWork_> ejt: my experience was that it was very very dificult for about 3 months
01:40:57 <BeelsebobWork_> then suddenly I could unicycle
01:41:02 <BeelsebobWork_> and I didn't know when it happened
01:41:07 <ejt> I'll tell him that
01:41:24 <ejt> I'll stick with my two wheel fixed gear bike I think
01:41:31 <haskellian> nah didnt figure it out, the documentation could really use some examples
01:41:41 <BeelsebobWork_> it took me about another 3 months after that to get to being able to mount easily
01:41:54 <haskellian> ridiculous amount of operations to do on Maps but no intuitive easy ones
01:42:02 <BeelsebobWork_> eh?
01:42:06 <ketil> Any reason a function should be shown with lots of entries in prof output, when AFAICT the code only should enter it once?
01:42:13 <BeelsebobWork_> Data.Map has all the intuative easy things to do on them
01:42:29 <BeelsebobWork_> ketil: -O2?
01:42:52 <BeelsebobWork_> also, I've seen that before, even without optimisation, but it does seem more common on -O2
01:43:09 <ketil> BeelsebobWork_, yes.
01:43:19 <ejt> haskellian: what do you want to do with your map ?
01:43:35 <BeelsebobWork_> turn off optimisation and you'll get something more accurate then ketil
01:43:36 <ketil> can I still trust the times from profiling output?
01:44:02 <BeelsebobWork_> ketil: probably not
01:44:03 <ketil> BeelsebobWork_, but I wan't to see how my *optimized* program performs. :-/
01:44:13 <BeelsebobWork_> yeh, unfortunately, not possible
01:44:32 <BeelsebobWork_> I've had it report a function having >2,000,000 entries, and used 0.0 seconds before
01:45:18 <ketil> -O and -O2 makes no difference
01:45:24 <ketil> checking without any -O
01:46:36 <sjanssen> haskellian: try adust rather than adjustWithKey
01:47:19 <ketil> without -O, I got zero entries, which I suppose is closer to 1 :-)
01:48:17 <idnar> bleh, I wish it were "x (g . f)" not "(f . g) x"
01:49:01 <BeelsebobWork> idnar: why?
01:49:20 <idnar> BeelsebobWork: because the latter is the reverse of my mental model
01:49:36 <BeelsebobWork> also, why don't you define ($>) = flip ($), and (>>) = flip (.)
01:49:46 <BeelsebobWork> and then do x $> g >> f
01:50:21 <quicksilver> there is already (>>>) as flip (.) in effect.
01:50:33 <idnar> I could, but nobody else will write code that way
01:50:39 <quicksilver> I don't think there is a flip ($) anywhere by default.
01:50:55 <ketil> Profiling seems very messed up, I get that my function takes less (i.e. about halv) total time with -O0 than with -O, even counting cumulative time.
01:51:08 <BeelsebobWork> quicksilver: yeh, I know -- I was just illustrating that he can do it whatever way he likes
01:51:25 <ketil> no way to fix this (refactoring modules, adding manual cost centres, whatever?)
01:51:34 <BeelsebobWork> ketil: that makes sense to me
01:51:44 <BeelsebobWork> if the optimisations have successfully worked on everything but that function
01:52:09 <ketil> BeelsebobWork, I don't see why it should be *slower* (I'm counting seconds here, not % execution time)
01:52:24 <BeelsebobWork> because optimisations can sometimes make things worse
01:53:32 <ketil> Okay, fair enough.  If that's the case, isn't it a bug in the optimizer? (-O shouldn't do risky optimizations).
01:53:54 <BeelsebobWork> shouldn't it?
01:54:00 <BeelsebobWork> why not?
01:54:19 <idnar> @type (>>>)
01:54:20 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
01:54:29 <BeelsebobWork> if it's 50% better in 90% of cases, and 20% worse in the other 10% of cases, why would you not do it?
01:54:29 <idnar> hmm?
01:55:11 <ketil> BeelsebobWork, because that's what we have -On for (n>1)?
01:55:12 <Deewiant> @ty (Control.Arrow.>>>)
01:55:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Control.Arrow.Arrow a) => a b c -> a c d -> a b d
01:55:26 <hml> i know i can fix the following by restarting (that'sx how i fixed it in the past; i'm running ubuntu; but i'd prefer to fix it some othner way)
01:55:29 <hml> x@x:~$ ghci
01:55:32 <hml> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
01:55:34 <hml> Segmentation fault
01:55:38 <lambdabot> Title: The Glasgow Haskell Compiler
01:55:43 <BeelsebobWork> ketil: the point is though that it has to generate code in *some* way -- what's to stop it chosing one over another?
01:55:54 <hml> other progs; like ls, work fine
01:56:03 <jeffz> hml, where is it crashing?
01:56:06 <idnar> @type (Control.Arrow.<<<)
01:56:07 <lambdabot> forall (a :: * -> * -> *) c d b. (Control.Arrow.Arrow a) => a c d -> a b c -> a b d
01:56:08 <BeelsebobWork> if one is worse in one situation, and the other in a different one, why should it use one over the other
01:56:27 <hml> jeffz: i don't know; how do i figure this out?
01:56:35 <jeffz> hml, strace ghci
01:56:40 <haskellian> I have a Map of Maps, like: http://hpaste.org/10003
01:56:47 <jeffz> hml, might be a systemcall
01:56:58 <quicksilver> BeelsebobWork, ketil: well, ketil is broadly right. -O is supposed to do mostly 'safe' optimisations.
01:57:07 <quicksilver> ketil: but in practice just about every optimisation is a trade-off.
01:57:22 <quicksilver> -O does the "less controversial" ones.
01:57:28 <ketil> BeelsebobWork, okay, sure.  I think emitting code that takes twice the time compared to -O0 is wrong, but perhaps it is inavoidable in some cases.
01:57:50 <hml> jeffz: http://paste.lisp.org/display/66052
01:57:50 <quicksilver> ketil: could also be an interaction with the profiler, unfortunately :(
01:57:51 <jeffz> hml, one of my servers running ubuntu broke itself when it used the wrong combination of glibc and a kernel
01:57:52 <BeelsebobWork> ketil: maybe you have inadvertantly hit upon a pathalogical case though
01:58:06 <hml> jeffz: no no, it ran fine earlier today
01:58:07 <quicksilver> ketil: in principle it does sound like something which should be reported as a 'bug'.
01:58:08 <BeelsebobWork> maybe it's 15% faster in 99.999% of cases
01:58:16 <hml> jeffz: what happens is that after running ubuntu for a fews hours; i start getting random segfaults
01:58:19 <quicksilver> ketil: the GHC devs will close it if they think it's doing the best it can.
01:58:20 <hml> which then disappear after restarting
01:58:26 <quicksilver> hml: sounds like hardware.
01:58:32 <jeffz> hml, yeah, hardware
01:58:36 <hml> fsck
01:58:36 <quicksilver> hml: insufficient cooling, perhaps.
01:58:48 <ketil> It is clearly something to do with the profiler: -O{1,2} -prof : 40 seconds (reported in .prof), -O{1,2}: 20 seconds.
01:58:51 <quicksilver> woo hpaste > 10000 ;)
01:59:15 <jeffz> hml, remove excess dust and try again?  I had a celeron with so much dust it was running at 100C
01:59:22 <ketil> -O0 -prof : 50 seconds (reported in .prof), -O0: 30 seconds.
01:59:38 <BeelsebobWork> ketil: heh, awesome
01:59:39 <hml> is there a way in linux to force the fan to run at max?
01:59:40 <ejt> hml: sounds like a memory error to me, rather than cooling
01:59:55 <hml> ejt: can i tell linux to flush it's file caches?
01:59:57 <ketil> I should probably look at core, too, but I generally only end up more confused when I try that :-)
01:59:58 <ejt> hml: if it goes away upon reboot
02:00:12 <quicksilver> haskellian: do I understand that you are tryign to 'normalise' the second-level?
02:00:18 <quicksilver> haskellian: so that the numbers add up to one?
02:00:38 <ejt> hml: I'm not sure - I have exactly the same problem with my machine, and am intending to just replace the memory at some point
02:01:01 <idnar> @src catMaybes
02:01:01 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:01:03 <ketil> I'll see if I can file a report on it.  Thanks, people.
02:01:30 <haskellian> quik:quicksilver: i calculate individual probabilities but then add them to each other after hand. so if it is 20% 30% 50% it should be 0.2, 0.5, 1
02:01:47 <idnar> > catMaybes [Just 5, Nothing, Just 3, Nothing, Just 1]
02:01:48 <lambdabot>  [5,3,1]
02:02:13 <BeelsebobWork> haskellian: in what order should it be adding them?
02:02:18 <haskellian> so then i can later do random(0 to 1)  an start with the smallest element and if elemnt > rand then choose it
02:02:31 <quicksilver> it sounds like first of all you want to normalise
02:02:33 <quicksilver> (so they add to one)
02:02:41 <quicksilver> and then you want to convert them to a cumulative dist.
02:02:45 <haskellian> beelse: donest matter
02:02:52 <quicksilver> I think that second part might be misguided.
02:02:54 <haskellian> quick: yes
02:03:00 <quicksilver> since maps aren't best thought of as ordered
02:03:04 <quicksilver> (although they are, I suppose)
02:03:09 <haskellian> i have done it python
02:03:18 <haskellian> not the same though
02:04:24 <mmorrow> heh, a cpp red-black tree implem: http://people.freebsd.org/~jasone/jemalloc/progs/rb.h
02:04:57 <BeelsebobWork> mmorrow: o.O
02:05:03 <BeelsebobWork> and they say Haskell is hard to understand?
02:06:23 <sjanssen> mmorrow: all that for want of parametric polymorphism
02:06:26 <Deewiant> haha "Red-black trees are difficult to explain without lots of diagrams, so little attempt is made to document this code."
02:06:50 * mmorrow wants to find some code that uses this code and see it fully expanded ;)
02:07:00 <quicksilver> haskellian: http://hpaste.org/10003#a1
02:07:11 <osfameron> to be fair, the code in okasaki's book is fairly unpleasant too
02:07:12 <quicksilver> haskellian: here is the first part, normalising the probabilities.
02:07:17 <quicksilver> haskellian: perhaps that helps you see the way.
02:07:33 <osfameron> 4x pattern matches instead of abstracting to a more comprehensible pattern
02:07:37 <osfameron> but at least it's compact
02:08:59 <hml> ejt: i found it: http://kassoulet.blogspot.com/2007/12/how-to-clear-disk-cache-in-linux.html
02:09:10 <hml> ejt: it actually works, "echo 3 > ..." got ghci to work again :-)
02:09:16 <hml> so yeah, it looks like my laptop's ram is fscked up
02:10:22 <mc__> fschked up, lol
02:11:39 <ejt> hml: thx, will try that
02:13:45 <haskellian> quik: thanks, looks like a job for scanl
02:16:28 <hml> in emacs/ghci mode, how do i send a ctrl-c
02:16:36 <hml> i.e. in emacs, i hit c-c c-l
02:16:39 <hml> i type in 'main'
02:16:42 <hml> now i want to kill that prog
02:16:48 <hml> or just send a ctrl-c to break it
02:18:31 <quicksilver> hml: C-c C-c
02:20:32 <hml> doesn't work
02:20:47 <hml> i'm also running git mode
02:20:55 <hml> but it shouldn't screw around with the haskell interpreter right?
02:21:44 <quicksilver> C-c C-c should send sigint to ghci.
02:21:49 <quicksilver> I use it all the time.
02:23:19 <hml> Loading package GLFW-0.3 ... linking ... done. C-c C-c
02:23:27 <hml> what's whatp happens when I type 'main' to run my prog
02:23:31 <hml> then hit c-c c-c
02:24:26 <hml> hitting it more times just has C-c C-c showig up in the ghci interpreter
02:24:39 <hml> damn it; we need a way to hpaste entire vm's
02:24:43 <quicksilver> well, then it's worked.
02:24:48 <quicksilver> I don't understand what you're saying?
02:25:00 <quicksilver> if C-c C-c is appearing then you've killed main and have control of the interpreter again.
02:27:02 <hml> main's definitely alive
02:27:10 <hml> since i can still see the running prog
02:27:24 <quicksilver> in a different thread, I imagine.
02:27:38 <hml> *Main GOA> main C-c C-c
02:27:38 <hml> C-c C-c
02:27:47 <hml> also; hitting enter doesn't get me another *Main GOA> prompt
02:27:50 <quicksilver> ah, OK.
02:27:51 <hml> so i think it's still alive
02:27:56 <quicksilver> Then I suspect something is ignoring sigint.
02:28:10 <quicksilver> maybe the GLFW mainloop ignores signals.
02:29:16 <hml> bingo
02:29:32 <hml> quicksilver: you're right, i can't kill it in ghci with ctrl-c either
02:30:24 <quicksilver> also I'm not sure ghci can kill threads which are in FFI calls
02:30:40 <quicksilver> and if it's in an GLFW mainloop it mgiht be living in FFI land.
02:30:56 <quicksilver> possibly if you click in the window or do somethign which triggers haskell code to run that will kill it ;)
02:35:18 <haskellian> is there no scanl for Maps ?
02:35:32 <BeelsebobWork> no
02:35:36 <BeelsebobWork> because maps aren't ordered
02:35:45 <BeelsebobWork> so what order would you scan in
02:35:57 <quicksilver> haskellian: I don't think there is any point builting the cumulatives.
02:36:00 <haskellian> any would be fine...
02:36:07 <BeelsebobWork> you can ofc fromList . scanl . toList
02:36:13 <quicksilver> as BeelsebobWork says it doesn't make much sense since maps aren't ordered.
02:36:21 <quicksilver> why not just use normalised probabilities?
02:36:30 <haskellian> quicksilver: well if I want to choose elemnts at random ?
02:36:34 <BeelsebobWork> if there's no order where's the "left" to scanLEFT on
02:36:48 <quicksilver> well suppose the numbers are (0.3,0.3,0.4)
02:36:55 <quicksilver> and you "roll" 0.7
02:36:59 <ejt> the keys are Ord though
02:37:12 <haskellian> i then choose what?
02:37:16 <BeelsebobWork> ejt: only an implementation detail
02:37:22 <BeelsebobWork> an unfortunate one at that
02:37:34 <quicksilver> you do this: 0.7 < 0.3 ? No. Ok, subtract 0.3 and move on. 0.4 < 0.3 ? No. Ok subtract 0.3 and move on. 0.1 < 0.4? Yes. Ok, pick the last element.
02:37:37 <quicksilver> easy.
02:37:43 <haskellian> 0.7 would result in the 0.4 to be chosen because it would 0.3,0.6,1
02:38:00 <quicksilver> which is the answer I just produced
02:38:06 <quicksilver> without wasting time computing cumulatives.
02:38:41 <haskellian> yes i see nice
02:39:18 <haskellian> i shouldnt stay up 24hours
02:39:18 <haskellian> i cant think
02:40:11 <quicksilver> I mean clearly you can fromList . scanl . toList but I think it's a waste of effort personally.
03:26:12 <haskellian> rollDice = getStdRandom (randomR (0,1)) , how do i get a value between 0 and 1 and not just 0 or 1 ?
03:26:39 <hodgekin> hi folks
03:27:36 <hodgekin> this came up here yesterday, but looking through the logs, i wasn't sure of the definitive answer: is it possible to get ghci to accept/print utf8 interactively?
03:28:20 <hodgekin> it deals with utf8 source files fine, but utf8 input and output get mangled.
03:29:58 <hodgekin> guess i'll have to try source-delving
03:31:01 <mmorrow> hodgekin: you can get utf8 output with eg utf8-string or utf8-light, which are both on hackage
03:31:43 <hodgekin> mmorrow: can i use those to get ghci to print out (e.g.) types correctly with utf-8?
03:31:45 <mmorrow> the input on the other hand.... i usually use ghci in xterm and i haven't had any luck (but i havent really gone to any effort)
03:32:14 <hodgekin> i'm wondering if may it respects some sort of locale setting.
03:32:16 <mmorrow> hodgekin: from what i understand this will be the case by default in 6.10
03:32:42 <mmorrow> but, as it is string IO doesn't do unicode
03:32:47 <hodgekin> oh, i do hope so. when's 6.10 due, then?
03:32:54 <mmorrow> september 10 :)
03:33:40 <mmorrow> you may be able to hack ghci in the meantime. if you do, i'd love to hear about it :)
03:34:36 <hodgekin> don't hold yer breath :-)
03:34:42 <mmorrow> (i'm not sure what the issue is though with input /into/ ghci, it may not be ghci at all and another something that's mangling my input)
03:34:57 <mmorrow> hodgekin: heh
03:35:15 <Axman6> @src foldr1
03:35:15 <lambdabot> foldr1 _ [x]    = x
03:35:15 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:35:15 <lambdabot> foldr1 _ []     = undefined
03:36:14 <hodgekin> mmorrow: well i'm using a term that definitely doesn't mangle utf8 input, and i still get the problem.
03:36:43 <mmorrow> yeah, me too (term doesn't mangle it and ghci does)
03:36:47 <mmorrow> sucky
03:36:55 <hodgekin> pity really, cos universal utf8 rocks
03:37:05 <mmorrow> definitely
03:37:42 <mmorrow> hodgekin: check out the new stuff in 6.10: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
03:37:43 <lambdabot> Title: Status/Releases - GHC - Trac
03:37:57 <hodgekin> ... and it's great being able to use the *proper symbols* in code ...
03:37:58 <mmorrow> err, september 19
03:37:59 <Axman6> @src foldl1
03:37:59 <lambdabot> foldl1 f (x:xs) = foldl f x xs
03:37:59 <lambdabot> foldl1 _ []     = undefined
03:38:11 <Axman6> @src foldl
03:38:11 <lambdabot> foldl f z []     = z
03:38:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:38:12 <besiria> what is Infinity? should a dividedbyzero exception be thrown when i do 3/0?
03:38:31 <Saizan_> > 1/0
03:38:32 <lambdabot>  Infinity
03:38:33 <mmorrow> hodgekin: ghc of course has no trouble with unicode in code
03:38:49 <besiria> it's a type constructor?
03:38:55 <Saizan_> besiria: Infinity is a value defined by the IEEE 754 standard
03:39:12 <Saizan_> well, it's the representation of that value in haskell
03:39:13 <hodgekin> ... which is why i find it strange that it has difficulty with interactive IO (which is after all just a file)
03:40:22 <Saizan_> uhm, i can use utf8 at ghci prompt
03:40:35 <besiria> Saizan_: ok, but can i use it like a normal value/constructor?
03:40:47 <Saizan_> Prelude> let è = 123
03:40:47 <Saizan_> Prelude> è
03:40:51 <Saizan_> 123
03:41:11 <Saizan_> identifier counts? :)
03:41:25 <besiria> Saizan_: i always get back no data constructor Infinity so that means i can't use it
03:41:56 <Saizan_> besiria: ah, no you can't use it as a data constructor, Double is an abstract type
03:42:05 <Saizan_> but
03:42:15 <Saizan_> > isInfinity (1/0)
03:42:16 <lambdabot>  mueval: Prelude.read: no parse
03:42:23 <Saizan_> ?type isInfinity
03:42:24 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
03:42:35 <Saizan_> ?hoolge isInfinity
03:42:36 <lambdabot> No results found
03:42:53 <Saizan_> i'm sure that exists somewhere..
03:43:04 <mornfall> ?hoogle CInt -> Int
03:43:04 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
03:43:04 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
03:43:04 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
03:43:12 <mornfall> Bah.
03:43:22 <mornfall> Any hints? : - )
03:43:38 <Saizan_> mornfall: fromIntegral
03:43:50 <mornfall> Ah!
03:43:51 <mornfall> Thanks.
03:44:00 <mmorrow> hodgekin: yeah, i think it's just the ghci IO code lagging behind ghc proper
03:44:03 <Saizan_> > isInfinite (1/0)
03:44:04 <lambdabot>  True
03:44:07 <besiria> Saizan_: i wonder how isInfinity is defined (when u can normall use Infinity)..
03:44:20 <besiria> isInfinite*
03:44:47 <Saizan_> besiria: it looks at the bits in the machine representation
03:44:54 <mmorrow> Saizan_: whoa. where are you using ghci from?
03:45:25 <besiria> Saizan_: is there a way to explicitly force a DidivedByZero exception? i think i saw this exception somewhere
03:45:25 <Saizan_> mmorrow: gnome-terminal, the errors mangle it though
03:45:39 <mmorrow> ah
03:46:06 <Saizan_> mmorrow: In the definition of `it': it = � == ()
03:46:25 <ejt> those record improvements in 6.10 are nice
03:46:29 <Saizan_> > 1 `div` 0
03:46:30 <lambdabot>  mueval: Prelude.read: no parse
03:46:31 <lambdabot> mueval: *** Exception: divide by zero
03:46:39 <mmorrow> it's weird, i'm using ghci in xterm and in bash i can paste unicode /in/ just fine. but in ghci it doesn't even show up as a printable char.
03:46:50 <Saizan_> besiria: div is for Integral types
03:47:31 <Saizan_> mmorrow: do you have an idea of where that Prelude.read: no parse si from?
03:47:53 <Deewiant> mmorrow: GHCi probably uses the standard System.IO/Prelude print functions which truncate Unicode
03:48:14 <mmorrow> i have no idea, but it's driving me nuts! :)
03:48:19 * mmorrow looks
03:48:26 <Saizan_> Deewiant: not true since here utf8 seems to work
03:48:46 <Deewiant> Saizan_: oh, interesting
03:49:11 <mmorrow> > let (∀) = 42 in (∀)
03:49:11 <lambdabot>  Illegal character ''\8704''
03:49:11 <lambdabot>  at "
03:49:17 <mmorrow> heh
03:49:21 <Saizan_> uhm
03:49:35 <Saizan_> ah, lambdabot still parses code with haskell-src!
03:49:59 <mmorrow> i know what that's from. it's using haskell-src-exts but they must have removed the dep on the version with your patch
03:50:35 <mmorrow> since i made that required in the patch i sent to gwern
03:51:15 <mmorrow> hint can't seem to handle the unicode though
03:51:22 <mmorrow> [m@ganon ~]$ mueval -e 'let (∀) = 42 in (∀)'
03:51:22 <mmorrow> [m@ganon ~]$
03:51:27 <Saizan_> mmorrow: patch for mueval or lb? lb still parses the expression before calling mueval :)
03:51:41 <Deewiant> Saizan_: just main = putStrLn "δ" doesn't work here though, even redirected to a file it gives ´
03:51:46 <mmorrow> oh, i'm talking for mueval.
03:52:18 <haskellian> sidestep: what is the difference between matlab and mathematica?
03:52:28 <Saizan_> mmorrow: that line works here
03:52:39 <gal_bolle> hi all
03:52:47 <Saizan_> Deewiant: we were talking about using utf8 in code, e.g. for variables
03:53:13 <gal_bolle> stupid question about haddock: is it possible to leave a blank line between the -- | comment and the definition itself?
03:53:16 <Deewiant> Saizan_: I'd expect it to use the same print function for either
03:53:28 <mmorrow> geez, so that expression is getting parsed twice then
03:53:35 <mmorrow> s/that/every/
03:54:14 <Saizan_> Deewiant: in fact it mangles the identifiers in type errors, but it parses them fine here, while mmorrow has problems
03:54:31 <Axman6> anyone know of an already defined function zipFoldWith :: (a -> b -> c) -> ( c -> c -> c) -> [a] -> [b] -> c?
03:54:53 <Deewiant> Saizan_: ah, right, parsing, I was thinking of output
03:55:37 <mmorrow> Deewiant: i'm aving problems getting any output at all from hint via mueval when there's any unicode in the expression being passed in. and since it outputs /nothing/, i've no idea what's going wrong
03:55:58 <mmorrow> yeeee!
03:56:00 <Saizan_> Axman6: why not use \f g xs ys -> foldr1 g $ zipWith f xs ys ?
03:56:03 <Deewiant> Axman6: flip ((.) . (.) . foldr1) . zipWith
03:56:54 <Axman6> because i wanted to see if i could actually define such a thing :)
03:57:34 <Saizan_> oh, sorry :)
03:58:30 <besiria> why's that i was taught at school that a `mod` 0 = a ? is this correct?
03:58:52 <Deewiant> > 1 `mod` 0
03:58:53 <lambdabot>  mueval: Prelude.read: no parse
03:58:53 <Axman6> > 10 `mod` 0
03:58:53 <lambdabot> mueval: *** Exception: divide by zero
03:58:54 <lambdabot>  mueval: Prelude.read: no parse
03:58:54 <lambdabot> mueval: *** Exception: divide by zero
03:59:00 <Axman6> oh noes!
03:59:07 <Axman6> > 10 `mod` 1
03:59:08 <lambdabot>  0
03:59:08 <besiria> :D
03:59:26 <Olathe> > 10 `mod` 10
03:59:28 <lambdabot>  0
04:00:04 <Deewiant> @check \a n -> a > 0 && n > a ==> a `mod` n == a
04:00:05 <lambdabot>  "Arguments exhausted after 93 tests."
04:00:29 <Olathe> @check \a -> a == 0 || a `mod` a == 0
04:00:30 <lambdabot>  "OK, passed 500 tests."
04:02:10 <Axman6> of course a `mod` 0 is undefined, since it's the remainder after dividing by zero...
04:02:51 <quicksilver> mmorrow / Deewiant : if I have it right, GHC 6.6 supports UTF8 in source files but you need 6.8 for utf8 in ghci.
04:03:09 <quicksilver> and even then, of course, 'show' will still do the 7-bit wrapping.
04:03:57 <Saizan_> 8, i hope :)
04:04:39 <conal> @seen dcoutts
04:04:39 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I don't know when dcoutts last spoke.
04:04:44 <quicksilver> Saizan_: 7, I think.
04:05:03 <quicksilver> Saizan_: I think show for String and Char always produces 7-bit clean output.
04:05:23 <quicksilver> > "\129\130"
04:05:24 <lambdabot>  "\129\130"
04:05:32 <mmorrow> quicksilver: it definitely does
04:05:45 <Saizan_> ah, show, right
04:06:19 <mmorrow> wow, i just used gnome-terminal for the first time in a while and i think i'm gonna give xterm a break...
04:06:22 <Saizan_> type errors just truncate at 8-bits though, no escaping
04:09:47 <besiria> is there a link to CHANGES of 6.10?
04:11:36 <mmorrow> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
04:11:39 <lambdabot> Title: Status/Releases - GHC - Trac
04:12:56 <besiria> mmorrow: thx.
04:17:52 <Saizan_> ?type () ()
04:17:53 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
04:18:06 <Saizan_> nice, they have lost my aptch :)
04:27:42 <quicksilver> Saizan_: what did your patch do?
04:33:44 <Saizan_> quicksilver: fix @type by avoiding "error "no type signature"" in the code that parses the message from ghci
04:34:33 <quicksilver> Saizan_: ah, nice.
04:35:06 <Saizan_> using error in parses to avoid the overhead and strictness of Maybe really seems to ask for problems, like in Plugin.Seen
04:36:07 <quicksilver> I've always like Either and Maybe precisely because they introduce strictness exactly when I want it :)
04:36:19 <quicksilver> suspicious of excessive laziness in parsers.
04:37:55 <Saizan_> yeah, for a lazy parser i'd like a stream of results anyhow, i don't want something that can explode anytime later
04:51:00 <ivanm> @type foldl'
04:51:01 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
04:51:03 <ivanm> ^^ wtf?
04:51:11 <smg> @type foldl
04:51:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:51:19 <smg> @type foldl'
04:51:20 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
04:51:35 <ivanm> doesn't lambdabot know about Data.List anymore or something?
04:51:36 <Saizan_> @type Data.List.foldl'
04:51:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:52:44 <Saizan_> ivanm: it looks like that
04:53:07 <ivanm> Cale: why have you lobotomized lambdabot?
04:53:25 * ivanm seems to recall getting the type of foldl' in lambdabot before... :s
05:02:59 <pastorn> @src elemIndex
05:02:59 <lambdabot> elemIndex x     = findIndex (x==)
05:03:12 <pastorn> @src findIndex
05:03:12 <lambdabot> findIndex p     = listToMaybe . findIndices p
05:03:12 <ivanm> @src findIndex
05:03:12 <lambdabot> findIndex p     = listToMaybe . findIndices p
05:03:34 <ivanm> @src findIndices
05:03:34 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
05:03:46 <pastorn> @src listToMaybe
05:03:46 <lambdabot> listToMaybe []        =  Nothing
05:03:46 <lambdabot> listToMaybe (a:_)     =  Just a
05:07:44 <GremlinHunter> range ((1, 1), (3, 3))
05:07:54 <GremlinHunter> Oops, wrong buffer :)
05:34:08 <hodgekin_> another quick question: i recently came across the following definition for a perfect binary tree: data Fork a = Fork a a; data Perfect a = Null a | Succ (Perfect (Fork a)); clever... but it isn't clear to me if it was possible to iterate across such a structure in standard haskell... is it?
05:34:56 <Botje> should be
05:35:19 <quicksilver> hodgekin_: why would it not be?
05:35:20 <hodgekin_> Botje: so what might such a function look like?
05:35:44 <quicksilver> f (Null a) = ... deal with leaves ...
05:35:53 <hodgekin_> it should be possible to run it on trees of differing depths
05:36:00 <quicksilver> f (Succ t) = f t
05:36:01 <quicksilver> perhaps.
05:36:54 <hodgekin_> quicksilver: problem is with f (Null a) is that you don't know what the type of a is. it might be Fork (Fork (Fork (Fork a))) for instance.
05:37:08 <quicksilver> yes.
05:37:28 <quicksilver> not necessarily a problem, though.
05:37:54 <hodgekin_> i'd like to see fmap defined for this data structure.
05:38:15 <quicksilver> it doesn't have the right kind for that.
05:38:21 <quicksilver> its parameter is "one level down"
05:38:25 <quicksilver> not the actual leave
05:38:28 <quicksilver> leaf, sorry.
05:39:06 <hodgekin_> ?
05:39:19 <quicksilver> "Perfect a" is not a tree of "a"s
05:39:23 <noteventime> Isn't Perfect just a linked list? O_o
05:39:41 <quicksilver> so it isn't a Functor instance in the sense you wanted.
05:40:00 <hodgekin_> hmm.
05:40:09 <quicksilver> there is no problem working with such types in haskell
05:40:15 <quicksilver> but of course they are a bit strange.
05:40:21 <quicksilver> The depth of the tree is encoded in the type
05:40:30 <quicksilver> so you don't have a general type of 'trees of any size'
05:40:43 <quicksilver> a particular concrete type represents trees of a particular *fixed* type.
05:40:46 <quicksilver> sorry.
05:40:49 <quicksilver> *fixed* size.
05:40:51 <quicksilver> ;)
05:40:55 <quicksilver> fingers not obeying brain.
05:40:59 <hodgekin_> quicksilver: so can you write a function that will operate on such a structure of any depth?
05:41:24 <quicksilver> the short answer is "yes" ;)
05:41:32 <quicksilver> but the long answer, is maybe not the function you wanted.
05:41:33 <noteventime> Wouldn't that require you to dotype level programming
05:41:48 <quicksilver> there certainly exist functions of type Perfect a -> b
05:42:24 <quicksilver> but such a function has no idea when to stop.
05:42:29 <hodgekin_> for instance a function that could map (Succ (Succ (Null (Fork (Fork 1 2) (Fork 3 4))))) to (Succ (Succ (Null (Fork (Fork "1" "2") (Fork "3" "4"))))) via show
05:42:32 <quicksilver> it can't tell where the "Real leaves" are.
05:42:45 <quicksilver> the show instance is no problem.
05:43:44 <hodgekin_> i realise that *deriving* Show isn't a problem.
05:44:24 <hodgekin_> is it possible (for instance) to write a function depth :: Perfect a -> Int
05:44:31 <quicksilver> No.
05:44:48 <hodgekin_> ah
05:45:18 <noteventime> quicksilver: Not even by using type type level Peano numbers?
05:45:26 <noteventime> Or whatever they're called
05:48:50 <hodgekin> my mind is bending
05:49:34 <Elly> try not to let it snap
05:51:22 <hodgekin> maybe i should stop getting distracted by following links from ghc up-coming release notes. that might help.
05:54:14 <hodgekin> catamorphisms, eek.
05:56:02 <mapreduce> hodgekin: A catamorphism is a function from n values to 1 value.
05:56:32 <mapreduce> Fold is a more friendly name, and reduce even friendlier.
05:56:35 <hodgekin> what, like foldl?
05:56:38 <mapreduce> Yes.
05:57:16 <mapreduce> n can be 1 or 0, of course, so you can even fold a Maybe.
05:57:58 <mapreduce> (I don't know Haskell's support for that, just the concept)
05:57:59 <EvilTerran> you could even theoretically fold a (), not that it'd be very interesting
05:58:11 <hodgekin> ok. that's easier than talking about F-algebras.
05:58:16 <EvilTerran> mapreduce, the catamorphism for Maybe is called "maybe"
05:58:18 <EvilTerran> ?src maybe
05:58:19 <lambdabot> maybe n _ Nothing  = n
05:58:19 <lambdabot> maybe _ f (Just x) = f x
05:58:35 <EvilTerran> ?src Either
05:58:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:58:38 <EvilTerran> ?src either
05:58:39 <lambdabot> either f _ (Left x)     =  f x
05:58:39 <lambdabot> either _ g (Right y)    =  g y
05:58:56 <EvilTerran> ...even - there's the one for Either, too
05:59:24 <mapreduce> hodgekin: I'm a simpleton, so by the time I understand something I can probably put it into easier words than I saw it in. :)
05:59:59 <porpoise> Does the if then else indentation enforced by emacses haskell-mode invalid?
06:00:08 <porpoise> I mean is, not does.
06:02:05 <hodgekin> i'm trying to make some sense of http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1095 pointed to by http://www.informatik.uni-bonn.de/~ralf/publications.html#J4
06:02:06 <lambdabot> Title: 1 Perfect Trees and Bit-reversal Permutations - CiteSeerX
06:02:26 <hodgekin> and i'm not finding it easy...
06:02:39 <im_alone> @google F-system
06:02:41 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
06:03:00 <im_alone> @google "F-system"
06:03:04 <lambdabot> http://www.last.fm/music/System+F
06:03:04 <lambdabot> Title: System F – Listen free at Last.fm
06:03:20 <im_alone> @google "F-system" calculus
06:03:23 <lambdabot> http://www.answers.com/topic/system-f
06:03:23 <lambdabot> Title: System F: Information from Answers.com
06:03:29 <sw17ch> what is an example of an undecidable instance?
06:04:46 <quicksilver> noteventime: I was being pedantically precise.
06:04:47 <im_alone> sw17ch, e.g. the halt of TM
06:05:03 <quicksilver> noteventime: it's not possible to have depth :: Perfect a -> Int with *exactly* that type.
06:05:15 <quicksilver> because with exactly that type, the function doesn't exist.
06:05:15 <noteventime> quicksilver: Ohh, sorry
06:05:18 <sw17ch> im_alone, can you expand just a little more?
06:05:28 <noteventime> quicksilver: I seem to be a little on the slow side today :)
06:05:33 <quicksilver> a polymorphic function like that can't tell if "a" is of the form "Fork b"
06:05:40 <quicksilver> because that would not be a parametric thing to do.
06:05:48 <Saizan_> porpoise: yes in do-blocks, you need to indent "then" and "else" more than "if"
06:05:56 <quicksilver> You can control all these using a second type parameter, or using classes, or both.
06:06:07 <im_alone> the halt of the Turing Machine is undecidable in the sense you won't know if the TM will terminate or not.
06:06:29 <hodgekin> quicksilver: what do you mean by "using a second type parameter"?
06:06:38 <Saizan_> porpoise: there's an improved indentation module, iirc, but i'm not sure where
06:06:55 <quicksilver> hodgekin: Perfect a b
06:07:02 <quicksilver> where 'b' is the "real leaf type"
06:07:19 <quicksilver> then it has some hope of knowing "where to stop"
06:07:34 <sw17ch> mmm
06:07:36 <sw17ch> ty
06:08:07 <hodgekin> quicksilver: presumably that would imply defining Perfect differently?
06:08:11 <porpoise> Saizan_: I know, but hitting tabs in Emacs haskell-mode, the damn editor says "sole indentation" and chooses the WRONG indentation
06:08:28 <quicksilver> hodgekin: yes.
06:08:53 <quicksilver> for example take Perfect (Fork Int)
06:09:04 <quicksilver> this is a tree of two elements, which are Ints
06:09:11 <quicksilver> but it is *also* a tree of one element, which is Fork Int
06:09:23 <quicksilver> a parametric function is not allowed to be able to tell the difference.
06:09:40 <quicksilver> (any function which works on 'trees of type a' will also work on 'trees of type Fork Int')
06:09:46 <hodgekin> quicksilver: i understand that (i think).
06:09:49 <porpoise> what editor do you guys use?
06:09:57 <quicksilver> emacs, of course.
06:09:58 <hodgekin> portpoise: acme
06:10:02 <jeffz> emacs.
06:10:10 <quicksilver> porpoise: use kuribas's better indentation mode
06:10:15 <quicksilver> your life will improve immeasurably
06:10:22 <quicksilver> @where kuribas-indentation
06:10:22 <lambdabot> I know nothing about kuribas-indentation.
06:10:26 <quicksilver> @botsmack
06:10:26 <lambdabot> :)
06:10:34 <quicksilver> what's the point in a bot which forgets things.
06:10:45 <porpoise> quicksilver: thanks. I was banging my head against the wall... I can't believe the default is so insanely bad
06:10:47 <quicksilver> porpoise: http://kuribas.hcoop.net/haskell-indentation.el
06:10:53 <ivanm> quicksilver: what's the point of a bot that keeps crashing?
06:11:09 <quicksilver> ivanm: to test car safety?
06:11:12 <hodgekin> qucksilver: so given the extra type parameter, you'd define a class with instances for Fork a and for the underlying type... or something like that?
06:11:13 <ivanm> quicksilver: how does one use that? replace the standard haskell-indentation.el with it?
06:11:17 <ivanm> quicksilver: lol
06:11:50 <lilac> hodgekin: http://hpaste.org/10005
06:12:38 <lilac> hmm, you'll need to remove the 'derving Show' to get that to work :)
06:13:32 <quicksilver> that's clever.
06:13:40 <quicksilver> it uses the given functor 'f' to anchor the base of the tree.
06:16:09 <Taejo> why is GHCi telling me "module main:Foo is not loaded" when I do ":m +Foo"
06:16:09 <Taejo> ?
06:16:27 <quicksilver> because the module Foo is not loaded?
06:16:44 <quicksilver> :m is not an instruction to load. It's an instruction to alter the local scope to bring a module into scope.
06:17:11 <porpoise> quicksilver: thanks, this is so much better
06:17:37 <Taejo> ah, stupid me, I was in the source directory of the library I was trying to import
06:17:39 <hodgekin> lilac: thanks. i'm a bit slow, sorry: how do you create a literal instance of Fork given your definition?
06:18:30 <quicksilver> hodgekin: you can use a dummy functor
06:18:34 <quicksilver> like data Id a = Id a
06:18:49 <quicksilver> instance Functor Id where fmap f (Id x) = Id (f x)
06:19:05 <hodgekin> ok.
06:19:07 <quicksilver> then Fork (Id 1) (Id 2)
06:19:09 <quicksilver> is a simple example.
06:19:37 <quicksilver> effectively you're using the special token 'Id' to mark the leaves.
06:19:47 <quicksilver> Except it's cleverer than that, because lilac wrote it using polymorphism
06:20:02 <quicksilver> so it's using parametric polymorphism in 'f' to mark the leaves, in some sense.
06:20:10 <RayNbow> > succ >>> succ $ 2
06:20:11 <lambdabot>  mueval: Prelude.read: no parse
06:20:23 <RayNbow> hmm, lambdabot doesn't like arrow composition?
06:20:46 <quicksilver> lambdabot has been upgraded :)
06:20:53 <quicksilver> but the module list hasn't caught up with how it used to be.
06:21:21 <dcoutts> conal: pong
06:21:21 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
06:21:50 <lilac> hodgekin: http://hpaste.org/10005#a1
06:22:24 <conal> dcoutts: hi.  i'm waiting to hear back on a c.h.o project ("unamb").  wondering if it fell through the cracks.
06:22:54 <dcoutts> conal: oh right
06:23:27 <RayNbow> hmm... which one is more readable...
06:23:28 <RayNbow> sed = curry $ uncurry (liftT2 (-)) >>> liftT (join (*)) >>> uncurry (+)  -- this one?
06:23:33 <RayNbow> sed (a,b) (c,d) = (a-c)^2 + (b-d)^2  -- or this one? :p
06:24:08 <dolio> First one. Totally. :)
06:24:12 <hodgekin> lilac: i shall continue pondering that! thanks.
06:24:21 <quicksilver> hodgekin: I was totally wrong about one thing.
06:24:28 <quicksilver> hodgekin: you can calculate the depth, even with your initial definition.
06:24:42 <quicksilver> depth (Null _) = 0; depth (Succ p) = 1 + depth p
06:24:49 <quicksilver> hodgekin: not sure what I was thinking there ;)
06:25:13 <quicksilver> hodgekin: but the point is that you can't make it an instance of Functor is a useful way without doing something like lilac's trick.
06:25:34 <hodgekin> ok
06:26:00 <quicksilver> quicksilver-- # wrong.
06:26:09 <dcoutts> conal: done
06:26:17 <conal> dcoutts: thx! :)
06:50:47 <hodgekin> lilac: interesting to observe that you had to use a GHC extension to implement Show (f a).... or is there another way?
06:51:51 <RayNbow> dolio, interested in a pointfree Manhattan distance function? :)
06:52:31 <quicksilver> hodgekin: which GHC extension?
06:52:32 <EvilTerran> RayNbow, you can use (^2) instead of join(*), incidentally
06:53:10 <RayNbow> EvilTerran: I know
06:53:18 <hodgekin> quicksilver: if i run vanilla ghc, i get Non type-variable argument in the constraint: Show (f a) (Use -fglasgow-exts to permit this)
06:53:21 <RayNbow> does it matter in performance btw?
06:53:29 <EvilTerran> not significantly
06:53:44 <EvilTerran> join (*) would be a little faster - (^) is recursive, so won't be inlined fully
06:53:45 <RayNbow> then I prefer the more obscure join version ;)
06:53:54 <EvilTerran> (unless you're using supero, which i doubt)
06:54:05 <quicksilver> hodgekin: interesting. I didn't know that wasn't standard haskell.
06:54:20 <quicksilver> hodgekin: haskell98 has some rather conservative restrictions on instance forms.
06:54:37 <RayNbow> I fear the code I'm working on will be actually run on an interpreter (Hugs)
06:54:40 <EvilTerran> quicksilver, yeah, in h98, a class constraint has to be of the form "ClassName typeVariable", i believe
06:54:58 <EvilTerran> RayNbow, why's that?
06:54:59 <RayNbow> unless the person I'll be sending this code has GHC installed :p
06:55:17 <EvilTerran> you could send them a binary, surely?
06:55:25 <RayNbow> EvilTerran: well, I'm just working on a simple puzzle of a university's magazine
06:55:28 <hodgekin> is there a catalog of "standard haskell extensions that everybody uses" somewhere?
06:55:31 <RayNbow> heh... binary? :p
06:55:40 <RayNbow> last time I tried that, the mail server ate my attachment :p
06:55:45 <EvilTerran> ah.
06:56:38 <hodgekin> as opposed to "experimental extensions that only three people ever understood and are only implemented in one compiler"
06:57:00 <hodgekin> as a newbie to haskell, it's difficult to know what subset of the language i should try to write in.
06:57:24 <hodgekin> (that should probably be "superset")
06:57:47 <quicksilver> hodgekin: 95% of all haskell work is done in only one compiler. Probably more.
06:57:49 <quicksilver> which is a shame.
06:58:00 <quicksilver> I think -XFlexibleInstances is pretty non-controversial.
06:58:06 <quicksilver> and I assume that's what is needed here.
06:58:11 <EvilTerran> hodgekin, anything covered by -fglasgow-exts is probably safe
06:59:27 <RayNbow> a beginner rarely (if ever) has to use an extension flag, right?
06:59:49 <hodgekin> i guess it'd be nice if my code could run in more than one compiler. just like i don't use GCC-specific stuff when writing C. but i get the feeling that haskell is less diverse.
07:00:07 <Wild_Cat> RayNbow: right.
07:00:22 <Wild_Cat> hodgekin: well, GHC is pretty much the only "real" Haskell compiler.
07:00:40 <hodgekin> RayNbow: that's what i'd have assumed, but the need for stuff like flexible instances seems to arise fairly quickly.
07:01:18 <hodgekin> Wild_Cat: all the world's a VAX, right?
07:01:33 <quicksilver> hodgekin: well polymorphically recursive types are fairly exotic :)
07:01:36 <quicksilver> not many people use them.
07:02:43 <Wild_Cat> hodgekin: more like "there are no commercial implementations of Haskell '98, and the community isn't that big to it's focusing on building a single industrial-strength one."
07:03:13 <BeelsebobWork> Wild_Cat: I think that's a bit of a falalcy
07:03:22 <BeelsebobWork> there's plenty of people working on e.g. yhc, and jhc
07:03:37 <dolio> Most of "the community" doesn't work on ghc, either.
07:04:14 <RayNbow> hodgekin, VAX? http://farm1.static.flickr.com/2/1934782_4e7c895c74.jpg?v=0
07:04:41 <im_alone> @google commercial haskell
07:04:44 <lambdabot> http://www.loopnet.com/Arkansas/Haskell-Commercial-Real-Estate/
07:04:44 <lambdabot> Title: Haskell Commercial Real Estate for Sale and Lease on LoopNet.com
07:10:59 <sw17ch> out of GHC/YHC/JHC, are any capable of running without an operating system?
07:11:12 <sw17ch> directly on the wires? :)
07:11:33 <sw17ch> and i guess i should note that i'm hoping to do it on an ARM9
07:11:43 <im_alone> sw17ch wrong way, you need an OS to do hardware abstraction
07:11:44 <BeelsebobWork> none of them will compile to ARM
07:11:52 <quicksilver> none of them do that out of the box, no.
07:11:55 <ejt> embedded Haskell
07:11:58 <quicksilver> but it's not particularly hard in principle.
07:12:02 <BeelsebobWork> im_alone: what if you want to write a Haskell OS
07:12:06 <ejt> that's a niche area!
07:12:08 <quicksilver> they don't require much form the OS beyond memory management.
07:12:12 <RayNbow> @google House Haskell OS
07:12:16 <lambdabot> http://programatica.cs.pdx.edu/House/
07:12:16 <lambdabot> Title: House
07:13:12 <sw17ch> ejt: i'd love to be able to ditch some of my C code for Haskell in my embedded work..
07:13:28 <sw17ch> quicksilver, my main problem is the sheer size of the programs and the memory requirements
07:14:22 <quicksilver> there have certainly been attempts to compile GHC for ARM
07:14:25 <sw17ch> im_alone, actually, i don't want an OS doing hardware abstraction
07:14:25 <quicksilver> I don't know how successful.
07:14:50 <hodgekin> RayNbow: http://www.museumwaalsdorp.nl/computer/images/11750cpu.jpg
07:14:53 <sw17ch> quicksilver, i thought i saw somethign for it somewhere
07:15:06 <sw17ch> i do have the option of using PPC chips once in a while :)
07:15:13 <sw17ch> but that's only when i have a large buget and a willing customer...
07:15:55 <sw17ch> usually the CPU needs to cost less than a dollar...
07:15:57 <im_alone> sw17ch, an OS that doesn't separate kernel space and user space is a crap as MSDOS or CP/M
07:16:12 <sw17ch> im_alone, i don't think you understand waht i do
07:16:26 <sw17ch> im_alone, i'm an embedded developer. I have 16K of memory total. I don't have room for an OS
07:16:35 <sw17ch> :)
07:16:42 <BeelsebobWork> sw17ch: use Hume then?
07:16:49 <im_alone> sw17ch, for you, use C, Pascal or Modula-2
07:16:57 <im_alone> or Assembler.
07:17:09 <BeelsebobWork> im_alone: why wouldn't he be able to use a nice functional language?
07:17:09 <sw17ch> im_alone, i know... :) i would *rather* use something else
07:17:15 <hodgekin> sw17ch: i'd say you definitely don't have room for haskell then...
07:17:18 <im_alone> Haskell consumes tons of memory
07:17:18 <BeelsebobWork> like... Hume
07:17:39 <RayNbow> @google hume functional language
07:17:42 <lambdabot> http://www-fp.cs.st-andrews.ac.uk/hume/index.shtml
07:17:43 <lambdabot> Title: The Hume Programming Language
07:17:51 <im_alone> for small devices, the imperative languages beat functional languages
07:18:02 <BeelsebobWork> im_alone: that's not what the Hume team say
07:18:13 <sw17ch> im_alone, i write my C in a functional manner...
07:18:26 <sw17ch> i just need to make sure GCC is doing the tail calls correctly...
07:18:44 <sw17ch> i'm actually pretty sure that Haskell could do it
07:18:52 <quicksilver> im_alone: that's a false generalisation.
07:19:00 <quicksilver> im_alone: GHC is not optimised for memory usage.
07:19:07 <im_alone> no, it's the true history
07:19:23 <quicksilver> im_alone: you cannot from that infer 'for small devices imperative languages beat functional'
07:19:49 <hodgekin> if you've only got 16K RAM you don't really want to be doing much dynamic memory allocation.
07:19:53 <im_alone> return back to 1970, what is the normal language used here?
07:20:04 <quicksilver> there is no inherent memory management difference between functional and imperative.
07:20:08 <sw17ch> hodgekin, another issue i deal with. :)
07:20:12 <RayNbow> I wasn't alive in 1970 :p
07:20:12 <quicksilver> These are implementation issues, not language issues.
07:20:50 <sw17ch> quicksilver, since you seem to buy into my idea... how hard would it be to make a haskell standard which would be able to target a smaller environment?
07:20:59 <sw17ch> that's a bad question
07:21:14 <quicksilver> I don't think you'd need to change the language standard for that
07:21:29 <quicksilver> just the compiler + careful choice of libraries to include.
07:21:32 <sw17ch> How hard would it be to add analysis tools to GHC which check upper and lower boudns for memory usage?
07:21:43 <sw17ch> quicksilver, i'm also thinking a Prelude replacement
07:22:01 <quicksilver> I'm not sure that would be necessary. I don't think the Prelude is inherently memory hungry.
07:22:09 <quicksilver> although you might cut down your basic types to those native to the hardware
07:22:10 <sw17ch> waht about executable size?
07:22:18 <quicksilver> executable size is a GHC issue
07:22:21 <quicksilver> not a language one :)
07:22:39 <Wild_Cat> executable size is rarely an issue, unless you're targeting stuff for which you should use ASM anyway.
07:22:47 <quicksilver> if you run the appropriate strip objects magic you can get GHC executables down to the sub 100K range.
07:23:10 <sw17ch> Actually, I'm not familiar with how GHC links. I know it's static, but does it have the ability to leave out pieces of the objects it's linking against?
07:23:22 <hodgekin> i have to say i've found it difficult to get a reasonable idea of how much memory my haskell programs might use.
07:23:49 <sw17ch> hodgekin, it seems that one could write a tool to check some of that
07:23:50 <quicksilver> sw17ch: that's the strip objects magic I'm referring to.
07:23:56 <quicksilver> it's hazy to me because I've never used it.
07:24:02 <sw17ch> quicksilver, i'll have to look into it :)
07:24:07 <quicksilver> but GHC links everything in; however it's a reasonable simple hack to stop it doing so.
07:24:10 <hodgekin> all the usual strict language intuitions don't apply
07:24:52 <im_alone> 40 years ago, many small devices with GC were Lisp Machines
07:25:16 <im_alone> and now? why not Lisp Machines?
07:25:35 <sw17ch> im_alone, no one knows lisp any more?
07:26:03 <sw17ch> (it's sad, but find me a full time embedded developer who knows lisp/scheme well enough to be profficient)
07:26:40 <jeffz> sw17ch: how many modern lisps run on vxworks or lynxos?
07:26:52 <sw17ch> jeffz, probably none :) i'm not sure
07:27:55 <jeffz> sw17ch: I'd bet none too and probably that a large amount of embedded work is maintenance or building on existing codebases
07:28:00 <im_alone> @google bytecode lisp
07:28:02 <lambdabot> No Result Found.
07:28:06 <im_alone> @google bytecodes lisp
07:28:09 <lambdabot> http://en.wikipedia.org/wiki/Bytecode
07:28:09 <lambdabot> Title: Bytecode - Wikipedia, the free encyclopedia
07:28:32 <Associat0r> you should look at http://bitc-lang.org/
07:28:35 <lambdabot> Title: The BitC Programming Language
07:28:41 <sw17ch> Has any one used Gumstix hardware?
07:28:56 <im_alone> lisp was a language non-purely functional programming
07:29:28 <quicksilver> I doubt many people in this channel need to have that explained :)
07:29:30 <im_alone> it was often to use setq and setf
07:30:02 <sw17ch> Hume looks cool
07:30:25 <sw17ch> Any way, Gumstix hardware isn't exactly "embedded" since it gives you gobs of memory and plenty of disk space... oh, and linux
07:30:38 <sw17ch> but it's an arm9 cpu... it'd be fun to run haskell on it
07:30:42 <sw17ch> err... haskell apps
07:31:43 <im_alone> with 16 KiB of RAM, arm7 is more ok than arm9
07:34:43 <sw17ch> im_alone, in my case, it's m68k, but i prefer the ARM chips
07:34:58 <sw17ch> (though, m68k isn't all that bad either :) )
07:35:47 <sw17ch> actually, doesn't JHC just spit out raw C?
07:36:13 <sw17ch> is there anything scary there that prevents me from using a cross compiler?
07:36:24 <Taejo> how do I build a profiling version of a cabalised lib?
07:36:42 <ejt> configure -p
07:37:03 <Taejo> thanks
07:47:03 * shapr sighs
07:47:40 * sw17ch wonders why shapr sighed
07:48:06 <matthew-_> right, so let's have a poll on the music people listen to when writing papers.
07:48:29 * sw17ch doesn't write papers :(
07:48:37 <matthew-_> and in particular, do people switch to "paper writing music" from their usual staples?
07:49:04 * sw17ch qualifies previous statement with "yet"
07:49:20 <matthew-_> sw17ch: you have *so* much to look forward to
07:49:34 <sw17ch> matthew-_, it depends on me going back to school at some point...
07:49:44 <sw17ch> or being handed a research budget
07:50:33 <sw17ch> NIN's Ghosts I-IV is some of the best programming/design music i have... but i'm not sure how well it woul work for paper writing
07:51:49 <quicksilver> sw17ch: GHC doesn't have a cross compilation mode.
07:52:20 <sw17ch> quicksilver, i was thinking the generated C source from JHC.
07:53:42 <quicksilver> sw17ch: Don't know about JHC.
07:53:59 <sw17ch> quicksilver, alright, i'll have to look into it :)
08:01:37 * EvilTerran tends to program to kohina.com
08:02:11 <EvilTerran> it's designed to be background music, so it works well :)
08:02:23 * Wild_Cat used to code to scenemusic.net , but hasn't checked it out in a while.
08:03:39 <Bleadof> Last.fm \o/
08:03:44 <EvilTerran> Wild_Cat, well, for starters, it seems to've moved to necarine.fr
08:03:53 <EvilTerran> *nectarine.fr
08:03:59 * Wild_Cat updates his bookmark
08:09:25 <k-zed> hulloh
08:09:34 <k-zed> i have a small program that refers to Data.ByteString.Lazy.Char8
08:09:42 <k-zed> i compile it by ghc -O somefile.hs
08:09:49 <k-zed> and i get a bunch of linking errors
08:09:53 <k-zed> sumfile.o: In function `s1sE_info':
08:09:53 <k-zed> (.text+0x391): undefined reference to `bytestringzm0zi9zi0zi1_DataziByteStringziLazzyziInternal_Empty_closure'
08:09:56 <k-zed> etc.
08:10:11 <Lemmih> k-zed: Try with --make.
08:10:35 <k-zed> that worked.
08:10:36 <_zenon_> EvilTerran, thanks for the link.
08:10:46 <k-zed> Lemmih: thanks.
08:11:09 <EvilTerran> :)
08:19:15 <sw17ch> i seem to remember that using "--make" was a "wrong way"
08:19:22 <sw17ch> and that for some reason the -via-c options were better... or something
08:19:32 <sw17ch> does some one know how to fill in the "or something"?
08:21:42 <jeffz> sw17ch: -fvia-c is supposed to be deprecated soon or something
08:22:14 <sw17ch> jeffz, hurrah for recursion :)
08:22:22 <quicksilver> sw17ch: --make is the "right way"
08:22:23 <jeffz> I just realised :)
08:22:39 <sw17ch> quicksilver, alright, i remember dons complaining about somethign related recently
08:22:44 <sw17ch> related to --make
08:22:51 <quicksilver> sw17ch: via-c may succeed in generating better floating point code
08:23:02 <quicksilver> (because it uses GCC's floating point code generator)
08:23:07 <quicksilver> other than that I don't think it's better.
08:23:37 <sw17ch> quicksilver, alright, i wasn't sure how much better GCC's code generator was than GHC's
08:24:01 <Saizan_> however -fvia-c and --make are orthogonal, no?
08:24:06 <quicksilver> well the thing is, they're rather different.
08:24:22 <quicksilver> Saizan_: unless there is a an obscure interaction via the FFI and header files?
08:24:45 <quicksilver> sw17ch: GCC's code generator is really rather good at generating code from C.
08:24:54 <quicksilver> sw17ch: but haskell has a very different model
08:25:01 <quicksilver> so many of GCC's advantages don't apply.
08:25:14 <quicksilver> ...whilst GHC has lots of smarts which apply to the haskell model.
08:25:34 <sw17ch> quicksilver, i've been reading the stuff about the upcoming code generator and C--... it all looks very cool...
08:25:42 <sw17ch> :)
08:40:20 <lispy> What are the pros and cons of using *Check vs. Hunit to add per-module unit tests?  (note, some module contain IO monads that should be tested)
08:40:37 <lispy> Which is "better" as a way to add unit tests?
08:44:49 <dmead> mccain picked a milf for vp
08:45:15 <sw17ch> that was necessary...
08:45:35 <lispy> dmead: er, that's #haskell-blah topic not #haskell :)
09:03:50 <guenni> how can I encode a huge lazily generated list also lazily, because simply trying to binary encode blows up?
09:05:12 <lilac> guenni: what type of encoding?
09:05:35 <guenni> from the binary package, encode
09:05:37 <ankh47> hi all, i tried to "cabal install" a package, which failed saying that package Win32 is hidden. so i "ghc-pkg expose"d the Win32 package and retried, with the same result (ie. package Win32 is hidden). any ideas what shoul i try next ?
09:06:30 <dcoutts_> ankh47: It's because the package fails to specify its dependency. Add build-depends: Win32 to the .cabal file for the package you're building.
09:06:41 <ddarius> guenni: You need to make an encoding that is lazy.
09:07:06 <saya> use foldl stuff like that?
09:07:14 <guenni> ddarius: so I guessed but I'm not sure how
09:07:43 <guenni> actually I need to get more aquainted with how to write lazy algos
09:08:15 <quicksilver> guenni: I would say, don't use the binary package.
09:08:25 <quicksilver> that's designed to serialise into a big strict chunk.
09:08:32 <quicksilver> write a streaming serialiser
09:08:37 <quicksilver> (which can use binary internally, of course)
09:09:05 <EvilTerran> note that that won't work for, eg, serializing infinite lists to disc
09:09:36 * quicksilver orders an infinite disc.
09:10:04 <EvilTerran> to do that, you'd need to represent the infinite list in a way that's finite when forced
09:10:18 <EvilTerran> unfortunately you can't serialize unevaluated thunks
09:10:22 <guenni> quicksilver: ic, looks like I'll have to study that subject some more
09:10:30 <ankh47> 2 dcouts: and it builds, yay ;-))) it seemed odd that win32 was nowhere to be seen int the .cabal file, but is i've never made mysel a package yet ... thx
09:10:33 <quicksilver> win 27
09:10:51 <guenni> quicksilver: do you know of any references that deal with this subject?
09:11:03 <ddarius> guenni: The problem is the format of the encoded list, not laziness.
09:11:29 <guenni> ddarius: can you be more specific?
09:11:30 <ddarius> binary encodes a list as its length followed by its elements.  It can't start writing the list until it has found the length.
09:11:52 <quicksilver> that's also true.
09:11:55 <guenni> ddarius: and is thus strict
09:11:56 <quicksilver> good point :)
09:12:26 <ddarius> So simply make a wrapper around [] (there may already be one somewhere handy), and then serialize things out in chunks or some format that only needs finite lookahead into the list.
09:15:23 <guenni> ddarius: I'm still lost, do you have an example?
09:15:57 <lilac> guenni: it being strict isn't a problem; it being spine-strict is the problem. </pedantic>
09:17:08 <guenni> lilac: thx, appreciated, but I'd need to read up more on this issue
09:17:50 <ddarius> guenni: Write out a byte specifying the length.  Have 0xFF represent "there's more remaining" and anything less represent "there are x items remaining."  After each byte write out as many elements as the byte specifies.  Keep doing this until you reach the end of the list.
09:18:12 <ddarius> To read, read a byte, read that many elements, if the byte was 0xFF, repeat.
09:20:22 <dons> http://www.reddit.com/r/programming/comments/6ynx3/scannerparsers_i_lifting_functions/
09:20:25 <lambdabot> Title: Scanner-parsers I: lifting functions : programming, http://tinyurl.com/5ah9v6
09:24:04 <guenni> ok, let's I manage that, could I also then compress it with the GZip "compress" out of the box?
09:26:30 <dons> there's a gzip binding on hackage
09:26:37 <ddarius> dons: Is the compress function streaming?
09:29:15 <dcoutts_> ddarius: yes
09:30:32 <dcoutts_> ddarius: the lazy bs chunk boundaries are exactly those fed in to zlib, the output is however chunked on 64k iirc. I could make that configurable if necessary.
09:31:30 <dcoutts_> or maybe I'm mis-remembering and we flush a chunk from our 64k buffer whenever zlib gives us some output
09:33:12 <dcoutts_> but it is overall lazy, assuming you do not care too much about the exact amount of buffering
09:33:31 <dcoutts_> so we can write nice compositional code, like shell script:
09:33:35 <dcoutts_> writeFile "foo-1.0.tar.gz" . gzip =<< tar "foo-1.0/"
09:33:46 <dcoutts_> almost as concise as:
09:33:47 <dcoutts_> tar -c foo-1.0/ | gzip > foo.tar.gz
09:34:15 <quicksilver> tar "foo-1.0/" >>= gzip >>> writeFile "foo-1.0.tar.gz"
09:34:26 <ddarius> >=>
09:34:36 <quicksilver> <=<
09:34:45 * dcoutts_ prefers the functional/applicative order
09:35:07 <quicksilver> so do I, actually.
09:35:11 <quicksilver> but it made the analogy stronger :)
09:35:16 <dcoutts_> aye :-)
09:35:26 <dcoutts_> and even better, the performance is almost identical
09:35:34 <dcoutts_> and strongly typed
09:37:46 <MyCatVerbs> dcoutts_: "almost as nice"? I think of it as almost as nice, except that I can do other entirely different things too like throwing all the lines into a Data.Map or whatever and it's no less pleasant to do so than to do anything else. :)
09:38:10 <dcoutts_> MyCatVerbs: right
09:44:23 <BONUS> @src length
09:44:23 <lambdabot> Source not found. There are some things that I just don't know.
09:44:36 <BONUS> what the heck
09:44:45 <Myoma> length /= foldr (const (+1)) 0
09:44:46 <Myoma> aoe
09:46:55 <BONUS> yeah but still its strange how it doesnt have that
09:47:57 <Myoma> :t succ
09:47:58 <lambdabot> forall a. (Enum a) => a -> a
09:48:15 <Myoma> > succ (0 :: CReal)
09:48:17 <lambdabot>  mueval: Prelude.read: no parse
09:48:17 <lambdabot> mueval: *** Exception: Cannot fromEnum CReal
09:48:23 <Myoma> this isn't good
09:51:06 * bos regrets using darcs every day. sigh.
09:51:18 <RayNbow> bos: why's that?
09:51:49 <bos> RayNbow: the way that you deal with conflicting patches is bizarre  and hard to remember.
09:51:50 * RayNbow has zero experience with darcs (well, I used it once for downloading the source of some project)
09:52:42 <bos> some people seem to like its working model. i find it to be utterly infuriating.
10:01:04 <Myoma> in ghc/compiler, which files depend on which others?
10:01:26 <Myoma> is there any way to get a print out of what order things depend on each other
10:01:34 <sw17ch> in the type system, is there a way to create somethign that applys a type N times?
10:01:58 <Myoma> if 'N' is a type level natural I think you can do that with a typeclass sw17ch
10:02:16 <sw17ch> Myoma, hmmm...
10:02:20 <sw17ch> what i'm looking for is
10:02:32 <sw17ch> data T = T a
10:02:39 <sw17ch> sorry
10:02:44 <Myoma> @src Maybe
10:02:44 <sw17ch> data T = T a | B
10:02:44 <lambdabot> data Maybe a = Nothing | Just a
10:03:11 <sw17ch> applyTs 5 B = T(T(T(T(T b))))
10:03:22 <Myoma> T is a function there
10:03:32 <sw17ch> oh, woops...
10:03:40 <sw17ch> do you understand waht i'm getting at though?
10:03:43 <Myoma> yes
10:03:45 <RayNbow> sw17ch: you want the type of the result depend on the first argument?
10:03:46 <Myoma> I'd start with a fold,
10:03:53 <Myoma> fold'n zero succ 0 = zero
10:03:58 <sw17ch> oh, it's this...
10:04:02 <Myoma> fold'n zero succ (x+1) = succ (fold'n zero succ x)
10:04:04 <Myoma> then you can write
10:04:05 <rwbarton> there's nothing special about the type of the result there, it's always T
10:04:05 <sw17ch> data T a = T | B
10:04:10 <sw17ch> no, still wrong
10:04:16 <Myoma> applyNTime f o = fold'n o f
10:04:23 <sw17ch> data T a
10:04:25 <sw17ch> data B
10:04:32 <Myoma> applyNTime T b 5 = T(T(T(T(T b))))
10:05:17 <rwbarton> sw17ch: what you can do is create a typeclass Peano that all T(T(...(T(B))...)) belong to and a function Int -> (forall a. Peano a => b) -> b
10:05:18 <sw17ch> I'm looking at Type-Level Instant Insanity by Conrad Parker
10:05:48 <Myoma> sw17ch: See what I wrote just now ?
10:06:02 <Myoma> sw17ch: You can just do that in the type system, instead of the fold use a class
10:06:09 <quicksilver> sw17ch: one question to ask, in these cases, is
10:06:11 <sw17ch> Myoma, hmm...
10:06:16 <quicksilver> "what would the type of applyTs" be.
10:06:20 <quicksilver> ?
10:06:26 <quicksilver> that is often an elightening question.
10:06:40 <sw17ch> quicksilver, :) that's a very hard question
10:06:50 <sw17ch> in this case, i'd guess that it would be (T a)
10:06:51 <quicksilver> yes. But if the type of the expression depends on one of the arguments
10:06:58 <Myoma> sw17ch: start by writing tde typeclass ...
10:07:02 <quicksilver> then you realise that you aren't in simple H-M land any more.
10:07:10 <quicksilver> of course some dependent types can be done in haskell.
10:07:16 <quicksilver> but you will need to (ab)use classes for that.
10:08:11 <sw17ch> type ThreeTs = T (T (T a))
10:08:18 <Myoma> data Z
10:08:22 <Myoma> data S n
10:08:45 <Myoma> FoldN zero succ n u => n -> u
10:09:51 <sw17ch> hmm... i'm starting to see it now
10:11:13 * Myoma wishes for a dependency graph
10:11:46 <dons> what  kidn of dependencies, Myoma ?
10:12:16 * lilac grants wish with GNU make
10:13:06 <Myoma> there's lots of things inside ghc/compiler and I don't know what order to look at them in
10:13:47 <lilac> hmm, a data dependency graph for a program would be really cool
10:14:22 <_zenon_> lilac, well, since haskell kind of works like that, it should be easily accomplished
10:14:38 <_zenon_> lilac, you mean with includes and such?
10:15:18 <MarcWeber> 	(<*>) f g x = f x (g x)
10:15:27 <MarcWeber> 	(<*>) f g x = f x (g x)
10:15:52 <MarcWeber> How to read this? I mena <*> has only two parameters ?
10:16:12 <Zao> MarcWeber: It has three.
10:16:26 <MyCatVerbs> MarcWeber: <*> is a two-parameter operator which returns a function of one argument.
10:16:27 <Zao> The usual usage is to apply it to two and apply the resulting one-arg function to the last one.
10:16:49 <lilac> _zenon_: have you seen doxygen graphs of inheritance heirarchies? something like that, only showing the functions which produce / consume data rather than inheritance
10:17:04 <MyCatVerbs> MarcWeber: it ties in with Schönfinkelisation, which you might occasionally hear called currying. :)
10:17:30 <MyCatVerbs> MarcWeber: it could also be written as f <*> g = \x -> f x (g x) -- if that makes life easier.
10:17:32 <MarcWeber> I've neither heard nor seen this word before..
10:18:03 <MarcWeber> Zao, MyCatVerbs Thanks, I got it now
10:18:11 <MyCatVerbs> MarcWeber: well. In Haskell, there's no distinction between a one-argument function that returns another one-argument function, and a two-argument function.
10:18:43 <Zao> f x y parenthesizes as (f x) y
10:19:03 <lilac> > (f <*> g) x :: Expr
10:19:05 <lambdabot>  Add a type signature
10:19:09 <MyCatVerbs> MarcWeber: f x y = doSomethingWith x y, is the same as f x = \y -> doSomethingWith x y, is the same as f = \x -> \y -> doSomethingWith x y
10:20:23 <saya> How do you impose a type on a closure or let statement? like (\x -> x+x) :: Int -> Int ?
10:20:39 <lilac> MyCatVerbs: ... except for where clauses :)
10:21:04 <MarcWeber> let a = 7
10:21:09 <MarcWeber>    a :: Int ?
10:21:20 <Deewiant> let a = 7 :: Int ?
10:21:43 <mmorrow> saya: any number of ways (\x->x+x::Int),  (\x -> ... (x::Int) ... )
10:22:02 <mmorrow> > randomRs (0,0) (mkStdGen 0)
10:22:05 <lilac> > ((\x -> x + x) :: Int -> Int) 42 -- saya: your way works too
10:22:08 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:22:08 <lambdabot> Terminated
10:22:16 <mmorrow> > randomRs (0,4) (mkStdGen 0)
10:22:17 <lambdabot>  [0,0,0,0,2,4,3,3,3,3,0,2,4,2,1,2,2,3,2,4,4,3,2,2,3,1,2,1,3,2,4,4,0,1,2,2,2,0...
10:22:22 <mmorrow> > randomRs (0,4::Double) (mkStdGen 0)
10:22:24 <lambdabot>  [3.949108141928238,3.98152275103647e-3,3.8950803787203228,0.5211217521040519...
10:22:32 <mmorrow> > randomRs (0,4::Rational) (mkStdGen 0)
10:22:34 <lambdabot>      No instance for (Random Rational)
10:22:34 <lambdabot>       arising from a use of `randomRs'...
10:23:12 <MyCatVerbs> lilac: example? I can't think offhand where (no pun) that's an issue.
10:23:15 <mmorrow> > (\x -> take 4 . randomRs (0,x::Int) $ mkStdGen 0) 2
10:23:17 <lambdabot>  [2,2,0,0]
10:24:21 <lilac> > let f x = foo where foo = x in f 1
10:24:23 <lilac> > let f = \x -> foo where foo = x in f 1
10:24:23 <lambdabot>  1
10:24:25 <lambdabot>  x
10:24:53 <rwbarton> MyCatVerbs: f x y = z where z = g x  is not the same (operationally) as  f x = \y -> z where z = g x
10:26:32 <thetallguy> conal
10:26:43 <MyCatVerbs> rwbarton: right, but that's just a syntactic issue. If you write that as a let clause, it becomes explicit. f x = let z = g x in \y -> doSomethingWith y z, versus f x = \y -> let z = g x in doSomethingWith y z.
10:27:07 <thetallguy> n/m
10:27:09 <rwbarton> MyCatVerbs: Sure.
10:28:07 <MyCatVerbs> rwbarton: I think let-floating will transform one into the other anyway, though, since they're not observably different.
10:28:18 <Myoma> 'In subsequent phases, the live CAF information is used to compute SRTs'
10:28:22 <Myoma> .. what does that mean?
10:28:23 <lilac> MyCatVerbs: one has a space leak, the other uses more runtime :)
10:29:18 <lilac> although if you mean different in the denotational semantics, then yes :)
10:29:39 <Myoma> how is there space leak?
10:29:43 <MyCatVerbs> lilac: space leak? No there isn't?
10:30:02 <MyCatVerbs> Myoma: you probably want to be asking these questions in #ghc, since that's where the GHC devs hang out. Well, there and also on mailing lists.
10:30:26 * Myoma is not hacking GHC just reading it 
10:30:27 <dons> MyCatVerbs: static reference tables.
10:30:50 <MyCatVerbs> dons: hah! Foiled by name completion. :)
10:30:58 * MyCatVerbs gives dons a cookie. ^_^
10:30:58 <dons> Myoma: ^^
10:31:07 * sw17ch is sad because of infinite types :
10:32:15 <Myoma> what does that mean?
10:32:54 <Myoma> f x = let z = g x in \y -> doSomethingWith y z
10:32:54 <Myoma> f x = \y -> let z = g x in doSomethingWith y z
10:34:00 <Myoma> f x y = doSomethingWith y (g x)
10:34:13 <Myoma> is that equivalent to any of them?
10:35:01 <MyCatVerbs> Myoma: that last one is what we would, in most highly arcane parlance, describe as "the only sane goddamn way of writing that function".
10:35:10 <Myoma> heh
10:35:41 <MyCatVerbs> Myoma: the rest are completely bletcherous examples just to illustrate the idea.
10:35:50 <Myoma> which idea?
10:36:27 <MyCatVerbs> Myoma: currying, at first. Then we got into let-floating and it all turned hairy from there. :)
10:36:44 <Myoma> I had never heard of let-floating
10:36:48 <Myoma> what is that?
10:36:59 <MyCatVerbs> Crap, I just did something weird to my GNU screen session and I don't know what.
10:37:21 <MyCatVerbs> Myoma: it's an optimization GHC does.
10:37:22 <Myoma> oh let-floating is how you get lazyness
10:37:28 <MyCatVerbs> No.
10:38:09 <MyCatVerbs> Say you have, f x = \y -> let z = g x in h y z, right? But (g x) is _really_ expensive to compute.
10:39:24 <MyCatVerbs> And you want to do something like, uh, map (f 1) [1..100], aye? So that expensive (g x) would be getting recalculated over and over when it doesn't really need to be.
10:39:37 <Myoma> oh I see
10:39:49 <Myoma> ok
10:40:01 <MyCatVerbs> GHC can transform that to, f x = let z = g x in \y -> h y z, which uses a bit more memory but allows that (g x) to be shared among all the invocations when you do map (f 1) [1..10].
10:40:20 * MyCatVerbs pokes dons. "Care to please correct me if I have that wrong?"
10:40:29 <Myoma> so in this one f x y = doSomethingWith y (g x)
10:40:44 <Myoma> do you still get sharing of (g x) during the map?
10:41:17 <MyCatVerbs> Myoma: I think GHC will float the (g x) out in that case.
10:42:25 <MyCatVerbs> (Provided you compile with the optimizer turned on, naturally. If you're really worried about performance, check with ghc-core.)
10:42:27 <Myoma> @hoogle delay
10:42:27 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
10:42:54 <rwbarton> I thought GHC never did this kind of (time) optimization because it could sometimes result in much larger memory usage.
10:43:05 <rwbarton> But I have no way to back up that assertion
10:43:11 <MyCatVerbs> rwbarton: ghc-core is your friend.
10:43:15 <Myoma> @hoogle unsafePerformIO
10:43:16 <lambdabot> Foreign unsafePerformIO :: IO a -> a
10:43:16 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
10:43:26 <dolio> You're thinking of CSE, not let floating.
10:43:42 <MyCatVerbs> rwbarton: mine, too. In fact, ghc-core loves everybody. It's like a deity's offspring, but more reliable (although more restricted in scope).
10:43:47 <rwbarton> dolio: Is there not the same issue?
10:43:55 <lilac> MyCatVerbs: you just described the space leak. g x is cached after the transformation, and its result could be big
10:44:00 <roconnor> is (,)a  a monad even when a is not a monoid?
10:44:16 <ddarius> roconnor: No.
10:44:20 <rwbarton> roconnor: No, since you need  join :: (a, a, x) -> (a, x)
10:44:34 <roconnor> take the second one
10:44:36 <roconnor> or the first
10:44:45 <rwbarton> roconnor: Then there is no identity
10:44:47 <dolio> rwbarton: I don't know. It's not clear that there isn't, though.
10:44:47 <MyCatVerbs> Myoma: easy way to test it is to write f x y = y + (naiveFibonacci x), then compare the time taken by main = print (map (f 20) [1..100]) when compiled with -O0 and -O2. You should see something stupid like a dozen orders of magnitude difference. :)
10:44:51 <ddarius> roconnor: Well you could stick () there or undefined, but that would make it equivalent to Identity
10:44:56 <dolio> I don't know what situations let floating is done in, though.
10:44:57 <roconnor> rwbarton: ah right
10:44:57 <Myoma> let foo x = (x,sleep 100) in map foo [1..100]
10:45:03 <Myoma> waits between each one
10:45:05 <Myoma> in ghci
10:45:15 <roconnor> good
10:45:34 <lilac> roconnor: the problem is 'return'. you need a function x -> (a, x)
10:45:44 <roconnor> yep
10:46:01 <MyCatVerbs> Myoma: beware, no optimization passes are done in GHCi.
10:46:02 <Myoma> but it only sleeps once with ghc -O2
10:46:07 <MyCatVerbs> Myoma: right. ^^
10:46:50 <djsiegel_> Hey, how do I get a constructor from a type? I don't quite know how to say this, but if I have data A = B | C String | D Int, and I have a [A], how do I check if I have a C `elem` [A]?
10:47:14 <Myoma> djsiegel_: isC (C _) = True ; isC _ = False
10:47:14 <roconnor> @djinn x->(a,x)
10:47:14 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
10:47:18 <djsiegel_> filter (isA C) [A]    is what I want
10:47:19 <Myoma> any isC
10:47:36 <roconnor> @djinn (a,(a,x)) -> (a,x)
10:47:37 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
10:47:38 <MyCatVerbs> Myoma: the fact that GHCi is a constant factor slower than compiled GHC code (because of the bytecode interpretation versus native machine code) isn't so much of an issue in practice, but the fact that GHC's optimizer can be made to (in extreme cases) shave centuries off your program's running time is sometimes a bit awkward. :)
10:47:39 <saya> String isnt an instance of arbitrary?
10:47:42 <sw17ch> What's the formal name for Haskell's type system?
10:47:47 <djsiegel_> hmmm, ok, is there a fancier way?
10:47:49 <roconnor> what happend to lambdabot?
10:47:54 <lilac> roconnor: and further, you need to fulfil the monad laws, which means that a >>= return === a, so >>= can't discard the LHS's a. similarly it can't discard the RHS's a. i think the monoid requirement follows from such arguments.
10:48:00 <Myoma> The Haskell Type System
10:48:06 <saya> (btw thx mmorrow / lilac for answering my question)
10:48:14 <sw17ch> Myoma, it doesn't have some earlier rooting of a different name?
10:48:16 <MyCatVerbs> sw17ch: it's based on Hindley-Milner, but very greatly expanded.
10:48:23 <Myoma> sw17ch: No
10:48:29 <roconnor> lilac: makes sense
10:48:32 <sw17ch> MyCatVerbs, tahts' the name i was looking for
10:48:51 <dcoutts_> sw17ch: H98 type system is HM plus an extension for polymorphic recursion
10:49:09 <augustss> plus type classes
10:49:11 <dcoutts_> oh, and type classes of course
10:49:18 <lilac> plus explicit type annotations
10:49:23 <MyCatVerbs> dcoutts_: GHC type system is H98 plus extensions for type-level anarchy! :)
10:49:29 <dcoutts_> MyCatVerbs: ;-)
10:49:32 <sw17ch> MyCatVerbs++
10:49:41 <Myoma> I don't see how any of this is clearer than saying "The Haskell Type System"
10:49:54 <Myoma> maybe you could translate it to greek or something
10:49:56 <sw17ch> Myoma, it's not, i'm just looking for keywords so i can find some papers on it
10:50:09 <sw17ch> i want to know why infinite types are hard :)
10:50:12 <Myoma> don't bother with papers, get TAPL
10:50:13 <sw17ch> beyond the, you know, infinit part
10:50:23 <sw17ch> TAPL?
10:50:24 <dcoutts_> augustss: since you're here, I do you know of a good canonical reference for the inductive and co-inductive encodings of data in system F ?
10:50:27 <ddarius> Infinite types aren't hard.
10:50:29 <Myoma> recursive types are implemented in ocaml
10:50:30 <dmhouse> ?go Types and Programming Languages
10:50:32 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
10:50:32 <lambdabot> Title: Types and Programming Languages
10:50:34 <MyCatVerbs> sw17ch: Types and Programming Languages.
10:50:36 <Myoma> ?go TAPL
10:50:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
10:50:38 <lambdabot> Title: Types and Programming Languages
10:50:39 <dmhouse> sw17ch: best book on type theory you'll even buy.
10:50:41 <dmhouse> *ever
10:50:45 <lilac> sw17ch: data X = X (Int -> X)
10:50:48 <sw17ch> ddarius, can they be used in haskell?
10:50:55 <dcoutts_> augustss: erm, /I//
10:50:57 <MyCatVerbs> ddarius: yes, but it seems they're not actually all that useful in practice.
10:51:02 <stepcut> infinite types are not hard, just unsafe
10:51:04 <ddarius> sw17ch: Not equirecursive types, but that doesn't make them hard.
10:51:11 <augustss> dcoutts_: hmmm, off hand, I can't say that I do
10:51:15 <sw17ch> ddarius, alright, hard was the wrong adjective
10:51:28 <MyCatVerbs> sw17ch: not directly, but you can use newtypes to make things work where you'd otherwise have to use infinite types.
10:51:41 <lilac> sw17ch: haskell eschews types that it can't write down in a finite amount of space. this is a Good Thing for error reporting.
10:51:43 <saya> Hey is there a standard Arbitrary Char instance somewhere to use with quickcheck?
10:51:47 <stepcut> almost every time I have enabled -rectypes in ocaml I have regreted it
10:52:05 <sw17ch> I want to apply a function N times, but each new application has a new type
10:52:06 <augustss> dmhouse: but TAPL has some factual error and lacks depth in some areas
10:52:07 <dcoutts_> augustss: it seems to be scattered all over the place, we all know it but without an obvious canonical reference
10:52:22 <sw17ch> a -> T a
10:52:34 <Myoma> TAPL is the best intro book I could think of
10:52:39 <augustss> dcoutts_: maybe in some early coq papers?
10:52:52 <rwbarton> sw17ch: that sounds more like polymorphic recursion than recursive types (a = T a)
10:52:55 <dmhouse> augustss: I've no doubt it has its flaws, but it extremely well written (modulo the errors -- although doesn't Peirce keep an errata on his website?) and seems pretty comprehensive.
10:53:13 <MyCatVerbs> sw17ch: like if you want to write a function which takes an integer and returns a pair consisting of an integer and another function of the same type as the first function, you can do that directly with infinite types, and you can do that easily in Haskell with a newtype. newtype WeirdFunction = WF (Int -> (Int, WeirdFunction), and from there it's easy.
10:53:15 <sw17ch> in all honesty, i'm not entirely sure waht i'm talking about :)
10:53:17 <lilac> sw17ch: you can do that with a type class (and probably a few extensions)
10:53:21 <dcoutts_> augustss: my best so far is a note from Wadler http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
10:53:24 <lambdabot> http://tinyurl.com/62s2nh
10:53:33 <augustss> dmhouse: yes, it's very good book.  i can't recommend anything better
10:53:45 <MyCatVerbs> sw17ch: er, please overlook my inability to balance parentheses. Obviously I'm not much of a lisp hacker. :)
10:53:46 <dcoutts_> augustss: I guess I'm trying to avoid the really heavy logic papers :-)
10:54:02 <dmhouse> sw17ch: I'd seriously consider buying TAPL if you want to study (or just read about) type theory.
10:54:22 <rwbarton> sw17ch: you may be interested in http://hpaste.org/9427
10:54:29 <Myoma> if you are just interested in programming languages, TAPL is worth getting
10:55:16 <ddarius> dcoutts: The "equations" in that are related to Kan extensions.
10:55:29 <sw17ch> http://hpaste.org/10008
10:55:37 <sw17ch> that's what i'm doing, the fixn function is badly named
10:55:41 <sw17ch> (applyN is better)
10:55:50 <dcoutts_> ddarius: I'm afraid that means nothing to me, I clearly have not done enough category theory or logic
10:56:37 <rwbarton> sw17ch: fixn cannot be typed, since it's result might be of type B or (W something).
10:56:50 <dmhouse> sw17ch: btw you can do {-# LANGUAGE EmptyDataDecls #-} at the top of the file to make GHCi apply that flag automagically.
10:57:12 <sw17ch> bah, i was using the GHC options syntax.. dangit.. i always forget the LANGUAGE part
10:57:13 <Myoma> rwbarton: How does that work? :)
10:57:26 <Myoma> rwbarton: .. Does it do computing with types at runtime?
10:57:40 <lilac> sw17ch: http://hpaste.org/10009
10:57:50 <rwbarton> Myoma: I would say it builds a dictionary at runtime
10:58:09 <dmhouse> Hmm, fixn looks like (!! n) . iterate to me
10:58:39 * Myoma tries to overload ..
10:58:44 <Myoma> sw17ch: http://okmij.org/ftp/Haskell/de-typechecker.lhs
10:58:47 <dmhouse> Well, ((!! n) .) . iterate.
10:59:10 <mmorrow> sw17ch: was scrolling back and saw you mention the C ouput of jhc... i was looking at that myself the other day, i uploaded some possibly interesting stuff to this dir: http://code.haskell.org/~morrow/jhc/tests/csv/
10:59:11 <lambdabot> Title: Index of /~morrow/jhc/tests/csv
10:59:12 <sw17ch> dmhouse, i was thinking that
10:59:14 <Myoma> rwbarton: Is it possible to write a program that gives a type error at runtime ?
10:59:26 <sw17ch> mmorrow, thanks!
10:59:28 <rwbarton> Myoma: a function  forall a. Peano a => a -> b  is really a function  forall a. (a -> Int) -> a -> b  (by expanding the definition of class Peano)
10:59:35 <lilac> Myoma: Data.Dynamic
10:59:41 <dmhouse> Yhich you definitely *can* type :)
10:59:49 <mmorrow> sw17ch: :) ... so this http://code.haskell.org/~morrow/jhc/tests/csv/csv.hs.html  goes to  http://code.haskell.org/~morrow/jhc/tests/csv/hs.out_code.c.html
10:59:49 <lambdabot> Title: Haskell code
10:59:53 * dmhouse wonders what rwbarton meant when he said fixn doesn't type
11:00:14 <dmhouse> *Main> :t fixn
11:00:15 <dmhouse> fixn :: (Num a, Ord a) => (t -> t) -> t -> a -> t
11:00:20 <dolio> Data.Dynamic doesn't really give type errors are runtime, though. :)
11:00:21 <Myoma> I see
11:00:25 <sw17ch> mmorrow, o_O
11:00:29 <sw17ch> wow
11:00:29 <rwbarton> dmhouse: sorry, you're right.  I should have said  fixn mapply  doesn't type
11:00:29 <thoughtpolice> i tried to build jhc the other day
11:00:30 <dolio> It gives type-rep errors. :)
11:00:31 <dmhouse> Of course, fixn mapply doesn't type, as mapply isn't a -> a
11:00:32 <thoughtpolice> did not workee :(
11:01:11 <thoughtpolice> last time I used it I only remember it taking about 20 minutes on 'hello world,' but damn was that executable small :]
11:01:24 <mmorrow> sw17ch: it's pretty cool in that the entire jhc runtime goes into that C file apparently
11:01:24 <lispy> Is HList decidable?
11:01:40 <lispy> Er, is typing checking an HList decidable I mean
11:02:09 <lispy> They use fundeps, but Id on't think they reqeuire undecidable instances...not sure
11:02:13 <Myoma> How do we know typeclasses don't go wrong -- that's what I mean
11:02:32 <dmhouse> lispy: isn't an HList just [Box], where data Box = forall a. MkBox a?
11:02:37 <dmhouse> (Essentially.)
11:02:39 <sw17ch> mmorrow, that's really awesome! then gcc can pull out the parts that aren't used...
11:02:40 <Myoma> > [1..0]
11:02:41 <lambdabot>  []
11:02:42 <lispy> dmhouse: no
11:02:43 <lilac> rwbarton: you'd need n to be a type-level integer, or to recast mapply as a -> a, or template haskell (or possibly dependent types?) for that sort of thing to work, i think.
11:02:46 <sw17ch> mmorrow, how big was that executable?
11:02:50 <lispy> dmhouse: that's not HList at all :)
11:02:52 * Myoma found
11:02:52 <Myoma> regList 0 = []
11:02:53 <Myoma> regList n = [1 .. n]
11:02:54 <Myoma> in ghc
11:02:55 <dmhouse> Oh, good.
11:02:56 <shepheb> GHC's Word32 has machine endianness, right?
11:03:02 <dolio> lispy: I doubt they're undecidable in practice. But the way fundeps work requires UndecidableInstances for anything interesting.
11:03:18 <thoughtpolice> mmorrow: there's only like 20 lines of boilerplate that goes in there (region inference code?) and the rest the code + the standard libs from what I understand (since jhc compiles the libs in with all compilations)
11:03:21 <lispy> Well, they avoid overlapping instances
11:03:21 <dolio> Or, that style of programming.
11:03:23 <dmhouse> Which is one of the reasons no-one really wants fundeps in h'.
11:03:24 <lilac> rwbarton: you could possibly get something workable using Data.Dynamic, if you know what your final type will be
11:03:57 <lispy> dmhouse: right but using gadts on the other hand is always decidable, yeah?
11:04:13 <Myoma> type inference for GADTs is not decideable is it?
11:04:43 <dolio> There are situations where it's obviously ambiguous.
11:04:51 <lispy> Myoma: I'm pretty sure it is decideable, that's what's in my head after reading several papers but I don't have a citation
11:05:09 <dmhouse> Don't GADTs generalise fundeps?
11:05:10 <dolio> data Foo a where FooInt :: Foo Int ; foo FooInt = ...
11:05:15 <Myoma> why doy ou have to annotate then?
11:05:16 <lispy> dolio: ambiguous yes, but ghc treats those as wobbly types and stops inference
11:05:25 <dolio> Should foo be "Foo Int -> ..." or "Foo a -> ..."
11:05:32 <thoughtpolice> mmorrow: i would really like to see jhc become more useful, it generates really small programs and the generated .c is pure ISO (portable)
11:05:48 <rwbarton> lilac: actually there is another way which covers many uses, which I used in http://hpaste.org/9427: rather than return a value of type "exists a. Peano a => a", pass it to a polymorphic function and return the result of that
11:05:49 <trurl> hi, I'm trying to install hdbc-sqlite3.  I get error messages like the following: /usr/local/lib/ghc-6.8.2/lib/base-3.0.1.0/libHSbase-3.0.1.0.a(Conc__142.o): In function `s4lk_info': ghc14288_0.hc:(.text+0x2cc): undefined reference to `base_ForeignziCziError_a96_info'
11:05:53 <dolio> Or something else.
11:05:54 <lilac> lis[y etc: good papers on fundeps and decidability may be found here: http://research.microsoft.com/~simonpj/papers/fd-chr/
11:05:55 <lambdabot> Title: Simon Peyton Jones: papers
11:06:09 <lispy> lilac: indeed
11:06:12 <mmorrow> thoughtpolice: the C's (well the parts which are meant to be) is actually readable to, complete with nice comments and ascii diagrams
11:06:21 <lispy> lilac: I've read several but misplaced my notes :)
11:07:00 <mmorrow> thoughtpolice: me too. jhc seems /really/ nice. another thing i'm meaning to look more into is how it implements classes
11:07:16 <bjrn> Is there a haskell array that gets created at compile-time and is indexed by Ints? I have a bunch of very large tables and wrapping all the values in tuples seems silly
11:07:30 <rwbarton> lilac: I like this application:
11:07:30 <rwbarton> *Math.Modular> (10^(10^10000)) `modN` 31337
11:07:30 <rwbarton> 16634
11:07:30 <rwbarton> (0.58 secs, 178871532 bytes)
11:07:31 <mmorrow> (i read the short description, but don't remember where that was)
11:08:10 <thoughtpolice> mmorrow: http://repetae.net/computer/jhc/jhc.shtml
11:08:14 * Myoma thinks that cap N sticks out like a sore thumb
11:08:15 <lambdabot> Title: jhc
11:08:56 <thoughtpolice> mmorrow: but definitely I would like to see JHC mature a lot more. :] having it output pure iso C is a big benefit; aggressive compilation is another.
11:09:09 <lilac> rwbarton: that buildType trick is really neat ;-)
11:09:25 <thoughtpolice> it would be way more immediately useful right now if the compilation times could be cut down
11:09:26 <trurl> any idea what is missing?
11:09:27 <thoughtpolice> (*a lot*)
11:10:16 <rwbarton> lilac: yeah.  it's in some oleg paper, but still comprehensible by mortals :)
11:10:34 <lispy> what is the buildType trick?
11:10:37 <ddarius> thoughtpolice: Cutting down the compilation times would require significantly reducing the "aggressive compilation"
11:10:46 <mmorrow> thoughtpolice: yeah, agreed
11:11:04 <rwbarton> lispy: lilac: I like this application:
11:11:04 <rwbarton> *Math.Modular> (10^(10^10000)) `modN` 31337
11:11:04 <rwbarton> 16634
11:11:04 <rwbarton> (0.58 secs, 178871532 bytes)
11:11:13 <rwbarton> lispy: Sorry! http://hpaste.org/9427   (X selection fooled me)
11:11:39 <dons> bjrn: you can create arbitrary arrays at compile time, yeah
11:11:46 <dons> but it's a little involved..
11:11:50 <mmorrow> thoughtpolice: yeah, that's exactly the type class spiel i read
11:12:01 <thoughtpolice> ddarius: sure, I think there is a middle ground to be sought though. but yeah, you can't always have your cake and eat it too I suppose
11:12:15 <bjrn> dons: Nice, any keywords I can search for?
11:12:17 <dons> bjrn: http://haskell.org/haskellwiki/Compiling_in_constants
11:12:18 <lambdabot> Title: Compiling in constants - HaskellWiki
11:12:26 <bjrn> dons: ah cheers
11:12:35 <dons> bjrn: bytestring binary literals, basically, containing some arbitrary value.
11:12:39 <lispy> rwbarton: so is that decideable then?
11:12:43 <mmorrow> thoughtpolice: err, to clarify <mmorrow> thoughtpolice: yeah, agreed  was to  ] having it output pure iso C is a big benefit; aggressive compilation is another.
11:13:17 <mmorrow> personally i don't mind long (w/in reason!) compilation times if that's time well spent
11:13:41 <dons> ibid: any progress on planet.haskell.org's galois subscription? :)
11:14:07 <ibid> dons: i said tomorrow ;)
11:14:26 <dons> isn't it tomorrow today?
11:14:37 * lispy thinks of a Cake song
11:15:16 <dons> lispy: the one about the girl with a short skirt and a loooong jacket?
11:15:42 <rwbarton> lispy: I'm not sure exactly what you mean; but it doesn't use much of -fglasgow-exts, that was just me being lazy
11:16:16 <thoughtpolice> mmorrow: yeah, jhc seems to be pretty serious about compiling. :] i wonder how beefy of a machine you would need for self compilation...
11:16:17 <lispy> dons: comfort eagle, actually, "Now today is tomorrow
11:16:17 <lispy> And tomorrow today
11:16:18 <lispy> And yesterday is weaving in and out"
11:16:41 <dons> ibid: so is today tomorrow?
11:16:43 * mmorrow shudders
11:16:45 <lispy> rwbarton: is the type checking for buildType decidable in general?
11:17:30 <ibid> dons: it's still friday here
11:17:41 <lispy> rwbarton: anyway, that's not really want a I want to know.  I want to know when GADTs stop being decidable and when/if HList is decidable.
11:17:59 <ibid> dons: i'd say 18 hours from now is a good time to ping, assuming you haven't heard from me before
11:18:29 <lispy> rwbarton: I was thinking about asserting that our decision to use GADTs allows us to keep our type checking whereas with HList that might not have been the case
11:18:33 <ibid> dons: (when we last talked, it was friday morning, now is friday evening)
11:18:42 <Myoma> wait can you do HList with GADTs??
11:18:51 <mmorrow> thoughtpolice: then again i had to build 6.8.3 with 6.4 the other week and it took 3+ hours on a 4-core (3Ghz each) box (a webhosting co's)
11:18:52 <Myoma> and type families
11:19:22 <lispy> Myoma: I'm not Oleg )
11:19:26 <lispy> Myoma: so I'm not sure...
11:19:39 <lispy> Myoma: you could use GADTs with Hlist
11:19:44 <rwbarton> lispy: yeah, I'm not really sure.  I could only offer speculation.
11:19:47 <dons> ibid: ah!
11:19:48 <dons> timezones
11:19:49 <mmorrow> thoughtpolice: (but 6.8/6.9 are **way** faster)
11:19:52 <lispy> Myoma: but most of the current HList coolness is using fundeps
11:19:59 <lispy> rwbarton: yeah, me too :)
11:20:08 <mmorrow> thoughtpolice: thankfully
11:20:09 <thoughtpolice> mmorrow: yeah, i remember when 6.8 came out the huge improvements I saw in compilation times
11:20:14 <thoughtpolice> it was welcomed greatly :]
11:20:23 <mmorrow> heh
11:20:40 <lispy> I upgraded my computer when compile times got in the way :)
11:20:52 <thoughtpolice> mmorrow: but even with a parallel build it took 3+ hours? were you running with like 'make -j12' or something?
11:21:00 <mmorrow> make -j10
11:21:24 <Myoma> what is wrong with  data family Append l1 l2  ?
11:21:26 <thoughtpolice> hm, well I guess for a full production build ~3hrs isn't completely unreasonable when you have 6.4 for the bootstrapping compiler
11:21:39 <mmorrow> who knows what sort of vm or whatever i was in though on the webhosted box though...
11:21:45 <Myoma> oh -XTypeFamilies
11:22:00 <thoughtpolice> i think it took like ~9hrs or something on my 256mb ram archlinux box, compiling 6.8 with 6.6
11:22:09 <lispy> Myoma: Oh, type families are not something I'm familiar with
11:22:12 <thoughtpolice> which was in vmware, on windows xp
11:22:16 <mmorrow> thoughtpolice: holy shit
11:22:28 <lispy> Myoma: I hadn't realized that was a technical term when you mentioned it
11:22:30 <bjrn> rwbarton: You the math olympiad guy?
11:22:36 <rwbarton> bjrn: yep
11:22:42 <mmorrow> thoughtpolice: well, actually that setup sounds pretty grim for performance of anything :)
11:22:44 <lilac> (# #)
11:22:45 <thoughtpolice> mmorrow: hehe, yeah, but I didn't realize I could make -j<x> the build so I just let it all run single threaded
11:22:54 <mmorrow> hehe
11:22:58 <thoughtpolice> otherwise I would have at least done like make -j2 or -j4
11:23:03 <bjrn> rwbarton: Ah cool, thought i recognized the name
11:23:03 <thoughtpolice> mmorrow: it actually worked really well
11:23:08 <sw17ch> ghc supports the -j flag?
11:23:13 <mmorrow> thoughtpolice: nice
11:23:15 <mmorrow> make
11:23:19 <mmorrow> make -j2
11:23:26 <sw17ch> oh, dangit
11:23:32 <mmorrow> i know!
11:23:39 <sw17ch> there's no equivelant option?
11:23:48 <thoughtpolice> mmorrow: i mean some things were obviously out of its reach, but surprisingly I never had to dig into swap for compiling ghc
11:23:48 <mmorrow> i wish
11:23:58 <mmorrow> (i wish @s17ch)
11:24:00 <thoughtpolice> xmonad was my wm (and still would be now,) and I used other really minimalist tools so my compilers got most of the RAM anyway
11:24:50 <trofi> +RTS -Nthreads?
11:25:20 <mmorrow> trofi: but for the compilation itself...
11:25:57 <mmorrow> trofi: err, i mean in the same sense as make -jN
11:25:59 <rwbarton> mmorrow: Yes, ghc is written in haskell after all
11:26:18 <trofi> ghc --make -Nthreads does not work?
11:26:25 <trofi> ghc --make +RTS -Nthreads
11:26:51 <thoughtpolice> provided you build ghc itself with the threaded runtime and the compiler is designed to make use of e.g. forkIO, sure
11:26:58 <mmorrow> sure, it may be running multithreaded, but the compilation chain is a straight line instead of a graph (from the understanding of things i have)
11:28:46 <bjrn> rwbarton: Always wanted to ask "one of you" if you don't mind. I guess you've recieved lots of interesting job offers, such as DE Shaw etc. You planning to work in finance and make lots of money, or stay in academia?
11:29:07 * roconnor wants to know too
11:29:27 <ibid> dons: i assume you are empowered to speak for all the authors of the blog in this matter?
11:29:29 <EvilTerran> one of who?
11:29:34 <ibid> (processing now)
11:29:36 <mmorrow> whereas make -j4 will graphify that. for instance, write a Makefile to build a more-than-one-or-two-files haskell prog, then do make -jN (N>1) and whatch it fail
11:29:39 <mmorrow> *watch
11:30:04 <mmorrow> (the Makefile here is not using --make)
11:30:05 <tristes_tigres> hello
11:30:21 <mmorrow> hello
11:30:34 <mmorrow> :)
11:30:36 <Saizan_> mmorrow: why fail?
11:30:50 <tristes_tigres> it looks like "else" should be indented as "then" in if-then-else
11:30:56 <ibid> dons: um, actually, the "Terms and Conditions" are unacceptable for planet
11:30:57 <mmorrow> Saizan_: because it'll do things in an inappropriate order
11:31:00 <tristes_tigres> but emacs haskell mode aligns else with if
11:31:20 <dmhouse> tristes_tigres: that's another valid way of doing it
11:31:31 <dons> ibid: oh, what's that? :(
11:31:38 <dmhouse> tristes_tigres: it's actually the report's recommended indentation, but it's not how most Haskell programmers do it.
11:32:02 <tristes_tigres> dmhouse: which one is recommended ?
11:32:14 <Saizan_> mmorrow: ah, assuming you're not using ghc -M to fetch the module dependencies before?
11:32:17 <mmorrow> Saizan_: (or something). i'm not sure _precisely_, but i've had that happen any Makefile for haskell code (other than ghc itself) that i've make -jN>2 with
11:32:28 <dons> ibid: oh, the license for stuff that's no part of the blog
11:32:48 <mmorrow> Saizan_: yeah, i wasn't doing anything like that (nor was i before now even aware that existed :))
11:32:56 <dmhouse> tristes_tigres: I'd indent then and else, myself.
11:33:14 <dmhouse> tristes_tigres: if you want to modify haskell-mode's indentation engine to support this, lots of people would be very thankful :)
11:33:28 <Saizan_> mmorrow: hah, then it's good that we're going to get parallel builds in cabal when my gsoc gets integrated :)
11:34:02 <mmorrow> Saizan_: awesome! parallel cabal builds would be most excellent
11:34:16 <ibid> dons: there's no limitation there that excludes the blog - and the link is incldued on the blog page
11:35:09 <tristes_tigres> The thing is, this code http://hpaste.org/10010 stops compiling when if aligned with else
11:35:30 <tristes_tigres> and compiles otherwise
11:36:00 <mmorrow> err, of course in ... "code (other than ghc itself) that i've make -jN>2 with"  ... i meant s/2/1/
11:37:33 <motus2> How do I enforce scrictness for STRef argument? e.g. the following example hogs RAM:  runST $ do { r <- newSTRef 0; mapM_ (\n -> modifySTRef r (+n)) [1..1000000]; readSTRef r }
11:37:57 <gpds> any clue what i'm doing wrong here?
11:37:57 <gpds> probVictory:: Int -> Int -> Double
11:37:58 <gpds> probVictory z s = exp coeffS / (exp coeffS + exp coeffZ)  where
11:37:58 <gpds>     coeffS = -63 * s + 10
11:37:58 <gpds>     coeffZ = -21 * z
11:38:10 <gpds> ghc is complaining about double
11:38:14 <rwbarton> :t exp
11:38:15 <lambdabot> forall a. (Floating a) => a -> a
11:38:40 <rwbarton> gpds: you need some fromIntegral in there
11:39:04 <gpds> fromIntegral? ok ill look into that!
11:39:12 <gpds> :t fromIntegral
11:39:14 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:40:35 <mmorrow> gpds: if you're using fromIntegral a lot, it might be convenient to do something like
11:40:41 <mmorrow> fi = fromIntegral
11:41:06 <tristes_tigres> http://hpaste.org/10010#a1 and http://hpaste.org/10010#a2
11:41:21 <gpds> so fromIntegral is used when mixing int and float?
11:41:23 <tristes_tigres> only difference is space before "else"
11:42:11 <mmorrow> tristes_tigres: yeah, i believe that's the expected behavior
11:42:17 <dmhouse_> tristes_tigres: sorry, didn't realise you were in a do-block
11:42:22 <dmhouse_> tristes_tigres: it works outside of one
11:42:57 <tristes_tigres> Why ? Where is that behaviour specified ?
11:48:44 * motus2 needs help with STRef
11:49:18 <Myoma> motus2: what is the problem?
11:49:44 <motus2> the following code hogs RAM like crazy:
11:49:51 <motus2> runST $ do { r <- newSTRef 0; mapM_ (\n -> modifySTRef r  (+n)) [1..1000000]; readSTRef r }
11:50:16 <Myoma> do you compile it with ghc -O2 ?
11:50:18 <motus2> looks like (+n) builds up thunks instead of evaluating them
11:50:26 <motus2> -O3 did not help
11:50:56 <Myoma> @hoogle getSTRef
11:50:56 <lambdabot> No results found
11:50:57 <rwbarton> maybe replace (+n) with \x -> x `seq` x+n
11:50:59 <Myoma> @hoogle STRef
11:50:59 <lambdabot> module Data.STRef
11:50:59 <lambdabot> Data.STRef data STRef s a
11:50:59 <lambdabot> Data.STRef.Lazy data STRef s a
11:51:10 <motus2> ooh that's a great idea!
11:51:22 <motus2> lemme try
11:52:30 <sioraiocht> :t fromIntegral
11:52:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:52:44 * EvilTerran wouldn't expect that to be a problem with strict STRefs
11:52:47 <sioraiocht> > fromIntegral 5 :: Float
11:52:49 <lambdabot>  5.0
11:53:05 <motus2> Myoma: still does not work :-(
11:53:13 <motus2> :t seq
11:53:15 <lambdabot> forall a t. a -> t -> t
11:53:24 * sw17ch thinks fromIntegral is magical
11:53:26 <motus2> @hoogle seq
11:53:26 <lambdabot> Data.Sequence data Seq a
11:53:26 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
11:53:26 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
11:53:49 <Myoma> fromIntegral is just standard typeclass
11:53:56 <djsiegel_> Is there a better way to do nubBy (\a b -> fst a == fst b) ?
11:54:01 <EvilTerran> motus2, you may have to make it even stricter
11:54:03 <sw17ch> oh, i know
11:54:04 <Myoma> (==)`on`fst
11:54:07 <djsiegel_> Something like nubBy (comparing fst) ?
11:54:20 <sw17ch> but when you're first exposed to fromIntegral, it's a little surprising... at least it was for me
11:54:23 <djsiegel_> oh, I've heard of on but never used it
11:54:23 <djsiegel_> thanks
11:54:35 <MyCatVerbs> @type LT
11:54:36 <EvilTerran> djsiegel_, except it'd be "equating" rather than "comparing" for nubBy
11:54:36 <lambdabot> Ordering
11:54:41 <sw17ch> > fromIntegral 5 :: Rational
11:54:43 <lambdabot>  5%1
11:54:44 <EvilTerran> ?src comparing
11:54:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:54:47 <sw17ch> > fromIntegral 5 :: Double
11:54:47 <djsiegel_> yeah, I know
11:54:49 <lambdabot>  5.0
11:54:53 <sw17ch> so cool
11:54:59 <EvilTerran> which we get with ((==)`on`)
11:55:02 <djsiegel_> that's why comparing wasn't working :)
11:55:16 <Myoma> motus2: I tried running it and I got a stakc overflow
11:55:40 <Myoma> @src mapM_
11:55:40 <lambdabot> mapM_ f as = sequence_ (map f as)
11:55:43 <Myoma> @src sequence
11:55:44 <lambdabot> sequence []     = return []
11:55:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:55:44 <lambdabot> --OR
11:55:44 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:55:51 <Myoma> try a different mapM_...
11:56:19 <motus2> Myoma: same here.. :( I tried sequence_ with list comprehension instead of mapM_ with the same result
11:56:33 <EvilTerran> motus2, what about runST $ do { r <- newSTRef 0; mapM_ (\n -> do x <- readSTRef r; writeSTRef r $! x+n) [1..1000000]; readSTRef r } -- ?
11:56:40 <EvilTerran> ?src ($!)
11:56:41 <lambdabot> f $! x = x `seq` f x
11:56:59 <motus2> EvilTerran: cool, let me try it
11:57:05 <EvilTerran> that should force the value of the ref before running the action
11:57:13 * Myoma still gets a stack overflow with a different mapM
11:57:16 <EvilTerran> as i said, i thought STRefs were strict like that by default, but i may be mistaken
11:57:29 <EvilTerran> it should definitely be mapM_ and not mapM, anyway
11:57:36 <EvilTerran> Myoma, which mapM_ are you thinking of?
11:57:54 <motus2> EvilTerran: they are strict, but not for the value they contain
11:58:06 <mib_jaj9ob> Hi
11:58:12 <EvilTerran> motus2, er, what for, then?
11:58:16 <mib_jaj9ob> I am trying to install Network.HTTP
11:58:19 <Myoma> :t writeSTRef
11:58:20 <lambdabot> forall s a. STRef s a -> a -> GHC.ST.ST s ()
11:58:22 <mib_jaj9ob> However, during the build process I get the following error:
11:58:31 <mib_jaj9ob> [...]
11:58:34 <mib_jaj9ob> magic number mismatch: old/corrupt interface file?
11:58:36 <djsiegel_> Can someone help me understand (((1<) .) . gcd ? I don't understand why it's not (1<) . gcd
11:58:42 <mib_jaj9ob> .../Data/Word.hi is the file.
11:58:45 <motus2> for the ST itself, i guess
11:58:51 <mib_jaj9ob> I was using the Solaris binary package of GHC.
11:58:53 <djsiegel_> oh, is it a trick to make currying work on two arguments?
11:59:02 <bjrn> Whats the name of the function that flattens a list of lits? Such as [[1,2,3],[4,5]] == [1,2,3,4,5]?
11:59:03 <Myoma> motus, actually
11:59:07 <Myoma> mapM_ (\n -> writeSTRef r n) [1..1000000]
11:59:09 <Myoma> works
11:59:10 <djsiegel_> bjrn, concat
11:59:14 <bjrn> ah cheers
11:59:19 <trofi> @unpl (((1<) .) . gcd
11:59:19 <lambdabot> Unbalanced parentheses
11:59:26 <trofi> @unpl ((1<) .) . gcd
11:59:26 <lambdabot> (\ e h -> 1 < (gcd e h))
11:59:47 <djsiegel_> @unpl (1<) . gcd
11:59:47 <lambdabot> (\ d -> 1 < (gcd d))
11:59:49 <EvilTerran> > runST $ do r <- newSTRef undefined
11:59:49 <lambdabot>  Parse error at end of input
11:59:57 <trofi> :t gcd
11:59:58 <lambdabot> forall a. (Integral a) => a -> a -> a
12:00:02 <EvilTerran> > runST $ do r <- newSTRef undefined; return ()
12:00:04 <lambdabot>  mueval: Prelude.read: no parse
12:00:27 <motus2> Myoma: yep, even (modifySTRef r id) seems to work
12:00:35 <Myoma>   mapM_ (\n -> do e <- readSTRef r ; let v = e+n in v `seq` writeSTRef r v ; return ()) [1..1000000]
12:00:38 <Myoma> also works
12:01:04 <EvilTerran> ghci> runST $ do r <- newSTRef undefined; return ()
12:01:04 <EvilTerran> ()
12:01:04 <EvilTerran> ghci> runST $ do r <- newSTRef $! undefined; return ()
12:01:04 <EvilTerran> *** Exception: Prelude.undefined
12:01:06 <motus2> Myoma: neat
12:01:11 <Myoma> I guess you just have to make a strict modify ST ref
12:01:12 <EvilTerran> motus2, did my version with $! work?
12:01:16 <tristes_tigres> Is there some reason why indent rules for if-then-else change inside do{} ?
12:01:18 <Myoma> and use that until something better comes along
12:01:30 <ddarius> tristes_tigres: They don't.
12:01:36 <EvilTerran> ddarius, actually, they do
12:01:41 <EvilTerran> slightly
12:01:48 <EvilTerran> they become a little more permissive, iirc
12:01:49 <tristes_tigres> ddarius: http://hpaste.org/10010#a1 and http://hpaste.org/10010#a2
12:01:54 <trofi> @pl \f g x -> g (f x)
12:01:54 <lambdabot> flip (.)
12:02:00 <trofi> @pl \f g x -> f (g x)
12:02:00 <lambdabot> (.)
12:02:07 <trofi> @pl \f g h x -> f (g (h x))
12:02:08 <lambdabot> (. (.)) . (.) . (.)
12:02:14 <EvilTerran> eeeeeeeeew
12:02:14 <tristes_tigres> thi is evil
12:02:21 <ddarius> EvilTerran: No, people want them to change
12:02:22 <trofi> @pl \f g a b -> f (g a b))
12:02:22 <lambdabot> (line 1, column 22):
12:02:22 <lambdabot> unexpected ")"
12:02:22 <lambdabot> expecting variable, "(", operator or end of input
12:02:25 <trofi> @pl \f g a b -> f (g a b)
12:02:25 <lambdabot> (.) . (.)
12:02:33 <ddarius> The rules are consistent.  People's expectations are not.
12:03:13 <tristes_tigres> ddarius: why indenting else to if does not work inside do block ? What is the reason for it
12:03:15 <motus2> EvilTerran: yep, $! works! thanks a lot!
12:03:31 <EvilTerran> :)
12:03:32 <Myoma> motus2: so what do you have now?
12:05:00 <motus2> Myoma: it's exactly what EvilTerran said:  runST $ do { r <- newSTRef 0; mapM_ (\n -> do x <- readSTRef r; writeSTRef r $! x+n) [1..1000000]; readSTRef r }
12:05:05 <ddarius> tristes_tigres: Because the rule for layout for do (and in general) is that anything indented at the same level as the first statement is a new statement.
12:05:18 <Myoma> motus2,   mapM_ (\n -> strictlyModifySTRef r (+n)) [1..1000000]
12:05:34 <ddarius> There are no rules for indenting if-then-else, it's just an expression like any other.
12:05:47 <tristes_tigres> ddarius: why it works outside the do block then ?
12:05:53 <motus2> wow, where did you find that?
12:05:58 <motus2> @hoogle strictlyModifySTRef
12:05:58 <lambdabot> No results found
12:06:09 <Myoma> it's in test.hs on my computer ...
12:06:18 <Myoma> strictlyModifySTRef ref f = do old <- readSTRef ref; writeSTRef ref $! f old; return ()
12:06:24 <ddarius> tristes_tigres: As I just said, there are no layout rules for if-then-else or any other expression.  You can put the else wherever you like as far as if-then-else is concerned.
12:07:07 <motus2> Myoma: neat :) thanks a lot, Myoma and EvilTerran ! you guys are awesome :)
12:07:18 <EvilTerran> ddarius, ah, i think i was thinking of some quirk involving nested do-blocks that's parsed more forgivingly by ghc than the spec states. or something.
12:07:25 <tristes_tigres> ddarius: that does not explain whty it works outside do{} but not inside
12:07:39 <Myoma> motus2: what are you doing with ST anyway?
12:07:44 <ddarius> tristes_tigres: Yes it does
12:08:23 <motus2> Myoma: project euler # 156 :)
12:08:23 <Myoma> @@ pl src on
12:08:23 <lambdabot>  pl src on
12:08:23 <EvilTerran> ghci> :{
12:08:23 <EvilTerran> Prelude| do if True then Nothing else do
12:08:23 <EvilTerran> Prelude|    Nothing
12:08:23 <EvilTerran> Prelude| :}
12:08:23 <EvilTerran> Nothing
12:08:24 <EvilTerran> ghci> :{
12:08:25 <tristes_tigres> ddarius: inside do{} it does not compile if else is aligned to if. Outside it does compile
12:08:26 <EvilTerran> Prelude| if True then Nothing else do
12:08:28 <EvilTerran> Prelude| Nothing
12:08:30 <EvilTerran> Prelude| :}
12:08:34 <EvilTerran> <interactive>:1:26: Not in scope: `doNothing'
12:08:36 <EvilTerran> that's the example i was thinking of
12:08:50 <EvilTerran> (sorry for the mini-flood)
12:08:55 <tristes_tigres> on its face, different behaviour
12:08:58 <ddarius> tristes_tigres: Which is completely consistent with the layout rules.
12:09:11 <ddarius> tristes_tigres: This is why some people want to change it, but those people are wrong.
12:09:17 <EvilTerran> tristes_tigres, you could demonstrate the same problem without using if
12:09:26 <EvilTerran> @. pl src on
12:09:26 <lambdabot> (line 1, column 1):
12:09:27 <lambdabot> unexpected end of input
12:09:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:09:30 <EvilTerran> eeh
12:09:33 <EvilTerran> @src on
12:09:33 <lambdabot> (*) `on` f = \x y -> f x * f y
12:09:44 <EvilTerran> @pl \(*) f x y -> f x * f y
12:09:45 <lambdabot> (line 1, column 3):
12:09:45 <lambdabot> unexpected "*"
12:09:45 <lambdabot> expecting pattern
12:10:33 <EvilTerran> ddarius, the quirk i demo'd above tends to manifest when people are using if, that's why i got a little confused
12:10:36 <ddarius> tristes_tigres: Outside a 'do' block (or a 'where' block or an 'of' block) you can have the 'else' less indented than the 'if' if you want, but you understand why that isn't allowed inside a block of layout right?
12:10:41 <Myoma> motus2: I hardly even understand the description :/
12:11:17 <tristes_tigres> ddarius: I do not understand why it is allowed outside, and even haskell mode for emacs indents it this way
12:11:29 <tristes_tigres> ddarius: if it is disallowed inside
12:11:45 <Myoma> an emacs mode doesn't have any say about what's a syntax error or not
12:11:54 <ddarius> tristes_tigres: The rules are simple and consistent.
12:12:10 <EvilTerran> Myoma, that does seem phrased confusingly, yes
12:12:29 <tristes_tigres> ddarius: you still haven't answered, which rule allows it outside do {}
12:12:45 <RayNbow> hmm... (a -> [a] -> b -> b) -> b -> [a] -> b    -- does this type generalizes paramorphisms on lists?
12:13:16 <EvilTerran> Myoma, it seems to me that f (n,d) = length . filter (==show d) . concatMap show $ [0..n]
12:13:24 <tristes_tigres> saying over and over that rules are consistent does not answer the question
12:13:31 <ddarius> tristes_tigres: Except for layout blocks, Haskell is free form.  As I said, you can put the 'else' wherever you want.
12:13:35 <ddarius> @where Report
12:13:35 <lambdabot> http://www.haskell.org/onlinereport/
12:13:38 <ddarius> tristes_tigres: Read.
12:15:24 <EvilTerran> Myoma, if you prefer, f (n,d) = length [() | i <- [0..n], d' <- show i, d == d']
12:15:42 <EvilTerran> er, approximately. missed a "show" there, i'm sure you can work it out :)
12:16:02 * EvilTerran =<< food
12:17:02 <lispy> EvilTerran =<< (food `fmap` salt)
12:17:11 <lispy> season to taste
12:17:25 <lispy> er, salt `fmap` food, of course
12:17:36 <tristes_tigres> ddarius: the term "layout block" does not seem to be defined in the report
12:19:37 <ddarius> tristes_tigres: That's irrelevant.  The syntax for the language and the layout algorithm are described or are you going to say the language definition doesn't answer your question?
12:20:03 <mmorrow> tristes_tigres: i think it's under the "lexical structure" section
12:20:19 <mmorrow> err, i dunno about that term exactly, but ...
12:20:42 <tristes_tigres> mmorrow:no
12:20:47 <mmorrow> heh
12:23:32 <Myoma> :{
12:23:58 <mmorrow> tristes_tigres: paragraph 3 in |2.7  Layout| seems to "lay" it out pretty well :)
12:24:04 <Myoma> ahaha
12:24:43 <tristes_tigres> "The specification takes the form of a function L that performs the translation. "
12:24:46 <tristes_tigres> this one ?
12:24:57 <mmorrow> err, a sec
12:25:18 <mmorrow> are you here? http://haskell.org/onlinereport/lexemes.html
12:25:24 <lambdabot> Title: Haskell 98 Lexical Structure
12:25:40 <Myoma> "people who talk with pixels over the web" :D
12:26:23 <tristes_tigres> mmorrow: you mean second bullet in section 9.3 ?
12:26:34 <mmorrow> section 2.7
12:26:35 <ddarius> mmorrow: You poor handwriting made 2.7 look like 9.3
12:26:51 <mmorrow> hehe, i should stop using a fountain pen
12:27:23 <tristes_tigres> I see, thanks
12:27:27 <mmorrow> :)
12:27:45 <Myoma> hrmf
12:27:56 <Myoma> I read various bits of GHC but I didn't really get it
12:28:27 <mmorrow> Myoma: keep reading!
12:28:39 <ddarius> Myoma: Why are you reading various bits of GHC?
12:28:52 <Myoma> trying to figure out this compiling buisness
12:29:05 <ddarius> Myoma: Why are you reading various bits of GHC?
12:29:38 <mmorrow> Myoma: re your discussion about visualizing thing earlier .. yeah, i totally want to generate a module dep graph + function dep graph from GHC's src, then render it with graphviz
12:30:26 <ddarius> mmorrow: So you can follow it and find exactly where perl is invoked
12:30:33 <mmorrow> it shouldn't be too hard with haskell-src-exts once all the src files are preprocessed and unlitted
12:30:50 <mmorrow> ddarius: hah, exactly!
12:32:01 * ddarius should make a compiler in a single PCRE
12:32:42 * mmorrow suggests regexqq so that it can be embedded in a .hs and checked at compile-time
12:34:26 <ddarius> @google "native code compiler" in "perl compatible regular expressions"
12:34:31 <lambdabot> http://godi.camlcity.org/godi/toc/toc-3.08.html
12:34:31 <lambdabot> Title: GODI: The source-code Objective Caml distribution
12:37:29 <mmorrow> no dice
12:37:38 <mmorrow> guess you'll have to write one
12:38:02 <Myoma> aha
12:38:10 <Myoma> so objective caml is written in pcre
12:38:57 <mmorrow> hah
12:40:28 <tristes_tigres> @vixen layout
12:40:29 <lambdabot> where on a map is Panama?
12:41:37 <laz0r> going back to a 'normal' programming language after using haskell for a while gives me a weird feeling
12:41:56 <Myoma> which language
12:42:00 <laz0r> how can anyone not like static typing?
12:42:01 <Myoma> none seem normal to me ...
12:42:06 <laz0r> python
12:42:34 <laz0r> it's like, everything can be everything, nothing is check at compile time (besides basic syntax)
12:42:50 <shepheb> I'd rather have Python's dynamic types than C's static types.
12:43:03 <shepheb> but Haskell's static types rather than Python's dynamic types
12:43:04 * Myoma decides python is popular because it's normal
12:43:16 <mmorrow> tristes_tigres: i found this paper through a link in a haskell-cafe msg: http://code.haskell.org/~morrow/Globals.ps
12:43:40 <tristes_tigres> Forbidden
12:43:40 <tristes_tigres> You don't have permission to access /~morrow/Globals.ps on this server.
12:43:44 <mmorrow> tristes_tigres: it seems relevant to the fp stuff that's been being discussed
12:43:47 <mmorrow> hmm
12:43:53 <mmorrow> ah, hold on
12:44:19 <mmorrow> ok
12:44:21 <mmorrow> try now
12:44:28 <trofi> :t ((()))
12:44:29 <lambdabot> ()
12:45:02 <Myoma> @tope ((((()))))
12:45:04 <lambdabot> ()
12:45:10 <laz0r> at least i now know that i _really_ like haskells type system, more that thought before
12:45:15 <Myoma> @tope ((([[[((()))]]])))
12:45:16 <lambdabot> [[[()]]]
12:45:22 <tristes_tigres> ok, now it works
12:45:28 <laz0r> *more than i thought before
12:45:54 * Myoma likes currying and lazyness
12:46:09 * MyCatVerbs wants System O's type system instead. :p
12:46:13 <tristes_tigres> curry Chicken
12:46:26 <Myoma> @go System O
12:46:28 <tristes_tigres> @t curry Chicken
12:46:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:46:37 <lambdabot> http://www.system-o.co.jp/
12:46:37 <lambdabot> Title: System-O / �V�X�e���I�[ �I�t�B�X �C���e���A  ...
12:46:49 <Myoma> lambdabot needs to do UTF-8
12:47:03 <tristes_tigres> @type curry Chicken
12:47:05 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:47:15 <MyCatVerbs> Myoma: probably not that. :)
12:47:16 <mmorrow> tristes_tigres: excellent. what i found in particular interesting was the analysis of what situations implicit params'll be faster than unsafePerformIO (newIORef _) and vice-versa
12:47:23 <Myoma> what is it?
12:47:45 <saya> > take 10 [1,1,2,3,5..]
12:47:45 <lambdabot>  Parse error at "..]" (column 19)
12:48:05 <Myoma> > take 10 (extendSequence [1,1,2,3,5])
12:48:08 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
12:48:36 <dionoea> saya: \o/
12:48:41 <saya> :o /o\
12:50:33 <saya> !id test
12:50:34 <tutbot> test
12:50:35 <trofi> :t one
12:50:50 <saya> !quit
12:51:10 <RayNbow> @type curry Rice
12:51:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:51:19 <ddarius> saya: It is best to test these things in a new channel or via private messages.
12:51:24 <RayNbow> people in #haskell are starting to starve :p
12:51:31 <saya> sorry
12:51:38 <RayNbow> ...if lambdabot cannot supply spicy curry :p
12:52:01 <MyCatVerbs> Myoma: a proposed type system which has a generalization of Haskell's typeclasses.
12:52:21 <tristes_tigres> unsafePerformIO is dirty, evil and dishonest hack
12:52:23 <MyCatVerbs> Myoma: I can't remember who the heck wrote the paper, though. Still looking for it now.
12:54:42 <Mantaar> hey #haskell. Probably not the *right* place to ask, but the best I know of. when I have, say f(g)(h) and g and h can be _sets_ and I want the outcome to be f({a,b,c})({d,e,f'}) = {f(a)(d), f(a)(e), f(a)(f'), f(b)(e) ... }, is there any sort of explicit (set) calculus or logic class for this?
12:54:43 <mmorrow> tristes_tigres: heh, such colorful adjectives
12:55:15 <roconnor> Mantaar: liftM2 f
12:55:20 <Mantaar> sorry if this is a stupid question... in this case, I'd be glad to be pointed to resources or papers that should get me going...
12:55:32 <Myoma> It's call cartesian product
12:56:00 <roconnor> > liftM2 f [a,b,c] [d,e,f]
12:56:02 <lambdabot>  Add a type signature
12:56:21 <Mantaar> thanks roconnor, thanks Myoma. I don't yet need to implement it in haskell, just describe it formally (i have done it in prolog, though).
12:56:21 <roconnor> > liftM2 (+) [a,b,c] [d,e,f]
12:56:23 <lambdabot>  [a + d,a + e,a + f,b + d,b + e,b + f,c + d,c + e,c + f]
12:56:41 <Myoma> Mantaar: You don't implement it in Prolog
12:56:45 <roconnor> ah right, too many fs
12:56:47 <Mantaar> hehe. I love haskell!
12:56:52 <roconnor> > liftM2 f [a,b,c] [d,e,i]
12:56:54 <lambdabot>  Add a type signature
12:56:57 <tromp> > liftM2 (,) [a,b,c] [d,e,f]
12:56:57 <Mantaar> Myoma: it is already implemented?
12:57:00 <lambdabot>  [(a,d),(a,e),(a,f),(b,d),(b,e),(b,f),(c,d),(c,e),(c,f)]
12:57:01 <Myoma> yes
12:57:09 <pmurias> how should i generate unique identifiers from a an emit function, it takes the thing which should be emitted and the register it should be put in
12:57:19 <Myoma> it's a fundamental part of the execution model
12:57:46 <Mantaar> urgh... there I go thinking I was smart... wait, I'll ask in in #prolog, this is off topic here, I guess...
12:57:54 <saya> > quickCheck ( (\x -> a == show $ read a) :: Maybe Int -> Bool )
12:57:55 <lambdabot>  Couldn't match expected type `Expr'
12:58:06 <saya> > quickCheck ( (\a -> a == show $ read a) :: Maybe Int -> Bool )
12:58:08 <lambdabot>  Couldn't match expected type `Maybe Int'
12:58:20 <saya> > quickCheck ( (\a -> a == show $ read a) :: Int -> Bool )
12:58:22 <lambdabot>  Couldn't match expected type `Int'
12:58:33 <roconnor> > quickCheck ( (\a -> a == (show $ read a)) :: Int -> Bool )
12:58:34 <lambdabot>  Couldn't match expected type `String' against inferred type `Int'
12:58:37 <tristes_tigres> maybe Haskell 2 will save us from unsafe performIO ?
12:58:39 <Saizan_> ?type show
12:58:41 <lambdabot> forall a. (Show a) => a -> String
12:58:53 <roconnor> > quickCheck ( (\a -> a == (read $ show a)) :: Int -> Bool )
12:58:55 <lambdabot>  mueval: Prelude.read: no parse
12:58:55 <lambdabot> mueval: *** Exception: "<IO ()>"
12:59:19 <Saizan_> weird..
12:59:31 <tristes_tigres> @vixen unsafe
12:59:31 <lambdabot> you're turning me on :)
12:59:33 <thoughtpolice> tristes_tigres: if you've got a better idea, sure :]
12:59:54 <saya> yeah swapped  read and show :(!
13:00:06 <rwbarton> > quickCheck (const True)
13:00:07 <lambdabot>  mueval: Prelude.read: no parse
13:00:07 <lambdabot> mueval: *** Exception: "<IO ()>"
13:00:29 <mmorrow> @remember lambdabot <tristes_tigres> @vixen unsafe <lambdabot> you're turning me on :)
13:00:29 <lambdabot> I will never forget.
13:00:36 <tristes_tigres> thoughtpolice: Common block ! Like in fortran
13:00:48 <MyCatVerbs> Myoma: dammit. I'm sure I can remember reading this paper, but I can't seem to find it. This is annoying me now.
13:00:59 <Saizan_> oh, btw, you can't use quickCheck from >, there's a separate command @check
13:01:38 <tristes_tigres> common blocks rule
13:01:47 <mmorrow> MyCatVerbs: that happens to me constantly. i've started to just save everything there's even a remote chance i'll want to find again
13:02:13 <tristes_tigres> chicks like dangerous men
13:02:33 <tristes_tigres> and presumably unsafeperformIO
13:02:36 <mmorrow> i hear they dig scars too
13:02:53 <mmorrow> same with segfaults
13:03:29 <tristes_tigres> How about common blocks though ? Haskell could use some
13:04:03 <mmorrow> tristes_tigres: have you been following the discussion on haskell-cafe?
13:04:09 <Saizan_> what is a "common block"?
13:04:21 <tristes_tigres> mmorrow:no, where ?
13:04:57 <mmorrow> the many [Haskell-cafe] Re: [Haskell] Top Level <-
13:04:59 <mmorrow> which are here
13:05:03 <mmorrow> http://www.haskell.org/pipermail/haskell-cafe/2008-August/thread.html
13:05:05 <lambdabot> Title: The Haskell-Cafe August 2008 Archive by thread, http://tinyurl.com/5ajhp2
13:05:15 <tristes_tigres> Saizan: in Fortan, you can say Common /some_name/ var1, var2, var2
13:05:53 <skorpan> i wish i knew a bit more 'bout haskell, i wish i was a hacker...
13:05:56 <tristes_tigres> saizan: and in any scope you say that, var1 is the same variable
13:06:09 <tristes_tigres> ditto for var2, var3
13:07:59 <gwern> @check (const True)
13:08:00 <lambdabot>  "OK, passed 500 tests."
13:08:06 <Saizan_> tristes_tigres: i see, thanks
13:08:18 <MyCatVerbs> mmorrow: same, since PDFs and .ps.gzs are so small I just stuff them eternally into a directory in my ~.
13:08:34 <MyCatVerbs> mmorrow: but I can't find this in there, either. I'm not entirely sure what the Heck is up.
13:08:41 <Saizan_> gwern: do you have any idea of where read ends up being used in mueval?
13:08:48 <MyCatVerbs> mmorrow: did I *hallucinate* a paper or something? ;_;
13:09:00 <gwern> I dunno, I have some 19M pdfs hanging around
13:09:08 <gwern> Saizan_: at a guess, inside haskell-src-exts
13:09:31 <Saizan_> gwern: evil
13:10:21 * gwern shrugs. you guys bitched about the blacklist, so me and mmorrow put in haskell-src-exts. are you going to bitch about read now?
13:11:10 <Saizan_> surely :)
13:11:46 <gwern> bah humbug
13:11:56 <tristes_tigres> mmorrow: which thread you mean ?
13:12:59 <newsham> <- watches a haskell-cafe flame war devolve into a productive academic discussion on static analysis.
13:13:27 <dons> it was hardly a flamewar?
13:13:37 <Heffalump> newsham: which flamewar?
13:13:42 <Saizan_> gwern: if the bitching comes in the form of patches (assuming they don't break semantics) it's fine, no? (btw, i've sent you a couple today)
13:13:47 <newsham> haskell propoganda / haskell doesnt cause segv
13:13:48 <gwern> for -cafe it struck me as remarkably bitter and contentious
13:13:51 <BMeph> newsh: "Haskell: Where fights break out...into spontaneous talking!" ;)
13:14:03 <gwern> Saizan_: oh, you did?
13:14:49 <Saizan_> gwern: on some other glitches
13:15:51 <MyCatVerbs> gwern: sure, but 19M <<<<< 1GB, and I would happily spare a gig or two for papers. Most are only ~300k-1500k, though.
13:15:59 * lispy waits for someone to make an Oleg facts website
13:16:35 <monochrom> Perhaps there is still hope in the Haskell community.
13:16:43 <Leimy> nope
13:16:48 <gwern> MyCatVerbs: so you only care about sizes when they get into the gig range? a reasonable position I supose if you aren't transferring over the network a lot or on restricted devices
13:16:54 <Myoma> hey Agda has a haskell FFI
13:17:00 <mmorrow> MyCatVerbs: yep, in a dir in ~
13:18:07 <mmorrow> tristes_tigres: all the msgs with title [Haskell-cafe] Re: [Haskell] Top Level <-
13:18:59 <ddarius> gwern: How do you get bitterness?
13:19:30 <gwern> ddarius: all the comments about how noone is presenting a 'real' argument and being dogmatic
13:19:48 <gwern> not to mention all the dick waving about whose written more low-level stuff without global vars
13:21:00 <gwern> 'I wrote a linux device driver without global state' 'yeah, well I wrote a microkernel server with just handles passed around and no state' 'you both suck, cause how would you write an exokernel in haskell without global state?'
13:21:06 <dons> gwern: you should see the length of the code i've written without global variables.
13:21:12 <dons> enormously long code.
13:21:22 <dons> very wide lines too.
13:21:38 * gwern snorkles just a little bit
13:21:49 * Myoma deep sea dives a tad
13:21:58 <newsham> is gwern talking about the same thread?
13:22:04 <ddarius> newsham: No
13:22:34 <gwern> dons: were those lines all very hard?
13:22:38 <gwern> to write, I mean
13:23:27 <dons> very robust too. the code was rock hard.
13:23:33 <tristes_tigres> mmorow: just like I said, a common blocks from fortran is THE answer :-)
13:24:02 <gwern> dons: any chance you could whip it out for us to see?
13:24:03 <lispy> I've heard chicks dig that kind of code
13:24:11 <gwern> unless galois wants it nonpublic, I mean
13:24:24 <gwern> if your licenses don't swing that way I'd understand
13:24:41 <gpds> if i want to multiply an Int with a Double and return an Int is there an analogue to fromIntegral that I can use?
13:24:51 <dons> we tend to be a bit shy about showing it off in public. for fear of causing widespread panic
13:25:17 <Saizan_> gpds: round/truncate/floor/ceiling ..
13:25:35 <mmorrow> dons: yeah, that what those system transmitted viruses'll do
13:25:49 <gpds> well, ideally ill like to do that after the multiplication to prevent rounding errors
13:26:13 <lispy> gpds: then yes, you need to convert the Int to a double before the multiplication
13:26:28 <gpds> thanks
13:26:32 <Saizan_> ?type \x y -> round $ fromIntegral (x :: Int) * (y :: Double)
13:26:33 <lambdabot> forall b. (Integral b) => Int -> Double -> b
13:26:55 * Leimy thinks dons and gwern aren't talking about code
13:29:02 <gwern> Leimy: we're just discussing basic software practices - like who goes in for kinky stuff like FFI and who doesn't
13:29:26 <gwern> not that I'm judging dons or anything :) diff'rent strokes for differnet folks
13:30:05 <gwern> we all have different problems to solve, youknowwhatimean Leimy?
13:30:19 <Myoma> are you arguing to add global variables to haskell?
13:30:29 * BMeph thinks dons and gwern are, however, talking *in* code
13:30:59 * tristes_tigres just imagined a type system virus
13:31:14 * BMeph thinks gwern spends too much time surfing the differnet
13:32:43 <Leimy> gwern: yes.
13:32:44 <Leimy> totally
13:33:05 <Leimy> I'm wrapping up the main bits of a fairly large system done in Erlang that I've been doing this summer.
13:33:44 <Leimy> Haskell might have been a contender, if I could have had something like Erlang's JInterface :-)
13:34:04 <Leimy> also, it's pretty much a high-concurrency system...
13:34:16 <Leimy> lots of I/O too.
13:38:22 <tristes_tigres> This whole discussion about global variables seems to suggest that Haskell is not entirely thought-out yet
13:39:37 * Myoma doesn't get it -- what's a global variable
13:40:36 <Leimy> Uhm
13:40:47 <Leimy> MY haskell has no variables.
13:41:00 <lament> mine neither
13:41:06 <Leimy> I've got some values :-)
13:41:10 <Leimy> and I've got some names
13:41:13 <Leimy> but they don't vary :-)
13:41:46 <idnar> Leimy: what about your function parameters? :P
13:41:50 <skorpan> so they're like const*? oh i get it!
13:41:52 <lament> ignoring modules, haskell only has one namespace
13:41:58 <lament> for variables
13:41:58 <Leimy> idnar: nope... they're values :-)
13:42:03 <lament> so all variables are global
13:42:09 <lament> (ok not really :D)
13:42:33 <Leimy> all variables are "contained"
13:42:42 <lament> one namespace for arguments, and one for global variables
13:42:44 <lament> like id
13:42:44 <MyCatVerbs> Myoma: aha! Found it, finally. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.1932
13:42:45 <lambdabot> Title: A Second Look at Overloading In Proc. FPCA'95 Conf. on Functional Programming La ...
13:42:45 <idnar> Leimy: variable != mutable
13:42:57 <MyCatVerbs> Myoma: I didn't just hallucinate that paper! :)
13:43:00 <lament> idnar: they're synonyms :)
13:43:01 <Saizan_> variable /= mutable reference
13:43:03 <idnar> Leimy: function parameters vary across different uses of the function
13:43:05 <Leimy> idnar: it depends on the audience :-)
13:43:07 <Myoma> thank you MyCatVerbs :)
13:43:09 <idnar> Leimy: that's why they're called variables :P
13:43:25 <lament> is "id" a variable?
13:43:26 <Leimy> idnar: each call to a pure function may as well be a table lookup :-)
13:44:32 <Saizan_> lament: no
13:44:42 <Saizan_> (if you mean Prelude.id)
13:45:56 <Leimy> idnar: if you think of everything as a series of function constructors, you don't really have variables, you just have an assload of functions :-)
13:46:32 <lament> Saizan_: what is it, then?
13:46:40 <Leimy> kind of like currying.
13:46:42 <MyCatVerbs> Myoma: anyway. This one is really cool because, amongst other things, it gets rid of the problems we have with which methods should be in which classes. It also AFAIK allows you to do things that're just about as handy as structural typing. :)
13:46:51 <Saizan_> lament: a constant, of course! ;)
13:47:15 <Leimy> in other words, there is no spoon... it is you that bends
13:47:17 <Leimy> :-)
13:47:30 <djsiegel_> I have to chain a series of functions a -> a    what's a good way to do it? I am chaining a series of String -> String, then applying the results to a template string: http://hpaste.org/10014
13:47:47 <djsiegel_> and I don't like doing it the way I am
13:47:50 <MyCatVerbs> djsiegel_: one way is to use the Monoid interface for Endo.
13:48:02 <djsiegel_> I don't know what that means!
13:48:16 <Myoma> my computer is crashing when I load PDFs :/
13:48:31 <mmorrow> > foldr (.) id (replicate 10 show) $ "asdf"
13:48:33 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:48:34 <Myoma> this is rubbish, I must have it fixed
13:48:37 <MyCatVerbs> djsiegel_: another is just foldr' (.) id, or foldl' (.) id, depending on which way you want to go. :)
13:48:38 <mmorrow> > foldr (.) id (replicate 3 show) $ "asdf"
13:48:39 <lambdabot>  "\"\\\"\\\\\\\"asdf\\\\\\\"\\\"\""
13:48:52 <djsiegel_> MyCatVerbs, yeah, that's what I'm doing
13:48:56 <djsiegel_> in my hpaste
13:49:03 <mmorrow> @type foldr (.) id :: [String -> String] -> (String -> String)
13:49:04 <lambdabot> [String -> String] -> String -> String
13:49:28 <Myoma> @type mconcat :: [String -> String] -> (String -> String)
13:49:29 <lambdabot> [String -> String] -> String -> String
13:49:48 <Saizan_> djsiegel_: foldr (.) id [f,g,h] == f . g . h . id, if this helps
13:50:10 <mmorrow> > foldr (.) id [f,g,h]
13:50:11 <lambdabot>      Overlapping instances for Show (a -> a)
13:50:11 <lambdabot>       arising from a use of `sho...
13:50:13 <djsiegel_> yes, I know, as I said, I am using that technique already
13:50:20 <mmorrow> > foldr (.) e [f,g,h]
13:50:21 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `Expr'
13:50:40 <mmorrow> > foldr (|.|) e [f,g,h]
13:50:41 <lambdabot>  mueval: Prelude.read: no parse
13:50:45 <mmorrow> > foldr o e [f,g,h]
13:50:47 <lambdabot>  Couldn't match expected type `a -> b -> b'
13:50:47 <Myoma> I think it's a hardware problem
13:50:51 <mmorrow> ahhhh!
13:50:55 <Myoma> but I am used to blaming software when things don't work
13:50:58 <Saizan_> djsiegel_: why don't you like it?
13:51:14 <Myoma> djsiegel_: mconcat works
13:51:36 <djsiegel_> look at my hpaste -- seems overcomplicated for applying replacements [(String, String)] to a template string
13:51:38 <mmorrow> > foldr f c (replicate 10 x)
13:51:39 <lambdabot>  f x (f x (f x (f x (f x (f x (f x (f x (f x (f x c)))))))))
13:51:41 <djsiegel_> maybe I need a state monad
13:51:50 <Myoma> what's your paste
13:51:56 <djsiegel_> http://hpaste.org/10014
13:52:12 * Heffalump is trying to find a monad tutorial that explains state, do-notation, and not too much else. Anyone know of one?
13:52:44 <Myoma> djsiegel_: What is this 'do' for?
13:52:58 <djsiegel_> :t forM
13:52:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:53:02 <MyCatVerbs> djsiegel_: http://hpaste.org/10014#a1
13:53:37 <djsiegel_> yeah, first is better than these
13:53:47 <Myoma> :t forM replacements $ \(this, that) -> do return $ \body -> replace body this that
13:53:54 <djsiegel_> I think I'll use a StateT (a -> a) IO
13:54:05 <Myoma> djsiegel_: Is this in IO?
13:54:08 <djsiegel_> yeah
13:54:12 <Myoma> djsiegel_: Why
13:54:13 <djsiegel_> I don't need the do
13:54:13 <MyCatVerbs> djsiegel_: hang on, do you need the monad at all for this?
13:54:20 <djsiegel_> no
13:54:44 <djsiegel_> I am just in main, but I was thinking of putting it in a StateT
13:54:49 <djsiegel_> or State, rather
13:54:59 <Myoma> why would you use state?
13:55:07 <djsiegel_> to build a String -> String
13:55:15 <Myoma> from what?
13:55:22 <djsiegel_> from other String -> String
13:55:31 <MyCatVerbs> djsiegel_: http://hpaste.org/10014#a3
13:55:32 <Myoma> there's no state in that
13:55:33 <djsiegel_> I guess that's overkill
13:55:43 <Leimy> nice
13:55:46 <Toxaris> foldr (\(this, that) body -> replace body this that) replacements "TEMPLATE STRING"
13:55:46 <Myoma> (String -> String) -> (String -> String) ?
13:55:51 <Saizan_> foldl' (\body (this,that) -> replace body this that) "TEMPLATE STRING" replacements
13:56:04 <MyCatVerbs> Toxaris: d'oh. Missed that. :/
13:56:12 <MyCatVerbs> djsiegel_: Heck, drop the "let foo =" from those and just have them as top-level identifiers.
13:56:18 <Saizan_> Toxaris: replacements goes last :)
13:56:18 <Leimy> Isn't that just mapfold
13:56:20 <Leimy> l
13:56:22 <Leimy> hmmm
13:56:24 <djsiegel_> MyCatVerbs, \(this, that) body -> ... will curry?
13:56:36 <Toxaris> Saizan_: yeah :)
13:56:36 <djsiegel_> I did not know that
13:56:48 <Leimy> it's just a tuple :-)
13:56:51 <djsiegel_> I don't know why I didn't realize that
13:56:57 <Toxaris> djsiegel_: no currying involved
13:57:03 <MyCatVerbs> djsiegel_: yes. You can write it as (\(this, that) -> (\body -> ...)) if you want to make it more clear that that's what's going on though, if you want to. It doesn't make any difference either way.
13:57:23 <Toxaris> djsiegel_: oh ok yeah, same currying with \ as with let or top level identifiers
13:57:37 <djsiegel_> ok, yeah, earlier I was writing \(this, that) -> \body -> ... when I switched for forM from map
13:57:46 <djsiegel_> *switched from map to forM
13:57:51 <djsiegel_> yeah, this is nicer
13:58:03 <MyCatVerbs> djsiegel_: actually, now that you mention it, if I were going to wave this in front of someone who wasn't particularly Haskell-happy, I'd write it as \(this, that) -> \body -> ..., on purpose in order to make it clear precisely where I intend to curry it.
13:58:20 <djsiegel_> is -> rassoc?
13:58:27 <Myoma> yes
13:59:02 <MyCatVerbs> djsiegel_: lambda expressions always extend as far to the right as possible. But I'd put the brackets in too, because I like to be certain. :)
13:59:43 <MyCatVerbs> For certain values of "certain". Specifically, values that include "the code must still make sense even when I'm drunk." :)
14:00:46 <djsiegel_> ok, now I want to apply fold1 (.) replacementFs to "TEMPLATE STRING" to a fixed point :)
14:01:01 <djsiegel_> how do I do that?
14:01:02 <Myoma> :t fold1
14:01:27 <Saizan_> :t Datal.List.foldl1
14:01:29 <Myoma> djsiegel_: iterateProgress foo bar
14:01:40 <Saizan_> @bot
14:01:40 <lambdabot> :)
14:01:42 <djsiegel_> I love you guys.
14:01:54 <MyCatVerbs> Myoma: iterateProgress?
14:02:05 <MyCatVerbs> @index iterateProgress
14:02:05 <lambdabot> bzzt
14:02:14 <djsiegel_> hoogle no findie
14:02:26 <Saizan_> it's left as an exercise to the reader :)
14:02:33 <Myoma> iterateProgress f x = let fx = f x in if x == fx then x else iterateProgress f fx
14:02:40 <djsiegel_> haha, easy enough
14:03:01 <MyCatVerbs> Bah. iterateProgress f v = eff (iterate f) where { eff (a:b:more) = if a == b then a else eff (b:more) }
14:03:24 <MyCatVerbs> Myoma: damn, I like yours better. :(
14:04:12 * Myoma wants a working computer
14:04:31 <MyCatVerbs> Myoma: what are you typing on, a dead badger with Linux on it?
14:05:10 <Myoma> MyCatVerbs: I think the graphics hardware is broken
14:05:26 <MyCatVerbs> Oh, bummer. No Quake3? :(
14:05:34 <Myoma> worse,
14:05:42 <Toxaris> @type \f -> head . head . filter (not . null . drop 1) . Data.List.group . iterate f
14:05:43 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
14:05:46 <BMeph> So, "iterateProgress" is just a mouthy name for "fix"? :)
14:05:57 <Myoma> no PDF or postscript and it crashes very often
14:06:01 <Myoma> BMeph: n
14:06:20 <Myoma> it's only sometimes the same as fix
14:06:28 <Toxaris> BMeph: they use different meanings of equality
14:06:40 <Toxaris> BMeph: iterateProgress uses Eq, while fix uses isAsDefinedAs
14:06:58 <Toxaris> e.g. iterateProgress (* 0) 5 = 0
14:08:10 <MyCatVerbs> iterateProgress (1:) will fail. fix (1:) is an infinite, despicably boring list.
14:08:12 <Toxaris> @type group -- why not Data.List.group in scope?
14:08:14 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:08:40 <MyCatVerbs> > groupBy (==) [1,2,3,3,4,5,5]
14:08:42 <lambdabot>  [[1],[2],[3,3],[4],[5,5]]
14:08:56 <MyCatVerbs> > group [1,2,3,3,4,5,5]
14:08:58 <lambdabot>  [[1],[2],[3,3],[4],[5,5]]
14:09:15 <MyCatVerbs> Toxaris: bug in \bot, apparently.
14:09:15 <Toxaris> @type Data.List.group
14:09:16 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
14:09:20 <Toxaris> @type group
14:09:22 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:10:27 <Toxaris> lambdabot: how to report bugs in you?
14:10:42 <Myoma> there are too many bugs
14:11:22 <Toxaris> @faq can \bot be bug-free?
14:11:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:12:45 <dons> it's a study in a project without technical leadership. :)
14:13:04 <MyCatVerbs> dons: it's lead like the USSR army.
14:13:57 <MyCatVerbs> dons: from the rear, that is. Every time the commissars get pissed off enough, they start shouting orders and shooting peasants until something gets done.
14:14:31 * MyCatVerbs slaps himself for using such disgraceful language in a public (hopefully friendly, no less!) forum. :(
14:14:50 <dons> if only we had commissars.
14:16:03 <EvilTerran> @faq could i adapt lambdabot into commissarbot?
14:16:03 <lambdabot> The answer is: Yes! Haskell can do that.
14:16:31 <MyCatVerbs> Er, we do. The top-ranking commissar of lambdabot is Cale. Every time *he* gets annoyed enough by the bugs, lambdabot gets beaten until it misbehaves less. :)
14:16:33 <noteventime> Has anyone had any experience with Mercury?
14:16:51 <Myoma> if you didn't know #mercury exists
14:17:17 <noteventime> Myoma: With five people :p
14:17:17 <MyCatVerbs> Myoma: I'd be surprised if they were as nice as the people in #haskell, though. ;)
14:17:35 <Myoma> MyCatVerbs: They are all as nice as the people in #haskell
14:17:35 <MyCatVerbs> noteventime: well there was this one time I swallowed a drop of the stuff, after which monad tutorials stopped making sense for me, but other than that, no. ;)
14:17:46 <MyCatVerbs> Myoma: oh, cool. ^^
14:17:48 <Myoma> MyCatVerbs: (because they are all in #haskell)
14:18:01 <MyCatVerbs> Myoma: you're kidding me, srsly?
14:18:07 <noteventime> Since Haskell is what I'm interested in at the moment, I was interested if anyone in here had any experience with it
14:18:28 <EvilTerran> MyCatVerbs, you mean monad tutorials once made sense for you? O.o
14:18:38 <MyCatVerbs> Myoma: hot diggity! You're right! :)
14:18:38 <EvilTerran> what did you swallow a drop of to get that effect?
14:18:51 <MyCatVerbs> EvilTerran: sleep deprivation. ;P
14:19:14 <noteventime> Dunno, Monad tutorials have always seemed to be more confusing than informative :)
14:19:24 <EvilTerran> "monads are like fractals, swooping and diving through the air! they have faces!"
14:19:35 <noteventime> I found it a lot easier after I read some very basic category theory
14:19:52 <MyCatVerbs> EvilTerran: (actually, they never have. Just using them in practice and reading "All About Monads" worked far better than all the stupid monad tutorials put together. Oh and someone (I think it was dons) being nice enough to explain how do notation desugars.
14:20:03 <EvilTerran> noteventime, maybe you should write a monad tutorial including that basic category theory
14:20:09 <pjdelport> there should be a monad tutorial tutorial, that explains how the elaborate metaphors relate to monads
14:20:14 <EvilTerran> "monads as a basic category-theoretic concept"
14:20:26 <noteventime> EvilTerran: As soon as I feel more comfortable with it :)
14:20:37 <MyCatVerbs> EvilTerran: BTW, did I mention that I went through a phase where I was using >>=, >> and return happily, but couldn't remember how to use do notation at all? I wrote some *really* unreadable code back then. ^_^)
14:20:56 <EvilTerran> MyCatVerbs, you didn't. that's... Interesting
14:21:00 <Myoma> >>= \x ->
14:21:04 <Myoma> vs' ;
14:21:17 <MyCatVerbs> x <- ... ;
14:21:28 <idnar> monads are like onions
14:21:40 <Philonous> Monad tutorials are for people who want to become nuclear waste disposers in space suits ^^
14:21:46 <MyCatVerbs> idnar: not cakes? :)
14:21:48 <EvilTerran> idnar, they make your eyes water when you try to dissect them?
14:22:00 <idnar> MyCatVerbs: what about parfait? everybody likes parfait!
14:22:18 <idnar> EvilTerran: no, they get all brown and wrinkly when you leave them out in the sun ;)
14:22:46 <EvilTerran> monads are like stroganoff - no-one's really sure what's going on in there, but the result's really quite nice
14:22:48 <MyCatVerbs> idnar: and they start sproutin' lil' white hairs. :)
14:23:04 <MyCatVerbs> EvilTerran: oh I'm pretty certain Moggi and Wadler know what's going in on there.
14:23:10 <EvilTerran> TWAJS
14:23:28 <Toxaris> monads are to onions what monads are to nuclear waste. sounds circular, but who cares with non-strict semantics
14:23:36 <EvilTerran> hehe
14:23:39 <MyCatVerbs> EvilTerran: I'm not sure whether anyone bar Wadler and a few pals understand how Moggi understands them, though. But Wadler's monad tutorial is certainly nice. :)
14:23:46 <Myoma> what about Arrows
14:23:48 <Myoma> ?
14:24:02 * EvilTerran likes "you could have invented monads"
14:24:24 <tristes_tigres> Yeah. monads are a peace of cake compared to arrows
14:24:37 <Myoma> arrows are like ?
14:24:41 <Toxaris> but arrows are so much easier
14:24:42 <Myoma> rocket powered banana chainsaws ?
14:24:51 <EvilTerran> actually, in general, i seem to understand sigfpe's writing really easily
14:25:03 <Toxaris> (not to use, but to understand)
14:25:28 <EvilTerran> my main difficulty with arrows is the desugaring confuses the hell out of me
14:25:43 <Heffalump> it's non-local, too
14:25:45 <EvilTerran> the unsweetened version seems almost trivial
14:26:03 <Myoma> there aren't any arrows which actually let you do anything :/
14:26:12 <Heffalump> Myoma: AFRP
14:26:14 <Heffalump> (Yampa)
14:26:31 <tristes_tigres> EvalTerrain: sugared arrows are better than poisoned arrows
14:26:41 <Cale> MyCatVerbs: Of course, I really would like to receive more patches from other annoyed lambdabot users to help me whip the bugs into submission :)
14:26:41 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
14:26:49 <Toxaris> EvilTerran: yeah, but understanding proc notation is part of using, not understanding, imho
14:27:06 <MyCatVerbs> Cale: entirely sympathetic to your cause. :)
14:27:11 <Myoma> why not add vits of lambdabot into preflex
14:27:12 <Saizan_> EvilTerran: maybe the sugar proposed by wadler is better, but i'm not aware of an implementation
14:27:51 <EvilTerran> Saizan_, do you have a link? i haven't heard about that
14:28:00 <Saizan_> Cale: btw, i think you lost my FIX @type patch when deleting your repo yesterday, so i've resent it to you
14:28:19 <Cale> oh... sorry about that if true, I'll apply it again :)
14:28:29 <Myoma> doesn't mueval fix the unicode problems?
14:28:50 <Capso> Cale: Is lambdabot coded in Haskell?
14:28:55 <Saizan_> EvilTerran: http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf
14:28:58 <lambdabot> Title: The Arrow Calculus (Functional Pearl)
14:29:04 <Cale> Capso: yep
14:29:06 <EvilTerran> ty
14:29:37 <Cale> Capso: It's sort of crazy though, since it's been written organically by patches from many users ;)
14:29:47 <Capso> ah
14:30:09 <Capso> Cale: Linux kernel scaled down! ;)
14:30:17 <mmorrow> strict vs. lazy state monad benchmark: http://hpaste.org/10016
14:31:23 <chrisdone> During interactive linking, GHCi couldn't find the following symbol: base_DataziTuple_Z70T_con_info or base_DataziTuple_Z70T_static_info
14:31:26 <chrisdone> anyone recognise this error?
14:32:21 <gwern> Saizan_: you said you sent me mueval patches?
14:32:26 <gwern> today, that is?
14:32:30 <Saizan_> yes
14:32:43 <Saizan_> you didn't get them?
14:33:08 <gwern> hm. I cannot seem to find them. they haven't shown up in my inbox, they're not in spam, and a gmails earch doesn't give me anything
14:33:29 * Saizan_ resends and then vanishes
14:33:39 <Cale> ... uh oh, lambdabot-utils is dependency-schizophrenic now
14:33:45 <Cale> cabal: dependencies conflict: lambdabot-utils-4.2 requires bytestring
14:33:45 <Cale> ==0.9.0.1.1 however
14:33:45 <Cale> bytestring-0.9.0.1.1 was excluded because lambdabot-utils-4.2 requires
14:33:45 <Cale> bytestring ==0.9.1.2
14:34:02 <Capso> Cale: How is your Japanese pronunciation, by the way?
14:34:02 <gwern> zomg
14:34:06 <Saizan_> gwern: sent to gwern0 on gmail
14:34:22 <Cale> Capso: I don't know. I don't have any Japanese people to rate it :)
14:34:31 <Cale> Capso: I think it's okay :)
14:34:46 <Capso> Have you taken any classes?
14:34:50 <Cale> Nope.
14:34:56 <Peaker> The regexp \w+ (at|on) (gmail|yahoo|...) will probably have a lot of hits on various web logs
14:35:03 <gwern> ah, there we go
14:35:23 <chrisdone> Morph.o: In function `s2uS_info':
14:35:24 <chrisdone> (.text+0x14f5): undefined reference to `base_DataziTuple_Z70T_con_info'
14:35:33 <Cale> chrisdone: --make
14:35:34 <Cale> ?
14:35:38 <chrisdone> why would something in Data.Tuple not be found?
14:35:40 <chrisdone> Cale: sure is!
14:35:54 <Cale> hmm
14:35:59 <sjanssen> Data.Tuple is in base anyway
14:36:09 <Cale> Hmm... that's true.
14:36:16 <mmorrow> chrisdone: you only have one base package, right?
14:36:16 <Cale> Maybe bad temporary files?
14:36:40 <chrisdone> mmorrow: umm
14:36:49 <Cale> (like, did you recently upgrade ghc?)
14:37:00 <mmorrow> chrisdone: ghc-pkg list base
14:37:04 <chrisdone> mmorrow: ghc-pkg list | grep base shows base-3.0.2.0
14:37:28 <mmorrow> chrisdone: hmm, what ghc are you using??
14:37:32 <chrisdone> Cale: I haven't, no
14:37:42 <chrisdone> mmorrow: 6.8.3
14:38:05 <mmorrow> chrisdone: hmm, what are you building?
14:38:09 <chrisdone> I'll paste it
14:39:00 <Cale> I wish cabal gave me a little more detail regarding *why* this package needs conflicting versions of bytestring.
14:39:20 <chrisdone> mmorrow: do you think the size of the function is causing a problem? http://paste.lisp.org/display/66078
14:39:25 <Peaker> it was difficult to figure out, it should be difficult to...
14:39:25 <Myoma> why is (# x,y #) faster than (x,y)?
14:39:29 * Cale browses hackage to trace the dependencies out.
14:39:36 <Capso> Cale: How would you pronounce Eigo?
14:39:42 <chrisdone> mmorrow: before I caused ghci to crash with an out of memory error.. presumably due to such large error outputs or something..
14:40:03 <Cale> Capso: I would pronounce each character as if separately.
14:41:04 <Capso> 'eygo'
14:41:12 <Peaker> hai
14:41:14 <Cale> え　い　ご
14:41:15 <bjrn> What about Eizo? I love their monitors.
14:41:20 <chrisdone> mmorrow: test case; load into ghci and then try: runPeg parse ""
14:41:23 <roconnor> snd (# undefined, 7 #) is undefined, while snd (undefined, 7) is 7
14:41:28 <mmorrow> chrisdone: whoa, that's pretty cool..a single massive mdo block. yeah, somethings probably blowing somwhere, i don't even know
14:41:44 <roconnor> I think
14:41:46 <mmorrow> what it could be though :/
14:41:55 <Cale> Myoma: It's not a pair of pointers to values, it's a physical pair of values.
14:42:23 <Capso> Peaker: Ah, do you speak the language as well?
14:42:35 <Cale> Myoma: This of course has some disadvantages as well.
14:42:42 <Myoma> Can't it be optimized?
14:42:51 <Cale> Myoma: Can't what be?
14:42:51 <chrisdone> mmorrow: hrm, thanks anyhoo
14:42:54 <Peaker> Capso: hai. (Not really :-)
14:42:55 <Myoma> (x,y)
14:43:25 <Cale> Myoma: Well, pairs need boxing to support lazy semantics.
14:43:26 <mmorrow> chrisdone: let me know anything you find out regarding the mdo and performance, i'm thinking of using that method now ...
14:44:00 <chrisdone> mmorrow: sure
14:44:06 <Cale> Myoma: As roconnor pointed out (undefined, 7) is not the same as undefined.
14:44:12 <Capso> Peaker: Nihongo hanashimasu? ;)
14:44:16 <mmorrow> Myoma: from what i understand, and each args in the unboxed tuple gets put in a register (if there are enough)
14:44:23 <roconnor> I'd be surprised if mdo is the problem.
14:44:33 <mmorrow> s/and each arg.../each arg.../
14:44:36 <Myoma> > (\(x,y)->y)(undefined,3)
14:44:38 <Capso> Peaker: whoops: Nihongo o hanashimasu? ;)
14:44:38 <lambdabot>  3
14:44:46 <roconnor> mdo is moderately simple syntatic sugar
14:44:56 <Myoma> okkk
14:45:13 <Peaker> Capso: hai (Sorry, its the only word I know :-)
14:45:22 <Capso> Peaker: haha
14:45:46 <mmorrow> roconnor: i was thinking because it's not extensively used, and because chris's is somewhat of an extreme use of it, something might be breaking under the stress (but /what/ i've no friggin clue)
14:45:56 <thoughtpolice> join #ghc
14:45:59 <mmorrow> (and that's just my wild guess which is most likely wrong)
14:46:18 <RayNbow> <Cale> え　い　ご <-- hiragana in #haskell? :p
14:46:33 <Cale> dcoutts_: Is there any way I can get cabal to tell me why it believes two incompatible versions of bytestring are needed to build a given package?
14:47:28 <Cale> レインボー: はい
14:47:30 <chrisdone> I'll try a small test case
14:47:32 <mmorrow> chrisdone: oh, what is Text.Parsers.Frisby
14:47:33 <mmorrow> ?
14:47:39 <chrisdone> mmorrow: http://repetae.net/computer/frisby
14:47:41 <roconnor> mmorrow: that is possible.
14:47:45 <lambdabot> Title: Text.Parsers.Frisby
14:48:03 <chrisdone> it's supposed to be used with mdo, according to the docs: http://repetae.net/computer/frisby/#v%3AnewRule
14:48:04 <lambdabot> Title: Text.Parsers.Frisby
14:48:13 <gwern> Cale: upgrade cabal and turn on verbose messages?
14:48:20 <RayNbow> Cale: my katakana is not so good, but I managed to read it :p
14:48:34 <chrisdone> maybe I could split into separate mdos..
14:49:22 <chrisdone> yeah, with a smaller test case it doesn't fail
14:49:48 <Cale> hey, what the...
14:49:50 <chrisdone> the size of the mdo is probably causing the weird error
14:49:55 <mmorrow> chrisdone: does a small test case importing T.P.Frisby work without the linker error?
14:49:59 <Cale> Installing lambdabot-utils separately worked...
14:50:01 <chrisdone> mmorrow: yeah, I just tried it
14:50:18 <Cale> But not when it was to be installed as part of dependency chasing from lambdabot?
14:50:19 <Cale> ...
14:50:20 <newsham> how do you get minBound for a parametric type?
14:50:27 <chrisdone> mmorrow: *Morph GOA> runPeg (newRule anyChar) "a"
14:50:27 <chrisdone> 'a'
14:50:39 <chrisdone> mmorrow: and with an mdo, too
14:50:39 <Cale> oh well
14:50:40 <mmorrow> chrisdone: weird, maybe it /is/ the massive mdo.
14:50:40 <gwern> Cale: I've been pondering uploading lambdabot to hackage so we can let cabal-install handle the bytestring issue
14:50:45 <RayNbow> > minBound :: Int
14:50:51 <newsham> Int isnt parametric
14:50:55 <dmwit> Hello all!
14:50:55 <mmorrow> chrisdone: what about a small test which uses an mdo?
14:50:56 <Cale> gwern: I've been using cabal install to build it, anyway.
14:50:56 <RayNbow> oh
14:51:05 <chrisdone> mmorrow: I'll paste one that works
14:51:18 <newsham> for example.   Int -> Maybe a
14:51:19 <Cale> gwern: (since the homedir version)
14:51:20 <gwern> I really ought to switch my aliases to cabal install and not runhaskell
14:51:25 <newsham> minBound :: a
14:51:27 <mmorrow> chrisdone: maybe you just found a bug
14:51:40 <Myoma> use Bounded a => Int -> Maybe a
14:51:48 <Myoma> which is what would be infered
14:51:49 <chrisdone> mmorrow: http://paste.lisp.org/display/66078#1
14:51:50 <newsham> ok, now how do I use minBound?
14:51:51 <Cale> Don't even need to alias anything, unless plain 'cabal install' is too long to type :)
14:51:55 <chrisdone> mmorrow: seems so
14:52:17 <dmwit> newsham: undefined `asTypeOf` ?
14:52:34 <gwern> > if (length "cabal install") > 2 then "Too Long!" else "Just right"
14:52:39 <dmwit> :t (fmap (minBound `asTypeOf`) .)
14:52:54 <rwbarton> chrisdone: perhaps mdo is desugared into mfix and a tuple, and ghc doesn't support 60-tuples or whatever
14:53:36 <chrisdone> rwbarton: ahhh, good point. let me reduce it slightly...
14:53:42 <lambdabot>  mueval: Prelude.read: no parse
14:53:42 <lambdabot> mueval: GhcException mueval: interrupted
14:53:42 <lambdabot> Terminated
14:54:22 <dmwit> newsham: \bot didn't respond, but it's :: Bounded b => (a -> Maybe b) -> (a -> Maybe b), anyway.
14:54:33 <dmwit> newsham: But you shouldn't need to do that, what's the bigger picture?
14:55:15 <newsham> (Monad m, Enum a, Bounded a) => Int -> m a
14:55:28 <chrisdone> newsham: yes. if I remove five or so lines, it no longer fails. I am going to produce a simple test case file of mdo with the same number of statements. maybe I can send a bug report (or look for one)
14:55:32 <dmwit> Okay, replace fmap with liftM, then. =)
14:55:34 <humasect> do-syntax can be unhealthy=)
14:55:43 <newsham> mToEnum n | min <= n && n <= max = return (toEnum n)
14:56:16 <newsham> min and max need to be integers based on minBound/maxBound of the appropriate type
14:56:29 <dmwit> aaa
14:56:42 <newsham> i have a solution using {-# LANGUAGE ScopedTypeVariables #-}
14:56:54 <newsham> wondering if there's a more portable solution
14:56:57 <dmwit> How about fromEnum minBound?
14:57:05 <dmwit> :t fromEnum minBound
14:57:12 <lambdabot>     Ambiguous type variable `a' in the constraints:
14:57:14 <newsham> yah, but then which minBound will it use?
14:57:18 <ziman> :t fromEnum
14:57:18 <lambdabot>       `Enum a' arising from a use of `fromEnum' at <interactive>:1:0-16
14:57:22 <newsham>    where min = fromEnum (minBound :: a)
14:57:23 <Ogedei> not entirely on topic maybe, but if I want to understand the notation and vocabulary people use when describing type systems and proving soundness, what book should I read?
14:57:24 <lambdabot> forall a. (Enum a) => a -> Int
14:57:35 <dmwit> newsham: Yep, then you get into the `asTypeOf` or scoped type variables thing.
14:57:37 <dmwit> bummer
14:57:54 <newsham> if i was to use asTypeOf, where do i get a value of the right type?
14:57:57 <newsham> its the return type.
14:58:11 <newsham> i guess another 'let'
14:58:13 <dmwit> yeah
14:58:25 <newsham> ?hoogle asTypeOf
14:58:25 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:58:31 <newsham> i'll go that route.
14:58:59 <Myoma> oh you can't use < with Enums
14:58:59 <mmorrow> chrisdone: i got it: http://hpaste.org/10017
14:58:59 <bjrn> Ogedei: I like "Types and Programming Languages" this far, however augustss mentioned there are some factual errors in it. Don't know what these errors are tho.
14:59:14 <dmwit> Myoma: Many Enums are also Ord, why do you ask?
14:59:15 <chrisdone> mmorrow: nice work
14:59:20 <mmorrow> chrisdone: maybe that lib was expecting jhc?
14:59:44 <chrisdone> mmorrow: or expected me to use separate functions :P
14:59:49 <RayNbow> > liftT2 (+) (1,2) (3,4)
14:59:50 <lambdabot>  (4,6)
14:59:53 <mmorrow> chrisdone: ha, or that :)
14:59:58 * RayNbow pets lambdabot
15:00:05 <dmwit> :t liftT2
15:00:06 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => (b -> a b' c') -> (b, b) -> a (b', b') (c', c')
15:00:15 <newsham> thanks dmwit.
15:00:28 <ziman> hy does hpaste have the signature (a -> b) -> f a -> f b ? :)
15:00:34 <ziman> *why
15:00:41 <dmwit> why not? =)
15:00:42 <RayNbow> dmwit: http://hpaste.org/9986
15:01:05 <chrisdone> mmorrow, newsham: thanks for the help. I will split up the code into seperate functions
15:01:15 <ziman> just looking for some symbolism behind that :)
15:01:46 <dmwit> :t Data.Typeable.everywhere
15:01:46 <lambdabot> Not in scope: `Data.Typeable.everywhere'
15:01:52 <dmwit> :t Data.Generics.everywhere
15:01:53 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
15:02:05 <dmwit> ...whoa
15:02:24 <liesen> how do i read an Int64 from a Handle?
15:02:27 <RayNbow> hmm, didn't notice mmorrow's annotation
15:02:40 * mmorrow isn't clear on where the tuples are coming from in the first place
15:02:43 <dmwit> liesen: Is it text or binary?
15:02:49 <liesen> binary
15:03:00 <dmwit> Check out the Get and Put monads in the ByteString library.
15:03:28 <mmorrow> RayNbow: soooo useful cuz it's soooo little effort
15:03:36 <dmwit> liesen: (i.e. you may have to write that particular read function yourself)
15:03:44 <liesen> okay thanks
15:03:52 <Myoma> newsham,
15:03:53 <Myoma> mToEnum x = do result <- return $ toEnum x
15:03:53 <Myoma>                guard (between (minBound,maxBound) result)
15:03:53 <Myoma>                return result
15:03:56 <Myoma> isn't right ?
15:04:05 <dmwit> liesen: If you have control over the format, consider sending and receiving using "read" and "show" instead.
15:04:14 <Myoma> :: (MonadPlus m, Enum a, Bounded a, Ord a) => Int -> m a
15:05:02 <RayNbow> mmorrow: hmm, it's not portable... does it work in Hugs? (or should I force someone to use GHC? :p)
15:05:06 <dmwit> Myoma: No, it isn't right.
15:05:18 <dmwit> Myoma: If you give an out-of-bound value, result will be undefined.
15:05:26 <Myoma> ?
15:05:46 <dmwit> Myoma: Try (mToEnum 3 :: Maybe Bool).
15:06:01 <mmorrow> RayNbow: err, i haven't ever really used hugs. probably not portable if Data.Generics is a ghc-only thing
15:06:12 <mmorrow> (which i don't know if it is)
15:06:54 <dmwit> Myoma: (In particular, "between (minBound, maxBound) === True", so it's useless, you might as well write mToEnum = return . toEnum)
15:07:43 <newsham> myoma: that will fail because toEnum will error before guard fails
15:08:09 <newsham> need to check bounds in Int before toEnum.
15:09:30 <newsham> myoma: this is what i ended up using: http://hpaste.org/10018
15:10:39 <dmwit> It's weird that Enum doesn't have something like that already.
15:10:46 <dmwit> ?src Enum
15:10:46 <lambdabot> class  Enum a   where
15:10:46 <lambdabot>     succ                     :: a -> a
15:10:46 <lambdabot>     pred                     :: a -> a
15:10:46 <lambdabot>     toEnum                   :: Int -> a
15:10:46 <lambdabot>     fromEnum                 :: a -> Int
15:10:48 <lambdabot> [3 @more lines]
15:10:49 <Myoma> @hoogle toInteger
15:10:50 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
15:10:54 <dmwit> ?more
15:11:04 <dmwit> ...
15:11:05 <newsham> ?hoogle Enum a => Int -> Maybe a
15:11:06 <dmwit> @more
15:11:06 <lambdabot> Prelude toEnum :: Enum a => Int -> a
15:11:06 <lambdabot> Prelude Just :: a -> Maybe a
15:11:06 <lambdabot> Data.Maybe Just :: a -> Maybe a
15:11:15 <Myoma> @hoogle toInt
15:11:16 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
15:11:16 <lambdabot> Data.Char digitToInt :: Char -> Int
15:11:16 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
15:11:24 <dmwit> Ooo, are we on a new version of Hoogle?
15:11:28 <newsham> so many partial functions in the std libs :(
15:11:38 <dmwit> Wow!
15:11:47 <dmwit> The web version of Hoogle is more spicy, too!
15:12:17 <newsham> toEnum should really be -> Maybe a
15:12:22 <dmwit> I can't say I understand what the +/- icons are for, though.
15:13:58 <Myoma> did you find a good solution?
15:14:14 <newsham> myoma: this is what i ended up using: http://hpaste.org/10018
15:14:35 <Myoma> odd
15:14:54 <Myoma> I would have thought you'd have to put the e as a lambda binding not a let
15:15:06 <dmwit> e should be fine
15:15:13 <newsham> code is already tested.
15:15:35 <dmwit> asTypeOf is properly lazy
15:15:54 <RayNbow> <RayNbow> hmm, hpaste will soon hit the 10k mark <-- this was yesterday... :)
15:16:10 <dmwit> Yay!
15:16:20 <Myoma> I tried to check your code
15:16:21 <Myoma>     Ambiguous type variable `a' in the constraints:
15:16:21 <Myoma>       `Enum a' arising from a use of `e' at test.hs:12:46
15:16:21 <Myoma>       `Bounded a' arising from a use of `minBound' at test.hs:12:26-33
15:16:37 <dmwit> Be more specific when you call the function.
15:16:51 <Myoma> this is output from :load
15:17:00 <RayNbow> Time to celebrate hpaste's 10kth paste... free lambda's for everyone!
15:17:04 <Myoma> oh
15:17:10 <dmwit> Myoma: -fno-monomorphism-restriction?
15:17:36 <newsham> myoma: http://codepad.org/O4kKtihn
15:24:19 <wadcom> hi
15:24:34 <Philonous> @test \a b -> ((\(x,y) -> (y,x)) (a,b) == (uncurry. (flip id)) (a,b))
15:24:35 <lambdabot> Maybe you meant: let list tell
15:24:41 <wadcom> where can I find a syntax of core haskell? quick search didnt' reveal anything useful
15:24:42 <Philonous> @check \a b -> ((\(x,y) -> (y,x)) (a,b) == (uncurry. (flip id)) (a,b))
15:24:43 <lambdabot>  Couldn't match expected type `(t1, t)'
15:24:57 <Myoma> :t uncurry . flip id
15:24:58 <lambdabot> forall b c a. a -> (a -> b -> c, b) -> c
15:25:09 <Myoma> :t uncurry id
15:25:10 <lambdabot> forall b c. (b -> c, b) -> c
15:25:16 <Myoma> :t uncurry flip
15:25:17 <lambdabot> forall a b c. (a -> b -> c, b) -> a -> c
15:25:38 <Philonous> :t uncurry (flip id)
15:25:39 <lambdabot> forall a c. (a, a -> c) -> c
15:26:26 <Myoma> ?djinn (p,q) -> (q,p)
15:26:26 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
15:26:37 <Myoma> @pl \(p,q) -> (q,p)
15:26:37 <lambdabot> uncurry (flip (,))
15:26:58 <Philonous> :t (,)
15:26:59 <lambdabot> forall a b. a -> b -> (a, b)
15:27:12 <Myoma> @pl \a -> \b -> (a, b)
15:27:12 <lambdabot> (,)
15:28:33 <Philonous> @src flip
15:28:34 <lambdabot> flip f x y = f y x
15:28:50 <Myoma> it should be flip f y x = f x
15:28:51 <Myoma> it should be flip f y x = f x y
15:29:11 <Philonous> Is there any difference?
15:29:18 <Myoma> the names of variables
15:29:53 <Philonous> Doesn't alpha-conversion make them equal?
15:30:06 <dmwit> Yes.
15:30:08 <Botje> indeed.
15:30:17 <Botje> you could call them apple and banana for all haskell cares
15:30:47 <dmwit> I don't see a very compelling argument for either x/y or y/x.
15:31:46 <RayNbow> > let apple banana mango peach = banana peach mango in apple subtract 4 3
15:31:47 <lambdabot>  1
15:31:59 <RayNbow> something like that?
15:32:27 <dcoutts> Cale: yes, more info on conflicts might be nice, perhaps you can file a ticket and give an example and say what you'd like it to say. That'd be really useful.
15:32:29 <ddarius_> flip f thisIsTheFirstArgumentAndWillBecomeTheSecond thisIsTheSecondArgumentAndWillBecomeTheFirst = f thisIsTheSecondArgumentAndWillBecomeTheFirst thisIsTheFirstArgumentAndWillBecomeTheSecond
15:32:34 <dcoutts> Cale: Generating good error messages from the conflict set is not trivial, and I'm hampered by the full generality of possible conflicts (N of these, M of those) but in many specific situation we could probably do a lot better.
15:32:51 <humasect> =)
15:34:36 <Cale> flipTheParametersOfTheSuppliedFunction theFunctionWhoseParametersWeAreGoingToFlip thisIsTheFirstArgumentAndWillBecomeTheSecond thisIsTheSecondArgumentAndWillBecomeTheFirst = theFunctionWhoseParametersWeAreGoingToFlip thisIsTheSecondArgumentAndWillBecomeTheFirst thisIsTheFirstArgumentAndWillBecomeTheSecond
15:34:41 <dons> omfg.
15:34:44 <Cale> There. Enterprised.
15:34:57 <dons> i leave for 30 minutes and we've gone totally corporate.
15:35:18 <dmwit> Moral of the story: dons must NEVER LEAVE
15:35:19 <RayNbow> so... when will we see a CamelCase Haskell Enterprise Edition submission @ reddit? :p
15:36:10 <djsiegel_> Does anyone in here know Text.PrettyPrint? I tried putStr (render (text myLongString)) and did not get anything pretty.
15:36:41 <ddarius_> Smalltalk version: aFunction `flip` anArgument anotherArgument = aFunction anotherArgument anArgument
15:36:58 <Cale> dcoutts: Well... it would be helpful to at least know one pair of dependency chains which cause the conflict
15:37:18 <Cale> dcoutts: (so that one has some place to start working on resolving things)
15:37:21 <dmwit> djsiegel_: Just at a guess (without looking at the source), render . text = id
15:37:21 <gwern> 'Use -pgmF cmd  to select the program to use as the preprocessor. When invoked, the cmd pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where cmd should write its output to.'
15:37:26 <gwern> argggh
15:37:36 <Philonous> > let cindy loves adam = adam in cindy 0 1
15:37:36 <gwern> I was going nuts trying to figure out what profiling options like -p had to do with BotPP
15:37:37 <lambdabot>  1
15:37:39 <dmwit> djsiegel_: I think the idea is to use the pretty printer to generate myLongString in the first place.
15:37:41 * gwern hates lambdabot *so* much
15:37:49 * Myoma too
15:37:59 <Cale> dcoutts: Currently, it seems that it just reports the very ends of those chains, and not all the packages in between yours and the conflicting versions.
15:38:14 <djsiegel_> dmwit, ok -- I was hoping I could just pass myLong string (loaded from a file) and get something pretty :)
15:38:42 <Cale> gwern: What is wrong now?
15:38:52 <gwern> 'the second is the name of the file holding the input'? wtf
15:39:04 <gwern> Cale: I'm trying to get ghic to work with lambdabot modules
15:39:20 <gwern> but botpp was defeating me because I couldn't figure out the *3* arguments
15:39:23 <Cale> gwern: I'm guessing additional input to the preprocessor?
15:39:40 <gwern> 2 makes perfect sense - one to read from and 1 to write to, but 3 has me all >.<
15:39:49 <Cale> /dev/null?
15:40:01 <dmwit> 3 doesn't make sense either
15:40:09 <dmwit> lern2pipe
15:41:12 <gwern> however, the manual did help me inasmuch as it seems one can just add '{-# OPTIONS_GHC -pgmF BotPP -F #-}
15:41:16 <gwern> to the source files and ghci will work
15:41:37 <gwern> this is going to take a lot of edits :(
15:42:53 <gwern> Cale: incidentally, I was thinking of adding a '-e' option to lambdabot so we could write a tests.sh for lb like I did for mueval
15:42:59 <gwern> Cale: lb needs testing badly!
15:46:07 <gwern> (things like adding OPTIONS_GHC to every file in a directory make me very grateful for emacs, dired, and macros0
15:46:30 <sjanssen> gwern: I think it might be worth the effort to kill botpp
15:47:04 <gwern> sjanssen: moving botpp into OPTIONS_GHC is a good intermediate step inasmuch as it removes the biggest issue botpp causes - no ghci loading
15:47:14 <sjanssen> gwern: yeah, true
15:47:49 <gwern> I wonder whether botpp could be replaced with TH?
15:48:11 <gwern> I wouldn't be surprised if botpp predates TH, or was motivated by TH problems
15:49:01 <sjanssen> I don't think you can do what botpp does with TH
15:50:07 <gwern> I'll admit, I haven't actually looked at the generated boilerplate
15:50:41 <sjanssen> I can't remember what the issue was, but I think there's some limitation
15:56:12 <saya> @src mapM
15:56:12 <lambdabot> mapM f as = sequence (map f as)
15:56:29 <_zenon_> Hm.. someone has a binary of lambabot which you can download it it won't compile?
15:57:47 <gwern> _zenon_: not really
15:58:15 <_zenon_> darn, I keep getting the same error, installed zlib several times and all
15:58:25 <_zenon_>     zlib -any, binary >=0.2, plugins >=1.0, oeis -any
15:58:36 <_zenon_> Configuring lambdabot-4.1...
15:58:36 <_zenon_> Setup.hs: At least the following dependencies are missing:
15:58:36 <_zenon_>     zlib -any, binary >=0.2, plugins >=1.0, oeis -any
15:59:51 <gwern> plugins? oh, you're using the hackage one
16:00:03 <gwern> _zenon_: you'd be better off with darcs lb
16:00:16 <_zenon_> gwern, ooo
16:01:28 <_zenon_> gwern, so many files
16:01:35 <_zenon_> gwern, what to download? what to do?
16:03:42 <_zenon_> gwern, help?
16:08:22 <Philonous> :t maybe
16:08:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:08:53 <Philonous> :src maybe
16:08:59 <Philonous> @src maybe
16:08:59 <lambdabot> maybe n _ Nothing  = n
16:08:59 <lambdabot> maybe _ f (Just x) = f x
16:09:36 <Capso> Is 'maybe' supposed to lie between truthhood and falsehood?
16:10:34 <Philonous> Capso: I don't think so
16:10:46 <Capso> Just joking.
16:12:10 <sjanssen> TH could really use some actual documentation
16:12:11 <Philonous> Ok. I want the irony mark -.-
16:12:21 <sjanssen> the haddocks don't even have any comments!
16:12:55 <wadcom> is there a way to demangle GHC --ddump-simpl output? I keep seeing things like base:GHC.Base.ZC, which corresponds to (:)
16:13:00 <chrisdone> Philonous: you want an irony mark?
16:13:07 <chrisdone> Philonous: why‽
16:13:43 <Philonous> :P
16:13:47 <Peaker> slashdot comment: "TCL is very strongly typed. Everythin is a string. That's a 100% unbreakable typesystem :-)"
16:16:41 <dmwit> wadcom:
16:16:46 <dmwit> preflex: zdec ZC
16:16:46 <preflex>  :
16:17:42 <lispy> Guys, now that stackoverflow.com is launching, we should step in an fill it full of useful haskell questions and answers so that it exposes people to haskell :)
16:21:19 <EvilTerran> "unit in a monad" is return, right?
16:22:58 <lispy> EvilTerran: say what?
16:23:08 <Peaker> lispy: beware of becoming a liability - avoid success at ALL COSTS..
16:23:19 <lispy> Hello Peaker
16:23:23 <Peaker> lispy: hi :)
16:24:21 <ddarius> EvilTerran: Yes ...
16:24:41 <EvilTerran> ddarius, good, just checking. that makes sense in the context of this arrows paper. :)
16:25:17 <EvilTerran> (http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf)
16:25:19 <lambdabot> Title: The Arrow Calculus (Functional Pearl)
16:25:20 <EvilTerran> ta
16:30:38 <_zenon_> Jesus christ, start fixing one dependency and you end up patching with the whole of the darn hackage
16:30:44 * _zenon_ is building lambdabot
16:32:30 <chrisdone> is there a library for haskell which you can give a file with a PEG grammar in it which will produce a parser from that grammar?
16:33:21 <dmwit> What does PEG stand for?
16:33:24 <dmwit> Is it a standard format?
16:33:49 <gwern> _zenon_: so how goes lb?
16:33:52 * gwern was having dinner
16:33:58 <chrisdone> dmwit: I suppose it is standard. it stands for "parsing expression grammar"
16:34:06 <ddarius> Parsing Expression Grammar
16:34:10 * dmwit reads Wikipedia
16:34:41 <Botje> chrisdone: I seem to remember Pugs having a PEG part.
16:34:59 <_zenon_> gwern, I came past the depency problem, however, I don't know where to find Distribution.Simple.PackageIndex
16:35:02 <ddarius> @google pappy haskell
16:35:02 <dmwit> Looks like a restricted BNF.
16:35:05 <lambdabot> http://pdos.csail.mit.edu/~baford/packrat/thesis/
16:35:05 <lambdabot> Title: Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking
16:35:21 <gwern> _zenon_: wait what? that sounds like a cabal mismatch
16:35:35 <gwern> _zenon_: where's that error coming from?
16:35:55 <dons> weird, http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
16:35:57 <lambdabot> Title: [FoRK] And then there's Haskell... (was: Bone / Greenspun, etc.), http://tinyurl.com/5c7uj5
16:35:58 <_zenon_> gwern, zenon@zenon-laptop:~/Haskell/Cabals/ghc-paths-0.1.0.5$ runhaskell Setup.hs configure
16:35:58 <_zenon_> Setup.hs:7:7:
16:35:58 <_zenon_>     Could not find module `Distribution.Simple.PackageIndex':
16:35:58 <_zenon_>       Use -v to see a list of the files searched for.
16:36:21 <gwern> _zenon_: could you tell me what version of cabal is installed/being used?
16:36:39 <gwern> dons: yeah I saw that on reddit, and it was weird
16:37:07 <_zenon_> gwern, where do you see the version?
16:37:09 <dons> you saw it on reddit?
16:37:16 <gwern> yes
16:37:26 <gwern> _zenon_: well, ghc-pkg list cabal might help
16:37:50 <lament> dons: ...wow
16:38:03 <_zenon_> gwern, zenon@zenon-laptop:~/Haskell/Cabals/ghc-paths-0.1.0.5$ ghc-pkg list cabal
16:38:03 <_zenon_> /usr/lib/ghc-6.8.2/package.conf:
16:38:05 <chrisdone> dmwit: I'm using Frisby at the moment (http://repetae.net/computer/frisby), but it's kind of cumbersome for big grammars
16:38:09 <dmwit> If by weird you mean Awesome!
16:38:29 <gwern> dmwit: xmonad is awesome; awesome is not
16:38:29 <_zenon_> gwern, It's the first time I'm using cabal seriously.
16:38:54 <dons> http://www.reddit.com/r/programming/comments/6yq8i/and_then_theres_haskell_nsfw/ :)
16:38:56 <lambdabot> Title: And then there's Haskell.... :: NSFW () : programming, http://tinyurl.com/6cjg6j
16:38:58 <gwern> _zenon_: so ghc-pkg didn't show any cabal versions?
16:39:06 <dons> i think that can only glamourise haskell.
16:39:06 <gwern> that is, it's not even installed?
16:39:17 <_zenon_> gwern, that might be a problem then :)
16:39:23 <dons> at least amongst alpha hackers who like fast cars, danger, fire and knives.
16:39:24 <lament> dons: that article desperately needs pictures
16:39:28 <gwern>  yeah...
16:39:52 <gwern> _zenon_: so how did you get ghc installed with no cabal?
16:40:15 <_zenon_> apt-get
16:40:17 <lispy> dons: that reminds me, I need to attach flaming knives to my car...
16:40:35 <dons> lispy: re. beer, next week is good  (maybe thurs?)
16:40:45 <lispy> dons: Okay
16:40:58 <lispy> dons: sounds good!
16:40:58 <gwern> _zenon_: well, I'll warn you in advance - ghc-paths needs particular versions of cabal
16:41:35 <_zenon_> gwern, weird it's not stated in dependencies for it =/
16:41:52 <_zenon_> gwern, which version should that be then?
16:42:00 <gwern> _zenon_: well, it would appear in a different field than build-depends
16:42:07 <gwern> cabal-version:, iirc
16:42:21 <gwern> _zenon_: cabal 1.4.x iirc
16:42:40 <_zenon_> gwern, k, thanks
16:42:56 <_zenon_> safe then, I just downloaded 1.4.0.2
16:43:20 <chrisdone> “She [Haskell] leaves a trail of broken, brainy, embittered PhDs and former programmers behind her”, bahaha
16:43:42 <_zenon_> :)
16:43:49 <gwern> _zenon_: I'll admit, the current situation with manual dependencies is not ideal, which is why I recommend cabal-install in the readme
16:43:57 <gwern> which hopefully will handle everything appropriately, eventually
16:44:25 <_zenon_> gwern, Yeah, this could have been handled smoother :) but that's really just a question of time and resources (human such)
16:45:18 <gwern> one day debian and the other distros will all package cabal-insatall! and then we will just tell everyone 'apt-get install cabal-install && cabal install lambdabot'
16:45:52 <dmwit> unlikely
16:46:10 <dmwit> Debian doesn't package gem or scons or...
16:46:11 <gwern> eh? y
16:46:15 <dmwit> oh
16:46:17 <dmwit> package
16:46:21 <dmwit> Well, that's totally possible.
16:46:32 * dmwit was thinking "install by default"
16:47:56 <gwern> well, I doubt gentoo, say, will ever turn its ebuild scripts into 'cabal install "$1"' since the packages are out of their control and remote
16:48:02 <gwern> a simple issue of trust
16:48:14 <Heffalump> that's a different issue
16:48:18 <gwern> even if cabal install would install system-wide in a 'correct' debian-policy-compatible way
16:48:39 <gwern> (I understand rubygem isn't popular among debian devs because it breaks the filesystem hierarchy?)
16:49:08 <gwern> dmwit: but there's obviously nothing stopping gentoo from its scripts being glorified 'runhaskell Setup configure && build && install', and that's what they already do
16:49:14 <sjanssen> gwern: have you already done your {-# OPTIONS #-} modification to lambdabot?
16:49:22 <sjanssen> gwern: I'm almost done writing PLUGIN in TH
16:49:25 <gwern> sjanssen: yes
16:49:28 <gwern> made and pushed
16:49:39 <gwern> sjanssen: so it *can* be done?
16:49:44 <Heffalump> if cabal install puts things in /usr/local, what's the issue?
16:49:47 <sjanssen> gwern: yes, I think so
16:49:57 <sjanssen> gwern: at least the PLUGIN part, haven't investigated MODULE yet
16:50:23 <gwern> MODULE?
16:50:26 * _zenon_ drools..... mmmmmm apt-get install lambdabot
16:50:31 <_zenon_> so great
16:50:42 <dons> we need a new lambdabot. one of these hackathons..
16:50:58 <dons> btw, whose going to Victoria for ICFP?
16:51:00 <dons> byorgey?
16:51:05 <dons> Heffalump: you are, right?
16:51:10 <sjanssen> gwern: btw, this library thing for botpp is useless, right?
16:51:10 <dons> dcoutts: ?
16:51:26 <_zenon_> zenon@zenon-laptop:~/Haskell/Cabals/hint-0.2.4.1$ runhaskell Setup.lhs configure
16:51:26 <_zenon_> Warning: defaultUserHooks in Setup script is deprecated.
16:51:26 <_zenon_> Configuring hint-0.2.4.1...
16:51:26 <_zenon_> Warning: This package indirectly depends on multiple versions of the same
16:51:26 <_zenon_> package. This is highly likely to cause a compile failure.
16:51:26 <gwern> sjanssen: the library thing allows us to enforce a dep on botpp
16:51:27 <_zenon_> package ghc-6.8.2 requires bytestring-0.9.0.1
16:51:29 <_zenon_> package utf8-string-0.3.1.1 requires bytestring-0.9.1.2
16:51:31 <_zenon_> what?
16:51:35 <gwern> so a user can't forget to install botpp
16:51:39 <sjanssen> gwern: blehhhh
16:51:48 <sjanssen> gwern: how is this better than the executable section in lambdabot?
16:52:26 <gwern> sjanssen: yes yes, lambdabot is a very good case example of why we need a runtime-depends: as well build-depends, and the library/executable split is the best workaround I have
16:52:29 <sjanssen> also, what is up with the lambdabot library thing?
16:52:32 <dmwit> _zenon_: For the future, use hpaste for longish errors, please.
16:52:52 <_zenon_> dmwit, sorry, It was actually quite long =/
16:53:00 <gwern> sjanssen: I hope to split out Plugin/* to an independent library which could be useful to preflex, lambdabot, mubot, etc.
16:53:04 * gwern has gone over this before
16:53:11 <sjanssen> gwern: but right now all it does is make me build it twice
16:53:25 <_zenon_> gwern, what do you propose for the multiple dependency?
16:53:30 <gwern> all life is suffering
16:53:52 <gwern> _zenon_: reflect, repent, and recompile
16:53:53 <_zenon_> dmwit, it was really pure lazyness, I must apologize.
16:54:02 * sjanssen adds buildable: False
16:54:08 <dons> heh
16:54:44 <_zenon_> gwern, I am at a loss, must all parts be rebuilt? Or what?
16:55:02 <sjanssen> gwern: okay if I add buildable: False upstream?  It will save everybody CPU time until that feature actually works
16:55:48 <gwern> _zenon_: I don't entirely understand the details of the bytestring link problem in general, but I think the usual solution is to remove the updated bytestring and rebuild everything like utf8-string. in the case of lambdabot, you could try removing mueval from the dependencies
16:56:16 <gwern> sjanssen: hm. if buildfable is false, would that mean the library section could have configuration errors which we would not see at runtime?
16:56:53 <gwern> er, compiletime
16:56:54 <gwern> I mean
16:56:58 <_zenon_> gwern, building lambdabot is like a big cruel practical joke
16:57:01 <_zenon_> :)
16:57:06 <_zenon_> but still you learn something
16:57:22 * gwern chants. static public void main []
16:57:36 <_zenon_> and the prospect of having it working is definitively worth it
16:58:24 <sjanssen> gwern: some compile errors yes
16:58:39 <sjanssen> gwern: or I can make it optional on a flag that defaults to False, if you want to test it that way
16:58:52 <gwern> hm. well, it wouldn't be a big deal. push that change if you like
17:01:05 <shepheb> ?users
17:01:06 <lambdabot> Maximum users seen in #haskell: 470, currently: 443 (94.3%), active: 14 (3.2%)
17:02:52 <sjanssen> gwern: it seems to work!!
17:03:21 <gwern> what does? my botpp change, th botpp, buildable false?
17:03:39 <sjanssen> th botpp
17:03:55 <gwern> sweet
17:04:03 <sjanssen> okay if I just darcs revert "[move BotPP into individual modules and out of .cabal"?
17:04:14 <gwern> so, ah, how would th botpp work anyway? a new module you import from?
17:04:19 <sjanssen> erm, darcs undo
17:04:26 <sjanssen> gwern: it's just a function in Plugin
17:04:26 <gwern> sjanssen: th botpp can't be done on top of it?
17:04:49 <sjanssen> gwern: it's just a million lines I'd have to delete manually
17:05:05 <gwern> go ahead, as long as darcs undo can be undone by any random darcs getter
17:05:23 <sjanssen> gwern: ghci loading will work before I push all this
17:05:43 <sjanssen> gwern: you also have a bunch of whitespace changes along with the OPTIONS pragmas, watch out for that
17:06:18 * gwern shrugs
17:07:44 <_zenon_> We really really really need some kind of handling for all these dependency issues
17:09:12 <Cale> _zenon_: Which ones?
17:09:58 <_zenon_> everyone like me that had do download all dependencies in a depth first fashion discovering problems along the way.
17:10:03 <Cale> _zenon_: Building lambdabot is still troublesome, but it's not horrible anymore, you just need cabal install.
17:10:27 <Cale> (You *do* have cabal install, right?)
17:10:38 <_zenon_> Cale, I am using runhaskell
17:10:45 <Cale> oh, then you're doing it wrong :)
17:10:51 <_zenon_> that explains it
17:11:26 <dmhouse_> Well, unless you're using runhaskell to run the Cabal setup script.
17:11:31 <Cale> Install the cabal-install package, then just run 'cabal install' from inside the lambdabot directory. If it gives you some flak about bytestring versions, try doing the same from the lambdabot-utils directory first.
17:12:01 <hansfbaier> dons: I built the original ghc 6.8.3 sources using the OpenBSD stock ghc. Everything worked well. Would this probably mean I could build a port where I can take the old Makefile, but with no patches or am I a bit naive?
17:12:15 <hansfbaier> dons: s/naive/naive about that/
17:13:08 <_zenon_> Cale, oh, that seems several times easier than the mountain of dependencies I just crawled over
17:15:37 <dobblego> is \(a, b) -> (b, a) somewhere in the standard libraries?
17:15:40 <dobblego> @hoogle \(a, b) -> (b, a)
17:15:41 <lambdabot> Parse error:
17:15:41 <lambdabot>   --count=20 "\(a, b) -> (b, a)"
17:15:41 <lambdabot>              ^
17:15:51 <Olathe> @pl \(a, b) -> (b, a)
17:15:51 <lambdabot> uncurry (flip (,))
17:15:59 <Cale> dobblego: nope
17:16:02 <Cale> er...
17:16:06 <Olathe> You can use that, though.
17:16:13 <Cale> Hmm, maybe it's in Data.Tuple now...
17:16:15 <dobblego> ok ta
17:16:25 <Cale> no, not yet
17:16:26 <Olathe> flipTuple = uncurry (flip (,))
17:16:47 <Cale> But when it comes, it'll probably be there, and with the name 'swap'
17:16:47 <Olathe> Or, for readability: flipTuple (A, b) = (b, a)
17:17:25 <_zenon_> Cale, so after the cabal install it's done?
17:17:53 <Cale> _zenon_: You should add ~/.cabal/bin to your path
17:18:00 <_zenon_> Is there some other hackage package I can download to regain my lost hour?
17:18:02 <Cale> _zenon_: a lambdabot binary will be there
17:18:06 <Cale> heh
17:18:26 <dmhouse> Doesn't recent cabal-install add symlinks to ~/bin?
17:18:37 <dmhouse> (Or does "recent" mean "newer than the release"?)
17:18:47 <_zenon_> darn it to heck and more...... I feel hackage dependency-ravaged
17:18:57 <_zenon_> It seems to work like a charm.
17:19:08 <SamB_XP> is ~/bin even usual?
17:19:18 <dobblego> \p s -> case s of [] -> Nothing; (h:t) -> if p h then Just t else Nothing -- can this be tidied up at all?
17:20:43 <dmhouse> do h:_ <- s; guard (p s)
17:21:27 <dmhouse> Err, guard (p h)
17:21:35 <gwern> SamB_XP: ~/bin is pretty conventional
17:21:37 <gwern> if you have anything in ~/ at all
17:21:37 <dmhouse> Oh, wait, that won't work :)
17:21:40 <gwern> I believe darcs cabal-install hopes to symlink in ~/bin but doesn't insist on't
17:21:50 <dmhouse> do h:t <- s; guard (p h); return t
17:22:05 <gwern> sjanssen: you push anything yet?
17:22:06 <Olathe> f _ [] = Nothing; f p (x:xs) = if p x then Just xs else Nothing
17:22:25 <dmhouse> Olathe: guards > top-level if
17:22:33 <Olathe> @src guard
17:22:34 <lambdabot> guard True  =  return ()
17:22:34 <lambdabot> guard False =  mzero
17:22:45 <dmhouse> f _ [] = Nothing; f p (x:xs) | p x = Just xs | otherwise = Nothing
17:22:49 <dobblego> @check \p s -> let f p s = case s of [] -> Nothing; (h:t) -> if p h then Just t else Nothing; g p s do h:t <- s; guard (p h); return t in f p s = g p s
17:22:50 <lambdabot>  Parse error in pattern at "do" (column 94)
17:22:57 <dobblego> @check \p s -> let f p s = case s of [] -> Nothing; (h:t) -> if p h then Just t else Nothing; g p s = do h:t <- s; guard (p h); return t in f p s = g p s
17:22:57 <lambdabot>  Parse error in pattern at "=" (column 94)
17:23:00 <dmhouse> (I meant guards as in |, rather thean the guard statement there.)
17:23:13 <Olathe> @pl let f _ [] = Nothing; f p (x:xs) | p x = Just xs | otherwise = Nothing in f
17:23:13 <lambdabot> (line 1, column 9):
17:23:13 <lambdabot> unexpected "["
17:23:13 <lambdabot> expecting pattern or "="
17:23:35 <_zenon_> Cale, where does the config file go when you build with cabal-install ?
17:23:45 <dmhouse> @check \p s -> let f p s = case s of [] -> Nothing; (h:t) -> if p h then Just t else Nothing; g p s = do h:t <- s; guard (p h); return t in f p s == g p s
17:23:46 <lambdabot>  Parse error in pattern at "=" (column 94)
17:24:01 <dmhouse> @check \p s -> let f p s = (case s of [] -> Nothing; (h:t) -> if p h then Just t else Nothing) g p s = do h:t <- s; guard (p h); return t in f p s == g p s
17:24:01 <lambdabot>  Parse error at "=" (column 95)
17:24:19 <gwern> hm. the online.rcs aren't in data-files
17:25:06 <Cale> _zenon_: Well, you should probably copy online.rc to somewhere convenient (I recommend ~/.lambdabot) and make an appropriate passwd.rc to go with it. The default config files are installed to ~/.cabal/share/lambdabot-*/...
17:25:17 <Cale> (somewhere under there :)
17:25:24 <_zenon_> Cale, thanks.
17:25:54 <dmhouse> dobblego: I think it'd have to be do h:t <- return s; guard (p h); return t.
17:26:00 <dobblego> thanks dmhouse
17:26:01 <Cale> After you run lambdabot for the first time, it will copy the config into ~/.lambdabot
17:26:05 <Cale> and then use it from there
17:26:16 <Cale> _zenon_: ^^ that is important in case you walked away :)
17:26:20 <gwern> it will?
17:26:34 <gwern> iirc, I never touched onlinerc handling with my ~/ patches
17:27:17 <Cale> gwern: the State/ stuff ends up there
17:27:29 <Cale> gwern: The online.rc won't, but I like to put it there anyway
17:33:03 <sjanssen> gwern: I don't think your OPTIONS changes work at all
17:33:20 <gwern> they Worked Here
17:33:38 <sjanssen> nevermind
17:33:52 <sjanssen> oh, you did forget to add it to Modules.hs
17:34:16 <tristes_tigres> @seen int-e
17:34:16 <lambdabot> I haven't seen int-e.
17:34:48 <_zenon_> Cale, what's the passwd.rc file for?
17:35:17 <Cale> _zenon_: sending a password to nickserv
17:35:32 <_zenon_> I'm trying to connect the lambdabot, but it fails.
17:36:22 <Cale> Did you change the nick?
17:36:41 <dobblego> @type flip lookup
17:36:42 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
17:37:25 <Olathe> @src lookup
17:37:25 <lambdabot> lookup _key []          =  Nothing
17:37:25 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
17:37:25 <lambdabot>                         | otherwise = lookup key xys
17:37:27 <_zenon_> I belive so, I changed lambdabot to Guest88
17:38:22 <_zenon_> Cale, It's as if lambdabot fails to keep the connection alive
17:40:52 <_zenon_> Cale, it dies just after irc[freenode] error: <socket: 6>: hGetChar: end of file
17:41:38 <ertai> In parsec3, is there a a way to test of end-of-input, while staying generic?
17:41:59 <ddarius> eof should work fine
17:42:54 <ertai> ddarius: thanks I didn't found it
17:49:08 <_zenon_> what is the format of the passwd.rc file? the syntax I mean.
17:50:25 <b\6> _zenon_: ? what uses that?
17:50:48 <_zenon_> b\6, lambdabot, in the online.rc file
17:51:45 <_zenon_> b\6, to be honest I am mostly trying stepwise, I can't find any thorough documentation on how to set up lamdbabot
17:51:51 <b\6> _zenon_: yeah, looks kind of weird. are you looking at the stuff in darcs?
17:51:52 <_zenon_> lambdabot
17:52:14 <_zenon_> b\6, nah, i downloaded the hackage version and installed it with cabal-install (after tip from Cale)
17:52:32 <_zenon_> I just want lambdabot to join #mobileread
17:52:49 <chrisdone> isn't that a web forum?
17:53:10 <b\6> _zenon_: join nameofnet:#mobileread
17:53:29 <_zenon_> b\6, yeah, but it drops the connection for some weird reason
17:53:33 <b\6> _zenon_: looks like nameofnet has to match the irc-connect line.
17:53:36 <b\6> oh, hmm.
17:54:25 <_zenon_> chrisdone, I believe you are referring to www.mobileread.com/forums  ?
17:54:58 <chrisdone> _zenon_: yeah, I found that forum very useful for getting information about my Sony Reader
17:55:01 <b\6> _zenon_: what does your online.rc look like? irc-connect line, then join line?
17:55:19 <_zenon_> b\6, yes
17:55:37 <b\6> is it connecting or joining?
17:55:51 <_zenon_> b\6, http://hpaste.org/10020
17:57:38 <_zenon_> Will someone that feels at ease with lambdabot hack together a manual or a thorough documentation on setting up lambdabot etc ?
17:57:53 <b\6> think it's too much of a work in progress.
17:58:19 <_zenon_> b\6, possibly
17:58:36 <_zenon_> can you spot some direct fault?
17:58:49 <b\6> it's weird because it looks like freenode drops you for not having identd, but i know it doesn't.
17:59:24 <b\6> maybe specify one more field after nick, anything. 'yo' or something.
17:59:48 <_zenon_> check..
18:00:07 <_zenon_> yey
18:00:10 <_zenon_> b\6, you made it ;)
18:00:30 <b\6> oh, cool. dunno if that's part of the protocol or what.
18:00:55 <_zenon_> b\6, thanks anyway ;)
18:01:02 <b\6> happy to.
18:05:21 <_zenon_> holy shi*
18:09:28 <dmwit> _zenon_: Somebody (/0)
18:09:31 <_zenon_> can lambdabot log channel activity?
18:09:40 <dmhouse> ?faq
18:09:40 <lambdabot> The answer is: Yes! Haskell can do that.
18:09:41 <dmwit> Yes, and I believe she does.
18:09:43 <dmhouse> (Sorry.)
18:09:57 <_zenon_> dmwit, or they used a GOTO statement
18:10:51 <gwern> I thought Tunes did its own logging
18:11:00 <_zenon_> where does the log go with the standard config?
18:11:40 <b\6> gwern: know what the deal is with having to specify a realname or whatever it is as the last field of the irc-connect in online.rc? does the server demand that?
18:11:51 <gwern> b\6: no idea
18:12:15 <Olathe> It's one of the fields in the USER line, which is required.
18:12:19 <b\6> ok.
18:12:25 <gwern> b\6: strikes me as part of the protocol though. I've never seen a client connect without either their own Real Name or some default
18:12:49 <b\6> maybe whatever parses irc-connect should demand it, then.
18:14:15 <_zenon_> hm... @dice X always gives X for my bot
18:14:42 <dmhouse> ?dice 4
18:14:42 <lambdabot> 4 => 4
18:14:43 <dmhouse> ?dice 4
18:14:43 <lambdabot> 4 => 4
18:14:44 <dmhouse> ?dice 4
18:14:44 <lambdabot> 4 => 4
18:14:45 <dmhouse> ?dice 4
18:14:46 <lambdabot> 4 => 4
18:14:46 <dmwit> _zenon_: It should.
18:14:49 <dmwit> ?dice 4d4
18:14:49 <lambdabot> 4d4 => 10
18:14:53 <dmwit> ?dice 4d4
18:14:53 <lambdabot> 4d4 => 11
18:14:57 <dmwit> ?dice 1d6
18:14:57 <lambdabot> 1d6 => 5
18:15:00 <_zenon_> ahh
18:15:00 <dmwit> ?dice 1d4
18:15:01 <lambdabot> 1d4 => 4
18:15:03 <dmhouse> ?help dice
18:15:03 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
18:15:03 <dmwit> ?dice 1d4
18:15:03 <lambdabot> 1d4 => 3
18:15:05 <sjanssen_> oh, I remember why BotPP can't be replaced
18:15:15 <sjanssen_> TH can't import modules
18:15:26 <dmwit> ?dice 1d3+2d5+1d6
18:15:26 <lambdabot> 1d3+2d5+1d6 => 15
18:16:05 <gwern> sjanssen_: so, ah, what does that mean?
18:16:18 <TehZorroness> I'm having a little trouble with haskell-mode for (gnu)emacs.  It doesn't seem to be handling indentation properly
18:16:27 <TehZorroness> this paste sorta explains my situation: http://hpaste.org/10021
18:16:28 <b\6> welcome to a world!!!
18:16:53 <dmhouse> TehZorroness: yes, indentation of if statements in do-blocks is unfortunately broken.
18:16:59 <gwern> TehZorroness: it never does
18:17:01 <dmhouse> TehZorroness: this is actually the second time today this has come up.
18:17:07 <b\6> not sure whether i'm glad or not to hear emacs indentation is as busted as vim's.
18:17:14 <dmhouse> gwern: actually, the haskell-mode indentor is quite good.
18:17:41 <sjanssen_> gwern: look at Modules.hs
18:17:50 <gwern> dmhouse: I don't consider an indentor good until I can put it in a macro to run on my entire file and not get compilation errors because of it
18:17:59 <TehZorroness> so if that code weren't in the do block, the indentation would work "normally?"
18:18:15 <dmwit> gwern: But... then indentation wouldn't be significant.
18:18:17 <gwern> sjanssen_: so botpp has been confined to that one file?
18:18:28 <sjanssen_> gwern: it takes a list of plugins, imports each of them, then generates some extra boilerplate
18:18:30 <dmwit> Indentation can *change the meaning* of a program.
18:18:31 <sjanssen_> gwern: yep
18:18:41 <gwern> sjanssen_: perhaps we can run botpp on that one file and scrap botpp entirely then
18:18:45 <dmhouse> gwern: impossible with Haskell, there are multiple valid places to indent a Haskell line.
18:18:54 <dmhouse> (This is mostly due to the lack of semicolons.)
18:19:06 <gwern> dmwit: call me spoiled because of lisp indentors and non-significant whitespace, but THIS IS THE WAY I AM
18:19:10 * gwern has no regrets!
18:19:23 <sjanssen_> gwern: perhaps
18:19:24 <SamB_XP> what if that only worked if the file had been correctly indented to begin with?
18:19:27 <Olathe> I've gretted, but never regretted.
18:19:32 <sjanssen_> gwern: I'm looking to see if we can at least automate part of it
18:19:54 <dmhouse> gwern: E.g. consider: "let a = b". On the next line, you might want to do any of 1) write `in', 2) write a new binding to let, 3) write an argument to b.
18:20:19 <gwern> SamB_XP: I'll admit, an indentation function which at least won't turn correct -> incorrect would be nice
18:20:34 <dmhouse> gwern: the first one we can tell apart if you write `in' before indenting (and haskell-mode does this). The second one we can tell apart if you write an = sign (again it does this).
18:20:46 <dmhouse> gwern: but if you just press RET TAB, what are we supposed to do?
18:21:00 <gwern> dmhouse: DWIM, of course
18:21:20 <dmhouse> I just explained there are at least three things you could mean.
18:21:25 <SamB_XP> gwern: you want it to read your <expletive omitted> mind?
18:21:42 * gwern thinks that is a reasonable desire
18:21:43 <TehZorroness> I wish computers could do that
18:21:45 <TehZorroness> :(
18:21:48 <dmhouse> SamB_XP: I'd settle for a function which says "indent to the column I'm looking at"
18:22:04 * SamB_XP wishes he could come up with a strong word to replace explitives with, that was not itself one
18:22:28 <TehZorroness> we could stop considering expletives to be evil
18:22:29 <SamB_XP> dmhouse: you need, like, cameras -- calibrated just so
18:22:42 <dmhouse> SamB_XP: this is probably beyond the scope of haskell-mode.
18:23:01 <TehZorroness> iunno
18:23:10 <SamB_XP> TehZorroness: well, I don't like poluting the language by using anglo-saxon words to refer to things that they don't actually mean, anyway
18:23:10 <TehZorroness> some emacs hackers are kinda crazy
18:23:14 <TehZorroness> I could se it happening
18:23:16 * dmwit suggests air-pressure sensitive screens
18:23:22 <dmwit> Just *blow* at the column you want to indent to.
18:24:08 <dmhouse> Tbh, I thought the lack of semicolons was neat in Haskell, until I realised how convenient it is to have an indentor which just works, every time.
18:24:25 <insomaniac> can "impure" FP languages have something like typeclasses ?
18:24:29 <dmhouse> (Yes, I know I could write with semis in. No, of course I won't do that.)
18:24:37 <dmwit> insomaniac: No reason not to.
18:24:44 <insomaniac> aha ok
18:24:45 <SamB_XP> insomaniac: absolutely!
18:24:50 <dmwit> insomaniac: Java comes close with its interfaces, for example.
18:24:54 <dmhouse> insomaniac: sure. In fact, OO languages have interfaces, which are superficially fairly similar.
18:25:00 <dmwit> They put arbitrarily bad restrictions on interfaces, though. =/
18:25:03 <SamB_XP> typeclasses have more to do with HM-style typing than with purity
18:25:23 <SamB_XP> purity is really quite orthogonal to the typesystem ;-)
18:25:24 <dmhouse> Yeah, nothing about HM says that it must be lazy.
18:25:30 <ddarius> dmhouse: Not really.
18:25:35 <ddarius> Cripes, dmwit
18:25:45 <insomaniac> then why, for the sake of argument, should i bother with haskell as a "pure" FP language instead of more "comfortable" choices like say ocaml or scala ?
18:25:49 <dmhouse> You could seq-ify everything in your program, and it would still be a valid HM program.
18:25:54 <SamB_XP> dmwit: yeah, the restrictions aren't *arbitrarily* bad
18:25:58 <dmwit> Whoops, I said "arbitrarily bad," but I meant "arbitrary, bad".
18:25:58 <SamB_XP> they are a constant amount bad
18:26:07 <dmhouse> Hehe.
18:29:11 <insomaniac> i don't quite see the benefit of haskell when there
18:29:31 <insomaniac> 're choices that can be "impure" when i need it
18:29:45 <SamB_XP> insomaniac: well, I don't see ocaml and scala HAVING typeclasses
18:29:48 <SamB_XP> just a thought
18:30:09 <SamB_XP> I mean, there's no reason why ocaml couldn't have them ...
18:30:14 <insomaniac> SamB_XP: exactly, typeclasses are a very nice propery of haskell
18:30:26 <dmhouse> Woah, I got mixed up with laziness, ignore my previous comment about seqification.
18:30:31 <SamB_XP> but it doesn't seem to have them NOW, so that's a reason not to use ocaml now
18:30:38 <SamB_XP> dmhouse: hehe
18:30:48 <SamB_XP> dmhouse: you know, I didn't catch that
18:30:50 <dmwit> insomaniac: Beware the bondage.
18:30:54 <dmwit> You might find you like it.
18:30:57 <SamB_XP> probably because lazy => pure ;-P
18:31:06 <dmhouse> Quite.
18:31:15 <SamB_XP> or at least lazy => pure || insane
18:31:23 <insomaniac> is "clean" lazy ?
18:31:37 <SamB_XP> insomaniac: can be
18:31:52 <SamB_XP> it's pure, so...
18:32:02 <insomaniac> ok
18:32:13 <SamB_XP> oh, I heard they were going to add support for Haskell
18:33:09 <gwern> I heard they did add support for '98
18:33:09 <insomaniac> i'm just unsure what the benefits of a pure FP language are
18:33:49 <SamB_XP> insomaniac: well, it aids reasoning -- that's why only pure languages can reasonably support laziness
18:34:35 <SamB_XP> in an impure one, you'd go insane because all your side-effects would happen at unexpected times ;-)
18:34:37 <insomaniac> SamB_XP: yes, but the "real world" benefits ... i'm not planning to run my app thru a theorem prover
18:34:54 <SamB_XP> I meant, debugging
18:35:05 <dmwit> Reasoning can be done by humans, too, you know. ;-)
18:35:28 <SamB_XP> and just FYI haskell is a bit fast-and-loose for a theorem prover's taste ;-)
18:36:14 <insomaniac> debugging, ok, so you're implying once my app reaches a certain level of complexity debugging becomes a pain because of side effects in places where i didn't expect them ?
18:36:17 <dmwit> insomaniac: Equational reasoning and ghci make Haskell one of the best languages to debug, as far as I'm concerned.
18:36:23 <Capso> "theorem prover" sounds like a human to begin with
18:36:33 <dmhouse> Let's prove theorems!
18:36:40 <dmwit> insomaniac: Well... a little bit, yes.
18:36:44 <dmhouse> First up: Modus Ponens: a -> (a -> b) -> b
18:36:51 <dmhouse> ?djinn a -> (a -> b) -> b
18:36:51 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
18:37:03 <dmwit> insomaniac: But the interesting part is that Haskell allows you to make very specific claims about what kind of side effects a function is allowed to have.
18:37:05 <SamB_XP> state problem ?
18:37:05 <dmhouse> Oh, there goes the theorem-proving fun.
18:37:10 <SamB_XP> ?help djinn
18:37:11 <lambdabot> djinn <type>.
18:37:11 <lambdabot> Generates Haskell code from a type.
18:37:11 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:37:12 <dmhouse> ?djinn-clr
18:37:20 <dmhouse> ?djinn a -> (a -> b) -> b
18:37:20 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
18:37:21 <dmwit> For example, you can have functions that are allowed to keep state, but not allowed to (say) access the file system.
18:37:30 <dmwit> This is a *very* cool restriction to be able to make.
18:37:30 <SamB_XP> ?list djinn
18:37:30 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
18:37:40 <insomaniac> dmwit: yes, i've read about that
18:37:45 <SamB_XP> ?djinn-env
18:37:57 <SamB_XP> ?djinn-names
18:38:06 <SamB_XP> ?djinn-ver
18:38:06 <lambdabot> Plugin `djinn' failed with: Prelude.head: empty list
18:38:16 <SamB_XP> Cale: did you forget to INSTALL djinn?
18:38:24 <SamB_XP> or what?
18:38:28 <SamB_XP> because it's not working at all
18:38:29 <dmwit> insomaniac: In fact, if you look at larger Haskell programs, you'll see that the first thing they do is enter a custom-made monad -- essentially declaring *in its type* exactly what kind of side effects they expect to do.
18:38:59 <Cale> SamB_XP: hmm
18:38:59 <SamB_XP> dmwit: only one?
18:39:13 <SamB_XP> dmwit: most have a number of them ;-)
18:39:19 <dmwit> SamB_XP: Usually, yes.  Though it's often constructed from many transformers.
18:39:38 <SamB_XP> at least, if by "haskell programs" you mean "compilers written in Haskell"
18:39:49 * dmwit mentions xmonad's X monad
18:40:00 * dmwit suggests also lambdabot's IRC monad
18:40:21 <insomaniac> dmwit: thb, the "custom monad" thing frightens me, because *every* haskell program has a layer of "monaish" things around the stuff its actually doing
18:40:23 <Saizan_> we still don't have a proper abstraction to mix various monads, especially wrt callcbacks
18:40:38 <SamB_XP> insomaniac: you'd never understand them without those layers
18:40:42 <dmwit> insomaniac: Not so surprising.  All programs have a set of custom functions to call.
18:40:46 <SamB_XP> nor would they ever have been written
18:40:46 <dmwit> Haskell is no different.
18:40:52 <insomaniac> hmhm
18:41:00 <pjdelport> insomaniac: so do other languages, they're just not as explicit about it
18:41:06 <dmwit> right
18:41:22 <dmwit> The advantage of Haskell is exactly that: there are a lot of things that are made explicit.
18:41:27 <SamB_XP> pjdelport: they don't have the monads, they just hide all the state in global variables or whatever
18:41:44 <dmwit> Parametric polymorphism is another great example.
18:41:47 <SamB_XP> and can't easily do nondeterminism, etc.
18:41:49 <insomaniac> is it okay if i come back another time to ask really noobish questions about haskell / FP and monadish glue among things ?
18:41:52 <pjdelport> SamB_XP: which forms an implicit monad, or monads
18:42:03 <dmwit> Type classes make the "range" of polymorphism very explicit, which I find cool.
18:42:04 <SamB_XP> insomaniac: ... um, yes ;-P
18:42:18 <insomaniac> ah ok :) will do so
18:42:23 <SamB_XP> insomaniac: that is probably one of the stupidest questions I've ever seen asked here, actually ;-P
18:42:30 <insomaniac> hehe
18:42:33 <MyCatVerbs> insomaniac: no! You get ONE and ONLY ONE CHANCE to ask ALL the questions you EVER WANT!
18:42:41 <SamB_XP> "is it okay to ask noobish questions later as well as now???", he asks
18:42:48 <MyCatVerbs> insomaniac: that change BEGINS from the moment you are born and is TERMINATED at the moment of your death! So there!
18:42:53 <the_unmaker> is wash a web system suitable for a large blog site?
18:42:59 <MyCatVerbs> s/change/chance/
18:43:05 <insomaniac> i just thought i'd ask, because you're probably all experts and i didn't want to bother you
18:43:21 <dmwit> the_unmaker: I do not recommend WASH.
18:43:23 <MyCatVerbs> insomaniac: have a cookie or something. :)
18:43:23 <pjdelport> insomaniac: Haskell experts are happy to answer your questions
18:43:37 <insomaniac> thank you :)
18:43:38 * SamB_XP can't stop laughing
18:43:46 <dmwit> the_unmaker: I can present no alternatives with authority, but I've heard good things about happs.
18:43:51 * SamB_XP may need to increase the dosage on his new ADD medication
18:44:23 <SamB_XP> dmwit: so, would you say it's a bit of a wash?
18:44:58 <dmwit> ?yow!
18:44:58 <lambdabot> Couldn't find fortune file
18:45:01 <dmwit> ...
18:45:07 <insomaniac> enjoy yourselves and gn8
18:45:13 <dmwit> I found this BOOT in my DETROIT!
18:45:16 <SamB_XP> Cale: did you say you are running this bot on lispy's machine?
18:45:25 <Cale> mhm
18:45:33 <SamB_XP> lispy: seriously, install fortune-off already!
18:46:24 <MyCatVerbs> The offensive ones are the only ones worth reading anyway. :)
18:46:27 <lispy> SamB_XP: fortune-off?
18:46:43 <SamB> lispy: contains the zippy-the-pinhead quotes
18:46:57 <dmwit> apt-get install fortune-off # get the offensive fortune files
18:47:03 <SamB> hmm, maybe Igot the name a bit wrong
18:47:04 <dmwit> Might need a dash of sudo in front.
18:47:06 <MyCatVerbs> lispy: most distros package the offensive fortune databases separately from the inoffensive ones.
18:47:21 <SamB> fortunes-off
18:47:27 <the_unmaker> happs --- i had trouble installing it
18:47:47 <dmwit> the_unmaker: Did you try cabal-install?  It's the new big thing.
18:47:53 <lispy> SamB: done
18:47:58 <dmwit> ?yow!
18:47:59 <lambdabot> Couldn't find fortune file
18:48:01 <dmwit> =/
18:49:15 <SamB> Cale: now you can tell lambdabot to look in /usr/share/games/fortunes/zippy for the fortune database
18:49:30 <ddarius> Whew.
18:49:39 <SamB> dmwit: dons kept the file in his homedir for some reason
18:50:36 <SamB> @list yow
18:50:37 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
18:50:49 <SamB> @protontorpedo
18:50:49 <lambdabot> how can haskell automate ftp?
18:50:50 * mmorrow just realizes that ***all*** code that uses exceptions in pretty much any way will become immediately and completely broken with 6.10
18:51:04 <SamB> mmorrow: is 6.10 out yet?
18:51:16 <Saizan_> mmorrow: why?
18:51:20 <bjrn> How does exceptions work in a purely functional language anyway?
18:51:21 <SamB> mmorrow: because otherwise I think nominolo was planning to fix that
18:51:26 <mmorrow> no, but s/6.10/6.9 as of at least last week/
18:51:30 <thoughtpolice> mmorrow: there's base3-compat?
18:51:48 <thoughtpolice> i just built latest HEAD, the whole 'no package repo found' thing was finally fixed
18:51:50 <SamB> mmorrow: nominolo has been changing the workings
18:52:36 <mmorrow> um, i dunno what just happened
18:52:38 <mmorrow> anyway
18:52:42 * mmorrow sighs with relief
18:52:51 <lispy> I wish we had checked exceptions other than just MonadError and the ad-hoc exceptions
18:53:05 <SamB> lispy: hmm?
18:53:11 <mmorrow> lispy: yeah, how do you mean?
18:53:26 <lispy> do you know what checked exceptions are in Java terminology?
18:53:29 <SamB> who we, checked them for what in what?
18:53:31 <SamB> oh.
18:53:42 <SamB> I thought you were talking about test coverage ;-P
18:53:59 <mmorrow> thoughtpolice: yeah, the no package repo found thing is nicely gone
18:54:18 <sjanssen_> gwern: BotPP is dead!
18:54:31 <SamB> sjanssen_: sweet
18:54:32 <Saizan_> long life to BotPP!
18:55:02 <Saizan_> sjanssen: how? you replaced the sources with the preprocessed ones?
18:55:09 <lispy> bjrn: they are monadic
18:55:27 <mmorrow> sjanssen_: how did you do it? (i saw mention of TH, then read the logs and pulled the curr lb and was reading)
18:55:53 <Cale> Aha! I didn't even realise there was a config for this in Config.hs
18:56:15 <the_unmaker> any one got a happs website up?
18:56:21 <MarcWeber> Saizan_: I'm trying the haskellcafe mailinglist now. Maybe a type level programming guru knows how to do some further speed enhancements.. Let's hope for the best
18:56:48 <sjanssen> Saizan_: TH
18:57:00 <sjanssen> mmorrow: I just pushed my patch, that is probably the best explanation
18:57:04 <Cale> There's another path here... fptoolsPath which used to point at /home/dons/fptools
18:57:11 <Cale> Is there any purpose to that?
18:57:17 <sjanssen> we have to write the import statements ourselves, but otherwise boilerplate is equivalent
18:57:33 <mmorrow> did you just (runIO doStuff) or something equiv?
18:57:35 <mmorrow> ohh
18:57:38 * mmorrow pulls
18:58:29 <sjanssen> also, the ghci script works now.  Did it actually work before?
18:59:53 <Cale> @yow ?
18:59:59 <dmhouse_> @yow!
19:00:00 <lambdabot> All this time I've been VIEWING a RUSSIAN MIDGET SODOMIZE a HOUSECAT!
19:00:00 <the_unmaker> HAppS-IxSet — Efficient relational queries on Haskell sets.
19:00:00 <the_unmaker> darcs get --partial --tag=0.9.2 http://happs.org/repos/HAppS-IxSet
19:00:00 <the_unmaker> Just pick which parts of your data structures you want indexed using an easy to use template-haskell function. Spare yourself the need to write, run, and maintain code that marshalls your data to/from an external relational database just for efficient queries. IxSet relies on generics and TH to spare you the boilerplate normally required for such tasks.
19:00:04 <dcoutts> dons: pong
19:00:05 <mmorrow> sjanssen: ah nice, do the imports ahead of time for TH
19:00:16 <sjanssen> mmorrow: right.  I wish there were a better way
19:00:17 <dmhouse_> @yow
19:00:17 <lambdabot> Plugin `quote' failed with: thread killed
19:00:22 <dmhouse_> @yow!
19:00:24 <the_unmaker> can haskell queries like this be fast?
19:00:25 <lambdabot> I'm pretending that we're all watching PHIL SILVERS instead of RICARDO
19:00:27 <mmorrow> sjanssen: me too.
19:00:28 <the_unmaker> fater than mysql etc?
19:00:31 <lambdabot> MONTALBAN!
19:00:38 <sjanssen> mmorrow: perhaps if TH provided a way to inspect the list of imports?
19:00:43 <lambdabot> Plugin `quote' failed with: thread killed
19:00:53 <dmhouse_> Weirdness.
19:01:02 <mmorrow> sjanssen: i've got a way to do that, i'll paste in a few
19:01:19 <sjanssen> mmorrow: then we could simply attempt to reify theModule from each imported module
19:01:51 <mmorrow> sjanssen: ooh, that sounds nice
19:01:58 <sjanssen> @yow
19:02:01 <dmhouse_> @localtime dmhouse_
19:02:03 <sjanssen> > 1
19:02:03 <mmorrow> the one thing is though, you need the newer TH package
19:02:04 <lambdabot> SANTA CLAUS comes down a FIRE ESCAPE wearing bright blue LEG WARMERS
19:02:10 * sjanssen hopes he didn't break it
19:02:12 <lambdabot> ... He scrubs the POPE with a mild soap or detergent for 15 minutes,
19:02:14 <lambdabot>  1
19:02:20 <dmhouse_> Seems to be running pretty slowly.
19:02:20 <lambdabot> Plugin `quote' failed with: thread killed
19:02:40 <sjanssen> is lambdabot's box under heavy load?
19:02:53 <mmorrow> sjanssen: the one with        qLocation :: m Loc     in Quasi  instead of qCurrentModule
19:03:01 <dmhouse_> Anyway, it's bedtime.
19:03:32 <Cale> @seen check
19:03:32 <lambdabot> I haven't seen check.
19:03:45 <mmorrow> sjanssen: well, actually since the names and relative file locations are know ahead of time, that's get-around-able
19:03:53 <mmorrow> *known
19:04:02 <Heffalump> gah, cabal-install doesn't have a remove command!
19:04:24 <dcoutts> Heffalump: we don't track installed files yet
19:05:02 <Heffalump> oh well :-)
19:05:06 * Heffalump unregisters instead
19:05:10 <dcoutts> Heffalump: it's primarily because the install code in the Cabal lib just does the install, rather than deciding what files it will install and then doing it.
19:05:20 <mmorrow> sjanssen: what/where is 'theModule'?
19:05:49 <sjanssen> mmorrow: each plugin exports a value "theModule :: MODULE"
19:06:01 <dcoutts> Heffalump: so there's no intermediate point to collect the file list, unless we go and do an install into an image dir, but that's a bit tiresome
19:06:08 <mmorrow> sjanssen: ah, gotcha.
19:06:28 <sjanssen> mmorrow: so what do we do?  Get the current file, and parse out the imports ourselves?
19:06:59 <mmorrow> sjanssen: ahh, now i actually gotcha.
19:07:15 <mmorrow> sjanssen: yeah, parse with haskell-src-exts, then pattern-match-extract the import list
19:07:42 <mmorrow> i already have all the code to do the various parts of that, i just have to get it together in one place. 10 min
19:08:46 <mmorrow> so since we know the filename /ahead/ of time, we can get by without the Loc datatype in the new TH package
19:10:29 <sjanssen> true
19:11:01 <L3v1> Hi all.
19:12:02 <Cale> hello
19:12:18 * chrisdone moonwalks over L3v1's lawn
19:13:03 <dmwit> chrisdone.  adding the surreal one sentence at a time.
19:13:18 <dmwit> Now available in mint and lemon.
19:15:20 * chrisdone beams
19:15:52 * ddarius beams, struts, and crossbars.
19:16:05 <L3v1> On reading Functional Programming, I notice that the Gofer-interpreter can show how many reductions and cells being used. How can I open it in GHCi ?
19:16:21 <dmwit> ghci doesn't have that feature
19:16:35 <L3v1> Oh,, pity.
19:16:37 <dmwit> Hugs does, though.  I guess that's what you meant by Gofer interpreter?
19:17:05 <L3v1> Sorry?
19:17:19 <dons> you could install Gofer.
19:17:26 <dons> dmwit: Gofer is the father of Hugs
19:17:31 <dmwit> "hugs" is the modern equivalent of Gofer.
19:17:35 <dmwit> dons: Right.
19:17:41 <dons> gofer supports n*m+k patterns.
19:17:52 <dmwit> ...wat
19:17:57 <Olathe> Gophers aren't for hugging.
19:18:11 <dons> n * m + k
19:18:32 <L3v1> This feature is a very useful feature, I think.
19:19:15 <L3v1> I'll try Hugs. thx alot.
19:19:42 <dons> remember what hugs stands for :)
19:19:43 <SamB> @yow
19:19:43 <lambdabot> HAIR TONICS, please!!
19:19:51 <SamB> Cale: good job ;-)
19:19:52 <lispy> hmm..no I forgot
19:20:00 <dons> "haskell users gofer system"
19:20:02 <ramdomname4524> I don't understand why foldl has a different type [b]
19:20:07 <dons> :t foldl
19:20:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:20:13 <SamB> lispy: you also, good job ;-)
19:20:22 <lispy> SamB: thanks! glad I could help
19:20:27 <Cale> ramdomname4524: Could you elaborate?
19:20:27 <dons> the input list can be a different type to the accumulated state
19:20:28 * lispy hugs lambdabot 
19:20:33 <dmwit_> ramdomname4524: The a's/b's are switched.
19:20:34 <SamB> dons: doesn't it make you so happy to see yow working again ?
19:20:38 <Cale> ramdomname4524: What type do you think it should have?
19:20:39 <dons> lambdabot seems rather responsive and awesome.
19:20:41 <ramdomname4524> ok so I want to fold a list to a list of another type.
19:20:43 <ddarius> lispy: Exception: Stack overflow
19:20:48 <dmwit_> ramdomname4524: foldl :: (b -> a -> b) -> b -> [a] -> b
19:21:01 <lispy> ddarius: hi!  Say what?
19:21:16 <ramdomname4524> I think it should be foldl :: (a -> b -> a) -> b -> [b] -> a
19:21:19 <Cale> > foldl (flip (:)) [] [1,2,3,4]
19:21:21 <lambdabot>  [4,3,2,1]
19:21:52 <Cale> randomity: Okay, so suppose I hand you a function (a -> b -> a), and a value of type b, and a list of values of type b
19:22:00 <Cale> er, ramdomname4524 rather
19:22:03 <L3v1> cale: i prefer foldl'. :)
19:22:15 <Cale> ramdomname4524: Now, how can you apply that function?
19:22:28 <Cale> ramdomname4524: You'll need a value of type a, right?
19:22:37 <Cale> ramdomname4524: But you don't have one, or any way to get one.
19:22:43 <ramdomname4524> true.
19:22:45 <lispy> Cale: if I'm reading correctly ramdomname4524 is teasing and just doing an alpha substitution of to swap a and b
19:22:55 <Cale> lispy: He didn't though.
19:22:56 <ddarius> lispy: You aren't reading correctly.
19:23:00 <lispy> oh okay
19:23:13 * lispy shuts up
19:23:19 <lispy> psych!
19:23:25 <Cale> @yow
19:23:26 <lambdabot> The fact that 47 PEOPLE are yelling and sweat is cascading down my
19:23:26 <lambdabot> SPINAL COLUMN is fairly enjoyable!!
19:23:42 <lispy> ?vixen go on
19:23:42 <lambdabot> i was finished
19:23:45 <ramdomname4524> Cale: then why is there another type b is it just for readability?
19:23:49 <SamB> hah
19:23:56 <SamB> ?vixen are you certain?
19:23:57 <lambdabot> yes, i am
19:23:58 <dons> so why is lambdabot suddenly so happy?
19:24:04 <SamB> ?vixen really truly
19:24:05 <lambdabot> really really?
19:24:08 <SamB> ?vixen really truly?
19:24:08 <lambdabot> yup, really
19:24:12 <SamB> ?vixen really truly
19:24:12 <lambdabot> really!?
19:24:12 <ddarius> ?vixen why are you so happy?
19:24:12 <lambdabot> just the way God made me
19:24:18 <Cale> ramdomname4524: Well, what if the type of the result of the fold is not the same as the type of the elements of the list?
19:24:20 <lispy> dons: didn't you hear?  Vixen and I are dating now...
19:24:22 <dons> :)
19:24:22 <SamB> ?vixen happy?
19:24:23 <lambdabot> no
19:24:25 <SamB> ?vixen happy?
19:24:25 <lambdabot> whoa whoa whoa, one question at a time!
19:24:27 <SamB> ?vixen happy
19:24:27 <lambdabot>  key
19:24:45 <Olathe> @vixen Why ?
19:24:45 <lambdabot> good question
19:24:46 <ramdomname4524> Cale: but you need it to be or you can't apply the function
19:24:48 <lispy> ?vixen who's a sexy bot?
19:24:49 <lambdabot> bots should be destroyed. they are so annoying
19:24:54 <pjdelport> :t foldl1
19:24:55 <Cale> ramdomname4524: Not true at all :)
19:24:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
19:24:58 <pjdelport> :t foldl
19:24:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:25:00 <Olathe> @vixen What is your quest ?
19:25:00 <lambdabot> is that really what you want to know?
19:25:08 <pjdelport> randomity: compare -^
19:25:29 <dmwit_> People!  The third letter  in ramdomname4524's nick is 'm'.
19:25:46 <ramdomname4524> heh
19:26:16 <Olathe> dmwit_: That was a completely ramdom observation.
19:26:25 <Cale> ramdomname4524: Have a look at this fold:
19:26:35 <Cale> > foldl (flip (:)) [] [1,2,3,4]
19:26:37 <lambdabot>  [4,3,2,1]
19:26:52 <ramdomname4524> > let addTuple (a,b) (c,d) = (a+b,c+d,a+d)
19:26:53 <lambdabot>  mueval: Prelude.read: no parse
19:26:57 <Cale> There's an example where the type of the result is not the same as the type of the elements of the list.
19:27:06 <Cale> :t flip (:)
19:27:07 <lambdabot> forall a. [a] -> a -> [a]
19:27:17 <Cale> :t []
19:27:18 <lambdabot> forall a. [a]
19:27:22 <pjdelport> > foldr ((+) . length) 0 ["hello","world"]
19:27:23 <lambdabot>  10
19:27:36 <pjdelport> ramdomname4524: there's another example
19:27:48 <ramdomname4524> ok
19:28:22 <lispy> ramdomname4524: you get how map's type signature works, right?
19:28:34 <Cale> > let myMap f = foldr ((:) . f) [] in myMap (*2) [1..10]
19:28:41 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
19:28:43 <Olathe> > foldl (flip ((:) . repeat)) [] [1,2,3,4]
19:28:45 <lambdabot>  [[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
19:28:57 <pjdelport> ramdomname4524: the foldr1 and foldl1 variants of the function don't take a separate starting value for the accumulator, and instead use the input list
19:29:03 <pjdelport> that's why they're constrained to be the same type
19:29:11 <pjdelport> you would not be able to use them to do the above
19:29:30 <ramdomname4524> pjdelport: that makes sense
19:35:35 <mmorrow> sjansenn: ok, all set: http://code.haskell.org/~morrow/code/haskell/Imports.hs
19:49:59 <mmorrow> @tell sjanssen http://code.haskell.org/~morrow/code/haskell/Imports.hs  which i added to a fresh lb repo and put  http://code.haskell.org/~morrow/lambdabot/
19:49:59 <lambdabot> Consider it noted.
19:53:39 <ramdomname4524> http://pastebin.com/m4981070c
19:55:20 * sw17ch has a brand new Asus Eee 901... and it's building cabal :D
19:55:34 <sw17ch> not very willingly though
19:55:52 <ramdomname4524> I think I know why that code doesn't work. Is there a way to reference a function without having it trying to capture arguments?
19:56:02 <mmorrow> randomname4524: s/( a -> b -> b) b -> [a] -> b/( a -> b -> b) -> b -> [a] -> b/
19:56:16 <ramdomname4524> ah
19:56:32 <dcoutts> sw17ch: yay :-)
20:01:31 <obk> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html (somewhat NSFW) has just made it to Reddit's top. I wouldn't have mentioned it if it weren't such a perfect description of my, ahem, "relationship with Haskell" :-)
20:02:40 <shepheb> obk: that was spotted a while back. brilliant, IMO
20:03:26 <obk> I was ROTFL
20:03:37 <obk> I'm sort of at "The Choice" point
20:04:14 <obk> I got as far as I can without committment - and, well, I can't really commit to Haskel...
20:05:19 <mmorrow> obk: life only happens once
20:06:01 <mmorrow> or were you quoting ....
20:06:22 <mmorrow> either way the fact remains
20:06:38 <shepheb> I chose Haskell. She beats my brain sometimes, but I can't wait for more.
20:06:50 * BMeph feels a little squicked-out, thinking about how many men have "banged away in comfort" with Java...
20:07:27 <obk> Well, the bitch of it is that you only live once - and you got to eat
20:07:39 <ramdomname4524> BMeph: how do you feel about scala?
20:07:57 <obk> Scala is very interesting, actually
20:08:28 <obk> She has a fighting chance of becoming "respectable"
20:09:02 <obk> But... she isn't Haskell ;-)
20:09:09 <mmorrow> obk: respectable to whom?
20:09:24 <obk> Well, Java shops, of which there are plenty
20:09:35 <mmorrow> ah.
20:09:57 <obk> They can do a mixed-environment prigramming, Java libraries and Scala home code
20:10:09 <obk> And there are a lot of Java libraries out there...
20:10:19 <obk> Sort of the way C++ took over C
20:10:36 <BMeph> ramdomname4524: Scala's an interesting idea, but I haven't delved too deeply. I just peer over DRMacIver's shoulder (AKA his blog), mostly. :)
20:11:01 <obk> me too - I haven't actually coded in it
20:11:13 <obk> But the docs look interesting, cool concepts
20:11:13 <ramdomname4524> I decided to start learning haskell instead
20:11:24 <obk> Likewise :-)
20:11:36 <mmorrow> yay!
20:11:58 <obk> My company is a C# shop anyway... so it isn't like Scala had any chance there
20:12:24 * obk sighs
20:12:25 <ddarius> F#
20:12:39 <obk> Now that is a tough sell
20:12:59 <BMeph> obk: Interesting thread. I read Stephen Williams' response, and thought to myself, "Bitter, party of one, your table's ready..." ;)
20:13:02 <obk> C# shops are all about VisualStudio support and F# doesn't have much support there. It works - barely
20:13:34 <ramdomname4524> I think scala and F# could gain support if more libraries were written in them.
20:13:46 <ramdomname4524> then it would seem "normal"
20:13:57 <ramdomname4524> since people would be using libraries that used those langauges
20:14:13 <obk> F# realy needs MS to make it a formal part of the VS release - intellisense, docs, etc. - then it would get great traction
20:14:49 <obk> But like IronRuby etc., it is just almost-sort-of supported, and MS shops are horribly conservative, no way they'll adopt it
20:15:13 <chrisdone> it's neat how you learn haskell because you are drawn in by the purely functional paradigm, and then you find loads more things like algebraic data types, monad abstractions, arrows and applicative, lack of objects... so that when people say “well, it's not haskell, but at least X is functional”, it's just not the same at all
20:15:42 <mmorrow> well put
20:15:50 * obk nods in agreement
20:16:20 <b\6> i feel like i missed the big revelation by 2 seconds.
20:16:32 <rwbarton> @yow
20:16:33 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
20:16:33 <lambdabot> legislation...
20:16:43 <ramdomname4524> I like pattern matching in haskell.
20:16:44 <mmorrow> @yow
20:16:44 <lambdabot> Look into my eyes and try to forget that you have a Macy's charge card!
20:17:03 <TomMD> I think there is a growing army of ex-Imeritivists whos thinking goes Function iff Pure, ADT, Monads, Functions 1st class.
20:17:06 <obk> Lambdabot is waxing poetic tonight
20:17:49 <shepheb> @remember chrisdone it's neat how you learn haskell because you are drawn in by the purely functional paradigm, and then you find loads more things like algebraic data types, monad abstractions, arrows and applicative, lack of objects... so that when people say "well, it's not haskell, but at least X is functional", it's just not the same at all
20:17:49 <lambdabot> Nice!
20:18:00 <TomMD> b\6: See that 'remember'
20:18:03 <b\6> ok, thanks.
20:18:07 <mmorrow> @quote jack-nicholson
20:18:07 <lambdabot> jack-nicholson says: You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
20:18:17 <mmorrow> haha
20:18:28 <obk> I thought that was marketing and polic :-)
20:18:33 * chrisdone chuckles
20:18:36 <TomMD> What truth?
20:18:37 <TomMD> There is no spoon.
20:18:52 <obk> That's the truth they can't handle
20:19:20 <goodmanson> hey
20:19:31 <mmorrow> my fav lambdabot yow is
20:19:34 <mmorrow> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with MISSILES!!
20:19:39 <TomMD> hello goodmanson.  If this is your first time here you'll want to see the FAQ.
20:19:41 <mmorrow> goodmanson: hey!
20:19:47 <ramdomname4524> I don't think I'll really be programming in haskell professionally anytime soon though.
20:20:02 <TomMD> @faq What is the answer to goodmanson's question about Haskell?
20:20:02 <lambdabot> The answer is: Yes! Haskell can do that.
20:20:12 <goodmanson> lol
20:20:18 <ajdhs> @quote
20:20:19 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious!
20:20:22 <goodmanson> r u real ppl ?
20:20:28 <dmwit> nope
20:20:32 <dmwit> bots, every one of us
20:20:35 <TomMD> I am a bot, but lambdabot is a programmer.
20:20:46 <shepheb> lambdabot coded dons, who coded us all.
20:20:47 <mmorrow> goodmanson: lol
20:20:50 <dmwit> goodmanson: impressed yet?  Wait till you see our FRUIT!
20:20:54 * obk hasn't taken the Turing test in a while so he doesn't know
20:20:55 <TomMD> @let truth =  (const "Yes")
20:20:56 <lambdabot> Defined.
20:21:07 <goodmanson> nice
20:21:09 <TomMD> > truth "Are you a programmer?"
20:21:10 <lambdabot>  "Yes"
20:21:20 <mmorrow> > fix ((0:) . scanl (+) 1)
20:21:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:21:22 <ramdomname4524> truth "Are you a program?"
20:21:37 <dmwit> > truth "Are you a program?"
20:21:38 <lambdabot>  "Yes"
20:21:40 <goodmanson> nice to meet u ppl
20:21:53 <dmwit> > truth "Is there an element in the set of elements not in the set?"
20:21:54 <lambdabot>  "Yes"
20:22:14 <ramdomname4524> truth "Is an absurdity true?"
20:22:19 <ramdomname4524> > truth "Is an absurdity true?"
20:22:21 <lambdabot>  "Yes"
20:22:30 <mmorrow> > truth "is the color of dentist's offices the new black?"
20:22:31 <lambdabot>  "Yes"
20:22:32 <ramdomname4524> I broke the universe.
20:22:42 <Cale> @type fix id
20:22:43 <lambdabot> forall a. a
20:23:48 <chrisdone> mmorrow: I once made a scheme bot that pretended to be other people, but with tourettes
20:23:59 <TomMD> Humm.  He was short lived.
20:24:02 <mmorrow> hahah
20:24:55 <roconnor> > fix truth
20:24:57 <lambdabot>  "Yes"
20:25:12 <TomMD> You can't fix the truth!
20:25:33 <rwbarton> > handle truth
20:25:34 <lambdabot>      Overlapping instances for Show (((b, ex) -> [Char]) -> b -> [Char])
20:25:34 <lambdabot>     ...
20:25:38 <Cale> chrisdone: Did it change its nick to a mock version of their nick?
20:25:40 <TomMD> It is what it is!
20:25:42 <TomMD> @type truth
20:25:42 <SamB_XP> you can't handle the truth!
20:25:43 <lambdabot> forall b. b -> [Char]
20:25:50 <SamB_XP> @type handle
20:25:51 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
20:32:51 <newsham> ?hoogle Handle -> Bool
20:32:51 <lambdabot> System.IO hGetEcho :: Handle -> IO Bool
20:32:51 <lambdabot> System.IO hIsClosed :: Handle -> IO Bool
20:32:51 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
20:33:16 <newsham> True <- hIsEof handle
20:33:50 <newsham> ?type Bool -> Handle
20:33:51 <lambdabot> parse error on input `->'
20:33:58 <newsham> ?hoogle Bool -> Handle
20:33:59 <lambdabot> Control.Exception assert :: Bool -> a -> a
20:33:59 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
20:33:59 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:44:32 <Kip0130> I want to learn haskell any decent books?
20:45:09 <roconnor> Kip0130: are you coming from another language?
20:45:43 <Kip0130> unless you count dabbling in python 3 years ago
20:46:50 <roconnor> http://haskell.org/haskellwiki/Learning_Haskell
20:46:51 <lambdabot> Title: Learning Haskell - HaskellWiki
20:47:02 <Kip0130> I would figure it would be be better for me to learn C# first?
20:47:10 <roconnor> no no
20:47:20 <mbz> no C#
20:47:22 <dmwit> Haskell is a great first language.
20:47:28 <roconnor> that would be harmful :D
20:47:36 <Kip0130> ah ok
20:47:53 <dmwit> You might like Real World Haskell.
20:48:22 <Kip0130> *goes to amazon*
20:48:41 <dmwit> I don't think it's there yet.
20:48:48 <Kip0130> ergh
20:49:02 <dmwit> http://book.realworldhaskell.org/
20:49:13 <lambdabot> Title: Real World Haskell
20:49:28 <Kip0130> its there
20:49:47 <roconnor> http://www.amazon.com/gp/product/0596514980?ie=UTF8&tag=reaworhas-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596514980
20:49:50 <lambdabot> http://tinyurl.com/5ow2fw
20:49:52 <dmwit> Oh!  I stand corrected!
20:50:04 <dmwit> It's not published yet, though.
20:50:04 <roconnor> This title has not yet been released.
20:50:15 <Kip0130> Then i shall wait
20:50:35 <roconnor> Kip0130: you can download the online version I think
20:50:45 <Kip0130> I'm not much into PDF reading
20:50:53 <Kip0130> i get distracted easily when doing that
20:50:53 * roconnor nods
20:51:08 <Kip0130> and the white space on the screen kills me
20:51:20 <roconnor> what do people think of http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/ ?
20:51:21 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
20:52:00 <Kip0130> I'm off to sleep
20:52:08 <Kip0130> 12 hour shift tommrrow
20:52:17 <roconnor> sleep well
20:57:48 <designs703> Prelude> "¡Hola, mundo!
20:57:48 <designs703> <interactive>:1:14: lexical error in string/character literal at end of input
20:57:57 <designs703> Prelude> "triste..."
20:57:58 <designs703> "triste..."
20:58:12 <designs703> Why can't I use "¡" in a string?
20:58:30 <ivanm> designs703: use utf8-string
20:58:38 <designs703> ok
20:58:57 <ivanm> because IIRC, it uses plain 'ol ASCII by default (even though internally it's unicode codepoints)
20:59:05 <ivanm> *shrug* something like that :p
20:59:41 <designs703> how do I import utf-8. Is it in the standard library? I'm googling around
21:00:29 <ivanm> nope, you have to install it first
21:00:39 <ivanm> @where utf8
21:00:39 <lambdabot> I know nothing about utf8.
21:00:43 <pjdelport> % ghci --help
21:00:44 <pjdelport> ghc-6.8.3: cannot use `--interactive' with `--help'
21:00:44 <pjdelport> Usage: For basic information, try the `--help' option.
21:00:58 <pjdelport> perhaps that could be better stated
21:00:59 <ivanm> http://code.haskell.org/utf8-string/
21:00:59 <lambdabot> Title: Index of /utf8-string
21:00:59 <designs703> this is interesting:
21:01:00 <designs703> Prelude> import Data.ByteString.Char8
21:01:01 <designs703> Prelude Data.ByteString.Char8> "¡"
21:01:01 <designs703> "\161"
21:01:47 <dmwit> designs703: I think you just didn't terminate the string the first time.
21:01:59 <designs703> I guess I'll just use English for now
21:02:11 <pjdelport> > "¡Hola, mundo!"
21:02:12 <dmwit> designs703: i.e. ¡ is just fine
21:02:12 <lambdabot>  "\161Hola, mundo!"
21:02:15 <pjdelport> > "¡Hola, mundo!
21:02:16 <lambdabot>      lexical error in string/character literal at character '\n'
21:02:25 <designs703> hm
21:02:55 <designs703> worked there. I must've missed something
21:03:09 <adu> ?t ()
21:03:09 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:03:10 <dmwit> Yeah, you were just missing a closing " character.
21:03:11 <designs703> but I need to pass that through utf8 to output the appropriate chars
21:03:15 <designs703> haha oops
21:03:18 <designs703> just noticed that
21:03:24 <TehZorroness> (noob question) you have to use 'return' when in an action (do)?
21:03:29 <dmwit> designs703: No, no need to do anything special.
21:03:29 <adu> @t ()
21:03:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:03:44 <dmwit> designs703: Try 'putStr "¡"' to see what I mean.
21:03:53 <adu> TehZorroness: nope
21:03:54 <dmwit> TehZorroness: No.
21:03:56 <designs703> ?Hola, mundo!
21:03:56 <lambdabot> Unknown command, try @list
21:04:05 <dmwit> TehZorroness: The only restriction is that the final line in a do-block be a monadic action.
21:04:09 <designs703> ! becomes ?
21:04:46 <dmwit> designs703: I blame your terminal.
21:04:53 <TehZorroness> is return a monadic action?
21:04:56 <rwbarton> TehZorroness: 'return x' is an "action" that does nothing and produces the value x
21:04:58 <adu> TehZorroness: as long as the type is (Monad m => m a) then you're fine. Since (return :: Monad m => a -> m a) then many ppl end their do-blocks with "return" but you don't have to
21:05:07 <dmwit> designs703: So... yes, you were right.  You *do* need to utf-8 encode it first. =P
21:05:15 <designs703> reasonable enough. I'll have to try with a text file as the input
21:05:40 <designs703> No Mac terminal is UTF-8
21:05:58 <dmwit> designs703: Yes, but ghc doesn't produce UTF-8 output by default. =/
21:06:06 <designs703> hm
21:06:22 <shepheb> there if utf8-string, though
21:06:32 <dmwit> right
21:06:37 <adu> TehZorroness: actually no "return" is not monadic, but "return x" is
21:06:44 <dmwit> There are libraries to do that stuff for you.
21:07:12 <adu> TehZorroness: return is a function that takes one argument and returns a monad
21:07:35 <dmwit> Pedantic mode: return is a function that takes an argument and returns an element of a monad
21:08:07 <designs703> ok, I'll take a look, thanks for the help!
21:08:10 <adu> dmwit: sorry for butchering my terminology
21:09:20 * rwbarton notes that further pedantry is easily possible
21:09:27 <adu> lol
21:09:38 <TehZorroness> thanks for the advice everyone.  my number adder seems to work now (everyone starts somewhere :)
21:11:26 <adu> TehZorroness: soon enuf, you'll be teaching me parser monad transformer theory :)
21:12:08 <TehZorroness> before that (even sooner!), I'll have to find out what that means :)
21:13:03 <dmwit> lots of fancy, precise words for very simple ideas
21:13:05 <adu> TehZorroness: something that lets you "insert" print statements in the middle of a non-IO monad
21:13:24 <ramdomname4524> > repeat 4
21:13:26 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:13:47 <ramdomname4524> cycle repeat 4
21:13:48 <waynemokane> if you have a plain state machine like State s, is it difficult to retrofit it for debugging?
21:13:50 <ramdomname4524> > cycle repeat 4
21:13:51 <lambdabot>  Couldn't match expected type `[a]'
21:13:58 <ddarius> dmwit: Monads don't have elements
21:14:04 <ramdomname4524> ah statemachines..
21:14:10 <adu> waynemokane: you know, monad transformers might work for that too
21:14:20 <ramdomname4524> I like to use regular expressions to model state machines.
21:14:25 <dmwit> ddarius: What is the category-analog of element?
21:14:27 <waynemokane> adu: yeah I mean... you can lift it into a StateT, true
21:14:48 <TehZorroness> Is it possible to turn a list into a ring like you can in lisp (that would be dangerous for lambdabot's health. hehe)
21:14:48 <adu> dmwit: object?
21:15:09 <ramdomname4524> > cycle (repeat 4)
21:15:10 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:15:22 <Cale> > repeat 4
21:15:24 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:15:27 <Cale> > cycle [4]
21:15:28 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:15:28 <TehZorroness> I remember a while ago I made the list's end point at it's start and the interpreter died a bloody death
21:15:32 <adu> :t (.*.)
21:15:33 <lambdabot> Not in scope: `.*.'
21:15:36 <dmwit> waynemokane: If you did it right (i.e. using MonadState instead of State in your type sigs), then it should be pretty trivial to turn it into a StateT s IO.
21:15:38 <ddarius> dmwit: An arrow from the terminal object (though there are "generalized elements" which are just arrows).  However, an arrow from the terminal object in the category of monads is definitely not what return is or returns.
21:15:56 <waynemokane> dmwit: ah interesting, I'll have to check into that
21:16:00 <waynemokane> dmwit: thanks
21:16:01 <Cale> TehZorroness: Haskell is fine with infinite lists.
21:16:06 <Cale> > let x = 1 : x in x
21:16:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:16:12 <TehZorroness> ohh yeah
21:16:21 <TehZorroness> that's one of it's defining features
21:16:25 <TehZorroness> please shoot me :)
21:16:40 <dmwit> ddarius: Okay, I clearly still have much to learn. =)
21:16:53 <TehZorroness> (it's not like these people are constantly doing it to the bot right now as we speak or anything)
21:16:54 <adu> > nubBy (((>1).).gcd) [2..]
21:16:55 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:16:59 <adu> and good with primes too
21:17:54 <Cale> We ought to make a better algorithm for generating the primes possible to write as a quick oneliner :)
21:17:55 <ramdomname4524> replicate 4 3
21:17:58 <ramdomname4524> > replicate 4 3
21:17:59 <lambdabot>  [3,3,3,3]
21:18:12 <Cale> > replicate 4 (replicate 4 3)
21:18:13 <lambdabot>  [[3,3,3,3],[3,3,3,3],[3,3,3,3],[3,3,3,3]]
21:18:31 <ramdomname4524> mersenne primes are cheating
21:18:33 <rwbarton> > extendSequence [2,3,5,7,11]
21:18:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:18:38 <adu> Cale: we could write an isPrime function, and use "filter isPrime" instead...
21:18:42 <Cale> heh, there is that :)
21:19:05 <Cale> (but that list is not really infinite :)
21:19:17 <adu> wtf is extendSequence?
21:19:18 <Cale> > length (extendSequence [2,3,5,7,11])
21:19:20 <lambdabot>  58
21:19:32 <Cale> > extendSequence [1,1,2,3,5]
21:19:34 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:19:45 <dmwit> adu: It plugs into OEIS.
21:19:47 <Cale> > extendSequence [1,1,2,6]
21:19:49 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:19:49 <ddarius> > length . extendSequence . extendSequence $ [2,3,5,7,11]
21:19:50 <adu> dmwit: cool
21:19:52 <lambdabot>  58
21:20:02 <Trinithis> @src extendSequence
21:20:02 <lambdabot> Source not found. You speak an infinite deal of nothing
21:20:17 <Cale> Trinithis: See the oeis package on hackage.
21:20:27 <ramdomname4524> > fibonacci
21:20:28 <lambdabot>  mueval: Prelude.read: no parse
21:20:30 <Cale> > describeSequence [2,3,5,7]
21:20:32 <lambdabot>  Just "The prime numbers."
21:20:32 <Trinithis> Is it like a smarter [..] ?
21:20:37 <adu> Cale: so how do you think we should implement isPrime? some kind of general field sieve or something?
21:20:40 <ddarius> @check \xs -> extendSequence xs == extendSequence (extendSequence xs)
21:20:43 <lambdabot>  mueval: Time limit exceeded
21:20:49 <Korollary> @type describeSequence
21:20:50 <lambdabot> SequenceData -> Maybe String
21:20:56 <adu> Cale: or that x^2 == y^2 thing
21:21:16 <bos> @seen dons
21:21:16 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 1h 24m 56s ago.
21:21:20 <adu> ?hoogle isPrime
21:21:20 <lambdabot> No results found
21:21:22 <adu> :(
21:21:30 <Cale> adu: Well, it would be interesting to see if there's a higher order function which would let us write the *real* Sieve of Eratosthenes.
21:21:49 <Korollary> > describeSequence "haskell"
21:21:50 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Char'
21:22:02 <ddarius> Cale: Sitting around in the standard libraries?
21:22:05 <ramdomname4524> Does anyone know of a programming language that given a program it tries to deterimine what data structures and algorithms to use and determine memory layout?
21:22:19 <adu> ramdomname4524: prolog
21:22:26 <Korollary> > describeSequence (map ord "haskell")
21:22:27 <Cale> ddarius: Something which could reasonably go into the standard libraries.
21:22:27 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
21:22:45 <Spark> ramdomname4524: all languages decide memory layout, but data structures and algorithms are always left to the programmer
21:22:46 <ddarius> Cale: Perhaps we should look at J.
21:22:50 <Cale> ddarius: (that is, it should have uses beyond writing just the sieve :)
21:22:57 <ramdomname4524> Spark: why do they have to be?
21:23:03 <dmwit> > describeSequence (map (fromIntegral . ord) "haskell")
21:23:04 <lambdabot>  Nothing
21:23:15 <Spark> ramdomname4524: because usually the programmer needs control over these things
21:23:23 <Korollary> > describeSequence (map (fromIntegral . ord) "haskell")
21:23:24 <adu> Cale: like uniqueness in decomposability of datatypes or something?
21:23:24 <lambdabot>  Nothing
21:23:27 <Korollary> boo
21:23:28 <Cale> I recall there was a paper/post of some kind about implementing the real infinite sieve of Eratosthenes in Haskell.
21:23:48 <dobblego> I recall that too
21:23:51 <dobblego> it was on the wiki
21:24:08 <ddarius> It was discussed on Haskell-Cafe for quite some time.
21:24:34 <ddarius> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
21:24:36 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun], http://tinyurl.com/yphbu2
21:25:09 <Cale> Calculating the Sieve of Eratosthenes
21:25:09 <Cale>     Lambert Meertens. Journal of Functional Programming, 14(6):759-763, 2004.
21:25:11 <Cale> hmm
21:27:00 <Cale> Perhaps that was not it...
21:28:42 <Cale> aha, right, the paper was linked from ddarius' link :)
21:28:51 <TehZorroness> > "Hi."
21:28:52 <lambdabot>  "Hi."
21:31:29 <ivanm> hmmm.... the sqrt signs in that paper look a little weird :s
21:32:19 <Cale> They do?
21:33:26 <ivanm> unless okular is showing them funny... the bar on top is slightly lower than the top of the surd "tick"
21:34:10 <ddarius> ivanm: It's possible that they are formed correctly, displayed correctly, and that it is your eyes that are weird.
21:34:10 <Cale> hmm... it might just be a fault in the antialiasing algorithm
21:34:20 <ivanm> ddarius: heh
21:34:34 * ivanm thinks Cale's response is more likely the correct answer
21:34:45 <Cale> They are separate outline paths, but I'm pretty sure that if you zoom in far enough you'll see that they join up nicely
21:35:10 <ivanm> they join up, just that they don't join up at the right spot
21:35:15 <Cale> Probably it's doing something wrong, like choosing a different coordinate system for antialiasing each outline.
21:35:17 * dmwit sees it too
21:35:23 <ivanm> the top bar is slightly lower :s
21:35:26 * ivanm feels vindicated!
21:35:34 <Capso> Journal of Functional Programming?
21:35:40 <dmwit> Check out page 3, the second /sqrt in the "big" formula.
21:35:51 <Capso> Hmm, that's interesting -- how academically involved is Haskell?
21:35:55 <dmwit> very
21:36:07 <Cale> Haskell is a research language :)
21:36:12 <ivanm> dmwit: I meant more as in the sqrt sign just above the code on page 3
21:36:16 <Capso> In what regards (purely programming, applications ...)?
21:36:24 <ivanm> Capso: everything!
21:36:31 <ddarius> It's perfectly fine in evince.
21:36:33 <Capso> Cale: In what way?
21:36:54 <Capso> ddarius: ePDFViewer is worth a shot, btw.
21:36:55 <ddarius> Haskell is more than a research language.
21:36:57 <dmwit> ddarius: I'm looking at it in evince.
21:37:00 <adu> Capso: Haskell is involved in 3D Game/graphics design
21:37:06 <Cale> Capso: In the sense that it was developed primarily as a collaboration between research projects.
21:37:12 <ddarius> Capso: Why would I want to use that?
21:37:14 <adu> Capso: and also cryptography and security and stuff
21:37:39 <Cale> (It's only fairly recently that it's started to receive attention as a practical language)
21:37:47 <Capso> ddarius: I've found evince to be quite slow and resource consumptive -- this application manages memory better.
21:38:04 <ivanm> Cale: you mean it's only recently that it's started to receive attention from others as a practical language?
21:38:15 <ddarius> Capso: Does it handle ps, dvi, and djvu and have continuous scrolling?
21:38:15 <ivanm> I'm sure a lot of people "researching" it thought of it as a practical language...
21:38:29 <ivanm> ddarius: epdfview IIRC is just evince - gnome stuff
21:38:35 <Cale> ivanm: Yeah, as a practical language for doing anything but research :)
21:38:41 <ivanm> lol
21:39:04 <ddarius> Cale: The Haskell 1.0 Report stated that the purpose of Haskell was more than just research.
21:39:41 <ivanm> ddarius: yes, but the researchers who wrote that probably had difficulty telling that to non-researchers :p
21:39:44 <Ilmuri> EVENTUALLY HASKELL WILL RULE THE WORLD WITH AN IRON FIST
21:39:55 <dmwit> Ilmuri: I'm scared that you might be right.
21:39:59 <Ilmuri> or perhaps with.. ters ksi
21:40:00 <ivanm> hmmm... is there any other language that's been as relatively popular/good that was designed by committee??
21:40:07 <dmwit> It's not avoiding success very well. =/
21:40:24 <ivanm> most of the "popular" langauges I've heard of were designed by one or two people IIRC...
21:40:35 <ivanm> Ilmuri: translation?
21:40:40 <Capso> Ilmuri: Sy that last sentence again? I want to see if it's just me or if screen needs to be told to use UTF-8 every time.
21:40:46 <Capso> say*
21:40:53 <Ilmuri> ivanm: just a reference to a crappy star wars fightan game
21:40:59 <dmwit> Capso: eräs käs
21:41:00 <ivanm> which one?
21:41:07 <Cale> Well, Haskell's design was mostly stolen from Miranda... how many people designed Miranda?
21:41:13 <Capso> dmwit: OK, screen sucks.
21:41:15 <Ilmuri> one with "ters ksi" in the title
21:41:18 <ivanm> Cale: true
21:41:22 <ivanm> Ilmuri: lol
21:41:35 <dmwit> Capso: I'm sure it has an rc file.
21:41:37 <Capso> Ilmuri: Huh, I can't see the chars when you type it.
21:41:44 <ddarius> Cale: It significantly extended Miranda.
21:41:50 <Capso> Different encoding?
21:41:55 <ddarius> Also, Miranda stole its design from earlier languages.
21:41:58 <ddarius> I blame Landin.
21:42:00 <ivanm> Cale: but when I recall what I read about how other langauges were created, weren't they more piecemeal development?
21:42:20 <ivanm> whereas the haskell report defined the language? (there might have been numerous extensions, etc. but that's a different story)
21:42:31 <ivanm> ddarius: who?
21:42:39 <Cale> ddarius: Mr. ISWIM?
21:42:49 <ddarius> Cale: Among other things, yes.
21:42:56 <Peaker> Capso: still, screen is great :) though shall not speaketh negatively upon screen
21:43:07 <Capso> ivanm: There's a neat mailinglist archive of some 50 posts or so, involving many computer scientists, that traces the motivations for many of the popular languages.
21:43:07 <Cale> Peaker: 'thou'
21:43:13 <Capso> haha
21:43:14 <Peaker> oops, I blame xchat
21:43:28 <ivanm> Capso: oh? where?
21:43:46 <Twey> 'shalt'
21:43:54 <Twey> 'speak'
21:43:59 <Capso> ivanm: Let me see if I can find it. And Paul Graham archived it on his site as well (though, I hate the pretentious bloke).
21:43:59 <Twey> &c.
21:44:00 <Twey> :-P
21:44:38 <Cale> X-Chat has a moderately annoying property of autocorrecting things. It always replaces teh with the. What if I meant to type teh? I have to go back and carefully edit it. :)
21:44:50 <ivanm> Cale: you can get rid of that...
21:44:59 <ivanm> it's the only default autocorrect option
21:45:03 <dons> bos
21:45:13 <Cale> I did, but it came back somehow...
21:45:25 <ddarius> It autocorrected your correction!
21:45:30 <stepcut> Cale: my favorite is when chat programs expand, rm -r, to, rf -are,
21:45:31 <ivanm> Cale: hmmm..... did you manually or automatically close xchat?
21:45:33 <Peaker> Paul Graham wrote some interesting articles, though
21:45:45 <Twey> Haha, stepcut
21:45:49 <ivanm> I've found times when if I left it open when I shut down my computer, its settings weren't saved :s
21:45:53 <Capso> Cale: No imitating Mitch Hedberg.
21:46:00 <bos> dons: i had a lot of fun tuning my bloom filter library in response to an actual user. got it to within 8% of C for small fragments of lazy bytestring.
21:46:11 <ivanm> stepcut: uhhh, what?
21:46:24 <ivanm> how does rm go to rf?
21:46:28 <dons> bos, that's awesome!
21:46:29 <ivanm> s/how/why/
21:46:33 <stepcut> ivanm: that part was just a typo
21:46:36 <ivanm> heh
21:46:49 <dons> low level hacking haskell is a lot of fun, i must say.
21:46:58 <stepcut> ivanm: i did not get to bed until 4AM last night -- I ordered decaf -- but received the real thing
21:47:01 <bos> especially with quickcheck to keep you honest.
21:47:04 <Capso> dons: But how low level can *haskell* go?!
21:47:10 <Twey> http://www.slant.org/nyc/The-High-Rate-Of-Child-loveual-Abuse-By-Homoloveual-Males-1390.html -- warning: marked as 'may harm your computer' by Google, not sure why
21:47:12 <ivanm> stepcut: you're point being? :p
21:47:17 <dons> yeah. it wouldn't be fun if it wasn't for quickcheck and friends
21:47:22 <Peaker> Did you ever try to remove everything in a directory? rm -rf blah/* fails to remove dot files. so you try: rm -rf blah/.*  and it removes blah/..  RECURSIVELY
21:47:23 <lambdabot> Title: The High Rate Of Child loveual Abuse By Homoloveual Males 1390, http://tinyurl.com/67nuhr
21:47:30 <Capso> ivanm: No, he is a human being.
21:47:32 <stepcut> Peaker: yep
21:47:33 <dons> Capso: all the way, man, all the way.
21:47:40 <bos> once i had the basic framework of the final 2x speedup in place, i found three corner cases with quickcheck that i hadn't thought of. it easily turned days of debugging into maybe 90 minutes.
21:47:54 <Peaker> stepcut: I hate "hidden dotfiles". That's stupid, they should have created a directory instead of prefixing a bazillion files
21:47:57 <Twey> Peaker: Argh what
21:47:58 <ivanm> Twey: ff3 calls it a reported attack site
21:48:13 <ivanm> Twey: http://safebrowsing.clients.google.com/safebrowsing/diagnostic?client=Firefox&hl=en-US&site=http://www.slant.org/nyc/The-High-Rate-Of-Child-loveual-Abuse-By-Homoloveual-Males-1390.html
21:48:14 <lambdabot> Title: Google Safe Browsing diagnostic page for www.slant.org/, http://tinyurl.com/6kpaxh
21:48:16 <Peaker> Twey: I should have used:  rm -rf blah && mkdir blah
21:48:26 <Peaker> Twey: but I tried: rm -rf blah/* and rm -rf blah/.* instead
21:48:35 <Twey> Yeah... but I never ran into rm -rf blah/.*
21:48:36 <Peaker> Twey: because * does not expand "hidden files" (start with dot)
21:48:40 * shepheb hacked up an interpreter for a MIPS-ish assembly last night. fairly low-level, Data.Bits and all that. a remarkable joy. the thought "would this be easier in C?" came up, and was quickly squashed: "I've got two Data.Maps full of functions, and wrote zipWith ($) fs xs just now. Haskell it is.
21:48:47 <Peaker> Twey: how else do you tell it to remove the dot files?
21:48:51 <Twey> That's pretty dumb default behaviour
21:49:30 <Peaker> "rm" should not be irreversible until the space is actually claimed, too
21:49:46 <stepcut> rm needs a --one-file-system-only option like rsync as well
21:49:47 <Peaker> there shouldn't be a "delete this" (except for secrets), there should be a "de-prioritize this"
21:49:57 * stepcut filed a bug with GNU about once
21:50:09 <stepcut> s/about once/about that once/
21:50:13 <Twey> Peaker: *nod*
21:50:18 <Twey> That would be `shred`
21:50:27 <ivanm> stepcut: it does, IIRC...
21:50:31 <Peaker> yeah, shred and mark-unimportant
21:50:48 <ivanm> stepcut: yup, man rm lists that as an option
21:50:50 <stepcut> ivanm: sweet! they must have read my bug
21:52:09 <ivanm> stepcut: added in 2006 according to the changelog
21:52:37 * stepcut checks out GNU
21:52:47 <pjdelport> Peaker: rm *(D) in zsh
21:52:48 * Twey chuckles.
21:53:06 <Twey> *(D)?
21:53:10 <Twey> What does the (D) do?
21:53:18 <Peaker> what if I want to delete files that have (D) as a suffix? :)
21:53:25 <Twey> Peaker: Escape
21:53:32 <Peaker> encoding everything as a sequence of chars sucks :P
21:53:36 * Twey used zsh for a bit but really has never harnessed its power :-\
21:53:41 <ddarius> Use PowerShell.
21:53:46 * Twey snorts.
21:54:09 <pjdelport> Twey: the () suffix contains glob qualifiers
21:54:21 <pjdelport> D includes dotfiles
21:54:44 <pjdelport> (other common ones are . and / for files and directories only, and so on)
21:55:03 <stepcut> http://osdir.com/ml/gnu.core-utils.bugs/2004-08/msg00164.html
21:55:09 <Twey> pjdelport: Oho
21:55:11 <Twey> Nice
21:55:13 <pjdelport> Peaker: quote :)
21:55:13 <lambdabot> Title: rm -xdev: msg#00164
21:55:18 * Twey switches to zshu.
21:55:21 <lispy> what does this mean: due to the growing disaffection with the Prelude
21:55:23 <Twey> s/zshu/zsh/
21:55:31 <lispy> disaffection?  Is that a community sentiment?
21:55:44 <lispy> or is that a commentary on the way the logfloat library is evolving?
21:56:27 * Twey likes doing 'chsh zsh' for some reason
21:56:33 * Twey giggles sanely
21:57:25 * Twey notes that the command doesn't actually work without a -s, which completely upsets the balance...
21:57:26 <lispy> s/san/insan/ ;)
22:02:00 <Lycurgus> disaffection: unruhe?
22:02:35 <Lycurgus> the many like it not
22:03:06 * stepcut uses eshell
22:08:21 <guenni> @src encode
22:08:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:08:34 <guenni> @src Maybe
22:08:35 <lambdabot> data Maybe a = Nothing | Just a
22:08:56 <guenni> @src fromChunk
22:08:56 <lambdabot> Source not found. You untyped fool!
22:09:24 <guenni> @src Monad
22:09:24 <lambdabot> class  Monad m  where
22:09:24 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
22:09:24 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
22:09:24 <lambdabot>     return      :: a -> m a
22:09:24 <lambdabot>     fail        :: String -> m a
22:09:44 <guenni> @src forall
22:09:44 <lambdabot> Source not found.
22:14:20 <guenni> > :t [1 .. 10]
22:14:21 <lambdabot>  mueval: Prelude.read: no parse
22:15:02 <ivanm> @type [1..10]
22:15:03 <lambdabot> forall t. (Enum t, Num t) => [t]
22:15:08 <ivanm> guenni: that what you wanted?
22:15:46 <guenni> ivanm: I was just playing really :)
22:16:01 <ivanm> heh
22:16:16 <ivanm> if you're playing, maybe you should /msg lambdabot to be able to play with her in private :p
22:16:47 <guenni> I hadn't expected anybody was on at this time of day
22:16:59 <ivanm> @time guenni
22:16:59 <lambdabot> Local time for guenni is Sa Aug 30 07:16:56 2008
22:17:01 <ivanm> @time ivanm
22:17:02 <lambdabot> Local time for ivanm is Sat Aug 30 15:17:01
22:17:02 <Capso> Cale: With a lot of undo moves, I can beat GnuGo quite well. ;)
22:17:17 <ivanm> guenni: this is an _international_ service! :p
22:17:47 <guenni> where in this world is it 15:17 right now?
22:17:57 <ivanm> down under
22:18:02 <guenni> thought so
22:18:08 <ivanm> or else anywhere else that's UTC+10
22:18:13 <Capso> guenni: Are you in Russia?
22:18:27 <guenni> Capso: worse
22:18:44 <ivanm> germany?
22:18:49 <guenni> bingo
22:18:51 <Capso> Oh, dou... err... deutchland.
22:19:01 <guenni> Deutschland
22:19:13 <Capso> Sorry about the s.
22:19:14 <guenni> almost Capso
22:19:23 <guenni> you?
22:20:17 <Capso> I'm in the largest periphery country in the world, which is not itself a continent, but is ignorant enough to go by the name of its containing continent.
22:20:35 <ivanm> yankee central?
22:20:43 <ivanm> "periphery country"?
22:20:57 <Capso> Bing-bing-bing!
22:21:00 <ivanm> see, we're allowed to call ourselves by the continent we live on!
22:21:06 <guenni> america
22:21:32 <ivanm> as I said, yankee central
22:21:50 <Capso> ivanm: It's the new term for "third-world".
22:22:05 <ivanm> ahhh
22:22:07 <Capso> In a sense.
22:22:16 <ivanm> seeing as how there's almost no second world countries to speak of?
22:22:32 * ivanm wonders if the PRC is classified as a second or third world country...
22:22:53 <Capso> ivanm: Well, nth-world countries were named as such due to reasons specific to their times...
22:23:21 <ivanm> second world used to refer to communist countries, primarily the warsaw pact group
22:23:55 <Capso> ivanm: Now the "under-developed", "somewhat developed" and "well-developed" go by the names, "periphery", "semi-periphery", and "core", respectively. But there's more to that, of course.
22:24:15 <guenni> is there anybody else here who has come to the awful realization that they really, not doubt possible, are their parents kids?
22:24:57 <ivanm> ummm.... all of us who aren't adopted are in fact their parent's kids...
22:24:59 <guenni> I just found out I am so my fathers son
22:25:11 <guenni> no doubt about it
22:25:13 <Spark> i am the son of satan
22:25:14 <Lycurgus> actually it's reasonable for Estados Unidensos to refer to themselves as Americans as it was the first independent country
22:25:34 <Lycurgus> the largest and most populous, etc.
22:25:39 <ivanm> Lycurgus: who?
22:25:42 <guenni> he is just being swindeled out of 80k USD by some Africans
22:26:04 <Lycurgus> and SFAIK, no other country has "America" in its official name
22:26:04 <guenni> and actually buys the story why there still are no diamonds
22:26:25 <Capso> guenni: Anyways, I hail from India.
22:26:26 <guenni> and why he has to advance another 175k so there will be diamands
22:26:41 <guenni> I am so my fathers son
22:26:53 <humasect> haskell?
22:27:19 <guenni> not at this time of day humasect
22:27:32 <ivanm> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs -- for humasect
22:27:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:27:41 <humasect> aw=)
22:27:42 * ivanm still loves that one-liner
22:28:03 <shepheb> #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
22:28:24 <vegai> how about a function that gives you all the times you needed the fibonacci in actual program code? :)
22:28:26 <pjdelport> @remember shepheb #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
22:28:26 <lambdabot> Okay.
22:28:35 <guenni> anybody know how I can serialize a very large list?
22:28:36 <Capso> @shepheb
22:28:36 <ivanm> shepheb: lol
22:28:36 <lambdabot> Unknown command, try @list
22:28:44 <ivanm> @remember shepheb #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
22:28:45 <lambdabot> Done.
22:28:45 <Capso> @karma
22:28:45 <lambdabot> You have a karma of 0
22:28:50 <Capso> Oh, to hell with you!
22:28:53 <Capso> lambdabot--
22:29:00 <vegai> @karma lambdabot
22:29:00 <lambdabot> lambdabot has a karma of 3
22:29:03 <ivanm> oh, whoops, didn't notice pjdelport already doing it :s
22:29:11 <ivanm> shepheb: oh well, you're quoted twice now ;-)
22:29:21 <shepheb> ivanm: I thought it forgot the old one?
22:29:24 <Capso> @quote shepheb
22:29:24 <lambdabot> shepheb says: #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
22:29:26 <ivanm> does it?
22:29:28 <Capso> @quote Cale
22:29:29 <lambdabot> Cale says: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
22:29:30 <guenni> I sometimes wonder if lambdabot is actually a bot
22:29:34 <ivanm> if you do @remember+ maybe...
22:29:38 <ivanm> @help remember
22:29:39 <lambdabot> quote <nick>
22:29:39 <lambdabot> remember <nick> <quote>
22:29:39 <lambdabot> Quote somebody, a random person, or save a memorable quote
22:29:48 <ivanm> @help remember+
22:29:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:29:54 <ivanm> @quote shepheb
22:29:54 <vegai> if she's not a bot, she sure types fast
22:29:54 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
22:30:05 <guenni> list
22:30:08 <ivanm> vegai: ummm... yes, lambdaBOT is a bot...
22:30:14 <guenni> > list
22:30:15 <lambdabot>  mueval: Prelude.read: no parse
22:30:16 <Capso> @quote ivanm
22:30:16 <lambdabot> osfameron says: <ivanm> @localtime popcorn <osfameron> every time is popcorn time
22:30:21 <shepheb> oh, that one. I think there was an old one, but she forgot it.
22:30:27 <guenni> @list
22:30:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:30:45 <ivanm> @quote Capso
22:30:45 <lambdabot> No quotes match. There are some things that I just don't know.
22:30:54 <pjdelport> unsafePerformKick :: IO a -> Sparta
22:31:14 <Capso> @why
22:31:15 <lambdabot> Maybe you meant: ghc thx what wn
22:31:26 <Capso> @ghc thx what wn
22:31:26 <lambdabot> No quotes match. Just what do you think you're doing Dave?
22:31:34 <Capso> ;)
22:31:54 <vegai> ivanm: you base everything on the nick? Do you think I'm gai? :P
22:32:28 <Capso> vegai: You're certainly not a poorly spelt Vijay!
22:32:41 <adu_> Cale: how is "nubBy" not the real "Sieve of Eratosthenes"?
22:33:46 <ivanm> vegai: ummm.... wtf?
22:33:56 <ivanm> adu_: did you read that paper?
22:34:02 <ivanm> wrong type/number of comparisons
22:34:05 <Capso> How many of you know about Reiser?
22:34:05 <adu_> ivanm: nope
22:34:16 <ivanm> Capso: that he's been sentenced 15-life?
22:34:30 <Capso> I'm wondering whether or not anyone here will appreciate this: http://en.wikipedia.org/w/index.php?title=Comparison_of_file_systems&oldid=220529437#Features
22:34:33 <lambdabot> Title: Comparison of file systems - Wikipedia, the free encyclopedia, http://tinyurl.com/5gdlfm
22:35:20 <guenni> anybody here good at serialization?
22:35:33 <ivanm> oh, that old thing...
22:38:22 <BMeph> guenni: Not so good at serialization, just curious - a big list of what? :)
22:38:48 <Cale> adu_: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
22:38:49 <lambdabot> Title: The Genuine Sieve of Eratosthenes
22:40:10 <adu_> well I made a new prime one liner anyways
22:40:13 <adu_> > let isPrime t = not$any ((0==).(mod t)) [2..t-1] in filter isPrime [2..]
22:40:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:41:03 <Peaker> "murders your wife"
22:41:12 <ddarius> not . any p == all (not p)
22:41:13 <adu_> i think its more descriptive than the nubBy one too
22:41:15 <Peaker> took me a while to spot that out
22:41:17 <Capso> Peaker: ;)
22:41:49 <ddarius> @pl isPrime t = all ((0/=) . mod t)
22:41:50 <lambdabot> isPrime = all . ((0 /=) .) . mod
22:42:02 <adu_> nice
22:42:12 <ddarius> @pl isPrime t = all ((0/=) . mod t) (enumFromTo 2 (t-1))
22:42:13 <lambdabot> isPrime = ap (all . ((0 /=) .) . mod) (enumFromTo 2 . subtract 1)
22:42:21 <adu_> lol
22:42:26 <davidL> you only have to go to sqrt of t
22:43:09 <waynemokane> is there some reason why the arguments to execStateT/evalStateT is opposite to that in runStateT ?
22:43:18 <davidL> > let isPrime t = not$any ((0==).(mod t)) [2..floor(sqrt(fromIntegral t))] in filter isPrime [2..]
22:43:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:43:23 <waynemokane> er, the order of arguments
22:43:27 <guenni> BMeph: let say a very large list of ints [1 .. 100000000]
22:43:28 <adu_> davidL: thats longer...
22:43:41 <davidL> adu_: faster too.
22:44:08 <BMeph> guenni: Then why not use show? :)
22:44:48 <davidL> > nubBy(((>1).).gcd)[2..] -- if you want short ;)
22:44:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:45:04 <guenni> well because the problem I'm dealing with isn't a list of ints, this was just for example
22:45:23 <BMeph> davidL: I like how it filters itself. Kinky! ;)
22:45:29 <adu_> davidL: I know, but we were talking about something more interesting than "nubBy"
22:45:48 <BMeph> guenni: Hmm. Sounds like you need better examples. ;)
22:46:14 <guenni> I have a huge amount of static data which I want to become part of my exe and show won't compile, but if I had it for instance in a bytestring I could compress that and desiraliue it
22:46:22 <guenni> deserialize
22:47:38 <guenni> BMeph: have a look at: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014385.html
22:47:40 <lambdabot> Title: static constants -- ideas?, http://tinyurl.com/6mshve
22:47:42 <adu_> guenni: have you tried including it with hsc or something?
22:47:45 <stepcut> guenni: you could compress it with bzip2, and using Template Haskell and ByteString to link the data into your code perhaps ?
22:48:00 <stepcut> (and the bzip2 library)
22:48:15 <guenni> stepcut: don't know, could I?
22:48:31 <adu_> guenni: like foreign include "mydata.inc"
22:48:37 <adu_> i dunno
22:49:47 <adu_> guenni: or you could do like unix ppl do, and put it in /usr/local/share/myapp
22:49:55 <adu_> guenni: and read it during runtime
22:50:07 <dons> guenni: http://haskell.org/haskellwiki/Compiling_in_constants
22:50:08 <lambdabot> Title: Compiling in constants - HaskellWiki
22:50:39 <stepcut> guenni: you could basically do with is in that mailing list post, but instead of putting the string literal directly in your source, you could put it in an external file and use Template Haskell + runIO to read in the data at compile time. Though, cpp might be just has good for that.
22:51:31 <guenni> well actually the problem in my case was that the encoding phase blew the memory, because "encode" wasn't lazy
22:53:55 <stepcut> ah
22:59:08 <thatsright> which linux distro has the most haskell packages?
23:00:00 <BMeph> guenni: So, what you're telling us is, you've already found that your encode function is the bottleneck to your problem, but you're hoping an efficient-enough packing will make the difference? ;)
23:00:05 <dolio> Arch.
23:00:18 <BMeph> thatsright: I'd sa Slackware...but it's an inside joke... ;)
23:00:24 <BMeph> s/sa/say/
23:00:40 <dolio> It's definitely arch linux. No contest. :)
23:01:12 <dons> 522 packages.
23:01:33 <dons> gentoo's second.
23:01:52 <dons> thatsright: http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=arch-haskell&SB=v&SO=d&PP=100&SeB=m&do_Orphans=
23:02:04 <lambdabot> Title: AUR (en) - Search: arch-haskell, http://tinyurl.com/5a3rtx
23:02:09 <Lycurgus> you'd think it would be debian but it prolly isn't
23:02:36 <dons> haskell moves at a frequency several octaves above debian's package process.
23:02:59 <Lycurgus> like as not there's a haskell specific distro squirelled someplace or hatching
23:03:03 <dolio> Debian derivatives may split the usual packages into the most packages. :)
23:03:39 <vegai> at least if you count the packages in AUR
23:03:55 <guenni> BMeph: in short, yes
23:04:23 <Lycurgus> sid like as not tries to drag as much as possible out of hackage
23:05:11 <dons> Lycurgus: ?
23:05:20 <dons> are you saying sid has a lot of hackage packages?
23:05:45 <dons> we need a distro package with scores for each distro on how well they're supporting hackage
23:05:47 <Lycurgus> my imagination, sid doesn't care what it breaks
23:08:11 <thatsright> gentoo portage means you have to compile everything right?
23:08:16 <ivanm> dons: we're only second because dcoutts is a slacker and quit :p
23:08:31 <dons> yeah, to work on cabal :)
23:08:40 <dons> the thing that enables hackage. go dcoutts!
23:17:34 <BMeph> guenni: ...have you considered improving your encoder? :)
23:18:17 <guenni> well the encoder is from the binary package :)
23:18:32 <guenni> did you hear that "it's not my fault" in there?
23:19:40 <Cale> Have you considered shouting at dons or someone? ;)
23:20:39 <guenni> well I did discuss this problem earlier, some 8 hrs ago and got some very spiffy answers
23:20:51 <guenni> which I did not understand ... :(
23:21:21 <chrisdone> anyone know if it's possible to use pegleg from haskell? it outputs C code... so maybe FFI, but how to get well typed values from the parse?
23:21:30 <dons> wassup?
23:21:39 <dons> chrisdone: sure, if you have the C types
23:21:43 <dons> you can parse to haskell values.
23:22:16 <dons> Cale: we sure talk a lot about packages these day.s
23:22:23 <chrisdone> hmm
23:22:34 <dons> i remember a time when we used to talk about what packages we would have to write to answer the questions :)
23:22:42 <chrisdone> I'm having trouble thinking in a non functional way :\
23:22:45 <dons> now we can just sit back and what the code roll in.
23:22:49 <Cale> hehe
23:23:28 <chrisdone>            start <- "username"    { printf("%s\n", getlogin()); }
23:23:29 <chrisdone>                   / < . >         { putchar(yytext[0]); }
23:23:38 <chrisdone> should I modify some global object or something?
23:23:55 <chrisdone> like “current_parse”
23:24:09 <dons> btw, hope to have slides up for ghc+gpu after the tech talk next week, http://www.galois.com/blog/2008/08/29/gpugen-bringing-the-power-of-gpus-into-the-haskell-world/
23:24:15 <lambdabot> Title: Galois › Blog › Blog » Bringing the Power of GPUs to Haskell, http://tinyurl.com/5s7fwn
23:24:31 <chrisdone> bahh I dunno
23:24:54 <Cale> dons: Tell the web design guy that light grey on white only looks good if you don't actually want to read the text ;)
23:25:09 <mwc> dons: personally, I think watching GHC code scale across Larabee will be way cooler
23:25:27 <dons> light grey?
23:25:33 <Cale> dons: The page you linked to.
23:25:37 <dons> oh, it is kind of light grey isn't it.
23:25:45 <dons> weird.
23:26:12 <mwc> Harrop is always whining that STM won't scale
23:26:19 * BMeph wonders if there's some Thai guy out there named "Sran Lee," and if something could be contrived to get him on a stage standing between Sean Lee and Stan Lee...
23:26:33 <Twey> COLOURS ARE NOT COMPLIANT
23:26:34 <dons> mwc, isn't he more that anything-but-.NET's GC won't scale?
23:26:37 <Twey> http://snook.ca/technical/colour_contrast/colour.html
23:26:40 <lambdabot> Title: Colour Contrast Check - snook.ca
23:26:40 <mwc> dons: heh
23:26:42 <dons> actually, anything he doesn't use, doesn't scale.
23:26:44 <Twey> #999999-#FFFFFF
23:26:51 <mwc> snook.ca?
23:26:59 * mwc devolves into southpark flashback
23:27:00 <Twey> Haha, BMeph
23:27:23 <mwc> dons: still, if GHC kicks ass and takes names when we get it running on Larabee, it'll be pretty cool
23:27:34 * BMeph winks at Twey for "getting it"
23:27:40 <dons> taking over the quad core shootout would be one good step
23:27:56 <Twey> BMeph: 'Hi, uh, my name's Sran Lee, and... I've been asked to stand here because BMeph thought it would be cool.  This... uh... "funk-shun-al prow-gram-ing" sounds wonderful, and, uh, I hope you guys have a good time with that!'
23:28:28 <mwc> Sran sounds Indian to me, that's where you should look
23:28:38 <BMeph> dons: I'd just like to figure out what keeps making the shootout rig flub up using the Posix lib. :)
23:28:55 <dons> it doesn't have the regex-posix lib installed
23:29:29 <Cale> Twey: That thing accepts a lot of annoying things still though...
23:30:46 <Cale> But, if everything complied with at least that, I'd be happier :)
23:31:32 <Cale> It's too bad that browsers don't have a feature where they just automatically smash the colours to the nearest ones which contrast sufficiently :)
23:31:42 <Twey> Cale: Such as what?
23:32:02 <mwc> Reversing the colors always helped
23:32:04 <Cale> Twey: You can go quite far with grey on white.
23:32:08 <Twey> If anything, I've found it to be overly-rigorous
23:32:33 <mwc> there was a nice keystroke for Mac OS X, Shift-command-option-8 or something. Must have been an emacs user who implemented it
23:33:31 <Twey> Cale: Only as far as #777
23:33:47 <chrisdone> “and their programmability has also improved to the level where they can be used fo general-purpose computations”
23:33:51 <chrisdone> fo' sho'!
23:34:04 <mwc> Personally, I want a vimperator mode to mash website colors onto my current gvim color scheme
23:34:11 <Twey> Heh
23:34:13 <mwc> zenburn ftw
23:34:13 <chrisdone> fo' general-purpose computayshenanigans
23:35:06 <dons> oh, is there a typo?
23:35:17 <Twey> Yes, dons :-P
23:35:37 <Cale> Twey: Maybe I'm overly draconian, but if text is not going to have a colour, and it is meant to be read, it really should be pure white or pure black.
23:36:03 <Cale> (whatever is farthest from the background)
23:36:39 <Cale> Grey text always somehow seems unacceptable.
23:37:30 * Twey grins.
23:37:32 <chrisdone> a grey background is unworkable. this is why the common lisp hyperspec web site has a grey background, to troll innocent programmers...
23:37:33 <Twey> So Cale
23:37:41 <Twey> You'd be unhappy with http://80.4.194.222/uploads/tcc3.jpg then?
23:37:57 <Cale> hehe
23:37:59 <Twey> Argh excessive JPEG compression
23:38:06 <Trinithis> what site are you making?
23:38:15 <Twey> Just my personal one
23:38:22 <Cale> Why not make the text pure white?
23:38:40 <Cale> (because you want that for links?)
23:38:40 <Twey> Because then I can't use pure white to make things stand out
23:38:47 <chrisdone> I didn't know you spoke latin
23:38:56 <Trinithis> I dislike pure white. too bright for my darkish themes
23:38:57 <Cale> That isn't Latin :)
23:39:04 <Twey> ro bangu mi doi .xris.
23:39:11 <Twey> :)
23:39:48 <Cale> It's just something which looks like Latin and is an informal standard to use when testing designs that involve text.
23:39:54 * Twey nods.
23:40:12 <chrisdone> Twey: yeah, you're lacking a selbri there
23:40:16 <Cale> http://en.wikipedia.org/wiki/Lorem_ipsum
23:40:17 <Twey> Nope, chrisdone
23:40:17 <lambdabot> Title: Lorem ipsum - Wikipedia, the free encyclopedia
23:40:20 <Twey> Read again
23:40:28 <Twey> Oh
23:40:36 <Twey> No, I'm missing a sumti :)
23:40:40 <Twey> ro da bangu**
23:41:03 <chrisdone> now it has a selbri
23:41:56 <chrisdone> that was actaully a joke, but, uh. nevermind
23:42:44 <Twey> Heh, aye :-P
23:44:11 <chrisdone> http://clhs.lisp.se/Graphics/CLHS_Lg.gif <-- it makes me laugh every time
23:46:32 <Twey> Hahaha
23:47:59 <Cale> "the current GPU programming systems are based on the specialized parallel processing model" -- is there really only one specialized parallel processing model to choose from?
23:48:07 <mwc> Actually, isn't real loren ipsum out of some old classical text?
23:48:31 <Cale> mwc: It's chopped bits and pieces, where the cuts go through various words :)
23:49:58 <mwc> maybe the specialization is the distinction
23:50:27 <mwc> heterogenous specialized processors as opposed to homogenous general purpose
23:50:57 <mwc> actually, dons, wouldn't .NET's GC be spectacularly *bad* for a functional language?
23:51:24 <mwc> a functional GC needs to be tuned for rapid accumulation of working garbage in the birth generation
23:51:37 <mwc> whereas with Java/C#, objects tend to live for a longer period of time and be larger
23:52:13 <mmorrow> re: the earlier discussion of the sieve of eratosthenes http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=21
23:57:24 <joed> mwc: Do you mean that GC and JIT/Hotspot would be bad as a designed language in a JVM or that the JVM is bad for it?
23:59:03 <mwc> I can't quite parse that question, but I think the answer is that I've read previously that attempting to build a JVM backend for haskell ran into trouble because of the JVM's GC
23:59:27 <mwc> since Java and C# are so similar in spirit, I'd expect that similar problems would occur on .NET
23:59:34 <joed> I can't even parse what I wrote.
