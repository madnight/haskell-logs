00:00:36 <patc> Hi can anyone help me by explaining some ffi internals?
00:01:27 <dolio> Yeah, that class is about as good as you're going to do, I think. It's kind of messy, though.
00:01:36 <ahunter2> rwbarton: that seems like it might work
00:01:38 <hansfbaier> patc: What exactly do you want to know?
00:01:39 <ahunter2> thanks
00:02:29 <dolio> It goes to show that type classes (with appropriate extensions) get you C++-esque overloading in the limit.
00:02:41 <dolio> If you so desire.
00:02:51 <patc> I've written a virtual machine in Haskell, and performance stinks. I want to convert the critical stuff to C
00:03:29 <patc> The machine has operations, i'll give an example, getCT :: (WAMData a) -> IO WAMRef
00:03:53 <patc> here "WAMData a" holds the machine state
00:04:01 <ibid> there might be optimizations you could do in haskell, without using ffi, perhaps?
00:04:10 <patc> and WAMRef is a reference into the machine
00:04:55 <thoughtpolice> indeed, i would say you can probably optimize a few good things without dropping to C or making your haskell look like FORTRAN :)
00:05:03 <patc> ibid:  I've tried and failed on that route.  I've decided life is too short to learn GHC internals
00:05:59 <patc> the big optimization I've don in haskell is to get rid of Ints, chnage everything to Word64s, and bitfiddle manually
00:06:58 <patc> Anyway, what I want to do is turn my "getCT" into C, but I want to inline it.  The question is, is the ghc linker smart enough to inline stuff in the ffi
00:07:25 <ibid> very unlikely
00:07:28 <thoughtpolice> ints are raw machine integers anyway, I don't see how much of a benefit you'd get from going to word64's (but I don't know for sure)
00:07:33 <ibid> if you want to inline, you'd better stay in haskell
00:07:44 <thoughtpolice> also you do not have to bit fiddle to get faster
00:07:46 <ibid> thoughtpolice: ints are boxed integers
00:08:00 <dolio> Word64s are boxed Word64s.
00:08:10 <Shiruka> even if it were, it probably wouldn't make much of a difference, as it can't do any further optimizations anyway, and further optimizations are the biggest benefit with inlining
00:08:14 <patc> It doubled the speed essentally
00:08:19 <thoughtpolice> ibid: oh are they? i was thinking they were unboxed for some reason. :)
00:08:34 <solrize> patc, use harpy :)
00:08:41 <patc> What is harpy?
00:08:50 <thoughtpolice> patc: it lets you do runtime code generation
00:08:53 <ibid> thoughtpolice: you can assume anything withough an # is boxed (modulo unboxing optimizations)
00:08:55 <thoughtpolice> it embeds x86 assembly into the language
00:08:55 <solrize> http://uebb.cs.tu-berlin.de/harpy/
00:08:56 <lambdabot> Title: Harpy - Runtime code generation for x86 machine code
00:09:13 <solrize> augustss's blog has some good posts about it
00:09:16 <patc> I'll have a look, thanks.
00:09:19 <ibid> patc: are you sure you've eliminated all unnecessary laziness?
00:09:20 <solrize> http://augustss.blogspot.com/2007/06/playing-with-harpy-recently-there-was.html
00:09:21 <lambdabot> Title: Things that amuse me, http://tinyurl.com/3dlr2o
00:09:24 <thoughtpolice> ibid: i'm aware, just for some reason I was under the wrong impression :)
00:09:50 <thoughtpolice> patc: you can get far with optimizations if you use unboxed types (i.e. you strictify a few things) and utilization of an optimized library if it's there
00:10:13 <solrize> patc have you looked at dons's blog lately?
00:10:33 <solrize> bunch of stuff about low level haskell optimization
00:10:37 <patc> ibid:  I'm pretty sure I haven't got rid of all laziness.  I tried unboxed types but got fed up with the lack of documentation and so decided on C
00:10:39 <thoughtpolice> just know that doesn't mean "make everything, everywhere strict"
00:11:10 <thoughtpolice> i agree with solrize, dons has a lot of good posts lately about optimizing your code.
00:11:12 <dons> patc: hehe, at least do you call the C from the FFI?
00:11:29 <dons> it's really rare now to need unboxed types -- you should just be careful about what you're doing.
00:11:38 <dons> since strict atomic types will be unboxed anyway
00:12:10 <dons> ah, a virtual machine.
00:12:22 <dons> these are surprisingly difficult to do well in haskell, i'm not sure why.
00:12:29 <dons> jitting the code via harpy makes sense though
00:13:32 <thoughtpolice> actually I've been working on my own virtual machine; indeed, I was considering haskell but at first was not sure at how well it would perform. i went the C route instead
00:13:37 <ibid> i'd probably do code generation in haskell and have the full vm interpreter in C
00:13:47 <thoughtpolice> if it didn't pay off in any way it sure as hell made me appreciate the abstractions I get with haskell a lot more :)
00:14:19 <ibid> (but then again, jitting might be even better)
00:14:55 <thoughtpolice> harpy is an attractive approach, if you ask me.
00:14:57 <patc> My observations are that putting the (virtual) code and stack into a big IOArray (or IOUArray) seems to allocate a lot more memory than needed.
00:15:07 <thoughtpolice> the 0.4 release is so much better since you don't have to keep track of the code buffer size now
00:15:18 <patc> I've decided I want to control memory allocation myself :)
00:15:19 <dons> patc, well, an IOUArray is just the same as the equivalent C array
00:15:35 <dons> but this is still unambigously easier to get good performance in C
00:15:43 <dons> one of the few domains left :)
00:16:00 <dons> ibid's approach of generating code for the C interpreter is likely more profitable.
00:16:22 <dons> there's probably a HW paper in working out how best to implement vms
00:16:26 <dons> and what the current barriers are.
00:16:41 <dons> after all, all the asm is available to us, so why isn't it easily available?
00:16:46 <patc> Somehow the haskell code allocates 140 meg whereas my C code allocates 24 meg.  I confess I don't know what's going on here, I suspect there';s some laziness I've not tracked down.
00:16:58 <dons> patc, oh, that sounds like a space leak on a loop, would be my guess.
00:17:13 <dons> or you're using some funny data type (like a huge linked list?)
00:17:36 <glguy_> data HugeLinkedList?
00:17:39 <dons> a IOUArray Word8 will allocate exactly the same as a char array in C, so your problem would be somewhere else.
00:17:57 <dons> glguy_: data MakeMyMemoryFull
00:18:40 <patc> Nope, mostly IO(U)Arrays.  According to the hp output, it's all allcoacted by my "buildWAMData" function, and all sits in types "MUT_ARR_PTRS_CLEAN and MUT_ARR_PTRS_DIRTY
00:18:58 <patc> I don;t really know how to interpret that
00:19:27 <glguy_> If we could reliably reason about the space and time usage of haskell, there'd be nothing left to keep the community managable!
00:19:31 <dons> heh
00:20:01 <dons> if anyone is bored, i've a talk i'm giving in the morning, on doing chemistry in haskell, galois.com/~dons/tmp/polymer-padl.pdf
00:20:06 <dons> if you spot a typo, ping me.
00:20:17 <dons> the talks admittedly a bit technical.
00:20:32 <Shiruka> oh, that one.. I recently re-read the paper
00:20:47 <Shiruka> interesting stuff :-)
00:20:48 <dons> oh cool. yeah, about polymer simulation.
00:21:02 <dons> or, using haskell for high performance kick arse scenarios :)
00:21:11 <dons> which are my favourite scenarios
00:21:15 <solrize> "specializing" is misspelled :)
00:21:45 <dons> yes, you mispelled it.
00:21:54 <dolio> Z is more Xtreme.
00:22:00 <glguy_> dons has to live up to his nametag
00:22:10 <glguy_> they might think he was up to something if he spelled it like you did
00:22:13 <dons> don-S to the max!
00:22:16 <Shiruka> I don't know about polymer simulation, but "haskell"+"high performance"+"mcmc"+"kick arse" are the keywords there for me ;-)
00:22:32 <dons> good to know, Shiruka
00:22:56 <dons> the other lesson: every problem is either a compiler or an interpreter
00:23:12 <dons> or, the programming language researcher's full employment theorem.
00:23:20 <audreyt> dons: is the final sentence on the final slide some sort of a hypnotic sublime message?
00:23:36 <solrize> why does the slide called "back to being a programming language researcher" actually describe becoming a numerical analysis weenie?
00:23:45 <dons> audreyt: yes :)
00:23:51 <dons> it is both sublime and hypnotic
00:24:09 <audreyt> and one I can wholeheartly agree with
00:24:10 <dons> solrize: well, that slide's about rewriting systems.
00:24:13 <solrize> hmm, ok, next slide starts to explain
00:24:13 <audreyt> nice slides :)
00:24:18 <dons> :)
00:25:20 <audreyt> on page 8 "In other words," is redundant
00:25:28 <solrize> monomeres?  polymeres?  is that correct?
00:25:33 <solrize> yeah i guess
00:25:34 <audreyt> it disrupts the view flow
00:25:53 <dons> audreyt: thanks.
00:27:20 <solrize> slide 24, dependent is misspelled
00:27:36 <solrize> and 25
00:27:44 <dons> thanks.
00:27:47 <solrize> twice on 25
00:28:18 <solrize> icc crushes gcc on 26 :(((
00:28:25 <dons> yeah
00:28:27 <dons> go icc!
00:28:53 <dons> icc is a pretty awesome compiler. i recommend it, if you can get it.
00:28:56 <Shiruka> solrize: probably should be "monomers" and "polymers"
00:29:07 <solrize> shiruka yeah i was wondering about that
00:29:22 <dons> yeah, "monomers".
00:29:34 <solrize> i thought maybe monomere meant something different
00:29:36 <solrize> like telemere
00:29:49 <dons> maybe in french.
00:29:55 <BeelsebobWork> dons: random note, seeing as you do a lot of campaigning about Haskell being fast... on OS X, Haskell averages about 2x faster than C on the debian language shootout programs
00:30:12 <dons> oh, you do the shootout on OS X?
00:30:26 <dons> btw, the debian programs are out of date. use the gp4 ones.
00:30:32 <dons> but that's interesting. did apple break their compiler?
00:30:40 <BeelsebobWork> no, they broke their malloc implementation
00:30:46 <dons> heh
00:30:51 <BeelsebobWork> C levels Haskell (roughly) if you use dlmalloc
00:31:00 <dons> that's cool.
00:31:14 <BeelsebobWork> got a link to gp4?
00:31:14 <dons> were you surprised?
00:31:24 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
00:31:25 <lambdabot> Title: Create your own Ranking | Gentoo : Intel® Pentium® 4 Computer Language Benchma ..., http://tinyurl.com/lepfo
00:31:30 <BeelsebobWork> ah, cheers
00:31:40 <solrize> dons i wonder if you could pitch this to the larger numerical PDE crowd
00:31:47 <BeelsebobWork> oh, these are the ones I was working with dons
00:32:21 <solrize> it looks cool
00:32:45 <solrize> for some reason it reminds me of that thing vaughn pratt did to measure how bad the original pentium FDIV bug was
00:32:52 <dons> solrize: hmm. that sounds likely. i think this approach is under appreciated.
00:34:29 <dons> thanks everyone for your input. go interwebs!
00:34:31 <solrize> seems worth a shot
00:34:43 <solrize> have a good talk :)
00:40:51 <dainanaki> is it possible to use icc with ghc?
00:41:25 <thoughtpolice> it might be possible to compile with -fvia-C and set the c compiler to be icc, yes.
00:41:29 <thoughtpolice> not sure if it would actually work
00:41:37 <thoughtpolice> (is icc even available for OS X? :( )
00:41:43 <dainanaki> i'm about to test it in a bit
00:42:02 <dainanaki> once i get icc installed
00:42:06 <thoughtpolice> i've heard real good things about icc
00:42:21 <Shiruka> it generates fast code for intel processors
00:42:31 <thoughtpolice> afaik it's the only other compiler that can compile the linux kernel, but it is iffy (i.e. it can only compile certain releases)
00:42:32 <dainanaki> it ought to be interesting to benchmark icc performance vs gcc performance for ghc programs
00:42:52 <dainanaki> why is it picky exactly?
00:42:56 <thoughtpolice> Shiruka: naturally.
00:43:19 <thoughtpolice> dainanaki: the linux kernel changes so rapidly it's not surprising, things that only GCC supports may be added in one release and rewritten/removed the next
00:43:27 <Shiruka> thoughtpolice: one might think that AMD would be sufficiently similar for it to generate good code for that too, but apparently not :-)
00:43:47 <thoughtpolice> hehe
00:44:04 <solrize> i bet the coming new ghc backend will beat any c compiler because haskell can support much better alias analysis
00:44:18 <dainanaki> when is the new backend due?
00:44:22 <solrize> icc apparently generates different code paths depending on the cpuid
00:44:24 <thoughtpolice> 6.10 release
00:44:43 <dainanaki> and when is the 6.10 release estimated?
00:44:44 <solrize> dainanaki not any time soon, i think.  6.10 should have the parallel gc if i understand correctly
00:44:51 <thoughtpolice> it will also hopefully help porting and writing new backends from what I hear
00:44:56 <Shiruka> solrize: if (amd_detected) busy_loop_a_bit(); <-- like this? ;-)
00:45:05 <solrize> shiruka heh
00:45:06 <thoughtpolice> solrize: no it's listed on the wiki as something that they plan to get in before release
00:45:10 <solrize> oh cool
00:45:16 <thoughtpolice> dainanaki: around ICFP 08
00:45:24 <thoughtpolice> an RC is apparently scheduled for mid september
00:45:39 <dainanaki> ok
00:45:43 <thoughtpolice> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
00:45:43 <dainanaki> I can be patient
00:45:44 <lambdabot> Title: Status/Releases - GHC - Trac
00:46:28 <thoughtpolice> dainanaki: oh yes, I did get the HEAD to build just yesterday
00:46:39 <dainanaki> on os x?
00:46:44 <thoughtpolice> yes
00:46:50 <dainanaki> sweet
00:46:55 <dainanaki> you have a good memory
00:47:04 <thoughtpolice> after taking ChilliX's advice and complaining on cvs-ghc someone mentioned most of the show-stoppers have been fixed
00:47:36 <dainanaki> ohhh there's gonna be an update to record syntax
00:47:38 <thoughtpolice> just be sure if you get the latest to also pull the latest libraries too since the extensible exception changes went in, and that's mainly affecting the libraries
00:47:41 <dainanaki> that looks awesome
00:47:42 <vixey> thoughtpolice: did you do anything special to get it to build?
00:47:48 <araujo> hi
00:47:57 <thoughtpolice> vixey: no, just ./configure; make; worked
00:47:57 <dainanaki> hi there
00:48:20 <thoughtpolice> vixey: but yeah just be sure to have the latest up to date libraries or it will break
00:48:23 <dainanaki> well, thoughtpolice, how do I go about doing this, I've never hand-built ghc before?
00:48:28 <thoughtpolice> it happened to me yesterday
00:48:30 <dolio> Oh, they're going to fix text IO to work with unicode.
00:48:37 <Guest61322> wtf
00:48:37 <vixey> yay
00:48:40 <Guest61322> this is all for 6.10?
00:48:41 <thoughtpolice> because darcs is totally retarded
00:48:42 <Guest61322> seems too good
00:48:42 <thoughtpolice> Guest61322: yep
00:48:43 <Guest61322> haha
00:48:47 <thoughtpolice> seriously
00:48:52 <thoughtpolice> many times I run ./darcs-all pull -a
00:48:57 <thoughtpolice> and it will just randomly stop
00:48:59 <solrize> huh?  we're still at 6.8.3
00:48:59 <vixey> so
00:49:03 <thoughtpolice> lots of times I just say screw it and continue with the build
00:49:07 <vixey> http://www.haskell.org/ghc/dist/current/dist/ghc-6.9.20080719-src.tar.bz2 and http://www.haskell.org/ghc/dist/current/dist/ghc-6.9.20080719-src-extralibs.tar.bz2 ?
00:49:08 <lambdabot> http://tinyurl.com/6344sd
00:49:15 <thoughtpolice> because it can take forever
00:49:17 <rwbarton> dolio: What does "text" IO mean?  Will this break IO for arbitrary binary files?
00:49:22 <solrize> that has to be 6.9 in trunk right now
00:49:27 <solrize> at most
00:49:40 <solrize> i mean in head
00:49:51 <opqdonut> it's a shame what's happened to darcs, really
00:49:55 <thoughtpolice> dainanaki:
00:49:57 <thoughtpolice> http://darcs.haskell.org/ghc-HEAD-2008-07-24-ghc-corelibs-testsuite.tar.bz2
00:49:58 <lambdabot> http://tinyurl.com/57e7dc
00:49:59 <solrize> what happened to darcs?
00:50:00 <thoughtpolice> download that
00:50:00 <dolio> rwbarton: They say that you disable any encoding by opening files in binary mode.
00:50:10 <thoughtpolice> solrize: ghc hq is switching of darcs because it is causing issues
00:50:22 <solrize> doh :(
00:50:25 <opqdonut> solrize: well it's basically in maintenance mode but serious performance issues remain
00:50:39 <solrize> if ghc is switching that's probably the end of darcs
00:50:39 <opqdonut> not enough devs, many parts need reworking etc
00:50:43 <dainanaki> git really will be a lot faster
00:50:54 <dainanaki> i don't see them going to mercurial
00:50:56 <thoughtpolice> dainanaki: in general follow these steps - http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
00:50:58 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
00:51:05 <thoughtpolice> dainanaki: but basically the process is pretty simple, download that tarball
00:51:06 <opqdonut> i thought 2.0.0 would have fixed the performance bug but it seems not
00:51:08 <thoughtpolice> go into the directory
00:51:10 <hansfbaier> yeah in my experience git is much faster than darcs
00:51:19 <opqdonut> but I guess it would be nice if everybody would just use git
00:51:21 <thoughtpolice> do a 'darcs pull -a' and then do a './darcs-all pull -a'
00:51:27 <thoughtpolice> that will get you the latest up to date compiler and libraries
00:51:29 <dolio> solrize: I still use darcs. :)
00:51:30 <thoughtpolice> then you can build manually
00:51:34 <dainanaki> ok, thanks thoughpolice
00:51:43 <hansfbaier> the download times of darcs are loooooooooooonng
00:51:44 <dainanaki> how long does a build usually take?
00:51:55 <thoughtpolice> dainanaki: there are a few snags that you can hit if you're not careful when using HEAD
00:52:04 <thoughtpolice> dainanaki: on my macbook pro (core2 2.2gHz)
00:52:08 <thoughtpolice> building with make -j6
00:52:13 <thoughtpolice> probably takes about 20 minutes for everything?
00:52:34 <thoughtpolice> opqdonut: darcs 2 did fix a lot of bugs in particular the exponential merge bug
00:52:53 <thoughtpolice> it's just not cut out for large projects
00:53:15 <thoughtpolice> GHC is the largest project using darcs and it is having some very bad problems; this does not say very good things about darcs ability to handle *really* big stuff
00:53:19 <thoughtpolice> because GHC isn't even that big
00:53:25 <opqdonut> thoughtpolice: yeah, I was just kinda hoping for a miracle
00:54:01 <thoughtpolice> dainanaki: but yes follow the build guide. there are a couple of snags you can hit if you are not careful, if you ask me I might be able to help or i might defer you to #ghc if necessary :p
00:54:20 <dainanaki> okidoke, thanks a bunch
00:54:37 <thoughtpolice> in particular after you pull the latest compiler patches (with darcs pull -a) you might need to run ./darcs-all get first so you can get some of the extra stuff like hsc2hs and whatnot
00:54:41 <thoughtpolice> also
00:54:56 <thoughtpolice> before you pull new patches be sure to have a 'make distclean' because otherwise the build system can get confused from files that are preprocessed
00:55:21 <thoughtpolice> (i.e. foo.hsc will become foo.hs, and if you don't do a make distclean it can confuse the build system a little from what I've gathered)
00:55:25 <dolio> Yeah. Forgetting to distclean before pulling is a good way to hose your checkout.
00:55:46 <dainanaki> that would explain why i've always failed at this before
00:55:49 <dainanaki> :/
00:56:22 <thoughtpolice> dolio: indeed, it's just not mentioned anywhere apparently
00:56:42 <thoughtpolice> (except on cvs-ghc after I complained)
00:56:44 <dolio> It's mentioned on the building GHC tutorial on the trac.
00:57:38 <dainanaki> i hope my university classes will mostly let me choose the programming language i want to use
00:58:01 <vixey> dainanaki: that's an odd thing to want
00:58:16 <dainanaki> why's that?
00:58:21 <Shiruka> you can probably choose any language, as long as it's in the list of approved languages (which may not be very long!)
00:58:28 <dainanaki> Ah
00:58:39 <dainanaki> I wonder if they'll let me add haskell to the list then
00:58:43 <dainanaki> :)
01:00:10 <thoughtpolice> hehehe, i have no idea what to expect with my classes when I first go in about a month or two other than i will probably have to finally learn C++
01:00:27 <dainanaki> i'm in the same boat
01:00:41 <dainanaki> hooray incoming university students
01:01:23 <rtra> I've got to learn java this semester :-(
01:01:48 <dainanaki> java is really really easy
01:01:50 <mrsolo> why :-(?
01:01:57 <rtra> it's ugly
01:02:13 <thoughtpolice> when I go one of the first things I plan to do is seek out professors/people in the CS department with a common interest. when i visited a while back they said they had a few people with similar interests
01:02:26 <vixey> rtra: That's a shame that you're going to increase the amount of knowledge you have about programming and programming languages ....
01:02:57 <thoughtpolice> dainanaki: where are you going?
01:03:11 <dainanaki> Abilene Christian University
01:03:11 <mrsolo> rtra: so?
01:03:15 <dainanaki> how about you?
01:03:21 <rtra> vixey: yes, il try to learn oop from sicp 1st :-)
01:03:25 <thoughtpolice> dolio: also I see no mention of distclean in the building/getting sources guide on the trac wiki except for the new pages
01:03:32 <thoughtpolice> none of it mentions needing to distclean before pulls though
01:03:38 <thoughtpolice> dainanaki: university of houston
01:03:53 <dainanaki> not too far away then huh?
01:03:57 <dainanaki> but houston...
01:04:11 <dainanaki> you couldn't pay me to live there
01:04:12 <thoughtpolice> dainanaki: doesn't seem like it's that far. one of my friends actually moved to abeline about a month ago
01:05:27 <thoughtpolice> dainanaki: well my family is reletively poor and out of state tuition can get insane; i wanted to try and go as far as I could to try and 'start fresh,' houston is a crazy place but I liked it. plus there were some really cool people at the uni. when I went
01:05:44 <dainanaki> yeah
01:05:50 <thoughtpolice> also I figured if I went to houston there must be at least one other FPer around. :)
01:05:52 <dainanaki> i mostly just hate the weather
01:05:55 <dainanaki> :)
01:05:59 <dainanaki> yeah
01:05:59 <thoughtpolice> yeah, really, really, really humid
01:06:26 <thoughtpolice> i was going to post to -cafe right before I moved to see if there was anybody in that area willing to get together
01:06:33 <dainanaki> i got a full-tuition scholarship so I was lucky to be able to go to an otherwise expensive-ish school
01:08:47 <thoughtpolice> dainanaki: hopefully I will have more chances to travel places once I move so if I ever go by there I'll be sure to give you a hollar. :)
01:13:36 <JaffaCake> is Hackage working? I can't seem to upload
01:18:20 <patc> A profiling question; in the profiler output, what does %alloc refer to?  I'm using "-P" and getting some percentage of alloc but zero "bytes", e.g.:  retry_here   Engine  3.2    2.0     22
01:18:20 <patc>     0
01:18:59 <patc> that's 2.0 "%alloc" but 0 "bytes" in that line
01:21:23 <thoughtpolice> JaffaCake: seems to be responding on my end, or can you just not upload?
01:21:48 <JaffaCake> thoughtpolice: it's ok, cabal upload didn't tell me what the error was, but the web interface did
01:21:57 <JaffaCake> was a problem with my package
01:22:49 <mattam> chipie
01:27:35 <moozilla> @src liftIO
01:27:35 <lambdabot> Source not found. There are some things that I just don't know.
01:28:30 <vixey> :t liftIO
01:28:34 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:28:50 <vixey> @src MonadIO
01:28:50 <lambdabot> Source not found. You untyped fool!
01:28:55 * slava is working on persistent hashtables
01:28:56 <slava> lots of fun
01:29:14 <moozilla> how do i generate a random byte
01:29:49 <vixey> @hoogle random
01:29:49 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
01:29:49 <lambdabot> System.Random :: module
01:29:49 <lambdabot> System.Random.Random :: class Random a
01:30:36 <luqui> moozilla, first you need a random generator, which can be made using mkStdGen (for a given seed) or newStdGen (for a system seed)
01:31:11 <luqui> > newStdGen -- I wonder if lambdabot can do this...
01:31:12 <lambdabot>   add an instance declaration for (Typeable StdGen)
01:31:28 <vixey> :t newStdGen
01:31:29 <lambdabot> IO StdGen
01:31:41 <moozilla> right so what do i do with a StdGen
01:31:56 <luqui> > fmap (fst . random) (newStdGen) -- I wonder if lambdabot can do this...
01:31:57 <lambdabot>  Add a type signature
01:31:58 <vixey> moozilla: did you see the function 'random'?
01:32:06 <luqui> > fmap (fst . random) newStdGen :: IO Int-- I wonder if lambdabot can do this...
01:32:07 <lambdabot>  <IO Int>
01:32:32 * luqui was hoping lambdabot had some insane reimplementation of only safe IO...
01:34:32 <solrize> anyone looking at this new larrabee stuff?  will the 6.10 parallel gc be bothered by the read-only caches?
01:37:02 <hml> are there actually that many more haskell users than ocaml users? (curious why the haskell channel is so large) -- or is it that practically everyone that uses haskell is in chis channel
01:37:28 <luqui> the impression i get is that ocaml is more popular than haskell
01:37:34 <luqui> but that may have changed over the last year or so...
01:37:40 <newsham> its jsut that haskell is so hard that a lot of people need to ask questions on irc
01:37:42 <slava> haskell is less popular but more interesting imo
01:37:54 <ejt> perhaps people have more questions about haskell
01:38:03 <hml> luqui: what happened over the last year?
01:38:11 <slava> i actually don't like lazyness, but i think haskell's type system innovations are very cool, also the ocaml compiler is pretty rudimentary
01:38:17 <luqui> hml, haskell has been getting much more popular in the last few years
01:38:40 <opqdonut> luqui: ORLY?-)
01:39:06 <luqui> all my discourse for the next ten minutes is still under the pretext of "my impression"
01:39:28 <osfameron>  well, much less unpopular at least ;)
01:39:36 <luqui> osfameron, well said
01:39:55 <newsham> haskell has become that big book on the shelf that everyone wishes they had read.
01:42:40 <opqdonut> ?remember osfameron <luqui> hml, haskell has been getting much more popular in the last few years <osfameron> well, much less unpopular at least ;)
01:42:40 <lambdabot> Done.
01:42:47 <opqdonut> ?quote unpopular
01:42:47 <lambdabot> osfameron says: <luqui> hml, haskell has been getting much more popular in the last few years <osfameron> well, much less unpopular at least ;)
01:43:56 <solrize> am i just whack for thinking that ada is interesting?
01:44:24 <vixey> yes
01:44:30 <solrize> hmm
01:44:30 <luqui> solrize, larry wall thinks ada is very interesting.  how you take that is up to you...
01:44:32 <opqdonut> no
01:44:58 * vixey is a whack too, interested in ALGOL and so on ...
01:45:09 * opqdonut is interested in J
01:45:18 <opqdonut> and prolog, actually
01:45:29 <vixey> yeah J and Prolog and super cool
01:45:39 <opqdonut> the art of prolog is a great book, it covers the metaprogramming and extralogical stuff better than any other
01:45:46 <solrize> I remember being impressed with Ada because you could write an infinite loop without a faked up condition. The idea being that in Ada the typical infinite loop would normally be terminated by detonation. (Larry Wall)
01:45:50 * luqui thinks prolog is interesting, just broken
01:45:59 <hml> what's a good way to learn J?
01:46:11 <opqdonut> hml: the guide
01:46:19 <hml> what should i gogogle for?
01:46:25 <vixey> luqui: what does it mean to be broken?
01:46:33 <opqdonut> hml: http://www.jsoftware.com/help/primer/contents.htm
01:46:35 <lambdabot> Title: Primer Contents
01:46:36 <solrize> When Roman engineers built a bridge, they had to stand under it while the first legion marched across. If programmers today worked under similar ground rules, they might well find themselves getting much more interested in Ada. (Robert Dewar)
01:46:40 <hml> opqdonut: thanks
01:46:47 <opqdonut> np
01:46:54 <luqui> vixey, for prolog, the fact that it is "logic programming", but the only way to use it without getting into trouble is to understand it operationally
01:47:13 <opqdonut> exactly.
01:47:21 <opqdonut> logic programming is a pretty weak system, imo
01:47:38 * luqui gets that impression too
01:47:44 <luqui> but it's turing complete if you've got arithmetic ;-)
01:48:07 <vixey> hmm, I don't share that view
01:48:10 <thetallguy> luqui: thanks for your comments on 2d zip.  Nice touches.
01:48:14 <opqdonut> but prolog lets you do mindbending stuff like "verify X :- not (not X, X)"
01:48:27 <opqdonut> which can't really be described by any logic system in use
01:48:29 <luqui> thetallguy, ;-) yw
01:48:33 <opqdonut> and that's the cool part
01:48:45 <thetallguy> luqui: and I hope you catch your flight next time.
01:48:52 <luqui> LOL
01:50:25 <luqui> opqdonut, that is indeed bending my mind.  that's verifying that X is independent... somehow...
01:51:07 * vixey wonders what language it is ...
01:51:34 <opqdonut> luqui: if I got that code right it verifies that X is provable without unifying any current variables
01:52:16 <luqui> opqdonut, oh ok... wait... now  you're just confusing me more
01:57:10 <opqdonut> luqui: hmm, can't find the correct version and I don't have TAOP with me right now
01:57:16 <opqdonut> I'll get back to you later :)
01:58:37 <vixey> I would write verify(X) :- copy_term(X,Y),call(Y). which is similar to verify(X) :- \+ \+ call(X).
01:59:23 <opqdonut> yeah that'd work
01:59:25 <vixey> similar in that they both succeed if X does once but they undo any bindings made in X
01:59:33 <opqdonut> yeah
02:01:03 <opqdonut> isn't call() superflous in some dialects?
02:01:20 <vixey> none that I know of
02:01:50 <vixey> sometimes foo(X) :- X. is the valid, but it means something different to foo(X) :- call(X).
02:02:18 <vixey> s/ the//
02:08:32 <hackage> Uploaded to hackage: ghc-paths 0.1.0.3
02:11:16 <vixey> thoughtpolice: you didn't get any message like "Package contains no library to register: ghc-bin-6.9..." ?
02:11:21 <vixey> I am still getting this :/
02:12:39 <thoughtpolice> vixey: ? no, don't believe so
02:19:40 <vixey> I don't understand why EHC is 'essential'
02:20:19 <dainanaki> i can see why the devs want to switch away from darcs
02:20:30 <dainanaki> this is a pain waiting for it to do anything
02:21:33 <kowey> dainanaki: out of curiosity, what is it in particular that you're waiting on it to do?
02:22:19 <dainanaki> i'm waiting for it to download patches to update the core-libraries in HEAD
02:22:50 <kowey> it may be a good idea to enable the global cache in case you do further downloads
02:23:04 <dainanaki> how do you do that?
02:25:24 <moozilla> are there any good bitmap manipulation libraries in haskell?
02:25:33 <moozilla> all i really need to do is pixel manipulation
02:25:37 <kowey> dainanaki: please see http://www.darcs.net/manual/node5.html#SECTION00510070000000000000
02:25:39 <lambdabot> Title: Configuring darcs, http://tinyurl.com/yubb8j
02:25:57 <kowey> it won't help for this download, but future attempts at getting the repository (which sometimes happens)
02:26:13 <moozilla> ?hoogle bitmap
02:26:13 <lambdabot> No matches found
02:28:41 <dainanaki> thanks kowey
02:36:02 <yitz> moozilla: there are a few things on hackage. search for image, and magick.
02:36:16 <moozilla> alright
02:36:49 <moozilla> i think i might just do text graphics
02:36:52 <moozilla> for the heck of it
02:37:20 <moozilla> any easy way to clear the window?
02:38:38 <vixey> putStr (replicate 1000 '\n')
02:38:40 <rwbarton> print "\e[2J"
02:38:48 <rwbarton> are you on linux?  Try man console_codes
02:40:09 <dainanaki> nooooo, i have a buld error
02:41:57 <moozilla> no i'm on windows
02:42:12 <yitz> > fromEnum '\e'
02:42:13 <lambdabot>  Illegal escape sequence at "'\e'" (column 10)
02:42:53 <dolio> moozilla: I've written some small PPM stuff when playing around generating fractals and such. Nothing very elaborate, though.
02:43:20 <rwbarton> > fromEnum '\27'
02:43:21 <lambdabot>  27
02:43:26 <yitz> > fromEnum '\ESC'
02:43:27 <lambdabot>  27
02:43:34 <rwbarton> that's the one
02:44:08 <moozilla> looks like <-
02:44:09 <moozilla> to me
02:44:35 <rwbarton> Yeah, I don't know what it will do in a windows terminal
02:45:13 <moozilla> is there a matrix type where its efficient to access elements by coordinates?
02:45:45 <dolio> Array (Int,Int)
02:46:25 <yitz> or Map (Int, Int) for something pure
02:46:41 <dolio> Oh, yeah, that'll let you update.
02:46:44 <yitz> or IntMap (IntMap a)
02:47:02 <luqui> how is Array not pure?
02:47:23 <luqui> do you mean impl. in pure haskell?
02:47:30 <yitz> or STArray or STUArray
02:48:09 <mercury^> moozilla: use Array (Int,Int)
02:48:40 <moozilla> im having trouble figuring out how to create an Array
02:48:41 <yitz> luqui: well, if you generate it all at once and then never update it, it's pure. If you want to update it, then you use an STArray or STUArray inside the ST monad.
02:48:57 <mercury^> how is that not pure?
02:49:02 <vixey> does GHC use C--?
02:49:10 <mercury^> moozilla: have you read the docs on them already?
02:49:19 <vixey> ST is impure on the inside, but it's pure to observers
02:49:32 <moozilla> the doc doesnt seem very verbose
02:49:36 <moozilla> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
02:49:37 <lambdabot> Title: Data.Array, http://tinyurl.com/2uoebz
02:49:48 <dolio> You can update Arrays if you're willing to pay the price.
02:50:00 <mercury^> moozilla: well, it depends on how you want to initialize it
02:50:11 <dolio> Which can be less terrible if you can batch the updates appropriately.
02:50:19 <yitz> mercury^: ST is really IO in disguise. But since it's side effects are limited to the array's memory, I guess you could call it semi-pure.
02:50:32 <moozilla> well i'm looking for something to hold the state of a screen
02:50:36 <yitz> s/it's/its/
02:50:38 <moozilla> 64x32 pixels
02:50:57 <mercury^> yes, but how do you want to initialize it?
02:50:58 <dolio> In that case you'd probably want the map.
02:51:19 <mercury^> Uh, the Array is a lot faster than the map. What advantage would the map have?
02:51:23 <dolio> Assuming you're going to update that screen frequently by pixels.
02:51:47 <dolio> Updating a pixel isn't O(n) for the map.
02:51:52 <moozilla> it's going to use the most processing time probably
02:52:10 <moozilla> well i guess thats true
02:52:14 <moozilla> since its a fixed size array
02:52:17 <moozilla> i could just use an IntMap
02:52:23 <mercury^> dolio: it's O(1) for an Array too...
02:52:27 <moozilla> thats fairly non-confusing so i think i will do that
02:52:46 <dolio> Updating an Array is not O(1). It involves copying the whole array.
02:53:01 <dolio> Unless you use DiffArray.
02:53:15 <yitz> Maps/IntMaps are fast, and they're nice pure functional structures. I think that Array is usually a premature optimization.
02:53:20 <yitz> dolio: or STArray
02:54:04 <dolio> Yes, but STArray requires running in ST and so on, which I thought people were trying to avoid.
02:54:12 <yitz> dolio: indeed.
02:54:12 <luqui> moozilla, use the docs for IArray, not for Array
02:54:17 <mercury^> I still don't get why you call arrays dysfunctional...
02:54:54 <moozilla> thanks for the tip lucca
02:54:57 <moozilla> luqui*
02:55:04 <yitz> mercury^: their not if they're constant. but if you need to do updating, you wind up in the ST monad because you need side effects.
02:55:21 <mercury^> well, the ST monad is nothing evil...
02:55:23 <yitz> s/their/they're/
02:55:33 * yitz seems a bit alingual today.
02:55:43 <luqui> yitz, unless you're happy with updating in a non-ST way...
02:55:52 <yitz> mercury^: neither is IO itself, if you need it.
02:56:06 <yitz> luqui: unsafePerformIO?
02:56:16 <luqui> yitz, no, just using //
02:56:18 <luqui> or whatever
02:56:27 <moozilla> what exactly is ST
02:56:30 <luqui> update in the functional sense of "return a new one"
02:56:46 <moozilla> i'm fairly sure im just using the IO monad
02:56:50 <mercury^> if you lose all references to the old one on the update, the compiler should do an O(1) operation
02:56:55 <luqui> moozilla, it's like IO, but only allows a very restricted set of operations, and then makes sure that its effects are localized
02:56:58 <mercury^> which is exactly what is happening in ST
02:57:06 <yitz> moozilla: it's like IO, except that it guarantees that the only side effects involve updating the memory of the array.
02:57:17 <moozilla> i see
02:57:50 <luqui> it is very very handy every once in a blue moon
02:57:53 <dolio> Technically, you could implement ST purely. The fact that it uses mutable update is purely an optimization, as mercury^ says.
02:58:05 <luqui> dolio, I challenge that
02:58:33 <luqui> newSTVar is a tough one to do purely
02:58:37 <MarcWeber> Can I get an IO handle to write to a bytestring?
02:58:37 <yitz> dolio: yep. You could use Map. But then - why not just use Map?
02:59:04 <luqui> MarcWeber, uh... that doesn't sound very purely functional to me
02:59:07 <rwbarton> luqui: why? Just set ST = State STData, where STData has a list of variable identifiers and their current values
02:59:27 <yitz> MarcWeber: you don't need one. it's a pure structure. its interface is similar to the usual lists.
02:59:47 <MarcWeber> luqui I'd like to use WASH from HAppS.. and it takes an IO handle.. and HAppS uses lazy bytestrings
03:00:26 <MarcWeber> So the way to go is patch WASH so that it works with bytestrings as well..
03:00:31 <luqui> rwbarton, and what is the type of this list?
03:01:15 <rwbarton> luqui: erm, ok :)
03:01:30 <dolio> yitz: Because couching your algorithm in terms of a number of mutable references looks nicer than looking up magic numbers in a map?
03:01:41 <moozilla> @src isDigit
03:01:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:01:47 <dolio> (The real reason is that you want the optimization, of course. :))
03:01:48 <moozilla> ?hoogle isDigit
03:01:48 <lambdabot> Data.Char.isDigit :: Char -> Bool
03:02:03 <dainanaki> @src join
03:02:03 <lambdabot> join x =  x >>= id
03:03:17 <dainanaki> @hoogle join
03:03:17 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
03:03:17 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
03:03:17 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
03:03:57 <yitz> dolio: it's usually not nicer, because mutable things damage composability. That's why we're here in Haskell, to avoid that problem. Also - usually it's not a map on "magic numbers", you design your algorithm around a map that makes sense for your particular problem space.
03:04:33 <vixey> yitz: ST is composable
03:04:39 <mercury^> If you want to have an updateable matrix and end up with a map, something went wrong...
03:04:43 <dolio> Yeah, yeah. But Sometimes You Really Want Mutable References (TM).
03:05:00 <vixey> mercury^: A map may be suitable
03:05:11 <mercury^> for a sparse matrix maybe
03:05:19 <yitz> dolio: right. I do use Arrays sometimes. But only when I know that I need that optimization.
03:06:51 * EvilTerran prefers to use maps by default, too
03:07:13 <EvilTerran> even if i'm not intending on changing bits
03:07:13 <yitz> vixey: well, in a different sense than Map. When you have to lift everything into ST, things do get more complicated. And messy, in my opinion.
03:07:33 <vixey> it is definitely more complicated
03:07:34 <EvilTerran> because it means i don't have to specify bounds
03:07:47 <vixey> I can't it being messy in any way though
03:08:02 <vixey> see^
03:09:31 <yitz> EvilTerran: true. that's a limitation of Array, not ST, but yeah.
03:11:43 <sioraioc_> fromIntegral is a no-op, right?
03:11:54 <vixey> sioraioc_: no
03:12:03 <sioraiocht_> no? ooh, good to know..
03:12:37 <sioraiocht_> vixey: how does it work, then?
03:12:46 <sioraiocht_> i thoguht it was just a cast
03:12:47 <vixey> I don't know
03:12:54 <luqui> sioraiocht, it's implemented differently for each type you cast to
03:13:02 <vixey> no it's not a cast and casts aren't no op's
03:13:19 <sioraiocht_> oh, my mistake
03:13:36 <sioraiocht_> luqui: okay, thanks
03:13:39 <yitz> mercury^: sparse only makes a different for a really big matrix, because of the log n extra memory of a Map (with a small coefficient). In this case, it's not an issue.
03:14:05 <Baughn> sioraiocht_: It's probably very cheap, but converting from, say, a char to an int still takes some allocation
03:14:11 <yitz> s/different/difference/
03:14:17 <sioraiocht_> Baughn: from Word16 to Int?
03:14:17 * yitz continues to babel today.
03:14:35 <Baughn> sioraiocht_: Whatever. Any pair of types that aren't the same, anyhow.
03:14:43 <sioraiocht_> Baughn: oh okay, thanks
03:20:59 <yitz> vixey: messy is somewhat subjective, I guess.
03:23:02 <sioraiocht_> is there anyway to have an unboxed constant be considered a Word# instead of an Int#?
03:23:28 <Baughn> sioraiocht_: :: Word#?
03:23:34 <Baughn> THey're supposed to be the same thing, though
03:23:44 <sioraiocht_> Baughn: I agree, the typechecker disagrees with you
03:24:02 <sioraiocht_> I have a numerical constant and it wants it to be an Int#
03:24:26 <sioraiocht_> Couldn't match expected type `Word#' against inferred type `Int#' In the second argument of `minusWord#', namely `(55296# :: Word#)'
03:24:44 <yitz> vixey: but as an example, I once wrote a function that randomly shuffles a list. I wrote it using State IntMap, and then using STArray. The pure version was just *nicer*, and there was no noticeable difference in performance for any my applications.
03:25:02 <yitz> of^. sigh
03:25:10 <rwanderley> hi...  am starting to learn haskell.  I read a few tutorials so far...  Now I'm reading "Writing yourself a Scheme Parser in 48 hours", but think a book would be better.  Is SOE the recommended one for beginners?
03:25:33 <vixey> yitz: yeah I don't pick between things like this for speed reasons
03:25:58 <sioraiocht_> rwanderley: it depends on your background and what you want-- I recommend "programming in haskell" by graham hutton
03:26:29 <Baughn> sioraiocht_: Well, why don't you say :: Int# instead?
03:26:58 <sioraiocht_> Baughn: All the rest of my types are words, so I'd like to do arithmetic using the word operators
03:27:05 <sioraiocht_> the word values are being taken from an array
03:27:08 <rwanderley> sioraiocht_: I'm a CS student, do not have a very good math background.
03:27:20 <Baughn> sioraiocht_: ..probably impossible. Primitive arithmetic operators work on ints, period.
03:27:36 <rwanderley> sioraiocht_: will look at this book, thanks.
03:27:37 <sioraiocht_> ...except for plusWord#, minusWord#, etc..
03:27:39 <Baughn> sioraiocht_: At least on some computers they do, and even on x86 that's faster than using other types
03:27:57 <Baughn> Well, you can still convert before and after. *shrug*
03:28:05 <sioraiocht_> Baughn: this is true, but not free ;)
03:28:23 <Baughn> sioraiocht_: Depending on the optimizer, it might be
03:28:32 <Baughn> sioraiocht_: Or you could switch /all/ of them to use int#. :P
03:28:53 <sioraiocht_> that's a bad idea...
03:29:08 <sioraiocht> in this case, heh
03:30:34 <sioraiocht> well, as long as word2Int# is a cheap operation..., heh
03:31:05 <Baughn> Oh it is that. Might even be a no-op, after the optimizer is done with it.
03:31:15 <sioraiocht> that's good, heh
03:37:24 <Stinger> what toolkits does ghc incorperate?
03:38:24 <Stinger> gcc, binutils?
03:38:32 <dainanaki> rwanderly, SOE is really great too
03:38:47 <dainanaki> plus you might want to check out the upcoming real world haskell book
03:39:10 <dainanaki> and wikibooks is also quite helpful, if incomplete in parts
03:40:25 <dainanaki> *rwanderley
03:40:52 <Stinger> I feel I should get a haskell book
03:41:16 <Stinger> I've read most of SOE from the library in bits and peices
03:41:29 <dainanaki> your library has it?
03:41:31 <dainanaki> lucky
03:41:49 <Stinger> my uni library, which I no longer attend, so :(
03:41:56 <dainanaki> ah
03:42:18 <Stinger> I dunno if other people can get memberships to it though, something I have thought about looking into
03:42:23 <Stinger> but I am terminally lazy
03:42:34 <dainanaki> how likely would a uni library be to order a book upon request?
03:43:18 <Baughn> Near 100%, in my experience
03:43:31 <Baughn> Especially if you can get multiple people to ask for it. ;)
03:43:57 <dainanaki> haha
03:43:59 <dainanaki> great
03:45:15 <jeffz> I remember asking my primary/elementry school library for books on programming, a group of us jammed the suggestion box full of requests, they only threatened to ban us.
03:46:54 <Axman6> urgh, why must monads be so confusing >_<
03:47:12 <sioraiocht> dcoutts_: ping?
03:47:44 <dcoutts> sioraiocht: pong
03:48:33 <Stinger> If you are at a uni, find the local fp nut lecturer and ask him to request it
03:49:00 <Stinger> might give it more weight
03:49:00 <Axman6> Stinger: that would by my lecturer from last semester then ;)
03:49:19 <Axman6> some of his code's in GHC
03:50:20 <vixey> Axman6: What are you confused about?
03:51:12 <Axman6> vixey: i don't get them, i don't understand what exactly they do, or why they're used. and reading blogs that say things like "the monadic solution is obvious" doesn't help -_-
03:51:47 <vixey> @src Monad
03:51:47 <lambdabot> class  Monad m  where
03:51:47 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:51:47 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:51:47 <lambdabot>     return      :: a -> m a
03:51:47 <lambdabot>     fail        :: String -> m a
03:51:59 <vixey> Axman6: every monad  has >>= and return
03:52:13 <Axman6> that really doesn't help :\
03:52:19 <Stinger> what tools does ghc use for dealing with libraries?
03:52:32 <Axman6> http://logicaltypes.blogspot.com/2008/05/oh-my-acking-monad.html is one of the posts i'm referring to
03:52:33 <lambdabot> Title: Typed Logic: Oh! my acking monad!
03:52:42 <vixey> ok I actually was going to say more than just that ..
03:52:52 <Axman6> heh, ok, sorry
03:53:25 <yitz> Axman6: look at Cale's wiki pages: http://www.haskell.org/haskellwiki/Monads_as_containers and http://www.haskell.org/haskellwiki/Monads_as_computation.
03:53:26 <lambdabot> Title: Monads as containers - HaskellWiki
03:53:47 <Stinger> monads are a way of abstracting sequencing, is the best overall description I have heard
03:54:04 <Axman6> ok, thanks
03:54:47 <vixey> Stinger: knowing that doesn't give you any ability to program using them or define your own
03:55:13 <Stinger> no, but it helps to give you an idea of what the hell they are there for :)
03:56:06 <yitz> Stinger: yeah, that's the "as computation" metaphor. There's also: monads are containers that you can map over. You think about each of those metaphors, then all of sudden you realize why they are really both the same thing, and *bing*. See those two wiki pages.
04:06:39 <Stinger> don't suppose anyone has built hdbc-postgresql on windows recently?
04:08:33 <hackage> Uploaded to hackage: Codec-Image-DevIL 0.1
04:22:38 <Axman6> "If you understood the above, then you have a good start on understanding monads in Haskell." and, if you didn't? -_-
04:23:25 <sioraiocht> Axman6: whatcha wantot know about monads? heh
04:24:18 <Axman6> sioraiocht: well, what they are would be good, why they're there, and how they're used (and how to use them preferably)
04:24:31 <luqui> Axman6, did you read the monads as computation one?
04:24:33 <sioraiocht> Axman6: have you ever used the maybe type before?
04:24:40 <Axman6> luqui: no
04:24:47 <luqui> it starts with some motivational words
04:24:56 <Axman6> sioraiocht: no i haven't, but i thin i do understand it
04:25:01 <Axman6> k*
04:25:35 <luqui> let's do this socratically
04:25:51 <luqui> Axman6, what is the Maybe type?
04:26:26 <Axman6> data Maybe a = Just a | Nothing ?
04:26:46 <luqui> Axman6, so what do you use it for?
04:26:58 <Axman6> choice...
04:27:17 <luqui> be a bit more specific.  an example is fine if that's the easiest way
04:27:20 <Axman6> well, that's the best way i put it at least
04:27:33 <luqui> (I am going somewhere with this... ;-)
04:28:07 <Axman6> well, the one my friend and i have talked about is a minary search tree, where if we find the value, return Just value, otherwise Nothing
04:28:12 <Axman6> binary even
04:28:47 <luqui> so you use Nothing when your computation failed in some sense
04:28:54 <luqui> (some specific sense, not just "bad programming")
04:29:04 <Axman6> yes
04:29:26 <luqui> okay.  Let's say you have two functions, f and g, both with type Int -> Maybe Int
04:29:44 <Axman6> yep
04:29:51 <luqui> and you want to stitch them together, passing the result of f to g
04:30:02 <luqui> but returning Nothing if f returns Nothing, of course
04:30:17 <luqui> how would you write that?
04:30:30 <Axman6> so g $ f, yes?
04:30:46 <luqui> er, probably g . f
04:30:59 <luqui> but that doesn't type check, because g wants an Int and f returns a Maybe int
04:31:10 <Axman6> yeah, i'm never quite sure when to use which
04:31:12 <Axman6> ah, yes
04:31:49 <luqui> so something of the form: h x = ... g ... f ... x ....
04:31:54 <luqui> (not necessarily in that order)
04:32:20 <Axman6> wait, i'm not sure how i'd do that...
04:32:52 <luqui> you know how to use case?
04:33:24 <Axman6> i haven't used it, and i'm not sure of the syntax. but i think so
04:33:33 <Axman6> i have seen it used in haskell though
04:34:05 <luqui> yeah, the one-liner syntax for case is a bit more annoying than what is usually seen, but I'll indulge you:
04:34:17 <Axman6> heh, ok
04:34:36 <luqui> h x = case f x of { Nothing -> Nothing ; Just result -> g result }
04:34:42 <luqui> er sorry
04:34:51 <luqui> wait no, that's right.
04:34:59 <dainanaki> yep
04:35:09 <Axman6> yeah, i was just about to write something like like that :)
04:35:20 <Axman6> ok, so far i'm getting this
04:35:45 <luqui> okay.  that was the forward part.  now we start jumping upward in levels of abstraction :-)
04:36:30 <luqui> so you could presumably write a function called, uh, pass :: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
04:36:46 <Axman6> sure
04:36:53 <luqui> which is just h parameterized over f and g
04:37:30 <Axman6> something like h f g x = case f x of { Nothing -> Nothing ; Just result -> g result }
04:37:35 <Axman6> right?
04:37:37 <luqui> But what if you had another kind of failure?  What if you had data Failable a = Success a | Failure String
04:37:39 <luqui> yeah
04:37:56 <Axman6> sounds like Either...
04:38:09 <luqui> yeah it pretty much is
04:38:11 <Axman6> i've been doing a little reading...
04:38:20 <luqui> but that's not really important
04:38:28 <luqui> the important thing is that you could write pass for it also
04:39:18 <luqui> and then we get to my favorite: lists
04:39:31 <luqui> you can also write pass :: (a -> [b]) -> (b -> [c]) -> a -> [c]
04:39:48 <luqui> which takes *all* the results of the first function, passes each of them to the second, and concatenates them together
04:40:16 <luqui> essentially defining "function composition" for functions that return multiple results
04:40:22 <Axman6> could you give an example? i think i get it, but it would help...
04:41:25 <luqui> yeah.  say f x = [x+1,x+2] and g x = [2*x,3*x]
04:41:45 <Axman6> yep
04:41:50 <luqui> then pass f g 4 = [2*(x+1),2*(x+2),3*(x+1),3*(x+2)]
04:41:56 <luqui> where by x I meant 4
04:42:11 <Axman6> yeah, ok
04:43:01 <luqui> Maybe, Failable, [] are all monads, and what 'pass' does is the defining feature, that's what the Monad instance defines
04:43:23 <luqui> it defines something almost like it, called bind
04:43:37 <Axman6> which is >>= right?
04:43:40 <luqui> instead of (a -> m b) -> (b -> m c) -> a -> m c, it just defines m a -> (a -> m b) -> m b
04:43:44 <luqui> right
04:43:56 <Axman6> ok
04:44:11 <luqui> but it should be easy to see (from the types even) that they are inter-definable
04:44:32 <Axman6> what do you mean?
04:45:00 <luqui> you could define >>= if you had pass, and you could define pass if you had >>=
04:45:34 <luqui> so there's no essential reason to prefer one over the other, it's just aesthetic...
04:46:12 <Axman6> would that make pass something like pass f g x = f x >>= g ?
04:46:16 <Axman6> no...
04:46:22 <opqdonut> yes
04:46:33 <luqui> yep
04:46:35 <Axman6> heh, well, there you go
04:46:50 <luqui> (we call pass "kleisli composition" and spell it ">=>")
04:47:01 <Axman6> how would that expand out?
04:47:11 <luqui> Axman6, what do you mean?
04:47:29 <Axman6> i'm not totally sure what happens in pass f g x = f x >>= g
04:47:43 <Axman6> f x turns x into a monad right?
04:47:59 <luqui> Axman6, well... hmm... hang on
04:48:05 <luqui> one more thing :-)
04:48:09 <Axman6> heh, ok
04:48:22 <luqui> the other thing you need is a way to say "success' (in the case of Maybe and Failable)
04:48:24 <Axman6> well, returns a monad containing x
04:48:54 <luqui> we call that return :: a -> m a
04:49:14 <luqui> so return 42 = Just 42 (for Maybe), return 42 = Success 42 (for Failable)
04:49:29 <Axman6> ok
04:49:37 <Axman6> and return Nothing = ...
04:50:01 <luqui> Axman6, hmm, that would return m (Just a) for some monad m
04:50:23 <luqui> so return Nothing could be Just Nothing, or Success Nothing...
04:50:26 <Axman6> whoops, yeah dw
04:50:44 <luqui> do you have a hunch about what it might look like for lists?
04:51:01 <Axman6> return x = [x]?
04:51:07 <luqui> excellente!
04:51:08 <Axman6> pretty sure i read that earlier, and it makes sense
04:51:35 <Axman6> oo, might be able to use that in something i've written..
04:51:43 <SamB_XP_> and here I thought it was (:[])
04:51:59 * luqui is partial to the robot also
04:52:24 <FordCortina> is it possible to express a type function with GADTs?
04:52:39 <luqui> So... let's see, where to go from here?... Axman6, any questions you have?
04:52:44 <FordCortina> especially one that needs a kind of pattern matching....
04:52:57 <dolio> That's more of a type families thing.
04:53:22 <Axman6> i still find >>= a little confusing
04:54:19 <Axman6> how handy: "sum $ Prelude.map (read.return) (show $ 2^1000)"
04:54:41 <Axman6> i was using (\x -> read [x]) originally
04:54:43 <luqui> Axman6, let's do some examples with it.   Just 4 >>= (\x -> Just (x + 1))
04:55:01 <Axman6> Just 5?
04:55:10 <Axman6> or... 5...
04:55:16 <Axman6> no
04:55:35 <luqui> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
04:55:41 <luqui> so it's got to be a Maybe.
04:55:47 <Axman6> ok
04:55:54 <Axman6> so, it is Just 5
04:56:01 <luqui> yeah.
04:56:20 <luqui> but we can rewrite that to Just 4 >>= (\x -> return (x+1))
04:56:31 <luqui> (or even return 4 >>= .. as well)
04:56:55 <luqui> so that (\x -> return (x+1)) will work on *any* monad, and increment whatever it's holding
04:57:08 <Axman6> and Success 4 >>= (\x -> return (x+1)) would work also?
04:57:11 <luqui> right
04:57:21 <dolio> > liftM (\x -> x+1) (Just 4)
04:57:25 <lambdabot>  Just 5
04:57:30 <luqui> even:
04:57:36 <luqui> > [1,2,3,4,5] >>= (\x -> return (x+1))
04:57:36 <FordCortina> has anybody read this paper http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.pdf ?
04:57:37 <lambdabot>  [2,3,4,5,6]
04:57:38 <lambdabot> Title: Polymorphic Typed Defunctionalization and Concretization, http://tinyurl.com/5qs4rw
04:57:57 <Axman6> ok, that is a little more confusing
04:58:00 <FordCortina> pottier and gautier seem to be saying that anything you can do with TCs can be done with GADTs
04:58:04 <Axman6> i see what happened, but not totally sure why
04:58:09 <luqui> which increments whatever it's holding; it's just that [] can hold multiple things
04:58:16 <luqui> yeah, okay, let's expand that one
04:58:24 <Axman6> thanks
04:58:25 <dolio> What's TC?
04:58:29 <FordCortina> which would mean that type-function might be possible although i dont see how
04:58:40 <FordCortina> dollios: type class
04:58:45 <dolio> Oh.
04:58:48 <Axman6> heh, i could be studying for a materials quiz right now, but i don't think i'll learn much, and it
04:58:51 <luqui> for list, xs >>= f = concat (map f xs)
04:58:52 <Axman6> s not worth much ;)
04:59:08 <Axman6> ah yes
04:59:27 <Axman6> and the map part would return a list of lists?
04:59:28 <FordCortina> dolio: they don't mention MPTCs or functional dependencies though
04:59:36 <luqui> Axman6, right
04:59:40 <mattam> FordCortina: you can have a GADT indexed by two types where the constructors describe the type function?
04:59:49 <luqui> because f :: a -> m a   (which is a -> [a] for lists)
04:59:55 <luqui> er I mean a -> m b
05:00:26 <FordCortina> mattam: i think ive had a go at that, i didnt get very far
05:00:50 <luqui> Axman6, satisfed, or need to see more?
05:00:55 <luqui> with this example I mean
05:01:01 <Axman6> nah i think i get it now
05:01:01 <FordCortina> mattam: you always have the problem "how do i put two different cases under the same name", if you get what i mean
05:01:11 <Axman6> does >>= have to be defined for each monad?
05:01:17 <luqui> Axman6, yep
05:01:18 <dainanaki> yes
05:01:20 <luqui> that and return
05:01:21 <FordCortina> say you are doing a type-level `and`
05:01:24 <Axman6> ok, good
05:01:42 <FordCortina> the result is going to be decided on the value of the first argument
05:01:55 <luqui> list being my favorite monad, we can start using it to do combinatorical programming
05:01:55 <FordCortina> and you have two cases to treat
05:02:10 <FordCortina> assuming the arguments get evaluated in that order
05:02:30 <mattam> Wait a minute, what's a type-level and?
05:02:43 <luqui> > [1,2,3,4,5] >>= (\x -> [1,2,3,4,5] >>= (\y -> if (x + y) `mod` 3 == 0 then return (x,y) else []))
05:02:45 <lambdabot>  [(1,2),(1,5),(2,1),(2,4),(3,3),(4,2),(4,5),(5,1),(5,4)]
05:03:09 <luqui> which is just:
05:03:27 * Botje has to implement gauss elimination for euler101 but is too lazy
05:03:29 <Botje> some other time :)
05:03:32 <luqui> > do { x <- [1,2,3,4,5]; y <- [1,2,3,4,5]; if (x + y) `mod` 3 == 0 then return (x+y) else [])
05:03:32 <lambdabot> Unbalanced parentheses
05:03:35 <luqui> > do { x <- [1,2,3,4,5]; y <- [1,2,3,4,5]; if (x + y) `mod` 3 == 0 then return (x+y) else [] }
05:03:36 <lambdabot>  [3,6,3,6,6,6,9,6,9]
05:03:43 <luqui> er, you know what I meant :-)
05:03:55 <luqui> (x,y) instead of (x+y)
05:04:03 <FordCortina> mattam: you could index a type by a boolean, except the normal bool wont do because its a value. So you make a new data type called TAnd say. And then suddenly you will need a function that can `and` these types together
05:04:24 <yitz> @src gcd
05:04:24 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
05:04:24 <lambdabot> gcd x y = gcd' (abs x) (abs y)
05:04:24 <lambdabot>    where gcd' a 0  =  a
05:04:24 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
05:04:28 <FordCortina> s/suddenly/probably/
05:04:45 <yitz> Botje: here ^^
05:04:46 <luqui> Axman6, so aaanyway, I'm guessing you grok Maybe and [], but probably IO is still a bit of a mystery
05:04:53 <rwbarton> gcd 0 0 is clearly 0
05:05:01 <Axman6> luqui: oh yes, very much so :)
05:05:14 <FordCortina> mattam: eg: foo :: a b1 -> a b2 -> a (And b1 b2)
05:05:24 <yitz> rwbarton: it's infinity
05:05:33 <mattam> Ok.
05:05:41 <Botje> yitz: http://en.wikipedia.org/wiki/Gaussian_elimination
05:05:41 <lambdabot> Title: Gaussian elimination - Wikipedia, the free encyclopedia
05:05:45 <Botje> i meant that one :)
05:05:48 <luqui> Axman6, there's a small revolt in Haskell complaining that IO has no simple semantics, and is thus quite hard to explain.
05:05:49 <dolio> data TTrue ; data TFalse ; data TAnd a b c where TId :: TTrue b b ; TNull :: TFalse b TFalse
05:05:52 <yitz> Botje :)
05:06:09 <luqui> Axman6, but another monad is State, which looks like s -> (a,s) for some type s
05:06:15 <Axman6> luqui: i spent about two hours trying to do some very simple IO, so i'd have to agree
05:06:30 <Axman6> ah yes, i'd like to know how State works
05:06:32 <dolio> foo :: TAnd b1 b2 r -> a b1 -> a b2 -> a r
05:06:35 <FordCortina> dolio: ah
05:06:36 <luqui> Axman6, and that's kind of what IO is, except s is "the type of the entire real world"
05:06:49 <Axman6> ha, ok
05:07:18 <FordCortina> dolio: yes that might work :) thanks
05:07:47 <luqui> Axman6, so functions of type s -> (a,s) are monads.  what would return be for such a function
05:07:50 <dolio> FordCortina: That's probably less nice than: type family TAnd a b :: * ; type instance TAnd TTrue b = b ; type instance TAnd TFalse b = TFalse
05:08:11 <luqui> knowing that it's meant to take the state, and return a modified state
05:08:13 <dolio> foo :: a b1 -> a b2 -> a (TAnd b1 b2)
05:08:22 <FordCortina> dolio: yes, but its interesting to know you can do it with GADTs
05:08:25 <yitz> luqui: imho the State RealWorld stuff is an implementation detail. If you accept "monad as computation", IO is trivial to understand.
05:08:27 <Axman6> a?
05:08:33 <hackage> Uploaded to hackage: hoogle 4.0.0.2
05:08:44 <mattam> FordCortina: so, problem solved?
05:08:50 <dolio> Yeah. A big difference is that GADTs aren't open like type classes and type families.
05:08:52 <luqui> yitz, I do not accept "monad as computation" as semantics!
05:08:57 <FordCortina> mattam: i think so
05:09:00 <luqui> so I am forced to handwave
05:09:05 <luqui> here at least I can give a semantics
05:09:13 <FordCortina> dolio: which can be good or bad depending on what you want to do
05:09:25 <luqui> Axman6, well, return :: a -> m a, so return :: a -> (s -> (a,s))
05:09:40 <luqui> Axman6, which doesn't look like the type of your function...
05:09:45 <FordCortina> dolio: i think its harder (impossible?) to run into problems with the coverage condition with GADTs too
05:09:56 <opqdonut> coverage condition?
05:10:30 <Axman6> luqui: ok, not sure where the s is coming from...
05:10:32 <FordCortina> opqdonat: i that was the name, type families are a bit like muli parameter type classes in some ways
05:10:41 <FordCortina> (with fun deps)
05:10:41 <Axman6> could you maybe give an example?
05:10:59 <yitz> luqui: well if you mean formal denotational semantics, then no. But in the informal sense, that's all a programmer needs to know to understand completely how to use IO in practice.
05:11:10 <luqui> Axman6, oh, State is parameterized over a state type.  so State Int String is a "computation" which has an Int as its state and returns a String
05:11:12 <Axman6> also, thanks doe this, you're helping a lot, and you're much clearer than anything else i've read online
05:11:28 <opqdonut> interactive teaching is always better.
05:11:37 <FordCortina> opqdonat: if, a b -> c, then you have to make sure that c is in a or b in all instances... or something like that
05:11:38 <luqui> Axman6, it's much easier to do this when your reader is giving you guidance :-)
05:11:47 <dolio> FordCortina: Well, GADTs require you to pass around type witnesses all the time. So you're probably doing more manual work than with multi-param type classes and fundeps and such.
05:11:47 <Axman6> indeed
05:11:52 <yitz> Axman6: and, fortunately, this is all being logged! :)
05:11:53 * dainanaki is secretly following Axman6 and luqui's conversation
05:11:54 <dolio> And there's always runtime overhead.
05:12:00 <opqdonut> FordCortina: ok
05:12:31 <Axman6> yitz: yeah, i was thinking it would be useful to put this convo online :P
05:12:48 <dainanaki> socratic approach to monads!
05:12:53 <luqui> Axman6, so return for states presumably should just not modify the state.
05:12:54 <Axman6> could this be, the best monad tutorial ever? :o
05:13:04 <luqui> there is no best monad tutorial
05:13:06 <opqdonut> I agree with dolio, GADTs might be equivalent to typeclasses in some way but they're much more cumbersome
05:13:20 <luqui> in order to rewire a circuit, you have to see how it is wired already
05:13:36 <Axman6> ok
05:13:36 <mattam> dolio: overhead of GADT's w.r.t. TCs?
05:14:07 <dolio> Lots of type class stuff can be resolved at compile time, so there's no actual dictionary passing.
05:14:30 <Axman6> so let me get this straight, return for State would return a function that takes a ... something, and turns it into some other something. ok, i thought i had it...
05:14:42 <dolio> Whereas if you encode the stuff yourself into GADTs, you'll be passing around the GADT all the time.
05:14:50 <dolio> The compiler won't erase it.
05:14:53 <dolio> At least, GHC won't.
05:15:04 <luqui> Axman6, yeah, and you have no idea what that function is, because return has to work no matter what the state type is
05:15:04 <FordCortina> dolio: ah i didnt know that
05:15:14 <luqui> Axman6, so you really only have one choice :-)
05:15:15 <mattam> Well, I would expect it's constant propagation just the same.
05:15:25 <Axman6> what do you mean?
05:15:26 <luqui> Axman6, ehem, you have no idea what that *something* is
05:15:36 <dolio> It has to, really, because the GADT could be bottom.
05:15:44 <dolio> Since it's Haskell.
05:16:04 <luqui> Axman6, in the same way that there's only one way to implement id :: a -> a, which is id x = x, there's only one way to implement return :: a -> s -> (a,s)
05:16:26 <mattam> Ah right. Damn partiality.
05:16:45 <Axman6> i don't remember seeing that first -> s the first time...
05:17:00 <luqui> it was written a -> (s -> (a,s))
05:17:06 <luqui> (but -> is right-associative!)
05:17:26 <Axman6> heh, ok
05:17:39 <Axman6> oh, i think i get it
05:17:46 <mattam> dolio: Well, if you introduce it as a constructor it can't be bottom right.
05:17:53 <luqui> so it'd be, return x = \currentState -> (x,currentState)  -- the verbose way ;-)
05:18:08 <luqui> which just returns the value, and the state unmodified
05:18:18 <Axman6> so, we get back a function that would take an s, and turn it into (a,s), using the a we fed return?
05:18:25 <dolio> mattam: Introduce what as a constructor?
05:18:26 <luqui> yeah
05:18:47 <mattam> dolio: The instance of the GADT
05:18:54 <Axman6> and what are the purposes of a and s here?
05:19:19 <dolio> I'm not sure I follow.
05:19:34 <Axman6> i can see what happens, but knowing how they're actually used would be good
05:19:43 <dolio> In general, you can encode type classes like 'data TypeRep where ...' where you have a constructor for each type.
05:19:47 <mattam> If you emulate TCs with GADTs, to each class instance will correspond a constant of the GADT type.
05:19:52 <luqui> Axman6, well there are other functions of type s -> (a,s)
05:20:05 <dolio> And then a type class becomes 'method :: TypeRep -> ... ; method Int = ... ; ..'
05:20:08 <luqui> for example a counter: (\s -> (s,s+1))
05:20:19 <dolio> Where the match against the type rep selects which instance you want.
05:20:26 <luqui> which returns the value of the counter and increments it (intuitively speaking)
05:20:30 <SamB_XP_> um, wth?
05:20:35 <dolio> But someone can always call 'method undefined ...', which doesn't select any branch.
05:20:45 <SamB_XP_> I don't think a -> s -> (a, s) fits the type for return
05:20:58 <luqui> SamB_XP_, hmm?
05:21:11 <SamB_XP_> > return :: a -> s -> (a, s)
05:21:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, s)
05:21:12 <lambdabot>     In the ...
05:21:13 <luqui> I am ignoring the newtype for the moment
05:21:22 <SamB_XP_> hmm.
05:21:34 <luqui> essentially treating it as:  type State s a = s -> (a,s)
05:21:56 <luqui> even though it would not be legal to declare Monad for it, I think the constructors just confuse the issue further
05:21:57 <Axman6> so state is a kind of function?
05:22:09 <luqui> Axman6, yeah
05:22:17 <Axman6> ok
05:22:34 <SamB_XP_> in that case, allow me to express my confusion & distate regarding the use of (a, s) instead of (s, a) like any sane person would write
05:22:40 <mattam> dolio: I was thinking of encoding each class with a GADT representing it completely, so that each constructor would contain the whole implementation. Then when calling a method you'd have the actual instance at hand, which would be a constant.
05:22:53 <SamB_XP_> yes, I know this is from the MTL -- I still don't get how they came up with that crazy order!
05:23:25 <luqui> SamB_XP_, I don't see one reason to prefer one over the other except for technical reasons about instances of Functor...
05:23:39 <SamB_XP_> luqui: technical reasons?
05:23:54 <dolio> mattam: Yeah, you can constrain it more. But in general, bottom is a member of every (lifted) type, so someone could always call your function with 'undefined' in the GADT spot.
05:24:03 <luqui> SamB_XP_, haskell allows Functor ((,) a) but not "Functor (flip (,) a)"
05:24:09 <dolio> Unless you do whole program analysis and prove that that never happens.
05:24:13 <SamB_XP_> my reasons are not a bit technical ;-)
05:24:23 <luqui> what is your reason?
05:24:23 <dolio> (Like jhc, maybe.)
05:24:50 <SamB_XP_> well, it seems more natural ;-)
05:24:51 <luqui> Axman6, so did you get the incrementor example?
05:24:58 <luqui> SamB_XP_, oh that's very convincing
05:25:06 <Axman6> not entirely...
05:25:08 <SamB_XP_> I'm not the only one as thinks so
05:25:11 <dolio> JHC actually encodes type classes as a type rep GADT, and does specialization via dead code elimination like that.
05:25:38 <Axman6> could you gtive an example?™
05:25:47 <luqui> Axman6, that sortof was an example...
05:25:47 <SamB_XP> dolio: too bad it has bugs regarding the ordering of the type parameters ...
05:25:49 <mattam> dolio: indeed, but every legitimate call could be inlined because the argument would be a constant... Well herediteraly as you say.
05:26:21 <Axman6> ok, so let me try something...
05:26:26 <SamB_XP> at least, last I heard it did
05:26:34 <SamB_XP> saw, rather
05:26:59 <SamB_XP> it generated ill-typed RULES when compiling Control.Arrow
05:27:18 <Axman6> i could have f s = return (\s -> (s,s+1))...?
05:27:48 <Axman6> i don't quite get how that stores state...
05:27:55 <Axman6> i could be totally missing something here
05:28:07 <SamB_XP> ???
05:28:41 <SamB_XP> State doesn't so much STORE state as thread it through the computation
05:28:52 <luqui> Axman6, no you can't return it. return introduces a value into a monad; \s -> (s,s+1) is already in the monad
05:29:10 <luqui> SamB_XP, that could be a good way of putting it...
05:29:45 <Axman6> ok, i'm missing something here, and i'm not quite sure what
05:30:06 <luqui> hmm, okay, here's an example
05:30:11 <luqui> a more... complete one
05:30:12 <Axman6> cheers
05:30:57 <luqui> let's deifne:  next = \s -> (s,s+1)
05:31:20 <luqui> so then next >>= (\x -> next >>= (\y -> return (x,y))
05:31:54 <luqui> oh, we haven't defined >>= yet
05:32:14 <luqui> it's kind of a bitch in the details, but conceptually it's easy.  hmm, how to approach this
05:32:38 <luqui> maybe I can handwave my way through it
05:32:47 <Axman6> heh, ok
05:33:09 <luqui> so this operation as a whole, is of type State Int (Int,Int)
05:33:33 <luqui> meaning it is a *function* (by def of State) which takes an Int, and returns an ((Int,Int),Int)
05:33:54 <luqui> so we give it, say, 0
05:33:59 <luqui> it passes that to next and gets (0,1)
05:34:27 <luqui> x becomes 0, and it passes the new state to the second occurrence of next
05:34:28 <Axman6> wait, why's it return ((Int, Int), Int)?
05:34:56 <luqui> type State s a = s -> (a,s), so State Int (Int,Int) = Int -> ((Int,Int),Int)
05:35:46 <Axman6> ah, and if it were Stata Int Int, it would return (Int, Int) yes?
05:35:50 <luqui> yeah
05:35:51 <Axman6> e*
05:35:59 <Axman6> ok
05:36:22 <luqui> so right, it passes the new state (1), which the first 'next' returned, to the second 'next'
05:36:24 <luqui> and gets (1,2)
05:36:41 <Axman6> ok
05:36:49 <luqui> and y becomes 1  (meaning it passed 1 to that lambda binding y)
05:37:03 <luqui> and then it returns (x,y) = (0,1)
05:37:22 <luqui> meaning it returns a function (\s -> ((0,1),s)
05:37:34 <luqui> essentially saying that part doesn't modify the state
05:37:43 <luqui> the function as a whole returns ((0,1),2)
05:38:25 <luqui> (that wasn't a very direct explanation, hoping for it to come together between the lines in some sense)
05:38:33 <Axman6> how is the (0,1) passed to next?
05:38:35 <rwbarton> Can I try for a moment?
05:38:42 <luqui> rwbarton, sure
05:38:56 <luqui> er I guess that is up to Axman6 :-)
05:39:02 <Axman6> go for it :)
05:39:15 <rwbarton> A value of State s a is a function that takes an initial state and returns some value, along with a modified state.
05:39:21 <rwbarton> Hence State s a = s -> (a, s)
05:39:42 <rwbarton> I want to explain how we bind two of these together
05:40:27 <Axman6> ok
05:40:40 <rwbarton> or more precisely define >>=
05:41:28 <rwbarton> Let's say v is a State s a, and f is a function a -> State s b.  What can we do?
05:41:45 <rwbarton> Well, we need a new State s a.  So suppose we're given some initial state initialState
05:42:22 <rwbarton> v tells us how to get a value x, together with a transformed, intermediate state intermediateState.
05:43:06 <rwbarton> Then f x is a new State s b, so we can apply it to intermediateState.
05:43:11 <rwbarton> In Haskell,
05:43:46 <rwbarton> (>>=) v f initialState = let (x, intermediateState) = v initialState ; (y, finalState) = f x in (y, finalState)
05:44:46 <rwbarton> Let's suppose our actions don't return any value, so a = b = ()
05:45:47 <rwbarton> Then v :: State s () = s -> ((), s) which I'll treat as the same as s -> s
05:46:09 <rwbarton> Also f :: () -> State s () which I'll treat as State s () or again s -> s
05:46:37 <rwbarton> Then (>>=) just becomes composition of functions.  As SamB_XP said, the state is "threaded" through the computation
05:46:55 <luqui> rwbarton, your restricting a and b to () is causing me to see new beauty in the state monad...
05:47:07 <rwbarton> That probably went a little fast--it was more complicated than I expected :)
05:47:07 <Axman6> and confusing me...
05:47:14 <Axman6> heh
05:47:37 <rwbarton> Anyways, maybe thinking about State s () first is a good idea
05:47:38 <luqui> rwbarton, yeah, like I said, the details are kind of bitchy :-)
05:48:03 <Axman6> how about we skip State for now
05:48:15 <luqui> that was my bootstrap to IO.
05:48:53 <luqui> essentially I was going to go with IO a = State TheRealWorld a
05:49:04 <Axman6> for some reason i can't get this idea of State being like a global hash table
05:49:09 <Axman6> which i know is wrong
05:49:19 <luqui> ah, here it's just a single value
05:50:00 <luqui> which each piece of the computation may modify if it likes
05:50:03 <Axman6> how about Either. why is that a monad? does it need to be a monad? could it not just be an ADT?
05:50:28 <luqui> Axman6, Either (or more specifically Either a for some a) is a monad in the same way Maybe is
05:50:43 <luqui> where Left deones failure, and Right denotes success
05:51:03 <luqui> but there are ADTs which are not monads
05:52:18 <Axman6> so why does Either a need to be a monad?
05:52:42 <luqui> it doesn't really need to be one, it just is one.  i.e. there is an implementation of >>= and return which satisfy the laws
05:52:48 <luqui> and then somebody finds it useful
05:52:59 <luqui> (for example it's good as a Maybe monad that returns an error message)
05:53:11 <Axman6> i mean, semantically, it looks like a normal ADT, and i don't get what being a monad brings to the table
05:54:01 <ziman> it doesn't /need/. You can take any set (a type) and declare that as an algebraic structure (say, monad) by defining how the structure's operations behave on the set
05:54:37 <Axman6> i still don't see why monads are useful -_-
05:54:39 <luqui> Axman6, it means we can use >>= on it, to thread together computations of the form (a -> Either b c) in that failure mode...
05:54:45 <ziman> by declaring it a Monad, you get convenient (and abstract) way to do stateful computations, for example
05:54:56 <lilachaz1> rwbarton: i think you meant (>>=) v f initialState = let (x, intermediateState) = v initialState; (y, finalState) = f x intermediateState in (y, finalState)
05:55:18 <rwbarton> lilachaz1: Yes, that's right
05:55:25 <lilachaz1> Axman6: they're a convenience more than anything. they make certain types of programs easier to write
05:55:42 <rwbarton> lilachaz1: I got confused writing it :)
05:55:56 <luqui> Axman6, (and the more I use haskell, the less useful they're becoming... not that that should discourage you ;-)
05:56:01 <Axman6> rwbarton: i got confused reading it too, do you're not alone :)
05:56:09 <lilachaz1> rwbarton: i never get the definition of (>>=) right the first time ;-)
05:56:15 <trez> > read "test" :: String
05:56:17 <lambdabot>  "Exception: Prelude.read: no parse
05:56:17 <lilachaz1> (for *any* monad)
05:56:40 <luqui> I read:  (>>=) v f = initialState = let blah blah blah blah ack complicated I think I can figure out what this should do based on the type blah blah balh ,finalState)
05:56:41 <Axman6> > read ["test"] :: String
05:56:42 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
05:56:48 <Axman6> :\
05:57:02 <lilachaz1> luqui: heh :)
05:57:19 <thoughtpolice> :t read
05:57:20 <lambdabot> forall a. (Read a) => String -> a
05:57:43 <thoughtpolice> the type of ["test"] is [String], not String
05:57:53 <luqui> Axman6, I think more explanation will probably serve just to kick your brain while it's down for today
05:57:54 <Axman6> yeah
05:58:07 <luqui> Axman6, what was the IO thing you failed to do?
05:58:25 <Axman6> i'll have to find it, it was about 5 months ago...
05:58:29 <luqui> (the 'you don't have to understand monads to use them' approach :-P)
05:59:15 <luqui> most monad programming can be done type-directed; what's going on under the hood becomes irrelevant
05:59:21 <lilachaz1> rwbarton: v >>= f = uncurry f . v
05:59:32 <luqui> (not that you should give up trying to understand that, it just takes meditation)
06:00:06 <lilachaz1> or possibly medication?
06:00:23 <rwbarton> lilachaz1: That definition is even more confusing :)
06:00:29 <Axman6> http://hpaste.org/9405
06:00:36 <luqui> and also incorrect
06:00:48 <luqui> :t \v f -> uncurry f . v
06:00:49 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a, b) -> (a -> b -> c) -> f c
06:01:46 <luqui> oh wait... no it's obscurely correct I think
06:01:52 <luqui> wow, cool
06:02:41 <Axman6> luqui: you talking to me?
06:02:41 <rwbarton> :t (\v f -> uncurry f . v) :: (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
06:02:42 <lambdabot> forall s a b. (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
06:02:48 <Axman6> because that code does work
06:03:05 <Axman6> but far out it was a bitch to figure out
06:03:29 <luqui> Axman6, I was talking to lilachaz1
06:03:48 <lilachaz1> luqui: yeah, it's a little subtle ;-)
06:03:51 <luqui> haven't looked at the paste yet
06:04:06 <Axman6> ok
06:04:14 <dmwit> return x e = x; f >>= g e = g (f e) e; -- figured this one out last night
06:05:14 <lilachaz1> dmwit: looks like reader monad?
06:05:18 <dmwit> yeah
06:06:09 <Axman6> man, i wrote that code, and i still just barely follow it
06:06:47 <luqui> Axman6, looks fairly typical imperative style.  Are you comfortable with recursion in other languages?
06:07:18 <Axman6> sure, but i'm more comfortable with it in haskell
06:08:34 <hackage> Uploaded to hackage: hfov 0.5
06:08:34 <luqui> Axman6, what do you find confusing about it?  (eg. any line in particular?)
06:08:53 <Axman6> it looks yuck mainly
06:09:09 <Axman6> but, kinda nice too
06:10:42 <luqui> yeah, ifs and do notation mix like hot fudge and prime rib
06:11:34 <rwbarton> fwiw, I can't think of a better way to write it without changing the behavior slightly
06:13:11 <luqui> http://hpaste.org/9405#a1
06:13:44 <luqui> right, I see the pattern a lot.  I use the function whileM
06:14:04 <luqui> whileM :: (a -> Bool) -> m a -> m [a]
06:14:12 <luqui> (which I had to write m'self)
06:14:31 <rwbarton> yeah, that's what I hoogled for
06:15:21 <dmwit> readLn :: Read a => IO a
06:15:52 <Axman6> i think i tried to use that originally
06:15:58 <rwbarton> Of course, if this was the whole program I'd write  map read . takeWhile (/= "") . lines <$> getContents  and someone would object to the use of lazy IO :)
06:16:04 * luqui wonders if there's a natural explanation for whileM's behavior on the list monad
06:16:04 <dmwit> Then you gotta catch an exception to exit cleanly, though.
06:16:17 <Axman6> and died when i entered the empty line
06:16:35 <dmwit> right, exceptions exshmeptions
06:16:58 <luqui> maybeReadLn I suspect would be more useful
06:17:06 <rwbarton> whileM on the list monad reminds me of the game mornington crescent
06:17:07 <Axman6> indeed
06:17:07 <luqui> (again, doesn't exist)
06:17:18 <luqui> rwbarton, ? wtf
06:17:26 <luqui> (that was just a strange statement)
06:18:06 <rwbarton> It's a "game" where players take turns naming stops on the london underground, and the first player to name mornington crescent wins
06:18:36 <osfameron> it's allegedly funny
06:18:40 <luqui> uhh
06:18:48 <rwbarton> whileM (/= morningtonCrescent) (listOfStops) is the list of ways to play this game
06:18:52 <dmwit> whileM doesn't do anything for the list monad, does it?
06:18:54 <Axman6> rwbarton: can't you just say mornington crescent?
06:19:09 <rwbarton> Axman6: Yes.  Hence the quotes around "game" :)
06:19:18 <dmwit> It either stops right away (if all the elements become False under your predicate) or loops forever (if even one of them becomes True)...
06:19:24 <Axman6> heh, ok
06:20:03 <luqui> :define whileM f a = do { x <- a; if f a then liftM (x:) (whileM f a) else return [] }
06:20:12 <luqui> ?define whileM f a = do { x <- a; if f a then liftM (x:) (whileM f a) else return [] }
06:20:13 <lambdabot> Undefined.
06:20:19 <luqui> huh?
06:20:23 <luqui> ?help
06:20:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:20:24 <dmwit>  ?let
06:20:28 <idnar> > whileM (/= 5) [1..10]
06:20:29 <lambdabot>   Not in scope: `whileM'
06:20:31 <luqui> ?let whileM f a = do { x <- a; if f a then liftM (x:) (whileM f a) else return [] }
06:20:32 <lambdabot> Defined.
06:20:35 <dolio> Heh.
06:20:36 <idnar> > whileM (/= 5) [1..10]
06:20:37 <lambdabot>   add an instance declaration for (Num [t1])
06:20:48 <luqui> :t whileM
06:20:49 <lambdabot> forall (t :: * -> *) t1. (Monad t) => (t t1 -> Bool) -> t t1 -> t [t1]
06:20:53 <idnar> err what
06:20:54 <luqui> oops
06:20:58 <idnar> oh
06:20:59 <luqui> ?let whileM f a = do { x <- a; if f x then liftM (x:) (whileM f a) else return [] }
06:20:59 <lambdabot> <local>:2:29:     Occurs check: cannot construct the infinite type: t = t1 t ...
06:21:01 <dmwit> ?undefine
06:21:01 <lambdabot> Undefined.
06:21:03 <idnar> it wasn't my fault :P
06:21:09 <luqui> ?let whileM f a = do { x <- a; if f x then liftM (x:) (whileM f a) else return [] }
06:21:10 <lambdabot> Defined.
06:21:16 <luqui> :t whileM
06:21:16 <lambdabot> forall t1 (t :: * -> *). (Monad t) => (t1 -> Bool) -> t t1 -> t [t1]
06:21:20 <rwbarton> I think you'll need to use whileM (/= 1) [1..10], if you want to see interesting output
06:21:22 <idnar> > whileM (/= 5) [1..10]
06:21:24 <lambdabot>  Exception: stack overflow
06:21:27 <idnar> > whileM (/= 1) [1..10]
06:21:28 <lambdabot>  [[],[2],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2...
06:21:36 <rwbarton> OK, not that interesting :)
06:21:40 <idnar> heh
06:21:48 <rwbarton> I promise [3] is in there near the back
06:21:52 <idnar> hahaha
06:21:53 <luqui> oh, this might be more interesting on the Omega "monad"
06:21:54 <osfameron> rwbarton: that monad doesn't make up interesting reasons for why a given stop is a good or bad play though :-)
06:22:02 <dmwit> > whileM (/= 0) [1..10]
06:22:03 <lambdabot>  Exception: stack overflow
06:22:10 <luqui> rwbarton, at position omega+1?
06:22:26 <dmwit> oh
06:22:26 <rwbarton> er, well, [2, 3] comes before it
06:22:50 <luqui> oh, so my hunch is it's at omega^2 or omega^2+1
06:23:30 <lilachaz1> Maybe is the Mornington Crescent monad. As soon as someone says Nothing, the game is over.
06:23:40 <dmwit> There's a set with the same cardinality as the reals in there before [3].
06:23:47 <dolio> > let f = do i <- get ; put (i+1) ; return i in runState (whileM (< 20) f) 5
06:23:48 <lambdabot>  ([5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],21)
06:24:09 <luqui> dmwit, no I don't think so
06:24:15 <luqui> no infinite lists in there, are there?
06:24:24 <dmwit> arbitrarily long ones
06:24:29 <luqui> yeah, but still finite
06:24:36 <lilachaz1> luqui: the aleph0+1 element is [2,...,2,3] i think
06:24:55 <lilachaz1> that is, you get all infinite strings of 2s and 3s starting with a 2 before [3]
06:25:00 <lilachaz1> but i'm not sure ;-)
06:25:17 <dmwit> luqui: No, there are infinite lists.
06:25:43 <rwbarton> It seems if you're going to allow the possibility that the result is > omega in length, you should also allow the lists contained in it to be infinite...
06:25:48 <Axman6> [1..] is infinite right?
06:25:52 <lilachaz1> yes
06:25:53 <rwbarton> Probably runs into some kind of cardinality paradox.
06:25:57 <luqui> dmwit, corresponding to when the input list didn't have a 1 at the beginning (never)?
06:26:03 <chr1s> Axman6: I think it ends at 42
06:26:10 <chr1s> but it might also be infinite
06:26:11 <lilachaz1> rwbarton: transfinite computation is well-definable.
06:26:19 <Axman6> take 42 [1..]
06:26:23 <lilachaz1> a friend of mine is doing a PhD on it
06:26:26 <Axman6> >take 43 [1..]
06:26:29 <xerox> > last [[1..],[2..],[3..],[4]]
06:26:30 <lambdabot>  [4]
06:26:39 <Axman6> > take 43 [1..]
06:26:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:26:54 <Axman6> >last.take 43 [1..]
06:26:58 <Axman6> > last.take 43 [1..]
06:26:58 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
06:27:05 <Axman6> > last $ take 43 [1..]
06:27:06 <lambdabot>  43
06:27:14 <rwbarton> where's "thread killed" when you need it?
06:27:20 <Axman6> > last [1..]
06:27:21 <lambdabot>  Tried to use too much memory
06:27:34 <luqui> lambdabot, what's to remember?
06:27:52 <luqui> ah, probably back to his school years.
06:28:03 <Axman6> yeah, just look at the last element!
06:28:18 <luqui> lilachaz1, you mean I could be getting a PhD for the stuff I do for fun?
06:28:29 <luqui> (and also, I understand, working my butt off)
06:30:05 <rwbarton> luqui: 1+(1+(1+...)), sadly...
06:31:29 <luqui> > let ns (!n) = n : ns (n+1) in take 10 (ns 0)
06:31:30 <lambdabot>  Parse error in pattern at "in" (column 28)
06:31:31 <benpicco> Hi, how to make haskell ignore everything behind a comment?
06:31:41 <luqui> > let ns n = n `seq` (n : ns (n+1)) in take 10 (ns 0)
06:31:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
06:31:48 <benpicco> hugs tries to interpret -- -> :-/
06:31:53 <luqui> > let ns n = n `seq` (n : ns (n+1)) in last (ns 0)
06:31:59 <lambdabot>  Exception: Time limit exceeded
06:32:02 <luqui> that's better
06:32:30 <luqui> benpicco, what do you mean?
06:32:49 <luqui> > 42 -- are you just asking what the comment syntax is?
06:32:50 <lambdabot>  42
06:32:54 <benpicco> luqui, I have a comment like -- -> this funktion does something
06:33:05 <Botje> Hugs> 42 -- eek!
06:33:05 <Botje> 42
06:33:06 <lilachaz1> benpicco: don't know about hugs, but you need to ensure that there's not a symbol after the -. --+ is a valid operator for instance.
06:33:12 <benpicco> and haskell tries to interpret the -> behind the comments
06:33:22 <luqui> benpicco, uh... usually not
06:33:29 <luqui> benpicco, are you sure there's a space after the --
06:33:38 <benpicco> yes
06:33:43 <luqui> paste?
06:35:00 <benpicco> http://hpaste.org/9406
06:35:18 <Botje> --(n+n)*(n/2)
06:35:26 <Botje> see? no space :P
06:35:27 <luqui> ahh my guess is that it's an encoding issue
06:35:30 <Toxaris> benpicco: there is no space after the first "--"
06:35:38 <Toxaris> benpicco: trz "-- (" instead of "--("
06:35:47 <luqui> > 42 --(stuff)
06:35:49 <lambdabot>  42
06:35:56 <Toxaris> not that it should make any difference
06:36:05 <Botje> uh
06:36:07 <Botje> and is Pali
06:36:08 <Toxaris> because ( is not exactly a operator char, but who knows what hugs thinks
06:36:15 <Botje> isPali str = str == reverse str
06:36:24 <rwbarton> hpaste seems to think --( doesn't start a comment, at least...
06:36:25 <luqui> benpicco, ghc understands utf-8.  if you're in latin-1 or something that squared symbol is not going to fly
06:39:00 <benpicco> it's utf8
06:39:15 <rwbarton> can you paste the error message?
06:41:02 <b\6> cabal has problems installing haskelldb-hdbc due to needing stuff from pretty, which it says is hidden. did i screw up?
06:41:27 <dcoutts_> b\6: no, the package needs updating to work with ghc-6.8
06:41:49 <luqui> benpicco, (works for me)
06:42:03 <benpicco> ah, k, there was another error in it
06:42:25 * luqui disagrees :-)
06:42:39 <jrh> did a message from me make it to Haskell cafe yesterday?  jefferson.r.heard at gmail dot com?
06:42:54 <benpicco> luite_, somewhere else
06:43:03 <Toxaris> > join ((==) . reverse) . map toUpper $ "Anna"
06:43:04 <benpicco> ops, sorry luite_
06:43:04 <lambdabot>  True
06:43:14 <jrh> I asked the question that I asked in here yesterday about program state, and there's been a lot of cricket chirping since
06:43:18 <luqui> jrh, yes
06:43:41 <Zao> jrh: It hit the list, no replies.
06:43:51 <jrh> oh good.  Sometimes I'm not sure which email address I have subscribed to the list with
06:43:58 <jrh> thanks libqui, Zao
06:44:27 <luqui> jrh, "warnock's dilemma"
06:44:59 <luqui> jrh, as for your question, it's a hard one.
06:45:00 <Axman6> > join ((==) . reverse) . map toUpper $ "able was i ere i saw elba"
06:45:03 <lambdabot>  True
06:45:07 <Axman6> huzzah
06:45:15 <Axman6> i've never actually tested that one...
06:45:25 <luqui> jrh, FRP is one answer
06:45:42 <luqui> dealing with callbacks kind of forces your into an imperative setting
06:45:59 <jrh> Yeah, I realize that...  I wasn't thinking everyone thought I was an idiot;  I've had email bounce from the list before without noticing for days, because bounces tend to make it inot the spam queue
06:46:33 <luqui> jrh, seriously, http://en.wikipedia.org/wiki/Warnock's_Dilemma
06:46:35 <lambdabot> Title: Warnock's Dilemma - Wikipedia, the free encyclopedia
06:46:35 <jrh> Hrm @ libqui.  I thought about that -- actually been exploring it a little as of last night, but I haven't gotten very far.
06:46:44 * ddarius hasn't looked at it yet.
06:46:56 <jrh> heh...  got it
06:47:21 <luqui> jrh, FRP is very beautiful, but mature implementations are somewhat lacking
06:48:41 <jrh> I've noticed that...  I seem to recall someone writing a UI toolkit using FRP awhile back.
06:48:43 <luqui> jrh, but there are probably little things you can do to clean it up
06:49:43 <luqui> jrh, eg. abstract away things you can do when something happens and store them in a list
06:50:01 <luqui> or... it's hard to say only seeing the skeleton of your code
06:50:48 <luqui> if you give me more code, I'll hack it down to pretty a bit. :-)
06:50:54 <luqui> (it's one of my favorite things to do)
06:51:16 <jrh> Alright, libqui.
06:51:18 <luqui> Axman6, you just accidentally used the Reader monad!
06:51:36 <Axman6> wut? :O
06:53:55 <jrh> libqui, http://bluheron.europa.renci.org/GoTermViz-1.0.tar.gz
06:54:14 <Axman6> also, what was the syntax for a case statement again?
06:54:17 <jrh> That's a hacked up job of a previous visualization, so pardon the lack of commentary
06:54:36 <jrh> ProgramState, EventHandler, and GoTermMain.hs are where the ugly code is
06:56:18 <luqui> Axman6, case blah of { pattern1 -> ... ; pattern2 -> ... }
06:56:28 <Axman6> yeah, found it :)
06:56:32 <luqui> the braces and semicolons can be done away with using indentation
06:56:33 <luqui> okay
06:58:57 <byorgey_> > liftM2 (==) id reverse $ map toUpper "able was i ere i saw elba"
06:58:58 <lambdabot>  True
07:02:29 <luqui> jrh, oh I see what you're talking about!  GoTermMain.hs lines 181-203?
07:02:34 <Toxaris> Haskell palindrome checkers should be lazier imho
07:02:50 <jrh> yes
07:02:55 <jrh> libqui, yes
07:03:31 <jrh> then state becomes an IORef which is passed to the render callback and to the mouse motion callback
07:03:43 <jrh> as the first arg, curried away into the computation as state
07:03:50 <jrh> it works, but I think it's ugly
07:04:22 * luqui agrees... :-/
07:04:42 <jrh> problem is I can't use the ST monad or anything like that, because I don't want a tabula rasa between runST computations, and I have to end with an IO monad everywhere for OpenGL to be satisfied
07:05:37 <luqui> and you can't even do StateT because OpenGL is so stubborn about its half-abstraction
07:05:37 <Axman6> anyone heard of ANUplot?
07:05:40 <luqui> (my biggest complaint)
07:05:55 <jrh> right
07:06:24 <jrh> there's a reason for that, though, libqui, which is that OpenGL needs to work in practice like the spec says it should -- which is that computations are immediate
07:06:45 <jrh> OpenGL is very much immediate mode programming, which is anaethema to the Haskeller's mind
07:07:16 <jrh> for all it's breaking the usual rules, I rather like HOpenGL
07:07:52 <luqui> jrh, no, I just mean that hopengl would have been a lot nicer if they hadn't done stuff like renderPrimitive, and instead exposed glBegin and glEnd
07:07:53 * Axman6 thinks jrh might like to look ay ANUplot
07:08:01 <luqui> because then it would have been compatible with transformers
07:08:07 <Axman6> though, i'm not sure what you're trying to achieve
07:09:13 <jrh> Axman, I need something more generic than that, I'm afraid, but thanks.  For one thing, I actually want OpenGL exposed, as it's what most of my colleagues are most comfortable with
07:09:31 <Axman6> ok
07:09:38 <Philippa> *nod*. There's a definite need for that whatever else there is on top of it
07:09:39 <jrh> ahhh, I see what you mean, libqui
07:10:07 <Philippa> jrh: re the ST monad, does stToIo help?
07:10:22 <jrh> @where stTolo
07:10:22 <lambdabot> I know nothing about sttolo.
07:10:36 <Twey> @src String (==)
07:10:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:10:40 <Philippa> sorry, stToIO
07:10:43 <Twey> Hmph
07:10:49 <Philippa> it's in Control.Monad.ST
07:10:58 <Philippa> you get s=RealWorld
07:10:59 <luqui> jrh, yeah, you have a tough problem here, especially if you want to expose OpenGL
07:11:01 <Twey> Is == on strings always O(n) or is that just worst-case?
07:11:05 <luqui> in its comfortable form
07:11:22 <Twey> I.E. does it stop if it finds a character that doesn't match?
07:11:47 <Philippa> worst-case
07:11:53 * Twey nods.
07:11:54 <Twey> Thanks
07:12:09 <jrh> Philippa, the problem with that is that I don't need to build and destroy state within the state computation -- I'm effectively carrying a continuation throughout the entire program
07:12:36 <jrh> FRP would be great for this, if it were more mature, and maybe that's the path I should work down if I'm interested in making whatever I do a longer project
07:13:37 <jrh> luqui, if glBegin and End were the only places that HOpenGL half-abstracted things, that would be something, as Gtk's OpenGL extension includes glBegin and glEnd
07:13:56 <luqui> jrh, yeah but it's all over the place :-(
07:14:02 <jrh> yep.
07:14:09 <jrh> well, glad to know I have a hard problem to play with
07:14:13 <jrh> makes my day better :)
07:14:26 <luqui> jrh, meanwhile, you might like functional references to slightly lessen the inconvenience of using a big state structure like that
07:14:38 <jrh> library?
07:15:21 <luqui> there are a couple around. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor is mine
07:15:22 <lambdabot> Title: HackageDB: data-accessor-0.0.1, http://tinyurl.com/58srnn
07:15:27 <luqui> (minimal, but works :-)
07:15:51 <jrh> I always prefer minimal
07:15:55 <Axman6> @src (>)
07:15:55 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
07:15:58 <jrh> That's why I'm in Haskell :)
07:16:16 <Axman6> @src compare
07:16:16 <lambdabot> compare x y | x == y    = EQ
07:16:16 <lambdabot>             | x <= y    = LT
07:16:16 <lambdabot>             | otherwise = GT
07:16:27 <Axman6> @src (<=)
07:16:27 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
07:16:35 <Axman6> @src (==)
07:16:35 <lambdabot> x == y = not (x /= y)
07:16:40 <Axman6> @src (/=)
07:16:41 <lambdabot> x /= y = not (x == y)
07:16:49 <Axman6> oh god >_<
07:16:50 <luqui> and looking at it again, I remember that I completely failed to document the important parts
07:16:55 <trofimovich> @type ==
07:16:58 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
07:17:00 <luqui> like what the TH routines are looking for...
07:17:02 <jrh> don't we all?
07:17:12 <trofimovich> @type (==)
07:17:13 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:17:45 <luqui> ah no I did nevermind ;-)
07:18:14 <Axman6> how does that work anyway? how can == and /= be defined using each other?
07:18:44 <luqui> Axman6, one of them has to be overridden by the Eq instance
07:18:50 <luqui> (of whatever type you're comparing)
07:18:56 <Axman6> hmm, ok
07:19:11 <jrh> nice.  that's more or less what I was thinking to do, partially.
07:19:12 <luqui> and if you don't, then you get inexplicable infinite loops.  the situation could be better ;-)
07:19:17 <jrh> Thanks, libqui
07:19:25 <Axman6> indeed :)
07:20:09 <luqui> jrh, you're welcome, glad to have my module used :-)
07:23:30 <Deewiant> luqui: well, you get a warning if you just do "instance Eq Mytype"
07:24:02 <Deewiant> and that looks a bit suspicious anyway, so I doubt people actually get infinite loops due to Eq often ;-)
07:33:49 <lispy> I've never had infinite loops from Eq instaces
07:36:24 <byorgey> I've gotten an infinite loop from an Ord instance.
07:38:22 <Pete_I> does haskell(ghc) have multiline comments?
07:38:35 <jeffwheeler> Pete_I: {- content -}
07:38:37 <vixey> {- yes -}
07:38:43 <Pete_I> thank you :)
07:38:47 <jeffwheeler> I wonder . . .
07:38:50 <jeffwheeler> > {- test -}
07:38:50 <lambdabot>   parse error on input `}'
07:38:53 <jeffwheeler> :(
07:39:01 <jrh> sadly, lambdabot is not amused
07:39:04 <vixey> > {- test -} 3
07:39:05 <lambdabot>  3
07:39:07 <jrh> > -- test
07:39:09 <lambdabot>   parse error on input `}'
07:39:19 <jeffwheeler> Err, what?
07:39:27 <jeffwheeler> > 3 -- test
07:39:28 <lambdabot>  3
07:39:39 <vixey> >
07:39:40 <jeffwheeler> I guess internally -- is transformed into {- -}?
07:39:43 <jrh> 3--;
07:39:48 <jrh> > 3-- ;
07:39:49 <lambdabot>  3
07:40:06 <luqui> no, it's an artifact of how lambdabot evaluates expressions
07:40:09 <jrh> above is how to confuse a C++ programmer
07:40:33 <jeffwheeler> A C++ programmer without Haskell syntax highlighting. ;)
07:40:48 <waern> did anyone do anything for haskell on the iphone? I remember people discussing it on -cafe
07:40:48 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
07:41:07 <jeffwheeler> waern: there was a thread about it on hoc-users I found a while back
07:41:25 <jeffwheeler> It only had about three posts without anything very useful, though, iirc
07:42:19 <waern> dcoutts_: thanks for the congrats ;)
07:42:25 <dcoutts_> :-)
07:42:36 <dcoutts_> waern: did you have any cabal-install patches for me btw?
07:44:48 <waern> dcoutts_: yeah, I'll send something when I'm home tonight
07:45:03 <waern> I did the least fancy thing
07:45:18 <waern> but I think I'll definitely improve it in the future
07:46:42 <byorgey> waern: for what are you to be congratulated?
07:46:55 <vixey> hello
07:47:07 <waern> jeffwheeler: thanks
07:47:18 <jeffwheeler> waern: what?
07:47:29 <byorgey> hi vixey
07:47:32 <waern> jeffwheeler: for the info
07:47:40 <waern> :)
07:48:10 <waern> byorgey: dcoutts sent a lambdabot message just after the haddock 2.2.1 release
07:48:39 <byorgey> ah, I see =)
07:48:55 <Axman6> ok, not sure what's up here:
07:48:56 <Axman6> *Main| :}
07:48:56 <Axman6> unknown command ':}'
07:48:56 <Axman6> use :? for help.
07:49:01 <Axman6> in ghci
07:49:20 <vixey> Axman6: ':}' is not a known comman
07:49:30 <Axman6> sure it is
07:49:34 <vixey> no it's not
07:49:35 <Axman6> :? tells me it is
07:49:59 <Axman6>    :{\n ..lines.. \n:}\n       multiline command
07:50:10 <Axman6> and it's been working
07:50:14 <dcoutts_> waern: I might have some patches for you
07:50:48 <byorgey> Axman6: well, don't you have to start with :{ ?
07:50:51 <jeffwheeler> Axman6: I have no idea why it says that, but it should be {- -}
07:50:53 <Axman6> i did
07:50:59 <darx> Whats a constructor in haskell?
07:51:02 <Axman6> that's why there's a Main| there
07:51:02 <jeffwheeler> Axman6: Prelude> {- test -} 3
07:51:13 <Cale> Axman6: perhaps you've forgotten to close some other syntax? (Just a guess)
07:51:14 <byorgey> jeffwheeler: no, in ghci you can use :{ and :} to enter multi-line expressions
07:51:22 <vixey> darx: A function that can make a bit of data
07:51:24 <Cale> darx: It's a function which can be pattern matched against
07:51:25 <byorgey> well, recent versions of ghci at least
07:51:29 <Axman6> Cale: yeah, thought it might be that
07:51:42 <jeffwheeler> byorgey: Oh, I misread it as {: :} and didn't notice it wasn't comments --- my bad
07:52:07 <byorgey> jeffwheeler: no problem =)
07:52:23 <darx> Cale, vixey: i think i got the pattern matching part, but whats does make bits of data mean?
07:53:04 <Cale> darx: Well, it might be easiest to go by example...
07:53:32 <vixey> darx: Data is a pattern match pulls apart
07:53:33 <Cale> data Employee = Boss String Integer | Peon String
07:53:49 <Cale> Here's a datatype, it has two data constructors Boss and Peon
07:54:00 <Cale> Boss takes a String and an Integer, and makes an Employee
07:54:14 <Cale> Peon just takes a String, and makes an Employee
07:54:17 <vixey> is what a *
07:54:36 <Cale> For example,  (Boss "The Guy" 100000) is a value of type Employee
07:54:57 <darx> cool
07:54:58 <Cale> as is (Peon "James Rabble")
07:55:21 <Cale> and functions can pattern match:
07:55:30 <luqui> byorgey, you are my hero!
07:55:58 <Cale> raise n (Boss name pay) = Boss name (pay + n)
07:55:59 <byorgey> luqui: well gee, thanks!  why's that?
07:56:13 <Cale> raise n (Peon name) = Peon name
07:56:24 <Cale> (no raises for them!)
07:56:37 <luqui> byorgey, I guess it wasn't you who initiated the conversation, but I saw your utterance about :{ and :}
07:56:39 <jeffwheeler> No pay for them!
07:56:47 <Cale> :)
07:56:50 <byorgey> luqui: oh, hehe, yeah =)
07:56:58 <byorgey> a lot of people seem not to know about that
07:57:10 <darx> Cale: Thanks..
07:58:16 <Cale> darx: In addition to data constructors, there are also type constructors. Here, Employee can be thought of as a (nullary) type constructor. A better example is with something like the datatype:
07:58:23 <Cale> data Maybe a = Nothing | Just a
07:58:50 <Cale> For any type 'a', the type Maybe a consists of the values Nothing, and Just x, where x is of type a
07:59:05 <Cale> For instance,  Just 5 :: Maybe Integer
07:59:21 <darx> You mean like a recursive definition?
07:59:29 <Cale> Maybe is a type constructor -- it constructs a type from another type
07:59:32 <luqui> hmm, :{ and :} don't seem to work as well as I'd like
07:59:33 <vixey> this is not recursive
07:59:44 <Cale> No recursion yet, though we can have that :)
07:59:54 <darx> cool
08:00:00 <luqui> doesn't respect iindentation or something
08:00:02 <vixey> data Term
08:00:03 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
08:00:12 <vixey> aww
08:00:55 <Cale> "A tree of values of type a is either a Leaf, or a Branch with a value of type a, and two subtrees of values of type a"
08:01:03 <darx> I think I should lurk around here more!!
08:01:10 <darx> :-D
08:01:16 <Cale> Yeah, and don't be afraid to ask questions :)
08:01:28 <darx> Oh I will..
08:01:34 <vixey> data Term = Constructor Name [Term] | Lambda (Term -> Term) | Term :$: Term -- is a cool one
08:02:18 <byorgey> lurking in #haskell is highly encouraged =)
08:02:25 <Japsu> lurking <3
08:02:53 <darx> :)
08:04:02 <jeffwheeler> I wonder if he realizes he has that quit message . . .
08:08:37 <mnislaih> question: does any of the URI parsers out there parse the params in the query segment of the URI ?
08:08:44 <osfameron> lambdacamels: is this proof-of-concept toy ( http://search.cpan.org/~osfameron/Acme-Fork-Lazy-0.01/lib/Acme/Fork/Lazy.pm ) similar to how Haskell's forking works?
08:08:46 <lambdabot> http://tinyurl.com/5qpp72
08:09:07 <Toxaris> I wonder why tools try to punish their users for using them?
08:10:03 <jeffwheeler> Toxaris: You're using Emacs, aren't you? ;)
08:10:20 <Toxaris> jeffwheeler: not at all
08:10:22 <jrh> Toxaris, read The Design of Everyday Things sometime
08:10:32 <jeffwheeler> Toxaris: what tools, then?
08:10:45 <Toxaris> jrh: standing right on my desk
08:10:50 <jrh> oh good
08:11:06 <Toxaris> jrh: but that's no reason not to read it again :)
08:11:33 <Toxaris> jeffwheeler: I was talking about UberScript, and your comment about benpicco
08:12:02 <jrh> Toxaris: Then go ahead and read Edward Tufte's books next, if you haven't
08:12:04 <jeffwheeler> Toxaris: ah, yeah; I've never seen uberscript before, but that tool does seem silly
08:12:21 <BeelsebobWork> is code.haskell.org/bytestring or darcs.haskell.org/packages/bytestring the right repo?
08:12:25 * jeffwheeler has The Visual Display of Quantitative Information, v. 2 on my desk
08:12:28 <Toxaris> jeffwheeler: but the general idea of "my user is dumb" default quit messages is the same for many irc clients / script suites / whatever
08:12:38 <jeffwheeler> Toxaris: ha, yes
08:13:17 * Toxaris considers changing his quite message (however that works; whatever it is now) to "I didn't jump through holes to place a dumb joke in my quit message"
08:13:31 <Toxaris> s/quite/quit
08:19:45 <Toxaris> jrh: will consider it. I have actually never heard of him before.
08:21:03 <Cale> Tufte is the guy when it comes to visual presentation of data :)
08:22:22 <b\6> yeah, he's tufte beat.
08:23:39 <Toxaris> is there a guy for textual presentation of data?
08:23:44 <Toxaris> e.g. programming languages
08:25:16 <jrh> Toxaris, few people agree on the principles that make for good programming languages.  I don't know that one person stands out from another in this field.
08:25:45 <jrh> Well... there are people that stand out, but not one overarching name I can think of
08:25:48 <Lycurgus> my money on don knuth
08:26:07 <jrh> knuth says very little about programming languages, though -- much more about algorithms
08:26:18 <Toxaris> isn't literate programming from knuth?
08:26:26 <jrh> yes
08:26:30 <Lycurgus> "for textual presentation of data"
08:26:32 <baaba> literate programming isn't language-dependent though
08:26:52 <Lycurgus> "e.g. programming languages"
08:27:06 <jeffwheeler> That "e.g." is important; it's not "i.e."
08:27:16 <Toxaris> sic!
08:27:18 <Asgaroth> If a have a constant application form which returns an infinite list and I use take 20 foo in one place in my code and take 10 foo after that, will the second call reuse the results from the first one automatically?
08:28:06 <Deewiant> if it's the same foo (i.e. from a global/let/where binding) it should, probably not otherwise though
08:28:34 <Asgaroth> Deewiant: Ok, thanks.
08:28:37 <lilachaz1> Asgaroth: (if i've understood correctly), the haskell standard does not specify, but reasonable implementations will reuse the results of the first calculation
08:28:47 <Toxaris> Asgaroth: if you access the CAF by the same binding, and it is truly constant (i.e. no hidden parameters due to bounded polymorphism), then afaik yes
08:29:36 <Asgaroth> Ok, thank you. I assume the same also applies when using takeWhile/dropWhile, right?
08:30:00 <Toxaris> Asgaroth: sure, it's independent of what you do with the value
08:30:20 <Toxaris> Asgaroth: but the predicate has to be reevulated of course
08:30:47 <Toxaris> Asgaroth: there is no magic going on, just caching of information *which you bound to a name*
08:30:54 <lilac> Asgaroth: the value of foo will be remembered until the garbage collector detects it's not needed, so subsequent operations will reuse it
08:31:14 <Asgaroth> I see, thanks.
08:32:09 <Toxaris> I'm not sure how I see literate programming. I'm tempted to consider it a work-around to make up for unreadable code.
08:33:14 <Asgaroth> Just standard comments for the trickier parts, should be enough in my opinion.
08:33:26 <luqui> > let show' (In xs) = "[" ++ intercalate "," (map show' xs) ++ "]" in show' $ fix (In . (:[]))
08:33:27 <lambdabot>  "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
08:34:42 <vixey> hmmm
08:34:45 <vixey> > In 3
08:34:46 <lambdabot>   add an instance declaration for (Num (f (Mu f)))
08:34:50 <vixey> :t In
08:34:51 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
08:34:53 <vixey> @src Mu
08:34:53 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
08:35:17 <vixey> :t In . (:[])
08:35:17 <lambdabot> Mu [] -> Mu []
08:35:50 <vixey> :t let show' (In xs) = "[" ++ intercalate "," (map show' xs) ++ "]" in show
08:35:51 <lambdabot> forall a. (Show a) => a -> String
08:35:53 <vixey> :t let show' (In xs) = "[" ++ intercalate "," (map show' xs) ++ "]" in show'
08:35:53 <lambdabot> Mu [] -> [Char]
08:37:07 <Deewiant> > repeat '[' -- don't overcomplicate things
08:37:08 <lambdabot>  "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
08:37:46 <luqui> Deewiant, your string differs from mine at position omega
08:38:19 <Deewiant> luqui: can you get \bot to find a difference by just comparing the outputs? :-)
08:38:23 <luqui> actually I haven't the slightest clue what's at position omega in mine
08:39:11 <Toxaris> luqui: so you consider repeat '[' and repeat '[' ++ "]" to be different?
08:39:13 <luqui> Deewiant, is lambdabot an oracle machine?  Because if she was.... wowee
08:39:17 <Deewiant> > let show' (In xs) = "[" ++ intercalate "," (map show' xs) ++ "]" in show' $ (In [In []])
08:39:18 <lambdabot>  "[[]]"
08:39:36 <luqui> Toxaris, jokingly yes.  I'm somewhat interested in theories in which they are.
08:40:03 <Deewiant> luqui: yours is something like concat (repeat (repeat '[')) ++ concat (repeat (repeat ']'))... maybe
08:40:26 <CosmicRay> so a test case for hdbc is crashing under hugs, on arm only.
08:40:29 <Deewiant> or more like infinite nesting
08:40:32 <CosmicRay> how do I go about tracking that down?
08:40:35 <CosmicRay> (hugs is segfaulting)
08:40:56 <luqui> yeah, but it's infinite unary nesting.  still just aleph 0.  I can do better.
08:40:59 <vixey> :k Mu
08:41:00 <lambdabot> (* -> *) -> *
08:41:07 <luqui> > let show' (In xs) = "[" ++ intercalate "," (map show' xs) ++ "]" in show' $ fix (In . repeat)
08:41:09 <lambdabot>  "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
08:41:15 <vixey> :k Mu ((->) ())
08:41:16 <lambdabot> *
08:41:16 <luqui> there, that's 2^aleph 0
08:41:25 <Toxaris> > fix (("[" ++) . (++ "]"))
08:41:29 <lambdabot>  "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
08:41:38 <Baughn> > let x = [x] in x -- Sadly..
08:41:39 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
08:41:39 <lambdabot>       Expected...
08:41:52 <jeffwheeler> > last $ (repeat '[') ++ [']']
08:41:54 <jeffwheeler> :(
08:41:56 <vixey> :t > let x = In [x] in x
08:41:59 <lambdabot> Terminated
08:42:00 <vixey> :t let x = In [x] in x
08:42:00 <lambdabot> Mu []
08:42:12 <Baughn> :t In
08:42:13 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
08:42:16 <vixey> @src Mu
08:42:17 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
08:42:28 <vixey> :t let x = In (\e -> x) in x
08:42:29 <lambdabot> forall t. Mu ((->) t)
08:42:45 <vixey> :t let x = In (\e -> 1 : x) in x
08:43:00 <Baughn> :t In 2
08:43:01 <lambdabot> forall (f :: * -> *). (Num (f (Mu f))) => Mu f
08:43:07 <Baughn> > In 2
08:43:08 <lambdabot>   add an instance declaration for (Num (f (Mu f)))
08:43:19 <Baughn> > out $ In 2
08:43:19 <lambdabot>   add an instance declaration for (Num (f (Mu f)))
08:43:30 <luqui> the cool thing is that Num (Mu Maybe) is a reasonable instance...
08:43:50 <Baughn> Okay, what is this Mu thing?
08:44:03 <luqui> Baughn, fix on types
08:44:39 <vixey> Baughn: Mu
08:45:02 * luqui wishes he remembered the paper where he first read about it
08:45:33 <vixey> Baughn,
08:45:34 <vixey> :k Mu
08:45:35 <lambdabot> (* -> *) -> *
08:45:38 <vixey> :k Mu Just
08:45:43 <luqui> ehem
08:45:45 <luqui> :k Mu Maybe
08:45:46 <lambdabot> *
08:45:58 <vixey> :t fix (\x -> In (Just x))
08:45:59 <lambdabot> Mu Maybe
08:46:09 <Baughn> :t In (Just 2)
08:46:13 <vixey> ....
08:46:22 <vixey> 2 is not of type Mu Maybe
08:46:32 <luqui> :t In
08:46:33 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
08:46:35 <Baughn> No, I imagine not. I wanted to see the error
08:46:46 <vixey> lambdabot has given up displaying errors
08:47:00 <luqui> use ?type to get errors.  lambdabot just assumes that you didn't want the type or kind of something if it isn't valid
08:47:07 <luqui> (or ?kind resp.)
08:47:12 <Deewiant> ?type doesn't work either
08:47:12 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:47:15 <Deewiant> as you can see
08:47:28 <luqui> ?type In (Just 2)
08:47:29 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:47:31 <luqui> ohhhh
08:47:39 <Deewiant> it broke this week, I think
08:47:51 <jeffwheeler> Demanding the type signature sure makes its job /so/ much easier, though.
08:48:14 * sebaseba can't see the bottom of it: when he finally understands fix, some people come talking about fix on types and other alien stuff
08:48:42 <jeffwheeler> Same goes for monads: as you soon as you think you understand, here comes arrows
08:48:47 <lilac> :t In (Just Nothing)
08:48:48 <luqui> seanmce, it's the full employment theorem for computer science
08:49:24 <Deewiant> jeffwheeler: what's after arrows, then :-)
08:49:29 <lilac> So "Mu Maybe" is isomorphic to the naturals?
08:49:33 <sebaseba> Targets
08:49:37 <jeffwheeler> Deewiant: Not sure yet, I haven't read that far ahead. ;)
08:50:01 <luqui> jeffwheeler, eh, arrows are easy.
08:50:12 <jeffwheeler> I'm still playing with monads though.
08:50:17 <Cale> It's the arrow syntax which is hard :)
08:50:23 <vixey> lilac: yes!
08:50:31 <Cale> (well, understanding the translation)
08:50:40 <lilac> vixey: cool :)
08:50:42 <jeffwheeler> That tutorial that replicated some Monads (Maybe, List) into Python was one of the best I've seen, for me.
08:50:46 <vixey> lilac: And (Mu (Either Integer)) is [Integer]
08:50:53 <vixey> or is it ...
08:50:57 <vixey> no it's not
08:51:04 <Cale> Personally, I just trust the translation to do something sane, and the fact that the arrow laws hold means I don't have to care what it translates things into :)
09:00:43 <chrisdone> what what what bring back the bot
09:02:53 --- mode: irc.freenode.net set +o ChanServ
09:03:11 <lilac> yow
09:03:17 <Baughn> Urk. "Join flood detected, ignoring.. <huge list of nicks>"
09:03:21 <Baughn> More "join flood". irssi.. why?
09:03:21 <EvilTerran> i could use something which does that
09:03:26 <EvilTerran> Baughn, i think the net is un-splitting
09:03:27 <Deewiant> Baughn: wow, you get that? I just get hundreds of joins :-P
09:03:29 <lilac> as i understand it, the derivative of a type is essentially the state of a process navigating the type
09:03:33 <Deewiant> Baughn: one per line, of course
09:03:38 <lilac> Deewiant: likewise ;-(
09:03:42 <Baughn> Deewiant: Oh, I got the hundreds of joins too
09:03:48 <Baughn> Deewiant: It's just that now I've got hundreds of ignores
09:04:02 <EvilTerran> Deewiant, yeah, me too. i've been meaning to see if i can write an xchat extension to prevent it
09:04:05 <lilac> are we done?
09:04:09 <Deewiant> Baughn: ah, great
09:04:11 <Deewiant> lilac: almost, I'd say
09:04:15 <EvilTerran> i'll probably end up writing haskell bindings for xchat first :P
09:04:18 <Deewiant> @users
09:04:18 <lambdabot> Maximum users seen in #haskell: 477, currently: 459 (96.2%), active: 6 (1.3%)
09:04:18 <jeffwheeler> It seems everybody's back.
09:04:53 <jeffwheeler> When was lambdabot last restarted? We reached 507 about a week ago.
09:05:04 <BeelsebobWork> hmm, am I the only one for whom the bytestring package on hackage doesn't build for
09:05:19 <_zenon_> My god!
09:05:25 <Baughn> BeelsebobWork: Possibly. What's your ghc version?
09:05:44 <BeelsebobWork> 6.9.20080615 -- on OS X it built
09:05:52 <BeelsebobWork> on linux it fails, with GHC.Prim not existing
09:06:11 <chrisdone> you guys all need to get more reliable servars rofl
09:06:28 <Baughn> chrisdone: Freenode's not ours..
09:06:32 <BeelsebobWork> chrisdone: uh, it's freenode -- not #haskell
09:06:36 <BeelsebobWork> oh, Baughn beat me
09:06:38 <Cale> chrisdone: MOAR NINEZ
09:06:43 <Baughn> I agree about the servers, though. Hackage's somewhat.. slow, at times
09:06:50 <jeffwheeler> Looks like they were all on Kubrick.
09:07:00 <lilac> chrisdone: lolz teh servars r sux
09:09:07 <BeelsebobWork> hmm, just needs a slight modification to the cabal file
09:14:23 <Pete_I> what's the difference between "expected type" and "inferred type"?
09:14:56 <SL_> inferred is the actual type. expected is what type is expected from context
09:15:01 <jeffwheeler> Expected type is what the context would suggest the type should be, and the inferred type is what the type actually is.
09:15:12 <jeffwheeler> Or SL_ can beat me. ;)
09:15:30 <chrisdone> can I beat you?
09:15:38 <jeffwheeler> You didn't. :P
09:15:42 <Baughn> It uses the context to infer what it should be, though..
09:15:59 <jeffwheeler> Baughn: then you should be great at avoiding type errors
09:16:02 <SL_> jeffwheeler, well, your explanation is a bit better :)
09:16:09 <EvilTerran> the expected type is what the type must be based on stuff external to the term
09:16:21 <Baughn> I always thought of it as expected type being the type it's inferred from wrapping expressions, and inferred being what it expects based on what is wrapped
09:16:22 <EvilTerran> the inferred type is what the type must be based on stuff internal to the term
09:16:38 <EvilTerran> EXpected/EXternal; INferred/INternal
09:16:40 <vixey> I never know
09:16:43 <EvilTerran> that's my mnemonic, anyway :)
09:16:48 <vixey> I just thought, "There is a problem in this area"
09:16:54 <vixey> and then stare at the code and think for a bit
09:17:08 <chrisdone> more efficient than udnerstanding the words
09:17:24 <EvilTerran> understanding what exactly type errors mean can save a lot of time
09:17:35 <EvilTerran> you can see which of the types isn't what you'd expect for that expression
09:17:37 <lilac> as far as i'm concerned, they're just two types which haskell has decided the same expression should be :)
09:17:48 <lilac> and at least one of them is wrong
09:17:50 <EvilTerran> and then do type inference backwards in your head to see where you've gone wrong
09:19:14 <Pete_I> well...i don't really know the language. it's all an exercise in debugging, so knowing what the messages mean would help there
09:19:36 <vixey> I don't think there's much value in error messages, other than location
09:20:27 <chrisdone> vixey: I think the same for exceptions
09:20:35 <chrisdone> backtraces I haven't had a use for in haskell
09:20:40 <chrisdone> line numbers, however..
09:21:05 <chrisdone> or a function name of which the line number is easy to find
09:21:14 <jeffwheeler> The hardest thing about learning Haskell for absolute beginners, I suspect, is the inability to randomly stick print statements in functions.
09:21:22 <vixey> hehe
09:21:33 <jeffwheeler> A really easy dbg would help that, although ghc does make it pretty dang easy to add breakpoints.
09:21:39 <Baughn> jeffwheeler: Eh? I do that all the time. ^_^
09:21:43 <jeffwheeler> I think that should be emphasized in absolute beginner tutorials.
09:21:54 <jeffwheeler> Baughn: In /pure/ functions
09:21:55 * vixey ~never~ uses Debug.Trace ... :p
09:22:03 <Pete_I> i haven't ever used breakpoints
09:22:10 <Baughn> jeffwheeler: Debug.Trace
09:22:23 <jeffwheeler> Baughn: I haven't ever used that; I'll google it
09:22:30 <ziman> vixey, what do you use instead? :)
09:22:39 <chrisdone> I used Debug.Trace once when I started on Haskell and then it soon became useless
09:22:43 <chrisdone> I've observed the same for others
09:22:46 <geezusfreeek> i've only ever used the debugger once, and that was after i didn't consider myself a newb anymore
09:23:04 <chrisdone> it's probably an artifact of imperative languages with ``printf'' debugging
09:24:03 <chrisdone> hey emma
09:24:11 <chrisdone> emma: moved on from scheme? ;)
09:24:45 <vixey> Why eager execution is a better default than lazy execution - http://www.codepoetics.com/wiki/index.php?title=Topics:Eager_Versus_Lazy_Evaluation
09:24:47 <lambdabot> Title: Topics:Eager Versus Lazy Evaluation - CTMWiki, http://tinyurl.com/6rjmlr
09:25:55 <Baughn> chrisdone: I've used debug.trace specifically to count dethunks
09:26:06 <emma> chrisdone: Not quite but I just cannot keep myself from at least hanging out with haskell people because everyone says it is so cool.
09:26:07 <Baughn> Making sure my lazy data structures had the amortized behaviour I wanted them to have
09:26:17 <chrisdone> emma: ahh :)
09:26:22 <emma> I'm going to try to actually learn Scheme before I dive very much into another language though :)
09:26:36 <chrisdone> Baughn: fair enough
09:27:08 <vixey> emma, you have wanted to start learning scheme for quite a long time ..
09:27:10 <chrisdone> emma: oh ok
09:27:27 <vixey> have you not thought of a program to write yet?
09:27:28 <emma> vixey: I know. I think maybe today will be the day.
09:27:36 <chrisdone> haha
09:27:43 <emma> vixey: Well that is probably a bit of an issue.
09:28:16 <emma> Some times I seem to be more enamoured at the idea of knowing things than I am of the hard part of learning them. :)
09:28:29 <emma> But I really think that today might be the day I start really learning Scheme.
09:29:49 <smtms> emma, you know about the "write a scheme interpreter in Haskell in 48 hours"?
09:29:50 <chrisdone> if scheme's channel had the same dynamic as #haskell you would learn it in an hour and put sussman to shame
09:29:57 <trofimovich> :]
09:30:49 <geezusfreeek> we would also say they are big on themselves :P
09:31:18 <chrisdone> I don't want to know what being big on oneself means
09:31:22 <Elly> that tutorial is actually really good
09:31:36 <Elly> (the write-yourself-a-scheme-interpreter one)
09:31:46 <Elly> chrisdone: having a big ego I think
09:31:50 <vixey> Elly I think it should be a haskell interpreter
09:31:53 <geezusfreeek> chrisdone: get out of the gutter
09:32:14 <Elly> vixey: probably more difficult to parse than scheme though
09:32:22 <gbacon> I'm getting "combination not supported: Threaded/Profiling" from a cabal build
09:32:24 <chrisdone> geezusfreeek: I have no idea what you're talking about
09:32:25 <vixey> Elly, ok not haskell but a little lazy fp language
09:32:35 <gbacon> but the cabal file makes no mention of threading
09:32:49 <dcoutts_> gbacon: no ghc-options: -threaded ?
09:32:54 <Pete_I> let n = 4; take n [1..]; "Couldn't match expected type `Int' against inferred type `Integer'" the hell?
09:32:54 <vixey> Elly, although there is pattern matching and typing to implement, so I don't know if that makes it a bit too complex
09:33:02 <gbacon> where is it making this inference, and is there an easy way to disable threading for a profiling build?
09:33:07 <Pete_I> why is Int != Integer?
09:33:13 <vixey> > let n = 4 in take n [1..]
09:33:15 <lambdabot>  [1,2,3,4]
09:33:18 <_zenon_> Pete_I, Integer has more space
09:33:23 <chrisdone> Pete_I: int is fixed size
09:33:25 <dcoutts_> Pete_I: Int fits in a register
09:33:26 <vixey> > let n = 4 :: Int in take n [1 :: Integer ..]
09:33:27 <lambdabot>  [1,2,3,4]
09:33:27 <Toxaris> Pete_I: because they are different :)
09:33:33 <gbacon> dcoutts: no
09:33:35 <geezusfreeek> chrisdone: to be big on yourself is to think a bit too highly of yourself. to be in the gutter is to take everything the wrong way (as sounding sexual)
09:33:39 <chrisdone> Pete_I: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Int.html#t%3AInt
09:33:40 <lambdabot> Title: Data.Int, http://tinyurl.com/5tjd5j
09:33:44 <trofimovich> > upperBound :: Int
09:33:44 <lambdabot>   Not in scope: `upperBound'
09:33:52 <vixey> Elly, what do you think?
09:33:57 <chrisdone> geezusfreeek: can't you just talk real words?
09:34:15 <dcoutts_> gbacon: it's a message coming from ghc not cabal, so I'm not exactly sure
09:34:17 <Botje> > (minBound,maxBound) :: (Int,Int)
09:34:18 <lambdabot>  (-2147483648,2147483647)
09:34:20 <geezusfreeek> chrisdone: i thought they were fairly common figures of speech. are you native english?
09:34:22 <Elly> vixey: pattern matching is one of the things that makes haskell cool though
09:34:40 <Toxaris> I don't think pattern matching is that hard
09:34:44 <Elly> I have no idea
09:34:50 <trofimovich> > maxBound :: Integer
09:34:51 <lambdabot>   add an instance declaration for (Bounded Integer)
09:34:51 <lambdabot>     In the expression: ma...
09:34:52 <gbacon> dcoutts: right, but the ghc command line (generated by cabal) includes both -threaded and -prof
09:34:56 <vixey> Toxaris: I haven't seen any simple implementations
09:35:18 <dcoutts_> gbacon: that's why I asked about -threaded
09:35:29 <Toxaris> vixey: really? interesting.
09:35:39 <dcoutts_> gbacon: so the question is where that's coming from, Cabal doesn't just generate it on it's own
09:35:50 <gbacon> dcoutts: correct, that's my question :-)
09:36:09 <gbacon> dcoutts: the -prof comes from --enable-executable-profiling given to configure
09:36:11 <dcoutts_> gbacon: it either comes from the .cabal file or the command line
09:36:57 <dcoutts_> gbacon: there is no option to cabal that makes it generate the -threaded ghc flag. It can only occur because it's been specified as an input.
09:37:42 <chrisdone> can you use haskell to kill a process based on a pid? or should I launch ``kill'' and forget about cross platform, uh, ness?
09:37:58 <mrd> killing a process by pid is already non-cross-platform
09:38:04 <dcoutts_> chrisdone: try the System.Posix.Process
09:38:07 <mrd> did you check out the System stuff?
09:38:19 <chrisdone> yeah but I'm launching fastcgi which writes a pid to file
09:38:22 <chrisdone> does windows not have pids?
09:38:57 <dcoutts_> gbacon: it could be saved in the cabal config if it was previously specified as a configure flag.
09:39:19 <chrisdone> there goes windows
09:39:33 <gbacon> dcoutts_: I've run Setup clean; doesn't that eliminate that possibility?
09:39:46 <dcoutts_> gbacon: it does indeed
09:40:09 <jrh> dons: can I get a hackage account?  I've cabalized the FTGL package I wrote and I'd like to release it
09:40:25 <dcoutts_> jrh: the hackage web page says how to get one
09:40:36 <dcoutts_> jrh: dons is not the hackage gate keeper
09:40:45 <jrh> dcoutts_: which was send dons an email, which I did do several days ago.
09:41:02 <jrh> thought he might have missed it.  not trying to be rude
09:41:12 <dcoutts_> jrh: see http://hackage.haskell.org/packages/accounts.html
09:41:13 <lambdabot> Title: HackageDB: User accounts
09:41:28 <dcoutts_> jrh: where does it say to email dons?
09:41:59 <jrh> in my webcache...  said dons a few days ago, I'm sure of it.  Huh.
09:42:19 <gbacon> dcoutts_: dist/setup-config doesn't mention either option, but when I run Setup build -v, it's there
09:42:32 * jrh stares blankly at the new email address on hackage
09:42:35 <FordCortina> the only way to change the behaviour of a function based on the type of its argument in Haskell is to use a type class, right?
09:42:45 <dcoutts_> jrh: it's been that address since the beginning :-)
09:43:53 <jrh> dcoutts_: http://hackage.haskell.org/packages/accounts.html
09:43:53 <dcoutts_> gbacon: I'm stumped. Have you got some weird Cabal lib ? :-)
09:43:53 <lambdabot> Title: HackageDB: User accounts
09:43:54 <vixey> Ford: yes
09:44:13 <jrh> In firefox, that says dons@galois.com
09:44:19 <jrh> I just hit reload and everything
09:44:28 <gbacon> dcoutts_: ghc-pkg reports Cabal-1.2.3.0, Cabal-1.4.0.1
09:44:55 <dcoutts_> jrh: not for me it doesn't, when I hit reload
09:45:00 <dcoutts_> jrh: lemme check on the server
09:45:15 <FordCortina> vixey: ... and in a language like agda you dont really need type classes, because the behaviour of a function can depend on its argument
09:45:17 <gbacon> dcoutts_: does Cabal scan infer ghc flags from library dependencies?
09:45:23 <gbacon> s/scan //
09:45:24 <dcoutts_> gbacon: no
09:45:40 <jrh> alright.  cleared webcache and hit reload and now it says ross@soi....
09:45:44 <vixey> FordCortina: I'm pretty sure you can implement typeclass dispatch in Agda
09:45:48 <dcoutts_> gbacon: can you give me details on how to reproduce it?
09:45:54 <jrh> how... odd.
09:46:06 <dcoutts_> jrh: perhaps someone changed it temporarily, I dunno why though
09:46:37 <gbacon> dcoutts_: got a copy of pugs handy?
09:46:53 <FordCortina> vixey: i suppose the main advantage of type classes is that they are not closed, unlike the kind of mechanisms you get with dependent types
09:47:01 <dcoutts_> gbacon: not on this box sadly
09:47:05 <jrh> k.  I'll refrain from sending a screenshot of my firefox to prove I'm not crazy and just email Ross
09:47:14 <dcoutts_> gbacon: check the pugs.buildinfo
09:47:26 <dcoutts_> gbacon: that's another source of flags input
09:48:15 <gbacon> dcoutts_: that's it
09:48:26 <dcoutts_> gbacon: so how/why is it doing that?
09:48:34 <dcoutts_> gbacon: it should do that kind of stuff in the .cabal file
09:48:57 <dcoutts_> gbacon: I presume it's a configure script doing that right?
09:49:05 <chrisdone> @hoogle deleteFile
09:49:06 <lambdabot> No matches found
09:49:28 <dcoutts_> gbacon: they should generally only be used to discover platform-specific C linking options, not ghc-options and the like
09:49:53 <FordCortina> vixey: i asking because im deciding whether to do implement stuff with type classes or some funny runtime processing to emulate this behaviour in agda
09:50:02 <gbacon> dcoutts_: looks like Makefile.PL calls Configure.PL which writes Pugs.buildinfo
09:50:09 <FordCortina> s/do//
09:50:39 <FordCortina> the runtime processing would be to check the constuctor of some singleton type... if that makes sense
09:50:39 <dcoutts_> gbacon: and what's the condition on which it decides to use that flag or not?
09:50:41 <vixey> The only type level computations you can do in haskell is via typeclasses  (is this now false, given type families?)
09:50:50 <gbacon> dcoutts_: it's unconditional
09:50:57 <dcoutts_> gbacon: doh!
09:51:01 <gbacon> dcoutts_: :-)
09:51:03 <dcoutts_> gbacon: just put it in the .cabal file
09:51:13 <FordCortina> vixey: i believe you can do some with GADTs as well, and type families too
09:51:20 <dcoutts_> gbacon: even conditional stuff can usually go in the .cabal file
09:51:22 <vixey> GADTs? really?
09:51:25 <vixey> I don't think so
09:51:28 <vixey> can you show me?
09:51:31 <Cale> Type families are essentially type-level functions
09:51:36 <gbacon> dcoutts_: right, I know how to use flags (super-spiffy feature, BTW)
09:51:55 <FordCortina> hang on
09:52:03 <dcoutts_> gbacon: great, so you can send audreyt patches :-)
09:52:11 <gbacon> dcoutts_: kind of weird to write Prolog programs for build specs :-)
09:52:24 <dcoutts_> gbacon: no, actually it makes perfect sense
09:52:33 <dcoutts_> gbacon: being able to drive them both directions is super useful
09:52:36 <gbacon> dcoutts_: I'm a committer, trying to make profiling deps optional
09:52:53 <FordCortina> vixey: http://hpaste.org/9408
09:53:02 <gbacon> dcoutts_: as I said, it's a great feature.. just weird in the context of the primitive tools I've had to use before
09:53:13 <PeakerWork> is there a Prolog implementation in Haskell as a DSL (without the parser/etc)?
09:53:16 <FordCortina> vixey: im developing a more compicated one with Parser indices all Daniellsson-Norell
09:53:21 <dcoutts_> gbacon: I guess Cabal could just filter -threaded when profiling is on, as a service to the community :-)
09:53:24 <FordCortina> s/all/a la/
09:53:38 <gbacon> dcoutts_: that could be helpful
09:53:46 <Baughn> PeakerWork: Have you looked at logict?
09:53:58 <dcoutts_> gbacon: file a feature request, it should be trivial.
09:54:00 <vixey> LogicT is really nothing to do with haskell
09:54:01 <vixey> er....
09:54:03 <Baughn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict <-- I don't know how complete this is
09:54:04 <lambdabot> Title: HackageDB: logict-0.2.3
09:54:05 <vixey> s/haskell/prolog/
09:54:09 <gbacon> dcoutts_: where?
09:54:12 <vixey> PeakerWork: There's 3/4s of one http://muaddibspace.blogspot.com/2008/07/interpreter-for-prolog-without-cut.html
09:54:15 <lambdabot> Title: Muad`Dib: Interpreter for Prolog without cut, http://tinyurl.com/5jjg7o
09:54:21 <FordCortina> vixey: i think the main advantage with GADTs is that they are quite usefull for prototyping
09:54:29 <dcoutts_> gbacon: http://hackage.haskell.org/trac/hackage/
09:54:29 <vixey> PeakerWord: Also Hugs comes with a few Prolog interpreters
09:54:30 <lambdabot> Title: Hackage - Trac
09:54:34 <PeakerWork> Baughn: nope, what's that?
09:54:37 <vixey> I think
09:54:40 <FordCortina> vixey: you cant run into decidablity problems
09:54:57 <Baughn> PeakerWork: I'm not sure yet. It's apparently nothing to do with prolog, but it does do backtracking, etc., so it might be useful
09:55:15 <Baughn> PeakerWork: http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/Control-Monad-Logic-Class.html <-- This suggests it is
09:55:16 <lambdabot> Title: Control.Monad.Logic.Class, http://tinyurl.com/37f4ga
09:56:21 <Baughn> vixey: Does it actually have nothing in common with prolog, or is it feature-equivalent but just a different way to do the same?
09:56:37 <vixey> Baughn: It's really nothing to do with Prolog
09:56:50 <vixey> Baughn: You couldn't use it to implement Prolog, for example
09:57:10 <vixey> Baughn: but you could use it to implement a better logic language
09:57:29 <Baughn> It looks useful to me regardless, though
09:57:48 <vixey> Baughn: I would love to see some programs that use it ...
09:57:55 <vixey> Baughn: afaik there aren't any though
09:58:10 <vixey> FordCortina: I don't think this is type level computatio
09:59:21 <gbacon> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/317
09:59:23 <lambdabot> Title: #317 (filter -threaded when profiling is on) - Hackage - Trac
09:59:30 <dcoutts_> gbacon: ta
09:59:31 <gbacon> dcoutts_: thanks for your help
09:59:34 <ddarius> The Typed Logical Variables paper essentially gets all of pure Prolog.
10:01:39 <FordCortina> vixey: i guess your right actually. but it is doing more type checking
10:01:51 <FordCortina> s/your/you're/
10:01:56 <vixey> ddarius: that paper by conal about implementing logic languages (goes from prolog up to lambda prolog and so on) was really great
10:02:24 <dcoutts_> gbacon: np
10:02:35 <vixey> (you'd linked it a while ago)
10:02:40 <dcoutts_> gbacon: I'm glad we figured it out, I was quite perplexed.
10:03:00 <FordCortina> vixey: you get all the type checking you would with type functions, but with a bit more work at runtime
10:03:25 <FordCortina> that's my hunch anyway
10:03:31 <vixey> FordCortina: wait with GADTs? I was assuming none of that happened checking happened at runtime
10:03:55 <twobitwork> ick... perl's open() function accepts a scalar (not even a reference to a scalar) and changes its value in the caller scope :(
10:04:13 <PeakerWork> Perl is pretty horrible :)
10:04:21 <Baughn> twobitwork: Shouldn't that be impossible?
10:04:23 <twobitwork> sorry... I know its off topic, but I just had to complain to people who would understand the problems therein
10:04:32 <twobitwork> Baughn: perldoc -f open
10:05:06 <twobitwork> my $fd; open($fd, "asdf"); print "$fd\n"; # .... leads to $fd taking on a value corresponding to a file handle
10:05:12 <Baughn> twobitwork: ooh dear, that's messy
10:05:21 <Baughn> twobitwork: Call-by-name taken to the logical limit
10:05:28 <FordCortina> vixey: hmm ill have to think a bit more about this
10:06:19 <EvilTerran> perl -le 'my $x = 1; (sub { $_[0] = 2 })->($x); print $x'
10:06:21 <EvilTerran> will print 2
10:06:25 <EvilTerran> iirc
10:06:42 <Baughn> No more. Let us bask in the light of haskell.
10:07:06 * Baughn has never learned perl; this sort of thing won't make me change my mind
10:07:29 <chrisdone> Baughn: high five!
10:07:32 <FordCortina> :D
10:07:46 <vixey> programming languages are weird
10:07:58 <PeakerWork> especially Perl
10:08:11 <vixey> I don't think so
10:08:15 <vixey> perl is kind of normal
10:08:32 <slarba> recursive regexps...
10:08:34 <vixey> perl, python, php, ruby, .. all pretty normal
10:08:35 <hackage> Uploaded to hackage: FTGL 1.0
10:08:46 <jrh> yay.  thank you, hackage
10:08:58 <Jedai> Perl is pretty weird... when you use all its twisted tricks
10:09:14 <geezusfreeek> in order from least insane to most insane: python, ruby, perl, php
10:09:15 <chrisdone> it's syntax is weird (read: twisted), anyway
10:09:23 <geezusfreeek> where perl and php and very close
10:09:23 <chrisdone> semantics aren't so special
10:09:26 <Jedai> Baughn: Yeah, all argument passing is pass-by-alias in PErl
10:09:33 <vixey> geezusfreeek: python, ruby, perl, php are all exactly the same
10:09:52 <Jedai> geezusfreeek: Nope, I think Perl is much more consistent than PHP
10:10:04 <geezusfreeek> Jedai: that is why it came first in the list
10:10:11 <geezusfreeek> *before php
10:10:23 <Jedai> I think PHP is in a category apart
10:10:49 <vixey> Jedai: I think they are all equally rubbish
10:11:21 <chrisdone> whey check this guise
10:11:22 <chrisdone> http://chrisdone.com/kibro.txt
10:11:27 <chrisdone> http://chrisdone.com:3000/
10:11:27 <lambdabot> Title: chris done's homepage
10:11:36 <Jedai> seriously, a language that has thousands of global imported unconditionally... which have "===" and "mysql_real_escape_function" (there is a not real variant too)
10:11:39 <chrisdone> uh, that title is wrong. lambdabot assumes port 80
10:12:00 <Jedai> vixey: I like Perl, you can do a lot of cool thing in it :-)
10:12:06 * vixey uses ≡ instead of ===
10:12:18 <Trinithis> math ftw!
10:12:19 <vixey> Jedai: I don't like Perl (anymore), I like Perl 6 though
10:12:33 <gbacon> dcoutts_: so does cabal-install support side-by-side installations of profiling and non-profiling libraries?
10:12:34 <vixey> Perl 6 is interesting
10:12:37 <Trinithis> What firewall and antivirus software should I install on ubuntu?
10:12:49 <dcoutts_> gbacon: yep
10:12:53 <geezusfreeek> i haven't drunk the perl 6 koolade yet
10:13:00 <lilac> chrisdone: whoa me too
10:13:02 <_zenon_> Trinithis, I don't know, go ask the people in #ubuntu :)
10:13:02 <pastorn> Trinithis: none?
10:13:09 <chrisdone> lilac: what‽
10:13:13 <Jedai> vixey: Perl6 is too crazy, I was following its development but I'll wait for the first release to take a look at it again
10:13:18 <lilac> chrisdone: chrisdone.com:3000
10:13:19 <Trinithis> Isn't haskell the only language so far to implemtn pearl 6?
10:13:23 <CosmicRay> Trinithis: wouldn't an ubuntu channel be more appropriate for that? ;-)
10:13:24 <Trinithis> perl*
10:13:30 <chrisdone> lilac: what about it?
10:13:32 <CosmicRay> I mean the av question
10:13:33 <vixey> Trinithis: there is no perl 6 implementation yet
10:13:37 <Jedai> Trinithis: Not really anymore,
10:13:45 * CosmicRay is totally confused about perl6/parrot
10:13:50 <pastorn> what happened to pugs?
10:14:05 <Jedai> Trinithis: And anyway "pugs" never implemented the whole Perl6 spec
10:14:19 <chrisdone> why are you talking in the paste tense
10:14:23 <CosmicRay> anyone see my latest message about bytestring stuff?
10:14:26 <chrisdone> "darcs was good"
10:15:02 <thoughtpolice> pugs has been dormant over the last year primarily because of audreyt's absense
10:15:05 <Jedai> pastorn: It's still developed, but I think a lot of work has been reported on Perl6 on Parrot
10:15:27 <twobitwork> I always want to read bytestring as by-test-ring...
10:15:27 <Jedai> thoughtpolice: It seems to be restarting though ?
10:15:34 <thoughtpolice> but luckily she is back and will be hitting hard i think.
10:16:19 <chrisdone> haha
10:16:26 <chrisdone> audreyt: II
10:16:56 <audreyt> hi
10:17:09 <vixey> hello
10:17:25 <audreyt> I was very ill. no longer ill now. and I'm back to general hacking. :)
10:17:56 <audreyt> and "cabal install Pugs" gives you a pretty fast and efficient and reasonably complete perl6 implementation.
10:17:58 * BMeph cheers for audreyt!
10:18:22 * Jedai cheers too !!
10:18:28 * BMeph spends a couple of minutes explaining to his workmates what the cheering was for...
10:18:29 <chrisdone> hey
10:18:56 <PeakerWork> I hate Perl, and like Haskell. It seems so weird to me that Haskell folks would like Perl -- such a huge mismatch in my mind :)
10:19:13 <audreyt> ...but GHC's only external dependency is Perl5
10:19:13 <ddarius> PeakerWork: Who says they do?  Some do, some don't.
10:19:22 <CosmicRay> PeakerWork: mine too ;-)
10:19:42 <audreyt> and every time you compile something with ghc -O, you need to thank perl for optimizing your code :D
10:19:44 <CosmicRay> perl has its niche though.
10:19:47 <CosmicRay> as does haskell.
10:20:21 <chrisdone> yeah what an interesting statement :P
10:20:30 <chrisdone> "X popular language as a niche"
10:20:35 <chrisdone> ya think?
10:20:50 <audreyt> "C is just this niche language"
10:21:08 <CosmicRay> chrisdone: cobol has no niche.
10:21:50 <geezusfreeek> sure it does
10:22:03 <geezusfreeek> maintenance programmers
10:22:05 <Shiruka> cobol's niche is "despised programming languages"
10:22:11 <CosmicRay> I don't consider "because that what we've always used" to be a niche
10:22:12 <CosmicRay> hah
10:22:36 <CosmicRay> geezusfreeek: well then, 32-bit extended DOS has a niche too.
10:22:39 <chrisdone> more like "because that's what they always used"
10:22:43 <geezusfreeek> sure does
10:22:44 <CosmicRay> heh
10:22:59 <CosmicRay> geezusfreeek: its niche is that thin space between /dev/null and /dev/zero
10:23:28 <geezusfreeek> the stuff that happens between cat /dev/zero > /dev/null ?
10:23:40 <CosmicRay> hah
10:23:48 <PeakerWork> Perl's lack of func argument specification (with the shift/$1 horrors), horrors like the above-mentioned "open", its tolerance of attempts to parse strings as ints (and otherwise abuse "scalars"), its awkwardness in handling nested data structures, its syntatic noise, I can't stand it all :)
10:24:26 <CosmicRay> PeakerWork: try using multithreading in python some time.  I only this week realized what a true horror that is.
10:24:26 <Pete_I> it's not noise, it's awesome.
10:24:44 <araujo> PeakerWork, that changes on perl6
10:24:51 <audreyt> PeakerWork: modern perl is nothing like that thouugh :) # see http://search.cpan.org/dist/Moose/
10:24:52 <lambdabot> Title: Shawn M Moore / Moose - search.cpan.org
10:24:58 <PeakerWork> CosmicRay: I hear that multithreading in Perl sucks even more :) Besides, you shouldn't be using threads in Python (Twisted is a good alternative)
10:24:58 <geezusfreeek> multithreading in _most_ imperative languages is pretty bad now that i know haskell
10:25:15 <PeakerWork> audreyt: Perl 5 is not modern Perl?
10:25:23 <CosmicRay> PeakerWork: oh man.  I actually ported offlineimap to twisted back in the day.  what a maintenance nightmare.
10:25:40 <Pete_I> #perl uses 5.8 mostly
10:25:42 <PeakerWork> CosmicRay: What gave you grief?  My experiences with Twisted were extremely happy ones :)
10:25:43 <CosmicRay> PeakerWork: twisted is incredibly difficult to debug and get flow right
10:25:46 <audreyt> PeakerWork: modern as in modern coding practices
10:25:48 <chrisdone> audreyt: haha, did you just put a comment inside your message? <3
10:25:55 <CosmicRay> PeakerWork: were you doing programs of much of a significant size?
10:26:03 <olsner> oh, btw, does perl 5.10 still break ghc?
10:26:12 <audreyt> PeakerWork: which involves type discipline and autoboxing and sane OO ect
10:26:17 <audreyt> olsner: no I fixed that, afaik.
10:26:36 <PeakerWork> CosmicRay: I had very few troubles with re-entrance issues with deferred calling, but otherwise the flow was easier to debug and more deterministic than threading solutions and alternate solutions
10:26:37 <Philippa> modern perl = greenspun?
10:26:37 <olsner> ah, nice, no need for me to figure out how to report bugs then :)
10:26:56 <CosmicRay> PeakerWork: that's not what I found.  But then I also don't like WASH in haskell for similar reasons.
10:27:02 <CosmicRay> it just leads to spaghetti way too easily.
10:27:02 <gbacon> audreyt: done with your interview?
10:27:06 <PeakerWork> CosmicRay: I think my largest Twisted works were ~10000 lines
10:27:10 <audreyt> gbacon: yup. I think I got the job
10:27:11 <CosmicRay> I like how forkIO in Haskell handles it.
10:27:12 <PeakerWork> CosmicRay: maybe a little more
10:27:15 <gbacon> audreyt: sweet
10:27:32 * audreyt prepares to infiltrate yet another company with haskell
10:27:32 <CosmicRay> PeakerWork: that's probably about 2x larger than offlineimap
10:27:54 <CosmicRay> initially I tried twisted because python's imaplib.py sucks so much
10:27:59 <CosmicRay> twisted has a nice mail infrastructure
10:28:03 <CosmicRay> but its core sucks more ;-)
10:28:11 * CosmicRay is now pondering porting offlineimap to haskell
10:28:14 <gbacon> audreyt: I'm working toward the same aim in my local chapter of Project Haskell-hem :-)
10:28:18 <CosmicRay> but it turns out our low-level networking sucks.
10:28:22 <PeakerWork> CosmicRay: any concrete things that suck?
10:28:33 <CosmicRay> PeakerWork: let me see if I can dig up some mailing list posts.
10:28:34 <Baughn> CosmicRay: Cheap forkIO is nice, but other languages have that. What really gets me is the immutability.
10:28:43 <PeakerWork> CosmicRay: I dislike some things about Twisted, and its internals are kinda yucky (and overly dynamic), but the exported API is pretty nice
10:28:54 <gbacon> Immutability is good for the soul.
10:29:01 <CosmicRay> PeakerWork: this was back in 2003 so my memory is a bit fuzzy
10:29:18 <chrisdone> gbacon: like novacaine
10:30:55 <gbacon> if I already have a package installed without profiling, how can I tell cabal-install to also build and install the profiling library? cabal install -p <package> quits thinking that it has nothing to do
10:31:35 <gbacon> chrisdone: But immutability never makes you drool!
10:31:58 <CosmicRay> PeakerWork: sorry, I'm not turning up anything solid.
10:32:08 <chrisdone> gbacon: it does!!
10:32:34 <dcoutts_> gbacon: there's no easy way to do it at the moment. The workaround is to either do the configure, build && install steps directly, or to unregister the package first, or to fix ticket #301
10:32:47 <CosmicRay> ahh actually
10:32:57 <CosmicRay> PeakerWork: one problem was no curses interface for twisted
10:33:01 <audreyt> dcoutts_: pugs is running into cabal limitations quickly and frequently :)
10:33:08 <camio> @hoogle X
10:33:08 <lambdabot> Text.XHtml :: module
10:33:08 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
10:33:08 <lambdabot> Distribution.Simple.Utils.xargs :: Int -> ([String] -> IO ()) -> [String] -> [String] -> IO ()
10:33:17 <audreyt> (such as the -p questions above)
10:33:17 <dcoutts_> audreyt: just make sure you report them all! :-)
10:33:19 <audreyt> I hope we get a better cabal out of this, though.
10:33:26 <dcoutts_> audreyt: yeah, me too
10:33:30 <audreyt> that what we're doing in the channel :)
10:33:35 <fiddlerwoaroof> what is sp? as in sp ghc -isrc src/Main.hs --make --run --http-port=5000 ?
10:33:49 <thoughtpolice> fiddlerwoaroof: searchpath
10:33:50 <dcoutts_> audreyt: it's better than before where pugs was using horrific workarounds and the Cabal hackers didn't even know there was a need.
10:34:03 <thoughtpolice> fiddlerwoaroof: http://searchpath.org
10:34:04 <lambdabot> Title: SearchPath — Automatic import chasing across the Internet for Haskell modules
10:34:07 <audreyt> well to be fair there were no hackage.
10:34:12 <audreyt> but yes, it's much better now.
10:34:27 <dcoutts_> audreyt: oh, I don't mean hackage, there were other horrors :-)
10:34:38 <audreyt> ok :)
10:34:39 <fiddlerwoaroof> thoughtpolice: thank you, I spent 15 or 20 minutes looking for it
10:34:44 <chrisdone> can cabal install install from a directory? I want it to install packages dependencies for me :0
10:34:51 <dcoutts_> chrisdone: yes
10:34:57 <audreyt> #perl6 is positively happy about cabal-install's UI though, it's highly intelligent and non-intrusive when it works
10:35:07 <dcoutts_> audreyt: great :-)
10:35:30 <dcoutts_> audreyt: and you're welcome to point contributers to our list of easy Cabal bugs :-)
10:35:39 <audreyt> but when it doesn't work, the messages are cryptic or nonexistent or impossibly unrelated :)
10:35:40 <dcoutts_> audreyt: http://hackage.haskell.org/trac/hackage/report/13
10:35:41 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
10:35:45 <audreyt> sure, will do
10:36:06 <PeakerWork> audreyt: what advantages does Perl have over Python, though? Why emulate proper objects in Perl, instead of just moving to a language that already has them?
10:36:14 <audreyt> PeakerWork: not emulate, codify
10:36:18 <audreyt> PeakerWork: think javascript
10:36:38 <lispy> rank-2 polymorphism is hard, let's go shopping
10:36:42 <audreyt> it doesn't have a proper class based oo but through time people codify on what works best in a mixed fp/oo idiom
10:36:47 <vixey> shopping!
10:36:51 <audreyt> and jquery or extjs, like moose, is pretty neat!
10:37:08 <audreyt> so sometimes flexible oo system is a win
10:37:13 <PeakerWork> audreyt: I think a lot of people don't realize that having more features is not necessarily a good thing - especially when those features are at the disposal of not only yourself.  There is a lot of power that arises from limitations
10:37:34 <olsner> lispy: shopping is hard, let's go write a type-level RSA
10:37:35 <fiddlerwoaroof> thats quite acool tool
10:37:55 <audreyt> PeakerWork: yes, and modern perl (see the best practice book and Perl::Critic automated linter) is all about choosing the correct set of limitations and use commit hooks to enforce them
10:38:19 <audreyt> but because those limitations can be decided by the team policy, it sometimes give a better fit for the domain.
10:38:29 <audreyt> it requires more upfront thinking costs, though.
10:39:28 <PeakerWork> audreyt: The problem with that approach is that in that case, you're using a language that only your team uses in the world, and cannot easily share code with others.  They cannot read the code written with your particular limitations, and you cannot read theirs, because they chose different limitations
10:39:46 <audreyt> actually you can read just fine, but you can't easily write, yes.
10:39:52 <audreyt> you'd be acting through module API boundaries.
10:40:04 <audreyt> but that is what the ruby-dsl people are advocating too
10:40:23 <audreyt> and while that approach doesn't fit all problem domains, it works really well for some teams.
10:40:43 <PeakerWork> audreyt: A lot of language features that allow doing the same thing in different (but equivalent, not really any shorter) ways means that you will have to learn a lot more before being able to read others' code, and their code will be more difficult to parse (given Perl's huge grammar)
10:41:23 <audreyt> I actually can't think of the kind of equivalent features you mentioned
10:41:42 <audreyt> unless you're talking about really trivial syntax like "if (x) { y }" vs "y if x"
10:42:25 <PeakerWork> audreyt: There are a lot of trivial syntactic differences.  Then there are different ways to accept arguments, and hundreds of different operators you can use, and so on
10:43:59 <audreyt> this is turning into #perl :)
10:44:55 <audreyt> but anyway, I agree the traditional calling convention is not very helpful
10:45:30 <olsner> Topic in #haskell is now: "Everything perl! Haskell conversations have been moved to #perl."
10:45:43 <audreyt> lol
10:46:49 <audreyt> PeakerWork: vanilla perl5 syntax is badly broken, and modern perl5 revolves standardizing on a nonbroken, heavily perl6-influenced dialect, and I think it's pretty healthy doing that
10:47:08 <audreyt> and pretty much everyone agree vanilla perl5 syntax is broken, let's not dwell on it :)
10:47:09 <chrisdone> how do you pronounce cabal? I've always pronounced it "sabull"
10:47:09 <Shiruka> secretly the perl and ghc hackers are planning to make ghc 6.10 the next perl (perl 6)
10:47:18 <Elly> like the english word
10:47:24 <Elly> with a hard c, I think
10:47:24 <dcoutts_> chrisdone: hard c
10:47:25 <Elly> 'kabal'
10:47:52 <PeakerWork> audreyt: does strict modern Perl allow for things like converting "hello world" to a 0 successfully, with the default to-int conversion?
10:48:05 <matthew-_>     No instance for (Show GHC.Prim.Any)
10:48:07 <Baughn> chrisdone: I pronounce it llike "cobol", but with an a
10:48:09 <matthew-_> bother ;)
10:49:13 <lispy> ku-ball
10:49:26 <audreyt> PeakerWork: no, it's a fatal runtime error.
10:49:47 <Beelsebob> ka-bahl -- as in Qabula
10:49:50 <audreyt> "use warnings FATAL => 'numeric';" is the relevant policy
10:49:55 <fiddlerwoaroof> cabal is giving me this error on update-- cabal: Failed to download index 'ErrorMisc "Invalid HTTP code: (4,0,3)"'
10:50:05 <Shiruka> I sense worshippers of the lords of cobol here
10:50:38 <PeakerWork> audreyt: I see, I'll look into modern Perl to update my view of what's wrong with Perl :)
10:50:53 <dcoutts_> fiddlerwoaroof: interesting. That's 403, forbidden http error code.
10:51:03 <gwern> Shiruka: absurd. Cobolds are squat ugly creatures, while all #haskellers are gracile elves
10:51:05 <dcoutts_> fiddlerwoaroof: but I just tried it and it works for me
10:51:08 <fiddlerwoaroof> I guessed that
10:51:19 <Baughn> fiddlerwoaroof: What url does it claim to be downloading from?
10:51:29 <fiddlerwoaroof> http://hackage.haskell.org/packages/archive
10:51:30 <lambdabot> Title: Index of /packages/archive
10:51:40 <dcoutts_> no, it append 00-index.tar.gz
10:51:51 <dcoutts_> use cabal update -v3 to see the http conversation
10:52:08 <gwern> or should I say #haskllers are eλves? :)
10:52:49 <Elly> is gracile a word?
10:53:04 <fiddlerwoaroof> http://hpaste.org/9410
10:53:05 <vixey> @w80 gracile
10:53:06 <lambdabot> *** "gracile" wn "WordNet (r) 2.0"
10:53:06 <lambdabot> gracile
10:53:06 <lambdabot>      adj : slender and graceful [syn: {willowy}]
10:53:31 <newsham> I have a profiling question.  I dont quite understand the results here http://www.thenewsh.com/%7Enewsham/store/Server8.p.prof where get8 is being listed as 32% of my time, but is rarely called in http://www.thenewsh.com/%7Enewsham/store/Proto4.hs is this because its lumping all of the "get" calls together as "get8" incorrectly?
10:53:57 <newsham> (where get8 is defined as:  get8 = get :: Get Word8
10:54:11 <Elly> hm, that's a nice word
10:54:25 <fiddlerwoaroof> Baughn, dcoutts_ : http://hpaste.org/9410, I can download the file with Firefox
10:55:09 <dcoutts_> fiddlerwoaroof: is the problem persistent? Are you using a proxy? (check $http_proxy or $HTTP_PROXY)
10:55:35 <gwern> Elly: I am distressed you ever doubted my vocabulary :(
10:55:42 * gwern is very proud of my English vocabulary
10:56:03 <fiddlerwoaroof> dcoutts_: no I am not
10:56:21 <newsham> anyone know why weird profiling results?
10:56:24 <lispy> gwern: proud of my english vocabulary, why thank you
10:56:34 <Baughn> fiddlerwoaroof: And firefox allows you to download http://hackage.haskell.org/packages/archive/00-index.tar.gz ?
10:56:36 <matthew-_> is there a "standard" way to get round the need for incoherent instances?
10:56:40 * lispy beams
10:56:49 <fiddlerwoaroof> Baughn: yes
10:56:50 <gwern> dcoutts_: btw, I was wondering. have you ever heard of a cabal-install problem where you can download/update once, and then every time after in a given shell/terminal it fails with a getHostName problem? (starting up a new term always results in working cabal-install)
10:57:02 <matthew-_> really I want one instance to be selected for a floating type, and other instances to be selected for ground types
10:57:03 <gwern> lispy: calloo callay, my beamish lad
10:57:11 <dcoutts_> gwern: nope
10:57:28 <dcoutts_> gwern: that's pretty odd
10:57:42 <gwern> dcoutts_: yeah, which is why I was wondering
10:58:04 <Baughn> fiddlerwoaroof: ..I've got nothing. Compare the connections with wireshark?
10:58:43 <Baughn> fiddlerwoaroof: Oh, hang on. What os are you on? Don't suppose you happen to be running some odd software firewall that might be blocking it per-program?
10:58:45 <fiddlerwoaroof> Baughn, dcoutts_: I found out the problem by replaying the connection with telnet
10:59:04 <fiddlerwoaroof> Im in a public cafe and there is a transparent content filter
10:59:09 <fiddlerwoaroof> which is wierd
10:59:32 <Baughn> fiddlerwoaroof: Can you use telnet to check, see if it's objecting to the user-agent?
11:00:24 <dcoutts_> fiddlerwoaroof: perhaps it does not like .tar.gz files?
11:00:40 <matthew-_> you know I increasingly think I'm a very bad haskell programmer - I spend all my time programming at the type level, which is basically untyped. So I just write untyped programs, that happen to run at compile time
11:00:40 <Baughn> Firefox downloads it fine, though
11:00:52 <Baughn> The user-agent thing is about the only thing I can imagine
11:00:58 <dcoutts_> ah but it'll be using a different content encoding
11:01:11 <dcoutts_> since firefox claims to grok transfer-encoding gzip
11:01:17 <gwern> matthew-_: typed types sounds difficlt to think about
11:01:20 <vixey> the type system is kinded
11:01:25 <vixey> :k Mu Just
11:01:32 <Baughn> dcoutts_: Surely that won't make a difference when you're downloading a .gz file?
11:01:34 <matthew-_> gwern: nah, it's been done before - Omega for one
11:01:39 <dcoutts_> Baughn: so apache will say it's a tar file but transfer-encoded using gzip
11:01:49 <camio> Anyone know of a simple way to get an arbitrary floating point number in a given range with QuickCheck?
11:01:49 <dcoutts_> Baughn: no really, check the mime types apache reports
11:01:54 <gwern> matthew-_: the name alone frightens me
11:01:55 <Baughn> dcoutts_: It does? That's bizarre
11:02:05 <Baughn> dcoutts_: I don't want firefox to automatically unpack my archives. :/
11:02:05 <dcoutts_> Baughn: not really
11:02:06 <gwern> camio: filter out non-matching ones?
11:02:20 <dcoutts_> Baughn: it doesn't, but it knows more about the type
11:02:28 <gwern> not (1 < x < n) ==> (test x), I suppose it'd look like
11:02:35 <camio> gwern: This is on the right side of an arbitrary =.
11:02:35 <matthew-_> camino: take any random float and scale it appropriately
11:02:40 <dcoutts_> Baughn: and it does affect how it gets handled, depending on how the server reports the mime type.
11:03:09 <matthew-_> camio: but don't forget floats don't do maths
11:03:15 * vixey thinks you can't write 1 < x < n
11:03:25 <dcoutts_> Baughn: a primitive server that reports it as a gz type will make filefox open the file-roller app telling it it's a .gz file, so it'll only show one file content, the .tar inside the .gz!
11:03:28 <vixey> or can you?
11:03:49 <matthew-_> vixey: you can in fortress, IIRC
11:03:52 <camio> matthew -> I'm not sure how I'd scale that. If I had a float between 0 and 1 that'd be enough. But how would I scale -infty and +infty?
11:03:59 <vixey> I meant haskell
11:04:00 <vixey> lo
11:04:19 <vixey> or quickcheck or whatever it is
11:04:22 <fiddlerwoaroof> Baughn, dcoutts_: if I GET /packages/archive/00-index.tar.gz  and set a host header it works
11:04:35 <fiddlerwoaroof> Baughn, dcoutts_: if I GET http://hackage.haskell.org/packages/archive/00-index.tar.gz  and set a host header it fails
11:04:48 <fiddlerwoaroof> Baughn, dcoutts_: without a host header that is
11:04:50 <matthew-_> > (maxBound :: Float) / (maxBound :: Float)
11:04:52 <lambdabot>   add an instance declaration for (Bounded Float)
11:04:58 <matthew-_> sigh
11:04:59 <vixey> weird
11:05:15 <matthew-_> > ((1/0) :: Float) / ((1/0) :: Float)
11:05:17 <lambdabot>  NaN
11:05:21 <camio> nevermind, I found it elsewhere:  http://hpaste.org/9411
11:05:25 <vixey> > dropWhile (>) $ iterate (+1) (1::Float)
11:05:26 <lambdabot>  Couldn't match expected type `Bool'
11:05:31 <vixey> > dropWhile (>1) $ iterate (+1) (1::Float)
11:05:33 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
11:05:38 <vixey> > dropWhile (<1) $ iterate (+1) (1::Float)
11:05:39 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
11:05:50 <Baughn> fiddlerwoaroof: Hm. Sounds like you might be behind a proxy that doesn't really grok http 1.1
11:06:19 <fiddlerwoaroof> yeah I guess so
11:07:15 <Baughn> "To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies. " <-- Note the MUST
11:07:39 <Baughn> An "absoluteURI", here, is specifically the http://foo.bar/baz form of GET
11:08:01 <Baughn> fiddlerwoaroof: Makes it extra odd that this proxy /doesn't/ grok it, but if it's meant to be a transparent proxy only..
11:08:16 <fiddlerwoaroof> its the Sonicwall content proxy
11:08:27 <fiddlerwoaroof> by transparent I meant it was invisible to me
11:08:48 <vixey> > 99999999999999999999999999999999999999::Float
11:08:49 <lambdabot>  1.0e38
11:08:50 <vixey> > 999999999999999999999999999999999999999::Float
11:08:51 <lambdabot>  Infinity
11:08:57 <Baughn> You don't have to set a proxy address; it redirects all http/port 80 requests to the proxy. That's a transparent proxy.
11:09:04 <Baughn> s/it/the router/
11:09:16 <fiddlerwoaroof> yes
11:09:30 <fiddlerwoaroof> is there a way I can hack the source code to work?
11:09:49 <bogomipz> Is there any way to make a haskell program listen to a port, and present a REPL when you connect, where you can incrementally (re)-compile parts of the running program?
11:10:26 <Baughn> fiddlerwoaroof: Hm. This is amusing..
11:10:54 <dcoutts_> Baughn: it's not clear to me that we're doing it right though.
11:11:06 <Baughn> fiddlerwoaroof: Apparently, proxies and servers MUST accept the absoluteURI form. At the same time, clients MUST use the absolutePath form and a Host header unless they know they're talking to a proxy
11:11:15 <EvilTerran> bogomipz, in theory, kinda
11:11:21 <EvilTerran> using ghc-api, i believe
11:11:24 <thoughtpolice> bogomipz: it is feasible to recompile parts of your program and keep it going, yes (i did it for an IRC bot)
11:11:26 <Baughn> So you're being bitten by the conjunction of a hshttp bug and proxy-server bug
11:11:37 <dcoutts_> Baughn: from my reading of the HTTP 1.1 spec we should GET /path HTTP/1.1; Host: hackage.haskell.org
11:11:46 <Baughn> dcoutts_: Right. You MUST, in fact.
11:11:52 <thoughtpolice> EvilTerran: I never got the GHC API to work properly for loading new code; I might have been doing something wrong though
11:12:01 <dcoutts_> Baughn: where as the GET http://server/path   is for proxies only
11:12:06 <Baughn> dcoutts_: It's just that servers MUST accept the way you're actually doing, too
11:12:10 <dcoutts_> Baughn: heh
11:12:17 <thoughtpolice> @go Dynamic applications from the ground up
11:12:18 <dcoutts_> Baughn: bug report for the HTTP package...
11:12:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
11:12:19 <lambdabot> Title: Dynamic Applications From the Ground Up
11:12:38 <fiddlerwoaroof> Baughn: it looks like the proxy is trying to block other proxies
11:12:44 <thoughtpolice> bogomipz: ^^ that paper describes an approach to doing it, worth reading
11:12:48 <dcoutts_> Baughn: know of any http protocol validators?
11:12:59 <Baughn> fiddlerwoaroof: A possible interpretation
11:13:06 <Baughn> dcoutts_: Sorry
11:14:08 <bogomipz> thoughtpolice: thanks :) last time I tried, I had trouble even recompiling in GHCi without restarting the thread running that code
11:14:12 <Baughn> dcoutts_: Right, writing bug report
11:14:22 <dcoutts_> Baughn: thanks
11:15:20 <pjdelport> @remember matthew-_ you know I increasingly think I'm a very bad haskell programmer - I spend all my time programming at the type level, which is basically untyped. So I just write untyped programs, that happen to run at compile time
11:15:20 <lambdabot> Okay.
11:15:48 <thoughtpolice> bogomipz: the approach might be a little complicated since you would invoke recompilation commands, orthogonal to the program's actual task, but with some syncronization primitives (i.e. MVars or STM) it shouldn't be hard to adapt the general approach
11:16:57 <thoughtpolice> bogomipz: note the above paper uses hs-plugins, which works well but might not compile on your system (i'm not aware of the status of win32 support, for example)
11:17:01 <Baughn> dcoutts_: Never mind. It was alrady fixed.
11:17:15 <dcoutts_> Baughn: oh, in which version?
11:17:16 <Baughn> dcoutts_: Fix's in 3001.1.0, in fact
11:17:31 <thoughtpolice> bogomipz: never the less it is probably good for some ideas :)
11:17:54 <fiddlerwoaroof> oops
11:18:05 <bogomipz> thoughtpolice: should it work with an out of the box ghc 6.8.2 on linux, you think?
11:18:26 <Baughn> dcoutts_: ..I'm going to have to check whether that fix actually /works/, now
11:18:35 <dcoutts_> Baughn: ta
11:19:21 <thoughtpolice> bogomipz: I wrote my IRC bot (which used hs-plugins for code hot-swapping) on linux and used ghc 6.8, so no i don't think you'll have a problem
11:20:06 <leather> dcoutts_: You might be just the person I'm looking for. I've got a question about testing a package built with cabal.
11:20:15 <dcoutts_> leather: aye
11:20:28 <Baughn> dcoutts_: Oh, wait. Yes, it's fixed.
11:20:29 <thoughtpolice> bogomipz: in fact if you have cabal-install it is likely you can just do 'cabal install plugins' and things will be good :)
11:20:39 <Baughn> It's just that the latest version on hackage is 3001.0.4, which is older than the fix
11:20:55 <leather> I want to test the compiled library without actually installing it. How would I do that?
11:21:12 <dcoutts_> Baughn: ah
11:21:21 <Baughn> dcoutts_: I'm sending an update request to the author
11:21:34 <dcoutts_> leather: cabal register --inplace
11:21:37 <bogomipz> thoughtpolice: ok, thanks for the tip
11:21:46 <dcoutts_> Baughn: cheers
11:23:15 <leather> dcoutts_: Ah, I now see the documentation on it.
11:24:28 <Baughn> fiddlerwoaroof: Meanwhile, if you install http 3001.1.0 and then rebuild cabal-install, the problem should be fixed.
11:24:33 <fiddlerwoaroof> where is 3001.1.0 ?
11:24:47 <Baughn> http://www.haskell.org/http/
11:24:47 <lambdabot> Title: Haskell HTTP package
11:25:14 <Baughn> fiddlerwoaroof: It hasn't been.. released. You'll have to get the darcs version.
11:25:19 <fiddlerwoaroof> ok
11:27:54 <leather> dcoutts_: Hmm, did that. Now I get "ld: in .../lib.a, archive has no table of contents"
11:28:17 <leather> dcoutts_: Maybe there's something wrong with the args I'm passing to ghc.
11:30:11 <matthew-_> @seen DRMacIver
11:30:11 <lambdabot> DRMacIver is in #haskell-blah, #scala and #haskell. I last heard DRMacIver speak 9s ago.
11:30:49 <fiddlerwoaroof> is there an easy way to uninstall a cabal package before cabal is installed?
11:31:43 <Baughn> ghc-pkg unregister foo..
11:31:53 <Baughn> Though that doesn't really /uninstall/ it, it has the same general effect
11:32:19 <fiddlerwoaroof> ok, thanks
11:33:49 <fiddlerwoaroof> That didn't work
11:34:09 <fiddlerwoaroof> it is still trying to get an absolute URL
11:35:42 <bwr_> i am not seeing a function to get today's date as Day...
11:37:43 <leather> dcoutts_: I'm on a MacBook. Do you think the problem could be this: http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/14030/focus=14032 ?
11:37:46 <lambdabot> Title: Gmane Loom, http://tinyurl.com/5k9pvx
11:41:04 <_zenon_> Is there a package for doing the @src  operation from ghci?
11:41:35 <Beelsebob> leather: the easiest way to get ghc building on OS X is to use the port install
11:41:37 <Cale> _zenon_: @src just reads from a textfile
11:41:49 <Beelsebob> then download a source tarball, if you want a more recent version
11:41:53 <Toxaris> _zenon_: note that @src doesn't access the real source, but looks up things in a manually composed database
11:41:56 <leather> Beelsebob: I'm not trying to build ghc. I'm building library.
11:42:11 <leather> Beelsebob: I'm just wondering if it's the same problem.
11:42:12 <_zenon_> Cale, Toxaris oohhh
11:42:20 <Beelsebob> leather: ah, okay
11:42:29 <fiddlerwoaroof> how can I discard a Just to get the value?
11:42:39 <Cale> fiddlerwoaroof: Usually by pattern matching with case
11:42:46 <fiddlerwoaroof> from ghci
11:42:48 <leather> Beelsebob: The funny thing is that I started the thread I linked to when I _was_ trying to build ghc. ;)
11:42:55 <Toxaris> _zenon_: I tend to use Hoogle to access the standard library docs, and follow the Source links there
11:43:02 <Beelsebob> leather: yeh, I recognised the error ;)
11:43:07 <camio> @hoogle fromJust
11:43:07 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
11:43:08 <Cale> > case Just 5 of Nothing -> ""; Just x -> show x
11:43:09 <lambdabot>  "5"
11:43:12 <Beelsebob> (from experience of getting ghc going on a MacBook)
11:43:14 <_zenon_> Toxaris, yeah, me 2, but doing @src would be nicer
11:43:31 <Cale> > maybe "" show (Just 5)
11:43:32 <lambdabot>  "5"
11:43:36 <Cale> > maybe "" show Nothing
11:43:37 <lambdabot>  ""
11:43:39 <Beelsebob> which library are you trying to build leather?
11:43:43 <Toxaris> _zenon_: yeah, a locally installed, hoggle + hadock + source command line interface would be great
11:43:48 <fiddlerwoaroof> Cales: thanks
11:43:54 <Toxaris> _zenon_: automatically updated by cabal install
11:43:58 <leather> Beelsebob: One I'm developing. It's not released, yet.
11:44:06 <Beelsebob> leather: and the error?
11:44:14 <Cale> fiddlerwoaroof: There's also fromJust which is available in Data.Maybe, but it gives an error if the value turns out to be Nothing
11:44:39 <fiddlerwoaroof> Cale: Im doing interactive experimentation, and the Monads can get anoyying
11:44:46 <Toxaris> > fromMaybe 42 Nothing -- the better fromJust
11:44:47 <lambdabot>  42
11:44:55 <Toxaris> > fromMaybe 42 (Just 23) -- the better fromJust
11:44:56 <leather> "ld: in /blah/dist/build/lib-0.1.a, archive has no table of contents"
11:44:56 <lambdabot>  23
11:46:19 <Cale> fiddlerwoaroof: Well, Maybe happens to be a monad, but there's nothing monadic about this stuff :)
11:46:21 <Beelsebob> leather: try running ranlib on the .a file
11:46:30 <dcoutts> leather: ah, yes. That is the problem. Run ranlib on the archive file.
11:46:36 <fiddlerwoaroof> Cale: mhm
11:46:44 <Cale> fiddlerwoaroof: However, you can use the fact that it's a monad to make composing things a bit more convenient.
11:47:29 <leather> Sweet. It works.
11:47:32 <Toxaris> Cale: what is "monadic code" anyway?
11:47:45 <leather> Thanks.
11:47:48 <leather> Now, how do I add that to the build process
11:47:52 <leather> ?
11:47:55 <Cale> Toxaris: Well, code that uses the general monad operations :)
11:48:08 <Beelsebob> leather: are you using cabal to build your library?
11:48:15 <leather> Beelsebob: Yeah.
11:48:15 <Beelsebob> Cale: interestingly -- I tend to find that monads make composition harder, not easier
11:48:26 <Toxaris> > "so " `mplus` " this is monadic?"
11:48:27 <lambdabot>  "so  this is monadic?"
11:48:37 <Cale> Beelsebob: Then perhaps you're using them at the wrong times?
11:48:41 <waern> how to clean the cabal install cache?
11:48:45 <dcoutts> leather: report it as a Cabal bug.
11:48:49 <dcoutts> waern: rm :-)
11:48:54 <waern> oki
11:48:58 <dcoutts> waern: why?
11:49:02 <Beelsebob> Cale: no, generally it's a case of someone else using it at the wrong times, and their library not fitting into what I want to do because of it
11:49:08 <Cale> Beelsebob: ah
11:49:28 <waern> I want to upgrade Cabal, but it tries to upgrade ghc-paths first, since it is cached
11:49:46 <wagstaff> ?pl \(gs, g) -> (g:gs, n)
11:49:46 <Toxaris> maybe class MonadUnsafeRun m where unsafeRun :: m a -> a would be cool, with unsafeRun = unsafePerformIO, head, fromMaybe
11:49:47 <lambdabot> uncurry (flip flip n . ((,) .) . flip (:))
11:50:04 <dcoutts> waern: the caching has nothing to do with cabal's dependency planning.
11:51:00 <dcoutts> waern: so perhaps you mean to 'install' rather than 'upgrade' cabal. The 'upgrade' command tries to upgrade the deps too, 'install' does not.
11:51:34 <waern> hm, ok
11:51:42 <waern> so Cabal depends on ghc-paths?
11:51:50 <dcoutts> waern: no
11:52:54 <dcoutts> waern: I don't know what you're doing exactly, but deleting downloaded files will not change it (except for deleting the index obviously)
11:53:21 <waern> I just want to upgrade Cabal
11:53:33 <waern> cabal install Cabal sais I already have it installed
11:53:43 <waern> so I assumed that I should try cabal upgrade Cabal
11:53:51 <waern> says, even
11:54:00 <dcoutts> waern: no, it says it's already installed if you've got the latest version.
11:54:18 <dcoutts> waern: cabal install Cabal will install the latest version if it's not already the latest version.
11:54:26 <waern> ok
11:54:33 <guillaum2> hello there
11:54:35 <waern> then I need to figure out why my version is old :)
11:55:40 <leather> dcoutts: Which part do I report? I'm not even sure what the problem is. Is something missing from my .cabal or is it the fact that I'm on a Mac?
11:55:46 <Toxaris> talking about cabal, it would be great if cabal-install would work together with the dump windows vista privileges management
11:56:14 <Toxaris> atm the behaviour is to download everything, then compile everything, then complain that it cannot install it because of missing rights
11:56:23 <Toxaris> then throw everything away
11:57:00 <Toxaris> s/dump/dumb
11:57:10 <dcoutts> Toxaris: I don't have access to vista, please report in detail what happens, and perhaps how we might fix it.
11:57:30 <dcoutts> Toxaris: bug reports here: http://hackage.haskell.org/trac/hackage/
11:57:34 <lambdabot> Title: Hackage - Trac
11:57:43 <Toxaris> dcoutts: no clue about fixing, but I can describe the user-visible behaviour I would like to see
11:57:50 <dcoutts> leather: report that the libs cannot be used inplace on OSX
11:57:56 <newsham> if I run "./Setup configure -p" and build and install, will that build and install both profiling and non-profiling libs? or just profiling libs?
11:58:05 <dcoutts> newsham: both
11:58:38 <dcoutts> newsham: to get just the profiling, use --disable-library-vanilla
11:58:52 <newsham> hrm.. then I think upgrading the binary package just cost me a ton of performance...
12:00:31 <newsham> err.. blah.. nope, that wasnt it.. hmm
12:00:35 <newsham> i'm confusing myself here
12:01:31 <Shiruka> performance is measured in tons? :-)
12:01:39 <newsham> metric tons
12:03:31 <humasect> hsc files cannot be used in interactive/interpreted mode for ghc ?
12:03:47 <humasect> oh, sorry, these are for hsc2hs. nevermind =)
12:04:07 <leather> dcoutts: I just confirmed that the same library did indeed work when installed and not when registered in-place.
12:04:20 <leather> dcoutts: Thanks for the help.
12:04:34 <dcoutts> leather: yes, it's because we run ranlib when we install it, but not when we first generate it.
12:05:40 <gwern> '"Last week, California Governor Arnold Schwarzenegger ordered a pay cut, to minimum wage of $6.55/hr,, for 200,000 state workers because a state budget hadn't been approved yet. The state controller, who has opposed the pay cut on principle and legal grounds, now says the pay cut isn't even feasible because the state's payroll systems are so antiquated. He says it would take 6 months to go to minimum wage, and 9 months more to restore salaries once a ...
12:05:46 <gwern> ... budget is passed. The system is based on COBOL, according to the Sacramento Bee, and the state hasn't yet found the funds or resources, in 10 years of trying, to upgrade it."'
12:07:21 <Shiruka> they could always pray to the lords of COBOL
12:07:53 <gwern> how hard could it be to find some crack cobolds?
12:08:01 <Shiruka> I still haven't entirely gotten over the shock that COBOL is used for anything anymore
12:08:36 <hackage> Uploaded to hackage: haddock 2.2.2
12:08:36 <hackage> Uploaded to hackage: hoogle 4.0.0.3
12:08:50 <stepcut> the old NewBinary library could get/put/seek in memory *or* file handles. Is there any way of doing this with binary and friends ?
12:09:08 <waern> ndm: hey
12:09:20 <Shiruka> lords of COBOL don't have anything to do with kobolds :-< http://en.wikipedia.org/wiki/Lords_of_Kobol <-- there (though wikipedia has obviously misspelled COBOL)
12:09:42 <gwern> Shiruka: 'cobolds' is a subtle joke, sheesh!
12:10:04 <Shiruka> I guessed it would be, but since you made it twice, I got doubts :-)
12:10:27 <gwern> you see, I punningly liken cobol programmers to the weak warped monsters, kobolds, by trading on the common english practice of titlefying nouns
12:10:29 <ndm> hi waern
12:11:05 <ndm> waern: shall i just push my hoogle annotations patch before doing the stuff to the other side of haddock? it will probably be a week or two before i get round to the other bits
12:11:11 <gwern> waern: did the 'type foo = ... -- ^ ' bug get fixed?
12:11:12 <ndm> dcoutts: ping?
12:11:26 <waern> gwern: no, it's a bug in GHC
12:11:51 <waern> ndm: what is hoogle annotations?
12:12:10 <ndm> waern: the deprecated/infix stuff, that's just the name i used in the source code
12:12:23 <gwern> waern: :( any idea which ghc will fix it?
12:13:09 <waern> ndm: by all means, push if it doesn't break anything
12:13:12 <jeffwheeler> gwern: where did you get that? I'd like to pass the link around.
12:13:20 <dcoutts> hia ndm
12:13:22 <jeffwheeler> it's a pretty amusing story.
12:13:57 <leather> dcoutts: Done: http://hackage.haskell.org/trac/hackage/ticket/318
12:13:59 <lambdabot> Title: #318 (Library cannnot be used when registered in-place on OS X) - Hackage - Trac
12:14:06 <gwern> jeffwheeler: get what?
12:14:18 <jeffwheeler> gwern: the California COBOL story
12:14:27 <waern> gwern: perhaps I'll have time to fix it in 6.10.1
12:14:29 <gwern> jeffwheeler: front page slashdot
12:14:32 <dcoutts> leather: ta
12:14:37 <jeffwheeler> gwern: ah, I don't read it while at work
12:14:43 <jeffwheeler> gwern: thanks
12:14:56 <gwern> waern: but, wouldn't that be like next year?
12:15:45 <waern> gwern: haven't they said end of september or something?
12:16:40 <gwern> waern: I've no idea, but I tend to always assume releases will be late
12:18:39 <waern> gwern: well, you can't get the fix any sooner, unless you use ghc head, and I fix it :)
12:19:09 <waern> are you using ghc head?
12:19:34 <gwern> then I'm screwed. I've not successfully compiled head in many moons, and ubuntu is so far behind I don't even have 6.8.3
12:19:54 <waern> I just compiled head from scratch
12:24:54 <pozic> Predict what the following output is without cheating: minimum [1,0/0,3]
12:25:05 <Pete_I> does the id function have a use, or is it in prelude just because?
12:25:37 <ndm> Pete_I: its incredibly useful, crops up all the time
12:25:39 <Pete_I> Pozic, 1?
12:25:45 <pozic> Pete_I: wrong.
12:25:51 <ndm> NaN?
12:25:55 <Pete_I> or error div by zero?
12:25:56 <pozic> ndm: wrong
12:26:11 <ndm> 3?
12:26:18 <pozic> ndm: we have a winner
12:26:27 <pozic> ndm: kind of unexpected, not?
12:26:30 <ziman> heh
12:26:32 <Pete_I> you've got to be kidding.
12:26:39 <pozic> Pete_I: no, Haskell is the new PHP.
12:26:41 <ndm> as NaN (the middle one) is incomparable, and the algorithm with compares goes in particular ways
12:26:42 <Pete_I> why would 1 not be the answer?
12:27:06 <pozic> ndm already said it.
12:27:07 <Deewiant> because NaNs compare in unexpected ways
12:27:10 <Pete_I> oh, bug in the algorithm :/
12:27:21 <ndm> Pete_I: no, bug in floating point numbers
12:27:24 <Deewiant> no, it just expects a list that doesn't contain NaNs
12:27:29 <pozic> I am not sure what the specification is of minimum.
12:27:35 <pozic> Let me see...
12:27:35 <ndm> they do not obey the law of trichotomy
12:27:38 <Deewiant> @src minimum
12:27:38 <lambdabot> minimum [] = undefined
12:27:38 <lambdabot> minimum xs = foldl1 min xs
12:27:46 <Deewiant> @src min
12:27:46 <lambdabot> min x y = if x <= y then x else y
12:28:03 <Deewiant> > 0/0 <= 3
12:28:04 <lambdabot>  False
12:28:04 <Pete_I> Deewiant, where does lambdabot get that data?
12:28:07 <Deewiant> > 1 <= 0/0
12:28:08 <lambdabot>  False
12:28:15 <Deewiant> Pete_I: beats me
12:28:25 <Pete_I> anybody know?
12:29:06 <pozic> Pete_I: either directly from the report, or from some file that's copied from the report.
12:29:07 <ndm> Pete_I: someone made it up, its not even accurate
12:29:10 <ndm> > minimum []
12:29:12 <lambdabot>  Exception: Prelude.minimum: empty list
12:29:25 <ndm> the real version has a nicer error message, rather than just undefined
12:29:44 <dino-> @seen CosmicRay
12:29:44 <lambdabot> CosmicRay is in #haskell-blah and #haskell. I last heard CosmicRay speak 1h 56m 47s ago.
12:29:48 <pozic> ndm: why didn't they use the real version?
12:29:55 <dmhouse> ndm: it's "accurate" in that it's the report's recommended implementation, isn't it?
12:30:08 <ndm> pozic: how would you define map?
12:30:09 <dmhouse> ndm: it's not necessarily GHC's, but it's not claiming to be.
12:30:21 <pozic> @src map
12:30:22 <lambdabot> map _ []     = []
12:30:22 <lambdabot> map f (x:xs) = f x : map f xs
12:30:22 <ndm> dmhouse: no, i think its just a random one - it doesn't always match the report
12:30:36 <pozic> ndm: like that?
12:30:43 <dino-> CosmicRay or anyone else familiar with hslogger: I'm trying to setHandlers with a handler made from a file path, which is fine works. But the log stubbornly continued to go to STDOUT as well..
12:30:46 <ndm> pozic: Hugs in reality uses a list comprehension, GHC uses a foldr - only Yhc uses that one
12:30:59 <dino-> Even though setHandlers says: "All existing handlers are removed first."
12:31:06 <pozic> ndm: by "real" I meant the one from the report.
12:31:07 <dino-> Can I get that STDOUT to stop?
12:31:41 <CosmicRay> dino-: show me your code?
12:31:52 <andyjgill> afternoon room!
12:32:31 <CosmicRay> dino-: you might want to start by running updateGlobalLogger rootLoggerName (setHandler blah)
12:32:51 <dino-> fh <- fileHandler "foo.log" DEBUG
12:32:51 <dino-> updateGlobalLogger logger (setLevel NOTICE . setHandlers [fh])
12:33:15 <dino-> CosmicRay: Ah, the logging is propogating up higher than my named logger?
12:33:44 <CosmicRay> I suspect you missed this senetence in the docs:
12:33:46 <dino-> i.e. STDOUT logging not removed any higher than my level.
12:33:47 <CosmicRay> When your Logger has a message to log, it passes it to every LogHandler it knows of to process. What's more, it is also passed to all handlers of all ancestors of the Logger, regardless of whether those Loggers would normally have passed on the message.
12:34:01 <CosmicRay> exactly
12:34:03 <dino-> ah, I see. Thank you
12:34:18 <dino-> Sorry to hit you with what should have been a RTFM
12:34:24 <CosmicRay> the point of this is so you can easily implement something like "Log everything to syslog in addition to whatever else it goes"
12:34:25 <CosmicRay> no problem
12:34:41 <CosmicRay> I don't mind easy questions.  It takes much more time for me to answer difficult ones ;-)
12:34:47 <dino-> CosmicRay: Yes, I see that, very important to have!
12:35:06 <dino-> CosmicRay: And btw, thank you for the hslogger. Very powerful.
12:35:11 <CosmicRay> glad you like it
12:35:26 <waern> dcoutts: I just installed ghc head and stumbled on the #2201 problem
12:36:14 <dino-> CosmicRay: One more thing, the Priority on the filehandler call, what is that setting priority on?
12:36:41 <dino-> Handler and logger priorities are independent?
12:36:42 <waern> dcoutts: can I overcome this problem by installing Cabal 1.5?
12:36:59 <dcoutts> waern: want to implement http://hackage.haskell.org/trac/hackage/ticket/311 ?
12:37:00 <lambdabot> Title: #311 (support ghc-pkg dump) - Hackage - Trac
12:37:01 <CosmicRay> dino-: correct.  there are two different points you can filter on.
12:37:11 <dino-> Ok, many thanks
12:37:22 <dcoutts> waern: only if you implement #311, which isn't that hard btw
12:37:25 <CosmicRay> dino-: the Priority on a Handler is there to facilitate things like "under no circumstances do I want a DEBUG message in syslog"
12:38:01 <CosmicRay> dino-: once a logger accepts a message, it will be handled and propogated up the chain.  A Handler doesn't stop propogation, but may ignore a given message for that specific Handler.
12:38:22 <dcoutts> waern: I've pushed some patches to cabal-install to build haddock docs and log results.
12:38:40 <waern> dcoutts: oh, how mice
12:38:41 <dcoutts> waern: but there's no command line flag yet, you'll need to change one False to True :-)
12:38:42 <waern> nice
12:38:47 <dcoutts> mm, mice
12:39:05 <dcoutts> wait! I'm a vegetarian, no mice for me
12:39:12 <humasect> be well everyone=)
12:39:29 <waern> argh, I should learn how to type
12:39:46 <dino-> CosmicRay: ok
12:40:03 <waern> stop laying on the floor with my laptop probably would make my typing better
12:40:56 <newsham> anyone here pretty familiar with ByteStrings?  I have a perf question.
12:41:11 <dcoutts> newsham: shoot
12:41:21 <Shiruka> minimum [1, 0/0, 3] could reasonably return any of the values :-)
12:41:36 <dmhouse> Shiruka: well, not 3, surely?
12:41:58 <newsham> dcoutts:  http://www.thenewsh.com/%7Enewsham/store/TestBin.hs     the first test case is very fast, the next two are much slower..  even more odd, when i get rid of the lazy->strict conversion the performance actually drops.
12:42:04 <newsham> which operation is causing this slowdown?
12:42:04 <Pete_I> if 0/0 is incomparable, it should return 1, because 1 < 3
12:42:09 <Shiruka> it depends on the order of and direction of comparison
12:42:11 <newsham> am I losing fusion with one of my ops?
12:42:19 <waern> dcoutts: what exactly do I need to do to implement 311?
12:42:27 <hml> anyone here tried ghci on acid? is it worth the trouble of installing it?
12:42:47 <dcoutts> waern: ok, see the referenced ticket, see Distribution.Simple.GHC where we call ghc-pkg describe '*'
12:42:47 <newsham> and more importantly, is there a better way to do what i'm doing without losing perf?
12:42:54 <CosmicRay> hml: at the risk of asking a highly ironic quesiton, what is acid
12:43:03 <dcoutts> waern: you need to parse this: http://hpaste.org/9230
12:43:19 <dcoutts> waern: which is easy, just split on "\n---", but preferably efficiently
12:43:19 <Shiruka> all comparisons with NaN are false, so whether you do (x < y) or (not (x >= y)), both of which are reasonable enough..
12:43:26 <waern> dcoutts: all of it? or just the package names?
12:43:28 <Toxaris> CosmicRay: ghci-on-acid is ghci + lambdabot
12:43:34 <Shiruka> +matters
12:43:36 <CosmicRay> ah
12:43:49 <dcoutts> waern: we can already parse the content, we just need to split
12:43:51 <dino-> CosmicRay: This is minor, but I notice I don't see info about rootLoggerName in the API doc for System.Log.Logger  I'm not that familiar with haddock yet, I wonder if it's because it starts with -- |  instead of {- |
12:44:00 <waern> dcoutts: ah, ok
12:44:02 <hml> Toxaris: do you use it?
12:44:18 <dino-> This is local haddock, generated by cabal when I built
12:44:27 <dcoutts> waern: so ghc-pkg describe '*' used to just concatenate the describe output, now it uses --- separators. That's the only change.
12:44:34 <newsham> dcoutts: any ideas?
12:44:42 <CosmicRay> dino-: "There is a special logger known as the root logger that sits at the top of the logger hierarchy. It is always present, and handlers attached there will be called for every message. You can use getRootLogger to get it or rootLoggerName to work with it by name. " -- http://software.complete.org/static/hslogger/doc//hslogger/System-Log-Logger.html
12:44:43 <lambdabot> Title: System.Log.Logger, http://tinyurl.com/5pxduh
12:45:00 <Toxaris> hml: nope. I was under the impression it wouldn't compile on windows when I last looked at it
12:45:01 <dcoutts> waern: that, and instead of calling "ghc-pkg describe '*'" you should call ghc-pkg dump, because describe '*' returns non-0 exit code when the db is empty.
12:45:06 <dcoutts> newsham: looking
12:45:07 <dino-> CosmicRay: I meant where things are listed with their type.
12:45:10 <waern> dino: does it have a type signature?
12:45:17 <dino-> waern: It does not
12:45:18 <CosmicRay> dino-: oh, I think that haddock may not list things that are bare variables.
12:45:19 <Toxaris> hml: and I'm quite fine with ghci + hoogle on www + lambdabot on irc
12:45:24 <CosmicRay> ah that would be the problem then.
12:45:40 <thobel> @pl \x y z -> x + y + z
12:45:41 <lambdabot> ((+) .) . (+)
12:45:41 <waern> dino: then that's the problem
12:45:44 <waern> dcoutts: ok
12:45:49 <hml> @src alone makes it very tempting to install ghci on adic
12:45:49 <lambdabot> Source not found. You type like i drive.
12:45:51 * CosmicRay commits fix
12:46:50 <waern> dino: future versions of Haddock will create docs for functions without type signatures
12:47:21 <Toxaris> haddock should just inference the types :)
12:47:34 <waern> Toxaris: yep, that's the plan
12:47:59 <dino-> waern: huh cool. I tend to use -Wall and make sure to type everything top-level
12:48:24 <Toxaris> my little project to do this as a source->source transformation failed because it is not possible without adding imports
12:49:01 <newsham> does peeking at the length of the bytestring break the fusion optimizations?
12:49:19 <dcoutts> newsham: B.cons is slow of course and gives you a bad data representation
12:49:26 <waern> Toxaris: hmm? you did that just to get documentation for functions without signature in haddock, or for some other reason?
12:49:36 <newsham> dcoutts: whats the preferred way to prepend two Word8's?
12:49:51 <Toxaris> waern: I tried it to get type signatures in my code
12:49:51 <hml> who is this chris done person? why is he suggesting that i donwload from his website rather than hackage? i.e. if he has commit access to goa, why isn't the mod committed to hackage? if not, why did his patch get rejected? and if it got rejected, why would I want to install it?
12:49:52 <dcoutts> newsham: yep, but I don't think you'd get any fusion anyway afaiks
12:50:01 <waern> Toxaris: ok
12:50:08 <Toxaris> waern: because i like to look at them, but hate to write them
12:50:18 <waern> Toxaris: because implementing it in Haddock is probably quite simple
12:50:27 <newsham> my real program sends the data over a socket and two sends is a big lose over the cons it seems.
12:50:29 <waern> Toxaris: perhaps something to implement for yi?
12:50:30 <Toxaris> waern: and my colleagues hate to read my code without type signatures
12:51:27 <chrisdone> I write my type signatures before writing my functions. always
12:51:54 <chrisdone> hml: who does this chris done think he is‽
12:52:13 <hml> chrisdone: yeah; who iks this guy?
12:52:16 <hml> lol
12:52:16 <dcoutts> newsham: so you're trying to make small messages that get sent in a single write, right?
12:52:23 <newsham> yup
12:52:26 <hml> chrisdone: are you the a dev of goa?
12:52:28 <chrisdone> hml: wasn't aware I had commit access to goa
12:52:39 <chrisdone> hml: I may be or will be a maintainer
12:52:47 <newsham> (its too bad that network-binary doesnt support writev for lazy bytestrings.. )
12:53:08 <hml> chrisdone: oh, don't know whether you had commit access to goa; was just curious why it wasn't part of main line (slightly paranoic when it comes down to running arbitrary code from the web)
12:53:11 <dcoutts> newsham: so this is tricky because you need the header in front of the payload, but calculating it depends on the data in the payload.
12:53:14 <Toxaris> hml: why should you trust hackage more or less then every other website?
12:53:19 <newsham> *nod*
12:53:30 <newsham> although in this case the only data attribute i need is length
12:53:41 <dcoutts> newsham: however you probably still want to use binary's Put and just take the hit of copying the short bytestring
12:53:43 <hml> Toxaris: atleast there's a trail of commit's;
12:53:43 <chrisdone> hml: I've just patched goa to fix a problem
12:53:59 <hml> chrisdone: is it avaliable as a patch? which version of goa did you modify?
12:54:02 <dcoutts> newsham: if you can calculate the length in advance of course then you save the copy
12:54:07 <chrisdone> hml: the one on hackage
12:54:20 <ndm> anyone has permission to upload a new hackage release
12:54:22 <chrisdone> hml: I can make a patch if you'd like
12:54:27 <ndm> although only the maintainer should...
12:54:36 <hml> ndm: waht, anyone can upload a new hackage release?
12:54:40 <newsham> only way to do that would be to break the Data.Binary abstraction.
12:54:42 <hml> ndm: there\s not a list of approved devs?
12:54:55 <Toxaris> waern: well, after I realized the import problem (not all types you need for a type signature are in scope), I'm not sure how I want the problem to be solved
12:54:56 <dcoutts> newsham: also, you're making small records right? so the encode isn't optimal for you since it allocates big buffers. You want a version with a buffer size hint.
12:55:02 <chrisdone> well, you have to request an account
12:55:15 <waern> Toxaris: perhaps just not adding the signature in that case
12:55:19 <chrisdone> let me check my status on hackage
12:55:52 <newsham> would it be possible to write an encode that leaves storage for two elements at the front that could be filled in after?
12:56:02 <newsham> (and also smaller buffers)
12:56:35 <Toxaris> waern: that seems to be highly un-intuitive. I thought about adding it as a comment
12:56:49 <Toxaris> waern: but then I have to be careful not adding another comment when the tool is run again
12:57:04 <ndm> hml: indeed
12:57:17 <Toxaris> waern: and maybe I should replace the comment with a real signature when the user added the import manually
12:58:19 <Toxaris> waern: and it is not easy to find out which types are in scope and which not. I get the missing type signature as a string from the GHC API. (actually, I get it as a string from piping stuff into ghci, but in the meantime, I found out how to get it from the GHC API, which is much nicer of course)
12:58:23 <pozic> Is there anyone who likes the Prelude?
12:58:38 <Deewiant> define "likes"
12:58:40 * ndm <3 the Prelude
12:58:46 <johnnowak> define "anyone"
12:58:50 <Deewiant> it could be better but it could also be a lot worse :-P
12:58:52 <Toxaris> waern: so in the end, it just was too complicated for a weekend project :) do you think it would be of use to people?
12:59:19 <chrisdone> hm, how are cabal version numbers worked out?
12:59:20 <pozic> I haven't done a single project that doesn't basically doesn import qualified Prelude in every module or does so via an indirection.
12:59:34 <ndm> pozic: i'ev never done that...
12:59:52 <waern> Toxaris: it would definitely be useful to people. I'd like to have something like that integrated in the editor though
13:00:38 <pozic> does*
13:01:18 <Toxaris> waern: I do not plan to start Yi hacking, but it surely could be done with both an executable and a Haskell API so that i can be integrated into Yi without calling an external executable
13:01:42 <hml> how do i tell cabal to install from a local.tar.gz?}}
13:02:05 <chrisdone> hml: in my experience, extract it, cd into and do sudo cabal install
13:02:07 <dcoutts> hml: can't at the moment. You have to unpack and cd into it.
13:02:21 <stepcut> this example from associated types with class does not work for me, class MapKey k where data Map k v, how do I do it instead ?
13:02:25 <Toxaris> waern: I will think about it and maybe invest another weekend.
13:02:27 * dcoutts wishes people would not sudo cabal install things
13:02:37 <Twey> dcoutts: Why's that?
13:03:03 <waern> Toxaris: sounds like a good plan :)
13:03:04 <dcoutts> we've got a --root-cmd=sudo
13:03:13 <chrisdone> dcoutts: why?
13:03:18 <dcoutts> I worry that sudo cabal install will pick up the wrong config
13:03:24 <dcoutts> and besides, the default works nicely
13:03:38 <Twey> Aha
13:04:03 <Twey> 'sudo make me a sandwich'
13:04:11 <hml> chrisdone: got it manually patched and installed; thanks for all your work; this mod is really really cool :-) @src has been  my favorite feature of lambdabot
13:04:20 <chrisdone> hml :)
13:04:43 <Toxaris> waern: coolest would be to call into another tool for the import modifying stuff: "make sure Foo.Bar.Baz is in scope and tell me it's local name in this module"
13:05:58 <waern> Toxaris: heh, yeah. Sounds like the beginnings of a source transformation DSL
13:06:01 <chrisdone> so goa's version is 3.0, if I want to upload my change, what is a sensible version to use?
13:06:44 <Pete_I> @src min
13:06:45 <lambdabot> min x y = if x <= y then x else y
13:07:09 <Guest61322> does anyone know of a simple exampling showing how continuations can be used to resume a computation where it left off
13:07:13 <Guest61322> example*
13:07:48 <hml> chrisdone: crap, one last obstale: what should I put isntaed of: setLambdabotHome "/var/www/chrisdone/lambdabot-personal"
13:07:51 <hml> in my ghci?
13:07:55 <hml> err , in my .ghci
13:07:56 <Toxaris> waern: statically typesafe in the sense that a well-typed DSL program will transform well-typed Haskell programs into well-typed Haskell programs (i.e., never introduce type errors during transformation).
13:07:58 <chrisdone> hml: where is your lambdabot?
13:08:02 <Toxaris> waern: *that* would be awesome
13:08:09 <hml> chrisdone: i dunno; how do i find out?
13:08:15 <hml> chrisdone: is it the dir i installed it in?
13:08:16 <chrisdone> hml: did you install it with cabal install?
13:08:18 <chrisdone> hml: yeah
13:08:36 <waern> Toxaris: wow, that would probably build up quite large types =)
13:08:43 <waern> if it is at all possible
13:08:53 <hml> chrisdone: nope, didn't use cabal insta;; going to try the dir i darcs get then
13:08:56 <chrisdone> hml: it just needs to know where the lambdabot executable you want to use is
13:09:20 <hml> GOA> :source map
13:09:20 <hml> map not available
13:09:29 <hml> okay, alteats it's hitting labmdabot
13:09:37 <hml> are tehre some doc generatiokn commands I need to run?
13:10:17 <hml> GOA> :index Monad Control.Monad, Prelude, Control.Monad.Reader,
13:10:19 <hml> so Index works
13:10:46 <hml> index and instances works; source and hoogle do not
13:11:04 <chrisdone> hml: cabal install hoogle
13:11:22 <hml> wow; i could have sworn it was installed
13:11:35 <hml> GOA> :hoogle Monad A Hoogle error occured.
13:11:40 <chrisdone> I haven't tried source; it seems to need fptools, so let me see
13:11:42 <hml> this is after installikng it
13:11:53 <MichaelGG> hey everyone, thanks for the advice i got a while back. every bit i learn is awesome
13:11:59 <MichaelGG> picked up a book on category theory too
13:12:20 <chrisdone> hml: is hoogle in your PATH? e.g. can you run hoogle in your terminal?
13:12:28 <hml> nope
13:12:31 <MichaelGG> and recommending to everyone to learn some haskell
13:12:34 <hml> okay; going to fix that
13:12:43 <chrisdone> hml: you probably need to add ~/cabal/bin to your PATH
13:13:37 <hml> chrisdone: great; Hoogle works now, (inside of GOA too)
13:13:51 <chrisdone> hml: grand. let's figure out source. it seems to require fptools
13:14:13 <hml> fptools doesn't look like a hcakge module; and i get a bunch of cvs stuff from googlj
13:14:35 <hml> noting from apt-cache search either
13:15:56 <chrisdone> anyone have any idea what fptools is?
13:16:34 <chrisdone> apparently it comes with ghc or hugs
13:16:48 <byorgey> MichaelGG: excellent =)
13:17:02 <ndm> hml: which version of Hoogle?
13:17:10 <byorgey> chrisdone++
13:17:20 <byorgey> (for getting GOA to work again =)
13:17:26 <chrisdone> hehe :)
13:17:31 <hml> ndm: how to i find out?
13:17:39 <Nafai> byorgey: How's PA?
13:17:45 <hml> ndm: 3.1
13:18:00 <byorgey> hi Nafai!
13:18:08 <ndm> hml: ok, there is a 4.0.0.3 release on hackage, if you have cabal install its as simple as cabal update && cabal install hoogle
13:18:10 <tibbe> I'm struggling trying to come up with a name for a Data.Map like function that folds over keys and values starting from a given key (i.e. skipping all keys smaller than this one). foldWithKeysFrom doesn't read as well as I would like. Any suggestions?
13:18:13 <byorgey> this corner of it is great, don't know much about the rest =)
13:18:19 <Nafai> byorgey: Cool! :)
13:19:00 <hml> src/Hoogle/Query/Render.hs:4:13: lexical error at character '\b'
13:19:01 <hml> cabal: Error: some packages failed to install:
13:19:01 <hml> hoogle-4.0.0.3 failed during the building phase. The exception was:
13:19:11 <hml> lol; not well tested?
13:20:42 <ndm> hml: i have no idea why it would do that, and i have the source code in front of me
13:20:59 <hml> ndm: do you get the same error when you execute cabal install?
13:21:04 <ndm> does anyone else get the same results? cabal update && cabal install hoogle
13:21:21 <chrisdone> I'll try it
13:21:23 <ndm> hml: i don't have the cabal install progarm on this machine, but runhaskell setup configure/build/install works fine
13:22:22 <mauke> Linking dist/build/hoogle/hoogle ...
13:22:22 <mauke> Installing: /home/mauke/usr/local/bin
13:22:23 <mauke> %
13:22:38 <hml> weird; i no longer get that error now, sorry about that
13:22:50 <ndm> must haev been some sort of corruption...
13:23:00 <Toxaris> hoogle installs fine here
13:23:28 <hml> okay, colol; how do i leverage this to get fptoosl?
13:23:32 <hml> do i need to install the latest ghc?
13:23:40 <hml> x@x:~$ ghc --version
13:23:40 <hml> The Glorious Glasgow Haskell Compilation System, version 6.8.2
13:24:18 <chrisdone> yeah, hoogle installs fine here too
13:24:51 * chrisdone secret-handshake's mmorrow 
13:25:08 <ndm> neat :)
13:25:19 * mmorrow does the fresh-prince-of-belair handshake and hopes it the right one
13:25:31 <Toxaris> even better, hoogle *works* fine
13:25:31 <chrisdone> pishh
13:25:33 <Toxaris> ndm++
13:25:35 * hml waves a big sign saying "how do I get fptools:-)"
13:25:51 <Cale> Does fptools still exist?
13:25:55 <chrisdone> hml: I don't think anyone knows what it is. kind of like spam
13:26:03 * Toxaris calls the police because of hml starting a demonstration
13:26:10 <Cale> hml: I thought that was split up into a bunch of packages on hackage...
13:26:24 <chrisdone> GOA has a line
13:26:25 <chrisdone> :def source    lambdabot "fptools"
13:26:25 <Cale> I might be wrong.
13:26:31 <chrisdone> so we're wondering what it means
13:26:45 <chrisdone> wait
13:26:47 <chrisdone> duhhh
13:26:49 <lelf`> not spam, but obsolete mostly I think http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
13:26:51 <lambdabot> Title: fptools/
13:26:55 <chrisdone> it's the source of the module
13:27:09 <chrisdone> GOA Data.List> :source Data.Map http://darcs.haskell.org/packages/base/Data/Map.hs
13:27:24 <chrisdone> you want @src
13:27:31 <chrisdone> which isn't in GOA @_@
13:27:34 <hml> yes, oh ... no
13:27:41 <hml> gah
13:27:45 <hml> okay, how do I get @src?
13:28:15 <hml> i want to be able to , in emacs, place my cursor over a fucntion name, hikt m-. and have it's source pop up
13:29:12 <hml> wait wait; lambda bot supports @src already right?
13:29:18 <lelf`> you need TAGS-file
13:29:36 <chrisdone> lelf`: where does one get that?
13:29:55 <hml> lambdabot> @src map
13:29:55 <hml> map _ []     = []
13:29:55 <hml> map f (x:xs) = f x : map f xs
13:30:01 <hml> it works fine in lambdabot; how do I get it into GOA?
13:30:04 <lelf> chrisdone: by means of hasktags
13:30:47 <hml> wow; lambdabot was written by a vim user
13:31:17 <chrisdone> it's been written by three thousand people
13:31:25 <chrisdone> more than there are haskell programmers
13:31:57 <osfameron> hml: you expected yi? ;-P
13:32:03 <hml> was just suprissed the README refers to scripts/ ... which is a bunch of vim, rather than emacs code
13:32:07 <shepheb> @quote dons.and.lambda
13:32:07 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
13:32:13 <shepheb> @quote recursively.coded
13:32:14 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
13:32:38 <Toxaris> Prelude> :def echo return . (":! echo " ++)
13:32:38 <Toxaris> Prelude> :echo test
13:32:38 <Toxaris> test
13:33:05 <Toxaris> hml: that's my template to add things to ghci
13:33:35 <hml> Toxaris: i don't understand
13:34:08 <Toxaris> hml: so if lambdabot is fast enough and supports to execute a single command, you can ignore GOA and just start a new lambdabot process everytime you want to
13:34:32 <Toxaris> hml: of course, looking into whatever you have to do it properly is much better :)
13:34:48 * Toxaris is a strong follower of the a-new-process-for-every-editor-command methodology of extending an IDE
13:35:00 <hml> yeah; i'm looking at the vim scripts ... and they all look like they're creating a new lambdabot instance every time
13:35:24 <hml> pity they can't juse write to a fifo or something
13:35:28 <hml> then i could get persistnet too
13:35:35 <hml> *persistence*
13:35:42 <osfameron> GOA?
13:35:51 <hml> was looking at lambdabot, not GOA
13:36:03 <hml> anyone want to help me hack @src from lambdabot into GOA?
13:36:23 <ski> @whatis GOA
13:36:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:37:12 <hml> wow
13:37:16 <hml> that's like a one line hack
13:37:23 <hml> :def src lambdabot "src"
13:37:24 <hml> lol
13:37:29 <hml> (in ghci)
13:37:30 <chrisdone> I was about to say :P
13:37:33 * Toxaris is looking at http://www.cse.unsw.edu.au/~dons/code/goa/GOA.hs
13:37:37 <hml> okay, time to eat; thanks everyone, especially chrisdone for all help
13:37:47 <Toxaris> and is about to propose the lambdabot function
13:37:48 <Toxaris> but too late
13:38:03 <osfameron> hmmm, ah, the .cabal file has a 1-line description: GHCi bindings to lambdabot
13:38:16 <osfameron> er
13:38:24 <osfameron> isn't lambdabot an irc binding to GHCi ?
13:38:35 <chrisdone> osfameron: http://chrisdone.com/blog/2008/08/01/ghci-on-acid-goa/
13:38:37 <lambdabot> Title: 17 Chris Done’s Blog 1b » GHCi on Acid (GOA) b
13:39:18 <osfameron> ah, cool
13:39:41 <osfameron> emacs does occasionally look tempting when you see how powerful it is for embedding/IDE use
13:39:56 <chrisdone> yeah
13:39:56 <osfameron> I never got on with the vi-alike bindings for it though
13:40:06 <chrisdone> did you try the emacs bindings?
13:40:29 <osfameron> haven't tried emacs in years
13:40:30 <jeffwheeler> The emacs bindings do tend to work quite well.
13:42:36 <maciek> can somebody explain $= to me? I don't know how to google for it :)
13:42:49 <erikc> for hopengl?
13:43:02 <maciek> yes
13:43:12 <maciek> oh, it's hopengl-specific?
13:43:16 <Zao> It's explained somewhat in the State part of the hopengl docs.
13:43:18 <erikc> yup
13:43:35 <maciek> thanks, I thought is something more general
13:43:56 <erikc> ($=) :: (HasSetter s) => s a -> a -> IO ()
13:43:57 <Zao> maciek: http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html#v%3A%24%3D
13:43:58 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.StateVar, http://tinyurl.com/2fcodm
13:44:40 <erikc> and every opengl state var has an instance for hassetter
13:44:51 <erikc> (every settable state var)
13:46:08 <maciek> thanks, I think I got it.
13:49:33 <chrisdone> mmkay, I uploaded the fixed version of GOA to hackage
14:08:39 <hackage> Uploaded to hackage: validate 0.0
14:08:39 <hackage> Uploaded to hackage: goa 3.0.1
14:10:09 <pmurias> how can i do the equivalent of returning two value from map cleanly?
14:10:46 <Botje> return a pair?
14:11:32 <pmurias> i want to merge it into a list
14:12:09 <atp> concatMap ?
14:12:30 <EvilTerran> > concatMap (\x -> [f x, g x]) [a,b,c,d,e]
14:12:30 <lambdabot>  Add a type signature
14:12:31 <atp> > concatMap (\x -> [pred x, succ x]) [3, 8, 12]
14:12:33 <lambdabot>  [2,4,7,9,11,13]
14:12:34 <EvilTerran> > concatMap (\x -> [f x, g x]) [a,b,c,d,e] :: [Expr]
14:12:35 <lambdabot>  [f a,g a,f b,g b,f c,g c,f d,g d,f e,g e]
14:13:04 <pmurias> thanks ;)
14:14:30 <ski> > do x <- [a,b,c,d,e]; [f x, g x] :: [Expr]
14:14:31 <lambdabot>  [f a,g a,f b,g b,f c,g c,f d,g d,f e,g e]
14:14:46 * Cale thought he was looking at musical notes at first there.
14:14:55 <ski> hehe :)
14:15:14 <ski> > [do,re,..]
14:15:14 <lambdabot>  Parse error at ",re,...." (column 4)
14:15:32 <pmurias> i'm just turning a list of [Named key value...] into [key,value]
14:15:51 <pmurias> btw is it possible to use list comprehension for this?
14:16:00 <ziman> > liftM2 (:) ['C', 'D', 'E'] ["mi", "maj7", "mi7b5"]
14:16:02 <lambdabot>  ["Cmi","Cmaj7","Cmi7b5","Dmi","Dmaj7","Dmi7b5","Emi","Emaj7","Emi7b5"]
14:16:07 <seliopou> anybody have experience with Thrift's haskell bindings?
14:16:10 <ski> pmurias : maybe `unzip' would be better for what you want ?
14:16:28 <ski> pmurias : for `concatMap' ? surely !
14:16:53 <ski> > [ y :: Expr | x <- [a,b,c,d,e] , y <- [f x, g x] ]
14:16:55 <lambdabot>  [f a,g a,f b,g b,f c,g c,f d,g d,f e,g e]
14:16:56 <Botje> pmurias: [ x | Named k v <- list, x <- [k,v ] ]
14:16:58 <drigz> pmurias: [x | (Named k v) <- list, x <- [k,v]] but it's not pretty
14:17:13 <ski> @type unzip
14:17:13 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:17:20 <ski> @type mapAndUnzip
14:17:20 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:17:48 <ski> hmm
14:18:05 <ski> @hoogle (a -> (b,c)) -> [a] -> ([b],[c])
14:18:05 <lambdabot> No matches, try a more general search
14:18:12 <ski> @hoogle mapAndUnzip
14:18:12 <lambdabot> Control.Monad.mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
14:18:40 <ski> there's no plain `mapAndUnzip' ?
14:18:54 <sm> g'day all
14:19:28 <sm> dons: I notice http://haskell.org/haskellwiki/Lambdabot links to another home page, but that redirects back to the wiki
14:19:29 <lambdabot> Title: Lambdabot - HaskellWiki
14:19:38 <ski> pmurias : anyway, you might try `unzip (map (\(Named k v) -> (k,v)) myNamedList)'
14:20:17 <sm> I see lambdabot advertises "darcs patch tracking", which sounds like just the thing for #darcs. I've never seen it used here or anywhere else, anyone used it ?
14:20:29 <drigz> @type uncurry (++) . unzip
14:20:29 <lambdabot> forall b. [(b, b)] -> [b]
14:20:49 <drigz> wrong order, though
14:22:44 <gwern> man, why is ghc head always broken for me?
14:23:08 <gwern> I don't even know what this error is
14:23:28 <gwern> http://hpaste.org/9414 make[2]: *** No rule to make target `with-bootstrapping-compiler'.  Stop.
14:23:43 <Zao> Updating an existing tree or building from a clean one?
14:23:57 <Igloo> gwern: Are all your repos up-to-date?
14:25:16 <gwern> I just did a darcs-all pull of everything and the ghc itself
14:25:18 <gwern> also a autoreconf
14:25:45 <dainanaki> did you do a make distclean before building?
14:26:01 <gwern> no
14:26:16 <gwern> 'make -C hsc2hs clean
14:26:17 <gwern> make[2]: *** No rule to make target `clean'.  Stop.'
14:26:34 <sm> talk to me lambdabot. help
14:26:36 * gwern runs ./darcs-all check. I no longer trust these repos
14:27:17 <sm> dons: and should I try to set up a new lambdabot, or does the one here handle multiple channels ?
14:27:27 <ndm> @seen lambdabot
14:27:27 <lambdabot> Yes, I'm here. I'm in #japanese, #macosx, #arch-haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.cz, #haskell.dut, #haskell.de, #
14:27:27 <lambdabot> haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #
14:27:27 <lambdabot> unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
14:27:31 <sm> ahaa
14:27:35 <ndm> sm: it handles multiple channels :)
14:27:45 <gwern> @join #darcs
14:27:45 <lambdabot> Not enough privileges
14:27:52 <sm> how can I get it to tell us about darcs checkins ? :)
14:28:09 <gwern> sm: I have no idea what that could be referring to
14:28:37 <sm> I've been blathering about it here and on #darcs
14:28:44 <ndm> Hoogle web version 4.0: http://haskell.org/hoogle/beta/
14:28:44 <lambdabot> Title: - Hoogle
14:28:54 <sm> notify #darcs when the main repo has a patch applied
14:29:01 <sm> (as a start)
14:29:01 <ndm> doesn't yet have accurate links to results, or inline haddocks
14:29:20 <gwern> Plugin/DarcsPatchWatch.hs seems promising
14:29:23 <ndm> and the function list isn't perfect, but the searching is pretty much done
14:29:30 <ndm> if anyone has any comments?
14:29:50 <rwbarton> ndm: Is it going to remain in beta for the next 5 years? :)
14:29:54 <gwern> hm. DarcsPatchWatch is not imported anywhere, sm
14:30:07 <sm> interesting
14:30:09 <gwern> sm: also, 'announceTarget = Nick { nTag  = "freenode", nName = "#lazybottoms-dev"
14:30:18 <gwern> sm: my guess? long since bitrotted
14:30:29 <sm> ok, thanks
14:30:35 <ndm> rwbarton: no! it will get a release in a few weeks :)
14:30:52 <sm> I'm waiting for the repo to finish downloading so I can figure out who to ask about it
14:31:08 <ndm> it does everything, it just doesn't have a good enough function list, which is kind of outside Hoogle, but still necessary
14:31:33 <gwern> sm: well, uh, there aren't a whole lot of lambdabot maintainers. just occasional hackers
14:31:49 <gwern> sm: but patchwatch is credited to Stefan Wehr
14:31:53 <gwern> ask him maybe?
14:32:13 <misterbeebee> I can't get lambdabot+goa working on my Mac: I can't update/reinstall lambdabot:
14:32:14 <misterbeebee> wednet% ls -l `which ghc`
14:32:14 <misterbeebee> lrwxr-xr-x  1 root  wheel  62 Jun 26 22:27 /usr/bin/ghc -> /Library/Frameworks/GHC.framework/Versions/Current/usr/bin/ghc
14:32:15 <misterbeebee> wednet% cabal install lambdabot
14:32:15 <misterbeebee> Resolving dependencies...
14:32:15 <misterbeebee> cabal: cannot configure plugins-1.2. It requires ghc >=6.8
14:32:17 <misterbeebee> There is no available version of ghc that satisfies >=6.8
14:32:19 <misterbeebee> wednet% ghc --version
14:32:21 <misterbeebee> The Glorious Glasgow Haskell Compilation System, version 6.8.3
14:32:22 <sm> thanks
14:32:23 <misterbeebee> wednet%
14:32:27 <sm> lambdabot repo seems pretty active
14:32:32 <misterbeebee> and goa hangs:
14:32:39 <misterbeebee> Loading package goa-3.0.1 ... linking ... done.
14:32:39 <misterbeebee> GOA> :bs
14:32:40 <misterbeebee> (^c kills it)
14:32:48 <misterbeebee> (sorry for the multi-line)
14:33:18 <gwern> misterbeebee: you want to get lambdabot from darcs, I assure you
14:33:31 <gwern> misterbeebee: are you following chrisdone's GOA guide? you'll want to use his repos
14:33:59 <dainanaki> the GOA setup is pretty sweet
14:34:02 <dainanaki> i must say
14:34:15 <misterbeebee> yeah, i am. I have an old lambdabot installed, but I can't prove where it came form anymore...
14:35:01 <jason> is anyone using Facebook's Thrift library with Haskell?
14:35:26 <misterbeebee> I'll try rebuilding lambdabot from darcs, thanks
14:35:30 <MarcWeber> dons: Is there already a patch for hs-plugins about ModuleName ?
14:35:40 <MarcWeber> @seen dons
14:35:40 <lambdabot> dons is in #haskell, #ghc, #xmonad and #arch-haskell. I don't know when dons last spoke.
14:35:48 <gwern> jason: I've never heard of anything to do with thrift
14:35:50 <gwern> preflex: seen dons
14:35:50 <preflex>  dons was last seen on #haskell 14 hours, 1 minute and 21 seconds ago, saying: thanks everyone for your input. go interwebs!
14:36:14 <jeffwheeler> preflex?
14:36:28 <jeffwheeler> I thought the only bots were hackage and lambdabot.
14:36:45 <gwern> sm: if you're going to update watchpatches, keep in mind it will not work as-is with darcs 2
14:36:48 <MarcWeber> *lol*.. That's why we've hit 500 users :)
14:37:04 <gwern> jeffwheeler: no, mauke runs preflex, in part to make up for lambdabot's deficiencies
14:37:09 <gwern> jeffwheeler: also, sometimes there's hpaste
14:37:18 <sm> gotcha
14:37:24 <jeffwheeler> gwern: mmk
14:37:34 <sm> I had in mind just finding a bot that would watch an rss feed
14:37:51 <sm> this one probably needs to run on the repo host and so may not work here
14:38:25 <EvilTerran> we could use a more pluggable version of lambdabot on a more stable server
14:38:37 <EvilTerran> so all the functionality could be in one bot
14:38:38 <gwern> sm: well, if you just want rss, that's easy. that's basically how hpaste and hackage bots work
14:39:35 <gwern> EvilTerran: patches welcomed, as the saying goes
14:39:47 <RayNbow> http://www.reddit.com/r/programming/comments/6uyox/twodimensional_zip/c04xw0w <-- where are zipWithU, etc., defined? Hoogle and Hayoo can't find them.
14:39:48 <lambdabot> Title: dons comments on Two-dimensional zip, http://tinyurl.com/5f28bh
14:39:53 <EvilTerran> i can't help but feel it'd be more of a ground-up rewrite, i'm afraid
14:40:00 <EvilTerran> ?vixen sorry about that
14:40:00 <lambdabot> don't worry about it
14:41:12 <MarcWeber> Has anyone compiled hs-plugins with recent cabal and ghc ?
14:41:53 <gwern> RayNbow: that's a good question. I see exactly one grep hit: libraries/base/GHC/Float.lhs:            print (sumU (zipWithU (*) c a))
14:42:37 <hml> i run emacs in a terminal; what's so important about this font-locking in the emacs haskell mode?
14:42:47 <drigz> i guess the U stands for unboxed, so it's probably not implemented in haskell? at a guess?
14:43:52 <gwern> but it'd still need to be named somerehwer - if it was an FFI binding, you'd still see a second hit for 'foreign import stufff zipWithU', you know
14:43:57 <gwern> odd
14:44:31 <lelf`> RayNbow: Data.Array.Parallel.Unlifted from ndp?
14:44:39 <drigz> gwern: did you grep the GHC source?
14:44:51 <MarcWeber> drigz: I did . No match @ RayNbow
14:45:48 <gwern> drigz: yes
14:45:57 <misterbeebee> hmm, lambdabot from darcs doesn't build so well:
14:45:57 <drigz> wow
14:45:59 <misterbeebee> % sudo ./build
14:45:59 <misterbeebee> unrecognized option `--global'
14:45:59 <misterbeebee> More specifically:
14:45:59 <misterbeebee> wednet% cabal --global
14:46:00 <misterbeebee> unrecognized option `--global'
14:46:07 <gwern> lelf`: I think it must be from the ndp stuff, since I don't have that
14:46:07 <Cale> You have the wrong cabal
14:46:12 <misterbeebee> I figured so much
14:46:14 <gwern> misterbeebee: you should be going through cabal maybe?
14:46:19 <misterbeebee> trying to figure out which is the right one
14:46:27 <dcoutts> misterbeebee: --global is not a option at the top level
14:46:34 <Cale> I'm using the cabal that comes with ghc-6.8.3 and the cabal-install that's available on hackage
14:46:39 <elliottt> chrisdone: ping?
14:46:45 <Cale> dcoutts: It isn't?
14:46:47 <dcoutts> misterbeebee: it's an option to the 'install' sub-command
14:46:58 <Cale> dcoutts: I regularly write  cabal --global install ...
14:47:22 <misterbeebee> oh, the lambdabot build script has 'cabal --global install'
14:47:30 <dcoutts> Cale: does it work?
14:47:31 <misterbeebee> but 'cabal install --global' looks more promising
14:47:32 <Botje> aaauw
14:47:34 <Botje> I HAS THE DUMB TODAY
14:47:34 <Cale> dcoutts: yes
14:47:35 <misterbeebee> no, it does not work
14:47:48 <RayNbow> gwern: which version of GHC?
14:47:55 <Botje> > foldr f x [a,b,c,d] ::Expr
14:47:56 <lambdabot>  f a (f b (f c (f d x)))
14:47:57 <misterbeebee> i'm trying again with the arguments switched...
14:47:59 <dcoutts> Cale: perhaps you've got an ancient cabal-install, what version ooi?
14:48:02 <Cale> dcoutts: How do I tell which version of cabal-install I have?
14:48:09 <Cale> cabal -v doesn't work
14:48:12 <dcoutts> Cale: cabal --version
14:48:13 <RayNbow> my libraries/base/GHC/Float.lhs doesn't contain "print (sumU (zipWithU (*) c a))"
14:48:14 <Botje> > foldl f x [a,b,c,d] ::Expr
14:48:15 <lambdabot>  f (f (f (f x a) b) c) d
14:48:21 <Cale> Unrecognized options:
14:48:21 <Cale> --version
14:48:22 <dcoutts> Cale: and if that doesn't, then it's really really old :-)
14:48:24 <RayNbow> (6.8.2 source)
14:48:27 <misterbeebee> Here's mine:
14:48:27 <misterbeebee> wednet% cabal --version
14:48:27 <misterbeebee> cabal-install version 0.5.1
14:48:28 <misterbeebee> using version 1.4.0.1 of the Cabal library
14:48:57 <dcoutts> Cale: it'll be 0.4.0 or something
14:49:09 <Cale> That sounds about right
14:49:32 <Cale> ah, yes, I have a download of 0.4.0 here.
14:49:39 <misterbeebee> ok, when I flip '--global' and instal, lamabdabot (from darcs) build script gets further, then dies
14:49:43 <Cale> So that's what I'm using :)
14:49:44 <misterbeebee> cabal: cannot configure plugins-1.2. It requires ghc >=6.8
14:49:55 <gwern> RayNbow: my repo? HEAD
14:49:56 <misterbeebee> which is the same error that 'cabal install lambdabot' gave earlier
14:49:59 <Cale> misterbeebee: Do you not have ghc >= 6.8?
14:50:01 <misterbeebee> the reasons for which should be obvious :)
14:50:05 <dcoutts> misterbeebee: ghc-pkg list ghc
14:50:06 <misterbeebee> if course I do
14:50:16 <misterbeebee> wednet% ghc-pkg list ghc
14:50:16 <misterbeebee>     {ghc-6.8.3}
14:50:21 <misterbeebee> uh, did i hide it?
14:50:49 <dcoutts> misterbeebee: no, it's broken. use ghc-pkg check
14:51:31 <misterbeebee> aha package ghc-6.8.3 has missing dependencies:
14:51:31 <misterbeebee>     bytestring-0.9.0.1.1
14:51:49 <dcoutts> misterbeebee: right, you should not have unregistered bytestring-0.9.0.1.1
14:51:49 <misterbeebee> I went to far fiddlign with package versions when i went hackage-happy one day
14:52:32 <misterbeebee> I have 0.9.1.0 registered
14:52:51 <dcoutts> misterbeebee: that doesn't help
14:53:10 <misterbeebee> I'm trying to figure how to get 0.9.1.1 registered
14:53:17 <misterbeebee> cabal upgrade bytestring didn't help
14:53:18 * gwern gives up and blows away my ghc repo
14:53:35 <Cale> Upgrading the bytestring package is unfortunately not so advisable, since things which rely on the ghc package have to have a compatible version of bytestring.
14:53:58 <misterbeebee> i think i might have tried to upgrade in the past, and then gotten myself into a mess.
14:53:59 <dcoutts> misterbeebee: you'll be lucky if it works, it'd have to produce the exact same abi.
14:54:20 <misterbeebee> so now i've got a mixture of 0.9.1.1 and 0.9.1.0-desiring packags
14:54:25 <dcoutts> misterbeebee: tip: don't unregister the packages that come with ghc itself
14:54:35 <misterbeebee> (How's that JVM port coming along? :-/ )
14:56:17 <Cale> dcoutts: hmm, in the newer version of Cabal, will the --global option apply to dependencies that are installed as a result of installing the given package as well?
14:56:39 <Cale> dcoutts: Because the behaviour where dependency chasing goes and installs things as user is really annoying :)
14:57:02 <dcoutts> Cale: --global or --user apply to all the things that are installed in that go
14:57:17 <dcoutts> Cale: and if you always want global then set in the config file
14:57:58 <dcoutts> Cale: btw, what's wrong with installing as user?
14:58:31 <Cale> dcoutts: hs-plugins can't seem to find things when they're installed as user for some reason.
14:59:29 <dcoutts> Cale: hmm, I've not heard of that before, but otoh, it doesn't surprise me too much, hs-plugins isn't very well behaved. Perhaps it's using hard coded paths?
14:59:43 <Cale> I don't know.
15:00:08 <dcoutts> Cale: anything that uses the module that Cabal provides is able to find it's data files wherever the user chooses to install the package.
15:00:12 <Cale> Heh, version 0.4.0 of cabal-install ignores the --global flag when you put it after install
15:00:33 <dcoutts> Cale: yeah, that was one of the first things I rewrote, the command line handling was a mess.
15:00:56 <dcoutts> the new one has bash command line completion :-)
15:00:59 <dcoutts> very handy
15:01:22 <Cale> nice :)
15:02:30 <misterbeebee> i installed bytestring-0.9.0.1 , but that didn't satisfy 'ghc-pkg check', many packages are looking for 0.9.0.1.1, but 0.9.0.1.1. isn't on Hackage
15:02:43 <misterbeebee> (5 sig figs in teh version number is lovely, btw)
15:03:24 <Cale> bytestring-0.9.0.1.1 should come with ghc-6.8.3
15:03:42 <misterbeebee> so did i lose it and need to reinstall ghc?
15:04:13 <Cale> Well, that would be one way to get it back. I'm surprised nobody uploaded it to hackage.
15:04:15 <misterbeebee> i do have the library in my installation....
15:04:26 <misterbeebee> just need to confing ghc-pkg to see it
15:04:33 <misterbeebee> ./lib/ghc-6.8.3/lib/bytestring-0.9.0.1.1 -- does exist
15:04:55 <dcoutts> misterbeebee: it's because you unregistered it, but did not delete the files
15:05:17 <dcoutts> misterbeebee: if you've got the original package.conf then you can restore the config
15:05:31 <misterbeebee> dcoutts: ok i see, i'll look for it
15:05:31 <dcoutts> eg the debian packages keep a saved copy
15:08:23 <misterbeebee> i have the Mac bundle, and no package.conf.
15:08:40 <hackage> Uploaded to hackage: kibro 0.0
15:08:42 <misterbeebee> is package.conf same or different format from bytetring.cabal, as in: ( http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/bytestring.cabal)
15:08:43 <lambdabot> http://tinyurl.com/6l7xf9
15:09:22 <dcoutts> misterbeebee: no
15:09:29 <misterbeebee> alas.
15:09:54 <dcoutts> misterbeebee: you may need to reinstall your ghc, or at least grab the package.conf from the package you got ghc from.
15:12:13 <misterbeebee> hmm...
15:12:13 <misterbeebee> wednet% pwd
15:12:14 <misterbeebee> wednet% ghc-pkg register package.conf
15:12:14 <misterbeebee> Reading package info from "package.conf" ... ghc-pkg: 1: unexpected span: ","
15:12:18 <misterbeebee> maybe reinstall time
15:12:51 <misterbeebee>  (pwd output was: /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3
15:12:52 <misterbeebee> )
15:15:37 <lelf> register package.conf? Ough
15:16:18 <misterbeebee> oh 'ghc-pkg register bytestring.cabal' looks more promising
15:16:35 <misterbeebee> ..maybe
15:16:36 <dcoutts> misterbeebee: no!
15:16:39 <misterbeebee> (confused)
15:16:46 <dcoutts> they're not the same format
15:16:49 <misterbeebee> well, neither attempt works
15:16:58 <misterbeebee> i see they are different format
15:17:24 <misterbeebee> that was a shot in the dark by me.
15:17:36 <misterbeebee> but my package.conf file is not satisfying ghc-pkg
15:18:27 <dcoutts> misterbeebee: re-install ghc
15:18:36 <misterbeebee> dcoutts: yes. i will :(
15:21:31 <misterbeebee> reinstalling fixed my bytestring dependency problem, thank you. trying to build lambdabot again
15:22:56 <misterbeebee> seems to be moving along now....
15:27:37 --- mode: irc.freenode.net set +o ChanServ
15:28:35 <misterbeebee> arg, still have a mismatch somewhere:
15:28:36 <misterbeebee>     Couldn't match expected type `bytestring-0.9.1.0:Data.ByteString.Lazy.Internal.ByteString'
15:28:36 <misterbeebee>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
15:33:09 <mmorrow> > typeOf 9
15:33:10 <lambdabot>  Integer
15:33:15 <Guest61322> is there an infinite number in the prelude or do you have to do something like: Number = Infinity | Number { x :: Integer }
15:33:23 <mmorrow> > Node () []
15:33:24 <lambdabot>  Node {rootLabel = (), subForest = []}
15:33:28 <mmorrow> > let toTree a = let go t = Node (typeRepTyCon t) (fmap go . typeRepArgs $ t) in go (typeOf a) in toTree $ ([Just (42,"adsf",())],[((),0)])
15:33:29 <lambdabot>  Node {rootLabel = ,, subForest = [Node {rootLabel = [], subForest = [Node {r...
15:33:44 <ski> > 1/0.0
15:33:45 <lambdabot>  Infinity
15:34:09 <ski> that's for `Float'/`Double'
15:34:27 * Baughn has had a revelation, and is in the process of rewriting the pastafarian testament according to Greater Flour Theory
15:34:44 <ski> what is the greater flour theory ?
15:34:48 <mmorrow> it's interesting/enlightening to do that above toTree and then prettyprint
15:34:49 <mmorrow> putStr . drawTree . fmap show . toTree
15:35:03 <mmorrow> i can't stop doing it
15:35:37 <Baughn> ski: Glad you asked. You see.. just as mundane pasta is born from ingredients such as flour, so did the Noodly One actually condense from part of a sentient, cosmic cloud of flour
15:35:38 <jeffwheeler> ski: Google "flying spaghetti monster", if you don't know about that part
15:36:05 <ski> jeffwheeler : i've indeed heard about FSMism .. but not this "Greater Flour Theory"
15:36:11 <mmorrow> Baughn: heathen!!
15:36:13 <jeffwheeler> ski: ah, wasn't sure
15:36:27 <Baughn> ski: As such, His Noodliness is actually the messiah, not god himself, and will be cooked yet reconstituted three days after feeding the world
15:37:13 <ski> hm. what you say seems sensible
15:37:18 <mauke> is "messiah" a reference to olive oil?
15:37:24 <Baughn> yes
15:37:24 <ski> let us cook and eat
15:37:39 <mmorrow> delicious!
15:38:13 * ski wonders what's up with ChanServ ..
15:38:15 --- mode: irc.freenode.net set +o ChanServ
15:38:42 <jeffwheeler> I really want to try to challenge somebody with FSM sometime.
15:38:49 <jeffwheeler> s/with/using/
15:38:52 <Baughn> mmorrow: Also, technically I'd be a heretic, not a heathen
15:39:51 <mmorrow> Baughn: that too!
15:40:06 <Baughn> jeffwheeler: I tried that. Fundamentally, it doesn't work; if someone's operating on rules that state firstmost that you should never accept other ideas, they never will.
15:40:20 <Baughn> jeffwheeler: Well, I suppose jailbreaking is fun, just not very productive
15:40:23 * mmorrow takes a rest, all these exclamatory statements have worn him out
15:40:49 <jeffwheeler> Baughn: that rule does make it difficult, you're right; impossible? I'm not sure.
15:41:06 <jeffwheeler> Baughn: they accepted that rule in the first place.
15:42:09 <Baughn> jeffwheeler: Think of it as jailbreaking a locked device. Yes, they accepted a program to begin with; no, you can't really /replace/ it without either finding flaws, or using attack methods software can't defend against (like.. physically... brainwashing might work. Un-brainwashing?)
15:42:49 <Baughn> Once you've used your abilities to rewrite your own software to build software that /doesn't let you/ rewrite it, you're kinda screwed. ;_;
15:44:12 <Baughn> (Well, possibly. I suppose I'm that way with science.. I don't consider that a great loss, but my parents do. *sigh*)
15:45:34 <jeffwheeler> Baughn: I think your jailbreaking analogy works well. If just FSM were slightly more similar to Ziphone, we'd be perfect.
15:48:16 <hml> what's a good tutorial for haskell pattern guards?
15:48:23 <misterbeebee> So  I blew away my ~/.cabal and ~/.ghc and reinstalled GHC 3 and now I'm installing libs again... (With cabal), How do I avoid corrupting my ghc again? Should I be afraid of upgrading any package, for fear its older version is needed by some other package?
15:48:48 <dcoutts> misterbeebee: don't unregister packages that come with ghc
15:49:01 <dcoutts> misterbeebee: installing new versions is always ok
15:49:05 <misterbeebee> OK
15:49:10 <Baughn> misterbeebee: Install packages in ~/.ghc, so you don't have to blow away your entire installation if something goes wrong
15:49:15 <dcoutts> but you have to be careful with unregistering old ones
15:49:22 <Baughn> Oh, and you should basically never have to remove ~/.cabal
15:49:39 <dcoutts> misterbeebee: yes, what Baughn says
15:50:03 <Baughn> It contains.. packages, mostly. Tarballs. No compiled code
15:50:13 <sm> how come ghc-pkg list shows {ghc-6.8.2}, even after I do ghc-pkg expose ghc ?
15:50:14 <misterbeebee> I'll keep that in mind,   but I have a knack for getting myself in trouble, when i sink to desperation, I triy copying and tweaking and files to try to force them. I should quit that habit.
15:50:17 <dcoutts> misterbeebee: in other words, the default thing that cabal does is ok, ie --user installs.
15:51:12 * sm is trying to build lambdabot and getting "no available version of ghc that satisfies >=6.8"
15:51:28 <misterbeebee> sm: see my conversaion from 1 hour ago in the logs :)
15:51:35 <sm> thanks
15:52:04 <sm> nice :)
15:52:55 <misterbeebee> i think the interesting bit started here:
15:52:56 <misterbeebee> [2:50pm] misterbeebee: wednet% ghc-pkg list ghc
15:52:56 <misterbeebee> [2:50pm] misterbeebee:     {ghc-6.8.3}
15:52:56 <misterbeebee> [2:50pm] misterbeebee: uh, did i hide it?
15:52:56 <misterbeebee> [2:50pm] dcoutts: misterbeebee: no, it's broken. use ghc-pkg check
15:55:39 <randomity> @pf \funcs -> zipWith ($) (map foldl1 funcs) . repeat
15:55:39 <lambdabot> Maybe you meant: bf pl
15:55:43 <randomity> @pl \funcs -> zipWith ($) (map foldl1 funcs) . repeat
15:55:44 <lambdabot> (. repeat) . zipWith id . map foldl1
15:56:07 <sm> yes.. ouch
15:56:21 <sm> I must have got rid of Cabal-1.2-3.0 at some point
15:58:42 <sm> aha.. a quick cabal install Cabal-1.2.3.0 was enough to fix ghc-pkg check and expose ghc
15:58:58 <dcoutts> sm: that may or may not work
15:59:04 <dcoutts> it might not be binary compatible
15:59:15 <sm> lambdabot's setup is still complaining that ghc is missing though
15:59:40 <bwr> hi... i am trying to beat a ruby golf item in haskell... anyone want to help? i already have it working
16:00:00 <sm> ok.. looks like a ghc upgrade if I want to play with lambdabot
16:00:04 <Twey> :t foldl1
16:00:05 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:00:07 <Twey> bwr: If I can
16:00:15 <bwr> cool
16:00:24 <bwr> here is the ruby: ruby -le '32.times{|y|print" "*(32-y),(0..y).map{|x|~y&x>0?" .":" A"}}'
16:00:50 <bwr> here is what i have in haskell... ghci (with Data.Bits)  putStr$unlines[ [' '|x<-[0.. 32-y]]++concat[if (complement y).&.x>0 then " ." else " A"|x<-[0..y]] |y<-[0..31]]
16:00:53 <drigz> bwr: can we have the problem statement? it might be easier to understand :p
16:00:58 <bwr> sure
16:01:03 <bwr> http://gilesbowkett.blogspot.com/2008/04/ruby-golf-ascii-sierpinski-triangle.html
16:01:03 <lambdabot> Title: Giles Bowkett: Ruby Golf: ASCII Sierpinski Triangle, http://tinyurl.com/5uhb4d
16:04:46 <drigz> i think you can change [0.. 32-y] to [y..32]
16:05:07 <misterbeebee> next time someone like chrisdone writes an enticing blog post, he should also announce followup workshop hours :)
16:05:20 <bwr> drigz: cool... i will try it
16:05:38 <bwr> yea, that seems to work
16:05:46 <sm> cool.. I skipped the failing setup and got lambdabot proper built
16:08:24 <drigz> bwr: i think you can lose one character with the transformation concat[zs|x<-xs] => [z|z<-zs,x<-xs] but syntax might get in the way
16:08:44 <hml> in emacs haksell mode, is there a way to have c-c c-t NOT ask me to hit enter? i'm asking it for type info, i have it over a keyword .. for some reason, emacs wants me to hit enter to verifvy that i'm over the word i want the type for ... rather than just give me the info direc5tly
16:08:51 <hml> how can i have it not ask me to hit enter?
16:09:35 <bwr> i found there are lots of spaces you don't need
16:10:27 <misterbeebee> argh, I got lambdabot to install from darcs using my new ghc plus some cabal packages, and installed goa from cabal, but in ghci, the lambdabot commands still hang:
16:10:28 <misterbeebee> GOA> :source map
16:10:28 <misterbeebee> ^CUnable to run lambdabot: exception :: GhcException
16:10:28 <misterbeebee> GOA>
16:11:54 <bwr> here is what i have now
16:11:56 <bwr> putStr$unlines[[' '|x<-[y..32]]++[z|x<-[0..y],z<-if(complement y).&.x>0then" ."else" A"]|y<-[0..31]]
16:13:58 <Twey> Cripes
16:14:56 <adu> i need help
16:15:09 <drigz> adu: ask away
16:15:49 <adu> map dConv fields :: [VarStrictType] but I want [Q VarStrictType]
16:16:25 <adu> i'm thinking its as simple as return or mapM, i'm just not thinking straight
16:16:35 <mauke> map return
16:16:46 <adu> lol
16:16:49 <adu> thanks
16:16:52 <Twey> Heh
16:17:02 <mauke> bwr: perl -le 'for$y(0..31){print$"x(32-$y),map~$y&$_?" .":" A",0..$y}'
16:17:41 <edwardk> IORef's are not an instance of Ord so that GHC can move them around in memory right?
16:18:25 <edwardk> i presume it resolves equality by chasing the reference to get its current position in the gc even if it gets moved? but that Ord would break because relative position can flipflop across collections?
16:18:51 <bwr> mauke: nice
16:21:56 <dcoutts> edwardk: I believe so.
16:22:05 <edwardk> dcoutts: ok, drat
16:23:15 <edwardk> using iorefs as tags in a test grin/stg bastard-child, but can't use Ord to move them around, maybe i should switch to Static or something
16:24:11 <BMeph> s/[' '|x<-[y..32]/[y..32]>>" "/ --three fewer chars
16:25:41 <edwardk> gah even stableptr isn't Ord
16:25:43 <bwr> oh wow
16:25:47 <bwr> i didn't know you could do that
16:26:05 <mmorrow> does anyone know how you get links to the haddock docs to appear in a package that's uploaded to hackage?
16:26:11 <drigz> complement y => xor x y
16:26:35 <mmorrow> (the links to the docs which appear on it's hackage project page)
16:26:55 <bwr> drigz: are you sure about that?
16:27:40 <drigz> bwr: i think so, but i'm ready to be corrected
16:27:51 <drigz> i think you can assume x[i] is set because of the .&.
16:28:11 <drigz> so it will invert y[i]
16:28:18 <drigz> and if x[i] is unset, it will be zero whatever
16:28:53 <edwardk> hrmm that appears to be a gap in the api, because Ptr is an instance of Ord.
16:28:57 <bwr> could we check this with quickcheck? :D
16:29:16 <bwr> i've never used it before
16:29:18 <drigz> well, since the code takes no arguments, you only need one test case
16:29:20 <mauke> @check (==)
16:29:21 <lambdabot>   Not in scope: `myquickcheck''
16:29:26 <drigz> and i tested that case :D
16:29:33 <bwr> cool
16:30:03 <bwr> yup it works, thanks
16:30:14 <ski> edwardk : istr on the new monads page on the wiki there was a variant of `ST' with ordered references (basically kept a creation count inside them, afaiu)
16:30:31 <drigz> you want to get rid of the if then else somehow, but i can't see how
16:30:43 <drigz> i tried with chr and signum but it just ends up longer
16:30:51 <bwr> so i have now.. mapM_(\y->putStrLn$([y..32]>>" ")++[z|x<-[0..y],z<-if(x`xor`y).&.x>0then" ."else" A"])[0..31]
16:31:14 <bwr> yea... i can't think of any way to get out of using if
16:31:14 <edwardk> instance Ord (StablePtr a) where a <= b = castStablePtrToPtr a <= castStablePtrToPtr b
16:31:29 <edwardk> surprised its not baked in though
16:31:52 <ski> edwardk : not sure which would be preferred ..
16:32:15 <mauke> >0 can be replaced by /=0 except that's longer
16:32:26 <edwardk> in this case they are write once because they represent the tag info table in the STG
16:32:35 <edwardk> so stable is probably the correct answer here
16:32:40 <drigz> @pl\y->putStrLn$([y..32]>>"  ")++[z|x<-[0..y],z<-if(x`xor`y).&.x>0then" ."else" A"]
16:32:40 <lambdabot> Unknown command, try @list
16:32:47 <drigz> @pl \y->putStrLn$([y..32]>>"  ")++[z|x<-[0..y],z<-if(x`xor`y).&.x>0then" ."else" A"]
16:32:48 <lambdabot> putStrLn . ap ((++) . (>> "  ") . flip enumFromTo 32) (ap ((:) . ((z | x) <-) . enumFromTo 0) (return . (z <-) . flip (flip if' " ." . (> 0) . (.&. x) . (x `xor`)) " A"))
16:32:55 <drigz> not quite shorter :p
16:32:58 <bwr> haha
16:33:16 <mauke> @. pl undo  \y->putStrLn$([y..32]>>"  ")++[z|x<-[0..y],z<-if(x`xor`y).&.x>0then" ."else" A"]
16:33:16 <lambdabot> (line 1, column 83):
16:33:16 <lambdabot> unexpected reserved word "if"
16:33:16 <lambdabot> expecting variable, "(", operator or ")"
16:33:31 <ski> `more pointless' not equal to `shorter'
16:34:32 <chrisdone> I puked a little
16:35:07 <CosmicRay> mauke: wow that looks... perlish.
16:35:19 <CosmicRay> a lot of punctuation.  different punctuation, but still.
16:36:23 <bwr> is there no short if in haskell
16:36:37 <chrisdone> not standard
16:36:41 <bwr> ah
16:37:04 <chrisdone> you mean a function :: Bool -> a -> a -> a?
16:37:40 <bwr> chrisdone: yea i think
16:37:52 <chrisdone> that is usually called if'
16:38:20 <bwr> right but it isn't worth it if i need to define it
16:38:30 <osfameron> er
16:38:41 <chrisdone> bwr: indeed :/
16:39:37 <osfameron> defining the language you want to write in is quite worthwhile..
16:40:17 <chrisdone> it should be in Data.Bool imho
16:43:05 <edwardk> @pl \p f a b -> p (f a) (f b)
16:43:05 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:43:10 <edwardk> oh yeah no 'on'
16:50:07 <drigz> bwr: you can remove the parens around the xor
16:51:36 <drigz> you can use [" A"," ."]!!signum(x`xor`y.&.x) for the same length but it looks much cooler :D
16:52:24 <Twey> Haha, nice.
16:52:58 <bwr> haha awesome
16:55:40 <drigz> mapM_(\y->putStrLn$[z|x<-[y-33..y],z<-[" "," A"," ."]!!(signum(x`xor`y.&.x)+1)])[0..31]
16:55:48 <drigz> i like this one :D
16:56:11 <drigz> it's probably architecture dependent
16:56:31 <bwr> that is getting pretty short :D
16:57:51 <bwr> that's pretty crazy
17:00:30 <drigz> 3 more down:
17:00:33 <drigz> mapM_(\y->putStrLn$do{x<-[y-33..y];[" "," A"," ."]!!(signum(x`xor`y.&.x)+1)})[0..31]
17:01:25 <bwr> lol i don't know how that works
17:01:43 <drigz> which one? the signum optimisation or the do optimisation?
17:01:47 <bwr> do
17:01:50 <drigz> it uses the List monad
17:01:54 <bwr> oh
17:02:03 <drigz> as did the previous [y..32]>>" "
17:02:13 <bwr> ah...
17:02:30 <mauke> the braces look redundant
17:02:34 <hml> how do I convert a : Graphics.Rendering.OpenGL.GL.BasicTypes.GLint : to a GLdouble?
17:02:44 <Botje> fromIntegral?
17:02:47 <Botje> maybe? :)
17:02:47 <mauke> :t mapM_(\y->putStrLn$do x<-[y-33..y];[" "," A"," ."]!!(signum(x`xor`y.&.x)+1))[0..31]
17:02:48 <lambdabot> IO ()
17:02:55 <mauke> one character down
17:03:14 <adu> wow
17:03:34 <Botje> :t forM_
17:03:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:03:41 <Botje> couldn't you use forM_ too?
17:03:48 <Botje> forM_[0..31]$...
17:03:48 <guenni> does anybody know the file ending ".hsc"?
17:03:51 <Botje> saves one (
17:03:56 <mauke> :t forM_[0..31]$\y->putStrLn$do x<-[y-33..y];[" "," A"," ."]!!(signum(x`xor`y.&.x)+1)
17:04:26 <Botje> *poke* \bot
17:04:38 <drigz> forM_ requires an extra import i beleive
17:04:40 <bwr> i get an error on that one
17:04:40 <drigz> *believe
17:04:42 <Twey> @botsmack
17:04:42 <lambdabot> :)
17:04:43 <drigz> @where forM_
17:04:44 <lambdabot> I know nothing about form_.
17:04:50 <drigz> @hoogle forM_
17:04:50 <lambdabot> Control.Monad.forM_ :: Monad m => [a] -> (a -> m b) -> m ()
17:04:50 <lambdabot> Data.Foldable.forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
17:05:07 <mauke> how do I get .&. into ghc -e ?
17:05:26 <bwr> surround everything in '' ?
17:05:35 <bwr> oh wait... you mean how do imports?
17:05:38 <drigz> Botje: i don't think you save anything because you need an extra space after the $
17:05:39 <mauke> yeah
17:05:51 <drigz> i.e. forM_[0..31]$ \y->
17:05:58 <Botje> really?
17:05:59 <adu> mauke: have you tried ghc -e "import Data.Bits" -e "the stuff"
17:06:15 <Botje> :t id$\y->y+1
17:06:20 <mauke> adu: ah, thanks
17:06:22 <drigz> mauke: why not ghci?
17:06:31 <Botje> ah
17:06:32 <Botje> indeed
17:06:34 <Botje> parse error
17:06:35 <Botje> boo!
17:07:33 <drigz> @pl \x->[" "," A"," ."]!!(signum(x`xor`y.&.x)+1)
17:07:34 <lambdabot> ([" ", " A", " ."] !!) . (1 +) . signum . ((.&.) =<< (`xor` y))
17:07:35 <hml> newtype MyFloat = MyFloat GL.GLdouble -- given that, why am i still required to sa (num MyFloat) ?
17:08:25 <adu> lol that is not the GHC user manual: http://gyb.gs-yuasa.com/download/manual/file/manual_ghc.pdf
17:08:27 <lambdabot> Title: cache:http://gyb.gs-yuasa.com/download/manual/file/manual_ghc.pdf - Google Searc ...
17:08:45 <hackage> Uploaded to hackage: lighttpd-conf 0.3
17:08:45 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.2
17:08:45 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.1
17:08:45 <hackage> Uploaded to hackage: lighttpd-conf 0.2
17:08:54 <mauke> hackage--
17:09:14 <adu> hackage--
17:09:22 <adu> @karma hackage
17:09:22 <lambdabot> hackage has a karma of -1
17:09:30 <byorgey> what's wrong with it?
17:09:34 <bwr> adu: lol
17:09:44 <mauke> I hate the announce format
17:10:13 <adu> mauke: should it be "Uploaded: lighttpd-conf, lighttpd-conf-qq, ..."
17:10:39 <mauke> yes, and it should be in the right order, and preferably in a CTCP ACTION
17:14:54 <Guest_Account> :pl \x y z->f x y z
17:15:13 <Guest_Account> asdfk
17:15:15 <byorgey> Guest_Account: try @pl
17:15:24 <Guest_Account> oh, thx
17:15:35 <Guest_Account> @pl \x y z->f x y z
17:15:35 <lambdabot> f
17:15:39 <bwr> @pl  \x->[" "," A"," ."]!!(signum(x`xor`y.&.x)+1)
17:15:40 <lambdabot> ([" ", " A", " ."] !!) . (1 +) . signum . ((.&.) =<< (`xor` y))
17:16:22 <Guest_Account> @pl \f x y z->g (f x y z)
17:16:22 <lambdabot> (((g .) .) .)
17:17:00 <Guest_Account> @pl \f x y z->f (g x y z)
17:17:01 <lambdabot> (. g) . (.) . (.)
17:17:26 <Guest_Account> @pl \f x y z->g (f x z y)
17:17:26 <lambdabot> ((((g .) .) . flip) .)
17:18:36 <dobblego> @check \z -> unfoldr (const Nothing) z == []
17:18:36 <lambdabot>   Not in scope: `myquickcheck''
17:18:38 <dobblego> wtf?
17:18:41 <dobblego> @scheck \z -> unfoldr (const Nothing) z == []
17:18:42 <lambdabot>     Failed to load interface for `SmallCheck':
17:18:42 <lambdabot>       Use -v to see a list of ...
17:30:42 <bwr> @pl \x-> x`xor`y.&.x
17:30:42 <lambdabot> (.&.) =<< (`xor` y)
17:31:51 <mmorrow> if anyone happens to use lighttpd and ghc6.9 ... then there's a QuasiQuoter for lighttpd config files that lets you embed the confs in hs src and check syntactic correctness at compile time:
17:31:53 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lighttpd-conf-qq-0.3
17:31:55 <lambdabot> Title: HackageDB: lighttpd-conf-qq-0.3, http://tinyurl.com/64bc7z
17:32:17 <mmorrow> here's and example of it's convenience wrt embedding in hs src:
17:32:18 <mmorrow> http://code.haskell.org/~morrow/code/haskell/web/lighttpd-conf-qq/test/test0.hs.html
17:32:19 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5ksujk
17:32:44 <mmorrow> </spam>
17:33:32 <Lemmih> mmorrow: It requires ghc6.9?
17:33:47 <mmorrow> oh, and the ouput http://code.haskell.org/~morrow/code/haskell/web/lighttpd-conf-qq/test/test0.output.html
17:33:48 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5dj6rk
17:34:02 <mmorrow> yeah, QuasiQuotes don't exists pre 6.9
17:34:10 <mmorrow> unfortunately
17:34:36 <SamB_XP> QuasiQuotes?
17:34:39 <SamB_XP> what's that?
17:34:48 <BMeph> mmorrow: What in 6.9 (and not in 6.8.3) allows QQ?
17:35:14 <mmorrow> it wasn't *implemented* until 6.9
17:35:26 <mmorrow> (not the regular TH quasiquotes)
17:35:39 <mmorrow> http://haskell.org/haskellwiki/Quasiquotation
17:35:39 <lambdabot> Title: Quasiquotation - HaskellWiki
17:35:51 <mmorrow> the paper by the implementor:
17:35:52 <mmorrow> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
17:35:53 <lambdabot> Title: Why It’s Nice to be Quoted: Quasiquoting for Haskell, http://tinyurl.com/yo9sa3
17:36:16 <mmorrow> i also have a regex quasiquoter...
17:36:51 <mmorrow> ghci> maybe [] tail $ [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
17:36:51 <mmorrow> ["-","3","141592653589793"]
17:38:04 <mmorrow> here's the haddock docs for Language.Haskell.TH.Quote (since this module isn't in the standard lib's template-haskell haddock docs):
17:38:06 <mmorrow> http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/Language-Haskell-TH-Quote.html
17:38:07 <lambdabot> Title: Language.Haskell.TH.Quote, http://tinyurl.com/5wmqsp
17:39:05 <mmorrow> audreyt wrote a patch for 6.8.3 that adds them though...
17:39:27 <mmorrow> http://code.haskell.org/~audreyt/qq-6.8.3.diff
17:50:08 <chrisdone> I'm so lazy I work in O(1) space
17:51:33 <Pete_I> "Haskell functions are also pure. Every time they’re called with the same arguments, they’ll return the same result." every time i read this, i think "...damn, they can't tell time."
17:52:11 <Twey> Pete_I: 's what monads are for :)
17:52:22 <Pete_I> i know, i just wish i understood em
17:52:30 <Twey> You'll get there...
17:52:35 <Pete_I> i'm sure
17:52:44 <znutar> I've had girlfriends that did that thing with the same arguments, but they sure weren't pure.
17:52:54 <Twey> ... in six months' time... *waves stick about and brandishes the beard he grew in the six months locked in his cave studying monads*
17:53:00 <Twey> Hahahaha, znutar :-D
17:53:33 <Twey> Pete_I: If you're just getting to the 'ARGH MONADS!' stage, I strongly recommend http://haskell.org/haskellwiki/Monads_as_computation
17:53:34 <lambdabot> Title: Monads as computation - HaskellWiki
17:53:35 <SamB_XP> Pete_I: well, returning in the IO monad is not the kind of returning that is referred to in the above statement
17:53:48 <Twey> That's what finally made it click for me :)
17:53:56 <chrisdone> Twey: murmering lojban to yourself .. uanaisaicaicaisaicaicaicai...
17:54:04 <SamB_XP> the above statement is just talking about the value of the CALL
17:54:07 <Twey> Hahahaha
17:54:22 <Twey> chrisdone: ma krinu lo nu do na zvati la'o .irk. #lojban .irk.
17:55:41 <annica> > foldr (&&) True $ map isDigit "12345"
17:55:42 <chrisdone> .y na nelci ja cinri .u'u
17:55:43 <lambdabot>  True
17:56:02 <annica> is there an easier way to tell if a string is a (positive) integer?
17:56:06 <Twey> xu lo prenu go'i
17:56:07 <mauke> > all isDigit "12345"
17:56:08 <lambdabot>  True
17:56:21 <EvilRanter> ...
17:56:25 * EvilRanter detects lojban
17:56:26 <Twey> > all isDigit "+12345"
17:56:27 <lambdabot>  False
17:56:31 <annica> Twey, i knew ther would be something better, thanks :)
17:56:41 <mauke> :-(
17:56:43 <dino-> e> Data.Time.getCurrentTime >>= return . (Data.Time.utcToZonedTime Data.Time.utc)
17:56:46 <Twey> No, annica, I was just pointing out that mauke's didn't work for all cases
17:56:48 <dino-> > Data.Time.getCurrentTime >>= return . (Data.Time.utcToZonedTime Data.Time.utc)
17:56:49 <lambdabot>   Not in scope: `Data.Time.utc'
17:56:54 <chrisdone> .u'i na go'i
17:56:58 <dino-> :(
17:57:07 <Pete_I> twey, i forgot the small bit i knew of the language. I started fresh two days ago
17:57:14 <dino-> > Data.Time.getCurrentTime >>= return . (Data.Time.utcToZonedTime Data.Time.LocalTime.utc)
17:57:15 <lambdabot>   Not in scope: `Data.Time.LocalTime.utc'
17:57:21 <Pete_I> ...i think. i skipped sleep one day
17:57:31 <dino-> lambdabot: Ok, I give up. You're out of time!
17:57:35 <annica> ow, mauke was first. that will work for me though. thanks mauke :)
17:57:47 <Twey> OK :)
17:57:49 <mauke> @src all
17:57:50 <lambdabot> all p =  and . map p
17:57:52 <mauke> @src and
17:57:53 <lambdabot> and   =  foldr (&&) True
17:58:15 <Pete_I> thanks for the link
17:58:20 <annica> heh, nice
17:58:21 <mauke> EXPERT REWRITE RULER
17:58:49 <chrisdone> Twey: .ai mi ba cilre fi lo zu'o tavla fo la .lojban. .i lo mi pendo cu kansa mi lo nu go'i je'u.a'o
17:59:34 <Twey> .ua xamgu pendo
17:59:44 <chrisdone> .ie
17:59:52 <Twey> .i'e lo ninpre ze'e cinri .ie-pei pau-nai le'o zo'o
17:59:53 <chrisdone> na simsa do
18:00:04 <Twey> .yyy. lo jbopre .u'i
18:00:09 <Twey> T_T
18:00:20 <Pete_I> there's a chan for esperanto, isn't there one for lojban?
18:00:23 <Twey> mi djica troci .i ku'i mi nitcu lo nu mi gunka
18:00:31 <Twey> There is
18:00:32 <mauke> uıop n ɹ ɟʇʍ ǝɯ ǝsnɔxǝ
18:00:39 <Pete_I> lol
18:00:39 <hansfbaier> > System.Time.getClockTime
18:00:40 <Twey> mauke: Hahaha
18:00:40 <lambdabot>   Not in scope: `System.Time.getClockTime'
18:00:52 <hansfbaier> > :m System.Time
18:00:53 <lambdabot>   parse error on input `:'
18:00:57 <chrisdone> cracked me up
18:01:18 <Twey> hansfbaier: You can't load arbitrary modules
18:01:21 <paczesiowa> mmorrow: what's so great about that quasiquoting? and why do you need haskell to statically parse lighttpd cfg files?
18:01:23 <Twey> For fairly obvious reasons :-P
18:01:35 <Pete_I> lambdabot, time
18:01:38 <Pete_I> ?
18:01:43 <Pete_I> > time
18:01:44 <lambdabot>   Not in scope: `time'
18:01:48 <Pete_I> darn
18:01:59 <mauke> @localtime lambdabot
18:01:59 <lambdabot> I live on the internet, do you expect me to have a local time?
18:02:03 <chrisdone> kibro is a proposed lojban word for "cyber". doesn't really mean "web framework", but I like the sound of it
18:02:26 <mauke> @localtime Pete_I
18:02:27 <lambdabot> Local time for Pete_I is Tue Aug  5 20:02:38
18:02:29 <chrisdone> lambdabot: no, you are the demons
18:02:40 <Pete_I> internet time is UST though
18:02:42 <mauke> and then lambdabot was a zombie.
18:02:51 <Twey> Haha
18:02:58 <hansfbaier> > System.Posix.Time.epochTime
18:02:59 <lambdabot>   Not in scope: `System.Posix.Time.epochTime'
18:03:02 <chrisdone> @brains
18:03:02 <lambdabot> Well, I think so, Brain, but first you'd have to take that whole bridge apart, wouldn't you?
18:03:09 <Pete_I> hansfbaier, give up. it's not there
18:03:12 <chrisdone> O_O
18:03:55 <hansfbaier> @localtime hansfbaier
18:05:37 <Pete_I> i think it should be like "time to get a watch"
18:05:58 <pjdelport> Pete_I: to think about how Haskell functions can tell time
18:06:09 <pjdelport> think about random number generation
18:06:18 <chrisdone> I'd bet lots of people have been punched in the face for saying that. "haha tiem to get a w-BIFF!"
18:06:28 <Pete_I> also fuzzy, a horrible failure last time i tried.
18:06:59 <adu> internet time is UST+1
18:07:08 <Pete_I> adu, why so?
18:07:11 <pjdelport> Pete_I: you can't make a function return a different random number each time you use it
18:07:35 <Pete_I> how do you make a rand function then?
18:07:35 <pjdelport> but you can give it a seed
18:07:37 <adu> http://en.wikipedia.org/wiki/Swatch_Internet_Time
18:07:38 <lambdabot> Title: Swatch Internet Time - Wikipedia, the free encyclopedia
18:07:39 <chrisdone> that's the mean time of internets users
18:07:58 <mauke> :t randomIO
18:07:58 <lambdabot> forall a. (Random a) => IO a
18:08:06 <Pete_I> the seed is usually the time from the epoch
18:08:24 <adu> Pete_I: for some reason, Swatch decided it would be more marketable if it were non-standard
18:08:39 <Pete_I> nonstandard is failure
18:08:44 <adu> indeed
18:08:45 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.3
18:08:53 <Pete_I> atleast in terms of time and computers
18:08:56 <adu> besides 1000 units is totally not enough time
18:09:15 <Pete_I> oh...i remember reading about that
18:09:27 <Pete_I> they don't account for leap seconds, and thus fail.
18:09:37 <Pete_I> no real benefits over our current system either
18:09:41 <pjdelport> Pete_I: right, that's one possible source
18:09:51 <adu> I'm going to make adu's internet time, which will be divided into 1,000,000 units, with unit "ud" for micro-day and "ADU" will be the timezone :)
18:10:14 <Pete_I> heheh
18:10:25 <hansfbaier> Anyone who successfully compiled WaSH recently (WashNGo) ?
18:10:34 <pjdelport> Pete_I: the important thing is that when you generate a random number, you don't just calculate a number from the seed/state
18:10:37 <chrisdone> a little nonsense now and then is cherished by the wisest men
18:10:45 <mauke> anno dominu umbrarum
18:10:55 <chrisdone> I don't play pokemon
18:11:06 <mauke> s/nu/ni/
18:11:09 <chrisdone> ohhh
18:11:12 <pjdelport> but you also generate the next internal state
18:11:16 <petekaz> how do I convert a decimal such as 1.0 to an Int?
18:11:23 <chrisdone> hansfbaier: trying to do haskell web development, are we?
18:11:27 <pjdelport> @type random
18:11:27 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
18:11:33 <mauke> petekaz: round, floor, ceiling
18:11:46 <petekaz> thanks
18:12:05 <hansfbaier> chrisdone: more investigating what would be the best way to do it in haskell (for enterprise apps)
18:12:14 <chrisdone> I used to think flour and ceiling did really complicated things before actually reading what they did
18:12:27 <dino-> and truncate
18:12:57 <chrisdone> hansfbaier: oh, I see. I'm working on a simple framework for, uh, not enterprise apps, but it might interest you; http://chrisdone.com/blog/2008/08/06/kibro-haskell-lighttpd-and-fastcgi/
18:12:58 <lambdabot> Title: 17 Chris Done’s Blog 2d » Kibro: Haskell, lighttpd and fastcgi b, http://tinyurl.com/59vhhb
18:13:14 <Pete_I> dino-, wouldn't that require a show and a read?
18:13:25 <chrisdone> :t truncate
18:13:25 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
18:13:39 <Pete_I> hmm. i'd expected it to be a string function
18:13:41 <mauke> fromEnum
18:13:44 <chrisdone> > truncate 999.666
18:13:45 <lambdabot>  999
18:13:53 <mauke> > fromEnum 999.666
18:13:54 <lambdabot>  999
18:13:58 <chrisdone> omfg
18:14:00 <hansfbaier> chrisdone: Any progress on it recently?
18:14:12 <mauke> EXPERT PRELUDE ABUSER
18:14:17 <pjdelport> Pete_I: so if you give random the same state as input, it will always give you the same result as output
18:14:17 <chrisdone> hansfbaier: well, I posted that about 15 minutes ago
18:14:24 <chrisdone> hansfbaier: there will be lots of progress this week
18:14:46 <pjdelport> Pete_I: but it also gives you the *next* state to use
18:15:03 <Pete_I> that's why they usually use the time as the seed, it changes fast, and often
18:15:18 <pjdelport> well, you only have to seed the state once
18:15:30 <hansfbaier> chrisdone: Kibro has its own SQL layer?
18:15:48 <pjdelport> after that, it's the purpose of the generator to just keep on perturbing it
18:15:51 <chrisdone> hansfbaier: it uses HDBC underneat
18:15:57 <chrisdone> er, underneath
18:16:26 <chrisdone> hansfbaier: but yes, it will have to ensure thread safety and whatnot
18:17:18 <pjdelport> Pete_I: so by threading together calls to random like that, each call provides the state for the next call
18:17:25 <chrisdone> hansfbaier: writing SQL results to memcached could be a simple setting, for those ENTERPRISE applications. but IIRC sqlite doesn't scale well anyway
18:17:35 <gwern> @remember Anonymous Klingon processes do not time-share.  They battle for supremacy!
18:17:36 <lambdabot> I will never forget.
18:17:43 <gwern> @quote Klingon
18:17:43 <lambdabot> Anonymous says: Klingon processes do not time-share.  They battle for supremacy!
18:17:54 * Twey laughs.
18:18:03 <pjdelport> Pete_I: it's exactly what happens behind the scenes in most other languages;  Haskell just makes the state-passing explicit
18:18:22 <chrisdone> "supreme" only used in the first person, of course
18:19:11 <pjdelport> Pete_I: by making all the input to the random function explicit, it becomes referentially transparent
18:19:30 <chrisdone> bbl
18:20:13 <pjdelport> Pete_I: make sense?
18:22:00 <Pete_I> well, i know how it works, "referentially transparent" is a bit ....i have no idea what that means.
18:22:12 <hansfbaier> chrisdone: hxweb looks interesting too.
18:22:45 <gwern> Pete_I: the first step is admitting you have a problem :)
18:23:09 <Pete_I> hey, hey
18:23:10 <pjdelport> Pete_I: oh, that's just the formal word for "Every time they’re called with the same arguments, they’ll return the same result."
18:23:11 <paczesiowa> Pete_I: (I was just reading this) http://projects.workingmouse.com/public/intro-to-highlevel-programming-with-scala/artifacts/latest/html/index.html grep Referential Transparency
18:23:13 <lambdabot> Title: Introduction to High-level Programming with Scala, http://tinyurl.com/65rz6s
18:24:04 <Pete_I> should be interesting
18:24:15 <adu> i wrote a program for adu time
18:24:21 <Pete_I> already?
18:24:23 <adu> > getCurrentTime>>=(return.floor.(*1000000).timeOfDayToDayFraction.timeToTimeOfDay.utctDayTime)
18:24:24 <lambdabot>   Not in scope: `utctDayTime'
18:24:27 <adu> crap
18:24:31 <Pete_I> that's pretty short there
18:24:53 <Pete_I> floor? doesn't that round down? a bit imprecise isn't it?
18:25:02 <adu> you can take it out if you want
18:25:40 <pjdelport> Pete_I: so does it make sense how you get random numbers above?
18:25:48 <Pete_I> referential transparency = huge words for what all the tutorials call (short/simply) "pure"
18:25:58 <pjdelport> right
18:26:07 <Pete_I> yeah, i'm familiar with it from perl
18:26:10 <dobblego> is the ((->) t) Applicative pure just const?
18:26:16 * Twey laughs out loud!
18:26:18 <mauke> dobblego: yes
18:26:24 <dobblego> mauke, ta
18:26:30 <mauke> @src (->) return
18:26:31 <lambdabot> return = const
18:26:31 <pjdelport> the problem is just that "pure" is poorly defined
18:26:36 <mauke> @src (->) pure
18:26:36 <lambdabot> pure = const
18:26:39 <pjdelport> people use it to mean various things
18:26:51 <Pete_I> looks pretty well defined there
18:26:52 <pjdelport> "referentially transparent" being one of them
18:26:54 * Twey submits to bash.org
18:27:10 * Twey wonders if it's a little too high-class, but shrugs and decides it's worth a go
18:27:13 <Pete_I> twey, it was that funny?
18:27:25 <Twey> 'twas pretty funny :-P
18:27:32 <Pete_I> alright, go ahead then :)
18:27:45 <adu> > getCurrentTime>>=(return.fromRational.(*1000000).timeOfDayToDayFraction.localTimeOfDay.(utcToLocalTime utc))
18:27:46 <lambdabot>   Not in scope: `utc'
18:27:49 <adu> crap
18:28:50 <adu> > getCurrentTime>>=(return.fromRational.(*1000000).timeOfDayToDayFraction.localTimeOfDay.(utcToLocalTime (hoursToTimeZone 0)))
18:28:50 <lambdabot>   Not in scope: `hoursToTimeZone'
18:29:25 <Pete_I> >:show packages
18:29:37 <adu> > :show packages
18:29:38 <lambdabot>   parse error on input `:'
18:29:47 <Pete_I> :show packages
18:29:59 <Pete_I> @help
18:29:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:30:04 <pjdelport> Pete_I: anyway, the idea above is essentially how IO works
18:30:08 <adu> @show packages
18:30:08 <lambdabot> "packages"
18:30:19 <Pete_I> @show modules
18:30:19 <lambdabot> "modules"
18:30:22 <Pete_I> fail
18:30:29 <pjdelport> (and thus time, and so on)
18:30:38 <mauke> @help show
18:30:38 <lambdabot> show <foo>. Print "<foo>"
18:30:55 <Pete_I> pjdelport, yeah...i usually run into problems with types when it's like "Type IO : can't be used with any normal functions"
18:31:13 <pjdelport> sure they can
18:31:15 <Pete_I> some how IO automagically turns into type string along the way via read apparently
18:31:29 <mauke> Pete_I: try http://mauke.ath.cx/stuff/haskell/how-to-io.html
18:31:31 <lambdabot> Title: Haskell: How To IO
18:31:50 <adu> Pete_I: how many introductions to monads have you had so far?
18:32:05 <Pete_I> counting just the channel, or in total?
18:32:11 <adu> total
18:32:19 <pjdelport> Pete_I: "IO foo" is just a way of saying that the value foo depends on IO
18:32:38 <mauke> it is possible to completely understand IO without touching monads
18:32:41 <Pete_I> i've probably got 4 books on it in my haskell folder here, and another 4 pages in chan, then probably 2 i found randomly today
18:32:47 <pjdelport> if you use it, you will thus also depend on IO
18:32:51 <mauke> "monads" are a red herring
18:33:18 <adu> Pete_I: if you haven't read them yet, thats 0
18:33:38 <pjdelport> right, the IO monad is just convenience
18:33:46 <Pete_I> adu, i'm working on it :P
18:34:28 <Pete_I> i'll be well into them by this weekend
18:34:30 <pjdelport> it's easier to start with the IO functor
18:34:43 * heatsink is apparently not the only one who pronounces "eval" the same as "evil"
18:34:53 <adu> Pete_I: anyways, I think a great way to look at it is a one-way street
18:35:30 <Pete_I> they're filehandles >.> perl's filehandles are one way
18:35:32 <adu> Pete_I: once you walk down the IO monad you can't go back
18:35:48 <Twey> Pete_I: Start with Monads as Computation
18:35:49 <Pete_I> uh...ok
18:35:53 <Twey> It's wonderful.
18:36:01 <Twey> Oh, and stop thinking of Haskell in terms of Perl.
18:36:03 <mauke> wait, what problem are we trying to solve
18:36:05 <Twey> It's not going to work.  :-P
18:36:08 <adu> Pete_I: which is why everyone here is very picky about what functions they decide to declare as -> IO a
18:36:29 <Twey> (correct answer: 'as few as possible')
18:36:40 <Pete_I> twey, ok.
18:36:50 <mauke> Perl's filehandles are not one way. If you just want to use IO, you should ignore monads for now. Thinking of Haskell in terms of Perl works fine in my experience.
18:37:13 <adu> Pete_I: thats because of referential-transparency
18:38:18 <Pete_I> i thought you had to use modules to make a two way filehandle? open even with pipes is still one way isn't it?
18:38:29 <mauke> huh?
18:38:31 <Pete_I> adu, ok
18:38:34 <pjdelport> Pete_I: completely different sense of "one way"
18:38:37 <Pete_I> mauke, nevermind
18:38:42 <adu> referential-transparency is a property that most things outside the monad world have, because they never change, but monads allow you to change things, and you can't mix mutability and immutability
18:38:48 <mauke> open my $fh, '+<', $file
18:38:56 <mauke> now you can both read and write
18:39:10 <pjdelport> adu: that's not really true
18:39:25 <adu> pjdelport: ok i'll stop
18:40:01 <adu> pjdelport: does it have more to do with how many arguments the type constructors have?
18:40:34 <pjdelport> adu: define "it" in that sentence? :)
18:40:43 <adu> mutability
18:40:43 <pjdelport> referential transparency?
18:40:49 <pjdelport> oh
18:41:23 <pjdelport> well, the short answer is "Haskell has no mutation"
18:41:23 <bd_> adu: no
18:41:34 <adu> heh
18:42:07 <bd_> adu: strictly speaking nothing is mutable in haskell, ever - there's just a few functions which make certain things act like handles to mutable objects
18:42:27 <adu> bd_: like IO and Ptr...
18:42:40 <pjdelport> the more elaborate answer is that Haskell implementations are free to optimize sequences of operations to avoid temporary intermediate values
18:42:48 <pjdelport> and use in-place mutation instead, if they can
18:43:10 <pjdelport> but there is still no observable mutation
18:43:42 <adu> pjdelport: so what exactly was it that you were disagreeing with?
18:44:02 <geezusfreeek> adu: you said monads make function not referentially transparent. that isn't true
18:44:04 <pjdelport> adu: monads have nothing to do with mutability or changing things
18:44:07 <geezusfreeek> *functions
18:44:24 <adu> pjdelport: in haskell they do
18:44:31 <mauke> adu: no
18:44:31 <pjdelport> nope :)
18:45:06 <geezusfreeek> the IO monad effectively constructs an imperative program which the runtime executes, but the IO functions themselves are referentially transparent
18:45:09 <pjdelport> as mauke said, monads are a red herring
18:45:21 <adu> monads have everything to do with the opportunity for optimizing compilers to do mutation behind your back, which to me is the same as mutation
18:45:26 <mauke> adu: no
18:45:29 <adu> yes
18:45:30 <pjdelport> adu: no, they don't
18:45:44 <adu> yes
18:45:56 <pjdelport> adu: that kind of optimization happens all over the place, completely independent of any monads
18:45:58 <geezusfreeek> you do not _use_ it as if there is mutation
18:46:05 <mauke> adu: explain to me how function calls are mutation behind my back
18:46:07 <pjdelport> e.g. list fusion, and whatnot
18:46:14 <geezusfreeek> it's just constructing a sequence of steps
18:46:31 <adu> function calls?
18:46:38 <mauke> yes, e.g. id 42
18:46:46 <adu> thats not a monad
18:46:50 <mauke> it is
18:47:00 <mauke> > (do x <- id; return x) 42
18:47:02 <lambdabot>  42
18:47:19 <pjdelport> adu: think of the random number generation example above
18:47:44 <Twey> (id >>= return) 42
18:47:46 <Twey> > (id >>= return) 42
18:47:48 <lambdabot>  42
18:48:00 * Twey is still amazed at functions secretly being monads, after all this time.
18:48:21 <pjdelport> adu: an optimizing compiler can spot how the RNG state is only used once in each case
18:48:28 * BMeph wonders why Twey thought it was a secret... ;)
18:48:43 <pjdelport> adu: and optimize it so that storage is only allocated once, and overwritten each time
18:48:52 <adu> so does the appearance of mutability stem from scope?
18:49:22 <mauke> where do you see mutability? IO?
18:49:37 <adu> not just IO
18:49:52 <adu> many parameterized types
18:49:56 <mauke> for example?
18:50:10 <adu> like Parser ()
18:50:27 <mauke> as in Parsec? what does it mutate?
18:50:29 <adu> and Q and Ptr and IO and ST ()
18:50:35 <mauke> Ptr is not a monad
18:50:43 <adu> i understand that
18:50:47 <adu> but you asked about mutability
18:50:53 <mauke> ah
18:51:01 <mauke> well, Ptr isn't mutable either :-)
18:51:13 <adu> i know, but the thing it points to is :)
18:51:27 <pjdelport> adu: they involve no more mutability than random number generation
18:51:30 <mauke> ST is special :/
18:51:36 <mauke> adu: do you know State?
18:51:43 <pjdelport> adu: there are just data dependencies
18:51:45 <adu> mauke: nope
18:52:13 <adu> mauke: I tend to shy away from things with too many variants
18:52:25 <mauke> > runState (do x <- get; put (x * 2); return "fiddlesticks") 21
18:52:26 <lambdabot>  ("fiddlesticks",42)
18:53:00 <mauke> basically, you have a single hidden variable that can be accessed with 'get' and 'put'
18:53:06 <adu> like IArray, UArray, MArray, SArray, i don't understand which one to use, so i just use Map
18:53:39 <adu> there are also too many State like types
18:53:47 <mauke> for example?
18:53:50 <shepheb> don't forget YMCArray
18:54:05 <pjdelport> @remember shepheb don't forget YMCArray
18:54:05 <lambdabot> Okay.
18:55:02 <adu> mauke: i can't think of any, but i know i've seen things like ST STU STM State State#
18:55:18 <mauke> STM has nothing to do with state
18:55:22 <mauke> I've never seen State#
18:55:23 <adu> ok
18:55:37 <mauke> ST gives you multiple explicit variables
18:55:39 <pjdelport> the world is full of state
18:55:44 <mauke> like Ptrs, basically
18:55:52 <mauke> State has only one, but it's "global"
18:56:30 <adu> oh, I was thinking of IORef, STRef, MVar TVar and the like i think...
18:56:37 * BMeph wants to get a "State#" sweatshirt
18:56:38 <mauke> anyway, State is just syntactic sugar for manually passing state around
18:56:43 <mauke> @src State
18:56:43 <lambdabot> Source not found. My pet ferret can type better than you!
18:56:46 <mauke> :-(
18:56:49 <pjdelport> s/syntactic/library/
18:56:59 <mauke> @unmtl State s a
18:56:59 <lambdabot> s -> (a, s)
18:57:22 <pjdelport> :t random
18:57:23 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
18:57:26 <adu> @unmtl Arrow a
18:57:26 <lambdabot> Arrow a
18:57:30 <adu> :(
18:57:58 <enso> hah
18:58:01 <adu> BMeph: lol
18:58:25 <enso> I hate when lambdabot is so concise
18:59:10 <mauke> anyway, old state goes in, return value and new state come out
18:59:25 <adu> ok
18:59:30 <mauke> the State monad just hides the plumbing
18:59:57 <adu> but how does that change the way I think about monads?
18:59:59 <edwardk> i just realized that boquist's version of grin doesn't do blackholing or deal with redirection nodes very well. (while jhc conspicuously tries to avoid needing them)
19:00:40 <mauke> I don't know how you think about monads :-)
19:00:42 <pjdelport> you shouldn't really think about monads in particular
19:00:53 <adu> lol
19:00:54 <pjdelport> they're just another library abstraction
19:00:54 <mauke> but does your mental model allow for thins like Reader or Cont?
19:01:00 <enso> ...it makes your head hurt
19:01:00 <mauke> *things
19:01:05 <pjdelport> think about Functor, Applicative, and so on!
19:01:56 <enso> adu: have you read "Monads as Computation" http://www.haskell.org/haskellwiki/Monads_as_computation
19:01:57 <lambdabot> Title: Monads as computation - HaskellWiki
19:02:03 <shapr> @yow !
19:02:04 <lambdabot> Couldn't find fortune file
19:02:06 <shapr> @quote
19:02:06 <lambdabot> pcrs says: Premature carriage ret
19:02:51 <enso> That is a very succinct discussion of monads
19:03:12 * mauke kicks you in the monads
19:03:16 <shapr> ow!
19:03:49 <enso> mostly avoids the unnecessary mathematical discussion. its a more conceptual review of monads
19:03:56 * enso doubles over
19:04:39 <adu> mauke: no I've never used State, Reader or Cont
19:04:55 <adu> only IO, Ptr, Parser, and Q
19:05:06 <dobblego> how do you say "the (->) Monad" when talking?
19:05:12 * enso would give his left monad to TOTALLY understand arrows, monads..etc
19:05:28 <pjdelport> dobblego: (r ->), surely
19:05:35 <enso> the "pointy" Monad?
19:05:41 * Twey laughs.
19:05:49 <mauke> the function monad
19:06:00 <BMeph> Reader
19:06:07 <Twey> What's the use of the Id monad?
19:06:18 <enso> with Transformers
19:06:42 <BMeph> (...which isn't Technically Correct, but it's still understood ;)
19:06:54 <enso> heh
19:07:05 <adu> whats the Id monad?
19:07:11 <mauke> @src Identity
19:07:11 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
19:07:13 <edwardk> twey: i'm abusing it very heavily at the moment just to have a placeholder so i can plug in monadic effects later if needed
19:07:18 <Twey> Haha, oh
19:07:26 <adu> wait, you said Ptr wasn't a monad, sorry
19:07:26 <mauke> @src Identity return
19:07:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:07:32 <mauke> :-(
19:07:32 <enso> StateT run with Id becomes like State
19:07:53 <enso> ListT run with Id becomes [] ... etc
19:07:55 <edwardk> there is a Pointer comonad, but that is a whole other ballgame ;)
19:08:03 <BMeph> Twey: The Id monad is used to express subliminal desires to make Monad Transformers act like Monads... ;p
19:08:16 * enso agrees
19:08:16 * Twey grins.
19:08:26 * adu smiles
19:08:33 <Twey> 'A Freudian slip is when you mistake one thing for your mother.'
19:08:39 <enso> ha
19:08:41 <edwardk> Its a little harder to reason with than the Ego monad however
19:08:45 * BMeph is STILL waiting for edwardk's comonad tutorial...
19:09:09 <enso> wow...freud is popular this evening
19:09:16 <mauke> Nothing About Comonads
19:09:17 <pjdelport> BMeph: they're just like monads
19:09:21 <Twey> Haha
19:09:25 <pjdelport> only the other way around
19:09:27 <edwardk> all you can do with the Id monad is 'want this' and 'want that'
19:09:34 <enso> except....they're co
19:09:39 <petekaz> how do I write a function to generate a list of numbers starting at 1 up to sqrt of n.  But I want the list to be a list of Ints.
19:09:45 <BMeph> mauke: Everything About Comonads, please! ;p
19:10:06 <mauke> [1 .. ceiling (sqrt n)]
19:10:15 <petekaz> I keep getting type errors with that.
19:10:16 <mauke> [1 .. ceiling (sqrt (fromIntegral n))]
19:10:16 <enso> ta-da!
19:10:19 <BMeph> s/ceiling/floor/
19:10:23 <Dzlk> However, you can make the Id monad somewhat better behaved by wrapping it in SuperegoT.
19:10:37 <edwardk> BMeph: at the moment i'm neck deep in a toy compiler cursing up a storm because grin doesn't play nicely with most of the spineless tagless gmachine tricks used in ghc.
19:10:41 <enso> wow. props to Dzlk
19:10:43 <enso> :)
19:10:47 <BMeph> (since ceiling would presumably go beyond the sqrt. :)
19:11:01 <petekaz> mauke: thanks! the fromIntegral is the missing part!
19:11:02 <edwardk> BMeph: when i switch gears back to category theory i'll keep it in mind though ;)
19:11:02 <Dzlk> :)
19:11:26 <petekaz> mauke: I seem to get constantly stumped on math in haskekll
19:11:26 <mauke> > 1/3 + 1/3 + 1/3 :: Rational
19:11:27 <lambdabot>  1%1
19:11:54 <mauke> petekaz: the short version is: there are 2.5 numeric types
19:12:03 <enso> 2 + 2 = 5 in Haskell
19:12:17 <BMeph> edwardk: Sure, sure - Good Luck in that wrestling match. Meanwhile, I content myself with your (and sigfpe's) blog articles. :)
19:12:19 <adu> instance Monad Ego where return = id ; id >>= ego = superego ego id
19:12:20 <mauke> Int, Integer for integral numbers; Double for floating point numbers
19:12:50 <mauke> conversion from Double is with round/floor/ceiling; for everything else, use fromIntegral
19:13:22 <BMeph> Eep, time to head for home...
19:13:26 <mauke> of course, you have to know if the operation you want to use is an integer or a floating point op
19:13:32 <enso> so every article I read about Haskell, be it monads, comonads, arrows, functors....yadayada, mentions category theory
19:13:50 <enso> Are there any recommended books (as I'm sure there are)
19:14:01 <opensores> hellar me am teh doing compilezorz
19:14:13 <opensores> make: *** No rule to make target `mk/config.mk'.  Stop.
19:15:37 <enso> ...
19:15:54 <edwardk> does anyone know if anyone is working on ehc?
19:15:56 <ddarius> enso: Do you have any reason to care to learn CT?
19:16:27 <enso> curious. it's a major character trait/flaw of mine. :)
19:16:45 <enso> I'll probably care about it for a month or two
19:16:57 <enso> ignore it for 8
19:17:05 <enso> repeat.
19:17:05 <enso> :)
19:17:17 <opensores> nerdchild!
19:17:24 <edwardk> enso: i found categories for the working mathematician, and basic category theory for computer scientists by mac lane and pierce respectively to be worth reading
19:17:26 <enso> eventually I actually learn stuff
19:17:32 <pjdelport> enso: category theory is a bit hard to learn in isolation
19:17:33 <dolio> Conceptual Mathematics is supposed to be a nice (very) light introduction to it.
19:17:46 <ddarius> @google Barr Wells ESSLLI
19:17:48 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
19:17:48 <lambdabot> Title: Courses: Barr / Wells
19:17:54 <ddarius> enso: Read that for a start.
19:18:23 <enso> alrighty
19:18:26 <pjdelport> enso: since it's mostly about relating other areas of mathematics
19:18:26 <enso> thanks
19:18:40 <edwardk> enso: to understand the motivation behind monads, etc. i admit i found them easier to understand in haskell by going back and digging up the original papers on them by wadler and the original monads for encapsulating effects paper by moggi, etc. and building up to the modern versions than getting my head around them 'whole-cloth' from the mathematical definitions
19:19:08 <enso> yeah
19:19:19 <enso> I actually just read the wadler paper
19:19:30 <ddarius> Monads are used rather differently in most of CT than they are in Haskell or even PL semantics.
19:19:31 <opensores> gonads are objects right?
19:19:32 <enso> I thought it was very helpful
19:20:00 <edwardk> Yeah but I don't think you want opensores handling them.
19:20:05 <enso> perhaps I should search for the moggi paper before diving into the CT stuff too deep
19:20:15 <pjdelport> ddarius: how are they otherwise used elsewhere?
19:20:57 <edwardk> aha, ehc cheats and uses the boehm collector
19:22:01 <enso> for anyone that may have been silently following that "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2918"
19:22:02 <lambdabot> Title: Monadic Encapsulation of Eects: a Revised Approach (Extended Version) E.Moggi an ...
19:22:32 <heatsink> Why do OCR programs have so much trouble with ff and ffi ligatures?
19:22:39 <ddarius> pjdelport: Mathematicians tend to be more interested in Eilenberg-Moore algebras rather than Kleisli arrows.  They also tend to care about the relationship to adjunctions much more. The applications I'm most familiar with tend to be about algebras and aren't too far from recursive datatype theory.
19:23:33 <enso> heatsink: good question
19:24:19 <ddarius> heatsink: Perhaps because they are not looking for them
19:24:33 <mauke> ghc -fﬃ
19:24:40 <heatsink> haha
19:24:54 <pjdelport> @quote ﬃ
19:24:55 <lambdabot> No quotes match. Are you on drugs?
19:25:00 <pjdelport> @quote -f
19:25:00 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
19:30:35 <Twey> Gnargh.  Why, if I have a definition `data Node a = Node { value :: a, next :: Maybe (Node a) }`, can't I create a `Node Int 3 Nothing`?
19:30:53 <Twey> I get 'data constructor not in scope' on the Int
19:31:13 <mauke> because Int is not a data constructor
19:31:21 <mauke> what did you expect that to do?
19:32:02 <ddarius> This isn't System F.  We don't explicitly apply our types.
19:32:26 <Twey> OK, I apologise in advance for being obtuse here, it's too late to be doing this but I've nothing else to do and I can't sleep yet, so I'm going to plough on for a bit
19:32:52 <Twey> I'm trying to create a generalised Node type such as one might find in a linked list
19:33:01 <ddarius> A rephrasing of mauke's question: Why do you want to put 'Int' there?
19:33:14 <mauke> Haskell already has that
19:33:15 <Twey> So that I can have an integer in 'value'
19:33:20 <Twey> I know, mauke
19:33:20 <mauke> it's called '[]'
19:33:28 <Twey> I'm working through a textbook
19:33:29 <sm> I wonder if dons' darcs-graph handles darcs 2 repos
19:33:33 <Twey> I'm trying to humour it :)
19:34:01 <ddarius> Twey: So why aren't you writing Node Int 3 (Nothing (Node Int)) ?
19:34:23 * Twey blinks.
19:34:31 <Twey> (Nothing (Node Int)) ?
19:34:42 <Twey> When I construct my instance, you mean?
19:34:45 <mauke> if you think that doesn't make any sense ... neither does your original code :-)
19:34:59 <Twey> OK, so how would I do that instead?
19:35:05 <ddarius> Node 3 Nothing
19:35:06 <mauke> Node 3 Nothing
19:35:21 <ddarius> mauke: No, the latter made more sense then his original code as it was at least consistent.
19:35:44 <Twey> Um, then what does the definition look like?
19:35:53 <mauke> data Node a = Node { value :: a, next :: Maybe (Node a) }
19:36:19 <enso> is there a way to ask lamdbabot the src for a particular implementation of a class?
19:36:29 <Twey> Oh
19:36:30 <ddarius> Yes
19:36:31 <Twey> Uh
19:36:34 <pjdelport> @src [] fmap
19:36:34 <lambdabot> fmap = map
19:36:34 <opensores> u've all gone insane
19:36:34 * Twey shakes his head.
19:36:47 <enso> ahh...drat thanks
19:36:55 * Twey lets out a bloodcurdling laugh in opensores' direction.
19:38:17 <sebaseba> Twey: perhaps it would help if you thought of constructors as normal functions
19:38:40 <pjdelport> Twey: did you mean Node (3 :: Int) Nothing ?
19:39:18 <Twey> sebaseba: Don't mind me too much, I've done this before and it will all make perfect sense in the morning.
19:40:11 <sebaseba> Twey: for me, the enlightenment usually comes in the middle of the night :)
19:40:40 <Twey> sebaseba: I'm in a period of 'argh why aren't I asleep yet', I have the dumb :)
19:41:11 <mauke> http://arcanux.org/lambdacats/dumb.jpg
19:41:26 <sebaseba> lol
19:41:36 <Thomas2> that's awesome
19:41:41 <heatsink> Wha?  You had that pre-made?
19:41:47 <opensores> cats dont talk
19:41:48 * sebaseba thought this only happened to him...
19:41:59 <mauke> http://arcanux.org/lambdacats.html
19:41:59 <lambdabot> Title: Lambdacats
19:42:02 <ddarius> mauke: Incidentally, his type is not equivalent to [] but to non-empty lists.
19:42:30 <mauke> yeah, so he's going to define type List a = Maybe (Node a) :-)
19:42:58 <ddarius> Ugh, that reminds me of that ridiculous definition in Data.Tree.
19:44:38 <mauke> http://arcanux.org/lambdacats/io-monad.jpg
19:44:54 <lispy> dons: ping
19:45:29 <mauke> preflex: seen dons
19:45:30 <preflex>  dons was last seen on #haskell 19 hours, 11 minutes and 1 second ago, saying: thanks everyone for your input. go interwebs!
19:49:52 <hml> does this not work because I can't use : for matching lambdas?
19:49:54 <hml> modifyIORef lines (\ (DSegment (Segment other _)) : end ->
19:50:07 <lispy> for matching lambdas?
19:50:07 <heatsink> My favorite is Dmitry Astapov's.
19:50:14 <hml> pattern matching with lambda notatin
19:50:15 <bwr> lol
19:50:20 <bwr> mauke: are there more lambdacats?
19:50:25 <Cale> hml: you can't match against a lambda.
19:50:33 <bwr> oh... didn't see previous link
19:50:35 <hml> oh, not at all?
19:50:39 <ddarius> hml: Add parentheses.
19:50:39 <lispy> > \(x:xs) -> x) [1,2,3]
19:50:39 <lambdabot> Unbalanced parentheses
19:50:41 <Cale> hml: (well, you can match it against a plain variable, and that's it)
19:50:46 <lispy> > (\(x:xs) -> x) [1,2,3]
19:50:47 <lambdabot>  1
19:51:00 <Cale> er...
19:51:00 <hml> i can't match it vs constructors?
19:51:17 <Cale> oh, are you trying to use the lambda to patterm match?
19:51:18 <hml> i like lispy/s examplese
19:51:20 <Cale> That's okay
19:51:24 <Cale> pattern*
19:51:40 <hml> okay, it worked; lispy: thanks
19:51:41 <Cale> Yeah, you can do that much, as lispy showed :)
19:51:58 <Cale> If you need to match more than one case though, you need a case expression
19:52:04 <lispy> > (\(x:xs) -> x) [] -- but it can be dangerous since you only get one pattern
19:52:05 <lambdabot>   Non-exhaustive patterns in lambda
19:52:21 <lispy> DANGER!
19:52:30 <lispy> Non-total function!
19:52:41 <rwbarton> unsafeDoSomethingDangerous
19:52:52 <lispy> (who needs words like `partial' when we have non-total)
19:52:53 <mauke> > (\ ~1 -> 2) 3
19:52:54 <lambdabot>  2
19:52:57 <Cale> unsafeLaunchMissiles
19:53:08 <lispy> unsafePolitics
19:53:21 <Cale> unsafeOfficePolitics
19:53:37 <Cale> unsafeGiantWasteOfTime
19:53:40 <pjdelport> mauke: approximate pattern matching? :)
19:53:45 <lispy> unsafeSegfault
19:54:10 <sebaseba> unsafeCutTheRedWire
19:54:27 <rwbarton> what have I done?!
19:55:00 <bwr> lol
19:55:06 <Korollary> nothing bad until we have unsafeLolcats
19:55:38 <adu> can't you do \ {a -> b ; c -> d}?
19:55:57 <sebaseba> who said #haskell has lost its former humor?
19:56:07 <pjdelport> Korollary: http://arcanux.org/lambdacats/unsafeperformio.jpg
19:56:27 <adu> lolol
19:57:04 <adu> was such a long name chosen specifically to discourage its use?
19:57:12 <heatsink> adu: yes
19:57:20 <adu> I would imagine unIO would have been used more
19:57:41 <lispy> Yeah, 'unsafe' makes people turned off to using it
19:57:49 <sebaseba> then following that line of reason, we are forced to conclude that public static void main was chosen to discourage people from writing in Java
19:57:54 <sebaseba> *reasoning
19:58:01 <lispy> "Duuuuude...that code has this like unsafe thing or something."
19:58:04 <adu> you should have called it fsckUpYourCode
19:58:10 <heatsink> and XML was designed to discourage people from using it
19:58:18 <ddarius> sebaseba: No has said that.
19:58:30 <adu> lispy: lol
19:58:35 <lispy> sebaseba, heatsink: yeah, I don't think I would argue :)
19:58:42 <Korollary> I might argue.
19:59:42 <adu> is there a difference between unsafePerformIO.return and return.unsafePerformIO?
19:59:56 <ddarius> Yes.
19:59:56 <hml> the following makes constructing a DSegment "DSegment (Segment p1 p2))" and pattern matching a DSegment kind of clunkyh, is it possible to make it more elegant, i.e. like "DSegment p1 p2"; the two classes in question are: data Segment t = Segment (GL.Vertex3 t) (GL.Vertex3 t)
20:00:03 <hml> data Drawable = DList [Drawable ] | DSegment (Segment GL.GLdoubl)
20:00:18 <rwbarton> The first is the identity, the second is like unsafeInterleaveIO I suppose?
20:00:51 <lispy> adu: I think they might be different at the type level when things like rank-2 polymorphism are involved
20:01:03 <adu> @type return.unsafePerformIO
20:01:04 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:01:09 <ddarius> rwbarton is correct.
20:01:53 <adu> i get return.unsafePerformIO :: (Monad m) => IO a -> m a
20:02:18 <thoughtpolice> why shouldn't you?
20:02:37 <adu> thoughtpolice: wondering why lambdabot didn't
20:04:10 <Cale> adu: because unsafePerformIO is not in scope, of course :)
20:04:19 <adu> Cale: oh, ok
20:04:21 <Cale> adu: Sorry about the error reporting.
20:04:45 <Cale> adu: Not sure what killed that, but I think gwern is working on a replacement for the type/eval modules
20:05:09 <adu> ok, it seems to be working 80% of the time
20:06:48 <adu> > getCurrentTime
20:06:48 <lambdabot>   Not in scope: `getCurrentTime'
20:07:01 * ddarius blames Cale.
20:08:19 <adu> > $(LitE (IntegerL 3))
20:08:20 <lambdabot>   parse error on input `$'
20:08:37 <adu> @type (LitE (IntegerL 3))
20:08:37 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:08:43 <monjaro> Hey.  First off, if this isn't the place to ask this, I apologize.  I'm a high school student who is very interested in functional programming (especially Haskell) and I was wondering if it would be worthwhile to attend the ICFP.  I live in Victoria, so I wouldn't have to travel at all and the registration fee would not be a problem.  I realize that much of the material covered would be over my head, but it still seems li
20:08:55 <Cale> ddarius: Well, it's possible that it's my fault. It doesn't seem to coincide with any changes that I made though.
20:09:09 <adu> monjaro: do it
20:09:15 <ddarius> Since you've gotten custody lambdabot has seemed much less stable.
20:09:18 <Cale> monjaro: your message got cut off at "it still seems l"
20:09:46 <enso> the castle of aaaaaaaaaaarrggggggg....
20:09:58 <adu> @type (\x y -> [x..y])
20:09:59 <lambdabot> forall t. (Enum t) => t -> t -> [t]
20:10:00 <monjaro> Sorry about the message getting cut off.  The ending was "it still seems like it might be very interesting. Could anyone offer some advice?"
20:10:12 <ddarius> adu: That is enumFromTo
20:10:30 <enso> @ty enumFromTo
20:10:30 <adu> ddarius: I know, i just wanted to trick the @type plugin :P
20:10:30 <lambdabot> forall a. (Enum a) => a -> a -> [a]
20:10:43 <enso> tada :)
20:10:58 <Cale> monjaro: It seems like you could meet lots of interesting people there. If it was coming to my city, I'd go :)
20:11:20 * ddarius never has to worry about ICFP coming to a city near him.
20:11:27 <adu> monjaro: or you can stay here with us :)
20:11:34 <Cale> ddarius: Because you can fly to it?
20:11:35 * sebaseba doesn't have to worry either
20:11:48 <Cale> ddarius: Or because you never attend? :)
20:12:28 <ddarius> Cale: No, because there will never be one near where I currently live.  In the future though, it may be the case that an ICFP conference will be in a city near him.
20:13:16 <Cale> ddarius: ah, I hadn't thought of that possibility ;)
20:13:44 <adu> when I lived in San Fran. i went to sooo many conferences
20:14:22 <adu> no more LinuxWorld...
20:15:50 <adu> there was one LinuxWorld where I met 5 other people I knew from IRC
20:16:44 <monjaro> Cale: That chance of meeting other people interested in function programming was the main reason I was interested in going.  It would be nice to hear something about functional programming from somewhere other than reddit and LtU
20:17:58 <adu> monjaro: you should wear a half-life T-shirt then everyone will be like: Wow his lambda is different than ours!
20:18:04 <Cale> monjaro: By the way, if you're new here, feel free to stick around and ask questions about Haskell and functional programming :)
20:23:52 <Plouj> hi dons
20:24:51 <Plouj> dons: I tried to compile frag but at the very last compilation step I'm getting: http://paste.lisp.org/display/64852
20:25:58 <TSC> Looks like it's not linking properly with glut
20:26:05 <Plouj> I can tell that
20:26:16 <Plouj> but I have no idea how to troubleshoot it with haskell/ghc
20:27:17 <thoughtpolice> are you using cabal?
20:27:19 <Cale> hmm, you'll want to make sure that the right packages are specified as dependencies in the cabal file if you're building with cabal
20:27:36 <Cale> If not, make sure that you're putting --make on the commandline to GHC.
20:27:50 <monjaro> heh.  I guess that settles it.  I'll sign up soon.  Would it also be worthwhile to sign up for the Haskell Symposium?
20:27:51 <Plouj> well, this time I built with `ghc --make -O2 -fglasgow-exts Main.hs`
20:28:06 <thoughtpolice> if so you will probably have to specify a libdir so that the linker can pick up libglut or whatever
20:28:27 <thoughtpolice> i.e. '-L/usr/blah/lib/' or somesuch
20:28:54 <Plouj> `pkg-config --libs gl` ?
20:29:04 <Plouj> humm, no
20:29:40 <Plouj> why doesn't it just know where to look for libs like a C compiler/linker?
20:30:32 <mmorrow> <paczesiowa> mmorrow: what's so great about that quasiquoting? and why do you need haskell to statically parse lighttpd cfg files?
20:31:04 <mmorrow> you can also splice haskell values into the quasiquotes, giving you a way to *build* config files as well:
20:31:13 <mmorrow> ghci> (\port -> [$lighttpd| server.port = $port |]) 80
20:31:13 <mmorrow> Config [OptionE (QName {moduleName = Name "server", baseName = Name "port"}) (IntegerV 80)]
20:31:24 <mmorrow> and pprinting:
20:31:25 <mmorrow> ghci> putStrLn . render . ppr $ (\port -> [$lighttpd| server.port = $port |]) 80
20:31:25 <mmorrow> server.port = 80
20:32:01 <adu> what does [$lighttpd| ...|] mean?
20:32:29 <thoughtpolice> Plouj: well if your LD_PATH is not set up right then a c compiler/linker is not going to be able to find it either
20:32:29 <thoughtpolice> (on OS X it's actually DYLD_LIBRARY_PATH to specify what directories might contain libraries, YMMV)
20:33:15 <adu> Plouj: are you on OSX?
20:33:16 <thoughtpolice> Plouj: the problem is that you are linking with the haskell library GLUT, and it actually needs glut. you must be sure that it is somewhere in your libpath, or you must specify it on the command line
20:33:21 <Plouj> I'm on Fedora9
20:33:34 <adu> Plouj: did you use an rpm or compile yourself?
20:33:37 <thoughtpolice> i.e. ghc --make -O2 -fglasgow-exts -L/usr/local/blah/blah -lglut
20:33:49 <thoughtpolice> will tell the linker where to look and what lib to use
20:34:33 <Plouj> adu: did I use an rpm for what? I installed ghc from the Fedora's repository.
20:34:44 <thoughtpolice> it specifies a quasi-quoteer
20:35:19 <adu> Plouj: thats what i mean, I'm on macosx, and when I use macport ghc, everything works except for gl/glut, but then after i recompled, both work, maybe its the same?
20:35:44 <adu> i recompiled ghc with ghc-extralibs
20:35:55 <Plouj> adu: maybe, but I don't feel like maintaining ghc on my computer
20:36:03 <adu> maintain?
20:36:08 <adu> who said anything about maintain
20:36:20 <Plouj> compiling from scratch implies manual maintenance
20:36:29 <adu> nope
20:36:29 <adu> ./configure && make install
20:36:43 <adu> i don't see where the maintenance is
20:37:17 <b\6> i have to keep bicycling to keep my machine powered up.
20:37:28 <Plouj> my LD_PATH is empty, as it should be, I think
20:37:31 <mmorrow> <adu> what does [$lighttpd| ...|] mean?
20:37:42 <mmorrow> it's in reference to:
20:37:46 <dons> ?users
20:37:47 <lambdabot> Maximum users seen in #haskell: 484, currently: 422 (87.2%), active: 18 (4.3%)
20:37:53 <lispy> dons:
20:37:54 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lighttpd-conf-qq-0.4
20:37:55 <lambdabot> Title: HackageDB: lighttpd-conf-qq-0.4, http://tinyurl.com/6myhzq
20:38:04 <lispy> dons: I have a question about darcs-graph
20:38:11 <dons> oh?
20:38:16 <dons> mmorrow: woot!
20:38:19 <lispy> dons: do you still maintain it, and why did you parse the patch format instead of, say, using the --xml of changes?
20:38:21 <mmorrow> hehe
20:38:42 <dons> lispy, hmm. yes, and, it was easy at the time.
20:38:54 <mmorrow> adu: it's a quasiquoter as described here: http://haskell.org/haskellwiki/Quasiquotation
20:38:55 <lambdabot> Title: Quasiquotation - HaskellWiki
20:38:55 <dons> i've patches in my inbox from someone to port it to 2.0
20:38:56 <Plouj> `ghc --make -O2 -fglasgow-exts -L/usr/lib64/ -lGLU Main.hs` doesn't help :(
20:39:06 <lispy> dons: Hmm..I see.  It looks like it's incompatible with hashed repos
20:39:38 <lispy> dons: A more robust approach would be to write an xslt version or use a haskell xml parser
20:40:21 <lispy> dons: So, this has significance.  Someone pointed out hat darcs.net should have the darcs activity graph on the front page.  We need that darcs2.0 support :)
20:40:25 <dons> lispy, right.
20:40:42 <dons> i've a patch to parse the patch formats, so i could look at that.
20:41:36 <Dzlk> mmorrow: Nice. I could have used that a month ago. :)
20:42:11 <lispy> dons: that would be appreciated
20:42:13 <mmorrow> Dzlk: heh, hopefully you can still use it now :)
20:42:14 <adu> mmorrow: i'm just learning about TH, so I don't even know what [|...|] means yet...
20:42:33 <adu> mmorrow: so far I know the L.H.TH api, and the $(...) syntax
20:42:54 <ddarius> [| |] is the inverse of $( )
20:43:21 <adu> ddarius: so [| |] is like `() and $() is like ,@()
20:43:29 <ddarius> Yes.
20:43:32 <adu> ok :)
20:45:11 <adu> so is there $lighttpd() as well?
20:45:46 <lispy> adu: I think that's part of a new GHC extension
20:46:00 <lispy> adu: so that you can define things like $lighthttpd() as you want
20:46:15 <ddarius> adu: The [$foo| |] stuff is like reader macros.
20:46:23 <adu> thats a horribly ambiguous syntax tho
20:46:30 <mmorrow> adu: cool. what the  [$<a var id here>|  .... the syntax of whatever here ... |]    does is  it gets as a string "  .... the syntax of whatever here ... ", and uses the parser supplied by the person that defined the var (<a var id here> :: QuasiQuoter) to turn that string into a template-haskell expression of type ExpQ (which is a type synonym for Q Exp) which is actually the abstract syntax of whatever the quoted language is again
20:46:30 <mmorrow> quoted as a TH Exp. Finally, ghc evaluates this Exp which results in whatever the parser wanted it to be. _this all happens at compile-time_.
20:46:36 <mmorrow> phew
20:46:51 <adu> it should be $|[lighttpd]|(...)
20:46:55 <adu> just to be confusing
20:47:05 <mmorrow> heh
20:48:19 <mmorrow> the thing is, in order to splice haskell values into the AST of the quoted lang, you have to implement that yourself
20:48:50 <adu> so i could make a quoter for heterogeneous lists? hmm...
20:49:02 <mmorrow> via choosing some syntax to rep that, then parse that syntax, and finally insert (varE (mkName "x")) or whatever when it's lifted to TH syntax
20:49:11 <lispy> could your QuasiQuoter do IO?
20:49:18 <mmorrow> yesh
20:49:41 <mmorrow> ghci> :t runIO
20:49:42 <mmorrow> runIO :: forall a. IO a -> Q a
20:49:58 <lispy> So, your QuasiQuoter could parse Haskell?
20:50:11 <lispy> As in a Haskell file in the same directory
20:50:13 <adu> lispy: my?
20:50:17 <mmorrow> oh yeah, i've actually already got a package which does just that
20:50:20 <adu> lispy: mmorrow?
20:50:29 <lispy> adu: sorry?
20:50:39 <adu> lispy: n/m i was confused, i'm not now
20:51:06 <mmorrow> now i'm confused
20:51:12 <dons> bring it on, http://www.reddit.com/comments/6v2nl/ghc_project_switches_to_git/
20:51:13 <lambdabot> Title: GHC project switches to Git! : reddit.com
20:51:14 <lispy> mmorrow: I did something just like that in TH before using the H98 parser, but alas my blog is down at the moment
20:51:22 <dons> i hope this brings in new ghc devs.
20:51:42 <mmorrow> aww dang, you've gotta link me to that when it's back up
20:52:13 <adu> dons: did it used to use darcs?
20:52:25 <dons> it used darcs for 3 years, and cvs for about 12
20:52:36 <dons> i don't know what it used before cvs
20:52:45 <lispy> mmorrow: It was pretty simple...I just used the standard H98 parser and an unsafePerformIO.  What I was doing was reading in Unit.hs and looking for top level funs that started with "prop_" and then building the code to quickcheck them
20:52:45 <mmorrow> lispy: i used the haskell-src-exts parser which supports pretty much all the ghc extensions (including TH itself!!), and i've added almost working support for QQ syntax as well
20:52:51 <adu> so its a version control system slut
20:52:54 <dons> somone should write a book about the great dvcs wars of the 21st century
20:53:05 <dons> its as fun as the browser wars
20:53:19 <adu> lol
20:53:21 <mmorrow> i first parse an expression with the haskell-src-exts parser, then translate to ast to the TH ast
20:53:25 <lament> we need a winner first
20:53:38 <ddarius> There's a winner in the browser market?
20:53:38 <lament> (ie. we need Mercurial to die :D)
20:53:46 <adu> ddarius: yes, Amaya
20:53:54 <adu> Amaya is a clear winner
20:53:55 <mmorrow> lispy: http://code.haskell.org/~morrow/code/haskell/metaquote/
20:53:55 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
20:54:03 <lispy> dons: yeah, darcs' glory days are gone :(
20:54:19 * lispy has to cry himself to sleep every night now
20:54:51 <mmorrow> adu, lispy: i put the newest (as of a few weeks ago) template-haskell haddock docs here (since the one on the stdlib page don't currently have Language.Haskell.TH.Quote in them):
20:54:53 <mmorrow> http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/
20:54:53 <lambdabot> Title: template-haskell-2.2, http://tinyurl.com/6xdh6w
20:54:58 <adu> ddarius: o wait, does it have to be popular?
20:55:31 <adu> mmorrow: oO
20:55:57 <mmorrow> adu: check out http://code.haskell.org/~morrow/quasiquotes/template-haskell_docs_HEAD_080623/Language-Haskell-TH-Quote.html
20:55:57 <lambdabot> Title: Language.Haskell.TH.Quote, http://tinyurl.com/5wmqsp
20:56:16 <adu> ya i noticed Quote was new
21:00:07 <adu> how does "data ... deriving Typable" work?
21:00:25 <ddarius> Magic.
21:00:54 <adu> == sufficiently advanced technology
21:00:55 <sw17ch> is there an unsigned 8bit integer in the libraries?
21:01:03 * sw17ch thinks he's missing something obvious
21:01:03 <adu> Word8
21:01:10 <sw17ch> ah yes, thanks...
21:02:08 <mmorrow> adu: just like deriving (Show)
21:02:36 <adu> mmorrow: well, Show has to be magic, I just though maybe Typable wasn't
21:02:58 <mmorrow> adu: all it is is ghc generating the ast for the class instance
21:03:03 <adu> can you write your own "deriving" classes?
21:03:06 <ddarius> What?  What is magic about Show?
21:03:12 <ddarius> adu: No.
21:03:21 <mmorrow> i did a GADT show deriver with haskell-src-exts and put it in  a cgi program
21:03:25 * mmorrow get the link
21:03:45 <mmorrow> adu: http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
21:03:46 <lambdabot> Title: GADT Show
21:03:47 <thoughtpolice> dons: as someone who wants to contribute I can say it will at the very least make things less frusterating. :)
21:05:04 <mmorrow> adu: the derive package on hackage has Typeable as an option to derive for you also (check out the code)
21:06:21 <mmorrow> it even has a command line tool that given a module filename, grabs all the data declarations in it and derives whatever you tell it to for you ... then dumps the code to stdout
21:08:48 <hackage> Uploaded to hackage: lighttpd-conf-qq 0.4
21:09:12 <lispy> wow I've managed to create a very very broken darcs :(
21:18:18 <adu> mmorrow: i could use that on a Name.hs.in file with autoconf... hehe
21:18:47 <mmorrow> adu: use what?
21:19:02 <adu> mmorrow: the command line tool
21:19:14 <mmorrow> oh yeah. that thing is *awesome*
21:19:19 <adu> mmorrow: as an alternative to TH
21:19:59 <mmorrow> what are you doing in particular to Name.hs.in (or to Name.hs with TH) ?
21:20:24 <bogner> given (|||) :: (LayoutClass r a, LayoutClass l a) => l a -> r a -> Choose l r a, where Choose is an instance of LayoutClass, why does foldl1 (|||) [] give a type error?
21:21:03 <bogner> that is, why is ghc convinced that i'm constructing an infinite type?
21:21:15 <mmorrow> adu: (i mean, obviousy deriving stuff, but ....)
21:21:22 <mmorrow> +l
21:21:40 <adu> mmorrow: configuration defaults
21:21:58 <adu> mmorrow: using TH right now
21:22:24 <ddarius> bogner: Probably because you are.
21:22:34 <mmorrow> i've found using the cli tool to derive Binary for whole collections of datatypes to be really really useful
21:22:58 <bogner> ddarius: but the function should be well typed on every intermediate value, no?
21:23:16 <adu> mmorrow: I was getting tired of updating both the "data MyType" and the "defaultMyType =" every time I added another configuration option
21:23:42 <ddarius> bogner: What is the type of foldl1?
21:24:11 <bogner> hmm, foldl1 :: (a -> a -> a) -> [a] -> a
21:24:18 <bogner> i see what you mean
21:24:32 <mmorrow> adu: ahhh, i gotcha. interesting. i've not thought of using TH for configurations, it seem like they're a really good use for it though
21:25:02 <adu> mmorrow: ya, i just wrote a function that outputs a dataD and a valD ... it works pretty good
21:25:15 * mmorrow adds that to the list of things-TH-would-crush-at-and-eliminate-massive-amounts-of-work
21:25:36 <bogner> maybe i can write a polymorphic foldl1...
21:26:06 <mmorrow> well, i guess the lighttpd quasiquoter could be construed as "using TH for configurations", but not in the same sense...
21:26:46 <adu> heh
21:31:46 <bwr> .... putStr$unlines[concat$map show[(head$drop(2*(1+y)+x)$foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..])`mod`2|x<-(reverse[-64-y..64-y])]|y<-(reverse[1..64])]
21:45:03 <mmorrow> bwr: looks like a job for hstidybwr! http://hpaste.org/9418
21:45:18 <mmorrow> s/hstidybwr/hstidy/ ;)
21:46:05 <bwr> haha
21:46:08 <bwr> that didn't help much
21:46:09 <mmorrow> hehe
21:47:14 <mmorrow> interestingly, haskell-src-exts is sooooo great, that it parses TH syntax also ... so it parsed $unlines  and  $map   as if they were  $(unlines) and $(map)  (as it should)
21:48:59 <mmorrow> bwr: heh, here's the AST of that exp: http://hpaste.org/9418#a1
21:49:26 <bwr> what is the AST ? :/
21:49:49 <mmorrow> the parsed representation of something
21:49:54 <mmorrow> abstract syntax tree
21:50:00 <bwr> ah
21:50:07 <mmorrow> in this case, it just happens to be haskell representing haskell :)
21:52:19 <bwr> :P
21:52:55 <mmorrow> hehe, and here's the result of running _that_ through the parser one more time:
21:52:59 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/omgz.html
21:52:59 <lambdabot> Title: Haskell Code by HsColour
21:53:12 <mmorrow> haskell representing haskell representing haskell !!!
21:53:20 <bwr> lol
21:53:27 <bwr> that's bad
21:53:47 <mmorrow> haha
21:54:18 <mmorrow> since at every step, it's a valid expression, that could be done forever
21:54:45 <bwr> could you evaluate it at any stage?
21:55:32 <mmorrow> oh yeah, if you translated that into the template haskell AST, you could evaluate it back down one level
21:55:57 <mmorrow> but evaluating it as is gives you itself
21:56:55 <mmorrow> (i mean "evaluating" in the sense that evaluating  "Just ()"  gives you "Just ()")
21:58:38 <mmorrow> how you do it with template haskell is, say you have
21:58:41 <mmorrow> (\x -> x)
21:58:45 <mmorrow> that is rep by
21:58:58 <mmorrow> LamE [VarP x] (VarE x)
21:58:58 <jeffwheeler> MySpace user named "Alex Haskell." Ruining your searches 31 years ago.
21:59:11 <jeffwheeler> * searches since
22:02:20 <bwr> http://hpaste.org/9419
22:02:20 <bwr> :D
22:02:23 <bwr> much better
22:04:12 <lament> haskell is a reasonably common name
22:04:36 <lament> 16 Haskells on wikipedia
22:05:06 <b\6> is a really wonderful and robust getopt example hiding out somewhere?
22:05:22 <jeffwheeler> lament: any others named after other Haskell software?
22:05:43 <lament> hah, there's a composer named Haskell Small
22:06:34 <jeffwheeler> An ISD, even: http://en.wikipedia.org/wiki/Haskell_Consolidated_Independent_School_District
22:06:35 <lambdabot> http://tinyurl.com/6aevuv
22:14:46 <mmorrow> bwr: ok, check it out:
22:14:49 <mmorrow> http://hpaste.org/9420
22:15:39 <mmorrow> using template haskell to quote and unquote
22:16:12 <mmorrow> e''' was *really* huge. i didn't even print e''''
22:17:24 <mmorrow> (in case anyone is wondering, that parseExp function isn't in template-haskell, and template haskell doesn't provide an instance of lift for Exp either, so lifting them with lift won't work)
22:17:50 <adu> mmorrow: interesting
22:17:53 <mmorrow> both of those are here though: http://code.haskell.org/~morrow/code/haskell/metaquote/
22:17:53 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
22:18:35 <mmorrow> adu: yeah, that is cool. i never thought to do that before until after that exchange with bwr
22:19:31 <mmorrow> good thing Exp is an instance of Eq
22:20:06 <mmorrow> ha, and evaluating   e''' == $(return e'''')   took _at least_ a second in ghci
22:26:50 <hml> j
22:26:52 <hml>                                     
22:26:53 <hml>                                                
22:26:57 <hml> sorry;
22:27:59 <mmorrow> adu: omg. the prettyprinted e'''' is 18838 lines
22:28:11 <adu> lol
22:28:18 <mmorrow> and in-file it's 1.7M
22:28:39 <dons> go chrisdone ! http://www.reddit.com/comments/6v2yn/kibro_a_new_web_framework_for_haskell/
22:28:41 <lambdabot> Title: Kibro: a new web framework for Haskell : reddit.com, http://tinyurl.com/5pempv
22:28:53 <dons> this community rocks.
22:30:10 <mmorrow> our legions will rule t3h earf!
22:30:29 <mmorrow> adu: here's a dir w/ those prettyprinted and HsColoured: http://code.haskell.org/~morrow/code/haskell/misc/meta/
22:30:30 <lambdabot> Title: Index of /~morrow/code/haskell/misc/meta
22:30:35 <hml> ,
22:31:18 <mmorrow> adu: beware that eeeee.html is 3.5MB
22:31:32 <adu> heh, ok
22:32:26 <adu> wow
22:33:12 <tibbe> would functors over a data type with more than one type variable for its elements make sense (i.e. a Functor2 instance for Data.Map)
22:33:16 <tibbe> :t fmap
22:33:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:33:22 <adu> mmorrow: so that allows you to lift Exp?
22:33:52 <lispy> tibbe: I've asked this question about Monads
22:34:09 <mmorrow> if you mean s/that/what/... i've got instance for all of TH syntax in metaquote at http://code.haskell.org/~morrow/code/haskell/metaquote/
22:34:09 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
22:34:45 <mmorrow> s/instance/instances/
22:35:11 <lispy> tibbe: iirc you need more than plain H98 to even define the monad and functor classes
22:35:19 <mmorrow> tibbe: what type would you want it to be?
22:35:41 <yaru1022> hi, i have a question about the type of (compare . toLower)
22:35:43 <yaru1022> :t compare
22:35:43 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:36:09 <tibbe> mmorrow: not sure, basically I'm sitting here pondering traversals over maps and how they can be generalized to something similar to Data.Foldable, etc
22:36:14 <tibbe> lispy: yes
22:36:31 <yaru1022> we can think of compare as a function that accepts one argument (because of currying) and returns a function that accepts another argument and produce Ordering, right?
22:36:36 <tibbe> :t (compare . toLower)
22:36:36 <lambdabot> Char -> Char -> Ordering
22:37:20 <yaru1022> my initial guess was that (compare . toLower) would have a type Char -> a -> Ordering
22:37:29 <yaru1022> oh.. actually lol ; nvm. I got it :)
22:37:37 <yaru1022> because compare accepts two arguments of the same type
22:38:06 <mmorrow> tibbe: you could make a class like            class Functor2 f where fmap1 :: (a -> c) -> f a b -> f c b     fmap2 :: (b -> d) -> f a b -> f a d
22:38:26 <mmorrow> or some such thing
22:38:53 <dmwit> yaru1022: You probably want "comparing toLower" anyway.
22:39:02 <mmorrow> for Map, fmap1 would be over keys, and fmap2 over elems
22:39:13 <Pete_I> i have a dataset [1, 1, 2, 3, 3, 4], i want to sort by frequency, then remove duplicates. how would i do that?
22:39:16 <tibbe> mmorrow: I also need one over both keys and values
22:39:25 <Pete_I> in perl i'd use hashes. i don't know where to start here
22:39:50 <tibbe> mmorrow: I guess I'm looking for some theoretical foundations for these kind of traversals
22:39:52 <mmorrow> you could add   fmap12 :: ((a,b) -> (c,d)) -> f a b -> f c d
22:40:02 <dmwit> > map (length &&& id) . group $ [1, 1, 2, 3, 3, 4]
22:40:04 <lambdabot>  [(2,[1,1]),(1,[2]),(2,[3,3]),(1,[4])]
22:40:15 <dmwit> > map (length &&& head) . group $ [1, 1, 2, 3, 3, 4]
22:40:16 <lambdabot>  [(2,1),(1,2),(2,3),(1,4)]
22:40:40 <dmwit> > map snd . sort . map (length &&& head) . group $ [1, 1, 2, 3, 3, 4]
22:40:41 <lambdabot>  [2,4,1,3]
22:41:14 <kscaldef> hmm... what did that sort on?
22:41:26 <dmwit> length, then head
22:41:30 <Pete_I> sort by frequency
22:41:41 <Pete_I> ie, 1 or 3 should be first, they're most common
22:41:50 <yaru1022`> sorry ; my internet got disconnected
22:41:57 <dmwit> > reverse . map snd . sort . map (length &&& head) . group $ [1, 1, 2, 3, 3, 4] -- Pete_I
22:41:58 <lambdabot>  [3,1,4,2]
22:42:00 <dmwit> ;-)
22:42:08 <yaru1022`> did anyone answer my question ?
22:42:09 <kscaldef> hmm... did not realize sort worked transparently on pairs
22:42:21 <Pete_I> ....while awesome, that'll take me a while to parse
22:42:39 <mmorrow> tibbe: well, that Functor2 two class is the same as Functor really, it's just the you can't make Functor do that because you can't do (eg)  newtype F (a,b) = F (Map a b)
22:42:42 <Pete_I> thank you
22:42:51 <dmwit> > reverse . map head . sortBy (comparing length) . group $ [1, 1, 2, 3, 3, 4]
22:42:52 <lambdabot>  [3,1,4,2]
22:43:04 <dmwit> That one is probably easier to understand, though maybe a bit slower.
22:43:09 <bwr> http://hpaste.org/9419#a1
22:43:10 <bwr> yay
22:43:14 <kscaldef> Pete_I: just try it in ghci bit by bit working from right to left
22:43:15 <dmwit> Also, both of them only work if the list is sorted to begin with.
22:43:17 <bwr> ... the second item
22:43:40 <mmorrow> tibbe: ooh, actually i think you could do something essentially like F (a,b) = Map a b with type families
22:43:59 <Pete_I> that's ok i can just put qsort on the end there
22:44:10 <dmwit> yup
22:45:52 <dmwit> > map head . sortBy (flip (comparing length)) . group $ [1,1,2,3,3,4]
22:45:53 <lambdabot>  [1,3,2,4]
22:46:09 <dmwit> Even better, that's a stable sort, and it generates prefixes more lazily.
22:46:42 <mmorrow> tibbe: point being, in answer to your original question "would functors over a data type with more than one type variable for its elements make sense", .... yes. sometimes referred to as a Bifunctor.
22:46:46 <Pete_I> awesome, i think
22:47:12 <Pete_I> group groups the similar items?
22:47:18 <dmwit> yes
22:47:29 <Pete_I> ...that's unexpectedly simple.
22:48:24 <ahunter2> Question: exactly how special is "-" in the Haskell grammar?  Is it possible to make similar user-defined prefix operators?
22:48:47 <dmwit> pretty special
22:48:48 <dmwit> BUT
22:49:00 <dmwit> > Let (!) x = product [2..x] in (5!)
22:49:00 <lambdabot>  Parse error at "=" (column 11)
22:49:05 <dmwit> > let (!) x = product [2..x] in (5!)
22:49:06 <lambdabot>  120
22:49:09 <dmwit> =)
22:49:21 <ahunter2> Pretty good!
22:49:23 <Deewiant> BUT
22:49:24 <ahunter2> Pity:
22:49:25 <Deewiant> that's a GHC extension
22:49:52 <olsner> dmwit: clever :) but doesn't haskell demand that a section be a function?
22:49:59 <ahunter2> > let (!x) = product [2..x] in (!5)
22:49:59 <lambdabot>  Parse error in pattern at "in" (column 27)
22:50:01 <ahunter2> doesn't work
22:50:14 <dmwit> olsner: <3 GHC
22:50:33 <ahunter2> dmwit: fwiw, if GHC extensions would let me do it, I'd be more than happy with it
22:51:04 <ahunter2> dmwit:  I'm embedding a DSL for writing linear-programming expressions right now; trying to do it with operators so you can just write natural algebra syntax (while type-checking that you don't have x*why)
22:51:26 <dmwit> ahunter2: If you don't mind your operator being surrounded by (), then why not use exactly that trick?
22:51:42 <ahunter2> dmwit: prefix would be nice...
22:51:52 <dmwit> > let (!&$) x = product [2..] in (!&$) 32 -- it's prefix
22:51:57 <lambdabot>  Exception: Time limit exceeded
22:52:05 <ahunter2> o rly? :P
22:52:19 <ahunter2> ....ah, I see
22:52:32 <ahunter2> I mean, this is for unary negation... I might just add a "negate" function, which would be acceptable
22:52:44 <dmwit> :t negate
22:52:45 <lambdabot> forall a. (Num a) => a -> a
22:52:54 <olsner> dmwit: heh, oops, no time limit's big enough for the infinite factorial :D
22:52:58 <ahunter2> well, negate_prog or what have you.
22:53:06 <dmwit> olsner: oops =P
22:53:52 <dmwit> ahunter2: *nod*
22:54:24 <tibbe> mmorrow: great :)
22:54:53 <ahunter2> dmwit: fwiw, I was tempted to just add a Num instance for my terms, so you could just use +/*/etc but I realized that it would be worth using ^+^ ^/^ ^*^, or similar fake-math operators, so you could exploit typechecking to prevent trying to optimize a linear program for x*x...
22:55:04 <mmorrow> ahunter2: can you give me an example of one such expression where you use  some of these prefix operator that you have in mind? i wanna try something
22:55:05 <ahunter2> ...I think
22:55:21 <Pete_I> > let (!) x = product [1..n] in ((!) 4)
22:55:22 <lambdabot>  Exception: not a number
22:55:29 <Pete_I> ...what?
22:55:37 <dmwit> > let (!) x = product [1..x] in ((!) 4)
22:55:38 <lambdabot>  24
22:55:45 <dmwit> Pete_I: x on LHS, n on RHS
22:55:45 <ahunter2> mmorrow: how about 2 ^*^ x + 3 ^*^ z ^=^ ^-^ 3
22:55:51 <olsner> :t n
22:55:52 <lambdabot> Expr
22:56:05 <Pete_I> LHS? RHS? what are those?
22:56:13 <dmwit> left-hand side, right-HS
22:56:22 <mmorrow> ahunter2: perfect
22:56:43 <dmwit> ahunter2: Why not just type-restrict your solve function instead?
22:56:44 <Pete_I> oh...crap :D
22:56:56 <ahunter2> dmwit: ...hmm?
22:57:12 <dmwit> ahunter2: Why drop the Num instance?/
22:57:21 <ahunter2> dmwit: for what I have so far, which isn't much http://hpaste.org/9421
22:57:53 <ahunter2> the idea is that I'll have maximize :: ProgExpr -> [Constraint] -> <some type for solutions>
22:58:20 <ahunter2> and I'd like to write ProgExprs as, say, 2 ^*^ x + 3 ^*^ z ^=^ ^-^ 3, but make sure that x ^*^ z doesn't type check
22:58:28 <dmwit> I see no reason not to have a Num instance for ProgExpr there.
22:58:42 <dmwit> ...oh
22:59:06 <dmwit> Yeah, okay, I get it.
22:59:08 <ahunter2> dmwit: is this a stupid goal?
22:59:14 <dmwit> No, I get it.
23:00:05 <dmwit> It's too bad we don't have separate classes for +- and */...
23:00:34 * dmwit has a theory that very few type classes should have more than one function in them
23:00:35 <ahunter2> Numeric Prelude or whatever that idea is, seeming good?
23:01:27 <Cale> dmwit: Of course that would work better with class aliases.
23:02:12 <Cale> dmwit: It's also important to have a way to at least hint that a set of operations should satisfy some laws in conjunction with one another.
23:02:25 <dmwit> Yeah, those are the exceptions.
23:02:38 <dmwit> i.e. Monad
23:03:04 <ahunter2> mmorrow: OOcuriosity, what's your idea?
23:03:55 <Cale> even Num to some extent -- you'd like to be able to say that a*(b+c) = a*b + a*c, at least in some approximate sense :)
23:05:59 <dolio> Monad could be split, actually.
23:06:18 <dolio> Except that you might want to put join and bind in the same class, interdefined.
23:06:45 <luqui> Cale, I see laws talking about multiple classes (the dependency between Monad and Functor, for example) as a big weak point in the idea of typeclasses
23:07:05 <dolio> But return you can push down the stack into Applicative, or even make a pointed functor class.
23:07:07 <luqui> not that I have anything better, but it just doesn't handle that in any engineeringly stable way
23:07:45 <Nevmemoz> hi all!
23:08:57 <Cale> hi
23:09:11 <hml> ,
23:09:49 <ahunter2> For that matter, is there a reason that we don't have instance (Monad f) => Functor f where fmap x z = z >>= (return x)?
23:10:04 <opqdonut> yes, undecideability
23:10:15 <dolio> Yes, that's an overlapping instance.
23:10:24 <ahunter2> dolio: overlapping w/ what?
23:10:30 <dolio> Everything.
23:10:47 <Nevmemoz> ?
23:16:22 <luqui> ahunter2, specifically, overlapping with every Functor instance.
23:19:33 <mmorrow> ahunter2: heh, it involves modifying the haskell-src-exts parser ;) i'm messing with it anyways and trying to figure out all the moving parts. this'll be a good exercise to help me figure it out, w/ the nice side effect that it may be useful :) (if one were to go this route, they'd have to preprocess source code the translate it into valid syntax)
23:20:05 <mmorrow> no promises though!
