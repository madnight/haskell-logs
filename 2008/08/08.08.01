00:00:07 <dons> i mean, that's a lot of work right there, and its fairly modular now, so if you want to do quick web stuff, not a bad starting point.
00:00:23 <Twey> telexicon: Isn't it awesome?  :-P  And more importantly, wouldn't it be so ideally suited to being the de facto standard Haskell templating system?
00:00:43 <telexicon> genshi is useful because it makes sure there isnt people injecting stuff
00:00:51 <telexicon> and it makes sure your xml is well-formed
00:00:58 <dons> more bindings to fancier apis is always good. if huge systems are being built up without haskell bindings, we miss out on entire markets.
00:01:02 <telexicon> Twey, i think that style system would fit well with haskell
00:01:06 <dons> where are the gnome apps, for example.
00:01:11 <telexicon> i mean.. its a big data processing system
00:01:17 <Twey> Yeah
00:01:30 <Twey> It's useful because it's *smart*
00:01:40 <telexicon> generate :: String -> Map -> String
00:01:47 <Twey> Rather than just doing dumb text replacement and making you do everything yourself
00:01:51 <telexicon> yea
00:01:59 <telexicon> i also like it because
00:02:04 <telexicon> the inputs are valid xml
00:02:11 <dons> dogbite: btw, you should post a final clean code, written easily, using libs for that csv stuff -- since its sorted now. people are going to cite your first post for the next 6 months :/
00:02:12 <telexicon> i can use all my xml processing tools, xslt to build parts of things
00:02:24 <telexicon> i can even use xslt to build templates for genshi dynamically if i needed to
00:02:28 <telexicon> and then the output is tunable
00:02:32 <telexicon> html4, xhtml and xml
00:02:39 <telexicon> or even plain text if you wanted
00:02:42 <Twey> Yeah... and it integrates the dynamic bits *into* the template XML, rather than having it be some sort of meta-language
00:02:52 <telexicon> yea
00:03:33 <telexicon> it is slower than the text meta-language ones though
00:03:44 <Twey> Yeah
00:03:44 <telexicon> but that doesnt really bother me, i cache outputs anyways
00:03:48 * Twey nods.
00:03:56 <Twey> It's not slow enough that it's impractical
00:03:58 <Shiruka> it does only XML, not HTML?
00:04:04 <telexicon> i had it tuned so that it could handle about 600req/s on a 333mhz ultrasparc
00:04:12 <telexicon> Shiruka, the input is xml
00:04:18 <telexicon> Shiruka, but it can output html, xhtml or xml
00:04:23 <telexicon> you dont even have to change the input template
00:04:26 <telexicon> it just does the right thing
00:04:38 <Twey> Shiruka: The templates are XHTML + XIncludes + the Genshi XML namespace, but you can just tell it to output HTML and it'll transform it for you
00:04:41 <telexicon> you say.. i want you to output this as html, or xhtml.. and it makes sure its compatible
00:04:54 <Shiruka> ic
00:05:33 <telexicon> i dont know if im ready to move to haskell for web development though
00:05:34 <Twey> So you can take advantage of XML's features server-side, then transform it to HTML for browser compatibility
00:05:37 <Shiruka> I'm semi-allergic to XML, but that sounds potentially almost sane (maybe)
00:05:53 <olsner> almost certainly a sign of sanity
00:05:58 <telexicon> well you're going to have to write xml or psuedo-xml somewhere
00:06:03 <telexicon> if you're doing work with web stuff
00:06:06 <Twey> Unless it's Lisp
00:06:35 <telexicon> xml doesnt really bother me in general
00:06:40 <Shiruka> at least with django you can skip all but the unavoidable parts :-P
00:06:40 * Twey remembers (html:a :href "foo" (html:content "bar")) and shudders.
00:06:52 <telexicon> Shiruka, except
00:07:05 <Shiruka> re-encoding html in sexp form doesn't change things any
00:07:06 <telexicon> the templates are mostly the same as the output
00:07:22 <Twey> Django's templates have all the disadvantages I was talking about above, though
00:07:23 <telexicon> the only difference is you do like
00:07:45 <telexicon> well, it even lets you do, <p>${e.test}</p>
00:07:51 <Twey> You've got dumb text processing, with the dynamic stuff in a seperate dumbed-down meta-language
00:08:06 <telexicon> or you can do, <p py:content="e.test"/>
00:08:32 <chrisdone> Twey: does â€œbody << p << "hello" make you shudder?
00:08:56 <Shiruka> vaguely C++'ish :-P
00:08:58 <telexicon> D:
00:09:20 <telexicon> lets go out of our way to make data transformations completely sequential, imperative
00:09:21 <Twey> In Django, you'd go {{ if foo.bar }}<div class="somediv">Foo</div>{{ endif }} -- in Genshi it's <div py:if="foo.bar()">Foo</div>
00:09:47 <chrisdone> c++'s meaning has nothing to do with it
00:09:51 <Twey> Where that test is actual, proper Python, with no limits
00:09:59 <Twey> chrisdone: Depends how body and p are generated
00:10:22 <Twey> Basically, there's no better language for representing markup than markup.
00:10:39 <telexicon> the part i like about xml, is that i can write a schema and automatically validate all the outputs from the software
00:10:46 <Shiruka> sounds sensible, if you don't then need to do any strange extra xml situps
00:10:50 <chrisdone> Twey: well, they generate xhtml
00:11:10 <Twey> chrisdone: Yes
00:11:16 <Twey> What do you do when you want to style them?
00:11:26 <chrisdone> Twey: style them in what way?
00:11:29 <Shiruka> (like writing a 500KB configuration file in XML or something equally nutty)
00:11:33 <jsnx> telexicon: i like that, as well
00:11:35 <telexicon> Shiruka, as long as you arent doing crazy stuff like tables for layout.. its pretty clean
00:11:52 <jsnx> there is something displeasing about genshi's reliance on python
00:12:03 <Twey> jsnx: That's why we're suggesting porting it to Haskell :-P
00:12:05 <telexicon> jsnx, thats because it was written in python
00:12:22 <jsnx> Twey: it would be incompatible, then
00:12:24 <telexicon> so, somebody use similar ideas, improve it.. and port it to haskell
00:12:30 <telexicon> jsnx, huh?
00:12:31 <Twey> Yes
00:12:31 <jsnx> telexicon: XSLT was written in C and Java
00:12:39 <chrisdone> I suspect HXT can convert from XML to XHTML
00:12:42 <telexicon> XSLT can be implemented in any language
00:12:45 <jsnx> telexicon: you have to implement python to implement Genshi
00:12:47 <Twey> jsnx: Erm, I'm not getting the point
00:12:52 <Twey> Yes
00:12:56 <Twey> It would be incompatible
00:13:05 <Twey> We wouldn't have Python for the expressions, we'd use Haskell
00:13:07 <Twey> That's the point
00:13:14 <jsnx> telexicon: right, XSLT can be implemented in any language
00:13:14 <telexicon> jsnx, i dont see an issue with that
00:13:26 <telexicon> you replace the python parts with haskell parts
00:13:36 <telexicon> you take the ideas.. which are good.. and use those
00:13:37 <Twey> chrisdone: Not much help, XHTML can't be used for serious apps these days, because IE has no support for it
00:13:43 <jsnx> telexicon: but then what if i want to move my site from haskell to C?
00:13:48 <jsnx> how will i process those parts?
00:13:57 <telexicon> right
00:14:00 <jsnx> that is why XSLT is teh awesome
00:14:10 <telexicon> ok but XSLT doesnt do what genshi does
00:14:13 <chrisdone> yeah, HXT has XSLT
00:14:16 <telexicon> XSLT is xml -> xml
00:14:26 <Twey> jsnx: So, what, you'd *rather* have a crippled magic language (*cough PHP cough*) power your templates?
00:14:39 <telexicon> and on top of that
00:14:51 <telexicon> the data flow with xslt is, data -> xml -> xml
00:14:53 <jsnx> Twey: i'd rather have a purely declarative language power my templates
00:14:57 <telexicon> whereas with genshi its
00:15:03 <Twey> jsnx: So, Haskell?
00:15:05 <telexicon> data + template -> xml/xhtml/html
00:15:15 <Shiruka> porting python to haskell is likely to be less painful than using xslt anyway..
00:15:30 <jsnx> telexicon: i guess if you were willing to exclude IO operations from the templates
00:15:45 <telexicon> what IO operations?
00:15:55 <chrisdone> Twey: I'm not sure how one determines what IE supports
00:15:57 <jsnx> telexicon: just dump the HTML or text in a CDATA section and unwrap it at the end
00:15:57 <telexicon> generate :: String -> Map -> String
00:16:03 <Twey> jsnx: Well the template-embedded code wouldn't be running in the IO monad
00:16:09 <Twey> It would be purely functional
00:16:17 <chrisdone> Twey: what web browsers does Google's homepage support, and what language is that written in?
00:16:30 <Twey> chrisdone: That's messed-up HTML
00:16:38 <telexicon> google's homepage is pre-standard html
00:16:57 <chrisdone> Twey: so what browsers does it support?
00:17:00 <Twey> chrisdone: Well, you can determine what it *doesn't* support by sending it and seeing if it at least attempts to render it.  :-)
00:17:02 <jsnx> Twey: well, i could see that being manageable
00:17:17 <jsnx> if i wanted to insert the time, for example, how would i do it?
00:17:28 <Twey> It supports the error-correction modes of various current browsers
00:17:29 <telexicon> jsnx, honestly, i dont need the embedded execution of python parts
00:17:38 <jsnx> telexicon: oh?
00:17:41 <telexicon> jsnx, i like that the output format is tunable, and that it makes sure nothing is getting injected
00:17:58 <jsnx> telexicon: nothing is getting injected? can you explain more?
00:18:00 <telexicon> and that it ensures the output is well-formed
00:18:27 <telexicon> jsnx, if you do <p>${somevar}</p> it will escape somevar
00:18:49 <chrisdone> Twey: it seems to me that's the realistic state of things. so I don't see why you can't use XHTML if IE just parses it in its own fangled way, like it does everything else
00:18:58 <telexicon> you can turn that functionality off of course, but its just an extra layer to help prevent XSS
00:19:12 <jsnx> telexicon: well, that's neat
00:19:12 <Twey> chrisdone: Because it doesn't
00:19:25 <jsnx> telexicon: does genshi have "template variables"?
00:19:35 <telexicon> jsnx, what do you mean
00:19:45 <Twey> chrisdone: If you send XHTML, IE will not parse it (it gives a download box)
00:19:50 <telexicon> its true
00:19:52 <chrisdone> Twey: well, I can view XHTML pages with IE
00:19:55 <telexicon> IE pops up a download box
00:19:59 <telexicon> chrisdone, thats not xhtml
00:20:04 <chrisdone> the source is
00:20:04 <telexicon> chrisdone, thats xhtml sent as html
00:20:08 <chrisdone> you're missing the point
00:20:09 <telexicon> look at the mime type
00:20:10 <dpn``> that's xhtml parsed as html
00:20:11 <dpn``> :P
00:20:15 <Twey> chrisdone: You can't -- if you think you can, then you're serving it with the text/html MIME type, which means that it's actually just invalid HTML
00:20:15 <dpn``> look at the http headers
00:20:15 <chrisdone> Google's page isn't any standard html either
00:20:18 <chrisdone> but it works just fine
00:20:18 <jsnx> like, in XSLT, if you want to print the current time, you tell the template that it has a parameter t and then feed it t when you start the template
00:20:29 <telexicon> chrisdone, it works fine where?
00:20:39 <chrisdone> Twey: yes, invalid HTML, god forbid
00:20:47 <telexicon> it looks fine in IE, and FF, and maybe the others
00:20:49 <chrisdone> telexicon: are you asking me where google works?
00:20:49 <telexicon> but
00:21:00 <telexicon> it may not work fine in X standards compliant browser
00:21:02 <chrisdone> the places that matter
00:21:08 <chrisdone> telexicon: such as?
00:21:11 <telexicon> like mobile devices?
00:21:17 <telexicon> where they use who knows what
00:21:17 <jsnx> telexicon: each template is nominally a pure function of parameters and input XML to output XML
00:21:19 <chrisdone> yeah, did you know on mobile devices it sends XHTML?
00:21:41 <telexicon> chrisdone, i did not know that
00:21:49 <chrisdone> http://www.google.com/xhtml
00:21:49 <lambdabot> Title: Google
00:21:51 <telexicon> jsnx, yeah thats how it works
00:22:08 <telexicon> jsnx, you pass the template, and a dictionary
00:22:18 <jsnx> oh, got t
00:22:20 <telexicon> and it fills it all in
00:22:25 <jsnx> s/t$/it/
00:22:54 <telexicon> chrisdone, uh.. it doesnt even look close to the same
00:23:04 <chrisdone> telexicon: so?
00:23:07 <Twey> telexicon: It's XHTML Mobile
00:23:09 <Twey> (and valid)
00:23:09 <jsnx> i think it would be cool to do the port without any embedded execution of anything
00:23:09 <chrisdone> telexicon: it's a mboile phone
00:23:23 <telexicon> jsnx, yeah, that would be nice
00:23:26 <jsnx> telexicon: you have code that does this, though?
00:23:36 <telexicon> jsnx, that uses genshi?
00:23:39 <telexicon> chrisdone, ok
00:23:46 <Twey> jsnx: 'Without embedded execution of anything'?
00:23:52 <Twey> How do you intend to do if blocks?
00:23:52 <jsnx> i can't remember how much of this is a proposal and how much is a description of some project you were doing
00:24:14 <telexicon> Twey, i think he means, instead of triggering the interpreter to fill in certain areas
00:24:28 <telexicon> jsnx, genshi is somebody else's project
00:24:38 <telexicon> its used by trac iirc
00:24:42 <jsnx> telexicon: yes, i know
00:24:47 <Twey> telexicon: Yes, but that defeats the whole point
00:24:49 <telexicon> i just used it in a pylons app
00:24:52 <jsnx> telexicon: i thought you had built something with it
00:24:55 <telexicon> Twey, it does?
00:24:59 <jsnx> telexicon: oh, i understand
00:25:07 <Twey> One of Genshi's biggest advantages is that you *don't* get some crippled dedicated templating language
00:25:08 <chrisdone> Twey: so do you actually believe XHTML is unusable because IE doesn't parse it when served as XML?
00:25:16 <Twey> chrisdone: Of course it is unusable
00:25:25 <Twey> chrisdone: You can't use any of its features
00:25:30 <Twey> (if you intend to support IE)
00:25:42 <Twey> You might as well just be using HTML anyway
00:25:43 <jsnx> i think a nice template language is of value
00:26:04 <telexicon> yeah
00:26:10 <telexicon> i disagree with Twey
00:26:12 <chrisdone> Twey: well, I assumed we were talking about producing html
00:26:18 <jsnx> i do not think pulling in `if`, `case`, &c. is necessary
00:26:18 <telexicon> i dont really use embedded python at all in my genshi templates
00:26:34 <telexicon> jsnx, well its just if, for etc .. in a declarative way
00:26:47 <telexicon> but you need that part
00:26:49 <Twey> chrisdone: Uh?
00:26:51 <Twey> No
00:27:02 <jsnx> telexicon: yes
00:27:05 <telexicon> otherwise, how do you make a big list of items?
00:27:16 <jsnx> telexicon: map?
00:27:18 <jsnx> hehe
00:27:27 <telexicon> you need a way to multiply the xml parts
00:27:43 <jsnx> what about subordinate templates?
00:27:56 <Twey> jsnx: Accomplished via XIncludes
00:27:58 <jsnx> we will make a template interpreter, and templates can call each other recursively
00:28:12 <telexicon> :-/
00:28:14 <jsnx> Twey: that doesn't do recursive template calls, though
00:28:20 <telexicon> there goes the simple data flow model
00:28:23 <Twey> That's much uglier than Genshi's py:for
00:28:36 <Twey> Yeah, it gets one hell of a lot more complex
00:28:45 <jsnx> Twey: so you would like to port a python subset?
00:28:45 <Twey> Think of it in terms of replicate
00:28:55 <Twey> NO, jsnx, I would not like to port a Python subset
00:29:34 <telexicon> you are giving the behavior of if/for in a declarative way
00:29:37 <telexicon> you dont need any python
00:29:41 <telexicon> the input is standard xml
00:29:57 <jsnx> so, we introduce our own "if" and "for" elements
00:29:59 <Twey> Genshi syntax is: <div py:for="comment in comments"><div class="comment">${comment.title}</div></div>
00:30:08 <telexicon> jsnx, precisely, genshi puts them in its own namespace
00:30:16 <jsnx> yeah, by that py:for is actually python, right?
00:30:33 <jsnx> like you can put literal python in it?
00:30:35 <telexicon> it is what it is
00:30:56 <telexicon> i dont know.. i wouldnt
00:31:00 <Twey> The syntax I'd propose would be something like <div hsk:for="comment" hsk:seq="comments"><div class="comment">${title comment}</div></div>
00:31:07 <Twey> Yes, you can
00:31:24 <Twey> And you'd be able to put literal Haskell in the ported version
00:31:34 <telexicon> :(
00:31:50 <telexicon> i wouldnt want it to require an interpreter though
00:31:52 <jsnx> XSLT is much better than any of that
00:32:00 <jsnx> it is simple and elegant
00:32:04 <telexicon> jsnx, but what about the other features?
00:32:05 <jsnx> purely declarative
00:32:17 <jsnx> telexicon: write an escaper?
00:32:38 <Twey> jsnx: Haskell is also purely declarative (without IO)
00:32:40 <jsnx> a beautiful template language is more valuable than a beautiful escaper
00:32:53 <jsnx> Twey: haskell is not a template langauge
00:32:57 <Twey> XSLT is not simple
00:33:06 <Twey> Nor elegant, for many cases
00:33:14 <Twey> It is a Turing tarpit of a sort
00:33:27 <jsnx> it does the whole job of templating, in itself
00:33:28 <telexicon> jsnx, and the conversion to xhtml/html4 ?
00:33:35 <jsnx> telexicon: CDATA sections
00:33:47 <telexicon> thats not automatic
00:34:13 <jsnx> neither is the conversion of <your template format here> to <anything else>
00:34:22 * Twey twitches.
00:34:25 <Twey> CDATA sections?
00:34:28 <telexicon> um
00:34:28 <Twey> CDATA sections?!
00:34:29 <telexicon> yeah it is
00:34:30 <jsnx> yes
00:34:37 <Twey> Yes, it is, jsnx
00:34:40 <telexicon> genshi just does it
00:34:44 <telexicon> you give it your xml template
00:34:53 <telexicon> and it outputs it in whichever dialect you ask it to
00:34:54 <jsnx> telexicon: was it simple for them?
00:35:04 <telexicon> making all the necessary conversions
00:35:08 <jsnx> remember, we will have to reimplement that for the library
00:35:14 <telexicon> i dont know
00:35:18 <telexicon> does haskell have an html parser?
00:35:29 <jsnx> probably
00:35:29 <luqui> tagsoup?
00:35:36 <telexicon> no, doesnt need to handle soup
00:35:43 <telexicon> just output good html
00:35:45 <Twey> Yes, jsnx
00:35:57 <jsnx> anyways, i can see value in what you guys want to do
00:35:57 <Twey> The templates are represented as streams internally
00:36:01 <luqui> I was actually mentioning the name of a library, "tagsoup"
00:36:12 <Twey> It's just as easy to represent them as HTML as it is XHTML
00:36:16 <jsnx> i will be interested to see how you avert the plague of evals
00:36:29 <jsnx> maybe you'll have to compile templates to haskell or something
00:37:17 <jsnx> the closer we get to a pure genshi, the closer we get to reimplementing XSLT
00:37:31 <Twey> No
00:37:34 <Twey> Genshi *uses* XSLT
00:37:48 <jsnx> but if it is pure, it can not have haskell in it
00:37:51 <chrisdone> maybe it's time for #haskell-blah
00:38:10 <jsnx> all in favor?
00:38:21 <jsnx> say aye
00:38:32 <Twey> To #haskell-blah or Haskellless templating?
00:38:44 <jsnx> #haskell-blah
00:39:06 <Twey> Aye
00:39:17 <telexicon> which is the haskell xml library to use?
00:39:51 <chrisdone> telexicon: what do you want to do with it?
00:39:58 <Twey> HaXml is the de-facto standard, isn't it?
00:40:23 <chrisdone> telexicon: there are a few, `xml' is nice and simple. HXT is a beast, with XPath -- good for extracting things from documents like web pages etc.
00:40:52 <telexicon> which has xpath and xslt?
00:40:56 <chrisdone> HaXml doesn't have XPath, it has some weird version of it
00:41:01 <chrisdone> HXT has those
00:41:18 <telexicon> ok
00:41:21 <chrisdone> http://www.fh-wedel.de/~si/HXmlToolbox/index.html and http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
00:41:23 <lambdabot> Title: Haskell XML Toolbox 8.1.1
00:42:08 * BeelsebobWork ponders why anyone sane enough to use Haskell would ever use XML too
00:42:46 <chrisdone> BeelsebobWork: because other people store information we want to use in XML
00:42:59 <BeelsebobWork> poor you :(
00:43:03 <telexicon> because having my output formats auto-validated is convenient
00:43:30 <BeelsebobWork> so use show'n Haskell data structures
00:43:37 <BeelsebobWork> they're auto-validated, and a lot less verbose
00:43:56 <telexicon> and i have to talk with the rest of the world
00:48:35 <mxc> anyone use proto buffers?
00:48:52 <Twey> BeelsebobWork: Are you one of those in favour of representing HTML in Haskell as body << p << class "foo" << "some content", then?
00:49:09 <Twey> I can't think of any better way to represent HTML than XML, personally
00:49:11 <BeelsebobWork> why the random infix operators?
00:49:24 <glguy> mxc: superficially
00:49:40 <erikc> Twey: relationally with tables for each tag and link tables
00:49:47 <BeelsebobWork> Html (Head (Title "jam")) (Body (Div (P "random stuff)))
00:49:50 <erikc> is a better way
00:49:59 <BeelsebobWork> plus some combinators to create useful patterns
00:49:59 <mxc> wondering how they compare with Data.Binary and XmlContent for [de]marshalling
00:50:01 <erikc> link tables for the hierarchy
00:50:07 <BeelsebobWork> or in fact -- just redesign the language a good chunk
00:50:16 <mxc> probably between the two in terms of speed and compatiblility
00:51:10 <Twey> BeelsebobWork: Urgh :-\
00:51:21 <Twey> Yes, 'redesign the language' sounds lovely, but not very practical :-)
00:51:28 <BeelsebobWork> Twey: agreed
00:51:32 <jsnx> BeelsebobWork: i think working with a subset is wise
00:51:42 <glguy> mxc: I think that they all fit unique enough roles
00:51:42 <BeelsebobWork> but Html (Head (Title "jam")) (Body (Div (P "random stuff))) + combinators is a good intermediary
00:51:48 <glguy> that there isn't much overlap
00:51:52 <BeelsebobWork> you at least get the smaller, more consistant syntax then
00:51:57 <erikc> it depresses me how hierarchal data continues to trump relational data
00:52:09 <chrisdone> BeelsebobWork: how do you have an empty element?
00:52:31 <BeelsebobWork> chrisdone: you include Empty as an element of the ADT?
00:52:31 <jsnx> erikc: why?
00:52:38 <BeelsebobWork> the same way as it's done in all other ADTs
00:52:43 <chrisdone> BeelsebobWork: Terrible!
00:52:53 <BeelsebobWork> chrisdone: so list is terrible, because it's got [] in the ADT?
00:53:12 <erikc> jsnx: relational can model more forms of data
00:53:21 <chrisdone> BeelsebobWork: no, list isn't
00:53:33 <chrisdone> BeelsebobWork: how would you write <br/>?
00:53:57 <jsnx> erikc: so you would have an HTML document be a deductive database, then?
00:54:01 <chrisdone> BeelsebobWork: <textarea/>, etc.
00:54:05 <BeelsebobWork> chrisdone: I would imagine that a P would be made up of a list of strings
00:54:07 <jsnx> not such a bad thing, actually
00:54:08 <erikc> sure
00:54:17 <BeelsebobWork> and that would be (TextArea Empty)
00:54:20 <erikc> and you can do joins to recreate the hierarchy and spit the html back out
00:54:30 <BeelsebobWork> which I'm sure you could come up with a combinator shorthand for
00:54:36 <jsnx> erikc: indeed
00:55:39 <jsnx> so, we could get parameters into this kind of template by appending relations to the database
00:56:11 <jsnx> and we could change the class of all the paragraphs with a class "foo" to a class "bar", too
00:56:16 <erikc> yea
00:56:38 <jsnx> that is much better than all this other stuff
00:57:25 <jsnx> okay, so now i need to go read about how to implement datalog in haskell
00:58:27 <Twey> BeelsebobWork: Don't see how that's at all good :-\
00:58:42 <erikc> ive been meaning to check whether HApps-Ixset implements the relational algebra, hard to tell from the meager docs
00:59:12 <BeelsebobWork> Twey: it's a lot smaller, less cluttered with syntax, and easier to work with than html
00:59:14 <erikc> but one of my todo projects is a "D" library (as in http://www.thethirdmanifesto.com/) for haskell
00:59:15 <lambdabot> Title: The Third Manifesto
00:59:19 <BeelsebobWork> otoh... it could do with a complete redesign
00:59:40 <erikc> so a datalog, basically
01:00:11 <chrisdone> BeelsebobWork: I think you'd need a class for that, like class HTML a where toHtml :: a -> Html, instance HTML Html where toHtml = id, instance HTML String where toHtml = String "", or something. then you could have instances similar to Show, like instance HTML Person where toHtml (Person name) = (Cons (B "Name:") name)
01:08:10 <chrisdone> *HTML> (Cons (B "Name:") "George")
01:08:10 <chrisdone> <b>Name:</b>George
01:08:11 <chrisdone> like that
01:10:08 <chrisdone> HTML> Person "dave"
01:10:08 <chrisdone> Person {name = "dave"}
01:10:08 <chrisdone> *HTML> (P (Person "dave"))
01:10:08 <chrisdone> <p><b>Name:</b>dave</p>
01:10:59 <chrisdone> sorry. it sounded interesting. http://hpaste.org/9304
01:19:19 <magthe> good morning!
01:24:26 <BeelsebobWork> chrisdone: as I said -- +combinators
01:24:37 <BeelsebobWork> sorry, boss grabbed my attention
01:26:12 <glguy> Beelsebob: tell him to go to bed, that it is 1:26 in the morning
01:27:40 <vincenz> chrisdone: why use existentals?
01:28:46 <glguy> If your class has only one method
01:28:52 <glguy> no sense in delaying its application
01:29:48 <dolio> The only method is one that turns it into the existential. :)
01:29:49 <Twey> There is sense, in that it's useful to be able to treat it as a tree
01:30:24 <glguy> no
01:30:24 <glguy> http://hpaste.org/9304#a1
01:30:26 <glguy> like this
01:30:41 <glguy> with a single method class you are just delaying the inevitable
01:32:16 <chrisdone> glguy: could you paste something that compiles?
01:32:38 * Twey doesn't quite understand -- there are sure to be other methods on an instance
01:33:33 <dolio> If the only thing you know about something is that it's in the class HTML, and the only thing you can do with something in that class is turn it into an Html, then there's no advantage to not just having an Html.
01:33:49 <dolio> Unless the other thing takes significantly less memory or something.
01:34:20 <glguy> http://hpaste.org/9304#a2
01:34:23 <chrisdone> the point of the class was so you could write (P "hello") instead of (P (String "hello"))
01:34:33 <glguy> chrisdone: look at the paste
01:35:23 <chrisdone> yeah.. I was kind of avoiding writing a function for every constructor
01:37:01 <chrisdone> but yeah, if you're not addressing that problem, it looks like a nice way to write html code
01:37:24 <glguy> What are you trying to do that the xhtml library doesn't?
01:37:37 <chrisdone> glguy: it's just a different way of writing it
01:38:07 <glguy> so its exploratory / educational
01:38:10 <glguy> ?
01:38:12 <chrisdone> glguy: though, I'm not sure the xhtml library lets you take a whole tree of xhtml and manipulate it, its combinators are like ShowS, IIRC
01:38:17 <chrisdone> glguy: yeah
01:38:42 <chrisdone> glguy: I just made it after BeelsebobWork mentioned it
01:39:08 <chylli> :t lift
01:39:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
01:39:24 <chylli> :t liftIO
01:39:24 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:42:03 <chrisdone> well, if Text.XHtml.Internals was exposed, then you could manipulate existing XHTML like a transformation
01:42:06 <chrisdone> good stuff
01:43:33 <chrisdone> (but if you're doing that you may as well use HXT and use proper XSLT)
01:53:37 <chrisdone> Twey: ping
01:57:12 <Twey> chrisdone: Pong
01:58:17 <chrisdone> Twey: if you want to discuss some haskell web programming ideas, join #webhaskell :)
01:58:35 <Shiruka> wah, the channels multiply like wabbits
01:58:43 <chrisdone> haha
01:59:51 <glguy> http://hpaste.org/9305
02:01:51 <masak> has someone ever written an in-place quicksort in Haskell?
02:02:07 <BeelsebobWork> the HOpenGL package has no maintainer at the moment, does it?
02:02:25 <BeelsebobWork> masak: in-place makes no sense in Haskell -- it involves mutation
02:02:31 <BeelsebobWork> Haskell is all about not doing mutation
02:02:34 <osfameron> masak: unsafeQuickSort ?
02:02:51 <masak> BeelsebobWork: I know that. but I recently learned about the State monad
02:03:07 <BeelsebobWork> yes, and the state monad is all about making sure you don't do mutation
02:03:09 <hansfbaier> masak: that was my thought too.
02:03:10 <BeelsebobWork> but making it look like you do
02:03:36 <masak> BeelsebobWork: so what are we quarreling about. all that's required is that it looks like you're mutating
02:03:47 <hansfbaier> probably tha plain haskell qsort may be more efficient ...
02:04:00 <BeelsebobWork> masak: well no -- the point of in-place qsort is presumable to save RAM by never duplicating the list
02:04:08 <ToRA> if you want in place quicksort you would need to be in the context of st arrays or io arrays in haskell
02:04:13 <BeelsebobWork> but even something that *looks* like it's in place in the state monad will in fact not be
02:04:46 <pozic> masak: yes, you can write inplace quicksort in the ST monad.
02:05:04 <pozic> masak: Lennart has done so already.
02:05:12 <BeelsebobWork> in reality, all quicksorts in haskell will be close to in place though, assuming nothing holds onto the input -- the garbage collector will clean up at the same rate as you move stuff about
02:05:13 <masak> BeelsebobWork: I'm aware that the exercise might be pointless from an efficiency point of view. I was just interested in how similar one could get algorithm-wise to the in-place quicksorts in imperative langugages
02:05:21 <masak> pozic: URL?
02:05:30 <pozic> masak: google lennart quicksort
02:05:37 <BeelsebobWork> masak: yes -- I'm just saying... why?  Why try to be like an imperative language?
02:05:49 <BeelsebobWork> when you can get the memory bonus from garbage collection, and never have to look ugly
02:05:59 <masak> BeelsebobWork: to compare and learn.
02:06:13 <pozic> BeelsebobWork: to save a log n factor?
02:06:21 <pozic> BeelsebobWork: or even more.
02:06:27 <BeelsebobWork> pozic: how?
02:06:42 <masak> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
02:06:43 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
02:06:51 <pozic> BeelsebobWork: for sorting there is merge-sort, but there are other problems.
02:07:15 <BeelsebobWork> pozic: no, how is in-place quicksort gonna save log n over quicksort?
02:07:29 <pozic> BeelsebobWork: it won't.
02:07:33 <BeelsebobWork> exactly
02:07:50 <BeelsebobWork> so in Haskell you gain nothing by writing an in-place version other than sticking it into an ugly, unnecessary monad
02:07:57 <pozic> BeelsebobWork: I was talking about why one would not always use a functional algorithm.
02:08:00 <BeelsebobWork> code bloat and no benefit
02:08:06 <BeelsebobWork> pozic: ah, I see
02:08:32 <pozic> BeelsebobWork: and since the compilers are not omniscious, reality sometimes kicks in.
02:08:35 <Shiruka> you could try to improve on the speed of plain merge sort while keeping the code clean and obviously correct
02:08:39 <pozic> omniscient*
02:08:47 <BeelsebobWork> pozic: I've not found the point where reality kicks in yet
02:08:51 <Shiruka> and then submit that for inclusion to GHC :-P
02:09:13 <Shiruka> (GHC uses very plain merge sort)
02:09:15 <pozic> BeelsebobWork: I have.
02:09:57 <BeelsebobWork> pozic: I won't be convinced that such a point exists until it's proved to me -- so far, every time someone's said to me "you need to do this imperatively", they just haven't been imaginative enough to see the functional solution
02:10:43 <BeelsebobWork> (and that includes me)
02:12:55 <Shiruka> in-place sort would make sense for STUArrays and the like, though
02:13:38 * osfameron always reads that as STFUArrays :-(
02:13:48 <Shiruka> :-D
02:14:00 <__pao__> glguy: what is the code you pasted?
02:14:25 <glguy> http://www.lri.fr/~filliatr/ftp/publis/puf-wml07.ps
02:14:27 <glguy> inspired by that paper
02:14:29 <glguy> just playing around
02:15:19 <__pao__> glguy: so you are Eric Meyer ;-)
02:15:27 <glguy> no
02:15:49 <glguy> There's a joke in there that I don't understand :-p
02:16:02 <__pao__> s/Meyer/Mertens/ sorry...
02:20:39 <glguy> Oh, yeah, that's me :)
02:25:11 <magthe> Bjorn Bringert doesn't happen to be here?
02:27:05 <sjanssen> preflex: seen bringert
02:27:05 <preflex>  bringert was last seen on #ghc 11 days, 18 hours, 12 minutes and 53 seconds ago, saying: dcoutts: sounds ok
02:28:10 <pozic> BeelsebobWork: when is something functional? Can one use DiffArray or not? If one cannot, and one doesn't generate Haskell code at run-time, then it's simply not going to work for graphs.
02:29:07 <pozic> BeelsebobWork: the compiler also doesn't scale to large inputfiles, so the latter is not even practical.
02:30:47 <BeelsebobWork> pozic: I'm gonna default to a rather nice definition that conal gave for when a program is "functional" as opposed to just written in a functional language... It's functional when it's simple, compositional, and easily verified
02:31:57 <pozic> BeelsebobWork: is something in the Render monad functional?
02:32:16 <BeelsebobWork> pozic: I'm not sure -- the render monad is not something I've looked at
02:32:36 <pozic> All notions of "functional" are arbitrary.
02:32:41 <BeelsebobWork> yes
02:32:50 <BeelsebobWork> in the same way as all notions of "nice code" are arbitrary
02:32:52 <pozic> That is my opinion at least.
02:32:57 <sjanssen> pozic: the Render Monad from Cairo?  I would say that is not very compositional
02:33:04 <BeelsebobWork> doesn't mean that it's not a valuable measure
02:33:19 <pozic> sjanssen: you can compose two render actions together to get a new one.
02:33:30 <pozic> sjanssen: in that sense it is compositional.
02:33:58 <pozic> Most "functional" code has an extra layer of indirection in it.
02:34:16 <pozic> So, that instead of rendering to the screen directly, you get some in memory respresentation.
02:34:17 <BeelsebobWork> the idea of "actions" imediately screams non-compositional to me
02:34:39 <BeelsebobWork> you should be describing data, not actions
02:34:41 <pozic> Most people consider that to be more "functional".
02:34:56 <sjanssen> pozic: sequencing is not the nicest composition, IMO
02:35:28 <Shiruka> sequencing tends to overspecify
02:35:42 <pozic> But sequencing happens when you call a function: reverse ([1,2]).
02:36:35 <BeelsebobWork> yes -- but you didn't write the sequencing
02:36:38 <BeelsebobWork> you didn't specify it
02:36:38 <Shiruka> because the number of possible different orders rises very fast as a function of the number of operations, and it's unlikely that a huge proportion of them would really be incorrect
02:37:07 <pozic> BeelsebobWork: who says the render monad needs to sequence it in a certain way?
02:37:20 <pozic> BeelsebobWork: that too could contain domain specific optimizations.
02:37:20 <BeelsebobWork> pozic: you did -- you used the sequence composition
02:38:01 <pozic> BeelsebobWork: but reverse also is "sequential" in the same way.
02:38:05 <sjanssen> pozic: functions like setFontSize, moveTo, etc. essentially require sequence
02:38:09 <BeelsebobWork> no it isn't pozic
02:38:19 <BeelsebobWork> you never write what order things should work in with reverse
02:38:36 <BeelsebobWork> ah, so there's setFontSize -- it's not compositional then
02:38:59 <BeelsebobWork> because if I have a function that sets the font size, I can't arbitrarily compose it with other operations and expect them to keep doing the same thing
02:39:09 <pozic> What's the difference between <foo>; setFontSize; and record{setFontSize = value}?
02:39:30 <Shiruka> reverse ([1,2]) won't necessarily be evaluated immediately
02:39:38 <pozic> They are the same thing, it's just that the latter version is factored better.
02:39:43 <BeelsebobWork> one of them represents a sequence of actions, and the other represents the existance of a piece of data with a certain font size
02:40:01 <BeelsebobWork> the latter is compositional -- in taht I can attach another thing with a different font size to it
02:40:04 <pozic> That is "functional"  code often is better factored, although that also doesn't have to be the case.
02:40:11 <Shiruka> and non-strictness gives rise to multiple possible orders to evaluate (even if in practice lazy eval is used)
02:40:58 <audreyt> @seen dcoutts_
02:40:59 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
02:41:00 <Shiruka> .. hm, and even lazy eval doesn't specify much of the order
02:41:12 <dolio> preflex: seen dcoutts_
02:41:12 <preflex>  dcoutts_ was last seen on #haskell 9 hours, 4 minutes and 19 seconds ago, saying: I still don't understand call cc and I've written several cont monad style things
02:41:45 <BeelsebobWork> Shiruka: nah, it very much specifies an evaluation order -- it's just the order that one function is evaluated in depends on what surrounds it
02:41:56 <BeelsebobWork> but yeh, that's an implementation detail of the language
02:41:58 <BeelsebobWork> not of your program
02:42:02 <BeelsebobWork> which is the important thing
02:42:02 <sjanssen> @src reverse
02:42:03 <lambdabot> reverse = foldl (flip (:)) []
02:42:35 <sjanssen> hey look, the only valid use of foldl ever!
02:42:43 <dolio> Heh.
02:43:15 <Shiruka> using flip is cheating
02:43:18 <Twey> Hahaha, sjanssen
02:43:31 <Twey> Can XHtml output HTML?
02:43:36 <dolio> Cheating?
02:44:00 <Shiruka> makes it like foldr, just reverse :-p
02:46:21 <Shiruka> ... hm, that was not a very clear thought
02:46:45 <pozic> BeelsebobWork: An Action-oriented library induces monad transformers to enable compositional use of the library and a data oriented library doesn't. Data is easier to use in Haskell. Would you agree with that?
02:46:46 <sjanssen> foldl is just foldr in disguise anyway
02:46:48 * Shiruka is getting too old to pull all-nighters, it seems
02:49:11 <pozic> Is there a nice solution to remove innermost empty lists generically using some Haskell extensions? That is f [[[[]]],[[['a']]]] returns ['a']?
02:49:34 <sjanssen> @type  [[[[]]],[[['a']]]]
02:49:44 <pozic> Er returns [[[['a']]]]
02:49:49 <lambdabot> thread killed
02:50:33 <pozic> It should work for every nesting depth of course.
02:50:37 <sjanssen> pozic: it is possible, but a little tricky
02:51:30 <sjanssen> can you constrain yourself to just a few base types?
02:51:57 <pozic> sjanssen: for what?
02:52:17 <sjanssen> pozic: eg. 'a' is your base there
02:52:35 <pozic> sjanssen: I only need it for base types at first.
02:55:04 <pozic> sjanssen: the strafunski has no documentation and reading a paper for every library is no good.
02:56:13 <sjanssen> pozic: this can be done with type classes
02:56:17 * sjanssen is hacking it up real quick
02:57:04 <sjanssen> what should the function do with [[], []]?
02:57:20 <sjanssen> nevermind, that is obvious
02:58:00 <pozic> sjanssen: the PrintArgs trick?
03:00:30 <sjanssen> pozic: http://hpaste.org/9307
03:02:23 <pozic> sjanssen: you are using one of the most evil extensions, but thanks.
03:02:43 <sjanssen> pozic: this is why I asked about a fixed set of base types
03:03:11 <sjanssen> you can replace the overlapping instance with an instance for each non-list type involved
03:04:30 <sjanssen> http://hpaste.org/9307#a1
03:05:10 <sjanssen> oh, and that doesn't require FlexibleInstances either -- pure Haskell '98
03:05:20 <sjanssen> type classes ftw
03:47:29 * _zenon_ listens at the silence
03:51:54 <the_ez> hi folks.
03:52:04 <the_ez> i'm trying to install cabal
03:52:26 <the_ez> the first point of confusion is that there are two downloads on the site at http://www.haskell.org/cabal/download.html
03:52:26 <lambdabot> Title: The Haskell Cabal
03:52:57 <the_ez> one of them (Cabal) has installation instructions, which I followed & they seemed to work
03:53:07 <the_ez> but I don't have a "cabal" executable
03:53:22 <the_ez> the other one (cabal-install) hasn't any installation instructions.
03:57:47 <Deewiant> the_ez: the "cabal" executable is cabal-install
03:57:59 <Axman6> the_ez: think you need to cd into the cabal-install dir, ghc --make Setup.hs, ./Setup configure... then some other stuff
03:58:12 <Deewiant> ./Setup configure, ./Setup build, ./Setup install
04:07:55 <fons> can anyone with a recent HEAD version of GHC try this? http://hpaste.org/9308
04:08:13 <fons> I want to confirm it before creating a ticket in GHC?s trac
04:11:10 <the_ez> Axm6, Deewiant: ok. Now ./Setup configure in the cabal-install dir complains,
04:11:10 <the_ez> Setup: At least the following dependencies are missing:
04:11:10 <the_ez> Cabal >=1.4 && <1.5, HTTP >=3000 && <3002, zlib >=0.4
04:11:50 <Deewiant> So you need to go and get them and install them. (what cabal-install would do for you automatically if you would have it)
04:12:15 <Deewiant> and evidently your Cabal installation didn't quite work out since it says it's missing
04:12:29 <the_ez> right; i suspect some problem with paths
04:16:40 <the_ez> one thing i would suggest is that the landing page for Cabal somehow explain the two downloads. a neophyte is left wondering what to do & whether time will be wasted downloading the wrong one.
04:17:31 <Deewiant> I agree, I was confused about it as well when I first got it
04:22:17 <Axman6> the_ez: when i installed it, i was told it's worth going through the pain of setting it up the first time to make setting everything else uo easier
04:22:17 <the_ez> ah splendid, got it worked out
04:22:30 <the_ez> i installed the dependencies (zlib and HTTP) by hand--not much trouble.
04:23:06 <the_ez> the issue with the Cabal package must have been due to an erroneous installation (maybe I forget to say sudo)
04:23:18 <the_ez> it was resolved when i went through it again; so now I have cabal.
04:23:23 <the_ez> thanks all!
04:26:22 <DrSyzygy> byorgey: Thanks for the correction!
04:47:06 <ivanm> how do Data.Graph graphs compare to FGL graphs?
04:47:37 <ivanm> I've been using the latter for my thesis, but just realised that I'm only using it as a data structure and basically re-writing all the algorithms myself because they don't work like I want them to :s
04:48:11 <ivanm> the only thing I'm really using from FGL is match and matchAny...
04:49:20 <Cale> Data.Graph uses an array from vertices to lists of vertices.
04:49:32 <Cale> (adjacency)
04:49:50 <Cale> Personally I find using  Map Vertex (Set Vertex)  more pleasant.
04:51:08 <ivanm> hmmm....
04:51:42 <ivanm> reason I'm not using FGL's algorithms is because in the most part I want to get out the resulting subgraph, whereas it just spits out a list of nodes :s
04:54:45 <Cale> I suppose you could get the edges from the current graph and mkUGraph
05:00:06 <pozic> sjanssen: what about  given [[1],[2]] return [1,2] given [[1]] return 1?
05:00:38 <dcoutts> audreyt: pong
05:01:29 <pozic> sjanssen: the problem here is that before the call, the result type is unknown.
05:01:59 <audreyt> dcoutts: technical question.
05:02:07 <audreyt> people want a standalone Pugs tarball.
05:02:16 <audreyt> that requires nothing more than GHC 6.8 to install
05:02:29 <audreyt> we now bundle Cabal, cabal-install, zlib, HTTP, and use automated installation to detect and install those.
05:02:32 <audreyt> that was easy and done.
05:02:43 <audreyt> the nontrivial part is telling "cabal update" to look at file:///
05:02:53 <audreyt> without invasively rewriting the user's ~/.cabal/config.
05:03:01 <audreyt> if we can do that then we can bundle a mini-hackage
05:03:06 <audreyt> with only pugs's deps
05:03:08 <dcoutts> audreyt: ok, bundling all the pugs packages
05:03:14 <audreyt> and then tell cabal-install to resolve from there.
05:03:18 <audreyt> end of question.
05:04:04 <audreyt> fwiw, in the perl land we have CPAN::Mini and CPAN::Inject to do just that.
05:04:29 <dcoutts> audreyt: I suppose you could customise your bundled cabal-install to use a different config, eg ~/.pugs/something
05:04:53 <dcoutts> audreyt: and cabal-install does support file:/// paths in its index.
05:05:05 <audreyt> but that wouldn't be cabal-install
05:05:07 <audreyt> would it
05:05:17 <dcoutts> audreyt: well, no, it'd be a copy
05:05:25 <audreyt> so pugs-cabal-install or something
05:05:36 <audreyt> but it seems strange to do that just for one line that can easily be read from environment.
05:05:53 <audreyt> export CABAL_CONFIG_FILE = ...
05:06:04 <audreyt> wouldn't that seem more natural?
05:06:15 <dcoutts> audreyt: and how does that get set?
05:06:34 <audreyt> in our makefile
05:06:42 <dcoutts> audreyt: so you want a cabal-install because you want pugs users to be able to get auto updates?
05:06:53 <dcoutts> audreyt: or are you just trying to make a simple easy to build pugs?
05:06:57 <audreyt> the latter
05:06:58 <pozic> sjanssen: I already got an idea
05:07:04 <audreyt> I can hard-code the dependency chain
05:07:12 <audreyt> and hand-write the version dep resolver again
05:07:17 <dcoutts> audreyt: as you could just have a script to combine all the pugs packages into one
05:07:27 <audreyt> I can do that?
05:07:33 <dcoutts> audreyt: a package merge
05:07:45 <audreyt> but then it'd include things like "binary" and "utf8-strict"
05:07:47 <dcoutts> audreyt: there's nothing automatics to do it, but it's in principle possible
05:07:56 <audreyt> which I'd like to not install if the user already has later versions available
05:08:04 <dcoutts> audreyt: sure, you'd have to bundle all deps
05:08:05 <audreyt> er, "utf8-string"
05:08:16 <audreyt> ok, in which case I need no cabal-install
05:08:22 <dcoutts> audreyt: indeed
05:08:27 <audreyt> so does Cabal support subpackages?
05:08:35 <dcoutts> audreyt: all the ones that you cannot be sure are installed
05:08:39 <dcoutts> audreyt: no, it doesn't
05:08:51 <audreyt> or do you mean by "run each Custom Setup.lhs in turn"
05:08:58 <dcoutts> audreyt: no, I mean merging
05:09:07 <audreyt> yes, but suppose you merge package A and B
05:09:10 <audreyt> each is build-type: custom
05:09:14 <audreyt> each has its own Setup.lhs
05:09:18 <audreyt> what then?
05:09:27 <dcoutts> audreyt: custom Setup.hs scripts does make it harder
05:09:47 <dcoutts> audreyt: for the rest, it'd be: eg hs-src-dirs: pugs, thing, other
05:09:54 <SamB_XP> well, just solve the halting problem and you should be all set
05:10:06 <dcoutts> audreyt: other-modules: ... just list all the modules from all the packages
05:10:09 <audreyt> SamB_XP: that's easy, you just turn off the power and it's solved
05:10:25 <audreyt> dcoutts: but there are already a few custom Setup.hs
05:10:37 <audreyt> so it doesn't look like a convenient solution
05:10:48 <dcoutts> audreyt: yeah, so maintaining a merged Setup.hs would be less fun.
05:11:04 <dcoutts> audreyt: a program to merge build-type: Simple could be automatic
05:11:18 <dcoutts> audreyt: remind me why you'd need a different ~/.cabal/config ?
05:12:10 <audreyt> dcoutts: a custom 00-index.tar.gz.
05:12:30 <audreyt> a subset of the hackage one, that is.
05:12:51 <ivanm> dcoutts: that reminds me, is it possible to install non-hackage packages using cabal-install?
05:13:01 <audreyt> I'm going for "temporarily fudge ~/.cabal/config" for now
05:13:07 <dcoutts> audreyt: ah, so you only need that once, during the install and not thereafter ?
05:13:07 <audreyt> but just want to check with you about the sanity of it
05:13:11 <audreyt> correct.
05:13:19 <dcoutts> audreyt: aahh, much easier then
05:14:15 <dcoutts> audreyt: we used to have a command line flag to specify the config file, but it got removed during some other changes. We could re-instate that. Or we could add a flag to specify another hackage server (eg local file://)
05:14:43 <dcoutts> audreyt: cabal-install can be configured to use multiple servers, though we've not played much with local ones yet.
05:14:45 <audreyt> a command line flag would be much better.
05:14:56 <audreyt> cabal --with-repo=file:///...
05:15:39 <dcoutts> audreyt: note also, that this should just be a short-term solution. The plan for ghc-6.10 is to move to the Haskell Platform being the primary thing end users download, and that'd bundle cabal-install.
05:15:53 <audreyt> I'm aware of that
05:16:30 <audreyt> so I'm even more motivated to see cabal-install able to deal with local/transient repos
05:16:35 <audreyt> before it's made part of HLP proper
05:16:55 <dcoutts> audreyt: sure, perhaps you'd like to send us some patches :-)
05:17:02 <MyCatVerbs> dcoutts: frankly, I'm disappointed at the very concept of a "short term solution">
05:17:25 <audreyt> dcoutts: that I will do, just trying out the design with you :)
05:17:29 <audreyt> so --with-repo is fine?
05:17:31 <MyCatVerbs> dcoutts: these kinds of problems demand at the very least a colloidial suspension.
05:17:33 <dcoutts> audreyt: so there are two approaches then, one is to specify an alternate config file, eg see Main.hs:
05:17:34 <dcoutts>   configFile <- defaultConfigFile --FIXME
05:17:54 <dcoutts> that's where we removed support for having the config file specified on the command line
05:18:49 <dcoutts> audreyt: and then in Distribution.Client.Types, we have AvailablePackageSource = LocalUnpackedPackage | RepoTarballPackage Repo
05:18:56 <SamB_XP> MyCatVerbs: hahahaha
05:19:27 <dcoutts> audreyt: however for a local repo, we probably want a third alternative. Because we do not need to copy and cache the index or tarballs locally.
05:19:50 <MyCatVerbs> SamB_XP: \o/ I have amused someone! My life is complete.
05:20:22 <dcoutts> audreyt: I mean you could use RepoTarballPackage Repo, and specify a file::/ uri, but that also needs a local cache dir which seems rather pointless.
05:21:21 <nominolo_> @users
05:21:21 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
05:21:23 <dcoutts> audreyt: so how about we add | LocalTarballPackage LocalRepo where LocalRepo = FilePath
05:21:54 <dcoutts> audreyt: we'd expect the local repo to be the same format as our download/cached form
05:22:06 <audreyt> right.
05:22:07 <MyCatVerbs> nominolo_: 440, by irssi's count.
05:22:47 <nominolo_> MyCatVerbs: what command do you use for that?
05:22:53 <dcoutts> audreyt: and unlike remote repos, it wouldn't need a name, since the name is only used to make a name for the local download cache
05:23:48 <audreyt> all correct.
05:23:56 <audreyt> it also means that I can reuse the same 00-index
05:24:02 <audreyt> which contains all the package's index
05:24:12 <MyCatVerbs> nominolo_: /names. After it shows the whole list, it prints "13:21:59 -!- Irssi: #haskell: Total of 440 nicks [1 ops, 0 halfops, 0 voices, 439 normal]"
05:24:16 <audreyt> but only populate the cache dirs with the one leftover from a from-scratch install
05:24:25 <audreyt> s/the one/the ones/
05:24:30 <audreyt> which trivially solves the dependency-bundling problem
05:24:38 <mauke> nominolo_: /n -count
05:24:50 <MyCatVerbs> nominolo_: so actually only 439 here, because I just counted Chanserv too by mistake. But ddarius just popped in, so _now_ it's up to 440 again!
05:24:51 <dcoutts> audreyt: so lets integrate this in the cabal-install darcs repo
05:24:54 * MyCatVerbs ignores \bot.
05:25:03 <nominolo_> ah nice
05:25:31 <DuClare> Can you implement asks for State in one neat line?
05:25:41 <MyCatVerbs> mauke: damn! Now that's precisely the sort of efficiency that reading the damned documentation gets you. You communist!
05:25:42 <EvilTerran> asks?
05:25:46 <EvilTerran> ?hoogle asks
05:25:47 <lambdabot> Control.Monad.Reader.Class.asks :: MonadReader r m => (r -> a) -> m a
05:25:53 <DuClare> That.
05:25:58 <nominolo_> isn't that just gets?
05:26:02 <MyCatVerbs> State $ \state -> (state,state)
05:26:03 <SamB_XP> DuClare: you don't want that!
05:26:03 <DuClare> Right
05:26:12 <EvilTerran> ?hoogle gets
05:26:13 <lambdabot> Control.Monad.State.Class.gets :: MonadState s m => (s -> a) -> m a
05:26:13 <lambdabot> Data.Monoid.getSum :: Sum a -> a
05:26:13 <lambdabot> System.Random.getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
05:26:17 <EvilTerran> ?src gets
05:26:17 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:26:33 <EvilTerran> ?type (get >>=)
05:26:35 <lambdabot> forall (m :: * -> *) a b. (MonadState a m) => (a -> m b) -> m b
05:26:45 <EvilTerran> ?type (<$> get)
05:26:45 <lambdabot> forall a b (f :: * -> *). (Functor f, MonadState a f) => (a -> b) -> f b
05:26:46 <MyCatVerbs> State $ \state -> (state,state) -- !
05:26:54 <audreyt> dcoutts: cool. I need to go offline soon, but can resume hacking in 24hr
05:27:04 <EvilTerran> MyCatVerbs, isn't that get?
05:27:15 <audreyt> dcoutts: would you have some spare tuits to add LocalTarballPackage first? I'll check from darcs tomorrow.  If not I'll have a go at it
05:27:17 <DuClare> Looks like get to me. :o
05:27:23 <MyCatVerbs> EvilTerran: yes. I... wait, what does gets do?
05:27:25 <dcoutts> audreyt: ok, make sure you pull first, there are some changes in the repo since the release
05:27:31 <nominolo_> gets f = State $ \s -> (f s, s)
05:27:34 <dcoutts> audreyt: and yes, I'm just adding the types
05:27:38 <EvilTerran> MyCatVerbs, it does (<$> get), AFAICT
05:28:06 <MyCatVerbs> EvilTerran: oO
05:28:15 <audreyt> yay thanks!
05:28:17 <audreyt> dcoutts++
05:28:21 <MyCatVerbs> EvilTerran: ah, right. Handy. But just where in the Heck is that defined?
05:28:24 <SamB_XP> dcoutts: what shape tuits do you have?
05:28:31 <EvilTerran> <EvilTerran> ?hoogle gets <lambdabot> Control.Monad.State.Class.gets :: MonadState s m => (s -> a) -> m a
05:28:52 <dcoutts> SamB_XP: huh whu?
05:29:08 <MyCatVerbs> EvilTerran: d'ahhhh.
05:29:13 <EvilTerran> dcoutts, i think he wants to know if you'll get a round tuit
05:29:54 <EvilTerran> or, indeed, if you've already got one. i dunno, i haven't read all the scrollback
05:29:58 * dcoutts wonders what a "tuit" is
05:30:24 <EvilTerran> http://google.com/search?q=a-round-tuit
05:30:25 <lambdabot> Title: a-round-tuit - Google Search
05:30:28 <mauke> dcoutts: http://en.wiktionary.org/wiki/round_tuit
05:31:08 <dcoutts> heh
05:32:35 <dolio> I used to have one.
05:34:21 <mauke> #define ENOTUIT EAGAIN
05:34:41 <SamB_XP> lol
05:35:10 <dolio> At one point I kept it in my wallet, but eventually I took it out, because it made a round raised shape in it.
05:35:20 <nominolo_> so, when someone says "i'll do it when i get a round to it" you hand him "a round tuit"?
05:35:28 <dolio> Looked like I was some ridiculous guy keeping a condom around at all times.
05:35:51 <nominolo_> dolio: safety first!
05:36:11 <SamB_XP> or "I just haven't gotten around to it"
05:38:38 <ibid> #define EWRONGTUITSHAPE EAGAIN
05:39:17 <SamB_XP> my dad is always like "well use a square one instead!"
05:39:19 <Gwern-away> hm. I need a rhetorical example of something which is a nasty buggy hack but programmers use it anyway
05:39:20 <Gwern-away> goto, maybe
05:39:24 <jnaimard> hi all, I'm having problems building yi (on mac OS X): Setup.hs build works, but (silently) does not create any yi executable
05:39:32 <SamB_XP> Gwern-away: nope!
05:39:41 <pozic> Is it even possible to write a function that given [[[1]]] returns 1,  given [1,2] returns [1,2], given [[1,2]], returns [1,2] and so on?
05:39:43 <SamB_XP> Gwern-away: it's not a hack
05:39:48 <jnaimard> (this is using 0.4.3)
05:39:55 <SamB_XP> the workarounds resulting from it's lack -- those are hacks
05:40:05 <SamB_XP> or at least nasty, buggy ...
05:40:58 <ddarius> Gwern-away: C
05:41:39 <Gwern-away> SamB_XP: well, what if you're using goto instead of throwing an error or exception?
05:41:46 <SamB_XP> Gwern-away: hmm.
05:42:03 <ddarius> Programmer's tend not to use goto nowadays, even new programmers.
05:42:14 <Gwern-away> I want to say 'and you can calculate fibonacci using C++ templates, but they're still a hack', and then I remembered that people seem to like doing things in templates
05:42:44 <ddarius> I wrote the factorial function in a little Haskell-like language that compiled to C++ templates.
05:43:46 <vixey> All the C programmers I've ever talked to use goto all the time
05:43:54 <vixey> "it's the clean way to do error handling"
05:44:05 * Gwern-away sighs. maybe I'll just use an esolang as an example
05:44:50 <SamB_XP> I think the new programmers aren't often told about goto...
05:46:39 * Twey laughs.
05:46:42 <nominolo_> goto is nice to jump out of a nested loop
05:46:59 <Twey> 'clean way to do error handling' *chuckle*
05:47:16 <ddarius> SamB_XP: That's perfectly fine by me.
05:47:28 <SamB_XP> which is probably just as well
05:47:35 <mauke> (loop labels)++
05:47:39 <SamB_XP> since they'd most likely not know what to do with it
05:47:45 <Twey> Aye, too many people tell the kids about eval() in dynamic languages *shudder*
05:47:48 <osfameron> yeah, loop labels make goto fun
05:47:57 <Twey> SamB_XP: More importantly, what *not* to do with it
05:48:03 <SamB_XP> well, yes
05:48:11 <Twey> osfameron: I like the loop labels in Javascript
05:48:24 <mauke> Twey: do they work like perl's?
05:48:29 <Twey> No idea
05:48:29 <ddarius> Twey: But, isn't eval what makes dynamic languages powerful?  Way more powerful than those static languages that can't have eval?
05:48:35 <Twey> toploop: for (blah) { for (baz) { break toploop; }}
05:48:39 <SamB_XP> if they only find out about once they get comfy with the other constructs, they'll know just what to use it for ;-)
05:48:40 <mauke> yep
05:48:40 <Twey> ddarius: Rubbish
05:48:53 <Twey> ddarius: You're manipulating code.  As strings.
05:49:07 <Twey> The key tennet to eval() is 'don't use it'
05:49:17 <SamB_XP> Twey: I thought it was s-expressions!
05:49:19 <Twey> With a few very rare exceptions (see \b)
05:49:32 <Twey> SamB_XP: Only in Lisps :-)  They're cool.
05:49:36 * ddarius finishes trolling Twey and passes off to SamB_XP 
05:49:48 * Twey chuckles.
05:49:57 <vixey> lol
05:50:24 <vixey> gwern: I got the perfect example!
05:50:29 <vixey> gwern:  -
05:50:35 <vixey> in haskell, it sucks!
05:50:56 <SamB_XP> that is rather a nasty hack
05:51:48 * Twey nods.
05:51:56 <Gwern-away> minus?
05:52:05 <Gwern-away> what's so terrible about that?
05:52:11 <SamB_XP> unary minus!
05:52:19 <vixey> > -3
05:52:22 <lambdabot>  -3
05:52:28 <vixey> what ???
05:52:30 <vixey> > (-4) 6
05:52:30 <lambdabot>   add an instance declaration for (Num (t -> a))
05:52:33 <Gwern-away> oh, right the negation thing
05:52:36 <Gwern-away> yeah, that is unpleasant
05:53:32 <Gwern-away> is that hardwired in, or a clever typeclass thing?
05:53:39 <mauke> hardwired
05:53:46 <vixey> horriblewired
05:53:54 <mauke> otherwise -x wouldn't even parse
05:54:28 <mauke> also horrible: n+k patterns, numeric patterns
05:54:47 <vixey> type inference, horrible!
05:54:54 <mauke> no, type inference is sound
05:55:16 <Gwern-away> did those get removed in haskell'? that'd be nice. n+k always confused me when I saw it. kind of like function-level pattern matching, but not
05:55:19 <DrSyzygy> @type -2
05:55:20 <lambdabot> forall a. (Num a) => a
05:55:23 <DrSyzygy> @type (-2)
05:55:24 <lambdabot> forall a. (Num a) => a
05:55:40 <DrSyzygy> @type (-)
05:55:41 <lambdabot> forall a. (Num a) => a -> a -> a
05:55:41 <vixey> @type id -2
05:55:41 <lambdabot> forall a. (Num (a -> a)) => a -> a
05:55:43 <SamB_XP> what was wrong with numeric patterns?
05:55:47 <DrSyzygy> @type (-) 2
05:55:48 <lambdabot> forall t. (Num t) => t -> t
05:55:56 <mauke> they don't do pattern matching
05:56:07 <vixey> SamB_XP: They aren't a general mechanism or something, I don't know I think they are fine
05:56:08 <mauke> numbers aren't constructors (in general)
05:56:19 <vixey> you can make a view for i
05:56:20 <vixey> for it
05:56:37 <vixey> if GHC 6.9 ever compiled
05:56:55 <Gwern-away> 'I was given a description of the UNIVAC. It described acoustic delay lines, excess-three notation and end-around carry. I had the feeling that I was entering a dark, eerie world in which words would be used as charms and incantations rather than to communicate definite meanings. I was right.'
05:56:57 <SamB_XP> meh. so it's not actually pattern matching. so?
05:57:19 <SamB_XP> what would you propose, mauke ?
05:57:31 <Gwern-away> http://ed-thelen.org/comp-hist/APL-hist.html
05:57:32 <mauke> > case 0 :: Word16 of 65536 -> "wat"; x -> show x
05:57:35 <lambdabot>  "wat"
05:57:45 <vixey> :(
05:57:48 <vixey> finite things
05:57:52 <vixey> horrible!
05:58:05 <mauke> SamB_XP: remove them from the language
05:58:17 <SamB_XP> mauke: it would be so damn inconvenient though
05:58:36 <mauke> not really, you could always use guards
05:58:40 <vixey> SamB_XP: What, you actually use them?
05:58:56 <SamB_XP> nobody else does?
05:59:03 <vixey> no, only you
05:59:22 <mauke> I do, but I feel kind of bad about it :-(
06:00:06 <dolio> I use numeric patterns sometimes.
06:00:09 <dolio> Usually for 0.
06:05:40 <dolio> No accounting for taste, though, I guess. Someone was recently talking about guards as if they're a bad thing.
06:05:57 <SamB_XP> dolio: how insane can you get?
06:06:10 <SamB_XP> what did he want to use -- if expressions ?
06:06:11 <dolio> I don't know. That's pretty insane. :)
06:06:50 <dolio> He was saying they're bad because they're syntactic sugar, and lead people to want more syntactic sugar.
06:06:55 <dolio> At least, that's how I took it.
06:06:58 <ddarius> Henning Thielemann, I think on the mailing list.
06:07:03 <dolio> Yeah.
06:07:21 * SamB_XP throws sugar lambdas
06:07:22 <vixey> syntax... horrible?
06:07:54 <mauke> that's why lisp is so bad
06:07:54 <SamB_XP> so has this guy actually tried programming without them?
06:07:54 <ddarius> We should do away with syntax and just excite terminal ends.
06:07:57 <Twey> dolio: Was he a Lisp programmer?
06:08:00 <mauke> it encourages user-defined syntactic sugar
06:08:22 <Twey> Lisp encourages a user-defined *language*
06:08:32 <SamB_XP> not very well
06:08:49 <mauke> language is sugar
06:08:56 <dolio> Twey: I don't know. But I think that about 90% of the time, when he throws his two cents in, I disagree with him, so this instance wasn't too surprising. :)
06:09:00 <SamB_XP> I once decided to try to implement Amphetamine's language in CL -- it didn't go too well
06:09:02 <Twey> I don't remember who it was that said that the best style of programming in Lisp is to write a small DSL for your application and then write in that, but they were right
06:09:11 <vixey> what is Amphetamine?
06:09:11 <ddarius> mauke: Don't waver.  You were more right to begin with.
06:09:36 <Twey> Paul Graham, perhaps
06:09:46 <SamB_XP> vixey: a game
06:12:56 <puusorsa> amphetamine is what mathemagicians transform into theorems
06:13:06 <puusorsa> just ask erdös
06:13:12 <vixey> hehe
06:13:38 <SamB_XP> I might have got the wrong name
06:13:53 <SamB_XP> that is, I might be confusing two games
06:14:21 <DrSyzygy> Well, ErdÃ¶s -did- say that mathematicians transform COFFEE into theorems. However, disappointed as he was with the quality of coffee, he augmented it with amphetamine as well...
06:14:34 * DrSyzygy enjoys the story about when ErdÃ¶s abstained for a month.
06:14:42 <DrSyzygy> On a bet with someone who worried about his addiction.
06:15:02 <Asgaroth> How do I create hoogle databases from source files? I tried "haddock --hoogle Foo.hs", but it can't find basic types like Integer or Ord.
06:15:04 <DrSyzygy> And the result was a clean ErdÃ¶s, who was going out of his mind with the lack of productivity, and who produced MUCH less and WORSE mathematics in the meantime.
06:15:55 <SamB_XP> maybe he had ADD
06:17:02 <SamB_XP> Asgaroth: it needs, er, was it ".haddock" files?
06:17:11 <SamB_XP> for the base package etc.
06:17:57 <Asgaroth> SamB_XP: How do I create them?
06:19:19 <SamB_XP> well, that's the tricky bit ... how did you install ghc?
06:22:51 <Asgaroth> SamB_XP: via the archlinux package manager(pacman)
06:24:07 <pozic> Is it possible to write a method that given [[[1]]] returns 1,  given [1,2] returns [1,2], given [[1,2]], returns [1,2] and so on? That is, it is concat on steroids.
06:24:34 <nominolo_> pozic: type of 1
06:24:35 <SamB_XP> Asgaroth: hmm.
06:24:43 <nominolo_> pozic: and type of [1,2]
06:24:55 <SamB_XP> Asgaroth: did you install the doc packages?
06:25:25 <pozic> nominolo_: Int, [Int]
06:25:35 <pozic> nominolo_: but I doubt that's what you meant...
06:25:44 <Asgaroth> SamB_XP: Hmm, there don't seem to be any.
06:25:49 <nominolo_> pozic: so can you write a function that returns both Int and [Int] ?
06:25:56 <pozic> nominolo_: method, yes.
06:26:09 <dmwit> pozic: no
06:26:10 <SamB_XP> Asgaroth: hmm.
06:26:14 <pozic> nominolo_: at least, I can, but I cannot get this one.
06:26:32 <pozic> dmwit: multi-parameter type-classes
06:26:32 <dmwit> pozic: With a bit of magic, you might be able to get it to return [Int], given [Int], [[Int]], [[[Int]]], etc.
06:26:36 <Asgaroth> I think only the .hi files got installed.
06:26:54 <SamB_XP> Asgaroth: you might be able to alter the source packages so that they build/install .haddock files
06:27:01 <Asgaroth> SamB: Can I download the .haddock files from somewhere?
06:27:06 <dmwit> pozic: It's not a type-class issue; the problem is that your return type (in that example) depends on the *data*.  That's called dependent typing, and it's not really something we have.
06:27:10 <kpreid> class Flat a b where flat :: a -> b; instance Flat [[a]] [a] where flat = concat; instance Flat [a] [a] where flat = id -- does this work?
06:27:11 <Asgaroth> SamB_XP: I'll try.
06:27:11 <nominolo_> pozic: there're some advanced tricks to do that, but that's probably not what you want
06:27:44 <pozic> dmwit: yes, I am sorry. You are right.
06:28:00 <SamB_XP> obviously then send your patches to the archlinux maintainer(s) for those packages
06:28:02 <kpreid> pozic: did you mean to map [[[1]]] to [1], not 1? if so, my typeclass will do something of the sort, tho it might need extension options or maybe some fundep or something...
06:28:17 <pozic> kpreid: I wanted to map it to 1
06:28:29 <kpreid> well, that's something that just doesn't exist in Haskell :)
06:28:41 <SamB_XP> pozic: can't tell that from the type, so, you can't do that ;-)
06:29:44 <dmwit> pozic: You could maybe define your own GADT that couples a Peano number with your list.
06:29:58 <dmwit> pozic: But that's likely to be much more work than you want to do just to get that function.
06:32:15 <nominolo_> class Flatten x a where flatten :: x -> [a];  instance Flatten [a] a where flatten = id; instance Flatten [[a]] a where flatten xs = concat xs; instance Flatten [[[a]]] a where flatten xxs = ...
06:33:09 <nominolo_> possibly class Flatten x a | x -> a where ...
06:33:29 <EvilTerran> i don't think you want that fundep, actually
06:33:44 <pozic> nominolo_: it should work for every nesting level.
06:34:18 <pozic> kpreid's stuff probably works.
06:34:29 <EvilTerran> seeing as you'll want to have Flatten [a] [a] and Flatten as [a] => Flatten [as] [a]
06:34:47 <EvilTerran> you'd get a fundep collision with | x -> a
06:34:49 <nominolo_> pozic: right, that seems nicer
06:35:26 <Twey> @hoogle [(a -> b)] -> a -> b
06:35:28 <lambdabot> No matches, try a more general search
06:35:31 <Twey> :-(
06:35:44 <Twey> Oh
06:35:51 <Twey> @hoogle [(a -> b)] -> a -> [b]
06:35:51 <lambdabot> No matches, try a more general search
06:36:07 <Botje> boo :)
06:36:07 <Twey> Is there any function that takes a list of functions and a single value and applies them to all of them?
06:36:10 <nominolo_> @djinn [a -> b] -> a -> b
06:36:11 <lambdabot> -- f cannot be realized.
06:36:31 <Botje> @pl \fs x -> map ($x) fs
06:36:31 <lambdabot> flip (map . flip id)
06:36:45 <Twey> Ahhh
06:36:49 <Twey> That's beautiful, thanks
06:36:50 <EvilTerran> Botje, sequence
06:36:55 <Twey> Ah?
06:36:56 <EvilTerran> er, Twey
06:37:02 <Twey> :t sequence
06:37:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:37:04 <EvilTerran> > sequence [f,g,h] x :: [Expr]
06:37:06 <lambdabot>  [f x,g x,h x]
06:37:14 <Twey> Oho!
06:37:19 <Twey> *thinks*
06:37:20 <EvilTerran> it's working in the (e->) Monad
06:37:21 <Twey> Thank you
06:37:24 <Twey> Ahhhh.
06:37:32 <EvilTerran> you take a load of (e->) "actions"
06:37:42 <EvilTerran> ie functions expecting a parameter of type e
06:37:46 * Twey nods.
06:37:57 <Twey> Functions as monads confuses the heck out of me still.
06:37:58 <EvilTerran> and sequence them into a single action, ie a function that expects a parameter of type e
06:38:07 <EvilTerran> there's only one reasonable implementation for it :)
06:38:07 <Twey> I'm sure all will become clear soon :-)
06:38:12 <Twey> Hehe, right
06:38:26 <kpreid> too bad the name "sequence" doesn't make sense here
06:38:46 <DuClare> Um.  What if I don't want to take an intermediate value in do notation, but feed the result directly to another function?
06:38:50 <EvilTerran> much like the instance Functor ((->) e) where fmap = (.) -- that's the only strict implementation that fits the type
06:39:31 <nominolo_> DuClare: do x <- f <$> monadComputation y z
06:39:45 <dmwit> Twey: If you understand State, then Reader is similar, but with an implicit "get" everywhere. =P
06:39:45 <DuClare> Neat.
06:39:46 <DuClare> Thanks.
06:39:51 <nominolo_> where <$> is in Control.Applicative, and is equivalent to fmap
06:40:03 <EvilTerran> <$> is, in fact, exactly fmap
06:40:11 <EvilTerran> it's equivalent to liftM for monads
06:40:14 <DuClare> I think I've used <$>, although that was long ago.
06:40:29 <DuClare> There was somebody here who tutored me.  I did functors and stuff. :o
06:40:44 <nominolo_> DuClare: some monads have no Applicative instance yet
06:40:56 <nominolo_> DuClare: so use liftM or fmap there
06:40:58 <EvilTerran> you don't need an Applicative instance to use <$>
06:41:03 <EvilTerran> ?type (<$>)
06:41:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:41:26 <EvilTerran> ?type liftA -- this is the one with the type requiring Applicative
06:41:27 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
06:41:47 <nominolo_> oh, good
06:42:03 <nominolo_> what package is Applicative in now?
06:42:05 <EvilTerran> ?type liftA2 -- liftA has multi-parameter versions as well, so the constrained type makes liftA consistent with those
06:42:06 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:42:12 <dcoutts> nominolo_: base
06:42:29 <nominolo_> dcoutts: oh, then i could use it in GHC
06:42:37 <nominolo_> unless it'll get moved out again
06:42:54 <dcoutts> nominolo_: I don't think it'll be moved out, but I dunno if it was there in 6.4.1
06:45:37 <Twey> http://hpaste.org/9310 -- have I done this wrong?  It doesn't compile...
06:45:55 <nominolo_> nominolo_: oh, no, certainly not in 6.4.1
06:46:24 <Twey> :t sequence_
06:46:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
06:46:37 <nominolo_> Twey: put parens around joinChannel chans
06:46:51 <Twey> nominolo_: Eh?
06:47:23 <Twey> nominolo_: chans is [String], joinChannel is String -> Handle -> IO ()
06:47:42 <dmwit> Twey: sequence_ (map (flip joinChannel h) chans)
06:47:44 <dmwit> or
06:47:47 <Twey> (map joinChannel chans) *should* be [(Handle -> IO ())]
06:47:56 <dmwit> mapM_ (flip joinChannel h) chans
06:48:13 <dmwit> Twey: Yes... which makes joinChannels :: [String] -> Handle -> [IO ()]
06:48:23 <chrisdone> sequenceM takes a list of actions, mapM takes a list of values
06:48:33 <vixey> flip mapM_ chans $ flip joinChannel h
06:48:44 <dmwit> vixey: forM_ = flip mapM_
06:48:48 <Twey> dmwit:       Inferred type: Handle -> ()
06:49:06 <Twey> (for joinChannels)
06:49:16 <nominolo_> Twey: oh, sorry, yes
06:49:24 <Twey> Oh wait, no
06:49:32 <Twey> In the definition of
06:49:36 <Twey> Expected: Handle -> IO ()
06:49:40 <dmwit> right
06:49:43 <nominolo_> Twey: you need [Handle]
06:49:51 <dmwit> You're sequencing in the function monad.
06:49:55 <Twey> Aye.
06:50:09 <nominolo_> so, sequence_ . sequence
06:50:24 <nominolo_> or just mapM_
06:50:37 <dmwit> Incidentally: if the channel name does not contain a space, the ':' is not necessary in front of the channel name.
06:50:51 <Twey> Aye, dmwit
06:50:53 <Baughn> Is it possible to construct one repository (a local one) from another (http/cabal) while using a third (local/cabal1.4) as a cache where possible?
06:50:55 <Twey> Better safe than sorry.  :-)
06:51:11 <dcoutts> Baughn: huh?
06:51:12 <dmwit> (...and I'm pretty sure spaces are not allowed in channel names)
06:51:33 <chrisdone> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
06:51:34 <lambdabot> Title: HackageDB: irc-0.4.3
06:51:38 <dcoutts> Baughn: can you try explaining that again :-)
06:51:46 <dmwit> Baughn: Why would cabal have anything to do with it?  And a repository with which VCS, darcs?
06:51:50 <Baughn> dcoutts: I'm trying to darcs-get cabal. It's taking a Very Long Time, and I already have the cabal-1.4 branch here, which has most of the same patches.. plus some extras
06:52:10 <Botje> Baughn: --partial to the rescue?
06:52:17 <dmwit> Baughn: darcs get <local>; darcs pull <remote>
06:52:20 <Baughn> If not for the extras, I could get from /that/ and then pull from the cabal repo. With the extras, I'm not sure how to do it
06:52:37 <dmwit> roll back the extras?
06:52:43 <Baughn> dmwit: YEah. I tried that; it sat for an hour and a half, thinking, and then proclaimed conflicts.
06:53:14 <dcoutts> Baughn: oooh, you're talking about darcs, not cabal's package repos. That's ok then. In that case I don't know :-)
06:53:15 <Baughn> I was hoping for something automated.. well, I suppose I could read the inventory and construct it myself; the format is simple enough
06:53:33 <Twey> :t mapM_
06:53:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:53:45 <Twey> \b is kind of slow today...
06:54:00 <Botje> \bot has the dumb i think
06:54:24 <Twey> But ah, that makes sense now, thanks dmwit :-)
06:58:13 <chrisdone> Twey: any reason for not using the irc library?
06:58:25 <Twey> chrisdone: There is one?
06:58:33 <EvilTerran> ?hackage irc
06:58:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
06:58:39 <Twey> TBH I didn't look very hard, thought it would be a nice warm-up
06:58:39 <EvilTerran> i imagine lambdabot uses it
06:58:50 * Twey considers it.
06:58:52 <chrisdone> I don't think Î»b does use it
06:58:57 <chrisdone> it was written after Î»b
06:59:13 <Twey> chrisdone: Showoff
06:59:17 <chrisdone> lambabot has loads of stuff hard coded that has now been implemented as libraries
06:59:18 <EvilTerran> oh right
06:59:24 <chrisdone> as you know
06:59:25 <Twey> Î›b
06:59:32 <Twey> Aye
07:00:23 <Twey> 'Arie' is such a pretty name.  ('ooh look, shiny...')
07:01:41 <Twey> Mph, no docs for Network.Irc *grumble*
07:01:55 <chrisdone> Twey: funny enough, I wrote this IRCd and started writing my own IRC parsing stuff and then discovered Network.IRC
07:02:23 <Twey> Mmn.
07:02:29 <Twey> Oh, chrisdone
07:03:25 <Twey> Are there any Haskell parsers out there capable of handling the Lojban grammar?
07:04:00 <chrisdone> I reckon Frisby could do it
07:04:13 <chrisdone> which is a PEG grammar maker
07:04:35 <chrisdone> ( http://repetae.net/computer/frisby/ )
07:04:35 <lambdabot> Title: Text.Parsers.Frisby
07:05:06 <Twey> Hmn, yes, it doesn't seem to be completed yet
07:05:18 <Twey> Have you looked at it?  Is it usable?
07:06:00 <Twey> I'm wondering whether to try to parse it myself or to parse the output of jbofi'e or camxes (neither of which output something nice and simple, like s-expressions -.-)
07:06:08 <chrisdone> I haven't tried it; I considered it and then just figured I'd run jbofihe as a pipe
07:06:13 <chrisdone> hehe
07:06:23 <Twey> Yeeeah, might be easier :-\
07:06:31 * Twey hugs Parsec.
07:06:51 <Twey> Especially since Network.IRC uses Parsec anyway.
07:07:26 <chrisdone> we could work on a haskell lojban parser, but I'm not sure how useful (worth it?) it would be in the long run
07:08:08 <EvilTerran> well, it'd be a step towards lojban-as-programming-language :P
07:08:20 <chrisdone> hehe
07:08:25 <Twey> :-)
07:09:03 <vixey> There is a parser in C .. isn't there
07:10:22 <Twey> Yes, jbofi'e
07:10:24 <chrisdone> I think jbofihe is in C. there's the packrat parser in Java
07:10:59 <chrisdone> http://teddyb.org/~rlpowell/hobbies/lojban/grammar/lojban.peg.txt
07:11:40 <Twey> Hmn, Network.IRC is kind of...
07:11:42 <Twey> ... minimal
07:12:00 <chrisdone> Twey: yeah, feel free to add to it, of course
07:12:24 <chrisdone> I just requested a Hackage account, because I think there's an issue with its message creation
07:13:50 <Twey> What is it?
07:14:09 <chrisdone> ah, no. it's been fixed, probably from when I pointed it out a while ago
07:14:16 <chrisdone> Prelude GOA Network.IRC> showMessage $ privmsg "#haskell" ":whut"
07:14:16 <Twey> Oh, heh
07:14:16 <chrisdone> "PRIVMSG #haskell ::whut"
07:14:26 <chrisdone> previously, it would output "PRIVMSG #haskell :whut"
07:14:33 <Twey> GOA?
07:14:36 <chrisdone> which is wrong
07:14:38 <chrisdone> Ghci on ACID
07:14:40 <Twey> Yeah
07:14:42 <Twey> Oh
07:14:45 <chrisdone> :)
07:14:56 <Twey> Heh
07:17:20 <sal23> chrisdone: what is the motivation for Ghci on ACID? any papers? Can't find unbroken links on google
07:17:51 <ivanm> don's site is it, AFAIK
07:18:05 <ivanm> it's a way of using lambdabot inside a ghci session
07:18:21 <ivanm> though last I checked, as soon as you loaded another module then goa died :s
07:19:50 <sal23> I see.... what is the role of ACID here? I don't see any paper with obvious title on Don's site...
07:20:26 <ivanm> no paper AFAIK
07:20:35 <ivanm> acid == trippy, high, etc. (as in drugs) AFAIK
07:20:54 <sal23> ha....I was thinking database
07:21:54 <Philippa_> I suspect someone liked the acid/goa combination
07:23:50 <sal23> well, dope/goa combination would do but dope sounds kind of teen thing compared to Acid....
07:24:36 <sal23> Acid sounds like something that can burn you if handled improperly...which sounds dangerous and good
07:24:40 <RayNbow> hmm, why is it actually that GHC is lower ranked on the Sempron shootout than on the P4 Shootout?
07:25:46 <sal23> I would think difference in instruction sets between Sempron and P4, plus the architecture...
07:25:55 <xerox> It's like you load GOA and in a moment GHCi can see a lots of things it couldn't see before.
07:26:15 <sal23> nice analogy
07:26:53 <chrisdone> hey, sorry
07:27:00 <chrisdone> it's basically all the good stuff Î»b has
07:27:19 <chrisdone> like @hoogle, @instances, @src, @docs ..
07:27:23 <chrisdone>  and @pl
07:28:37 <chrisdone> ivanm: I made a little fix for that, but you may not like it
07:28:51 <ivanm> oh? why not?
07:29:17 <chrisdone> ivanm: you can make it re-launch the lambdabot process when it finds it's not there anymore
07:29:40 <chrisdone> ivanm: only problem is you need to hard code the path for lambdabot (otherwise how does it know where it is when it's freshly loaded?)
07:30:06 <ivanm> that's not too bad... especially as realistically, you'd need to install lambdabot locally anyway
07:30:42 <chrisdone> ivanm: I can link you to my patch GOA
07:31:11 <ivanm> heh, don't even have lambdabot installed here anymore :p
07:31:25 <ivanm> maybe you should link to it on lambdabot's page on the wiki?
07:31:25 <chrisdone> ah, ok
07:31:47 <ivanm> (waiting for a working version to get put onto hackage so I can use cabal-install :p )
07:32:24 <chrisdone> ivanm: well, I've found cabal install to install Î»b perfectly happily (except runplugs doesn't work --but that doesn't matter in GOA)
07:32:43 <ivanm> oh? when I tried it didn't for some reason :s
07:33:15 <chrisdone> was it a "happy" error? because that needs to be installed (even though it's not on the dependancies...)
07:33:27 <ivanm> can't recall...
07:33:28 <chrisdone> try again? maybe I'll recognise the error
07:33:38 <chrisdone> if you're not busy.. :p
07:33:45 <ivanm> in a bit...
07:33:47 <ivanm> @localtime
07:33:49 <lambdabot> Local time for ivanm is Sat Aug  2 00:33:48
07:33:57 <ivanm> ^^ I should be busy in the land of nod atm :p
07:34:12 <chrisdone> :)
07:34:45 <chrisdone> ivanm: actually I think I'll change the patch so that it reads from your .ghci, rather than hard coding it :) then it's not so ugly
07:35:04 <ivanm> \o/
07:36:17 <gchrupala> could someone explain how i can make the look in this: http://hpaste.org/9311 strict in the accumulator arg, so i dont get a stack overflow?
07:36:25 <gchrupala> loop
07:38:12 <BMeph> gchrupala: "loop i !ws"
07:38:31 <gchrupala> BMeph: ws is a Map
07:38:52 <BMeph> ...and? :)
07:39:29 <gchrupala> I thought the bang wont do a deep eval?
07:42:07 <Cale> gchrupala: rnf ws `seq` if ...
07:44:30 <Cale> er, actually, that's a Data.Map, so it should be strict in the structure at least.
07:45:30 <chrisdone> is there a cross platform way of getting directory path seperators?
07:45:33 <Cale> gchrupala: So it's possible that the ! will be enough
07:45:40 <chrisdone> this question gets asked all the time but I've never seen the answer
07:45:44 <gchrupala> ya that didnt work so the overflow must be somewhere else..
07:45:53 <Cale> chrisdone: There's a library called filepath you might want to look at
07:46:30 <chrisdone> Cale: thanks :)
07:48:10 <lilachaze> i find it humorous that cabal-install has so many dependencies ;-)
07:48:55 <lilachaze> perhaps we could do with an install-cabal-install script?
07:49:01 <BMeph> Cale: Does that only need C.P.Strategies (rnf) for use?
07:49:15 <Cale> BMeph: yeah
07:49:38 <DuClare> Ugh.  The more I use the record syntax, the more I hate it.  It's plain ugly. :O
07:49:41 <Cale> BMeph: er, I don't know if there's an instance of NFData for Data.Map or not though.
07:49:58 <Cale> DuClare: is it really so bad?
07:50:58 <vixey> I think it's pretty bad :)
07:51:12 <vixey> I don't understand why it's part of haskell..
07:51:31 <vixey> DuClare: Isn't the solution to not use it?
07:51:55 <DuClare> Cale, Yeah, the curly brackets just don't fit in, looks ugly and is annoying and makes unreadable. :o
07:52:07 <DuClare> vixey, I don't know of a good alternative
07:52:08 <BMeph> Cale: I pulled up your artfully-provided link to C.p.Strat - Map is in it. :)
07:52:21 <vixey> DuClare: alternative to what? horrible syntax
07:52:44 <chrisdone> I like the construction syntax
07:53:11 <chrisdone> using it for updating is nasty... lenses++
07:53:20 <DuClare> Updating is what I do
07:54:00 <chrisdone> you need updating? I'm your man
07:54:05 <DuClare> How would you update without the curly braces?
07:54:32 <dmwit> funrefs
07:54:39 <dmwit> ?where funrefs
07:54:39 <lambdabot> I know nothing about funrefs.
07:54:45 <dmwit> ?where twanvl
07:54:45 <lambdabot> I know nothing about twanvl.
07:54:46 <chrisdone> functional references/lenses would do the trick, if we had them as an extension or something. that would be nice
07:54:52 <chrisdone> @go overloading functional references
07:54:54 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
07:54:54 <lambdabot> Title: Overloading functional references - 21 thoughts
07:55:10 <osfameron> where does @go look ?
07:55:48 <chrisdone> google feeling lucky, I believe
08:00:33 <osfameron> it's just too perfectly haskell related each time... I don't believe it's "luck" ;-P
08:00:55 <Botje> @go cookies
08:00:56 <lambdabot> http://en.wikipedia.org/wiki/HTTP_cookie
08:00:56 <lambdabot> Title: HTTP cookie - Wikipedia, the free encyclopedia
08:01:09 <Botje> perhaps it checks @where too?
08:01:39 <chrisdone> osfameron: well I knew that one off by heart :P
08:01:45 <EvilTerran> osfameron, that'll be google using heuristics to bring you more relevant results based on your (or, in this case, lambdabot's) search history
08:02:04 <EvilTerran> creepy but useful :P
08:02:15 <chrisdone> EvilTerran: yeah, I like that. I can search really general topics and get haskell results
08:02:28 <osfameron> so I shouldn't pollute it by @go nude picture of buffy the vampire slayer, for example?
08:02:39 <EvilTerran> you *could*
08:02:42 <dmwit> ?go nude picture of buffy the vampire slayer
08:02:43 <lambdabot> No Result Found.
08:02:47 <chrisdone> like "nude picture of" is even necessary in that query
08:02:51 <dmwit> *shrug*
08:02:52 <osfameron> now that's *not* the internet
08:02:59 <EvilTerran> i'd compare it to teaching furbies in toy stores bad language
08:03:16 <dmwit> I'm pretty sure \bot doesn't log in at the big G.
08:03:16 <chrisdone> EvilTerran: creepiest. toys. ever.
08:03:26 <dmwit> So it's not so likely that G is really tracking her search history.
08:03:29 <DuClare> Na, I don't like the idea of TH.  I'd rather see new syntax.
08:03:30 <EvilTerran> chrisdone, what about Tickle Me Elmo?
08:03:36 <DuClare> But then again it's just me.
08:03:40 <chrisdone> EvilTerran: or the harry potter broom sticks?
08:03:40 <vixey> DuClare: that's what TH is
08:03:46 <chrisdone> EvilTerran: vibrating ones, that is
08:03:46 <dmwit> EvilTerran: Hey, you know what every Tickle Me Elmo gets before it leaves the factory?
08:03:46 <DuClare> vixey, Is?
08:03:54 <DuClare> Hm.
08:03:56 <vixey> DuClare: oh well... There is new syntax with QQ
08:03:56 <dmwit> Two test tickles!
08:03:59 <EvilTerran> dmwit, i wouldn't be surprised if it's doing things with her IP address
08:04:06 <EvilTerran> dmwit, o.Ã³
08:04:07 <vixey> DuClare: But you have to trick 6.9 into compiling
08:04:07 <Botje> dmwit: groan :)
08:04:09 <DuClare> I'm hoping the new standard will bring something for this
08:04:19 <chrisdone> dmwit: hahaha
08:04:20 <Twey> dmwit: Big groan :-P
08:04:23 <vixey> DuClare: haskell' ?
08:04:29 <MyCatVerbs> chrisdone: oooh, I know!
08:04:35 * EvilTerran is still a little annoyed that Google took their SOAP interface down
08:04:36 <MyCatVerbs> chrisdone: how about vibrating Furbies?
08:04:41 <DuClare> vixey, Yes
08:04:47 <vixey> DuClare: Why care about Haskell', you could design and implement your own language :)
08:05:03 <chrisdone> dmwit: a magic tractor is driving down a road, and turns into a field
08:05:11 <dmwit> amazing!
08:05:21 <dmwit> chrisdone: You know when a door is not a door?
08:05:25 <chrisdone> dmwit: when it's ajar :P
08:05:28 <dmwit> ;-)
08:05:32 <DuClare> Why design yet another language.  There are too damn many already.  I'd rather see the existing ones improve. ;)
08:05:34 <chrisdone> dmwit: best jokes ever
08:05:43 <Twey> What did one whale say to the other when it got back from holiday?
08:05:44 <dmwit> chrisdone: What did the farmer say when he couldn't find his tractor?
08:05:47 <chrisdone> dmwit: a woman walks into a bar and asks the barman for a double entendre; so he gives her one
08:05:51 <chrisdone> dmwit: what? :P
08:05:52 <Twey> 'I had a whale of a time'
08:05:52 <dmwit> "Hey!  Where's my tractor?"
08:05:58 <chrisdone> dmwit: hahah
08:05:58 * Twey laughs.
08:06:11 <MyCatVerbs> chrisdone: how do you fit eighteen astronaughts in a mini?
08:06:14 <chrisdone> dmwit: oh god. I love these jokes
08:06:19 <chrisdone> MyCatVerbs: how?
08:06:23 <MyCatVerbs> chrisdone: two in the back, two in the front, fourteen in the ash tray.
08:06:26 <ivanm> does dons still maintain ghc-core?
08:06:38 <vixey> DuClare: I think that languages don't improve, new ones are created..
08:06:41 <EvilTerran> MyCatVerbs, ...
08:06:42 <chrisdone> MyCatVerbs: haha, brilliant
08:07:16 <Botje> that's one thing the imperative pigs have on us.
08:07:24 <Botje> they can change and update their languages, we have to create new ones.
08:07:36 <EvilTerran> heh. remarkably close to the truth.
08:08:03 * Twey grins.
08:08:09 <dmwit> bye guys!
08:08:10 <Twey> 'Imperative scum!'
08:08:14 <Twey> 'bye dmwit :-D
08:08:17 <Twey> Thanks for the help
08:08:29 <vixey> hahhah "imperative pigs"
08:08:51 <sheyll> hi
08:08:57 <vixey> hello
08:09:20 <MyCatVerbs> Botje: usually we can just define a clever enough combinator to get around the same issue, though.
08:09:30 * Twey grins.
08:09:40 <sheyll> what flags to I have to add into the source to enable "forall" ?
08:10:06 <MyCatVerbs> Botje: e.g. envious of C++'s constructor-destructor (with ordering enforced!) semantics? Define a bunch of withFoo functions! ^_^
08:10:18 <Botje> :)
08:10:22 <MyCatVerbs> sheyll: {-# LANGUAGE ExistentialTypes #-}, IIRC.
08:10:38 <sheyll> thank you MyCatVerbs
08:10:54 <Botje> I was amazed by the Cont trick for combining withFoo's
08:10:55 <chrisdone> MyCatVerbs: envious of Haskell's withFoo capabilities? invent a horrible thing like RAII! ^__^
08:10:56 <MyCatVerbs> sheyll: put that in front of the "module Foo where" line so it's the first thing the compiler sees.
08:11:11 <sheyll> ok
08:11:24 <baaba> RAII is the best thing that ever happened to any C derivative
08:11:34 <baaba> it's unfortunate, then, that only C++ and D adopted it
08:11:35 <sheyll> ghc complaints: cannot parse LANGUAGE pragma...
08:11:38 <chrisdone> it seems like a mistake to me
08:11:44 <MyCatVerbs> sheyll: whoops.
08:11:44 <sheyll> ghci actually
08:11:59 <ivanm> has anyone here managed to build ghc-core-0.3?
08:12:11 <MyCatVerbs> sheyll: ExistentialQuantification not ExistentialTypes
08:13:09 <sheyll> no it works, thanks MyCatVerbs
08:13:13 <MyCatVerbs> sheyll: sorry. The correct feature names can be found over here, though you'll need to check your compiler's manual to find out which ones correspond to which features: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
08:13:14 <lambdabot> Title: Language.Haskell.Extension, http://tinyurl.com/2xjyqs
08:13:16 <sheyll> now
08:13:25 <MyCatVerbs> No worries.
08:14:27 <MyCatVerbs> sheyll: oh and you can give a comma seperated list in the LANGUAGE pragma, too, if you need more than one feature. ^^
08:14:51 <sheyll> uhmm ... I have another question, what is actually the diffrence between data and newtype?
08:15:26 <MyCatVerbs> newtypes only work for a single data field and a single constructor.
08:15:42 <Jedai> sheyll: newtype is purely virtual, the outside layer get removed after compilation
08:15:43 <Twey> sheyll: newtype causes the datatype to represented internally as the datatype you use
08:15:44 <MyCatVerbs> newtypes are always strict in the data element (data is by default lazy)
08:16:00 <Twey> For a performance gain.
08:16:07 <Jedai> sheyll: And that has consequences on strictness (like MyCatVerbs said)
08:16:08 <MyCatVerbs> Pattern-matching against the constructor of a newtype always succeeds. (Bit of a random one that you'll never come across.)
08:16:30 <Twey> MyCatVerbs: Unless you send it something of the wrong type?  :-P
08:16:41 <MyCatVerbs> Twey: no, that doesn't even typecheck.
08:16:44 <sheyll> ahhhhh...now I get it
08:16:50 <vixey> newtype demands a single constructor
08:16:52 <MyCatVerbs> Twey: can't have a runtime failure in a piece of code that doesn't compile.
08:17:00 <Twey> Ah, good point.
08:17:09 <MyCatVerbs> sheyll: oh and if you ever think of trying to use newtype on a tuple... don't. :P
08:17:12 <vixey> this invarient lets the implementation do a  few useful things
08:17:17 <vixey> invariant
08:17:17 * sheyll 's brain just clicked loudly
08:17:25 <Jedai> MyCatVerbs: Why ?
08:17:29 <Twey> sheyll: *chuckles*
08:17:31 <MyCatVerbs> Jedai: because it'll be a waste of time.
08:17:41 <MyCatVerbs> Jedai: the tupling will require the compiler to box the thing anyway.
08:17:44 <ivanm> @ask dons is there a bug in ghc-core-0.3? Every time I try and build it ghc complains about a type mismatch on line 135 of ghc-core.hs (expected: String, inferred: String -> String)
08:17:45 <lambdabot> Consider it noted.
08:18:08 <Jedai> MyCatVerbs: Yeah but if you just want to give some new instances ?
08:18:10 <MyCatVerbs> Jedai: newtype Foo1 = Foo1 (Int,Int) is practically indistinguishable, even in memory usage and laziness, from data Foo2 = Foo2 Int Int.
08:18:20 <MyCatVerbs> Jedai: oh right, yeah, fair point.
08:18:34 <Jedai> MyCatVerbs: So the argument is that it's uglier for no benefits ?
08:18:51 <MyCatVerbs> Entirely that. Except that you just pointed out the benefits with instances.
08:19:47 <Botje> .oO(what about Foo1 undefined?)
08:19:59 <Jedai> Well no, there's no benefit compared to a data declaration (except if you mean NewTypeDeriving ?)
08:20:07 <Botje> ah, no
08:20:09 <Botje> works there too :)
08:21:12 <Jedai> @instances (a,b)
08:21:20 <lambdabot> Couldn't find class `(a,b)'. Try @instances-importing
08:22:11 <sheyll> will Foo1 (_|_, 1) fail "immediately" ?
08:22:32 <Twey> > _|_
08:22:32 <lambdabot>  Parse error at "|_" (column 2)
08:22:35 <Twey> Yes.
08:22:59 <Jedai> sheyll: No, because there's a tuple around it
08:23:17 <sheyll> ??
08:24:13 <sheyll> so as soon a the tuple is "there", the contents of the tuple are evauluted lazyly (by the rules of the (,) function?)
08:24:20 <Jedai> sheyll: For exemple you can do "getSnd (Foo1 (_,b)) = b" on "Foo1 (undefined,1)"
08:24:25 <xerox> > (snd . fromJust) (Just (undefined,"foo")
08:24:25 <lambdabot> Unbalanced parentheses
08:24:27 <xerox> > (snd . fromJust) (Just (undefined,"foo"))
08:24:43 <lambdabot>  thread killed
08:25:05 <Jedai> sheyll: tuples are lazy in their components (which is sometimes a great cause of inefficiencies)
08:25:35 <Jedai> > (snd . fromJust) (Just (undefined,"foo"))
08:25:36 <lambdabot>  "foo"
08:25:50 <sheyll> will (snd (undefined, "bar")) work?
08:26:06 <sheyll> > (snd (undefined, "bar"))
08:26:07 <lambdabot>  "bar"
08:26:11 <sheyll> ahh
08:26:16 <Jedai> sheyll: Yeah, since tuples are lazy in their components and snd don't look at the first component
08:26:33 <vixey> > let prime = (==[prime]) . divisors ; divisors n = factor [2..] n ; factor fs@(f:s) n = case n `divMod` f of (0,1) -> [] ; (remander,0) -> f : factor fs remainder ; _ -> factor s n in filter prime [2..]
08:26:43 <lambdabot>   Not in scope: `remainder'
08:28:06 <Jedai> sheyll: An exemple of a nasty consequence of tuple lazyness : "foldl' (\a (m, s) -> (max m a, s + a) (0,0)" can stack overflow
08:28:10 <cnwdup> dcoutts: ping
08:28:39 <vixey> > let prime p = (==[p]) $ divisors p ; divisors n = factor [2..] n ; factor fs@(f:s) n = case n `divMod` f of (0,1) -> [] ; (remander,0) -> f : factor fs remainder ; _ -> factor s n in filter prime [2..]
08:28:40 <lambdabot>   Not in scope: `remainder'
08:28:42 <Jedai> > foldl' (\a (m, s) -> (max m a, s + a)) (0,0) [1..100000]
08:28:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
08:28:43 <lambdabot>       Expec...
08:28:53 <vixey> > let prime p = (==[p]) $ divisors p ; divisors n = factor [2..] n ; factor fs@(f:s) n = case n `divMod` f of (0,1) -> [] ; (remainder,0) -> f : factor fs remainder ; _ -> factor s n in filter prime [2..]
08:28:55 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:29:05 <Jedai> > foldl' (\(m, s) a -> (max m a, s + a)) (0,0) [1..100000]
08:29:06 <lambdabot>  (100000,5000050000)
08:29:11 <Jedai> > foldl' (\(m, s) a -> (max m a, s + a)) (0,0) [1..1000000]
08:29:13 <lambdabot>  (Exception: stack overflow
08:29:20 <sheyll> hmmmmmmmmm
08:29:26 <dcoutts_> cnwdup: pong
08:29:48 <Jedai> sheyll: Do you understand the foldr/foldl/foldl' issue yet ?
08:29:55 <sheyll> yes
08:30:07 <sheyll> I am just thinking why the stack overflow occurs
08:30:10 <cnwdup> dcoutts_: gour told me you could help with that. I am trying to import the Graphcis.UI.Gtk.OpenGL module but ghc can't find it. I have the OpenGL and the gtk2hs package installed.
08:30:24 <Jedai> sheyll: ok, then the "stack overflow" should surprise you (because I used foldl')
08:30:28 <Jedai> ??
08:30:43 <sheyll> so what does foldl' mean?
08:30:50 <wozer> TOD (-1000) 0
08:30:55 <wozer> > TOD (-1000) 0
08:30:56 <lambdabot>   Not in scope: data constructor `TOD'
08:30:59 <sheyll> > :t foldl'
08:30:59 <lambdabot>   parse error on input `:'
08:31:04 <sheyll> :t foldl'
08:31:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:31:14 <dcoutts_> cnwdup: you need to build gtk2hs with the opengl support enabled.
08:31:50 <cnwdup> dcoutts_: It is built with --enable-opengl.
08:31:57 <wozer> > System.Time.TOD (-1000) 0
08:31:58 <lambdabot>   Not in scope: data constructor `System.Time.TOD'
08:32:01 <Jedai> sheyll: In fact the problem is that foldl' just strictify the top structure of the accumulator, here it just check that we have a tuple but don't look at the components (because tuples are lazy)
08:32:30 <MyCatVerbs> sheyll: foldl f [1,2,3,4,5] = (((1 `f` 2) `f` 3) `f` 4) `f` 5
08:32:55 <MyCatVerbs> Er, forgot the terminating element.
08:33:07 <tromp> > foldl f [a,b,c]
08:33:08 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
08:33:09 <sheyll> ok, so the stack overflows because of all the additions?
08:33:23 <MyCatVerbs> > foldl f d [a,b,c]
08:33:24 <vixey> > let n x = 1+x ; d x = 1/(1+1/x) in map (foldr (.) id) (map (flip replicateM) [n,d] [0..]) 1
08:33:24 <lambdabot>  f (f (f d a) b) c
08:33:25 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
08:33:39 <MyCatVerbs> sheyll: the stack overflows because lazy thunks are being built up for the additions.
08:34:00 <dcoutts_> cnwdup: then double check it all worked properly. If --enable-opengl was used to configure and it installed without complaining then the gtkglext package will be available.
08:34:03 <Jedai> sheyll: Yes, or the max, anyway the components of the accumulator tuple aren't evaluated before the end of the foldl and the thunks become too big to hold into the stack when we finally want to evaluate them
08:34:37 <MyCatVerbs> sheyll: so you're ending up with massive expressions that look like (1+1+1+1+1+1+1+...) when what you really want is to expressions like (1+1), (2+1), (3+1), (4+1)...
08:34:41 <cnwdup> dcoutts_: Ok. I'll try to build it myself with --enable-opengl. Thank you.
08:34:53 <dcoutts_> cnwdup: good luck :-)
08:35:06 <sheyll> ok, but the max ... expression must be evaluated everytime, right?
08:35:12 <Jedai> sheyll: Which is why you should use strict tuples for cases like that (in plenty of cases anyway)
08:35:42 <Jedai> sheyll: No they just accumulate because we never look at them during the traversal
08:36:25 <sheyll> ahh yes
08:36:35 <Jedai> sheyll: We just look at the accumulator and say "ok, it's a real tuple, not an undefined value"
08:37:11 <sheyll> so what does foldl' do compared to foldl? how is strictness enforced, and on what?
08:37:41 <Jedai> sheyll: foldl' evaluate its accumulator at each step of the traversal, foldl don't
08:38:18 <Jedai> sheyll: but the trick here is that "evaluation" just mean looking at the first layer of the data structure, not deeper
08:38:25 <sheyll> ahhhhhhhhhhh
08:38:26 <sheyll> ok
08:38:30 <sheyll> now i get it
08:38:36 <sheyll> always forget about that
08:38:51 <sheyll> so the tuple is actually the first layer
08:38:58 <vixey> > (100%)   $5
08:38:59 <lambdabot>  20%1
08:39:01 <sheyll> and as long as this is not undefined, ok
08:39:18 <sheyll> pretty neat, though
08:39:43 <sheyll> vixey: :-)
08:39:45 <tromp> > const undef `seq` ()
08:39:46 <lambdabot>   Not in scope: `undef'
08:39:51 <tromp> > const undefined `seq` ()
08:39:52 <lambdabot>  ()
08:40:05 <Twey> Mmn?
08:40:08 <Twey> :t seq
08:40:10 <lambdabot> forall a t. a -> t -> t
08:40:14 <tromp> evaluation means reduction to weak head normal form
08:40:17 <Twey> @src seq
08:40:17 <lambdabot> Source not found. There are some things that I just don't know.
08:40:23 <Twey> :-\
08:40:27 <sheyll> tromp ahhh
08:40:28 <sheyll> ok
08:40:32 <vixey> > let divisors n = factor [2..] n ; factor fs@(f:s) n = case n `divMod` f of (0,1) -> [] ; (remainder,0) -> f : factor fs remainder ; _ -> factor s n in divisors (2^127-1)
08:40:34 <Twey> seq is magic?
08:40:35 <lambdabot>  Tried to use too much memory
08:40:58 <Jedai> Twey: Yes, seq is magic, you can't define it in a lazy language
08:41:14 <Twey> Really?  Why not?
08:41:25 <Jedai> > undefined `seq` ()
08:41:27 <lambdabot>  Exception: Prelude.undefined
08:41:30 <tromp> semantically, seq is same as const id
08:41:37 <Jedai> > (undefined, undefined) `seq` ()
08:41:38 <lambdabot>  ()
08:41:45 <Twey> What is it meant to do?
08:41:48 <vixey> > let n x = 1 + x ; d x = 1/(1+1/x) ; foo x = [n x,d x] in iterate (>>= foo) [1]
08:41:50 <lambdabot>  [[1.0],[2.0,0.5],[3.0,0.6666666666666666,1.5,0.3333333333333333],[4.0,0.75,1...
08:41:58 <sheyll> is that correct? :   seq a b = if a /= undefined the b else undefined
08:42:19 <vixey> > let n x = 1 + x ; d x = 1/(1+1/x) ; foo x = [n x,d x] in concat $ iterate (>>= foo) [1] :: Rational
08:42:20 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
08:42:26 <sheyll> > seq undefined 1
08:42:27 <lambdabot>  Exception: Prelude.undefined
08:42:28 <vixey> > let n x = 1 + x ; d x = 1/(1+1/x) ; foo x = [n x,d x] in concat $ iterate (>>= foo) [1] :: [Rational]
08:42:29 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
08:42:44 <sheyll> > seq (undefined,0) 1
08:42:45 <lambdabot>  1
08:43:31 <sheyll> thanx for all the great help and explanations!
08:44:17 <chrisdone> ivanm: ping
08:44:44 <Jedai> sheyll: Conceptually your definition of seq is quite right, but you can't compare anything to "undefined"
08:44:56 <ivanm> chrisdone: about to hit the sack... but pong!
08:45:35 <lispy> g'morning #haskell
08:45:36 <sheyll> because the result would be undefined
08:45:40 <chrisdone> ivanm: well, for future reference, this patched GOA re-reads the lambdabot process from your .ghci file: http://chrisdone.com/haskell/goa.tar.gz (or darcs http://chrisdone.com/haskell/goa/ )
08:46:01 <Jedai> sheyll: Exactly, which means that the result of your "seq" would always be "undefined"
08:46:09 <sheyll> so how is seq defined??
08:46:14 <lispy> ?src seq
08:46:15 <lambdabot> Source not found. Sorry.
08:46:19 <lispy> sheyll: magic, iirc
08:46:19 <vixey> sheyll: It's not
08:46:34 <lispy> sheyll: it's primitive is what I Should say
08:46:36 <Jedai> sheyll: magic ! As I said, you can't define it in a lazy language, so it's a built-in
08:46:46 <sheyll> that's cheating... :-)
08:46:50 <ivanm> OK, but it looks like I'm not going to be building lambdabot... cabal doesn't like how I've got different versions of bytestring installed :s
08:46:55 <vixey> cheating is just fine
08:47:10 <baaba> at some point you have to abandon ideology for pragmatism
08:47:11 <chrisdone> ivanm: ok
08:47:13 <dcoutts_> ivanm: just do what cabal says, use the version it says is necessary
08:47:17 <dcoutts_> ivanm: I don't see the problem
08:47:22 <lispy> ivanm: isn't the solution for that to hide one of them or specify the exact one to use in the .cabal?
08:47:36 <osfameron> seq can't be defined normally?  I thought you just had to annotate it for strictness?
08:47:45 <ivanm> dcoutts_: cos then I'd have to rebuild all those packages again to take into account the other version of bytestring installed :p
08:47:51 <vixey> seq !x y = y -- ?
08:47:55 <dcoutts_> lispy: it depends on the ghc package which depends on an exact bytestring version, there's nothing you can do about that.
08:47:55 <lispy> osfameron: er, well how do you define the strictness annotation?
08:48:03 <vixey> is that valid
08:48:10 <osfameron> lispy: well, I'd presume *that* was the builtin... is it actually the other way around?
08:48:21 <lispy> vixey: well, bang patterns have to desugar into something :)
08:48:27 <vixey> no they don't
08:48:33 <vixey> they could compile into something
08:48:38 <lispy> osfameron: right, seq is in the language spec but bang patterns are an extension
08:48:40 <vixey> hmm
08:48:52 <vixey> yeah well I guess that's it
08:49:03 <osfameron> ah ok
08:49:22 <sheyll> in a newtype declaration ghc does not allow me to use "forall", but I don't quite understand why, could you give me a hint?
08:49:29 <osfameron> me wonders why there's a seq a->b->b instead of just a force a->a
08:49:29 <lispy> foo !x = bar ==> foo | x `seq` bar
08:49:42 <seliopou> sheyll: -fglasgow-exts, maybe?
08:49:44 <lispy> er wait
08:49:55 <lispy> foo | x `seq` False, is more lke it
08:50:34 <tromp> the force wouldn't be evaluated...
08:50:49 <sheyll> seliopou: no. doesn't work
08:51:43 <seliopou> sheyll:
08:51:44 <seliopou> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
08:51:45 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
08:52:05 <Jedai> osfameron: And what would "force x" do that "x" doesn't already do ?
08:52:09 <tromp> you cld define force = join seq
08:52:28 <tromp> for those cases where you use x `seq` x
08:52:31 <osfameron> Jedai: force evaluation?
08:52:40 <seliopou> tromp: that doesn't type
08:52:43 <seliopou> :t join seq
08:52:45 <lambdabot> forall a. a -> a
08:52:49 <rwbarton> tromp: x `seq` x = x
08:52:49 <seliopou> or maybe it does :)
08:52:51 <osfameron> I don't understand why seq just throws away the argument it forces
08:52:59 <tromp> yes, it's not a useful case:(
08:53:11 <Jedai> osfameron: when you evaluate x you evaluate x, you don't need to put a force before it to get this effect...
08:53:26 <seliopou> osfameron: it's for stuff like this:
08:53:34 <seliopou> x `seq` (... x ...)
08:53:43 <seliopou> get it?
08:53:56 <osfameron> a
08:53:58 <osfameron> ah
08:54:22 <sheyll> data Method scope = forall a. (Read a), (Show a) => Method String (a -> a)
08:54:27 <osfameron> to prevent the rhs expression using an uncalculated thunk of x
08:54:29 <sheyll> data Method scope = forall a. (Read a), (Show a) => Method String (a -> a)
08:54:37 <osfameron> seliopou: yeah, much clearer with an example, thanks
08:54:43 <sheyll> data Method scope = forall a. (Read a), (Show a) => Method String (a -> a)
08:54:52 <sheyll> ohs sorry!!!
08:54:59 <sheyll> my client hang
08:55:04 <osfameron> though you can do  x `seq` (expression that has nothing to do with x) too ?
08:55:08 <seliopou> sheyll: did you find the flag you needed from that page?
08:55:14 <seliopou> osfameron: yeah
08:55:14 <sheyll> yes.
08:55:39 <sheyll> uhmm how do I put several restrictions on "a"?
08:55:42 <Jedai> osfameron: That can be useful too, x could be in another data structure
08:55:51 <sheyll> the line I pasted doesn't work.. :(
08:55:54 <seliopou> osfameron: I do that sometimes when I'm using unsafePerformIO for debugging
08:56:00 <rwbarton> (Read a, Show a)
08:56:24 <seliopou> ^ yep
08:56:42 <sheyll> rwbarton: thank you :-)
08:57:29 <mightybyte> Is there any recently maintained haskell shell?
08:58:16 <mightybyte> ll
08:58:21 <mightybyte> Oops
08:59:40 <xerox> mightybyte: have you seen h4sh? it's on dons' site.
09:00:40 <mightybyte> xerox: No, I saw haskal and hashell
09:05:48 <BMeph> @let seq1 a b = if a == a then b else undefined -- the else is superfluous, but explanatory
09:05:49 <lambdabot> Defined.
09:06:31 <BMeph> > seq1 (undefined,undefined) 9
09:06:34 <lambdabot>  Exception: Prelude.undefined
09:06:39 <Cale> > seq1 (0.0/0) 1
09:06:41 <lambdabot>  Exception: Prelude.undefined
09:07:17 <BMeph> Well, THAT didn't work! 8D
09:08:01 <Cale> @undefine
09:08:01 <lambdabot> Undefined.
09:08:08 <Cale> @let seq1 a b = if a == a then b else b
09:08:08 <lambdabot> Defined.
09:08:15 <Cale> > seq1 (0.0/0) 1
09:08:16 <lambdabot>  1
09:08:31 <Deewiant> @let seq2 a b = if a == a || a /= a then b else undefined
09:08:32 <lambdabot> Defined.
09:08:44 <Deewiant> > seq2 (0.0/0) 1
09:08:45 <lambdabot>  1
09:09:00 <BMeph> > let a = (0.0/0) in a == a
09:09:01 <lambdabot>  False
09:09:16 <Deewiant> NaN /= NaN
09:10:45 <mightybyte> xerox: Hmmm, h4sh (as well as the other shells I've looked at) requires hs-plugins
09:13:34 <mightybyte> ...which doesn't appear to be maintained.
09:13:39 <Jedai> > seq2 (undefined,1) 1
09:13:40 <lambdabot>  Exception: Prelude.undefined
09:14:11 <Jedai> seq can't be defined in Haskell without seq
09:17:43 <Deewiant> > let seq3 = par in seq3 (undefined,1) 1
09:17:44 <lambdabot>  1
09:17:46 <Deewiant> ;-)
09:19:56 <vixey> > ((sqrt(5)+1)/2) :: CReal
09:20:03 <lambdabot>  1.6180339887498948482045868343656381177203
09:22:29 <Deewiant> > iterate ((1+).(1/)) 1 !! 1111 :: CReal
09:22:35 <lambdabot>  Exception: Time limit exceeded
09:22:45 <Deewiant> > iterate ((1+).(1/)) 1 !! 111 :: CReal
09:22:47 <lambdabot>  1.6180339887498948482045868343656381177203
09:25:05 <EvilTerran> > ((sqrt 5 + 1)/2 :: CReal) == iterate ((1+).(1/)) 1 !! 100
09:25:07 <lambdabot>  True
09:25:52 <vixey> o_o
09:26:01 <vixey> that's not right
09:26:04 <Deewiant> > iterate ((1+).sqrt) 1 !! 111 - 1 :: CReal
09:26:05 <lambdabot>  Exception: Negative exponent
09:26:09 <EvilTerran> > let phi :: CReal; phi = (sqrt 5 + 1)/2 in length . takeWhile (/=phi) . iterate ((1+).(1/)) $ 1
09:26:11 <lambdabot>  100
09:26:14 <Deewiant> eh?
09:26:18 <MyCatVerbs> :i CReal
09:26:18 <Deewiant> > (iterate ((1+).sqrt) 1 !! 111 - 1) :: CReal
09:26:19 <lambdabot>  Exception: Negative exponent
09:26:22 <Deewiant> > (iterate ((1+).sqrt) 1 !! 111 - 1)
09:26:23 <lambdabot>  1.618033988749895
09:26:26 <MyCatVerbs> @index CReal
09:26:26 <lambdabot> bzzt
09:26:33 <Deewiant> Negative exponent?
09:26:37 <vixey> ((sqrt 5 + 1)/2 :: CReal) == iterate ((1+).(1/)) 1 !! 100 should def. be false
09:26:56 <EvilTerran> > iterate ((1+).(1/)) 1 !! 99
09:26:57 <lambdabot>  1.618033988749895
09:27:01 <lilachaze> is 'par' semantically equivalent to 'flip const'?
09:27:02 <EvilTerran> > iterate ((1+).(1/)) 1 !! 99 :: CReal
09:27:03 <lambdabot>  1.6180339887498948482045868343656381177203
09:27:08 <EvilTerran> > iterate ((1+).(1/)) 1 !! 100 :: CReal
09:27:10 <lambdabot>  1.6180339887498948482045868343656381177203
09:27:15 <EvilTerran> > iterate ((1+).(1/)) 1 !! 98 :: CReal
09:27:16 <lambdabot>  1.6180339887498948482045868343656381177203
09:27:17 <Deewiant> lilachaze: more like 'seq'
09:27:18 <EvilTerran> hm
09:27:23 <Deewiant> > iterate ((1+).(1/)) 1 !! 64 :: CReal
09:27:24 <lambdabot>  1.6180339887498948482045868328482671523058
09:27:40 <lilachaze> Deewiant: seq _|_ x = _|_, but par _|_ x = x
09:27:45 <lilachaze> (AFAICS)
09:27:50 <Deewiant> > par undefined 1
09:27:51 <lambdabot>  1
09:27:55 <Deewiant> > seq undefined 1
09:27:56 <lambdabot>  Exception: Prelude.undefined
09:27:58 <Deewiant> meh
09:28:11 <EvilTerran> > length . takeWhile id . (zipWith (==) <*> tail) . iterate ((1+).(1/)) $ (1 :: CReal)
09:28:12 <lambdabot>  0
09:28:17 <EvilTerran> > length . takeWhile id . (zipWith (/=) <*> tail) . iterate ((1+).(1/)) $ (1 :: CReal)
09:28:19 <lambdabot>  100
09:28:30 <MyCatVerbs> lilachaze: (flip const) semantically, but closer to seq in effect.
09:28:51 <lilachaze> > foldr1 par (replicate 1000 undefined ++ [42])
09:28:53 <lambdabot>  42
09:29:06 <lilachaze> MyCatVerbs: right, that's what i thought
09:29:16 <EvilTerran> > zipWith (==) <*> tail . drop 95 . iterate ((1+).(1/)) $ 1
09:29:17 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
09:29:17 <lambdabot>       Expected...
09:29:27 <Deewiant> > 2 * cos (pi / 5) :: CReal
09:29:28 <lambdabot>  1.6180339887498948482045868343656381177203
09:29:29 <EvilTerran> > (zipWith (==) <*> tail) . drop 95 . iterate ((1+).(1/)) $ 1
09:29:30 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
09:29:39 <EvilTerran> > (zipWith (==) <*> tail) . drop 95 . iterate ((1+).(1/)) $ (1 :: CReal)
09:29:45 <lambdabot>  [False,False,False,False,False,True,True,True,True,True,True,True,True,True,...
09:30:15 <lilachaze> > (f <*> g) x
09:30:16 <lambdabot>  Add a type signature
09:30:41 <MyCatVerbs> lilachaze: I don't think it affects strictness at all, though, so in places where use of `seq` would allow the strictness analyser to unbox things, `par` won't.
09:31:06 <lilachaze> MyCatVerbs: i had no idea the strictness analyser was smart enough to do that :-)
09:32:51 <MyCatVerbs> lilachaze: have a poke with ghc-core sometime, it's fun.
09:33:41 <MyCatVerbs> lilachaze: easiest example to try it on are things like the factorial or (linear!) fibonacci functions on Ints.
09:34:10 <MyCatVerbs> lilachaze: you'll note the strictness analyser going through and changing intermediate Ints to Int#s.
09:35:51 <zachk> http://hpaste.org/9313
09:35:57 <hackage> Uploaded to hackage: PageIO 0.0.3
09:35:57 <hackage> Uploaded to hackage: mueval 0.5.1
09:35:57 <hackage> Uploaded to hackage: show 0.3
09:35:58 <hackage> Uploaded to hackage: Pugs 6.2.13.11
09:35:59 <zachk> mvars, and what happened to announce?
09:36:00 <hackage> Uploaded to hackage: dephd 0.1.1
09:37:02 <performance> http://hpaste.org/9314
09:37:09 <performance> hi
09:37:26 <performance> how do i find what is wrong with that program?
09:38:06 <jeffersonheard> depends...  are we talking a compiler error or a runtime bug?
09:38:38 <performance> run time, just prints empty strings for stuff
09:38:56 <performance> the file has some contents in it..
09:38:58 <zachk> http://hpaste.org/9314#a1
09:39:01 <jeffersonheard> well, your problem here is that hGetContents is lazy
09:39:02 <MyCatVerbs> zachk: newMVar instead of newEmptyMVar.
09:39:13 <zachk> how do i use emptymvar though MyCatVerbs
09:39:13 <jeffersonheard> so when you close the file all the way with hClose, nothing ever gets read
09:39:20 <zachk> lazy reading
09:39:26 <zachk> performance: http://hpaste.org/9314#a1
09:39:39 <MyCatVerbs> zachk: also, only issue I can see with that is that you're mixing tabs and spaces, so maybe the compiler will swear at you.
09:39:50 <jeffersonheard> the better way would be to not use the h* functions at all, and just use readFile, which will take care of the file close operation for you
09:40:00 <jeffersonheard> closing only after all the contents are consumed
09:40:40 <MyCatVerbs> zachk: hrmn? What's the problem you have with the mvar-using code you posted?
09:41:09 <jeffersonheard> performance, http://hpaste.org/9315
09:41:14 <MyCatVerbs> zachk: if you're wondering why you only ever get one copy of "Hello" printed, that's because taking from an MVar leaves it empty, and you're only putting into that MVar once.
09:41:20 <zachk> performance: http://hpaste.org/9314#a2
09:41:37 <zachk> MyCatVerbs: thank you
09:41:39 <MyCatVerbs> zachk: oh right, and the other issue.
09:41:49 <jeffersonheard> zachk's stuff works, too, performance
09:42:07 <MyCatVerbs> zachk: Haskell programs end as soon as main quits, so that'll exit as soon as the forkIO finishes creating the new thread.
09:42:09 <performance> hmm.. mapM_ maps print to each line?
09:42:35 <zachk> MyCatVerbs: so i should loop my main"thread" as well
09:42:41 <jeffersonheard> yes.  much like map, but mapM_ allows you to do things that return an IO m
09:43:20 <jeffersonheard> however, performance, note that "print" will pretty-print the strings, giving you quotes at the beginning and end of each line
09:43:24 <zachk> performance: i use mapM_ when i want to use a function with side effects and i dont care about the return value, i often use it on a list
09:43:25 <MyCatVerbs> zachk: oh wait, there's another issue. putMVar doesn't return anything useful just (). You don't want to do box <- putMVar "Hello!" box, you want to just do putMVar "Hello!" box.
09:43:28 <jeffersonheard> you may instead want putStrLn
09:43:32 <EvilTerran> ?src mapM_
09:43:32 <lambdabot> mapM_ f as = sequence_ (map f as)
09:43:38 <EvilTerran> ?src sequence_
09:43:38 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:43:58 <EvilTerran> alternatively, sequence_ [] = return (); sequence_ (x:xs) = do x; sequence_ xs
09:44:16 <zachk> MyCatVerbs: can i put to an Mvar more then once?
09:44:21 <zachk> do they work like queues?
09:44:47 <MyCatVerbs> zachk: http://hpaste.org/9313#a1
09:45:28 <MyCatVerbs> zachk: you can put into an MVar any number of times. An MVar always has exactly 0 or 1 things in it.
09:45:31 <performance> thanks guys. is there any good entry level documentation on hash tables, Data.Map ?   im having trouble understanding how to update a particular key
09:45:34 <sal23> does GHC 6.10 have capability to parallelize code execution even if it doesn't use ndp library?
09:45:48 <MyCatVerbs> zachk: if you try to put into an MVar that is empty, it becomes full. If you try to take from an MVar that is full, it becomes empty.
09:45:51 <performance> same with list..
09:46:09 <EvilTerran> Data.Map isn't a hash table, incidentally - it's a tree
09:46:13 <EvilTerran> but it comes to the same thing
09:46:50 <MyCatVerbs> zachk: if you try to fill an already-full MVar, the thread that ran putMVar will block until the MVar is taken from by some other thread. If you try to take from an empty MVar, the thread that tries to take is blocked until some other thread puts something into that MVar.
09:47:06 <EvilTerran> performance, there's no primitive to update a single element in a list, because it's not very time- or space-efficient
09:47:12 <MyCatVerbs> sal23: using `par`, with the threaded RTS? GHC6.6 will do that.
09:47:15 <EvilTerran> s/not very/very not/
09:47:23 <EvilTerran> (modulo grammar :P)
09:47:52 <MyCatVerbs> sal23: GHC 6.10 should, AFAIK, have a parallel GC, too. :)
09:48:05 <EvilTerran> performance, most of the functions you'll need will be described in the haddock for Data.List and Data.Map
09:48:40 <sal23> MyCatVerbs: I forgot about RTS option...which parallel GC algorithm is being implemented in 6.10?
09:48:51 <performance> actually i cant figure out how an update can happen, when it is supposed to be pure
09:49:26 <jeffersonheard> well, performance, it's all in the conceptual structure...  you never update, you simply create anew
09:49:36 <EvilTerran> performance, you don't actually change anything, you just make a new map or list or whatever
09:49:39 <zachk> MyCatVerbs: forever what; what do i put in what to have it do nothing and just infinitely loop
09:49:50 <MyCatVerbs> sal23: I don't know. All I can remember offhand is that it's still stop-the-world rather than concurrent, it's just that it can take advantage of SMP during some of the more expensive parts of the collection.
09:50:00 <performance> sounds very resource consuming
09:50:03 <jeffersonheard> but because of laziness, exploitation of shared structure, and optimization, you won't actually create an *entirely* new map when you do this
09:50:16 <EvilTerran> performance, however, the tree structure that i mentioned Data.Map uses means that you can share all but O(log n) nodes in the tree when replacing one element in a Map of n elements
09:50:31 <jeffersonheard> so no, it's not resource consuming at all.  at the most basic level, think of a linked list that you code in C.
09:50:46 <zachk> and for any small N O(log n)=O(1)
09:50:55 <MyCatVerbs> zachk: why do you want your program to infinitely loop? forever (return ()) will do that, but why?
09:51:00 <jeffersonheard> if you pass the list off to a thread, with the head pointed at element B, then that's as much of the list that the thread will ever see
09:51:18 <EvilTerran> performance, for a simpler example, consider "replaceHead x [] = []; replaceHead x (_:xs) = x:xs"
09:51:20 <zachk> MyCatVerbs: i have no idea how to use threads, never used them in my life so im just trying to get them working so i can tinker with them
09:51:22 <jeffersonheard> if you then add elements to the beginning of the list later, you conceptually have a "new" list
09:51:34 <EvilTerran> performance, calling replaceHead on a list doesn't result in any list cells being copied
09:51:45 <jeffersonheard> which you can pass to other functions without affecting thread B's view of the list
09:52:06 <EvilTerran> performance, only a single new cell is made, with its "tail" field pointing to an existing cell
09:52:13 <EvilTerran> (namely, the second cell in the original list)
09:52:44 <jeffersonheard> and to add to what EvilTerran is saying, performance, maps are simply specially ordered lists, so the updates occur more or less the same way
09:53:05 <performance> ususally maps are some kind of a balanced tree
09:53:07 <EvilTerran> jeffersonheard, uh... i think they're a bit more complicated than "specially ordered lists"
09:53:18 <jeffersonheard> I was being simplistic, EvilTerran, yes
09:53:19 <EvilTerran> as performance says, some kind of tree
09:53:22 <jeffersonheard> I know how they're stored
09:53:25 <MyCatVerbs> zachk: right, I don't really know how to teach you that. I'm afraid I learned the hard way.
09:53:54 <MyCatVerbs> zachk: best guess is, pick up a reasonably good textbook. http://www.greenteapress.com/semaphores/ <-- this is both free and excellent, although it revolves around semaphores.
09:53:54 <lambdabot> Title: The Little Book of Semaphores
09:54:22 <jeffersonheard> sorry, EvilTerran...  that sounded ruder than it was meant
09:54:26 <MyCatVerbs> zachk: but you can implement everything in there with Control.Concurrent.QSem anyway.
09:54:55 <zachk> MyCatVerbs: im an undergrad in a weak cs program atm, just attempting to extend my horizons way paste what ive been taught so far, because im not learning much
09:55:06 * EvilTerran gets uncomfortable about simplifying explanations to the point when they're not really true any more, is all
09:55:19 <jeffersonheard> E.T., fair enough
09:55:33 <EvilTerran> i got enough of that from my school teachers :P
09:55:53 <jeffersonheard> I'm in the middle of writing a tutorial on Haskell for visualization people, though, and so I'm in elementary school mode
09:56:06 <b\6> why doesn't last return Maybe a?
09:56:13 <zachk> jeffersonheard: visualization people? definition?
09:56:14 <b\6> head, etc.
09:56:19 <EvilTerran> b\6, for the same reason head doesn't
09:56:26 <MyCatVerbs> b\6: because that'd be tedious, probably.
09:56:27 <EvilTerran> "because the report says so"
09:56:48 <BMeph> EvilTerran: Just curious, but do you know of any textbooks that deal with runtime system design? :)
09:56:52 <jeffersonheard> zachk, people who work in scientific visualization, information visusalization, or visual analytics.  See Edward Tufte's books at http://www.tufte.com
09:57:04 <EvilTerran> also, because haskell isn't a total language anyway
09:57:18 <MyCatVerbs> zachk: good on you, then.
09:57:56 <EvilTerran> BMeph, er... not off-hand, no. i'm not really inspired enough by the prospect of RTS design to read books on it ;)
09:58:04 <b\6> so does everyone write safe* that return Maybe or just rig it so the dangerous condition can't occur, or what?
09:58:08 <zachk> MyCatVerbs: most of my stuff was self taught, but i never really liked C, was into scheme for a bit but then found it had crap for libraries and compilers
09:58:33 <BMeph> EvilTerran: Hm, fair enough. Does that mean you might know of some relevant papers? :)
09:58:35 <jeffersonheard> Basically, OpenGL bindings in Haskell are better than the C bindings, so I've managed to sell my local research group on the idea that they should be using Haskell
09:58:39 <performance> one more quick question.. why must foldl be used on a finite list only? to me it seems foldr should be teh one to apply on finite lists only
09:58:50 <ddarius> b\6: Mostly people don't use head that much.
09:59:05 <EvilTerran> BMeph, no :P
09:59:06 <jeffersonheard> because, performance, tail recursion works differently in lazy languages than it does in strict ones
09:59:07 <jeffwheeler> lambdabot should add spaces inside ( : ), as most clients otherwise interpret it as a smiley
09:59:07 <zachk> i believe foldl is strict not lazy, i may be wrong
09:59:14 <performance> foldl keeps updating its accumulator as the list is traversed from left to right
09:59:19 <jeffersonheard> foldl is not strict... no
09:59:22 <jeffersonheard> foldl' is strict
09:59:23 <EvilTerran> zachk, foldl' is strict
09:59:25 <EvilTerran> foldl is lazy
09:59:26 <jeffwheeler> . . . and lambdabot uses (:) all the time.
09:59:30 <MyCatVerbs> performance: because foldl has to keep building up: f (f (f (f (f (f (f... all the way up 'til it can finally stick firstelement) secondelement)...
09:59:54 <ddarius> jeffersonheard: Such clients should be shot.
09:59:55 <zachk> MyCatVerbs: im guessing that would crash stack or run out of room on an infinite list
10:00:08 <performance> and how is that different from foldr because if has to do the same thing there too right? except in teh reverse order
10:00:23 <MyCatVerbs> performance: whereas foldr can emit: f firstelement (f secondelement (f thirdelement (... ))))))... which means that, if f emits something early, then foldr can emit early too.
10:00:29 <MyCatVerbs> zachk: yes, indeed it does.
10:00:33 <jeffersonheard> ddarius, which clients?
10:00:49 <BMeph> performance: Because foldr can potentially do partial function application , depending on elements further to the left than the last.
10:01:03 <ddarius> jeffersonheard: Er sorry, that was meant for jeffwheeler
10:01:12 <BMeph> performance: ...aw, never mind, it's already being/been said. :)
10:01:12 <jeffersonheard> ah good.  I was confused
10:01:23 <Shiruka> > head $ foldr (:) (1:undefined) []
10:01:37 <jeffwheeler> ddarius: is Pidgin not the most popular client on Linux, and Adium the most popular client on Mac?
10:01:38 <lambdabot>  thread killed
10:01:45 <jeffersonheard> anyway, writing this tutorial for the research group, but also giving it at DEFUN2008 in Victoria
10:01:46 <Shiruka> :-<
10:01:46 <jeffwheeler> ddarius: as far as I know, both do by default
10:01:53 * Shiruka looks pityingly at \bot
10:01:54 <MyCatVerbs> Shiruka: that's just \bot being temperamental.
10:02:07 <chrisdone> sal23: hey. I've written a basic rundown of GOA and how to install it: http://chrisdone.com/blog/2008/08/01/ghci-on-acid-goa/
10:02:08 <lambdabot> Title: 17 Chris Dones Blog 1b » GHCi on Acid (GOA) b
10:02:20 <Shiruka> sabotaging my demonstration, eh, \bot :-<
10:02:41 <MyCatVerbs> > head $ foldr (:) [] (1:undefined)
10:02:42 <ddarius> jeffwheeler: They shouldn't be shot because they are popular.  You should be able to turn such nonsense off.  If you can't, then they quite definitely should be shot.
10:02:43 <lambdabot>  1
10:02:52 <BMeph> jeffwheeler: I shouldn't answer for ddarius, but I'd say "Definitely not!" :)
10:03:05 <Shiruka> oh, oops :-D
10:03:16 <MyCatVerbs> Wait, who's being shot?
10:03:22 <sal23> chrisdone: good stuff....I have been trying to install it...only thing is that showQ mode is broken for lambdabot...gotta figure what is broken for that plugin on intel mac
10:03:33 <jeffwheeler> ddarius: I think they can be turned off, but only globally --- no smileys for /any/ type of chat, and I don't think most people want that.
10:03:40 <chrisdone> sal23: oh dear :/
10:03:51 <jeffwheeler> BMeph: Definitely not the most popular?
10:03:54 <ddarius> jeffwheeler: People who want smileys should be shot.
10:03:54 <jeffersonheard> Basically, performance, Haskell will only evaluate exactly enough of an expression to provide what answer is required.
10:04:03 <BMeph> MyCatVerbs: IRC clients that "automatically" render smilies. :)
10:04:04 <performance> > take 10 $ foldr (:) 1 [ 1,..]
10:04:04 <lambdabot>  Parse error at "..]" (column 27)
10:04:11 <MyCatVerbs> BMeph: oh hell.
10:04:12 <jeffersonheard> evaluatating the return from foldl will cause all the thunks, which are nested, to be evaluated at once
10:04:15 <MyCatVerbs> Yes, shoot them.
10:04:19 <chrisdone> ddarius: yeah, gmail chat puts smileys in, screws up my code samples all the time ;_;
10:04:36 <jeffwheeler> ddarius: heh
10:04:36 <ddarius> chrisdone: Yeah, I hate that too though not usually for code.
10:04:43 <BMeph> jeffwheeler: Genau... er, yes exactly. Modulo definitions of "popular"... ;)
10:04:48 <performance> thanks guys, gotta go .. bye
10:04:53 <jeffersonheard> bye
10:04:55 * lispy thinks there are better things to worry about than smilies
10:05:11 <MyCatVerbs> jeffersonheard: Pidgin is no more an IRC client than a vintage Ferguson tractor is a racing vehicle.
10:05:17 <ddarius> lispy: Sure, but one can worry about those too.  And anyway, one needs to start small.
10:05:28 <MyCatVerbs> jeffersonheard: which is to say, sure, but it's sure as Hell not competitive.
10:05:37 <zachk> MyCatVerbs: but it works
10:05:59 <BMeph> jeffwheeler: If by "popular" you mean "the most used by population," versus "the one most admired or liked for its feature set, ease-of-use and interface
10:06:02 <BMeph> "
10:06:12 <jeffersonheard> MyCatVerbs, I said nothing about Pidgin & IRC.  I'm using Konversation
10:06:18 <jeffwheeler> BMeph: that's generally the definition of popular I use, yes
10:06:29 <MyCatVerbs> zachk: so did Windows ME, and look how that turned out.
10:06:41 <ddarius> MyCatVerbs: Windows ME worked?
10:06:45 <sal23> chrisdone: I don't think I installed happy when compiling lambdabot and goa...what is it for?
10:06:53 <jeffersonheard> And my wife snogged the dude who created IRC years ago, so I have to use a real IRC client to have cred.
10:06:55 <MyCatVerbs> ddarius: to withing a fir-well, halfth approximation.
10:07:02 <chrisdone> sal23: lambdabot uses it for parsing haskell, I believe
10:07:12 * lispy prefers it when #haskell is on topic
10:07:22 <BMeph> jeffwheeler: Okay, because I personally prefer the second definition I used, even though I understand the first usage is...more "popular" by the first definition, heh-heh. :)
10:07:24 <jeffwheeler> lispy: this is entirely relevant to the lambdabot :P
10:08:20 <zachk> MyCatVerbs: tab completion of names, can click on links, not mirc, also lets me be on aim, now windows ME was garbage but win98lite wasnt too bad
10:08:25 <jeffwheeler> BMeph: a dictionary can solve this :) http://en.wiktionary.org/wiki/popular
10:08:42 <BMeph> MyCatVerbs: People race Fergie tractor?!? That's, like, so kuhl!! ;p
10:09:10 <lispy> So what killer apps are people writing in Haskell today?
10:09:13 * jrh is now known as jrh to avoid confusion with Wheeler
10:09:23 <jeffwheeler> jrh: appreciated :)
10:09:25 * BMeph prefers it when #haskell is lispy
10:10:00 <chrisdone> @activity
10:10:00 <lambdabot> 1*total 1*#macosx
10:10:01 * BMeph thinks he meant "LisP"-esque, not "lispy"
10:10:08 <chrisdone> @users
10:10:09 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:10:32 <Shiruka> killer apps.. hmm.. *wonders about writing a killer fibs*
10:10:33 <lispy> BMeph: hehe, I should be lambdy
10:10:46 <lispy> Shiruka: are you familiar with the research of Dr. Cull?
10:10:56 <jeffwheeler> Haskell needs a cool word like "lisp" or "Pythonic"
10:10:57 <jrh> Shiruka, that's as easy as 1,1,2,3
10:11:02 <Shiruka> lispy: no
10:11:02 <jeffwheeler> s/lisp/lispy/
10:11:08 <ptolomy2> hasklish?
10:11:12 <TychoSIX> Haskish?
10:11:12 <lispy> Shiruka: he has done a lot of research over the years on efficiently computing that sequence due to the applications it has in the sciences and engineering
10:11:14 <jeffwheeler> Eh, that works, I guess.
10:11:15 <ptolomy2> haskellesque
10:11:32 <jrh> Hacksy
10:11:32 <Shiruka> lispy: (O.o; it has actual applications?
10:11:53 <ptolomy2> The pronunciation of haskellesque backwards sounds like "excellence" to me.
10:12:01 <lispy> Shiruka: mind you, I've not read his papers, only the abstracts but it seems that he mentions some sort of applications somewhere
10:12:13 <lispy> Shiruka: I've also taken some excellent courses from him :)
10:12:28 * Shiruka is dubious of applications of fibs - at least ones that would require more efficient means of computing it
10:13:13 <lispy> I would also imagine that innovations in fibs alogrithms might shed light on other algs
10:16:41 <MyCatVerbs> zachk: except for having NO GODDAMN MEMORY PROTECTION.
10:16:47 <MyCatVerbs> zachk: I mean, like, MMUs are for WHAT now?
10:16:59 <MyCatVerbs> zachk: shits and giggles, if MS were to be believed. :P
10:17:05 <Shiruka> but we already have a word like "pythonic" for "haskell": pointless!
10:17:18 * Shiruka runs away
10:17:29 <MyCatVerbs> "Idiomatic". :P
10:17:33 <lispy> "fun"
10:17:51 <MyCatVerbs> "Fun"'s a good one. As are "clean" and "elegant".
10:18:07 <lispy> I mean, seriously.  how many of you program in Haskell because it's good and how many learned it and used it because it was enjoyable?
10:18:25 <lispy> I'm guessing more people use and stay with Haskell for hobby stuff because it's enjoyable
10:19:13 <sebaseba> i use it for both reasons
10:19:16 <masak> I'm a hedonist. I fail to see the difference between "good" and "enjoyable" :)
10:19:26 <ddarius> MyCatVerbs: ME didn't have memory protection either and it had no excuse (though neither did 98)
10:19:30 <sal23> EvilTerran: http://www.haskell.org/haskellwiki/Fold - according to this, foldl is lazy because of recursive evaluation???
10:19:32 <lambdabot> Title: Fold - HaskellWiki
10:19:55 <lispy> sal23: well, that foldl is lazy sounds right
10:20:36 <sal23> oops, I meant strict...well, why would it sound right that it is lazy?
10:21:04 <lispy> sal23: because foldl' is a strict version :)  But, it's strict in the accumulation
10:21:27 <lispy> they probably mean strict in that it consumes the entire input list before giving a result
10:22:05 <sal23> lispy: if I supply all the parameters for foldl, it should force evaluation in a recursive definition, right?
10:22:25 <lispy> sal23: I don't think I understand the question
10:22:58 <lispy> sal23: I think they mean foldl is strict in the same way that reverse is strict
10:23:20 <sal23> lispy: lazy would make sense if it were accumulating parameters, e.g., appending to a list... but, if it is a recursive function that is calling itself, shouldn't the function execution be strict?
10:23:30 <lispy> sal23: reverse can't stop looking at the input list until the end, so it's strict in that parameter right?
10:23:38 <sal23> right....
10:23:52 <lispy> ?src foldl
10:23:52 <lambdabot> foldl f z []     = z
10:23:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:24:01 <lispy> and we see that foldl has the same property
10:24:21 <lispy> But, foldl isn't strict in the value that it constructs
10:24:30 <lispy> (the z)
10:24:38 <lispy> ?src foldl'
10:24:38 <lambdabot> foldl' f a []     = a
10:24:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:25:18 <lispy> notice that foldl' does more work, in particular the seq.  When you talk about strictness of functions it helps to be clear about which parameters you mean
10:25:39 <sal23> yep, that is what I was asking...
10:26:05 <BMeph> MyCatVerbs, lispy: Haskell is pure fun. Literally. :)
10:26:15 <lispy> BMeph: exactly!
10:26:52 <lispy> sal23: and strictness comes down to pattern matching and seq
10:27:06 <lispy> sal23: and pattern matching desugars to case expressions
10:28:04 <sal23> lispy: so, in foldl, it will look at the whole list but won't construct z unless it is explicitly consumed somewhere
10:28:18 <lispy> sal23: right
10:29:02 <lispy> sal23: and did you know that looking at a list just produces the cons cells but doesn't require that we compute the elements?
10:29:15 <sal23> lispy: right, I know that
10:29:15 <lilachaze> how do guards get translated by layout?
10:29:40 <lilachaze> > let fib n | n < 2 = n; | otherwise = fib (n-1) + fib (n-2)
10:29:41 <lambdabot>  Parse error at "|" (column 24)
10:29:42 <mauke> guards don't use layout
10:30:01 <mauke> > let fib n | n < 2 = n | otherwise = fib (n-1) + fib (n-2) in fib 12
10:30:04 <sal23> lispy: another question....the calls in foldl are building z, but since it is lazy, doesn't it save the call data somewhere so that to build z when needed?
10:30:09 <lambdabot>  144
10:30:23 <lispy> sal23: right, and that "somewhere" is called a thunk
10:30:32 <lispy> I think anyway
10:30:36 <lilachaze> mauke: thanks! :)
10:30:39 <sal23> lispy: gotcha....I have read about it
10:30:52 <lispy> sal23: this can lead to heap exhaustion, iirc
10:31:13 <lispy> sal23: which is why most of the time you want foldl'
10:31:33 <lispy> sal23: usually the value you're after is smaller than the thunk when the input list was long
10:31:42 <sal23> lispy: yep, makes sense
10:32:07 <sal23> lispy: what is iirc?
10:32:14 <lispy> if i recall correctly
10:37:14 <sal23> is there a way to lookup prelude source code online if not using lambdabot? hoogle shows definition but not source code AFAIK
10:37:48 <r3m0t> definition but not source code?
10:38:21 <lispy> sal23: the haskell report has them all
10:38:38 <sal23> cool, thanks
10:38:44 <lispy> sal23: and also, the ghc source can be read in a web browser
10:39:13 <Deewiant> ( http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html )
10:39:14 <lambdabot> Title: Prelude, http://tinyurl.com/y4wexy
10:39:23 <MyCatVerbs> sal23: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html <-- inside any given section, hit the "Souce Code" link at the top.
10:39:24 <lambdabot> Title: Haskell Hierarchical Libraries
10:39:45 <MyCatVerbs> sal23: what you'll get is from HsColour with a sane scheme.
10:40:43 <sal23> MyCatVerbs: thanks
10:41:05 <BMeph> Haskell: Now "colour-coded" for your reading pleasure!  :)
10:43:11 <jsnx> Cale: I am trying to work out the co-unit diagram for the adjunction where the diagonal functor is the right adjoing and the coproduct functor is the left adjoint [ http://hpaste.org/9303 ]
10:43:36 <jsnx> i can't figure out how f* and g* (in the diagram) can be unique
10:45:07 <BMeph> ddarius: CT guru UP! ;)
10:45:27 <jsnx> BMeph: oh, i chatted with ddarius yesterday
10:46:02 <jsnx> it was not really clear where to start with his suggestions, though
10:46:30 <BMeph> jsnx: Ah, so you need better diagrams... got it! :)
10:46:36 <jsnx> so i thought i'd see what Cale says and then see if I can't piece things together from the two of them
10:47:21 <jsnx> "learning category theory by #haskell sampling"
10:49:44 <lilachaze> Will this work reliably (minus the printing): http://hpaste.org/9316 ?
10:50:34 <lilachaze> Also, is there a better way to get the same effect? The idea is that I have a function which might or might not use its argument, and if it doesn't i want to cache its result
10:50:52 <RayNbow> > let fib n = ( phi^n - (1-phi)^n ) / sqrt 5    in    fib 400
10:50:59 <lambdabot>  1760236806450139664682269453924112507703843833044921918867259928965753450442...
10:51:39 <lilachaze> I'm using a nasty unsafePerformIO trick to determine whether the argument gets forced the first time the function is run
10:53:01 <roconnor> > let fib n = ( phi^n - (1-phi)^n ) / sqrt 5    in    fib 400 :: CReal
10:53:08 <jrh> exp pi - pi
10:53:09 <lambdabot>  1760236806450139664682269453924112507703843833044921918867259928965753450442...
10:53:29 <lilachaze> jrh: floating point inaccuracy detected in universe :)
10:53:36 <jrh> let n = exp pi - pi in n
10:53:39 <jrh> :D
10:53:49 <jrh> haven't tried lambdabot out before
10:53:52 <lilachaze> > exp pi - pi
10:53:53 <lambdabot>  19.999099979189474
10:53:59 <jamii> lilachaze: I think it depends what you mean by using an argument
10:54:00 <RayNbow> roconnor: I defined phi to be a CReal
10:54:05 <RayNbow> :t phi
10:54:06 <lambdabot> CReal
10:54:10 <lilachaze> jamii: by 'use' i mean force.
10:54:17 <roconnor> RayNbow: oh, that explains it.
10:54:43 <lament> whoa, i didn't know about e^pi - pi
10:54:45 <lilachaze> obviously whether the result depends on the argument isn't computible, but you can detect whether the arg is foced
10:54:46 <RayNbow> I'm interested how CReals are implemented though... :)
10:54:52 <roconnor> > let fib n = ( phi^n - (1-phi)^n ) / sqrt 5    in   trunc $ fib 400
10:54:53 <lambdabot>   Not in scope: `trunc'
10:55:02 <lament> is there an explanation for it? :)
10:55:03 <jamii> Then yes, it looks like it should work
10:55:04 <roconnor> @hoogle trunc
10:55:08 <Deewiant> roconnor: truncate
10:55:11 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
10:55:15 <roconnor> > let fib n = ( phi^n - (1-phi)^n ) / sqrt 5    in   truncate $ fib 400
10:55:23 <lambdabot>  1760236806450139664682269453924112507703843833044921918867259928965753450442...
10:55:30 <RayNbow> <RayNbow> > let fib n = ( phi^n - (1-phi)^n ) / sqrt 5 in  fib 400
10:55:31 <RayNbow> <lambdabot>  176023680645013966468226945392411250770384383304492191886725992896575345044216019675.0
10:55:43 <lilachaze> jamii: second question then, is there a nicer way of doing it? :)
10:55:46 <RayNbow> ^ it works when sent as a private message
10:56:01 <lilachaze> 5 uses of unsafePerformIO seems excessive to me ;-)
10:56:35 <roconnor> RayNbow: cool
10:56:38 <RayNbow> hmm
10:57:07 <RayNbow> the CReal method is slower than integer math :)
10:58:22 <maltem> lilachaze: you could maybe replace the IORef stuff by something along the lines of, let x' = seq raiseError x -- and then catch that with C.E.catch
10:58:23 <laz0r> is there by any chance a collada parser written with parsec available somewhere?
10:58:51 <RayNbow> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs ; fs = take 401 fibs    in    seq (rnf fs) (last fs)
10:58:53 <lambdabot>  1760236806450139664682269453924112507703843833044921918867259928965753450442...
10:59:13 <maltem> lilachaze: But would that be cleaner?
10:59:37 <jamii> lilachaze: What exactly do you want this for?
11:00:39 <lilachaze> maltem: that's a neat idea. but it would require me to run the function twice the first time
11:01:44 <lilachaze> jamii: it's mostly a thought experiment at the moment. but it seems like a good optimization, in the cases where it applies
11:02:11 <lilachaze> a compiler could implement it really efficiently...
11:02:22 <maltem> hm right, since you're also interested in the result...
11:02:43 <roconnor> @bab nl en Betreft
11:02:44 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
11:02:48 <roconnor> oh right
11:04:37 <maltem> roconnor: fwiw, bab de en Betreff -> subject, topic
11:05:08 <roconnor> maltem: source?
11:05:12 <jamii> Im not sure. I dont think I often see expensive functions ignoring arguments. Maybe in the occasional curried argument to something...
11:05:21 <BMeph> Aye - Betreft -> Subject
11:05:24 <roconnor> hmm
11:05:30 <roconnor> okay
11:05:31 <maltem> roconnor: my tongue
11:05:32 <roconnor> subject
11:05:38 <BMeph> Source: http://translate.google.com/translate_t?sl=nl&tl=en
11:05:39 <lambdabot> Title: Google Translate
11:06:02 <lispy> google translate is funny, use the auto detect and try to translate "Hello"
11:06:29 <lispy> It gives you an error about not being able to autodetect Ukranian (which isn't even a supported language to begin with)
11:06:32 <EvilTerran> Ukrainian?!
11:06:38 <roconnor> there must be some way for me to transfer money between my accouts at the same bank faster than 2 days.
11:07:06 <Gwern-away> roconnor: but then how will the bank profit on the float?
11:07:11 <EvilTerran> roconnor, well, one of the banks here lets you do it instantly between certain accounts online
11:07:13 <lispy> EvilTerran: their list of alternatives must give Ukrainian instead of "Uknown" :)
11:07:15 <Deewiant> "We are not yet able to translate from English into English."
11:07:33 <lispy> Deewiant: ah, maybe they fixed it
11:07:45 <roconnor> Gwern-away: it's the same bank! :)
11:07:48 <Deewiant> lispy: no, that was for "hello world" actually, I just thought that was amusing in itself :-)
11:08:11 <Gwern-away> roconnor: so?
11:08:13 <maltem> lispy: Interestingly, if it would be in the list, it would be the last entry. Used a loop variable when the loop had already terminated? :)
11:08:18 <EvilTerran> ?djinn a -> a
11:08:19 <lambdabot> f a = a
11:08:21 <lispy> roconnor: they have to print your request, give it to a teller, have them process it, give the receipe to an account manager so they can update your account :)
11:08:32 <EvilTerran> ?djinn english -> english -- that was easy
11:08:32 <lambdabot> Cannot parse command
11:08:33 <roconnor> Gwern-away: don't they get "the float" either way?
11:08:36 <EvilTerran> ?djinn english -> english
11:08:36 <lambdabot> f a = a
11:08:37 <EvilTerran> doh
11:08:55 <Deewiant> even ?djinn knows how to do it :-)
11:09:17 <Gwern-away> roconnor: unless I'm using the term float wrong, every day the money is stuck in between, they can keep the interest and not pay it to you
11:09:19 <EvilTerran> "the float" - the interest on the money while it's between accounts (effectively)?
11:09:21 <roconnor> lispy: yeah, I'd do that if it didn't require a trans-atlantic flight.  Flying there and back also takes 2 days :)
11:09:21 <tromp> ?djinn [a] -> a
11:09:22 <lambdabot> -- f cannot be realized.
11:09:32 <lispy> "We are not yet able to translate from Ukrainian into English."
11:09:34 <EvilTerran> djinn doesn't do lists
11:09:36 <roconnor> Gwern-away: ah I see.
11:09:46 <Deewiant> ?djinn a -> [a]
11:09:46 <lambdabot> -- f cannot be realized.
11:09:59 <EvilTerran> djinn still doesn't do lists :P
11:10:01 <tromp> ?djinn a -> a -> a
11:10:01 <lambdabot> f _ a = a
11:10:03 <Deewiant> ?djinn a -> Maybe a
11:10:03 <lambdabot> f = Just
11:10:07 <lispy> maltem: that's very plausible
11:10:10 * Gwern-away notes that a classic saudi arabian corruption tactic is for a prince or whoever to take money from the bank, but delay paying it to the foreign bank for weeks or months - thereby keeping the interest
11:10:13 <EvilTerran> ?djinn b -> [a] -> b
11:10:13 <lambdabot> f a _ = a
11:10:36 <Gwern-away> prince bandar is supposed to be notorious for being dilatory in payments
11:11:09 <roconnor> Gwern-away: are you really away?
11:11:14 <roconnor> :)
11:11:27 <Gwern-away> roconnor: I am high as a kite
11:11:32 <lispy> maltem: except ukrainian is not in my list, not even last :)
11:11:35 <roconnor> :D
11:11:37 <Gwern-away> away from the mundane earth and its petty concerns
11:11:58 <roconnor> up there with lucy in the sky.
11:12:01 <Gwern-away> (and it'll be a long long time before I touch down)
11:12:46 <maltem> lispy: hence my "if it were" hypothetic reasoning
11:13:14 <roconnor> Koop : Buy :: Verkoop : Sell :: Ontvangst : ???
11:15:36 <igel> hi all
11:15:42 <igel> is there an image processing library?
11:15:57 <igel> i want to load and save images
11:15:58 <lispy> igel: what type of image processing?
11:16:13 <lispy> igel: iirc, hackage had some bindings to one
11:16:19 <lispy> ?where hackage
11:16:19 <lambdabot> http://hackage.haskell.org/
11:16:34 <igel> reading and writing would be sufficiant, some simple filters and labelling would be helpful
11:16:49 <jrh> reading into what kind of structure, though, igel?
11:17:01 <jrh> do you want access to the raw bytes, or?
11:17:10 <igel> something that provides access to pixels and their colors
11:17:18 <roconnor> oh crap.  I need to tell my bank to initiate the transfer.
11:17:25 <roconnor> no wonder it wasn't being sent.
11:17:49 <jrh> igel, I use Gtk.Pixbuf inside the gtk2hs library for most of that
11:17:57 <jrh> ?where gtk2hs
11:17:57 <lambdabot> http://haskell.org/gtk2hs/
11:17:58 <roconnor> hey, it's there already!
11:18:07 <roconnor> that was fast.
11:18:20 <igel> jrh: that's a good idea :)
11:18:38 <roconnor> banking in a foreign language is not the easiest thing in the world
11:19:24 <maltem> roconnor: Texts found by Google suggest ontvangst = Empfang, which means either reception/receipt or acceptance
11:19:53 <roconnor> maltem: could it mean dividend?
11:20:15 <psnively> Testing...
11:20:37 <r3m0t> EvilTerran: didn't you break lambdabot a while ago?
11:20:48 <maltem> roconnor: That would surprise me, actually...
11:20:55 <Deewiant> roconnor: http://en.wiktionary.org/wiki/ontvangst
11:21:00 <EvilTerran> r3m0t, i seem to recall i was somehow involved, yes
11:21:01 <xerox> ?babel nl en ontvangst
11:21:01 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
11:21:11 <r3m0t> EvilTerran: using seq. anyway, http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code might be interested
11:21:12 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
11:21:16 <r3m0t> (see bottom of page)
11:21:26 <EvilTerran> ta
11:21:59 <EvilTerran> i think it was using `par`
11:22:03 <EvilTerran> which was the problem
11:22:11 <EvilTerran> forkbomb
11:23:17 <zachk1> even though lambdabot seems broke, its pieces of it are still running, amazing
11:23:20 <zachk1> > 2+2
11:23:22 <lambdabot>  4
11:23:38 <lispy> lambdabot is broke?
11:25:31 <jrh> lispy, well, obviously if it thinks 2+2 is four
11:25:59 <mauke> > let 2+2 = 5 in 2+2
11:26:00 <lambdabot>  5
11:26:16 <jrh> 2+2
11:26:32 <Heffalump> > let 2+3 = 6 in 3+2
11:26:33 <jrh> > 2+2
11:26:33 <lambdabot>   Non-exhaustive patterns in function +
11:26:34 <lambdabot>  4
11:26:45 <jrh> see?  broke
11:26:48 <jrh> can't convince it
11:26:50 <BMeph> ontvangst -> receipt
11:27:05 <jrh> besides, the proper answer should be something like "Can't sufficiently determine the type of 2"
11:27:24 <mauke> that's what defaulting is for
11:28:07 <jrh> My axioms feel violated
11:28:14 <lispy> Couldn't match expected type `Int` against inferred type `Integer`
11:28:30 <jrh> lol.  thanks, lispy
11:28:32 <mauke> hmm
11:28:57 <lispy> > (2::Int) + (2::Integer)
11:28:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
11:29:00 <igel> jrh: so i load a PixBuf (which is an actual image) and retrieve its PixBufData, which again is an array?
11:29:17 <mauke> too bad /a isn't a valid regex flag or I could write //axioms in perl
11:29:49 <jrh> That's the idea.   And PixBufData implements one of the Array interfaces, I believe MArray
11:30:01 <igel> correct, MArray
11:30:46 <igel> this sounds like a lot of "fun" with low-level indexing though :]
11:31:19 <jrh> Well...  I don't know what you're trying to do, so I can't reccommend anything more specific.  You can do anything in PIxbuf in Haskell you can do in Pixbuf in C
11:31:39 <david48> Hello everyone.
11:31:53 <jrh> Hi! Dave!  (sorry, couldn't resist)
11:32:21 <igel> well nice access functions that directly retrieve the color of a given pixel would be a good start ;)
11:32:21 <david48> anyone knows why I get this error message ? : (remote:665): libglade-WARNING **: Error loading image: Couldn't recognize the image file format for file './logo.svg'
11:32:22 <lispy> david48: is that your age or your IQ? *symbal crash*
11:32:40 <igel> getPixel :: PixBufData -> (Int, Int) -> Color
11:32:49 <igel> and a corresponding setPixel
11:33:24 <lament> david48: the error message seems to imply that libglade cannot recognize the svg format.
11:33:51 <david48> lispy:if I sounded dumb that might well be my IQ, but I wouldn't know :)
11:34:16 <maltem> david48: does logo.svg have an xml header, doctype etc.?
11:34:28 <david48> lament: but what libglade might be missing to recognize svg ? I sure I compiled gtk2hs with svg support.
11:35:31 <jrh> igel, Yep...  if you want, and you have a good enough video card, you could simply load your image into a texture and use a shader to do your image processing...  It'd be lightning fast, but more work
11:35:31 <david48> maltem : when I try it on my computer at work, logo.svg reads ( and displays) fine. At home, it doesn't. So I guess there must be someone in my libglade installation ( or gtk2hs, but I think I've compiled them the same way )
11:36:19 <igel> jrh: that sounds interesting, what libs are you referring to?
11:36:28 <maltem> david48: hm ok, then I have no idea
11:37:11 <lament> david48: then make sure libglade is fine
11:37:13 <mmorrow> i just asked this is ghc, but possibly i should have asked here:
11:37:15 <mmorrow> i'm trying to install a binary ghc-6.8.3 dist on centos so that i can use that to build a src dist (since the centos yum repo only has ghc6.4), and i get a floating point exception when trying to install
11:37:15 <lament> and supports svg
11:37:20 <Cale> jsnx: you had a question about category theory... did you get that sorted out?
11:37:23 <mmorrow> http://hpaste.org/9317
11:37:31 <jrh> Well, Milfoh will load anything libtiff will load into the currently bound OpenGL texture.
11:37:31 <mmorrow> would anyone happen to know a solution?
11:37:39 <jrh> ?where milfoh
11:37:39 <lambdabot> I know nothing about milfoh.
11:37:54 <Botje> mmorrow: i think i saw that documented on the GHC wiki
11:38:00 <jrh> http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Flinuz.sns.it%2F~monge%2Fwiki%2Findex.php%2FMilfoh&ei=AViTSMbzEqXEeuve_aUJ&usg=AFQjCNGdKwKaMuIKC43NAPvNlOrjG6mUqw&sig2=aUY1qOcEAqaBPz2Qn5MFRQ
11:38:01 <mmorrow> Botje: cool, thx
11:38:02 <lambdabot> Title: Milfoh - MaurizioHomepage, http://tinyurl.com/6rartn
11:38:14 <jrh> darned google links
11:39:26 <david48> lament: I know, that means I'll have to find out what (k)ubuntu package I forgot to install... Poor me :)
11:39:43 <lament> hehe, suffer!
11:39:43 <jrh> anyway, that'll load into the texture.  then the general procedure is to write a shader, bind it to the current context, and render a quad that is the imagesize
11:39:48 <jrh> it's a bit involved.
11:40:18 <jrh> worth it if you're seriously worried about performance and you've got a lot of time on your hands.  (and you know GLSL)
11:40:50 <jrh> otherwise, I'd stick with using the MArray interface.
11:42:33 <jrh> I'd hpaste some code, but I'd have to find it first, and I'm about out of time for the day here
11:45:07 <RayNbow> <roconnor> Koop : Buy :: Verkoop : Sell :: Ontvangst : ??? <-- trying to learn Dutch? :)
11:46:44 <roconnor> RayNbow: trying to use a dutch bank.
11:48:51 <jesperj> lispy: If you think you're being funny making childish bully remarks to people you're mistaken, you're just pissing people off for being an asshole and embaressing yourself.
11:48:57 <igel> jrh: oh then i'm afraid that's beyond my knowledge ;)
11:49:13 <david48> Is there a gtk2hs channel ?
11:49:41 <roconnor> RayNbow: I spent two days waiting for my money to bet transfered between accounts before I discovered I need to initate the transaction that I constructed.
11:49:42 <jrh> igel, my rule is to write the simple stuff, and then write the complicated stuff only when it becomes clear that it's necessary
11:50:03 <igel> exactly^^
11:50:28 <igel> but it's not a serious project, it's just for fun, so this rule may be bent :)
11:51:18 <RayNbow> roconnor: heh... which bank are you using?
11:51:29 <roconnor> RayNbow: SNS
11:52:35 <RayNbow> roconnor: so with SNS, transfers are not immediately scheduled?
11:53:21 <EvilTerran> if it's like my bank's internet system, you "create a transfer" by putting in stuff like sort codes, account numbers, and reference numbers
11:53:22 <dcoutts_> david48: no, but there are some gtk2hs hackers and users around here
11:53:28 <roconnor> RayNbow: I think the workflow is to construct one or more transfers.
11:53:29 <lispy> david48: oh, sorry just making a silly joke
11:53:44 <roconnor> RayNbow: and then send them all at once, which requires another use of the digipas.
11:53:47 <RayNbow> roconnor: ah right
11:53:48 <EvilTerran> then it's a seperate action to actually tell them to transfer money with that "transfer"
11:53:58 <EvilTerran> which is a very confusing use of nomenclature
11:54:00 <roconnor> RayNbow: which is reasonable
11:54:02 <RayNbow> yes, that's also the case with Rabobank
11:54:18 <RayNbow> I can create several transfers and then sign them all at once
11:54:21 <roconnor> RayNbow: but a little had to figure out for an North American.
11:55:08 <roconnor> The digipas is pretty cool.  I'm surprised they are not in use in North America.
11:55:12 <lispy> jesperj: noted, although david48 appeared to take it for what it was worth, a stupid joke
11:56:10 <RayNbow> roconnor: well, I have no idea how the internet banking world looks like in the US
11:56:28 <roconnor> RayNbow: you just log in with a password or two.
11:56:36 <jesperj> lispy: I'm sensetive and hate it when people pick on other people ;) Good that there was no intentions of harm. Have a great weekend.
11:56:36 <RayNbow> all I know is that for internet shopping, the credit card is favored in the US
11:57:01 <RayNbow> while here in the Netherlands, the credit card never really took off and bank transfers were prefered
11:57:07 <mauke> jesperj: god help you should you ever discover 4chan
11:57:28 <jesperj> hehe
11:57:31 <jrh> lol @ mauke
11:57:34 <RayNbow> roconnor: is that password chosen by the user?
11:57:37 <maltem> A funny thing about some German banks is that your password for online banking is restricted to, like, five characters
11:57:37 <RayNbow> or generated?
11:57:38 <jesperj> :P
11:57:47 <roconnor> RayNbow: chosen by the user.
11:58:34 <camio> Anyone know why mapAccumL (from Data.List) isn't in Data.Foldable? Is there a better way to do that?
11:58:35 <RayNbow> roconnor: do you need to sign transactions or are they just accepted after logging in?
11:58:52 <roconnor> they are just accepted once you are logged in.
11:58:57 <RayNbow> ouch...
11:58:58 <lispy> jesperj: I will thanks.  You too!
11:59:28 <Jedai> camio: You can just rewrite it if you miss it (don't forget to use strict tuples though)
11:59:37 <RayNbow> maltem: well, online banking here in the Netherlands only require 4 digits (PIN) associated with the card
11:59:43 <lispy> What is Data.Foldable all about?
11:59:58 <roconnor> I much perfer the European system, even if it takes me a while to figure it out.
12:00:00 <quicksilver> lispy: it's all about toList, if you like to be reductionist.
12:00:18 <roconnor> OTOH, I understand the liability in Europ is reversed from North America.
12:00:18 <camio> lispy: Generalizing normal list fold functions to other things that support it, like Data.Map.
12:00:22 <david48> lispy: yes, took it for a silly joke :)
12:00:24 <quicksilver> (because lists are the free monoid)
12:00:39 <lispy> camio: cool
12:00:40 <roconnor> Our online banking system here is so insecure, that the banks are held responsible for it.
12:00:51 <lispy> quicksilver: free monoid?  free as in trivial or?
12:01:08 <EvilTerran> lispy, as in, their definition leads directly from that of a monoid
12:01:37 <lispy> EvilTerran: ah, I might have called it natural, but I see
12:01:40 <david48> dcoutts_: I was hoping for a gtk2hs channel in case someone there had a clue about my libglade problem
12:01:40 <camio> EvilTerran: How's that?
12:01:58 <EvilTerran> well, you need an identity element
12:02:00 <lispy> I think dcoutts_ is our #gtk2hs chan
12:02:01 <EvilTerran> let's call it []
12:02:12 <dcoutts_> david48: ask me later or post to the gtk2hs users mailing list
12:02:20 <EvilTerran> and you need some associative operator
12:02:41 <lispy> > [1] :: [] Int -- This notation surprised me the first time I saw it
12:02:42 <lambdabot>  [1]
12:02:49 <david48> dcoutts_: I was considering already posting to the list. Will do :)
12:03:21 <EvilTerran> because the operator's associative, you can think about any bracketing of it in terms of just the list of elements being operated on, in order
12:03:26 <EvilTerran> (but ignoring parentheses)
12:03:26 <camio> EvilTerran: Associative operator being (++)?
12:03:47 <EvilTerran> and the operator would, yes, act like (++) on those lists of operands
12:04:09 <lispy> ?check \xs ys zs -> (xs ++ ys) ++ zs == xs ++ (ys ++ zs)
12:04:11 <lambdabot>  OK, passed 500 tests.
12:04:14 <EvilTerran> part of the point, i think, is that you don't need to know anything about the operator to build that list
12:04:43 <lispy> ?check \xs ys zs -> (xs ++ ys) ++ zs == xs ++ (ys ++ (zs :: [Int]))
12:04:44 <lambdabot>  OK, passed 500 tests.
12:04:46 <EvilTerran> because you can pick any monoid ((*),unit) later and work out the result
12:05:24 <camio> EvilTerran: I guess I don't see how that differs from something like ((+),0)
12:05:58 <camio> Unless those are also considered natural.
12:05:59 <lispy> if the monoid was ((+), 0), would fold be (*)?
12:06:17 <EvilTerran> sorry, i meant you could have something like
12:06:51 <EvilTerran> runMonoid (*) unit [] = unit; runMonoid (*) unit (x:xs) = x * runMonoid xs
12:07:06 <EvilTerran> (which happens to be foldr)
12:07:22 <EvilTerran> i was just using "*" and "unit" as placeholders
12:07:35 <EvilTerran> you could use ((+),zero) equally well
12:07:43 <camio> Ah, okay
12:08:29 <mmorrow> (mappend mempty) === id
12:08:49 <mmorrow> or at least it's supposed to
12:09:14 <mmorrow> but nothing would stop someone from writing an instane of Monoid where that's not the case
12:09:22 <mmorrow> (instance)
12:11:02 <mmorrow> (just like nothing would stop someone from writing a sqrt function that return the cude root)
12:11:14 <mmorrow> geez i can't type
12:11:25 <mmorrow> ... that returns the cube root)
12:12:01 <roconnor> I would stop them
12:12:18 <Jedai> @where fold
12:12:18 <lambdabot> I know nothing about fold.
12:12:25 <Jedai> ?where fold
12:12:25 <lambdabot> I know nothing about fold.
12:12:28 <Jedai> ?where folds
12:12:28 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
12:12:35 <lispy> yeah, roconnor and the PETN (People for the ethical treatment of numbers) would stop them
12:12:38 <Deewiant> > let sqrt = (/2) in sqrt 4
12:12:39 <lambdabot>  2.0
12:13:09 <mmorrow> roconnor: heh
12:13:09 <roconnor> Deewiant: STOP!
12:13:13 <mmorrow> haha
12:13:17 <Deewiant> > let sqrt = (/3) in sqrt 9
12:13:18 <lambdabot>  3.0
12:13:26 <mmorrow> looks good to me!
12:13:55 <Deewiant> @check \x -> let sqrt = (/3) in sqrt x == sqrt x
12:13:55 <lambdabot>  OK, passed 500 tests.
12:13:59 <Deewiant> see, it works and everything
12:14:08 * roconnor emails Deewiant a fork bomb
12:14:40 * Deewiant deletes a suspicious-looking email
12:14:56 <camio> Anyone know of a trd function for tuples?
12:15:09 <Deewiant> coming in Data.Tuple in 6.10 IIRC
12:15:11 <mmorrow> let trd (_,_,x) = x
12:15:24 <camio> cool.
12:15:26 <mmorrow> Deewiant: oh? cool,
12:15:30 <lispy> trd, haha
12:15:38 <Deewiant> I always called it trd
12:15:39 <camio> I have an issue with using points.
12:15:52 <mmorrow> @pl \(_,_,x) -> x
12:15:52 <lambdabot> (line 1, column 6):
12:15:52 <lambdabot> unexpected ","
12:15:52 <lambdabot> expecting operator or ")"
12:15:52 <lambdabot> ambiguous use of a non associative operator
12:15:56 <RayNbow> @djinn (a,b,c) -> c
12:15:56 <lambdabot> f (_, _, a) = a
12:16:27 <RayNbow> mmorrow: @pl seems to have trouble with triples
12:16:31 <mmorrow> i guess you can't make it pointfree w/out something like (un)curry3
12:16:45 <mmorrow> @src curry
12:16:45 <lambdabot> curry f x y = f (x, y)
12:16:49 <mmorrow> @src uncurry
12:16:50 <lambdabot> uncurry f p = f (fst p) (snd p)
12:16:54 <EvilTerran> it'd be uncurry3
12:16:58 <mmorrow> @src fst
12:16:59 <lambdabot> fst (x,_) =  x
12:17:04 <camio> I think I'm going to use a (a,(b,c)) instead.
12:17:14 <RayNbow> @pl \(,) a b -> b
12:17:15 <lambdabot> (line 1, column 3):
12:17:15 <lambdabot> unexpected ","
12:17:15 <lambdabot> expecting pattern
12:17:16 <EvilTerran> see, if tuples were defined in terms of (,) and (), we could do way more fun stuff
12:17:19 <mmorrow> camio: i usually always go with that way
12:17:50 <Jedai> EvilTerran: Yeah, but they're issues with the lazyness
12:18:09 <Jedai> oops : there are issues
12:18:10 <EvilTerran> meh
12:18:13 <EvilTerran> fine
12:18:20 <Deewiant> hmm, I could have sworn I saw a GHC ticket as a result of which fst3 etc. were coming but I can't find it so maybe not :-/
12:18:27 <EvilTerran> data a :& as = a :& !as
12:18:28 <EvilTerran> :P
12:18:35 <EvilTerran> we can use that
12:18:53 <sheyll_> bye!
12:18:57 <Deewiant> maybe it was just the Data.Either stuff
12:19:01 <camio> The laziness issue is that (a,b,undefined) = undefined where (a,(b,undefined)) != undefined.
12:19:20 <Deewiant> no, (a,b,undefined) is not undefined
12:19:26 <Deewiant> fst3 (a,b,undefined) == a
12:19:29 <bd_> > (1,1,undefined) `seq` ()
12:19:30 <lambdabot>  ()
12:19:32 <camio> Ah, true.
12:19:37 <camio> What was it. Hrm.
12:20:15 <Deewiant> (a,undefined) versus (a,undefined,undefined) versus (a,(undefined,undefined))
12:20:18 <lispy> using (a, (b, c)) and so on for tuples over size two is really just lisp lists
12:20:21 <EvilTerran> the issue is that you'd get something like (a :& undefined) which doesn't correspond to a single-constructor tuple
12:20:41 <Jedai> lispy: No, it's lisp pairs
12:20:55 <EvilTerran> lispy, except with the length and element types fixed at compile-time
12:21:24 <EvilTerran> Deewiant, that problem could be fixed as i suggested above with the ! in the :& definition
12:22:25 <lispy> EvilTerran: that's true
12:22:45 <lispy> EvilTerran: so maybe we should associate the type with the value instead of the name so that it's no longer fixed
12:23:01 <EvilTerran> what?
12:23:21 <EvilTerran> the whole point of my suggestion was that they would be isomorphic to n-tuples
12:23:24 <lispy> EvilTerran: Well, if the type was part of the value then we'd just do the type checking at run-time
12:23:31 <mmorrow> > let seqTup (a,b) = a`seq`b`seq`(a,b) in fmap seqTup (fmap (\x->(x,x)) [0..])
12:23:34 <lambdabot>  [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11)...
12:23:36 <EvilTerran> but with it possible to do clever trickery with instances and whatnot
12:23:42 <lispy> EvilTerran: my point was to make Haskell more like lisp, but I was just teasing
12:23:45 <EvilTerran> to have functions that worked over arbitrary tuples
12:24:40 <Jedai> EvilTerran: Though you have some problems of "irregular" pairs like in Lisp if you use your type
12:25:37 <lispy> (1, (2, ())) vs (1, 2), the later would be a dotted pair in lisp
12:26:23 <Jedai> (0 &: (0 &: ()) would be the proper pair, while (0 &: 1) would be improper (and have strictness issues)
12:26:44 <lelf`> Deewiant: http://www.haskell.org/pipermail/libraries/2008-March/009460.html, so they will be
12:26:44 <lambdabot> Title: Proposal: add some missing tuple functions
12:28:05 <lispy> Jedai: actually, :&, the colon has to be the first character
12:29:00 <Jedai> lelf`: What annoys me the most is that for a brief time we had some strict pairs in the library and they just disappeared (strict pairs are very useful, much more than fst3 and so on)
12:29:39 <lispy> Why are strict pairs useful?
12:31:54 <Jedai> lispy: In foldl' when you want to return a pair of result for instance
12:32:37 <lispy> Jedai: I see, and a lazy (,) only forces the tuple, but not the elements of the tuple, to be constructed?
12:32:39 <petekaz> Anyone familiar with SSL?  I'm writing a trivial IMAP library to let me check my gmail account.  I've implemented the basics, but I don't know how to go about making it work over an SSL connection.  Does Haskell have any SSL wrappers to make this easy given a working implementation over regular sockets?
12:33:09 <lispy> petekaz: I've used stunnel to add ssl to non-ssl aware apps before
12:33:13 <Jedai> lispy: Yes, which lead to an accumulation of thunks
12:33:23 <mmorrow> http://hpaste.org/9318
12:33:42 <Jedai> lispy: Besides strict pair has much better performance in many scenario
12:33:58 <lispy> petekaz: You have stunnel manage the ssl layer and then communicate using sockets (usually on a commandline) through the tunnel it made
12:34:16 <mmorrow> Jadai, lispy: relevant to this issue: http://hpaste.org/9318
12:34:26 <mmorrow> s/Jadai/Jedai/
12:34:44 <petekaz> lispy: Thanks ... I'm "apt install stunnel" right now.
12:35:10 <Jedai> mmorrow: What are you trying to do exactly ? forcing the evaluation to normal form ?
12:35:26 <petekaz> lispy: it would be nice though if haskell had a nice way to SSL wrap network handles.
12:35:30 <mmorrow> Jedai: it only evals one level deep
12:35:34 <Jedai> mmorrow: or rather to two levels ?
12:35:49 <mmorrow> yeah, i meant "one level more than usual"
12:36:11 <Jedai> mmorrow: What's the role of Seq (a -> b) instance ?
12:36:24 <mmorrow> i dunno about that one, i was groping for instances
12:36:24 <lispy> petekaz: it very well might.  I would use stunnel to see that the program works, then start looking for ssl libs in Haskell and if you fail to find one, wrapping one that is in C and putting the lib on hackage :)
12:36:57 <Jedai> mmorrow: Do you know Control.Parallel.Strategies ?
12:37:01 <petekaz> lispy: I'll have to wait for the FFI chapter in RWH to come out!
12:37:13 <Jedai> mmorrow: It's pretty good at this kind of stuff
12:37:15 <petekaz> lispy: I'm a newbie.
12:37:49 <mmorrow> Jedai: yeah, it looks cool. does it have an equiv of the Seq class from that paste though?
12:37:50 <lispy> petekaz: okay, well the canonical place to look first for haskell libs these days is hackage
12:37:55 <lispy> ?where hackage
12:37:55 <lambdabot> http://hackage.haskell.org/
12:38:02 <lispy> petekaz: you might find what you need
12:38:07 <mmorrow> Jedai: i though it was rnf or nothing
12:38:22 <mmorrow> (thought)
12:38:32 <petekaz> thanks.
12:39:32 <camio> http://hpaste.org/9320 <- Could anyone give me some suggestions on simplifying/cleaning my lsnipd function?
12:39:34 <Jedai> mmorrow: Seq doesn't have an instance on everything, NFData has one though (even if they're not all written now...), you have some combinators that gives you the same functionality (and more) than your Seq class
12:39:56 <Jedai> mmorrow: but not in an unified manner
12:41:32 <mmorrow> Jedai: hmm, that's a good point. Related.. have you ever used the derive package? it can derive NFData instance (using an i'm-not-sure-if-it's-optimal-or-how-"good" strategy) for arbitrary (non-gadt) datatypes
12:42:09 <Jedai> mmorrow: Yeah, it looks pretty nice (never used it myself)
12:42:50 <petekaz> http://hpaste.org/9321 <- after reading the monad chapters of RWH, I feel like I am actually understanding things, here is how I use my IMAP library to print the contents of my IMAP inbox.  I think it "looks" nice.
12:42:58 <jrh> Something I've noticed before is that when people talk about memoizing code, they often use scanr and scanl in Data.List.  What the hell do these functions do?  I can't grok the recursive structure of the documentation in my head
12:43:15 <Jedai> mmorrow: Or maybe I used it once... I used DrIft instead (though it doesn't have the nice TH option)
12:43:17 <hgolden> Hi. ghc-core-0.3 compile fails on ghc-6.8.3: http://hpaste.org/9319
12:43:24 <mmorrow> Jedai: but, i'm not saying Seq is a replacement for NFData. it seems to me though that suppose type 'a' is an instance of NFData, then would their be any way the evaluated two-levels deep like 'bang' does?
12:43:37 <jrh> RWH?
12:43:50 <petekaz> 'Real World Haskell'
12:43:52 <Jedai> mmorrow: No :-)
12:43:59 <jrh> thx
12:44:31 <mmorrow> Jedai: you should check it out! it even has a command-line tool that graps all the data decls from a module and derives whatever you tell it for each of them, then dumps a module with all the derivations to stdout
12:44:36 <Jedai> mmorrow: I meant that "two level deep" is a pretty rare needs, so it probably is better reported to some strategy combinators
12:44:44 <dons> hgolden: hmm, that's very weird.
12:44:54 <dons> you using the package from hackage.haskell.org?
12:45:06 <Jedai> mmorrow: Yeah, but that part doesn't interest me because Drift already does that
12:45:08 <mmorrow> Jedai: i dunno. what about     foldl' (\(a,b) c -> (a+b,a*c)) (0,1) [0..]
12:45:13 <hgolden> dons: gentoo haskell overlay
12:45:16 <mmorrow> that'll eventually blow the stack
12:45:34 <Jedai> jrh: type @where folds and look at the URL
12:45:50 <mmorrow> but fmap bang (foldl' (\(a,b) c -> (a+b,a*c)) (0,1) [0..]) should fix it up
12:45:55 <esdee> is yi supposed to work on windows?
12:45:57 <jrh> @where folds
12:45:57 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
12:45:59 <mmorrow> (bang there being the tuple bang)
12:46:04 <jrh> thx
12:46:11 <Jedai> mmorrow: Nope that doesn't work
12:46:16 <mmorrow> darn
12:46:33 <mmorrow> foldl' (\(a,b) c -> bang (a+b,a*c)) (0,1) [0..]
12:46:34 <lispy> mmorrow: you could define a strict version of your lambda though
12:46:36 <Jedai> mmorrow: The bang need to be in the function, anyway the real way to do it is to use a Strict pair
12:46:50 <sms_> @seen sw17ch
12:46:50 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:46:55 <Jedai> mmorrow: Then you'll probably get nice unboxing too
12:47:17 <mmorrow> so we're saying that this'd do it:   foldl' (\(a,b) c -> bang (a+b,a*c)) (0,1) [0..]
12:47:18 <mmorrow> ?
12:47:25 <Jedai> mmorrow: And it'll ten times faster
12:47:33 <Jedai> mmorrow: Yes
12:47:50 <camio> Anyone know if it is possible to do an automatic "deriving Arbitrary"?
12:47:59 <camio> I remember seeing it somewhere.
12:48:09 <lispy> mmorrow: the thunk accumulation happens in the recursion, so that's also where you have to deal with it
12:48:11 <Jedai> camio: No, but you can use "Derive" to do it with TH
12:48:20 <mmorrow> ohhh, of course..heh, since that first example wouldn't even type check
12:48:37 <mmorrow> well, actually it would, but not be doing what i though
12:48:45 <camio> Jedai: Thanks
12:49:03 <hgolden> dons: SRC_URI="http://hackage.haskell.org/packages/archive/${PN}/${PV}/${P}.tar.gz" in gentoo ebuild
12:49:04 <lambdabot> http://hackage.haskell.org/packages/archive/${PN}/${PV}/${P}.tar.gz
12:49:33 <lispy> For all the composability that purity and laziness bring to Haskell, strictness isn't always composable
12:49:36 <thetallguy> Interesting announcement, preview release of http://dlmf.nist.gov/
12:49:39 <lambdabot> Title: DLMF: NIST Digital Library of Mathematical Functions
12:49:56 <thetallguy> should we try and get Haskell bindings/implementations out there?
12:49:58 <bd_> @hoogle (a -> Bool) -> [a] -> [[a]]
12:49:59 <lambdabot> Distribution.Simple.Utils.breaks :: (a -> Bool) -> [a] -> [[a]]
12:50:35 <lispy> dons: I hope you can find time to contribute to the discussion on haskell-cafe about "I would contribute to darcs only if..."
12:50:41 <lelf> dons: they added argument to hscolour's colourPrefs func
12:51:03 <lelf> dons: (I'm about ghc-core)
12:52:20 <BMeph> mmorrow: Sorry, I just walked in on your example, but... why isn't it (\(a,b) c -> (a+c,b*c))? :)
12:52:26 <hgolden> lelf: So you're saying new hscolour version is breaking ghc-core? (Just want to be sure I'm following.)
12:52:46 <lelf> Seems so
12:53:26 <mmorrow> BMeph: why isn't it _?
12:53:56 <mmorrow> "ok without the bang"?
12:53:56 <hgolden> lelf: Perhaps new hscolour should not redefine colourPrefs but create a new version with a different name?
12:54:01 <BMeph> mmorrow>	so we're saying that this'd do it: foldl'  ___ (0,1) [0..]
12:54:08 <mmorrow> ahh
12:54:23 <mmorrow> BMeph: but foldl' will seq the tuple, but not its contents
12:54:37 <dons> lispy, i find it all a bit depressing.
12:54:57 <dons> lispy, but i'll have a think.
12:55:00 <mmorrow> BMeph: so you get the same problem as with    foldl (+) 1     one level down
12:55:01 <dons> lelf, ah.
12:55:03 <dons> lefl, thanks
12:55:09 <lispy> dons: honest feedback is appreciated, and it's okay to end directly to Eric
12:55:24 <dons> lispy, ok.
12:55:26 <lispy> (or me for that matter)
12:55:41 <chrisdone> dons: thanks for the hackage account :)))
12:56:02 <mmorrow> chrisdone: oh nice, now yer in business
12:56:08 <lelf> dons: oh, hscolor function
12:56:10 <dons> lispy, i don't want to see any more bad press about darcs.
12:56:15 <BMeph> mmorrow: Ah, it's an exercise where a (deeply/totally) strict version would (if you used a finite list) get an answer, but a non-strict one won't? :)
12:56:50 <lispy> dons: Yeah, the bad press at the 2.0 ANN is still hurting us :(
12:57:08 <dons> it was close to the worst possible thing to have done.
12:57:18 <lelf> hgolden: perhaps... :)
12:57:46 <mmorrow> BMeph: but the foldl' (\(a,b) c -> bang (a+b,b*c)) (0,1)    doesn't evaluate past one level deep in the  a+c  and a*c. it does just enough to eval the + and * respectively
12:57:46 <BMeph> Since  (\(a,b) c -> bang (a+b,a*c)) is going to be a line of bang (0,0) thunks.
12:58:57 <mmorrow> so it avoids         ((((((a+c)+c)+c)+c)+c)+...), ...)       happening after a while
12:59:05 <BMeph> Oh, wait... I got it, NM. :)
12:59:06 <Jedai> BMeph: It still would overflow the stack without the bang, even it the result isn't very interesting
13:00:17 <gwern> @seen mauke
13:00:17 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:00:23 <mmorrow> BMeph: this example is fresh in my mind from someone a week or two ago hpasting a stack overflow which was caused by this same thing, and it really made me be aware of this case
13:00:30 <gwern> preflex: seen mauke
13:00:30 <preflex>  mauke was last seen on #xmonad 1 hour, 2 minutes and 25 seconds ago, saying: you can probably strip it to reduce its size
13:01:13 <gwern> @ask mauke has the preflex darcs repo moved somewhere? http://mauke.ath.cx/preflex seems to be down for me
13:01:13 <lambdabot> Consider it noted.
13:01:19 <mmorrow> lispy: what happened at the "2.0 ANN" (i don't know what that is)
13:01:24 <mmorrow> lispy: ?
13:01:33 <mmorrow> (wrt darcs)
13:03:37 <mmorrow> i couldn't imagine not using darcs, and would definitely be willing to contribute time to helping with stuff that needs to be done (time being the small amount that i can spare, but >0 nonetheless)
13:03:52 <mmorrow> i bet many people feel similarly
13:04:47 <conal`> oops -- i forgot to sign off at work.  would someone remind me how to grab my user name -- i guess killing my other irc connection?
13:05:05 <mmorrow> ghost conal <passwd>
13:05:06 <lispy> conal`: /msg nickserver ghost conal <yourpassword>
13:05:13 <lispy> er
13:05:16 <lispy> nickserv?
13:05:17 <lispy> no er
13:05:29 <mmorrow> i just do /ghost mmorrow <passwd>
13:05:39 <conal`> lispy, mmorrow: thx!
13:05:44 <lispy> conal`: yw
13:06:12 <mmorrow> np
13:06:26 <lispy> mmorrow: http://lists.osuosl.org/pipermail/darcs-devel/2008-April/007778.html
13:06:27 <lambdabot> Title: [darcs-devel] announcing the darcs 2.0.0 release, http://tinyurl.com/5snhwn
13:06:38 <conal`> hm: "*** ghost: Unknown command"
13:06:48 <lispy> mmorrow: I need to run to an appointment, but the stuff you want to know is in that email
13:07:13 <lelf> conal`: /msg nickserv help ghost
13:07:14 <lispy> conal`: in my client at least, you have to message the nick serv bot
13:07:34 <mmorrow> lispy: cool. i just found http://www.haskell.org/pipermail/haskell-cafe/2008-August/045701.html  as well
13:07:36 <lambdabot> Title: [Haskell-cafe] poll: how can we help you contribute to darcs?, http://tinyurl.com/5evk6e
13:07:42 <mauke> gwern: hi
13:07:42 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
13:08:09 <Azure_Ag> Good evening, gentle creatures.
13:08:21 <xerox> Hello :)
13:08:21 <conal`> woot!
13:08:28 <mauke> gwern: mauke.ath.cx is my home pc. it's unreachable when I switch it off and when my internet connection drops (every 24 hours)
13:08:37 <lispy> mmorrow: yes and please add to that second thread (it just started today)
13:08:47 <mmorrow> lispy: most definitely
13:08:48 * lispy &
13:10:14 <gwern> mauke: oh. is it up now?
13:10:20 <mauke> should be
13:10:34 <mauke> as soon as the dynamic dns updates
13:11:05 <Jedai> mmorrow: As I said, bang is not the good way to resolve the stack overflow problem with pair and foldl'
13:11:31 <Jedai> mmorrow: The right way is strict pair, it's faster and cleaner
13:11:39 <mmorrow> Jedai: i must have missed your conclusion. was it to use (# , #) ?
13:12:21 <Jedai> mmorrow: Well (# , #) is ugly, you can always define your own strict pair datatype (and there was one in the library recently)
13:12:23 <mmorrow> Jedai: ah, i agree, and recently've been starting to use strict pairs in some of my code
13:12:46 <mmorrow> Jedai: you mean like  Vector !a !a !a !a    then?
13:12:46 <gwern> lispy: as I've said before, the way to make darcs easier is very clear from the xmonad model. a focus on haddocks, cabalization, QC tests for important things, and clean code
13:12:47 <Jedai> mmorrow: But anyway it's much faster than lazy tuple
13:13:08 <Jedai> mmorrow: Yeah or !a :& !b
13:13:36 <chrisdone> gwern: where did you get the code for this upload? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/goa
13:13:37 <lambdabot> Title: HackageDB: goa-3.0
13:13:46 <gwern> (also, libraries. but xmonad isn't a terrific example of using libraries, precisely, in the interests of easy installs)
13:13:51 <Jedai> If I remember right, you had :!: in Data.Pair for a time
13:13:59 <mmorrow> Jedai: i grabbed ghc's strict state monad and reformatted/made-it-mine. it's a nice little module. i'll hpaste
13:14:33 <gwern> chrisdone: the goa darcs repo
13:14:38 <gwern> http://www.cse.unsw.edu.au/~dons/code/goa
13:14:40 <lambdabot> Title: Index of /~dons/code/goa
13:14:48 <gwern> so far as I know, dons never moved it over to c.o.haskell
13:15:15 <gwern> (he also didn't accept my cabal patch for it)
13:18:00 <mmorrow> Jedai: http://hpaste.org/9323
13:19:38 <BMeph> preflex is accessible - I just finished `darcs get`
13:21:12 <gwern> yes, my pull finished a little while ago
13:21:34 <Jedai> BMeph: What is preflex, another lambdabot ?
13:21:46 <gwern> mauke: how many of the preflex plugins do you think are preflex-specific? it'd be interesting if one could pull out @seen and the ohter plugins from lambdabot and preflex into a single library
13:22:10 <BMeph> Jedai: Er, I'd say 'yes,' but it's mauke's brainchild, so I'll defer to him. :)
13:23:08 <mauke> gwern: that doesn't sound very useful to me
13:23:37 <mauke> where would it store the data?
13:23:57 <gwern> mauke: ~/.irc, perhaps
13:24:09 <mauke> you mean manually?
13:24:56 <gwern> well, serialization to disk is a good thing, but I don't really see why libraryfying plugins would have anything to do with where data is stored
13:25:24 <mmorrow> on this topic... what would i have (in particular) do to add template-haskell syntax to lambdabot? if i knew where to start (i know nothing about lambdabot's internals) i'd do it asap
13:25:28 <gwern> although I do think storing to disk avoids crash issues, and storing in a canonical location avoids issues like 'lambdabot can only be run in the darcs repo directory'
13:25:58 <mauke> gwern: preflex uses a separate data server for everything
13:26:15 <mauke> communication goes over a named socket
13:26:32 <gwern> mmorrow: what do you mean?
13:26:36 <mauke> the Plugin monad encapsulates access to the storage "db"
13:27:35 <gwern> mauke: an interesting approach. so I guess the server links in the various plugins?
13:27:44 <mauke> huh?
13:27:44 <mmorrow> gwern: so assume there's a function       unQ :: Q a -> a     (which internally would have to use unsafePerformIO, but ignore that for now)     ,
13:27:45 <mmorrow> then
13:28:07 <mmorrow> ppr . unQ ( [d| data A = A | B |])
13:28:10 <mmorrow> would eval to
13:28:14 <mauke> the basic functions of the server are store(key, value) and retrieve(key) -> value
13:28:27 <mmorrow> "data A = A | B" :: String
13:28:37 <mmorrow> actually, that should be   pprint . unQ ( [d| data A = A | B |])
13:28:54 <gwern> mmorrow: you mean you want '>' to understand TH?
13:28:55 <mmorrow> actually, that should be   (pprint . unQ)  [d| data A = A | B |]
13:29:02 <mmorrow> gwern: exactly
13:29:34 <gwern> hm. the sandboxing code does have comments about TH. to the effect, I think, 'if we hide 1 or 2 functions, TH *should* be safe to use'
13:30:01 <mmorrow> gwern: yeah, i've read that and i'm fairly well up to date on TH particular, so i feel i can make it safe
13:30:50 <mmorrow> and if '>' understood TH syntax, i think that'd be a *huge* things for its approachability
13:30:55 <mmorrow> s/s//
13:32:42 <gwern> mmorrow: interesting. I wonder how hard it'd be to do TH in mueval
13:33:33 <mmorrow> gwern: i'd be willing to code it up anywhere, i just don't know where to start and don't have an excessive amount of time to spend trying to figure out where to even begin
13:34:45 <gwern> mmorrow: what is unQ?
13:34:48 <gwern> I don't see it in my hoogle
13:34:52 <gwern> I see runQ
13:34:56 <mmorrow> it's not
13:35:08 <mmorrow> unQ :: Q a -> a           unQ = unsafePerformIO . runQ
13:35:28 <mmorrow> (because    [| id "asfd" |] :: Q Exp
13:35:35 <Orphi> does uninstalling GHC also uninstall all Haskell modules?
13:36:31 <mmorrow> ghci> (pprint . unQ) [| \x -> x |]
13:36:31 <mmorrow> "\\x_0 -> x_0"
13:36:35 <mmorrow> ghci> (show . unQ) [| \x -> x |]
13:36:35 <mmorrow> "LamE [VarP x_2] (VarE x_2)"
13:37:22 <gwern> mmorrow: ah, I see. I'm just following along in ghci
13:37:41 <gwern> hm. I suppose one could write a SafeTH module, and only export some of the TH modules...
13:38:05 <mmorrow> gwern: so, i'd create a new monad which is an instance of Quasi (i already have one such monad, which used plugins eval to implem reify), and this monad would not implem runIO (for obvious reasons), and unQ would be made safe somehow
13:38:50 <mmorrow> gwern: i'll code up such a module and get back to you (this would be at the earlies tues/wed)
13:39:08 <gwern> mmorrow: sounds interesting. I'd like to see such a module - I could stick it into the show package, which I'm already using for such purposes but for QuickCheck/SmallCheck
13:39:31 <mmorrow> gwern: is mueval in #haskell though? i really want to be able to run code w/ TH in it with '>'.
13:39:55 <mmorrow> err, mubot i mean
13:41:48 <mauke> :t foldM
13:41:50 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:52:48 <mauke> how do I select the maximum n elements from a list, using a key extractor in IO?
13:52:56 <mmorrow> gwern: another really nice function for dealing with TH in ghci/anytime-you want it to be readable is:
13:53:14 <mauke> that is, (Ord b) => Int -> [a] -> (a -> IO b) -> IO [(a, b)]
13:53:30 <mmorrow> cleanNames :: (Data a) => a -> a        cleanNames = everywhere (mkT (mkName . nameBase))
13:55:01 <mmorrow> ghci> (show . unQ) [| \f g x -> (g . f) (Just (), [x]) |]
13:55:01 <mmorrow> "LamE [VarP f_9,VarP g_10,VarP x_11] (AppE (InfixE (Just (VarE g_10)) (VarE GHC.Base..) (Just (VarE f_9))) (TupE [AppE (ConE Data.Maybe.Just) (ConE GHC.Base.()),ListE [VarE x_11]]))"
13:55:10 <mmorrow> (ugly)
13:55:15 <mmorrow> ghci> (show . cleanNames . unQ) [| \f g x -> (g . f) (Just (), [x]) |]
13:55:15 <mmorrow> "LamE [VarP f,VarP g,VarP x] (AppE (InfixE (Just (VarE g)) (VarE .) (Just (VarE f))) (TupE [AppE (ConE Just) (ConE ()),ListE [VarE x]]))"
13:55:18 <mmorrow> (nicer)
13:56:04 <solrize> @hoogle  [a] -> (a -> IO b) -> IO [(a, b)]
13:56:05 <lambdabot> No matches, try a more general search
13:56:23 <mmorrow> gwern: and it's the diff between:
13:56:42 <mmorrow> "\\f_0 g_1 x_2 -> (g_1 GHC.Base.. f_0) (Data.Maybe.Just GHC.Base.(),[x_2])"
13:56:44 <mmorrow> and
13:56:48 <gwern> mmorrow: mubot doesn't exist yet. it is blocked on mueval being finished
13:56:48 <mmorrow> "\\f g x -> (g . f) (Just (), [x])"
13:57:14 <mmorrow> gwern: ahhh. i'd always seen the mubot subdir, but never checked in to it
13:57:29 <mmorrow> err, that's the other way around
13:57:45 <mmorrow> whatever the case may be, i didn't know it didn't exist
13:58:04 <dcoutts_> xerox: long time no see
13:58:16 <gwern> mmorrow: that's an interesting function. so it's at runtime compiling a Haskell expression into core?
13:58:20 <xerox> dcoutts_: hi there (:
13:58:24 <dcoutts_> :-)
13:58:24 <gwern> or, no, I guess that'd be a syntax tree
13:58:26 <dcoutts_> @arr!
13:58:26 <lambdabot> Shiver me timbers!
13:58:34 <xerox> ?yarr!
13:58:35 <lambdabot> Yarrr!
13:58:39 <xerox> indeed!
13:59:01 <camio> Is there anyway to ask lambda bot to find a function with a given signature?
13:59:24 <lament> @hoogle (a -> b) -> [a] -> [b]
13:59:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
13:59:25 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
13:59:25 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:59:41 <camio> @hoogle (a,b) -> (b,a)
13:59:41 <lambdabot> No matches, try a more general search
13:59:47 <dcoutts_> xerox: how's your course going?
13:59:51 <camio> arg
13:59:52 <mauke> @djinn (a,b) -> (b,a)
13:59:53 <lambdabot> f (a, b) = (b, a)
14:00:13 <mmorrow> gwern: you can only use   [| ...<exp>... |] at runtime if you (eg) use plugins dynamic eval or something, since ghc takes the quoted expression, parses it, renames vars, etc, then turns it into a TH abstract syntax tree
14:00:20 <lament> (a,b) -> (b,a) sounds like it should be a standard arrow function with some ridiculous name like >><<
14:00:28 <camio> hehe
14:00:34 <BMeph> Heh-heh, another victim^w potential ally in my request for swap... ;)
14:00:56 <xd> importing swap would take more chars than defining it manually
14:01:14 <xerox> dcoutts_: it's going well, i still have something for september, but it's okay. Are you still TA-ing?
14:01:17 <camio> xd: Yes, but then I wouldn't have to write points.
14:01:25 <camio> xd: Which is much much worse.
14:01:37 <mauke> camio: swap = snd &&& fst
14:01:38 <dcoutts_> xerox: I've just finished TA'ing a couple months ago
14:01:50 <gwern> mmorrow: well, mueval is using the GHC API. that count?
14:01:51 <camio> mauke: yay! Thanks.
14:02:15 <mauke> @. pl djinn (a,b) -> (b,a)
14:02:15 <lambdabot> f = uncurry (flip (,))
14:02:23 <mauke> there, from type to pointless definition
14:02:28 <mmorrow> gwern: err, actual i don't think the explanation is quite correct, but i guess the point is that TH is compile-time-only metaprogramming
14:02:59 <mmorrow> gwern: oh yeah, most definitely. anything that is the equivalent of  hs-plugins' eval function
14:03:03 <pastorn> how do i perform a command?
14:03:11 <pastorn> String -> IO ()
14:03:21 <pastorn> @hoogle String -> IO ()
14:03:21 <lambdabot> Prelude.putStr :: String -> IO ()
14:03:21 <lambdabot> Prelude.putStrLn :: String -> IO ()
14:03:21 <lambdabot> System.IO.putStr :: String -> IO ()
14:03:40 * pastorn is scripting in haskell...
14:03:49 <mauke> @hoogle system
14:03:50 <lambdabot> System.Cmd.system :: String -> IO ExitCode
14:03:50 <lambdabot> Distribution.System :: module
14:03:50 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
14:04:07 <xerox> dcoutts_: now it's time for some vacations
14:04:26 <mmorrow> gwern: i've a haskell quasiquoter  which is mostly done at: http://code.haskell.org/~morrow/code/haskell/metaquote
14:04:26 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
14:04:37 <mmorrow> in particular, see the Language.Haskell.Meta.QQ module
14:04:43 <mmorrow> http://code.haskell.org/~morrow/code/haskell/metaquote/src/Language/Haskell/Meta/QQ.hs
14:04:44 <lambdabot> http://tinyurl.com/68zw8z
14:05:11 <mmorrow> you'll see the eval function at the bottom of QQ.hs
14:05:16 <dcoutts_> xerox: yay
14:05:19 <gwern> mmorrow: I dunno what quasiquoting is :) or why you'd want it in mueval
14:05:27 <pastorn> mauke: thanks :)
14:05:35 <mmorrow> gwern: that's irrelevant for QQ.hs
14:05:36 <xerox> dcoutts_: I miss cambridge :) But I would be unable to come at any event this summer :(
14:05:59 <dcoutts_> xerox: ah well, in spring perhaps
14:06:04 * dcoutts_ has to go
14:06:12 <xerox> bye bye!
14:06:27 <mmorrow> gwern: in QQ.hs a module is defined which is made an instance of Quasi, so this means that it become essentially a drop-in replacement for the Q monad
14:07:11 <mmorrow> but the important difference about QQ, Q can't call reify at runtime, but QQ can
14:07:37 <gwern> hm. is it just me or is 'cabal list' slow these days?
14:08:21 <mmorrow> gwern: ohh, that QQ.hs is a newer version and doesn't have the particular thing i meant to show you, hold on
14:08:31 <mmorrow> oh no, it does
14:08:56 <mmorrow> see the evalReify function
14:09:14 <mauke> :t mapMaybes
14:11:33 <mmorrow> > 1
14:11:35 <lambdabot>  1
14:11:40 <mmorrow> hmm
14:12:22 <Toxaris> @type mapMaye
14:12:23 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:12:25 <Toxaris> @type mapMaybe
14:12:26 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
14:16:30 <gwern> mmorrow: metaquote not on hackage? is it incomplete?
14:17:20 <BMeph> gwern: I think it's "reserved for 6.10" (well, 6.9 at least) :)
14:18:10 <mmorrow> gwern: i feel i need to touch up a few things before i put it there, but i haven't found time. i think this is just me being neurotic and i should really just upload it
14:19:17 <mmorrow> gwern: oh, i just realized i may not have given any motivation as to why i was even showing you that. so the point was, it's an example of how one would go about making a same Q monad for untrusted eval and an example of how one might go sneaking around that TH is compile-time-only. But since lambdabot/mubot like ghci in that dynamic compilation+eval is what it does, the compile-time-only aspect of TH isn't a problem
14:20:51 <mmorrow> (ignore the fact that some of that came out incoherent)
14:21:01 <mmorrow> s/incoherent/mangled/
14:22:19 <mmorrow> gwern: oh yeah, also what BMeph said. -XQuasiQuotes desn't exists in ghc < 6.9
14:22:29 <gwern> mmorrow: mm, you mind want to add a ghc dep then
14:22:33 <gwern> I just noticed it failed to compile
14:22:43 <gwern> *might
14:23:03 <mmorrow> gwern: oh, ok. i'll do that asap
14:25:39 <mmorrow> gwern: actually, metaquote itself doesn't depend on -XQuasiQuotes, but does require a new enough template-haskell package that has Language.Haskell.TH.Quote
14:26:06 <gwern> yeah, that was the error - couldn't find that module
14:26:14 <mmorrow> so i'll add the min version requirement to template-haskell
14:26:30 <mmorrow> http://darcs.haskell.org/libraries/template-haskell/
14:26:31 <lambdabot> Title: Index of /libraries/template-haskell
14:26:47 <mmorrow> if you install the darcs template-haskell, you'll be good
14:28:00 <shapr> @seen edwardk
14:28:00 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:28:07 <shapr> preflex: @seen edwardk
14:28:22 <shapr> preflex: seen edwardk
14:28:22 <preflex>  edwardk was last seen on #haskell 2 days, 20 hours, 58 minutes and 23 seconds ago, saying: =)
14:29:19 <dcoutts_> gwern: cabal list is indeed very slow, it's because you've got lots and lots of packages registered
14:29:29 <dcoutts_> gwern: and reading the installed package db is very slow
14:29:37 <dcoutts_> gwern: eg time ghc-pkg list
14:30:02 <dcoutts_> gwern: cabal cannot read the list any faster than ghc-pkg can
14:30:07 <dcoutts_> that's the limiting factor
14:30:21 <mmorrow> real    0m0.562s
14:30:22 <mmorrow> user    0m0.536s
14:30:22 <mmorrow> sys     0m0.011s
14:30:30 <mmorrow> (on mine)
14:30:35 <dcoutts_> and ghc-pkg is slow to read it because internally it's stored in Read/Show format and those parsers are slow
14:30:51 <dcoutts_> mmorrow: you're lucky it's that quick
14:30:57 <dcoutts_> real    0m8.861s
14:30:57 <dcoutts_> user    0m5.784s
14:30:57 <dcoutts_> sys     0m0.036s
14:31:01 <mmorrow> holy crap
14:31:05 <dcoutts_> though that is on my 500Mhz sparc
14:31:10 <mmorrow> oh, heh
14:31:38 <dcoutts_> ghc-pkg list --simple-output | wc -w
14:31:39 <dcoutts_> 68
14:31:55 <mmorrow> i have 2x  Intel(R) Core(TM)2 CPU         T7200  @ 2.00GHz
14:31:57 <dcoutts_> mmorrow: on my fast desktop it's about 1.2 sec, with ~400 packages registered
14:32:14 <mmorrow> dcoutts_: whoa, i thought i had a lot of packages
14:32:25 <dcoutts_> mmorrow: you've not been testing hackage ;-)
14:32:38 <roconnor> > sqrt(3) * (5*12 + 4) / 12
14:32:40 <lambdabot>  9.237604307034012
14:33:21 <gwern> dcoutts_: are you sure?
14:33:36 <gwern> I time ghc-pkg list as being 0.8 s, and cabal list at 5.2 seconds
14:33:52 <dcoutts_> gwern: try: time cabal list xmonad
14:34:03 <gwern> mmorrow: I have 218 packages installed
14:34:15 <gwern> dcoutts_:  2.4s
14:34:21 <mmorrow> i'm trying to find a way to count mine..
14:34:33 <dcoutts_> gwern: the difference is the time to parse the .cabal files of every package, vs just a subset
14:35:31 <gwern> it takes 2 moer seconds to parse the cabal files of several hundred packages versus 1?
14:35:45 <dcoutts_> gwern: there must be some other overhead too
14:36:31 <dcoutts_> gwern: but reading the hackage package index is very quick, if you don't have to inspect the content of any packages (ie just look at the package id)
14:37:10 <dcoutts_> gwern: cabal list does a linear search through package names, because it's doing substring matching
14:38:19 <gwern> sounds like a job for par!
14:38:22 <gwern> just kidding
14:39:29 <mmorrow> i have 185
14:39:35 <mmorrow> ghc-pkg list | tail -`eval 'echo "\`ghc-pkg list | wc -l\` - 1" | bc'` | tr -d ' ' | tr -d '\n' | tr , '\n' | wc -l
14:39:52 <mauke> preflex: karmatop
14:39:53 <preflex>  c: 21125; g: 1135; ##c: 711; c/c: 529; vc: 425; #c: 308; notepad: 227; "c: 181; ##iso-c: 156; ac: 153
14:39:54 <dcoutts_> gwern: heh, true. I think there are more pressing performance and feature work though. Reading the installed package index really does need to be addressed.
14:48:00 <mmorrow> i'm building 6.8.3 with 6.4.1 on a 4-core 3GHz Xeon box with make -j10, and i must be at 1hour+ now
14:50:00 <mmorrow> oh wow, it's been 3hrs (i'm building all the extralibs too)
14:57:37 <ddarius> mauke: Impressive.
14:59:41 <dolio> 6.4.1 builds slowly.
14:59:50 <dolio> That was before -fasm.
15:00:11 <ddarius> dolio: He's using 6.4.1 to build 6.8.3
15:00:27 <zachk> what does MVar stand for, and what can i liken it to
15:00:32 <dolio> Right.
15:01:00 <mauke> a possibly empty box
15:01:09 <b\6> can linux ghc produce exes for windows ok?
15:01:09 <mauke> also, a queue of size 1
15:01:35 <ddarius> b\6: No.
15:02:28 <dolio> That was my explanation for why it's taking so long. Building GHC with 6.8 or later probably takes me 3 hours on a machine with less than 1/4 that power.
15:04:49 <dolio> Oh, or was my grammar confusing? I guess I should have said '6.4.1 compiles things slowly.'
15:06:47 <zachk> what if i want MQueueOfInfiniteLength is there an out of the box solution to that?
15:07:09 <ddarius> Chan
15:07:09 <dolio> Chan
15:07:19 <mauke> JackieChan
15:13:21 <mauke> whee, preflex++
15:13:36 <mmorrow> dcoutts_: here's a derived Read instance for InstalledPackageInfo_ fwiw. maybe it could help to write a more efficient parser
15:13:42 <mmorrow> http://hpaste.org/9326
15:14:09 <mmorrow> (and serves as an example of the awesomeness of the derive package)
15:14:24 <mauke> preflex: rot13 this sentence no verb.
15:14:24 <preflex>  guvf fragrapr ab ireo.
15:14:40 <mauke> why isn't there a rot13 module on hackage?
15:14:53 <dcoutts_> mmorrow: but that's going to be just as slow as the derived Read instance isn't it?
15:14:54 <mmorrow> preflex: rot13 guvf fragrapr ab ireo.
15:14:54 <preflex>  this sentence no verb.
15:15:11 <lispy> preflex: rot13 tang
15:15:11 <preflex>  gnat
15:15:12 <dcoutts_> mmorrow: I think one has to use a different parser, and probably with a dedicated lexer
15:15:21 <lispy> I love that tang/gnat is a rot13 palindrome
15:15:33 <mmorrow> dcoutts_: yeah, but it maybe be able to be extracted from the instance decl and tweaked
15:15:49 <mmorrow> really, i just wanted an excuse to run derive on something ;)
15:15:57 <dcoutts_> mmorrow: :-)
15:16:10 <dcoutts_> mmorrow: really, the solution is for ghc-pkg to use a binary format, and for us to parse the output of ghc-pkg lazily
15:16:34 <mmorrow> dcoutts_: ohhh. i'll really quickly derive a Binary instance for it...
15:16:59 <dcoutts_> mmorrow: that code would have to be in ghc-pkg and ghc
15:17:25 <mmorrow> ah, yeah
15:18:21 <lispy> mmorrow: I see that you're eager to be helpful, but you may need a different strategy to maximize the pay-off (email the list saying you're adding the feature, send in some patches and then wait for comments might work better)
15:19:37 <ahunter> Hey, I'm curious--is there a standard LaTeX tool for embedding Haskell code?
15:19:54 <koninkje> lhs2TeX?
15:19:55 <ahunter> iirc, there's a way to convert literate scripts, but I don't want that--I just would like to stick a snippet in a plain latex paper
15:20:03 <mmorrow> lispy: will do. in the meantime i'm going to spend the 10 minutes it'll take to write a little cli app that archives a package.conf with Data.Binary and Codec.GZip :)
15:20:06 <dcoutts_> ahunter: yes, lhs2tex is excellent
15:20:17 <lispy> mmorrow: cool
15:20:41 * mmorrow start the timer
15:21:12 <ahunter> dcoutts_: yeah, but is there a lighterweight solution if I'm not really writing full haskell programs?  I.e. I'm just writing a paper in LaTeX and want to stick the line let foo = map f . map g . map h $ lst in the middle somewhere
15:21:34 <lispy> ahunter: well, you could always just verbatim it
15:21:35 <dcoutts_> ahunter: there are some haskell macro packages
15:21:59 <lispy> IMO, I dislike when paper replace haskell code with funny symbols that won't compile
15:22:10 <seliopou> IMO, I love that
15:22:21 <dcoutts_> lispy: you just need a different lexer :-)
15:22:45 <lispy> Perhaps, but the one I have is great for reading real code
15:24:31 <seliopou> I like it because it changes the experience
15:24:45 <seliopou> it's like you're reading equations rather than code
15:25:43 <Jedai> ahunter: You can use listings, they have an Haskell setting
15:26:03 <ahunter> Jedai: sweet, thanks
15:26:11 <ddarius> If you don't use a blackboard R it's not real math.
15:26:26 <lispy> The first time I was reading a paper about haskell and encountered the funny replacement for (++) I had to ask someone what that symbol represented.  It wasn't a good start.  I do like if alpha can be replaced by \alpha, that's nice.  But when operators are changed I actually find it confusing.
15:27:39 <koninkje> @hoogle m Bool -> m () -> m ()
15:27:40 <lambdabot> No matches, try a more general search
15:28:15 <lispy> :t when
15:28:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:28:20 <lispy> :t liftM
15:28:21 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:28:37 <koninkje> yeah...
15:28:39 <lispy> :t liftM when
15:28:42 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 Bool -> m1 (m () -> m ())
15:29:10 <lispy> :t whenM
15:34:03 <seliopou> :t (. flip when) . (>>=)
15:34:04 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
15:36:00 <dolio> > let f = 0 : zipWith (+) f (1:f) in f
15:36:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:37:04 <mmorrow> lispy: ok, my time's about up. these'll work once i figure out the typo of m in InstalledPackageConfig_ m  so the read function doesn't fail. other than that, they work :)
15:37:06 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/pkginfo-encode.hs
15:37:07 <lambdabot> http://tinyurl.com/5rcp4h
15:37:10 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/pkginfo-decode.hs
15:37:11 <lambdabot> http://tinyurl.com/6j4opc
15:37:23 <mmorrow> s/typo/type/
15:40:42 <mmorrow> they take the package.conf on stdin
15:41:10 <ziman> @unpl \f ->  0 : zipWith (+) f (1:f)
15:41:10 <lambdabot> \ f -> 0 : zipWith (+) f (1 : f)
15:41:14 <ziman> @pl \f ->  0 : zipWith (+) f (1:f)
15:41:14 <lambdabot> (0 :) . ap (zipWith (+)) (1 :)
15:41:31 <chrisdone> lambdabot should have a copycat plugin that says a message pretending to be someone based on markov chains of their previous logs :)
15:42:13 <pastorn> @hoogle filterM
15:42:13 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
15:50:56 <mmorrow> lispy: ok, they work
15:50:58 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/pkginfo-encode.hs
15:50:59 <lambdabot> http://tinyurl.com/5rcp4h
15:51:00 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/pkginfo-decode.hs
15:51:01 <lambdabot> http://tinyurl.com/6j4opc
15:52:41 <mmorrow> (i was linking to a diff cabal version than package.conf was created with)
15:53:17 <dcoutts_> mmorrow: aye, that's one of the tricky things, the format is essentially internal and it changes occasionally
15:53:30 <dcoutts_> mmorrow: Cabal itself knows how to read three versions of package.conf files
15:53:46 <dcoutts_> though it actually only uses two
15:55:05 <mmorrow> dcoutts_: heh, i just *couldn't* figure out why read was failing, then remembered i have three diff cabal versions install, the newest being 1.5.1
15:55:26 <mmorrow> my package.conf was apparently written with Cabal-1.3.2 though
15:55:52 <dcoutts_> mmorrow: it's actually related to the ghc version rather than the Cabal version
15:56:05 <dcoutts_> mmorrow: since it's ghc-pkg that writes the package.conf
15:56:35 <dcoutts_> (though it uses the Show instance from the data type defined in the Cabal lib)
15:57:01 <mmorrow> ah yeh, ghc-pkg has it's one internal cabal (that doesn't necessarily correspond to a released cabal version) then?
15:57:11 <mmorrow> s/one/own/
15:57:29 <dcoutts_> mmorrow: it corresponds to the version of Cabal that came with that version of ghc
15:57:39 <mmorrow> oh gotcha
15:57:52 <dcoutts_> mmorrow: it changed between 6.4.1 and .2, and it has changed again in ghc-6.9
15:58:12 <mmorrow> hehe, i know about the change in 6.9 all to well
15:58:18 <mmorrow> to -> too
15:59:39 <mmorrow> (not by choice, but using 6.9 with most any hackage package makes you knowledgeable about cabal changes/quirks pretty fast ;))
16:00:01 <dcoutts_> yes indeed
16:05:38 <ddarius> chrisdone: Write one.
16:06:30 <dcoutts_> chrisdone: heh, that is a cool idea
16:06:53 <dcoutts_> chrisdone: I think lambdabot would probably have me saying @arr! rather a lot :-)
16:09:24 <chrisdone> dcoutts_: yeah :P
16:09:29 <chrisdone> ddarius: I am going to ;)
16:20:34 <lispy> ?. vixen arr
16:20:35 <lambdabot> so?
16:21:30 <luqui> ?arr
16:21:30 <lambdabot> Avast!
16:21:41 <lispy> ?help arr
16:21:42 <lambdabot> arr. Talk to a pirate
16:21:53 <lispy> ?arr Too bad you can't translate what I say into pirate
16:21:53 <lambdabot> Smartly me lass
16:22:25 <luqui> hmmm....
16:22:29 <luqui> ?arr Too bad you can't translate what I say into pirate
16:22:30 <lambdabot> Yo ho ho, and a bottle of rum!
16:22:38 <luqui> maybe it should pick the response based on a hash
16:22:47 <luqui> so that when we get good responses, we can repeat them
16:24:18 <lispy> ?. vixen arr
16:24:18 <lambdabot> Most guys don't understand me, but we really seem to connect.
16:24:31 <lispy> Figures, vixen likes pirates :(
16:28:21 <BMeph> lispy: Hm? You were hoping for ninjas? ;)
16:28:24 <Twey> I suggest piping to the Text Filter Suite: http://dougal.gunters.org/projects/text-filter-suite/README.txt
16:32:37 <lispy> BMeph: don't you know, I have a crush on vixen so I was hoping for haskell programmers
16:32:46 <lispy> ?vixen we'll get married some day
16:32:46 <lambdabot> you sound like an awesome guy... are you single?
16:32:59 <lispy> O_O
16:33:13 * lispy takes this to /msg lambdabot
16:33:54 <lament> @vixen BANZAI!
16:33:54 <lambdabot> If something takes a lot of effort to do, it probably ain't worth doing.
16:34:07 <lament> she does not like ninjas :(
16:38:29 <BMeph> @vixen Bonsai?
16:38:30 <lambdabot> yes
16:38:48 <BMeph> lament: But she does like gardeners? ;)
16:41:52 <Cale> @vixen ä¸‡æ­³
16:41:52 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
16:42:06 <Cale> ã€‚ã€‚ã€‚
16:42:55 <EvilTerran> well, that utterly confused her
16:43:41 <luqui> ?vixen lispy is a good guy.  I think we should break up.
16:43:41 <lambdabot> good good
16:50:27 <Shiruka> ?vixen what's a lambda with such beautiful eyes doing in a place like this?
16:50:28 <lambdabot> i like what i'm hearing... you sound sexy
16:52:08 * Shiruka tried to think of the worst pickup line possible, but certainly there must be worse ones
16:54:40 <BMeph> @vixen Are those mirrors in your jeans, 'cause I can see myself in 'em!
16:54:40 <lambdabot> Uh-huh
16:54:46 <BMeph> o.O
17:13:10 <ivanm> dons: ping!
17:14:18 <SubOne> http://hpaste.org/9327 getting a compile error: Main.hs:56:42:, No instance for (Num [a]), arising from a use of `+' at Main.hs:56:42-44, Possible fix: add an instance declaration for (Num [a])
17:15:29 <SubOne> I'm sure I'm doing everything wrong...
17:15:47 <SubOne> That line was working before I added the outFacotrials bits
17:16:19 <mauke> hah
17:16:24 <mauke> it thinks l is a list of lists
17:16:42 <SubOne> did I do it wrong?
17:16:58 <mauke> you'll probably get a better error if you put type signatures in
17:17:01 <ivanm> SubOne: try adding your own type signatures to the functions
17:17:06 <ivanm> dammit, mauke beat me!
17:17:09 <SubOne> idk what that means
17:17:17 <mauke> ok then
17:17:23 <ivanm> SubOne: OK, for factorial for instance
17:17:27 <SubOne> I'm following a tutorial it says nothing of type signatures
17:17:36 <mauke> I can see two problems in outFactorials
17:17:43 <SubOne> ok...
17:17:45 <ivanm> you have  factorial :: Int -> Int (it takes in an integer and returns and integer)
17:18:01 <mauke> #1:  if null x then
17:18:02 <ivanm> SubOne: ummm... which tutorial is this that covers the IO monad before type signatures?
17:18:21 <mauke> null takes a list
17:18:25 <lispy> :t null
17:18:27 <lambdabot> forall a. [a] -> Bool
17:18:28 <mauke> x is supposed to be a number, not a list
17:18:29 <SubOne> ivanm: Actually it said that it was gonna cover the IO monad later and to ignore most of it
17:18:38 <ivanm> ahhh
17:18:42 <ivanm> this is a copy/paste
17:18:57 <SubOne> ivanm: no its based on their example, this is an exercise
17:19:07 <mauke> this null x call forces it to rethink everything, causing subsequent errors in other places
17:19:41 <SubOne> ok so how would i handle it?
17:20:12 <mauke> you'd add another case for outFactorial for when it's called with an empty list
17:20:18 <SubOne> should i just use a single variable and use head/tail?
17:20:31 <SubOne> mauke: I tired that but i got a diffeeent error
17:20:39 <mauke> then you did it wrong :-)
17:20:45 <mauke> what did you write?
17:20:59 <SubOne> mauke: when i removed `outFactorials [] = []` it went away :p
17:21:12 <SubOne> sec... lemme tell you whgat it said...
17:21:20 <mauke> don't bother
17:21:27 <mauke> you need a "return"
17:21:36 <SubOne> oh
17:21:45 <SubOne> outFactorials [] = return [] ?
17:21:48 <mauke> yeah
17:21:52 <SubOne> or with a do
17:21:57 <mauke> same thing
17:22:04 <SubOne> compiled :D
17:22:08 <SubOne> lemme test
17:22:17 <mauke> next issue: why does outFactorials return a list anyway?
17:22:22 <mauke> it's always an empty list
17:22:51 <SubOne> i could just as easily return 0, but if not it gives an error that last line of a do must be an expression
17:23:02 <SubOne> return 0 is fine i guess
17:23:07 <mauke> the canonical return value is ()
17:23:19 <SubOne> ?
17:23:33 <mauke> () is what you use when you have nothing useful to return
17:23:41 <SubOne> return () errors
17:23:42 <bd_> > ()
17:23:45 <lambdabot>  ()
17:23:50 <mauke> errors how?
17:23:52 <SubOne>  Couldn't match expected type `[a]' against inferred type `()'
17:24:06 <mauke> can you repaste your current code?
17:24:07 <lispy> When I really have nothing useful to return I return undefined
17:24:14 <SubOne> sec...
17:24:25 <bd_> SubOne: somewhere else you're using outFactorials as if it was returning a list; or you have the type signature stating it returns a list
17:24:47 <SubOne> you mean this line: d <- (outFactorials l)
17:24:55 <mauke> no, that should have no effect
17:25:00 <SubOne> ok
17:25:03 <SubOne> one moment
17:25:31 <SubOne> http://hpaste.org/9328
17:25:58 <mauke> outFactorials [] = return ()
17:26:07 <bd_> mauke: well, it depends on what 'd' is bound to later
17:26:09 <SubOne> oh
17:26:26 <mauke> outFactorials (x : xs) = do { putStrLn (show x ++ " factorial is " ++ show (factorial x)); outFactorials xs }
17:27:14 <SubOne> compiles now
17:27:52 <SubOne> hmm the product comes up wrong
17:28:08 <mauke> it's 0
17:28:14 <SubOne> oh nvm
17:28:16 <SubOne> duh
17:28:26 <SubOne> foldl (*) 1 l :p
17:28:34 <mauke> actually, product l
17:28:45 <SubOne> huh?
17:28:57 <mauke> > product [1, 4, 3]
17:28:59 <lambdabot>  12
17:29:02 <SubOne> oh
17:29:03 <mauke> > sum [1, 4, 3]
17:29:04 <lambdabot>  8
17:29:10 <SubOne> didnt learn that function
17:30:23 <SubOne> well that is certainly easier to read :p
17:31:23 <mauke> do you know any other programming languages?
17:31:27 <SubOne> can someone explain what this tutorial means that foldl cant work on infinite lists because it has to go to the last element first, when it clearly shows the way it works is from left to right not right to left? is the LAST element supposed to be the LEFTmost?
17:31:33 <SubOne> yeah
17:31:38 <SubOne> this one is a doozie
17:31:50 <mauke> what languages do you know?
17:32:31 <SubOne> c#/c/c++,vb,asm,html,js,vbscript,css,etc...
17:32:53 <mauke> ok, then you should be familiar with type signatures :-)
17:32:59 * Twey chuckles.
17:33:12 <mauke> returning () is like a void return type in C
17:33:21 <SubOne> doesn't help me when the tutorial hasn't gone over it yet
17:33:28 <SubOne> syntax is key
17:33:36 <SubOne> this is like no other syntax ive ever seen before
17:33:38 <mauke> right
17:33:42 <Jedai> SubOne: foldl has to go _until_ the last element of the list before it can return anything
17:34:27 <SubOne> Jedai: yes that the thing i dont understand, whereas foldr can output immediately even though it starts at the last element which might be infinite...
17:34:46 <mauke> foldr doesn't start at the last element
17:34:52 <Jedai> SubOne: See foldl f a [b, c] == foldl f (f a b) [c], so after a reduction, it's still a foldl
17:35:23 <SubOne> mauke: thats what the book says (what you just said) says that foldl must go to the last element first, which i dont understand
17:35:25 <mauke> SubOne: this stuff is all about lazy evaluation, so it may take some getting used to
17:35:46 <mauke> SubOne: no, it says foldl must go to every element first
17:35:58 <Jedai> Whereas : foldr f c [a, b] == f a (foldr f c [b]), so it's a call to f, and if f is lazy in its second argument you can get some output immediately
17:35:59 <mauke> which means you get the result after it has visited the last element
17:36:31 <Stinger> > foldl1 (const (const 1)) [1..]
17:36:33 <lambdabot>  Tried to use too much memory
17:36:51 <Stinger> > foldr1 (const (const 1)) [1..]
17:36:51 <lambdabot>  1
17:36:54 <SubOne> "...However, foldr can work on infinite lists, while foldl cannot. This is because before foldl does anything, it has to go to the end of the list."
17:36:59 <mauke> yes
17:37:12 <mauke> "go to the end of the list" means "visit each element in turn"
17:37:22 <SubOne> ic... i read it differently
17:37:52 <Twey> :t foldl
17:37:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:37:57 <mauke> basically, it's tail recursive
17:38:04 <Jedai> SubOne: As you see, after a reduction, foldl stay foldl except if the end of the list has been reached, while foldr immediately becomes a call to another function, which might be lazy in its second argument and can give us some output right now
17:38:11 <Twey> foldl (+) 0 [1..] = (1 + (1 + (1 + (1 + (1 + ...
17:38:25 <mauke> more like 1 + (2 + (3 +
17:38:38 <Twey> mauke: Er, yes.  *coughs*
17:38:46 <Stinger> more like 0 + 1 + 2 + ..
17:38:52 <Stinger> with brackets
17:38:54 * SubOne brain explodes
17:39:09 <Twey> foldr (+) 0 [1..] = ((((0 + 1) + 2) + 3) + 4) ...
17:39:15 <mauke> SubOne: that's normal; just ignore it :-)
17:39:21 <Twey> Hehe
17:39:28 <Stinger> actually no the 0 would be at the end, ignore me
17:39:35 <Jedai> SubOne: I have an URL which explains it well : http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
17:39:36 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
17:39:37 <Twey> SubOne: The brain explosion is one of the more unique features  of learning Haskell.
17:39:59 <Twey> SubOne: You'll have several of them over the course of your progress to enlightenment.
17:40:08 <mauke> meh, just ignore it until you've learned more basic haskell
17:40:27 <Jedai> Yes, brain explosion is very healthy, it widen your horizon !! :-D
17:40:27 <Twey> You see, as foldr's brackets match, it's not necessary to go all the way to the end of the list to calculate a given subset.
17:40:41 <mauke> http://foldr.com/
17:40:42 <lambdabot> Title: 9 foldr.com 20
17:41:16 <Twey> WOW
17:41:23 <Twey> http://foldl.com/ exists too!
17:41:24 <lambdabot> Title: 9 foldl.com 20
17:41:38 <Twey> That pair of sites are, for some reason unbeknownst to me, incredibly awesome
17:41:38 <dons> ivanm: pong
17:42:01 <dons> http://www.reddit.com/comments/6ujle/haskell_fastcgi_lighttpd/ go chrisdone
17:46:12 <b\6> little sad he's using lighttpd. what are the best few haskell http server options?
17:46:30 <Jedai> Twey: Your foldr is a foldl...
17:46:39 <Twey> Is it?  Oh bugger
17:46:57 <SubOne> chapter 4, now its explaining type checking :p
17:47:02 <Twey> No, no it isn't
17:47:07 <Twey> foldl.com says I'm right
17:47:15 <ivanm> dons: not sure if you got my @tell message, but I'm having trouble getting ghc-core-0.3 to compile
17:47:17 <Jedai> Twey: Nope, check the parenthesis
17:47:32 <ivanm> hgolden had the same trouble: http://hpaste.org/9319
17:47:43 <newsham> when using Network.Socket is it necessary to catch SIGPIPE to avoid the process shutting down?  is there a portable way to do this (ie. so that its a nop on win32)?
17:47:47 <dons> ivanm: right, hscolour changed.
17:47:53 <ivanm> ahhhh
17:47:59 <ivanm> so it only likes hscolour 0.9?
17:48:06 <Twey> Jedai: Oh, damn
17:48:13 <dons> b\6: the happs server is the only one in wide use, tibbe's writing a new high performance http server
17:48:43 <b\6> dons: tibbe's stuff in darcs somewhere i can see?
17:48:55 <newsham> also is there a way to test a Socket for eof?
17:49:10 <Jedai> Twey: foldl (+) 0 [1..] = (..((0+1) + 2) + ..
17:49:41 <dons> b\6: hmm, ping him. i'd like to have it more public too.
17:49:55 <dons> rewriting simon marlow's classic concurrent web server would also be a nice task.
17:50:08 <newsham> > foldl (+) z [a,b,c]
17:50:23 <lambdabot>  thread killed
17:50:26 <newsham> > foldl (+) z [a,b,c]
17:50:42 <lambdabot>  thread killed
17:50:47 <newsham> ?karma- lambdabot
17:50:48 <lambdabot> lambdabot's karma lowered to 2.
17:51:05 <ivanm> methinks lambdabot needs a restart
17:51:08 <ivanm> @users
17:51:08 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:51:15 <dons> lambdabot: @quit
17:51:25 <dons> let's see if Cale runs it in a while loop...
17:51:27 <dons> yes.
17:51:36 <newsham> > foldl (+) z [a,b,c]
17:51:36 <ivanm> is lambdabot tracking too many channels these days or something, that she seems to be getting buggier? :s
17:51:44 <lambdabot>  z + a + b + c
17:51:46 <kryptiskt> b\6, There's this, haven't used it though... http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Lucu
17:51:54 <lambdabot> Title: HackageDB: Lucu-0.1
17:52:06 <dons> kryptiskt: hey, didn't know about that.
17:52:19 <dons> how'd i miss it .hmm
17:52:24 <newsham> seems like it would be fairly easy to abuse the bot since it responds back with more lines than you send it (force multiplication) and irc is throttled.
17:52:51 <roconnor> ivanm: I blame the language that lambdabot is writen in.  ... although people here smack me when I say that.
17:52:58 <ivanm> @slap roconnor
17:53:00 <ivanm> like that?
17:53:01 <ivanm> :p
17:53:04 <roconnor> :P
17:53:04 * lambdabot throws some pointy lambdas at roconnor
17:53:14 <dons> roconnor: explain yourself.
17:53:15 <ivanm> why, what's wrong with haskell as a language to write a bot in?
17:53:17 <newsham> lambada bot
17:53:24 <ivanm> newsham: lol
17:53:39 <roconnor> ivanm: inexpressive type system. :D
17:54:23 <b\6> kryptiskt: thanks, checking.
17:54:44 <roconnor> anytime anything goes wrong with software, it's because of an insufficent type system.
17:54:51 <dons> true that.
17:54:53 <ivanm> ...right
17:54:53 <lament> @vixen What's wrong with Haskell as a language to write a bot in?
17:54:54 <lambdabot> Ooh, functional programmers are so hot!
17:55:03 <ivanm> so what language has a better type system?
17:55:13 <ivanm> you want the type system to be turing complete as well, do you?
17:55:27 <roconnor> ivanm: agda and coq and epigram.
17:55:45 <mauke> how many bots are written in agda?
17:55:50 <roconnor> none
17:55:57 <roconnor> afaik
17:55:59 <newsham> ?vixen ever do it in the type system?
17:55:59 <lambdabot> isn't it obvious?
17:56:06 <camio> They must have more interesting things to code than bots.
17:56:07 * ivanm thought coq was just a proofing tool, not a lanugage in its own right...
17:56:12 <roconnor> but all the bots written in agda work properly.
17:56:17 <ivanm> lol
17:56:30 <newsham> roconnor: just because you have an expressive type system doesnt mean you have to use it.
17:56:37 <Jedai> I don't know much about agda, does it have IO ?
17:56:51 <mauke> none of the bots written in agda work properly
17:56:52 <newsham> agda has an FFI to haskell.
17:56:59 <performance> i didnt know that every time some one used my nick i would get a copy of the message !!
17:57:08 <roconnor> newsham: true.  I was going to clairfy that, but I didn't feel like writing such a long statement.
17:57:18 <mauke> performance: that's your IRC client
17:57:28 <mauke> there's probably an option to disable it somewhere
17:57:29 <performance> chatzilla
17:57:44 <newsham> you can be a lot more expressive about your bot's type in haskell
17:57:59 <newsham> conal's bots dance elegantly in the type system
17:58:08 <roconnor> newsham: ya, lambdabot probably needs more GADTs
17:58:35 * mauke is tempted to NOTICE the channel just to see what happens
17:58:42 <performance> performance: this is a test message
17:58:57 <performance> performance: this is a test message with copy turned on
17:59:06 <performance> dang i dont get it when i use it
17:59:11 <newsham> so, Network.Socket... do I need ot catch SIGPIPE?  is there a portable way to do this?
17:59:13 <mauke> performance: ha-ha
17:59:19 <newsham> is there a way to detect eof on Socket?
17:59:31 <performance> mauke: again please
17:59:34 <mauke> performance: ok
17:59:39 <mauke> newsham: try to read from it
17:59:48 <newsham> will it recv 0 bytes when eof?
17:59:59 <mauke> either that or it will throw an exception
18:00:02 <performance> did not get the ok. but this is bad, now i wont get those tht are intended to be important too!!
18:00:28 <isaacd> performance: maybe you need to change your nick; or could use match on "performance:"?
18:00:39 <kryptiskt> newsham, I found no other solution than separating the unixisms into a separate file (using cpp is not a better solution in my mind)
18:00:55 <Cale> The @seen plugin fails like that whenever lambdabot is restarted and I don't explicitly clear the state... (come to think of it, I should add something to my script that runs lambdabot to do that)
18:01:06 <newsham> *Utils> y <- recv s 5
18:01:06 <newsham> *** Exception: Network.Socket.recv: end of file (end of file)
18:01:26 <mauke> yay, IO exception
18:01:45 <Cale> The @seen plugin creates an empty file in State when the bot shuts down whose presence screws up the @seen plugin.
18:01:48 <newsham> hm... tis a shame.. would be nice for standard libs to hide platform specifics
18:01:59 <Shiruka> you could rewrite it in the mostest bestest programming language anyone will ever invent, lisp
18:02:08 * Shiruka ducks
18:02:17 <sebell> newsham: Well if you're using Socket it is because you don't want those to be hidden, no?
18:02:28 <Jedai> Shiruka: Ok but which Lisp ?
18:02:34 <newsham> sebell: not entirely, but point taken.
18:02:36 <roconnor> maybe the problem isn't that lambdabot is written in Haskell, rather that the operating system isn't written in Haskell.
18:02:42 <newsham> Socket is a portable API.
18:02:54 <Cale> Jedai: The platonic ideal Lisp which doesn't exist :)
18:03:07 <mauke> ANSI Common Losp
18:03:14 <kryptiskt> sebell, You don't want to catch SIG_PIPE just cause youre using sockets
18:03:52 <Cale> mauke: Just because of your typo, someone has to create a language called Losp now.
18:03:56 <mauke> newsham: fixed in 6.10
18:04:09 <Shiruka> Jedai: whichever implementation you pick, it's the wrong choice if you get any problems with it and should've picked another implementation
18:04:11 <newsham> mauke: the recv/exception behavior?
18:04:18 <mauke> SIGPIPE
18:04:33 <newsham> whats the solution in 6.10?  it auto-installs a SIGPIPE for unix platforms?
18:04:39 <mauke> yep
18:04:43 <newsham> thats cool.
18:04:52 <newsham> so, any idea on the EOF thing?  do i just need to deal with it as an exception?
18:04:59 <mauke> yes, as usual
18:05:17 <mauke> Cale: that wasn't a typo :-)
18:05:50 <newsham> which module defines that exception?
18:06:20 <Jedai> newsham: Its an IO exception
18:06:38 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html
18:06:39 <lambdabot> Title: System.IO.Error, http://tinyurl.com/5s9q7f
18:06:53 <roconnor> Is it even possible to catch an EOF exception?
18:06:53 <Cale> newsham: You can catch it with catch from Control.Exception
18:07:05 <roconnor> I think I tried it once, but there was not predicate for it in H98
18:07:40 <mauke> roconnor: isEOFError
18:07:51 <roconnor> @hoogle isEOFError
18:07:52 <lambdabot> System.IO.Error.isEOFError :: IOError -> Bool
18:07:52 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
18:07:56 <newsham> ok, i've used exceptions a little but not super comfortable with them yet.. if I want to catch the eof exception only, do I catch, and then rethrow everything thats not eof?
18:08:26 <roconnor> mauke: ah, must have been some other exception.
18:08:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3AcatchJust
18:08:30 <lambdabot> Title: Control.Exception, http://tinyurl.com/sqmlj
18:08:50 <roconnor> mauke: maybe it was network timeout exception.
18:08:54 <mmorrow> make graphs interactively with haskell cgi and graphviz's .dot syntax
18:08:55 <mmorrow> http://lunar.moonpatio.com/cgi-bin/graphedit.cgi
18:09:07 <Jedai> newsham: Well you can trap only IOError
18:09:26 <roconnor> Firefox can't find the server at lunar.moonpatio.com.
18:10:10 <newsham> jedai: how is that done?
18:10:11 <mauke> :t (ioErrors >>= guard . isEOFError)
18:10:23 <Jedai> newsham: You still have to rethrow the other kinds of IOError
18:10:53 <Cale> Well, if you provide catchJust with a sufficiently restrictive predicate, that'll do.
18:11:15 <Jedai> mauke's solution seems fine
18:11:21 <newsham> hmm.. catchJust.. interesting, danke.
18:11:26 <mauke> it doesn't typecheck
18:11:33 <newsham> i should read Control.Exception, looks like theres some good docs :)
18:11:38 <mauke> blargh
18:12:17 <mauke> :t (>>= guard . isEOFError) . ioErrors
18:12:31 <mauke> @bot
18:12:32 <lambdabot> :)
18:12:41 <Cale> :t (>>= guard . isEOFError) . ioErrors
18:12:47 <Cale> heh
18:12:50 <Cale> :t 1
18:12:50 <lambdabot> forall t. (Num t) => t
18:12:57 <EvilTerran> ?type (>>= guard . isEOFError) . ioErrors
18:12:58 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:13:04 <Cale> heh
18:13:06 <Jedai> (\e -> ioErrors e >>= guard . isEOFError)
18:13:10 <mauke> @type () ()
18:13:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:13:19 <Jedai> Let's be a little bit less pointless
18:14:24 <Jedai> better : (ioErrors >=> guard . isEOFError)
18:14:37 <mauke> @index (>=>)
18:14:37 <lambdabot> bzzt
18:14:45 <mauke> @hooge >=>
18:14:45 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:15:32 <mauke> guard . isEOFError <=< ioErrors
18:15:46 <EvilTerran> ?type guard . isEOFError <=< ioErrors
18:15:46 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:16:28 <Jedai> ?type (guard . isEOFError <=< ioErrors)
18:16:29 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:16:37 <Jedai> @type (guard . isEOFError <=< ioErrors)
18:16:38 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:16:52 <dolio> @type isEOFError
18:16:52 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:16:59 <Jedai> Damn ! Well it types correctly in my ghci
18:17:00 <Cale> @type fhduiafhd
18:17:01 <EvilTerran> ?hoogle isEOFError
18:17:01 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:17:01 <lambdabot> System.IO.Error.isEOFError :: IOError -> Bool
18:17:01 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
18:17:08 <Cale> It's not in scope
18:17:09 <EvilTerran> ?type System.IO.Error.isEOFError
18:17:13 <lambdabot> IOError -> Bool
18:17:16 <Jedai> Too bad
18:17:20 <mauke> :t doesn't report errors anymore
18:17:34 <EvilTerran> ?type guard . System.IO.Error.isEOFError <=< System.IO.Error.ioErrors
18:17:35 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:17:45 <EvilTerran> ?hoogle ioErrors
18:17:46 <lambdabot> Control.Exception.ioErrors :: Exception -> Maybe IOError
18:17:56 <Cale> Maybe something changed about the way ghci is printing them?
18:17:59 <EvilTerran> ?type guard . System.IO.Error.isEOFError <=< Control.Exception.ioErrors
18:18:00 <lambdabot> GHC.IOBase.Exception -> Maybe ()
18:18:04 <EvilTerran> that was a mission
18:18:07 <haskellator> :t lines
18:18:07 <lambdabot> String -> [String]
18:18:23 <mauke> senil = unlines
18:18:38 <haskellator> :t senil
18:19:20 <Cale> :t unlines
18:19:20 <lambdabot> [String] -> String
18:19:55 <haskellator> :t foo_nonExistantfunc
18:20:11 <haskellator> does nothing? cant it say it doesnt exist
18:23:23 <Apocalisp> if fmap is (a -> b) -> f a -> f b such that the functor laws hold, and comap is (b -> a) -> f a -> f b such that the cofunctor laws hold, what do you call (a -> a) -> f a -> f a, such that the cofunctor laws hold?
18:24:16 <twanvl> a specialized comap?
18:24:27 <mauke> (if (comap patient)
18:24:44 <newsham> ok, on the catching EOF error thing, is this reasonable?  is there a better way?  http://hpaste.org/9329
18:28:10 <Apocalisp> I have a parameterised type that can support the "specialized comap", but not comap. Just wondering if there's a name for such an impoverished "functor".
18:29:01 <mauke> .oO( Endor )
18:29:50 <Apocalisp> :)
18:29:56 <roconnor> mauke: :D
18:30:20 <BMeph> What's a bifunctormap look like? :)
18:31:01 <BMeph> Blasted Space bar - it's bloody big enough, so why doesn't it register?!? :P
18:31:15 <BMeph> s/bifunctormap/bifunctor map /
18:35:06 <haskellator> > head "asdf"
18:35:15 <mauke>  'a'
18:35:17 <haskellator> >head ""
18:35:21 <lambdabot>  thread killed
18:35:35 <mauke>  Error: head: empty list
18:35:50 <hackage> Uploaded to hackage: logfloat 0.8.1
18:36:08 <Apocalisp> ?hoogle (a -> b) -> (b -> a) -> f a -> f b
18:36:09 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
18:36:09 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
18:36:09 <lambdabot> Control.Parallel.Strategies.(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
18:36:42 <BMeph> See y'all on Monday...
18:36:44 <Apocalisp> ?hoogle (Functor f) => (a -> b) -> (b -> a) -> f a -> f b
18:36:44 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
18:36:44 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
18:36:44 <lambdabot> Control.Parallel.Strategies.(.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
18:36:46 <roconnor> crap, my pixels are dying
18:36:47 <Apocalisp> bah
18:37:05 <roconnor> oh nevermind, the dead pixels just fell off the screen
18:37:16 <mauke> :t const . fmap
18:37:17 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (a -> b1) -> b -> f a -> f b1
18:37:32 <haskellator> >head ""
18:37:48 <Apocalisp> What is that, a lens?
18:37:51 <haskellator> > head [1,2,3,4]
18:37:52 <lambdabot>  1
18:37:56 <haskellator> > head []
18:37:57 <lambdabot>  Exception: Prelude.head: empty list
18:38:13 <haskellator> how do i get it in a Maybe? Just 1 or Nothing?
18:38:23 <mauke> > listToMaybe []
18:38:24 <lambdabot>  Nothing
18:38:37 <roconnor> listToMaybe is awsome
18:38:57 <roconnor> I'm remembering to use it more.
18:39:27 <haskellator> > listToMaybe [1,2,3,4]
18:39:28 <lambdabot>  Just 1
18:40:02 <haskellator> is it guaranteed to give the head if it exists?
18:40:06 <mauke> yes
18:40:21 <mauke> @djinn a -> (b -> a) -> Maybe b -> a
18:40:21 <lambdabot> f a b c =
18:40:21 <lambdabot>     case c of
18:40:21 <lambdabot>     Nothing -> a
18:40:21 <lambdabot>     Just d -> b d
18:40:43 <mauke> @djinn a -> (b -> [b] -> a) -> [b] -> a
18:40:43 <lambdabot> f a _ _ = a
18:40:49 <mauke> :-|
18:41:51 <haskellator> OHT
18:43:12 <Apocalisp> ExpFunctor!
18:44:12 <theshadow> Alright I'm getting a compiling error with this and I don't understand why http://hpaste.org/9330
18:45:05 <rwbarton> theshadow: what is the type of factorial supposed to be?
18:45:24 <theshadow> an integer? if I understand your question correctly
18:45:30 <glguy> :t print
18:45:30 <lambdabot> forall a. (Show a) => a -> IO ()
18:45:36 <mauke> print does not return a number
18:45:38 <rwbarton> theshadow: Right, but print (show 1) is not an integer
18:45:43 <mauke> you can't multiply by print (show 1)
18:45:48 <theshadow> oooh right
18:45:52 <mauke> also, wtf
18:45:53 <glguy> (unless you have a Num instace for IO ())
18:46:03 <mauke> print (show 1) is print "1" is "\"1\""
18:46:10 <Shiruka> print returns an action.. but if what you want is debugging, you can use trace
18:46:13 <Shiruka> :t trace
18:46:50 <Shiruka> \bot doesn't like me :-<
18:47:26 * rwbarton thinks this tutorial is cruel to have people writing programs before teaching about type signatures
18:48:22 <SubOne> i agree
18:48:48 <SubOne> type signatures is the next chapter right after the excercise hes doing >_<
18:49:12 <rwbarton> Maybe it's intended to make you appreciate them more? :)
18:49:37 <SubOne> by making you bash head against wall until you get to them huh
18:59:28 <haskellator> i think im digging a hole deeper than i can climb out of
19:00:04 <dons> @tell byorgey quotable, pozorvlak , In my professional opinion, Eugenia Cheng is entirely made of win.
19:00:04 <lambdabot> Consider it noted.
19:00:25 <dons> category theorists are the heroes of our age.
19:00:27 * Shiruka gives haskellator a power shovel
19:00:40 <haskellator> to dig deepr?
19:00:51 <Shiruka> you might get out from the other side
19:01:03 <haskellator> :D
19:02:33 <dons> glguy: so thinking of writing about awesome union find this weekend?
19:02:45 <glguy> dons: I made some improvements
19:02:51 <glguy> generalized out of sT specifically
19:03:03 <glguy> and reversed the functional dependency on the Ref class
19:03:09 <glguy> so that the monad picks the refernce type
19:03:09 <dons> i also wonder about how well the final code will be, with all the genericity.
19:03:21 <dons> fixing to some specific array types might help. -- but worth checking the code.
19:03:36 <dons> but then again, i think strict monomorphic pairs are awesome.
19:03:40 <glguy> but it allows me to not mention ST in the union find algorithm
19:03:46 <dons> yeah, that's important.
19:03:49 <glguy> which I didn't want to leak
19:03:52 <dons> right.
19:04:20 <glguy> given: class C a b | a -> b, is there a way to write the following without GADT syntax? data T a where U :: C a b -> b -> T a
19:04:56 <glguy> oops
19:05:00 <glguy> given: class C a b | a -> b, is there a way to write the following without GADT syntax? data T a where U :: C a b => b -> T a
19:05:22 <dons> i'd also use type families instead of FDs, just cause they're hot.
19:05:46 <glguy> I use 6.8.2 still, so they are still a bit too rough
19:05:49 <dons> to have the constraint enforced, don't you require GADTs syntax?
19:06:11 <dolio> data T a = forall b. C a b => U b?
19:06:12 <glguy> I'm more concerned with referring to 'b' inside
19:06:39 <dolio> With ExistentialQuantification
19:07:15 <Shiruka> oh, eugenia cheng is that utubing category theorist
19:07:30 <glguy> dolio: perfect, thanks
19:07:41 * Shiruka watched a few of the lectures
19:08:21 <haskellator> :t genericLength
19:08:25 <lambdabot> forall b i. (Num i) => [b] -> i
19:08:42 <haskellator> > genericLength "asdf"
19:08:56 <haskellator> > genericLength ""
19:08:57 <lambdabot>  thread killed
19:08:59 <lambdabot>  0
19:10:08 <Shiruka> would be good to read a good book about category theory, then I'd so be able to scare people away at parties
19:10:18 <mmorrow> an example graph made interactively (ignore the ugly png graphics for now, i'm building new2er libs): http://tinyurl.com/5mc27a
19:10:35 <mmorrow> (the need for a tinyurl will become apparent if you goto the page)
19:11:40 <mmorrow> the base-page is http://lunar.moonpatio.com/cgi-bin/graphedit.cgi
19:12:06 <rwbarton> mmorrow: that hostname doesn't resolve
19:12:49 <mmorrow> hmm
19:13:17 <mmorrow> the base-page is http://207.58.166.174/cgi-bin/graphedit.cgi
19:13:40 <mmorrow> that should work
19:14:03 <mmorrow> i'll make a new tinyurl for the other one
19:14:24 <Shiruka> that one works
19:14:54 <mmorrow> here's a tinyurl to the example graph: http://tinyurl.com/5qsudk
19:15:28 <mmorrow> (the urls are long, but using GET you can bookmark/link to graphs)
19:15:31 <haskellator> split::String->String->(String,String)
19:15:32 <haskellator> split key (lhs:key:rhs) = (lhs,rhs)   -- Conflicting definitions for `key' ? cant i use the first arg in the second?
19:15:34 <haskellator> split _ _ = ("","")
19:17:02 <rwbarton> haskellator: Nope.  If you want to write such a pattern it would be "split key (lhs:key':rhs) | key == key' = ..." (but I think you'll find other problems with that)
19:17:45 <Shiruka> like key' being Char instead of String..
19:19:11 <Shiruka> more prologish pattern matching would be nice, though
19:20:25 <dons> hmm, is this a job for view patterns?
19:21:57 <dolio> Is split 'd' "abcdefg" supposed to be ("abc","efg")?
19:23:53 <Axman6> > split 'd' "abcdefg"
19:23:54 <lambdabot>  Couldn't match expected type `[Char] -> t'
19:24:05 <Axman6> yup...
19:24:28 <Axman6> @type split
19:24:39 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
19:24:54 <ez> @type List.split
19:24:55 <Axman6> ...
19:24:55 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:25:21 <haskellator> couldnt find a builting split.. or break ... there are a few other homebrews though
19:25:49 <Axman6> @type splitAt
19:25:52 <dolio> > break (=='d') "abcdefg"
19:25:53 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:25:55 <Shiruka> probably about as many as there are monad tutorials
19:26:08 <lambdabot>  thread killed
19:26:28 <haskellator> why does thread killed happen?
19:26:43 <dolio> Slow server, maybe.
19:26:48 <dolio> > break (=='d') "abcdefg"
19:26:49 <Shiruka> \bot's mind is going
19:26:49 <lambdabot>  ("abc","defg")
19:27:07 <haskellator> > break ( == 'd') ""
19:27:08 <lambdabot>  ("","")
19:27:11 <ez> @type span
19:27:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:27:14 <haskellator> > break ( == 'd') "asfffffffff"
19:27:20 <lambdabot>  ("asfffffffff","")
19:27:29 <haskellator> > break ( == 'd') "asffdddddd"
19:27:30 <lambdabot>  ("asff","dddddd")
19:27:40 <haskellator> great, this works for me
19:27:48 <Axman6> @src break
19:27:48 <lambdabot> break p =  span (not . p)
19:27:55 <yondalf> @hoogle a [a] -> [[a]]
19:27:55 <lambdabot> No matches, try a more general search
19:28:04 <yondalf> @hoogle a -> [a] -> [[a]]
19:28:05 <lambdabot> No matches, try a more general search
19:28:10 <haskellator> @src span
19:28:10 <lambdabot> Source not found. Are you on drugs?
19:28:46 <roconnor> @src lsd
19:28:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:28:54 <dolio> > span isAlpha "abcde2abcde"
19:28:56 <lambdabot>  ("abcde","2abcde")
19:50:33 <Shiruka> hmh, cabal remove would be nice
19:51:29 <Shiruka> somewhat unintuitive to do manually, removing lines from ~/.ghc/.../package.conf :-P
19:52:34 <dcoutts_> Shiruka: never edit package.conf by hand
19:52:42 <dcoutts_> use ghc-pkg unregister
19:53:35 <Shiruka> doh, I've only used cabal so didn't even know that command
19:54:03 <dcoutts_> Shiruka: cabal calls ghc-pkg to register and unregister packages
19:54:21 <dcoutts_> one day cabal-install will track what files it installed and so will be able to uninstall too
19:55:14 <dibblego> and when it does I'll stop using vmware for Haskell software
19:55:38 <Shiruka> vmware (O.o;
19:58:10 <slava> dibblego: you run all your hakell software in vmware?
19:58:20 <dibblego> a lot of it
19:58:35 <dibblego> a long time ago I got tired of the battle of uninstalling it
19:58:41 <dibblego> maybe it has improved
20:06:02 <dcoutts_> dibblego: or use distro packages
20:08:41 <haskellator> http://hpaste.org/9331  leaks memory..  how can i find where and why?  [ and it gives output that i dont expect it to ]
20:09:43 <jganetsk_> hey, having a compilation problem
20:09:43 <haskellator> http://hpaste.org/9331#a1
20:09:45 <jganetsk_> i'm a n00b
20:10:14 <jganetsk_> i get this kind of crap
20:10:14 <jganetsk_> http://rafb.net/p/FYA1v295.html
20:10:15 <lambdabot> Title: Nopaste - No description
20:10:46 <jganetsk_> i can't link right
20:11:05 <Shiruka> try --make
20:11:17 <jganetsk_> ah
20:11:19 <jganetsk_> thank you!
20:12:36 <SubOne> Show can't handle Nothing?
20:12:57 <TSC> > show Nothing
20:13:00 <dolio> haskellator: You print the whole file ("putStrLn $ stuff") and then you do stuff with it ("putStrLn $ (iniFile stuff)"). The first part reads the whole file into memory until portions of it are used in the second part.
20:13:01 <lambdabot>  "Nothing"
20:13:50 <dolio> Also, you don't need to hClose a handle that's had hGetContents called on it (in fact, you shouldn't use it at all after that).
20:13:57 <Twey> > read "Nothing" :: Maybe
20:13:57 <SubOne> odd
20:13:58 <lambdabot>      `Maybe' is not applied to enough type arguments
20:13:58 <lambdabot>     Expected kind `?', b...
20:14:09 <Twey> > read "Nothing" :: Maybe String
20:14:10 <lambdabot>  Nothing
20:14:20 <TSC> SubOne: what problem were you having?
20:14:36 <SubOne> sec...
20:14:40 <haskellator> dolio: why not hclose? and if i replace the iniFile function to just behave like id, it doesnt leak memory
20:15:14 <dolio> haskellator: hGetContents lazily reads in the input as needed, and then closes the handle automatically when it's done.
20:15:43 <jganetsk_> what do you use for haskell paste?+
20:15:48 <SubOne> http://hpaste.org/9332
20:15:57 <bd_> jganetsk_: hpaste.org
20:16:06 <jganetsk_> thanks
20:16:26 <slava> dolio: what if its never done?
20:17:01 <SubOne> "Ambiguous type variable `a' in the constraint" means nothing to me lol
20:17:16 <haskellator> hmm
20:17:25 <dolio> slava: In that case, it probably gets closed when the handle gets garbage collected.
20:17:27 <TSC> SubOne: I can see the problem, I think
20:17:35 <SubOne> please share
20:17:36 <Jedai> SubOne: That's because it don't know what's the fourth type variables argument of Tuple (and so of Maybe)
20:17:40 <dolio> If by that you mean you never read to the end of the string.
20:17:47 <Jedai> is
20:18:17 <slava> dolio: so if you open a bunch of files and read the first byte of each you can run out of fds?
20:18:21 <dolio> I'm not 100% sure, though.
20:18:38 <SubOne> right but `tuple4 (Tuple3 a b c) = Nothing ' should be making it return nothing should it not?
20:18:44 <Jedai> SubOne: There is not enough context for him to know that, so it don't know what the type he's trying to show, it don't even know if it's really an instance of Show
20:19:01 <TSC> SubOne: Yeah, but the return type is "Maybe a", and it can't determine the "a"
20:19:11 <dolio> Possibly.
20:19:20 <TSC> You can do, for example: print (tuple4 (Tuple3 4 5 6) :: Maybe ())
20:19:22 <haskellator> http://hpaste.org/9331#a2
20:19:30 <Jedai> SubOne: Yeah, but which Nothing ? A Nothing of type "Maybe d" d being undetermined in your program
20:20:15 <SubOne> im uber confused this tutorial is probably the worst ive ever read but im told its like one of the best
20:20:36 <Jedai> SubOne: In a real program, it is probable that your Tuple type will be produced by a function that knows what all types variables are and you won't have this problem
20:20:47 <Jedai> SubOne: What are you using ?
20:20:55 <SubOne> i had to look at the solutions to even get this far as they dont tell yu how to use the data types you create
20:20:58 <SubOne> yaht
20:21:27 <Jedai> Well I never used YAHT myself I think... I used the Gentle
20:21:37 <Jedai> Which is not very gentle
20:21:44 <SubOne> :: Maybe () worked
20:21:46 <SubOne> but why
20:21:59 <haskellator> dolio: why does it match everything as a comment?
20:22:05 <SubOne> i thought that Nothing would imply :: Maybe ()
20:22:19 <dolio> Hmm...
20:22:54 <TSC> Nothing can be a value of any Maybe type; Maybe Int, Maybe Double, Maybe (), Maybe [Int], etc.
20:23:00 <Jedai> SubOne: No, of course not, your function tuple4 sometimes return Just d which is obviously of type "Maybe d", so the Nothing is of type "Maybe d" too
20:23:13 <SubOne> ic
20:23:15 <dolio> haskellator: 'isComment (comment_char:_) = True' matches any non-empty string, defining "comment_char" to be the first character in the string.
20:23:36 <SubOne> but why doesnt it error unless i used the call?
20:23:48 <dolio> Also, 'b == True' is equivalent to 'b'.
20:23:50 <haskellator> how do i make it use teh predefined defn ?
20:23:53 <Jedai> SubOne: But this "d" (fourth parameter of the type constructor Tuple) isn't determined by anything in your program, so the compiler can't type your program
20:24:13 <SubOne> im so confused
20:24:30 <Jedai> SubOne: error ? unless you used the "call" ?
20:24:33 <dolio> haskellator: You want either "isComment ('#':_) = True" or "isComment (c:_) | c == comment_char = True".
20:24:57 <SubOne> Jedai: yeah i dont get the compile error if i use tuple3 in the print
20:25:00 <rwbarton> SubOne: What is the type of Tuple3 4 5 6?
20:25:14 <SubOne> Tuple?
20:25:30 <rwbarton> Tuple has parameters a, b, c, d.
20:25:41 <SubOne> right... is that wrong?
20:25:51 <haskellator> thanks dolio, this worked..
20:25:54 <Jedai> SubOne: If you use tuple3, the return type is determined (it's Maybe Integer since 6 is an Integer )
20:25:56 <SubOne> in their solution it has a b c d e, is that correct?
20:26:12 <rwbarton> Well, Tuple isn't itself a type; only things like Tuple Integer Integer Integer Integer are types
20:26:19 <Jedai> SubOne: What solution, what is the question ?
20:26:42 <SubOne> Jedai: its at the top of my file
20:26:43 <SubOne> http://hpaste.org/9332
20:27:11 <Jedai> SubOne: Ok, I saw it, your solution is perfect
20:27:23 <SubOne> so wtf is the point of Tuple if only Tuple1, Tuple2,Tuple3,Tuple4 are real types?
20:27:47 <Jedai> SubOne: Tuple1 is not a type, it's a data constructor
20:27:57 <SubOne> I think i'm stuck thinking polymorphism here but that doesnt seem to work in haskell?
20:28:16 <Jedai> SubOne: it construct a value of type "Tuple a b c d" (a b c and d being determined types)
20:28:35 <Jedai> SubOne: Haskell polymorphism is one of the better
20:28:45 <SubOne> then im really confused
20:29:19 <rwbarton> SubOne: perhaps it's better to think about a more realistic example, like Maybe
20:29:24 <rwbarton> data Maybe a = Nothing | Just a
20:29:28 <haskellator> isSectionHdr ('[':_:']':_) = True should match [sec1] and [sec2] #onecomreser  right? but it doesnt!!
20:29:30 <SubOne> the damn tut didnt explain how to pass a udt into a function or how to determin what values are in it or anything, thats why i was forced to look at their solution
20:29:39 <Jedai> SubOne: Look the why your program isn't working is just because it's a toy program that won't occur in real life and which don't contain enough information for the compiler to determine some types
20:29:52 <dmwit> SubOne: Let's back up. =)
20:30:00 <SubOne> ok
20:30:08 <dmwit> SubOne: There are two separate things being defined in your "data" line.
20:30:11 <Jedai> SubOne: What's an "udt" ?
20:30:18 <SubOne> user defined type
20:30:25 <dmwit> SubOne: "Tuple a b c d" is defining a new *type*.
20:30:27 <yondalf> SubOne, i see what's the problem, but i'll wait for dmwit to explain first
20:30:33 <SubOne> ok
20:30:38 <SubOne> i got that part
20:30:42 <dolio> haskellator: Strings are made of single characters prepended to Strings. The first _ in your pattern does not match arbitrary strings.
20:30:45 <SubOne> the others are consturctors
20:30:51 <dmwit> If you've done generics/templates, then you could think of "a,b,c,d" as template typenames or generic typenames.
20:31:08 <dmwit> So each of the lower-case letters also name types.
20:31:13 <haskellator> hmm maybe i have to break it into two conditions
20:31:19 <dmwit> The other thing you're defining are *functions*.
20:31:36 <dmwit> The function "Tuple1" takes an 'a' type and returns a 'Tuple a b c d' type.
20:31:42 <dmwit> Are you with me so far?
20:32:03 <SubOne> yes, and i notcied i couldnt just use a single overloaded function
20:32:26 <dmwit> (Likewise, "Tuple4" is a function that takes four arguments -- one of each type -- and returns a value of type "Tuple a b c d".)
20:32:43 <dmwit> Okay, if you get that, then think about this:
20:33:11 <dmwit> Given that you're calling "Tuple1" with a value of type "Int", we know that the 'a' in "Tuple a b c d" is 'Int'.
20:33:18 <dmwit> But what are 'b', 'c', and 'd'?
20:33:19 <SubOne> right
20:33:22 <SubOne> um
20:33:25 <SubOne> ()?
20:33:30 <dmwit> No, it's a trick question.
20:33:33 <SubOne> lol
20:33:35 <dmwit> They aren't decided yet.
20:33:45 <SubOne> ok
20:33:59 <dmwit> This is essentially what the error is telling you: it doesn't know what the 'b', 'c', and 'd' are -- they could be any valid type.
20:34:14 <dmwit> So:
20:34:24 <yondalf> SubOne, http://codepad.org/VoOAZw9B
20:34:35 <dmwit> when you call (tuple4 (Tuple3 4 5 6)), you have bound the 'a', 'b', and 'c' in "Tuple a b c d".
20:34:39 <SubOne> well in the case of my error it didnt know what d was right
20:34:42 <yondalf> SubOne, but you should listen to dmwit's explanation too :-)
20:34:56 <dmwit> But 'd' is not bound to any type, and the "tuple4" function is asking for a value of exactly that type!
20:35:11 <Jedai> yondalf: You're wrong, SubOne solution is right
20:35:15 <dmwit> (Well, not exactly... it's actually asking for a "Maybe d".  But the problem is the same.)
20:35:26 <SubOne> ok so i think i get it
20:35:31 <SubOne> lemme see if i get this...
20:35:58 <dmwit> yondalf: Your solution is not a tuple. =/
20:36:05 <bwr> hehe... f n = foldr (.) (*1) [(*x)|x<-[2..n]] 1
20:36:07 <dmwit> yondalf: It's too restrictive on the types.
20:36:16 <SubOne> because i didnt specify that tuple4 returned Maybe explicitly it cast it to Maybe d at compile time because of the last overloaded function of tupal4?
20:36:19 <yondalf> Jedai, SubOne's solution has a compile error, and the problem doesn't say that all the types have to be same...and besides, for such an introductory level i don't think they know how to handle "unknown" types
20:36:25 <dmwit> bwr: Why not write that as product [2..n]?
20:36:33 <bwr> dmwit: because i am playing around
20:36:37 <dmwit> okay =)
20:36:40 <SubOne> yondalf: yes but by definition of tupal it implies it
20:36:44 <Jedai> yondalf: A tuple by definition allows multiple types
20:36:58 <SubOne> dmwit: so was i correct?
20:37:07 <dmwit> SubOne: Essentially, yes.  It results in a "Maybe d", but since it doesn't know 'd', it doesn't know which version of "show" to use.
20:37:22 <dmwit> SubOne: Er, wait, no, what you said is dangerously wrong.
20:37:29 <SubOne> o.O
20:37:29 <dmwit> SubOne: There is no casting involved here.
20:37:45 <SubOne> well...
20:37:50 <dmwit> SubOne: It didn't "cast" the result to "Maybe d"... the result *is* a "Maybe d".
20:38:00 <Jedai> All of that is happening at compile time, there is no cast
20:38:05 <dmwit> Unfortunately, it can be "Maybe d"... for all possible 'd'!
20:38:12 <SubOne> what i meant was that the compiler is explicitly setting the return type of all 4 functions based on the return type of the last one
20:38:25 <dmwit> not... really
20:38:34 <dmwit> wait
20:38:38 <rwbarton> do you mean all four lines of tuple4?
20:38:38 <dmwit> explain what you mean a bit more
20:38:39 <SubOne> well then wtf is the point of Nothing, why not Nothing d?
20:39:08 <dmwit> If you mean, "based on the return type of the last line of tuple4"... then yes.  (sorry)
20:39:13 <SubOne> yeah
20:39:16 <dmwit> ok =)
20:39:29 <dmwit> Good, maybe things are starting to make sense. =P
20:39:34 <SubOne> ok but my question is why are the different? should a Maybe be a Maybe?
20:39:38 <dmwit> SubOne: Now, the only (possibly) confusing part:
20:39:55 <dmwit> SubOne: The compiler isn't smart enough to know that all "Nothing" values print as "Nothing".
20:40:05 <SubOne> lol that sucks
20:40:11 <dmwit> The reason is that it doesn't have enough type information.
20:40:23 <haskellator> if i have data sth = List Int , and a funciton func::String->[Int]  how do i convert teh return value to a sth ?
20:40:47 <dmwit> SubOne: Nothing can be any kind of "Maybe", and different kinds of "Maybe" can have different "show" functions.  (polymorphism)
20:40:49 <haskellator> so that i can have bunc::String->Sth
20:40:55 <Jedai> SubOne: In a normal case, you would have a function that would return a "Tuple Int Int Float Double" for example, which sometimes returns a Tuple1 and sometimes a Tuple4, but the compiler would have enough information, you have a problem because this is a toy program and you have a random Tuple3 literal
20:41:11 <dmwit> SubOne: So you have to give it a slight hint about which version of "show" you want to use. =)
20:41:34 <dmwit> Also, yes, your case is not so common as it might seem at first. =)
20:42:08 <SubOne> dmwit: this is as confusing as why i cant just say Tuple  4 5 6 and it pick the overloaded constructor for me
20:42:08 <dmwit> haskellator: Dunno what List is, but how about writing a "convert :: [a] -> List a"?
20:42:21 <haskellator> Data.List
20:42:31 <dmwit> haskellator: ...there is no List type in there.
20:42:34 <dmwit> only [a]
20:42:50 <dmwit> SubOne: Well...
20:42:53 <haskellator> oh so it just treated that as my custom cosntructor!!
20:42:53 <Jedai> SubOne: because Haskell doesn't overload on length of argument list (it doesn't make much sense actually)
20:43:01 <dmwit> SubOne: Let's see how to explain this.
20:43:28 <dmwit> ?src Either
20:43:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:43:38 <dmwit> SubOne: data Either a b = Left a | Right b
20:43:54 <dmwit> SubOne: Now, would "Either 3" be a "Left 3" or a "Right 3" in your language?
20:43:59 <dmwit> ;-)
20:44:04 <slava> a superposition of the two
20:44:20 <Jedai> slava: Don't confuse SubOne... ^^
20:44:26 <SubOne> too late
20:44:43 <haskellator> great!! now i can recognize all the components of an ini file :D but i still have one major problem
20:44:50 <dmwit> SubOne: Just because it's easy to tell your constructors apart in the Tuple data type doesn't mean all data types have easily-recognizable constructors.
20:46:15 <SubOne> and yet... i can be more confused :D
20:46:34 <dmwit> SubOne: sorry, maybe that was too fast =P
20:46:41 <chrisdone> hey what happened to the memcached project on hackage?
20:46:52 <yondalf> :t 1
20:46:53 <lambdabot> forall t. (Num t) => t
20:47:12 <slava> how would you create a list of Num instances in haskell?
20:47:23 <dmwit> slava: google for existential types
20:47:30 <SubOne> o.O
20:47:48 <dmwit> slava: (Assuming you don't just want "Num a => [a]".)
20:47:49 <slava> dmwit: that's what i thought, but would it require code to be written to wrap each type class?
20:47:57 <Jedai> SubOne: The point is that udt are more rich than this case with Tuple and there's no easy way to get an unique constructor with overloaded meanings for every one of them
20:48:02 <dmwit> slava: probably
20:48:07 <dmwit> slava: See also Data.Dynamic
20:49:01 <dmwit> SubOne: I've got to run, but keep asking questions and people here will keep confusing you. ;-)
20:49:08 <SubOne> i bet
20:49:15 <SubOne> i think im done for tonight
20:49:20 <Jedai> We'll try our best ;-)
20:49:29 <SubOne> this is supposed to be just for fun and im getting a headache
20:49:45 <atp> subone come back tomorrow, it'll be easier then
20:49:59 <SubOne> atp: I can only hope your right :p
20:50:01 <SubOne> night
20:52:18 <bwr> hehe, i have made the most pointless function ever :D
20:52:48 <Jedai> bwr: Really ?
20:52:59 <bwr> no, probably not... but it is pretty useless
20:53:13 <bwr> Prelude> let f n = foldr (.) (*1) [*x|x<-[2..n]] 1
20:53:13 <bwr> Prelude> let g = foldr (.) (f) [(f.f)|x<-[1..10]]
20:53:25 <bwr> g 1 = 1 and g 2 = 2 but it seems any other value causes stack overflow
20:54:05 <rwbarton> 3!!!!!!!!!!!!!!!!!!!!! is pretty big
20:54:08 <bwr> it seems resonable... it just ends up with a really ridiculous function
20:54:09 <bwr> yea
20:55:05 <Jedai> (!! 21) . iterate fact
20:55:43 <bwr> i am just playing around with lists that generate functions and then somehow combine those into another function
20:56:00 <Jedai> let fact n = product [1..n] ; g = (!! 21) . iterate fact in g 3
20:56:09 <chrisdone> nevermind, I found a repo. of memcached
20:56:11 <Jedai> > let fact n = product [1..n] ; g = (!! 21) . iterate fact in g 3
20:56:17 <lambdabot>  Exception: Time limit exceeded
20:56:30 <chrisdone> I want to use it to save server state between fastcgi restarts
21:00:29 <Jedai> Well this version don't seem to overflow the stack but it seems to take forever instead... :-D
21:00:37 <bwr> haha
21:01:07 <SubOne> cant get it out of my head >_<
21:01:13 <SubOne> :t Nothing
21:01:13 <lambdabot> forall a. Maybe a
21:01:27 <SubOne> :t Nothing a
21:01:52 <rwbarton> That means "apply the function Nothing to the value a"
21:02:01 <Jedai> SubOne: Nothing a don't exist, Nothing is a function with zero arguments
21:02:17 <rwbarton> and Nothing isn't a function.  For some reason lambdabot isn't answering :t queries when there's no type
21:02:21 <rwbarton> @type Nothing a
21:02:21 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:02:24 <Jedai> (or a polymorphic constant, whichever formulation you prefer)
21:02:51 <Quylui> i am high
21:03:15 <SubOne> why does it say 'forall a. Maybe a' if Nothing a isnt valid?
21:03:29 <Jedai> SubOne: That was the type of "Nothing"
21:03:34 <SubOne> right
21:03:35 <TSC> It's saying that Nothing's type is "Maybe a", for any a
21:03:45 <SubOne> so whats this Maybe ()?
21:03:47 <rwbarton> SubOne: Maybe you're looking for something like
21:03:54 <rwbarton> @type Nothing :: Maybe Int
21:03:55 <lambdabot> Maybe Int
21:03:59 <TSC> Maybe () is one possible type of Nothing
21:04:12 <Jedai> SubOne: Maybe () is a type whose value are (Just ()) and Nothing
21:04:26 <yondalf> hmm...okay let me try
21:04:40 <Jedai> the Nothing of type Maybe () which you can obtain with (Nothing :: Maybe ())
21:04:46 <dons> gwern: http://www.dinkla.net/fp/cglib.html
21:04:47 <lambdabot> Title: Library for Geometric Algorithms in Haskell
21:04:59 <yondalf> the type of (Tuple3 4 5 6) is Tuple Num Num Num <unknown>
21:05:28 <dons> Num a => Tuple3 a a a ?
21:05:30 <yondalf> the type of (tuple4 (Tuple3 4 5 6)) is Maybe <unknown>, since it takes Maybe <the fourth type>
21:05:36 <Jedai> SubOne: But most of the time you don't need to write (Nothing :: Maybe ()) explicitly because the context will force this Nothing to have the right type
21:05:46 <int-e> (Num a, Num b, Num c) => Tuple3 a b c?
21:05:59 <Shiruka> hm.. is pcre-light better than regex-pcre?
21:06:09 * Shiruka hadn't noticed that lib before now..
21:06:13 <yondalf> dons, init-e: SubOne brought up a problem where Tuple3 is a constructor of Tuple a b c d
21:06:16 <Jedai> dons: (We're dealing with "data Tuple a b c d = Tuple1 a | ... | Tuple4"
21:06:51 <SubOne> brb gotta make dinner
21:07:11 <yondalf> print requires an argument which type is an instance of Show, but the compiler can't determine that this is true because the argument is of type Maybe <unknown> and the compiler doesn't know what <unknown> is
21:07:46 <dons> Shiruka: i think its better.
21:07:53 <dons> Shiruka: its smaller, and much less complicated.
21:08:07 <dons> it doesn't do perl-like overloading of return types, for example.
21:10:40 <Shiruka> the correctness "guarantees" of text.regex always did make me a bit nervous.. :-/
21:10:55 * hgolden is away: going for a walk. Back in about 1 hour. Will respond then.
21:11:35 <chrisdone> hgolden: public away messags are an IRC faux pas, imho
21:12:38 <hgolden> chrisdone: Sorry. Was in conversation on #gentoo-haskell. I don't mean to pollute #haskell.
21:12:58 <chrisdone> hgolden: no problem
21:29:55 <SubOne> so `print (tuple3 (Tuple3 4 5 6) :: Maybe ())` returns a compiler error and `print (tuple4 (Tuple3 4 5 6) :: Maybe ())` compiles... so how do i check if the Maybe returned is Nothing?
21:31:05 <dibblego> what is the type of tuple3 and tuple4?
21:31:22 <dibblego> Maybe () is better written as Bool
21:31:48 <SubOne> i dont want maybe () apparently
21:31:49 <rwbarton> dibblego: this is one of the yaht exercises
21:31:53 <dibblego> ah
21:32:34 <rwbarton> SubOne: What should the value of tuple3 (Tuple3 4 5 6) be?
21:32:54 <SubOne> 6
21:33:19 <rwbarton> SubOne: not quite...
21:33:35 <SubOne> what?
21:34:35 <rwbarton> look at your definition of tuple3 again
21:35:10 <SubOne> Just 6?
21:35:13 <rwbarton> Yep.
21:35:20 <rwbarton> :t Just 6
21:35:21 <lambdabot> forall t. (Num t) => Maybe t
21:35:23 <Trinithis> Off topic: I'm downloading Ubuntu. Should I get the 32 or 64 bit version? (I have enough RAM)
21:35:44 <rwbarton> You can't make Just 6 into a Maybe ().  That's why the first thing you gave didn't compile.
21:35:48 <SubOne> Trinithis: are you running on a 64bit box?
21:35:50 <hackage> Uploaded to hackage: permutation 0.1
21:35:50 <hackage> Uploaded to hackage: ieee 0.3
21:36:00 <rwbarton> If you want to check whether something is a Nothing, there is a function isNothing
21:36:00 <Trinithis> yes
21:36:04 <rwbarton> @type isNothing
21:36:05 <lambdabot> forall a. Maybe a -> Bool
21:36:06 <rwbarton> @src isNothing
21:36:07 <lambdabot> isNothing Nothing = True
21:36:07 <lambdabot> isNothing _       = False
21:36:31 <SubOne> rwbarton: i understand that which is why i asked how do i check for Nothing
21:36:40 <SubOne> isNothing ok ty
21:37:05 <SubOne> Trinithis: dl the 64bit version then
21:37:11 <Trinithis> k
21:37:33 <SubOne> Trinithis: unless there is some specific reason why you'd want to downgrade
21:43:24 <atp> subone: i thought you were going to bed? :)
21:43:24 <SubOne> not in scope isNothing...
21:43:39 <rwbarton> SubOne: import Data.Maybe
21:43:52 <hansfbaier> @src concatMap
21:43:52 <lambdabot> concatMap f = foldr ((++) . f) []
21:44:01 <rwbarton> SubOne: (or you could write it yourself, using the source shown above)
21:44:04 <hansfbaier> @src fix
21:44:05 <lambdabot> fix f = let x = f x in x
21:44:14 <SubOne> atp: not to bed, just done with haskell... i cant give in that easy or it will just roll around in my head stabbing my brain with that pointy bit thats sticking out there that i cant understand
21:44:21 <SubOne> atp: if you follow...
21:44:24 <atp> sure
21:44:34 <haskellator> :T show
21:44:38 <haskellator> :t show
21:44:40 <hansfbaier> @src mfix
21:44:41 <lambdabot> Source not found. :(
21:44:42 <atp> being confused by something can't be allowed to persist for long
21:44:43 <lambdabot> forall a. (Show a) => a -> String
21:44:50 <SubOne> rwbarton: is there any advantage to writing it myself?
21:45:08 <dmwit> I'm back!
21:45:09 <rwbarton> SubOne: Nope, just so you see that it isn't magical :)
21:45:11 <dibblego> SubOne, just a potential learning advantage (in reality, you'd use the library function)
21:45:13 <dmwit> SubOne, you're still here!
21:45:32 <SubOne> dmwit: yes... i gave up on giving up
21:45:33 <dmwit> SubOne: You must be up to reverse zygohylomorphisms and their monadic underpinnings by now...
21:45:40 <atp> haha
21:45:43 <SubOne> o.O
21:45:59 <atp> it's zygohistomorphisms, dmwit
21:46:01 <atp> hehe
21:46:17 <SubOne> darn now it outputs Just 6 lol
21:46:17 <atp> specifically zygohistomorphic preproparamorphisms
21:46:24 <SubOne> er rather "Just 6"
21:46:27 <haskellator> recursion by any name is still recursion :D
21:46:41 <atp> jmp by any other name is still jmp
21:46:44 <SubOne> how do i get the 6 out of the Just 6?
21:46:54 <dmwit> With pattern matching!
21:46:55 <haskellator> err..
21:47:01 <haskellator> recursion by any name is still a rose :D
21:47:12 <dmwit> > fromMaybe 0 (Just 6)
21:47:16 <lambdabot>  6
21:47:17 <dmwit> > fromMaybe 0 (Nothing)
21:47:19 <lambdabot>  0
21:47:34 <atp> SubOne: let m = Just 6 ; Just x = m in x
21:47:38 <dmwit> All of #haskell: don't you dare mention any partial functions.
21:47:38 <atp> hehe
21:47:46 <haskellator> note in small print :  may contain thorns, made in a facility that also manufactures monads and control structures
21:47:48 <Trinithiss> Anyone know of a firefox extenstion that remembers broken downloads
21:47:58 <dmwit> Trinithiss: wget ;-)
21:48:05 <haskellator> downthemall
21:48:20 <Trinithiss> thx
21:48:37 <SubOne> the download manager saves them until you clear the list
21:48:40 <atp> > let f (Just x) = x in f (Just 6)
21:48:41 <lambdabot>  6
21:48:51 <atp> let f (Just x) = x in f Nothing
21:48:53 <Axman6> speaking of control, check this out http://www.youtube.com/watch?v=p958woXcYcI&feature=related
21:48:53 <lambdabot> Title: YouTube - Derren Brown The Heist
21:48:59 <atp> > let f (Just x) = x in f Nothing
21:49:00 <Axman6> it's crazy :|
21:49:00 <lambdabot>   Non-exhaustive patterns in function f
21:49:46 <dmwit> Axman6: It's also quite a bit of camera magic.
21:49:47 <atp> SubOne: also, if you have a value in a Just, and you don't mind leaving it in the Just, you can use fmap
21:50:06 <SubOne> atp: all i want to do is get the Num value
21:50:10 <atp> > negate `fmap` (Just 6)
21:50:12 <lambdabot>  Just (-6)
21:50:13 <Axman6> dmwit: in what way?
21:50:21 <atp> > (*2) `fmap` (Just 6)
21:50:22 <lambdabot>  Just 12
21:50:23 <dmwit> Axman6: Derren Brown is an accomplished magician.  If at any moment you believe that what you are seeing is what you think you are seeing, you're being naive.
21:50:35 <dmwit> Axman6: I haven't seen this particular video before, so I can't comment on it.
21:50:40 <Axman6> heh, fair enough
21:50:42 <dmwit> But very little of what he does is "real".
21:50:46 <atp> SubOne: well, just remember that a Maybe value can also be Nothing
21:50:52 <atp> SubOne: which means you have to handle that case.
21:51:02 <SubOne> right i already did
21:51:13 <atp> how did you handle that case?
21:51:17 <jeffz> dmwit: though he admins he doesn't do magic, he does illusions
21:51:20 <SubOne> main =  let x = tuple3 (Tuple3 4 5 6) in    if isNothing x then      putStrLn "Nothing"    else      print x
21:51:29 <dmwit> jeffz: That's stupid.
21:51:33 <atp> i think you're probably better off doing it this way
21:51:40 <dmwit> oh
21:51:44 * dmwit shrugs
21:51:53 <dmwit> jeffz: Okay, great, so he's honest about lying. =P
21:52:11 <atp> > let m = Just 6 in case m of Just x -> show x ; Nothing -> "Nothing"
21:52:13 <lambdabot>  "6"
21:52:26 <atp> see, you can get rid of the isNothing
21:52:34 <atp> if you absolutely want to use isNothing, then you can use fromJust
21:52:40 <atp> > fromJust (Just 6)
21:52:41 <lambdabot>  6
21:52:48 <atp> however, that doesn't check for Nothing
21:52:53 <atp> > fromJust (Nothing)
21:52:54 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:52:54 <dibblego> which fails in the event of Nothing
21:53:00 <atp> so in general you should avoid fromJust
21:53:20 <SubOne> why is a case better?
21:53:22 <atp> it's generally considered better practice to use a case statement so that you explicitly handle each case
21:53:42 <atp> it forces you to remember that it might be Nothing and not Just
21:53:48 <atp> because while you're be vigilant right here,
21:53:54 <atp> soon enough you'll forget to use isNothing
21:54:02 <atp> but it's a style thing, you can do it whichever way you want
21:54:05 <dmwit> SubOne: http://hpaste.org/9334 Use pattern matching, it's the nicest way for beginners.
21:54:22 <SubOne> um... i fail to see how a case makes it easier to remember than an if statement
21:54:23 <atp> SubOne: case basically is just inline pattern matching
21:54:35 <SubOne> main =  let x = tuple3 (Tuple3 4 5 6) in    if isNothing x then      putStrLn "Nothing"    else      print (fromJust x)
21:54:36 <dmwit> SubOne: Not easier to remember.  Just easier to write.
21:54:39 <atp> SubOne: like i said, it's a style thing, it's up to you
21:54:47 <atp> SubOne: you can do it however you feel comfortable.
21:54:51 <dmwit> SubOne: (Also, easier to check mechanically, use -Wall to see when you missed a possible pattern.)
21:55:14 <rwbarton> SubOne: case is more general than if; it includes pattern matching which lets you pull the 6 out of Just 6.
21:55:22 <SubOne> a case is easier to write than an if?
21:55:32 <dmwit> Try it for a while. ;-)
21:55:36 <atp> SubOne: if is syntactic sugar for case
21:55:40 <atp> :)
21:55:45 <SubOne> so
21:55:46 <Jedai> SubOne: Well, when you'll get four or more different possibility, you'll understand why using "case" is nicer than "if"
21:55:53 <atp> unlike most languages, there's nothing special about True and False in haskell
21:56:10 <SubOne> well yeah obviously but this isnt its only chekcing for Nothing otherwise do this
21:56:15 * dmwit shuts up for a bit; two teachers is more than enough
21:56:23 <SubOne> i'm well versed in many other languages...
21:56:26 <atp> SubOne: don't take this the wrong way, no one is telling you you have to use case
21:56:35 <atp> SubOne: you can use if if you want
21:56:47 <Jedai> SubOne: Haskell isn't like many other languages... ;-)
21:57:19 <SubOne> obviously, but i still see no apparent reason to use case rather than if in this case
21:57:25 <atp> ok
21:57:34 <haskellator> http://hpaste.org/9335   what am i doing wrong with the show ?
21:57:35 <SubOne> unless your telling me that if is a significant performance hit or soemthing
21:57:35 <Jedai> SubOne: It's more efficient
21:57:48 <dmwit> There is no way it's significant.
21:57:49 <atp> SubOne: no, no preformance difference really
21:57:54 <Jedai> SubOne: Not particularly significant
21:58:00 <atp> SubOne: it's not an issue
21:58:01 <Jedai> atp: There is one
21:58:03 <SubOne> ok
21:58:10 <atp> Jedai: not really
21:58:16 <dmwit> There's a difference, but there are much more important optimizations to make.
21:58:30 <atp> i don't think it's worth worrying about that anyway
21:58:36 <atp> not at this juncture
21:58:38 <SubOne> can't say ive ever used a case in which there were no more than 2 cases, unless of course it was left open for more additions later
21:58:39 <dmwit> haskellator: You need more parens.
21:58:54 <Jedai> atp: You have in fact at least a double case with the "if" against a single case (but sure it's not important)
21:59:08 <atp> SubOne: well, the thing is this
21:59:09 <dmwit> haskellator: show (CIniEntry_Comment (CComment str)) = ...
21:59:19 <dmwit> haskellator: Also, show returns a String, not a tuple.
21:59:25 <atp> SubOne: isNothing is defined basically like this: isNothing Nothing = True ; isNothing _ = False
21:59:30 <haskellator> yeah i just tried it that worked.
21:59:32 <Jedai> SubOne: it's prettier, most haskeller don't use if for this kind of thing
21:59:49 <atp> SubOne: which is actually the same thing as isNothing x = case x of Nothing -> True ; _ -> False
22:00:18 <atp> SubOne: then if cond then foo else bar is just sugar for case cond of True -> foo ; False -> bar
22:00:27 <atp> similarly, fromJust is just
22:00:31 <atp> fromJust (Just x) = x
22:00:38 <atp> which is the same
22:00:38 <haskellator> dmwit, while you are there,  i dont think the data  defns are right,..
22:00:39 <atp> as
22:00:44 <haskellator> could you please comment on that..
22:00:49 <atp> fromJust x = case x of (Just y) -> y
22:00:50 <dmwit> fromJust Nothing = error "FUCK"
22:00:54 <SubOne> i think     if isNothing x then
22:00:54 <SubOne>       putStrLn "Nothing"
22:00:54 <SubOne>     else    print (fromJust x)`
22:01:01 <SubOne> looks much clearer than a case
22:01:06 <Jedai> SubOne: The "case" deconstruct the value at the same type as it chose the case, while with the "if" you'll need some deconstructors (that don't exists for every datatype)...
22:01:11 <atp> SubOne: so what you're really doing is introducing three cases to do the job of just one
22:01:44 <Jedai> case x of Nothing -> putStrLn "Nothing"
22:01:47 <SubOne> atp: isnt that the job of the compiler to optimize that out?
22:01:48 <haskellator> my basic plan is to represnt an ini file as a list of (name. value)  pairs, and then hopefully a Data.Map to support nested sections and retain comments when dumping a modified inifile back to file
22:01:52 <dmwit> haskellator: Why, what's wrong with them?
22:01:54 <Jedai> Just x -> print x
22:02:15 <dmwit> haskellator: Oh, s/SectionHeader/SectionHdr/
22:02:17 <atp> SubOne: and it will, but the thing is, functions like isNothing and fromJust are relatively uncommon for most datatypes
22:02:21 <haskellator> dmwit:  there are two seperate constructors for essentially the same line
22:02:29 <haskellator> Entry and Comment
22:02:33 <SubOne> ic
22:02:34 <Jedai> case x of Nothing -> putStrLn "Nothing"
22:02:34 <Jedai>                Just x -> print x
22:02:39 <atp> SubOne: those mostly exist to make pointfree code easier to write
22:02:49 <dmwit> haskellator: Oh, well, I know nothing about the .ini format, if that's what you're asking about.
22:02:50 <atp> SubOne: the case system generalizes easily to any datatype you run into
22:02:55 <Jedai> I don't see how the if is clearer (at all)
22:03:21 <atp> Jedai: it's clearer to him because in most programming languages, you use getters and setters on datatypes
22:03:30 <dmwit> SubOne: Why not use the catamorphism?
22:03:31 <dmwit> :t maybe
22:03:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:03:38 <Twey> dmwit: [SectionTitle]
22:03:39 <dmwit> You could write your thing as:
22:03:47 <Twey> dmwit: variable = value ;comment
22:04:02 <haskellator> dmwit: http://hpaste.org/9335#a1
22:04:02 <Jedai> atp: Yeah but if he continue trying to do that, he'll miss completely a good part of the Haskell fun
22:04:05 <haskellator> has sample data
22:04:05 <dmwit> main = maybe (putStrLn "Nothing") print (...)
22:04:11 <atp> > maybe (putStrLn "Nothing") print
22:04:13 <lambdabot>  <Maybe () -> IO ()>
22:04:19 <atp> > maybe (putStrLn "Nothing") print $ Just 6
22:04:24 <lambdabot>  <IO ()>
22:04:34 <atp> heh
22:04:36 <Jedai> dmwit: That's what I would do ultimately but it's already an higher order function...
22:04:39 <SubOne> `  let x = tuple4 (Tuple3 4 5 6) in  case x of    Nothing ->      putStrLn "Nothing"    Just x ->      print x` returns a compiler error
22:05:06 <atp> SubOne: you need a semicolon
22:05:10 <atp> SubOne: if you put it on one line
22:05:14 <Jedai> SubOne: You can't put it on one line (well you can but then you need to put braces and semicolons)
22:05:14 <atp> SubOne: which i don't recommend
22:05:17 <dmwit> SubOne: Layout is important.
22:05:32 <dmwit> SubOne: Also, drop the let and just do "case tuple4 (Tuple3 4 5 6) of ..."
22:05:36 <SubOne> its only on one line for the benefit of the channel o.O
22:05:46 <Jedai> case x of Nothing -> putStrLn "Nothing"
22:05:46 <Jedai>                 Just x -> print x
22:05:46 <dmwit> SubOne: probably an indentation issue
22:05:57 <SubOne> the large spaces are (i thought obviously) the \n's
22:05:58 <dmwit> SubOne: Nothing and Just must start in the same column
22:06:06 <Trinithiss> dmwit: wget is really cool!
22:06:16 <dmwit> SubOne: ...and in a later column than "case"
22:06:20 <atp> usually i put all the cases on a separate line from the case
22:06:22 <SubOne> no it compilers fine with tuple3
22:06:24 <atp> case x of
22:06:31 <Jedai> Don't use tabulations (the character, the key isn't a problem)
22:06:32 <atp>     Nothing -> putStrLn "Nothing"
22:06:34 <SubOne> compiles*
22:06:39 <atp>     Just x -> print x
22:06:44 <dmwit> Trinithis: yeah! =D
22:07:08 <atp> i used to use wget to download so much porn back in the day
22:07:20 <atp> back when the magic of video had not conquered the net yet
22:07:23 <atp> and i was still on a dialup
22:07:28 <SubOne> Ambiguous type variable `a' in the constraint:
22:07:28 <SubOne>       `Show a' arising from a use of `print' at Main.hs:47:14-20
22:07:39 <Trinithis> Man, I failed downloading Ubuntu 3 times after 1/2 completion. That was annoying
22:07:50 <SubOne> my if statement worked the first tim e:p
22:08:17 <dmwit> SubOne: Maybe you should try moving on in the tutorial.
22:08:26 <dmwit> It's not really helpful to dwell on this stuff for a long time at the beginning.
22:08:37 <dmwit> Just get to where you're writing lots of code that's interesting to you.
22:08:57 <SubOne> i doubt ill find any practical use for this really... just curious
22:09:09 <Jedai> SubOne: As I said, this case won't happens much in real code, you'll get it eventually.
22:11:24 * SubOne replaces the case with the working if statement
22:12:10 <SubOne> ok i think im really done for tonight
22:12:30 <SubOne> i'll go waste the rest of the night with stumbling
22:12:42 <SubOne> night
22:14:25 <mmorrow> atp: lol
22:22:13 <haskellator> class Pairable a where
22:22:15 <haskellator>  pair::a->(b,b)
22:22:39 <dolio> Nope.
22:23:01 <haskellator> how do i prevent b from becoming a rigid type due to one of the definitions?
22:23:34 <dmwit> There is no (good) definition of pair there.
22:23:44 <haskellator> ??
22:23:44 <rwbarton> You might have better luck with 'class Pairable a b'
22:23:46 <dmwit> Maybe you mean "class Pairable a b where ..."?
22:24:24 <rwbarton> (The type of your pair is  Pair a => a -> (b, b)  which is too general to be useful)
22:24:29 <dmwit> In which case you might also want "class Pairable a b | a -> b where ...", which says that given 'a', there is exactly one 'b' for which Pairable a b is an instance.
22:25:13 <haskellator> well this is followed by Instance  Pairable IniFile where        instance Pairable IniEntry where
22:25:15 <haskellator>  pair ( CIniEntry_Comment (CComment str) ) =  ("" , show $  str)
22:25:27 * dmwit doesn't actually know the general syntax for fundeps, only that specific case, anybody have a reference I could read?
22:25:54 <dmwit> haskellator: The result of "pair" there is not a (b, b), but a (String, String).
22:26:10 <dmwit> haskellator: If you know it's going to be Strings, you have to say so in your class.
22:26:23 <dmwit> class Pairable a where pair :: a -> (String, String) -- for example
22:26:25 <haskellator> basically i want it to be easy for users of IniFile to get a pair of (k,value)
22:26:48 <haskellator> but i want it to be genric so that otehrs may have their own type instead of String
22:26:49 <Jedai> dmwit: The user manual ?
22:27:06 <dmwit> haskellator: Then you have to give more parameters to the Pair class.
22:27:15 <dmwit> Jedai: You mean the Report?
22:27:23 <dmwit> I should really get around to reading the Report some day.
22:27:57 <Jedai> dmwit: Of course not (fundeps are an extension) I means the GHC User Manual, you have a section on fundeps
22:28:19 <Jedai> dmwit: Though reading the Report is a fine idea too ^^
22:28:21 <dmwit> ah HA!
22:28:41 <dmwit> Jedai: From http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies:
22:28:42 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
22:28:56 <dmwit> "There should be more documentation, but there isn't (yet)." =P
22:29:17 <haskellator> class Pairable a b c where
22:29:18 <haskellator>  pair::a->(b,c)
22:29:40 <dmwit> haskellator: That's one possibility, yes.
22:29:43 <rwbarton> But then there's a fair amount of documentation... :)
22:29:49 <haskellator>    Too many parameters for class `Pairable'
22:29:51 <haskellator>    (Use -XMultiParamTypeClasses to allow multi-parameter classes)
22:29:52 <haskellator>    In the class declaration for `Pairable'
22:29:58 <dmwit> rwbarton: Not enough. =/
22:30:15 <dmwit> rwbarton: Suppose I wanted to declare two dependencies, for example; is it possible?  They say nothing about such a case!
22:30:33 * hgolden is back
22:30:35 <Jedai> dmwit: Anyway fundeps are getting replaced by type families for many uses
22:30:38 <rwbarton> They do actually
22:30:43 <Jedai> dmwit: They do
22:30:51 <dmwit> Wait, what?
22:31:00 <Jedai> | a -> b, c b -> d
22:31:01 <rwbarton> See the paragraph beginning "More generally, dependencies take the form x1 ... xn -> y1 ... ym"
22:31:04 <Jedai> for instance
22:31:28 <dmwit> Oh... I didn't even *see* that section.
22:31:35 * dmwit stopped at 8.6.2.2.1
22:31:38 <haskellator> how do i use -XMultiParamTypeClasses ?
22:31:52 <dmwit> haskellator: Pass it to the ghc[i] command line.
22:32:04 <haskellator> im using runhaskell now
22:32:05 <rwbarton> haskellator: Or start your file with {-# LANGUAGE MultiParamTypeClasses #-}
22:32:06 <dmwit> haskellator: Or, put {-# LANGUAGE MultiParamTypeClasses #-} at the top of your file.
22:33:04 <dmwit> Jedai++ good suggestion
22:34:48 <haskellator> given the above class definition , whats wrong with :   instance Pairable IniEntry String String where ...
22:36:00 <dmwit> String is a type synonym for [Char]
22:36:18 <dmwit> ...and H98 doesn't allow concrete types in instances, only type variables.
22:36:31 <rwbarton> (How does instance Show String work then?)
22:36:47 <dmwit> uh
22:36:53 <dmwit> Probably by me being wrong.
22:36:55 <rwbarton> I guess it must be magic--it's an overlapping instance of [a]
22:37:02 <rwbarton> No, you're definitely right
22:37:05 <dmwit> rwbarton: No, there's a showList
22:37:07 <dmwit> ?src show
22:37:07 <lambdabot> show x = shows x ""
22:37:10 <dmwit> ?src Show
22:37:10 <lambdabot> class  Show a  where
22:37:10 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:37:10 <lambdabot>     show      :: a   -> String
22:37:10 <lambdabot>     showList  :: [a] -> ShowS
22:37:25 <rwbarton> I remember trying to define  instance Num [Integer]
22:37:28 <rwbarton> Ah, OK
22:38:03 <haskellator> so what do i do?
22:38:16 <rwbarton> Turn on -XFlexibleInstances or whatever the error message tells you to do?
22:38:59 <haskellator> if i use Instance IniFile a a where .. I get this
22:39:31 <haskellator> but if i use Instance Pairable IniFile String String i get -XTypeSynonymInstances
22:40:19 <dmwit> So... turn on TypeSynonymInstances, then?
22:40:33 <haskellator> :D i turned both on, just in case,
22:40:42 <rwbarton> Just keep following its instructions until something goes wrong, then hpaste whatever you end up with :)
22:40:47 <haskellator> hope there is no other side effect of doing that
22:41:50 <Jedai> haskellator: As long as you don't it UndecidableInstances or OverlappingInstances all is well... after that it's more complicated
22:42:10 <haskellator> thanks Jedai, ill keep that in mind
22:42:18 <haskellator> actually inteh file
22:54:09 <vovik> is there an article dealing with correctness proofs for programs written in functional languages?
22:57:37 <dmwit> vovik: You'll have to pardon our Friday-night lackadaisical attitude.
22:58:08 <vovik> i just had to look that word up
22:58:11 <dmwit> There are certainly such articles about, but you might have to ask at a higher-traffic time to get links to them.
22:58:26 <vovik> ya, i'll do that
22:58:44 <dmwit> In the mean time, you might be interested in Coq.
22:58:59 <dmwit> first hit on Google ;-)
23:00:08 <Jedai> Coq is nice, Agda looks interesting...
23:00:58 <Jedai> Correctness proof for functional programs are often much easier to write than for imperative programs
23:00:59 <vovik> well i was look for something more like an explanation of why it's easier to prove functional programs than imperative ones
23:01:07 <vovik> lol ^
23:01:19 <vovik> i understand the intuition
23:01:26 <vovik> no side effects and all that
23:01:31 <vovik> mathematically pure functions
23:01:56 <vovik> but i was looking for an explanation with as little hand-waving as possible
23:01:58 <Jedai> vovik: What do you need more than that ? You get complete composability with that ?
23:02:26 <vovik> maybe some examples
23:02:51 <vovik> well certainly some small examples would help
23:02:56 <Jedai> You see, the semantics associated with functional languages are very simple and well understood, did you do much work with lambda-calculus ?
23:04:06 <vovik> no, not at all
23:04:30 <vovik> i first heard about lambda calculus when i started looking into lisps and haskell
23:04:51 <Jedai> vovik: Ok... Maybe you should start by familiarising yourself with the lambda-calculus and some of the types systems for it.
23:04:55 <vovik> which was pretty recent, so my background is very limited
23:05:27 <vovik> any recommendations for that?
23:05:59 <Jedai> A very nice book is "Type and Programming Languages", very interesting read, really
23:06:33 <vovik> pierce?
23:06:40 <Jedai> vocik: Yes
23:08:01 <Jedai> vovik: If you want some little examples of one of the nice reasoning scheme that functional programming allows us to use, you could look into equational reasoning
23:08:37 <vovik> hmm, looks interesting
23:09:01 <vovik> does pierce cover untyped lambda calculus?
23:11:11 <dolio> That doesn't have types. :)
23:11:35 <Jedai> vovik: I don't really remember, but I think so (in one of the first chapters)
23:12:26 <vovik> the reason i ask is because it's been recommended to me to learn about untyped before going into typed
23:13:49 <dmwit> The untyped lambda calculus is simpler, in the sense that it has fewer rules.
23:15:05 <geezusfreeek> tapl does cover untyped lambda calculus
23:15:14 <Jedai> Do any of you remember some nice papers on derivation of an efficient program from a specification ?
23:15:31 <geezusfreeek> it covers the evaluation rules and such
23:15:33 <Jedai> I don't remember one right now though I read a few
23:15:54 <dolio> Jedai: I'd search for stuff by Richard Bird.
23:18:17 <Jedai> dolio: Yes, but his paper on the sudoku solver don't seem to be available, I liked this one...
23:18:45 <dolio> Jedai: Isn't it or something like it on the wiki's sudoku page?
23:18:48 <Jedai> Well let's say a recent example could be http://www.informatik.uni-bonn.de/~ralf/hw2001/2.ps.gz
23:20:16 <dolio> http://cs.nott.ac.uk/~gmh/sudoku.lhs
23:21:53 <Jedai> Yeah, I found it too, but it seems to me its article was a bit longer (and much easier on the eyes of course)
23:22:03 <Jedai> s/its/his/
23:22:08 <dolio> I'm not sure I've ever seen it.
23:22:33 <dolio> Shin-Cheng Mu wrote a paper not too long ago on doing algebra of programming style stuff in Agda, if you're into that.
23:22:52 <dolio> Writing combinators for proving two versions of a program are equivalent, I think.
23:23:08 <dolio> Or something of the sort.
23:23:20 <Trinithis> When I shrink vista size, will maxing out the highlighted area still leave room for vista apps :   http://vista.blorge.com/wp-content/uploads/2008/02/untitled-4.jpg
23:23:31 <Jedai> dolio: Yeah, I saw a bit of that, but I think it would more likely to scare vovik, I had difficulty following the paper myself
23:23:54 <dolio> Heh. Yeah.
23:24:03 <Jedai> But it looked very powerful and interesting
23:24:33 <vovik> if you think it'll scare me you're probably right
23:25:36 <Jedai> vovik: That's dependent typing, and in its latest developments so ... Try something a little more basic beforehand I think, Bird's papers are nice.
23:26:44 <vovik> ok
23:27:38 <vovik> which of bird's papers
23:50:04 <hansfbaier> @src StateT
23:50:04 <lambdabot> Source not found. My pet ferret can type better than you!
23:52:02 <sjanssen> Data.Monoid++
23:52:08 <sjanssen> @karma Data.Monoid
23:52:08 <lambdabot> Data.Monoid has a karma of 1
23:53:03 <sjanssen> "\c -> myKeys c `M.union` keys defaultConfig c" becomes "myKeys `mappend` keys defaultConfig" :)
23:53:44 <sjanssen> the Monoid instance for functions is pretty much my favorite thing in the whole wide world
