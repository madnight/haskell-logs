00:36:25 <bos> outside of GADTs, i can't think of any valid uses for constraints on type definitions.
00:39:02 <dolio> You mean 'data Foo a => Bar a = ...'?
00:39:21 <bos> yes.
00:39:24 <dolio> Those are pretty useless.
00:40:30 <dolio> I guess it might theoretically put some type errors in more appropriate places.
00:41:02 <dolio> If you construct a Bar with something that isn't a Foo, it'll get caught at the constructor, rather than where that Bar is used.
00:41:47 <dolio> Assuming everything that does anything with a Bar requires the constraint. But I don't know how much that'd gain you.
00:45:00 <sjanssen> bos: there's a reason nobody uses them
00:45:11 <bos> yes, i know.
00:45:47 <bos> i just had some comments in the book asking why they're there. my understanding has always been that they were essentially a mistake.
00:51:47 <chylli> @pl addNo a = (show (fst a)) ++ " " ++ (snd a)
00:51:48 <lambdabot> addNo = ap ((++) . show . fst) ((' ' :) . snd)
00:53:08 <BeelsebobWork> why you would want to do that without pattern matching I have no idea
00:54:25 <dolio> @type show *** id >>> \s t -> s ++ " " ++ t
00:54:27 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
00:54:50 <dolio> @type show *** id >>> uncurry (\s t -> s ++ " " ++ t)
00:54:51 <lambdabot> forall a. (Show a) => (a, [Char]) -> String
00:55:46 <b_jonas> hello, guyz
00:57:35 <chylli> @type (->)
00:57:36 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
01:02:58 <hml> honest opinion; if i'm trying to write a 3d modeling tool, like blender, can i write it in haskell, or am i just asking for problem dyue to large meshes and haskell's laziness?
01:05:08 <quicksilver> you can write it in haskell.
01:05:59 <quicksilver> bos: I think it is, at least, a mistake that they don't confer the constraint when deconstructing.
01:19:27 <luqui> How do I get ghci to show utf-8?
01:19:50 <luqui> (my terminal is properly configured)
01:19:58 <hatseflats> I have to say, I started with Haskell just yesterday, but it is awesome in almost every syntactical aspect.
01:20:09 <vixey> luqui: I didn't have to do anything for it to work
01:20:16 <luqui> hmm.
01:21:20 <vixey> actually
01:21:32 <vixey> It doesn't really display unicode properly, but it accepts it and handles it fine
01:21:52 <gvdm> hatseflats: really? tell us what you like most, what's the awesomeness tweaking your mind?
01:24:16 <hatseflats> gvdm: Nothing in particular is so mindblowing that I like Haskell because of it, but Haskell is the first language I've seen that is so feature rich and where it all clicks together without anything really standing out at the same time
01:24:54 <gvdm> wow, really? what clicks together? which features are the coolest?
01:25:44 <gvdm> nothing stands out about it though? I think there are a few key points which make haskell highly distinguishable from other languages
01:26:45 <b_jonas> I'm back and ready to ask some more questions...
01:26:56 <hatseflats> Of course there are, but I meant to say that it all fits in the syntax and general construction of the language without things looking out of place of hacked together
01:27:20 <hatseflats> A 'flow' of features with no rapids or waterfalls, if you will.
01:27:27 <gvdm> yes, but _what_ are the bits you think fir well together
01:27:33 <gvdm> s/fir/fit/
01:27:35 <dolio> @yarr
01:27:36 <lambdabot> Yarrr!
01:28:43 <hatseflats> But for instance, yesterday I had to understand that all functions in haskell that appear to have multiple arguments are just syntactical sugar for curryied lamda functions. Today I'm messing around with a few things (like findElement), and figure I can just say "(< 5)" is the predicate
01:28:58 <hatseflats> This, I think, is very nice
01:30:55 <gvdm> yes it is, /partial application/ is most awesome
01:32:00 <hatseflats> I mean, after you understand it's all lambda's, even the 'primitives', you can partially unroll any function and apply it where needed, I wouldn't even imagine doing such a thing in C, or Lisp for that matter
01:32:17 <b_jonas> you mentioned this Cale's IO monad with explicit gadts
01:32:24 <b_jonas> so I'd still like you know what it's used for
01:33:13 <b_jonas> is it to define a new type that represents io actions but only some restricted kinds of io actions?
01:33:14 <b_jonas> or what else?
01:33:19 <b_jonas> is there a link?
01:33:59 <b_jonas> also, is it worth to do the latter, that is, defining a type that represents restricted io actions but still can only be run in io
01:34:24 <b_jonas> even if you implement it in some other way than algebraic types (likely functions then)?
01:34:26 <halberd> I was just thinking that the point of object oriented programming is not data associated with functions per se, but data associated with types
01:35:06 <halberd> because once you have the type of your data structure, the functions that share that type as an argument are automatically associated with it
01:35:56 <halberd> and the idea of actually writing those functions within the lexical class definition is superfluous
01:38:07 <b_jonas> halberd: writing the functions in the lexical class definition is useful so you can have data constructors/accessors and even methods lexically private to that scope
01:39:30 <hml> besides the type system and laziness, does haskell have anything ovber erlang?
01:40:16 <quicksilver> purity
01:40:19 <halberd> b_jonas: I think that the concept of scoping is orthogonal to the concept of object orientation
01:40:26 <b_jonas> hml: no idea about erlang, but haskell also has a nice comprehensive standard library and addon libraries
01:40:40 <quicksilver> "besides the type system, purity and laziness" probably not much.
01:40:47 <quicksilver> mind you that's a hell of a lot.
01:40:50 <halberd> that is you could scope at the package level but still be object oriented
01:40:57 <b_jonas> halberd: yeah, maybe scoping is always useful, even if you use OO
01:41:15 <quicksilver> "besides burning gas and nuclear reactions and a massive gravitational pull" the sun isn't very different from the moon
01:41:31 <hml> quicksilver: laziness i can easily get with force/delay; type system -- my real like of it is the pattern matching; what do you mean by haskell's purity?
01:41:32 <quicksilver> halberd: common OO languages conflate all kinds of notions.
01:41:46 <quicksilver> hml: purity means that a function is a function.
01:41:50 <quicksilver> it doesn't have side effects.
01:42:01 <b_jonas> hml: you forget type classes
01:42:05 <quicksilver> halberd: in particular, they conflate scoping in with their object system.
01:42:15 <halberd> the purpose of limiting the scope of access methods is to prevent people from writing code that makes false assumptions about your class
01:42:43 <slava> has anyone experimented with compilers that use lazy structures for the IR, with incrementally applied optimizations?
01:42:47 <b_jonas> hml: the type class isn't just the algebraic types and function types (and the usual cpu-supported primitive types like numbers), but type classes and advanced extesions like that
01:42:53 <halberd> for example it could prevent them from assuming that the class internally represents something as a linked list and not an array-based stack
01:43:45 <halberd> and the reason that works is psychological, because it's assumed that anybody who IS writing access methods for the class has made it his business to understand which assumptions about it are valid and which are not
01:44:08 <quicksilver> b_jonas: actually, type classes are a way of selecting which code to run based on type inference, so they are in effect a way of hooking into the compiler's type inference system.
01:44:22 <halberd> this problem could be more rigorously solved using dependent types
01:44:46 <vixey> halberd: heh, I would like to see that
01:45:01 <halberd> so that you explicitly state as part of the type what assumptions about the class are valid
01:45:57 <halberd> so that you don't have to rely on the psychological trick of assuming that the person writing the class methods knows clearly what the assumptions are
01:46:03 <halberd> without formally stating them
01:46:05 <quicksilver> halberd: that doesn't sound like anythign to do with dependent types.
01:46:18 <vixey> it sure does
01:46:23 <quicksilver> that's just a more expressive kind of type.
01:46:31 <quicksilver> quite possible to imagine that without dependent types.
01:46:41 <quicksilver> dependent types are when types depend on values.
01:46:48 <quicksilver> you're just talking about types encoding assumptions or invariants
01:46:52 <halberd> okay but some kinds of assumptions about the class would require dependent types to state them
01:46:53 <quicksilver> you *could* do that using values
01:46:55 <quicksilver> but you don't have to.
01:46:56 <quicksilver> sure.
01:46:58 <vixey> I don't think there are any reasonable formalisms around which let you express something like, the monad laws and actually check them
01:47:04 <vixey> other than dependent typing
01:47:07 <vixey> are there?
01:47:55 <dolio> I've seen it argued that dependent types aren't good for abstraction.
01:47:59 <b_jonas> vixey: do you mean check automatically without extra input or be able to prove it if you're smart enough and it can be proved?
01:48:06 <halberd> dolio: link?
01:48:09 <dolio> Since everything is transparent.
01:48:57 <b_jonas> also, stupid question but does ghc usually compile code written largely inside monad transformer chain efficently?
01:48:59 <vixey> checking as in type checking
01:49:31 <dolio> halberd: http://www.cs.cmu.edu/~rwh/courses/modules/index.htm
01:49:32 <b_jonas> automatically proving theorems then, that's what type checking is
01:49:33 <lambdabot> Title: Courses
01:49:38 <vixey> no
01:49:41 <vixey> checking proofs
01:49:47 <dolio> The lecture on translucent sums just kind of states it.
01:49:57 <dolio> Some of the others might go into more detail.
01:49:58 <b_jonas> well, sort of both
01:50:01 <quicksilver> well if your type checker does inference then it is also automatically proving
01:50:02 <vixey> no not both
01:50:09 <quicksilver> admittedly the inference tends to be simple
01:50:13 <quicksilver> the kinds of proof are fairly limited.
01:50:15 <b_jonas> a type system usually still needs input for the proofs
01:50:24 <b_jonas> but less
01:50:28 <b_jonas> so yes, it's checking a proof
01:50:56 <vixey> ?djinn a -> a
01:50:56 <lambdabot> f a = a
01:50:59 <dolio> Basically, you want weak sums/existentials for abstraction, not strong sums like you usually use with dependent types.
01:51:03 <vixey> this is automatic theorem proving
01:51:16 <vixey> :t let f a = a in f
01:51:17 <lambdabot> forall t. t -> t
01:51:18 <vixey> that's not
01:51:37 <dolio> (And weak sums are kind of a pain if you're dedicated to a consistent type theory.)
01:51:59 <vixey> if you have an inconsistent theory doesn't that mean you can write programs that crash?
01:52:04 <vixey> like  1 + "foo"
01:52:13 <b_jonas> vixey: hmm ,yeah, make sense
01:52:21 <halberd> thanks for the resources dolio
01:52:24 <dolio> vixey: By inconsistent I mean you can prove false.
01:52:35 <dolio> Like Haskell (where it's trivial).
01:52:38 <vixey> yeah if I can prove false I can say    nat = string
01:52:49 <vixey> then I can say,  evil = "foo" : nat
01:53:01 <vixey> and crash the thing?
01:53:20 <dolio> Can you? That'd be more a soundness issue.
01:53:29 <vixey> well that's what I'm wondering
01:53:39 <dolio> Although I guess if you can prove type equality with bottom, it might be a problem.
01:53:44 <quicksilver> there is inconsistency at various different 'layers'.
01:53:46 <b_jonas> dolio: by haskell, do you mean h89 there or more extensions?
01:53:48 <dolio> I'm not really sure.
01:53:52 <quicksilver> if you had inconsistency in the unifier
01:53:53 <vixey> this doesn't break soundness in Coq because I had to assume False, which means it's opaque and that blocks evaluation
01:53:59 <quicksilver> then any pair of types would unify
01:54:03 <quicksilver> that would be pretty useless.
01:54:07 <vixey> but if you really could prove false, I think it would break soundness
01:54:12 <quicksilver> inconsistency that haskell has just means that every type is inhabited
01:54:22 <quicksilver> which is logically absurd but doesn't break the programming language
01:54:23 <quicksilver> (phew)
01:54:24 <dolio> b_jonas: Any of them. Every type is inhabited in Haskell, so 'data False' has an inhabitant.
01:55:22 <b_jonas> dolio: well, you can't define that type in h89 because it doesn't allow neither gadts nor empty data
01:55:32 <hml> :t read
01:55:33 <lambdabot> forall a. (Read a) => String -> a
01:55:37 <hml> :t show
01:55:38 <lambdabot> forall a. (Show a) => a -> String
01:55:44 <vixey> I guess you could do this in Agda and see what happens
01:55:45 <b_jonas> but I'm not sure if you may still define an abstract type in h89
01:55:46 <hml> Read & Show are type classes?
01:55:50 <vixey> or cayenne
01:55:54 <hml> so objects that can be read / displayed derive from them?
01:55:55 <vixey> hml: yes
01:56:16 <b_jonas> hml: well, it's not called derive
01:56:28 <vixey> dolio: Do you think it does break soundness? I'm not sure
01:57:17 <dolio> vixey: I'm not sure. Maybe I'll play around with Agda --type-in-type a bit.
01:57:17 <b_jonas> vixey: I think that would break soundness only if you could actually prove that they're inhabited by writing an expression that has such a type
01:57:29 <b_jonas> which you can for sure in haskell
01:57:45 <vixey> dolio, you can get a proof of nat = bool or whatever in agda a lot easier, by using general recursion
01:57:55 <b_jonas> just because you can name such a type isn't bad
01:58:19 <vixey> b_jonas: yeah, if you had an inconsistent type theory, and types dependent on values, do you lose type soundness
01:58:28 <vixey> that's what the question is
01:58:41 <dolio> vixey: I guess you don't need --type-in-type to show a problem. You just need to write 'foo :: False -> Nat -> String' or something.
01:58:51 <b_jonas> vixey: I see
01:59:16 <Anoobus> C > haskell !! :D
01:59:23 <Anoobus> hahaha.
01:59:27 <vixey> Anoobus: thanks for that.
01:59:42 <Anoobus> Np :P
01:59:44 <sbahra> vixey, did you see the link Korollary pasted earlier?
01:59:54 <vixey> no I missed it sbahra, what was it?
02:00:01 <sbahra> vixey, http://journals.cambridge.org/action/displayJournal?jid=RSL
02:00:32 <hml> wow, foldr works on infinite lists
02:00:33 <hml> that's insane
02:00:44 <hatseflats> nope it's not
02:01:03 <sbahra> vixey, first issue is free
02:01:23 <vixey> sbahra: oh great, thank you
02:01:44 <b_jonas> hml: it woudl only be insane if foldl worked for them (in any sane way)
02:01:51 <hml> @src map
02:01:51 <lambdabot> map _ []     = []
02:01:51 <lambdabot> map f (x:xs) = f x : map f xs
02:01:57 <hml> @src foldl
02:01:57 <lambdabot> foldl f z []     = z
02:01:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:02:03 <hml> @src foldr
02:02:03 <lambdabot> foldr f z []     = z
02:02:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:02:08 <dolio> vixey: Do you have type-equality based casting written in Agda somewhere?
02:02:16 <b_jonas> like,
02:02:17 <vixey> no
02:02:20 <hml> hmm, so map can be implemented in foldr easily; but not hte other wya around?
02:02:30 <vixey> I should install Agda,,
02:03:04 <dolio> Oh, that's right, I have to install Agda, too.
02:03:15 <hml> is Agda like Ada with a g?
02:03:25 <b_jonas> > foldr (\x y -> x : x : y) [] (enumFrom (0 :: Integer))
02:03:27 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15...
02:03:32 <b_jonas> this one makes sense I think
02:03:35 <b_jonas> it should work
02:04:04 <hml> [0..]
02:04:07 <b_jonas> though I wouldn't actually write this directly with foldr but some foldr based thing like concatMap instead
02:04:10 <hml> > [0..]
02:04:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:04:15 <Anoobus> bye all im bored :| laterz.
02:04:26 <vixey> bye Anoobus, nice to meet you
02:04:40 <hml> > foldr (\x y -> x : x : y) [] [0..]
02:04:40 <b_jonas> hml: yes, map can be implemented from foldr but not the other way
02:04:43 <dolio> vixey: Thinking about it briefly, I think it'd only cause unsoundness if your cast didn't inspect the proof at all.
02:04:44 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15...
02:05:11 <vixey> dolio: proof erasure should happen before evaluation though, I think.
02:05:24 <vixey> then again Agdas internals are a bit confusing.
02:06:16 <dolio> vixey: Reminds me of the observational equality papers, actually. Since their Props get erased, they have to ensure their consistency.
02:07:21 <dolio> Or something like that.
02:09:12 <sbahra> vixey, np, some cool papers in there
02:09:45 <hml> is there a wya to g3et lambda bot to tell me the right/left assosivity and priroity of operators?
02:12:45 <dolio> hml: ghci should tell you with the command :i, I think.
02:12:53 <b_jonas> really?
02:13:34 <dolio> Yes.
02:13:41 <hml> > :i (+)
02:13:42 <lambdabot>   parse error on input `:'
02:13:53 <dolio> No, lambdabot won't do it.
02:14:03 <hatseflats> > :i +
02:14:03 <lambdabot>  Parse error at end of input
02:14:05 <hatseflats> aah
02:14:11 <hml> dolio: ghci does tell me; thanks
02:14:22 <b_jonas> what's the @command for :i?
02:14:28 <b_jonas> :i (+)
02:14:33 <dolio> There isn't one.
02:14:41 <b_jonas> is there a :i in lambdabot at all?
02:15:04 <vixey> @index +
02:15:04 <lambdabot> Prelude
02:15:06 <b_jonas> ah, but the ghci :i command does indeed tell the fixity
02:15:14 <b_jonas> that's useful
02:19:46 <hml> how do I unload a module from ghci?
02:20:13 <b_jonas> hml: why would you need to? most modules are loaded by default
02:20:18 <b_jonas> they're just not imported
02:20:20 <vixey> hml: How did you load it?
02:20:26 <hml> :m IO Random
02:20:32 <hml> actually, I want to unload Prelude
02:20:40 <vixey> :m - Prelude
02:20:56 <dolio> vixey: So, ruminating some more, I'd say that inconsistency doesn't lead to unsoundness, but it leads to not being able to erase proofs.
02:21:25 <vixey> dolio, ah yeah that makes sense
02:21:29 <dolio> augustss would probably be a better person to ask, though.
02:21:39 <dolio> Since he's implemented such a language.
02:22:39 <b_jonas> dolio: he's implemented a language with a deliberately inconsistent type system for some good reason or a language with a plain wrong type system?
02:22:57 <vixey> ?go hotter than haskell
02:22:59 <lambdabot> http://www.cs.chalmers.se/~augustss/cayenne/
02:22:59 <lambdabot> Title: Cayenne
02:23:02 <dolio> Cayenne has dependent types, but is also turing complete.
02:23:33 <nominolo> and undecidable type-checking
02:23:34 <hml> :t String
02:23:38 <hml> > :t String
02:23:38 <lambdabot>   parse error on input `:'
02:23:46 <dolio> Yes, all kinds of good stuff. :)
02:24:16 <b_jonas> thanks
02:24:22 <hml> how do i get ghci to tell me that String = [Char] ?
02:24:28 <hml> @src String
02:24:28 <lambdabot> type String = [Char]
02:24:31 <hml> ah, there we go
02:24:35 <vixey> hml: putStrLn "String = [Char]"
02:24:48 <b_jonas> yeah, type defines an alias to a type
02:25:00 <b_jonas> it can also define an alias to a higher-kind type, with some limitations
02:25:06 <quicksilver> hml: :i String in ghci probably says something useful.
02:25:12 <quicksilver> hml: in ghci, :i is a good starting place
02:25:45 <hml> quicksilver: nice; thanks
02:27:11 <hml> since . has precedence 9, is there any reason to say (f . g)?
02:27:20 <quicksilver> (f . g) x
02:27:22 <quicksilver> for example
02:27:57 <hml> is ' ' of function applicatinon higher precendcenc?
02:28:05 <vixey> highest
02:28:07 <quicksilver> yes
02:28:12 <vixey> f . g x = f . (g x)
02:28:19 <quicksilver> functional application takes higher precendence than any binary operators
02:28:19 <BeelsebobWork> hml: if you want to lower application's precidence, use $ instead
02:28:25 <BeelsebobWork> f . g $ x
02:29:05 <hml> BeelsebobWork: ah; cool; thanks
02:29:10 <b_jonas> hml: you might also say (f . g) if you mix it with another precedence 9 operator
02:29:10 <osfameron> it's a shame "$" is such a big ugly symbol
02:29:38 <BeelsebobWork> yep
02:29:50 <b_jonas> osfameron: what do you think would be nicer?
02:30:00 <quicksilver> @ would be more standard
02:30:05 <quicksilver> but probably equally ugly
02:30:14 <b_jonas> quicksilver: standard as in Mathematica uses it but what else?
02:30:33 <b_jonas> plus, Mathematica uses it to make high precedence, not low precedence
02:30:51 <BeelsebobWork> â€º would be nice
02:31:01 <osfameron> b_jonas: I don't suppose there are lots of free symbols left... but something like ":" or "`" would be lighter typographically
02:31:06 <quicksilver> b_jonas: mathematicians use it.
02:31:12 <b_jonas> (Mathematica is also not curried which makes difference)
02:31:20 <hatseflats> Wait up; in YAHT it says "A binary tree blabla, a branch holds a left child, a right child and a value"
02:31:23 <quicksilver> b_jonas: probably just because 'at' and 'app' begin with a.
02:31:38 <b_jonas> quicksilver: I've never seen mathematicians use the @ symbol for that
02:31:46 <hatseflats> I've never heard of a binary tree with a value in the branches, only in the leafs, right?
02:31:58 <BeelsebobWork> hatseflats: you can define it either way
02:32:05 <encryptio> hatseflats: it makes definition in haskell slightly easier
02:32:08 <b_jonas> osfameron: well, it's not really about free symbols if you can suggest a whole reshuffling of symbols that's better
02:32:12 <BeelsebobWork> but usually they're more useful with them at the branches
02:32:13 <quicksilver> binary trees can have values at leaves or branches or both.
02:32:19 <BeelsebobWork> you know what you're comparing with
02:32:24 <hml> in a do block, a let does not need a corresponding in; is it possible to even put in a corresponding in?
02:32:38 <BeelsebobWork> hml: not in a do block no,
02:32:40 <b_jonas> harseflats: incorrect
02:32:42 <quicksilver> you could but then you wouldn't be using the special form.
02:32:47 <quicksilver> you'd be using the expression form
02:32:49 <quicksilver> that's fine too.
02:33:03 <b_jonas> in fact, values in the branches can be convenient because it's easy to search a simple binary search tree that way
02:33:06 <BeelsebobWork> do {let x = y; z} is sugar for let x = y in z hml
02:33:06 <quicksilver> > do let x = 4 in [5,x,6]
02:33:07 <lambdabot>  [5,4,6]
02:33:13 <osfameron> b_jonas: tbh, once you learn the foo . bar . baz $ thing form, it's not so bad.  It's mainly the foo $ bar $ baz qux  thing that looks ugly
02:33:14 <b_jonas> it depends on what exact flavor of binary tree
02:33:24 <vixey> yay Agda works
02:33:44 <hml> BeelsebobWork: quicksilver : thanks
02:34:17 <b_jonas> osfameron: well, yes, if you don't overuse $ but use () and other things in most cases, then it's certanly much less ugly
02:34:37 <BeelsebobWork> the only place I tend to use $ is at the end of a chain of .s
02:35:13 <hml> besides $ and . are there any other operators built for avoiding ()'s ?
02:35:29 <b_jonas> hml: well, let can help sometimes
02:35:52 <b_jonas> hml: and in general if you define lots of small functions you have less parenthesis I think
02:35:53 <BeelsebobWork> tbh, theres nothing wrong with having ()s
02:36:04 <BeelsebobWork> if you're nesting them deeply, it's time to refactor
02:36:06 <b_jonas> and that can be considered a good style of programming
02:36:08 <hml> what does tbh mean?
02:36:12 <BeelsebobWork> to be honest
02:36:42 <b_jonas> @wtf tbh
02:36:43 <lambdabot> Maybe you meant: bf ft wn
02:36:44 <BeelsebobWork> deeply nested ()s just inform you when your functions are getting too large, and you should think a bit more compositionally
02:36:49 <b_jonas> doesn't tell
02:36:53 <b_jonas> @acronym tbh
02:36:53 <lambdabot> Unknown command, try @list
02:36:57 <b_jonas> meh
02:42:23 <hml> how do i conclude that \x -> x x is not well typed?
02:43:29 <b_jonas> hml: you mean how to ask ghc for it or by hand?
02:43:50 <jansz> @pl (\x y -> dt!!x!!y)
02:43:50 <lambdabot> (!!) . (dt !!)
02:44:05 <b_jonas> it's a lambda so it must have type a -> b for some a and b with the parameter x being type a
02:44:22 <b_jonas> and the body being type b
02:44:22 <vixey> dolio, hehe I crashed AGda
02:44:29 <dolio> Oh?
02:44:35 <b_jonas> but the body is the expr x x where each x has the type a
02:44:50 <hml> b_jonas: bhmm, by hand; trying to work it out mentally first
02:44:57 <vixey> or maybe it is just looping
02:44:59 <b_jonas> so a has to be a function type of a -> a
02:45:03 <hml> hmm, this is interesting
02:45:04 <b_jonas> which you have to unify with b
02:45:11 <vixey> http://rafb.net/p/NfBaMj13.html
02:45:12 <lambdabot> Title: Nopaste - No description
02:45:12 <b_jonas> um, wrong
02:45:20 <hml> so haskell lets us have infinite lazy lists, but not infinite lazy types?
02:45:22 <b_jonas> last but one step I messed up
02:45:37 <b_jonas> a has to be a function type a -> b
02:45:45 <vixey> if you try to compute the normal form of killer it gets confused
02:46:01 <vixey> hml: yes, data is coinductive, types are inductive
02:46:06 <b_jonas> (because x is called with an argument of type a and the return value is unified with b
02:46:17 <b_jonas> so then a has to be unified with a -> b
02:46:26 <b_jonas> which obviously leads to an occurs check
02:46:27 <hml> got it; thanks
02:46:50 <hml> to be more stupid; hypothetically, if i was writing a type system myself
02:47:03 <hml> what rules would at this pooint tell me "this can't be solved?" ?
02:47:21 <vixey> hml: I don't think there's anything stupid about that
02:47:57 <hml> something else: so in "data Pair a b = Pair a b", the 'a' and 'b' are types: but in "pairFst (Pair a b) = a", the a and b are variables / values?
02:48:20 <vixey> hml: say you try to find the type of: (\u -> u u)
02:48:37 <vixey> hml: first you annotate it: (\u -> (u :: x) (u :: y)) :: z
02:48:42 <b_jonas> hml: the occurs check rule of unification
02:48:47 <b_jonas> I think it's something like
02:48:57 <vixey> hml: then you constrain it (\u -> (u :: a) (u :: a) :: b) :: a -> b
02:49:12 <vixey> now the application rule is used
02:49:36 <b_jonas> when you try to unify a single type variable (of any kind) with a type in which that variable occurs, you raise an occurs check error
02:49:37 <vixey> (u :: a) (u :: a) :: b   -->    a =  p -> q, u = p, b = q
02:50:07 <vixey> oops
02:50:12 <vixey> I wrote u = p, meant a = p
02:50:17 <b_jonas> where the rule is considered understood with two things unified in either order
02:50:21 <vixey> anyway if you try to solve those equations you get an infinite type
02:50:55 <vixey> the type is infininite because you have a = a -> b  so a occurs on both sides (that's the occurs check)
02:51:23 <vixey> :t \u -> u u
02:51:39 <b_jonas> vixey: heh, it must be confusing if you made an error in it not just me :-)
02:51:55 <vixey> typa
02:51:57 <vixey> typo*
02:53:43 <b_jonas> did I say the occurs check correctly?
02:54:02 <b_jonas> that is, did I state the general rule for it correctly
02:55:02 <hml> vixey: b_jonas thank,s for your help; i think the only way this'll be crystal clear is for me to implement a type inference engine one of these days myself
02:55:13 <b_jonas> hml: heh
02:55:23 <b_jonas> that's a nice exercise probably
02:55:26 <b_jonas> I never did that
02:55:56 <hml> is type classes what allows haskell to avoid ocamls's + and +. ?
02:56:13 <b_jonas> (not that I'm saying I understand the haskell type system exactly)
02:56:15 <b_jonas> hml: yes
02:58:25 <vixey> (a :: x) (b :: y) :: z  =>  x = p -> q, b = p, z = q
02:59:09 <vixey> (\a :: x -> b :: y) :: z  =>  z = x -> y
02:59:29 <vixey> you pretty much just traverse the syntax tree apply those rules on it
02:59:41 <vixey> '=' here being first order unification
03:00:02 <vixey> then you can add in data/type constructors to the syntem
03:00:09 <vixey> which isn't a big change
03:00:13 <b_jonas> stupid question, but is (\y f = f (y f)) what is normally called the y combinator?
03:00:24 <b_jonas> or at least one y combinator, as some say there are more
03:00:32 <vixey> no
03:00:32 <b_jonas> also, if it is, what's its usual name in haskell
03:00:35 <b_jonas> um
03:00:40 <b_jonas> I should have written
03:00:50 <b_jonas> let y f = f (y f) in y
03:00:51 <b_jonas> I'm stupid
03:00:56 <b_jonas> how about that one?
03:01:08 <vixey> no
03:01:16 <vixey> @w80 combinator
03:01:16 <lambdabot> No match for "combinator".
03:01:23 <vixey> its \m -> (\f -> m (\a -> (f f) a)) (\f -> m (\a -> (f f) a)) or something
03:01:29 <hml> wow () is a data type, i always thought ikw as black magic
03:02:11 <b_jonas> hml: that's just syntax
03:02:17 <b_jonas> you could define a similar data type like
03:02:21 <b_jonas> data Void = Void
03:06:15 <b_jonas> vixey: I see
03:07:15 <b_jonas> vixey: though en.wikipedia disagrees with you I think
03:07:45 <vixey> I don't read wikipedia much
03:08:34 <b_jonas> it might be wrong
03:08:36 <b_jonas> I'm just mentioning
03:08:51 <b_jonas> there might even be multiple naming conventions
03:08:59 <b_jonas> @src fix
03:09:00 <lambdabot> fix f = let x = f x in x
03:09:18 <b_jonas> that's not it
03:11:18 <augustss> yo
03:11:25 <vixey> hi augustss
03:12:33 <sm> morning all
03:12:43 <sm> darcs tests tell me hGetContents doesn't ensure the file is closed before it is deleted! What should I use instead ?
03:13:27 <b_jonas> sm: why is it important that it is closed before it's deleted?
03:13:59 <sm> I don't know. Maybe some platforms like it ?
03:14:00 <b_jonas> what semantic difference does it cause? I think the worst it could cause is that an open fails because of too many open filehandles.
03:14:07 <b_jonas> oh, you mean like windows?
03:14:21 <sm> yeah
03:14:23 <sm> darcs tests complained when I tried to commit a file with this code
03:14:34 <b_jonas> yeah, windows is broken because opens are locked by default so no other people can open the same file.
03:14:43 <b_jonas> that's a strange interface
03:15:06 <b_jonas> well, you can probably write some more restricted variant of it with the file open primitives
03:16:18 <b_jonas> System.IO has a hClose mehtod
03:16:28 <b_jonas> s/method/function/ sorry
03:16:39 <yakov> hey
03:17:54 <sm> thanks, I'll try
03:19:24 <augustss> b_jonas: To answer an earlier question: Cayenne's type system is deliberately unsound as a logic, but that doesn't matter if you just want to use it as a programming language.
03:19:48 <b_jonas> augustss: I see
03:22:25 <vixey> augustss: Since you can write an infinite loop, you can prove than nat = bool, for example
03:22:41 <vixey> and then rewrite the type of something, which lets you do  1 + True
03:23:13 <vixey> but does that break soundness or not? It seems like to actually evaluate the term in Agda it loops
03:23:19 <vixey> but I don't know what happen in cayenne
03:23:26 <vixey> what wolud happen*
03:24:23 <augustss> vixey: It's been a while, but I dont think you could prove nat=bool
03:24:41 <augustss> Because you can't prove much about things at the type level at all.
03:24:47 <chylli> @src FilePath
03:24:48 <lambdabot> type FilePath = String
03:25:17 <hackage> Uploaded to hackage: AERN-Real 0.9.6
03:28:10 <augustss> vixey: I'm trying to think of ways in which you could prove nat=bool ...
03:28:23 <vixey> augustss: I had a go in Agda earlier,
03:28:31 <vixey> http://rafb.net/p/NfBaMj13.html
03:28:31 <lambdabot> Title: Nopaste - No description
03:28:41 <vixey> so I put,
03:28:42 <vixey> evil : Bool == Coin
03:28:42 <vixey> evil = evil
03:29:11 <vixey> because of the loop it typechecks, but I think that the proof is still around during evaluation
03:29:46 <augustss> Why does that pass the termination checker?
03:29:50 <vixey> it doesn't
03:30:26 <chylli> @src lines
03:30:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:30:29 <vixey> when I try to normalize  not foo  it loops, I guess it's what dolio said earlier, You can't do proof erasure if you don't have a consistent logic
03:31:18 <ivanm> they actually list better Haskell support as one of the expected improved features for Fedora 10? :o http://fedoraproject.org/wiki/Releases/10/FeatureList
03:31:19 <lambdabot> Title: Releases/10/FeatureList - FedoraProject
03:32:20 <dcoutts> patc: use Haskell String "" syntax for paths with spaces in.
03:34:41 <augustss> vixey: I'll try that example in Cayenne later.  It needs some rewriting since Cayenne doesn't have GADTs.
03:34:56 <augustss> vixey: Right now it's time to do Ulan Bator by night. :)
03:35:36 <vixey> oh if you are adding GADTs that will be interesting to
03:35:38 <vixey> see
03:37:54 <b_jonas> augustss: does it need GADTs?
03:38:59 <augustss> b_jonas: No, it's possible to rewrite.
03:39:13 <b_jonas> good
03:48:13 <MarcWeber> sjanssen: storable vectors is twice as fast as bytestrings http://rafb.net/p/1M52lM63.html
03:48:14 <lambdabot> Title: Nopaste - No description
03:48:35 <MarcWeber> However using 1g as chunk size noting happens and the application quits with exit status 0 ?
03:55:04 <quicksilver> MarcWeber: what if you use L.putStr instead of I.putStr ?
03:55:08 <quicksilver> I.putStr is probably slow.
03:55:20 <quicksilver> and L.getContents
03:56:03 <MarcWeber> quicksilver: Of course maybe it gets faster than. But my goal was to compare storablevectors against bytestring
03:57:16 <rwbarton> comparing how they convert to and from Strings, you mean?  I think most applications of ByteString would try to avoid massive packs and unpacks...
03:57:25 <dolio> By running them through the worst possible operation on them?
03:58:05 <MarcWeber> Of course. But packing and unpacking happons for both libraries here..
03:59:29 <dolio> But '... L.pack =<< I.getContents' is something you'll never do with byte strings.
04:06:12 <chylli> I want to count number of '\n' in a string. what function can do that ?
04:06:25 <vixey> :t count
04:06:42 <vixey> @let count x = length . filter (==x)
04:06:42 <lambdabot> Defined.
04:06:55 <vixey> > count 'x' "foxbox"
04:06:56 <lambdabot>  2
04:06:58 <chylli> thanks
04:07:25 <hatseflats> how long will lambdabot remember these definitions?
04:07:27 <chylli> ok. I mistake filter function just now
04:07:38 <chylli> @src filter
04:07:39 <lambdabot> filter _ []     = []
04:07:39 <lambdabot> filter p (x:xs)
04:07:39 <lambdabot>     | p x       = x : filter p xs
04:07:39 <lambdabot>     | otherwise = filter p xs
04:07:53 <vixey> > filter (> 3) [1,5,8,7,4,6,6,8,5,3,2]
04:07:54 <lambdabot>  [5,8,7,4,6,6,8,5]
04:07:58 <vixey> > filter (<= 3) [1,5,8,7,4,6,6,8,5,3,2]
04:07:59 <lambdabot>  [1,3,2]
04:08:09 <chylli> @type filter
04:08:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:09:35 <quicksilver> MarcWeber: but you're not doing anything with ByteStrings
04:09:40 <quicksilver> MarcWeber: you're just packing and unpacking
04:09:43 <quicksilver> I don't really see the point
04:09:48 <quicksilver> or what you're trying to prove?
04:09:55 <vixey> chylli: length . lines also
04:10:03 <quicksilver> you would never use I.putStr or I.getContents on a bytestring
04:10:11 <quicksilver> that would defeat the point of using bytestrings...
04:10:26 <chylli> vixey: seems length.lines is not as quick as length.filter
04:10:33 <vixey> > length . lines $ unlines . words $ "this is a multiline string"
04:10:34 <lambdabot>  5
04:10:37 <vixey> chylli: Really?
04:10:48 <dolio> Not surprising.
04:11:02 <chylli> yes
04:11:22 <chylli> [chylli@arch /tmp] time (cat everything.log|./test)
04:11:22 <chylli> 683384(; cat everything.log | ./test; )  2.49s user 0.25s system 87% cpu 3.150 total
04:11:22 <chylli>  
04:11:30 <chylli> this is length.filter version
04:11:38 <MarcWeber> quicksilver First I thought it would be a nice idea to patch WASH to use ByteStrings. Now it happens that WASH as a function encoding some special characters within comments
04:11:50 <chylli> time (cat everything.log| ./test)
04:11:50 <chylli> 683384(; cat everything.log | ./test; )  7.71s user 0.43s system 90% cpu 8.972 total
04:11:50 <chylli>  
04:11:59 <chylli> this is length.lines version
04:12:06 <quicksilver> chylli: did you compile with -O2 ?
04:12:06 <chylli> don't know why
04:12:12 <MarcWeber> So when using bytestrings there I've lost, because I can only use Char8 or I have to pass UTF-8, but then the encoding function might suck..
04:12:14 <chylli> with nothing
04:12:16 <chylli> let me test again
04:12:29 <quicksilver> (lines is much more complex than just == '\n' so I'm not surprised to see a difference)
04:12:36 <quicksilver> but speed tests with optimisation off are not very interesting
04:12:50 <quicksilver> like doing a horse race with the jockeys carrying the horses
04:13:09 <vixey> that sounds quite interesting :p
04:13:13 <MarcWeber> quicksilver: sjanssen has pointed me to storablevector because it's kind of bytestring but can store Chars.
04:13:18 <quicksilver> MarcWeber: yes, byte string is not a good match for chars
04:13:23 <quicksilver> MarcWeber: because it stores bytes :)
04:14:17 <ivanm> is it intentional that unlines ends the string with a newline?
04:14:27 <MarcWeber> I've written the small test to make sure that storablevectors isn't much slower than bytestrings
04:14:38 <quicksilver> MarcWeber: but it doesn't test what you claim it tests.
04:14:45 <quicksilver> it tests the speed of pack/unpack, perhaps.
04:14:51 <quicksilver> although it might not even test that.
04:15:05 <quicksilver> certainly this isn't a comparison of the speed of bytestring and storeablevector
04:15:49 <MarcWeber> quicksilver: and what happens if you pack some hundred "<br>" "<div " `cons` "attr" `cons` "=" `cons" value etc ?
04:15:53 <chylli> still that result.
04:16:40 <quicksilver> MarcWeber: in a sensible conversion, you wouldn't use 'pack' at all
04:16:46 <quicksilver> you'd use append, or whatver storablevector calls it
04:16:53 <quicksilver> to join bits together
04:17:02 <quicksilver> the speed by which it can pack/unpack a file
04:17:07 <quicksilver> is not a very interesting benchmark
04:17:16 <quicksilver> because it is not likely to measure the speed of something you care about.
04:18:14 <MarcWeber> quicksilver: a = pack "a" ... when using a will it packed more than once ? I guess yes if you say it should inline the function and I'd guess no if you say noinline?
04:18:38 <quicksilver> of course it won't
04:19:01 <quicksilver> if "b = f a" and you use b more than once
04:19:07 <quicksilver> it doesn't execute f more than once
04:23:36 <MarcWeber> quicksilver: So if I have a function returning a 2gb value and I know that I won't need that value a second time.. than I'm lost?
04:24:10 <quicksilver> MarcWeber: no, that's why we have a garbage collector.
04:24:19 * quicksilver peers at MarcWeber curiously :)
04:25:25 <nominolo> MarcWeber: can the value be processed in chunks?
04:25:38 <MarcWeber> How does the gc now wether the result of a function will be used again? You told me the string will only packed once ?
04:26:19 <quicksilver> MarcWeber: it sees whether or not you still have a pointer to it.
04:26:33 <nominolo> MarcWeber: if it runs out of memory it starts to free some, and if there's memory that can never be accessed by the program it's freed
04:29:15 <MarcWeber> So when having "b = f a"  and using it putStr $ concatMap (const (show b)) =<< getContents it will keep a pointer unless stdin is closed?
04:29:53 <quicksilver> I don't know why you're making this so hard.
04:29:55 <quicksilver> it really isn't.
04:30:05 <quicksilver> named values stick around until the name is no longer around
04:30:20 <quicksilver> if you name 'b', it's evaluated precisely once (the first time it is demanded)
04:30:39 <quicksilver> the evaluated value sticks around until it's no longer referenced
04:30:44 <quicksilver> at which point the GC can reclaim it.
04:34:30 <nominolo> @seen JaffaCake
04:34:31 <lambdabot> JaffaCake is in #haskell and #ghc. I last heard JaffaCake speak 3h 20m 22s ago.
04:35:06 <MarcWeber> quicksilver: What hoppens if you have kind of webserver which spawns a new thread for each connection and the response is returning b ? So when all connections end there is no reference left? Thus the gc may remove the result? But then if anotehr connection is established the value has to be calculated again?
04:35:38 <quicksilver> MarcWeber: depends on the scope of the name.
04:35:44 <quicksilver> control the scopes of your names wisely.
04:35:53 <quicksilver> if you wish to understand your memory consumption.
04:37:02 <quicksilver> (it's really pointers to values that matter, not names, to be honest. The business about names is a convenient white lie)
04:37:23 <quicksilver> being in scope doesn't guarantee being accessible either.
04:37:33 <quicksilver> but if you're not in scope you're definitely not accessible.
04:37:47 <MarcWeber> So we are lost in the darcness of ghc internals here :)
04:37:56 <SamB_XP> only with a k
04:37:56 <rwbarton> what?
04:38:14 <opqdonut> darcsness
04:38:19 <opqdonut> except it's gitness nowadays
04:38:45 <hatseflats> at least no submess..
04:39:18 <rwbarton> There are no ghc internals involved.  This is how every garbage-collected language works
04:39:51 <quicksilver> MarcWeber: not really, no.
04:40:05 <quicksilver> There are a couple of specific details which might vary from implementation to implementation.
04:40:10 <b_jonas> only it's getting a bit more complicated to predict things because of lazy evaluation
04:40:13 <quicksilver> but the basic guideline is entirely standard.
04:40:39 <quicksilver> named values are shared
04:40:42 <b_jonas> except that
04:40:45 <quicksilver> let a = 1+1 in a + a
04:41:07 <quicksilver> it would be pretty surprising if that calculated a twice
04:41:27 <b_jonas> never mind
04:41:32 <hackage> Uploaded to hackage: AERN-RnToRm 0.3.0.2
04:41:32 <hackage> Uploaded to hackage: AERN-RnToRm 0.3.0.1
04:41:32 <hackage> Uploaded to hackage: AERN-RnToRm 0.3.0
04:41:33 <hackage> Uploaded to hackage: AERN-Real 0.9.6
04:41:35 <hackage> Uploaded to hackage: mdo 0.0.1
04:41:45 <quicksilver> (in general, it would be surprising. In a specific example with sufficient inlining a compiler might decide to, sure)
04:50:47 <rwbarton> MarcWeber: In your "putStr $ concatMap (const (show b)) =<< getContents where b = f a" example, not only b but also show b will be computed just once.
04:52:55 <MarcWeber> what about f c = let a = 1 in a + a + c ? will a be computed again if you call f again?
04:53:59 <quicksilver> MarcWeber: yes. Because that's a different a, then.
04:54:11 <quicksilver> MarcWeber: that's what I mean about using scopes to control sharing.
04:54:35 <rwbarton> Yes, anything inside a lambda expression gets recomputed (even if the compiler might be able to see that it's a constant)
04:55:18 <FordCortina> could anybody tell me what's causing this error http://hpaste.org/9439 ?
04:56:25 <quicksilver> rwbarton: unless the compiler hoisted it out.
04:56:35 <quicksilver> which is why that is a controversial optimisation.
04:56:45 <quicksilver> and here we *do* get the point which is compiler-internal.
04:56:49 <rwbarton> quicksilver: But I think it never does, precisely because it could lead to huge memory use... yeah.
04:57:14 <rwbarton> quicksilver: True, without saying what I mean by "it" I can't be totally certain of that statement :)
04:59:10 <rwbarton> FordCortina: Your type declaration for iseq looks too general, for one thing...
05:00:33 <MarcWeber> FordCortina: And why TFalse*,*c1 ?
05:02:27 <rwbarton> FordCortina: This compiles:
05:02:29 <rwbarton> iseq :: TIndex e1 c1 -> TIndex e2 c2 -> SI (TIndex e1 c1) (TIndex e2 c2) (TIndex e1 c1)
05:02:32 <rwbarton> iseq (TFalse,c1) (_,_) = SIFalse (TFalse,c1)
05:02:47 <rwbarton> I don't know whether what you're trying to do is possible
05:03:00 <FordCortina> MarcWeber: it because the final type should be (e1 'and' e2, if e1 then (Node c1 c2) else c1)
05:03:25 <FordCortina> MarcWeber: im trying to do terminating parser combinators
05:03:38 <FordCortina> rwbarton: thanks
05:04:39 <FordCortina> rwbarton: i should have tried that, i was hoping that ghc would work out that the "i"s have to be TIndex
05:05:58 <rwbarton> FordCortina: well you also can't say   foo :: a   foo = ("x", "y")   but you at least get a much better error message for that :)
05:07:34 <FordCortina> rwbarton: ic
05:07:40 <FordCortina> rwbarton: :(
05:07:50 <rivercheng> hi
05:08:22 <quicksilver> FordCortina: that would be a "partial type annotation"
05:08:29 <quicksilver> FordCortina: haskell doesn't have those.
05:08:33 <b_jonas> rwbarton: ah yeah
05:08:37 <quicksilver> if you annotate a type as 'ti' then it is 'ti'
05:08:43 <rivercheng> Could I ask a question about profiling
05:08:53 <b_jonas> though it's possible to do in a roundabout way
05:08:53 <b_jonas> like
05:08:57 <FordCortina> quicksilver: ic
05:08:59 <quicksilver> in the absence of any other use of 'ti' that is, therefore, fully polymorphic.
05:09:17 <pozic> Is there an OptionallyWriteOnce monad that I can use to return a value from deep inside a computation all the way to the top?
05:09:26 <b_jonas> _ = (if :: a -> a) foo; foo = ("x", "y")
05:09:29 <b_jonas> or something like that
05:09:37 <pozic> The Writer monad assumes one writes to it multiple times.
05:09:49 <b_jonas> s/if/id/
05:09:51 <b_jonas> sorry
05:10:08 <pozic> I can also just write a list of values, but it expresses a different idea.
05:10:16 <SamB_XP> pozic: but you have more computing to do afterwards?
05:10:17 <rivercheng> I have a function like evaluate x = collect ! aux x
05:10:32 <SamB_XP> the optionally-write-once idea sounds awfully complicated :-(
05:10:38 <pozic> SamB_XP: just showing the number to a user.
05:10:41 <b_jonas> pozic: a Maybe monad
05:10:48 <rivercheng> The profiling shows that >95% time is on function evaluate.
05:10:52 <b_jonas> that way the rest of the computation won't be ran (hopefully)
05:10:54 <pozic> b_jonas: right, maybeT
05:11:14 <pozic> b_jonas: no, that won't work.
05:11:20 <SamB_XP> rivercheng: yes?
05:11:28 <b_jonas> pozic: um
05:11:30 <quicksilver> pozic: sounds like the Exit monad?
05:11:33 <b_jonas> maybe an EitherT
05:11:38 <b_jonas> I mean
05:11:39 <b_jonas> ErrorT
05:11:44 <SamB_XP> rivercheng: what is collect?
05:11:48 <rivercheng> Then since collect and aux are local functions, they are not shown in the .prof
05:11:52 <SamB_XP> ah
05:11:54 <pozic> I already use ErrorT.
05:11:58 <b_jonas> with the error type being the type of the value you want to extract from deep
05:12:00 <pozic> quicksilver: what's Exit?
05:12:01 <SamB_XP> you could use {-# SCC #-}s
05:12:09 <quicksilver> @go MonadExit
05:12:11 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadExit
05:12:11 <lambdabot> Title: New monads/MonadExit - HaskellWiki
05:12:15 <b_jonas> I was stupid about the maybe, sorry
05:12:28 <quicksilver> pozic: although, maybe you do want the writer monad, and you just want to choose the right monoid.
05:12:29 <rivercheng> I try to add ACC at the left of collect and aux
05:12:38 <SamB_XP> hmm?
05:12:48 <rivercheng> but their stat data are 0
05:12:49 <SamB_XP> rivercheng: ACC?
05:12:49 <rwbarton> b_jonas: no, I think you were write.  Writer (Maybe a) should do it
05:12:52 <quicksilver> there are 'take first' and 'take last' monoids over Maybe
05:12:53 <rwbarton> *right
05:13:05 <SamB_XP> oh, you got results then but not the ones you wanted?
05:13:16 <rivercheng> Sorry SCC
05:13:34 <b_jonas> rwbarton: why not an either?
05:13:38 <SamB_XP> yeah, I figured you must have got it right in the code when you said you got 0s ;-)
05:13:56 <rivercheng> Yes. I want to know how much time are spent on collect and how much on aux
05:14:09 <b_jonas> ah, a writer parametrized with a maybe
05:14:10 <b_jonas> makes sense
05:14:13 <pozic> quicksilver: Either the computation halts in the middle throwError, or it needs to communicate some variables back (these variables are used in the normal control flow to continue the computation).
05:14:16 <SamB_XP> why are they local anyway?
05:14:24 <rivercheng> I use where
05:14:27 <pozic> with throwError*
05:14:32 <b_jonas> @src Monoid Maybe
05:14:33 <lambdabot> Source not found. Do you think like you type?
05:14:38 <SamB_XP> I meant, is there any reason you couldn't lift them to the toplevel?
05:14:52 <SamB_XP> ... not that it's all that likely to help
05:14:56 <rivercheng> Yes. Good idea, I can try to write them as top level functions
05:15:19 <rivercheng> But still how to profile local functions remains a problem .:)
05:15:44 <SamB_XP> yeah
05:15:56 <rwbarton> b_jonas: it seems Either a b and Writer (Maybe a) b are rather similar
05:16:02 <b_jonas> rwbarton: I think the difference is that a writer to maybe both gives the first value written and finishes the computation after is,
05:16:24 <rwbarton> b_jonas: Yeah, provided you demand the result half of the pair returned by runWriter.
05:16:26 <b_jonas> rwbarton: whereas an either computes either the first value written or finishes if there's no value written
05:16:46 <b_jonas> rwbarton: hmm, yeah
05:16:49 <pozic> Maybe is not a monoid according to my documentation.
05:16:51 <b_jonas> rwbarton: makes sense
05:16:57 <SamB_XP> rivercheng: hmm, possibly the cost of "collect" was being attributed to the CAF cost center?
05:17:07 <SamB_XP> maybe you should use the -caf-all flag?
05:17:20 <rwbarton> > runWriter (do { tell (Just "x"); return 0 } :: Writer (Maybe String) Int)
05:17:21 <lambdabot>  (0,Just "x")
05:17:24 <b_jonas> pozic: First is
05:17:26 <rivercheng> But the current CAF cost are all almost 0
05:17:39 <rwbarton> > runWriter (do { if False then tell (Just "x") else tell Nothing; return 0 } :: Writer (Maybe String) Int)
05:17:40 <lambdabot>  (0,Nothing)
05:18:18 <b_jonas> I wonder why Data.Monoid doesn't define a Min and Max monoid (which would be strict of course but you could use them for numbers where that's no problem)
05:18:21 <SamB_XP> hmm, I wonder why in http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-compiler-options.html they refer to _scc_ constructs rather than SCC pragmas?
05:18:22 <lambdabot> Title: 6.2.ï¿½Compiler options for profiling, http://tinyurl.com/6nv7s7
05:18:48 <rwbarton> pozic: Oh... the monoid instance I was thinking of isn't the one that's defined.
05:18:49 <quicksilver> pozic: there are two ways to make Maybe a monoid
05:18:51 <quicksilver> as I said.
05:18:56 <quicksilver> at least two :)
05:19:02 <quicksilver> but two of possible relevant here.
05:19:12 <quicksilver> take first and take last
05:19:19 <SamB_XP> quicksilver: I'm fairly certain there are only two
05:19:19 <rwbarton> > Just "foo" `mappend` Just "bar" -- this is the third one
05:19:20 <lambdabot>  Just "foobar"
05:19:39 <rwbarton> it's Monoid a => Monoid (Maybe a), of course.
05:20:02 <SamB_XP> oh, okay, so there are three if you count that one
05:20:08 <SamB_XP> or I guess 4
05:20:10 <b_jonas> quicksilver: which is why First and Last are defined in Control.Monoid
05:20:36 <rivercheng> I wish they include a example of how to use SCC in the document
05:20:39 <SamB_XP> (you could use the opposite order for the submonoid ...)
05:20:58 <SamB_XP> rivercheng: well, make a ticket
05:21:36 <pozic> And if you place these instances in a different module, you can use them all in different situations?
05:21:45 <rivercheng> :)
05:21:48 <SamB_XP> http://hackage.haskell.org/trac/ghc/newticket?type=bug
05:22:05 <rivercheng> Is this can be counted as a bug?
05:22:12 <pozic> b_jonas: you meant Data.Monoid?
05:22:12 <SamB_XP> pozic: not a wise thing to do
05:22:24 <pozic> SamB_XP: no, it looks kind of complicated.
05:22:34 <b_jonas> pozic: yeah, Data.Monoid
05:22:35 <b_jonas> sorry
05:22:36 <SamB_XP> rivercheng: until they add a more suitable ticket type, why not?
05:23:50 <SamB_XP> just use as the excuse that you couldn't find a more appropriate ticket type ;-)
05:24:32 <SamB_XP> (I think you can log in as guest/guest in order to create the ticket, if you don't want to register an account of your own)
05:24:36 <rivercheng> Maybe we could issue a feature-request ticket other than bug
05:24:49 <pozic> SamB_XP: so, the best thing is to write a custom datatype with Monoid instance?
05:24:57 <SamB_XP> eh, feature request sounds like you want someone to write code!
05:25:08 <SamB_XP> pozic: newtype I guess
05:25:14 <rivercheng> I see.
05:25:16 <SamB_XP> yeah
05:25:21 <pozic> SamB_XP: yes, same thing.
05:25:22 <rivercheng> Hi ,Sam. Thanks
05:25:45 <rivercheng> Does the laze feature affect the profiling?
05:26:13 <rivercheng> I mean it will cause the cost of other functions all to one single functions?
05:26:38 <SamB_XP> eh?
05:27:41 <quicksilver> pozic: a wrapping newtype, like First and Last.
05:27:59 <quicksilver> laziness can make profiling hard, but not for that reason.
05:28:09 <SamB_XP> and nobody would EVER want the fourth Maybe Monoid I spoke of
05:28:12 <rivercheng> I mean when I run function A, it force the lazy part of function B to be evaluated. Then the cost will be counted as A's or B's?
05:28:26 <b_jonas> SamB_XP: what's the fourth maybe monoid?
05:28:29 <ejt> is there a quick way of converting between lazy and strict bytestrings ?
05:28:39 <b_jonas> there's Left, Right, the one that gives constant Nothing, and?
05:28:47 <quicksilver> ejt: toChunks/fromChunks
05:28:59 <Deewiant> ejt: using the *Chunks is short, but not quick
05:29:00 <SamB_XP> the third one is not a monoid
05:29:00 <quicksilver> you might need Internals to get at them, I don't recall.
05:29:04 <b_jonas> oh, you mean when the argument is a monoid itself
05:29:09 <SamB_XP> the third you spoke of
05:29:14 <b_jonas> SamB_XP: hmm, yeah, it isn't
05:29:15 <quicksilver> rivercheng: B's.
05:29:19 <b_jonas> what are the three then?
05:29:20 <SamB_XP> yeah, that was the third and fourth ones
05:29:35 <SamB_XP> the fourth one would use the argument's monoid backwards
05:29:42 <b_jonas> oh, I see
05:29:46 <b_jonas> makes sense
05:29:46 <pozic> quicksilver: didn't b_jonas said First was already defined somewhere?
05:29:52 <pozic> say*
05:29:55 <b_jonas> pozic: yes, in Data.Monad
05:30:02 <Deewiant> Monoid*
05:30:09 <b_jonas> yeah, Data.Monoid
05:30:17 <b_jonas> I keep saying the wrong thing
05:30:17 <ejt> quicksilver: thx, I'm sure that's quicker than my (pack . unpack)
05:30:18 <b_jonas> sorry
05:30:20 <pozic> b_jonas: in what version?
05:30:25 <pozic> b_jonas: 6.8.3?
05:30:27 <rivercheng> quicksilver: Thanks.
05:30:31 <pozic> b_jonas: I am still at 6.8.2.\
05:30:34 <b_jonas> dunno, I'm reading it from http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
05:30:35 <lambdabot> Title: Data.Monoid, http://tinyurl.com/y5qk9n
05:30:59 <b_jonas> well, it's not too difficult to define it yourself if you don't have it of course
05:31:06 <b_jonas> @src First
05:31:06 <lambdabot> Source not found. That's something I cannot allow to happen.
05:31:13 <b_jonas> @src Data.Monoid.First
05:31:14 <lambdabot> Source not found.
05:31:37 <b_jonas> @kind Data.Monoid.First
05:31:40 <lambdabot> * -> *
05:31:56 <pozic> b_jonas: but is that module already in a release?
05:32:50 <rwbarton> You could also use [] and just read the first element
05:33:18 <pozic> b_jonas: oh, right, I now see what First and Last mean :)
05:38:32 <b_jonas> in 6.8.2: http://hpaste.org/9440
05:41:23 <hackage> Uploaded to hackage: formlets 0.2
05:41:51 <ivanm> is there a way of getting a random temp file (like the *nix command mktemp)?
05:42:05 <ivanm> I _could_ hard code a temp file name in, but that seems a little... dodgy :s
05:43:35 <quicksilver> well there is System.Posix.Temp
05:43:51 <quicksilver> and there is System.FilePath.getTemporaryDirectory
05:44:33 <ivanm> *nod*
05:45:03 <rwbarton> also openTempFile in System.IO
05:45:24 <ivanm> dammit.... now that I'm going to be storing the numeric data in a file rather than adding it in to the command to pipe into gnuplot later on, I've got to use the IO Monad :s
05:47:01 <ivanm> I presume openTempFile just calls System.Posix.Temp.mkstemp on posix machines?
05:57:13 <ivanm> is anyone here a gnuplot guru? I'm wanting to splot some 3d points, rotate it with my mouse, and _then_ save the resulting image... is there a way I can do this?
05:57:30 <sbahra> Yes
05:57:36 <sbahra> But I forget how.
05:57:45 <sbahra> ivanm, there is a gnuplot channel though.
05:58:01 <ivanm> (I'm meant to be plotting points generated by some PRNGs I have to write to demonstrate the spectral test, and I can't work out how to automatically rotate the graph to face the correct way)
05:58:08 <ivanm> sbahra: :o didn't think of that...
05:58:27 <ivanm> besides, I thought sumBy knowledge #haskell = everything! :p
05:58:53 <byorgey> ivanm: it is, but you have to sum over time as well as users
05:59:02 <ivanm> byorgey: ahhh
06:00:10 <quicksilver> ivanm: you also forgot to filter (`wantsToTell` ivanm)
06:00:43 <ivanm> quicksilver: well, whether they want to tell me or not is a different story :p
06:03:06 <pozic> Isn't plumbing monads the same as doing data-flow optimizations?
06:09:27 <hml> does haskell have an identity function?
06:09:38 <Stinger> id?
06:09:53 <Stinger> @src id
06:09:54 <lambdabot> id x = x
06:10:02 <dino-> and const!
06:10:05 <dino-> @src const
06:10:05 <lambdabot> const x _ = x
06:14:14 <hml> is there a built in \x y -> (x, y) ?
06:14:23 <tromp> (,)
06:14:51 <Axman6> > x , y
06:14:53 <lambdabot>   parse error on input `,'
06:14:54 <tromp> > (,) x y
06:14:55 <lambdabot>  (x,y)
06:15:00 <Axman6> heh, ok then
06:15:03 <dino-> :t (,)
06:15:04 <lambdabot> forall a b. a -> b -> (a, b)
06:15:47 <hml> tromp: dino- : thanks
06:15:56 <byorgey> @pl \x y -> (x,y)
06:15:56 <lambdabot> (,)
06:16:15 <Axman6> !hoogle a -> b -> (a, b)
06:16:22 <Axman6> @hoogle a -> b -> (a, b)
06:16:23 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
06:16:23 <lambdabot> Control.Monad.RWS.Strict.execRWS :: RWS r w s a -> r -> s -> (s, w)
06:16:23 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
06:16:29 <Axman6> o.O
06:16:32 <byorgey> heh
06:16:38 <byorgey> hopefully that will be better with hoogle 4
06:16:38 <Axman6> right, sleep time
06:17:42 <rwbarton> the hoogle 4 beta doesn't find (,) either
06:20:32 <byorgey> ah, too bad
06:20:32 <conal> Axman6: for somewhat subtle reasons, "," is not a regular infix operator.  used to be in the old ML days.
06:20:53 <byorgey> conal: what are the subtle reasons?
06:21:10 <byorgey> I've never understood why we can't have e.g. sections with (,)  like (1,)
06:21:18 <conal> byorgey: (a,b,c) isn't isomorphic to ((a,b),c) in a lazy language.
06:21:22 <hml> byorgey: that is a cool trick, using the pl there
06:21:43 <byorgey> conal: oh, I see!
06:21:48 <hml> > :pl \f g l -> (filter f) (map g l)
06:21:48 <lambdabot>  Parse error at "\f" (column 5)
06:21:57 <dino-> :t ((,) 1)
06:21:58 <lambdabot> forall t b. (Num t) => b -> (t, b)
06:22:00 <hml> @pl \f g l -> (filter f) (map g l)
06:22:00 <lambdabot> (. map) . (.) . filter
06:22:09 <hml> is the point free style a good idea in thiscase?
06:22:10 <Axman6> yuck
06:22:20 <conal> byorgey: yeah.  too bad, though, as things would sure be simpler (less ad hoc) if there were only binary pairs.
06:22:21 <Axman6> no, imo
06:22:24 <byorgey> hml: not in my opinion
06:22:26 <Axman6> . (.) .?
06:22:31 <Axman6> wtf is that!
06:22:33 <byorgey> although you don't need the parens around (filter f)
06:22:41 <Axman6> :t . (.) .
06:22:41 <byorgey> conal: indeed.
06:23:15 <Axman6> @type . (.) .
06:23:16 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
06:23:24 <byorgey> hml: personally, I'd probably write that as \f g -> filter f . map g
06:23:33 <Axman6> @type (.) (.) (.))
06:23:34 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
06:23:37 <Axman6> @type ((.) (.) (.))
06:23:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:23:40 <hml> @type map
06:23:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:24:00 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2452#comment:10 <-- excellent
06:24:01 <lambdabot> Title: #2452 (Add a flag to disable the implicit qualified import of every available mo ...
06:24:09 <conal> Axman6: if you like those compositions, see DeepArrow
06:24:13 <byorgey> Axman6: note that the type of (.) has been generalized in lambdabot
06:24:25 <hml> what's so great babout deeparrow?
06:24:31 <conal> Axman6: and note that you can toss in "first" and "second" arbitrarily
06:24:49 <Axman6> eh?
06:24:57 * Axman6 is quite sleepeh
06:25:16 <conal> Axman6: intersperse "first" and "second", along with "(.)"
06:25:22 <quicksilver> conal: and remove them coarbitrarily?
06:25:37 <conal> quicksilver: :)
06:25:42 <Axman6> @type first (.) . second (.) (.)
06:25:43 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
06:26:00 <Axman6> first there was one boob...
06:26:23 <conal> @type first . (.) . second . (.) . (.)
06:26:23 <lambdabot> forall d (f :: * -> *) d1 (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> (f (d1, f1 (f2 a)), d) -> (f (d1, f1 (f2 b)), d)
06:26:35 <byorgey> wheee
06:26:46 <conal> @type first.fmap.second.fmap.first.fmap
06:26:47 <lambdabot> forall d (f :: * -> *) d1 (f1 :: * -> *) d2 a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> (f (d1, f1 (f2 a, d2)), d) -> (f (d1, f1 (f2 b, d2)), d)
06:26:54 <Axman6> @pl first . (.) . second . (.) . (.)
06:26:54 <lambdabot> first . (.) . second . (.) . (.)
06:26:58 <Axman6> lame
06:27:07 <conal> first, second, and (.)  are semantic editor combinators.
06:27:12 <conal> composable ones
06:27:49 <b_jonas> > 1 `(,)` "foo"
06:27:49 <lambdabot>  Parse error at "(,)`" (column 4)
06:27:58 <Axman6> ok, before i go to bed, can someone explain what currying is? or a curried function... or... curry
06:28:15 <hml> #src .
06:28:17 <byorgey> curry is a spice often used in indian cuisine
06:28:17 <hml> @src .
06:28:18 <lambdabot> (f . g) x = f (g x)
06:28:18 <lambdabot> -- In lambdabot, it's been generalised to:
06:28:18 <lambdabot> (.) = fmap
06:28:35 <hml> @src fmap
06:28:35 <lambdabot> Source not found. It can only be attributed to human error.
06:28:35 <Axman6> byorgey: i don't believe that's true
06:28:38 <byorgey> currying is representing multi-arguemnt functions by one-argument functions which return other functions
06:28:57 <Axman6> example?
06:29:02 <b_jonas> @src curry
06:29:03 <lambdabot> curry f x y = f (x, y)
06:29:12 <byorgey> Axman6: actually, I guess you're right, it's a blend of spices, eh?
06:29:22 <Axman6> yup
06:29:29 <Axman6> yummy ones too
06:29:38 <byorgey> hehe, indeed =)
06:29:38 <Axman6> damnit, now i want curry!
06:29:48 <byorgey> anyway, as an example, take the function (+) which adds two numbers.
06:30:05 <byorgey> in non-curried form, you would write its type as (+) :: (Int,Int) -> Int
06:30:18 <byorgey> i.e. it takes a pair of two arguments, and returns their sum
06:30:28 <byorgey> in curried form, we have (+) :: Int -> Int -> Int
06:30:41 <byorgey> note that -> associates to the right, so we can also write that as (+) :: Int -> (Int -> Int)
06:31:04 <byorgey> this means that (+) just takes a single number as an argument, and returns a function which takes another number, and adds it to the first.
06:31:14 <byorgey> e.g.  (+) 2   is a function which adds 2 to its argument.
06:31:18 <Axman6> like (+10)?
06:31:51 <byorgey> well,  (+10) is actually a bit different, that's special haskell syntax called a 'slice', it's the same as  \x -> x + 10
06:32:04 <byorgey> but it's the same idea.
06:32:04 <Axman6> ok
06:32:23 <Axman6> anyway, sleep time. g'night all
06:32:30 <byorgey> night Axman6
06:32:34 <byorgey> dream of curry
06:33:00 <RayNbow> byorgey: spicy curry? :p
06:33:17 <Axman6> yes
06:33:24 <byorgey> yes, that kind =)
06:33:33 <dino-> That's interesting. Not exactly the same thing is going on betwen (+10) and ((+) 10)
06:33:47 <dino-> I guess the argument is in a different place in those two.
06:33:49 <Toxaris> (10 +) == (+) 10
06:33:56 <dino-> ya
06:34:02 <Toxaris> (+ 10) == flip (+) 10
06:34:18 <byorgey> dino-: right.  with + you can't tell the difference since it's commutative, of course, but it is different
06:34:41 <Toxaris> byorgey: who tells you that + is commutative?
06:34:50 <RayNbow> for Int it is
06:35:07 <b_jonas> not only for int, it's commutative for every sane numeric type
06:35:13 <byorgey> Toxaris: the little voices in my head?
06:35:13 <b_jonas> even floating-point ones
06:35:27 <byorgey> but you're right, you could easily make a Num instance where it isn't
06:36:30 <Toxaris> b_jonas: i would expect http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ANum to state laws which Num instances are expected to fullfill
06:36:31 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
06:36:45 <RayNbow> is there actually a way to force commutativity? (is there any research been done on this?)
06:38:45 <ddarius> b_jonas: There are perfectly sane definitions where (+) isn't commutative.
06:38:48 <Twey> > (10 +) == (+) 10
06:38:49 <lambdabot>   add an instance declaration for (Eq (t -> t))
06:38:49 <lambdabot>     In the expression: (10 +)...
06:39:05 <Twey> Aww.
06:39:26 <byorgey> @check \x -> (10+) x == (+) 10 x
06:39:27 <lambdabot>   Not in scope: `myquickcheck''
06:39:32 <byorgey> erm
06:39:41 <b_jonas> ddarius: for the + meaning the method in the haskell standard Num instance?
06:40:14 <Toxaris> > (x + y, y + x)
06:40:15 <lambdabot>  (x + y,y + x)
06:40:24 <ddarius> Yes.
06:40:47 <byorgey> ddarius: example?
06:41:13 <Toxaris> b_jonas: just gave one
06:41:15 <b_jonas> ddarius: byorgey seconded, please give some example
06:41:20 <ddarius> (+) = Add
06:41:23 <hackage> Uploaded to hackage: formlets 0.2.1
06:41:35 <b_jonas> ddarius: oh, yeah,
06:41:37 <b_jonas> symbolic
06:42:09 <b_jonas> but it's still supposed to be mostly commutative
06:42:28 <b_jonas> in that in any code you usually don't have to think whether you should write x+y or y+x, right?
06:42:28 <Toxaris> > ((x +) y, (+ x) y, (+) x y, flip (+) x y) -- :)
06:42:29 <lambdabot>  (x + y,y + x,x + y,y + x)
06:42:30 <dolio> (+) on lazy naturals is not commutative.
06:42:35 <b_jonas> even if the results aren't exactly the same
06:42:51 <b_jonas> dolio: ah, now that might be a good example actually
06:43:19 <Toxaris> dolio: why not?
06:43:46 <dolio> _|_ + omega = _|_, omega + _|_ = omega
06:44:12 <dolio> Etc.
06:44:18 <Toxaris> ok I see.
06:44:53 <dolio> SSSZ + _|_ = SSS_|_
06:45:29 <b_jonas> > (():():():())++undefined
06:45:29 <lambdabot>  Couldn't match expected type `[()]' against inferred type `()'
06:45:38 <b_jonas> > (():():():[])++undefined
06:45:39 <lambdabot>  [(),(),()Exception: Prelude.undefined
06:45:45 <b_jonas> > undefined++(():():():[])
06:45:46 <lambdabot>  Exception: Prelude.undefined
06:45:48 <Toxaris> b_jonas: thinking about it wouldn't help, since you cannot know what (+) does at all, since there are no laws about it in the Num documentation or in the Prelude. Therefore, one could argue that every function which uses Num should document the expected laws :)
06:45:49 <b_jonas> seems like
06:46:27 <b_jonas> Toxaris: I thought there were some expected rules only not in that prelude documentation
06:46:30 <b_jonas> but it seems no
06:46:50 <b_jonas> I think h89 don't give them either, even though it gives the Monad laws
06:47:05 <Toxaris> well, to conclude, Num is broken :)
06:48:35 <Toxaris> but of course, there is a unwritten standard that "if I write Num, I mean Num somewhat like Integer"
06:48:51 <Toxaris> and users have to guess what meaning of somewhat applies
06:49:46 <Cale> Num should approximately be a ring :)
06:50:09 <ddarius> How 'bout a near-rig?
06:50:17 <Cale> There are some misbehaved instances like Float and such
06:50:41 <ddarius> Associativity is asking too much.
06:50:48 <Cale> heh
06:50:54 <mattam> rig's don't get negation do they?
06:51:21 <Cale> I sort of wonder how effective just using CReals in place of Float/Double would be.
06:51:21 <mattam> Or is there some hidden pun in near-rig?
06:51:52 <Cale> It's an anagram of earring?
06:52:07 <vixey> Cale: I bet that would work much better for general purpose use, but not be suitable for only a things like OpenGL
06:52:12 <Toxaris> after learning about how IEEE floats work, I decided to never again use them
06:52:14 <vixey> only a few things*
06:52:31 <Cale> vixey: For performance reasons or simply interoperability?
06:52:48 <vixey> interoperability
06:53:04 <b_jonas> yeah, approximagely ring
06:53:22 <Toxaris> hehe approximagely is good
06:53:43 <pozic> Is CReal packaged?
06:53:43 <b_jonas> domain of Float isn't a ring but approximagely rings
06:54:08 <Cale> pozic: yes, the numbers package on Hackage has it
06:54:20 <__pao__> #join pypy
06:54:39 <mattam> /kick __pao__?
06:54:52 <pozic> Cale: how expensive are CReal operations?
06:55:06 <vixey> Â£100
06:55:11 <__pao__> mattam: that was a typo... sorry for that
06:55:34 <Cale> pozic: They seem reasonably efficient from what I've tested. I haven't used them in anything too serious though.
06:55:35 <mattam> That was / /join #pypy then :)
06:55:51 <__pao__> mattam: exactly :-)
06:57:13 <hml> how do i get lambdabot / ghci to show the parens?
06:57:24 <pozic> Cale: it has a nice simple API :)
06:57:43 <byorgey> hml: what parens?
06:57:54 <Cale> pozic: indeed :)
06:57:59 <mattam> Cale: how are they implemented? Do you have any reference?
06:58:06 <Asgaroth> Is there a shortcut notation for sorting a list by (f x), instead of using sortBy (\a b -> compare (f a) (f b)), which gets bit annoying after a while?
06:58:15 <Asgaroth> Or would I have to define one myself?
06:58:18 <Cale> mattam: the source code is available and fairly readable
06:58:23 <vixey> Asgaroth: comparing
06:58:27 <ddarius> sortBy (comparing f)
06:58:44 <hml> i mean, given a cojplex expression, how do i get ghci to tell me how it's parenthetixed, i.e. 1-2-3 -> (1-2)-3
06:58:46 <Asgaroth> vixey, ddarius: thanks
06:58:47 <wjt> @src comparing
06:58:47 <lambdabot> Source not found. :(
06:58:54 <wjt> @ty on
06:58:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:59:05 <wjt> @ty compare `on` ?f
06:59:06 <lambdabot> forall b a. (?f::a -> b, Ord b) => a -> a -> Ordering
06:59:06 <vixey> @src on
06:59:06 <lambdabot> (*) `on` f = \x y -> f x * f y
06:59:19 <byorgey> hml: ah.  I think there's a trick to that but I forget how it works...
06:59:19 <vixey> comparing = (compare`on`) -- doesn't it?
06:59:25 <Cale> actually, it's a bit funny... CReal's interface just might be a little too simple
06:59:54 <Cale> I doubt all the computable reals are available through that interface :)
07:00:08 <mattam> Can't find it using google, where is it?
07:00:23 <Cale> http://hackage.haskell.org/packages/archive/numbers/2008.4.20/numbers-2008.4.20.tar.gz
07:00:24 <lambdabot> http://tinyurl.com/6ztu8b
07:01:00 <Cale> data CReal = CR (Int -> Integer)
07:01:20 <hml> how do i get lambdabot to tlel me how an expression is parentherized, i.e. 1-2*3 -> 1-(2*3)
07:01:44 <hml> also, how do pull up the source for >>= for the LIst monad?
07:01:44 <mattam> thx
07:01:58 <sal23> Cale: what is the URL of your monad tutorial? Google is down for me...
07:02:21 <pozic> Etherbunny :)
07:02:25 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
07:02:27 <lambdabot> Title: Monads as computation - HaskellWiki
07:02:28 <Twey> sal23: http://www.haskell.org/haskellwiki/Monads_as_Computation
07:02:30 <lambdabot> Title: Monads as computation - HaskellWiki
07:02:30 <Twey> Damn
07:02:31 <Twey> Haha
07:02:35 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
07:02:36 <lambdabot> Title: Monads as containers - HaskellWiki
07:02:37 <Twey> I know it off by heard.
07:02:40 <Twey> heart.
07:02:44 <Botje> @src (>>=) []
07:02:44 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:02:48 <Botje> @src [] (>>=)
07:02:48 <lambdabot> xs >>= f     = concatMap f xs
07:02:49 <vixey> > let par s x y = "("++x++s++y++")" ; (-) = par "-" ; (*) = par "*" in "1"-"2"*"3"
07:02:50 <lambdabot>  "((1-2)*3)"
07:03:02 <sal23> Cale, Twey: thanks
07:03:04 <Cale> Oh, there's also http://www.haskell.org/haskellwiki/Introduction_to_IO if you're just looking to use basic I/O :)
07:03:05 <lambdabot> Title: Introduction to IO - HaskellWiki
07:03:13 <Cale> (but it's not exactly a monad tutorial :)
07:03:19 <Botje> vixey: woah. that's badass :)
07:03:26 <Botje> > 1 - 2 * 3 :: Expr
07:03:27 <sal23> nah, I have read the container tutorial before...just reviewing it again
07:03:27 <lambdabot>  1 - 2 * 3
07:03:44 <ddarius> Botje: You do realize that doesn't work.
07:03:44 <Twey> The computation tutorial is much better, IMO.
07:03:57 <vixey> instance Num String where
07:03:58 <ddarius> (vixey's approach that is)
07:03:58 <vixey>   fromInteger = show . fromIntegral
07:03:58 <vixey>   x+y = "(+ "++x++" "++y++")"
07:03:58 <vixey>   x*y = "(* "++x++" "++y++")"
07:04:04 <Botje> ddarius: kind of
07:04:07 <vixey> x = "x"
07:04:07 <vixey> y = "y"
07:04:23 <vixey> now you have, 3 * x + ( 9 + y ) * 4 == "(+ (* 3 x) (* (+ 9 y) 4))"
07:04:29 <hml> Botje: thanks
07:04:36 * Botje is amazed
07:04:41 <Botje> i keep learning new tricks
07:04:52 <Twey> Mmm Lispy
07:04:56 <Botje> haskell is very quickly losing its goal of not becoming popular.
07:05:03 <Twey> Heheh
07:05:11 <Twey> It was never going to last
07:05:11 <hml> vixey: wait, what r u doing, getting it to show it's paren?
07:05:28 <vixey> hml: yes exactly
07:05:55 <Cale> Botje: yeah, we need to raise the bar a bit. :)
07:06:18 <Cale> Maybe it's time to change the IO monad out for something a bit less familiar :)
07:06:22 <vixey> ok, How can we make haskell harder to learn? :)
07:06:33 <hml> how does concatMap and map differ?
07:06:41 <pozic> vixey: depends on what you mean by Haskell.
07:06:44 <ddarius> data S = N Integer | Add S S | Negate S | Sub S S | Mul S S deriving (Eq, Show); instance Num S where fromInteger = N; (+) = Add; (-) = Sub; (*) = Mul; negate = Negate
07:06:45 <Cale> hml: concatMap f xs = concat (map f xs)
07:06:51 <pozic> vixey: Haskell 98 is already full of gotchas.
07:07:07 <hml> how about we make haskell faster first? like ocaml fast before raising the bar
07:07:10 <byorgey> > map (replicate 3) [1,2,3]
07:07:11 <lambdabot>  [[1,1,1],[2,2,2],[3,3,3]]
07:07:15 <sw17ch> good morning
07:07:15 <lambdabot> sw17ch: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:07:16 <byorgey> > concatMap (replicate 3) [1,2,3]
07:07:18 <lambdabot>  [1,1,1,2,2,2,3,3,3]
07:07:24 <Cale> hml: That will make it more popular...
07:07:29 <hml> Cale: byorgey : got it, thanks
07:07:47 <Cale> hml: The goal is to keep it from becoming too popular, so that it remains flexible :)
07:07:54 <wjt> Cale: main :: Reactive ()  or something? :)
07:07:55 <byorgey> hml: Haskell is already plenty fast anyway.
07:08:20 <Cale> wjt: :)
07:08:23 <vixey> wjt: hehe
07:09:48 <BeelsebobWork> > [1,2,3] >>= (replicate 3)
07:09:49 <lambdabot>  [1,1,1,2,2,2,3,3,3]
07:10:15 <Cale> > [1,2,3] >>= join replicate
07:10:16 <lambdabot>  [1,2,2,3,3,3]
07:10:32 <sal23> Cale: isn't haskell in general fast enough to compete with OCaml? Well, comparisons are difficult but still is there general impression that Haskell is slower than OCaml?
07:10:38 <vixey> > map length . group $ [1..] >>= join replicate
07:10:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:10:49 <Cale> sal23: It's getting there.
07:11:05 <ddarius> On 64-bit machines, GHC is significantly slower that ocamlopt
07:11:19 <BeelsebobWork> hml: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all <-- Haskell benchmarks faster than OCaml
07:11:20 <Cale> sal23: The O'Caml guys spent a lot more time on good code generation, and they have a more traditional language, so standard things apply better.
07:11:22 <lambdabot> Title: Create your own Ranking | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language Benchma ..., http://tinyurl.com/lepfo
07:12:06 <Cale> sal23: However, there are supposed to be some really smart people working on GHC's code generation now.
07:12:19 <sal23> ddarius: what are the issues on 64-bit machines that is making GHC slower?
07:12:54 <pozic> To win the benchmark game, they could also just compile to OCaml from Haskell.
07:12:59 <sal23> Cale: there are re-write rules...so, if you pay attention to what you want to optimize, and know how haskell code is generated, I am sure you can show that it is fast enough
07:13:22 <ddarius> sal23: My understanding is that O'Caml has quite a lot of effort in the 64-bit backend whereas GHC has very little.
07:13:36 <sal23> interesting....
07:13:46 <quicksilver> sal23: 64 bit machines means almost twice as much data to process
07:13:54 <quicksilver> and GHC code is quite often memory-bottlenecked
07:14:02 * ddarius wants to see someone make ruby #1 in the shootout benchmark by choosing some combination of weights.
07:14:04 <quicksilver> AIUI.
07:14:13 <sal23> quicksilver: that would depend on how you use the registers IIRC
07:14:23 <quicksilver> sal23: GHC doesn't use the registers.
07:14:23 <quicksilver> ;)
07:14:35 <sal23> well, I mean the assembly code....
07:14:46 <BeelsebobWork> quicksilver: I was under the impression that some of the bugs in ghc 6.9 were mostly down to register allocation being buggy
07:14:55 <BeelsebobWork> namely, -- why it can't compile SHA1.hs
07:14:56 <quicksilver> GHC produces assembly code which doesn't use registers.
07:15:03 <quicksilver> that's not really true :)
07:15:06 <sal23> really....
07:15:11 <BeelsebobWork> (at least this is what Simon Marlowe told me)
07:15:14 <pozic> quicksilver: it must use a few registers ;)
07:15:15 <quicksilver> but GHC currently produces code which doesn't use registers very much.
07:15:20 <quicksilver> certainly not as much as it could / should
07:15:27 <quicksilver> BeelsebobWork: yes, that is certainly true.
07:15:42 <quicksilver> the pieces are falling into place with native code gen
07:15:51 <quicksilver> it is reasonable to expect it to get much better over the next 12 months, IMO.
07:16:21 <ddarius> Yeah.  6.12 or 7.2 or whatever is the version after 6.10 will likely be significantly faster than 6.8
07:16:35 <sal23> is the optimization focussed on x86_64, or also, on sparc (I know sun made a grant)?
07:16:40 <ddarius> 6.10 should already be a lot better
07:16:56 <quicksilver> sal23: the optimization is more focussed on the general stuff
07:17:01 <ddarius> sal23: The backend stuff started long before that.
07:17:02 <quicksilver> than the specific arch backends
07:17:18 <quicksilver> but, in general, the backends which get most work are x86_32 and x86_64
07:17:27 <quicksilver> the sparc project will also help, I hope
07:17:31 <pozic> Why can't there be one generic "optimizer" component shared by all compiler writers?
07:17:42 <vixey> that wouldn't work
07:17:43 <pozic> Would it make the compilers too slow?
07:17:47 <quicksilver> no
07:17:50 <sal23> no
07:17:55 <quicksilver> it's just different compilers produce very differnt kinds of code
07:17:58 <quicksilver> it's hard to be generic
07:18:04 <quicksilver> but see also: gcc and llbm
07:18:15 <quicksilver> gcc does share its backend between multiple front-ends
07:18:16 <BeelsebobWork> pozic: no, it's just some CPUs are fast at one thing, while others are fast at other things
07:18:23 <BeelsebobWork> so an optimisation for one, is the oposite for another
07:18:24 <quicksilver> and llvm is a (different) approach to sharing optimization
07:18:30 <pozic> BeelsebobWork: for the same CPU of course.
07:18:38 <ddarius> Let's just make whole program super optimizers.
07:18:46 <quicksilver> but a haskell frontend produces very different code to a C frontend
07:18:58 <BeelsebobWork> oh, well in that case -- still no, because different program styles are amenable to different optimisation techniques
07:19:04 <quicksilver> so an optimiser which was designed to work with code generated from C will do surprisingly poorly on haskell
07:19:08 <BeelsebobWork> e.g. Haskell is very amenable to whole program transformations
07:19:17 <BeelsebobWork> while C is very amenable to really low level twiddling
07:19:19 <quicksilver> ddarius: no, let's just wait for ndm to write one for us :)
07:19:26 <pozic> quicksilver: I am thinking of something that contains the sum of all those optimizations.
07:19:39 <quicksilver> pozic: you will find they don't sum cleanly.
07:19:39 <BeelsebobWork> pozic: often one can cancel out another
07:19:41 <quicksilver> they conflict.
07:19:42 <ddarius> quicksilver: ndm is not writing a super optimizer let alone a whole program one.
07:19:54 <BeelsebobWork> ddarius: he isn't?
07:20:00 <quicksilver> indeed some of them are precisely opposed to each other.
07:20:03 <BeelsebobWork> I thought ndm was writing all possible haskell programs all at the same time
07:20:06 <ddarius> supercompilation /= superoptimization
07:20:14 <quicksilver> A -> B and B -> A may both be optimisations
07:20:17 <quicksilver> under some circumstances
07:20:23 <quicksilver> like loop unrolling, for example.
07:20:29 <quicksilver> loop re-rolling can be an optimisation
07:20:38 <baaba> but not at the same time
07:20:41 <pozic> quicksilver: so, specify the circumstances for every language.
07:20:41 <quicksilver> ddarius: yes, he's writing a whole program super compiler, you're right.
07:20:52 <ivanm> is there a function that takes in a list of numbers and returns them in sublists grouped by a given tolerance? (e.g. if the given tolerance is 0.5, then there'd be a list of numbers 0<=x<1, 1<=x<2, 2<=x<3, etc.)
07:21:01 <quicksilver> the circumstances are not decidable, in general
07:21:02 <baaba> and an optimizer won't just blindly unroll loops
07:21:18 <pozic> quicksilver: I think the only problem is the overhead in CPU time for the compiler and the communication overhead between the developers.
07:21:18 <baaba> it'll look at various factors like how much will fit in cache etc
07:21:36 <baaba> or at least, a good optimizer for some sufficient value of "good" :)
07:21:43 <pozic> quicksilver: but you also have that problem when everyone writes their own compiler.
07:21:45 <ddarius> pozic: Then write one.
07:21:49 <ivanm> only thing I can think of is to start at the minimum, and do takeWhile/dropWhile recursively until the input list is all consumed :s
07:21:58 <EvilTerran> ivanm, groupBy ((==) `on` something)
07:22:13 <EvilTerran> > groupBy ((==) `on` floor) [0,0.2..]
07:22:14 <lambdabot>  [[0.0,0.2,0.4,0.6000000000000001,0.8],[1.0,1.2,1.4,1.5999999999999999,1.7999...
07:22:19 <EvilTerran> err
07:22:29 <EvilTerran> > groupBy ((==) `on` floor) [0,0.2::Rational..]
07:22:29 <lambdabot>  Parse error at "Ratio..." (column 35)
07:22:31 <EvilTerran> > groupBy ((==) `on` floor) [0,0.2::Rational ..]
07:22:32 <lambdabot>  [[0%1,1%5,2%5,3%5,4%5],[1%1,6%5,7%5,8%5,9%5],[2%1,11%5,12%5,13%5,14%5],[3%1,...
07:22:35 <rwbarton> possibly after sorting
07:22:47 <baaba> also llvm provides stuff you just can't get with static compilatin, ever, at all
07:23:01 <baaba> like regenerating code based on differing program input
07:23:03 <ivanm> EvilTerran: hmmmm....
07:23:07 <baaba> *compilation
07:23:56 <EvilTerran> ivanm, as rwbarton said, if you need non-contigous elements grouped, you'll need to sortBy (comparing something) first
07:24:02 <ivanm> so you'd want something like splitter x = groupBy ((==) `on` (floor . (/x)) . sort ?
07:24:19 <ivanm> EvilTerran: well, it wouldn't have to be sortBy really, just sort, but yes
07:24:35 <ivanm> I didn't think about doing floor though :s
07:25:08 * ivanm is trying to create a histogram out of a list of numbers, if anyone is interested :p
07:25:11 <noteventime> Has anyone used vertex buffers with HOpenGL?
07:25:29 <noteventime> (If it's called that nowadays)
07:25:32 <EvilTerran> ivanm, alternatively, you could just use (group . map floor . sort) in that case
07:25:48 <EvilTerran> if all you need is the size of each grouping
07:25:53 <ivanm> *nod*
07:30:19 <Asgaroth> Is there a replace function(replace every element foo by bar in a list) in the standard libs?(I know it takes just 2 lines to write one, but I prefer to use standard functions if available)
07:31:21 <dolio> map
07:31:27 <Cale> Not as far as I'm aware. [if x == k then v else x | x <- xs]  will work though.
07:33:34 * Twey wonders how clever \bot is...
07:33:43 <ddarius> Not very
07:34:21 <Twey> @pl \a b xs -> [if x == a then b else x | x <- xs]
07:34:21 <lambdabot> flip flip [] . ((flip . ((:) .)) .) . flip flip ((x | x) <-) . ((.) .) . if' . (x ==)
07:34:25 <Twey> Wah!
07:34:50 <Cale> heh, it doesn't understand list comprehension syntax :)
07:35:02 <ddarius> @. pl undo \a b xs -> [if x == a then b else x | x <- xs]
07:35:02 <lambdabot> ((=<<) .) . flip flip [] . ((flip . ((:) .)) .) . flip flip id . (ap .) . flip . (if' .) . (==)
07:36:51 <vixey> how do you write foldM for on a HOAS AST?
07:37:04 <gwern> 'Windows systems have a rough analog to tmpfs in the form of "Temporary temporary Files". ' <-- oh, that's good to know
07:40:25 <vixey> ohhhhh
07:40:35 <vixey> Now I understand why they want higher order unification
07:42:37 <pozic> Uh, this is odd: I went from looking up a value every single time in a list to just having direct access (no arrays or whatever) and it became slower?
07:42:37 <byorgey> wow, flip flip ((x | x) <-) ?
07:43:03 <Baughn> gwern: Um. "Temporary temporary files"?
07:43:15 <byorgey> pozic: what do you mean, "just having direct access" ?
07:43:29 <gwern> Baughn: yes, I was struck by the phrase
07:43:51 <Baughn> As opposed to.. what, permanent temporary files?
07:45:00 <seliopou> I think they were using repetition to underscore the... "transient nature" of the files
07:46:26 <pozic> byorgey: I first had map (\a -> f list a) xs and now map (\(a,b) -> a*b) xs. f here had to lookup b in a list.
07:46:54 <vixey> map (\a -> f list a) xs = map (f list) xs
07:47:13 <pozic> vixey: I was emphasising something...
07:47:16 <vixey> (\(a,b) -> a*b) = uncurry (*)
07:47:33 <pozic> vixey: and lambdabot can do this too...
07:47:36 <seliopou> vixey: that's pretty pointless
07:47:52 <gwern> @seen emertens
07:47:52 <lambdabot> I haven't seen emertens.
07:48:17 <seliopou> pozic: can we see f?
07:48:54 <pozic> seliopou: no, it is dependent on a lot of other stuff.
07:49:58 <pozic> It looks as if GHC somehow caches it, since it is not something that's that difficult to recognize, but I was under the impression that GHC's optimizer was not that good.
07:50:05 <vixey> pozic: yeah I know
07:56:22 <vixey> @w80 glom
07:56:23 <lambdabot> *** "glom" wn "WordNet (r) 2.0"
07:56:23 <lambdabot> glom
07:56:23 <lambdabot>      v 1: take by theft; "Someone snitched my wallet!" [syn: {hook}, {snitch},
07:56:23 <lambdabot>            {thieve}, {cop}, {knock off}]
07:56:23 <lambdabot>      2: seize upon or latch onto something; "The Republicans glommed
07:56:25 <lambdabot>         onto Whitewater"
07:56:27 <lambdabot>      [also: {glomming}, {glommed}]
07:56:54 <Twey> That's a nice word
07:57:11 * vixey gloms it for her code
07:57:55 <Twey> Haha
07:57:58 <Twey> glom a = ...
07:58:04 <vixey> yes :)
08:01:06 <b_jonas> what on earth, why does the example have snitch if it's the entry for glom?
08:01:36 <Baughn> Because they're synonyms?
08:01:46 <b_jonas> Baughn: so?
08:01:56 <b_jonas> it's a bloddy dictionary entry
08:02:06 <b_jonas> it can't use a synonym as an example
08:02:12 * Baughn wonders how "glon" turned into "glomp"
08:02:19 <Baughn> *glom, that is
08:03:33 <Twey> b_jonas: Looks like Webster
08:03:37 <Twey> Webster does that a lot
08:04:51 <b_jonas> maybe, but it doesn't match the entry for glom in this webster: http://www.merriam-webster.com/dictionary/glom
08:04:52 <lambdabot> Title: glom - Definition from the Merriam-Webster Online Dictionary
08:10:51 <vixey> I need a new name for a list or string ..
08:11:01 <vixey> kind of like sequence thing
08:11:24 <Baughn> Rope?
08:11:42 <b_jonas> queue
08:11:51 <Philippa_> vixey: what's different about it?
08:11:56 <Baughn> b_jonas: zippper
08:11:59 <b_jonas> deque, array, sequence,
08:12:11 <b_jonas> no wait, it's spelt dequeue
08:12:15 <vixey> It's different because it might not fit together like that (the way it was presented)
08:12:28 <Baughn> vixey: How /does/ it fit together?
08:12:32 <b_jonas> though array and seq are used
08:12:49 <b_jonas> some compound word?
08:12:56 <Baughn> Vixeylist
08:12:58 <b_jonas> foolist or fooseq for some value of foo
08:12:58 <quicksilver> sequence is a reasonable generic word
08:13:05 <quicksilver> if you're just looking for an english synonym
08:13:16 <b_jonas> orderedbag
08:13:21 <b_jonas> series
08:13:26 <Baughn> Ordered.. bag?
08:13:36 <b_jonas> yes, bag as in multiset
08:13:50 <Baughn> Well, I suppose..
08:13:51 <vixey> lol vixeylist
08:13:59 <Elly> vixeylist? :O
08:14:09 <Baughn> vixey: It would really help if we knew how a vixeylist differs from an ordinary list
08:14:25 <vixey> well I glom it then try and mash it together
08:14:37 <b_jonas> vlist, hlist, flist, glist, etc
08:14:39 <Elly> so it's more space-efficient than regular lists?
08:14:41 <vixey> so... I don't know, I just wanted a word that fit in with that
08:14:43 <b_jonas> (slist and plist are already used)
08:14:52 <rwbarton> blob
08:14:56 <Baughn> Knot
08:15:00 <Elly> Tangle
08:15:04 <b_jonas> wow
08:15:06 <b_jonas> nice words
08:15:06 <vixey> blob is the right kind of thing but it is ordered
08:15:10 <Elly> bag
08:15:11 <b_jonas> line?
08:15:15 <Baughn> Ordered blob?
08:15:18 <Elly> oh, someone already said that one
08:15:25 <Elly> hah, I like "ordered blob"
08:15:40 <b_jonas> as in a line is to a string as a string is to a rope
08:15:57 <Elly> what does that even mean?
08:16:00 <Baughn> b_jonas: That would make a line a single char
08:16:10 <Baughn> Or possibly an array of such
08:16:12 <b_jonas> thread or fibre?
08:16:16 <Baughn> Taken
08:16:40 <b_jonas> cord
08:16:43 <Baughn> Vine
08:16:46 <Elly> wire
08:16:49 <b_jonas> twine
08:16:54 <Baughn> Quine
08:16:56 <Elly> bale!
08:16:56 <b_jonas> oh, wire and vine are nice
08:16:58 <vixey> ooh
08:17:00 <vixey> I like Vine
08:17:17 <Baughn> Gives off an organic, changing feel
08:17:24 <Elly> a vine is like a rope except with nodes attached to the side
08:17:31 <wyrs> selam
08:17:38 <wyrs> kanalda türk var mý
08:17:39 <wyrs> ?
08:17:46 <camio> A new word for nodes is grapes?
08:17:47 <Baughn> Elly: Well, also it's self-repairing
08:18:56 <b_jonas> then there's road, street, alley
08:19:04 <b_jonas> way, freeway
08:19:10 <Elly> expressway!
08:19:12 <b_jonas> path
08:19:21 <Elly> wyrs: we speak english here usually
08:20:11 <quicksilver> plait!
08:20:14 <quicksilver> ribbon
08:20:28 <b_jonas> curve
08:20:35 <Elly> helix?
08:20:43 <Elly> for two lists that are attached to each other :)
08:20:50 <Elly> (at every element)
08:21:18 <b_jonas> I wonder, is there some synonym that's closer to list or sequence than string?
08:21:36 <Toxaris> > zip "ICFCIFFPFCFCFPFPCCFIFCCPF" "ICFPFICCIIFPPFCCICIFFCPFICCFP"
08:21:38 <lambdabot>  [('I','I'),('C','C'),('F','F'),('C','P'),('I','F'),('F','I'),('F','C'),('P',...
08:22:19 <b_jonas> strip?
08:22:38 <b_jonas> roll
08:22:50 <Elly> tape
08:22:53 <quicksilver> 'win 20
08:22:57 <b_jonas> ah, tape's nice
08:23:32 <b_jonas> also spool
08:23:33 <Toxaris> maybe "consecution" or "series", but both are, well, strange
08:23:45 <b_jonas> I already mentioned series
08:23:50 <b_jonas> but consecution is new I think
08:23:54 <Elly> 'consecution' is interesting
08:24:03 <b_jonas> I'm writing all the non-compunds up so we can recup
08:24:05 <Toxaris> b_jonas: sorry, didn't want to steal it
08:24:11 <b_jonas> s/recup/recap
08:24:32 <b_jonas> is consecution a real word?
08:24:51 <Deewiant> yes
08:24:57 <Toxaris> progression
08:25:03 <b_jonas> ah, progression is good
08:25:03 <Toxaris> (e.g. in musics)
08:25:38 <Toxaris> you already have column and row?
08:25:47 <b_jonas> are there good noun forms of some relevant verbs like order, follow,
08:25:50 <b_jonas> Toxaris: ah, no
08:25:53 <b_jonas> also not file
08:25:53 <Baughn> > iterate (+1) 0 !! 10000000
08:25:53 <Toxaris> what about file?
08:25:55 <lambdabot>  Tried to use too much memory
08:26:07 <b_jonas> how about ordering?
08:26:28 <Toxaris> linearization
08:26:41 <Toxaris> succession
08:27:02 <b_jonas> rank
08:27:27 <b_jonas> so we're searching only for ones that imply an ordering, right?
08:27:33 <b_jonas> not like set, collection
08:27:41 <b_jonas> belt?
08:29:46 <Toxaris> flow
08:29:52 <Toxaris> course
08:29:56 <b_jonas> are there some other organic ones?
08:30:00 <b_jonas> similar to vine
08:30:13 <Baughn> Well, twine..
08:30:19 <b_jonas> well?
08:30:22 <Toxaris> run
08:30:37 <Baughn> Stalk?
08:31:11 <b_jonas> are some of stick, branch, shoot good enough?
08:31:18 <Toxaris> warp
08:31:37 <b_jonas> wow, we're reaching obscure english words I'm unfamiliar with
08:31:49 <Baughn> Weft
08:32:04 * b_jonas gets a dictionary
08:32:14 <b_jonas> also just order
08:32:50 <quicksilver> Ooh. When did lambdabot get explicit memory limits like that?
08:33:03 <Baughn> Yarn, heddle, band
08:33:05 <Toxaris> cable, cord, rope, wire, lead, hawser
08:33:06 <b_jonas> (alley array bale belt blob branch consecution coulmn course curve dequeue fibre
08:33:06 <b_jonas> file flow helix knot line linearization list order ordering path plait
08:33:06 <b_jonas> progression queue rank ribbon road roll rope row run sequence series shoot
08:33:06 <b_jonas> stalk stick street string strip succession tangle tape thread vine warp way
08:33:06 <b_jonas> weft well wire)
08:33:10 <BMeph> conglomeration! :)
08:33:24 <Toxaris> tail
08:33:27 <Baughn> quicksilver: Hm. Not so long ago.. a month?
08:33:36 <BMeph> Or, "con-glom" for short... ;)
08:33:37 <Toxaris> trail
08:33:41 <trofimovich> Does anyone have UTF-8 patch for lambdabot?
08:33:48 <trofimovich> > "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
08:33:49 <lambdabot>  "\1087\1088\1080\1074\1077\1090"
08:33:57 <quicksilver> Baughn: I was only away for a fortnight. It must have been less.
08:34:07 <b_jonas> directions?
08:34:10 <quicksilver> trofimovich: doesn't that demonstrate that it *is* supporting UTF8?
08:34:12 <b_jonas> recipe?
08:34:13 <Toxaris> strand
08:34:38 <trofimovich> quicksilver: it does not output utf string i gave
08:34:57 <b_jonas> imperative program? that implies an ordered collection of statements :-)
08:35:01 <Toxaris> fiber/fibre, yarn
08:35:02 <Toxaris> hair
08:35:14 <quicksilver> trofimovich: looked OK to me? it had the right number of characters at least?
08:35:18 <BMeph> trofimovich: Ð—Ð´Ñ€Ð°Ð²ÑÑ‚Ð²Ñ‹Ð¹!
08:35:23 <b_jonas> tutorial, book, novel, text, ...?
08:35:26 <quicksilver> trofimovich: you gave it a 6 char string, it replied with a 6 char string?
08:35:33 <b_jonas> sentence
08:35:41 <quicksilver> I'm not on a unicode terminal so I can't check the codepoints
08:35:43 <b_jonas> I guess I'll include only "text"
08:35:46 <trofimovich> quicksilver: show does not non-ascii letters at all?
08:36:19 <quicksilver> trofimovich: show always produces 7-bit clean output
08:36:23 <BMeph> trofimovich: ÐšÐ°Ðº Ð´ÐµÐ»Ð°?
08:36:24 <quicksilver> trofimovich: this is a feature, not a bug.
08:36:38 <Toxaris> trofimovich: show is for computer-readable output, not human-readable
08:36:42 <quicksilver> show doesn't know what the text encoding might be of the context it gets embedded in.
08:36:43 <trofimovich> BMeph: Ð½ÐµÐ¿Ð»Ð¾Ñ…Ð¾. Ð’Ð¸ÑˆÑŒ Ð²Ð¾ÑŽÑŽ Ð·Ð° i18n :]
08:37:07 <b_jonas> trofimovich: are those addittional synonyms?
08:37:07 <wyrs> heeey
08:37:11 <b_jonas> :)
08:37:13 <wyrs> what the fuck up man ?
08:37:16 <quicksilver> but the mere fact it's producing code points like \1087 shows it interpreted unicode input
08:37:22 <quicksilver> I presume, correctly.
08:37:22 <wyrs> \111
08:37:36 <Toxaris> dash, streak, stroke
08:37:36 <trofimovich> i think it's not unicode, it's utf8
08:37:39 <Toxaris> bar
08:37:55 <quicksilver> trofimovich: this is IRC, so yes, it's interpreting UTF8 as unicode
08:38:04 <quicksilver> UTF8 is the 'de-facto' standard on IRC these days.
08:38:13 <trofimovich> ghc internally stores chars as UCS-2/4 ?
08:38:13 <Toxaris> what do we do with the sequence synonyms now?
08:38:27 <quicksilver> trofimovich: in principle it depends on the OS I think
08:38:33 <b_jonas> quicksilver: it's not used on all irc channels
08:38:36 <quicksilver> trofimovich: under GNU libc it uses wchar
08:38:53 <trofimovich> i see. fixed string
08:38:54 <b_jonas> but it's the most popular
08:39:06 <trofimovich> i meant fixes char size
08:39:08 <quicksilver> b_jonas: that's what I meant by de facto, really
08:39:12 <quicksilver> trofimovich: yes, fixed size.
08:39:14 <b_jonas> quicksilver: yep
08:39:27 <quicksilver> trofimovich: at least, under GNU libc
08:39:33 <trofimovich> > toUpper "hello"
08:39:33 <quicksilver> under windows perhaps it uses some abomination
08:39:34 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
08:39:35 <quicksilver> I don't know.
08:39:38 <b_jonas> quicksilver: in fact, two of the hungarian channels I visit have changed from 8859-2 to utf-8 only within the last years
08:39:40 <trofimovich> > map toUpper "hello"
08:39:41 <lambdabot>  "HELLO"
08:40:08 <jinjing> > show "hello"
08:40:09 <lambdabot>  "\"hello\""
08:40:11 <b_jonas> squiggle?
08:40:20 <jinjing> show "æµ‹è¯•"
08:40:28 <jinjing> > show â€œæµ‹è¯•"
08:40:28 <lambdabot>  Illegal character ''\8220''
08:40:28 <lambdabot>  at "KÕ"" (column 6)
08:40:40 <trofimovich> lambdabot can output stats for niks, and there we have absolute mess
08:40:51 <jinjing> > show "æµ‹è¯•"
08:40:52 <lambdabot>  "\"\\27979\\35797\""
08:40:52 <b_jonas> 69 synonyms so far
08:41:01 <b_jonas> I'll publish it somewhere later
08:42:04 <b_jonas> are some of draw, draft, drawing, doodle, scribble good?
08:42:20 <Toxaris> what about tube and hose
08:42:40 <b_jonas> Toxaris: ah, yeah
08:43:45 <Toxaris> bone and vein
08:44:07 <osfameron> dammit, I want haskell lazy sequences in a spreadsheet
08:44:34 <Toxaris> leg
08:44:59 <b_jonas> arm
08:45:01 <Toxaris> crural as an adjective means "belongs to the leg"
08:45:03 <trofimovich> @type unsafePerformIO
08:45:04 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:45:13 <trofimovich> @hoogle unsafePerformIO
08:45:13 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
08:45:13 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
08:45:29 <b_jonas> worm
08:45:33 <Toxaris> snake
08:45:34 <b_jonas> snake
08:45:35 <b_jonas> yeah
08:45:36 <Twey> IO a -> a?
08:45:40 <Twey> Eek
08:45:45 <trofimovich> unsafe! :]
08:45:51 <Toxaris> Twey: well, its *unsafe* *perform* *IO*
08:45:55 <Twey> Hahahaha, aye
08:46:03 <b_jonas> speech?
08:46:07 <Toxaris> Twey: so the IO actually happemns
08:46:11 <Toxaris> thought
08:46:20 <Toxaris> reasoning
08:46:21 <Twey> Telepathy?
08:46:21 <b_jonas> (speech implies long and boring to me, so it's definitely long)
08:46:22 <Toxaris> argument
08:46:33 <Toxaris> speech is ordered
08:46:36 <Toxaris> sometimes
08:46:40 <b_jonas> yeah
08:47:07 <Toxaris> ray
08:47:39 <trofimovich> i've just read about arrays in haskell and have messed 'em all. So which is the most efficient in memory/speed?
08:47:47 <b_jonas> rail
08:48:01 <Toxaris> beam, jet
08:48:16 <trofimovich> (for small obj like Int)
08:49:17 <BeelsebobWork> @index on
08:49:17 <lambdabot> bzzt
08:49:21 <Toxaris> trofimovich: STUArray lets you implement array-modifying algorithms in c-style
08:49:24 <Deewiant> Data.Function
08:49:31 <BeelsebobWork> is `on` part of Caleskell?
08:49:36 <Deewiant> no
08:49:37 <Deewiant> Data.Function
08:49:40 <BeelsebobWork> ah, cool
08:49:41 <BeelsebobWork> cheers
08:49:46 <Deewiant> no problem
08:49:53 <trofimovich> Toxaris: thanks!
08:50:20 <Toxaris> trofimovich: if you don't want to change individual elements, UArray may be easier to use
08:50:47 <Toxaris> trofimovich: and if you want / can make use of laziness, Array may be actually faster
08:50:57 <Deewiant> and IOUArray should be identical to STUArray but in the IO monad?
08:51:01 <Toxaris> indeed
08:51:14 <Toxaris> but ST is cooler, of course :)
08:51:36 <Toxaris> because there is runSTUArray
08:51:55 <Toxaris> which let you embed a c-style array algorithm in an otherwise pure piece of code
08:52:08 <vixey> yes
08:52:27 <Toxaris> so you have "local mutable state"
08:52:27 <vixey> If I had QQ working I was thinking about making a procedural language to embed
08:54:12 <Toxaris> b_jonas: do we have trip, way, road, track, drive, journey, ride, run, tour?
08:54:37 <b_jonas> some are new
08:54:56 <Toxaris> sooo many words all meaning the same, given enough context
08:54:58 <Toxaris> funny
08:55:33 <trofimovich> > "hello" >>= (return.toUpper)
08:55:34 <lambdabot>  "HELLO"
08:55:59 <b_jonas> 97 bso far: http://hpaste.org/9445
08:56:08 <Toxaris> > toUpper . "hello"
08:56:09 <lambdabot>  "HELLO"
08:56:19 <Toxaris> :)
08:56:25 <trofimovich> why does it work?
08:56:26 <b_jonas> maybe we need a bot to automate collecting such words
08:56:38 <Twey> > toUpper 'a'
08:56:39 <lambdabot>  'A'
08:56:40 <Toxaris> @src .
08:56:40 <lambdabot> (f . g) x = f (g x)
08:56:40 <lambdabot> -- In lambdabot, it's been generalised to:
08:56:40 <lambdabot> (.) = fmap
08:56:43 <Twey> Hmnhmnhmn.
08:57:05 <b_jonas> in fact, I think I could do that with my bot, but I'm not allowed to bring that in #haskell so I won't
08:57:05 <trofimovich> because of fmap?
08:57:11 <Toxaris> trofimovich: so in here, (.) is fmap, and generally, fmap can be map
08:57:22 <trofimovich> @src fmap
08:57:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:57:31 <Toxaris> @src [] fmap
08:57:32 <lambdabot> fmap = map
08:57:43 <b_jonas> let me run a spell checker on them
08:57:49 <trofimovich> @help src
08:57:49 <lambdabot> src <id>. Display the implementation of a standard function
08:57:55 <Toxaris> trofimovich: generally, x >>= return . f  ==  fmap f x,  for sane Monad and Functor instances
08:58:39 <trofimovich> fmap is lambdabot's extension ? of Moand class function?
08:58:42 <Toxaris> src <instance> <method>. Display the implementation of a standard method in a standard instance
08:58:53 <Toxaris> trofimovich: fmap is not special to lambdabot
08:59:16 <rwbarton> @type fmap
08:59:16 <Toxaris> trofimovich: fmap is like map, but not only for lists
08:59:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:59:23 <trofimovich> ah class Functor
08:59:24 <Toxaris> > fmap succ (Just 3)
08:59:25 <lambdabot>  Just 4
08:59:30 <Toxaris> > fmap succ [1, 2, 3]
08:59:31 <lambdabot>  [2,3,4]
08:59:43 <trofimovich> fmap (+1) [1..]
08:59:58 <RayNbow> > succ . [1,2,3]
08:59:58 <trofimovich> > fmap (+1) [1..]
08:59:59 <lambdabot>  [2,3,4]
09:00:00 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
09:00:03 <Toxaris> > (fmap fmap fmap) succ [("hello", 41), ("whatever", 22)]
09:00:04 <lambdabot>  [("hello",42),("whatever",23)]
09:00:10 <BMeph> We don't have "woof". Can't have a warp w/o a woof... ;)
09:00:31 <Twey> Hahahahaha
09:00:41 <Twey> We call it 'weft'
09:01:10 <trofimovich> what about all there words? are you playing some game?
09:01:21 <b_jonas> walk
09:01:31 <Toxaris> direction
09:01:32 <Baughn> quicksilver: No, I wrote the patch july 3rd
09:02:15 <Baughn> quicksilver: * Set maximum heap size for runplugs
09:02:24 <Toxaris> trofimovich: <b_jonas> I wonder, is there some synonym that's closer to list or sequence than string?
09:02:25 <b_jonas> lane
09:02:35 <b_jonas> vector
09:02:38 <b_jonas> how could we forget that?
09:02:45 <Toxaris> avenue
09:02:52 <Toxaris> vector sounds so c++-ish
09:02:59 <quicksilver> Baughn: cool.
09:03:04 <trofimovich> deque :p
09:03:16 <RayNbow> <Toxaris> > (fmap fmap fmap) succ [("hello", 41), ("whatever", 22)] <-- ((,) a) is in the functor class?
09:03:26 <b_jonas> trofimovich: yeah, we mentioned that but then I thought I'd remove it because it's compound
09:03:31 <b_jonas> I'll add it back though
09:03:39 <b_jonas> but isn't it spelt dequeue?
09:04:01 <trofimovich> @dict deque
09:04:02 <lambdabot> Supported dictionary-lookup commands:
09:04:02 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:04:02 <lambdabot> Use "dict-help [cmd...]" for more.
09:04:02 <Toxaris> RayNbow: yep, but the instance is somewhat hidden
09:04:13 <trofimovich> @dict jargon deque
09:04:13 <lambdabot> Supported dictionary-lookup commands:
09:04:13 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:04:13 <lambdabot> Use "dict-help [cmd...]" for more.
09:04:14 <Baughn> > fmap (+1) (0,0)
09:04:15 <lambdabot>  (0,1)
09:04:35 <trofimovich> @type (fmap fmap)
09:04:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
09:05:03 <trofimovich> does it have same effect as fmap ?
09:05:13 <Toxaris> RayNbow: the cool thing about (fmap fmap fmap) is that it can be written as ((<$>) . (<$>)), the greedy monster combinator
09:05:28 <b_jonas> is bow good?
09:05:34 <b_jonas> no I guess it isn't
09:05:39 <Toxaris> trofimovich: fmap fmap is not much worth, but consider (fmap . fmap)
09:05:43 <Toxaris> @type fmap . fmap
09:05:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:05:45 <RayNbow> Toxaris: heh...
09:05:51 <b_jonas> how about program and script though, in the non-computer sense
09:06:00 <Toxaris> trofimovich: that's fmapping into a nested functor
09:06:15 <b_jonas> like TimToady says, "script is what you give to the actors, program is what you give to the audience"
09:06:18 <Toxaris> trofimovich: now, since fmap = (.) for the (-> r) functor, we can write that as (fmap fmap fmap)
09:06:19 <trofimovich> too hard without examples :]
09:06:42 <Toxaris> > (fmap . fmap) succ [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
09:06:43 <lambdabot>  [[2,3,4],[5,6,7],[8,9,10]]
09:06:48 <b_jonas> flight?
09:06:53 <Toxaris> trofimovich: one fmap for each layer of lists
09:07:25 <Toxaris> > (fmap . fmap) [Just 41, Nothing, Just 22] -- trofimovich: one fmap for list, one for Maybe
09:07:26 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
09:07:30 <trofimovich> would be great having macroexpand1 from lisp here :]
09:07:34 <Toxaris> > (fmap . fmap) succ [Just 41, Nothing, Just 22] -- trofimovich: one fmap for list, one for Maybe
09:07:36 <lambdabot>  [Just 42,Nothing,Just 23]
09:07:55 <Toxaris> > (fmap . fmap) f [Just 41, Nothing, Just 22] -- lets try this
09:07:56 <lambdabot>  Add a type signature
09:08:00 <trofimovich> @type fmap
09:08:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:08:19 <Toxaris> > (fmap . fmap) f [Just 41, Nothing, Just x] -- lets try this
09:08:20 <lambdabot>  Add a type signature
09:08:23 <Toxaris> :(
09:08:28 <trofimovich> @pl fmap fmap fmap
09:08:28 <lambdabot> fmap fmap fmap
09:08:31 <trofimovich> :\
09:08:34 <Toxaris> > fmap f [x, y, z]
09:08:35 <lambdabot>  Add a type signature
09:08:35 <pozic> Can I tell GHC to keep intermediate files?
09:08:40 <trofimovich> where is join ?
09:08:46 <geezusfreeek> @unpl fmap fmap fmap
09:08:47 <lambdabot> fmap fmap fmap
09:08:49 <Deewiant> @index join
09:08:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:08:50 <RayNbow> > fmap f [a,b,c]
09:08:51 <lambdabot>  Add a type signature
09:08:56 <RayNbow> oh
09:08:58 <Deewiant> > fmap f [x,y,z] :: [Expr]
09:08:59 <lambdabot>  [f x,f y,f z]
09:09:03 <Toxaris> trofimovich: fmap fmap fmap /= join fmap fmap
09:09:09 <Toxaris> trofimovich: look at the types!
09:09:14 <b_jonas> oh, we forgot a good one:
09:09:14 <b_jonas> trail
09:09:24 <trofimovich> @type join
09:09:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:09:26 <damg> @index Expr
09:09:26 <lambdabot> bzzt
09:09:38 <Toxaris> b_jonas: I mentioned that one
09:09:54 <b_jonas> Toxaris: did you? I must have missed
09:10:04 <trofimovich> @ type :: [Expr]
09:10:08 <trofimovich> @type :: [Expr]
09:10:09 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:10:21 <vixey> @kind [Expr]
09:10:21 <lambdabot> *
09:10:23 <Toxaris> @type x
09:10:24 <lambdabot> Expr
09:10:29 <trofimovich> :: [Expr] what is it?
09:10:34 <b_jonas> indeed, irc window shows it
09:10:37 <lilac> > (fmap . fmap) f [Just 41, Nothing, Just 22] :: [Maybe Expr]
09:10:38 <lambdabot>  [Just (f 41),Nothing,Just (f 22)]
09:10:42 <vixey> trofimovich: Do you know what :: means?
09:10:43 <Deewiant> > 1 :: Int
09:10:44 <lambdabot>  1
09:10:46 <trofimovich> yes
09:10:47 <Deewiant> > 1 :: Float
09:10:48 <lambdabot>  1.0
09:10:53 <trofimovich> type signature
09:10:58 <Toxaris> @where simplereflect
09:10:58 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:11:15 <Toxaris> trofimovich: ^^^^^ about Expr
09:11:22 <trofimovich> thanks
09:11:53 <Toxaris> lilac: cool thanks
09:12:02 <trofimovich> seems like macroexpand is here :]
09:12:19 <b_jonas> why doesn't hpaste announce work?
09:12:26 <quicksilver> the bot isn't here
09:12:42 <b_jonas> could someone look through the list of synonyms to check if anything should be removed: http://hpaste.org/9445#a1
09:12:51 <b_jonas> then I guess I'll post somewhere on the haskell wiki
09:12:54 * vixey wonders what AH means
09:13:07 <b_jonas> also any missing ones of course
09:13:16 <b_jonas> vixey: at home? not sure
09:13:19 <vixey> oo
09:13:20 <RayNbow> vixey, http://www.ah.nl/ ?
09:13:21 <lambdabot> Title: AH Homepage - Albert Heijn
09:13:28 <vixey> did you make a program to find synonyms?
09:13:33 <b_jonas> vixey: no
09:13:36 <trofimovich> @type (^) :: Expr
09:13:36 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:13:40 <b_jonas> I just collected all we mentioned here by hand
09:13:43 <vixey> I should do that at some point
09:13:47 <quicksilver> b_jonas: yes, you did. An organic program.
09:13:50 <b_jonas> and then sorted, uniqued, and counted by hand
09:13:56 <Toxaris> computational linguistics
09:13:58 <quicksilver> b_jonas: running on the machine called '#haskell'
09:13:59 <b_jonas> sorry
09:14:05 <quicksilver> b_jonas: of which we are merely components :)
09:14:06 <b_jonas> and then sorted, uniqued, and counted automatically
09:14:08 <b_jonas> that's what I mean
09:14:22 <b_jonas> quicksilver: yeah, it's like a hivemind
09:14:55 <trofimovich> @type (^) :: [Expr]
09:14:56 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:14:58 <quicksilver> in soviet russia, #haskell PROGRAMS YOU
09:15:04 <b_jonas> that's what makes it a good community
09:15:09 <trofimovich> > (x^x) :: [Expr]
09:15:10 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
09:15:20 <Deewiant> > x^x
09:15:22 <lambdabot>  Tried to use too much memory
09:15:26 <Deewiant> O_o
09:15:32 <RayNbow> > x ^ 3
09:15:34 <lambdabot>  x * x * x
09:15:35 <trofimovich> is x already defined?
09:15:43 <RayNbow> :t x
09:15:43 <lambdabot> Expr
09:15:51 <Toxaris> @type ^
09:15:52 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:15:54 <trofimovich> @t xx
09:15:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:15:57 <RayNbow> :t (^)
09:15:58 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:16:13 <trofimovich> :t xx
09:16:33 <b_jonas> where should I add the list of list synonyms on the haskell wiki?
09:16:54 <lilac> Deewiant: x^x doesn't work, because it never reaches the base case. Eq and Ord on Expr are done via string comparisons on the representation
09:16:54 <trofimovich> > x^1
09:16:55 <lambdabot>  x
09:17:05 <trofimovich> > x^y
09:17:05 <quicksilver> trofimovich: yes, a-z are defined.
09:17:07 <lambdabot>  Tried to use too much memory
09:17:08 <b_jonas> how about serialization or marshalling?
09:17:19 <trofimovich> > x * y
09:17:21 <lambdabot>  x * y
09:17:31 <trofimovich> > let x = 2 in x * y
09:17:32 <lambdabot>  2 * y
09:17:47 <trofimovich> how about eval the result ?
09:17:54 <trofimovich> @type let x = 2 in x * y
09:17:54 <Deewiant> @src (^)
09:17:56 <Toxaris> @src ^ -- not a method
09:17:58 <lambdabot> x ^ 0            =  1
09:18:02 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
09:18:06 <lambdabot>   where f _ 0 y = y
09:18:12 <lambdabot> Plugin `source' failed with: thread killed
09:18:26 <Toxaris> now we confused pour \bot
09:18:31 <Toxaris> s/pour/poor
09:18:50 <trofimovich> > map f [1..]
09:18:51 <lambdabot>  Add a type signature
09:18:57 <trofimovich> > map f [1..] :: [Expr]
09:18:58 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 17...
09:19:08 <trofimovich> > map f [1..] :: Expr
09:19:08 <Toxaris> > x ** y
09:19:09 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
09:19:10 <lambdabot>  x**y
09:19:12 <b_jonas> apparently marshaling is spelt with a single l
09:19:28 <trofimovich> > (f x, fy) :: (Expr, Expr)
09:19:29 <lambdabot>   Not in scope: `fy'
09:19:31 <trofimovich> > (f x, f y) :: (Expr, Expr)
09:19:31 <Baughn> Sure. It's derived from the military rank.
09:19:32 <lambdabot>  (f x,f y)
09:19:34 <Baughn> Or possibly the other way around
09:19:49 <lilac> > zipWith ($) (iterate f) [1..]
09:19:49 <lambdabot>  Couldn't match expected type `[a -> b]'
09:19:49 <b_jonas> let me reask, where should I post it on the wiki?
09:20:18 <b_jonas> chain?
09:21:46 <b_jonas> connection or relation are too generic, or aren't they?
09:21:54 <b_jonas> I guess they're ok enough
09:21:57 <b_jonas> I'll add them too
09:21:57 <trofimovich> >           Syn:
09:21:58 <trofimovich>        progression, series, succession
09:22:03 <lambdabot>   parse error on input `}'
09:22:44 <b_jonas> trofimovich: already have those three
09:22:59 <lilac> > zipWith ($) (iterate (f.) id) [1..] :: [Expr]
09:23:01 <lambdabot>  [1,f 2,f (f 3),f (f (f 4)),f (f (f (f 5))),f (f (f (f (f 6)))),f (f (f (f (f...
09:23:06 <trofimovich> are you collecting all of them?
09:23:47 <b_jonas> trofimovich: yes
09:23:56 <b_jonas> well, all except those I miss accidentally
09:24:29 <trofimovich> are you extending a someone's dictionary? or for fun?
09:25:59 <trofimovich> > foldl f [a,b,c]
09:26:00 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
09:26:22 <Baughn> > foldl1 f [a,b,c]
09:26:23 <lambdabot>  f (f a b) c
09:26:24 <trofimovich> why bot can't do it itself?
09:26:31 <Baughn> @type foldl
09:26:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:26:35 <trofimovich> > foldr f [a,b,c]
09:26:36 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
09:26:45 <Deewiant> > foldr (+) [0,1,2]
09:26:46 <lambdabot>   add an instance declaration for (Num [t])
09:26:48 <quicksilver> you're using foldr and foldl wrong.
09:26:57 <trofimovich> oops
09:26:57 <quicksilver> they take three parameters not two.
09:27:06 <trofimovich> > foldr f x [a,b,c]
09:27:07 <lambdabot>  f a (f b (f c x))
09:27:22 <b_jonas> Baughn: when you said "zipper" very early, is that supposed to be one of the synonyms?
09:27:43 <trofimovich> @src foldl
09:27:43 <lambdabot> foldl f z []     = z
09:27:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:27:47 <trofimovich> @src foldl1
09:27:47 <lambdabot> foldl1 f (x:xs) = foldl f x xs
09:27:47 <lambdabot> foldl1 _ []     = undefined
09:27:54 <Baughn> b_jonas: With the amount of information I had, it very well might be
09:28:00 <Baughn> It's taken, of course, but so are many of the others
09:28:07 <b_jonas> ok
09:28:15 <trofimovich> @src foldl'
09:28:15 <lambdabot> foldl' f a []     = a
09:28:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:28:32 <trofimovich> @src foldl
09:28:32 <lambdabot> foldl f z []     = z
09:28:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:28:33 <b_jonas> and it's not actually spelt with a triple "p", right?
09:29:23 <trofimovich> @type seq
09:29:24 <lambdabot> forall a t. a -> t -> t
09:29:51 <trofimovich> is forall - haskell98 feature?
09:29:52 <ahunter> Hey, I'm having some trouble with withArray;   I'm passing it a list of Int (say, [1,2,3,4]) and instead of giving me an C array with 1,2,3,4, it seems to be giving me 1,0,2,0,3,0,4,0...any idea why?
09:29:56 <Deewiant> trofimovich: no
09:30:10 <Deewiant> ?ty withArray
09:30:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:30:15 <Deewiant> ?hoogle withArray
09:30:15 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
09:30:15 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
09:30:15 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
09:30:26 <Twey> What does 'forall' actually do?
09:30:31 <trofimovich> but most modern hascell compilers support it?
09:30:37 <b_jonas> created http://haskell.org/haskellwiki/StringSynonyms
09:30:37 <lambdabot> Title: StringSynonyms - HaskellWiki
09:30:48 <b_jonas> now let's link it from somewhere
09:30:49 <Baughn> trofimovich: Lh
09:30:52 <trofimovich> it's like template<> in C++ i suppose
09:30:59 <Deewiant> ahunter: maybe you've got the types wrong or something (treating Int as CInt or vice versa, perhaps?)
09:31:02 <Baughn> trofimovich: Er.. Oh, and you almost never want foldl. You want either foldr or foldl'
09:31:16 <Baughn> For "never" values of "almost never", I think
09:31:26 <Deewiant> > foldl (flip f) z [a,b,c]
09:31:26 <lambdabot>  f c (f b (f a z))
09:31:28 <Toxaris> trofimovich: yes in a sense
09:31:33 <b_jonas> we forgot trunk (as in that of a tree)
09:32:08 <Toxaris> trofimovich: in Haskell, you can just use type variables without declaring them, but sometimes you want the declaration on a specific position, and then you can use forall
09:32:19 <b_jonas> now where should I link that page from?
09:32:39 <ahunter> Deewiant: maybe, I guess...how should I be using it, though?
09:33:10 <Deewiant> ahunter: well, how are you using the Ptr
09:33:25 <ahunter> as a argument of type int[] (in C)
09:33:49 <Deewiant> ahunter: then you might at least want to make sure that the list you give is of type [CInt]
09:33:53 <Deewiant> and not [Int]
09:33:57 <Beelsebob> okay, so my conclusion from this is that Haskell is more than suitable for 3D work :)
09:34:00 <Deewiant> so map fromIntegral or whatever
09:34:16 <ahunter> Deewiant: but Int is Storable--doesn't that mean withArray should be marshaling it?
09:34:21 <Twey> :t foldl
09:34:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:34:23 <Twey> :t foldl'
09:34:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:34:38 <trofimovich> the differ in efficiency?
09:34:41 <Baughn> Twey: The difference is in the implementation
09:34:48 <Twey> We should have some sort of indicator in the type that screams 'AAH STRICT'
09:34:49 <Deewiant> ahunter: sure, but that doesn't mean it's the same bit size as C "int", for instance
09:35:10 <ahunter> Deewiant: ...actually, now that I tthink about it, that's it exactly, I'm on a 64 bit system.
09:35:12 <b_jonas> I guess I'll ask on perlmonks in case someone knows any more synonyms
09:35:13 <trofimovich> > foldl f x [a,b,c]
09:35:14 <lambdabot>  f (f (f x a) b) c
09:35:16 <trofimovich> > foldl' f x [a,b,c]
09:35:17 <lambdabot>  f (f (f x a) b) c
09:35:33 <Baughn> trofimovich: Kind of. foldl (and foldl') are tail-recursive, which isn't quite as good as you'd expect when laziness is thrown in
09:35:35 <b_jonas> vixey: I guess you don't mind that I quoted you here: http://haskell.org/haskellwiki/StringSynonyms
09:35:35 <Deewiant> ahunter: I haven't actually used the FFI with foreign-language programs so I'm just guessing but I'd say getting your types correct is a start :-)
09:35:36 <lambdabot> Title: StringSynonyms - HaskellWiki
09:35:58 <vixey> b_jonas: it should say she
09:36:09 <Baughn> trofimovich: Okay, executive summary: foldl' will produce your result, walking the original list tail-recursively, as you'd expect from scheme or something.
09:36:10 <trofimovich> Baughn: foldl' is stricter of `seq`?
09:36:30 <b_jonas> oh, ok
09:36:33 <ahunter> Deewiant: actually, no, that didn't fix it
09:36:33 <b_jonas> fixed
09:36:48 <trofimovich> @src foldl'
09:36:48 <lambdabot> foldl' f a []     = a
09:36:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:36:49 <Cale> foldl' f z [] = z; foldl' f z (x:xs) = let y = (f z x) in y `seq` foldl' f y xs
09:36:52 <Baughn> trofimovich: foldl will do the same, but instead of producing a result it will produce a /chain of thunks/ instead. When you try to /use/ it, the RTS will get a stack overflow. (And if you don't, it'll never make the chain of thunks)
09:37:16 <vixey> b_jonas: there was one time when people thought of lots of pairs of works that could be use like  peek/poke  set/get etc..
09:37:21 <Baughn> trofimovich: foldr, meanwhile, can produce partial results. Um, I know I'm probably being confusing here, so I'll just find the wiki page instead of explaining it properly
09:37:33 <Baughn> trofimovich: http://haskell.org/haskellwiki/Stack_overflow
09:37:34 <lambdabot> Title: Stack overflow - HaskellWiki
09:37:58 <Baughn> trofimovich: It uses foldl/'/r as examples, so it'll do fine. ;)
09:38:01 <b_jonas> vixey: oh yeah, there are indeed lots of those
09:38:09 <Cale> Well, it's easy once you understand that lazy evaluation proceeds by reducing the outermost redex first (rather than the innermost as strict evaluation does)
09:38:09 <trofimovich> ok :]
09:38:09 <Deewiant> ahunter: if you're sure it's CInt now, then my advice ran out, beats me
09:38:13 <b_jonas> vixey: sometimes it's not even clear how they're paired
09:38:16 <Cale> So for instance, you have reductions like
09:38:32 <b_jonas> vixey: it's also fun if you try to pair synonyms of begin and end
09:38:39 <trofimovich> @src ($!)
09:38:39 <lambdabot> f $! x = x `seq` f x
09:38:43 <trofimovich> @src ($)
09:38:43 <lambdabot> f $ x = f x
09:38:45 <Twey> > let x = seq undefined in 3
09:38:46 <lambdabot>  3
09:38:46 <trofimovich> i see
09:38:47 <b_jonas> vixey: because IMO those two are not a pair
09:38:49 <Baughn> trofimovich: Cale's got a good point here. Look at this expression:
09:38:50 * Twey ponders.
09:38:52 <Cale> foldr f z [1,2,3] --> f 1 (foldr f z [2,3]) and then f gets applied next
09:38:58 <Baughn> > foldl1 f [a,b,c,d,e]
09:38:58 <lambdabot>  f (f (f (f a b) c) d) e
09:39:16 <Baughn> trofimovich: Looks good, doesn't it? In a strict language, it /would/ be; all tail-recursive
09:39:16 <Deewiant> Twey: if you don't force the x the seq doesn't get called, I would think
09:39:20 <Cale> If f doesn't happen to pattern match against its second parameter there, there's no need to continue the foldr
09:39:29 <Twey> > let x = [1, undefined] in head x
09:39:30 <lambdabot>  1
09:39:38 <Twey> > let x = seq [1, undefined] in head x
09:39:38 <lambdabot>  Couldn't match expected type `[a]' against inferred type `t -> t'
09:39:42 * Twey blinks.
09:39:44 <Deewiant> > let x = seq undefined 1 in x
09:39:44 <lambdabot>  Exception: Prelude.undefined
09:39:46 <rwbarton> @type seq
09:39:47 <lambdabot> forall a t. a -> t -> t
09:39:53 <Twey> Hmnhmnhmn
09:40:00 <Baughn> trofimovich: But because haskell evaluates outside-in, it ends up having to run through every f in the chain before even /starting/ to do any computation
09:40:09 <Twey> > let x = seq 1 [1, undefined] in head x
09:40:10 <lambdabot>  1
09:40:15 <Cale> Twey: evaluating (seq x y) will evaluate x up to determining the top-level constructor before resulting in y
09:40:20 <Baughn> trofimovich: foldl' uses seq to force it to evaluate inside-out, the way strict languages work
09:40:29 * Twey shakes his head.
09:40:31 <Twey> Right-ho.
09:41:03 <Cale> Baughn: hmm... actually that's not necessarily the case.
09:41:11 <trofimovich> @src seq
09:41:12 <lambdabot> Source not found. :(
09:41:21 <Baughn> Cale: It's a lie-to-students. :/
09:41:21 <trofimovich> it is a primitive?
09:41:24 <rwbarton> seq is a super-magical builtin
09:41:24 <Deewiant> seq = scaryInternalPrimitive#
09:41:24 <Cale> Baughn: if f doesn't match against its first parameter, then there's no problem :)
09:41:26 <hackage> Uploaded to hackage: AERN-Real 0.9.6.1
09:41:26 <hackage> Uploaded to hackage: AERN-RnToRm 0.3.0.3
09:41:31 <b_jonas> if you know any more synonyms, add them to the wiki page directly, because I won't keep following all traffic here
09:41:33 <b_jonas> thanks
09:41:54 <chrisdone> good day
09:41:59 <Cale> However, if it does, then it gets put on the stack, and the parameter starts evaluating.
09:42:46 <Baughn> > foldl (const 1) 0 [1..]
09:42:47 <lambdabot>   add an instance declaration for (Num (b -> a))
09:43:03 <rwbarton> > let tail' = foldl const in tail' [1,2,3,4,5] -- a correct (though silly) use of foldl
09:43:03 <Baughn> > foldl (const 1) [1..] 0
09:43:04 <lambdabot>   add an instance declaration for (Num (b1 -> [t]))
09:43:04 <lambdabot>  Add a type signature
09:43:05 <Cale> The stack in most lazy evaluators measures the distance between the expression you're trying to evaluate and the outermost redex in it.
09:43:17 <Baughn> @type foldl
09:43:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:43:22 <rwbarton> > let tail' = foldl const undefined in tail' [1,2,3,4,5] -- a correct (though silly) use of foldl
09:43:23 <lambdabot>  Exception: Prelude.undefined
09:43:28 <Cale> Or perhaps the outermost leftmost redex, I should say.
09:43:33 <rwbarton> > let tail' = foldl (flip const) undefined in tail' [1,2,3,4,5] -- a correct (though silly) use of foldl
09:43:34 <lambdabot>  5
09:43:37 <Deewiant> > foldl (const (const 1)) 0 [1..]
09:43:39 <lambdabot>  Tried to use too much memory
09:43:50 <Deewiant> > foldr (const (const 1)) 0 [1..]
09:43:51 <lambdabot>  1
09:43:52 <Baughn> ..well, not a stack overflow
09:44:11 <Baughn> Can we just agree that this use of folds is silly? :P
09:44:23 <Cale> The problem with foldl is that it does nothing but call foldl over again until it gets to the end of the list.
09:44:40 <Cale> (well, it builds up a large expression in its parameter in the meantime)
09:44:49 <Baughn> Mm. Actually..
09:45:03 <Baughn> It strikes me that lazy evaluation should be /easier/ to understand than strict, if you don't learn strict first
09:45:32 <Cale> yeah, it's not so bad at all :)
09:45:36 <Baughn> "f foo bar: First call f, then f does what it likes with foo and bar"
09:45:44 <twanvl> you know you have been programming too much Haskell when ...
09:45:46 <Baughn> Just the way it's written, no jumping around. ;)
09:45:51 <trofimovich> @src ($!)
09:45:51 <lambdabot> f $! x = x `seq` f x
09:45:54 <Baughn> twanvl: Haskell starts making sense
09:45:58 <Cale> foldl f z [a,b,c] --> foldl f (f z a) [b,c] --> foldl f (f (f z a) b) [c] --> foldl f (f (f (f z a) b) c) [] --> f (f (f z a) b) c
09:46:11 <trofimovich> > "hi" `seq` (1+2)
09:46:12 <lambdabot>  3
09:46:22 <b_jonas> Baughn: I don't think it would be easier to argue time and memory usage about it even if you learnt it that way
09:46:24 <trofimovich> strange syntax :]
09:46:36 <Baughn> b_jonas: No, but that isn't easy in /any/ language
09:46:40 <Cale> Baughn: also, in (f . g . h), f is the first function to be expanded.
09:46:51 <Cale> (after (.))
09:46:56 <b_jonas> Baughn: well, yeah, you could say that
09:47:06 <b_jonas> depends on what programs it is about I guess
09:47:16 <lilac> "f foo bar: first call f, then f does what it likes with foo, and returns a function which does what it likes with bar"
09:47:17 <Baughn> b_jonas: That's okay. I could spend a lot more time working on that, what with not having to explain mutation
09:47:30 <Baughn> lilac: That would be nice, if it were true
09:47:36 <b_jonas> maybe it's imperative style where it's easier to reason about time and memory usage
09:47:50 <trofimovich> @hoogle runSTU
09:47:50 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
09:47:50 <Cale> Baughn: it might as well be true? :)
09:47:54 <Baughn> b_jonas: Only because you /have/ to specify those in the source
09:48:04 <Baughn> Effectively. You can't /not/ think about it
09:48:26 <Baughn> Cale: But they aren't. I got bitten by that one once
09:48:27 <b_jonas> Baughn: yeah, mostly
09:48:34 <Cale> I really like the way that in Haskell, you can get most of what you need to understand with regard to performance just by evaluating expressions by substitution.
09:48:39 * lispy suspects he was adjectived again
09:48:41 <b_jonas> bust still, it's a natural consequence of the imperative style
09:48:48 <b_jonas> s/bust/but/
09:49:07 <Baughn> Cale: Expecting "foo x y = let costlyThing = foo x in ..." to work the same as "foo x = let costlyThing = foo x in \y ..."
09:49:10 <b_jonas> it's not just because old compilers were lazy to include a malloc in the librar
09:49:12 <b_jonas> y
09:49:57 <Baughn> Cale: Um. The second foo in each quote should be bar.
09:50:18 <Cale> Baughn: ah, yeah :)
09:50:22 <Cale> I get the idea anyway.
09:50:51 <trofimovich> @src sum
09:50:51 <lambdabot> sum = foldl (+) 0
09:50:53 <b_jonas> ah, closures
09:50:54 <b_jonas> yeah
09:51:03 <Cale> Baughn: Does GHC really preserve the difference between those two?
09:51:08 <trofimovich> > sum [1..10^6]
09:51:08 <lilac> Baughn: doesn't it still hold there? the question is whether "foo x" returns let costlyThing = ... in \y -> ..., or returns \y -> let costlyThing = ... in ...
09:51:09 <lambdabot>  500000500000
09:51:13 <trofimovich> > sum [1..10^8]
09:51:15 <lambdabot>  Tried to use too much memory
09:51:19 <Baughn> Cale: It does.
09:51:24 <Cale> Baughn: I can imagine that it might do something different with them without optimisations...
09:51:24 <Deewiant> > foldl' (+) 0 [1..10^8]
09:51:26 <lambdabot>  Tried to use too much memory
09:51:36 <Baughn> Cale: Well, 6.6 did at least
09:51:41 <Baughn> That is to say, didn't optimize
09:51:46 <b_jonas>  > foldr (+) 0 [1..10^8]
09:52:32 <Baughn> > sum [0..10^8]
09:52:34 <rwbarton> The optimization could be bad for memory usage
09:52:34 <lambdabot>  Tried to use too much memory
09:52:49 <b_jonas> > foldr (+) 0 [1..10^8]
09:52:50 <lambdabot>  Exception: stack overflow
09:53:01 <Baughn> @src sum
09:53:01 <lambdabot> sum = foldl (+) 0
09:53:10 <Baughn> > foldl' (+) 0 [0..10^8]
09:53:12 <b_jonas> > foldl' (+) 0 [1..10^8]
09:53:12 <lambdabot>  Tried to use too much memory
09:53:14 <lambdabot>  Tried to use too much memory
09:53:18 <b_jonas> > foldl (+) 0 [1..10^8]
09:53:19 <trofimovich> GC issue?
09:53:20 <lambdabot>  Tried to use too much memory
09:53:22 <Deewiant> how many times will we try each fold with the same arguments?
09:53:23 <Baughn> Ooh,r ight
09:53:31 <Baughn> trofimovich: LB bug. Or hs-plugins bug.
09:53:35 <Baughn> Well, bug anyway
09:53:42 <b_jonas> > foldl (+) 0 [1..10^6]
09:53:44 <lambdabot>  500000500000
09:53:44 <Baughn> It's not GCing, nope
09:53:47 <b_jonas> > foldr (+) 0 [1..10^6]
09:53:48 <lambdabot>  Exception: stack overflow
09:53:52 <b_jonas> > foldl' (+) 0 [1..10^6]
09:53:53 <trofimovich> ah, doesn't implement 'em correctly?
09:53:53 <lambdabot>  500000500000
09:54:00 <b_jonas> Baughn: lambdabot is not GCing?
09:54:09 <Baughn> b_jonas: Not top-level forms
09:54:11 <Baughn> Or something like that
09:54:23 <trofimovich> restarts every new compiled program
09:54:24 <Baughn> b_jonas: The [1..10^8] list is never GCed, for whatever reason
09:54:38 <b_jonas> hmm
09:54:45 <Baughn> > let a=1; b=10^6; c=[a..b]; d=sum c in d
09:54:46 <lambdabot>  500000500000
09:54:55 <Baughn> > let a=1; b=10^8; c=[a..b]; d=sum c in d
09:54:57 <lambdabot>  Tried to use too much memory
09:55:10 <b_jonas> Baughn: what does top-level form mean there?
09:55:15 <Baughn> > let c=42 in (let a=1; b=10^8; c=[a..b]; d=sum c in d)
09:55:17 <lambdabot>  Tried to use too much memory
09:55:18 <Baughn> b_jonas: I have no idea
09:55:20 <Deewiant>  > let a=1; b=10^8; c=[a..b]; d=foldl' 0 (+) c in d
09:55:24 <Deewiant> > let a=1; b=10^8; c=[a..b]; d=foldl' 0 (+) c in d
09:55:25 <lambdabot>        add an instance declaration for
09:55:25 <lambdabot>       (Num ((a -> a -> a) -> b -> a ->...
09:55:31 <Deewiant> > let a=1; b=10^8; c=[a..b]; d=foldl' (+) 0 c in d
09:55:33 <lambdabot>  Tried to use too much memory
09:56:03 <trofimovich> > x where x = 1
09:56:04 <lambdabot>  Parse error at "where" (column 3)
09:56:15 <trofimovich> > x; where x = 1
09:56:15 <lambdabot>  Parse error at ";" (column 2)
09:56:27 <trofimovich> > xx where xx = 1
09:56:27 <lambdabot>  Parse error at "where" (column 4)
09:56:28 <Deewiant> lambdabot wants expressions
09:56:44 <Deewiant> > let x = y where y = 1 in x
09:56:45 <lambdabot>  1
09:56:57 <trofimovich> where breaks expression?
09:57:06 <b_jonas> maybe it doesn't gc at all during evaluation of a certain statement?
09:57:20 <Baughn> No, the gc has a chance to be invoked during any allocation
09:57:22 <Toxaris> trofimovich: where is only allowed in definitions
09:57:24 <Deewiant> "x where y" isn't an expression
09:57:26 <Baughn> It's a LB-attached bug
09:57:37 <lament> trofimovich: if 'where' was allowed as part of any expression, parsing Haskell would be a nightmare
09:57:42 <Toxaris> trofimovich: <name> = <expression> where <local definitions>
09:57:43 <b_jonas> Baughn: but isn't there a way to disable it temporarily?
09:57:45 <Baughn> Deewiant: Oh, and oddly enough, sum really /is/ implemented using foldl - not foldl'
09:57:50 <Baughn> b_jonas: Yes, but we don't do that
09:57:59 <b_jonas> I see
09:58:01 <Deewiant> Baughn: yep
09:58:03 <Baughn> Er. I really hope we don't do that.
09:58:06 <lament> trofimovich: x where x = 1 + y where y = 2 where x = 3 where y = 2 + 10 where x = 10
09:58:08 <Deewiant> I've wondered about that myself
09:58:13 <trofimovich> i'm too lame in grammar questions :]
09:58:15 <b_jonas> Baughn: so why is sum implemented as foldl?
09:58:17 <Toxaris> Baughn: yep, all the predefined folds are unusable, sum, maximum and so on
09:58:33 <Deewiant> well, not unusable
09:58:36 <Baughn> Unusable.
09:58:46 <chrisdone> usurpable!
09:58:48 <Deewiant> the strictness analyser should be able to handle most normal cases
09:58:50 <Baughn> b_jonas: I have no idea
09:58:52 <Deewiant> if you compile with -O, at least
09:59:00 <Baughn> Deewiant: It isn't /on/ when you run code in ghci
09:59:11 <Baughn> > foldl1 (+) (take 10^8 (iterate (+1) 0))
09:59:11 <lambdabot>  Couldn't match expected type `[a]'
09:59:12 <Deewiant> yes, in ghci they are unusable
09:59:20 <Deewiant> but that doesn't mean they're unusable, period. :-P
09:59:21 <Baughn> > foldl1 (+) (take (10^8) (iterate (+1) 0))
09:59:25 <lambdabot>  Tried to use too much memory
09:59:58 <Toxaris> Deewiant: I don't want to introduce code in my codebase which is unsuited for testing in ghci for stupid reasons
10:00:01 <b_jonas> it should be foldl' really, right?
10:00:03 <Baughn> > foldl1' (+) (take (10^8) (iterate (+1) 0))
10:00:08 <lambdabot>  Exception: Time limit exceeded
10:00:12 <b_jonas> Baughn: could it be because foldl' isn't in the prelude?
10:00:15 <Baughn> b_jonas: Of course
10:00:16 <Toxaris> Deewiant: so I write foldl' max (error "empty list for maximum")
10:00:36 <b_jonas> Baughn: that's what I think, but after they're defined with foldl, who knows?
10:00:49 <Baughn> b_jonas: Oh, and see the way that iterate-based version doesn't run out of memory?
10:00:54 <Deewiant> > foldl' max (error "foo") [1,2]
10:00:55 <lambdabot>  Exception: foo
10:01:12 <Baughn> Somehow, mentioning a value in the expression you pass to LB makes it not be GCed
10:01:12 <b_jonas> @src iterate
10:01:13 <lambdabot> iterate f x =  x : iterate f (f x)
10:01:19 <Toxaris> this was discussed on -cafe, and there were arguments for not changing the default
10:01:52 <Toxaris> Deewiant: hehe, seems like i'm talking nonsense
10:01:56 <b_jonas> are min and max like these as well?
10:02:04 <b_jonas> I mean
10:02:06 <Deewiant> @src maximum
10:02:07 <lambdabot> maximum [] = undefined
10:02:07 <lambdabot> maximum xs = foldl1 max xs
10:02:09 <b_jonas> maximum and minimum
10:02:12 <b_jonas> yeah, that
10:02:15 <b_jonas> hmm
10:02:18 <sw17ch> > maximum []
10:02:20 <lambdabot>  Exception: Prelude.maximum: empty list
10:02:22 <sw17ch> hehe
10:02:40 <Toxaris> Deewiant: but you know what I mean
10:02:50 <Deewiant> Toxaris: yes, I do. ;-)
10:03:03 <Toxaris> Deewiant: and often enough, there is a good default for foldl' max / min anyway, like 0 or minBound
10:03:39 <b_jonas> Toxaris: Integer is common and it doesn't have a minBound
10:03:51 <b_jonas> or does it?
10:03:55 <trofimovich> nope
10:03:56 <b_jonas> > minBound :: Int
10:03:57 <lambdabot>  -2147483648
10:03:58 <b_jonas> > minBound :: Integer
10:03:59 <lambdabot>   add an instance declaration for (Bounded Integer)
10:03:59 <lambdabot>     In the expression: mi...
10:04:05 <b_jonas> right
10:04:18 <b_jonas> > minBound :: Double
10:04:19 <lambdabot>   add an instance declaration for (Bounded Double)
10:04:19 <lambdabot>     In the expression: min...
10:04:25 <b_jonas> that doesn't have one either?
10:04:26 <Toxaris> b_jonas: yeah, nevertheless, sometimes you want to get the biggest element out of a non-integer-list, don't you?
10:04:33 <trofimovich> > minBound :: Char
10:04:35 <lambdabot>  '\NUL'
10:04:36 <b_jonas> Toxaris: sure you do
10:04:40 <trofimovich> > minBound :: [Char]
10:04:41 <lambdabot>   add an instance declaration for (Bounded [Char])
10:04:41 <lambdabot>     In the expression: min...
10:04:51 <b_jonas> Toxaris: but making minimum use that would make its type wrong
10:05:02 <b_jonas> Toxaris: it would be unusable for non Bounded types
10:05:09 <Toxaris> b_jonas: sure, I did not propose that, did I?
10:05:17 <b_jonas> oh, ok
10:05:28 <lilac> do you folks ever use guards in lets, like "let r | a == 42 = 76; r | otherwise = 12 in r + a"?
10:05:38 <Toxaris> b_jonas: minimum :: Ord a => a -> [a] -> a would be an option I guess
10:05:45 * lilac has an aversion to using if...
10:06:04 <b_jonas> Toxaris: how would that help? does Ord have a minBound or something?
10:06:15 <b4taylor> Is there a yi channel?
10:06:30 <trofimovich> @seen yi
10:06:30 <lambdabot> I haven't seen yi.
10:06:39 <Toxaris> b_jonas: Ord is there for min, and the additional argument is there as a default result
10:06:49 <b_jonas> lilac: do you use guards instead of if or pattern match booleans?
10:07:23 <Deewiant> lilac: I have an aversion to using guards, when there are only two cases :-)
10:07:30 <b_jonas> Toxaris: oh,
10:07:32 <Toxaris> b_jonas: myMinimum x xs = foldl1' min x xs
10:07:42 <b_jonas> I thought you meant Enum instead of Ord
10:07:43 <b_jonas> sorry
10:07:46 <Toxaris> s/foldl1'/foldl'
10:07:49 <lispy> lilac: yes, but I don't use gards a lot, I'm much more likely to use pattern matching and where clauses
10:08:11 <b_jonas> @src Enum
10:08:11 <lambdabot> class  Enum a   where
10:08:11 <lambdabot>     succ                     :: a -> a
10:08:11 <lambdabot>     pred                     :: a -> a
10:08:11 <lambdabot>     toEnum                   :: Int -> a
10:08:11 <lambdabot>     fromEnum                 :: a -> Int
10:08:12 <Toxaris> lilac: I use where + guards to avoid if
10:08:13 <lambdabot> [3 @more lines]
10:08:20 <lispy> I really, really like where clauses and I'm not at all fond of let
10:08:22 <trofimovich> @more
10:08:22 <lambdabot>     enumFrom                 :: a -> [a]
10:08:22 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
10:08:22 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
10:08:26 <lispy> lilac: so how is that for weird?
10:08:46 <Deewiant> pattern matching > if > guards > case
10:09:00 <b_jonas> Toxaris: I don't really like where
10:09:20 <elliottt> Igloo: you around?  i've got a code.haskell.org question for you :)
10:09:28 <trofimovich> toplevels are easy to debug
10:09:37 <lispy> But, where and let both have problems with some types of polymorphism that doesn't happen when pattern matching in a function definition.  So sometimes I abuse do notation for my pattern matching lik, do (Foo b) <- return $ mkFoo 5
10:09:46 <dcoutts> elliottt: or I might be able to answer
10:09:50 <Toxaris> b_jonas: there used to be a haskell wiki page about let vs. where, pointing out that these belong to different mindsets
10:10:06 <elliottt> dcoutts: ah, thanks
10:10:18 <b_jonas> lispy: heh
10:10:36 <lispy> b_jonas: i only do that if GHC says its head exploded though
10:10:44 <lispy> otherwise, I use let or where
10:10:49 <b_jonas> lispy: wow
10:11:10 <b_jonas> doesn't _your_ head explode when you do that kind of thing?
10:11:17 <lispy> It used to
10:11:24 <lispy> But, now I just deal with it :)
10:11:25 <b_jonas> lol lol
10:11:42 <elliottt> dcoutts: sorry, i'll just be a minute
10:11:42 <b_jonas> how about lambdas?
10:11:55 <b_jonas> do you like those?
10:12:13 <lispy> Not really, I prefer to define something in a where clause
10:12:36 <elliottt> dcoutts: i've got a project to create on code, and was wondering if you'd be able to run the script for me :)
10:12:44 <Toxaris> lambdas are so wordy in Haskell, all these -> arrows
10:12:51 <lispy> I think the criticism that lambdas are akin to generalized goto is true, so I try to name my lambdas now :)
10:12:55 <dcoutts> elliottt: oh, sure, sorry, there's a bit of a backlog
10:13:21 <elliottt> dcoutts: thanks, i'll just get the repo in a good state.  do you want me to submit through the web form?
10:13:26 <lispy> b_jonas: and I've found that giving them a good name can really pay off in the future
10:13:28 <Toxaris> Scala can be fun with it's hole-in-a-context-syntax
10:13:33 <b_jonas> generalized goto? I thought that was call/cc
10:13:50 <b_jonas> oh, you use good names?
10:13:54 <vixey> any continuation could be compiled into a jump
10:14:04 <b_jonas> good variable names would help lots of my code
10:14:05 <dcoutts> elliottt: oh, you've not made a request yet? then yes. I'm just going to deal with the backlog of other requests. Ping me when you've submitted the req.
10:14:10 <lispy> b_jonas: about the only time I use a lambda instead of a locally defined function is if I'm just dealing with putting a parameter in the right position in a function call, \x -> foo a x b
10:14:13 <elliottt> dcoutts: thanks :)
10:14:41 <Toxaris> lispy: yeah, that's when (foo a _ b) would be cool imho
10:14:51 <lispy> Toxaris: interesting
10:14:56 <Deewiant> Toxaris: oo, that /would/ be cool
10:15:13 <vixey> uh oh... *hopes somebody doesn't invent Hsk*
10:15:19 <vixey> or Hark...a
10:15:20 <Deewiant> > let _ = 1 in x
10:15:21 <lambdabot>  x
10:15:22 <Deewiant> > let _ = 1 in _
10:15:23 <lambdabot>  Parse error in expression at end of input
10:15:25 <Deewiant> hm
10:15:46 <lispy> > x
10:15:48 <lambdabot>  x
10:15:50 <lispy> that's the problem
10:16:01 <lispy> :t x
10:16:02 <lambdabot> Expr
10:16:13 <Deewiant> > let _ = 1 in 1
10:16:13 <lambdabot>  1
10:16:19 <Deewiant> x isn't the problem
10:16:25 <Deewiant> I was wondering why let _ = anything works
10:16:32 <vixey> _ is a pattern
10:16:35 <Toxaris> Deewiant: that's the definition of _
10:16:37 <vixey> f (Just _) = bar
10:16:42 <Deewiant> aye
10:16:46 <Deewiant> but you can't refer to it afterwards
10:16:51 <Toxaris> Deewiant: it's the pattern wich always succeeds, and never binds anything
10:17:02 <vixey> _ is just a variable
10:17:03 <Deewiant> I'm surprised it's allowed on its own
10:17:06 <vixey> but it doesn't have a name
10:17:13 <rwbarton> @src cont
10:17:13 <lambdabot> Source not found. You untyped fool!
10:17:15 <rwbarton> @src const
10:17:15 <lambdabot> const x _ = x
10:17:16 <lispy> b_jonas: I don't think the criticism was that lambda is generalized goto, just that using lambda is like using goto.  If you're not discplined about it, you create the same mess as undisciplined users of goto
10:17:18 <vixey> f A = b
10:17:19 <Deewiant> I guess it can make a difference if you use unsafePerformIO :-P
10:17:19 <vixey> f B = c
10:17:21 <vixey> f _ = x
10:17:24 <vixey> is common..
10:17:29 <Deewiant> yes...
10:17:30 <Toxaris> Deewiant: it is often used on it's own in the last clause of a function definition
10:17:36 <Deewiant> but if you do let _ = foo
10:17:39 <Deewiant> there is no way to get foo
10:17:47 <wjt> Deewiant: what's the point of a special-case banning _ in that particular context?
10:17:55 <vixey> it would be utterly bizzare to disallow that
10:18:00 <rwbarton> Yeah, that's just for consistency
10:18:17 <Deewiant> I don't know, to me it makes sense to disallow pointless constructions in the grammar :-)
10:18:25 <Deewiant> but that's a matter of opinion
10:19:07 <vixey> Deewiant: is "pointless" objective?
10:19:32 <Deewiant> depends on what you mean by it ;-)
10:19:34 <vixey> Are you sure that somebody else wont find let _ = .. very useful?
10:19:37 <vixey> I'm asking you
10:19:53 <Deewiant> in this case, I'd say that let _ = .. is always useless
10:19:58 <vixey> I disagree
10:20:11 <vixey> you might do that during editing some code
10:20:14 <Deewiant> conjure me an example and feel free to change my mind :-)
10:20:24 <vixey> I don't care about changing your mind about that specific thing
10:20:33 * lilac concludes that there is no One True Haskell Style ;-)
10:20:34 <vixey> but in general, If you are going to increase the complexity of a language you better have a good reason
10:22:53 <BMeph> Deewiant: Is "objective" pointless? ;)
10:23:15 <Deewiant> >_<
10:23:36 <Deewiant> well, it doesn't refer to any points ;-P
10:24:04 <lispy> vixey: how about (as a reason) to weed out programmers that can't handle complexity ;)
10:28:07 <lispy> Note: I sometimes think that was the intent of creating C++.
10:28:34 <Valodim> @pl objective
10:28:35 <lambdabot> objective
10:28:40 <Valodim> ...hm.
10:28:52 <lispy> Valodim: is that a pointless objectve?
10:28:59 <Valodim> it seems so
10:29:06 <Valodim> ergo, objective must be pointless
10:29:11 <pozic> Deewiant: it is useful.
10:29:17 <lispy> ?pl mylife
10:29:17 <lambdabot> mylife
10:29:22 <lispy> Valodim: oh no!
10:29:37 <lilac> lispy: judging by some of the people we interview, if that was the intent of c++, it failed :(
10:29:39 <Valodim> don't worrt
10:29:40 <Valodim> @pl life
10:29:40 <lambdabot> life
10:29:46 <Valodim> see, it's pointless in general. not only yours :)
10:29:46 <ziman> @pl line
10:29:47 <lambdabot> line
10:29:50 <Deewiant> pozic: do tell
10:30:01 <vixey> Isn't C++ easier than Haskell?
10:30:38 <lispy> vixey: I'd say they're similar in cognitive load, but that the Haskell compiler can offer more guidance at compile time
10:30:50 <Deewiant> Haskell-98 is much simpler IMO
10:31:01 <Valodim> is there any language with a steeper learning curve than haskell? :|
10:31:08 <roconnor> I'm pretty sure C++ is humanly impossible to write
10:31:10 <vixey> Valodim: yes
10:31:34 <chrisdone> icelandic
10:31:44 <lispy> chrisdone: hehe
10:32:01 <Valodim> haha
10:32:07 <Beelsebob> Valodim: Haskell doesn't have a steep learning curve -- all those other languages you know have a steep unlearning curve
10:32:15 <trofimovich> > let _hello = "hi" in _hello
10:32:15 <lispy> chrisdone: but, I watched that video where that one savant learned icelandic in a week well enough to be interviewed on TV in it :)
10:32:16 <lambdabot>  "hi"
10:32:18 <Valodim> that might be true
10:32:27 <Valodim> anyone here who learned haskell as native language?
10:32:28 <Valodim> (hah)
10:32:31 <roconnor> http://r6.ca/blog/20040530T203100Z.html
10:32:31 <lambdabot> Title: Programming in C++ is Not Humanly Possible
10:32:35 <lispy> of course, he also memorized pi to some insane number of digits
10:32:39 <sw17ch> @quote unlearning
10:32:40 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
10:32:46 <Beelsebob> Valodim: a native language?
10:32:55 <Beelsebob> as in, their first language?
10:33:00 <Valodim> that was the joke
10:34:19 <trofimovich> @karma-all
10:34:19 <lambdabot>  "moritz"               51
10:34:19 <lambdabot>  "lwall"                47
10:34:19 <lambdabot>  "pmurias"              43
10:34:19 <lambdabot>  "audreyt"              42
10:34:19 <lambdabot>  "ruoso"                28
10:34:20 <lispy> roconnor: oh that's just because you're n00b, geez ;)
10:34:21 <lambdabot> [141 @more lines]
10:34:27 <roconnor> ``I wrote a class that called calloc in its constructor, and free in its destructor. If you think this is all reasonable, you are totally wrong!
10:34:49 <roconnor> lispy: that's right.  My degree is CS is worthless. :P
10:34:59 <lispy> roconnor: exactly
10:35:14 <roconnor> and the years of experience.
10:35:25 <Beelsebob> roconnor: hmm? why do you say your degree is useless?
10:35:36 <Beelsebob> oh, you were being fecicous
10:35:39 * Beelsebob learns to read up
10:35:45 <roconnor> Beelsebob: Because I still can't program in C++
10:35:52 <Beelsebob> lol
10:35:54 <roconnor> ... not that anyone else can either.
10:36:01 <roconnor> well, maybe 12 people can.
10:36:05 <trofimovich> :]
10:36:08 <dolio> qwe1234 can.
10:36:11 <Beelsebob> I can write C++... just it won't use half the language features
10:36:22 <Beelsebob> it'll essentially be C, with objects
10:36:40 <roconnor> Beelsebob: do you always rememeber to overide the copy constructor?
10:36:41 <dublpaws> try saying that in #C++
10:36:52 <Beelsebob> roconnor: heh
10:36:52 <roconnor> whenever you have pointers in the structure.
10:36:58 <b4taylor> Wow, I've never had so much trouble getting something to run.
10:37:03 <b4taylor> I'm probably missing something.
10:37:11 <b4taylor> Trying to get yi running.
10:37:12 <Beelsebob> b4taylor: hmm? what is it?
10:37:14 <Beelsebob> oh
10:37:16 <lispy> Well, languages like C++ and python do let you write _something_ and start playing with that _something_.  Where as with Haskell, sometimes the hard part is just getting to a point where you have _something_ that you can run, even if statistically speaking it's usually closer to correct once it runs.  So, I think the cognitive load can be similar.
10:37:48 * lilac would claim to be able to program in c++
10:38:05 <b4taylor> Oh wait, I'm getting a different error now about hidden packages.
10:38:10 <roconnor> lispy: I think I might disagree with what you say, but I do understand you.
10:38:10 <b4taylor> I think I can solve this.
10:38:10 <lament> roconnor: nice domain name
10:38:12 <Beelsebob> lispy: so what you're saying is that in C++ and python it's easier to write a program that crashes, than in Haskell
10:38:16 <Beelsebob> but just as hard to write a correct one
10:38:18 <pozic> lispy: that's nonsense. Writing helloworld in Haskell is easier than in C++.
10:38:20 <lament> roconnor: my friend has z3.ca :)
10:38:32 <roconnor> lament: my boss was like: you can't have a 2 letter domain name!
10:38:43 <Cale> main = putStrLn "Hello, World"
10:38:44 <roconnor> lament: I said that one is a number.
10:38:54 <lament> "it's actually a 1-letter domain name"
10:38:58 <Beelsebob> Cale: yeh, that's so lame
10:38:59 <trofimovich> #include "hellos.hpp"
10:39:00 <trofimovich> HI
10:39:05 <Beelsebob> it should be main = "Hello world"
10:39:07 <lispy> Beelsebob: yes, and part of that is because writing a correct program is it's own difficult problem
10:39:31 <lilac> Threading is so much harder than memory management anyway...
10:39:41 <pozic> Beelsebob: and that would work how?
10:39:49 <lispy> Once I've learned the language a bit, I don't typically worry about writing Hello, World in it.
10:39:56 <roconnor> lament: I originally got it to save characters on SMS messages. :P
10:39:57 <Beelsebob> pozic: well, by not making main always have type IO ()
10:39:57 <lispy> But, maybe that's just me :)
10:40:00 <Beelsebob> make main of type a
10:40:09 <Beelsebob> and make your OS able to deal with the return values
10:40:13 <Beelsebob> (functional OS ftw)
10:40:20 <Beelsebob> also... compositionality ftw
10:40:24 <lispy> I was surprised main was not type IO Int, actually
10:40:38 <trofimovich> that OS would have funny ABI
10:40:43 <lament> lispy: exit codes are too practical for haskell
10:41:08 <dolio> @type exitWith
10:41:08 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
10:41:09 <lispy> main :: [String] -> IO Int, this would have been pretty natural coming from C
10:41:13 <lilac> doesn't GHC support main :: (Show a) => IO a ?
10:41:38 <Deewiant> I think a reasonable approach would be to allow it to be either IO a or IO Int, where IO a would just be the same as IO () which would be equivalent to "return (0 :: Int)"
10:41:43 <lilac> tho main :: RealWorld# -> RealWorld# is pretty nice
10:41:44 <pozic> Beelsebob: then it would be a library.
10:42:09 <ziman> main = interact (const "Hello world")
10:43:12 <Beelsebob> pozic: no it wouldn't
10:43:17 <Beelsebob> it would be a program
10:43:24 <Beelsebob> it would be a program of type a
10:43:36 <trofimovich> :]
10:43:38 <Beelsebob> and I would be able to take the data from it and move it to another programe easily
10:43:47 <trofimovich> how exactly?
10:43:51 <Beelsebob> without this whole parsing stdin and stdout thing
10:44:00 <pozic> Beelsebob: this is just name arguing.
10:44:09 <Beelsebob> pozic: no, no it isn't
10:44:10 <elliottt> dcoutts: I just submitted the project request
10:44:24 <pozic> Beelsebob: well, I understand you perfectly, although you might think I don't.
10:44:44 <Beelsebob> pozic: if you think it's just "name arguing" then you don't understand
10:45:16 <dcoutts> elliottt: what is glguy's username on code.h.o? it's not 'glguy'.
10:45:39 <elliottt> dcoutts: emertens?
10:45:49 <dcoutts> elliottt: ah yes.
10:46:06 <dcoutts> elliottt: ok, done.
10:46:19 <elliottt> dcoutts: thanks!
10:46:40 <glguy> \o/
10:47:01 <b4taylor> yi.hs: Prelude.head: empty list
10:47:01 <b4taylor> ??
10:47:07 <elliottt> oh, no .git extension
10:48:16 <glguy> it will work without the .git extension, but using it is a common convention and is especially useful in a directory overrun by darcs
10:49:36 <Igloo> I don't think having .git in the project name makes sense. You can always make a subdirectory with git in the name
10:50:08 <glguy> all of those top level directories are repositories
10:50:23 <glguy> to put the repository down a level would be unusual
10:50:25 <Igloo> They don't have to be. In fact, I think that's probably a mistake
10:50:38 <Igloo> It makes it much harder to have branches (with darcs)
10:52:37 <vixey> what's the algorithm for this?  if you have a list of [Term "x", Op "+", Term "y", Op "*", Term "7"] type thing, and you chop it up and put it into  Apply "+" [Trm "x",Apply "*" [Trm "y",Trm "7"]] ?
10:52:42 <glguy> yeah... its a shame that typical darcs use doesn't follow the subversion "trunk" convention
10:52:56 <vixey> can you take a table to operators with prec. levels and turn it into a DFA?
10:53:20 <Toxaris> vixey: sounds like "parsing"?
10:53:39 <dolio> :)
10:53:44 <dmhouse> ?ask kowey what on earth the "RWH 'crisis'" is? And the wikibook list has been dead for months, unless I'm missing something.
10:53:44 <lambdabot> Consider it noted.
10:54:04 <vixey> yeah but ways to do this specific bit?
10:54:32 <chrisdone> normalise?
10:55:04 <vixey> and how do you report good error messages for op clashes?
10:55:13 <rwbarton> I have a vague recollection that you're supposed to keep a stack of terms and a stack of operators, and when you hit a new operator you either push it on the stack (if it has high precedence) or pop some stuff off the stack (otherwise)
10:55:47 <Toxaris> vixey: you convert your precedence table into a context-free grammer, and the cfg into a parser
10:55:57 <vixey> how do you do that?
10:56:05 <vixey> and it can be done automatically?
10:56:13 <dolio> You might be able to do it pretty easily with parsec.
10:56:19 <dolio> Sort them by precedence.
10:56:34 <dolio> Depending on fixity, use chainr/chainl.
10:57:44 <dolio> And lower precedence operators use higher precedence operators as their chainX sub-parsers.
10:58:30 <dolio> Although reporting good errors for conflicting r/l of the same precedence would be difficult, I guess.
11:00:04 <vixey> yeah good error messages is a really hard thing
11:00:43 <b4taylor> Oh no, I've forgotten how to uninstall a package from cabal...
11:00:57 <dcoutts> b4taylor: you've not forgotten, cabal doesn't do it :-)
11:01:14 <dcoutts> use $ ghc-pkg [--user] unregister pkgname
11:01:21 <b4taylor> Ahha.
11:01:39 <b4taylor> I forgot how to make the package go away :p
11:08:28 <sw17ch> dcoutts, why doesn't cabal assist with removing packages?
11:09:03 <dmhouse> Hey kowey.
11:09:03 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:12 <kowey> dmhouse, hello!
11:09:45 <dmhouse> kowey: RWH is a real book?
11:10:13 <dmhouse> It doesn't really look like a Wikibook competitor to me, judging from the website...
11:10:33 <kowey> dmhouse : well, different audience
11:10:43 <kowey> but it could well become /the/ way for beginners to pick up Haskell
11:10:49 <dons_> dmhouse: um yes, it is a real book :)
11:11:15 * kowey is rooting for the competition... and err... the wikibook as well
11:12:22 <dmhouse> dons_: heh, sorry, I recognise it now I'm browsing through the website, the TLA didn't jog my memory.
11:12:43 <dmhouse> kowey: how is darcs, anyway? Seems you guys have taken a few hard hits over the last couple of weeks...
11:13:03 <kowey> dmhouse: darcs is working on transforming this hit into the best thing that ever happened to us
11:13:40 <dmhouse> kowey: sounds exciting. :) In what way?
11:13:44 <kowey> we've got some projects up our sleeves, thanks to everybody's advice
11:13:45 <kowey> http://wiki.darcs.net/index.html/Recruitment
11:13:47 <lambdabot> Title: Recruitment - DarcsWiki
11:14:07 <dmhouse> In other news, I recently introduced a coworker (new to VCS) to darcs, and reached the 500th patch on my work project.
11:14:30 <kowey> in the sense that this helps us to focus / rally.... gives us the usual kick in pants
11:15:11 <dons_> kowey: yeah, that's a good result.
11:15:16 <dons_> clarify the future directoin
11:15:36 <kowey> oh, time for another link, then - http://wiki.darcs.net/index.html/Roadmap
11:15:37 <lambdabot> Title: Roadmap - DarcsWiki
11:15:47 <glguy> what causes GHC to leave all of the ghcNNNNN_N garbage in my /tmp?
11:16:10 <Igloo> A bug, if you haven't asked it too keep-tmp-files or similar
11:16:14 <kowey> dons_: thanks for the feedback you've been giving over the past year by the way (over reddit, etc)... we've been listening, just not in a position to act
11:16:23 <dmhouse> "seamless integration with git, svn, etc" -- I'd love seamless svn integration.
11:16:58 <kowey> i wonder if we could launch an Adopt a Darcs Module campaign
11:17:07 <kowey> everybody haddock just one module
11:17:15 <kowey> or maybe just three functions
11:19:39 <dons_> woo, DEFUN! http://www.reddit.com/comments/6vcg0/making_functional_programming_work_icfp_now_has/
11:19:41 <lambdabot> Title: Making functional programming work: ICFP now has DEFUN developer workshops! : re ..., http://tinyurl.com/6exlzb
11:19:55 <dons_> come to ICFP, skip the boring theory talks, learn how to build web servers in haskell
11:20:19 <dcoutts> dons: who's building web servers in Haskell?
11:20:22 <dons> oleg :)
11:20:22 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:20:35 <dons> check out the workshop program though.
11:20:42 <dons> we've a full day of developer talks on haskell
11:20:56 <dcoutts> great :-)
11:21:33 <dmhouse> I saw some anti-Haskell-fanboy comment on reddit the other day. I feel we're really making it as a language.
11:22:00 <dons> dmhouse: right!
11:22:03 <Valodim> hahaha
11:22:07 <Valodim> php has lambda functions now
11:22:26 <Valodim> irony~
11:22:30 * dcoutts gets back to hacking on his web server written in Haskell
11:22:32 <dmhouse> Yay! Now it just need to stop trying to be a ripoff of Java...
11:22:36 <dcoutts> important demo tomorrow! :-)
11:22:39 <Chile`> kowey: just a general hacking request, but its amazingly helpful to have a tree heirarchy of parts/behaviors/functions along with where specifically they're implemented & maybe briefly what other parts they touch
11:23:16 <Chile`> kowey: the big hurdle is getting familiar with the code base, which isn't worth it for most people for a patch or two, especially if they're not sure what mucking with one thing will do to another
11:23:21 <RayNbow> btw, anyone managed to read this paper? http://crave.cnet.com/i/bto/20080604/HTC_340x367.jpg
11:23:23 <RayNbow> ah crap
11:23:28 <Shiruka> PHP isn't a ripoff of Java, it's Perl's long-lost ugly cousin :-p
11:23:28 * RayNbow kicks clipboard
11:23:35 <RayNbow> this paper, http://www.reddit.com/r/programming/comments/6v2um/why_monads_are_a_poor_foundation_for_dealing_with/
11:23:36 <lambdabot> Title: Why monads are a poor foundation for dealing with side-effects [PDF] : programmi ..., http://tinyurl.com/59e442
11:24:03 <RayNbow> Shiruka: a mutilated Perl? :p
11:24:14 <dmhouse> Shiruka: you seen the object functionality in PHP5?
11:24:23 <Shiruka> thankfully no
11:24:29 <kowey> Chile`: http://bugs.darcs.net/issue980 filed!
11:24:30 <lambdabot> Title: Issue 980: documentation: tree hierarchy of general behaviour parts - Darcs bug  ...
11:24:35 * Shiruka doesn't have to touch PHP with a 10-foot pole
11:24:56 * dmhouse is a PHP-monkey for the day job at the moment.
11:25:40 <kowey> Chile` : does this help at all? http://koweycode.blogspot.com/2006/08/eric-shuts-up-at-last-and-dreams-of.html
11:25:41 <lambdabot> Title: koweycode: eric shuts up at last (and dreams of tidyness), http://tinyurl.com/ybpezf
11:26:16 <kowey> oh wait, no it doesn't
11:27:26 <b_jonas> Shiruka: I agree
11:28:19 <RayNbow> Shiruka, you need a HEV suit if you want to use PHP ;)
11:28:23 <Chile`> kowey: yeah, not quite the same thing. what I'm thinking of was on an intranet wiki.. basically it was a list of every feature/menu button/command in a rough hierarchy with a reference to the source, and then a lot of "before you edit __, you should look at __, __, and __ to make sure you don't screw those up"
11:28:52 <Shiruka> RayNbow: "want"? :-)
11:29:14 <RayNbow> ok... if you're forced to use PHP :p
11:29:18 <kowey> Chile`: have you looked at any bits of darcs code?
11:29:20 <Chile`> kowey: it might be a prohibitive amount of work, but it made adding things pretty painless even for people not at all familiar with the system
11:29:23 <dmhouse> Oh, and to those who say PHP doesn't have lambdas: http://uk2.php.net/create_function ;)
11:29:24 <lambdabot> Title: PHP: create_function - Manual
11:29:27 <kowey> maybe we could work on an example together?
11:29:36 <Chile`> kowey: I haven't, but I could be open to it
11:29:57 <Chile`> kowey: I've been spending my time trying to get darcs yi to compile :p
11:30:04 <kowey> :-)
11:30:18 <erikc> what is the | in class decls, such as class ISession sess => Statement stmt sess q | stmt sess -> q
11:30:31 <dmhouse> erikc: functional dependencies
11:30:32 <Chile`> seems that every time I pull a new version of it there's a different build error
11:30:33 <kowey> well, I would love it if you found some darcs stuff you wanted to hack on (I've got a couple of ideas)
11:30:43 <kowey> so that we could work together on this documentation project
11:31:02 <kowey> at least, just to get a proof-of-concept
11:31:47 <RayNbow> erikc, http://www.cs.chalmers.se/~hallgren/Papers/wm01.html
11:31:48 <lambdabot> Title: Fun with Functional Dependencies
11:31:49 <b_jonas> dmhouse: does that support lexical scoping?
11:32:08 <adamw> hi, all. anyone here can help with wxhaskell build issues? or knows where can?
11:32:37 <kowey> adamw: maybe me
11:32:44 <dmhouse> b_jonas: hah, did you read the documentation at all? You pass the code for the function. As a string. This is then eval()d and assigned a unique name.
11:32:46 <adamw> ok, give it a shot :) just let me pastebin:
11:33:00 <dmhouse> b_jonas: there was a heavy dose of <sarcasm />.
11:33:07 <b_jonas> dmhouse: oh yeah, I've read it
11:33:12 * erikc reads
11:33:19 <Chile`> kowey: what are the failing parts at the moment? I'm mostly a perforce user, tbh :)
11:33:22 <adamw> kowey: http://www.pastebin.ca/1094952
11:33:23 <b_jonas> the lexical scoping is exactly why it doesn't have lambdas
11:33:42 <adamw> honestly, i know nothing about haskell or wxhaskell, i'm just a packaging monkey, updating old mandriva packages, and wxhaskell's in the list
11:33:43 <b_jonas> (the total lack of garbage collection is secondary)
11:33:51 <b_jonas> you can still say it has higher-order functions
11:33:53 <seliopou> RayNbow: that's probably the last paper you should link to for a question like that
11:33:54 <adamw> i made the logical changes to the spec for the new version of wxhaskell
11:34:00 <adamw> and when I run a test build I get that error
11:34:13 <adamw> so yeah, I dunno what's wrong. :)
11:34:17 <kowey> Chile`: (be back with you later)... right now we're most worried about real world performance, for example, it seems like we've been bitten by misreported mtimes
11:34:36 <adamw> /usr/share/doc/ghc/libraries/*/*.haddock indeed does not exist, but I don't know if it should, or if the build's looking for something it shouldn't be.
11:34:39 <RayNbow> seliopou: it's actually one of the first papers I read on fundeps
11:34:44 <kowey> adamw: what version of haddock, please?
11:34:50 <RayNbow> seliopou: what's a better introductory paper?
11:34:54 <b_jonas> just like how J doesn't have lambdas but does have higher-order functions and you can create functions with bound upvalues
11:34:58 <adamw> ooh. it's quite old, now I come to look.
11:35:02 <adamw> [adamw@lenovo SPECS]$ urpmq -r haddock
11:35:02 <adamw> haddock-0.8-1mdv2007.1
11:35:13 <adamw> mdv2007.1 means it hasn't been updated / rebuilt for at least a year and a half
11:35:16 <adamw> that could be the problem?
11:35:22 <kowey> perhaps... please try with a  more recent one
11:35:22 <b_jonas> so yeah
11:35:25 <adamw> okay, will do - thanks
11:35:32 <kowey> we've been mucking around a bit so that it at least works with haddock 2.x
11:35:49 <adamw> so now I have to update the haddock package =)
11:36:05 <kowey> :-)
11:36:30 <adamw> will anything else have trouble with me just bumping it from 0.8 to whatever the latest is?
11:36:35 <seliopou> RayNbow: not a paper
11:36:37 <Shiruka> J code looks interesting :-) too bad it's not foss, otherwise I'd just have to learn it and scare hapless programmers witless
11:36:43 <adamw> any of: wxhaskell haskell-missingh haskell-HTTP haskell-configfile haskell-HaXml ghc haskell-HXT haskell-X11 haskell-utf8-string haskell-hslogger haskell-cabalrpmdeps haskell-filepath
11:36:44 <seliopou> maybe the haskell wiki
11:36:53 <adamw> those are the other packages we have that build-depend on haddock
11:37:06 <seliopou> http://haskell.org/haskellwiki/Functional_dependencies
11:37:06 <lambdabot> Title: Functional dependencies - HaskellWiki
11:37:55 <RayNbow> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.7153
11:37:56 <lambdabot> Title: Type classes with functional dependencies - CiteSeerX
11:37:59 <malcolmw> adamw: even ghc HQ recommends using haddock 0.9 instead of 2.x
11:38:47 <adamw> hmm
11:38:55 <Shiruka> anybody here used HTF?-)
11:38:58 <adamw> kowey: should i try 0.9 before 2.0? or will that be no good?
11:39:18 * kowey does not remember
11:39:28 <kowey> in the worst case, we could give you a workaround in the configure script
11:39:29 <bjrn> In the simply typed lambda calculus, what is the "typing context"?
11:39:40 <adamw> i will try 0.9, then
11:39:43 <adamw> then 2.0
11:39:49 <adamw> and then i'll come and moan if it still doesn't work =)
11:40:02 <kowey> yes! constructive moaning!
11:40:08 <seliopou> it's an environment mapping type variables to types
11:40:13 <dolio> In 'Gamma |- e : t' Gamma is the typing context, I believe.
11:40:13 <seliopou> bjrn: ^
11:40:57 <adamw> kowey: it's my specialty ;)
11:40:59 <bjrn> seliopou: Environment in the sense of scope/binding?
11:41:05 <kowey> Chile`: still around? here is an example of the kind of fail we get - http://bugs.darcs.net/issue973
11:41:06 <lambdabot> Title: Issue 973: darcs whatsnew significantly slower on hashed format - Darcs bug trac ...
11:41:12 <mmorrow> dcoutts: i just saw you meantion you're building a haskell webserver. cool! i wrote an super mini one the other day. It currently has a fixed response, but i used httperf on it and it does 3000+ requests/sec. http://lunar.moonpatio.com/neutron/neutron.hs
11:41:18 <dmhouse> bjrn: [(Term, Type)]
11:41:38 <kowey> we've got this nice new robust 'hashed' repository format... but for some reason it sometimes get really slow
11:41:50 <seliopou> brjn: sorry, terms to types, as dmhose said
11:41:57 <seliopou> and yes, sortof
11:42:03 <mmorrow> dcoutts: also, it catches USR1, and disables itself cleanly.
11:42:04 <jganetsk> variables to types
11:43:00 <mmorrow> dcoutts: (that's 3000+ req/sec running httperf on the same machine...)
11:45:10 <mmorrow> dcoutts: if for some reason that link i just gave doesn't work, http://207.58.166.174/neutron/neutron.hs
11:45:11 <Chile`> kowey: ah, interesting. that's not quite the same type of thing that I was picturing the doc for
11:45:32 <kowey> Chile`: well, one feature I want to see, and it's a minor one...
11:45:53 <kowey> is to be able to do something like darcs diff --match 'touching foo bar baz'
11:46:12 <kowey> the novelty here being the 'touching' matcher that selects patches that touch a specific file
11:46:23 <kowey> or hmm, maybe that's too specific?
11:47:09 <Chile`> interesting idea. isn't there a file-specific diff tool though?
11:47:31 <kowey> ah! but then the matcher could be used for stuff like
11:47:40 <kowey> darcs unpull --match 'touching foo && author bob'
11:48:09 <kowey> likewise, a 'hunk' matcher would be useful to grab patches whose contents have a specific hunk
11:48:51 <Chile`> ah, interesting.
11:48:54 <dcoutts> mmorrow: I'm not doing it from scratch :-) I'm building a hackage-server using HAppS with Lemmih. We'll be demoing it tomorrow at AngloHaskell.
11:49:44 <dcoutts> mmorrow: we're getting ~1000 requests per sec with static content and ~200-400 with dynamic
11:49:51 <mmorrow> dcoutts: ah, cool. that's the one that's gonna have a live webcast, right?
11:50:06 <dcoutts> mmorrow: oh, we're not doing an official talk
11:50:18 <dcoutts> just showing off
11:50:24 <mmorrow> heh
11:50:39 <mmorrow> is there a code repo anywhere yet?
11:50:43 <mmorrow> i'd love to see
11:50:46 <dcoutts> code.haskell.org/hackage-server
11:51:01 <dcoutts> it's got nearly 30 deps, so use cabal-install
11:51:22 <mmorrow> sweet
11:51:27 * mmorrow darcs pulls
11:51:36 <dcoutts> we're madly hacking in build reporting in time for tomorrow
11:51:43 <dcoutts> you any good with xhtml? :-)
11:52:26 <mmorrow> uh, i'm ok with it...but i'm swamped with work today :(
11:53:20 <dcoutts> always the problem :-)
11:53:38 <mmorrow> dcoutts: very true :). what are you trying to get done by tomorrow in particular?
11:54:10 <mmorrow> (wrt xhtml)
11:54:11 <adamw> kowey: okay, running test build with haddock 0.9 now, it'll take 15 mins or so to reach the fail point i guess
11:54:32 <dcoutts> mmorrow: have cabal-install collect build logs and build meta-data and upload it to hackage and have it presented there.
11:55:22 <dcoutts> mmorrow: so we've got the stuff stored on the server and we need to present it nicely, currently we've got some simple ugly html tables and plain text presentation.
11:56:22 <dcoutts> see Distribution/Server/Pages/BuildReports.hs
11:56:45 <mmorrow> heh, i see. cool i'll check it out...
12:04:58 <adamw> kowey: identical error with haddock 0.9 - i'll try 2.0
12:10:21 <jeffwheeler> > take 5 $ repeat 'm'
12:10:25 <lambdabot>  "mmmmm"
12:10:26 <jeffwheeler> What's a better way to write that?
12:10:36 <jeffwheeler> I'm sure there's some function in Prelude.
12:10:38 <dmhouse> > replicat 5 'm'
12:10:39 <lambdabot>   Not in scope: `replicat'
12:10:41 <dmhouse> > replicate 5 'm'
12:10:42 <lambdabot>  "mmmmm"
12:10:47 <jeffwheeler> ah, okay; thanks
12:11:30 <jeffwheeler> Does that just do the other internally?
12:11:38 <dmhouse> ?src replicate
12:11:38 <lambdabot> replicate n x = take n (repeat x)
12:11:47 <jeffwheeler> I win!
12:13:07 <Twey> @pl \b d -> a b $ c d
12:13:07 <lambdabot> (. c) . a
12:13:18 <Twey> Oh, 'course
12:13:20 <Shiruka> "Sorry I wrote such a big function, but I didn't have time to look up all the prelude functions needed to compress my code."
12:13:23 <Twey> That pattern always gets me :(
12:13:27 <Twey> Shiruka: *wince*
12:13:39 <Twey> You know you're in for it when you hear...
12:14:16 <olsner> jeffwheeler: "mmmmm" is shorter than both :D
12:14:30 <jeffwheeler> olsner: but oh so much less fun
12:14:35 <olsner> indeed
12:14:48 <Shiruka> but it's against "don't repeat yourself" principle, look at all the repetition of the m's there! :-O
12:15:07 <dmhouse> > nub "replicate 5 'm'" -- Ultimate DRY
12:15:08 <lambdabot>  "replicat 5'm"
12:15:19 <Deewiant> > nub "mmmmm"
12:15:20 <lambdabot>  "m"
12:15:36 <mmorrow> > take 5 ['a'..'z']
12:15:37 <lambdabot>  "abcde"
12:15:50 <mmorrow> what about this case though!!!
12:15:53 <Shiruka> proper DRY code doesn't change meaning then you nub it
12:15:54 <Deewiant> > take 5 ['a'..]
12:15:54 <lambdabot>  "abcde"
12:16:00 <mmorrow> heh
12:16:05 <Shiruka> *when :-(
12:16:12 <jeffwheeler> > take 28 ['a'..]
12:16:13 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|"
12:16:20 <olsner> > take x "mmmmmmmmmmmmmmmmmmmmmmmmmmmm" -- NOTE: Add an m when increasing x beyond the length of the string
12:16:21 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
12:16:27 <Shiruka> take 85 [' '..]
12:16:34 <Shiruka> > take 85 [' '..]
12:16:35 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
12:16:36 <Shiruka> sigh :-)
12:16:49 <olsner> looks like a perl program :)
12:17:01 <mmorrow> hah
12:17:02 <jeffwheeler> It probably compiles.
12:17:09 <Shiruka> @let perl = take 85 [' '..]
12:17:10 <lambdabot> Defined.
12:17:27 <Deewiant> > fix perl
12:17:28 <lambdabot>  Couldn't match expected type `a -> a'
12:17:30 <Deewiant> :-(
12:17:40 <geezusfreeek> lol
12:17:50 <jeffwheeler> > take 25 ['z'..]
12:17:51 <lambdabot>  "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
12:17:56 <mmorrow> > fix (perl:)
12:17:57 <lambdabot>  [" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
12:18:10 <Shiruka> > drop 20 perl
12:18:11 <lambdabot>  "456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrst"
12:19:03 <Shiruka> 20 can't be that small number :-(
12:19:11 <Beelsebob> > take 26 ['z','y'..]
12:19:12 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
12:19:34 <jeffwheeler> > reverse ['a
12:19:34 <lambdabot>  Improperly terminated character constant at "'a" (column 10)
12:19:36 <jeffwheeler> err
12:19:40 <jeffwheeler> > reverse ['a'..'z']
12:19:42 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
12:20:02 <jeffwheeler> > ['z'..'a']
12:20:03 <lambdabot>  ""
12:20:05 <bjrn> "> take 26 ['z','y'..]" I see lambdabot is not under the influence of strong substances.
12:20:19 <geezusfreeek> > reverse "your mom"
12:20:20 <lambdabot>  "mom ruoy"
12:20:23 <Trinithis> lol
12:20:51 <rwbarton> > zipWith id (cycle [toUpper, id]) ['a'..'z']
12:20:52 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
12:21:09 <jeffwheeler> @src cycle
12:21:09 <lambdabot> cycle [] = undefined
12:21:09 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:21:29 <jeffwheeler> That's funky.
12:22:19 <mmorrow> > fmap fst . sortBy (compare `on` snd) . M.toList . foldl' (\m x -> M.insertWith (+) x 1 m) mempty . take 100000 . randomRs ('a','z') . mkStdGen $ 426546
12:22:22 <lambdabot>  "jhevauxkqtmypcdwlisgroznbf"
12:22:33 <rwbarton> > ap [toUpper, id] ['a'..'z']
12:22:34 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
12:22:46 <Beelsebob> > zipWith id (cycle (repeat 26 toUpper ++ repeat 26 id)) (cycle ['a'..'z'])
12:22:47 <lambdabot>  Couldn't match expected type `(Char -> Char) -> m'
12:23:11 <rwbarton> replicate
12:23:20 <Beelsebob> > zipWith id (cycle (replicate 26 toUpper ++ replicate 26 id)) (cycle ['a'..'z'])
12:23:21 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW...
12:23:39 <rwbarton> > liftM2 (flip id) ['a'..'z'] [toUpper, id]
12:23:40 <lambdabot>  "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"
12:24:00 <Shiruka> > replicate 3 "phaser"
12:24:01 <lambdabot>  ["phaser","phaser","phaser"]
12:24:07 <geezusfreeek> > getZipList $ ZipList (cycle [toUpper, id]) <*> ZipList ['a'..'z']
12:24:08 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
12:24:19 <Beelsebob> > ['a'..'z'] >>= [toUpper, id]
12:24:20 <lambdabot>  Couldn't match expected type `Char -> [b]'
12:24:38 <Beelsebob> > ['a'..'z'] >>= [(:[]) . toUpper, (:[]) . id]
12:24:38 <lambdabot>  Couldn't match expected type `Char -> [b]'
12:24:50 <Beelsebob> > ['a'..'z'] >>= join [(:[]) . toUpper, (:[]) . id]
12:24:51 <lambdabot>  Couldn't match expected type `Char -> Char -> [b]'
12:24:54 <Beelsebob> bah
12:25:30 * jeffwheeler wants a client that does syntax-highlighting and parentheses matching after '>'
12:25:33 <dmhouse> That simply won't work. >>= is concatMap
12:25:54 <Beelsebob> yeh, I know
12:25:59 <Beelsebob> I was being a noob
12:26:35 <Shiruka> > if (1 > 2) { printf("noob\n"); }
12:26:35 <lambdabot>  Parse error at "("noo..." (column 20)
12:27:48 <mmorrow> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . foldl' (\m x -> M.insertWith (+) x 1 m) mempty . take 100000 . randomRs ('a','z') . mkStdGen $ 426546  -- random substitution cipher generator
12:27:49 <lambdabot>  [('a','j'),('b','h'),('c','e'),('d','v'),('e','a'),('f','u'),('g','x'),('h',...
12:28:24 <rwbarton> I bet 100000 isn't big enough that you need foldl'
12:28:59 <mmorrow> ha. i'd use it with 10 ;)
12:29:17 <mmorrow> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . foldl' (\m x -> M.insertWith (+) x 1 m) mempty . take 10000000 . randomRs ('a','z') . mkStdGen $ 426546  -- random substitution cipher generator
12:29:21 <lambdabot>  Tried to use too much memory
12:29:26 <mmorrow> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . foldl' (\m x -> M.insertWith (+) x 1 m) mempty . take 1000000 . randomRs ('a','z') . mkStdGen $ 426546  -- random substitution cipher generator
12:29:30 <lambdabot>  [('a','z'),('b','g'),('c','c'),('d','x'),('e','t'),('f','n'),('g','y'),('h',...
12:29:35 <rwbarton> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . M.fromListWith (+) 0 . zipWith (repeat 1) . take 100000 . randomRs ('a','z') . mkStdGen $ 426546
12:29:36 <lambdabot>  Couldn't match expected type `a1 -> M.Map k a'
12:30:01 <rwbarton> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . M.fromListWith (+) . zipWith (repeat 1) . take 100000 . randomRs ('a','z') . mkStdGen $ 426546
12:30:02 <lambdabot>  Couldn't match expected type `a -> b -> c'
12:30:25 <rwbarton> > zip ['a'..] . fmap fst . sortBy (compare `on` snd) . M.toList . M.fromListWith (+) . (`zip` (repeat 1)) . take 100000 . randomRs ('a','z') . mkStdGen $ 426546
12:30:27 <lambdabot>  [('a','j'),('b','h'),('c','e'),('d','v'),('e','a'),('f','u'),('g','x'),('h',...
12:30:49 <geezusfreeek> > ['a'..'z'] >>= \c -> if fromEnum c `rem` 2 == 1 then [toUpper c] else [c]
12:30:50 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
12:31:13 <mmorrow> nice. i wonder if that (repeat 1) list would have any additional overhead with -O2
12:31:43 <geezusfreeek> @src repeat
12:31:44 <lambdabot> repeat x = xs where xs = x : xs
12:32:10 <rwbarton> wait, your foldl' doesn't do anything anyways.  You need a stricter insertWith
12:33:05 <mmorrow> rwbarton: that's true, but i think it'll help with the Map (i'm not positive, but worst case it's === foldl)
12:33:06 <rwbarton> > (M.fromList [(1, undefined)]) `seq` 1
12:33:07 <lambdabot>  1
12:33:21 <adamw> kowey: gah, I just keep falling down rabbit holes here
12:33:23 <mmorrow> hmm
12:33:47 <jeffwheeler> > let rep x = x : (rep x) in take 5 (rep 3)
12:33:48 <lambdabot>  [3,3,3,3,3]
12:33:54 <jeffwheeler> Why isn't repeat defined like that?
12:34:07 <adamw> kowey: haddock 2.0.0.0 won't build with ghc 6.8.3. haddock 2.2.1 which i just had to drag out of darcs apparently does, but needs ghc-paths , which is something new, and i can't get it to build...sigh
12:34:11 <dmhouse> jeffwheeler: AFAIK, it's to avoid foxing simplistic CSE optimisers.
12:34:28 <rwbarton> jeffwheeler: that version can use linear space in some circumstances
12:34:40 <jeffwheeler> Hmm, okay.
12:34:46 <Deewiant> where 'in some circumstances' == 'with crap optimizers'
12:35:38 <adamw> kowey: could you just give me the configure workaround maybe?
12:35:45 <kowey> adamw : it may be available on http://hackage.haskell.org
12:35:46 <lambdabot> Title: HackageDB: introduction
12:35:47 <geezusfreeek> > fst $ head $ M.toList $ M.fromList [(1, undefined)]
12:35:48 <lambdabot>  1
12:36:03 <adamw> kowey: what might? ghc-paths ? i've found it but i can't build it
12:36:37 <kowey> adamw: oh, I was talking about haddock (sorry, didn't read fully)
12:36:43 <adamw> ah
12:36:52 <adamw> i dunno about there but i got it from darcs, it's tagged
12:37:33 <kowey> is building the api doc important to you?
12:38:40 <adamw> kowey: i don't honestly know how important it is, as I said, I'm not using haskell myself and I don't know who the hell on mdv does :) i'm just trying to update old packages...
12:38:59 <adamw> kowey: i could frankly probably skip it if it's going to avoid the problem
12:39:09 <adamw> kowey: so you just advise skipping make doc entirely?
12:39:16 <adamw> or...?
12:39:26 <kowey> or, you see http://hpaste.org/9449 ?
12:39:43 <adamw> yeah
12:39:44 <adamw> dump that bit?
12:39:50 <kowey> if you just set hdocbases to the empty string
12:40:52 <adamw> right
12:41:51 <kowey> maybe those flags won't trip haddock up
12:42:35 <kowey> i'm a bit annoyed because the changelog indicates that we try to work with both haddocks 1 and 2
12:43:16 <adamw> it's possible there's something stuffed up in our haskell packages, i really don't know, i ain't an expert on this stuff and it doesn't appear to be massively actively maintained
12:43:27 <adamw> so i wouldn't conclude there's a general problem unless you test this yourself and find the same :)
12:43:45 <waern> http://hpaste.org/9450 <- to get ghc-paths going with Cabal 1.5
12:44:03 <waern> if you're having trouble building ghc-paths, try that
12:44:07 <adamw> thanks, will do
12:46:52 <mmorrow> rwbarton: thats an excellent point, a strict insertWith is definitely in order
12:47:43 <dcoutts> waern: that code is pretty ugly. I should just do PackageIndex.lookupPackageName
12:47:46 <dcoutts> I/it
12:48:36 <adamw> waern: doesn't seem to work either. i don't know exactly what's going on with this 'cabal' thing here, given that i'm building in a distro environment; i *think* it's using cabalrpmdeps ...
12:49:49 <dcoutts> waern: btw, I applied your ghc-pkg dump patch. Thanks.
12:50:03 <waern> dcoutts: ok, I wasn't familiar with the types and just wanted to fix it quickly
12:50:12 <waern> dcoutts: so, tell Simon M that instead :)
12:50:21 <dcoutts> @arr
12:50:21 <lambdabot> Shiver me timbers!
12:50:33 <waern> but it's nice to know that there's a non-ugly way of doing it
12:50:40 <waern> dcoutts: np
12:55:20 <dmhouse> ?seen apfelmus
12:55:20 <lambdabot> I haven't seen apfelmus.
12:55:49 <Dr_Foo> @quote qwe1234
12:55:49 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
12:56:05 <dolio> Hah.
12:56:21 <twobitwork> wow... ghc is listed as hit #5 from google when the query is "compiler" :)
12:56:59 <bd_> twobitwork: personalized search? :)
12:56:59 <jeffwheeler> Not for me; it's not even on the first page. :-/
12:57:10 <Beelsebob> number 17 for me
12:57:12 <jeffwheeler> #13 for me
12:57:20 <twobitwork> bd_: ohh, you're right :P
12:57:25 <bd_> twobitwork: top right, more details :)
12:57:34 <twobitwork> I've never noticed that
12:57:49 <jeffwheeler> although ghs is the #1 ad ;)
12:58:15 <bd_> twobitwork: the more details thing is new
12:58:59 <twobitwork> jeffwheeler: the only ad for me is ghs.com
12:59:07 <geezusfreeek> #13 here
12:59:09 <jeffwheeler> Yeah, same. That's #1. :D
12:59:46 <ziman> #7 here
12:59:59 <jeffwheeler> Ever seen somebody who has the Google Desktop Search or whatever come up? It's /really/ weird to see somebody's files integrated right into the results.
13:00:01 <geezusfreeek> still, that's pretty good
13:02:15 <jeffwheeler> A lot of compilers are named after the language, so that's usually all you see.
13:02:36 <jeffwheeler> E.g. "python" is the compiler, "perl", etc.
13:02:42 <jeffwheeler> (Well, and some are interpreters, too.)
13:03:39 <cjb> "only perl can parse Perl"
13:03:56 <jeffwheeler> Haskell comes close.
13:04:07 <b_jonas> jeffwheeler: how so?
13:04:13 <jeffwheeler> b_jonas: PUGS
13:04:17 <jeffwheeler> (Or is it Pugs?)
13:04:24 <b_jonas> the compiler is called ghc, the language is haskell
13:04:27 <b_jonas> how's that even close?
13:04:48 <jeffwheeler> b_jonas: I meant Haskell came close to parsing Perl.
13:05:03 <mmorrow> b_jonas: oh, i thought they were the same thing ;)
13:05:27 <b_jonas> mmorrow: they _are_ the same, but named differently
13:05:30 <b_jonas> that's the point
13:05:56 <b_jonas> haskell, as we mangle it in haskelistan, is de facto defined by ghc
13:06:19 <mmorrow> b_jonas: not for long!! i heard haskell' is going to rename the lang to "ghc"
13:06:39 <jeffwheeler> Isn't that the same as saying hippopotamuses are equivalent to saying ï»¿hippopotamuses pools?
13:06:45 <mmorrow> hah, haskelistan
13:06:53 <jeffwheeler> They're related, but not exactly the same thing.
13:07:24 <Shiruka> you know, all your ghc code is evilly mangled by perl before it runs ;-P
13:07:25 <dolio> It's possible that Perl6 is less heinous to parse than Perl5.
13:08:07 <jeffwheeler> Then we've been cheating ourselves. We should've written a Perl5 compiler, instead.
13:08:10 <dmhouse> jeffwheeler: I think b_jonas's point is that what people consider to be part of the Haskell language is pretty much determined by what GHC implements.
13:08:16 <Dr_Foo> a new distro install never seems complete until i've got cabal-install set up
13:08:25 <dcoutts> :-)
13:08:27 <dmhouse> jeffwheeler: great analogy, btw.
13:08:39 <dcoutts> Dr_Foo: soon enough they'll come with it I hope
13:08:40 <mmorrow> Shiruka: only if you go -fvia-C though
13:08:47 <dcoutts> and the rest of the Haskell Platform
13:09:09 <Shiruka> hm, true.. and these days -fasm is default with -O too
13:09:17 <jeffwheeler> dmhouse: indeed, he's right in that regard; nevertheless, the compiler /is/ a different entity than the language it implements
13:09:37 <jeffwheeler> minus all the words about entity that made that sentence convoluted
13:10:11 <b_jonas> morrow: "haskelistan" is stolen from the chapter title of http://www.lojban.org/tiki/tiki-download_wiki_attachment.php?attId=198
13:10:12 <lambdabot> Title: Lojban Reference Grammar: Chapter 1, http://tinyurl.com/5ckk58
13:10:20 <bd_> dolio: perl6's parser is being written in perl6 itself. This is perhaps not conductive to easy parsing.
13:10:47 <bd_> (they're using a restricted subset right now, for bootstrapping)
13:10:54 <mmorrow> b_jonas: haha, " Lojban As We Mangle It In Lojbanistan: ..."
13:11:59 <dolio> bd_: Well, to parse Perl5, you need to be able to execute Perl5, so it can't be much worse than that.
13:12:44 <bd_> I suppose. At least syntax extensions will be more well behaved (instead of doing random text manipulation before parsing...)
13:12:58 <pozic> Why doesn't Debug.Trace support Unicode?
13:13:21 <Toxaris> > foldr (curry $ let swap = snd &&& fst in ((swap >>> first (snd >>> fst) >>> app >>> (:)) &&& (snd >>> fst) >>> app) &&& (snd >>> snd >>> swap)) ([], (id, toUpper)) >>> fst $ ['a'..'z']
13:13:22 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
13:13:26 <bd_> pozic: because none of the core I/O stuff supports unicode
13:14:02 <glguy> The core IO stuff supports Unicode, but not utf-8
13:14:07 <b_jonas> bd_: by core, do you mean what comes with ghc, or h89 standard?
13:14:29 <b_jonas> dolio: to parse perl6, you need to be able to execute perl6
13:14:31 <bd_> either, I think?
13:14:51 <b_jonas> and that's apparently harder, because executing perl6 well is an unsolved problem as yet
13:15:02 <dolio> b_jonas: Oh yeah? Same issue as Perl5?
13:15:08 <b_jonas> dolio: yeah
13:15:13 <b_jonas> dolio: it's considered a feature
13:15:13 <bd_> b_jonas: you can embed parrot and use the perl6 compiler library. Which doesn't exist yet.
13:15:17 <dolio> That's not surprising, I guess.
13:15:33 <sw17ch> so, does Pugs work? or not?
13:15:41 <b_jonas> bd_: sure, that's why they say 'nothing but perl can parse perl' isntead of 'nothing can parse perl'
13:15:51 <bd_> sw17ch: it was hibernating for a while, I think it's starting to awaken from its slumber lately...
13:15:51 <jeffwheeler> I think Pugs is a partial implementation, so far.
13:16:21 <b_jonas> jeffwheeler: yep, there are working partial implementatoins
13:16:43 <jeffwheeler> The last Perl guy I talked to said that it was a good start, but they quickly realized that there are very few Haskell people out there; even fewer know Perl really well, too.
13:17:01 <sw17ch> I'm in a compiler group, and we've been targeting Parrot
13:17:16 <sw17ch> (most of us are compiler n00bs though... we have one professor who's done a bunch)
13:18:03 <Heffalump> most of the people where I work pick up Haskell pretty quickly if they need it
13:18:31 <jeffwheeler> I find I have to play with it about three hours before I get the hang of it, each time, and then can do decently.
13:18:46 <jeffwheeler> I'm not very experienced. :D
13:19:40 <b_jonas> jeffwheeler: wow
13:19:51 <b_jonas> after about how long a pause?
13:19:58 <jeffwheeler> I don't know, a few weeks.
13:20:23 <jeffwheeler> I've been getting slightly better, but I'm still slow.
13:20:47 <jeffwheeler> I usually dive into more than I can handle. ;)
13:21:43 <b_jonas> diving into more than you can handle can help learning
13:21:51 <jeffwheeler> . . . and it does.
13:23:56 <cnwdup_> I've got a aesthetic question concerning a GTK+ app: Since some functions alter some widgets I am about to put all the widgets in a data structure and put that into a Reader. How ugly is that?
13:23:57 <dublpaws> > concat [[fst x, snd x] | x <- zip ['A','C'..'Z'] ['b','d'..'z']]
13:23:58 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
13:24:01 <cnwdup_> And what are better ways?
13:25:20 <Heffalump> cnwdup_: these are mutable widgets?
13:25:30 <EvilTerran> > concat . transpose $ [['A','C'..'Z'], ['b','d'..'z']]
13:25:31 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
13:25:31 <Heffalump> and you're using ReaderT .. IO ?
13:25:49 <cnwdup_> heffalump: For instance I want to change the label's text somewhere in the program. Yep, meant ReaderT.
13:26:04 <EvilTerran> > zipWith ($) (cycle [id,toLower]) ['A'..'Z']
13:26:06 <lambdabot>  "AbCdEfGhIjKlMnOpQrStUvWxYz"
13:26:07 <cnwdup_> I somehow have to pass a few labels to the function that handles key presses.
13:26:32 <Heffalump> cnwdup_: I don't know GTK+ particularly, but that sounds like a reasonable approach.
13:26:50 <cnwdup_> heffalump: I somehow feel that this is ugly. But I can't think of a better way. \-:
13:27:04 <cnwdup_> heffalump: Well, thanks for your validation.
13:27:11 <Heffalump> It's fairly standard to layer stuff on top of IO to avoid having to explicitly pass it around.
13:27:55 <Heffalump> When you say "alter the widgets", presumably the actual alteration is something done by GTK+ in an IO operation?
13:28:15 <cnwdup_> It is. I just have to pass the widget to that function.
13:28:17 <Heffalump> (since Reader[T] doesn't let you alter what is passed in, just change it for a sub-invocation)
13:28:30 <cnwdup_> I just have to save the widget names there.
13:29:46 <dmhouse> What's the canonical name for the function Void -> a?
13:30:00 <Elly> dmhouse: aren't those continuations?
13:30:03 <roconnor> dmhouse: some people call it void
13:30:04 <dolio> void
13:30:07 <Heffalump> dmhouse: canonical in what sense?
13:30:11 <roconnor> dmhouse: some people call it abort
13:30:13 <dmhouse> Elly: no, not really.
13:30:18 <dmhouse> Heffalump: most standard.
13:30:18 <Heffalump> "not a" is the logical interpretation, AIUI
13:30:22 <bd_> dmhouse: const undefined? :)
13:30:31 <dmhouse> bd_: or just "undefined" ;)
13:30:47 <dolio> not a is a -> Void.
13:30:50 <bd_> dmhouse: no, this function is not the bottom itself, with seq.
13:30:52 <roconnor> some people call it fold :)
13:30:59 <bd_> > (const undefined) `seq` ()
13:31:00 <lambdabot>  ()
13:32:35 <roconnor> I'd might call it "abort" myself
13:32:53 <roconnor> although that isn't a very good name
13:33:08 <pozic> Is the Void we speak of here ()?
13:33:09 <roconnor> but it is better than void IMHO
13:33:16 <roconnor> pozic: nope
13:33:21 <roconnor> data Void =
13:33:21 <dmhouse> I might call it empty
13:33:36 <pozic> roconnor: isn't that data Void ?
13:33:51 <roconnor> pozic: oh is it?
13:33:57 <b_jonas> dmhouse: thunk?
13:34:01 <ski> @djinn Void -> a
13:34:01 <lambdabot> f = void
13:34:14 <bd_> :t void
13:34:26 <ski> void :: forall a. Void -> a
13:34:29 <pozic> roconnor: I have never seen your version, but I used mine.
13:34:41 <Twey> What is Void?
13:34:44 <Twey> o.@
13:34:48 <ski> the empty type
13:34:57 <roconnor> pozic: Simon Thompson calls it abort in his book.
13:35:07 <b_jonas> ski: the empty type, not the unit one?
13:35:17 <Twey> The point of this being...?
13:35:20 <roconnor> pozic: oh you mean the declairation
13:35:20 <ski> i think Filinski has called it `abort' too ..
13:35:22 <b_jonas> I thought that type is called something like Abstract
13:35:30 <Twey> How can it ever be used?  What use has it?
13:35:32 <ski> (or maybe 'twas Thielecke ?)
13:35:34 <roconnor> pozic: well, it isn't haskell 98, so I'm not sure what synax GHC uses.
13:35:39 <pozic> Twey: Curry-Howard stuff, AFAIK.
13:35:45 <ski> b_jonas : right, the empty type
13:35:49 <pozic> Excluded middle and all that.
13:35:57 <roconnor> Twey: Maybe Void
13:36:06 <b_jonas> ski: what's the void function do then?
13:36:09 <b_jonas> @src void
13:36:09 <lambdabot> Source not found. Where did you learn to type?
13:36:11 <ski> roconnor :)
13:36:20 <roconnor> @djinn Maybe Void
13:36:20 <lambdabot> f = Nothing
13:36:21 <b_jonas> is it const undefined?
13:36:29 <ski> void u = case u of {}
13:36:36 <b_jonas> ski: I see
13:36:38 <ski> `void' would be a total function
13:36:41 <dolio> It proves an arbitrary proposition given the false proposition.
13:36:45 <dmhouse> Or void _ = undefined
13:37:02 <ski> dmhouse : nicer with no `undefined' in the source, imho
13:37:08 <b_jonas> dmhouse: undefined is different
13:37:08 <roconnor> dmhouse: that version seems less strict
13:37:13 <dmhouse> ski: probably right.
13:37:17 <dmhouse> b_jonas: not really.
13:37:34 <roconnor> dmhouse: although I'm not certain it is.
13:37:39 <dmhouse> b_jonas: you can never reach the 'undefined' in that definition, so they're equivalent I think.
13:37:40 <roconnor> :)
13:37:41 <b_jonas> dmhouse: well, seq differentiates between them I think
13:37:49 <ski> roconnor : how do you define strictness for functions over non-pointed types ?
13:37:50 <dmhouse> How?
13:37:51 <b_jonas> but seq is the only thing that can
13:38:18 <b_jonas> oh, void _ = undefined
13:38:18 <ski> (`seq' is evil anyway ..)
13:38:21 <dmhouse> > const undefined () `seq` ()
13:38:22 <lambdabot>  Exception: Prelude.undefined
13:38:22 <b_jonas> not void undefined
13:38:24 <roconnor> ski: okay I believe they are the same.
13:38:26 <b_jonas> in that case they're the same I think
13:38:33 <b_jonas> sorry
13:38:45 <dmhouse> NP, crossed wires.
13:39:02 <roconnor> well, modulo the exception that is thrown
13:39:48 <dmhouse> Strictly we're talking denotational semantics anyway.
13:39:57 <dmhouse> (So in particular, sod off with your seq's ;))
13:40:13 <b_jonas> rocconor: oh yeah, in that sense undefined and undefined might be different too if the compiler preserves line number and position information for them
13:41:27 <hackage> Uploaded to hackage: hsXenCtrl 0.0.7
13:41:51 <ziman> @djinn a -> [a]
13:41:51 <lambdabot> -- f cannot be realized.
13:42:07 <ski> no lists for the djinn
13:42:17 <dmhouse> ?djinn-env
13:42:17 <lambdabot> data () = ()
13:42:17 <lambdabot> data Either a b = Left a | Right b
13:42:17 <lambdabot> data Maybe a = Nothing | Just a
13:42:17 <lambdabot> data Bool = False | True
13:42:17 <lambdabot> data Void
13:42:19 <lambdabot> type Not x = x -> Void
13:42:21 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:42:38 <dolio> @djinn-add type Cont r a = (a -> r) -> r
13:42:40 <dmhouse> I don't think it can do recursive types, can it?
13:42:45 <dmhouse> ?djinn-add data List a = Nil | Cons a (List a)
13:42:48 <ski> i can't
13:42:51 <b_jonas> @more
13:42:52 <ski> s/i/it/ :)
13:43:00 <dmhouse> ?djinn a -> List a
13:43:01 <lambdabot> Cannot parse command
13:43:01 <lambdabot> -- f cannot be realized.
13:43:03 <ski> @less
13:43:04 <lambdabot> Maybe you meant: let list oeis
13:43:23 <b_jonas> dolio: I thought it doesn't have lists becasue it can't handle them anyway
13:43:41 <ski> @djinn-clr
13:44:09 <ziman> @djinn Maybe (a, Maybe a) -> a
13:44:09 <lambdabot> -- f cannot be realized.
13:44:38 <b_jonas> @djinn-env
13:44:38 <lambdabot> data () = ()
13:44:38 <lambdabot> data Either a b = Left a | Right b
13:44:38 <lambdabot> data Maybe a = Nothing | Just a
13:44:38 <lambdabot> data Bool = False | True
13:44:38 <lambdabot> data Void
13:44:41 <lambdabot> type Not x = x -> Void
13:44:42 <b_jonas> @more
13:44:42 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:45:46 <dmhouse> ?djinn ((a -> b) -> a) -> a
13:45:46 <lambdabot> -- f cannot be realized.
13:45:56 <dolio> @djinn-add type Cont r a = (a -> r) -> r
13:46:12 <dmhouse> ?djinn Either a (Not a)
13:46:12 <lambdabot> -- f cannot be realized.
13:46:18 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
13:46:18 <lambdabot> f a b = a (\ c _ -> b c) b
13:46:33 <dmhouse> Intuitionistic logic ftw!
13:46:58 <dolio> @djinn Not (Not (((a -> b) -> a) -> a))
13:46:59 <lambdabot> f a =
13:46:59 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
13:47:18 <b_jonas> yeah
13:47:45 <ziman> @djinn (a ->(b->c)) -> ((a->b)->(a->c))
13:47:46 <lambdabot> f a b c = a c (b c)
13:48:05 <ski> @djinn ((a,Either a0 a1),(b,Either b0 b1),(c,Either c0 c1)) -> (Either a (Either a0 a1),Either b (Either b0 b1),Either c (Either c0 c1))
13:48:05 <lambdabot> f ((a, b), (c, d), (e, _)) =
13:48:05 <lambdabot>     case b of
13:48:05 <lambdabot>     Left _ -> case d of
13:48:05 <lambdabot>               Left _ -> (Left a, Left c, Left e)
13:48:05 <lambdabot>               Right _ -> (Left a, Left c, Left v46)
13:48:07 <lambdabot>     Right f -> case v78 of
13:48:09 <lambdabot>                Left _ -> (Left a, Left v77, Left v82)
13:48:11 <lambdabot>                Right g -> case v114 of
13:48:13 <lambdabot>                           Left _ -> (Left a, Left v77, Left v113)
13:48:15 <lambdabot>                           Right h -> (Right (Right f), Right (Right g), Right (Right h))
13:48:31 <dolio> Nice.
13:48:34 <ziman> wow :)
13:48:52 <ski> let me check whether it gave the "right" solution ..
13:49:01 <sw17ch> djinn is magic...
13:49:12 <ski> ("right" meaning the one i wanted)
13:49:17 <sw17ch> :t lookup
13:49:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:49:49 <mmorrow> whoa
13:49:54 <mmorrow> djinn++
13:50:02 <ski> hm, no it didn't
13:50:07 <sw17ch> @djinn (Eq a) => a -> [(a,b)] -> Maybe b
13:50:07 <lambdabot> f _ _ = Nothing
13:50:09 <sw17ch> cheater
13:50:25 <ski> fyi, the wanted function was the `gustave' one
13:50:37 <dmhouse> It's a theorem prover. It attemps to find any inhabitant of the type given.
13:50:50 <mmorrow> @djinn (Eq a) => a -> (forall b.b) -> Maybe a
13:50:50 <lambdabot> f a _ =
13:50:50 <lambdabot>     case a == a of
13:50:50 <lambdabot>     False -> Nothing
13:50:50 <lambdabot>     True -> Just a
13:51:11 <ski> e.g. mentioned in "Coherent Banach Spaces : A Continuous Denotational Semantics", by Jean-Yves Girard
13:51:36 <dolio> I wonder why it didn't give 'f ((a, _), (b, _), (c, _)) = (Left a, Left b, Left c)'
13:51:40 <mmorrow> @djinn (Eq a) => (forall c. a -> (forall b.b -> c)) -> a -> Maybe a
13:52:10 <adamw> kowey: okay, just fyi - that workaround works
13:52:13 <dmhouse> ski: is empty x = case x of {} valid Haskell?
13:52:15 <dolio> Or am I parsing that type wrongly?
13:52:22 <ski> dmhouse : it should be
13:52:24 <mmorrow> uhoh, i hope it didn't explode
13:52:27 <kowey> adamw: great... sorry for the trouble
13:52:29 <ski> (but it isn't)
13:52:29 <dmhouse> > let empty x = case x of {} in 4
13:52:30 <lambdabot>  Parse error at "}" (column 26)
13:52:33 <dmhouse> ski: oh.
13:52:37 <adamw> kowey: now i'm struggling with something else, sigh. it seems "make install" is necessary before "make wx", yes?
13:52:42 <adamw> kowey: this is very bad for packaging...
13:52:45 <kowey> yes
13:52:50 <adamw> sigh, fun
13:52:50 <glguy> {} -> _  ?
13:52:52 <kowey> you should think of it as two separate packages
13:52:54 <ski> maybe GHC's extension for allowing empty types allow this too, i'm not sure
13:52:57 <kowey> in one tarball
13:53:00 <adamw> yeah, i'll have to figure out a way to split it up
13:53:02 <mmorrow> @djinn (Eq a) => (forall c. a -> (forall b.b -> c)) -> a -> Maybe a
13:53:15 <dmhouse> glguy: no, we want no branches. And _ on the RHS?
13:53:16 <adamw> kowey: we were previously using an ancient version
13:53:20 <dolio> Actually, what's "v46" and so on in that definition djinn gave?
13:53:26 <kowey> well, you could make two packages... at the slight cost of downloading the tarball twice
13:53:32 <dolio> Bug?
13:53:36 <adamw> kowey: yes, I might do that in the end
13:53:48 <ski> dolio : fresh variables, i think ..
13:53:55 <adamw> kowey: but just for my education - we previously had 0.9.4.1
13:54:01 <adamw> kowey: in the spec for that, it just does:
13:54:06 <adamw> make all
13:54:10 <dolio> ski: Right, but they're not bound anywhere.
13:54:18 <adamw> and then make install-files
13:54:23 <adamw> did things change since then?
13:54:27 <ski> dolio : hm, you're right ..
13:54:28 <adamw> or was that not building / installing everything?
13:54:33 <kowey> adamw: yeah, unfortunately... there was a technical reason for this
13:54:34 <ski> augustss : see above
13:54:36 <mmorrow> @djinn (forall a.a) -> ()
13:54:36 <lambdabot> f _ = ()
13:54:37 <adamw> okay
13:54:38 <kowey> something about shared modules
13:54:48 <kowey> basically GHC changed for the better
13:54:58 <kowey> but there was a slight cost to us
13:55:10 <adamw> kowey: ok, so with current version, make -> make install -> make wx -> make wx-install is the equivalent
13:55:17 <mmorrow> @djinn (forall b. a -> b) -> a -> Maybe b
13:55:17 <lambdabot> f _ _ = Nothing
13:55:20 <adamw> as long as that's the case it's alright, i can split it into two packages
13:55:23 <kowey> yes
13:55:25 <adamw> just wanted to make sure i wasn't missing anything
13:55:29 <kowey> in fact, you could cd wx
13:55:34 <dolio> mmorrow: djinn doesn't do higher-rank polymorphism.
13:55:37 <ski> mmorrow : i don't think the djinn handles higher-rank types
13:55:40 <kowey> and think of it as having its own little build system
13:55:48 <mmorrow> i thought it just handled one earlier
13:55:53 * mmorrow scrolls back
13:55:58 <kowey> (which would be cabal, btw)
13:56:20 <adamw> kowey: okay, so have the main package do "make / make install" and have the other package do "cd wx" then "make / make install"?
13:56:26 <mmorrow> @djinn (Eq a) => a -> (forall b.b) -> Maybe a
13:56:26 <lambdabot> f a _ =
13:56:26 <lambdabot>     case a == a of
13:56:26 <lambdabot>     False -> Nothing
13:56:26 <lambdabot>     True -> Just a
13:56:33 <mmorrow> i guess that doesn't really count though
13:56:44 <ski> @paste
13:56:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:57:01 <adamw> hmm, wx doesn't have a makefile though
13:57:04 <adamw> oh well i'll figure it out
13:57:05 <adamw> thansk
13:57:11 <kowey> err. it's runhaskell Setup configure
13:57:15 <adamw> ah yeah
13:57:19 <kowey> runhaskell Setup build and runhaskell Setup install
13:57:22 <adamw> same as all the others
13:57:26 <dolio> @djinn forall b -> forall b
13:57:26 <lambdabot> f a = a
13:57:48 <ziman> is that correct?
13:57:59 <kowey> actually, you could also apply that methodology to wxcore (the stuff above)
13:58:02 <mrd> @djinn f b -> f b
13:58:02 <lambdabot> f a = a
13:58:07 <dcoutts> kowey: btw, we should talk sometime about what we need to do in Cabal so that wx doesn't need to use build-type: Make
13:58:33 <ziman> @djinn a -> m a
13:58:33 <lambdabot> -- f cannot be realized.
13:58:36 <kowey> dcoutts: sure!
13:58:36 <dcoutts> kowey: I'm sure we have similar issues in gtk
13:59:38 <ski> pasted "gustave" at <http://hpaste.org/9451>
13:59:44 <dcoutts> kowey: part of your problem is multiple custom pre-processors and building C++ right?
14:00:43 <kowey> dcoutts : my memory is rusty but that does sound right - http://bp2.blogger.com/_c6WmXt2id8U/R8HABBJjdjI/AAAAAAAAAHk/ZT_q6Ts53XY/s1600-h/components.png
14:00:45 <lambdabot> Title: components.png (image), http://tinyurl.com/5ohd47
14:00:52 <dcoutts> sioraiocht: remember, meet 8:10am tomorrow for 8:20 bus! :-)
14:01:01 <sioraiocht> haha
14:01:03 <sioraiocht> have no fear :)
14:01:10 <kowey> we generate some of our .hs from .h and .e files
14:01:38 <mmorrow> @djinn (forall a.a) -> (forall a.a)
14:01:38 <lambdabot> f a = a
14:02:00 <ski> @djinn (forall a. a) -> (forall a. Maybe a)
14:02:02 <mmorrow> @djinn (forall a.(a,b)) -> (forall a.(a,b))
14:02:02 <lambdabot> f a = a
14:02:18 <mmorrow> @djinn (forall a.(a,b)) -> (forall a.(a,c))
14:02:18 <lambdabot> -- f cannot be realized.
14:02:22 <ski> dolio : i pasted "gustave" at <http://hpaste.org/9451>
14:02:49 <mmorrow> ski: it seems like when you ask it a "nontrivial" one with higher order types, it just doesn't respond
14:03:13 <ski> dolio : iirc, that function was invented as a counter-example for serializable pattern-matching wrt an attempted formalization of serializable
14:03:19 <dcoutts> kowey: right. Hmm. You know it might be possible to make it work already, though the Setup.hs might get rather scary.
14:03:31 <mmorrow> @djinn (a -> b) -> a -> b
14:03:31 <lambdabot> f a = a
14:04:03 <mmorrow> @djinn (b -> c -> d) -> (forall a.(a,b)) -> (forall a.(a,c)) -> d
14:04:03 <lambdabot> -- f cannot be realized.
14:04:13 <mmorrow> @djinn (b -> c -> d) -> (forall a.(a,b)) -> c -> d
14:04:13 <lambdabot> -- f cannot be realized.
14:04:28 <mmorrow> @djinn (b -> c -> d) -> ((forall a.a),b) -> c -> d
14:04:28 <lambdabot> f a (_, b) c = a b c
14:06:04 <ski> (dolio : btw, djinn tries to be relevant in its answers ..)
14:07:13 <visq> dcoutts: regarding c2hs: is it ok to fix the parser ?
14:07:32 * ski sighs
14:07:37 <dcoutts> visq: fix it how?
14:07:42 <mmorrow> visq: i think that's what language-c is doing
14:07:59 <visq> i send an email recently, because of CDeclr to c2hs mailing list
14:07:59 <mmorrow> visq: http://code.haskell.org/language-c/
14:07:59 <lambdabot> Title: Index of /language-c
14:08:10 <dcoutts> visq: oh, sorry, I've not read that yet
14:08:10 <visq> mmorrow: I'm working on language-c
14:08:10 <mmorrow> visq: oh, i gotcha
14:08:15 <mmorrow> visq: heh
14:08:41 <visq> but dcoutts's parser was almost bug free :)
14:09:01 <visq> dcoutts: no problem.
14:09:53 <jeffwheeler> What is language-c? A C parser?
14:10:06 <visq> short story: parser returns (char*x[]) as (CPtrDeclr (CArrDeclr (...))
14:10:13 <visq> but I think it should be the other way round
14:10:20 <dcoutts> visq: is that right, char * x[]
14:10:36 <dcoutts> I thought that meant a pointer to an array, not an array of pointers
14:10:37 <dolio> ski: Serializable meaning? Splitting the matches into a tree of cases?
14:10:41 <ski> (dolio : if you see a non-ascii character in the paste, that should be `×', i.e. a "times" cross symbol)
14:10:44 <EvilTerran> char*x[] is an array of char pointers, i think
14:11:01 <visq> EvilTerran: right
14:11:01 <dolio> Yeah, that's what I was guessing.
14:11:08 <ski> dolio : yes, basically deciding which part to pattern-match first one
14:11:32 <visq> dcoutts: because of this, sizeof fails for e.g. (char*x[3))
14:11:45 <dolio> Yeah, this reminds me of a version of the majority function discussed on the Epigram list a while back.
14:11:53 <visq> but I wasn't sure if parser or analysis is wrong
14:12:01 <dcoutts> visq: sure, it'd cause all sorts of problems if we've got it the wrong way round
14:12:09 <dolio> Although maybe this one isn't just a contrivance.
14:12:23 <visq> dcoutts: is it ok if i fix this and darcs send the patch ?
14:12:37 <ski> dolio : e.g. `True || _ = True; _ || True = True; False || y = y; x || False = x; _|_ || _|_ = _|_' would not be serializable
14:12:41 <dcoutts> visq: so you're right in your reading: http://www.ericgiguere.com/articles/reading-c-declarations.html
14:12:41 <lambdabot> Title: Reading C Declarations
14:12:56 <dcoutts> char *argv[]; "declare argv as array of pointer to char"
14:13:25 <dcoutts> visq: so I guess it's a parser bug
14:13:31 <dolio> Ah, yeah.
14:13:43 <visq> dcoutts: I've been studying the C99 spec for some time now :)
14:13:46 <EvilTerran> dcoutts, given the whole arrays/pointers mess in C, i can see why you got confused :)
14:14:25 <dcoutts> visq: heh, or indeed it could be a misreading of our AST :-)
14:14:35 <dmhouse> I think most of the confusion re arrays/pointers is that the syntax for one is prefix, and the syntax for the other is postfix.
14:14:57 <dmhouse> I quite like the fact that x[i] = *(x+i).
14:15:09 <ski> dolio : in some sense `gustave' doesn't look at both parts of each of the three given pairs .. and the semantics agreed with this, i think
14:15:12 <adamw> kowey: so the first package should be named something like wxcore and the second one something like wx , yes?
14:15:21 <visq> dcoutts: wasn't too easy either, choosing good datatype names for C AST is a nightmare, too
14:15:43 <dcoutts> aye
14:15:55 <visq> jeffwheeler: language.c is a gnu99 parser and pretty printer library I'm working on
14:16:23 <visq> dcoutts: is there some interest in enum-define hooks too ?
14:16:38 <jeffwheeler> visq: sounds really neat; now we need a library to compile and optimize a lot :D
14:16:44 <dcoutts> visq: lots of people ask for it, nobody volunteers to implement it :-)
14:17:11 <ski> dolio : hm, how was the `majority' function defined ?
14:17:27 <visq> dcoutts: I want to do it. I guess generating enum types and then analyzing them is the easiest way to go ?
14:17:40 <mauke> what does '<stderr>: hPutStr: illegal operation (handle is finalized)' mean?
14:17:55 <jeffwheeler> mauke: you might have already closed stdin, I think
14:17:57 <dcoutts> visq: I'm not sure, I'd have to page in that whole issue :-)
14:17:59 <dolio> ski: Not the way you'd likely write it down at first. :)
14:18:06 <mauke> jeffwheeler: unlikely
14:18:16 <cnwdup_> @type (<-)
14:18:17 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:18:23 <cnwdup_> > :t (<-)
14:18:23 <lambdabot>  Parse error at "<-)" (column 5)
14:18:23 <jeffwheeler> mauke: then I'm not sure; that was what I had done to get the error in the past
14:18:25 <visq> dcoutts: of course. I'll just give it a try and post to c2hs mailing list
14:18:36 <mauke> jeffwheeler: this program doesn't touch stderr except for calls to hPutStr
14:18:55 <ski> cnwdup_ : the `<-' syntax is part of the syntax for `do'-blocks
14:19:12 <dcoutts> visq: so if you think we're reading the AST correctly, ie CPtrDeclr decl  really is a pointer type at the top level, then our parser must be wrong
14:19:34 <cnwdup_> ski: In the expression m <- (ioFunc::IO Int), then m is of type Int?
14:19:41 <jeffwheeler> mauke: Mine was a stdin issue, so I'm exactly sure, but it had been closed implicitly; I was trying to read using "contents" several times, after one had already captured all of stdin
14:19:42 <ski> cnwdup_ : if you have a command `foo <- bar' in a `do'-block, then if e.g. `bar :: IO Blah', then `foo :: Blah' .. similarly for other monads than `IO'
14:19:48 <dcoutts> visq: here's how to check, grab an old c2hs, in the old C parser and see what AST it generates.
14:19:51 <cnwdup_> ski: Ok, thanks.
14:19:52 <ski> cnwdup_ : right
14:19:56 <visq> dcoutts: Actually, I was thinking for the last two month that the parser is right and that it is a really weird AST representation :) Oh my
14:20:14 <mauke> jeffwheeler: hmm, no calls to getContents
14:20:16 <dcoutts> visq: it's not totally impossible! :-)
14:20:27 <mauke> oh wait
14:20:40 <dcoutts> visq: after all 'x' ends up at the most inner part of the decl, which doesn't correspond to my intuition
14:21:18 <visq> dcoutts: That's C syntax :) I've changed it for Language.C though.
14:21:20 <ski> dcoutts : `x' ?
14:21:48 <dcoutts> ski: "char * x[];" parsing as CPtrDeclr (CArrDeclr (CVarDeclr "x"))
14:21:57 <dcoutts> visq: aye, inside out
14:22:06 <dcoutts> visq: how do you represent it now?
14:22:26 <ski> this is not much different to `foo x = ..x..' (instead of `foo = \x -> ..x..')
14:22:28 <dolio> ski: http://hpaste.org/9451#a1
14:22:56 <visq> dcoutts: CDecl char (CDeclr x [CArr,CPtr]) , roughly
14:23:09 <ski> dolio : ty
14:23:12 <hml> what's the big deal about the computation monad?
14:23:25 <ski> (.. which computation monad ?)
14:23:50 <visq> dcoutts: I've removed the innermost VarDeclr, it didn't correspond to my intuition :)
14:24:16 <dcoutts> visq: aye. Though I'm not convinced about using [CArr,CPtr]
14:24:31 <visq> dcoutts: But C declarations are hard to understand, and there are nicer representations in the Analysis module
14:24:35 <hml> not sure; it sedems to be mentioned alot
14:24:51 <ski> visq : how do you represent `void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));' ?
14:25:00 <visq> dcoutts: It is actually [CArrDeclr,CPtrDeclr], read as Array of Pointers
14:25:14 <dolio> ski: Annotated with a link to Conor McBride's e-mail on it.
14:25:21 <visq> ski: the void doesn't belong to the declarator, syntactically
14:25:57 <visq> the rest is (simplified) [CFun (params)]
14:26:35 <mauke> preflex: cdecl void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
14:26:35 <preflex>  qsort: function(base: pointer to void, nmemb: size_t, size: size_t, compar: pointer to function(pointer to const void, pointer to const void) returning int) returning void
14:26:36 <dcoutts> visq: as for the second issue. I'm not sure why. I'd have to look at the darcs history of that comment.
14:26:39 <ski> or maybe `void (*(signal(int signum, sighandler_t handler)))(int);' would be a better example ..
14:27:01 <ski> dolio : ty again
14:27:19 <dolio> You're welcome.
14:27:32 <mauke> preflex: cdecl void (*(signal(int signum, sighandler_t handler)))(int);
14:27:32 <preflex>  signal: function(signum: int, handler: sighandler_t) returning pointer to function(int) returning void
14:27:43 <mauke> preflex++
14:28:12 <visq> dcoutts: it certainly wrong, but strange that this assumption was reused in the analysis code
14:28:33 <Nafai> mauke: Is preflex the bot you've been working on?
14:28:37 <mauke> Nafai: yes
14:29:18 <ski> hml : many monads can be seen as modeling "computation" of some sort ..
14:29:52 <mauke> this doesn't make sense :/
14:29:59 <mauke> nothing should cause stderr to be finalized
14:30:03 <dcoutts> visq: it may have been true once
14:30:44 <visq> dcoutts: there has to be at least one type qualfifier (const,volatile,restrict) ? I don't think so, but ..
14:30:48 <ski> visq : anyway .. i suppose my point would be that i would prefer either the earlier nested AST, or an inverse-nested one .. i can't explicate much about why, though
14:31:13 <hml> how is it that || let ok p = do {es}; ok _ = fail "..." in e >>= ok || equal to || e >>= \p -> es ||
14:31:43 <visq> ski: this is a tradeoff between parsing (reverse) and analysis (other way round)
14:31:44 <ski> hml : no
14:32:30 <dmhouse> hml: where p is a pattern?
14:32:46 <hml> where we have the statemnt " do { p <- e; es }"
14:32:51 <ski> visq : i'm just not sure why the "flat" version would be easier to understand than a nested one (either way)
14:33:03 <dmhouse> hml: yeah, that makes sense. It's the definition of do-blocks, essentially. What's wrong?
14:33:27 <visq> ski: It isn't easier to understand, but it seemed more convenient
14:33:58 <visq> ski: interesting comment anyway. Things aren't set in stone
14:35:08 <ski> what i would consider, i think, would be to either preserve the "use"-syntax .. or i'd turn it into something with more similar structure to haskell types ..
14:36:48 <ski> .. i.e. `char * x[];' parsing as `CVar "x" (CArr (CPtr CChar))' or something ..
14:37:11 <visq> ski: no, that doesn't work, because CChar isn't part of the declarator
14:37:35 <visq> ski: this is pure syntax. there are normalized, simplified semantic type representations too
14:37:37 <ski> `declarator' being ?
14:37:48 <mauke> ski: the pseudo-expression
14:37:52 <visq> ski: consider char* x,y**z
14:37:59 <visq> char*x,y,**z
14:38:06 <ski> (there's of course some complications with multiple variable declarations .. and initializers)
14:38:15 <ski> right
14:38:20 <mauke> {char} [*x], [y], [**z]
14:38:38 <visq> the AST is used in parsing and code generation. It has to be close to the formal syntax
14:39:02 <ski> why the latter ?
14:39:22 <visq> ski: the parser is already quite complicated
14:39:25 <ski> (if by "formal" you mean the "concrete" syntax ..)
14:39:39 <mauke> I need a deep strict apply. what library function should I use?
14:39:51 <visq> ski: yes
14:40:04 <mauke> i.e. something like f $! x that completely forces the list x
14:40:33 <mrd> how about nfdata
14:40:40 <ski> visq : ok .. if you want close to the concrete syntax, then you should just use the nested AST, imo
14:40:42 <mrd> @hoogle rnf
14:40:42 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
14:40:50 <mrd> "reduce normal form"
14:41:03 <visq> ski: there are several reasons for my choice
14:41:15 <ski> ok
14:41:18 <visq> ski: I do not want to have to object name hidden in the chain
14:41:19 <mauke> rnf x `seq` f x?
14:41:46 <visq> ski: (CPtr : CArr: []) is close to (CPtr (CArr ( Stop ))
14:42:04 <mauke> hmm, (f $| rnf) x
14:42:37 <ski> visq : i suppose .. though i don't see why not something like the latter, then
14:43:09 <visq> ski: yes, the latter would be possible.
14:43:21 <visq> ski: a matter of taste, I suppose
14:43:22 <ski> visq : but i'm not really criticising your choice .. i'm just wondering the reasons
14:44:00 <ski> yes, a matter a taste, i suppose
14:44:01 <visq> ski: In the parser, things are built up from the other side, and then reverse is applied
14:44:10 <ski> settled ? :)
14:45:05 <visq> boring issue, i know. I'm just so used to it :)
14:45:30 <ski> (i can see how that could be slightly easier to pull of, yes :)
14:51:47 <ski> dolio : hm
14:51:48 <BMeph> char **f()[]
14:51:56 <ski>   maj _|_ False True = _|_
14:51:57 <ski> ?
14:52:00 <gwern> @hoogle a -> a
14:52:01 <lambdabot> Prelude.id :: a -> a
14:52:01 <lambdabot> Data.Function.id :: a -> a
14:52:01 <lambdabot> GHC.Exts.breakpoint :: a -> a
14:52:41 <ski> well, i suppose you get that if you swap the known booleans, too ..
14:53:30 <dolio> ski: I'm not sure that matters in Epigram.
14:54:09 <ski> hm, right
14:55:34 <dolio> Although, that's what that e-mail was about I guess. Whether there's any situation where picking an arbitrary splitting tree is undesirable.
14:55:47 <dmhouse> sw17ch: ping, I'm about to disappear, let me know as soon as you get around to reading the article.
14:55:58 <sw17ch> dmhouse: will do.
14:59:11 <adamw> kow: thanks for all the help - I have it building properly now. however, i'm not sure it's working right :) i compiled the filebrowse sample app from the samples and when i run it, every bit of text shows only the first letter...
15:03:01 <adamw> ah, he left.
15:03:05 <ski> dolio : hm, would you know whether the `open' in `open terms' McBride speaks of is in the topological sense ?
15:03:25 <ddarius> ski: Uh, wouldn't it be in the lambda calculus sense...
15:05:19 <ski> hm .. i suppose it could be
15:07:51 <adamw> ooh, figured it out, was using the wrong wxgtk...
15:14:53 <b\6> can i tell parsec to match something at most n times?
15:15:25 <Philippa_> I don't think so - exactly n times, yes
15:15:32 <Philippa_> but it shouldn't take you long to write  function to do that
15:16:35 <ddarius> "<Philippa_> No, but yes!"
15:16:44 <b\6> yeah, i know count.
15:17:16 <Philippa_> alternatively you could use count and optional together and do something with the list afterwards?
15:17:53 <b\6> not sure. i read the number of bytes to read and then read that number of bytes. so i need that integer right there.
15:18:34 <jganetsk> hey, why is there no info on the net of System Fw
15:18:39 <jganetsk> can someone point me to good a resource about that
15:18:55 <ddarius> @google "System F omega"
15:18:56 <lambdabot> http://lambda-the-ultimate.org/node/1430
15:18:56 <lambdabot> Title: How do Java generics correspond to System F-(omega)? | Lambda the Ultimate
15:19:06 <Philippa_> ...not ideal
15:19:16 <Philippa_> @google "System F omega" wikipedia
15:19:18 <lambdabot> http://episteme.arstechnica.com/eve/forums/a/tpc/f/6330927813/m/4300902045?r=4300902045
15:19:18 <lambdabot> Title: The lambda-cube, Pure Type Systems, and Liam's type type - Topic Powered by eve  ...
15:19:37 <Philippa_> ...poke around wikipedia, anyway - it's got good stuff generally
15:19:59 <jganetsk> i did, it has a very brief section for Fw under the section for F
15:20:59 <Philippa_> basically, Fw's type level is the simply-typed lambda calculus, plus variables can be bound at term level ala System F
15:21:11 <ddarius> @google "System FÏ‰"
15:21:12 <lambdabot> No Result Found.
15:21:21 <ddarius> lambdabot is probably trashing that omega
15:21:30 <ddarius> Anyway, stick that intogoogle.
15:21:37 <ddarius> Or buy TAPL.
15:22:12 * ddarius is assuming TAPL talks about System FÏ‰ 
15:22:14 <jganetsk> wait, TAPL? i have it i think
15:22:27 <Philippa_> TAPL's got good material on Fw
15:22:34 <Philippa_> Fw:> is about where it stops
15:22:36 <Botje> @google "system eff omega"
15:22:37 <lambdabot> No Result Found.
15:22:41 <jganetsk> http://books.google.com/books?id=ti6zoAC9Ph8C&dq=types+and+programming+languages+ben+pierce&pg=PP1&ots=EzFhtFp2WC&sig=cesQOLLYV4S3wM5x6DPn8SnF8AM&hl=en&sa=X&oi=book_result&resnum=1&ct=result
15:22:42 <lambdabot> Title: Types and Programming Languages - Google Book Search, http://tinyurl.com/68ga8m
15:22:45 <jganetsk> that one?
15:22:55 <Philippa_> yeah
15:23:00 <jganetsk> ok, i do have it
15:23:07 <jganetsk> it talks about Fw? i thought it only talked about F
15:24:37 <Philippa_> it's dependent types it skips
15:26:30 <newsham> ?go lambda cube agustss
15:26:31 <lambdabot> No Result Found.
15:27:16 <newsham> http://augustss.blogspot.com/2007/11/some-lambda-calculus-examples-syntax-in.html
15:27:17 <lambdabot> Title: Things that amuse me, http://tinyurl.com/23uoxu
15:27:51 <newsham> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
15:27:52 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
15:28:40 <Abraxas123> > let myAdd = (+) in -1 `myAdd` 1
15:28:42 <lambdabot>  -2
15:28:56 <jganetsk> nice
15:28:58 <Abraxas123> i know how it works correctly, but what does happen here
15:29:01 <newsham> > let myAdd = (+) in (-1) `myAdd` 1
15:29:02 <lambdabot>  0
15:29:18 <newsham> > let myAdd = (+) in -(1 `myAdd` 1)
15:29:19 <lambdabot>  -2
15:30:57 <Twey> Abraxas123: `` is function-to-operator conversion
15:31:07 <Twey> () is operator-to-function conversion
15:31:10 <Twey> In a nutshell
15:31:45 <Twey> a b c is the same as b `a` c
15:31:57 <Twey> And a + b is the same as (+) a b
15:32:03 <pjdelport> () slices, `` splices
15:32:44 <seliopou> > let myAdd = (+) in negate 1 `myAdd` 1
15:32:45 <lambdabot>  0
15:33:00 <newsham> walmart.com ?
15:33:14 <Twey> Apparently
15:33:17 <Abraxas123> sorry afk
15:33:26 <Twey> Cheap mobile GPRS maybe?
15:33:28 <cnwdup_> Is it possible to have just "newtype KeyMap" in a .hs-boot file? Like with a data structure but with newtype?
15:33:33 <Abraxas123> thanks, newsham
15:33:52 <newsham> your welcome
15:33:56 <newsham> you're
15:33:57 <Abraxas123> the function name has higher precedence than - ?
15:34:22 <newsham> unary minus is designed to shock and awe
15:34:28 <Twey> Haha
15:34:51 <newsham> > (+3) 2
15:34:52 <lambdabot>  5
15:34:54 <newsham> > (-3) 2
15:34:55 <lambdabot>   add an instance declaration for (Num (t -> a))
15:35:21 <newsham> awe :(
15:35:46 <cnwdup_> > (\x -> x - 3) 2
15:35:47 <lambdabot>  -1
15:35:48 <Abraxas123> but the same with + works fine, so i guess the precedence for + has been manipulated?
15:35:48 <cnwdup_> What is prettier?
15:35:59 <newsham> > (subtract 3) 2
15:36:00 <lambdabot>  -1
15:36:06 <cnwdup_> newsham: (-:
15:36:22 <pjdelport> > ((-)2) 3
15:36:23 <lambdabot>  -1
15:36:31 <newsham> abrax:  (+3) is the function that adds 3 to an argument
15:36:38 <newsham> not the number positive-three
15:36:58 <Abraxas123> > -1 + 1
15:36:59 <lambdabot>  0
15:37:01 <Abraxas123> looks silly
15:37:06 <Abraxas123> but that's what i mean
15:37:16 <newsham> oh i see what you're asking.
15:37:16 <pjdelport> Abraxas123: it's not precedence;  "-" is a special case in Haskell syntax
15:37:20 <ddarius> newsham: 2-3 is prettier
15:37:32 <newsham> ddarius: you are in fact correct.
15:37:34 <lispy> > 1 (+1)
15:37:34 <lambdabot>        add an instance declaration for (Num ((a -> a) -> a1))
15:37:45 <lispy> > (+1) 1
15:37:46 <lambdabot>  2
15:38:03 <newsham> btw, that fold-stream article you pointed me to went in one eye and out the other :(
15:39:19 <Abraxas123> but the + is special, too, hence it works differently than a replacement like myAdd, right
15:39:37 <ddarius> There's nothing special about (+)
15:39:46 <Abraxas123> hehe
15:40:07 <newsham> I think he wants an explanation of why   -1+1 and -1 `myPlus` 1   parse differently
15:40:08 <Abraxas123> there must be some difference to myAdd or did i do sth else wrong
15:40:13 <Abraxas123> *different
15:40:22 <Abraxas123> yes
15:40:37 <ddarius> The default precedence and associativity is different from (+)'s
15:40:42 <newsham> (i would have guessed precedence but pjd said its not)
15:40:52 <Abraxas123> me too
15:41:11 <Abraxas123> + is a little special, then :p
15:41:16 <ddarius> No.
15:41:21 <Abraxas123> come on
15:41:30 <newsham> abrax: you can define infix operators and define their precedence
15:41:32 <newsham> its not built-in
15:41:35 <Abraxas123> you just don't like poor +
15:41:38 <ddarius> You can give `myPlus` whatever precedence and associativity you want.  You haven't so it has the default.
15:41:57 <Abraxas123> right, i saw that somewhere
15:42:08 <EvilTerran> it defaults to infixl 9
15:42:16 <EvilTerran> (9 is tightest-binding)
15:42:22 <EvilTerran> ... or is it infixr?
15:42:48 <lispy> isn't there a generic infix that isn't l or r?
15:42:48 <EvilTerran> ghci> let (%) = (,)
15:42:49 <EvilTerran> ghci> 1 % 2 % 3
15:42:49 <EvilTerran> ((1,2),3)
15:42:57 <EvilTerran> it defaults to infixl. that's what i thought
15:42:57 <Abraxas123> well, what i meant was that sth was done to + that i didn't do
15:43:02 <Abraxas123> i see now
15:43:05 <ddarius> It's not generic, but yes, you can declare something as just infix
15:43:18 <EvilTerran> ghci> let infixr %; (%) = (,)
15:43:19 <EvilTerran> ghci> 1 % 2 % 3
15:43:19 <EvilTerran> ((1,2),3)
15:43:26 <EvilTerran> er, what
15:43:43 <ddarius> :t (x < y < z)
15:43:45 <pjdelport> http://www.haskell.org/onlinereport/exps.html#operators
15:43:47 <lambdabot> Title: The Haskell 98 Report: Expressions
15:44:16 <EvilTerran> > let infixr %; (%) = (,) in 1 % 2 % 3
15:44:17 <lambdabot>  (1,(2,3))
15:44:17 <pjdelport> "The special form -e denotes prefix negation, the only prefix operator in Haskell, and is syntax for negate (e)."
15:44:20 <Abraxas123> btw, is it better style to write mod prefix?
15:44:22 <EvilTerran> > let (%) = (,) in 1 % 2 % 3
15:44:23 <lambdabot>  ((1,2),3)
15:44:26 <EvilTerran> Abraxas123, generally, yes
15:44:28 <ddarius> EvilTerran: Those aren't in the same binding group.
15:44:42 <Abraxas123> the `` are a pain
15:44:45 <ddarius> Or are they?
15:44:47 <EvilTerran> because mod x y means "x modulo y"
15:44:51 <EvilTerran> ddarius, i'm pretty sure they are
15:45:29 <EvilTerran> Abraxas123, if you don't get into the habit of writing it infix, you might get caught out by writing (mod x) when you mean (`mod` x)
15:46:06 <ddarius> > let infixr % 9; (%) = (,) in 1 % 2 % 3
15:46:06 <lambdabot>  Parse error at "9;" (column 14)
15:46:15 <newsham> http://codepad.org/AnqBHHVH
15:46:15 <ddarius> > let infixr 9 %; (%) = (,) in 1 % 2 % 3
15:46:16 <lambdabot>  (1,(2,3))
15:46:24 <Abraxas123> yeah the problem with the `is that it doesn't show up at the end until i hit space
15:46:53 <Abraxas123> i think i switch to prefix
15:46:54 <EvilTerran> ddarius, what i put into ghci was equivalent to "do { let { infixr %; (%) = (,) }; print (1 % 2 % 3) }"
15:49:40 <BMeph> Is anyone here familiar with "ropes," as in "an alternative to strings"? :)
15:49:43 <Abraxas123> should i move to pointfree style early on or is this sth elitist? :D
15:50:01 <lispy> BMeph: yes, vaguely
15:50:10 <Abraxas123> to be honest, i don't like the idea
15:50:14 <lispy> BMeph: often called treis or tries or something like that
15:50:34 <lispy> BMeph: SGI used to ship an implementation with the STL implementation
15:50:39 <Abraxas123> is it a hot topic in the community?
15:51:14 <lispy> BMeph: the idea is that you use balanced trees where the leaves are strings.
15:51:17 <BMeph> lispy: O RLY? I thought tries were a different animal altogether, aalthough I can see how using tries would be a good impl. model for them.
15:51:46 <cnwdup_> http://hpaste.org/9452 How do I create a valid hs-boot file from this module for the Builder module which defines the App monad? I can't solve the import cycle.
15:51:52 <lispy> BMeph: perhaps my understanding is based entirely on one implementation.  Tell me, what is your definition of a trie
15:52:30 <lispy> cnwdup_: I have always found it easier to make a 3rd module with the mutualy imported definitions
15:52:44 <lispy> cnwdup_: boot files are the devil :)
15:52:47 <BMeph> Abraxas123: Not at all. Some people just like the idea of point-free style, since it helps to focus on what's being done, versus how it does it.
15:52:53 <cnwdup_> lispy: I am quite stupid. I can just put KeyMap in the Builder module. *blush*
15:53:42 <lispy> cnwdup_: yeah, geez you idiot haskell programmer! ;)
15:53:52 <Abraxas123> well, i tried to comprehend the examples in the wikibook, but i couldn't do it
15:54:01 <cnwdup_> Hum, still import cycles. \-: But I think those are solvable.
15:54:03 <BMeph> lispy: My definition seems to match Wikipedia's, to wit: "an ordered tree data structure that is used to store an associative array where the keys are usually strings"
15:54:13 <Abraxas123> tried briefly, i should advance first
15:54:20 <lispy> cnwdup_: well, I stay away from hs-boot files at any rate
15:54:45 <lispy> BMeph: oh, then maybe my bit about tries is way off base.
15:55:03 <lispy> BMeph: but, ropes are usually stored as balanced trees of strings, iirc
15:55:19 <BMeph> Abraxas123: Yeah, it's good practice to understand what your function does, but using pF style is more a matter of taste, or problem set. :)
15:55:25 <Abraxas123> would you say more people like pointfree than not liking it?
15:55:31 <Shiruka> very simple pointless expressions are easy to understand :-)
15:55:38 <Shiruka> > (take 4 . drop 3 . sort) "sdjhqefqbaaesiurh"
15:55:39 <lambdabot>  "deef"
15:55:57 <Shiruka> "take the string <barf>, sort it, drop first 3, then take 4 and return that"
15:56:06 <Shiruka> (read from right to left)
15:56:08 <lispy> Abraxas123: pointfree really breaks down if you're passing more than one parametr through
15:56:33 <Shiruka> ... ermh, or does pointless apply to function definitions only, not application..
15:56:37 <lispy> ?pl \x y s -> take 4 (drop 3 (sort s))
15:56:37 <lambdabot> const (const (take 4 . drop 3 . sort))
15:56:38 <Abraxas123> the examples sure seemed a little complicated
15:56:47 <lispy> ?pl \x y s -> take x (drop y (sort s))
15:56:47 <lambdabot> (. ((. sort) . drop)) . (.) . take
15:56:54 <lispy> Abraxas123: like that example ^^
15:56:55 <Philippa_> Abraxas123: it's best used sparingly and with good taste
15:56:59 * Shiruka associates too freely and should sleep
15:57:03 <Abraxas123> uh easy or not?
15:57:09 <BMeph> lispy: Okay, I was just wondering how well Bytestrings follow the spec - it looks like they match, but I'm ot sure if it's deliberate or not. That's a Q best answered by dons, though, I suppose. :)
15:57:32 <damg> i think nations prefering right-to-left notation will also prefer point-free ;)
15:57:55 <ddarius> Ropes are trees of strings.  Tries are trees whose paths are labelled by characters so and whose leaves are the suffixes of the prefixes represented by the paths.
15:58:09 <Abraxas123> damg: is that all there is it it?
15:58:12 <seliopou> ?pl \y s -> drop y (sort s)
15:58:12 <lambdabot> (. sort) . drop
15:58:14 <Abraxas123> *to
15:58:27 <seliopou> o_O
15:58:59 <EvilTerran> seliopou, it makes perfect sense!
15:59:21 <EvilTerran> ((. sort) . drop) y = (. sort) (drop y) = drop y . sort
15:59:31 <EvilTerran> (drop y . sort) s = drop y (sort s)
15:59:33 <ddarius> @pl \ s y -> drop y (sort s)
15:59:33 <lambdabot> flip drop . sort
15:59:45 <BMeph> \y s -> drop y (sort s) => \y -> drop y . sort
15:59:52 <seliopou> EvilTerran, I wasn't referring to that, the last pl looked a bit too complicated
15:59:56 <seliopou> I think it can be reduced
16:00:14 <EvilTerran> what, (. ((. sort) . drop)) . (.) . take?
16:00:19 <seliopou> yeah
16:00:28 <EvilTerran> ah
16:01:58 <seliopou> actually, I take it back
16:02:06 <seliopou> I think that's as reduced as it's gonna get
16:03:00 <BMeph> \x y s -> take x (drop y (sort s)) => \x y -> take x . drop y . sort  -- did I get that right? :)
16:03:45 <phlpp_> @src curry
16:03:45 <lambdabot> curry f x y = f (x, y)
16:04:05 <seliopou> x is the first argument
16:04:17 <seliopou> BMeph: ^
16:04:42 <Abraxas123> i guess using the case command is a question of what language you started with
16:04:52 <ddarius> BMeph: Yes, that is correct.
16:05:02 <BMeph> seliopou: Yes, and s is the last argument. I'm working the applications last-to-first.
16:05:32 <seliopou> yes, of course
16:05:34 <seliopou> sorry
16:05:37 <seliopou> brain fart
16:06:00 <BMeph> seliopou: "You mean it's not just me?" :)
16:08:04 <Abraxas123> or is it better style to use case than pattern matching if your function only takes a value and returns another
16:08:31 <lispy> I pretty much always prefer pattern matching
16:08:33 <Abraxas123> i am very worried about style :p
16:08:37 <seliopou> :t ((.) . (.)) sort drop
16:08:37 <lambdabot> forall a. (Ord a) => Int -> [a] -> [a]
16:08:51 <lispy> Abraxas123: what is an example
16:09:14 <Abraxas123> http://en.wikibooks.org/wiki/Haskell/Next_steps
16:09:20 <Abraxas123> that's where i am now
16:09:45 * ddarius wonders what function Abraxas123 has that doesn't just take a value and return a value.
16:09:49 <lispy> > let f a = a + 1 in f 4 -- is this what you mean?
16:09:50 <lambdabot>  5
16:09:58 <Abraxas123> i mean, not doing anything else
16:10:08 <ddarius> There is nothing else for it to do.
16:10:09 <Abraxas123> just plotting values to other values
16:10:24 <Twey> Abraxas123: You use whatever makes your function neater
16:10:42 <Abraxas123> yeah, but does case make anything neater :D
16:10:45 <Twey> Patterns, case, do notation, if/else
16:10:50 <Twey> It can do sometimes
16:10:53 <ddarius> Abraxas123: Occassionaly.
16:10:57 <lispy> Abraxas123: can you give us an example of what you're doing?
16:11:08 <Abraxas123> yes, learning
16:11:25 <Abraxas123> the tutorial above
16:11:44 <lispy> Abraxas123: but, do you have an actual question or no?
16:12:00 <Abraxas123> i guess not
16:12:05 <lispy> It's great that you're learning haskell, but with an example I can't answer your question
16:12:11 <lispy> er without an example
16:12:22 <lispy> I don't understand what you're considering
16:12:39 <lispy> > let f a = case a of a -> a + 1 -- this seems silly compred to f a = a + 1
16:12:40 <lambdabot>  Parse error at end of input
16:12:52 <lispy> But, is that what you're constrasting?
16:12:55 <Abraxas123> i'm considering if case serves a purpose other than inidividual style
16:13:14 <lispy> Well, case is the primitive used to implement pattern matching
16:13:32 <Abraxas123> ah
16:13:45 <Abraxas123> right, i haven't looked into any of that
16:13:50 <mrd> you use "case" if you want to pattern-match without writing a new function
16:13:53 <Shiruka> gnahghg.. should've known better than to switch a somewhat complex solution I'd thought through to a simpler "more obviously correct" one I had only cursorily examined.. "why does this property fail quickcheck? *minutes of debugging later* Oh, that earlier change.."
16:14:42 <pjdelport> Abraxas123: function definitions with multiple patterns are just syntax sugar for case
16:14:52 <Abraxas123> i don't no anything about monads yet, i guess it's part of that
16:15:00 <ddarius> Abraxas123: NO
16:15:03 <ddarius> s/NO/No
16:15:04 <Abraxas123> sorry
16:15:05 <lispy> nope, not part of monads :)
16:15:07 <Abraxas123> uhoh
16:15:36 <paggas> hello people, how can i define new datatypes (data/type/newtype statements) in GHCi?
16:15:45 <ddarius> paggas: You don't.
16:15:47 <Botje> you can't
16:15:47 <newsham> :load MyDataTypes.hs
16:16:08 <BMeph> paggas: by putting them in a file and (:)load-ing it. :)
16:16:25 <lispy> or :r once it's been loaded
16:16:30 * BMeph high-fives himself!
16:17:35 <lispy> Abraxas123: in Haskell you have the "core" expressions and then you also have some more programmer friendly syntax.  case expressions are part of that core, and pattern matching in a function definition are in the programmer friendly syntax
16:18:00 <paggas> BMeph: is there no way to define new types at the prompt? :(
16:18:05 <EvilTerran> lispy, well, sometimes more friendly
16:18:13 <lispy> Abraxas123: That way, the compiler reasons about the programmer friendly syntax by knowing how to transform it into the "core" expressions
16:18:32 <Philippa_> at least, in theory. Actually GHC typechecks /first/ :-)
16:19:03 <BMeph> paggas: Not yet... ;)
16:19:13 <Abraxas123> alright, just syntactic sugar, NOT anything to do with monads, hehe
16:19:32 <lispy> Abraxas123: nope, but monads have quite a bit of syntax sugar to themselves
16:19:44 <lispy> Abraxas123: that's the do-notation you'll hear us go on about
16:19:44 <enso> heh
16:19:50 <paggas> aaah, not all hope is lost yet.... :)
16:20:00 <newsham> are case statements defined to be part of a core language, or is that a ghc implementation detail?
16:20:02 <jeffz> paggas: typically you might have emacs open with ghci in one buffer and your source file in another, where you could add or change types etc and just hit :r in ghci
16:20:06 <Abraxas123> yes, that's about all i've read about it
16:20:09 <Abraxas123> the do
16:20:35 <lispy> newsham: hmm...i thought that's what the H98 report presents, but i'm not 100% sure about it...let me check
16:21:01 <lispy> newsham: I know modern compiler design (the book) gives their simplified haskell compiler that way
16:21:38 <newsham> my intuition is that there are other ways to define a core language
16:21:44 <paggas> jeffz: well, there are times that i get lazy and just open up a ghci prompt... :P
16:21:57 <newsham> i know STG gives case special importance
16:22:03 <lispy> newsham: ah, yeah the report says that they define the syntatic convension common in FP languages by translation into a "kernel" of haskell expressions
16:22:16 <newsham> cool
16:22:23 <lispy> section 1.2
16:22:30 <jeffz> paggas: C-x 3, M-x ansi-term RET ghci foo.hs
16:23:03 <enso> you can also edit files from within ghci with :e
16:23:35 <paggas> jeffz: not an emacs fan though... :D
16:23:47 <enso> it uses $EDITOR
16:24:02 <enso> mine opens vi(m) paggas
16:24:04 <lispy> newsham: I think it's that detail that makes the Haskell report cooler than many of the other language specs I've looked at (okay, I've only looked at the one for C-99 and the common lisp hyperspec, but still)
16:24:29 <ddarius> lispy: You haven't read R5RS?
16:24:36 <lispy> ddarius: no
16:24:47 <lowki> is there any tutorial you could point me to related to compiler library design?
16:24:57 <lispy> ddarius: I was never a scheme guy
16:25:08 <newsham> scheme is lispy
16:25:12 <newsham> but lispy is not scheme
16:25:19 <lispy> see, newsham gets it :)
16:25:19 <stulli> What purpose do *.chs.pp files have? It looks like ordinary source code to me
16:25:21 <damg> does the new C standard still support such style notation? : foo(bar, baz) char bar; int *baz { .. } ?
16:25:25 <lispy> lowki: what do you want exactly?
16:25:32 <lowki> i've been making a compiler in haskell but am not sure how to make compile time libraries or anything
16:25:51 <lowki> currently all functions are hardcoded
16:26:14 <ddarius> newsham: If you are going to look at language specs, R5RS would be an obvious choice regardless of whether you were particularly Schemely.
16:26:19 <lowki> and i wanna soften them up but don't know how to modularize them or get them to load modules at compile time
16:26:24 <lispy> lowki: what do you mean functions are hardcoded?
16:26:56 <enso> all within one file?
16:27:01 <lowki> like so i have a list of functions and their translation in a case root of statement
16:27:05 <lispy> lowki: how does your compiler work right now?  What do you compile to?
16:27:16 <newsham> ddarius: i'm just playing with words.  i think lispy needs to see r5rs
16:27:18 <lowki> from rpoku to assembler or rpoku to english
16:27:23 <ddarius> lowki: Does the implemented language have no means of abstraction at all?
16:27:33 <lowki> abstraction?
16:27:45 <ddarius> Christ.  Have you read SICP?
16:27:49 <lament> abstracted from abstraction by abstraction
16:29:05 <lispy> r5rs might interest me and if I pickup helisp again, i'll probably take a look at it.
16:29:22 <lament> read SICP.
16:29:24 <lispy> I never did finish implementing tail call optimization
16:29:33 <lament> (i mean lowki)
16:30:14 <lament> designing/implementing a language before reading SICP is foolhardy at best. Best leave it to lolcoders.
16:30:23 <lispy> tail call optimization is really just a foldl' on the stack, right? ;)
16:30:43 <xor> Hi, I've declared a data type that is a tuple (ie, Data State = State (Integer, String) ) and I can't figure out how to access the stuff inside the tuple. Stuff like snd and fst don't seem to work on my values. What's going on?
16:30:55 <mauke> xor: you want pattern matching
16:30:59 <mauke> also, why are you using a tuple
16:31:03 <mauke> \ ?
16:31:11 <xor> It seemed like a good idea at the time
16:31:15 <mauke> data State = State Integer String works fine
16:31:44 <pjdelport> xor: you would have to un-State it to get at the inner tuple
16:32:02 <xor> how do I go about that?
16:32:31 <ski> do you perchance have function arguments of type `State' ?
16:32:34 <pjdelport> unState (State (x, y)) = (x, y)
16:32:43 <xor> ski, yes
16:32:51 <xor> actually, PState.
16:32:51 <pjdelport> you can use record syntax to declare such a function implicitly
16:32:58 <ski> like e.g.
16:33:04 <ski>   foo :: State -> ...
16:33:20 <ski>   foo (State (n,s)) = ..n..s..
16:33:49 <ski> xor : do you need further explanation ?
16:33:50 <xor> ski, I tried that, but got errors
16:33:58 <pjdelport> xor: you could also make State a type synonym
16:34:05 <ski> @paste
16:34:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:34:12 <pjdelport> if you don't particularly want it to be a distinct type
16:34:16 <ski> xor : maybe paste your code there ^
16:34:29 <xor> pjdelport I tried that initially but I need my values to be sortable
16:34:40 <pjdelport> tuples are sortable
16:34:46 <ski> `(Int,String)' is sortable
16:35:08 <xor> oh, so I don't need to use deriving
16:35:20 <ddarius> ...
16:35:26 <ddarius> xor is seriously confused
16:35:31 <ski> > sort [(3,"a"),(2,"c"),(5,"c"),(2,"d")]
16:35:32 <lambdabot>  [(2,"c"),(2,"d"),(3,"a"),(5,"c")]
16:36:10 <pjdelport> xor: you would, with "data State" or "newtype State"
16:36:24 <pjdelport> but "type State" doesn't introduce a new type
16:36:49 <xor> ok
16:37:47 <pjdelport> xor: http://en.wikibooks.org/wiki/Haskell/Type_declarations has a bit more on "data" versus "type"
16:37:47 <lambdabot> Title: Haskell/Type declarations - Wikibooks, collection of open-content textbooks
16:38:54 <orgthingy> cool
16:39:04 <ski> hot
16:39:22 <hml> harpy doesn't work for me on 64bit linux; is my best next option for 'dynamic code' via having haskell genertrate c code. compiling it via gcc, and then using ffi to call it?
16:39:33 <dons> that's one good way, hml.
16:39:44 <dons> hml, you can use Language.C to generate the  C code nicely
16:39:47 <hml> i'm generating numerical code; any other ideas?
16:40:00 <dons> that's the apporach i took for some numerical simulation problems
16:40:02 * hml looks at Language.C
16:40:03 * BMeph wonders if anyone else thinks "sick-up" when seeing SICP
16:40:06 <dons> generate C , link it and call via the FFI.
16:40:14 <hml> any good module for generating gpu code ?:-)
16:40:26 <dons> not yet. but CUDA looks like C, right?
16:40:35 <dons> conal worked on this.
16:40:41 <dons> he might have gpu generation code available, actually
16:40:46 <Philonous> Do I get it right, that a monad is basicly just some data type and a definition what function application is to mean on that type?
16:40:53 <hml> godo point; once i generate other code and get ffi working, c and cuda do not differ by much
16:41:15 <ski> (BMeph : i might have interpreted that as `sick-P' some time)
16:41:22 <pjdelport> Philonous: to a good approximation, yes
16:41:29 <hackage> Uploaded to hackage: applicative-extras 0.1.3
16:41:58 * ski takes for granted BMeph knows the `P'-convention
16:42:02 <lispy> But, GPU optimization will differ quite a lot from typical C optmization, right?
16:42:24 <pjdelport> Philonous: you've pretty much described applicative functors, which are very close to monads
16:42:42 <lispy> sick-p sounds like something you'd say to a doctor
16:42:44 <hml> dons: I can't find Langauge.C on hasckage.haskell.org
16:42:49 <hml> should i be searching for something else
16:42:54 <augustss> ski: looks like a Djinn bug
16:43:00 <dons> hml, its a SoC project that's not had a formal release yet.
16:43:06 <dons> but you can find it on google.
16:43:09 <ski> augustss : ok
16:43:40 <ski> augustss : could you refresh us on how higher-ranked types are (not) handled, btw ?
16:43:42 <Philippa_> pjdelport: actually it's valid for monads too, it's just that monads allow higher-order application
16:44:15 <BMeph> lispy: Wouldn't that be what the doctor asks you, though? ;)
16:44:23 <pjdelport> Philippa_: right, thanks
16:44:33 <ski> (dolio ^)
16:44:34 <Philonous> Philippa_: Would you mind to elaborate a bit?
16:44:51 <lispy> BMeph: maybe I have a bad doctor...
16:45:33 <Philippa_> Philonous: monads have join (and >>= is definable in terms of it), applicatives don't, basically
16:45:48 <Philippa_> @type join
16:45:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:46:14 <Philonous> Oh ok
16:46:15 <mmorrow> hml: http://code.haskell.org/language-c
16:46:16 <lambdabot> Title: Index of /language-c
16:46:20 <BMeph> pjdelport: So, do you disagree with the "Oblivious" paper's conclusion? :)
16:46:22 <Philippa_> "run outer layer of computation to get the inner layer". To put it another way "make result of computation usable as computation"
16:46:34 <pjdelport> BMeph: ?
16:46:35 <Philonous> Though I'm not sure what the implications of that are exactly. But I'll find out.
16:46:44 <BMeph> @where oblivious
16:46:44 <lambdabot> I know nothing about oblivious.
16:47:20 <pjdelport> :t fmap
16:47:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:47:22 <Axman6> how ironic
16:47:24 <mmorrow> hml> harpy doesn't work for me on 64bit linux; is my best next option for 'dynamic code' via having haskell genertrate c code. compiling it via gcc, and then using ffi to call it?
16:47:25 <pjdelport> :t (=<<)
16:47:25 <Axman6> (almost)
16:47:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:47:33 <mirakel> is there anything to learn from comparing Functor and Monad?  monads are generalized functors, right?
16:47:46 <dibblego> mirakel, Monads are *specialised* Functors
16:47:52 <pjdelport> Philonous: note the extra m b in the second signature
16:47:53 <Philippa_> mirakel: no, they're a massive specialisation of them
16:47:54 <Philonous> Philippa_: "computation" meaning monad?
16:47:57 <EvilTerran> Philonous, it makes it possible to do things like branch on the result of part of a computation within the same computation
16:48:21 <dibblego> mirakel, there is something to learn in comparing them, which is their relationship (e.g. derive fmap from >>= and return)
16:48:27 <Philippa_> Philonous: computation meaning 'value of monadic type'. The type constructor m is a monad, a value of type m a is a computation
16:48:39 <gwern> hey, are we allowed cabal entries like 'cabal-version: ==1.4.0.1'?
16:48:39 <Twey> (yielding type a)
16:48:49 <mmorrow> hml: if you can somehow get it down to machine code yourself (possibly a large assumption, but maybe not), then you can turn a [Word8] into a FunPtr and call that
16:48:52 <lispy> dibblego: I did that once on accident :)
16:48:58 <ski> (Philonous : aka `action')
16:49:18 <mmorrow> hml: http://code.haskell.org/~morrow/code/haskell/misc/Call.hs
16:49:22 <Philippa_> ski: normally only for IO and derivatives, though
16:49:46 <ski> Philippa_ : well, i happily use it for any monad :)
16:49:55 <xor> Thanks for your help, I shouldn't have been using the data declaration.
16:50:14 <pjdelport> mirakel: comparing them is how i understood them
16:50:16 <mmorrow> hml: that code is an extension of some code of mauke's, where i got the idea from
16:50:28 <ski> (i'm not so sure of the origin .. mayhaps it only used it for `IO'-like monads ..)
16:50:31 <dibblego> @type fromInt
16:50:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
16:50:35 <pjdelport> mirakel: in terms of specialization, Monad < Applicative < Functor
16:50:47 <gwern> @hoogle fromInt
16:50:47 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
16:50:47 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
16:50:50 <mmorrow> hml: (by "idea", i mean the method by which to do that in *haskell*)
16:50:54 <Philonous> Ah, so basicly a monad "works" on functions, that themselfes return values of the monaid type, wheres a applicative functor just "lifts functions which work in the underlying type
16:50:58 <Philippa_> ski: there're monads it's less appropriate for. Obvious examples: identity, the const monads... but also list, for example
16:51:28 <ski> (Philippa_ : i think i've used "list action" here many times ..)
16:52:19 <pjdelport> Philonous: yes
16:52:32 <Philippa_> ski: it's not a formally defined thing. List action makes me itch though
16:52:46 <ski> ok, ymmv
16:52:54 <Philippa_> it's no more actiony than the identity case, IYSWIM
16:53:17 <ski> (idnswym, but nvm)
16:54:19 <Philippa_> ski: it's identity, only non-deterministic. It doesn't "do things". I can see it for the state family, perhaps error-style monads...
16:54:45 <ski> .. hm, iswim syntax was inspiration for haskell's, yes ?
16:55:04 <ddarius> iswim syntax was an inspiration for all statically type functional languages
16:55:11 <ski> Philippa_ : environment ? output ? continuation ?
16:55:13 <Philonous> Does that mean every functor induces a monad, since I can just 'return' the underlying type to the monadic type after i'm done applying the function?
16:55:40 <ddarius> Philonous: No.  That's why monads are specializations of functors.
16:55:42 <dibblego> Philonous, other way around
16:55:57 <Philippa_> ski: are all implementation artefacts
16:56:02 <dibblego> Philonous, take >>= and return and try to derive a function with this signature: m a -> (a -> b) -> m b
16:56:05 <pjdelport> Philonous: every monad is also a functor, but you get functors which are not monads
16:56:14 <Philippa_> also, they all apply to identity :-)
16:56:33 <Philippa_> or do you mean as in Reader, Writer, Cont?
16:56:48 <ski> Philippa_ : let me clarif.. yes, those
16:56:48 <Philippa_> (the first two I meant to include within "the state family")
16:57:05 * ddarius would not count Reader
16:57:16 <Philippa_> I'd still avoid it, because in those cases we really want to highlight the pure aspect
16:57:19 * ski would not count Writer
16:57:39 <ski> what is "the pure aspect" ?
16:57:39 <Philippa_> Cont depends on what mood I'm in :-)
16:57:44 <ski> (:
16:57:46 * ddarius only uses "action" for IO or occasionally for an arbitrary monad.
16:57:50 <Philippa_> they're still pure functions
16:58:19 <ski> and `IO'-actions would not be pure ?
16:58:20 <Philippa_> ddarius: I don't use it for an arbitrary monad unless I'm talking arbitrary computational monad and looking at it as an abstract machine or something
16:58:32 <Philonous> Oh ok, I see what my mistake is -.-. Obviously it's the other way around for the reason I mentioned ...
16:58:52 <Philippa_> ski: reader and writer have pure denotation. IO doesn't for sufficiently interesting values of 'pure'
16:58:54 <ddarius> I tend to use it that way for consistency with previous conversation or something.  I don't go out of my way to use it that way.
16:59:22 <ski> Philippa_ : ok .. i'm not sure about that .. but it could be
16:59:32 <Philippa_> (by the time you've rendered IO pure, the dumber physics students've stopped whining about quantum mechanics ;-)
16:59:46 <EvilTerran> i call monadic values "actions" in general - i figure it's no worse than borrowing the word "data" and giving it a slightly different meaning
16:59:53 <EvilTerran> or indeed "class" and "instance"
17:00:19 <Philippa_> er. Those three examples are /all/ valid uses
17:00:48 <Philippa_> note that OO didn't invent either class /or/ instance, and that data doesn't imply mutability...
17:00:51 <Philonous> Ok, thanks a lot. That really cleared my mind
17:01:03 <Philippa_> (okay, the specialised sense in which we also have codata is somewhat weirder)
17:01:08 <ski> Philippa_ : hm, would you say `amb' in scheme is pure ?
17:01:16 <Philippa_> ski: not familiar with it
17:01:29 <ddarius> Philippa_: amb x y nondeterministically returns x and y
17:01:30 <Philippa_> is it one of the parallel evaluation-type constructs?
17:01:34 <pjdelport> Philonous: one nice way to think of monads is <=<
17:01:40 <pjdelport> :t (<=<)
17:01:40 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:01:43 <ddarius> It's like do a <- [x,y]
17:01:43 <EvilTerran> i could give you some better examples from outside haskell, if you want. i just mean there's an established history of maths borrowing words from mainstream english and giving them subtly different meaningsw
17:01:45 <damg> is there a built-in way to notate numbers in binary (similar to 0x... for hex) ?
17:01:45 <pjdelport> :t (.)
17:01:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:01:49 <Philippa_> ah. Pure given an oracle or a pure means of reflection...
17:01:54 <EvilTerran> and i say haskell counts as maths :)
17:02:00 <pjdelport> err
17:02:06 <ski> Philippa_ : `(* (amb 2 3) (amb 4 5))' is the same as `(amb 8 10 12 15)'
17:02:08 <pjdelport> (.) :: (b -> c) -> (a -> b) -> a -> c
17:02:28 <EvilTerran> ski, ah, it's the list monad
17:02:30 <mauke> > 0b1
17:02:31 <lambdabot>   Not in scope: `b1'
17:02:33 <damg> damn, crashed ...
17:02:45 <ski> EvilTerran : yes, but reflected into a side-effect ! :)
17:02:54 <EvilTerran> except weird and kinda implicit, yeah
17:03:15 <ski> EvilTerran : just like state in imperative languages in general, yes
17:03:21 <Philippa_> EvilTerran: I still value keeping action for things we don't want to think of as pure
17:03:23 <pjdelport> Philonous: so (<=<) composes two monadic functions
17:03:29 <Philonous> pjdelport: Does <=< happen to be named bind2 in other languages?
17:03:35 <lispy> If ghc says, "Could not deduce (Foo a, Bar a) from context Baz a" but I have instance Baz a => Bar a, does that mean I need to add instance Baz a => Foo a, or is it not even finding the instance I have?
17:03:39 <pjdelport> no idea
17:03:42 <EvilTerran> Philippa_, i tend to use "side-effect" for that
17:03:44 <EvilTerran> but, sure
17:03:50 * ski thinks `pure' vs. `impure' is "just" a difference of view-point
17:03:54 <Philippa_> but then I'm one of those people who ruthlessly exploits pure-on-the-outside monads
17:04:16 <EvilTerran> as long as everyone defines their terminology before they start, it doesn't matter what words we use for what, anyway :)
17:04:22 <Philippa_> ski: I don't see a World datatype I can reason with, therefore I cannot reason purely about IO...
17:04:26 <pjdelport> Philonous: but (<=<) demonstrates the essence of monads versus (applicative) functors:
17:04:34 <ski> Philippa_ : granted
17:04:41 <Twey> Philippa_: There is a RealWorld, actually, I think...
17:04:49 <Philippa_> EvilTerran: a side-effect is something that impure code may have. The impure code isn't a side-effect :-)
17:04:51 <lispy> Instances don't need to exported and imported right?
17:05:05 <Philippa_> Twey: It's a stub/kludge though
17:05:08 <EvilTerran> Philippa_, well, i guess. never mind.
17:05:17 <Twey> Well, yes
17:05:21 <Philippa_> btw, gotta go tie this machine to a socket
17:05:25 <sw17ch_> I have a n00b question... I want something hidden away in a monad... in this case it has an "initialize" and a "terminate" option between which everything needs to happen and nothing of that type of operation may happen outside
17:05:29 <Twey> But it works like it were real.
17:05:41 <ski> (EvilTerran : "side-effecting" ?)
17:05:58 <sw17ch_> can monads do that without having to explicitly calling the "initialize" and "terminate" in the final library
17:05:58 <sw17ch_> ?
17:06:01 <pjdelport> Philonous: even though both a and b are wrapped in a "layer" of m, the result is just (m c) instead of (m (m c))
17:06:08 * ski ponders .. "side-affecting"
17:06:11 * sw17ch_ apologizes for his grammar 
17:06:51 <pjdelport> if you just had a functor instead of a monad, the result type would have to be (m (m c))
17:06:52 <EvilTerran> sw17ch_, the general notation would be something like "withMyLibrary $ \{- any relevant data from the library -} -> {- code using the library -}"
17:07:06 <pjdelport> or (f (f c)), as the case may be
17:07:10 <EvilTerran> where withMyLibrary :: ... -> IO () or what-have-you
17:07:20 <Philonous> pjdelport: I somewhat always took it for granted that monads would "do the right thing" when composing functions which return values of the monadic type. It happens that thanks to join they actually do
17:07:28 <pjdelport> right
17:07:51 <sw17ch_> EvilTerran, alright, i was thinking that
17:07:52 <sw17ch_> thanks
17:08:00 <pjdelport> composing them together to get a result of (m (m c)), and then joining that, is effectively what <=< does
17:08:29 <pjdelport> so you could think of monads as "flattenable" functors
17:08:46 <Cale> + return :)
17:08:57 <EvilTerran> flattenable pointed functors!
17:09:02 <pjdelport> "flattening" applicative functors, i meant to apply :)
17:09:12 <pjdelport> s/flattening/flattenable/
17:09:18 <pjdelport> s/apply/imply/
17:09:19 <pjdelport> sheesh
17:09:22 <sm> a question, perhaps for dons: darcs-graph uses uniq and ignore, and works, but when I load it in ghci those two aren't in scope. Where should they come from ?
17:09:36 <lispy> I have "instance Baz a => Foo a" and when I try to define "instance Baz a => Bar a" ghc says it's a duplicate, but then it also complains that it cannot debuce (Foo a, Bar a) from context (Baz a), any ideas?
17:09:52 <pjdelport> so for the list monad, flattening means concatenating, for IO, flattening means sequencing, and so on
17:09:58 <lispy> sm: check ?hoogle
17:10:29 <sm> hoogle finds neither, but hayoo shows a uniq in eg MissingH (and no ignore fn)
17:10:42 <sm> it compiles though
17:10:48 * sm <- confused
17:11:02 <dibblego> do sm <- confused
17:11:03 <pjdelport> for Reader / (r ->), flattening means passing the environment to both functions
17:11:43 <enso> either is valid ;}
17:12:53 <ski> `Either e' is a monad
17:13:51 <Philonous> So a functor is a notion of what function application should mean on some type and a monad is a functor with type magic to keep the result clean.
17:14:15 <ski> that's one way to put it, yes
17:15:48 <pjdelport> well, you could say that at the type level, an applicative functor lets you introduce and preserve levels of magic
17:16:05 <pjdelport> while a monad additionally lets you reduce the level of magic too
17:16:10 <ski> the functor part tells how to perform functions "under the `f'", while the monad parts tells how to infect a value with an outer `f' and how to merge two infections
17:16:14 <gwern> if fromList is O(n*log n), and toList is O(n), is 'toList . fromList' == 'O(n*log n) + O(n)' or 'O(n^2 * log n)'?
17:16:20 <enso> question: is there a way make LB/ghci translate from a specific monad instance into a generic monad; i.e Reader -> Monad ((->) a)
17:16:33 <pjdelport> :t pure
17:16:34 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:16:40 <pjdelport> :t fmap
17:16:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:16:45 <pjdelport> :t join
17:16:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:16:58 <EvilTerran> enso, @unmtl
17:17:07 <ski> @unmtl Reader e a
17:17:07 <lambdabot> e -> a
17:17:16 <EvilTerran> @unmtl StateT s (ReaderT r IO) a
17:17:16 <lambdabot> s -> r -> IO (a, s)
17:17:22 <pjdelport> pure introduces an f, fmap preserves an f, join takes an m away
17:17:24 * Philippa_ returns
17:17:28 <enso> ah...thanks!
17:17:40 <ski> @unmtl ContT (Either e o) (StateT s (Reader e)) a
17:17:40 <lambdabot> (a -> s -> e -> (Either e o, s)) -> s -> e -> (Either e o, s)
17:17:43 <EvilTerran> enso, bear in mind that you have to give it a complete type
17:17:49 <enso> right
17:17:51 <EvilTerran> otherwise you'll get inscrutible error messages
17:17:54 <EvilTerran> @unmtl State
17:17:54 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
17:18:01 <enso> isn't there a way to tell LB to make it generic?
17:18:03 <EvilTerran> er, well, that kinda works
17:18:14 <Philippa_> Twey: the RealWorld in GHC's just used to make a few things play along nicely without any (other) special-case hacks. It's not a World value in the sense of world-passing semantics, so it doesn't "work like one"
17:18:15 <ski> enso : meaning ?
17:18:18 <EvilTerran> enso, how generic?
17:18:24 <EvilTerran> i mean, generic how?
17:18:26 <enso> @unmtl Reader a b :: Expr
17:18:26 <lambdabot> err: Parse error
17:18:45 <enso> lambdabot: (a -> b)
17:18:45 <ski> pjdelport : i'd prefer saying `join' merges two `m's ..
17:18:53 <pjdelport> right
17:18:57 <EvilTerran> enso, you can't have a type on the left of a ::
17:19:01 <EvilTerran> unless you have a kind on the right
17:19:15 <EvilTerran> and @unmtl probably won't accept that anyway, because it just wants a type
17:19:20 <pjdelport> i just meant at the type level
17:19:22 <EvilTerran> and so the kind must always be *
17:19:45 <Philippa_> pjdelport: "merges" preserves the fact it's not also a "run" function
17:19:45 <enso> ok
17:19:55 <EvilTerran> enso, so what do you mean by "generic"?
17:19:58 <Philippa_> comonads have an operation (coreturn) that can do that
17:20:13 <EvilTerran> enso, it replaces the explicit monad constructors with the non-monadic form
17:20:17 <enso> right
17:20:19 <enso> I gotcha
17:20:33 <enso> I meant not having to provide specific types like Int
17:20:34 <EvilTerran> and you can give it variables in any parameters you don't want to specify (sa you can seE)
17:20:41 <pjdelport> Philonous: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
17:20:42 <lambdabot> Title: Control.Applicative, http://tinyurl.com/yrwujr
17:20:43 <EvilTerran> @unmtl Reader e a
17:20:44 <lambdabot> e -> a
17:20:48 <enso> oh...
17:20:50 <ski> @unmtl a
17:20:50 <lambdabot> a
17:20:51 <enso> hah
17:20:55 <enso> duh...
17:20:55 <pjdelport> that's the "applicative functors" we refer to
17:21:03 <Twey> Philippa_: Ah :-\
17:21:12 * heatsink wonders if it'll ever understand what "co" means.
17:21:33 <ski> just reverse the arrows !
17:21:45 <pjdelport> coheatsink <-> coolsource
17:21:46 <EvilTerran> coprogrammers turn programs into coffee
17:21:56 <ski> that's what `co' means ..
17:22:17 <pjdelport> EvilTerran: ffee, you mean
17:22:22 * ski wonders whether `cobordism' is the dual of `bordism' .. Cale, do you know ?
17:22:25 <EvilTerran> er, i guess
17:22:31 <heatsink> Haskell has taken me a long way in understanding abstract algebra, but I'm still moving slowly on categories.
17:22:44 * Philippa_ wonders what cobullshit smells like ;-)
17:22:49 <EvilTerran> ah, categories are easy. there's practically nothing there :P
17:23:00 * wjt wonders what a list mprehension is
17:23:26 <Philippa_> wjt: a specialisation of a comonad mprehension, duh
17:23:33 <ski> wjt : probably you mean some device for taking apart colists ?
17:23:34 <wjt> Philippa_: :H
17:23:37 <wjt> erm, :D
17:24:05 <Cale> ski: hmm, I think the 'co' is in another sense here
17:24:29 <ski> CoList a = nu r. 0 * (a + r)
17:24:36 <ski> Cale : ok ?
17:24:36 <Cale> ski: Two manifolds are cobordant if they jointly bound a manifold, so co + bordant
17:24:43 <ski> ah
17:26:08 <ski> (roughly similar meaning as `co' in `covariance', statistics)
17:26:20 <Cale> yeah, or cooperation, say :)
17:26:52 <ski> hm .. maybe `de(con)structors' should be called `nstructors' ?
17:27:58 <ski> (though i think i've seen someone suggesting `structors' for both .. or maybe a generalization .. possibly this was in some strange logic)
17:28:27 <pjdelport> hmm, anastructor and katastructor
17:28:48 <ski> hm
17:28:59 <ski> (anaconstructor ?)
17:29:26 <dolio> What do ana and kata mean again?
17:29:34 <ddarius> upward and downward
17:29:34 <pjdelport> your anaconda ate my cataconda
17:29:37 <ski> `down' and `up' iirc
17:29:48 <ski> (: pjdelport
17:29:48 <dolio> Ah.
17:30:04 * ski >={<-<}=> bed
17:30:13 <sm> ACK! they were hiding in a where, way down the file
17:30:16 <pjdelport> dolio: think "anabolic" and "catastrophe"
17:30:50 <dolio> Heh.
17:31:02 <ddarius> And you can think of apostrophe for apo!
17:31:15 <pjdelport> what's apo again?
17:31:16 <EvilTerran> ... what does apo mean?
17:31:26 <atp> the dual of ana iirc
17:31:27 <ski> (how about `zygo', then ?)
17:31:30 <ddarius> outward (or inward, but I think it is outward)
17:31:38 <ddarius> atp: cata is the dual to ana
17:31:42 <ddarius> apo is the dual to para
17:31:46 <atp> oh right
17:31:46 <paggas> are guards faster that if/then/elses? (by guards i mean things like f x | cond1 x = ... | cond2 x = ...)
17:31:51 <EvilTerran> paggas, no
17:32:00 <ddarius> I think strophe is something like "step"
17:32:09 <EvilTerran> use whichever one looks better for your particular situation
17:32:11 <dolio> They're all desugared to case.
17:32:22 <EvilTerran> at least if you compile with optimisations, they'll end up exactly the same
17:32:27 <EvilTerran> and probably otherwise, too
17:32:59 <pjdelport> ddarius: so the journey of a thousand miles begins with a single apostrophe?
17:34:15 <gwern> pjdelport: the thread of a thousand flames certainly does
17:34:28 <pjdelport> haha
17:35:49 <dolio> @remember supernov (in #oasis) can u download oasis music here?
17:35:50 <lambdabot> Nice!
17:36:45 <Philonous> Can't you? :>
17:37:06 <lispy> dolio: you told him there is only IO (Oasis Music), in #oasis right?
17:37:35 <lispy> to which he would probably ask, but how do I get it out of the IO monad?
17:37:49 <lispy> unsafePerformRIAAViolation
17:38:07 <dolio> He said that some time yesterday, so no.
17:38:17 <dolio> #oasis is pretty low-traffic.
17:38:30 <gwern> wow. I'm benchmarking different implementations of 'uniq', and while the Data.Set version has bad big-O, itt kicks tthe list version's ass
17:38:35 <pjdelport> unsafeInfringeCopyright
17:38:43 <erikc> the Pirate monad is an insecurity kernel
17:39:01 <gwern> constants truly matter!
17:39:22 <dolio> What's the list version do? map head . group . sort?
17:39:48 <gwern> yeah
17:40:25 <gwern> I'm going to try the worker//wrapper version next
17:40:38 <dolio> Isn't that the same big-O as toList . fromList?
17:40:38 <lispy> This is driving me nuts
17:40:39 <lispy>     Could not deduce (Conflict (PatchInfoAnd p),
17:40:39 <lispy>                       Patchy (PatchInfoAnd p))
17:40:39 <lispy>       from the context (RepoPatch p)
17:41:08 <gwern> dolio: I don't think so, but I'm not sure
17:41:11 <gwern> I asked earlier
17:41:31 <dolio> fromList should be O(n lg n), I think.
17:41:36 <dolio> And toList should be O(n).
17:41:36 <lispy> Looking at my instances, RepoPatch p, seems to imply both Conflict p and Patchy p.  And Conflict p implies Conflict (PatchInfoAnd p) and likewise for Patchy p
17:42:04 <dolio> Or O(k) where k is the number of unique elements.
17:42:07 <lispy> So, shouldn't RepoPatch p, be enough to deduce those it?
17:42:21 <gwern> @hoogle member
17:42:21 <lambdabot> Data.Set.member :: Ord a => a -> Set a -> Bool
17:42:21 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
17:42:21 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
17:42:24 <dolio> And I guess fromList is O(n lg k).
17:43:25 <dolio> Whereas sort is strictly O(n lg n), group is O(n) and map head is O(k).
17:44:59 <dolio> Which looks like Set could have better big-O when there are significant numbers of duplicates.
17:45:23 <dolio> Unless we ignore log factors. :)
17:47:54 <hml> what is the intuition behind : type State st a = st -> (st, a)
17:48:08 <hml> so this is a function that takes  state, and returns a tuple?
17:48:28 <Twey> hml: It returns a value, and a new state.
17:48:49 <hml> so it jmaintains some state of type 'st' and returns a value of type 'a'; hmm
17:48:50 <Twey> Yes.  In a pair (two-tuple).
17:49:12 <hml> is: returnState a = \st -> (st, a) ... similar to the regular return?
17:49:12 <ddarius> hml: Write a function that takes a binary tree and labels each of the leafs with consecutive numbers (in the in-order traversal of the tree)
17:49:23 <hml> ddarius: lol; this is the example i'm readinb about right now
17:49:44 <ddarius> hml: Just write the function from that specification.
17:49:49 <ddarius> However you like.
17:50:16 <hml> do interior nodes hold values too, or only brancyhes?
17:50:28 <ddarius> Either way you prefer.
17:57:25 <BMeph> Dang, I Hate missing conversations where I know something... :)
17:57:48 <ddarius> BMeph: The solution is to not know anything.
17:58:45 <BMeph> ddarius: I've tried, but I always wind up knowing something. At least, I /thinK/ i KNOW SOMETHING... ;P
17:59:39 <ddarius> You might need to reevaluate your knowledge of where the capslock key is.
17:59:40 <BMeph> Hm, I'm sure going to be busy somedday...at least, if I actually have to do all of those things I've promised... ;)
17:59:48 <newsham> you can never know you know nothing
17:59:55 <ddarius> BMeph: Make sure you die before then.
18:00:05 <BMeph> newsham: How sure are you of that? ;)
18:08:51 <lispy> omg, I finally fixed this deduce context mess
18:09:12 <ddarius> lispy: Did it turn out the compiler was right?
18:09:25 <lispy> ddarius: I'm not sure.
18:09:41 <lispy> I had the phantom types in my instances
18:09:50 <lispy> When, I removed those, ghc stopped complaining
18:11:43 <lispy> instance RepoPatch (p x y) => RepoPatch (PatchInfoAnd (p x y)) -- this causes the problem
18:11:46 <lispy> So, change it to:
18:12:03 <lispy> instance RepoPatch p => RepoPatch (PatchInfoAnd p), I don't know why this fixes it
18:13:53 <lispy> ddarius: do you know why that changes things?
18:14:16 <ddarius> Vaguely.
18:15:10 <lispy> My solution was very low tech but also time consuming.  I just kept trying things.
18:15:28 <lispy> I should probably ask on Haskell-Cafe what it's all about
18:15:42 <ddarius> Just search Haskell-Cafe.  I'm sure it's been discussed before.
18:15:49 <ddarius> And/or the GHC mailing list.
18:33:04 <Philonous> Btw. monads are sometimes compared to space suits or nuclear waste containes - you put stuff in but hopefully it never leaks out. But since monads are just data types, can't I pattern match them and thus extract the data?
18:33:39 <enso> yes. but outside the particular function it's trapped again
18:33:46 <ddarius> @quote a.monad.is.like
18:33:46 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
18:34:02 <ddarius> @quote monads.are.like
18:34:02 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
18:34:11 <ddarius> Not what I was going for.
18:34:35 <ddarius> @quote spacesuit
18:34:35 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
18:34:37 <thoughtpolice> Philonous: if the data constructors aren't exported (which IO isn't,) no
18:34:39 <ddarius> @quote space.suit
18:34:39 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:34:49 * ddarius gives up.
18:35:07 <Botje> @quote apples
18:35:07 <lambdabot> No quotes match. You speak an infinite deal of nothing
18:35:10 <Botje> yup
18:35:13 <Botje> \bot sure is forgetful
18:35:42 <mjrosenb> doesn't it forget every time it gets restarted?
18:35:55 <gwern> wow. toList . fromList takes 25seconds, but http://blog.unsafeperformio.com/?p=15 takes 3 seconds. an impressive difference
18:35:55 <lambdabot> Title: 13 Functional Thinking 37 Â» Deriving an Efficient nub Using Worker/Wrapper 47
18:35:56 <Philonous> Ok, so sometimes I want to be able to extract the data again, then I export the constructors (a maybe monad wouln't be of much use when I couln't take actions if the computation fails)
18:36:35 <gwern> no wait, that's map head
18:36:46 <enso> Nothing >>= _ = Nothing
18:36:47 <gwern> toList .fromList takes ,8 seconds, nm
18:37:56 <ddarius> Putting "a monad is like" (with quotes) into Google is hilarious.
18:38:02 <thoughtpolice> Philonous: if you export the data constructors of your monad you are compromising the 'security' the monad provides - in the case of IO, you'd basically be able to put arbitrary side effects in any 'pure' expression (like what unsafePerformIO does) since you could just have makePure (IO a) = a (roughly speaking)
18:38:17 <gwern> I is unhappy. toList . fromList is the fastest version, so I've wasted all my work :(
18:39:16 <Philonous> IO is obviously one of the examples where I hardly ever want to touch the stuff behind the monad. But sometimes I want to - for example - retrieve the nth element of a list.
18:39:17 <enso> "a monad is like a soul or atom"
18:39:27 <thoughtpolice> "a monad is like a macro," "a monad is like a loop," "a monad is like a soul or atom," "a monad is like a design pattern"
18:39:37 <ddarius> "<lispy> a monad is like a butterfly"
18:39:51 <lispy> when did I say that?
18:40:03 <ddarius> In 2006
18:40:25 <enso> on a tuesday?
18:40:26 <sm> Configuring MissingH-1.0.2.0... tells me hslogger -any is missing. hslogger is installed
18:40:27 <thoughtpolice> "so a monad is like a gonad but... mo?"
18:40:47 <thoughtpolice> sm: if it's in your user package configuration you will have to pass --user to configure
18:40:55 <lispy> ddarius: lol, I see the context now, I just sort of kept going
18:41:02 <thoughtpolice> (because otherwise user packages are hidden by default)
18:41:13 <bogner> wow, the very last hit i get on google is "A monad is like a monad. And nothing else."
18:41:15 <sm> that's important.. thanks for the tip
18:41:32 <enso> "monads are like a programmable semi-colon?!?"
18:42:27 <enso> huh?
18:42:42 <TSC> That's in reference to do-blocks, sort of
18:42:46 <sm> next, it says Not in scope: type constructor or class `QC.Config'. I have QC 2.1 installed as well as 1.x, but hidden
18:42:55 <Philonous> Ok, thanks
18:43:05 <enso> yeah, I kinda get that...but not really
18:43:19 <erikc> programmable semicolon is how i think of them
18:43:29 <enso> do-tell
18:43:39 <paczesiowa> is there rfc822-compliant printer for dates somewhere in Data.Time ?
18:45:36 <erikc> its a programmable way of chaining the result of one computation into the input of another
18:45:50 <sm> looks like configure used QC 2.1 even though hidden.. deinstalling it and re-configuring fixed it
18:46:14 <dino-> paczesiowa: I think you can do that with formatTime defaultTimeLocale "%c"
18:46:28 <koninkje> /sc/sc
18:46:31 <koninkje> bah!
18:46:43 <dino-> formatTime is Data.Time.Format
18:46:45 <enso> fair enough
18:46:58 <paczesiowa> dino-: thanks, I'll try that
18:47:15 <dino-> paczesiowa: You may need a different locale (like UTC), but the basic idea..
18:49:30 <thoughtpolice> mjrosenb: you can pass a configure flag to hide a particular package as well
18:49:34 <thoughtpolice> er
18:49:35 <thoughtpolice> sm
18:49:40 <dino-> paczesiowa: And that defaultTimeLocale is from System.Locale
18:49:52 <thoughtpolice> sm: something like 'configure --hide-package=QuickCheck-2.1.0.0'
18:50:04 <paczesiowa> dino-: there's rfc822DateFormat in System.Locale
18:50:45 <dino-> paczesiowa: :/  Or you can do it the stupid way like I suggested.
18:50:46 <sm> thoughtpolice: thanks. I thought ghc-pkg hide would be enough
18:50:56 <dino-> Can't believe I didn't see that while in there *getting defaultTimeLocale*
18:51:18 <dino-> <- silly
18:51:57 <dino-> But that other function, handy for other custom formatting. It was strftime-like % format strings
18:52:24 <dino-> s/was/has/
18:56:41 <paczesiowa> I have a stupid question - what time is it (UTC) ?
18:56:51 <lispy> ?go localtime UTC
18:56:52 <lambdabot> http://www.dxing.com/utcgmt.htm
18:56:52 <lambdabot> Title: UTC GMT Conversion
18:57:03 <Zao> 1:57, I'd say.
18:57:04 <lispy> darn, if you actually google that it just tells you
19:10:40 <paczesiowa> formatting time is done through [g]libc?
19:12:32 <stepcut> paczesiowa: no
19:16:20 <paczesiowa> > rfc822DateFormat
19:16:21 <lambdabot>   Not in scope: `rfc822DateFormat'
19:17:42 <paczesiowa> rfc822DateFormat == "%a, %_d %b %Y %H:%M: %Z" why is there that '_'? it breaks numbering days I think
19:18:55 <b\6> paczesiowa: think i remember. it's for space padding or something instead of 0 padding.
19:19:44 <b\6> paczesiowa: (underscore) Pad a numeric result string with spaces.  from man strftime
19:19:44 <paczesiowa> > getCurrentTime >>= putStrLn . formatTime defaultTimeLocale rfc822DateFormat
19:19:45 <lambdabot>   Not in scope: `rfc822DateFormat'
19:20:04 <paczesiowa> I get: Fri, d Aug 2008 02:20:58 UTC
19:20:27 <mauke> apparently your strftime doesn't like %_
19:20:44 <paczesiowa> who do I complain to?
19:23:39 <b\6> paczesiowa: what do you need? if you don't care too much, just don't use the wacky space padding thing.
19:26:27 <b\6> are you on solaris or something?
19:27:03 <paczesiowa> gentoo linux
19:27:32 <sm> why is cabal convinced MissingH is hidden/uninstalled ?
19:27:40 <sm> ghc-pkg shows it exposed globally
19:28:33 <ddarius> cabal hides all packages not listed in the depends or whatever clause
19:29:01 <sm> so I added it to the depends, then it doesn't see it at all
19:29:24 <sm> build-depends: missingh etc.
19:30:00 <sm> I just had a brainwave.. ghc --make. worked great :/
19:32:38 <b\6> yeah, sometimes i run ghc --make on random other source that isn't even haskell to see if it'll help.
19:32:53 <lispy> lol @ b\6
19:33:36 <sm> good idea
19:34:13 <lispy> ?remember b\6 yeah, sometimes i run ghc --make on random other source that isn't even haskell to see if it'll help.
19:34:14 <lambdabot> Okay.
19:35:00 <sm> when my program dies with Maybe.fromJust: Nothing , what's the way to get more of an execution trace ?
19:35:25 <paczesiowa> sm: ghci debugger
19:36:18 <SamB_XP> sm: or possibly profiling
19:36:49 <sm> thanks.. I remember something you could turn on in the RTS
19:37:06 <SamB_XP> oh, yes, -xc is nice
19:38:07 <lispy> SamB_XP: how do I read the documentation for that?
19:38:56 <lispy> possible here: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
19:38:57 <lambdabot> Title: 5.14.ï¿½Running a compiled program, http://tinyurl.com/d7dj4
19:39:46 <lispy> oh, that is cool
19:40:28 <SamB_XP> lispy: also +RTS --help on a profiling binary
19:41:12 <SamB_XP> it still irks me that if I pass --help from my bootloader, Linux does not display usage information :-(
19:41:13 <sm> great, thanks
19:42:59 <sm> shouldn't -xc be available when running interpreted ?
19:44:20 <sm> hm, when I add -prof to ghc --make it fails to see missingh again
19:44:42 <thoughtpolice> sm: you have to build with profiling enabled (it will build two seperate copies, one with profiling instructions and a regular one)
19:45:00 <sm> argh, yes.. thx
19:45:12 <thoughtpolice> anything you build with profiling enabled has to have profiling versions of all the libraries it references installed
19:45:41 <SamB_XP> unfortunately cabal is very unsmart about this :-(
19:45:44 <paczesiowa> b\6: does your strftime like underscores?
19:45:48 <thoughtpolice> yeah, kinda.
19:46:16 <b\6> paczesiowa: sure, no problem. i remembered it because i'd used it.
19:46:16 <SamB_XP> it doesn't realize anything need be done if you try to reinstall a library but with profiling enabled this time
19:46:21 <sm> I see cabal install has a -p flag
19:46:34 <sm> right, looks like I'd have to uninstall it
19:46:56 <b\6> irb(main):001:0> Time.now.strftime("%_d")    => " 7"
19:46:59 <b\6> excuse my ruby
19:47:34 <sm> argh I see.. everything
19:47:39 <thoughtpolice> SamB_XP: yeah, a --force flag is definitely needed (especially for cabal install)
19:48:13 <sm> no way.. back to ghci
19:49:51 <paczesiowa> b\6: my strftime works from C (and ruby too) only haskell version hates underscores
19:51:16 <b\6> paczesiowa: hmm.
19:52:58 <sm> soo.. in ghci, I set a breakpoint on some early fn (main didn't stop it) and call main, then I :trace, and it runs and gives the exception. Is that expected ?
19:53:10 <sm> oh maybe now I can poke around
19:53:41 <sm> :history .. not stopped at a breakpoint :(
19:54:57 <b\6> i hate rfc 822.
19:55:04 <b\6> more like request for me to hate them.
19:55:13 <sm> :b linenumber .. awesome
19:55:28 <sm> request for condemnation :)
19:55:38 <SamB_XP> b\6: didn't you here? you must upgrade to hating rfc 2822!
19:55:44 <SamB_XP> s/here/hear/
19:55:48 <b\6> oh yeah.
19:56:00 <b\6> think they managed not to fix anything.
19:56:06 <b\6> that date format is retarded.
19:56:32 <SamB_XP> 2008-08-07 FTW
19:57:04 <b\6> SamB_XP: haha, no. no, no no. never ever.
19:57:39 <SamB_XP> well, 2008-08-08 then
19:57:43 <SamB_XP> that's tomorrow
19:57:50 <mauke> tomorrow comes today
19:57:52 <SamB_XP> (maybe today for you)
19:58:10 <SamB_XP> and I suddenly notice it has a lot of 08s in it
19:58:39 <mauke> 20(08){3}
19:59:12 <b\6> yeah, big day for the chinese. they love 8s.
19:59:13 <sm> aha! ghci provides -fbreak-on-exception
19:59:40 <b\6> in parsec, how can i 'count' more than the max of Int?
19:59:45 <paczesiowa> can anyone else try "getCurrentTime >>= putStrLn . formatTime defaultTimeLocale rfc822DateFormat" with imports: Data.Time, System.Locale ?
20:00:49 <mauke> Fri, d Aug 2008 03:00:40 UTC
20:01:07 <sm> Stopped at <exception thrown>
20:01:07 <sm> _exception :: e = GHC.IOBase.IOException (GHC.IOBase.IOError Nothing
20:01:08 <sm>                                                              GHC.IOBase.NoSuchThing ....) .. great, and now.. ?
20:01:14 <paczesiowa> so we do have a bug:>
20:01:36 <mauke> yep
20:01:51 <mauke> because formatTime doesn't use strftime; it's pure haskell
20:02:11 <b\6> think the _ thing is gnu.
20:02:24 <paczesiowa> than rfc822DateFormat is wrong
20:02:44 * sm reads the manual properly.. silly me
20:02:55 <b\6> for now i'd just use %d if you want to use that kind of wack date format.
20:03:47 <paczesiowa> I'll do that, I emit rss xml so I have to use that rfc822
20:03:49 <adu> ok, i'm doing another map thing
20:03:57 <adu> and I can't figure out how to do it
20:04:33 <adu> modes :: [Mode] and files :: [FilePath] and doMode :: FilePath -> Mode -> IO ()
20:04:46 <adu> how do I do "doMode" on all of them?
20:05:17 <mauke> :t zipWithM
20:05:19 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
20:05:23 <mauke> :t zipWithM_
20:05:24 <adu> ooo
20:05:24 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
20:05:30 <adu> I never would have thought of that
20:05:40 <adu> mauke: thanks
20:05:44 <mauke> :t zipWithM_ ?doMode ?files ?modes
20:05:44 <lambdabot> forall a b (m :: * -> *) c. (Monad m, ?modes::[b], ?files::[a], ?doMode::a -> b -> m c) => m ()
20:06:13 <adu> that's perfect :)
20:06:21 <paczesiowa> any volontiers to report that rfc822DateFormat bug?
20:06:31 <adu> wait
20:06:42 <adu> does that do all modes on all files?
20:06:52 <mauke> no
20:06:54 <adu> or just the first mode on the first file, second mode on second file?
20:06:58 <mauke> yes
20:07:03 <adu> :(
20:07:15 <mauke> oh, you want a cartesian product?
20:07:18 <adu> ya
20:08:17 <mauke> @undo sequence_ [ doMode f m | f <- files, m <- modes ]
20:08:17 <lambdabot> sequence_ concatMap (\ f -> concatMap (\ m -> [doMode f m]) modes) files
20:08:23 <b\6> paczesiowa: hmm. i think the _ stuff isn't posix.
20:08:54 <paczesiowa> b\6: than why define rfc822DateFormat with it?
20:09:01 <b\6> yeah, good point.
20:09:08 <b\6> strange nobody noticed for such a long time.
20:09:45 <adu> its been so long since I used list comprehension
20:09:49 <paczesiowa> I bring bad luck and find bugs in every library:)
20:10:29 <mauke> paczesiowa++
20:12:11 <paczesiowa> but I like to think that the day I find a bug in HList is the day that my curse is broken I can enjoy bug-free code for the rest of my life
20:17:05 <b\6> so where was quickcheck during this rfc822 date formatting fiasco ???
20:17:20 <b\6> think maybe the space shuttle challenger might have blown up due to that bug.
20:17:30 <SamB_XP> b\6: WHAT?
20:17:51 <b\6> think i might have to open a homicide investigation and start grepping.
20:18:00 <SamB_XP> you think e-mail bugs led to faulty o-rings?
20:18:29 <SamB_XP> I thought it was that dismissive attitude that NASA has a history of having
20:18:37 <b\6> the orings probably tried to format an rfc 822 date during the launch.
20:18:45 <SamB_XP> um, no
20:18:59 <SamB_XP> o-rings are purely mechanical
20:19:22 <b\6> right; not purely functional as they should have been.
20:19:26 <SamB_XP> they do not have any logic
20:19:52 <SamB_XP> (that is, they are not electronic)
20:19:53 <Cale> o-rings are completely illogical
20:20:08 <b\6> the space shuttle had side effects. it was doomed from the start.
20:20:32 <SamB_XP> b\6: so is your IRC client then
20:20:45 <SamB_XP> it is sending me your messages
20:21:03 <b\6> yeah, but my irc client doesn't contain tons of rocket fuel.
20:21:06 <SamB_XP> network I/O is generally known to be an irrevocable side-effect
20:21:30 <SamB_XP> rocket fuel is not very useful in a purely functional setting
20:23:54 <b\6> rationalize the loss of life any way you want. it's clear to me the blood is on haskell's hands for not formatting %_d right.
20:25:09 <paczesiowa> that blood is an hour of my life:)
20:26:14 <bd_> b\6: The o-ring stuff is clearly just an elaborate coverup orchestrated by the Haskell cabal, as they try to shift the blame onto clearly non-functional equipment.
20:26:51 <RyanT5000> how do i turn on -fglasgow-exts with runhaskell?
20:27:10 <SamB_XP> bd_: dumbass, nasa had certainly not been using Haskell at all
20:27:21 <SamB_XP> and the cabal had not even been imagined yet
20:27:36 <SamB_XP> nevermind been used to break GHC's HEAD
20:27:51 <b\6> SamB_XP: might want to adjust your sarcasm detection threshhold a little.
20:27:57 <b\6> just a tad.
20:28:02 <TSC> RyanT5000: Isn't it simply "runhaskell -fglasgow-exts Foo.hs" ?
20:28:07 <bd_> SamB_XP: I think you are underestimating the cabal. NASA was indeed using haskell at the time - although you will be hard-pressed to find any remaining documentation or surviving witnesses.
20:28:11 <SamB_XP> b\6: oh, sorry, I thought that was just random goofiness
20:28:35 <SamB_XP> bd_: I believe they have thorough documentation as to what they had been using
20:29:00 <SamB_XP> I suppose it's not really possible to dismiss the possibility that they had used Haskell in prototyping at some point
20:29:01 <bd_> The cabal is very thorough.
20:29:03 <RyanT5000> TSC: no, i just figured it out: it's runhaskell -- -fglasgow-exts Foo.hs
20:29:13 <RyanT5000> if you just do -f, it thinks that's the location of ghc
20:29:38 <TSC> Ah, right
20:29:56 <SamB_XP> but they certainly were not foolhardy enough to run Haskell code on such underpowered computing equipment as they had available
20:31:01 <SamB_XP> I mean, it probably would only have been able to run ... gopher
20:31:06 <SamB_XP> or do I mean gofer?
20:32:37 <b\6> if i remember correctly, neil armstrong passed some time on the way to the moon playing ultima 7. they had some pretty scary doublespace and himem.sys problems, but they told him a new config.sys to type in and got it going.
20:33:03 <SamB_XP> what the hell?
20:33:41 <SamB_XP> was he playing on mission-critical equipment?
20:34:55 <bd_> wasn't this before the 8086? <.<
20:35:02 <RyanT5000> alright, say i'm doing the "data Zero ; data Succ a" thing; how do i define a homogeneous list of a certain length?
20:35:45 <SamB_XP> bd_: well, NASA has this NIH syndrome when it comes to CPUs actually
20:36:11 <SamB_XP> (though they actually have a really really damn good excuse for it)
20:36:57 <bd_> SamB_XP: Well, I mean, the apollo stuff was designed in the 60s, the 8086 wasn't around then :)
20:41:54 <petekaz> how do I take every 3rd element of a list?  [1,2,3,4,5,6,7,8,9] -> [3,6,9]
20:45:10 <b\6> petekaz: i guess one way would be to build a list by drop 2, take 1, etc. there are lots of ways.
20:45:21 <ivanm> with Text.Printf, is there a way of passing it a list of numbers, or would I have to convert that list first?
20:45:26 <petekaz> I thought there would be some clever way.
20:45:58 <mauke> ivanm: you'll need to convert it first
20:46:02 <mauke> C doesn't have lists :-)
20:46:08 <ivanm> > let everyThird (x:y:z:rest) = z : (everyThird rest); everyThird _ = [] in everyThird [1..10]
20:46:10 <lambdabot>  [3,6,9]
20:46:15 <ivanm> mauke: that's what I figured :s
20:46:18 <ivanm> petekaz: like that?
20:46:55 <petekaz> ivanm: good enough!
20:46:59 <petekaz> ivanm: thanks
20:47:05 <ivanm> note that how b\6 said would be extendable so that you could take every nth element of a list, mine needs to be re-written each time
20:47:10 <ivanm> petekaz: no worries ;-)
20:51:51 <mauke> @quote mauke
20:51:51 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
20:52:38 <mauke> @quote mauke
20:52:39 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
20:52:39 <jeffz`> @quote cpst
20:52:39 <lambdabot> cpst says: your mom's like a monad, because she supports do notation
20:53:41 <b\6> and cuz nobody understands her and she's annoying.
20:54:15 <int-e> you'll get to love monads once you mature.
20:54:24 <b\6> yeah yeah.
20:55:36 * bitrot has always wondered about the acronym: "Monads I'd Like Functionally"
20:56:23 <b\6> heh. i noticed there's a section in _the haskell road_ called "let's talk about sets".
20:56:33 <b\6> they don't seem like jokers, but ..
20:58:56 <b\6> is there any savings to be had in doing matches like l@[] -> l rather than [] -> [] ?
20:59:36 <mauke> no, [] is globally unique anyway
20:59:45 <b\6> ok.
20:59:48 <mauke> also, l@[] -> l might not typecheck
20:59:58 <b\6> yeah, i think i did have a problem once.
21:00:09 <b\6> seems to depend on its order in the matches.
21:00:22 <SamB_XP> there might actually be as many as 2 different []s
21:16:03 <dsrogers> Greetings
21:16:51 <dsrogers> as anyone tried implementing a relational calculus in haskell?
21:17:02 <dsrogers> it seems very functional.
21:17:18 <hml> is there a built in name for something like: (state -> a -> (state, b))
21:17:37 <dibblego> hml, the State monad
21:17:42 <dsrogers> State monad
21:18:11 <hml> state monad is not: (state -> a -> (state, a)) ?
21:18:19 <dsrogers> no.
21:18:21 <mauke> a -> State state b
21:18:52 <ivanm> I know that ghci only prints out the codepoints of utf8 characters... but when printing it to stdout/file will it print the actual character?
21:18:58 <dsrogers> the type a state returns when run may change after each invocation
21:19:09 <hml> mauke: what do you mean by a -> State state b?
21:19:10 <ddarius> ivanm: It depends on what function you use to print them.
21:19:18 <mauke> @unmtl a -> State state b
21:19:18 <lambdabot> a -> State state b
21:19:21 <mauke> :-(
21:19:24 <mauke> hml: it's a type
21:19:30 <ivanm> ddarius: oh? what function _should_ I use?
21:19:51 <ivanm> I'm trying to have the show instance of my function print the xor symbol: âŠ»
21:20:00 <ddarius> ivanm: A function that encodes codepoints as utf8 characters.  They aren't utf8 in memory.
21:20:06 <mauke> System.IO.UTF8.*
21:20:11 <ddarius> @hackage utf8-string
21:20:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
21:20:20 <ivanm> :(
21:20:53 <ivanm> dammit, what font is xchat using? when I entered that character it showed properly... but when it appeared in the msg window it's just a box :s
21:22:54 <dsrogers> the font xchat is using depends on how it was compiled.
21:23:00 * ivanm might just use "xor" to represent the xor function... it's not that big a deal :s
21:23:09 <ivanm> dsrogers: ummm.... you _can_ change the font...
21:23:18 <dsrogers> it's not compiled in.
21:23:23 <dsrogers> but you have some choices.
21:23:41 <ivanm> though the weird thing is, it's using dejavu sans mono in the msg window... and I'm using that in emacs and the char appears :s
21:23:49 <dsrogers> it's possible to make it use the gnome settings, for example.
21:23:49 <ddarius> ivanm: All you have to do is cabal install utf8-string and import System.IO.UTF8 and continue as normal.
21:24:14 <ivanm> ddarius: I've got it installed, that's not a problem
21:44:02 <hml> is it pssible to get all about monads a a single pdf?
21:44:08 <hml> dead trees are much easier 9on the eyes
21:44:33 <ddarius> @google "All About Monads" filetype:pdf
21:44:34 <lambdabot> http://www.cas.mcmaster.ca/~carette/CAS706/F2006/presentations/comonads.pdf
21:44:34 <lambdabot> Title: (Co)Monads for Dummies Grad Students
21:44:45 <hml> wtf are comonads?
21:44:49 <mlh> dsrogers: there's a lot of hits on google for Relational _Algebra_ and haskell  -- is that close enough?
21:45:16 <dsrogers> Is there a way to make a .hs file directly executable (by somehow allowing #!/usr/bin/runhaskell at the top of the file, for example?)
21:45:20 <lispy> I want a Relational Googlegebra implemented in Haskell
21:45:38 <mlh> well you can't have one so there
21:45:56 <dsrogers> I'm looking for a relational calculus implemenation, actually.
21:46:17 <ddarius> dsrogers: You can make a .lhs file directly executable that way.
21:46:41 <MyCatVerbs> mlh: roughly the opposite of monads. :)
21:46:57 <dsrogers> kinda like list comprehensions, only on relations, and mathematically rigorous
21:47:01 <lispy> MyCatVerbs: so they keep taking values out of wrappers?
21:47:07 <mlh> MyCatVerbs: you mean hml not mlh
21:47:32 <MyCatVerbs> mlh: ...how in the name of rubberised buggery am I supposed to tell you two apart? Sorry, that's just not civilised.
21:47:50 * lispy is tempted to change nicks to hlm or another permutation of m, l and h that is not taken :)
21:48:06 <MyCatVerbs> lispy: right. Cobind does something weird, instead of return there's an extract.
21:48:54 <MyCatVerbs> hml, lispy: http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html <-- very good blog post, explains the concept with a solid motivating example.
21:49:00 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
21:49:20 <MyCatVerbs> Thanks, \bot. You're my heroine.
21:49:56 <lispy> Is there something like type MyFun p = Foo p x y -> Bool ?
21:50:15 <lispy> That particular way of doing it, I get an error that x and y are not in scope, basically
21:50:29 <lispy> But adding a forall p x y. is wrong too
21:50:36 <lispy> er forall x y, actually
21:50:40 <Cale> Cellular automata are sort of my default example comonad actually :)
21:50:58 <MyCatVerbs> They're a pretty good one.
21:51:10 <ddarius> Cale: Why not zippers and such?
21:51:33 <dolio> Cellular automata are just a special case of zippers.
21:51:38 <ddarius> lispy: wtf do you want it to mean?
21:52:03 <lispy> Suppose, I had String -> Foo p x y -> Bool
21:52:04 <hml> MyCatVerbs: cool; thanks
21:52:15 <lispy> And I want to change it to, String -> MyFun p
21:52:38 <ddarius> You want dynamically scoped typed variables ...
21:52:39 <lispy> So that when I change MyFun, i just have to edit the type synonm
21:52:47 <MyCatVerbs> lispy: what's wront with type MyFun p x y = Foo p x y -> Bool?
21:52:53 <MyCatVerbs> *wrong, even.
21:53:05 <ddarius> s/typed/type
21:53:07 <lispy> Nothing I guess
21:53:21 <lispy> I was just hoping to avoid specifying the x y all over the place
21:53:39 <MyCatVerbs> lispy: unless you have a forall. in there, it just doesn't make any sense to have MyFun not mention x or y. Think about the point of use - how on Earth is the compiler supposed to pick concrete types for x and y?
21:54:01 <ddarius> lispy: forall should do the right thing most of the time
21:54:10 <lispy> ddarius: I get errors about monotypes
21:54:24 <lispy>     Cannot match a monotype with `MatchFun p'
21:54:24 <lispy>       Expected type: Either String (MatchFun p)
21:54:24 <lispy>       Inferred type: Either [Char] b
21:54:41 <ddarius> lispy: Yeah.  That's one of the places it won't do the right thing.
21:54:51 <lispy> :)
21:54:57 <MyCatVerbs> ddarius: damn your "most" qualifier!
21:55:13 <ddarius> It will pretty much only work in the simple case you illustrated.
21:55:33 <ddarius> String -> forall x y. Foo p x y -> Bool  ~ forall x y. String -> Foo p x y -> Bool
21:55:45 * lispy nods
21:56:00 <lispy> It's when it's on the right of the last arrow that it means someithng different
21:56:21 <lispy> (unless you put parens in to regroup the arrows of course)
21:56:59 <MyCatVerbs> :t (Nothing :: forall a. Maybe a)
21:57:01 <lambdabot> forall a. Maybe a
21:57:29 <ddarius> You could always go #define MyFun(p) ...
21:57:36 <MyCatVerbs> > (\a -> (a >>= (+5),a >>= (++"foo"))) (Nothing :: forall a. Maybe a)
21:57:36 <lambdabot>  Parse error at "." (column 58)
21:58:04 <ddarius> But if you did that, you would be shot.
21:58:55 <Cale> Well, perhaps more generally, I think of the case of functions whose domain is a group.
22:02:04 <MyCatVerbs> Cale: huh? Why a group?
22:02:29 <ddarius> class Group g where unit :: g; mult :: g -> g -> g; inverse :: g -> g; instance Group g => Comonad (g ->) where extract f = f unit; duplicate w = (w .) . mult
22:03:12 <MyCatVerbs> Oh, nice.
22:03:14 <Pseudonym> :t \f -> f unit
22:03:44 <ddarius> Looks like it only needs something monoid-ish.
22:03:45 <ivanm> if I have a class Foo, is it possible to state that all instances of Foo must also be an instance of Show?
22:03:59 <ddarius> class Show a => Foo a
22:04:12 <MyCatVerbs> ddarius: was gonna say, that looks like it should work just fine for Monoids too, since it doesn't use inverse.
22:04:15 <ivanm> thanks ddarius
22:04:47 <Cale> mm... yeah, monoid should do
22:04:58 <Cale> hmm...
22:05:08 <Cale> yeah
22:05:18 <dolio> What is that? Writer comonad?
22:05:43 <ddarius> @tell edwardk We have the comonad of functions Monoid m => m -> a, no?
22:05:44 <lambdabot> Consider it noted.
22:05:55 <Cale> I can check :)
22:05:57 <ddarius> I guess I could check.
22:06:23 <ddarius> I'm wondering if he has it in category-extras.
22:06:41 <dolio> Can't say I recall seeing it.
22:06:43 <ddarius> I think he may actually.
22:07:50 <dolio> Oh, he does, but he calls it Exp m.
22:07:58 <MyCatVerbs> What're the Comonad laws?
22:08:01 <dolio> And doesn't have (->) m.
22:08:17 <Cale> Okay, so extract . duplicate = id and fmap extract . duplicate use the identity laws for monoid, and iirc, duplicate . duplicate = fmap duplicate . duplicate will use associativity
22:09:08 * Cale checks the last one
22:09:09 <dolio> He doesn't actually have (,) r, either.
22:09:21 <dolio> Just Coreader r.
22:12:45 <Cale> yes
22:12:49 <Cale> That's right.
22:12:54 <Cale> All you need is a monoid.
22:13:41 <Cale> wrt groups, I was thinking of another definition involving multiplication by the inverse
22:14:05 <Cale> That one ought to work out just as well.
22:14:09 <lispy> MacHaskuyver just needs a monoid, an identity function and one where clause!
22:14:42 <dolio> Rather makes sense, since Monoid m => (,) m and (->) r are monads, that Monoid m => (->) m and (,) r woudl be comonads.
22:15:14 <lispy> Due to his upbringing, MacHaskuyver never uses unsafePerformIO to get his way, instead he likes to use simple transformations in clever ways.
22:16:00 <ddarius> dolio: Demonstrate it.
22:16:12 <dolio> Demonstrate what?
22:16:26 <Pseudonym> MacHaskuyver can do amazing things with a couple of monad transformers and a roll of bailing wire.
22:17:06 <vanLiempt> Hey, is anyone active to help a complete and total noob with his haskell problem?
22:17:10 <lispy> Pseudonym: I'm glad MacHaskuyver is on the side of good
22:17:12 <Cale> vanLiempt: yep
22:17:17 <Cale> vanLiempt: ask away :)
22:17:23 <vanLiempt> Okay.
22:17:27 <lispy> Uh, oh, you have Cale's attention...you're screwed ;)
22:17:34 <Cale> haha
22:17:35 <MyCatVerbs> instance Comonoid ((,) r) where { coreturn (c,b) = b; cojoin (c,b) = (c,(c,b)); } -- ?
22:17:50 <Pseudonym> "Screwed" in this case means you're doomed to learn something whether you want to or not.
22:18:05 <MyCatVerbs> Erm, subject to beta-reduction wherein I suddenly change my name about the symbol name ('c' instead of 'r', oops) about halfway through...
22:18:06 <vanLiempt> Heh.
22:18:08 <vanLiempt> Excellent.
22:18:19 <vanLiempt> This is my code: http://hpaste.org/9454
22:18:29 <Pseudonym> Those who reinvent Haskell are doomed to understand it.
22:18:33 <dolio> MyCatVerbs: Yes, if you mean Comonad.
22:18:49 <vanLiempt> I have a whole plethora of problems when I try to compile it, and I'm unable to understand why they exist.
22:18:54 <MyCatVerbs> dolio: great. Two screwups in the space of one sentence. Faiiiiil. x_x
22:19:01 * Cale waits for hpaste.org to respond...
22:19:02 <MyCatVerbs> dolio: still. Dank.e
22:19:19 <Cale> ah, there we are...
22:19:29 <ddarius> dolio: That there is an actual connection.
22:19:29 <lispy> vanLiempt: Well, you could start by reducing your code to simpler parts
22:19:32 <Pseudonym> vanLiempt: Just a suggestion, it's well worth putting type declarations on.
22:19:42 <Pseudonym> Your error messages tend to be nicer.
22:19:42 <lispy> vanLiempt: for example
22:19:43 <lispy> nPDF = \o u x -> exp(-((x-u)^2/(2*o^2)))/(o*sqrt(2*pi))
22:19:47 <vanLiempt> Pseudonym: That's a problem in and of itself.
22:19:49 <MyCatVerbs> Oh and, (c,b) =>> f = (c,f (c,b)), no?
22:19:51 <rwbarton> MyCatVerbs: The first "screwup" wasn't one--r is a type, and c is a value of that type.
22:19:51 <Cale> my initial guess without actually looking at the code is that you're being bitten by an annoying misfeature called the monomorphism restriction
22:19:57 <lispy> vanLiempt: more traditional way is, nPDF o u x = ...
22:20:00 <rwbarton> MyCatVerbs: So your screwups were in different sentences :)
22:20:07 <MyCatVerbs> rwbarton: THREE screwups, in which case.
22:20:23 <MyCatVerbs> rwbarton: I mess up inductively. :)
22:20:30 <vanLiempt> When I try to declare a type for u I get a compiler error no matter what type I use.
22:20:32 <Cale> vanLiempt: Try moving the parameters to the other side first like lispy suggests.
22:20:37 <dsrogers> getNameInfo: does not exist (System error)
22:20:37 <vanLiempt> Okay.
22:20:49 <dsrogers> I'm getting that in HApps
22:21:01 <Pseudonym> vanLiempt: Either doing that, OR putting on type declarations, will fix any monomorphism restriction problems in this code.
22:21:11 <MyCatVerbs> rwbarton: myCatVerbs = Data.Function.fix (\l -> ScrewUp : l)
22:21:12 <vanLiempt> Cale: And that fixed it.
22:21:12 <Pseudonym> (Not in all code, but in this case it will.)
22:21:13 <vanLiempt> Wow.
22:21:24 <vanLiempt> Care to explain what my problem was exactly?
22:21:26 <vanLiempt> =P
22:21:27 <Pseudonym> Haha.
22:21:33 <Pseudonym> ?go monomorphism restriction
22:21:35 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:21:35 <lambdabot> Title: Monomorphism restriction - HaskellWiki
22:21:42 <Pseudonym> By all means try to understand it.
22:21:53 * lispy sighs.
22:21:56 * vanLiempt is a mathematician, not a Computer Scientist.
22:22:03 <lispy> I don't understand the monomorphism restriction still...
22:22:06 <Cale> vanLiempt: It's extremely unfortunate, but without type signatures, pattern bindings (as opposed to function bindings which take parameters) are not allowed to be polymorphic.
22:22:20 <lispy> Other than, sometimes Haskell infers things to be less polymorphic than it should
22:22:46 <Pseudonym> vanLiempt: Please do read that page.  It's gentler than I remember.
22:23:12 <lispy> Cale: so a lambda absraction is a pattern binding an not a function binding?
22:23:20 <vanLiempt> Okay, I shall do so.
22:23:36 <Cale> lispy: well, things like look like  foo = ...  are pattern bindings, whereas  foo x = ...  is a function binding
22:23:46 <vanLiempt> Thanks Cale, lispy, Pseudonym, et al.
22:24:09 <Cale> Another example of a pattern binding is something like  (x:xs) = ...
22:24:29 <Cale> That is, one where you have a pattern to match on the lhs.
22:24:31 <lispy> Cale: I never really thought about that before
22:24:48 <Cale> Yeah, it really should be something that you don't have to think about so much.
22:24:52 <Pseudonym> lispy: And that is why the monomorphism restriction gets people.
22:24:59 <Cale> But the MR is pure evil. I just turn it off by default.
22:25:18 <lispy> Cale: maybe because I was taught in haskell we have eta for free, so (ignoring MR), f = \e -> ... == f e = ...
22:25:18 <vanLiempt> You can turn it off?
22:25:29 <rwbarton> > let len = genericLength "foo" in (len, len) :: (Integer, Double) -- it's off in lambdabot
22:25:30 <lambdabot>  (3,3.0)
22:25:31 <Pseudonym> vanLiempt: Yes, but then you're not programming in Haskell 98.
22:25:44 <Pseudonym> Which may or may not be an issue for you.
22:25:45 <Cale> vanLiempt: yeah  -XNoMonomorphismRestriction  -- you can put  :set -XNoMonomorphismRestriction  in your .ghci file
22:25:52 <Pseudonym> Few people program in Haskell 98 these days.
22:26:07 <vanLiempt> I'm learning Haskell as more of a time killer than anything else.
22:26:20 <Pseudonym> It's a great time sink, that's for sure.
22:26:20 <Cale> You can also include a comment in your source that looks like:  {-# LANGUAGE NoMonomorphismRestriction #-}
22:26:34 <vanLiempt> Okay, cool.
22:26:36 <Pseudonym> However, Cale, one caveat on doing that.
22:26:40 <Cale> Or if you're building with cabal, add it to the list of language extensions in the cabal file.
22:27:08 <Pseudonym> Unless you're programming polymorphic combinator code, there would seem to be no reason to turn it off.
22:27:13 <dmwit> {-# LANGUAGE NoMonomorphismRestriction #-}
22:27:28 <vanLiempt> If I added a line that said "arcerf :: (Integral a, Num (a -> a), Floating a) => a -> a -> a" or something, could I go back to the lamba form?
22:27:45 <Pseudonym> In the case of vanLiempt's code, it is meant to be monomorphic, unless he intended it to work with both Double and Float.
22:27:47 <Cale> Pseudonym: I wasted half an hour trying to track down what was going wrong with some code in ST once.
22:27:54 <dmwit> vanLiempt: yes
22:27:58 <Pseudonym> That's polymorphic combinator-like code, though.
22:28:07 <Cale> Well, okay
22:28:13 <rwbarton> vanLiempt: Yes, and adding type annotations is a good idea for other reasons too.
22:28:26 * vanLiempt is eager to learn.
22:28:26 <Cale> But the reason was that this was before forM was in Control.Monad, and I'd glibly written  forM = flip mapM
22:28:44 <rwbarton> vanLiempt: As Pseudonym mentioned, you'll get better error messages when your program doesn't type check
22:28:44 <vanLiempt> rwbarton: Which might include. . .?
22:28:48 <Cale> Which caused my s to become ()
22:29:33 <vanLiempt> Okay.
22:29:34 <Cale> (of course, it was not obvious that this was the reason, because there was a whole bunch of stuff going on :)
22:29:54 <rwbarton> vanLiempt: Plus, they act as documentation for the function.  This is less true in your case, but a lot of the time, you can tell what a function does just by looking at its type signature.
22:29:55 <dmwit> vanLiempt: as documentation
22:29:57 <vanLiempt> Cale: While I have your attention, what are Flexible Contexts and why do they hate me?
22:30:01 <Pseudonym> The bottom line with the monomorphism restriction: "If this seems arbitrary, that's because it is."
22:30:02 <Cale> The goals that the MR is in place for would be much better served by a warning message.
22:30:28 <dmwit> it's not arbitrary
22:30:29 <Cale> vanLiempt: uh, what message are you getting?
22:30:35 <Pseudonym> dmwit: Yes, it is.
22:30:49 <vanLiempt>     Non type-variable argument in the constraint: Num (a -> a)
22:30:51 <vanLiempt>     (Use -XFlexibleContexts to permit this)
22:30:51 <vanLiempt>     In the type signature for `arcerf':
22:30:51 <vanLiempt>       arcerf :: (Integral a, Num (a -> a), Floating a) => a -> a -> a
22:31:03 <Cale> vanLiempt: Ah, you're trying to use a function as a number.
22:31:16 <Pseudonym> As I pointed out in the wiki page, it's an attempt to design an objective rule to disallow subjectively unexpected behaviour.
22:31:19 <Pseudonym> Ergo, it's arbitrary.
22:31:39 <dmwit> Pseudonym: "Arbitrary" implies a malicious lack of reasons.  The MR has a reason, even if it seems misguided to you (and me).
22:31:49 <Pseudonym> @wn arbitrary
22:31:50 <lambdabot> *** "arbitrary" wn "WordNet (r) 2.0"
22:31:50 <lambdabot> arbitrary
22:31:50 <lambdabot>      adj : based on or subject to individual discretion or preference
22:31:50 <lambdabot>            or sometimes impulse or caprice; "an arbitrary
22:31:50 <lambdabot>            decision"; "the arbitrary rule of a dictator"; "an
22:31:52 <lambdabot> [3 @more lines]
22:32:15 <Cale> vanLiempt: If that much is okay, and it's really what you want, then the next problem is that Haskell 98 has restrictions on what typeclass contexts are supposed to look like
22:32:16 <Pseudonym> "Individual discretion" does it for me.
22:32:20 <vanLiempt> Cale: Forgive me if I'm being dense, but how do I fix this?
22:32:38 <dmwit> "caprice" does it for me. =)
22:32:42 * dmwit shrugs
22:33:16 <dmwit> Anyway, I don't like it.  If you want to call it arbitrary, I guess I'll stop arguing.
22:34:29 <rwbarton> vanLiempt: It's because you wrote "2m", not "2*m", in con
22:34:51 <vanLiempt> Oh.
22:35:00 <rwbarton> vanLiempt: See, if you wrote a type signature for con, you'd get the error in the right place :)
22:35:11 <lispy> > \m -> 2m + 1
22:35:12 <lambdabot>   add an instance declaration for (Num (t -> a))
22:35:14 * vanLiempt is used to juxtaposition.
22:35:17 <Cale> Yep, rwbarton is right :)
22:35:36 <lispy> :t 2m
22:35:37 <lambdabot> forall t. (Num (Expr -> t)) => t
22:35:45 <Cale> vanLiempt: another thing is that we don't write f(x) in Haskell, we write f x
22:35:50 <lispy> :t \m -> 2m
22:35:51 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
22:35:56 <Cale> Parens are only used when you need to group things.
22:36:14 <vanLiempt> And it's left associative?
22:36:18 <Cale> yeah
22:36:22 <vanLiempt> Okay
22:36:23 <Cale> f x y = (f x) y
22:36:36 <lispy> :t 2foo
22:36:44 <lispy> (stupid m :: Expr)
22:36:55 <lispy> lambdabot: hey!  I'm talking to you!
22:37:17 <vanLiempt> Hmm, even when I kill the 2m and put in 2*m I still get the same error.
22:37:21 <lispy> Huh, so 2m = 2 m
22:37:25 <lambdabot> Install your own GHCi, primate.
22:37:29 <Cale> lispy: yes
22:37:29 * vanLiempt tries to figure out what type would have.
22:37:39 <vanLiempt> Erm, what type con would have, rather.
22:37:41 <rwbarton>  :t isn't giving an error message these days when the expression doesn't typecheck
22:37:50 <lispy> ?vixen you like it when I acts like a Primate though...you said...
22:37:50 <lambdabot> yeah, i like
22:38:06 <lispy> rwbarton: ah
22:38:14 <rwbarton> I think?
22:38:16 <rwbarton> :t fix fix
22:38:22 <Cale> vanLiempt: Well, if you don't want the absolute most general type, it's easy. Double -> Double will work.
22:39:08 <Cale> Its actual type is (Fractional t, Enum t) => t -> t
22:39:13 <vanLiempt> con :: (Fractional t, Enum t) => t -> t
22:39:24 <vanLiempt> Yeah, that's what I was just going to ask.
22:39:45 <vanLiempt> Okay, so I don't want to trouble you folks anymore, but I'm still failing.
22:39:46 <Cale> Fractional because you're doing division on things of type t, and Enum because of the [1..(k-1)]
22:39:52 <Cale> Oh?
22:39:54 <vanLiempt> Even with all the changes.
22:39:59 <vanLiempt> Same error message too.
22:40:08 <rwbarton> Can you update the hpaste?
22:40:13 <lispy> vanLiempt: can you annotate your paste
22:40:14 <Cale> Did you fix the multiplication thing?
22:40:14 <vanLiempt> Sure.
22:40:41 <vanLiempt> Yup.
22:40:42 <Cale> It compiles here...
22:40:48 <vanLiempt> http://hpaste.org/9455
22:41:07 <lispy> Num (a -> a)
22:41:10 <lispy> That's fishy
22:41:19 <Pseudonym> > id * id
22:41:20 <lambdabot>   add an instance declaration for (Num (a -> a))
22:41:42 <Cale> vanLiempt: Oh, wrong type signature for arcerf
22:41:58 <Cale> vanLiempt: You must have gotten that before you fixed con
22:42:15 <vanLiempt> Oh.
22:42:45 <lispy> Although, Num (Double -> Double), might be a fun ring to have
22:42:53 <vanLiempt> It should be arcerf :: (Integral a, Floating a) => a -> a -> a?
22:43:05 <lispy> Or maybe Num (Rational -> Rational) would be better
22:43:35 <Cale> vanLiempt: oh, that's right, but it's going to cause you trouble
22:43:53 <Cale> vanLiempt: Because nothing is both Integral and Floating :)
22:44:03 <vanLiempt> Oh.
22:44:10 <rwbarton> vanLiempt: As an aside, generally when you see the compiler generate something like Num (a -> a) (or Num [a], etc.) it's because you used a number where you needed a function or vice versa.
22:44:16 <vanLiempt> I only have integral in there because if I didn't it would complain about the exponentiation.
22:44:25 <Cale> vanLiempt: The problem is ^ which should probably be **
22:44:35 <Pseudonym> Yeah, there are three kinds of exponentiation.
22:44:38 <Pseudonym> :t (**)
22:44:39 <lambdabot> forall a. (Floating a) => a -> a -> a
22:44:40 <Pseudonym> :t (^)
22:44:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:44:42 <Pseudonym> :t (^^)
22:44:43 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
22:44:45 <Pseudonym> Which is a bit confusing.
22:44:53 <vanLiempt> Oh, I see.
22:44:54 <lispy> I didn't know about (^^)
22:44:57 <Cale> It's not confusing if you know the definitions from mathematics though :)
22:45:07 <lispy> > 100101010101010101 ^^ 0.5
22:45:07 <lambdabot>  Add a type signature
22:45:17 <lispy> ?instances Fractional
22:45:18 <lambdabot> Double, Float
22:45:19 <Pseudonym> Cale: It's confusing as to which version corresponds to which ASCII combination.
22:45:26 <Cale> well, okay, yeah :)
22:45:39 <rwbarton> vanLiempt: You might expect to just get an error message, but because Haskell has type classes which are open, it's conceivable you really did mean to define an instance of Num (a -> a).
22:45:41 <vanLiempt> So if I drop the Integral and change the ^ to ** it should work?
22:45:42 <Cale> But it's at least not confusing why there's three of them then :)
22:45:45 <Cale> yeah
22:45:53 <vanLiempt> Okay.
22:45:55 <lispy> > 0.5 ^^ 99999999999999999
22:45:56 <lambdabot>  0.0
22:46:19 <vanLiempt> Oh, should I have Enum a too?
22:46:23 <rwbarton> vanLiempt: So in practice, you should treat Num (a -> a) as an error like "Couldn't match expected type a -> b against inferred type <something numeric>"
22:46:23 <Cale> > 0.5 ^^ (-3)
22:46:24 <lambdabot>  8.0
22:46:34 <vanLiempt> Yeah. Needed an Enum.
22:46:40 <vanLiempt> Anyway, thank you all very much.
22:46:45 <Cale> vanLiempt: no problem
22:46:53 <Cale> vanLiempt: Make sure to stick around
22:47:02 <Cale> and feel free to ask questions any time :)
22:47:09 <vanLiempt> Ok.
22:48:30 <Cale> Haskell's number classes can be a little bewildering at first... they're a bit of a compromise between practical issues of computing with numbers and mathematical elegance. There are also some little annoyances about them which most people would like to change, but by and large they're not so bad once you're used to them.
22:49:04 <Cale> Reading the Prelude will probably answer most questions about them... there's also a handy diagram of what implies what in the Report...
22:49:14 <vanLiempt> Most of them aren't foreign to me.
22:49:15 <Pseudonym> vanLiempt: Also, if you haven't already, join haskell-beginners.
22:49:16 <lispy> BTW, Cale is a math conseur :)
22:49:23 <magthe> morning!
22:49:33 <Cale> http://haskell.org/onlinereport/basic.html#standard-classes
22:49:33 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
22:49:46 <Cale> (you might have to scroll up a bit)
22:49:54 <Pseudonym> There's also a certain amount of historical stuff in the number classes.
22:50:10 <Pseudonym> As in, if the language support for fine-grained classes were a bit better, you could do more.
22:50:28 <Cale> yeah...
22:50:55 <vanLiempt> lispy: Conseur?
22:51:12 * vanLiempt notes that English isn't his first language.
22:51:49 <dibblego> in the denotational semantics of logic, does -> have right associativity?
22:51:53 <lispy> vanLiempt: enthusiast
22:52:27 <vanLiempt> Aha.
22:52:37 <quicksilver> lispy: "connoisseur"
22:52:39 <quicksilver> fwiw.
22:52:53 <Cale> I wasn't sure about that word either :)
22:53:20 <Cale> Ah, connoisseur :)
22:53:50 <lispy> doh!
22:53:51 <Cale> dibblego: Most often I've seen people always parenthesise it explicitly.
22:53:53 <lispy> MY spelling is terrible
22:53:56 <lispy> Sorry for the mix up
22:54:05 <vanLiempt> Heh.
22:54:22 <dibblego> Cale, what if it isn't though? what if I wrote P -> Q -> R where P, Q and R are propositions; how would a reader be expected to interpret this?
22:54:24 <Cale> dibblego: (in mathematical contexts)
22:54:43 <Cale> Oh, in that case, I would start by guessing that it's right associative.
22:54:57 <quicksilver> dibblego: very definitely right associative.
22:54:59 <lispy> Ugh, 'type' isn't as general as I would like
22:55:03 <dibblego> ok thanks
22:55:06 <vanLiempt> Yeah, right asociative.
22:55:15 <|Steve|> If -> is implication, I'd start by complaining loudly that implication isn't associative and refuse to deal with it.
22:55:31 <vanLiempt> Heh.
22:55:41 <vanLiempt> -> is a lot of things.
22:55:41 <dibblego> |Steve|, would you do the same for a - b - c?
22:56:00 <quicksilver> complaining at text books and exam papers is not ultimately productive though :)
22:56:02 <|Steve|> Of course not, that is a well defined meaning as does a^b^c.
22:56:17 <lispy> I have, type EasyPC p x y = FL (PatchChoice p) x y, but when I use it with my type constructor (:>) p x y -> p y z -> (:>) p x z, i get errors about EasyPC not being fully applied :(
22:56:21 <quicksilver> right associativity of -> is a rather widely held convention.
22:56:30 <vanLiempt> Cale: How much math do you know? (i.e. how far have you been educated in the field?)
22:56:43 <Cale> |Steve|: It's rather useful for -> to be right associative, but it's a bit uncommon among mathematicians to define it that way as of yet.
22:56:44 <|Steve|> Not that I've ever seen and I've been forced to teach propositional logic more times than I'd care to.
22:56:51 <Cale> vanLiempt: I have a BMath
22:57:12 <vanLiempt> And you're pursuing graduate education in. . .?
22:57:25 <|Steve|> In irc, iirc.
22:57:28 <quicksilver> |Steve|: well, I've tought propositional logic myself for quite a few years in the UK, and right associativity was universally understood.
22:57:31 <Cale> vanLiempt: Eventually, probably algebraic combinatorics, certainly some branch of mathematics :)
22:57:37 <quicksilver> certainly local standards vary.
22:57:47 <Cale> vanLiempt: For the next couple years, I'm going to be working in the real world :)
22:58:03 <vanLiempt> Cale: Also, note that some some people don't like -> to be used as implication.
22:58:13 <vanLiempt> Erm, not cale.
22:58:13 <vanLiempt> Someone else.
22:58:16 <Cale> vanLiempt: Well, =>
22:58:18 <|Steve|> quicksilver: Good to know. I'll keep that in mind in case I ever see it unparenthesized.
22:58:43 <magthe> a parsec question: http://hpaste.org/9456?lines=true
22:58:52 <vanLiempt> Cale: Oh goody.
22:59:02 <|Steve|> Cale: Not that I'd know since I haven't left academia, but real world sounds boring.
22:59:04 <magthe> any pointers appreciated :)
22:59:05 <vanLiempt> I'm a specialist in set theory and foundations myself.
22:59:23 <vanLiempt> But I dabble in everything.
22:59:52 <Cale> |Steve|: eh, it should be okay. It sounds like it should be not such hard work, and I ought to get nice pay for it.
22:59:52 <Pseudonym> You'll love Haskell, then.
23:00:12 <Cale> magthe: looking...
23:00:15 <|Steve|> Since I can never get any responses in #ghc, any ideas why when building ghc, stage1 doesn't seem to like compiling c files?
23:00:26 <vanLiempt> Pseudonym: It's actually why I got into it.
23:00:31 <Cale> |Steve|: btw, do you know about the Curry-Howard correspondence?
23:00:38 <quicksilver> magthe: the point here is that manyTill consumes the "final" thing you give it.
23:00:42 <|Steve|> Cale: I'm familiar with it, yeah.
23:00:44 <vanLiempt> A peer of mine in the physics field recommended it to me, so I thought I'd try it out.
23:00:54 <|Steve|> Type systems and proofs or some such.
23:01:01 <Cale> |Steve|: so the -> arrow in Haskell in some sense *is* the implication arrow :)
23:01:12 <Cale> (that is, the type-level ->)
23:01:14 <quicksilver> magthe: I'd probably solve that problem with a separate tokenising step.
23:01:22 <|Steve|> I was afraid someone would bring that up.
23:01:24 <quicksilver> although I'm sure there is a parsec solution too.
23:02:17 <|Steve|> (Maybe I should just give up on ever compiling ghc.)
23:02:47 <b\6> nice way to match [1-9]\d* with parsec? currently doing do c <- oneOf ['1'..'9']; many digit >>= return.read.(c:) but i bet it could be nicer.
23:03:16 <lispy> One of the things they don't tell you about in CPP school is that haskell identifiers can't appear on the same line as a pre-processor macro :(
23:03:50 <Cale> fmap read (liftM2 (:) (oneOf ['1'..'9']) (many digit))
23:04:10 <b\6> thanks, studying.
23:04:41 <vanLiempt> Pseudonym: What's haskell-beginners?
23:04:45 <Cale> magthe: Try wrapping that char '.' in lookAhead
23:05:01 <lispy> vanLiempt: a mailing list
23:05:09 <Cale> That is, manyTill anyChar (lookAhead (char '.'))
23:05:33 <vanLiempt> Aha.
23:06:00 <Cale> mm... no, that won't work.
23:06:18 <Cale> The next string will be empty.
23:06:28 <quicksilver> magthe: maybe you want sepBy anyway?
23:06:39 <Cale> yeah, that's what I was just thinking
23:07:47 <Cale> many (noneOf ".") `sepBy` char '.'
23:08:25 <Cale> mm... but he seemingly only wants to eat 2?
23:09:10 <Cale> er, and that doesn't exactly add the . to the following strings
23:09:25 <Cale> I think the easiest thing would be simply to add it yourself. ;)
23:11:17 <quicksilver> or not return strings at all
23:11:22 <luqui> is Nothing a limit of Maybe?
23:11:37 <|Steve|> A limit?
23:11:39 <quicksilver> you almost never really want to return strings from a parser
23:11:53 <quicksilver> you want to return some custom type which indicates the shape of your structures
23:12:00 <luqui> I have no idea... I'm trying to learn category theory by looking at the docs for category-extras (this time)
23:12:16 <quicksilver> objects are types, not values.
23:12:24 <quicksilver> so limits (which are objects) are types, not values.
23:12:25 <|Steve|> Ah, a limit in that sense.
23:12:33 <quicksilver> Nothing is a value.
23:12:46 <luqui> hm ok.
23:13:11 <rwbarton> Hask doesn't have many limits, either
23:13:12 <luqui> obviously I can't jump in head first and get anywhere.  sigh... such a struggle ;-)
23:13:25 <luqui> rwbarton, can you name one?
23:13:43 <Cale> That's a funny diagram to take a limit of...
23:13:44 <rwbarton> Sure,   consider the two maps const 0, (`mod` 2) :: Integer -> Integer
23:13:51 <rwbarton> the equalizer of those maps would be the type of even Integers
23:14:04 <rwbarton> Hmm, maybe that's not such a great example, but I think you can see the problem
23:14:31 <luqui> I follow so far
23:14:46 <luqui> but I don't know what a limit is... so I don't really see the problem ;-)
23:15:02 <rwbarton> OK... let me see if I can come up with a more convincing example before I try to explain further :)
23:15:19 <luqui> ok.  I'm willing to extend haskell with subtypes in my mind if that would make it easier.
23:15:21 <|Steve|> For limits of diagrams, think of products (that's what I do at any rate).
23:15:43 <|Steve|> I can't imagine trying to learn CT through Haskell.
23:16:01 <rwbarton> Right, so a product (a, b) (usually written a x b in category theory) is a limit of the diagram   a  b   (with no arrows).  That limit exists
23:16:03 <luqui> |Steve|, I'm learning CT as many ways as I can, because no single one seems to be working
23:16:25 <luqui> |Steve|, the hope is that my brain will be able to make sense of the many different senses.
23:16:38 <rwbarton> luqui: Do you understand that example of a limit?
23:16:40 <|Steve|> CTftWM is good.
23:17:21 <Cale> Are you asking for the limit of the diagram Maybe: Hask -> Hask?
23:17:40 <luqui> rwbarton, not really.  I don't have the backround for it, I think; i.e. I don't grok adjunctions even yet.  I just saw something I thought I understood in Control.Functor.Limit
23:17:53 <Cale> (that is, the indexing category is all of Hask?)
23:18:16 <magthe> quicksilver: I'm actully not really parsing strings, but they are the easiest thing to use to show the problem I have
23:18:28 <magthe> Cale: thanks, I'll take a look at lookAhead
23:18:30 * luqui doesn't know; I was asking for the limit of something so maybe I could generalize to understand what limit is...
23:18:38 <Cale> magthe: That won't exactly work...
23:18:54 <Cale> magthe: (since you'll hit the '.' over and over then)
23:19:32 <rwbarton> luqui: Limits are easier than adjunctions.  Let me try to explain this example
23:19:40 <luqui> rwbarton, okay, thanks :-)
23:20:03 <rwbarton> luqui: A limit of this diagram is an object x, together with maps from x to every arrow in the diagram, such that any triangles formed commute.
23:20:05 <Cale> magthe: however, if you use  noneOf ".", you can eat characters up to the first '.', and then follow that up with something like liftM2 (:) (char '.') (noneOf ".")  to get the next segment
23:20:31 <rwbarton> luqui: But we don't have any arrows in our diagram     a   b    so we don't have to worry about that last bit.  So it's just an object x with maps x -> a, x -> b.
23:21:02 <rwbarton> luqui: I'll call the maps p : x -> a, q : x -> b.
23:21:16 <luqui> rwbarton, so there are maps ot every arrow and every object?
23:21:36 <rwbarton> luqui: A map to every object, and a commuting triangle for every arrow.
23:21:41 <luqui> oh ok.
23:21:49 <rwbarton> luqui: Sorry, I said arrow above when I meant object
23:21:57 <luqui> was about to ask about that
23:22:37 <luqui> ok, so that's the def. of limit?
23:22:38 <rwbarton> luqui: This objects has to have the following property: if we have any other such object and maps (y, f : y -> a, g : y -> b) then there's a unique map i : y -> x making everything commute.
23:22:51 <rwbarton> s/This objects/This object/
23:23:14 <rwbarton> So, informally, a map y -> x is supposed to be "the same" as a pair of maps y -> a, y -> b.
23:24:10 <magthe> Cale: I created a manyTill1, which solved that particular problem
23:24:12 <rwbarton> ("Everything commutes" means f = p . i, g = q . i.  You should draw a little triangle with y on the left, x in the middle, and a and b on the right)
23:25:03 * luqui gets out his whiteboard :-)
23:25:08 <rwbarton> (If we have the map y -> x, we can compose with p and q to get y -> a and y -> b; and if we have y -> a and y -> b we can get y -> x by the property we required.  That's what "the same" means)
23:25:58 <magthe> Cale: the next problem I have is that I don't really want only 2 (`count 2`), I want all of them but I don't know how many there are... just using `many` results in an error as soon as I hit the end of the string :(
23:26:17 <rwbarton> luqui: I claim that this requirement "more or less" determines what x has to be in terms of a and b... can you see what?
23:26:19 <Cale> liftM2 (:) (many (noneOf ".")) (liftM2 (:) (char '.') (many (noneOf ".")))
23:26:25 <Cale> That should work.
23:26:41 <|Steve|> What does that do?
23:27:04 <|Steve|> Any nonperiods followed by a period followed by a nonperiod?
23:27:24 <|Steve|> or rather followed by any nonperiods.
23:27:28 <magthe> Cale: that'll give me exactly two, right? (Right ["hello",".there"])
23:27:39 <Cale> magthe: no, arbitrarily many
23:27:50 <Cale> Parses "foo.bar.baz" into ["foo",".bar",".baz"]
23:28:07 <luqui> ok drew the diagram and understood it (insofar as I understand diagrams... not used to reasoning with them).
23:28:13 <|Steve|> Wow, that's not obvious at all.
23:28:25 <rwbarton> It'll become more clear once you know what x is.
23:28:39 <|Steve|> x?
23:28:50 <magthe> Cale: thanks, not that I see it ATM though, haha
23:28:59 <luqui> yeah, if x is (a,b), then i y = (f y, g y)
23:29:08 <Cale> magthe: okay...
23:29:26 <Cale> magthe: It might be easier without the monad combinators?
23:29:38 <luqui> (where, er, y :: y)
23:29:39 <|Steve|> Oh, totally unrelated to what I was talking about. =)
23:29:55 <rwbarton> luqui: Exactly right.  So (a, b) is the limit of the diagram we started with.
23:30:14 <luqui> rwbarton, ok cool.  so what is the purpose of a limit; i.e. why is it defined?
23:31:32 <Cale> do xs <- many (noneOf "."); xss <- many (do y <- char '.'; ys <- many (noneOf "."); return (y:ys)); return (xs:xss)
23:31:37 <rwbarton> luqui: Well, if we started with a more complicated diagram, we'd get a more interesting notion of limit.
23:31:52 <rwbarton> luqui: It's hard to give a particular application of the notion of limit, without having a particular application of category theory :)
23:32:09 <luqui> rwbarton, yeah, that's been my problem with category theory in general :-)
23:32:16 <luqui> nothing to hold onto
23:32:42 <rwbarton> luqui: I'll try to give a more interesting example that has to do with the name "limit"
23:32:54 <luqui> ok :-)
23:32:59 <rwbarton> luqui: I want to consider the category whose objects are real numbers
23:33:22 <luqui> and arrows are <=?
23:33:27 <rwbarton> luqui: there is a map a -> b if and only if a <= b, and there's only one such map.  We can compose maps because <= is transitive.
23:33:31 <rwbarton> luqui: yeah
23:34:04 <rwbarton> luqui: Now we could draw a diagram ... -> x_n -> x_{n-1} -> ... -> x_2 -> x_1
23:34:23 <|Steve|> Cale: that makes far more sense. The equality of the two eludes me.
23:34:33 <rwbarton> Let's suppose it is bounded below, i.e., the x_n don't converge to -infinity
23:34:54 <luqui> rwbarton, alright (I can see where this is going :-)
23:34:58 <rwbarton> OK, cool.
23:35:07 <Cale> |Steve|: liftM2 (:) x y = do v <- x; vs <- y; return (v:vs)
23:36:44 <|Steve|> @type liftM2
23:36:45 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:37:07 <rwbarton> luqui: In general, a diagram might not have a limit (e.g., consider an unbounded sequence x_n)
23:37:43 <|Steve|> rwbarton: x_1 -> x_2 -> ... has a limit, no?
23:37:45 <Cale> In general,  liftM2 f x y = do v <- x; w <- y; return (f v w)
23:37:49 <|Steve|> It doesn't have a colimit.
23:37:56 <rwbarton> |Steve|: right.
23:38:06 <luqui> rwbarton, okay, I made an object l and arrows m_n to each x_n.
23:38:22 <luqui> hmm, what does commuitivity mean in this case back in the 'real' world?
23:38:23 <|Steve|> Cale: Okay, I see.
23:38:40 <rwbarton> luqui: It means nothing, because we said there's at most one arrow from any object to any other.
23:38:55 <luqui> oh
23:39:39 <|Steve|> Cale: It still seems like you're missing a many though. You had 2 when you didn't use "do" and you had 3 when you did.
23:39:49 <Cale> mm...
23:39:50 <luqui> oh! so it means that any l' <= all the x_ns is <= l!
23:40:03 <rwbarton> yep.
23:40:10 <luqui> sweetness
23:40:28 <Cale> Ah!
23:40:42 <Cale> I copied the wrong line... sorry magthe!
23:40:55 <Cale> Yeah, there is supposed to be another many in there
23:41:06 <luqui> for some reason I have a lot easier time thinking about categories when the objects are things like real numbers rather than things like groups
23:41:22 <koninkje> Does anyone remember what the name is for the most specific equivalence relation in a system?
23:41:25 <|Steve|> Oh good. I was so confused how you were planning on getting more than 2.
23:41:27 <Philippa> luqui: they feel more concrete
23:41:28 <luqui> could be that my algebra isn't that strong
23:41:31 <Cale> liftM2 (:) (many $ noneOf ".") (many $ liftM2 (:) (char '.') (many $ noneOf "."))
23:41:43 <|Steve|> koninkje: Most specific? Equality?
23:41:48 <rwbarton> luqui: It's certainly good to think about examples of both types.
23:42:10 <rwbarton> luqui: Too often the "concrete" categories aren't mentioned much
23:42:30 <koninkje> |Steve|: no, there's some specific name (named after someone). For when you have many different equivalence relations and need to distinguish them
23:42:38 <|Steve|> rwbarton: They aren't? They seem to be the majority of what one sees at an introductory level.
23:42:56 <koninkje> (including, potentially, many "equalities")
23:42:57 <|Steve|> Set, Grp, Rng, Cat, etc.
23:43:16 <|Steve|> koninkje: I fail to see how that's specific, but clearly I don't understand your question.
23:43:25 <rwbarton> |Steve|: Sorry, maybe I confused you by using the word "concrete".  Pretend I said "small"
23:43:49 <koninkje> |Steve|: no worries, I'm just failing at Google today... :(
23:44:38 <Cale> grr... in the new Parsec, the ParsecT is an instance of Applicative and Alternative, but I still get errors about which 'many' I want when importing both Control.Applicative and Text.ParserCombinators.Parsec
23:44:41 <|Steve|> rwbarton: A concrete category is one that has a forgetful functor to Set. A small category is one whose class of objects is a set.
23:44:51 <rwbarton> |Steve|: Right, I know.  I had to confuse either you or luqui :)
23:45:07 <Cale> It seems that the latter module is re-exporting many with a more restricted type?
23:45:21 <|Steve|> Clearly you know what you're doing so I should just leave you alone. =)
23:45:29 <rwbarton> |Steve|: I meant examples like the reals viewed as a category with their ordering.  I couldn't think of a better word than concrete... suggestions?
23:46:02 <luqui> well, it's a cognitive thing anyway, and I think concrete works in that domain
23:46:09 <luqui> I just think concrete is not a good name in CT :-)
23:46:21 <Cale> luqui: yeah, that word is taken by something else :)
23:46:25 <Philippa> Cale: they're different and you want the parsec version
23:46:30 <luqui> (small makes sense)
23:46:44 <rwbarton> small is a technical term too :)  but at least accurate.
23:46:56 <luqui> but I also have trouble thinking about the category of the set of all consistent theories.
23:47:05 <luqui> if there is one.
23:47:08 <luqui> even though it's small.
23:47:10 <Philippa> the applicative version's only any good if you didn't want some self-analysis, parsec catches many nonConsumingParser and warns you
23:47:47 <Cale> mm... okay
23:47:49 <Philippa> funnily enough I ran into that knocking up an example parsing lib as an extended example for my talk today
23:47:57 <|Steve|> rwbarton: That would be a concrete, small category. I guess I'm not sure what you're saying isn't covered as much.
23:48:21 <|Steve|> No, sorry, what am I saying?
23:48:50 <Cale> Philippa: another problem then is that the Parsec specialisation of many does not seem to appear in the Haddock?
23:48:57 <|Steve|> It's clearly an  abstract  category, just like any preorder category.
23:49:08 <Cale> ah, it's in Prim...
23:49:10 <|Steve|> Hmm, I shouldn't say "any."
23:49:51 <rwbarton> |Steve|: It happens to be concrete, where r |-> (-infinity, r]
23:50:10 <luqui> rwbarton, as long as we're on the subject, what's the formalization of an applicative functor?
23:50:10 <|Steve|> I should stop failing at talking about CT and go do something constructive like read a paper.
23:50:52 <|Steve|> rwbarton: Well, I'd think of it more as the real numbers are the objects rather than associate them with sets and then give arrows a -> b if a <= b.
23:50:55 <rwbarton> luqui: roughly, a functor F with a map FX x FY -> F(X x Y) (if you'll forgive the category-theoretic notation)
23:51:18 <Cale> rwbarton: mm... is that really equivalent?
23:51:20 <|Steve|> Note that the same works for any poset, no need for a total/linear order.
23:51:54 <Cale> Don't you actually want F(Y^X) -> FY^FX
23:52:14 <Cale> +pointed
23:52:28 <luqui> pointed = a -> f a ?
23:52:33 <Cale> yeah
23:52:42 <|Steve|> a -> fa or a |-> fa?
23:52:48 <Cale> That is, there's a natural transformation 1 -> F
23:52:56 <|Steve|> Okay, so the second one.
23:53:04 <rwbarton> Cale: Yeah, but FX x FY -> F(X x Y) is equivalent in a cartesian closed category and more generally useful, so to me it's the category theory analogue
23:53:05 <rivercheng> Hello
23:53:24 <rivercheng> Could I ask a question?
23:53:28 <|Steve|> That's not obvious to me, why would an exponential object be equivalent to a product object?
23:53:31 <Cale> rivercheng: certainly
23:53:31 <|Steve|> Yes, of course.
23:53:36 <|Steve|> Also, why isn't this in #math. =)
23:53:50 <rivercheng> Is Data.Set good to be used to implement a priority queue?
23:53:52 <Cale> |Steve|: because Haskell is about category theory too  :)
23:53:56 <luqui> because we share a common background in haskell that is grounding the discussion?
23:53:58 <rwbarton> |Steve|: What I said shouldn't *quite* be obvious.
23:54:06 <luqui> and folks in #math would confuse us (read: me)
23:54:23 <rwbarton> |Steve|: but it comes from the fact that a map X x Y -> Z is the same as a map X -> Z^Y (currying)
23:54:25 <|Steve|> rwbarton: Not obvious to me doesn't mean nonobvious. =)
23:54:25 <rivercheng> Is there a better candidate in the library?
23:54:43 <Cale> rivercheng: Well, you can get a rather nice priority queue on Hackage.
23:54:51 <Cale> PSQueue
23:55:07 <Pseudonym> PSQueue++
23:55:08 <Cale> (It's actually a priority search queue)
23:55:11 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/PSQueue
23:55:12 <lambdabot> Title: HackageDB: PSQueue-1.0, http://tinyurl.com/56yg73
23:55:21 <rwbarton> |Steve|: No, it's really not obvious.  I spent 20 minutes convincing myself that it was *probably* true :)
23:55:22 <Pseudonym> Oh, is that the Ralf Hinze implementation?
23:55:31 <rivercheng> Cale: Thanks. PSQueue provides O(1) insert O(1) delete-min?
23:55:36 <rwbarton> :t \x y -> (,) <$> x <*> y
23:55:38 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
23:55:39 <Pseudonym> If it's the one from the paper, I think there's a bug in it.
23:55:39 <rivercheng> Thanks all. I will check it
23:55:42 <|Steve|> rwbarton: So some sort of isomorphism Z^(X x Y) =~ (Z^Y)^X or something?
23:55:43 <Pseudonym> But it might have been fixed.
23:56:08 <|Steve|> That actually seems really reasonable.
23:56:15 <Philippa> Cale: ow, hadn't noticed re haddock. Prod ddarius?
23:56:18 <luqui> rivercheng, O(1)!! impossible!
23:56:22 <Cale> rivercheng: logarithmic, but who's counting? :)
23:56:33 <rivercheng> Amortized I mean
23:56:35 <Philippa> anyway, I'm AFKish for a while now
23:56:41 <Cale> Philippa: will do
23:56:51 <luqui> rivercheng, that can't be true either, because then sort would be O(n)
23:56:56 <Pseudonym> http://andrew.bromage.org/darcs/sudoku/ <- Sudoku with PSQueue
23:56:57 <luqui> (i.e. heapsort)
23:56:58 <lambdabot> Title: Index of /darcs/sudoku
23:57:06 <matthew-_> @seen dons
23:57:06 <rivercheng> I see. Thanks
23:57:06 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 2h 14m 37s ago.
23:58:07 <Cale> @tell ddarius The haddock for Text.ParserCombinators.Parsec.Combinator doesn't include the 'many' function like I'd expect it to. (This is in fact documented in .Prim, but...)
23:58:07 <lambdabot> Consider it noted.
23:59:42 * luqui considers learning categorty theory through IRC as his primary means.  so far this has been far more effective than any of the papers/tutorials he's read
