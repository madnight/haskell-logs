00:10:04 * lispy is so sick of type errors at the moment
00:10:21 <ulfdoz> I suggest you just make less of them.
00:15:56 <dancor> break in to parts and get it to incrementally compile
00:39:35 <cjs> Often easier said than done.
00:45:59 <Vq^> but often easier than finding those errors afterwards in a language with weaker type-system
00:47:04 <dons> Don's Rule: 'foldl' only exists to teach us to think about laziness
00:47:30 <dons> it is one of those rare functions that is required to exist, and serves a good purpose, but only by never being used in production.
00:47:30 <cjs> Yes, but in a non-typechecked system, the errors might not manifest themselves when you actually run the program.
00:47:36 <cjs> In other words, you could get lucky.
00:48:04 <cjs> Haskell never lets you get lucky.
00:49:09 * dons listens to a story on the bbc about killing albinos and selling their body parts to witch doctors
00:49:13 <dolio> Why would you want that?
00:49:14 <dons> news you don't hear everyday.
00:49:30 <mapreduce> Haskell lets you get lucky.
00:49:33 <mapreduce> > head []
00:49:38 <cjs> Oh, right.
00:49:39 <mapreduce> Terminated
00:49:39 <dons> Cale, i want a lambdabot.
00:49:41 <cjs> I always hated that one.
00:49:43 <dolio> That just means it'll blow up later when someone actually does the thing that gets handled wrongly.
00:50:10 <cjs> dolio: Yes, but by then, I'm hoping it won't be my problem any more.
00:50:18 <dolio> Heh. :)
00:50:36 <cjs> That's what I like about Ruby: "Trust in fate."
00:50:50 <cjs> Hm. When I put it like that, it doesn't seem so good any more.
00:50:59 <mapreduce> It is true that you have to have a lot of trust to program.
00:51:17 <Wild_Cat> yeah, Python's better than Ruby in that respect: "Join me. I am your father."
00:51:27 <cjs> Ah. It's just the wrong quote. We need something that makes it look more powerful.
00:51:28 <dolio> Nah, Ruby is: "rewrite all the checks a type system would help with manually with unit tests." :)
00:51:32 <cjs> How about: "Do you feel lucky?"
00:51:41 <mapreduce> Unless you invent your own hardware, etc.  But when you do that, make sure you invent your own atoms, etc., because the current ones have some unknown properties.
00:52:02 <Wild_Cat> or, in the words of the Ankh-Morpork Night Watch's motto: Fabricati diem, pvnc.
00:53:15 <mapreduce> But having to have a lot of trust doesn't mean that you should place trust in code unnecessarily.  It's like saying "I have to drive to work each morning, so I'll drive to the shop around the corner too, for consistency".
00:53:24 * mapreduce slinks back into the shadows.
00:55:19 <dons> we should push for a derivable 'rnf' eh?
00:55:26 <dons> like the old Eval class, for seq,
01:00:41 <sjanssen> dons: I think we need a way to extend the set of derivable classes
01:01:07 <sjanssen> (ideally it wouldn't require a separate preprocessor like drift)
01:01:39 <dons> mm
01:01:43 <dons> deriving scripts for ghc? :)
01:01:49 <dons> oh, i know, macros!
01:02:15 <sjanssen> perhaps a little TH hook
01:03:29 <dons> yeah, a TH-only library
01:03:36 <dons> then you import the $(derive foo)
01:04:32 <sjanssen> except $(derive foo) is ugly
01:08:58 <lispy> dancor: oh, I'm adding types in that weren't there before...so breaking it into pieces and doing in incrementally are much harder than it sounds
01:09:10 <lispy> it's very tiring work
01:09:15 <cjs> Aw! "cannot mix `(=<<)' [infixr 1] and `(>>)' [infixl 1] in the same infix expression"
01:10:17 <lispy> Would "after the fact" derivables weaken the type saftey?
01:10:30 <dons> lispy, you're now a "proof engineer"
01:10:39 <lispy> dons: omg, shoot me! :)
01:10:54 <dons> when types are sufficiently complex, you actually need to bring some engineering discipling to the task. modularity, separation, namespaces et al.
01:11:05 <dons> (we had a "proof engineering" talk at work today)
01:11:10 <lispy> heh
01:11:21 <lispy> We need a type inference/check visualizer
01:11:29 <lispy> That's my next project
01:11:35 <lispy> But, it should have been my first
01:12:13 <lispy> I'm convinced that sometimes if I could just "see" what the type checker is doing, I wouldn't be going batshit crazy.
01:13:33 <cjs> Switch to Ruby!
01:13:48 <dons> you clearly need reflection in the type system
01:13:53 <dons> so you can monkey patch it with agile methods
01:13:59 <dons> to fix up those cross cutting concerns
01:15:51 <cjs> Hm. I seem to be writing about one unit test per 30 lines of code in my current project.
01:16:02 <Wild_Cat> no, you don't fix up cross-cutting concerns. You leverage b2b synergies to utilize them in an out-of-the-box, forward thinking manner.
01:16:14 <cjs> And don't forget to use XML.
01:16:20 <dons> using QC?
01:16:33 <Japsu> enterprise haskellbeans
01:16:35 <dons> Wild_Cat: i'm in agreement going forward with you on this.
01:17:42 <Wild_Cat> dons: good. Can we touch base to ensure our new Enterprise Monad Beans will be win-win value proposals?
01:17:49 <zi> How would you count the number of lines from input?
01:18:30 <dons> zi: main = print . length . lines =<< getContents
01:18:38 <lispy> dons: heh, I'd rather have transparency than reflection
01:18:51 <dons> i'd rather have side effects than transparency
01:18:57 <dons> check that!
01:19:07 <zi> dons: gg
01:19:10 <lispy> side effects in the ... type system?
01:19:19 <lispy> that sounds....omg
01:19:20 <lispy> evil
01:19:28 <dons> that modify the types that are inferred, whatnot?
01:19:38 <lispy> Actually, it sounds like prototype based OO in javascript
01:19:53 <lispy> Hmm...
01:19:59 <lispy> Are you being serious?
01:20:48 <lispy> I have a way to use unsafeCoerce# that can make two types equal.  But everytime I turn around I find a new way to combine that with phantom times in such a way that you can rewrite unsafeCoerce#
01:21:38 <dons> i suppose people use side effects in Prolog
01:21:41 <dons> so there are uses.
01:21:46 <dons> `cut` for the type system?
01:22:00 <dons> Wild_Cat: let me do a root-and-branch investigation of the matter.
01:22:25 * Japsu is planning a Haskellspeak generator
01:22:42 <Japsu> with a 15% probability of adding co- in front of ANY word.
01:22:54 <lispy> Joking aside, are agile methods themselves so bad?  Don't they advocate things like TDD taht are pretty much considered good?
01:23:08 <dons> Japsu: that would be fun.
01:23:17 <dons> lispy, yep.
01:23:26 <Wild_Cat> agile methods are pretty good IMO. I love XP principles.
01:23:38 <dons> the buzzwords are amusing though.
01:23:43 <lispy> indeed
01:23:46 <dons> and now they're retro buzzwords!
01:23:55 <dons> it's like straight out of 2003.
01:23:56 <lispy> that synergistic fusion is great!
01:23:56 <Wild_Cat> the problem is that nobody in management understands them, so they just lift buzzwords left and right and try to shoehorn them into a waterfall method.
01:24:22 <newsham> unsafeLiftBuzzword
01:24:43 <lispy> unsafeLiftBuzzword :: Buzzword -> a
01:24:57 <mapreduce> What a first-class proposal.  Let's action it at once!
01:25:10 <Wild_Cat> "yeah, let's do XP! Oh, but we don't have time to write tests, we need features instead. No, you'll refactor later, we need new features. No, you'll debug later, we need new features. We don't give a damn about user feedback, just give us new features! Yeah, we're doing XP."
01:25:28 <Wild_Cat> "...as in, Windows XP."
01:25:32 <lispy> lol
01:25:40 <Japsu> Wild_Cat: that sounds just like my current job
01:26:09 <lispy> My current job is one step worse...we don't need new features, we just need to ship.
01:26:17 <Japsu> well, my job current until tomorrow
01:26:36 <Japsu> the semester is starting so I'm returning to Tampere Univ. of Tech.
01:26:41 <Wild_Cat> Japsu: sounds like so many jobs :p
01:26:50 <mapreduce> "We do Agile here" I was told in my last interview.  I thought, great, religious loonies, but at least they'll have some unit tests.  Reality: "We don't do Agile, but when you start, you will!".
01:27:03 <mapreduce> Sadly, I didn't realise that reality until taking the job.
01:27:06 <newsham> http://www.ddj.com/hpc-high-performance-computing/210200736?cid=RSSfeed_DDJ_All
01:27:39 <lispy> haskell program coverage in dr dobbs?
01:27:46 <mapreduce> Next time I will ask for their average ratio of code lines to test lines.  It would have been 1000000:100 here.
01:27:56 <newsham> no, not directly haskell related
01:28:52 <lispy> mapreduce: IMO, the most important thing is to get on with a good team.  The rest is deatils.
01:28:52 <newsham> just possibly really really important
01:29:47 <zi> could you do something like this for line counting? byLines :: String -> Int
01:29:52 <zi> and then
01:30:17 <zi> byLines g = lines g
01:30:21 <lispy> ?djinn String -> Int
01:30:43 <Japsu> > read "5" :: Int
01:31:06 <lispy> zi: byLines has the same type as lines if you did that
01:31:19 <lispy> :t lines
01:31:22 <lispy> ?bot
01:31:39 <Japsu> countLines = lines >>> length
01:33:28 <Adamant> newsham: really cool!
01:35:29 <Adamant> I'm doing a software engineering class right now. The book is based on RUP, except the writer more or less tells you to throw certain things out, add in other things, and then adopt a grabbag approach to how much process you adopt based on project size.
01:36:14 <Wild_Cat> RUP is basically Enterprise Agile Beans. Yes, it *does* defeat the point.
01:36:31 <Adamant> I have severe prejudices against RUP but this seemed pretty sane.
01:37:05 <Wild_Cat> and it's aimed at selling you a lot of Rational Software's Enterprise-class, Java software. As in, say, XDE instead of post-it notes for UML diagrams.
01:37:23 <Adamant> Wild_Cat: he's not particularly trying to sell software or UML as executable or anything like that
01:37:38 <Wild_Cat> but the "grabbag approach" advice is sane indeed. Works for any methodology, mind ;)
01:37:49 <Adamant> but yeah
01:37:57 <Adamant> in the general case you have a point
01:38:37 <Adamant> anyway, when I heard RUP I thought it would be rubbish, but it's actually been half-decent so far
01:39:01 <Wild_Cat> it's at least much better than waterfall. Anything's better than waterfall.
01:39:11 <Adamant> yes, everyone hates waterfall
01:39:31 <Wild_Cat> everyone except management, sadly.
01:39:32 <Adamant> I wonder if it will ever get any traction again for some reason
01:39:46 <Adamant> well waterfall is perfect for management and horrible for everyone else
01:39:55 <Wild_Cat> http://www.waterfall2006.com/
01:41:05 <Adamant> Waterfall 2008 - why vote for lesser evils like Cthulu?
01:42:40 <Adamant> anyway
01:42:49 <Adamant> this dicussion need more monad
01:44:31 <kaol> return $ discussion
01:45:04 <binrapt> Dirty IO
01:57:45 <thomashartman1> I'm on ubuntu, ghc 6.8.3. How do I build local documentationI'm on ubuntu, ghc 6.8.3. How do I build local documentation that matches what I see at http://www.haskell.org/ghc/docs/latest/html/libraries/ ? When I go to file:///usr/share/doc/ghc6-doc/libraries/index.html to browse local docu, I am missing for example Control.Monad.Error.
01:57:59 <thomashartman1> shit bad copy/paste
01:58:12 <thomashartman1> but I think my question still got across
02:13:38 <osfameron> does anyone know how banks store user passwords: of the type "Please tell us the 1st and 3rd character of your password" ?
02:13:47 <osfameron> I'm guessing many of them just store it in plaintext
02:14:25 <osfameron> but is there some kind of datastructure (bloom filter came to mind, but I'm sure that's not right) that allows the password to be encrypted, but still queried for X characters in it
02:16:54 <otsdr> having a structure like that would allow an attacker to guess the password
02:17:17 <quicksilver> osfameron: I can't think of any structure which wouldn't make dictionary attacks / rainbow table type things rather easy.
02:19:30 <osfameron> ok.  assuming they can get hold of the db, the fact that only 2 characters are needed does make a dictionary attack easier
02:19:37 <osfameron> but they have to store it *somehow*
02:19:52 <quicksilver> well like you said, I suspect they store it plaintext.
02:19:55 <otsdr> they can brute force 2 characters at a time
02:19:56 <osfameron> and there must surely be some better alternative to plaintext?
02:20:01 <otsdr> no need for dicts
02:20:12 <quicksilver> osfameron: well, they'll store it two-way encrypted.
02:20:28 <quicksilver> osfameron: and they'll have all kinds of documents about how securely they keep their keys.
02:20:42 <osfameron> ok
02:20:48 <quicksilver> according to some points of view two-way encryption is 'no better than' plaintext :)
02:20:56 <osfameron> indeed
02:21:15 <quicksilver> but it is sufficient to pass various official security certificates.
02:21:18 <osfameron> though it means that simple access to the db is safe, you have to break in precisely in the application layer
02:21:41 <otsdr> it's safe to assume that if the db is compromised, then the keys used in the encription will be compromised sooner or later
02:21:54 <otsdr> the attacker gains "admin" access to the app
02:22:04 <osfameron> note that if the key was hashed as "char@X AND char@y" then just having got 1 of the combinations by brute force doesn't mean that the attacker can reliably log into the application later
02:22:13 <osfameron> as the application will ask for random X and Y positions
02:22:34 <cjs> Gah. My functional programming group meeting starts in an hour, and I have no idea what to do for a presentation.
02:22:57 <quicksilver> cjs: unicycling demonstrationg.
02:23:32 <cjs> Err....yeah, right.
02:23:50 <otsdr> I thought the idea was that you already have the database :). Brute forcing through the app ui is pretty time consuming
02:24:23 <otsdr> and most apps have an accound lockdown policy
02:24:30 <otsdr> *account
02:26:31 <osfameron> ok, so you'd need to db, and brute forcing all combinations of an entry that contained all pairs of characters encrypted is still easier than brute forcing the password all at once
02:26:43 <otsdr> yes
02:26:47 <osfameron> fair enough
02:26:49 <osfameron> thanks :-)
02:26:56 <otsdr> :)
02:27:23 <osfameron> we were discussing this story from yesterday - http://news.bbc.co.uk/1/hi/england/shropshire/7585098.stm - and were wondering how the bank stored the passwords
02:27:37 <osfameron> the fact that an employee could see what his was does imply bad things on the application side...
02:27:48 <dreixel> but those are passwords for telephone banking
02:27:54 <quicksilver> osfameron: well also once you've got one pair, the next ones are easier.
02:27:55 <dreixel> right?
02:27:56 <BeelsebobWork_> osfameron: it's a voice password
02:27:59 <BeelsebobWork_> how else do you do it?
02:28:05 <dreixel> they have to be plaintext.
02:28:05 <osfameron> quicksilver: yeah
02:28:16 <quicksilver> osfameron: because you always have one already. Much easier.
02:28:20 <osfameron> indeed
02:28:26 <quicksilver> my bank uses triples: brute-forcing every triple woudl be harder.
02:28:40 <quicksilver> but, I bet that someone who spent a while thinking about it could devise something clever
02:28:41 <Adamant> hash things or don't bother.
02:28:43 <quicksilver> (based on the hash)
02:28:56 <quicksilver> because I bet correlations start to show once you hash every triple
02:29:04 <osfameron> but again, once you've got one triple, every other character is just a linear search rather than combinatorial
02:29:15 <BeelsebobWork_> Adamant: how are you meant to guarentee that the operators can all (a) spell (b) capitalise correctly (c) put apostrophies in the same place
02:29:19 <BeelsebobWork_> this is a voice password
02:29:26 <BeelsebobWork_> not something that can easily be hashed
02:29:40 <osfameron> ah, true
02:29:41 <Adamant> just saw the voice password bit
02:29:53 <ejt> presumably voice gets converted to some phoneme sequence though ?
02:29:56 <osfameron> I was thinking of my mobile phone password with is 4-8 characters and you have to spell it
02:29:56 <Adamant> I thought this was a regular password
02:30:49 <osfameron> yeah, my question was about regular passwords
02:31:01 <osfameron> but the story does look like maybe that password isn't one of those, now that you mention it
02:31:29 <otsdr> it's a text one
02:31:50 <otsdr> he told the password to the operator, who checked it on his screen
02:32:00 <otsdr> no audio processing involved
02:32:04 <otsdr> I guess
02:32:15 <quicksilver> I'm sure you're right.
02:32:16 <dreixel> yes
02:32:23 <dreixel> it's a text password used for telephone banking
02:32:28 <dreixel> so you have to say it to an operator
02:33:08 <Adamant> yeah, I don't see how you could store that encrypted then
02:33:20 <Adamant> well
02:33:53 <Adamant> you could have a hash of the phrase and then hash the password someone just told you over the phone
02:34:06 <Adamant> and compare
02:34:16 <quicksilver> they may well store it 2-way encrypted
02:34:24 <quicksilver> and decrypt it when the phone operator asks for it.
02:34:25 <otsdr> add a bit of salt also :P
02:34:26 <Adamant> but then you have BeelsebobWork_'s problems
02:34:58 <BeelsebobWork_> syphilis?
02:35:21 <BeelsebobWork_> poor Malcolm -- that probably wasn't the best time to join the channel
02:35:31 <Adamant> I though you had the good clap
02:35:52 <malcolmw> the one-hand clap?
02:37:16 <BeelsebobWork_> in the mean time... why the crap does (hang `race` (threadDelay 10 >> return True)) terminate, but not ((myPotentiallyLongComputation) `race` (threadDelay 10 >> return True))
02:37:49 <quicksilver> what are the definitions of 'hang' and 'race' ?
02:40:41 <BeelsebobWork_> http://hpaste.org/9977
02:41:44 <cjs> command line parsing always seems to be such a PITA in Haskell.
02:41:59 <BeelsebobWork_> cjs: hm? I find it much easier than in most languages
02:42:21 <BeelsebobWork_> in the simple case it's just a map from String -> Option, in the difficult case, just a foldl
02:43:21 <sjanssen> BeelsebobWork_: killThread is a blocking operation
02:43:39 <BeelsebobWork_> sjanssen: hmm?
02:43:49 <BeelsebobWork_> i.e. it waits until the thread blocks to kill it?
02:43:56 <Twey> BeelsebobWork_: Mmmmmmm
02:44:03 <sjanssen> BeelsebobWork_: so myPotentiallyLongComputation is in a foreign call, or is blocking exceptions
02:44:22 <Twey> GetOpt takes up something like half my Main module :)
02:44:25 <sjanssen> BeelsebobWork_: killThread doesn't return until the killed thread receives the exception
02:45:49 <sjanssen> BeelsebobWork_: and threads don't receive exceptions in two situations: FFI calls and when exceptions are being blocked by Control.Exception.block
02:46:06 <quicksilver> BeelsebobWork_: in other news, you don't need "lock".
02:46:16 <quicksilver> BeelsebobWork_: "v" can double up easily enough as your lock.
02:46:29 <BeelsebobWork_> sjanssen: hmm, so is there any way to kill a thread that will *never* block -- but instead is just doing an infinite computation
02:46:47 <quicksilver> BeelsebobWork_: you misunderstand, I think.
02:47:04 <sjanssen> BeelsebobWork_: oh, and a thread can potentially block the entire runtime if it is in a tight loop doing no allocation
02:47:07 <BeelsebobWork_> well, I'm assuming taht a thread can only recive the kill when it's sleaping?
02:47:12 <quicksilver> BeelsebobWork_: no.
02:47:18 <BeelsebobWork_> sjanssen: yep, that sounds pretty much what's happening
02:47:37 <BeelsebobWork_> the pottentiallyLongComputation does nothing but check a property of it's input (which is already allocated)
02:47:41 <quicksilver> it can receive the thread at any context switch (and probably other occasions)
02:48:19 <quicksilver> but if it doesn't allocate memory it may not receive the exception. or if exceptions are disabled, or if it's in FFI.
02:48:26 <quicksilver> I would just make your killThread async.
02:48:35 <BeelsebobWork_> well, exceptions aren't disabled (that I know of)
02:48:39 <BeelsebobWork_> and it's deff not FFI
02:48:47 <sjanssen> but even that won't work if GHC runs out of available capabilities
02:48:48 <BeelsebobWork_> quicksilver: hmm? how would I go about that?
02:48:56 <quicksilver> forkIO (killThread tid)
02:48:57 * BeelsebobWork_ is naïve with these things and looking at conal code
02:49:08 <BeelsebobWork_> oh, okay, yeh, that makes sense
02:49:16 <BeelsebobWork_> so that potentially leaves threads hanging about
02:49:21 <BeelsebobWork_> waiting to be killed
02:49:27 <quicksilver> but, that doesn't matter particularly.
02:49:30 <BeelsebobWork_> but will at least always terminate
02:49:44 <quicksilver> as soon as it does anything which consumes resources it probably becomes eligible to collect the exception.
02:49:59 <sjanssen> BeelsebobWork_: well, you'll still have problems if GHC runs out of capabilities to run your threads on
02:49:59 <quicksilver> if it's blocked on an MVar or similar then it might get GCed anyway.
02:50:31 <BeelsebobWork_> quicksilver: hmm, nope, that's not it -- after making that change, it still blocks indefinately
02:50:38 <BeelsebobWork_> or sorry, it doesn't block
02:50:44 <BeelsebobWork_> it is actually consuming resources slowly
02:50:55 <BeelsebobWork_> it's at 100% CPU and leaking like a sive in fact
02:51:22 <quicksilver> hmm.
02:51:45 <quicksilver> what kind of thing is the potentially long computation doing?
02:51:54 <quicksilver> if it involves FFI you do need to compile with -threaded
02:52:07 <BeelsebobWork_> it's a quickcheck property -- it's stepping down an Event making sure it's monotone all the way
02:52:15 <BeelsebobWork_> it just happens that said Event is infinite
02:52:47 <BeelsebobWork_> so the idea here is that if the test hasn't failed after 10us, I assume it isn't going to
02:52:54 <BeelsebobWork_> (dodgy, I know)
02:53:34 <quicksilver> that sounds like the kind of thing which would allocate lots of memory and thus be available for context switches
02:53:35 <sjanssen> "hang = unsafePerformIO hangIO
02:53:38 <quicksilver> and killing.
02:53:39 <sjanssen> that is scary
02:53:55 <quicksilver> maybe there is something scary about the 'Event'
02:53:58 <BeelsebobWork_> sjanssen: fairly -- but it seems safe to me
02:54:04 <BeelsebobWork_> in that you'll never get a value back from it
02:54:09 <BeelsebobWork_> so it can't have it's value cached
02:54:32 <BeelsebobWork_> quicksilver: nothing more scary than the standard reactive definition for Event
02:54:39 <BeelsebobWork_> (which is fairly scary I'll admit)
02:54:59 <sjanssen> this "race
02:55:00 <quicksilver> right. Conal does lots of weirdness hiding operational semantics in pure values.
02:55:05 <sjanssen> " seems needlessly complicated
02:55:06 <quicksilver> I don't have the paper open in front of me.
02:55:18 <quicksilver> I can't remember how scary Event is ;)
02:55:26 <BeelsebobWork_> quicksilver: nah, all the wierdness is hidden in this race operator
02:59:00 <sjanssen> oops
02:59:23 <sjanssen> http://hpaste.org/9977#a2
02:59:31 <sjanssen> BeelsebobWork_, quicksilver: how does that look?
03:01:03 <quicksilver> sjanssen: certainly looks simpler to me :)
03:01:33 <BeelsebobWork_> sjanssen: that looks nice, let me plug it in and see what happens
03:02:30 <BeelsebobWork_> sjanssen: is it okay to kill a thread that's already dead?
03:02:54 <sjanssen> I think so
03:02:59 <sjanssen> you should probably double check that
03:03:24 <BeelsebobWork_> also, that seems to have the same semantics as the current one -- it is doing the infinite computation, not the slow computation of True
03:03:33 <quicksilver> the worst that could happen is the killer gets an exception.
03:03:35 <quicksilver> no problem there.
03:03:40 <quicksilver> BeelsebobWork_: are you compiling with -threaded?
03:03:58 <BeelsebobWork_> quicksilver: nope, running in ghci
03:04:04 <sjanssen> ghci is threaded
03:04:15 <BeelsebobWork_> quicksilver: that is a problem
03:04:19 <quicksilver> ghci uses the threaded RTS, yes
03:04:24 <BeelsebobWork_> if ta wins, you'll get an exception killing it
03:04:25 <sjanssen> but it can also have weird interactions with threads
03:04:32 <BeelsebobWork_> and then tb won't get killed
03:04:45 <sjanssen> yes, that would be a problem
03:04:47 <quicksilver> BeelsebobWork_: oh yeah. Good point. Well still I don't hink it's an exception.
03:05:04 <BeelsebobWork_> I'll do a quick check on that
03:05:27 <quicksilver>  tid <- forkIO (putStrLn "Hello world")
03:05:34 <quicksilver> followed by 'killThread tid'
03:05:36 <quicksilver> works fine for me.
03:05:39 <quicksilver> (in ghci)
03:05:47 <quicksilver> BeelsebobWork_: try compilnig your program out of interest.
03:05:59 <quicksilver> to eliminate the possibility that this is ghci weirdness.
03:06:07 <BeelsebobWork_> quicksilver: it's hard to do this compiled
03:06:15 <BeelsebobWork_> because I'm calling quickCheck tests
03:06:32 <BeelsebobWork_> let me write a little test program though
03:06:35 <quicksilver> surely you can write a stub main.hs with main = {- whatever you type in ghci -}
03:06:35 <quicksilver> ;)
03:08:25 <sjanssen> here is a puzzle: what is the difference between hangIO and hang :: IO a?
03:08:42 <BeelsebobWork_> sjanssen: yeh, we already puzzled that
03:08:48 <BeelsebobWork_> one is the IO action that hangs indeffinately
03:08:56 <sjanssen> hang is evil
03:09:03 <BeelsebobWork_> the other is an IO action that hangs indeffinately trying to produce an IO action that hangs indeffinately
03:09:06 <BeelsebobWork_> yes, yes it is
03:09:16 <BeelsebobWork_> you suggested it though :P :D
03:09:23 <sjanssen> ?
03:09:30 <BeelsebobWork_> look at the comments in hangIO
03:09:35 <sjanssen> oh, hangIO
03:09:47 <sjanssen> I would never think to suggest the unsafePerformIO variant
03:09:58 <BeelsebobWork_> why not?
03:10:00 <BeelsebobWork_> it's a pure computation
03:10:03 <BeelsebobWork_> it always has the same result
03:10:13 <sjanssen> attaching such operational semantics to a forall a. a value scares me
03:10:24 <conal> *all* functionality in haskell uses unsafePerformIO, except for IO
03:10:44 <sjanssen> it might be perfectly reasonable, but it confuses me
03:11:08 <BeelsebobWork_> okay, compiled, it has the same behavior, both with and without -threaded
03:11:19 <BeelsebobWork_> except that line buffering gets a bit buggered up
03:12:08 <BeelsebobWork_> note to self -- kill it fast
03:12:17 <BeelsebobWork_> it got to using 5.93GB of RAM
03:12:27 <BeelsebobWork_> and really didn't want to give any physical RAM to processes trying to kill it
03:13:49 <conal> btw, hang is useful as the left and right identity of unamb, which is also commutative and associative (assuming the compatibility precondition)
03:14:31 <conal> hang is semantically equal to bottom, but it complains less
03:14:38 <conal> s/bottom/undefined
03:14:58 <cjs> No, I mean dealing with issues like, "this subcommand must include one and only one of the -d or -f options."
03:15:14 <conal> (at least that was my intention)
03:15:15 <BeelsebobWork_> cjs: just nub it then
03:15:41 <quicksilver> BeelsebobWork_: I can't explain that.
03:15:47 <cjs> Well, the idea is that if I get both, I produce an appropriate error message rather than randomly pick one to use.
03:15:48 <quicksilver> BeelsebobWork_: sounds almost like an RTS bug.
03:16:00 <BeelsebobWork_> I'll play with other infinite computations
03:16:02 <sjanssen> BeelsebobWork_: what is the expression we're testing again?
03:16:10 <BeelsebobWork_> see if I can figure out exactly what it is that triggers it
03:16:25 <BeelsebobWork_> monotoneTest f e = unsafePerformIO (       (return (isMonotoneE . f $ e))
03:16:25 <BeelsebobWork_>                                     `race` slowTrue)
03:16:46 <BeelsebobWork_> where isMonotoneE tests if an Event is monotone
03:16:58 <BeelsebobWork_> and e is an infinite event
03:17:03 <BeelsebobWork_> as is f $ e
03:17:10 <sjanssen> BeelsebobWork_: we've found your problem
03:17:15 <BeelsebobWork_> oh?
03:17:19 <sjanssen> BeelsebobWork_: return does not evaluate its argument
03:17:44 * quicksilver slaps BeelsebobWork_ with a trout
03:17:49 <BeelsebobWork_> oh, so the IO action happens on the main thread
03:17:50 <BeelsebobWork_> arses
03:18:25 <quicksilver> is the type of "isMonotoneE . f $ e" Bool?
03:18:35 <BeelsebobWork_> quicksilver: yes
03:18:47 <quicksilver> then in this case return $! should be sufficient.
03:19:05 <conal> that's why amb uses evaluate
03:19:18 * quicksilver doesn't like evaluate.
03:19:25 * BeelsebobWork_ doesn't like $!
03:19:38 * conal doesn't like imperative programming 
03:19:40 <quicksilver> use `seq` then.
03:20:04 <conal> (since we're whining)
03:20:20 <sjanssen> conal: it seems like you're pretending to program in a strict language
03:21:04 <quicksilver> conal: my intention isn't to whine. My intention is to express the opinion that evaluate confuses people and seq is easier to explain.
03:21:35 <sjanssen> we're talking about Control.Exception.evaluate, right?
03:21:50 * quicksilver nods
03:22:36 <sjanssen> I don't see how it is hard to explain: evaluate this value to WHNF (just as seq does) here and now
03:23:08 <quicksilver> in my experience people expect evaluate to be magic
03:23:22 <sjanssen> I suppose that is true
03:23:22 <quicksilver> they expect it to inspect the value and do magically what they meant.
03:23:38 <quicksilver> (often that means they expect full NF instead of WHNF)
03:23:45 <sjanssen> that's only because the name "seq" means exactly nothing
03:23:58 <quicksilver> I just think that if you're going to explain a strictness concept
03:24:04 <quicksilver> you might as well ust explain one, and use it everywhere
03:24:12 <quicksilver> and that one might as well be 'seq' since it's more general.
03:24:25 <quicksilver> (unless there is something you can do with evaluate that you can't do with seq that I haven't thoguht of?)
03:24:30 <sjanssen> but seq and evaluate are different!
03:25:18 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7
03:26:23 <quicksilver> sjanssen: I know they're different, but is there anything important you can do with evaluate you can't do with seq?
03:26:39 <quicksilver> sjanssen: (furthermore there was a mailing list post which appeared to conclude that the spec for evaluate is buggy, anyway)
03:27:43 <conal> i'd be happy to switch from evaluate to seq
03:28:15 <conal> i just want whnf
03:28:38 <sjanssen> quicksilver: return $! _|_ == _|_
03:28:46 <sjanssen> quicksilver: evaluate _|_ /= _|_
03:29:21 <quicksilver> sjanssen: I know.
03:29:30 <quicksilver> sjanssen: that's not what I asked though, is it?
03:29:42 <quicksilver> when does that matter? why would you care?
03:30:22 <sjanssen> from my point of view, evaluate turns a _|_ into a proper IO action that throws an exception
03:30:39 * quicksilver nods.
03:30:44 <sjanssen> note that _|_ is not an exception in Haskell '98
03:31:54 <cjs> Is there some sort of parsec-like combinator library for parsing command line options?
03:32:27 <osfameron> isn't there a getopt style module already on hackage?
03:32:42 <cjs> Yeah, but I've never found it very nice to use.
03:32:54 <osfameron> ah
03:33:18 <quicksilver> there is a getopt module in the libraries distributed with GHC, indeed.
03:33:29 <quicksilver> it seems quite nice to me, once you get the hang of it.
03:34:10 <quicksilver> as mauke said the other day "I once tried to write a brand new haskell-like GetOpt library which would be much better; but once I finished designing the API I realised it was the same"
03:35:37 <osfameron> heh
03:35:49 <osfameron> sometimes you have to try reinventing the wheel to realise how good the current one is
03:38:20 <yitz> @bots
03:38:39 <yitz> preflex list
03:38:39 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
03:47:27 <dolio> Do global variables with unsafePerformIO really get used all the time?
03:47:59 <quicksilver> no
03:48:01 <quicksilver> almost never.
03:48:14 <quicksilver> Bulat's opinion diverges completely from my experience of haskell programming.
03:48:34 <dolio> Not just him.
03:48:44 <quicksilver> they are used a few times in the standard libraries but I consider that almost forgivable since one of the things the standard libraries do is "define" the IO monad
03:48:46 <dolio> But that whole discussion seems to take for granted that they're used all over the place.
03:49:03 <quicksilver> so "adding things on to" the IO monad's implicit state seems like somethign the standard libs might reasonably do.
03:49:26 <quicksilver> however adding things onto the IO monad's implicit state is a very poor idea for a re-usable library because it's non compositional.
03:49:37 <dolio> Yeah.
03:49:50 <quicksilver> also dcoutts' point about "what do you mean by global?"
03:50:01 <quicksilver> (I haven't read the whole thread, I mean his first message)
03:50:21 <dolio> I've only skimmed it.
03:50:32 <quicksilver> should we exlucde the possibility of a "haskell application server" which runs multiple haskell programs in the same RTS
03:50:37 <quicksilver> (ghci is one example of such a thing)
03:50:58 <dcoutts> quicksilver: happs has this bug because it uses 'global' vars
03:50:58 <quicksilver> if we don't exclude that possibility then this idea is very harmful, because the multiple programs collide on these global-variables.
03:51:11 <quicksilver> dcoutts: I didn't know that but I'm not surprised.
03:51:43 <dcoutts> quicksilver: specifically happs data, only one instance of each data component per process (modulo linking issues)
03:52:08 * quicksilver nods.
03:52:39 <dolio> Haskell is in bad shape this week, I guess.
03:52:47 <dolio> unsafePerformIO all over the place.
03:52:56 <dolio> nub ruining performance of all kinds of programs.
03:53:19 <quicksilver> the issue with the global vars thing seems to be one of these unresolvable standoffs.
03:53:33 <quicksilver> there is an obvious solution which doesn't involve any such contortion
03:53:40 <quicksilver> which is explicit calling of library init functions
03:53:45 <quicksilver> (which return a token, or similar).
03:53:58 <quicksilver> you can encode that into monad type classes which then form a capabilities functions.
03:54:03 <dolio> I think the position that parameterized, first-class modules solve most of the problems there has some promise.
03:54:08 <quicksilver> to my mind, that's much more elegant.
03:54:18 <quicksilver> however, to the opposing view that is a clumsy hack
03:54:24 <quicksilver> and global variables are elegant.
03:54:41 <quicksilver> so it's my opinion of what is "clumsy" vs "elegant"
03:54:44 <quicksilver> against someone elses.
03:54:55 <quicksilver> my version doesn't involve changing compilers, which seems like a good thing to me ;)
03:55:01 <dolio> :)
03:55:01 <quicksilver> but the other side doesn't accept that view.
03:55:13 <quicksilver> dolio: the first-class modules solution is also interesting.
03:55:19 <quicksilver> of course that doesn't exist yet and needs writing ;)
03:55:30 <dolio> Details, details. :)
03:55:32 <quicksilver> but superficially it appears to solve the problem.
03:56:19 <quicksilver> dolio: the other surprising thing about this debate is how much heat it generates.
03:56:30 <quicksilver> dolio: haskell-cafe is normally not known for such heat.
03:56:39 <quicksilver> I remember last time it came up.
03:56:41 <dolio> Yeah.
03:56:57 <quicksilver> the first time I saw the debate I believe I entered on the ACIO side and came out convinced against it.
03:57:03 <quicksilver> I've not seen anything since to convince me back.
03:57:35 <quicksilver> However, it is interesting that JM decided to implement it. I instinctively respect things that JM has blessed ;)
03:59:50 <yitz> dolio: global state is not used that often. neither is runCommand - but that doesn't mean we can just omit it from Haskell. It's essential, and so is global state.
04:00:02 <dolio> I'm not sure I've seen an explanation of what ACIO actually is in the cafe thread.
04:01:21 <sjanssen> runCommand doesn't have the implications that global mutable state does, hardly a fair comparison
04:01:42 <Beelsebob> sjanssen: quicksilver: thanks btw, was very useful
04:01:52 <yitz> sjanssen: runCommand "rm -rf /"
04:01:54 <Beelsebob> I just got embedded in making it do interesting stuff after it suddenly worked
04:02:26 <quicksilver> Beelsebob: \o/
04:03:00 <quicksilver> yitz: there is no consensus that global state is essential.
04:04:42 <yitz> quicksilver: there are definitely situations which it would be a show-stopper for a project if it's not available.
04:05:38 <yitz> I'm just amazed that people say things like "tell them to fix those C libraries". I thought Haskell got past the windmill-jousting days a long time ago.
04:05:42 <sjanssen> yitz: you keep saying this, but it isn't really true
04:05:44 <quicksilver> I've never found that nor had it demonstrated to me.
04:07:43 <sjanssen> yitz: the lack of global mutable variables has actually stopped you from writing a program?
04:09:00 <yitz> ok. it goes like this: In a professional development environment. you have to follow procedures and protocols from outside your group. Sometimes, for various reasons, you just can't change the API, or you just can't change certain other modules (possible Main), etc.
04:10:35 <Beelsebob> yitz: I'm using Haskell in a professional development environment
04:10:47 <Beelsebob> nothing's causing major problems
04:10:50 <yitz> global state is need generally in these kinds of situations - where you need to do something in IO, but you have no access to the function in the IO monad that would need to be changed.
04:11:40 <yitz> Beelsebob: great! this is not something that happens all the time - or in every work environment even. but we have to make sure that there is *some* way out if it does happen.
04:11:59 <Beelsebob> so what exactly is the problem?
04:12:13 <Beelsebob> you have a C library, that relies on global state, but doesn't maintain it itself?
04:12:23 <Beelsebob> sounds like it just doesn't work to me
04:13:09 <yitz> as I have been saying - I have no problems with leaving it as a pragma with unsafePerformIO - as long as the pragma really has the right semantics - nor do I have a problem with Cale's desire to confine the whole think to FFI or some other kind of quarantine.
04:13:41 <yitz> it just has to be possible in case of an emergency, that's all.
04:14:34 <yitz> now is that really the best way to do it - perhaps not, but I'm not going to get involved in all of that discussion. my bones are somewhat fragile :)
04:14:41 <dolio> I can see that. I just don't see the motivation to invent some kind of top-level <- to further bless/encourage it.
04:15:27 <dolio> Since top-level <- seems fraught with peril at first blush.
04:15:28 <sjanssen> yitz: stick #define GLOBALVAR NOINLINE in all your Haskell source if it makes you happy
04:15:30 <Beelsebob> yeh, top level <- sounds like the wierdlest idea ever
04:15:37 <yitz> Beelsebob: that's one example, yeah. C libraries have no problem requiring the caller to manage global state for them, no one envisioned Haskelll when they wrote the library.
04:15:53 <Beelsebob> yitz: don't use them
04:16:01 <sjanssen> yitz: I think global state is a hack, so it's okay that we have a hackish workaround
04:16:01 <Beelsebob> if the library requires you to do it's job for you
04:16:04 <Beelsebob> what's the point in the library
04:17:29 <yitz> sjanssen: heh. I don't care what it's called. yeah it's an unfortunate hack, I agree. But the point is that it needs to be required to have the right semantics - the compiler must officially support it, and be committed to fixing that if it goes wrong in some future version of the compiler.
04:18:40 <sjanssen> yitz: NOINLINE is so firmly entrenched that I don't think it will ever change
04:18:58 <sjanssen> yitz: but yeah, it'd be nice to have a paragraph in the FFI standard or something
04:19:02 <yitz> Beelsebob: well obvious when that scenario happens the author doesn't consider it to be the job of the library. For example, it's one way for a library writer to be polite - here, you manage this memory yourself, so that I'll be sure not to cause you leaks or segfaults or whatever.
04:19:27 <yitz> sjanssen: NOINLINE is fine, it could be useful on its own
04:19:40 <yitz> its just something else, not exactly what we need for this.
04:21:31 <yitz> sjanssen: I think the original intention of NOINLINE is for pure functions, to tell the compiler that this calculation might be more expensive than it looks so I'd rather use up memory to avoid repeating it
04:26:21 <yitz> Here's another situation where this came up
04:27:07 <yitz> I wanted to write a library to use Festival for speech synthesis. I want the library to be able to link in to places where, say, a message is written to the screen. For accessiblity.
04:28:20 <yitz> Now, I'm not rewriting any programs. I just need to add a line to messageBox that also calls festivalSpeech.
04:30:08 <yitz> So there is no way that I can say "your program must call initializeFestival :: IO ()" - I just don't have control over that. The requirement is - I get called every once and a while with a message, and I have to generate speech.
04:31:16 <yitz> So now - I have to somehow know that this is the first time I am being called, call initializeFestival, and then not call it subsequent times. I don't see any way around global state with those requirements.
04:38:45 <Saizan_> ?bot
04:51:37 <conal> quicksilver: (old thread) thx for the explanation of your preference of evaluate over seq, namely that "evaluate confuses people and seq is easier to explain".  if we can use seq, i'd prefer it, since i'm confused about evaluate also.
05:15:46 * ski wonders what's hard to understand about `evaluate'
05:18:28 <BeelsebobWork_> the specification takes the form of a suggested implementation that can't possibly be right
05:18:30 <lilac> yitz: if you don't like the global state in your Haskell wrapper, you could write a C wrapper which manages it then FFI to that :)
05:19:58 <yitz> lilac: yeah. actually, in that case it was a pipe to an external command. But you could do anything you want in FFI - C is a very flexible language. :)
05:20:03 <RayNbow> @bot
05:20:31 <yitz> hi RayNbow. no \bot around today, sad to say.
05:20:39 <ski> BeelsebobWork_ : elaborate ?
05:21:20 <BeelsebobWork_> a bit of googling tells me that the docs say it should be evaluate x = (return $! x) >>= return
05:21:38 <BeelsebobWork_> but if >>= is strict in its first argument, then it's no better than (return $! x)
05:21:58 <BeelsebobWork_> and >>= *is* strict in its first argument when it's second argument is return
05:26:45 <quicksilver> ski: I submit as evidence the fact that the people who designed evaluate wrote an inconsistent spec
05:26:49 <Peaker> @type ($!)
05:27:17 <quicksilver> ski: I claim this demonstrates that evaluate managed to confuse some SufficientSmartPeople (tm) and thus might conceivably confuse anyone.
05:27:46 <ski> i see
05:28:10 <quicksilver> sjanssen fairly clearly explained 'the difference'
05:28:19 <kosmikus> what/where is the origin of this discussion?
05:28:25 <quicksilver> but I have yet to see an example where evaluate is 'the right solution to a problem'
05:28:30 * Peaker wants docstrings to be available in ghci....
05:28:41 <quicksilver> kosmikus: someone made a forcing bug. I submitted that evaluate was a poor solution and a simple seq would have been easier
05:28:50 <kosmikus> where?
05:28:57 <quicksilver> here in this very channel.
05:29:00 <kosmikus> ah
05:29:04 * kosmikus reads log
05:30:03 <Peaker> a `seq` b means: To evaluate the resulting b, first evaluate a? (e.g if the result of seq is never evaluated, a won't be evaluated, right?)
05:30:09 <Saizan> @bot -- there's some bug with @let, but it mostly works
05:30:09 <psibot> :)
05:30:31 <EvilTerran> @vixen who are you, and what have you done with lambdabot?
05:30:32 <psibot> no, how dare you ask if i'm a bot!
05:30:39 <EvilTerran> o.ó
05:31:05 <quicksilver> Peaker: correct.
05:31:38 <Peaker> quicksilver: and it only does top-level forcing, not "all the way down" forcing, right?
05:32:00 <quicksilver> WHNF.
05:32:05 <quicksilver> which means Yes.
05:32:06 <quicksilver> ;)
05:32:08 <Saizan> quicksilver: by a simple seq you mean \x -> x `seq` return x ?
05:32:24 <quicksilver> Saizan: well yes, that would have been the right answer in this case, yes.
05:32:27 <kosmikus> quicksilver: fwiw, I also agree. using seq is much less confusing than using evaluate.
05:33:34 <GremlinHunter> Where might you use seq other than in x `seq` f x?
05:36:32 <Peaker> Is this true?  a $! b = b `seq` a b
05:36:43 <EvilTerran> ?src ($!)
05:36:43 <psibot> f $! x = x `seq` f x
05:36:48 <EvilTerran> yes :)
05:36:51 <Peaker> ah, cool :)
05:38:04 <saya> ?src const
05:38:04 <psibot> const x _ = x
05:39:47 <quicksilver> GremlinHunter: all kinds of places :)
05:40:30 <quicksilver> but it might be true that most examples have somethign like that form.
05:41:03 <Peaker> (if they do, they should be using $! ?)
05:41:24 <quicksilver> no, because the general form is
05:41:49 <Peaker> where do you want to force stuff, even with seq, at all? When using interleave'd IO?
05:41:57 <quicksilver> x `seq` g (h a b c (j e f x) l (d y x w))
05:42:06 <quicksilver> and it's not obvious how to rewrite that using $!.
05:42:12 <quicksilver> well, I suppose it is obvious, actually.
05:42:16 <quicksilver> but it's going to be uglier :)
05:42:22 <Peaker> ah
05:42:42 <EvilTerran> Peaker, you want to force stuff to stop thunks building up, primarily
05:42:44 <quicksilver> Peaker: when you don't want to accumulate a large thunk until its demanded.
05:42:46 <EvilTerran> ?src foldl'
05:42:47 <psibot> foldl' f a []     = a
05:42:47 <psibot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:42:53 <quicksilver> but instead want to store a relatively compact value
05:42:59 <quicksilver> as in a long-lived data structure, typically
05:43:14 <Peaker> has anyone working on any project to do automatic run-time profiling that determines whether to force thunks?
05:43:23 <quicksilver> also when you want to control in which thread an expensive evaluation is done.
05:43:24 <Peaker> s/has/is
05:44:12 <quicksilver> I'm not aware of any current projects.
05:44:21 <quicksilver> I'm sure there have been countless masters theses and papers on things like that.
05:45:00 <Peaker> with some not-too-high overhead per-value (perhaps 1 bit for small values, and more for larger values), you could probably store information such as frequency of access, expensiveness of computation, etc that will let it decide whether to force thunks and whether to keep them alive intelligently
05:45:57 <quicksilver> I don't think it's that easy :)
05:46:18 <Peaker> then we could get rid of the difference between let and function application (keeping result vs throwing it away and recomputing) as well as avoid the need for strictness annotations
05:46:53 <Peaker> and despite the extra overhead, the smarter decisions on a case-by-case basis might even improve performance :)
05:47:26 <Peaker> the programmer is forced to decide the strictness of an expression for all the evaluations, or duplicate the code. This probably encourages the wrong thing for many cases
05:48:24 <Philonous> Common subexpression elimination should already get rid of the difference between let and functional application, but I think lets are easier to read
05:49:21 <Wild_Cat> Peaker: if you do that, you can probably throw in automatic memoization based on more or less the same data.
05:50:26 <Peaker> Philonous: but ghc at least uses "let" vs func-apply as a hint about whether to keep the value around after its use
05:50:45 <quicksilver> Peaker: can you explain what you mean by that?
05:50:51 <quicksilver> that doesn't sound quite right.
05:51:16 <Peaker> f x = <some expression of f x> is treated differently to: let a = <some expression of a> in a
05:51:27 <Saizan> ghc doesn't do CSE
05:51:48 <Philonous> Doesn't? Ok then. I thought it did.
05:52:13 <Peaker> I dislike the use of "let" as a hint..  an automatic profiler can do a better job than static per-expression hints
05:52:27 <Peaker> (IMO :-) )
05:52:36 <ejt> 'let' isn't a hint
05:52:42 <quicksilver> you're wrong in pointing the finger at let.
05:52:54 <quicksilver> the different between your two expressions is that "f x" has a parameter.
05:53:08 <quicksilver> f x = <some expression of f x> ; vs ; a = <some expression of a>
05:53:22 <quicksilver> the same contrast applies.
05:53:36 <quicksilver> named values are evaluated once and then saved until GCed
05:53:40 <quicksilver> that's the "point of" naming something.
05:53:43 <quicksilver> so naming controls sharing.
05:54:30 <Peaker> yeah, I think sharing control should be automatic
05:55:00 <quicksilver> this doesn't seem connected to what we were just discussing though.
05:55:05 <Peaker> I think one of Haskell's worst difficulties is controlling sharing and strictness, and if those were automatic, Haskell would be a truly easy-to-use language :)
05:56:23 <quicksilver> optimisations which increase sharing (e.g. CSE) leak memory
05:56:27 <Saizan> Peaker: you may like the maximal laziness paper here: http://nixos.org/docs/papers.html
05:56:28 <psibot> Title: Nix Papers
05:56:34 <quicksilver> it's very hard to get that right.
05:56:34 <Peaker> Saizan: thanks
05:56:54 <Peaker> quicksilver: yeah, that's why an automatic profiler that compares the costs of memory with runtime and chooses the cheaper resource at any given moment would be nice
05:57:06 <quicksilver> much like a cure for cancer would be nice.
05:57:06 <gwern> Peaker: so all we need is an even more sufficiently smart compiler?
05:57:14 <Peaker> quicksilver: another nice thing about that is that if memory is cheaper at a given moment, it can use that information, whereas static code can't
05:57:16 <quicksilver> I think that's *extremely* hard to get right.
05:57:21 <gwern> poor ghc. people expect so much of it
05:57:41 <Peaker> gwern: I think ghc has proven that the "sufficiently smart compiler" is not a total myth :)
05:58:33 <RayNbow> hmm... is depth = length . levels an efficient way to compute the depth of a tree? (Data.Tree)
05:59:05 <gwern> while we're at it, we might as well ask it to start proving theorems so we can evaluate stuff like [1..] == [1..]
05:59:09 <Peaker> quicksilver: do you think it is as difficult as a cure for cancer?
05:59:21 <quicksilver> RayNbow: I don't think there are any efficient ways.
05:59:28 <Peaker> gwern: it doesn't have to be perfect, just a good enough approximation
05:59:28 <quicksilver> RayNbow: you have to scan the entire tree.
05:59:34 <Wild_Cat> Peaker: I think what you're describing would require a VM more than a compiler.
05:59:38 <quicksilver> RayNbow: length . levels is good enough I should think.
05:59:42 <Peaker> Wild_Cat: I agree
05:59:50 <Wild_Cat> (prior art: HotSpot)
05:59:55 <quicksilver> Wild_Cat: I don't think it requires much more "VM-like" than the GHC RTS already has.
06:00:23 <quicksilver> I'm pretty sure hotspot doesn't attempt anything like this.
06:01:00 <Peaker> Wild_Cat: I think JIT should in theory be better than static native code generation
06:01:02 <quicksilver> Peaker: I don't know, I'm not a medic ;)
06:01:08 <Wild_Cat> quicksilver: well, it does automatic runtime profiling and inlines stuff it thinks will make faster.
06:01:12 <quicksilver> But I think it's seriously hard.
06:01:26 <Wild_Cat> isn't that automated time/memory tradeoff?
06:01:36 <quicksilver> yes, but a completely different one.
06:02:13 <Wild_Cat> Peaker: that's part of the theory behind Hotspot. Sometimes it works. Sometimes it gets pummeled by the JVM bloatware suckage factor.
06:02:34 <Jedai> Peaker: gwern: I think ghc has proven that the "sufficiently smart compiler" is not a total myth
06:02:53 <Wild_Cat> quicksilver: yeah, I guess CSE isn't easy to do in non-functional langs.
06:03:07 <Jedai> Peaker: I'm not completely sure, I think most of the power of GHC comes from the nice properties of the language
06:03:47 <Peaker> Jedai: well, I think the statement "the sufficiently smart compiler is a myth" is a meaningless one, as we constantly get smarter compilers
06:03:57 * RayNbow wonders why Data.Tree doesn't contain a foldTree that gives more control...
06:04:08 <quicksilver> Wild_Cat: compilers for C-like languages do CSE only on an "obvious functional subset"
06:04:52 <Jedai> Peaker: Well... There is "sufficiently smart" and there is "quasi AI-like", sometimes there's a confusion between the two
06:04:58 <Peaker> Jedai: we didn't always have reasonable GC.. why is it sufficiently smart for GC, but not for automatic deduction of strictness and sharing?
06:05:24 <quicksilver> Peaker: automatic deduction of strictness it does
06:05:34 <quicksilver> reasonably successfully, in the domain it is intended to work on.
06:05:37 <Jedai> Peaker: It's pretty good at strictness analysis now
06:05:42 <quicksilver> automatic deduction of sharing is *HARD*.
06:05:56 <Peaker> quicksilver: yeah, but not trying to get a good runtime/memory use tradeoff
06:06:04 <quicksilver> yes, that is hard too.
06:06:20 <Jedai> Peaker: As proof, much of the strictness annotation of the shootout are now unnecessary
06:07:03 <Jedai> quicksilver: Especially since excessive sharing can have catastrophic consequences on the performances/memory occupation
06:07:08 <Peaker> Jedai: that's awesome - but as a relatively new Haskell user, I got burnt by thunk buildup that could have been avoided with even a very stupid automatic profiler
06:07:56 <Jedai> Peaker: Mostly in the interpreter or without optimisation, though, no ?
06:08:18 <Peaker> Jedai, quicksilver: What if you assign a general "cost" to memory and runtime (based on the sparsity of them [supply]) and measure the frequency of access [demand] and compute the actual alternative costs of sharing/unsharing a result greedily for each expression?
06:08:44 <Peaker> Jedai: nope, when trying to use the lazy state monad, compiling with optimizations
06:09:18 <quicksilver> Peaker: I don't think you're right.
06:09:32 <quicksilver> Peaker: I think that "very stupid automatic profiler", while it might have fixed your program, would have broken others.
06:09:43 <quicksilver> If it is that easy, I suggest you go write it, or write a paper on it :)
06:09:59 <Peaker> each percentage of memory use would be assigned a cost, computation time (you know how much it took to compute the last time) could be assigned a cost, and those could be related to one another because memory use translates to actual time when swapping out/in
06:10:12 <quicksilver> most thunks have never been computed before.
06:10:27 <quicksilver> so getting a sensible computation time estimate is hard.
06:10:50 <Peaker> quicksilver: well, the expressions these thunks originated from did get computed, and that's probably a good estimate
06:11:13 <quicksilver> I don't understand that comment.
06:11:18 <quicksilver> suppose I have the thunk (fib 42)
06:11:23 <quicksilver> how do you estimate how long that takes?
06:11:56 <Peaker> how much time did the last computation of (fib x) take?
06:12:30 <quicksilver> no time at all, because the last computaiton was (fib 0)
06:12:48 <Peaker> btw: I have another "trick" at my disposal, if something passes some memory use threshold, I can begin to force it - but only pay some amount of computation time that is proportional to the space it uses, and give up after that
06:12:59 <Peaker> then when it builds up more memory use, give it some more runtime, and so on
06:13:37 <araujo> morning
06:13:43 <Peaker> then I assume it will takes as much as (fib 0) takes, and if I'm wrong, I'll pay now, and have a better estimate later (and can even avoid too big a penalty for a wrong estimate by cutting my losses when the computation becomes too long)
06:14:16 <saya> Couldn't the compiler kindov get the complexity  of an algorithm at compile time?
06:14:33 <quicksilver> saya: in general, no.
06:14:45 <quicksilver> saya: in particular cases, well that's another interesting research problem :)
06:14:49 <Peaker> saya: interesting - I think specifying complexities manually would be much better hints than strictness annotations!
06:15:18 <saya> :)!
06:15:48 <Peaker> quicksilver: I can "try" to throw computation time at it, and see if I'm able to decrease its memory use by doing that - and by limiting my error I can get an approximation that is at least some % optimal
06:16:14 <quicksilver> you can indeed.
06:16:24 <quicksilver> But you risk throwing away a lot of computation time that way
06:16:33 <quicksilver> and slowing down programs which worked well without your profiler.
06:16:44 <Peaker> yeah, C computation units for every M memory usage units
06:16:49 <quicksilver> Believe me I'm not trying to say this is impossible: it's a very interesting and exciting idea.
06:16:59 <quicksilver> I'm just trying to say it's extremely hard and that's why no one has done it.
06:20:58 <quicksilver> there's definitely enough material for a multi-person research project
06:22:06 <Peaker> btw: I think one specific problematic case of huge thunks building up for large recursions taking tons of memory is a common problem. for this specific case - wouldn't it already be beneficial to have a thunk-size threshold that triggers forcing?
06:22:39 <Peaker> why are you building a huge thunk if you'll never evaluate it?
06:22:41 <quicksilver> Yes, it feels like it would.
06:22:52 <quicksilver> don't forget that "huge thunk" is actually a slightly inaccurate way of speaking
06:22:55 <quicksilver> all thunks are the same size
06:23:04 <quicksilver> the issue is about a large graph of related thunks
06:23:05 <SamB_XP> are they now?
06:23:12 <quicksilver> SamB_XP: well, roughly.
06:23:46 <Saizan> isn't that case mostly covered by foldl' ?
06:24:48 <Wild_Cat> Peaker: the problem with that is that some thunks resolve to infinite computations (e.g. [1..]).
06:24:57 <quicksilver> when we speak of a "huge thunk" what it actually is is a tree (or, frequently, simply a linked list)
06:25:01 <quicksilver> of thunks.
06:25:10 <Peaker> Saizan: that may be a solution, but it is not automatically used when you make a mistake, such as using the lazy state monad and never looking at the state
06:25:16 <quicksilver> Wild_Cat: [1..] never forms a large thunk, though. It forms a large data structure with a small thunk at the end.
06:25:30 <Philippa> <Peaker> why are you building a huge thunk if you'll never evaluate it? <- because it's necessary in evaluating what you /are/ evaluating
06:25:49 <Philippa> you can only avoid building the thunk if you can either a) prove you never use it or b) retain another way of evaluating the same thing if needed
06:25:54 <quicksilver> Philippa: yes, but I think peaker's point is that, since you will need it you might as well evaluate it now.
06:26:07 <yitz> preflex: seen dcoutts
06:26:08 <preflex>  dcoutts was last seen on #haskell 2 hours, 34 minutes and 24 seconds ago, saying: quicksilver: specifically happs data, only one instance of each data component per process (modulo linking issues)
06:26:11 <quicksilver> Philippa: he's not arguing to delete the value, he's arguing to force it instead of letting the thunks build up.
06:26:14 <Wild_Cat> quicksilver: ...and that thunk evaluates to a number consed to another thunk of the same size.
06:26:19 <Philippa> which comes back to: prove it
06:26:28 <Wild_Cat> thus, an infinite graph.
06:26:29 <EvilTerran> the problem with implicitly forcing "large thunks" is that it, of course, increases strictness
06:26:33 <quicksilver> Wild_Cat: yes. so that doesn't produce large thunks in the sense that Peaker is talking about.
06:26:39 <quicksilver> Wild_Cat: it produces something else :)
06:26:40 <Philippa> because otherwise you screw with the language's semantics - we're not just talking a different but valid evaluation strategy
06:26:53 <Peaker> Philippa: which side would you rather err on - computing too much, or consuming too much memory?
06:27:05 <Peaker> which err is easier to debug, too?
06:27:28 <EvilTerran> Peaker, i'd err on not making an otherwise non-_|_ expression _|_ in an attempt to optimise
06:27:34 <Peaker> I think I'd want a hybrid - if I'm consuming a lot of memory, and barely doing any computation, I'd rather fix the err towards computation, and vice versa
06:28:01 <quicksilver> Peaker: yes, of course, EvilTerran and Philippa raise an important point which I missed.
06:28:08 <Peaker> EvilTerran: I'm talking about strictly an optimization, it can force thunks to reduce memory without actually using the results
06:28:14 <EvilTerran> that's the most important point
06:28:19 <quicksilver> Peaker: even evaluating a thunk "one step" may take infinite time or raise an exception.
06:28:20 <Philippa> Peaker: you can't do that
06:28:22 <EvilTerran> Peaker, what about if one of those thunks is _|_?
06:28:32 <Philippa> exactly
06:28:45 <Peaker> quicksilver, EvilTerran, Philippa: I can put a computational limit on the time I give to a thunk evaluation, and give up after that
06:28:46 <quicksilver> Peaker: so to do what you want, you need some general mechanism for time limiting a computation and ignoring/collecting excpetions.
06:28:53 <EvilTerran> Peaker, and the exception?
06:29:00 <Peaker> EvilTerran: what exception?
06:29:10 <EvilTerran> _|_ isn't just non-termination, it's also exceptions
06:29:13 <yitz> dcoutts: ping
06:29:20 <Philippa> Peaker: yeah, that can be done
06:29:25 <EvilTerran> where would those exceptions go?
06:29:28 <Philippa> see "Optimistic Evaluation"
06:29:33 <quicksilver> EvilTerran: well you'd leave them in the thunk ;)
06:29:35 <Peaker> EvilTerran: I would ignore the exceptions until they're actually used.  I'd distinguish forcing for use and forcing for memory reduction
06:29:35 <Philippa> EvilTerran: nowhere
06:29:56 <Philippa> rather, you do the update /after/ you've forced all you're going to, and the exception just blocks the update
06:30:00 <quicksilver> EvilTerran: you could then mark as unreachable anything "past" the exception though.
06:30:02 <EvilTerran> then we could get the FFI involved and have to start worrying about things like segfaults
06:30:09 <Philippa> (or modifies how far through you were going to)
06:30:17 <quicksilver> EvilTerran: which might let you GC some memory.
06:30:17 <Philippa> OTOH it's a much bigger issue in the presence of unsafePerformIO
06:30:41 <quicksilver> Peaker: a general mechanism for time-limiting computations tends to add an overhead to your RTS model too.
06:30:48 <quicksilver> (I'm not sure how significant that would be in this case)
06:30:50 <Peaker> EvilTerran: hmm.. if forcing an expression causes a segfault, wouldn't that be considered a bug?  Are you allowed to rely, denotationally, on the laziness and its extent?
06:31:09 <Peaker> quicksilver: we're already paying the overhead of background timer interrupts
06:31:12 <Philippa> Peaker: unsafePerformIO causes some problems
06:31:16 <EvilTerran> Peaker, yeah, that was a little facetious
06:31:21 <saya> What would you use as a makefile for haskell?
06:31:29 <quicksilver> saya: ghc --make if it works.
06:31:38 <EvilTerran> if the compiler can prove that an expression is non-_|_, then strictifying it shouldn't be a problem - i believe it already does so in some cases
06:31:40 <Shiruka> is there some trick to using manual cost centres with ghc profiling? seems like they always get near-zero time (both individual and inherited), but moving the expression to a toplevel function and using -auto-all produces expected results :-/
06:31:46 <ejt> saya: or a makefile or cabal
06:32:07 <EvilTerran> but otherwise, the compiler implicitly adding strictness sounds awkward and a recipe for trouble
06:32:11 <Peaker> EvilTerran: Why can't I force thunks in a memory-optimization mode that A) limits the computation time,  B) ignores exceptions
06:32:20 <saya> ok thanks :) ill look at cabal
06:32:24 <Peaker> EvilTerran: note this is purely a memory-use optimization
06:32:34 <Peaker> EvilTerran: so it would do its best to stay out of the way, exception-wise
06:32:47 <EvilTerran> Peaker, you could. will it make your code use significantly less memory intensive in general, though?
06:33:06 <EvilTerran> and will it do so without greatly increasing runtime in general?
06:33:16 <Peaker> EvilTerran: I think it will make many Haskell programs that currently leak memory, leak computation time instead, which is far easier to debug
06:33:40 <quicksilver> a small step in the direction you're discussing
06:33:41 * EvilTerran is willing to strictness-annotate explicitly
06:33:44 <quicksilver> (something you'd need anyway)
06:33:51 <quicksilver> is a runtime dynamic heap profiler
06:33:57 <quicksilver> that would be a useful step on its own
06:34:03 <quicksilver> even if it didn't actually do any optimisation.
06:34:11 <EvilTerran> it's a lot less painful than explicit laziness in most strict languages, so i'm happy with that :)
06:34:12 <quicksilver> simply getting information about whether or not thunks are accumulating.
06:34:35 <Peaker> EvilTerran: I find it very difficult to even identify my leaks in my Haskell programs :-(
06:34:37 <ejt> Peaker: a smaller project would be to work out what time/memory a program would have used if it had your magic predictor
06:35:06 <Peaker> ejt: not a predictor, just a memory waste to cpu waste convertor :-)
06:35:29 <EvilTerran> Peaker, indeed, but i'd be inclined to go about writing something that can identify those leaks rather than something to silently fix them
06:35:41 <EvilTerran> at least as a first step
06:35:47 <Philippa> I hae to admit, I'd still sometimes like a way to request call-by-name evaluation
06:35:49 <Philippa> *have
06:35:55 <EvilTerran> seeing as you'll need to find them before you can fix them
06:36:06 <quicksilver> EvilTerran: that's what I just said, I think :)
06:36:10 <quicksilver> EvilTerran: certainly it's what I just tried to say.
06:36:13 <Peaker> quicksilver: Isn't the barrier-of-entry of ghc hacking pretty high?
06:36:18 <EvilTerran> and that alone might turn out to be sufficient, if not even preferrable to fixing them
06:36:19 <Philippa> (= I get control over whether intermediate thunks're live or not)
06:36:32 <EvilTerran> it'd be a lot more educational to use, anyway :)
06:36:57 <ejt> Peaker: it predicts which expressions will need to be evaluated, so it would be interesting to assume a perfect predictor (after the event) and see what the best possible space/time trade off would be for various programs
06:37:20 <geev> hi to all
06:38:01 <EvilTerran> who knows, if we had something that could easily identify where thunks were building up but we had to fix the leaks outselves, maybe we'd all pick up better reasoning about thunks after using it for a while
06:38:04 <Peaker> ejt: if there's a perfect prediction, why not just force all expressions that will ever be evaluated asap?
06:38:07 <yitz> Peaker: it depends how you define "hacking". And in any case, it's getting quickly lower day by day.
06:38:27 <EvilTerran> Peaker, for a given definition of "asap", that's what we do now :P
06:39:06 <EvilTerran> also, there isn't perfect prediction, that's the problem
06:39:08 <ejt> Peaker: exactly, that's perfect predictor gives you a theoretical limit to strive for with your not-so-perfect predictor
06:39:18 <yitz> geev: hi
06:39:28 <ejt> Peaker: and tells you if this is a useful avenue to persue
06:39:29 <Peaker> ejt: Oh, I didn't mean trying to predict whether it will be in use - just measuring its actual memory use
06:40:05 <geev> i would like to know which programming language thats runs on linux will can i use to program my computer to interact with external device
06:40:08 <ejt> Peaker: well you're just using memory use as the heuristic then
06:40:13 <Peaker> ejt: I can easily devise programs that currently take arbitrarily large memory before they are forced into a small result, which can instead use O(1) memory
06:40:26 <tylere> geev: Well, C is the obvious choice...
06:40:31 <ejt> Peaker: most would argue that those are badly written programs though
06:40:47 <Peaker> ejt: if its using memory, its not more likely that it will be in use - it just means I'd rather err on the other side
06:41:16 <Peaker> ejt: I agree - but I think this is partially useful as a way to identify these bad programs (as others have mentioned, a good heap profiler might be a better way)
06:41:29 <geev> <tylere> is it C/C++
06:41:46 <Wild_Cat> geev: just about any language, really. UNIX makes this quite easy.
06:42:06 <Wild_Cat> C, Haskell, Python, heck, shell scripts if you really want to be hardcore...
06:42:20 <Peaker> ejt: (given that cpu profiling is probably easier than heap profiling)
06:43:17 <mapreduce> I interacted with an external device once.  I ejected a disk 8,000 miles away.
06:43:46 <Wild_Cat> mapreduce: must have been a pretty powerful spring in the drive.
06:43:50 <ivanm> mapreduce: what kind of disk? floppy? optical?
06:44:00 <mapreduce> CD drive.
06:44:16 <ivanm> so you had a remote coffee cut holder?
06:44:47 <mapreduce> They're useless as coffee holders because they spill when they retract.
06:44:50 <mapreduce> Noob.
06:45:11 <Philonous> Does "calling the guy sitting beneath it and asking him to eject the disk" count as remote interaction?
06:45:34 <ivanm> mapreduce: no, see, you only retract it when you've finished drinking your coffee!
06:45:58 <Philonous> s/beneath/in front of/
06:46:10 <Peaker> the mention of noob kinda makes me want to have a starcraft game
06:47:05 <Peaker> any Haskellers play[ed] SC?
06:47:13 <saya> me :)
06:47:24 <Wild_Cat> everybody's played SC.
06:47:26 <Peaker> saya: still play? ICCup? :)
06:47:51 <ivanm> Wild_Cat: even young script kiddies that only started using a computer a couple of years ago?
06:48:04 <ivanm> to them, starcraft probably has rubbish graphics or something :p
06:48:06 <saya> nah i just played on battlenet, must have the cd somewhere but its been a while
06:48:10 <GremlinHunter> Do haskellers employ lazy tactics?
06:48:28 <ToRA> they avoid success at all costs...
06:48:33 <ivanm> GremlinHunter: sure "I _could_ build something, or I could just wait till I get more minerals and vespene gas"
06:49:06 <Wild_Cat> ivanm: I doubt many of those lurk around an IRC channel dedicated to a relatively obscure and definitely alien programming language that strives for mathematical elegance ;)
06:49:58 <ejt> I'll try StarCraft once I've finished with NetHack
06:50:06 <Peaker> the players still on Battle net are increasingly good, so to keep up you have to practice quite a bit
06:50:08 <ivanm> Wild_Cat: you said that _everybody_, not all haskellers...
06:50:18 <Peaker> (increasingly, for 11 years or so)
06:50:43 <Philippa> *nod*
06:50:52 <Philippa> it's a bit like if you can find anyone to play Doom against, they'll slaughter you
06:50:57 <Philippa> (though less so on XBLA)
06:52:10 * EvilTerran has the same problem with Tribes II - the servers are either open-to-all and full of noobs or clan servers and full of experts who'll thrash you even with one hand behind their backs and the other on a trackpad
06:52:28 <Wild_Cat> ivanm: I used a lazy speaking evaluation strategy, assuming you'd do the rest of the work on your end. It backfired.
06:52:51 <ivanm> heh
06:52:52 * EvilTerran still plays SC with his friends, though
06:53:52 <Peaker> EvilTerran: you're THAT kind of an evil terran?? :)
06:54:05 <Peaker> mnm or tech fan? :-)
06:54:20 <EvilTerran> that was not my original intent with this nickname - there are terrans in a lot of scifi
06:54:22 <EvilTerran> but it works :)
06:54:50 <dmead> what about infested command center?
06:54:51 <Wild_Cat> yeah, trying Battle.net now would be Korean-assisted suicide.
06:54:59 <Japsu> Isn't StarCraft 2 due out sometime soon?
06:55:02 <dmead> i bought sc again this year
06:55:04 <Peaker> Wild_Cat: I kick korean's ass on bnet :-)
06:55:05 <dmead> it's really not that bad
06:55:10 <dmead> but you do get hackers sometimes
06:55:15 <Peaker> I'm pretty good, but I've practiced a lot...
06:55:25 <dmead> like... people who fill the map with hatcheries in 4 min
06:55:28 <Peaker> dmead: I think on iccup, map hacks and perhaps mineral hacks no longer work
06:55:35 <EvilTerran> Peaker, mnm?
06:55:38 <dmead> kewl
06:55:49 <Peaker> EvilTerran: mnm is marines and medics
06:55:58 <EvilTerran> ah. yes, that's my usual style.
06:56:00 <Peaker> EvilTerran: vs tech (tanks/vults/gols) are the two main strategies
06:56:09 <dmead> i like the reaver drop rush myself
06:56:27 <Peaker> dmead: yeah, I love it. I quickly go to 2 robotics and fast shuttles :)
06:56:39 <EvilTerran> it varies - sometimes i go for turtling 'til i can sweep the map with a dozen yamato cannons
06:56:46 <dmead> one of the last games i played was a 4v4
06:56:52 <dmead> i was the 4th who never got attacked
06:57:00 <dmead> so i just cranked out reaver drops all game
06:57:01 <Peaker> EvilTerran: that would never work on bnet :)
06:57:16 <EvilTerran> i never play on bnet :)
06:57:24 <dmead> i was on a team with b.falcon once
06:57:30 <Peaker> who's that?
06:57:31 <dmead> and he's the master terran turtler
06:57:40 <dmead> he was like 1 or 2 in the world a while ago
06:57:51 * Twey laughs.
06:57:51 <dmead> check his stats
06:57:52 <EvilTerran> i find half the fun of RTSes and FPSes is being able to yell at the guy who just blew you up 'cos he's sitting across the table from you
06:57:52 <Peaker> higher than boxer?
06:57:53 <Twey> 'Turtler'
06:57:58 <dmead> it's like 5000-1 or something crazy
06:58:17 <EvilTerran> i bore very quickly playing them online against random strangers
06:58:17 <RayNbow> @bot
06:58:18 <psibot> :)
06:58:25 <dmead> yea
06:58:31 <dmead> i've lost interest in bnet
06:58:35 * Wild_Cat nods to EvilTerran
06:58:36 <quicksilver> well anything with strangers is a risk
06:58:42 <dmead> sc2 might be a flop for me
06:58:43 <quicksilver> discussing haskell with strangers is a risk
06:58:44 * Twey turtles.
06:58:48 <dmead> lol
06:58:55 <quicksilver> but this channel actually has a realy good community
06:58:58 <Peaker> dmead: not even a pro master can keep that kind of stats in random team games on bnet (a master + noob will lose to two very good casual players)
06:59:03 <quicksilver> similarly, some online games have really good communities
06:59:08 <quicksilver> most don't, in my experience ;)
06:59:18 * ejt tries to think of a Haskell question quick
06:59:20 <quicksilver> I enjoyed Myth : TFL back in '97 or so.
06:59:24 <Peaker> dmead: not even a pro can beat a 1v2 against good players..
06:59:36 <dmead> Peaker, usually... sometimes people get lazy
07:00:03 <dmead> quicksilver, the games that do are usually nitche
07:00:06 <dmead> which very few active players
07:00:12 <dmead> compared to like sc or counterstrike
07:00:33 <Peaker> SC has a lot of sub-communities, for example per-country. The Israeli one is pretty nice
07:01:27 <EvilTerran> to get this back on-topic
07:01:45 * EvilTerran has been thinking about writing an RTS where the units are scriptable
07:01:50 <EvilTerran> potentially with haskell
07:01:57 <Wild_Cat> Haskell: the Starcraft of Functional Programming.
07:02:03 <EvilTerran> because i find the level of micromanagement in most of them kinda offputting
07:02:14 <EvilTerran> "no, that's obviously not what i wanted you to do! wtf?"
07:02:16 <dmead> like you'd have to write your uber-micro scripts?
07:02:21 <dmead> beforehand?
07:02:23 <ziman> yeah
07:02:30 <dmead> that'd be hillarious
07:02:34 <EvilTerran> "why can't i reprogram these things to have sensible behaviour?"
07:02:36 * BeelsebobWork is missing the connection between SC and Haskell
07:02:37 <Peaker> EvilTerran: Also had that idea.. a game between scripts - but people would probably be mixing&matching scripts from all over the place, not really understanding them
07:02:37 <EvilTerran> dmead, yeah, pretty much
07:02:37 <ziman> a contest of coders instead of a contest of clickers :)
07:02:44 <Wild_Cat> EvilTerran: that's usually a design decision, though. Blizzard *wants* you to micromanage. Their games are written for 400 APM Koreans :p
07:02:53 <Wild_Cat> try Homeworld.
07:03:00 <EvilTerran> Wild_Cat, yes, but it's a design decision i dislike
07:03:03 <dmead> BeelsebobWork, a large majority of haskell people probably have been sc players
07:03:06 <Peaker> Wild_Cat: what's your APM?
07:03:07 <quicksilver> Peaker: there are lots of games between scripts
07:03:13 <BeelsebobWork> dmead: guilty as charged
07:03:16 <quicksilver> (I mean, lots of games designed that way)
07:03:19 <dmead> =)
07:03:26 <quicksilver> not just games where that happened because of cheater.s
07:03:30 <Wild_Cat> EvilTerran: me too. That's why I love stuff like Homeworld and Total Annihilation.
07:03:44 <EvilTerran> Peaker, well, the higher-level stuff would still come down to human control
07:03:45 <quicksilver> EvilTerran: the reason I liked Myth : TFL was the lack of micro management.
07:03:50 <quicksilver> and the shortness of the games.
07:03:53 <dmead> hmm
07:03:53 <EvilTerran> but you could script away all the bits you didn't like doing yourself
07:03:55 <dmead> i get the concept
07:04:12 <dmead> but it sounds too much like writting an aimbot for quake or something
07:04:12 <EvilTerran> if you love micromanagement and hate high-level strategy, maybe you could script it to play that way, too :)
07:04:16 <Peaker> EvilTerran: yeah, that would indeed be cool. It can be done with SC, but that would be cheating
07:04:42 <dmead> so like
07:04:52 <dmead> would those scripts totally automate the game?
07:04:53 <dmead> or like
07:04:59 <dmead> would it be a move do you during a fight
07:05:01 <EvilTerran> i've seen lists of "build exactly in this order to win" for the starcraft races, you could automate that and do the combat by hand
07:05:24 <EvilTerran> (i'm skeptical of these lists, but they seem to do a fairly good first approximation of good build strategy)
07:05:30 <Peaker> EvilTerran: then you'd send a probe to harass his scv's so they fail to build where they're programmed to :)
07:05:32 <ejt> I think you'd want to limit the amount of 'cpu' each unit has
07:05:46 <EvilTerran> ejt, yes, there'd need to be some kind of limit
07:06:00 <EvilTerran> perhaps you could even make the processing ability of different units variable
07:06:02 <ejt> so you'd invest in expensive units that have the cpu to work out higher level strategy
07:06:10 <ejt> and have them communicate with the grunts
07:06:11 <dmead> thats a good ideas
07:06:12 <EvilTerran> so you could have fragile "brain" units to do thinking for you
07:06:24 <dmead> hmm
07:06:28 <Peaker> EvilTerran: that you buy and upgrade like everything else
07:06:28 <ejt> y, you'd have to protect them
07:06:34 <dmead> that'd be a good way to teach programming
07:06:36 <EvilTerran> perhaps have them communicating concurrently
07:06:40 <dmead> have kids learn to play this game
07:06:45 <ejt> definitely communicating
07:07:01 <EvilTerran> or perhaps just have a "total processing power" like you have minerals and vespene gas
07:07:13 <EvilTerran> and make the concurrency optional
07:07:19 <dmead> but that kind of implies every is playing on the same hardware
07:07:27 <dmead> you'd have to quantify it
07:07:31 <dmead> not just a percentage
07:07:31 <ejt> that just means you're writing a conventional AI
07:07:32 <quicksilver> limit cycles on a fixed VM.
07:07:44 <quicksilver> rather than CPU usage on concrete hardware.
07:07:49 <EvilTerran> quicksilver, yes, that's what i was thinking
07:07:58 <dmead> like so many game ticks per unit?
07:08:02 <ejt> we should be able to knock this up pretty quickly
07:08:04 <quicksilver> something like that.
07:08:08 <EvilTerran> unfortunately, that makes making the units haskell-scriptable a bit difficult
07:08:22 <dmead> haskell would be awful for this, tbh
07:08:23 <EvilTerran> short of writing a YHC backend for our units
07:08:32 <quicksilver> yes, you'd want a DSL with obvious cycle counts
07:08:36 <EvilTerran> i guess
07:08:36 <quicksilver> for the scripting language
07:08:39 <dmead> yea
07:08:41 <GremlinHunter> Perhaps the first game to be ruled by Computer Scientists?
07:08:51 <quicksilver> there are loads and loads of games like this
07:08:52 <EvilTerran> maybe a bytecode, and let people use higher-level languages if they want
07:08:54 <dmead> well they would be the target audience
07:08:58 <SamB_XP> GremlinHunter: Core Wars variants have been around for ages though
07:09:02 <EvilTerran> GremlinHunter, there's CoreWars
07:09:05 <quicksilver> although most of them are not as sophisticated in teh RTS direction
07:09:11 <dmead> no bytecode
07:09:14 <dmead> something standardized
07:09:21 <EvilTerran> dmead, i mean the VM's bytecode
07:09:21 <dmead> like how sc has the same resolution setting for everyone
07:09:25 <dmead> it has to be even
07:09:26 <GremlinHunter> This sounds much more like complex AI than in corewars though
07:09:26 <dmead> ahg
07:09:27 <dmead> ah
07:09:37 <dmead> well
07:09:41 <dmead> maybe it could be like
07:09:45 <dmead> each little unit
07:09:48 <quicksilver> well, BattleBots, say
07:09:48 <EvilTerran> dmead, as in, you could write more efficiently if you were willing to write in assembly or on the bare metal
07:09:48 <dmead> is an expert system
07:09:55 <quicksilver> (there are literally thousands of games in the genre)
07:09:56 <dmead> with a very short list of rules
07:10:06 <SamB_XP> EvilTerran: is that necessarily the case?
07:10:15 <EvilTerran> but there could be higher level languages if folk wanted them
07:10:22 <EvilTerran> SamB_XP, i'm thinking of what i've read of corewars
07:10:38 <quicksilver> http://en.wikipedia.org/wiki/Programming_game
07:10:39 <psibot> Title: Programming game - Wikipedia, the free encyclopedia
07:10:44 <EvilTerran> i believe they offer a higher-level language for getting started, but that doesn't really get used by "pros"
07:10:46 <SamB_XP> corewars doesn't really tolerate higher-level languages though, since the machine language is stored in the playing field ...
07:10:53 <dmead> http://www.corewars.org/
07:10:55 <psibot> Title: Core War
07:10:55 <ejt> in corewars the world is memory, so quite different I think
07:10:56 <dmead> yea...
07:10:57 <quicksilver> sure, corewars is a bit 'different'
07:11:12 <EvilTerran> quicksilver, well, i wasn't thinking of something that's a pure programming game by that definition
07:11:24 <EvilTerran> as there'd still be a great deal of scope for real-time interaction with the units
07:11:47 <EvilTerran> assuming you scripted your units to respond to user input, anyway :P
07:11:51 <SamB_XP> quite so, I for one was just pointing out that games dominated by CS types already existed ;-)
07:13:25 <quicksilver> yes, as sam says.
07:13:30 <quicksilver> just pointing out this space has been explored.
07:13:40 <EvilTerran> this does also present the interesting thought that units might have to stay within "radio range" or something if you wanted to still be able to control them in realtime
07:13:47 <quicksilver> There are also 'turn-based' ones wher eyou only program one turn ahead.
07:13:59 <quicksilver> like Lords of Chaos (?) on 8-bit systems
07:14:09 <quicksilver> or RobosomethingIcan'tremember on the 68k macs
07:14:13 <EvilTerran> but you could send units outside that range, and let them run on programming
07:14:26 <SamB_XP> EvilTerran: fascinating
07:14:32 <EvilTerran> yeah :D
07:14:34 <GremlinHunter> Is there anything as complex as what your describing though, this seems more complex than something like robot football
07:14:45 <SamB_XP> EvilTerran: would you be able to find out what befell them before they came back in range?
07:14:56 <EvilTerran> SamB_XP, nope, no communication at all, i'm thinking
07:15:09 <EvilTerran> maybe you could give them an emergency flare or something
07:15:23 * BeelsebobWork ponders -- does x `par` y demand the value of x in a seperate thread, or does it demand x get to WHNF in a seperate thread?
07:15:25 <EvilTerran> but it'd be very limited
07:15:49 <EvilTerran> BeelsebobWork, WHNF is closer to reality
07:16:11 <BeelsebobWork> hmm, so *that's* why it doesn't improve efficiency in the binarytree example
07:16:14 <EvilTerran> BeelsebobWork, although it's not guaranteed to make a new thread - it merely makes a new "spark", which the RTS may make into a new thread later if there's a processor free
07:16:22 <BeelsebobWork> the seperate thread just goes "yep, it's a tree alright"
07:16:29 <quicksilver> BeelsebobWork: it's definitely only WHNF. Furthermore it's only a hint.
07:16:40 <BeelsebobWork> quicksilver: sure, I knew about the only a hint bit
07:16:48 <quicksilver> BeelsebobWork: but you can use more sophisticated combinators to get beyond WHNF
07:16:53 <quicksilver> see the Strategies module
07:16:56 <BeelsebobWork> cool
07:17:02 <SamB_XP> EvilTerran: so when units returned, what would appear on the screen ?
07:17:04 <EvilTerran> BeelsebobWork, heh, reminds me of http://www.mopo.ca/uploaded_images/identify-wood-746327.jpg
07:17:16 <BeelsebobWork> EvilTerran: awesome
07:17:42 <EvilTerran> SamB_XP, well, your base radar or whatever would be able to see them again, so presumably they'd appear on map
07:18:02 <EvilTerran> SamB_XP, along with any information you'd told them to collect on their travels, i guess
07:18:10 <SamB_XP> how would that be displayed?
07:18:19 <SamB_XP> it might be important to see timestamps
07:18:22 <EvilTerran> well, units could automatically record the terrain
07:18:32 <EvilTerran> have it appear as uncovered-but-not-currently-visible
07:18:48 <SamB_XP> (for unit sightings especially)
07:19:03 <EvilTerran> i'm thinking you'd want some kind of generalised "marker" thing that units could add to or remove from your HUD
07:19:04 <GremlinHunter> Would robots be able to communicate while in proximity to each other as well as over radio?
07:19:14 <EvilTerran> with arbitrary data attached to them
07:19:25 <SamB_XP> GremlinHunter: I expect that would be done by radio as well
07:19:30 <quicksilver> now it sounds like an ICFP problem :)
07:19:32 <EvilTerran> like "hey, SCVs, when one of you's free, come build a power plant here"
07:19:44 <ejt> proximity only would lead to flocking like behaviour
07:19:44 <EvilTerran> or "i saw a big gribbly thing here a minute ago"
07:19:52 <GremlinHunter> I meant could a group of robots still communicate if they left your radio coverage area?
07:19:52 * quicksilver hides from the gribbly.
07:19:53 <SamB_XP> quicksilver: except ICFP doesn't allow players to play
07:20:01 <EvilTerran> GremlinHunter, i guess so, yes
07:20:05 <Axman6> @hoogle parallel
07:20:05 <psibot> A Hoogle error occurred.
07:20:11 <Axman6> -_-
07:20:18 <SamB_XP> EvilTerran: could YOU move?
07:20:27 <ejt> did anyone here do the ICFP contest this year ?  I just couldn't get interested
07:20:27 <EvilTerran> i was thinking that it'd be a mesh network kinda thing - any group of units and structures close enough together could communicate
07:20:34 <SamB_XP> also, could more than one human play on the same side?
07:21:07 <EvilTerran> SamB_XP, i was thinking that each player would be in a ship in orbit or something, and your "command centres" would have sattelite dishes or what-have-you
07:21:24 <Peaker> EvilTerran: I'd be happy if I could get a bunch of dragoons to go out without those stuck behind others starting to go the opposite direction...
07:21:38 <Peaker> EvilTerran: requiring you to repeat any command you give again and again until its fully completed
07:21:42 <EvilTerran> so multiple command centres, and anything near them, could communicate no matter how far apart the command centres were
07:22:17 <EvilTerran> SamB_XP, alternatively, having a single "general" building or unit representing the player would be potentially more interesting
07:23:34 <SamB_XP> EvilTerran: could vary from scenerio to scenerio
07:23:43 <SamB_XP> between campaigns or otherwise
07:23:47 <EvilTerran> indeed
07:24:01 <EvilTerran> a game could consist of "kill everyone else's generals"
07:24:20 <Shiruka> so.. about SCC annotations: http://hpaste.org/9981
07:24:23 <SamB_XP> what would happen to orphaned units?
07:24:44 <EvilTerran> they'd have to rely on their programming entirely, i guess
07:24:52 <Shiruka> granted, nfib' n = nfib n is crying for being optimized away, but still, optimizing the SCC away too isn't so nice :-(
07:24:57 <EvilTerran> although the player would be out of the game
07:24:57 <ejt> we need an irc server that detects off topic conversation and moves people to a new channel
07:25:02 <Shiruka> is there a way to prevent that other than lifting the function to toplevel?
07:25:12 <EvilTerran> ejt, i intend to implement this in haskell, it's on-topic :P
07:25:23 <Shiruka> (and why doesn't it optimize it away when at toplevel, it's not exported anyway..)
07:25:44 <EvilTerran> SamB_XP, that presents the interesting possibility of one player killing another's general, then losing their general to an orphaned unit on autopilon
07:25:48 <EvilTerran> *pilot
07:26:08 <quicksilver> Shiruka: looks like the inlining is breaking the SCC
07:26:13 <EvilTerran> people could even program their units to go kamikaze nad trying to avenge their general ;)
07:26:19 <EvilTerran> s/nad//
07:26:41 <GremlinHunter> How about limited battery life, only to be recharged from other robots or HQ
07:26:45 <SamB_XP> hmm, it'd be important to include such information in the final report ;-)
07:27:02 <Shiruka> quicksilver: adding a NOINLINE doesn't change the result..
07:27:03 <GremlinHunter> So you could send out large battery robots as refueling bots
07:27:11 <SamB_XP> GremlinHunter: only at night ;-P
07:28:06 <SamB_XP> so, what would be the ad-hoc networking capabilities of these units?
07:28:14 <GremlinHunter> That would be a good tactical choice -- do I weaken my robots by continuing or let them sleep, defenseless
07:28:44 <Shiruka> I'm using toplevel functions and -auto-all for now, but this was a bit surprising.. I didn't expect SCCs to be optimized away :-p
07:29:03 <SamB_XP> Shiruka: that IS a bit troubling, isn't it?
07:29:07 <Peaker> SCC?
07:29:16 <SamB_XP> Peaker: Source Cost Center
07:29:18 <Igloo> Shiruka: Can you file a bug please?
07:29:27 <SamB_XP> (not Strongly Connected Component)
07:30:25 <Shiruka> I only have GHC 6.8.2, maybe it's fixed in a later version?
07:30:39 <SamB_XP> Shiruka: file anyway
07:30:43 <Shiruka> (if it isn't intended that way)
07:30:57 <SamB_XP> not your responsibility to determine if it's been fixed or not!
07:31:03 <Shiruka> heh
07:31:05 <SamB_XP> (it's too much to expect, really)
07:31:08 <yitz> Igloo: how hard would it be for cabal to support listing source file to be compiled explicitly, and their names passed explicitly to ghc, rather than having ghc search for them?
07:31:26 <yitz> s/file/files
07:31:43 <RayNbow> @pl \f (a,b) (c,d) -> (f a c, f b d)
07:31:43 <Igloo> yitz: I don't think it would be hard, but dcoutts is the head Cabal dude
07:31:45 <psibot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
07:31:57 <SamB> yitz: why do you want that?
07:32:12 <EvilTerran> SamB_XP, i was thinking the networking would be fairly automatic - basically there'd be an ad hoc mesh network in any group of units allowing (near-)instant communication between any two units in that group
07:32:13 <yitz> ok. he doesn't seem to be around just now.
07:32:47 <EvilTerran> plus sattelite uplinks or long-range directional antennae or what-have-you
07:33:14 <ejt> EvilTerran: you could send code across the network ?
07:33:17 <EvilTerran> that could be used to connect these meshes together, perhaps with latency
07:33:23 <r3m0t> RayNbow: how elegant
07:33:26 <EvilTerran> ejt, well... i don't see why not
07:33:33 <yitz> SamB: see http://hackage.haskell.org/trac/ghc/ticket/2550 and the referenced cafe thread
07:33:35 <psibot> Title: #2550 (Add an option to read file names from a file instead of the command line) ...
07:33:48 <EvilTerran> ejt, it'd make sense to be able to update firmware mid-game, and i guess that's how you'd have to do it
07:33:54 <RayNbow> r3m0t: I was actually hoping for some obscure combinator :p
07:34:28 <ejt> EvilTerran: so the general unit could give orders by programming, so you probably don't need many units, at all
07:34:39 <ejt> s/units/unit types/
07:34:54 <EvilTerran> well, unit types would have different physical properties
07:35:04 <GremlinHunter> Could any datatype be transmitted, or would there be limits on type and size
07:35:21 <EvilTerran> RayNbow, i think you could do something nicer with Control.Arrow
07:35:43 <GremlinHunter> You could just do firmware updates by sending lambdas across the networks
07:36:01 <SamB> ejt: well, you might want some that are fast and lightly armored, perhaps with extended radio range
07:36:09 <SamB> and some that are slow and heavily armed
07:36:38 <SamB> and some that fly, and buildings ...
07:36:44 * shepheb wants to play this game
07:36:46 <SamB> and units that can build buildings
07:36:56 <EvilTerran> RayNbow, you'd start with join (***), i think
07:37:15 <GremlinHunter> How about just add components to a base unit, all with a cost and a draw on a power source
07:37:36 <SamB> GremlinHunter: you'd still want more than one chassis to choose from
07:37:40 <r3m0t> :t join
07:37:52 <r3m0t> @type join
07:37:53 <psibot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
07:38:27 <GremlinHunter> Couldnt you just add armour, jets, etc. do your liking?
07:38:36 <EvilTerran> GremlinHunter, ... foundations?
07:38:39 <MAC87_> 25gt9juioneruntvidezi0z80zx94h7jiut59uruzxjgeouh+
07:38:46 <SamB> probably a trike chassis, a humvee chassis, one or more tank chassises, and some construction-suitible chassises as well
07:38:49 <EvilTerran> RayNbow, i think you want (\f -> uncurry (***) . join (***) f)
07:38:55 <SamB> (is that the correct plural of chassis?)
07:39:01 <EvilTerran> chasses?
07:39:14 <quicksilver> :t \f -> uncurry (***) . join (***) f
07:39:24 <dmead> it's like deer singular and deer plural i think
07:39:28 <SamB> oh
07:39:33 <EvilTerran> chassis (plural: "chassis")
07:39:47 <EvilTerran> quicksilver, ?type and :t seem to be broken today
07:39:49 <ejt> how about we move over to #haskell-game ?
07:39:59 <SamB> maybe even a bike chassis ;-)
07:40:04 <dmead> k
07:40:08 <Wild_Cat> #haskell-game? There is such a channel?
07:40:09 <EvilTerran> ghci> :t \f -> uncurry (***) . join (***) f
07:40:09 <EvilTerran> \f -> uncurry (***) . join (***) f :: (Arrow a) => (b1 -> a b c) -> (b1, b1) -> a (b, b) (c, c)
07:40:25 <thoughtpolice> hi tibbe_
07:40:30 <SamB> Wild_Cat: there is now
07:40:37 <EvilTerran> i've said pretty much all i've worked out so far, really
07:40:43 * EvilTerran intends to think quietly about this some more
07:40:49 <BeelsebobWork_> @. pl djinn (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
07:40:51 <psibot> f = (`ap` snd) . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . (ap =<< (liftM2 (,) .))
07:40:56 <SamB> EvilTerran: are you coming anyway?
07:40:56 <tibbe_> thoughtpolice: hi :)
07:40:58 * BeelsebobWork_ giggles
07:40:59 <EvilTerran> we could go to #haskell-blah, though
07:41:06 <EvilTerran> rather than making a new channel
07:41:16 <thoughtpolice> tibbe_: how is nio coming?
07:41:20 <SamB> we already started talking there though
07:41:33 <EvilTerran> i have to go now, anyway. laters.
07:41:44 <yitz> @type \f -> uncurry (***) . (f ***f)
07:41:44 <psibot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
07:42:16 * EvilTerran does wonder, though, if viruses would appear in this game somehow
07:42:22 <tibbe_> thoughtpolice: connection a bit unstable it seems
07:42:28 <EvilTerran> infect your oppenents units and get them to fight for you :P
07:42:39 <dmead> map (disease) yourarmy
07:43:11 <dmead> the game world should definatly be full of contagions
07:43:55 <dmead> you know what i hate
07:44:07 <dmead> when one of your team mates is getting creamed and never calls for help
07:44:15 <SamB> EvilTerran: dmead was threatening to use memset(0, ...) on opposing armies
07:44:20 <SamB> in #haskell-game
07:44:25 <Peaker> dmead: check the damn minimap! :)
07:44:50 <SamB> well, that's what automated flares would be excellent for, I guess
07:44:58 <dmead> indeed
07:45:04 <SamB> though the downside would be that the enemies could see 'em too..
07:45:07 <dmead> your doods could throw a flare when attacked
07:45:20 <dmead> nah
07:45:25 <dmead> the marines just have to get on the horn
07:45:26 <dmead> and be like
07:45:32 <dmead> "CHARLIE EVERYWHERE NEED AIR SUPPORT"
07:45:44 <guenni> anybody know how to deal with haxml and unicode problems?
07:47:31 <quicksilver> guenni: what kind of problems?
07:47:46 <guenni> I have this xml doc in utf8
07:48:03 <quicksilver> then make sure you use a utf8 library to read it.
07:48:10 <quicksilver> the standard openFile is not utf8.
07:48:16 <guenni> how so?
07:48:44 <quicksilver> the standard openFile is a simple 8-bits-per-character file IO model.
07:48:49 <quicksilver> all of the standard IO stuff is.
07:49:00 <quicksilver> you need to use something else to load utf8
07:49:08 <guenni> how do I make it use the right one?
07:49:09 <yitz> RayNbow: psibot isn't doing types. anyway it looks like \ f -> uncurry (***) . (f *** f) does what you wanted. You can apply further @pl if you'd like. :)
07:49:19 <quicksilver> guenni: you don't make it do anything.
07:49:26 <quicksilver> guenni: you do the file reading, and you pass the String to HaXML.
07:49:32 <quicksilver> use, for example, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
07:49:34 <psibot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
07:49:38 <quicksilver> or one of the other utf8 packages.
07:49:50 <guenni> thx
07:50:09 <yitz> guenni: or dataenc package
07:50:16 <RayNbow> EvilTerran, yitz: thx for the help :)
07:51:08 <yitz> ah, I didn't see that EvilTerran already said that. sorry. :)
07:51:51 <RayNbow> I was playing around with (***), but I got stuck after (f *** f)
07:52:07 <guenni> just to get this right: I usually would do readFile and the pass that to haxml
07:52:13 * RayNbow should have thought about uncurry :p
07:52:40 <guenni> once I install utf8 do I then use readFile from the utf8 package?
07:53:04 <quicksilver> yes.
07:53:04 <guenni> or how exactly does this work?
07:53:16 <guenni> quicksilver: thx
07:53:17 <quicksilver> the utf8 version of readFile is exactly like the standard one, except it works on utf8 files.
07:53:39 <mmorrow> > maxBound :: Char
07:53:43 <psibot>  '\1114111'
07:54:55 <chrisdone> openJbovlaste path = ((JDB path <$>) <$> parseXMLDoc) <$> readFile path
07:54:55 <mmorrow> guenni: so for instance the unicode char "\2000" is utf8 encoded as "\223\144"
07:54:57 <chrisdone> taking it too far?
07:55:12 <guenni> mmorrow: ic, thx
07:58:26 <RayNbow> > let tmap f = join (***) f >>> uncurry (***)  in (3,4) `tmap (+)` (7,6)
07:58:26 <psibot>  Parse error at "(+)`" (column 61)
07:58:36 <RayNbow> oh wait
07:58:44 <RayNbow> > let tmap f = join (***) f >>> uncurry (***)  in tmap (+) (3,4) (7,6)
07:58:46 <psibot>  mueval: Prelude.read: no parse
07:59:27 <Myoma> > let tmap f (x,y) (u,v) = (f x u, g y v) in tmap (+) (3,4) (7,6)
07:59:30 <psibot>  Add a type signature
08:00:59 <Myoma> @pl foo (x,y) = e x *** e y
08:00:59 <psibot> foo = uncurry ((. e) . (***) . e)
08:01:02 <guenni> in which way are non-ascii strings escaped in haskell code?
08:01:18 <Myoma> guenni: they needn't be
08:01:32 <mmorrow> guenni: you mean outside of "...." right?
08:01:49 <guenni> well I don't seem to be able to "brige" into a .hs file
08:02:09 <guenni> I had to escape the umlaut
08:02:15 <mmorrow> > "Übrige"
08:02:17 <guenni> with \220 so far
08:02:18 <psibot>  "\220brige"
08:03:19 <guenni> I'm using ghc, I have so far not been able to use unescaped umlauts in the code
08:03:31 <mmorrow> guenni: hmm, what ghc version?
08:03:37 <guenni> 6.8.3
08:03:57 <guenni> on windows
08:04:05 <mmorrow> i'm not sure of the particulars, b...
08:04:11 <mc__> Would you guys recommend this book: http://www.amazon.de/gp/product/0134843460/ref=s9sims_c2_14_img1-rfc_p-3161_p?pf_rd_m=A1IDDPBG1NC5TQ&pf_rd_s=center-2&pf_rd_r=1GVQ06NJXGMPWGWQ44N9&pf_rd_t=101&pf_rd_p=214155091&pf_rd_i=301128 ?
08:04:14 <mmorrow> oh, that may have something to do with it
08:04:14 <psibot> http://tinyurl.com/5l29sd
08:04:22 <quicksilver> guenni: perhaps your editor is not saving the file in utf8 format.
08:04:24 <mmorrow> (windows), but i'm not sure
08:04:32 <quicksilver> guenni: (utf8 is not the default format for many windows programs)
08:04:42 <quicksilver> GHC is supposed to support UTF8 in source since 6.6, IIRC.
08:04:45 <guenni> true, that might be it then
08:04:50 <guenni> using emacs
08:05:10 <mmorrow> guenni: yeah, quicksilver's probably right. if not, i don't know
08:05:11 <guenni> mc__ : I do
08:05:50 <quicksilver> C-h v buffer-file-coding-system
08:05:52 <guenni> right, I'll figure out how to make emacs safe to utf8 and then try again, thx guys
08:05:59 <mc__> guenni: and you have read it personally?
08:06:06 <quicksilver> (will tell you how emacs thinkgs the current file is formatted)
08:06:14 <guenni> mc__: yes and many others too
08:06:38 <mc__> well, I guess then I'll go with it :)
08:07:17 <guenni> mc__ : are you German?
08:07:31 <mc__> guenni: actually I'm austrian
08:08:35 <guenni> mc__: close enough
08:10:48 <DrSyzygy> Guh! I tried updating my old gentoo box. And things started breaking.
08:11:12 <Myoma> "if it works, don't touch it"
08:11:16 <DrSyzygy> I'm currently in the vicious loop that updating darcs pulls in things from the layman overlay which in turn cannot be accessed since the overlay wasn't updated since I haven't yet updated darcs.
08:18:05 <dcoutts_> @seen augustss
08:18:05 <psibot> augustss is in #haskell. I don't know when augustss last spoke.
08:18:31 <dcoutts_> augustss: you wouldn't happen to know of a good reference for the inductive and co-inductive encodings of data in system F ?
08:19:24 <Saizan> dcoutts_: just pushed preprocessor chaining on ~saizan/cabal :)
08:19:32 <dcoutts_> augustss: the mu r. T r = forall r. (T r -> r) -> r and nu s. T s = exists s. s * (s -> T s) stuff?
08:19:36 <dcoutts_> Saizan: cool
08:19:46 <BMeph> RayNbow: ping
08:19:54 <zandax> hi
08:20:17 <telemach> hello, can someone give me a hint how to display binary numbers in haskell? i cannot find a suitable function in the prelude. do i have to roll my own?
08:20:42 <dcoutts_> Saizan: so when do you think is a natural point to pause and for us both to do our write ups?
08:21:19 <tromp> :t showIntAtBase
08:22:06 <tromp> > ()
08:22:11 <psibot>  ()
08:22:48 <Myoma> unlist 0 (\zs -> divMod zs base)
08:23:02 <Saizan> dcoutts_: http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html <- recursive types for free defines those, but it's a draft
08:23:03 <psibot> Title: Wadler: Parametricity
08:23:20 <Apocalisp> What was QuickCheck for C# called again?
08:23:23 <telemach> ah, great, thanks :).
08:23:27 <tromp> @let showBin = showIntAtBase 2 chr
08:23:30 <psibot> Defined.
08:23:40 <dcoutts_> Saizan: ah, I did half expect it'd be something by Wadler I'm looking for
08:23:46 <BMeph> telemach: working from the other showBase functions, do 'showIntAtBase 2 intToDigit'
08:23:47 <Myoma> unlist stop uncons ((==stop) -> True) = [] ; unlist stop uncons (uncons -> (ys,x)) = x : unlist stop uncons ys
08:23:47 <idnar> @type showBin
08:23:48 <psibot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
08:24:00 <Myoma> @type showIntAtBase 2 chr
08:24:00 <psibot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
08:24:02 <idnar> actually
08:24:11 <dcoutts_> Saizan: my supervisor said if I can't find a good reference then should just ask Wadler :-)
08:24:12 <Saizan> ..
08:24:17 <idnar> > showIntAtBase 44
08:24:20 <psibot>      Overlapping instances for Show
08:24:20 <psibot>                                 ((Int -> ...
08:24:24 <idnar> heh
08:24:38 <dolio> dcoutts_: Those are pretty straight forwardly related to the datatypes in question.
08:24:40 <idnar> don't you want (showIntAtBase 2) . intToDigit ?
08:25:12 <dolio> forall r. (T r -> r) -> r is the type of the fold for the initial algebra for T.
08:25:27 <dolio> And same for the other (the unfold for the terminal coalgebra).
08:25:34 <dolio> More or less.
08:25:43 <dcoutts_> dolio: I know what they are, I just need a canonical reference that says that those are the standard encodings of data types in system F
08:25:48 <BMeph> @src showHex
08:25:48 <psibot> Source not found. Sorry.
08:25:51 <dolio> Ah.
08:26:17 <zandax> I need to pass an abstract data type as the type itself but I also need access to the members. So far I only know that I can pass it itself or as a tuple. In other languages I would have simply done something like object.member. Is there a similar feature in Haskell?
08:26:26 <tromp> @let showBin = showIntAtBase 2 intToDigit
08:26:29 <psibot> Defined.
08:26:43 <zandax> I'm thankful for any hints :)
08:26:44 <Deewiant> > showBin 15
08:26:46 <psibot>  mueval: Prelude.read: no parse
08:26:49 <tromp> > showBin 11 ""
08:26:51 <psibot>  mueval: Prelude.read: no parse
08:27:01 <Myoma> zandax: it is not clear to me what you are actually asking
08:27:40 <BMeph> zandax: Are you asking about a record-style type?
08:27:56 <zandax> yes and how to pass it
08:27:56 <telemach> zandax: http://www.haskell.org/tutorial/moretypes.html
08:27:57 <psibot> Title: A Gentle Introduction to Haskell: Types, Again
08:28:04 <Saizan> @type id
08:28:06 <telemach> zandax: 6.2  Field Labels
08:28:06 <psibot> forall a. a -> a
08:28:28 <DrSyzygy> DRMacIver: darcs is currently broken on menme.
08:28:30 <zandax> I know that I can pass it as a tuple, like "function type = " or "function (a, b) = "
08:28:32 <DrSyzygy> Trying to fix it...
08:28:56 <DRMacIver> DrSyzygy: That's ok. I don't use darcs. :)
08:29:00 <zandax> But I need the members of the type and the it's members in the same function
08:29:00 <DrSyzygy> kk
08:29:03 <DRMacIver> And my code is all hosted elsewhere
08:29:09 <DRMacIver> But thanks for the heads up
08:29:31 <Saizan> zandax: export a member function?
08:29:32 <zandax> *tuple or it's identifier
08:29:34 <Myoma> zandax: perhaps if you have Foo x y z
08:29:35 <DrSyzygy> DRMacIver: In general - I tried (still trying) to do an update - caused by the profile it uses to be out of date. And things are breaking all over the place.
08:29:41 <Myoma> and a function xOf (Foo x y z) = x
08:29:43 <Myoma> then you could write
08:29:48 <Myoma> function (xOf -> x) = ....
08:29:51 <telemach> zandax: do you look for c(++)-style structures?
08:29:59 <zandax> yes
08:30:01 <Myoma> zandax: is that what you meant ?
08:30:30 <zandax> er...
08:30:44 <lumi> zandax: When you say "abstract", you mean the function is polymorphic?
08:30:49 <zandax> I don't know.
08:30:55 <mmorrow> @paste
08:30:56 <psibot> Haskell pastebin: http://hpaste.org/new
08:31:00 <mmorrow> :)
08:31:07 <zandax> @lumi: no, I thought "abstract" just means "non-algebraic" in that context
08:31:08 <psibot> Unknown command, try @list
08:31:42 <zandax> @Myoma: I don't know how to use you your code
08:31:42 <psibot> Unknown command, try @list
08:31:51 <lumi> zandax: Are you looking for: foo point@(Pt x y) ?
08:31:52 <rwbarton> zandax: "abstract data type" means the representation of the data type is hidden in another module, which exports operations on that data type
08:32:26 <rwbarton> zandax: so I think it's not what you mean?
08:32:32 <lumi> zandax: Where you name both the entire value and its subfields?
08:32:49 <zandax> yes lumi
08:32:56 <zandax> that was exactly what I'm looking for!
08:33:20 <lumi> HTH :)
08:34:20 <zandax> @rwbarton: I was refering to http://en.wikipedia.org/wiki/Abstract_data_type
08:34:20 <psibot> Unknown command, try @list
08:34:30 <zandax> Sorry, I will get it with the @ over time
08:38:21 <telemach> zandax: haskell hogs the brain too much in the beginning, we all know that. :)
08:38:40 <zandax> :D
08:38:48 <Myoma> before you are assimilated ---
08:41:45 <zandax> I'm feeling like I have to learn programming again from the beginning ;)
08:42:05 <telemach> oh, you do, kind of.
08:43:09 <zandax> But it's also cool to do the things with a completly new approach of course
08:43:20 <telemach> though in general haskell texts are more academic than they need to be.
08:43:41 <Myoma> @quote academic
08:43:41 <psibot> shapr says: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving
08:43:42 <psibot> silence...
08:44:31 <quicksilver> telemach: is that like being "more beautiful than you need to be" ? ;)
08:45:00 <zandax> The problem is that there is no big source for example codes. When I was learning other codes there were big projects of all kinds to learn from
08:45:15 <zandax> -codes *programming languages :/
08:45:46 <telemach> zandax: i heard a scheme course at university which helped a bit
08:45:50 <Myoma> there is lots of haskell code around
08:45:52 <jeffz> zandax: the source to the standard libraries can be useful
08:46:07 <lumi> zandax: There's a bunch of stuff in hackage
08:46:21 <telemach> it was based on "how to design programs"
08:46:22 <telemach> http://www.htdp.org/2003-09-26/Book/
08:46:23 <psibot> Title: How to Design Programs: An Introduction to Computing and Programming
08:46:58 <telemach> there are a lot of parallels to haskell.
08:47:35 <saya> zandax
08:47:36 <zandax> Is the majority of you guys here working as programmers?
08:47:37 <saya> http://hackage.haskell.org/packages/archive/pkg-list.html
08:47:39 <psibot> Title: HackageDB: packages by category
08:47:52 <telemach> zandax: i'm a physicist actually.
08:47:52 <zandax> tahnk you saya, I will have a look at it
08:48:29 <zandax> I see
08:48:30 <telemach> zandax: just doing my bachelor thesis with heavy number crunching. :)
08:48:38 <zandax> :)
08:49:33 <telemach> ok, i'm off to training.
08:49:34 <telemach> bye
08:49:38 <zandax> hf
08:51:33 <lumi> What's a good, simple, fairly complete GUI library?
08:52:06 <quicksilver> lumi: pick any one.
08:52:09 <lumi> Only I'm trying WX, and I'm having crazy trouble understanding how to use the Layouts
08:52:17 <zandax> They are all big and have thousands of features
08:52:23 <zandax> (which I don't need)
08:52:42 <lumi> Ah, available in Haskell, today, also
08:52:43 <quicksilver> lumi: sorry that wasn't clear. I meant "good, simple, or fairly complete" : you can pick any no more than one of the three.
08:52:52 <geev> your help please i have written c program but i fail compile with gcc
08:53:07 <Myoma> geev: I can't help you but maybe someone in ##c can
08:53:17 <lumi> quicksilver: OIC. Simple might do, then
08:53:41 <quicksilver> afaik the best options are wx or gtk, neither is simple.
08:53:42 <lumi> quicksilver: Where that means I'll be able to understand what it's doing and extend it
08:53:45 <quicksilver> I'm not aware of any simple ones.
08:54:42 <lumi> Phooey looks like it has something that makes layouts easier, but it seems to come with Phooey
08:54:52 <lumi> I mean, all around it
08:55:20 <zandax> oh my god. I have to do change a random value on a 2d map and I have no idea how to do it :(
08:55:41 <Myoma> zandax: What is a 2d map?
08:55:48 <zandax> A list of lists
08:56:03 <Myoma> and what exactly do you want to do to it?
08:56:08 <zandax> rendered as a quadratic map
08:56:22 <zandax> I am doing a game with collectible items.
08:56:40 <zandax> I need to change the value to remove the item when the player moves over it
08:56:43 <Myoma> zandax: so what type is the function you're trying to write
08:57:00 <Myoma> something like Coordinate -> Cell -> Board -> Board ?
08:57:19 <zandax> yes kinda like that
08:57:25 <Myoma> well what exactly is it?
08:58:06 <zandax> Coordinate -> Board -> Board should be enough
08:58:20 <Myoma> just curious what does it do?
08:58:55 <zandax> map !! x !! y = 0
08:59:19 <Myoma> so something you could use is
08:59:31 <Myoma> modifyElement :: [a] -> Integer -> (a -> a) -> [a]
08:59:46 <Myoma> modifyElement "xyz" 1 upcase = "xYz"
09:00:27 <Myoma> in a way like modifyElement board column (\col -> modifyElement col (const 0) row), or something like that
09:01:38 <zandax> looks promising! Can I also do numeric operations?
09:01:56 <Myoma> of course
09:02:02 <Myoma> > (const 0) 23453
09:02:07 <Myoma> > (
09:02:08 <Myoma> > (+2) 23453
09:02:08 <psibot> Unbalanced parentheses
09:02:10 <twanvl> Myoma: you should swap the order of the arguments, Int -> (a -> a) -> [a] -> [a]
09:02:17 <psibot>  thread killed
09:02:21 <Myoma> twanvl: oh good idea
09:02:23 <psibot>  thread killed
09:02:26 <dmead> is there docs somewhere on how to convert a program to use bytestrings instead of the slow [Char] ?
09:02:56 <zandax> I will try that one, thank you!
09:03:16 <quicksilver> twanvl: I tried to find your blog the other day and google failed me.
09:03:22 <quicksilver> twanvl: where's it gone?
09:03:49 <twanvl> quicksilver: http://twan.home.fmf.nl/blog/
09:03:51 <psibot> Title: 21 thoughts
09:04:18 <gwern> dmead: not really. it's pretty easy though. you do a pack to turn strings ino bytestring, use the bystring operators which are named the same as the usual string stuff often, and then unpack any time you need your Strings back
09:05:18 <quicksilver> twanvl: yay thanks.
09:07:48 <ziman> hm, interesting blog
09:09:16 <quicksilver> ziman: yes, it is. That's wy I was looking for it ;)
09:11:49 <ziman> a friend of mine made a bachelor thesis out of nonograms in Java, and haskell code is 147 LOC :)
09:13:23 <quicksilver> well bachelor theses are about effort rather than content, aren't they? :)
09:15:51 <dmead> gwern, gothca
09:15:57 <dmead> *gotcha
09:16:09 <ziman> yes, maybe :)
09:17:13 <gwern> quicksilver: I suppose one *would* have to pat him on the head for that...
09:17:38 <kake05> Hola, alguien habla espaol?
09:17:56 <quicksilver> kake05: not much, no.
09:18:10 <quicksilver> beyond ordering a beer and a paella.
09:18:17 <quicksilver> which isn't very helpful for haskell programming.
09:19:19 <lumi> instance Monoid Cerveza where
09:23:05 <dmead> gwern, do bytestrings make file io faster?
09:23:31 <gwern> I think so, in a general sense
09:23:52 <mmorrow> dmead: very much so
09:24:15 <gwern> but why not benchmark it? write a simple program - do a main = writeFile 'tmp' . readFile 'foo' and benchmark against main = B.writeFile 'tmp2' . B.readFile 'foo'
09:24:23 <gwern> the work at 10 minutes, max
09:24:29 <dmead> is there a bytestring version of readFile?
09:24:31 <gwern> the hardest part is finding a big file to try on...
09:24:43 <dmead> i got mad big files
09:25:14 <gwern> @hoogle readFIle
09:25:15 <psibot> A Hoogle error occurred.
09:25:16 <Beelsebob> gwern: writeFile "bigFile" $ take 10000000000 (repeat ' ')
09:25:27 <gwern> @hoogle readFile
09:25:27 <psibot> A Hoogle error occurred.
09:25:46 <mmorrow> dmead: also, if you're working with an actual FilePath and not just a Handle, there's bytestring-mmap as well  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap
09:25:48 <psibot> Title: HackageDB: bytestring-mmap-0.2.0, http://tinyurl.com/6xpfmw
09:26:05 <dmead> i am indeed
09:26:08 <gwern> Beelsebob: well, I think dmead would also care about read performance, not just write. it strikes mas as possible that writes are slow enough on modern disks that you wouldn't see a difference?
09:26:19 <gwern> Data.ByteString readFile :: FilePath -> IO ByteString
09:26:24 <Beelsebob> gwern: no, I'm indicating how to get a big file ;)
09:26:31 <Saizan> dmead: yes, but pay attention to the fact that Data.ByteString.readFile is strict, it will read all the file up front, while Data.ByteString.Lazy.readFile is lazy (surprise!) and will read it in chunks as demanded.
09:26:43 <dmead> awesome
09:26:44 <gwern> Beelsebob: oh. nm then
09:26:57 <dmead> i don't really care about writes
09:27:02 <dmead> i'm just saving a big emacs buffer
09:27:03 <dmead> =)
09:27:04 <gwern> Saizan: in this case, lazy would just hurt performance wouldn't it?
09:27:06 * SamB wonders what the signum of a quaternian is
09:27:23 <dmead> lazy evaluation if you will
09:27:26 <dmead> zing!
09:27:40 <Deewiant> SamB: signum . determinant
09:27:40 <Saizan> gwern: i guess it depends on the size of your ram vs. the size of the file
09:27:56 <mmorrow> dmead: import Data.ByteString.Char8 (ByteString) ; import qualified Data.ByteString.Char8 as B ; main = B.putStr . (whereIDoStuff :: ByteString -> ByteString) =<< B.getContents
09:28:36 <mmorrow> (assuming a filter type program, but that's the boilerplate import strategy)
09:31:36 <saya> SamB: quaterniOn !
09:35:33 <SamB> saya: oops
09:35:40 <zandax> why does the last generator in do {...} needs to be an expression? :/
09:36:53 <ziman> because do needs to return a value
09:36:59 <Myoma> generator? :D
09:37:07 <Myoma> I think you just wrote a monad tutorial
09:37:08 <SamB> zandax: why isn't "getChar >>=" a valid expression ?
09:37:16 <ziman> (do is a syntactic sugar for a >>, >>= sequence)
09:37:26 <SamB> or even "getChar >>= \x ->"
09:37:49 <zandax> hm
09:38:07 <saya> yeah the result must be of form SomeMonad Stuff
09:38:16 <Samy> @tell vixey "Foundations of Inductive Logic Programming" is a great book, has a decent introduction into model theory
09:38:17 <psibot> Consider it noted.
09:38:23 <mmorrow> :t (getChar >>=)
09:38:26 <psibot> forall b. (Char -> IO b) -> IO b
09:38:26 <zandax> tricky
09:38:43 <mmorrow> :t (=<< getChar)
09:38:46 <psibot> forall b. (Char -> IO b) -> IO b
09:41:00 <quicksilver> zandax: alternatively you could just say that do {a <- getChar} is daft.
09:41:07 <quicksilver> zandax: why collect "a" and not use it.
09:42:11 <zandax> I see
09:42:42 <mmorrow> :t (=<< do {a <- getChar ; return a})
09:42:44 <psibot> forall b. (Char -> IO b) -> IO b
09:43:38 <mmorrow> :t (=<< (getChar >>= return))
09:43:42 <psibot> forall b. (Char -> IO b) -> IO b
09:45:15 <Myoma> :t (=<<(?f>>=))
09:45:17 <psibot> forall b (m :: * -> *) a b1. (Monad m, ?f::m a) => (m b1 -> (a -> m b1) -> b) -> (a -> m b1) -> b
09:45:57 <mmorrow> :t (=<< ?f)
09:46:00 <psibot> forall a (m :: * -> *) b. (Monad m, ?f::m a) => (a -> m b) -> m b
09:46:49 <mmorrow> whoa, i didn't know about this ?f business
09:46:57 <Myoma> it is so awesome
09:47:00 <Myoma> :t ?f ?x
09:47:07 <psibot> forall t t1. (?x::t, ?f::t -> t1) => t1
09:47:12 <Samy> what does it do?
09:47:12 <Myoma> it's just an GOA thing I think
09:47:15 <Samy> oh
09:47:16 <Myoma> Samy!
09:47:17 <Myoma> :)
09:47:19 <Saizan> psibot: @join #darcs
09:47:20 <Samy> hi!?
09:47:21 <mmorrow> i just tried it in ghci and it worked
09:47:30 <Samy> I'm not the Persian one
09:47:36 <Myoma> aww
09:47:40 <Myoma> Prelude> :t ?f ?x
09:47:40 <Myoma> <interactive>:1:0: parse error on input `?'
09:47:43 <Myoma> I don't have it
09:47:54 <mmorrow> ghci> :t (=<< ?f)
09:47:54 <mmorrow> (=<< ?f) :: forall a (m :: * -> *) b. (Monad m, ?f::m a) => (a -> m b) -> m b
09:47:56 <Myoma> but yeah it is super useful
09:48:02 <mmorrow> [m@ganon src]$ ghc -V
09:48:02 <mmorrow> The Glorious Glasgow Haskell Compilation System, version 6.9.20080504
09:48:15 <Myoma> The Glorious Glasgow Haskell Compilation System, version 6.9.20080619
09:48:20 <quicksilver> it's a glasgow-exts thing I think
09:48:21 <mmorrow> weird
09:48:22 <Myoma> I am winning!!
09:48:26 <mmorrow> ah
09:48:28 <quicksilver> or -XImplicitParameters or something.
09:48:46 <mmorrow> i have this in my ghci
09:48:48 <mmorrow> :set -fglasgow-exts -O2 -fno-print-bind-result
09:48:48 <mmorrow> :set -XQuasiQuotes -XTemplateHaskell
09:49:10 <Myoma> :set -XPatternSignatures :set -fno-monomorphism-restriction :set -XViewPatterns :set -XEmptyDataDecls :set -XMultiParamTypeClasses :set -XFunctionalDependencies :set -XFlexibleContexts :set -XTypeSynonymInstances :set -XFlexibleInstances :set -XGADTs
09:49:11 <mmorrow> ahh, ok so it /is/ implicit parameters. i thought that at first, then convinced myself otherwise
09:49:13 <Myoma> thas's my ghci
09:49:52 <mmorrow> Myoma: add -XQuasiQuotes -XTemplateHaskell :)
09:50:35 <mmorrow> i wonder if :set -O2 actually does anything
09:51:34 <mmorrow> <Myoma> I am winning!!
09:51:36 <Myoma> :set -funroll-loops
09:51:36 <mmorrow> haha
09:51:49 <mmorrow> ooh, /me adds -funroll-loops
09:52:06 * Myoma made up this flag.. :p
09:52:11 <mmorrow> hahah
09:52:15 <mmorrow> damn
09:52:35 <GremlinHunter> mmorrow: In the ghci manual I think it says you cant optimize code from ghci
09:52:52 <mmorrow> GremlinHunter: :(
09:53:28 <ddarius> -funfolding-fun-discount
09:53:44 <GremlinHunter> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-faq.html
09:53:46 <psibot> Title: 3.11.�FAQ and Things To Watch Out For, http://tinyurl.com/377cw9
09:53:52 <mmorrow> -ffifty-percent-discount-sunday-only
09:55:10 <GremlinHunter> unrecognised flags: -fubar :(
09:55:57 <BMeph> unrecognised flags: -foobar
09:56:00 <Myoma> java is a more academic language
09:56:02 <BMeph> :)
09:56:32 <mmorrow> Myoma: i dunno, i think VB has it beat there
09:56:40 <DukeDave> > map ((+) 1) [1..4]
09:56:49 <psibot>  [2,3,4,5]
09:57:02 <DukeDave> Zomg, where's lambdabot? :o
09:57:24 <mmorrow> > zipWith ($) (map (+) (repeat 1)) [1..4]
09:57:27 <psibot>  [2,3,4,5]
09:57:52 <Myoma> > map (uncurry (+)) . zip [1,1..] $ [1..4]
09:57:55 <psibot>  [2,3,4,5]
09:58:08 <mmorrow> > zipWith ($) (cycle (+1)) [1..4]
09:58:08 * DukeDave puts on his unfoldr hat
09:58:10 <psibot>      The section `(+ 1)' takes one argument,
09:58:10 <psibot>     but its type `[a -> b]' has ...
09:58:13 <Myoma> :D
09:58:20 <mmorrow> > zipWith ($) (cycle [(+1)]) [1..4]
09:58:20 <DukeDave> Hehe
09:58:23 <psibot>  [2,3,4,5]
09:58:37 <EvilTerran> > zipWith ($) (repeat (+1)) [1..4]
09:58:40 <psibot>  [2,3,4,5]
09:58:57 <BMeph> >  uncurry (***) (`div` 10) (25,36)
09:58:59 <psibot>      The section `(`div` 10)' takes one argument,
09:58:59 <psibot>     but its type `(a b c, a...
09:59:19 <mmorrow> > zipWith ($) (fix . (:) $ (+1)) [1..4]
09:59:20 <BMeph> Bah. :P
09:59:22 <psibot>  [2,3,4,5]
09:59:29 <Deewiant> > join (***) (`div` 10) (25,36)
09:59:31 <psibot>  mueval: Prelude.read: no parse
09:59:36 <Deewiant> O_o
09:59:49 <mmorrow> > (***)
09:59:52 <psibot>      Overlapping instances for Show
09:59:52 <psibot>                                 (a b c ->...
10:00:02 <EvilTerran> (***) doesn't seem to agree with @run at the moment
10:00:02 <mmorrow> > (`div`10) 1
10:00:05 <psibot>  0
10:00:09 <EvilTerran> join (***) doesn't, anyway
10:00:14 <EvilTerran> i was playing with it in /msg earlier
10:00:15 <mmorrow> > join (***)
10:00:18 <psibot>      Overlapping instances for Show (a b c -> a (b, b) (c, c))
10:00:18 <psibot>       arising ...
10:00:21 <GremlinHunter> :t (***)
10:00:21 <Deewiant> meh
10:00:24 <psibot> Not in scope: `***'
10:00:25 <DukeDave> > unfoldr (\x -> if x > 5 then Nothing else Just (x, x+1)) 2
10:00:26 <BMeph> >  uncurry (***) (`div` 10,`div` 30) (25,36)
10:00:27 <psibot>  Parse error at ",`div..." (column 24)
10:00:28 <mmorrow> > join (***) (+1) (0,0)
10:00:28 <psibot>  [2,3,4,5]
10:00:30 <psibot>  mueval: Prelude.read: no parse
10:00:39 <mmorrow> weird
10:00:41 <GremlinHunter> What is ***?
10:00:41 <Myoma> oh
10:00:45 <EvilTerran> > ((+1) *** (+2)) (3,4)
10:00:46 <BMeph> >  uncurry (***) ((`div` 10),(`div` 30)) (25,36)
10:00:51 <psibot>  mueval: Prelude.read: no parse
10:00:52 <psibot> Terminated
10:00:52 <Myoma> @let bool true false True = true ; bool true false False = false
10:00:52 <DukeDave> GremlinHunter: I was just about to ask the same :)
10:00:55 <psibot> Defined.
10:01:01 <EvilTerran> ?hoogle (***)
10:01:01 <psibot> A Hoogle error occurred.
10:01:02 <DukeDave> :type (***)
10:01:09 <DukeDave> ?type (***)
10:01:11 <psibot> Not in scope: `***'
10:01:13 <GremlinHunter> Something to do with Arrows.
10:01:22 <mmorrow> Myoma: heh
10:01:24 <GremlinHunter> Not that I know what arrows are :)
10:01:26 <EvilTerran> (***) :: Arrow (~>) => (a ~> b) -> (c ~> d) -> (a,c) ~> (b,d)
10:01:40 <EvilTerran> the Arrow class is a generalisation of functions, approximately
10:01:59 * Myoma is forever defining folds
10:02:09 <DukeDave> I think I was just about to rise to Arrows before I stopped using Haskell for a few months
10:02:12 <mmorrow> @check \x -> not x == (bool False True) x
10:02:15 <psibot>  mueval: Time limit exceeded
10:02:19 <EvilTerran> but its functions are useful as combinators, just using the (->) instance
10:02:19 <Myoma> oh but I did find that CPS may be better than folds
10:02:22 <Philonous> @bot
10:02:22 <psibot> :)
10:02:22 <GremlinHunter> Any good intros to arrows?
10:02:24 <mmorrow> @check \x -> not x == (bool False True) x
10:02:26 <psibot> Terminated
10:02:30 <Myoma> for the printer/parser thing
10:02:56 <mmorrow> Myoma: interesting
10:03:23 <Myoma> drop'k O k = k [TO]
10:03:23 <Myoma> drop'k (Add u v) k = drop'k u (\u' ->
10:03:24 <Myoma>                      drop'k v (\v' ->
10:03:24 <Myoma>                      k ([TLPar] ++ u' ++ [TAdd] ++ v' ++ [TRPar])))
10:03:33 <Myoma> lift'k (TO:ts) k = k O ts
10:03:34 <Myoma> lift'k (TLPar:ts) k = lift'k ts (\u (TAdd:ts) ->
10:03:34 <Myoma>                       lift'k ts (\v (TRPar:ts) ->
10:03:34 <Myoma>                       k (Add u v) ts))
10:03:42 <Myoma> they actually _look_ like inverses
10:03:45 <ddarius> $ \u ->
10:03:54 <DukeDave> Myoma: Wah?
10:04:06 <EvilTerran> Myoma, ... now i want to eliminate the apparent duplication  there :P
10:04:11 <mmorrow> i love that $ \k ->
10:04:42 <BMeph> go oblivious idioms
10:04:48 <BMeph> ?go oblivious idioms
10:04:50 <psibot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:04:51 <psibot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
10:04:51 <mmorrow> heh
10:05:16 <EvilTerran> Myoma, as ddarius says, replacing those "(\"s with "$ \" will save you having to count parentheses
10:05:24 <BMeph> GremlinHunter: ^^ is *NOT* a good intro, but it's a great follow-up. :)
10:05:33 <DukeDave> Heh, this is going to be fun isn't it :|
10:05:54 <mmorrow> i find that mixing  $ \k ->   and   (\k ->    improve readability sometimes
10:06:01 <mmorrow> *improves
10:06:11 <Myoma> DukeDave: hmm?
10:06:15 <ddarius> mmorrow: This is not one of those cases.
10:06:35 <mmorrow> ddarius: yeah, it would break the symmetry :)
10:06:38 <DukeDave> The paper BMeph just linked
10:08:10 <BMeph> ?go new Arrows
10:08:12 <psibot> http://submissions.agile2008.org/node/2054
10:08:12 <psibot> Title: New arrows for the Agile quiver: Now that the team's head is in the game, how do ...
10:08:29 <BMeph> ?wiki Arrows
10:08:29 <psibot> http://www.haskell.org/haskellwiki/Arrows
10:08:54 <Deewiant> @pl f u (\u' -> f v (\v' -> k ([a] ++ u' ++ [b] ++ v' ++ [c])))
10:08:54 <psibot> f u (f v . ((k . (a :)) .) . (. ((b :) . (++ [c]))) . (++))
10:09:37 <_zenon_> ah, much better
10:09:40 <_zenon_> errrr
10:09:47 <BMeph> GremlinHunter, DukeDave: I like http://www.haskell.org/arrows/ as an intro to arrows. :)
10:09:48 <psibot> Title: Arrows: A General Interface to Computation
10:10:06 <_zenon_> BMeph, the illustrations are very clear
10:10:17 <Deewiant> @pl \f -> f u (\u' -> f v (\v' -> k u' v'))
10:10:17 <psibot> ap ($ u) ((. k) . ($ v))
10:10:30 <GremlinHunter> Pretty pictures!
10:11:21 <BMeph> Myoma: I put your drop'... and lift'... stuff at http://hpaste.org/9982
10:11:37 <DukeDave> Owh, its was so nice & friendly until they dropped "called Freyd-categories or (more generally) premonoidal notions of computation" in there *_*
10:11:43 <Myoma> why? :p
10:12:10 <_zenon_> Some day someone should add Data.Strict to hackage with all cumulated strict functions people have made
10:13:53 <BMeph> _zenon_: I'd prefer if they called it Data.Non-Lazy, myself. ;)
10:14:41 <_zenon_> or Functions.Non.Lazy thus Functions.Non.Strict would be the standard set of lazy functions :)
10:15:09 <EvilTerran> Data'.List ?
10:16:38 <stepcut> EvilTerran: heh
10:17:28 <EvilTerran> (or just Data' , if you don't want to separate them out by type)
10:17:53 <EvilTerran> shouldn't be Data.List', though - that should be a strict list type, not strict operations on normal lists :P
10:18:12 <Myoma> what is the use of a strict list?
10:18:51 <ddarius> Head strict lists are probably what one usually wants.
10:19:08 <ddarius> CONS should not CONS it's CDR
10:24:14 <dons> data StrictList a = Empty | Cons !a (StrictList a) -- has its uses
10:24:25 <dons> esp. monomorphic versions, can sometimes have better performance.
10:24:59 <Myoma> can't the optimizer figure it out?
10:25:11 <Myoma> at  least potentially
10:25:15 <dons> potentially.
10:25:17 <ddarius> Myoma: There's nothing to "figure out".  The semantics are just different.
10:25:30 <dons> ghc doesn't change data representations for polymorphic structures yet, much.
10:25:35 <Mitar> is there already defined function which takes as an argument a function with type [a] -> [a] and a list and applies that function to a list until the resulting list is a singleton?
10:25:45 <dons> so [a] used in a strict manner won't turn into [{-UNPACK-}!a]
10:25:48 <ddarius> As a rule of thumb recursive components should be lazy and non-recursive ones strict.
10:25:54 <dons> yep.
10:25:55 <dons> good rule.
10:26:02 <dons> atomic types, strict.
10:26:26 <dons> maybe i should add that as a point to the RWH optimisation chapter.
10:26:31 <Deewiant> Mitar: use takeWhile, iterate, and a function which checks for length 1
10:27:30 <Myoma> I never wrote a program in haskell that is kept running for a very long time or has to work through megabytes of data
10:27:47 <Myoma> and that is why I never had to use strictness?
10:28:16 <dons> well, the compiler is pretty smart too.
10:29:03 <ddarius> One nice thing about e.g. head strict lists is that you can get fully lazy lists back from them.  data Box a = Box a; type [a] = HeadStrictList (Box a)
10:29:50 <dons> yep. we use that in streams, fwiw, where the default state is strict, but you wrap a Box to bring back laziness
10:32:01 <Myoma> weird
10:32:06 <Myoma> it's like scheme
10:36:05 <zandax> hm
10:37:00 <zandax> Is there a better way to modify an element in a list than splitting it, removing an element and adding a new one?
10:37:07 <Myoma> no
10:37:19 <zandax> :(
10:37:23 <Myoma> don't worry :)
10:37:33 <lumi> There's zippers
10:37:39 <ddarius> zandax: If you want to do that, you probably don't want to use a list.
10:37:42 <Myoma> that's what a zipper does
10:37:54 <zandax> @ddarius: are there arrays in Haskell?
10:37:55 <psibot> Unknown command, try @list
10:38:09 <ddarius> zandax: Tons, but that is also probably not what you want.
10:38:10 <Deewiant> zandax: yes, see Data.Array
10:38:17 <falbani> hi
10:38:37 * ddarius doesn't know where this "Haskell doesn't have arrays" stuff comes from.
10:38:38 <zandax> ok
10:38:57 <Deewiant> I guess they don't count unless they're built-in
10:39:20 <Myoma> ST is good
10:40:06 <rog> what's the situation with unicode symbol names in ghc? it seems to allow (for example) lambda (0x03bb) as a name but not sum-of (0x2211).
10:40:38 <rog> is it restricted to unicode-classified "alphabetic" characters?
10:40:42 <Myoma> 'sum-of' i suppercase?
10:40:49 <Myoma> and lambda is lowercase
10:41:05 <Deewiant> rog: yes, you might be allowed to use it in an operator though
10:41:21 <Myoma> it would be sensible if the lanugage has a directive like infixr to let you choose
10:41:31 <Deewiant> and what Myoma said as well, lower/upper case rules apply for all Unicode, not just ASCII
10:41:34 <falbani> I'm writing a simple module for handling poker decks, and I want to be able to show this symbols: ♠♣♥♦, but ghci cannot do it... any idea how to set up?
10:42:14 <falbani> (vim & urxvt can show them nice)
10:42:32 <rog> Deewiant: yes, that's it. i can now use, for example, star-in-circle (229b) as an operator. so i'm happy. i should have thought of that.
10:43:20 <Deewiant> falbani: I think you need a utf-8 library, the default IO doesn't really work well with unicode
10:43:58 <falbani> Deewiant: something I can solve importing anything?
10:44:51 <rog> ... could be confusing when one doesn't know whether a letter in a particular language is upper or lower case though.
10:45:04 <lelf> falbani: you can just import System.IO.UTF8
10:45:12 <Deewiant> falbani: I'm fairly certain you need a library, for instance http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-light
10:45:15 <psibot> Title: HackageDB: utf8-light-0.3, http://tinyurl.com/5nbge9
10:45:36 <rog> ⊛
10:45:39 <Deewiant> lelf: eh, where's that
10:45:56 <rwbarton> falbani: (btw, this should be fixed when 6.10 comes out in a month or so)
10:45:58 <falbani> It is not shipped with ghc?
10:46:17 <Deewiant> ah, utf8-string
10:46:19 <lelf> Deewiant: utf8-string
10:46:20 <Deewiant> falbani: and no, it's not
10:46:39 <SamB_XP> rwbarton: fixed in what sense?
10:46:40 <ddarius> @hackage utf8-stritng
10:46:40 <psibot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-stritng
10:46:45 <ddarius> @hackage utf8-string
10:46:45 <psibot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
10:48:12 <falbani> libghc6-utf8-string-dev         - GHC 6 libraries for the Haskell UTF-8 libr  <--- I got this from aptude search ghc|grep utf   in a Debian Lenny
10:48:18 <falbani> Is the same?
10:48:27 <Deewiant> sounds like it
10:48:41 <rwbarton> SamB_XP: in that IO will assume utf8 encoding by default, with some mechanism for specifying pure byte-based IO.
10:48:47 <rwbarton> SamB_XP: Whether this is really a fix is debatable
10:49:19 <ddarius> Won't that break old code?
10:49:32 <rwbarton> Seems that way to me
10:50:05 <Deewiant> given that putStrLn eats Strings, which are Unicode, it's the old code that is broken if it's outputting any non-ASCII...
10:50:13 <rwbarton> Well, the encoding will be locale-dependent.  http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
10:50:16 <psibot> Title: Status/Releases - GHC - Trac
10:50:52 <falbani> does importing System.IO.UTF8 overrides thing automatically?
10:51:07 <ddarius> falbani: Nothing overrides anything automatically.
10:51:22 <Deewiant> hmm, I wonder what it does if given a higher-than-255 byte in a non-UTF-using locale
10:51:38 <SamB_XP> Deewiant: it depends on what encoding is in use
10:51:46 <Deewiant> SamB_XP: ISO-8859-1
10:51:57 <Deewiant> (or windows-1252, probably more common)
10:52:01 <falbani> ddarius: I can see... I need to replace "show"?
10:52:07 <rwbarton> Deewiant: probably what it does now
10:52:21 <Deewiant> yeah, probably
10:52:35 <ddarius> falbani: show has nothing to do with output
10:52:47 <rwbarton> falbani: "show" is fine, I think you want   import Prelude hiding (print)   import System.IO.UTF8 (print)   and so on
10:52:59 <falbani> oh... thanks
10:53:30 <falbani> I have always been very confused with encodings, etc. :P
10:55:21 <rog> what is "standard applicative style"?
10:56:10 <falbani> *Main> print Club
10:56:11 <falbani> ♣
10:56:11 <falbani> *Main> Club
10:56:11 <falbani> c
10:56:23 <Myoma> f <$> x <*> y <*> z -- probably
10:56:24 <falbani> Why it does that?
10:56:49 <dons> falbani: nice.
10:56:56 <Deewiant> falbani: probably ghci uses a non-UTF8 print internally
10:57:05 <dons> falbani: oh, interesting.
10:57:12 <dons> show versus print, hmm
10:57:16 <rog> (the quote comes from http://www.soi.city.ac.uk/~ross/papers/Applicative.html, which seems like it's quite straightforward, but i'm finding it hard going...)
10:57:17 <psibot> Title: Applicative Programming with Effects
10:57:34 <Deewiant> dons: my guess it's because his print is from System.IO.UTF8 and GHCi's is not
10:58:20 <dons> ah maybe.
10:58:50 <falbani> Deewiant: you are right
10:59:09 <Deewiant> yay
10:59:37 <dmead> @hoogle odds
10:59:37 <psibot> A Hoogle error occurred.
10:59:40 <dmead> :<
10:59:42 <dmead> :t odds
10:59:45 <psibot> Not in scope: `odds'
11:00:13 <Deewiant> > [1,3..]
11:00:19 <psibot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
11:00:49 <lelf> oh, ψbot
11:01:15 <falbani> http://hpaste.org/9984
11:02:30 <falbani> Is that a good way of dealing with utf8 chars?
11:03:13 <falbani> It would be nice if I can use the module from ghci
11:03:14 * SamB_XP wonders if gamecube discs are DVD
11:03:16 <lelf> utf-8 chars? :)
11:03:38 <dmead> i mean odds as in every other member of a list
11:03:47 <ddarius> falbani: Nothing in that code does anything at all with UTF-8 characters.
11:03:57 <Deewiant> SamB_XP: they're not
11:05:09 <SamB_XP> Deewiant: what are they?
11:05:21 <Deewiant> SamB_XP: they're gamecube discs :-P
11:05:30 <Deewiant> SamB_XP: http://en.wikipedia.org/wiki/Nintendo_optical_discs
11:05:31 <psibot> Title: Nintendo optical disc - Wikipedia, the free encyclopedia
11:05:59 <rwbarton> falbani: looks good, just remember you're only using the utf8-enabled print, you might also want putStr, putStrLn, ...
11:06:03 <rwbarton> falbani: http://hackage.haskell.org/packages/archive/utf8-string/0.3.1.1/doc/html/System-IO-UTF8.html
11:06:05 <psibot> Title: System.IO.UTF8, http://tinyurl.com/6s38q7
11:07:28 <SamB_XP> hmm, I wonder if DVD firmware can be updated to read it
11:07:41 <SamB_XP> since apparantly it's just a CAV variant of DVD
11:07:54 <falbani> ddarius: forgive my ignorance, I just want ghci to be able to show ♠♣♥♦...
11:08:03 <dmead> let odds ([]) = [] ; odds (x:y:xs) = odds (x:xs) in odds [1..10]
11:08:12 <dmead> let odds ([]) = [] ; odds (x:y:xs) in odds (x:xs) in odds [1..10]
11:08:14 <dmead> erpagergaer
11:08:17 <dmead> > let odds ([]) = [] ; odds (x:y:xs) in odds (x:xs) in odds [1..10]
11:08:17 <psibot>  Parse error at "in" (column 36)
11:08:38 <Deewiant> you had it right the first time
11:08:38 <dmead> > let odds ([]) = [] ; odds (x:y:xs) ; odds (x:xs) in odds [1..10]
11:08:39 <psibot>  Parse error at ";" (column 36)
11:08:41 <Deewiant> (well, almost)
11:08:50 <Deewiant> dmead: =
11:08:52 <dmead> woops
11:08:54 <dmead> ja
11:09:05 <dmead> > let odds ([]) = [] ; odds (x:y:xs) = odds (x:xs); in odds [1..10]
11:09:09 <Deewiant> the syntax was right, the code wasn't. :-P
11:09:15 <psibot>  * Exception: /tmp/600906755:52:50-93: Non-exhaustive patterns in function odds
11:09:40 <dmead> > let odds ([]) = [] ; odds (x:[]) = [] ; odds (x:y:xs) = odds (x:xs); in odds [1..10]
11:09:43 <psibot>  []
11:09:45 <dmead> gah
11:10:06 <Deewiant> > let odds (x:y:xs) = x : odds xs; odds x = x in odds [1..10]
11:10:08 <psibot>  [1,3,5,7,9]
11:10:16 <yitz> dons: my irc client is acting funny. did you say something to me?
11:10:16 <dmead> eh eh
11:10:21 <dmead> yea i saw that
11:10:37 <dons> yitz: "hi"
11:10:46 <yitz> :) hi
11:10:52 <ddarius> falbani: The problem is in GHCi itself.  You could get the characters to print out in GHCi (I'm pretty sure,) but what you'd need to do would lead to massive confusion later on
11:13:28 <Myoma> hm
11:14:30 <Myoma> > let odds (x:y:zs) = Just ((x,y),zs) ; odds [] = Nothing ; unfoldr odds [1,2,3,4,5,6]
11:14:30 <psibot>  Parse error at end of input
11:14:34 <Myoma> > let odds (x:y:zs) = Just ((x,y),zs) ; odds [] = Nothing in unfoldr odds [1,2,3,4,5,6]
11:14:37 <psibot>  [(1,2),(3,4),(5,6)]
11:14:53 <Deewiant> > let odds (x:y:zs) = Just ((x,y),zs) ; odds [] = Nothing in unfoldr odds [1,2,3,4,5]
11:14:56 <psibot>  [(1,2),(3,4)* Exception: /tmp/1418105818:52:58-108: Non-exhaustive patterns ...
11:15:09 <Myoma> > head []
11:15:12 <psibot>  * Exception: Prelude.head: empty list
11:15:29 <dmead> you need single element case for odds
11:15:34 <Myoma> no I don't
11:15:36 <Myoma> :p
11:15:40 <Myoma> Just let it be partial
11:15:43 <dmead> Deewiant, does
11:16:02 <Deewiant> > let odds x = let (a,b) = splitAt 1 x in if null a then [] else if null b then [head a] else head a : f (tail b) in odds [1..10]
11:16:04 <psibot>      No instance for (SimpleReflect.FromExpr [t])
11:16:05 <psibot>       arising from a use of...
11:16:11 <Deewiant> oops
11:16:15 <Deewiant> > let odds x = let (a,b) = splitAt 1 x in if null a then [] else if null b then [head a] else head a : odds (tail b) in odds [1..10]
11:16:19 <psibot>  [1,3,5,7,9]
11:18:10 <Deewiant> > let odds [] = []; odds x = take 1 x ++ odds (drop 2 x) in odds [1..10]
11:18:14 <psibot>  [1,3,5,7,9]
11:18:26 <Deewiant> there, no single-element case :-P
11:19:29 <zachk> I hpasted a more clone the other day but it had some minor bugs, here is the fixed version http://hpaste.org/9985. I am using pipes alot and I think it may be a good way to introduce people to programming. I attempted earlier showing my mom some basic pipeage and the source to a program like cat, but written in haskell, any comments on pipes as an introduction to programming?
11:22:18 <zachk> oh no comments. I'll just carry on then :-D
11:22:33 * BMeph sstarts to say something about "showing something to zachk's mom, then stops, closes the xkcd browser windows, and continues reading...
11:23:16 * BMeph should've put a '"' right after 'mom'
11:23:20 <yitz> > let odds = map head . takeWhile (not . null) . iterate (drop 2) in odds [1..20]
11:23:24 <psibot>  [1,3,5,7,9,11,13,15,17,19]
11:23:37 <Deewiant> yitz++
11:24:02 <ddarius> > cycle $ show '"'
11:24:05 <psibot>  "'\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"''\"...
11:24:35 <Deewiant> > iterate show '"'
11:24:38 <psibot>  Couldn't match expected type `String' against inferred type `Char'
11:24:48 <Deewiant> d'oh
11:25:13 <BMeph> > let odds = fst .  foldr (\x (p,q) -> (x:q,p)) ([],[]) in odds [1..20]
11:25:16 <psibot>  [1,3,5,7,9,11,13,15,17,19]
11:25:25 <Myoma> woah
11:25:35 <Deewiant> BMeph++
11:25:39 <tylere> what does the $ operator do exactly? Was trying to find out last night and couldn't find a reference in the wiki
11:25:39 <Myoma> that makes no sense lol
11:25:40 * BMeph flexes for the channel
11:25:56 <Myoma> > foldr (\x (p,q) -> (x:q,p)) ([],[]) [1..20]
11:25:59 <psibot>  ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
11:26:04 <ddarius> Add a ~
11:26:05 <Myoma> ahh
11:26:08 <Myoma> very nicea
11:26:13 <Deewiant> @src ($)
11:26:13 <psibot> f $ x = f x
11:26:14 <Myoma> @pl (\x (p,q) -> (x:q,p))
11:26:14 <psibot> (`ap` snd) . (. fst) . flip . ((,) .) . (:)
11:26:15 <Deewiant> tylere: ^
11:26:34 <Myoma> :t \x -> first (x:)
11:26:37 <psibot> Not in scope: `first'
11:26:46 <Myoma> @let first f (x,y) = (f x,y)
11:26:49 <psibot> Defined.
11:27:20 <tylere> hrrm, so it's just like syntax sugar for function application?
11:27:31 <Deewiant> essentially it's a way to get rid of brackets
11:27:35 <tylere> ok
11:27:37 <ddarius> > let first f ~(x,y) = (f x, y) in foldr (first . (:)) ([],[]) [1..20]
11:27:39 <Myoma> > foldr (\x (p,q) -> (x:q,p)) ([],[]) [1..21]
11:27:40 <Deewiant> instead of f (g x y), f $ g x y
11:27:43 <psibot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[])
11:27:43 <psibot> Terminated
11:27:45 <Myoma> > foldr (\x (p,q) -> (x:q,p)) ([],[]) [1..22]
11:27:48 <psibot>  ([1,3,5,7,9,11,13,15,17,19,21],[2,4,6,8,10,12,14,16,18,20,22])
11:27:48 <tylere> e.g. f $ g x instead of f (g x)
11:27:48 * ddarius needs a swap
11:27:51 <Myoma> > foldr (\x (p,q) -> (x:q,p)) ([],[]) [1..23]
11:27:54 <psibot>  ([1,3,5,7,9,11,13,15,17,19,21,23],[2,4,6,8,10,12,14,16,18,20,22])
11:27:54 <Deewiant> yep
11:28:08 <ddarius> > let first f ~(x,y) = (f x, y); swap ~(x,y) = (y,x) in foldr (swap . first . (:)) ([],[]) [1..20]
11:28:10 <psibot>  Couldn't match expected type `(t, t1)'
11:28:28 <ddarius> > let first f ~(x,y) = (f x, y); swap ~(x,y) = (y,x) in foldr ((swap .) .first . (:)) ([],[]) [1..20]
11:28:31 <psibot>  ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
11:28:41 <Myoma> :t ([],[])
11:28:44 <psibot> forall a a1. ([a], [a1])
11:29:30 <yitz> @type \x -> first (x:) . uncurry (flip (,))
11:29:32 <psibot> Not in scope: `first'
11:30:03 <trofi> @pl \x y -> y x
11:30:03 <psibot> flip id
11:30:15 <yitz> @type \x -> (\f (a, b) -> (f a, b)) (x:) . uncurry (flip (,))
11:30:17 <psibot> forall a a1. a -> (a1, [a]) -> ([a], a1)
11:30:37 <trofi> @version
11:30:37 <psibot> lambdabot 4.2
11:30:37 <psibot> darcs get http://code.haskell.org/lambdabot
11:30:40 <yitz> @pl \x -> first (x:) . uncurry (flip (,))
11:30:41 <psibot> (. uncurry (flip (,))) . first . (:)
11:30:50 <yitz> not bad
11:31:11 <BMeph> @let (><) = uncurry (***)
11:31:13 <psibot> Defined.
11:31:16 <lelf> > let o [] = []; o [x] = [x]; o (x:xs) = x : e xs; e (x:xs) = o xs in o [1..10]
11:31:19 <psibot>  [1,3,5,7,9]
11:31:23 * _zenon_ is eating roasted coffee beans coated with chocolate, yummy
11:31:40 <Myoma> :t (><)
11:31:43 <psibot> Not in scope: `><'
11:31:47 <Myoma> what is that
11:32:17 <idnar> @type uncurry (***)
11:32:21 <psibot> Not in scope: `***'
11:32:40 <yitz> psibot === pre-alpha-bot
11:32:50 <Saizan> uhm
11:33:25 <yitz> @vixen we want our lambdabot back
11:33:50 <Elly> :t fold
11:33:55 <yitz> ha, no answer to that one
11:33:58 <psibot> Plugin `vixen' failed with: thread killed
11:33:59 <Saizan> yitz: what's the problem?
11:34:06 * BMeph wants swap and (><) in Data.Pair of the next GHC...
11:34:07 <psibot> thread killed
11:34:26 <Saizan> apart my machine being swamped by ghc when i'm building something..
11:35:01 <yitz> Saizan: you're running psibot?
11:35:37 <Elly> what's the type of generalized fold?
11:35:51 <Deewiant> ?ty Data.Foldable.fold
11:35:52 <yitz> whoever is running psibot, we of course highly appreciate it. that was not what I meant.
11:35:54 <psibot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
11:36:34 <Saizan> yitz: i was asking for something like an informal bug report :)
11:36:41 <Saizan> yitz: however yes, i'm running it
11:37:29 <RayNbow> EvilTerran, yitz: http://hpaste.org/9986
11:37:51 <RayNbow> hmm, hpaste will soon hit the 10k mark
11:38:03 <FunctorSalad> why the Monoid instance? this looks like the evaluation map of a free object
11:38:17 <lispy> Where are flexibleinstances documented?  I'm not pulling up anything useful on google
11:38:35 <FunctorSalad> lispy: not in ghc doc?
11:38:41 <yitz> RayNbow: very nice!
11:38:59 <lispy> FunctorSalad: this is the top hit on google: http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
11:39:02 <psibot> Title: FlexibleInstances - Haskell Prime - Trac, http://tinyurl.com/yrzrj5
11:39:04 <lispy> But, I'm not using haskell'
11:39:04 <BMeph> RayNbow++
11:39:13 <trofi> @dict
11:39:14 <psibot> Supported dictionary-lookup commands:
11:39:14 <psibot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
11:39:14 <psibot> Use "dict-help [cmd...]" for more.
11:39:17 <RayNbow> yitz: except that the second operand for (>>>) keeps growing :p
11:39:29 <FunctorSalad> lispy: there's a ghc flag -XFlexibleInstances or so. ought to be in the manual
11:39:39 <trofi> @jargon ICE
11:39:41 <psibot> *** "ice" jargon "Jargon File (4.3.1, 29 Jun 2001)"
11:39:42 <psibot> ice n. [coined by Usenetter Tom Maddox, popularized by William Gibson's
11:39:42 <psibot>    cyberpunk SF novels: a contrived acronym for `Intrusion Countermeasure
11:39:42 <psibot>    Electronics'] Security software (in Gibson's novels, software that
11:39:42 <psibot>    responds to intrusion by attempting to immobilize or even literally kill
11:39:43 <psibot> [13 @more lines]
11:40:30 <Myoma> @hitchcock birds
11:40:31 <yitz> RayNbow: now ask Oleg how to define liftTN :: Int -> (a -> ... -> a -> b) -> (a, a) -> ... -> (a, a) -> (b, b)
11:40:32 <psibot> No match for "birds".
11:41:08 <dmhouse> ?help hitchcock
11:41:08 <psibot> I perform dictionary lookups via the following 13 commands:
11:41:08 <psibot> all-dicts ... Query all databases on dict.org
11:41:08 <psibot> devils ...... The Devil's Dictionary
11:41:08 <psibot> easton ...... Easton's 1897 Bible Dictionary
11:41:08 <psibot> elements .... Elements database
11:41:10 <psibot> [9 @more lines]
11:41:17 <RayNbow> yitz: I don't think my brains would be able to comprehend Oleg's reply :p
11:41:17 <yitz> s/Int/Nat/
11:41:26 <thetallguy> Hmm..   So the German high speed trains are Intrusion Countermeasure Electronics?
11:41:34 <Saizan> ?type (***) -- some files weren't copied in the right places
11:41:34 <lispy> FunctorSalad: the index shows nothing about it
11:41:36 <psibot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:41:40 <thetallguy> Seems like they are the opposite
11:41:55 <yitz> Saizan: yay!
11:42:03 <BMeph> yitz: Or ask Daniel Fridlender. :)
11:42:10 <lispy> FunctorSalad: but maybe this is it: http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
11:42:11 <psibot> Title: 8.6.�Class and instances declarations, http://tinyurl.com/3ym44d
11:42:32 <FunctorSalad> lispy: sorry I don't remember in what context ghc complained that it wants these ;)
11:42:50 <FunctorSalad> if you don't turn on -fglasgow-exts, you get to know all the -X's personally
11:44:11 <lispy> FunctorSalad: I wanted to know what it is
11:44:44 <lispy> Basically, in instance Foo (Bar a b c), a, b, c need to be distinct in H98
11:45:02 <lispy> So, instance Foo (Bar a a b) is not allowed
11:45:02 <FunctorSalad> lispy: your link seems to describe it
11:45:07 <lispy> FunctorSalad: right
11:45:22 <FunctorSalad> seems to be a safer version of undecidable-instances
11:53:23 <Valodim> so uh, this function "error" in the prelude
11:53:29 <Valodim> it stops program flow outside of any monad?
11:53:41 <Valodim> how isn't that impure?
11:53:54 <Cale> Valodim: It's treated as equivalent to nontermination.
11:54:14 <Valodim> is it catchable?
11:54:20 <Cale> Only from inside IO.
11:54:38 <FunctorSalad> how can even IO catch nontermination?
11:54:38 <Cale> (catching it is impure :)
11:54:39 <ddarius> and only with GHC's exception library
11:55:05 <Cale> FunctorSalad: Well, it can't catch nontermination, but it can catch things thrown by error :)
11:55:19 <ddarius> > let x = x in x
11:55:24 <psibot>  * Exception: stack overflow
11:55:33 <FunctorSalad> okay
11:55:54 <Valodim> alright
11:56:00 <Cale> @version
11:56:00 <psibot> lambdabot 4.2
11:56:00 <psibot> darcs get http://code.haskell.org/lambdabot
11:56:02 <Cale> hmm
11:56:11 <Cale> @seen Cale
11:56:11 <psibot> You are in #haskell. I last heard you speak just now.
11:56:13 <Cale> hmm
11:56:25 * Cale wonders who is running psibot, and how they got it to work :)
11:56:30 <Saizan> Cale: me
11:56:42 <Cale> Which version of the darcs repo did you build it from?
11:56:48 <ddarius>  @seen worked fine for several years.
11:56:56 * ddarius doesn't know how you guys managed to break it.
11:57:13 <Myoma> haha
11:57:15 <Saizan> Cale: i'm running it from a fresh using HEAD, and copying some files like imports.h and L.hs manually in $CWD/State/
11:57:26 <Myoma> o_O
11:57:28 <Myoma> > let x = x in x
11:57:32 <psibot>  * Exception: stack overflow
11:57:33 <Myoma> > let f x = f x in f 3
11:57:40 <Myoma> why does _that_ stack overflow
11:57:41 <Saizan> s/fresh/fresh directory/
11:57:48 <psibot>  thread killed
11:57:52 <Cale> Saizan: Do you have the version which (attempts to) run out of the user's homedir?
11:57:52 <Valodim> huh
11:58:03 <Myoma> to evaluate let x = x in x
11:58:04 <Saizan> Cale: yeah
11:58:12 <Cale> Saizan: Does that work for you?
11:58:45 <Cale> (because it utterly failed for me)
11:58:55 <Saizan> Cale: apart from those two files yes
11:59:25 <Myoma> why does it stack overflow
11:59:34 <Cale> Specifically, if there is a seen file in State/, the seen plugin will fail, and if there is not, then lambdabot won't even run.
11:59:36 <Saizan> Cale: gwern said it was going to fix that, i'm not sure what the File module is really doing
11:59:54 <Cale> (at least, in my experience)
12:00:14 <Cale> Perhaps I should just blow away my copy of the repo and redownload it.
12:00:33 <Myoma> .------.
12:00:33 <Myoma> |      |
12:00:35 <Cale> Also...
12:00:35 <Myoma> '- x <-'
12:00:41 <Myoma> that is the graph it tries to evaluate right?
12:00:46 <Cale> @type fix
12:00:49 <psibot> forall a. (a -> a) -> a
12:01:00 <Cale> Okay.
12:01:05 <Saizan> well, now it installs a seen file via Cabal, and copies that in ~/.lambdabot/State/seen when running
12:01:13 <Myoma> I don't get it
12:01:33 <Cale> Saizan: yeah, I noticed that, but with that file present, it seemed to give lots of errors.
12:01:35 <Saizan> Myoma: it might be the display functions that causes the Stack Overflow, have you tried in ghci?
12:01:53 <Myoma> main = print foo
12:01:53 <Myoma> foo = foo :: String
12:02:05 <Myoma> running it with -O2 gives a.out: <<loop>>
12:02:09 <dmhouse> Seems to be running in O(1) space for me (in GHCi)
12:02:10 <ddarius> It should be giving a blackhole exception not a stackoverflow
12:02:12 <Myoma> but that doesn't explain why it stack overflow
12:02:26 <Saizan> Cale: maybe you had a different seen file in repo/State/seen when installing
12:02:33 <Myoma> what :S
12:02:34 <Cale> Saizan: that's possible
12:02:45 <Cale> Saizan: Is your default seen file nonempty?
12:02:56 <Myoma> How do you have a heap limit on ghci which is read from a file or env variable?
12:03:35 <Saizan> Cale: yeah
12:03:43 <Myoma> Prelude> let x = x in x
12:03:44 <Myoma> Heap exhausted;
12:04:00 <Myoma> I got heap, psibot got stack, dmhouse got O(1), ghci -O2 got <<loop>>
12:04:06 <Cale> Saizan: That would be it then. Perhaps someone (gwern?) was able to get hold of a valid seen plugin state.
12:04:40 <Valodim> > map snd $ reads "hi123"
12:04:44 <psibot>  Add a type signature
12:04:46 <Saizan> Cale: that might be it
12:04:50 <Cale> Saizan: Normally, lambdabot just produces an empty seen file, and then the plugin screws up on the next time lambdabot is run unless that's deleted.
12:04:53 <Myoma> > map snd $ reads "\"hi\"123"
12:04:57 <psibot>  Add a type signature
12:05:14 <Cale> (or at least, it's been doing that ever since I started using lambdabot)
12:05:55 * Saizan reads Plugin.Seen
12:06:00 <Myoma> :(
12:06:09 <Myoma> does anybody know why this happens?
12:06:50 <trofi> :t reads
12:06:53 <psibot> forall a. (Read a) => String -> [(a, String)]
12:06:55 <rwbarton> > map snd $ ((reads "\"hi\"123") :: [(String, String)]
12:06:55 <psibot> Unbalanced parentheses
12:06:58 <rwbarton> > map snd $ ((reads "\"hi\"123") :: [(String, String)])
12:07:04 <psibot>  ["123"]
12:07:09 <rwbarton> > map snd $ ((reads "\"hi\"123") :: [(Integer, String)])
12:07:15 <psibot>  []
12:07:31 <trofi> :t read
12:07:34 <psibot> forall a. (Read a) => String -> a
12:07:57 <trofi> > read "Just 4" :: Maybe Int
12:07:57 <Valodim> ok I don't get that one :|
12:08:03 <psibot>  Just 4
12:08:08 <trofi> > read "Just 4" :: [Char]
12:08:14 <psibot>  "* Exception: Prelude.read: no parse
12:08:37 <Cale> Valodim: what don't you get?
12:08:43 <Valodim> > reads "hi123" :: [(String,String)]
12:08:58 <psibot>  thread killed
12:09:03 <Cale> ...
12:09:10 <rwbarton> Valodim: hi123 doesn't begin with a string literal.  What are you trying to do?
12:09:15 <Cale> should give []
12:09:19 <Cale> > reads "hi123" :: [(String,String)]
12:09:21 <Myoma> is it like evil to think about how lazy evalation works? :p
12:09:34 <psibot>  thread killed
12:09:41 <lelf> > reads "hi123" :: [(String,String)]
12:09:42 <Cale> Why does that give thread killed?
12:09:48 <psibot>  []
12:09:49 <rwbarton> > 0 :: Int32
12:09:55 <psibot>  0
12:09:57 <Cale> heh
12:10:01 <Valodim> wow that took a while
12:10:04 <Cale> oh, the machine must have been busy :)
12:10:07 <Cale> > reads "hi123" :: [(String,String)]
12:10:10 <dmhouse> Prelude> :set -O2
12:10:10 <dmhouse> Prelude> let x = x in x
12:10:10 <dmhouse>   C-c C-cInterrupted.
12:10:13 <psibot>  []
12:10:16 <Cale> okay
12:10:19 <dmhouse> Myoma: ^^ that was after about 5 minutes, no noticable activity
12:10:21 <yitz> Myoma: it's evil if you're a C programmer.
12:10:22 <Cale> > reads "\"hi123\"" :: [(String,String)]
12:10:26 <dmhouse> Myoma: 6.8.2
12:10:29 <psibot>  [("hi123","")]
12:10:33 <Myoma> dmhouse: ok
12:10:49 <rwbarton> :set -O2 doesn't do anything in ghci AFAIK
12:11:06 <int-e> > read ('"' : repeat ' ') :: Int
12:11:22 <psibot>  thread killed
12:11:37 <Myoma> @let quote = '"'
12:11:43 <psibot> Defined.
12:12:14 <rwbarton> int-e: is that a bug?
12:12:35 <Valodim> I'm still trying to figure out how to possibly read something
12:13:02 <Valodim> if it can be read into an int, do a, otherwise do b
12:13:05 <Myoma> how should x be evaluated?
12:14:28 <rwbarton> case (reads str) :: [(Int, String)] of [(_, _)] -> a ; _ -> b
12:16:10 <Valodim> sounds good
12:16:16 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . (:[]) . show) . listToMaybe . map fst . reads in intOrOops "42"
12:16:26 <psibot>  Couldn't match expected type `Char' against inferred type `String'
12:16:32 <int-e> rwbarton: well, it's behaving as specified in the Haskell report
12:16:56 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . reads in intOrOops "foobar"
12:17:04 <int-e> rwbarton: the read instances are built around 'lex' and lex never returns its first token.
12:17:06 <psibot>  "Oops"
12:17:07 <int-e> @index lex
12:17:08 <psibot> Text.Read, Prelude, Text.Read.Lex
12:17:10 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . reads in intOrOops "42"
12:17:18 <psibot>  "Oops"
12:17:53 <Valodim> so what does this pair return? the parsed value as a string and in parsed form?
12:18:02 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . (reads :: String -> [(Int, String)]) in intOrOops "42"
12:18:18 <psibot>  thread killed
12:18:22 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . (reads :: String -> [(Int, String)]) in intOrOops "42"
12:18:23 <lumi> Valodim: The parsed value, and the unparsed remainder of the string
12:18:29 <Valodim> aah
12:18:32 <psibot>  <no location info>: can't find file: L.hs
12:18:38 <Valodim> great
12:19:11 <Valodim> and now that you mention it I promptly find it in the docs.
12:19:12 <Valodim> durrr
12:19:35 <yitz> > reads "42xxx" :: [(Int, String)]
12:19:46 <psibot>  [(42,"xxx")]
12:19:56 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . (reads :: String -> [(Int, String)]) in intOrOops "42"
12:20:04 <psibot>  "The number is 42"
12:20:13 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . (reads :: String -> [(Int, String)]) in intOrOops "foobar"
12:20:22 <Myoma> > maybe "Oops" (\(i :: Integer) -> show i) . listToMaybe . map fst . reads $ "42xxx"
12:20:24 <int-e> > lex "\"  "
12:20:24 <psibot>  Parse error in pattern at "->" (column 31)
12:20:33 <Myoma> > maybe "Oops" (\i -> show (i :: Integer)) . listToMaybe . map fst . reads $ "42xxx"
12:21:08 <yitz> > let intOrOops = maybe "Oops" (("The number is " ++) . show) . listToMaybe . map fst . (reads :: String -> [(Int, String)]) in intOrOops "foobar"
12:21:47 <yitz> hmm. poor psibot. well, anyway Valodim I think you've got the idea.
12:21:57 <Valodim> yes
12:21:59 <Valodim> thank you
12:22:43 <Valodim> I still have problems working with ::, usually the types all just fall into place :)
12:23:38 * Myoma wishes haskellian would grow up
12:23:41 <rwbarton> in practice if you use the parsed value from reads then it will at least default to a reasonable type
12:24:06 <yitz> Valodim: yes, that's true. read and show functions are one of the only common exceptions to that, because they are *so* polymorphic.
12:24:44 <Valodim> rwbarton: it does, but I can't rely on that when it's only possibly of such type :P
12:27:11 <gwern> @seen nomeata
12:27:26 <gwern> preflex: seen nomeata
12:27:26 <preflex>  nomeata was last seen on #xmonad 4 days, 18 minutes and 11 seconds ago, saying: * nomeata is building .debs for the 0.8rc. Any users of the debian package here that want to test it?
12:28:22 <gwern> preflex: tell nomeata You know what would be really really awesome for darcswatch? if it could add links to the mailing list entry. I'm manually going through the XM and XMC lists of unapplied patches, and it's a real pain in the arse to track down the html page for an email, even with google site search
12:28:22 <preflex>  Consider it noted.
12:28:43 * Saizan wonders what made my machine swap like hell
12:29:28 <Myoma> hm
12:29:38 <Myoma> ghci +RTS -M2M
12:29:40 <Myoma> doesn't swap
12:33:32 <chrisdone> so are there any solutions to a new, better IRC?
12:33:41 <jims_ideal> 640+ peeps
12:34:02 <Myoma> did anyone get a good GHCRTS setting?
12:34:03 <chrisdone> @users
12:34:14 <Myoma> -M2m crashes for everything and -M3m doesn't seem to make any difference
12:38:58 <Saizan> can you derive NFData automatically somehow?
12:42:46 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
12:42:52 <Saizan> is hackage very slow only for me?
12:43:02 <mmorrow> damn
12:44:05 <mmorrow> Saizan: Data.Derive will derive NFData for you. i'm not sure how good/(universally) appropriate the derive instance is though
12:44:17 <mmorrow> *derived instance
12:48:04 <maukf> preflex: seen lambdabot
12:48:04 <preflex>  lambdabot was last seen on #haskell 20 hours, 46 minutes and 13 seconds ago, saying: Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
12:51:47 <maukf> where can I read about mdo desugaring?
12:52:34 <BMeph> Here's a semi-topical question for you all: What kind of tool can you use to find out what machine is blocking a program from completing an HTTP transaction?
12:52:58 <dmhouse> maukf: try the GHC documentation, they'll probably at least have references.
12:53:01 <Heffalump> maukf: it was introduced in a paper at the Haskell Workshop in Pittsburgh. I forget the year - 2003?
12:53:05 <Heffalump> no, 2002.
12:53:15 <gwern> preflex: tell Cale I fixed that imports.h problem. I hope - I seem to have a compilation problem because of a binary upgrade, so I haven't tested it
12:53:15 <preflex>  Consider it noted.
12:53:20 <Heffalump> at least, that's what I recall
12:53:40 <maukf> ah, yes
12:56:07 <maukf> got it, thanks
12:59:48 <Saizan> gwern: did you see that Plugin.Type needs L.hs too?
13:00:00 <gwern> gah
13:00:03 <gwern> no I didn't
13:00:12 <gwern> why does it, it goes through ghci...
13:01:10 * gwern sighs. that's why I missed it, it's ":m L', not L.hs
13:01:16 <gwern> ah well, later
13:02:02 <Sadache> hello
13:02:10 <Saizan> we need a bug tracker :)
13:02:20 <Sadache> I am thinking about writing a web application using haskell
13:02:52 <Sadache> and i need it to have a web 2.0 look, which means ajaxified
13:03:21 <Sadache> so my first question, any advices or comments?
13:03:30 <stepcut> Sadache: HAppS
13:03:37 <mc__> Sadache: why do you want to use haskell?
13:03:40 <stepcut> Sadache: plus some javascript
13:03:53 <mc__> I'm currently evaluation some choices for a web app too
13:04:01 <Sadache> second question, I tried to install Wash on windows but i failed
13:04:46 <Sadache> stepcut: I want to use haskell because I believe in its cleaness, I like the language and i want to do a real project with it
13:04:50 <gwern> I didn't know wash still could be installed anywhere
13:05:06 <Sadache> is wash abandoned?
13:05:14 <gwern> Sadache: have you looked at hadoop?
13:05:19 <gwern> is that ajxy enough?
13:05:23 <Sadache> actually, is web programming possible with haskell at all?
13:05:36 <gwern> wait, is that new search engine hadoop or what?
13:05:42 * gwern forgets the exact name. hm
13:06:02 <gwern> oh, no, it's Hayoo
13:06:09 <gwern> hadoop is some apache project :()
13:06:36 <Sadache> no i dont know hayoo, i ll look at it
13:06:40 <ddarius> Sadache: Of course it is.
13:07:57 <Sadache> so hayoo is made with haskell right? yeah i guess it is ajax enough for what i need
13:08:28 <dons> yeah.
13:08:32 <stepcut> the ajaxy stuff is mostly client-side javascript, you can use HAppS+HSP+RJson to do the server-side portion, we is not very different than non-AJAX stuff, except that you might return JSON instead of HTML
13:08:35 <dons> there's lots of web programming libs on hackage.
13:08:39 <Sadache> so how can i do that, i have to say that I will be connecting with some amazon services for my data (most probably rest services)
13:08:49 <dons> there's an S3 binding too
13:09:06 <maukf> haha, awesome. the mdo paper uses lift1 and lift0 instead of liftM and return
13:09:14 <stepcut> HAppS has some S3 support as well, though I am not sure if it is currently up-to-date
13:09:34 <Sadache> dons: Yes, a lot but it is a bit misleading and confusing
13:09:59 <dons> misleading?
13:10:17 <Sadache> that is good, so does that mean that what i need is happs, the one choice?
13:10:58 <dons> it's a web serving framework.
13:10:59 <stepcut> Sadache: there are a bunch of different frameworks, some use CGI or FastCGI, some use 3rd-party SQL to store data
13:11:06 <dons> you can do other things, fastcgi + json, for example.
13:11:10 <thetallguy> Sayoo: do you mean that there is no clear path to nirvana given?
13:11:11 <Sadache> dons: I mean I couldnt, though i did a lot of search, find what i really need. I thought I have to use wash, but here I find out that i was wrong
13:11:22 <dons> wash is just another library for generating sites.
13:11:28 <dons> it really depends on what approach you want to take.
13:11:37 <dons> what are your fundamental archtectural requirements?
13:11:48 <stepcut> Sadache: I like HAppS because it is self contained, you don't need apache or sql. But, it does mean you need to be able to run your own server on port 80. (Though, there was a FastCGI interface for HAppS at one point in time as well)
13:11:51 <thetallguy> Sadache: yes, the heterogeneity there reflects the mish-mash that is the wwww.
13:12:06 <Sadache> stepcut: my data will be on amazon S3 and in cookies at the client side, that is all i guess
13:13:24 <stepcut> Sadache: will you be storing all your session data on S3 as well, or would you want that stored someplace else?
13:13:31 * ddarius should write a web service in unlambda.
13:14:02 * stepcut hopes to finish his unlambda compiler now that Language.C is out
13:14:16 <Cale> Write an unlambda backend for GHC and compile HAppS to it :)
13:14:17 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
13:14:26 <ddarius> Ugh, why would you compile unlambda via C?
13:14:40 <stepcut> Sadache: HAppS has a high learning curve, and is undocumented, you can look at my blog posts here to see if you like it or not, http://nhlab.blogspot.com/
13:15:06 <stepcut> Sadache: though, those examples use a slightly modified version of the HAppS/HSP libraries, but nothing fundamentally different
13:15:20 <Sadache> stepcut: If nothing forces me doing other wise, all my data will be on S3 and client side cookies
13:15:26 <stepcut> ddarius: portability, the other option was to use Harpy or something
13:16:49 <stepcut> Sadache: that means when a client connects to your server, you take their cookie, then you look up their session data which is stored on S3, then you render the page using the session data. Does that sound like what you want to do ? (I'm not implying it is wrong to do that, btw)
13:17:04 <stepcut> ddarius: I am open to other suggestions though.
13:17:16 <Myoma> compile to haskell
13:17:18 <ddarius> stepcut: Target the CLR.
13:17:28 <stepcut> hrm
13:17:35 <Sadache> lets what i want to do is somehow straightforward: Get data from s3, sending it to the client (as json probably) then generating Html out of it (preferably using map and monadic facilities)
13:17:38 <ddarius> Compiling to Haskell is an actual good idea
13:18:39 <stepcut> It is somewhat straigt-forward to compile unlambda to ocaml, because you can use -rectypes, though I forget why I needed to do that in the first place
13:18:55 <stepcut> (-rectypes enables the unsafe infinite types)
13:19:11 <Myoma> stepcut: consider data HOAS = App HOAS HOAS | Lam (HOAS -> HOAS)
13:19:20 <Sadache> stepcut: yes somehow, the server will get the cookie, and connects to s3 then sends back some data. Of course then there are some data to ve sent to S3 for being persisted
13:19:29 <Myoma> you can write a 2 line interpreter for untyped lambda calc. with it
13:19:35 <maukf> meh, rectypes can be done with newtype wrapping
13:19:42 <stepcut> Myoma: but I don't want an interpreter...
13:20:00 <stepcut> maukf: yes, but more annoyingly
13:20:02 <Myoma> everything runs on an interpreter
13:20:27 <maukf> stepcut: who cares, it's compiler output :-)
13:20:54 <stepcut> maukf: it's annoying to write the code that outputs the compiler output as well ;)
13:22:01 <stepcut> Myoma: well, yes, opcodes are interpreted and converted to machine code, but I wis to target the opcode level interpreter not the unlambda level interpreter
13:24:00 <stepcut> anyway, I am not really clear that targeting Haskell is a big benefit here.
13:24:05 <ddarius> New Catsters!  My day is made!
13:24:13 <Cale> Hooray!
13:24:17 * Cale looks
13:24:20 <stepcut> I targeted STG before, and it did not make for a great fit
13:24:39 <maukf> ST:TNG
13:27:37 <Sadache> so it seems that Happs is what i am looking for, right?
13:27:54 <FunctorSalad> I'm really waiting for them to make the "small category = kitten" joke
13:27:59 <dmead> > groupBy (\x -> x > 10) [1..30]
13:28:01 <dons> Sadache: are you looking for a 'rails' like complete framework?
13:28:05 <dons> with no extra webserver?
13:28:24 <dmead> *couch* haskell on helicopters *cough*
13:28:34 <dmead> > "ping"
13:28:39 <dmead> L<
13:28:40 <dmead> :(
13:28:41 <stepcut> Sadache: well, if you don't plan to use the HAppS persistent storage layer, then you could use something simplier, like a FastCGI library
13:28:58 <dons> btw, team, galois' blog is now functional, http://www.galois.com/blog/2008/08/28/galois-tech-talks/
13:29:03 <dons> you can read the slides of the last 3 tech talks.
13:29:07 <dmead> where lambdabot?
13:29:09 <Sadache> dons: rails like would be ok, but i am rather searching for a web framework that has the haskell's taste
13:29:14 <FunctorSalad> dmead: hmm, "helicopters" aren't very analogous to rails :(
13:29:18 <stepcut> Sadache: but, you also might opt to store temporary session data in HAppS and the content and persistent data on S3.
13:29:29 <dmead> rails, trains, python on planes
13:29:40 <stepcut> dons: as in, not imperative ?
13:29:44 <FunctorSalad> dmead: oh, didn't know about python on planes
13:29:45 <dons> that's right.
13:29:46 <dons> :)
13:29:56 <dons> 'live' i suppose is common palance.
13:29:59 <Sadache> for me it is an experiment
13:30:04 <stepcut> dons: looks like wordpress to me :(
13:30:12 <dons> yeah.
13:30:20 <stepcut> dons: that's not functional!
13:30:26 <dons> hah
13:30:44 <stepcut> a functional blog is almost everyones first Haskell web app ;)
13:31:34 <ddarius> dons: How did your cover slide go over?
13:31:54 <dons> ddarius: it rocked the house :)
13:32:11 <FunctorSalad> dmead: haskell on hum-vees? ;)
13:32:28 <dmead> rails has ground covered
13:32:33 <dmead> i also said haskell in  hyperspace
13:32:35 <dmead> for ground air and space
13:32:54 <ski> haskell on hovercrafts
13:33:05 <ddarius> dmead, ski: This has all been done before.
13:33:09 <tristes_tigres> Hello
13:33:11 <dmead> i think somone suggested that the last time we had this conversaion
13:33:13 <dmead> like 2 years ago
13:33:22 <ddarius> dmead: Indeed.
13:33:24 <ski> quite possible
13:33:36 <maukf> haskell on hylomorphisms
13:33:40 <dmead> > groupBy (\10 x -> x > 10) [1..30]
13:33:44 <dmead> haskell in holocrons
13:33:54 <ski> > haskell `on` hylo
13:34:04 <maukf> ENOBOT
13:34:17 <dmead> wheres lambdabot dewds?
13:34:19 <dons> Cale.
13:34:20 <FunctorSalad> haskell on Bayer painkillers...
13:34:24 <MyCatVerbs> dmead: shouldn't that just pattern match fail straight away?
13:34:31 <dmead> i'm not sure
13:34:33 <ddarius> dons: Your fourth slide will come in handy the next time a newbie says "Haskell has arrays?"
13:34:42 <dmead> the docs say a -> a -> bool
13:34:44 <dons> heh
13:34:46 <Sadache> stepcut: Do you think it is better to store temp session in the happs server?
13:34:49 <Cale> Oh, is Saizan's psibot not running anymore?
13:34:55 <dons> you might enjoy the microkernel/haskell talk.
13:35:05 <dmead> whats the equality test supposed to look like for groupby?
13:35:11 <dons> i hope the tech talk series gives some more insight into what galois does, too, rather than being somewhat of a black box.
13:35:18 <stepcut> Sadache: I don't know, I have not used S3 enough to know how well it would work for session data.
13:35:21 <dmead> i find polymorphic type signatures a bit vauge
13:35:26 <MyCatVerbs> dmead: type wise, it's fine. But it'll be trying to match the elements of the list against the number 10. It will fail on the first element. You'll get an error.
13:35:32 <stepcut> Sadache: in fact, I have not used S3 at all.
13:35:35 <Myoma> dmead; ahaha
13:35:45 <MyCatVerbs> dmead: (isn't that the objective? ;)
13:35:57 <Cale> ahaha, check this out:
13:35:58 <dmead> sure, but you have to give an example
13:36:02 <Cale> cale@olive:~$ darcs get http://code.haskell.org/lambdabot
13:36:02 <Cale> Copying patch 1804 of 1804... done.
13:36:02 <Cale> Applying patch 432 of 1804... Unapplicable patch:
13:36:02 <Cale> Sat Apr 23 18:23:38 PDT 2005  dons@cse.unsw.edu.au
13:36:02 <Cale>   * More state
13:36:04 <Cale> darcs: ./State/seen: openBinaryFile: does not exist (No such file or directory)
13:36:11 <dmead> type signatures don't tell you what the function body actually is supposed to do
13:36:11 <Cale> This file is the bane of my existence!
13:36:12 <FunctorSalad> @src groupBy
13:36:33 <dmead> like the equality functor, one can't really tell which is the constant
13:36:50 <dmead> or maybe i'm just retarded
13:37:08 <FunctorSalad> equality functor?
13:37:11 <maukf> dmead: it compares elements to the first item of each group until the predicate returns false; then it starts a new group
13:37:25 <Sadache> stepcut: well at least what i am sure of is that i will not have to connect to a database
13:37:39 <FunctorSalad> it's main purpose is being abused with non-equivalence-relation on #haskell to calculate primes or whatever
13:37:43 <ski> (maukf : is that much specified ?)
13:37:45 <FunctorSalad> *relations
13:37:59 <maukf> ski: I don't know
13:38:16 <maukf> also, I hate chatzilla's tab completion
13:38:52 <DrSyzygy> What was the irc-channel to discuss ghc on gentoo again?
13:39:09 <dmead> #gentoo-haskell
13:39:12 <dmead> or the reverse
13:39:15 <stepcut> Sadache: with HAppS there is not external database, which is nice. You just have a datastore in your HAppS app which stores an arbitrary Haskell data structure. The HAppS-State component makes sure that that datastore is persistent across application restarts, and is thread-safe
13:39:22 * BMeph wants to see STG:TNG
13:39:33 * dmead does the picard dance
13:39:35 <ddarius> The LHC is all the craze right now.
13:40:23 <Sadache> oh, that is good, is  some kind of in memory datastore?
13:40:38 <ddarius> dons: You use "ruthlessly" a lot.
13:40:39 <dons> Lazy Haskell Compiler?
13:40:47 <dons> ddarius: it's a phase
13:40:53 <FunctorSalad> ddarius: ruthlessly, really.
13:40:59 <dons> my pirate phase, yarr!
13:41:17 <stepcut> Sadache: yes, HAppS stores everything in memory, but does write-ahead logging so that it can recover from a crash
13:41:45 <stepcut> Sadache: also, supports multi-master replication and sharding (though that stuff is a bit primative as it is the current area of development)
13:41:53 <Sadache> i guess that is something that is quite interesting for me
13:41:57 <stepcut> Sadache: also, there is a #happs, though it is not very active
13:42:25 <yitz> preflex: remember dmead i find polymorphic type signatures a bit vauge
13:42:32 <Sadache> stepcut: even sharding! I guess that is what i am looking for
13:42:46 <yitz> preflex: quote dmead
13:42:46 <preflex>  <dmead> i find polymorphic type signatures a bit vauge
13:42:49 <ddarius> yitz: That's odd.  I find monomorphic type signatures a bit vague.
13:43:05 <yitz> hehe
13:43:07 <dmead> :P
13:43:22 <dmead> > groupBy (\10 x -> x > 10) [1..30]
13:43:32 <dmead> no?
13:43:33 <stepcut> Sadache: not sure if sharding is available yet, but I think it is the top priority at the moment. There is definitely some replication support in there -- I have used it.
13:43:48 <Sadache> stepcut: does happs have an active community behind in case I need some help?
13:44:35 <stepcut> Sadache: the community is still pretty small. Though, I am usually around on #happs and the mailing list
13:44:46 <Sadache> ok
13:44:46 <yitz> > groupBy ((==) `on` (`div` 10)) [1..30]
13:45:24 <Sadache> i guess I ll give Happs a try, seems it is very close to what i am looking for
13:45:32 <yitz> [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19],[20,21,22,23,24,25,26,27,28,29],[30]]
13:45:34 <lispy> should newtype deriving be considered harmful?
13:45:46 <lispy> I just learned today that some people realy think it's nasty
13:45:52 <lispy> I thought it was a blessing!
13:45:52 <maukf> s/harmful/awesome/
13:46:15 <rwbarton> "considering things harmful considered harmful"
13:46:22 <yitz> lispy oh yeah? why do they think it's nasty?
13:46:22 * lispy nods at rwbarton 
13:46:26 <stepcut> Sadache: HAppS is developed by the HAppS, LLC, so there is some funding behind its on going development
13:46:35 <lispy> yitz: I asked, but I did not receive clarification
13:46:36 <Sadache> yet I guess I will have to write a sort of a monad to interpret some monadic operators into javascript code that generates dom tree. It will be amusing i guess
13:46:39 <maukf> fix (considered harmful)
13:46:45 * BMeph notices his shirt is rising up, and gives it "the Picard Manoeuvre ."
13:47:13 <Sadache> stepcut: thanks very much for your time
13:47:33 <dmead> he just kept talking and talking in one incredible long sentence so that no one could interrupt him it was really quite hipnotic notic notic notic
13:47:53 <Sadache> thanks to this very cute community, i am surprised always of how helpful people are here.
13:48:15 <dmead> ops in #C are jerks
13:48:17 <lispy> Sadache: thanks
13:48:37 <stepcut> dmead: yes, very strict.
13:49:38 <mc__> dmead: what did they do to you?
13:49:43 <yitz> stepcut: as opposed to ops in #haskell, who are very lazy (just joking)
13:49:44 <dmead> if you say something that doesn't meet their textbook definition of C then you get lectures for 5 min
13:49:56 <gwern> I sometimes wonder how Happs Inc makes money to develop happs
13:49:58 <stepcut> yitz: exactly! :)
13:50:08 <stepcut> gwern: I don't think they do yet
13:50:22 <lament> dmead: same happens here if you say something that doesn't meet people's textbook definition of Haskell...
13:50:29 <Lemmih> gwern: Counterfeiting.
13:50:48 <stepcut> Lemmih: sweet!
13:50:49 <gwern> Lemmih: ah, of course. continuations as applied to money - sinister!
13:51:00 <Lemmih> gwern: But you didn't hear it from me.
13:51:05 <dmead> lament, i disagree, people have different opinions here
13:51:10 <dmead> and aren't jerks about it
13:51:13 <gwern> stepcut: but then how - er, what? did a VC give them money to develop haskell web apps or something?
13:51:17 <Sadache> it is funny while searching I had the impression that I was going to Wash with Ajax
13:51:23 <yitz> Lemmih: venture capital.
13:51:25 <stepcut> gwern: Lemmih would know better than I would
13:51:31 <Sadache> or Wash some Haskell with HAjax
13:51:37 <yitz> ah, same thing, right.
13:52:04 * gwern wonders what the VC was thinking - that happs would be the next ruby on rails or something?
13:52:28 <Lemmih> gwern: Alex is a venture capitalist himself.
13:52:30 <yitz> gwern: maybe not the next, but the one after that
13:52:34 <dmead> thats silly
13:52:35 <mrd> haskell on hoverbikes
13:52:36 <Myoma> haskell on hydraulics
13:52:42 <gwern> if I were a vc I think i'd want my money back. happs has been coding for years now haven't they? there's some nice stuff but I don't get the impression happs is hugely successful
13:52:50 <dmead> the next rails will be the next release of rails
13:52:54 <stepcut> gwern: the VC is half the development team ;)
13:52:58 <Myoma> I get the impression nobody can build happs
13:53:00 <lispy> > fix revenue
13:53:21 <Lemmih> Myoma: It's quite easy now: cabal install HAppS-Server
13:53:21 <gwern> or to put it another way, if anyone ever puts the happs wikipedia article up for deletion, I don't think I'll be able to rescue it like I could [[Xmonad]]
13:53:33 <Lemmih> gwern: Most of the development has been spent on research.
13:53:33 <yitz> Software on Segways
13:53:48 <gwern> C on Segfaults
13:53:50 <lispy> gwern: interesting, why did they want to deleted Xmonad?
13:53:53 <stepcut> Myoma: I build it several times a week, http://deb.seereason.com, has a lot of dependencies though. However I have heard people using cabal-install recently and succefully
13:54:06 <gwern> lispy: wm-cruft
13:54:25 <lispy> oh those wikipedia elitists :)
13:54:25 * stepcut wonders if harrop was behind the wikipedia incident
13:54:45 <lispy> stepcut: we need him to write a book on haskell so he'll start promoting it
13:54:47 <_zenon_> dmead, Haskell on heels.
13:54:56 <lispy> _zenon_: heh
13:54:59 <dmead> that sounds defensive
13:55:04 <dmead> you wanna be bold and inspiring
13:55:10 <stepcut> lispy: some Haskell haters on 4chan's /prog/ decided to cause some trouble for xmonad
13:55:10 <yitz> maybe someone mistakenly thought that one of the xmonad developers is a republican.
13:55:11 <lispy> what about: Curry on Rice
13:55:16 <dmead> hah
13:55:18 <_zenon_> lispy, :D
13:55:19 <_zenon_> hehehe
13:55:39 <gwern> stepcut: no, I doubt harrop idles on the *chans
13:55:43 <lispy> stepcut: Is this Battletoads?
13:56:04 <stepcut> lispy: um... I don't know what that means, but maybe related
13:56:06 <maukf> wrong board
13:56:11 <gwern> no, it can't be Curry on Rice, because Curry's a different language
13:56:15 <gwern> a logic language iirc
13:56:21 <lispy> stepcut: it was a 4chan prank on gamestop
13:56:30 <Myoma> curry is haskell with nondeterminism built in
13:56:34 <Myoma> and logic variables
13:56:54 <ddarius> Myoma: and type classes removed and other stuff removed
13:57:00 <stepcut> gwern: I would not be suprised either way.
13:57:07 <ddarius> Curry is a functional logic language utilizing narrowing.
13:57:08 <lispy> stepcut: the correct answer is, "No, it's Doom 3" BTW
13:57:14 <stepcut> lispy: ah
13:57:30 <maukf> it's clearly Fighting Frogs
13:58:01 <stepcut> maybe Haskell on Heroin to go with GHC on Acid ?
13:58:02 <dmead> haskell helping hackers
13:58:04 <dmead> bam
13:58:06 <lament> Flying Frogs
13:58:10 <lispy> BTW, to the haskell on heels people, did you see SQL on Rails?  It's a funny spoof of rails
13:58:30 <gwern> I liked Cobol on Cogs
13:58:35 <osfameron> perl on poles
13:58:42 <ddarius> dons: Is the Galois blog going to be in Planet Haskell?
13:59:21 <lament> C on Crutches
13:59:32 <Wild_Cat> "Cobol on Cogs" is an awesome name.
13:59:57 <_zenon_> "Haskell in hell"
14:00:01 <_zenon_> that's bold
14:00:01 <olsner> osfameron: Vlad the Impaler style?
14:00:10 <gwern> no Heaven
14:00:25 <maukf> HEAVEN OR HELL: LET'S ROCK
14:00:37 * EvilTerran considers "python on pogosticks"
14:00:46 <_zenon_> hehehe
14:00:47 * Wild_Cat starts playing the intro to "Momentary Life"
14:00:53 <olsner> python = kindergarten programming ;-)
14:00:56 <lament> python on painkillers
14:01:11 <Wild_Cat> I Can Haskell Cheezburger.
14:01:21 <_zenon_> monads on mondays.
14:01:46 <mc__> monad of the monkeys
14:01:58 <Wild_Cat> The Secret of Monad Island.
14:02:10 <EvilTerran> haskell on hallucinogens!
14:02:17 <lament> monads on medication
14:02:17 <dmead> yessssss
14:02:31 <Wild_Cat> Haskell SD
14:02:40 <maukf> monads on markov chains
14:02:49 <dmead> i'm gonna start that project
14:02:53 <dmead> haskell on hallucinogens
14:02:57 <mc__> haskell on hallucinogens is genius
14:03:01 <Myoma> has anyone done a markov chain of all the monad tutorials?
14:03:01 <dmead> all it does is tell you were to get drugs
14:03:03 <_zenon_> And that's why you don't say "X on Y" in the haskell #
14:03:09 <dmead> and then exits in a freaky color scheme
14:03:24 <Wild_Cat> dmead: what if I'm lazy and can't be arsed getting the drugs?
14:03:28 <EvilTerran> it's g.o.a. taken further :D
14:03:56 <RayNbow> <Wild_Cat> The Secret of Monad Island. <-- any release date for this game? :p
14:03:59 <dons> ddarius: yeah, i've asked ibid to add it.
14:04:01 <dmead> then you won't have to get the drugs until their just about to effect your system
14:04:02 <dons> ibid: ^^
14:04:05 <dmead> =)
14:04:10 <olsner> RayNbow: as soon as you've built it!
14:04:13 <Wild_Cat> RayNbow: I'd play that for a dollar ;)
14:04:31 <_zenon_> RayNbow, sounds like yet another monad tutorial
14:04:35 <Wild_Cat> dmead: so not until I get tested for drugs, then?
14:04:41 <dmead> ahaha
14:04:49 <dmead> indeed
14:04:55 <Wild_Cat> lazy bloodstream.
14:05:26 <dmead> yes, they will appear in bloodstream at the last possible instant
14:05:37 <Wild_Cat> dmead: when you're wounded.
14:05:42 * Myoma opens #haskell-blah
14:05:45 <olsner> secretOfMonadIsland :: MonadIO m => ScummT m ()
14:05:47 <dmead> now you've lost me
14:05:58 <Wild_Cat> thinking of it, "bloodstream" would be a cool name for a lib of some kind.
14:06:10 <stepcut> olsner: heh
14:06:14 <Wild_Cat> dmead: well, your bloodstream has no output unless you're wounded and bleeding.
14:06:21 <dmead> ah i gotcha
14:06:27 <dmead> well, or getting blood drawn
14:06:36 <_zenon_> Wild_Cat, can you buffer the blood-stream?
14:06:43 <olsner> someone should just invent the remote bloodletting protocol
14:07:14 <maukf> is that like FS/IP? (face stabbing over IP)
14:07:24 <Wild_Cat> _zenon_: it's an implementation detail. I don't care about it.
14:07:40 <olsner> maukf: it's basically an abstraction of FS/IP I guess
14:07:56 <Baughn> Ilmuri: Don't worry. We don't normally stab people in the face here.
14:08:11 <Wild_Cat> indeed. We stab them in the back.
14:08:11 <r3m0t> there's a first time for everything
14:08:21 <_zenon_> when they're sleeping
14:08:27 <Ilmuri> Wild_Cat: do you ever target kidneys?
14:08:28 <olsner> aiming for a vein might give you better bandwidth than simple facestabbing
14:08:43 <Wild_Cat> or to be more precise, their backs become stabbed when someone attempts to see if they're alive.
14:08:58 <olsner> you lazy backstabber! :P
14:09:05 <Baughn> Wild_Cat: See, this sort of thing is why you should stay away from lazy I/O
14:09:10 <Wild_Cat> Ilmuri: depends. I prefer adultneys.
14:09:12 <xif> olsner: lazy is appropriate here.
14:09:48 <Baughn> Ilmuri: I sincerely apologize on behalf of the channel. We are usually more sirius.
14:10:16 <_zenon_> Is it just me or this this sliding off haskell content?
14:10:24 <r3m0t> #not-haskell
14:10:27 <r3m0t> #naskell
14:10:29 <Ilmuri> Baughn: at least it's alive
14:10:37 <gwern> facestabbing has better latency than backstabbing, albeit with worse throughput
14:10:42 <BMeph> dmead: Make it Haskell `on` hallucinogens, and it's a Deal! ;)
14:11:02 <olsner> BMeph: beautiful!
14:11:10 <Baughn> Ilmuri: You never know until you check
14:11:14 <mc__> I think that game should be coded by stoners
14:11:30 <olsner> @ty ?haskell `on` ?hallucinogens
14:11:41 <olsner> @bot
14:12:26 <Ilmuri> Baughn: yeah, it might have inhaled cyanide acid while I've been looking away
14:12:55 <Baughn> Ilmuri: It wouldn't have actually happened until you check, though
14:13:03 <Baughn> #haskell is odd like that
14:13:11 <dons> Cale, lambdabot plz.
14:13:27 <dons> or has she been murdered?
14:13:48 <Cale> I'm having various troubles building it.
14:13:52 <_zenon_> the MurderMonad
14:14:11 <Baughn> &ty 2
14:14:12 <Cheiron> forall t. (Num t) => t
14:14:19 <olsner> &ty ?haskell `on` ?hallucinogens
14:14:20 <Cheiron> forall b c a. (?hallucinogens::a -> b, ?haskell::b -> b -> c) => a -> a -> c
14:14:23 <dons> :(
14:14:40 <dons> the decline and fall of lambdabot makes me sad.
14:14:45 <Wild_Cat> "It was a dark and stormy night. A bot's dying scream echoed through the streets, a lazy ghost with nobody to haunt."
14:14:49 <Cale> hmm, I'm currently stuck on dependency hell involving bytestring-0.9.0.1.1 (which is needed for ghc-6.8.3) vs bytestring-0.9.1.2 (which is needed for various other things)
14:14:56 <Cale> maybe it's avoidable...
14:15:10 <dons> maybe it isn't needed?
14:15:15 <dons> try upgrading binary
14:15:39 <BMeph> MOAR LABMDAS PLZ KTHXBAI!
14:16:53 <Wild_Cat> hrmm. Glade is hard.
14:17:06 <Cale> http://hpaste.org/9989
14:17:12 <Cale> Wild_Cat: how so?
14:17:15 <_zenon_> BMeph, what just happened?
14:17:52 <Cale> hmm, this is strange
14:18:09 <Cale> ghc-6.8.3 isn't even a dependency of lambdabot afaict...
14:18:10 <Cale> oh
14:18:10 <dmead> BMeph, maybe we could just have @drugs for lambdabot
14:18:12 <Cale> mueval
14:18:12 <Wild_Cat> Cale: there's no tutorials on it. You find basic GTK tutorials that explain how to draw a 2-button app and then load it using your programming language of choice, but nothing in-depth for Glade itself, which I would find vastly more interesting.
14:18:22 <olsner> Cale: I recognize that, and I solved it somehow... something like uninstall the new bytestring and recompile your other libraries using the old bytestring
14:18:29 <dmead> clade produces really messy code
14:18:42 <Cale> aha, I removed mueval from the dependency list for lambdabot and that fixed it
14:18:50 <Wild_Cat> dmead: Glade isn't meant to produce code anymore.
14:18:56 <olsner> otoh, that was lambdabot-4.1 and afaik lambdabot-utils didn't exists then
14:18:57 <dmead> yea?
14:19:03 <dmead> just xml files for gui configurations?
14:19:14 <Cale> Wild_Cat: Well, there are a bunch of Gtk2Hs examples
14:19:19 <Wild_Cat> dmead: in 3.0, C code generation was removed.
14:19:24 <dmead> ah
14:19:42 <Wild_Cat> Cale: yup. None of which (of those I've seen) have anything approaching the UI complexity of, say, X-Chat.
14:19:54 <olsner> but glade is a gui application; what documentation do you need? :P
14:19:58 <Cale> Wild_Cat: Mostly I found using the GUI bits of Glade really straightforward. You plonk down some hboxes/vboxes for your window to lay things out, and fill them in with controls and save :)
14:20:00 <igel> uhm... where is "instance Monad (Either String)" defined?
14:20:09 <Wild_Cat> I still have no idea whether GTK has something that behaves like Swing's BorderLayout, for example.
14:20:14 <Cale> igel: Control.Monad.Error
14:20:40 <Cale> It's really sad that on account of fail, we don't have a general instance of Monad for (Either e)
14:20:52 <Cale> fail is dumb anyway
14:20:58 <dmead> don't you mean instance of fail?
14:21:03 <igel> Cale: thanks
14:21:13 <Cale> dmead: Well, in the libraries.
14:21:19 <Cale> dmead: classes have instances :)
14:21:25 <dmead> oh sorry :P
14:21:25 <Wild_Cat> HBoxes and VBoxes are good, but AFAICT they only resize proportionally, where I'd find it much more useful to have a VBox with a fixed-height component and the other that takes all the remaining available space.
14:21:41 <igel> imho it's a problem that instance foo bar can be declared anywhere
14:21:44 <Cale> Wild_Cat: I'm pretty sure that's configurable.
14:22:01 <igel> so there may be several overlapping instance declarations
14:22:01 <Wild_Cat> Cale: probably. Question being, where and how? :D
14:22:37 <olsner> there are checkboxes for expand, something and something (three booleans, iirc) that control the magical gtk box layout algorithm
14:22:39 <Cale> Wild_Cat: Click on the thing you put in one section of the v/hbox and uncheck its Expand property.
14:22:39 <igel> and haddock doesn't get all of them
14:22:55 <Wild_Cat> Cale: Aha. Awesome. Cheers.
14:23:09 <Cale> cabal: Error: some packages failed to install:
14:23:09 <Cale> lambdabot-4.2 failed during the final install step. The exception was:
14:23:09 <Cale> State/url: copyFile: does not exist (No such file or directory)
14:23:11 <Cale> hmm
14:23:44 * Cale tries just touching that file.
14:24:00 <Cale> oh, and there's no 'seen' file either
14:24:05 <Cale> Which is going to create problems...
14:24:10 <Cale> augh!
14:24:22 <gwern> Cale: you seem to have a lot of problems with the State/ files... were i you I'd try to figure out why they keep getting messed up
14:24:23 <Cale> hmm
14:25:42 <Ilmuri> what does a \ in front of a variable mean?
14:25:58 <maukf> lambda
14:26:03 <Cale> Ilmuri: \ is ascii art for lambda
14:26:09 <Ilmuri> hmh
14:26:16 <tristes_tigres> In State monad we have two types - the mutable state and a value. What if I only need the state ?
14:26:20 <encryptio> \ is a seperate term from the name it precedes, just like =
14:26:20 <Cale> (\x -> x+1) is the function which takes a parameter x and gives x+1
14:26:27 <mmorrow> > (\x -> 2 * x) 2
14:26:29 <Cheiron>  4
14:26:40 <mmorrow> Cheiron++
14:26:51 <tristes_tigres> what is the data type for "I don't care"
14:26:54 <Ilmuri> okays
14:26:59 <Cale> gwern: I had just done a darcs get, but let's try again
14:27:09 <Cale> tristes_tigres: ()
14:27:10 <Baughn> tristes_tigres: (), typically
14:27:13 <EvilTerran> ?src ()
14:27:17 <maukf> or a
14:27:25 <maukf> &src ()
14:27:26 <Cheiron> data () = ()
14:27:33 <EvilTerran> orite
14:27:37 <EvilTerran> &bot
14:27:38 <maukf> http://macrochan.org/get.py?sha1=YPRB5BCWGELHD56KA4RCPZWSUD7ESWUP
14:27:38 <Cheiron> :)
14:27:42 <Myoma> _ :: ()
14:27:43 <mmorrow> > let x = ((0,(0,((0,0),0))),(0,(0,0))) in everywhere (mkT (+1)) x
14:27:45 <Cheiron>  ((1,(1,((1,1),1))),(1,(1,1)))
14:27:47 <tristes_tigres> Thancs, Cale Baughn and Cheiron\
14:28:01 <_ar> is there a built in haskell type for natural numbers?
14:28:09 <tristes_tigres> should have guessed myself
14:28:10 <maukf> no
14:28:13 <EvilTerran> maukf, heh... er, do try to keep things on-topic, though :)
14:28:21 <maukf> unless you coun't [()]
14:28:24 <maukf> what
14:28:28 <maukf> where did that ' come from
14:28:28 <Myoma> data N = Z | S N
14:28:30 <Myoma> Integer
14:28:32 <Myoma> both work
14:28:32 <Cale> gwern: darcs get http://code.haskell.org/lambdabot  doesn't give me a State/seen file
14:28:43 <Baughn> _ar: It would be hard/impossible to implement properly, since Num instances have to allow things like 2-3
14:28:49 <gwern> hm
14:28:54 <Cale> gwern: It also doesn't give me a State/url file
14:28:57 <Myoma> Baughn: partial functions are fine
14:29:01 <EvilTerran> you could newtype-wrap Integer to keep things in the natural numbers
14:29:12 <gwern> could I have accidentally removed them?
14:29:12 <Baughn> Myoma: Okay. Not hard, then, just ugly.
14:29:24 <Cale> I don't know... if you could record yours there, it would be good though :)
14:29:27 <_ar> EvilTerran: good idea. thanks
14:30:05 <EvilTerran> if you're willing to replace the numeric heirarchy entirely, you can even make it so that "Natural -> Natural -> Integer" is a valid type for (-), while "Natural -> Natural -> Natural" isn't
14:30:07 <Myoma> we should embrace partial functions
14:30:08 <Myoma> :)
14:30:10 <EvilTerran> probably not worth it, though
14:30:28 <Myoma> 6 - 235 = 0
14:30:32 <Cale> x - y on naturals should probably give 0 when y > x
14:30:32 <EvilTerran> (note that things are currently vice-versa)
14:30:33 <Myoma> is another option
14:30:45 <_ar> EvilTerran: like a torsor
14:30:52 <Cale> Similarly to drop
14:30:53 * EvilTerran would really be inclined to make it _|_ rather than 0
14:31:09 <mmorrow> -y isn't even a natural number, since it's only a monoid
14:31:13 <dmhouse_> pred 0 = 0 is fairly canonical
14:31:14 <Cale> That way you have that length (drop n xs) = length xs - n
14:31:14 <mmorrow> x + (-y)
14:31:30 <ddarius> (-) :: Natural -> Natural -> Integer
14:31:34 <_ar> mmorrow: all groups are monoids and they have negatives... i know what you meant thought
14:31:43 <EvilTerran> ddarius, that was my suggestion. too much work, really, though
14:31:58 <ddarius> Natural numbers form a versor
14:31:58 <EvilTerran> _ar, i think he meant "only a monoid" as in "not a group too"
14:31:59 <_ar> mmorrow: that it was not a group ... not that it was not a group because it was a monoid
14:32:01 <ddarius> Er torsor
14:32:31 <dmead> :t mkT
14:32:32 <Cheiron> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
14:32:33 <maukf> to preserve negate . negate = id I suggest negate = id
14:32:34 <mmorrow> _ar: um, so you're telling me the positive integers + 0 are a group??!
14:32:42 <_ar> mmorrow: no
14:32:43 <Sadache> i am trying to get searchpath installed and built with no success
14:32:45 <dmead> > groupBy (\10 x -> x > 10) [1..30]
14:32:47 <Cheiron>   Non-exhaustive patterns in lambda
14:32:59 <_ar> i'm telling you that all groups are monoids
14:33:04 <_ar> not that all monoids are groups
14:33:08 <mmorrow> _ar: well of course they are
14:33:13 <Sadache> i ve got the searchpath.hs downloaded, but not sure what to do next
14:33:28 <_ar> mmorrow: i know... we clearly both get it, i don't know why we're talking this out
14:33:28 <nroot7> i just made my first haskell program, the factorial one. made me wonder how can a recursive solution be so fast. a similar recursive solution in java will not be so fast. whats the secret???
14:33:30 <mmorrow> _ar: i don't see how i implied that at all (that monoid => group)
14:33:31 <Sadache> http://searchpath.org/
14:33:35 <dmead>  > groupBy ((==) `on` (`div` 10)) [1..30]
14:33:39 <Cale> gwern: Let me know when you've pushed your copies of those State/ files :)
14:33:42 <dons> nroot7: tail calls, probably.
14:33:51 <maukf> nroot7: a non-retarded compiler
14:33:54 <mmorrow> _ar: in fact, i was pointing out that they *were not* a group
14:34:00 * lispy has a grammar question
14:34:03 <dons> the recursion is compiled to a loop (and you're compiling to native code, with optimisations on?)
14:34:13 <_ar> mmorrow: you said "only a monoid" in the sense of not a group
14:34:32 <Myoma> nroot7: java will allocate lots of stack frames, haskell does graph reduction
14:34:44 <nroot7> i am using ghci, i dont know if it by default optimizes to loops
14:34:45 <lispy> Suppose I'm using BNF, meaning I have expr1 ::= expr2, expr ::= expr1 | expr2.  How would you specify the syntax of lisp?
14:34:55 <dons> nroot7: oh, ghci?
14:34:58 <_zenon_> A semigroup with an identity element is a monoid
14:34:59 <maukf> nroot7: heh, ghci is slow
14:35:01 <dons> well, that's actually slow...
14:35:07 <dons> 30x or more than compiling it.
14:35:09 <_ar> mmorrow: but i read it as if you were attributing the reason that it didn't have negatives to the fact that is was "only a monoid"
14:35:15 <dons> so i guess your java is just suboptimal somehow
14:35:15 <maukf> no optimizations, no native code
14:35:15 <mmorrow> _ar: exactly. Z+ `union` {0} is only a monoid, so  x - y doesn't make sense if (-) :: N -> N -> N
14:35:21 <Myoma> <lisp> ::= <atom> | (<lisp> ...)
14:35:21 <bd_> nroot7: is it the dumb O(n^2) version or the not-so-dumb O(n) compiles-to-a-loop version? :)
14:35:24 <dons> since the jvm should beat ghci on any given day.
14:35:29 <Myoma> <lisp> ::= <atom> | (<lisp>*) -- alternative
14:35:37 <Sadache> so am i supposed to make the searchpath.hs with ghc?
14:35:38 <lispy> exp ::= litexps | exp exp | ( exp ); litexps ::= litexp | litexps litexps
14:35:47 <lispy> Myoma: I don't have *
14:35:51 <maukf> dons: not if the jvm takes 7 seconds just to boot :-)
14:35:58 <mmorrow> _ar: because there doesn't exist any (-y) in N
14:36:11 <Myoma> lispy: huh, why not?
14:36:25 <nroot7> humm,, let me make a quantitative test
14:36:25 <lispy> Myoma: it's straight up BNF, not EBNF I suppso
14:36:25 <Myoma> <lisp> ::= <atom> | (<lisp*>) ;  <lisp*> = | <lisp> <lisp*>
14:36:39 <mmorrow> _ar: :)
14:36:41 <_ar> mmorrow: lol i know that N is not a group damnit
14:36:43 <dons> maukf: oh, true.
14:36:58 <Cale> What? Is there a (reasonable) way to compute factorial which is O(n^2)?
14:37:12 <lispy> Myoma: hmm..so I have a bunch of extra productions?
14:37:15 <mmorrow> _ar: hehe
14:37:15 <Cale> (ignoring the cost of multiplication of course)
14:37:27 <bd_> Cale: fact n | n < 2 = 1; | otherwise = fact (n - 1) (n - 2)
14:37:32 <Myoma> lispy: yes, if you don't have the kleene star, unfold it manually
14:37:35 <maukf> er
14:37:35 <lispy> Myoma: I thouht I tried what you suggested without luck...I'll try again now that tweaked my lexer
14:37:40 <maukf> factonacci?
14:37:53 <Cale> bd_: huh?
14:37:56 <bd_> er
14:37:59 <Myoma> lispy: you are using BNF to write a parser? :S
14:38:01 <lispy> Myoma: on my actually sentences my lexer is conditional, makes it a pain to test
14:38:04 <bd_> Cale: fact n | n < 2 = 1; | otherwise = (fact (n - 1)) + (fact (n - 2))
14:38:05 <bd_> right then
14:38:10 <dmhouse> > let fact n = (`div` n) . sum . replicate n $ product [1..n] in fact 10
14:38:11 <Cheiron>  3628800
14:38:15 <bd_> common example, horribly slow
14:38:17 <newsham> myoma: yes, one often uses a formalism to specify a language.
14:38:25 <dmhouse> bd_: err, that's fib
14:38:27 <Cale> bd_: That's fib, isn't is?
14:38:29 <bd_> oh
14:38:29 <Cale> it*
14:38:29 <Myoma> newsham: but you don't _run_ it
14:38:30 <lispy> Myoma: yes, I'm using a python implementation of yacc but I didn't say that because it's not haskell :)  Besides, my question is about grammar :)
14:38:30 <bd_> doh
14:38:32 <newsham> what would you prefer? some sort of ad hoc set of machine instructions?
14:38:38 <bd_> my brain's off it seems >.<
14:38:42 <Myoma> hm yacc
14:39:04 <dmhouse> Cale: erm, if you ignore multiplication, fact is O(1)...
14:39:09 <lispy> Myoma: now that my conditinoal lexer is working, and the grammar is so simple, I'm about to forget about yacc thouh
14:39:23 <Cale> fac 0 = 1; fac n = n * fac (n-1) is the usual way, and it takes n steps to reduce out the calls to fac
14:39:24 <Myoma> good idea, I think yacc can only complicate things
14:39:38 <Cale> Hence O(n)
14:39:40 * Myoma thought product [1..n] is the usual
14:39:44 <Cale> Or that.
14:40:02 <dmhouse> foldl' (*) 1 [1..n] is best, I think
14:40:04 <Cale> (but that's more annoying to analyse for time)
14:40:17 <Cale> dmhouse: Right, but asymptotially, it's the same as my recursive one.
14:40:18 <newsham> > foldl' f 1 [1..5]
14:40:20 <Cheiron>  Add a type signature
14:40:26 <dmhouse> product doesn't use foldl' since you can't guarantee (*) is strict
14:40:38 <dmhouse> But I mean, seriously, ... :)
14:40:52 <Cale> There should be a product' perhaps :)
14:40:59 <Myoma> why not just make haskell strict
14:41:02 <Myoma> ?
14:41:05 <EvilTerran> ...
14:41:09 <Cale> Myoma: because laziness is awesome
14:41:14 <EvilTerran> actually, that should be ".."
14:41:18 <EvilTerran> as in [1..]
14:41:29 <EvilTerran> that idiom's reason enough, imo :)
14:41:41 <Cale> > scanl (*) 1 [1..]
14:41:43 <Cheiron>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
14:41:45 <maukf> > let (...) = enumFrom in (1...)
14:41:47 <Cheiron>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:41:47 <newsham> if you make haskell strict, is product [1..n] a good solution anymore?
14:41:54 <BMeph> lispy: Have you ever played with PEGs, or are you more interested in NLP? :)
14:41:57 <Cale> newsham: of course it would be
14:41:57 <mmorrow> Myoma: i think i read somewhere that the person that was doing the GHC compiler plugins thing has one which make haskell strict
14:42:08 <maukf> newsham: if you can fuse it
14:42:22 <Cale> If you only look at implementing the factorial function, laziness doesn't look all that attractive.
14:42:23 <newsham> fuse?  in strict haskell?
14:42:24 <lispy> BMeph: I'm not doing NLP never studied.  What is PEGs?
14:42:32 <dmead> whats the third for tuples?
14:42:38 <dmead> we have fst snd and ...?
14:42:40 <mmorrow> Myoma: i've been meaning to find that again and try it cuz i can't even imagine what it would be like
14:42:42 <quicksilver> Cale: if you make haskell strict, product [1..n] takes O(n) space.
14:42:42 <EvilTerran> dmead, no more
14:42:45 <dmead> drat
14:42:47 <BMeph> lispy: Parsing expression grammar
14:42:48 <EvilTerran> dmead, fst and snd are only for pairs
14:42:48 <quicksilver> Cale: with laziness it's O(1) space.
14:42:50 <Cale> dmead: pairs don't have a third component
14:42:52 <EvilTerran> > fst (1,2,3)
14:42:54 <Cheiron>  Couldn't match expected type `(a, b)'
14:42:54 <dmead> i guess i'll roll my own
14:43:01 <dmead> ah
14:43:01 <newsham> i have to generate in memory a list of all integers [1..n] before computing fact n?
14:43:10 <quicksilver> that's what strict means, yes :)
14:43:12 <Cale> quicksilver: Oh, that's a good point
14:43:13 <Myoma> mmorrow; there'd probably less confusion about how programs written in it work :p
14:43:17 <newsham> i wouldnt implement factorial that way in a strict language
14:43:21 <dmead> hmm
14:43:26 <dmead> how would you overload it for triples?
14:43:39 <dmead> i have a whole program written on pairs... and i wanna make em triples
14:43:41 <Myoma> newsham: It's just as bad (if not worse) in a lazy langauge
14:43:47 <Cale> dmead: You basically wouldn't...
14:43:47 <quicksilver> newsham: one of the things laziness gives you is the ability to use data structures as control structures.
14:43:57 <quicksilver> newsham: in this case, lists as loops.
14:44:03 <maukf> dmead: can you make them records instead?
14:44:08 <dmead> aw
14:44:11 <EvilTerran> if (x1,x2,...,xN) were syntactic sugar for, say, (x1 :& x2 :& ... :& xN :& ()), where data Cons x xs = !x :& xs
14:44:15 <Cale> dmead: This is a good example of where using your own record types is better.
14:44:21 <dmead> i suppose so
14:44:25 <EvilTerran> then you could have general fst and snd functions
14:44:28 * BMeph goes off to write a Data.Control module...
14:44:33 <Myoma> CAR  and  CDR
14:44:36 <EvilTerran> er, data Cons x xs = x :& !xs, even
14:44:41 <dmead> > "ping"
14:44:42 <Cheiron>  "ping"
14:45:00 <dmead> > let third (a,b,c) = c in third (1,2,3)
14:45:01 <Cheiron>  3
14:45:07 <dmead> find replace is fantastic
14:45:10 <dmead> find-replace
14:45:19 <newsham> shouldnt third be similar to first and second?
14:45:25 <lispy> Myoma: ah, something is wrong with <lisp*> ::= <lisp> <lisp*>
14:45:30 <dmead> let first (a,b,c) = a in first (1,2,3)
14:45:32 <Myoma> lispy: correct
14:45:33 <lispy> Myoma: it's an infinite recursion
14:45:34 <dmead> > let first (a,b,c) = a in first (1,2,3)
14:45:36 <Cheiron>  1
14:45:44 <Myoma> lispy: <lisp*> ::= | <lisp> <lisp*>
14:45:50 <maukf> > first succ (3,2)
14:45:51 <Myoma> the '|' is important
14:45:52 <newsham> /*empty*/ | ....
14:45:52 <Cheiron>  (4,2)
14:46:07 <EvilTerran> dmead, it is possible to write polymorphic fst, snd, etc, if you're willing to use multi-parameter typelcasses
14:46:18 <lispy> Myoma: oh, if you had put in epsilon I would have noticed it may...I did wonder why it was missing when I was typing it up :)
14:46:30 <dmead> that would require me to learn to use typeclasses
14:46:34 * Myoma uses nothing to indicate nothing
14:46:48 <EvilTerran> class Fst t a | t -> a where fst :: t -> a; instance Fst (a,b) a where fst (x,_) = x; instance Fst (a,b,c) a where fst (x,_,_) = x; etc
14:46:56 <Myoma> ε works too
14:47:05 <dmead> ah
14:47:08 * maukf would write <lisp> <lisp*> |
14:47:14 <Myoma> greedy
14:47:15 <dmead> i just wrote first second third
14:47:17 <maukf> regex habit
14:47:21 <dmead> and did find-replace
14:47:31 <dmead> the lazy way, etc
14:47:33 * Myoma has a Prolog habit
14:47:34 <Myoma> :p
14:47:46 <ddarius> 3649 consecutive squares
14:48:05 <maukf> suddenly, a triangle!
14:48:11 <newsham> polymorphic snd: http://www.thenewsh.com/%7Enewsham/x/order.hs
14:48:15 <maukf> AIEEE
14:48:28 <Myoma> what's wrong with snd??
14:48:39 <maukf> doesn't work with triples
14:48:43 <Myoma> > let (*) = (,) in snd (1 * 2 * 3)
14:48:44 <Cheiron>  3
14:48:57 <RayNbow> hmm... is it just me or is http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf missing figures? (for example, on pg. 16, Fig. 1... I don't see anything)
14:49:09 * BMeph finds people with habits and kicks them
14:49:15 <newsham> > snd [1,2,3]
14:49:17 <Cheiron>  Couldn't match expected type `(a, b)' against inferred type `[a1]'
14:49:29 <Myoma> > let snd = (!!2) in [1,2,3]
14:49:31 <Cheiron>  [1,2,3]
14:49:34 * BMeph has been banned from 29 convents so far
14:50:11 <newsham> > let snd = (!!2); (*) = (,) in (snd [1,2,3], snd (1 * 2 * 3))
14:50:13 <Cheiron>  Couldn't match expected type `[a]'
14:50:54 <BMeph> newsham: Your second bombs out on singletons. :)
14:51:19 <newsham> bmeph: error or Maybe?
14:51:48 <BMeph> newsham: Probably (hopefully) a non-exhaustive pattern fault. :)
14:52:19 <newsham> you'd leave it undefined on singletons
14:52:25 <newsham> type error
14:52:30 <newsham> bad programmer
14:52:46 <newsham> or do you mean the list instance
14:52:48 <newsham> yah... oopz
14:55:27 <Myoma> any forums where people talk about applying formal methods to programming ?
14:55:36 <Myoma> I found comp.specification
14:55:48 <Myoma> but it's actually just a place where spam is collected
14:56:06 <newsham> myoma: http://spivey.oriel.ox.ac.uk/mike/zrm/
14:56:18 <r3m0t> boo Z
14:57:26 <newsham> the sel4 papers
14:57:26 <Cale> Saizan_: are you around?
14:57:29 <Cale> gwern: ?
14:57:41 <newsham> the programatica papers
14:58:06 <binrapt> Is Haskell code difficult to debug? Vote now!
14:58:24 <binrapt> I'd imagine that imperative code is much more comfortable to step through hm
14:58:28 <Myoma> I did'nt mean reference manuals
14:58:33 * roconnor finds Haskell easier to debug because there is usual less state to setup
14:58:49 <Cale> binrapt: Stepping through code is a horrible thing to have to do to get rid of bugs
14:58:59 <newsham> #coq , #logic and #isabelle might be helpful
14:59:32 <roconnor> doesn't ghc have a nifty new debugger?
14:59:38 <roconnor> I haven't tried it yet
14:59:54 <newsham> stepping through code can provide great intution into how code works in a complex system
14:59:55 <roconnor> (other than :b doesn't do browse anymore)
15:00:00 <mmorrow> EvilTerran: re: fst, snd  http://hpaste.org/9990
15:00:09 <thomas_> binrapt most of haskell code is debugged at  compile time rather than runtime
15:00:20 <thomas_> and you get quickcheck to test pure code
15:00:29 <newsham> morrow: its a sickness.
15:00:30 <binrapt> Hm
15:00:36 <Cale> I think the most useful thing that an interactive debugger can do for you is find you parameters for which a function fails to do what it should.
15:00:37 <EvilTerran> mmorrow, indeed, i have some very similar TH in a file somewhere
15:01:09 <Cale> Once you have those, there are much better things you can do than wading through the evaluation of code :)
15:01:19 <Saizan_> Cale: pong
15:01:21 <r3m0t> Cale: how do you define the correct behaviour? maybe with a slow but correct version of the function, or a check from the answers
15:01:32 <r3m0t> but it's practically a theorem prover of its own now
15:01:33 <mmorrow> EvilTerran: nice, i'm assembling a "th-utils" library. do you have anything you'd like to add?
15:02:04 <newsham> cale: how do you do that?
15:02:07 <Cale> Saizan_: Oh, it seems that darcs get http://code.haskell.org/lambdabot doesn't give me State/seen and State/url
15:02:32 <newsham> you have a large, complex program and a bag load of functions, its behaving incorrectly somewhere.
15:02:42 <Saizan_> (i find the ghci debugger mostly useful for dealing with exceptions in pure code, which are the roots of all evil by themselves..)
15:03:02 <Cale> Saizan_: It would be good if I could get those files somehow...
15:03:10 <EvilTerran> newsham, you need formal descriptions of what all those functions are meant to be doing
15:03:39 <Cale> newsham: Well, once you know which function it is, and for what parameters it's not doing what you want, then you can start to look at the source code.
15:03:54 <EvilTerran> newsham, the problem then becomes that i write those formal descriptions in haskell ;)
15:04:01 <newsham> et: you could sit and write properties for each of the functions (maybe, depending on their nature)..  but sometimes steping through code is the pat hof least resistence
15:04:11 <Saizan_> Cale: i can email you the ones i have.. or record a patch with them, which do you prefer?
15:04:14 <newsham> cale: what if you dont know which function it is?
15:04:16 <EvilTerran> (often even when i'm intending to write the finished product in an imperative language)
15:04:20 <EvilTerran> mmorrow, what about some helpful stuff for type-level arithmetic?
15:04:33 <Cale> Saizan_: a patch would be good, since it's genuinely missing from the repo.
15:04:36 <newsham> obviously if you were writing properties from the start, you probably avoided this issue or have much less work to do
15:04:39 <Myoma> do you have any programs that use type level arithmetic?
15:04:46 * ddarius has never used a debugger purely to understand the code of something he had the source for, except for maybe assembly (but then you can view the debugger as an interactive environment...)
15:04:52 <Myoma> I am just curious to see uses
15:04:52 <newsham> but if the code is already written, throwing in traces and stepping through code is prob your fastest path to success
15:04:54 <akamaus> greetings. Is there a way to minimize amount of ram ghc uses? I have troubles building HAppS on vps with 256mb of virtual memory.
15:04:56 <EvilTerran> tyNat :: Int -> Q Type
15:04:57 <EvilTerran> etc
15:05:04 <EvilTerran> Myoma, no, but i might if it was a bit easier
15:05:09 <Cale> newsham: I said that's what an interactive debugger is useful for.
15:05:22 * ivanm wants to know why Patrick Perry released his monte carlo package _after_ he already submitted his monte-carlo based assignment :@
15:05:32 <Cale> newsham: Once you've found the problem, you don't really need it though.
15:05:34 <newsham> ddarius: I do it all th etime when I have 500kloc to review and I dont care about most of it.  find a deep function i care about, breakpoint, look up the call stack for hints on what functions I do care about.
15:05:38 <EvilTerran> Myoma, the uses are such things as vectors and matrices of fixed size, checked at compile-time
15:05:46 <newsham> cale: oh, i misunderstood you
15:05:51 <Myoma> I know but I never once saw somebody actually doing that
15:06:02 <EvilTerran> Myoma, i've seen a wrapper around Data.Array that does such a thing. i don't know if anyone uses it, though.
15:06:09 <EvilTerran> it might just be a proof of concept
15:06:10 <mmorrow> EvilTerran: cool. what rep are you using? i have one that defined    data D0,...,D9   then uses nested 2-tuples to construct a base 10-rep
15:06:12 <Myoma> who uses this stuff to their advantage?
15:06:31 <MyCatVerbs> Myoma: EVIL PEOPLE, MWHAHAHAHAHA!
15:06:35 <newsham> also not all code is written very clearly or skillfully, tracing with a debugger is useful to understand whats going on then.
15:06:36 <Myoma> is it possible that types more expressive than hindley milder actually don't have any uses ?
15:06:40 <Cale> newsham: Which is different from an imperative language, where to test if you've fixed the problem, you basically always need to go back and recreate the exact situation in which the problem first occurred.
15:06:47 <Leimy> debuggers are for stack traces
15:06:58 <Saizan_> Cale: sent to cgibbard at gmail com
15:06:58 <Cale> newsham: In Haskell, that's (almost always) entirely determined by the parameters of the function.
15:07:03 <Cale> Saizan_: awesome :)
15:07:06 <ddarius> newsham: I'm not saying that it isn't helpful; I'm just saying that I've never done it.
15:07:08 <EvilTerran> mmorrow, well, that sounds fairly reasonable, i guess
15:07:09 <newsham> cale: *nod* although you still get that sometimes..  weird socket error you are having trouble tracking down, perhaps.
15:07:15 <newsham> ddarius: gotcha.
15:07:17 <Myoma> .. silence .. :(
15:07:26 <Cale> newsham: Right, there's still stuff in IO which can be hard :)
15:07:27 <MyCatVerbs> Myoma: no, not at all. What's in Haskell is a generalisation of Hindley Milner, and it's pretty durn useful.
15:07:33 <newsham> ddarius: i just did it 2hrs ago.
15:07:41 <newsham> (not haskell)
15:07:51 <mmorrow> Myoma: i'd say most definitely. for instance, take SAPL.
15:07:58 <EvilTerran> mmorrow, although giving the digit types a parameter and writing things like D1 (D3 (D3 (D7 ()))) is more usual, i think. and using binary.
15:08:13 <mmorrow> EvilTerran: ooh, nice idea
15:08:26 <EvilTerran> using binary wouldn't be such a handicap if you had some TH helper functions
15:08:38 <Myoma> mmorrow: I didn't really understand the SAPL stuff is it much diff. to Oleg and Shans tagless staged interpreters?
15:08:43 <mmorrow> EvilTerran: yeah, i thought about binary, but the base-10 rep is more compact /and/ easier to read
15:08:46 <MyCatVerbs> Myoma: it is really really hard to make a system that's simultaneously powerful enough to express interesting things, simple enough to understand (in at of its mechanisms, consequences, and error messages!) and that correctly picks up human mistakes.
15:09:10 <mmorrow> Myoma: i'll paste some SAPL that can't be typed with hindley milner
15:09:16 <newsham> ET: you mean Data.Binary?
15:10:07 <newsham> i want deriving for Binary and NData
15:10:08 <mmorrow> Myoma: newtypes may be capable though, i haven't tried (that'd be sweet)
15:10:33 <MyCatVerbs> Myoma: IIRC, there's a theorem that you can't ever make a decidable type system that will allow all possible well-typed programs through.
15:10:44 <newsham> NData seems especially good for deriving
15:10:45 <Myoma> I don't know what you mean
15:10:47 <chessguy_> @bot
15:10:53 <Myoma> the definition of well typed comes from the type system
15:11:02 <Myoma> doesn't it ?
15:11:12 <newsham> err NFData
15:11:19 <MyCatVerbs> Myoma: yes, I'm phrasing it badly. There will always be sane, valid formulations that don't quite work in whatever decidable type system you choose to build. Constraints you can't express, etc.
15:11:26 <Myoma> oh sure
15:11:39 <MyCatVerbs> Myoma: I think constraints you can't express is the important one. Anyway.
15:11:40 <Myoma> I can easily construct a program that doesn't go wrong which can't be typed
15:11:45 * MyCatVerbs nodnod.
15:11:53 <chessguy> hm, no LB?
15:11:57 <EvilTerran> &bot
15:11:58 <maukf> &bot
15:11:58 <Cheiron> :)
15:11:58 <Cheiron> :)
15:12:15 <roconnor> MyCatVerbs: however you can make a decidable type system that will allow all possible provably well-typed programs through.
15:12:19 <newsham> bot flu's been going around
15:12:32 <Myoma> would love to see some programs that make use of the type system :)
15:12:55 <roconnor> It's just those darned well-typed but no-one-knows-why programs that we lose.
15:13:00 <MyCatVerbs> roconnor: no you can't? Unless I'm reading that wrong, those two statements are an assertion and exactly its negation.
15:13:29 <MyCatVerbs> roconnor: what's the definition of "provably well-typed"?
15:14:14 <roconnor> MyCatVerbs: it is provable in some deduction system that the programs preserves types.
15:14:34 <haskellian> in Maps, can I have String-Integer pairs? Or I have to make the ints Strings?
15:14:47 <Myoma> Can you think of a program which may benefit from using more expresive types?
15:14:53 <Cale> haskellian: You can have a Map from any ordered type to any other type.
15:15:18 <Myoma> > compare ("foo",3) ("bar",7)
15:15:20 <Cheiron>  GT
15:15:21 <MyCatVerbs> Myoma: http://www.wellquite.org/anglohaskell2008/ <-- check out Matthew Sackman's paper on enforcing EDSL constraints.
15:15:23 <Cale> haskellian: It helps if the ordering/comparison is fast of course :)
15:15:29 <maukf> haskellian: as keys or as values?
15:15:31 <Myoma> cool
15:15:46 <Saizan_> what was the binary replacement with error reporting?
15:15:54 <MyCatVerbs> Myoma: note that that's a really brutal example, heh. :)
15:16:02 <Myoma> what brutal ?
15:16:38 * Cale wonders how many other state files he's going to need
15:16:47 <Cale> Saizan_: at least State/state is also missing from the repo...
15:17:00 <tristes_tigres> What if I have data My = My {first, second, third :: Int} and State My (), and update only one field of My ? do{ s <- get ; s1 <- first s +1; return My s1 (second s) (third s) ? Kind of unwieldy
15:17:07 <MyCatVerbs> Myoma: matthew-_'s work, that I just linked. He's using extensions that make the type checker Turing-complete in order to check invariants in an EDSL.
15:17:25 <Cale> Saizan_: I'm going to see if there are any others missing.
15:17:26 <Myoma> I see
15:17:34 <tristes_tigres> especially if there are more fields in My
15:17:35 <maukf> I think functional references are supposed to help with that
15:18:01 <MyCatVerbs> roconnor: I'm missing something. If we can build a type checker that works for *all* deduction systems, then there aren't any well-typed programs that can't be decidably checked?
15:18:12 <maukf> but you could always say modify (\s -> s{ first = first s + 1 })
15:18:22 <Saizan_> Cale: i wonder how i have them, lb produces them if they are missing?
15:18:49 <Cale> Saizan_: It seems possible. Now it fails to install without them though.
15:18:55 <tristes_tigres> thanks, maukf
15:19:01 <haskellian> what is the general style in haskell for functions: someFunction or some_function? and for variables?
15:19:04 <tristes_tigres> got to read ALL of State docs
15:19:09 <Cale> (and I don't understand what happened which made this the case)
15:19:19 <Cale> haskellian: the first
15:19:26 <chessguy> is there a good way to take a list of Num n => n, and produce a list of progressive sums. e.g., f [1,2,3,4,5] = [1,3,6,10,15]
15:19:27 <maukf> theFirst
15:19:37 <maukf> that looks like a scan
15:19:38 <roconnor> MyCatVerbs: well, for every well-typed program, there is a type system that can type check it, but it is not the case that there is a type system that can typecheck every well-typed program.
15:19:40 <Cale> chessguy: scanl (+) 0
15:19:50 <roconnor> MyCatVerbs: quantiefier order
15:19:59 <Cale> (but drop 1 from that, if you want your exact list)
15:20:07 <chessguy> &type scanl (+) 0
15:20:08 <Cheiron> forall a. (Num a) => [a] -> [a]
15:20:23 <Cale> > scanl (+) 0 [1,2,3,4,5]
15:20:25 <Cheiron>  [0,1,3,6,10,15]
15:20:36 <Cale> > drop 1 . scanl (+) 0 $ [1,2,3,4,5]
15:20:38 <Cheiron>  [1,3,6,10,15]
15:20:50 <mmorrow> Myoma: http://hpaste.org/9991
15:20:51 <haskellian> i wasa disconnecteed, please answe again if u did
15:20:52 <MyCatVerbs> roconnor: ah! Yes, that's what I was trying to get at, only you've put it correctly rather than fuzzily. :)
15:20:52 <chessguy> &src scanl
15:20:53 <Cheiron> scanl f q ls = q : case ls of
15:20:53 <Cheiron>     []   -> []
15:20:53 <Cheiron>     x:xs -> scanl f (f q x) xs
15:21:09 <Cale> > scanl f z [1,2,3,4,5]
15:21:11 <Cheiron>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (f...
15:21:18 <maukf> haskellian: theFirst
15:21:24 <Myoma> mmorrow: Oh I see
15:21:41 <Cale> haskellian: We generally use camelCase for everything.
15:22:08 <Cale> haskellian: List variables generally have names ending in s, such as xs
15:22:38 <maukf> they do?
15:23:08 <Cale> haskellian: Also, slight variations on a function or variable are typically named ending in ' (pronounced prime in these cases)
15:23:23 <Cale> For instance foldl' is a strict variant of the left fold foldl
15:23:33 <maukf> I sometimes define foo' first, then foo based on foo'
15:23:37 <mmorrow> Myoma: i want to implem some stuff from those SAPL papers when i get a chance, it seems really interesting
15:23:37 <haskellian> i prefer some_functin but oh well, I will conform :)
15:24:03 <maukf> haskellian: me too, but the whole standard library disagrees
15:24:35 <Cale> I'm happy, because I dislike the underscore character :)
15:24:55 <Cale> (I don't know why)
15:25:05 <maukf> eNJOYnAMESlIKEtHIS
15:25:14 <dmhouse> I think the underscore is the nicest way of separating words.
15:25:21 <maukf> I prefer the hyphen
15:25:22 <Cale> maukf: heh, what?
15:25:29 <dmhouse> camelCase is not quite enough visual distincion, the hyphen way to little.
15:25:33 <mercury^> talking about the merits of camelCase vs other naming schemes?
15:25:37 <maukf> Cale: you can get names like that when translating C macros
15:25:52 <dmhouse> I find it very hard, when parsing Lisp, to distinguish when a function name ends and its parameters begin
15:25:56 <Cale> maukf: That can be avoided by just renaming them into camelCase
15:25:58 <maukf> the-hyphen-is-just-right
15:26:08 <MyCatVerbs> dmhouse: mmm, spaces?
15:26:16 <mercury^> I find camelCase is not very nice imo
15:26:22 <dmhouse> MyCatVerbs: it's just not quite visually distinctive enough
15:26:24 <Saizan_> Cale: i've sent you a patch, i think it has the ones missing
15:26:24 <mercury^> err, I find camelCase not very nice :)
15:26:29 <Cale> Saizan_: thanks :)
15:26:35 <yitz> Cale: years ago, the Perl community chose underscore over camel case mostly because it was found that non-native speakers of English have more trouble with camel case.
15:26:36 <MyCatVerbs> dmhouse: how about some spaces... and a kick in the teeth?
15:26:51 <MyCatVerbs> yitz: I like that reasoning. ^_^
15:26:51 <Cale> yitz: Oh?
15:26:57 <dmhouse> (if-you-have-a-long-func name-and-then-extra parameters) <- very hard to tell those atoms apart at a glance
15:26:58 <Cale> yitz: Why is that?
15:27:09 * Japsu thinks everyone should code in English anyway so the non-native speakers are a non-issue :)
15:27:10 <maukf> and because it generalizes to names_like_this, Names_Like_This and NAMES_LIKE_THIS
15:27:10 <dancor> camel can be iffy when you get into case-insensitive situations like sql
15:27:12 <stepcut> years ago, the LISP community chose dash over camel case ;)
15:27:12 <mercury^> The naming scheme promoted by Stroustrup is good imo.
15:27:25 <maukf> Japsu: what
15:27:27 <stepcut> names-like-this?
15:27:31 * Japsu is one of those non-issue non-native speakers btw
15:27:34 <Japsu> ;P
15:27:37 <jeffz> stepcut, names+like+this are good too.
15:28:06 <Japsu> it's quite annoying to read code that's a mixture of English and Finnish
15:28:35 <yitz> Cale: I think it is not as automatic for non-native speakers to parse them into separate words using subconscious semantic clues. The physical space provided by underscore (hyphen, whatever) makes that easier.
15:28:45 <MyCatVerbs> Japsu: well then, making everybody learn English is a stupid idea.
15:28:59 <MyCatVerbs> Japsu: let's make everyone learn Finnish instead, and we can all be just like Linus. ;)
15:28:59 <Ilmuri> Japsu: but finnish is so comfortable to think in ;<
15:29:24 <haskellian> outputting a Data.Map(imported as Dmap, how do i type that? markovProbs :: [String] -> Dmap
15:29:55 <maukf> Dmap.Map
15:30:10 <yitz> Ilmuri: that's it! from now on, all monad tutorials must be written in Finnish!
15:30:15 <Cale> haskellian: If you imported the module as Dmap, then the type constructor is named Dmap.Map and must be applied to two type arguments: the type of key and the type of value
15:30:55 <Cale> haskellian: Normally, I include another line below my initial qualified import which does  import Data.Map (Map), so that I don't have to refer to it as Map.Map or anything.
15:31:09 <tristes_tigres> maukf: But wouldn't modify (\s -> s{ first = first s + 1 }) lose all other fields of My ?
15:31:19 <Japsu> MyCatVerbs: English is the language of computing. I'm not suggesting (right now) that we should make everyone learn English (that'd be a good idea, too, but it's not the point), just the programmers
15:31:21 <maukf> tristes_tigres: no
15:32:32 <MyCatVerbs> Japsu: how about we compromise... make everyone learn Chinese. That way, we can write entire programs using single-character combinators.
15:32:40 <gwern> Cale: I am starting to wonder whether url was ever in the lb repo
15:32:45 <EvilTerran> tristes_tigres, variableName{...} is the "record modification" syntax
15:32:53 <r3m0t> Japsu: then all the philosophers should learn Greek, and all the musicians can learn Latin?
15:32:55 <Japsu> MyCatVerbs: Chinese is seriously impaired by their alphabet
15:33:04 <r3m0t> Japsu: all the physicists can learn German too!
15:33:04 <gwern> Cale: darcs annotate doesn't find it, and trackdown fails even with commands like darcs trackdown 'sh -c "ls /home/gwern/lambdabot/State/seen"'
15:33:06 <EvilTerran> tristes_tigres, as compared to ConstructorName{...}, which makes a new value from scratch
15:33:15 <Myoma> > (!)
15:33:16 <Japsu> r3m0t: Latin is not the language of music, Italian is
15:33:16 <lament> musicians already learn Italian
15:33:17 <Cheiron>  Add a type signature
15:33:18 <Cale> I'm now getting tons and tons of "Main: caught (and ignoring) too few bytes. Failed reading at byte position 18551"
15:33:23 <lambdabot>      Overlapping instances for Show (Array i e -> i -> e)
15:33:25 <lament> at least, a bunch of Italian words
15:33:29 <lambdabot>       arising from ...
15:33:32 <Shiruka> how can the chinese be impaired by their alphabet - it's not like there's any shortage of characters there!
15:33:35 <Japsu> da capo al fine!
15:33:50 <Cale> @seen Cale
15:33:53 <tristes_tigres> EvilTerrain: Aaah, thanks
15:33:53 <Myoma> so
15:33:55 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 18551
15:33:57 <EvilTerran> &seen Cale
15:33:57 <Cheiron> Cale is in #haskell. I last heard Cale speak 7s ago.
15:33:59 <MyCatVerbs> r3m0t: most musicians pick up a touch of Italian, most martial artists learn some Japanese or whatever the native language the tradition they're studying is rooted in.
15:34:07 <Myoma> expressive types are for embedding new typed language
15:34:09 <Cale> yep... that's the problem
15:34:21 <Cale> Apparently that seen file is not working.
15:34:23 <Myoma> and then writing programs in them that doesn't do anything special with types
15:34:32 <Cale> hmm
15:34:36 * Shiruka agrees that non-english code is ugly though
15:34:40 <MyCatVerbs> Shiruka: they're weighed down by it. Like an anchor.
15:34:45 <Saizan_> where's that error message from?
15:34:53 <Ilmuri> can't we all just omit speaking and make keyboards for body language?
15:35:00 <Japsu> it's funny though that the only non-English code I've come across has been Finnish
15:35:04 <Cale> oh, and check that out, when I killed lambdabot, it restarted (because that's what's in the script) and immediately got:
15:35:08 <Cale> Main: caught (and ignoring) too few bytes. Failed reading at byte position 8
15:35:12 <lament> Japsu: what natural languages do you speak?
15:35:16 <EvilTerran> tristes_tigres, btw, i am not a patch of land, i am someone from terra ;)
15:35:27 <Cale> .lambdabot/State/seen is now empty
15:35:42 <Cale> So whatever the heck is wrong with the seen module is still wrong with it.
15:35:54 <Shiruka> I haven't actually seen almost any code in finnish, just heard the horror stories :-)
15:35:57 <Japsu> lament: Finnish is my mother tongue and I speak English fluently. I know some Swedish and German, too.
15:36:00 <Saizan_> mmh, maybe it doesn't expect to be killed?
15:36:04 <mmorrow> Myoma: interesting observation
15:36:13 <yitz> Japsu: I've seen many languages. Including Russian transliterated into Latin letters.
15:36:20 <Japsu> Oh, and I read Norwegian somewhat easily ;)
15:36:26 <lament> Japsu: if Finnish and English are the languages you speak fluently, how is it surprising that those are the ones you've seen code in?
15:36:34 <Japsu> (That does not extend into understanding Norwegian speech.)
15:36:37 <tristes_tigres> EvilTerran: wouldn't thinking about oneself as a patch of land be kind of expansive &
15:36:42 <lament> just a basic observation bias
15:36:49 <tristes_tigres> ?
15:36:49 <EvilTerran> heh, quite
15:36:54 <Cale> hmm, that would be unfortunate, but would explain a lot ;)
15:36:54 <Myoma> (hopefully I'm wrong but) I get the impression really expressive typte systems are best for talking about weaker languages
15:37:08 <Myoma> maybe someone just has to tie the knot .. though ..
15:37:08 <Saizan_> Cale: Plugin.Seen implements moduleExit, so maybe it's that
15:37:10 <EvilTerran> Myoma, "weaker"?
15:37:13 <Japsu> lament: It wouldn't surprise me if it was only an overwhelming majority
15:37:23 <Japsu> but I don't recall seeing _any_ code in eg. German or French
15:37:30 * ddarius has seen German, Spanish, Portugese, and English code.
15:37:30 <Myoma> such as using CIC to prove Sys F is strongly normalizing
15:37:35 <mmorrow> Myoma: that would be ideal (the knot)
15:37:38 <Myoma> pretty easy you just embed it
15:37:43 <Cale> However, it still had some kind of problem reading the nonempty seen state.
15:37:46 <Shiruka> heh, I've seen almost no code in Finnish, but some in Japanese
15:37:56 <lament> i've seen code samples in the russian equivalent of Cobol
15:37:59 <Japsu> I've seen code in "English" written by Japanese.
15:38:02 <Japsu> Boy, that was traumatic.
15:38:04 <Shiruka> haha
15:39:15 <tristes_tigres> channel logs seem to be updated with a big delay, and my clent scroll buffer is too small
15:40:05 <yitz> Shiruka: romanji?
15:40:09 <FunctorSalad> embiggen it then
15:40:41 <Shiruka> Japsu: would the finnish code you've seen by any chance have been written by students?
15:40:44 <Myoma> @w80 embiggen
15:40:46 <lament> unshrink
15:40:57 <Japsu> Shiruka: some, but not all of it
15:40:58 <FunctorSalad> Myoma: it's in wiktionary :D
15:40:58 <tristes_tigres> functorSalad: yeah, if only it allowed that
15:41:05 <FunctorSalad> (at least it used to be)
15:41:18 <tristes_tigres> @bot
15:41:20 <yitz> @go embiggen
15:41:31 <Shiruka> yitz: hm, actually the identifiers might have been english.. the comments were proper japanese though
15:41:38 <Japsu> my opinion is that students should be taught to write code in English from the very beginning... not everyone agrees, of course
15:41:54 <Ilmuri> Shiruka: most finnish code I see is made by beginners of beginners.. naturally in an interpreted BASIC-variant
15:42:17 <Ilmuri> their cargo cults have built ziggurats
15:42:19 <ddarius> The TUNES log is update immediately.
15:42:21 <binrapt> lol BASIC
15:42:37 <saya_> i see lots of pseudo code in french and we dont have alot of problems translating it to english
15:42:37 <binrapt> I've never actually been confronted with BASIC for educational purposes.
15:42:42 <lament> Japsu: it's hard to write code in English when you don't speak it
15:42:46 <FunctorSalad> wasn't tunes that singularitarian page?
15:43:01 * tristes_tigres thinks judging by the number of code coming from finland, even penguins there program
15:43:05 <lament> Japsu: and learning English is much harder than learning a programming language
15:43:33 <FunctorSalad> lament: if you don't know any PL I'm not sure
15:43:35 <gwern> tristes_tigres: I think the issue is that they have a lot of computers but not a lot they can do
15:43:52 <Ilmuri> binrapt: a finnish basic-variant meant for gameprogramming :P
15:43:53 <gwern> it's finland - what are they going to do but drink themselves into a depression, take a sauna, or code?
15:43:55 <ddarius> All the wild penguins in Finland do program.
15:44:06 <binrapt> That sounds terible
15:44:17 <Cale> okay, this appears to finally be working!
15:44:19 <Ilmuri> gwern: do all of them and fuck anything that doesn't output binary
15:44:23 <Japsu> lament: the students I've been teaching the Other Programming Language (*whistles*) have been first-years students in upper secondary school... at that level you should be able to assume at least _some_ skills in English. most of them have been studying English for six years, and everyone's at least for three years
15:44:29 <binrapt> :t readFile
15:44:29 <Nafai> ddarius: And a penguin in Norway is a knight!
15:44:30 <Cheiron> FilePath -> IO String
15:44:33 <Cale> @seen Cale
15:44:36 <Shiruka> gwern: all three at the same time, but the depression only comes in the morning
15:44:38 <lambdabot> You are in #haskell and #ghc. I last heard you speak just now.
15:44:46 <gwern> Ilmuri: well said
15:44:52 <binrapt> Hmm what happens if readFile fails?
15:44:57 <binrapt> How do I check for that case?
15:44:57 <lament> FunctorSalad: Having not known any PL and then having learnt several, and having learnt English, I think English is much harder (obviously it's a very different task - it just takes more time and effort)
15:44:59 <tristes_tigres> @vixen penguins ?
15:45:04 <lambdabot> why don't you guess?
15:45:13 <maukf> binrapt: terrible! :/
15:45:19 <gwern> Shiruka: as I once heard, if the hangover came before the drunkenness, getting drunk would be virtuous
15:45:24 <Myoma> my dogs got no nose
15:45:25 <binrapt> I expected Maybe IO String or something
15:45:32 <binrapt> maukf: Huh?
15:45:33 <gwern> Cale: how you fix bot?
15:45:33 <Japsu> ddarius: No, that would be the domesticated penguins. What use would there be for our code farms if wild penguins would code?
15:45:35 <FunctorSalad> lambdabot: I guess it depends on how you match up skill levels between them
15:45:38 <yitz> binrapt: an IO exception is raised
15:45:38 <saya_> :t readFile
15:45:40 <Cheiron> FilePath -> IO String
15:45:41 <FunctorSalad> lament:
15:45:43 <Saizan_> binrapt: it throws an exception, see Control.Exception.catch
15:45:48 <binrapt> Oh I guess I gotta read up on exceptions first then
15:46:00 <maukf> @src readFile
15:46:07 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
15:46:09 <gwern> Japsu: wild code has a gamier taste to it some people like?
15:46:18 <Cale> gwern: By getting Saizan to make patches that include the State/ files, and modifying the deps to not include mueval, and well, basically deleting my existing copy of the repo and starting over :)
15:46:20 <yitz> @type catch
15:46:21 * ddarius imagines Finland has some penguins in a zoo somewhere so the statement wouldn't be vacuously true for them.
15:46:25 <lambdabot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
15:46:29 <Cale> oh...
15:46:31 <Japsu> ddarius: ;P
15:46:35 <Cale> right, that's got to be fixed...
15:46:46 <yitz> &type catch
15:46:47 <Cheiron> forall a. IO a -> (IOError -> IO a) -> IO a
15:47:04 <maukf> &type Control.Exception.catch
15:47:05 <Cheiron> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
15:47:06 <yitz> &type Control.Exception.catch
15:47:07 <Cheiron> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
15:47:10 <Cale> imports.h should probably be moved into State/
15:47:14 <Shiruka> finns keep penguins in the freezer and eat them for snack
15:47:53 <Cale> uhhh...
15:47:58 <Shiruka> or at least ice cream with a penguin logo on them, but close enough
15:48:04 <Cale> Oh, Pristine.hs no longer uses CPP?
15:48:08 <Cale> then how...
15:48:11 <Cale> oh, I see
15:48:30 <yitz> penguins keep fins in the freezer and use them to swim
15:48:32 <Ilmuri> Shiruka: they're enchanted with the ESSENCE OF CODING
15:48:55 <Ilmuri> yitz: the whole place is a giant freezer
15:49:42 <Shiruka> the only difference is that there are no polar bears in a freezer
15:50:38 <tristes_tigres> If Penguin is a constructor, PolarBear is a destructor
15:50:48 <Ilmuri> Shiruka: the truth is finland has only neutral bears
15:51:14 <tristes_tigres> PolarBear Penguin = nil
15:51:20 <mapreduce> These monads smell fishy.
15:51:22 <maukf> cartesian bears?!
15:51:25 <Shiruka> sounds dangerous.. at least with polar bears you can get out of a sticky situation by reversing the polarity
15:51:25 <Cale> Well, I'll fix the type bug after dinner, I'll need to know how to get the path to State though.
15:51:28 <FunctorSalad> tristes_tigres: no no, you destruct polar bears by taking their logarithm
15:51:50 <awesame> so, I have a type like this: data Lang = Python | Php deriving (Read, Show)
15:52:13 <Myoma> why not PHP
15:52:16 <awesame> and I'm currently reading the name of the language to use from various places
15:52:23 <Myoma> Php looks odd
15:52:29 <awesame> I want 'PHP' and 'php' and 'Php' to all work
15:52:48 <awesame> is there some easy way to do that?
15:52:55 <Myoma> ((==)`on`downcase) where downcase = map toLower
15:53:11 <lament> awesame: No.
15:53:11 <Myoma> you must write your own read and show instances though
15:53:14 <mapreduce> Don't forget PhP.
15:53:24 <awesame> blah
15:53:33 <awesame> I really want a case-insensitive maybeRead
15:53:43 <mapreduce> :t maybeRead
15:53:44 <Cheiron> Not in scope: `maybeRead'
15:53:45 <Myoma> why must it be a read
15:53:45 <lament> call it something other than read
15:54:22 <awesame> sorry, maybeRead is my own thing
15:54:30 <gwern> Cale: the path to State/? have you looked at my File.hs module?
15:55:46 <mmorrow> awesame:  data Lang = PYTHON | PHP  deriving (Show,Read)           read' = read . map toUpper       ?
15:56:11 <awesame> hm, that's a pretty decent suggestion
15:56:37 <mmorrow> or Python | Php          read' = read . (\(x:xs) -> toUpper x : xs) . map toLower
15:56:51 <mmorrow> (checking for a [] of course)
15:57:34 <awesame> yeah, I guess I can just transform the string before reading it
15:57:40 <mmorrow> totally
15:58:23 <awesame> can I do that as a read instance somehow?
15:58:29 <binrapt> What is the terminological difference between a function which you can only evaluate in a do block and the normal pure function which performs no IO etc? (no monads?)
15:58:39 <awesame> I wouldn't know how to reference the derived one...
15:58:51 <binrapt> Is a function which performs IO in Haskell still called pue?
15:58:54 <dons> binrapt: one is monadic?
15:58:54 <mmorrow> you could write your own Read instance, and have it try a number of possibilities before failing
15:58:54 <binrapt> pure*
15:59:00 <binrapt> Monadic ok
15:59:37 <awesame> yeah, I'm not crazy about updating my read function every time I add something to this type
16:00:10 <maukf> binrapt: technically, no function performs IO
16:00:27 <binrapt> maukf what do you call it then?
16:00:43 <maukf> call what
16:01:06 <binrapt> Monadic function vs. non-Monadic function I guess?
16:01:13 <maukf> meh
16:01:15 <binrapt> What I described above
16:01:21 <maukf> there is no difference
16:02:49 <mmorrow> awesame: get the derive package from hackage and install it. it come with a lib + a command line tool to auto-derive things for you. it won't completely solve your problem, but may make things easier somehow
16:03:16 <awesame> hm, I'll take a look
16:03:19 <awesame> thanks mmorrow
16:03:28 <mmorrow> it's pretty handy
16:04:22 <adu> ah :)
16:04:50 * BMeph likes read' = read . (toUpper *** map toLower) . splitAt 1
16:05:07 <adu> my favorite words :) pure, monadic, auto-derive...
16:05:32 <noohgodno> i like the word "opacity"
16:05:37 <awesame> BMeph: what's ***?
16:05:46 <adu> noohgodno: I think 'transparency' is better
16:05:46 <maukf> @index (***)
16:05:47 <lambdabot> Control.Arrow
16:05:59 <BMeph> awesame: f ** g (x,y) = (f x, g y)
16:06:04 <BMeph> s/**/***/
16:06:40 <BMeph> awesame: Well, rather: (f *** g) (x,y) = (f x, g y)
16:06:45 <awesame> ah
16:06:47 <awesame> handy!
16:07:33 <adu> BMeph: is that the same as (***) :: a b c -> a b' c' -> a (b, b') (c, c')?
16:07:47 <Myoma> adu: change a b c to (b ~> c)
16:07:49 <yitz> &type readLang = read . uncurry (++) . (***) `on` map toUpper  toLower . splitAt 1
16:07:51 <Cheiron> parse error on input `='
16:07:53 <Myoma> one Arrow is where ~> is ->
16:08:02 <yitz> &type  read . uncurry (++) . (***) `on` map toUpper  toLower . splitAt 1
16:08:04 <Cheiron>     Couldn't match expected type `(String, String)'
16:08:04 <Cheiron>            against inferred type `a b' c' -> a (b, b') (c, c')'
16:08:04 <Cheiron>     Probable cause: `***' is applied to too few arguments
16:08:28 <adu> BMeph: i don't like that symbol
16:08:37 <yitz> &type  read . uncurry (++) . ((***) `on` map) toUpper  toLower . splitAt 1
16:08:39 <Cheiron> forall a. (Read a) => [Char] -> a
16:09:24 <BMeph> adu: If you mean: 1) (***) :: (Arrow a) => a b c -> a b' c' -> a (b,b') (c,c')
16:09:44 <yitz> >  let preRead = uncurry (++) . ((***) `on` map) toUpper  toLower . splitAt 1 in preRead "php"
16:09:45 <lambdabot>  mueval: Prelude.read: no parse
16:09:46 <Cheiron>  "Php"
16:09:51 <BMeph> adu: and 2) instance (->) Arrow, then yes, that's precisely the (***) I mean. :)
16:09:59 <yitz> >  let preRead = uncurry (++) . ((***) `on` map) toUpper  toLower . splitAt 1 in preRead "PHP"
16:10:00 <lambdabot>  mueval: Prelude.read: no parse
16:10:01 <Cheiron>  "Php"
16:10:20 <yitz> hmm. Cale?
16:11:14 <BMeph> adu: I like the symbol very much; I just think it ought to be in say, a Data.Pair insteaed. :)
16:11:35 <BMeph> s/insteaed/instead/
16:11:35 <adu> BMeph: ya, I don't like the choice of symbol, because I'd like to use iterated exponentials with haskell, but the traditional notation (^^) is taken by the standard prelude, and the other possible notation is (***) which is taken by the arrow stuff, which means (++++) is the only one left for iterated exponentials
16:12:00 <Myoma> adu: Ignore what previously exists
16:12:09 <Myoma> adu: You can just not import them
16:12:10 * BMeph looks up i. e. on Wikipedia...
16:12:21 <adu> BMeph: Tetration
16:12:56 <noohgodno> > 5
16:12:57 <lambdabot>  5
16:12:58 <Cheiron>  5
16:14:56 * BMeph feels wiser (but isn't)
16:15:30 <BMeph> adu: You /do/ know that you can redefine symbols inHaskell, right? ;)
16:16:27 <chrisdone> when variables are to be in uppercase, for whatever reason, what's the convention to do that in Haskell? fOO, _FOO, or other?
16:16:34 <adu> BMeph: i know you can hide them
16:16:50 <adu> BMeph: so I'm more sad about (^^) than (***)
16:17:11 <BMeph> adu: Take hope: if we just made the (><) function a standard, we can ditch (***) then. ;)
16:18:25 <BMeph> Hmm, maybe that ought to be (->^) instead of (><)...
16:19:02 <maukf> ^v^v<> a b START
16:19:20 <BMeph> Where (f,g) >< (x,y) == (f x, g y)
16:19:42 <adu> BMeph: if only hiding the Prelude and including the numeric prelude was as easy as "-np"
16:20:10 <Myoma> BMepd: $$
16:20:13 <Myoma> BMeph: ($$)
16:20:27 <BMeph> Maybe it should be (>$<), as a clue to its purpose.
16:20:34 <Myoma> why not $$
16:21:17 <BMeph> adu: I blame the GHC crew - give us GHC 12, already, I NEED that info from the Future! ;)
16:22:21 <stepcut> BMeph: doesn't conal have a library for values from the future ?
16:23:07 <BMeph> stepcut: Uh, if he does, you should ask *him* about it, heh-heh. :)
16:23:48 <yitz> > ((+1) *** (*4)) (2,3)
16:23:49 <lambdabot>  mueval: Prelude.read: no parse
16:23:50 <Cheiron>  (3,12)
16:23:51 <BMeph> Myoma: ($$) is already used in pretty-printing.
16:24:23 <BMeph> ((+1),(*4))><(2,3)
16:24:47 <yitz> @tell Cale This parses in Cheiron, but not \bot: > ((+1) *** (*4)) (2,3)
16:24:48 <lambdabot> Consider it noted.
16:25:05 <Myoma> not a problem to just reuse that operator
16:25:45 <BMeph> Myoma: True. The same for any other operator. I'd like to use (?) for (*), and see folks Freak Out! ;)
16:26:19 <adu> I suppose I could alias ghci="ghc --interactive -XNoImplicitPrelude NumericPrelude.hs"
16:26:28 <mmorrow> awesame: http://hpaste.org/9995
16:27:27 <awesame> mmorrow: neat!
16:28:26 <adu> mmorrow: is that Data.Derive?
16:29:15 <adu> :t (><)
16:29:16 <Cheiron> Not in scope: `><'
16:30:12 <adu> ah, (><) is (++) for Seq
16:35:51 <seydar> what does "qualified" mean in an import statement?
16:36:03 <bjrn> Is there a stateful version of Bytestring somewhere? I have a bunch of functions that in essence "take"s N bytes from a bytestring, transforms then, "drop"s N bytes, returning the shorter bytestring.
16:36:10 <maukf> don't dump names in the global scope
16:36:21 <adu> seydar: it renamed stuff
16:36:35 <maukf> there's a Get monad in Data.Binary
16:36:36 <mmorrow> awesame, adu: yeah, Data.Derive. here's a demonstration of a few of the classes it can derive: http://hpaste.org/9995#a1
16:36:43 <seydar> adu: so it overwrites any functions already defined?
16:36:55 <adu> seydar: like import qualified Prelude as P, means you have to use "P.map" instead of "map"
16:37:13 <bjrn> seydar: it's used to avoid polluting the namespace
16:37:19 <seydar> but couldn't i do that already without the qualified and just as?
16:37:47 <mmorrow> awesame, adu: also, the TH prettyprinter is kinda hideous, but hstidy uses the haskell-src-exts prettyprinter and i've found it to be nice
16:37:47 <bjrn> maukf: Ah will check it out, thanks
16:37:54 <adu> seydar: I don't think so
16:38:04 <seydar> gotcha. thanks all!
16:38:05 <adu> import Prelude as P is a syntax error I think
16:38:30 <adu> I didn't make the rules
16:38:43 <maukf> I don't think it's an error
16:38:47 <adu> really?
16:38:52 <adu> then why "qualified"?
16:38:54 <maukf> IIRC it lets you use both map and P.map
16:39:04 <maukf> and probably also Prelude.map
16:39:05 <Myoma> hmmm
16:39:11 <Myoma> How to write a pretty printer?
16:39:16 <adu> mauke: no it doesn'yt
16:39:18 <Myoma> I know how to do it in a fold for infix ops and such
16:39:35 <Myoma> but what about if _ then _ else, do _ ... and case and stuff?
16:39:39 <aCiD2> hello
16:39:49 <adu> aCiD2: hi
16:39:56 <aCiD2> I'm reading the Real World Haskell book online atm - and I had a thought... are namespaces not required in Haskell?
16:40:04 <aCiD2> I mean, it seems that everything lives in the same namespace?
16:40:22 <adu> aCiD2: no, everything lives in 5 namespaces
16:40:27 <aCiD2> oh?
16:40:28 <lament> heh
16:40:45 <lament> aCiD2: things of the same kind (eg. variables) do all live in one big namespace
16:40:48 <bjrn> aCiD2: For GHC http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
16:40:49 <lambdabot> Title: Haskell Hierarchical Libraries
16:40:58 <lament> aCiD2: unless *drumroll* you use modules!
16:41:04 <adu> aCiD2: (Uppercase values, lowercase values, Uppercase types, lowercase types, and Modules)
16:41:21 <lament> aCiD2: do you know Python?
16:41:24 <aCiD2> yea
16:41:31 <aCiD2> and I know modules in Haskell, a bit
16:41:40 <mmorrow> awesame, adu: i almost forgot Data and Typeable http://hpaste.org/9995#a2
16:41:47 <lament> aCiD2: you know how in python you can do import foo; foo.bar; OR you can do from foo import *; bar;
16:41:52 <aCiD2> yup?
16:42:03 <lament> aCiD2: in Python, the convention is to use the former
16:42:12 <lament> in Haskell, both those options are also available
16:42:19 <lament> but the convention is to use the latter when possible
16:42:34 <aCiD2> right - and that doesn't cause problems or collisions or whatever much?
16:42:39 <lament> no
16:42:44 <lament> because if there're problems, the compiler would tell you
16:42:49 <aCiD2> right
16:43:22 <bjrn> also the documentation usually mentions if a module function can collide with the prelude
16:43:28 <adu> aCiD2: is does with Data.Map, Data.Set, and Data.Seq
16:43:50 <aCiD2> but I mean, with things like data types if you do data Foo = Bar { id :: Integer } - that creates accessors, right? Don't you get collisions with the same named fields?
16:43:55 <adu> aCiD2: so ppl usually use "import qualified Data.Map as M"
16:44:01 <lament> aCiD2: oh. Yes. You do.
16:44:05 <aCiD2> I haven't tried actually using Haskell yet, so maybe I'm inventing problems :)
16:44:13 <lament> aCiD2: no, that's an actual, real problem
16:44:17 <aCiD2> ah
16:44:23 <Myoma> it's not really
16:44:27 <lament> aCiD2: named fields are not a very well-thought-out feature
16:44:38 <Myoma> you can just not import any module that exports id
16:44:54 <lament> Myoma: but what if you have several types that all need an id field
16:44:54 <haskellian> *MarkovSentenceGen> f
16:44:55 <haskellian> fromList [("hej",4),("hejsan",4)] , I want to add 1 to hejsan, adjustWithKey seem like the right one but what does k -> a -> a mean? what is he syntax of changing the correspong value of a key?
16:45:13 <aCiD2> lament, yes - that's my thought. And they're in the same module
16:45:19 <lament> aCiD2: right. you can't do that.
16:45:23 <Myoma> :t adjustWithKe
16:45:24 <Myoma> :t adjustWithKey
16:45:25 <Cheiron> Not in scope: `adjustWithKe'
16:45:25 <Cheiron> Not in scope: `adjustWithKey'
16:45:32 <adu> aCiD2: from what i've seen ppl usually invent their own namespace scheme like "data Color = MkColor { colorRed, colorGreen, colorBlue :: Int }
16:45:38 <haskellian> also, why not just integrate Data.Map in the prelude with the {} syntax?
16:45:39 <lament> aCiD2: call it fooId
16:45:40 <Saizan_> :t M.adjustWithKey
16:45:42 <Cheiron> forall k a. (Ord k) => (k -> a -> a) -> k -> M.Map k a -> M.Map k a
16:45:47 <Saizan_> :t M.adjust
16:45:48 <Cheiron> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
16:45:51 <haskellian> :t Data.Map.adjustWithKey
16:45:53 <Cheiron> forall k a. (Ord k) => (k -> a -> a) -> k -> M.Map k a -> M.Map k a
16:46:03 <aCiD2> ok - I thought that would be the solution, just wondered if there was a slightly more organised one
16:46:19 <aCiD2> but obviously, being a non-oo language, I guess that's as good as it gets
16:46:26 <aCiD2> thanks for helping :)
16:46:34 <Saizan_> > M.adjust (+1) "hejsan" $ M.fromList [("hej",4),("hejsan",4)]
16:46:35 <lambdabot>  mueval: Prelude.read: no parse
16:46:36 <Cheiron>  fromList [("hej",4),("hejsan",5)]
16:46:45 <maukf> M.adjust succ "hejsan"
16:47:10 <lament> aCiD2: right - otherwise, it would be ad-hoc overloading of functions, which haskell definitely doesn't allow
16:47:17 <aCiD2> true
16:47:27 <aCiD2> i just wondered if there was a way to have a type namespace as well
16:47:30 <adu> aCiD2: but you should know that each accessor is a global function that has the type "colorRed :: Color -> Int"
16:47:42 <Saizan_> you can define each record in its own module
16:48:00 <aCiD2> adu: yup, I know that, which was what initially made me think "I can see a problem there..."
16:48:09 <haskellian> ty
16:48:10 <Saizan_> or use typeclasses if those fields have actually something in common
16:48:15 <aCiD2> that's true
16:48:32 <aCiD2> and in the id case, it problem is better solved with typeclasses
16:49:27 <lament> don't call it id, in any case
16:49:34 <lament> :t id
16:49:35 <Cheiron> forall a. a -> a
16:49:38 <adu> ya, Class = type class + data constructor ... Object = type class + data value
16:49:42 <mmorrow> :t id id
16:49:43 <Cheiron> forall a. a -> a
16:49:48 <aCiD2> heh
16:49:51 <lament> 'id' is already a commonly used function
16:49:52 <mmorrow> :t id . id
16:49:53 <Cheiron> forall a. a -> a
16:49:55 <Myoma> :t flip id
16:49:57 <Cheiron> forall b c. b -> (b -> c) -> c
16:50:03 <adu> aCiD2: which means type class = interface + class + object
16:50:05 <mmorrow> :t (flip . flip) id
16:50:07 <Cheiron> forall b c. (b -> c) -> b -> c
16:50:14 <Myoma> :t flip . flip . id
16:50:15 <Cheiron> forall a b c. (a -> b -> c) -> a -> b -> c
16:50:21 <mmorrow> :t (flip . flip . flip) id
16:50:23 <Cheiron> forall b c. b -> (b -> c) -> c
16:50:26 <Myoma> !
16:50:26 <Saizan_> however there are already many proposals for a better record system
16:50:42 <mmorrow> Myoma: it normalizes after (flip . flip)
16:50:43 <adu> Saizan_: gotta link?
16:51:34 <aCiD2> well, thanks for letting me have this discussion - has cleared some of my thoughts up :)
16:51:44 <mmorrow> Myoma: i don't know how to say it precisely, but (flip . flip) is id on all functions /except/ those w/ arity < 2
16:51:56 <Saizan_> adu: http://www.haskell.org/haskellwiki/Extensible_record
16:51:57 <lambdabot> Title: Extensible record - HaskellWiki
16:52:18 <Myoma> flip . flip = id :: (p -> q) -> (p -> q) -- does that do it?
16:52:24 <adu> ooo I love HLists
16:52:25 <Myoma> er...
16:52:29 <mmorrow> hmm
16:52:31 <Myoma> flip . flip = id :: (p -> q -> o) -> (p -> q -> o) -- does that do it?
16:53:08 <mmorrow> yeah, i believe so
16:53:23 <Saizan_> adu: yeah, but HList is kind of an hack :)
16:53:40 <Myoma> :t flip . flip $ (?f :: (u -> v -> w -> o)
16:53:41 <Cheiron> parse error (possibly incorrect indentation)
16:53:41 <Myoma> :t flip . flip $ (?f :: (u -> v -> w -> o))
16:53:42 <Cheiron>     Could not deduce (?f::u -> v -> w -> o) from the context ()
16:53:43 <Cheiron>       arising from a use of implicit parameter `?f'
16:53:43 <Cheiron>                    at <interactive>:1:15-16
16:54:27 <mmorrow> Myoma: hah, nice. it just hit me that it's made precise by just doing  :t (flip . flip)   ... nothing else needed
16:54:29 <adu> You know, all think talk about deptypes and hlists and Haskell' is making me realize something
16:54:48 <Myoma> adu: It's all completely useless?
16:54:51 <adu> Haskell _is_ the new C
16:55:13 <Saizan_> new C as in?
16:55:21 <adu> because all of these features are probably going to be implemented in Haskell
16:55:22 <Capso> Huh?
16:55:41 <Myoma> hello Capso
16:55:48 <Capso> Hello, Myoma.
16:55:48 <adu> like how Agda compiles to Haskell... which compiles to C... which compiles to...
16:55:55 <mmorrow> i think adu means in the sense that C has implement most every programming lang at least once
16:55:57 <Myoma> turtles
16:56:02 <Capso> Myoma: Just being friendly, or have we seen each other around?
16:56:12 <Myoma> Capso: both
16:56:26 <Ilmuri> adu: let's just wait till it compiles back to haskell
16:56:30 <Capso> Really, the latter? Where?
16:57:16 <Saizan_> Ilmuri: on a graph-reducing machine?:)
16:57:46 <im_alone> @google graph machine
16:57:56 <lambdabot> http://citeseer.ist.psu.edu/5386.html
16:57:56 <lambdabot> Title: Universidad Polit'ecnica de Madrid y - CiteSeerX
16:58:03 <Myoma> lean mean graph reducing lambda machine
16:58:19 <Capso> Myoma: Where else have we seen each other? :)
16:58:46 <im_alone> @google graph reducing machine
16:58:48 <lambdabot> No Result Found.
16:59:10 <im_alone> @google graph lambda machine
16:59:22 <lambdabot> http://lambda-the-ultimate.org/node/87
16:59:22 <lambdabot> Title: Richard Feynman and the Connection Machine | Lambda the Ultimate
16:59:28 <shteou> Doesn't George Foreman sponsor that, Myoma?
16:59:33 <Myoma> I hope so
16:59:41 <Capso> im_alone: See Graph Reduction Machine
16:59:54 <im_alone> @google graph reduction machine
16:59:57 <lambdabot> http://en.wikipedia.org/wiki/Graph_reduction_machine
16:59:57 <lambdabot> Title: Graph reduction machine - Wikipedia, the free encyclopedia
17:00:04 <BMeph> ?go Reduceron
17:00:07 <im_alone> thanks Capso
17:00:07 <BMeph> RAWR! :)
17:00:07 <lambdabot> No Result Found.
17:00:22 * BMeph boos at lambdabot. Boo!
17:00:49 <adu> Ilmuri: does it already?
17:00:57 <adu> well not all...
17:01:01 <Pseudonym> ?go "SKIM the s k i reduction machine"
17:01:12 <adu> Someone needs to write some language beginning with P in haskell
17:01:13 <lambdabot> http://www.patentstorm.us/patents/4502118.html
17:01:13 <lambdabot> Title: Concurrent network of reduction processors for executing programs stored as tree ...
17:01:14 <FunctorSalad> oh no
17:01:16 <Myoma> adu, why
17:01:20 <Pseudonym> Please no.
17:01:28 <Pseudonym> Don't tell me there's a patent on functional programming.
17:01:32 <BMeph> www.cs.york.ac.uk/~mfn/reduceron2/
17:01:34 * Pseudonym sighs deeply
17:01:54 <Pseudonym> OK, it's hardware.  I guess that's okay, grumble grumble.
17:01:55 <FunctorSalad> "Method for exercising a cat with a monad"
17:01:57 <mmorrow> @help
17:01:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:02:05 <mmorrow> @help go
17:02:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:02:10 <Pseudonym> ?go "super-combinators a new implementation method for applicative languages"
17:02:14 <lambdabot> http://portal.acm.org/citation.cfm?id=802129
17:02:14 <lambdabot> Title: Super-combinators a new implementation method for applicative languages
17:02:18 <Pseudonym> Woo.
17:02:21 <adu> Pseudonym: there a patent?
17:02:27 <mmorrow> how to you set something so that from then on ?go goes
17:02:28 <mmorrow> ?"
17:02:28 <lambdabot> Maybe you meant: . ? @ v
17:02:38 <mmorrow> ?set
17:02:39 <Pseudonym> adu: Scroll up.
17:02:39 <lambdabot> Defined.
17:02:47 <im_alone> @google reduction lambda patent
17:02:53 <lambdabot> http://www.freepatentsonline.com/4662335.html
17:02:53 <lambdabot> Title: Automatic control of contaminant reduction - Patent 4662335
17:03:03 <mmorrow> @google reduceron
17:03:05 <lambdabot> No Result Found.
17:03:08 <im_alone> is there or not a patent in lambda calculus?
17:03:09 <Pseudonym> ?go patent "applicative language"
17:03:11 <lambdabot> http://www.freepatentsonline.com/5099450.html
17:03:11 <lambdabot> Title: Computer for reducing lambda calculus expressions employing variable containing  ...
17:03:13 <mmorrow> @google reduceron haskell
17:03:15 <lambdabot> No Result Found.
17:03:20 <mmorrow> bah
17:03:23 <im_alone> :(
17:03:31 <Pseudonym> im_alone: No, the patents are on lambda calculus CPUs.
17:03:45 <Pseudonym> Which makes a certain amount of sense.
17:03:50 <Pseudonym> Machines like SKIM.
17:03:55 <Pseudonym> Or SECD in microcode.
17:04:30 <SamB_XP_> you can't patent lambda calculus, since it's clearly theoretical mathematics ;-P
17:04:42 <Pseudonym> Indeed.  And there's lots of prior art.
17:04:59 <SamB_XP_> that too ;-)
17:05:15 <haskellian> how do i refer to a Data.Map inside a Data.Map?
17:05:18 <Capso> Myoma: This is rather rude, but whatever.
17:05:28 <haskellian> *MarkovSentenceGen> q4
17:05:28 <haskellian> fromList [("yes",fromList [("hej",2)])]
17:05:34 <Myoma> Capso: oh well sorry
17:06:18 <Pseudonym> haskellian: It's pretty straightforward.  What's its type?
17:06:50 <Pseudonym> :t Data.Map.fromList [("yes",Data.Map.fromList [("hej",2)])]
17:06:51 <Cheiron> forall t. (Num t) => M.Map [Char] (M.Map [Char] t)
17:06:58 <Pseudonym> :t Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])]
17:06:59 <Cheiron> M.Map [Char] (M.Map [Char] Int)
17:07:03 <Pseudonym> Just to be clear.
17:07:08 <Pseudonym> Oh, who's Cheiron?
17:07:13 <Pseudonym> @version
17:07:13 <lambdabot> lambdabot 4.2
17:07:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:07:26 <FunctorSalad> :version
17:07:27 <Pseudonym> Is it just me or does lambdabot spend most of its time not being lambdabot these days?
17:08:20 <FunctorSalad> :vixen would you say that you have the same personal identity as lambdabot?
17:08:26 <FunctorSalad> hmm
17:08:36 <FunctorSalad> @bot
17:08:37 <lambdabot> :)
17:08:48 <Pseudonym> Spooky.
17:08:54 <FunctorSalad> Cheiron appears to be some light version
17:09:29 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in Data.Map.lookup m "hello"
17:09:31 <Cheiron>     Couldn't match expected type `M.Map
17:09:31 <Cheiron>                                     (M.Map [Char] (M.Map [Char] Int)) a'
17:09:31 <Cheiron>            against inferred type `[Char]'
17:09:37 <Pseudonym> :t Data.Map.lookup
17:09:38 <Cheiron> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
17:09:41 <Pseudonym> Ah, right.
17:09:46 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in Data.Map.lookup "hello" ,
17:09:47 <Cheiron> parse error on input `,'
17:09:50 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in Data.Map.lookup "hello" ,
17:09:51 <Cheiron> parse error on input `,'
17:09:52 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in Data.Map.lookup "hello" m
17:09:53 <Cheiron> forall (m :: * -> *). (Monad m) => m (M.Map [Char] Int)
17:09:56 <Pseudonym> That's it.
17:10:02 <Pseudonym> So tehre you are, you have another map.
17:10:12 <Saizan_> lambdabot has been cabalized and runplugs has been substitued with the ghc-api, this has induced some bugs
17:10:13 <Pseudonym> You can also do this if you know the keys are okay:
17:10:33 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in m Data.Map.! "hello" Data.Map.! "world
17:10:34 <Cheiron> lexical error in string/character literal at end of input
17:10:37 <Pseudonym> :t let m = Data.Map.fromList [("yes",Data.Map.fromList [("hej",2 :: Int)])] in m Data.Map.! "hello" Data.Map.! "world"
17:10:39 <Cheiron> Int
17:10:42 <Pseudonym> Perfect.
17:12:24 <Myoma> hmm It sucks when a program works in one compiler but not another
17:13:11 <Pseudonym> Anyone got a spare NZ$100?
17:13:13 <im_alone> i know SECD and SKI machines, are there more?
17:13:18 <haskellian> thats not simple, its ridic
17:13:27 <Pseudonym> http://www.renaissancebooks.co.nz/?page=shop/flypage&product_id=5103&keyword=b+curry+feys+haskell+robert&searchby=author&offset=0&fs=1&CLSN_2133=12199686952133d19dad5956a3f9ed09 <- You're not going to find a copy anywhere else.
17:13:30 <FunctorSalad> Saizan_: hmm. I installed lambdabot locally recently via cabal and it seemed fine
17:13:33 <BMeph> ?go Reduceron2
17:13:43 <FunctorSalad> Saizan_: of course I didn't try stuff like @seen
17:13:47 <Pseudonym> haskellian: I only did Data.Map.foo because of lambdabot's eval.
17:13:48 <lambdabot> http://www.cs.york.ac.uk/~mfn/reduceron2/
17:13:48 <lambdabot> Title: The Reduceron
17:14:08 <im_alone> thanks
17:14:13 <Saizan_> FunctorSalad: still running it from the repo, right?
17:15:10 <FunctorSalad> Saizan_: think cabal downloaded it
17:15:16 <im_alone> machine here is defined as abstract machine, ok
17:15:18 <im_alone> ok?
17:15:42 <Saizan_> FunctorSalad: oh, you just did cabal install lambdabot ?
17:15:49 <haskellian> fromList isnt the funciton i want
17:16:12 <im_alone> @google lambda abstract machine
17:16:12 <FunctorSalad> Saizan_: some days ago
17:16:16 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
17:16:21 <haskellian> i want to update fromList [("yes",fromList [("hej",2)])] 2 to 3
17:16:21 <dibblego> what function goes [Either a b] -> Either [a] [b] accumulating Rights until a Left and so all Lefts?
17:16:38 <Myoma> you don't want [Either a b] -> ([a],[b]) ?
17:16:39 <BMeph> im_alone: Reduceron's more vaporware, so that's kind of abstract... ;)
17:16:55 <dibblego> no I don't
17:16:56 * Pseudonym is currently reading "On the roles of types in mathematics" by de Bruijn.  I never realised how readable it is.
17:17:00 <FunctorSalad> "lambdabot 4p0, GHC 6.8.3", "darcs get"
17:17:09 <newsham> "and so all Lefts" ?
17:17:12 <im_alone> BMeph, i need to read the history of the abstract machines in lambda calculus
17:17:18 <newsham> if you accumualte all rights until a left, thats no guarantee that there are no more rights
17:17:19 <Myoma> You can't implement it using that?
17:17:26 <dibblego> "and so accumulates Lefts"
17:17:38 * BMeph is wondering what it'd take to put the Reduceron code on an Altera chip instead of Xilinx
17:17:40 <Myoma> @let isLeft (Left _) = True ; isLeft _ = False
17:17:41 <lambdabot> Defined.
17:17:41 <dibblego> I can, but I thought there might be another function
17:17:50 <newsham> if its accumulating all lefts and all rights, you have two lists,   Either [a] [b] is just one list
17:17:59 <Myoma> > groupBy isLeft [Left 'x, Left 'y', Right 3, Right 4, Left 'z']
17:17:59 <lambdabot>  Improperly terminated character constant at "'x," (column 22)
17:17:59 <Cheiron>  Improperly terminated character constant at "'x," (column 22)
17:18:04 <Myoma> > groupBy isLeft [Left 'x', Left 'y', Right 3, Right 4, Left 'z']
17:18:05 <lambdabot>  mueval: Prelude.read: no parse
17:18:05 <Cheiron>   Not in scope: `isLeft'
17:18:09 <dibblego> newsham, no, if it has hit at least one Left, then it needn't care about Rights
17:18:34 <newsham> so it returns a list of rights unless there are one or more lefts?
17:18:36 <im_alone> the abstract machines are not designed for hardware only, they are designed to do easy the implementation between layers of software
17:18:39 <dibblego> newsham, correct
17:18:40 <Myoma> &let isLeft (Left _) = True ; isLeft _ = False
17:18:41 <Cheiron> Defined.
17:18:42 <Myoma> > groupBy isLeft [Left 'x', Left 'y', Right 3, Right 4, Left 'z']
17:18:42 <lambdabot>  mueval: Prelude.read: no parse
17:18:43 <Cheiron>  Couldn't match expected type `Either t t1 -> Bool'
17:18:55 <newsham> myoma:   [x | (Left x) <- xs]
17:18:56 <Myoma> :t groupBy
17:18:57 <Cheiron> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:19:07 <Myoma> oh :[
17:19:21 <Myoma> > groupBy ((==)`on`isLeft) [Left 'x', Left 'y', Right 3, Right 4, Left 'z']
17:19:22 <Pseudonym> @free groupBy
17:19:22 <lambdabot>  mueval: Prelude.read: no parse
17:19:22 <lambdabot> Plugin `free' failed with: imports.h: openFile: does not exist (No such file or directory)
17:19:23 <Cheiron>  [[Left 'x',Left 'y'],[Right 3,Right 4],[Left 'z']]
17:19:32 <Pseudonym> @ft groupBy
17:19:32 <lambdabot> Plugin `ft' failed with: imports.h: openFile: does not exist (No such file or directory)
17:19:44 <Myoma> > last . groupBy ((==)`on`isLeft) $ [Left 'x', Left 'y', Right 3, Right 4, Left 'z']
17:19:45 <lambdabot>  mueval: Prelude.read: no parse
17:19:46 <Cheiron>  [Left 'z']
17:19:49 <newsham> let (l,r) = ([x | (Left x) <- xs], [x | (Right x) <- xs]) in if null l then r else l
17:19:57 <im_alone> @google abstract state machines
17:19:59 <lambdabot> http://www.eecs.umich.edu/gasm/
17:20:45 <newsham> dibblego: that work for you?
17:21:21 <dibblego> newsham, yes it will, that's what I came up with as well (or a solution using foldr)
17:21:29 <dibblego> newsham, I intuit a better solution is all
17:21:40 <mmorrow> &version
17:21:40 <newsham> ?djinn [Either a b] -> Either [a] [b]
17:21:41 <Cheiron> lambdabot 4.1
17:21:41 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
17:21:41 <Cheiron> darcs get http://code.haskell.org/lambdabot
17:21:42 <lambdabot> Title: Index of /lambdabot
17:21:49 <mmorrow> @version
17:21:49 <lambdabot> lambdabot 4.2
17:21:49 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:22:22 <Myoma> &let list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
17:22:23 <Cheiron> Defined.
17:22:42 <Myoma> &type list [x | (Right x) <- xs] (:) [x | (Left x) <- xs]
17:22:43 <Cheiron> Not in scope: `xs'
17:22:43 <Cheiron> Not in scope: `xs'
17:22:50 <Myoma> &type \xs -> list [x | (Right x) <- xs] (:) [x | (Left x) <- xs]
17:22:52 <Cheiron> forall t1. [Either t1 t1] -> [t1]
17:22:57 <mmorrow> hmm
17:23:44 <sbahra> where's vixey
17:24:12 <mmorrow> sbahra: Myoma may know
17:24:24 <sbahra> mmorrow, why?
17:24:33 <newsham> myoma: I forgot to Left/Right the return values.
17:24:40 * Myoma is not vixey anymore
17:24:43 <sbahra> Ah.
17:24:45 <sbahra> Okay.
17:24:47 <sbahra> I thought so :-/
17:24:50 <sbahra> I just wasn't sure.
17:24:59 <newsham> if null l then Right r else Left l
17:25:07 <sbahra> Myoma, I left you a message
17:25:14 <sbahra> If you're still interested in models
17:25:15 * sbahra poofs
17:25:42 <mmorrow> poof as in a ninja-vanish smoke bomb?
17:26:08 * mmorrow decides that must have been it
17:26:42 <FunctorSalad> Myoma: anymore?
17:27:51 <adu> Myoma: why what?
17:28:51 <adu> o I have no idea why anyone would want to program in a language beginning with P...
17:29:22 <Ilmuri> because of triangles
17:29:32 <adu> triangles?
17:29:56 * BMeph wonders what "PLT Scheme" has to do with triangles...
17:30:00 <adu> the only language I would use in that category is Plankalkul
17:30:28 <GremlinHunter> Triangles in Prolog?
17:30:39 * adu <3 Prolog
17:30:45 * adu <3 Plankalkul
17:30:45 <mbeddoe> hi i'm trying to compile this program: ghc -o test test.hs
17:31:03 <mbeddoe> module Main where
17:31:03 <mbeddoe> import Data.ByteString
17:31:03 <mbeddoe> main = do return ()
17:31:04 <adu> mbeddoe: try "ghc --make test.hs"
17:31:07 <mbeddoe> ok
17:31:18 <mbeddoe> excellnt
17:31:19 <mbeddoe> thanks
17:31:20 <adu> mbeddoe: the -o is optional
17:31:21 <mbeddoe> that fixed it
17:31:21 * Myoma gets bored of working on this prolog compiler
17:31:25 <mbeddoe> appreciate it :D
17:31:30 <adu> mbeddoe: and --make handles dependancies
17:32:01 <adu> does anyone here know the significance of Plankalkul?
17:32:32 <FunctorSalad> wasn't it a pl designed before the first computer was built?
17:32:45 <FunctorSalad> (zuse?)
17:32:54 <adu> FunctorSalad: yes, thats part of it, its also the only language older than Fortran
17:33:18 <adu> some think Plankalkul was THE first pl
17:34:08 <Ilmuri> http://thedailywtf.com/Articles/We-Burned-the-Poop.aspx :|
17:34:16 <lambdabot> Title: We Burned the Poop - The Daily WTF
17:34:26 <lament> surely the analytical engine had the first PL, unless you somehow discount machine languages
17:34:26 <Ilmuri> thousands of cds with a poop popup
17:35:54 <adu> lament: ok you win, but imho, that wasn't a language, that was _code_
17:37:24 <adu> lament: but thats a distinction without a definand
17:38:05 <adu> oops "definiens"
17:38:38 <lament> while i have an intuitive understanding of the distinction, i don't feel it's a useful one
17:40:02 <adu> lament: certainly ambiguous when it comes to J
17:42:33 <adu> I just thought of a great name for php...tcl combined: [P-T]\w{2,5}
17:50:19 <Myoma> hmf
17:50:30 <Myoma> the worst kind of bug is the ones like bubbles under cling film
17:50:43 <Myoma> i.e. you 'fix' it and it ends up somewhere else
17:51:37 * Myoma can't get feature A and feature B to work at the same time
17:52:06 <Capso> Ah, PROLOG. OK.
17:54:35 <adu> ?pl \x n -> foldr1 (+) (replicate n x)
17:54:35 <lambdabot> (foldr1 (+) .) . flip replicate
17:55:23 <adu> one of these days I'm going to learn to think like ?pl
17:55:37 <Myoma> it wont be a good day
17:55:53 <adu> Myoma: I had one like that a wee ago
17:56:03 <adu> s/wek/week/
17:56:08 <Capso> Myoma: Is this the nick you will be sticking with now?
17:56:18 <adu> Myoma: what was your old nick?
17:56:22 * FunctorSalad kinda things currying makes pointless programming more difficult
17:56:43 <adu> FunctorSalad: ughm, its points-free
17:57:02 <FunctorSalad> products of mappings are way simpler than this weird partially applied application stuff IMHO
17:57:25 <FunctorSalad> s/application/composition/
17:57:38 <FunctorSalad> s/things/thinks/
17:57:50 <adu> like f . g . h
17:58:03 <Capso> Myoma: I know you'll be rude as before in not replying after initiating a conversation, but due to that, I'd just like to make sure that I've got the right information to /ignore.
17:58:17 <FunctorSalad> adu: I mean products as in (f,g) :: A -> (B,C)
17:58:54 <FunctorSalad> or (h *** i) :: (Z,A) -> (B,C)
17:59:13 <lispy> Capso: it's irc...you can't expect people to fit your model of ettique :)
17:59:18 <FunctorSalad> (I think the first one is actually written &&& in haskell)
17:59:19 <lispy> ettiquette
17:59:22 * lispy can't spell
17:59:28 <adu> FunctorSalad: do you mean a categorical product?
17:59:42 <lispy> adu: I think cartesian
17:59:52 <Capso> lispy: And I'm human -- I have perspective. I like this one, and I'll be sticking with it. :)
18:00:47 * adu is a contravariant Cartesian quandle
18:00:48 <FunctorSalad> adu: yes, to be specific f&&&g is the target tupling or "mediating arrow for the product"
18:00:56 <Myoma> the perl6 guys have got the right idea
18:01:00 <Myoma> (create loads to tests)
18:01:37 <FunctorSalad> or the arrow yielded by the universal property, or ......
18:01:50 * FunctorSalad shuts up
18:01:52 <adu> FunctorSalad: my understanding of category theory and Arrow theory is vague, so I'll have to agree with you on that :)
18:03:27 <adu> FunctorSalad: so which do you perfer? coinitial? or coterminal?
18:03:48 <Spark> anyone know of a paper about the physical limits that are driving the move to multicore?
18:04:05 <Cale> @type fix
18:04:11 <lambdabot> forall a. (a -> a) -> a
18:04:12 <FunctorSalad> adu: ?
18:05:26 <adu> FunctorSalad: there are at least 4 sets of terms for initial objects and terminal objects, I was wondering which terms you perferred?
18:05:39 <Cale> So, I think everything *ought* to be fixed up...
18:05:45 <Cale> @seen Cale
18:05:46 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:05:52 <lambdabot> You are in #japanese, #haskell-overflow, #haskell and #ghc. I last heard you speak just now.
18:05:55 <lispy> Cale++
18:05:57 <lispy> Cale: thanks
18:06:11 <adu> #Nihongo?
18:06:24 <adu> Cale++
18:06:24 <Cale> > ((+1) *** (*4)) (2,3)
18:06:25 <lambdabot>  mueval: Prelude.read: no parse
18:06:26 <Cheiron>  (3,12)
18:06:31 <Cale> hmm, no parse, eh?
18:06:36 <adu> @karma adu
18:06:36 <lambdabot> You have a karma of 0
18:06:43 <Cale> adu++
18:06:44 <Cale> hehe
18:06:47 <adu> :)
18:06:57 <adu> Cale++
18:07:11 <Cale> oh, there are updates for mueval
18:07:14 * Cale updates
18:07:30 <Cale> > ((+1) *** (*4)) (2,3)
18:07:31 <lambdabot>  mueval: Prelude.read: no parse
18:07:32 <Cheiron>  (3,12)
18:07:33 <Cale> hmm
18:08:27 <Cale> Huh, it works using mueval from the commandline...
18:08:38 <rwbarton> > 1+1
18:08:39 <lambdabot>  2
18:08:40 <Cheiron>  2
18:08:50 <rwbarton> > (+1) 1
18:08:51 <lambdabot>  2
18:08:52 <Cheiron>  2
18:09:02 <rwbarton> > (***)
18:09:03 <Cale> > (2,3)
18:09:03 <lambdabot>      Overlapping instances for Show
18:09:03 <lambdabot>                                 (a b c ->...
18:09:04 <lambdabot>  (2,3)
18:09:04 <Cheiron>  Add a type signature
18:09:05 <Cheiron>  (2,3)
18:09:18 <Cale> Oh, there's that problem too, I suppose.
18:09:39 <bjrn> > (,) 1
18:09:40 <lambdabot>      Overlapping instances for Show (b -> (t, b))
18:09:40 <lambdabot>       arising from a use of...
18:09:41 <Cheiron>  Add a type signature
18:09:46 <rwbarton> But it seems lambdabot knows about (***), so why doesn't what you wrote originally work?
18:09:47 <haskellian> can i do destructive updating within a monad?
18:10:01 <Cale> haskellian: In which monad?
18:10:10 <haskellian> and evrything including = do is a monad?
18:10:23 <Cale> do expressions produce monadic results.
18:10:37 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
18:10:39 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:10:39 <Cheiron>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:10:45 <Cale> For example, that's the list monad.
18:10:58 <Cale> > (do x <- id; y <- reverse; return (x,y)) "Hello"
18:11:00 <lambdabot>  ("Hello","olleH")
18:11:00 <Cheiron>  ("Hello","olleH")
18:11:05 <Cale> And there's the function monad :)
18:11:20 <Cale> (Well, (->) String)
18:11:23 <Myoma> :t runST
18:11:25 <Cheiron> forall a. (forall s. ST s a) -> a
18:13:19 <haskellian> how can I break a line?
18:13:40 <haskellian> how can I break a line?
18:13:41 <haskellian> like using \ in python
18:14:01 <Cale> haskellian: You just break it and indent the next line further
18:14:25 <Cale> The expression won't end until the indentation level goes back to at least what it originally was.
18:15:13 <Cale> Hey... what the heck... mueval is importing Test.SmallCheck.Serial for some reason, even though it's not in L.hs?
18:17:28 <rwbarton> > let x = ((+1) *** (*2)) in x
18:17:29 <lambdabot>      Overlapping instances for Show ((b, b') -> (b, b'))
18:17:29 <lambdabot>       arising from a...
18:17:30 <Cheiron>  <(Integer,Integer) -> (Integer,Integer)>
18:17:33 <rwbarton> > let x = ((+1) *** (*2)) in 6 -- this is bizarre
18:17:34 <lambdabot>  mueval: Prelude.read: no parse
18:17:35 <Cheiron>  6
18:19:30 <FunctorSalad> you could compile it with -XIncoherentInstances ;)
18:19:48 <FunctorSalad> (for that show)
18:21:41 <Cale> I don't understand why either of the modules where the conflicting instances are are getting loaded anyway.
18:21:50 <Cale> Neither of them are imported by L.hs
18:21:52 <Cale> ...
18:22:06 <Cale> Perhaps they're both in Mueval's personal list of imports.
18:22:26 <Cale> But I think that may even be baked in...
18:23:39 <rwbarton> > let x = (+1) *** (*2) in 6
18:23:40 <lambdabot>  mueval: Prelude.read: no parse
18:23:41 <Cheiron>  6
18:23:55 <Olathe> @bot
18:23:55 <lambdabot> :)
18:24:12 <haskellian> what does return do in a if-them-else clause it still continues in the loop afterwards? return is just "reporting" back a value then continuing?
18:24:32 <haskellian> and arent lets allowed ina if then else?
18:24:45 <GremlinHunter> return doesnt act like return in other languages
18:24:49 <Cale> haskellian: return is a function which takes a value and produces a computation that does nothing but return that value
18:24:50 <Myoma> think of if _ then _ else as a function
18:25:45 <TSC> How does one get the path to the home directory in Haskell?
18:25:46 <Cale> For example in the IO monad,  return 5  is the no-op action which returns 5 every time it is run.
18:25:49 <Ilmuri> how would one proceed to implement the "traditional" return then?
18:26:03 <Myoma> Ilmuri: it is implemented differently for every monad
18:26:05 <Cale> Ilmuri: You'd need to be in a continuation monad.
18:26:18 <Cale> Ilmuri: and you'd need to wrap your functions in callCC
18:26:33 <Cale> callCC (\return -> do ...)
18:26:55 <FunctorSalad> TSC: import HSH; abspath "~"
18:27:31 <FunctorSalad> TSC: err, wait, abspath doesn't recognize it. try glob "~"
18:27:38 <Cale> System.Environment.getEnv "HOME" ?
18:27:53 <TSC> Or System.Posix.User
18:27:54 <Cale> that works
18:27:59 <TSC> getEnv HOME is probably easiest
18:28:01 <FunctorSalad> mine's shortest ;)
18:28:04 <TSC> Thanks
18:28:11 <haskellian> can someone look at this: http://hpaste.org/9996 , ig et parse error on else, first i tired iwthout lets but then i odnt know how to return the updated Map
18:28:28 <Cale> haskellian: you have a let without an in
18:28:42 <haskellian> ah must use in inside functions?
18:28:43 <Cale> haskellian: Those are only allowed as a statement of a do-block
18:28:58 <Cale> (which the then branch of an if is not)
18:29:12 <haskellian> but in a main = do i dont need in...?
18:29:32 <Cale> But hang on...
18:29:48 <Cale> There's a lot of strangeness here :)
18:30:42 <haskellian> but i dont want in, i want to to store the computed value to return
18:31:13 <Cale> http://hpaste.org/9996#a1
18:31:15 <rwbarton> Cale: Could it be that mueval doesn't see these imported modules but there's an initial type-checking phase that does?
18:31:29 <Cale> haskellian: however, there's another problem
18:31:43 <Cale> haskellian: You have a forM loop filled with no-ops.
18:31:53 <Cale> er, that might be okay
18:32:08 <haskellian> no-ops?
18:32:17 <Cale> Well, return doesn't *do* anything
18:32:32 <Cale> However, you'll get a list of results which is the same as mapping a function over your list of values
18:33:00 <Cale> forM xs (\x -> return (f x)) = return (map f xs)
18:33:10 <Cale> same thing.
18:33:31 <Cale> What you probably want is for all those updates to happen to your map.
18:33:44 <rwbarton> > 3 (***) -- Cale: this knows about (***), but
18:33:45 <lambdabot>      No instance for (Num
18:33:45 <lambdabot>                        ((a b c -> a b' c' -> a (b, ...
18:33:46 <Cheiron>        add an instance declaration for
18:33:46 <Cheiron>       (Num ((a b c -> a b' c' -> a (b,...
18:33:50 <Cale> Not a list of variations of the map which have been adjusted in a variety of ways.
18:33:53 <rwbarton> > ((+1)***(*2)) (3, 4) -- doesn't
18:33:54 <lambdabot>  mueval: Prelude.read: no parse
18:33:55 <Cheiron>  (4,8)
18:34:11 <Cale> rwbarton: I'm going to try and let gwern figure it out first :)
18:34:17 <Capso> @seen Cale
18:34:17 <lambdabot> Cale is in #japanese, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 6s ago.
18:34:25 <rwbarton> @seen gwern
18:34:25 <Capso> ;)
18:34:25 <lambdabot> gwern is in #xmonad, #haskell and #darcs. I don't know when gwern last spoke.
18:34:38 <FunctorSalad> rwbarton: apparently the instance ambiguity error kicks in before the mueval error ;)
18:35:08 <FunctorSalad> or missing instance error, in this case
18:35:17 <Cale> haskellian: So, what you really want is a fold
18:35:22 <rwbarton> FunctorSalad: Right, I think something type-checks the expression before it gets handed off to mueval and that something has more modules imported
18:36:23 <pjdelport> Cale: that could be Haskell's catchphrase
18:37:07 <Cale> haskellian: also, you should be aware that xs !! n is an O(n) operation
18:37:13 <Cale> haskellian: and should basically never be used
18:37:31 <Cale> (If you have to do !!, chances are, a list is the wrong structure.)
18:38:03 <Olathe> Double factorials shouldn't use lists anyway.
18:38:03 <pjdelport> lists are for walking, arrays are for indexing
18:38:19 <newsham> these lists were made for walking
18:38:21 <FunctorSalad> would Map Int X be a good random access structure if you're scared of the arrays? ;)
18:38:24 <haskellian> well im moving it to a Map...dont hvae much choice at first
18:38:35 <im_alone> lists are for walking, arrays are for indexing and walking
18:39:03 <Capso> What's for running?
18:39:03 <Cale> haskellian: one sec, let me transform this a bit
18:39:12 <newsham> hands are for shaking, not tying.
18:39:22 <allbery_b> hm. IntMap?
18:39:59 <rwbarton> this list is fine though, you could  zip word_list (tail word_list)  (and then you wouldn't have any off-by-one errors)
18:42:13 <Cale> haskellian: wait a minute...
18:42:48 <Cale> haskellian: Are you just trying to build a list of the number of occurrences of each word?
18:42:54 <Cale> Or, a map, rather?
18:43:18 <Cale> Or are you trying to build a map of the number of occurrences of each pair of words, one after the other?
18:44:39 <Cale> There are multiple things wrong with this code, so it's hard to judge the true intent :)
18:44:56 <pjdelport> > let histogram = fromListWith (+) . (`zip` repeat 1) in histogram "abracadabra"
18:44:56 <lambdabot>  mueval: Prelude.read: no parse
18:44:57 <Cheiron>   Not in scope: `fromListWith'
18:45:10 <pjdelport> > let histogram = M.fromListWith (+) . (`zip` repeat 1) in histogram "abracadabra"
18:45:10 <Cale> haskellian: http://hpaste.org/9996#a2
18:45:11 <lambdabot>  mueval: Prelude.read: no parse
18:45:12 <Cheiron>  fromList [('a',5),('b',2),('c',1),('d',1),('r',2)]
18:45:31 <Cale> oh great, more things with no parse
18:45:35 <Cale> haskellian: you're back?
18:45:40 <Olathe> > let d = 1:1:zipWith (*) [2..] d in d
18:45:40 <stepcut> is there a, newtype IdentityT m a = IdentityT { runIdentityT :: m a }, in the the standard libs somewhere ? (or anywhere?)
18:45:41 <lambdabot>  [1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920...
18:45:42 <Cheiron>  [1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920...
18:45:58 <Cale> stepcut: I don't think so, for some odd reason.
18:46:10 <Cale> (at least in the standard mtl)
18:46:12 <stepcut> ok
18:46:14 <rwbarton> "mueval: Prelude.read: no parse" seems to just mean "Not in scope: <something>"
18:46:32 <Cale> rwbarton: ah, hmm
18:46:42 <Cale> > fhdusaif
18:46:43 <lambdabot>  mueval: Prelude.read: no parse
18:46:43 <Cheiron>   Not in scope: `fhdusaif'
18:46:46 <Cale> aha
18:46:59 <rwbarton> > 3 &
18:46:59 <lambdabot>  mueval: Prelude.read: no parse
18:47:00 <Cheiron>   parse error on input `}'
18:47:02 <haskellian> yes
18:47:05 <rwbarton> Well, it could also be that
18:47:17 <Cale> haskellian: Okay, so I'm trying to guess from this code what you're trying to do.
18:47:32 <Cale> haskellian: http://hpaste.org/9996#a2 is a rough guess
18:48:06 <Cale> haskellian: However, if what you're trying to do is build a map of the number of occurrences of, say, adjacent pairs of words, there are easier ways to do that
18:48:19 <Olathe> > let d n = 1:[1..(n - 1)] ++ zipWith (*) [n..] (d n) in d 1
18:48:20 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:48:20 <Cheiron>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:48:26 <Olathe> > let d n = 1:[1..(n - 1)] ++ zipWith (*) [n..] (d n) in d 2
18:48:27 <lambdabot>  [1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920...
18:48:28 <Cheiron>  [1,1,2,3,8,15,48,105,384,945,3840,10395,46080,135135,645120,2027025,10321920...
18:48:43 <haskellian> or a text, i poslit it into words. then i build a map of all words, for each word a map of the words that come after it in the text and how often
18:48:50 <haskellian> cale: i already did it in python: as an exercise to improve my haskell-skills i translate it, but is not as easy as  thought since state is tricky in haskell
18:48:51 <Cale> haskellian: Let me know when your internet connection is stable :)
18:49:03 <Cale> haskellian: Yeah, you don't need state for this :)
18:49:15 <haskellian> hehe, yeah dont know whats up with my connection
18:49:34 <Cale> haskellian: Do you want something like  Map String (Map String Integer)  ?
18:49:56 <Cale> haskellian: Where, for each word, you get a map of the number of occurrences of each word that occurs after it?
18:50:21 <Olathe> Is there a way to use pl to simplify a recursive function ?
18:50:56 <Cale> Olathe: well, you can rewrite the recursive function using fix
18:51:08 <Olathe> @src fix
18:51:08 <lambdabot> fix f = let x = f x in x
18:51:15 <Cale> Olathe: and then apply @pl to the function which you're taking the fixed point of.
18:51:15 <rwbarton> @pl let x = x x x in x
18:51:15 <lambdabot> fix (join (join id))
18:51:24 <Olathe> Ahh, thanks.
18:51:27 <chrisdone> > foo = blah // foo
18:51:27 <lambdabot>  Parse error at "=" (column 5)
18:51:27 <Cheiron>  Parse error at "=" (column 5)
18:51:28 <chrisdone> > blah = oneOf "abc"
18:51:28 <lambdabot>  Parse error at "=" (column 6)
18:51:28 <Cheiron>  Parse error at "=" (column 6)
18:51:38 <chrisdone> runPeg (newRule foo) "a" => infinite loop
18:51:40 <chrisdone> anyone know why?
18:51:43 <Cale> @pl let f x = x + 1 in f
18:51:44 <lambdabot> (1 +)
18:51:52 <Cale> @pl let f x = f (x + 1) in f
18:51:52 <lambdabot> fix (. (1 +))
18:51:56 <Olathe> @pl let d n = 1:[1..(n - 1)] ++ zipWith (*) [n..] (d n) in d
18:51:57 <lambdabot> fix (((1 :) .) . ap ((++) . enumFromTo 1 . subtract 1) . ap (zipWith (*) . enumFrom))
18:51:59 <Cale> Olathe: ^^ oh look
18:52:01 <rwbarton> @pl let fib n = if n <= 1 then n else (fib (n-1) + fib (n-2)) in fib
18:52:01 <lambdabot> fix (ap (if' =<< (<= 1)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
18:52:43 <Cale> haskellian: are you still with us?
18:53:16 <rwbarton> @pl let x = 1 : y ; y = 2 : x in x
18:53:16 <lambdabot> fst (fix (uncurry (flip ((,) . (1 :)) . (2 :))))
18:53:20 <Olathe> @pl let f x = 1:1:blah f
18:53:20 <lambdabot> (line 1, column 21):
18:53:20 <lambdabot> unexpected end of input
18:53:20 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
18:53:27 <Olathe> @pl let f x = 1:1:(blah f)
18:53:27 <lambdabot> (line 1, column 23):
18:53:27 <lambdabot> unexpected end of input
18:53:27 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
18:53:32 <Olathe> @pl let f x = 1:1:(blah f) in f
18:53:32 <haskellian> yes
18:53:33 <lambdabot> fix (const . (1 :) . (1 :) . blah)
18:54:01 <chrisdone> :hoogle mdo
18:54:02 <haskellian> cale: i get some file from anywhere, project gutenberg fro example
18:54:30 <haskellian> then i use the function words but i could ofc write a parser or my own split-function and map it onto a map instead of a list
18:54:49 <haskellian> haskellian: Do you want something like  Map String (Map String Integer)  ?: yes
18:54:57 <Cale> http://hpaste.org/9996#a3
18:54:58 <roconnor> whats the standard way of creating a global variable holding comand line arguments?
18:55:13 <Cale> haskellian: check out that last hpaste
18:56:34 <Cale> haskellian: I believe that does the right thing for you
18:56:44 <Cale> roconnor: Is there any need?
18:56:52 <Olathe> roconnor: The standard way is to create a function that gets and processes them, I'd expect.
18:56:56 <Cale> roconnor: getArgs will get the commandline arguments for you.
18:58:24 <Cale> *Main> markovMap (words "a b a b a c d a c a c d a c d b")
18:58:24 <Cale> fromList [("a",fromList [("b",2),("c",4)]),("b",fromList [("a",2)]),("c",fromList [("a",1),("d",3)]),("d",fromList [("a",2),("b",1)])]
18:58:29 <roconnor> the command line arguments are global and constant for the entire process.  Making it into a pure value seems reasonable to me.
18:58:42 <Cale> haskellian: ^^ does that look like what you want?
18:58:43 <sadache> i am a windows user, how to install cabal?
18:59:13 <sadache> i downloaded a tar, extracted it, then?
18:59:14 <roconnor> passing the value into ever function that may wish to use it seems unnecessarily annoying.
18:59:41 <newsham> roconnor: unsafely make it so
19:00:12 <Cale> sadache: Well, the Cabal library comes with GHC. I believe the additional dependencies of cabal-install are HTTP-3001 and zlib... you may also need the latest version of the Cabal library...
19:00:19 <newsham> all IO functions are free to call getArgs :)
19:00:22 <roconnor> newsham: right, but how to get all the inlining an new IORef and reads and writes all done propertly?
19:00:42 <rwbarton> roconnor:   args = unsafePerformIO getArgs  ?
19:00:42 <newsham> why does it have to be iorefs and such?
19:00:56 <Cale> sadache: each one of these, you install by running  runhaskell Setup.hs configure  and then  runhaskell Setup.hs build  and finally  runhaskell Setup.hs install
19:01:00 <haskellian> cale: what does it take as input? i cant feed it a list of words
19:01:00 <roconnor> rwbarton: oh, is it that simple?
19:01:09 <Cale> haskellian: a list of Strings
19:01:14 <roconnor> @type unsafePerformIO . getArgs
19:01:15 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:01:19 <sadache> ok, i have to download these libraries first
19:01:22 <sadache> thanks
19:01:29 <roconnor> @type unsafePerformIO getArgs
19:01:30 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:01:56 <haskellian> file <- readFile "C:/users/saftarn/desktop/textfiles/pg.txt"
19:01:56 <haskellian>   let pg_words = words file
19:01:58 <Cale> sadache: If runhaskell doesn't work for any reason, try runghc
19:02:08 <newsham> unsafePerformIO getArgs :: [String]
19:02:08 <roconnor> @hoogle unsafePerformIO
19:02:09 <lambdabot> A Hoogle error occurred.
19:02:12 <haskellian> is a list of strings but :Couldn't match expected type `[a]'
19:02:12 <haskellian>            against inferred type `Dmap.Map Char a1'
19:02:20 <Cale> haskellian: make sure those are indented to the same level
19:02:25 <roconnor> lambdabot: can you do anything anymore?
19:02:38 <haskellian> the function compiles
19:02:52 <roconnor> newsham: should it be marked noinline?
19:02:54 <rwbarton> Prelude System.IO.Unsafe System.Environment> unsafePerformIO getArgs
19:02:54 <rwbarton> []
19:03:00 <newsham> ?type System.IO.Unsafe.unsafePerformIO System.Environment.getArgs
19:03:01 <lambdabot> [String]
19:03:07 <Myoma> haha
19:03:07 <Cale> haskellian: try applying it to (words "a b c b a")  or something
19:03:08 <Myoma> unsafePerformIO getArgs
19:03:12 <Myoma> ?
19:03:16 <Myoma> why don't you use State monad?
19:04:02 <psygnisfive> sucks*
19:04:08 <psygnisfive> whoops wrong channel :D
19:04:21 <Olathe> > unsafePerformIO getArgs
19:04:21 <lambdabot>  mueval: Unsafe functions to use mentioned.
19:04:23 <Cheiron>   Not in scope: `getArgs'
19:04:23 <rwbarton> roconnor: I'd think that since getArgs is idempotent, inlining won't matter
19:04:39 <roconnor> rwbarton: right, but it is probably more efficient to not inline it?
19:04:42 <newsham> > System.IO.Unsafe.unsafePerformIO System.Environment.getArgs
19:04:43 <lambdabot>  mueval: Unsafe functions to use mentioned.
19:04:44 <roconnor> maybe it doesn't matter much
19:04:44 <Cheiron>   Not in scope: `System.Environment.getArgs'
19:04:49 <haskellian> main = do
19:04:49 <haskellian>   file <- readFile "C:/users/saftarn/desktop/textfiles/pg.txt"
19:04:49 <haskellian>   let pg_words = words file
19:04:49 <haskellian>   print (markovMap pg_words)
19:05:10 <Cale> haskellian: looks like it should work
19:05:16 <newsham> > System.IO.Unsafe.unsafePerformIO $ writeFile "/tmp/gotcha" "boom"
19:05:17 <lambdabot>  mueval: Unsafe functions to use mentioned.
19:05:18 <Cheiron>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
19:05:40 <MyCatVerbs> newsham: IST NICHT FUR GERSTABBENMITUNSAFEPERFORMIO!
19:05:56 <newsham> print =<< markovMap . words <$> readFile "pg.txt"
19:05:57 <Olathe> DERSTUBBLEONDENFACEN
19:06:03 <haskellian> c:/ghc-6.8.3/Progs/MarkovSentenceGen.hs:54:9:
19:06:03 <haskellian>     No instances for (Enum (Dmap.Map String a),
19:06:03 <haskellian>                       Num (Dmap.Map String a))
19:06:03 <haskellian>       arising from a use of `markovMap'
19:06:22 <Cale> haskellian: hmm...
19:06:34 <MyCatVerbs> newsham: more specifically, \bot's devs have already thought of most avenues of attack that a sane person would concievably come up with, and blocked them (sometimes in heavy handed fashion).
19:06:37 <Cale> haskellian: which version of markovMap did you take?
19:06:43 <Cale> markovMap ws = foldl add Dmap.empty (zip ws (tail ws))
19:06:43 <Cale>   where add prob (x,x') = Dmap.insertWith (Dmap.unionWith (+)) x (Dmap.singleton x' 1) prob
19:06:45 <Cale> that one?
19:06:58 <Olathe> > getArgs
19:06:59 <lambdabot>  mueval: Prelude.read: no parse
19:06:59 <Cheiron>   Not in scope: `getArgs'
19:07:08 <Olathe> > System.Environment.getArgs
19:07:09 <lambdabot>      Not in scope: `System.Environment.getArgs'
19:07:09 <Cheiron>   Not in scope: `System.Environment.getArgs'
19:07:18 <Olathe> > raise periscope
19:07:19 <lambdabot>  mueval: Prelude.read: no parse
19:07:20 <Cheiron>   Not in scope: `periscope'
19:07:33 <mmorrow> :t raise
19:07:34 <lambdabot> forall (a :: * -> * -> *) ex b. (ArrowError ex a) => a ex b
19:07:34 <Cheiron> forall (a :: * -> * -> *) ex b. (ArrowError ex a) => a ex b
19:07:40 <Cale> sigh
19:07:53 <Cale> Couldn't you do that in #haskell-overflow?
19:07:58 <Olathe> Sorry.
19:08:16 <haskellian> newsham: should tha tbe inside main = do?
19:08:34 <newsham> haskellian: its the equiv of your do block
19:08:50 <haskellian> i have both the 5liner and the 2liner
19:08:58 <mmorrow> this is a nice head-to-head bottest we have here
19:09:05 <Cale> haskellian: actually newsham's version needs Control.Applicative
19:09:08 <mmorrow> &version
19:09:08 <Cheiron> lambdabot 4.1
19:09:08 <Cheiron> darcs get http://code.haskell.org/lambdabot
19:09:09 <lambdabot> Title: Index of /lambdabot
19:09:10 <mmorrow> @version
19:09:10 <lambdabot> lambdabot 4.2
19:09:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:10:24 <Cale> haskellian: the 2-liner is the one you want
19:10:41 <haskellian> http://hpaste.org/9997
19:10:42 <Cale> haskellian: I didn't even test the 5-liner, there might be bugs in it :)
19:10:50 <haskellian> ok i do 2liner now
19:11:08 <Cale> haskellian: Also, <*>  requires Control.Applicative
19:11:09 <rwbarton> haskellian: the 5-liner was for a different problem, with a differently-typed result
19:11:15 <Cale> er, <$> rather
19:11:39 <Cale> and you still need the   main =
19:12:00 <sadache> http://www.mibbit.com/pb/aoESRk
19:12:01 <lambdabot> Title: Mibbit: PasteBin
19:12:12 <sadache> how can i solve this then :'(
19:12:28 <newsham> btw, haskellian, if you use codepad.org it will compile and run it (and show errors)
19:12:49 <rwbarton> sadache: try the latest version 3001.0.4
19:12:59 <Cale> sadache: You have an outdated version of the HTTP library there
19:13:09 <haskellian> now it works
19:13:17 <Cale> sadache: you should get everything from http://hackage.haskell.org/packages/archive/pkg-list.html
19:13:18 <lambdabot> Title: HackageDB: packages by category
19:13:19 <sadache> ok
19:13:20 <bjrn> haskellian: Are you learning Haskell for fun or do you have to use the language in a course?
19:13:23 <haskellian> sickness haha 2 lines of code did allt hat, ty sooo much
19:13:32 <haskellian> i am very grateful
19:13:37 <Cale> haskellian: no problem :)
19:13:55 <newsham> ie: http://codepad.org/vfZoI9yq
19:14:09 <haskellian> very beautiful, the cool thing about haskell is that whenever i think it is difficult someone shows mw a superclean way do to it
19:14:27 <newsham> its hard until its easy.
19:14:32 <Cale> haskellian: It's just really different :)
19:14:47 <newsham> actually sometimes its easy to make complicated code and hard to make it nice and simle and pretty
19:14:48 <haskellian> --print =<< markovMap . words <$> readFile "C:/users/saftarn/desktop/textfiles/pg.txt" , never worked, complained about intendation
19:15:04 <Cale> haskellian: you forgot the main =
19:15:09 <haskellian> bjrn: for fun/later use
19:15:27 <Cale> haskellian: also, did you import Control.Applicative ?
19:15:40 <haskellian> [1 of 1] Compiling MarkovSentenceGen ( c:/ghc-6.8.3/Progs/markov.hs, interpreted )
19:15:40 <haskellian> c:/ghc-6.8.3/Progs/markov.hs:9:2:
19:15:40 <haskellian>     precedence parsing error
19:15:40 <haskellian>         cannot mix `(.)' [infixr 9] and `(<$>)' [infixl 9] in the same infix expression
19:15:41 <haskellian> c:/ghc-6.8.3/Progs/markov.hs:9:30: Not in scope: `<$>'
19:15:41 <haskellian> Failed, modules loaded: none.
19:15:43 <haskellian> Prelude>
19:15:52 <newsham> haskellian: see http://codepad.org/vfZoI9yq
19:15:53 <haskellian> cale: for newshams part? no
19:15:54 <Cale> haskellian: import Control.Applicative
19:16:00 <Cale> You need it for <$>
19:16:18 <haskellian> ah there we go
19:16:22 <newsham> alternately you can use `fmap` or `liftM` instead of <$>
19:17:50 <Cale> http://codepad.org/7pfPJ63r
19:18:10 <Cale> (there's a nice example run, I removed the reference to the file)
19:22:05 <haskellian> a
19:24:14 <sadache> how to how to update cabal version for ghc?
19:28:37 <jeffz> sadache: download it from hackage
19:29:02 <sbahra> how to how to how to how to how to ... how to = how to
19:29:04 <sbahra> ?
19:29:52 <sadache> sbahra: what do u mean
19:29:56 <MyCatVerbs> sbahra: no, silly. You map "how to how to" to "how to" and iterate that function to a fixed point. :)
19:30:26 <sadache> jeffz: i did download it, but how to install it
19:30:39 <jeffz> sadache: extract it and run the Setup
19:31:03 <sbahra> sadache, runhaskell Setup.hs configure --user --prefix=<PREFIX> && runhaskell Setup.hs build && runhaskell Setup.hs install
19:31:16 <sbahra> or Setup.lhs
19:32:16 <sadache> sbahra: it feels so cool and fun to make fun of a newbie right?
19:32:38 <sbahra> I wasn't making fun of you.
19:33:45 <sadache> it is quite a chalange with less socumentation to get a simple web application to run
19:35:11 <bjrn> What's the recommended maximum line length for haskell code? 78 characters is a bit tight.
19:35:14 <Olathe> It's amazing to me how often nicknames tell a lot about a person.
19:36:39 <sadache> and it is amazing how people tend to draw fast careless conclusions about others
19:38:03 <sereven> hmm.. I'm not surprised sadache is having trouble. Several google and haskell.org searches don't have much of anything relavent. I haven't used windows in so long that I'm just guessing.. but
19:38:59 <sereven> sbahra was telling you what should work if you go to the directory where you extracted cabal in a dos shell and type those commands (well not &&)
19:39:01 <jeffz> sereven: installing cabal on windows is no different to linux
19:39:32 <sereven> unless you're new to the whole thing
19:40:06 <jeffz> sereven: so then the fact that the person is using windows is a nonissue
19:40:09 <sadache> I am new to the whole thing, I program with .net, and i have 5 years of experience
19:40:34 <sadache> all what i am trying to do is to do a real project with haskell in my spare time
19:40:52 <sadache> and then ppl thing it is easy to configure something like this
19:40:58 <mmorrow> heh, http://codepad.org/xZQEorn7
19:40:58 <jeffz> sadache: feel free to ask questions if you need help.
19:41:26 <sereven> so welcome, and the runhaskell commands should work if translated into whichever shell equivalent you're using
19:41:28 <sadache> guys it is 4h40 am in here and i have work in the morning, there is a big lack of documentation and nothing is obvious as you think
19:42:13 <jeffz> sadache: maybe you should sleep instead.
19:43:28 <sadache> http://www.mibbit.com/pb/MWFTwE
19:43:28 <lambdabot> Title: Mibbit: PasteBin
19:43:42 <mmorrow> sadache: it's not easy and it isn't obvious. :)
19:44:16 <haskellian> why isnt this possible ? print (Dmap.lookup "startup" mmap) , complains about no instance for show
19:44:43 <mmorrow> sadache: cd ..
19:46:13 <haskellian> Ambiguous type variable `m' in the constraint:
19:46:16 <haskellian>       `Monad m'
19:48:41 <mmorrow> haskellian: take the entire e and do (for instance) (id::[a]->[a])(e))
19:48:59 <mmorrow> or (id::Maybe a->Maybe a)(e))
19:49:12 <mmorrow> ie tell it what the monad m is
19:49:33 <sadache> mmorrow: actually the cd.. was empty, i ve just found out that the tar wasnt unzipped properly, but i am really wondering why there is no one command that installs all these things. I tried searchpath but it doesnt like windows' filenames with spaces
19:50:20 <jeffz> sadache: once you install the latest version of Cabal properly you can then install cabal-install so that configuring, building and installing other packages is generally easier
19:50:39 <mmorrow> sadache: gah. i try to always have cygwin, save that i'd prefer not to imagine it. hmm. what did you untar/gunzip with?
19:51:33 <sadache> winrar, but it was purely my fault, well at least if we dont want to blame ergonomy :)
19:51:43 <mmorrow> heh
19:52:21 <mmorrow> sadache: once you get everything bootstrapped and you have cabal-install + a base setup, life will become /much/ easier :)
19:52:34 <sadache> done
19:52:44 <sadache> they are installed now
19:52:46 <mmorrow> nice. you mean you've got cabal-install
19:52:47 <mmorrow> ?
19:52:50 <mmorrow> sweet!
19:52:52 <sadache> yes
19:53:15 <im_alone> @google hidden markov model
19:53:17 <lambdabot> http://en.wikipedia.org/wiki/Hidden_Markov_model
19:53:18 <lambdabot> Title: Hidden Markov model - Wikipedia, the free encyclopedia
19:53:39 <sereven> sadache: there is a bootstrap.sh in this latest version of cabal-install-0.5.2, which downloads everything but ghc and saves trouble. but I didn't find a windows version of it. Although it should work in cygwin if cygwin emulates bash. http://www.haskell.org/cabal/download.html wasn't going to bring it up to avoid confusion.
19:53:40 <lambdabot> Title: The Haskell Cabal
19:54:03 <jeffz> cool, I just used cabal-install to build and install frag on Wine
19:54:22 <jeffz> mind you... had to fix a bug in Wine first :P
19:54:22 <sadache> sereven: good to know about it
19:55:12 <mmorrow> sadache, sereven: if one of you knows batch files and translated it, i bet that would help countless people in the future
19:55:18 <sadache> go to go now, sorry for bothering a lot. Trust me it is not easy to ask for help
19:55:27 <jeffz> mmorrow: I heart batch :>
19:55:36 <mmorrow> sadache: good luck!
19:55:48 <mmorrow> jeffz: heh.
19:55:50 <sadache> thank you, at least i got my cabal-install installed
19:56:09 <rwbarton> i install, you install, we all install cabal-install
19:56:18 <sbahra> haha
19:56:59 <mmorrow> jeffz: hmm, perhaps Language.Batch.{Syntax,Parser,Pretty} is in order? ;)
19:57:12 <jeffz> mmorrow: *runs screaming*
19:57:18 <mmorrow> lol
19:57:48 <haskellian> mmorrow: it is inside a "main=do"
19:57:52 * mmorrow (parenthetically remarks that he was serious)
19:58:14 <haskellian> it works in the prelude, why is it whining whem im doing it in a odule+
19:58:31 <mmorrow> haskellian: what is the line that's giving you the error?
20:03:16 <mmorrow> basically, there's some ambiguity wrt what monad something's in, so you've gotta help the type system somehow ... most likely with a type annotation somewhere, or by rearranging thing sso that the surrounding types make the currently ambiguous one clear
20:03:50 <joed> sso clear as crystal
20:05:18 <mmorrow> this is true
20:06:31 <haskellian> let vbnm = Dmap.lookup "startup" f
20:08:03 <haskellian> print (Dmap.size whash) iz fine
20:08:13 <haskellian> let vbnm = Dmap.lookup "startup" whash is not
20:22:24 <ddarius> mmorrow: Is batch file syntax actually specified anywhere?
20:23:12 <lispy> ?pl \a b -> a >>= (const b)
20:23:12 <lambdabot> (. const) . (>>=)
20:23:22 <lispy> I think I like the pointful one better
20:24:04 <Myoma> :t (>>= const ?x)
20:24:05 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?x::m b) => m a -> m b
20:24:06 <Cheiron> forall (m :: * -> *) a b. (Monad m, ?x::m b) => m a -> m b
20:24:16 <jeffz> I think it's only specified by the behavior of the implementation
20:24:18 <ddarius> lispy: Seeing if @pl has a rule to turn >>= \_ to >> ?
20:24:19 <Myoma> :t (>> ?x)
20:24:20 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?x::m b) => m a -> m b
20:24:20 <Cheiron> forall (m :: * -> *) a b. (Monad m, ?x::m b) => m a -> m b
20:24:54 <lispy> ddarius: hmm...no I was defining (>>) in terms of (>>=) and seeing if there was a nce pointfree form
20:25:08 <lispy> ddarius: I'm not atually using the Monad class so I can't rely on the default
20:25:26 <Myoma> do people want Language.Foo.Whatever ?
20:25:34 <Cale> haskellian: oh, it's a (kind of) stupidity about the lookup function... it's generalised to an arbitrary monad rather than just giving you a Maybe value (even though this is a totally inappropriate generalisation, as failure isn't really available in any monad)
20:25:41 <Myoma> I have some interpreters and compilers
20:25:57 <ddarius> Cale: The problem is Monad not so much the generalization.
20:26:12 <ddarius> Or put another way, it should generalize to MonadPlus (or better MonadZero)
20:26:14 <Cale> ddarius: Well, it should be MonadZero at least.
20:26:16 <Cale> yeah
20:26:26 <Cale> Though I don't think there's a problem with using Maybe
20:26:50 <Cale> Since Maybe is in some sense an initial object among MonadZero's :)
20:27:34 <ddarius> Yes, there is a monad homomorphism from Maybe to any MonadZero, but it can be annoying to have to keep writing it out.
20:27:46 <Cale> haskellian: So, the solution is just to add a type signature
20:28:10 <Cale> haskellian: vbnm :: Maybe (whatever)
20:28:25 <Cale> haskellian: (where whatever is the appropriate type)
20:29:34 <Cale> ddarius: It should at least be given a nice convenient name... I'm not sure that one even exists in the libraries.
20:30:12 <Cale> :t maybe mzero return
20:30:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
20:30:14 <Cheiron> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
20:30:36 <jeffz> Myoma: which languages do you have compilers and interpreters for?
20:31:04 <Myoma> :t \m -> mzero `mplus` do e <- m ; return e
20:31:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a
20:31:05 <Cheiron> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a
20:31:18 <waynemokane> is there anything special about a data constructor, as opposed to simply a function that returns a value of that type?
20:31:24 <Myoma> how do you make m a -> m' a ?
20:31:37 <SamB_XP_> waynemokane: well, you can pattern match with it ...
20:31:54 <Myoma> jeffz: Janus and Rascal and probably some others around
20:31:57 <ddarius> Myoma: You don't in general.
20:32:01 <pgavin> waynemokane: they are implemented by the compiler completely differently
20:32:10 <Myoma> ok
20:32:21 <waynemokane> hmm, ok, I knew there was something but I had a  hard time figuring out the difference
20:32:26 <waynemokane> they have the same type
20:32:28 <Cale> waynemokane: For example, since Just and Nothing are data constructors, we can write definitions like   f Nothing = 0; f (Just n) = n
20:32:56 <ddarius> f Nothing = mzero; f (Just n) = return n
20:33:11 <waynemokane> ooh, you can only pattern match using data constructors?
20:33:15 <Cale> waynemokane: right
20:33:19 <waynemokane> yes that is an important difference, indeed
20:33:23 <jeffz> i should finish my postscript interpreter
20:33:23 <Cale> f (cos x) = ...
20:33:30 <Cale> would be tricky :)
20:33:45 <SamB_XP_> Cale: massive understatement
20:33:49 <ddarius> @google "Pattern Calculus"
20:33:52 <lambdabot> http://portal.acm.org/citation.cfm?id=1034775
20:33:53 <lambdabot> Title: The pattern calculus
20:34:02 <waynemokane> right.. cause basically I was working with Parsec to parse some existing JSON stuff
20:34:03 <ddarius> There's a free version available elsewhere
20:34:03 <pgavin> f = cos^-1 x
20:34:21 <Myoma> you turn haskell into a relational language as soon as you do that
20:34:22 <waynemokane> and I was using the float function, which parses a Double
20:34:32 <waynemokane> then I wanted to sue floatOrNatural... I think it was called
20:34:41 <waynemokane> which is Either Int Double
20:34:51 <ddarius> Myoma: Implement an interpreter for the pattern calculus.
20:35:10 <Myoma> ddarius, I'll have a look at it
20:35:26 <waynemokane> so... my data type had a constructor for a Double but not int... obviously we can use fromIntegral, but it was tricky figuring out how to retrofit the function inside the parsin monad
20:35:41 * lispy wonders what the next cool haskell app will be
20:35:51 <Myoma> minesweeper
20:36:20 <lispy> we have xmonad, darcs, cabal/hackage...what else?
20:36:23 <waynemokane> because I was working wtih an example that did something like <|> JNumber double <|> JString stringLiteral...  I thought you had to use data constructors there
20:36:28 <lispy> We need a really cool web browser :)
20:36:33 <Cale> lispy: Especially given that some mysterious person on the Haskell mailing list is looking for Lockheed, Indra, Thales, and Raytheon employees...
20:36:42 <lispy> Cale: rofl
20:37:06 <pgavin> those are all defense contractors, right?
20:37:12 <rwbarton> unsafeLaunchMissiles?
20:37:13 <Cale> This is a strange question, I know, but is there anyone working in any of the above companies on this mailing list?
20:37:14 <Cale> Everyone will no doubt be wondering what they have in common.  I'm afraid I can't discuss that.
20:37:15 <lispy> I'm not trying to promote NIH, but instead, some new cool take on something that makes a killer app
20:37:16 <Cale> Paul.
20:37:27 <pgavin> I know raytheon is always trying to recrute people from my school
20:38:14 <Cale> rwbarton: Hehe, competing implementations of unsafeLaunchMissiles :)
20:38:43 <ddarius> lispy: If you want to know what the next killer app will be, make it.  <insert obligatory Alan Kay quote>
20:38:44 <waynemokane> my god... are you suggesting the US government has discovered higher order functions??? I thought they were decades away
20:39:11 <lispy> ddarius: I have one in mind that will be killer for haskell users
20:39:14 <ddarius> waynemokane: C# has HOFs and the government uses C# among other things
20:39:23 <lispy> ddarius: But, we need something with wider scope!
20:39:30 <waynemokane> C# has HOFs now?  hmm interesting.. haven't looked at it since 1.x
20:39:45 <ddarius> waynemokane: They were added in 2.0 and improved in 3.0
20:39:46 <lispy> waynemokane: some actual language theorists work on it these days.
20:40:03 <waynemokane> interesting.... we are using F# at my company
20:40:10 <im_alone> there are 2 things: the goverment and the terrorists
20:40:11 <waynemokane> which is of course Microsoft's ode to OCaml
20:40:22 <im_alone> they are controversial
20:40:25 <SamB_XP_> lispy: why are you promoting Not Invented Here or the National Institute of Health ?
20:40:35 <lispy> SamB_XP_: I'm NOT promoting it
20:40:51 <lispy> SamB_XP_: not invented here is what I want to avoid
20:40:56 <SamB_XP_> OH
20:41:00 <SamB_XP_> sorry, misread
20:41:02 <lispy> But, if there is something we can legitamely do better, we should go for it
20:41:09 <SamB_XP_> and couldn't figure out what you meant by NIH
20:41:15 <im_alone> the government wanna terrorists, but the terrorists wanna government
20:41:29 <lispy> SamB_XP_: heh, maybe I meant, Not In Haskell
20:41:51 <Cale> Heh, I misread "Dangling symbolic links" on the Haskell-cafe list as "Dancing symbolic links", and had thought that maybe someone had been perverse enough to implement Knuth's DLX in the filesystem. :)
20:42:02 <stepcut> heh
20:42:09 <lispy> Cale: hehe
20:42:13 <SamB_XP_> DLX?
20:42:19 <ddarius> Cale: Someone might've
20:42:25 <lispy> Hey, Do we have a weak hash table implementation in Haskell?
20:42:28 <Cale> http://en.wikipedia.org/wiki/Dancing_Links
20:42:29 <lambdabot> Title: Dancing Links - Wikipedia, the free encyclopedia
20:42:33 <lispy> or any sort of weak references?
20:42:35 <im_alone> New Is Haskell
20:42:44 <ddarius> lispy: There are definitely weak references.
20:42:48 <Cale> lispy: System.Mem.Weak
20:42:50 <lispy> im_alone: Now is Haskell!
20:43:04 <SamB_XP_> Now In Haskell
20:43:26 <Cale> Hashtables are overrated ;) Balanced trees forever!
20:43:26 <im_alone> Not Is Haskell!
20:43:48 <lispy> Cale: interesting (the S.M.W thing)
20:43:54 <stepcut> Balanced trees are overrated ;) unordered lists forever!
20:43:56 <im_alone> Nobody In Haskell!
20:44:18 * SamB_XP_ feels tempted to make a Mario joke
20:44:20 <lament> skiplists forever!
20:44:20 <waynemokane> No Imitations. Haskell
20:44:41 <lispy> Cale: I was thinking, maybe darcs could use weak pointers to the data it loads
20:46:24 <Cale> lispy: The main use of weak references that I can think of is for the construction of memo tables... is that the sort of thing you're doing?
20:46:56 <ddarius> Any kind of cache would be an appropriate application
20:46:57 <lispy> Cale: I was just thinking of ways to reduce memory pressure
20:47:24 <lispy> Cale: maybe I misunderestimate the power of weak
20:47:54 <Cale> lispy: Weak references aren't followed by the garbage collector, so the things they point to can be GC'd.
20:48:22 <lispy> Cale: But, they can also be recreated when referenced again, right?
20:49:20 <Cale> lispy: If you hang on to the way in which they were created in the first place, sure ;)
20:49:59 <Cale> :t System.Mem.Weak.deRefWeak
20:49:59 <lambdabot> forall v. GHC.Weak.Weak v -> IO (Maybe v)
20:50:00 <Cheiron> forall v. GHC.Weak.Weak v -> IO (Maybe v)
20:50:41 <ddarius> lispy: By only holding a weak reference you are saying that it'd be nice to have whatever it references but you don't -need- it.
20:50:44 <Cale> If the key associated with the weak pointer is still alive, then Just v is returned, otherwise Nothing is returned.
20:51:37 <lispy> ddarius, Cale: Yeah, so for strings read from files that aren't changing, I was thinking you hold a weak ref to the string
20:52:02 <lispy> if it's been cleaned up, you fetch it again
20:52:19 <Cale> lispy: Are the strings larger than the description of how to get the string?
20:52:36 <lispy> Cale: oh definitely
20:52:46 <Cale> Then yeah, that's a worthwhile approach.
20:52:47 <ddarius> lispy: Yes, that is fine.  That is a cache.  Though you'll need to have the cache be maintained by something.
20:52:47 <haskellian> wtf i dont get lookup, i tried makign it a function: look :: Maybe (Dmap.Map)
20:52:47 <haskellian> look word hash = Dmap.lookup word hash
20:52:59 <haskellian> it gives no clues on the type
20:53:04 <Cale> haskellian: That's the wrong type signature.
20:53:07 <ddarius> lispy: You can't "reinstate" the value of a weak reference once it is lost.
20:53:20 <lispy> ddarius: ah
20:54:00 <Cale> haskellian: look :: (Ord k) => k -> (Dmap.Map k a) -> Maybe a
20:54:26 <Cale> haskellian: Also, it's just a little bit wrong to call a Data.Map a 'hash', since it's not implemented with hashing, but a balanced tree.
20:54:34 <ddarius> So instead of the strings, you'd pass around tokens for the strings and then look them up in some structure when you needed it.  That structure would handle caching.
20:56:59 <ddarius> Alternatively, you could pass around IORefs to weak pointers.
20:57:42 <ddarius> (well, weak pointers plus the information needed to recreate the value)
20:57:46 <lispy> ddarius: yeah, that token -> string mapping is what I think of when I say "weak hashtable"
21:02:11 <waynemokane> it seems type classes are similar to the idea of interfaces in Java/C#  .... agree/disagree?
21:02:52 <sjanssen> waynemokane: there are some similarities
21:03:01 <Cale> waynemokane: Similar, but different as well. :)
21:03:10 <waynemokane> ah of course... go figure
21:03:27 <rwbarton> more similar to interfaces than classes, certainly
21:03:32 <Cale> waynemokane: In Java, all the functionality is carried around with the objects themselves.
21:04:02 <Cale> waynemokane: In Haskell, the functionality travels separately, which gives you some flexibility, for example, functions can be polymorphic in their *return* type.
21:04:15 <Cale> > read "1" :: Integer
21:04:16 <lambdabot>  1
21:04:17 <Cheiron>  1
21:04:36 <Cale> > read "([1,2,3], 5)" :: ([Integer], Double)
21:04:37 <lambdabot>  ([1,2,3],5.0)
21:04:38 <Cheiron>  ([1,2,3],5.0)
21:04:38 <waynemokane> yes, true... but in the sense that they both outline abstract functions that need to be filled in by any interested types
21:04:42 <Cale> yeah
21:05:06 <lispy> interface is the closest concept you'll find in java
21:05:10 <Cale> Another thing is that classes, at least in most implementations of Haskell, can have multiple type parameters.
21:05:30 <waynemokane> hmm... yes that is interesting
21:05:37 <lispy> Cale: but that's true with java interfaces I think
21:05:43 <Cale> Which means you can have classes that represent the interrelationships between types, not just properties that a given type might or might not have.
21:05:50 <haskellian> thanks again cale, but do I have to create a function njust for that?
21:06:04 <Cale> haskellian: No, you can just specify the type of the result.
21:06:19 <Cale> haskellian: lookup foo bar :: Maybe Integer
21:06:21 <waynemokane> aah, ok that makes sense
21:06:22 <Cale> haskellian: for example
21:06:54 <Cale> Another thing is that Haskell has type constructors, and classes can apply to those as well, but that's a rather subtle point.
21:06:56 <haskellian> where? outside the main?
21:07:00 <waynemokane> I think you could do something similar with Java interfaces, especially now with generics, but it would be fairly clunky
21:07:06 <Cale> haskellian: on the expression where you do the lookup
21:07:25 <Cale> haskellian: just how I wrote it there (substituting foo and bar with the appropriate things)
21:07:34 <haskellian> print $ look "startup"  wmap
21:07:50 <Cale> haskellian: The problem is that the only thing you do with the result of the lookup is to print it, so Haskell/GHC can't guess what type you want it to be.
21:07:57 <haskellian> print $ Dmap.lookup startup"  wmap , howd I coomment on that?
21:08:08 <waynemokane> Cale: what do you mean that a class can apply to a type constructor?  as opposed to the type itself?  maybe I'm getting confused with Data constructors
21:08:40 <dons> "I’d thought Haskell’s cryptic errors were bad, but OCaml are useless other than the line number
21:08:40 <Cale> haskellian: What's the type of wmap?
21:08:43 <dons> "
21:09:03 <Cale> waynemokane: Well, for example...
21:09:08 <lispy> dons: context?
21:09:12 <dons> interesting comparisons with ocaml, http://systematicgaming.wordpress.com/2008/08/29/functional-gaming-writing-a-game-in-ocaml/
21:09:14 <lambdabot> Title: Functional Gaming: Writing a game in OCaml « Systematic Gaming, http://tinyurl.com/5qxva6
21:09:15 <Cale> There's a class Functor defined like this:
21:09:19 <Cale> class Functor f where
21:09:20 <haskellian> Dmap of DMaps, String String Integer (its from before)
21:09:26 <Cale>   fmap :: (a -> b) -> f a -> f b
21:09:27 <dons> "being allowed to drop printf’s throughout your code really helps
21:09:27 <dons> "
21:09:35 <dons> we should make it clear that debugging is fine.
21:09:40 <dons> Debug.Trace.printf ?
21:09:49 <dons> would ease some pain
21:10:03 <Cale> haskellian: okay... then it'd be:  print (Dmap.lookup "startup" wmap :: Maybe (Dmap.Map String Integer))
21:10:08 * dons uploads debug-printf to hackage.
21:10:28 <dons> what's the best practice api for printf debugging? :)
21:10:35 * dons looks for white papers on printf debugging.
21:10:47 <ddarius> Text.Printf's interface is mildly broken.
21:10:57 <dons> which part ?
21:11:21 <Cale> When using Debug.Trace, I've always found the availability of show to be more than enough...
21:11:24 <jeffz> printf considered harmful?  making it available means people aren't forced to think about their problem in depth :p
21:11:33 <lispy> "Why Objective Caml? No real reason, I’ve heard it one of the faster functional programming languages, rivaling C/C++ for speed."  <-- where do people here this, but not hear the same thing about Haskell?
21:11:53 <dons> lispy, the shootout helps there.
21:11:57 <Cale> lispy: 3 or 4 years in the past.
21:12:00 * dons mentions the quad core shootout...
21:12:11 <dons> we could *own* that for a while to come with a few crafty submissions.
21:12:14 <Cale> O'Caml has had good code generation for a long time.
21:12:24 <sjanssen> dons: is Haskell actually up on that yet?
21:12:26 <ddarius> dons: There is no way to write a wrapper function around printf that has the same kind of variadic behaviour except by completely copying the functionality.
21:12:31 <dons> sjanssen: yeah, in 2nd spot.
21:12:37 <adk> hi. I'm a haskell newbie and was wondering if someone was willing to explain to me why the following code is not working < http://hpaste.org/9998 >. the current error tells me that there might be an incorrect indentation
21:12:43 <dons> ddarius: true that.
21:13:02 <Cale> adk: the lines starting with | are not indented enough
21:13:07 <ddarius> Someone needs to make a good paste for hpaste 10k
21:13:15 <dons> sjanssen: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
21:13:17 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® Computer Language Benchma ..., http://tinyurl.com/55nbs6
21:13:20 <Cale> adk: They should be indented farther than the e in encrypt
21:13:35 <dons> sjanssen: the languages between C and Haskell don't run on 64 bit quad cores :)
21:13:49 <dons> yay for disruptive hardware killing off old languages (i'm looking at you Clean)
21:14:27 <ddarius> dons: Doesn't GHC (currently) do relatively poorly on 64-bit?
21:14:27 <adk> Cale:thanks that works. Is the rule of thumb to get the guards after the first letter of the where variable?
21:14:31 <Cale> dons: Clean is apparently turning into a Haskell compiler?
21:14:39 <dons> ddarius: no, it's hot.
21:14:46 <dons> 32 bit is kinda deprecated as a backend.
21:14:49 <Cale> adk: well, indented more than the function itself
21:15:02 <dons> ddarius: all the uvector stuff seems to do much better on 64 bit
21:15:09 <waynemokane> does anyone know if you can use Cabal packages in a "local" mode?
21:15:17 <dons> waynemokane: sure, use --user
21:15:25 <waynemokane> like let's say I want to use dons' JSON package but I don't have root access
21:15:39 <dons> waynemokane: cabal install json
21:15:49 <dons> :) (installs as user)
21:15:59 <Cale> adk: but yeah... to be inside the where, things have to be indented as much as the first non-whitespace character after the 'where', and to be inside the definition of encrypt, they should be indented more than it.
21:16:03 <waynemokane> dons: hmm don't know how I missed the --user option... d'oh
21:16:05 <waynemokane> thanks
21:16:36 <adk> Cale:ok. Also, is there a better way to write this code? and, also, why cann't I compose ord and toUpper? according to the definition toUpper Char -> Char and ord Char -> Int
21:16:48 <Cale> adk: The general rule is if you want something to be inside something else, it should start on a further column, and if things should be on the same level, then they should line up. :)
21:17:10 <Cale> Maybe you just parenthesised incorrectly...
21:17:19 <Cale> :t (ord . toUpper)
21:17:20 <lambdabot> Char -> Int
21:17:21 <Cheiron> Char -> Int
21:17:32 <Cale> Cheiron: @part #haskell
21:17:34 <Cale> hmm
21:17:54 <Cale> I guess I could use my op :)
21:17:58 --- mode: ChanServ set +o Cale
21:18:02 --- kick: Cheiron was kicked by Cale (Cale)
21:18:05 --- mode: Cale set -o Cale
21:19:21 <lispy> dons: You want to get a beer after work tomorrow?
21:19:29 <waynemokane> OT but I'm kind of an IRC noob... can someone explain what just happened w/Cheiron
21:19:34 <ddarius> lispy: Why wait until after work?
21:19:39 <lispy> heh
21:19:47 <Cale> waynemokane: I kicked it
21:19:48 <lispy> unsafePerformAlcohol
21:20:04 <Cale> waynemokane: (It's a duplicate lambdabot, and lambdabot is (at least sort of) working now.
21:20:09 <Cale> )
21:20:20 <waynemokane> aah, so you somehow acquired operator status, kicked it, and relinquished
21:20:32 <waynemokane> sudo kickemout
21:20:33 <lispy> waynemokane: correct
21:20:37 <mmorrow> <ddarius> mmorrow: Is batch file syntax actually specified anywhere?
21:20:42 <mmorrow> i'm not sure
21:21:06 <lispy> mmorrow: command.com probably specifies it :)
21:21:15 * mmorrow looks
21:21:20 * ddarius will just reverse engineer command.com 
21:21:23 <lispy> mmorrow: er, I mean the binary
21:21:25 <Cale> waynemokane: yeah
21:21:30 <mmorrow> heh, i actually went to the link
21:21:33 <lispy> mmorrow, ddarius: freedos?
21:21:45 <mmorrow> ooh, nice call.
21:21:46 <jeffz> windows cmd.exe is probably a better place to start, I think it provides a more featureful implementation than the old command.com
21:21:52 <waynemokane> they always say IO has to be the innermost if used in a Monad transformer... is that "innermost" only referring to the Monadic type itself, and not the logical flow?
21:22:10 <adk> so you need (ord . toUpper) 'a' instead of ord . toUpper 'a' ? why? does haskell evaluate the former as ord . (toUpper 'a') ?
21:22:10 <jeffz> mmorrow: Wine also has an implementation of cmd
21:22:12 <Cale> waynemokane: yeah, basically.
21:22:15 <mmorrow> i know that yhc has a module for batch generation/prettyprinting
21:22:26 <Cale> adk: yes
21:22:30 <mmorrow> jeffz: hmm
21:22:37 <Cale> adk: Function application binds tighter than any operator symbol
21:22:37 * mmorrow collects links real quick
21:22:45 <waynemokane> I mean... every program starts in IO ()... and if at some point you are executing actions in State s... you have started in IO, so if you do liftIO you are kind of wrapping it around yourself
21:22:59 <Cale> waynemokane: State s isn't a monad transformer :)
21:23:02 <adk> Cale: is there a way around that? (ord . toUpper) looks less eligant than ord . toUpper
21:23:19 <Cale> waynemokane: But yeah, you might use something like the StateT s IO monad.
21:23:20 <waynemokane> ah, so it doesn't really have anything to do with program flow at all... just stricly for typing purposes
21:23:32 <waynemokane> I guess it makes things easier on the compiler?
21:23:35 <Cale> adk: You can combine with $ to apply
21:23:50 <roconnor> mental note: haskell-download
21:23:50 <Cale> $ is function application, but it has really weak precedence
21:24:05 <adk> Cale: how would it look with the $ ? something like $ ord . toUpper x ??
21:24:12 <Cale> adk: but in this expression with the subtraction, it might get in the way...
21:24:15 <waynemokane> so I can always safely do liftIO with impunity... even if I have already "left" IO at some point prior
21:24:18 <Cale> ord . toUpper $ x
21:24:48 <Cale> But of course, $ binds more weakly than -
21:25:38 <adk> Cale: is it generally a good practice to use the $'s or should is (ord . toUpper) x a better style?
21:25:55 <Cale> Using a $ after the last thing in a composition chain is fine.
21:26:26 <Cale> I take exception with using a chain of $'s rather than making the first (n-1) of them composition though, since composition has nice properties that $ doesn't.
21:26:35 <Cale> (associativity being the main thing :)
21:26:48 <Cale> f . (g . h) = (f . g) . h
21:26:54 <Cale> Whereas if you write
21:27:30 <lispy> I find that I often use them together
21:27:35 <Cale> Yeah
21:27:41 <lispy> foo . bar baz . quux $ blah
21:27:54 <Cale> In  f . g . h $ x, for example, g . h has meaning on its own
21:28:12 <Cale> But if you write f $ g $ h $ x, then g $ h is probably a type error on its own
21:28:15 <waynemokane> just so I'm clear... if, from main :: IO (), I run a state machine State s... within the action of that state machine I can do "liftIO" safely even though the IO monad from main is "outside" of the state machine?
21:28:30 <Cale> waynemokane: Perhaps you mean  StateT s IO
21:28:38 <Cale> waynemokane: The State monad can't do IO.
21:28:52 <Cale> (it's pure, implemented with functions and pairs :)
21:29:00 <waynemokane> yeah I know... but I can always liftIO to get a hold of IO within some other Monad
21:29:03 <waynemokane> right?
21:29:03 <Cale> no
21:29:08 <waynemokane> oh
21:29:09 <rwbarton> :t liftIO
21:29:10 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:29:19 <Cale> Only in monads which are transformed versions of the IO monad.
21:29:24 <waynemokane> ooh because of this constraint
21:29:25 <waynemokane> main = print . runState $ do
21:29:30 <waynemokane> er, crap...
21:29:31 <waynemokane> liftIO :: (MonadIO m) => IO a -> m a
21:29:35 <adk> lispy: what does foo . bar baz . quux $ blah look like in, say, python? foor(bar(baz)???
21:29:57 <lispy> adk: (foo (bar baz (quux blah)))
21:30:09 <Cale> foo(bar(baz, quux(blah)))
21:30:21 * lispy went with lisp
21:30:44 <Draconx> how lispy of you.
21:31:13 <adk> but baz is a variable. in general what would  f(x,y) . g(z) mean?
21:31:20 <lispy> adk: it takes a while to develop the intuition for ($). I'd say get used to (.) first.
21:31:38 <Cale> adk: It means the composite of the functions produced by f (x,y) and g (z)
21:32:06 <lispy> adk: well, in haskell, foo :: a -> b -> c, is the same as foo :: a -> (b -> c), which means, foo somea :: b -> c
21:32:29 <Cale> Where  somea :: a
21:32:39 <mmorrow> ok, links in general: http://code.haskell.org/~morrow/code/batch/links.html
21:32:39 <waynemokane> Cale: is it because StateT declares itself an instance of MonadIO whereas State does not?
21:32:56 <mmorrow> and an HsColourized yhc/misc/Batch.hs http://code.haskell.org/~morrow/code/batch/Batch.hs.html
21:32:57 <lambdabot> Title: Haskell Code by HsColour
21:32:59 <Cale> waynemokane: right, but more fundamentally, in State, there's no way to represent IO actions at all.
21:33:20 <waynemokane> ooh, that just made a whole bunch of stuff make sense
21:33:20 <mmorrow> the yhc Batch.hs actually has a batch AST
21:33:23 <Cale> waynemokane: Because values of type (State s a) are internally really just functions  s -> (s,a)
21:33:38 <adk> so the same definition of f and g. f . g x y  := f(x,g(y)) or is it f(g(x), y) or would you write it as f x . g y to avoid this confusion all together?
21:33:58 <Cale> waynemokane: So there's no obvious way to turn putStrLn "Hello" into a function s -> (s,a) :)
21:34:26 <waynemokane> right, because it doesn't know about the state of the world
21:34:31 <Cale> f . g x y = \z -> f (g x y z)
21:34:38 <jeffz> mmorrow: i have a repl in batch, i'll paste it in a sec
21:34:49 <Cale> f x . g y = \z -> f x (g y z)
21:34:57 <rwbarton> f(x,g(y)) --> f x . g $ y   f(g(x), y) --> f (g x) y
21:35:03 <ddarius> @unpl f x . g y
21:35:03 <lambdabot> (\ c -> f x (g y c))
21:35:03 <koninkje> augustss++
21:35:07 <jeffz> mmorrow: it can do self modifying code :P
21:35:11 <Cale> adk: Do those help?
21:35:19 <mmorrow> jeffz: interesting..
21:35:29 <Cale> adk: The functions are applied to their parameters first, and then the results are composed.
21:35:49 <rwbarton> (alternatively,  f(g(x), y) --> (`f` y) . g $ x  )
21:35:49 <Cale> (though, that's not actually the order things are evaluated in...)
21:35:59 <lispy> adk: it's good to see you asking questions.  It's fun to see the next generation of Haskellers get started :)
21:36:07 <adk> Cale: I think so.
21:36:23 <Cale> adk: Perhaps some examples will help :)
21:36:50 <waynemokane> Cale: ok... maybe you can help me make sense of how StateT implements liftIO then
21:36:55 <Cale> > map ord . map toUpper $ "hello"
21:36:57 <lambdabot>  [72,69,76,76,79]
21:37:01 <Cale> > (map ord . map toUpper) "hello"
21:37:02 <lambdabot>  [72,69,76,76,79]
21:37:10 <Cale> waynemokane: Okay :)
21:37:24 <waynemokane> instance (MonadIO m) => MonadIO (StateT s m) where
21:37:24 <waynemokane>     liftIO = lift . liftIO
21:37:24 <waynemokane> instance (MonadIO m) => MonadIO (StateT s m) where
21:37:24 <waynemokane>     liftIO = lift . liftIO
21:37:24 <waynemokane> instance (MonadIO m) => MonadIO (StateT s m) where
21:37:25 <waynemokane>     liftIO = lift . liftIO
21:37:26 <Cale> > map ord (map toUpper "hello")
21:37:27 <waynemokane> instance (MonadIO m) => MonadIO (StateT s m) where
21:37:28 <lambdabot>  [72,69,76,76,79]
21:37:29 <waynemokane>     liftIO = lift . liftIO
21:37:31 <waynemokane> instance (MonadIO m) => MonadIO (StateT s m) where
21:37:33 <waynemokane>     liftIO = lift . liftIO
21:37:35 <Cale> waynemokane: ...
21:37:36 <waynemokane> oops sorry folks!
21:37:48 <geezusfreeek> wtf
21:37:57 <Cale> heh, no problem :)
21:38:08 <Cale> (Just be careful in the future ;)
21:38:26 <waynemokane> oh trust me I will... finally I can see how tricky xchat aqua can be
21:38:42 <Cale> Okay, so, well, you really need to understand lift in order to understand what's actually going on.
21:38:45 <waynemokane> anyway.... it seems like that implementation of liftIO is self recursive
21:38:47 <Cale> But let's look at this
21:38:52 <Cale> It's not really.
21:38:58 <Cale> It's recursing on a different liftIO
21:39:00 <jeffz> mmorrow: http://hpaste.org/9999 - damn, almost the 10000th paste
21:39:06 <Cale> For a different instance of MonadIO
21:39:20 <Cale> (in the end, IO is an instance of MonadIO, which is just the identity)
21:39:25 * mmorrow looks
21:39:41 <mmorrow> just found http://source.winehq.org/source/programs/cmd/
21:39:41 <lambdabot> Title: wine/programs/cmd/
21:39:42 <mmorrow> w/
21:40:01 <mmorrow> http://source.winehq.org/source/programs/cmd/batch.c
21:40:02 <lambdabot> Title: wine/programs/cmd/batch.c
21:40:05 <jeffz> mmorrow: yes, you can git clone git://source.winehq.org/git/wine.git
21:40:30 <mmorrow> cool
21:40:47 <waynemokane> oh, so basically m is the second argument to the type constructor of StateT?  and it must be a MonadIO for this to be relevant?
21:41:23 <Cale> waynemokane: I think before I can explain this, I should explain what lift does.
21:41:35 <jeffz> mmorrow: wine's cmd doesn't seem to support the neat trick though
21:41:40 <Cale> lift is a key component as far as how monad transformers work
21:41:45 <Cale> :t lift
21:41:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
21:41:55 <jeffz> mmorrow: everytime a line is executed in a batch file it's re-read from the disk
21:41:57 <Cale> Jeez... enough quantifier nonsense...
21:42:01 <Cale> (Monad m, MonadTrans t) => m a -> t m a
21:42:06 <Cale> there, the important bit :)
21:42:21 <waynemokane> well I think I get lift... basically it just gives you a function which "gets you into" the next level Monad
21:42:21 <Cale> So, if m is any monad, and t is any monad transformer
21:42:40 <jeffz> mmorrow: that's why you can define new procedures with my repl
21:42:50 <mmorrow> jeffz: ah, i see. hmm, wish i had a haskell batch interp ...
21:42:58 <waynemokane> given the monad you're in now... whatever it is, you can always lift out of it
21:43:06 <Cale> lift's job is exactly that, to add whatever structure to the action is required to include it in the transformed monad
21:43:07 * mmorrow looks at the code and pretends
21:43:28 <adk> Cale: that makes sense. (map ord . map toUpper) "Hello" just means map ord k where k = map toUpper "hello"
21:43:50 <Cale> lift adds more structure, it doesn't take it away... for example, you can lift from IO to StateT Integer IO, but you can't go back down using lift.
21:43:59 <Cale> adk: Right :)
21:44:14 * mmorrow begins to learn the syntax
21:44:21 <waynemokane> oh crap I have it backwards
21:44:24 <Cale> adk: map takes one parameter and gives a function from lists to lists.
21:44:37 <Cale> adk: and those functions get composed together here :)
21:45:07 <mmorrow> jeffk: ok. i just realized what you're doing there.
21:45:25 <Cale> waynemokane: So, for the StateT transformer, lift needs to take an IO action, say  x :: IO t
21:45:50 <Cale> and turn it into an action of type StateT s IO t
21:46:01 <Cale> Of course, under the covers, that's just...
21:46:07 <Cale> @unmtl StateT s IO t
21:46:08 <lambdabot> s -> IO (t, s)
21:46:09 <adk> Cale: Thanks that clears up many of my confusions. I will try to write some more programs and ask you any questions later.
21:46:16 <Cale> adk: Cool :)
21:47:19 <Cale> So, that would be (\s -> do v <- x; return (v,s))
21:47:30 <Cale> and then wrap that in a StateT data constructor, and we're done :)
21:47:43 <Cale> lift x = StateT (\s -> do v <- x; return (v,s))
21:48:00 <Cale> waynemokane: follow that?
21:48:34 <Cale> waynemokane: So lift added the extra plumbing of the state variable which was required for the StateT transformed monad.
21:48:34 <waynemokane> yeah it makes sense... following along in the source here
21:48:50 <waynemokane> I guess I just never expected these "constraints" or whatever you want to call them, to appear in that position
21:48:52 <Cale> I hope I'm close enough to the source that things match up okay :)
21:48:59 <waynemokane> yes very close
21:49:17 <waynemokane> basically everyting to the left of the "=>"
21:49:32 <mmorrow> jeffk: just in case you happen to be messing with a repl/interp ( :) ), here's a wrapper around readline/editline that makes it easypeasy to get a nice prompt  http://code.haskell.org/~morrow/code/batch/Repl.hs.html
21:49:33 <lambdabot> Title: Haskell code
21:49:33 <Cale> right, class constraints
21:49:46 <jeffz> mmorrow: over here.
21:49:51 <Cale> For lift, those are just saying that m is a monad, and t is a monad transformer.
21:49:58 <mmorrow> jeffz: hmm?
21:50:05 <Cale> (Monad m, MonadTrans t) => m a -> t m a
21:50:06 <waynemokane> I really am only thinking of those in terms of functions... f (c1 a, c2 b) => (a->b) -> b
21:50:09 <waynemokane> or whatever
21:50:19 <jeffz> mmorrow: I think you were addressing jeffk
21:50:41 <waynemokane> crazy... I need to read about class constraints then
21:50:51 <Cale> This reads as "If m is any instance of Monad, and t is any instance of MonadTrans, then lift takes values of type m a and produces values of type t m a
21:51:07 <mmorrow> jeffz: ahh, tab completion ... it took me a second
21:51:17 <Cale> Oh... you should definitely know about them if you're studying monads...
21:51:32 <waynemokane> so is it accurate to say that StateT is only "conditionally" a MonadIO?  that is, if and only if its second type argument is an instance of MonadIO?
21:51:43 <Cale> Well, yeah
21:51:49 <mmorrow> jeffz: hmm, actually i don't think there's a jeffk here so it wasn't tab completion ... aaaanyway
21:52:00 <jeffz> mmorrow: ok cool, if I lose my mind and decide to implement an interpreter I'll know where to start :)
21:52:11 <Cale> StateT Integer [], for example has nothing to do with IO
21:52:19 <mmorrow> jeffz: mind that you lose it soon :)
21:52:20 <waynemokane> ok that is  blowing my mind... need a moment to ponder it over
21:52:21 <Cale> So there's no way to turn IO actions into something of that type.
21:52:30 <waynemokane> seems like the Java interface analogy in my brain is starting to come undone
21:52:35 <Cale> hehe
21:52:43 <Cale> Okay, let's step back to something simpler
21:52:46 <Cale> sort
21:52:56 <Cale> Say we're writing a function that sorts a list
21:53:07 <Cale> Well, we'd like it to be able to sort "any" list.
21:53:30 <Cale> But not every possible type of elements has a natural ordering.
21:53:34 <waynemokane> so if I have some action of type :: StateT Integer [Integer] a... within that action I will not be able to do liftIO
21:53:42 <Cale> (for example, what if the elements are IO actions?)
21:53:59 <Cale> waynemokane: that's a kind error...
21:53:59 <waynemokane> because [Integer] is not IO x
21:54:09 <Cale> StateT Integer [] a
21:54:22 <Cale> @unmtl StateT Integer [] a
21:54:22 <lambdabot> Integer -> [(a, Integer)]
21:54:31 <Cale> Nothing IO-ish about that :)
21:54:52 <Cale> Just a function from Integers to lists of pairs of values of type a and Integers :)
21:55:00 <waynemokane> yep
21:55:08 <waynemokane> whoa did that bot just determine the type of what you said?
21:55:18 <Cale> It determined the underlying type
21:55:26 <sjanssen> @src StateT
21:55:26 <lambdabot> Source not found. Do you think like you type?
21:55:35 <mmorrow> waynemokane: oh man, you're in for a bottrip
21:55:38 <hml> the haskell emacs mode tends to ident blocks more than 2 spaces; when i really want it ot only ident two spaces; it there an easy way to fix this?
21:55:49 * Cale wishes that lambdabot was in better health :)
21:55:50 <Cale> hehe
21:55:51 <waynemokane> man who needs the twilight zone when I can just come into this channel
21:56:22 <lispy> ?src ask
21:56:22 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:56:36 <mmorrow> @pl \g f a b c d e -> g (f a b c d e)
21:56:36 <lambdabot> (.) . (.) . (.) . (.) . (.)
21:57:01 <mmorrow> @pl \g f a b -> g (f a) b
21:57:01 <lambdabot> (.)
21:57:03 <ddarius> @src Reader ask
21:57:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:57:11 <ddarius> @src (->) ask
21:57:11 <mmorrow> @pl \g f a b -> g a (f b)
21:57:11 <lambdabot> ask = id
21:57:12 <lambdabot> flip . ((.) .)
21:57:30 <lispy> I'm really tripped up on how to implement my ask
21:57:48 <lispy> for Reader, it's ask = Reader id
21:57:57 <ivanm> lispy: ask and ye shalt receive! :p
21:58:01 <Cale> waynemokane: okay, so if you were following that stuff about sort just a moment ago...
21:58:08 <ivanm> (or maybe ask and ye shalt Read?...)
21:58:13 <lispy> I have something that is nearly identical to Reader, but the above isn't the right type for me...
21:58:14 <Pseudonym> lispy: This is for a custom monad?
21:58:33 <Cale> waynemokane: sort :: [a] -> [a]  isn't quite right, because we need to be able to compare values of type a, and being totally polymorphic, there's no guarantee that we could do that
21:58:35 <lispy> Pseudonym: costom monad thing...it has the wrong kind to be a monad
21:58:42 <waynemokane> Cale: yeah I am reading it now... I was talking around you when you first typed it... 1 sec
21:58:42 <Pseudonym> Right.
21:58:50 <Pseudonym> So, lispy, what are the operations on it?
21:58:54 <Pseudonym> And their types.
21:59:17 <lispy> Pseudonym: One thing I do differently than Reader, is that where reader is Reader r a, I'm MyReader r a = Reader r (IO a)
21:59:34 <lispy> Pseudonym: well....where do you want me to start?
21:59:34 <Pseudonym> No, ignore that.
21:59:40 <Pseudonym> I want to know what the basic operations are.
21:59:43 <sjanssen> lispy: sounds like ReaderT r IO?
21:59:45 <Pseudonym> You support return and bind, presumably?
21:59:56 <ddarius> @unmtl ReaderT r IO a
21:59:56 <lambdabot> r -> IO a
21:59:57 <lispy> sjanssen: aye, I can derive that but it won't have the right type
22:00:10 <lispy> Pseudonym: yeah, return, (>>) and (>>=) and fmap
22:00:21 <lispy> Pseudonym: also, an equivalent of liftIO
22:00:24 <Pseudonym> Well, fmap and (>>) are derived.
22:00:29 <Pseudonym> OK, what does the lifIO type have?
22:00:31 <Pseudonym> What type.
22:00:43 <Pseudonym> liftIO, I guess
22:00:44 <lispy> rIO :: IO a -> RIO p r u tt a
22:00:45 <lispy> er
22:00:47 <lispy> rIO :: IO a -> RIO p r u t t a
22:00:58 <Pseudonym> RIO is your type?
22:01:03 <waynemokane> Cale: ok... so we can't be sure that over all types a, we can even write a function to sort a list of as
22:01:03 <ddarius> It's 00:00 o'clock, time for sleep.
22:01:09 <Cale> waynemokane: right
22:01:17 <Pseudonym> OK.
22:01:22 <jeffz> mmorrow: http://www.commandline.co.uk/lib/treeview/index.php has a good library of procedures
22:01:23 <lambdabot> Title: Batch Function Library for Windows NT4/2000/XP/2003
22:01:24 <Cale> waynemokane: we need to have a way to compare values of type a for ordering
22:01:27 <lispy> newtype RIO p r u t t1 a = RIO { unsafeUnRIO :: Repository p r u t -> IO a -- that's my type
22:01:31 <Pseudonym> So the type of return is, I assume, a -> RIO p r u t t a
22:01:32 <Cale> waynemokane: So, we create a typeclass...
22:01:42 <Pseudonym> Ignore the type for the moment please.
22:01:45 <Cale> waynemokane: If you'd like, we could move to #haskell-overflow :)
22:01:47 <Pseudonym> I want to know what it does abstractly.
22:01:56 <lispy> Pseudonym: yes, return looks right
22:01:57 <Pseudonym> Or we could. :-)
22:02:00 <Cale> (since this is a little noisy :)
22:02:08 <waynemokane> Cale: ok I'm there
22:02:20 <lispy> Pseudonym: want move to #darcs?  this is related to darcs
22:02:24 <Pseudonym> t1 is phantom?
22:02:40 <mmorrow> jeffz: nice. added to http://code.haskell.org/~morrow/code/batch/links.html
22:02:42 <lispy> Pseudonym: yes it is
22:02:46 <Pseudonym> lispy: Actually, in a moment, I'm going to get you to redefine your type in an interesting way.
22:02:55 <lispy> Pseudonym: cool!
22:02:59 <ivanm> does yi depend on gtk2hs even if it isn't built with the gtk flag?
22:03:00 <Pseudonym> We could take it to #darcs if you like.
22:03:54 <ivanm> wait, forget that... I found were its listed in the cabal file...
22:09:49 <Pseudonym> CONGRATULATIONS LISPY 10,000th PASTE
22:10:54 <lispy> hehe
22:11:01 <lispy> whooohooo!
22:11:22 <shepheb> man, my guess for when the 10,000th would be was way off
22:11:32 * shepheb tears up his November 10th ballot
22:12:58 <mmorrow> jeffz: added a link to your repl to links.html
22:14:10 <haskellian> damn how do I iterate over a Data.Map? why isnt this possible btw : print (Dmap.elems (Dmap.elems small))
22:14:36 <TSC> haskellian: I think you'd need a map in there
22:14:43 <haskellian> when print (Dmap.elems small) , works afsgsf
22:14:47 <TSC> map Dmap.elems (Dmap.elems small)
22:14:56 <TSC> i.e. call elems on every element of small
22:15:04 <haskellian> the first call return a map
22:15:06 <jeffz> mmorrow: I guess you could do something cool with a customizable variation, add a cffi and it would be awesome :D
22:15:19 <haskellian> or wait a list of maps?
22:15:33 <TSC> The inner call returns a list of maps, doesn't it?
22:15:36 <haskellian> aha!
22:18:09 <haskellian> damn at least in other langauges i can do things tupidly if i cant think of a better way.
22:18:49 <Pseudonym> Hey, we resent that.  You can write stupid code in Haskell.
22:18:49 <haskellian> I have a Map of Maps and for every key/value pair in the second list I want to calculate something
22:18:50 <mmorrow> jeffz: definitely. it'd be really sweet if it could do (ba)sh+batch, is fully (and easily) customizable, and has a cffi (which would be trivial w/ haskell's ffi)
22:18:57 <Pseudonym> You just hve to think about it a bit, that's all.
22:19:06 <TSC> Yeah, I write stupid Haskell all the time
22:19:27 <mmorrow> (i took cffi to mean C FFI (?))
22:19:35 <jeffz> mmorrow: yep
22:19:40 <mmorrow> definitely
22:45:41 <haskellian> http://hpaste.org/10001 , sigh help please
22:47:24 <TSC> Do it in bits
22:47:27 <TSC> First compute the sum
22:47:40 <TSC> Then perform the division
22:47:47 <TSC> The accumulate the values
22:48:04 <haskellian> yes but im wondering if there is some nice function for mapping over the Maps
22:49:33 <TSC> Data.Map.map ?
22:50:07 <quicksilver> haskellian: there is both 'map' and 'mapWithKey'
22:50:16 <quicksilver> haskellian: and a bunch of more obscure ones.
22:50:24 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#11
22:50:26 <lambdabot> Title: Data.Map, http://tinyurl.com/34gle9
22:50:36 <rwbarton> is there a scanl for Traversable?
22:51:06 <dons> i think we wondered this the other day, but you can recover scanl from foldl
22:51:16 <dons> :t scanl
22:51:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:51:19 <dons> :t foldl
22:51:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:51:41 <rwbarton> for the Traversable version I was thinking of sequence'ing a State monad
22:52:28 <quicksilver> dons: no you can't ;)
22:52:50 <quicksilver> dons: foldl comes with Foldable but you need Traversable to get a generalised scanl.
22:53:01 <quicksilver> (assuming you want the return type to be 't a' and not [a])
22:53:58 <rwbarton> > let scanlT f start t = evalState (Data.Traversable.mapM (\x -> do { a <- get; let b = f a x; put b; return b }) t) start  in  scanlT (+) 0 (M.fromList [("a", 1), ("b", 2), ("c", 3)])
22:53:59 <lambdabot>  Parse error at ";" (column 99)
22:54:33 <rwbarton> help?
22:54:40 <hml> the following complains about windowRefreshCallback being not in scope; but I can clearly see it in: :browse Graphics.OpenGLFW
22:54:44 <hml>   GLFW.windowCloseCallback $= writeIORef quit True
22:54:46 <hml>   GFLW.windowRefreshCallback $= writeIORef dirty True
22:55:23 <quicksilver> hml: "GFLW" is not "GLFW" :P
22:55:56 <hml> quicksilver: i'm blind
22:56:01 <hml> quicksilver: thanks
22:56:32 <ivanm> anyone know how strict the build requirements for yi are? e.g. does parsec _have_ to be <2.2 ?
22:57:39 <rwbarton> > let scanlT f start t = evalState (Data.Traversable.mapM (\x -> do { a <- get; put (f a x); b <- get; return b }) t) start  in  scanlT (+) 0 (M.fromList [("a", 1), ("b", 2), ("c", 3)])
22:57:40 <lambdabot>      Not in scope: `Data.Traversable.mapM'
22:59:38 <rwbarton> of course the result of scanl includes the initial value at the beginning of the list, which doesn't have a Traversable analogue
23:00:21 <quicksilver> it's scanl1 you want to emulate isn't it?
23:00:24 <quicksilver> :t scanl1
23:00:25 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
23:00:39 <quicksilver> I mean, that's the one you can most naturally emulate.
23:00:54 <mib_qe35tqaf> testing 1 2 3
23:00:56 <rwbarton> yes, and that's what I'm using anyways
23:01:01 <rwbarton> scanl1 (+) []
23:01:02 <rwbarton> > scanl1 (+) []
23:01:03 <lambdabot>  []
23:01:09 <quicksilver> mib_qe35tqaf: not working, no, we can't hear you.
23:01:09 <quicksilver> :P
23:01:10 <mib_qe35tqaf> hi haskellers
23:01:19 <dolio> That has no initial state, though.
23:01:20 <mib_qe35tqaf> meh how do i change my name -_-
23:01:42 <rwbarton> dolio: a <- get; case a of Nothing -> .......
23:01:51 <mib_qe35tqaf> hey guys, how do you calculate the frequency of a letter in a string using elem
23:02:09 <dolio> Yeah, that'd work.
23:02:11 <mib_qe35tqaf> for example, icecream, the frequency of i in that string is 1
23:02:29 <mib_qe35tqaf> for example, icecream, the frequency of c is 2
23:02:34 <sbahra> mib_qe35tqaf: Why don't you begin by showing us your attempt?
23:02:46 <mib_qe35tqaf> i dont know how to start
23:02:52 <sbahra> Do you know haskell?
23:03:03 <mib_qe35tqaf> so just wandering whether there is any inbuilt functions in haskell that could do that
23:03:03 <roconnor> > (head &&& length) . group . sort $ "hello world"
23:03:04 <lambdabot>  mueval: Prelude.read: no parse
23:03:21 <mib_qe35tqaf> are there any ?
23:03:28 <roconnor> > 2
23:03:29 <lambdabot>  2
23:03:31 <sbahra> mib_qe35tqaf: You can implement it using elem.
23:03:42 <rwbarton> roconnor: it's because mueval doesn't know about Control.Arrow
23:04:02 <roconnor> rwbarton: oh, why not?
23:04:03 <mib_qe35tqaf> ok rwbarton
23:04:04 <haskellian> yeah but how do I build a Map with the old map at the smae time
23:04:10 <mib_qe35tqaf> i'll try it out with elem :)
23:04:18 <roconnor> who is mueval?
23:04:20 <mib_qe35tqaf> if i could not work it out, I'll post it here :D
23:04:24 <roconnor> where is eval?
23:04:27 <roconnor> where am i?
23:04:33 <sbahra> Great, atleast give us something to work on :-)
23:04:39 <rwbarton> roconnor: :) just a bit broken I guess.
23:14:22 <ibid> dons, ddarius: there's no such request in my queue
23:14:54 * ibid is now looking at the log of processed requests...
23:20:57 <ibid> dons, ddarius: actually, there is, it just doesn't hit my usual filters (sent to planet@ or "planet" in subject) so i've probably missed it in my procesing
23:21:56 <ibid> dons, ddarius: ah. i see it's a new request.  why did you have to highlight it for me here, made me think i had missed something :)
23:24:22 <mib_qe35tqaf> hmm
23:24:39 <mib_qe35tqaf> do i need to store the string into a list so i could check each letter?
23:24:46 <mib_qe35tqaf> o_o
23:25:12 <jeffz> mib_qe35tqaf: a String is a list
23:25:36 <mib_qe35tqaf> huh
23:25:39 <mmorrow> > 'a' : 's' : 'd' : 'f' : []
23:25:40 <lambdabot>  "asdf"
23:25:42 <TSC> String is [Char]
23:25:48 <mmorrow> > ['a'..'z']
23:25:49 <mib_qe35tqaf> i thought a list should have these 2 boxy brackets [ ]
23:25:49 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
23:26:03 <mmorrow> > map ord ['a'..'z']
23:26:04 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
23:26:07 <jeffz> mib_qe35tqaf: you should probably read some tutorials on haskell.org that give you an introduction
23:26:19 <mmorrow> > map (chr . ord) ['a'..'z']
23:26:20 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
23:26:26 <mib_qe35tqaf> you see, what im trying to do now is using monad , the getLine thingy to get user input and later store it into a list
23:26:31 <mib_qe35tqaf> >.<
23:26:52 <mmorrow> mib_qe35tqaf: a nice main function for a filter program is something like
23:27:06 <mmorrow> main = putStr . doStuff =<< getContents
23:27:11 <mmorrow> then, you write
23:27:17 <mmorrow> doStuff :: String -> String
23:27:27 <mmorrow> so the main function is one line
23:27:33 <Cale> mib_qe35tqaf: usually /nick newnickname  will work to change your nick.
23:27:34 <mmorrow> the rest of the program may be 1000
23:27:52 <Cale> (In most IRC clients, I don't know about mibbit)
23:29:10 <newbieneedhelp> i dont really understand this doStuff =<< getContents
23:29:14 <newbieneedhelp> =<<
23:29:19 <mmorrow> err, so :
23:29:56 <newbieneedhelp> hmm since you mentioned taht a string is a list, then, could i just use head and tail directly to get 1 letter from the string?
23:30:16 <newbieneedhelp> without putting the user input string into a list
23:30:20 <TSC> > head "string"
23:30:21 <lambdabot>  's'
23:30:25 <mmorrow> do { a <- getContents ; putStr (doStuff a) } === putStr . doStuff =<< getcontents === getContents >>= putStr . doStuff === getContents >>= \a -> putStr (doStuff a)
23:30:45 <newbieneedhelp> oh thanks tsc
23:31:07 <mmorrow> > reverse ['a'..'z']
23:31:08 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
23:31:21 <lispy> > ['z'..'a']
23:31:22 <lambdabot>  ""
23:31:26 <lispy> :(
23:31:28 <hml> given: import Graphics.Rendering.OpenGL as GL ;;; how can I still get:     Ambiguous occurrence `Point'
23:31:31 <hml>     It could refer to either `Main.Point', defined at /home/x/fun/test.hs:9:13
23:31:34 <hml>                           or `GL.Point', imported from Graphics.Rendering.OpenGL at /home/x/fun/test.hs:1:0-37
23:31:42 <TSC> hml: "import qualified"
23:31:53 <mmorrow> > span (/='.') "127.0.0.1"
23:31:54 <lambdabot>  ("127",".0.0.1")
23:32:06 <TSC> Or use "Main.Point" or "GL.Point" instead of "Point"
23:32:42 <mmorrow> > span isDigit "127.0.0.1"
23:32:43 <lambdabot>  ("127",".0.0.1")
23:33:42 <thetallguy> ?seen conal
23:33:42 <lambdabot> I haven't seen conal.
23:33:51 <newbieneedhelp> hmm
23:33:53 <thetallguy> ?seen conal'
23:33:53 <lambdabot> I haven't seen conal'.
23:34:01 <newbieneedhelp> btw, elem produces boolean like true and false
23:34:03 <mmorrow> preflex: seen conal
23:34:04 <preflex>  conal was last seen on #ghc 18 hours, 31 minutes and 3 seconds ago, saying: sweet.  then we can simplify the unamb implementation.  thx.
23:34:13 <newbieneedhelp> > 1 'elem' [1..2]
23:34:14 <lambdabot>  Improperly terminated character constant at "'elem..." (column 3)
23:34:33 <TSC> newbieneedhelp: You need backquotes: ` not '
23:34:39 <mmorrow> > not (1 `elem` [1..2])
23:34:40 <lambdabot>  False
23:34:48 <newbieneedhelp> ok , i got mixed up ^_^ "
23:34:53 <thetallguy> Hmm..  what's preflex?  a lambdabot fork?
23:34:53 <mmorrow> :)
23:34:58 <otsdr>  /msg nickserv
23:35:12 <mmorrow> thetallguy: it's mauke's bot. i'm pretty sure he wrote it from scratch
23:35:26 <thetallguy> ah, based on mueval, right?
23:35:27 <newbieneedhelp> elem can tell me there is or there isnt a letter from a string, if there is 1, it could not tell me how many of them o_o
23:35:42 <mmorrow> thetallguy: no, it doesn't do any evaluation
23:36:04 <mmorrow> thetallguy: but its seen is second to none
23:36:07 <newbieneedhelp> > a `elem` "abcda"
23:36:08 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
23:36:14 <thetallguy> mmorrow: lol
23:36:19 <newbieneedhelp> > 'a' `elem` "abcda"
23:36:20 <lambdabot>  True
23:36:26 <newbieneedhelp> see?
23:37:11 <newbieneedhelp> so any suggestions o_o
23:37:18 <roconnor> > ['z',y'..'a']
23:37:19 <lambdabot>  mueval: Prelude.read: no parse
23:37:25 <TSC> newbieneedhelp: Maybe you'd be interested in filter
23:37:26 <roconnor> > ['z','y'..'a']
23:37:27 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
23:37:50 <newbieneedhelp> ok TSC, ill check filter out :D
23:37:51 <TSC> newbieneedhelp: If you're learning, maybe the best thing is to write it by hand
23:38:04 <newbieneedhelp> writing?
23:38:13 <newbieneedhelp> typing
23:38:16 <mmorrow> > let count a = foldl' (\n c -> if c == a then n+1 else n) 0 in count 'a' "aaaaaafdsasdsasdsaASSASAQa"
23:38:17 <lambdabot>  10
23:38:45 <dons> ibid: oh, sorry for indicating incorrectly :)
23:39:05 <newbieneedhelp> foldl is a filter?
23:39:17 <ibid> dons: not a big issue :)
23:39:17 <mmorrow> it foldl the list into something new
23:39:25 <mmorrow> @type foldl
23:39:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:39:27 <mmorrow> @type foldr
23:39:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:39:40 <mmorrow> > foldl (*) 1 [1..9]
23:39:41 <lambdabot>  362880
23:39:42 <ibid> dons: i'll try to notice it on my next round through the queue, today or tomorrow
23:39:59 <mmorrow> > foldr (++) [] (repeat [0..9])
23:39:59 <dons> ibid: great. tomorrow there'll be a tech talk announcement.
23:40:00 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7...
23:40:16 <mmorrow> > foldr (:) [] [0..9]
23:40:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
23:40:27 <mmorrow> > foldl (flip (:)) [] [0..9]
23:40:28 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
23:40:39 <ibid> dons: feel free to ping me late tomorrow :)
23:40:41 <mmorrow> > foldl (+) 0 [1..9]
23:40:42 <lambdabot>  45
23:40:43 <ibid> dons: (my time)
23:40:46 <dons> ok.
23:40:49 <dons> thanks!
23:40:52 <newbieneedhelp> oh i see
23:40:54 <mmorrow> @src product
23:40:54 <lambdabot> product = foldl (*) 1
23:40:58 <mmorrow> @src sum
23:40:58 <lambdabot> sum = foldl (+) 0
23:41:01 <mmorrow> @src concat
23:41:01 <lambdabot> concat = foldr (++) []
23:41:08 <mmorrow> @src reverse
23:41:08 <lambdabot> reverse = foldl (flip (:)) []
23:41:12 <newbieneedhelp> wow all those inbuilt function uses fold
23:41:18 <newbieneedhelp> amazing
23:41:44 <mmorrow> yeah, foldl and foldr are fundamental to lists
23:41:49 <dons> that's how you loop
23:41:54 <newbieneedhelp> a great eye opener ^_^
23:42:06 <jeffz> mmorrow: http://hpaste.org/9999#a1
23:42:11 <newbieneedhelp> mmorrow, are a you a haskell teacher or something
23:42:18 <mmorrow> heh, no :)
23:42:25 <newbieneedhelp> you sound pro
23:42:30 <mmorrow> haha
23:42:55 <mmorrow> you'll be sounding pro in no time
23:43:40 <dons> http://hpaste.org/10000
23:43:41 <dons> woot
23:43:43 <dons> go team
23:43:57 <dons> glguy_: ^
23:44:14 <newbieneedhelp> ok, i'll read up on fold and make a function in my winhugs
23:44:21 <dons> happs has had a pretty reliable run. hpaste is rarely down, and it just keeps serving.
23:44:26 <dons> awesome work.
23:44:27 <newbieneedhelp> brb
23:44:31 <jeffz> I bet hpaste is the most interesting pastebin on the internet too.
23:45:07 <mmorrow> jeffz: i like it.
23:45:10 <dons> we tried to make it a clean, elegant paste bin
23:45:19 <mmorrow> (the list zipper as file)
23:47:44 <conal> thetallguy: ping
23:49:10 <mmorrow> jeffz: and what's cool about it being parameterized by a is that a line can be a String, an AST, a ...
