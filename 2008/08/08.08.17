00:01:54 <newsham> hi
00:03:42 <Trinithis> newsham: on your monad primer page, I would suggest reordering the (+x) to (x+) for the function monad to reinforce that env gets applied last
00:03:51 <Trinithis> in your comments
00:04:15 <tehgeekmeister> mmorrow: the code that processes the match, if i'm using the bytestring wrapper, is it passed a bytestring or a string?
00:05:22 <newsham>     testEnv (const 3 >>= \n -> (+n))          -- (3+) -> 103
00:05:23 <Trinithis> never mind. I'm dumb
00:05:32 <newsham> ?
00:05:33 <Trinithis> i got confused for a sec
00:06:00 <Trinithis> or wait...
00:06:24 <Trinithis> because of non-associative operators like (-)
00:07:32 <newsham> const 3 >>= \n -> (+n)
00:07:40 <Trinithis> testEnv (const 3 >>= \n -> (-n))   -- (3-) -> -97
00:07:57 <newsham> it says (-n) not (n-)
00:08:19 <lispy> guys...monads aren't realy
00:08:21 <lispy> er real
00:08:22 <Trinithis> s/(-n)/(n-)
00:08:25 <Trinithis> typo
00:08:40 <newsham> trinithis: so you see that the answer is going to depend on how its written .
00:08:54 <newsham> if you write  >>= \n -> (n-)     its going to be  (n-) at the end
00:09:15 <newsham> that doesnt imply that env gets applied first
00:09:23 <Trinithis> yeah. guess the best way is to use a non-communative operator like - rather than +
00:09:41 <newsham> I think that misses the point.
00:09:45 <newsham> you can make it commute either way
00:09:51 <newsham> err.. apply in whatever order
00:10:41 <newsham> (\n -> n+3) and   (\n -> 3+n)   are both legitimate functions that can have an env applied "after"
00:11:24 <Trinithis> What I mean is that it isn't apparent if the env is applied before or after with communative functions like +
00:11:32 <tehgeekmeister> hmm.  i get type errors from using both the Prelude and ByteString list functions in my handler for regex matches in alex when using the bytestring wrapper
00:11:47 <newsham> I'm not sure what you mean by "before" or "after"
00:12:08 <Trinithis> env * n vs n * env
00:12:24 <newsham> there is no before or after there.
00:12:34 <newsham> (*n) and (n*) are both functions that take one argument
00:13:13 <Trinithis> Oh I see what you mean. I was thinking in terms of not using lambdas
00:14:28 <Trinithis> aka: f >>= (+)
00:15:06 <newsham> > ((*2) >>= \n -> (\m -> n - m)) 100
00:15:09 <lambdabot>  100
00:15:14 <newsham> > ((*2) >>= \n -> (\m -> m - n)) 100
00:15:17 <lambdabot>  -100
00:15:57 <newsham> you can pick   m-n   or   n-m,  they both work
00:16:26 <newsham> anyway, i must sleep.
00:16:29 <Trinithis> night
00:18:39 <ndmitchell> @seen dcoutts
00:18:40 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
00:18:41 <ndmitchell> @seen dcoutts_
00:18:42 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 7h 57m 36s ago.
00:26:42 <mmorrow> tehgeekmeister: it'll get a ByteString in the bytestring wrapper case
00:26:56 <tehgeekmeister> mmorrow: okay
00:27:18 <mmorrow> i've gotta crash, good luck .. lemme know how it's going tomorrow.
00:27:38 <tehgeekmeister> okay, will do
00:27:45 <tehgeekmeister> it still errors on that, fyi, but i'll keep at it
00:27:49 <tehgeekmeister> thanks for your help
00:28:06 <tehgeekmeister> (using the ByteString functions instead of Prelude ones.)
00:35:08 <lispy> hey everybody!
00:35:26 <tehgeekmeister> yo!
00:35:37 <Apocalisp> Do the libraries contain a function like unfoldr except that it discards intermediate results?
00:36:08 <sjanssen> (last .) . unfoldr?
00:36:26 <lispy> let me here ya make some λ
00:37:08 <lispy> Apocalisp: if you don't hold on to them, neither will the run-time, more or less
00:37:08 <tehgeekmeister> anyone here know alex well?
00:37:15 <Apocalisp> sjanssen: Does that not traverse the list twice, or does laziness save us?
00:37:22 <sjanssen> Apocalisp: just the once
00:37:24 <sjanssen> laziness FTW
00:37:32 <Apocalisp> epic win
00:37:33 <lispy> sjanssen: doesn't that assume fusion?
00:37:45 <lispy> some sort of builder/consumer fusion
00:39:24 <sjanssen> lispy: there is only one traversal without fusion, thanks to laziness
00:40:16 <lispy> sjanssen: is it ... that the unfoldr doesn't evaluate until the call to last tries to get to the end, and hence one traversal?
00:40:41 <tehgeekmeister> http://hpaste.org/9706 <== alex file and error i'm getting that i have NO idea how to work on, if anyone is inclined to take a look
00:40:43 <lispy> tehgeekmeister: I thought you were asking about someone named "alex well".  No never used alex.
00:41:00 <tehgeekmeister> lispy: hah, i thot that might be ambiguous
00:41:01 <tehgeekmeister> =P
00:41:29 <sjanssen> lispy: last will demand each cell of the list in sequence, and unfoldr will only produce a cell when demanded by last
00:41:44 <lispy> tehgeekmeister: hrm...so you're trying to give a bytestring to a string consumer?
00:41:58 <lispy> sjanssen: got it, thanks
00:42:03 <sjanssen> so yes, list cons will be created, but they can be garbage collected immediately
00:42:43 <ndmitchell> tehgeekmeister: how is Article defined?
00:42:56 <tehgeekmeister> ndmitchell: oh.
00:43:02 <lispy> sjanssen: heh, immediately...if not sooner...I'm guessing GHC can do even better than creating the list
00:43:24 <tehgeekmeister> works now.
00:43:26 <tehgeekmeister> thanks.
00:43:39 <lispy> tehgeekmeister: whatcha making?
00:43:46 <sjanssen> lispy: hmm, I don't think it is smart enough in this case
00:44:03 <tehgeekmeister> lispy: still working on cleaning up the wikipedia xml dump to make a graded reader for language learning out of it.
00:44:26 <lispy> tehgeekmeister: graded reader?  so it will classify the content by reading level?
00:45:10 <sjanssen> :t \f x0 -> (fix $ \go x -> go =<< f x `mplus` mzero) x0
00:45:12 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => (a -> m a) -> a -> m b
00:45:15 <tehgeekmeister> lispy: not exactly, it orders the words learned/sentences used to introduce them so that you can read the greatest number of sentences for the least number of words learnt at any given point
00:45:39 <lispy> tehgeekmeister: wow, interesting. Hobby? research? work?
00:45:42 <sjanssen> Apocalisp: above is a version that should be more efficient for your case
00:46:06 <lispy> sjanssen: how did you derive that?
00:46:09 <tehgeekmeister> lispy: hobby for now, and if i end up making something cool enough, maybe work later.
00:46:35 <sjanssen> lispy: inspired by the muse, I guess
00:46:48 <sjanssen> actually, this version is slower than it could be
00:47:05 <sjanssen> :t \f x0 -> (fix $ \go x -> go =<< (f x `mplus` mzero)) x0
00:47:06 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => (a -> m a) -> a -> m b
00:47:32 <sjanssen> bleh, but it's wrong
00:47:44 <tehgeekmeister> lispy: unfortunately, i have a feeling that the (ideal) solution to this problem is np complete, so i'll have to actually put some effort into it if i'm to make it useful at all.
00:48:14 <lispy> tehgeekmeister: if it's for human consumption, we're pretty tolerant of the difference between good and optimal solutions
00:48:27 <lispy> tehgeekmeister: so, maybe you'll get lucky
00:48:30 <tehgeekmeister> lispy: aye which i will have to take advantage of.
00:49:26 <tehgeekmeister> lispy: on the plus side, however, i can use heuristics from other np complete problems to help me, so i don't have to work so hard coming up with an algorithm
00:49:28 <sjanssen> > (\f x0 -> (fix $ \go x -> (go =<< f x) `mplus` return x) x0) (\x -> if x == 10 then Nothing else Just (x+1)) 0 -- working version
00:49:30 <lambdabot>  Just 10
00:49:42 <lispy> tehgeekmeister: yeah
00:50:21 <sjanssen> we should also never result in Nothing...
00:51:08 <sjanssen> > (\f x0 -> (fix $ \go x -> maybe x go (f x)) x0) (\x -> if x == 10 then Nothing else Just (x+1)) 0
00:51:10 <lambdabot>  10
00:51:16 <sjanssen> there we go, now I'm happy
00:52:12 <flw> Just 10
00:52:25 <flw> > Just 10
00:52:27 <lambdabot>  Just 10
00:52:28 <flw> > (\f x0 -> (fix $ \go x -> (go =<< f x) `mplus` return x) x0) (\x -> if x == 10 then Nothing else Just (x+1)) 0 -- working version
00:52:30 <lambdabot>  Just 10
00:52:37 <flw> > :t 10
00:52:38 <lambdabot>   parse error on input `:'
00:52:44 <flw> :t 10
00:52:45 <lambdabot> forall t. (Num t) => t
00:52:48 <lispy> ?pl \_ -> True
00:52:48 <lambdabot> const True
00:53:00 <sjanssen> @pl () == ()
00:53:01 <lambdabot> (line 1, column 3):
00:53:01 <lambdabot> unexpected " "
00:53:01 <lambdabot> expecting variable, "(", operator or end of input
00:53:08 <sjanssen> @pl True == True
00:53:08 <lambdabot> True == True
00:53:11 <lispy> I wonder what makes a person prefer \_ -> True over const True
00:53:29 * lispy is reading some code
00:53:42 <sjanssen> lispy: they're clearly crazy
00:53:57 <lispy> I want to say "const True" is better, but I have no basis
00:54:24 <sjanssen> I'd prefer, though there may be some contexts where \_ is better
00:54:50 <sjanssen> if for example, it's near other functions that actually use the binding
00:55:11 <lispy> hmm
00:55:20 <lispy> why does that make it better?
00:56:17 <sjanssen> uniformity: myfuns = [\x -> x + 1, \x -> x * 2, \_ -> 0]
00:56:55 <lispy> oh, gotcha
00:57:11 <lispy> in my case it's on the else branch
00:57:21 <lispy> if foo then blah opts else \_ -> True
00:57:47 <sjanssen> I'd write const True there
00:58:10 <lispy> I'm tempted to change it...but the maitnainer doesn't seem to like wibbly changes :)
00:58:33 * sjanssen is now curious
00:59:21 <lispy> about what?
00:59:29 <sjanssen> where this code is
00:59:34 <lispy> ah, it's part of darcs
00:59:39 <sjanssen> oh
00:59:53 <lispy> http://darcs.net/src/Darcs/Commands/Changes.lhs
01:00:03 <lispy> about line 170 or so
01:00:09 <lispy> I may have changed my local line numbers a bit
01:00:20 <sjanssen> so what you need to do is write a bunch of substantial patches, then sneak this wibble in your next 'darcs send'
01:00:39 <lispy> I'm doing that actually
01:00:49 <lispy> My current patch is a couple hundred lines...
01:01:08 <lispy> I'd break it up, but it's all related
01:01:28 <lispy> all, right I just changed it :)
01:01:50 <lispy> I've been trying to sneakin dropWhile for our custom list types and that hasn't worked out yet
01:02:16 <lispy> So, everwhere I've seen a need for dropWhile I've refactored and made a local function (copy & paste)
01:02:33 <lispy> So, eventually it will be like, "Oh look, we define dropWhile in 10 places, let's refactor that"
01:02:53 <sjanssen> why do you need to sneak it in?
01:02:54 <dons> hmm.
01:03:07 <lispy> sjanssen: I don't know.
01:03:13 <Apocalisp> sjanssen: Thanks, that looks rather nice.
01:03:28 <lispy> sjanssen: I was given a reason, but I don't understand it, so it's hard to remember it
01:04:16 * lispy is very fond of doing many small refactors
01:04:25 <Apocalisp> I should have seen that the essence of that was fixpoint
01:04:46 <dons> anyone get to haskell.org?
01:04:52 <dons> this sunday downtime thing is weird.
01:05:18 <lispy> dons: it's timing out, looks lie
01:05:26 <dons> hmm
01:05:33 <dons> intertubes suxors.
01:05:55 <sjanssen> is this the firewall thing, or the apache connection limit thing?
01:06:11 <dons> unknown..
01:06:15 <dons> Igloo: ?
01:06:19 <tehgeekmeister> oh, so that's why i can't read the alex documentation...
01:06:55 <dons> it's weird that these outages always happen on sundays
01:07:02 <dons> i wonder if yale does all its network reconfigs on sunday
01:07:08 <dons> yale's been informed.
01:09:59 <Stinger> hmm is there a way to do d <- readFile whatever or similar without ghci printing d?
01:10:20 <tehgeekmeister> does alex fail with a lexical error when the regex's used to build the lexer are non-exhaustive?
01:10:39 <tehgeekmeister> or might there be another cause?
01:10:53 <sjanssen> Stinger: :set -fno-print-bind-result
01:11:30 <Stinger> thanks
01:31:31 <Stinger> hmm anyone running HXT on windows?
01:32:05 <Stinger> actually I'll test something else first
01:32:52 <XOKADO> where I think a channel of sex here?
01:32:54 <XOKADO> :)
01:33:05 <Stinger> ...
01:33:14 <XOKADO> ??
01:33:32 <Stinger> you are in the wrong place
01:34:25 <XOKADO> you know where is the right place?
01:34:29 <XOKADO> Stinger
01:34:40 <ruddel> ouch a F# book just said haskell wasn't suitable for general-purpose programming =O
01:35:02 <dzlk> Ouch!
01:35:04 <dzlk> Why not?
01:35:06 <Japsu> this means war!
01:35:12 <erikc> behaaaaaaaaaaaaaaaave
01:35:47 <ruddel> yes, it's probably not suitable in their eyes because people are still too used to imperative programming
01:36:42 <dons> ruddel: haha
01:36:51 <dons> ruddel: you mean, a blog by jon harrop?
01:37:10 <ruddel> yeah the author of the F# book
01:37:12 <dons> or actually in a book (by jon harrop?)
01:37:16 <ruddel> but i didn't read it from his blog
01:37:21 <ruddel> yeah
01:37:23 <ruddel> actual book
01:37:24 <dons> he actually said that in a book?
01:37:26 <dons> wow.
01:37:28 <dons> what a jerk.
01:37:37 <ruddel> should we kick his ass?
01:37:48 <dons> well, he's a famous spammer of the FP communities
01:37:56 <dons> he's already banned in most lists
01:38:04 <ruddel> wow
01:38:06 <ruddel> i didn't know that
01:38:07 <dons> so that kind of thing is typical.
01:38:43 <ruddel> the F# community seems pretty puny compared to the haskell one, anyway =D
01:38:54 <dons> he wrote a blog article just yesterday saying haskell wasn't suited for real world programming.
01:38:56 <ruddel> in fact, theres only like 2 people in #F#
01:39:00 * stepcut tried to install F# on linux, but failed miserably
01:39:02 <dons> heh
01:39:15 <maltem> Wait, I thought F# was supposed to be a functional language?
01:39:21 <besiria> what is with all those sharp symbols?
01:39:23 <dons> yeah, it's an ocaml variant.
01:39:28 <besiria> it's a trend or sth?
01:39:45 <ruddel> yeah, i think it's C-Sharp but with functional paradigm
01:39:51 <ruddel> hence F-Sharp
01:39:51 <erikc> its ocaml for .net
01:39:56 <dons> nope. it's ocaml, for .net.
01:40:00 <ruddel> oh
01:40:01 <dons> nothing to do with C#.
01:40:04 <ruddel> ahhh
01:40:05 <ruddel> ocaml :)
01:40:10 <ruddel> need to look into that
01:40:18 <erikc> its pretty well designed given the constraints it has work in
01:40:49 <maltem> Funny then that Jon Harrop would reference Haskell in that way :)
01:40:53 <dons> btw, if you want to get a sense for how professional the author of that book is, check out this thread in #ocaml from two days ago,
01:40:56 <dzlk> It's not really source-compatible with o'caml, though. I forget what the differences are but IIRC there are enough that you couldn't expect to port something like Coq easily.
01:40:56 <dons>  http://tunes.org/~nef/logs/ocaml/08.08.14
01:41:00 <dons> jdh30 is harrop.
01:41:03 <erikc> and if you are stuck on .net, it'll be a great option (since it sounds like MS will officially productize it)
01:41:06 <profmakx> Jon Harrop is strange
01:41:16 <profmakx> (and i am being polite here)
01:41:20 <ruddel> hehe
01:41:39 <dons> he's odd. but he has a clear strategy. he presents to the outside world as a professional, advocating for F# (or formerly OCaml).
01:42:03 <dons> while facing the functional programming communities, he cross posts and creates flame wars, to encourage people to look at his stuff
01:42:20 <dons> which is odd, since you'd think his ability to get jobs would rely on the support of the FP community.
01:42:45 <ruddel> that is odd
01:43:11 <dons> so to us he looks like a troll. all very strange.
01:43:17 <ruddel> he seems it
01:43:40 <ruddel> he really has no points in saying haskell isn't a general-purpose programming language
01:43:41 <dons> but i think he likes to be the outsider, to feel he can struggle against an elite, or a cabal.
01:43:47 <ruddel> he just says it and i dont see anything to back it up
01:43:51 <dons> heh
01:44:12 <ruddel> hehe, i see, he has a crusader complex
01:44:38 <dons> well, it's not clear he wants to change things, but he definitely relies on sales and advertising. google placements and so on.
01:44:57 <profmakx> well. trolling _is_ the best way to get attention ;)
01:45:09 <ruddel> hehe
01:45:26 <ruddel> i want to look at a lot of haskell source code
01:45:32 <ruddel> and analyze it
01:45:35 <ruddel> so i can learn =)
01:45:37 <dons> i mean, here, he attempted to troll the haskell community today, with a post concluding that haskell was not suited for real programming, becaues ghc switched to git. http://www.reddit.com/r/programming/comments/6wl85/haskells_virginity/
01:45:39 <lambdabot> Title: Haskell's virginity : programming, http://tinyurl.com/64zscz
01:45:46 <profmakx> ruddel  write code on your own, best way to learn IMHO
01:45:49 <dons> however, so many people know about him now, the credibility is all gone.
01:45:52 <besiria> WARNING: unversioned dependencies are deprecated, and will NOT be accepted by GHC 6.10: base <- what is this
01:46:28 <profmakx> strange when your credibility is gone when people know you ;)
01:46:51 <dons> i just can't see how this strategy can work in the long term.
01:47:02 <dons> it relies on future customers not hearing about his behaviour.
01:47:09 <dons> but on the internet, details like these leak.
01:47:51 <dons> he's not really interested in the FP community as it stands, as a source of sales though. he doesn't blog for it, or attend CUFP or so on.
01:47:56 <ruddel> it would be nice if haskell was taught in public schools, of all ages
01:48:16 <ruddel> i remember in highschool they had pascal, which isn't a bad language but, it would have been sweet to learn functional from the get go =)
01:48:22 <maltem> besiria: It means that some .cabal file needs to be edited if it shall still work when ghc 6.10 comes out
01:48:28 <profmakx> that blog post is hilarious o.o
01:48:43 <dons> ruddel: so you bought his book?
01:48:48 <dons> profmakx: he tries so hard.
01:48:50 <ruddel> of course not
01:48:53 <dons> a phew :)
01:49:04 <ruddel> i ordered 2 Haskell books though
01:49:07 <ruddel> =)
01:49:09 <dons> i'm not actually sure what he does.
01:49:17 <dons> he doesn't work on implementations, and he doesn't release libraries
01:49:23 <ruddel> Haskell School of Expression and Haskell: Crafting in Haskell or something
01:49:26 <dons> he seems to sell books and subscription blog posts
01:49:31 <dons> ruddel: both good.
01:49:39 <dons> i learnt from "Craft of FP"
01:49:45 <ruddel> dons nice
01:49:48 <dons> which i think is your crafting book :)
01:49:51 <ruddel> yes
01:50:00 <ruddel> i still haven't received it
01:50:02 <dons> good for beginner programmers
01:50:05 <ruddel> so i forget the name
01:50:12 <dons> have you done much programming ?
01:50:18 <ruddel> not in functional
01:50:22 <ruddel> but a lot of imperative
01:50:28 <dons> but you're competent in python or c or ?
01:50:36 <ruddel> hmmm, i wouldn't say competent
01:50:41 <ruddel> its a hobby
01:50:46 <dons> oh, programming?
01:50:47 <dons> cool!
01:50:48 <ruddel> yeah
01:51:01 <ruddel> but it would be nice to become a competent functional programmer
01:51:11 <ruddel> in fact, if i learn haskell i will teach my little brother
01:51:18 <ruddel> well, i'm sure i will learn
01:51:25 <dons> if you're into math, you might like "The Haskell Road to Logic, Maths and Programming"
01:51:32 <dons> i think that's also a good "hobby book"
01:51:38 <ruddel> hehe
01:51:48 <ruddel> yeah, i saw it, but i dont have enough monies to buy them all at once
01:51:57 <ruddel> but i want to buy them all =)
01:52:03 <dons> you can also read "real world haskell" online http://www.realworldhaskell.org/blog/
01:52:06 <lambdabot> Title: Real World Haskell
01:52:10 <dons> though its aimed at more advanced programmers
01:52:11 <ruddel> yes, i plan on ordering that one
01:52:21 <dons> that's a lot of books!
01:52:24 <ruddel> yes
01:52:29 <ruddel> muahaha i shall order all books on haskell
01:52:32 <dons> heh
01:52:33 <ruddel> and take over the world
01:52:42 <dons> well, you'll be able to win bar fights.
01:52:49 <maltem> Hey, I even missed Simon Marlow's announcement about the switch to git until now. I'll be curious how it works out
01:52:52 <ruddel> dons, how?
01:52:57 <dons> by hitting people with the books :)
01:53:04 <ruddel> lol
01:53:19 <dons> profmakx: so did you gain any new insights into the harrop mind?
01:54:07 <ruddel> dons, i do have a pdf on the craft, i couldn't wait for it to arrive, i remember trying the code for inverting a horse head macro but its display was crap in hugs98 interactive
01:54:31 <dons> oh, you might want to install ghc
01:54:35 <ruddel> i have that too
01:54:40 <dons> it's a much much better compiler and interpreter.
01:54:44 <dons> and all the libraries work with ghc.
01:55:00 <ruddel> i only installed hugs98 because the book used it, thought there might be some things that wouldn't work in GHC
01:55:13 <dons> oh, that'd be interesting to see. they should be quite compatible.
01:55:20 <dons> hugs is mostly a subset of what ghc provides.
01:57:09 <ruddel> dons, so what stuff have you written in haskell?
01:57:18 <ruddel> this topic is very exciting for me :)
01:57:28 <dons> well, i work at a company that does almost all its stuff in haskell.
01:57:34 <ruddel> wow
01:57:45 <ruddel> what stuff do you develop for the company
01:58:02 <ruddel> full blown applications or research stuff?
01:58:06 <dons> i work on network/server stuff at the moment
01:58:22 <dons> yeah, applications. file systems, servers, OS kernels,
01:58:34 <ruddel> wow
01:58:44 <ruddel> i'd like to see an OS written in Haskell
01:58:59 <profmakx> dons: Only that it has to be a very disturbed one. I cannot really follow the arguments in the blog post.
01:59:36 <dzlk> ruddel: you can. http://programatica.cs.pdx.edu/House
01:59:40 <lambdabot> Title: House
02:00:47 <dons> ruddel: btw, some of the things i've worked on are here, http://code.haskell.org/~dons
02:00:50 <lambdabot> Title: Don Stewart
02:01:08 <dons> probably the best thing to know is that most of the activity in haskell these days is on hackage.haskell.org
02:01:09 <dzlk> profmakx: there were arguments in the blog post?
02:01:13 <dons> that's where all the new libraries are.
02:02:42 <besiria> maltem: ok understood. got it while installing gtk2hs
02:03:10 <dons> profmakx: he's also quite underhand, running a 'fake' haskell blog, http://haskell-news.blogspot.com/
02:03:11 <lambdabot> Title: Haskell News
02:03:36 <ruddel> wow
02:03:37 <profmakx> hm. well i meant his simulated line of argumentation, not arguments
02:03:38 <dons> where the conclusions of each post point to his services
02:03:44 <ruddel> House looks cool
02:03:45 <ruddel> =D
02:04:04 * ruddel sees a bright future for the world of Haskell
02:04:05 <profmakx> yeah. the link list is nice
02:04:17 <profmakx> is house still in development?
02:04:40 <dons> hmm. i think so, yes.
02:04:49 <dons> there's definitely related or spin off projects that are active.
02:05:52 <profmakx> hm. that would be a nice hobby project i would be interested in. as soon as i start my phd studies i hope to have time for such things again
02:18:13 <erikc> heh, harrop reminds me of the trolls in comp.database.theory
02:20:03 <dons> i wonder if there's a correlation between how much we see of him, and how employed he is.
02:23:38 <erikc> it'd be funny if it wasnt for convincing less informed ppl
02:23:56 <erikc> same as the guys selling 'object databases' to fix the 'object-relational' mismatch
02:26:01 <Heffalump> dons: I was wondering that
02:26:11 <Heffalump> has he been trolling more over the weekend?
02:27:54 <dons> it might have just jumped on the ghc/git thing, as a chance to have a stab at us.
02:28:03 <dons> since he's been quiet otherwise.
02:29:06 <dons> interestingly, his wikipedia user history has been deleted.
02:29:15 <dons> i wonder if it was becoming a liability.
02:35:37 <Stinger> hmm HXT doesnt seem to deal with paths with spaces properly at least version 8 on windows
02:40:31 <ndmitchell> @seen dcoutts
02:40:32 <lambdabot> dcoutts is in #haskell, #darcs, #haskell-overflow, #ghc, #gentoo-haskell and #haskell-soc. I don't know when dcoutts last spoke.
02:40:33 <ndmitchell> @seen dcoutts_
02:40:33 <lambdabot> dcoutts_ is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
02:41:34 <tibbe> morning ass
02:41:47 <tibbe> shit
02:41:47 <tibbe> all
02:41:52 <tibbe> morning all!
02:42:28 <dzlk> LOL (literally)
02:42:59 <dzlk> morning. :)
02:43:00 <tibbe> a Freudian slip
02:43:03 <tibbe> :p
02:44:00 <conal> tibbe: morning!
02:44:14 <tibbe> conal: hey! how's life
02:44:15 <tibbe> ?
02:44:29 <conal> tibbe: fun.  i'm spending the summer in belgium (antwerp).
02:44:40 <conal> working on frp stuff.
02:44:44 <tibbe> conal: I heard, Christoph told me
02:44:46 <tibbe> excellent
02:45:14 <conal> yeah.  i like antwerp a lot.  we live in the old city center area.
02:45:24 <conal> tibbe: how's life with you?
02:45:35 <tibbe> good good
02:45:43 <tibbe> will get lots of hacking done this week
02:45:47 <conal> on what?
04:14:44 <tusho> The topic should be: ChannelTopic { topic = "Haskell", blurb = "precision engineering for programmers", description = "The Haskell programming language", website = "http://haskell.org", pasteSite = "http://hpaste.org", logs = "http://tunes.org/~nef/logs/haskell" }
04:14:45 <tusho> :P
04:15:06 <nornagon> for quite a while it was :: [String]
04:15:14 <nornagon> oh
04:15:15 <nornagon> it still is
04:15:19 <nornagon> oops :)
04:15:32 <nornagon> shows how much attention i pay to channel topics :/
04:18:07 <jayaund> Hi, I'm looking for videos about haskell, I've encontered:
04:19:25 <jayaund> http://blip.tv/file/324976
04:19:25 <jayaund> http://es.youtube.com/view_play_list?p=9D558D49CA734A02&page=3
04:19:25 <jayaund> ... other suggests?
04:19:26 <lambdabot> Title: YouTube - Broadcast Yourself.
04:19:26 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
04:20:29 <jeffz> jayaund: http://www.londonhug.net/2007/09/24/better-video-for-games-in-haskell/
04:20:36 <lambdabot> Title: λondon HUG » Blog Archive » Better Video for Games in Haskell, http://tinyurl.com/26m86z
04:20:50 <jayaund> Yes, in youtube I've found http://es.youtube.com/view_play_list?p=9D558D49CA734A02&page=3, and in blip.tv OSCON videos
04:20:51 <lambdabot> Title: YouTube - Broadcast Yourself.
04:20:54 <jayaund> Ok
04:21:09 <jayaund> I'll see
04:21:20 <jeffz> jayaund: http://www.londonhug.net/2008/08/11/video-paradise-a-dsel-for-derivatives-pricing/
04:21:22 <lambdabot> Title: λondon HUG » Blog Archive » Video: Paradise, a DSEL for Derivatives Pricing, http://tinyurl.com/6kmkek
04:22:09 <jeffz> jayaund: they all seem to be listed here http://haskell.org/haskellwiki/Video_presentations
04:22:11 <lambdabot> Title: Video presentations - HaskellWiki
04:22:39 <jayaund> Thanks lambdabot and jeffz
04:22:46 <tusho> nornagon: yeah but [String] is unstructured! :-)
04:24:50 <jayaund> Yes, a lot of material in HaskellWiki Video presentations.
04:57:05 <besiria> Haskell threads are native, right?
04:57:59 <trofi> par?
05:00:55 <rwbarton> besiria: Mostly "no"
05:01:39 <Zao> besiria: forkOS is guaranteed a native thread, forkIO not.
05:02:39 <rwbarton> besiria: Also, you can get a fixed number of native threads with +RTS -N<num>
05:03:12 <besiria> rwbarton: when i use the -threaded and +RTS -N and runtime , i'm getting native threads?
05:03:43 <rwbarton> besiria: Yes.  You're getting the number of native threads you specify on the command-line, not the number of logical threads you create using forkIO.
05:07:10 <trofi> @src par
05:07:10 <lambdabot> Source not found. Do you think like you type?
05:07:17 <besiria> but, in what circumstances should i use forkOS in place of forkIO?
05:07:34 <besiria> or should i never use forkOS?
05:08:03 <nornagon> all code i've seen uses forkIO...
05:11:18 <besiria> well, i'm reading Control.Concurrent doc, with +RTS -N you specify the number of OS threads, and each of these threads gets assigned a green thread (forked with forkIO) , is that right?
05:11:44 <haskellian> @quote SPJ
05:11:44 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
05:11:45 <lambdabot>  what you just said?"
05:12:20 <haskellian> @quote SPJ
05:12:21 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
05:14:15 <igel> besiria: i've once used forkOS in a multithreaded gtk application
05:14:34 <igel> i don't remember why
05:15:07 <igel> probably the gtk-libs block otherwise
05:15:24 <kryptiskt> besiria, use forkOS if you use libs that need to be called from one OS thread. Otherwise, don't
05:16:12 <besiria> igel: well, it must be related to gtk or sth, because it's the first time i see that a forkOS exists.
05:16:24 <besiria> well, i probably should use forkIO only.
05:16:50 <jtraub> Hi!
05:16:55 <igel> kryptiskt: does that mean that forkOS foo guarantees, that foo is executed in one thread while forkIO foo might distribute foo in several threads?
05:17:21 <rwbarton> kryptiskt: Oh, is that what the word "bound" means in the documentation for forkOS?
05:17:36 <jtraub> i try to learn haskell
05:17:43 <jtraub> and i have several problems
05:17:48 <jtraub> i can not solve
05:17:57 <igel> jtraub: go ahead!
05:18:00 <jtraub> can you help me?
05:18:45 <Botje> sure!
05:19:21 <Heffalump> well, we can try :-)
05:19:53 <kryptiskt> igel, yes, that's the purpose of forkOS, a green thread can be scheduled on any underlying thread when run under --threaded
05:20:28 <igel> i see
05:21:18 <haskellian> what do i need to import to use Nothing Just and Maybe?
05:21:40 <rwbarton> haskellian: Nothing
05:21:42 * rwbarton ducks
05:21:47 <igel> so just to prevent me from misunderstanding: "forkIO (a >> b)" might execute a and b in different threads, while "forkOS (a >> b)" doesn't?
05:22:15 <igel> haskellian: they're part of the Prelude, which is imported by default
05:22:34 <igel> some additional helper functions for the Maybe type are in Data.Maybe
05:23:13 <besiria> can any1 give me information about the community server? is it easy to get access there?
05:24:05 <Botje> jtraub: don't get scared now
05:24:08 <Botje> we won't bite you :)
05:24:38 <jtraub> sorry
05:24:43 <jtraub> some connections problems
05:24:45 <kryptiskt> igel. yes, if you use --threaded
05:24:45 <jtraub> Ok.
05:24:58 <jtraub> I am using book by A. Hutton
05:24:58 <igel> ok :)
05:25:10 <jtraub> Programming In Haskell
05:25:25 <kryptiskt> it's -threaded, not --threaded of course
05:25:29 <jtraub> I stopped at chapter about list comprehensions
05:25:44 <igel> kryptiskt: sure
05:25:51 <jtraub> there is an exercise in this chapter
05:26:57 <jtraub> Implementation of merge sort
05:27:10 <jtraub> i implemented merge function from previous exercise
05:27:19 <jtraub> and made halve function from hint
05:27:39 <jtraub> but i really don't know how to make sort function
05:27:52 <Botje> can you put what you already have on hpaste.org ?
05:27:55 <jtraub> let me post whole test of the exercise
05:28:24 <jtraub> Botje, sure
05:28:28 <jtraub> wait a minute
05:28:36 <Botje> i have time :)
05:33:26 <dcoutts> @seen ndmitchel
05:33:27 <lambdabot> I haven't seen ndmitchel.
05:33:41 <dcoutts> @seen ndmitchell
05:33:42 <lambdabot> I saw ndmitchell leaving #haskell-soc, #ghc and #haskell 2h 48m 28s ago, and .
05:34:03 <dcoutts> gwern: you were having a problem with install prefix. did you work out what was wrong?
05:34:14 <jtraub> http://hpaste.org/9709
05:34:48 <jtraub> merge is function from previous exercise(it merges 2 sorted lists into single sorted list)
05:36:29 <Botje> okay
05:36:34 <Botje> do you know the mergesort algorithm?
05:36:40 <jtraub> yep
05:37:04 <Botje> it has three parts: splitting up the list, sorting each part, and merging them back together
05:37:11 <Botje> every call to "sort" is a recursive call
05:37:21 <jtraub> hmm..
05:37:24 <Botje> so your function mergesort
05:37:24 <jtraub> ok..
05:37:27 <Botje> should call halve
05:37:32 <Botje> call mergesort on each
05:37:39 <Botje> and then merge the two results back together
05:37:40 <jtraub> Can i match with list with only one element?
05:37:44 <Botje> yes
05:37:49 <Botje> mergesort [x] = [x]
05:37:53 <jtraub> how can id o it?
05:37:57 <jtraub> ok
05:37:58 <Botje> let me type, man ;)
05:38:07 <jtraub> now i understand it :-)
05:38:15 <jtraub> now i understand it :-))
05:38:25 <jtraub> Let me try to implement it :-)
05:38:32 <Botje> good luck!
05:38:42 <jtraub> thanks
05:39:45 <flw> >Just 10
05:39:57 <flw> > Just 10
05:39:59 <lambdabot>  Just 10
05:45:38 <gwern> dcoutts: yes, I did. turned out cabal was accountably installinh to .cabal, not ~/bin, but a configure fixed it. it was frustrating me since none of my changes were being reflected in the broken installed binary, so I naturally something was broken in one of the libs
05:46:53 <dcoutts> gwern: so what were you changing that was having no effect?
05:46:56 <eu-prleu-peupeu> hello people from planet haskell
05:47:09 <dcoutts> gwern: and do you think Cabal could do something more helpful?
05:47:35 <Zao> gwern: I did that with X11 once. Great fun trying to troubleshoot why xmonad didn't get xinerama :)
05:47:56 <gwern> dcoutts: well, I'm a little mystified how cabal decided to change configuration and why my .cabal/config wasn't forcing it to install to ~/bin
05:49:00 <gwern> Zao: I can imagine; this was particularly bad since I had reason to believe Hint/GHC API were screwing up - they had before. I simply didn't think to suspect cabal until I found that every compiation method resulted in a working binary *except* Setup install
05:50:18 <dmhouse> Wow, the HTTP package is version 3000! It must be *really* advanced!
05:50:32 <opqdonut> http3k
05:50:41 <gwern> dmhouse: it comes with cylong technology
05:50:44 <gwern> *cylon
05:50:57 <ivanm> oh, is that all?
05:50:57 <eu-prleu-peupeu> it can make coffee
05:51:02 <ivanm> no starfleet stuff? :(
05:51:11 <ivanm> eu-prleu-peupeu: sure you don't mean ceylon tea?
05:51:17 <eu-prleu-peupeu> ehehe
06:15:37 <jtraub> Botje, what do you think about http://hpaste.org/9710#a0 ?
06:21:19 <jtraub> did something wrong in http://hpaste.org/9710#a0 ?
06:21:30 <jtraub> I mean that it works
06:22:16 <jtraub> but i want to know if it contains bad or "non-haskell" code
06:22:23 <yitz> hi jtraub
06:22:34 <jtraub> hello yitz
06:22:44 <yitz> jtraub: looks good
06:23:04 <yitz> jtraub: one small point about the Haskell, and one about the algorithm
06:23:50 <yitz> jtraub: your "halve" function is basically the Prelude function "splitAt"
06:24:00 <yitz> > splitAt 3 [1..10]
06:24:03 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
06:24:14 <jtraub> yitz, thanks..
06:24:36 <jtraub> yitz, but i used hint from exercise :-)
06:25:15 <jtraub> Can i ask stupid question?
06:25:27 <yitz> also - you're counting the length of the array over and over again. Maybe you want to count it once and then pass it on (or its halved version) as an extra parameter.
06:25:58 <yitz> jtraub: i ask stupid questions all the time here, so i guess i can't object
06:26:36 <jtraub> does order of naming in where section matter?
06:26:40 <gwern> I am having a persisent file IO problem
06:26:46 <gwern> when I evaluate manually, everything seems just right
06:26:57 <gwern> but when run, the file Just Won't appear in /tmp
06:27:40 <yitz> jtraub: there's a lot of freedom in how to name in a where section. what you did is fine. what did you have in mind?
06:27:54 <Botje> jtraub: sorry, i'm playing slashem :)
06:28:04 <Botje> jtraub: one thing i'd change is using pattern matching
06:28:04 <yitz> hi Botje
06:28:24 <Botje> (splitA, splitB) = halve xs
06:28:28 <gwern> http://hpaste.org/9711
06:28:30 <Botje> a = mergesort splitA
06:28:32 <gwern> <-- problem
06:28:35 <Botje> b = mergesort splitB
06:28:43 <gwern> what should show up is /tmp/TmpModule.hs
06:29:02 <gwern> I am pretty sure it is not a permission problem 0 I can copy manually
06:29:17 <jtraub> I didn't know about this :-)
06:30:08 <yitz> gwern: horrors, why are you doing it that way?
06:30:20 <gwern> yitz: I know no better way?
06:30:24 <Botje> gwern: have you tried strace?
06:30:38 <gwern> strace has never been very helpful
06:30:43 <gwern> but I shall give it a whirl
06:31:07 <jtraub> I was impressed by type inference
06:31:23 <jtraub> because :t mergesort shows me correct types :-)
06:31:54 <gwern> Botje: also, I can't interpret strace output
06:32:24 <yitz> gwern: do canonFile <- makeRelative...; copyFile canonFile ("/tmp/"++canonFile)
06:32:35 <gwern> http://hpaste.org/9711#a1
06:33:42 <matthew-_> hGetBuf does advance the handle suitably right?
06:33:52 <matthew-_> it doesn't leave the handle in the same place does it?
06:33:56 <gwern> yitz: that works, but why doesn't my version?
06:33:59 <gwern> IT COMPILES
06:34:08 <Botje> urgh
06:34:16 <Botje> haskell makes strace _REALLY_ fugly :(
06:34:22 <yitz> almost anything compiles when you use unsafeHorrors#
06:34:37 <yitz> you can cast types, etc.
06:34:53 <gwern> well sure, but the versions minus unsafe worked just as notly
06:35:40 <yitz> gwern: what I wrote doesn't work?
06:35:52 <gwern> yitz: no, your version does
06:35:59 <gwern> but it looks much the same to me
06:36:19 <int-e> gwern: you have main :: IO (IO ())
06:36:34 <gwern> so?
06:36:46 <Heffalump> that's wrong..
06:36:52 <Heffalump> but nothing that a quick join can't fix
06:36:53 <yitz> gwern: yeah, you only want one liftM, not 2
06:37:00 <int-e> gwern: you're producing an IO action (copyFile ...) that is never run, as a result of an IO action (main) that is run.
06:37:03 <trofi> it doesn't seem to do any work at all
06:37:11 <int-e> gwern: it should be no surprise that nothing is happening at all.
06:37:54 <yitz> @type liftM
06:37:55 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:38:44 <int-e> gwern: presumably,  main = copyFile canonfile' =<< liftM ("/tmp/" ++) canonfile  is what you meant.
06:38:58 <yitz> gwern: main = cf >>= liftM (copyFile cf')
06:39:03 <yitz> no
06:39:36 <int-e> (but I agree with yitz that you shouldn't be using unsafePerformIO at all)
06:39:37 <yitz> gwern: main = cf >>= copyFile cf'
06:40:27 <gwern> any cleaner way of saying 'if prt then say $ expr ++ "\n" else return ()' in a do?
06:40:45 <rwbarton> @src when
06:40:45 <lambdabot> when p s = if p then s else return ()
06:40:47 <yitz> gwern: when
06:40:54 <yitz> @type when
06:40:56 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:40:58 <gwern> :t when
06:41:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:41:11 <jtraub> where can i read intro about lambda functions?
06:41:19 <gwern> @hoogle when
06:41:20 <lambdabot> A Hoogle error occurred.
06:41:34 <gwern> Control.Monad, of course
06:44:22 <yitz> jtraub: for using lambdas in Haskell there isn't much to read, it's simple. do you want dive into the lambda calculus, where it all came from?
06:44:45 <trofi> @type (>>>)
06:44:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:44:49 <yitz> to
06:44:57 <jtraub> yitz, yep
06:45:12 <jtraub> yitz, and few examples of lambdas in Haskell
06:45:30 <jtraub> yitz, i know about lambdas from Python
06:45:41 <jtraub> but i want ot see how it looks in Haskell
06:45:45 <yitz> i'm sure that there are great resources at your school. but you can always start with the wikipedia page, it's not too bad
06:45:55 <trofi> > (\x -> x^2 ) 4
06:45:57 <jtraub> and to read some information about bacground
06:45:58 <lambdabot>  16
06:46:28 <yitz> ah ok.
06:46:55 <rwbarton> jtraub: http://worrydream.com/AlligatorEggs/
06:46:57 <yitz> the "\" in trofi's example is a lambda (it is supposed to look like one, kind of)
06:47:04 <lambdabot> Title: Alligator Eggs!
06:47:31 <yitz> jtraub: you do simple pattern matching in a lambda in Haskell:
06:48:08 <jtraub> > (\x,y->x+y) 1 2
06:48:09 <lambdabot>  Parse error at ",y->x..." (column 4)
06:48:14 <yitz> > (\ (x:x':xs) -> (x+x'):xs) [2,5,9,10]
06:48:16 <lambdabot>  [7,9,10]
06:48:20 <int-e> jtraub: no comma
06:48:25 <jtraub> > (\x y->x+y) 1 2
06:48:27 <lambdabot>  3
06:48:36 <jtraub> cool :-)
06:48:48 <Stinger> > (+) 1 2
06:48:50 <lambdabot>  3
06:48:50 <yitz> you can also do
06:49:02 <trofi> @help unpl
06:49:03 <lambdabot> pointful <expr>. Make code pointier.
06:49:14 <trofi> @unpl (+1).(/2)
06:49:15 <lambdabot> (\ e -> (e / 2) + 1)
06:49:31 <trofi> @unpl (*)
06:49:31 <lambdabot> (*)
06:49:43 <int-e> @unpl (.) . (.)
06:49:43 <lambdabot> (\ i b c f -> i (b c f))
06:49:49 <trofi> @unpl *
06:49:50 <lambdabot> (*)
06:50:22 <jtraub> yitz, your example of lambda
06:50:37 <jtraub> yitz, it takse first element of list, secnd element of list
06:50:45 <yitz> @unpl flip ap tail . zipWith
06:50:45 <lambdabot> (\ f -> (zipWith f) >>= \ h -> tail >>= \ g -> return (h g))
06:50:48 <jtraub> sums it annd makes
06:51:10 <jtraub> new list from sum and rest of our original list. Correct?
06:51:12 <yitz> jtraub: yes indeed
06:51:18 <trofi> > (\ (x:x':xs) -> (x+x'):xs) [a,b,c]
06:51:20 <lambdabot>  [a + b,c]
06:52:05 <jtraub> symbolic calculations. Wow
06:52:18 <trofi> :type a
06:52:20 <yitz> jtraub: that's just here, with lambdabo
06:52:23 <yitz> jtraub: that's just here, with lambdabot
06:52:30 <trofi> @type a
06:52:31 <lambdabot> Expr
06:52:40 <trofi> @type aa
06:52:41 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
06:52:45 <trofi> :p
06:53:10 <jtraub> sorry. I'll be back in 5 minutes
06:53:13 <trofi> @go SimpleExpression haskell
06:53:21 <lambdabot> http://kahu.zoot.net.nz/mondrian/doc/mondrian.html
06:53:21 <lambdabot> Title: Introduction to Mondrian
06:56:35 <Stinger> @src runX
06:56:36 <lambdabot> Source not found. You speak an infinite deal of nothing
07:03:01 <dmhouse> Is /usr/local the default place that cabal-install installs to?
07:03:08 <jtraub> hm..
07:03:22 <dcoutts> dmhouse: only if you do --global installs, the defualt is --user installs.
07:03:47 <dmhouse> dcoutts: i.e. to ~/bin, ~/lib etc?
07:03:57 <jtraub> How can i do function composition in haskell?
07:04:06 <dcoutts> dmhouse: the default prefix for --user installs is ~/.cabal
07:04:08 <dmhouse> jtraub: with the . operator
07:04:38 <jtraub> dmhouse, f.g x  will make f(g(x)) call?
07:04:52 <dmhouse> jtraub: almost, (f . g) x will do f(g(x)).
07:05:00 <dmhouse> jtraub: or f (g x), or f $ g x.
07:05:22 <dmhouse> jtraub: f . g x (or f.g x) is parsed as f . (g x), since function application always binds tighter than operators.
07:05:46 <jtraub> dmhouse, ok. Thanks.
07:09:16 <dmhouse> dcoutts: so I'll have to add ~/.cabal/bin to my PATH?
07:09:50 <trofi> i've added
07:09:54 <jtraub> I want to know code of char
07:09:59 <dcoutts> dmhouse: right, or use the dev version of cabal-install which can symlink binaries into ~/bin
07:10:01 <trofi> ord
07:10:08 <trofi> > ord 'Z'
07:10:10 <jtraub> trofi, yep
07:10:10 <lambdabot>  90
07:10:22 <jtraub> trofi, i found it in Haskell Wiki
07:10:23 <jtraub> but..
07:10:27 <dmhouse> dcoutts: wait, there are versions of cabal-install _other_ than the dev version?
07:10:44 <jtraub> Hugs> ord 'a'
07:10:46 <trofi> it's in Data.Char
07:10:51 <jtraub> ERROR - Undefined variable "ord"
07:11:12 <trofi> you may need `import Data.Char'
07:11:17 <jtraub> trofi, hmm.. I am completely newbie
07:11:32 <jtraub> trofi, can you point me in right direction?
07:11:34 <dmhouse> :m Data.Char
07:11:35 <jtraub> oh.. Thanks
07:11:39 <dmhouse> In Hugs, I think.
07:11:44 <dcoutts> dmhouse: there's the released version on hackage. That's the one most people are using. The dev version only has a couple improvements (and has had a few bugs added and removed recently).
07:12:20 <yitz> jtraub: in Hugs you type :load Data.Char
07:12:30 <dmhouse> dcoutts: the page at http://hackage.haskell.org/trac/hackage/wiki/CabalInstall only seemed to link to a darcs repo, so that's what I'm using.
07:12:40 <yitz> jtraub: (what dmhouse wrote is for ghci)
07:12:41 <lambdabot> Title: CabalInstall - Hackage - Trac
07:12:50 <dcoutts> dmhouse: hackell.org/cabal links to the release
07:13:16 <jtraub> yitz, trofi, dmhouse thank you very much
07:14:38 <dmhouse> dcoutts: it does? Where? The link "How to install a Cabal package" on that page goes to http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package, which says "A program to automate this process, called cabal-install, is under development. In the meantime, you'll have to do it manually"
07:14:40 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
07:14:47 <jtraub> I guess : is an operator too
07:15:10 <dcoutts> dmhouse: it links to the download page http://haskell.org/cabal/download.html
07:15:11 <lambdabot> Title: The Haskell Cabal
07:15:23 <trofi> an infix function(constructor)
07:15:28 <trofi> :t (:)
07:15:29 <lambdabot> forall a. a -> [a] -> [a]
07:15:46 <trofi> > (:) 1 [2]
07:15:49 <lambdabot>  [1,2]
07:15:56 <trofi> @type (:) 1
07:15:58 <lambdabot> forall t. (Num t) => [t] -> [t]
07:16:06 <trofi> @type (1:)
07:16:07 <lambdabot> forall t. (Num t) => [t] -> [t]
07:16:12 <trofi> > (1:) [2]
07:16:14 <lambdabot>  [1,2]
07:16:26 <dmhouse> dcoutts: okay, true. Well, at least http://hackage.haskell.org/trac/hackage/wiki/CabalInstall and http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package should be updated, I guess.
07:16:27 <lambdabot> Title: CabalInstall - Hackage - Trac
07:16:54 <trofi> > (8:) 1:[ p ] -- smileys
07:16:56 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
07:17:05 <dcoutts> dmhouse: I'm fixing the cabal-install wiki page
07:17:08 <trofi> > (8:) 1:[ p ] :: [Expr]
07:17:09 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[t]'
07:17:29 <gwern> @seen camio
07:17:29 <lambdabot> camio is in #haskell. I don't know when camio last spoke.
07:17:31 <trofi> > (8:) a:[ p ] :: [Expr]
07:17:31 <gwern> @seen Cale
07:17:32 <lambdabot> I saw Cale leaving #japanese, #haskell-overflow, #ghc and #haskell 16h 40m 47s ago, and .
07:17:32 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[t]'
07:17:39 <dmhouse> dcoutts: great, thanks.
07:17:45 <gwern> preflex: seen Cale
07:17:46 <preflex>  Cale was last seen on #haskell 2 days, 16 hours, 42 minutes and 5 seconds ago, saying: hehehe
07:17:51 <trofi> 've mixed Expr/Int
07:18:41 <dmhouse> dcoutts: so by default will cabal-install (the dev version) create simlinks from ~/.cabal/bin to ~/bin, or is there an option to pass?
07:18:41 <trofi> :t (1) :: Expr
07:18:42 <lambdabot> Expr
07:19:15 <trofi> > let 1 = 2 in 1
07:19:17 <lambdabot>  1
07:19:42 <dmhouse> dcoutts: also, is there any reason to install within $HOME rather than globally?
07:19:49 <trofi> > let 1 = 1 in 1
07:19:51 <lambdabot>  1
07:19:57 <dmhouse> Feel free to point me at a mailing list thread or wiki page if there's some recommended reading.
07:20:35 <gwern> finally
07:20:41 <gwern> I've finally added loading from file to mueval
07:20:53 <gwern> ye deep gods, that took a long time
07:21:47 * gwern really deserves that shower now
07:22:04 <yitz> yay gwern
07:22:07 <yitz> !
07:22:14 <dmhouse> ?where mueval
07:22:14 <lambdabot> I know nothing about mueval.
07:22:19 <dmhouse> ?go mueval
07:22:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
07:22:22 <lambdabot> Title: HackageDB: mueval-0.5.1
07:22:33 <dcoutts> dmhouse: because it "Just Works"tm rather than failing with a permission error.
07:23:05 <dmhouse> dcoutts: ah, right.
07:27:58 <gwern> @tell Cale I've emailed you about mueval and lambdabot
07:27:58 <lambdabot> Consider it noted.
07:28:07 <gwern> the patches are only in darcs, not on hackage yet
07:28:30 <Valodim_> ..is there a way to have if expressions without else in a do block?
07:28:44 <trofi> when
07:29:13 <gwern> ironically, that came up just a little while ago for me as well
07:30:22 <Valodim_> aah
07:30:34 <Valodim_> it's implemented as a function, as I thought. just couldn't find a name :P
07:30:36 <jtraub> Now i stuck with following exercise
07:30:49 <jtraub> Redefine the functions map f and filter p using foldr .
07:31:26 <chrisdone> jtraub:  just look at the types. the rest is cake
07:31:37 <gwern> a very haskelly reply
07:31:42 <Stinger> @ty foldr
07:31:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:31:58 <dmhouse> > runState (do x <- get; when (x == 2) (put 10))
07:32:00 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
07:32:00 <lambdabot>                ...
07:32:02 <dmhouse> > runState (do x <- get; when (x == 2) (put 10)) 1
07:32:04 <lambdabot>  ((),1)
07:32:06 <dmhouse> > runState (do x <- get; when (x == 2) (put 10)) 2
07:32:08 <lambdabot>  ((),10)
07:32:11 <pozic> How can I replace the first occurence of regexp in "afoobarfoofoofoo" by "" where regexp is a regular expression?
07:32:26 <trofi> > foldr f x [a,b,c]
07:32:29 <lambdabot>  f a (f b (f c x))
07:32:37 <dmhouse> pozic: have you looked at Text.Regex? http://haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
07:32:39 <lambdabot> Title: Text.Regex, http://tinyurl.com/2nww8c
07:32:57 <pozic> Or it there nothing built-inf or that in any of the rather complete regex libraries?
07:33:00 <jtraub> hm.. I need to make composition of f and :
07:33:06 <haskellian> is there some isChar or isAlpha in Haskell?
07:33:10 <jtraub> to solve it
07:33:14 <dmhouse> haskellian: yes, both of those exist.
07:33:14 <jtraub> hm...
07:33:17 <trofi> Data.Char
07:33:22 <pozic> dmhouse: yes, I looked at it, but they are quite big libraries.
07:33:23 <dmhouse> haskellian: wait, maybe not isChar. What would it do?
07:33:30 <chrisdone> > isLetter 'λ'
07:33:32 <lambdabot>  True
07:33:34 <dmhouse> haskellian: isChar :: Char -> Bool; isChar = const true?
07:34:14 <dmhouse> pozic: what do you want to do exactly?
07:35:14 <dcoutts> dmhouse: ok updated: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
07:35:16 <lambdabot> Title: CabalInstall - Hackage - Trac
07:35:28 <trofi> > isLetter . chr 1024
07:35:30 <lambdabot>  Couldn't match expected type `f Char' against inferred type `Char'
07:35:41 <pozic> dmhouse: anything followed by a newline followed by a number should be replaced by ""
07:35:47 <dmhouse> dcoutts: looks brilliant.
07:35:55 <pozic> dmhouse: and only the first occurence.
07:35:59 <dmhouse> > isLetter $ chr 1024
07:36:01 <lambdabot>  True
07:36:09 <dmhouse> > isLetter . isChar $ 1024
07:36:10 <lambdabot>   Not in scope: `isChar'
07:36:14 <dmhouse> > isLetter . chr $ 1024
07:36:16 <lambdabot>  True
07:36:19 <dmhouse> > (isLetter . chr) 1024
07:36:21 <lambdabot>  True
07:36:29 <dmhouse> > isLetter (chr 1024)
07:36:31 <lambdabot>  True
07:36:35 <pozic> lambdabot: I can write something myself, but it seems some library function should be able to do it too.
07:36:46 <haskellian> this compiles:
07:36:49 <pozic> dmhouse: that was for you.
07:36:50 <dmhouse> trofi: any of those, but not what you wrote. Yours parses as isLetter . (chr 1024), which fails as chr 1024 isn't a function.
07:37:19 <dmhouse> pozic: so strip numbers at the beginning of lines?
07:37:47 <dmhouse> pozic: unlines . map (dropWhile isDigit) . lines
07:38:02 <pozic> dmhouse: no, you misread.
07:38:21 <pozic> dmhouse: and I don't need code that's not in a library.
07:38:43 <dmhouse> pozic: okay, then what does your first "anything" refer to? A single character?
07:39:11 <pozic> dmhouse: I already found a solution using parsec.
07:39:24 <dmhouse> Wait, the regex libraries are too big but Parsec's fine?
07:39:36 <pozic> Parsec is documented properly.
07:39:38 <jtraub> argh...
07:39:52 <jtraub> i give up :-)
07:40:00 <pozic> Regex has been improved too, but this specific function is simply not implemented.
07:40:00 <haskellian> is there  a builtin for: 'a' in ['a','b','1'], xiny :: char -> [char] -> Bool ?
07:40:21 <haskellian> or a -> [a] -> Bool
07:40:43 <dmhouse> > 'a' `elem` "ab1"
07:40:45 <lambdabot>  True
07:40:54 <dmhouse> ?type elem
07:40:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:41:11 <lilac> @hoogle (Eq a) => a -> [a] -> Bool
07:41:11 <lambdabot> A Hoogle error occurred.
07:41:24 <lilac> ;( no hoogle4 on \b yet?
07:41:45 <chrisdone> lilac: add it yo'self
07:41:50 <dmhouse> pozic: wait, subRegex http://haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html#v%3AsubRegex doesn't do what you awnt?
07:41:56 <lambdabot> Title: Text.Regex, http://tinyurl.com/2nww8c
07:42:10 <dmhouse> The Text.Regex documentation seems reasonable.
07:42:47 <pozic> dmhouse: that replaces every occurence
07:43:37 <jtraub> I made it as newmap f = foldr (\x y -> f x:y) []
07:43:41 <dmhouse> pozic: well add .*$ to your regex
07:44:11 <yitz> jtraub: does it work?
07:44:26 <jtraub> yitz, seems to work :-)
07:44:41 <jtraub> but i am not sure that it was correct solution
07:44:47 <jtraub> thats why i am asking here
07:44:58 <yitz> @check \f xs -> map f xs == foldr (\x y -> f x : y) []
07:45:00 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]       Expected...
07:45:11 <yitz> @check \f xs -> map f xs == foldr (\x y -> f x : y) [] xs
07:45:13 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>                ...
07:46:18 <yitz> jtraub: well. anyway it looks good to me.
07:46:19 <pozic> dmhouse: yeah, that would work too.
07:48:01 <lilac> > foldr (\x y -> f x:y) [1..10]
07:48:03 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
07:48:03 <lambdabot>                ...
07:48:19 <lilac> > foldr (\x y -> f x:y) [] [1..10]
07:48:21 <lambdabot>  Add a type signature
07:48:37 <lilac> > foldr (\x y -> f x:y) [] [1..10] :: [Expr]
07:48:39 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10]
07:50:42 <jtraub> Can i use conditional expressions in lambdas?
07:50:52 <dmhouse> Not guards, but if will work.
07:51:20 <dmhouse> Well, not guards on the arguments. You can use them as part of let or where, of course.
07:51:36 <dmhouse> jtraub: but if the function's getting too complicated, consider putting it in as part of a where clause or something instead.
07:52:16 <LegendaryPenguin> whats the best way to learn haskell? some of the books i looked at really suck
07:52:42 <jtraub> LegendaryPenguin, i tried several books
07:52:44 <Stinger> SoE is the first thing I read, after the gentle introduction, it wasnt bad
07:53:08 <dmhouse> ?where yaht
07:53:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:53:14 <dmhouse> LegendaryPenguin: ^^ is fairly good, and free!
07:53:26 <Stinger> soe = haskell school of expression btw
07:53:36 <Stinger> Paul Hudak (sp?)
07:53:41 <LegendaryPenguin> o
07:55:04 <haskellian> is there a pos :: Char -> String -> Int ?
07:55:19 <dmhouse> ?type findIndex
07:55:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
07:55:36 <dmhouse> > findIndex (== 'a') "123abc"
07:55:38 <lambdabot>  Just 3
07:55:39 <dmhouse> > findIndex (== 'd') "123abc"
07:55:41 <lambdabot>  Nothing
07:55:44 <jtraub> Can you help me with implementation of filter using foldr?
07:55:53 <jtraub> I don't have ideas :-(
07:59:53 <chrisdone> `foldr f k xs' is like give a man some things (xs), and a box (k), and you (f) have asked him to come to you with each item and the box. you go into a room and do something with the box and the item. you might put the item in the box, or do nothing with the box and discard the item. you give the man the box back, and he goes away and comes back, repeating the same process
08:00:26 <chrisdone> a filter implemented in foldr is just like discarding the items into the room that don't satisfy your needs, and putting ones that do into the box
08:00:47 <BONUS> jtraub: start as the empty list as your starting value
08:00:58 <dmhouse> BONUS: he's writing it using foldr.
08:01:08 <BONUS> ah, whoops
08:01:37 <dmhouse> jtraub: use an if statement. The "then" branch should look exactly like map. Think about what to put in the "else" branch.
08:01:57 <dmhouse> (This is how to write the 'f' to foldr, in case you didn't guess.)
08:02:17 <jtraub> dmhouse, the problem is in if statement
08:02:40 <jtraub> dmhouse, i don't knw how to use it because it wasn't referred in the book yet
08:02:58 <jtraub> :-) so i guess i need to make it without if
08:03:07 <dmhouse> jtraub: have you done guards?
08:03:24 <jtraub> dmhouse, yep
08:03:27 <BONUS> solution:  let filter' p = foldr (\x acc -> if p x then x:acc else acc) []
08:03:39 <BONUS> oh, without an if?
08:03:47 <dmhouse> BONUS: don't give it away!
08:03:49 <chrisdone> BONUS: you don't have to solve it for him
08:03:52 <EvilTerran> BONUS, people learn better if you don't give them the answer. geez.
08:04:01 <BONUS> ooh, sorry
08:04:03 <LegendaryPenguin> haha
08:04:04 <BONUS> i put it in black spoiler things
08:04:07 <mar77a> the answer is haskell
08:04:10 <BONUS> :[
08:04:25 <dmhouse> jtraub: you can do it with guards, too. But write the function 'f' separately, not as a lambda.
08:04:29 <BONUS> i kind of trust him not to just read it right away
08:04:34 <dmhouse> BONUS: you put it in what?
08:04:47 <jtraub> dmhouse, thanks. I got it !!!
08:04:55 <BONUS> ah wait you dont see that
08:05:02 <dmhouse> ;)
08:05:05 <BONUS> im on windows right now and in mirc and i used the color things
08:05:11 <BONUS> looks like a black band to me
08:05:25 <chrisdone> BONUS: colours are disabled on this channel due to fascism
08:05:27 <dmhouse> A better solution would have been to hpaste the answer.
08:05:39 <BONUS> ah yes. heil mussolini.
08:06:14 <pozic> dmhouse: Shouldn't this return "world"? subRegex (mkRegex "hello \\(world\\)") "\\1" "hello world"
08:06:35 <pchiusano> hi
08:06:36 <chrisdone> pozic: no backslashes
08:06:37 <dmhouse> jtraub: what's your answer, then? Just to check.
08:06:51 <pozic> chrisdone: then I get lexical errors.
08:06:55 <jtraub> dmhouse, let me test it. I'll post it on hpaste
08:07:01 <dmhouse> jtraub: sure.
08:07:02 <chrisdone> pozic: I mean none at all
08:07:14 <dmhouse> chrisdone: in the regex, that is.
08:07:21 <dmhouse> Obviously you need them for the backreference.
08:07:24 <chrisdone> > Text.Regex.subRegex (Text.Regex.mkRegex "hello (world)" "\\1" "hello world"
08:07:24 <lambdabot> Unbalanced parentheses
08:07:30 <chrisdone> > Text.Regex.subRegex (Text.Regex.mkRegex "hello (world)") "\\1" "hello world"
08:07:31 <lambdabot>   Not in scope: `Text.Regex.mkRegex'
08:07:35 <chrisdone> D:!!!
08:08:22 <pozic> subRegex (mkRegex "hello (world)") "\\1" "hello world" => "\\1"
08:08:29 <dmhouse> Prelude Text.Regex> subRegex (mkRegex "hello (world)") "hello" "\\1"
08:08:29 <dmhouse> "hello"
08:08:48 <chrisdone> yeah, I don't why that argument order is a good idea
08:08:51 <dmhouse> Wait, that's not right. :)
08:08:55 <jtraub> dmhouse, http://hpaste.org/9712
08:09:22 <jtraub> dmhouse, it works on simple tests :-)
08:09:35 <BONUS> yeah thats looks ok
08:09:51 <dmhouse> jtraub: perfect.
08:09:53 <chrisdone> regex -> input -> replacement -> output
08:10:05 <jtraub> dmhouse, thank you
08:10:05 <dmhouse> jtraub: you even got the partial application in there, nice ;)
08:11:48 <lilac> chrisdone: presumably it's to allow extracting the different matches separately, as in `let get n = mkRegex "\((.*)\) \((.*)\)" `subRegex` "(foo) (bar") in (get "\\1", get "\\2")'
08:12:44 <chrisdone> lilac: well, if you want to match on it I'd use matchRegex
08:13:52 <chrisdone> lilac: I know it's useful if you want to produce many strings from one string with different replacements. but I don't think that's more common than applying one replacement to many strings, do you?
08:14:23 <lilac> no. but the current argument order allows optimizations which no other arg order does
08:14:47 <lilac> regex first means that (subRegex r) can cache a representation of the regex
08:14:58 <chrisdone> I'm not talking about the regex first
08:15:01 <BONUS> jtraub: you could also do it like this http://hpaste.org/9712#a1 :]
08:15:04 <lilac> text to match next means that it can cache a representation of the match
08:15:05 <chrisdone> I'm talking about the order of replacement and input string
08:15:55 <jtraub> BONUS, could i do it with where clause?
08:16:00 <BONUS> sure
08:16:26 <jtraub> hm.. What is the defference between let .. in .. and ... where  ... ?
08:16:35 <BONUS> thing is that p is always the same so the helper function doesn't really have to be dependant on p
08:16:39 <lilac> i guess it's a tradeoff. the other order makes use in map much easier, but this order makes optimizing the case of multiple replacements for one match possible...
08:16:49 <BONUS> well, the main thing is that where is shared across guards
08:16:55 <lilac> (or at least the most obvious use in map...)
08:17:09 <BONUS> but let is an expression
08:17:11 <dmhouse> jtraub: for reference, http://hpaste.org/9712#a2 is how it looks with 'if'.
08:17:13 <BONUS> so you can do stuff like
08:17:21 * lilac is never really sure what order to put args in anyway :(
08:17:28 <BONUS> > 3 + (let a = 3; b = 5; in a + b) * 3
08:17:30 <lambdabot>  27
08:17:43 <dmhouse> jtraub: 'let' is an expression, so you can put it anywhere. 'where' is a part of a function defition (more generally, a binding).
08:17:53 <chrisdone> lilac: makes using map easier for who?
08:18:01 <dmhouse> So 'where' shares stuff across guards, for one thing.
08:18:17 <BONUS> me personally, i always use let unless i have to have names that are shared across guards
08:18:31 <EvilTerran> while i prefer to use where wherever i can
08:18:50 <BONUS> just interested - why?
08:18:58 <chrisdone> lilac: regex last means it's only good if you produce many strings from one string and many replacement regexes. input string last means you produce many strings from other strings using one replacement regex. I think the latter is far more common
08:19:29 <EvilTerran> BONUS, because it keeps the expressions i'd reason about equationally closer together
08:19:44 <lilac> chrisdone: regex last would be an odd choice, yes. but i thought we were talking about replacement last versus input last?
08:19:48 <BONUS> ah
08:20:26 <jtraub> Hm..
08:20:26 <chrisdone> EvilTerran: likewise, I like my whole program to read as one big "where ...". not syntactically but structurally, I prefer the high level things first, like `main = foo' \n `foo = ...' and so forth. that way you can see the structure of the program, like looking at a framework, rather than looking at nuts and bolts
08:20:29 <EvilTerran> "foo x = ... y ... where y = ... x ..." - if i'm reasoning equationally, i can just look at the line with the =, and worry about whatever's defined in the where{} clause later
08:20:33 <jtraub> I don't understand task..
08:20:36 <jtraub> http://hpaste.org/9713
08:20:40 <chrisdone> lilac: sorry, s/regex/replacement
08:20:55 <jtraub> Can you show me example of how function should work?
08:21:16 <BONUS> > (uncurry (+)) (3,4)
08:21:18 <lambdabot>  7
08:21:59 <EvilTerran> > uncurry map (f, [x,y,z])
08:22:01 <lambdabot>  Add a type signature
08:22:03 <EvilTerran> > uncurry map (f, [x,y,z]) :: [Expr]
08:22:05 <lambdabot>  [f x,f y,f z]
08:22:30 <lilac> chrisdone: sure, ok. the tradeoff seems to be (common case) partial application given regex and replacement is easier or harder, versus (less common) optimization of matching once for multiple replacements is possible or impossible
08:22:44 <chrisdone> lilac: like “map (myReplace str) ["\\1","foo","bar \\1"]” vs. “map myReplace strs”
08:23:58 <lilac> like "map (\x -> subRegex reg x rep) xs" versus "map (subRegex' reg rep) xs"
08:24:58 <chrisdone> right
08:25:08 <chrisdone> or simply (flip (subRegex reg))
08:25:47 <lilac> sure, if you find that simpler ;-)
08:26:04 <chrisdone> let me paste proper example
08:27:30 <jtraub> BONUS, did i write correct solution http://hpaste.org/9713#a1 ?
08:27:44 <jtraub> ok.. Last exercise before i
08:27:56 <jtraub> i will go to the bed
08:29:27 <BONUS> lets see
08:30:02 <chrisdone> lilac: http://hpaste.org/9714
08:30:21 <BONUS> yup!
08:30:30 <jtraub> BONUS, thanks!
08:30:40 <chrisdone> lilac: which do you think is a more common problem, the one subRegex solves or the one subRegex' solves?
08:31:44 <lilac> chrisdone: well, i'd say example2 is the more likely case (that is, i agree with you). however, subRegex allows optimizations which subRegex' does not.
08:33:40 <lilac> that is, i strongly suspect haskell compilers aren't smart enough to do the matching only once in the case of "let f = subRegex' reg rep in ..."
08:34:09 <lilac> i mean "let f rep = subRegex' reg rep str in ..."
08:36:52 <chrisdone> the matching has to be done multiple times because there are multiple strings to match against
08:37:17 <lilac> not in example1...
08:37:27 <chrisdone> but that's a different problem
08:38:07 <chrisdone> I don't think optimisation has a lot to do with the choice of arg order, it's comparing the speeds of different problems. apples and oranges
08:38:38 <lilac> subRegex' can be defined in terms of subRegex, but not vice versa without losing optimization opportunities. therefore it seems to me that subRegex is more primitive in some sense
08:39:52 <chrisdone> subRegex can be defined in terms of subRegex' with flip
08:40:10 <lilac> "without losing optimization opportunities"
08:40:37 * lilac puts together a test case
08:42:25 <Stinger> hmm is there a builtin to reverse an Ordering value?
08:43:25 <twanvl> "compare EQ" should work
08:43:26 <Heffalump> how did you get the Ordering value?
08:43:29 <int-e> compare EQ
08:43:37 <Heffalump> oh, cunning
08:43:42 <Heffalump> if a bit evil :-)
08:44:11 <Stinger> nice
08:44:15 <pastorn_> <3 <3 Orderings <3 <3
08:44:28 <Heffalump> I was going to say that you could use flip compare instead of compare to generate the Ordering value.
08:47:40 <trofi> @src fmap
08:47:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:47:51 <trofi> @type fmap
08:47:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:48:14 <dmhouse> ?src fmap []
08:48:14 <lambdabot> Source not found. That's something I cannot allow to happen.
08:48:19 <dmhouse> ?src [] fmap
08:48:19 <lambdabot> fmap = map
08:48:24 <dmhouse> ?src Maybe fmap
08:48:24 <lambdabot> fmap _ Nothing       = Nothing
08:48:25 <lambdabot> fmap f (Just a)      = Just (f a)
08:48:25 <dmhouse> etc.
08:48:45 <jtraub> why i can not run http://hpaste.org/9715 ?
08:49:00 <jtraub> chop8' is reimplementation of chop8 with help of unfold
08:49:23 <trofi> @type compareBy
08:49:24 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
08:50:21 <trofi> @type (***)
08:50:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:50:28 <chrisdone> lilac: it would seem that example1 is never likely to have more than a few replacements to do. how many replacemet operations on one string could you want?
08:51:16 <lilac> chrisdone: depends on which RealWorld# you live in, i guess :)
08:51:49 <chrisdone> o_o
08:52:44 <chrisdone> lilac: please provide an example of doing many replacements on one string which is “Real World”
08:52:58 <trofi> @pl \a b -> compare (snd a) (snd b)
08:52:59 <lambdabot> (. snd) . compare . snd
08:53:43 <lilac> chrisdone: please define "Real World" ;-)
08:54:05 <chrisdone> lilac: go off whatever definition you had when you used the word
08:54:14 <sbahra> So how do I get lambdabot to join a channel?
08:54:23 <trofi>  @join
08:54:41 <mux> :t comparing snd
08:54:43 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
08:54:45 <chrisdone> @join never worked for me, I expect you need to be an admin
08:54:45 <lambdabot> Not enough privileges
08:54:46 <sbahra> I don't have those privileges.
08:54:55 <sbahra> mux, :D
08:54:56 <Heffalump> ask Cale
08:55:02 <mux> sbahra: hi
08:55:09 <trofi> @src comparing
08:55:09 <lambdabot> Source not found. Just try something else.
08:55:12 <chrisdone> lilac: did you come up with a testcase?
08:56:26 <lilac> chrisdone: still working on it.
08:56:46 <mux> trofi: comparing = (compare `on`) if that helps
08:57:10 <trofi> mux: comparing is sufficient, thanks!
08:57:42 <trofi> oh, i misread
08:58:35 <haskellian> how can I make this one row: foldl1 (++) $ map upper list
08:58:36 <trofi> @src on
08:58:37 <lambdabot> (*) `on` f = \x y -> f x * f y
08:58:57 <haskellian> sorry, how can I make it in one iteration over the list?
08:59:21 <trofi> place upper into foldl
08:59:41 <trofi> @type foldl1
08:59:43 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
08:59:53 <trofi> @type foldl
08:59:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:00:42 <trofi> > foldl (\res val -> toUpper val:res) ['a'..'z']
09:00:43 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
09:00:44 <lambdabot>                ...
09:01:02 <trofi> > foldl (\res val -> toUpper val:res) [] ['a'..'z']
09:01:04 <lambdabot>  "ZYXWVUTSRQPONMLKJIHGFEDCBA"
09:01:09 <chrisdone> lilac: I get equal times. let me increase my input data
09:02:11 <chrisdone> lilac: http://hpaste.org/9714#a1
09:03:52 <trofi> @kind (->)
09:03:53 <lambdabot> ?? -> ? -> *
09:04:27 <chrisdone> lilac: I really need a program which will run another program repeatedly and time each running and give me an average
09:04:41 <pozic> Can Parsec even do this? do many1 anyChar;newline;string "hi" when running on input string "foobar\nhi" Even when I placed try on every possible location, it still didn't work.
09:06:02 <chrisdone> I found that newline didn't work how I expected it to with Parsec...
09:06:03 <trofi> @type first
09:06:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
09:06:13 <trofi> @unpl first f
09:06:14 <lambdabot> first f
09:07:25 <pozic> chrisdone: using char '\n' makes no difference.
09:07:34 <chrisdone> pozic: yeah, I noticed
09:08:10 <trofi> @type (-<)
09:08:12 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:09:43 <chrisdone> lilac: hm, I figured the length might not be forcing evaluation, so instead I just ran "show $ example(1|2)" and outputted it to /dev/null, but I get the same results both average a second
09:09:46 <trofi> pozic: maybe anyChar -> anyCharExceptNewline?
09:10:30 <lilac> @index intersperse
09:10:30 <lambdabot> Data.List
09:10:32 <chrisdone> lilac: I'll increase the complexity of the regex
09:11:57 * chrisdone looks for an e-mail regex
09:13:00 <chrisdone> that was a joke. I don't have enough HD space to download a whole e-mail regex
09:13:13 <haskellian> how would you check if the stack is growing in Haskell?
09:13:24 <pozic> trofi: the input runs over a few lines, so anyChar could be a newline too.
09:13:51 <chrisdone> haskellian: perhaps GHC profiling
09:16:14 <haskellian> chrisdone: I am not talkign about a haskell program
09:16:21 <trofi> i need parser like this too. never wrote anything meaningful in parsec. let's try
09:16:23 <haskellian> im talkign checking in general on the computer
09:16:56 <Valodim_> is there a way to explicitly use subtraction operator, instead of unary negate?
09:17:53 <Valodim_> never mind
09:21:10 <int-e> pozic: you're really running against parsec's desire not to backtrack. you can use something like   stuff = (newline >> string "hi") <|> (anyChar >> stuff)
09:22:02 <int-e> pozic: wait, that also needs a try. stuff = (try $ newline >> string "hi") <|> (anyChar >> stuff)
09:23:42 <trofi> @type parse
09:23:44 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
09:25:32 <int-e> pozic: ah, manyTill does the job: manyTill anyChar (try $ newline >> string "hi")
09:25:55 <jtraub> is there function to return first element of list in Prelude?
09:25:56 <lilac> chrisdone: i can't get any reliable results. looks like runtime is dominated by GC, and varies by about 50% from run to run ;(
09:25:57 <int-e> @src manyTill
09:25:57 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:26:11 <int-e> jtraub: head
09:26:11 <trofi> @src head
09:26:12 <lambdabot> head (x:_) = x
09:26:12 <lambdabot> head []    = undefined
09:26:44 <lilac> chrisdone: anyway, i'm done playing devil's advocate for the day ;-)
09:29:12 <haskellian> anyone written some advcaned game in hskell?
09:29:51 <pozic> int-e: with lookAhead added it works perfectly.
09:30:12 <MyCatVerbs> haskellian: there's a rough Quake3-like thing on Hackage called "Frag".
09:30:43 <jtraub> thank you all.
09:31:03 <jtraub> Learning Haskell is a real fun
09:31:08 <jtraub> See you tomorrow
09:31:17 <jtraub> Good bye
09:31:27 <BONUS> byez
09:31:30 <BONUS> :]
09:31:48 <Stinger> > sequence . map (putStrLn . show) [1..4]
09:31:49 <lambdabot>  Couldn't match expected type `[m a]' against inferred type `IO ()'
09:32:11 <Stinger> whats goin on there
09:32:17 <trofi> no IO
09:32:24 <trofi> @src sequence
09:32:25 <lambdabot> sequence []     = return []
09:32:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:32:25 <lambdabot> --OR
09:32:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:32:26 <trofi> @src sequence_
09:32:27 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:32:41 <BONUS> @src print
09:32:42 <MyCatVerbs> Stinger: just a precedence problem.
09:32:42 <lambdabot> print x = putStrLn (show x)
09:32:51 <BONUS> fyi :]
09:32:54 <trofi> > [print "hi"]
09:32:57 <lambdabot>  [Exception: "<IO ()>"
09:33:00 <MyCatVerbs> Stinger: you wanted to write sequence . map (putStrLn . show) $ [1..4]
09:33:02 <pozic> int-e: manyTill grabs too much of the input.
09:33:22 <MyCatVerbs> Stinger: alternatively, sequence (map (putStrLn . show) [1..4])
09:33:58 <int-e> mmm
09:34:44 <pozic> int-e: no, that's not it. There's something else going on.
09:34:45 <trofi> @src bracket
09:34:45 <lambdabot> bracket before after thing = block $ do
09:34:45 <lambdabot>     a <- before
09:34:45 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
09:34:45 <lambdabot>     after a
09:34:45 <lambdabot>     return r
09:35:39 <Stinger> ok well I now have (which I changed to put brackets around the map)
09:36:00 <trofi> @help type
09:36:00 <lambdabot> type <expr>. Return the type of a value
09:36:01 <Stinger> let printlist = sequence_ . (map (putStrLn . show)) :: Show a => [a] -> IO ()
09:36:26 <trofi> why do you need (.) ?
09:36:34 <trofi> @type sequence
09:36:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:36:46 <Stinger> but it gives me a type of [()] -> IO ()
09:37:00 <Stinger> this is in ghci though, do I need it in a file to work?
09:37:05 <trofi> sequence . list -> sequence list
09:37:50 <trofi> sorry
09:37:59 <chrisdone> lilac: yeah. all in all, though, I think subRegex' should be defined somewhere
09:38:36 <chrisdone> lilac: it's annoying to (and I've done this often enough for it to be annoying) write flip (subRegex ...)
09:41:37 <MyCatVerbs> Stinger: oh, you got hit by the monomorphism restriction.
09:42:18 <Stinger> yeah wait for H` I know :P
09:42:30 <Stinger> any more news on that recently? :)
09:42:30 <MyCatVerbs> Stinger: if you try giving it in-place (let printList l = sequence_ (map (putStrLn . show) l) in getLine >>= printList, it'll work fine.
09:43:36 <Stinger> I put it in my file, I just didnt want to cause I was mucking around in my emacs ghci session with some data I didnt feel like redoing
09:43:42 <MyCatVerbs> Stinger: if you check the inferred type, it should be (Show a) => [a] -> IO (), aye? But if you define it then check the type, it defaults the (Show a) => a in there to ().
09:43:56 <esteth> Hey all. I'm wanting to represent a board game grid in haskell. I'm wondering what kind of type would be the most appropriate. My first thought, from an imperative background, is to go for [[SomeTypeRepresentingWhatsOnTheSquare]], but I'm not sure if some kind of matrix type would be better
09:44:06 <Stinger> yeah thats what I was getting
09:44:11 <MyCatVerbs> Stinger: either :set -fno-monomorphism-restriction, or put it in the file and give a type declaration.
09:44:33 <Stinger> yeah I did the latter, thanks
09:47:26 <esteth> Actually, I think I'm going to go with a tuple-of-tuples, but I'd love to know if there's a more elegent way of defining a 7x6 tuple-of-tuples than ((Player,Player,Player,Player,Player,Player),(Player .... ))
09:49:02 <Heffalump> well, you could define a type synonym for the nested tuple
09:49:07 <Heffalump> but IMO that way lies madness
09:49:19 <Heffalump> you'll have to enumerate stuff everytime you pattern match, for example
09:49:45 <int-e> use Data.Array for sanity
09:49:48 <esteth> Heffalump, Ah, good point.
09:50:18 <int-e> (or maybe just [[Player]] if its fast enough)
09:51:33 <pozic> int-e: http://paste.debian.net/14980/ This only parses the first two numbers and returns no failure. Why would it ever do that?
09:51:44 <esteth> int-e, Thanks for the suggestions. I'll take a look at Data.Array. My primary reason to be using tuples was because of the Zip functions, which I think I'm going to be using a fair amount, and I reckon a list -> tuple conversion will be slow. I may be horribly mistaken though
09:51:47 <explicitjelly> okay
09:51:53 <explicitjelly> I have a data type with lots of constructors
09:52:07 <explicitjelly> tree-like
09:52:33 <explicitjelly> because constructors often have at least one instance of the data type as arguments
09:52:40 <explicitjelly> (by the way, do you say arguments?)
09:53:19 <explicitjelly> now, sometimes, I want to traverse that tree and do something to specific nodes.
09:54:38 <explicitjelly> but if there's, say, only one interesting type of node where I want to do something special, I still have to explicitly write out function definitions which match constructors that contain instances of that data type, to traverse it
09:54:53 <explicitjelly> and that's getting tedious.
09:55:09 <explicitjelly> any idea?
09:56:10 <explicitjelly> I can write a quick code example if that wasn't clear enough.
09:56:49 <explicitjelly> basically I'm searching for a compact and beautiful way to apply a function to specific nodes of a tree-like structure
09:56:53 <ToRA> have a look at Data & Typeable
09:57:20 <int-e> pozic: let me guess,  spaced (string "...") matches "\n..."
09:57:46 <int-e> pozic: try (try (spaced (char ','))) in floatsRow
09:57:46 <explicitjelly> "The Typeable class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation."
09:57:56 <explicitjelly> ToRA, hmm. I don't understand? how can that help?
09:58:01 <ddarius> explicitjelly: There are a variety of ways to solve that problem.  Three main ones are Scrap Your Boilerplate, Uniplate, and Compos.
09:58:20 <explicitjelly> ddarius, intriguing. I will look into it.
09:58:48 <ddarius> explicitjelly: The Scrap Your Boilerplate method uses Data and Typeable and Uniplate has a compatibility mode with SYB as well.
09:59:34 <explicitjelly> ddarius, do you have any recommendation?
10:00:01 <int-e> pozic: eh no, it must be the haskell token parser actually.
10:00:33 <explicitjelly> "Using this approach, you can write generic functions such as traversal schemes (e.g., everywhere and everything), as well as generic read, generic show and generic equality (i.e., gread, gshow, and geq)."
10:00:41 <explicitjelly> mhm. sounds like what I want.
10:01:04 <int-e> pozic: in any case what happens is that the floatsRow already consumes the '\n' character, so floatsRows has nothing to match and stops parsing after the first row.
10:01:15 <quicksilver> explicitjelly: uniplate is a simler API
10:01:40 <BONUS> when i do :k (->), why does it show ?? -> ? -> * instead of * -> * -> *
10:01:41 <quicksilver> but less capable in the sense that it's operations center around a single 'leaf type' at a time.
10:01:56 <quicksilver> ?? and ? are special GHC kinds
10:01:56 <lambdabot> Plugin `compose' failed with: Unknown command: ""
10:02:04 <quicksilver> to do with unboxing
10:02:29 <BONUS> ah
10:03:30 <ddarius> explicitjelly: Uniplate is the simplest and most efficient in my opinion, but SYB is more powerful.  I don't know much about Compos.
10:04:13 <explicitjelly> I'm just reading about SYB
10:06:19 <quicksilver> make sure you read the right stuff. There were 3 papers about it and only one corresponds to the library with your GHC :)
10:06:37 <explicitjelly> SYB is really intriguing
10:06:51 <ToRA> > everywhere (mkT (succ :: Int -> Int)) [Just [(1 :: Int),2,3], Nothing]
10:06:53 <lambdabot>  [Just [2,3,4],Nothing]
10:06:54 <eu-prleu-peupeu> im having a stress, can someone help me please: http://hpaste.org/9716
10:06:56 <explicitjelly> yap
10:07:19 <explicitjelly> I wonder how SYB works.
10:07:35 <ddarius> It's all explained in the papers.
10:07:37 <explicitjelly> I suppose I could just read the papers :)
10:07:51 <b4taylor> SYB? Link?
10:07:56 <explicitjelly> http://www.cs.vu.nl/boilerplate/
10:07:57 <b4taylor> Google fails me.
10:07:58 <lambdabot> Title: Scrap your boilerplate ... in Haskell
10:08:01 <explicitjelly> that's what I'm reading right now
10:08:54 <Stinger> ah good, Data.on exists
10:09:09 <BONUS> eu-prleu-peupeu: you cant add together two different types that are both instances of Num
10:09:20 <BONUS> try doing addScalar :: (Num a) => vec a -> a -> vec a
10:09:27 <ddarius> @where syb
10:09:27 <lambdabot> http://www.cs.vu.nl/boilerplate
10:09:59 <eu-prleu-peupeu> BONUS: it works! thanks for the magic tip :D
10:10:04 <BONUS> hehe np :)
10:10:43 <BONUS> (+) is (Num a) => a -> a -> a
10:10:58 <BONUS> that's why you can't have vec a -> b -> vec a
10:10:59 <eu-prleu-peupeu> :)
10:11:14 <eu-prleu-peupeu> i would have made Vector an instance of Num, but i dont know how i would define "signum" then :/
10:11:25 <eu-prleu-peupeu> and fromInteger :P
10:11:41 <Deewiant> yes, Num is somewhat bloated :-/
10:11:56 <BONUS> im not sure if mathematically it makes sense that a Vector is an instance of Num
10:12:07 <eu-prleu-peupeu> heheh true
10:12:21 <eu-prleu-peupeu> but, it would be very nice to be able to use the (+) and (-) operations on Vectors
10:13:04 <bos> Num is well known to be inconvenient for many (most) kinds of mathematical object.
10:13:24 <bos> see http://www.haskell.org/haskellwiki/Numeric_Prelude
10:13:26 <lambdabot> Title: Numeric Prelude - HaskellWiki
10:13:27 <BONUS> you can define a function like .+ and .- or something
10:13:32 <explicitjelly> depends on what a data type must satisfy to be an instance of Num. for example, matrix multiplication isn't commutative... does Num imply commutative multiplication?
10:13:47 <eu-prleu-peupeu> oh well, no stress, i wouldn't be able to use + and - if i were to use C :)
10:13:56 <eu-prleu-peupeu> so add, and sub will work fine heheh
10:14:38 <ddarius> explicitjelly: No.
10:14:55 <explicitjelly> SYB is really exactly what I need
10:14:59 <explicitjelly> and the paper starts out interesting.
10:15:02 <explicitjelly> thanks a lot.
10:15:15 <explicitjelly> I thought I was missing something obvious...
10:15:53 <ddarius> explicitjelly: SYB has issues that Uniplate avoids, so if Uniplate can do what you want, I'd recommend that.
10:16:17 <explicitjelly> ddarius, thanks. but right now, I'm reading the paper about SYB to see what I'm dealing with
10:16:26 <explicitjelly> ddarius, afterwards, I'll check out Uniplate to see what's different %)
10:16:46 <bos> i wish there was a more active generic programming community. almost nobody understands or uses SYB or its offshoots.
10:18:04 <bos> i'd sneak in a final chapter about SYB for the book, only i've never used it and reading the haddocks doesn't help one bit.
10:18:06 <ddarius> bos: For small things people tend not to use them, but my impression is people do use them when they are dealing with large data structures.
10:18:12 <esteth> ghc is telling me this type signiture is invalid. Anyone know why? listToTuple6 :: [a] -> (a,a,a,a,a,a)
10:18:18 <ddarius> bos: Uniplate is simpler.
10:18:20 <bos> ddarius: yes, i've noticed that too.
10:18:42 <EvilTerran> esteth, what's the error?
10:19:00 <rwbarton> esteth: It's probably telling you your definition doesn't match that signature
10:19:03 <bos> ddarius: does uniplate sacrifice anything for its simplicity?
10:19:14 <esteth> EvilTerran: Invalid type signiture on the line of the definition of the function
10:19:14 <rwbarton> > let listToTuple6 = undefined in listToTuple6 :: [a] -> (a,a,a,a,a,a)
10:19:16 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
10:19:16 <lambdabot>                ...
10:19:41 <ddarius> bos: Yes, but it the most important things.
10:19:46 <esteth> "listToTuple6 x1:x2:x3:x4:x5:x6:[] :: (x1,x2,x3,x4,x5,x6)" is the function itself
10:19:52 <explicitjelly> I'm writing a little compiler here, and I'm mangling the intermediate stage languages a lot, so I absolutely need some scheme to avoid boilerplate code
10:20:00 <EvilTerran> esteth, er...
10:20:03 <ddarius> bos: Also, it would be perfectly possible to explain how Uniplate works in a book like RWH.
10:20:08 <rwbarton> esteth: *That*'s an invalid type declaration (you don't mean ::)
10:20:21 <EvilTerran> esteth, i think you mean ::, not =
10:20:24 <EvilTerran> er, =, not ::
10:20:37 <EvilTerran> listToTuple6 (x1:x2:x3:x4:x5:x6:[]) = (x1,x2,x3,x4,x5,x6)
10:20:38 <esteth> EvilTerran / rwbarton: Ah, I feel silly. Thanks :)
10:20:39 <EvilTerran> or even
10:20:45 <explicitjelly> for example, right now I want to do lamba lifting. this affects *only* the lambda notes in the expression tree of the particular immediate language I'm using here, and writing all that boilerplate code again is stupid
10:20:48 <bos> ddarius: interesting.
10:20:49 <EvilTerran> listToTuple6 [x1,x2,x3,x4,x5,x6] = (x1,x2,x3,x4,x5,x6)
10:20:51 <trofi> are parens optional?
10:20:54 <explicitjelly> -notes+nodes
10:21:00 <EvilTerran> trofi, not that pair, no
10:21:14 <EvilTerran> trofi, you were writing (listToTuple6 x1):x2:...
10:21:22 <EvilTerran> er, esteth was
10:21:23 <bos> ddarius: i have about 8 hours within which to learn uniplate and write about it.
10:21:41 <ddarius> bos: That's doable.
10:21:48 <ddarius> Well, the learning.
10:21:52 <bos> ddarius: yeah, i think i'll give it a try.
10:22:09 <explicitjelly> bos, you're writing a Haskell book?
10:22:13 <bos> STM was supposed to be my last chapter, but it's so simple that there's not much to say.
10:22:17 <bos> explicitjelly: yes.
10:22:24 <explicitjelly> bos, nice. what's its scope?
10:22:34 <EvilTerran> trofi, the parens around a tuple are part of the tuple syntax, but, aside from those (and a couple of similar cases), you only need them for grouping expressions when the unparenthesised version is wrong
10:22:39 <bos> explicitjelly: http://book.realworldhaskell.org/
10:22:40 <lambdabot> Title: Real World Haskell
10:22:43 <ddarius> bos: Some kind of boilerplate removal chapter doesn't sound like a bad idea.
10:22:58 <explicitjelly> bos, oooh. I want that.
10:23:17 <bos> ddarius: right.
10:23:19 <explicitjelly> bos, yes. Looking at the table of contents, I definitely want that.
10:23:38 <explicitjelly> bos, and I agree, some boilerplate removal hints would be helpful
10:23:41 <bos> explicitjelly: you can preorder it - go to http://www.realworldhaskell.org/ for links.
10:23:41 <trofi> EvilTerran: i meant list deconstructor in first function definition: f a:[] vs. f (a:[])
10:23:43 <lambdabot> Title: Real World Haskell
10:23:50 <TomMD> The FFI chapter still isn't up?  I've been looking forward to that one.
10:24:03 <FordCortina> can anybody tell me why this typechecks? http://hpaste.org/9717#a1
10:24:07 <EvilTerran> trofi, that one is necessary, yes
10:24:17 <EvilTerran> trofi, because the unparenthesised version means (f a):[]
10:24:28 <trofi> ah, i see
10:24:54 * trofi constantly messes op precedence
10:24:57 <EvilTerran> function application always binds tighter than any infix operator
10:25:15 <rwbarton> FordCortina: Why should it be any less valid than   data Bar ; x :: Bar ; x = x
10:25:35 <haskellian> can you do this with one function? http://hpaste.org/9718
10:26:29 <FordCortina> rwbarton: because there is no constructor with signature (Foo Int)?
10:26:31 <EvilTerran> haskellian, yes
10:27:02 <trofi> good examples
10:27:17 <rwbarton> FordCortina: Right, that just means there are no non-bottom *values* of Foo Int, but the type Foo Int still exists
10:27:23 <haskellian> evil: how?
10:27:42 <EvilTerran> haskellian, well, you need to find some kind of recursive step that doesn't need that extra parameter
10:27:42 <FordCortina> rwbarton: aha, i think i see what you mean
10:27:52 <rwbarton> FordCortina: a better example would have been    data Bar a ; x :: Bar Int ; x = x
10:28:08 <FordCortina> rwbarton: which is why bar = undefined is also valid
10:28:20 <eu-prleu-peupeu> when is the haskell report going to be reviewed again ?
10:28:25 <Stinger> haskellian, have you considered findIndex?
10:28:35 <rwbarton> FordCortina: I don't find this behavior surprising, but I'm also not surprised that someone could find it surprising. :)
10:28:46 <bos> eu-prleu-peupeu: that's been underway for years.
10:28:57 <EvilTerran> haskellian, consider: pos c (x:xs) | (c == x) = baseCase | otherwise = recursiveStep (pos c xs)
10:29:08 <EvilTerran> haskellian, can you give suitable definitions of "baseCase" and "recursiveStep"?
10:29:48 <Stinger> ok sleep time, bye all
10:29:48 <FordCortina> rwbarton: well i dont find myself thinking about bottoms very often....
10:29:56 <eu-prleu-peupeu> hasta Stinger
10:30:06 <FordCortina> :D
10:30:43 <FordCortina> sorry that one must have been done to death here....
10:33:59 <FordCortina> is there a way to assert at the type level that a type has more values than just "bottom"?
10:37:59 <bos> FordCortina: i think so, but it would require some substantial type hackery. that's the sort of thing oleg might have done.
10:38:28 <bos> in general, if you can think of something that sounds wildly improbably or impossible to do with types, oleg has already done it.
10:38:50 <chessguy_> i bet he hasn't written a chess engine in the type system
10:39:00 <bos> that's merely a lot of work.
10:39:39 <flux> how about a type-system that recognizes standard-complying C-programs..
10:40:08 <FordCortina> _chessguy: lol
10:40:13 <pozic> int-e: yes, I I thought spaced did something else :(. Thanks for the fresh perspective.
10:41:03 <explicitjelly> bos, thanks, I just preordered
10:41:19 <explicitjelly> bos, 58$ with shipping, that's only 39EUR
10:41:28 <explicitjelly> probably well worth it.
10:41:43 <explicitjelly> I like shopping in the US, even with shipping it's cheap
10:41:55 <bos> explicitjelly: heh, i think it's EU39 from amazon.de, too.
10:42:46 <explicitjelly> bos, didn't check if I could preorder at amazon.de
10:43:05 <bos> explicitjelly: yes, i just don't have a link up to it yet.
10:43:42 <explicitjelly> well, it doesn't really matter to me, now %)
10:44:33 <twifkak> hey, haskellers. question.
10:45:33 <twifkak> what do you recommend for a data persistence library? (including but not limited to sql libraries)
10:45:48 <bos> @where binary
10:45:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
10:46:54 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
10:47:06 <lambdabot> Title: HackageDB: binary-0.4.2
10:47:49 <newsham> unfort the built-in List marshalling will blow the stack for large lists. :(
10:47:56 <twifkak> oh, thanks :) i'm looking for some indexing ability, too. essentially items with tags. what would be three tables in an RDBMS.
10:48:10 <newsham> there are bindings for databases
10:48:22 <newsham> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Database
10:48:22 <twifkak> i mean, i suppose i could write 'cdb' on my own...
10:48:24 <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f
10:49:01 <twifkak> yeah, didn't know if you had a recommendation, there. HaskellDB looks nice, but unmaintained.
10:49:38 <bos> if you want a database interface, there are sqlite bindings, and more generically, HDBC.
10:50:39 <twifkak> i'm open to new interfaces. actually, i'd prefer not writing sql.
10:51:01 <newsham> perhaps also HAppS' store?  i havent looked much into it yet.
10:51:16 <marcot> Why does GHC depends on perl?
10:51:31 <Zao> marcot: The Evil Mangler is in Perl.
10:51:31 <twifkak> newsham: btw, what would you recommend to fix the List marshalling in binary?
10:51:49 <eu-prleu-peupeu> marcot: because in the end, it all comes down to that perl onliner
10:51:57 <Zao> marcot: http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
10:51:57 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
10:51:58 <newsham> twifkak: i'm using this:  http://www.thenewsh.com/%7Enewsham/store/test10.hs
10:52:14 <newsham> which seems to work better for big lists, but I think might still have problems with really-really big lists
10:52:15 <gwern> wonder when the mangler will finally be scrapped
10:52:20 <gwern> it's a little embarassing
10:52:27 <newsham> I am not sure why, I asked on haskell-cafe and havent gotten any feedback
10:52:35 <ddarius> gwern: It's on its way out.
10:52:54 <twifkak> sweet. i will only need it for moderately big lists.
10:53:03 <marcot> Thanks.
10:53:21 <newsham> (could be perhaps my test case causing problems and not the marshaller?)
10:55:54 <twifkak> i probably can't help you there. :) i'll have to compare this to the built-in serializer to follow.
10:56:14 <newsham> the built-in serializes length followed by the elements.
10:56:23 <twifkak> ah.
10:58:27 <twifkak> btw, can I ask what license this is under? :)
10:58:58 <newsham> public domain.. free code.  eat all you want.
10:59:09 <twifkak> thanks :)
10:59:12 <newsham> also everything else in that dir
11:01:03 * ddarius eats ..
11:01:06 <profmakx> ok. people i just learned about misra. i am officially shocked.
11:02:19 <monochrom> Misra is cool. :)
11:02:32 <monochrom> Oh wait, what do you mean?
11:02:57 <esteth> The motor industry software reliability association? Or am I missing something obvious
11:03:47 <profmakx> http://en.wikipedia.org/wiki/MISRA_C <- this
11:03:49 <lambdabot> Title: MISRA C - Wikipedia, the free encyclopedia
11:04:55 <monochrom> Nevermind. I thought Jay Misra.
11:05:37 <newsham> misrable c
11:06:25 <profmakx> heh
11:07:17 <psyklops> When you want if-then-elseif-else, is there a better way than sticking an 'if' into the first if's else?
11:07:36 <gwern> guards? cases?
11:07:39 <Wild_Cat> psyklops: case, maybe
11:07:43 <haskellian> well I could reverse the list first but that still means another function
11:07:59 <psyklops> Mmm.. case.. yes
11:08:24 <twifkak> i'd add where foo | cond1 = blah; | cond2 = blah
11:08:39 <newsham> func x | ifcond = ...;  | elseifcond = ....;  | otherwise = ...;   ?
11:08:49 <trofi> @src otherwise
11:08:50 <lambdabot> otherwise = True
11:09:08 <newsham> haskellian: "functional" programming, you should have lots of "another function"s
11:09:14 <explicitjelly> @t concatMap
11:09:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:09:20 <chessguy> @thx
11:09:21 <lambdabot> you are welcome
11:09:27 <explicitjelly> :t concatMap
11:09:28 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:09:30 <trofi> :t or @type
11:10:06 <Wild_Cat> hrmm. Haskell doesn't seem to support trailing commas in lists. Hulk smash Haskell syntax. :(
11:10:08 <haskellian> posin char (x:xs)
11:10:08 <haskellian>        | char /= x = posin char xs
11:10:08 <haskellian>        | otherwise = length xs
11:10:12 <explicitjelly> another instance of "why didn't I know that earlier, I've been using that pattern all the time"!
11:10:25 <haskellian> how can I add reverse to the argument the first time?
11:12:07 <int-e> haskellian: define a helper function.
11:12:41 <int-e> > length . dropWhile (/= ' ') . reverse $ "abc def ghi" -- or use predefined list functions
11:12:43 <lambdabot>  8
11:13:07 <int-e> (off by one)
11:13:29 <esteth> hm. Is there some kind of function in the standard library that lets me go over a list and putStrLn each item? I think I could use foldl, maybe, but it doesn't seem like the kind of task foldl was made for
11:13:50 <int-e> esteth: mapM_ putStrLn list
11:13:59 <int-e> (mapM_ is defined in Control.Monad)
11:14:08 <Olathe> > dropWhile (/= ' ') . reverse $ "abc def ghi"
11:14:10 <lambdabot>  " fed cba"
11:14:28 <esteth> int-e: Thanks, that's perfect :)
11:17:17 <haskellian> where is unionsWith ? not in Data.List...
11:17:26 <int-e> Data.Map?
11:17:31 <int-e> @index unionsWith
11:17:31 <lambdabot> Data.IntMap, Data.Map
11:18:18 <haskellian> int-e i already had a helper, i wanted to get rid of it, thanks for the dropWhile-func though, nice one
11:19:43 <chrisdone> hi
11:20:35 <esteth> hm. MapM_ is complaining that putStrLn is String -> IO () instead of String -> [b]. But the definition of mapM_ makes it look pretty clear that putStrLn should fit
11:21:32 <explicitjelly> esteth, wrongly paranthesized?
11:21:46 <haskellian> hwo do I use it?
11:21:49 <trofi> > mapM return "hello"
11:21:49 <rwbarton> :t mapM_ putStrLn ["foo", "bar", "baz"]
11:21:51 <lambdabot> IO ()
11:21:52 <lambdabot>   add an instance declaration for (Show (m [Char]))
11:21:52 <haskellian> don't ge tit
11:22:07 <esteth> explicitjelly, Ah, you're right. I have a show where i shouldn't :)
11:22:30 <trofi> > mapM (\x -> [x]) "hello"
11:22:33 <lambdabot>  ["hello"]
11:22:46 <trofi> > mapM (\x -> [[x]]) "hello"
11:22:48 <lambdabot>  [["h","e","l","l","o"]]
11:23:39 <explicitjelly> esteth, often that :)
11:28:56 <newsham> ?type putStrLn . unlines
11:28:57 <lambdabot> [String] -> IO ()
11:30:39 <trofi> why not [Char] -> IO () ?
11:30:46 <newsham> ?type putStrLn
11:30:48 <lambdabot> String -> IO ()
11:30:53 <newsham> that's [Char] -> IO ()
11:30:54 <trofi> oh
11:31:03 <trofi> yes
11:33:10 <int-e> s
11:54:46 <noohgodno> > map (2**) [1..1000]
11:54:48 <lambdabot>  [2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0,512.0,1024.0,2048.0,4096.0,8192.0,16...
11:55:03 <noohgodno> > product(map (2**) [1..1000])
11:55:05 <lambdabot>  Infinity
11:55:11 <noohgodno> yay
11:55:37 <noohgodno> that's not even
11:55:39 <noohgodno> remotely right
11:55:48 <ziman> > sum . map (2**) $ [1..1000]
11:55:50 <lambdabot>  2.1430172143725347e301
11:56:07 <ziman> noohgodno, :D
11:56:25 <noohgodno> > product . map (2**) $ [1...1024]
11:56:27 <lambdabot>   Not in scope: `...'
11:56:30 <noohgodno> > product . map (2**) $ [1..1024]
11:56:32 <lambdabot>  Infinity
11:56:36 <noohgodno> gfy lambdabot
11:56:47 <sbahra> noohgodno, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Decimal
11:56:49 <lambdabot> Title: HackageDB: Decimal-0.1.0, http://tinyurl.com/5sdyzl
11:56:51 <hcube> hi! do you know any haskell or functional language compiler what support parallel execution. i mean parallel lambda expression reduction. this also known as virtual reduction.
11:57:36 <sbahra> > product $ map (2 ^) [1 .. 1000]
11:57:39 <lambdabot>  3257090475636636231524401551165512008571467652285541123963226386542150446658...
11:58:08 <trofi> > 1 %3
11:58:10 <lambdabot>  1%3
11:58:22 <noohgodno> (it's 1)
11:58:24 <noohgodno> or -1
11:58:56 <noohgodno> > product (map(sin(2 ^)) $ [1..1000])
11:58:58 <lambdabot>   add an instance declaration for (Floating (b -> a))
11:59:29 <sbahra> :t sin
11:59:30 <lambdabot> forall a. (Floating a) => a -> a
11:59:47 <ziman> noohgodno, it's not 1
11:59:53 <int-e> > product (map(sin . (2 ^)) $ [1..1000])
11:59:55 <lambdabot>  0.0
12:00:16 <ziman> > sum . map ((2**) . negate) $ [1..1000]
12:00:19 <lambdabot>  1.0
12:00:41 <yitz> hcube: haskell will do that, but of course you have to give it a hint where to parallelize. That is what the par function is for.
12:00:46 <dons_> araujo: well done! http://www.reddit.com/comments/6wpke/himerge_using_haskell_in_applications_for_the/
12:00:48 <lambdabot> Title: Himerge: using Haskell in applications for the masses : reddit.com, http://tinyurl.com/6bxmfx
12:01:10 <dons_> hcube: yea, we use the `par` annotation to describe where parallelism is to be found.
12:01:56 <sbahra> cool
12:02:01 <sbahra> himerge seems pretty
12:02:13 <chrisdone> I want to write an irc bot
12:02:30 <dons> ?go roll your own irc bot
12:02:32 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:02:32 <chrisdone> how are all the cool kids re-loading updated bot code? just restarting the whole process?
12:02:32 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
12:02:35 <andyjgill> I've got a question, dons. It there a way of asking how many cores I have to play with, from inside a GHC process?
12:02:35 <lambdabot> andyjgill: You have 1 new message. '/msg lambdabot @messages' to read it.
12:02:38 * ziman # emerge himerge :)
12:02:52 <dons> andyjgill: yeah, there's a numCapabilities constant
12:03:10 <dons> andyjgill: i note that won't scale to these 10k core machines , where the cores fail at runtime
12:03:26 <dons> GHC/Conc.lhs:        , numCapabilities -- :: Int
12:03:27 <bos> buh?
12:04:05 <andyjgill> Fantastic. I'll use this inside checkit.
12:04:18 <dons> bos, oh, out at the multicore workshop, one of the threads was people talking about application fault tolerance on huge machines (10k+ cores), where you need to keep running as cores fail
12:04:46 <bos> dons: oh yes. MPI is a complete disaster for that.
12:05:01 <sbahra> bos, what isn't?
12:05:02 <bos> basically the *only* plausible approach is to use declarative parallelism.
12:05:06 <Valodim_> is there any useful replacement for associative data in haskell?
12:05:10 <noohgodno> want to see my dadabot code?
12:05:17 <noohgodno> it's in python , i admit
12:05:44 <chrisdone> noohgodno: are you talking to me?
12:05:54 <bos> sbahra: there are several alternative approaches.
12:06:21 <bos> sbahra: but they all rely on not caring exactly where your data is.
12:06:44 <bos> the HPC community is obsessed with raw performance, and there's a depressing lack of focus on whether they're actually getting the right answers at all.
12:06:50 <monochrom> dadabot? jajabing? :)
12:07:03 <trofi> @help index
12:11:31 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
12:11:31 <sbahra> Atleast in HPC, locality is important. Developments are adopting atleast a subset of some PGAS languages.
12:11:31 <sbahra> bos, I see
12:11:31 <trofi> @index Distribution.Simple
12:11:31 <lambdabot> bzzt
12:11:31 <trofi> @index Distribution.Version
12:11:31 <lambdabot> bzzt
12:11:31 <trofi> @index Distribution.Version pleease
12:11:31 <lambdabot> bzzt
12:11:31 <Deewiant> @hoogle Version
12:11:31 <lambdabot> A Hoogle error occurred.
12:11:31 <Deewiant> well that's no help :-P
12:11:31 <bos> sbahra: you can get locality of reference without having to hardwire that into the bowels of your code.
12:11:31 <r3m0t>  bzzt
12:11:32 <chrisdone> maybe I could just run two processes. one to maintain the IRC connection and another to tell it what to send which can be restarted
12:11:32 <sbahra> bos, well, the PGAS approach usually has locality awareness defined in specification.
12:11:32 <chrisdone> then I could talk to it through ghci similar to how GOA talks to lambdabot
12:11:32 <sbahra> bos, for exampled: shared int dongs[10] distributes int objects RR across available cores.
12:11:32 <sbahra> bos, dongs[MYTHREAD] is local (mod).
12:11:32 <bos> sbahra: yes, but all the PGAS languages are ridiculously low-level, and their underlying runtimes just use MPI anyway.
12:11:32 <sbahra> bos, no.
12:11:32 <sbahra> bos, other than CAF, I would say UPC is one of the more popular ones.
12:11:32 <bos> UPC and CAF aren't ridiculously low-level?
12:11:32 <sbahra> bos, I think both use GASnet which supports MPI.
12:11:32 <bos> come on, nobody uses UPC outside of the NSA.
12:11:32 <sbahra> bos, but the MPI conduit isn't so popular.
12:11:32 <sbahra> bos, there are, but not too many :-P
12:11:32 <sbahra> And I am not aware of people using it in actual industry.
12:11:32 <bos> yes, that's because only the NSA cares and provides funding for it.
12:11:33 <DarkPyro> Question: Using the glagow extention to haskell (-fglasgow-exts), how can I include type-information on an where-clause in a function? (If possible at all)
12:11:33 <sbahra> bos, no.
12:11:33 <sbahra> bos, DoD is the main sponsor.
12:11:50 <sbahra> bos, NSA actually does not directly fund any of the projects, AFAIK.
12:12:01 <bos> i've got a pretty solid idea of where the DoD gets its funding direction from for that.
12:12:03 <sbahra> bos, and in fact, NSA is least interested in this.
12:12:11 <sbahra> bos, NSA and NRA are invested in reconfigurable HPC mostly.
12:12:11 <DarkPyro> Hmm
12:12:56 <sbahra> bos, WRT "low-level", I agree with you completely. I don't like explicit data distribution.
12:13:42 <dons> the new cray box is interesting, with its hashed memory, so you don't get to play for locality.
12:14:26 <sbahra> I haven't really had the opportunity to play with it.
12:14:40 <sbahra> Though I think I should have access to one of them by now.
12:14:45 <dons> very few have :) they're expensive.
12:14:58 * bos has been blissfully unaware of new HPC gear for 18 months or so.
12:15:50 <sbahra> I spent this summer in Alaska working on mutual exclusion algorithms.
12:15:56 <yitz> DarkPyro: you can include type signatures in where clauses even without glasgow-exts.
12:16:16 <sbahra> I would've preferred on working on runtime systems for CELL, but my lab is obsessed with PGAS :-P
12:16:24 <smtms> summer in Alaska? sounds cool (literally) :-)
12:16:26 <sbahra> It's a shame, really.
12:16:46 * sbahra thinks SIMD model is nasty
12:16:47 <dons> sbahra: that sounds like an interesting posting.
12:17:08 <dons> played with data parallel haskell any?
12:17:15 <sbahra> No, I will very soon.
12:17:31 <sbahra> I just need to gain more experience with haskell (and fp in general).
12:18:25 <bos> grump. "thread blocked indefinitely" is not my friend.
12:18:33 <DarkPyro> yitz: How?
12:18:47 <DarkPyro> I am unsure of the syntax. :/
12:19:49 <yitz> foo x = h where {h :: String; (h, _) = splitAt 42 x} -- for example
12:20:02 * tibbe is stuck in a left fold.
12:20:11 <yitz> of course, in real life you will probably use layout instead of the curlies and semis.
12:20:28 <yitz> tibbe: push hard with your right hand
12:20:52 <tibbe> :)
12:21:18 <DarkPyro> Thanks yitz.
12:22:00 <dons> tibbe: a left fold of your own making, i imagine :)
12:22:25 <tibbe> dons: indeed
12:22:36 <tibbe> dealing with I/O in blocks is tricky
12:22:59 <tibbe> blocks have a tendency to end exactly where you don't want them to, like in between \r and \n
12:23:01 <andyjgill> dons: Thanks, numCapabilities works and does exactly what I want. Sub-prop parallelism will follow for free :-)
12:23:20 <tibbe> dons: forcing a suspension
12:24:15 <araujo> dons, :-)
12:25:24 <bos> @hoogle mfix
12:25:25 <lambdabot> A Hoogle error occurred.
12:25:35 <LegendaryPenguin> whats the standard editor for haskell? i dont like notepad anymore
12:25:36 * bos cracks lambdabot on the noggin.
12:25:43 <bos> LegendaryPenguin: emacs.
12:25:53 <dons> andyjgill: cool.
12:25:58 <glguy> Control.Monad.Fix probably
12:26:05 <bos> glguy: right.
12:26:11 <dons> despite what bos says, it's really vim. ;)
12:26:17 <dons> glguy can confirm this.
12:26:29 <LegendaryPenguin> but im on windows
12:26:30 <bos> yeah, but you guys think git is nice. i rest my case.
12:26:33 <dons> heh
12:26:40 <bos> LegendaryPenguin: vim and emacs both run on windows just fine.
12:27:00 <LegendaryPenguin> is there a specific emacs for haskell?
12:27:01 <bos> LegendaryPenguin: just be warned, they'll both warp your brain.
12:27:07 <LegendaryPenguin> ive used them before
12:27:17 <bos> no, both emacs and vim have modes (plugins) for editing haskell code.
12:27:40 <kryptiskt> LegendaryPenguin, if you want something more IDEish, there's an eclipse plugin, eclipseFP
12:29:30 <noteventime> LegendaryPenguin: There's also yi
12:29:48 <noteventime> Which is like emacs written in (and extended with) Haskell
12:32:13 <chrisdone> should I use unix domain sockets to talk to my process which maintains the IRC connection?
12:32:59 <haskellian> Haskell keeps amazing me
12:33:05 <haskellian> how cool is this: http://www.haskell.org/haskellwiki/Frag
12:33:06 <lambdabot> Title: Frag - HaskellWiki
12:33:11 <trofi> why not tcp?
12:33:18 <haskellian> http://www.haskell.org/haskellwiki/Frag
12:33:19 <lambdabot> Title: Frag - HaskellWiki
12:33:33 <trofi> echo "do stuff" > /dev/tcp/127.0.0.1/port #bashism though
12:33:34 <haskellian> lambdabot: mediterranian cruise?
12:35:10 * bos needs to read up on pattern guard syntax.
12:35:20 <chrisdone> trofi: why internet sockets and not unix domain sockets?
12:35:21 <Heffalump> pattern guards rock
12:36:44 <trofi> chrisdone: tcp sockets have clents built into OS (like telnet)
12:36:50 <haskellian> @src Maybe
12:36:51 <lambdabot> data Maybe a = Nothing | Just a
12:36:58 <trofi> easier to use/test
12:36:59 <haskellian> @src Just
12:36:59 <lambdabot> Source not found. Just try something else.
12:37:07 <haskellian> @src Nothing
12:37:07 <lambdabot> Source not found. You type like i drive.
12:37:14 <noohgodno> =-o
12:38:37 <chrisdone> trofi: hm, that's a good point
12:39:01 <bos> boy, it's nice to be coding instead of writing text for an hour or two.
12:39:14 <trofi> inet are more portable :]
12:39:38 <trofi> can export service no internet!
12:39:52 <trofi> s/no/to/
12:43:02 <yitz> Heffalump: pattern guards are horrid, avoid them like the plague.
12:43:19 <chrisdone> yitz: what!?
12:43:24 <yitz> (i know not everyone agrees with me on that, but that's my opinion)
12:43:25 <tibbe> can I trust GHC to not allocate a new value in case of: case x of { Right x -> Right x; ... } ?
12:43:37 <tibbe> or do I have to use y@(Right x) -> y ?
12:44:13 <trofi> casze z of { Right x -> z; ... }
12:44:19 <bos> tibbe: you cannot trust it.
12:44:31 <tibbe> but y@... will always work?
12:44:31 <explicitjelly> @t gmapT
12:44:32 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:44:35 <bos> tibbe: yes
12:44:39 <tibbe> goodie
12:44:41 <explicitjelly> :t gmapT
12:44:43 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
12:44:45 <bos> yitz: whydja think?
12:45:13 <trofi> case already_has_name@(maybe:deconstructed) od {- in -} statements
12:45:20 <yitz> they are a major mistake - totally confusing the semantics of "<-", and for no reason, there is no use for them, they add nothing
12:45:33 <Valodim_> :t Map
12:45:43 <Valodim_> what's \bot's type thing?
12:46:17 <sioraiocht> Valodim_: :t works
12:46:19 <sioraiocht> :t Map
12:46:20 <haskellian> Graphics.UI.Gtk I cant find where to download it
12:46:30 <sioraiocht> @type Map
12:46:31 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:46:32 <sioraiocht> that also works
12:46:40 <trofi> @package gtk2hs
12:46:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gtk2hs
12:46:47 <trofi> or not?
12:46:52 <Valodim_> so uh
12:46:52 <sioraiocht> @kind Map
12:46:54 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:46:57 <sioraiocht> booo
12:47:05 <trofi> @type map
12:47:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:10 <twanvl> @kind Data.Map.Map
12:47:12 <lambdabot> * -> * -> *
12:47:14 <Valodim_> when I load :t Data.Map in ghci, :t Map says not in scope
12:47:14 <sioraiocht> ah
12:47:24 <sioraiocht> Valodim_: Map is not a function
12:47:27 <sioraiocht> it's a type
12:47:56 <sioraiocht> Prelude Data.Map> :k Map
12:47:56 <sioraiocht> Map :: * -> * -> *
12:48:02 <sioraiocht> values have types
12:48:05 <sioraiocht> types have kinds =p
12:48:08 <sioraiocht> and kinds have...no love
12:48:20 <Valodim_> ah
12:48:22 <Valodim_> got it
12:48:49 <yitz> every use of <- before that, means bind a non-monadic value on the left resulting from a monadic value on the right. with pattern guards, you write a *non-monadic* value on the right, it gets effectively sent *additively* through a Maybe monad, and then pops out onto the left.
12:49:10 <haskellian> The requested resource was not found: no such package 'gtk2hs'
12:51:04 <yitz> if you really wanted something like pattern guards - at least use different syntax, don't confusingly overload something.
12:51:16 <LegendaryPenguin> what plugin would give color coding in haskell
12:51:20 <LegendaryPenguin> for emacs
12:51:45 <yitz> LegendaryPenguin: the usual haskell-mode does it
12:52:52 <LegendaryPenguin> weird, i think i have it installed & configured but no colors.  I have this haskell tab in emacs now
12:53:42 <yitz> but there is no need for pattern guards anyway - it is easy to prove that anything that can be written with pattern guards can be written as simply, or almost as simply, using the exit monad or maybe monad. and then you are not hiding anything in weird syntax, it is much more clear.
12:53:52 <trofi> M-x global-font-lock-mode
12:53:53 <noohgodno> no you're a moand
12:53:55 <noohgodno> monad
12:54:16 <yitz> </rant>
12:55:18 <SamB_XP> yitz: define "simply"
12:55:21 <LegendaryPenguin> cool got it working, thx
12:56:05 <Heffalump> yitz: the advantage of pattern guards is the scoping
12:56:05 <yitz> about the same number of keystrokes//lines, writing directly what you mean.
12:56:17 <yitz> Heffalump: you already have that with monads.
12:56:49 <SamB_XP> yitz: how do you use a monad to pick which rhs to use?
12:57:43 <yitz> SamB_XP: with the Maybe monad: guard and mplus (or msum). with the Exit monad - when/unless and exitWith.
12:58:30 <Heffalump> yitz: how do you use that with guards?
12:58:39 <seanmce_> can I tell quickCheck to pass in only Integers >0?
12:59:15 <chrisdone> :t guard
12:59:16 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:00:30 <trofi> seanmce_: try this http://book.realworldhaskell.org/beta/testing.html
13:00:31 <lambdabot> Title: Chapter 13. Testing and quality assurance
13:01:30 <sioraiocht> how stable is xmonad?
13:02:01 <chrisdone> sioraiocht: I've been up for 31 days. hasn't crashed for me :P
13:02:14 <TomMD> Pretty damn stable.  I have several boxes that have been up for months.
13:02:32 <ddarius> sioraiocht: I'm still using xmonad 0.3 and I never worry about it crashing.
13:02:36 <TomMD> Of coarse, the one I installed today already crashed once, but I was screwing with some libraries too so take your grain of salt.
13:03:09 <SamB_XP> TomMD: well, if it tends to either run for months or crash in the first 24 hours, that's pretty nice
13:03:24 <sioraiocht> heheh, I just need a small monitor friendly WM for my new Advent 4211 :)
13:03:30 <yitz> Heffalump: generally something like f = maybe default g $ lookup x ys `mplus`... instead of something like f | z <- lookup x ys = g z ... | otherwise = default
13:03:35 <sioraiocht> :t maybe
13:03:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:03:50 <TomMD> Yes - that is how I like it.  Unless I can get it to the 'run for months or it won't even compile' level of quality ;-)
13:04:11 <sioraiocht> > maybe (x -> x + 1) Nothing
13:04:12 <lambdabot>  Parse error at "->" (column 10)
13:04:18 <sioraiocht> > maybe (\x -> x + 1) Nothing
13:04:19 <lambdabot>  Couldn't match expected type `a -> a1 -> a1'
13:04:23 <sioraiocht> ?
13:04:30 <chrisdone> :t maybe
13:04:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:04:33 <sioraiocht> that should be tpe corent =p
13:04:35 <ddarius> maybe takes three arguments
13:05:06 <sioraiocht> I thought it took a HOF and an argument...
13:05:08 <TomMD> > maybe 1 (fmap (+1)) Nothing
13:05:09 <yitz> Of course, if it's a big hairy definition you'll use something more concise. If you like Caleskell, you can use ++ for example. Or some other short operator. Or, use an Exit monad.
13:05:10 <lambdabot>   add an instance declaration for (Num (f a))
13:05:14 <Heffalump> yitz: that doesn't work if you want to pattern match too
13:05:19 <Heffalump> which is why guards are nice
13:05:30 <yitz> Heffalump: sure it does, do notation supports pattern matching.
13:05:34 <sioraiocht> > maybe (\x -> x + 1) Nothing
13:05:36 <lambdabot>  Couldn't match expected type `a -> a1 -> a1'
13:05:36 <sioraiocht> oops
13:05:46 <sioraiocht> oh, i couldn't read the type sig, damn forall =p
13:05:48 <Heffalump> but I want to pattern match in the function definition..
13:06:00 <Heffalump> you're basically saying "get rid of multi-clause definitions"
13:06:24 <sioraiocht> > maybe 0 (\x -> x + 1) Nothing
13:06:27 <lambdabot>  0
13:06:31 <sioraiocht> > maybe 0 (\x -> x + 1) (Just 2)
13:06:32 <chrisdone> > (do [a] <- Just [1]; return a, do [a] <- Nothing; return a)
13:06:34 <lambdabot>  3
13:06:34 <lambdabot>  (Just 1,Nothing)
13:06:36 <sioraiocht> ahhh
13:06:49 <ddarius> yitz: Have you read "First class patterns?"
13:06:56 <yitz> Heffalump: no, only get rid of them in complex cases where they obfuscate things - and abusing <- only makes that worse. In straightforward cases, by all means.
13:07:19 <yitz> ddarius: ?
13:07:27 <Heffalump> well, the benefit of pattern guards for me is that they allow me to use multi-clause definitions even in complex cases
13:07:27 <SamB_XP> yitz: eh???
13:07:31 <Heffalump> and I don't find them obfuscating
13:07:45 <SamB_XP> yitz: you seem to have got things exactly backwards
13:07:48 <yitz> Heffalump: you can do that with monads.
13:07:50 <Heffalump> I agree that the overloading of <- is slightly unfortunate, but I think it's livable with.
13:08:15 <Heffalump> yitz: how can you write multi-clause definitions (of the kind that pattern guards allow) with monads?
13:08:18 <ddarius> @google "First Class Patterns"
13:08:23 <lambdabot> http://citeseer.ist.psu.edu/tullsen00first.html
13:09:51 <yitz> Heffalump:  it's quite trivial when you give it a try. Just as simple as pattern guards, really.
13:10:06 <Heffalump> show me an example
13:15:17 <bos> ooh. i thought Text.Printf.printf was strongly typed, but it's just variadic.
13:15:32 <bos> in some strange alien way.
13:15:47 <dons> yep. recursive instances to soak up the arguments.
13:15:53 <Leaves> Hello, do you know how I convert a rational numer to a string? something like rat2string 5 (recip (3::Rational)) == 0.33333
13:15:56 <dons> but tags checked dynamically
13:16:08 <trofi> > show (1%3)
13:16:11 <lambdabot>  "1%3"
13:16:29 <dons> > printf "%0.4f" (1/3 :: Rational)
13:16:31 <lambdabot>        add an instance declaration for (PrintfArg (Ratio Integer))
13:16:34 <dons> boo
13:16:43 <yitz> Heffalump: well, for example, the examples in the "pattern guards" paper are easy. I'll convert and hpaste if you'd like. The ghc guys always pull out some huge P.G. declarations - they're already messy with P.G., about the same with monads. I don't have one of those at had just now, but I could try to make one up. What's you're pleasure?
13:16:47 <chrisdone> heh, I have an example in my own code
13:17:11 <yitz> chrisdone: great! can you paste it?
13:17:12 <dons> yitz: i love using pattern guards for regex matching.
13:17:25 <yitz> dons: throw 'em at me.
13:17:34 <chrisdone> http://hpaste.org/9720
13:17:43 <tibbe> could someone recommend a good introduction to defunctionalization?
13:17:52 <chrisdone> yitz: could be done a better way; feel free to annotate it
13:18:02 <chrisdone> dons: heh, that's what my example is :P
13:18:38 <rwbarton> One contrast between pattern guards and the monad approach is the pattern guard forces you to put the precondition up front, whereas failing computations could occur anywhere in a do block
13:19:13 <ddarius> @google "Defunctionalization at work"
13:19:14 <dons> substring s = Just [x] <- match r s [] = x where r = compile "a(.*b)" []
13:19:17 <lambdabot> http://www.brics.dk/RS/01/23/
13:19:17 <lambdabot> Title: Defunctionalization at Work
13:19:17 <dons> that kind of thing.
13:20:51 <Heffalump> you got a = and a | confused
13:20:55 <chrisdone> yitz: which do you prefer in that paste?
13:21:30 <rwbarton> chrisdone's hpaste is a good example of an advantage of the pattern guard--"maybe default g $ ..." sounds easy enough, but often g won't have a simple point-free form
13:22:45 <chrisdone> parse (Link a b) = flip Link b $ fromMaybe a $ do [id] <- match; return id
13:22:48 <chrisdone> is also an option
13:23:28 <chrisdone> yitz: ah, you pasted it
13:23:31 <yitz> chrisdone: yeah, that's what I just pasted.
13:24:18 <LegendaryPenguin> whats wrong with this indentation? http://pastebin.com/d61a55fd7
13:24:33 <nodogbite> does one of the haskell libraries have a cubed root function?
13:24:56 <ddarius> > 2**(1/3)
13:24:57 <glguy> LegendaryPenguin: else needs to be indented past if
13:24:58 <lambdabot>  1.2599210498948732
13:25:00 <yitz> chrisdone: advantage is that you don't need to abstract out "match". disadvantage is that the Link _ _ don't line up vertically (but you could fix that if important, say when you've got a lot of them)
13:25:15 <nodogbite> ddarius: okay, fair enough
13:25:59 <yitz> ddarius: ok, interesting paper. a bit dated now. it states the problem well, but I'm not too fond of the proposed solution.
13:26:24 <chrisdone> yitz: really, I suppose one could write head <$> match, rather than the pattern, but that defeats the point of this example of pattern matching
13:26:54 <glguy> LegendaryPenguin: http://pastebin.com/m477b3a08
13:27:00 <olsner> @pl \a x -> x ** (1/a)
13:27:01 <lambdabot> flip (**) . (1 /)
13:28:18 <ddarius> yitz: If you want to seem something totally crazy, but not too related, see Barry Jay's Pattern Calculus stuff.
13:28:20 <yitz> chisdone. yeah. anyway, the real nitty gritty is when you have complex nesting of logic structures that bind and pattern match along the way.
13:28:40 <explicitjelly> :t GenericT
13:28:46 <yitz> ddarius: Haskell really brings out the creativity in people.
13:28:55 <Heffalump> that example isn't very interesting because there's no real pattern matching in the LHS
13:28:58 <explicitjelly> @i GenericT
13:28:59 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
13:29:02 <Heffalump> chrisdones, that is
13:29:03 <explicitjelly> ?
13:29:06 <yitz> Heffalump: tru
13:29:07 <explicitjelly> @?
13:29:16 <explicitjelly> :i GenericT
13:29:35 <explicitjelly> @
13:29:47 <Heffalump> optSE' in http://code.haskell.org/squiggle/unstable/src/Database/Squiggle/
13:29:47 <explicitjelly> @info GenericT
13:29:47 <lambdabot> Title: Index of /squiggle/unstable/src/Database/Squiggle
13:29:48 <lambdabot> GenericT
13:29:50 <Heffalump> is the kind of thing I really like them for
13:29:59 <Heffalump> sorry, Types.hs in that path
13:30:21 <explicitjelly> how can I ask lambdabot to tell me how GenericT is implemented?
13:30:23 <explicitjelly> :info GenericT
13:31:21 <dons> it's in Data.Generics
13:31:21 <chrisdone> @src GenericT
13:31:21 <lambdabot> Source not found. My mind is going. I can feel it.
13:31:25 <dons> so poke around in the source
13:31:31 <yitz> uh, Heffalump, do you have a roadmap for that module? :)
13:31:38 <explicitjelly> I just did :i GenericT in GHCi, worked
13:31:39 <dons> or, lambdabot could read you sections from the SYB papers
13:31:39 <Heffalump> just search for optSE'
13:31:50 <Heffalump> (no :-)
13:33:09 <newsham> ?read me a story
13:33:09 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
13:34:12 <chrisdone> ?can haskell teach me how to read?
13:34:12 <lambdabot> Maybe you meant: faq map run wn
13:34:16 <chrisdone> ?faq can haskell teach me how to read?
13:34:17 <lambdabot> The answer is: Yes! Haskell can do that.
13:34:45 <lelf> ?. elite faq
13:34:45 <lambdabot> T|-|E aNSwER IS: yEs! hASk3|l Can dO 7|-|a7.
13:34:46 <Olathe> Can Haskell answer this question ?
13:35:09 <yitz> Heffalump: ok, found it. also optIQ, I see.
13:35:17 <dsrogers> hi
13:35:17 <Heffalump> yeah
13:35:39 <dsrogers> I'm looking at this code, and I believe I have found someone using unsafePerformIO to create a global thread lock.
13:35:46 <dsrogers> that seems .... unhaskell like
13:36:05 <chrisdone> heathens
13:36:11 <hackage> Uploaded to hackage: logfloat 0.8.6
13:36:11 <hackage> Uploaded to hackage: list-extras 0.2.1
13:36:11 <hackage> Uploaded to hackage: logfloat 0.8.5
13:36:11 <trofi> > let stmt ? = "i dunno" in "'ynow" ?
13:36:12 <hackage> Uploaded to hackage: logfloat 0.8.4
13:36:12 <lambdabot>  Parse error at "=" (column 12)
13:36:14 <hackage> Uploaded to hackage: roguestar-engine 0.2.2
13:36:17 <dsrogers> what is the safe way to create a global thread lock?
13:36:30 <Heffalump> yitz: anyway, obviously you don't have to translate the whole thing, just a few clauses
13:36:37 <Heffalump> and simplify or whatever
13:36:59 <chrisdone> dsrogers: use an MVar, perhaps
13:37:04 <yitz> Heffalump: just trying to make some sense about those types, just a minute.
13:37:58 <dsrogers> chrisdone: this is what is happening: getGlobalLock = unsafePerformIO $ newMVar ()
13:38:30 <chrisdone> dsrogers: horrible!
13:38:33 <newsham> you could just make the lock in main and pass it to all functions that need it
13:38:53 <dsrogers> then in the state modifying code: withMVar getGlobalLock $ \_ -> do ...
13:39:35 <dsrogers> newsham: is there someway to abstract that away?  This is supposed to be library code, which has no control over the main function
13:39:54 <Heffalump> how about using STM instead?
13:40:19 <newsham> dsroger:    handle <- initLib;   runLibFunc handle   ?
13:40:31 <TomMD> Or passing 'getGlobalLock' as an argument.
13:41:00 <newsham> though.. isnt that th ekind of thing unsafePerformIO was made for?
13:43:04 <dsrogers> newsham: I don't know. I thought it was made as a last resort.  I'm not convinced this is a last resort.
13:43:09 <TomMD> unsafePerformIO wasn't made... it was discovered.  And what a horrible discovery it was.
13:43:18 <dsrogers> lol
13:44:34 <TomMD> As for a serious answer: This is the very first use I saw of unsafePerformIO and how I have came to think of as the safest use for it.  Though I won't call any use of unsafePerformIO 'legitimate'.
13:45:09 <newsham> i've seen several programs use unsafePerformIO to read config files at startup
13:45:32 <TomMD> yuck!  That doesn't make much sense - or were they making the config a global variable?
13:46:14 <newsham> ie. HWS ... serverRoot = unsafePerformIO $ do ... read command line args ....
13:46:31 <rwbarton> I don't think a library that doesn't use unsafePerformIO can tell whether there are "two copies of it", so it can't create a global thread lock
13:46:51 <newsham> if you're reading a static config file or program environment, it should be safe, no?
13:47:23 <dsrogers> newsham: depends.  that stuff could all be modified at any time.  including from outside the program.
13:48:04 <newsham> right, but if you're saying "this config file is static", you're taking on the responsibility of the unsafe part
13:48:08 <rwbarton> a static config file is one of the examples of a valid use of unsafePerformIO in the Awkward Squad paper.  Though, it's probably best to read the file strictly
13:49:42 <dsrogers> ah.  so the answer is, really, global thead locks in haskell are "hard"
13:50:39 <newsham> why?  just unsafePerformIO to create the lock
13:51:38 <dsrogers> I mean without the magic of ignoring all the checks.
13:51:44 <yitz> Heffalump: http://hpaste.org/9721
13:52:10 <newsham> ignoring all the checks?
13:53:14 <lucca> argh, why not STM?
13:53:21 <yitz> Heffalump: oops, misread the flow, one second
13:53:25 <Heffalump> yitz: what happens when none of the cases apply?
13:53:32 <Heffalump> that's the key point here, really
13:53:40 <Heffalump> the fallthrough to the default way lower down
13:53:42 <yitz> Heffalump: yeah - one second
13:54:02 <dsrogers> I'm looking into it.  This code, in particular has a lot of unsafe foreign calls
13:55:11 <dsrogers> newsham: unsafePerformIO is very unsafe.  I'd like to avoid it at almost all costs. You can ignore type systems, write to random locations in memory, etc.
13:55:35 <dsrogers> even trying to use it in a safe manner requires various compiler flags.
13:55:47 <dsrogers> and that stuff means that your app could break when a new compiler comes out.
13:55:50 <rwbarton> dsrogers: if you're calling C code, it can do all of the same things.
13:55:57 <Trinithis> What is (~>) ?
13:56:05 <rwbarton> dsrogers: and if you're not, you shouldn't need a global thread lock (probably?)
13:57:00 <dsrogers> rwbarton: well I avoid C code too, when possible.
13:57:45 <dsrogers> rwbarton: and I'm actually wondering if that's true.  I need a global lock because I'm calling C code and there is no other way is a perfectly acceptable answer...
13:58:35 <rwbarton> dsrogers: I mean, "fix your C code" :)
14:00:35 <LegendaryPenguin> whats wrong with this http://pastebin.com/d6cbeea9e last 2 lines?
14:00:44 <dsrogers> rwbarton: fix it in what sense?
14:01:20 <rwbarton> dsrogers: Sorry, I think I made up the fact that you're calling C code, but maybe it's true anyways?
14:01:40 <Trinithis> LegendaryPenguin: foldr needs a list, and x is not  a list
14:01:45 <dsrogers> rwbarton: yes.  it's true.  I'm calling C code.
14:01:45 <Trinithis> or nevermind
14:01:47 <Trinithis> misread
14:02:04 <lucca> well you could do locking in the C code
14:02:06 <rwbarton> dsrogers: And that C code is calling some function like gethostbyname which is why it needs a global thread lock?
14:02:14 <rwbarton> dsrogers: (more wild guessing here :)
14:02:15 <LegendaryPenguin> Couldn't match expected type `[a]' against inferred type `()' on last line
14:02:29 <dsrogers> rwbarton: it's calling into pieces of the objective-c runtime.
14:02:34 <LegendaryPenguin> do i need to return x?
14:02:44 <Trinithis> you can or you can change
14:02:54 <Trinithis> then return [] to return ()
14:03:02 <dsrogers> rwbarton: keeping track of allocated haskell-objective-c object pairs.
14:03:03 <Trinithis> then return ()*
14:03:27 <Trinithis> What do you want number to return ?
14:04:12 <LegendaryPenguin> list of all the inputs
14:04:59 <dsrogers> lucca: there's an idea....  keep the unsafe stuff in the C...
14:04:59 <Trinithis> http://pastebin.com/m1b5efc5d
14:05:08 <rwbarton> dsrogers: ... oh.  It sounds to me like you're doing something deeply magical, and you shouldn't let a little thing like unsafePerformIO stand in your way :P
14:05:17 <dsrogers> rwbarton: lol
14:05:41 <rwbarton> dsrogers: (really it's just that I know almost nothing about objective c)
14:06:28 <Trinithis> LegendaryPenguin: You might want to consider renaming x to xs because it is kind of a standard convention
14:06:55 <dsrogers> rwbarton: you don't need too.  It's a two way language binding, so there are proxy objects for one language to another.  The map that stores that mapping needs synchronization.
14:07:12 <LegendaryPenguin> ok, wil do
14:07:16 <dsrogers> rwbarton: but I get your point.
14:07:25 <rwbarton> dsrogers: I mean, it sounds like to show your program won't crash, you have a lot more proof obligations besides "it doesn't matter when this IO gets run"
14:07:32 <lucca> dsrogers: are you using HoC?
14:07:34 <bluestorm> quick question : can i have equi-recursive types in Haskell ?
14:07:42 <dsrogers> lucca: I'm modifying HoC
14:07:44 <bluestorm> (i guess it's the name for eg.  type t = (t, t) )
14:07:53 <lucca> this is relevant to my interests :p
14:08:33 <dsrogers> HoC is dead, as far as I can tell.  I've been busy documenting code so I can start finishing it up.
14:08:33 <bluestorm> i suppose there may be a GHC cli option to enable that, and would be interested in the type constructor (type / newtype / data :/ ) to use
14:08:50 <humasect> what about the other objc binding that needs no intermediary tools or maps ?
14:08:52 <lucca> yeah, seems to have been unmaintained for quite a long while
14:09:41 <dsrogers> humasect: it doesn't have the type safety of this version.
14:09:53 <humasect> ah i see
14:10:24 <bluestorm> nobody for equirecursives types ?
14:11:18 <newsham> is there a channelf or discussing FRP?
14:11:41 <rwbarton> bluestorm: only via a newtype   (newtype T = T (T, T))
14:12:04 <bluestorm> oh
14:12:08 <bluestorm> newtype. thanks !
14:12:18 <yitz> Heffalump: http://hpaste.org/9721#a1
14:12:25 <bluestorm> it's a real pain that type declarations are not accessible from ghci
14:13:10 <bluestorm> is there an interpreter more liberal on the Haskell code it accepts ?
14:13:10 <Heffalump> yitz: well, IMO that's way less readable than my existing code
14:13:13 <dsrogers> lucca: yeah, the mailing list is more or less dead too.
14:13:34 <yitz> Heffalump: oops, bumped the tab key for the first e2'. well, anyway.
14:14:25 <bluestorm> oh rwbarton
14:14:33 <bluestorm> your type has a data constructor
14:14:37 <bluestorm> i didn't spot that at first
14:14:53 <bluestorm> so i guess we can't do without a data constructor ?
14:15:11 <chrisdone> what's that effect called where incompetents overestimate their skill, and competents underestimate their skill?
14:15:13 <newsham> > 3 <$ Just 5
14:15:15 <lambdabot>  Just 3
14:15:18 <dsrogers> lucca: I'm converting the repo to darcs as we speak, if you're interested.
14:15:56 <newsham> > Just 3 *> Just 5
14:15:59 <lambdabot>  Just 5
14:16:02 <newsham> > Just 3 <* Just 5
14:16:05 <lambdabot>  Just 3
14:16:08 <lucca> tailor or something?
14:16:14 <dsrogers> yeah
14:16:17 <rwbarton> bluestorm: ... right.  The data constructor is just syntax, though.
14:16:32 <dsrogers> though I may discard the version history and start with an in-place depo.
14:16:37 <dsrogers> because tailor is failing
14:16:44 <newsham> > Just 3 <*> return (+1)
14:16:45 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
14:16:48 <newsham> > Just 3 <**> return (+1)
14:16:50 <rwbarton> bluestorm: it's because the vast majority of the time the compiler tries to unify 't' with '(t, t)', it's because the programmer made an error.
14:16:50 <lambdabot> Terminated
14:16:54 <ddarius> rwbarton: Those are isorecursive types, not equirecursive.
14:17:00 <lucca> hmmmm
14:17:00 <SamB_XP> aren't there other ways to convert SVN or CVS repos to darcs?
14:17:08 * rwbarton is a category theorist and doesn't care
14:17:18 <ddarius> chrisdone: Competent people accurately estimate their skill.
14:17:18 <bluestorm> rwbarton: i'm not sure that's "not syntax"
14:17:25 <bluestorm> hm
14:17:28 <bluestorm> "just syntax", sorry
14:17:53 <rwbarton> bluestorm: I mean there's no runtime cost to the T.  If you used 'data', it would be a different situation
14:18:06 <ddarius> chrisdone: And you are probably thinking about the Dunning-Kruger effect.
14:18:10 <bluestorm> i can accept runtime cost
14:18:16 <bluestorm> actually
14:18:38 <rwbarton> bluestorm: but maybe you need t = (t, t) for some reason I'm not considering.  In which case, the answer is "not in Haskell"
14:19:11 <bluestorm> i'm an ocaml user, and ocaml has a -rectypes switch to allow these things (rationale : something it's useful, but most of the time as you say it's an error, and you can shot yourself in the foot with that kind of inference), so i thought GHC might have that too
14:19:26 <ddarius> Well t = (t,t) is a pretty pointless type equation.  Completely pointless in a strict context.
14:19:29 <chrisdone> ddarius: that's the one
14:19:41 <rwbarton> bluestorm: pretty sure it doesn't
14:19:45 <bluestorm> ok, thanks
14:20:01 <yitz> Heffalump: when you abuse <- it will certainly lead to bugs, or at least more compile errors. My code follows more or less the same pattern - slightly busier, but still cleanly organized and about the same size, and without the cascading case statements of the paper.
14:20:03 <SamB_XP> competent people may overestimate the attainable competency
14:21:09 <rwbarton> bluestorm: now that I think about it, t = (t, t) might interact strangely with type classes
14:21:37 <bluestorm> rwbarton: how so ?
14:22:35 <rwbarton> bluestorm: t = (t, t) matches the instance  instance Foo (a, (b, c)) where ...,  right?  The compiler has to do some work to detect that
14:22:56 <rwbarton> bluestorm: Maybe it's not a difficulty
14:23:19 <ddarius> rwbarton: It's just unification.
14:23:21 <bluestorm> hm
14:23:35 <rwbarton> ddarius: Yeah, you're right
14:24:19 <Heffalump> yitz: there's no reason it should lead to bugs, I am actually aware of the distinction in the different contexts.
14:24:32 <Heffalump> and the type system would quickly catch it if I weren't
14:24:36 * stepcut notes that every time he has intentionally used -rectypes, he has untentiontally run into the run-time error that switching on -rectypes allows ;)
14:25:04 <Heffalump> and IMO the pattern-matching definitions flow much easier
14:25:14 <bluestorm> (i actually answering to something asking :  why isn't this code legal ?   let to_tuple (Node a left right) = (a, left, right);  let to_tuple Leaf a = a  )
14:25:41 <SamB_XP> yitz: I can't believe you are STILL trying to convince Heffalump that pattern guards are evil
14:25:47 <yitz> ddarius: t = (t,t) is not pointless at all. It gives you a static unlabeled graph with possible cycles. As it is, you can only do it with an ADT, so there is no way to get a static graph with cycles directly in ghci, only via a loaded modules.
14:26:31 <SamB_XP> it's been like an hour and a half since I came in, and you've been harping on that the whole time!
14:26:53 <Heffalump> well, I remain as unconvinced as I was before, and am going to bed :-)
14:26:55 <chrisdone> SamB_XP:  it's been five minutes since I came in, and you've been going on about yitz the whole time!
14:26:56 <ddarius> yitz: In a strict language the only value of that is bottom.  In a lazy language you can only semi-decide how deeply a path is defined.
14:27:28 <SamB_XP> chrisdone: yeah right!
14:27:55 <yitz> SamB_XP: Just paying up. I promised I would convert any PG-rated code into real Haskell that's just as good or better. Of course, the bottom line is always subjective. The point is - you'll have to agree that it's at least close stylistically. So it comes down to whether overloading <- is evil, and I believe that it is evil.
14:28:24 <SamB_XP> yitz: why do I have to agree that it's close?
14:28:26 <stepcut> it's been years since I came in, and you've all been going on about haskell the whole time!
14:28:37 <ddarius> stepcut: Not the whole time.
14:28:40 <SamB_XP> stepcut: not really
14:28:45 <yitz> ddarius: Haskell is lazy :) I use that structure from time to time.
14:29:06 <rwbarton> yitz: Are you sure you don't use  t = (Int, t, t)  or something?
14:29:08 <yitz> stepcut: only when people get me going about PGs ;)
14:29:17 <SamB_XP> sometimes we talk about ADD, C, Python, Perl, Prolog, sex, movies, drugs ....
14:29:38 <SamB_XP> yitz: oh, I thought you were referring to the PG movie rating
14:29:57 <SamB_XP> wait you did
14:30:00 <chrisdone> stepcut: it's been seconds since I read your message, and I've been thinking about it the whole time!
14:30:01 <yitz> rwbarton: yeah. but that's not possible either in ghci.
14:30:37 <yitz> SamB_XP: :)
14:30:51 <bluestorm> rwbarton: yeah it would be more useful to add some data somewhere
14:31:25 <bluestorm> hm
14:31:41 <bluestorm> i guess it is possible to encode information with the physicial equality relation
14:32:05 <yitz> bluestorm: there is no physical equality relation in Haskell.
14:32:09 <rwbarton> Haskell doesn't give you physical equality (except via unsafe*)
14:32:12 <bluestorm> ah
14:32:31 <bluestorm> hm
14:32:37 <bluestorm> type t = [t]  looks like more fun then
14:32:47 <yitz> bluestorm: that's important - you don't want to tie the compiler to a specific physical implementation
14:33:08 <yitz> bluestorm: ghc screams at me for that one all the time :)
14:33:14 <eu-prleu-peupeu> where can i download okasaki book ?
14:33:20 <ddarius> eu-prleu-peupeu: You can't.
14:33:40 <bluestorm> yitz: you mean the compiler want to retain the freedom to silently copy values somewhere ?
14:33:45 <ddarius> Or maybe there is some eBook dealer who sells it?
14:33:50 <yitz> bluestorm: right
14:33:59 <SamB_XP> eu-prleu-peupeu: you can download it at selected libraries -- johny 5 style, that is
14:34:02 <bluestorm> eu-prleu-peupeu: a bookshop looks like the easier path
14:34:04 <ddarius> physical equality violates referential transparency.
14:34:14 <yitz> bluestorm: or the oposite, to unify values that it deduces must be the same
14:34:20 <bluestorm> however eu-prleu-peupeu , his thesis is available
14:34:20 <eu-prleu-peupeu> allright
14:34:30 <bluestorm> that closely follows some part of the books (but not everything)
14:34:32 <eu-prleu-peupeu> hmm whats the name of the book ?
14:34:39 <bluestorm> Purely Functional Data Structures
14:34:46 <bluestorm> (iirc)
14:35:09 <bluestorm> no funny stuff like The Little Data Structurist
14:35:26 <eu-prleu-peupeu> oh
14:35:26 <eu-prleu-peupeu> :/
14:35:36 <eu-prleu-peupeu> im a begginner, is it good to read it ?
14:35:45 <SamB_XP> actually it would be more accurate to say that it closely precedes those parts of the book ;-P
14:36:07 <chrisdone> :t (***)
14:36:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:36:14 <bluestorm> eu-prleu-peupeu: hm
14:36:26 <bluestorm> that's data-structure-foo, quite different from general programming
14:36:45 <dsrogers> hmm, where is mdo defined?
14:36:50 <rwbarton> I've looked at the thesis, it's intense, but doesn't require lots of knowledge
14:36:54 <ddarius> mdo is syntax
14:36:57 <bluestorm> i'd say the same
14:36:58 <dsrogers> ah.
14:37:02 <glguy> dsrogers: it is syntax and you'll need a compiler flag to use it
14:37:03 <eu-prleu-peupeu> well... i need something to read on the long commute times i have from my village to the city :/
14:37:06 <dsrogers> where is mdo explained, then?
14:37:09 <eu-prleu-peupeu> i've tried the bible
14:37:12 <SamB_XP> dsrogers: it's a combo of mfix and do
14:37:14 <bluestorm> eu-prleu-peupeu: you'll need some concentration
14:37:17 <SamB_XP> sort of
14:37:27 <bluestorm> if think i'd choose something easier to read
14:37:32 <bluestorm> but that book sure is interesting
14:37:38 <eu-prleu-peupeu> hmm
14:37:39 <SamB_XP> @google ghc manual mdo
14:37:41 <humasect> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:37:42 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
14:37:42 <lambdabot> Title: 8.3.�Syntactic extensions
14:37:43 <lambdabot> Title: Purely Functional Data Structures
14:37:51 <eu-prleu-peupeu> are there any good books on type theory ?
14:38:02 <chrisdone> hells yeah, pdf titles
14:38:08 <bluestorm> (is that "TPL" ?)
14:38:18 <SamB_XP> bluestorm: you mean TaPL?
14:38:23 <chrisdone> @go types and programming languages
14:38:26 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:38:26 <lambdabot> Title: Types and Programming Languages
14:38:28 <bluestorm> probably
14:38:49 <bluestorm> eu-prleu-peupeu: do you need a printed book ?
14:38:52 <ddarius> @google "wizard book"
14:38:55 <lambdabot> http://mitpress.mit.edu/sicp/
14:38:55 <lambdabot> Title: Welcome to the SICP Web Site
14:39:00 <ddarius> @google "brick book"
14:39:02 <bluestorm> (maybe you have a pdf reader in your bus ?)
14:39:03 <chrisdone> ddarius: hehe
14:39:12 <lambdabot> http://www.brick-book.com/
14:39:12 <lambdabot> Title: John Oliver's Brick Book - The definitive guide to bricklaying, masonry, and the ...
14:39:43 <newsham> masonry and haskell?
14:40:10 <chrisdone> and the art of landscape gardening
14:40:24 <eu-prleu-peupeu> hmm
14:40:27 <eu-prleu-peupeu> ill print it
14:40:33 <ddarius> "At last. A current, comprehensive text devoted to bricks and brickwork."
14:40:34 <eu-prleu-peupeu> i barely print anything :/
14:40:36 <newsham> monadic landscaping
14:41:27 <chrisdone> ddarius: I laughed
14:41:56 <newsham> if you laugh on the internet, you must tell someone.
14:41:57 <yitz> subtitle: what to do with your iPhone after you try to compile GHC on it
14:42:17 <bluestorm> hm
14:42:21 <chrisdone> newsham: correct
14:42:37 <bluestorm> you mean, after the fifth compilation hour ?
14:42:52 <bluestorm> going to sleep is the easy way
14:42:58 <|Steve|> Only 5 hours? That's pretty good.
14:42:59 <LegendaryPenguin> are there any good sites that have haskell language features + example code using it? like CLHS?
14:43:50 <newsham> the wiki?  hpaste?  codepad?
14:44:07 <chrisdone> LegendaryPenguin: http://book.realworldhaskell.org/beta/
14:44:12 <lambdabot> Title: Real World Haskell
14:44:32 <haskellian> someone want help me with binary serialization? http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/4291590a7702e289# , http://hpaste.org/9722
14:44:48 <yitz> LegendaryPenguin: the Wikibook
14:44:53 <bluestorm> chrisdone: do you know if the online content will still be available after publication ?
14:45:03 <ddarius> bluestorm: It will.
14:45:07 <bluestorm> great
14:45:12 <newsham> haskellian: sure.  whats the question?
14:45:16 <bluestorm> nice publishers also :p
14:45:51 <newsham> are the "put 0"s in expectation of future alternatives?
14:45:57 <haskellian> look at the google groups thread, bottom post
14:46:21 <LegendaryPenguin> like this i mean : http://www.lispworks.com/documentation/HyperSpec/Front/X_AllSym.htm
14:46:27 <lambdabot> Title: CLHS: Alphabetical Symbol Index (Full), http://tinyurl.com/6o5vos
14:46:33 <haskellian> i knwo case 0 is unneccsary i guess, i changed existing eamples and wasnt 100% how it should be
14:46:50 <newsham> haskellian: btw, you can write cleaner "get" with Control.Applicative
14:47:02 <newsham> ie:     moveID <$> get <*> get <*> get <*> get
14:47:13 <newsham> (err.. too many gets by one)
14:47:24 <dons> liftM3 moveID get get get ?
14:47:31 <newsham> yah
14:47:38 <newsham> err..   liftM3 Review get get get
14:48:01 <eu-prleu-peupeu> hmm, im reading through the preview of okasaki's book on amazon, and im noticing that ML is very similar to haskell
14:48:26 <bluestorm> of course eu-prleu-peupeu
14:48:30 <eu-prleu-peupeu> haskell is like ML++ :P
14:48:35 <bluestorm> with a 10 minutes crash-course
14:48:41 <humasect> eu-prleu-peupeu: haven't you seen? http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:48:41 <bluestorm> you can expect to understand all the examples in the book
14:48:42 <ski> except the MLs are strict (except LML)
14:48:43 <lambdabot> Title: Purely Functional Data Structures
14:49:06 <newsham> hmm.. is this a formattin gissue?
14:49:06 <eu-prleu-peupeu> humasect: yes, but i read only throught the initial part
14:49:11 <eu-prleu-peupeu> ill probably print it :)
14:49:14 <newsham> do put ..\n    put;
14:49:21 <humasect> okay. well it seems like it is there for you if you need it
14:49:38 <bluestorm> ( eu-prleu-peupeu : how do you know that haskell is superior to ML if you haven't used or even read some code of the latter before ? )
14:49:50 <eu-prleu-peupeu> heheh
14:49:59 <eu-prleu-peupeu> i deduced because it is more modern
14:50:04 <bluestorm> ++ is crappy side effect anyway
14:50:09 <eu-prleu-peupeu> ahah
14:50:09 <eu-prleu-peupeu> :)
14:50:20 <eu-prleu-peupeu> ok, ML#
14:50:20 <newsham>      In the expression: put (0 :: Word8) put idn put reviews
14:50:22 <dons> well, haskell's descended from ML, so it learns from its mistakes?
14:50:24 <eu-prleu-peupeu> or ML$ :P
14:50:44 <newsham> I think your do block isnt workinh right due to layout
14:50:47 <LegendaryPenguin> ML is a cool name though
14:50:54 <bluestorm> dons: well he mean't "the strict and faithful ML sons" i guess, because the language he was referring to was SML
14:51:27 <bluestorm> LegendaryPenguin: Haskell is quite good to, especially the part about the choice in the History of Haskell paper
14:51:32 <bluestorm> s/to/too/
14:51:40 <SamB_XP> eu-prleu-peupeu: being more recent doesn't imply that it is better ;-)
14:51:58 <SamB_XP> bluestorm: the choice?
14:52:03 <SamB_XP> I don't remember what it was
14:52:04 <bluestorm> the name choice
14:52:34 <dmhouse> dons: there are plenty of example where people have based languages on other languages and made a hash of it, though.
14:52:46 <newsham> haskellian: try changing layout?
14:52:59 <dons> dmhouse: yeah, that's certain.
14:53:27 <jaj> Hi, I was wondering whether it's possible to build ghc 6.8 with nhc or yhc
14:53:39 <SamB_XP> case in point: C++!
14:53:45 <eu-prleu-peupeu> what about this tut, that builds a scheme interpreter in haskell in 48 hours ?
14:53:48 <LegendaryPenguin> C > C++
14:53:50 <eu-prleu-peupeu> is it worth reading ?
14:53:56 <LegendaryPenguin> C++ more like C--
14:54:00 <newsham> c == c++
14:54:10 <newsham> post-increment
14:54:11 <dmhouse> jaj: unlikely, why would you want to?
14:54:30 <newsham> (prob undefined order of op?)
14:55:00 <jaj> dmhouse: I was thinking of it as a nice way to get ghc 6.8 to openbsd
14:55:04 <newsham> i guess if c++ is evald first then   c > c++
14:55:06 <haskellian> newsham: order? i redid this example: http://hpaste.org/9723
14:55:14 <haskellian> but not sur ei got it right
14:55:16 <gwern> @check \x -> x == x
14:55:16 <dons> jaj, isn't 6.8 already happy on ghc?
14:55:17 <lambdabot>  OK, passed 500 tests.
14:55:18 <eu-prleu-peupeu> this one: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/evaluator1.html
14:55:20 <lambdabot> Title: Write yourself a Scheme in 48 hours, http://tinyurl.com/6gwea8
14:55:20 <dons> jaj, on bsd.
14:55:24 <dons> or are you porting to a new arch?
14:55:26 <dmhouse> jaj: isn't there a GHC for BSD already?
14:55:37 <dmhouse> jaj: you can use an older version of GHC to compile newer versions of GHC.
14:55:37 <dons> i've been using 6.8.2 on x86_64/openbsd for ages
14:55:47 <jaj> dons: the latest bsd port is 6.6
14:55:55 <newsham> haskellian: and does that fix the error?
14:55:56 <dmhouse> jaj: so use that to compile 6.8.
14:55:56 <gwern> @check (\x -> x == x)
14:55:58 <lambdabot>  OK, passed 500 tests.
14:56:10 <dons> jaj, so use 6.6 to build 6.8.x
14:56:17 <nominolo> @scheck (\x -> x == x)
14:56:18 <lambdabot>     Failed to load interface for `SmallCheck':
14:56:18 <lambdabot>       Use -v to see a list of ...
14:56:28 <jaj> post-6.6 versions cannot bootstrap from hc files anymore and the maintainer wants to fix that before updating the port
14:56:40 <gwern> nominolo: smallcheck works in mueval, btw
14:56:43 * gwern is a little smug
14:56:46 <dons> yeah, i've spoken to kili about it.
14:56:55 <dons> jaj, but you can still use 6.6 to directly build 6.8.x
14:57:00 <haskellian> from where do i import liftM and liftM3?
14:57:03 <dons> you certainly cannot use nhc or hugs to build ghc
14:57:07 <gwern> Control.Monad
14:57:07 <dmhouse> haskellian: Control.Monad?
14:57:09 <dmhouse> ?index liftM
14:57:09 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:57:11 <dons> Control.Monad!
14:57:13 <gwern> @hoogle liftM
14:57:13 <lambdabot> A Hoogle error occurred.
14:57:18 <dmhouse> ?quote stereo
14:57:19 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
14:57:23 <dons> mwhaha
14:57:26 <sjanssen> gwern: so how is mueval going?  Any outstanding issues?  Can we look at replacing lambdabot's eval stuff with it?
14:57:27 <dons> meta-stereo
14:57:31 <dmhouse> Eurgh, metastereo quotes.
14:57:34 <jaj> dons: so I thought if nhc86 is able to compile 6.8 then you can update the ghc port without adding a new port
14:57:36 <gwern> sjanssen: actually, I'm doing that right now
14:57:43 <dmhouse> ... and stereo of "metastereo". :)
14:57:44 <newsham> haskellian: you can also compactly write:    put 1 >> put s >> put e1 >> put e2
14:57:45 <dons> jaj, yeah, it won't be able to though sadly.
14:57:53 * gwern notes that lambdabot has a way-too-long compile time
14:57:53 <sjanssen> gwern: nice
14:58:06 <nominolo> @remember dmhouse Eurgh, metastereo quotes.
14:58:06 <lambdabot> Done.
14:58:09 <sjanssen> gwern: yeah, I think we should turn off some plugins for the default build
14:58:13 <nominolo> for more meta-fun...
14:58:24 <dmhouse> Eurgh, (meta)*stereo quotes.
14:58:38 <newsham> put8 = put :: Put Word8     is useful to avoid lots of type decls
14:58:43 <luqui> hmmm.. how do we meta that one...
14:58:43 <sjanssen> @quote stereo
14:58:44 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
14:58:47 <sjanssen> @quote stereo
14:58:47 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
14:58:52 <dons> fix stereo
14:59:10 <dmhouse> dons: you meant fix meta stero?
14:59:19 <nominolo> @quote metastereo
14:59:20 <lambdabot> dmhouse says: Eurgh, metastereo quotes.
14:59:24 <sjanssen> newsham: I think that's in Data.Binary somewheres
14:59:52 <newsham> yup, putWord8,  huh.  danke sjanssen
15:00:25 <dons> sigfpe's stuff on knots is getting interesting.
15:00:33 <dmhouse> Has part one been posted? Ooh.
15:00:38 <dons> yeah.
15:00:42 <dons> a dsl for describing tangles
15:00:50 <dons> http://www.reddit.com/r/programming/comments/6wpk9/a_neighborhood_of_infinity_untangling_with/
15:00:53 <dmhouse> I'll save it for tomorrow's lunchtime, I think.
15:00:53 <lambdabot> Title: A Neighborhood of Infinity: Untangling with Continued Fractions: Part 1 : progra ..., http://tinyurl.com/5bjx7c
15:01:15 <bluestorm> dons: why don't you link to the URL directly ?
15:01:20 * ddarius would want to know about a formal language for describing real knots.
15:01:46 <dons> bluestorm: habit? reddit's always open.
15:01:57 <yitz> ddarius: algebraic topology does that
15:02:00 <QtPlatypus> ddarius: How is a real knot diffrent from a knot?
15:02:32 <ddarius> QtPlatypus: All real knots tied from a rope are trivial knot-theoretically.
15:03:16 <nominolo> are there knots that would work if there were no friction?
15:03:53 <ddarius> nominolo: The ones knot theory talks about would.
15:03:56 <dmhouse> nominolo: Yes, the standard half-hitch is an example, surely.
15:04:07 <dmhouse> If you pull the ends it gets tighter.
15:04:47 <ddarius> dmhouse: "tighter" doesn't mean much without friction.
15:05:29 <dmhouse> ddarius: if you pull on the ends it doesn't rely on friction to keep from coming undone.
15:05:36 <dmhouse> Wasn't that the question?
15:05:53 <nominolo> dmhouse: ah, so the key is "both"
15:06:22 <newsham> if you're pulling on both ends, do you need a knot?
15:06:29 <newsham> just drape a rope over a pole and hang onto both ends
15:06:36 <dmhouse> I suppose so.
15:06:48 <nominolo> newsham: heh, yeah, my thought's too
15:06:59 <nominolo> that's what i do to make sure i don't lose my keys ;)
15:07:09 <newsham> although might be hard to hold onto without the frictions
15:07:16 <dsrogers> what is a fixed point of a function?
15:07:26 <dmhouse> dsrogers: a point x such that f x = x
15:07:46 <newsham> ie. when the function converges after repeated application
15:07:58 <dmhouse> dsrogers: if you're reading about the fix function, see http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
15:08:00 <dsrogers> I read that definition half a dozen times and it didn't make sense until you said it.
15:08:16 <dsrogers> it's an eigenvalue.
15:08:27 <luqui> uh... except there's no scalar, and f isn't linear
15:08:34 <dmhouse> Err, ish. It's an eigenvector with eigenvalue one.
15:08:35 <nominolo> dsrogers: but it's used in many other contexts.  in particular smallest and largest fixpoints play a role in semantics
15:08:53 <dmhouse> But you don't have to be talking about vector functions, of course.
15:08:53 <ski> ddarius : hm, isn't there categories where the morphisms are braids .. could you represent your knots with such ?
15:09:05 <ddarius> dmhouse: If you fix both ends, then you get the tangles that sigfpe is talking about and yes there are non-trivial knots that correspond to that.
15:09:34 <dmhouse> dsrogers: if you think about f : A -> B moving all the points in A to those in B, then a fixed point is one that doesn't move when you apply f to it.
15:09:38 <newsham> ?let f g 0 = 1; f g n = n * g (n - 1)
15:09:40 <lambdabot> Defined.
15:09:52 <gwern> @tell Cale I'm sending a first stab at muevaling lambdabot; but I dunno why these 'resource vanished' error messages
15:09:53 <lambdabot> Consider it noted.
15:09:54 <newsham> > (f.f.f.f.f.f.undefined) 5
15:09:56 <lambdabot> Terminated
15:10:01 <luqui> dmhouse, f : A -> B... how can you have a fixed point when the dom and codom aren't the same?
15:10:02 <newsham> > (undefined.f.f.f.f.f.f.f) 5
15:10:04 <lambdabot> Terminated
15:10:07 <newsham> ugh
15:10:13 <dmhouse> Sorry, we do indeed need f : A -> A.
15:10:27 <newsham> > fix f 5
15:10:27 <haskellian> u were right it was intendation
15:10:29 <lambdabot> Terminated
15:10:30 <dmhouse> dsrogers: example: f is a rotation of the plane. You can picture the action of f by picturing the plane, then picturing it rotated. All points move under f except the origin, which is "fixed".
15:10:38 <dmhouse> > fix f 5 :: Expr
15:10:40 <lambdabot> Terminated
15:10:51 <dmhouse> > tak 20 show (fix f 5 :: Expr)
15:10:52 <lambdabot> Terminated
15:10:55 <dmhouse> > take 20 $ show (fix f 5 :: Expr)
15:10:56 <lambdabot> Terminated
15:11:13 <dsrogers> dmhouse: yeah.  I've dealt with vector calculus a lot before for "eigenvector" makes a lot of sense to me.
15:11:19 <luqui> so "fix" is Arnold Schwarzenegger?
15:11:22 <ddarius> This gives a good example of an eigenvector.  A rotation matrix fixes the axis of rotation which is the eigenvector.
15:11:39 <ddarius> > f
15:11:41 <lambdabot> Terminated
15:11:44 <dmhouse> ddarius: right, because that axis is an evector with evalue 1.
15:12:28 <dmhouse> ddarius: and to use the definitions, if v is an evector with evalue 1, then Av = 1*v, i.e. Av = v. Now if you write alpha(v) for Av, you get alpha(v) = v, which is the definition above.
15:12:36 <dmhouse> Err, s/ddarius/dsrogers/
15:12:51 <ddarius> @undefine
15:12:51 <ddarius> > fix f :: Expr
15:12:53 <lambdabot> Undefined.
15:12:54 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
15:13:21 <haskellian> hmm is serialization slow?
15:13:24 <dmhouse> No, wait, I did mean to speak to ddarius. Argh, I don't know.
15:13:37 <haskellian> finished, lets see results!
15:13:40 <ddarius> dmhouse: I hope not.  I already know all this hence me saying it.
15:13:46 <dmhouse> There are too many people with nicks beginning with 'd', they should all be culled.
15:13:52 <dons> let's do it!
15:13:54 <dons> wait. no.
15:14:14 <dmhouse> ddarius: yes, I kinda meant to build on what you said, and say it to dsrogers, I think. :)
15:14:36 <dyitz> dmhouse: please reconsider.
15:14:58 * ddarius will just use his other nick, DerekElkins... doh!
15:15:05 <user23> how come i cant divide two different instances of Fractional? like Double and DiffUTCTime
15:15:16 <ski> @type (/)
15:15:18 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:15:31 <ski> `(/)' takes two arguments of the same type
15:15:33 <haskellian> is this how it should look if i open in textpad? http://hpaste.org/9724
15:15:36 <dons> user23: you need to specify the conversion first.
15:15:38 <luqui> ddarius, capital Ds are fine, i think
15:15:52 <ddarius> luqui: Point.
15:16:00 <newsham> -- ?let fact g 0 = 1; fact g n = n * g (n - 1)
15:16:06 <newsham> > (fact $ fact $ fact $ fact $ fact $ fact undefined) 3
15:16:08 <lambdabot>  6
15:16:10 <newsham> > (fact $ fact $ fact $ fact $ fact $ fact undefined) 5
15:16:12 <lambdabot>  120
15:16:14 <newsham> > (fact $ fact $ fact $ fact $ fact $ fact undefined) 10
15:16:15 <dmhouse> user23: is one of them a literal?
15:16:16 <lambdabot>  Exception: Prelude.undefined
15:16:19 <user23> how do you do that for fractionals though? all i know of is fromIntger x :: Blah
15:16:23 <user23> dmhouse: nope
15:17:08 <dmhouse> There is also fromRational :: Num a => Rational -> a, which is used for converting literals with a decimal point, but I don't think that helps you here either. Interesting question.
15:17:29 <luqui> fromRational . toRational ?
15:17:41 <dmhouse> That's likely to be lossy.
15:18:18 <ski> hm .. does it make sense to have `DiffUTCTime' in `Fractional' ?
15:18:53 <dmhouse> Hoogle gives nothing helpful.
15:19:07 <user23> well mostly im just trying to convert some win32 specific code that uses queryperformancecounter to something platform neutral
15:19:14 <user23> im not entirely sure if Data.Time.Clock is the right way to go
15:19:22 <ski> (i.e., is the quotient of two time differences really a time difference ?)
15:19:40 <dmhouse> Not units-wise.
15:20:54 <ski> (possibly `(/)' is undefined, and there's separate scaling operation ..)
15:21:49 <dmhouse> ski: if (/) is undefined then the Fractional instance is mostly empty...
15:24:11 <explicitjelly> :t >>
15:24:15 <explicitjelly> :t (>>)
15:24:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:24:39 <geezusfreeek> fix fact 5
15:24:42 <geezusfreeek> ? fix fact 5
15:24:48 <geezusfreeek> > fix fact 5
15:24:50 <lambdabot>  120
15:24:53 <geezusfreeek> i suck
15:25:45 <geezusfreeek> oh i see that was the topic of discussion earlier anyway
15:28:28 <augustss_> hi
15:29:29 <ski> lo lennart
15:33:16 * tibbe is no longer stuck in his left fold :D
15:36:02 <hackage> Uploaded to hackage: maybench 0.1
15:37:24 <dons> tibbe++
15:37:54 <tibbe> dons: I have HTTP chunked encoding working using left folds
15:38:06 <tibbe> dons: my plan is to run the left folds using async I/O
15:39:10 <ski> employer : employee :: quantifier : ?
15:41:46 <eu-prleu-peupeu> haskell is best coded when listening to funk music
15:43:41 <ddarius> > tan (pi/8)
15:43:43 <lambdabot>  0.41421356237309503
15:43:55 <ddarius> > sqrt 2 - 1
15:43:57 <lambdabot>  0.41421356237309515
15:45:01 <ski> > (sqrt 2 - 1) - tan (pi/8)
15:45:03 <lambdabot>  1.1102230246251565e-16
15:45:15 <ski> > (sqrt 2 - 1) - tan (pi/8) :: CReal
15:45:17 <lambdabot>  0.0
15:49:06 <ddarius> > tan (3*pi/16)
15:49:08 <lambdabot>  0.6681786379192989
15:51:10 <TomMD> is there more than one Haskell mode for vim?  I thought I used one where the default mode had proper indenting and automatic '> ' marks for lhs.
15:53:23 <Olathe> > exp 1
15:53:25 <lambdabot>  2.718281828459045
15:53:55 <luqui> > 4*atan 1
15:53:57 <lambdabot>  3.141592653589793
15:54:24 <luqui> eu-prleu-peupeu, yes, it put the funk in funktion, as they say
15:58:21 <explicitjelly> :t foldM
15:58:23 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:58:26 <explicitjelly> :t foldlM
15:58:29 <explicitjelly> :t foldrM
15:58:35 <explicitjelly> :t foldMl
16:02:01 <stepcut> @pl (\x y -> distribute (Product x y))
16:02:02 <lambdabot> (distribute .) . Product
16:02:08 <stepcut> ugh
16:02:33 <bd_> @hoogle mkNorepType
16:02:33 <lambdabot> A Hoogle error occurred.
16:02:36 <bd_> :|
16:02:52 <noecksit> i dont know why but for some reason i can't push my repository to the server anymore, it says "Identifying repository format" and then asks me for a password
16:03:07 <ski> distribute .: Product
16:03:13 <ski> (.:) = (.) . (.)
16:03:37 <noecksit> is it "darcs push username@server:~/dir" or "darcs push username@server:dir"?
16:07:27 <ddarius> > let x = 3 - sqrt 2 in x / (1+x)
16:07:29 <lambdabot>  0.6132704598304931
16:08:03 <ddarius> > let x = 3 - 2*sqrt 2 in x / (1+x)
16:08:05 <lambdabot>  0.1464466094067261
16:08:20 <dons> araujo: the web site for himerge is lovely
16:08:28 <dons> i think we should redo xmonad.org along those lines.
16:08:52 <ddarius> Link?
16:09:07 <dons> http://www.haskell.org/himerge/
16:09:08 <lambdabot> Title: Himerge
16:10:02 <ddarius> It's lightweight.  I like it.
16:10:19 <wjt> dons: something along those lines that fits on a 1024-pixel wide screen :P
16:10:38 <dons> wjt, indeed.
16:10:49 <dons> ddarius: right. it has the same content as xmonad.org, but structured a little less hard core
16:16:12 <araujo> dons, :-D
16:16:14 <araujo> dons, Thanks!
16:16:38 <araujo> dons, I wanted something simple and handy as possible, it's based on a public template
16:17:28 <haskellian> help on decoding serialized file: http://hpaste.org/9726
16:17:53 <dons> haskellian: decodeFile is an io actoin
16:18:37 <dons> main = do let src = "C:/users/saftarn/desktop/netflixtest/binserial.txt" x <- decodeFile src print "done"
16:18:40 <dons> grr.
16:19:03 <dons> http://hpaste.org/9726#a1
16:19:35 <newsham> also decodeFile can decode many formats, you need to specify the result type
16:19:48 <newsham> x <- Bi.decodeFile fromFile :: [Customer]
16:19:53 <newsham> x <- Bi.decodeFile fromFile :: IO [Customer]
16:20:27 <dons> and yes, you'll need to specify the type of the data you're reading.
16:24:56 <davidL> is there any haskell interface to PAM?
16:25:23 <dons> http://www.haskell.org/pipermail/haskell/2005-October/016564.html ?
16:25:24 <lambdabot> Title: [Haskell] ANNOUNCE: pam-1.0
16:25:36 <dons> needs updating.
16:25:50 <dons> i'll stick it on hackage.
16:25:51 <davidL> ah, thanks
16:30:05 <eu-prleu-peupeu> is there any SOAP haskell module ?
16:30:36 <eu-prleu-peupeu> or some framework to ease the development of web services in haskell ?
16:30:49 <dons> hmm. it's somewhat bit rotted, davidL
16:31:47 <dons> eu-prleu-peupeu: there's lots of web service stuff.
16:31:51 <dons> see hackage.haskell.org
16:32:00 <dons> everything from low level to complete standalone frameworks.
16:32:02 <davidL> dons: to the point where it's easier to just start fresh?
16:32:13 <dons> davidL: hmm. no, but you'll need to fix some errors in the binding.
16:32:19 <dons> let me post an amended darcs repo
16:32:23 <dons> and you can have a play with it
16:32:25 <stepcut> eu-prleu-peupeu: there was a master's thesis on SOAP, but I am not sure if there are any production ready SOAP modules
16:32:45 <stepcut> eu-prleu-peupeu: there is a lots of other non-SOAP web frameworks, if you don't need SOAP specifically
16:33:08 <eu-prleu-peupeu> hmm, its nothing professional, i just started thinking on ways to earn money coding haskell :P
16:34:27 <chrisdone> two IO threads can read and write to the same socket, right? one thread can be waiting for data, and another can write to it?
16:34:29 <eu-prleu-peupeu> hmm, well, i was thinking about wsdl, soap, and uddi
16:35:00 <dons> davidL: $ darcs get http://code.haskell.org/~dons/code/forks/pam
16:35:01 <lambdabot> Title: Pam bindings for haskell
16:35:18 <dons> i updated it to at least start to build, but you can hunt down the remaining errors, if you like.
16:35:52 <chrisdone> actually I guess my question should really be s/socket/Handle
16:35:54 <davidL> sounds good, thanks
16:36:00 <stepcut> dons: how's the xmonad port to F# going?
16:36:18 <chrisdone> stepcut: that cracks me up
16:37:47 <stepcut> I've been meaning to thank Harrop for all his hard work. Haskell's charter is to avoid success at all costs, and quite frankly, we've been doing a pretty poor job this past few years
16:37:59 <stepcut> the mailing lists have been growing, the irc channel is growing
16:38:15 <stepcut> we made it much easier to install 3rd party libraries
16:38:23 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#t%3AHandle
16:38:24 <stepcut> all around, we are getting to close to success
16:38:25 <lambdabot> Title: System.IO, http://tinyurl.com/sbkmj
16:38:25 <haskellian> wooooooot it is working
16:38:28 <chrisdone> doesn't say whether handles are threadsafe
16:38:28 <haskellian> thank you so much
16:38:48 <haskellian> foldl (thank you) 1 [1..]
16:39:09 <dons> stepcut: hah
16:39:19 <dibblego> haskellian, foldl won't terminate on [1..] :)
16:39:33 <haskellian> thats the point, i am forever grateful
16:39:44 <explicitjelly> huh. stupid question: I've got a stack overflow and I want to know where
16:39:53 <explicitjelly> i.e. I want the stack trace
16:39:59 <explicitjelly> ghc.
16:40:03 <stepcut> but, I for one, and not willing to give up the advancements of the compiler in the last few years, so our only hope is that outsiders don't find out what we really have
16:40:11 <chrisdone> where can I find out if reading/writing to a Handle is threadsafe?
16:40:18 <dons> explicitjelly: it's a little tricky. one way is to compile with profiling, -prof -auto-all
16:40:21 <dons> then run with +RTS -p
16:40:27 <dons> you'll get a profiling log of what's allocating
16:40:32 <dons> chrisdone: it's thread safe
16:40:35 <explicitjelly> not built for: -prof or -parallel
16:40:39 <explicitjelly> ah, ok
16:40:51 <dons> each Handle has an MVar lock, preventing races. only one thread can take the handle at a time.
16:40:53 <chrisdone> dons: should that be documented anywhere or are all standard thingies assumed to be threadsafe?
16:41:04 <dons> the standard thingies are assumed to be, yeah.
16:41:09 <chrisdone> ah..
16:41:11 <dons> there'll be explicit discussions if that's not the case.
16:41:27 <chrisdone> thanks
16:41:47 <dons> we'd have missed the point of haskell if it wasn't be default full of persistant, thread safe code
16:43:12 <chrisdone> I better use nonblocking functions then
16:43:32 <explicitjelly> dons, what's -auto-all for?
16:43:45 <dons> explicitjelly: it inserts profiling points "cost centres" automatically on top level things
16:43:52 <dons> otherwise you have to do them yourself.
16:44:22 <explicitjelly> ah, nice.
16:44:33 <chrisdone> I see that I don't have to tell ghci to be -threaded when I load my code, but I do have to tell ghc. what's all that about?
16:44:40 <explicitjelly> dons, how do you suggest using the output? looking at what allocated most, or what?
16:45:30 <ddarius> > 0.5 + (3/2 - sqrt 2) * (3/4 - (sqrt 2 + 1) / 2)
16:45:32 <lambdabot>  0.460786437626905
16:46:19 <dons> explicitjelly: yes, and what was on top of the call stack when you ran out of memory
16:46:42 <ddarius> > 0.5 + (3/2 - sqrt 2) * (3/4 - (3 - sqrt 2) / 2)
16:46:45 <lambdabot>  0.4963203435596426
16:46:55 <ddarius> > 0.5 + (3/2 - sqrt 2) * (3/4 + (3 - sqrt 2) / 2)
16:46:57 <lambdabot>  0.6323593128807147
16:47:10 <explicitjelly> dons, hmm. where is the call stack?
16:48:58 <dons> you've got a .prof file now?
16:49:04 <explicitjelly> yes.
16:49:43 <dons> could you hpaste.org it?
16:49:47 <explicitjelly> yes!
16:50:48 <explicitjelly> dons, it's truncated: http://hpaste.org/9727
16:51:15 <explicitjelly> dons, but there's just that list that continues, nothing new afterwards
16:51:45 <dons> so you can trace the call stack from main
16:51:53 <dons> that was with -auto-all ?
16:51:55 <explicitjelly> ah, the second list is the call stack?
16:51:56 <eu-prleu-peupeu> can someone please help me with this code: http://hpaste.org/9728
16:51:58 <explicitjelly> that was with auto-all.
16:52:01 <eu-prleu-peupeu> why does ghci complaints ? :(
16:52:05 <dons> explicitjelly: it shows the call stack, yeah.
16:52:18 <dons> explicitjelly: the next thing you could try would be to compile with -fhpc and examine the code coverage
16:52:27 <dons> the point at which it failed should be coloured bright yellow
16:52:31 <lispy> eu-prleu-peupeu: an unfortunate misfeature of the record system
16:52:40 <lispy> eu-prleu-peupeu: the fields have global scope within the module
16:52:47 <esteth> hmm. I have a [[Piece]] type, and I want to map over each piece, not each [Piece]. How would I do that? Would I need to do something like map (map ...) list ?
16:52:57 <eu-prleu-peupeu> lispy: ouch ... :(
16:52:58 <ddarius> > 39/8 - 3*sqrt 2
16:52:59 <rwbarton> esteth: precisely
16:53:00 <lambdabot>  0.6323593128807143
16:53:01 <eu-prleu-peupeu> is there any extension ?
16:53:01 <dons> esteth: maybe a list comprehensions?
16:53:28 <explicitjelly> dons, the tix file? how do I use it?
16:53:34 <lispy> eu-prleu-peupeu: aye, one solution is to use multiple modules for the data declarations, then import them all into one module usng qualified imports and write their utility funtions there
16:53:44 <eu-prleu-peupeu> okey
16:53:45 <dons> explicitjelly: so hpc you use as follows: compile with -fhpc and run the program
16:53:48 <dons> this generates a .tix file
16:53:54 <dons> containing counts for everything that was evaluated.
16:53:55 <explicitjelly> got that
16:54:00 <esteth> rwbarton, Wow. I assumed there'd be more steps to it than that. Remarkably simple :)
16:54:02 <dons> if you then say: hpc markup foo.tix
16:54:07 <dons> you'll get .html files for all your source.
16:54:11 <eu-prleu-peupeu> seems good, ill have several files, a class specification file, and one for each instance of it... nice
16:54:19 <dons> load those up in the browser, and you can see what code was actually executed.
16:54:25 <explicitjelly> dons, pretty. thanks!
16:54:32 <lispy> eu-prleu-peupeu: other solutions include, putting x, y, z, etc into type classes
16:54:47 <eu-prleu-peupeu> lispy: how is that ?
16:54:49 <dons> i actually like this hpc approach for finding failure points.
16:55:00 <dons> it seems pretty reliable -- just hunt for partial functions
16:55:06 <lispy> eu-prleu-peupeu: it's not such a good way to go actually
16:55:13 <explicitjelly> dons, there's a lot of bright yellow stuff...
16:55:19 <dons> so that's dead code.
16:55:21 <eu-prleu-peupeu> okey, ill skip it then, thanks lispy ;)
16:55:21 <dons> look for main,
16:55:27 <dons> and walk through the white code
16:55:39 <dons> until you see some function that's enterered, but never left.
16:55:54 <dons> maybe use the .prof output to guide you
16:55:57 <explicitjelly> dons, ah, so the yellow stuff is code that hasn't been covered?
16:56:00 <dons> yep
16:56:03 <dons> dead code.
16:56:06 <explicitjelly> thanks.
16:56:10 <dons> for that particular program run.
16:56:17 <eu-prleu-peupeu> okey, time to feed the baby kitten, and go to sleep, bye bye people from planet haskell, and thanks
16:56:41 <Pseudonym> Awwww... baby kitten...
16:56:44 <Pseudonym> Not enough of that on #haskell.
16:57:01 <noecksit> omg my head hurts
16:57:10 <noecksit> way too much time on the comp
17:02:00 <explicitjelly> dons, what does red and green code mean?
17:02:28 <ddarius> newsham: Your question seems thoroughly answered.
17:04:18 <chrisdone> @hoogle IO a -> IO ()
17:04:18 <lambdabot> A Hoogle error occurred.
17:04:22 <chrisdone> O_O
17:04:49 <dons> explicitjelly: red is always False conditionals, and green are always True
17:06:20 * lispy is rather annoyed that pattern matches that bind existential types are not allowed in where clauses
17:10:07 <chrisdone> zot = (\a -> let z = compute a in \b -> ...), biz = (\a b -> let z = compute a in ...), partially applying zot can allow for z to be cached, throught multiple calls, right? whereas biz has to recompute z every single time
17:12:18 <dons> newsham: so did you make progress with your decodeFile issue last week?
17:12:33 <stepcut> do all sets have an = relation?
17:12:57 <lispy> stepcut: mathematically or haskelly?
17:13:04 <stepcut> lispy: mathematically
17:13:23 <lispy> stepcut: it seems like all objects in math have an identity
17:13:24 <chrisdone> for some reason lilac thought subRegex could cache the match from the regex and input through multiple calls with different replacement strings
17:13:51 <stepcut> lispy: so a group with <= is a 'ordered group'. I am wonder what the name for the thing with only a '=' relation is ?
17:14:04 <stepcut> lispy: i thinking that is just a set
17:14:21 <gcarrier> glguy: do you even see my messages?
17:14:25 <lispy> stepcut: I think a set is one such example, but we could come up with others
17:14:41 <lispy> stepcut: like a multiset
17:15:16 <lispy> stepcut: a multiset is like a set, except that the membership function tells you how many times that thing is in the set instead of just yes/no
17:15:22 <stepcut> lispy: yeah. in hierarchy of, monoid -> group -> rng -> ring -> field, I am trying to figure out what is more basic than a monoid (in abstract algebra terms)
17:15:52 <stepcut> lispy: and also figure out how relations come into play in Abstract Algebra
17:16:22 <lispy> stepcut: I see.  Well, I a set is a fair example to use here.
17:16:28 <lispy> "I think"*
17:18:43 <stepcut> lispy: I currently have classes like, class Monoid a where (<+>) :: a -> a -> a, zero :: a. For 'ordered groups' I could add, class (Group a) => OrderedGroup a where (.<=.) :: a -> a -> Bool. But if I do that, then it seems like I should have a class where I introduce the .==. operator as well.
17:23:47 <noecksit> could anyone give me any idea how i can parse foreign letters using parsec?
17:24:27 <noecksit> in my input, i have for Info information about a player, however most of the players are japanese and the string becomes really weird
17:24:29 <stepcut> noecksit: as in utf-8 characters ?
17:24:46 <noecksit> stepcut: yeah, i think so
17:25:17 <stepcut> noecksit: if the encoding is utf-8 then it should be straight forward. If the encoding varies, then I suspect it is a fair bit trickier
17:25:45 <stepcut> noecksit: how do you currently get the String you are parsing into your application ?
17:26:06 <noecksit> stepcut: it comes in through a socket connection
17:26:40 <stepcut> noecksit: and you do something like, hGetContents handleForTheSocket, to turn it into a String ?
17:28:01 <dons> noecksit: so something like utf8-string to do the IO, then parse with parsec as usual
17:28:07 <stepcut> noecksit: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.3.1.1
17:28:09 <noecksit> stepcut: i use hGetLine from the Handle that i use from connectTo
17:28:09 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/5npojm
17:28:49 <stepcut> noecksit: ok, your problem is that hGetLine is the standard libraries is not utf-8 aware. But utf8-string has drop in replacements which are.
17:30:29 <stepcut> noecksit: in Haskell, Char is supposed to hold a utf-8 code point. So, parsec shouldn't know the difference.
17:30:38 <stepcut> noecksit: (sorry, a Unicode code point)
17:31:21 <stepcut> noecksit: but the data you are reading from the socket is utf-8 encoded, and you currently have no step where the utf-8 encoded data is converted to proper unicode characters.
17:31:56 <stepcut> noecksit: also, when you write the data back out, you have to ensure that the encoding is correct as well, because putStrLn and friends are also not utf-8 aware.
17:32:41 <stepcut> noecksit: utf8-string should contain everything you need. In addition to utf-8 aware hGetLine, putStrLn, it also have encode/decode functions for String -> String, ByteString -> ByteString, etc.
17:33:17 <noecksit>  stepcut : ok thanx that seems what i need
17:33:25 <stepcut> well, maybe not ByteString -> ByteString that does not make any sense
17:34:33 <stepcut> noecksit: if the characters are encoded using something else, like EUC-JP, then you could use iconv instead. But utf8-string is superior for utf-8 only apps
17:34:37 <noecksit>  stepcut : what would happen to the weird characters when they are encoded in utf-8? right now they are shown as a bunch of \123\234e\159 numbers
17:34:49 <stepcut> noecksit: how are you showing them ?
17:35:13 <noecksit> stepcut: i output stdout to a file
17:36:17 <stepcut> noecksit: if you use the utf8-string library for input and output, then you should see the unicode glyphs for the characters in the file, not \xxx
17:37:15 <rwbarton> noecksit: you should only be seeing \xxx if you're using show or print though
17:37:45 <stepcut> noecksit: ASCII characters (0-127), have the same bit representation in ASCII and utf-8. Characters higher than 127 get encoded using multiple bytes.
17:38:17 <noecksit> stepcut: no, im sorry, i havent installed utf8-string library yet, ill try to use System.IO.UTF8's hGetLine and see how it looks
17:39:34 <dons> noecksit: cabal install utf8-string
17:39:34 <dons> done.
17:40:00 <stepcut> rwbarton: or a viewer that shows them that way ? If the first character is ", that would be a good sign that show was called at least one too many times.
17:40:40 <rwbarton> yeah, the first step is definitely to understand what the viewer is saying
17:43:07 <noecksit> i guess i should get cabal-install after all
17:43:14 <dcoutts> indeed
17:43:25 * dcoutts is about to do a new cabal-install release
17:43:30 <dcoutts> noecksit: but don't wait
17:43:55 * stepcut waits for cabal-uninstall
17:44:09 <dcoutts> stepcut: don't wait, send patches! :-)
17:44:36 <stepcut> dcoutts: heh, my patch is to use cabal-debian to debianize the library so I can do dpkg --remove ;)
17:44:48 <dcoutts> excellent
17:47:16 <reilly> when I step away from haskell for a while, certain things leak away from my brain.  this is true with almost any language.  the problem that I have is that one of the things that leaks away is the operator precedence rules.  That makes haskell unreadable until i get them back.  I've long thought that an ideal haskell learning tool would be "Show Precedence" in an expression --- it rewrites the current expression with all the "implicit p
17:48:16 <dons> dcoutts: exciting.
17:48:21 <dons> dcoutts: will this have logging?
17:48:42 <reilly> my brain needs logging
17:48:44 <stepcut> reilly: just write Haskell code everyday, that's what I do...
17:48:49 <bos> wow, ghci is segfaulting on me.
17:49:01 <reilly> stepcut: i wish i could
17:49:06 <dons> bos, not good.
17:49:10 <dcoutts> dons: the current version has logging
17:49:16 <stepcut> bos: you broke it
17:49:19 <bos> dons: it seems to be allergic to alwaysSucceeds
17:49:20 <dcoutts> dons: or do you mean the more detailed build reports ?
17:49:25 <dons> dcoutts: 1.4.x?
17:49:28 <dons> or 1.5.x i mean
17:49:40 <dcoutts> dons: Cabal 1.4.0.2 and cabal-install-0.5.2
17:49:53 <dons> oh, maybe i need to update the arch package.
17:50:02 <dcoutts> dons: I've not released them yet :-)
17:50:05 <dons> dcoutts: will you do us the favour of a nice well-typed/blog write up about the cabal work?
17:50:13 <dcoutts> yep
17:50:17 <dons> with ref. to the platform project
17:50:18 <noecksit> hmm, the aur in archlinux for cabal-install is a little broken, maybe because it cant manually install aurs it is dependant on
17:50:23 <dons> noecksit: hmm?
17:50:23 <dcoutts> dons: ah that too
17:50:35 <dons> noecksit: oh, on AUR in general, you mean.
17:50:48 <dons> noecksit: yes, we need to move cabal-install into the community
17:50:52 <dcoutts> dons: make sure your cabal-install arch package is installing the bash-completion support, that's sooo useful
17:50:52 <dons> *or* you can use the overlay
17:51:04 <noecksit> dons: you have to hunt down haskell-http and haskell-zlib manually
17:51:17 <dons> noecksit: oh, they're not listed in the web interface?
17:51:36 <dons> ah so they're not. they "build depends"
17:51:47 <dons> and the silly web interface doesn't list those as true deps.
17:52:08 <dons> noecksit: i think yoghurt let's you install deps from aur
17:59:22 <jsnx> is there a special name for a DAG where each is uniquely identified by its start and end points?
17:59:31 <jsnx> s/each/each edge/
18:00:43 <bos> @pl addBalance a b = (a +) `liftM` readTVar (balance b)
18:00:44 <lambdabot> addBalance = (. (readTVar . balance)) . fmap . (+)
18:00:48 <bos> bleh.
18:00:56 <Philonous> a tree?
18:01:08 <slava> jsnx: a DAG that is not a multi-graph?
18:02:04 <jsnx> Philonous: well, that's if each *path* is unique in its endpoints
18:02:47 <jsnx> slava: thank you
18:02:49 <Philonous> Oh right.
18:03:17 <Philonous> sorry
18:03:58 <dons> bos, we don't have a chapter on obfuscation? :)
18:04:19 <bos> the closest i could come was applicative functors, sorry.
18:04:27 <dons> a <note> on point free might be fun to drop in somewhere.
18:04:31 <bos> <* <$>
18:04:34 <dons> a bit of light relief during a heavy section.
18:04:42 <bos> i believe there's something about point free style.
18:04:45 <gnut> hi all
18:05:02 <dons> yeah, a little
18:05:18 <lispy> gnut: hi and welcome to #haskell :)
18:05:22 <gnut> anyone here try project fortress?
18:05:27 <gnut> lispy: hello.
18:05:37 * lispy googles it
18:05:42 <dons> gnut: i've not heard much.
18:06:14 <gnut> dons: they finally have 1.0 out. but i'm also lamenting the fact that it's not FP
18:06:43 <lispy> gnut: hrm...not fp
18:06:54 <lispy> gnut: yet implicit paralellism?
18:07:05 <gnut> I don't know how thing are implemented
18:07:11 <dons> for loops :)
18:07:21 <gnut> yeah
18:07:28 <gnut> that's right. they mention for loops a lot :)
18:07:54 <lispy> "Flexible, space-aware, mathematical syntax"
18:08:24 <gnut> and work stealing
18:08:42 <lispy> it sounds like something people in the computational sciences would like
18:08:45 <gnut> the mathematical syntax part is cool sounding... though you may need a special editor to make it look cool, otherwise, it's just all ASCII
18:08:55 <gnut> I am in the computational sciences :)
18:10:00 <lispy> space sensitive seems to mean that "- 1" us subtract 1, and "-1" is negate 1
18:10:45 <gnut> and context-sensitive parsing... so depending on whether something is known to be a function, it could be application or multiplication
18:11:28 <lispy> that's interesting, I wonder if people will find that inuitive or not
18:12:04 <Philonous> Sounds like it is hard to read
18:12:41 <sfultong> is there something builtin for... forever = sequence_ . repeat ?
18:12:47 <dons> ?src forever
18:12:47 <lambdabot> Source not found.
18:12:51 <lispy> ?hoogle forever
18:12:52 <lambdabot> A Hoogle error occurred.
18:12:54 <dons> it's in recent Control.Monad
18:12:55 <lispy> oy
18:12:57 <dons> man, that all sucks
18:13:05 <rwbarton> @type forever
18:13:06 <sfultong> huh... so that has been invented
18:13:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:13:10 <lispy> preflex: seen cale
18:13:11 <preflex>  cale was last seen on #haskell 3 days, 3 hours, 37 minutes and 30 seconds ago, saying: hehehe
18:13:13 <dons> sfultong: forever a = a >> forever a
18:13:21 <newsham> dons: re decodeFile -- yah, I implemented decodeFully which checks for EOF, and the file handle is being closed properly now.
18:13:27 <lispy> whoa, cale has been off irce for 3+ days???
18:13:32 <lispy> I hope he's okay
18:13:49 <dons> newsham: so i'm thinking of adding: v <- get ; m <- isEmpty ; m `seq` return v
18:13:59 <dons> so if you're at EOF, decodeFile will close.
18:14:26 <sfultong> dons: yeah, but that definition is all... recursivey and stuff :-P
18:14:35 <dons> sfultong: yeah, loops are loopy
18:14:49 <dons> no one understands loops.
18:14:55 <dons> let's use combinators instead.
18:15:06 <sfultong> yay!
18:15:18 <lispy> :t fixM
18:15:23 <newsham> dons: i think that makes sense..  although i think it also makes sense to have a combinator for checking and error/fail/whatever on non-eof (ie "fully")
18:16:12 <lispy> this matter of freeing the resource (the file handle) and lazy IO is very problematic for large programs
18:16:28 <lispy> I really do think we need a better solution
18:17:05 <dons> it's really a rather specific problem, streaming, lazy io is good for.
18:17:12 <dons> rather than a general strategy for all io.
18:17:18 <newsham> sometimes it makes sense for APIs to close the file handle as soon as the last byte is read, rather than when the next byte is read.
18:17:21 <dons> i'm not sure why this wasn't recognised earlier.
18:17:24 <dons> like 15 years ago earlier.
18:17:31 <newsham> ie. if "readFile" closed after you consumed the final byte
18:18:06 <lispy> one problem that came up in darcs, is that if you use lazy io to stream many files at once, you run out of handles
18:18:16 <dons> definitely.
18:18:20 <lispy> so I'm not even sure it's so great for streaming
18:18:21 <dons> does darcs do strict io now?
18:18:28 <dons> well, it's a great abstraction for streaming.
18:18:39 <dons> those one line terabyte filters are megafun
18:18:42 * stepcut has accidently used up all the handles on more than one occasion
18:18:47 <newsham> even in imperative style coding you have to be careful about handling many file descriptors, though.
18:19:03 <lispy> dons: yeah, I think file reads and stuff are strict now but there is so much code it's hard tell
18:19:14 <rwbarton> crazy idea: maybe haskell should manage its own file descriptors, the same way it manages its own threads ("green threads")
18:19:31 <lispy> rwbarton: that's a very interesting idea
18:19:54 <Philonous> I wish haskell had a construct like with-open-file
18:19:57 <lispy> rwbarton: but it does seem problematic, in some cases you may have to keep reopening and doing an fseek
18:20:00 <dons> Philonous: withFile ?
18:20:01 <stepcut> in fact, we should just do away with the OS altogether and run Haskell on the bare metal ;)
18:20:05 <bos> pop quiz. if you try to use STM inside ghci, will it (a) crash (b) go into an infinite loop (c) produce the right answer or (d) all of the above.
18:20:06 <dons> :t withFile
18:20:08 <newsham> that sounds attractive until you start thinking of non-file things that act like files, and side effects due to openning and closing
18:20:16 <stepcut> bos: d
18:20:16 <dons> bos, i vote for (d).
18:20:23 <newsham> lets say you pretend the file is opened but you really close it, and then reopen it later to do more reading
18:20:26 <dons> particularly for 6.8.2
18:20:27 <newsham> in the meantime the ifle perms change
18:20:27 <newsham> oops
18:20:29 <dons> or was it 6.8.1
18:20:35 <bos> i'm afraid the voters for d have won!
18:20:39 <dons> :(
18:20:45 <Philonous> dons Oh, does that close the file afterwards?
18:21:00 <dons> Philonous: yep
18:21:01 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
18:21:01 <dons> withFile name mode = bracket (openFile name mode) hClose
18:21:06 <dons> hofs for the win.
18:21:22 <Philonous> Thanks
18:21:30 <sjanssen> is anyone using X11 on a Mac?  Can you please tell me what 'echo $DISPLAY' returns in an xterm?
18:22:02 <lispy> $ echo $DISPLAY
18:22:06 <lispy> doh
18:22:14 <rwbarton> sjanssen:   :0.0
18:22:19 <lispy>  /tmp/launch-ojzXVl/:0
18:22:33 <lispy> I couldn't paste it because it started with a / :)
18:23:03 <sjanssen> rwbarton, lispy: thanks
18:23:45 <newsham> lispy: / /foo/bar
18:23:47 <newsham> /foo/bar
18:24:25 <lispy> newsham: cool, I just added a space
18:24:50 <sfultong> / hey, I didn't know that
18:25:41 <lispy> dons: in the case of darcs we have 2 primary problems with the lazy io, either we accidentally demanded the end of the IO and got more than we could handle, or we opened up files and didn't close then before opening lots more
18:26:04 <lispy> dons: and I think the big problem with the first one is that sometimes you just don't realize you're composing strict + lazy
18:26:14 <lispy> in a large program it just gets away from you
18:26:36 <lispy> in the second case, maybe streams wouldn't help because those you have to keep track of too
18:27:56 <lispy> just goes to show that even haskell doesn't make programming trivial :)
18:28:12 <newsham> programming: still not trivial.
18:28:18 <bos> i just finished writing the chapter on STM.
18:28:30 <lispy> bos: congrats
18:28:31 <dons> woot!
18:28:32 <bos> that means my part of writing RWH is now done. YAY!
18:28:37 <lispy> bos: there is beer in the fridge, want one?
18:28:47 <dons> so we have only half a chapter left now. exciting.
18:28:56 <bos> i've got a beer open right next to me - this is why it's been such a productive afternoon!
18:29:01 <newsham> sweet, soon we can give you guys money
18:29:11 <lispy> maybe I should go preorder now
18:29:18 <dons> bos, how big is it?
18:29:20 <bos> lispy: hold off a bit.
18:29:23 * sjanssen doesn't like transcribing C code
18:29:26 * dons wonders idly if we'll hit 500 words... 
18:29:33 <dons> 500 pages i mean :)
18:29:47 <bos> dons: $ wc ch29-stm.xml
18:29:47 <bos>   641  3042 24267 ch29-stm.xml
18:29:57 <dons> ok, that's good.
18:30:12 <bos> also including a code example that's 250 lines long, and another that's about 100.
18:30:23 <bos> so it's about 1000 lines total.
18:30:46 <bos> that's about 3% of the total page count.
18:30:57 <bos> er, total line count.
18:31:03 <lispy> bos: hehe, you guys do have an amazon page already though.  Which is kinda cool. I could go rate your book now if I wanted to
18:31:22 <newsham> amazon is giving you a special deal if you buy it with a fantasy/sci fi book
18:31:23 <bos> lispy: i've got links through our associates doodad on realworldhaskell.org now.
18:31:29 <newsham> haskell is just that futuristic
18:31:31 <sfultong> hey, what's the status on developer mindshare in darcs?  I wonder if all the reddit anti-hype is a positive or negative factor
18:31:36 <bos> that way, we earn ever so slightly more pfennigs.
18:31:47 <bos> sfultong: trending towards zero.
18:32:06 <lispy> bos: assuming you make your current deadline, when is it expected to hit shelves?
18:32:21 <dons> i think we can be pretty accurate now with the forecast.
18:32:29 <bos> we can?
18:32:31 <lispy> bos: hey no, not trending towards zero
18:32:37 <bos> i don't know what the last we heard is.
18:32:45 <dons> Oct 15, iirc.
18:32:58 <dons> so the unknown is the copy edit.
18:33:00 <lispy> sfultong: darcs is currently having a lot of developer activity
18:33:06 <dons> o'reilly is a black box.
18:33:10 <dons> xml in, paper out.
18:33:50 <sfultong> lispy: good to hear!  is the codebase becoming more friendly to newcomers?
18:33:57 <lispy> sfultong: not sure how to answer your question exactly.  David is still the authority on patch theory, but I've learned a ton recently about the code base and understand a fair bit of the theory
18:33:59 <cjs> How does cabal determine the version of haddock?
18:34:21 <dons> cjs, cabal doesn't care about the haddock version, does it?
18:34:27 <lispy> sfultong: we're working on that.  I've put in a lot of effort to increase the amount of machine checkable documentation as phase0 of that.
18:34:38 <cjs> It does if you "runhaskell Setup.lhs haddock" on QuickCheck. :-)
18:34:54 <lispy> sfultong: we still need more haddocks though
18:35:18 <cjs> I've broken something in my build system, sad to say, and that command can't seem to find my project packages.conf file.
18:35:36 <dcoutts> dons: it's quite different calling haddock 0.x vs 2.x and some features can only be used with a minumum version
18:35:52 <dons> ah, so you do do something clever?
18:35:55 <dcoutts> cjs: it calls haddock --version
18:36:36 <cjs> Hm. Really?haddock is in my path.
18:36:38 <dcoutts> dons: heh, I dunno about it being clever
18:37:35 <dcoutts> cjs: cabal only looks for progs at configure time, so if you change installed progs then you have to re-configure
18:37:49 <dcoutts> cjs: you can see what versions it finds and where if you use cabal configure -v
18:38:45 <cjs> Ah, thanks.
18:40:05 <lispy> sfultong: also, Igloo has been writing about patch theory a bit again, trying to get a doc that is up to date with the new repo formats
18:40:20 <lispy> sfultong: (understand patch theory was identified as a big reason people don't grok the darcs source)
18:40:56 <dons> lispy: "theory" considered bad. git's got some terribly complicated theory, but they don't talk about it, so no one thinks it is hard
18:41:08 <dons> darcs talks about their model, calls it theory, people run away screaming.
18:41:10 <dons> see also "monads"
18:41:41 <sfultong> I should add patch theory to my ever-growing list of things to read up on
18:42:12 <lispy> dons: yup
18:42:48 <lispy> dons: not sure what can be done about it at this point though...
18:42:55 <cjs> This is odd. The release/bin directory is in my path, and that release dir is also the prefix, haddock is in that bin dir, yet configure -v claims that it's not found.
18:46:10 <cjs> And ktrace shows it going through everything in my path except the release/bin dir. Very odd.
18:46:38 <dcoutts> cjs: is the path up to date in that session?
18:46:41 <cjs> But if you give it a prefix for the install, it doesn't look in prefix/bin to run stuff?
18:46:53 <cjs> It is; I'm printing it out just before I run setup, to confirm it.
18:47:05 <dcoutts> cjs: it only looks in the $PATH
18:47:38 <cjs> Oh, wait, I just realized the issue. Argh.
18:47:49 <dcoutts> cjs: it uses System.Directory.findExecutable
18:48:31 <cjs> I've got wrappers for runhaskell, ghci, etc. in release/bin, that add the appropriate opts to use the package db in the release dir.
18:48:51 <cjs> But that strips off the release/bin dir from the path in order to run the "real" runhaskell, etc.
18:49:17 <cjs> So I really need to be leaving the path alone and searching for that binary in a different way.
18:49:22 <cjs> That should be fun in a shell script.
18:49:34 <cjs> Maybe I should just be using the darn environment variable instead.
18:49:37 * luqui wishes darcs were a little more explicit about their theory
18:49:43 <luqui> the handwaving is what bugs me.
18:50:16 <dons> luqui: what about git , svn or cvs?
18:50:29 <dons> isn't darcs more up front about assigning a model than usual?
18:50:30 <lispy> luqui: you're welcome to join #darcs-theory, the /topic has some links (Igloo has been trying un-hand-wavey it)
18:50:38 <cjs> svn doesn't need patch theory.
18:50:55 <dons> the model's certainly richer in darcs case.
18:51:16 <lispy> darcs has a high minimum complexity internally
18:51:22 <dons> dcoutts: someone should translate this into a nice cairo ap, http://alaska-kamtchatka.blogspot.com/2008/08/aperiodic-tilings.html
18:51:24 <lambdabot> Title: Alaska Ataca a Kamtchatka: Aperiodic Tilings, http://tinyurl.com/5daedv
18:51:29 <lispy> where as, I would imagine, svn/cvs do not
18:51:39 <luqui> dons, they don't even claim to have theory.  Basically the thing that is attractive about darcs is its theory, but it's not accessible
18:51:51 <luqui> (by accessible, i mean precise)
18:52:06 <lispy> luqui: right. You use darcs because it's supposed to have an elegant model
18:52:22 <lispy> luqui: but it's really hard for non-David humans to know if that's the case
18:52:29 <luqui> uh huh
18:54:02 <lispy> luqui: darcs get  http://urchin.earth.li/~ian/theory/
18:54:08 <lambdabot> Title: Index of /~ian/theory
18:54:15 <lispy> luqui: that's Igloo's latest attempt at making it precise
18:54:20 <newsham> hmm.. Network.HTTP isnt lazy?  blah.. is there a lib that is?
18:54:23 <dcoutts> dons: mm, that's rather pretty.
18:54:37 <newsham> (no wonder my code was taking so long to start processing)
18:55:25 <mmorrow> was just reading the log..
18:55:42 <mmorrow> re: the discussion about unsafePerformIO not having legititimate/useful uses
18:55:57 <mmorrow> this is the first line of unpack :: ByteString -> String
18:56:00 <mmorrow> unpack (PS ps s l) = inlinePerformIO $ withForeignPtr ps $ \p ->
18:56:14 <mmorrow> not only is it using unsafePerformIO, but it's inlining it
18:56:27 <mmorrow> but it's perfectly safe
18:56:34 <lispy> I think it's weird to pretend unsafePerformIO doesn't have legitimate usefulness
18:56:55 <dons> it's rather important for purity we can't prove.
18:57:01 <dons> it makes code *more* haskelly
18:57:04 * lispy nods
18:57:11 <dcoutts> mmorrow: there are some pretty special reasons for the safety in that case
18:57:13 <lispy> like import the sin function from math.h
18:57:23 <mmorrow> dcoutts: i'm sure :)
18:57:57 <mmorrow> just like every safe use of an unsafe function has reason why it's safe
18:58:02 <lispy> don't systems with richer type systems (like coq) generate haskell code that is safe but full of tons of unsafeBlah?
18:58:22 <dons> yup
18:58:28 <dcoutts> lispy: I believe so, though nobody can prove the translation is correct
18:58:56 <mmorrow> happy (with the --ghc flag) uses Addr#s and a bunch of unsafeCoerce s
18:58:59 <dons> we should have a "handwave" version of undefined
18:59:07 <mmorrow> probably alex as well
18:59:59 <mmorrow> even ghc crashes
19:00:04 <ddarius> One would need a semantics of Haskell to even start to prove such correct.
19:00:20 <cjs> So has anybody used the GHC_PACKAGE_PATH environment variable? I've appended a colon to it (under Unix), but I still doesn't seem to search the default system packages as well as the ones I specify.
19:01:03 <mmorrow> err, what i meant is  "even haskell programs produced _by ghc_ crash while not using any unsafe functions"
19:01:32 <dsrogers> mmorrow: how?
19:01:38 <roconnor> should I say "every monad induces A canoncial applicative functor" or "every monad induces THE canoncial applicative functor"?
19:01:47 <mmorrow> dsrogers: because ghc messed up
19:02:01 <mmorrow> "The impossible happened"
19:02:10 <dons> runtime bugs, essentially
19:02:10 <mmorrow> "please report this as a GHC bug!"
19:02:12 <lispy> dcoutts: hah, interesting point
19:02:14 <dons> occasionally compiler bugs.
19:02:50 <dsrogers> and what really motivated that discussion for me was that I understood unsafePerformIO as "use only when necessary"
19:02:56 <ddarius> roconnor: If it is canonical than "the" would be appropriate, though I'm not sure I would use the term canonical outside an appropriate context.
19:03:11 <dsrogers> and I was poking at the defintion of "necessary"
19:03:47 <mmorrow> totally
19:03:56 <roconnor> ddarius: Well, there are two applicative functors induced by a monad.  I want to refer to the standard one
19:04:07 <roconnor> (which I then go on to define)
19:04:59 <|Steve|> > 1/7.0
19:05:01 <lambdabot>  0.14285714285714285
19:05:55 <roconnor> > 999999/7
19:05:57 <lambdabot>  142857.0
19:06:44 <sfultong> > 999/7
19:06:46 <lambdabot>  142.71428571428572
19:08:11 <cjs> Can anybody check to see if GHC_PACKAGE_PATH with a colon on the end is working? For me it doesn't append the system paths on two different GHC 6.8.3 builds (Linux and NetBSD).
19:08:58 <cjs> (You can check it with "ghc-pkg list".)
19:10:11 <ddarius> roconnor: If there are two, then neither is canonical.
19:10:27 <explicitjelly> okay
19:10:29 <dsrogers> how does fix or fixM detect convergence?
19:10:29 <explicitjelly> lambda lifting works
19:10:31 <explicitjelly> what to do next.
19:10:51 <dsrogers> fixM, really.
19:10:58 <roconnor> ddarius: sure one is.  Doesn't canonical refer to "the one the is commonly used"
19:11:09 <ddarius> @wn canonical
19:11:21 <luqui> de facto?
19:11:25 <lambdabot> Error: thread killed
19:11:33 <dsrogers> As, in mdo will recurse until done.  And I understand done to mean until the mdo block is least defined.
19:11:50 <dsrogers> oh I see.
19:11:51 <dsrogers> nm
19:11:59 <roconnor> |wn canonical
19:12:03 <roconnor> @wn canonical
19:12:04 <lambdabot> *** "canonical" wn "WordNet (r) 2.0"
19:12:04 <lambdabot> canonical
19:12:04 <lambdabot>      adj 1: appearing in a Biblical canon; "a canonical book of the
19:12:04 <lambdabot>             Christian New Testament" [syn: {canonic}]
19:12:04 <lambdabot>      2: of or relating to or required by canon law [syn: {canonic}]
19:12:06 <lambdabot> [6 @more lines]
19:12:08 <dsrogers> it's when all the variables on the left side of a <- converge, isn't it?
19:12:29 <roconnor> what book of the bible talks about applicative functors?
19:12:44 <explicitjelly> so, how does fix detect convergence?
19:12:47 <ddarius> The third definition is less Bible specific.
19:13:07 <luqui> dsrogers, mfix doesn't really recurse in the monad at all.
19:13:51 <luqui> see also explicitjelly's question as an answer :-)
19:14:17 <explicitjelly> uh, what? :)
19:14:58 <dsrogers> fix converges when the result of the application is no longer _|_, right?
19:15:26 <luqui> if you want to define converge as that, then yes
19:15:33 <explicitjelly> @info fix
19:15:34 <lambdabot> fix
19:15:41 <luqui> thanks, lambdabot =P
19:15:57 <explicitjelly> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
19:16:23 <luqui> dsrogers, but 'detecting' doesn't make sense to me.  Or do you mean something else by that?
19:17:06 <roconnor> ddarius: I think I'll stretch definition 4 to suit my purposes
19:17:32 <luqui> however, fix (1:) = sup { 1:undefined, 1:1:undefined, 1:1:1:undefined, ... }.   The application 1:undefined is not _|_, but fix is not "done" by any means...
19:17:34 <dsrogers> I did read that already.
19:17:47 <explicitjelly> ah. lazy evaluation. of course.
19:18:57 <mmorrow> > fix (let go g _ = let (a,g') = next g in a : go g' undefined in go (mkStdGen 0))
19:18:59 <lambdabot>  [2147482884,2092764894,1390461064,715295839,79337801,347273588,1427314282,18...
19:20:56 <dsrogers> huh.  I guess the answer is "apply until done"
19:21:17 <luqui> or "apply ..."
19:21:53 <luqui> the done happens because of lazy evaluation; fix doesn't know when it's done :-)
19:24:04 <dsrogers> right.  in fact iif the argument is strict, it diverges
19:25:16 <dsrogers> so in the case of mdo, it takes all the recursive parameters and "binds until done," correct?
19:27:34 <mmorrow> > throwDyn ()
19:27:36 <lambdabot>   Not in scope: `throwDyn'
19:27:39 <mmorrow> aww
19:28:03 <dsrogers> >:m +Control.Exception
19:28:14 <dsrogers> > throwDyn ()
19:28:15 <lambdabot>   Not in scope: `throwDyn'
19:28:42 <mmorrow> fix (let go n _ = if n < 5 then n : go (n+1) undefined else throwDyn() `seq` undefined in go 0)
19:28:51 <mmorrow> [0,1,2,3,4*** Exception: (unknown)
19:40:32 <mmorrow> heh
19:40:39 <mmorrow> let xs = fix (let go n _ = if n < 5 then n : go (n+1) undefined else throwDyn() `seq` undefined in go 0)
19:40:46 <mmorrow> catchDyn (mapM_ (\x -> putStr $ show x ++ ",") xs) (\() -> print 5)
19:40:50 <mmorrow> 0,1,2,3,4,5
20:14:43 <dons> we need a word for "haskelly"
20:14:46 <dons> i should offer a bounty
20:15:13 <dons> mm. this code has a flavour. Haskell flavour!
20:17:29 <EvilTerran> "superior"
20:17:49 <EvilTerran> :D
20:18:47 <sereven> hallacious
20:18:48 <Zao> dons: "sane"
20:19:35 <sereven> hmm, most of the ones I think of have some scary connotation. elegant... but how to use h or skell with that?
20:20:08 <explicitjelly> hasky
20:20:17 <heavensrevenge> hello
20:20:47 <dons> yeah, like "pythonic"
20:21:08 <jeffz> words cannot describe it :p
20:21:28 <dons> precision, elegance, purity. the marriage of theory and practice.
20:21:35 <Zao> cohaskellic
20:22:09 <explicitjelly> divine
20:22:10 <cjs> helegant?
20:22:24 <explicitjelly> cjs, sounds like your throat is sick
20:22:31 <Zao> "clever"
20:22:34 <sereven> hehe
20:22:38 <cjs> Or like I'm a cockney.
20:22:52 <explicitjelly> this code is haaaask
20:23:03 <cjs> Ah. "ehlegant."
20:23:18 <explicitjelly> skellegant? %)
20:23:27 <cjs> That would apply very well to my mailing list manager, mhailist. If only it were.
20:23:56 <sereven> cjs: better, but kind of ugly, visually
20:24:20 <explicitjelly> you know what I hate about SML?
20:24:23 <cjs> Yeah.
20:24:27 <explicitjelly> almost everything's uncurried.
20:24:50 <explicitjelly> I mean what the hell?
20:25:14 <stepcut> explicitjelly: that's what makes it enterprise ready
20:25:31 <explicitjelly> stepcut, aah. of course. harness the power of tuples
20:26:14 <dons> heh
20:26:33 <explicitjelly> even operators are uncurried.
20:26:52 <luqui> at least the tuples are unlifted  (because everything is)
20:26:53 <explicitjelly> you don't do map op(+)(1) l...
20:26:53 <dons> like He Man, you hold aloft your type signatures, and declare, "by the power of tuples!", now you can do battle with the masters of the universe.
20:26:55 <heavensrevenge> just to wonder, is there a way have a hoogle like thing to functions from ghci?
20:27:16 <dons> heavensrevenge: the 'goa' library gives a ghci binding to hoogle
20:27:16 <heavensrevenge> along the lines of :info unzip3
20:27:52 <EvilTerran> heavensrevenge, yes, it's called "ghci on acid"
20:28:00 <EvilTerran> it embeds lambdabot functionality into ghci
20:28:03 <heavensrevenge> lol ghci on acid?
20:28:15 <EvilTerran> yes. shortens to "goa"
20:28:15 <luqui> "goa" for short, as dons said
20:28:22 <heavensrevenge> sounds kinda funny
20:28:31 <EvilTerran> as in the birthplace of psychadelic trance, by coincidence
20:28:31 <luqui> it takes itself _very_ seriously
20:28:33 <explicitjelly> but it also sounds useful.
20:28:42 <heavensrevenge> uhm.. is there a way to simply list a functions definition in ghci for a quick refrence?
20:28:44 <stepcut> plus if your code gets to tricky you can just chat with vixen instead
20:28:52 <explicitjelly> heavensrevenge, try :info
20:29:00 <heavensrevenge> just info?
20:29:03 <stepcut> yikes, that is second time I have used 'to' instead of 'too' today
20:29:16 <explicitjelly> heavensrevenge, hm okay that doesn't really seem to list function definitions
20:29:19 <explicitjelly> heavensrevenge, but datatypes.
20:29:28 <heavensrevenge> indeed
20:29:48 <explicitjelly> Prelude Data.Char> :i String
20:29:49 <explicitjelly> type String = [Char]    -- Defined in GHC.Base
20:29:55 <heavensrevenge> along the lines of printing its code block out to read
20:30:07 <explicitjelly> relude Data.List> :i []
20:30:08 <explicitjelly> data [] a = [] | a : [a]        -- Defined in GHC.Base
20:30:08 <explicitjelly> instance (Eq a) => Eq [a] -- Defined in GHC.Base
20:30:09 <explicitjelly> ...
20:30:17 <heavensrevenge> from the prelude
20:30:38 <explicitjelly> but ghci would need to know the code for that
20:30:44 <explicitjelly> that's not always the case
20:30:48 <heavensrevenge> would it?
20:30:58 <explicitjelly> to print the code?
20:31:01 <heavensrevenge> im blindly asking....
20:31:28 <EvilTerran> heavensrevenge, again, GOA does that
20:31:32 <heavensrevenge> so i may not be entirely specific to describe what im seeking
20:31:35 <EvilTerran> as it provides lambdabot's @src functionality
20:31:51 <explicitjelly> @src fix
20:31:51 <lambdabot> fix f = let x = f x in x
20:31:54 <explicitjelly> sexay.
20:32:09 <explicitjelly> @src concatMap
20:32:09 <lambdabot> concatMap f = foldr ((++) . f) []
20:32:22 <heavensrevenge> thats more like it
20:32:43 <explicitjelly> and here I was, stupidly thinking that concatMap was just (concat . map)
20:32:46 <EvilTerran> huh. pre-fused for your compiler's convenience
20:32:52 <heavensrevenge> so... that would mean without internet connectivity it would be useless?
20:32:56 <EvilTerran> no
20:33:03 <EvilTerran> lambdabot works from a local database
20:33:17 <heavensrevenge> ah of course
20:33:19 <ddarius> You can do what most of the people here do and just stay on #haskell all the time and query lambdabot.
20:33:35 <EvilTerran> it basically gives you a local copy of lambdabot embedded in ghci
20:33:43 <heavensrevenge> ok so it would query a local lambdabot to get back something from itself?
20:34:08 <explicitjelly> yeah. you can also do what I do all the time and typing random weird stuff into the channel because you don't really know what the lambdabot commands are.
20:34:09 <heavensrevenge> is... there any reason why this functionality isnt built-in??
20:34:16 <explicitjelly> -typing+type in
20:34:18 <heavensrevenge> it seems awefully useful
20:34:21 <ddarius> If you went 'lambdabot "@type \\x -> x", yes.
20:35:07 <heavensrevenge> especially in that case
20:35:45 <heavensrevenge> like have :src built in
20:36:08 <heavensrevenge> and :info to datatype info in addition would really rock :P
20:37:09 <heavensrevenge> or is it so easy and trivial noone actually bothered to add such a useful tool lol
20:39:21 <heavensrevenge> dont mind me im just querying haskell's human database ;)
20:39:53 <ddarius> Most of the stuff you load into GHCi is compiled so the source isn't available.
20:41:51 <heavensrevenge> but it shouldnt hurt for a.. monad function to read in from the prelude and print info as a specified default verbosity in ghci
20:42:08 <heavensrevenge> supposed to be a quick prototyping environment correct?
20:42:11 <explicitjelly> :t on
20:42:12 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:42:44 <EvilTerran> ?src on
20:42:44 <lambdabot> (*) `on` f = \x y -> f x * f y
20:42:47 <heavensrevenge> not like id try to toss in a ghci :<whatever> command in a .hs file
20:43:33 <ddarius> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
20:43:34 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
20:43:42 <ddarius> @djinn on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:43:43 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
20:44:09 <EvilTerran> @djinn a -> a
20:44:10 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
20:44:14 <EvilTerran> it's broken =/
20:44:17 <heavensrevenge> lol
20:44:25 <EvilTerran> ?vixen are you okay?
20:44:26 <lambdabot> i truely am
20:44:34 <EvilTerran> ?vixen ...are you sure?
20:44:34 <lambdabot> why don't you guess?
20:44:49 <explicitjelly> what is djinn supposed to do?
20:44:56 <ddmnshs> does anybody know how to make these small numbers 1 2 3 etc ( mean vitual workspaces) on xmonad? Thanks a lot
20:44:57 <EvilTerran> ?help djinn
20:44:57 <lambdabot> djinn <type>.
20:44:57 <lambdabot> Generates Haskell code from a type.
20:44:57 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:45:08 <explicitjelly> oh. nice.
20:45:14 <explicitjelly> @djinn a -> a
20:45:14 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
20:45:17 <explicitjelly> :(
20:45:25 <heavensrevenge> you/someone should add an A.L.I.C.E interface :P
20:45:31 <heavensrevenge> that would be fun
20:45:39 <EvilTerran> we've already got vixen
20:45:44 <EvilTerran> ?vixen say hi to heavensrevenge
20:45:44 <lambdabot> hiya
20:45:54 <explicitjelly> ?vixen should I go to bet?
20:45:55 <lambdabot> why don't you guess?
20:46:02 <heavensrevenge> so vixen is a stype of AI?
20:46:11 <heavensrevenge> or just a pattern matcher?
20:46:13 <EvilTerran> ?help vixen
20:46:13 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
20:46:15 <explicitjelly> ?vixen that's not a question where guessing makes sense.
20:46:16 <lambdabot> my keyboard doesn't have an
20:46:41 <EvilTerran> @vixen looks like you're suffering from premature carriage ret
20:46:41 <lambdabot> i'm 19
20:47:03 <heavensrevenge> lol that all seems slightly hard coded
20:47:07 <heavensrevenge> it was almost humerous
20:47:29 <explicitjelly> I'm going to sleep now
20:47:31 <explicitjelly> n8
20:47:43 <heavensrevenge> n8 then, thanks
20:48:49 <heavensrevenge> im going to continue reading
20:49:31 <heavensrevenge> i cant get enough of that "programming in Haskell" book
20:50:25 <lispy> haskell!? who uses that?
20:50:28 <lispy> ?users
20:50:29 <lambdabot> Maximum users seen in #haskell: 490, currently: 421 (85.9%), active: 14 (3.3%)
20:50:49 <lispy> oh wait, 421 people in here...must be someone
20:51:01 <heavensrevenge> i must say theres alot of people here
20:51:19 <lispy> haskell has a pretty good community these days just in terms of size
20:51:22 <heavensrevenge> its dums as SOME people are trying to nail down Haskell
20:51:31 <EvilTerran> nah, we're all bots written by the simons
20:51:33 <heavensrevenge> just becuz its becoming threatening to them
20:52:32 <heavensrevenge> Haskell(functional paradigms in general) are new competition :P
20:52:58 <heavensrevenge> its slumbered and marinated and cured and aged long enough
20:53:48 <heavensrevenge> as long as Haskell can kick ass in the concurrent and parallel area in the next while, we should really see some positive press
20:55:13 <heavensrevenge> just my take on things tho
20:55:24 <heavensrevenge> you veterans have much more say ;)
20:55:58 <lispy> those may very well become niches for FP, not sure.  But, I hope it sees wider applicability soon.
20:56:03 <ddarius> The rise of actual use of FP has very little to do with parallelism.
20:56:42 <lispy> I would say that FP tends to have a stigma in many of the "real-world" places I've met other programmers
20:56:51 <lispy> I don't think it's deserved thought
20:57:52 <heavensrevenge> something has to leverage 1000's of cores
20:57:53 <wolgo> I have a question, since all functions can be curried and function application is left associative I can read functions as: ((f x) y) if f is a function of two arguments x y
20:57:57 <heavensrevenge> might as well be the worthy
20:58:18 <EvilTerran> wolgo, indeed, that's part of the point
20:58:18 <lispy> wolgo: correct
20:58:25 <wolgo> Okay
20:58:34 <wolgo> This is really cool.
20:58:52 <lispy> whereas, in C, where all functions are uncurried, you'd be (f (x,y))
20:59:00 <EvilTerran> > map ((,) 1) [1..5]
20:59:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5)]
20:59:08 <EvilTerran> > (,) 1 3
20:59:09 <lambdabot>  (1,3)
20:59:20 <EvilTerran> > ((,) 1) 3
20:59:21 <lambdabot>  (1,3)
21:00:04 <wolgo> >map (("tuple",) 1) [1..10]
21:00:10 <wolgo> > map (("tuple",) 1) [1..10]
21:00:10 <lambdabot>  Parse error at ")" (column 15)
21:00:41 <wolgo> > map ((,) "tuple") [1..10]
21:00:43 <lambdabot>  [("tuple",1),("tuple",2),("tuple",3),("tuple",4),("tuple",5),("tuple",6),("t...
21:00:44 <EvilTerran> there are no sections of (,)
21:00:46 <wolgo> ahhhh
21:00:47 <EvilTerran> it's not an operator
21:00:57 <EvilTerran> > 1 , 2 -- otherwise this would work
21:00:58 <lambdabot>   parse error on input `,'
21:01:07 <EvilTerran> and list literals would be ambiguous
21:01:21 <wolgo> EvilTerran: What do you mean by sections?
21:01:27 * luqui wishes there were
21:01:34 <EvilTerran> as in (1+) and (^2)
21:01:46 <EvilTerran> they're called operator sections
21:01:53 <wolgo> Oh okay
21:02:05 <wolgo> hmm
21:02:07 <EvilTerran> (,) is kinda like a both-sided section of (,) (like (+) is for +)
21:02:19 <EvilTerran> but it's a seperate class of syntax, alongside (,,) (,,,) etc
21:02:26 <luqui> ((,) x)  and esp. (flip (,) x) are so grotesque I usually just write (\y -> (x,y)).
21:02:53 <EvilTerran> i'd define them somewhere, give them a name
21:02:56 <EvilTerran> pair and riap?
21:03:05 <wolgo> So if I could take 1,2,3,4 and the list [1..13] I would have an easy way to create a zip of 1,2,3,4 for each integer  1..13
21:03:13 <wolgo> And I could make blackajack:)
21:03:15 <wolgo> hahah
21:03:23 <wolgo> Blackjack*
21:03:26 <luqui> EvilTerran, that's actually a good idea.  I don't know why I didn't think of that.   Define... function?  What for?
21:03:43 <EvilTerran> just to tidy the syntax up a bit
21:03:53 <EvilTerran> pair = (,); riap = flip (,)
21:04:03 <luqui> I know.  I was making fun of the fact that I didn't think to define a function in a functional language...
21:04:11 <EvilTerran> or use some unicode symbol
21:04:22 <EvilTerran> or something like (&) = (,)
21:04:25 <luqui> oh yeah!
21:04:28 <EvilTerran> so you could write (x &) or (& y)
21:04:44 <luqui> that makes it clear how ridiculously stupid the lack of tuple sections are!
21:04:57 <EvilTerran> it doesn't generalise to n-tuples at all
21:05:13 <luqui> true.  I don't use those anyway.
21:06:07 <luqui> > let x &%#%& y = (x,y) in map (&%#%& 42) [1..10]
21:06:09 <lambdabot>  [(1,42),(2,42),(3,42),(4,42),(5,42),(6,42),(7,42),(8,42),(9,42),(10,42)]
21:06:24 <wolgo> what is /\ in a boolean expression? and>?
21:06:33 <Mr_Awesome> yes
21:06:47 <wolgo> thanks
21:06:50 <lispy> > map ((,,) 1 2) [1..3]
21:06:52 <lambdabot>  [(1,2,1),(1,2,2),(1,2,3)]
21:06:55 <EvilTerran> you could do something weird with associativity and typeclasses so (x %% y) = \z -> (x,z,y), and (% x %) = \y z -> (x,y,z), and all relevant crafty sections
21:07:03 <EvilTerran> wolgo, &&
21:07:06 <EvilTerran> ?src (&&)
21:07:06 <lambdabot> True  && x = x
21:07:07 <lambdabot> False && _ = False
21:07:30 * wolgo is learning Haskell from "Programming in Haskell"
21:07:37 <luqui> (% x %), does that parse
21:07:44 <EvilTerran> luqui, er, i guess not
21:07:48 <EvilTerran> now you mention it
21:08:08 <EvilTerran> do something with template haskell or quasiquotes or sometihng :P
21:08:26 <luqui> yeah, wait until 6.10 for Haskell to turn into perl!
21:09:04 <luqui> (by which I mean everybody has their own dialect;  but Haskell was already doing that, quasis will just make the dialects cleaner (and stronger))
21:09:38 <ddarius> @where haskerl
21:09:39 <lambdabot> I know nothing about haskerl.
21:30:20 <Trinithis> Are there laws that govern Arrows?
21:32:10 <Heffalump> yes, several
21:32:27 <Trinithis> The Control.Arrow page doesnt list them? Got a link?
21:32:46 <Trinithis> s/them?/them.
21:36:57 <Heffalump> http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows
21:37:00 <lambdabot> Title: Wadler: Links
21:37:10 <Trinithis> Thanks
21:37:57 <Heffalump> (that mentions them in the process of showing one of them to be redundant, if they're not there in detail then you'll need Hughes' original paper)
21:38:10 <noohgodno> > product [1..100000]
21:38:16 <lambdabot>  Exception: Time limit exceeded
21:38:21 <noohgodno> > you fucking bot i'm going to
21:38:22 <lambdabot>   Not in scope: `to'
21:38:24 <noohgodno> >sodomize you with a chain saw
21:38:50 --- mode: ChanServ set +o glguy
21:38:53 --- kick: noohgodno was kicked by glguy (glguy)
21:39:16 <Elly> who *is* that guy?
21:41:51 <Trinithis> Heffalump: It shows a nice table
21:46:16 <wolgo> Are there techniques one should use to identify base cases for recursive functions?
21:46:44 <Trinithis> wolgo: Intuition?
21:47:00 <wolgo> Okay
21:47:20 <Trinithis> shouldnt be too hard. just think of cases where you know an answer
21:47:24 <wolgo> I typically try to find the identity of the set
21:47:31 <Trinithis> factorial's 0.... map's []
21:47:31 <wolgo> Err, use not find
21:48:00 <Trinithis> a tree's leaf
21:48:00 <wolgo> Okay
21:48:18 <Trinithis> Just guidelines, but sometimes there are more than 1 base case too
21:48:28 <wolgo> like with the fibs
21:48:40 <Trinithis> yeah
21:49:02 <Trinithis> or for lazy functions, there can be no base cases.... aka "iterate"
21:49:14 <Trinithis> or rather functions that gen lazy structures
21:50:28 <wolgo> Okay
21:50:36 <wolgo> I guess I will just get used to it.
21:50:45 <wolgo> I have definitely gotten better at identifying them.
21:50:46 <Trinithis> new to haskell?
21:50:52 <wolgo> Yeah
21:51:23 <wolgo> I have successfully rewritten some of the stdlib functions as myZip, myMap just to get a feel for them
21:51:36 <wolgo> And get a better handle on the language
21:51:36 <dons> cool
21:51:51 -ChanServ(ChanServ@services.)- glguy added noohgodno to the AKICK list.
21:51:52 <Trinithis> You can always look at Data.List's source code for examples : http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
21:51:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
21:52:37 <wolgo> I want to make blackjack as my first newbie project which will require a type Card which is a tuple of two values and a type Deck which will be a list of Cards
21:52:50 <wolgo> But I still have a few things to learn before I start on that
21:52:56 <Trinithis> probably :D
21:52:58 <wolgo> Trinithis: Oh okay thanks
21:53:08 <Pseudonym> Sounds like a good simple project, though.
21:53:13 <Trinithis> Are you comfortable with choosing foldr over foldl?
21:53:43 <wolgo> I have not used them yet
21:53:51 <wolgo> one is a left fold and one is a right fold
21:53:53 <wolgo> I read that
21:54:00 <wolgo> I do not know what that means though hahah
21:54:21 <Pseudonym> Personal opinion, I think the best thing to do is write some code, then show it to people.
21:54:24 <Trinithis> One thing that made them click for me was that the accumulator is applied to the right for foldr and for foldl, to the left side
21:54:28 --- mode: glguy set +b noohgodno!*@*
21:54:30 --- kick: noohgodno was kicked by glguy (glguy)
21:54:45 <Pseudonym> folding is something tht I only really understood by finding examples of the pattern in my own code.
21:54:47 <Trinithis> so foldr actually grows to the left
21:54:56 <Trinithis> and foldl grows to the right
21:55:16 <wolgo> What is an accumulator? brb wikipedia
21:55:38 -ChanServ(ChanServ@services.)- glguy added *!*@c-71-192-179-132.hsd1.ma.comcast.net to the AKICK list.
21:56:20 <Pseudonym> wolgo: You implemented some of the standard library, right.  How did you implement "sum"?
21:56:35 <Pseudonym> That's a good example for showing the difference.
21:57:00 <wolgo> I have not done sum. I will do it right now.
21:57:25 <Trinithis> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
21:58:43 <Trinithis> but worry about that later I guess
21:59:46 <sereven> wolgo: Real World Haskell is a great complement to PiH Ch 5 has good intro to folds (work through earlier chapters too) http://book.realworldhaskell.org/beta/fp.html
21:59:47 <lambdabot> Title: Chapter 5. Functional programming
22:00:06 <dons> sereven: PiH ?
22:00:10 <dons> oh, :)
22:00:17 <sereven> oh no, but don't look at mySum yet!
22:00:29 <sereven> programming in haskell
22:00:36 <dons> RWH, PiH, SOE, TAPL.
22:00:47 <Trinithis> soe? tapl?
22:01:02 <dons> School of Expression, Types and Prog. Languages.
22:01:05 <sereven> SOE and RWH is what's finally making some sense for me. typical intros were too boring
22:01:13 <dons> awesome.
22:01:25 <dons> i think we know much more than we did 10 years ago, about how to sexy up haskell :)
22:01:43 <Trinithis> The other day I was reading about haskell exceptions in RWH. Never bothered to learn them until them :D
22:02:02 <adu> Haskell is already sexy
22:02:46 <sereven> dons: there's your haskelly synonym: "sexy" ;-)
22:02:51 <dons> hehe
22:02:57 <dons> Trinithis: that's great to know.
22:03:35 <adu> did we know anything 10 years ago?
22:03:46 <dons> sure.
22:03:50 <Trinithis> A few weeks ago I wrote Tetris (and Pentris... pentrominos) in haskell. That was fun.
22:03:52 <dons> all the classic were written about 10 years ago
22:03:57 <dons> SoE and Craft of FP.
22:04:14 <dons> but they had to build the ground for just talking about purely functional programming, as a language.
22:04:18 <dons> there were few tools and no libs to help
22:04:29 <dons> so sexy in an cerebral way
22:04:30 <dons> :)
22:04:31 <wolgo> hmm
22:04:33 <wolgo> cool
22:04:48 <wolgo> It will take me some time to figure it out but I will figure it out
22:04:59 <dons> Trinithis: awesome. opengl i hope? :)
22:05:07 <Trinithis> I used gtk2hs
22:05:20 <dons> hey, why not stick it on hackage?
22:05:24 <dons> add it to the Games category
22:05:29 <Trinithis> There were some pain moments with the api tho
22:05:35 <Trinithis> but I trudged thru
22:05:42 <Trinithis> Hackage?
22:05:46 <dons> hackage.haskell.org
22:05:53 <dons> our shared collection of programs and tools
22:06:04 <Trinithis> Ah
22:06:07 <dons> if you wrote a gtk tetris, that's awesome, people would love to see it.
22:06:16 <Trinithis> Sure I'll post it
22:06:33 <Trinithis> once I figure out how to use hackage of course :D
22:06:44 <dons> ?go how to write a haskell program
22:06:47 <lambdabot> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
22:06:47 <lambdabot> Title: How to write a Haskell program - HaskellWiki
22:06:49 <dons> that's it.
22:06:55 <dons> goes through cabal and uploading to hackage.
22:07:00 <Trinithis> Ok
22:07:09 <dons> then your app will be in half a dozen distros, and we can all install it with: cabal install tetris
22:07:40 <Trinithis> mm... my haskell bookmark folder is overflowing!
22:09:38 <adu> dons: can I do that with only?
22:10:48 <dons> adu?
22:11:32 <adu> the 'grep' replacement I wrote in haskell, Its pretty sweet
22:11:36 --- mode: glguy set +d nhgdng
22:11:45 <adu> I called it 'only'
22:11:56 --- mode: glguy set -o glguy
22:12:20 <adu> It works with filenames just fine, but doesn't read stdin yet
22:18:20 -ChanServ(ChanServ@services.)- glguy added noohgodno*!*@* to the AKICK list.
22:22:52 <lispy> adu: why 'only'?
22:23:15 <dons> ah ok. adu, yes, that's perfect for hackage.
22:23:22 <dons> *any* library or tool that's cabalised.
22:23:42 <adu> well, when you are filtering I thought it would be neat to write "... | only --lines /x/" or "... | only --words /y/"
22:24:00 <lispy> adu: cool ideas
22:24:30 <adu> it makes pipelines easier to read too :)
22:26:14 <lispy> So when well we reimplement all of unix tools, run house and use haskell based processorS?
22:34:30 <cjs> lispy: I think that that will take several months, at the least.
22:34:57 <ruddel> hmm, why are most Haskell books slim
22:35:14 <cjs> They tend to be fairly dense.
22:35:14 <ruddel> i guess because the code is slim
22:35:21 <lispy> cjs: oh, the hardware engineers need more time?
22:35:42 <wolgo> I cannot figure out mySum
22:35:51 <ruddel> cjs, hmmm, what Haskell book is fairly dense?
22:35:53 <wolgo> I got something that would create [3,5,7 fail
22:35:59 <ruddel> oh, you're talking about the engineers being dense
22:36:00 <wolgo> but not a single int
22:36:23 <Caelum> I gave up on "programming in haskell" close to the end, need to reread it now
22:36:35 <lispy> Caelum: why is that?
22:36:58 <Caelum> it got really hard
22:37:10 <ruddel> =)
22:37:15 <ruddel> challenges are yummy
22:38:20 <lispy> wolgo: what is the specification of mySum?
22:38:36 <wolgo> mySum is sum written by me
22:38:47 <wolgo> so sum [Int] -> Int
22:39:09 <lispy> wolgo: how did you try to write ti?
22:40:19 <ruddel> it's strange, while all the Haskell books are so slim, they still probably take as long as a thick book on an imperative language to read, because the concepts might be much difficult to digest
22:40:42 <ruddel> hmm, much more*
22:41:29 <ddarius> mySum = sum
22:41:33 <ddarius> seems easy enough
22:41:42 <wolgo> I was trying : mySum (x:xs) = x + mySum xs also, I tried mySum (x:xs) = x + head xs : mySum xs which is obviously wrong because it is [Int] and not Int
22:41:57 <wolgo> I was trying to rewrite it to learn hahah
22:42:01 <dons> ruddel: rwh isn't going to be slim :)
22:42:05 <wolgo> I know I could do mySum = sum
22:42:07 <wolgo> hahhaha
22:42:25 <lispy> wolgo: what went wrong with your first attempt
22:42:38 <lispy> wolgo: (hint: it's almost right)
22:42:44 <sjanssen> wolgo: "mySum (x:xs) = x + mySum xs" is 50% of the correct solution, think about the cases you need to handle
22:43:14 <lispy> > let mySum (x:xs) = x + mySum xs in mySum [1..3]
22:43:16 <lambdabot>   Non-exhaustive patterns in function mySum
22:43:23 <ruddel> dons, =) i'm looking foward to buying that book
22:43:35 <Caelum> rwh?
22:43:38 <ruddel> yes
22:43:40 <lispy> ?where rwh
22:43:41 <lambdabot> is http://www.realworldhaskell.org/blog/
22:43:47 <ruddel> i've been reading it
22:43:58 <hml> anyone know of any efforts to interface: http://www.cgal.org/ ... and haskell? the two could be a really powerful combo for 3d modeling / cad design
22:44:03 <ruddel> but like i said yesterday, i really want to own the first o'reilly book on Haskell, ever
22:44:04 <lambdabot> Title: CGAL - Computational Geometry Algorithms Library
22:44:11 <dons> hml, that sounds awesome.
22:44:13 <hml> (i would do it myself, except i'm a newb when it comes to haskell ffi; and i'm wimpy)
22:44:19 <hml> dons: care to take the lead?
22:44:29 <hml> i'll help out w8ith testing :-)
22:44:29 <dons> i'm a little busy these days, sadly
22:44:37 <wolgo> I have mySum [] = []
22:44:41 <dons> but i can put you in touch with the guys doing all the lapack/blas bindings
22:44:52 <dons> oh, C++ ?
22:44:55 <lispy> :t []
22:44:56 <lambdabot> forall a. [a]
22:44:57 <dons> that's harder to bind to
22:45:03 <lispy> wolgo: are you sure that's what you want to return?
22:45:43 <hml> dons: i took a brief look at simon peyton jone's awkward squad; what about C++ makes it harder to bind?
22:45:44 <wolgo> 0 not a list
22:45:59 <lispy> wolgo: right
22:46:00 <wolgo> Ahh
22:46:23 <wolgo> The base case is the identity for addition on the set of integers
22:46:28 <wolgo> not a list
22:46:38 <wolgo> heh
22:46:43 <wolgo> I will learn
22:46:47 <MyCatVerbs> hml: exceptions are a _big_ pain in the arse.
22:46:56 <lispy> wolgo: now are you ready for a 1 liner?
22:47:01 <hml> MyCatVerbs: C++ exceptions?
22:47:12 <wolgo> yes
22:47:13 <lispy> wolgo: if so, go learn about folds
22:47:14 <MyCatVerbs> hml: yes, I should've been clearer.
22:47:17 <hml> MyCatVerbs: isn't that part of the c++= run time? why does haskell care abou tit?
22:47:28 <hml> *about it*
22:47:30 <wolgo> mySum = 0 + foldl xs?
22:47:37 <lispy> :t foldl
22:47:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:48:01 <wolgo> I snuck a peek at the answer but I have not learned about folds yet.
22:48:03 <wolgo> Hahah
22:48:04 <MyCatVerbs> hml: name mangling is also a pain in the arse, mainly because the C++ standard doesn't specify it.
22:48:16 <lispy> wolgo: okay, have you studied map yet?
22:48:37 <hml> MyCatVerbs: got it; so if I wrote a C wrapper/interface aorund the C++ code; would my life be much easier?
22:48:44 <MyCatVerbs> hml: so anyway. C++ exceptions are evil. Imagine foreign import cppthing :: CInt -> IO CInt, right?
22:48:47 <hml> or does hte run time still get me, (confused about why C!! exceptions matter)
22:48:49 <lispy> hml: yes, that's the standard approach I would say
22:48:52 <wolgo> A little
22:49:02 <Trinithis> Just out of curiosity, does the haskell specification require tail call optimization?
22:49:08 <MyCatVerbs> hml: now, ask yourself what happens if we call cppthing inside Haskell code, and it throws an exception?
22:49:09 <wolgo> :t map
22:49:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:49:13 <hml> IK see how writing C wrappers gets around name mangling; how does this interact with exceptions
22:49:25 <dons> the name mangling
22:49:30 <wolgo> I do not understand these types lambda bot shows
22:49:32 <dancor> @pl \ xs ys -> [f x y | x <- xs, y <- ys]
22:49:33 <lambdabot> (. (return . (y <-))) . (:) . ((f x y | x) <-)
22:49:47 <lispy> wolgo: a fold is like a map in that it processes a list for you.  But, with a map you hit each element independent of the rest.  With a fold you get to process adjacent elements and you bring along your previous calc
22:49:47 <sjanssen> Cale-- your types are confusing newbies
22:49:50 <MyCatVerbs> wolgo: it's just tacking some extra crap onto a normal type declaration.
22:49:54 <wolgo> a function over a list to list
22:50:00 <ruddel> hml, 'IK'? are you dutch?
22:50:02 <MyCatVerbs> hml: writing C-safe wrappers is precisely what you need to do.
22:50:09 <hml> MyCatVerbs: suppose I call C++ function foo, and foo calls bar; and bar throws an exception; if foo handles it, i'm fine; if foo doesn't handle it, i die
22:50:16 <Trinithis> :t Prelude.map
22:50:16 <sjanssen> wolgo: the actual type of map is "(a -> b) -> [a] -> [b]", ignore what lambdabot says
22:50:16 <MyCatVerbs> hml: precisely.
22:50:17 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:50:19 <hml> ruddel: i'm using a ergo kinesis
22:50:24 <ruddel> oh
22:50:27 <hml> ruddel: still not quite used to this keyboard yet
22:50:36 <Trinithis> sjanssen: just apend Prelude or whatever before to simlify the type
22:50:49 <lispy> > foldl1 (+) [x,y,z] :: Expr
22:50:51 <lambdabot>  x + y + z
22:51:08 <MyCatVerbs> hml: you put in a C-callable wrapper to get around the name mangling, and you *must* make it catch *all* exceptions and translate them into return codes (or something similarly checkable).
22:51:10 <wolgo> > foldr (+3) [1,2,3]
22:51:11 <lambdabot>   add an instance declaration for (Num ([t] -> [t]))
22:51:25 <wolgo> > map (+3) [1,2,3]
22:51:27 <lambdabot>  [4,5,6]
22:51:31 <Trinithis> > foldr1 (+3) [1,2,3]
22:51:32 <lispy> :t map
22:51:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
22:51:32 <lambdabot>     Probabl...
22:51:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:51:36 <wolgo> > foldr ((+) 3) [1,2,3]
22:51:37 <lambdabot>   add an instance declaration for (Num ([t] -> [t]))
22:51:44 <Trinithis> > foldr1 (+3) [1,2,3] :: Expr
22:51:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
22:51:46 <lambdabot>     Probabl...
22:52:00 <Trinithis> > foldr1 (+) [1,2,3] :: Expr
22:52:00 <MyCatVerbs> Trinithis: you just tried foldr1 with a function that has arity 1, where it needs a function of at least arity 2.
22:52:02 <lambdabot>  1 + (2 + 3)
22:52:13 <lispy> wolgo: the function that map uses processes one element at a time, that's why you pased (+3), but in a fold you process 2 values at once, that's why I used (+)
22:52:19 <MyCatVerbs> hml: this isn't the case for just Haskell, by the way. Practically all programming languages need C-compatible wrappers in just the same way.
22:52:32 <Trinithis> That's the problem with cut and paste :D
22:52:33 <hml> MyCatVerbs: got it; thanks
22:52:36 <MyCatVerbs> hml: er, all programming languages with sane FFIs, anyway. :)
22:52:51 <adu> lispy: hopefully soon, is the house website back up?
22:53:07 <lispy> adu: hehe, I have no idea actually
22:53:29 <lispy> adu, well this is up: http://programatica.cs.pdx.edu/House/
22:53:29 <wolgo> oh
22:53:33 <lambdabot> Title: House
22:54:01 <wolgo> What the hell?
22:54:08 <wolgo> @src foldl
22:54:08 <lambdabot> foldl f z []     = z
22:54:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:54:10 <lispy> wolgo: here is a test, can you implement myMap or myFoldl L
22:54:10 <MyCatVerbs> hml: (though a lot of the wrapper is technically just boring boilerplate, and AFAIK languages like Perl and Python come with tools to automatically generate it, too. I suppose it wouldn't be intractable to write something similar to get C++-from-Haskell. Though it'd be a huge pain in the hindquarters, since you'd have to resolve templates, ugh.)
22:54:25 <wolgo> I will try my map
22:55:23 <dancor> @pl \ xs ys -> [(x, y) | x <- xs, y <- ys]
22:55:24 <lambdabot> (. (return . (y <-))) . (:) . (((x, y) | x) <-)
22:55:29 <adu> lispy: YEY last time i checked it was down...
22:55:32 <hml> MyCatVerbs: yeah; i was hoping it'd just be a call to swig ...
22:55:40 <lispy> I'm waiting for someone to use the new Language.C with template TH to do automated bindings
22:56:01 <lispy> "template TH" being redundant there :)
22:56:03 <adu> hey i can't upload to hackage
22:56:52 <hml> lispy: why it it redundant/
22:57:03 <lispy> hml: well, TH = template Haskell
22:57:15 <lispy> it's like saying PIN number
22:57:37 <wolgo> I got it
22:57:39 <wolgo> I think
22:57:47 <wolgo> base case is an empty list
22:57:52 <MyCatVerbs> lispy: "Personal Identification PIN Number".
22:58:00 <wolgo> which needs to be another empty list to cons
22:58:07 <MyCatVerbs> lispy: spotted on the news a couple of times by various people, apparently.
22:58:08 <Trinithis> wolgo: Which function?
22:58:10 <wolgo> so the first line is: myMap f [] = []
22:58:14 <MyCatVerbs> Trinithis: map.
22:58:19 <wolgo> next one is myMap f (x:xs) = f x : myMap f xs
22:58:25 <MyCatVerbs> wolgo: eeeeexcellent. Yep.
22:58:34 <wolgo> f is a function (a -> b)
22:58:38 <Trinithis> @src Prelude.map
22:58:38 <lambdabot> Source not found. My mind is going. I can feel it.
22:58:45 <wolgo> @src map
22:58:45 <lambdabot> map _ []     = []
22:58:45 <lambdabot> map f (x:xs) = f x : map f xs
22:58:49 <wolgo> :t map
22:58:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:58:55 <Trinithis> :t Prelude.map
22:58:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:59:01 <wolgo> okay
22:59:07 <wolgo> yeah and it gives another list
22:59:14 <lispy> wolgo: good job, now try foldl when you're ready :)
22:59:26 <wolgo> Why did I have so much problems with mySum and I got that one quickly?
22:59:32 * wolgo sighs
22:59:34 <Trinithis> learn filter before folds
22:59:43 <wolgo> filter and folds okay
23:00:33 <wolgo> I am going to go read this chapter in the book :)
23:01:00 <wolgo> I have this book too: "The craft of functional programming"
23:01:05 <wolgo> It uses Haskell and hugs
23:01:50 <wolgo> foldr(l) is an example of a higher order function?
23:02:03 <wolgo> so is map too then no?
23:02:16 <Trinithis> yes
23:02:25 <adu> yes
23:02:25 <wolgo> Okay
23:02:34 <Trinithis> A higher order function is a function that takes a function as an argument
23:02:55 <adu> (.) is also a higher-order function
23:04:12 <adu> and I think it is by far the one with the shortest name :)
23:05:32 <adu> i want to upload my package
23:06:45 <wolgo> Oh cool filter takes a bool
23:07:48 <dons> adu, do you have a hackage account?
23:08:04 <adu> well anyways, I can't upload it to hackage, so here is where i can put it: http://tetration.itgo.com/hs/only-0.0.1.0.tar.gz
23:08:08 <adu> dons: no
23:08:09 <Trinithis> wolgo: Almost
23:08:21 <dons> adu, can you just request one?
23:08:21 <wolgo> hehehehe
23:08:26 <wolgo> check this out haha
23:08:31 <adu> dons: i did
23:08:34 <wolgo> oh shoot
23:08:37 <Trinithis> wolgo: It takes (a -> Bool) such as ==, even, odd
23:08:53 <wolgo> *Main> myFilter (>3) [1,2,3,4,5,6,7,8]
23:08:55 <wolgo> [False,False,False,True,True,True,True,True]
23:08:57 <wolgo> haha
23:09:10 <Trinithis> That's a map, not a filter
23:09:16 <humasect> what is it, adu?
23:09:17 <adu> dons: its ok, i can wait
23:09:27 <Trinithis> > filter (>3) [1,2,3,4,5,6,7,8]
23:09:27 <adu> humasect: its a grep replacement
23:09:29 <lambdabot>  [4,5,6,7,8]
23:09:33 <humasect> ohh =)
23:09:49 <Trinithis> > map (>3) [1,2,3,4,5,6,7,8]
23:09:51 <lambdabot>  [False,False,False,True,True,True,True,True]
23:10:06 <wolgo> Hey would filter be better written with a guard?
23:10:33 <wolgo> I am going to put a comment in here to rewrite them all using guards
23:10:36 <Trinithis> wolgo: go ahead, but your myFilter is incorrect
23:10:51 <wolgo> I noticed hahah
23:11:09 <wolgo> falsefalsefalse
23:11:12 <wolgo> falsefalse
23:11:17 <humasect> adu, i will be using it as much as i can.
23:11:23 <adu> humasect: :)
23:11:34 <adu> then I will try to improve it as much as i can
23:11:40 <humasect> hehe=)
23:12:21 <wolgo> I think I can do filter with a list comprehension easier. I am about to read that part
23:12:50 <wolgo> I could collect only the values in y:ys that are TRUE
23:12:54 <wolgo> I am going to try that
23:13:23 <wolgo> Thanks Trinithis
23:13:26 <humasect> only: user error (internal error: went to far into context!)
23:16:31 <adu> humasect: hmm, how did you run it?
23:16:41 <humasect> only -l "dirty" *.hs
23:17:24 <adu> hmm that should return nothing
23:17:51 <humasect> why is that?
23:18:30 <Trinithis> What exactly is darcs?
23:18:41 <adu> well, it was designed for multiple modes (line-mode, word-mode) I had planned on adding paragraphs, code-blocks, etc
23:19:02 <dons> Trinithis: it's a smart, distributed, revision control system.
23:19:18 <Trinithis> ok
23:19:56 <humasect> ohh cool, adu
23:19:58 <Trinithis> Guess I should learn how to use all these haskell tools sometime
23:20:16 <adu> and it starts by descending through the modes, separating by newlines, separating by spaces, then when it goes back up, it concats by spaces, then concats by newlines, and if there are n modes, then it must start at mode (n-1) to do its job properly, by if it starts at mode (n), then it gives that error
23:20:50 <humasect> ahh
23:20:57 <dons> Trinithis: darcs is just a general developer tool.
23:21:00 <adu> my brain sucks at recursion
23:21:07 <dons> its not haskell specific in any way.
23:21:35 <Trinithis> I see...
23:21:38 <dons> adu, your brain sucks at what what your brain sucks at
23:22:12 <dons> Trinithis: have you used cvs or svn?
23:22:19 <Trinithis> never
23:22:31 <dons> any revision control systems?
23:22:31 <adu> dons: lol
23:22:34 <Trinithis> nope
23:22:36 <humasect> my brain likes recursion i think
23:22:46 <dons> ah well, there's a lot of interesting productivity to find out about :)
23:23:03 <dons> revision control is really a foundational aspect of our industry.
23:23:14 <dons> let the computer worry about your files for you.
23:23:47 <Trinithis> dons, any other interesting developer tools I should know about? I'm basically just a vi user :D
23:24:06 <dons> vim + darcs + ghci, is a good start.
23:24:28 <dons> learn some sed and shell.
23:24:33 <adu> humasect: try http://tetration.itgo.com/hs/only-0.0.2.0.tar.gz
23:25:48 <Trinithis> is bash a good shell to use?
23:26:21 <adu> Trinithis: yes
23:26:34 <nornagon> i prefer zsh
23:26:44 <Trinithis> are they all similar though?
23:26:49 <nornagon> yep
23:26:54 <adu> humasect: i think I forgot to test with multiple files
23:27:00 <nornagon> bash is maybe better to start with; it has fewer features
23:29:27 <Caelum> zsh is awesome
23:29:33 <nornagon> i <3 zsh
23:29:45 <Trinithis> i <3 haskell
23:29:51 <adu> i <3 only
23:29:57 <Trinithis> only?
23:30:12 <adu> Trinithis: its a 'grep' replacement i wrote
23:30:59 <Trinithis> is grep like 'easy' regex?
23:31:34 <adu> easy?
23:31:48 <Trinithis> simpler*
23:32:18 <Trinithis> like *.txt vs .*txt
23:32:19 <adu> 'grep' is usually basic regex while 'egrep' is extended regex
23:32:54 <Trinithis> err actually I think I'm thinking about globbing
23:32:57 <adu> no you're talking about globs or shell-patterns
23:32:59 <adu> ya
23:33:03 <humasect> hehe adu, its ok =)
23:33:09 <humasect> i will try this
23:34:09 <humasect> ok, that command prints the whole .hs
23:34:18 <humasect> it needs regexp syntax ?
23:34:48 <adu> try these:
23:34:57 <adu> only -l 'Only' only.hs
23:35:32 <adu> only -l '1/Only/' only.hs
23:35:33 <humasect> ok this works, how come "dirty" is finding all lines? (i have a function called dirty.=)
23:35:36 <adu> only -l '3/Only/0:2' only.hs
23:36:00 <humasect> neat=)
23:37:22 <Trinithis> adu: can I look at the source code for kicks?
23:37:37 <adu> sure, its in that link
23:38:07 <adu> humasect: the 'doMatch' function is not doing the match
23:38:21 * humasect looks into the code
23:38:24 <adu> :P
23:40:11 <humasect> NOINLINE for ioref ? how come?
23:40:55 <adu> i don't know
23:40:59 <adu> oooo i get it
23:41:04 <humasect> heh
23:41:12 <adu> I'm using isJust, and its returning Just [] for the matches
23:41:37 <humasect> ah
23:50:20 <dons> humasect: so you don't duplicate the top level IO
23:50:24 <dons> and get two iorefs.
23:50:35 <humasect> ahh i see, how does it happen ?
23:50:46 <humasect> laziness ?
23:51:00 <sjanssen> humasect: inlining
23:51:18 <humasect> i should probably use this too..
