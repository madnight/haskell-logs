00:00:11 <ivanm> http://www.itee.uq.edu.au/~paul/tfp-papers/
00:00:13 <lambdabot> Title: TFP Summary
00:00:31 <Cale> aren't coinductive values straightforward?
00:00:58 <Cale> maybe not...
00:01:03 <ivanm> no idea... that was the only ever "theoretic" FP I've done...
00:01:10 <Myoma> Cale: I suspect you'd need recursive types for it
00:01:12 <ivanm> and all my haskell stuff is self-taught
00:01:18 <ivanm> (though I _did_ learn scheme in first year...)
00:01:29 <Cale> ivanm: basically same here :)
00:01:40 <Cale> Though I've taken to reading some papers :)
00:02:36 <ivanm> I've read a few...
00:02:50 <ankh47> hi, is it possible to create a 0-parameter lambda (closure, no need for parameters) ? thx
00:03:01 <Myoma> ankh47: yes
00:03:11 <Cale> ankh47: no need
00:03:12 <ivanm> I _did_ want to do an FP project for my PhD next year in computational combinatorics... but couldn't find anything like that in the unis I was considering :s
00:03:15 <Myoma> ?go self applicable lambda calculus partial evaluator
00:03:18 <lambdabot> http://citeseer.ist.psu.edu/61020.html
00:03:18 <lambdabot> Title: Self-applicable partial evaluation for pure lambda calculus - CiteSeerX
00:03:29 <Cale> ankh47: You can create a function which takes () as a parameter, but that's silly to do.
00:03:36 <Myoma> on that same totally functional thing, this paper is fun
00:04:08 <Cale> Actually, isn't the usual Stream datatype nothing more than (a -> c -> c) -> c ?
00:04:13 <ankh47> any special syntax required ? when i write it like \ -> .... i get a "syntax error at ->" messsage).
00:04:33 <Cale> ankh47: right, lambdas always need parameters
00:04:46 <Cale> ankh47: you can write (\() -> ...)
00:04:48 <Myoma> I'd have thought stream a = (a,stream a)
00:04:49 <Cale> but it's silly
00:04:55 <ankh47> cale: i came to that, but because it's ugly :-(((
00:05:09 <Cale> ankh47: why not just write the part after the -> ?
00:05:28 <Cale> ankh47: a function of no parameters might as well be a value
00:05:48 <Cale> because you can only apply it trivially, and so it always has to result in the same thing
00:06:09 <Myoma> (\() -> ...) is nice because it lets you use . for application
00:06:34 <ankh47> cale: it's a "cached" value, that nedds to be refreshed sometimes ...
00:06:43 <Cale> ankh47: values never change
00:07:12 <Cale> :)
00:08:30 <ankh47> cale: veeeeery funny, but the only one here suggesting using a value were you ;-)
00:08:54 <Cale> Functions always give the same value when you give them the same parameters.
00:09:05 <Cale> So if a function has no parameters, it always gives the same value.
00:09:05 <Myoma> ankh47: "a 0-parameter lambda" is a value
00:09:23 <ankh47> i eed an action that looks wheter the cache is stale and either return it or update & return it.
00:09:33 <Cale> ankh47: Then it cannot be a plain function :)
00:09:47 <Cale> ankh47: It might be an action, in some monad (like the IO monad in particular)
00:09:51 <Nafai> Sounds like a case for monads :)
00:10:02 <Cale> Or it might be a function which takes the cache as a parameter
00:10:29 <Cale> (and returns either an unmodified or updated cache)
00:11:44 <Cale> The result of a function is only affected by its parameters, so if it needs to access a cache, that cache had better be a parameter :)
00:12:38 <Cale> Of course, if the cache is effectively constant once computed, you could also just use a constant value.
00:13:08 <Cale> (which will only be computed once, unless it has a typeclass-polymorphic type)
00:14:28 <ankh47> well i want to share a list of caches among many webserver sessions. so i thought i create list/map of closures. ok, i can just take the cache index as parameter and it would do ...
00:14:53 <Cale> "closure" is a funny word to use :)
00:14:55 <ankh47> btw, since i mentioned that the cache gets stale and needs to be updatet at some time, plain values are not of much use :-p
00:15:28 <Cale> I tend to think of closures as an implementation mechanism for functions, which is effectively a pair. :)
00:15:43 <Cale> (one possible implementation mechanism)
00:15:57 <ankh47> cale: why, it encloses a value defined outside of its scope, what's so weird about it ?
00:16:24 <Cale> (the pair consists of some syntax tree or code, and an environment consisting of a mapping from free variables of the code to values)
00:16:42 <Cale> Saying "closure" implies that you have access to the components of that pair, in my mind :)
00:17:00 <Cale> That is, it's like you're writing a compiler or something :)
00:17:36 <Cale> Once you stop allowing separate access to the code and environment, it becomes a function, (or procedure, if it has effects).
00:17:36 <Myoma> ankh47: You are coming from a procedural language ?
00:17:56 <Cale> It's just a language thing :)
00:17:57 <ankh47> it's all just how you want to look at what it really does. how you reason about mechanism you have at your disposal doesn't matter so much al long as you get them right imho.
00:18:08 <Cale> I suppose, yeah.
00:18:28 <Cale> I've just been troubled by too many flamewars about whether to "add closures" to some language.
00:18:45 <Cale> Closures are not really a language feature, they're an implementation mechanism :)
00:19:12 <Myoma> java already has closures
00:19:17 <Cale> Right.
00:19:25 <ankh47> basic -> pacal -> c-> c# -> ruby -> smalltalk -> lisp -> haskell (maybe not so liner process, and a few more in between, but basically yeah, i've using procedural langs for loong time ;-)
00:19:28 <Cale> It just doesn't have first class functions/procedures :)
00:19:47 <Nafai> Cale: Which is a huge pain point for me every day :)
00:20:10 <Myoma> ankh47: so the biggest change is probably purity
00:20:15 <Cale> Or perhaps it's more correct to say that it's quite possible that most implementations of Java involve closures :)
00:20:40 <Myoma> Cale, just because inner classes can close over variables
00:20:54 <ankh47> myoma: yeah, and what that should get me is the reason i try to cram it into my brain instead of saying fuck it and sticking to ocaml ;-)
00:21:22 <Myoma> ankh47: You didn't list ocaml in the timeline
00:21:51 <Myoma> ankh47: haskell isn't harder than ocaml anyway
00:22:51 <ankh47> because i decidet to learn haskell instead .. they are basically the same, only real difference is haskell is lazy & pure and ocaml is strict & impurity allowing
00:22:59 <ivanm> is there a difference between Set.elems and Set.toList?
00:23:13 <Cale> ivanm: no
00:23:25 <Cale> ivanm: There are lots of silly names for the same thing in that module :)
00:23:29 <ivanm> so why the to names? to satisfy different instances?
00:23:33 <ivanm> Cale: yeah, I've noticed :s
00:23:46 <Cale> I'm not sure... maybe historical reasons.
00:23:47 <ivanm> and there's no way of picking elements without converting it to a list first :s
00:23:51 <Cale> There's also toAscList
00:23:52 * RayNbow notices that Hoogle has been changed slightly
00:24:01 <Cale> ivanm: picking elements?
00:24:11 <ivanm> Cale: if that was the case, then wouldn't it have them listed in the deprecated section?
00:24:11 <Cale> ivanm: Like filter?
00:24:19 <ivanm> Cale: like a maximumBy on sets
00:24:48 <Cale> Set is an instance of Foldable
00:24:55 <Cale> So you can use Data.Foldable.maximumBy
00:25:13 <ivanm> ooohhhh.... I didn't know that!
00:25:30 <ivanm> is there a way of picking a random element without resorting to converting to a list first?
00:25:37 <Cale> mm...
00:26:42 <Cale> More efficiently than converting to a list? There ought to be, but I'm not sure that there actually is.
00:26:54 <ivanm> *nod*
00:27:35 <RayNbow> the Set is a treeset, right?
00:27:38 <Cale> yes
00:27:49 <ivanm> what in general is better? f . maximumBy (compare `on` f) , or maximum . map f ?
00:27:57 <Cale> It would be nice if there were a way to project out the representative tree.
00:28:16 <Myoma> maximum . map f
00:28:18 <ivanm> Cale: as in a data structure tree, rather than a printed version?
00:28:20 <ivanm> Myoma: *nod*
00:28:21 <Cale> ivanm: For efficiency, the latter.
00:28:30 <Cale> ivanm: yeah
00:28:36 <Myoma> :t \f -> f . maximumBy (compare `on` f)
00:28:37 <lambdabot> forall b c. (Ord c) => (b -> c) -> [b] -> c
00:28:44 <Myoma> :t \f -> maximum . map f
00:28:45 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> b
00:29:01 <Cale> Of course, there would be no guarantee that two equal sets give the same tree...
00:29:28 <ivanm> Cale: true
00:29:41 <ivanm> if foldable normally imported qualified?
00:29:47 <Cale> yeah
00:29:51 <Cale> because of the Prelude :)
00:29:59 <ivanm> silly prelude :p
00:30:45 <Cale> Not to dis the Prelude *too* much, there's plenty of beautiful code in there really. But the mistakes hurt so much :)
00:31:51 <Cale> You know what...
00:32:09 <Cale> Foldable is missing just one thing and I think it's exactly what you'd need :)
00:37:18 <Cale> Yeah...
00:37:48 <Cale> Actually, you can, in a hackish way, get at the tree structure :)
00:38:21 <Cale> Using Data.Foldable.fold, and a not-so-scrupulous instance of Monoid for a tree type :)
00:40:34 <Cale> But the ideal thing would be foldM, which isn't there.
00:41:12 <Cale> (but can be awkwardly written using fold and said unscrupulous instance of Monoid)
00:42:00 <ivanm> heh, I think I'll stick to converting it to a list and then randomly choosing one from there
00:42:19 <Cale> yeah, probably easier, and won't make too much difference for small numbers of elements
00:50:06 <Cale> http://hpaste.org/9838
00:50:39 <ivanm> gah!
00:51:16 <ivanm> what's the integer there for? node count?
00:51:19 <Cale> yeah
00:51:37 <Cale> So that if you were to use it to generate a random one, you'd know what probability weights to use :)
00:51:46 <ivanm> heh
00:52:38 <ivanm> so foldMap automatically goes and combines them?
00:52:43 <Cale> yeah
00:53:48 <Cale> ... and it can't tell when the instance of Monoid you supply doesn't satisfy the associativity axioms. :)
00:53:52 <Cale> er, axiom :)
00:54:49 <Cale> So you can reveal the actual structure being used to represent the Set. It's awkward to have to do that though.
00:56:39 <Cale> Interestingly, Data.Sequence always seems to associate things to the right.
00:57:22 <Cale> Seems like it might be slightly more efficient another way, but not asymptotically, anyway.
00:59:58 <RayNbow> @pl (\x -> Leaf x)
00:59:58 <lambdabot> Leaf
01:04:18 <dewpearl> I've got some issue with the ax of dependent choice - anyone familiar with it?
01:13:01 * Axman6 's choices are are rarely dependent
01:19:14 <dewpearl> :)
01:25:29 <explicitjelly> how do you document your data types?
01:25:53 <Wild_Cat> with Haddock.
01:25:57 <explicitjelly> stuff like "data Foo a b = Bar [a] [a] a b [b]" isn't very descriptive
01:27:10 <explicitjelly> ah. so even if I don't use haddock, I suppose I could just use its comment syntax
01:28:05 <Wild_Cat> explicitjelly: well, the Haddock comment syntax is pretty much "add a | or a ^ at the beginning of your comments" :p
01:29:01 <explicitjelly> Wild_Cat, yup... better than coming up with my own convention which won't have the benefit of being processable by haddock... thanks!
01:29:27 <Wild_Cat> to be more precise, -- |This documents the next declaration
01:29:36 <Wild_Cat> and -- ^This documents the previous declaration
01:29:38 <explicitjelly> I prefer -- ^ foo
01:29:52 <explicitjelly> because I can comment on the same line.
01:39:58 <explicitjelly> suppose I need an "incrementing counter" monad...
01:40:06 <explicitjelly> yes, I could use a State monad, but isn't there something prebuilt?
01:40:13 <explicitjelly> seems like an awfully common pattern
01:40:53 <Cale> explicitjelly: hmm... at one point I wrote a Supply monad and put the code on the wiki
01:41:14 <explicitjelly> nice. but you also wrote it yourself...
01:41:16 <Cale> If there isn't a package on Hackage for it, then the code is probably still there
01:42:32 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
01:42:33 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
01:43:15 <explicitjelly> thx
01:48:14 <mgsloan> argh, ICFP perfectly coincides with the beginning of university of washington >.< so close yet so far
01:48:21 <mgsloan> I'm noo late for early reg anyway tho
01:49:26 <mgsloan> (Vancouver is very close to seattle..)
01:59:50 <explicitjelly> heh. sometimes thinking about how I'll layout a function takes longer thank thinking about the function's code.
02:01:00 <trofi> > recip 3 :: CReal
02:01:01 <lambdabot>  0.3333333333333333333333333333333333333333
02:04:44 <explicitjelly> writing Haskell is really fun
02:04:55 <explicitjelly> every other language becomes boring and tedious in comparision
02:05:15 <Wild_Cat> Haskell is fun indeed. So is Python IMO, though.
02:05:28 * hml thinkgs scheme is more fun
02:05:30 <ulfdoz> explicitjelly: Pscht! Don't let the C-kiddies in #linux.de hear that. :)
02:05:40 <explicitjelly> yes, although haskell has superceded python as my favorite language...
02:05:46 <explicitjelly> ulfdoz, heheh
02:08:04 <Wild_Cat> to me, Python will be hard to supercede. Equal, at most. But I doubt Haskell will supercede it in the end. I know Python far too well for that ;)
02:08:30 <hml> what do you guys like about python
02:08:38 <hml> i find the languyage repulsive
02:08:43 <hml> it's like a half hearted attempt at lisp
02:09:51 <mgsloan> my problem is that haskell's too good, but not perfect.  Whereas with C or something I'll be comfortable with crappy code, with haskell i feel i need to attain perfect succinctity and semantic accuracy
02:11:04 <explicitjelly> mgsloan, I think I know what you mean
02:11:08 <Vq^> hml: that objects is dictionaries can be quite usefull, you can often hijack the existing object-system instead of reinventing it
02:11:33 <int-e> hml: it has a nice syntax, it's easy to learn, and it has very nice libraries. it has a simple object model, too.
02:12:52 <jeffz> slow as molasses, forced whitespace layout, dynamically typed.
02:14:07 <int-e> Sure, it has its limits. I didn't want to imply that it was a perfect language, but it has a few things going for it.
02:14:09 <Vq^> it can actually be surprisingly fast if done right
02:14:45 <Vq^> space-indentation is actually not a bad thing mostly
02:15:33 <Vq^> and the lack of typing can actually be dealt with, just look at Zopes handling of interfaces
02:15:35 <Wild_Cat> hml: in short, Python is elegant, powerful, pragmatic and its stdlib is mighty useful.
02:16:03 <dobblego> haha
02:16:51 <hml> i have a different theory
02:16:59 <Vq^> it's lacking in the functional parts though, i wanted to concatenate two generators the other day and it turned quite sour :(
02:17:00 <hml> i think what makes python 'more pragmatic' than scheme
02:17:07 <hml> is that python is not as well defined as scheme
02:17:16 <hml> as a result, there's only one python implementation instead of 20 fragmented scheme ijmplementations
02:17:26 <dobblego> pragmatism is a flawed philosophy; waving it around as a complement is amusing
02:17:28 <hml> thus everyone ends up contributing to the ONE python rather than their favorite scheme
02:17:48 <Vq^> one large python implementation...
02:18:00 <loop> jython? ironpython? stackless python?
02:18:15 <hml> doesn't compare to the # of scheme implemntations out there
02:20:25 <explicitjelly> python could be a tad more functional, yes
02:21:29 <dons> woo. finished the final chapter of the book. phew!
02:21:35 <quicksilver> \o/
02:21:38 <osfameron> yay!
02:21:50 * dons stares at a pile of 700 pages in disbelief
02:22:11 <dons> this thing'll stop a bullet.
02:22:23 <Vq^> dons: congratulations :)
02:22:24 <ivanm> dons: you going to test it?
02:22:33 <ivanm> what caliber bullet, anyway? :P
02:22:54 <Wild_Cat> hml: Python has a real language specification, though.
02:22:55 <dons> we should be able to get the final chapter up in the morning, and then everyone has a week or two to do the last tech reviews.
02:23:06 <dons> before the text disappears entirely into the oreilly production pipeline
02:23:18 <Wild_Cat> and by "real language specification", I mean implementation-independent.
02:23:19 <dons> to emerge the other side stronger and brighter, in dead tree form :)
02:24:02 <dons> fingers crossed the LHC doesn't destroy the world before then.
02:24:04 <Wild_Cat> but that's irrelevant. Python's true selling point is that it allows its users to get stuff done fast.
02:24:26 <quicksilver> dons: are oreilly doing any editing?
02:24:37 <dons> quicksilver: they have dedicated copy editors, yep.
02:24:43 * quicksilver nods
02:24:50 <quicksilver> I wonder how much they'll butcher it :)
02:24:58 <dons> grammar only, i hope :)
02:25:08 <dons> but there's got to be some inconsitencies in that much text.
02:25:13 <dons> split over three authors.
02:25:17 <Adamant> people are complaining about Ruby's libraries, but the same complaints were once leveled at Python in comparison to Perl's CPAN.
02:25:33 <dons> Adamant: and once upon a time, we didn't have 750 haskell libraries :)
02:25:40 <Adamant> that too!
02:25:41 <dons> there's 4k libs on pyPI.
02:25:52 <dons> and we're 1/6th of the way there.
02:25:56 <dons> pretty freaking awesome.
02:25:59 <Adamant> indeed
02:26:07 <Adamant> and not in small part due to you
02:26:19 <ivanm> but does python have a cli downloader/installer? :o
02:26:23 <Wild_Cat> yeah, Haskell has quite a few nice libs. That's part of the reason I'm learning it and not, say, Ocaml or Lisp.
02:26:25 <ivanm> (ruby has gems, IIRC...)
02:26:28 <quicksilver> python is what you get if you impose some regularity in Perl and remove inconsistencies, remove many of the multiple ways of doing the same thing.
02:26:32 <Wild_Cat> ivanm: it has easy_install.
02:26:35 <ivanm> ahhh
02:26:36 <dons> ivanm: good question.
02:26:37 <Wild_Cat> it's not great, but it's there.
02:26:38 <quicksilver> as such, I find it surprising that people get so excited about it.
02:26:44 <quicksilver> it's really just a slow version of Perl
02:26:49 <Adamant> quicksilver: nah
02:26:52 <quicksilver> with a bit more regularity imposed by the language.
02:27:10 <osfameron> quicksilver: it has some niceties - the decorator syntax, multiply-resumable co-routines etc.
02:27:22 <ivanm> quicksilver: I thought perl was still primarily a string manipulation language, whereas python is touted as a "glue" language...
02:27:25 <int-e> quicksilver: people can get excited about any programming language. :P
02:27:31 <osfameron> (the lack of the second being a problem in trying to trivially implement nice monad-syntax in perl)
02:27:34 <Adamant> they're both glue languages
02:27:35 <Wild_Cat> quicksilver: and real memory management (as in, a GC in addition to the refcounter), a standard object system, pervasive documentation and quite a few other things.
02:27:39 <ivanm> int-e: even BASIC? or brainfuck? :p
02:27:43 <osfameron> they're both languages...
02:27:44 <int-e> ivanm: sure
02:27:52 <dobblego> quicksilver, because they don'
02:27:55 <dobblego> t know any better ala blub
02:27:59 <mgsloan> dons - from the comments people are leaving, looks like you have some very close readers already. see stuff i totally miss hah
02:28:14 <Adamant> people got excited about the original BASICs and VB at least, and for good reason
02:28:21 <dons> mgsloan: yeah, there's a dozen or so guys that must have read the entire thing, line by line.
02:28:22 <int-e> ivanm: (I can attest to the latter. Brainfuck is great. :P)
02:28:39 <quicksilver> osfameron: I don't find those niceties exactly showstoppers. :) They are nice though.
02:28:59 <ivanm> int-e: heh
02:29:04 <mgsloan> are you going to icfp, by the way?  I'm seriously considering going since it's victoria and i'm in seattle
02:29:05 <quicksilver> Wild_Cat: real memory management is a good point. Although problems with perl's refcounting are fairly rare.
02:29:19 <quicksilver> Wild_Cat: the standard object system is exactly what I meant by 'impose some regularity on perl'
02:29:20 <hml> dons: which book is this?
02:29:35 <osfameron> quicksilver: well indeed.  But I was impressed with that when I read the monads-in-python post.  Didn't find it obvious and immediatley readable and beautiful, like pythonistas often claim it inherently is.  But powerful and elegant certainly.
02:29:48 <quicksilver> in many ways I find javascript a more attractive general purpose dynamic language than python.
02:29:55 <Wild_Cat> quicksilver: well, I submit that issues in memory management are enough to make Python a general-purpose language where Perl remains a scripting one.
02:29:55 <osfameron> And it beats my proposed hack of munging the optree and/or localised source filtering :-(
02:30:03 <Adamant> I can see that.
02:30:09 <Wild_Cat> (I doubt EVE Online could be done in Perl)
02:30:13 <quicksilver> but javascript is not really set up around general purpose computing.
02:30:15 <osfameron> Wild_Cat: but that's silly.  Perl is a general purpose programming language
02:30:18 <Wild_Cat> as for Javascript, it has no stdlib.
02:30:26 <Adamant> it wasn't done in regular Python, it was done in Stackless
02:31:01 <quicksilver> Wild_Cat: As someone with 13 years experience on and off using Perl commercially as a general purpose programming language, and employing a team of half a dozen people who have between them 30-40 years aggregate experience between them...
02:31:05 <quicksilver> Wild_Cat: I have to disagree :)
02:31:07 <Wild_Cat> Adamant: they're the same language. Stackless just adds one concept. (a real useful one, admittedly)
02:31:16 <quicksilver> Perl is definitely used as a general purpose programming language.
02:31:25 <Adamant> Wild_Cat: I thought Stackless was a seperate distro
02:31:33 <Adamant> or is it like Template Haskell?
02:31:43 <osfameron> its memory management is no worse (in fact rather better) than C's, which is very rarely accused of being a scripting language
02:31:46 <Wild_Cat> Adamant: it is, because the one additional concept requires under-the-hood changes.
02:32:06 <Cale> > describeSequence [0,1,2,4,8,14,28]
02:32:07 <lambdabot>  Just "Least number m such that every tournament with at least m nodes contai...
02:32:20 <Cale> > extendSequence [0,1,2,4,8,14,28]
02:32:22 <lambdabot>  [0,1,2,4,8,14,28]
02:32:25 <Wild_Cat> Adamant: namely, minimizing the use of the C stack. But as long as you don't "import stackless", there's *no* difference between regular and Stackless Python.
02:32:25 <Cale> hehe :)
02:32:41 <Adamant> lol, did you hook it into the ODIS?
02:32:57 <Cale> Yeah, that's the oeis package. :)
02:33:11 <Adamant> haha
02:33:11 <Cale> > extendSequence [0]
02:33:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:33:27 <dons> hml, "real world haskell"
02:33:29 <Wild_Cat> also, Guido has a different vision than Larry. That's reason enough for people to switch from Perl to Python.
02:33:47 <Adamant> I am not a fan of Guido's vision
02:33:51 <mgsloan> > extendSequence [1, 1, 2, 3, 5, 8]
02:33:53 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:34:03 <mgsloan> new way to write fibs :)
02:34:18 <ivanm> Wild_Cat: which one needs glasses? :p
02:34:29 <Wild_Cat> Adamant: I am. ;)
02:34:43 <Adamant> haha, that's the important thing right? ;)
02:34:48 <Wild_Cat> exactly;
02:34:56 <hml> dons: is the entire book availbal e online still?
02:35:45 <dons> hml, well, not yet the chapter i just finished, but yeah. the betaaa.
02:36:29 <dons> i wonder if RWH is the first book to be tech reviewed using a wiki-like, open, online system. that would be cool.
02:36:37 <dons> we could write a paper about it :)
02:36:45 <ivanm> dons: I thought you based it off another book...
02:36:51 <hml> dons: you ah academic?
02:36:54 <Cale> "The smallest number N that satisfies the strengthened finite Ramsey theorem is a computable function of n, m, k, but grows extremely fast. In particular it is not primitive recursive, but it is also far larger than standard examples of non primitive recursive functions such as the Ackermann function. Its growth is so large that Peano arithmetic cannot prove it is defined everywhere, although Peano arithmetic easily p
02:36:54 <Cale> roves that the Ackermann function is well defined."
02:36:57 <ivanm> at least I seem to recall reading that on your blog when you started writing it...
02:37:03 <dons> hml, not any more. i was doing a phd for the last 5 years though.
02:37:10 <hml> dons: ... you wrote real world haskell?
02:37:23 <dons> hml, i'm one of the guys writing it, yeah.
02:37:35 <explicitjelly> (forall b. (Data b) => b -> b)
02:37:35 <quicksilver> Wild_Cat: people using perl are not doing it for larry's vision; they're doing it for the language as it is now.
02:37:37 <hml> are you the same dons what wrote xmonad?
02:37:42 <dons> yup
02:37:47 <explicitjelly> is there really a difference to (Data b) => b -> b
02:37:47 <quicksilver> Wild_Cat: (if you were using it for a vision of the future you would be hopelessly optimistic)
02:37:49 <explicitjelly> without the forall?
02:38:00 <quicksilver> explicitjelly: the forall is implicit if not mentioined.
02:38:11 <Wild_Cat> dons: nevertheless, I read bits and pieces of RWH and it looks good. More... Well, more real-world than "The craft of functional programming", which really does look like it was written by someone who doesn't expect you to ever actually use Haskell.
02:38:13 <explicitjelly> quicksilver, ah, ok
02:38:15 <quicksilver> (the ability to explicitly mention it is a GHC extension; under haskell 98 all foralls are implicit)
02:38:43 <explicitjelly> quicksilver, so why is it not also, for example, forall m. Monad m => (a -> m b)... for map?
02:38:50 <explicitjelly> mapM
02:38:52 <explicitjelly> not map
02:38:53 <ivanm> quicksilver: but does that ability do anything practical (apart from making type sigs longer)?
02:38:53 <Wild_Cat> quicksilver: same with Python. But what both languages are now directly stem from Guido's and Larry's respective visions.
02:38:53 <quicksilver> it is.
02:38:56 <quicksilver> :t mapM
02:38:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:39:07 <BeelsebobWork_> @hoogle on
02:39:08 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:39:08 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
02:39:08 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
02:39:09 <dons> Wild_Cat: heh. yeah, we *demand* you use Haskell.. Now!
02:39:10 <quicksilver> in fact there is a further GHC extension there (kind signatures)
02:39:19 <explicitjelly> Prelude Data.Generics> :t mapM
02:39:19 <explicitjelly> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
02:39:19 <explicitjelly> Prelude Data.Generics> :t gmapT
02:39:19 <explicitjelly> gmapT :: (Data a) => (forall b. (Data b) => b -> b) -> a -> a
02:39:20 <quicksilver> Wild_Cat: yes, that's totally fair.
02:39:29 <explicitjelly> so ghci is just funky? %)
02:39:31 <quicksilver> Wild_Cat: I'm not actually trying to say that python isn't better than Perl.
02:39:35 <quicksilver> Wild_Cat: in many ways it is.
02:39:46 <explicitjelly> quicksilver, are there any other existential quantors?
02:39:46 <quicksilver> what I'm trying to say is that those ways are rather minor, in my opinion.
02:39:54 <explicitjelly> quicksilver, I mean, why the "forall" keyword at all?
02:40:04 <Wild_Cat> quicksilver: neither am I making the converse point. I'm just trying to explain why a lot of people, me included, use Python. ^^
02:40:07 <quicksilver> and I find the buzz around python surprising since it's really just perl-cleaned-up.
02:40:23 <quicksilver> explicitjelly: because when it's in parantheses it matters :)
02:40:31 <quicksilver> explicitjelly: the implicit foralls are always at the top level (far left)
02:40:38 * osfameron isn't sure python is perl-cleaned-up
02:40:42 <quicksilver> an explicit forall not at the top level might mean something different.
02:40:45 <osfameron> they date from very nearly the same time
02:40:57 <osfameron> and have many similarities but also many differences
02:40:58 <Wild_Cat> quicksilver: I'm not sure it is, really. *Ruby* is Perl cleaned up.
02:41:01 <quicksilver> osfameron: I'm not suggesting that is its genesis; or its objective.
02:41:16 <quicksilver> osfameron: I'm suggesting that that is its state. By accident rather than design.
02:41:20 <explicitjelly> quicksilver, hmmm... example?
02:41:21 <osfameron> heh
02:41:35 <quicksilver> they are both dynamic languages centered around hashtables/dictionaries
02:41:42 <quicksilver> with a more-or-less ad hoc object system
02:41:48 <quicksilver> and good sets of standard libraries
02:41:57 <quicksilver> their similarities far outweight their differences IMO.
02:42:04 <klugez> dons: The comment system is modeled after this one: http://www.djangobook.com/
02:42:05 <lambdabot> Title: The Django Book
02:42:17 <osfameron> and don't forget "fairly good support for (untyped, impure) functional programming"
02:42:30 <GremlinHunter> Does perl have lambdas?
02:42:33 <osfameron> yes
02:42:48 <osfameron> full multiline ones, unlike python :-)
02:42:50 <explicitjelly> @src gmapT
02:42:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:43:03 <explicitjelly> ... i WHAT?
02:43:07 <Wild_Cat> quicksilver: I disagree.
02:43:43 <lilac> python is perl cleaned up in pretty much the same way that delphi is C cleaned up ;-)
02:44:13 <quicksilver> explicitjelly: simple examples are not that common.
02:44:16 <explicitjelly> python really isn't very common to perl
02:44:18 <Wild_Cat> the main way in which both languages diverge is that Python attempts to have a minimalistic, easy to parse and remember syntax. It has less than 30 keywords IIRC. Perl, OTOH, has ad-hoc syntax for pretty much everything including the kitchen sink.
02:44:32 <quicksilver> explicitjelly: erm. I mean, simple and useful.
02:44:34 <dons> klugez: ah yes, that's right. it's written with django, after all.
02:44:41 <quicksilver> explicitjelly: I can give you simple but useless examples :)
02:44:52 <quicksilver> explicitjelly: (forall a . a -> a) -> b -> b
02:44:55 <explicitjelly> quicksilver, you don't need to :) thanks anyway, you're always very helpful
02:44:59 <lilac> Wild_Cat: and there's probably half a dozen obvious ways of expressing the kitchen sink
02:45:11 <quicksilver> Wild_Cat: yes. That's the kind of thing I meant by regularity.
02:45:12 <Wild_Cat> After less than 1 year of casual experience, you can look at just about any Python program and understand it without ever looking up the *syntax* reference.
02:45:21 <quicksilver> Wild_Cat: (being present in python and absent from perl)
02:45:46 <quicksilver> but these things don't relate much to expressivity.
02:46:03 <quicksilver> given a particular algorithm, the python and perl code would look very similar, to those who knew both languages.
02:46:11 <quicksilver> (ignoring differences in libraries used)
02:46:22 <quicksilver> the same would not be true of, say, C and haskell.
02:46:26 <quicksilver> or C++ and lisp.
02:46:56 <osfameron> perl does have traps for the unwary
02:47:02 <lilac> ... but would be true of C and Pascal ...
02:47:06 <lilac> ... or C++ and Java ...
02:47:18 <Wild_Cat> quicksilver: Not *that* similar. Perl code will be procedural at heart. Python and its libs are OO-focused.
02:47:47 <osfameron> Wild_Cat: do you know Perl?
02:47:57 <ivanm> why does lambdabot have @src for mapAccumL but not mapAccumR?
02:48:13 <osfameron> Wild_Cat: and if so, and you are writing Moose and Cat code in procedural style, then you are very odd indeed.
02:48:17 <GremlinHunter> What about that len function :)
02:48:18 <Wild_Cat> osfameron: I did, a long time ago. Not in-depth, I must admit. And I know Perl has several OO systems.
02:48:43 <dons> ivanm, mapAccumR is the work of the devil.
02:48:49 <ivanm> is it? :o
02:48:51 <ivanm> how come?
02:48:54 <Wild_Cat> doesn't change the fact that the stdlib is procedural.
02:49:23 <quicksilver> Wild_Cat: the way perl is used in practice, typically, is very similar to the python object system.
02:49:29 <quicksilver> again, this is what I meant about regularity.
02:49:31 <osfameron> perl's stdlib is CPAN
02:49:39 <quicksilver> perl can be all kinds of things
02:49:42 <quicksilver> (irregular)
02:49:47 <mm_freak> what is the fastest indexing scheme for arrays?  intuitively i'd think that indexing with Int starting at 0 is the fastest, am i right?
02:49:47 <sjanssen> ivanm: I don't think I've ever seen mapAccumR used
02:49:47 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
02:49:52 <quicksilver> but perl used in practice has much in common with python commonalities.
02:49:53 <lilac> GremlinHunter: len() is just a wart from back in the day :)
02:50:10 <ivanm> sjanssen: so why is it there then?
02:50:12 <quicksilver> Wild_Cat: the perl standard library includes lots of OO libs now.
02:50:13 <mapreduce> Wild_Cat: OO depends on procedural, whether you are doing procedural or OO depends on your viewpoint.  Add in polymorphism of some kind and people will start claiming it's a form of OO.
02:50:33 <mapreduce> s/polymorphism/indirection/
02:51:17 <explicitjelly> "The type of gfoldl is a headache, but operationally it is a simple generalisation of a list fold. "
02:51:26 <explicitjelly> thanks, I was wondering.
02:52:21 <explicitjelly> @src gmapT
02:52:21 <lambdabot> Source not found. stty: unknown mode: doofus
02:52:37 <explicitjelly> @src gfoldl
02:52:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:52:39 <explicitjelly> :/
02:53:01 <dreixel> explicitjelly: http://www.cs.vu.nl/boilerplate/
02:53:04 <lambdabot> Title: Scrap your boilerplate ... in Haskell
02:53:54 <dreixel> actually http://www.haskell.org/ghc/dist/stable/docs/libraries/base/src/Data-Generics-Basics.html is better.
02:53:56 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6ho84j
02:54:03 <explicitjelly> dreixel, thx!
02:55:34 <quicksilver> the SYB types are likely to break your head.
02:55:43 <quicksilver> If you're using them as a source of learning, then good luck to you.
02:55:55 <quicksilver> If you actually want to do some metaprogramming, I'd check out uniplate first.
02:56:24 <explicitjelly> quicksilver, right now, SYB works quite well for me
02:57:20 <explicitjelly> ... I need to build my own extended version of "everything"
02:57:30 <explicitjelly> er, no, "everywhere"
02:57:55 <quicksilver> extended?
02:58:01 <explicitjelly> that's why I'm checking out gfoldl, because I'll actually need something similar to gmapT which isn't gmapT
02:58:26 <ivanm> Cale: that RG existential type for RandomGen instances... is there any particular reason you used case statements?
02:58:27 <explicitjelly> quicksilver, I'm passing the "path" of the tree-like structure as a list
02:58:46 <Cale> ivanm: I was afraid that let might give errors.
02:59:02 <ivanm> how about using first/second/*** ?
02:59:10 <Cale> ivanm: because sometimes that makes ghc's brain explode
02:59:17 <explicitjelly> so the generic function given to the gmapT-alike has type [a] -> a -> a instead of a -> a
02:59:19 <ivanm> those three? why? :o
02:59:23 <Cale> Or rather, Simon's brain :)
02:59:31 <ivanm> (and how can a piece of software have a brain???)
02:59:36 <ivanm> Cale: which Simon?
02:59:57 <ivanm> it just looks a bit weird having a single-case case statement?
03:00:05 <ivanm> s/?//
03:00:34 <dons> ivanm: good for evaluation.
03:00:45 <quicksilver> ivanm: you have to use case to deconstruct existentials.
03:00:57 <ivanm> oh, OK
03:01:07 <quicksilver> case introduces a new strictly closed scope.
03:01:10 <quicksilver> let doesn't.
03:01:16 <ivanm> dons: you never said why mapAccumR is so inherently evil...
03:01:20 <quicksilver> let-deconstructing two existentials recursively
03:01:21 <explicitjelly>   gmapT f x = unID (gfoldl k ID x)
03:01:21 <explicitjelly>     where
03:01:21 <explicitjelly>       k (ID c) x = ID (c (f x))
03:01:22 <Saizan> ivanm: the point is that let is lazy, but to get at the typeclass context soundly you've to be sure the value is not bottom
03:01:27 <quicksilver> would make a mess of the type system.
03:01:29 <ivanm> *nod*
03:01:31 <explicitjelly> I think it will take a while until I can wrap my head around that...
03:01:44 <ivanm> explicitjelly: what's that from?
03:02:13 <explicitjelly> ivanm, scrap your boilerplate, Data.Generics.Basics
03:02:32 <dreixel> explicitjelly: you should avoid using gfoldl directly, you probably don't need it at this stage anyway
03:02:43 <dons> ivanm: i think its an oversight not to be in @src :)
03:02:43 <explicitjelly> dreixel, ok, what do I use instead?
03:02:49 <dons> but saying it was evil is more mysterious.
03:02:56 <dreixel> explicitjelly: why is your path [a] and not [Int]?
03:03:02 <ivanm> dons: *nod*
03:03:03 <ivanm> heh
03:03:12 <explicitjelly> dreixel, uh, why should it be [Int]?
03:03:44 <dreixel> explicitjelly: denoting the argument numbers of where to go. How do you use it with [a], then?
03:05:04 <explicitjelly> dreixel, well, let's assume that the type is a simple binary tree type... an example for a path would be [Node (Node .. 2) (Node .. 3) 1, Node (Leaf 4) (..) 2, Leaf 4]
03:05:33 <explicitjelly> but, yes, that's not very beautiful.
03:05:44 <dreixel> fairly verbose :-)
03:05:57 <explicitjelly> hmm. maybe I do something else, entirely
03:06:00 <quicksilver> explicitjelly: do you know about zippers?
03:06:12 <dreixel> yeah, zippers are the best choice for paths, anyway.
03:06:22 <explicitjelly> quicksilver, ah, good idea!
03:06:28 <explicitjelly> I just recently learned about zippers
03:06:59 <quicksilver> that looked very much like a way of representing a tree zipper
03:07:08 <quicksilver> a tree zipper is precisely a path through a tree
03:07:12 <explicitjelly> hmm. I just realized... with the approach I'm following her, there's no need for generic programming anyway
03:08:32 <explicitjelly> meh. you know what. I'm just generating function names for lambda listing. I think I'll stick to "_lambda_<functionname>_<numericID>"... that way I can use the normal "everywhere'" and a simple State monad for incrementing the ID.
03:09:25 <explicitjelly> lambda lifting, not lambda listing
03:11:01 <explicitjelly> although it's a bit sad that I have to do the whole State monad boilerplate thing just to increment an ID.
03:31:43 <explicitjelly> hmm. there's a monadic variation on everywhere (called everywhereM), but not on everywhere'?
03:37:27 <mm_freak> converge (x0:x1:xs) = if x0 == x1 then x0 else converge (x1:xs)  -- am i reinventing the wheel?  or is there any more elegant way to express this?
03:38:21 <BONUS> hmm
03:38:37 <BONUS> you could do a group
03:38:45 <BONUS> and then select the head of the first group with more than 1 element
03:39:40 <BONUS> converge = liftM head . find ((>1) . length) . group
03:40:28 <BONUS> hmm wait that doesn't work on infinite lists
03:40:38 <BONUS> eugh
03:44:11 <mm_freak> BONUS: that was my original idea, but it doesn't work that way
03:44:52 <mm_freak> it works that way: head . head . dropWhile (\(x:xs) -> null xs) . group
03:44:59 <mm_freak> but that's very ugly IMO
03:45:31 <BONUS> how about converge xs = fst . head . dropWhile (uncurry (/=)) . zip tail . tail $ xs
03:45:43 <mm_freak> that's even more ugly
03:45:43 <BONUS> yeah this is also ugly as well too i think
03:46:21 <mm_freak> i like the above code best, i just wanted to know whether i'm reinventing the wheel
03:46:54 <BONUS> yeah hmm, i don't think htere's such a function in the standard libraries
03:46:58 <mm_freak> i couldn't find something like 'converge' in the base libs
04:05:38 <medfly> how do i add a package? (i wanna use utf-8)
04:06:41 <quicksilver> download, install.
04:06:50 <quicksilver> you make choose to install cabal-install, to make it easier.
04:06:52 <medfly> yes, i'm not sure how to do the install part
04:07:27 <dcoutts_> medfly: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
04:07:29 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
04:07:37 <medfly> thanks.
04:07:51 <dcoutts_> medfly: or for a quick-install script for cabal-install see:
04:07:53 <dcoutts_> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
04:07:54 <lambdabot> Title: CabalInstall - Hackage - Trac
04:08:59 <medfly> cool. :)
04:08:59 <mm_freak> i'm proposing to add an 'isqrt' function to Integral in the next haskell standard
04:11:04 <mm_freak> the isqrt is easy to calculate from other Integral functions, so essentially just adding that function and giving a default definition would do
04:14:39 <quicksilver> mm_freak: would be nice to have bindings to more of the relatively fast operations GMP provides.
04:14:55 <quicksilver> mm_freak: (or an alternative large integer implementation, of course, but bindings anyway)
04:15:11 <quicksilver> mm_freak: the Integer interface provided currently is irritatingly limited.
04:16:38 <mm_freak> quicksilver: yeah, and it's very frustrating that you can't even do anything about it, even though the code to do it is right in the executable, waiting to be called
04:17:53 <mm_freak> despite that GHC is wonderful everywhere else, this design decision was one major mistake
04:18:58 <quicksilver> mm_freak: design decision makes it sound like a concious decision to exclude it.
04:19:05 <quicksilver> mm_freak: I think it's simply that nobody has got around to it.
04:19:34 <quicksilver> mm_freak: I'm sure a patch to reroute more of gmp's underlying facilities to the haskell layer would be gratefully received :)
04:20:13 <mm_freak> quicksilver: well, using GMP as the underlying bigint library is a design decision, isn't it?  i'm not talking about conceptional design
04:20:25 <mm_freak> yeah
04:20:45 <quicksilver> using GMP is a design decision.
04:20:53 <quicksilver> I'm not qualified to judge if it was a bad one, I don't know what the choices were.
04:21:07 <quicksilver> Not binding more of the underlying functionality up to the haskell layer was just 'we haven't done this yet'
04:21:22 <mm_freak> i'd be happy to see the GMP developers move to the BSD license, and the GHC developers to provide interfaces to GMP
04:21:22 <pozic> It's not like it's an irreversible choice.
04:21:24 <Adamant> is Liskell included with ghc-6.8?
04:21:45 <pozic> Adamant: not that I know of.
04:22:02 <mm_freak> quicksilver: there were other choices, and i think GMP was chosen because of its performance
04:22:20 <pozic> Adamant: IIRC it was a branch at some time.
04:22:28 <mm_freak> it has always been superior to all other bignum libraries
04:23:05 <pozic> mm_freak: it's not superior, just better for most purposes.
04:23:28 <pozic> mm_freak: and they would never ever change to a BSD license.
04:23:44 <mm_freak> pozic: yeah, because it's GNU
04:23:50 <quicksilver> mm_freak: I'd be happy to see GHC move to the GPL to become more GMP compatible ;)
04:23:53 <quicksilver> but that's not going to happen either.
04:24:16 <mm_freak> quicksilver: that wouldn't solve the GMP problem
04:24:28 <mm_freak> it's not GHC using GMP, because that's fine
04:24:29 <pozic> GNU MP is LGPL.
04:24:37 <mm_freak> it's the compiled programs using GMP without providing source code
04:24:55 <pozic> mm_freak: it's the statically compiled programs using GMP.
04:25:08 <mm_freak> yes, i meant that
04:25:23 <mm_freak> it GMP were linked dynamically, it would be alright, but that wouldn't work
04:25:40 <pozic> What wouldn't work?
04:25:53 <mm_freak> linking GMP dynamically, because you'd require the end-user to have GMP installed
04:26:02 <pozic> Also, you can just distribute all the object files.
04:26:19 <pozic> mm_freak: no, that's not true.
04:26:26 <mm_freak> how?
04:26:41 <pozic> mm_freak: you can always ship the library yourself to.
04:26:45 <pozic> too*
04:27:11 <pozic> mm_freak: i.e. find the library in the system paths and when not found use the one you shipped.
04:27:44 <pozic> mm_freak: Unfortunately, I don't know how practical it is to do that currently.
04:27:50 <mm_freak> pozic: "it wouldn't work" in that it would be a major burden
04:28:28 <mm_freak> for example, it would make distributing binaries difficult
04:28:51 <pozic> mm_freak: yes, I suppose it would.
04:29:02 <pozic> mm_freak: discussing it has no use, though.
04:29:19 <pozic> mm_freak: it has been discussed at least a couple of times on the mailing lists.
04:30:13 <pozic> What I don't know is whether a program that doesn't use bignums still links in gmp.
04:31:36 <int-e> the RTS interfaces gmp.
04:31:43 <int-e> also Integer is pretty much omnipresent
04:32:01 <pozic> :t take
04:32:02 <lambdabot> forall a. Int -> [a] -> [a]
04:32:18 <pozic> Most Prelude functions take Ints.
04:32:26 <int-e> (not quite, but it's very easy to have it sneak in, after all it's the default Num instance)
04:33:12 <int-e> > [1..]
04:33:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:33:27 <pozic> Also, does the LGPL state that it has to be easy to change the updated gmp library?
04:33:40 <mm_freak> pozic: the default integral type is Integer
04:33:50 <pozic> I thought it merely stated that it's possible.
04:34:04 <mm_freak> :t print 0
04:34:06 <lambdabot> IO ()
04:34:10 <mm_freak> uhm
04:34:20 <mm_freak> :t 0
04:34:21 <lambdabot> forall t. (Num t) => t
04:34:30 <int-e> @src fromIntegral
04:34:31 <lambdabot> fromIntegral = fromInteger . toInteger
04:34:35 <mm_freak> :t 0 `div` 1
04:34:36 <lambdabot> forall t. (Integral t) => t
04:34:44 <int-e> (ok, that one gets optimized in many cases)
04:40:30 <trofi> @src Monoid []
04:40:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:40:52 <trofi> @src Monoid
04:40:52 <lambdabot> class Monoid a where
04:40:52 <lambdabot>     mempty  :: a
04:40:52 <lambdabot>     mappend :: a -> a -> a
04:40:52 <lambdabot>     mconcat :: [a] -> a
04:42:15 <BONUS> mappend = (++), mempty = []
04:42:19 <BONUS> :]
04:42:58 <pozic> BONUS: are you a member of somethingawful.com?
04:44:57 <trofi> @help src
04:44:57 <lambdabot> src <id>. Display the implementation of a standard function
04:45:12 <trofi> @src Monoid [a]
04:45:12 <lambdabot> Source not found. Maybe you made a typo?
04:45:18 <trofi> @src [] Monoid
04:45:18 <lambdabot> Source not found. Are you on drugs?
04:45:36 <ivanm> trofi: that's part of an instance declaration, so lambdabot won't have it
04:47:26 <quicksilver> ivanm, trofi: lambdabot has some things which are part of instance declarations
04:47:34 <quicksilver> @src mempty []
04:47:34 <lambdabot> Source not found. stty: unknown mode: doofus
04:47:37 <quicksilver> @src mempty [a]
04:47:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:47:42 <quicksilver> @src [a] mempty
04:47:42 <lambdabot> Source not found.
04:47:45 <quicksilver> but not this one :)
04:48:19 <sw17ch> this lambdabot has had a lobotomy
04:48:29 <quicksilver> our friend @src is useful but arbitrary in its coverage.
04:48:29 <ivanm> quicksilver: oh?
04:48:45 <ivanm> maybe they should re-parse the ghc source ;-)
04:50:21 <pozic> lambdabot could use some self-reflection.
04:50:36 <Botje> @vixen do you have a reflection?
04:50:36 <lambdabot> i do occassionally, i guess
04:51:24 <quicksilver> @src (->) first
04:51:25 <lambdabot> first f = f *** id
04:51:30 <quicksilver> an example of a method source :)
04:52:57 <trofi> :t []
04:52:58 <lambdabot> forall a. [a]
04:53:31 <trofi> :t [] :: []
04:53:32 <lambdabot>     `[]' is not applied to enough type arguments
04:53:32 <lambdabot>     Expected kind `?', but `[]' has kind `* -> *'
04:53:32 <lambdabot>     In an expression type signature:
04:54:54 <pozic> mm_freak: Also, http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
04:54:56 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac
04:55:47 <mm_freak> pozic: yeah, i've read that
04:57:40 <ivanm> for randomR (x,y), are values produced inclusive?
05:01:38 <BeelsebobWork> > randomR (0,1) (mkStGen 1)
05:01:39 <lambdabot> Terminated
05:01:44 <BeelsebobWork> o.O splode
05:02:23 <BeelsebobWork> > randomR (0,1) (mkStdGen 1)
05:02:24 <lambdabot>  (1,80028 40692)
05:02:33 <BeelsebobWork> there's your answer then
05:03:03 <ivanm> :(
05:03:10 <ivanm> that's ints though...
05:03:17 <ivanm> > randomR (0,1) (mkStdGen 1)
05:03:18 <lambdabot>  (1,80028 40692)
05:03:22 <ivanm> whoops...
05:03:24 <ivanm> > randomR (0,1) (mkStdGen 2)
05:03:24 <BeelsebobWork> why would it be any different for any other type?
05:03:25 <lambdabot>  (1,120042 40692)
05:03:31 <ivanm> BeelsebobWork: hope? :p
05:03:34 <BeelsebobWork> haha
05:03:42 <BeelsebobWork> you want satisfiesM
05:03:50 <BeelsebobWork> which I concocted
05:03:54 <BeelsebobWork> so you don't have
05:03:54 <BeelsebobWork> sec
05:03:55 <ivanm> lol
05:04:10 <quicksilver> the docs say it does include both endpoints.
05:04:17 <ivanm> oh, wait, just plain old random generates in [0,1), which is what I want :D
05:04:17 <quicksilver> Takes a range (lo,hi) and a random number generator g, and returns a random value uniformly distributed in the closed interval [lo,hi]
05:04:19 <BeelsebobWork> satisfiesM p x = x >>= if' p return (const (satisfiesM p x))
05:04:36 <BeelsebobWork> it's a hack
05:04:39 <BeelsebobWork> but it'll do your job
05:04:57 <BeelsebobWork> keep doing the monadic action, until the result satisfies a predicate
05:05:05 <ivanm> @src randomR
05:05:05 <lambdabot> Source not found. There are some things that I just don't know.
05:05:07 <ivanm> :(
05:05:23 * ivanm wonders why random is semi-closed, but random is closed :s
05:06:25 <idnar> what?
05:06:42 <quicksilver> the difference between [0,1] and [0,1) is a bit hard to observe, empirically.
05:06:49 <ivanm> true
05:07:01 <quicksilver> the absence of an event of probably 0 is not really something you can draw a conclusion from.
05:07:06 <quicksilver> probability.
05:07:07 <quicksilver> sorry.
05:07:52 <ivanm> but if I'm generating values in [0,x], and want to split them into n equally sized bins by using <...
05:08:12 <ivanm> hang on, I can include 0 in the first bin and use <= \o/
05:22:44 <trofi> http://book.realworldhaskell.org/beta/data.html - intro to Sequence has bunch on ghci errors. Is it ok?
05:22:45 <lambdabot> Title: Chapter 14. Data Structures
05:23:03 <trofi> @hoogle Data.Sequence
05:23:03 <lambdabot> module Data.Sequence
05:23:03 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
05:23:03 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
05:25:36 <dcoutts_> @seen gwern
05:25:37 <lambdabot> gwern is in #xmonad, #haskell and #darcs. I don't know when gwern last spoke.
05:26:04 <dcoutts_> gwern: more config file changes, see http://hackage.haskell.org/trac/hackage/ticket/223#comment:7
05:26:05 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
05:34:40 <adekoba> > let (^.^) = (+)
05:34:40 <lambdabot>  Parse error at end of input
05:34:53 <adekoba> > let (^.^) = (+); 3 ^.^ 1
05:34:53 <lambdabot>  Parse error at end of input
05:35:27 <BeelsebobWork> let (^.^) = (+) in 3 ^.^ 1
05:35:48 <adekoba> thanks. I'm trying to make faces with operators.
05:36:11 <BeelsebobWork> my favourite is angry monkey... :([])
05:36:23 <BeelsebobWork> angry monkey likes putting things in lists
05:37:19 <BeelsebobWork> :< and :> work well for data
05:37:37 <adekoba> I wish underscore was allowed
05:37:50 <BeelsebobWork> >.< >.> and <.< are nice too
05:37:56 <adekoba> > let (^_^) = (*) in 3 ^_^ 2
05:37:57 <lambdabot>  Parse error at ")" (column 9)
05:38:06 <adekoba> BeelsebobWork: yeah, those work
05:38:26 <BeelsebobWork> >:-<
05:38:37 <Wild_Cat> let (d(-.-)b) = (+) in 5 d(-.-)b 8
05:38:40 <Wild_Cat> > let (d(-.-)b) = (+) in 5 d(-.-)b 8
05:38:41 <lambdabot>  Parse error in pattern at "in" (column 21)
05:39:09 <adekoba> i don't think letters are allowed with symbols... correct me if I'm wrong
05:39:16 <BeelsebobWork> they aren't
05:39:54 <trofi> > let (^-.-^) = (+) in 8 ^-.-^ 8
05:39:55 <lambdabot>  16
05:40:08 <adekoba> what the hell is that? a koala?
05:40:12 <adekoba> haha
05:40:23 <trofi> looks like fox
05:40:29 <idnar> BeelsebobWork: (:[]) you mean?
05:40:36 <BeelsebobWork> idnar: either
05:40:45 <BeelsebobWork> the boobies combinator is a good one... (.) . (.)
05:40:58 <trofi> > let ("\@.) = (-) in 4 "\@. 4
05:40:59 <lambdabot> Unbalanced parentheses
05:40:59 <adekoba> mole
05:41:07 <trofi> > let (\@.) = (-) in 4 \@. 4
05:41:08 <lambdabot>  0
05:41:46 <BeelsebobWork> > let oYo = (++) in (oYo) "yay " "boobies"
05:41:47 <lambdabot>  "yay boobies"
05:42:11 <trofi> \@. - snail
05:42:57 <trofi> > let ('\@.) = (-) in 4 '\@. 4
05:42:57 <lambdabot> Unbalanced parentheses
05:43:18 <int-e> ^\@
05:43:27 <trofi> > let (^\@.) = (-) in 4 ^\@. 4
05:43:28 <lambdabot>  0
05:43:31 <trofi> 8)
05:43:35 <BeelsebobWork> let (:-) = (:) in (5 :-) 6 -- needs data, but you get the idea
05:44:54 <trofi> ^*.*^
05:45:09 <adekoba> bat
05:45:14 <BeelsebobWork> :)
05:45:51 <trofi> \.^./
05:48:01 <BeelsebobWork> :(><) -- omn omn omn
05:48:08 <BeelsebobWork> would make a good data constructor
05:49:55 <adekoba> ^<^
05:59:50 <zachk> are haskell regular expressions fast?
06:00:24 <Lemmih> ?faq Can Haskell do fast regular expressions?
06:00:24 <lambdabot> The answer is: Yes! Haskell can do that.
06:00:43 <zachk> ?faw can Haskell make me breakfast?
06:00:43 <lambdabot> The answer is: Yes! Haskell can do that.
06:00:50 <quicksilver> zachk: the standard ones defer to your system's regexp library.
06:01:06 <zachk> do they work on windows?
06:01:16 <quicksilver> I assume so.
06:01:18 <quicksilver> I have no idea how.
06:01:24 <quicksilver> I've never used windows.
06:01:32 <zachk> in your entire life?
06:01:46 <Lemmih> That's quite a feat.
06:02:14 <chrisdone> that's a worthy life's work
06:03:00 <quicksilver> I admit to stretching the truth. There is a windows machine to my right I use to test IE6 on.
06:03:07 <dcoutts> pah
06:03:09 <quicksilver> I've never programmed on a windows platform though.
06:03:21 <quicksilver> and I've never owned, nor pirated, a copy of the OS.
06:03:26 <dcoutts> I can't even see or touch the Windows machine I use occasionally
06:05:00 <dcoutts> when I was alive windows were things that let the wind and rain though, and we were grateful for it
06:05:11 <BeelsebobWork> quicksilver: if you'd like to remove that step for the most part, there's a really nice app called IEs4OSX which lets you run the IE engine on OS X
06:05:15 <BeelsebobWork> (darwine stuff)
06:05:29 <BeelsebobWork> it works so well that you can even run windows update on a mac
06:05:56 <jeffz> BeelsebobWork: don't you need to run the genuine advantage stuff?
06:06:07 <BeelsebobWork> jeffz: wine fakes genuine advantage nicely
06:06:24 <jeffz> BeelsebobWork: it hasn't for the past several months, microsoft changed it, they also broke it for windows 98
06:06:37 <BeelsebobWork> that's odd -- it worked about 2 weeks ago when I tried it
06:08:22 <chrisdone> yeah, I generally VNC into my dad's laptop to test with IE6
06:18:45 <trofi> @hoogle (a -> b) -> (a -> mb)
06:18:46 <lambdabot> Prelude . :: (b -> c) -> (a -> b) -> a -> c
06:18:46 <lambdabot> Data.Function . :: (b -> c) -> (a -> b) -> a -> c
06:18:46 <lambdabot> Prelude $ :: (a -> b) -> a -> b
06:18:47 <trofi> @hoogle (a -> b) -> (a -> m b)
06:18:48 <lambdabot> Prelude $ :: (a -> b) -> a -> b
06:18:48 <lambdabot> Prelude $! :: (a -> b) -> a -> b
06:18:48 <lambdabot> Data.Function $ :: (a -> b) -> a -> b
06:19:52 <trofi> @hoogle Monad m => (a -> b) -> (a -> m b)
06:19:53 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
06:19:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
06:19:53 <lambdabot> Prelude $ :: (a -> b) -> a -> b
06:20:02 <Wild_Cat> @src $!
06:20:03 <lambdabot> f $! x = x `seq` f x
06:20:19 <Wild_Cat> @src seq
06:20:19 <lambdabot> Source not found. Maybe you made a typo?
06:20:40 <quicksilver> Wild_Cat: seq is primitive.
06:20:50 <Wild_Cat> hrmm. What does it do again?
06:20:59 <quicksilver> forces the evaluation to WHNF
06:21:11 <quicksilver> of its left argument at the time the right argument gets evaluated.
06:21:15 <Wild_Cat> right, so $! is the strict version of $, correct?
06:21:17 <Saizan> does unsafeInterleaveIO break some monads laws or it simply breaks what we expect from pure values?
06:21:19 <quicksilver> right.
06:21:37 <quicksilver> although 99% of the times ($!) is used incorrectly :)
06:21:57 <quicksilver> as if it is a magic spell and sprinkling it like faerie dust will make code strict.
06:21:58 <chrisdone> quicksilver: par example?
06:22:15 <quicksilver> chrisdone: well people just sprinkle them everywhere without actually understand what gets evaluated when :)
06:22:58 <quicksilver> > const "Hi" (error $! "oops")
06:22:59 <lambdabot>  "Hi"
06:23:15 <quicksilver> the mere presence of strictness there, for example, doesn't make that error clause get evaluated.
06:23:33 <quicksilver> Saizan: No, it doesn't break the monad laws.
06:23:43 <quicksilver> Saizan: (adding new equations can never break a system of equations)
06:23:57 <quicksilver> adding new axioms can only make new things true, never invalidate old things.
06:24:02 <ToRA> > head $! ('h':error "urk")
06:24:03 <lambdabot>  'h'
06:24:17 <quicksilver> ToRA: yes, another good example I think.
06:24:25 <ToRA> lists are great :)
06:24:35 <quicksilver> Saizan: as you say, it breaks purity.
06:24:53 <quicksilver> and if you are prepared to expend a little effort constructing the example, it breaks referential transparency.
06:25:09 <trofi> :t return
06:25:10 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:25:48 <r3m0t> > const "Hi" $! (error $! "oop")
06:25:50 <lambdabot>  mueval: "*** Exception: oop
06:26:50 <ToRA> > error ('h':(error "urk"))
06:26:51 <lambdabot>  mueval: urk
06:26:59 <Saizan> quicksilver: i see, thanks
06:27:29 <mauke> > fix error
06:27:44 <ToRA> mauke: heh
06:27:45 <lambdabot>  thread killed
06:28:06 <mauke> > fix (('!' :) . error)
06:28:22 <lambdabot>  thread killed
06:35:32 <Saizan> quicksilver: i'm not really convinced in general that adding a primitive can't break the laws, couldn't e.g. the proof for m >>= return = m, make use of an exhaustive case analysis on the possibile m expressions given a fixed number of primitives and combinators?
06:36:25 <Saizan> s/number/set/
06:38:34 <Saizan> so adding a new primitive might invalidate that proof
06:39:21 <SamB_XP> Saizan: it depends on how you did the proof, I guess, and how the "primitive" is implemented
06:39:52 <quicksilver> you're taking what I said at the wrong level, I think.
06:40:02 <quicksilver> If you have a system of axioms (or equivalently laws)
06:40:14 <quicksilver> then adding new ones doesn't invalidate any existing proofs
06:40:16 <quicksilver> in that format system.
06:40:32 <quicksilver> because the proof is just a series of rule uses, and those rules are all still rules.
06:40:48 <dmead> hey guys
06:40:57 <quicksilver> IOW, such "proofs" never proceed by anything like exhaustive case analysis.
06:41:05 <dmead> is there some way to get parsec to use the strict IO package?
06:42:13 <ziman> hm, does parsec use io at all?
06:42:26 <chrisdone> I don't think so
06:42:46 <BeelsebobWork> dmead: are you looking to improve the efficiency of a parser?
06:43:04 <jrheard> Too bad someone's already taken the name Haggis for a project...  I'm porting GDAL/OGR to Haskell, and then I'll write some high level stuff to do GIS work in Haskell, but HagGIS is a perfect name for the thing...
06:43:14 <dmead> i'm looking to prevent file handle errors
06:43:28 <dmead> i'm trying to strictly load and parse files
06:43:29 <chrisdone> jrheard: damn name sitters
06:43:41 <BeelsebobWork> dmead: then you need to fix a bug in your own file loading code
06:43:44 <lilac> dmead: parsec doesn't do IO itself
06:43:46 <BeelsebobWork> parsec doesn't do file loading
06:43:51 <dmead> yea, i just realized that
06:43:52 <dmead> sorry :P
06:46:14 <dmead> wait....
06:46:19 <dmead> @hoogle parseFromFIle
06:46:19 <lambdabot> Text.ParserCombinators.Parsec.Prim parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
06:46:22 <dmead> @hoogle parseFromFile
06:46:22 <lambdabot> Text.ParserCombinators.Parsec.Prim parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
06:46:25 <dmead> yea
06:46:30 <dmead> thats the parsec IO i'm talking about
06:46:47 <dmead> @slap everybody
06:46:47 * lambdabot locks up everybody in a Monad
06:47:05 <BeelsebobWork> dmead: parse . readFile
06:47:11 <BeelsebobWork> now strictify to your hearts content
06:47:27 <dmead> oh
06:47:28 <BeelsebobWork> (note provide parse with appropriate arguments)
06:47:33 <dmead> right
06:51:25 <BeelsebobWork> (note, I in no way support the idea that strictifying things makes them efficient)
06:52:43 <dmead> i don't want to have to leave monads everywhere to take care of the file handles
06:52:52 <dmead> i have one shit IO thats not at the top level of my program
06:53:14 <BeelsebobWork> sure, it certainly sounds like the lesser evil for you
06:53:16 <dmead> so i do it with unsafeperform, and the regular lazy file io leaves the handle open
06:55:22 <quicksilver> why would you have to leave monads everywhere?
06:55:28 <quicksilver> open the file at the top level and pass the contents in
06:55:47 <BeelsebobWork> quicksilver: threading contents about all over the place isn't so neat
06:55:52 <BeelsebobWork> even if you do hide it with a monad
06:56:28 <quicksilver> perhaps not.
06:56:29 <BeelsebobWork> I have to admit, I've been known to unsafePerformIO $ readFile things -- but only when I know that's the *only* place in the program that I'll ever touch that file, and I don't care when I open it
06:56:50 <quicksilver> well, that's the unsafePerformIO side-condition
06:57:07 <BeelsebobWork> well, it's the unsafePerformIO side-condition for reading files
06:57:07 <quicksilver> "The will have the same result whenever it is executed, and I don't care if it is executed more than once or never"
06:57:36 <BeelsebobWork> oh, I see what you're saynig
06:57:37 <BeelsebobWork> yeh
07:01:44 * ejt discovers 'liftM2 (&&)'
07:02:09 * BeelsebobWork hands ejt liftA2 (&&)
07:02:23 * ejt faints
07:03:03 <kpreid> :t liftM2 (&&)
07:03:05 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
07:03:22 <ejt> :t liftA2 (&&)
07:03:23 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
07:03:34 * Lemmih draws a lambda on ejt cheek and snickers.
07:03:38 <BeelsebobWork> ejt: note, all monads *should* be Applicatives
07:03:43 <BeelsebobWork> some aren't because of teh lazy
07:04:16 <ejt> hmm, I need to rea up on Applicative again
07:08:12 <r3m0t> @info Applicative
07:08:12 <lambdabot> Applicative
07:08:24 <r3m0t> thaqnks lambdabot, I knew that already
07:08:33 <BeelsebobWork> hahaha
07:09:10 <twanvl> class Functor f => Applicative f where { pure :: a -> f a ; (<*>) :: f (a -> b) -> f a -> f b }
07:09:13 <dcoutts> Applicative ftw!
07:09:16 <BeelsebobWork> if the prelude had been designed when applicative was known about, monad would probably be derived, and require an applicative instance first
07:09:22 <BeelsebobWork> dcoutts: amen to that
07:09:53 <dcoutts> even for things that are monads, the applicative <*> can sometimes provide stronger properties
07:10:14 <dcoutts> because it allows more info to be gathered statically
07:10:39 <lilac> haskell would need a way to say, "instance Monad m deriving Functor m, Applicative m" or similar
07:11:03 <lilac> or some way to automatically deduce the definition of pure and <*> from return and >>=
07:11:20 <dmead> hmmm
07:11:30 <BeelsebobWork> lilac: you mean pure = return and <*> = ap?
07:11:52 <dmead> this is still strange behavior
07:12:02 <chrisdone> instance Applicative m => Monad m where ..
07:12:08 <dmead> if i run my parser code and grab some file contents in ghci
07:12:17 <dmead> and open/close the same file in nano
07:12:22 <dmead> and try to run my code again
07:12:26 <dmead> i get parse error
07:12:32 <BeelsebobWork> haha
07:12:32 <dmead> and i didn't change anything in nano
07:12:34 <BeelsebobWork> fun
07:12:35 <dmead> :/
07:12:48 <dmead> dons says it's from semi-open handles
07:13:01 <dmead> but i switched to strict io :/
07:13:52 <lilac> BeelsebobWork: yeah, something like that. like "class Applicative m => Monad m where { return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; pure = return; <*> = ap }", and then allow "instance Monad m" to imply an instance of Functor m.
07:14:04 <lilac> s/Functor/Applicative/
07:14:20 <BeelsebobWork> dmead: do purely functional IO... read the entire file system lazily when you start, and thread it everywhere
07:14:23 * BeelsebobWork ducks
07:14:47 <dmead> lols
07:14:48 <BeelsebobWork> lilac: yeh, but you can define Applicative without Monad
07:15:11 <lilac> BeelsebobWork: sure, "instsance Applicative a" would be unaffected
07:15:17 <BeelsebobWork> you can't define Monads without them also being Applicatives though
07:15:49 <BeelsebobWork> lilac: all it needs is the definition of the Monad class to be changed to class (Applicative m) => Monad m where...
07:15:54 <lilac> BeelsebobWork: the proposal is to allow 'class' to specify default implementation for superclasses in terms of the implementation of the subclass.
07:16:17 <BeelsebobWork> but you could just as well define pure and <*> and get Monad derived from them
07:16:59 <lilac> if that were true, Monad and Applicative would be equivalent
07:17:18 <BeelsebobWork> no, Monads would be a subclass of Applicatives
07:17:22 <BeelsebobWork> which is semantically true
07:17:31 <Toxaris> BeelsebobWork: but then you have to define fmap, pure, <*> and >>= (4 methods) instead of just return and >>= (2 methods)
07:17:57 <BeelsebobWork> Toxaris: yes -- but then you'd get all the benefits of having fmap, pure and <*>
07:18:07 <BeelsebobWork> it's specifically for that reason I want the change
07:18:22 * lilac hpastes, irc is no good for this
07:18:23 <BeelsebobWork> (because there are lots of monads I want to be able to use applicative operators on)
07:18:57 <BeelsebobWork> Gen (from QuickCheck) for example, is a monad, but not applicative (unless you use checkers)
07:19:25 <Toxaris> BeelsebobWork: but I want to define only >>= and pure, and have fmap and <*> derived
07:19:43 <BeelsebobWork> ahh, I see...
07:19:59 <Toxaris> BeelsebobWork: but for Applicatives which aren't Monads, I want to define <*> and pure by hand, and fmap derived
07:20:00 <BeelsebobWork> so yeh, what we all really want is to be able to define any 2 of 5 essentially
07:20:05 <BeelsebobWork> and magically get the others
07:20:40 <BeelsebobWork> Toxaris: tbh, the way I'd handle that is to define <*> and pure... and then be able to derive Monad iff Applicative is defined somewhere
07:21:28 <Toxaris> BeelsebobWork: but you still have to define >>= and <*>, even if <*> can be defined in terms of >>= ?
07:21:49 <BeelsebobWork> no, I'd have to define only <*> and pure
07:21:55 <BeelsebobWork> because >>= can be defined in terms of them
07:22:02 <Toxaris> not at all
07:23:12 <BeelsebobWork> I was under the impression that there was a definition of >>= in terms of the applicative operators that was valid exactly when your applicative happened to also be a monad
07:23:24 <SamB_XP> eh???
07:24:13 <Toxaris> that's new to me
07:24:24 * BeelsebobWork goes agoogling
07:24:31 <BeelsebobWork> I may have picked up the wrong end of a stick
07:24:34 <SamB_XP> is that like agog?
07:24:38 <medfly> i wanna do something stupid... like have "let something x =" and i want x to be like... a function of it sown.. or something. my vocabulary sucks.
07:24:53 <SamB_XP> BeelsebobWork: just hope it isn't actually a snake ;-)
07:24:55 <medfly> do i need to do anything special to get that?
07:24:59 <BeelsebobWork> medfly: that's not stupid
07:25:09 <SamB_XP> incidentally, which end of a snake is the correct end to pick up ?
07:25:09 <BeelsebobWork> and no, Haskell is specifically designed to not make that a special case
07:25:24 <BeelsebobWork> SamB_XP: I'm not entirely sure
07:25:27 <medfly> somehow it doesn't work right
07:25:46 <SamB_XP> hpaste it
07:25:48 <SamB_XP> @hpaste
07:25:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:26:00 <lilac> BeelsebobWork: this is what i'm suggesting: http://hpaste.org/9839
07:26:06 <Toxaris> > let foo x = x + x in foo 21 -- medfly note how foo is a function here
07:26:08 <lambdabot>  42
07:26:27 <SamB_XP> Toxaris: he wanted *x* to be a function
07:26:31 <BeelsebobWork> Toxaris: he wanted the argument to be a function
07:26:54 <BeelsebobWork> > let apply f x = f x in apply (+5) 10
07:26:55 <SamB_XP> > let twice f = f . f
07:26:55 <lambdabot>  Parse error at end of input
07:26:56 <lambdabot>  15
07:26:58 <Deewiant> > let foo f = f 1 in foo (+5)
07:27:00 <lambdabot>  6
07:27:02 <Arnar> hey there..
07:27:06 <Toxaris> > let foo x = x 21 in foo (2 *) -- ok ok
07:27:08 <lambdabot>  42
07:27:08 <SamB_XP> > let twice f = f . f in twice (*2) 3
07:27:10 <lambdabot>  12
07:27:15 <Arnar> a quick one: does catch deal with *all* exceptions, no matter the type?
07:27:22 <medfly> scary
07:27:29 <SamB_XP> Arnar: which catch?
07:27:35 <trofi> :t catch
07:27:37 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:27:49 <Arnar> Control.Exception.catch
07:27:52 <BeelsebobWork> medfly: do @src map
07:28:07 <SamB_XP> Arnar: I believe so, but ... er ... who was mucking with those?
07:28:07 <Arnar> :t Control.Exception.catch
07:28:07 <BeelsebobWork> medfly: this is exactly what makes functional programming powerful -- functions are values
07:28:08 <medfly> .. in here?
07:28:09 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
07:28:18 <BeelsebobWork> @src map
07:28:19 <lambdabot> map _ []     = []
07:28:19 <lambdabot> map f (x:xs) = f x : map f xs
07:28:33 <Arnar> hmm..
07:28:35 <BeelsebobWork> medfly: there you go -- it's the function which accepts a function, and applies it to all elements in a list
07:28:43 <medfly> something is wrong with my notation, and i don't understand w hat is, and your code creeps me.
07:28:48 <BeelsebobWork> > map (+2) [1,2,3,4,5,6]
07:28:50 <lambdabot>  [3,4,5,6,7,8]
07:29:06 <trofi> > (^2) 7
07:29:08 <lambdabot>  49
07:29:13 <trofi> > (2^) 7
07:29:15 <lambdabot>  128
07:29:23 <Arnar> SamB_XP: basically, I want to run user-provided code (I'm a library) .. catch any exception, do some sanity check (not dependent on the exception) and then maybe rethrow it or replace it with my own..
07:29:30 <lilac> BeelsebobWork: what do you think of my class-deriving proposal?
07:29:39 <BeelsebobWork> lilac: it looks interesting
07:29:43 <Toxaris> lilac: what if I want to define a superclass method myself for efficiency reasons?
07:30:21 <Arnar> SamB_XP: I'm basically wondering if there's a way to "throw" something that gets by Control.Exception.catch
07:30:41 <SamB_XP> I don't think so, but nominolo should know for sure ...
07:30:41 <quicksilver> lilac: would it be a compiletime if the superclass was in fact already defined?
07:30:52 <quicksilver> or would the defaults then be ignored?
07:31:03 <lilac> well, ideally, i'd like the derived instances to be 'weak' and overridden by explicit instances. i'm not sure if that causes issues.
07:31:13 <SamB_XP> Arnar: however, it won't catch all instances of nontermination ;-)
07:31:22 <Arnar> SamB_XP: of course.. :)
07:31:37 <Arnar> SamB_XP: nontermination in the client code is not my problem :)
07:31:37 <lilac> the other option would be to require a 'deriving Functor' in the instance as well
07:31:54 <medfly> i have to go..
07:31:59 <Arnar> since we're on the topic.. what is a good discussion of Haskell's exceptions?
07:32:01 <quicksilver> lilac: it might cause a susprising behaviour.
07:32:21 <quicksilver> lilac: suppose A defines (Functor f) and B defines (Applicative f) ... without importing A.
07:32:42 <quicksilver> lilac: now if a third module imports A, B or (both A and B), I wonder which Functor instance it gets in every case?
07:32:46 <lilac> yeah, surprising is the word :)
07:33:03 <quicksilver> and suppose C imports A, and gets that Functor instance; whilst D imports B and gets that Functor instance.
07:33:06 <lilac> perhaps requiring 'deriving whatever' in the instance as well is the best way out of this :)
07:33:15 <quicksilver> if E imports both C and D, it now has two instances in scope.
07:33:42 <Toxaris> quicksilver: how is that different from A and B defining Functor instances explicit?
07:33:49 <quicksilver> Toxaris: well, perhaps it isn't.
07:33:52 <quicksilver> (that's a compile-time error)
07:34:01 <quicksilver> and maybe that's what lilac intends for this case.
07:34:04 <quicksilver> just hilighting the issue.
07:34:23 <Toxaris> but I like "deriving Superclass" in the instance declaration
07:34:42 <Toxaris> that way, code cannot magically define instances it never mentions
07:35:11 <Toxaris> unfortunately, the additional advantage from the hpaste no longer applies then
07:36:01 <quicksilver> lilac: I like the idea, anyhow. I've seen similar notions proposed but I dodn't remember anyone proposing exactly what you have.
07:36:19 <quicksilver> lilac: have you see John Meacham's Class Alias proposal?
07:36:24 <ejt> I think <*> and pure are going to greatly improve the readability of my IO code, thx
07:36:34 <quicksilver> that appears (to me) to be the best thought-out one on this line
07:36:41 <lilac> quicksilver: no, i don't think i've seen it
07:37:29 <quicksilver> @go john meacham class alias
07:37:31 <lambdabot> No Result Found.
07:37:35 * quicksilver slaps lambdabot 
07:37:51 <quicksilver> http://repetae.net/recent/out/classalias.html
07:37:52 <lambdabot> Title: Class Alias Proposal for Haskell
07:38:12 <Toxaris> lilac: what happens if two different subclasses allow deriving of the same superclass, and I want a type to instantiate both subclasses?
07:38:28 <quicksilver> another good question.
07:38:35 <quicksilver> I think that's probably a compile time error.
07:38:41 <trofi> sounds C++ish
07:39:12 <quicksilver> no, C++-ish is to solve sudoku in the type-system and then crash with an error message longer than your actual program.
07:39:47 <jrheard> lol.  Okay, I switched to this window at exactly the right time
07:39:55 <jrheard> Thanks, quicksilver.  That was good for a chuckle
07:40:36 <SamB_XP> quicksilver: crash at compile time or at runtime?
07:40:55 <quicksilver> compile time, I meant.
07:40:58 <lilac> Toxaris: that's got to be a compile-time error.
07:41:13 <SamB_XP> Toxaris: are you talking about class aliases?
07:41:17 <lilac> quicksilver: the class alias thing seems to be a pretty comprehensive solution; i like it.
07:41:23 <quicksilver> I like it too.
07:41:28 <quicksilver> but there may be hidden problems.
07:41:35 <quicksilver> no one has actually implemented it which is the only proof.
07:41:42 <quicksilver> although SamB once claimed he would attempt it :)
07:41:43 <Toxaris> SamB_XP: kind of, we are talking about lilacs proposal here: http://hpaste.org/9839
07:41:53 <SamB_XP> I did begin
07:42:08 <SamB_XP> I got frustrated with JHC's buggy implementation of *normal* classes
07:42:30 <lilac> quicksilver: well, i've started playing with GHC's source, so i might give it a go ;-)
07:43:06 <quicksilver> SamB_XP: buggy? interesting. From JM's description it sounded rather elegant.
07:43:09 * lilac wanted to implement template arrows, with a pureT :: Exp -> a b c instead of pure, and accompanying proc notation
07:43:10 <quicksilver> but I've never looked at the code.
07:43:12 <SamB_XP> beware the inconsistant syntax that John uses in his page on the subject
07:44:15 <SamB_XP> quicksilver: the buggyness is related to the order in which the types are passed to the methods
07:44:28 <quicksilver> intresting.
07:45:22 <lilac> quicksilver: i'm not quite clear on whether the class alias thing actually solves the Functor => Applicative => Monad problem
07:46:13 <quicksilver> it (purports to)  solvessome of the objections people have to the haskell98 solution
07:46:19 <SamB_XP> lilac: it can make it easier to define instances with the proper class hierarchy in place
07:46:32 <quicksilver> which are constraints getting more complex, and lots of little isntances needing writing.
07:47:01 <lilac> presumably it'd define Monad as an alias for OldMonad and Applicative, but that breaks code which defines both a Monad and an Applicative instance
07:47:27 <SamB_XP> I'd actually leave the old names as they are and define new names for the aliases
07:47:41 <lilac> either that or define an ApplicativeMonad as an alias for Monad and Applicative, but that doesn't give quite the right semantics either
07:48:07 <twanvl> lilac: A problem with your proposal is how to specify an explicit instance of Functor for a type that is also Applicative
07:50:13 <lilac> twanvl: definitely. so far i've thought of either (a) implicit instances are 'weak' and overridden by explicit ones (with weird semantics in some cases :(), (b) you have to explicitly ask for an instance to be generated, or (c) you just can't. none of these is completely satisfactory.
07:50:36 <twanvl> My idea was that you would specify both classes in the instance declaration:  instance (Functor f, Applicative f) where ...
07:50:50 <twanvl> see also http://haskell.org/haskellwiki/Superclass_defaults
07:50:56 <lambdabot> Title: Superclass defaults - HaskellWiki
07:53:31 <lilac> twanvl: looks a lot like my proposal with option b. but it lacks source-compatibility when new superclasses are added.
07:58:09 <lilac> quicksilver: i think the 'weak' instance thing works if there're no orphan instances.
07:59:52 <lilac> ... actually, there're probably still problems with overlaps between implicit and explicit instances.
08:01:42 <quicksilver> Yes, that's the problem.
08:01:56 <quicksilver> the current setup assumes you either have an instance or you don't.
08:02:04 <quicksilver> If you don't have one, error. If you have two in scope, error.
08:02:10 <quicksilver> if you have one in scope, that's fine.
08:02:25 <quicksilver> This has the appropriate monotonic property in terms of modules importing other modules.
08:05:59 <lilac> quicksilver: if there are no orphan instances, and there is both an implicit and an explicit instance, then if you can see the implicit instance you can also see the explicit one.
08:06:28 <twanvl> I don't think implicit instances are a good idea, too many things can go wrong, especially across module boundaries
08:06:51 <lilac> the tricky thing i think is if you define "instance Monad (A b) where ..." and also "instance Applicative (A Int) where ..."
08:07:09 <quicksilver> lilac: but if one module can't see the explicit one, it's compiled using the implicit one.
08:07:17 <quicksilver> lilac: then, a second module which *can* see the explicit one
08:07:18 <lilac> twanvl: without implicit instances, you can't add superclasses in a source-compatible fashion.
08:07:25 <explicitjelly> SYB is great.
08:07:27 <quicksilver> becomes incompatible with the other one.
08:07:33 <explicitjelly> especially when writing a compiler
08:07:39 <twanvl> lilac: your proposal is not fully source-compatible either
08:07:57 <lilac> quicksilver: sure, but that can only happen with orphan instances, so i don't think it's *that* big a deal.
08:08:18 <explicitjelly> (okay, I know, everything is a compiler. more specific: when writing a compiler which translates a multipurpose higher language into a low level language, possibly through several intermediate languages)
08:08:20 <lilac> twanvl: no, but i want to get as close as i reasonably can
08:08:51 <explicitjelly> you're gonna do a lot of transformations and queries on the code trees, for translation and optimizations
08:08:54 <twanvl> I think you can also get source compatability with class aliases
08:09:00 <explicitjelly> most of them benefit a lot from SYB
08:11:09 <twanvl> And the Functor/Applicative/Monad problem is not about factoring out new super classes, it is about discovering that two existing things are releated.
08:11:48 <Philippa> really that's just the Functor/Monad problem, isn't it?
08:12:16 <lilac> twanvl: you can't get source compat when adding a superclass of Applicative to Monad with class aliases, AIUI. you either break code which defines an Applicative instance alongside the Monad instance, or break code which doesn't.
08:14:15 <BONUS> is there a function like elem in the standard library that requires Ord a and uses bisection?
08:14:26 <BONUS> e.g. runs on log n
08:14:31 <twanvl> BONUS: you can't bisect lists
08:14:47 <twanvl> BONUS: But you can use Data.Map instead of a list
08:14:50 <twanvl> or Data.SEt
08:14:59 <BONUS> ah, right
08:15:01 <BONUS> of course
08:15:03 <r3m0t> BONUS: or Data.IntMap or Data.IntSet
08:15:05 <explicitjelly> twanvl, hmm. isn't it that you can bisect finite lists, but it's not very feasible to do it?
08:15:11 <BONUS> how much does it cost to put a list into a set though
08:15:17 <BONUS> is it n log n
08:15:36 <twanvl> explicitjelly: yes, you actually can bisect them, just not in log n
08:15:46 <explicitjelly> twanvl, that's what I meant... thanks
08:15:50 <quicksilver> BONUS: yes
08:15:59 <quicksilver> BONUS: (it would be a pretty useless structure if it was anythign else :P)
08:16:01 <twanvl> BONUS: Data.Set.fromList = O(n log n),  Data.Set.fromAscList = O(n)
08:16:04 <explicitjelly> wasn't sure if my definition of "bisecting a list" was right.
08:16:08 <BONUS> hehe
08:16:19 <lilac> quicksilver: it would be a very useful structure if it were O(1) ;-)
08:16:28 <BONUS> but like, let's say you have an ordered list of Ord a elements
08:16:35 <quicksilver> fromAscList is O(n)
08:16:40 <lilac> quicksilver: but yes, that's O(n log n) so...
08:16:40 <quicksilver> if you've already got it sorted.
08:16:41 <BONUS> is there a way to find an element in just log n
08:16:52 <quicksilver> No.
08:16:54 <BONUS> ah
08:16:57 <quicksilver> you have to move it into a better structure first.
08:17:03 <quicksilver> which is at least O(n) to move it.
08:17:06 <BONUS> that's what i thought, yeah
08:17:06 <Toxaris> you can do binary search in a list with O(log n) calls of compare :)
08:17:21 <twanvl> it would probably be better if you switch to using Sets instead of sorted lists everywhere
08:17:29 <r3m0t> quicksilver: but did it ever need to be in a list in the first place? ;-)
08:17:35 <quicksilver> r3m0t: well, that's a good question.
08:17:43 <lilac> how does binary search on an Array compare to lookup in a Map?
08:17:59 <quicksilver> you can do somethign really clever with a lazy algorithm to put a sorted list *lazily* into a heap
08:18:08 <quicksilver> so you don't need to access more elements than you need.
08:18:13 <quicksilver> but that's probably more than you want.
08:20:00 <twanvl> lilac: yes, code will break if Applicative becomes a superclass of Monad, but mostly library code that is trivial to fix. Other superclass extraction like splitting up Num can probably be done without breaking existing code.
08:21:51 <chrisdone> twanvl: there is the problem again if yet more abstractions are dreamed up of which monad happens to be a subclass
08:24:00 <twanvl> chirsdone: the only *big* problem is that both Applicative and Monad already exist. Using class aliasses, if we later decide to add a PointedFunctor superclass to Applicative, we can define alias Applicative f = (PointedFunctor f, ApplicativeLike f), and no code will break.
08:30:58 <lilac> twanvl: you're right. the only problem is that some people have already defined Applicative instances for their Monads.
08:32:21 <twanvl> lilac: adding Applicative instances for all Monad instances is not that big of a problem
08:33:22 <lilac> ideally, if one library contains class A and another library contains class B, it should be possible for a third party to set up some semi-automatic derivation of B from A, say
08:34:12 <lilac> perhaps that's orthogonal functionality
08:35:02 <twanvl> lilac: that is exactly what class aliasses give you
08:35:30 <Peaker> are class aliases adapters between classes?
08:35:49 <SamB_XP> actually, that's not EXACTLY what class aliases give you ...
08:36:13 <lilac> Peaker: http://repetae.net/recent/out/classalias.html
08:36:14 <lambdabot> Title: Class Alias Proposal for Haskell
08:36:50 <SamB_XP> they let the third library to provide a set of default methods for creating instances of both classes at once
08:37:05 <twanvl> it is important all this is explicit, since it must still be possible to define both instances separately
08:37:16 <lilac> SamB_XP: the third party won't be defining all A instances, so that doesn't work in general.
08:37:56 <SamB_XP> lilac: it doesn't need to work in general
08:39:30 <lilac> SamB_XP: sorry, that comment was directed at twanvl re "that is exactly what class aliasses give you"
08:40:33 <lilac> well, there seems to be a fair amount of interest in this, at least... hopefully something will happen for Haskell'
08:40:52 <twanvl> lilac: it does give a *semi* automatic derivation, all that is left to do is for somone to invoke it with an instance declaration
08:41:51 <quicksilver> lilac: nothing will happen unless someone writes an implementation.
08:42:10 <quicksilver> haskell' is only intended to standardise things which are already in practice and working.
08:42:32 <dmead> > max [1..3]
08:42:34 <lambdabot>      Overlapping instances for Show ([t] -> [t])
08:42:34 <lambdabot>       arising from a use of ...
08:42:53 <dmead> :t max
08:42:54 <lambdabot> forall a. (Ord a) => a -> a -> a
08:42:55 <dmead> ?src max
08:42:55 <lambdabot> max x y = if x <= y then y else x
08:43:11 <dmead> :? many
08:43:16 <dmead> ?src many
08:43:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:43:21 <dmead> :t many
08:43:22 <lambdabot>     Ambiguous occurrence `many'
08:43:22 <lambdabot>     It could refer to either `Control.Applicative.many', imported from Control.Applicative
08:43:22 <lambdabot>                           or `Text.ParserCombinators.Parsec.many', imported from Text.ParserCombinators.Parsec
08:43:35 <twanvl> > maximum [1..3]
08:43:36 <dmead> :t Control.Applicative.many
08:43:38 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
08:43:38 <lambdabot>  3
08:43:41 <dmead> ah
08:44:07 <quicksilver> that's an interesting combinator.
08:44:29 <dmead> many max [1..3]
08:44:36 <dmead> > many max [1..3]
08:44:37 <int-e> does it have any use besides applicative parsers?
08:44:38 <lambdabot>      Overlapping instances for Show ([t] -> [t])
08:44:38 <lambdabot>       arising from a use of ...
08:44:43 <twanvl> many is also quite useless outside parser combinator land
08:44:51 <gwern> @seen dcoutts
08:44:51 <preflex>  gwern: you have 2 new messages. '/msg preflex messages' to read them.
08:44:51 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts speak 1h 34m 37s ago.
08:44:54 <gwern> @seen dcoutts_
08:44:54 <lambdabot> dcoutts_ is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts_ speak 2h 55m 59s ago.
08:45:10 <dcoutts> hia gwern
08:45:17 <dmead> > many max [1..3] [9..14]
08:45:19 <lambdabot>  Couldn't match expected type `[t1] -> t'
08:45:35 <gwern> dcoutts: so, I've been rewriting my cabal config
08:45:40 <dmead> > maximum [1..30]
08:45:42 <lambdabot>  30
08:45:44 <dmead> alrighty
08:45:49 <gwern> dcoutts: is there something I need to do for haddock builds besides 'documentation: True'?
08:45:57 <dcoutts> gwern: that should be enough
08:46:11 <dcoutts> gwern: I take it it's not working ?
08:46:29 <dcoutts> probably some bit of missing plumbing
08:46:39 <gwern> dcoutts: well, I'm installing libraries and I'm not seeing nay haddocks
08:46:45 <gwern> I'll hpaste an example session
08:47:03 <dcoutts> gwern: s'ok, I believe you, I'll test it
08:47:16 <gwern> http://hpaste.org/9844
08:48:08 * gwern was a little surprised to see split-objs turned off by default
08:48:24 <gwern> dcoutts: notice that it finishes compiling the profiled lib and linking, and then it immediately installs
08:48:56 <dcoutts> gwern: split-objs is slow and not necessary for most small packages
08:49:03 <dcoutts> and it borks on too many arches
08:53:25 <gwern> @messages
08:53:25 <lambdabot> You don't have any new messages.
08:53:36 <gwern> hm
08:53:39 <gwern> preflex: messages
08:53:39 <preflex>  mmorrow said 13 hours, 58 minutes and 43 seconds ago: i extended and integrated checkNames http://code.haskell.org/~morrow/code/haskell/misc/mueval-checkNames.diff
08:53:39 <preflex>  mmorrow said 13 hours, 57 minutes and 32 seconds ago: also, your tests.sh which prevents darcs recording doesn't succeed even on an unmodified mueval repo
08:53:51 <lambdabot> http://tinyurl.com/6jsaqt
08:54:50 <dmead> @hoogle io map
08:54:50 <lambdabot> Control.Exception mapException :: (Exception -> Exception) -> a -> a
08:54:55 <dmead> @hoogle mapio
08:54:55 <lambdabot> No results found
08:55:05 <dmead> guys whats map with io?
08:55:15 * gwern thinks mmorrow ought to start using darcs send
08:55:16 <gwern> mapM?
08:55:23 <dmead> ?t mapM
08:55:24 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:55:28 <dmead> :t mapM
08:55:30 <dmead> ah yes
08:55:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:55:33 <gwern> @hoogle mapM
08:55:34 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:55:34 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:55:34 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:56:18 <dmead> kool
08:56:20 <dmead> brb
08:59:33 <jrheard> does anyone here know the Language.C.Syntax.AST package fairly well?
09:00:15 <jrheard> Doing FFI by hand from a C Header is a pain, but the solutions out there for automatic translation just don't satisfy me
09:00:55 <quicksilver> jrheard: only the author, I suspect :)
09:02:02 <gwern> @tell mmorrow just saying tests.sh doesn't work doesn't help me much. is it because no mueval is guranteeed to be installed? should I switch it to build.sh?
09:02:02 <lambdabot> Consider it noted.
09:02:06 <jrheard> That was my fear.  It seems like the perfect package to generate Haskell code in Haskell from C, but when it finds an include file it pastes it in (gee, who'd have thunk?) meaning my AST is polluted by all kinds of cruft
09:02:20 <jrheard> like stdio and such
09:02:46 <quicksilver> but if it doesn't, it can't parse the rest.
09:02:54 <quicksilver> because you can't parse C without seeing typedefs.
09:02:56 <quicksilver> not reliably, anyway.
09:03:03 <jrheard> oh, I know that.  Actually, I want that.
09:03:10 <quicksilver> I'm sure you do know it :)
09:03:12 <jrheard> What I want, though, is to know which file something was declared in
09:03:25 <quicksilver> that seems like a very natural thing to want to know.
09:03:45 <jrheard> So that I can filter out whether I generate an FFI call based on whether or not the function was declared in a file I'm interested in
09:03:46 <gwern> dcoutts: any idea about the haddocks?
09:04:04 <dcoutts> gwern: probably some missing plumbing between the config and its use
09:04:20 <dcoutts> gwern: check that install --enable-documentation works
09:05:53 <mmorrow> gwern: hey, i wasn't exactly clear on the why in a few cases. the script just stops with no error msg. it may be hint dying badly/silently. one i had to increase the time out by a second, .... all in all misc things here and there
09:05:53 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
09:06:17 <gwern> just stops?
09:06:27 <mmorrow> gwern: yeah, weird
09:06:40 <gwern> I've somtimes noticed that on the first invocation, loading everything frmo cache eats up enough time that it fails
09:06:45 <mmorrow> remember that mine is the system that the resources break mysteriously though ...
09:06:46 <gwern> is that it?
09:07:14 <gwern> oh. but wait, I disabled resources by default, and tests.sh doesn't add that option
09:07:18 <gwern> build.sh does, tho
09:07:19 <mmorrow> the unicode one caught me, and i had to fix some of my stuff to hand utf8 :)
09:07:41 <gwern> heh. the tests work!
09:07:45 <mmorrow> but running utf8 through the thing also results in a silent death
09:07:53 * gwern has faith in the tests and the tests work
09:07:54 <twanvl> jrheard: as I understand it, a CDecl contains a NodeInfo, which contains a Position (posOf), which contains the source filename
09:08:00 <mmorrow> either on my modified mueval, or a fresh one from darcs
09:08:16 <jrheard> Found it.  just now as you were typing that, twanvl.  Thanks!  That's exactly what I need
09:09:02 <gwern> mmorrow: which test, specifcally? they all have -i so it should print out the expression first and then eval
09:09:14 <mmorrow> gwern: i'll run it real quick
09:14:37 <explicitjelly> another haskell observation: writing code in common imperative languages is also possible when you're really tired. only, it may turn out less than optimal or potentially catastrophic. in Haskell, your compiler won't accept that.
09:15:42 <gwern> mmorrow: also, why don't you use darcs send?
09:16:03 <mmorrow> http://hpaste.org/9845
09:16:20 <mmorrow> gwern: heh, tests.sh wouldn't let me record ...
09:16:41 <mmorrow> so i wanted to make sure my stuff wasn't actually broken first ;)
09:16:44 <gwern> you didn't use darcs send even before I set tests.sh as the record test
09:16:57 <mmorrow> yeah, then i didn't plan on getting sucked in
09:17:39 <mmorrow> but i'll darcs send from now on
09:17:56 <gwern> mmorrow: try manually mueval -e 'let fix f = let x = f x in x in fix show'
09:17:58 <mmorrow> oh, here  http://hpaste.org/9845
09:18:16 <mmorrow> that works perfectly
09:18:47 <gwern> so mueval fails on mueval -e 'fix show'?
09:19:15 <mmorrow> no, it work on that
09:19:30 <mmorrow> oh, it got chopped, hold on
09:19:41 <gwern> so then why would the last one be fix show?
09:20:13 <mmorrow> http://hpaste.org/9845#a2
09:20:22 <mmorrow> hpaste cut the paste short
09:20:37 <gwern> dcoutts: manually adding that option does indeed build haddocks
09:21:01 <gwern> & install
09:21:04 <dcoutts> gwern: aye, I've found the bit where the information pipes were not connected
09:21:44 <gwern> mmorrow: so, the last thing evaled is '(+1) <$> [1..3]
09:21:47 <gwern> '? srsly/
09:21:49 <Saizan> gwern: why in ShowFun is reasonable to have IO's show call error? it's not like you're trying to execute the IO action if you're showing it
09:22:14 <Saizan> moreso it's ugly
09:22:16 <gwern> Saizan: the exit code, iirc
09:22:23 <Saizan> > return () :: IO ()
09:22:25 <lambdabot>  mueval: *** Exception: "<IO ()>"
09:22:54 <Saizan> why shouldn't that be <IO ()> like in the old days?
09:23:14 <dcoutts> gwern: for cabal configure, would you expect that to get default values from the config file, or just for the install command ?
09:23:39 <dcoutts> gwern: eg enabling profiling, optimisation, install paths etc etc
09:23:54 <gwern> dcoutts: I would, a priori, expect the former. it is named ~/.cabal, not ~/.cabal-install, after all
09:24:04 <gwern> although I could certainly understand it not doing so
09:24:05 * dcoutts notes that nobody has mentioned it thus far
09:24:33 <dcoutts> gwern: thing is, one often wants different flags for configure since you do that for development rather than deployment
09:24:36 <eu-prleu-peupeu> hello people from planet haskell
09:24:36 <mmorrow> Saizan: i agree. i mean, you're already getting the "<IO ...>" show in the error msg, why not just print it and exit cleanly??
09:24:41 <gwern> dcoutts: oh, I've long pondered and wanted it (to simplofy my shell scripts), but I decided that other things were more important
09:25:08 <dcoutts> gwern: perhaps you can file a ticket so people can have their say
09:25:13 <gwern> dcoutts: right, but I figured the only time I need to override my config is when I need to disable profiling
09:25:26 <dcoutts> gwern: it's not difficult to do, it's just a question of what the right thing to do is
09:25:26 <gwern> which would be doable if there were --no flags
09:25:26 <Saizan> mmorrow: totally agree, but gwern is of the opinion that mueval must exit with failure wherever it sees IO, it seems
09:25:30 <gwern> (are there?)
09:25:49 <dcoutts> gwern: sorry, are there what?
09:26:28 <gwern> dcoutts: well, I turn on lib/executable profiling in config, right? but sometimes I need to disable profiling ie when something simply can't be built with profiling (yi, mueval, etc.)
09:26:57 <gwern> so I would want 'runhaskell Setup configure' to take parameters from ~/.cabal/config only if I could override them on the cli
09:27:24 <dcoutts> gwern: runhaskell Setup will never look in ~/.cabal
09:27:36 <dcoutts> gwern: but cabal configure could, if we wanted it to
09:27:37 <gwern> alias normal-install='runhaskell Setup configure && build && install'; alias nonnormal-install='runhaskell Setup configure --noprofile && build && install'
09:27:40 <gwern> if you follow
09:28:00 <gwern> ...wasn't that what we were discussing?
09:28:01 <dcoutts> gwern: it'd still be possible to override from the command line
09:28:15 <dcoutts> gwern: eg cabal configure --disable-library-profiling
09:28:25 <dcoutts> even if you had set the default to on in the config file
09:28:37 <gwern> mmorrow: figure out which test makes mueval blow chunks once you got unicode fixed?
09:29:07 <gwern> dcoutts: yeah, ok. that addresses my main issue with configure also taking parameters from the config file
09:29:46 <gwern> Saizan: is your issue with the idea of exiting with 1 on IO actions, or do you simply find the textual output unpleasant?
09:29:50 <gwern> if the latter, it might be fixable
09:30:07 <mmorrow> gwern: i already have unicode fixed :)
09:30:10 * Twey grumbles.
09:30:14 <Twey> Is h.o down again?
09:30:52 <Stinger_> Twey, seems really slow for me
09:31:03 * dcoutts ssh's into h.o
09:31:04 <Twey> >.<
09:31:05 <Saizan> gwern: both, but i mostly care about the second
09:31:12 <dons_> hmm.
09:31:19 <mmorrow> in fact, as of last night it didn't come back from hint with a result in either my modded mueval or the darcs mueval, and the darcs mueval printed it mangled
09:31:23 <dcoutts> dons: I'm on it
09:31:27 <dons> go dcoutts
09:31:31 <Twey> Hehe
09:31:31 <FunctorSalad> "Could not deduce (MyClass ...) from the context ..." <-- does this always mean that it could not find *any* instance, or can it also mean that it found more than one?
09:31:34 <Twey> dcoutts to the rescue!
09:31:47 <Stinger_> activate admin powers
09:31:54 <gwern> Saizan: mm. perhaps the show could instead call something like error, minus the prefix
09:32:06 <gwern> is 'error' special in how it kills the program?
09:32:36 <Saizan> gwern: the prefix is added by forceString, but the problem is that we don't know if the exception is thrown by IO's show or not
09:32:38 <Twey> Lovely, dcoutts :)
09:32:47 <ddarius> @src error
09:32:47 <lambdabot> error s = throw (ErrorCall s)
09:32:52 <mmorrow> gwern: again, i think this has to do with whatever is causing certainb resource limits to be broken, so i'm not how indicative it is that something fails on my machine
09:33:30 <gwern> mmorrow: well, as I said - darcs mueval no longer calls the rlimits code. you could, I suppose, try commenting it out entirely
09:33:38 <Saizan> also:
09:33:42 <BeelsebobWork_> best... type... sig... ever! http://hpaste.org/9846
09:33:43 <mmorrow> i'll mess with it
09:33:46 <Saizan> > return :: () -> IO ()
09:33:47 <gwern> but I don't hold out hopes of that doing anything - if the code never runs, why would it be a problem?
09:33:47 <lambdabot>      Overlapping instances for Show (() -> IO ())
09:33:47 <lambdabot>       arising from a use of...
09:34:23 <dcoutts> fixed
09:34:57 <dcoutts> some ip from .au was downloading a windows ghc.exe ~50 times simultaneously
09:35:03 <dons> hmm
09:35:10 <gwern> BeelsebobWork_: holy cow, what is that?
09:35:36 <dcoutts> it's the same old Achilles heal in apache
09:35:50 * Twey nods :-\
09:35:52 <BeelsebobWork_> gwern: it's for checking that the arrow laws hold for your new 'arrow'
09:35:58 <FunctorSalad> for context, I have a "class Foo a b c where foo :: b -> c". Now I have: "instance (Foo a b c) => (AdvancedFoo a b c) where afoo x = foo x". now I get an error "Could not deduce an instance (Foo a2 b c) ... arising from the use of foo"
09:36:03 <gwern> lol. someone messed up
09:36:17 <quicksilver> FunctorSalad: scopes on instances don't mean what you want them to.
09:36:26 <quicksilver> if I can take a simpler example.
09:36:31 <dcoutts> dons: we need to get h.o upgraded, it's really annoyingly ancient
09:36:39 <quicksilver> instance (Group m) => Monoid m
09:36:45 <quicksilver> does not mean "all groups are monoids"
09:36:50 <BeelsebobWork_> gwern: if you can think of a better way of doing it, please tell me
09:36:52 <quicksilver> it means "EVERYTHING is a Monoid"
09:36:56 <quicksilver> ...but add a Group constraint.
09:36:58 <dcoutts> dons: but since it's a shared machine with lots of users and cruft it's not easy to do
09:37:10 <gwern> BeelsebobWork_: hm. could that be used to check whether the monad laws are satisfied?
09:37:27 <FunctorSalad> quicksilver: hmm, thanks
09:37:49 <ddarius> gwern: Just use the Kleisli arrow.
09:38:04 <gwern> BeelsebobWork_: no, just curious. I was wondering if it'd be userful for checkers
09:38:17 <BeelsebobWork_> gwern: this *is* checkers
09:38:20 <BeelsebobWork_> I'm working on it atm
09:38:22 <Saizan> FunctorSalad: methods must mention all the type parameter of the class, so foo :: b -> c is not usable
09:38:28 <BeelsebobWork_> and monad is already in there gwern
09:38:39 <BeelsebobWork_> it's type sig isn't anywhere near as awesome
09:38:40 <FunctorSalad> Saizan: it is, with one of the flags
09:39:00 <dons> dcoutts: hmm... and we need mirrors
09:39:09 <BeelsebobWork_> monad :: forall m a b c. ( Monad m , Show a, Arbitrary a, Arbitrary b , Arbitrary (m a), EqProp (m a), Show (m a) , Arbitrary (m b), EqProp (m b) , Arbitrary (m c), EqProp (m c)) => m (a,b,c) -> TestBatch
09:39:12 <gwern> :) nm then
09:39:12 <FunctorSalad> in fact, if I add a fundep like b -> c then it works
09:39:16 <dons> dcoutts: would these lock ups go away with better hardware, newer servers?
09:39:16 <BeelsebobWork_> gwern: see... no where near as good gwern
09:39:17 <BeelsebobWork_> >.<
09:39:26 <Saizan> FunctorSalad: you've to add a fundep though, like Foo a b c | b c -> a where, if not there's no way to determine which instance it should be using
09:39:28 <dcoutts> dons: no, newer software configuration
09:39:45 <BeelsebobWork_> gwern: worst thing is, that I expect the arrow one to get worse as I add more laws to check
09:39:52 <FunctorSalad> what I want is to tell it "just use an arbitrary Foo a b c for any a you can find"
09:40:06 <dcoutts> dons: with the same config it'd kill any single machine or even cluster. With a sane config the single box can handle loads of bandwidth
09:40:23 <gwern> ouch
09:40:55 <dcoutts> dons: a single happs instance can handle 1000 concurrent connections without a sweat, our apache config falls over at 50 (exactly 50)
09:40:56 <BeelsebobWork_> gwern: I've written checks of 5 of the 9 laws
09:41:10 <Saizan> FunctorSalad: that's not possibile, at best you can add an 'a' phantom parameter to foo
09:41:37 <ddarius> BeelsebobWork_: Some of the laws are not necessary and others should be split out.
09:41:37 <gwern> cool. since monads are special cases of arrows, does that mean they will easily fall out?
09:41:52 <dons> dcoutts: hmm.
09:42:20 <BeelsebobWork_> gwern: not really, because not all monads are arrows
09:42:27 <BeelsebobWork_> or rather...
09:42:31 <BeelsebobWork_> not all monads are defined as arrows
09:42:44 <dcoutts> dons: more recent apache versions can prevent a single ip from making more than N connections at once. That'd fix it.
09:42:54 <ddarius> BeelsebobWork_: Kleisli m is an Arrow for any Monad m
09:43:06 <BeelsebobWork_> hmm, good point
09:43:10 <FunctorSalad> Saizan: yeah. that looks like a "I'm doing it wrong" hint to me though ;)
09:43:11 <gwern> gah, I thought they were
09:43:20 <BeelsebobWork_> so is monad equal to arrow . Kleisli
09:43:28 * gwern thought it went monads < monoids < arrows < functors
09:43:46 <ddarius> gwern: Monoids are a totally different list
09:43:50 <dcoutts> dons: typical traffic is ~10 connections at once, except during reddit storms, and even then. No the problem is only with the flaw that a single user can tie up all the download slots.
09:44:02 <ddarius> And arguably so are Arrows.
09:44:14 <BeelsebobWork_> monoids are already done
09:44:19 * gwern sighs. one day I will know this theoretical stuff
09:44:23 <BeelsebobWork_> as are functors and applicatives
09:44:43 <BeelsebobWork_> it's already proving useful -- we've managed to show that Event in Reactive is not a Monad
09:44:46 <ddarius> BeelsebobWork_: I think if you check associativity and identity of the arrow composition for Kleisli arrows you will have proven the monad laws.
09:45:18 <BeelsebobWork_> well yes, those are the monad laws
09:46:02 <tusho> Configuring language-c-0.3.1...
09:46:03 <tusho> Setup.hs: happy is required but it could not be found.
09:46:05 <tusho> but I does has happy!
09:46:22 <BeelsebobWork_> ghc-pkg list tells you you do?
09:46:53 <dcoutts> tusho: is it on your $PATH ?
09:46:54 <ddarius> BeelsebobWork_: You may have to prove functoriality as well given only those (but that would be covered by checking the functoriality of arr)
09:47:12 <tusho> BeelsebobWork_: Hm. No.
09:47:13 <tusho> :\
09:47:16 <tusho> But I cabal install'd it...
09:47:18 <BONUS> there's no way to call functions with ' in them as infix, right?
09:47:33 <ddarius> ' isn't `
09:47:34 <dcoutts> tusho: you probably do not have ~/.cabal/bin on your $PATH
09:47:36 <BONUS> > let elem' = elem in 4 `elem'` [1,2,3,4,5]
09:47:38 <lambdabot>  True
09:47:40 <BONUS> hmm
09:47:41 <BONUS> strange
09:47:44 <BONUS> my ghci complains when i do that
09:47:47 <BeelsebobWork_> ddarius: yeh, I'm working on checking that arr behaves well atm, but it spat out a big type error, and it's pretty damn hard to sort them out atm
09:47:58 <dcoutts> tusho: we're hoping to make that behaviour a bit better
09:48:16 <tusho> dcoutts: Okay
09:48:57 <BONUS> http://hpaste.org/9848
09:49:22 <ddarius> BONUS: That has nothing to do with the ``s
09:49:32 <ddarius> That is simply the monomorphism restriction.
09:49:37 <BONUS> oh!!!!
09:49:44 <BONUS> damn MR
09:50:06 <quicksilver> together with extended defaulting
09:50:10 <quicksilver> (causing the default to ())
09:50:26 <quicksilver> my ghci defaults that to Int
09:50:28 <quicksilver> and it works ;)
09:50:33 <BONUS> hmm
09:50:39 <BONUS> where is extended defaulting set/used/what is it
09:51:00 <cpfr> hey where can i get some haskell-themed wallpaper
09:51:05 <BONUS> lol
09:51:31 <quicksilver> I think it's a 6.6/6.8 differnce, BONUS
09:51:40 <quicksilver> I'm using 6.6 which didn't have () in the default list.
09:51:46 <BONUS> ah
09:52:57 <ddarius> It seems wrong.  The H98 default should be Integer.  If it's a case that can be defaulted by H98 rules it should follow H98.
09:54:33 <BONUS> hmm, where is this defaulting business specified in the report
09:54:57 <ddarius> @google site:haskell.org inurl:onlinereport defaulting
09:54:59 <lambdabot> http://www.haskell.org/onlinereport/decls.html
09:55:00 <lambdabot> Title: The Haskell 98 Report: Declarations
09:55:16 <BONUS> thanks!!!
09:55:48 <ddarius> 4.3.4
09:55:48 <quicksilver> ddarius: I'm a bit surprised, yes.
09:56:05 <quicksilver> the 'extended' aprt in GHC is at:
09:56:06 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
09:56:08 <lambdabot> Title: 3.4.�Interactive evaluation at the prompt, http://tinyurl.com/6j5p63
09:56:13 <Twey> cpfr: Take some code, colour it green on black
09:56:19 <Twey> Apply cool fonts and text transformations :)
09:56:37 <FunctorSalad> quicksilver: hmm I guess the class hierarchy should contain all these things then? (class (Monoid m) => (Group m))
09:56:41 <Twey> Fade out a section and stick a colourised logo in there
09:56:49 <Twey> Or just a lowercase lambda
09:57:30 <ddarius> Hmm.  Since I run xmonad with 0 width borders and always fullscreen, I could set the background to be a screen shot of a Windows desktop.
09:57:40 <quicksilver> FunctorSalad: Yes. Superclasses are "better" than constraints in instance declarations.
09:57:49 <Twey> Haha, ddarius
09:57:51 <Twey> Sneaky
09:57:54 <quicksilver> FunctorSalad: because they reduce contexts and force every instance to obey.
09:58:21 <cpfr> Twey: thats a bit more work than I'd like
09:58:46 <Twey> Fine, I'll do it for you
09:58:54 <Twey> Hey guys!  Who's got some really cool-looking code?
09:59:10 <cpfr> Twey: you dont have to!
09:59:20 <Twey> Oh, I could use one of the wackier factorial functions from Evolution of a Haskell Programmer
09:59:35 <cpfr> though i figure anything from comonad reader
10:00:21 <Twey> My Inkscape's borked :(
10:00:32 * Twey reluctantly fires up the GIMP.
10:05:15 <FunctorSalad> paste some code, apply random effect, repeat ;)
10:07:31 <BONUS> i drew this today for a thing im doing http://www.vulomedia.com/images/30016maxs.png
10:07:32 <BONUS> :]
10:08:47 <FunctorSalad> quicksilver Saizan : hmm, turns out the typechecker is smarter than I am. the error corresponded to the real-life problem that for the "domain" function of a type that implements my Morphism class, you have to say "domain in which category?"
10:09:06 <FunctorSalad> (a type can be a Morphism in more than one category in my file)
10:09:07 <mmorrow> BONUS: rad
10:10:14 <BMeph> ddarius: Thanks, ddarius! That gave me the great idea of putting up an Ubuntu screenshot on the Windows machine here at work! :)
10:11:19 <BMeph> cpfr: Check out some HAppS code... ;)
10:22:58 <cpfr> ok
10:25:30 <Twey> cpfr: How's http://i34.tinypic.com/iqhesj.jpg do you?
10:25:39 <Twey> Sorry it's not great, I'm a little lost without my Inkscape :(
10:26:27 <cpfr> Twey: it looks great
10:26:33 <mercury^> Twey: use png for anything but photographs :>
10:26:46 <Twey> mercury^: It's 1600x1200, hell if I'm using PNG :-P
10:26:58 <mercury^> PNG has different compression levels
10:27:13 <Twey> Hang on, let me see what it comes out to
10:27:14 <dmhouse> Twey: it's mostly black, PNG will be very efficient.
10:28:04 <Twey> Huh, you're right
10:28:10 <Twey> Moreso than the JPEG
10:28:28 <dmhouse> Twey: also, there aren't actually any monads in that ;)
10:28:43 <Twey> http://i38.tinypic.com/2ih2f40.jpg -- brighter
10:28:53 <Twey> dmhouse: Did I say there were?  :-P
10:29:33 <Twey> It has 'generalised catamorphisms, zygomorphisms and paramorphisms'
10:29:35 <Twey> It'll do me :-P
10:29:46 * Twey has no idea what any of those are, except the first.
10:30:28 <dmhouse> ?go bananas lenses paper
10:30:31 <lambdabot> http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps
10:30:44 <cpfr> lenses paper doesnt cover zygo
10:30:59 <cpfr> i think a better caption is: "Category theory bitches!"
10:31:33 * Twey chuckles.
10:33:16 <Twey> Oh dear
10:33:32 <Twey> Poor Maarten Fokkinga :-\  Must be hard dealing with English-speakers...
10:37:31 <gavin0> i hate stupid managers!!!
10:46:38 <BMeph> Yes! "Category Theory: It works, Bitches!" :)
10:47:18 <tusho> i prefer the innuendo of 'have you played with your monads today'
10:49:13 <BMeph> Everybody >>= stand back (I know Monads)
10:49:27 * Twey laughs.
10:49:45 <trofi> > "they" >> "rock "
10:49:47 <lambdabot>  "rock rock rock rock "
10:50:02 * MyCatVerbs laughs.
10:50:06 <Twey> Haha, nice!
10:51:09 * Lycurgus grips gonads at mention of Monads.
10:51:27 <lament> "When i hear the word Monads I reach for my gonads?"
10:51:46 <dmhouse> Nice and subtle.
10:51:50 * Twey laughs.
10:51:59 <Stinger_> subtle like a brick through a window
10:52:43 <tusho> > "When I hear the word monads, my hand goes" >> "to my gonads"
10:52:44 <lambdabot>  "to my gonadsto my gonadsto my gonadsto my gonadsto my gonadsto my gonadsto ...
10:52:53 <tusho> imagine it to a beat
10:53:39 <tusho> When I hear the word monads my hand goes (swish swish) to my gonads, to my gonads, to my gonads, to my gonads
10:53:41 <tusho> (repeat)
10:53:58 <dmhouse> There are always the classics like "Putting the funk back into funktion" and "Functional programming with class".
10:54:30 <bos> @seen augustss
10:54:30 <lambdabot> I haven't seen augustss.
10:55:32 <Stinger_> > minimum []
10:55:34 <lambdabot>  mueval: *** Exception: Prelude.minimum: empty list
10:56:10 <trofi> > minimum $ map sin [1..]
10:56:13 <lambdabot>  mueval: Time limit exceeded
10:56:29 <_zenon_> (\x.da)(lamb)
10:56:47 <_zenon_> baaaah
10:56:51 <cpfr> subtle
10:56:54 <dmhouse> _zenon_: -> da
10:57:02 <tusho> mueval?
10:57:05 <tusho> 'sthat thing new?
10:57:18 <dmhouse> tusho: yep, it's gwern's doing.
10:57:23 <trofi>  > a + b
10:57:29 <tusho> dmhouse: What about that time we killed LB a few months ago?
10:57:29 <dmhouse> > a + b
10:57:32 <lambdabot>  a + b
10:57:34 <tusho> Is it resistant to that?
10:57:36 <_zenon_> dmhouse: it's the wooly calculus :)
10:57:40 <dmhouse> tusho: what did we do? Remind me?
10:57:49 <tusho> dmhouse: I don't recall, something about spawning a lot.
10:57:52 <tusho> Kind of like a forkbomb, I think.
10:58:03 <dmhouse> Oh. Probably. I don't think it'll let you fork...
10:58:11 <Myoma> > use unsafe functions
10:58:12 <lambdabot>  mueval: Unsafe functions to use mentioned.
10:58:12 <tusho> Well, it wasn't in IO.
10:58:20 <dmhouse> > const "unsafe"
10:58:20 <lambdabot>  mueval: Unsafe functions to use mentioned.
10:58:20 <tusho> [18:58:12] <Myoma> > use unsafe functions
10:58:21 <tusho> [18:58:12] <lambdabot> mueval: Unsafe functions to use mentioned.
10:58:21 <tusho> lol wut
10:58:32 <dmhouse> Yes, it's rather eager.
10:58:37 <tusho> What does that even mean?
10:58:39 <trofi> > "don't treat me as unsafe code"
10:58:39 <lambdabot>  mueval: Unsafe functions to use mentioned.
10:58:55 <tusho> Ah.
10:58:59 <tusho> That's kind of stupid.
10:59:10 <trofi> > "Boo! unsafe!"
10:59:10 <lambdabot>  mueval: Unsafe functions to use mentioned.
10:59:28 <tusho> > "MUEVAL IS UNSAFE IT ABORTS PERFECTLY FULLY-FORMED CODE. AT N WEEKS"
10:59:30 <lambdabot>  "MUEVAL IS UNSAFE IT ABORTS PERFECTLY FULLY-FORMED CODE. AT N WEEKS"
10:59:35 <tusho> > UNSAFEPERFORMIO
10:59:37 <lambdabot>      Not in scope: data constructor `UNSAFEPERFORMIO'
11:00:13 <dmhouse> > "I'm really not unsafe, I promise! :)"
11:00:13 <lambdabot>  mueval: Unsafe functions to use mentioned.
11:01:09 <Myoma> gwern: Why does anything containing "unsafe" get filtered out?
11:01:57 <tusho> Myoma: a ridiculous security measure
11:01:58 <tusho> I imagine
11:02:27 <dmhouse> It's not really ridiculous, it's just broken.
11:03:10 <lament> > "un" ++ "safe"
11:03:12 <lambdabot>  "unsafe"
11:03:46 <trofi> > 'u':"nsafe"
11:03:48 <lambdabot>  "unsafe"
11:03:56 <tusho> > "UNSAFFE"
11:03:58 <lambdabot>  "UNSAFFE"
11:04:06 <tusho> > "The food is unsafery."
11:04:06 <lambdabot>  mueval: Unsafe functions to use mentioned.
11:04:08 <lament> unsafe me now!
11:04:08 <tusho> :|
11:06:27 <_zenon_> damon the nomadic nomad
11:06:29 <_zenon_> :)
11:07:14 <dmhouse> I'm sure gwern would love it if someone would fix that unsafe bug.
11:07:26 <bos> the last chapter of the book is now online. http://www.reddit.com/comments/6xjrl/real_world_haskell_the_last_chapter_is_up_and/
11:07:32 <lambdabot> Title: Real World Haskell: the last chapter is up, and ... we're done writing! : reddit ..., http://tinyurl.com/6znnkk
11:07:58 <trofi> the last of Chapters
11:08:21 <lament> ooh congratulations!
11:08:36 <Deewiant> bos: chapter 11 has broken GHCi output, http://book.realworldhaskell.org/beta/binary.html
11:08:41 <lambdabot> Title: Chapter 11. Code case study: parsing a binary data format
11:09:23 <trofi> same for ch14
11:09:28 <lament> awesome cover, too
11:09:39 <lament> that's exactly the kind of bugs you get with haskell
11:09:52 <trofi> http://book.realworldhaskell.org/beta/data.html (Data.Sequence)
11:09:52 <lambdabot> Title: Chapter 14. Data Structures
11:10:02 <lament> not billions of tiny bugs you have to squish one by one
11:10:12 <lament> but one giant monster that comes and rips your head off
11:10:31 <sampointon> it's not a monster, it's a warm fuzzy thing that woke up on the wrong side of the bed today
11:10:33 <bos> Deewiant: thanks
11:11:17 <Deewiant> bos: it seems that some profiling paragraphs have comments which belong in the STM section? (near the "Time Profiling" heading)
11:11:28 <bos> Deewiant: yes, some comments got all buggered up.
11:12:46 <lament> sampointon: yeah, warm and fuzzy are precisely the two words that describe it best
11:13:18 <dmhouse> bos: hmm, clicking "1 comment" reveals the comment but then changes the text to "One comment".
11:13:34 <explicitjelly> :t many
11:13:36 <lambdabot>     Ambiguous occurrence `many'
11:13:36 <lambdabot>     It could refer to either `Control.Applicative.many', imported from Control.Applicative
11:13:36 <lambdabot>                           or `Text.ParserCombinators.Parsec.many', imported from Text.ParserCombinators.Parsec
11:13:37 <dons> interesting.
11:13:39 <bos> what debian package does Data.Sequence live in?
11:13:45 <explicitjelly> :t Control.Applicative.many
11:13:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
11:13:49 <dons> containers, bos.
11:13:52 <dons> so hmm, wherever that is.
11:13:55 <explicitjelly> @src Control.Applicative.many
11:13:55 <lambdabot> Source not found. My pet ferret can type better than you!
11:14:37 <bos> goddamit, level3 has just flaked out, so i can't fix anything.
11:14:40 <sampointon> > (\ s -> s ++ (show s)) "> (\\ s -> s ++ (show s)) "
11:14:42 <lambdabot>  "> (\\ s -> s ++ (show s)) \"> (\\\\ s -> s ++ (show s)) \""
11:16:21 <r3m0t> is that a quine I see before me
11:16:23 <sampointon> hmm, mueval always show-s the result?
11:16:46 <byorgey> sampointon: as does ghci.
11:16:47 <Deewiant> yes, and this happens now even with stuff like @check which is annoying :-/
11:17:33 * byorgey bakes a broccoli-lambda casserole
11:18:17 <_zenon_> byorgey, where did you find that recipe?
11:18:39 <byorgey> _zenon_: www.lambda-recipes.com, of course
11:18:41 <dcoutts_> gwern: try pulling cabal-install, I think I've fixed the config file issue you reported earlier
11:19:24 <ziman> > var "x"
11:19:25 <lambdabot>      Ambiguous occurrence `var'
11:19:25 <lambdabot>     It could refer to either `Data.Number.Sym...
11:19:32 <ziman> > var "x" :: Expr
11:19:33 <_zenon_> byorgey, ooh, I se. I'll try the unsafeChilli
11:19:33 <lambdabot>      Ambiguous occurrence `var'
11:19:33 <lambdabot>     It could refer to either `Data.Number.Sym...
11:20:09 <Lycurgus> oder?
11:20:19 <byorgey> _zenon_: careful with that, it's pretty spicy
11:21:06 <trofi> :t Var
11:21:07 <Lycurgus> did lambdabot use rhetorical ellipsis>
11:21:08 <lambdabot> Not in scope: data constructor `Var'
11:21:13 <Lycurgus> s/>/?/
11:21:22 <Lycurgus> ah
11:21:45 <trofi> > x
11:21:47 <lambdabot>  x
11:21:48 <trofi> :t x
11:21:50 <lambdabot> Expr
11:22:03 <trofi> @hoogle var :: a
11:22:04 <lambdabot> Language.Haskell.TH.Syntax VarName :: NameSpace
11:22:04 <lambdabot> Control.Exception BlockedOnDeadMVar :: Exception
11:22:04 <lambdabot> Distribution.Extension ScopedTypeVariables :: Extension
11:22:23 <ziman> :t var
11:22:24 <lambdabot> forall a. String -> Sym a
11:22:48 <trofi> @hoogle var :: String -> Sym a
11:22:48 <lambdabot> Warning: Unknown type Sym
11:22:48 <lambdabot> No results found
11:23:14 <trofi> @hoogle String -> a
11:23:15 <lambdabot> Prelude error :: String -> a
11:23:15 <lambdabot> Debug.Trace trace :: String -> a -> a
11:23:15 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
11:26:02 <twanvl> > SimpleReflect.var "x" :: Expr
11:26:04 <lambdabot>  x
11:26:13 <_zenon_> byorgey, have you tried the monad rice rolls ?
11:26:31 <_zenon_> byorgey, maybe I'm straining this joke a bit on the far side.
11:26:36 <byorgey> hehe =)
11:27:28 <byorgey> I'm personally a big fan of the applicative applesauce
11:28:45 <Stinger_> hmm, else should be aligned with if right?
11:28:52 <_zenon_> byorgey, hehehe, I've heard it goes perfectly to the point-free pancaces
11:30:09 <twanvl> Stinger_: else doesn't have to be aligned with anyhting, except in a do block it must be indented *more* than the if
11:30:36 <Stinger_> ah, right, it's in a do block
11:30:38 <Twey> The usual layout is:
11:30:40 <Twey> if foo
11:30:42 <Twey>   then bar
11:30:44 <Twey>   else baz
11:45:44 <Eelis> can lhs2tex be instructed to permit breaking up identifiers like "some_thing" into "some_" and "thing" at the end of a line? i have a few long names, and lhs2tex's unwillingness to let them be broken up at the underscores results in very awkward text layout
11:53:48 <byorgey> Eelis: I doubt it, not easily at least.  Line breaks in the middle of identifiers doesn't sound like something I'd imagine people would want to do very often.
11:54:53 <Eelis> well, i'd only want it on underscores. i sure wouldn't want "som\ne_thing" :)
11:55:18 <Myoma> it sounds like hyphenation ... I don't know anything about TeX though :/
11:55:30 <Myoma> (so I don't know if you can latch onto that mechanism ?)
11:55:46 <Eelis> that would be ideal, yes, but i don't know anything about how TeX does it either
11:58:27 <trofi> http://www.tex.ac.uk/cgi-bin/texfaq2html?label=nohyph
11:58:35 <lambdabot> Title: TeX Frequently Asked Questions -- question label "nohyph"
12:02:24 <Eelis> \hyphenation{some_-thing} is rejected. also, i'm skeptical hyphenation is used at all within lhs2tex's |...| sections
12:04:34 <trofi> isn't '_' - special symbol for tex?
12:05:15 <trofi> _ -> \_
12:07:00 <Eelis> no dice with \hyphenation{some\_-thing} either
12:07:19 <Eelis> (also rejected)
12:07:35 <FunctorSalad> this time I ran diff on it to avoid embarassment - the X in this error are really exactly the same: "Could not deduce X from the context X arising from the superclass of an instance declaration"
12:07:38 <Deewiant> how about some\_\-thing (not in \hyphenation but at the actual occurrence)
12:08:08 <luqui> FunctorSalad, are you using associated types?
12:08:50 <FunctorSalad> luqui: hmm not sure, not explicitly, but maybe one of my GHC_OPTIONS implies it
12:08:51 <Eelis> Deewiant: that works, but it's extremely fragile
12:09:05 <hackage> Uploaded to hackage: data-accessor-template 0.1.3
12:09:05 <hackage> Uploaded to hackage: show 0.3.1
12:09:05 <hackage> Uploaded to hackage: mueval 0.6.4
12:09:06 <hackage> Uploaded to hackage: WebBits 0.9.2
12:09:08 <hackage> Uploaded to hackage: language-c 0.3.1
12:09:43 <Deewiant> Eelis: yeah, lhs2tex is probably not expecting it
12:09:44 <luqui> FunctorSalad, there goes my hypothesis.  What's X?
12:10:17 <FunctorSalad> luqui: FWIW, " (FunctorC c a1 a2 m c' a1' a2' m' f)"
12:11:15 <FunctorSalad> (not the Haskell Functor; I'm trying to build a category theory zoo app)
12:12:29 <Eelis> Deewiant: actually lhs2tex just treats shows it as a subtraction. i meant that it was fragile in the sense that i would have to manually inspect and update this fix whenever the text before it changes, because this pseudo-hyphenation might no longer be needed
12:12:34 <Eelis> -treats
12:13:17 <Deewiant> yeah, that's kind of what I meant: if lhs2tex would expect it, it shouldn't show up if the word doesn't need to be hyphenated
12:13:33 <Eelis> right, ok
12:13:43 <Deewiant> or I think so, anyway
12:15:07 <luqui> FunctorSalad, hmm.  might you have found a ghc bug?
12:15:50 <FunctorSalad> luqui: possible, but I'd guess that I messed something else up and the error message is just misleading
12:16:06 <luqui> wel it
12:16:15 <luqui> well it's still a bug, even if it's just an error message one
12:16:21 <FunctorSalad> :)
12:16:38 <luqui> what version of ghc?
12:16:51 <FunctorSalad> 6.8.3
12:16:57 <luqui> (I'll ask that anyway.  Associated types are pretty broken in 6.8, leading to messages like that.)
12:17:05 <luqui> 6.9 fixes them.
12:17:29 <luqui> but you don't have any equality constraints or anything, so I don't see how it could be a problem.
12:17:34 <Heffalump> associated type synonyms are still pretty broken in 6.9 IME
12:17:35 <cpfr> does Omega work in 6.9
12:18:02 <luqui> Heffalump, really?  Didn't they publish a paper about how to make them work, and implement it?
12:18:21 <FunctorSalad> luqui: I'm not familiar with associated types, but if they need the "family" keyword I'm not using them
12:18:50 <luqui> FunctorSalad, not always.  Also:   class Foo a { type Bar a :: * ; ... }
12:19:35 <FunctorSalad> luqui: didn't even know that syntax exists :)
12:19:36 <Heffalump> luqui: well, product types still don't typecheck properly..
12:19:45 <Heffalump> (in ghc HEAD as of a few days ago)
12:19:48 <mega_repulsed> is there a host based intrusion detection system done in haskell?
12:19:53 <luqui> hm.
12:20:39 <FunctorSalad> luqui: the context is that I'm doing a redundant instance declaration in order to have a "most specific instance" as demanded by -XOverlappingInstances
12:21:17 <Heffalump> http://hpaste.org/9849
12:21:19 <luqui> ohh.  yikes.
12:21:25 <FunctorSalad> =)
12:21:40 * luqui doesn't play with Overlapping or Undecidable instances
12:22:08 <FunctorSalad> I have the undecidable instances on too ;)
12:22:39 <FunctorSalad> so I'm really expecting ghc to be a theorem prover more or less ;)
12:22:40 <luqui> Heffalump, I see :-(
12:22:53 <luqui> FunctorSalad, yeah it's pretty bad at that
12:25:11 <FunctorSalad> maybe I'll have to add a layer of indirection to my hierarchy of mathematical entities
12:25:56 <luqui> newtype away, that's usually how it's done.  not that I have any idea whether that will work for what you're trying to do.
12:26:17 <gwern> compuer science means not all dreams can come true!
12:26:25 <Myoma> The chemist says "3's prime; 5's prime; 7's prime; 11's prime. 9's not prime — ah well, experimental error. Therefore, all odd numbers are prime."
12:26:25 <Myoma> The engineer just says "3's prime; 5's prime; 7's prime; 9's prime; 11's prime; ..."
12:26:25 <Myoma> And the computer scientist writes a program that prints "1's prime; 1's prime; 1's prime; ..."
12:26:55 <Myoma> ah gwern, Why does anything containing "unsafe" get filtered out by this bot
12:26:55 <Myoma> ?
12:27:01 <dmhouse> Myoma: what? A joke for which an engineer isn't the butt? Heresy!
12:27:23 <FunctorSalad> > "unsafe"
12:27:23 <lambdabot>  mueval: Unsafe functions to use mentioned.
12:27:28 <FunctorSalad> hehe
12:27:42 <FunctorSalad> > "un" ++ "safe"
12:27:43 <SamB_XP> it sounds like the engineer and the chemist are using the same theory to me
12:27:43 <lambdabot>  "unsafe"
12:28:14 <cpfr> lambdabot: you spoke!
12:28:23 <gwern> FunctorSalad: mock it as you will; the next version will put paid to your petty derision!
12:29:01 <zandax> hi
12:29:06 <Myoma> gwern, hello?
12:29:09 <FunctorSalad> gwern: I didn't mock it. me and lambdabot are friends :(
12:29:23 <gwern> Myoma: blacklist
12:29:31 <gwern> Myoma: since so many dangerous functions use unsafe
12:29:46 <SamB_XP> gwern: yes but shouldn't it only match in identifiers ?
12:29:46 <Myoma> I don't see it
12:29:51 <FunctorSalad> @botsnack
12:29:51 <lambdabot> :)
12:29:52 <zandax> I am completly new to Haskell and have a small problem with replacing for loops with functional constructs
12:29:53 <gwern> unsafePerformIO, unsafeInterleaveIO, unsafeCoerce, unsafeIOtoST (?)
12:29:57 <lelf`> > {-unsafe-} 2+2
12:29:58 <lambdabot>  mueval: Unsafe functions to use mentioned.
12:30:11 <Myoma> gwern: So don't put any of them in scope
12:30:16 <lelf`> > {-safe-} 2+2
12:30:16 <gwern> SamB_XP: well sure, but that'd require analyzing an expression as a haskell expression and not doing string matching
12:30:18 <lambdabot>  4
12:30:25 <lelf`> oh:)
12:30:29 <gwern> Myoma: ah, I remember when I was similarly young and naive.
12:30:40 <Myoma> gwern: ...is filtering out the text "unsafe" a security measure?
12:30:41 <luqui> gwern, splain
12:30:41 <gwern> 'just don't import them, then, and you'll be fine'
12:30:44 <SamB_XP> gwern: so do you really think what you're doing is in some sense secure?
12:30:59 * Myoma suggests rewriting lambdabot in perl for even more security
12:31:13 <zandax> http://rafb.net/p/5fYXPw64.html <- what I basically want is drawing a line of 2d tiles (at first)
12:31:13 * SamB_XP agrees with Myoma  
12:31:18 <lambdabot> Title: Nopaste - haskell problem
12:31:27 <zandax> or of a tile map.
12:31:30 <Saizan> gwern: if you're going to load untrusted modules it's not hard to define safePerformIO = unsafePerformIO
12:31:30 <gwern> SamB_XP: I believe it is a leaky, poor method which I will replace with mmorrow's patches (which parse using haskell-src-exts) soon, and which may or may not provide a last ditch line of defense
12:31:43 <luqui> Myoma, definitely.  it has taints, which you can only remove by using regular expressions!
12:31:50 <zandax> however the function returns [IO ()] and I don't know how to get around that
12:32:03 <SamB_XP> luqui: eh?
12:32:10 <dmhouse> zandax: use sequence
12:32:12 <chrisdone> woah, lambdabot has now replaced hpaste?
12:32:13 <dmhouse> ?hoogle sequence
12:32:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:32:13 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:32:13 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
12:32:14 <gwern> yes, you've said that before and I've answered that before
12:32:20 <chrisdone> uh, ignore that. I've just woke up
12:32:41 <SamB_XP> luqui: how do the taints get applied to start with?
12:32:45 <dmhouse> Woah, hpaste has been integrated into lambdabot?
12:32:50 <zandax> Monads? But I thought they were kinda "bad" or so :|
12:32:56 <smg> lol
12:32:58 <zandax> Sorry, I am completly new
12:33:06 <smg> zandax: Monads = good
12:33:08 <luqui> SamB_XP, whenever they come from the envt in taint mode.  I.e. from a network socket, stdin, etc.
12:33:10 <smg> zandax: but you have to learn it
12:33:12 <Myoma> zandax, sequence :: [IO ()] -> IO [()]
12:33:33 <zandax> confusing
12:33:37 <chrisdone> dmhouse: I confused λbot's title display with paste declaration
12:33:47 <dmhouse> chrisdone: oh, heh, me too.
12:33:56 * chrisdone laughs
12:34:10 <luqui> zandax, right, sequence takes a list of actions and combines them into a single action
12:34:22 <chrisdone> @src sequence
12:34:22 <lambdabot> sequence []     = return []
12:34:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:34:22 <lambdabot> --OR
12:34:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:34:25 <Saizan> gwern: as a last point, lambdabot never had such a blacklist and worked pretty well
12:34:27 <zandax> I see
12:34:50 <gbacon> if I have a Maybe-valued predicate, how can I construct a pattern guard, e.g., foo x | Just a <- pred x = ... ?
12:34:56 <zandax> I'll try
12:35:07 <chrisdone> gbacon: that is correct
12:35:10 <Myoma> gbacon:  foo (pred -> Just a) = ...
12:35:15 <gbacon> chrisdone: thanks!
12:35:25 <gbacon> Myoma: thanks!
12:35:26 <chrisdone> Myoma: does that also work?
12:35:37 <gbacon> Myoma: is that a view type?
12:35:49 <Myoma> yeah, you need -XViewPatterns
12:35:54 <gwern> Saizan: maybe I wanted a blacklist in addition to the lambdabot mechanisms! did you ever think of that?
12:36:01 <_zenon_> Is there some nice page with proper information for setting up lambdabot in an IRC channel?
12:36:01 <chrisdone> myoma: very nice! :)
12:36:48 <Myoma> _zenon_: The readme file in the source code directory
12:36:51 <gwern> _zenon_: it's easy. get lambdabot darcs, compile & install, and then edit one of the rcs
12:36:59 <gwern> the rc format is very straightforward
12:37:10 <chrisdone> (“compiling lambdabot is now easy!”)
12:37:20 <gwern> change the bot name and channels, and you're good to go (once you've readf the readme as Myoma sez)
12:37:20 <gbacon> are view patterns in 6.8 or 6.10+?
12:37:24 <gwern> chrisdone: well, it is.
12:37:34 <Myoma> gbacon: 6.9
12:37:35 <_zenon_> Myoma, gwern okay
12:37:42 <FunctorSalad> gwern: the code analysis for lambdabot sounds like a hard problem. I'm clueless about the details, but why not somehow jail the bot from the outside?
12:37:54 <gbacon> Myoma: thanks
12:38:06 <Saizan> gwern: but you're using it for lambdabot, and the results aren't nice :)
12:38:35 <gwern> FunctorSalad: well, chroot has the problem that it generally isn't secure
12:38:41 <trofi> @djinn ?foo :: a -> [a]
12:38:41 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
12:38:51 <gwern> FunctorSalad: and I really couldn't ask Cale to set up a virtual machine just to run lambdabot
12:38:54 <Saizan> FunctorSalad: you just need not have in scope functions like unsafePerformIO
12:39:16 * gwern does plan to experiment with having mueval change user to nobody, but I haven't figured out how to do that from haskell
12:39:20 <FunctorSalad> hmm, ok
12:39:23 <luqui> Saizan, I think gwern disagrees, but I'm still wondering why
12:39:38 <Saizan> luqui: me too
12:39:43 <dmhouse> http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
12:39:45 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
12:39:52 <chrisdone> gwern: I might look at the source myself later on, so you can be brief, what is the general method for “securing” eval inputs right now?
12:39:55 <dmhouse> Specifically http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code#Exploits
12:39:57 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
12:40:05 <trofi> #ifdef UNIX\n c_setuid
12:41:08 <zandax> Thanks guys! I dunno how and why but it works perfectly with these sequences
12:41:18 <gwern> chrisdone: a thread-based timeout system; nicing; cd /tmp; blacklisting based on Strings; only importing from a whitelist of modules (specifically exlcuding antying which exports stuff like unsafePerformIO); and one or two others I forget
12:41:25 <chrisdone> gwern: from an old mueval I seem to remember filtering out impure names and impure modules (but strings like "unsafePerformIO" would cause the bot to spit it back out?)
12:41:26 <zandax> Can someone explain me the difference between IO () and IO [()] ?
12:41:43 <chrisdone> gwern: what's nicing?
12:41:45 <dmhouse> zandax: one is an IO action which yields a result of () (so basically, no result).
12:41:49 <gwern> chrisdone: yes, that's still there
12:41:49 <Myoma> zandax: Do you know what [] means?
12:41:57 <dmhouse> zandax: the other is an IO action which yields a list of ().
12:41:58 <zandax> a list
12:42:08 <Myoma> zandax: and ()?
12:42:10 <zandax> whats () then?
12:42:11 <zandax> no
12:42:16 <Myoma> () is the type with one single element
12:42:17 <dmhouse> zandax: the type whose only value is ()
12:42:18 <gwern> I plan to replace that soon
12:42:19 <Myoma> :t ()
12:42:19 <luqui> > :t ()
12:42:20 <gwern> maybe tonight
12:42:20 <lambdabot> ()
12:42:21 <lambdabot> Terminated
12:42:22 <dmhouse> > ()
12:42:25 <lambdabot>  ()
12:42:27 <Myoma> ok
12:42:29 <gwern> chrisdone: man nice
12:42:31 <Myoma> everyone wants to talk at once
12:42:34 <gwern> reduces the process priority
12:42:35 <chrisdone> gwern: ah, thank you
12:42:37 <dmhouse> zandax: so IO () basically doesn't return anything important.
12:42:45 <zandax> ok :/
12:43:01 <dmhouse> zandax: it's used for things like putStrLn where the side effects are actually the important bits
12:43:03 <Myoma> zandax: if Bool = 2, () = 1
12:43:07 <chrisdone> gwern: ah, that is nice
12:43:39 <gwern> chrisdone: iirc, the cabal description covers all thaat
12:43:40 <zandax> so IO () basically means 1 IO instance?
12:43:51 <dmhouse> zandax: it means an IO action.
12:43:52 <chrisdone> gwern: ah, okay, sorry
12:44:06 <Myoma> it means that there is a value of type () inside an IO monad
12:44:07 <dmhouse> zandax: what did you mean by "instance"?
12:44:15 <gwern> chrisdone: also, special show instances for functions and stuff, but that's not really important
12:44:56 <zandax> @dmhouse: I don't know exactly what IO is. I always thought its something like a class in ordinary non-functional languages.
12:44:56 <lambdabot> Unknown command, try @list
12:45:09 <dmhouse> zandax: not so much.
12:45:12 <cpfr> foo:: a -> IO ()   ~~ void foo(a) {} in C
12:45:26 <Myoma> zandax: I think of IO as a monad which emits instructions to whatever is running the haskell code
12:45:41 <dmead> > take 4 [1..5]
12:45:43 <lambdabot>  [1,2,3,4]
12:45:48 <Myoma> zandax: Do you know what a monad is?
12:45:49 <FunctorSalad> cpfr: is the lowercase a there intentional?
12:45:50 <dmhouse> zandax: an IO action is something which you run as part of a do block, or by binding it to main. It can have side-effects (like doing IO).
12:46:03 <zandax> Monads are "lists of actions" right?
12:46:08 <Myoma> zandax: No
12:46:13 <zandax> :|
12:46:16 <Myoma> @src Monad
12:46:17 <lambdabot> class  Monad m  where
12:46:17 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:46:17 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:46:17 <lambdabot>     return      :: a -> m a
12:46:17 <lambdabot>     fail        :: String -> m a
12:46:20 <Myoma> ^ It's one of those
12:46:22 <dmhouse> zandax: a (pure) function is simply a mapping of inputs to outputs. This mapping never changes, i.e. f 5 will always be the same, no matter how many times you call it.
12:46:22 <sampointon> zandax: they're used for sequencing actions, though
12:46:27 <cpfr> FunctorSalad: it was more to show it in context of the C function
12:46:33 <dmhouse> zandax: how are you learning Haskell?
12:46:35 <Myoma> with a couple of rules relating the functions
12:46:51 <FunctorSalad> cpfr: yeah, I was just wondering because I didn't see the equivalent of the type variable on the C side
12:46:57 <gwern> @tell dcoutts alas and alack! I cannot report haddock succes with darcs cabal-install as of 2 or 3 minutes ago
12:46:58 <lambdabot> Consider it noted.
12:47:05 <zandax> @dmhouse: I am reading the "haskell for c programmers tutorial"
12:47:05 <lambdabot> Unknown command, try @list
12:47:10 <cpfr> FunctorSalad: its in the foo
12:47:13 <zandax> But I am not really getting along with it
12:47:26 <chrisdone> @go real world haskell beta
12:47:28 <dmhouse> ?where yaht
12:47:29 <lambdabot> http://book.realworldhaskell.org/beta/index.html
12:47:29 <lambdabot> Title: Real World Haskell
12:47:29 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
12:47:33 <dmhouse> Try one of those.
12:47:43 <zandax> ok, thank you!
12:48:28 <zandax> You guys are a big help!
12:49:13 <Myoma> You don't actually need to understand any of this to write real programs in haskell by the way
12:49:56 <zandax> I don't?
12:50:12 <dmhouse> Yes you do.
12:50:21 <dmhouse> Or rather, you will do at some point.
12:50:43 <dmhouse> You can write main = putStrLn "Hello world" without knowing how the hell it works but at some point any half-decent tutorial should cover monads.
12:51:21 <zandax> You mean like programming imperative without knowing how a CPU works?
12:51:28 <Myoma> y
12:51:33 <luqui> Haskell for C programmers looks like a decent tutorial
12:51:44 <Zao> Much like you can std::cout << "Hello world" << std::endl; in C++ without having to know about Koenig lookup and operator overloading.
12:51:48 <Twey> zandax: More like programming imperatively without knowing how functions work
12:51:51 <chrisdone> the point is monads are a useful abstraction for writing programs and so they are worth learning
12:52:05 <Twey> Oh, yes, better example from Zao there.
12:52:15 <zandax> I understand
12:52:30 <FunctorSalad> one way to think of a monad is as something that can "upgrade" types
12:52:32 <Twey> It's relevant but not vital that you understand it straight away.
12:52:33 * luqui takes the above back
12:52:35 <Toxaris> many things are worth learning, but one should start with only some of them
12:52:48 <sampointon> either way, I always find the best way to learn something is to practice, and you have to start somewhere
12:53:13 <luqui> Zao, Koenig lookup = overloading resolution rules?
12:53:24 <cpfr> its important since other people's code will make heavy use of monads
12:53:33 <Zao> luqui: Also known as argument dependent lookup.
12:53:50 <Zao> luqui: A function name is looked up in the surrounding scope as well as the scopes and parent scopes of the parameter types.
12:54:01 <luqui> ok
12:54:02 <Myoma> if someone embeds a language in haskell and writes a program in that, you may not need to understand haskell to read and understand it
12:54:28 <zandax> Yeah
12:54:28 <chrisdone> if you are eager enough then you will write enough haskell code to the point where a monad is necessary because a certain kind of computation or abstraction is needed
12:54:59 <Toxaris> chrisdone: if you are lazy enough, you will start wondering about monads at exactly that point
12:55:05 <luqui> haha
12:55:18 <chrisdone> toxaris: hopefully
12:55:28 <sampointon> laziness is the mother of invention?
12:55:43 * luqui prefers to throw up his hands and say "monads suck, I'm going back to perl!'
12:56:01 <zandax> Is there a good solution for iterating nested lists also?
12:56:03 <chrisdone> Perl isn't slow, the programs are!
12:56:14 <luqui> zandax, what do you mean iterating?
12:56:15 <Myoma> zandax: I don't know what you mean
12:56:21 <BONUS> 4th monadic rule: monads rule
12:56:36 <zandax> I want to draw a 2d tilemap.
12:56:36 <SamB> zandax: concat!
12:56:40 <zandax> Which is stored as [[Int]]
12:56:54 <goblin_her0> laziness is the monther of all invetion
12:56:56 <BONUS> well you can use a map.map
12:57:00 <Myoma> zandax,
12:57:00 <Myoma> display :: Board -> String
12:57:01 <Myoma> display = unlines . map displayRow
12:57:01 <Myoma>  where displayRow = map (bool '#' ' ')
12:57:01 <goblin_her0> when combined with specializtion
12:57:05 <FunctorSalad> you might want to make a 2D-tiling monad?
12:57:09 <goblin_her0> I am a true believer in adam smith
12:57:11 <chrisdone> :t map.map
12:57:12 <BONUS> > (map . map) (+3) [[1,2,3],[3,4,5],[2,3,4]]
12:57:13 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
12:57:15 <lambdabot>  mueval: Time limit exceeded
12:57:17 <SamB> how about a comonad?
12:57:22 <SamB> (possibly both?)
12:57:35 <SamB> note: I'm NOT kidding
12:57:48 <goblin_her0> most pain at work
12:57:59 <Myoma> goblin_her0: What's up?
12:58:00 <Toxaris> why Time limit exceeded?
12:58:03 <goblin_her0> it due to fact that someone inherits a system they didnt build and dont understand
12:58:21 <FunctorSalad> SamB: hmm, what would be the map M a -> a ?
12:58:25 <Myoma> zandax, oh I have bool true false True = true ; bool true false False = false by the way
12:58:27 <luqui> SamB, well, surely you are wrt to the best solution for zandax.  But a comonad is a nice contender for the 'best' solution :-)
12:58:29 <goblin_her0> once i understand a ssytem is easy and i can ven try to improve
12:58:51 <goblin_her0> what are methods fo interprocess communication with haskell?
12:58:56 <Myoma> Why on earth would you use a comonad to display a grid?
12:58:57 <goblin_her0> of-
12:59:20 <luqui> Myoma, comonad to do arbitrary computations over a grid.  displaying is one of them.
12:59:21 <chrisdone> > (map . map) (+3) [[1,2,3],[3,4,5],[2,3,4]]
12:59:22 <lambdabot>  [[4,5,6],[6,7,8],[5,6,7]]
12:59:31 <chrisdone> λbot likes me
12:59:34 <gbacon> for ByteStrings, if findSubstring is deprecated, what should I use instead?
12:59:37 <BONUS> :[
12:59:55 <SamB> FunctorSalad: well, he could use a zipper representation, and coreturn would give the focused tile
12:59:55 * luqui only found the (map . map) ... notation appealing.  I think it's highly abstract.  I prefer map (map f) ...
13:00:01 <Myoma> luqui: Is there an example of this somewhere ?
13:00:05 <luqui> s/appealing/appealing recently/
13:00:14 <FunctorSalad> SamB: or a superposition of all the tiles, heh
13:00:18 <luqui> Myoma, http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
13:00:21 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
13:00:29 <SamB> FunctorSalad: I didn't say anything about quantum mechanics
13:00:38 <Toxaris> > ((<$>) . (<$>)) (+3) [[1,2,3],[3,4,5],[2,3,4]] -- its time for the greedy monster combinator again
13:00:40 <lambdabot>  [[4,5,6],[6,7,8],[5,6,7]]
13:00:42 <SamB> or images or anything
13:00:44 <FunctorSalad> SamB: would be enough if the tiles had an addition function
13:01:03 <luqui> Toxaris, ah yes, quite transparent =/
13:01:05 <SamB> but a comonad can't constrain the tile type that way in Haskell ...
13:01:25 <chrisdone> :t join
13:01:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:02:04 <Toxaris> luqui: do you prefer ((<$>) <$> (<$>))? ;)
13:02:09 <luqui> haha
13:02:32 <luqui> :t (.)
13:02:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:02:38 <luqui> hey, no Caleprelude!
13:02:40 <FunctorSalad> SamB: hmm, why not? the "data" that implements the grid can constrain the type
13:03:21 <luqui> FunctorSalad, you will get errors when you try to "instance Comonad Grid"
13:03:23 <dmhouse> > let o = id in (o . o) 4 {- the owl operator? -}
13:03:25 <lambdabot>  4
13:03:33 <Myoma> I do not get the impression any of this is actually a good idea
13:03:35 <FunctorSalad> luqui: hmm, I see
13:03:51 <cpfr> ?src <$>
13:03:52 <lambdabot> f <$> a = fmap f a
13:04:00 <luqui> unless you use constrained (co)monads.
13:04:04 <olsner> Toxaris: is that ap ap ap or fmap fmap fmap?
13:04:18 <dons> this is weird, http://uncyclopedia.org/wiki/Haskell
13:04:18 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
13:04:20 <Toxaris> olsner: fmap fmap fmap
13:04:21 <dons> surely we can do a funnier job.
13:04:40 <Toxaris> olsner: with the first fmap = (.), and the others = map, in this example
13:04:42 <luqui> > fmap fmap fmap (+3) [[1,2],[3,4,5]]
13:04:43 <gwern> yeah. objectivist c is hilarious, but that isn't too hot
13:04:43 <lambdabot>  [[4,5],[6,7,8]]
13:04:50 <FunctorSalad> dons: what a coincidence, I read that this morning. it's rather caustic
13:05:09 <dons> but done by one of us. :)
13:05:15 <FunctorSalad> though "nonfunctional programming language" wasn't bad ;)
13:05:20 <olsner> Toxaris: heh, filter (/= 'm') for a smidgen of lulz
13:05:20 <FunctorSalad> yeah
13:05:41 <dons> i always throught there was a joke about "ineffective" programming
13:05:47 <dons> being that without side effects
13:05:48 <dons> :)
13:06:08 <Toxaris> olsner: ?
13:06:22 <luqui> don't forget the pointless programming subculture
13:06:30 <olsner> don't worry, it was a bad joke anyway
13:06:43 <olsner> I'd like a pointless programming t-shirt
13:06:56 <dons> ineffective and pointless
13:07:13 <SamB> I initially thought that purely-functional programming meant programming where EVERYTHING is a function -- I was quite puzzled as to how the output would be interpreted ...
13:07:16 <luqui> olsner, heh, gross
13:07:22 <SamB> or seen at all
13:07:32 <dons> bulat sez: "many thanks! the book is huge step toward in spreading Haskell to rule
13:07:32 <dons> the world :)"
13:07:33 <dons> yaya:)
13:07:39 <goblin_her0> what book?
13:07:45 <dons> ?go real world haskell
13:07:50 <lambdabot> http://www.realworldhaskell.org/
13:07:50 <lambdabot> Title: Real World Haskell
13:07:53 <goblin_her0> ?go real world haskell
13:07:53 <Toxaris> one book to rule them all
13:07:56 <lambdabot> http://www.realworldhaskell.org/
13:07:56 <lambdabot> Title: Real World Haskell
13:07:59 <TomMD> That page isn't accurate, dons.  Not everyone here is a dead end college student - I have at least three years ahead of me before I can be declared "dead end"!
13:08:05 <dons> TomMD: heh
13:08:06 <FunctorSalad> SamB: hmm, untyped lambda calculus does that. you get the identity maps λx.x as base cases
13:08:08 <luqui> yay for orielly.  if they have a book about it, it must be cool.
13:08:18 <dons> luqui: so true. so true.
13:08:30 <stulli> > putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
13:08:32 <lambdabot>  mueval: *** Exception: "<IO ()>"
13:08:34 <SamB> FunctorSalad: yes, I know that NOW...
13:08:48 <goblin_her0> wait a second
13:08:50 <Myoma> I think  (Bool ->)  as on ordered pair is very neat
13:08:54 <goblin_her0> its not free online?
13:08:56 <chrisdone> samb: I thought that one might have to subscribe to event “callbacks” in ones code. like “call this pure function when a line is given to me” rather than “wait for line input”
13:09:11 <Myoma> goblin_her0: the whole thing is online
13:09:11 <_zenon_> Configuring lambdabot-4.1...
13:09:11 <_zenon_> Setup.hs: At least the following dependencies are missing:
13:09:11 <_zenon_>     zlib -any, binary >=0.2, plugins >=1.0, oeis -any
13:09:15 <_zenon_> I keep getting that error
13:09:24 <_zenon_> but I have zlib1g installed
13:09:26 <dmhouse> Huh? Where's the IO in stulli's code?
13:09:28 <FunctorSalad> (actually nvm what I said, there's nothing special about the identities)
13:09:30 * luqui likes type Bool = forall c. c -> c -> c
13:09:30 <SamB> FunctorSalad: and I'm also aware of Lazy K now...
13:09:34 <dons> _zenon_: are they installed as --user ?
13:09:46 <dmhouse> Oh, I missed the putStrLn. Heh.
13:10:00 <_zenon_> dons, I'll check
13:10:01 <Myoma> @let bool true false True = true ; bool true false False = false
13:10:02 <lambdabot> Defined.
13:10:03 <Myoma> :t bool
13:10:04 <lambdabot> forall t. t -> t -> Bool -> t
13:10:40 <Myoma> > intercalate ',' . bool "prime" "composite" . map odd $ [1..]
13:10:42 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
13:10:44 <TomMD> @let (?) a True b = a ; (?) a False b = b
13:10:45 <lambdabot> Defined.
13:10:48 <_zenon_> dons, seems so
13:11:11 <Myoma> > intercalate ", " . map (bool "prime" "composite") . map odd $ [1..]
13:11:23 <lambdabot>  "prime, composite, prime, composite, prime, composite, prime, composite, pri...
13:12:13 <luqui> > intercalate ", " . map ("she loves me" ++) . map (bool "" " not") $ cycle [True,False]
13:12:15 <lambdabot>  "she loves me, she loves me not, she loves me, she loves me not, she loves m...
13:12:18 <FunctorSalad> @dict-all intercalate
13:12:19 <lambdabot> Unknown command, try @list
13:12:24 <FunctorSalad> @all-dicts intercalate
13:12:25 <lambdabot> *** "Intercalate" gcide "The Collaborative International Dictionary of English v.0.48"
13:12:25 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
13:12:25 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
13:12:25 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
13:12:25 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
13:12:27 <lambdabot> [18 @more lines]
13:12:39 <luqui> that was useless
13:12:44 <FunctorSalad> :)
13:12:44 <chrisdone> awful definition
13:12:48 <Myoma> @wore
13:12:48 <lambdabot>    {Calendar}.]
13:12:48 <lambdabot>    [1913 Webster]
13:12:48 <lambdabot>    1. (Chron.) To insert, as a day or other portion of time, in
13:12:48 <lambdabot>       a calendar.
13:12:48 <lambdabot>       [1913 Webster]
13:12:50 <lambdabot> [13 @more lines]
13:12:59 <Myoma> @wole
13:12:59 <lambdabot> Maybe you meant: more vote
13:12:59 <chrisdone> is that a joke dictionary, like the devil's dictionary, but sans funny?
13:13:29 <FunctorSalad> chrisdone: no, it's real. the actual definition just got cut off
13:14:03 <Toxaris> well, the latin root "to call between" is near enough the Haskell meaning, isn't it
13:14:24 <dons> woo, new monad tutorials! http://www.reddit.com/r/programming/comments/6xkge/the_first_monad_tutorial_of_the_season/
13:14:25 <sampointon> also, what kind of pronunciation transcription is that?
13:14:27 <dons> new metaphors :)
13:14:31 <lambdabot> Title: The First Monad Tutorial of the Season : programming, http://tinyurl.com/63hsh7
13:14:40 <zandax> Drawing the map works perfectly know! But I know have a drawRow helper function which does not look very elegant :/
13:14:59 <Toxaris> Monads are like Metaphors.
13:15:38 <FunctorSalad> yeah, Metaphors are endofunctors of the category of.... err, nevermind
13:16:13 <Beelsebob> a bad analogy is like a leaky screwdriver :)
13:17:32 <FunctorSalad> technically a metaphor takes two concepts and points at their common abstract properties, doesn't it?
13:17:36 <sampointon> Monad, n - an assistive tool used by blog authors to write tutorials and coin confused metaphors and invent contrived examples
13:17:59 <Toxaris> "(Recall that a type definition is just like a data definition,
13:17:59 <Toxaris>  but with no choice operator (|).)" no sorry thats wrong :(
13:18:06 * Myoma would like tutorials about other structures than monads
13:18:37 <Myoma> infact maybe we should sentance anybody that writes a monad tutorial to write a tutorial for one of edwardks category extras
13:18:42 <chrisdone> Applicative n, an anomaly, used by blog authors to demonstrate awesome abstractions and make haskell look godlike
13:18:47 <luqui> Beelsebob, LOL
13:19:01 <Toxaris> imho people should learn abstract data types, type classes, constructor classes and types, then look at the definition of class Monad and of some instances, then be happy
13:19:15 <zandax> http://rafb.net/p/H8QpYZ32.html <- and I get an exception error :(
13:19:16 <lambdabot> Title: Nopaste - haskell problem
13:19:31 <FunctorSalad> is there a "a Monad is like a car" analogy yet? (you could pretty much adapt the monster analogy tutorial I guess)
13:19:39 <zandax> sry, if I would know this bot I would use useful titles
13:19:40 <Myoma> zandax: I suggest a different approach
13:19:47 <sw17ch> that's quite the exception
13:19:51 <Beelsebob> luqui: did you see my type signature of "I'm more awesome than you, because this type signature is huge"
13:19:54 <luqui> Myoma, that's a good idea
13:20:00 <Myoma> zandax: first define a synonym to make things easier, type Cell = Int
13:20:06 <Myoma> zandax: type Board = [[Int]]
13:20:09 <luqui> Beelsebob, no
13:20:19 <Beelsebob> luqui: http://hpaste.org/9846
13:20:23 <Myoma> zandax: now write, coordinate :: Board -> [(Coordinate,Cell)]
13:20:26 <Beelsebob> I don't think it's finished yet either
13:20:30 <Myoma> zandax: type Coordinate = (Int,Int)
13:20:37 <Beelsebob> there'll be a bit more as I add the other 4 arrow laws
13:20:39 <luqui> oh my god
13:20:42 <chrisdone> Toxaris: likewise. what clicked for me is when I implemented the State monad in javascript, going off the State's implementation code, and I only used functions to do it. so (1) I got the experience of realising the state monad is clever but understandable and (2) realised that my implementation wasn't a true monad because I didn't use some kind of polymorphism
13:20:45 <Beelsebob> luqui: :D
13:20:46 <zandax> sounds good
13:20:50 <luqui> that has to be computer generate
13:20:50 <luqui> d
13:20:54 <Myoma> zandax: so now, drawMap board = mapM_ drawTile (coordinate board)
13:20:55 <Beelsebob> nope
13:20:57 <olsner> hmm, I think I've actually seen worse type signatures :P
13:21:12 <zandax> mapM_ ?
13:21:15 <Myoma> zandax: but drawTile :: (Coordinate,Cell) -> IO () or something, anyway it should be straightforward
13:21:33 <luqui> olsner, in eg. adga definitely
13:21:42 <chrisdone> Toxaris: that is, my bind only worked with one type of monad, which misses the point of what a monad is. that is where I had a zen moment
13:21:47 <Beelsebob> well... you could call it computer generated, in that I figured it out by adding a constraint every time the compiler complained luqui
13:21:48 <olsner> but that was iirc part generated, part ghci bug, part vast amount of inferred contexts
13:22:26 <Toxaris> chrisdone: well, you had still implemented a monad, but not the abstraction of all monads
13:22:32 <Toxaris> chrisdone: if I understand you correctly
13:22:48 <zandax> I will definitely try a different apporach, Myoma
13:22:54 <chrisdone> Toxaris: right. without the monad abstraction it's just a library that uses closures cleverly
13:23:00 <zandax> But it would be good to know why I get this exception
13:23:26 <FunctorSalad> luqui: huh? Beelsebob's code looks rather clean to me except that I don't know what an "Arbitrary" and "EqProp" is :)
13:24:06 <Beelsebob> FunctorSalad: a type sig 12 lines long?
13:24:12 <chrisdone> Toxaris: http://chrisdone.com/stuff/javascript-state-monad.js.html (since I have discovered that one can use objects in javascript to get polymorphism, so proper monads are actually possible!)
13:24:14 <lambdabot> Title: State monad in Javascript
13:24:20 <Twey> Is someone coding in the type system again?
13:24:27 <Beelsebob> also, Arbitrary means quickcheck can generate arbitrary items in the type
13:24:36 <Beelsebob> and EqProp means that there's equality for properties defined
13:24:40 <Toxaris> FunctorSalad: IIRC a Metaphor relates two domains so that each concept in one domain relates to a concept in the other domain, and the relations between the concepts are preserved, so a metaphor may be an arrow in some category?
13:24:45 <SamB> Twey: what, isn't there always SOMEONE doing it?
13:24:52 <sampointon> chrisdone: and if all else fails, you greenspun yourself a Haskell interpreter!
13:24:54 <luqui> Beelsebob, yeah, you're basically just mimicing ghci... slowly
13:25:09 <Beelsebob> luqui: yeh, except that ghci can't actually infer the type for it
13:25:10 <chrisdone> sampointon: and why not?
13:25:16 <Beelsebob> or at least, not in one pass
13:25:24 <Twey> SamB: *chuckles* Perhaps
13:25:28 <luqui> hm.  that's... odd.
13:25:34 <Beelsebob> actually no, there are a couple of bits of that that I had to figure out manually
13:25:41 <Beelsebob> luqui: there's a few MPTC bits in the def
13:25:46 <Beelsebob> so it can't do full inference
13:25:51 <FunctorSalad> Toxaris: good point, I had just been thinking of metaphors between single words... if the domain is a category, then the metaphor *is* a functor ;)
13:25:57 <sheyll> is there a memory leak in here?
13:26:01 <sampointon> chrisdone: actually, Haskell in Javascript might be interesting, now that I think about it
13:26:09 <sioraiocht> so, if data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents, what does the Addr# point to?
13:26:22 <chrisdone> sampointon: yhc apparently compiles to javascript
13:26:23 <Toxaris> people keep telling that Javascript is a cool low-level language
13:26:24 <Myoma> sheyll, yeah, you should have brought wellington boots
13:26:35 <chrisdone> toxaris: it's like a retarded Scheme
13:26:44 <FunctorSalad> Toxaris: it's even pretty common in math that functors formalize the idea of metaphor
13:26:44 <jeffwheeler> @pl \s -> x >= (snd s)
13:26:45 <lambdabot> (x >=) . snd
13:26:50 <sheyll> http://hpaste.org/9851
13:27:14 <chrisdone> toxaris: I find people discover it's not as horrible as the software implemented in it suggests
13:27:29 <Myoma> sheyll: why not just use foldr?
13:27:48 <sampointon> Toxaris: I presume these people are enterprise-grade web programmers, who up til last year were trapped in a Java servlet. Javascript is practically heaven to them
13:27:49 <Beelsebob> luqui: tbh, what I find worrying is that there are people in here that don't mind it :/
13:27:57 <Beelsebob> but I have no idea how to make it any better
13:27:59 <chrisdone> I really dislike this “x <- action; if x then ... else ...” idiom. isn't there an abstraction for it?
13:28:02 <sheyll> Myoma: but how do I check for eof?
13:28:04 <chrisdone> :t ifM
13:28:06 <lambdabot> Not in scope: `ifM'
13:28:09 <Myoma> sheyll: You don't
13:28:13 <sheyll> ??
13:28:30 <chrisdone> :hoogle (m Bool) -> m a -> m a -> m a
13:28:37 <Beelsebob> chrisdone: if'?
13:28:46 <chrisdone> if' won't extract the value from the monad
13:28:49 <byorgey> sheyll: just do a readFile to get the whole file as a string, then break it up with 'lines', and fold over that
13:28:56 <chrisdone> unless you're thinking of a new definition of if'
13:29:00 <Toxaris> chrisdone: liftM3 if' ?
13:29:00 <Beelsebob> chrisdone: it will if you define it fully generally on applicatives
13:29:07 <Jedai> sheyll: liftM (foldr f z . lines) hGetContents h
13:29:12 <byorgey> sheyll: due to laziness, that's a perfectly memory-efficient way to do it
13:29:23 <chrisdone> Beelsebob: how would that look?
13:29:24 <_zenon_> dons, you had some suggestion to the lambdabot problem?
13:29:25 <luqui> Beelsebob, I find it worrying that you can't make it better.   What... does it do?
13:29:27 <sheyll> byorgey: I am analyzing logfiles that are > 6 GB, this will cause an outof memory error
13:29:35 <byorgey> sheyll: no, it won't =)
13:29:40 <sheyll> I tried that in the first place...
13:29:52 <sheyll> uh.... it did?
13:29:54 <byorgey> well, the memory error might be due to a too-lazy fold
13:29:56 <SamB> sheyll: maybe you used the wrong fold?
13:29:56 <Beelsebob> luqui: it's for defining all the constraints you need on the various bits of an arrow to test whether it really is an arrow or not
13:30:00 <byorgey> not because of reading the file all at once
13:30:03 <chrisdone> Toxaris: I don't suppose that is so bad...
13:30:07 <Jedai> sheyll: Show your code, you're being too strict somewhere
13:30:13 <sheyll> k
13:30:15 <byorgey> readFile and hGetContents are lazy, they only read as much as you need
13:30:17 <Myoma> why is everyone using haskell to analyze logs?
13:30:17 <luqui> Beelsebob, oh it checks the arrow laws?
13:30:19 <Jedai> sheyll: or not enough...
13:30:19 <SamB> Jedai: or too lazy ;-)
13:30:23 <Beelsebob> luqui: yep
13:30:30 <Myoma> Or maybe people are using haskell for everything and only the log analyzers have problems
13:30:34 <SamB> Myoma: well, how would YOU do it?
13:30:35 <luqui> okay, I can believe that then.  THere are a lot of them...
13:30:41 <Myoma> I would not, I don't care about logs
13:30:48 <Jedai> Myoma: Well, Haskell is actually pretty good at it
13:30:57 <SamB> Myoma: what if you did care?
13:31:05 <Myoma> Jedai: I estimate it's the most mentioned problem in #haskell
13:31:14 <chrisdone> a disturbing thing is that I have been using haskell for all my scripting needs, and as a result haven't learned how to be magic with grep and awk and sed and those types
13:31:19 <dons> i hope people are using bytestrings...
13:31:20 <SamB> kind of hard to get accurate statistics
13:31:28 <dons> since anything else is mistake.
13:31:37 <MyCatVerbs> dons: I don't. I want to see people using Data.Text, when it's out. :P
13:31:42 <SamB> dons: I've been using tritstrings, personally
13:31:50 <FunctorSalad> chrisdone: hmm, does haskell really replace grep?
13:31:52 <Jedai> dons: especially for 6GB log files !! (lazy bytestring)
13:31:54 <Toxaris> sampointon: no, these people are researchers in the programming languages / compilers / virtual machines fields
13:31:54 <chrisdone> ChompString :p
13:31:54 <olsner> as soon as you figure out the correct fold, haskell is awesome for log analyzing - high-level and fast!
13:32:00 <dons> Jedai: yeah. crikey.
13:32:04 <Myoma> SamB: ok, let's write a log analyzer to get accurate statistics
13:32:27 <dmead> :t rest
13:32:28 <Myoma> @remember <olsner> as soon as you figure out the correct fold, haskell is awesome for log analyzing - high-level and fast!
13:32:28 <lambdabot> I will remember.
13:32:29 <lambdabot> Not in scope: `rest'
13:32:36 <sheyll> ok I pasted it, it doent get announced, does it?
13:32:47 <Myoma> :t sleep
13:32:48 <lambdabot> Not in scope: `sleep'
13:32:49 <Toxaris> dmead: tail?
13:32:50 <dons> maybe i should repackage uvector as a log analsysi library
13:32:52 <chrisdone> FunctorSalad: in the case of myself, I wrote a few lines for “hgrep”. maybe grep already does this, but it allows you to parenthesize values that you want outputted from the match. I think awk lets you do this
13:32:53 <MyCatVerbs> chrisdone: grep and sed and awk and all those types aren't particularly interesting for analysis tasks.
13:32:55 <dmead> :ah yes
13:32:55 <Myoma> dmead: no rest for the wicked
13:32:55 <dmead> ty
13:33:04 <sheyll> ok ... http://hpaste.org/9852
13:33:04 <dmead> > tail [1..10]
13:33:06 <lambdabot>  [2,3,4,5,6,7,8,9,10]
13:33:09 <sheyll> this is a lot ofg stuff sorry
13:33:32 <sheyll> but I tried to optimize that, and I played around with haskell
13:33:54 <MyCatVerbs> chrisdone: they work just fine, but they're far more painful to use than pretty much any real programming language.
13:34:00 <SamB> Myoma: well, the trouble is determining when someone has mentioned a problem, and what kind(s) of problem it is
13:34:06 <chrisdone> FunctorSalad: e.g. cat 'foo 1 2' | hgrep "^foo ([0-9]) ([0-9])" => 1 2
13:34:07 <sheyll> my intuition was that haskells lazyness could be of help for log analyzing, but I realized I just too n00b to figure it out
13:34:16 <Toxaris> FunctorSalad: I think I see, a category is a formalization of a domain, arrows are formalizations or relations and so on, so functors are formalizations of metaphors
13:34:21 <chrisdone> MyCatVerbs: I think I agree
13:34:37 <FunctorSalad> chrisdone: nice. I don't know off hand whether grep has a flag to extract groups
13:34:53 <olsner> you'll probably want to change that foldr into a foldl' at least
13:35:07 <Toxaris> FunctorSalad: and since monads are special functors, monads are metaphors is not so bad maybe :)
13:35:13 <MyCatVerbs> FunctorSalad: who cares if it does? groupBy (\a b -> ...) is much less painful to work out.
13:35:51 <chrisdone> FunctorSalad: to my hapiness I found that my compiled hgrep is acceptably fast. IIRC it matched 10,000 lines in a second quite happily (that includes extracting values and outputting them to stdout)
13:36:28 <luqui> a monad is a metaphor with the ability to collapse a metaphor of a metaphor back into the original metaphor
13:36:36 <FunctorSalad> chrisdone: I guess that depends on the regexp library you used? or did you write the whole thing from scratch?
13:36:41 <luqui> yeah, _that_ makes sense
13:36:47 <chrisdone> FunctorSalad: I just imported Text.Regex
13:37:17 <byorgey> monads aren't metaphors, they're tar pits for metaphors
13:37:33 <MyCatVerbs> chrisdone: AFAIK, Haskell hackers seem to use Parsec in most situations where others would try to apply regexen.
13:38:12 <FunctorSalad> luqui: hmm, I think it does. maybe think "translation" instead of "metaphor"
13:38:21 <Toxaris> I kind of forgot that we are dealing with endofunctors here, and a endo-metaphor doesn't make much sense
13:38:41 <chrisdone> MyCatVerbs: aye
13:38:46 <luqui> what's an endofunctor?
13:38:56 <byorgey> luqui: a functor from a category to itself
13:39:08 <luqui> or to a subcategory, presumably?
13:39:22 <luqui> well, yeah, that it would be also
13:39:45 <SamB_XP> @quote <olsner>
13:39:45 <lambdabot> <olsner> says: as soon as you figure out the correct fold, haskell is awesome for log analyzing - high-level and fast!
13:39:46 <FunctorSalad> that's almost the same thing, since a functor needn't be surjective anyway
13:39:52 <SamB_XP> @quote olsner
13:39:52 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
13:39:53 <FunctorSalad> ( @ luqui )
13:39:54 <SamB_XP> @quote olsner
13:39:54 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
13:40:02 <dons> heh
13:40:04 <luqui> going skydiving is like forgetting your parachute when you're skydiving.
13:40:18 <SamB_XP> @remember olsner as soon as you figure out the correct fold, haskell is awesome for log analyzing - high-level and fast!
13:40:18 <lambdabot> I will never forget.
13:40:22 <luqui> what's a harmful feature?
13:40:25 <byorgey> you can always compose a functor from C to a subcategory S of C  with the inclusion functor from S to C to get an endofunctor.
13:40:29 <luqui> I thought haskell had launchMissiles
13:41:02 <SamB_XP> luqui: nobody has written the wargames package yet
13:41:05 <MyCatVerbs> luqui: defined as (missilesAt >>=) ;P
13:41:17 <sampointon> that's nor harmful, it's an essential part of the national defence system!
13:41:25 <olsner> unsafeWageWar launchMissiles
13:41:26 <goblin_her0> i love this game
13:41:27 <goblin_her0> !!
13:41:55 <SamB_XP> goblin_her0: what game?
13:41:58 <Toxaris> hehe the War monad
13:42:16 <Beelsebob> luqui: we should embed a hidden launchMissiles function in nm8
13:42:23 <dons> one thing i like about RWH is that we've written down some of the cultural aspects
13:42:25 <sampointon> no, wouldn't it be the Weapon typeclass
13:42:35 <luqui> Beelsebob, what would it mean?
13:42:36 <dons> things like launching missles in side effects.
13:42:42 <dons> haskell memes, for the world.
13:42:46 <luqui> we could have it lock up the computer?
13:42:51 <olsner> obviously unsafeWageWar is perfectly harmless until evaluated :)
13:43:00 * stepcut implemented the card game, 'war' in basic once. You could play against the computer. But it was boring to just hit enter, so I add a mode where it would play your hard automatically... then it was really pointless.
13:43:02 <Beelsebob> luqui: nah, something more entertaining
13:43:07 <luqui> agreed
13:43:07 <Beelsebob> like... blow up the computer
13:43:15 <SamB_XP> it should display an animation of missles being launched
13:43:19 <luqui> Beelsebob, you can code that!?  No wonder they hired you.
13:43:35 <bos> @hoogle alloca
13:43:35 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
13:43:36 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
13:43:36 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
13:43:36 <chrisdone> stevan: please don't talk about your porn games here
13:43:37 <Beelsebob> lol
13:43:40 <luqui> oh I've got it.  We require a hardware key like protools, which has a bomb in it.
13:43:51 <bos> @hoogle poke
13:43:51 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
13:43:51 <lambdabot> Foreign.Storable pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
13:43:51 <lambdabot> Foreign.Storable pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
13:43:53 <SamB_XP> ... possibly by launching a webbrowser on an appropriate youtube vidoe...
13:44:00 <SamB_XP> er. video...
13:44:05 <dons> whatcha looking for, bos?
13:44:19 <Beelsebob> luqui: awesome plan
13:44:22 <Toxaris> it should launch a webbrowser on a faked CNN like site with news about the war
13:44:23 <Beelsebob> but why a bomb?
13:44:26 <Beelsebob> why not missiles?
13:44:30 <luqui> oh right
13:44:32 <Beelsebob> fire them at the artist's face
13:44:36 <bos> dons: trying to figure out why my haskell inner loop is half the speed of my C.
13:44:41 <Beelsebob> hmm... aimMissiles function too
13:44:48 <Beelsebob> so kim can fire them a sven
13:44:49 <sheyll> :t  liftM (foldr f z . lines) hGetContents h
13:44:51 <lambdabot> Not in scope: `hGetContents'
13:44:57 <SamB_XP> Beelsebob: we don't need no stinking AIM
13:45:00 <dons> bos, oh, bloomfilters?
13:45:05 <bos> dons: i'm hashing a list of bytestrings, and i think i need to hoist the calls to alloca out of the inner loop somehow.
13:45:07 <bos> dons: yes
13:45:13 <dons> hmm
13:45:41 <dons> we did a bit of that with rewrite rules in Data.Binary, hoisting bounds checks out of applicative pipeliens.
13:45:41 <bos> i can't avoid the need to poke in the inner loop, but i suspect that alloca in haskell doesn't just adjust the size of the stack inline, like it does in C.
13:45:47 <dons> dcoutts: reminds me, we should write that up at some point.
13:46:05 <bos> dons: yes, i'll probably have to do this via some gnarly rewrite rule. if it actually helps.
13:46:37 <dons> bos, it's a heap allocation though
13:46:40 <dons> not 'stack' at all.
13:46:48 <dons> newPinnedByteArray#
13:46:52 * Beelsebob goes and stabs the people upstairs with the loud bassy music
13:46:53 <bos> then it's almost certainly slowing me down.
13:47:13 <dons> heap allocs are heap pointer bumps, of course. but still, not the same thing.
13:48:14 <dons> it would be interesting to do a safe alloc that made it a type error to leak the value out.
13:48:18 <dons> the pointer out.
13:48:25 <dons> seems like runST could really do that.
13:48:38 <sjanssen> I think Oleg has some work on that
13:48:44 <dons> yeah, monadic regions.
13:48:45 <olsner> sheyll: btw, if you import Data.Map qualified, you can also get rid of most of the module prefixes in your code
13:48:46 * SamB_XP gums up the works with a stray $
13:48:46 <sjanssen> you need an extended version of IO
13:48:56 <Elly> monadic religions?
13:48:57 <Myoma> I thought monadic regions was Shans stuff
13:49:26 <bos> oh wow, inlining Foreign.Marshal.Utils.with improved performance by 15% right off the bat.
13:49:55 <sheyll> olsner: ah ok.. that was bugging me. thanx for the hint :)
13:49:56 <quicksilver> inlining is everything, in GHC optimisations.
13:50:02 <luqui> :t ?f ?x ?y
13:50:04 <lambdabot> forall t t1 t2. (?y::t1, ?x::t, ?f::t -> t1 -> t2) => t2
13:50:05 <Heffalump> s/GHC/compiler/
13:50:07 <quicksilver> because the optimisations are based on static analysis of code forms.
13:50:09 <luqui> :t ?x `?f` ?y
13:50:11 <lambdabot> parse error on input `?f'
13:50:12 <luqui> boo!
13:50:15 <Myoma> :t \x -> ?b
13:50:17 <lambdabot> forall t t1. (?b::t1) => t -> t1
13:50:20 <quicksilver> and until you inline, that's not visible.
13:51:01 <sjanssen> with should probably have an {-# INLINE #-} on it
13:51:03 <bos> specialisation is often enough, though.
13:51:28 * luqui wishes ghc could do whole-program optimization without having to spew INlINE everywhere
13:51:41 <bos> really, what you want is a "specialise this to all types" directive that doesn't inline.
13:51:45 <sheyll>  "liftM (foldr f z . lines)  $  hGetContents h"   works greate thanks!
13:51:52 <SamB_XP> luqui: to do that, wouldn't it need to keep the whole program around ?
13:52:03 <luqui> yeah I think so
13:52:03 <SamB_XP> and maybe do less optimization when compiling each module?
13:52:06 <Myoma> sheyll: cool
13:52:09 <dons> bos, whoa. so missing an inline there?
13:52:10 <dons> hmm.
13:52:11 <ddarius> foldr f z . lines <$> hGetContents h
13:52:11 <sjanssen> luqui: usually GHC is pretty good at chosing things that ought to be inlined
13:52:17 <dons> we could be way more aggressive with inlining in Foreign.*
13:52:19 <bos> dons: the inline alone probably isn't enough.
13:52:28 <SamB_XP> dons: probably not a bad idea
13:52:29 <sheyll> :t <$>
13:52:31 <lambdabot> parse error on input `<$>'
13:52:33 <luqui> sjanssen, yeah, but every once in a while it isn't and you get a 400% speedup by inlining something manually
13:52:35 <Myoma> :t (<$>)
13:52:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:52:37 <bos> i still need to use RULES to get the pointer bump out of the inner loop.
13:52:47 <dons> yup
13:53:09 <sheyll> <$> is an infix liftM or fmap ?
13:53:10 <olsner> sheyll: you don't really have to muck about with hGetContents either; you can just readFile and send the (lazy!) string into the analysis function
13:53:14 <quicksilver> sheyll: yes.
13:53:38 <luqui> sheyll, specifically fmap
13:54:01 <luqui> which is the same as liftM assuming you're using monads which have functor instances (I hate the ones that don't!)
13:54:16 <olsner> (and as dons pointed out, you probably want to use bytestring instead of plain strings)
13:54:36 <sheyll> in a "do" block, if theres sth like "blah <- readFile", this will also be lazy, right?
13:55:00 <luqui> sheyll, because readFile returns a lazy string, yeah.
13:55:18 <sheyll> are there any non-lazy io functions?
13:55:25 <luqui> most of them.
13:55:36 <Beelsebob> which is a shame :(
13:55:37 <dmhouse> putStrLn, e.g.
13:55:44 <luqui> Beelsebob, it is?
13:55:48 <Myoma> hm
13:55:49 <dmhouse> That one pretty much has to be strict.
13:55:53 <sheyll> ok, but for input?
13:55:54 <Beelsebob> luqui: yes -- lazy IO is really easy, and made of win
13:56:07 <Beelsebob> luqui: remember, I'm an interact hugger
13:56:11 <luqui> Beelsebob, and semantic bullshit
13:56:13 <Myoma> In Java, everything (except some primitives) are in Maybe (because of null), and everything is in IO of course, and State
13:56:27 <luqui> Beelsebob, readFile really frightens me.
13:56:34 <Beelsebob> luqui: rubbish -- you just ignore the real world, and get on with it
13:56:35 <Beelsebob> :D
13:56:40 <olsner> but lazy IO requires unsafeInterleaveIO, right? is that really referentially transparent?
13:56:58 <Beelsebob> luqui: but... just read the entire file system lazily, and thread it about the app >.>
13:56:59 <Beelsebob> <.<
13:57:04 <luqui> olsner, unsafeInterleaveIO is fine if you believe in the "seeing into the future" ability of IO
13:57:07 <SamB_XP> olsner: ... technically
13:57:08 <Beelsebob> (we should be able to do that, and it would be awesome)
13:57:09 <Myoma> olsner: it doesn't mean you can't create referentially transparent things with it
13:57:59 <ddarius> It's referentially transparent I believe, but not pure a la Amr Sabry.
13:58:00 * luqui prefers not to believe in that ability, as it ruins reasoning properties nonlocally.
13:58:04 <quicksilver> Beelsebob: on the contrary, lazy IO is subtle, and made of fail.
13:58:25 <quicksilver> ddarius: it is possible to construct examples where unsafeInterleaveIO breaks referential transparency.
13:58:28 <Beelsebob> quicksilver: depends if you're in the mindset of lazy IO or not
13:58:39 <olsner> what happens of you mix hGetContents with other I/O functions on the same handle? couldn't you use that to side-effectually talk to your "pure" code?
13:58:40 <Beelsebob> it's subtle and difficult and faily if you think imperatively
13:58:53 <luqui> quicksilver, is it?  Even with nondeterministic IO semantics?
13:58:59 <Cale> quicksilver: It depends on your definition of referential transparency.
13:58:59 <sjanssen> "made of win/fail" somehow reminds me of newspeak
13:59:12 <SamB_XP> olsner: that IS fail
13:59:23 <SamB_XP> that is, you aren't supposed to DO that
13:59:24 <sjanssen> is memespeak the language of the future?
13:59:29 <luqui> sjanssen, yeah, it's plus win, but double plus fail
13:59:41 <quicksilver> Cale: "replacing a name by its definition always leads to the same result" ?
13:59:55 <FunctorSalad> > let epic_fail = fail
13:59:55 <lambdabot>  Parse error at end of input
13:59:56 <Beelsebob> sjanssen: hehe, bugger, you just put me off a phrase I use all the time
13:59:57 <sjanssen> luqui: double plus == epic, I think
14:00:02 <Beelsebob> because you just categorised it really nicely
14:00:06 <quicksilver> luqui: yes, because you observe the inconsistency in somethign with a pure type.
14:00:10 <olsner> wouldn't it work if your filesystem had semantics where opening a file read-only gives you a snapshot of its state when it was opened?
14:00:24 <SamB_XP> quicksilver: do you have such an example?
14:00:26 <quicksilver> olsner: for the specific case of readFile, yes.
14:00:34 <luqui> quicksilver, but the observation itself is not pure
14:00:36 <sjanssen> epic memespeak is made of win
14:00:37 <quicksilver> SamB_XP: it's slightly fiddly to construct correctly.
14:00:40 <monochrom> Hi, does anyone want basic haskell help? :)
14:00:47 <dons> heh monochrom yes!
14:00:48 <ddarius> sjanssen: Oh god
14:00:50 <SamB_XP> quicksilver: do you have a URL, at least?
14:01:00 <quicksilver> SamB_XP: you hide a writeIORef inside an unsafeInterleave
14:01:04 <dons> my hylomorphisms have been playing up all day, lol. help!
14:01:07 <SamB_XP> monochrom: yes, quicksilver does
14:01:08 <Cale> quicksilver: Well, once evaluated, the values resulting from unsafeInterleaveIO actions will remain the same. However, what they evaluate to can be nondeterministic in various ways.
14:01:25 <zandax> I am trying to do sometinh with HGL now. And I wonder how to load images
14:01:32 <zandax> bmp a = do (a, _) <- load "test.bmp" <- this is my approach so far :/
14:01:33 <sjanssen> lambdabot plugin idea: @memespeak to translate into this new dialect
14:01:33 <SamB_XP> he wants to know if unsafeInterleaveIO is referentially transparent or not
14:01:45 <Cale> For instance, you can produce a list of values which expresses the order in which each value is demanded.
14:01:55 <olsner> or maybe just if the filesystem provides referentially transparent read-only access with snapshot semantics when accessed outside of IO
14:01:57 <quicksilver> Cale: indeed, but referential transparency is stated at the level of syntactic substitution.
14:02:05 <ddarius> sjanssen: We don't need a translator into it.
14:02:10 <FunctorSalad> sjanssen: do want
14:02:18 <quicksilver> Cale: so notions of time (like 'once evaluated') are not quite hitting the nail squarely.
14:02:32 <monochrom> This one is tough. How about: different runs of the program gives different results.
14:02:35 * Myoma has reached that point in writing a program where it all starts to go awry
14:02:38 <luqui> quicksilver, indeed, you should come up with an equation that fails in the face of an unsafeInterleaveIO value
14:02:52 <ddarius> Myoma: The beginning?
14:03:04 <quicksilver> SamB_XP: I don't have a URL although I think there is a discussion floating around from some mailing list posting.
14:03:15 <Myoma> oh I'm not quite started the actual program I wanted to write yet
14:03:23 <luqui> but the thing is, that the IO on unsafeInterleaveIO looks into the future execution of *this instance* of the program.
14:03:28 <sjanssen> quicksilver: but you can't syntactically substitute unsafeInterleaveIO calls (nor any strict IO functions either)
14:03:51 <ddarius> Myoma: So before the beginning.
14:03:51 <SamB_XP> indeed
14:03:51 <luqui> so it could be different the next time around
14:04:12 <luqui> you might say that it's totally random, in a way that just happens to correlate to the evaluation order
14:04:14 <quicksilver> sjanssen: why can't you? you are always allowed to substitute.
14:04:19 <sheyll> I want to translate a logfile tool written in perl to haskell. The tool uses nested Hastables, which are updated as the log files are progressed. What data types should I use in haskell?
14:04:26 <quicksilver> let x = putStrLn "hello" in do x; x
14:04:32 <olsner> luqui: sounds like a case for a monadic fixpoint combinator!
14:04:34 <dmhouse> sheyll: Data.Map
14:04:43 <quicksilver> ^^ example when it's obviously sound to substitute the definition of an IO action.
14:04:48 <luqui> olsner, ?
14:04:58 <Cale> quicksilver: Because (unsafeInterleaveIO foo) is just an IO action, and surely at that level, nothing is breaking referential transparency, is it?
14:04:58 <luqui> olsner, I know what mfix is, I don't know what you're talking about.
14:05:05 <olsner> neither do I!
14:05:08 <quicksilver> Is it sufficient to say "augustss said so, and augustss is never wrong?" ;)
14:05:14 <SamB_XP> quicksilver: sure, you can substitute that
14:05:21 <sjanssen> quicksilver: I think you're making the wrong arguments against lazy IO
14:05:27 <SamB_XP> but you can't substitute the definitions of primitives
14:05:42 <SamB_XP> quicksilver: what is the definition of unsafeInterleaveIO ?
14:06:00 <dmhouse> ?src unsafeInterleaveIO
14:06:00 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
14:06:17 <luqui> SamB_XP, well, it should be whatever its denotation is in the model.  But... IO doesn't have one, so IO blows.
14:06:22 <monochrom> Oh haha, right.  do { x <- unsafeInterleaveIO readLn; y <- unsafeInterleaveIO readLn; return (x / y) }  This is sensitive to (/)'s evaluation order.
14:06:26 <sjanssen> quicksilver: the real problem is that the pure part of Haskell doesn't have operational semantics, and operational semantics are the most important thing with IO
14:06:47 <luqui> monochrom, but you could say that it's not, and that it's sensitive to the nondeterminacy of unsafeInterleaveIO
14:07:02 <sjanssen> monochrom has a good example there
14:07:12 <SamB_XP> luqui: my point is that quicksilver surely doesn't propose to substitute such junk into an expression -- especially given the implementation-specificity of unsafeInterleaveIO ...
14:07:23 <monochrom> Let's just agree it's sensitive to something :)
14:07:43 <ddarius> sjanssen, monochrom: Sensitivity to evaluation order is what Amr Sabry uses to define impure.
14:07:45 <olsner> luqui: I have a somewhat unclear thought on the relation between time travel and fixpoints waiting for a coherent expression, and your comment "looks into the future execution of *this instance* of the program." sounded like time travel
14:07:45 <luqui> unsafeInterleaveIO a -- executes a at some random future time
14:07:47 <FunctorSalad> what if we replace / by something symmetrical?
14:07:56 <SamB_XP> and probably doing so would work if he did ...
14:08:23 <quicksilver> SamB_XP: no, I certainly didn't mean to substitute that non-haskell mess :)
14:08:27 <luqui> is there anything non-referentially transparent about the above unsafeInterleaveIO description
14:08:27 <quicksilver> that would indeed be cheating.
14:08:45 <Heffalump> IO already isn't referentially transparent, is it?
14:08:53 <luqui> Heffalump, no, it is.
14:08:55 <SamB_XP> quicksilver: so where would this alleged violation of referential transparency occur?
14:08:56 <hackage> Uploaded to hackage: formlets 0.4.5
14:08:56 <hackage> Uploaded to hackage: formlets 0.4.4
14:09:04 <SamB_XP> Heffalump: sure it is
14:09:07 <Heffalump> well, IO actions are, but not when they run
14:09:08 <dmhouse> Woah, that was a quick revision of formlets.
14:09:09 <monochrom> Oh yikes, in the absence of a formal semantics of GHC goodies, we can violently agree with each other forever and still have "do we agree with each other?" computationally undecidable. :)
14:09:18 <luqui> Heffalump, I don't even know what you mean by that.
14:09:24 <Heffalump> neither do I :-)
14:09:40 <SamB_XP> Heffalump: referential transparency is probably not applicable to that which you speak of
14:09:48 <Heffalump> well, I mean that things of type IO a are freely substitutable just like any other Haskell value.
14:09:56 <SamB_XP> since I don't think it has to do with the value of an expression
14:10:42 <quicksilver> SamB_XP: I'll have to reconstruct that example. I'll let you know when I have :)
14:10:45 <Heffalump> but there's not much reasoning (substitution-based or otherwise) that you can do about what IO actions produce
14:10:59 <SamB_XP> Heffalump: quite so
14:11:10 <SamB_XP> but why would there be?
14:11:19 <luqui> quicksilver, please do remember the above random future time definition.
14:11:57 <luqui> I thought unsafeInterleaveIO wasn't ref trans at some point, but then that argument destroyed it.  I still think it's kind of a cop-out bullshit argument, but formally it's okay (as far as I can tell)
14:12:16 <dons> http://www.swoodhouse.com/reddit.hs.html <-- reddit in haskell, via WASH
14:12:16 <lambdabot> Title: reddit.hs.html
14:12:17 <dons> ?
14:12:21 <ddarius> luqui: Except that that isn't the semantics of unsafeInterleaveIO
14:12:34 <olsner> well, you can describe IO as functions RealWorld -> (RealWorld, a), or as generators of lists of syscalls
14:12:35 <luqui> unsafeInterleaveIO does not *have* semantics, because IO does not have semantics
14:12:48 <luqui> I mean denotational...
14:12:57 <quicksilver> the fact we haven't written down IO's semantics doesn't mean it odesn't have them.
14:13:00 <quicksilver> of course it has them.
14:13:16 <quicksilver> and if we weren't all fairly sure what they were, we wouldn't be able to program in haskell :)
14:13:18 <sclv> ok I know I should be offended, but this is actually sort of funny: http://www.reddit.com/r/programming/comments/6xkhm/haskell_is_an_obscure_and_mostly_disused_esoteric/
14:13:23 <lambdabot> Title: "Haskell is an obscure and mostly disused esoteric programming language named af ..., http://tinyurl.com/6z2c35
14:13:23 <luqui> oh right, I misread ddarius's comment
14:13:28 <ddarius> luqui: Yes, but to the extent that we do have semantics for them (either intuitively or how they are implemented) that is not the semantics.
14:13:32 <luqui> ddarius, can you come up with a counterexample?
14:13:46 <ddarius> luqui: A counterexample to what?
14:13:56 <luqui> to those not being the semantics of unsafeInterleaveIO
14:14:20 <dmhouse> sclv: I wouldn't be offended by anything on the Uncyclopedia ;)
14:14:27 <SamB_XP> I would be offended if that weren't an uncyclopedia entry
14:14:32 <ddarius> do unsafeInterleaveIO launchMissiles; exitSuccess;  -- launchMissiles never gets run
14:14:38 <dons> someone here wrote it, i'm sure :)
14:14:55 <luqui> ddarius, okay, amend that the future time might be never.
14:14:56 <dmhouse> “Haskell is compiled from .hs-files which means HOMO SEXUAL”- hah!
14:15:25 <luqui> dmhouse, yeah, that was a very clever creative one
14:15:56 <lament> @hoogle pSwitch
14:15:56 <lambdabot> No results found
14:15:58 <ddarius> do s <- unsafeInterleaveIO (readFile "foo"); writeFile "foo" "bar"; return s
14:15:59 <lament> hey!
14:15:59 <monochrom> "undetermined future time" is practically useless. no one uses it for that. every use is for a very well-known future time.
14:16:06 <luqui> lament, it's from Yampa
14:16:21 <luqui> monochrom, indeed, but it's consistent.
14:16:23 <sclv> it was sort of scary that I recognized what pSwitch did right away...
14:16:26 <lament> luqui: hee
14:16:41 <sheyll> how do I combine the Maybe monad and the IO monad?
14:16:44 <luqui> I'm trying to argue that unsafeInterleaveIO is semantically sound, if in kind of a bullshit way
14:16:49 * SamB_XP fixes the spelling of Wadler
14:16:49 <luqui> sheyll, using MaybeT?
14:16:56 <idnar> Zeta calculus, hah
14:16:56 <lament> SamB_XP: don't
14:17:03 <sclv> anyway I think the problem is that unsafeInterleaveIO plays funny with exceptions...
14:17:04 <SamB_XP> why not?
14:17:06 <sheyll> luqui: thanx
14:17:07 <dmhouse> That page is absolute genious.
14:17:08 <lament> SamB_XP: it's intentional...
14:17:15 <idnar> Zetabot: ping
14:17:15 <monochrom> I see. I support strongly that it is sound. :)
14:17:16 <luqui> sheyll, it's in the MaybeT package on hackage
14:17:16 <lament> SamB_XP: "waddle" is how ducks walk
14:17:16 <idnar> :P
14:17:38 <sclv> if IO functions always returned Maybe values then unsafeInterleave would be fine...
14:17:40 <monochrom> Hahahaha
14:17:40 <SamB_XP> lament: but won't it be funnier if the ignorant people are the ones who think it's misspelled?
14:17:50 <luqui> sclv, I don't follow
14:17:53 <idnar> SamB_XP: it links to Donald Duck
14:17:54 <lament> SamB_XP: that's already the case :P
14:18:13 <SamB_XP> I know it links to donald duck!
14:18:19 <sclv> x <- unsafeInterleaveIO $ throw "gotcha!"
14:18:19 <SamB_XP> how could I have missed that?
14:18:28 <olsner> sheyll: are you sure you need to combine Maybe and IO? (there's e.g. catMaybes that takes a list of Maybes and removes the Nothings - if the objective is to remove malformed log lines or something like that)
14:18:36 <SamB_XP> anyway I changed it -- you want it changed back, you know how to work mediawiki don't you?
14:18:58 <sclv> now I can pass x to any pure function and woosh -- an indeterminate exception in pure code.
14:19:17 <lament> SamB_XP: Uncyclopedia is already unfunny enough without you stripping any more jokes from it.
14:19:19 <luqui> sclv, but again, that was just unsafeInterleaveIO throwing an exception at a random time in the future
14:19:20 <olsner> x <- return (error "gotcha!") ?
14:19:25 <sheyll> olsner: catMaybes is cool
14:19:30 <dons> put some funnier jokes in.
14:19:31 <dmhouse> Huh, "rc" stands for "run commands". I always figured it was "runtime configuration".
14:19:34 <dons> we can do a much better job.
14:19:54 <SamB_XP> lament: honestly I personally think the joke is still there, just toggled
14:19:57 <sjanssen> (++ "!!") . (>> "AA") $ "Hello world !"
14:20:03 <sjanssen> > (++ "!!") . (>> "AA") $ "Hello world !"
14:20:05 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
14:20:08 <sjanssen> :)
14:20:12 <sclv> olsner -- but that gotcha will be evaluated when the IO action is executed, no.
14:20:21 <dons> http://www.reddit.com/r/programming/comments/6xkr2/a_window_into_monadic_io/
14:20:25 <lambdabot> Title: A window into monadic IO : programming, http://tinyurl.com/5q42lk
14:20:27 <sclv> the other way lets it "escape" into the wild, in disguise as a legitimate pure thunk.
14:20:43 <luqui> sclv, error "foo" is a pure thunk.
14:21:13 <luqui> > take 5 [1,2,3,4,5,6,error "nooo!"]
14:21:15 <lambdabot>  [1,2,3,4,5]
14:21:23 <luqui> > [1,2,3,4,5,6,error "nooo!"]
14:21:25 <lambdabot>  mueval: [1,2,3,4,5,6,*** Exception: nooo!
14:21:47 <sclv> oh, right... but all error gives you is a normal exception.
14:22:04 <sclv> it doesn't let you hide anything more interesting like "delete this file" or etc.
14:22:21 <luqui> sclv, so are you arguing the random future argument?
14:22:38 <luqui> because if you don't buy that, there are plenty of ways to say unsafeInterleaveIO is evil and non-RT.
14:22:46 <olsner> let id x = unsafeInterleaveIO (formatHardDrive >> return x)
14:23:01 <sclv> not sure I quite understand the random future argument.
14:23:34 <luqui> the semantics of unsafeInterleaveIO a is that it executes a at some random time in the future, maybe never.  And that random time just *happens* to correlate to the evaluation order of the thunks in your program.
14:23:48 * olsner tries to come up with something funny for the uncyclopedia article
14:24:19 <Myoma> real world #haskell is much funnier than that article
14:24:25 <monochrom> haha
14:24:47 <lament> Myoma: that's often true of Uncyclopedia.
14:24:51 <luqui> the @quote x for any x has a 90% probability of being funnier than that article
14:24:52 <lament> @quote
14:24:52 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
14:25:01 <mopped> CAn anyone tell me what a 'side effect' acctualy is? :P
14:25:07 <luqui> that probability going down the more @quote becomes saturated with metastereo quotes
14:25:16 <sclv> I guess that's reasonable -- I was more thinking about unsafeInterleaveIO for reading only (since its insane for anything else, generally) -- in which case I guess you could argue that it randomly introduces partiality.
14:25:25 <quicksilver> cale, SamB_XP, sjanssen: ah well, I can't reproduce it now, and it may have been a figment of too much caffeine.
14:25:39 <quicksilver> the general idea was unsafeInterleaved thunks which read and write to IORefs
14:25:51 <quicksilver> and a piece of code which has binding which might or might not be shared
14:25:59 <sclv> I.e. if you have something potentially failing at some time in the future, then the rest of the program is indeterminate as well, no, since you have no guarantee of ANYTHING executing afterwards.
14:26:06 <olsner> heh, but I think metastereo quoting has been going down lately... probably some fishy business like Cale editing the lambdabot state files
14:26:08 <FunctorSalad_> lament: on the other hand, the "article series on huffing" is among the greatest works of literature of our time
14:26:11 <quicksilver> and the sharing is observable because if the thunk gets not-shared, and evaluated more than once, the IORef increases more than once
14:26:23 <quicksilver> but I can't get it written down now so maybe I made a mistake last time :)
14:26:23 <luqui> sclv, yeah.  that's why that argument is kind of bullshit.
14:26:29 <luqui> semantically sound, but not useful.
14:26:35 <Myoma> mopped: sure
14:26:38 <SamB_XP> olsner: in a hexeditor?
14:26:45 <SamB_XP> @quote c-a-l-e
14:26:45 <lambdabot> No quotes match. That's something I cannot allow to happen.
14:26:49 <Myoma> mopped: can you name any procedural language you have used?
14:26:50 <monochrom> After accumulating much wisdom I define side effects thus: those that make your life complicated.
14:26:56 <olsner> hmm, aren't they just gzipped text?
14:27:03 <sclv> so the semantics of unsafeInterleaveIO is that it renders everything after its use undefined...
14:27:23 <sclv> @quote fugue
14:27:23 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:27:24 <Cale> olsner: The lambdabot state is astoundingly unreliable. It often just disappears on me.
14:27:26 <monochrom> Anyway why do functional programmers fear nondeterminism.
14:27:33 <sclv> ^^ we'll always have fugue.
14:27:34 <SamB_XP> sclv: only in C ;-)
14:27:37 <luqui> sclv, uh, practically yes.  Though that's not a very precise way to say it.
14:28:05 <olsner> side effect = spooky action at a distance
14:28:06 <luqui> but yeah, those semantics are about as useful as:  unsafeInterleaveIO a = do { r <- randomIO; if r then fail "oops" else a }
14:28:28 <mopped> Myoma: Python
14:28:37 <lament> once I wrote a programming language called Fugue
14:28:40 <sclv> well that sounds about right...
14:28:42 <monochrom> Yeah I like fugue. "majestic stereo" is lame. especially the "majestic" part which was the name of a canadian stereo chain store that no longer exists.
14:28:42 <luqui> monochrom, because it destroys the uniform reasoning properties that make haskell so wonderful to work with?
14:29:04 * luqui doesn't think he's heard fugue
14:29:29 <monochrom> Listen to a lot of Bach stuff. Also quite some of Mozart stuff.
14:29:35 <dmhouse> Now we need someone to say something interesting about fugue, so we can get metafugue quotes.
14:29:36 <lament> Hello World in fugue: http://www.esolangs.org/w/images/0/05/Hworld.png
14:29:43 <luqui> heheh, I mean the quote.
14:29:46 <luqui> I assume it's a quote.
14:30:18 <dmhouse> monochrom: you mean you've actually listened to some fugues, and not just read about them in GEB? :)
14:30:23 <lament> (one day, i'll learn to play that)
14:30:32 <FunctorSalad_> dmhouse: haha
14:30:38 <monochrom> Yes. GEB is a short story made long anyway.
14:30:52 <lament> I stopped reading GEB about 1/4 in.
14:31:10 <dmhouse> It's a great book, but you do have to drag yourself through some of the moring boring AI bits.
14:31:13 <lament> I started reading it as a little baby, and was an old man when I stopped.
14:31:19 <dmhouse> It's full of things to discover.
14:31:28 <monochrom> I guess philosophers and common people enjoy the indulgence in long-winded wording.
14:31:35 <dmhouse> Y.
14:31:56 * lament nods silently
14:31:59 <zandax> haha Vox
14:32:08 <zandax> sry, wrong window :/
14:32:18 * SamB_XP thinks it would be funnier to claim that Haskell is a dialect of Pascal
14:32:18 <lament> Mozart's fugues suck, though.
14:32:24 <lament> Paskell
14:32:47 <zandax> + Pastell gfx lib
14:33:08 <luqui> that hello world fugue is weird...
14:33:38 <lament> there's a midi
14:33:42 <lament> it sounds horrible on it
14:33:58 <lament> it should be possible to write a much better sounding hello world but nobody ever bothered
14:34:09 <dmhouse> In what way is it a hello world?
14:34:25 <lament> dmhouse: it is in the programming language Fugue
14:34:42 <monochrom> Oh God. Hahahahah
14:34:55 <lament> :D
14:35:02 <dmhouse> lament: yes, does it print "hello world" at any point?
14:35:07 <luqui> lament, is there a reason it's called "hello world"?
14:35:08 <monochrom> (Can you do recursion in Fugue?)
14:35:09 <lament> yep
14:35:16 <luqui> oh it's a program!
14:35:18 <luqui> woah...
14:35:27 <lament> http://www.esolangs.org/wiki/Fugue
14:35:28 <lambdabot> Title: Fugue - Esolang
14:35:31 <Jedai> sheyll: I put something on hpaste, I don't know if it does what you want, but it should be better than what you had
14:35:50 * luqui is a composer too.  maybe I'll write a better one :-)
14:36:03 <dmhouse> That is awesome.
14:36:03 <zandax> you're composing? :)
14:36:29 <dmhouse> So the transitions between notes compile down to Prelude, which is a traditionally input programming language?
14:37:06 <lament> more or less traditional; Prelude still has the concept of several simultaneous "voices" (coroutines i suppose)
14:38:00 <zandax> Can somebody explain me how I load a global (!) image with HGL? The prototype is: "load :: String -> IO (Bitmap, (Int, Int))"
14:38:27 <dmhouse> zandax: looks like do (img, (x,y)) <- load "filename"
14:38:33 <dmhouse> I presume x and y are the size of the image.
14:38:44 <zandax> But how do I design the monad?
14:38:51 <dmhouse> Or rather, do (img, (x,y)) <- load "filename"; stuff with img
14:38:51 <monochrom> main = do { (img, (x,y)) <- load "filename"; putStrLn "goodbye!" }
14:39:02 <zandax> but how do I declare it global? :/
14:39:02 <dmhouse> zandax: that question makes little sense.
14:39:09 <Lemmih> zandax: You don't.
14:39:11 <monochrom> No global.
14:39:20 <FunctorSalad_> zandax: you can't get the image out of the IO monad, if that helps
14:39:38 <zandax> But I don't want it to pass it to my drawing functions. They're becoming too complex.
14:39:48 <dmhouse> ?hoogle setIORef
14:39:49 <lambdabot> No results found
14:40:11 <monochrom> Approach your task differently.
14:40:21 <SamB_XP> so -- lament made prelude?
14:40:39 <dmhouse> zandax: you can use IORefs as a global state.
14:40:56 <olsner> hmm, ironically, the second code example on the uncyclopedia page is actually more useful than the fake hello world program
14:41:15 <zandax> never heard about IORefs :(
14:41:47 <SamB_XP> olsner: fake hello world?
14:42:01 <olsner> > (++ "!!") . (>> "AA") $ "Hello world !"
14:42:03 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
14:42:08 <lament> SamB_XP: I created Prelude and Fugue but I didn't write that Hello World
14:42:10 <SamB_XP> oh
14:42:20 <SamB_XP> heh
14:42:32 <dmhouse> lament++
14:42:34 <dmhouse> It's a great idea.
14:42:40 <SamB_XP> but it's way more fun than a real hello world ;-)
14:42:50 <dmhouse> Getting the programs to sound good might be quite artistically challenging, thought.
14:43:16 <lament> there's quite a bit of freedom
14:43:28 <olsner> but there should be a way to write hello world such that it's fun too... maybe find a polynomial for the ascii sequence or something
14:43:32 <lament> it should be quite doable, nobody just really bothered
14:43:52 <SamB_XP> lament: maybe you should update the links in http://www.esolangs.org/wiki/Prelude ?
14:43:53 <lambdabot> Title: Prelude - Esolang
14:45:00 <sampointon> I wonder what the output of running Bohemian Rhapsody would be
14:45:28 <luqui> probably a syntax error
14:45:31 <FunctorSalad_> lament: I'm no composer, but maybe a step would be to only have short sequences that sound not that bad as valid programs
14:45:48 <luqui> oh wait, no syntax errors, it's like brainfuck
14:46:08 <olsner> it'd be interesting to take a largeish collection of popular songs and run them through fugue and see if any song does something useful
14:46:19 <SamB_XP> luqui: what about simultaneous (/) ?
14:46:26 * monochrom runs the full Ring cycle through it :)
14:46:27 <FunctorSalad_> olsner, sounds unlikely...
14:46:52 <FunctorSalad_> unless the language is unusually error-tolerant
14:46:55 <sampointon> olsner: useful, I doubt. Funny or strange, almost certainly
14:47:09 <luqui> SamB_XP, hmm?
14:47:41 <SamB_XP> you aren't allowed more than one ascending/descending fifth at a time
14:47:59 <lament> no parallel fifths! :D
14:48:06 <lament> ...almost
14:48:23 <lament> luqui: brainfuck can have syntax errors
14:48:45 <lament> [ ] have to be matched
14:49:11 <xif> hi. it's pretty simple to understand how a binary function foo() can be turned into an infix operator with `foo`. but how does infixing work for other functions?
14:49:25 <xif> e.g. ones with a single argument, or three or more arguments.
14:49:26 <luqui> ah right
14:49:35 <olsner> hmm, yeah, maybe the odds are hard enough that it's not worth it to spend the work setting up the giant music pipe to (probably) see nothing happen
14:49:40 <zandax> I don't find references to SetIORef :(
14:49:57 <monochrom> Hi, please don't write "foo()", please write "foo". :)
14:50:07 <slava> dons: let's play, "guess the reddit user"
14:50:08 <slava> "i just dont get your anti-haskell attitude. why do you hate it so much? you probably just dont truly understand the language. but thats what you get when all you really know is java."
14:50:13 <Jedai> zandax: Why don't you just search IORef in hoogle ?
14:50:18 <Jedai> @hoogle IORef
14:50:18 <lambdabot> Data.IORef data IORef a
14:50:18 <lambdabot> module Data.IORef
14:50:18 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:50:21 <monochrom> Single argument functions can't be helped.
14:50:35 <xif> monochrom: OK, how about ones with 3 or more?
14:51:08 <monochrom> Three-argument functions are treated thus:  You can write "(x `foo` y) z" for "foo x y z".  Generalizes to more arguments.
14:51:09 <int-e> xif: a 3 argument function is a binary function that returns a single argument function
14:51:09 <zandax> Found it, thank you.
14:51:09 <mmorrow> http://uncyclopedia.org/wiki/Brainfuck
14:51:10 <lambdabot> Title: Brainfuck - Uncyclopedia, the content-free encyclopedia
14:51:13 <FunctorSalad_> xif: split it into two function and a dummy type for the intermediate result?
14:51:16 <sampointon> xif: should work, they're (a -> b -> (c -> d))
14:51:19 <mmorrow> @bf
14:51:20 <lambdabot> Done.
14:51:23 <mmorrow> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
14:51:23 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
14:51:30 <int-e> @bf ]
14:51:30 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
14:51:37 <mmorrow> @bf <<+++++++++++++++.>.
14:51:37 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
14:51:40 <mmorrow> crap
14:51:45 <Jedai> zandax: anyway are you sure that you need "global" ? For example if you are passing a set of image you then need, you just can create a record type which contains all images of interest and pass that around
14:51:55 <slava> brainfuck is concatenative right?
14:52:02 <zandax> But it seems that my approach is wrong. I have a couple of images I want to load and draw in other functions.
14:52:02 <xif> monochrom, int-e, FunctorSalad_, sampointon: cool, thanks.
14:52:31 <lament> slava: brainfuck is imperative
14:52:40 <slava> right, but it uses an operand stack?
14:52:46 <lament> no
14:53:01 <slava> ok
14:53:27 <lament> all instructions are zero-argument
14:53:32 <monochrom> May I say, lambdabot's brain is fucked...  (duck) :)
14:53:38 <sampointon> oh, speaking of concatenative languages: what's a more natural primitive, pick or swap?
14:53:42 <slava> ah i see how it works
14:53:43 <FunctorSalad_> @slap monochrom
14:53:44 <lambdabot> go slap monochrom yourself
14:53:48 <monochrom> hehe
14:53:49 <FunctorSalad_> meh.
14:53:49 <slava> sampointon: what is 'pick'?
14:53:58 <kpreid> brainfuck is basically while loops over a turing tape
14:54:17 <sampointon> slava: pop a value at an arbitrary position off the stack, and put it on the top
14:54:30 <slava> sampointon: pick ( ... n -- stack[n] ) ?
14:54:39 <Jedai> zandax: I'm not sure I understand your problem, but guessing I had a game where a certain number of images must be redraw over and over, I would probably place them in a record type "GameImages" create an initialization function and then pass a graph value around
14:54:39 <slava> sampointon: well, i'm not sure which one is more 'primitive'
14:54:57 <slava> swap is certainly simpler to implement; depending on your forth it might be one instruction, xchg [esp],eax
14:55:14 <lament> swap is implementable in terms of pick, but not the other way around
14:55:20 <slava> swap is not implementable with pick
14:55:28 <slava> pick copies an element but it doesn't delete it
14:55:28 <sampointon> lament: well, it's swap + dip, really
14:55:49 <lament> slava: then swap is still implementable with it, you just need to know the depth of the stack :)
14:56:07 <slava> a minimal basis is over, drop, dip, curry, call
14:56:26 <SamB_XP> lament: what?
14:56:29 <slava> swap is over [ [ drop ] dip ] dip
14:56:45 <zandax> @Jedai: Sounds interesting.
14:56:46 <lambdabot> Unknown command, try @list
14:56:58 <FunctorSalad_> zandax: maybe this will help? it essentially helps you in passing something around to everything http://hackage.haskell.org/packages/archive/mtl/1.1.0.1/doc/html/Control-Monad-Reader.html
14:56:59 <lament> SamB_XP: make a copy of everything on the stack. Swap the top elements.
14:56:59 <lambdabot> Title: Control.Monad.Reader, http://tinyurl.com/5v9upa
14:57:19 <slava> lament: you can implement pick using arithmetic operations, dup, swap, and dip
14:57:21 <FunctorSalad_> zandax: but I'm a noob with that Monad too
14:57:36 <SamB_XP> lament: wouldn't that have a certain tendancy to double the size of the stack ?
14:57:44 <slava> : pick dup 0 = [ drop dup ] [ 1- swap [ pick ] dip swap ] if ;
14:57:45 <zandax> I'll have a look at it :|
14:58:04 <FunctorSalad_> zandax: your "r" parameter would be the image(s)
14:58:06 <int-e> slava: what is dip?
14:58:19 <slava> int-e: [ foo ] dip is joy's equivalent of forth's >r foo r>
14:58:44 <lament> SamB_XP: sure it would!
15:00:15 <glguy_> dons: coming?
15:01:05 * SamB_XP lols at HowTo:Divide_by_Zero
15:01:10 <slava> glguy_: your disjoint-sets library is very useful to me now; i'm glad you contributed it back in the day
15:01:12 <RayNbow> hmm... http://www.reddit.com/r/programming/comments/6xjrl/real_world_haskell_the_last_chapter_is_up_and/c054yww <-- that would be awesome :p
15:01:14 <lambdabot> Title: samlee comments on Real World Haskell: the last chapter is up, and ... we're don ..., http://tinyurl.com/5umspw
15:01:25 <ddarius> SamB_XP: It can be tricky in some cases.
15:02:14 <ddarius> Congratulations dons, bos, and CosmicRay (in spirit).  You have fan bois.
15:02:40 <SamB_XP> ddarius: I'm loling at the statement that people have been unable to get past the zillions of warning dialogs to open calc.exe in vista ;-P
15:03:04 * ddarius has never really used Vista.
15:04:26 <solrize> yah!!!!!!!!
15:04:36 <solrize> hooray dons/bos/cosmicray!!!
15:04:36 <dmhouse> ?yow
15:04:36 <lambdabot> Couldn't find fortune file
15:04:43 <FunctorSalad_> @huff
15:04:44 <lambdabot> Unknown command, try @list
15:04:45 <dmhouse> ?ask Cale to fixify ?yow :(
15:04:46 <lambdabot> Consider it noted.
15:05:09 <matthew-_> YAY! My linear hash table works!
15:05:16 <matthew-_> that was only two days of immense pain
15:05:23 <matthew-_> and writing C-like code in Haskell
15:05:54 <slava> matthew-_: like the language shootout?
15:06:28 <solrize> the comments in the new chapter are messed up
15:06:34 <matthew-_> slava: no idea. The code isn't pretty. But dealing with raw pointers all over files is never pretty
15:06:54 <slava> raw pointers are teh suck
15:06:54 <TomMD> solrize: they noticed and are using the comments anyway.  Two chapters are flipped or something.
15:07:04 <solrize> yeah
15:09:08 <matthew-_> slava: yeah, but if you want it to go fast...
15:09:45 <matthew-_> besides, when dealing with on disk structures, there's little choice
15:26:02 <sclv> anybody know of any "in the wild" haskell work that uses rpcs, distributed processing, etc?
15:26:32 <sclv> or for that matter, libraries with actual production uses supporting a worker/supervisor thread model?
15:32:57 <monochrom> 700 pages is very thick!
15:33:12 <dobblego> that's 700 pages of golden goodness
15:33:15 <ddarius> monochrom: It's about typical for a programming book.
15:33:39 <monochrom> You can tell that I have never read a typical programming book. :)
15:34:06 <monochrom> Oh I lied. I read one or two Eclipse books and a Java Swing book.
15:34:22 <TomMD> Owch! Owch!  The first programming book I failed to read was a Java book.
15:37:21 <jberryman> is there a standard module for representing and evaluating a numerical expression in tree (or whatever) form?
15:38:28 <mmorrow> quicksilver: your talk of IORefs and unsafe*IO made me think of this: http://hpaste.org/9853
15:38:44 <mmorrow> (think of as in recall)
15:39:09 <therp> "Code You Can Believe In" :)
15:39:53 <chadz> hey -- why does "decode . encode $ <Network.IRC.function>" always return Nothing?
15:40:21 <mmorrow> what (decode . encode) are those?
15:40:35 <jberryman> I wrote a module to do some parsing and conversion of expressions in infix and RPN notation and used exlicit Float for everything at first and have been banging my head on the wall trying to make it represent operands as Num a
15:40:36 <chadz> Network.IRC.Parsing ?
15:40:43 <monochrom> why are you encoding a function?
15:40:50 <mmorrow> chadz: hmm, i'm not familiar
15:40:55 <chadz> mmorrow: http://hackage.haskell.org/packages/archive/irc/0.4/doc/html/Network-IRC-Parser.html#v%3Adecode
15:40:57 <lambdabot> Title: Network.IRC.Parser, http://tinyurl.com/62jebq
15:41:35 <chadz> monochrom: not a function, that's just a placeholder for some operation such as 'nick', 'user', etc.
15:41:39 <chadz> ie,
15:41:53 <mmorrow> chadz: err, where is encode ?
15:42:10 <mmorrow> or what is it doing exactly?
15:42:16 <chadz> decode . encode $ user "chadz"    = Nothing
15:42:24 <chadz> http://hackage.haskell.org/packages/archive/irc/0.4/doc/html/Network-IRC-Base.html#v%3Aencode
15:42:25 <lambdabot> Title: Network.IRC.Base, http://tinyurl.com/68tast
15:42:30 <chadz> encode :: Message -> String
15:42:43 <monochrom> is (user "chadz") a Message?
15:42:55 <chadz> Yes.
15:43:31 <monochrom> I'm sorry?  The doc says no.
15:43:40 <chadz> well, for accuracy, subsitute nick for user
15:44:04 <monochrom> Then I don't know.
15:44:08 <thou> hi, all.  i'm getting the wrong results when using FFI to read info from a C structure; details are at http://hpaste.org/9854 -- would someone be able to take a look?
15:44:14 <chadz> monochrom: semantics. you realize it wouldn't return 'Nothing' if the parameters didn't match ;)
15:46:19 <thou> i suspect it might have something to do with the short int which is the first member of the MEVENT struct.  or maybe it's just that i don't understand what i'm doing 100% :-)
15:46:32 <jberryman> ...as usual a little googling turns up help. GADTs will help me I think.
15:46:49 <mmorrow> jberryman: you probably want to parse it to an abstract data type (which w/out mutable vars is a tree in haskell), then fold it when you want to eval
15:47:00 <mauke> thou: why isn't there a Storable instance for MouseEvent?
15:47:42 <mauke> and wtf is going on with preflex
15:47:47 <thou> mauke: that's probably a good question.  i'll do some research to understand it, and then perhaps have an answer.  :-)
15:48:03 <mmorrow> data Exp a = Val a | Op Exp Op Exp                data Op = Add | Sub | Mul | Div
15:48:04 <mauke> is MouseEvent part of hscurses?
15:48:21 <thou> mauke: yes, it's useless at the moment though
15:48:30 <mmorrow> jberryman: fun stuff
15:48:32 <thou> never gets used or filled in
15:48:42 <mmorrow> jberryman: (re: GADTs)
15:49:55 <thou> the hscurses-1.4 version on hackage and the darcs version from stefan both have the same incomplete mouse code
15:50:00 <mmorrow> jberryman: you may be interesting in this one package on hackage called 'calc'. it compiled arithmetic expressions to machine code (i've only looked, never touched) :)
15:50:10 <mmorrow> s/compiled/compiles/
15:50:39 <Myoma> ?hackage calc
15:50:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/calc
15:51:08 <Myoma> o_O
15:51:14 <Myoma>         generate x | EInt y   <- x = gconst y
15:51:14 <Myoma>                    | Add      <- x = gadd
15:51:14 <Myoma> ...
15:51:22 <Myoma> such an odd way to program
15:51:32 <AlexSuraci> Any ideas why I'd be getting this in ghci?: http://paste.pocoo.org/show/g9RBgR3KC2lDXsaOgzOI/
15:51:59 <dmhouse> Abuse of pattern guards ftw!
15:52:00 <mauke> AlexSuraci: a = "foo" is an invalid expression
15:52:04 <monochrom> Hi, you have to say: let a = "foo"
15:52:10 <AlexSuraci> Well, it's doing it on anything
15:52:14 <AlexSuraci> Even if I copy and paste
15:52:22 <AlexSuraci> That's just me being stupid, just getting into Haskell now. :P
15:52:23 <luqui> lament, so you made prelude?
15:52:40 <thou> AlexSuraci: try pasting into a text document, and then compiling that from the command line
15:52:40 <AlexSuraci> Using "let" works, weird.
15:52:51 <chadz> oh, that's why
15:52:57 <monochrom> ghci prompt != source code file
15:52:59 <chadz> it expects a newline/carriage return.
15:53:03 <chadz> stupid stupid
15:53:26 <dobblego> slava, nice one @ reddit ;)
15:53:26 <AlexSuraci> monochrom: Guess so, thanks. Would I be able to just run those as .hs files?
15:53:38 <dmhouse> AlexSuraci: think of input to GHCi as being inside a do-block, except any nonmonadic values are automagically returned.
15:53:41 <monochrom> Yes, a="foo" is valid in .hs files
15:53:46 <dmhouse> (Non-IO values, that is.)
15:53:55 <slava> why doesn't ghci permit type definitions at the top level?
15:54:07 <AlexSuraci> Thanks for the help. :)
15:54:21 <jberryman> mmorrow: thanks for the tips, will check out 'calc'. ghc couldn't figure out what I was trying to do with types in the tree representations I was playing with. will report back when I finish.
15:54:39 <mmorrow> jberryman: good luck ;)
15:54:58 <jberryman> thx
15:55:34 <monochrom> The same reason why Vista is resource-intensive.  Started out that way a long time ago for whatever reason, and now too late to re-architect.
15:56:15 <dmwit> slava: It does.
15:56:36 * luqui waits with bated breath for dmwit's follow-up
15:56:38 <mauke> ‽
15:56:44 <monochrom> But hey, a C++ prompt is hard to come by, too. :)
15:56:52 <mauke> for some reason preflex just stopped seeing responses from the IRC server
15:57:00 <Myoma> /query geordi
15:57:06 <dmwit> slava: Err, hum.
15:57:11 <mauke> it got the MOTD and everything, sent JOIN commands, and ... nothing
15:57:13 <Myoma> not so hard, monochrom
15:57:19 <dmwit> slava: I thought I remembered doing it with :{ before, but now I can't remember how.
15:57:37 <mauke> the IRC server obviously saw the JOINs, though
15:57:56 <mauke> and now that the connection was closed, preflex died with: <stderr>: hPutStr: illegal operation (handle is finalized)
15:58:05 <dmwit> slava: Although, you can certainly do "let foo :: a; foo = undefined" at ghci prompt.
15:58:28 <luqui> @ask lament I can't quite interpret the rules for Prelude, and the draft spec is 404d.  Do you have a copy of the spec somewhere?
15:58:28 <lambdabot> Consider it noted.
15:59:22 <lament> luqui: sorry
15:59:22 <lambdabot> lament: You have 1 new message. '/msg lambdabot @messages' to read it.
15:59:25 <lament> one moment
16:01:36 <lament> luqui: dcc?
16:01:47 <luqui> yeah I got a mysterious box I've never seen before
16:01:59 <luqui> but it does nothing when I push accept
16:02:20 <luqui> email?  lrpalmer gmail com
16:03:22 <lament> gr
16:04:01 <monochrom> firewall blocks half of dcc
16:04:34 <monochrom> (the half where you press "accept" :) )
16:05:18 <lament> dcc almost never works :(
16:06:10 <monochrom> It doesn't help that dcc is weird and do certain things the reverse way of what you expect.
16:07:42 <luqui> lament, or you could just answer my question.  Does each voice have a separate "instruction pointer", or do all the voices jump simultaneously when a () block jumps?
16:08:49 <luqui> I'm guessing that they are all separate... but that seemed kind of contrary to the idea.
16:09:07 <mauke> preflex: list
16:09:07 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
16:09:23 <lament> luqui: all voices jump simultaneously
16:09:31 <luqui> oh good (kinda) :-)
16:09:40 <lament> luqui: there's a Python interpreter at http://esoteric.voxelperfect.net/files/prelude/
16:09:59 <luqui> yay, the esolang link was also 404
16:11:07 <dmwit> preflex: 8ball
16:11:08 <preflex>  without a doubt
16:11:19 <dmwit> preflex: 8ball Should I answer the phone?
16:11:20 <preflex>  better not tell you now
16:11:23 <Myoma> preflex 8ball
16:11:23 <preflex>  reply hazy, try again
16:11:27 <Myoma> preflex 8ball
16:11:28 <preflex>  very doubtful
16:11:46 <mauke> hmm, maybe I should check for an empty argument list
16:11:58 <Myoma> preflex 8ball!
16:15:24 <chrisdone> preflex: 8ball THEN WHO WAS PHONE?
16:15:25 <preflex>  it is certain
16:20:58 <thou> hmmm, i changed MouseEvent to use CShort for the id member, and now it always shows up as 0, no matter where I click
16:21:05 <ski> slava : probably the same reason it doesn't really allow normal value definitions at the top-level
16:21:21 <Saizan> mauke: does preflex's seen try to track people when they change nick?
16:21:28 <mauke> Saizan: no
16:21:31 <slava> ski: it sort of limits its usefulness
16:21:37 <ski> (it does support `let foo = 42' et.c. but that's because that's allowed in a `do'-block)
16:21:54 <ski> and the reason is that it is not clear how to handle recursive definitions
16:21:57 <ski> should
16:22:08 <ski>   data Foo = X Bar
16:22:17 <ski> complaing about `Bar' not being defined ?
16:22:25 <ski> or wait until `Bar' is defined ?
16:22:40 <ddarius> hbci did all this.
16:22:50 <ski> slava : aye, it does
16:22:57 <ski> ddarius : in what way ?
16:23:12 <Saizan> multiline code blocks?
16:23:39 <ddarius> If my sources are correct, hbci accepted the full language hbc did.  I'm not sure how it handled mutual recursion.
16:24:33 <ski> @seen augustss
16:24:34 <lambdabot> I haven't seen augustss.
16:25:25 <mauke> preflex: seen augustss
16:25:25 <preflex>  augustss was last seen on #haskell 3 days, 1 hour, 35 minutes and 31 seconds ago, saying: Cale: there's a new version of djinn in case you want to update the bot.  Nothing exciting, just various little fixes.
16:26:14 <Cale> dons: Will the book stay online even once the beta is over?
16:26:32 <thou> changing x,y,z :: CInt doesn't help
16:29:10 <wadcom> hi, got a profiling question: http://hpaste.org/9855
16:29:39 <mauke> preflex: 8ball
16:29:39 <preflex>  what
16:29:50 <Cale> mauke: hehe, I like that response :)
16:29:57 <Myoma> preflex: what
16:30:01 <Heffalump> wadcom: enable-library-profiling just sets up the library to be linked against a profiling executable
16:30:05 <Heffalump> it doesn't actually enable profiling in it
16:30:39 <mauke> diagnostic messages inspired by ed
16:30:43 <wadcom> Heffalump: ...ok, how do I enable profiling in it? I build it along with the binary
16:31:00 <Heffalump> I'm not sure - I remember running into this problem myself, but I forget what I did.
16:32:08 <Heffalump> --ghc-options="-prof -auto-all" maybe
16:32:29 <Heffalump> in fact just -auto-all since -prof will already come from --enable-library-profiling
16:32:35 <wadcom> Heffalump: thanks, will give it a shot now
16:34:31 <dcoutts_> @seen gwern
16:34:31 <lambdabot> gwern is in #xmonad, #haskell and #darcs. I last heard gwern speak 3h 26m 39s ago.
16:35:02 <dcoutts_> @tell gwern ok, should be fixed now. Discovered the other problem and actually tested it this time ;-)
16:35:03 <lambdabot> Consider it noted.
16:36:30 <noecksit> @instances Reader
16:36:31 <lambdabot> Couldn't find class `Reader'. Try @instances-importing
16:36:51 <mauke> @help instances-importing
16:36:52 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
16:37:05 <Myoma> weird
16:37:09 <mauke> @instances-importing Control.Monad.Reader MonadReader
16:37:10 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
16:37:23 <noecksit> @info Reader
16:37:23 <lambdabot> Reader
16:37:28 <Myoma> <module>*   isn't clearer than   [<module> [<module> [<module...]]] ?
16:37:51 <mwc> Heh, another new monad tutorial... am I the last person who hasn't written one?
16:38:05 <Myoma> mwc: I didn't write one
16:38:07 <Heffalump> I haven't written one.
16:38:14 * wadcom neither
16:38:36 <Heffalump> well, I did write a few slides about them as part of a course on Haskell, but only about using them
16:38:59 * ski was tempted to say he is a monad tutorial
16:39:08 <mauke> noecksit: there is no @info
16:39:12 <noecksit> well, if I have two ReaderT MyEnv IO types, what is their common instance?
16:39:24 <ddarius> You are only a monad tutorial for the Reader monad
16:39:41 <noecksit> or maybe actually common class
16:39:49 <noecksit> ddarius: probably good idea
16:40:18 <ski> (s/he/ski/)
16:41:19 <dbueno> @seen dcoutts
16:41:19 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts speak 6h 53m 20s ago.
16:41:23 <noecksit> ooh, probably MonadReader
16:41:25 <dbueno> @seen dcoutts_
16:41:25 <lambdabot> dcoutts_ is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts_ speak 6m 22s ago.
16:41:30 <dcoutts_> hia dbueno
16:41:46 <dcoutts_> dbueno: btw, for some reason I couldn't apply your simple spelling patch
16:42:02 <dbueno> dcoutts_ Hey.  I know I've been kinda MIA lately, but, I have a question about Cabal.
16:42:15 <dcoutts_> it didn't appear as an attachment to the email, and darcs choked when I tried feeding it the email directly
16:42:20 <dcoutts_> dbueno: shoot
16:42:24 <dbueno> dcoutts_ Oh, really?  Hm, I created it with `darcs send -o', or whatever the flag is to get the output to a file.
16:42:54 <dbueno> dcoutts_ All right, I'll resend as an attachment.  Maybe some email encoding munged it.  Though it sounds really odd.
16:42:56 <dcoutts_> dbueno: right, the whole thing appeared inline, where normally it's an attachment
16:43:19 <dcoutts_> dbueno: anyway, you had a question
16:43:20 <mwc> is there a lib for accessing locally-stored mail? (Mbox,Maildir) Can't spot anything on hackage
16:43:21 <dbueno> dcoutts_ Um, is there a way to get a list of _all_ (transitive) dependencies associated with an _installed_ package?
16:43:30 <dcoutts_> dbueno: yes
16:43:34 * dcoutts_ looks it up
16:43:39 <qwr> noecksit: yes, but MonadReader is type constructor, not a type ;)
16:43:51 <dcoutts_> dbueno: so start with a PackageSet InstalledPackageInfo
16:43:59 <dbueno> dcoutts_ I'm writing some code for the funsat backend, and I need something for that.  I'm almost happy with how the debugging looks for this problem, which is good news
16:44:23 <qwr> noecksit: (or Reader)
16:44:25 <dcoutts_> dbueno: then use dependencyClosure
16:44:52 <dcoutts_> dbueno: dependencyClosure takes the package set and a list of roots, so in your case just the one.
16:45:10 <dbueno> dcoutts_ Is PackageSet the new PackageIndex?
16:45:27 <sw17ch> the uncyclopedia page on Haskell is hilarious
16:45:42 <dcoutts_> dbueno: yep, there's still Index, but it's only for case insensitive package name lookups now really
16:46:06 <dbueno> dcoutts_ Okay, I'm not sure the last time I pulled patches to the repo in which I'm doing the funsat backend.
16:46:11 <mwc> ooh, dons, have you seen http://www.reddit.com/r/programming/comments/6xl16/jon_harrop_makes_a_sock_puppet_reddit_user/
16:46:13 <dcoutts_> dbueno: oh, though if you're doing this code in cabal-install, it's still using Cabal-1.4 which uses PackageIndex, and the dep closure operation is there too
16:46:13 <lambdabot> Title: Jon Harrop makes a sock puppet reddit user account to promote F# and his consult ..., http://tinyurl.com/64optm
16:46:38 <dbueno> dcoutts_ Cool.  Yeah, I'm using Cabal 1.4.
16:46:38 <sw17ch> @index fix
16:46:40 <Myoma> #haskell-blah blah blah
16:46:40 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
16:46:49 <dcoutts_> dbueno: it can return Right if the dependency closure isn't, er closed.
16:46:53 <sw17ch> @index (<$>)
16:46:53 <lambdabot> bzzt
16:47:04 <dbueno> dcoutts_ Right, but for an installed package it should be cool, right?
16:47:10 <dcoutts_> dbueno: ie installed packages with missing dependencies.
16:47:27 <chrisdone> :hoogle (Monad m, MonadPlus m1) => m (m1 a) -> m (m1 a) -> m (m1 a)
16:47:42 <dcoutts_> dbueno: but you probably do not need to deal with that because we filter out broken packages before we pass them on to the dep resolver.
16:47:46 <chrisdone> @hoogle (Monad m, MonadPlus m1) => m (m1 a) -> m (m1 a) -> m (m1 a)
16:47:46 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
16:47:46 <lambdabot> Control.Applicative <|> :: Alternative f => f a -> f a -> f a
16:47:46 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
16:47:51 <sw17ch> http://uncyclopedia.org/wiki/Haskell
16:47:52 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
16:47:58 <luqui> :t liftM2 mplus
16:47:59 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
16:48:03 <sw17ch> @type fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
16:48:05 <lambdabot> forall a. (Num a) => [a]
16:48:21 <dcoutts_> dbueno: see hideBrokenPackages in Distribution.Client.Dependency
16:48:22 <chrisdone> an operator that did this would be nice
16:48:38 <dbueno> dcoutts_ Ah, right.  Cool.
16:48:41 <dcoutts_> dbueno: there's also a full on dependencyGraph operation
16:48:52 <luqui> chrisdone, you mean an infix operator?
16:49:08 <chrisdone> yes.
16:49:28 <noecksit> qwr: is it? i thought it was a class
16:49:39 --- mode: irc.freenode.net set +o ChanServ
16:50:12 <luqui> I think it would be nice to be able to succinctly lift infix operators
16:50:21 <dcoutts_> dbueno: the dep graph discards deps on missing packages, which as I say, should be safe by the time you see it
16:50:24 <luqui> so I could say  foo `liftM2 mplus` bar or something...
16:51:02 --- mode: irc.freenode.net set +o ChanServ
16:51:04 <dcoutts_> dbueno: so how's the hacking going? do you think cabal-install might gain another resolver?
16:51:17 <qwr> noecksit: ok, it's type class constructor ;)
16:51:31 <r3m0t> sw17ch: why all that
16:51:48 <sw17ch> http://uncyclopedia.org/wiki/Haskell
16:51:49 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
16:51:53 <sw17ch> r3m0t, ^^
16:51:56 <qwr> noecksit: but it has parameters, so it isn't directly a type class
16:51:58 <r3m0t> > iterate (*2) 1
16:52:00 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:52:01 <sw17ch> very funny
16:52:12 <dcoutts_> dbueno: btw, you know another good use case if your resolver is likely initially to be complete (ie unlike mine) but have terrible error messages, is to use it during hackage uploads to reject packages that we can prove cannot possibly be installed.
16:52:36 <dcoutts_> dbueno: mine is not suitable for that task because it cannot guarantee to find solutions, even if they exist.
16:52:38 <chrisdone> gismu = try (c & v & cs & v) <|> try (cc & v & c & v) where c = return <$> consC; v = return <$> vowelV; cs = consCSC; cc = consCC; (&) = liftM2 mplus
16:53:08 <thou> uh-oh.  something fixed it and i'm not sure what.  Maybe using CInt *was* the trick, and i didn't touch my test.hs before ghc --make
16:53:10 <sw17ch> > main = putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
16:53:10 <lambdabot>  Parse error at "=" (column 6)
16:53:14 <dcoutts_> dbueno: or another interesting task is finding the maximal (or near max) set of consistent packages on hackage.
16:53:15 <sw17ch> > main = putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
16:53:15 <lambdabot>  Parse error at "=" (column 6)
16:53:31 <sw17ch> > putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
16:53:32 <Myoma> >  (++ "!!") . (>> "AA") $ "Hello world !"
16:53:33 <lambdabot>  mueval: *** Exception: "<IO ()>"
16:53:34 <lambdabot> Terminated
16:53:36 <TomMD> > "pong"
16:53:39 <lambdabot>  "pong"
16:53:40 <Myoma> >  (++ "!!") . (>> "AA") $ "Hello world !"
16:53:41 <sw17ch> >  (++ "!!") . (>> "AA") $ "Hello world !"
16:53:42 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
16:53:43 <lambdabot> Terminated
16:53:46 <chrisdone> I think I might change from parsec to something else. I am using “try” on pretty much everything
16:53:53 <sw17ch> heheh
16:53:57 <sw17ch> that's actually pretty slick
16:54:07 <sw17ch> neat use of the list monad...
16:54:20 <sw17ch> (>> "1") $ [1..10]
16:54:21 <Myoma> (x >>) = (x >>=) . const ?
16:54:25 <sw17ch> > (>> "1") $ [1..10]
16:54:27 <lambdabot>  "1111111111"
16:54:30 <Myoma> @src (>>)
16:54:30 <lambdabot> m >> k      = m >>= \_ -> k
16:55:09 <qwr> noecksit: hmm, if i think more, its still type constructor. monad is type class. Reader foo bar is concrete type. Reader itself is type constructor.
16:55:32 <chrisdone> what's a nice parsing library like parsec but where it backtracks by default
16:55:50 <dcoutts_> chrisdone: polyparse
16:56:00 <chrisdone> thanks
16:56:09 <thou> yes, using CInt for x, y, z solved the problem.
16:56:10 <qwr> noecksit: and i hope you're not trying to mix type classes with oop class concept ;)
16:56:38 <thou> (my random comments are in reference to http://hpaste.org/9854 by the way)
16:56:43 <noecksit> well, when i try to define subclass my function, it says that it there is no instance for MonadReader MyEnv IO, does that mean that ReaderT is not part of MonadReader?
16:57:55 <qwr> noecksit: what you're actually trying to do?
16:59:11 <noecksit> qwr: its kind of hard to explain, but I have one function which is of type = ReaderT MyEnv IO and one of type = ReaderT MySecondEnv IO
16:59:23 <r3m0t> why is there a flood on thi channel
16:59:32 <Myoma> r3m0t: there isn't
16:59:35 <ski> r3m0t : probably the netsplit
16:59:43 <r3m0t> seemed like it :P
16:59:58 <qwr> noecksit: so use ReaderT a IO
17:00:09 <mauke> noecksit: weird
17:00:24 <ddarius> chrisdone: You could simply write x <+> y = try x <|> y
17:00:24 <noecksit> qwr: then i have a general function that calls one of these functions based on the one passed on the parameter, so its type is (Int -> ReaderT a IO) -> ReaderT a IO
17:00:26 <qwr> noecksit: you can have free type variables in the function type signatures
17:00:37 <chrisdone> r3m0t: irssi just says “netsplit”, like a sensible irc client
17:01:00 <r3m0t> chrisdone: that I already have
17:01:00 <noecksit> qwr: dont i need to declare it to be instance of MonadReader class?
17:01:11 <r3m0t> just after the netsplit finished there were masses of messages
17:01:15 <qwr> noecksit: why should you need it?
17:01:31 <chrisdone> ddarius: well, this is for appending strings which result from parses
17:01:35 <ski> chrisdone : well, some 40 messages rushed past in maybe 5 seconds, here (irssi)
17:02:09 <chrisdone> I must have some beta version of irssi that doesn't suck
17:02:23 <qwr> noecksit: the free type variable seems to be perfectly good there?
17:02:52 <noecksit> qwr: i guess it doesnt matter, i just wanted to make it more specific so its easier to understand
17:03:49 <ski> (chrisdone : sure it said `Netsplit' when people disappeared .. but when they appeared again, the joins came one by one)
17:04:12 <chrisdone> ddarius: parse (string "a" <|> string "b") "" "ab" => "b", parse (string "a" & string "b") "" "ab" => "ab"
17:04:24 <chrisdone> uh, the first should've been "a"
17:04:48 <noecksit> qwr: just for future reference then, do you know what instance MyEnv and MySecondEnv are, are they instances of class MonadReader?
17:06:00 <ddarius> chrisdone: I don't know what you are intending that to mean or what your point with it is.
17:06:13 <chrisdone> ddarius: oh well
17:06:34 <chrisdone> ski: mine didn't. mine says “netsplit over: joins a,b,c,d”. what is your irssi version?
17:07:23 <ski> /ctcp <nick> version
17:07:48 <chrisdone> ski: ah, 0.8.9, mine is 0.8.12. upgrade?
17:08:03 <ski> possibly
17:09:54 <Guest28439> i think i have a space leak, whats the best way to go about finding/fixing it?
17:10:44 <TomMD> www.well-typed.com  ;-)
17:10:52 <chrisdone> frisby has (<++>) :: P s [a] -> P s [a] -> P s [a], which is nice
17:11:10 <TomMD> Guest28439: Or you could read the new RWH chapter on profiling and see if that helps.
17:11:55 <Guest28439> k ill check it out, thanks
17:12:46 <dogface_> I've heard rumors of a zeta calculus interpreter in here. As there's no such thing as zeta calculus, I'm guessing I guessed wrong.
17:13:23 <TomMD> dogface_: You've no doubt heard we are all dead-end college students too.  Rest assured, I'm no dead end for another couple years still.
17:13:52 <chrisdone> you said that joke already
17:14:08 <TomMD> Yes, but I figured dogface_ didn't hear, so I recycled.
17:14:19 <dogface_> Indeed, I have heard that.
17:14:28 <TomMD> Damned.
17:14:40 <sampointon> it's a CAF, the joke was only evaluated once. That's laziness for you
17:14:43 * Myoma supposes TomMD is just very worried about what's going to happen in two yeras
17:14:44 <idnar> o/` converting vegetarians o/`
17:15:37 <TomMD> Myoma: That isn't too far off, but worse comes to worse I'll run away from civilization and live in the mountains of the NorthWest.  You'll only hear of me in tales by then ;-)
17:15:42 <dogface_> I'll go out on a limb and guess that you've heard Haskell was invented by Donald Duck.
17:16:36 <Myoma> TomMD, I am trying to figure out just how bad that would be... might even be fun
17:16:58 <TomMD> Thats what I think right now.  Of coarse right now I work for a living, always have a full stomach and food on my plate.
17:17:44 <chrisdone> idnar: is that some infected mushroom?
17:17:53 <TomMD> Does anyone here know how Chan's (Control.Concurrent.Chan) are implemented?
17:18:47 * chrisdone brushes TomMD's course hair
17:19:11 <TomMD> Hummm... looks like way too many MVars.  Is that actually efficient?
17:19:37 <dogface_> Is there anything inefficient about MVars?
17:20:40 <chrisdone> lack of a counter argument is proof
17:20:55 <ddarius> Myoma: Sounds like fun.
17:21:14 <TomMD> if _ then True else maybe notTrue
17:21:38 <ddarius> Tomas: It's essentially a (doubly?) linked list of MVars.
17:23:51 <noecksit> does the new hoogle work with gtk2hs api?
17:24:04 <dcoutts_> noecksit: not yet
17:24:36 <dcoutts_> noecksit: but pgavin tells me that he's got Gtk2Hs working with haddock 2, so it should be possible to get it included with hoogle 4
17:24:53 <TomMD> ddarius: I just downloaded the concurrent Haskell paper.  Neat design.  I'll give it a quick test to see how many messages I can write/read a second.
17:25:02 * shapr boings
17:25:03 <jberg> i see ghc has moved to git, but is that because darcs is insufficient for really large projects? i've only read about darcs patch theory and found it really simple and intuitive so i want to use it for own my personal (and rather small) software projects. but is git better, should i go for git instead?
17:25:27 <shapr> From what I heard, darcs isn't so good for projects the size of the linux kernel.
17:25:32 <cjb> jberg: it seems to be faster (which doesn't mean it's more elegant).
17:25:40 <cjb> (git, that is.)
17:25:44 <Twey> TomMD: It's pretty damn fast.
17:25:57 * luqui has found git very nice, also fast.  not as beautiful, but better software.
17:26:00 <jberg> cjb: well, speed wasnt the reason ghc changed to git was it?
17:26:04 * Myoma mu's at shapr :))
17:26:04 <shapr> I use darcs for all my personal projects.
17:26:06 <Heffalump> jberg: some users of darcs on the ghc repo have had a lot of trouble with it
17:26:10 <shapr> hej Myoma!
17:26:11 <cjb> jberg: why would you think it wouldn't be?
17:26:19 <Heffalump> but you really do have to have a project that big before it really causes trouble
17:26:24 * shapr does lambaaa lifting in return!
17:26:33 * araujo throws a lambda web at shapr 
17:26:34 <Twey> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=ghc&lang2=python
17:26:36 <lambdabot> Title: thread-ring Haskell GHC #2 program | Gentoo : Intel® Pentium® 4 Computer Langu ..., http://tinyurl.com/5ry8u7
17:26:41 * shapr is stuck in the lambda web!
17:26:44 <Myoma> :D
17:26:47 <jberg> cjb: because i read why they changed to git. can't remember much about speed, i think it was more about merging branches or something
17:26:59 <daf> http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation discusses the problems
17:27:01 <lambdabot> Title: DarcsEvaluation - GHC - Trac
17:27:07 <Myoma> lambda web is probably edible, I imagine
17:27:08 <Heffalump> it's speed and bugginess
17:27:16 <shapr> hi daf!
17:27:21 <daf> shapr: hey :)
17:27:26 <jberg> hmm, so i think ill go for git then
17:27:36 <daf> it also has some interesting comparisons with other systems
17:27:36 <Heffalump> what size project do you want to use it on?
17:27:42 <Myoma> jberg: I prefer svn because I already have it installed
17:27:43 <noecksit> i had some problems pushing to remote repositories with darcs so i switched to git because i know it better
17:27:55 <daf> I love darcs for small projects
17:27:55 <shapr> I like darcs very much.
17:27:57 <jberg> Myoma: i have svn darcs and git installed
17:28:12 <ddarius> Myoma: darcs is less of a hassle to use than svn
17:28:20 <ddarius> Or at least that was my experience years ago
17:28:28 <Myoma> ddarius: only after you have it installed
17:28:44 <noecksit> i think its mostly a personal preference, darcs is more user friendly than git but less stable
17:28:44 * ddarius doesn't have svn installed.
17:28:50 * Myoma can hardly see any difference between these programs other than the name of the commands
17:28:54 <chrisdone> sudo apt-get install darcs -- not really a hassle
17:28:57 <sampointon> Myoma: as far as I remember, the darcs install was very painless
17:30:21 <noecksit> dcoutts_: is there a link to the old hoogle 3 somewhere for now that can search gtk2hs?
17:30:29 <luqui> haskell.org/hoogle/3
17:31:04 <sclv> darcs on windows is still mildly painful -- although i understand git is too....
17:31:11 <sclv> just an issue of configs and etc.
17:31:14 <noecksit> luqui: thanx
17:31:26 <sclv> folks don't seem to keep the binaries in good enough shape.
17:32:00 <Myoma> I don't know there has to be svn cvs darcs git .. etc, why couldn't somebody just write the best possible program in the first place?
17:32:39 <jberg> competition is good
17:32:54 <sclv> haskell, ocaml, c, perl, intercal.. I feel your pain.
17:32:55 <Myoma> competition is good when it makes shops have fair prices
17:32:56 <dcoutts_> noecksit: I've fixed up the link on the gtk2hs site to point to the old hoogle 3
17:33:01 <luqui> Myoma, they did, it was called cvs
17:33:09 <luqui> they just had a weird definition of "best"...
17:33:21 <dcoutts_> noecksit: thanks for reminding me to fix it
17:33:33 <Myoma> but when it requires you to learn 4 different sets of commands that do roughly equivalent things ...
17:33:44 <sclv> luqui: I always preferred tar/rsync actually...
17:33:52 <TomMD> Ok, so on the threaded RTS -N2 I get 700,000 messages a second though Chan.  I like.
17:33:54 <Myoma> I guess what I mean is why should free software compete instead of work together?
17:34:24 <luqui> competing is working together
17:34:28 <cjb> Myoma: cvs and git cannot be merged into one piece of software.
17:34:29 <sampointon> Myoma: darcs, git and svn aren't exactly compatible
17:34:36 <cjb> I mean, they could, but that piece of software would be git :)
17:34:40 <Myoma> luqui: :S huh?
17:34:50 <TomMD> But I don't see how to limit the amount of data buffer up in a chan without an external counter (TVar Int or some such).
17:34:53 * cjb agrees with luqui.
17:35:09 <Myoma> cjb, sampointon, that's the _problem_, isn't it?
17:35:11 <luqui> developers see work that has been done before, use it, see what's wrong with it, start a new project that avoids those problems, etc...
17:35:11 <cjb> the code is shared, each can borrow ideas from the rest.  competition here doesn't have the negative sense that you're ascribing to it.
17:35:15 <sclv> TomMD: have you looked at counting semaphores?
17:35:16 <cjb> Myoma: huh?  no.
17:35:21 <sampointon> Myoma: not really a problem, no
17:35:28 <noecksit> dcoutts_: cool
17:35:35 <sclv> You could create a neat data structure by putting the two together.
17:35:40 <cjb> Myoma: why is not being able to merge two pieces of software a bad thing?  I wouldn't try to merge gnome-terminal and firefox, either.
17:35:49 <Myoma> oh well I'm the only that gets fed up installing a new rcs every month and learning a new set of commands
17:35:50 <sampointon> Myoma: git users and devs want their architecture, darcs people want their patch theory
17:35:57 <TomMD> sclv: No, I haven't.  Looking now.
17:35:59 * Twey chuckles.
17:36:13 <daf> Myoma: often it's not clear what is best
17:36:20 <luqui> the main thing that will help competition is avoiding that zealous emotional attitude.  I am emotionally attached to darcs, but I grit my teeth and recommend git, because I know it's better...
17:36:27 <sampointon> Myoma: look into tailor, it can convert from one source control system to another, ish
17:36:28 <daf> Myoma: the best way to find out is to try different things and see what works out in the long term
17:36:28 <luqui> or help cooperative competition
17:36:32 <sclv> on the other hand -- doesn't seem to be any point to limiting the data buffered into a chan..?
17:36:33 <Myoma> luqui: How can one decide when it's best to fix something or start from scratch? I wonder if there is a problem in that, like most software that is written isn't hackable enough
17:36:38 <sclv> the chan is itself the buffer...
17:36:56 <daf> Myoma: I agree with you there
17:36:58 <luqui> Myoma, with rcs systems, it's when the "world view" of one system is what's holding it back
17:37:06 <sclv> I suppose if you really want to control differential rates of thread interaction...
17:37:11 <luqui> Myoma, for example, svn seeing the world as a sequential series of revisions
17:37:37 <TomMD> sclv: What I want is in the case the writer gets scheduled a hell of a lot more than the readers (as in my trivial example, it does), I want the writer to know too much data is pending and not read anymore from the source (Socket or what have you).
17:38:09 <TomMD> * I suppose I shouldn't say the writer is scheduled more, but it certainly works faster at putting items on than the readers take them off.
17:38:30 <sclv> sounds like you're probably better off with a throttle on the writer than a blocking buffer...
17:38:46 <luqui> Also Haskell hackers like to write things from scratch, since usually the thing they are cloning does not have a nice simple theory.
17:39:10 <sclv> i.e. forever $ threadDelay 10000 >> readThing >>= writeChan c
17:39:15 <Cale> It's really too bad that every category doesn't have all coproducts. This business of revision control systems would go much more smoothly ;)
17:39:52 <monochrom> I took a "theory of distributed systems and algorithms" course (actually two consecutively) and saw solutions to mind-boggling problems. I no longer fear decentralization and "what if you need a consistent snapshot". It can be easily done.
17:39:58 <TomMD> But a throttle is an arbitrary solution.  In one use case the library might have slow readers and in another it might not.  I'll look at a some Sem and the ramifications of having an separate buffer length count on Chans.
17:40:01 <Myoma> I wish I understood what a coproducts was better than 'probably something like Either except different'
17:40:33 <tb8132> hello. i am a racist spammer and i would like to announce the creation of a channel #whitepower.
17:40:43 <Cale> Myoma: The intuition is that it's like a disjoint union that's been glued together.
17:40:48 <monochrom> Hahahahaha
17:41:06 <luqui> wait, how is coproduct different from Either?
17:41:15 <luqui> other than it's more general, of course...
17:41:17 <Cale> er, sorry, pushouts :)
17:41:18 <sclv> TomMD: I suppose... but then there's all sorts of wasted cycles in blocking and unblocking...
17:41:19 <Myoma> @remember <tb8132> hello. i am a racist spammer and i would like to announce the creation of a channel #whitepower.
17:41:19 <lambdabot> I will never forget.
17:41:27 <Cale> Coproducts would be pretty good too :)
17:41:47 <Cale> Actually, I'm pretty sure that if every category had coproducts, then every category would have pushouts :)
17:41:48 <luqui> @forget tb8132
17:41:49 <lambdabot> Incorrect arguments to quote
17:41:58 <luqui> @forget <tb8132> hello. i am a racist spammer and i would like to announce the creation of a channel #whitepower.
17:41:58 <lambdabot> No match.
17:42:08 <sclv> (I already forgot it in privmsg)
17:42:08 <luqui> don't know how to work this thing.
17:42:14 <luqui> ah
17:42:17 <tb8132> @remember jews are beasts that must be destroyed
17:42:18 <lambdabot> Good to know.
17:42:18 <Cale> Myoma: A coproduct is basically a disjoint union, like Either, yeah.
17:42:32 <sclv> uh... cale... a little help?
17:42:35 <Cale> yep
17:42:36 <tb8132> @remember stormfront is at http://stormfront.org
17:42:36 <lambdabot> Done.
17:42:40 --- mode: ChanServ set +o Cale
17:42:42 <sclv> @forget jews are beasts that must be destroyed
17:42:42 <lambdabot> Done.
17:42:42 <Myoma> sclv: why?
17:42:46 --- mode: Cale set +b *!*@gateway/tor/x-0339c5109bbc534a
17:42:56 --- kick: tb8132 was kicked by Cale (Cale)
17:43:02 <sclv> @forget stormfront is at http://stormfront.org
17:43:03 <lambdabot> Done.
17:43:25 --- mode: Cale set -o Cale
17:43:46 <Cale> Of course, that's a tor address, so he could potentially be more annoying.
17:43:58 <sclv> haha poor bot would probably have forgotten them within the hour anway.
17:44:33 <sclv> how many great quotes have been lost to \bot's nondeterministic state?
17:44:55 <mauke> none really; you can still grep the logs for [@?]remember
17:44:57 <sampointon> exactly _|_, sclv. I kept count
17:45:13 <monochrom> "if every category had coproducts, then every category would have pushouts" is a pretty weak statement.
17:46:52 <Cale> monochrom: In the sense that it's true?
17:47:24 <monochrom> It's weaker than "for every category, if it has coproducts, then it has pushouts".
17:48:58 <monochrom> My logic kills the conversation.
17:49:52 <Cale> monochrom: Would you mind giving a proof of that?
17:50:30 <MyCatVerbs> Cale: that's like the nuclear-doomsday version of "[citation needed]". :)
17:51:08 <monochrom> I can prove "weaker than or equal to" but I lack the category skill to prove "strictly weaker than".
17:51:42 <lament> [peer-reviewed proof needed]
17:53:16 <Cale> If a category has an initial object and pushouts, then it has coproducts. That way is easy. (I'm not sure how to get rid of the initial object though.) The other way, guaranteeing that if a category has all coproducts then it has all pushouts seems much harder.
17:54:48 <Cale> But if *every* category had coproducts, you can form the category of objects under A, and take a coproduct in that, and it should give you the pushout, I would think.
17:55:34 <Myoma> is a pushout the dual of pullback?
17:55:37 <Cale> yeah
17:56:30 <FunctorSalad_> IIRC all colimits <=> (coequalizers and coproducts) <=> (pushouts and initial object)
17:56:51 <FunctorSalad_> (all finite colimits / coproducts)
17:56:58 <Cale> FunctorSalad_: that sounds much more sensible :)
17:57:03 <monochrom> nice
18:00:28 <FunctorSalad_> the cat of free groups has coproducts but not pushouts I think
18:00:46 <FunctorSalad_> unless the pushout in that category is not what I think it is.
18:00:53 <ddarius> FunctorSalad_: Prove it.
18:02:16 <Cale> FunctorSalad_: oh, yeah.
18:02:33 <FunctorSalad_> ddarius: I was thinking about the pushout with f: Z -> Z, f x = 2 x, g : Z -> 1 the trivial map, then in Grp at least the pushout would be Z / 2Z
18:02:36 <Cale> The pushout in the category of groups is the amalgamated free product.
18:02:53 <FunctorSalad_> Cale: yeah, but is it in the subcategory of free groups?
18:03:10 <FunctorSalad_> there probably some easier example...
18:03:23 <Cale> Well, you have all the maps between those objects that you have in the category of groups.
18:03:32 <ddarius> FunctorSalad_: If it is a full subcategory then yes except that it doesn't exist within that category.
18:05:27 <Cale> I remember finding a website at one point that was like a zoo of categories and how various concepts resolve in each, but I lost the URL. I wonder if anyone else here would know of something like that.
18:06:04 <FunctorSalad_> Cale: I was thinking about doing something like that semi-formally
18:06:31 <FunctorSalad_> (with the "structures" formally specified but the theorems just asserted)
18:07:36 <Cale> yeah
18:07:45 <haskellian> is Haskell good for creating DSLs?
18:08:25 <Cale> haskellian: yeah, generally
18:08:30 <dons> haskellian: that's one of the 5 pillars of strength.
18:08:32 <_JFT_> Hi I"m trying to create a type class for a category of container which have 2 type parameters. One operation of this type has type q a b -> q b a which works ok. I wanted to define another one which is actually the same method called twice and I keep hitting error messages  any Ideas? (Pretty please :))
18:08:48 <_JFT_> http://hpaste.org/9856
18:08:56 * Cale has a look
18:09:27 <_JFT_> I spent about 2 hours today writing and rewriting this, with and without quantification (using kind)
18:09:30 <_JFT_> and to no avail
18:09:43 <Cale> _JFT_: q determines both a and b...
18:09:46 <_JFT_> the best I could get was q a a -> q a a (monomorphism) which is useless
18:09:49 <_JFT_> yes
18:09:54 <Nafai> dons: What are the 5 pillars?
18:09:54 <_JFT_> if you look SQuad
18:10:04 <Cale> So if a and b are meant to be different
18:10:08 <_JFT_> you see basicaly it is to represent a QuadEdge data structure
18:10:11 <_JFT_> (topology)
18:10:17 <Cale> and you apply qRot to q a b, giving q b a
18:10:25 <Cale> then surely you can't apply qRot again
18:10:26 <_JFT_> for exemple 4 quad are linked in a circle using rot
18:10:31 <Cale> because q b a is the wrong type
18:10:45 <_JFT_> but sqSym (if you look at my code works fine)
18:10:47 <dons> Nafai: hmm DSLs, compilers, verification, parsers, kicking butt.
18:10:50 <Cale> The instance IQuad q b a can't exist if IQuad q a b does
18:10:55 <Cale> unless a and b are equal
18:10:58 <_JFT_> I just can write an equivalent qSym (within or outside the type class)
18:11:01 <_JFT_> that is generalised
18:11:01 <Nafai> dons: w00t.  Like that last one :)
18:11:04 <dons> :)
18:11:14 <_JFT_> Cale: I hear what you say but I dont understand why
18:11:22 <_JFT_> qRot basically "toggle"
18:11:23 <Cale> _JFT_: well, what's the type of sqSym?
18:11:30 <_JFT_> q a b -> q a b
18:11:39 <Guest28439> whats the longest any of you have had "ar" run?
18:11:42 <Cale> Really? That seems wrong to me.
18:11:48 <_JFT_> see the for Quad a b are linked alternating what the a and the b are
18:12:02 <_JFT_> for q0 a is vertex b is face
18:12:08 <_JFT_> rot from q0 is q1
18:12:09 <Cale> oh, that's SQuad
18:12:14 <_JFT_> yes
18:12:16 <ddarius> dons, you should, at some point, blog about RWH and how it is a representative example of how the Haskell community works and how one makes use of the Haskell community.
18:12:20 <Cale> Oh, yeah, then that's fine.
18:12:21 <_JFT_> q1 a is a face and b is a vertex
18:12:28 <_JFT_> but it diesn't work :(
18:12:43 <FunctorSalad_> _JFT_: I think you want qSym outside the class
18:12:49 <_JFT_> I tried
18:12:53 <Cale> _JFT_: Your problem is that q *determines* the types a and b
18:12:55 <_JFT_> but I could not get it to work
18:13:00 <Cale> (because of your fundeps)
18:13:05 <FunctorSalad_> qSym (q a b, q b a) => q a b -> q a b
18:13:06 <_JFT_> cale: I can't really avoid it
18:13:16 <FunctorSalad_> sorry, I mean: qSym :: (q a b, q b a) => q a b -> q a b
18:13:18 <_JFT_> FunctorSalad_: I get q a a -> q a a when I tried that
18:13:25 <_JFT_> monomorphism
18:13:42 <Twey> Grr
18:13:42 <Cale> So if a and b are different, then at least one of IQuad q a b and IQuad q b a is false.
18:13:48 <Twey> Why is Network so confusing?
18:14:00 <Twey> There's a data PortNumber
18:14:01 <Cale> Twey: Which interface? The easy one?
18:14:04 <Cale> okay
18:14:15 <Twey> *And* a data PortID = PortNumber PortNumber
18:14:19 <Twey> What's that all about?
18:14:30 <Cale> PortNumber is an instance of Num
18:14:35 <Twey> Right
18:14:38 <ruddel> Cale :D
18:14:42 <_JFT_> here's a diagram of the structure: http://www.voronoi.com/wiki/index.php?title=Image:Quadedge.png
18:14:44 <mauke> is that the one with the insane internals?
18:14:47 <lambdabot> Title: Image:Quadedge.png - VoroWiki
18:14:47 <Cale> So you can just write PortNumber 6667 to get a value of type PortID
18:14:59 <Cale> Hello ruddel :)
18:15:12 <luqui> () is a monad right?
18:15:19 <mauke> luqui: no
18:15:22 <FunctorSalad_> _JFT_: I agree with Cale, can't you get rid of the fundeps?
18:15:23 <ddarius> luqui: It doesn't even have the right kind.
18:15:23 <Cale> luqui: no, because it's not a type constructor
18:15:27 <ruddel> Haskell School of Expression just arrived at a local barnes and nobles :D
18:15:30 <luqui> oh right, I mean Const ()
18:15:31 <_JFT_> no because of qData
18:15:43 <ddarius> luqui: Yes, it can be made into a Monad.
18:15:45 <_JFT_> unless I'm doing it wrong.. (it is always possible :P)
18:15:54 <Cale> ruddel: One thing that I'll warn you about is that SoE is a little bit dated.
18:16:10 <Cale> Unless there's been a new revision since I checked :)
18:16:24 <ruddel> Cale, nope its from 2000
18:16:34 <luqui> so, what's the corresponding comonad?
18:16:38 <ruddel> but how much different can it be?
18:16:57 <ddarius> 8 years is certainly not a long time in the computing world ...
18:17:09 <_JFT_> SoE was a revelation for me in one way, it is the best introduction book on programming by charging type semantic (not sure if that make sense in English !)
18:17:24 <_JFT_> I mean using type to store logic
18:17:29 <FunctorSalad_> _JFT_: your current declaration means "for every Q, there is a type A such that IQuad Q A A is the only instance of the form IQuad Q a b
18:17:38 <FunctorSalad_> "
18:17:46 <_JFT_> FunctorSalad_: which is not what I want :(
18:17:46 <FunctorSalad_> unless I'm missing something
18:17:47 <Cale> FunctorSalad_: not quite
18:17:48 <_JFT_> So if a and b are different, then at least one of IQuad q a b and IQuad q b a is false.
18:17:50 <_JFT_> oupus
18:17:53 <_JFT_> sorry wrong copy past
18:18:01 <_JFT_> check this please FunctorSalad_ http://www.voronoi.com/wiki/index.php?title=Image:Quadedge.png
18:18:03 <lambdabot> Title: Image:Quadedge.png - VoroWiki
18:18:09 <ruddel> ddarius, is that a sarcastic statement or do you really agree that 8 years isn't much in the computing world?
18:18:16 <FunctorSalad_> oh right, A and B can be different
18:18:16 <_JFT_> Quad are grouped by 4 in a loop
18:18:19 <_JFT_> yes
18:18:19 <Cale> It means that for every Q there are types A and B such that IQuad Q A B is the only instance of the form IQuad Q a b
18:18:23 <adu> I just had a brilliant idea!
18:18:25 <FunctorSalad_> Cale: *nod*
18:18:29 <ddarius> luqui: A functor to the initial object.
18:18:32 <_JFT_> for q in that diagram a is vertice b is face
18:18:35 <Cale> (they might be distinct types)
18:18:37 <Cale> But!
18:18:45 <_JFT_> for qRot q (which is also a Quad) a is face and b is vertex
18:18:59 <_JFT_> then qRot . qRot q a is back to a vertices and b a face
18:19:01 <Cale> It means that if A and B are different, and IQuad Q A B is an instance, then IQuad Q B A won't be.
18:19:08 <dfrey|work> Really simple question:  How do I convert from an Int to an Integer?
18:19:13 <Cale> dfrey|work: fromIntegral
18:19:14 <mauke> dfrey|work: fromIntegral
18:19:16 <luqui> ddarius, Const Absurd?  (where Absurd has no constructors)?
18:19:20 <Twey> Cale: Hmn
18:19:31 <ddarius> luqui: I believe so.
18:19:32 <_JFT_> Cale: I must be thinking this wrong
18:19:32 <mauke> we call it Void
18:19:33 <_JFT_> but
18:19:45 <_JFT_> cale: I meant IQuad to store the structure
18:19:46 <Twey> Cale: I'm getting "Couldn't match expected type `PortID' against inferred type `PortNumber'"
18:19:51 <Myoma> Absurd isn't very absurd when you're in haskell land
18:19:52 <_JFT_> and they are alternating their type
18:20:04 <_JFT_> so I thought it was ok to have IQuad Q A B and IQuad Q B A
18:20:16 <luqui> heh.  picked up the terminology from my brief digression into agda.
18:20:17 <stepcut> Twey: this worked for me, (PortNumber 6667)
18:20:28 <stepcut> ?type (PortNumber 6667)
18:20:30 <adu> _JFT_: why can't you?
18:20:30 <lambdabot> Not in scope: data constructor `PortNumber'
18:20:32 <stepcut> :(
18:20:35 <mauke> where is PortID coming from?
18:20:37 <Twey> When passing (PortNumber 6667) to a function startBack :: PortID -> ...
18:20:42 <stepcut> mauke: Network
18:20:49 <_JFT_> adu: http://hpaste.org/9856
18:20:55 <mauke> ah, I see
18:20:56 <dfrey|work> Cale, mauke: And the other way around?
18:21:05 <mauke> dfrey|work: fromIntegral
18:21:37 <adu> woah.... what does "| q -> a, q -> b" mean?
18:21:38 <_JFT_> cale: isn't it possible to code a qSym (which is qRot . qRot) for all instance of IQuad?
18:21:42 <mauke> Twey: hmm, that shouldn't happen
18:21:52 * Twey pastes some code.
18:21:53 <_JFT_> (And thanks for helping ! :))
18:22:08 <ddarius> adu: Know any relational database theory?
18:22:48 <adu> ddarius: I know how to use Postgres and MSAccess... does that count?
18:23:10 <luqui> adu, it means that for any choice of q, there is at most one choice for a.
18:23:13 <luqui> (and also for be)
18:23:15 <luqui> er, b
18:23:24 <ddarius> adu: Do you know database design?  Stuff like normalization?
18:23:41 <Twey> Ah!
18:23:45 <adu> luqui: so like q is a primary key for a?
18:23:53 <Cale> _JFT_: not without a and b being the same type, no
18:23:56 <Twey> Never mind, mauke, Cale, caught it -- had a PortNumber lurking in a type signature
18:24:02 <Cale> Twey: ah
18:24:02 <_JFT_> adu: | q -> a, q -> b is specifying a functional dependency. i.e. the type of a is specified from q (likewise for b)
18:24:11 <stepcut> Twey: :)
18:24:12 <adu> ddarius: never heard of normalization
18:24:12 <mauke> Twey: whatever you do, don't use 'PortNum'
18:24:13 <_JFT_> Cale: Is my error in my SQuad definition then?
18:24:15 <luqui> adu, uh. I don't do databases.  =P
18:24:31 <adu> ddarius: i understand "primary key" and "one-to-many" :)
18:24:43 <_JFT_> Cale: should SQuad have type variable for each quad (rot and next) instead for parametrising quad?
18:24:44 <Twey> mauke: What's that one?
18:24:59 <mauke> it's PortNumber internals
18:25:25 <mauke> or rather, its data constructor
18:25:32 <Twey> Ah
18:25:36 <adu> ddarius: I probably understand more than that, but i don't know terminology
18:25:42 <dons> ddarius: that's an interesting idea. i'll have to think more about it.
18:25:55 <Twey> Hm, I don't see it, mauke
18:25:58 <Twey> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
18:25:59 <mauke> good :-)
18:26:00 <FunctorSalad_> _JFT_: I don't get the diagram :)
18:26:10 <Twey> Oh, I see.
18:26:16 <_JFT_> FunctorSalad_: the "+" is actually 4 quad linked together
18:26:17 <Twey> Yes, PortNumber appears to have no constructors.
18:26:19 <_JFT_> by their rot
18:26:23 <Twey> Heh
18:26:25 <_JFT_> rotation pointer if you want
18:26:27 <Cale> _JFT_: you could just lose the fundeps
18:26:49 <ddarius> dons: Rereading http://www.cs.kuleuven.ac.be/~dtai/projects/ALP//newsletter/dec07/content/Articles/tom/content.html might get the juices going (again)
18:26:50 <_JFT_> cale: I thought I was forced to have them to releated IQuad a b to SQuad a b?
18:26:51 <adu> _JFT_: so q -> (q, q)? would that be an example? or (a, a) -> a?
18:26:51 <lambdabot> Title: Wake up call, http://tinyurl.com/3p3zvk
18:27:32 <Myoma> let foo = (\x -> (product [1..30000] + x) * 0::Integer)
18:27:41 <_JFT_> adu: I don't follow you (about functional dependency?)
18:27:46 <Myoma> foo 1 then foo 2 ... seems to compute the product every time
18:28:00 <adu> _JFT_: thats good, cuz i don't follow you either :)
18:28:01 <_JFT_> cale: I am just starting to grasp fundep so I might be wrong
18:28:03 <dbueno>                        -- We choose this package in the configuration.
18:28:03 <dbueno>                                 
18:28:03 <dbueno>                        -- We choose this package in the configuration.
18:28:03 <dbueno>                                 
18:28:03 <dbueno> dcoutts_ Is there a reason why PackageIndex can't be an instance of Functor?
18:28:08 <_JFT_> adu: lol
18:28:26 <dbueno> dbueno: Er ... sorry about that.
18:28:36 <dons> ddarius: cheers.
18:28:50 <dons> ddarius: yes, something in response to that, drawing comparisons.
18:28:51 <_JFT_> adu: in my type class declaration the functional dependency link the 2 type variable a and b to the type class beeing defined (q) so that not any type can be put there
18:29:09 <dons> -- having 700 tech reviewers, when the usual case is 4 or 5, is *exactly* the kind of story we like :)
18:29:33 <adu> _JFT_: would "(q, q)" be an example of an "a" that is specified from "q"?
18:30:00 <ddarius> dons: The fact that the you guys had the book open to comments is something relatively unusual but quintessentially Haskell.
18:30:04 <_JFT_> adu: it depends of how q (the type instance) is defined and used in the type class
18:30:46 <FunctorSalad_> _JFT_: maybe lets start with the question why a class is needed at all?
18:31:12 <_JFT_> I need to have Immutable and mutable version so I was trying to generlise the code using type class
18:31:17 <_JFT_> maybe that's my error there
18:31:39 <_JFT_> FunctorSalad_: I took inspiration from the Array, IArray and MArray
18:31:49 <_JFT_> FunctorSalad_: headed that way anyway :P
18:31:51 <matthew-_> agh, my man is broken, what's the nowarn shadowing option?
18:32:03 <FunctorSalad_> _JFT_: I don't know these, sorry
18:32:29 <_JFT_> adu: check this http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes there is a section about functional dependency
18:32:32 <lambdabot> Title: Haskell/Advanced type classes - Wikibooks, collection of open-content textbooks
18:32:46 <TSC> matthew-_: -fwarn-name-shadowing is the positive one, so -fnowarn-name-shadowing ?
18:32:56 <FunctorSalad_> _JFT_: in what sense can something be mutable in haskell at all?
18:33:12 <_JFT_> using a monad decorated version
18:33:42 <matthew-_> TSC: nope isn't that
18:34:00 <_JFT_> FunctorSalad_:  http://hackage.haskell.org/packages/archive/array/0.1.0.0/doc/html/Data-Array-MArray.html
18:34:06 <lambdabot> Title: Data.Array.MArray, http://tinyurl.com/5lldg2
18:34:08 <TSC> What about with a - between "no" and "warn"?
18:34:23 <matthew-_> ahh, -fno-ward
18:34:25 <matthew-_> *warn
18:34:26 <matthew-_> indeed
18:35:32 <_JFT_> cale: if I drop the fundep here's what I get
18:35:40 <_JFT_> cale: http://hpaste.org/9857
18:36:44 <_JFT_> FunctorSalad_: about mutability my idea was to use a "thaw" and freeze" to convert between an Immutable and Mutable version of the Quad
18:37:05 <_JFT_> FunctorSalad_: the Mutable beeing implemented by storing STRef
18:37:31 <mikv_> Hi!
18:37:37 <Cale> _JFT_: right, you'll need a good type signature for qRot
18:37:43 <Cale> _JFT_: It needs two instances
18:37:52 <_JFT_> two version of qRot?
18:38:01 <Cale> Er...
18:38:03 <_JFT_> cale: in the type class 2 version of qRot?
18:38:11 <Cale> type signature for qSym rather
18:38:13 <mikv_> What does value constructor do?
18:38:14 <Cale> yeah
18:38:27 <Cale> mikv_: make values, as the name would suggest
18:38:45 <_JFT_> cale: yes but I tried many and could not figure the magic one.
18:38:47 <adu> why is there no comma in "class Mult a b c | a b -> c where"
18:38:49 <adu> ?
18:39:15 <adu> does "a b -> c" mean "a -> c, b -> c"?
18:39:16 <Cale> adu: commas are used to separate the dependencies
18:39:17 <Myoma> why does a spider have 8 legs
18:39:23 <ddarius> adu: No
18:39:28 <FunctorSalad_> adu: it means a and b *together* determine c
18:39:30 <Cale> adu: It means that together, a and b determine c
18:39:32 <ddarius> Myoma: Why not?
18:39:34 <Cale> Rather than separately.
18:39:37 <adu> o ok
18:39:57 <ddarius> Myoma: Alternatively, "By definition."
18:40:03 <Myoma> hehe
18:40:04 <Cale> _JFT_: qSym :: (IQuad q a b, IQuad q b a) => q a b -> q a b
18:40:25 <_JFT_> cale: I tried again but today I tried that and got q a a -> q a a
18:40:42 <Cale> _JFT_: that's because of your fundeps which are wrong
18:40:43 <_JFT_> from there I started declaring quantification (forall) to no avail...
18:40:54 <FunctorSalad_> _JFT_: tried moving the qSym out of the class *and* removing the fundeps?
18:40:55 <_JFT_> cale: ah.. Ok I'm retrying this. Thanks!
18:40:57 <mikv_> mikv_, i found type constructor, i understand what it does
18:41:14 <_JFT_> FunctorSalad_:  today qSym was actually out of the type class
18:41:22 <Cale> mikv_: Okay, so for example, Maybe is a type constructor, and Maybe Integer is a type
18:41:47 <Cale> mikv_: The values which are of type Maybe Integer are all either of the form Nothing, or Just n, where n is an Integer
18:41:54 <adu> someone lied to me: I just learned about Data.Derive
18:41:55 <Cale> Nothing and Just are the data constructors for Maybe
18:42:03 <Twey> adu: What does that do?
18:42:14 <FunctorSalad_> note that Maybe Integer is *definitely* a type (sorry)
18:42:23 <adu> Twey: It lets you make your own things to put after "data ... deriving ..."
18:42:30 <Twey> Oho
18:42:31 <Twey> Nice
18:42:35 <Twey> ... how does it do that?
18:42:49 <Twey> And where is it?
18:43:04 <adu> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
18:43:05 <lambdabot> Title: Data.Derive: A User Manual
18:43:07 <mauke> @where hackage
18:43:07 <lambdabot> http://hackage.haskell.org/
18:43:11 <_JFT_> cale: it did it!!! Thank you. Bad thing is that it mean I still don't undestand fundep well. any pointer ?
18:43:25 <Twey> Yes... but... *how*?
18:43:27 <Twey> Oh
18:43:28 <Twey> TH?
18:43:32 <mikv_> Cale, hm... so there are 3 types of constructor in Haskell?
18:43:48 <adu> Twey: dunno, just learn ABOUT it, I haven't learned IT yet
18:43:53 <Cale> mikv_: data constructors and value constructors are the same thing
18:44:03 <haskellian> dons: what is RHW?
18:44:34 <mikv_> Cale, why did they call the same thing with different names?
18:44:37 <Cale> mikv_: actually "value constructor" seems not to be used, but if I saw it, I would assume that they meant data constructor.
18:44:39 <mikv_> aaaa
18:45:26 <FunctorSalad_> the constructor constructs values, but belongs to a data statement...
18:45:33 <ddarius> "The snowball was tiny when it was first thrown, but it's become a real avalanche now! And the Haskell community sure is fanning the flames."  Yay mixed metaphors!
18:46:14 <Cale> ddarius: Obviously it's an avalanche of fire!
18:46:28 <Cale> The snow is fire snow!
18:46:33 <ddarius> From a tiny snowball ... of fire!
18:47:19 <_JFT_> brb
18:47:45 <adu> ?
18:47:46 <ddarius> dons: You could title your blog post: "Haskell: Snowball of Fire" or "Haskell: Fanning the Flames of an Avalanche"
18:47:47 <Twey> Hahahaha
18:48:01 <ddarius> (with added ! as necessary)
18:48:26 <adu> how about just "Snowfire"
18:48:45 <Cale> "Haskell: Fanning the Flames of an Avalanche" is the best title ever.
18:49:17 * Twey laughs.
18:49:55 <_JFT_> cale: can I ask why it was wrong in my earlier exemple to use fundeps? I thought they were proper (actually required) but you sure proved me wrong. Any good resource to learn fundep properly? (I've read the wikibooks and the wiki)
18:49:59 <adu> i thought there was no prefix? like it was just "constructor"
18:50:28 <_JFT_> "Fanning the Flames of an Avalance" is indeed a very good title!
18:50:30 <Cale> _JFT_: Well, the fundeps that you used mean that for any given type Q, there is at most one instance of IQuad Q a b
18:50:35 <Cale> _JFT_: That seems not true.
18:50:42 <_JFT_> cale: OH!
18:50:58 <adu> oooo
18:51:09 <_JFT_> cale: that's not at all what I meant but I understand now why it didn't! Thank you
18:51:10 <matthew-_> err, scratch that, about 0.00003 secs
18:51:12 <gwern> fanning the flames of a perfect avalanche, maybe
18:51:12 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
18:51:21 <gwern> @messages
18:51:21 <lambdabot> dcoutts_ said 2h 16m 18s ago: ok, should be fixed now. Discovered the other problem and actually tested it this time ;-)
18:51:38 * gwern is shocked. actually tested?
18:51:55 <FunctorSalad_> surely there must be some conditions where snow is actually flaming?
18:52:02 <gwern> 'This paradigm pioneers some unusual techniques. Infinite lists, for instance, are common in Haskell. In fact, all data items are treated as infinite lists of length 1. Other infinite lists may be longer. Evaluating them is still an error. '
18:52:17 <_JFT_> FunctorSalad_: if "snow" is a white substance yes ;)
18:52:23 <FunctorSalad_> water got to be able to react to something
18:52:25 <FunctorSalad_> _JFT_: lol
18:52:31 <gwern> wait, 'fanning the flames of an avalanche in hell'?
18:52:42 <FunctorSalad_> (react and release energy in the process I mean)
18:53:05 <gwern> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
18:53:07 <_JFT_> FunctorSalad_: isn't it magnesium which react violently to water?
18:53:07 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:53:19 <ddarius> FunctorSalad_: All the Akali metals.
18:53:33 <gwern> holy shit that works
18:53:35 <FunctorSalad_> ddarius: will that work with snow too?
18:53:49 <FunctorSalad_> (as in solid water)
18:53:50 <ddarius> FunctorSalad_: Soon enough, probably.
18:54:14 <FunctorSalad_> yay, so we get a flaming avalanche after all
18:55:33 <Myoma> "Vital to success is not knowing that what you're doing is impossible"
18:56:20 <_JFT_> gwern: I look at your line and after that C++ metaprogramming is almost legible ;)
18:56:55 <gwern> heck, it's not *mine*
18:57:47 <FunctorSalad_> gwern: typechecking the subexpressions to figure out which Applicative it uses would be a start I guess
18:58:14 <FunctorSalad_> of course, the first step would be to figure out what the subexpressions are
18:58:24 <gwern> FunctorSalad_: expressions like that make me seriously consider whether I want to learn the more advanced bits of Haskell
18:58:40 <mauke> excellent perl code
18:58:43 <monochrom> Myoma: www.despair.com :)
18:58:49 <FunctorSalad_> gwern: yeah but I'd say that code is doing it 'rong
19:00:39 <gwern> despair! despair! this world of incomprehensible abstract operators has driven me to despair!
19:00:42 * gwern hangs self
19:01:11 <FunctorSalad_> despair.com is pretty funny
19:01:31 <monochrom> "You aren't being paid to believe in the power of your dreams."  :)
19:01:33 <mikv_> mm.. does data constructor refer to structure in imperative languages?
19:01:43 <Myoma> There was this game called despair, it's like lemmings but you don't save them
19:02:17 <mauke> struct+union+enum
19:02:21 <gwern> nice
19:03:09 <FunctorSalad_> monochrom: this one's deeply evil: "if you honestly believe that you can make up for a lack of talent by redoubling your efforts, then there's no end to what you can't do"
19:03:42 <gwern> @tell dcoutts_ ok, haddocks are working now.
19:03:42 <lambdabot> Consider it noted.
19:03:56 <gwern> just as well, if this third time hadn't worked, I'd have to call in my hitmen
19:04:16 <monochrom> hehe
19:08:02 <Myoma> > 1+1 * 2+2
19:08:05 <lambdabot>  5
19:09:51 <ddarius> -b+sqrt(b*b - 4*a*c) / 2*a
19:10:36 <chrisdone> I like this one “let's agree to respect eachother's views, no matter how wrong yours may be”
19:13:14 <monochrom> Procrastination: "laziness pays off now" :)
19:13:34 <_JFT_> monochrom: Golden for Haskell!
19:13:48 <FunctorSalad_> "if we don't take care of the customer, maybe they'll stop bugging us"
19:13:56 <gabor> anybody here who can hand out HackageDB accounts?
19:19:00 <TomMD> gabor: there is a web form for that.
19:19:38 <gabor> TomMD: I hav only found one that says I have to mail Ross
19:19:54 <FunctorSalad_> I think the uncyc Haskell page could do with a kitten huffing joke, but "instance (Huffable Kitten)" by itself is not funny
19:20:39 <gabor> TomMD: http://hackage.haskell.org/packages/accounts.html
19:20:40 <lambdabot> Title: HackageDB: User accounts
19:20:45 <TomMD> gabor: Ah, thats right.  Is ross not responding?  He took about a week for me if I recall.
19:20:55 <Twey> Is there a common solution to parsing command-line arguments?  Other than a big case..of?
19:21:15 <TomMD> Twey: There are a couple command line parser packages.
19:21:15 <_JFT_> file:///Users/jftremblay/Documents/Documentation/Lang/Haskell/libraries/base/System-Console-GetOpt.html
19:21:17 <gabor> TomMD: so far not, I applied earlier today
19:21:20 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
19:21:22 <lambdabot> Title: System.Console.GetOpt, http://tinyurl.com/y3585u
19:21:28 <Twey> Not helpful, _JFT_ :-P
19:21:32 <Twey> Thanks, mauke
19:21:35 <_JFT_> Twey:  :P
19:21:46 <_JFT_> Twey: forgot I had the link local lol
19:21:50 * Twey laughs.
19:21:59 <TomMD> gabor: Probaby just need to give him time - a day is pretty short turn around.
19:22:15 <gabor> yep, but is he the only one?
19:22:23 <TomMD> Out of curiosity, what package are you going to upload?
19:22:51 <TomMD> If ross were out for a long period of time I bet someone like dcoutts has access, but I'm not certain.
19:23:03 <gabor> TomMD: http://heisenbug.blogspot.com
19:23:08 <lambdabot> Title: don't count on finding me
19:23:10 <FunctorSalad_> doesn't the bot have an equivalent of :browse? (for use in queries only, of course)
19:24:10 <chrisdone> aw, hells yeah
19:24:19 <chrisdone> I'd never heard of :browse
19:24:35 <FunctorSalad_> it dumps all the declarations in a given module
19:24:45 <gabor> TomMD: even better: http://heisenbug.blogspot.com/search/label/thrist
19:24:46 <lambdabot> Title: don't count on finding me: thrist
19:28:22 <TomMD> I've got your draft thrist paper now - thank you.
19:28:28 <EvilTerran> gabor, noooo, more for my reading list :/
19:28:47 * EvilTerran collects interesting-looking FP-related papers
19:29:05 <gabor> np! :-)
19:29:13 <Myoma> EvilTerran: Calculating Compilers
19:29:21 <TomMD> EvilTerran: lol, perhaps the most evil thing one could do would be to link a bunch of interesting but fringe or less publicized PDFs here.
19:29:27 <EvilTerran> Myoma, i've already got that one somewhere
19:29:41 <EvilTerran> TomMD, eh... it's tempting, i must say >:)
19:29:42 <Myoma> you've not read it yet?
19:30:14 <EvilTerran> ... i skimmed it, at least
19:30:21 <EvilTerran> i think i then retained it for more detailed reading
19:37:47 * luqui cannot find Calculating Compilers anywhere...
19:38:09 <Myoma> it's on meijers site
19:44:06 <Myoma> ?go erik meijer Calculating Compilers
19:44:07 <lambdabot> http://research.microsoft.com/~emeijer/
19:44:07 <lambdabot> Title: My Homepage
19:44:38 <mrsolo> real world haskell..nov..WOOT!
19:44:50 <explicitjelly> just read it on reddit
19:45:43 <luqui> Myoma, thanks found it :-)
19:46:54 <adu> is TH recursive?
19:48:07 <luqui> adu, what do you mean by that?
19:48:32 <adu> like what will x = [|[|expr|]|] ; y = $($(x)) do?
19:48:53 <luqui> ah yes it does nest
19:48:59 <luqui> but not like that (IIRC)
19:49:08 <Myoma> ghci -fth
19:49:12 <Myoma> Prelude> let x = [|[|expr|]|] ; y = $($(x))
19:49:12 <Myoma> <interactive>:1:12: Not in scope: `expr'
19:49:26 <adu> try 3
19:50:17 <luqui> >>> :t [|$([|3|])|]
19:50:24 <luqui> [|$([|3|])|] :: Language.Haskell.TH.Lib.ExpQ
19:50:25 <adu> no, it parses as "$($x)"
19:51:59 <luqui> it seems you can only go one [||] deep, but you can weave in and out arbitrarily
19:53:27 <adu> this works: http://hpaste.org/9858
19:54:24 <explicitjelly> hm, what is TH?
19:54:33 <luqui> template haskell
19:54:44 <luqui> it lets programs inspect the syntactic structure of the code around them...
19:55:07 <luqui> adu, yeah, I think that means something different though
19:55:21 <explicitjelly> oh
19:55:25 <explicitjelly> I should look into that
19:55:26 <luqui> [| [| x |] |]  -- would give you the syntactic representation of [| x |]
19:55:45 <Myoma> explicitjelly: why?
19:58:50 <explicitjelly> Myoma, why what?
20:00:02 <LegendaryPenguin> can someone explain what the treemap definition here means  http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
20:00:03 <lambdabot> Title: Haskell/More on datatypes - Wikibooks, collection of open-content textbooks
20:00:22 <LegendaryPenguin> like, how does making it look like that make it "more readable"
20:05:04 <blbrown> hope the haskell book covers best practices.  I can't think like a haskeller to save my life
20:07:33 <twanvl> LegendaryPenguin: I agree that it doesn't really make it more readable. Factoring out parameters that don't change (like f in this example) becomes more useful in larger cases
20:07:48 <zandax_> I feeling dumb asking this question but anyways: I slowly need a "main loop" or rather no main loop because it's a Haskell program. What's the general technique? :/
20:08:09 <explicitjelly> zandax_, you could always just use recursion.
20:08:23 <EvilTerran> ?type forever
20:08:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:08:31 <EvilTerran> ?src forever
20:08:31 <lambdabot> Source not found. It can only be attributed to human error.
20:08:34 <EvilTerran> ...
20:08:52 <EvilTerran> forever m = m >> forever m
20:08:57 <zandax_> you mean like a monad which calls itself?
20:09:02 <EvilTerran> is a potentially useful combinator
20:09:09 <explicitjelly> zandax_, however, maybe you want to process a stream of some kind (even if you're waiting for input, it's still a stream of input), so you want something that consumes a list instead? think lazily!
20:09:10 <EvilTerran> (aka forever m = do m; forever m)
20:09:25 <EvilTerran> explicitjelly raises a good point
20:09:29 <zandax_> I want to make a small game
20:09:33 <EvilTerran> "forever" is probably not what you want
20:09:52 <zandax_> I need a loop to draw the map and check for key input
20:09:58 <EvilTerran> seeing as you'll presumably have *some* way of exiting short of SIGTERMing the program
20:10:20 <explicitjelly> zandax_, you could design ist such that the key inputs come in an infinite list
20:11:03 <EvilTerran> zandax_, the most direct solution would be to have an IO computation that calls itself, yes
20:11:03 <explicitjelly> [Up, Left, Up, Up, Down...]
20:11:09 <zandax_> No chance for an even more complex solution? ;)
20:11:31 <sclv> really real world haskell -- documentation of the denotational semantics of GHC IO vis a vis exceptions, signals, pipes, and handles.
20:11:32 <Trinithis> Is there a standard 'forever' that has type :: m Bool -> m (), where the bool value dictates whether or not to continue looping?
20:11:47 <explicitjelly> hmm, consuming such a thing is actually quite straightforward.
20:11:58 <explicitjelly> processInput Left:keys = ...
20:12:01 <explicitjelly> processInput Up:keys = ...
20:12:05 <sclv> there are oodles of little surprises -- and forget about reliable cross platform behavior!
20:12:24 <EvilTerran> zandax_, something like "loop = do {-loop body-}; if {-keep going-} then loop else return ()"
20:12:30 <Myoma> zandax_: If you want a loop that is fine and you can do this
20:12:44 <zandax_> ok
20:12:51 <EvilTerran> or indeed "when ({-keep going-}) loop", iirc
20:12:53 <EvilTerran> ?src when
20:12:53 <lambdabot> when p s = if p then s else return ()
20:12:59 <EvilTerran> ?index when
20:12:59 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:13:04 <explicitjelly> zandax_, well, yes, if you actually want a loop, just use recursion.
20:13:06 <Myoma> zandax_: recursion is looping, you can define a while loop or such using recursion, or you can just write the recursion directly
20:13:20 <sclv> EvilTerran: if you're in an error monad then forever does just what you want...
20:13:21 <EvilTerran> ... Control.Monad's the relevant one there, not that you really need it, it's just a minor convenience
20:13:39 <zandax_> At the moment I don't see any advantages in recursion over imperative loops, but hopefully I'll get behind it someday :)
20:13:41 <sclv> or actually, you could just loop in IO and throw a normal dynamic exception...
20:14:08 <EvilTerran> sclv, yes, you could do that if you wanted, but i felt introducing ErrorT or whatever that'd be necessary would only cause confusion
20:14:23 <Myoma> zandax_: imperative loops are an instance of something more general
20:14:30 <EvilTerran> zandax_, well, normal loops are kinda useless without side-effects :P
20:14:32 <sclv> for a beginner, sure.
20:14:34 <Myoma> zandax_: that more general (and simpler) thing, is recursion
20:14:37 <Trinithis> Isn't : loop m = m >>= \b -> if b then loop m else return () .... a decent combinator for this?
20:14:59 <sclv> but I've found myself using throwError more for exiting when working with trnasformer stacks.
20:15:55 <EvilTerran> Trinithis, i guess that'd be a sensible sort of thing for something like untilM
20:15:58 <EvilTerran> ?type until
20:16:00 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:16:18 <EvilTerran> untilM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a -- kinda thing
20:16:23 <Trinithis> ah
20:16:34 <EvilTerran> (not that that's defined anywhere, as far as i know)
20:16:50 <zandax_> Btw.: How do Haskell compilers and interpreters get along with recursion? I mean, they can't seriously do it for infinite loops!?
20:16:51 <Trinithis> I remember defining someething similar for an app a while ago
20:16:59 <Myoma> zandax_: Why not?
20:17:11 <zandax_> Because the stack is not infinite
20:17:13 <explicitjelly> if you want to make a simple concept scary, use greek letters and display it in latex's math font.
20:17:14 <Jedai> zandax_: They do something called tail-call optimization
20:17:33 <Myoma> zandax_: "the stack"?
20:17:34 <sclv> flip catchDyn (\e::ExitException -> return ()) . forever $ do ....
20:17:36 <zandax_> So they avoid it?
20:17:40 <explicitjelly> zandax_, loops like that get transformed into... loops :)
20:17:44 <zandax_> @Myoma: the CPU
20:17:44 <lambdabot> Unknown command, try @list
20:17:45 <Trinithis> They do clever things
20:17:48 <Trinithis> to fix these issues
20:18:02 <Myoma> zandax_: Haskell doesn't care about CPUs
20:18:02 <zandax_> I mean Haskell functions are also pushing addresses on the stack of course!?
20:18:09 <explicitjelly> zandax_, you don't need the stack if you don't want to do anything after coming back!
20:18:16 <Jedai> zandax_: Which take every recursive function that simply end up calling itself and just replace the last call on the stack instead of stacking it up (because you don't need it anymore)
20:18:35 <LegendaryPenguin> where is where defined
20:18:37 <sclv> ?go "tail call optimization"
20:18:38 <zandax_> @explicitjelly: But the compiler has to know that I'll not come back :)
20:18:40 <lambdabot> http://en.wikipedia.org/wiki/Tail_recursion
20:18:40 <lambdabot> Title: Tail recursion - Wikipedia, the free encyclopedia
20:18:40 <lambdabot> Unknown command, try @list
20:18:40 <Trinithis> zandax_: http://en.wikipedia.org/wiki/Tail_call_optimization
20:18:55 <explicitjelly> zandax_, but it knows, if the last expression evaluated is the recursive call!
20:19:14 <Jedai> zandax_: Every "loop" in imperative languages can be written in a tail-recursive form
20:19:22 <zandax_> I understand, thank you :)
20:19:30 <Myoma> is tail call optimization actually relevant to haskell?
20:19:47 <Trinithis> foldl
20:19:48 <sclv> as I recall, yes, but less often than in strict languages.
20:19:59 <Trinithis> cps
20:20:17 <Myoma> say you have
20:20:18 <sclv> forever
20:20:19 <Jedai> Myoma: Of course, though there are some factors that makes it less useful than in a strict language
20:20:24 <Myoma> (define (foo)
20:20:30 <Myoma>   (a) (b) (c) (foo))
20:20:39 <explicitjelly> Jedai, interesting... explain?
20:20:45 <Myoma> it's clear why you need tail calls
20:20:50 <sclv> hey, waitaminute! that's not haskell! what are you trying to pull here!?
20:20:53 <Myoma> in haskell you do not have this
20:20:56 <sclv> :-P
20:21:10 <Myoma> there is no sequence of events, only a single value
20:21:16 <Jedai> explicitjelly: See map() for example, it's not tail-recursive, but it still execute in constant stack space
20:21:26 <explicitjelly> @src map
20:21:26 <lambdabot> map _ []     = []
20:21:26 <lambdabot> map f (x:xs) = f x : map f xs
20:21:30 <Myoma> so where do tail calls come into it?
20:21:31 <explicitjelly> (for reference)
20:21:42 <explicitjelly> Jedai, interesting! how?
20:21:55 <Jedai> explicitjelly: On the other hand, foldl is tail-recursive but may accumulate a thunk that will blow the stack
20:21:55 <Myoma> and why must the TCO optimization even happen in haskell?
20:21:58 <EvilTerran> Myoma, they're not the whole story in lazy languages, but they are relevant
20:22:31 <Myoma> e.g. let f x = f x in f 3
20:22:38 <Jedai> explicitjelly: That's because the cons can immediately be returned, without evaluating the tail of the list
20:22:46 <Myoma> the evaluation needn't 'go inside' f and evaluate that and return something
20:22:58 <Myoma> but f 3 gets replaced with f 3
20:23:05 <explicitjelly> Jedai, aah. it seems that lazyness has a *lot* of advantages...
20:23:07 <Myoma> so TCO isn't happening here, at least I don't see it that way
20:23:13 <Jedai> explicitjelly: so only one call to map ever goes on the stack
20:23:33 <Jedai> explicitjelly: Well, as the case of the foldl demonstrate it also create some traps
20:23:55 <Myoma> what about foo = do print 'x' ; print 'y' ; print 'z' ; foo
20:24:12 <sclv> func x y = if x <=0 then y + 1 else func (x-1) (y+1)
20:24:22 <Myoma> It's _not_ a tail call, like the (print 'x) (print 'y) (print 'z) (foo) version
20:24:26 <Jedai> Myoma: example of TCO in Haskell : foldl (or better foldl')
20:24:33 <sclv> func x y = if x <=0 then y + 1 else 1 + func (x-1) y
20:24:34 <Myoma> but the garbage collection deals with it
20:24:46 <sclv> Myoma: do you see the difference in how the two will be evaluated?
20:25:21 <Jedai> Myoma: Of course it is, it ends up calling foo again after all
20:25:24 <Myoma> sclv: no
20:25:33 <Myoma> Jedai: not in tail position
20:25:46 <sclv> the latter will end up as (1 + ( 1 + (1 + etc...
20:25:48 <Myoma> @undo do print 'x' ; print 'y' ; print 'z' ; foo
20:25:49 <lambdabot> print 'x' >> print 'y' >> print 'z' >> foo
20:26:02 <sclv> the former accumulates in the parameter and so gets tcoed and keeps a constant stack.
20:26:19 <sclv> the latter can, for sufficiently really massive values of x, blow the stack.
20:26:21 <Myoma> sclv: I don't think that's TCO at all
20:26:27 <Jedai> Myoma: after some calls to >>=, it calls foo with only foo on the stack, so yes it is TCO
20:26:29 <Myoma> sclv: it seems like strictness to me
20:26:35 <sclv> buh?
20:26:57 <Jedai> Myoma: You should really reread the basis
20:27:41 <Myoma> Jedai: foo in my example there is not a tail call, so it can't be using TCO
20:27:51 <Jedai> Myoma: What sclv just showed you is a perfect (and often used) example of tail-call
20:27:53 <sclv> how is that strictness!? the example I gave would look the same way in e.g. scheme
20:28:56 <Jedai> Myoma: It is...
20:29:17 <Jedai> Myoma: It is a tail call, just like sclv example is
20:29:17 <sclv> Myoma: tail calls need not be recursive, remember...
20:29:19 <Myoma> func1 x y = if x <=0 then y + 1 else func1 (x-1) (y+1)
20:29:19 <Myoma> func2 x y = if x <=0 then y + 1 else 1 + func2 (x-1) y
20:29:26 <Myoma> *Main> func1 1000000 0
20:29:27 <Myoma> *** Exception: stack overflow
20:29:27 <Myoma> *Main> func2 1000000 0
20:29:27 <Myoma> *** Exception: stack overflow
20:29:56 <Jedai> Myoma: When foo is called by foo, it returns its result without further manipulation, so it is a tail call
20:30:18 <Myoma> sclv: they both stack overflow, tail calls aren't relevant to that example
20:30:31 <EvilTerran> Myoma, what about when you compile with -O2?
20:30:33 <sclv> myoma -- the fact that the first overflows is probably strictness!
20:30:47 <Jedai> Myoma: The func1 stack overflow is due to not enough strictness, the func2's one is due to accumulation of func2 calls
20:30:51 <sclv> if you wrote them as func1 !x !y and func2 !x !y then it would probably work out.
20:31:00 <EvilTerran> Myoma, ghc does no optimisations at all, afaik, unless you at least use -O1
20:31:07 <EvilTerran> (i may be wrong)
20:31:09 <Jedai> Myoma: In func1 case, what blows the stack is the thunk of (+)s
20:31:13 <sclv> alternately, if you forced the arguments to be ints, I think you would get strictness by default?
20:31:24 <Myoma> sclv: So as I _said_ earlier it's about strictness not TCO, so I don't know what you're saying "buh?" for
20:31:39 <sclv> Myoma: no! the first is about strictness, the second is about tco.
20:31:51 <sclv> i.e. the first, with proper strictness, wouldn't overflow.
20:31:52 <Jedai> Myoma: No, you don't understand, strictness and TCO are orthogonal subject
20:31:56 <sclv> the second... there's no helping
20:32:36 <Jedai> Myoma: TCO is relevant in a lazy language too, there's just some case where you don't need it and some case where you need to insist so that it works
20:32:43 <Myoma> Jedai: strictness and TCO are not orthogonal
20:33:07 <sclv> (and as this example proves, some cases where tco doesn't help you unless you *also* take strictness into account)
20:33:25 <Jedai> Myoma: the tail-call recursive nature of a function is exactly the same wether the language is lazy or strict
20:33:52 <Myoma> Jedai: I don't know what you mean by nature
20:34:01 <Jedai> Myoma: Besides you obviously don't understand TCO very well since you argued your foo wasn't one
20:34:06 <EvilTerran> P(f) := "f is tail-recursive"
20:34:11 <Myoma> Jedai: I do know that the same code in a strict or lazy setting can work completely differently
20:34:24 <EvilTerran> P(f) is independent of strictness of evaluation
20:34:38 <Myoma> Jedai,
20:34:42 <Jedai> Myoma: If you write the same function in OCaml and Haskell, wether it will have TCO or not won't change
20:34:45 <EvilTerran> (for all f)
20:34:49 <Myoma> print 'x' >> print 'y' >> print 'z' >> foo
20:34:52 <Myoma> in scheme notation
20:35:12 <Myoma> (>> (print 'x) (>> (print 'y) (>> (print 'z) foo)))
20:35:14 <Myoma> ioops
20:35:15 <joed> Hah, I love seeing tco in a language discussion.
20:35:17 <Myoma> (>> (print 'x) (>> (print 'y) (>> (print 'z) (foo))))
20:35:23 <Myoma> it's _obviously_ not tail recursive
20:35:41 <Jedai> Myoma: It obviously is...
20:36:16 <sclv> Myoma: introducing laziness also never turns termination into non-termination (assuming a sufficient stack). on the other hand introducing strictness can in fact turn termination into non-termination.
20:36:17 <Myoma> Jedai: My definition of tail recursive comes from R5RS scheme, are you using a different definition that only makes sense in a lazy language?
20:36:29 <sclv> Myoma: it is a tail call, but it is not recursive
20:36:34 <Jedai> Myoma: Even in scheme it is
20:36:46 <Myoma> sclv: It is not a tail call
20:36:52 <sclv> foo is in the tail position
20:36:55 <Jedai> Myoma: It is darnit
20:36:56 <Myoma> no it is not
20:37:02 <sclv> wtf?
20:37:09 <Myoma> >> is a function
20:37:19 <sclv> and foo is a function too
20:37:25 <FunctorSalad_> recursion is annoying anyway. I prefer something more abstract whenever possible
20:37:36 <Myoma> if you used begin instead of >> then yes it would be in the tail position
20:37:40 <zandax_> "loop = if 1 then return else do func1; loop" <- whats wrong with that :/
20:37:58 <Myoma> zandax_: must give a parameter to return
20:38:19 <dobblego> let foo = print 'x' >> print 'y' >> print 'z' >> foo -- this is not tail recursive
20:38:58 <Jedai> dobblego: Ok, in fact ou may be right in that foo isn't even a function
20:39:10 <zandax_> It's the "do" where Hugs is complaining. The loop returns an IO () Action. So what could I return?
20:39:16 <Jedai> dobblego: But if I make foo a function, let's say :
20:39:18 <Myoma> Jedai: How come I'm wrong and dobblego is right? We both said the same thing
20:39:19 <dobblego> let foo n = print 'x' >> print 'y' >> print 'z' >> (foo n) -- this is not tail recursive
20:39:27 <Jedai> dobblego: This is
20:39:40 <dobblego> it is not a tail call because >> is in tail position
20:39:43 <Jedai> dobblego: Ah ok, you're right this one isn't
20:39:45 <dobblego> not foo, but >>
20:39:57 <dobblego> Myoma, you're welcome :)
20:40:02 <Myoma> Jedai: *sigh* I guess I'm just a total idiot right?
20:40:12 <Myoma> dobblego: thank you for some sanity :)
20:40:19 <Jedai> let foo () = print 'x' >> print 'y' >> print 'z' >>= foo
20:40:34 <Jedai> here you have a tail-call recursion
20:41:23 <Jedai> It's a recursion and the result of the function is the result of the recursive call
20:42:28 <sclv> am I missing something or is this sort of silly because the >> gives you the foo which in turn gives you the recursion without consuming stack anyway?
20:42:46 <Jedai> let foo = print 'x' >> print 'y' >> print 'z' >> foo is not a recursion per se, but I would argue that it's still a case of TCO because once you make the necessary translation (for GHC mechanism for IO at least), it will be
20:42:49 <Myoma> sclv: I really think that the whole "stack" intution is wrong
20:42:57 <sclv> i.e. without tco then foo would eat stack, and with it then foo doesn't?
20:42:58 * EvilTerran notes that, in strict semantics, "until p f x = if p x then x else until p f (f x)" is tail-recursive, but "foo p f x = bar (foo x)" is clearly not -- but then, in haskell, you could say "bar y = if p x then x else y" and it'd be tail recursive again
20:43:09 <Myoma> sclv: It makes sense for strict languages that actually have call stacks, but it's just plain wrong for a lazy one
20:43:17 <EvilTerran> kinda
20:43:22 <sclv> b-b-but haskell *does* have a call stack1?
20:43:32 <Myoma> remember the 'stack' in haskell is a flattened version of a _cyclic_ graph
20:43:34 <Jedai> Myoma: There still is a stack in Haskell you know ?
20:44:03 <Myoma> Jedai: not sure what you're getting at
20:44:06 <Jedai> Myoma: Most of the cycle business goes on in the heap
20:44:09 <Myoma> Jedai: STG or what?
20:44:22 <Cale> The way I think of it, the stack builds up as you descend through an expression to find a redex.
20:45:03 <adu> redux?
20:45:06 <Jedai> Myoma: Can we at least agree that sclv example (func1 func2) was an example of TCO (even if it was thwarted by lazyness without optimisation), you don't even seem to agree with that
20:45:43 <Cale> adu: reducible expression
20:45:46 <Myoma> EvilTerran: I'm going to say the whole notion of tail position is completely irrelevant in lazy languages
20:45:57 <Cale> "tail position"?
20:45:59 <Jedai> Myoma: And you're obviously wrong
20:46:07 <adu> Cale: o
20:46:08 <Myoma> EvilTerran: the analogue we get of TCO is rather different
20:46:13 <sclv> then how would you discuss foldr vs foldl' ?
20:46:38 <Myoma> Jedai: You assuming I don't know what I'm talking about makes it very hard for us to communicate effectively
20:47:06 <sclv> I guess that we could replace the notion of "calling a function" with "evaluating a thunk"...
20:47:33 <Cale> I don't like talking about thunks so much. Just call them expressions :)
20:47:35 <sclv> and the "call stack" becomes the context of partially evaluated thunks...
20:47:36 <adu> cool down, its just characters on a screen... no heart feelings...
20:47:39 <Myoma> sclv: yeah calling a function is definitely not something that makes sense in haskell
20:47:51 <Jedai> Myoma: Well, when you're telling me that the example of sclv is not an example of TCO, I don't really think you're really knowing what you're speaking about
20:48:00 <Myoma> sclv: taking the entire program and reducing it to successive WHNFs is a better intuition
20:48:43 <Myoma> Jedai: If we were talking about lisp or ocaml, then yes one was a tail call and doesn't blow up, the other will overflow since TCO didn't apply
20:48:44 <EvilTerran> sclv, yes, that would work more tidily in general than saying "calling a function" in this sort of context
20:48:50 <EvilTerran> (generalising over evaluation rules)
20:48:53 <adu> I think I thunk I saw a putty-tat
20:48:56 <Myoma> Jedai: that's not what happens here, run them both, they both crash
20:48:58 <Jedai> Myoma: Well, maybe to reason about the program in the abstract or in another evaluation model, but in GHC model you still have a call stack and you still have a TCO that's very relevant
20:49:15 <sclv> ok so I guess insofar as we think the word "call" is imprecise, then obviously TCO is imprecise as a term.
20:49:20 <Jedai> Myoma: With proper strictness on the parameters the TCO one doesn't ok ?
20:49:33 <EvilTerran> sclv, although, as others have said, there's equivalents that don't rely on such implementation-tasting words as "thunk"
20:49:45 <Cale> Isn't calling just substituting into the body of a function?
20:49:54 <Cale> (with sharing)
20:50:04 <adu> does TCO = tail-call optimization?
20:50:20 <Myoma> adu, yes
20:50:20 <Jedai> Myoma: Have you even tried ? The TCO one doesn't crash because the func call blows the stack, it crash afterwards when we try to evaluate the big thunk of (+)
20:50:33 <Myoma> Jedai: I pasted my results a short while ago
20:50:48 <sclv> reducing does capture both the evaluating and the throwing-away bit, so is a superset of TCO in that sense.
20:50:55 <Jedai> Myoma: You don't seem to understand that there is a difference !
20:51:41 <Cale> Yeah, foldl is tail recursive, and does not on its own blow-up the stack. The foldl creates a large expression in which the outermost reducible expression might be very deep.
20:51:51 <Jedai> Myoma: The TCO one has the optimisation, it's just that lazyness thwart its advantage, but it's easy to remedy by adding a little bit of strictness, the non-TCO one can't be corrected
20:51:55 <Cale> It's traversing down into that resulting expression which blows up the stack.
20:52:17 <FunctorSalad_> ... with unsafeLaunchMissiles
20:52:44 <Guest34301> any good references for understanding haskell-core?
20:52:46 <Myoma> Jedai: it should be completely clear by how often strictness is mentioned, and that (+) is strict that strictness is highly relevant to that example and we were talking about TCO, not strictness
20:52:53 <sclv> but since you don't *need* to throw away things to get an answer, just as you don't *need* tco, then you could say that "throwing away the stuff you're done with" is the moral equiv. of tco
20:53:34 <Cale> But tail-calling functions are often overrated, since they run for a long time before producing anything at all, rather than producing part of their output quickly.
20:53:37 <Jedai> Myoma: in this example TCO and strictness are relevant, but strictness and TCO aren't the same subject
20:53:44 <Myoma> Jedai: I'm saying the two go hand in hand, in particular with lazy data and lazy functions the whole idea of tail calls is irrelevant
20:54:03 <sclv> Guest34301: have you looked at the ghc-wiki?
20:54:04 <Myoma> we must have a different intutition
20:54:15 <Guest34301> not yet
20:54:33 <Jedai> Myoma: It obviously isn't since we can perform TCO
20:54:52 <Cale> Myoma: foldl can build a large expression very quickly in a tight loop
20:55:01 <Cale> Myoma: even if it's not strict
20:55:05 <Myoma> Jedai: when the language works by graph reduction, TCO isn't the name of what's happening
20:55:06 <Jedai> Myoma: And TCO function never accumulate calls to themselves
20:55:15 <sclv> http://hackage.haskell.org/trac/ghc/wiki/BackEndNotes ^^ tail calls in GHC. I don't know if they're in the report though... so we can maybe chalk it up as "implementation detail"?
20:55:20 <lambdabot> Title: BackEndNotes - GHC - Trac
20:55:30 <Toxaris> Myoma: I strongly disagree, the idea of tail calls is quite helpfull for me when trying to write sensible code. Of course, one has to take the strictnes properties of each function into account, just as in every other language (e.g. boolean shortcut evaluation or non-strict semantics of if-then-else)
20:55:33 <Myoma> It's TCO when you compile a call (read, something which creates a new call stack frame) into a jump
20:55:37 <adu> whats haskell-core?
20:55:41 <Jedai> Myoma: In GHC at least it is and it corresponds directly to what happens in OCaml or other functional languages (Scheme)
20:55:45 * sclv doesn't even think the report mandates garbage collection
20:56:06 <Jedai> Myoma: Yeah, well that's what happen with TCO in GHC gee !
20:56:12 <Cale> For example, consider  foldl (flip (:)) []
20:56:33 <sclv> Guest34301: I'd check out the ghc wiki for sure, but also just look at core generated for really simple programs...
20:56:42 <Jedai> adu: A tool to pretty-print the internal representation of your code in GHC (simplified)
20:56:49 <Guest34301> ok thanks
20:57:22 <Cale> That builds a very large expression quickly, but that expression won't generally cause a stack overflow, because it quickly produces a constructor.
20:57:58 <Cale> (after the first flip (:) evaluates, you can pattern match, and so the stack never gets very deep)
20:58:10 <adu> Jedai: oooo like a fancy (Show (Q a))?
20:58:47 <Jedai> adu: I don't think so (Q is a TH thing no ?)
20:59:24 <Cale> Myoma: does that make sense?
20:59:29 <Jedai> adu: GHC translate your code in a simplified form called Core, which it then simplify and optimize, that's what haskell-core pretty print
20:59:36 <Myoma> Cale, no, I don't understand
20:59:54 <Myoma> @src foldl
20:59:54 <lambdabot> foldl f z []     = z
20:59:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:59:56 <adu> oooo so Core : GHC :: Tree : GCC?
21:00:02 <Myoma> Cale, How can that produce a constructor without reaching the f z [] case?
21:00:17 <Jedai> Myoma: A function that is tail-recursive in Haskell won't accumulate call to itself on the stack
21:00:23 <Cale> Myoma: well, let's evaluate by hand
21:01:03 <Cale> foldl (flip (:)) [] [1,2,3] --> foldl (flip (:)) (flip (:) [] 1) [2,3] --> foldl (flip (:)) (flip (:) (flip (:) [] 1) 2) [3] --> foldl (flip (:) (flip (:)) (flip (:) (flip (:) [] 1) 2) 3) []
21:01:11 <Cale> --> (flip (:) (flip (:)) (flip (:) (flip (:) [] 1) 2) 3)
21:01:32 <Cale> all of the previous (save perhaps the last step) happened in a nice tight loop, no stack
21:01:54 <Cale> now, we start evaluating this expression
21:02:07 <Cale> (:) 3 (flip (:)) (flip (:) (flip (:) [] 1) 2)
21:02:36 <Cale> and we've reached a constructor, and so can start pattern matching
21:02:50 <Cale> (pattern matching is essentially the only reason you evaluate anything)
21:03:05 <Cale> So there's no reason for the stack to build up at any point.
21:03:15 <Cale> But there will be large expressions building up on the heap.
21:03:42 <Cale> There's never a point where the outermost function can't be evaluated immediately.
21:03:52 <Cale> (that's what causes things to go on the stack)
21:04:42 <Cale> The reason that it's different with (+) is that...
21:05:14 <Myoma> Cale, so, foldr Cons Nil [1,2,3], as an example of something that takes up stack?
21:05:29 <Cale> foldl (+) 0 [1,2,3] --> foldl (+) (0 + 1) [2,3] --> foldl (+) ((0 + 1) + 2) [3] --> foldl (+) (((0 + 1) + 2) + 3) [] --> ((0 + 1) + 2) + 3
21:05:42 <Cale> Now, evaluating  ((0 + 1) + 2) + 3  *will* take up stack.
21:05:59 <Cale> This is because (...) + 3 can't be reduced immediately.
21:06:04 <Jedai> Myoma: No, that's the same, it never takes up stack (but there's no TCO in this case, it's pure lazyness magic)
21:06:21 <Cale> So it has to go on the stack and wait for ((0 + 1) + 2) to evaluate.
21:06:27 <sclv> > foldl f a [1,2,3,4,5] :: Expr
21:06:29 <lambdabot>  f (f (f (f (f a 1) 2) 3) 4) 5
21:06:45 <Cale> foldr Cons Nil [1,2,3] also won't take any stack.
21:07:12 <Cale> In fact, it doesn't even need to loop before it's in WHNF
21:07:28 <Cale> foldr Cons Nil [1,2,3] --> Cons 1 (foldr Cons Nil [2,3])
21:07:30 <Cale> done :)
21:07:39 <Myoma> in that case, foldl (+) 0 [1..]  should give a heap overflow?
21:07:50 <Jedai> Myoma: Yes
21:08:02 <Cale> foldl (+) 0 [1..] may give either a heap or stack overflow
21:08:10 <Cale> er
21:08:21 <Cale> actually, yeah, heap... didn't notice that the list is unending :)
21:08:21 <Toxaris> how can it give a stack overflow?
21:08:22 <Jedai> Myoma: It could also swap your computer to death...
21:08:22 <Myoma> oops I meant to ask about  foldl (flip (:)) [] [1..]
21:08:33 <sclv> I don't think we get heap overflows... at least not in ghc?
21:08:46 <Cale> sclv: well, I assume he means that the machine runs out of memory
21:08:53 <Guest34301> how do you change what dependecy dlls ghci tries to load? its tring to load GL.dll and it should be opengl32.dll probably
21:08:57 <sclv> right.. I'm just being nitpicky.
21:08:58 <Jedai> sclv: Yeah, I think it just kill your computer...
21:09:13 <Guest34301> (ghc --make works fine)
21:09:14 <Cale> Myoma: yeah, that'll build up a huge huge expression
21:09:25 <Jedai> sclv: Actually I'm not sure you can't fix the maximum amount of heap with a runtime option
21:09:30 <Cale> Myoma: and will never get to the point of reducing to an application of a constructor
21:09:43 <Cale> (because the head will always be foldl)
21:09:50 <Myoma> why have a heap and a stack rather than just a heap?
21:10:31 <Jedai> Myoma: That's the model the GHC people choose, you could concevably do something else
21:10:44 <Cale> Yeah, you could.
21:10:48 <sclv> Jedai: ah yes, you can set it...
21:10:52 <Jedai> Myoma: I think every implementation of Haskell does though
21:11:10 <Myoma> oh you've got a heap of expressions and then something like a C program (with a stack) which is evaluating the bits inside the heap?
21:11:11 <Jedai> I mean they have a call stack
21:11:57 <Jedai> Myoma: I guess you could see it like that (except I don't see why a *C* program but well...)
21:12:07 <Myoma> just because haskells RTS is written in C
21:12:34 <Jedai> GHC RTS is
21:16:00 <sclv> but the GHC RTS in C doesn't do its main evaluation in a stack... but in a great big beautiful state machine.
21:18:39 <zandax_> Are there any HGL users in here and does someone know how to check for keypresses without program interruption? :(
21:30:52 <cmcq> is there a nice way to phrase the property of f that f will only ever be the first term in a reduction of f x, "in a way that f is responsible for", ie. dealing with the case when x evaluates to an expression including f?
21:36:58 <Twey> 37 lines of opt-parsing code >.<
21:37:16 <Twey> Out of a 54-line module, heh
21:40:14 <adu> hmm
21:41:01 <adu> so if Core uses 'z' as an escape char, then how does it represent 'zoo'? as 'zzoo'?
21:42:49 * Twey snrks.
21:42:56 <Twey> 'z' is an escape char?  What?
21:44:47 <explicitjelly> is do x <- foo; x <- bar x legal if I don't care about the first binding of x anymore, or should I use a unique name for every binding?
21:45:28 <explicitjelly> it would save me a lot of x <- .. x' <- .. x'' <- .. x''' <- .. stuff
21:45:38 <explicitjelly> (I want to easily comment out steps)
21:47:56 <Twey> explicitjelly: It becomes foo >>= \x -> bar >>= \x ...
21:48:09 <Twey> So yes, it's legal, the latter just shadows the former
21:48:13 <explicitjelly> ah, thanks
21:49:22 <FunctorSalad_> maybe you're better off with "foo >>= bar >>= baz >>= gazonk" instead of the do?
21:50:42 <explicitjelly> no, it's better with sugar here
21:51:25 * Twey chuckles at 'gazonk'
21:53:09 <FunctorSalad_> Twey: know the etymology by chance?
21:59:14 <Twey> Nay, FunctorSalad_
21:59:20 <Twey> Care to share it?  :)
21:59:42 <FunctorSalad_> I don't know it either, I just use the word. that can be dangerous, so I'm asking ;)
22:01:35 <Twey> Ah, heh
22:01:51 <Twey> FunctorSalad_: Ah, here we go
22:02:08 <Twey> FunctorSalad_: Early versions of emacs set the filename to 'gazonk.foo' by default
22:05:59 <adu> lol
22:06:58 <adu> Twey: apparently, I continued reading and "unsafeFreezzeArrayzh" answered my question...
22:07:12 * Twey snorts.
22:07:27 <adu> Twey: which is the GHC mangled name for unsafeFreezeArray#
22:07:32 * Twey nods.
22:31:12 <Trinithis> anyone got any good dark themed desktop backgrounds by any chance?
22:31:38 <Twey> Trinithis: http://i38.tinypic.com/2ih2f40.jpg
22:31:45 <Twey> Y'know, the one thing that irritates me is how much stuff ends up in IO
22:31:49 <dons> "If I can get more than 20 downmods, I'll believe that more than 20 people actually code in Haskell. Until then, go hang out with the Esperanto people."
22:31:52 <dons> http://www.reddit.com/r/programming/comments/6xjrl/real_world_haskell_the_last_chapter_is_up_and/c0554mj
22:31:54 <lambdabot> Title: adonis88 comments on Real World Haskell: the last chapter is up, and ... we're d ..., http://tinyurl.com/5my6mm
22:31:57 <dons> sounds like an invitation :)
22:32:00 <Myoma> :/
22:32:09 <Twey> Are there any good design patterns to keep stuff out of IO?
22:32:27 <Trinithis> Twey: is that yours?
22:32:54 <Twey> Someone asked for a Haskell wallpaper earlier so I hacked it up quickly
22:33:17 <Trinithis> Did you hack it up using Haskell only???
22:33:25 <Twey> Hahaha
22:33:27 <Twey> GIMP :)
22:33:30 <Trinithis> That would be 1337er than gimp
22:33:58 <Twey> Aye
22:34:02 <Twey> Design patterns?  Anyone?
22:34:35 <Trinithis> You forget, you don't need design patterns in functional programming :D
22:34:38 <Twey> Haha
22:34:45 <olsner> there's the fold, and the monad
22:34:47 <Twey> But you *do*, otherwise everything ends up in IO
22:35:18 <Trinithis> What's you code look like?
22:35:19 <olsner> hmm, so you have the "don't put everything in IO" design pattern as well :P
22:35:56 <Twey> I was just writing a bot plugin, and I wanted to make it pretty so instead of forking off into IO I had it take a pure callback that would take a message and respond with a list of messages to send back
22:36:23 <Twey> And then I realised that if I wanted to do anything more complex in the future that had to be inside IO
22:36:34 <Twey> So I'm practically forced to put it into IO for extensibility :-\
22:37:02 <Trinithis> What about returning IO x from a pure function. Is that avaliable instead?
22:37:09 <dons> if you want to allow arbitrary extension, yeah.
22:37:11 <Trinithis> err....
22:37:13 <Twey> Trinithis: Erm
22:37:19 <Twey> Then it's in IO :-P
22:37:20 <dons> you might want to distinguish effectful and pure extensions though
22:37:27 <dons> since you can do more things with the pure ones.
22:37:44 <Twey> dons: So I should branch and have registerResponder and registerResponderIO?
22:37:52 <dons> maybe, yes. xmonad does that.
22:37:59 <Twey> Hmn
22:38:01 <Twey> I see
22:38:02 <Twey> OK, thanks
22:38:06 <dons> i bet most plugins are pure
22:38:08 <Twey> I'll do that
22:38:10 <dons> so you want to encourage that.
22:38:11 <Twey> Mm
22:38:14 * Twey nods.
22:38:24 <dons> otherwise quality goes down hill
22:38:30 <Twey> Aye
22:39:38 <Twey> Got kind of worried that in the last few modules I wrote, only one function has been pure :-\
22:39:41 <Twey> And it was a helper
22:40:05 <Twey> That was quite IO-intensive, admittedly
22:40:59 <solrize> > mapM_ putStrLn$reverse[(++)([1..y-30]>>" ")$concat$map([" "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
22:41:01 <lambdabot>  mueval: *** Exception: "<IO ()>"
22:41:14 <Myoma> > concat$reverse[(++)([1..y-30]>>" ")$concat$map([" "," /", " -", " \\"]!!)[(foldr(.)(scanl(+)1)([1..y]>>[scanl(+)0])[2..]!!(2*(1+y)+x))`mod`4|x<-[-y-2..59-y*2]]|y<-[30..61]]
22:41:16 <lambdabot>  "                                /                               / \\       ...
22:41:39 * araujo needs to pre-order this book
22:44:23 <christos> hi, i m trying to make hs-plugins-0.9.10 with ghc-6.8.3 and I get some problem about the STArray constructor, does anyone know if hs-plugins is incompatible with my ghc version?
22:55:03 <falseep> ﻿/msg nickserv identify fr33node
23:10:56 <geocalc> /msg ?
23:31:50 <zandax_> hm
23:32:10 <zandax_> How can I ignore a value when doing a pattern match via case of?
23:32:14 <Myoma> _
23:32:37 <Myoma> _ is a variable name unlike any other
23:33:29 <zandax_> thanks! I already used _ in another context :/ getting a feel for the syntax is hard
23:34:04 <zandax_> but what do I write to ignore it?
23:34:12 <zandax_> _ -> ignore?
23:34:47 <Myoma> _ -> error "pattern match fell through" -- something like that? You could just not write this line at all and you'd get that for free
23:35:07 <zandax_> yes I get that error
23:35:40 <zandax_> how do I ge around it?
23:35:57 <Myoma> what do you want instead of an error?
23:36:00 <mauke> I'd like to zoom out, please
23:36:22 <Myoma> mauke, is that from bladerunner ?
23:36:30 <mauke> er, I don't think so
23:36:46 <Trinithis> I just downloaded frag... I couldnt find any monsters :(
23:36:53 <zandax_> I am checking for key presses and when no key was pressed I'm matching a 0
23:37:32 <zandax_> so I want the 0 to be ignored
23:37:43 <Myoma> zandax_: so like:  return ()
23:37:48 <Myoma> @hoogle xor
23:37:48 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
23:38:13 <zandax_> but when I am using return the rest of the monad is not executed :|
23:38:26 <mauke> what?
23:39:01 <mauke> > runIdentity (do { return (); return (); return "gargle" })
23:39:03 <lambdabot>  "gargle"
23:39:48 <zandax_> I am using a monad to check for key presses and do other stuff. When no key is pressed the other stuff should be executed as always.
23:42:00 <explicitjelly> zandax_, everything after "return" is still "executed".
23:43:24 <zandax_> I don't get it. :/
23:43:34 <mauke> get what?
23:43:38 <zandax_> It seems to work but how do I leave the monad then?
23:43:54 <mauke> do you mean the do block?
23:43:55 <Myoma> You do not leave the monad
23:44:41 <zandax_> can I perhaps past the monad?
23:46:17 <zandax_> http://rafb.net/p/KY7WYD34.html <- heres the problem
23:46:18 <lambdabot> Title: Nopaste - No description
23:46:47 <telofy> yeah, I'm not really getting this _ either: In many cases, like seq or >> it is used to still evaluate some expression, but throw away the result, yet there is "False && _ = False" in the Prelude. I thought with those Operator laziness would work...? If not, what to use, if I really want laziness there?
23:47:00 <aeolist> “Haskell is compiled from .hs-files which means HOMO SEXUAL”
23:47:01 <aeolist> ~ Oscar Wilde on Haskell
23:47:06 <aeolist> zomg
23:47:11 <aeolist> http://www.reddit.com/goto?rss=true&id=t3_6xkhm
23:47:12 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
23:47:22 <mauke> zandax_: case key of { 0 -> drawMap w level 0; mainLoop w; 1 -> return () }
23:47:39 <mauke> er, case key of { 0 -> do { drawMap w level 0; mainLoop w }; 1 -> return () }
23:48:08 <zandax_> I see. It's that simple :)
23:48:17 <mauke> telofy: how does seq use it?
23:48:25 <zandax_> I still think completly imperative! :/
23:48:40 <explicitjelly> "Haskell is a dialect of COBOL, which it superficially resembles, and an embodiment of the Zeta-Calculus." hah? %)
23:48:55 <aeolist> you didnt know?
23:49:21 <aeolist> is there also a #haskell-beginners or is this chan a free-for-all
23:49:25 <zandax_> @mauke: But what to do when I'm checking for multiple key presses?
23:49:26 <lambdabot> Unknown command, try @list
23:49:43 <explicitjelly> Well, I knew that it was a dialect of COBOL, but I didn't know it was related to Zeta-Calculus (according to the site: "Zeta-Calculus refers to the equations where the variable (no so variable in some cases, which defies some physical laws) is represented by the Z letter.")
23:49:45 <zandax_> :/
23:49:55 <explicitjelly> had I known, I had used the variable Z more often
23:50:08 <aeolist> z:zs is the new trend
23:52:06 <telofy> mauke, I saw seq using it in some version of the Prelude, searching, please stand by
23:53:42 <telofy> mauke, "seq _ y = y"
23:53:49 <telofy> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Prelude.html#seq
23:53:51 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/57672j
23:55:11 <telofy> still I'm confused about this occasional laziness with "_"...
23:55:55 <explicitjelly> why does seq eliminate "unwanted laziness"?
23:56:18 <telofy> perhalps in the same way >> does
23:56:33 <telofy> resp for the same reasons
23:57:09 <mauke> telofy: that isn't seq
23:57:11 <explicitjelly> which are=
23:57:12 <explicitjelly> ?
23:58:12 <mauke> telofy: the definition is wrapped in #ifdef __HADDOCK__, which means it's purely for documentation purposes
23:58:13 <telofy> if you want an expression to be evaluated, but you are not interested in the result, for example with io or stuff
23:58:30 <explicitjelly> mauke, ah. ok. thanks.
23:58:35 <explicitjelly> I was really getting confused there.
23:58:40 <telofy> mauke, ok, then lets stick to >> as an example, sry
23:59:56 <mauke> zandax_: when (key /= 1) $ do { case key of { 0 -> ... }; drawMap w level 0; mainLoop w }
