00:16:54 <cjs> Ah, ok, so I do want to move the dist directory.
00:17:54 <cjs> Any thoughts on how one might do that?
00:18:04 <cjs> (For Cabal, I mean.)
00:24:08 <sjanssen> preflex: seen dcoutts_
00:24:08 <preflex>  dcoutts_ was last seen on #haskell 5 hours, 58 minutes and 2 seconds ago, saying: noecksit_: unregister with ghc-pkg and delete files with rm. If you want something better you can help us write the code to track installed files.
00:24:21 <sjanssen> @localtime dcoutts_
00:24:22 <lambdabot> Local time for dcoutts_ is Thu Aug 21 08:24:30
00:24:31 <name_> are there any compiler/rt options that control floating point accuracy?
00:25:32 <sjanssen> name_: -ffast-math comes to mind
00:26:01 <sjanssen> (this allows intermediate results to be kept in floating point registers, which are often slightly larger)
00:26:40 <name_> thanks
00:34:46 <Deewiant> http://www.reddit.com/comments/6xb3r/what_do_you_lispers_think_of_haskell_discussion/
00:34:48 <lambdabot> Title: What do you LISPers think of Haskell? - Discussion : reddit.com, http://tinyurl.com/5amxmr
00:35:50 <cjs> Hm. Where is all of the Cabal source does it decide on the directory name "dist"?
00:39:19 <Wild_Cat> Deewiant: heh. Not even 5 posts in the thread and Xah Lee is already plugging his blog with a "[language] sucks 'cause it's not Lisp" rant.
00:39:42 <Deewiant> Wild_Cat: Harrop doesn't hesitate in posting about GHC's switch to git, either :-)
00:40:33 <cjs> Ah, Simple.LocalBuildInfo.distPref. And it appears to be hard-coded.
00:40:36 <sjanssen> clearly somebody needs to make sweet, sweet love to Haskell
00:40:52 <cjs> Clearly.
00:41:07 <cjs> Maybe lambdabot can do it. Or would that be incest?
00:41:29 <sjanssen> probably
00:45:18 <Wild_Cat> Deewiant: so in the end they're switching to git? Meh.
00:45:35 <b\6> yeah, but meh @ waiting 3 years for stuff to download, too.
00:46:03 <b\6> i wonder what david's reaction was.
00:47:05 <Wild_Cat> yeah, darcs get takes ages and that's a shame. But git in itself is just... Meh. Feels like the spawn of Linus suffering from NIH syndrome while looking at Mercurial.
00:47:13 <cjs> Yikes. "Could not find module `Data.Maybe': it is a member of package base, which is hidden"
00:47:26 <cjs> So do I actually have to explicitly specify in my .cabal file that my program uses Data.Maybe?
00:47:40 <Wild_Cat> (not that it's a bad SCM whatsoever, developing it just looks like a tremendous waste of time to me)
00:47:46 <cjs> No, just that it uses base, right?
00:48:12 <opqdonut> Wild_Cat: git and darcs are the only scms that have a proper achitecture
00:48:16 <opqdonut> the rest are just kludgepiles
00:48:23 <chr1s> cjs: yeah, just say that it uses base
00:48:29 <BeelsebobWork_> opqdonut: what about mercurial?
00:48:33 <opqdonut> git is a bit baroque, but it's powerful and flexible
00:48:33 <cjs> Why don't they show that in the examples?
00:48:49 <cjs> Is there a way to say that every Executable section uses base, or do I have to specify it individually for each one?
00:49:03 <osfameron> I thought svk had an architecture
00:49:15 <chr1s> cjs: you always have to specify it, I think.
00:49:18 <osfameron> though when I saw clkao talking about it my brane exploded, so I could be wrong
00:49:55 <cjs> Oh, gawd.
00:50:23 <opqdonut> BeelsebobWork_: well it too, especially branching can be quite hairy IIRC
00:50:33 <BeelsebobWork_> eh?
00:50:43 <BeelsebobWork_> it's distributed -- branching is the same as in any distributed system
00:50:55 <BeelsebobWork_> you just take a copy of the repo, and you're done
00:51:26 <Wild_Cat> opqdonut: my main gripe with git is that it's written in C and shell scripts, which guarantee crap portability and atrocious performance on Windows (if it even runs there).
00:51:59 <b\6> Wild_Cat: thought it was lots of perl, too.
00:52:49 <Wild_Cat> Perl!?
00:52:51 <opqdonut> Wild_Cat: errr come again?
00:52:59 <opqdonut> how does that guarantee atrocious performance?
00:53:12 <Deewiant> Wild_Cat: it seems to run surprisingly well on windows, based on my (very limited) testing
00:53:21 <Deewiant> spawns only one process for most tasks
00:53:37 <BeelsebobWork_> opqdonut: C is fairly slow on both windows and Mac OS -- or at least traditional C with mallocs and frees
00:53:44 <BeelsebobWork_> because malloc is slow on both platforms
00:54:06 <mgsloan> uhh, what is faster than C, on those platforms?
00:54:07 <Deewiant> I'd say the shell scripts would cause much more slowness on windows
00:54:08 <Wild_Cat> opqdonut: mostly because the only way to "do" shell scripts on Windows is through Cygwin, which emulates forking with disastrous performance (spawning new processes is very expensive on Windows).
00:54:33 <BeelsebobWork_> mgsloan: well, the debian language shootout's code says Haskell is about 2 times faster than C on Mac OS
00:54:34 <Wild_Cat> see http://en.wikipedia.org/wiki/Git_(software)#Portability
00:55:14 <osfameron> Wild_Cat: there are several native windows scripting platforms too... (ok, not "shell" in the sense of unix bash)
00:55:21 <mgsloan> Beelsebob - for a few bytestring fusionable problems, perhaps :P
00:55:50 <BeelsebobWork_> mgsloan: nope, on pretty much every problem the Haskell is faster -- the only ones where it comes out slower, are the ones where malloc is not called
00:55:53 <Wild_Cat> osfameron: yeah, but git uses bash.
00:56:04 <Wild_Cat> which relies heavily on forking.
00:56:28 <osfameron> Wild_Cat: yeah... I started replying having read a comment of yours out of context
00:57:18 <osfameron> isn't there also a windows port of git (the core ideas, but coded as an executable rather than a unix-specific shell thingy) ?
00:57:34 <BeelsebobWork_> mgsloan: the idea that Haskell is a slow language is a myth -- it's one of the fastest out there
00:57:47 <cjs> If you're a reasonably careful programmer.
00:57:52 <mgsloan> I'm getting haskell at 3.2x the runtime of C++
00:58:07 <cjs> Nobody who's not familiar with machine architecture at the level of a C programmer is going to get consistently fast code.
00:58:17 <mgsloan> yeah, haskell's processor and memory behavior is nonobvious
00:58:23 <BeelsebobWork_> I dunno -- maybe my code naturally drops into the "reasonably careful" cattegory -- but I've only had one major performance problem, and that was because I was doing the most na√Øve OpenGL possible
00:58:41 <Wild_Cat> osfameron: I *think* they may be working on that. Kind of. The fact remains that Mercurial, which does almost exactly the same thing but is written in a platform-agnostic language (Python), works out of the box on Windows too. :p
00:59:09 <mgsloan> I'm not new, and I'm not saying haskell's not performant, just the statement that C is slow is rediculous
00:59:11 <BeelsebobWork_> now Python -- that's a slow language
00:59:15 <mgsloan> true
00:59:18 <cjs> Oh, I get nailed by space leaks all the time.
00:59:33 <cjs> Well, not all the time, but three times in a bad way in as many months.
00:59:38 <BeelsebobWork_> mgsloan: I didn't say C was slow -- merely that on OS X, it's slower than haskell unless you're very very careful how you deal with heap allocation
00:59:44 <Wild_Cat> BeelsebobWork_: yet Mercurial has similar performance to git. (read: blows darcs out of the water ;) )
00:59:58 <BeelsebobWork_> Wild_Cat: darcs 2 is just as fast as either of them though
01:00:01 <cjs> But solving those is no worse than solving other dumb performance problems in other languages.
01:00:29 <Wild_Cat> which, I guess, leads to the question: if performance was the problem, why isn't ghc switching to darcs 2?
01:00:58 <BeelsebobWork_> at a guess, because it looks like darcs isn't getting the maintainance it deserves any more
01:01:07 <BeelsebobWork_> (while this is true or not is irrelevant, it looks that way)
01:02:01 <b\6> https://lopsa.org/node/1656
01:02:02 <lambdabot> Title: darcs: a study in communication failure | League of Professional System Administ ...
01:02:44 <b\6> it was probably a really bad idea to announce he was going to autotrash everything except patches.
01:02:54 <BeelsebobWork_> yep
01:04:09 <BeelsebobWork_> tbh, I've never had a problem with darcs performance, but I guess nhc/hat's repository is significantly smaller than ghc's
01:04:38 <Wild_Cat> well, darcs get takes bloody ages no matter what you try to check out.
01:04:52 <BeelsebobWork_> only time I've noticed that is on code.haskell.org
01:04:58 <BeelsebobWork_> and that's because c.h.o is often slow as crap
01:05:38 <Wild_Cat> every single piece of software I've darcs gotten exhibited that problem. Admittedly, most of it was on c.h.o but then again that's where most Haskell code *is* to begin with.
01:12:00 <b\6> dunno. we got introduced to darcs because we liked the ion wm. we started using it even though we had no idea what haskell was. we used it for trivial repos of mostly c.
01:12:05 <b\6> our impression was always that it was slow.
01:13:08 <ac> is there any advantage to storing an interval of time as a TimeDiff as opposed to an Integer containing milliseconds?
01:13:18 <ac> (if you know the time interval will never be more than a few hours)
01:14:42 <earthy> ac: the TimeDiff is easier to use within the library
01:15:07 <cjs> Damn, cabal is being a bitch to me today.
01:15:18 <cjs> GHC_PACKAGE_PATH doesn't seem to work very well.
01:15:20 <ac> how do I get milliseconds past the epoch?
01:15:22 <name_> is there any high rez platform neutral timer in the stdlib?
01:15:30 <b\6> weird, timediff stores seconds and then picoseconds.
01:15:32 <name_> like queryperformancecounter in the win32
01:15:39 <cjs> ac: getPOSIXTime.
01:16:47 <cjs> ac: Probably not, unless you need the higher resolution. On the other hand, doing the conversion from getPOSIXTime might be more expensive than just leaving it be, if you're only doing the odd comparison now and then with it.
01:17:07 <ac> I could just use TimeDiff if there was a subtractFromClockTime in addition to addToClockTime
01:18:40 <cjs> Hm? Just add a negative number.
01:19:03 <ac> how do you negate a TimeDiff?
01:19:09 <cjs> Or you can write subtractFromClockTime pretty easily.
01:19:30 <cjs> Hmmmm....is there a way to make an arbitrary TimeDiff?
01:20:02 <cjs> Yes, you can fromInteger or fromRational a number.
01:20:07 <Jedai> ac: It's an instance of Num
01:20:48 <cjs> > (-3.5) :: NominalDiffTime
01:20:49 <lambdabot>      Not in scope: type constructor or class `NominalDiffTime'
01:20:58 <cjs> (-3.5) :: Data.Time.NominalDiffTime
01:21:05 <cjs> > (-3.5) :: Data.Time.NominalDiffTime
01:21:06 <lambdabot>      Not in scope: type constructor or class `Data.Time.NominalDiffTime'
01:21:22 <al-maisan> Hello there! I would like to install cabal-install-0.5.1. Unfortunately, the README file does not say anything about the installation. Any advice?
01:21:28 <cjs> I'm not getting much love from lambdabot today, either.
01:22:07 <al-maisan> I don't have a previous version of cabal-install on my system i.e. I need to build it first.
01:23:42 <ac> cjs: I was talking about System.Time.TimeDiff. Is Data.Time better?
01:23:53 <ac> (it looks a lot more complicated)
01:25:08 <cjs> Oh, I'd not thought about it. There's some various stuff in Data.Time, but if you just use NominalDiffTime, you'll have just what you want.
01:25:34 <cjs> I'm not sure why I ended up using that for a bunch of my stuff. Maybe because I needed microsecond resolution.
01:26:49 <ac> cjs: thanks, it is what I want
01:27:31 <cjs> Yeah, I did spend a bit of time going through a lot of that before realizing how simple what I need is.
01:27:52 <ac> so I'm guessing Data.Time is the more complete and thorough time API, and System.Time is the Haskell98 spec?
01:27:59 <quicksilver> al-maisan: the install procedure is standard for all cabalised projects
01:28:06 <quicksilver> al-maisan: (of which cabal-install is one example)
01:28:13 <quicksilver> al-maisan: runhaskell Setup.lhs configure
01:28:19 <quicksilver> runhaskell Setup.lhs build
01:28:27 <quicksilver> (sudo) runhaskell Setup.lhs install
01:28:59 <al-maisan> quicksilver: thanks!
01:30:00 <cjs> Ok, that's two bugs in Cabal I've discovered.
01:30:17 <b\6> SO MUCH FOR FP.
01:30:25 * cjs jumps.
01:30:47 <cjs> I guess I'll go back to my custom build system for a while. *Sigh*.
01:30:58 <quicksilver> ac: yes, Data.Time is a rethought API, System.Time is deprecated.
01:31:07 <quicksilver> cjs: you're in need of a dcoutts :)
01:31:28 <ac> al-maisan: I believe if you say "runhaskell Setup.hs configure --user" you don't need root to install
01:31:52 <b\6> yeah, i use --user and --prefix all the time.
01:31:58 <al-maisan> ac: OK
01:39:25 <cjs> I am.
01:39:29 <cjs> @seen dcoutts
01:39:29 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-soc, #haskell-overflow, #darcs, #ghc and #haskell 7h 19m 16s ago, and .
01:39:44 <cjs> @and?
01:39:45 <lambdabot> ()
01:39:54 <cjs> Riiiiight....
01:41:33 <quicksilver> preflex: seen dcoutts
01:41:33 <preflex>  dcoutts was last seen on #haskell 8 hours, 27 minutes and 27 seconds ago, saying: gwern: mm, clearly I need to learn Japanese then, I've collected all the others.
01:41:38 <quicksilver> preflex: seen dcoutts_
01:41:38 <preflex>  dcoutts_ was last seen on #haskell 7 hours, 15 minutes and 32 seconds ago, saying: noecksit_: unregister with ghc-pkg and delete files with rm. If you want something better you can help us write the code to track installed files.
01:42:20 <ac> what's an elegant way to write modal GUI programs?
01:42:39 <quicksilver> ac: that sounds like a question to be answered with a PhD thesis and a series of books.
01:42:46 <quicksilver> ac: can you be at all more specific? ;)
01:43:56 <ac> well, I've got two screens, one where you enter in a bit of data, then you press a button or <return> and it displays another screen based on that data until you hit <esc>, which takes you back to the first screen
01:44:32 <trofi> > let a = 1 in how_are_you
01:44:33 <lambdabot> Terminated
01:44:48 <trofi> > lambdabot + 1
01:44:49 <lambdabot> Terminated
01:44:57 <quicksilver> ac: the high level answer depends on what structure your GUI toolkit is enforcing on you.
01:45:06 <ac> I'm using gtk
01:45:08 <cjs> ac: Functional Reactive Programming?
01:45:33 <quicksilver> I've never used gtk2hs; typically your modal application has a state (it's mode!)
01:45:45 <quicksilver> and the keyboard callbacks have access to that state
01:45:52 <quicksilver> I have a meta-callback which dispatches
01:45:54 <ac> screen2 has to be continuously updated with a timeout
01:46:02 <quicksilver> dispatches based on the current mode
01:46:07 <ac> how does that timeout get access to the state?
01:46:19 <quicksilver> give it an IORef when you set it up
01:46:23 <ac> right
01:46:29 <quicksilver> or an MVar if you're doing something concurrent
01:46:33 <ac> heh. no
01:47:08 <ac> I wonder if there's a way to add and remove timeouts
01:47:37 <quicksilver> it actually might be more elegant to use threads :)
01:47:50 <quicksilver> depending exactly what you're doing.
01:48:09 <quicksilver> a thread which sleeps for n milliseconds can be easier to understand than a system of timeout-callbacks.
01:48:13 <cjs> Sure, you maintain a list of timeout functions, and add to and remove from that list.
01:48:16 <sioraiocht> @seen dcoutts_
01:48:16 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts_ speak 7h 22m 10s ago.
01:48:19 <sioraiocht> @seen dcoutts
01:48:20 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-soc, #haskell-overflow, #darcs, #ghc and #haskell 7h 28m 6s ago, and .
01:50:38 <ac> ooh threads: exciting. When you go to screen2, the thread for screen1 could put itself to sleep and wake up screen2's thread
01:51:23 <ac> you can't use gtk2hs with threads though, right?
01:51:27 <quicksilver> yes, you can.
01:51:32 <quicksilver> You just need to exercise a little care.
01:51:39 <quicksilver> Don't make GUI calls from any non-main thread.
01:52:19 <ac> that would be cumbersome though for this design
01:52:45 <mgsloan> huh, so gtk shares that limitation
01:52:58 <mgsloan> i wonder if there are any uis without the main-thread business
01:53:17 <flux> ac, you could send messages to the mainthread, which would be continuations the main thread must execute, and then send the response back
01:54:46 <quicksilver> ac: it's not really very difficult to manage, in practice.
01:54:56 <quicksilver> You can use a Chan (IO ()) to pump actions back to the main thread.
01:55:00 <quicksilver> or do something simpler.
01:55:10 <quicksilver> you can just run "runInMainThread $ ....."
01:56:50 <trofi> cabal upgrade --constraint='bytestring <= 0.9.0.1.1' --dry-run
01:56:51 <trofi> Resolving dependencies...
01:56:51 <trofi> In order, the following would be installed:
01:56:51 <trofi> bytestring-0.9.1.0
01:56:59 <ac> @hoogle timeoutAdd
01:56:59 <lambdabot> No results found
01:57:12 <trofi> how ban bytestring for update?
01:58:09 <quicksilver> ac: there isn't any default timeout stuff, for good reason.
01:58:16 <quicksilver> ac: threads are simpler than callbacks :)
01:58:21 <quicksilver> (timeouts are a kind of callback)
01:58:27 <quicksilver> but you can build timeouts with threads.
01:58:35 <deufeufeu> hi, I'm using ghc, and I've a module showing up in ghc-pkg but ghc --make can't seem to find it
01:58:38 <quicksilver> libraries which run their own event-pump may well provide timeout facilities though
01:58:39 <deufeufeu> is there a quickfix ?
01:58:49 <quicksilver> (openGL does)
01:59:37 <int-e> gtk does, too.
01:59:56 <int-e> GL shouldn't, GLUT does.
02:01:48 <quicksilver> int-e: by 'openGL' I meant 'the haskell opengl package' :P
02:02:02 <quicksilver> but you're right, of course, that it's the GLUT part.
02:02:05 <ac> how could threads be simpler? It just seems silly to use two threads when neither will ever be executing concurrently
02:02:19 <quicksilver> something; sleep 1000; something else
02:02:23 <quicksilver> is a simpler model than
02:02:41 <quicksilver> addTimeout 0 (do something ; addTimeout 1000 (do something else))
02:02:46 <ac> but "sleep 1000" is actually "until <esc> is pressed"
02:02:52 <quicksilver> then that isn't a timeout.
02:02:54 <quicksilver> it's an event :P
02:02:58 <quicksilver> why are we talking about timeouts?
02:03:15 <ac> because that's what gtk calls it. It's more like setInterval (if you use JavaScript)
02:04:33 <quicksilver> then when esc is pressed you kill the thread, I guess.
02:04:45 <quicksilver> which is no worse than finding + cancelling the timeout.
02:05:01 <deufeufeu> (sorry I've fixed it)
02:06:48 <cjs> Hoo boy do I need dcoutts right now.
02:07:01 <cjs> It seems I can't turn around without finding a bug in cabal.
02:07:24 * osfameron spins cjs around really really fast, to help with the bug-finding!
02:07:33 <cjs> Whee!
02:11:35 <cjs> Ah!
02:11:37 <cjs> Gha!
02:11:40 <cjs> I mean.
02:16:03 <dcoutts_> cjs: mm?
02:16:03 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
02:20:49 <trofi> > lookup (zip [1..] ['a'..]) 5
02:20:51 <lambdabot>      No instance for (Num [([(t, Char)], b)])
02:20:51 <lambdabot>       arising from the literal ...
02:21:08 <trofi> @src lookup
02:21:08 <lambdabot> lookup _key []          =  Nothing
02:21:08 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
02:21:08 <lambdabot>                         | otherwise = lookup key xys
02:21:56 <trofi> > lookup 5 (zip [1..] ['a'..])
02:21:57 <lambdabot>  Just 'e'
02:23:46 <mc__> How would I create a 2-dimensional array in  haskell? I only see how to create 1-dimensional arrays
02:24:07 <Axman6> [[a]]?
02:24:21 <cjs> Ah, look who's here!
02:24:33 * Axman6 ?
02:24:39 <quicksilver> mc__: use a tuple as an index.
02:24:48 <quicksilver> mc__: Array (Int,Int) String
02:24:52 <quicksilver> mc__: for example.
02:24:56 <Deewiant> @check \x i -> i >= 0 ==> (flip lookup . zip [0..]) x i == flip ((listToMaybe .) . drop) x i
02:24:57 <cjs> My saviour!
02:24:57 <lambdabot>  "OK, passed 500 tests.\n"
02:25:00 <Deewiant> yay
02:25:42 <dcoutts_> cjs: use cabal's --package-db= flag.
02:25:50 <cjs> dcoutts_: Ok, I'm trying to manipulate Cabal in ways it doesn't appear to take to  particularly well. Do you have a few minutes to give me  some advice from you on this?
02:25:51 <cjs> Ah.
02:26:15 <dcoutts_> cjs: Cabal needs to know the dbs, so the ghc-pkg env var is no help
02:26:39 <cjs> It's not listed in my help. Is it in 1.2.x?
02:26:58 <cjs> That env var is not just ghc-pkg, it's ghc and all friends as well.
02:27:22 <dcoutts_> cjs: looks like it was added in Cabal 1.4
02:27:30 <mc__> quicksilver: thank you
02:27:40 <cjs> Ah. Well, if I was going to have to help with fixes, I'd have had to upgrade anyway.
02:28:08 <yitz> mc__: I usually use [[a]] like Axman6. along the lines of quicksilver, you could also use [((Int, Int), a)].
02:28:27 <cjs> Is head stable enough that I should be following it, or should I work against 1.4 and, if I have patches, submit against that?
02:28:45 <cjs> BTW, what will be included with ghc-6.10?
02:29:12 <dcoutts_> cjs: I'd use 1.4, but if you have patches they have to be for HEAD, 6.10 will come with 1.6 which will be branched from HEAD
02:29:42 <dcoutts_> cjs: I closed the first ticket because it's a ghc bug. I'll leave the second one open if people want to debate what to do about that env var. My inclination is to ignore it.
02:29:49 <cjs> Well, 1.6 must be pretty close, then.
02:30:04 <cjs> Is it a ghc bug? Or ghc-pkg?
02:30:14 <dcoutts_> cjs: http://hackage.haskell.org/trac/ghc/ticket/2521
02:30:20 <lambdabot> Title: #2521 (Trailing colon on GHC_PACKAGE_PATH doesn't work with ghc-pkg.) - GHC - Tr ...
02:30:37 <cjs> Why ignore it? All the GHC stuff uses it, or should.
02:32:34 <cjs> Ah, that's the ghc-pkg bug I found. It's just ghc-pkg; ghc works fine.
02:33:40 <cjs> Anyway, basically, for my projects each has its own release directory, where everything goes. (It's laid out like /usr/local.) I build various packages and my project source into that.
02:33:42 <dcoutts_> cjs: we need to know the package dbs or we cannot build stuff reliably
02:33:47 <cjs> Is that reasonable to support?
02:34:01 <dcoutts_> if you go behind the back of cabal then it is likely to make incorrect decisions
02:34:08 <cjs> Right, but you can get the package DBs from the env var, can you not? Probably you'd just want to use it on configure.
02:34:08 <dcoutts_> about package dependencies
02:34:25 <dcoutts_> but we already support that with --package-db
02:34:34 <dcoutts_> which is portable
02:34:36 <cjs> Ok, --package-db will do the trick just fine for me.
02:34:49 <quicksilver> I think cjs is asking "Why would cabal not respect an ENV var that ghc-pkg respects?"
02:34:53 <cjs> Right, portability. Ok, I think I'm coming over to your point of view, now.
02:34:59 <quicksilver> this seems like a reasonable question to me, although it may have a good answer.
02:35:27 <cjs> Though I supposey you could use the var only if you're configuring for ghc.
02:35:41 <dcoutts_> quicksilver: because it's not explicit, it's better to use a mechanism that is not ghc-specific
02:35:57 <quicksilver> I'm not suggesting you shouldn't use your explicit mechanism.
02:36:01 <cjs> quicksilver: But one issue is, it's sort of a "hidden" thing; if you happen to have it set when you configure, but you don't normally, it will quietly use that for everything until you reconfigure.
02:36:10 <quicksilver> I'm asking if there is a specific reason not to use this mechanism.
02:36:18 <quicksilver> ENV vars are hardly an unusual idea :)
02:36:29 <dcoutts_> quicksilver: we don't use any env vars
02:36:42 <matthew-_> no
02:36:45 <cjs> I generally like more explicit configuration myself; this is why my wrappers for runhaskell, ghci, etc. don't set or modify the env var.
02:39:54 <dcoutts_> quicksilver: actually these things are really hard to debug when there are lots of env vars floating about
02:40:17 <dcoutts_> quicksilver: one can't just ask people to paste the command and the output, it's no longer purely functional
02:40:30 <quicksilver> Yes, that's quite true.
02:41:08 <cjs> Yeah, I'm now with dcoutts_ on this one.
02:41:12 <dcoutts_> quicksilver: so I might add special support for that env var, in the form of unsetting it before calling ghc/ghc-pkg
02:41:38 <quicksilver> I wasn't trying to attack your decision; I was merely saying it was a decision which needed to be explained.
02:42:09 <quicksilver> By deliberately choosing not to support some mechanism which other parts of the toolchain support, you owe an explanation of your reasoning to people who might have been using them :)
02:42:13 <dcoutts_> quicksilver: I'll admit it's also personal bias, which is why I've left the ticket open in case anyone wants to make a good argument for it
02:42:29 <quicksilver> I'd almost recommend a warning message being displayed
02:42:35 <dcoutts_> quicksilver: nobody knew it was a mechanism the toolchain supported 'til recently
02:42:41 <quicksilver> "(Warning: ignoring environment va ....)
02:43:29 <dcoutts_> well, where nobody = a set of perhaps three people
02:44:17 <dcoutts_> it's a bit annoying as ghc doesn't use other env vars afaik
02:46:47 * mc__ sighs
02:46:58 <mc__> Haskell has a pretty steep learning curve
02:47:53 <quicksilver> programming has a steep learning curve
02:48:05 <quicksilver> haskell is more different from what you've done before, though.
02:49:42 <mc__> completely different, atm python is my main language, i'm not used to worry about the types all the time
02:51:22 <ziman> hm, i wouldn't call that `worrying'
02:51:49 <mc__> well, than lets call it "keeping in mind"
02:52:11 <quicksilver> mc__: any code which has a type error in haskell would be broken in python, too.
02:52:18 <quicksilver> it's just at python you'd spot the bug at runtime
02:52:20 <quicksilver> (or not at all)
02:52:25 <ziman> how many times in python i've come across (runtime!) errors that could easily be caught by the compiler
02:52:34 <ziman> exactly
02:52:49 <cjs> Yes, but a bug might or might not exhibit itself at runtime.
02:53:02 <BeelsebobWork_> quicksilver: python maybe, but I found an interesting example where that's not true in C... if (!ptr) will never break, even though if (NULL == ptr) is the type-safe way to do it
02:53:07 <cjs> And if it doesn't, you don't have to fix it. :-)
02:53:24 <ziman> i mean, gross kinds of errors, like mistyped identifiers, pair/variable mismatch etc.
02:53:35 <cjs> BeelsebobWork_: Are you sure? What if pointers are a completely strange and different machine word?
02:53:44 <cjs> Or even just segment:offset?
02:53:47 <BeelsebobWork_> cjs: the C spec defines that they're the same
02:53:55 <cjs> Ah.
02:54:54 <quicksilver> BeelsebobWork_: that's not really a difference.
02:55:11 <quicksilver> BeelsebobWork_: you're just talking about how '!' was overloaded to work on the pointer type.
02:55:18 <quicksilver> so if (!ptr) is type-safe.
02:55:22 <mc__> what is wrong with this? "array (1,100) [i  | i <- [1..100]]"
02:55:30 <quicksilver> in haskell we could move 'not' to a type.
02:55:37 <quicksilver> class.
02:55:42 * BeelsebobWork_ shrugs
02:55:44 <BeelsebobWork_> that's nasty
02:55:49 <GremlinHunter> mc__: Doesnt it nead to be [(i, i) | ...]
02:55:52 <quicksilver> it is, but C is nasty.
02:55:57 <BeelsebobWork_> yep
02:56:04 <quicksilver> however that particular nastiness is easily expressible :)
02:56:11 <quicksilver> C has implicit coercions
02:56:21 <quicksilver> it's possible to express them in haskell's type systems if you really want
02:56:28 <quicksilver> although it doesn't produce anythign pleasant ;)
02:56:30 <BeelsebobWork_> yeh, okay -- I was really meaning that it violates the type system in my head
02:56:38 <BeelsebobWork_> which I guess isn't a strong justification
02:56:41 <mc__> GremlinHunter: yeah it does, but I dont understand why
02:57:05 <GremlinHunter> Each item is put in like (index, value)
02:57:15 <ziman> mc__, it's (index, value) pairs, iirc
02:57:58 <mc__> ah, alright
02:57:59 <quicksilver> mc__: that's just how 'array' is written.
02:58:05 <quicksilver> no particular reason.
02:58:09 <quicksilver> 'listArray' works the way you wanted
02:58:11 <quicksilver> IIRC>
02:59:23 <mc__> quicksilver: yes, it does :) neat
03:01:26 <cjs> Maybe it's written that way to support sparse arrays?
03:09:23 <cjs> Crips, I just named a Ruby file with the extension '.hs'.
03:09:29 <cjs> s/Crips/Cripes/.
03:10:57 <BeelsebobWork_> haha
03:11:09 <BeelsebobWork_> hmm... there's an interesting idea
03:11:19 <BeelsebobWork_> design a language specifically to complement Haskell
03:11:26 <BeelsebobWork_> who's comments start with >
03:11:38 <BeelsebobWork_> so that you can have a file containing both Haskell and the complement language
03:14:52 <cjs> Gah. I need to bootstrap Cabal with the old cabal before I can use the new options, of course.
03:15:16 <dcoutts_> cjs: Cabal bootstraps using itself, not older versions
03:15:35 <cjs> Really? I can give it --package-db on setup, then?
03:16:09 <dcoutts_> cjs: yes
03:16:13 <cjs> Cool.
03:16:30 <dcoutts_> cjs: ghc --make Setup.hs && ./Setup configure --package-db=
03:17:00 <cjs> runghc will work too, of course, right?
03:17:03 <dcoutts_> you can use runghc though it'll have to interpret the whole of the Cabal source code on each step, configure, build, install
03:17:09 <cjs> Oof.
03:17:24 <cjs> Still, I rarely do it.
03:17:50 <dcoutts_> cjs: since of course normally when you runghc you're using a pre-compiled package. When you do it in the Cabal package you're compiling all the local source.
03:17:57 <cjs> Ok, so I can use my current build system as-is, if I can figure out why my dependency generation is broken.
03:17:59 <cjs> Right.
03:18:25 <dcoutts_> cjs: right, for the most part Cabal is just an ordinary Cabal package
03:18:40 <cjs> Very nice.
03:18:54 <cjs> You should get it building things like C libraries, apache, php....
03:19:05 <cjs> Then it would replace my build system. ;_0
03:19:07 <cjs> :-)
03:19:57 <dcoutts_> heh
03:21:59 <shaftyy> noobie question: how does foldr access the last element of a list? does it traverse the list first?
03:22:39 <BeelsebobWork_> shaftyy: it traverses the list forwards, building a stack, then on it's way back, it collects everything up
03:22:44 <Lemmih> shaftyy: http://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png
03:22:45 <lambdabot> http://tinyurl.com/5evrkl
03:23:07 <BeelsebobWork_> this is why foldl is often more efficient -- the elements can get garbage collected as foldl proceeds
03:23:39 <shaftyy> thx, that would have been my next question ;)
03:26:42 <sjanssen> dcoutts_: should patches to Cabal bugs go on trac or the mailing list?
03:27:22 <dcoutts_> sjanssen: either
03:27:45 <dcoutts_> sjanssen: it's probably easier for me to apply from an email
03:28:25 <dcoutts_> sjanssen: and if it's a simple obvious patch then that's easier, if it'll need more review and might hang about then the trac helps us not forget it
03:28:47 <dcoutts_> sjanssen: this is the sdist snapshot I presume
03:28:51 <sjanssen> dcoutts_: right
03:29:16 <dcoutts_> sjanssen: where snapshot gets done for the prepare but not archive step after we partitioned the code a bit (probably my fault)
03:54:45 <ski> smoofra : some variations <http://hpaste.org/9815#a1>
03:57:43 <trofi> @let unsafePerformIO = ()
03:57:43 <lambdabot> Defined.
03:58:00 <trofi> > unsafePerformIO
03:58:01 <lambdabot>  mueval: Unsafe functions to use mentioned.
03:58:14 <trofi> @let safePerformIO f = f
03:58:15 <lambdabot> Defined.
04:00:42 <sioraiocht> dcoutts_: ping?
04:01:45 <sioraiocht> @seen dcoutts_
04:01:46 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts_ speak 26m 34s ago.
04:01:51 <sioraiocht> ahh, he'll be back...
04:23:27 <b\6> if i were coding c, i'd do foo(&context) so foo could update context, maybe so the next foo(&context) that happens maybe way later can do whatever the next step is. does State help? i see how it helps within a function but not so sure about across separate calls.
04:25:45 <jorick> ugh ... how to answer this
04:25:47 <Saizan> b\6: you just have to remain inside the monad
04:26:08 <dcoutts> Saizan: http://blog.well-typed.com/2008/08/whats-wrong-with-make/
04:26:09 <lambdabot> Title: blog.well-typed.com ¬ª Blog Archive ¬ª What‚Äôs wrong with make?
04:26:59 * Saizan reads
04:27:01 <quicksilver> dcoutts: you don't need a blog for that. The answer is "everything" ;)
04:27:12 <dcoutts> quicksilver: ah, but more specifically
04:27:18 <dcoutts> quicksilver: and actually it's not that bad
04:27:26 <quicksilver> no, I'm being funny.
04:27:30 <quicksilver> it works when it works
04:27:35 <quicksilver> but it's not scalable or compositional.
04:27:39 <quicksilver> (spot the pattern!)
04:27:58 <quicksilver> the answer to "what is wrong with X" in systems administration is almost always either 'not scalable' or 'not compositional'
04:28:01 <quicksilver> or both.
04:28:34 <dcoutts> quicksilver: yes, both, though that's not what I'm complaining about
04:28:55 <dcoutts> it's more like "it's not typesafe" and "it cannot express things we must express"
04:32:19 <dcoutts> quicksilver: actually that's a good point. It works when it works, but how do you know when it works? :-)
04:33:06 <dcoutts> quicksilver: since there's no way of checking that you've specified the dependencies correctly.
04:34:17 <sjanssen> dcoutts: "track dependencies absolutely precisely or you loose.", lose
04:34:40 <dcoutts> sjanssen: doh.
04:34:43 <dcoutts> thanks :-)
04:37:07 <osfameron> where will icfp 200*9* be?
04:37:34 <dcoutts> osfameron: Europe, somewhere.
04:37:53 <osfameron> ah, it gets announced at  icfp 2008?
04:38:27 <dcoutts> osfameron: I'm not sure actually, but that sounds likely
04:40:24 <Philippa> osfameron: I'm hearing rumours about Edinburgh
04:40:34 <Philippa> I'm certainly hoping for somewhere in the UK myself
04:40:41 <dcoutts> Philippa: oh, that'd be cool
04:40:55 <osfameron> Edinburgh would totally rock
04:41:05 <osfameron> I could stay with my folks :-)
04:42:55 <quicksilver> sjanssen: ...or you loose the dogs of war.
04:42:59 <osfameron> conf is more expensive than perl confs, so great if I can save on hotel :-)
04:43:06 <quicksilver> it's dangerous stuff, dependency checking.
04:45:15 <dcoutts> quicksilver: ;-)
04:46:23 <matthew-_> sorry, really dumb question. Malloc does zero the space right?
04:46:30 <matthew-_> (as in Haskell's malloc)
04:47:22 <Philippa> matthew-_: don't assume unless the docs say so
04:47:41 <Feuerbach> matthew-_: no
04:47:48 <Feuerbach> matthew-_: calloc zeros the space
04:48:11 <matthew-_> ahh of course - hence the recent openssl issue
04:48:15 <dcoutts> Feuerbach: you're thinking of C
04:48:15 <matthew-_> sorry, I'm being dumb
04:48:26 <matthew-_> oh? it's different in haskell?
04:48:27 <dcoutts> matthew-_: the impl looks like it does not
04:48:41 <Feuerbach> oh, haskell has its own malloc?
04:49:26 <matthew-_> Feuerbach: it looks like a very simple ffi import of the stdlib
04:49:35 <matthew-_> foreign import ccall unsafe "stdlib.h malloc"  _malloc  ::          CSize -> IO (Ptr a)
04:49:54 <dcoutts> matthew-_: ah yes. ghc is using just C malloc, but it needn't according to the FFI spec
04:50:13 <dcoutts> matthew-_: so unless the FFI spec says malloc zeros then it doesn't
04:50:13 <trofi> @hoogle Alloc
04:50:14 <lambdabot> module Foreign.Marshal.Alloc
04:50:14 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
04:50:14 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
04:50:24 <dcoutts> matthew-_: or rather, you cannot rely on it
04:50:29 <trofi> @hoogle allocaArray
04:50:29 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
04:50:29 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
04:54:47 <matthew-_> if you do mallocBytes 9, it will allocate 9 bytes even if you're going to stick a Word64 in there right?
04:55:03 <quicksilver> right.
04:57:21 <quicksilver> I think malloc shoud fill the bytes it allocates with shellcode
04:57:35 <quicksilver> which prints messages all over the screen insulting the programmer for relying on the contents :P
04:58:18 <mc__> lol
04:58:33 <eu-prleu-peupeu> :)
04:59:06 <trofi> LD_PRELOAD=./my_shiny_malloc_impl.so
04:59:32 <quicksilver> also sprach valgrind
04:59:39 <ejt> is i me or did hoogle just improve ?
04:59:49 <ejt> s/ i / it /
05:00:22 <quicksilver> ndm has been working on hoogle recently.
05:00:32 <ejt> looks very nice now
05:01:25 <dcoutts> hah, have you read CosmicRay's blog post about dell sending him stuff through the postal service?
05:01:33 <dcoutts> it's hilarious
05:02:10 <dcoutts> the prohibitory order, which they're shortly going to violate no doubt
05:02:30 <guenni> quicksilver: you're German?
05:04:17 <desp> Ugh.
05:04:28 <desp> What is the correct module to import in order to access Parsec?
05:04:45 <mar77a> ?hoogle Parsec
05:04:45 <lambdabot> module Text.ParserCombinators.Parsec
05:04:45 <lambdabot> Distribution.Configuration parseCondition :: ReadP r (Condition ConfVar)
05:04:45 <lambdabot> Network.CGI parseContentType :: Monad m => String -> m ContentType
05:04:45 <quicksilver> guenni: no. "Also sprach Zarathrustra" is very famous, any educated person should IMO know the phrase :)
05:04:52 <quicksilver> even if they can't actually get through the book.
05:05:38 <desp> mar77a: that's what I thought, but...
05:05:38 <desp> Main.hs:3:7: Could not find module `Text.ParserCombinators.Parsec':
05:06:32 <int-e> desp: did you compile with --make?
05:06:46 <desp> I wanted to play around in ghci.
05:07:10 <desp> Can I even do that?
05:07:19 <desp> ghci --make Main.hs
05:07:25 <desp> ...doesn't seem to help.
05:08:05 <mc__> quicksilver: why is that phrase famou?
05:08:17 <mc__> and who is Zarathurstra?
05:08:41 <int-e> desp: hmm, parsec is an extra lib, is it installed? (you can use  ghc-pkg list  to list the installed packages)
05:09:00 <desp> Aha.
05:09:08 <desp> I thought it was included with GHC.
05:09:28 <trofi> ghci can --make? ghc can
05:09:43 <desp> Yeah, I just don't have it. :P  Sorry about that.
05:09:47 <MarcWeber> Is there already a library checking xml generation by statically? (I know about WASH)
05:10:22 <desp> That's what the Parsec webpage said, tho: "Nowadays, Parsec is distributed with the standard Haskell libraries with most Haskell compilers "
05:11:16 <Saizan> dcoutts: great post! on the edsl i think that we have not tried to pin down the features we really want, it could become a lot like vesta or we could try to mix a more declarative style into it
05:11:40 <quicksilver> mc__: it's the name of a book by Nietzsche, Zarathustra was a prophet. Wikipedia has more for you.
05:11:48 <janszn> @pl (\(x:xs)->  any (/=x) xs)
05:11:49 <lambdabot> ap (any . (/=) . head) tail
05:11:58 <int-e> desp: well, it is; ghc has a source package (just the bare minimum, parsec is not included) and an extralibs tarball (which includes parsec, among other libraries)
05:12:02 <dcoutts> Saizan: right, or one built on the other.
05:12:13 <desp> int-e: aha.
05:13:12 <int-e> parsec is also available from hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
05:13:15 <lambdabot> Title: HackageDB: parsec-3.0.0
05:13:29 <int-e> so you have several options.
05:50:09 <gwern> 'New Rubyists will be younger, and current Rubyists will get older. Some Rubyists will get dogs, others cats. A few will remain dogless and catless, perhaps opting for children instead. (This is a common mistake, as, in my experience, children are much more expensive than either dogs or cats.)'
05:50:35 <mc__> gwern: wtf?
05:50:52 <gwern> mc__: eternal verities, man.
05:51:04 <ivanm> what happens to those that don't want any cats, dogs, or children?
05:51:36 <gwern> ivanm: presumably they commit suicide out of existential despair and loneliness
05:51:53 <ivanm> ahhh
05:51:58 <ejt> I thought rubyists would get ducks
05:52:20 <ivanm> gwern: silly rubyists ;-)
05:52:46 <mc__> they dont get ducks, the get something that looks like a dug, sounds like a dug, tastes like a dug and therefore is called a dug
05:53:08 <Wild_Cat> in other words, they get... A witch!
05:53:18 <ddarius> gwern: New Rubyist don't need to be younger.
05:53:20 <Wild_Cat> well, no, it's more us Pythonists that get a witch, thinking of it.
05:53:35 <gwern> but does it weigh the same as a dug?
05:53:35 <Wild_Cat> Rubyists get... Whatever they call witches in Japanese. But without Unicode.
05:54:20 <Wild_Cat> well, of course, since it's made of wood.
05:54:56 <sampointon> I'd always presumed rubyists would like model railwaying, or maybe mineral geology
05:55:15 <gwern> what if it's balsa wood, and dugs are made out of ironwood or something?
05:56:01 <Wild_Cat> well then you'd need to get call Dig-Dug to the rescue. After all, Namco is Japanese too.
05:56:11 <mnislaih> int-e: you are the maintainer of the curl bindings, arent you? I've been seeing segmentation faults when using curlGetString on more than one thread
05:56:23 <int-e> ? no I'm not.
05:56:38 <mnislaih> ah, ok, so who is eric mertens ?
05:57:25 <int-e> I'd try 'emertens'
05:57:41 <mnislaih> ah, right
05:57:54 <mnislaih> emertens: ping
06:01:23 <gwern> @seen emertens
06:01:23 <lambdabot> emertens is in #haskell. I don't know when emertens last spoke.
06:01:37 <yitz> @seen dons
06:01:38 <lambdabot> I saw dons leaving #arch-haskell, #xmonad, #darcs, #ghc and #haskell 1h 37m 2s ago, and .
06:01:52 <yitz> @seen Igloo
06:01:52 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 25s ago.
06:02:00 <gwern> preflex: seen emertens
06:02:01 <preflex>  Sorry, I haven't seen emertens
06:02:56 <yitz> Igloo: I need to parse emails with attachments. you have a library, and so does dons. any recommendations?
06:03:15 * gwern makes a note. be warned preflex, your time will come! you too shall make use of mueval
06:03:50 <yitz> preflex help
06:03:51 <Igloo> yitz: I don't know or can't remember the differences
06:03:51 <preflex>  try 'help help' or see 'list' for available commands
06:04:31 <yitz> Igloo: yours is a lot bigger.
06:04:43 <yitz> preflex list
06:04:43 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
06:05:13 <yitz> preflex remember gwern be warned preflex, your time will come! you too shall make use of mueval
06:07:20 <Igloo> yitz: From what I remember, mine should be correct, and pretty friendly for taking messages apart
06:10:29 <yitz> Igloo: ok, thanks!
06:10:55 <yitz> preflex quote gwern
06:10:55 <preflex>  <gwern> be warned preflex, your time will come! you too shall make use of mueval
06:16:20 <yitz> Igloo: ah, I see, dons' package is for MIME type strings, not for MIME messages. So you're currently the only game in town.
06:20:05 <ziman> preflex help cdecl
06:20:06 <preflex>  cdecl DECLARATION - explain a C declaration
06:24:50 <SamB_XP> preflex: quote
06:24:50 <preflex>  <procyon> optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of time, but it still feels good.
06:25:37 <SamB_XP> preflex: quote
06:25:37 <preflex>  <quicksilver> learning from other people's mistakes is so web 1.0
06:52:47 <hackage> Uploaded to hackage: language-c 0.3.1
06:52:47 <hackage> Uploaded to hackage: bloomfilter 1.2.3
06:52:47 <hackage> Uploaded to hackage: hint 0.2.4.1
06:52:48 <hackage> Uploaded to hackage: AERN-RnToRm 0.4
06:52:50 <hackage> Uploaded to hackage: bloomfilter 1.2.2
06:57:59 <ejt> ifM :: (Monad m) => m Bool -> m a -> m a -> ma
06:57:59 <ejt> ifM cond t f = do b <- cond if b then t else f
06:58:09 <ejt> I've found myself using this a lot ^^
06:58:22 <ejt> but I'm sure there must be something better in Control.Monad ?
06:58:52 <Deewiant> not really
06:59:35 <yitz> @type liftM3 if'
06:59:36 <lambdabot> Not in scope: `if''
06:59:57 <yitz> @let if' cond t f = if cond then t else f
06:59:58 <lambdabot> Defined.
07:00:01 <yitz> @type liftM3 if'
07:00:02 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m t -> m t -> m t
07:01:59 <ejt> yitz: would that even work if m == IO ?
07:02:01 <mopped> 'Introduction to Functional Programming [1] or Davie's An Introduction to Functional Programming Systems Using Haskell', which one would be better for somebody new to functional languages, or even if theres one superior to the two?
07:02:05 <yitz> sure
07:02:25 <yitz> i think
07:03:30 <ejt> Prelude Control.Monad> (liftM3 if') (return True) (putStrLn "yes") (putStrLn "no")
07:03:34 <ejt> yes
07:03:34 <ejt> I think not
07:03:37 <ejt> no
07:03:50 <yitz> darn, it always runs both of them
07:03:55 <ejt> y
07:04:00 <ejt> pesky IO
07:04:33 <ejt> anyway, it's not the definition I was worried about, more that there was a form of guard or something that I should be using instead
07:05:26 <yitz> @type liftM3 $ (. guard) . flip maybe . const
07:05:27 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (MonadPlus m1, Monad m) => m (m1 ()) -> m Bool -> m (Maybe a) -> m (m1 ())
07:05:42 <yitz> not quite, let's see...
07:06:29 <yitz> @pl \ c t f -> maybe f (const t) (guard c)
07:06:29 <lambdabot> flip (flip . flip maybe . const) . guard
07:07:04 <yitz> @type liftM3 $ flip (flip . flip maybe . const) . guard
07:07:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m a -> m a
07:07:51 <yitz> I'll bet that's not what you were thinking of ;) (same problem as before)
07:07:58 <MarcWeber> is there an url library having a funciton such as isAbsoluteUri ?
07:08:32 <Jedai> liftM3 will always execute the 3 actions in a strict monad (IO, Control.Monad.State.Strict....)
07:09:40 <ski> bloomfilter 1.2.2 uploaded *after* 1.2.3 ?
07:09:49 <Jedai> MarcWeber: Network.URI : http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
07:09:51 <lambdabot> Title: Network.URI, http://tinyurl.com/2xdcca
07:10:00 <MarcWeber> I've found it as well now, thanks :-)
07:11:00 <yitz> @pl \c t f -> guard c >> lift t `mplus` lift f
07:11:01 <lambdabot> (. ((. lift) . mplus . lift)) . (.) . (>>) . guard
07:11:25 <yitz> @type \c t f -> guard c >> lift t `mplus` lift f
07:11:26 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t, MonadPlus (t m)) => Bool -> m a -> m a -> t m a
07:11:51 <ski> why `lift' ?
07:12:11 <yitz> @type \c t f -> lift c >>= guard >> lift t `mplus` lift f
07:12:12 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) b. (MonadPlus (t m), Monad m, MonadTrans t) => m Bool -> m b -> m b -> t m b
07:12:36 <yitz> @type \c t f -> runMaybeT (lift c >>= guard >> lift t `mplus` lift f)
07:12:38 <lambdabot> Not in scope: `runMaybeT'
07:12:40 <MarcWeber> Is this a valid uri to the home directory ? file://home/marc/ .. ?
07:13:09 <MarcWeber> I've read that the file url format is file://host/home/marc (host = localhost or empty or whatsoever)
07:13:27 <Deewiant> MarcWeber: you need one more slash before home, I think
07:13:47 <MarcWeber> Deewiant I think as well. Then HaXml is wrong here
07:13:48 <Deewiant> since its file:// /home/marc
07:13:55 <Vq^> i've never seen host embedded in that way
07:13:56 <Deewiant> but I'm not sure
07:14:08 <yitz> @type \c t f -> liftM head $ runListT (lift c >>= guard >> lift t `mplus` lift f)
07:14:09 <lambdabot> Not in scope: `runListT'
07:14:33 <Deewiant> @type \c t f -> evalStateT (lift c >>= guard >> lift t `mplus` lift f) ()
07:14:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m Bool -> m a -> m a -> m a
07:14:42 <MarcWeber> Deewiant: opera shows the file, but elinks doesn't, neither does firefox.. So it seems to be wrong
07:14:55 <yitz> @pl \c t f -> runMaybeT (lift c >>= guard >> lift t `mplus` lift f)
07:14:56 <lambdabot> ((runMaybeT .) .) . (. ((. lift) . mplus . lift)) . (.) . (>>) . (guard =<<) . lift
07:15:18 <yitz> ejt: there you have it. umm...
07:15:34 <yitz> well, it uses guard.
07:18:25 <yitz> ah one second
07:18:27 <ski> yitz : i don't think that's right
07:18:39 <ski> well . maybe in `IO' .. hm
07:18:40 <yitz> @pl \c t f -> lliftM fromJust $ runMaybeT (lift c >>= guard >> lift t `mplus` lift f)
07:18:41 <lambdabot> (((lliftM fromJust . runMaybeT) .) .) . (. ((. lift) . mplus . lift)) . (.) . (>>) . (guard =<<) . lift
07:18:48 <ski> but not in `[]' e.g.
07:19:17 <ski> @type \c t f -> c >>= \b -> if' b t f
07:19:17 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
07:20:39 <trofi> :t M.lookup
07:20:40 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
07:20:54 <ziman> @pl \x -> if a then b else x
07:20:55 <lambdabot> if' a b
07:21:24 <yitz> ski: I think that should work, but it needs to be checked.
07:22:39 <ski> which ?
07:23:47 <yitz> MaybeT
07:24:00 <yitz> so for example, let's say them monad is [], as you say.
07:24:16 <yitz> so the "condition" has type [Bool]
07:26:24 <yitz> now ejt's orignial will concat copies of t and f according to the pattern of Bools.
07:27:06 <ejt> neat
07:28:50 <ski> could you say again which version you mean .. there's too many variants above
07:30:52 <yitz> My MaybeT version will start with a list of Just True and Just False, and when we feed that to guard we get a list of Just () and Nothing corresponding to the origninal [Bool].
07:31:00 <mauke> preflex: help tell
07:31:00 <preflex>  tell NICK MESSAGE - when NICK shows activity, tell them MESSAGE
07:31:13 <mauke> so far, so good
07:31:25 <yitz> ski: I'm thinking about \c t f ->  lliftM fromJust $ runMaybeT (lift c >>= guard >> lift t `mplus` lift f)
07:31:28 <mauke> preflex: tell mauke hi
07:31:29 <preflex>  what
07:31:58 <yitz> preflex tell mauke hi
07:32:12 <mauke> preflex: version
07:32:13 <preflex>  8.330
07:32:13 <preflex>  mauke: you have 1 new message. '/msg preflex messages' to read it.
07:32:13 <yitz> ok mauke go ahead
07:32:33 <mauke> ok, that seems to work
07:33:37 <ski> yitz : yes, i think that version is correct .. however i prefer simpler ejt's version, i think :)
07:34:02 <yitz> ski: hehe yes indeed, even if it's correct.
07:36:18 <ejt> ok, dumb question time; how do I convert a Real to an Integral ?
07:36:28 <mauke> ejt: round, truncate, ceiling, floor
07:36:54 <ejt> tried that, I think that only works on RealFrac ?
07:37:00 <Deewiant> ?ty round
07:37:01 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:37:11 <Jedai> ejt: What's a "Real" ?
07:37:26 <Deewiant> ?src Real
07:37:26 <lambdabot> class  (Num a, Ord a) => Real a  where
07:37:26 <lambdabot>     toRational      ::  a -> Rational
07:37:38 <Deewiant> ?ty round . toRational
07:37:39 <lambdabot> forall b a. (Real a, Integral b) => a -> b
07:37:59 <ejt> great, thx
07:38:26 <quicksilver> are there any things which are instances of Real but not RealFrac?
07:38:31 <Deewiant> ?instances Real
07:38:32 <quicksilver> Ah, Integer.
07:38:32 <lambdabot> Double, Float, Int, Integer
07:38:33 <quicksilver> Duh.
07:38:48 <ejt> quicksilver: CTime
07:39:02 <mauke> ah, CTime is evil
07:39:13 <Jedai> quicksilver: But I guess it's pretty rare to need a function on the Real class generally
07:39:39 <quicksilver> yes, I think so.
07:40:26 <Twey> Why are lift and liftIO different?
07:40:39 <Deewiant> liftIO lifts all the way up to IO
07:40:41 <Deewiant> lift lifts one level
07:40:44 <Twey> Oho
07:40:48 <Twey> I see.  Thanks.
07:41:03 * quicksilver always thinks of IO as the bottom not the top
07:41:11 <Deewiant> :-)
07:41:12 <quicksilver> so liftIO lifts all the way up *from* IO, not to it.
07:41:15 <mauke> preflex: list
07:41:16 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
07:42:21 <Twey> Aye, quicksilver, me too
07:42:50 <mauke> preflex++
07:42:58 <noecksit_> hello, i accidentally broke my ghc installation yesterday, and i unregistered bytestring which is in /usr/lib because i have a newer version in ~/.cabal dir, however ghc is not recognizing that installation
07:43:43 <noecksit_> is there a way i could reregister the old bytestring or do i need to reinstall ghc?
07:44:19 <dcoutts> noecksit_: you either need to reregister the old bytestring or reinstall ghc
07:44:26 <Botje> ghc-pkg has a register command? :)
07:44:49 <dcoutts> noecksit_: if you're on gentoo or debian then you're in luck because they saved you a copy of the original package db for just these circumstances
07:45:15 <noecksit_> dcoutts: you mean package.conf.old?
07:45:55 <dcoutts> noecksit_: no, package.conf.shipped, though if you've not done any other register/unregister operations since you messed up your package.conf then the .old would be the last backup
07:46:47 <noecksit_> dcoutts: i also have package.conf.old, i think that might be good too, unless ghc-pkg unregister messes with any other files
07:47:13 <dcoutts> noecksit_: the .old is only a one place backup
07:47:44 <dcoutts> noecksit_: so it's ok if you've not installed or unregistered anything at all since you unregistered bytestring
07:48:02 <dcoutts> otherwise the backup will have been overwritten by another backup :-)
07:48:15 <noecksit_> dcoutts: no i didnt
07:49:00 <xeqi> exit
07:49:16 <dcoutts> noecksit_: ok, then ghc-pkg --package-conf=/path/to/package.conf.old describe bytestring > bytestring.pkg
07:49:21 * BeelsebobWork really wants unsafeShowFun :: (a -> b) -> String
07:49:36 <dcoutts> noecksit_: then take a look at the bytestring.pkg file and make sure it looks sane
07:49:47 <Twey> BeelsebobWork: Why is it unsafe?
07:49:50 <yitz> BeelsebobWork: that's a common topic here
07:49:53 <dcoutts> noecksit_: and if it does use ghc-pkg register bytestring.pkg
07:50:05 <BeelsebobWork> Twey: because the safe version is impossible to write
07:50:11 <BeelsebobWork> because equality of functions is undecidable
07:50:21 <Twey> What's the safe version, then?
07:50:32 * Twey feels somewhat confused.
07:50:49 <dcoutts> showFun _ = "<function>"
07:50:51 <lilac> not undecidable so much as uncomputable, right?
07:50:53 <Deewiant> unsafeShowFun = const "function"
07:50:55 <noecksit_> dcoutts: oh thanx
07:50:56 <Twey> Deewiant: Heh
07:50:59 <yitz> Twey: he wants the inverse function of GHC
07:51:04 <BeelsebobWork> dcoutts: okay, sorry, a useful one is impossible to write
07:51:06 * Twey chuckles.
07:51:09 <Twey> Aye, I get that
07:51:25 <dcoutts> BeelsebobWork: well, if the domain is enumerable then one could print some subset of the function
07:51:30 <BeelsebobWork> dcoutts: idd
07:51:43 <BeelsebobWork> actually, no
07:51:47 <jnaimard> I have a code.haskell.org wish, where is the magic lamp (or bts) ?
07:51:49 <BeelsebobWork> that assumes that it halts for the sample you chose
07:51:59 <dcoutts> BeelsebobWork: true
07:52:19 <dcoutts> BeelsebobWork: smallcheck uses a devilishly cunning method
07:52:24 <BeelsebobWork> hmm?
07:52:37 <hackage> Uploaded to hackage: WebBits 0.9.2
07:52:43 * BeelsebobWork goes and stares at the smallcheck paper
07:53:07 <dcoutts> BeelsebobWork: it records in an IORef each (arg, result) pair the function was actually invoked with and displays that at the end
07:53:21 <BeelsebobWork> dcoutts: ah, okay -- so it does what Hat does
07:53:27 <BeelsebobWork> but records a (much) smaller trace
07:53:40 <BeelsebobWork> no surprise given that it's a Runcimanisation too
07:53:46 <dcoutts> right
07:54:21 <lilac> instance Eq (a -> b) where (==) = (==) on (unsafePerformIO . makeStableName)
07:54:48 * lilac lives on the edge
07:54:50 <BeelsebobWork> makeStablName?
07:54:56 <BeelsebobWork> what's that meant to do?
07:55:12 <noecksit_> dcoutts: ok now the old version of bytestring is installed, however the new version in my home directory interferes, is it safe to ghc-pkg unregister it and delete it?
07:55:28 <lilac> BeelsebobWork: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
07:55:30 <lambdabot> Title: System.Mem.StableName, http://tinyurl.com/zrcmg
07:55:44 <dcoutts> noecksit_: if you've got exactly the same version registered in the user and global db then it'll get in the way, otherwise there's no problem.
07:56:40 <Twey> on == (.)?
07:56:41 <noecksit_> dcoutts: its not though, the one in the global dir is 0.9.0.1 and the one in the home dir is 0.9.1.0
07:56:53 <dcoutts> noecksit_: that's not a problem, you can have both
07:57:14 <DrSyzygy> ibid: Ping?
07:57:34 <eu-prleu-peupeu> in october ill be heading the development team of a project that scraps information from the web, and builds some charts... i was planning to use haskell for the job
07:57:35 <lilac> Twey: oops, typo :-)
07:57:40 <zeno_> would be cool to have @lagtest, so we can see how long lambdabot is taking to respond ATM
07:57:45 <eu-prleu-peupeu> maybe libcurl, and google chart api
07:57:51 <lilac> > "lagtest"
07:57:52 <lambdabot>  "lagtest"
07:58:06 <noecksit_> dcoutts: when i try to run my code through ghci, I get a fatal error that found duplicate definition for symbol "fps_minimum" while processing the bytestring object ifle
07:58:28 <dcoutts> noecksit_: if you specifically want to use one version or the other then use -package bytestring-0.9.0.1
07:59:09 <mauke> lambdabot should support CTCP PING
07:59:40 <noecksit_> dcoutts: well, i still get the error, ill hpaste it actually
08:00:28 <dcoutts> noecksit_: you've probably got other packages that are compiled against bytestring-0.9.1.0 then
08:00:40 <zeno_> lilac: meant as in it would se the time you sent it, and before responding get the current time and do a difftime printing it
08:01:14 <noecksit_> http://hpaste.org/9822
08:01:18 <ski> BeelsebobWork,lilac : in some cases, function equality is decidable even though the domain is not finite .. <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>
08:01:18 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>
08:03:42 <zeno_> is it normal for stuff to work in GHCI but not GHC?
08:04:05 <dcoutts> zeno_: no, but the other way around is not unheard of, because the linkers are different
08:05:51 <noecksit_> actually, my problem doesnt occur with when compiling with ghc, only with ghci
08:06:19 <zeno_> set to announce but nothing so far... http://hpaste.org/9823
08:06:41 <mauke> preflex: seen hpaste
08:06:41 <preflex>  hpaste was last seen on #haskell 40 days, 23 hours, 8 minutes and 3 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
08:07:04 <mauke> zeno_: ghc --make
08:07:28 <zeno_> mauke: ah, thanks my first time using ghc :)
08:07:37 <mauke> or -package time
08:07:44 <mauke> but --make nearly always works
08:08:01 <mauke> preflex: zdec timezm1zi1zi2zi0_DataziTimeziClockziPOSIX_zdwposixSecondsToUTCTime_info
08:08:02 <preflex>  time-1.1.2.0_Data.Time.Clock.POSIX_$wposixSecondsToUTCTime_info
08:08:43 <mauke> preflex++ (I love you)
08:12:44 <tylere_> is there a way to get haskell-mode to align = signs in lets, wheres, etc?
08:14:09 <quicksilver> tylere_: there is a default binding on C-c C-= or something?
08:14:18 <quicksilver> I don't use it because I use kuribas' better indentation mode.
08:14:24 <quicksilver> But I just use align-regexp from time to time.
08:14:27 <tylere_> ok, thanks
08:16:04 <quicksilver> C-c C-. maybe it was
08:21:52 <zeno_> omg ghc is so much faster than ghci :)
08:22:18 <mauke> (compiler optimizations)++
08:22:20 <noecksit_> ok what i did was just rename the .ghc file and that worked, no longer recognized the new package.conf file, if i delete it probably nothing will break
08:23:13 * ski first read it as "alien-regexp"
08:23:19 <zeno_> any idea how to do timePrint, but instead of printing just force evaluation? http://hpaste.org/9823
08:23:26 <mmorrow> > length "unsafe"
08:23:26 <lambdabot>  mueval: Unsafe functions to use mentioned.
08:23:34 <mauke> fail
08:23:50 <ski> @let u = unsafePerformIO
08:23:51 <lambdabot> <local>:3:4: Not in scope: `unsafePerformIO'
08:24:04 <mauke> > hClose
08:24:05 <lambdabot> Terminated
08:24:49 <quicksilver> zeno_: in general you need something like 'rnf'
08:24:54 <quicksilver> to fully force a value.
08:24:59 <quicksilver> it's not something one needs often.
08:26:44 <zeno_> quicksilver: i guess just doing timePrint $ last $ whatIWantEvaluated will work in this case :)
08:27:28 <sw17ch> @let u = "unsafe"
08:27:29 <lambdabot> Defined.
08:27:31 <mmorrow> > length ["cache","throw","lock"]
08:27:31 <lambdabot>  mueval: Unsafe functions to use mentioned.
08:27:34 <sw17ch> > length u
08:27:35 <lambdabot>      Ambiguous occurrence `u'
08:27:35 <lambdabot>     It could refer to either `L.u', defined at ...
08:27:42 <sw17ch> :(
08:27:45 <mmorrow> > length ["c4che","throw","lock"]
08:27:46 <lambdabot>  mueval: Unsafe functions to use mentioned.
08:27:50 <mmorrow> > length ["c4che","thr0w","lock"]
08:27:50 <lambdabot>  mueval: Unsafe functions to use mentioned.
08:27:53 <mmorrow> > length ["c4che","thr0w","l0ck"]
08:27:54 <lambdabot>  3
08:27:57 <sw17ch> @let un = "unsafe"
08:27:58 <lambdabot> Defined.
08:28:01 <quicksilver> zeno_: no, it doesn't.
08:28:02 <sw17ch> > length un
08:28:03 <lambdabot>  6
08:28:11 <zeno_> mmorrow: wha why did it not work the first 3 time
08:28:17 <quicksilver> zeno_: it's very easy to construct a list where evaluating the last element doesn't evaluate everything.
08:28:40 <Deewiant> zeno_: like it said, unsafe functions mentioned
08:28:50 <zeno_> quicksilver: yeah this is a really specific case, its doing random playouts of a go game
08:28:59 <sw17ch> > (map (+ 1) [1.1000]) !! 999
08:29:00 <lambdabot>  mueval: Prelude.(!!): index too large
08:29:05 <zeno_> Deewiant: but it worked the last time
08:29:06 <sw17ch> > (map (+ 1) [1.100]) !! 99
08:29:07 <lambdabot>  mueval: Prelude.(!!): index too large
08:29:13 <sw17ch> > (map (+ 1) [1.100]) !! 98
08:29:15 <lambdabot>  mueval: Prelude.(!!): index too large
08:29:16 <Deewiant> zeno_: because unsafe functions weren't mentioned
08:29:21 <sw17ch> > (map (+ 1) [1.100])
08:29:22 <lambdabot>  [2.1]
08:29:28 <Deewiant> sw17ch: you might want two dots :-)
08:29:28 <sw17ch> > (map (+ 1) [1..100])
08:29:29 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
08:29:30 <zeno_> ohhh i see length wasnt unsafe it was cache etc
08:29:31 <sw17ch> lol
08:29:34 <sw17ch> > (map (+ 1) [1..100]) !! 99
08:29:35 <lambdabot>  101
08:29:38 <mmorrow> zeno_: because it's currently just trying to pattern match for words rather that parsing the haskell and checking identifier names
08:29:42 <sw17ch> that only computes the 99th index...
08:30:27 <LegendaryPenguin> is there some function to group based on a number?  Like group 2 "asbd" would give ["as","bd"]
08:30:32 <sw17ch> :t Language.Haskell.Parser.parseModule
08:30:33 <lambdabot> String -> Language.Haskell.ParseMonad.ParseResult Language.Haskell.Syntax.HsModule
08:30:46 <sw17ch> > Language.Haskell.Parser.parseModule "1 + 1"
08:30:47 <lambdabot>      Not in scope: `Language.Haskell.Parser.parseModule'
08:31:16 <sw17ch> wouldn't there be a slick way to parse the lambdabot stuff with that, and then use fmap to match on the idents?
08:31:39 <mmorrow> sw17ch: i already wrote a patch :)  http://code.haskell.org/~morrow/code/haskell/mueval-parsing-patch.diff
08:31:41 <lambdabot> http://tinyurl.com/563r2b
08:32:09 <Deewiant> LegendaryPenguin: not sure if there's an easy way to do that but writing a function which keeps using splitAt would work
08:32:26 <sw17ch> mmorrow, that's what i had in mind... yep :)
08:32:51 <quicksilver> LegendaryPenguin: No. I write it like this:
08:33:04 <quicksilver> groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
08:33:10 <noecksit_> is there a way to view the kind of a function in ghc?
08:33:18 <quicksilver> the kind of a function will be *
08:33:24 <quicksilver> all functions have kind * :)
08:33:31 <Deewiant> oh right, that's /that/ function
08:33:35 <Deewiant> wonder why I didn't recognize it
08:33:41 <LegendaryPenguin> that is too advanced for me
08:34:14 <quicksilver> it will still work though :)
08:34:16 <noecksit_> well, it says that my function has kind * -> * but its expected kind is *
08:34:32 <quicksilver> let groupsOf n = takeWhile (not.null) . map (take n)  . iterate  (drop n) in groupsOf 2 "asbd"
08:34:36 <quicksilver> >let groupsOf n = takeWhile (not.null) . map (take n)  . iterate  (drop n) in groupsOf 2 "asbd"
08:34:39 <quicksilver> > let groupsOf n = takeWhile (not.null) . map (take n)  . iterate  (drop n) in groupsOf 2 "asbd"
08:34:40 <lambdabot>  ["as","bd"]
08:34:45 <mmorrow> LegendaryPenguin: ooh, i have the perfect link for you ..
08:34:49 <randomity> noecksit_: something of kind * -> * isn't a function, it's a type constructor (like Map)
08:34:51 <quicksilver> noecksit_: no it doesn't.
08:34:58 <quicksilver> noecksit_: that must be a type constructor :)
08:35:10 <b\6> having problems making State String String an instance of Show. what should show look like?
08:35:18 <mmorrow> heres a page with ~10 diff versions of that func
08:35:20 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5
08:35:26 <quicksilver> I don't imagine State String String can be a useful instance of Show.
08:35:27 <noecksit_> quicksilver: well actually it is, its a data constructor
08:35:34 <quicksilver> what makes you think it is?
08:35:44 <quicksilver> noecksit_: no data constructor has kind * -> *
08:35:47 <sw17ch> mmorrow, are we talking abuot chunk again?
08:35:49 <quicksilver> data constructors all have kind *
08:35:55 <sw17ch> hah, yes we are
08:35:59 <b\6> maybe i said it wrongly. i want to examine a State String String.
08:36:02 <mmorrow> sw17ch: heh
08:36:04 <sw17ch> IMHO, the CPS one is the best :)
08:36:08 <quicksilver> b\6: all you can do is run it on some values.
08:36:13 <mmorrow> sw17ch: :)
08:36:16 <quicksilver> b\6: that's the best way to examine it.
08:36:56 <sw17ch> though, i'm guessing the splitAt one works out to about the same asymptotic runtime
08:37:07 <sw17ch> @src splitAt
08:37:07 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:37:25 <sw17ch> bah... i wish that there was a @real-src-not-the-easy-one
08:38:02 <mmorrow> sw17ch: the splitAt seems to be better for larger chunk sizes
08:38:28 <Deewiant> sw17ch: the @real-src looks quite ugly
08:38:34 <sw17ch> Deewiant, oh, i know
08:38:39 <Deewiant> unboxed types galore
08:38:42 <sw17ch> doesn't stop me from wanting to see it occasionally :)
08:38:56 <mmorrow> sw17ch: while the cps or the explicitly recursive ones are better for small chunk sizes
08:39:09 <sw17ch> what about for when you have a lot of chunking to do?
08:39:33 <sw17ch> (in my case, i've been using chunk to do hundreds of thousands of chunks)
08:39:40 <mmorrow> maybe do a test on the chunk size, then use the best variant for that size?
08:39:46 <b\6> i feel like upchunking a few thousand.
08:40:05 <quicksilver> @remember b\6 i feel like upchunking a few thousand
08:40:05 <lambdabot> Okay.
08:40:23 <mmorrow> sw17ch: oh, i see. it seems that the chunk *size* os the important thing, not the eventual number of chunks you compute
08:40:28 <mmorrow> s/os/is/
08:41:16 <mmorrow> b\6: lol
08:42:04 * sw17ch waits for his hackage account...
08:42:16 <b\6> 8()~~~ state monads
08:43:40 <sw17ch> that took me a second, but now a coworker is looking at me funny...
08:43:49 <sw17ch> thanks for making me make a spectacle
08:43:59 <b\6> desperate times.
08:44:09 <b\6> monads out of control.
08:44:30 <b\6> you don't even want to hear about these side effects.
08:45:47 <b\6> i'm retarded. in c, i pass pointers to context structs to functions so they can alter the members. does State help me do anything like that?
08:45:58 <quicksilver> yes.
08:46:09 <quicksilver> State (your context struct) (return value)
08:46:24 <quicksilver> is an action which can modify the context structs as well as return a value.
08:46:47 <mauke> State gives you a single implicit variable
08:47:01 <b\6> like magical global?
08:47:05 <b\6> that's how it seems.
08:47:17 <mauke> it's pseudoglobal
08:47:21 <quicksilver> it's not remotely global really
08:47:23 <mauke> like member variables in C++
08:47:27 <quicksilver> it's very local to the action
08:47:37 <quicksilver> but it might be used for some things globals are used for.
08:48:05 <b\6> what does the function that does useful stuff involving the state look like?
08:48:28 <Deewiant> > let f = modify (+1) in execState f 0
08:48:29 <lambdabot>  1
08:49:04 <ibid> DrSyzygy: pong?
08:49:23 <b\6> what's its type?
08:49:33 <mauke> :t modify (+1)
08:49:33 <Deewiant> ?ty let f = modify (+1) in f
08:49:34 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => m ()
08:49:34 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => m ()
08:49:48 <Deewiant> > let f = modify (+1) >> return "foo" in runState f 0
08:49:49 <lambdabot>  ("foo",1)
08:50:45 <mauke> > runState (do { x <- get; put (x + 1); return (show x) }) 41
08:50:45 <quicksilver> although the use of 'runState' pins the type down further
08:50:46 <lambdabot>  ("41",42)
08:50:57 <mauke> :t runState
08:50:58 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
08:51:01 <LegendaryPenguin> is there a source plugin for emacs?  like @src function
08:53:30 <b\6> sorry, still hazy on the function that operates using the state. do i return a tuple? thought 'get' gives me whatever is contained, i mess with it and 'put' it back and return whatever the useful value is.
08:53:51 <quicksilver> you're right about get and put.
08:53:58 <dcoutts> sjanssen: I've got a slightly different fix which you might like to test: http://hackage.haskell.org/trac/hackage/ticket/333
08:53:59 <mauke> you return whatever you want
08:54:03 <lambdabot> Title: #333 (Setup sdist --snapshot fails) - Hackage - Trac
08:54:56 <b\6> not understanding how to give it access to the implicit state or put it in the state monad or whatever the terminology is.
08:54:58 <quicksilver> the action as a whole has a return type as well.
08:55:07 <quicksilver> b\6: get accesses the implicit state.
08:55:08 <mauke> b\6: to give what access?
08:55:10 <quicksilver> put replaces it.
08:55:18 <quicksilver> that sounded like the bit you understood :)
08:55:42 <b\6> but the type somehow tags it. get wouldn't make any sense without indicating it's in state.
08:55:46 <b\6> i think.
08:56:06 <mauke> @src MonadState
08:56:06 <lambdabot> Source not found. Wrong!  You cheating scum!
08:57:23 <quicksilver> b\6: yes, that's true.
08:57:36 <quicksilver> b\6: as you say, the type indicates that it must be in a monad with state
08:57:39 <quicksilver> which is what MonadState means.
08:57:44 <quicksilver> :t get
08:57:45 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
08:58:07 <mmorrow> > let fib n = evalState (replicateM n (get >>= \(m,n) -> put (n,n+m) >> return m)) (0,1) in fib 10
08:58:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
08:58:17 <mmorrow> > let fib n = runState (replicateM n (get >>= \(m,n) -> put (n,n+m) >> return m)) (0,1) in fib 10
08:58:19 <lambdabot>  ([0,1,1,2,3,5,8,13,21,34],(55,89))
08:58:36 <mmorrow> > let fib n = execState (replicateM n (get >>= \(m,n) -> put (n,n+m) >> return m)) (0,1) in fib 10
08:58:37 <lambdabot>  (55,89)
08:59:18 <b\6> if foo needs an Int, returns a String, and does its stuff in State, what is its type? Int -> State Whatever String?
08:59:31 <mauke> yes
08:59:33 <Deewiant> yep
08:59:59 <b\6> like if i make a state called Twilight i could think of stuff as executing in the twilight zone.
09:00:10 <mmorrow> yes!
09:00:14 <b\6> or perhaps a football simulation with an End zone.
09:00:34 <mmorrow> only if you have a referentially transparent endzone dance
09:00:48 <mauke> @unmtl Int -> State Whatever String
09:00:49 <lambdabot> Int -> State Whatever String
09:00:57 <mauke> :-|
09:01:04 <Deewiant> @unmtl Int -> State a String
09:01:04 <lambdabot> Int -> State a String
09:01:10 <Deewiant> meh
09:01:15 <mauke> @unmtl State Whatever String
09:01:16 <lambdabot> Whatever -> (String, Whatever)
09:01:54 <mmorrow> @type mapAccumL
09:01:55 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:02:24 <b\6> thanks, everyone.
09:02:36 <b\6> sorry to be baby in crib all smearing my applesauce in the keyboard.
09:02:42 <mauke> heh
09:05:57 <haskellian> question: length x > 0 or head x == True, will length x evaluate the whole list or can i because of lazy evaluation say that all it need to prove is that he list is 1 element and can then quit?
09:06:17 <mauke> length x will evaluate the whole list
09:07:22 <mmorrow> > (not . null) [1,2]
09:07:23 <lambdabot>  True
09:07:26 <mmorrow> > (not . null) [1]
09:07:27 <lambdabot>  True
09:07:28 <mmorrow> > (not . null) []
09:07:30 <lambdabot>  False
09:07:38 <quicksilver> haskellian: unless you have suitable implementation of lazy numbers
09:07:51 <quicksilver> haskellian: along with a lazy Ord instance (for >)
09:08:11 <mauke> @check liftM2 (==) ((== 0) . length) null
09:08:12 <lambdabot>  "OK, passed 500 tests.\n"
09:08:23 <quicksilver> which probably not a good solution really :)
09:08:26 <quicksilver> but interesting tot hink about.
09:08:55 <mmorrow> @src null
09:08:55 <lambdabot> null []     = True
09:08:55 <lambdabot> null (_:_)  = False
09:09:12 <haskellian> length x > 0 or head x == True. not one function, to separate to choose from, but I guess checking if head of x is true is faster then
09:09:26 <mmorrow> oh
09:09:29 <haskellian> wait that doesnt work
09:09:37 <mauke> head x == True better written as head x
09:09:53 <haskellian> (not . null) []
09:10:02 <quicksilver> I disagree.
09:10:12 <quicksilver> head x == True better written as head x == True ;)
09:10:23 <mauke> nooo
09:10:45 <mmorrow> let f [] = False ; f (True:_) = True in f (repeat True)
09:10:48 <mmorrow> > let f [] = False ; f (True:_) = True in f (repeat True)
09:10:49 <lambdabot>  True
09:11:06 <mauke> what
09:11:09 <mmorrow> oops,
09:11:22 <mmorrow> > let f [] = False ; f (True:_) = True ; f _ = False in f (repeat False)
09:11:23 <lambdabot>  False
09:11:40 <mauke> > head (repeat False)
09:11:41 <lambdabot>  False
09:11:45 <mauke> much simpler
09:11:48 <mmorrow> > head []
09:11:49 <lambdabot>  mueval: Prelude.head: empty list
09:11:57 <mauke> > head (repeat False ++ [False])
09:11:58 <lambdabot>  False
09:12:02 <mauke> > head ([] ++ [False])
09:12:03 <lambdabot>  False
09:26:10 <yitz> haskellian: use not . null
09:28:31 <chylli> how can program sleep several seconds ?
09:28:38 <chylli> what's the io action ?
09:28:48 <mauke> threadDelay
09:28:49 <yitz> chylli: threadDelay
09:29:02 <yitz> @index threadDelay
09:29:02 <lambdabot> GHC.Conc, Control.Concurrent
09:29:13 <quicksilver> win 27
09:29:35 <chylli> yitz: thanks
09:29:44 <mmorrow> chylli: make sure you compile with -threaded if you don't want that to block all threads
09:29:55 <mauke> mmorrow: are you sure about that?
09:29:56 <mmorrow> (if there are >1)
09:29:59 <mmorrow> mauke: no
09:30:07 <quicksilver> that doesn't sound right at all.
09:30:15 <quicksilver> -threaded is about using more than one core
09:30:21 <quicksilver> or about asyncrhonous FFI
09:30:30 <quicksilver> it shouldn't matter for pure haskell
09:30:36 <mmorrow> hmm
09:30:48 <quicksilver> the non-threaded RTS does its own pre-emption between threads.
09:31:01 <quicksilver> 'non-threaded' indicates that it doesn't support multiple OS threads
09:31:09 <quicksilver> no that it doesn't support multiple haskell threads.
09:31:51 <mmorrow> hmm, but i thought -threaded turn on the threaded runtime
09:32:24 <mmorrow> *turns
09:33:04 * mmorrow rtfm to get things straight
09:33:23 <quicksilver> indeed.
09:33:30 <quicksilver> btu the non-threaded runtime can still do threads.
09:33:38 <quicksilver> hence my comment above
09:33:46 <quicksilver> "'non-threaded' indicates that it doesn't support multiple OS threads"
09:34:33 <mmorrow> yeah, i thought that was wrt haskell lightweight threads, and w/out -threaded ghc didn't preemptively schedule the lightweight threads
09:35:10 <quicksilver> -threaded means use "Real" threads under some circumstances
09:35:16 <mauke> all scheduling is preemptive
09:35:21 <mmorrow> cool
09:35:33 <quicksilver> memory allocation pre-emption
09:35:34 <quicksilver> not perfect
09:35:40 <mauke> it hooks into IO operations and allocation
09:35:46 <quicksilver> but fortunatley it's pretty hard to write haskell code which doesn't allocate memory :)
09:35:59 <mmorrow> heh
09:36:56 * sw17ch has a hackage account... woohoo!
09:37:16 <cyrax_> heh
09:38:09 <GremlinHunter> Hackage wouldnt be so cool if it were pronounced like dressage
09:38:49 <mmorrow> ok, now it understand why building some things with -threaded gives a significant slowdown
09:38:53 <mmorrow> s/it/i/
09:43:29 <haskellian> can i filter and break when i found an elemnt? lets say i have list of reviews and there casn only be one with the ID 1, can I use filter and then break and return that review when/if found?
09:43:44 <mauke> there's no reason to break
09:43:49 <byorgey> haskellian: just use filter and head
09:43:50 <Deewiant> dropWhile / takeWhile
09:43:55 <mauke> just use filter and take 1
09:44:00 <byorgey> laziness means that only as much as needed will be computed.
09:44:10 <byorgey> i.e. it won't keep looking through the rest of the list.
09:44:29 <byorgey> laziness obviates the need for explicit breaks.
09:44:51 <|Steve|> How about just find it?
09:44:58 <|Steve|> :t find
09:44:59 <lambdabot> Not in scope: `find'
09:45:03 <byorgey> > head . filter (>5) $ [1..]
09:45:05 <lambdabot>  6
09:45:10 <|Steve|> Damn. I know there's some function to do that.
09:45:20 <byorgey> well, there's findIndex
09:45:44 <sw17ch> @index indexOf
09:45:44 <lambdabot> bzzt
09:45:53 <byorgey> @type index
09:45:54 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
09:45:55 <sw17ch> oh, that's in PrototypeJS... not Data.List :)
09:46:01 <GremlinHunter> :t findElem
09:46:02 <BMeph> quicksilver: Isn't it really simple to write haskell code that doesn't allocate memory?
09:46:02 <byorgey> hehe
09:46:02 <lambdabot> Not in scope: `findElem'
09:46:08 <sw17ch> :t elem
09:46:09 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:46:12 <Deewiant> :t findIndex
09:46:13 <lambdabot> Not in scope: `findIndex'
09:46:17 <Deewiant> O_o
09:46:21 <syscrash> you need Data.List for findIndex
09:46:21 <quicksilver> BMeph: let x = x in x ?
09:46:22 <syscrash> i think
09:46:23 <Deewiant> > findIndex (==6) [1..]
09:46:24 <lambdabot>  Just 5
09:46:28 <syscrash> lol
09:46:29 <|Steve|> Hmm, there has to be some function like (a -> Bool) -> [a] -> Maybe a
09:46:33 <quicksilver> BMeph: it's quite hard to write 'useful' haskell code that doesn't allocate memory.
09:46:38 <mmorrow> > foldr (.) id (repeat read) $ fix show
09:46:41 <lambdabot>  "
09:46:41 <byorgey> > find (==6) [1..]
09:46:42 <haskellian> when deriving Eq and Ord from a Data, is that something I have to implement then? Or if I have a data: data Customer = Customer { idnumber :: Int, reviews :: [Review] } deriving (Eq, Ord, Show) and want to sort a list of customers, will it work then? what will it sort on?
09:46:42 <lambdabot>  Just 6
09:46:50 <byorgey> |Steve|: you're right, it's 'find'
09:46:59 <byorgey> for some reason the @type command isn't working right
09:47:00 <quicksilver> haskellian: lexicographic
09:47:05 <quicksilver> haskellian: so id before review
09:47:08 <haskellian> ?
09:47:12 <byorgey> it isn't searching Data.List
09:47:13 <BMeph> quicksilver: Hey, hey, what's with all this 'useful' language? You're changing the parameters of the conjecture! ;)
09:47:15 <quicksilver> it will sort on id.
09:47:24 <quicksilver> if there were two customers with the same id
09:47:27 * BMeph is enjoying reading the "Proofs and Refutations" book
09:47:28 <quicksilver> it would sort on reviews.
09:47:38 <byorgey> BMeph: which book is that?
09:47:41 <|Steve|> byorgey: Oh good. My memory is bad enough without lambdabot telling me I'm wrong.
09:47:46 <byorgey> hehe
09:48:00 <Deewiant> ?ty Data.List.find
09:48:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:48:37 <ddarius> byorgey: Probably the one titled "Proofs and Refutations"
09:49:41 <b\6> keep this info private, but you can actually overclock your brain. the technique i use is to loop mplayer playing oggs but increase the speed like -speed 1.25 for 125% normal. your brain's speed increases accordingly, allowing you to solve problems much more easily.
09:49:48 <ddarius> @hoogle (a -> Bool) -> [a] -> Maybe a
09:49:48 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:49:48 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:49:48 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:50:07 <b\6> after a few seconds at -speed 4 all my most advanced work looked like homework assignments for first graders, but my brain tissue actually started to break down, so watch it.
09:50:19 <byorgey> b\6: haha!
09:50:33 <b\6> keep the speed between like 1.1 and 1.4 and nobody'll get too suspicious.
09:52:38 <guenni> quicksilver: ping
09:55:18 * sw17ch has an inferior media player incapable of brain overclocking :(
09:56:35 <guenni> I need some help comprehending this: http://hpaste.org/9824
09:56:59 <MyCatVerbs> b\6: the real trick to success is to sneak an iPod with on it rhythmbox turned down somewhere between 0.6 and 0.8 into cocktail parties. Makes dealing with people much easier.
09:57:00 <guenni> the 4th line, I'm not sure what it means
09:57:06 <yitz> guenni: looks like HaXml
09:57:17 <guenni> yitz: it is :)
09:57:32 <guenni> I just not sure about the 4th line
09:57:43 <sw17ch> guenni, looks like it's matching on a [CElem]
09:57:44 <guenni> never encounterd this before
09:57:45 <sw17ch> with one element
09:58:01 <sw17ch> unpacking the CElem, taking the first parameter and binding it to dict, and tossing the second parameter
09:58:20 <sw17ch> so, i'm guessing that the stuff to the right has a type of [CElem]
09:58:26 <guenni> yep, i got that part but
09:58:39 <guenni> I've never seen it done with a list
09:58:43 <sw17ch> yeah :)
09:58:53 <sw17ch> > [a,b,c,d] = "john"
09:58:53 <lambdabot>  Parse error at "=" (column 11)
09:58:58 <guenni> it's basically destructuring
09:59:02 <sw17ch> > let [a,b,c,d] = "john" in [a,b]
09:59:03 <lambdabot>  "jo"
09:59:10 <sw17ch> > let [a,b,c,d] = "john"n in [a,b]
09:59:11 <lambdabot>  Couldn't match expected type `t1 -> [t]'
09:59:15 <sw17ch> woops
09:59:19 <sw17ch> > let [a,b,c,d] = "johnn" in [a,b]
09:59:20 <lambdabot>  "
09:59:31 <sw17ch> well, that's not right...
09:59:39 <trofi> 4 letters
09:59:40 <sw17ch> isn't that a pattern match error?
09:59:48 <sw17ch> trofi, i was tryingto break it
10:00:04 <guenni> > let [a, b] = "john" in (a,b)
10:00:05 <lambdabot>  (
10:00:20 <guenni> ?
10:00:40 <sw17ch> yeah, that's odd...
10:00:52 <guenni> > let [a, b, c, d] = "john" in (a,b)
10:00:53 <lambdabot>  ('j','o')
10:00:54 <sw17ch> if you want to match on a list, and not contrain the length...
10:01:08 <sw17ch> > let (a:b:c:d:_) = "johnnnnnnn" in (a,b)
10:01:09 <lambdabot>  ('j','o')
10:01:25 <trofi> @ let foo Nothing = 1
10:01:26 <trofi> @let foo Nothing = 1
10:01:27 <lambdabot> Defined.
10:01:32 <trofi> > foo []
10:01:33 <lambdabot>  Couldn't match expected type `Maybe t' against inferred type `[a]'
10:01:39 <guenni> thx sw17ch
10:01:55 <sw17ch> pattern matching is neato
10:01:58 <guenni> you can see why this caused confusion :)
10:02:14 <trofi> > let { f 0 = 1; f 1 = 2 } in f 2
10:02:16 <lambdabot>  mueval: /tmp/1080790082139423999:59:32-47: Non-exhaustive patterns in functi...
10:02:33 <sw17ch> is that a guid i see there?
10:02:43 <sw17ch> no.. it's not
10:02:57 <guenni> come again sw17ch?
10:03:06 <sw17ch> sorry. i was looking at lambdabots output
10:03:12 <sw17ch> "/tmp/1080790082139423999:59:32-47:"
10:03:38 <guenni> sw17ch: what's neato?
10:03:46 <sw17ch> oh, pattern matching
10:03:52 <sw17ch> :)
10:04:00 <trofi> > let { f [] = 1; f [a] = 2 } in f "hi"
10:04:00 <sw17ch> it can do some crazy stuff
10:04:01 <lambdabot>  mueval: /tmp/4883373293810390800:59:29-47: Non-exhaustive patterns in functi...
10:04:31 <haskellian> after programming python again yesterday(python is my main and favourite language) I must say I missed Haskell, felt a bit criplled at times, the Haskell typesystem really is awesome
10:04:40 <trofi> > let { eff [a1,a2,a3,a4] = (a1,a2) } in eff "hi"
10:04:41 <lambdabot>  mueval: /tmp/8761726902560110524:59:33-59: Non-exhaustive patterns in functi...
10:04:53 <trofi> > let { eff [a1,a2,a3,a4] = (a1,a2) } in eff "hia!"
10:04:54 <lambdabot>  ('h','i')
10:05:18 <trofi> maybe troubles are in predefined a..z?
10:05:30 <trofi> > let { eff [a1,a2,a3,a4] = [a1,a2] } in eff "hia!!"
10:05:32 <lambdabot>  "
10:05:37 <trofi> > let { eff [a1,a2,a3,a4] = [a1,a2] } in eff "hia!!!!!!!"
10:05:38 <lambdabot>  "
10:05:51 <trofi> > let { eff [a1,a2,a3,a4] = ([a1,a2]) } in eff "hia!!!!!!!"
10:05:52 <lambdabot>  "
10:06:10 <trofi> :t "hi"
10:06:11 <lambdabot> [Char]
10:06:33 <trofi> @say hi
10:06:33 <lambdabot> Maybe you meant: faq map slap src
10:06:40 <Deewiant> @slap hi
10:06:40 * lambdabot activates her slap-o-matic...
10:06:41 <trofi> @show hi
10:06:41 <lambdabot> "hi"
10:06:53 <trofi> @. show run let { eff [a1,a2,a3,a4] = ([a1,a2]) } in eff "hia!!!!!!!"
10:06:54 <lambdabot> " \"\n"
10:06:58 <sw17ch> i didn't realize lambdabot was female
10:07:37 <sw17ch> i always thought of lambdabot as this gender-neutral entity of stupid brilliance :)
10:07:38 <Botje> @vixen ASL?!
10:07:38 <lambdabot> no
10:08:50 <trofi> @. show run let { eff [_,_,_,_] = 42 } in eff "hia!!!!!!!"
10:08:51 <lambdabot> " mueval: /tmp/3226437459374060496:59:29-46: Non-exhaustive patterns in functi...\n"
10:08:59 <trofi> %)
10:09:10 <trofi> @. show run let { eff [_,_,_,_] = (1,2) } in eff "hia!!!!!!!"
10:09:11 <lambdabot> " mueval: /tmp/3275671115141176128:59:29-49: Non-exhaustive patterns in functi...\n"
10:09:17 <trofi> @. show run let { eff [a,b,c,d] = (1,2) } in eff "hia!!!!!!!"
10:09:19 <lambdabot> " mueval: /tmp/2980378891419824673:59:29-49: Non-exhaustive patterns in functi...\n"
10:09:28 <Deewiant> @. show . run let { eff [a,b,c,d] = (1,2) } in eff "hia!!!!!!!"
10:09:29 <trofi> @. show run let { eff [a,b,c,d] = [1,2] } in eff "hia!!!!!!!"
10:09:29 <lambdabot> " <interactive>:2:1: parse error (possibly incorrect indentation)\nmueval: Unkn...\n"
10:09:30 <lambdabot> " mueval: /tmp/3766330365473210386:59:29-49: Non-exhaustive patterns in functi...\n"
10:09:57 <Deewiant> @. . show run let { eff [a,b,c,d] = (1,2) } in eff "hia!!!!!!!"
10:09:57 <lambdabot> Plugin `compose' failed with: Unknown command: "\"run"
10:10:29 <MyCatVerbs> sw17ch: haven't you seen \bot's picture?
10:10:46 <MyCatVerbs> sw17ch: http://www.haskell.org/haskellwiki/Lambdabot
10:10:47 <sw17ch> MyCatVerbs, i suppose not
10:10:49 <lambdabot> Title: Lambdabot - HaskellWiki
10:11:05 <sw17ch> MyCatVerbs, awesome
10:11:07 <Deewiant> O_o
10:11:39 <MyCatVerbs> sw17ch: indeed it is, yes.
10:12:25 <trofi> @. show run let { eff [arg1, arg2] = [arg1] } in eff "123"
10:12:26 <lambdabot> " \"\n"
10:14:55 <lispy> http://www.reddit.com/comments/6xe4i/darcs_2_realworld_push_performance_evaluation/
10:14:56 <lambdabot> Title: Darcs 2 Real-World Push Performance Evaluation : reddit.com, http://tinyurl.com/6bqmh4
10:17:33 <ddarius> You have an Excel tag?
10:18:00 <IsoPallo> Is there some separate Curry irc in some server or shall I just ask here?
10:18:10 <lispy> ddarius: yeah, I have some stuff about SpreadSheetML
10:18:22 <ddarius> IsoPallo: Asking here isn't going to be particularly helpful.
10:18:50 <oklopol> IsoPallo: awesome nick
10:19:29 <IsoPallo> ddarius: I always saw Curry as Haskell spinoff...
10:19:32 <Twey> Is there a built-in action like hGetLine that handles either \n or \r\n?
10:19:54 <IsoPallo> oklopol: Hmm... Thanks I suppose :)
10:19:55 <ddarius> IsoPallo: That doesn't mean here will be a good place to ask questions about it.
10:20:49 <dmhouse> Twey: maybe fmap (takeWhile (not . (`elem` "\r\n"))) . repeatM hGetChar
10:21:13 <Twey> dmhouse: That's a 'no' then :-P
10:21:19 <Twey> Thanks
10:21:29 <ddarius> hGetLine will use the OS convention
10:21:32 <dmhouse> (I don't know whether repeatM is lazy enough for that to work.)
10:21:34 * Twey nods.
10:22:10 <Twey> Why fmap and not mapM?
10:22:22 <ddarius> If you are on Windows, you can change it to use \n.
10:22:39 <dmhouse> Twey: there's no difference on monads.
10:22:41 <Twey> ddarius: Can I change it to use \r\n on 'nix?
10:22:55 <ddarius> No.  At least, not to my knowledge.
10:22:58 <dmhouse> Twey: I prefer fmap because 1) it's a character shorter, and 2) you don't have to import it from Control.Monad
10:23:02 <Twey> dmhouse: Aye, I just wondered if it was good style.
10:23:05 <Twey> 'kay.  :)
10:23:07 <BMeph> lispy: I hope you got permission from dons before you posted that reddit link. ;)
10:23:15 <lispy> BMeph: hehe
10:23:21 <Twey> ddarius: Hmn.  Thanks.
10:23:24 <dmhouse> Err, it's not a character shorter...
10:23:30 <Twey> Haha
10:23:33 <dmhouse> I don't know why I had that down as an advantage in my mind.
10:23:34 <Twey> It's a keystroke shorter.
10:23:35 <ddarius> :t fmap
10:23:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:23:36 <ddarius> :t mapM
10:23:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:23:37 <Arnar> dmhouse: if you count the shift key it is
10:23:42 <lispy> BMeph: I sort of expected I blog that and then come here to see that dons had already posted it :)
10:23:49 <dmhouse> Oh!
10:23:53 <Arnar> :t Prelude.fmap
10:23:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:23:55 <dmhouse> fmap is equivalent to liftM on monads,
10:24:08 <dmhouse> And it _is_ a character shorter than that.
10:24:18 <dmhouse> Twey: mapM has nothing to do with it ;)
10:24:49 <mc__> noobie question:  I want to iterate over map whix uses a (Int,Int) tuple as key, so I need to generate the numbers for acess. In a traditional language i would do this with 2 nested for-loops. How should I do it in Haskell?
10:25:02 <chrisdone> `io' is just better than `liftIO'
10:25:12 <trofi> :t io
10:25:13 <lambdabot> Not in scope: `io'
10:25:48 <Twey> Ah, dmhouse
10:25:49 <Twey> Haha
10:25:58 <Twey> chrisdone: Lies :-P
10:26:03 <Lemmih> mc__: Can't you just use 'map'?
10:27:10 <dmhouse> mc__: list comprehension, but you don't need do generate the keys to map over...
10:27:59 <mc__> i need to print the values out but I want to append a "|" to all but the last value, i do not know how to do this with map or list comprehension
10:28:24 <Deewiant> > intercalate "|" ["foo","bar","baz"]
10:28:25 <dmhouse> ?hoogle intersperse
10:28:25 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
10:28:25 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:28:25 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
10:28:25 <lambdabot>  "foo|bar|baz"
10:29:19 <yitz> @check \x y -> intercalate x y = concat $ intersperse x y
10:29:19 <lambdabot>  Parse error at "=" (column 25)
10:29:25 <dmhouse> > concat $ intersperse ["foo", "bar", "baz"] {- if you don't have a recent enough version of GHC
10:29:25 <lambdabot>  Unterminated nested comment at "]" (column 42)
10:29:28 <dmhouse> > concat $ intersperse ["foo", "bar", "baz"] {- if you don't have a recent enough version of GHC -}
10:29:29 <lambdabot>  Couldn't match expected type `[[a]]'
10:29:30 <yitz> @check \x y -> intercalate x y == concat $ intersperse x y
10:29:31 <lambdabot>  Couldn't match expected type `[a]'
10:29:43 <Deewiant> @check \x y -> intercalate [x] y == concat $ intersperse x y
10:29:44 <lambdabot>  Couldn't match expected type `[a]'
10:29:56 <Deewiant> @check \x y -> intercalate [x] y == intersperse x y
10:29:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:29:57 <lambdabot>       Expected...
10:29:58 <trofi> @help check
10:29:59 <lambdabot> check <expr>
10:29:59 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
10:30:04 <Deewiant> ?ty intercalate
10:30:04 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:30:10 <trofi> @check True
10:30:11 <lambdabot>  "OK, passed 500 tests.\n"
10:30:13 <Deewiant> @check \x y -> intercalate [x] (concat y) == intersperse x y
10:30:14 <lambdabot>      Occurs check: cannot construct the infinite type: a = [[a]]
10:30:14 <lambdabot>       Expect...
10:30:16 <yitz> @type \x y -> concat $ intersperse x y
10:30:17 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:30:20 <Deewiant> baah
10:30:25 <trofi> try :: [[Char]]
10:30:57 <yitz> @check \x y -> intercalate x y == concat (intersperse x y)
10:30:59 <lambdabot>  "OK, passed 500 tests.\n"
10:31:10 <trofi> @check \xs -> xs == reverse.reverse xs
10:31:11 <lambdabot>  Couldn't match expected type `a -> [a1]'
10:31:16 <trofi> @check \xs -> xs == reverse.reverse xs :: [Char]
10:31:16 <lambdabot>  Couldn't match expected type `a -> [a1]'
10:31:37 <Botje> (reverse . reverse) xs
10:31:45 <trofi> @check reverse.reverse xs :: [Char]
10:31:46 <lambdabot> Terminated
10:31:50 <trofi> @check (reverse.reverse) xs :: [Char]
10:31:51 <lambdabot> Terminated
10:32:07 <dmhouse> ?check \xs -> (reverse . reverse) xs == xs
10:32:08 <lambdabot>  "OK, passed 500 tests.\n"
10:32:24 <Twey> dmhouse: Uhm... silly question... where's repeatM?  :)
10:32:35 <lispy> :index repeatM
10:32:40 <trofi> :fixity .
10:32:41 <lispy> ?index repeatM
10:32:41 <lambdabot> bzzt
10:32:44 <gwern> @hoogle repeatM
10:32:44 <lambdabot> No results found
10:32:47 <yitz> Twey: missing from the libs
10:32:49 <trofi> @src (.)
10:32:49 <lambdabot> (f . g) x = f (g x)
10:32:49 <lambdabot> -- In lambdabot, it's been generalised to:
10:32:49 <lambdabot> (.) = fmap
10:32:51 * Twey blinks.
10:33:01 <Deewiant> ?ty replicateM
10:33:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:33:05 <dmhouse> Oh, sorry.
10:33:07 <Twey> Aha
10:33:08 <Twey> Heh
10:33:10 <Twey> Thanks
10:33:12 <yitz> Twey: I define it myself all the time.
10:33:19 <tylere_> > reverse [1,2,3]
10:33:20 <lambdabot>  [3,2,1]
10:33:21 <dmhouse> ?type sequence . repeat
10:33:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:33:30 <tylere_> neat
10:34:57 <trofi> :t reverse
10:34:58 <lambdabot> forall a. [a] -> [a]
10:35:10 <Twey> dmhouse: Hmn
10:35:13 <Twey>     No instance for (Monad ((->) Handle))
10:35:23 <dmhouse> Twey: pastebin
10:35:24 <gwern> @src (.)
10:35:24 <lambdabot> (f . g) x = f (g x)
10:35:24 <lambdabot> -- In lambdabot, it's been generalised to:
10:35:24 <lambdabot> (.) = fmap
10:35:26 <trofi> :t \xs -> xs == reverse xs
10:35:27 <lambdabot> forall a. (Eq a) => [a] -> Bool
10:35:34 <gwern> oops
10:35:36 <gwern> I'd better fix that
10:35:38 <trofi> @instances Eq
10:35:39 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:35:53 <trofi> @src Dual
10:35:53 <lambdabot> Source not found.
10:36:36 <trofi> @hoogle Dual
10:36:37 <lambdabot> Data.Monoid Dual :: a -> Dual a
10:36:37 <lambdabot> Data.Monoid newtype Dual a
10:36:37 <lambdabot> Data.Monoid getDual :: Dual a -> a
10:37:00 <BMeph> Isn't mapM the prototype for traverse? :)
10:37:17 <lilac> > (+2) . [1,2,3]
10:37:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:37:25 <Twey> dmhouse: http://hpaste.org/9825
10:37:43 <Twey> Oh!
10:37:46 * Twey is stupid.
10:37:48 <Deewiant> ?ty (.)
10:37:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:37:59 <Deewiant> meh
10:38:01 <trofi> > pred."asd"
10:38:03 <lambdabot>  Couldn't match expected type `a -> b'
10:38:03 <Twey> Oh no
10:38:06 <Twey> Still there
10:38:15 <dmhouse> Twey: $ before hGetChar
10:38:19 <Twey> I left an explicit handle in, pretend it's not there, the error's the same :-P
10:38:26 <Twey> Aha
10:38:55 <dmhouse> Twey: f . g x parses as f . (g x) since function application binds tighter than anything else
10:39:39 <Twey> dmhouse: Same error
10:40:43 <dmhouse> Twey: patebin again
10:41:26 <dmhouse> Twey: oh, hang on
10:41:41 <Twey> dmhouse: http://hpaste.org/9825#a1
10:41:42 <dmhouse> I meant . before hGetChar, not $, I didn't read the function properly
10:41:58 <Twey> Oh!  Haha
10:42:05 <Twey> Of course... that works, thanks :)
10:42:37 <dmhouse> Twey: what is moklu?
10:43:33 <Twey> dmhouse: Part of a potentially interesting bot structure
10:44:00 <Botje> will it seek out and destroy other bots written in imperative languages?
10:44:08 * Twey laughs.
10:44:21 <Twey> Botje: It does that just by virtue of being written in Haskell
10:44:25 <Twey> They all drop dead from shame
10:44:39 <noecksit_> is there a function to get read of carriage returns in strings?
10:44:46 * Twey laughs.
10:44:53 <Botje> :)
10:44:55 <Twey> noecksit_: Read up, perhaps
10:44:56 <dmhouse> noecksit_: filter (/= "\n")
10:45:05 <Twey> That's not a carriage return, dmhouse
10:45:10 <Twey> \r
10:45:18 <Botje> also, you mean '' :)
10:45:23 * Twey nods.
10:45:31 <Twey> I made that mistake yesterday :(
10:45:40 <dmhouse> Yeah, all those things.
10:46:04 <noecksit_> so id have to treat it as a literal, i guess
10:46:21 <sw17ch> is :) a valid operator?
10:46:24 <Botje> could also do (/= (fromEnum 15)
10:46:33 <Botje> sw17ch: don't think so
10:46:37 <dmhouse> sw17ch: no, you can't use parentheses.
10:46:40 <dmhouse> ( :) is though.
10:46:50 <sw17ch> dmhouse... yeah, but that's boring :(
10:47:01 <dmhouse> Botje: or chr there
10:47:05 <Botje> unicode smily
10:47:12 <Botje> dmhouse: heh, i keep forgetting about that function
10:47:13 <dmhouse> Botje: and you don't need the parens around the fromEnum call
10:47:13 <Botje> right you are :)
10:47:15 <sw17ch> @let (:]) a b = a + b
10:47:16 <lambdabot>  Parse error
10:47:16 <Deewiant> > let (;-) = (+ 1) in (;-) 2
10:47:17 <lambdabot>  Parse error at ";-)" (column 6)
10:47:23 <sw17ch> heh
10:47:27 <Deewiant> O_o
10:47:35 <Deewiant> semicolon's out?
10:47:41 <Twey> sw17ch: You can use the @.@ operator
10:47:45 <dmhouse> Probably. They are special.
10:47:49 <Deewiant> > let (‚Äì.‚Äì) = (+) in 1 ‚Äì.‚Äì 2
10:47:49 <lambdabot>  Illegal character ''\8211''
10:47:49 <lambdabot>  at ".)" (column 6)
10:47:52 <Deewiant> baah
10:48:00 <Twey> Whut :(
10:48:04 <dmhouse> > let (^-^) = 4 in (^-^)
10:48:05 <sw17ch> > let (@-->-) a b = a + b in 5 @-->- 10
10:48:05 <lambdabot>  4
10:48:05 <lambdabot> Unbalanced parentheses
10:48:12 <Twey> Hehe
10:48:12 <sw17ch> oh hah
10:48:16 <sw17ch> comment
10:48:19 * Twey nods.
10:48:20 <sw17ch> > let (@->-) a b = a + b in 5 @-->- 10
10:48:21 <lambdabot> Terminated
10:48:24 <sw17ch> > let (@->-) a b = a + b in 5 @->- 10
10:48:25 <lambdabot>  15
10:48:28 <sw17ch> :D
10:48:31 <Twey> Yay!
10:48:32 <sw17ch> the rose operator
10:48:49 <Twey> Hmm
10:48:50 <lispy> that would a pretty printer right?
10:48:53 <sw17ch> i'm guessing my wife wouldn't appreciate that instead of the real thing :)
10:48:54 <Twey> Haha
10:48:56 <lispy> "would be"
10:48:57 <sw17ch> lispy, exactly
10:49:01 <Twey> But it's much cooler!
10:49:11 <Twey> Well, more useful :)
10:49:35 <sw17ch> roses, like diamonds, have few uses... but i have to buy them any way
10:50:07 <sw17ch> actually, that's a lie... she doesn't like diamonds, and she's just as happy with daisies from the yard as roses
10:50:11 <sw17ch> :D
10:50:16 <dmhouse> Deewiant: it might also be that you can't start operators with a :
10:50:23 <dmhouse> > let (:P) = 4 in (:P)
10:50:23 <lambdabot>  Parse error in pattern at "in" (column 14)
10:50:31 <Deewiant> dmhouse: yes, but that was ;
10:50:34 <GremlinHunter> let (@-->-) a b = b ++ "<3" ++ a in a @-->- b
10:50:45 <GremlinHunter> > let (@-->-) a b = b ++ "<3" ++ a in a @-->- b
10:50:46 <lambdabot> Unbalanced parentheses
10:50:49 <Deewiant> dmhouse: and that's not valid anyway since you can't have both operator and non-operator chars in one :-)
10:50:55 <sw17ch> GremlinHunter, can't have "--"
10:51:03 <GremlinHunter> :(
10:51:15 <trofi> @->->- ? :]
10:51:15 <lambdabot> Unknown command, try @list
10:51:20 <GremlinHunter>  > let (@->-) a b = b ++ "<3" ++ a in a @->- b
10:51:39 <GremlinHunter> > let (@->-) a b = b ++ "<3" ++ a in a @->- b
10:51:40 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Expr'
10:51:43 <dmhouse> sw17ch: wrong.
10:51:47 <Deewiant> sw17ch, GremlinHunter: that's only a lambdabot limitation
10:51:54 <Deewiant> or bug, rather
10:51:58 <sw17ch> dmhouse, ?
10:51:59 <dmhouse> Prelude> let (-->) = 4 in (-->)
10:51:59 <dmhouse> 4
10:52:05 <sw17ch> oh my...
10:52:14 <sw17ch> so what's wrong with the long stemmed rose operator?
10:52:19 <dmhouse> hscolour gets this wrong :)
10:52:22 <lispy> > let (@_^-_^-_^-_) a b = a + b in 1 @_^-_^-_^-_ 2 -- the wiggle operator?
10:52:22 <lambdabot>  Parse error at "@_^-_..." (column 6)
10:52:23 <Deewiant> which is why comments begin with "-- " and not "--" :-)
10:52:24 <sw17ch> oh, it's on the right side
10:52:25 <GremlinHunter> > let (@->-) a b = b ++ "<3" ++ a in "Romeo" @->- "Juliet"
10:52:27 <lambdabot>  "Juliet<3Romeo"
10:52:32 <GremlinHunter> There you go, the dating operator
10:52:53 * sw17ch thinks #haskell needs to get out more
10:52:53 <dmhouse> Prelude> let (@-->-) a b = b ++ "<3" ++ a in "Juliet" @-->- "Romeo"
10:52:53 <dmhouse> "Romeo<3Juliet"
10:53:05 <lament> aww
10:53:08 * sw17ch then realizes he started this
10:53:32 * Twey laughs.
10:53:39 <Twey> There there, sw17ch :-P
10:53:45 <dmhouse> Twey: did the repeatM thing work? Was hGetChar lazy enough?
10:54:11 <leoncamel> is there anybody knows, how the project "GPLib" going on ? I can't link to its project web page now..
10:54:30 <lispy> > let (-^-^-^--) a b = a + b in 1 -^-^-^-- 2 -- flatline heart rate operator?
10:54:31 <lambdabot> Terminated
10:54:49 <Twey> dmhouse: It doesn't work, no :(
10:54:50 <dmhouse> > let (-^-^-^--) a b = a + b in 1 -^-^-^-- 2
10:54:52 <lambdabot>  3
10:55:00 <dmhouse> You can define operators infix, btw.
10:55:11 <Twey> Compiled eventually, but doesn't output when it should.
10:55:23 <dmhouse> > let a -*- b = a ++ b in "ab" -*- "cd"
10:55:25 <lambdabot>  "abcd"
10:55:32 <Deewiant> and functions too
10:55:34 <Deewiant> > let a `f` b = a + b in f 1 2
10:55:34 <dmhouse> Twey: okay, you might need to define sequenceWhile
10:55:35 <lambdabot>  3
10:55:42 <Valodim> I need a data type with a dynamic number of elements (usually around 300 of them), and relatively many lookups and updates of specific elements, non-associative. Any suggestions?
10:55:54 <dcoutts_> Valodim: Data.Map
10:55:58 <Deewiant> sequence?
10:56:00 <Valodim> had it working with map but the associative part seemed unnecessary
10:56:14 <yitz> Data.Set
10:56:23 <dcoutts_> Valodim: so what are they indexed by?
10:56:23 * Valodim looks up data.set
10:56:29 <Valodim> int
10:56:36 <dcoutts_> Valodim: Data.IntMap
10:56:47 <Deewiant> or IntSet if that's sufficient
10:57:11 <Valodim> wow did Hoogle get an update?
10:57:16 <jganetsk> has anyone heard the argument that continuations are like classical logic
10:57:17 <Deewiant> yep
10:57:21 <Deewiant> to the first
10:57:27 <dons> Valodim: yeah
10:57:33 <Valodim> sweet
10:57:52 <lilac> > map(const       o)$(  :)  :(  :)  :[           ]
10:57:54 <lambdabot>  [o,o]
10:58:01 <Valodim> weren't the types aligned before? seemed more readable that way..
10:58:06 <Deewiant> lilac: :-)
10:58:45 <dcoutts_> Valodim: tell ndmitchell when he's here, he's the hoogle guy
11:00:01 <dmhouse> Twey: http://hpaste.org/9827
11:00:06 <dmhouse> Twey: there may be a better way of doing it
11:00:16 <dmhouse> > o
11:00:18 <lambdabot>  o
11:00:28 <pgavin> dcoutts_: I sent a draft of my application to you at duncan@haskell.org
11:00:28 <yitz> map(const      0.0 )$(  :)  :(  :)  :[          ]
11:00:50 <dcoutts_> pgavin: great
11:00:56 <trofi> > 8:[p]
11:00:57 <lambdabot>  [8,p]
11:01:07 <pgavin> dcoutts_: thanks for helping me with that :)
11:01:15 <dcoutts_> pgavin: no probs
11:01:42 <dmhouse> yitz, lilac: reminds me of http://groups.google.com/group/comp.lang.perl/msg/21cb02abcb1bf3c8
11:01:44 <lambdabot> Title: Forking a bunch of processes... - comp.lang.perl | Google Groups, http://tinyurl.com/6q5lm6
11:01:50 <dmhouse> (About two-thirds of the way through that message.)
11:02:00 <pgavin> dcoutts_: are you still at cambridge?
11:02:11 <sw17ch>  what's the bash forkbomb again?
11:02:14 <dcoutts_> pgavin: Oxford
11:02:21 <sw17ch> i think taht's operaterable
11:02:22 <pgavin> dcoutts_: ah, ok
11:02:30 <Twey> sw17ch: Nah, contains brackets
11:02:36 <dcoutts_> pgavin: though I do seem to be in Cambridge half the time
11:02:44 <Twey> :(){:&:};:
11:02:45 * dcoutts_ grew up in Cambridge
11:02:46 <sw17ch> :(){ :|:& };:
11:02:47 <Twey> Wasn't it?
11:02:56 <sw17ch> http://www.euglug.org/pipermail/euglug/2005-August/004338.html
11:02:56 <pgavin> dcoutts_: cool :)
11:03:00 <Twey> Oh, with a pipe
11:03:01 <dmhouse> dcoutts_: it's of course the far better city. Stick to your roots.
11:03:02 <Valodim> wow, a set is exactly what I need
11:03:09 <lambdabot> Title: [Eug-lug] bash fork bomb?
11:03:14 <dcoutts_> dmhouse: heh heh
11:03:21 <pgavin> dcoutts_: the computer science deparment here may be undergoind an unfavorable reorganization and I'm probably going to be applying elsewhere
11:03:27 * dmhouse is at university in Cambridge
11:03:30 <dmhouse> Well, not right now.
11:03:42 <Twey> dmhouse: That's huge :-P
11:03:48 <haskellian> is there a unique-function or python-ish set()?
11:03:48 <gwern> @seen mmorrow
11:03:48 <lambdabot> I saw mmorrow leaving #ghc and #haskell 4m 19s ago, and .
11:03:49 <dcoutts_> dmhouse: are they not more into ML there?
11:03:50 <sw17ch> are most of you doing graduate work?
11:03:51 <GremlinHunter> I live near Cambridge, know where St. Neots is?
11:03:52 <BMeph> > s/>/^/1
11:03:53 <lambdabot> Terminated
11:03:54 <dmhouse> haskellian: nub
11:04:07 <pgavin> dcoutts_: the US gov't has this scholarship program that pays for students to go abroad, I'm thinking about applying over there
11:04:12 <trofi> List.nub
11:04:20 <dcoutts_> pgavin: cool
11:04:24 <dmhouse> GremlinHunter: I looked it up recently, that's actually where the Darcs hackathon might be
11:04:24 <dmhouse> trofi: *Data.List.nub
11:04:26 <gwern> preflex: seen mmorrow
11:04:27 <preflex>  mmorrow was last seen on #haskell 1 hour, 17 minutes and 49 seconds ago, saying: > foldr (.) id (repeat read) $ fix show
11:04:32 <dmhouse> trofi: or is it 1998 again?
11:04:39 <haskellian> what does nub mean? poor name it seems
11:04:44 <byorgey> haskellian: there is also Data.Set if you actually want efficient sets
11:04:47 <gwern> dang it, just when I‚áß wanted to ask about his mueval patch
11:04:48 <dons> it means "essence"
11:04:48 <dmhouse> The "essence" of something is its nub.
11:04:49 <Valodim> wait, you can't select a specific element of a set?
11:04:51 <gwern> @wn nub
11:05:02 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
11:05:02 <lambdabot> nub
11:05:02 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
11:05:02 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
11:05:02 <lambdabot>      3: the choicest or most essential or most vital part of some
11:05:04 <lambdabot> [5 @more lines]
11:05:07 <trofi> dmhouse: nono. Datal.List is definetly better :]
11:05:11 <dons> i'm surprised by how few people know that. it must be an anglo-ism
11:05:12 <dmhouse> dcoutts_: they teach ML in the first year whereas Oxford teach Haskell, yeah.
11:05:35 <dmhouse> dcoutts_: but then we do have two of the most important people in the Haskell community working here...
11:05:39 <lilac> dcoutts_: you grew up here in Cam too? :)
11:05:41 <dcoutts_> dmhouse: right
11:05:43 <haskellian> can you nub on a data?
11:05:45 <dcoutts_> lilac: aye
11:05:58 <dmhouse> Twey: sorry, backlog, what's huge?
11:06:12 <dcoutts_> dmhouse: yeah, I've been teaching our undergrads Haskell for the last five years :-)
11:06:29 <dmhouse> dcoutts_: heh, nice work.
11:06:42 <dmhouse> I'm not actually a CompSci anyway.
11:07:00 <lilac> dcoutts_: where abouts? i'm from Milton
11:07:19 * cjb has fond memories of Milton beer.
11:07:20 <SamB_XP> dmhouse: of course you are -- you're just an undercover compsci ;-P
11:07:30 <byorgey> haskellian: you can call 'nub' on a list of anything which is an instance of Eq.
11:07:31 <SamB_XP> I'm a semi-uncercover compsci
11:07:39 <dcoutts_> lilac: Newnham
11:07:48 <byorgey> haskellian: including your own data types, if you make them an instance of Eq.
11:07:56 <byorgey> > nub [1,1,2,3,1,3,3,2,4]
11:07:57 <lambdabot>  [1,2,3,4]
11:08:05 <GremlinHunter> Other than the hoogle guy, is there much Haskell at York?
11:08:08 <lilac> * insert compulsory Newnham joke here *
11:08:12 <Twey> dmhouse: sequenceWhile
11:08:13 <byorgey> haskellian: is that what you meant?
11:08:17 <dcoutts_> GremlinHunter: yep, quite a bit I think
11:08:50 <SamB_XP> I mean, I'm majoring in electrical engineering, but I haven't been especially secretive about my CS underpinnings ...
11:09:01 <Twey> Hahaha
11:09:03 <dcoutts_> lilac: I must have missed all the newnham jokes. I presume they are all about the college.
11:09:06 <Twey> 'Undercover compsci'
11:09:20 <dmhouse> dcoutts_: I'm living pretty near Newnham next year. Selwyn gardens, it's off Grange road.
11:09:29 <GremlinHunter> Im starting at York in october :)
11:09:36 <dcoutts_> dmhouse: yep, that's where I lived 'til I was 12
11:10:01 <dcoutts_> dmhouse: small world eh? :-)
11:10:06 <dmhouse> dcoutts_: hehe, nice!
11:10:20 <dmhouse> dcoutts_: my college has a couple of houses on that street.
11:10:31 <dmhouse> 2 and 10, I think.
11:10:37 <dcoutts_> dmhouse: you're at Selwyn?
11:10:42 <dmhouse> Pembroke college.
11:10:45 <dcoutts_> ah
11:11:05 <yitz> Valodim: you can check whether something is an element of the set, and you can delete it from the set.
11:11:23 <byorgey> GremlinHunter: congrats =)
11:11:40 <Valodim> ..but I can't select n'th element from the set
11:11:48 <Valodim> and in Sequence I can't delete it
11:11:57 <dmhouse> The nth element of a set doesn't make sense.
11:12:03 <dmhouse> That's the entire point of it being a set.
11:12:14 <yitz> Valodim: you can do both with both
11:12:35 <Valodim> yitz: yeah but workaround-ish
11:12:49 <yitz> dmhouse: (!! (n-1)) . Set.toList
11:13:12 <trofi> @src tails
11:13:13 <lambdabot> tails []         = [[]]
11:13:13 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
11:13:26 <trofi> > tails [1..]
11:13:28 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:13:28 <dmhouse> yitz: right, so you select the nth element of the list which contains the same elements of the set. I'd say not the same thing, but I guess it's just semantics.
11:13:32 <trofi> > tails [1..3]
11:13:33 <lambdabot>  [[1,2,3],[2,3],[3],[]]
11:13:46 <gwern> @tell mmorrow I'm not applying your hs-sources-ext patch. as near as I can tell, it just doesn't work. ie checkNames only returns Right Nothing or String - none of my examples return the Just "unsafe". I've done some cleanup. It's possible that I broke something
11:13:46 <lambdabot> Consider it noted.
11:13:49 <yitz> Valodim: right, sequence is when most of your work will be at one end or the other. Set is when you don't really care what order they are in. Otherwise, use IntMap.
11:14:06 <gwern> @tell mmorrow but I'll record and push anyway since nothing is using checkNames. I'd like you to debug or whatever against the darcs
11:14:07 <lambdabot> Consider it noted.
11:14:16 <Valodim> IntMap it is
11:14:31 <yitz> dmhouse: yeah, Valodim is right, it's a bit hackish. You wouldn't use Set if that's the main thing you want to do.
11:15:01 <dmhouse> What's the complexity of toList?
11:15:07 <Valodim> with map I have to simulate the "add one to the end" thing by getting the max key, which is what I wanted to avoid
11:15:14 <Valodim> but I can't find a more suitable data type
11:15:24 <dmhouse> Valodim: what do you want to do in summary?
11:15:39 <lilac> dcoutts_: yeah, all about the college. i'd not heard of newnham til i went to uni :)
11:15:46 <yitz> dmhouse: should be linear, no reason why not. It just traverses the tree.
11:16:17 <Valodim> [19:55] Valodim: I need a data type with a dynamic number of elements (usually around 300 of them), and relatively many lookups and updates of specific elements
11:16:37 <dons> Valodim: an IntMap ?
11:16:55 <Valodim> yeah but as I said, I have to hack "add one to the end" there
11:17:06 <dmhouse> Valodim: I think you'll struggle to get quick inserts and updates and lookups ;)
11:17:18 <sw17ch> fingertrees?
11:17:26 <Valodim> probably have to decide which part I want to hack in
11:18:30 <dcoutts_> pgavin: pong
11:18:57 <Valodim> I think I'll use sequence and hack the delete
11:19:30 <dcoutts_> bos: are you using the cabal makefile feature? Can I remove the feature?
11:19:45 <bos> yes, i use it.
11:19:54 <bos> ghc uses it too.
11:20:04 <dcoutts_> bos: can you tell me more? I think you and ghc are the only users, and ghc is going to stop using it
11:20:15 <bos> i use it for parallel builds.
11:20:22 <Cale> Sequence!
11:20:28 <bos> if there's another way to do that, then there's no problem.
11:20:37 <Cale> Valodim: Sequence has fast deletes as well :)
11:20:39 <dcoutts_> bos: ah ok, so that'll be no problem once we do that natively
11:20:45 <bos> right.
11:20:58 <dmhouse> dcoutts_: great couple of blog posts in the last few days, btw.
11:21:04 <dcoutts_> bos: well I'll probably leave it 'til we do it natively
11:21:45 <dcoutts_> dmhouse: ta
11:21:57 <dmhouse> dcoutts_: although I wonder why you don't enable comments
11:22:21 <dcoutts_> dmhouse: spam spam spam, wonderful spam!
11:22:24 <Cale> Actually, it's a good question why Data.Sequence doesn't have a deleteAt function, but you can just do a splitAt combined with a drop and ><
11:22:32 <bos> dcoutts_: i think that's a good idea, thanks.
11:22:40 <dcoutts_> dmhouse: I've used WordPress before ;-)
11:23:15 <dmhouse> dcoutts_: heh, what's wrong with comments?
11:23:30 <dcoutts_> bos: that had been my plan anyway, I just thought I might be able to get away with deleting it sooner since ghc was going to stop
11:23:49 <dcoutts_> bos: how much supporting makefile infrastructure did you need to write to make it work?
11:24:08 <bos> dcoutts_: about one line.
11:24:13 <dcoutts_> dmhouse: the comments always end up full of spam, no matter how good the spam filter
11:24:35 <dcoutts_> bos: wow, ok. I thought it was much more ghc-specific than that
11:24:36 <bos> i get very little comment spam, even though i use wordpress.
11:25:32 <dcoutts_> I turned off comments on the gtk2hs blog once the ratio of comments getting past the spam filter and into moderation to genuine comments got to be >100
11:25:58 <bos> dcoutts_: is it a known bug with cabal-install that if you forget "-p" when first building, you have to unregister everything that got built and redo it all?
11:26:32 <dcoutts_> bos: it's one of a number of different missing features, depending on your point of view
11:26:40 <bos> heh
11:26:43 <haskellian> why doens't this work? http://hpaste.org/9829, not saying this is a good way to implement quicksort, just wondering
11:26:53 <dcoutts_> bos: the simplest one to fix is to allow the --reinstall flag, which we now support
11:27:05 <dmhouse> haskellian: first length (x:xs) == 0 will always be false
11:27:20 <dmhouse> haskellian: you need to add a branch for when the pattern x:xs doesn't match
11:27:25 <dmhouse> I.e. an equation for qs []
11:27:49 <dcoutts_> bos: the hardest is to properly track which flavours/ways the package is installed, ie vanilla, profiling, docs etc and allow building just the missing flavours
11:27:59 <dmhouse> "[filter (\e -> e < x) xs]" -- use round brackets instead of square, otherwise you generate the singleton list whose only element is filter (\e -> e < x) xs
11:28:24 <bos> dcoutts_: ah, --reinstall would be just fine, had i but known of it :-)
11:28:34 <dmhouse> > let xs = [1..10] in [filter (> 5) xs]
11:28:36 <lambdabot>  [[6,7,8,9,10]]
11:28:40 <dcoutts_> bos: it's only in the dev version of cabal-install, but out shortly
11:28:40 <dmhouse> > let xs = [1..10] in filter (> 5) xs
11:28:41 <lambdabot>  [6,7,8,9,10]
11:29:00 <bos> dcoutts_: have you guys got binary installers of cabal-install?
11:29:25 <dcoutts_> bos: ideally you could install all packages without prof, then ask to build the current thing profiling and we'd track that all the dependent packages needed to be built for profiling and then only build them in the profiling way since the vanilla was already installed.
11:29:53 <dcoutts_> bos: no, but I might make a pre-compiled .exe for windows
11:29:57 <bos> dcoutts_: that would be ideal, yes, but --reinstall is easily good enough for now.
11:30:43 <dcoutts_> bos: it's going to be part of the Haskell Platform, so I don't think it's worth spending lots of time making things in the mean time. distros can of course package it if they like.
11:32:32 <dmhouse> dcoutts_: btw, http://hackage.haskell.org/packages/hackage.html still lists cabal-install as "experimental". Now we have a release, should this be updated?
11:32:33 <lambdabot> Title: HackageDB: introduction
11:32:43 <Arnar> @hoogle atomically
11:32:43 <lambdabot> GHC.Conc atomically :: STM a -> IO a
11:32:43 <lambdabot> Control.Exception NestedAtomically :: Exception
11:32:49 <Arnar> ^^ is this the new hoogle?
11:32:57 <Arnar> i.e. does lambdabot use hoogle 4?
11:32:58 <dcoutts_> dmhouse: yes it should
11:33:06 <Arnar> it's not finding atomically
11:33:09 <Arnar> :index atomically
11:33:15 <Arnar> sorry
11:33:18 <Arnar> @index atomically
11:33:18 <lambdabot> GHC.Conc, Control.Concurrent.STM
11:33:31 <dons> dcoutts_: did you see the post about solving sudoku using dpkg dependency resolution?
11:33:34 <dons> http://algebraicthunk.net/~dburrows/blog/entry/package-management-sudoku/
11:33:40 <lambdabot> Title: Package Management Sudoku, http://tinyurl.com/6zm2x6
11:33:44 <dcoutts_> dons: heh heh.
11:34:01 <dcoutts_> dons: it doesn't surprise me, though it's quite a cute idea.
11:34:05 <dons> yep :)
11:34:16 <dons> encode everything in terms of our generic constraint solver: the package system.
11:34:26 <dcoutts_> dons: since you can solve Sudoku with 3SAT and you can encode 3SAT into a package dep problem
11:34:36 <dons> actually , the line at the end is similar to what you wrote yesterday,
11:34:39 <dons> "Luckily, real-world package archives (what the aptitude resolver is designed to run on) don't usually look like this."
11:34:42 <Arnar> lol..
11:34:47 <dcoutts_> dons: I can assure you, cabal-install would fall over with such a problem :-)
11:35:00 <dons> dcoutts_: we need to construct a sudoku tree of .cabal packages!
11:35:10 <dcoutts_> nooooo!
11:35:28 <dcoutts_> dons: it'd be quite funny though, and show actually how regular normal package deps are
11:35:36 <sw17ch> dons: that article made me a little bit sick... and amazed :)
11:36:02 <dmhouse> Reminds me of when someone wrote a prime solver in XSLT.
11:37:05 <Cale> Heh, even though my code is wrong, this error message is ... problematic :)  "Could not deduce (Indexed m a) from the context (Indexed m a)"
11:37:10 <dons> hehe. you really need automation once trying to build your package requires solving a sudoku to find the deps.
11:37:27 <bos> @seen ketil
11:37:27 <lambdabot> ketil is in #haskell. I last heard ketil speak 1h 54m 57s ago.
11:37:31 <bos> glump.
11:37:39 <dons> ?time ketil
11:37:40 <lambdabot> Local time for ketil is Thu Aug 21 20:38:37
11:37:43 <dons> not too bad.
11:37:56 <dmhouse> dcoutts_: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package too, but I'll do that one myself.
11:38:04 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
11:38:14 <dcoutts_> dmhouse: though at the moment we still need the old instructions too
11:38:27 <dmhouse> dcoutts_: yep, I'm preserving them under a subsection
11:38:54 <dcoutts_> dmhouse: in particular people trying to build cabal-install for the first time need those :-)
11:39:28 <dmhouse> dcoutts_: oh, and is the standard advice to prefer distro's packages over hackage ones, even with c-i?
11:39:50 <dcoutts_> dmhouse: yep
11:40:01 <dcoutts_> dmhouse: the distro ones have been QA'ed
11:40:21 <Cale> hmm... actually, that's kind of strange...
11:41:55 <araujo> hello
11:48:04 <Arnar> hello araujo
11:52:48 <dmhouse> dcoutts_: how does http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package look?
11:52:50 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
11:53:29 <dmhouse> I guess runghc should probably be changed to runhaskell
11:55:04 <trofi> @src span
11:55:04 <lambdabot> Source not found. Where did you learn to type?
11:55:10 <trofi> :t span
11:55:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:56:12 <trofi> > (reverse.snd.(span (==':').reverse) "hello world:"
11:56:13 <lambdabot> Unbalanced parentheses
11:56:19 <trofi> > (reverse.snd.(span (==':')).reverse) "hello world:"
11:56:20 <lambdabot>  "hello world"
11:58:08 <dcoutts_> dmhouse: you can drop the .hs extension, runghc (and presumably runhaskell) will just pick the right one, .hs or .lhs
11:58:35 <dmhouse> Nice, didn't know that.
11:58:51 <dcoutts_> dmhouse: I'd drop the --prefix=$HOME, or mention they only need that if they're using Cabal-1.2.3.0
11:59:05 <dcoutts_> dmhouse: in Cabal-1.4+ --user implies --prefix=$HOME/.cabal
11:59:28 <dcoutts_> dmhouse: mind you, most people reading those instructions will be using the Cabal that came with their ghc, which means 1.2.x
12:00:09 <dcoutts_> dmhouse: otherwise it looks cleaner than it was before
12:00:16 <dcoutts_> good work
12:00:39 <dcoutts_> dmhouse: see also the Cabal README
12:00:59 <dcoutts_> dmhouse: for a global install the install step would need sudo on most systems
12:01:23 <b\6> http://hpaste.org/9830  still state monad problems. i get horrible errors trying to initialize IntSeq with stuff like [1,2,3] in main, and i don't know how to actually get anything useful out of it. :/
12:02:01 <bos> @hoogle Int -> [a] -> [a]
12:02:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
12:02:01 <lambdabot> Prelude take :: Int -> [a] -> [a]
12:02:01 <lambdabot> Data.List drop :: Int -> [a] -> [a]
12:02:54 <b\6> it's test junk for learning about state.
12:03:14 <trofi> @. (run map toLower) hoogle a -> a
12:03:14 <lambdabot> Plugin `compose' failed with: Unknown command: "(run"
12:03:31 <mmorrow> > let split p xs = case span p xs of xs@(_,[]) -> xs ; (ys,z:zs) -> (ys,zs) in split (/=',
12:03:31 <lambdabot> Unbalanced parentheses
12:03:31 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:03:40 <mmorrow> > let split p xs = case span p xs of xs@(_,[]) -> xs ; (ys,z:zs) -> (ys,zs) in split (/=',') "asdfdsadfg,gfdsdfg,gfds"
12:03:40 <luqui> @hoogle Monoid a => [a] -> a
12:03:41 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
12:03:41 <lambdabot> Prelude head :: [a] -> a
12:03:41 <lambdabot> Prelude last :: [a] -> a
12:03:41 <lambdabot>  ("asdfdsadfg","gfdsdfg,gfds")
12:04:11 <Twey> b\6: State doesn't work like that
12:04:27 * Twey frowns.
12:04:32 <Twey> Wait, no, I lie, sorry
12:05:05 <luqui> :t runState
12:05:06 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
12:05:08 <Twey> b\6: You never call that, you know
12:05:25 <Twey> The code you've got looks OK
12:05:28 <medfly> hi Twey
12:05:29 <Twey> How are you calling it?
12:05:32 <Twey> Hi medfly
12:05:37 <mmorrow> gwern: oh, i told you i didn't change the list of names from the one you were using, so of course it won't work as is :) ==> it needs to be modified to contain the full name of identifiers you wish to flag
12:05:38 <luqui> > runState $ do { put [1,2,3]; modify tail; return () }
12:05:39 <lambdabot>      Overlapping instances for Show ([a] -> ((), [a]))
12:05:39 <lambdabot>       arising from a u...
12:05:47 <luqui> > runState $ do { put [1,2,3]; modify tail; return () } []
12:05:47 <lambdabot>  Parse error at "[]" (column 55)
12:05:49 <sw17ch> Twey: when i read "state does not work like that", i immediately thought "STATE DOES NOT WORK LIKE THAT!!! GOOD NIGHT TINY EARTHLINGS!!"
12:05:55 <luqui> > runState (do { put [1,2,3]; modify tail; return () }) []
12:05:56 <Twey> Hahahaha
12:05:57 <lambdabot>  ((),[2,3])
12:06:09 <Twey> I misread the code :-P
12:06:20 <b\6> if i try to make any kind of function like 'load is = put is' so i can actually initialize it, i get weird errors.
12:06:25 <Twey> Saw head/tail as fst/snd for some reason
12:06:26 <dmhouse> b\6: you can also do (i, is') <- get
12:06:34 * sw17ch loves Futurama
12:06:35 <b\6> ok, good to know.
12:06:44 <dmhouse> b\6: i.e. the LHS of <- can be an arbitrary pattern
12:06:50 <dmhouse> Erm, I meant (i:is') <- get
12:06:51 <b\6> knew but forgot.
12:06:51 <Twey> b\6: What sort of functions?
12:06:58 <Twey> b\6: Write them out for us?
12:07:02 <luqui> b\6, have you tried running it?
12:07:03 <dmhouse> That will fail if the state is [], of course.
12:07:14 <dmhouse> (It actually uses the fail method of the respective monad.
12:07:29 <luqui> b\6, running next, using runState, I mean.
12:07:33 <b\6> Twey: just, from main, initialize it. put data in it. load it. put like [1,2,3] into the monad so there's actually something to get.
12:07:44 <b\6> no, i don't know how to use runState.
12:07:48 <Twey> b\6: Uhm
12:07:50 <b\6> what would it even be able to get?
12:08:03 <Twey> You kind of have to use runState.
12:08:08 <Twey> It's how you execute it.
12:08:13 <Arnar> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
12:08:13 <lambdabot> No results found
12:09:02 <luqui> b\6, runState takes the thing you want to run, together with an initial state
12:09:03 <dmhouse> All non-IO monadic computations have to eventually be executed using their respective run functions, and then you can do things with the (normally pure) results in main.
12:09:07 <dmhouse> (Or another function main calls.)
12:09:07 <Twey> main = do return runState next [1, 2, 3, 4] -- returns (1, newState), for example
12:09:21 <dmhouse> Twey: no need for 'fo' there. And $ after return
12:09:26 <Twey> Aye, sorry
12:09:29 <dmhouse> *do
12:09:46 <bos> @hoogle numCapabilities
12:09:46 <lambdabot> GHC.Conc numCapabilities :: Int
12:09:52 <luqui> b\6, so eg. runState next [1,2,3,4,5]  -- do this in ghci, see what you get
12:09:55 <Twey> b\6: And if you then runState next newState, you'll get 2
12:10:06 <Twey> Et cetera.
12:10:15 <b\6> hmm, ok. thank you.
12:10:43 <dmhouse> > runState (do x:xs <- get; put (map (+1) xs); return x) [1..4]
12:10:44 <lambdabot>  (1,[3,4,5])
12:11:08 <mm_freak> what's faster?  (foldr union []) or (foldl union [])?
12:11:15 <Twey> mm_freak: foldr
12:11:42 <mm_freak> thanks
12:12:09 <Twey> foldl has to save state on the stack, foldr doesn't, so foldr is always more efficient
12:12:10 <dolio> What's union?
12:12:18 <luqui> > union [1,2,3] [2,3,4]
12:12:19 <lambdabot>  [1,2,3,4]
12:12:19 <Twey> dolio: Two sets, joined
12:12:24 <Twey> Oh, or lists, it seems
12:12:45 <luqui> > union [3,1,4,1,5] [9,2,6,5,3]
12:12:46 <lambdabot>  [3,1,4,1,5,9,2,6]
12:12:51 <dolio> Oh, if it's lists, then foldr is probably it.
12:12:53 <luqui> interesting...
12:13:35 <luqui> mm_freak, rule of thumb:  use foldl for strict functions, foldr for everything else
12:13:49 <Twey> dolio: It joins two lists/sets such that if any element already in the first list is already in the second list, it doesn't get returned in the new list.
12:14:04 <mm_freak> ok, thanks‚Ä¶  i was very unsure in the case of union
12:14:18 <Arnar> @src union
12:14:18 <lambdabot> union = unionBy (==)
12:14:18 <mm_freak> i don't know whether union is strict or not
12:14:24 <Arnar> @src unionBy
12:14:24 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
12:14:46 <dolio> Well, I was just going to say that if it's Data.Set or Data.Map, foldl' is probably what you want.
12:14:58 <mm_freak> isn't (++) strict in its first paramter?
12:15:14 <mm_freak> parameter
12:15:55 <dolio> > take 1 $ (1 : undefined) ++ [5,6,7]
12:15:56 <lambdabot>  [1]
12:16:00 <mm_freak> ah, it's not, it seems
12:16:11 <mm_freak> ok, thank you all
12:16:12 <luqui> sure it is.  undefined ++ x = undefined, no?
12:16:40 <dolio> It's strict, but not strict in the entire structure of the list.
12:16:42 <mm_freak> luqui: that's not because it's strict, i guess
12:17:08 <luqui> mm_freak, which?
12:17:18 <Arnar> > take 1 $ 1 : (undefined ++ [1])
12:17:19 <mm_freak> undefined ++ x = undefined
12:17:19 <lambdabot>  [1]
12:17:26 <dmhouse> There are different levels of strictness.
12:17:27 <mm_freak> x ++ y cannot be calculated without x
12:17:37 <trofi> > tail (undefined ++ [1..])
12:17:38 <lambdabot>  mueval: Prelude.undefined
12:17:47 <mm_freak> but x ++ y can return head x, without needing x
12:17:49 <dmhouse> E.g. length evaluates all the conses, but not the contents of the cells.
12:18:10 <luqui> ah.  but much clarity is attained when you say "strict means f _|_ = _|_", rather than "strict means it kinda uses up its whole argument"
12:18:15 <Arnar> > tail [undefined] ++ [1,2,3]
12:18:17 <lambdabot>  [1,2,3]
12:18:25 <mmorrow> @tell gwern http://code.haskell.org/~morrow/code/haskell/misc/mueval-rascals.diff
12:18:26 <lambdabot> Consider it noted.
12:18:37 <dmhouse> mm_freak: you might find the first three chapters of http://en.wikibooks.org/wiki/Haskell/Laziness enlightening
12:18:38 <lambdabot> Title: Haskell/Laziness - Wikibooks, collection of open-content textbooks
12:18:53 <mm_freak> dmhouse: thanks
12:19:17 * Cale wonders why Control.Comonad.Supply uses the IO monad to construct new values.
12:19:24 <haskellian> i have a data with 3 fields and I have a list of those datas, I want to nub that list if 2 of the parameters are equal, the third one doesnt matter
12:19:37 <haskellian> is there something simple and cute for that or i ahve to do my own?
12:19:40 <mm_freak> i've had a long break from haskell, and i lost a few things =)
12:19:42 <Cale> It's essentially a pure datastructure in the end, and already uses unsafePerformIO internally...
12:19:44 <dmhouse> ?hoogle nubBy
12:19:44 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:19:54 <dolio> Cale: Someone asked that, and edwardk said it's more efficient than a pure implementation or something.
12:20:06 <dmhouse> haskellian: try that.
12:20:08 * dmhouse must dash
12:20:11 <haskellian> ty
12:20:25 <mmorrow> @tell gwern oh, and the reason i took the '^' chars out of the comment is that they were causing my haddock to have a parse error (haddock 2.1.0)
12:20:25 <Cale> dolio: yeah, but since you can't externally tell the difference between it and a pure implementation, you might as well unsafePerformIO those....
12:20:26 <lambdabot> Consider it noted.
12:20:52 <Cale> (especially as it's already using unsafePerformIO anyway :)
12:21:00 <mm_freak> well‚Ä¶  i'm trying to solve problem 1 from projecteuler.net non-algebraically by generalizing it
12:21:02 <dolio> Heh.
12:21:04 <haskellian> :example nubBy
12:21:26 <mm_freak> multiplesUpTo fs n = foldr union [] [ [f, f+f .. n] | f <- fs ]  -- this is what i have now‚Ä¶  it's fast, but could be faster i guess
12:21:59 <luqui> Cale, it has "split"
12:22:04 <luqui> so its semantics are nondeterministic
12:22:24 <Cale> luqui: oh?
12:22:33 <luqui> or rather supplyLeft and supplyRight
12:22:55 <Cale> Are those somehow not deterministic?
12:22:59 <mm_freak> btw, where can i read something about comonads?
12:23:17 <Cale> Oh... I think I see...
12:23:18 <luqui> it builds an infinite tree where all the nodes are distinct repeated applications of the gen function.
12:23:29 <luqui> but distinctness is all you get, there's no rhyme or reason to it
12:23:35 <Cale> luqui: ah, okay
12:23:42 <Cale> I suppose that's sensible then.
12:24:17 <Cale> mm_freak: hmm... there are a few papers, but not a whole lot of really decent introductory material
12:24:27 <Cale> I can point you at some blog posts :)
12:24:50 <Cale> mm_freak: Do you know the basic definition?
12:25:15 <mm_freak> no, but i understand monads quite well now‚Ä¶  though only the haskell monads, not the more general category theory monads
12:25:19 <Cale> okay
12:25:31 <Cale> and you know about join for monads?
12:25:44 <mm_freak> yes
12:25:48 <Cale> (just because I think it's easier to understand how things dualise then)
12:25:50 <Cale> Okay...
12:26:03 <Cale> So a comonad w is a functor with operations:
12:26:09 <Cale> extract :: w a -> a
12:26:22 <Cale> and  duplicate :: w a -> w (w a)
12:26:33 <Cale> Which are like duals to return and join
12:27:03 <Cale> Do you know what a monoid is?
12:27:09 <mm_freak> ok
12:27:21 <luqui> mm_freak, http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
12:27:23 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
12:27:23 <mm_freak> yes, but only from group theory‚Ä¶  haskell monoids seem to be something different
12:27:25 <Cale> My favourite example of a comonad is functions from a fixed monoid.
12:27:26 <luqui> my favorite comonad intro
12:27:32 <Cale> mm_freak: No, they're the same :)
12:27:43 <mm_freak> ok =)
12:27:43 <Cale> So if you fix a monoid m...
12:27:50 <gwern> @seen mmorrow
12:27:50 <lambdabot> mmorrow is in #haskell. I last heard mmorrow speak 7m 25s ago.
12:27:51 <luqui> mempty = e, mappend = *
12:27:58 <Cale> extract :: (m -> a) -> a
12:28:04 <sizur> join #firefox
12:28:09 <Cale> Easy to write, right? :)
12:28:12 <mauke> hi, gwern
12:28:16 <mm_freak> ok
12:28:19 <Cale> extract f = f mempty
12:28:24 <gwern> hiya mauke
12:28:24 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:28:45 <gwern> mmorrow: I've pushed changes to mueval which make rlimits optional
12:28:46 <Cale> duplicate :: (m -> a) -> (m -> m -> a)
12:28:46 <luqui> Cale, nice.  I suppose that's the cowriter comonad?  ;-)
12:28:53 <gwern> mmorrow: I hope that'll fix your problem with them
12:28:53 <mm_freak> seems to make sense, but i think i should read something more verbose =)
12:28:55 <Cale> luqui: sort of :)
12:28:57 <gwern> @messages
12:28:57 <lambdabot> mmorrow said 10m 31s ago: http://code.haskell.org/~morrow/code/haskell/misc/mueval-rascals.diff
12:28:57 <lambdabot> mmorrow said 8m 31s ago: oh, and the reason i took the '^' chars out of the comment is that they were causing my haddock to have a parse error (haddock 2.1.0)
12:29:06 <mm_freak> especially since i'd like to know where comonads are useful
12:29:15 <luqui> mm_freak, see link
12:29:15 <Cale> mm_freak: well... once I give this example, we'll be able to look at a good application :)
12:29:38 <mm_freak> once i've heard that if you view monads as containers, then you can view comonads as 'uncontainers'
12:29:48 <mm_freak> luqui: thank you
12:30:01 <Cale> So what does duplicate do?  duplicate f u v = f (u `mappend` v)
12:30:13 <sizur> #haskell is as lively as ever :)
12:30:26 <Cale> mm_freak: That's not quite true -- they're just another kind of container :)
12:30:27 <gwern> oh, haddocks are broken...
12:30:29 <gwern> I hadn't even checked
12:30:37 <Cale> (Really, it's Functors which look like containers :)
12:30:50 <mm_freak> Cale: yeah, seems to make much more sense
12:30:53 <Cale> With comonads, you have a natural element which you can pick off from the structure
12:30:56 <luqui> sizur, how dare you!  It's more!
12:31:02 <Cale> and a way to split it up in a natural way
12:31:37 <sizur> luqui, exponential growth is "as ever" ;) just very slow one
12:31:45 <luqui> heheh
12:31:46 <Cale> Now, this functions from a monoid monad is handy... let's use the monoid (Integer, Integer) under addition :)
12:31:47 <seanmce> kkjl
12:32:22 <Cale> So then, extract evaluates such a function at the origin
12:32:41 <Cale> and duplicate does something really neat...
12:33:29 <Cale> It produces a bunch of copies of the function, one for each point in the plane, which are translates of the original function to "recentre" it at each point.
12:33:51 <mm_freak> Cale: wait‚Ä¶  i'll really need to experiment with it a bit
12:34:11 <Cale> This will make it really easy to write the evaluation map for a cellular automaton :)
12:34:32 <sizur> seems other channels are dead, so i'll ask here in hopes somebody knows:  did anybody encounter problems with firefox 2.0 xsl transformer?  it doesnt seem to be displaying correctly after the transformation. block elements are flowing horizonally in particular and pre element doesnt keep spacing... :(
12:34:39 <mm_freak> first i'd like to get the basic structure and the idea behind it, and then i'll move on to applications =)
12:34:48 <Cale> (just duplicate, and then fmap a function which looks at the points around the origin and summarizes what it sees somehow)
12:34:51 <Cale> Okay
12:35:21 <mm_freak> but thanks for your intro, it's been very enlightening, now i'll read that blog post
12:36:42 <gwern> mmorrow: I've fixed the haddock issue by judicious use of new types :)
12:40:38 <haskellian> I know there is "nub" for this function but I a exercising Haskell so I decide to implement some preljude-functiosn as an exercise: http://hpaste.org/9831, is there a better way to do this? I often find myself using helper functions a la scheme in Haskell which isnt very idiomatic if I understand it right
12:40:43 <mmorrow> gwern: heh
12:41:03 <gwern> @tell mmorrow oops. I ah broke your patch with my haddock fixes, it seems. but I don't entirely follow - how does the patch fix anything? it looks like it's just matching against a subset of the old set of bad names
12:41:04 <lambdabot> Consider it noted.
12:41:10 <Twey> haskellian: For helper functions, we have 'where'.
12:41:11 <mmorrow> gwern: oh, just scrolled back ... a sec
12:41:11 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
12:41:45 <mauke> haskellian: length (x:xs) == 1 is pointless; just pattern match against [x]
12:41:49 <mmorrow> gwern: i don't follow. how do you mean it is broken?
12:42:10 <jrheard> I'm currently wrapping GDAL and OGR (GIS raster and vector functions) into Haskell, and I've run into something wanting a C FILE*
12:42:20 <haskellian> twey: yes that I know but if want a function that takes 1 argument sbut needs a second to accumulate?
12:42:23 <jrheard> is there a way to create one in Haskell, or should I write some C Code?
12:42:25 <luqui> haskellian, that's also not lazy.
12:42:45 <Twey> haskellian: ... then use 'where'
12:42:46 <luqui> haskellian, i.e. unique [1..] should be [1..], but your function gives _|_.
12:42:49 <mauke> jrheard: you could call fopen using the FFI
12:42:54 <noecksit_> is it possible for cabal to replace a Makefile? i have some files I need to be in a certain place and was wondering whether cabal could do that
12:43:05 <Twey> foo n = bar n acc where bar n acc = ...
12:43:07 <jrheard> mauke, that was what I was planning on doing.  I was just wondering if there was a better way
12:43:09 <mmorrow> so if the list (rascals::[String]) = ["unsafePerformIO","foo"]  , then it will return  Right "foo"    if given      "let = foo in foo unsafePerformIO"
12:43:13 <Twey> Er
12:43:13 <luqui> haskellian, just as an indicator for how you could make it more haskelly.  but yeah, "where' for helper functions typically, as you have heard 39 times by now.
12:43:15 <jrheard> or rather, if someone had already done it
12:43:19 <Twey> Oh, you know what I mean.
12:43:26 <Twey> @src nubBy
12:43:26 <lambdabot> nubBy eq []             =  []
12:43:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:43:29 <mauke> haskellian: nq [x] acc = nq [] (x:acc)
12:43:32 <dcoutts_> noecksit_: not really
12:43:36 <Twey> @src nub
12:43:36 <lambdabot> nub = nubBy (==)
12:43:40 <gwern> mmorrow: well, if I evaluate 'Foreign.unsafePerformIO $ readFile foo', should it return Just "unsafe..."?
12:43:43 <dcoutts_> noecksit_: it depends on exactly what the makefile does
12:43:52 <gwern> mmorrow: but as far as I could tell, it didn't
12:44:21 <mmorrow> gwern: if "Foreign.unsafePerformIO" is in its list, it will return Right "Foreign.unsafePerformIO"
12:44:42 <noecksit_> dcoutts_: well for example, i have .glade file, a couple of png images, and one other config file that I would like to be inside /etc/share
12:44:45 <mmorrow> so its list needs to be filled out
12:45:43 <dcoutts_> noecksit_: you can get cabal to install data files and there's a module it generates for you to find the data files at runtime, irrespective of where the user chooses to install the files
12:45:59 <gwern> mmorrow: but what if 'unsafePerformIO' is what's on the list?
12:46:17 <mmorrow> gwern: actually, that would work unmodified, so "Foreign.unsafePerformIO (print 8)" ==> Just "unsafePerformIO"
12:46:35 <mmorrow> if its list is  [ ... , "unsafePerformIO", ...]
12:46:39 <gwern> hm. perhaps I was doing something wrong
12:47:36 <mmorrow> i put some examples of the three possible return cases in the comment above checkNames in http://code.haskell.org/~morrow/code/haskell/misc/mueval-rascals.diff
12:47:37 <lambdabot> http://tinyurl.com/6esqmm
12:48:56 <mmorrow> ghci> checkNames "Forign.unsafePerformIO (print 42)"
12:48:56 <mmorrow> Right (Just "unsafePerformIO")
12:49:14 * gwern cleans ~/bin of dist/ directories. wow, I had a gig of space being used up by dist/s
12:49:43 <jrheard> I'm interested, by the way, in building OpenSceneGraph bindings into Haskell at some point.  If anyone else would be interested in helping on the project, let me know.
12:51:08 <mmorrow> gwern: it may be preferable to modify checkNames to take an additional arg :: [String] which is a list of identifier names (which need not be qualified) that the caller wishes to flag
12:51:44 <mmorrow> so this arg would replace the hardcoded rascals::[String]
12:51:50 <noecksit_> dcoutts_: do you know where in the user guide it tells you that information?
12:52:18 <mauke> btw, it would be nice if you could use preflex's @tell command next time; it needs testing :-)
12:52:24 <gwern> > 8 + 17 + 8
12:52:26 <lambdabot>  33
12:52:35 <dcoutts_> noecksit_: yep, it's documented in the bit about data-files I think
12:54:26 <pgavin> dcoutts_: I forgot to mention, I got gtk2hs working w/ haddock 2.0 last night
12:54:41 <pgavin> dcoutts_: actually, haddock 2.3 will work whenever it comes out
12:54:54 <dcoutts_> pgavin: oh cool, ndm will be happy, he needs that to be able to use it with hoogle
12:55:01 <haskellian> hwo would I make unique lazy?
12:55:30 <pgavin> dcoutts_: I'll pr4obably push the patch tonight, but I also had to modify haddock a bit
12:55:34 <haskellian> and in general when calling with x paramters and needing an accumulator, is there a way to not use an additional function?
12:55:43 <mauke> unique [] = []; unique (x : xs) = x : unique (filter (/= x) xs)
12:55:53 <dcoutts_> pgavin: oh yes? what kind of haddock mods?
12:56:02 <gwern> mmorrow: maybe, but would the code actually use such paramterization?
12:56:26 <pgavin> dcoutts_: I had to add the code to process image tags
12:56:40 <mmorrow> gwern: only you can answer that :)
12:56:45 <pgavin> dcoutts_: it wasn't much, all said about 20 lines of code in various places
12:56:49 <dcoutts_> pgavin: ahh yes
12:57:12 <dcoutts_> pgavin: right, that was a feature added to haddock 0.x after the 2.x fork
12:57:16 <gwern> well, I wouldn't actually make use of it - it's drawing on only 1 haskell standard libary set afterall
12:57:26 <trofi> hackage's `dimensions' had some problems building haddock yesterday
12:57:31 <gwern> ceteris paribus, everyone would have the same blacklist
12:57:34 <mmorrow> gwern: having the list inside checkNames' where clause is nice because then it's hidden
12:57:53 <pgavin> dcoutts_: I was surprised, I managed to get it working in less than an hour, and I've never looked at the haddock source
12:57:58 <luqui> haskellian, short answer: no.  long answer: typically haskell functions that will end up *returning* an accumulator are not lazy enough, and will perform poorly.
12:58:21 <pgavin> dcoutts_: that says a lot for haskell :)
12:58:21 <luqui> (but auxiliary parameters to keep track of things are okay)
12:58:25 <dcoutts_> pgavin: aye, it's not too bad when I looked at it to add the links to source
12:59:46 <Cale> haskellian: unique?
12:59:56 <mauke> nub
13:00:01 <Cale> ah
13:00:09 <Cale> Well, that can be made reasonably lazy :)
13:06:36 <__bg> Is there a way to 'tie the knot' across the IO monad without using unsafePerformIO?
13:07:04 <Peaker> what's tying the knot? getting it to execute?
13:07:09 <trofi> @hoogle unsageIotoST
13:07:10 <lambdabot> No results found
13:07:13 <trofi> @hoogle unsafeIotoST
13:07:13 <lambdabot> GHC.Conc unsafeIOToSTM :: IO a -> STM a
13:07:13 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
13:07:13 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
13:07:22 <__bg> Peaker: the 'credit card transform' thing
13:07:34 <mauke> :t mfix
13:07:35 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:08:33 <__bg> ooh! thanks all
13:08:59 <mauke> I don't understand mfix so I just use mdo notation
13:09:02 <trofi> @hoogle IO a -> a
13:09:02 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:09:02 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
13:09:02 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:09:22 <__bg> mauke: ooh, even better. thanks again
13:10:09 <__bg> mauke: s/do/mdo/ on my naÔve program and it works! Thanks!
13:10:26 <mauke> whee
13:14:05 <trofi> @instances MonadFix
13:14:05 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:14:48 <luqui> aww, no cont...
13:15:23 <mc__> May someone explain the type error to me. http://pastebin.com/m35c73c35  I spent about an hour looking at it but I dont get it
13:16:16 <haskellian> Cale: any hints on how?
13:16:50 <mauke> mc__: Data.Map.map show board does not return a String
13:17:16 <mc__> mauke:  I thought show converts everything into a String
13:17:24 <mauke> yes
13:17:41 <__bg> @t map show
13:17:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:17:49 <mauke> but that code says 'Data.Map.map show board', not 'show board'
13:17:51 <Cale> haskellian: What are you assuming about the elements of the list? Just that they're comparable for equality?
13:18:47 <Cale> uniq [] = [] -- easy case :)
13:18:59 <Cale> uniq (x:xs) = x : ...
13:19:08 <mauke> welcome to 20 minutes ago
13:19:19 <mc__> mauke: oh nevermind, I did not think about the type signature... I thought the type error had to do with the arguments passed to show
13:24:59 <Peaker> @type uniq
13:25:00 <lambdabot> Not in scope: `uniq'
13:25:07 <Peaker> uniq = nub?
13:27:07 <mc__> is the return in line 3 really needed? Or am I doing something ugly here? http://pastebin.com/m7d871860
13:27:33 <mauke> you're probably doing it wrong
13:27:49 <mauke> do { return ...; somethingElse } == do { somethingElse }
13:28:09 <mc__> without return I get a type error
13:28:25 <mauke> what is this code supposed to do?
13:29:05 <mc__> mauke: call renderBoard
13:29:48 <mauke> doesn't renderBoard just return a string?
13:30:26 <mc__> nope, it does not, it should print to the screent
13:30:28 <mc__> renderBoard board = Data.Map.map (putStrLn . show) board
13:30:38 <mauke> heh
13:30:45 <mauke> no, that doesn't print anything
13:31:11 <mauke> it returns a Map from Positions to IO actions
13:32:33 <Cale> (which, if individually executed, would print things on the screen)
13:33:25 <mc__> could I print directly using map?
13:33:48 * gwern ponders my email to haskell-cafe. 'ANN: Mueval 0.5.1, 0.6, 0.6.1, 0.6.2, 0.6.3'
13:34:00 * gwern needs to do anns more often if I'm going to bump version so often >.<
13:34:43 <mauke> mapM_ print (Data.Map.values board)
13:34:50 <mauke> I hope there is a values function for Maps
13:34:52 <Botje> do them separately and claim your mail server ate them.
13:35:08 <Botje> mauke: i think it's elems
13:35:10 <Botje> yup
13:35:15 <sw17ch> so, i noticed that cabal files can only use certain licenses... or at least has a hard tiem parsing others...
13:35:24 <sw17ch> is there a way i can tell it "i want to use MIT's license?"
13:35:31 <sw17ch> move that question mark over..
13:35:47 <gwern> sw17ch: OtherLicense?
13:35:50 <Cale> lispy: uhh... I would like to see the times for darcs 1 and 2, but the page is blank.
13:36:10 <dcoutts_> sw17ch: we'll add MIT in the next version but sadly, old Cabal versions would not be able to parse it.
13:36:24 <Cale> lispy: well... not blank exactly, it contains lots of javascript and such, but that doesn't seem to produce anything visible.
13:36:41 <gwern> lispy: SEE
13:36:41 <gwern> it's not just me!
13:36:42 <sw17ch> dcoutts_: OtherLicense will work though?
13:36:47 <dcoutts_> sw17ch: yes
13:36:58 <dcoutts_> sw17ch: which is why we've held off. We've updated the parser though, so we'll be able to add it in future without breaking the deployed Cabal versions.
13:37:12 <sw17ch> excellent
13:41:03 <sw17ch> any one want to give my portaudio library a shot? (i just want to know if it builds on machiens other than mine)
13:43:04 <LegendaryPenguin> @src (+)
13:43:04 <lambdabot> Source not found. It can only be attributed to human error.
13:43:09 <LegendaryPenguin> @src +
13:43:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:43:30 <mauke> (+) is a method
13:43:39 <LegendaryPenguin> what does it look like
13:44:00 <mauke> @src Num
13:44:00 <lambdabot> class  (Eq a, Show a) => Num a  where
13:44:00 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:44:00 <lambdabot>     negate, abs, signum     :: a -> a
13:44:00 <lambdabot>     fromInteger             :: Integer -> a
13:47:29 <sw17ch> what's the major difference between BSD and MIT?
13:47:32 <sw17ch> licences that is
13:47:55 <Zao> sw17ch: None, really, unless you're talking about the BSD one with the attribution clause.
13:48:07 <sw17ch> what's the attribution clause?
13:49:02 <Zao> sw17ch: http://en.wikipedia.org/wiki/BSD_license#UC_Berkeley_advertising_clause
13:49:04 <lambdabot> Title: BSD licenses - Wikipedia, the free encyclopedia, http://tinyurl.com/gctkb
13:50:16 <monochrom> BSD = Big Sad Death.  MIT = Morte Immensi Tragedi.  Sounds like equivalent to me. :)   *duck*
13:50:33 <sw17ch> so MIT ~=~ BSD3
13:51:06 <Zao> I pick MIT because I can never remember which BSD is the sane one.
13:51:32 <monochrom> Ah, interesting.
13:52:40 <hackage> Uploaded to hackage: show 0.3.1
13:52:40 <hackage> Uploaded to hackage: mueval 0.6.4
13:58:46 <trofi> > lentgh $ map error $ map (return.return) ['a'..'z']
13:58:47 <lambdabot> Terminated
14:00:01 <trofi> > lentgh $ map error $ mapM (\x -> return [x]) ['a'..'z']
14:00:02 <lambdabot> Terminated
14:00:11 <gwern> lentgh?
14:00:22 <trofi> > length $ map error $ mapM (\x -> return [x]) ['a'..'z']
14:00:23 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
14:03:01 <trofi> > length $ map error $ (mapM (\x -> return [x]) ['a'..'z'] :: [[Char]])
14:03:02 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
14:03:23 <trofi> > length $ map error $ (return `fmap` ['a'..'z'] :: [[Char]])
14:03:24 <lambdabot>  26
14:04:09 <gwern> you know, now that it's too late it occurs to me I should've benchmarked mueval versus lambdabot's hs-plugins
14:04:13 <gwern> ah well
14:06:56 <lispy> Cale: unfortunately I don't know what to tell you.  It has been reported to work in opera, iceape 1.0.9, FF 3.0 on windows and osx
14:07:21 <Cale> I'm on linux.
14:07:56 <lispy> Cale: yeah, but then Igloo reported it working in iceape, and a buddy of mine could view it on opera an ubuntu
14:08:03 <lispy> Cale: I have no idea why it breaks :(
14:08:03 <gwern> as am I
14:08:07 <lispy> makes me very sad
14:08:17 * gwern denigrates windows
14:09:07 <b\6> i have a data Connection that contains a Handle from connectTo and a String from hGetContents on the handle. after i parse stuff coming to me from the remote host, i need to update the string, dropping the part i successfully parsed, leaving the unread part. i'm so baffled about how/if State can help me do that. i just want to do something like parse(&ctx).
14:10:26 <mmorrow> gwern: ok, where would i look in the mueval src to fix this:
14:10:32 <mmorrow> [m@ganon mueval]$ mueval -e '()'
14:10:32 <mmorrow> mueval: NotAllowed "Could not find module `Data.Number.BigFloat':\n  Use -v to see a list of the files searched for."
14:10:48 <gwern> ... wow
14:10:51 <gwern> hm
14:11:19 <mmorrow> possibly it's an error from hint
14:11:26 <gwern> bigfloat... at a guess, I would try removing that module from the default module list in Context.hs
14:11:34 <gwern> possibly you simply don't have it installed
14:11:43 <mmorrow> ah cool, trying now
14:11:45 <trofi> oh. not many packages (yet?) use `hs-plugins' on hackage
14:12:06 <gwern> trofi: hs-plugins's heyday preceded hackage
14:12:59 * mmorrow finds it continues to work nicely for him
14:13:11 <mmorrow> [m@ganon mueval]$ mueval -e '()'
14:13:11 <mmorrow> ()
14:13:18 <mmorrow> finally!!!@
14:13:26 <trofi> why aren't used heavily. looks like easy runtime developing/ammending/testing
14:13:40 <gwern> the removal worked?
14:13:45 <mmorrow> trofi: i dunno
14:13:56 <noecksit_> b\6: i used parsec for what youre trying to do, except i kept something that parsed properly, you can use "noneOf" maybe
14:14:05 <gwern> trofi: it was broken for ages in the transition from 6.6 and 6.8.x, and in my experience, its reliability is less than great
14:14:11 <mmorrow> gwern: yeah, i commented out all Data.Number.* since i've never had any of those
14:14:14 <gwern> although I know dons disagrees with me there
14:14:42 <gwern> that's interesting. I wonder what package Data.Number comes from?
14:15:06 <trofi> @hoogle Data.Number
14:15:06 <lambdabot> Data.Char DecimalNumber :: GeneralCategory
14:15:06 <lambdabot> Data.Char isNumber :: Char -> Bool
14:15:06 <lambdabot> Data.Char LetterNumber :: GeneralCategory
14:15:08 <b\6> noecksit_: parsec's ok. it's just parsing the same server response because i didn't drop the part i parsed.
14:15:26 <trofi> > 1/3 :: CReal
14:15:27 <lambdabot>  0.3333333333333333333333333333333333333333
14:15:33 <mmorrow> reliability wrt what? getting it built? i've never had any issues once it's been built. had to hack it minorly to get it working on 6.9, but i built it the other day with a 6.8.3 and it built flawlessly
14:16:15 <trofi> gwern: current lambdabot does not remove /tmp/ after any evals
14:16:18 * gwern waggles my hoary locks. oh the many errors I have seen relating to hs-plugins...
14:16:43 <gwern> although to be fair, it should be a lot more stable now that it goes through the ghc api, I suppose
14:16:54 <stepcut`> gwern: and gigantic
14:16:59 <mmorrow> yeah :(
14:17:08 <gwern> instead of the crazier techniques of the original hs-plugins
14:17:23 <gwern> man, I didn't even follow the paper when it started talking about hacking the linker, or whatever
14:17:27 <lispy> Cale: so can you try it in opera?
14:17:40 <Cale> I don't have opera.
14:17:41 <noecksit_> b\6: for me, once i parse the string, i go back to listening from the socket, which makes the thread block and that is the only thing i use it for
14:17:49 <gwern> stepcut: a sufficiently smart compiler will fix the binary size problem! also, upx compresses it down to a few megs, which is fine
14:17:55 <lispy> Cale: I think opera is free (as in beer) now
14:18:26 <stepcut> gwern: well, it still takes forever to link, and uses a lot of RAM
14:19:04 * gwern sighs. nothing's perfect. compared to the common lisps, we're doing fairly well
14:19:17 <gwern> I mean, I remember image dumps of stumpwm were like 25 mb
14:19:21 <gwern> no tree shaker there!
14:19:32 <FunctorSalad> is there some existing tool to make a graphviz graph from the class hierarchy of a file?
14:20:04 <b\6> think i saw something close lately. dependency graph stuff with dot output.
14:20:08 <b\6> i'll see if i can find it.
14:20:34 <stepcut> gwern: compared to forth though...
14:20:42 <lispy> stepcut: FWIW, david marked that bug we reported as a darcs1 bug that he said was known and fixed in darcs2.  So it's not really a regression so much as darcs1 should have been complaining too.
14:20:50 <haskellian> help with IO-typing  please, http://hpaste.org/9833
14:21:00 <gwern> if we want forth, we know where to get it!
14:21:10 <monochrom> If you put Hugs in firmware you can attain executable size = source code size.
14:21:18 <stepcut> lispy: ok. thanks!
14:21:44 <Cale> haskellian: recommend 1 1 7 is an IO action
14:21:52 <Cale> haskellian: print doesn't know how to print IO actions
14:22:11 <Cale> haskellian: You probably want to print the result of running recommend, which would look like:
14:22:16 <Cale> do x <- recommend 1 1 7
14:22:18 <Cale>    print x
14:22:35 <Cale> Or  recommend 1 1 7 >>= print
14:22:53 <trofi> :t a =<< m
14:22:54 <lambdabot>     Couldn't match expected type `a -> m b'
14:22:55 <lambdabot>            against inferred type `Expr'
14:22:55 <lambdabot>     In the first argument of `(=<<)', namely `a'
14:23:04 <trofi> :t (a =<< m)
14:23:05 <lambdabot>     Couldn't match expected type `a -> m b'
14:23:05 <lambdabot>            against inferred type `Expr'
14:23:05 <lambdabot>     In the first argument of `(=<<)', namely `a'
14:23:18 <trofi> :t (act =<< mon)
14:23:19 <lambdabot> Not in scope: `act'
14:23:19 <lambdabot> Not in scope: `mon'
14:23:23 <Cale> :t (=<<)
14:23:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:23:42 <dolio> :t ?foo =<< ?bar
14:23:43 <lambdabot> forall a (m :: * -> *) b. (Monad m, ?bar::m a, ?foo::a -> m b) => m b
14:23:55 <haskellian> thanks, ofc silly me
14:24:17 <Cale> lispy: curious... it does work in Opera
14:24:17 <trofi> @redo a =<< m
14:24:18 <lambdabot> a =<< m
14:24:24 <trofi> @undo a =<< m
14:24:24 <lambdabot> a =<< m
14:24:38 <trofi> @redo  m >>= a
14:24:38 <lambdabot> do { b <- m; a b}
14:26:10 <itachi> hello
14:26:51 <itachi> can some1 talk to me
14:26:53 <itachi> plz
14:27:31 <r3m0t> hi
14:27:46 <gwern> not unless you answer me these questions three!
14:29:19 <dons> how many sides does a triangle have?
14:29:28 <mc__> what is the average velocity of a swallow?
14:29:29 <dons> what is a triangle good for?
14:30:17 <mauke> dons: two, upper side and underside
14:31:25 <gwern> 'Heh. Research by insult.
14:31:26 <gwern> "So it's impossible to construct a sentient artificial intelligence in Haskell? I see why people use Java!"'
14:31:32 <gwern> http://www.reddit.com/r/programming/comments/6xe6r/windows_search_gets_worse/c054jbt
14:31:35 <lambdabot> Title: Mr_Smartypants comments on Windows Search gets worse!, http://tinyurl.com/6nmhf3
14:31:45 <Twey> Hahaha, gwern, wha'
14:31:46 <monochrom> I see why people use reddit.
14:31:57 * Twey nods.
14:32:19 <Twey> Haha
14:32:28 * monochrom still proudly holds no reddit account.
14:32:33 <gwern> I am tempted to code up solomonoff induction in haskell and paste it
14:33:09 <gwern> 'This implements the optimal universal intelligence for all computable priors, per Schmidhuber (199x). Unfortunately, it is uncomputable.'
14:33:18 <b\6> FunctorSalad: sorry, can't find it. it was a mailing list post by haskell people concerned with dependency management. their code had graphviz dot output stuff.
14:34:10 <gwern> 'However, Haskell allows us to verify that the types compile! and laziness means that we could get some results back - if the constants weren't larger than the lifetime of the universa...'
14:34:15 <FunctorSalad> b\6: thanks anyway :)
14:34:41 <itachi> oh hello
14:34:55 <itachi> can u people help me with my wifi problem
14:35:05 <monochrom> "I told you so."
14:35:14 <gwern> unlikely
14:35:42 <monochrom> Just from the spellings you can tell what kind of troll it is.
14:36:55 <gwern> so i herd u liek mudlambdas
14:36:59 <jeffz> hi b\6
14:37:49 <b\6> hey jeffz.
14:38:21 <Twey> Haha, gwern
14:38:39 <jeffz> b\6: decided to do things the hard way?
14:39:08 <b\6> dunno. trying to learn, not just do what i already know.
14:39:22 <jeffz> fair enough
14:40:12 <FunctorSalad> hmm... sometimes you use the heavy guns for a simple problem just to practice their use, but people think you do it out of pretentiousness
14:41:10 * Twey is all in favour of any motive that causes people to attempt to act intelligently
14:41:13 <b\6> no chance of me being pretentious. learning haskell's like travelling back in time to 15 years ago when i could barely program.
14:41:29 <Twey> Heh, b\6, know that feeling
14:41:35 <b\6> i'm currently getting my ass kicked by the super advanced genius idea of updating a member in a struct.
14:41:46 <FunctorSalad> :)
14:42:13 <mc__> b\6:  I feel with you brother, I program for about 4 years now, but I cant get a simple tic tac toe to work correctly in haskell
14:42:34 <b\6> but when you get it going!!! omg, will it be reliable.
14:42:35 <monochrom> I don't assume pretentiousness. I assume ignorance or perversion. :)
14:42:37 <itachi> hey
14:42:48 <itachi>  is there a way to downlad unbuntu for free?
14:42:56 <b\6> itachi: did you try ghc --make?
14:43:05 <mc__> itachi: ehm ,yes
14:43:09 <ddarius> Is there a way to download Ubuntu not for free?
14:43:11 <jeffz> itachi: you're in the wrong channel join #ubuntu
14:43:16 <itachi> where
14:43:22 <mc__> itachi: ubuntu.com
14:43:47 <stepcut> ddarius: http://www.ubuntu.com/getubuntu/purchase
14:43:52 <lambdabot> Title: Purchase Ubuntu on CD or DVD | Ubuntu
14:43:57 <ddarius> stepcut: That's not downloading.
14:44:09 <stepcut> ddarius: true
14:44:16 <gwern> but they will send you free cds
14:44:20 <gwern> that much is true
14:44:24 <gwern> darn useful service
14:44:40 <mc__> yeah, bot nowadays it takes ages till you get the cd's
14:44:44 * gwern started using linux solely because of the free cds - I was too cheap to actually get around to buying one
14:45:00 <gwern> oh, a few weeks isn't too bad
14:45:22 <mc__> in the past it took less time, and it was easier to get more cd's
14:45:33 <jeffz> mc__: have you read the "Where do I begin" paper?  It talks about the difficulty experienced programmers have when starting with Haskell and some common approaches to making it easier
14:45:47 <mopped> Is there a channel for general computer science/programming questions?
14:45:58 <mc__> mopped: #programming
14:45:59 <wagle> where do i find definitions of <$>, <*>, and group?
14:46:07 <Twey> @src group
14:46:07 <lambdabot> group = groupBy (==)
14:46:11 <Twey> @src <$>
14:46:11 <lambdabot> f <$> a = fmap f a
14:46:14 <Twey> @src <*>
14:46:15 <lambdabot> Source not found. Take a stress pill and think things over.
14:46:17 <mc__> jeffz: nope i havent read that paper, im reading realworldhassek
14:46:17 <Twey> :<
14:46:25 <Twey> In the Report, perhaps, or the GHC docs
14:46:32 <stepcut> <*> is defined on a per-type basis
14:46:40 <ddarius> @src (<$>)
14:46:40 <lambdabot> f <$> a = fmap f a
14:46:41 <jeffz> mc__: http://haskell.org/sitewiki/images/9/97/ProbSolvInHas1.pdf
14:46:42 <ddarius> @src group
14:46:42 <lambdabot> group = groupBy (==)
14:46:48 <mc__> jeffz: thank you
14:46:51 <dolio> Applicative isn't in the report.
14:46:52 <ddarius> @src Applicative
14:46:52 <lambdabot> class Functor f => Applicative f where
14:46:52 <lambdabot>     pure  :: a -> f a
14:46:52 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:46:53 <wagle> i had the feeling the definitions were special/non-standard
14:46:53 <lambdabot> Title: cache:http://haskell.org/sitewiki/images/9/97/ProbSolvInHas1.pdf - Google Search
14:47:16 <ddarius> wagle: There is nothing either special or non-standard about any of them.
14:47:35 <wagle> ddarius, oki..  thanks
14:48:06 <Twey> What *is* a functor?
14:48:17 <ddarius> Twey: A category homomorphism.
14:48:23 <lament> a thing that takes things to other things.
14:48:23 <wagle> ddarius, well, actually those three don't work in a fresh ghci
14:48:26 <Twey> Oh, that clears it up wonderfully.
14:48:41 <ddarius> Twey: Doesn't it just.
14:48:45 <ddarius> @index gorup
14:48:46 <lambdabot> bzzt
14:48:49 <lament> no, it's really more like a thing that turns things with things into other things with things.
14:48:51 <ddarius> @index group
14:48:51 <lambdabot> Data.List
14:49:14 <mauke> Twey: a functor is something you can map through
14:49:26 <Twey> Oh, right.
14:49:34 <Twey> And 'pure' would be 'return' in monad terms?
14:49:48 <opqdonut> yes
14:49:50 <dolio> It's a pretty clear definition if you know what categories and homomorphisms are.
14:50:14 <Twey> Clearly, I am severely undereducatied :-P
14:50:32 <wagle> @index <$>
14:50:33 <lambdabot> bzzt
14:50:39 <dolio> Know yr algebra!
14:50:42 <mauke> @index (<$>)
14:50:42 <lambdabot> bzzt
14:50:46 <mauke> :-/
14:51:08 <Twey> And how about an applicative?
14:51:14 <Twey> Something that can be applied?
14:51:16 <dolio> What does @index do? I don't think I've ever seen it do anythign but "bzzt".
14:51:22 <Twey> dolio: Fail
14:51:23 <mauke> @index sort
14:51:23 <lambdabot> Data.List
14:51:24 <opqdonut> ?src Applicative
14:51:24 <lambdabot> class Functor f => Applicative f where
14:51:24 <lambdabot>     pure  :: a -> f a
14:51:24 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:51:33 <ruddel> Twey, are you learning Haskell from a book? :)
14:51:34 <wagle> i unpacked this old thing to show my java friends:
14:51:37 <FunctorSalad> Twey: they have a point, to learn what a functor is you really should look at categories first
14:51:38 <wagle> iterate (concatMap ((:) <$> length <*> return.head) . Data.List.group) [1]
14:51:39 <Twey> No, ruddel :-(
14:51:41 <opqdonut> Twey: it's a functor with application
14:51:56 <wagle> wanted them to be about to run it
14:52:02 <wagle> > iterate (concatMap ((:) <$> length <*> return.head) . Data.List.group) [1]
14:52:03 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
14:52:06 <Twey> Ah, OK, opqdonut
14:52:14 <opqdonut> Twey: like the "(<*>) :: f (a -> b) -> f a -> f b" sig says
14:52:23 * Twey nods.
14:52:30 <wagle> :t <*>
14:52:31 <lambdabot> parse error on input `<*>'
14:52:34 <ruddel> Twey, http://book.realworldhaskell.org/beta/ hurry read it all before the release date :P
14:52:40 <lambdabot> Title: Real World Haskell
14:52:40 <wagle> :t (<*>)
14:52:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:52:46 <ziman> ?src Functor
14:52:47 <lambdabot> class  Functor f  where
14:52:47 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:52:47 <Twey> Ooh, yes
14:52:50 <Twey> That book is awesome
14:52:54 <opqdonut> Twey: and then monad gives you "composition" on top of that
14:53:04 <ruddel> yes, i'm just reading it now, i'm also a haskell newbie
14:53:04 <Twey> I learned monads from it
14:53:07 <opqdonut> Twey: i.e. feeding results of computations to something
14:53:11 <opqdonut> :t (>>=)
14:53:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:53:14 <ziman> Functor doesn't have return/pure?
14:53:18 <opqdonut> Twey: contrast that with <*>
14:53:32 <Saizan_> ziman: only fmap
14:53:46 <opqdonut> ziman: well fmap.const is almost it
14:55:21 <Twey> fmap.const?
14:55:33 * Twey frowns.
14:55:38 <Twey> Oh, yes, I see it.
14:55:44 <ziman> and why does Applicative need pure when Functor doesn't have anything similar?
14:59:34 <MyCatVerbs> @type pure
14:59:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:59:54 <Cale> Having something like pure is not guaranteed by Functor
15:00:21 <Cale> There are functors for which you can't write pure/return
15:00:23 <MyCatVerbs> ziman: there are lots of types that one can write fmap but not pure for.
15:00:43 <dolio> Technically you could split it out into another class between Functor and Applicative.
15:00:47 <dolio> For pointed functors.
15:01:25 <MyCatVerbs> For instance, instance Functor (Pair a) where fmap f (Pair a b) = Pair a (f b)
15:01:45 <MyCatVerbs> Someone yell at me if that isn't correct, please?
15:01:50 <Cale> That's fine
15:01:54 <MyCatVerbs> Thanks.
15:01:56 <Cale> You could also write it as:
15:02:10 <Cale> instance Functor ((,) a) where fmap f (x,y) = (x,f y)
15:02:21 <MyCatVerbs> Cale: ah yes. ^^
15:02:24 <dolio> You can write it if a is a monoid.
15:02:31 <mauke> > fmap (* 2) ("A", 21)
15:02:32 <lambdabot>  ("A",42)
15:02:33 <dolio> pure, that is.
15:02:40 <dolio> Since that's the writer monad.
15:03:06 <MyCatVerbs> dolio: or Bounded, or *any* instance that allows you to create a value of that type. :/
15:03:16 <dolio> Yeah.
15:03:29 <MyCatVerbs> Monoid's one of the commoner instances, I guess?
15:03:38 <ziman> > (undefined, (*2)) <*> (3, 4)
15:03:39 <lambdabot>  Add a type signature
15:03:52 <dolio> Well, monoid gives you an operation for combining values, too.
15:05:21 <MyCatVerbs> Just that most interesting data structures can have *some* closed binary operation with a zero element defined on them.
15:05:25 <paczesiowa> anyone got ini-style config files parser handy?
15:05:45 <ziman> mhm, i see, thanks
15:06:11 <ddarius> paczesiowa: I'm sure someone has written one, but it may not be anywhere handy.  Maybe check MissingH?
15:06:13 <sjanssen> paczesiowa: I think missingh has one?
15:08:19 <ddarius> ruddel: The online version of RWH is still going to be there once the book is published.
15:08:40 <yitz> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile
15:08:42 <lambdabot> Title: HackageDB: ConfigFile-1.0.4, http://tinyurl.com/64s2s6
15:09:03 <yitz> paczesiowa: ^
15:09:42 <paczesiowa> yitz: thanks, you're faster than loading hackage pkg list
15:11:26 <paczesiowa> there are libraries for everything on hackage:/ nothing to complain about any more:/
15:12:21 <Philonous> Is it reasonable to to describe newtype as "stripping" a type from it's structure?
15:12:37 <dmhouse> Philonous: in what sense? I don't think so.
15:13:06 <roconnor> newtype makes an isomorphic type without the overhead of an isomorphism
15:13:29 <Philonous> roconnor: I thought that's waht type did?
15:13:33 <Philonous> what*
15:13:43 <roconnor> type makes a type synonym
15:13:54 <roconnor> the resulting type is literally the same as the old type
15:13:57 <Philonous> dmhouse: newtype throws away any instance delcarations and hides the constructors
15:13:58 <dmhouse> Philonous: newtype T = MkT U declares an exact copy of the type U, called T. The isomorphism from U to T is MkT, and this is an isomorphism since MkT's value cannot be bottom
15:14:23 <dmhouse> roconnor: I'd say you do get the overhead of the isomorphism, namely all the packaging and unpackaging of the constructor.
15:14:30 <dmhouse> It's explicit in the code.
15:14:38 <dmhouse> Unlike with type.
15:14:43 <roconnor> without the (run-time) overhead of the isomorphism
15:14:55 <roconnor> you still have the source code overhead I guess
15:15:13 <dmhouse> Sorry, it doesn't create an exact copy, it creates an isomorphic copy.
15:15:28 <dmhouse> Because it's a different type, you can have different instance declarations etc.
15:15:33 <ddarius> > let iso, unIso :: Int -> Int; iso = id; unIso = id in iso 3
15:15:34 <lambdabot>  3
15:16:01 <dmhouse> Philonous: it doesn't really hide the constructors, e.g. newtype J = MkJ Bool still has the True and False constructors, but they're now necessarily wrapped with a MkJ.
15:16:52 <roconnor> I'd hesitate to call True and False constructors for J
15:16:54 <Philonous> Ok, so it only forgets about the instance declerations?
15:17:25 <dmhouse> roconnor: I suppose so. However they're certainly not hidden. Just wrapped.
15:17:51 <dmhouse> Philonous: if you like, newtype is cp, type is ln.
15:18:09 <dmhouse> Because type A = B, A and B are the same literal type, everything about them must be the same.
15:18:11 <ddarius> Why don't we stop talking about constructors and start talking about values?
15:18:24 <Philonous> dmhouse That doesn't really help me :/
15:18:42 <dmhouse> With newtype A = MkA B, all the values of B are wrapped in this MkA constructor, so they're manifestly different.
15:18:48 <ddarius> Philonous: type A = B means A gets (textually) rewritten to B.
15:19:11 <Philonous> Ok
15:19:25 <jeffwheeler> @pl \s -> n `rem` s == 0
15:19:25 <lambdabot> (0 ==) . (n `rem`)
15:19:28 <dmhouse> However they're also manifestly isomorphic since you can transform values of B into values of A with MkA, and values of A back into values of B with unA (MkA b) = b
15:19:29 <Philonous> So newtype makes distuingishable types without any overhead
15:19:50 <roconnor> ya
15:20:18 <roconnor> in Modula-3 speak we would say newtype make "branded" types :)
15:20:19 <jeffwheeler> @pl prime n = (2==) $ length $ filter ((0==).(n `rem`)) [1..n]
15:20:19 <lambdabot> prime = (2 ==) . length . ap (filter . ((0 ==) .) . rem) (enumFromTo 1)
15:20:20 <dmhouse> Notice that unA is actually an isomorphism because MkA _|_ = _|_. If they were different, we would have that unA _|_ = unA (MkA _|_).
15:20:28 <dmhouse> (I.e. unA would fail to be injective.)
15:20:35 <Philonous> And this newtype isn't the instance of any class, so I can basicly reimplement the logic of the type?
15:20:37 <jeffwheeler> I'm sure there's a better way to write that, but I like that.
15:20:53 <dmhouse> And conversely MkA would fail to be surjective, since MkA x /= _|_, for all x.
15:20:56 <roconnor> Philonous: that is correct
15:23:13 <Philonous> Nice. Thanks. I can finally make something of it.
15:24:24 <lilac> Philonous: there's a ghc extension NewtypeDeriving which lets you derive any classes for the new type which the old type was an instance of
15:24:25 <yitz> jeffwheeler: null . drop 2 instead of (2==) . length
15:24:44 <jeffwheeler> yitz: clever
15:25:01 <lilac> yitz: 1 isn't prime :/
15:25:13 <jeffwheeler> It wasn't?
15:25:23 <ddarius> > nubBy (((>1).).gcd) [2..]
15:25:24 * jeffwheeler goes back to check the original.
15:25:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:25:30 <yitz> jeffwheeler: 2:[3,5..n] instead of [1..n]. or if you have an isqrt function, 2:[3,5..isqrt n]
15:25:50 <SamB_XP> lilac: there's apparantly a certain amount of disagreement about that
15:26:06 <paczesiowa> yitz: that ConfigFile kicks ass! monadified in generic MonadError and plenty of documentation - what more do you need?
15:26:18 <yitz> jeffwheeler: if your n will remain fairly small, you could use isqrt = floor . sqrt . fromIntegral
15:26:21 <lilac> bah, when i was brought up, 1 was a unit not a prime (and Pluto was a planet, and sulfur had a p and an h in it)
15:26:22 <SamB_XP> lilac: I wouldn't suggest being overly dogmatic on that point
15:26:26 <ddarius> SamB_XP: What?  Between the people who are wrong and the people who are right?
15:26:49 <Philonous> lilac: Thanks for the hint. I thought I could just derive from the base type without the extension (But I never actually tried it)
15:27:08 <SamB_XP> ddarius: I don't think so -- I think it's more a matter of definitions than anything
15:27:09 <yitz> paczesiowa: glad to hear it! maybe I'll use it sometime (I haven't yet)
15:27:36 <lilac> SamB_XP: in terms of unique factorization, it's pretty important that 1 isn't prime...
15:27:47 <SamB_XP> lilac: doesn't sulpher have a P and an H?
15:28:14 <ddarius> It definitely doesn't have an 'e' in it.
15:28:18 <yitz> lilac: and you tilled the earth with a plough, not a plow.
15:28:55 <lilac> yitz: i still do that ;-)
15:29:18 <lilac> SamB_XP: not according to IUPAC
15:32:57 <ruddel> when i think of recursion in Haskell, is it necessary to think of FIFO?
15:33:05 <Twey> ruddel: Uhm
15:33:16 <Twey> Nnno
15:33:21 <dmhouse> ruddel: it works the same as recursion in any other language. That is, LIFO.
15:33:22 <ruddel> ehhee
15:33:22 <ruddel> hehe
15:33:23 <Twey> If anything, I would say LIFO
15:33:31 <ruddel> d'oh
15:33:36 <ruddel> yeah, thats what i meant ,sorry
15:33:38 <Twey> But that's a fairly odd way of thinking about it, IMO
15:33:47 <sw17ch> any one have a second to test a darcs checkout/build for me before i submit this to hackage?
15:33:49 <dmhouse> It works in the most natural way...
15:35:04 <b\6> sw17ch: i'll try. gimme darcs url?
15:35:11 <ruddel> Twey, so when you think of recursion in Haskell, you don't think about LIFO?
15:35:13 <sw17ch> http://code.haskell.org/portaudio
15:35:14 <lambdabot> Title: Index of /portaudio
15:35:19 <b\6> trying.
15:35:20 <sw17ch> b\6: what distro are you running?
15:35:25 <jeffwheeler> @pl \s -> (s `gcd` n) == s
15:35:25 <lambdabot> (==) =<< (`gcd` n)
15:35:29 <sw17ch> you'll need the portaudio bindings... version 19
15:35:29 <jeffwheeler> Yuck.
15:36:07 <Twey> ruddel: No, I think about recursion
15:36:08 <Twey> Heh
15:36:34 <Twey> I think about each function call as the value it returns.
15:39:30 <b\6> sw17ch: ubuntu gutsy.
15:40:42 <sw17ch> b\6: i'm guessing that you'll need libportaudio-dev
15:40:54 <sw17ch> but...dangit...
15:40:57 <sw17ch> that's version 18
15:41:16 <sw17ch> portaudio19-dev?
15:41:33 <sw17ch> b\6: http://packages.ubuntu.com/gutsy/portaudio19-dev
15:41:34 <lambdabot> Title: Ubuntu -- Details of package portaudio19-dev in gutsy
15:42:23 <b\6> getting, sec. i'm on weird wireless and hummingbirds are swarming my antenna.
15:42:33 <sw17ch> hahah
15:43:51 <sw17ch> b\6: let me know how it goes, i have to step out for a second
15:43:54 <b\6> ok.
15:45:14 <dons> j/win 37
15:46:07 <b\6> caught you.
15:48:26 <Twey> Haha, b\6
15:48:36 <Twey> Hummingbirds disrupting your Internet!
15:49:18 <ivanm> dons: did you know that even Big W has RWH available for pre-order down here? :o
15:49:50 <dons> ivanm: whoa.
15:49:53 <dons> invam, url?
15:50:03 <dons> ivanm: do you know if its at dymocks or angus&robertson?
15:50:07 <ivanm> http://www.bigwentertainment.com.au/product/real_world_haskell_2032977_3936.html
15:50:10 <lambdabot> Title: REAL WORLD HASKELL (UNKNOWN): Books: BIGWentertainment.com.au, http://tinyurl.com/5lax3f
15:50:29 <ivanm> I just googled for it, restricting to australia
15:50:33 <dons> thta's awesome.
15:50:44 <dons> ivanm: yeah, i want to ensure we can preorder from australian retailers.
15:50:47 <ivanm> my guess is that whoever is in charge of their books supplies it
15:50:57 <jeffz> pricey $90.48
15:51:01 <ivanm> since a couple of online DVD stores have it at the same price
15:51:03 <ivanm> jeffz: yeah :s
15:51:18 <dons> not at dymocks yet.
15:51:20 <ivanm> surely the authors can organize for us to get some at a discounted price? ;-)
15:51:21 <jeffz> amazon is almost always cheaper for books in australia
15:51:42 <dons> i'd like to see it at the unsw bookstore
15:51:48 <dons> and the coop bookstore.
15:51:51 <Nafai> jeffz: Even with shipping?  Wow.
15:51:53 <dibblego> I'd like to see it on my desk
15:52:02 * shapr hugs Saizan_
15:52:03 <jeffz> Nafai: sure, it's usually $12
15:52:08 <shapr> even without the underscore!
15:52:09 <ivanm> the UQ bookstore would probably make it $100.48 or something :p
15:53:16 <dibblego> friggin scamming UQ
15:53:19 <stepcut> ?pl prs >>= \p -> newRule (p <<- eof)
15:53:20 <lambdabot> newRule . (<<- eof) =<< prs
15:53:24 * stepcut stops around
15:53:36 <b\6> sw17ch: built fine.
15:53:50 <thetallgu1> dons: nice work from UNSW: http://tinyurl.com/67m7rh
15:53:57 <lambdabot> Title: The Sydney Morning Herald: national, world, business, entertainment, sport and t ...
15:54:59 <roconnor> I talked with David Lester this week.  Apparently CReal has a few bugs in it.  Now that he has completed his PVS verification, I told him to give the new version to Lennart.
15:55:11 <dons> oh, the photovoltaics school.
15:56:02 <Twey> What does the C- prefix indicate?  Complex?
15:56:23 <stepcut> control
15:56:43 <thetallgu1> dons: yeah, but eerily similar in flavor, tossing aside big complex systems, and building new, simpler ones from good fundamentals
15:56:47 <stepcut> emacs uses the notation, C-x C-s instead of ^x ^s
15:56:53 <lispy> I have a grammar questions...if I have a parser where I read a number and it tells me how many more numbers to read, does that technically mean my grammer is context sensitive?
15:57:13 <thetallgu1> and I have this bridge for sale...
15:57:44 <EvilTerran> lispy, ornate magic aside, i think so
15:57:49 <MyCatVerbs> lispy: yes.
15:57:55 <EvilTerran> and i don't think you could do it with magic either
15:58:29 <dons> roconnor: huh
15:58:36 <MyCatVerbs> lispy: but if the number was strictly bounded (say, fixed number of digits specifying the number of digits to read) then you could kludge it with a massive table. :)
15:58:51 <roconnor> dons: CReals
15:59:02 <roconnor> > pi :: CReals
15:59:03 <lambdabot>      Not in scope: type constructor or class `CReals'
15:59:06 <roconnor> > pi :: CReal
15:59:07 <lambdabot>  3.1415926535897932384626433832795028841972
15:59:12 <roconnor> ^^
15:59:16 <roconnor> it has bugs in it
15:59:27 <roconnor> may possibly produce errounous results
15:59:34 <roconnor> use at your own risk
15:59:42 <roconnor> new version forthcoming
15:59:42 <b\6> filling may be hot
15:59:50 <b\6> keep out of reach of children
16:00:00 <b\6> may cause drowsiness
16:00:03 <sw17ch> b\6: how'd it go
16:00:10 <Valodim> duh. "may".
16:00:14 * Valodim spills
16:00:19 <lispy> MyCatVerbs: okay, I was wondering because I was trying to EBNF the grammar I'm staring at and I coludn't figure out how to express that rule.  But since I'm writing it as a recursive decent parser, I'll just make up my own notation for this problem
16:00:23 <b\6> sw17ch: built fine. i didn't cabal install.
16:00:32 <thetallgu1> what sort of beetle is that on the cover of RWH?
16:00:36 <sw17ch> b\6: that's all i wanted, thanks :)
16:00:43 <b\6> thetallgu1: hercules beetle or something.
16:00:46 <sw17ch> Rhinoceros
16:00:48 <sw17ch> i believe
16:01:24 <MyCatVerbs> lispy: it sounds like one of those cases where, even though you possibly *could* shoehorn it into something lower on the ol' Chomsky hierarchy, it possibly wouldn't be such a good idea to. :)
16:01:35 <b\6> THE WAY THAT BEETLE CAN BENCH PRESS 850 TIMES ITS BODY WEIGHT GETS ME PUMPED ABOUT HASKELL!!! I WANT TO BENCHPRESS 850 PRINTED OUT MONAD TUTORIALS!!!
16:01:58 <shapr> b\6: Worth of @yow!
16:02:00 <shapr> worthy*
16:02:19 <thetallgu1> Handsome devil.
16:02:19 <mauke> @yow
16:02:19 <lambdabot> Couldn't find fortune file
16:02:28 <thetallgu1> I mis fortune.
16:02:53 <mauke> preflex: karma i
16:02:53 <preflex>  karma for i: 158
16:03:00 <mauke> preflex: karma x
16:03:00 <preflex>  karma for x: 29
16:03:25 <paczesiowa> lispy: maybe google for bencoding, there are similar things inside
16:03:27 <lispy> MyCatVerbs: yeah, I'm okay with recursive decent in this case...the grammar is very...simple I'm just using EBNF to spec out the data types that are in the syntax
16:04:01 <MyCatVerbs> lispy: I like PBNF best, myself. Where 'P' is short for 'Pseudo'. :)
16:04:14 <lispy> MyCatVerbs: exactly
16:04:15 <mauke> and BNF is for brainfuck!
16:04:25 <lispy> paczesiowa: okay
16:05:34 <lispy> MyCatVerbs: again, my goal is just to spec out the format enough that I can make a new parser in a diff language, but it seems a bit heavy weight to use a parser generator when my syntax is just sexps
16:07:11 <lispy> MyCatVerbs: I think I could specify the conditional read in BNF every easily as just expr = literal | ( expr ), but that doesn't tell me much about what I've parsed
16:07:34 <lispy> er literal | ( expr* )
16:08:30 <lispy> although, I have thought about making a tokenizing step like that
16:09:04 <lispy> or I could do one pass over the data to make sure it has tht syntax, then make simplifying assumptions in the parser...
16:10:15 <mmorrow> lispy: how's that haskell.sty working out for you?
16:10:50 <MyCatVerbs> lispy: you could parse it as <size><delimiter><digits>, then check that the size matches the number of digits given after parsing.
16:11:03 <lispy> mmorrow: I read up on the listings package, heavily modified it and now I have something that is very happy :)
16:11:21 <lispy> MyCatVerbs: yeah, that's probably how I'll code it
16:11:30 <mmorrow> lispy: ooh, high class. is it in the darcs darcs repo?
16:11:45 <lispy> mmorrow: not in darcs.net repo, but in my local repo yeah
16:11:50 <lispy> mmorrow: I'll just hpaste it
16:11:58 <mmorrow> lispy: sweet
16:12:46 <lispy> mmorrow: http://hpaste.org/9835
16:13:10 <eriador> hello everyone
16:13:24 <lispy> mmorrow: most notably I added \h{} for inline Haskell, this is nice for type signatures
16:14:31 <lispy> mmorrow: oh, I borrowed the literate=... from a mpage on the haskell wiki
16:15:01 <lispy> mmorrow: it's different than yours, but i don't know hich is nice, so I'm trying it out
16:15:35 * mmorrow 's firefox crashed yet again and is waiting for it to restart
16:16:50 <mmorrow> nice touch with the \h{}
16:17:12 <lispy> thanks, I had a bunch of type sigantures I want to discuss inline so I had to have something :)
16:19:08 <eriador> hi, does anyone know where I can read about equirecursive typechecking?
16:21:32 <lispy> eriador: hmm..no clue, but it sounds cool
16:22:32 <paczesiowa> :-(
16:23:04 <eriador> I was told it's not too different from standard typechecking with isorecursive types
16:24:21 <eriador> kinda hoping one of you guys would know where to look
16:28:17 <Philippa_> eriador: TAPL talks about it some
16:28:47 <eriador> yeah, but it's for a system with subtyping
16:29:11 <eriador> and the chapter on the metatheory only deals with the implementation of the subtyping relation
16:29:32 <sclv> I was telling a story today about some grammar I was trying to parse.
16:29:59 <sclv> And somebody asked me why I made such a production out of everything.
16:30:02 <Philippa_> eriador: actually it covers recursion in a number of contexts
16:30:08 <Philippa_> iso and equi
16:30:10 <sclv> *rimshot*
16:30:19 <Philippa_> have you read the whole book yet?
16:31:32 * BMeph waits for someone to start telling sclv about coproductions...
16:31:33 <lispy> sclv: *groan* :)
16:31:45 <Philippa_> in fact, the metatheory of recursive types chapter leaves subtyping (in iso-recursive types) 'til last. Or do you specifically need metatheory of the equi-recursive equivalent?
16:33:19 <Philippa_> generally you don't need the metatheory to typecheck, btw
16:33:52 <eriador> Philippa_: I know, I only need typechecking, but I couldn't find anything else on equirecursive types apart from the metatheory chapter
16:34:21 <esteth> Hey all. how do I check the constructor of an argument? Specifically, I want my function to match if the last element of a list of Pieces (data Piece = Red | Blue | Empty) is Empty, but I'm not sure how to do this
16:34:33 <Philippa_> yeah? The chapter before uses them
16:34:45 <eriador> right, but it's not very specific
16:34:48 <Philippa_> esteth: f Empty = ...
16:35:19 <sclv> f x = case x of Empty -> foo; Red -> bar; etc
16:35:26 <Philippa_> oh, wait, last element...
16:35:31 <eriador> the chapter before uses isorecursive types
16:35:40 <Philippa_> so you need to extract that first
16:35:51 <sclv> f x = case (last x) of Empty -> foo; _ -> bar
16:35:59 <sclv> (the _ matches anything else)
16:37:03 <esteth> aha, thanks :) It's just dawned on me that maybe i should be using Maybe Piece and have a Piece being just Red | Blue, with nothing representing empty. Hmm.
16:37:45 <sclv> esteth -- that's probably a good idea, because then you get all the nice functions that handle maybe for free.
16:37:49 <Philippa_> eriador: section 20.1's all equi-recursive, isn't it?
16:38:36 <esteth> sclv, Yeah. I think I'll go with that. Thanks for the help :)
16:38:38 <eriador> Philippa_: but it doesn't explain typechecking for them
16:39:11 <Philippa_> eriador: correct. Nevertheless, the more accurate your statements about what there is/isn't, the less time I waste poking through the book checking!
16:39:33 <eriador> sorry, I didn't mean for you to go through the book
16:39:39 <Philippa_> it refers to Chapter 21 for typechecking btw
16:39:43 <eriador> indeed
16:40:12 <eriador> but then in Chapter 21 it explains how to check membership in a greatest fixpoint
16:40:16 <eriador> and applies it to subtyping
16:40:51 <Philippa_> yes. But this is what you should expect: fixpoints being a vital part of the semantics of recursive objects
16:41:02 <eriador> ok, I understand that
16:41:22 <Philippa_> the subtyping situation /allows recursive type definitions/
16:41:22 <ddarius> Doesn't just ignoring the occurs check pretty much do it?
16:41:52 <eriador> but somewhere else it states that an equirecursive typechecker should infer the occurrences of the fold/unfold annotations
16:42:16 <eriador> ddarius: yeah, I thought about ignorinf the occurs check
16:42:23 <eriador> but I don't think it's enough
16:42:31 <Philippa_> no, it says that MLish languages effectively do that which isn't the same
16:42:50 <Philippa_> (incidentally, what's wrong with inferred isorecursive?)
16:43:13 <eriador> nothing wrong with isorecursive, I'm just learning
16:43:26 * ddarius has occasionally wanted equirecursive types, but very rarely.
16:43:57 <eriador> well, I just wanted to know how to do it..
16:43:59 <Philippa_> *nod*. I've had times when I've wanted to parameterise a type on itself
16:45:04 <Philippa_> yeah. Don't worry, basically
16:45:18 <eriador> right, so you mean I just ignore the occurs check?
16:45:21 <Philippa_> the inferred 'unfolds' and 'folds' are just telling you which side of the equality is useful at any given moment
16:45:41 <Myoma> if you _ignore_ occurs check your typechecker may loop
16:45:56 <eriador> Myoma: that's my point
16:46:05 <edwardk> ddarius: that pretty much works, but afterwards pretty much everything will typecheck
16:46:10 <Myoma> you act differently on it
16:47:08 <ddarius> edwardk: Isn't that the case for equirecursive types in general?
16:47:14 <seydar> what does $! do? I couldn't determine it from the docs.
16:47:20 <ddarius> @src ($!)
16:47:21 <lambdabot> f $! x = x `seq` f x
16:47:32 <Philippa_> seydar: it's a strict version of $
16:47:34 <edwardk> ddarius: pretty much
16:47:48 <seydar> Philippa_: what makes it strict?
16:47:57 <Philippa_> that is: forcibly evaluates the RHS (to WHNF) before applying the LHS
16:48:03 <Philippa_> the seq
16:48:28 <Philippa_> (note that it's strict in the RHS only!)
16:48:43 <eriador> Myoma: I act different on it, how?
16:48:50 <Philippa_> well, no, it's just /obviously/ strict in RHS only
16:48:51 <edwardk> ddarius: i say pretty much because constructors muddle it a bit iirc you can get some terms that fail because of overapplication of constructors but basically everything else 'type checks'
16:49:00 <Philippa_> good luck using _|_ as a function :-)
16:49:43 <yitz> ping syntaxninja
16:49:50 <newsham> > (fix id) 3
16:49:51 <lambdabot>  Stack space overflow: current size 8388608 bytes.
16:49:51 <lambdabot> Use `+RTS -Ksize' to incre...
16:49:52 <Philippa_> ddarius: how many of your cases for equirecursive types can't be solved with a trivial intermediary to do the recursing?
16:49:55 <seydar> Philippa_: so normal $ doesn't necessarily evaluate the RHS?
16:50:00 <Philippa_> seydar: right
16:50:10 <seydar> nice. i understand!
16:50:12 <yitz> @seen SyntaxNinja
16:50:12 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. I don't know when SyntaxNinja last spoke.
16:50:15 <Philippa_> > const "foo" $ error "bang!"
16:50:16 <lambdabot>  "foo"
16:50:30 <ddarius> Philippa: Obviously none of them.  The point was that adding the isomorphisms was a pain
16:50:32 <SyntaxNinja> hi yitz
16:50:35 <yitz> > error "bang!"
16:50:37 <lambdabot>  mueval: bang!
16:50:38 <Philippa_> that's the default behaviour of haskell functions
16:51:01 <newsham> mueval?
16:51:05 <yitz> Hi, I was just discussing some darcs issues over on #darcs.
16:51:25 <Philippa_> hi
16:51:30 <Philippa_> newsham: new eval lib
16:51:37 <yitz> It seems that eventually I should upgrade my team to darcs 2, but our server is a vps running etch.
16:51:50 <Philippa_> ddarius: talking of which, I may just end up having to do it with parameterised inference rules. Ouch?
16:52:01 <eriador> I think i'm kind of at a loss here with the equirecursive issue
16:52:03 <yitz> SyntaxNinja: darcs is 1.0.9rc1 on etch.
16:52:07 <seydar> wow, monads really aren't that bad
16:52:17 <yitz> SyntaxNinja: any hope of getting a backport?
16:52:26 <Twey> seydar: *grin*
16:52:37 <seydar> Twey: should i be scared?
16:52:44 <Philippa_> (thankfully the higher-order aspect's all stageable, it's just the more resistant version of my Checkable rule)
16:53:02 <SyntaxNinja> yitz: have you tried just compiling it?  are there missing dependencies?
16:53:03 <newsham> ooh.. new eval?  new bugs?
16:53:05 <Twey> seydar: Depends
16:53:08 <edwardk> @seen bos
16:53:08 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 4h 43m 21s ago.
16:53:13 <newsham> > writeFile "/tmp/gotcha" "gotcha"
16:53:14 <seydar> i took a class with haskell, and when they explained monads, i died. but monads are just... normal things
16:53:15 <lambdabot>  mueval: "<IO ()>"
16:53:18 <Philippa_> ...hah! Yeah, it figures that I'd try to simplify type inference by invoking HOLs, doesn't it? :-)
16:53:19 <Twey> seydar: Either you're gifted and got monads straight away
16:53:23 <BMeph> > s/>/^/1
16:53:24 <lambdabot> Terminated
16:53:29 <newsham> > unsafePerformIO
16:53:29 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:53:29 <Twey> seydar: Or you've misunderstood them and are in for a shock
16:53:32 <Twey> :)
16:53:44 <seydar> Twey: no, i learned about them in a class from february
16:53:44 <ddarius> seydar: Yep.
16:53:47 <SyntaxNinja> yitz: I'm not really doing much with darcs maintainership. maybe trent buck or someone might create a backport for you :)
16:53:52 <yitz> SyntaxNinja: tons. and on a vps with limited memory and disk I doubt I'd be able to pull it off anyway. I really need a binary pkg
16:53:57 <newsham> > let unsafePerformIO = 5 in unsafePerformIO
16:53:57 <Myoma> Philippa_: what's this for ?
16:53:57 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:54:03 <seydar> Twey: now i'm beginning to understand them
16:54:28 <yitz> trent buck?
16:54:29 <seydar> monads are just like saran wrap
16:54:30 <edwardk> Neat. I got the llvm guys to patch up the thing that prevented it from doing the ghc trick of storing heap and stack in global registers. together with using a simple custom JITMemoryManager to actually tag code pointers with the appropriate tag annotations that means llvm can do everything needed for the STG.
16:55:02 <yitz> @remember seydar monads are just like saran wrap
16:55:02 <lambdabot> I will never forget.
16:55:09 <seydar> haha
16:55:11 <Twey> Ah, right, seydar :-P
16:55:18 <edwardk> though it might be simpler to compile to that from c--.
16:55:20 <dons> edwardk: cool
16:55:28 <Philippa_> Myoma: me being too meta for my own good :-) Some general ideas about making the development and documentation of type inference systems easier
16:55:30 <edwardk> dons: http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20080818/066238.html
16:55:32 <lambdabot> Title: [llvm-commits] [llvm] r55128 - /llvm/trunk/lib/Target/X86/X86CodeEmitter.cpp, http://tinyurl.com/574j7c
16:55:35 <edwardk> that was the patch needed
16:56:00 <edwardk> anton didn't get it in for PPC or ARM, etc yet though because the logic is more complicated there.
16:56:10 <Myoma> Philippa_: sounds very interesting
16:56:15 <eriador> well, thanks for your answers anyway
16:56:32 <newsham> textual blacklisting.. should be interesting
16:56:39 <newsham> what could possibly go wrong?
16:56:40 <SyntaxNinja> yitz: he's a darcs maintainer, probably more active than me on it.
16:56:48 <Philippa_> Myoma: the equirecursivity bit is because I'm deliberately keeping checking and inference separate but inference often wants to 'import' all the checking rules - or better yet, variants that call the inferrer back instead of the checker for subterms
16:57:01 <edwardk> basically what they do to support global register vars in llvm-gcc is they use inline asm nodes that have no body but which say take in this fixed register and return this logical register, and if there are any mutations they use one to plumb it back.
16:57:06 <yitz> SyntaxNinja: you have distinct honor of being the official maintainer
16:57:23 <Philippa_> anyway, I'm taking it to IFL. The equirecursivity isn't central, it's just one of a number of semi-smartassed tricks helping keep things in the right form
16:57:41 <Philippa_> (I'm actually doing something else in my draft because I'm working with a simple enough system)
16:57:57 <Myoma> sorry what is IFL?
16:58:11 <Philippa_> @go IFL2008
16:58:13 <lambdabot> No Result Found.
16:58:14 <lilac> seydar: the better you understand monads, the simpler they seem :)
16:58:17 <Philippa_> @go IFL 2008
16:58:29 <lambdabot> http://events.sac-home.org/ifl2008/
16:58:29 <lambdabot> Title: IFL 2008 ¬ª 20th International Symposium on the Implementation and Application o ...
16:58:32 <Philippa_> that
16:58:49 <Philippa_> draft deadline's... er, today now
16:59:31 <Philippa_> conference itself's in a few weeks, I'll chuck the slides up online assuming it's accepted
17:00:12 <Philippa_> you may well find it boringly simple once you've got your hands on it, though I'd hope deceptively so
17:00:21 <edwardk> its a bit hackish, but the result is that in my llvm jit i toss around stack and heap in a pair of fixed registers and by using global register vars in g++ the same stack and heap pointers just appear as variables in the c++ code that the more complicated primitive ops are written in. and i don't have to explicitly pass them using the ABI.
17:00:32 <Myoma> :)
17:01:26 <bos> edwardk: ?
17:02:05 <edwardk> bos: was going to mention the llvm thing above since you'd put together haskell llvm bindings at one point
17:02:33 <SyntaxNinja> yitz: I think I'm just an uploader actually. trent is the official maintainer
17:02:49 <SyntaxNinja> maybe you're looking at the etch maintainer field
17:03:43 <bos> ah
17:04:03 <yitz> from the source pkg page: "Links for darcs... Maintainer: Isaac Jones"
17:04:11 <Twey> 'Languages with strong type systems are often described as ‚Äúbondage & discipline‚Äù languages - supposedly this is something to avoid, and which no true hacker would willingly use. B&D is bad, mmmkay? Except there‚Äôre a lot of less-vanilla folks out there who‚Äôll look on in amusement and ask ‚Äúwhat‚Äôs so bad?‚Äù (or ‚Äúwmmf mmf bmf?‚Äù as the case may be).'
17:04:16 * Twey laughs.
17:04:36 <yitz> SyntaxNinja: indeed
17:05:10 <SyntaxNinja> hi bos
17:05:14 <bos> hi SyntaxNinja
17:05:34 <Myoma> Philippa_: Do you consider typeclasses at all?
17:05:35 <lament> it's true. No true hacker would willingly use Haskell.
17:05:36 <ddarius> Philippa: What you want are refinement types.
17:05:53 <lament> Many true hackers took their lives rather then use Haskell.
17:06:05 <bos> the threaded runtime is a wicked beast. what it gives out in multicore scaling it takes away in straightline performance.
17:06:47 <edwardk> lament: that reminds me of http://www.lisperati.com/landoflisp/
17:07:15 <mmorrow> bos: it sure seems that way
17:07:21 <lament> edwardk: I love that comic
17:07:23 <Philippa_> Myoma: I'm using them as an example, though I elide the tough parts as being orthogonal to my point. A brief exploration of what evidence might look like if my lang includes it explicitly nets a basic module system too
17:07:52 <Philippa_> Twey: someone suggested I turn that into an ICFP paper :-)
17:08:07 <Philippa_> ddarius: where do I want refinement types?
17:08:22 <Philippa_> (I mean okay, I often have cause for them in coding in a minorly irritating way, but hey)
17:08:27 <ddarius> To separate the language type checking works over from the language type inference works over.
17:09:26 <mmorrow> ddarius: wow, i had to read that sentence 4 times to parse it correctly
17:09:35 <Philippa_> ah. Not quite sure that's what I'm looking to do in context
17:09:53 <LegendaryPenguin> what is a better way to do this? http://pastebin.com/d6182f066
17:10:03 <Twey> Philippa_: Nice, you should do :-P
17:10:18 <Philippa_> the equirecursive trick'd allow me to lift that "only works bottom-up" limitation and thus handle bidirectional systems where the bidirectionality's effectively implied by the explicit lang though
17:10:48 <yitz> LegendaryPenguin: you're taking the length a lot of times
17:11:13 <yitz> LegendaryPenguin: length reads all the way to the end of the list
17:11:45 <LegendaryPenguin> hmm yea, i guess it could be a parameter
17:12:10 <yitz> LegendaryPenguin: good idea, that would speed you up a bit I think.
17:12:24 <LegendaryPenguin> what about the merge? is there some function that does that already
17:16:14 <Myoma> type checking is three stages for haskell isn't it?   inference, typeclass dispatch, type checking
17:17:29 <Philippa_> Myoma: they're not stages, and the inferrer does the checking if you're looking at it like that
17:18:23 <Philippa_> generating and solving constraints on monotypes and resolving typeclasses can all be viewed as distinct, but they're typically interleaved
17:18:41 <Myoma> why would they be interleaved?
17:19:07 <ddarius> Why would the be distinct?
17:19:26 <dons> type class dispatch?
17:19:54 <ddarius> Presumably type class resolution
17:20:33 <Philippa_> Myoma: to do things in one AST traversal
17:21:01 <haskellian> can someone point to a good example where haskell-constructs can match macros?
17:21:06 <Philippa_> generating and solving constraints is commonly done simultaneously, for example - you just unify types
17:21:20 <Philippa_> haskellian: for what purpose?
17:21:25 <Botje> haskellian: lazy evaluation vs an if macro?
17:21:39 <MyCatVerbs> Philippa_: it'd make for much cooler conference papers to -write- it as three traversals, but have clever deforestation tricks turn it into just one. ;)
17:21:58 <Philippa_> if c t f = case c of {True -> t; False -> f}
17:22:28 <Philippa_> MyCatVerbs: no kidding. I'm increasingly thinking of using unification as a premature optimisation that encourages crap error messages
17:22:34 <Myoma> MyCatVerbs: I'm getting this horrible urge to try it with attribute grammars
17:22:53 <Philippa_> if you use a unification solver then hand-fusing it /does/ get you the classic version
17:23:35 <Philippa_> but making a big deal of it would be... wanky. If I get to do my talk, there may be a slide or two - but I've already got good reason to be introducing constraint systems
17:24:15 <MyCatVerbs> Philippa_: ouch. I'm trying to laugh but this cough kicks in instead. :)
17:24:30 <gavin0> does the type system of haskell present a problem when you figure out your program might not grow as you though in the beginning?
17:24:45 <gavin0> paul graham wrote about ML being bad this way
17:24:54 <gavin0> discouraging exploratory programming
17:25:01 <gavin0> and needing more planning
17:25:07 <chrisdone> mostly nonsense
17:25:11 <gavin0> good
17:25:28 <gavin0> I have a book by g sutton [I think] that is nice for a beginner liek me.
17:25:42 <Myoma> gavin0: I mostly do exploratory programming in haskell, rather than design things carefully :)
17:25:52 <gavin0> :)
17:26:07 <MyCatVerbs> gavin0: there's a grain of truth in there - sometimes you find yourself having to go back and change bits and pieces you wrote earlier to cope with a new structure somewhere down the line.
17:26:41 <Philippa_> MyCatVerbs: I've been on a fairly heavy "don't just write the fused version straight away" kick lately because it removes useful explanatory detail. cf my talk :-)
17:27:06 <sjanssen> the nice thing about using Haskell for exploratory programming is that when you do change something fundamental, the compiler will tell you all the other parts of your program that must change too
17:27:17 <MyCatVerbs> gavin0: if you take proper advantage of polymorphism, though, it's exceedingly rare for that to happen in any situation where you wouldn't have to restructure untyped code in order to cope with the changes you've made anyway.
17:27:46 <gavin0> what is polymorphism?
17:27:57 <sjanssen> where in Lisp your program will just crash every other time you run it
17:28:14 <encryptio> gavin0: a function that can take arguments of many types is polymorphic
17:28:14 <Myoma> sjanssen: C not lisp :p
17:28:34 <sjanssen> Myoma: C is sometimes better in this regard
17:28:38 <jeffz> Myoma: C doesn't gauruntee that your program will crash
17:28:52 <lispy> sjanssen: yeah, I hate that.  As you dev and refactor you end up with things in memory that don't exist in the source...then you restart your interpreter and suddenly things don't work :(
17:29:10 <lispy> sjanssen: I have that with python too
17:29:11 <sjanssen> lispy: scary
17:29:16 <stepcut> gavin0: I find the type system to be most useful when making big changes, because I get lots of nice compiler errors telling me where I forgot to update stuff
17:29:17 <MyCatVerbs> gavin0: it's where functions have free variables in their types. You can think of it as functions not caring about all of the type that they're working on.
17:29:20 <Olathe> Does Haskell guarantee that my program will crash ?
17:29:34 <lispy> sjanssen: that's why I like that ghci will reload everything when you do :r so it clears the memory
17:29:44 <MyCatVerbs> Olathe: not if you use Foreign.Storable.poke inappropraitely. ^_^
17:29:58 <Olathe> Ahh.
17:30:04 <Olathe> I'll refrain from using it, then.
17:30:06 <MyCatVerbs> gavin0: for example, the "head" function in Haskell works on lists of any type, not just lists of one specific type.
17:30:38 <MyCatVerbs> Olathe: (yes, mostly, but a lot of dangerous stuff is still available anyway. It's marked as dangerous in the documentation, though.)
17:30:43 <Philippa_> Olathe: if you avoid the FFI and a few related bits and pieces in IO it shouldn't crash per se
17:31:20 <Olathe> Ahh, OK.
17:32:39 <Myoma> < 1 + unsafeCoerce "fish"
17:32:39 <Myoma> Segmentation fault
17:32:59 <Myoma> badly typed programs can go wrong
17:33:28 <sjanssen> > head [] -- crash or not?
17:33:29 <lambdabot> Terminated
17:33:33 <MyCatVerbs> Philippa_: interesting idea. You're talking about writing the program so that it reads as an easy-to-follow outline of the problem and its solution, rather than whatever runs quickest?
17:34:00 <MyCatVerbs> sjanssen: exception thrown, with well-defined semantics. Not a crash. :)
17:34:46 <sjanssen> MyCatVerbs: "head []" is not an exception in Haskell (GHC extensions aside)
17:34:57 <Myoma> yes it is
17:35:16 <Myoma> well it's an error not an exception
17:35:23 <sjanssen> it's _|_
17:35:25 <Myoma> i.e. the function error
17:35:26 <Philippa_> MyCatVerbs: right. Then I'd really like to be able to just spec the fusion (I don't mind doing that much), let the simplifier have a field day with the result and get fast results
17:35:30 <gavin0> ok
17:35:48 <Philippa_> does that help explain my interest in ToRA's project?
17:35:51 <gavin0> now I notice that lisp has simple syntax of (something x1 x2 x3)
17:35:59 <gavin0> is the haskell syntax light as well?
17:36:04 <Myoma> gavin0: In haskell:  something x1 x2 x3
17:36:17 <gavin0> (+ 3 4 5 6 7 8)
17:36:25 <gavin0> haskell need + a bunch of times eh?
17:36:27 <Myoma> sum [3,4,5,6,7,8]
17:36:35 <gavin0> commas yes I saw that
17:36:40 <gavin0> in my sutton book
17:36:51 <MyCatVerbs> Philippa_: no, but only because I can't quite remember which project ToRA's was. ;)
17:36:57 <gavin0> Myoma: so you use haskell as general purpose ?
17:37:05 <Myoma> gavin0: no
17:37:11 <sjanssen> Myoma: I do
17:37:26 <Philippa_> MyCatVerbs: originally it was a structure editor (that led to the lib he talked about) that he'd intended to add some serious rewriting tools to
17:37:35 <MyCatVerbs> Philippa_: oh aye, thanks.
17:37:41 <sjanssen> erm, I meant to address that to gavin0
17:37:58 <MyCatVerbs> Philippa_: you're thinking that could be used to create something like RULES pragmas, but more powerful?
17:38:16 <Philippa_> I think he was a little worried at my response to that aspect, not least because it's currently a backburner project
17:38:23 <MyCatVerbs> Heh. :)
17:38:56 <Philippa_> MyCatVerbs: sort of what happens if you use RULES as part of a language for defining commands within an editor that you can then target yourself
17:39:14 <MyCatVerbs> That's the first thought that pops into my head - if you want to write efficient programs that way - describe, then describe how it fuses - you'd presumably want something more powerful than the current naive term rewriting.
17:40:33 <gavin0> cool
17:40:34 <MyCatVerbs> How powerful is RULES theoretically, anyway? They can cause the simplifier to loop infinitely by mistake, so presumably they're Turing-complete?
17:40:41 <gavin0> sjanssen: what are you doing with haskell lately?
17:41:16 <Philippa_> MyCatVerbs: plenty of subturing langs that don't guarantee termination :-)
17:41:22 <jeffz> gavin0: implemented any dns servers lately?
17:41:33 <MyCatVerbs> Philippa_: I'm on pretty shaky ground here, hence asking. :)
17:41:55 <sjanssen> gavin0: last thing I did was submit a few patches to an X11 library written in pure Haskell
17:42:00 <MyCatVerbs> Philippa_: ohhhh, that'd be really cool. You could even use that as a way to test your rewrite rules manually, to check that they (eventually) produce the right code.
17:42:31 <Armored_Azrael1> Hey, are there any projects for running mirrors of darcs.haskell.org repositories? Either you guys are frequently under heavy load, or you're hugely rate-limited
17:42:43 <MyCatVerbs> Philippa_: plus it'd make all the Java hackers green with envy at how easily you could create new Haskell refactorings in your editor. ;)
17:43:15 <sjanssen> gavin0: I just wanted to point out that people use Haskell for all sorts of practical stuff
17:44:03 <chessguy> 'evening
17:44:49 <MyCatVerbs> sjanssen: some people do. I don't! I don't even use C or bash or Java for practical stuff. ANARCHY IN THE SUBSTRATE, YES!
17:45:12 <gavin0> sjanssen: k00l
17:45:33 <gavin0> jeffz: nope, i heard djbdns is k0l
17:45:41 <jeffz> heh, http://google.com/search?q=gavino+troll
17:45:42 <lambdabot> Title: gavino troll - Google Search
17:46:06 <Myoma> jeffz, maybe better for #haskell-blah
17:46:19 <gavin0> Im reformed
17:46:22 <chessguy> anybody know if Stuart Cook is a #haskell citizen
17:46:59 <sjanssen> jeffz: ah, I knew the nick was familiar
17:50:54 <Twey> 'ey, chessguy.
17:51:02 <chessguy> hiya
17:51:46 <Armored_Azrael1> If there is any kind of mirroring opportunities available, how much space do they require? (I run a cluster with a decently sized uplink, and mirroring something like haskell.org would come within our mandate)
17:52:19 <lispy> Armored_Azrael1: you need to speak with someone such as dcoutts_ or dons
17:52:29 <Armored_Azrael1> ok
17:52:43 <lispy> Armored_Azrael1: I'm not certain, but given the bandwidthing issues I think a mirror would be welcomed
17:53:14 <lispy> I know I get frustrated with the speed of some of the *.haskell.org servers
17:53:23 <dcoutts_> Armored_Azrael1: we've not got any mirroring for hackage set up, it's worth looking into, but the major part of the issue is management, not just finding suitable mirror machines
17:53:28 <lispy> Fast some days, and terrible throttled or unresponsive other times
17:54:13 <lispy> dcoutts_: what sense of management? Finding the knowledgable IT/sysadmin people who have time?
17:54:15 <dcoutts_> and there's only certain services that can easily be mirrored
17:54:36 <dcoutts_> lispy: well, how do we direct users to these mirrors? what services do we mirror etc
17:54:40 <chessguy> @pl s x = "x" ++ (s' . t $ x)
17:54:40 <lambdabot> s = ('x' :) . s' . t
17:54:54 <chessguy> @pl s x = "x" ++ (s . t $ x)
17:54:54 <lambdabot> s = fix ((('x' :) .) . (. t))
17:55:21 <dcoutts_> Liskni_si: eg the haskell wiki cannot be mirrored easily, though it could be proxied
17:55:27 <dcoutts_> oops
17:55:32 <lispy> hmm
17:55:37 * dcoutts_ is bitten by tab completion again
17:55:37 <Armored_Azrael1> dcoutts_: The wiki however isn't one of the slow services, right?
17:55:47 <ddarius> Turn it off and enter a new reality.
17:55:52 <Myoma> @pl f x = (q . p . u . v . y) x
17:55:53 <lambdabot> f = q . p . u . v . y
17:55:58 <Myoma> @pl f u x = (q . p . u . v . y) x
17:55:59 <lambdabot> f = ((q . p) .) . (. (v . y))
17:56:00 <dcoutts_> Armored_Azrael1: well, we've not got good measurements of what are and are not the slow things
17:56:06 <Armored_Azrael1> Ah.
17:56:13 <dcoutts_> Armored_Azrael1: what do you perceive as slow?
17:56:15 <Myoma> @pl f p x = (q . p . u . v . y) x
17:56:15 <lambdabot> f = (q .) . (. (u . v . y))
17:56:21 <Armored_Azrael1> dcoutts_: In my experience, the slow stuff is the darcs repositories and the hackage downloads.
17:56:41 * lispy agrees
17:56:50 <dcoutts_> Armored_Azrael1: so hackage downloads are a prime candidate for mirroring since they do not update fewquently
17:57:04 <Armored_Azrael1> This is true
17:57:09 <dcoutts_> at least the tarballs do not, and the index only updates a few times a day
17:57:12 <Armored_Azrael1> Repositories I understand would be less slow
17:57:15 <Armored_Azrael1> err
17:57:19 <Armored_Azrael1> less able to be mirrored
17:57:23 <dcoutts_> right
17:57:46 <lispy> If everyone had a post-hook in apply the mirror could be notified whenever they change...(huge PITA though)
17:57:48 <Armored_Azrael1> Though, another thing it might be nice to mirror is the head/branch tarballs used for loading ghc
17:58:09 <dcoutts_> Armored_Azrael1: and better, tools like cabal install could be taught how to find mirrors transparently
17:58:20 <Armored_Azrael1> Should work.
17:58:34 <dcoutts_> though there are also security issues with mirroring
17:58:57 <Armored_Azrael1> dcoutts_: Unfortunate, but if you're worried about cabal-install, you can solve that one with gpg signing
17:59:06 <seydar> Twey: ok, monads aren't *quite* saran wrap
17:59:17 <dcoutts_> yeah, it's a huge pita unfortunately
17:59:21 <Armored_Azrael1> Ah.
17:59:26 <dcoutts_> eg windows users
17:59:33 <dcoutts_> what do they do about gpg
17:59:36 <Armored_Azrael1> Oh, forgot about them
17:59:41 <dcoutts_> can it be made transparent
17:59:47 <seydar> How can I define my own monad?
17:59:52 <Armored_Azrael1> Well, if you have any kind of gpg lib, then sure.
17:59:56 <Armored_Azrael1> Which I assume we do...
18:00:03 <Armored_Azrael1> seydar: Look up the typeclass monad, make an instance
18:00:04 <lispy> dcoutts_: so now we need a cabal-installable gpg equivalent?
18:00:07 <chessguy> @pl m b = a (f b) b
18:00:08 <lambdabot> m = a =<< f
18:00:12 <dcoutts_> Armored_Azrael1: and people complain when we add deps to cabal-install
18:00:24 <dcoutts_> they complain now that it's got two non-standard deps
18:00:33 <Armored_Azrael1> dcoutts_: Yes, and this is somewhat understandable.
18:00:44 <seydar> Armored_Azrael1: is that as simple as adding 'deriving Monad' to my data type?
18:00:51 <Armored_Azrael1> seydar: No.
18:01:01 <seydar> ok, whipping out the google
18:01:12 <Armored_Azrael1> dcoutts_: An alternative would be to make it an optional dep with preprocessor stuff to turn off GPG checking in the code if it's not present.
18:01:40 <dcoutts_> lispy: we've got various crypto libs, but it's all just a lot of work and many dependencies. There's probably no getting away from it in the end though.
18:01:54 <Myoma> ?djinn (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
18:01:54 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
18:02:34 <Armored_Azrael1> dcoutts_: Oh, here's a simpler way--have a small md5sum on the real hackage with the md5sum for each package
18:02:36 <lispy> dcoutts_: yes, eventualy people will expect some sort of signing.  Maybe we should start now by geting the deps you'll need added to batteries included, when when it's out you just flip the switch and the ligths go on
18:02:49 <Armored_Azrael1> dcoutts_: An md5sum can be placed in the code directly with minimal effort
18:02:55 <Armored_Azrael1> (thus avoiding dependencies)
18:02:56 <Philonous> seydar: basically you need to implement >>= and return for your data type
18:03:00 <dcoutts_> lispy: probably the minimum we could get away with is a single hackage key that is used to sign package manifests (ie hashes)
18:03:25 <dcoutts_> or just a signed index
18:03:27 <lispy> dcoutts_: yes, and some might argue that's worth having just to ensure you downloaded it correctly
18:03:47 <solrize> gpg isn't that hard to implement, i've done it in python.  the rfc is kind of confusingly written but it's just a bunch of bit twiddling and some bignum arithmetic
18:03:50 <dcoutts_> lispy: indeed, the new hackage server uses ContentMd5 headers
18:03:58 <seydar> Philonous: thanks!
18:04:11 <ivanm> is there any way of getting a random element from a Set short of converting it to a list and choosing an element from there?
18:04:20 <Armored_Azrael1> solrize: True, but this means you're maintaining yet another gpg lib for use in cabal install, which is plain silly
18:04:26 <solrize> there's one already?
18:04:40 <dcoutts_> lispy: right, so if only the index is signed and the index contains md5/shasums of the tarballs then that's probably good enough
18:05:10 <Armored_Azrael1> solrize: Perhaps not a haskell library yet, but if you made one it wouldn't be part of the cabal-install package
18:05:14 <dcoutts_> and then on the other side hackage can do gpg verification of package uploads
18:05:40 <dcoutts_> so end users cannot do end to end verification (well perhaps optionally)
18:05:58 <dcoutts_> but can at least check that it's the thing that came from hackage
18:06:08 <solrize> alternatively you could use something like jar files, which are maybe more standard than gpg (you get the corp-fud scam certificate infrastructure, etc)
18:06:17 <lispy> dcoutts_: wel, md5 and most shas won't mke the purists happy.  But, I see them an practicaly good enough.  And I think sha256 is good enough for crypto people and darcs has an implementation in haskell
18:06:55 <solrize> these cabal thingies are small enough that slow hashes in haskell won't be too big a problem, i expect?
18:07:16 <dcoutts_> solrize: the index file is ~500k
18:07:22 <lispy> Er, sorry, darcs has a binding to a sha256 in C, which I think is probably fast enough
18:07:33 <dcoutts_> but the amount that needs signing is less than that I guess
18:07:35 <solrize> well i thought we wanted to get rid of c
18:07:41 <solrize> sign everything
18:07:53 <sw17ch> solrize, noo :) C has it's place
18:08:15 <sw17ch> we want to make Haskell as good at working with and competing with C as possible, but i don't think you're going to find a good way to replace it :)
18:08:25 <dcoutts_> so long as the C code can be easily bundled then it's not a problem for distribution
18:08:51 <dcoutts_> eg like what the zlib package does, uses the system zlib on sane systems and bundles a copy for windows
18:09:16 <lispy> dcoutts_: oh, well, it's GPL'd might be your only hesitation...at least the trivial haskell FFI wrapper is
18:09:18 <solrize> i made up a c vs. haskell joke, http://hpaste.org/9603
18:09:36 <blbrown> newb question:  how should I create a multidimensional array.  Are they really needed? Should I just create an array of arrays.  I was using this as a reference (immutable array):  http://haskell.org/haskellwiki/Arrays
18:09:37 <lambdabot> Title: Arrays - HaskellWiki
18:09:58 <dcoutts_> lispy: aye, that'd be problematic, but I'm sure we can find code
18:10:22 <lispy> dcoutts_: indeed, I'm looking at the C bits and the license type is unclear...probably BSD compatible though
18:10:51 <lispy> dcoutts_: hmm...yeah I think this is 3clause BSD without actually saying BSD
18:11:01 <solrize> this is for hash libs?  there's definitely some non-gpl ones, like libtomcrypt
18:11:29 <Armored_Azrael1> blbrown: Just use a tuple as your index
18:12:03 <chessguy_> @bot
18:12:03 <lambdabot> :)
18:12:06 * lispy is looking at http://darcs.net/src/Crypt/sha2.c
18:13:09 <solrize> ever since i looked at dawson engler's website i've been afraid to write any more c code.  and i've written a LOT.
18:13:54 <Olathe> What about his website did that ?
18:14:18 <Twey> seydar: *chuckles*
18:14:21 <solrize> the website basically illustrates that coding in c is not too much different from juggling live chainsaws ;)
18:14:29 <Twey> seydar: By making a type that's an instance of Monad
18:14:33 <Olathe> Ahh.
18:14:35 <nornagon> solrize: heh, yeah. i went to RUXCON one year and since then i've been afraid to call *any* software secure
18:14:48 <solrize> heh
18:15:08 <seydar> Twey: i was hoping i could just add 'deriving Monad' to my data type
18:15:13 <solrize> but an awful lot of security bugs are of the sesame street style: this bug was brought to you by the letter C
18:15:31 <Twey> seydar: You can't, because you need to provide return and >>=
18:15:51 <seydar> yea, i know that now
18:15:54 <Philonous> I think "deriving" only works for Ord, Eq, show and read
18:15:57 <Twey> instance Monad MyType where ...
18:16:01 <seydar> Armored_Azrael1 helped me on that one
18:16:05 <Twey> Ah, OK :)
18:17:01 <blbrown> Armored_Azrael1,  I guess I can't do this can I ... do you have the syntax to declare your multidimensional data structure:    arr <- newArray (1, 10) :: IO (IOArray (Int,  IO (IOArray Int Int)))
18:17:02 <seydar> its not possible to make a function that takes variable args, is it?
18:17:07 <seydar> is print special like that?
18:17:15 <Myoma> seydar: it is possible
18:17:47 <seydar> within only haskell? or do i have to drop down to C
18:17:59 <Myoma> :t print
18:18:00 <lambdabot> forall a. (Show a) => a -> IO ()
18:18:12 <Myoma> are you talking about this print?
18:18:27 <Twey> printf
18:18:31 <Twey> seydar: It's kind of possible
18:18:35 <Twey> But pretty awkward
18:18:49 <Olathe> You could end it with something.
18:19:39 <sw17ch> @index forever
18:19:39 <lambdabot> bzzt
18:19:51 <Armored_Azrael1> blbrown: OK, so you're making a two dimensional IO array
18:19:59 <Armored_Azrael1> blbrown: What do you want the bounds on that to be?
18:20:12 <Twey> forever f = f >> forever f
18:20:32 <nornagon> :t Control.Monad.State.forever
18:20:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:20:41 <seydar> Twey: shouldn't it be f >> forever? my knowledge is menial, but i t0tally just looked that up
18:20:47 <Twey> seydar: Nope
18:20:48 <Armored_Azrael1> blbrown: OK, I'll call the bounds (x1, y1) and (x2, y2)
18:20:54 <nornagon> seydar: nope, forever takes an argument
18:21:06 <Twey> seydar: Then the next iteration of 'forever' would get the 'unwrapped' monad value
18:21:08 <seydar> doesn't >> take a and supply it to b?
18:21:10 <blbrown> Armored_Azrael1, I just want a mutable array; something like int [10, 10] in imperative languages.  And some way to reference the values
18:21:11 <Twey> And >> would fail
18:21:15 <nornagon> seydar: that's >>=
18:21:19 <seydar> ah
18:21:23 <nornagon> @src (>>)
18:21:23 <lambdabot> m >> k      = m >>= \_ -> k
18:21:26 <Twey> (if it were >>=, aye)
18:21:27 <Armored_Azrael1> blbrown: OK
18:21:34 <Myoma> blbrown: Why would you use a mutable array?
18:21:37 <TomMD> > never id
18:21:37 <Armored_Azrael1> blbrown: arr <- newArray ((0, 0), (9, 9)) 0
18:21:38 <lambdabot> Terminated
18:21:50 <chrisdone> :t never
18:21:51 <lambdabot> Not in scope: `never'
18:21:54 <TomMD> Exactly
18:21:57 <Armored_Azrael1> blbrown: Will generate an array that can be indexed 0 to 9, with all values initialized to zero
18:22:08 <chrisdone> > typeOf never
18:22:09 <seydar> @src (>>=)
18:22:09 <lambdabot> Terminated
18:22:09 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:22:19 <Armored_Azrael1> blbrrown: The array has type IOArray (Int, Int) Int
18:22:19 <seydar> @src (>>)
18:22:20 <lambdabot> m >> k      = m >>= \_ -> k
18:22:21 <TomMD> If there were a never function what type would it have?  What is the inverse of forever?
18:22:36 <Twey> TomMD: a -> ()
18:22:41 <Myoma> never = return ()
18:22:46 <chrisdone> no
18:22:48 <Myoma> oops
18:22:49 <Twey> Oh, yeah, with a monad
18:22:49 <chrisdone> never = const $ return ()
18:22:51 <seydar> Twey: so then why did you do 'f >> forever f'? You're just evaluating f and then applying it
18:22:52 <Myoma> never action = return ()
18:23:08 <TomMD> Myoma: But how can you be sure something else won't run 'action' somewhere else?
18:23:21 <TomMD> never action = tricky_runtime_call_deleting_thunk action >> return ()
18:23:26 <Twey> seydar: IO magic.
18:23:35 <Armored_Azrael1> blbrown: To access it, use the syntax readArray arr (xIndex, yIndex)
18:23:54 <Myoma> in that case, let never = forever constraint to the opposites monad
18:24:02 <Armored_Azrael1> blbrown: But seriously, consider using a functional array. If you're just worried about performance, use a DiffArray. Corrupting your computation with the IO monad is usually a bad idea.
18:24:03 <Twey> Haha
18:24:22 <seydar> Twey: oh, is f a function?
18:24:24 <dons> DiffArray's performance sucks, sadly.
18:24:28 <blbrown> Armored_Azrael1, do I have to define the type; I am getting this error:  No instance for (MArray a t2 IO)  arising from a use of `newArray' at GameLife.hs:16:9-35
18:24:36 <chrisdone> seydar: f is an action
18:24:46 <Myoma> blbrown: What do you want mutable for?
18:24:49 <Twey> seydar: It's a monadic action
18:24:59 <seydar> chrisdone: whats an action?
18:25:09 <seydar> a function with all its args supplied, waiting to be eval'd?
18:25:17 <TomMD> dons: Since when did this data structure show up in Haskell land?
18:25:24 <Twey> An action is a function that runs within IO.
18:25:30 <chrisdone> seydar: a function which performs some computation in a monad
18:25:45 <ivanm> is there any way of getting a random element from a Set short of converting it to a list and choosing an element from there?
18:25:50 <dons> TomMD: DiffArray?
18:25:53 <TomMD> Yes
18:26:13 <dons> hm... circa 1992?
18:26:15 <ddarius> It's been there for a long, long time.
18:26:17 <blbrown> Myoma, write/change the elements of the array.  I guess it is easier to work with if I can just use: writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
18:26:23 <seydar> chrisdone: Twey: still lost. can you point me to a link or do you mind clarifying?
18:26:29 <TomMD> I certainly missed it.  Where do I look?
18:26:35 <dons> though the copyright says 2001, that sounds wrong.
18:26:58 <Armored_Azrael1> blbrown: You are getting a syntax error b/c you didn't load a module that provides an IO insance of MArray it seems, but seriously, consider DiffArray, it is _probably_ more correct
18:27:00 <dons> the code within looks like array fusion era. Gill et al code.
18:27:05 <dons> so early 90s.
18:27:08 <Twey> seydar: Errm, not sure what you're lost at
18:27:20 <dons> we've spent the last 5 years looking at using fusion to eliminate the costs of pure arrays
18:27:29 <dons> maybe its time to revist transaction/diff approaches
18:27:33 <dons> or a combination thereof :)
18:27:37 <Twey> It's pretty simple -- it just 'executes' the monad repeatedly
18:27:38 <chrisdone> seydar: all values of type `forall m a. Monad m => m a' are actions
18:27:58 <Armored_Azrael1> dons: While DiffArray's performance "sucks", it's still faster than using regular arrays, and you get to remain in functional land.
18:28:03 <seydar> Twey: couldn't an action that runs on IO just be something thats like: a <- getLine; init a? init is operating in IO
18:28:10 <Twey> Of course it's not *actually* forever because it will be broken at some point by an error or whatever
18:28:28 <Twey> seydar: Sure
18:28:32 <Twey> That's an action
18:28:33 <chrisdone> seydar: such as putStrLn "hello", which has type IO (), and getLine, which has type IO String
18:28:39 <Twey> As is getLine
18:28:51 <Myoma> blbrown:Are you implementing game of life? using a mutable array would not be a good way
18:28:52 <seydar> so init was an action in my example? really?
18:28:56 <Twey> Yep
18:29:01 <dons> Armored_Azrael1: you actually measured it as faster for some application?
18:29:06 <TomMD> Ahh, I see.  I suppose I should have looked at the Array library more than just being happy with IArray.
18:29:18 <dons> that's pretty cool. i've not heard of any reports of the current implementation being faster.
18:29:42 <dons> IntMap always seems to win, from my experience.
18:30:12 <Armored_Azrael1> dons: Yes
18:30:12 <blbrown> Myoma, DiffArray?  what do you recommend, 64x64 element data structure
18:30:26 <Myoma> blbrown: [[Bool]]
18:30:43 <Armored_Azrael1> dons: I was using a regular array for a pixel canvas for the purpose of trying my hand at software-only graphics rendering.
18:30:45 <gavin0> I want to allot a giant arry that is 95% of my ram in my pc
18:30:51 <gavin0> and use ti for everything!
18:30:53 <Armored_Azrael1> dons: Rasterizing was going ABSURDLY slow.
18:30:53 <gavin0> crazy?
18:31:03 <chrisdone> no, just stupid
18:31:06 <Olathe> > let mapMany _ [] = [[]]; mapMany f xs = (map f xs :) . mapMany f in mapMany (+1) [1, 2, 3] []
18:31:06 <gavin0> doh
18:31:07 <lambdabot>  Couldn't match expected type `[[a]]'
18:31:10 <Myoma> gavin0: crazy, you've wasted 5%
18:31:10 <Olathe> Doesn't work :(
18:31:15 <gavin0> heh
18:31:17 <Armored_Azrael1> gavin0: You already have it, it's called pointer dereference
18:31:34 <Armored_Azrael1> dons: So I switched to DiffArray, and it went much faster
18:31:50 <solrize> cache effect?
18:32:24 <Olathe> Why doesn't that work ?
18:32:24 <Armored_Azrael1> dons: To be fair, this is probably partially because many points remained black, but on my sample render, I went from about 4 minutes to about 30 seconds.
18:33:49 <blbrown> yea
18:34:45 <seydar> Twey: thanks. adios!
18:35:09 <Myoma> @pl q x = f (g x) x
18:35:09 <lambdabot> q = f =<< g
18:36:24 <Twey> @src State (>>=)
18:36:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:36:28 <Twey> :(
18:36:46 <Twey> I was just insulted by a pile of nuts and bolts :(
18:37:01 <Myoma> @pl f x y = q (zip x y)
18:37:01 <lambdabot> f = (q .) . zip
18:37:11 <Olathe> Have you considered trying to match wits with a pile of nuts and bolts ?
18:37:16 * Twey laughs.
18:39:46 <solrize> does anyone remember that c library for storing big vectors or lookup tables in memory?
18:42:43 <Myoma> @hoogle sleep
18:42:43 <lambdabot> No results found
18:43:50 <ddarius> The language is already lazy.  We don't need to exacerbate it.
18:45:02 <ddarius> sleep = do putStrLn "Ok"; newEmptyMVar >>= takeMVar
18:45:19 <Twey> Hmn
18:45:27 <Twey> Where might I find (>>=) for State?
18:45:32 <Twey> It's not in the Report, is it?
18:45:41 <ddarius> @src State (>>=)
18:45:41 <lambdabot> Source not found. You type like i drive.
18:45:52 <ddarius> State isn't in the Report.
18:45:56 <Twey> Thought so
18:47:09 <EvilTerran> ?source Control.Monad.State.Lazy
18:47:10 <lambdabot> Control.Monad.State.Lazy not available
18:48:50 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#line-102
18:48:52 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
18:54:23 <mmorrow> preflex: @tell
18:54:23 <preflex>  what
18:54:56 <mmorrow> preflex: @tell gwern i extended and integrated checkNames http://code.haskell.org/~morrow/code/haskell/misc/mueval-checkNames.diff
18:54:56 <preflex>  Consider it noted.
18:54:58 <lambdabot> http://tinyurl.com/6jsaqt
18:56:06 <mmorrow> preflex: @tell gwern also, your tests.sh which prevents darcs recording doesn't succeed even on an unmodified mueval repo
18:56:07 <preflex>  Consider it noted.
18:58:53 <stepcut> despite meachems assurances that adding error handling to frisby is trivial, I am not have a trivial time of it
19:00:08 <ddarius> That you can't trust anyone who says something is trivial is trivial.
19:01:00 * stepcut checks out the jhc source code
19:01:22 <stepcut> ah, jhc does not use Frisby...
19:02:13 <stepcut> ah, it is perhaps just baked in
19:07:02 <b\6> preflex: @tell b\6 eat a bag of hell
19:07:02 <preflex>  what
19:07:22 <Olathe> preflex: @tell b\6 eat a bag of hell
19:07:22 <preflex>  Consider it noted.
19:07:33 <b\6> thx.
19:07:33 <preflex>  b\6: you have 1 new message. '/msg preflex messages' to read it.
19:07:37 <Olathe> Bots are getting hard of hearing these days.
19:07:40 <b\6> hmm, intriguing.
19:13:58 <Cale> heh, that's an awesome 'what'
19:14:59 <Cale> stepcut: Maybe it's the sense of the word 'trivial' which means 'not a research problem'.
19:15:59 <dons> Armored_Azrael1: a "regular array" ? i guess not an unboxed array.
19:18:43 <shap1> SHAZAM!
19:19:20 <shap1> ?users
19:19:20 <lambdabot> Maximum users seen in #haskell: 490, currently: 437 (89.2%), active: 14 (3.2%)
19:19:46 <shap1> @seen vixey
19:19:46 <lambdabot> I haven't seen vixey.
19:19:48 <shap1> aww
19:19:58 <ivanm> preflex: seen vixey
19:19:58 <preflex>  vixey was last seen on #haskell 5 days, 2 hours, 10 minutes and 52 seconds ago, saying: sbahra: I can't find the code
19:20:03 <shap1> aha!
19:20:15 <Myoma> "It's wizard magic, It's all books and stars and geometry, she'd never grasp it. Who ever heard of a female wizard?"
19:20:53 <shap1> where's that from?
19:21:07 * Myoma is listening to Discworld - Equal Rites
19:21:25 <shap1> ah
19:21:59 <ivanm> Myoma: "listening"?
19:22:14 <ivanm> pfffft, people these days that can't even read books on their own but have to have it read to them....
19:22:15 <ivanm> :p
19:22:38 <shap1> ivanm: I like to listen to Swedish books
19:23:20 <ivanm> why? the person reading them has a sexy voice? :p
19:24:01 <ddarius> I'm sure there are some readers that I could listen to for quite some time.
19:24:24 <Myoma> shap1: I am here :)
19:24:24 <ddarius> Speaking of which
19:24:30 <shap1> ivanm: Nah, because I'm trying to improve my listening comprehension.
19:24:35 <ivanm> ahhhh
19:24:38 <ddarius> What's with the new nick?
19:24:54 <shap1> Myoma: aha! you changed nicks!
19:24:59 <shap1> I liked vixey...
19:25:01 <shap1> oh well
19:25:02 <ivanm> yeah.... I'm trying to improve my listening+speaking comprehension of Ukrainian via skype :p
19:25:09 <shap1> ivanm: That's cool.
19:25:20 <solrize> oh i thought ddarius was referring to shapl being a new nick
19:25:33 <solrize> and i wondered, wouldn't shapl' be faster?
19:26:19 <shapl> solrize: at speeds this slow, there's no perceptual difference
19:26:51 <shapl> I'm running at 5 Mu ops per second!
19:27:00 * lispy tries t picture shapl at realitivistic speeds
19:28:45 <shapl> how do you picture relativistic motion?
19:29:11 <ivanm> there's some cool simulations of what happens when you get close to the speed of light...
19:29:31 <Olathe> What happens when those simulations travel at the speed of light ?!
19:29:37 <ivanm> the light can't reach you
19:29:48 <ivanm> oh, waith, those are for when _you_ travel at the speed of light...
19:29:58 <ivanm> not sure if anyone has modelled what it looks like to a 3rd party...
19:31:47 <Olathe> So, if you take the projector or whatever that show the simulations running and accelerate it to near light speed, what happens to the understandability ?
19:32:13 <dcoutts_> @seen gwern
19:32:13 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I don't know when gwern last spoke.
19:32:22 <ivanm> preflex: seen gwern
19:32:23 <preflex>  gwern was last seen on #xmonad 3 hours, 54 minutes and 15 seconds ago, saying: * gwern points to what I already said about default imports. arguing that perl is better because it includes by default a shit-ton of operators and sugar and libraries isn't going to convince me
19:33:27 <dcoutts_> @tell gwern I'm pushing some cabal-install config file patches, back up your ~/.cabal/config and play around. Also try removing ~/.cabal/config and see what defaults it uses and the new semi-self documenting content.
19:33:27 <lambdabot> Consider it noted.
19:35:35 * Myoma only just _now_ realizes why shapl' is faster
19:47:12 <Myoma> @w80 alminack
19:47:13 <lambdabot> No match for "alminack".
19:48:40 <ddarius> Bah, if it were Webster he'd spell it almanak or alminak
19:48:53 <Myoma> what does it mean?
19:48:57 <ddarius> @wn almanac
19:48:58 <lambdabot> *** "almanac" wn "WordNet (r) 2.0"
19:48:58 <lambdabot> almanac
19:48:58 <lambdabot>      n 1: an annual publication including weather forecasts and other
19:48:58 <lambdabot>           miscellaneous information arranged according to the
19:48:58 <lambdabot>           calendar of a given year [syn: {farmer's calendar}]
19:49:00 <lambdabot> [3 @more lines]
19:49:16 <Myoma> @more
19:49:16 <lambdabot>      2: an annual publication containing tabular information in a
19:49:16 <lambdabot>         particular field or fields arranged according to the
19:49:16 <lambdabot>         calendar of a given year
19:49:35 * Myoma would like an almanac
19:50:37 <ddarius> They are easy enough to find.
20:27:06 <jeffwheeler> I've seen something like > iterate (cycle [(+1), (+2)]) 3 before, but I can't seem to get it right now.
20:27:25 <jeffwheeler> What's the correct form for that?
20:28:17 <jeffwheeler> I'm looking to create a list like [3, 4, 6, 7, 9, 10, ..]
20:29:35 <ddarius> > scanl ($) 3 (cycle [(1+), (2+)])
20:29:50 <jeffwheeler> Hm, not as beautiful as I thought, but that works; thanks.
20:30:02 <koninkje> > [3..]
20:30:12 <koninkje> ah, nevermind
20:31:09 <ddarius> @bot
20:32:03 <Cale> hmm... down?
20:32:58 <jeffwheeler> Actually, that scanl trick doesn't seem to work. :-/
20:33:05 <ddarius> Add a flip
20:33:06 <Cale> It didn't notice that it had been disconnected.
20:33:48 <Cale> > map ($ 3) (scanl (.) id (cycle [(1+), (2+)]))
20:33:51 <Cale> Or do that :)
20:34:09 <jeffwheeler> IThat works; thanks.
20:34:13 <jeffwheeler> Ack, drop the "I".
20:34:19 <ddarius> Blech.
20:34:24 <b\6> is there a pattern to the numbers ommitted?
20:34:36 <Cale> yes :)
20:34:50 <ddarius> Cale's is fugly.
20:34:52 <jeffwheeler> I bet, but those aren't the actual functions I'm using.
20:35:51 <Myoma> fix (\f x -> x:x+1:f (x+2)) 3
20:36:38 <Cale> Is it really? I rather like it :)
20:37:14 <Cale> Or possibly,  sequence (scanl (.) id (cycle [(1+), (2+)])) 3
20:37:17 <ivanm> how long are we going to be botless this time?
20:37:35 <Cale> I'm just taking the opportunity to pull in gwern's updates
20:37:40 <ivanm> *nod*
20:37:54 <Cale> shouldn't be long if nothing breaks :)
20:38:06 <ivanm> heh
20:38:12 <ivanm> in which case we can blame gwern?
20:38:17 <ivanm> this is the latest mueval I take it?
20:38:27 <ivanm> so does this mean lambdabot no longer requires hs-plugins?
20:38:49 <Cale> right.
20:38:55 <ivanm> \o/
20:39:15 <ivanm> are you going to be putting a tarball on hackage?
20:39:39 <Cale> It's still not on hackage
20:40:04 <Cale> I suppose that I could. It's meant to be built and run from its source directory still.
20:40:14 <ivanm> oh....
20:40:16 <Cale> So it wouldn't work so well with cabal install.
20:40:21 <ivanm> :(
20:40:45 <Cale> If someone wanted to make that happen though, it would be cool :)
20:40:59 <ivanm> heh
20:41:48 <blbrown> how would I do python's:  ' ' * 20
20:41:55 <Myoma> replicate
20:41:57 <Cale> replicate 20 ' '
20:42:10 <Myoma> let (*) = flip replicate
20:42:45 <Myoma> > let (*) = flip replicate in    ' ' * 20
20:42:50 <ivanm> Cale: so why does lambdabot only work when built from the src directory?
20:42:52 <Cale> hehe
20:42:52 <blbrown> dammit, I knew that
20:42:52 <lambdabot>  "                    "
20:42:55 <ivanm> dodgy build layout?
20:43:45 <ddarius> It is unnecessarily round-about.
20:44:00 <ddarius> Which adds a decent chunk of inefficiency for no reason.
20:44:07 <Cale> ivanm: Well, it still builds code using modules in the State directory, and needs files from there while running.
20:44:27 <Cale> I suppose they could be installed somewhere.
20:44:57 <Cale> :t foldr
20:44:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:45:20 <ddarius> > scanl (flip ($)) 3 $ cycle [(1+), (2+)]
20:45:21 <lambdabot>  [3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,40,42...
20:45:52 <Cale> > sequence (scanl (.) id (cycle [(1+), (2+)])) 3
20:45:54 <lambdabot>  [3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,40,42...
20:47:59 <b\6> is it way worse to filter for es such that e+1 % 3 != 0?
20:48:41 <Cale> Not really, but it doesn't generalise in the same way.
20:48:41 <jeffwheeler> And . . . I just realized I'm solving the completely wrong problem with all that cycle stuff. :D
20:49:18 <Cale> > [x | x <- [3..], x + 1 `mod` 3 /= 0]
20:49:20 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
20:49:44 <Cale> oh right :)
20:49:48 <Cale> > [x | x <- [3..], (x + 1) `mod` 3 /= 0]
20:49:49 <lambdabot>  [3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,40,42...
20:50:14 <b\6> but is that obviously way slower or something?
20:50:30 <b\6> maybe better to just produce the correct ones than to test them all.
20:50:47 <Cale> Well, it's not so different because they're both really fast.
20:52:11 <Cale> But if the functions you were applying were something more complicated, of course you might not be able to even express it as a filtering condition, or the elements might get sparse enough that generating all of them and then filtering is slower
20:52:17 <ddarius> > ap(zipWith subtract)tail[1..]
20:52:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:52:28 <Cale> Of course, you can come up with examples where the filter will be faster too.
20:52:39 <chrisdone> ddarius: what have you against spaces?
20:52:52 <Cale> > [1,1..]
20:52:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:01:54 <Myoma> > (zipWith subtract =<< tail) [1..]
21:01:55 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
21:03:40 <jeffwheeler> @pl l' n = if even n then n `div` 2 else (n*3)+1
21:03:40 <lambdabot> l' = ap (liftM2 if' even (`div` 2)) ((1 +) . (3 *))
21:03:41 <ivanm> > repeat (-1) -- I think this is easier/nicer :p
21:03:42 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
21:04:29 <Myoma> l' n | even n = n `div` 2
21:04:40 <Myoma> l' n | odd n = n * 3 + 1
21:05:51 <Twey> If I have a list of arguments and want to apply a monadic action to all of them and ignore the result, what do I use?  mapM_ is it?
21:05:58 <ivanm> yup
21:06:00 <Twey> Ta
21:28:14 <gneek> Hi everyone, I seem to be having some noob problem... I can't get this (www.gneek.narod.ru/hs/datatype.hs) to compile. Could someone tell me what I'm doing wrong?
21:30:54 <gneek> anyone?
21:30:56 <doctormach> Try main = putStrLn (tripleFst(Triple "one" 2 3.14))
21:31:38 <sjanssen> that isn't the only problem
21:31:45 <gneek> Thanks, that worked
21:31:51 <sjanssen> oh, nevermind
21:32:21 <doctormach> Is there any way to get ghc to desugar do-notation into regular monadic notation?
21:32:42 <sjanssen> doctormach: we do have a lambdabot plugin for that
21:32:50 <sjanssen> @undo do x <- m; f x
21:32:50 <lambdabot> m >>= \ x -> f x
21:33:12 <doctormach> sjanssen:, cool, thanks
21:34:27 <sjanssen> @redo m >>= \ x -> f x
21:34:28 <lambdabot> do { x <- m; f x}
21:42:02 <Myoma> @redo m >>= \     x -> f x
21:42:02 <lambdabot> do { x <- m; f x}
21:42:24 <shapr> shapl: goaway!
21:42:57 <TSC> @hoogle [a] -> Int -> [a]
21:42:57 <lambdabot> Prelude drop :: Int -> [a] -> [a]
21:42:57 <lambdabot> Prelude take :: Int -> [a] -> [a]
21:42:57 <lambdabot> Data.List drop :: Int -> [a] -> [a]
21:43:43 <sjanssen> heh, shapr vs. shapl
21:44:34 <Cale> heh
21:44:52 <shapM> too bad ' isn't allowed in IRC nicks
21:46:19 <Cale> Nicks should allow unicode characters.
21:46:53 <Myoma> we would design and implement something much much better than IRC
21:47:03 <sjanssen> well, IRC was invented before Unicode
21:47:04 <Myoma> the only problem is, nobody would use it
21:47:17 <Myoma> progress is impossible :(
21:47:25 <Cale> I wonder...
21:47:35 <sjanssen> IRC is particularly tough
21:48:08 <Cale> There are enough users in other countries whose names consist of characters that can't be rendered into the odd subset of ASCII that nicks normally support.
21:48:10 <sjanssen> you have to penetrate both the client and server market
21:48:11 * Myoma mostly wants to add drawing ability
21:48:35 <ivanm> Myoma: ummm.... why?
21:48:48 * ivanm thinks latex support would be better than drawing support...
21:49:00 <curveater> what's haskell?
21:49:11 <Cale> curveater: It's a functional programming language
21:49:15 <sjanssen> curveater: a functional programming language
21:49:30 <ivanm> Cale, sjanssen: shouldn't that be s/a/the/ ? :p
21:49:36 <Cale> heh
21:50:55 <Cale> You might have a look around haskell.org
21:51:02 <sjanssen> @girl19
21:51:02 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
21:54:42 <Myoma> @qqote
21:54:42 <lambdabot> DerekElkins says: What people need to do is stop reading two page blog posts by someone who's "just got" monads and read the well-written peer-reviewed papers by the people who clearly know what
21:54:42 <lambdabot> they are talking about.
21:54:57 <Myoma> @qqote
21:54:57 <lambdabot> Bulat says: there is new Time library, which is supposed to replace old System.Time. we hope that it will happen before 2038
21:57:19 <Cale> @quote
21:57:19 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
21:57:19 <lambdabot> us until we're sure they're OK.
21:57:29 <Cale> @quote
21:57:29 <lambdabot> DerekElkins says: What people need to do is stop reading two page blog posts by someone who's "just got" monads and read the well-written peer-reviewed papers by the people who clearly know what
21:57:29 <lambdabot> they are talking about.
21:57:33 <Cale> hmm
21:57:44 <ivanm> hang on, that quote makes sense!
21:57:46 <Myoma> @quoue
21:57:46 <lambdabot> osfameron says: hombre!  functional programming, he tiring!
21:57:47 <ivanm> what's it doing there?
21:58:01 <Cale> @keal
21:58:01 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
21:58:21 <Cale> ahhh... there we go, proper, high quality nonsense
21:58:30 <Cale> @keal
21:58:30 <lambdabot> bot seems useless
21:58:32 <Cale> @keal
21:58:32 <lambdabot> i lack in verbal and social expression
21:58:33 <ivanm> yay!
21:58:35 <Cale> @keal
21:58:35 <lambdabot> i aint running that on my puter
21:58:39 <Cale> @keal
21:58:40 <lambdabot> my proof show math is broken right now
21:58:43 <ivanm> who's keal meant to be, anyway?
21:58:46 <mwc> holy crap... RWH preorders are ridiculously cheap
21:58:46 <Cale> keal :)
21:58:51 <Myoma> @keal
21:58:51 <lambdabot> it is very easy to go off topic
21:58:57 <mwc> amazon.ca has it for $31
21:59:10 <Cale> He was a guy who joined here and trolled in rather amusing ways :)
21:59:11 <ivanm> :o
21:59:19 <ivanm> and they want $90+ here :o
21:59:33 <Cale> So we took a bunch of his quotes and put them in the bot :)
21:59:35 <ivanm> Cale: ahhh
21:59:43 <ivanm> better than farrop? :p
21:59:52 <Cale> Well... more blatantly insane
21:59:56 <sjanssen> @keal
21:59:57 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
21:59:59 <sjanssen> @keal
21:59:59 <lambdabot> you need a Zh function in Haskell
22:00:01 <sjanssen> @keal
22:00:01 <lambdabot> nsa try kill me numerous times
22:00:05 <sjanssen> there we go
22:00:47 <sjanssen> Harrop isn't so much a troll as a vocal self promoter
22:00:55 <Cale> I think he actually may be schizophrenic, or have some kind of real disorder... my friend talked to him for a while and it turns out that he sometimes goes off his meds, and...
22:01:00 <Myoma> > let b = 7 ; v = 6 ; p = 3 in b*(floor(v/b^p)/b-floor(floor(v/b^p)/b))
22:01:01 <lambdabot>  Add a type signature
22:01:17 <ivanm> @quote harrop
22:01:18 <lambdabot> No quotes match. Where did you learn to type?
22:01:28 <ivanm> I though lambdabot had some of his quotes :s
22:01:38 <Cale> It's almost time we had an @harrop :)
22:01:45 <sjanssen> Cale: it is time!
22:02:00 <Philippa_> sjanssen: he's worse than that though, he's willing to cause strife amongst others in order to generate sales
22:02:08 <Myoma> nobody will go insane faster than a sane person
22:02:19 <sjanssen> everyone hunt for good Harrop quotes
22:02:50 <Philippa_> most of the stuff I've found amusing's been a little too subtle for a straight-up quote, unfortunately
22:03:57 <mwc> Cale: hahah, I just saw a LISP thread linked on reddit where somebody called harrop out to say something bad about caml
22:03:57 <dons> does anyone know of hand what data of type "*" in a heap profile coresponds to?
22:04:32 <mwc> Cale: if GHC 6.10 gets out before concurrent GC in Caml (3.11 maybe?), Harrop will have major crow to eat
22:04:46 <Philippa_> dons: I'd guess boxed, unknown type on the inside - just a guess though
22:04:59 <Heffalump> mwc: 6.10 will just have *parallel* GC
22:05:04 <dons> he doesn't care about ocaml though. he happily proclaims its failure wrt. F#.
22:05:16 <dons> Philippa_: yeah. that's what i figure.
22:05:20 <dons> bit weird.
22:05:34 <Myoma> he said he likes ocaml better than f#
22:05:41 <sjanssen> dons: did you catch his blog post about popularity of Haskell packages vs. OCaml in Debian and Ubuntu
22:05:45 <sjanssen> ?
22:06:00 <dons> sjanssen: yeah, he's been pushing that since january.
22:06:04 <Myoma> > let b = 7 ; v = 6 ; p = 3 in b*((fromIntegral$floor(v/b^p))/b-(fromIntegral$floor((fromIntegral$floor(v/b^p))/b)))
22:06:06 <lambdabot>  0.0
22:06:18 <mwc> Heffalump: alas, yes, I screw up that distinction in speaking
22:06:18 <dons> though he did concede on the ocaml list that xmonad's increased its users by an order of magnitude this year.
22:06:57 <Myoma> Has anyone else tried to encode a hierarchy of number types with implicit promotion in haskell?
22:07:08 <Myoma> i.e. (int + rational) :: Rational
22:07:10 <dons> he's small game. he produces no code of significance, and basically lives somehow on self-published, pay-per-read blog posts, interleaved with ocaml/F# "consulting". all very sad.
22:07:12 <sjanssen> "Our conclusion is, of course, that we are not going to consider diversifying into the Haskell market, at least not until it matures. Right now, Scala is looking much more viable."
22:07:21 <dons> also refers to himself as "we".
22:07:21 <bos> harrop comes across as a complete ass. it's like he can't understand his own words.
22:07:37 <ivanm> dons: does anyone actually buy+read his books?
22:07:38 <dons> sjanssen: he can't make money from haskell.
22:07:41 <sjanssen> dons: that is his conclusion, after an entire article about how Haskell is deficient because there isn't enough software written in it
22:07:54 <sjanssen> it's a total non-sequitur!
22:07:54 <dons> since we already make available freely all the information he could potentially try to sell us.
22:08:01 <Cale> Myoma: It's doable with enough multiparameter typeclasses and functional dependencies, but automatic promotion of numeric types is sort of evil. :)
22:08:06 <mwc> I was appalled with how he equated GHC moving to git with the failure of haskell
22:08:08 <dons> his model relies on having unique access to knowledge, which only works in dysfunctional communities.
22:08:23 <dons> he sells ocaml blog posts, becaues there are no ocaml or f# bloggers.
22:08:57 <Cale> That is ridiculous, btw. :)
22:09:06 <Cale> Who pays for blog posts?
22:09:08 <dons> imagine if he tried to sell subscriptions to the "haskell journal", when TMR, the HWN, the wiki, the wikibook, etc, -- no market.
22:09:15 <Myoma> Cale: my semi-solution was quite horrible, and I can't see if it's possible to go the whole way with it.  but why is it evil?, I was mostly aiming for useable
22:09:52 <Myoma> dons: ocaml has a dysfunctional community?
22:10:01 <dons> so yes, given how effective we are at organising and distributing code and content *for free*, its no wonder he's not "diversifying into haskell"
22:10:02 <Cale> Myoma: Well, I suppose Integer -> Rational isn't so bad, but Integer -> Double, for example, loses precision... numeric conversions are usually something you want to be careful about.
22:10:08 <mwc> Myoma: ocaml has a poor link between the community and INRIA
22:10:11 <dons> Myoma: in comparison, it's not an effecitve market.
22:10:21 <mwc> Myoma: you have problems with type conversion at all in haskell
22:10:26 <Philippa_> *nod*
22:10:39 <dons> there isn't uniform access to information, so harrop can try to sell the stuff we give away.
22:10:40 <Myoma> Cale: yeah I set up a DAG of subsets, with CReal at the top
22:10:49 <mwc> at best, you can create a single datatype data VarNum = Int' Int | Float
22:10:53 <mwc> ' Float etc
22:11:03 <mwc> overload Num for it
22:11:06 <Philippa_> whereas the GHC HQ<=>community link is strong enough that we ended up with what's rapidly become a regular yearly event springing up out of what was originally a job interview there
22:11:08 <mwc> and then define a promotion class
22:11:12 <sjanssen> dons: he sells blog posts?
22:11:31 <dons> sjanssen: his "OCaml Journal" and "F# Journal" appear to be effectively what we do as blog posts.
22:11:36 <Cale> mwc: Well, by redefining Num, you can do better...
22:11:41 <Myoma> I think you need a more expressive relational language between types to do it actually
22:11:54 <Myoma> (and yeah I scrapped Num and all that)
22:12:01 <Cale> class Num a b c | a b -> c
22:12:09 <Cale> or something :)
22:12:17 <Philippa_> dons: I imagine they're peer reviewed. Pee on the articles, see how much they stink...
22:12:22 <dons> heh
22:12:22 <mwc> Cale: true, but then you'd have to go to say, +. as an operator
22:12:27 <mwc> and then it smacks of ocaml
22:12:28 <Heffalump> btw his justification for "we" is that he's talking about his company which is his wife and him
22:12:34 <dons> Heffalump: oh!
22:12:37 <Cale> mwc: Not if you don't import the Prelude...
22:13:02 <Myoma> dons: what do we get out of banning him from this channel and slagging him off ?
22:13:14 <dons> well, we don't have to slag him off. better to just ignore him.
22:13:15 <mwc> Cale: plus, runtime promotion has advantages... Int * Int doesn't necessarily need to promote to Integer, but if the result would overflow, then it should
22:13:17 <ivanm> Myoma: amusement?
22:13:19 <ivanm> ;-)
22:13:23 <dons> banning him helps remove noise from the community.
22:13:38 <mwc> dons: harrop has trolled this channel?!
22:13:40 <dons> esp. since he's keen to undermine the open source haskell world.
22:13:46 <Cale> mwc: That's sort of hard to tell at compile time.
22:13:58 <mwc> Cale: indeed, so runtime promotion is a win there
22:14:01 <dons> so denying him access to our large, diverse community is an effective punishment.
22:14:03 <Cale> mwc: Oh, *runtime* promotion
22:14:05 <Myoma> mwc: its' non trivial to encode trolling in the type system :p
22:14:07 <Cale> Yeah, okay.
22:14:12 <mmorrow> Myoma: i did that once, define a GenNum = Float Float# | Double Double# | Int Int# | Integer Integer# | ...  and wrote Num,... instance for GenNum in the same way that GHC does in GHC.{Int,Word,Integer,Float,Real}
22:14:19 <Cale> But Integer already effectively does that much.
22:14:32 <Cale> (It uses machine ints for small values)
22:14:32 <mmorrow> Myoma: it was quite tedious, and i never used it
22:14:50 <mwc> Cale: true. Less trivially, one could reduce Rationals to Ints when appropriate
22:14:59 <mmorrow> yeah, an integer is  Integer# = S# Int# | J# Int# ByteArray#
22:15:12 <Cale> For promoting to rationals/reals... perhaps such a thing would be worthwhile. I'm not sure.
22:15:34 <Cale> Rationals already use Integer arithmetic as part of their functioning.
22:15:35 <Myoma> Cale, things like
22:15:39 <mwc> compile time promotion is probably better for use in haskell, but I'd go the runtime route for interpreting another language
22:15:40 <Myoma> length :: [a] -> Integer
22:15:49 <Myoma> average list = sum list / length list
22:15:51 <Myoma> would be nice,
22:15:54 <Myoma> and
22:15:57 <Cale> Myoma: that's more a problem with the type of length, imo
22:15:58 <Myoma> > let b = 7 ; v = 6 ; p = 3 in b*((fromIntegral$floor(v/b^p))/b-(fromIntegral$floor((fromIntegral$floor(v/b^p))/b)))
22:15:59 <lambdabot>  0.0
22:16:04 <Myoma> really doesn't need all the fromIntegrals
22:16:11 <Cale> length :: (Num b) => [a] -> b  makes a lot more sense
22:16:44 <Myoma> Cale: I used to think so... but it turns if you defined length = foldr (const (+1)) 0 or whatever, it's less efficient than genericLength = fromIntegral . length
22:16:54 <mmorrow> but the fromIntegrals all get rewritten to the fastest, most efficient way that exists to convert, and this happens at compile time so there's no runtime overhead
22:17:05 <Cale> Myoma: That's what SPECIALISE pragmas are for :)
22:17:20 <Cale> and/or some rewrite rules :)
22:17:32 <Myoma> Cale: so I had a play with making all the promotion implicit but what struck me as odd is how much more expressive the typeclass logic language could be
22:17:59 <mmorrow> (and kess efficient)
22:18:03 <mmorrow> s/k/l
22:18:03 <Myoma> I think you could do a lot of generic programming over sets of type and so on if it was better
22:18:04 <Cale> Myoma: In what way exactly?
22:18:08 <Cale> hmm
22:18:24 <mmorrow> Myoma: ooh, elaborate :)
22:18:49 <sjanssen> allbery_b: may I quote you on "Where exactly did we pick up this, er, individual?  Would they please take it back as defective?" for the @harrop quote plugin I'm writing?
22:19:09 <Cale> Myoma: do you think the existing functional dependencies stuff is deficient? (I agree that it's hard to understand in detail... it will probably be replaced by type families)
22:19:15 <Philippa_> Myoma: have you got your head adequately around the restrictions on the logic language due to the need for coherency?
22:19:43 <Myoma> I don't know what coherency means here
22:19:45 <Philippa_> sjanssen: do we really need to indulge in frog-boiling?
22:19:50 <ivanm> if I've got a record-based type, is it possible to specify that one of the values has to be of a particular class? (i.e. specify that one of the values must be in the RandomGen class)
22:19:53 <Myoma> is that wrt. open world assumption?
22:20:00 <Philippa_> Myoma: always picking the same instance for the same type
22:20:04 <Philippa_> (s)
22:21:04 <mmorrow> ivanm: yeah.  data A a b = A { one :: (Foo a) => a, two :: (Blue b) =>b, three :: Int }
22:21:54 <Cale> ivanm: uh, there is, but it tends not to mean what you really want it to mean
22:22:36 <Cale> ivanm: You can restrict the types, but it only restricts the type of the constructor functions. You don't get those constraints for free when pattern matching later on.
22:23:02 <Cale> (so it doesn't let you remove any class constraints from your program, and potentially adds some)
22:23:45 <Cale> However, in GHC 6.8+ there is a nice feature of the GADT syntax which allows typeclass dictionaries to implicitly stored along with the data
22:23:52 <Cale> For example...
22:24:03 <Cale> data Set a where
22:24:19 <Cale>    Cons :: (Ord a) => a -> Set a -> Set a
22:24:19 <Myoma> Cale: I don't think so, but I know I can't currently do a few things I'd like to
22:24:29 <Cale>    ...
22:25:19 <mmorrow> Myoma: what are a few of these things you can't do but would like to? (out of interest)
22:25:46 <Cale> Will store the dictionary for Ord a along with values of type Set a constructed by Cons, so that comparisons can be made when pattern matching without the function that uses the Set values having an Ord constraint.
22:25:56 <ivanm> just in case it didn't appear before (my connection decided to die :s ): if I've got a record-based type, is it possible to specify that one of the values has to be of a particular class? (i.e. specify that one of the values must be in the RandomGen class)
22:26:05 <Cale> oh, d'oh
22:26:05 <mmorrow> haha
22:26:06 <Cale> hehe
22:26:15 <Myoma> mmorrow: well the running example was, given a DAG take it's transitive closure (call that Sub), then (+) :: (Number a, Number b, Number c, Sub a c, Sub b c) => a -> b -> c doesn't work
22:26:18 <Cale> ivanm: uh, there is, but it tends not to mean what you really want it to mean
22:26:29 <Cale> ivanm: You can restrict the types, but it only restricts the type of the constructor functions. You don't get those constraints for free when pattern matching later on.
22:26:34 <Cale> (so it doesn't let you remove any class constraints from your program, and potentially adds some)
22:26:37 <Cale> However, in GHC 6.8+ there is a nice feature of the GADT syntax which allows typeclass dictionaries to implicitly stored along with the data
22:26:42 <ivanm> :(
22:26:54 <Cale> For example...
22:26:57 <Cale> data Set a where
22:26:59 <Cale>    Cons :: (Ord a) => a -> Set a -> Set a
22:27:14 <Cale>    EmptySet :: Set a
22:27:19 <ivanm> so I should probably just restrict myself to a particular PRNG implementation?
22:27:31 <adu> Cale: wouldn't those have to be lowercase?
22:27:41 <Cale> adu: those what?
22:27:51 <adu> or are you missing |
22:28:02 <Cale> adu: It's GADT syntax.
22:28:06 <Cale> (note the 'where')
22:28:22 * adu does not know GADT syntax
22:28:26 <Myoma> :t Nothing
22:28:27 <lambdabot> forall a. Maybe a
22:28:27 <Myoma> :t Just
22:28:27 <mmorrow> Myoma: ok, so allow me to get that straight (in my head) ... so  there's an arrow   a ---> c   and one   b ---> c , where  t0 ---> t1 <=> t0 `subTypeOf` t0 ?
22:28:28 <lambdabot> forall a. a -> Maybe a
22:28:34 <ivanm> Cale: so that's different from a record-based data type?
22:28:42 <Myoma> adu: data Maybe a where Nothing :: Maybe a ; Just :: a -> Maybe a
22:28:56 <Cale> ivanm: Well, yeah, but you can combine GADT's and record syntax now...
22:28:59 <mmorrow> Myoma: err, where  t0 ---> t1 <=> t0 `subTypeOf` t1
22:29:02 <bos> dons: is ch26 in?
22:29:02 <Cale> iirc.
22:29:09 <Myoma> mmorrow: yes
22:29:25 <adu> Myoma: how is that different from "= Nothing | Just a"?
22:29:41 <Myoma> adu: It's exactly the same, you can use it to compare the syntax and not worry about the meaning
22:29:44 <ivanm> hmmmm... not sure what version of ghc my lecturer's got installed (since the only reason I'm "allowed" to use haskell is because he's got it installed at home... :s )
22:29:54 <adu> Myoma: o ok
22:30:00 <Cale> adu: The GADT syntax is more flexible
22:30:19 <Cale> adu: Because you can write things like...
22:30:26 <Cale> data Expr a where
22:30:26 <adu> Cale: i would imagine so, it seems more explicit and homogeneous
22:30:27 <mmorrow> Myoma: ok, so if a ---> c, does that imply that the type a can *always* be injected into the type c sensibly?
22:30:32 <Cale>    Const :: Integer -> Expr Integer
22:30:44 <Cale>    Positive :: Expr Integer -> Expr Bool
22:31:04 <Cale>    If :: Expr Bool -> Expr a -> Expr a -> Expr a
22:31:07 <adu> Cale: and since the language it is being homogeneous with is Haskell, that's gotta be pretty expressive
22:31:09 <Myoma> mmorrow: yeah I have a coerce :: a -> c function when a ---> c
22:31:31 <Cale> and then you can write something like   eval :: Expr a -> a
22:31:47 <Cale> So it effectively lets you hijack the type system for your own ends.
22:31:54 <adu> Cale: ooooo
22:32:53 <Cale> ivanm: Another option is maybe existentials around the RandomGen class.
22:33:19 <mmorrow> Myoma: so then you could possibly have a class    class To a b where to :: a -> b            and  write an instances for all conversion you want,  the you could have   (.+.) :: (To a c, To b c) => (c -> c -> c) => a -> b -> c     (.+.) f a b = (to a) `f` (to b)
22:33:38 <ivanm> Cale: existentials?
22:33:43 <Myoma> mmorrow: that's almost exactly what I have written down :)
22:34:05 <Cale> data RG = forall g. (RandomGen g) => RG g
22:34:09 <mmorrow> Myoma: heh
22:34:12 <Cale> Or in GADT syntax:
22:34:17 <Cale> data RG where
22:34:26 <Cale>    RG :: RandomGen g => g -> RG
22:34:43 <Cale> hmm, let me try that :)
22:35:20 <Myoma> I wonder if the biggest problem is interacting with modules, so perhaps making it expressive enough to use as a module system among others would resolve that
22:36:24 * Myoma can't really tell yet
22:37:26 <mmorrow> Myoma: beyond that then it seems that possibly you want Data.Dynamic, because if it the types can't be statically worked out to a satisfiable extent, then there's the possibility of runtime failure. Data.Dynamic handles this with  dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
22:37:41 <dons> bos, not yet. will be done tonight. it's getting big though.
22:37:47 <Myoma> what for ?
22:37:51 <dons> you'll be able to post it in the morning.
22:37:54 <bos> dons: ok, thanks.
22:38:13 <dons> we have lots of pretty puzzle solving through space and time profiling :)
22:38:21 <dons> and a bit of core for good measure.
22:38:39 <Cale> yeah, this works...
22:38:43 <Cale> I'll hpaste
22:39:05 <Cale> http://hpaste.org/9837
22:39:39 <Cale> That lets you wrap a value whose type is an instance of RandomGen in the constructor RG, which will forget what type of generator it was.
22:39:50 <Cale> (and makes RG an instance of RandomGen itself)
22:39:56 <mmorrow> Myoma: Data.Dynamic uses a Key type it derives from the type on the way in, then unsafeCoerce to do what it needs to do
22:41:05 <Cale> So it basically gives you a nice type for "I don't care what type of random generator this is" :)
22:41:09 <mmorrow> Myoma: oh, just saw your previous comment. how do you mean " so perhaps making it expressive enough to use as a module system among others would resolve that" ?
22:41:29 <Cale> ivanm: Did you catch that? :) (Just wondering if you're still here :)
22:41:45 <Cale> This is actually quite a nice use case for existentials.
22:41:57 <Cale> I'll have to remember it and use it as an example :)
22:42:14 <ivanm> heh, hard to tell who you were talking to :p
22:42:17 * ivanm looks
22:42:31 <mmorrow> toDyn :: Typeable a => a -> Dynamic
22:42:31 <mmorrow> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
22:42:36 <adu> Cale: as opposed to forall's? I haven't seen any exists type signatures yet...
22:43:02 <Cale> adu: yeah, that's because existential types use forall in a creative way to avoid making exists into a keyword
22:43:12 <Cale> (they move the forall outward)
22:43:15 <ivanm> Cale: and I can then use RG anywhere as an instance of RandomGen?
22:43:20 <Cale> ivanm: right
22:43:39 <ivanm> how many versions back did that extension get included?
22:43:46 <Cale> Quite a few...
22:43:59 <ivanm> OK, so it's likely the lecturer has it :p
22:44:01 <adu> ?
22:44:04 <Cale> oh, but that LANGUAGE pragma might be a problem...
22:44:17 <ivanm> oh?
22:44:20 <Cale> So you might just want to use -fglasgow-exts or something, if there's an issue.
22:44:27 <Cale> LANGUAGE is new in 6.8 iirc.
22:44:46 <quicksilver> no, LANGUAGE is in 6.6
22:44:47 <adu> so if the only keyword used is "forall" then shouldn't it be called universal types?
22:44:54 <ivanm> adu: I'm only "allowed" to use Haskell because after I started coding my assignment, we were told we could only use languages that were installed in the lab... but the lecturer has haskell installed at home, so he says it's OK
22:44:58 <quicksilver> it just didn't support a lot of useful things in 6.6
22:45:20 <ivanm> Cale: so how do I create a value of type RG?
22:45:21 <Cale> adu: Well, forall and exists can be expressed in logic in terms of one another, it's rather like that :)
22:45:39 <adu> Cale: I don't like double-negatives :)
22:45:43 <Cale> ivanm: By applying the RG data constructor to any RandomGen instance
22:45:52 <ivanm> *nod* thought so, just wanted to check
22:45:57 <Cale> adu: yeah, it's a bit awkward
22:46:12 <Cale> adu: Which is another reason why the GADT syntax is nicer :)
22:47:07 <adu> and I never understood how not being false for all elements makes one of them true
22:47:08 <Myoma> my biggest complaint with data is that the declarations don't make any sense in isolation
22:47:37 <adu> but it looks pretty
22:47:40 <Myoma> i.e. data Foo a = Bar (a -> a)
22:47:41 <Cale> adu: I think that's fairly natural :)
22:47:45 <Myoma> Bar (a -> a) doesn't make any sense
22:47:53 <ivanm> OK, I've got Data.Set imported qualified as Set...
22:48:14 <ivanm> but when I put in that RandomGen RG instance, ghci complains that it could be Set.Split _or_ the random split :s
22:48:30 <Cale> ....
22:48:30 <ivanm> ummmm, if it isn't qualified why would it think it's Set.split?
22:48:40 <Cale> I can't think of a good reason...
22:49:27 <ivanm> to have a qualified import, it's just "import Data.Set as Set", isn't it?
22:49:31 <Cale> no
22:49:35 <ivanm> oh :(
22:49:40 <Cale> import qualified Data.Set as Set
22:49:48 <Cale> and you'll probably also want
22:49:52 <Cale> import Data.Set (Set)
22:50:02 <Cale> (just so you don't have to type Set.Set in types)
22:50:12 <ivanm> ahhh, k
22:50:44 <Myoma> adu: Not (None (x:y:z)) = Not (No x `And` No y `And` No z) = Not (No x) `Or` Not (No y) `Or` Not (No z)
22:51:09 <adu> lol
22:51:38 <Myoma> should have written [x,y,z]
22:53:12 <adu> Cale, it hurts my brain to think about it, but when i write it out: ~(x forall y) = (y exists such that ~x) it makes my eyes happy, but my brain still hurts...
22:53:30 <Myoma> adu, that didn't help to see why not being false for all elements makes one of them true?
22:53:41 <Cale> adu: Are you more used to intuitionist logic for some reason?
22:53:47 <Myoma> (at least one of them)
22:53:51 <Cale> adu: Or just new to logic in general? :)
22:54:06 <adu> Cale: ya, I'm still fighting for tribools
22:54:07 <Cale> (I ask just because there are some people in here that are afraid of LEM :)
22:54:26 <adu> LEM?
22:54:34 <Cale> Law of Excluded Middle
22:54:37 * Myoma is afraid of valuations ...
22:54:56 <Cale> P or (not P)
22:55:03 <Pseudonym> I'm not afraid of LEM.  I kick sand in its face.
22:55:09 <adu> I'm afraid of PHP
22:56:26 <adu> Cale: its not so much that I'm afraid of it, but I feel like its not a very useful tool imho
22:57:05 <Myoma> @let value x () = x
22:57:06 <lambdabot> Defined.
22:57:11 <Myoma> @let eval v = v ()
22:57:12 <lambdabot> Defined.
22:57:20 <Myoma> > eval ((+3) . (*2) . value 3)
22:57:21 <lambdabot>  9
22:57:23 <Cale> I think the fundamental reason why one might have trouble with the idea that if something is not false for all x then there exists an x such that it is true is the way that you think of truth. There are definitely cases where it's difficult, or even impossible to find a particular x for which one can prove the proposition in such a case.
22:57:38 <Cale> But classical logic hands you one anyway.
22:58:52 <Myoma> not (and [not x,not y,not z]) = not (not x && not y && not z) = not (not x) || not (not y) || not (not z) = or [x,y,z]
22:59:17 <Cale> You say "Oh, I can show that it's not the case that the proposition fails for every x" and it says "Here you go, have an x where it succeeds then". Which is quite intuitive for finite cases, but not necessarily intuitive over infinite domains.
22:59:42 <adu> ya, but i realize that all modern logic is based on it, so I suppose I primarily believe that because of my spiritual beliefs, because it feels good to "see" that truth is so much more than "not false"
22:59:43 <Cale> (where you could possibly never finish looking for that x which it so conveniently hands you)
23:00:07 <Myoma> all modern logic is not based on it
23:00:41 <Cale> Well, almost all modern mathematics is based on classical logic...
23:00:46 <Pseudonym> It's the same as the problem with the Axiom of Choice.
23:00:58 <Pseudonym> For finite sets, it's obvious.
23:01:01 <Cale> In fact, if you don't accept AoC, you're considered a bit of a heretic even. :)
23:01:23 <Cale> But that's okay, it just means it's more awkward to communicate results. :)
23:01:40 <adu> lol, and never finishing is bad
23:02:04 <Cale> Right, but maybe you don't care about the particular example.
23:03:33 <Pseudonym> I think it's a programmer thing, too.
23:03:39 <adu> I'm definitely not the one to talk, because the only proof I've ever written was sketchy and statistical, maybe I should look into the axiom of choice...
23:03:39 <Cale> Yeah.
23:03:45 <Pseudonym> The AC says "well, there is one".  And you say "yes, but what _is_ it?"
23:03:56 <Pseudonym> Same with the LEM.
23:04:32 <matt_estes> just caught the end of this, is LEM = Law of Excluded Middle?
23:04:35 <Cale> yeah
23:04:40 <adu> you know what I like better than LEM? p-norms!
23:04:45 <Pseudonym> And, of course, Komolgorov and Chaitin say "well, there is one, but I hope you have a long time to wait for it".
23:05:19 <Cale> Global well ordering is more fun than AC, and not too much stronger :)
23:05:47 <adu> oops, I meant T-norms
23:08:57 <allbery_b> sjanssen: sure
23:09:16 <allbery_b> @seen sjanssen
23:09:16 <lambdabot> sjanssen is in #xmonad and #haskell. I last heard sjanssen speak 50m 27s ago.
23:09:29 <allbery_b> @tell sjanssen re quote:  sure
23:09:29 <lambdabot> Consider it noted.
23:10:25 <adu> but anyways, I think T-norms also suck sometimes, because you have to choose between continuity and idempodancy
23:19:41 <crutcher> I've been kicking about with constuctors, and was wondering if anyone else found it odd that you can't use pattern syntax for fields.
23:21:10 <crutcher> something like: data Foo (a, b) [x] = Foo { p@(a,b) :: (a, b), xs :: [x] }
23:21:17 <adu> crutcher: you mean you can't use func (Maybe (Left x)) = ...?
23:21:31 <adu> or Just
23:21:31 <adu> oops
23:21:39 * adu needs sleep
23:21:44 <crutcher> no, not functions, constructors
23:22:28 <Myoma> crutcher: I have no idea what that could mean
23:22:45 <Pseudonym> http://arxiv.org/abs/0808.2953 <- Anyone read this yet?
23:23:07 <crutcher> Well, it would give you access to the subfields without having to write an accessor, which is what the whole field syntax is for anyway.
23:23:56 <Cale> Pseudonym: not me, but it looks fun
23:24:05 <Cale> Pseudonym: It was only posted a couple days ago...
23:24:10 <Pseudonym> Yeah.
23:24:23 <adu> crutcher: nope, but I would like to use ({x = y}) instead of (\z -> z {x = y})
23:25:37 <crutcher> ooh. that'd be nice
23:25:45 <opqdonut> ?where fref
23:25:45 <lambdabot> I know nothing about fref.
23:25:51 <opqdonut> ?where functional references
23:25:52 <lambdabot> I know nothing about functional.
23:26:22 <opqdonut> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
23:26:24 <opqdonut> look that up
23:26:33 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
23:27:02 <ivanm> what would be the best way of performing an operation (a->a) n number of times? iterate and then !!n ?
23:28:07 <dibblego> wtf is with reddit?
23:28:19 <Myoma> foldn zero succ 0 = zero ; foldn zero succ (n+1) = succ (foldn zero succ n) ; dotimes f n = foldn id (f .) n
23:28:19 <ivanm> dibblego: in what way?
23:28:32 <dibblego> ivanm, take a look at the front page
23:28:56 <ivanm> Myoma: if that was for me, I didn't particularly want to use church numerals :p
23:29:10 <Myoma> ivanm: This is not church numerals
23:29:38 <ivanm> oh, wait, I take it back...
23:30:04 <Myoma> churchify zero succ n = foldn zero succ n
23:30:25 <ivanm> I did too much of that kind of stuff with a supervisor of mine on a project of mine, where that was his definition of a list (something like that anyway...) :s
23:32:43 <Myoma> dotimes f n x = foldn x f n -- is better actually
23:33:36 <crutcher> adu: I like that idea ({x=y}), but I worry about: data X a = X { x = a }; does 'X {x=1}' mean ' X 1' or 'X ({x=1} :: a b -> a c)'?
23:35:42 <adu> crutcher: the former obviously
23:35:56 <Cale> A possibly better idea is to have each field name refer to a tuple of functions which act on that field in a record.
23:36:12 <Cale> (and then one can define a bunch of extractors with appropriate names)
23:36:22 <adu> crutcher: it would have to be a special case like [|...|] that is keyed of the ({...}) pair or something
23:36:36 <Cale> (which is basically what the 'overloading functional references' thing does)
23:36:46 <adu> o
23:36:48 <adu> n/m
23:36:51 <crutcher> hey, what's [|...|]?
23:36:58 <adu> crutcher: template haskell
23:37:38 <Cale> It's a kind of quoting used in TH which turns Haskell expressions into syntax trees for use in TH.
23:37:42 <adu> iirc, those brackets reify an expression
23:38:53 <quicksilver> lens / frefs are a better solution than more magic.
23:39:07 <quicksilver> adding new syntactical forms to the language results in non-compositional features.
23:39:27 <quicksilver> you want something 'first-class' : i.e. something which is a haskell function and can be composed, passed around, etc.
23:39:46 <Cale> I want a combination of that with a real record system
23:39:59 <adu> i want first-class types
23:40:07 <quicksilver> I don't disagree but I think they're separate issues Cale
23:40:12 <quicksilver> one can solve one without the other.
23:40:17 <Cale> Well, at least to some extent, yes.
23:40:35 <Cale> I think lenses are almost necessary to have a good syntax for proper records.
23:40:47 <Cale> But certainly we could add lenses to the existing algebraic types :)
23:41:09 <ivanm> dibblego: still not seeing what you're talking about...
23:41:20 <ivanm> then again, I don't look at reddit's main page normally ;-)
23:41:22 <adu> modifyIORef ref (\r -> r {x = y}) is kind of distracting
23:42:01 <ivanm> Myoma: so there's no inbuilt function?
23:42:02 <Cale> I wish I knew someone who knew the internals of GHC really well and who had lots of free time ;)
23:42:20 <adu> Cale: I have free time :)
23:42:44 <Cale> I think one thing which is at least a minor problem is that row variables have a new kind.
23:43:12 <Cale> But that's not *so* bad... maybe :)
23:43:44 <Cale> The type equality stuff will probably help things along.
23:44:12 <Cale> I don't understand well enough how data actually ends up being represented in the intermediate language.
23:44:36 <adu> Cale: do you mean hc?
23:44:50 <Cale> Core?
23:45:12 <Cale> Oh, the type equality bits?
23:45:20 <Cale> I'm not sure what formal system they ended up with :)
23:45:29 <adu> o
23:46:04 <Cale> I just know that we now have class-context-like things which look like (a ~ b) and assert that a and b are the same type.
23:47:11 <adu> if types were first class, then we wouldn't need type classes anymore...
23:47:23 <Cale> hmm
23:47:23 <Myoma> you would still want them
23:47:32 <Myoma> but you could implement them in the languge
23:47:48 <adu> Myoma: right, but they'd be implemented with quickcheck instead, lol
23:47:58 <Cale> quickcheck?
23:48:49 <adu> i thought it was funny...
23:49:05 <Cale> It is sort of funny... :)
23:50:12 <adu> I have put a great deal of thought into how to make (::) into a first-class function as well, but very little progress...
23:50:57 <Cale> I'm not sure how first class types lead to typeclasses being implementable... how would instance selection and such work?
23:51:26 <ivanm> Myoma: what's wrong with this? lambdabot keeps complaining :s
23:51:28 <ivanm> > let foldn zero succ 0 = zero; foldn zero succ (n+1) = succ (foldn zero succ n); doTimes n f x = foldn x f n in doTimes 5 succ 0
23:51:28 <lambdabot>  Parse error in pattern at ";" (column 79)
23:51:31 <Cale> Typeclasses have a lot of funny things going on at the value level :)
23:51:58 <Cale> ivanm: no n+k patterns
23:52:03 <adu> Cale: I would imagine something like case (typeOf x) of Int -> ... ; Char -> ...
23:52:17 <ivanm> Cale: ahhhh
23:52:18 <Cale> > let foldn zero succ 0 = zero; foldn zero succ n = succ (foldn zero succ (n-1)); doTimes n f x = foldn x f n in doTimes 5 succ 0
23:52:20 <lambdabot>  5
23:52:26 <ivanm> *nod*
23:52:48 <Cale> adu: That's sort of a closed analogue of typeclasses then.
23:53:00 <ivanm> I think using iterate might be a bit cleaner... though using foldN lets you avoid creating the intermediate list I suppose...
23:53:03 <Cale> It's not easy to add new instances in future modules.
23:53:09 <Myoma> ivanm: No iterate is not cleaner
23:53:23 <Myoma> doTimes n f x = foldn x f n
23:53:30 <adu> Cale: true, you're right
23:53:32 <Myoma> doTimes n f x = iterate f x !! n
23:53:45 <ivanm> Myoma: than defining another function?
23:54:16 <Myoma> ivanm: If you are doing functional programming ...
23:54:30 <Myoma> ivanm: You shouldn't see defining a new function as a dirty horrible habit
23:54:36 <Cale> heh
23:54:37 <ivanm> heh, I don't
23:55:04 <ivanm> but on the other hand, creating one just as a utility function when there's another one already defined that does something similar... *shrug*
23:55:19 <Cale> However, you do have to watch out about strictness for large values of n
23:55:28 <Cale> (possibly in any case)
23:55:30 <ivanm> Cale: for iterate?
23:55:33 <Cale> yeah
23:55:39 <ivanm> hmmmmmm.....
23:55:39 <Cale> For iterate in particular.
23:55:52 <ivanm> *sigh* fine, I'll implement Myoma's foldN function
23:55:53 <Cale> Because walking down the list doesn't evaluate the f's
23:55:56 <ivanm> :p
23:55:58 <Myoma> You're also creating and iterating down a list for absolutely no reason
23:56:10 <Cale> so you'll end up with a huge chain of applications of f at the end
23:56:20 <ivanm> ahhh
23:56:26 <Cale> If your values of n are sufficiently large, that could be a problem regarding the stack :)
23:56:30 <Myoma> it's not that its slower I dislike, it's that there is all this bizarre behavior which isn't directly related to what you are doing
23:56:35 <Cale> (and if f is strict)
23:56:36 <ivanm> which is exactly what foldN is doing anyway though, isn't it?
23:56:47 <ivanm> Myoma: "bizarre behaviour"?
23:56:49 <Myoma> ivanm: Since haskell is lazy, yeah pretty much
23:56:53 <Myoma> ivanm: You're also creating and iterating down a list for absolutely no reason
23:57:01 <Cale> lists are loops!
23:57:02 <adu> gnight
23:57:03 <Cale> hehe
23:57:29 <ivanm> Cale: I thought that the lists were the iteration constructs, not the loops themselves...
23:57:31 <Myoma> True, lists are loops but data Nat = Z | S Nat are loops to
23:57:32 <ivanm> the _fold_ is the loop...
23:57:38 <Cale> ivanm: well, okay :)
23:58:27 <Cale> I wonder if iterate f x !! n will strictness analyse nicely when f is obviously strict...
23:58:30 <ivanm> I did a project with one of the few FP people at UQ last year, helping to prove his Totally Functional Programming idea where you completely get rid of data and just use functions...
23:58:40 <ivanm> at the end of it, I didn't end up minding using intermediate data as much :p
23:58:44 <Myoma> ivanm: In an untyped setting?
23:58:50 <Cale> Well, that's rather like the lambda calculus.
23:58:52 <ivanm> Myoma: nope
23:59:03 <ivanm> @go "Totally Functional Programming"
23:59:16 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
23:59:18 <Myoma> ivanm: can you do coinductive values, like infinite lists?
23:59:19 <ivanm> pseudo-haskell, except that in a lot of cases the advanced stuff wouldn't typecheck (needs rank-n types IIRC)
23:59:36 <Cale> hmm, that's an unfortunate error message
23:59:36 <ivanm> Myoma: don't think he'd gotten that far...
