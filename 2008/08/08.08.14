00:00:02 <lowki_> nm i found it :)
00:00:13 <lowki_> yep the user list is surprisingly short
00:02:08 <dons> well, its 200 or so people now, isn't it?
00:02:33 <dons> 254
00:02:54 <dons> that's a pretty decent community of library writers.
00:03:02 <lowki_> yea
00:03:06 <lowki_> that is true
00:03:12 <lowki_> quite decent
00:03:20 <dons> a big company. i wonder if there are 250 people writing java libraries at Sun?
00:03:32 <dons> hmm. i should blog about that figure at some point.
00:03:48 <lowki_> where is your blog at?
00:03:50 <lispy> mmorrow: I didn't make it to bed yet and I just saw the link.  Thanks!
00:03:53 <dons> 250 authors, 600 libraries.
00:03:55 <lispy> mmorrow: nice example
00:04:00 <orz1> if i return (x,y,z) from a function and only make use of x in teh caller, will y and z be evaluated anyway?
00:04:06 <dons> lowki_: www.cse.unsw.edu.au/~dons/blog
00:04:15 <dons> orz1: nope.
00:04:34 * lispy has been meaning to blog about the law of demeter and what it means for write good haskell code
00:04:48 <dons> > snd $ (\z -> return (undefined, z + 7) 8
00:04:49 <lambdabot> Unbalanced parentheses
00:04:54 <dons> > snd $ (\z -> return (undefined, z + 7)) 8
00:04:55 <lambdabot>   add an instance declaration for (Monad ((,) a))
00:04:55 <lambdabot>     In the expression: retu...
00:05:03 <dons> > snd $ (\z -> (undefined, z + 7)) 8
00:05:04 <lambdabot>  15
00:05:10 <lispy> although, I haven't done a thorough analysis, it seems that darcs code likes to violate demeter and I think it makes it harder to refactor the code!
00:05:11 <dons> > (\z -> (undefined, z + 7)) 8
00:05:12 <lambdabot>  (Exception: Prelude.undefined
00:05:31 <lowki_> i just use standard haskell functions none of the fancy stuff
00:05:33 <dons> poor Demeter. she probably doesn't like that.
00:05:42 <lispy> hehe
00:06:17 <lowki_> i tried getting fancy and using libraries but then i decided to rewrite everything in standalone functions
00:06:25 <dons> heh
00:06:30 <dons> libraries are fancy.
00:06:50 <lowki_> lots of icing on the haskell cake
00:06:58 <lispy> I look at this way, have you ever noticed how easily libraries solve problems they were designed for?
00:07:19 <lispy> So, why not write my application as a set of libraries?  then my app could solve it's problems easily...
00:07:33 <lowki_> i've had complications with a date library not showing properly
00:07:46 <lowki_> or at all but maybe i don't have the know how
00:07:50 <lispy> lowki_: I've had problems with dates that are no shows too
00:07:57 <lowki_> i just made a standalone function in approximation to the date
00:08:04 <lispy> lowki_: it can be frustrating after you're all dressed up, you brought flowers, etc
00:08:37 <lowki_> and the little flower that your supposed to squeeze to get the person in the eye with water doesn't work dang nag it
00:08:57 <lowki_> lol
00:09:00 <lowki_> :)
00:09:03 <lispy> mmorrow: there is a bug in your haskell.sty
00:09:08 <lispy> mmorrow: look at the monad instance
00:09:20 <lispy> mmorrow: notice how bind type sets
00:09:25 <lowki_> monads make me cry
00:09:38 <lowki_> :,(
00:09:54 <lowki_> i never got around to understanding them
00:09:57 <lispy> lowki_: you'll get used to them, they're too simple to remain confusing
00:10:32 <lowki_> i just always worked around monads and used standard functions
00:10:34 <mmorrow> lispy: heh, i guess that wasn't the one i fixed. i just pushed a patch to that repo though
00:10:43 <lowki_> i use the random library though i do admit
00:11:00 <mmorrow> i also put in a latex refcard in latex latexsheet.tex
00:11:09 <lispy> mmorrow: okay, much better
00:11:23 <mmorrow> i can't get latexsheet.tex to friggin render as a landscape though
00:11:35 <mmorrow> lispy: yeah
00:12:09 <mmorrow> lispy: if you wanna tweak the symbols to your tastes, here's a page with that's a nice reference
00:12:11 <mmorrow> http://web.ift.uib.no/Fysisk/Teori/KURS/WRK/TeX/symALL.html
00:12:23 <lambdabot> Title: Latex Math Symbols
00:12:36 <lispy> mmorrow: thanks
00:13:15 <mmorrow> no prob, that was a nice refresher for me also ;)
00:14:02 <lispy> mmorrow: a standard literate that I don't personally like, but is common in typeset haskell is ++ is changed to a line with two small vertical lines through it
00:14:13 <lispy> mmorrow: I don't knot the tex symbol, but you might decide to add it
00:14:30 <mmorrow> cool, thx
00:14:35 <lispy> mmorrow: the thing I really, really wish we could change is the font of type variables vs the rest of the font
00:14:58 <mmorrow> i think i'm gonna make two versions... one with stylized symbols, and one with real ascii syms
00:15:00 <lispy> mmorrow: I would like the type variables to be greek letters!
00:15:10 <lispy> yeah, that would be smart
00:15:12 <mmorrow> ahh, sweet!
00:15:27 <lispy> I would like for a, when it's a type variable only, to become alpha
00:15:39 <lispy> I have no idea how to do that without parsing the haskell and converting to tex
00:15:55 <lispy> well, \alpha I mean of course
00:15:59 <lispy> I should go to bed for real
00:16:03 <lispy> g'night
00:16:03 <mmorrow> i'll see what i can do with that. i've been doing a bit his haskell parsing lately, so i may be able to come up with something
00:16:06 <mmorrow> gnight
00:16:14 <mmorrow> s/his/with/
00:17:59 <pao> Hi all, I'm trying to use malloc on my Storage class instance bu I get undefined....
00:18:31 <pao> I've looked at the source and in fact it seems reasonable that it returns undefined
00:18:56 <pao> what seems strange is that it works with CTypes such as CInt...
00:21:16 <mmorrow> pao: you mean Storable instance?
00:21:20 <cjs> Hmm. When I use runhaskell with the -package-conf option, it gives me just "<interactive>:1:38: Not in scope: `main'". Without the option it works fine. Any thoughts on what's going wrong?
00:21:27 <cjs> This option works ok with ghci.
00:21:31 <pao> mmorrow: yes
00:21:49 <mmorrow> pao: could you maybe paste some code?
00:21:53 <mmorrow> @paste
00:21:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:21:58 <pao> yep
00:23:44 * mmorrow looks
00:23:49 <pao> http://hpaste.org/9609
00:24:10 <pao> mmorrow: please not that using mallocBytes directly works perfectly
00:24:14 <pao> *note
00:26:31 <mmorrow> pao: ok, i believe it's because the value passed to sizeOf isn't used, just it's type
00:27:34 <pao> mmorrow: the sizeOf used in my code or the sizoOf used in the source of malloc?
00:27:39 <mmorrow> so you can't have an instance (that works) of Storable where sizeOf depends of the value of x in sizeOf x ...  so, for example you should be able to do  sizeOf (undefined::MyType)  and have it work
00:28:02 <mmorrow> pao: malloc is using the sizeOf you defined in your instance of Storable
00:28:17 <pao> ah ok!
00:28:31 <mmorrow> so, malloc is passing (undefined::SvmNode)
00:28:33 <mmorrow> heh
00:28:59 <pao> so, the problem is the way I defined sizeOf for my instance right?
00:30:51 <mmorrow> yes
00:32:10 <mmorrow> wait, hmm
00:32:20 <pao> mmorrow: perfect... fixed
00:32:37 <mmorrow> ahh, good. i started to second-guess myself there for a sec :)
00:32:48 <pao> mmorrow: sizeOf _ = sizeOf (undefined :: CInt)  + sizeOf (undefined :: CDouble)
00:32:55 <mmorrow> nice.
00:33:25 <pao> mmorrow: thanks a lot
00:33:34 <mmorrow> no problem
00:37:32 <Dr_Zooix> Hey all !
00:38:14 <Dr_Zooix> I've got a little problem while coding a parser like in the tutorial "Write yourself a sheme in 48 hours"
00:38:32 <Dr_Zooix> Here are the source code and the errors: http://rafb.net/p/npZAxm23.html
00:38:38 <Dr_Zooix> Can you help me please.
00:39:49 <MarcWeber> Dr_Zooix: What happens if you rename your module to module Main where .. ?
00:40:00 <Dr_Zooix> I'll try
00:40:45 <Dr_Zooix> Omg you were right ! ;)
00:41:13 <MarcWeber> Dr_Zooix: Anywya, I never got this message for this small mistake :)
00:41:15 <Dr_Zooix> I'm a newbie, can you explain me the error. It works now.
00:41:53 <Vq^> it's almost certainly because the linker tries to use Main.main as the "start function"
00:42:18 <Dr_Zooix> Vq: Ok thanks.
00:42:42 <Zao> You can indicate in which module is the main one, or you could use --make
00:42:56 <Dr_Zooix> ok
00:43:19 <Zao> As a bonus, --make would find the parsec package for you as well.
00:44:21 <Dr_Zooix> Thank you ! Bye
00:46:54 <hackage> Uploaded to hackage: kbq-gu 0.1
00:46:54 <hackage> Uploaded to hackage: AvlTree 4.1
00:47:10 <Zao> Ah there, -main-is
01:07:23 <visof> can i write something like this | x `mod` n == 0 && y \= 1 where y = x /n  = something ?
01:11:52 <Zao> visof: You can hang the where at the usual place after the function body following the last case, I believe.
01:12:14 <visof> zao do it please
01:18:52 <Zao> visof: http://hpaste.org/9611
01:19:30 <visof> thanks
01:19:39 <trzkril> kann man "Hallo
01:19:39 <trzkril> ich habe frage von Übung dafür haben Sie noch Beratung oder Sprechstunde
01:19:39 <trzkril> ich bedanke mich schon jetzt ihre Antwort" einfach mit "ja" beantworten?
01:19:43 <trzkril> ups
01:19:49 <trzkril> focus...
01:19:49 <Zao> "Nein."
01:19:55 <trzkril> sorry
01:24:09 <jsnx> trzkril: what does that mean, exactly?
01:24:44 <jsnx> can one simply answer "" with yes?
01:24:56 <trzkril> yes
01:25:13 <jsnx> "i have a question over exercize such that..." and i don't understand the rest
01:25:16 <trzkril> but it was meant for another chanel
01:25:28 <trzkril> i don't either
01:25:42 <jsnx> trzkril: oh, got it
01:25:53 <trzkril> the author of this message seems to have some problems with the language
01:26:02 <jsnx> hehe
01:26:18 <trzkril> but i can still guess what he meant
01:26:23 <jsnx> oh?
01:27:21 <trzkril> now the limits of my english show off, hm
01:27:33 <jsnx> hehe
01:27:37 <jsnx> g'night all
01:34:43 <tehgeekmeister> i can't load hackage or hoogle right now, so i'll ask on here: is Data.Map good for large collections?
01:38:30 <solrize> well there's large and then there's large...
01:39:55 <tehgeekmeister> billions of elements, probably
01:40:00 <tehgeekmeister> at the least
01:46:16 <quicksilver> tehgeekmeister: billions of elements will require 100s of gigabytes of memory.
01:46:39 <quicksilver> although if you actually had 100s of gigabytes of memory access to individual elements would be reasonably fast.
01:46:40 <tehgeekmeister> quicksilver: fortunately i realized i was talking about the wrong thing after i said that
01:46:46 <quicksilver> phew.
01:46:54 <hackage> Uploaded to hackage: data-accessor-template 0.1.1
01:46:54 <hackage> Uploaded to hackage: data-accessor 0.1.1
01:47:00 <tehgeekmeister> the billions can stay on disk
01:47:08 <tehgeekmeister> it's more like hundred thousand at worst
01:48:25 <tehgeekmeister> if i can fit the hundred thousand in 300-500mb of ram, i'm good.  if not then i might have to consider using a database.
01:50:30 <quicksilver> > Data.Map.size $ Data.Map.fromList [(n,n) | n <- [1..100000]]
01:50:32 <lambdabot>   Not in scope: `Data.Map.fromList'
01:50:37 * quicksilver slaps lambdabot 
01:50:42 <quicksilver> :t M.fromList
01:50:43 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
01:50:52 <quicksilver> > M.size $ M.fromList [(n,n) | n <- [1..100000]]
01:50:54 <lambdabot>  100000
01:51:05 <quicksilver> tehgeekmeister: that runs in about 1 second on my machine, interpreted in ghci
01:51:14 <quicksilver> that's creating and counting a 100,000-elt map
01:51:22 <quicksilver> so I conclude that 100,000 elt maps are pretty feasible.
01:51:42 <tehgeekmeister> quicksilver: are you sure it's not just using constant memory and garbage collecting for you?
01:52:00 <quicksilver> Yes.
01:52:03 <tehgeekmeister> okay
01:52:08 <quicksilver> Maps are spine-strict.
01:52:20 <tehgeekmeister> then i should be fine
01:52:25 <tehgeekmeister> i'm glad i don't have to use a database
01:52:27 <tehgeekmeister> that'd be painful
01:52:31 <quicksilver> a million element map takes on the order of 8 seconds, interpreted.
01:52:57 <quicksilver> (2.90 secs, 1127649524 bytes)
01:53:04 <quicksilver> quicker the second time I ran it :)
01:54:06 <tehgeekmeister> nice, this might end up running a lot easier than i originally expected.
01:54:21 <jeeves__> The server at www.haskell.org is taking too long to respond.
01:54:24 <jeeves__> :(
01:56:49 <quicksilver> Cale: I thought lambdabot always had fully-qualified, but Data.Map doesn't work.
01:58:16 <trofimovich> @go lambdabot imports.h
01:58:32 <lambdabot> Plugin `search' failed with: thread killed
01:59:27 <trofimovich> http://code.haskell.org/lambdabot/imports.h
02:00:56 <yitz> @type Data.Map.size
02:00:58 <lambdabot> forall k a. M.Map k a -> Int
02:01:09 <yitz> @type Data.Map.fromList
02:01:10 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
02:01:25 <yitz> > Data.Map.size Data.Map.empty
02:01:26 <lambdabot>   Not in scope: `Data.Map.empty'
02:01:39 <yitz> > Data.Map.size undefined
02:01:40 <lambdabot>   Not in scope: `Data.Map.size'
02:02:28 <trofimovich> import qualified Data.Map as M
02:02:57 <yitz> interesting, it tries to infer the type of the argument before the function.
02:03:48 <yitz> @seen Cale
02:03:48 <lambdabot> Cale is in #japanese, #haskell-overflow, #ghc and #haskell. I last heard Cale speak 33m 48s ago.
02:04:07 <Peaker> #japanese?? :)
02:04:15 <yitz> quicksilver: he must have gone to sleep
02:04:17 <quicksilver> yitz: name lookup is a separate step from type inference, I think.
02:04:37 <quicksilver> yitz: one unscoped name anywhere in a file takes precedence over any type errors
02:05:11 <yitz> quicksilver: oh, yeah. then it's even more surprising that it looks up the argument first.
02:05:11 <quicksilver> trofimovich: I'm sure it used to import everything fully qualified
02:05:20 <quicksilver> trofimovich: (as well as with a short form)
02:05:24 <tehgeekmeister> i'm going to have a map from a word to a record type that holds absolute frequency of a word, sentence/article that each word occurs in, and offset where that can be found in the bzipped wikidump.  is there some efficient way i can find all the other words in a sentence from such a data type, without having to load each sentence off the disk?
02:05:54 <quicksilver> only if you added that to the record
02:06:00 <quicksilver> (with a co-occuring words field)
02:06:09 <tehgeekmeister> oh, that's a simple solution
02:06:10 <quicksilver> which would presumably be pretty expensive space-wise.
02:06:10 <yitz> @tell Cale lambdabot no longer recognizes Data.Map.* names, only M.*.
02:06:10 <lambdabot> Consider it noted.
02:06:21 <tehgeekmeister> oh
02:06:22 <tehgeekmeister> yeah
02:06:25 <tehgeekmeister> probably would
02:07:15 <tehgeekmeister> is there some other clever data structure you can think of off hand that'd help me here?
02:07:24 <yitz> tehgeekmeister: two maps
02:07:37 <tehgeekmeister> yitz: what would the second hold?
02:08:27 <yitz> sentence -> its words
02:08:58 <yitz> that's better than listing all the other words in the sentence for each word, which would be O(words^2)
02:09:15 <quicksilver> that is O(sentences)-sized map though
02:09:17 <besiria> haskell.org is down?
02:09:18 <tehgeekmeister> yitz: bear in mind this is for the entire french wikipedia
02:09:23 <quicksilver> and there are a lot of sentences in wikipedia :)
02:09:36 <tehgeekmeister> well, other languages later.  but french for now.
02:09:55 <trofimovich> quicksilver: according to darcs changes import.h it never did import FQN
02:10:06 <quicksilver> trofimovich: then the bug must be in quicksilver's brain.
02:10:11 <quicksilver> I wonder if there is a firmware update.
02:10:27 <elbar> haskell.org down 4ever or just broken?
02:10:39 <mfp> tehgeekmeister: are you writing a search engine? Do you want the rest of the sentence to perform phrase searching?
02:10:42 <besiria> elbar: y same here
02:11:35 <tehgeekmeister> mfp: no, i'm turning a foreign-language wikipedia into a graded reader.  i need to know what other words are in a sentence to rank how difficult it will be to read given what words are known at a given point.
02:11:57 <yitz> tehgeekmeister you are already O(words). because each sentence occurs once for each of the words that occurs in it.
02:12:17 <quicksilver> O(words) is much less than O(sentences), surely?
02:12:25 <tehgeekmeister> it certainly is
02:12:29 <quicksilver> there are about 20,000 words in the working set of a large language
02:12:37 <quicksilver> and there are millions of sentences in tehgeekmeister's corpus
02:12:47 <tehgeekmeister> there's not going to be more than 100,000 different forms, i'd guess
02:12:47 <yitz> quicksilver: no it is O(total_words), including repetitions
02:13:00 <tehgeekmeister> including misspellings and whatnot
02:13:19 <quicksilver> yitz: total memory, yes.
02:13:28 <rwbarton> an encyclopedia has a particularly large working set
02:13:29 <quicksilver> because each word record links to every sentence in which it occurs.
02:13:41 <quicksilver> rwbarton: yes, and it has all kinds of non-words too.
02:13:49 <yitz> so by adding the second map you are not change the O(), just multiplying by 2.
02:13:53 <quicksilver> abbreviations and jargon and wiki-stupidities.
02:15:14 <yitz> if that's not good enough, you need an efficient bi-map. didn't someone put something like that on hackage?
02:15:27 <trofimovich> @version
02:15:27 <lambdabot> lambdabot 4.1
02:15:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
02:16:22 <trofimovich> @type Data.Number.Symbolic
02:16:23 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
02:16:46 * tehgeekmeister thinks of other approaches
02:17:00 <trofimovich> @type CReal
02:17:01 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
02:17:09 <trofimovich> @kind CReal
02:17:10 <lambdabot> *
02:17:54 <quicksilver> tehgeekmeister: it does actually sound like a problem fairly well suited to a relational database.
02:17:59 <trofimovich> @package? Data.Number
02:18:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.Number
02:18:13 <yitz> @list
02:18:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:18:16 <tehgeekmeister> quicksilver: i know, but i was just trying to avoid that.  =P
02:18:51 <tehgeekmeister> if i had eight of ten gigabytes of ram to play with this would be trivial without a database
02:18:52 <yitz> quicksilver: google doesn't use a rdb, they do something specialized for this.
02:18:52 <tehgeekmeister> but i don't
02:19:08 <tehgeekmeister> *or
02:19:24 <quicksilver> yitz: yes, but google do very specific kinds of queries and have a special data structure optimised to that.
02:19:31 <yitz> otoh, google *does* have 8 or 10 GB of memory to play with
02:19:40 <quicksilver> tehgeekmeister could come up with a special optimised data structure too if he wanted.
02:19:46 <quicksilver> (could be bothered)
02:19:57 <quicksilver> I'm saying that a generalised indexing and searching toolkit might be simpler
02:20:02 <quicksilver> and that's what rdbs are.
02:20:24 <tehgeekmeister> if i had any brilliant idea for a datastructure that'd optimize this, i'd use it
02:20:29 <yitz> yeah, and they live on disk for better or for worse
02:20:40 <quicksilver> yitz: I suspect google nodes tend to have less than 8G of ram
02:20:56 <tehgeekmeister> but since i don't i'm probably going to end up using a database
02:20:57 <quicksilver> they're commmodity-class x86 boxes, and commodity class x86 boxes don't support > 2G generally.
02:20:59 <yitz> quicksilver: but they've got a few nodes
02:21:00 <tehgeekmeister> waiiiiiiit
02:21:13 <quicksilver> Yes. a few ;)
02:21:26 <tehgeekmeister> i can fit the entire bzipped wikidump in ram
02:21:47 <tehgeekmeister> then i can access it all i want cheaply
02:22:08 <quicksilver> random access to bz files isn't completely cheap.
02:22:20 <visof> to use "/" proberly", what should i do
02:22:34 <visof> i use it and  i have type error
02:22:39 <tehgeekmeister> oh, right, you have to decompress a whole block
02:22:40 <pozic> Who killed (or is killing) haskell.org?
02:22:46 <yitz> quicksilver: it's actually not too bad, because each sort chunk is the same size before huffman coding.
02:22:58 <quicksilver> visof: get your types right.
02:23:03 <quicksilver> > 1.0 / 4.0
02:23:05 <lambdabot>  0.25
02:23:07 <quicksilver> > 1 `div` 4
02:23:09 <lambdabot>  0
02:23:20 <quicksilver> visof: / is for floating, `div` for integral
02:23:31 <quicksilver> "fractional" not floating, I should say.
02:23:32 <visof> yeah
02:24:14 <Zao> visof: Note how I used div in my hpaste.
02:26:21 <visof> Zao `div won't work for me
02:26:28 <visof> i need "/"
02:26:50 <quicksilver> visof: we can't help you unless you tell us what you're doing.
02:26:59 <quicksilver> perhaps you need to convert some integers to doubles
02:27:03 <quicksilver> or perhaps the other way around
02:27:08 <visof> ok
02:28:14 <yitz> > fromIntegral 2 / fromIntegral 3
02:28:16 <lambdabot>  0.6666666666666666
02:28:45 <tehgeekmeister> quicksilver: there is a bidirectional map on hackage, i think that'd do what i need without having to use a full blown database, wouldn't it?
02:29:04 <quicksilver> I don't know because I don't know exactly what you're trying to do :)
02:29:09 <quicksilver> it would do some things, certainly.
02:29:11 <visof> quicksikv http://hpaste.org/9613
02:29:20 <yitz> tehgeekmeister: it might be just two maps, look at the implementation.
02:29:40 <visof> i'm tring to implement sieve methnod for primes
02:30:02 <quicksilver> visof: why would you want floating point numbers when searching for primes?
02:30:08 <quicksilver> surely this is an integer algorithm.
02:30:09 <yitz> visof: so that has to do with only integers. why do you need '/'
02:30:20 <visof> first this remove multiples of n
02:30:20 <rwbarton> visof: how about simply  x `mod` n == 0 && x /= n
02:30:43 <visof> this function so this
02:31:09 <visof> removes multiples except the base number
02:31:20 <tehgeekmeister> yitz: yep, that's what it is.
02:31:36 <tehgeekmeister> data Bimap a b = MkBimap !(M.Map a b) !(M.Map b a)
02:31:39 <visof> removes multiples of 2 but not remove 2
02:32:02 <yitz> tehgeekmeister: so you can design a more clever bimap, post it to hackage, and become famous
02:32:35 <tehgeekmeister> yitz: i'd rather just solve my problem, make my graded reader, learn french, and potentially become famous for the graded reader.  but i'll be happy just to know more french.  =P
02:34:12 <yitz> tehgeekmeister peut-être il s'éxiste #french?
02:35:52 <BeelsebobWork> is there any way (without just trawling the haddocks) that I can find out which of two operators has higher precidence?
02:36:00 <BeelsebobWork> (in this case, which of (.) and (<$>)
02:36:08 <tehgeekmeister> yitz: oui, mais je veux apprendre les mots tres rare au fin de pouvoir lire des livres classiques, commes les miserables
02:36:20 <quicksilver> BeelsebobWork: :i in ghci?
02:36:27 * tehgeekmeister wonders how badly he mangled his french
02:36:37 * yitz aussi
02:36:46 <BeelsebobWork> oh, cheers quicksilver -- I don't remember it doing that -- is that new?
02:36:53 <quicksilver> BeelsebobWork: no ;)
02:38:13 <osfameron> how was anglohaskell?  I didn't see writeups
02:38:50 <visof> is there a way to do this removeM ( removeM ( removeM [2..10] 2) 3) 5 ?
02:39:12 <quicksilver> that's what fold is for
02:39:23 <visof> how
02:39:24 <visof> ?
02:39:26 <quicksilver> foldr removeM [2..10] [2,3,5]
02:39:34 <visof> wow
02:39:41 <BeelsebobWork> @pl (\x -> listArray (0,fromIntegral (length x - 1)) x)
02:39:41 <lambdabot> listArray =<< (,) 0 . fromIntegral . subtract 1 . length
02:39:50 <quicksilver> actually it was a left fold as you wrote it.
02:40:05 <quicksilver> foldl removeM [2..10] [2,3,5]
02:40:06 <BeelsebobWork> hmm, that's not bad actualy
02:40:08 <BeelsebobWork> other than the bind
02:40:08 <rwbarton> > foldl f a [x, y, z]
02:40:10 <lambdabot>  f (f (f a x) y) z
02:40:56 <visof> it doesn't work
02:41:09 <quicksilver> that phrase is illegal in this channel.
02:41:15 <quicksilver> It is not permitted to say "it doesn't work"
02:41:27 <visof> sorry
02:41:37 <pozic> it doesn't work
02:41:39 <quicksilver> @remember quicksilver NEVER say "it doesn't work". hpaste your code and the error message, give more details, otherwise we can't help you.
02:41:40 <lambdabot> I will remember.
02:42:02 <pozic> It's still permitted.
02:42:06 --- mode: ChanServ set +o quicksilver
02:42:13 --- kick: pozic was kicked by quicksilver (permitted? I think not.)
02:42:16 <BeelsebobWork> lol
02:42:36 <quicksilver> ;)
02:43:02 <pozic> Very funny.
02:43:23 <pozic> Who made you @?
02:43:34 --- mode: quicksilver set -o quicksilver
02:43:37 <quicksilver> ChanServ.
02:44:10 <visof> http://hpaste.org/9614
02:44:31 <quicksilver> visof: yeah, I made a mistake in my first attempt ;)
02:44:36 <quicksilver> visof: it's a left fold not a right fold
02:44:40 <quicksilver> so 'foldl' not foldr'
02:44:42 <visof> ok
02:46:25 <yitz> @type foldl
02:46:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:46:31 <yitz> @type foldr
02:46:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:46:55 <hackage> Uploaded to hackage: protocol-buffers 0.1.0
02:47:08 <pozic> quicksilver: where did you get the permission to do that?
02:47:21 <pozic> quicksilver: shapr?
02:47:31 <quicksilver> I don't recall.
02:47:33 <quicksilver> Does it matter?
02:47:53 <Esteth> Am I the only one for whom the haskell.org site is down for?
02:47:53 <quicksilver> In fact, I'm not even sure if I know. I don't think ChanServ tells you who put you on the access list.
02:47:59 <quicksilver> Esteth: no, the server appears to be dead.
02:48:23 <pozic> Or Haskell is very popular... nah... ;)
02:48:23 <yitz> pozic: quicksilver tends to be around here a lot, so it's good for quicksilver to be an @. just in case of trouble, you know.
02:48:27 <Esteth> quicksilver: I'm not sure wether to be happy that it's a local problem, or sad that the server is dead. Thanks anyway
02:48:41 <quicksilver> it probably won't persist for too long
02:48:45 <quicksilver> but that server is in the US
02:48:50 <quicksilver> and lazy americans sleep, sometimes :(
02:48:57 <Esteth> silly americanfaces
02:49:08 <pozic> Maybe the Russians bombed the server?
02:49:35 <Esteth> In soviet russia, servers bomb you!
02:49:40 <Esteth> Sorry, couldn't resist.
02:50:00 <yitz> pozic: they're peeved about support for Georgia, so they took out the US's most valuable asset, haskell.org.
02:51:28 <pozic> yitz: that must be it! We are on to something here.
02:51:38 <yitz> @faq Can Haskell determine the outcome of a war?
02:51:39 <lambdabot> The answer is: Yes! Haskell can do that.
02:54:23 <mornfall> Hi. Anyone could hint me if there's a way to get at the flag values from cabal in the actual source? Maybe other than through CPP...
02:55:50 <mornfall> www.haskell.org refuses me again...
02:58:08 <visof> can i did something like this foldl removeM [2..100] [2..sqrt(100)]
02:58:22 <visof> but i want to convert sqrt to int
02:58:27 <visof> can i ?
02:59:20 <EvilTerran> (\n -> takeWhile ((<n).(^2)) [0..]) is the way i usually write integer square root
02:59:34 <EvilTerran> er, wait
02:59:35 <eu-prleu-peupeu> is haskell.org down ?
03:00:32 <EvilTerran> (\n -> head $ dropWhile ((<=n).(^2).(+1)) [0..])
03:00:41 <EvilTerran> somerthing like that. work out the off-by-ones yourself :P
03:00:54 <quicksilver> eu-prleu-peupeu: yes.
03:01:04 <quicksilver> visof: round (sqrt 100)
03:01:16 <Esteth> do we have an op who can put haskell.org being down in the topic perhaps?
03:01:29 * quicksilver wonders if there is room.
03:01:31 --- mode: ChanServ set +o quicksilver
03:01:37 <EvilTerran> quicksilver, but... gratuitous floating point =/
03:01:58 <mornfall> quicksilver: replace the haskell.org link ; - )
03:02:09 * EvilTerran remembers what he meant
03:02:27 <visof> wewe
03:02:29 <visof> work
03:02:42 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org (down 14th Aug, admins notified)", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]]' by quicksilver
03:02:42 <visof> thanks quicksilv
03:02:47 <yitz> EvilTerran: takeWhile((==0).(`mod`2)).iterate(`div`2)
03:02:47 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org (down 14th Aug, admins notified)", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by quicksilver
03:02:51 <EvilTerran> [0..floor (sqrt n)] = takeWhile ((<=n).(^2)) [0..]
03:02:59 <EvilTerran> that's what i was after!
03:03:14 <quicksilver> EvilTerran: true enough but I think visof needed to learn about round ;)
03:03:24 <quicksilver> EvilTerran: because he was having trouble with floating/int conversions.
03:03:32 <quicksilver> (1) learn about round (2) learn when not to use it. ;)
03:03:35 --- mode: quicksilver set -o quicksilver
03:04:09 <EvilTerran> i prefer (1) learn how to use exact arithmetic for everything it can be used for (2) learn what to use when exact arithmetic just won't work
03:04:42 <visof> i have : Exception: stack overflow
03:04:47 <visof> what this mean ?
03:05:14 <yitz> quicksilver: now you've done it. you'll have to explain foldl'. :)
03:05:40 <quicksilver> visof: it means you built a thunk which was too deep and the stack overflowed when evaluating it.
03:06:02 <visof> i can't understand too
03:06:09 <quicksilver> visof: foldl' -- with a apostrophe -- may solve it.
03:06:12 <visof> is there simpler than this
03:06:22 <EvilTerran> thunks! overflows! apostrophes! oh my!
03:06:34 <visof> ok
03:06:49 <yitz> visof: import Data.List -- brings foldl' into scope, among many other things
03:08:30 <osfameron> oooo! http://pubs.doc.ic.ac.uk/clase-cursor-library/ looks shiny
03:08:39 * osfameron adds it to his list of links on text editor implementations
03:09:04 <visof> yitz i put "import Data.List" in the file i define my functions
03:09:14 <visof> and load it from ghci
03:09:33 <visof> and i have "fold' not in scope"
03:09:47 <trofimovich> ghci can handle import?
03:09:48 <yitz> visof: foldl'
03:10:01 <visof> yeah
03:10:35 <visof> *Main>  foldl' removeM [2..600851475143] [2..(round (sqrt 600851475143))]
03:10:36 <visof> <interactive>:1:0: Not in scope: `foldl''
03:11:00 <yitz> visof: :r
03:11:07 <visof> what?
03:11:13 <yitz> reload your file
03:11:26 <yitz> (make sure you saved it)
03:13:12 <visof> yeah
03:13:20 <visof> it is working
03:13:23 <visof> thanks
03:13:33 <yitz> visof: good!
03:13:44 <visof> but what is the difference between foldl' and fold ?
03:13:59 <visof> the solution is so slow too
03:14:02 <Deewiant> fold is in Data.Foldable and is a class method, foldl
03:14:06 <Deewiant> ' is in Data.List and isn't.
03:14:22 <yitz> Deewiant: that's not what visof meant.
03:14:29 <visof> sorry c/fold/foldl
03:14:31 <Deewiant> yes, I know. I'm just being a jerk. :-P
03:14:48 <Deewiant> @src foldl
03:14:48 <lambdabot> foldl f z []     = z
03:14:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:14:49 <Deewiant> @src foldl'
03:14:49 <lambdabot> foldl' f a []     = a
03:14:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:15:01 <Deewiant> that's the difference.
03:16:21 <yitz> visof: Haskell is very lazy. Usually that is good. But when you do foldl, it delays every calculation as it iterates through your list. that fills up the stack after a while. foldl' says don't be so lazy  on each iteration.
03:16:38 <jaj> haskell.org seems to be down
03:16:50 <visof> is my solution very very bad ?
03:16:52 <yitz> jaj: look at the new channel topic
03:17:13 <jaj> yitz: oh right sorry :)
03:19:08 <DRMacIver> Is americanhellyeah on reddit a parody by someone in here? I'm having a hard time believing that he's real. :)
03:19:31 <yitz> DRMacIver: url?
03:19:55 <DRMacIver> http://www.reddit.com/user/americanhellyeah/
03:19:57 <dons> DRMacIver: reddit is all parody
03:20:27 <DRMacIver> dons: Yeah, but with a name like that and the attitude he routinely shows I can't quite believe he's the normal calibre of parody. :)
03:21:11 <visof> *Main> last $ foldl' removeM [2..100000] [2..(round (sqrt 100000))]
03:21:12 <visof> 97151
03:21:21 <visof> it's a slow
03:21:48 <visof> is this due to my implementation or the language itself ?
03:21:50 <DRMacIver> Hm. I see his parody extends outside the progamming reddit. I guess not
03:22:42 <dons> visof: what does removeM do?
03:23:13 <visof> remove multiples of the number n but don't remove the number itself
03:23:34 <quicksilver> visof: well you are running in an interpreter.
03:23:41 <quicksilver> visof: you will find it quite a bit faster if you compile :)
03:23:45 <dons> oh, you're running in ghci?
03:23:45 <dons> hehe
03:23:47 <quicksilver> (with optimisation on)
03:23:50 <visof> yeah
03:23:55 <dons> yeah, ghc -O2 A.hs please :)
03:23:57 <dons> then complain.
03:24:00 <visof> what is the wrong?
03:24:12 <dons> hint, lists aren't good for big "array" like operations.
03:24:14 <pozic> dons: the compile time is too long ;)
03:24:26 <dons> well, you only have to pay that once.
03:24:37 <dons> it's good to know ghc does the hard thinking for you, turning math into code.
03:25:40 <hask> Anyone good with profiling?
03:25:57 <dons> fire up ghc -O2 -prof -auto-all
03:26:01 <dons> run your code with +RTS -p
03:26:04 <pozic> Some computations take too long to run without -02, so you still need to wait for the compiler. Take a AAA game for example (then again, they have the same problems).
03:26:04 <hask> I am parsing a huge amount of files, some very big
03:26:10 <hask> I know how
03:26:14 <dons> hask, with bytestrings?
03:26:17 <dons> or parsing with Strings?
03:26:29 <hask> I want to find out if it is laziness/GC or algorithm
03:26:30 <hask> best options?
03:26:41 <dons> look at what's allocating in the .prof file
03:26:51 <dons> that'll tell you if GC is busy, if something's doing too much work.
03:26:55 <hask> parsing with strings
03:27:01 <dons> if laziness is an overhead, you'll see more memory tarffic
03:27:03 <dons> oh.
03:27:07 <dons> how big are the files?
03:27:55 <hask> 17000, between 3kb and 1MB
03:27:55 <dons> if they're bigger than say, 10k or so, you're only option is to use bytestrings. you might even see a few orders of magnitude better speed and memory use as well.
03:28:12 <hask> ok thanks I will look into that
03:28:15 <dons> use bytestrings then. they're as fast as C, and pretty much as easy as strings.
03:28:24 <dons> expect good results.
03:28:42 <rwbarton> hask: You can run with +RTS -sstderr and get some stats on the GC
03:29:08 <dons> well, i think we know what the problem is without doing that :)
03:29:26 <dons> a 1MB String is going to have high memory overhead.
03:29:31 <rwbarton> Yes, certainly
03:30:56 <hask> ok thanks for the advice, very good
03:31:32 <dons> got it working already?
03:33:20 <lomeo> hello! what happens with haskell.org? it doesn't work...
03:33:27 <quicksilver> yup, it's dead.
03:33:32 <quicksilver> fixed soon we hope :)
03:34:22 <lomeo> ok, thank )
03:34:48 <dons> something wrong at yale.
03:35:14 <visof> dons i have file with some functions, what should i do to make it about to be compiled ?
03:35:35 <dons> give it a 'main' function
03:35:39 <dons> and compile with ghc -O2 --make
03:37:11 <visof> dons http://hpaste.org/9615
03:37:16 <visof> like this ?
03:39:14 <dons> ah no. http://hpaste.org/9615#a1
03:43:17 <dons> i'm enjoying this guy's posts,  http://www.reddit.com/comments/6waa1/logical_types_using_difference_lists_great_prolog/
03:43:39 <dons> haskell with a prolog flavour.
03:44:19 <visof> dons visof@localhost:~$ ghc -02 --make prime.hs
03:44:21 <visof> ghc-6.8.2: unrecognised flags: -02
03:44:46 <visof> oh
03:44:48 <visof> it )
03:44:53 <visof> )
03:44:54 <visof> O
03:45:05 <dons> -O2 :)
03:46:37 <trofimovich> Ou not zero
03:47:54 <visof> dons i ahave an error : prime.hs:10:16: parse error on input `='
03:47:58 <visof> have*
03:48:19 <povman> i'm wondering if it is actually possible to define memoise :: (a->b) -> a -> b
03:48:41 <povman> it'd need to use unsafePerformIO, but it'd need some kind of static variable
03:49:59 <therp> povman: you could use unsafePerformIO to create a global var.
03:50:17 <povman> oo... /me googles
03:50:39 <therp> but you don't need unsafePerformIO for memoized functions
03:51:15 <povman> therp: how?
03:51:26 <therp> http://74.125.39.104/search?q=cache:1RhML8XSKwcJ:www.haskell.org/haskellwiki/Memoization+memoize+haskell&hl=en&strip=1
03:51:33 <therp> (haskell.org seems down at the moment)
03:51:43 <therp> have a look at memoized_fib for instance
03:51:48 <povman> oh of course
03:51:53 <antirobo1robot> it seems haskell.org is down :(
03:52:14 <quicksilver> 'fraid so
03:52:21 <pozic> antirobo1robot: it seems you didn't read the topic.
03:52:22 * therp wonders why the world is still spinning with h.o down..
03:54:24 <povman> i don't understand how you can write memoize without unsafePerformIO. How else can you retain values between calls?
03:55:12 <therp> povman: that's an implicit side effect that does not violate referential transparency, namely thunk evaluation
03:55:57 <therp> you don't compute fib numbers, but you define a lazy list of all fib numbers in the universe and compute them on the fly
03:56:19 <antirobo1robot> is there a mirror where i can download ghc 6.8.2 ?
03:56:35 <antirobo1robot> googling is bringing up nothing
03:56:38 <visof> http://hpaste.org/9616
03:56:48 <visof> what is the wrong of this code please?
03:58:33 <subw> visof: ( before last has to be $
03:59:08 <ziman> or append a ) to the whole line
03:59:20 <visof> prit $ ( last $ ... ?
03:59:25 <visof> print*
03:59:32 <trofimovich> why `[] ++' is neede?
03:59:51 <subw> no, print $ last
03:59:59 <subw> or print (last ... )
04:00:04 <trofimovich> visof: unbalanced parens ()
04:00:39 <Twey> print . last $ ...
04:00:42 <Twey> Actually
04:01:23 <povman> therp: I'm talking about something like an annotation (like seq) which tells the compiler that this function should be memoised across all calls
04:01:31 <trofimovich> @src removeM
04:01:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:02:23 <therp> povman: use the memoizing fix point op
04:03:02 <visof>  main = print · last $ foldl' removeM [2..600851475143] [2..(round (sqrt 600851475143))] ?
04:03:34 <therp> povman: let me give you an example..
04:04:08 <povman> therp: thanks
04:04:56 <yitz> povman: usually, where in imperitive language you "memoize" - explicitly force the program to use a hardware device called "memory" - in a pure language you don't need to do that.
04:05:43 <visof> Twey doesn't work too ?
04:05:57 <Twey> visof: Then you did it wrong
04:06:28 <visof> main = print · last $ foldl' removeM [2..600851475143] [2..(round (sqrt 600851475143))] ?
04:06:31 <yitz> povman: instead, you arrange to pass along what you need to "remember" as an additional parameter to your functions. If you are writing monadically, you can do that transparently just by adding "State" to the return type of your function.
04:06:43 <visof> Twey is this wrong ?
04:07:00 <Twey> Uh, · should be .
04:07:18 <therp> spoiler warning. that's my solution to problem 15 of project euler using memoization. http://projecteuler.net/index.php?section=problems&id=15 solution http://hpaste.org/9617
04:07:39 <yitz> povman: but if you really, really need to explicitly force things into physical memory in a certain way - say, you are doing very heavy optimization - then you would refactor your code to be in the ST monad, or even the IO monad.
04:07:41 <therp> povman: I hope you can make sense of this :). it's a bit tricky stuff
04:09:12 <therp> memoFix is a knot-tying variant
04:09:39 <therp> the only slightly tricky thing is how to memoize tuples as curried version of function application
04:10:05 <povman> yitz: i want to memoise without needing to pass an extra reference around
04:10:11 <yitz> povman: so the bottom line is: the thing you are looking for isn't needed, it wouldn't be good style to use it even if you had it.
04:10:20 <yitz> povman: ok, use the State monad
04:10:32 <therp> yitz: that's not necessary. see above.
04:10:38 <rwbarton> povman: http://sigfpe.blogspot.com/2007/09/tries-and-their-derivatives_08.html has a good explanation, though it doesn't talk about the recursive case
04:10:52 <yitz> therp: that's not necessary. Just use the State monad.
04:10:59 <povman> hm
04:11:41 <povman> i must be thinking too imperitively
04:12:23 <povman> so there's no use in something like (memoise cos), assuming cos is a complicated function?
04:12:34 <therp> yitz: that's ugly if there's no reason for it.
04:12:54 <therp> (ugly to me)
04:13:03 <yitz> therp: exactly, it really is. Just use a State monad, which is simple and elegant.
04:13:13 <yitz> (to me) :)
04:13:14 <therp> state monad elegant? no way.
04:13:19 <yitz> therp sure
04:13:35 <therp> but ok you seem to have different concept of beauty than me.
04:13:50 <rwbarton> the State monad is fine in its own way, but this isn't the place for it
04:15:19 <yitz> it is a minimalistic and general way to abstract state dependencies out of functions. It's really easy to understand and use (if all you want is to use it, not to study its category theoretical origins)
04:15:37 <rwbarton> Well, it depends on the domain type.  If your domain is Double or something, the State approach is your only option
04:15:58 <povman> ah of course, memoise would need to execute in IO anyway
04:16:13 <povman> so passing the map around isn't a problem
04:16:23 <therp> povman: no. see my example.
04:16:23 <yitz> I have to admin, for euler problems I don't do either of those two. I just add a parameter, throw in a fold or two, and it's done.
04:16:38 <yitz> State has nothing special to do with Double.
04:16:45 <therp> povman: especially the type of "p15 :: (Int,Int) -> Int"
04:16:53 <hask> what is the "" or '' for bytestrings?
04:17:01 <wjt> @index empty
04:17:01 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive, Data.Graph.Inductive.Internal.Heap, Data.IntMap, Data.IntSet, Data.Map, Data.Set, Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.
04:17:02 <lambdabot> PrettyPrint
04:17:02 <hask> Couldn't match expected type `ByteString'
04:17:02 <hask>            against inferred type `[a]'
04:17:02 <hask>     In the pattern: []
04:17:09 <wjt> oh well.
04:17:33 <rwbarton> povman: yitz: simple memo example:  memo :: (Bool -> a) -> Bool -> a  ;  memo f = let x = (f True, f False) in \y -> if y then fst x else snd x
04:18:16 <povman> rwbarton: gotcha :)
04:18:34 <povman> the 'let' causes the compiler to share
04:19:12 <yitz> rwbarton: this is CPS. it also works, but it really obscures code when it starts getting complicated. State monad code reads intuitively.
04:19:20 <rwbarton> yitz: what!?
04:19:48 <therp> yitz: State is much more CPS than this
04:20:09 <yitz> your f is a continuation, in essence.
04:20:11 <rwbarton> yitz: You just write f like you normally would and then define memoizedF = memo f.
04:20:17 <rwbarton> No, f is the function I want to memozie
04:21:13 <rwbarton> memo is slightly complicated, and gets more complicated when I want to handle other domain types, but I only have to write it once
04:21:22 <hask> Ambiguous occurrence `splitAt'
04:21:22 <hask>     It could refer to either `Prelude.splitAt', imported from Prelude
04:21:22 <hask>                           or `Data.ByteString.splitAt', imported from Data.ByteString
04:21:22 <hask> wtf why are there conflicting names?
04:21:22 <hask> How do I solvethat?
04:21:44 <quicksilver> hask: ByteString is designed to be imported with a prefix.
04:21:55 <quicksilver> it reuses the names of corresponding prelude functions.
04:23:08 <povman> thanks everyone, that's insane but it makes sense
04:24:21 <therp> povman: if you want a challenge, try to write "instance Memoizable a => Memoizable [a]" :)
04:26:12 <therp> although that shouldn't be hard given the trick is already there with Memoizable (a,b)
04:27:07 <hask> I do "import Data.ByteString"
04:27:22 <hask> I have to write the type as Data.ByteString then?
04:27:51 <therp> add qualified
04:28:02 <yitz> hask: import qualified Data.ByteString as B
04:28:17 <yitz> then say B.splitAt
04:28:36 <yitz> or just splitAt for the regular Prelude one
04:30:08 <hask> Prelude> import qualified Data.ByteString as B
04:30:08 <hask> <interactive>:1:0: parse error on input `import'
04:30:20 <hask> only works in a module?
04:30:58 <EvilTerran> yes
04:31:09 <quicksilver> ghci only does expressions.
04:31:14 <quicksilver> there are lots of things it doesn't do
04:31:20 <quicksilver> data types, functions, imports, classes...
04:31:22 <EvilTerran> however, you can load modules into scope in ghci with different syntax
04:31:30 <EvilTerran> quicksilver, er... functions?
04:31:40 <quicksilver> EvilTerran: it doesn't do normal function definitions.
04:31:50 <quicksilver> by a vicious hack it supports monad-style "let" ;)
04:31:54 <EvilTerran> ah, i see
04:32:03 <quicksilver> but the point I'm making is it's quite different from a .hs file.
04:32:07 <ekidd> haskell.org doesn't want to talk to me this morning. Is it down?
04:32:12 <quicksilver> yes, sadly so.
04:32:27 <EvilTerran> hask, you can load a module with ":m + Module.Name"
04:32:45 <EvilTerran> hask, but i don't think there's an equivalent to the "as B"
04:33:03 <ekidd> quicksilver: When is it expected to come back up? I'm trying to install cabal and write some silly little Haskell programs.
04:33:08 <EvilTerran> hask, however, you can make a file with all your imports and load that into ghci
04:34:28 <quicksilver> ekidd: when the east coast gets to work, hopefully.
04:35:10 <quicksilver> ekidd: you can still download from hackage
04:35:17 <quicksilver> (that's fortunately not the same host)
04:35:25 <malcolmw> ekidd: hackage is west-coast
04:35:42 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
04:35:44 <quicksilver> (e.g.)
04:35:52 <quicksilver> similarly cabal-install if that's what you need.
04:37:41 <hask> let sq x = x*x
04:37:41 <hask> does func
04:38:05 <quicksilver> yes, I know :)
04:38:09 <ekidd> quicksilver: Thanks!
04:41:02 <rwbarton> Is there anything that's valid both in ghci and at the top level of a .hs file?
04:42:09 <quicksilver> a blank line ;)
04:42:31 <rwbarton> Ooh, a comment too :)
04:43:05 <hask> But how do I create a bytestring, what is the notation? char is 'a', string is "hello" and bytestrng is?
04:43:16 <quicksilver> B.pack "hello"
04:44:00 <hask> I can't directly initialize it?
04:45:16 <hask> and it complains a packed "hello" is a char
04:45:43 <quicksilver> B.pack [1,2,3,4,5]
04:45:50 <quicksilver> if you're dealing with Word8s and not Char8s
04:47:17 <rwbarton> You might want to use Data.ByteString.Char8 rather than Data.ByteString.  AFAIK, it just changes some types (like that of pack) pretending that Char is the same as Word8
04:47:45 <quicksilver> exactly.
04:50:25 <eu-prleu-peupeu> im trying to work a simple vector module, but i want it to be only of types Int, Float and Double, how do i do that ?
04:50:39 <quicksilver> why do you want that?
04:50:49 <eu-prleu-peupeu> hmm
04:50:55 <quicksilver> why don't you allow people to use whatever types they want but document which ones work best.
04:51:26 <eu-prleu-peupeu> hmm, then how do i say that the types must have the methods (+) (*) (/) (-) defined ?
04:51:52 <rwbarton> add Num a => to your type signatures
04:51:53 <vixey> :t \x y -> (x+y,x*y,x/y,x-y)
04:51:54 <quicksilver> don't worry about it.
04:51:55 <lambdabot> forall a. (Fractional a) => a -> a -> (a, a, a, a)
04:51:56 <eu-prleu-peupeu> wouldn't it be better to restrict them ?
04:52:09 <eu-prleu-peupeu> rwbarton: like: type Vector a => Num a where (a, a, a, a)
04:52:10 <quicksilver> the use of + * / - will put Num a into your signatures automatically
04:52:10 <eu-prleu-peupeu> ?
04:52:40 <rwbarton> eu-prleu-peupeu: No, on your function type signatures (if you write them)
04:52:46 <quicksilver> datae Vector a = Vector !a !a !a !a
04:53:02 <quicksilver> then you'll find that your addition routine gets a Num constraint
04:53:11 <quicksilver> but your scalar divide routine gets a Fractional constraint
04:53:12 <quicksilver> which is fine.
04:53:20 <quicksilver> those are, after all, the correct constraints.
04:53:55 <eu-prleu-peupeu> hmm
04:54:36 <vixey> Fractional
04:55:57 <eu-prleu-peupeu> i dont understand the strict operator there :/
04:56:09 <eu-prleu-peupeu> why force the evaluation ?
04:57:06 <quicksilver> eu-prleu-peupeu: you don't need to.
04:57:13 <quicksilver> In general for simple numeric types it's good to do so
04:57:23 <eu-prleu-peupeu> hmm... ok
04:57:25 <quicksilver> if you tell the compiler your numeric fields are strict it may be able to unbox them
04:57:29 <quicksilver> in some circumstances
04:58:03 <eu-prleu-peupeu> hmm
04:58:07 <rwbarton> IMHO a "vector" like (3, undefined) is not really mathematically meaningful anyways
04:59:07 <eu-prleu-peupeu> i wanted to define a vector of with a 4-tuple, but the last one being optional, how do i do that without having to change all the methods ?
04:59:23 <quicksilver> rwbarton: a "vector" like (3, {- this takes a long time to calculate -}) is perfectly meaningful
04:59:31 <quicksilver> rwbarton: and that's the use-case for lazy components.
04:59:43 <quicksilver> rwbarton: however, I think it's an unusual use-case for this kind of thing.
04:59:50 <eu-prleu-peupeu> is there any way to specify a default value for the last vector coordinate ?
05:00:02 <eu-prleu-peupeu> like data Vector a = Vector a a a a = 1 :P
05:00:06 <quicksilver> stuff like matrix multiplication tends to force all components.
05:00:19 <quicksilver> eu-prleu-peupeu: better to have Vector3 and Vector4 be different types
05:00:23 <eu-prleu-peupeu> hmm
05:00:26 <quicksilver> which can, possibly, share some common code.
05:00:49 <eu-prleu-peupeu> yes, but i wouldn't want to have to replicate methods :/
05:01:09 <eu-prleu-peupeu> so dotProduct is Vector->Vector->a
05:01:29 <quicksilver> well doProduct is so simple to write I wouldn't personally worry about duplicating it.
05:01:38 <eu-prleu-peupeu> data Vector a = Vector3 a a a | Vector4 a a a a
05:01:39 <quicksilver> but then matrix multiply can be written in terms of dot product.
05:01:49 <quicksilver> so you can write that generically.
05:01:59 <quicksilver> No, separate types, not separate constructors, is my suggestion.
05:02:28 <eu-prleu-peupeu> hmm, that will make me duplicate the code :/
05:02:46 <eu-prleu-peupeu> duplicate code = duplicate bugs
05:02:57 <hask> I am changing to ByteStrings now but anyway I post the profiling of GC here: http://hpaste.org/9620
05:03:01 <BeelsebobWork> yeh but then they're easy to fix
05:03:03 * BeelsebobWork ducks
05:03:09 <hask> Since I don't know exactly how to interpret it some pointer sowuld be nice
05:03:15 <vixey> data Vector3 a = Vector3 !a !a !a
05:03:20 <vixey> data Vector4 a = Vector4 !a !a !a !a
05:03:27 <vixey> class Vector v where ...
05:03:33 <eu-prleu-peupeu> :)
05:03:34 <vixey> instance Vector Vector3 ...
05:03:43 <BeelsebobWork> hask: it's saying it spend 40.6% of it's time garbage collecting -- probably a large string
05:04:02 <rwbarton> eu-prleu-peupeu: You can use Template Haskell and write three times as much code instead :)
05:04:04 <BeelsebobWork> if you want to know what used all the space generate a heap profile
05:04:12 <BeelsebobWork> -hc IIRC
05:05:00 <quicksilver> eu-prleu-peupeu: well my point is you wouldn't have to duplicate much.
05:05:31 <quicksilver> you could actually use a class method converting to [a] and then duplicate zero code
05:05:44 <quicksilver> but that would not unfortunately be efficient. The optimiser isn't smart enough.
05:06:20 <quicksilver> So I suggest you write the basic operations (addition, multiplication) once for each type
05:06:24 <quicksilver> that really isn't much duplication.
05:06:31 <hask> ok thanks
05:06:40 <quicksilver> Then the higher-order operations like matrix multiplication can be geenric.
05:06:44 <vixey> you wouldn't have to duplicate anything
05:06:55 <eu-prleu-peupeu> hmm, ill try to figure out something... template haskell looks good heheheh
05:07:00 <vixey> you can't write one + that works on Vec3 and Vec4
05:07:02 <quicksilver> Some operations only make sense for Vector3
05:07:08 <eu-prleu-peupeu> i cant ?
05:07:13 <quicksilver> vixey: but they are essentially the same
05:07:14 <vixey> you have to write both cases out
05:07:26 <quicksilver> vixey: it's partial duplication.
05:07:33 <quicksilver> they are both zipWith (+)
05:07:35 <rwbarton> eu-prleu-peupeu: You're already "duplicating code" if you write add (Vector3 a b c) (Vector3 x y z) = (a+x, b+y, c+z)  :)
05:07:38 <eu-prleu-peupeu> can't i say that the last parameter has a default value when not specified ?
05:07:44 <vixey> You end up with the problem
05:07:50 <vixey> Vec3 ... + Vec4 ..
05:07:53 <quicksilver> eu-prleu-peupeu: because that would be extraordinarily evil.
05:07:57 <vixey> being a runtime error, rather than a type error
05:07:59 <hask> sd
05:08:03 <quicksilver> vixey: that's not what I meant.
05:08:09 <eu-prleu-peupeu> :P
05:08:17 <quicksilver> vixey: I meant Vector v => vplus :: v -> v -> v
05:08:29 <quicksilver> vixey: type safe, but it is annoying to have to write the vector instances separately
05:08:32 <quicksilver> instead of generically.
05:08:36 <quicksilver> although not a big problem.
05:08:44 <quicksilver> But I am saying, I do understand eu-prleu-peupeu's point.
05:08:47 <quicksilver> There is some duplication here.
05:08:49 <vixey> how would you like to write it ?
05:08:52 <BeelsebobWork> it's interesting that Vectors cause so much problem
05:09:07 <BeelsebobWork> I guess they're probably the simplest case where we *really* want dependant types
05:09:13 <eu-prleu-peupeu> well, its the strive for elegance
05:09:17 <quicksilver> I'd like to write class Vector v a where toList :: v a -> [a]
05:09:26 <quicksilver> unList :: [a] -> v a
05:09:31 <rwbarton> ... yeah, these aren't real problems, it's just our expectations are too high :)
05:09:32 <vixey> I can't see any duplication
05:09:35 <quicksilver> and then vplus = unList . zipWith (+) . toList
05:09:47 <quicksilver> that would be reasonably elegant
05:09:56 <quicksilver> it's a shame our optimiser isn't smart enough to make it fast.
05:09:59 <BeelsebobWork> uh, vplus wouldn't quite be that
05:10:08 <vixey> is the purpose of template haskell/deriving Data to let you write functions over sets of types?
05:10:10 <quicksilver> no, that was pseudo code :)
05:10:13 <BeelsebobWork> kk
05:10:25 <quicksilver> I think the idea is clear enough.
05:10:41 <BeelsebobWork> yeh -- I just always wish code that uses that patern actually looked like that
05:10:49 <vixey> :t ?unList . zipWith (+) `on` ?toList
05:10:50 <lambdabot> forall c a a1. (?toList::a1 -> [a], Num a, ?unList::([a] -> [a]) -> [a] -> c) => a1 -> a1 -> c
05:11:20 <vixey> :t (?unList .) . zipWith (+) `on` ?toList
05:11:21 <lambdabot> forall b a a1. (?toList::a1 -> [a], Num a, ?unList::[a] -> b) => a1 -> a1 -> b
05:19:43 <gal_bolle> looks like haskell.org is down
05:19:57 <EvilTerran> gal_bolle, the /topic agrees with you :)
05:20:22 <gal_bolle> ah thanks
05:29:28 <hask> here's my heap profile: http://hpaste.org/9621
05:30:01 <BeelsebobWork> hask: wanna graphify that
05:30:13 <Tordek> :t ?unlist
05:30:14 <lambdabot> forall t. (?unlist::t) => t
05:30:45 <hask> how?
05:33:11 <opqdonut_> heh Tordek
05:34:04 <BeelsebobWork> hask: we think it's hp2ps
05:34:15 <BeelsebobWork> and then whatever your favorite postscript rip is
05:35:38 <lambdapants> >unwords ['h','e','l','l','o']
05:36:00 <Botje> > unwords $ map return ['h','e','l','l','o']
05:36:02 <lambdabot>  "h e l l o"
05:36:24 <lambdapants> ;)
05:36:39 <vixey> :t ?x
05:36:39 <vixey> :t ?x ?y
05:36:41 <lambdabot> forall t. (?x::t) => t
05:36:41 <lambdabot> forall t t1. (?y::t, ?x::t -> t1) => t1
05:36:43 <vixey> :t \e -> ?x
05:36:45 <lambdabot> forall t t1. (?x::t1) => t -> t1
05:36:47 <lambdapants> I get a weird error using missingh's network libs
05:37:08 <BeelsebobWork> Botje: use (:[]) already
05:37:09 <BeelsebobWork> much clearer
05:37:19 <BeelsebobWork> you're not using the generality of return at all there
05:37:29 <ekidd> Has anybody done any sound programming in Haskell? I'd like to build a metronome application, and play wave files at precise times.
05:37:34 <Botje> true
05:37:39 <Botje> but it was easier to type :)
05:37:54 <BeelsebobWork> lol
05:38:05 <BeelsebobWork> but (:[]) looks like a smiley
05:38:07 <BeelsebobWork> it must be better
05:38:24 <Botje> actually, it's the evil robot monkey operator
05:38:24 <Botje> :)
05:38:34 <lambdapants> :-$
05:38:44 <BeelsebobWork> your haskell is not proper haskell if you can't read it as "angry face, evil robot monkey, slightly surprised face, skull and crossbones"
05:38:57 <lambdapants> ﻿BeelsebobWork: search youtube for some thing haskell sound related
05:39:14 <lambdapants> some dude made a program and demonstrates it on there
05:39:21 <lambdapants> but I can't quite remember anything about it
05:39:43 <ekidd> lambdapants: vocable? That's a slick little synth.
05:40:04 <lambdapants> whooops beeselebobwork, I pasted the wrong name, sorry :)
05:40:15 <ekidd> Unfotunately, it plays funky electronic waveforms through SuperCollider, and so it's pain to get working and does actually play samples...
05:40:24 <ekidd> s/does/doesn't/
05:40:32 <lambdapants> heh
05:40:45 <vixey> return = (:[])
05:40:59 <lambdapants> theres an mp3 player on hackage too, I think... I looked at the code once, it calls a lot of c but was poetic nonetheless
05:41:17 <ekidd> http://www.youtube.com/watch?v=77TPSrd-tuo
05:41:19 <BeelsebobWork> vixey: doesn't mean your code is as clear when you use return to mean the specific thing
05:41:28 <lambdabot> Title: YouTube - vocable rhythms
05:41:46 <lambdapants> actually, has anyone else read the code to monadius?  It's like paradise lost for haskell programmers
05:42:01 <opqdonut_> monadius?
05:42:11 <lambdapants> it's a space shootemup
05:42:11 <BeelsebobWork> it sounds like I'm going to hate it
05:42:25 <DavidDavid> need science calculation language
05:42:28 <lambdapants> ﻿it has a case statement 400 lines long.... refering (Just Int) to spawning new dudes
05:42:35 <BeelsebobWork> lol
05:42:45 <lambdapants> the dude leaves a comment saying it is like basic
05:43:28 <DavidDavid> can haskell use in atom theory, chemistry cal?
05:43:35 <lambdapants> most of the game is in one 1500 line file... the dude must be a genius... I mean, that isn't exactly modular software engineering.  it's more like a poem, that he thought out gestalt.
05:44:11 <pozic> lambdapants: Haskell has bad tools, putting everything in a file gives you easy access to everything.
05:44:12 <DavidDavid> atom theory, chemistry very complex, need super cal
05:44:25 <BeelsebobWork> pozic: >.<
05:44:31 <BeelsebobWork> what's wrong with your file browser?
05:44:37 <vixey> pozic: lol?
05:44:50 <pozic> There are some limits to "everything".
05:45:26 <quicksilver> haskell has bad tools?
05:45:29 * quicksilver ponders
05:45:41 <quicksilver> a rather broad accusation
05:45:43 <lambdapants> pozic: the dude could easily have put different parts of the program in different files in the same folder.  he just wrote it all one sunday afternoon, most likely and couldn't be arsed.
05:46:32 <lambdapants> anyway has anyone ever got *** Exception: accept: invalid argument (Invalid argument
05:46:50 <pozic> Given cursor on identifier in file, jump to location is not implemented in vim and emacs.
05:47:17 <quicksilver> yes it is.
05:47:22 <quicksilver> hasktags + tag support
05:47:24 <pozic> The compiler is the only thing that sort of works in Haskell.
05:47:29 <quicksilver> works in emacs, I presume it works in vim.
05:47:30 <lambdapants> (esp when using Network accept, along with missingH Network.SocketServer )
05:47:35 <pozic> quicksilver: no, hasktags misses lots of functions.
05:47:42 <quicksilver> I must admit I've never needed it myself.
05:47:42 <pozic> quicksilver: and it doesn't scale.
05:48:00 <vixey> scale?
05:48:01 <vixey> lol
05:48:02 <quicksilver> it would be nice to have, but hardly a big problem.
05:48:18 <araujo> pozic, ?
05:48:28 <pozic> araujo: ??
05:48:30 <araujo> pozic, there are also plenty of cool libraries and modules :-]
05:48:30 <DavidDavid> can u program haskell f me?
05:48:36 <Tordek> I'm trying to do this http://research.swtch.com/2008/06/electoral-programming.html in haskell. So far, I have http://hpaste.org/9622
05:48:37 <pozic> araujo: "cool"?
05:48:38 <mm_freak_> i'm unable to connect to haskell.org
05:48:41 <pozic> araujo: how many did you use?
05:48:44 <lambdapants> only for money or beer :)
05:49:03 <pozic> araujo: most worth anything are partial binds to C libraries that are undocumented.
05:49:04 <araujo> pozic, several ... including a whole GUI toolkit
05:49:14 <araujo> pozic, www.haskell.org/himerge
05:49:16 <Tordek> (ie, dynamic programming, or whichever the best ways it is to do in haskell)
05:49:32 <araujo> one of the purpose of that project is to show , Haskell is really cool for many kind of applications
05:49:33 <pozic> araujo: you only select GTK2HS and an application based on it.
05:49:46 <lambdapants> DavidDavid: can you give me a link to some example of the chemistry stuff you'd need written in haskell?
05:49:52 <araujo> pozic, just one of the toolkit I have used
05:49:55 <pozic> araujo: GTK2HS was built by funding from a university essentially, IIRC.
05:50:04 <pozic> araujo: and again, it's just a binding.
05:50:06 <araujo> pozic, ask dcoutts :-)
05:50:18 <araujo> pozic, I have used parsec, happy, alex ... ufff
05:50:18 <DavidDavid> everything is money, I try to obtain some free, my haskell level too low, only know r number
05:50:21 <lambdapants> DavidDavid: my flatmate studies chem eng, he would probably appreciate tools too
05:50:21 <araujo> Plenty of cool stuff
05:50:34 <araujo> Saying that the compiler is the only good thing on Haskell
05:50:36 <mm_freak_> does anyone else have problems connecting to haskell.org?
05:50:45 <araujo> It is kind of ... mis-informed
05:50:56 <pozic> araujo: all 0.1-0.4 libraries. Count the number of stable 1.0 libraries.
05:51:04 <araujo> pozic, please, think before talking
05:51:09 <araujo> or at least, do some researching
05:51:11 <dcoutts> pozic: gtk2hs has never had any uni funding afaik. It's all volunteer.
05:51:13 <pozic> araujo: hahaha
05:51:16 <araujo> We also have hackage
05:51:20 <araujo> dcoutts, Hi there :-)
05:51:28 <araujo> pozic, saw what dcoutts said? :-)
05:51:32 <quicksilver> pozic: try to make your comments a little more constructive.
05:51:36 <Tordek> mm_freak_: look at the topic
05:51:42 <quicksilver> there is lots of interesting software on hackage
05:51:48 <quicksilver> some of it is very experimental, some less so
05:51:49 <DavidDavid> yes, that's a good way, use tools in physics, atoms, etc.
05:51:54 <mm_freak_> oh, ok, thanks
05:51:58 <quicksilver> the version numbers are not a reliable guide.
05:52:03 <pozic> dcoutts: did you never write a paper on the topic or a related one?
05:52:34 * araujo points we also have cabal-install ... 
05:52:35 <rwbarton> Tordek: One suggestion: If you get rid of the 'c' parameter of ways, and instead have it return a list (value at c = 0, 1, ...) you can make just one recursive call
05:52:39 <mm_freak_> which SHA-256 would you recommend performance-wise?
05:52:52 <pozic> araujo: all software written by dcoutts.
05:52:59 <dcoutts> lispy: report cabal/hackage/cabal-install bugs here: http://hackage.haskell.org/trac/hackage/
05:53:02 <mm_freak_> s/SHA-256/SHA-256 implementation/
05:53:03 <DavidDavid> when collect enough tools, test, I will never have a team
05:53:09 <pozic> araujo: there are some others that write good software, but you can count those on two hands.
05:53:22 <araujo> pozic, that's kind of an unfair comment really
05:53:23 <sioraioc_> bos: ping
05:53:33 <dcoutts> pozic: oh some people (not I) have written papers that used gtk2hs, though it was not the main focus.
05:53:37 <mm_freak_> pozic: i can count up to 1023 on two hands =)
05:53:44 <pozic> araujo: that's your opinion.
05:53:44 <araujo> pozic, plenty of people write good haskell code and applications, please check hackage
05:54:01 <vixey> mm_freak_++
05:54:07 <dcoutts> pozic: we got invited to give a presentation on gtk2hs to a uni team once
05:54:08 <DavidDavid> but where got money pay them
05:54:17 <Tordek> rwbarton: I don't follow (ie, I don't understand how it works as you describe it)
05:54:31 <araujo> pozic, I bet, for example, you have heard of darcs ... and no, that is not written by dcoutts
05:54:33 <mm_freak_> pozic: but seriously, you shouldn't underestimate haskell…  it's just that haskell is not for everyone, but software written in haskell is fast and of high quality
05:54:33 <araujo> :-)
05:54:33 <pozic> araujo: how many libraries have you used again?
05:54:46 <pozic> araujo: darcs is being abandoned by GHC.
05:55:00 <quicksilver> xmonad is pretty neat.
05:55:05 <DavidDavid> can haskell coperate with AI
05:55:06 <araujo> pozic, plenty ... to name a few, gtk2hs, alex, happy, parsec, hs-plugins, hmagic, hsql .......
05:55:10 <mm_freak_> also don't count by code files or even lines…  haskell code is usually much shorter than code in other languages
05:55:16 <rwbarton> Tordek: Instead of ways, write ways' such that  ways' v = [ ways c v | c <- [0..] ]
05:55:21 <araujo> pozic, but not by the Haskell community
05:55:32 <pozic> xmonad is written mostly by old Haskellers (remember the hands).
05:55:42 <vixey> ugh pozic is trolling
05:55:46 <araujo> Oh, and xmonad
05:55:48 <quicksilver> certainly haskell has less stuff written for it than some more widely used languages.
05:55:54 <araujo> forgot to mention it
05:55:55 <araujo> hah
05:55:56 <quicksilver> is that particularly surprising?
05:56:01 <mm_freak_> pozic: well…  feel free not to use haskell or programs written in haskell
05:56:08 <mm_freak_> nobody forces you
05:56:14 <hask> haskell had bad tools? wtf, emacsmode for haskell is great, emacs > any ide or editor
05:56:25 <hask> good profiler, which doesnt even exist for other languages
05:56:31 <hask> good version control system
05:56:33 <hask> cabal
05:56:35 <hask> etc...
05:56:37 <rwbarton> Tordek: You can then write  ways' (v:vs) = (... some expression involving w ...) where w = ways' vs
05:56:41 <mm_freak_> hask: profilers exist for almost all languages
05:56:59 <hask> i was gonna write most other, not all
05:57:03 <araujo> hask, oh, haskell-mode is awesome, yeah
05:57:04 <pozic> The GHC profiler isn't all that good, either.
05:57:05 <mm_freak_> and emacs is not written in/for haskell
05:57:11 <sioraiocht> hrm, do we have a troll?
05:57:23 <hask> no i is not written in, so?
05:57:26 <araujo> sioraiocht, just a misinformed pal :-)
05:57:33 <sioraiocht> ah
05:57:36 <pozic> No, the entire channel is trolling claiming that Haskell has good tools.
05:57:42 <pozic> Duh
05:57:48 <audreyt> Haskell has good trolls!
05:57:50 <araujo> Certainly has
05:57:53 <araujo> audreyt, haha
05:57:56 <hask> there are good tools for haksell, both written in haskell some written in emacslisp etc
05:58:04 <araujo> Oh, forgot to mention pugs too
05:58:04 <audreyt> our trolls are more precise and efficient!
05:58:09 <quicksilver> actually all I said was that I thought it was unfair to say 'haskell has bad tools'
05:58:13 <hask> Our trolls are very expressive
05:58:20 <quicksilver> not the same thing as saying 'haskell has good tools'
05:58:27 <quicksilver> haskell has some excellent tools.
05:58:28 <audreyt> they troll in Constant Time!
05:58:37 <Tordek> rwbarton: I understand what you're saying, I just don't get how I'd calculate it :/
05:58:39 <pozic> quicksilver: like?
05:58:49 <DavidDavid> give up, I don't know how haskell become large scale application
05:59:05 <quicksilver> ghc. the emacs mode with kuribas's indentation package
05:59:08 <rwbarton> Tordek: Oh OK, something like   zipWith (+) w (replicate v 0 ++ w)
05:59:09 <quicksilver> the profiler
05:59:11 <quicksilver> ghci.
05:59:13 <mm_freak_> haskell has not a lot of tools, but those, which it has, are very good (IMO)
06:00:07 <quicksilver> Data.Derive is a good tool.
06:00:18 <pozic> quicksilver: if you think the profiler is good, you don't know what a good profiler is.
06:00:29 <vixey> haskell -is- a tool
06:00:32 <mm_freak_> it's just that haskell's community isn't as large as the communities of other languages, but all purely functional languages suffer from that
06:00:33 <araujo> pozic, how log have you been using Haskell?
06:00:41 <pozic> araujo: longer than you
06:00:55 <araujo> pozic, and how many libs have you used?
06:01:02 <pozic> araujo: more than you.
06:01:02 <araujo> :-)
06:01:10 <araujo> pozic, name them please?
06:01:17 <vixey> pozic: Don't be rude please
06:01:44 <hask> exactly haskell doesn't have the amount of libraries of Java or Python but the ones that are there a re excellent and very reusable
06:01:48 <DavidDavid> I remember, some large company use haskell write huge solution
06:01:55 <araujo> hask, my experience indeed
06:02:11 <araujo> Haskell stuff is usually of good quality
06:02:42 <araujo> (if they are considered stable of course)
06:02:50 <mm_freak_> well…  the Crypto library sucks
06:02:57 <mm_freak_> but all others i encountered were good
06:03:25 <pozic> Since you are asking for an example, take Data.Derive.
06:03:43 <DavidDavid> Siemens, NASA.
06:03:52 <pozic> DavidDavid: are you a bot?
06:04:07 <mm_freak_> ah, haskell.org is back up
06:04:07 <DavidDavid> a fool.
06:04:18 <ekidd> Hmm. Where does cabal-install put documentation for modules?
06:04:23 <mm_freak_> someone should adjust the topic
06:04:40 <quicksilver> ekidd: I think it doesn't automatically run haddock. Except maybe the newest version? I'm unsure.
06:04:44 * araujo was waiting for pozic answer :-)
06:04:46 <dcoutts> ekidd: it doesn't yet, that's implemented in the deve version and will be in the next release
06:04:52 <dcoutts> deve/dev
06:04:54 <quicksilver> (is it perhaps only the unreleased version?)
06:04:57 * quicksilver nods
06:04:59 <DavidDavid> it's, 'how to make large haskell solution'
06:05:25 --- mode: ChanServ set +o quicksilver
06:05:53 --- topic: set to '["Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by quicksilver
06:06:00 --- mode: quicksilver set -o quicksilver
06:08:49 <ekidd> dcoutts: Thanks! It would be really sweet to link to Haddock documentation from HackageDB someday, but I can see how that would present some possible issues...
06:09:19 <dcoutts> ekidd: you mean to link your local docs to the ones on hackage?
06:09:51 <ekidd> dcoutts: Perhaps for each package in HackageDB, run haddock and link to the results from the package's page?
06:10:07 <pozic> Regarding the library/tools issue: they have been improved, but >90% (I think more of >99%) cannot be used in a project without encountering some library/tool bug.
06:10:30 <dcoutts> ekidd: we do that already, unless I misunderstand what you mean
06:10:37 <DavidDavid> How to evaluate haskell skill professional?
06:11:15 <pozic> Ok, so we have a Markov chain here.
06:11:25 <ekidd> dcoutts: OK, I must be stupid. :-) How do I get from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ALUT to a documentation page?
06:11:49 <pozic> ekidd: click on a module
06:11:55 <dcoutts> ekidd: see the list of "Exposed modules", those are links to the docs for each module
06:12:14 <mauke> heh, it's just type signatures
06:12:15 <mauke> no real docs
06:12:15 <ekidd> pozic, dcoutts: Ow. I do have the stupid this morning. Thanks!
06:12:18 <DavidDavid> depend on education, and haskell module
06:12:37 <Tordek> rwbarton: sorry, I'm still stuck... I don't understand the base case... or how it's suppossed to work
06:12:41 <dcoutts> mauke: that'll be the fault of the package not providing any :-(
06:12:47 <rwbarton> Tordek: work' [] = repeat 0
06:13:00 <luqui> does anyone know if there is a way to use darcs2 on c.h.o?
06:13:01 <rwbarton> Tordek: Sorry, work' [] = 1 : repea t0
06:13:10 <visq> The idea of linking to the project's bug tracker on HackageDB has been abandoned ?
06:13:18 <visq> I thought that would be nice.
06:14:03 <visq> Try to find the bug tracker of hoogle, for example
06:14:05 <dcoutts> visq: no, I think that would be nice too
06:14:16 <dcoutts> visq: it doesn't seem very hard to do
06:14:20 <audreyt> it would also be nicer if a Changes/NEWS file can be automatically linked
06:14:33 <audreyt> it's my #1 gripe coming from CPAN where it's expected as a standard
06:14:56 <audreyt> it's otherwise very hard to find how package foo's version 1.0.3.5 differs from 1.0.3.4...
06:14:59 <DavidDavid> how to let haskell learn
06:15:02 <pozic> The killer feature is going to be able to weed out the packages that are of low-quality.
06:15:22 <vixey> DavidDavid: Ask them to write factorial and compare what they wrote against this chart: www.willamette.edu/~fruehr/haskell/evolution.html
06:15:30 <mauke> haha
06:15:39 <pozic> Not by some democratic voting process, but by letting the user select which people he/she trusts.
06:15:56 <luqui> pozic, I disagree
06:16:12 <luqui> I think CPAN is a fine model, where most things get in
06:16:14 <audreyt> I think some sort of objective kwalitee is nice, too
06:16:20 <Tordek> rwbarton: uh, thanks, and that's cool and all... but afaict, it's working by action of magic ;)
06:16:20 <DavidDavid> haskell learn knowledge
06:16:34 <luqui> people evaluate modules by using them
06:17:03 <luqui> good ones get reputation
06:17:10 <luqui> not using some voting system, reputation spreads itsefl
06:17:19 <hask> is there no builtin for:  flatten = foldl (++) []
06:17:20 <pozic> E.g. when dcoutts votes after he has looked at a libary and has decided it's great, then I might consider looking at it too.
06:17:38 <luqui> yeah, that happens automatically
06:17:48 <luqui> though formalization of that may be helpful.. not sure
06:17:57 <pozic> luqui: that only works for people that communicate all day long in #haskell or visit a mailinglist.
06:18:15 <pozic> And, of course, you can make it programmable.
06:18:19 <rwbarton> Tordek: you understand how what you wrote works, right?
06:18:25 <Tordek> yep
06:19:03 <DavidDavid> that's very complex, use AI algorithm
06:19:05 <audreyt> pozic: or maybe just write a frontend to ohloh.net :)
06:19:25 <pozic> audreyt: I don't know who owns the data of ohloh.net.
06:19:26 <rwbarton> Tordek: how about ways'' (v:vs) = [ ways'' vs !! c + (if c-n>=0 then ways'' vs !! (c-n) else 0) | c <- [0..] ] ?
06:19:32 <pozic> audreyt: do you?
06:19:40 <rwbarton> Tordek: ways'' [] = 1 : repeat 0
06:19:46 <dcoutts> pozic: I think you've probably got too high an opinion of me :-)
06:19:56 <mauke> hask: concat
06:20:00 <Tordek> repeat returns an infinite list of that element, right?
06:20:05 <rwbarton> Yeah
06:20:37 <audreyt> pozic: I have difficuty understand the meaning of "own here"
06:20:50 <audreyt> s/"own here"/"own" here/
06:20:52 <DavidDavid> anywhere start
06:21:09 <rwbarton> Tordek: way c vs = way'' vs !! c
06:21:16 <tibbe> @seen dcoutts
06:21:17 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc, #haskell-blah and #darcs. I last heard dcoutts speak 1m 31s ago.
06:21:23 <dcoutts> hia tibbe
06:21:31 <pozic> audreyt: there is some collection of votes whatever for a given software project.
06:21:36 <pozic> audreyt: that's called data.
06:21:48 <tibbe> @seen dcoutts
06:21:48 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc, #haskell-blah and #darcs. I last heard dcoutts speak 26s ago.
06:21:50 <pozic> audreyt: in the modern world people capitalize on data.
06:22:06 <tibbe> dcoutts: what's the plan for strict usage of binary?
06:22:09 <pozic> audreyt: so, can one redistribute that data for free or not? What's the license?
06:22:11 <DavidDavid> algorithm, data
06:22:17 <Tordek> rwbarton: it's similar to the sieve of erathostenes, just that counting instead of marking out?
06:22:24 <pozic> audreyt: I don't know, since I don't really care about those general systems that generally don't work.
06:22:30 <dcoutts> tibbe: what do you mean exactly?
06:22:33 <pozic> audreyt: that's why I asked.
06:22:36 <Tordek> (I'm weird with examples, yeah)
06:22:54 <rwbarton> Tordek: ... and different in lots of other ways too, but I guess? :)
06:22:54 <DavidDavid> finally, we found the system don't work
06:23:09 <tibbe> dcoutts: an interface for strict bytestrings
06:23:27 <tibbe> dcoutts: so I don't need to fromChunks
06:23:46 <rwbarton> I'm just trying to collect the values of ways c v, for fixed v and varying c, into a list
06:23:50 <audreyt> pozic: I think it only requires you to linkback to their site.
06:23:54 <audreyt> # http://www.ohloh.net/api/terms
06:23:58 <dcoutts> tibbe: I don't think it needs an interface for strict bytestrings, however I agree with many of the other points about exception handling and the continuation style which allows pushing more input in explicitly etc
06:24:01 <audreyt> pozic: otherwise you're free to make use of its API and its data.
06:24:05 <lambdabot> Title: Special Terms and Conditions for Ohloh API
06:24:19 <audreyt> pozic: it doesn't seem too onerous to me...
06:24:23 <DavidDavid> haskell is cal language, but algorithm, who knows problem
06:24:50 <tibbe> dcoutts: yes I would like to do on the fly serializing without lazy I/O
06:24:56 <pozic> audreyt: I see all kinds of limitations.
06:25:11 <sw17ch> @src lift
06:25:12 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:25:23 <audreyt> pozic: ok then :)
06:25:33 <paczesiowa> sw17ch: I see you're up already:>
06:25:36 <dcoutts> tibbe: absolutely, that doesn't require using strict bytestrings. I agree totally about the cont based api where you have explicit control over request/response from the binary encoder/decoder.
06:25:37 <tibbe> dcoutts: strict bytestrings fall out naturally once you do that
06:25:41 <sw17ch> paczesiowa, :)
06:25:49 <sw17ch> i was wondering about the source for that all night
06:26:00 <tibbe> dcoutts: why would you use lazy bytestrings in a cont API?
06:26:00 * sw17ch has lost more sleep to Haskell than Video Games
06:26:01 <dcoutts> tibbe: but it allows us to do all the use cases with one implementation, that's a big win.
06:26:06 <Tordek> hmm, I do (ways' votes) !! 271 and it says "Couldn't match expected type Int against inferred type Integer"
06:26:10 <paczesiowa> Control.Monad.Trans
06:26:10 <pozic> audreyt: competition should be based on software/UI quality, not on whoever owns the data.
06:26:19 <tibbe> dcoutts: sure, the interface could do the fromChunks just as an convenieve
06:26:32 <dcoutts> tibbe: aye, perhaps so
06:26:39 <tibbe> dcoutts: which allows it to be change if someone came up with a faster way to do it for strict bytestrings
06:26:51 <tibbe> dcoutts: I think it's conceptually the right type too
06:26:59 <rwbarton> Tordek: Oh, that's because votes is defaulting to Integer but replicate wants an Int
06:27:06 <dcoutts> tibbe: yeah, that might work. I don't want to force everyone to pick between two libs with different types.
06:27:06 <audreyt> pozic: I sympathize with you philosophically. :)
06:27:24 <Tordek> rwbarton: so votes :: [Int] ?
06:27:28 <rwbarton> Tordek: that'll work
06:27:37 <DavidDavid> test
06:27:37 <vixey> votes :: [Vote]
06:27:43 <Tordek> thanks :)
06:27:45 <tibbe> dcoutts: I think people who will use the cont api already work in terms of strict bytestrings
06:27:46 <dcoutts> tibbe: so that might be a plan however I cannot commit my time to it right now
06:27:52 <tibbe> dcoutts: sure
06:27:56 <tibbe> dcoutts: that's fine
06:28:08 <DavidDavid> where is the problem
06:29:09 <Tordek> rwbarton: uh... I got an overflow :/
06:29:16 <sw17ch> the source for ErrorT isn't in the api docs :(
06:29:28 <rwbarton> Tordek: stack overflow?
06:29:33 <Tordek> no, integer
06:29:41 <rwbarton> hmm...
06:29:43 <chrisdone> hello
06:29:45 <Tordek> nm, I set the return type to int, was integer
06:29:55 <paczesiowa> sw17ch: ErrorT is in Control.Monad.Error
06:30:03 <Tordek> ways' :: [Int] -> [Integer]
06:30:15 <paczesiowa> sw17ch: lift is from Control.Monad.Trans
06:30:18 <rwbarton> Tordek: yes, your type signature wasn't general enough
06:30:24 <Tordek> I had [Int] -> [Int] so it overflowed
06:30:32 <rwbarton> Or that :)
06:30:33 <sw17ch> paczesiowa, ... oh, i found it now :*|
06:30:36 <Tordek> ;P
06:31:08 <tibbe> dcoutts: I'm having a hard time to figure out when you want to use lazy bytestrings except for perhaps unfolds
06:31:14 <DavidDavid> how many man u have?
06:31:22 <malcolmw> luqui: darcs2 is now available on code.haskell.org (/usr/local/bin/darcs2)
06:31:30 <chrisdone> just trying this rcirc client @_@
06:31:35 <tibbe> dcoutts: is it all cabal nowadays? :)
06:31:51 * rwbarton wonders if there is something wrong with DavidDavid's IRC client
06:32:27 <paczesiowa> sw17ch: if you use IO in underlying monad, use liftIO - looks better and will be easier to modify the code later when adding another monad to stack
06:32:41 <audreyt> rwbarton: a bot, most likely
06:32:54 * sw17ch thinks he used liftIO and it broke.. but goes to try
06:33:29 <sw17ch> apparently i did it wrong
06:33:29 <paczesiowa> sw17ch: and for similar reason use throwError . strMsg instead of fail - you'll be free to switch away from Strings as errors
06:33:39 <DavidDavid> means huge money, haha
06:33:39 <Tordek> hmm, okay, now for the second part of the problem, which is the different minimal sets which get _at least_ 270 votes
06:33:56 <sw17ch> paczesiowa, nifty!
06:34:08 <DavidDavid> u did not have powerful tools
06:34:46 <sw17ch> thanks again
06:34:48 * sw17ch goes to work
06:34:49 <chrisdone> DavidDavid: judging from your written words, are all your variable names really short?
06:37:25 <DavidDavid> until now no haskell CASE tool are the most power
06:37:58 <paczesiowa> @instances Arrow
06:37:59 <lambdabot> (->), Kleisli m
06:38:14 <audreyt> http://www.nbcolympics.com/video/index.html
06:38:16 <lambdabot> Title: 2008 Beijing Summer Olympic Games | Free Online Videos, Olympic Event | Athlete  ...
06:38:17 <vixey> > 1+1
06:38:19 <audreyt> er sorry
06:38:20 <lambdabot>  2
06:38:21 <audreyt> wrong window :)
06:39:09 <chrisdone> > 2
06:39:11 <lambdabot>  2
06:39:12 <chrisdone> optimisation
06:39:28 <mauke> preflex: karma C/C
06:39:28 <preflex>  karma for C/C: 630
06:40:16 <Deewiant> preflex: karma C
06:40:16 <preflex>  karma for C: 23982
06:40:22 <opqdonut_> heh
06:40:31 <Deewiant> we need more C-- talk
06:40:43 <Botje> preflex: karma i
06:40:43 <mauke> preflex: karma C++
06:40:43 <preflex>  karma for i: 144
06:40:43 <preflex>  karma for C++: -9
06:40:46 <DavidDavid> u had to find someone to programming, n don't know what u get
06:40:49 <Deewiant> hmm, does it read it mid-sentence
06:40:51 <Deewiant> preflex: karma C
06:40:51 <preflex>  karma for C: 23982
06:40:58 <mauke> Deewiant: yes
06:41:17 <mauke> my request probably bumped it up again
06:41:22 <Deewiant> mauke: but it didn't update? or did "karma C++" increase it
06:41:31 <Deewiant> meh, that's somewhat silly :-)
06:44:12 <DavidDavid> one result: something u get, what use
06:46:30 <chrisdone> I like how rcirc just says "andyjgill JOIN" rather than "andyjgill has joined the channel"
06:48:07 <DavidDavid> true
06:48:43 <eu-prleu-peupeu> why can't i do this: type Vector3 a = (a, a, a)
06:48:43 <eu-prleu-peupeu> instance Vector Vector3 where   ?
06:48:52 <tibbe> @seen BSP
06:48:53 <lambdabot> I haven't seen BSP.
06:48:56 <DavidDavid> when u want to do smothing, u need to reconstruct all algorithms
06:48:57 <tibbe> @seen BSP_
06:48:58 <lambdabot> BSP_ is in #ghc. I don't know when BSP_ last spoke.
06:49:11 <mauke> eu-prleu-peupeu: H98 doesn't let you use type synonyms in instance declarations
06:49:31 <eu-prleu-peupeu> ok :/
06:49:42 <DavidDavid> all haskell programmers need to be giants
06:49:57 <eu-prleu-peupeu> i should really read the report :/
06:50:02 <mauke> there's a ghc extension, of course
06:50:03 <paczesiowa> eu-prleu-peupeu: -XTypeSynonymInstances
06:50:25 <eu-prleu-peupeu> will it be added to the report ? :P
06:50:37 <quicksilver> do we find the DavidDavid bot annoying or amusing? :)
06:50:52 <chrisdone> I thought it was a real person
06:50:52 <eu-prleu-peupeu> isn't it too bad to be working with extensions ? :/
06:51:03 <paczesiowa> it's a bot or troll?
06:51:12 <quicksilver> eu-prleu-peupeu: there is no real advantage to type Vector3 a = (a,a,a) over data Vector3 a = Vector3 a a a
06:51:25 <eu-prleu-peupeu> are they equivalent in terms of performance ?
06:51:34 <eu-prleu-peupeu> okey then...
06:51:39 <quicksilver> (the only advantage of the former would be re=using standard lib functions which work on triples)
06:51:42 <quicksilver> but there aren't any!
06:51:46 <quicksilver> so that isn't an issue :)
06:51:48 <eu-prleu-peupeu> i kind of save several "getters" with a data ...
06:51:55 <paczesiowa> > id (1,2,3)
06:51:57 <lambdabot>  (1,2,3)
06:52:05 <quicksilver> data Vector3 a = Vector3 !a !a !a
06:52:06 <eu-prleu-peupeu> oraite, thanks :D
06:52:12 <quicksilver> as I suggested before, is probalby better anyway.
06:52:31 <eu-prleu-peupeu> i dont understand the force evaluation there :/
06:55:53 <guenni> hi guys, anybody here who could help with parsing XML documents?
06:56:11 <quicksilver> eu-prleu-peupeu: simply the observation that it's not normally desirable to have laziness in numerical record fields.
06:56:16 <quicksilver> eu-prleu-peupeu: just a rule of thumb, that's all.
06:56:22 <paczesiowa> guenni: what lib?
06:56:24 <quicksilver> guenni: probably, yes.
06:56:29 <quicksilver> guenni: don't ask to ask jsut ask :)
06:56:37 <guenni> which I knew which one to take
06:56:37 <eu-prleu-peupeu> so the (!) operator is just a suggestion for the compiler ?
06:56:45 <eu-prleu-peupeu> like the "registry" in C ? :P
06:56:50 <eu-prleu-peupeu> (or inline)
06:56:57 <guenni> I just got started with Parsec and that worked like a charm
06:57:12 <guenni> know I got the data in XML doc instead
06:57:22 <vixey> is there not already XML parsers?
06:57:22 <paczesiowa> guenni: don't write your own xml parser
06:57:29 <guenni> which should theoretically even be easier
06:57:33 <mauke> eu-prleu-peupeu: no, strictness annotations have to be obeyed
06:57:35 <quicksilver> guenni: I have used tagsoup and haxml
06:57:43 <quicksilver> eu-prleu-peupeu: they're slightly more than a suggestion
06:57:48 <guenni> so I tried HaXml
06:57:50 <quicksilver> eu-prleu-peupeu: they do have a consequence.
06:57:56 <paczesiowa> I can help with hxt
06:57:59 <guenni> and don't understand a f.. thing
06:57:59 <quicksilver> eu-prleu-peupeu: but, it's not too far off to think of them that way.
06:58:07 <quicksilver> they're "mostly" just a performance hint.
06:58:07 <guenni> the docs are out of date
06:58:18 <Stinger> can you help me build hxt 8.1 on windows? :P
06:58:21 <guenni> so are the module paths in the examples
06:58:23 <quicksilver> not if you read the correct docs for the version, I think.
06:58:47 <quicksilver> ISTR you have to read the docs from the right page
06:58:48 <guenni> well I did install the 1.13 version
06:58:51 * quicksilver wonders if malcolmw is around.
06:59:04 <mauke> preflex: seen malcolmw
06:59:04 <eu-prleu-peupeu> ok, thanks
06:59:04 <preflex>  malcolmw was last seen on #ghc 28 seconds ago, saying: nominolo: since I don't have any hands-on experience of git, I was just assuming that if a git user recommends making branches, it likely leads to problems if you don't make a branch
06:59:10 <paczesiowa> Stinger: cabal install it?
06:59:21 <guenni> quicksilver: should I go with Haxml?
06:59:28 <quicksilver> guenni: what are you trying to do?
06:59:28 <Stinger> the problem is it wants libcurl now
06:59:36 <quicksilver> what kind of task are you trying to solve?
06:59:44 <Stinger> which is a pain to install/cant get it to work
06:59:46 <guenni> well there is a programm I'm supposed to write
06:59:52 <sioraiocht> @src guard
06:59:52 <lambdabot> guard True  =  return ()
06:59:52 <lambdabot> guard False =  mzero
07:00:01 <sioraiocht> :t guard
07:00:03 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:00:13 <guenni> the programm matches dynamic data with static data, a huge catalog
07:00:16 <paczesiowa> Stinger: sorry, I only used it in linux and it just worked(tm)
07:00:23 <guenni> that static data is in xml for now
07:00:46 <quicksilver> guenni: sounds like the kind of task I would use HaXML for.
07:00:56 <paczesiowa> Stinger: why do you need 8.1?
07:00:57 <guenni> I was gonna parse it into my own list of data structures and the make a "show" on it
07:01:00 <quicksilver> guenni: perhaps it would be useful for you to see the code I wrote to parse PList files.
07:01:04 <quicksilver> (using HaXML)
07:01:20 <guenni> quicksilver: oh yes please
07:01:29 <Stinger> I don't really
07:01:49 <Stinger> but as versions increase/features are added I assume this curl dependency is going to remain
07:01:50 <guenni> and dump the show into an .hs file
07:02:31 <quicksilver> guenni: http://hpaste.org/9543
07:02:33 <paczesiowa> Stinger: maybe install cygwin and libcurl under cygwin?
07:02:44 <Stinger> yeah thats what I had to do
07:02:51 <quicksilver> guenni: PList is an Apple XML format, by the way.
07:03:04 <DavidDavid> Can haskell use in text analysis
07:03:10 <quicksilver> it's a kind of representation of dictionarys and arrays which can contain other dictionarys and arrays
07:03:13 --- mode: ChanServ set +o quicksilver
07:03:15 <Stinger> but cabal building gives me errors that I can't be bothered investigating
07:03:16 <guenni> quicksilver: thx
07:03:18 <paczesiowa> pls kick him
07:03:18 --- mode: quicksilver set +b *!*=davidowh@59.42.197.*
07:03:19 --- kick: DavidDavid was kicked by quicksilver (bored now, sorry)
07:03:24 <paczesiowa> thx
07:03:50 <paczesiowa> Stinger: I'll try in vmware
07:03:59 <Stinger> heh don't go out of your way
07:04:07 <guenni> quicksilver: is it complete?
07:04:13 <Stinger> 8.0 is going to be plenty fine for me for the present
07:04:34 <quicksilver> guenni: well, it's self-contained if that's what you mean.
07:04:47 <quicksilver> it doesn't need anything else to compile
07:04:50 --- mode: quicksilver set -o quicksilver
07:05:17 <guenni> quicksilver: actually I meant if hpaste cut off some of the code you pasted
07:06:15 <quicksilver> nope
07:06:22 <guenni> quicksilver: good
07:06:30 <quicksilver> it was quite easy relaly :)
07:06:30 <guenni> quicksilver: it sometimes does
07:06:36 <quicksilver> just took some time to get used to the combinators
07:06:57 <guenni> quicksilver: which version did you use?
07:07:22 <quicksilver> now that is a good question.
07:07:24 <quicksilver> let's see
07:07:33 <guenni> quicksilver: lol
07:07:40 <quicksilver> 1.19.2
07:07:42 <quicksilver> apparently.
07:08:08 <guenni> quicksilver: I understand that's the dev branch?
07:08:22 <guenni> I mean that's why I installed 1.13
07:08:27 <quicksilver> yes, it is.
07:08:32 <quicksilver> I bet there was a good reason I chose it.
07:08:36 <quicksilver> I'm afraid I can't remember what it was :(
07:08:41 <guenni> quicksilver: ok
07:08:57 <quicksilver> it's all pure functions so it can't do any harm :)
07:09:15 <guenni> quicksilver: thx quick, I'll start playing with it then
07:09:20 <quicksilver> unstable libraries of pure functions are much safer than unstable libraries of missile control systems.
07:09:39 <guenni> quicksilver: I might come back in tears though :)
07:10:11 <guenni> quicksilver: you don't have a problem with a man crying do you?
07:11:07 <Samy> lambdabot is back!
07:11:14 <Samy> Cale, ping?
07:11:26 <quicksilver> guenni: no. malcolmw will also help you if he's around.
07:11:34 <quicksilver> guenni: (he is one of the main authors of haxml)
07:11:49 <guenni> quicksilver: k
07:21:39 <guenni> quicksilver: qould you have a sample xml for me too?
07:22:04 <quicksilver> guenni: you mean a sample PList that my code words on?
07:22:06 <quicksilver> works on
07:22:17 <guenni> quicksilver: yep
07:22:24 <BeelsebobWork> quicksilver: oh, you got plist parsing for Haskell?
07:22:35 <quicksilver> BeelsebobWork: the XML variety of plist, yes.
07:22:38 <BeelsebobWork> shiny
07:22:47 <BeelsebobWork> you know binary plists are just gzipped xml?
07:22:51 <quicksilver> BeelsebobWork: http://hpaste.org/9543
07:22:56 <quicksilver> BeelsebobWork: there is also the old-style text format.
07:22:59 <quicksilver> I didn't try that.
07:23:02 <BeelsebobWork> oh, okay
07:23:08 <BeelsebobWork> unless they changed that to sqlite or something
07:23:09 <quicksilver> NeXT-stylee
07:23:52 <quicksilver> guenni: if you have acess to a Mac, you have hundreds of them.
07:23:57 <quicksilver> Otherwise I'll try to find one.
07:24:00 <BeelsebobWork> quicksilver: how come dictionaries aren't Data.Maps?
07:24:21 <quicksilver> PLDict (Map String PListElem)
07:24:23 <quicksilver> they are?
07:24:44 <BeelsebobWork> P1Elt = ... | D [P1Elt] |...?
07:24:44 <guenni> quicksilver: true, sry, I do have a Mac
07:24:53 <BeelsebobWork> oh, I see
07:24:55 <quicksilver> BeelsebobWork: that's the first phase parser.
07:25:08 <quicksilver> it was easier to express in two layers.
07:25:18 <quicksilver> Or, that's way my brain saw the problem.
07:26:40 <guenni> btw: how can I uninstall a package from GHC?
07:26:49 <audreyt> ghc-pkg unregister package
07:26:56 <guenni> thx
07:27:24 <paczesiowa> dcoutts: couldn't cabal-install auto download package list where it's not present?
07:27:38 <audreyt> if that doesn't work, try: ghc-pkg --user unregister package-0.0.1
07:27:50 <dcoutts> paczesiowa: yeah, but it doesn't help much, since users need to know to download it later too
07:28:06 <guenni> when it comes to plain parsing is Parsec the way to go?
07:29:56 <audreyt> sure, though I slightly prefer attoparsec nowadays...
07:31:19 <quicksilver> I've never really got into parsing librarys because it's so easy to write your own parser.
07:31:29 <quicksilver> but I prefer the 'feel' of polyparse to parsec.
07:32:29 <paczesiowa> where is config.log from failed installs on windows?
07:33:39 <paczesiowa> dcoutts: why not try to update on every cabal upgrade and on every package not found?
07:33:53 <dcoutts> paczesiowa: you might be offline
07:34:12 <guenni> oh and can anybody recommend a realy good editor/ide?
07:34:51 <paczesiowa> geany
07:34:59 <trofimovich> > succ."Dl`br"
07:35:00 <lambdabot>  "Emacs"
07:35:12 <Tobsan> lol
07:35:41 <guenni> right, I did ask for that didn't I?
07:36:37 <quicksilver> emacs is certainly a good editor, and it does everything I need from an IDE.
07:36:52 <quicksilver> type-sensitive autocode would be very cool, but it's not easy for haskell.
07:37:00 <paczesiowa> quicksilver: does it compile haskell code?
07:37:02 <quicksilver> significantly harder than the C++/C#/Java case.
07:37:10 <trofimovich> haskell-mode/run-haskell
07:37:15 <quicksilver> paczesiowa: yes, it does.
07:37:15 <paczesiowa> quicksilver: does it highlight errors from ghc?
07:37:27 <quicksilver> although what I actually use sends it to ghci, rather than compiling.
07:37:39 <quicksilver> I think you can get error highlighting but I've never used it.
07:37:43 <trofimovich> it does it improperly
07:38:02 <trofimovich> it messes line numbers/line offsets
07:38:19 <paczesiowa> geany does it without configuration
07:38:41 <paczesiowa> (and I'm proud user if emacs for 5 days myself!)
07:38:44 <paczesiowa> *of
07:38:44 <guenni> quicksilver: so how did you get the hpaste code so neatly aligned?
07:39:21 <quicksilver> guenni: align-regexp
07:39:31 <quicksilver> well some of the alignment is automatic
07:39:38 <quicksilver> sometimes I alignw ith align-regexp.
07:39:41 <guenni> using?
07:39:56 <quicksilver> align-regexp is an emacs command.
07:40:08 <quicksilver> for example, the '=' signs which are aligned in the defn of makeVal
07:40:14 <quicksilver> that was M-x align-regexp =
07:40:21 <guenni> quicksilver: you just outed yourself :)
07:40:37 <quicksilver> on the other hand, the data definitions are aligned like that automatically.
07:40:49 <quicksilver> It's hardly a secret. I'm visibly in the #emacs channel ;P
07:41:05 <guenni> well I'm using Eclispse right now
07:41:09 <guenni> and hate it
07:41:22 <quicksilver> I used eclipse very briefly for a java project I abandoned
07:41:26 <quicksilver> I quite liked it for java
07:41:31 <quicksilver> but I don't think it works for other languages.
07:41:33 <therp> in category theory, is it common to denote use <a,b> as the notion for an arrow targeting a tuple like this (in point-wise notation) <a,b> x = (a x, b x)? Wadler used that notation
07:41:33 <guenni> true
07:41:57 <quicksilver> therp: I don't think it's particularly common, no.
07:42:01 <quicksilver> therp: but it's fairly 'obvious'
07:42:03 <vixey> therp: in haskell we write (a &&& b)
07:42:04 <quicksilver> IYSWIM.
07:42:16 <quicksilver> one of a number of sensible notations you might choose.
07:42:25 <therp> quicksilver: because the types of the functions involved suggest that...
07:42:38 <opqdonut_> i've seen (f,g)
07:43:09 <quicksilver> paczesiowa: geany has haskell support?
07:43:13 <therp> vixey: this paper is from 1990.. presumably pre-Haskell time
07:43:28 <vixey> k...
07:43:32 <vixey> I'm just talking about #haskell
07:43:50 <therp> :t (&&&)
07:43:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:46:54 <paczesiowa> quicksilver: yes
07:47:43 <greekcasino> hi
07:58:27 <mauke> http://dis.4chan.org/read/prog/1215889923/83
07:58:30 <lambdabot> Title: 4chan BBS - /prog/ Culture Thread
07:58:32 <hask> what do you gus thin of Ocaml?
07:59:01 <hask> and is the Dr Jon Harrop a knowledgeable guy or a troll?
07:59:12 <vixey> hask: lol
07:59:17 <quicksilver> hask: both
07:59:43 <paczesiowa> great module system, ascetic syntax with macro system. polymorphic variants are nice
08:00:13 <quicksilver> ocaml is a nice language but on balance I find its deficiencies relative to haskell annoying.
08:00:40 <quicksilver> I used it for a couple of research projects before deciding haskell was my choice
08:00:50 <paczesiowa> but it's not pure
08:01:11 <quicksilver> yes, that's a key disadvantage
08:01:24 <quicksilver> impure; value restriction; constructors not functions.
08:02:08 <flux> "The next haskell will be be strict; the next ml will be pure" :-)
08:02:27 <paczesiowa> constructors not being functions can be easily fixed with a macro I think
08:02:44 <quicksilver> you're probably right but it's annoying to have the problem in the first place.
08:03:30 <paczesiowa> quicksilver: do you understand value restriction?
08:03:49 <quicksilver> yes; I understand it to be a pretty much required consequence of impurity.
08:03:59 <quicksilver> but it remains annoying in practices.
08:04:06 <quicksilver> makes combinator libraries much clumsier.
08:04:12 <paczesiowa> quicksilver: could you give example what can go wrong without it?
08:04:26 <mauke> unsafeCoerce in terms of unsafePerformIO
08:04:38 <quicksilver> consider any expression which would have been affected by the value restriction.
08:04:44 <quicksilver> then add a side-effecting part to it.
08:04:59 <quicksilver> it's the same "problem" as the monomorphism restriction and haskell.
08:05:03 <quicksilver> but the consequences are worse
08:05:04 <vixey> constructors are functions. ...
08:05:06 <vixey> ?
08:05:06 <quicksilver> (not just a lack in sharing)
08:05:10 <quicksilver> vixey: not in ocaml, no.
08:05:19 <vixey> oh right ocaml
08:05:24 <vixey> I thought we were talking about haskell
08:05:45 <quicksilver> well we are :) haskell compared to ocaml.
08:05:45 <mauke> let v = ref []
08:05:47 <paczesiowa> yeah, once I was translating parsec code to ocaml and was pita to understand those cryptic errors that would mean value restricton in chineese
08:05:48 <vixey> Is haskell an ML ?
08:05:51 <quicksilver> its' one of the differences which annoys me.
08:05:53 <mauke> v : 'a list reference
08:06:01 <vixey> mauke: doesn't that break value restriction ?
08:06:06 <mauke> vixey: exactly
08:06:21 <quicksilver> haskell meets many/most of the goals of the original ML project
08:06:31 <quicksilver> but it isn't normally regarded as a member of the ML family.
08:06:55 <Quadrescence> I AM A PAR-SER MONADIC COMBI-NA-TOR, I WILL DESTROY YOU.
08:06:55 <lambdabot> Quadrescence: You have 1 new message. '/msg lambdabot @messages' to read it.
08:07:19 <paczesiowa> iirc normal code would throw nice errors about VR but if it was nested in let recs errors would get totally stupid
08:08:32 <quicksilver> I think SPJ even mentioned the value restriction as being an abstraction problem in one of his haskell talks.
08:08:35 <quicksilver> hair shirt, perhaps.
08:09:17 <paczesiowa> mauke: pls continue that example, I still don't get it
08:10:07 <mauke> paczesiowa: well, now you have a polymorphic reference. you can v := ["wtf"]; !v + 1
08:10:22 <mauke> that'll type because 'a can be instantiated to string and int
08:10:33 <mauke> er
08:10:34 <guenni> quicksilver: I might be using your script wrongly but it gives me an "Ran out of input"
08:10:46 <Quadrescence> paczesiowa: Check out geany? :D
08:10:47 <mauke> List.hd (!v) + 1 or something
08:11:22 <paczesiowa> I had problems with parsec code like foo = bar that I had to solve like foo st = bar st
08:11:59 <paczesiowa> how is that related to those ref examples
08:12:17 <guenni> quicksilver: neva mind, my mistake, did I mention that I'm not that smart?
08:12:21 <quicksilver> ;)
08:12:51 <quicksilver> the ref example gets solved if you add a spurious parameter
08:12:57 <quicksilver> v st = ref []
08:13:02 <quicksilver> or v () = ref []
08:13:04 <paczesiowa> Quadrescence: yeah, pretty nice for beginners, but I don't like key bindings
08:13:07 <quicksilver> because that defaults sharing.
08:13:12 <Quadrescence> paczesiowa: Ah.
08:13:13 <Quadrescence> ;)
08:13:18 <quicksilver> so each time you call it you get a different isntance, which is safe.
08:13:26 <quicksilver> defeats sharing.
08:13:32 <quicksilver> fingers do not type as I instruct them to!
08:13:36 * quicksilver bites one off.
08:13:43 <paczesiowa> Quadrescence: but compile and error highligting by default is great
08:14:21 <paczesiowa> quicksilver: smells like MR
08:14:24 <quicksilver> there was a flymake hack for error highlighting in emacs I think.
08:14:27 <quicksilver> paczesiowa: yes, it's very similar.
08:14:37 <quicksilver> paczesiowa: they are two variants of the same idea.
08:14:55 <quicksilver> but impurity makes it worse, since the side effects are unrestricted.
08:16:01 <paczesiowa> quicksilver: thanks, I'll have to think about it some more with ocaml repl handy
08:19:25 <guenni> ok I can tell it's time to dig into those Monads again
08:19:34 <guenni> and figure out what fmap means
08:19:48 <mauke> fmap is simpler
08:19:51 <mauke> @src Functor
08:19:52 <lambdabot> class  Functor f  where
08:19:52 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:20:19 <quicksilver> guenni: if you're looking at xmlParse f `fmap` readFile f
08:20:26 <quicksilver> that is shorthand for
08:20:38 <quicksilver> contents <- readFile f ; return (xmlParse f contents)
08:20:45 <quicksilver> in a do block.
08:20:49 <guenni> mauke: nice job, now I gotta think about Functor too :)
08:21:02 <mauke> guenni: do you know how map works?
08:21:06 <guenni> yes
08:21:14 <mauke> Functor generalizes it to other containers
08:21:23 <mauke> e.g. Maybe
08:21:34 <mauke> > fmap (+1) [1,2,3]
08:21:35 <lambdabot>  [2,3,4]
08:21:37 <mauke> > fmap (+1) (Just 4)
08:21:39 <lambdabot>  Just 5
08:22:02 <guenni> >map (+1) [1..3]
08:22:26 <mauke> space
08:22:27 <guenni> huh?
08:22:39 <guenni> did I break it?
08:22:47 <tromp> >()
08:22:53 <tromp> > ()
08:22:54 <lambdabot>  ()
08:23:01 <guenni> ic
08:23:01 <tromp> try space after >
08:23:05 <Quadrescence> > [5 .. 5]
08:23:07 <guenni> > map (+1) [1..3]
08:23:07 <lambdabot>  [5]
08:23:09 <lambdabot>  [2,3,4]
08:24:07 <guenni> I so gotta do more Monad Tutorials
08:24:18 <hask> lambdabot write me a program to win the netflix challenge, well split 99/1 me/you k thanks
08:24:30 <opqdonut> :D
08:24:41 <mauke> guenni: understanding monads is pointless; just use them
08:24:54 <opqdonut> ITYM merely understanding
08:25:35 <hask> anyone interested in the netflix challenge? I am working on it, I have only written the parsing part so far and now im improving ont he speed by shifting to bytestrings but will start with the real "recommendation engine "soon
08:25:59 <hask> im working on it in haskell...
08:26:19 <hask> my first bigger projec tin haskell, only wrote a spamfilter before that
08:27:24 <paczesiowa> curl fails to install under cygwin
08:27:45 <paczesiowa> after installing curl-devel it can configure successfully
08:28:02 <paczesiowa> but fails on compile with curl.h not found:/
08:28:04 <sioraiocht> dcoutts: ping?
08:30:00 <dcoutts> sioraiocht: pong
08:30:49 <geezusfreeek> i think i'm gonna finally try the netflix challenge
08:32:11 <geezusfreeek> i don't know why i feel i must announce these things. i guess it's to hold me more accountable to them
08:32:38 <geezusfreeek> hask: woah, i didn't even see that you were just talking about it
08:32:47 <quicksilver> geezusfreeek: would you like us to ask you every day if you have completed it yet?
08:33:02 <geezusfreeek> quicksilver: ha, no :P
08:35:32 <hask> curl fails to install under cygwin
08:35:35 <hask> same for me
08:37:33 <lispy> guten morgen #haskell!
08:37:42 <audreyt> greetings lispy
08:37:46 <guenni> guten morgen
08:37:50 <mauke> moin moin
08:37:55 <Valodim> hoi :)
08:44:20 <sioraiocht> @src zipWith
08:44:21 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:44:21 <lambdabot> zipWith _ _      _      = []
08:47:36 <Quadrescence> > head [1,2,3,4,5]
08:47:38 <lambdabot>  1
08:48:27 <paczesiowa> @tell dons could you pass this http://hpaste.org/9625 to one of your friends?
08:48:27 <lambdabot> Consider it noted.
08:49:42 <lispy> heh, would the caml list really generate so much traffic as to bring down h.o?
08:50:03 <lispy> I find it unlikely that h.o would get slashdotted...
08:50:09 <paczesiowa> they do like side-effects
08:50:33 <Quadrescence> @src (!!)
08:50:34 <lambdabot> xs     !! n | n < 0 = undefined
08:50:34 <lambdabot> []     !! _         = undefined
08:50:34 <lambdabot> (x:_)  !! 0         = x
08:50:34 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:50:49 <Quadrescence> @src take
08:50:49 <lambdabot> take n _      | n <= 0 =  []
08:50:50 <lambdabot> take _ []              =  []
08:50:50 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
08:52:15 <trofimovich> am i one having problems with http://darcs.net/ ?
08:52:16 <lambdabot> Title: darcs
08:53:02 <mauke> works here
08:54:39 <hask> what is the type here?: http://hpaste.org/9628
08:55:05 <mauke> B.ByteString
08:56:33 <quicksilver> hask: B is the name you've imported the module as, so the type is B.ByteString.]
08:56:37 <quicksilver> erm
08:56:43 <quicksilver> .] is a typo ;)
08:56:52 <mauke> one eyed robot
08:57:07 <mmorrow> haha
08:58:04 <eu-prleu-peupeu> i have this data type:
08:58:21 <hask> ok works but i dont get it, why B.ByteString and not just B or Char8? im using char8 no?
08:58:37 <eu-prleu-peupeu> data Vector3 v = Vector3 { x :: v, y :: v, z :: } and i want it to be an instance of class Vector, how do i say that ?
08:58:51 <eu-prleu-peupeu> instance Vector (Vector3 v) where .... ?
08:58:57 <mmorrow> hask: because you made it that way
08:59:14 <quicksilver> hask: ByteString is the name of the type.
08:59:15 <paczesiowa> @src Vector
08:59:16 <lambdabot> Source not found. It can only be attributed to human error.
08:59:20 <quicksilver> hask: B is the name of the module.
08:59:26 <quicksilver> (well it's the local name you have given the module)
08:59:29 <hask> but removing as B and using ByteString doesn't work
08:59:48 <mauke> is it still qualified?
09:00:01 <hask> yes
09:00:06 <mauke> there you go
09:00:08 <quicksilver> eu-prleu-peupeu: yes, instance Vector (Vector3 v) is correct.
09:00:17 <quicksilver> eu-prleu-peupeu: althugh, there might be a context required.
09:00:24 <hask> but I want it to be no? otherwise I get naming conflicts
09:00:25 <quicksilver> instance Num v => Vector (Vector3 v) possibly
09:01:05 <mauke> hask: yes, but that means you have to use fully qualified names
09:01:07 <hask> i removed qualified and now i can refer to bytestring
09:01:24 <mauke> Data.ByteString.Char8.ByteString
09:01:30 <hask> so easier and preferrable with as B and B.ByteString ?
09:01:39 <mauke> that's what I do
09:01:51 <hask> ah ok I see
09:02:04 <mauke> you could also say 'import Data.ByteString.Char8 (ByteString)' in the third line to get the typename as-is
09:02:25 <quicksilver> I normally do this for map:
09:02:32 <quicksilver> import qualified Data.Map as Map
09:02:36 <quicksilver> import Data.Map(Map)
09:02:43 <quicksilver> so I can use the type unqualifed and everything else qualified.
09:02:48 <eu-prleu-peupeu> i have this error: http://hpaste.org/9629
09:02:49 <quicksilver> for example.
09:02:56 <mmorrow> hask: http://hpaste.org/9630
09:03:07 <mauke> eu-prleu-peupeu: missing ( )
09:03:09 <quicksilver> eu-prleu-peupeu: you're missing parens in Vector3 x1*x2 y1*y2 z1*z2
09:03:17 <quicksilver> (x1*x2) (y1*y2) (z1*z2)
09:03:25 <quicksilver> otherwise it parses as:
09:03:37 <quicksilver> (Vector3 x1) * (x2 y1) * (y2 z1) * z2
09:03:40 <quicksilver> which isn't what you want.
09:03:59 <eu-prleu-peupeu> oh...
09:04:16 <mmorrow> hask: you can qualify names /without/ adding "qualified". But, if you add "qualified", then you /can't/ refer to imports from there without the qualifier.
09:04:36 <hask> I want everything to be as normal but just ByteString insetad of normal String
09:04:36 <hask> be able to perform same operations if possible
09:04:36 <hask> So I just have to change a small part of my program
09:04:38 <eu-prleu-peupeu> and i have to pass 'v' arround i guess
09:04:44 <mmorrow> you can also have multiple import stmts involving a single module
09:05:20 <quicksilver> If you wanted "take", "drop" and "length" [and all the other list functions] to magically know if they were dealing with a ByteString or a list, you need them to be in a typeclass.
09:05:33 <mmorrow> hask: the only think is, a lot of the function in ByteString have the same names as Prelude functions. so, you have to qualify ByteString or only import a subset of it
09:05:34 <quicksilver> for a variety of reasons this is not how ByteString was designed.
09:09:28 <besiria> @list
09:09:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:10:13 <besiria> @src Monad
09:10:14 <lambdabot> class  Monad m  where
09:10:14 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:10:14 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:10:14 <lambdabot>     return      :: a -> m a
09:10:14 <lambdabot>     fail        :: String -> m a
09:11:06 <besiria> how fail function works? The string is a text for exception but the type that is returned has any meaning?
09:11:18 <kpreid> besiria: it depends on the particular monad
09:11:29 <kpreid> > fail "boo" :: Either String Int
09:11:31 <lambdabot>  Left "boo"
09:11:50 <kpreid> > fail "boo" :: [Int]
09:11:52 <lambdabot>  []
09:11:54 <kpreid> > fail "boo" :: Maybe Int
09:11:56 <lambdabot>  Nothing
09:11:58 <kpreid> > fail "boo" :: IO Int
09:12:00 <lambdabot>  Exception: "<IO Int>"
09:12:12 <quicksilver> besiria: it's a mistake for it to be in Monad, since not all Monads support a userful kind of failure
09:12:38 <quicksilver> but several of them do.
09:13:05 <besiria> i don't understand the purpose of the type that is returned
09:13:13 <paczesiowa> > fail "boo" :: State Int Int
09:13:15 <lambdabot>        add an instance declaration for (Show (State Int Int))
09:13:31 <paczesiowa> > runState 0 $ fail "boo" :: State Int Int
09:13:33 <lambdabot>  Couldn't match expected type `State Int Int'
09:13:40 <paczesiowa> > runState 0 (fail "boo" :: State Int Int)
09:13:41 <lambdabot>        add an instance declaration for (Num (State (State Int Int) a))
09:13:46 <Deewiant> > runState (fail "boo" :: State Int Int) 0
09:13:47 <lambdabot>  Exception: boo
09:14:02 <paczesiowa> I knew that!
09:14:42 <quicksilver> besiria: The purpose is to indicate that you can fail whatever type is expected.
09:14:51 <quicksilver> besiria: the most enlightening examples is probably Either.
09:14:59 <quicksilver> If you are familiar with the Either type.
09:15:19 <quicksilver> :t Left "boo"
09:15:21 <lambdabot> forall b. Either [Char] b
09:15:36 <quicksilver> Left "boo" is a valid value of type Either String Int, but it's also a valid value of type Either String Double
09:15:46 <quicksilver> and Either String [[(Int,Double,String]] etc.
09:15:58 <quicksilver> that's archetypal for how a monad might store failure out of band.
09:17:58 <besiria> ok got it
09:18:23 <quicksilver> an important thing about monads is that "m a" need not actually contain a value of type a.
09:18:31 <quicksilver> In principle it is a computation returning a.
09:18:40 <quicksilver> But that computation might fail, or return multiple values, etc.
09:18:57 <quicksilver> different monads have different caveats.
09:19:19 <mmorrow> and sometimes it will never return at all
09:20:15 <mmorrow> (throw an exception which is meant to be caught, or call error and end the program, or exit cleanly, or segfault, ...)
09:23:12 <mmorrow> or forkIO with a Chan ...   so (m :: Chan String -> IO ()) , and then let m c = forever (writeChan c "qwerty") in (do c <- newChan ; forkIO (m c) ; <proceed-to-dump-the-chan/whatever>)
09:23:48 <mmorrow> you should really do though,
09:23:55 <Quadrescence> I am going to ask this channel a big favor. I have several functions to be written in Haskell, and I don't know how to write them /efficiently/. I made procedural pseudocode out of old code I made.
09:24:03 <Quadrescence> More information is in the paste: http://nopaste.com/p/aefgL0rKv
09:24:21 <Zao> Quadrescence: main = magicFunction 0x42
09:24:36 <Quadrescence> wut
09:25:49 <Stinger_> I dont think douglas adams had hexidecimal in mind
09:25:51 <Zao> @faq can Haskell do Quadrescence's code?
09:25:51 <lambdabot> The answer is: Yes! Haskell can do that.
09:26:00 <quicksilver> o2idx or v = foldr 0 (\t el -> t * v + el) or
09:26:03 <quicksilver> Quadrescence: I think.
09:26:12 <quicksilver> maybe that helps you head in the right direction.
09:27:21 <Quadrescence> quicksilver: Thanks. :)) Maybe you actually read the thing -- though I requested translation, I am more looking for help. And that will help. :>
09:28:16 <quicksilver> idx2o can also be a fold, a fold over [1..n]
09:28:35 <quicksilver> folds are typically the replacement for for loops.
09:28:40 <quicksilver> maps are a particular kind of fold.
09:30:16 <mmorrow> ..got distracted, so  ....  do mvar <- newEmptyMVar ; c <- newChan ; forkIO ((replcateM 1000 putStrLn "qwerty") `finally` putMVar mvar ()) ; takeMVar mvar ; exitWith ExitSuccess)
09:31:07 <mmorrow> err, didn't use the chan there .. s t i l l w a k i n g up
09:35:36 <Quadrescence> Would most "naive translations" of imperative code probably result in strict evaluation?
09:35:44 <Quadrescence> (I know it depends...but...)
09:37:17 <quicksilver> no.
09:37:30 <mmorrow> hmm, i think a "naive" translation would fail to be strict enough, and have poor performance
09:37:33 <quicksilver> depending what you mean by naive translation.
09:37:42 <quicksilver> most naive haskell code will be lazy evaluatio.
09:38:36 <mmorrow> hehe, it's the /non/-naive translation of the imperative code that is as strict as it can be, but lazy when it needs it
09:45:17 <Quadrescence> quicksilver: Hah, you should have seen my attempts at rewriting it.
09:45:25 <Quadrescence> They were not very good, not working well. D:
09:45:42 <Quadrescence> o2idx acc t maxo
09:45:42 <Quadrescence>     |acc == 1             = o2idx (acc+1) (head maxo) maxo
09:45:42 <Quadrescence>     |acc > 1 && acc < len = o2idx (acc+1) (t*len + (maxo !! acc)) maxo
09:45:42 <Quadrescence>     |acc == len           = t*len + (maxo !! acc)
09:45:42 <Quadrescence>         where
09:45:43 <Quadrescence>             len = length maxo
09:45:46 <Quadrescence> (for example)
09:45:48 <Quadrescence> :|
09:46:42 <Deewiant> traversing using length and !! isn't a good idea
09:46:49 <Quadrescence> I know.
09:47:04 <Quadrescence> That is what I would call a "naive translation"
09:47:34 <Deewiant> yes, quite naïve :-)
09:48:27 <Quadrescence> for i = n to 1
09:48:27 <Quadrescence>   or[i] = t mod v
09:48:27 <Quadrescence>   t = t / v
09:48:27 <Quadrescence> endfor
09:48:28 <Quadrescence> return t
09:48:34 <Quadrescence> How would that be done efficiently?
09:48:44 <Quadrescence> (i.e. constructing a list in that way)
09:48:57 <Quadrescence> (kind of the opposite of before)
09:51:27 <rog> hi, i'm new to haskell, and experimenting with trying to write idiomatic code while getting my work done. i've got a tiny sample function that implements value discounting (http://greenbook.treasury.gov.uk/annex06.htm). how could i do this better?
09:51:55 <rog> oops hpaste doesn't seem to work
09:52:41 <rog> link to code at http://hpaste.org/9632#a0
09:53:16 <rog> ta for any input!
09:53:54 <Quadrescence> funktio: !!
09:53:57 <Quadrescence> my main man
09:55:53 <rog> in particular it'd be great if anyone might have some comments on the superficialities of the code, e.g. "i'd usually do things this way instead".
09:56:43 <encryptio> Quadrescence: break it down into more operations, define each piece, and concatenate. ignore efficiency for the first revision - make it work, then make it fast
09:56:48 <vixey> rog: rewrite it using a fold
09:57:32 <encryptio> Quadrescence: to me, it looks like it's mainly a map and fold. unfortunately, i can't understand that code well enough to give you more details
09:57:50 <Quadrescence> I'll keep map/fold in mind.
09:58:30 <rog> vixey: i thought about that, but i couldn't think of a straightforward way of doing it - the alg only traverses some of the discountfactors list, and fold[lr] always traverses the whole list, no?
09:59:52 <encryptio> rog: (foldl (\x y -> x) 1 [5..20]) doesn't "use" any of the list
10:03:30 <rog> encryptio: no?  foldl (\a b -> a) 0 (cycle [4]) seems to yield bottom to me.
10:03:46 <encryptio> you're not reading an infinite list.
10:04:21 <vixey> > foldl (\a b -> a) 0 (cycle [4])
10:04:28 <lambdabot> Terminated
10:04:38 <vixey> > foldr (\a b -> a) 0 (cycle [4])
10:04:40 <lambdabot>  4
10:04:41 <trofimovich> @src cycle
10:04:42 <lambdabot> cycle [] = undefined
10:04:42 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
10:05:04 <vixey> cycle = concat . repeat
10:05:37 <rog> i hadn't seen repeat yet!
10:06:03 <rog> interesting about the foldr case. why the difference?
10:06:06 <ddarius> vixey: That would be a bad definition of cycle.
10:06:12 <rwbarton> rog: it looks like your code does  discount y = 1 / product (take y discounts) where discounts = (replicate 30 0.035 ++ replicate 45 0.03 ++ ... ++ repeat 0.01)
10:06:16 <rwbarton> rog: is that right?
10:06:30 <vixey> ddarius: why?
10:06:39 <ddarius> @src concat
10:06:39 <lambdabot> concat = foldr (++) []
10:07:35 <ddarius> vixey: Because it wouldn't create a cyclic list, it would just create an infinite one.
10:07:36 <Quadrescence> :t foldr
10:07:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:07:38 <vixey> > concat . repeat $ [1,2,3
10:07:39 <lambdabot>  Parse error at end of input
10:07:44 <vixey> > concat . repeat $ [1,2,3]
10:07:46 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
10:08:19 <vixey> @src repeat
10:08:20 <lambdabot> repeat x = xs where xs = x : xs
10:08:33 <rwbarton> rog: I forgot about the 1 + 0.035, of course
10:09:07 <rog> rwbarton: almost. replace 0.035 etc with 1.035 etc
10:09:31 <vixey> I don't think there's any way you could have a compiler figure that out and make my definition as good as the other one
10:09:35 <rog> rwbarton: not a greatly efficient way of going about it though!
10:10:02 <rog> rwbarton: and it wouldn't work if y was fractional.
10:10:18 <encryptio> rog: read the source to foldr and foldl keeping laziness in mind, and you'll see why foldr on infinite lists might terminate
10:10:28 <vixey> > fix . (:) $ 1
10:10:30 <rwbarton> rog: No, if you wanted efficiency you'd probably precompute 1.035^30 * 1.03^40, and so on
10:10:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:10:40 <rwbarton> rog: Hmm, that's true.
10:11:12 <ddarius> vixey: Sure it could in general.
10:11:54 <vixey> is there any relations for foldr f z . fix ?
10:11:56 <rog> rwbarton: which is what my alg does. i'll experiment with writing it to use foldl and see what it looks like.
10:12:13 <rog> rwbarton: oops.
10:12:24 <rog> rwbarton: didn't see "precompute"
10:12:50 <rwbarton> rog: Yeah, I mean "if y <= 30 then ... else if y <= 75 then ..." :)
10:13:55 <vixey> > fix . (++) $ "xyz"
10:13:57 <lambdabot>  "xyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyz...
10:14:09 <vixey> how to prove foldr (++) [] . fix . (:) = fix . (++) ?
10:14:44 <rog> rwbarton: but i'd have to write the code to do the precomputation in the first place, which would look quite similar
10:14:50 <rog> :t fix
10:14:52 <lambdabot> forall a. (a -> a) -> a
10:16:14 <rog> what's "fix"? it doesn't seem to be in the prelude.
10:16:30 <vixey> rog: fix f = f (fix f)
10:16:35 <tromp> > fix error
10:16:49 <vixey> rog: fix (1:) = 1: (fix (1:)) = [1,1,1,1,1,1,1,...]
10:16:50 <lambdabot>  thread killed
10:17:03 <jberg> hey, my haskell-mode doesn't seem to do intelligent indentation, it's just a normal tab. i have 'turn-on-haskell-indent as a haskell-mode-hook, should i have something else?
10:18:11 <ddarius> @free fix
10:18:13 <lambdabot> f . g = h . f => f (fix g) = fix h
10:20:06 <Stinger_> man
10:20:16 <Stinger_> working out pointfree stuff in your head is fun
10:20:29 <ddarius> g = (x:)  f = concat = foldr (++) [], by fusion we get f . g = (x++) . concat so concat . fix . (:) = fix . (++)
10:20:36 <Stinger_> > join ((( . (+)). (.)) . ((,) . (*2))) 1 2
10:20:38 <lambdabot>  (2,3)
10:20:39 <jberg> does anyone know how i can get intelligent indentation working in emacs?
10:21:36 <Stinger_> unfortunately my programs become excercises in unreadibility
10:21:38 <trofimovich> M-x haskell-mode
10:21:49 <rog> ddarius: what does @free do? (lambdabot page on haskellwiki doesn't seem to help much!)
10:22:01 <ddarius> @help free
10:22:02 <lambdabot> free <ident>. Generate theorems for free
10:22:10 <ddarius> @google "Theorems for Free"
10:22:15 <vixey> woww
10:22:17 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
10:22:22 <vixey> I thought the free theorems were useless
10:22:26 <vixey> cool
10:22:26 <dons> ?yow
10:22:26 <Stinger_> there was a good video lecture about that
10:22:26 <lambdabot> Couldn't find fortune file
10:22:34 <ddarius> vixey: Free theorems are critical.
10:22:50 <Stinger_> howard curry isomorphisms (I think was what it was called)
10:23:33 <jberg> trofimovich: thanks, i think that made it work
10:23:36 <dons> http://www.reddit.com/r/programming/comments/6wbyo/slicing_open_the_belly_of_the_io_monad_in_an/
10:23:36 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:23:38 <lambdabot> Title: Slicing open the belly of the IO monad in an alternate universe : programming, http://tinyurl.com/6raeaj
10:25:08 <rog> @free foldr
10:25:10 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
10:25:39 <trofimovich> jberg: which extensions do you use? haskell-mode triggers on automatically for me if files are *.hs
10:27:38 <vixey> @let unfold f p = unfoldr (\x -> if p x then Nothing else Just (f x))
10:27:39 <lambdabot> Defined.
10:28:03 <vixey> @let hylo (f,p) (c,z) = unfold f p . foldr c z
10:28:04 <lambdabot> Defined.
10:29:48 <jberg> trofimovich: yeah, i thought mine did that too. but now im not sure if the indentation is working again.. if i do let s = something and then press enter and tab i would expect it to line up under s again, but it just tabs straight pass it
10:31:08 <trofimovich> M-x haskell-version
10:31:30 <dons> dcoutts: your mua is still sending lots of &&&&&&&&&&&&&&&&&&
10:31:32 <dons> it's weird.
10:31:55 <rog> ddarius: in the free theorem, is "=" the same as haskell's "=="; or is it a more general equivalence? (says he, trying to get through the paper quickly and needing to stop being distracted...)
10:31:57 <jberg> trofimovich: 2-4
10:32:25 <trofimovich> strange. mine too
10:32:27 <vixey> rog: it's certainly not haskells ==
10:33:38 <vixey> what can you do with hylo?
10:33:49 <vixey> http://en.wikipedia.org/wiki/Hylomorphism_(computer_science) ... seems useless ....
10:34:58 <trofimovich> jberg: my .emacs has (load "/usr/share/emacs/site-lisp/haskell-mode/haskell-site-file" nil t)
10:35:01 <dcoutts> dons: I tried switching the encoding from utf8 to iso-8850-1 (ie ascii)
10:35:23 <dcoutts> dons: but it doesn't seem to have helped you say
10:35:37 <jberg> trofimovich: hmm, mine doesnt have nil t, what does that do?
10:36:25 <trofimovich> i dunno :]
10:36:33 <pozic> jberg: cursor on load C-h f RET
10:36:51 <trofimovich> (load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
10:37:05 <dmhouse> It supresses the "Loading foo..." message.
10:37:57 <ddarius> rog: It's observational equality (more or less)
10:38:04 <vixey> where do free theorems come from :(
10:38:17 <ddarius> vixey: parametric polymorphism
10:38:18 <jberg> okay
10:38:49 <ddarius> vixey: The relationship between parametric polymorphism and (di)naturality makes it very easy to generate the theorems.
10:39:13 <jberg> but to the others who are using haskell-mode, is it supposed to indent properly if write let s = 1 + 2 and then press <enter> <tab>, like, put the cursor right under s?
10:39:19 <rog> ddarius: is there always exactly one free theorem?
10:40:00 <ddarius> rog: I believe there is at most one most general one.
10:40:47 <jberg> it does syntax highlighting and stuff, but the module is really unusable if it doesnt indent properly
10:41:10 <lament> try pressing tab more
10:42:22 <jberg> lament: i have, it just inserts normal tabs
10:42:53 <dmhouse> jberg: yes, that ought to work
10:42:57 <dmhouse> jberg: are you inside a function?
10:43:21 <dmhouse> jberg: well, rather, if you press TAB TAB it should.
10:43:37 <rog> @free (\a -> a)
10:43:37 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:43:46 <dmhouse> haskell-mode does "bounce indenting" where multiple presses of TAB cycles you between the valid indentation points.
10:43:54 <dmhouse> (Since there's more than one valid place to indent a haskell line.)
10:44:16 <jberg> dmhouse: yes im inside a function
10:44:23 <jberg> dmhouse: this does not do bounce indenting
10:44:26 <jberg> just inserts tabs
10:44:35 <rog> @free id
10:44:36 <lambdabot> f . id = id . f
10:44:38 <dmhouse> jberg: paste the relevant parts of your .emacs?
10:44:43 <jberg> okay, 2 sec
10:44:47 <ddarius> @free x :: a -> a
10:44:48 <lambdabot> f . x = x . f
10:45:09 <ski> @free seq
10:45:10 <lambdabot> g . seq x = seq (f x) . g
10:45:23 <ddarius> @ft seq
10:45:25 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
10:45:27 <jberg> http://rafb.net/p/o7Ji8b81.html
10:45:32 <lambdabot> Title: Nopaste - No description
10:45:40 <ddarius> @ft seq :: a -> b -> b
10:45:42 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
10:46:27 <dmhouse> jberg, that looks reasonable. What does C-h c TAB say?
10:46:39 <dmhouse> In haskell-mode, obviously.
10:47:01 <rog> @help ft
10:47:01 <lambdabot> ft <ident>. Generate theorems for free
10:47:20 <gwern> ooh, burn
10:47:22 <gwern> That wasn't the reason Jon. I doubt the caml-list would generate enough
10:47:22 <gwern> traffic anyway.
10:47:46 <dmhouse> gwern, context?
10:48:00 <dons> gwern: you got to play that internet game
10:48:18 <gwern> dmhouse: jdh suggested that traffic from a ocaml ml brought down haskell.org
10:48:27 <gwern> dmhouse: that was dons' witty retort
10:48:45 * gwern reminds self to stock up on churchillisms if I ever need to go 'gainst dons 
10:48:48 <dons> traffic -- discusssing ghc's move away from darcs -- which is jon's other jab.
10:49:08 <jberg> dmhouse: runs the command lisp-indent or something
10:49:22 <dmhouse> jberg: in haskell-mode? That's seriously wrong.
10:49:25 <jberg> err, i dont think i was in haskell-mode, let me try again
10:49:40 <dmhouse> It should be indent-for-tab-command.
10:50:02 <rog> sorry for the lambdabot noise - i've only just discovered i can have a private conversation with it (shows how much irc *i've* done)
10:50:03 <jberg> dmhouse: self-insert-command
10:50:28 <dmhouse> jberg: right, something in your .emacs is setting TAB to that, I think. Try it with emacs -q and see if the bounce indenting works there.
10:50:57 <jberg> ah okay, le me try
10:51:46 <jberg> dmhouse: so now i've opened a .hs file, do M-x haskell-mode?
10:51:51 <dmhouse> jberg: yep.
10:51:56 <jberg> no match
10:52:16 <dmhouse> (load "haskell-site-file")
10:52:27 <dmhouse> (Or rather, M-: that RET.)
10:53:41 <hask> How do I convert from Int or String to byteString?
10:53:45 <jberg> yay, now bounce indenting works
10:53:51 <dmhouse> hask: pack
10:54:01 <jberg> im going to see if i can find the thing that fucks up tab, thanks a lot
10:54:55 <jberg> ah, i have global-set-key for tab which sets it to self-insert-command
10:55:10 <jberg> how can i get a description for what self-insert-command does?
10:55:27 <vixey> jberg: M-x ielm
10:55:35 <vixey> (apropos 'self-insert-command)
10:55:38 <Dwaylu> What's the operand for matching a char in Java?
10:55:51 <dmhouse> jberg: it just inserts the key that you press.
10:55:55 <vixey> Dwaylu: 'matching'?
10:56:01 <jberg> dmhouse: okay
10:56:01 <BONUS_> you mean like == ?
10:56:11 <jberg> i wonder why i have that bound..
10:56:16 <dmhouse> jberg: e.g. all the alpha keys are bound to self-insert-command (except in modes like dired).
10:56:40 <Dwaylu> Yeah, but it gives back incompatible operand types char and String
10:56:43 <jberg> is it helpful to have it? or should i just remove the line
10:56:46 <Dwaylu> for ==
10:56:59 <dmhouse> jberg: you should never have TAB bound to self-insert-command.
10:57:20 <jberg> okay, removed it now.
10:57:55 <cizra> Hi
10:58:24 <dmhouse> jberg: incidentally, how the hell did you work in *any* programming mode before now?!
10:59:58 <jberg> dmhouse: beats me. i havent really used emacs for some while now, and the last time i used it i think i copied a bunch of stuff from some other .emacs
11:00:27 <jberg> that was probably not a good idea :)
11:00:42 <dmhouse> Heh. It can be, as long as you know what it does.
11:00:43 <jberg> thanks a lot though, this was really helpful
11:02:04 <hask> dmhouse thanks someone had tole m e I forgot
11:02:48 <cizra> I want to learn functional-programming-thinking. I have this graph, and I want to find all possible Hamiltonian paths beginning in a certain node. In imperative style, I'd just recurse depth-first over it, marking the vertices visited. How to tackle this kind of problem Haskellishly?
11:03:15 <vixey> cizra: You could just write that, it's fine
11:03:28 <Pudding> ispalindrome::(Eq a) => [a] -> Bool           ---What does the (Eq a) => [a] mean?
11:03:38 <BONUS_> Eq a is a class constraint
11:03:38 <Pudding> is it that a is an instance of Eq?
11:03:39 <vixey> Pudding, what ever 'a' is you can check == on it
11:03:43 <BONUS_> it means that a has to be an instance of Eq
11:03:45 <dmhouse> Pudding: yep.
11:03:59 <BONUS_> everything before the => is basically a class constraint
11:04:07 <Pudding> oki :), thx
11:04:10 <BONUS_> :]
11:04:54 <dmhouse> cizra: sounds like a good question for the haskell-cafe mailing list, you might get some more detailed answers.
11:05:13 <cizra> dmhouse: Oh, so it's not very obvious how to do this?
11:05:35 <vixey> I think it is simple..
11:05:42 <dmhouse> It probably is, but I've never looked at functional graph algorithms
11:06:12 <vixey> cizra: I would write the graph like this:
11:06:16 <vixey> graph 1 = [3,5,6]
11:06:22 <vixey> graph 2 = [1,
11:06:25 <vixey> etc.
11:06:33 <cizra> What is this "graph" thingy?
11:06:38 <cizra> .. in your syntax
11:06:45 <vixey> cizra: this is haskell syntax
11:07:14 <cizra> Is graph some kind of data type?
11:07:21 <vixey> yes
11:07:41 <cizra> OK
11:07:55 <vixey> graph :: Node -> [Node]
11:08:22 <dmhouse> cizra: the "graph" vixey was defining is a function from nodes to their adjacent nodes.
11:08:46 <cizra> OK, I see
11:08:50 <cizra> Oh!
11:08:57 <cizra> Right, this is that fabled pattern matching, right?
11:09:04 <dmhouse> Not yet.
11:09:24 <dmhouse> These are just equations. I suppose you could say 1 is a very simple patter that matches a 1 literal...
11:09:26 <cizra> graph N = [some list] -- this looks like pattern matching to me
11:09:44 <cizra> When you invoke graph 117, it'll look for it. Right. I see, vixey
11:10:35 <dmhouse> cizra: pattern matching only really gets interesting when you have variables in it that get bound to stuff.
11:10:55 <dmhouse> E.g. head (x:xs) = x, where (x:xs) is a pattern that binds x to the head of the list and xs to the tail
11:14:02 <cizra> dmhouse: I understand that
11:14:10 <cizra> dmhouse: And yet I consider that kind of pattern matching also interesting.
11:14:21 <cizra> dmhouse: Or at least the clever application of it.
11:15:09 <dmhouse> Okay. It's a pretty standard use of multiple equations, but I guess it's different to most other languages. The classic example is fibs:
11:15:21 <dmhouse> fibs 0 = 0
11:15:21 <dmhouse> fibs 1 = 1
11:15:25 <dmhouse> fibs n = fibs (n-2) + fibs (n-1)
11:16:14 <cizra> Yes, I know how it works.
11:16:49 <dmhouse> All right then.
11:17:46 <hask> yeah! refactoring :: functional programming -> static typing -> modularity
11:18:34 <dmhouse> Nice, #haskell specifically mentioned as an example of a helpful IRC channel: slide 11 of http://blog.davebsd.com/2008/06/09/5-rules-i-had-to-break-to-create-a-senior-project-that-rules/
11:18:39 <lambdabot> Title: David Siegel - The Plenitude of Arboreal Beauty » Blog Archive » 5 Rules I Had ..., http://tinyurl.com/6y59cl
11:18:46 <vixey> cizra: Do you want to see my code for this?
11:19:11 <cizra> vixey: Hmm, actually yes, but only after I try to write one myself. Gimme the link, I'll look at it later.
11:20:52 <vixey> http://hpaste.org/9635
11:20:59 <cizra> Thank you.
11:22:07 <mmorrow> > (\a@(Just(Left b@(_:_:xs,()),c@(_,Nothing))) -> ((c,xs),(a,b))) (Just (Left ([0..4],()),(42,Nothing)))
11:22:09 <lambdabot>  (((42,Nothing),[2,3,4]),(Just (Left ([0,1,2,3,4],()),(42,Nothing)),([0,1,2,3...
11:22:13 <mmorrow> :)
11:23:52 <mmorrow> > (\a@((_,b),c@(_,Just _)) -> (a,b,c)) (("123",[4..6]),([],Just []))
11:23:54 <lambdabot>  ((("123",[4,5,6]),([],Just [])),[4,5,6],([],Just []))
11:26:48 <vixey> :t hylo
11:26:49 <lambdabot> forall b a a1. (b -> (a, b), b -> Bool) -> (a1 -> b -> b, b) -> [a1] -> [a]
11:27:59 <vixey> > hylo (head &&& tail,(/=[])) ((:),[]) $ [1,2,3]
11:28:01 <lambdabot>  []
11:28:08 <vixey> > hylo (head &&& tail,(==[])) ((:),[]) $ [1,2,3]
11:28:10 <lambdabot>  [1,2,3]
11:28:16 <mmorrow> @src hylo
11:28:17 <lambdabot> Source not found.
11:28:38 <vixey> hylo (f,p) (c,n) = unfold p f . fold c n
11:28:55 <dmhouse> What on earth is that?
11:29:08 <vixey> I don't know yet :S
11:29:14 <vixey> I'm sure it's very good for something
11:29:38 <dmhouse> What's unfold? And which fold is fold?
11:30:24 <agcorona> 472 users?
11:30:31 <dons> at least.
11:30:36 <vixey> agcorona: PHP has like 700
11:30:44 <dons> ocaml has like 70
11:30:46 <agcorona> why so much people lately?
11:30:48 <dons> so we're well placed :)
11:30:57 <dons> agcorona: there's been steady growth since 2002 or so.
11:31:07 <dons> we actually hit 500 two weeks ago, for the first tiem.
11:31:22 <lament> 2009 will be the year of Haskell on the desktop.
11:31:27 <eu-prleu-peupeu> :D
11:31:29 <agcorona> I know, I checked it two months ago, and there were no more than 200
11:31:38 <eu-prleu-peupeu> i need help :/
11:32:11 <eu-prleu-peupeu> http://hpaste.org/9636
11:32:17 <eu-prleu-peupeu> this doesn't work, why ? :/
11:32:25 <eu-prleu-peupeu> i have tried many things
11:32:34 <eu-prleu-peupeu> i just can't seem to get the hang of syntax, nor find examples :/
11:32:35 <agcorona> some breaktrough this month? some mainstream news referring to haskell?  some new developments?
11:32:50 <int-e> eu-prleu-peupeu: instance Num v => Vector (Vector3 v) where
11:32:53 <Nafai> Hi byorgey
11:32:55 <dons> agcorona: only the usual :)
11:32:56 <agcorona> i can´t believe it
11:33:01 <dons> taking over the world as always
11:33:03 <eu-prleu-peupeu> Vector is a type class
11:33:05 <dons> one function at a time.
11:33:07 <agcorona> hehe
11:33:14 <dmhouse> agcorona: which mainstream news?
11:33:22 <eu-prleu-peupeu> ill upload the "whole" code
11:33:38 <agcorona> I don´t know, just asking why so much people
11:33:52 <int-e> eu-prleu-peupeu: the syntax is 'instance' [context '=>'] typeclass type 'where'
11:33:59 <BMeph> dmhouse: Have youread https://wiki.ittc.ku.edu/lambda/images/9/9e/Meijer_Functional_Programming_with_Bananas%2C_Lenses%2C_Envelopes%2C_and_Barbed_Wire.pdf? :)
11:33:59 <rwbarton> (not sure why you're multiplying vectors coordinate-wise, but...) try  instance Num v => Vector (Vector3 v) where ...
11:34:00 <eu-prleu-peupeu> http://hpaste.org/9637
11:34:02 <lambdabot> http://tinyurl.com/5zahdn
11:34:05 <int-e> eu-prleu-peupeu: the Num v is the context, so it goes before the class name
11:34:13 <eu-prleu-peupeu> ahh
11:34:14 <dmhouse> BMeph: never all the way through, and not recently at all.
11:34:14 <eu-prleu-peupeu> ok ok ok
11:34:36 <eu-prleu-peupeu> i was looking at the report, but it was too cryptic for a reference, without reading through some pages :/
11:35:08 <BMeph> dmhouse: Ah. Well, I suspect it's what vixey's slogging through now. :)
11:35:17 <eu-prleu-peupeu> alright!!
11:35:22 <eu-prleu-peupeu> it worked, thanks a lot man!
11:35:42 <int-e> no problem
11:37:11 <eu-prleu-peupeu> rwbarton: this is just a stupid test to learn the syntax of it :/
11:37:25 <BMeph> vixey: Am I right? :)
11:38:10 <eu-prleu-peupeu> now ill do dot product and cross product and mul by scalar :P
11:42:00 <skorpan> i can't seem to find the qty package, does anyone know where it is?
11:48:05 <skorpan> disregard that, i was looking for vty
11:51:17 <vixey> BMeph: No
11:51:37 <vixey> BMeph: I read it recently as it's one of the chapters in something else though
11:52:10 <BMeph> vixey: So, you're just wondering why have a hylomorphism? :)
11:52:19 <Apocalisp> What do I have if I partially apply xmap with id?
11:53:00 <vixey> ieys
11:53:01 <vixey> yes
11:53:10 <vixey> what can you write as a hylo
11:53:19 <Apocalisp> xmap :: ExpFunctor f => (a -> b) -> (b -> a) -> fa -> fb
11:53:45 <dons> woot, haskell jobs.
11:54:23 <BMeph> Apocalisp: A cofunctor? :)
11:54:52 <Quadrescence> let lf a = length $ filter (>(vec !! a)) $ drop a [1..20] in map lf [1..10]
11:55:00 <Quadrescence> > let lf a = length $ filter (>(vec !! a)) $ drop a [1..20] in map lf [1..10]
11:55:02 <lambdabot>   Not in scope: `vec'
11:55:06 <Quadrescence> oops. :|
11:55:12 <Quadrescence> > let lf a = length $ filter (>([1..20] !! a)) $ drop a [1..20] in map lf [1..10]
11:55:15 <lambdabot>  [18,17,16,15,14,13,12,11,10,9]
11:55:26 <Quadrescence> aha.
11:56:01 <Apocalisp> (xmap id, (`xmap` id)) -- what are these?
11:56:09 <Botje> functions!
11:56:42 <Botje> the latter is a section
11:56:50 <Botje> the first is just partial function application
11:56:56 <Apocalisp> BMeph: Smells like cofunctor, but not contravariant.
11:57:12 <byorgey> Apocalisp: using id forces a and b to unify to the same type
11:57:13 <vixey> can you write some cool program as a hylo?
11:57:22 <byorgey> so xmap id :: (a -> a) -> f a -> f a
11:57:23 <vixey> like a web application/
11:57:37 <byorgey> doesn't look very useful.
11:57:54 <hask> is this slow: files <- forM filenames readFile
11:57:57 <Apocalisp> byorgey: Exactly. I find myself using this quite a lot for a particular expfunctor, which makes me wonder if I really need expfunctor at all.
11:58:18 <byorgey> Apocalisp: hmm...
11:58:38 <byorgey> hask: not necessarily.  it depends on what you do with 'files'.
11:58:56 <byorgey> in fact, since readFile is lazy, that in and of itself will take no time at all =)
11:59:06 <hask> ok so the readFile isn't slow itself
11:59:25 <byorgey> well, it depends what you mean by 'slow'.
11:59:34 <byorgey> it should be perfectly fine for most uses.
12:00:06 <byorgey> but if you have very large files or care very much about squeezing every bit of speed out of it, then you might have to worry about strictness and/or using bytestrings.
12:00:07 <BMeph> vixey: Unlabelled trees? :)
12:00:24 <vixey> what about them ?
12:00:32 <byorgey> Apocalisp: what particular expfunctor, if I might ask?
12:00:34 <Apocalisp> "coinvariant functor"? :)
12:00:40 <byorgey> hehe
12:00:44 <hask> slow for reading 2G of data
12:01:08 <byorgey> hask: ah, you have 2G of data?
12:01:12 <BMeph> vixey: I wonder if it might be easier to do a functional program that enumerates them, as a hylo.
12:01:25 <byorgey> then you may want to look into using ByteStrings.
12:01:37 <byorgey> I don't have much experience with them personally, however.
12:01:47 <byorgey> they will certainly result in better memory usage.
12:02:11 <vixey> oh ok
12:03:22 <Apocalisp> byorgey: It's similar to Control.Parallel.Strategies.Strategy
12:03:27 <BMeph> vixey: I don't know if it is, but from what I've seen of the C and Pascal versions of the program, it might work better that way. :)
12:06:42 <Quadrescence> > [8..1]
12:06:44 <lambdabot>  []
12:06:47 <Quadrescence> > [8,7..1]
12:06:49 <lambdabot>  [8,7,6,5,4,3,2,1]
12:06:55 <eu-prleu-peupeu> im sorry, i have another stress
12:06:57 <Apocalisp> byorgey: F t reduces expressions of type t to values of type t.
12:06:58 <eu-prleu-peupeu> http://hpaste.org/9639
12:07:08 <eu-prleu-peupeu> how do i say that value is v ?
12:07:59 <byorgey> eu-prleu-peupeu: which one?
12:08:02 <eu-prleu-peupeu> maybe im overcomplicating :/
12:08:22 <eu-prleu-peupeu> in the type class i have dotProduct :: vec->vec->value
12:08:42 <eu-prleu-peupeu> this "value" is v in the case of the instance i have there...
12:08:48 <eu-prleu-peupeu> how do i say it ? :/
12:09:11 <eu-prleu-peupeu> ghci outputs "    Couldn't match expected type `value' against inferred type `v'"
12:09:23 <Quadrescence> eu-prleu-peupeu: Types should be capitalized
12:09:38 <Apocalisp> byorgey: So I guess really it's the invariant functor a -> a. :)
12:10:04 <eu-prleu-peupeu> Quadrescence: ok
12:10:37 <byorgey> Apocalisp: well, it's invariant at the type level, but for a particular type a, you can have useful functions of type  a -> a other than the identity.
12:11:14 <sebaseba> > map (+1) [1..10]
12:11:16 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:11:27 <Quadrescence> [1..10] !! 1
12:11:31 <Quadrescence> > [1..10] !! 1
12:11:33 <lambdabot>  2
12:12:11 <Apocalisp> ?type force
12:12:12 <lambdabot> forall a. (NFData a) => a -> a
12:13:48 <Apocalisp> I'm going to file xmap id under "comap" and (`xmap` id) under "fmap" in my brain. :)
12:18:44 <eu-prleu-peupeu> im having problems with the binding :/
12:18:55 <eu-prleu-peupeu> can someone help please: http://hpaste.org/9641
12:19:01 <Quadrescence> In a set of guards, once one case matches, are any other ones checked?
12:19:21 <Botje> no
12:19:42 <Quadrescence> e.g., |i==1; |i<10; |i == 10
12:19:44 <Apocalisp> Hah. It is called coinvariant in at least one paper.
12:19:45 <dmhouse> Once you cross the =, you can't go back.
12:19:55 <Quadrescence> Good
12:19:56 <Botje> :)
12:20:00 <Botje> a "=" too far :D
12:20:06 <Quadrescence> HAhahha :D
12:21:02 <byorgey> eu-prleu-peupeu: you will have to make 'value' a second parameter of the Vector type class.
12:21:32 <eu-prleu-peupeu> oh :/
12:21:41 <eu-prleu-peupeu> i guess ill be better limiting it to Double
12:22:08 <byorgey> e.g.  class Vector vec v where ...
12:22:23 <byorgey> and then  instance Num v => Vector (Vector3 v) v where ...
12:22:34 <byorgey> limiting it to Double would certainly be easier =)
12:23:13 <eu-prleu-peupeu> but it would not be l33t lol
12:23:33 <hask> Hmm the ByteString library seem to be overall much better than the regular String library, why not just replace the String library with ByteString library?
12:23:40 <rwbarton> "coinvariant functor"? what's that supposed to be?
12:24:51 <eu-prleu-peupeu> if i limit it to a Double, and then i pass it an Int, would haskell blow ?
12:24:57 <eu-prleu-peupeu> does it implicitly convert ?
12:25:42 <idnar> eu-prleu-peupeu: no, you'd have to explicitly convert
12:25:50 <Quadrescence> Haskell would tell you you got the wrong type
12:25:55 <eu-prleu-peupeu> hmm ok
12:25:58 <Quadrescence> That's the essence of Haskell!
12:26:03 <Quadrescence> Or part of it, at least.
12:26:16 <eu-prleu-peupeu> heheh
12:26:45 <eu-prleu-peupeu> good
12:26:47 <eu-prleu-peupeu> thanks
12:28:16 <hask> hey there is B.readFile so it is faster than readFile + B.pack
12:28:45 <rwbarton> hask: Yes, very much so!
12:28:47 <dcoutts> hask: yep
12:32:33 <Quadrescence> Anyone know the time complexity (O(?)) of (++)?
12:32:40 <Quadrescence> @src (++)
12:32:40 <lambdabot> []     ++ ys = ys
12:32:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:32:40 <lambdabot> -- OR
12:32:40 <lambdabot> xs ++ ys = foldr (:) ys xs
12:32:40 <lambdabot> -- In lambdabot, this is generalised to:
12:32:42 <lambdabot> (++) = mappend
12:34:26 <marcot> What's the name of the lambdabot's function that tries to simplify some function composition?
12:34:46 <trofimovich> @help lp
12:34:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:34:50 <marcot> Actually, I'm after something as toEnum . fromEnum .  I just noticed I use this all the time.
12:34:50 <stepcut> marcot: pl ?
12:34:56 <Quadrescence> pointless
12:35:04 <marcot> @pl toEnum . fromEnum
12:35:04 <lambdabot> toEnum . fromEnum
12:38:59 <Pudding> is there a function to see if a certain element is already in a list?
12:39:10 <trofimovich> @src elem
12:39:10 <lambdabot> elem x    =  any (== x)
12:39:36 <trofimovich> > 3 `elem` [1..]
12:39:38 <lambdabot>  True
12:39:44 <trofimovich> > (-1) `elem` [1..]
12:39:46 <lambdabot>  Tried to use too much memory
12:40:11 <Quadrescence> (-1) is a function, isn't it?
12:40:14 <Quadrescence> It
12:40:21 <Quadrescence> s kind of ambiguous, I think.
12:40:22 <trofimovich> @type (-1)
12:40:23 <lambdabot> forall a. (Num a) => a
12:40:43 <Quadrescence> > (-1) 5
12:40:45 <lambdabot>   add an instance declaration for (Num (t -> a))
12:40:47 <Pudding> thx trofiovich
12:41:14 <Quadrescence> > map (-1) [1..10]
12:41:16 <lambdabot>   add an instance declaration for (Num (a -> b))
12:41:19 <Quadrescence> Okay.
12:41:22 <trofimovich> > 7 `notElem` [2,4..1024]
12:41:22 <jberg> is there a function in the prelude which finds the index of the first element equal to something in a list?
12:41:24 <lambdabot>  True
12:41:41 <byorgey> Quadrescence: it is O(n) in the length of its left-hand argument.
12:41:50 <byorgey> jberg: yes, findIndex I think
12:41:53 <byorgey> @type findIndex
12:41:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:42:00 <byorgey> @index findIndex
12:42:01 <lambdabot> Data.List, Data.Map
12:42:05 <trofimovich> > (`-` 1) . [1..]
12:42:06 <lambdabot>  Parse error at "-`" (column 3)
12:42:07 <trofimovich> :]
12:42:08 <jberg> thanks
12:42:12 <byorgey> jberg: you may have to import Data.List to use it
12:42:18 <trofimovich> > (`(-)`` 1) . [1..]
12:42:19 <lambdabot>  Parse error at "(-)``" (column 3)
12:42:20 <jberg> okay
12:42:39 <jberg> byorgey: where can i find functions which are declared in modules like Data.List and stuff?
12:42:40 <byorgey> jberg: well, findIndex takes a predicate, so obviously in your case you can just say  findIndex (==foo)
12:42:51 <jberg> yep
12:43:32 <byorgey> jberg: http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:43:33 <lambdabot> Title: Haskell Hierarchical Libraries
12:43:48 <jberg> thanks
12:44:02 <byorgey> sure
12:44:37 <jberg> so what is all the stuff in Data? just extensions to the prelude?
12:45:07 <byorgey> jberg: well, you could think of it that way I guess. =)  they are just library modules.
12:45:21 <Quadrescence> for j = i+1 to max_of_pm
12:45:21 <Quadrescence>   if pm[j] >= pm[i] then pm[j] = pm[j] + 1
12:45:21 <Quadrescence> endfor
12:45:28 <Quadrescence> How might I do that in haskell?
12:45:35 <Quadrescence> pm :: [Int]
12:45:46 <byorgey> the Prelude is just the particular set of functions from 'standard' library modules which are deemed worthy of being automatically available without having to explicitly import anything.
12:45:46 <jberg> okay
12:45:51 <stepcut> jberg: the stuff in Prelude is just a collection of the most commonly used things from Data.* and other places
12:46:03 <jberg> i see, makes sense
12:46:10 <trofimovich> @src max
12:46:11 <lambdabot> max x y = if x <= y then y else x
12:46:39 <twanvl> > map (max 5) [1,2,3,4,5,6,7,8]
12:46:41 <lambdabot>  [5,5,5,5,5,6,7,8]
12:48:32 <trofimovich> maximum [10..20]
12:48:38 <trofimovich> > maximum [10..20]
12:48:40 <lambdabot>  20
12:49:11 <Beelsebob> I'd say that's a pretty convincing demonstration of the conciseness and clarity of Haskell
12:49:18 <Beelsebob> shorter, and clearer, both at the same time
12:49:33 <stepcut> > 20
12:49:35 <lambdabot>  20
12:49:42 <marcot> > [0 ..]
12:49:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:49:50 <marcot> > [0, 0 ..]
12:49:52 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:49:59 <marcot> > sum [0, 0 ..]
12:50:02 <lambdabot>  Tried to use too much memory
12:50:24 <Beelsebob> @pl clamp x = map (max x)
12:50:25 <lambdabot> clamp = map . max
12:50:30 <Beelsebob> >.<
12:50:33 <Beelsebob> why am I a moron?
12:50:43 <Quadrescence> You're not. :D
12:50:52 <Beelsebob> no really, that's obvious
12:51:11 <Quadrescence> So? :))
12:53:13 <Beelsebob> > [1,4,9..]
12:53:13 <lambdabot>  Parse error at "..]" (column 7)
12:53:36 <trofimovich> arith progression is defined by two elements and delimiter
12:53:53 <Beelsebob> yeh, it's a shame -- it would be nice to make it work for arbitrary polynomials
12:54:18 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/diffEngine.hs
12:54:24 <Beelsebob> and yes, I know it's because it desugars to enumFromTo
12:54:35 <trofimovich> and make it solve linear equations?
12:54:42 <newsham> how does it know that 1,4,9 is polynomial (and what order?)
12:54:57 <trofimovich> 3 dots - x^2 poly
12:55:03 <Beelsebob> newsham: because you can define it to be a polynomial (instead of linear as it is now)
12:55:04 <newsham> obviously ;-)
12:55:19 <Beelsebob> and the order is determined by how many times you difference the numbers and don't get a constant
12:55:34 <rwbarton> I think the closest syntax you could get is ([1,4,9]...)
12:55:37 <trofimovich> @go lagrange polynomial interpolation
12:55:39 <lambdabot> http://en.wikipedia.org/wiki/Lagrange_polynomial
12:55:39 <lambdabot> Title: Lagrange polynomial - Wikipedia, the free encyclopedia
12:55:44 <newsham> beelsebob: just write a difference engine function that takes the first n+1 values for order n
12:55:55 <Beelsebob> newsham: sure
12:56:14 <Beelsebob> but if the syntax is already there for a special case it would be nice to make it *slightly* less special
12:56:20 <newsham> poly [1,4,9]   is much worse than    [1,4,9,...]  ?
12:56:39 <Beelsebob> enumFromTo 1 10 is much worse than [1..10] ?
12:56:46 <newsham> yes, yes it is.
12:56:51 <newsham> enumFromTo is hard to type
12:56:56 <vixey> have you added new syntax to haskell?
12:57:10 <Beelsebob> vixey: no -- I'm suggesting *slightly* generalising existing syntax
12:57:16 <marcot> @pl fromMaybe nullPtr
12:57:17 <lambdabot> fromMaybe nullPtr
12:57:18 <Beelsebob> (or just removing it)
12:57:22 <vixey> no code?
12:57:24 <vixey> :/
12:57:44 <Beelsebob> what do you mean by "no code?"?
12:57:59 <newsham> beelsebob: so, [a..b] no longer works for Enums?
12:58:00 <rwbarton> > let (...) [x] = repeat x ; (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...) in ([1,4,9]...)
12:58:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
12:58:12 <Beelsebob> newsham: oh, fair point
12:58:25 <Beelsebob> also rwbarton: shiny
12:58:58 <hask> wtf I cant find a toInt in the ByteString library
12:59:01 <BMeph> Beelsebob: 1) Which polynomial should the computer pick; 2)Why? :)
12:59:07 <newsham> rwb: very nice.
12:59:18 <Beelsebob> BMeph: there's only one possible polynomial given a sequence of appropriate length
12:59:21 <dmhouse> 3) Who really needs that?
12:59:43 <Beelsebob> specifically, with 2 numbers, there are always only linear sequences..
12:59:45 <tromp> :t fromIntegral
12:59:45 <trofimovich> @hoogle fomIntegral
12:59:48 <trofimovich> @hoogle fromIntegral
12:59:51 <lambdabot> A Hoogle error occurred.
12:59:52 <Beelsebob> hence [1,5..] gives you a linear sequence
12:59:53 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:59:55 <lambdabot> A Hoogle error occurred.
12:59:57 <dmhouse> Beelsebob: erm, that's not true.
13:00:02 <BMeph> Beelsebob: Assuming your variable is not in an exponent,...maybe.
13:00:07 <dmhouse> Beelsebob: there's a unique polynomial with smallest degree.
13:00:12 <Beelsebob> yes, sorry
13:00:24 <dmhouse> But for example, y = x and y = x^2 both go through both (0,0) and (1,1).
13:00:26 <rwbarton> yeah I golfed that function a while ago :)
13:00:37 <vixey> that means that [1..] should be [1,1,1,1,1...]
13:00:48 <Beelsebob> vixey: interesting observation, yeh
13:00:50 <Dr_Zooix> Hello all.
13:01:11 <hask> fromIntregal converts to float
13:01:13 <dmhouse> Hi, Dr_Zooix.
13:01:22 <hask> I needd from ByteString to Int or Integer
13:01:30 <dmhouse> hask: unpack
13:01:33 <dmhouse> ?hoogle unpack
13:01:34 <lambdabot> A Hoogle error occurred.
13:01:36 <Beelsebob> why unpack?
13:01:36 <hask> sonething like read(var)::Int but from bytestrings
13:01:42 <Dr_Zooix> I've got a little proble with this code: http://rafb.net/p/nmODWG93.html
13:01:44 <lambdabot> Title: Nopaste - No description
13:01:47 <Beelsebob> hask: readInt?
13:01:54 <hask> syntax?
13:01:56 <gwern> readInt, yeah
13:02:05 <gwern> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
13:02:13 <gwern>  or: Data.ByteString.Char8 readInteger :: ByteString -> Maybe (Integer, ByteString)
13:02:16 <Dr_Zooix> Can you help me please. The error is at the end of the code.
13:02:35 <newsham> http://codepad.org/WDXeV59b
13:03:01 <Beelsebob> Dr_Zooix: you got one of...
13:03:03 <Beelsebob> an Atom
13:03:07 <Beelsebob> or a List not containing Atoms
13:03:12 <Beelsebob> in  a call to eval
13:03:40 <Beelsebob> add a default case eval x = error ("Eval called with: " ++ (show x))
13:03:40 <Dr_Zooix> Beelsebob: I don't really understand, sorry.
13:03:46 <hask> if I imported ByteString as B I do B.readInt(var) but get:Couldn't match expected type `Int'
13:03:47 <hask>            against inferred type `Maybe (Int, B.ByteString)'
13:04:09 <Beelsebob> hask: arguments don't go in parentheses in Haskell
13:04:18 <Beelsebob> and yes, look at the Type of readInt
13:04:18 <hask> I know
13:04:22 <Beelsebob> it doesn't return an Int
13:04:23 <vixey> Dr_Zooix, I can't even load your code
13:04:28 <vixey>     Ambiguous type variable `a' in the constraint:
13:04:31 <Dr_Zooix> and I've to add this no ? eval val@(Atom _) = val
13:04:33 <Beelsebob> it returns Maybe (Int, Bytestring)
13:04:34 <hask> B.readInt $ mov_grade rev
13:04:47 <Beelsebob> Dr_Zooix: if that's what you intend eval of an atom to be
13:05:57 <hask> beelse: then how do i get the int?
13:06:09 <vixey> :t fromIntegral
13:06:09 <Beelsebob> fst . fromJust?
13:06:10 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:06:18 <Beelsebob> :t fst . fromJust
13:06:19 <lambdabot> forall a b. Maybe (a, b) -> a
13:06:45 <vixey> :t (\Just (x,_) -> x)
13:06:45 <Beelsebob> :t fst . fromJust . Data.ByteString.Char8.readInt
13:06:47 <lambdabot> BSC.ByteString -> Int
13:06:57 <newsham> :t (fst <$>)
13:06:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f a
13:07:11 <hask> vixey: no doesnt work at all
13:07:15 <jpcooper> hello
13:07:19 <Beelsebob> newsham: why use the functor version to obfuscate your code -- there's *nothing* general going on here
13:07:20 <vixey> hask :What
13:07:31 <mapreduce> > "hola"
13:07:33 <lambdabot>  "hola"
13:07:43 <vixey> that fst <$> is much neater than fst . fromJust
13:07:45 <newsham> beelsebob: because mine doesnt use the partial function fromJust
13:07:55 <Beelsebob> vixey: not at all -- there's nothing general going on
13:07:57 <rwbarton> And hence it doesn't extract the Int :P
13:08:01 <vixey> yes it is
13:08:02 <Beelsebob> we *know* we're getting a Maybe
13:08:04 <jpcooper> I'm using the reader monad, and I'd also like to be able to extract the values of Maybe values. Could anyone direct me to how to use the ReaderT monad transformer?
13:08:17 <Beelsebob> vixey: no there isn't -- we already know the type we're getting -- it's a Maybe
13:08:27 <vixey> Beelsebob: But do you also know the maybe you get isn't a 'Nothing' ?
13:08:31 <Quadrescence> Beelsebob: Tell me if this is cool or not cool. D:
13:08:37 <dmhouse> jpcooper: unless you're doing complicated stuff with Maybe, you could just use fromMaybe.
13:08:39 <Quadrescence> > let poly cvec x = sum (zipWith (\c e -> c*x^e) cvec [0..]) in map (poly [1,1,1]) [1..]
13:08:41 <lambdabot>  [3,7,13,21,31,43,57,73,91,111,133,157,183,211,241,273,307,343,381,421,463,50...
13:08:52 <jpcooper> dmhouse, alright
13:08:57 <jberg> im using ghci from emacs, how can i unload a module, then load it back but i want to shadow a function and use my own instead?
13:08:59 <Beelsebob> vixey: that's a fair point certainly
13:09:03 <dmhouse> Maybe do-blocks are thin on the ground.
13:09:08 <Quadrescence> > let poly cvec x = sum (zipWith (\c e -> c*x^e) cvec [0..]) in map (poly [0,0,0,1]) [1..]
13:09:10 <lambdabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,...
13:09:20 <dmhouse> jberg: you can shadow a function with let
13:09:31 <trofimovich> @help let
13:09:31 <Quadrescence> > let poly cvec x = sum (zipWith (\c e -> c*x^e) cvec [0..]) in map (poly [1,1,1,1]) [1..]
13:09:32 <lambdabot> let <x> = <e>. Add a binding
13:09:33 <lambdabot>  [4,15,40,85,156,259,400,585,820,1111,1464,1885,2380,2955,3616,4369,5220,6175...
13:09:35 <Quadrescence> :D
13:09:46 <Quadrescence> cvec = coefficients of the polynomial
13:09:46 <newsham> > (fst . fromJust) Nothing
13:09:48 <lambdabot>  Exception: Maybe.fromJust: Nothing
13:09:51 <Beelsebob> vixey: problem though
13:09:56 <newsham> > fst <$> Nothing
13:09:59 <lambdabot>  Nothing
13:09:59 <jberg> dmhouse: but isnt there another way?
13:09:59 <Beelsebob> the intention was to get something *out* of a Maybe
13:10:02 <Quadrescence> so [1,1,1,1] --> 1 + x + x^2 + x^3
13:10:08 <Beelsebob> fst <$> leaves it *in* the maybe
13:10:18 <dmhouse> jberg: how would you like it work?
13:10:19 <Beelsebob> he asked how to get at the Int, not at the Maybe Int
13:10:47 <newsham> so you answered his question, and I'm correcting his question :)
13:10:53 <Quadrescence> > let poly cvec x = sum (zipWith (\c e -> c*x^e) cvec [0..]) in map (poly [-1,2,2,-1]) [1..]
13:10:55 <lambdabot>  [2,3,-4,-25,-66,-133,-232,-369,-550,-781,-1068,-1417,-1834,-2325,-2896,-3553...
13:10:59 <Beelsebob> newsham: yeh, fair enough then
13:11:09 <vixey> :t (<$>)
13:11:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:11:16 <vixey> :t (<*>)
13:11:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:11:29 <jberg> dmhouse: hm i dont know. ill just rename my function
13:11:48 <vixey> :t (?x <*> ?y)
13:11:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f, ?y::f a, ?x::f (a -> b)) => f b
13:11:52 <Quadrescence> Beelsebob: No comment? :<
13:12:08 <Beelsebob> Quadrescence: it's shiny
13:12:12 <Quadrescence> Hah :D
13:12:35 <Dr_Zooix> So, someone has an idea ? This is the code: http://rafb.net/p/nmODWG93.html ans the error is at the end.
13:12:37 <lambdabot> Title: Nopaste - No description
13:12:37 <newsham> > (+) <$> Just 5 <*> Just 8
13:12:39 <lambdabot>  Just 13
13:12:45 <Beelsebob> newsham: I guess the alternative is to leave the int in there, and just fmap . first everything after that
13:12:59 <newsham> ?type maybe
13:13:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:13:06 <newsham> or use "maybe" to extract it in a safe way
13:13:08 <Beelsebob> > (fmap . first) (+2) (Just (2, undefined))
13:13:11 <lambdabot>  Just (4,Exception: Prelude.undefined
13:13:13 <newsham> when you finally get an answer you really want out of Maybe
13:13:21 <Beelsebob> that too
13:13:30 * Beelsebob giggles at the pretty conal tought him
13:13:30 <BMeph> Dr_Zooix: What part of "non-exhaustive patterns" do you not understand? :)
13:14:10 <eu-prleu-peupeu> byorgey: i tried passing two values on the class type, but it outputs an error saying it isn't allowed (only through an extension) :/
13:14:16 <Dr_Zooix> BMeph: Soory I'm new whit Haskell. I've tried to add this: eval val@(Atom _) = val but it doesn't work
13:14:19 <BMeph> newsham: BTW, nicely done with the '...'
13:14:20 <vixey> > first . (+2) <$>) (Just (2, undefined))
13:14:21 <lambdabot> Unbalanced parentheses
13:14:22 <eu-prleu-peupeu> i then tried passing a tuple, but it doesn't work either
13:14:23 <vixey> > first . (+2) <$> (Just (2, undefined))
13:14:25 <lambdabot>   add an instance declaration for (Num (b, a))
13:14:29 <chrisdone> did hask consider the GenericString class?
13:14:34 <vixey> > ((+2) . first) <$> (Just (2, undefined))
13:14:36 <vovik> what does <> do?
13:14:36 <lambdabot>        add an instance declaration for (Num ((b, d), (a, d)))
13:14:41 <hask> I don't get it, Im not down fully with Monads and maybes yet
13:14:41 <hask> How do I go the whole way from ByteString to an Int?
13:14:41 <hask> noone?
13:14:47 <newsham> bmeph: thats rwbarton.  i just put it on codepad
13:14:48 <vixey> > first (+2) <$> (Just (2, undefined))
13:14:51 <lambdabot>  Just (4,Exception: Prelude.undefined
13:14:59 <rog> does anyone know of a haskell implementation of the inverse error function in haskell, by any chance?
13:15:11 <BMeph> newsham: Ah, Okay. Nice catch, then. :)
13:15:15 <BMeph> rwbarton++
13:15:34 <chrisdone> hask: read . unpack
13:15:42 <Beelsebob> vixey: the shiny trick is that you can read the type left to right -- every time you want to apply something inside something you fmap, every time you want to apply it in a tuple you first or second it -- so you can easily get streams of (fmap . fmap . first . fmap . second) etc to apply functions deep inside structures
13:15:53 <Dr_Zooix> BMeph: Sorry I'm new whit Haskell. I've tried to add this: eval val@(Atom _) = val but it doesn't work
13:15:58 <Beelsebob> so there's a rather nice consistant way to do it
13:16:06 <vixey> oh I see
13:16:09 <newsham> hask: use Data.ByteString.Lazy.Char8  (or Data.ByteString.Char8)
13:16:11 <chrisdone> hask: http://hpaste.org/9642
13:16:15 <newsham> then as chrisdone said
13:16:18 <Beelsebob> vixey: good trick, isn't it
13:16:21 <vixey> yeah
13:16:25 <vixey>  that's cool
13:16:30 <Beelsebob> and it substitutes silly playing with ((.) . (.))
13:16:37 <Beelsebob> even if you no longer use the boobies combinator
13:17:02 <newsham> beelsebob: you can generalize that, too, to work with things other than tuples.
13:17:05 <BMeph> Dr_Zooix: Here's the deal: "non-exhaustive patterns" means that the compiler doesn't know what you want to do if 'eval' doesn't get an argument in a form like what you've written so far.
13:17:08 <newsham> and you can use it for both settors and gettors
13:17:15 <Beelsebob> newsham: yep
13:17:22 <newsham> beelsebob: http://www.thenewsh.com/%7Enewsham/x/accessor.lhs
13:17:52 <rog> (by which i mean http://functions.wolfram.com/GammaBetaErf/InverseErf/)
13:17:57 <lambdabot> Title: Inverse error function
13:17:58 <Dr_Zooix> BMeph: Ok, but I don't manage to resolve this error. So what should I do ?
13:18:55 <hask> newsham, I am
13:18:56 <eu-prleu-peupeu> i need help please
13:19:12 <eu-prleu-peupeu> binding problems in type class specification: http://hpaste.org/9641
13:19:32 <newsham> zooix: what error do you get for   eval val@(Atom _) = val   ?
13:19:43 <BMeph> Dr_Zooix: Add more options for eval to use. Either that, or tell the compiler that you want C-like behavior (i.e., to crash your program when given certain arguments). ;)
13:19:44 <hask> I don't get if you are talking to me or not, why can't I just get the damn int?
13:20:48 <lowki_> say i have a bunch of files in my darcs but when i do ./Setup.lhs sdist it only puts 3 or four files into the sdist tarball
13:20:56 <eu-prleu-peupeu> i guess ill just give up and have a look at template haskell :(
13:21:10 <vixey> yeah um
13:21:14 <vixey> template haskell will not help
13:21:24 <BMeph> hask: Have you tried to "get the damn int?" :)
13:21:30 <eu-prleu-peupeu> i want a vector class with multiple type, isn't that possible ?
13:21:31 <stepcut> jpcooper: http://hpaste.org/9643
13:21:34 <eu-prleu-peupeu> in C++ is easy :/
13:21:46 <vixey> it's also easy in haskell
13:21:53 <jpcooper> thanks stepcut
13:21:56 <eu-prleu-peupeu> then i guess im just messing it up
13:22:21 <vixey> you have put the Num => bits in funny places
13:22:53 <stepcut> jpcooper: i and j are examples of 'getting a value out of the Maybe'
13:23:05 <newsham> euprleupeupeu: your Vector class should be parameterized on the value and vector types, no?
13:23:06 <eu-prleu-peupeu> it just keeps on giving me the same error, that cannot bind the Num type from class specification, to the Num type in the class instantiation
13:23:23 <eu-prleu-peupeu> newsham: in haskell its not possible to have multiple parameter class types
13:23:38 <eu-prleu-peupeu> (thats what ghc says)
13:24:18 <eu-prleu-peupeu> well... ill just look at template haskell, and see where i can go from there :)
13:24:40 <jpcooper> stepcut, I guess when return is done, it goes up to the level of the reader
13:24:56 <rog> oh well, power series it is then. i never trust  myself to get floating point calculations stable & accuracy-preserving...
13:25:08 <stepcut> jpcooper: yes
13:25:23 <ddarius> rog: Use intervals then.
13:25:29 <stepcut> jpcooper: if you want just a Maybe String, then do, Just "hello"
13:25:40 <rog> ddarius: intervals?
13:26:01 <jpcooper> thanks a lot
13:26:32 <hask> BMeph: No im lost.
13:26:32 <hask> I have as Input a ByteString and I want to convert it to an Int
13:26:32 <hask> that's all
13:26:32 <hask> there must be a simple one-liner no?
13:26:32 <hask> readInt + unpack expects char
13:26:57 <ddarius> rog: I don't know the context so this may not make sense.  But you can use interval arithmetic or affine arithmetic.
13:27:34 <Dr_Zooix> BMeph: The problem is, that I've the same 'eval' function has here: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/code/listing4.3.hs but if I write "eval "(+ 2 2)", I obtain "(+" .
13:27:35 <Deewiant> hask: Data.ByteString.Internal has w2c
13:27:40 <lambdabot> http://tinyurl.com/6r399w
13:28:01 <eu-prleu-peupeu> neat, template haskell allows to change the haskell AST at compile time :)
13:29:01 <Quadrescence> Things are not supposed to work the first time. >:(
13:29:11 <stepcut> jpcooper: I updated it to show one way to use mplus as well.
13:29:21 <vixey> eu-prleu-peupeu: this has absolutely nothing to do with the code you're writing
13:29:25 <eu-prleu-peupeu> i know
13:29:26 <eu-prleu-peupeu> heheh
13:29:50 <newsham> hask: http://codepad.org/Vm95wBq6
13:29:50 <hask> well im using Data.ByteString.Char8 as B and I want to make the damn thing an int
13:30:08 <Dr_Zooix> BMeph: The problem is, that I've the same 'eval' function has here: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/code/listing4.3.hs but if I write "eval "(+ 2 2)", I obtain "(+" .
13:30:09 <lambdabot> http://tinyurl.com/6r399w
13:30:22 <Deewiant> hask: so unpack should work?
13:30:32 <BMeph> Dr_Zooix: Your eval function doesn't understand parens, outside of a dotted pair. :)
13:30:38 <vixey> hummmmm :/
13:30:53 <Quadrescence> :t (&&)
13:30:54 <BMeph> Dr_Zooix: Try eval "+ 2 2"
13:30:54 <lambdabot> Bool -> Bool -> Bool
13:30:55 <vixey> I don't like the scheme tutorial
13:31:00 <vixey> such weirdness
13:31:12 <luqui> Can anyone think of a way to make, eg., if undefined then [1..] else [1..] work?
13:31:27 <luqui> maybe with a special definition of if, or needing typeclasses on [], or something?
13:31:28 <Dr_Zooix> BMeph: I obtained: '+'
13:31:29 <Dr_Zooix> :/
13:31:40 <luqui> by "work" I mean return [1..]
13:31:44 <BMeph> Dr_Zooix: Well, eval . readExpr $ "+ 2 2", I guess. :)
13:32:04 <newsham> hask: that answer your question?
13:32:17 <vixey> luqui: since the lists are infinite , I am not sure ..
13:32:19 <Deewiant> luqui: there was a library which has stuff like isBottom, but I forget what it's called
13:32:58 <luqui> Deewiant, ah, no, that's not what I mean.  I mean if _|_ ..., where _|_ is one of those infinite loop thingamajiggers
13:33:20 <Dr_Zooix> BMeph: I obtained: '+' too :(
13:33:22 <twanvl> luqui: why not just write [1..]?
13:33:23 <Deewiant> luqui: like if last [1..] == 1 then [1..] else [1..]?
13:33:34 <luqui> yeah
13:33:42 <hask> nesham: but it is using lazy char8 which si what I don t want, for performance reasons I am suing ByteStrings
13:33:43 <BMeph> Dr_Zooix: Oh, NM, I see the List check. Okay, what does showVal . readExpr give you?
13:34:11 <Dr_Zooix> ?
13:34:16 <rog> ddarius: the context is that i just need the result (hopefully with reasonable properties across a wide range of inputs). it should be reasonably efficient as i'm using it to generate (many) normally-distributed samples. quantifying the inaccuracy won't help too much - there's nothing i can do about it.
13:34:33 <Deewiant> luqui: that library also had an isBottomTimeOut which is of course a hack, but what can you do :-P
13:34:36 <Dr_Zooix> I've to go, sorry :/
13:34:38 <newsham> so you want unlazy bytestring? like this?  http://codepad.org/hnzC9RMw
13:34:54 * luqui is thinking more theoretically
13:35:06 <luqui> it's a lambda calc question more than a "I want to code this" question
13:35:17 <Deewiant> luqui: well, this is solving the halting problem
13:35:24 <Deewiant> how do you know it will terminate or not
13:35:26 <luqui> I don't think necessarily it is
13:35:37 <Deewiant> in the general case it is, at least
13:35:47 <luqui> eg. glb is a definable function, that finds the greatest lower bound of two functions
13:36:04 <twanvl> luqui: You could have a lazy function that returns the first part of the alternatives as long as they are the same
13:36:08 <luqui> so ((+2) `glb` (*2)) 2 == 4, but ((+2) `glb` (*2)) 4 == _|_
13:36:14 <newsham> hask: does that work for you?
13:36:22 <luqui> twanvl, yeah, that's something like what I was thinking.
13:36:25 <noteventime> Hmm, I can't quite seem to grasp zippers, too me it seems to just be a matter of changing which node is the root :|
13:36:46 <rog> ddarius: BTW thanks. i didn't know about affine arithmetic. looks interesting, but grokking to the point of implementation  it will take more time than i have available...
13:37:09 <BMeph> hask: Have you tried (fst . fromJust . readInt) yet? :)
13:37:12 <noteventime> Or is it the back tracking that makes it something else?
13:37:19 <rog> ddarius: s/implemention it/implementation/
13:37:22 <twanvl> luqui: for your example, I was thinking:  ifList cond (x:xs) (y:ys)  | x == y = x : ifList cond xs ys  | cond = x:xs  | otherwise = y:ys
13:37:23 <ddarius> rog: It's typically not the kind of thing you'd implement yourself (though I don't think there are too many affine arithmetic libraries out there), you'd just use a prepackaged solution.
13:37:33 <Quadrescence> > tails [1..5]
13:37:35 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
13:37:46 <rog> ddarius: such as...
13:37:55 <SamB_XP> ddarius: you seem to be sending a mixed message!
13:38:17 <ddarius> SamB_XP: Prepackaged interval arithmetic solutions.
13:38:50 <SamB_XP> ddarius: ah. so you just weren't getting your point across clearly
13:38:56 <Quadrescence> > reverse . tails [1..5]
13:38:58 <lambdabot>  [[5,4,3,2,1],[5,4,3,2],[5,4,3],[5,4],[5],[]]
13:39:02 <Quadrescence> excellent.
13:39:11 <BMeph> noteventime: The thing with Zippers is: you don't just change the root, you change the whole tree! (modulo your defn of 'change')
13:39:19 <dmhouse> Hmm, that's confusing!
13:39:38 <dmhouse> I guess reverse . tails [1..5] is an example against having (.) be fmap.
13:39:48 <SamB_XP> I thought zippers were just a way of slowly turning a tree partly inside-out
13:39:52 <noteventime> BMeph: I'm going to try the Haskell wiki article instead :)
13:40:14 <BMeph> noteventime: I recommend it. :)
13:40:26 <noteventime> BMeph: I just read the wikibooks one
13:40:46 <ddarius> SamB_XP: I was relying on contextual disambiguation.
13:41:01 <BMeph> dmhouse: Why is that? :)
13:41:13 <BMeph> > reverse `fmap` tails [1..5]
13:41:15 <lambdabot>  [[5,4,3,2,1],[5,4,3,2],[5,4,3],[5,4],[5],[]]
13:41:23 <SamB_XP> ddarius: well you ... were apparantly in a different context from rog and myself
13:41:28 <dmhouse> BMeph: it's fairly common for beginners to write things like f . g . h x to mean f . g . h $ x
13:41:40 <BMeph> dmhouse: ...and? :)
13:41:57 <dmhouse> BMeph: so such expressions should be type errors, not compile and do things that you don't expect.
13:41:58 <BMeph> > reverse `fmap` tails $ [1..5]
13:42:01 <lambdabot>  [[],[5],[4,5],[3,4,5],[2,3,4,5],[1,2,3,4,5]]
13:42:03 <ddarius> SamB_XP: The context was the rest of the sentence and assuming I'm not being blatantly contradictory.
13:42:05 <dmhouse> Yes, I know how it works.
13:42:53 <BMeph> dmhouse: But...isn't the 'compile and do things that you don't expect' behavior what they're used to already? ;p
13:43:26 <SamB_XP> BMeph: in C++ I guess
13:43:42 <hask> newsham: im looking into it, I got it to compile in another way but no sure it is actually ok :)
13:43:47 <ddarius> rog: There was a recently announced interval arithmetic thing, but it's not quite what I was talking about.  There are plenty of non-Haskell implementations.
13:44:26 <BMeph> SamB_XP: Oh, you mean that doesn't occur when using Python, Ruby, PHP... ;)
13:44:46 <magthe> I suspect I'll get in trouble for this, but I vaguely remember reading that there is a sort of debug print function, something with a type like String -> a which does some unsafe IO... anyone know what I'm talking about?
13:44:47 <BMeph> > reverse . tails $ [1..5]
13:44:47 <SamB_XP> the term "compile" is not common usage in those settings
13:44:48 <lambdabot>  [[],[5],[4,5],[3,4,5],[2,3,4,5],[1,2,3,4,5]]
13:44:57 <SamB_XP> typically they instead speak of "parsing"
13:45:16 <stepcut> magthe: trace
13:45:24 <magthe> stepcut: ah, thanks!
13:45:32 <ddarius> @hoohle trace
13:45:33 <lambdabot> A Hoogle error occurred.
13:45:42 <ddarius> Thanks Hoogle.
13:45:47 <ddarius> Debug.Trace.trace
13:47:05 * magthe is feeling dirty
13:47:20 <noteventime> I was extremely happy when I realised today that Firefox's new smart search thingy worked with Hoogle :D
13:47:24 <hask> lol BIG fail
13:47:51 <noteventime> I wonder why I hadn't heard about it before :o
13:48:09 <SamB_XP> "smart search"?
13:48:56 <hask> noteventme: which smart thing?
13:48:56 <rog> ddarius: i'm really not sure that accuracy-confirming arithmetic will help me much - i just need to find the right formula and implement it (correctly). sadly my analysis course is very dimly recalled, so choosing the fastest-converging/most efficient  formula will be down to trial & error, i guess. i'd hoped to have finished implementing by the end of tonight, producing presentation tomorrow! this is just one hurdle on the way...
13:48:56 <noteventime> SamB_XP: Forgot what it's called :p
13:49:27 * SamB_XP was wondering how it works
13:49:35 <hask> you mean upper right where you can serach different sites or with diff engines?
13:49:36 <noteventime> SamB_XP: The keyword thing
13:49:44 <noteventime> hask: No
13:49:58 <noteventime> Right click any input box in a search engine
13:50:15 <noteventime> And press "Add a keyword for this search"
13:50:27 <noteventime> When you've saved they keyword (I just used hoogle)
13:50:45 <noteventime> I can now just type "hoogle flip" and get the search results directly
13:51:24 <noteventime> I've also (successfully) tried with the Haskell wiki, google, imdb and wikipedia
13:53:11 <noteventime> Did I kill everyone?
13:53:43 <SamB_XP> noteventime: yes, I am now dead of boredom
13:54:22 <noteventime> :p Sorry, I guess
13:54:25 <BMeph> Good advice for life in general: "approach negative comments by asking for details (kind of like Socratic questioning), rather than challenging the competence of the writer (ad hominem). "
13:55:32 <noteventime> After reading some of the Haskell one-liners around I suspected the Haskell community was full of zombies anyway :p
13:56:07 <dons> heh
13:56:42 <SamB_XP> noteventime: see, you were supposed to respond similarly to how I respond when my dad answers "no" to "are you awake?"
13:57:26 <noteventime> SamB_XP: Which would be how?
13:57:51 <SamB_XP> groans or "haha" or something
13:58:33 <noteventime> SamB_XP: I figured IRC had enough of those
13:59:32 <luqui> twanvl, I did it! http://hpaste.org/9644
14:03:05 <BMeph> luqui: Was your Inf [a] instance not working, with "inf _ _ = hang" after the secong eqn? :)
14:04:29 <twanvl> luqui: The Sup [a] looks a bit strange, first you use unamb to race x and y, but then you evaluate both later on
14:06:59 * BMeph points at twanvl and nods agreeingly
14:08:33 <luqui> BMeph, no, just didn't realize.
14:08:51 <BMeph> luqui: Ah, okay. No worries.
14:09:20 <luqui> twanvl, well I need to know whether it's []
14:09:25 <BMeph> luqui: Also, couldn't you just use the two branches in your case directly? :)
14:09:39 <luqui> i.e. [] `sup` _|_ and _|_ `sup` [] both need to be []
14:10:03 <luqui> BMeph, what do you mean?
14:11:10 <jpcooper> @hoogle lift
14:11:11 <lambdabot> A Hoogle error occurred.
14:11:17 <jpcooper> excellent
14:12:45 <Cale> ...
14:12:50 <Cale> I wonder what I can do about that.
14:13:00 <Cale> jpcooper: anyway, that's in  Control.Monad.Trans
14:13:11 <jpcooper> yes, I resorted to opening my browser
14:13:40 <BMeph> luqui: What will sup [1] ((tail.tail.tail.tail) [1,2,3]) do? :)
14:13:52 * Cale wonders how hard it would be to teach the lambdabot title plugin about other page encodings...
14:14:50 <Cale> Of course, the ideal thing would be to have a way to properly read things with all the various encodings...
14:16:30 <luqui> BMeph's ghost,  "tail: empty list" out, but it should be [1].  Just not sufficient error handling in unamb.
14:17:57 <BMeph> ...sorry about that.
14:20:04 <stepcut> Cale: the encoding is sometimes specified in the HTTP headers. Otherwise I think you have to look for a meta tag in the head element. Either one should be easy to do. Then use iconv to convert it to utf-8 ? (assuming most people on irc us utf-8?)
14:20:10 <hask> can I write this to a file: a list containing datas which mix Ints and ByteStrings?
14:20:25 <hask> Also, if it isnt possible would it complain or just print []?
14:20:32 <Cale> stepcut: Does iconv support things like EUC-JP?
14:20:33 <luqui> <luqui>  BMeph's ghost,  "tail: empty list" out, but it should be [1].  Just not sufficient error handling in unamb.
14:20:41 <stepcut> Cale: perhaps?
14:20:46 <Cale> I'll check :)
14:20:50 <trofimovich> :locale -m | grep EUC
14:20:51 <trofimovich> EUC-JISX0213
14:20:51 <trofimovich> EUC-JP
14:20:51 <trofimovich> EUC-JP-MS
14:20:51 <trofimovich> EUC-KR
14:20:53 <trofimovich> EUC-TW
14:20:58 <stepcut> Cale: I know it suports more than just utf-8
14:21:21 <stepcut> Cale: iconv --list
14:22:08 <Cale> nice
14:22:31 <byorgey> luqui: that's very cool!
14:23:12 <stepcut> Cale: on my system that returns around 1153 encodings, including EUC-JP
14:23:14 <byorgey> hask: you can't have a list which contains both Ints and ByteStrings directly, because lists in Haskell must be heterogeneous (all elements the same type).
14:23:17 <BMeph> luqui: Right. a problem with 'unamb' in my eyes, is that just because one of your choices 'comes back" first, doesn't mean that it's simpler in form. Or, for that matter, that your other argument is non-null. :)
14:23:19 <Cale> yeah, same here
14:23:28 <cjb> interesting, someone in Boston hiring Haskell people
14:23:37 <Cale> Exactly 1153, actually.
14:23:41 <byorgey> hask: however, you could make a new data type like this:  data MyType = I Int | B ByteString
14:23:48 <byorgey> hask: then you could have a list of MyType
14:24:05 <byorgey> and each value of MyType could either be an Int or a ByteString.
14:24:32 <byorgey> hask: does that help?
14:26:06 <rwbarton> It seems unamb should be named unsafeUnamb and sup unsafeSup.  inf is OK, though
14:26:10 * byorgey goes off to do some reading
14:27:04 <twanvl> luqui: I pasted an idea for a simpler cond implementation using mutual recursion
14:27:08 <Beelsebob> rwbarton: why is unamb unsafe?
14:27:17 <Beelsebob> because it's possible to pass things that have different results?
14:27:48 <rwbarton> Beelsebob: Right.  (At least, that's my understanding)
14:28:09 <stepcut> Cale: there is also a tool which will attempt to guess the encoding if it is not specified. Not sure what it's called though.
14:28:43 <Cale> There is conveniently a binding to iconv for Haskell already.
14:29:22 <stepcut> Cale: yep, that's why I suggested it
14:29:42 <mornfall> http://hpaste.org/9645 -- improvements, anyone?
14:29:46 <mornfall> Pretty please. : - )
14:31:19 <stepcut> mornfall: does that check for middle endian ?
14:31:36 <mornfall> stepcut: Well, it could, but I don't want to...
14:32:12 <mornfall> (The SHA1 in darcs only works on little and big endian anyway, and the check is for that.)
14:32:19 <stepcut> mornfall: :p
14:32:40 <mornfall> *and* I fortunately not even do not own, but I do not have access to any middle-endian hardware. *phew*
14:32:48 <stepcut> mornfall: you don't have a cell phone ?
14:33:03 <mornfall> stepcut: Well, not at this time.
14:33:25 <mornfall> Aren't they all like running ARM or something? Maybe some motorola stuff.
14:33:31 <stepcut> ARM processors sometimes have middle endian. And there is a lot of desire to run GHC on ARM.
14:33:32 <mornfall> And do they run GHC? : - ]
14:33:49 <BCoppens> mornfall: you should've gone to Akademy, free N810 (ARM)
14:33:59 <mornfall> BCoppens: Bummer.
14:34:14 <mornfall> I could actually use one...
14:34:26 <stepcut> BCoppens: yeah, but you have to hang out with a bunch of C++ lovers ;)
14:34:27 <BCoppens> (too bad it's not actually a phone.. sigh)
14:34:30 <mornfall> So I guess that code is as good as it gets?
14:34:33 <BCoppens> stepcut: ;)
14:34:53 <mornfall> Hey, I love how I can screw around with pointers from Haskell.
14:34:59 <mornfall> That's... unexpected.
14:35:09 <BCoppens> (mornfall: they have like <50 left, but then you have to give a good project as a reason you need it)
14:35:11 <Cale> mornfall: I love the type of malloc
14:35:27 <stepcut> I tried to talk Aaron Seigo into switching KDE to Haskell, but he wouldn't go for it. I still say they would have gotten KDE 4 out sooner :p
14:35:40 <Cale> hehehe
14:35:53 <mornfall> Cale: Oh, good point.
14:36:01 <rwbarton> mornfall: I'd use alloca, but I don't really know for sure what I'm doing :)
14:37:21 <BCoppens> stepcut: well, you could start with decent Qt4 bindings for Haskell ;)
14:37:56 <stepcut> BCoppens: first Qt4/KDE need to export a C interface :(
14:38:09 <BCoppens> stepcut: which is rather... problematic
14:38:17 <stepcut> BCoppens: http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
14:38:21 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
14:38:30 <mornfall> rwbarton: Works, and looks better. (malloc works just as well, I guess...). Sticking to alloca. :)
14:38:47 <stepcut> BCoppens: probably the only KDE application written in Haskell ;)
14:39:12 <BCoppens> stepcut: ick, the pain from looking at it is immense :P
14:39:19 <stepcut> indeed
14:39:20 <luqui> twanvl, ah, that's a nice one.
14:39:37 <luqui> a little less expressive I think
14:40:15 <luqui> consider cond hang [1,hang,3,hang,5] [hang,2,hang,4,hang]
14:40:32 <luqui> oh wait, that should actually just be repeat 5 hang
14:40:43 <BCoppens> stepcut: still, impressive
14:41:05 <mornfall> BCoppens: Say wow. ; - )
14:41:12 <stepcut> BCoppens: KDE does have some binding generation stuff these days that is in better shape than when I wrote that
14:41:28 <stepcut> BCoppens: so, it may actually be possibly to automate the binding generation for Haskell now
14:41:33 <BCoppens> mornfall: wow :P
14:41:36 <hask> Byorgey: I meant a list of type data Customer and the Customer has files that are Ints and ByteStrings
14:41:45 <BCoppens> stepcut: hmmmmm
14:41:47 <hask> fields
14:42:05 <hask> Byorgey: I meant a list of data Customer and the Customer has fields that are Ints and ByteStrings
14:42:13 <BCoppens> stepcut: the kde bindings people recently had like a meeting
14:42:22 <BCoppens> stepcut: you should've gone there
14:42:50 <stepcut> BCoppens: well, I don't use KDE anymore :)
14:42:56 <BCoppens> stepcut: *sniff* :( :P
14:43:00 <mornfall> http://sourceforge.net/projects/qthaskell btw...
14:43:04 <rwbarton> luqui: it's too bad 1 `inf` (1 `sup` 2) isn't 1  :P
14:43:18 <hask> and what is the notation of ByeString? If I want to test a function at the repl that takes a bytestring as input, what notation do i use?
14:43:31 <stepcut> mornfall: yeah, I've played with that before
14:43:57 <stepcut> hask: pack "your string"
14:44:00 <nolrai_East> @Hoogle swap
14:44:00 <lambdabot> Maybe you meant: google hoogle
14:44:05 <nolrai_East> @hoogle swap
14:44:05 <lambdabot> A Hoogle error occurred.
14:44:08 * stepcut wonders what happened to Stringable
14:44:12 <nolrai_East> @hoogle (+)
14:44:12 <lambdabot> A Hoogle error occurred.
14:44:16 <nolrai_East> hmm
14:44:24 <mornfall> hoogle is cooked... it works on the web.
14:44:27 <luqui> rwbarton, indeed, but it's okay, because 1 `sup` 2 doesn't exist.
14:45:05 <luqui> (and this implementation requires the user to prove that they are related, so it'll just pick 1 or 2 arbitrarily, and thus half the time be _|_ and the other half be 1)
14:45:46 <b\6> i have an IO Blah 'blah'. i need to return an IO Blah, and i'm doing blah {something = something}. ghc complains that i'm trying to return a Blah when i need to be returning an IO Blah. i don't get it.
14:46:09 <rwbarton> b
14:46:21 <Wild_Cat> hrmm... n00bish, probably asked 200 times a day, question: what are the text editors of choice for the discriminating Haskell hacker?
14:46:23 <rwbarton> b\6: this is confusing, but return "return blah {something = something}"
14:46:38 <luqui> b\6, fmap (\b -> b{something = something}) blah -- I think
14:46:44 <rwbarton> b\6: oh, never mind, listen to luqui
14:46:58 <b\6> checking it out. thanks.
14:47:07 <b\6> (course i tried 'return')
14:47:13 <tromp> yi,vi,emacs
14:47:31 <idnar> do b <- blah; return b {something = something}
14:47:54 <b\6> oh, ok.
14:48:00 * luqui would love anonymous record update.   fmap \{something=something} blah... or something
14:48:26 <luqui> \ was a poor syntax choice
14:48:28 <luqui> for that
14:49:42 <b\6> thanks, better.
14:50:04 <jpcooper> stepcut, say with inside this transformer monad if I do x <- y and y is Nothing. Will it fail afterwards?
14:50:28 <stepcut> jpcooper: yes. did you see the update I made with mplus ?
14:50:44 <jpcooper> I do now
14:50:45 <jpcooper> thanks
14:50:49 <Wild_Cat> erm... extra stupid question: how the heck do I *run* yi?
14:51:34 <Wild_Cat> I can't help but notice the lack of a "yi" binary anywhere on my $PATH after installing it.
14:52:02 <Beelsebob> Wild_Cat: did you use cabal install?
14:52:46 <Wild_Cat> Beelsebob: nope, I used the good old Setup.hs configure --user -f="gtk" / build / install routine.
14:53:01 <Beelsebob> fun -- no idea then
14:53:05 <Wild_Cat> cabal-install gives off a 404 every time I try to use it to install anything.
14:53:08 <dcoutts> Wild_Cat: out of interest, do you have any dir under $HOME that is on your path? (I'm fixing the issue about where cabal installs things atm)
14:53:17 <Beelsebob> yeh -- cabal install bugs out for me most of the time
14:53:27 <Wild_Cat> dcoutts: yup, I have ~/bin
14:53:31 <dcoutts> Wild_Cat: Setup.hs configure --user will install binaries to ~/.cabal/bin
14:53:40 <dcoutts> Wild_Cat: ok
14:54:19 <dcoutts> Wild_Cat: we'll probably make the deault that it'll symlink into ~/bin if it exists and is on the $PATH, otherwise it'll warn that it can't put the binaries anywhere on your path
14:54:19 <Wild_Cat> dcoutts: yet there is no yi binary in .cabal/bin . Or anywhere in ~/.cabal, for that matter.
14:54:53 <dcoutts> Wild_Cat: oh, hmm. run install with -v, see where it's installing.
14:56:16 <dcoutts> Wild_Cat: what version of Cabal lib are you using there? 1.2.x or 1.4? the default prefix for --user changed between the two.
14:57:29 <Wild_Cat> dcoutts: 1.4.0.1
14:57:59 <dcoutts> Wild_Cat: hmm, then if you use --user and don't override the --preifx then it uses $HOME/.cabal
14:58:30 <Wild_Cat> ...and runhaskell Setup.hs install doesn't seem to show *any* reference whatsoever to a plain "yi" binary. (I can pastebin the output if that's of any interest)
14:58:37 <Wild_Cat> (-v, of course)
14:59:36 <dcoutts> Wild_Cat: the build wasn't unrealisticly quick was it? I'm just wondering if the configuration you've got meant the executable was disabled
14:59:51 <dcoutts> the yi folks specifically disable some combinations
15:00:11 <dcoutts> Wild_Cat: -v3 on install will show exactly which files are installed where
15:00:38 <Wild_Cat> dcoutts: not really. It compiled 85 files, IIRC.
15:00:50 <dcoutts> hmm
15:01:16 <dcoutts> Wild_Cat: so is install -v3 enlightening?
15:01:55 <dons> http://www.reddit.com/comments/6wdk7/want_a_haskell_job_how_about_something_in/ anyone looking for work on the east coast?
15:01:57 <lambdabot> Title: Want a Haskell job? How about something in real-time collaboration in graphical  ..., http://tinyurl.com/5ecvqu
15:02:01 <dcoutts> Wild_Cat: btw, if you have any details on your cabal-install network issues that'd be useful. It's supposed to just work.
15:02:36 <Wild_Cat> dcoutts: nearly identical output to plain -v
15:03:00 <Wild_Cat> dcoutts: any install attempts bail out with a 404.
15:03:16 <Wild_Cat> (Ubuntu Hardy with ghc 6.8.2, by the way)
15:03:20 <hackage> Uploaded to hackage: kbq-gu 0.2
15:03:20 <hackage> Uploaded to hackage: protocol-buffers 0.1.0
15:03:20 <hackage> Uploaded to hackage: data-accessor-template 0.1.1
15:03:20 <dcoutts> Wild_Cat: are you using a http proxy?
15:03:21 <hackage> Uploaded to hackage: data-accessor 0.1.1
15:03:23 <hackage> Uploaded to hackage: kbq-gu 0.1
15:03:42 <Wild_Cat> dcoutts: nope. Just a wi-fi router.
15:04:12 <dcoutts> Wild_Cat: could you hpaste an example of say, cabal fetch xmonad -v3
15:04:14 <dcoutts> @hpaste
15:04:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:04:17 <vixey> I am confused :S
15:04:30 <Wild_Cat> certainly, gimme a sec...
15:04:34 <dcoutts> Wild_Cat: and I assume that fetching the same url with your browser works?
15:05:55 <Wild_Cat> dcoutts: http://hpaste.org/9646
15:05:56 <dcoutts> Wild_Cat: my suspicion is that you've got a transparent http proxy (eg your isp) and the version of the HTTP package you're using is not using exactly the right http-1.1 thing that proxies grok.
15:06:15 <Wild_Cat> hrmm. Interesting. My browser 404s as well. What. The. Heck.
15:07:05 <dcoutts> Wild_Cat: ohhh, you're using darcs cabal-install from a few days ago.
15:07:16 <Wild_Cat> erm... Yup.
15:07:19 <dcoutts> Wild_Cat: either use the released version or use the very latest darcs version.
15:07:57 <dcoutts> Wild_Cat: we were testing with a new hackage server which uses a different url layout, we've now got it working with both old and new.
15:08:40 <dcoutts> Wild_Cat: so there was a window of about a day and a half in which you must have grabbed the dev version
15:08:46 <dons> oh, you have the same url layout, dcoutts ?
15:08:58 <dons> since if you break all my hackage tools, i'll break your toes!
15:09:11 <Wild_Cat> dcoutts: I've always been such a lucky man :p
15:09:16 <dcoutts> dons: the server does permanent redirects from all the existing urls
15:09:28 <dons> great.
15:10:28 <dcoutts> dons: but the current urls are pretty indefensable and inconsistent, eg how do I find the upload url relative to the main hackage page? answer cannot. So cabal-install has the hackage upload url hard coded. Bleugh.
15:10:43 <Wild_Cat> dcoutts: right. Much better. cabal fetch works now.
15:10:48 <dcoutts> Wild_Cat: great
15:11:07 <dons> dcoutts: right. a better url scheme is good
15:11:09 <Wild_Cat> on to why the heck yi doesn't install itself now ^^
15:11:11 <dons> as long as the old semantics work too
15:11:17 <wadcom> hi
15:11:25 <dcoutts> dons: absolutely, can't break any old urls
15:11:54 <dcoutts> dons: we have a legacy module specially for that, new deployments don't have to use that of course.
15:12:32 <wadcom> I have a Data.Map and need to fetch an item from there. Is there a better way to express (C-like) assertion that the item should be present? Here is my current code:
15:12:41 <wadcom> invlist :: TermId -> TermInvListMap -> InvList
15:12:41 <wadcom> invlist t terms =
15:12:41 <wadcom>   case Data.Map.lookup t terms of
15:12:42 <wadcom>     Just x -> x
15:13:03 <wadcom> ?
15:13:04 <vixey> wadcom: I'd write that as fromJust . Data.Map.lookup t terms
15:13:06 <vixey> oops
15:13:11 <vixey> fromJust $ Data.Map.lookup t terms
15:13:27 <wadcom> vixey: alright, thanks
15:13:29 <vixey> > fromJust Nothing
15:13:31 <lambdabot>  Exception: Maybe.fromJust: Nothing
15:13:32 <vixey> > fromJust (Just 3)
15:13:34 <lambdabot>  3
15:13:45 <rwbarton> wadcom: or t Data.Map.!! terms
15:13:50 <wadcom> is there a way to attach some kind of diagnostic message to this code snippet?
15:14:33 <vixey> wadcom: instead of fromJus
15:14:34 <vixey> wadcom: instead of fromJust
15:14:36 <vixey> :t fromJust
15:14:38 <lambdabot> forall a. Maybe a -> a
15:14:38 <vixey> use maybe
15:14:39 <vixey> :t maybe
15:14:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:14:52 <vixey> > (maybe (error "this is not good") id) Nothing
15:14:53 <lambdabot>  Exception: this is not good
15:14:55 <vixey> > (maybe (error "this is not good") id) (Just 3)
15:14:57 <lambdabot>  3
15:15:04 <wadcom> great, thanks guys! :-)
15:15:16 <vixey> maybe nothing just Nothing = nothing
15:15:20 <vixey> maybe nothing just (Just x) = just x
15:15:45 * Wild_Cat tries the wimp-out method: cabal install yi-gtk.
15:16:29 <Wild_Cat> (unless somebody wants to try a last-ditch diagnostic, considering the version that didn't install itself is the official yi 0.4.3 tarball)
15:16:40 <b\6> better way to IOize foo than make a little function with the right signature that accepts foo and returns foo?
15:17:19 <tehgeekmeister_> is it sequence i need to use to map putStr or something like that over a list of strings?
15:17:35 <b\6> maybe mapM_.
15:17:56 <tehgeekmeister_> that sounds right, thanks
15:18:00 <vixey> :t (>> return ()) . map
15:18:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> ()
15:18:06 <vixey> :t mapM_
15:18:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:18:09 <dons> dcoutts: btw, were you of the view that these encode wrappers to binary instances should some how force eof?
15:18:13 <dons> how strict should they be?
15:18:21 <vixey> :t (>> return ()) . sequence . map
15:18:46 <dcoutts> dons: the file ones, yes. They should force the following block but nothing more.
15:19:22 <dons> encode :: Binary a => a -> ByteString
15:19:22 <dons> encode = runPut . put
15:19:23 <dons> ?
15:19:29 <dons> or jsut
15:19:30 <dons> encodeFile :: Binary a => FilePath -> a -> IO ()
15:19:30 <dons> encodeFile f v = L.writeFile f (encode v)
15:19:38 <dons> and decode too.
15:19:39 <dcoutts> dons: eg supposing we finish decoding at some offset within the current block, the end of that block may well be the EOF boundary, we should therefor force the following block (which may turn out to be [], we don't care)
15:19:44 <dons> decode's the issue, actually
15:19:58 <dons> so how much do we have to force?
15:20:09 <dons> decodeFile, for example.
15:20:19 <dons> should it force the whole file to eof, and close the handle?
15:20:31 <dons> since the handles opaque, it seems like we implictly scope the resource anyway
15:20:45 <dons> 'decode' though, operating on pure memory, seems less obvious.
15:20:50 <dcoutts> dons: right
15:21:18 <dons> btw people's, there's haskell jobs to be had,
15:21:20 <dons>  http://www.reddit.com/comments/6wdk7/want_a_haskell_job_how_about_something_in/
15:21:20 <dcoutts> dons: yeah, for the file it's ok I guess. Are we sure that all binary get operations are strict? is it really safe to just hClose ?
15:21:22 <lambdabot> Title: Want a Haskell job? How about something in real-time collaboration in graphical  ..., http://tinyurl.com/5ecvqu
15:21:23 <dons> show some enthusiasm!
15:21:31 <Wild_Cat> ::sigh:: of course, it couldn't be this easy. http://hpaste.org/9648 on a cabal install yi.
15:21:34 <dons> dcoutts: no, they're all lazy.
15:21:45 <dons> well, except list i guess.
15:22:00 <dons> hm. actually, there's an arbitrary mixture :)
15:22:01 <vixey> I do not have the qualifications for a haskell job
15:22:53 <mar77a> i'll take a haskell job if i get to code in c++
15:22:58 <dcoutts> Wild_Cat: ah yes, I've fixed that bug but I cannot push it at the moment because my ADSL is fighting me, doesn't like me uploading large files atm.
15:23:12 <dons> mar77a: that sounds arse backwards. :)
15:23:13 <dcoutts> I can scp files of 6k, but not 8k, lovely
15:23:33 <Wild_Cat> dcoutts: heh. Sucks :p . Is that a bug in cabal-install?
15:23:48 <mar77a> >:)
15:23:55 <mar77a> quote material if you ask me
15:24:02 <dcoutts> Wild_Cat: yep, so just cabal install cabal-install :-)
15:24:23 <Wild_Cat> dcoutts: what will that do, revert to the latest official release?
15:24:35 <dcoutts> Wild_Cat: it'll install the latest release, yes.
15:24:48 * Wild_Cat ponders aliasing that sequence to cannibal-install
15:25:09 <marcot> dons: have you seen my mail about X11?
15:25:11 <tehgeekmeister_> anyone know of a program along the lines of less/most/more that can search from stdin without having all the input yet?  as in it'll just search what it's already received?
15:25:27 <dons> marcot: yes!
15:25:32 <dons> let me get through my inbox
15:25:49 <marcot> dons: ok, just checking cause sometimes my mails got to spam boxes, because of my mail server.
15:26:50 <ptolomy2> Ooh. I just cobbled together a nice little implementation of functional unparsing with bytestrings that seems pretty efficient. No more Printf and pack for me.
15:27:23 <Wild_Cat> ...right. installing yi still fails at "alex version >=2.0.1 && <3 is required but it could not be found."
15:27:48 <vixey> ptolomy2: do you have a small example use ?
15:27:55 <vixey> I want to see
15:28:48 <Wild_Cat> and since it's past midnight, I think I'll call it a day and come back to that problem tomorrow.
15:29:07 <ptolomy2> format (lit "I have " . int . lit " apples: " . fshow) 5 True -- yields "I have 5 apples: True"
15:29:33 <vixey> ah cool
15:29:45 <ptolomy2> accumulates a list of bytestrings, then concats them. Seems like an efficient way to go.
15:29:57 <hask> is there a paus command for the repl?
15:30:02 <hask> or for the IO moands
15:30:09 <dons> pause?
15:30:11 <hask> so I can print one line, lick enter
15:30:12 <dons> threadDelay?
15:30:27 <hask> rpint next line on enter-click
15:30:29 <vixey> :t getLine
15:30:31 <lambdabot> IO String
15:30:35 <dons> oh, just getLine
15:30:36 <ddarius> dons: Don't you know your batch file programming?
15:30:45 <dons> ddarius: hah. you win.
15:30:57 <dons> ?users
15:30:57 <lambdabot> Maximum users seen in #haskell: 490, currently: 472 (96.3%), active: 28 (5.9%)
15:31:33 <sw17ch> how does it compute active users?
15:32:01 <dons> said something in the last 2hrs, i think.
15:32:11 <sw17ch> ?users
15:32:11 <lambdabot> Maximum users seen in #haskell: 490, currently: 470 (95.9%), active: 29 (6.2%)
15:32:14 <sw17ch> hehe
15:32:18 <sw17ch> i'm not active :)
15:32:19 <sw17ch> now*
15:33:50 <dibblego> how do you prove that forall a. a -> a is once inhabited in a terminating subset?
15:34:07 <ddarius> dibblego: Parametricity.
15:34:45 <vixey> @free id
15:34:47 <lambdabot> f . id = id . f
15:34:53 <dibblego> you mean, since a is forall, it just has to be?
15:36:14 <rwbarton> If g is such that f . g = g . f for all f, take f = const x
15:38:12 <nolrai_East> does "f [] = []; f (x:xs) = xs" have a standard name?
15:38:44 <dibblego> @type safeTail
15:38:44 <ddarius> drop 1
15:38:46 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
15:39:09 <nolrai_East> ddarous: thanks!
15:39:23 <hask> can I somehow use print (type x)?
15:39:36 <vixey> hask: what
15:39:37 <vixey> ?
15:39:43 <chrisdone> > does the Typable class let you do that?
15:39:43 <lambdabot>  Parse error at "class" (column 18)
15:39:46 <chrisdone> whoops
15:40:34 <chrisdone> > typeOf 1
15:40:36 <lambdabot>  Integer
15:40:38 <chrisdone> :)
15:40:47 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
15:40:51 <lambdabot> Title: Data.Typeable, http://tinyurl.com/ylclo5
15:41:14 <ddarius> :t \x -> x
15:41:16 <lambdabot> forall t. t -> t
15:41:20 <ddarius> > typeOf (\x -> x)
15:41:22 <lambdabot>  Add a type signature
15:41:48 <ddarius> > typeOf ((\x -> x) :: forall a. a -> a)
15:41:48 <lambdabot>  Parse error at "." (column 30)
15:41:58 <vixey> :t typeOf
15:41:59 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:42:00 <hask> typeOf 1
15:42:11 <vixey> > typeOf ('x',3)
15:42:13 <lambdabot>  (Char,Integer)
15:42:16 <vixey> :t ('x',3)
15:42:18 <lambdabot> forall t. (Num t) => (Char, t)
15:42:48 <vixey> > typeOf ((\x -> x)::() -> ())
15:42:50 <lambdabot>  () -> ()
15:42:51 <vixey> > typeOf ((\x -> x)::a -> a)
15:42:53 <lambdabot>  Add a type signature
15:43:02 <eu-prleu-peupeu> i am happy
15:43:03 <vixey> this typeOf thing isn't that good
15:43:08 <eu-prleu-peupeu> some guy at hpaste solved my problem :)
15:43:14 <dons> vixey: heh.
15:43:15 <eu-prleu-peupeu> im such a noob :P
15:43:27 <ddarius> vixey: Use Clean's
15:43:43 <eu-prleu-peupeu> if anyone is interested: http://hpaste.org/9644 (the solution is on his final comment)
15:44:07 <eu-prleu-peupeu> thanks for all the support, im now implementing more methods, until i hit another barrier :D
15:45:55 <chrisdone> > dataTypeOf 'c'
15:45:57 <lambdabot>  DataType {tycon = "Prelude.Char", datarep = StringRep}
15:46:03 <chrisdone> > dataTypeOf 1
15:46:05 <lambdabot>  DataType {tycon = "Prelude.Integer", datarep = IntRep}
15:46:05 <eu-prleu-peupeu1> (wrong link, it was this one: http://hpaste.org/9641 )
15:49:51 <Leaves> hi, do you know if the haskell prelude contains a mod function for which mod -1 7 == 6 ?
15:50:01 <chrisdone> > show (\x -> x)
15:50:03 <lambdabot>        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
15:50:03 <lambdabot>                ...
15:50:07 <rwbarton> > mod (-1) 7
15:50:09 <lambdabot>  6
15:50:13 <rwbarton> Leaves: ^^ yes :)
15:50:48 <chrisdone> i gess show is useless rofl!1
15:51:20 --- mode: ChanServ set +o dons
15:51:23 --- mode: dons set +b *!*n=jdh30@*.bb.sky.com
15:51:23 --- kick: jdh30 was kicked by dons (dons)
15:51:26 --- mode: ChanServ set -o dons
15:52:11 <Leaves> oops, I forgot to type (-1) instead of -1, (-1 `mod` 7 gives -1), thanks for your help (and sry for the stupid question)
15:52:52 <vixey> just banning people randomly ? :S
15:54:13 * vixey wonders what's going on
15:54:41 * sw17ch notes that jdh30 is probably Jon HArrop
15:54:48 <b\6> i was just thinking that.
15:54:57 <lament> aw
15:54:59 * sw17ch also notes there was an unfriendly spat on haskell-cafe
15:55:01 <b\6> there's some scuffling going on on haskell cafe.
15:55:01 <vixey> was he spamming ?
15:55:06 <vixey> or trolling
15:55:13 <vixey> or .. saying anything in channel
15:55:23 <sw17ch> dons: private messages?
15:55:28 <vixey> maybe it should stay on haskell cafe
15:55:34 <b\6> he kind of got invited to troll, so he did.
15:55:55 <dons> sw17ch: sure.
15:56:09 <sw17ch> i mean, was he spamming them?
15:56:22 <vixey> I guess he was doing nothing
15:57:52 <vixey> there's a huge bug in my room :/
15:58:01 <lament> eat it
15:58:05 <ddarius> vixey: Then take it out.
15:58:25 <gweiqi> protein
15:58:27 <ddarius> or is it bigger than you vixey?
15:58:32 <vixey> hehe
16:00:01 <b\6> i kind of imagined the mario mushroom sound when bonus joined.
16:03:10 <hackage> Uploaded to hackage: logfloat 0.8.2
16:03:23 <ddarius> @hackage logfloat
16:03:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logfloat
16:10:29 <roconnor> \nick 1up
16:14:09 <stepcut> hrm... I'm not sure how I feel about this code,  addContext f = mapStateT $ mapWriterT $ fmap $ second $ map $ second $ fmap f
16:15:49 <nolrai_East> stepcut: whats the type?
16:16:17 <stepcut> addContext :: (Expr -> Expr) -> StateT Int (WriterT [(String, Maybe Expr)] Maybe) Expr -> StateT Int (WriterT [(String, Maybe Expr)] Maybe) Expr
16:16:46 <ndmitchell> Cale: how do i persuade someone to upgrade the Hoogle on lambdabot?
16:18:23 <Heffalump> why might I be getting "hClose: illegal operation (handle is finalized)" from a program that only ever calls writeFile on the file in question? This is on Windows if that makes any difference.
16:18:36 <dons> that's weird.
16:19:06 <Igloo> On a normal local filesystem?
16:19:27 <Heffalump> yes.
16:19:37 <Heffalump> It's completely reproducible but under a rather odd set of circumstances.
16:20:13 <ndmitchell> are there exceptions involved?
16:20:14 <dons> do those circumstances involve bananas and a pint?
16:20:32 <dons> or was that a different bug.
16:20:37 <hask> is there a problem with using concat on Lists containing my ownmade datas?
16:20:47 <Heffalump> ndmitchell: not that I'm aware of.
16:20:50 <stepcut> hask: no
16:21:00 <Heffalump> I don't think there are any bananas around either.
16:21:16 <ndmitchell> do you have enough disk space?
16:21:19 <Heffalump> yes
16:21:41 <Igloo> Are these odd circumstances likely to tickle a race condition?
16:21:41 <ndmitchell> and does it happen on writing the first byte, or after you have successfully written some stuff
16:21:55 <Heffalump> the file is 0 bytes after the program exits (due to that failure)
16:21:55 <stepcut> hask: the type of concat is [[a]] -> [a]. That tells you that concat can not be doing anything that depends on the specifics of the types involved.
16:22:18 <Heffalump> but it does exist. And it only seems to be that file causing the problem; the program can write a different file in exactly the same way successfully before that.
16:22:26 <Heffalump> Though I can also comment out the previous write and the same thing happens.
16:22:33 <Heffalump> (That's what the odd circumstances are)
16:22:36 <Heffalump> Igloo: NAFAIK.
16:22:42 <Heffalump> I don't believe there's any threading involved.
16:22:58 <ndmitchell> is it possibly this exact file? does it have read only attributes or anything?
16:23:00 <Igloo> So it's writing to this filename that breaks?
16:23:14 * Heffalump realises that there was an excel lying around that might have had it locked
16:23:50 <Heffalump> Excel has this bad habit of leaving invisible (in the UI sense) dead processes around.
16:24:01 <ndmitchell> Excel does do that, it always breaks for me with darcs, even on csv files
16:24:56 <hask> goodnight fellow haskellers
16:25:32 <hask> time to sleep so i can prepare to conquer the world with my lazy magic tomorrow
16:25:32 <vixey> this is so irritating
16:26:27 <Heffalump> nope, doesn't seem to have been that :-(
16:26:28 <vixey> the analysis of foldr insert [] vs split -> left right = (merge`on`mergeSort) left right makes it obvious that the insertion one is really slow compared to merge sort
16:26:31 * Heffalump decides to reboot
16:26:54 <vixey> but it still doesn't feel like insertion sort should actually be any slower
16:28:28 <vixey> why is sorting lots of lists and mashing them together faster than doing it directly?
16:30:07 <ndmitchell> Heffalump: try a reboot?
16:30:17 <stepcut> * Heffalump decides to reboot
16:30:33 <vixey> > 1+1
16:30:35 <lambdabot>  2
16:31:04 <vixey> and quicksort is faster than mergesort?
16:31:45 <byorgey> vixey: it is?
16:31:50 <b\6> depends on number of elements, etc.
16:31:55 <byorgey> not asymptotically
16:32:02 <byorgey> but may have better constant factors.
16:32:18 <Heffalump> aargh, stupid Windows, it won't let me reboot over remote desktop (at least not via the UI)
16:32:24 <vixey> I don't know how you can have an intuition about these sorting algorithms
16:32:31 <vixey> I feel like insertion sort is the fastes
16:32:44 <b\6> it will be, for some elements.
16:32:45 <vixey> but it is not..
16:33:12 <Igloo> You can do it by SSHing into cygwin, if that helps
16:34:24 * Heffalump discovers that typing 'shutdown' at a command prompt works
16:34:29 <rgage> Heffalump: not sure, but doesn't ctrl-alt-end work in remote desktop?
16:34:43 <Heffalump> rgage: doesn't seem to
16:34:58 <chrisdone> chr1s: agh all my code broked with formlets 0.4.3 D:
16:35:53 <byorgey> vixey: interesting question.  I have good intuition as to why insertion sort is O(n^2) and merge sort is O(n lg n), but I'm not sure I have a direct intuition as to why one is faster than the other.
16:37:06 <Heffalump> ordering is transitive
16:37:16 <Heffalump> so you can do less work by taking advantage of that fact
16:37:30 <vixey> transitive in what respect?
16:38:35 <Heffalump> a <= b && b <= c => a <= c
16:39:20 <Shiruka> maybe the unintuitiveness is because small-scale physical examples (such as a deck of cards..) have fast insertion operation
16:39:46 <byorgey> right, so if you have an algorithm that compares a and b, b and c, AND a and c, it can probably be improved upon.
16:45:15 <ddarius> @google Insertion Sort is O(n log n)
16:45:27 <lambdabot> http://citeseer.ist.psu.edu/bender04insertion.html
16:51:15 <Shiruka> interesting tidbit :-)
16:51:24 <b\6> i want to fold OK (&&*) xs, but the xs are in IO and my result needs to be in IO.
16:52:05 <yitz> ddarius: hmm, so there is something to vixey's thought. you don't really need gaps, either. just insert into a data structure that has log n insertion, like Data.Sequence.
16:52:51 <yitz> @type foldM
16:52:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:53:27 <vixey> @hoogle Data.Sequence
16:53:28 <lambdabot> A Hoogle error occurred.
16:53:32 <vixey> well is,
16:53:40 <vixey> foldr Data.Sequence.insert Data.Sequence.nil
16:53:43 <vixey> n log n?
16:53:56 <vixey> (insert and nil probably don't exist)
16:55:07 <b\6> yitz: yeah, tried. maybe the folding function needs to be like \a b -> return $ a &&* b
16:55:31 <vixey> how would you write insert for data.sequence?
16:56:07 <ddarius> take n s ++ x ++ drop n s
16:57:36 <yitz> b\6: ah, &&* is pure? so how about xs >>= return . foldl' (&&*) OK
16:58:11 <twanvl> case splitAt n seq of (before,after) -> before >< x <| after
16:58:56 <vixey> it should be insert 3 [0,2,5,7] = [0,2,3,5,7]
16:59:09 <vixey> but is it possible in log n time?
17:00:07 <BMeph> vixey: it's called empty, not nil, but otherwise, you're good. :)
17:00:09 <twanvl> yes, splitAt is O(log n), and so is (><)
17:00:30 <vixey> I don't have the value 'n' though
17:02:27 <Armored_Azrael1> I forget--is it good form for main to be IO () or IO Int?
17:02:36 <vixey> it doesn't matter
17:02:44 <Armored_Azrael1> Oh, does Int not set the return value?
17:02:48 <twanvl> vixey: Why are you using Data.Sequence here? This looks like a job for Data.Set
17:02:53 <vixey> ok
17:03:07 <twanvl> Armored_Azrael1: main must always have type IO ()
17:03:12 <Armored_Azrael1> twanvl: OK
17:03:13 <yitz> twanvl: my fault
17:03:16 <ddarius> twanvl: False.
17:03:22 <ddarius> main's type is IO a
17:03:43 <vixey> toList . foldr Data.Set.insert Data.Set.empty is n log n?
17:04:32 <twanvl> vixey: Yes, but why not use Data.Set.fromList
17:04:51 <yitz> vixey: S.toList . S.fromList
17:05:04 <vixey> is fromList = foldr insert empty ?
17:05:28 <gwern> the good ol' toList.fromList trick; surprisingly handy and performant
17:05:39 <ndmitchell> vixey: that is fixed in Hoogle 4, persuade the lambdabot God's to upgrade and it will work :)
17:05:47 <twanvl> = map head . group . sort
17:05:50 <yitz> twanvl: there are many ways to sort. we were discussing how specifically an insertion sort could be O(n*log n). That's why I mentioned Data.Sequence. Sorry for the confusion.
17:06:05 <BMeph> (From the source code:)fromList xs   = foldlStrict ins empty xs
17:06:06 <twanvl> yitz: ah
17:06:11 <gwern> twanvl: actually, I benchmarked that against the set trick. it performs like shit
17:06:24 <vixey> my test shows that insertionSet is a little slower than merge sort :(
17:07:00 <b\6> yitz: hmm. i think that's expecting xs to be in IO or something. but the situation is that xs contains things that evaluate to stuff in IO.
17:07:01 <vixey> much much better than insertion sort though
17:07:05 <twanvl> gwern: It does? that is strange
17:07:12 <vixey> Comparing times for 1048576 sized list..
17:07:12 <vixey> merge: 8 secs insertionSet: 19 secs
17:07:19 <yitz> b\6: what's the type?
17:07:28 <vixey> oh wait a sec
17:07:33 <gwern> yeah. everyone seems to think it's fast to do map head... versus nub or toList, but it's the slowest one iirc
17:07:51 <vixey> yeah
17:07:54 <vixey> insertionSet [1,1,2] = [1,2]
17:07:58 <vixey> so it's not a sort algorithm
17:08:06 <yitz> vixey: good point
17:08:08 <vixey> I can't use Data.Set
17:08:39 <vixey> but yeah I think I can have log n insertion into a binary tree right?
17:08:52 <vixey> and then enumerate the leaves in O(n)
17:09:34 <yitz> gwern how could group . sort be slower than nub?
17:09:53 <ddarius> vixey: Yes.  That is tree sort.
17:09:59 <gwern> yitz: don't ask me, man, I'm not the compiler
17:10:00 <b\6> yitz: the function is :: IO Might. so it's like [f0, f1, f2] >>= return . foldl' (&&*) OK. all the f* functions are :: IO Might.
17:10:21 <vixey> map head . group . sort must be faster
17:10:34 <yitz> vixey: that's pretty much what you are doing with Data.Sequence, but it's wrapped up to look like an insertion sort.
17:10:35 <gwern> all I know is map head... performed so terribly it would lock my 'puter, whereas the other two at least terminated on my list of Ints within less than half an hour
17:11:14 <yitz> gwern weird. was the problem with sort, or with group, or only the combination?
17:11:40 <gwern> I didn't try any subsets, just the full map head
17:11:44 <ddarius> yitz: Data.Sequence.Seq isn't an ordered tree.
17:12:24 <dons> mfp: well, re. the post, in my defense, it is an unusual domain to find haskell. they're not a bank or a defense contractor.
17:12:37 <dons> only the unusual ones end up on reddit.
17:12:45 <dons> if you have any better news of the day, feel free to submit it.
17:17:05 <yitz> ddarius: it's ordered by the index. so yeah, I guess you'll get a (log n)^2 when you look for where to insert. hmm, are we back to gaps? or can we find a flaw in that paper and show that there's is also O((log n)^2)?
17:17:23 <yitz> s/there/their/
17:21:19 <yitz> well, I guess you could say that they are using memory access, which is really log n. ;)
17:21:26 <ddarius> yitz: We aren't sorting the indices.  Data.Sequence.Seq requires no ordering on the element type.  The only way to find where to insert the next element is to traverse it linearly.
17:21:42 <yitz> ddarius: or bin search
17:21:55 <ddarius> Binary search only works if the thing is already ordered.
17:22:13 <yitz> ddarius: the ones you have already inserted are ordererd
17:22:22 <yitz> s/ordererd/ordered/
17:23:30 <ddarius> I don't think using a binary search on the ordered part would affect the overall asymptotic complexity.
17:25:01 * lispy waves lambda hands at the good people of #haskell
17:25:17 <ddarius> lispy: You murderer!
17:25:18 <yitz> ddarius: I am assuming that we are not starting with the list already in a D.S. Rather we fold over them, inserting each one into the initially empty D.S with a bin search, then get them all back out with toList. Make sense?
17:25:28 <lispy> ddarius: eh?
17:25:29 <Heffalump> gaah, it's still happening after the reboot
17:27:27 <twanvl> "Lispy Lambdahands"?
17:28:11 <ndmitchell> Heffalump: only that one file?
17:28:19 <ndmitchell> Heffalump: can you delete that file?
17:28:20 <ddarius> yitz: That should work.
17:29:14 <yitz> of course, that's already cheating a little. it's doesn't really look like a classic insertion sort anymore.
17:29:46 <ddarius> Except, indexing is roughly O(log n) so that gives you O(n (log n)^2)
17:31:13 <pastorn> @paste
17:31:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:35:44 <zeta-> I'm looking for a charting library -- XY plot for list of complex floats or pairs -- any pointers?
17:36:03 <yitz> ddarius: yeah.
17:38:20 <BMeph> zeta: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Chart, perhaps? :)
17:38:22 <lambdabot> Title: HackageDB: Chart-0.8
17:39:15 <zeta-> BMeph: sound good :-) will check it out -- thanks
17:39:44 <BMeph> Sure. Feel free to look around more on Hackage. :)
18:07:23 <adu> hi
18:07:41 * adu :: Confusion -> IO Logic
18:07:59 * SamB_XP begins to wonder what exactly the riot act *is*
18:08:47 <adu> Pearl Jam?
18:08:58 <adu> i wonder if there is a Haskell Jam
18:09:25 <adu> SamB: http://en.wikipedia.org/wiki/Riot_Act_(album)
18:09:35 <paczesiowa> there are hackatons
18:09:41 <SamB_XP> adu: uh, you can't read that to people
18:09:44 <paczesiowa> are whatever they're called
18:09:46 <SamB_XP> that's an album
18:09:57 <SamB_XP> not any sort of text
18:11:19 <QtPlatypus> SamB_XP: It was an act of parlement that basically said that anyone who did not disperce after the act was read out loud would be arrested for roiting.
18:11:48 <SamB_XP> interesting!
18:12:01 <SamB_XP> that's kind of cyclic
18:13:15 <adu> QtPlatypus: how would they hear it completely if they dispersed?
18:13:49 <Philippa> http://en.wikipedia.org/wiki/Riot_Act
18:13:50 <lambdabot> Title: Riot Act - Wikipedia, the free encyclopedia
18:14:22 <BMeph> adu: If they displersed, they wouldn't need to be read to, thus, you wouldn't do it. That's what we call "lazy government." ;)
18:14:26 <adu> my link has parentheses, that means its more useful
18:14:33 <adu> :P
18:14:35 <BMeph> s/displersed/dispersed/
18:15:07 <adu> BMeph: you mean non-strict?
18:16:19 <BMeph> adu: ...
18:16:31 <BMeph> adu: Mm, not-so-much. ;p
18:16:50 * sw17ch likes ErrorT a lot
18:17:23 <paczesiowa> sw17ch: :)
18:17:27 <adu> i like ExceptionT
18:18:59 <sw17ch> paczesiowa, it's working out great :)
18:19:11 <sw17ch> i'm going to have to find a better way to hid the runErrorT part...
18:19:22 <sw17ch> (the problem is that i want access to it in a lot of different places)
18:19:44 <sw17ch> (well, expose more functions than i currently am)
18:21:50 <sw17ch> how much overlap is there between #haskell and Reddit...
18:22:55 <dons> hmm. 100 degrees in the shade. warm.
18:22:56 <avegas> greetings haskellers
18:23:03 <dons> welcome, avegas
18:23:12 <dmwit> Hiya!
18:23:12 <adu> greetings
18:23:27 <avegas> I'm playing about with J.R. Heard's Beautiful Code, Compelling Evidence
18:23:49 <dons> oh, nice.
18:23:56 <avegas> http://bluheron.europa.renci.org/docs/BeautifulCode.pdf
18:23:58 <lambdabot> Title: B C , C E
18:24:04 <adu> avegas: absence of evidence is not evidence of absence
18:24:13 <avegas> so anyways, I've never compiled any haskell code
18:24:32 <avegas> I've got ghc and a plethora of packages installed on my ubuntu box
18:24:36 <dons> ah. you'll want to do something about that :)
18:24:47 <dons> have you gone through one of the 5 minute introductions?
18:24:48 <avegas> I am :D
18:25:05 <avegas> anywhoo
18:25:11 <adu> avegas: but Haskell is the most beautiful code ever
18:25:18 <adu> avegas: generally
18:25:19 <paczesiowa> sw17ch: we like to waste our time:>
18:25:21 <dons> heh.
18:25:26 <dons> what's your question, avegas ?
18:25:47 <paczesiowa> dons: you ask him to ask?
18:25:58 <adu> lol
18:26:09 <paczesiowa> don't ask to ask just wait until we ask you to ask
18:26:17 <avegas> so,  I'm trying to build Heard's Sparklines bit
18:26:25 <dmwit> dons is a busy man
18:26:37 <avegas> which is on page 23
18:26:49 <dmwit> Oh, I heard other people were having trouble with sparklines, too.
18:26:53 <avegas> of the link
18:26:54 <dmwit> You might want to start with something else.
18:27:12 <sw17ch> it would be interesting to put together some kind of package that would detect "linked from IRC chatroom" based on the flurry of clicks to a deep link
18:27:27 <dmwit> (Or, you might want to fight ahead and figure out what's wrong. =P)
18:27:32 <adu> avegas: have you done a helloworld yet?
18:27:39 <avegas> nope
18:27:46 <adu> avegas: build this: http://hpaste.org/9653
18:27:53 <avegas> hang on gf is annoying
18:28:03 <gwern> (wow, quick reply from the chortl guys)
18:28:04 <adu> avegas: "ghc --make hello.hs"
18:28:19 <dmwit> avegas: Also, just by glancing at the link: have you got Gtk2Hs installed?
18:29:12 <avegas> yes
18:29:46 <dmwit> Okay.
18:29:57 <avegas> Main.hs:5:17: parse error on input `!'
18:29:58 <dmwit> Do let us know if you can make helloworld, and what ghc --version says.
18:30:39 <avegas> sorry, gf called and demanded tending
18:30:53 <avegas> I will build helloworld to appease you
18:31:02 <mmorrow> lol
18:31:05 <dmwit> import Data.Map ((!))
18:31:12 <dmwit> He wrote too few parens there.
18:31:19 <dmwit> I wonder if he built it himself... =P
18:31:43 <avegas> the beautiful code thing has lovely typesetting, but seems a bit hastily published
18:32:08 <mmorrow> avegas: if the problems you were having with building hsparklines were gd-related, try installing at least libgd.so.2
18:32:28 <mmorrow> someone had that problem a while back
18:32:37 <paczesiowa> SyntaxNinja: why xml outputs non-ascii chars as Numeric character references (ć -> &#263; ) ? it can blow the size of feed by factor of 3 with russian or asian languages (11% for polish)
18:32:42 <adu> avegas: I've also written something in HOpenGL, so if you need help with that you can ask me
18:34:55 * sw17ch wonders if any one in here has used FTGL yet
18:34:59 <avegas> so, is whitespace significant in haskell?
18:35:02 <dmwit> yes
18:35:10 <avegas> I approve :D
18:35:21 <avegas> the emacs haskell major mode will set me aright?
18:35:25 <dons> sw17ch: i've built an arch package for it.
18:35:31 <dmwit> avegas: Not too likely.
18:35:47 <dmwit> It will probably try, though. =)
18:36:42 <avegas> my compiler is now griping about a possible indentation error in this file
18:36:43 <avegas> http://hpaste.org/9655
18:37:14 <dmwit> avegas: Check the indentation in the PDF.
18:37:26 <dmwit> In particular, "sheet" and "return" need to line up.
18:37:27 <avegas> so, I initially closely imitated that
18:37:44 <avegas> and got an error in a different place
18:37:50 <avegas> so I tried tabbing about with emacs
18:37:54 <dmwit> Yeah, it doesn't have matching parens!
18:37:56 <dmwit> =/
18:37:59 <adu> avegas: make sure "sheet" and "return" have the same prefix whitespace
18:38:14 <adu> avegas: get haskell-mode.el
18:38:14 <dmwit> Stick a ')' before `fmap`, maybe.
18:38:22 <avegas> yep, the unmatched parens are from the pdf
18:38:33 <dmwit> avegas: I know, hence the =/.
18:38:39 <sw17ch> dons: but you haven't done the OpenGL "Hello World" with it?
18:38:42 <adu> avegas: do you have haskell-mode?
18:38:59 <avegas> indeed
18:39:03 <sw17ch> SELECT * FROM #haskell WHERE linux_dist = "gentoo";
18:39:25 <adu> {}
18:39:34 <avegas> well, must go meet the girlfriend in central sq
18:39:34 * Twey joins the resultset.
18:39:41 <dmwit> sw17ch: I think maybe sjanssen, dunno about anybody else.
18:39:42 <paczesiowa> > /j gentoo-haskell ?
18:39:43 <avegas> will give things another go upon the morrow
18:39:43 <lambdabot>  Parse error at end of input
18:39:47 <Twey> Haha
18:39:50 <avegas> thanks haskellers
18:40:07 <sw17ch> SELECT * FROM #haskell WHERE linux_dist = "arch";
18:40:07 <dmwit> avegas: NYC?
18:40:23 <dmwit> sw17ch: dons, maybe others
18:40:44 <paczesiowa> dons: why xml outputs non-ascii chars as Numeric character references (ć -> &#263; ) ? it can blow the size of feed by factor of 3 with russian or asian languages (11% for polish)
18:40:51 <dons> hmm
18:40:59 <dons> paczesiowa: that's a good point.
18:41:01 <dons> we should get you a repo.
18:41:45 <avegas> dmwit, cambridge ma
18:42:00 <avegas> gf is a new yawker though
18:42:23 <dmwit> have fun =)
18:42:32 <avegas> always do
18:42:37 <shapr> avegas: Hey, are you coming to the Davis Square #haskell drinking gathering?
18:42:44 <adu> my gf dumped my for her ex
18:42:53 <adu> :(
18:42:54 * sw17ch notes that a Haskell job just showed up in Cambridge
18:42:56 <dons> shapr: did you see that haskell job in your area?
18:42:59 <shapr> no??
18:43:01 <shapr> WHERE?
18:43:05 <paczesiowa> dons: that should be easy fix - just remove all the escaping code - haskell Strings are already unicode, then just provide fun to print it with utf8encoding (can be done with encoding package)
18:43:13 <nodogbite> avegas: i miss cambridge!
18:43:16 <dons> they seem like friendly guys, chatting to them via email.
18:43:25 <dons> paczesiowa: yep
18:43:35 <dons> shapr: http://article.gmane.org/gmane.comp.lang.haskell.cafe/43175
18:43:39 <lambdabot> Title: Gmane -- Mail To News And Back Again
18:44:00 <sw17ch> Peerium looked like it would be a fun place
18:44:08 <shapr> Sounds awesome!
18:44:12 <sw17ch> though their website wasn't all that descriptive :)
18:44:19 <dons> the iphone apps they write are just a side hobby
18:45:12 * sw17ch wants Haskell jobs in the west michigan area
18:46:20 <dons> speaking of which, let's write some iphone apps!
18:46:32 <dons> take over the world, $1.99 at a time.
18:46:51 * sw17ch just entered a two year contract with Verizon :(
18:47:09 <dons> it's a trap!
18:47:14 <shapr> yes it is!
18:47:37 * sw17ch uses 40 minutes per month .. and about 700 MB
18:48:06 <sw17ch> but my phone doesn't even pretend to be able to run haskell
18:49:14 <dons> shapr: did you see nomeata got xmonad running on openmoko?
18:49:21 <shapr> Yeah, that's awesome!
18:49:33 <dons> yeah!
18:50:08 <newsham> i dont need a phone thats lazier than me
18:51:08 * dons loves portland. just got back from the farmer's market, with fresh berries, salad, cucumbers, and crazy tomators. and now relaxing with a nice season high desert ale. 
18:51:12 <dons> america's not so bad :)
18:51:19 <bjrn> tbh the haskell culture is probably wrong for writing the kind of apps people would wanna buy for their iphone. Take a ruby programmer. He would write a shiny iPhony apple-like app. Perhaps something to do with socializing, restaurants. Python programmer? An app to keep track of friends! Haskell programmer? Theorem prover using a language resembling Martin-Lof Type Theory.
18:51:39 <dons> how about all the little games, bjrn ?
18:51:47 <dons> puzzles. we like puzzles!
18:51:58 <nomeata> which I find puzzling, in a sense.
18:51:58 <bjrn> Hehe just mocking
18:51:59 <dons> mental puzzles, of course.
18:52:04 <nomeata> and even more when out of my senses.
18:52:24 <dons> how's argentina, nomeata ?
18:52:24 <dmwit> I wrote a clone of that network game.
18:52:41 <dmwit> But Cairo is slow!
18:52:46 <dmwit> Especially when you use it wrong, like me. =/
18:52:51 <sw17ch> my professor was just showing off the light saber iphone app
18:52:57 <nomeata> dons: nice so far. we are hopefully going to announce Debian support on the FreeRunner tomorrow, and then try to handle the community reaction
18:53:06 <newsham> dons: nice.  wish there were more of those near me.
18:53:20 <dcoutts> dmwit: heh heh
18:53:28 <sw17ch> there's a great farmer's market in Grand Rapids
18:54:15 <dcoutts> dmwit: trick is to avoid gradients and to cache things that don't change frequently, compositing is really fast.
18:54:16 <newsham> i like the prog someone wrote for their phone -- using an accelerometer to detect the tilt, had a virtual ball that rolled around and bounced off the edges
18:54:40 <bjrn> didn't someone code that maze game for an apple laptop?
18:54:50 <dmwit> dcoutts: Ah, well, I "stroke"d after every "lineTo" instead of doing all the lines at once.
18:55:10 <dcoutts> dmwit: aye, that won't help
18:55:43 <newsham> http://www.youtube.com/watch?v=eDQgWoL2D-g
18:55:44 <lambdabot> Title: YouTube - Sliding Ball (K850, W910, C902, W760, ...)
18:57:24 <sw17ch> paczesiowa, i have a scary ErrorT error if you want to help me figure out what it means quick :)
18:57:28 <dmwit> dcoutts: But I have to cut me a little slack, it was my first time ever doing a GUI.
18:57:33 <paczesiowa> sw17ch: np
18:57:43 <shapr> avegas: beer in somerville some weekend?
18:58:00 <dcoutts> dmwit: :-)
18:58:00 <shapr> We had three Haskellers and three programming language theory grad students the previous weekend.
18:58:12 <shapr> Went out drinking, and I got home at 5am
18:58:30 <shapr> adjoint functor was a perfectly normal bit of vocabulary in that group.
18:58:33 <dcoutts> dmwit: for cairo and animation, I'm quite pleased with my haskell port of the cairo clock, in the gtk2hs demo collection.
18:58:35 <sw17ch> paczesiowa, http://hpaste.org/9656
18:58:36 <newsham> how many programming langugae theory grad students does it take to stay out till 5am drinking?
18:58:46 <bjrn> glguy: i recognize your nick from somewhere. were you active at the valladolid online judge several years ago?
18:58:53 <shapr> newsham: Well, I'm the one that gave out first... but I am ten years older than the rest :-)
18:59:03 <SamB_XP> newsham: as many as you can afford to buy drinks for
18:59:21 <paczesiowa> sw17ch: which line is 711
18:59:44 <glguy> bjrn: I don't recognize "valladolid"
18:59:48 <sw17ch> paczesiowa, the last line of the type signature, but i think it means 712
18:59:55 <newsham> i wonder if there are three haskellers who live within 500 miles of me
18:59:57 <sw17ch> c2hs seems to get confused with line numbers some times
19:00:11 <sw17ch> newsham, i'm hoping for more than 1
19:00:18 <sw17ch> i know of one
19:00:22 <shapr> newsham: If they don't live within 100 miles, could they be within 200-500?
19:00:23 <dmwit> newsham: Almost certainly.  500 miles is pretty far.
19:00:37 <shapr> I mean, they'd have to be whales or something, right?
19:00:41 <paczesiowa> throwError (show err) -> throwError (strMsg (show err))
19:00:51 <bjrn> glguy: Ah okay, not you then. :) the online judge is http://online-judge.uva.es/problemset/
19:00:53 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
19:00:54 <newsham> shapr: *shrug* who knows..  some sort of evil genius floating platform thing?
19:01:07 <shapr> Could be.. Dr Horrible-style
19:01:10 <dmwit> Saying there are >75,000 square miles of land with no Haskell programmer in them is pretty strong...
19:01:22 <shapr> dmwit: newsham lives in Hawaii
19:01:26 <sw17ch> paczesiowa, can you explain why that fixed it? :)
19:01:29 <newsham> there's not 75k sq miles of land nearby
19:01:35 <dmwit> shapr: heh... oh
19:01:36 <dmwit> =/
19:01:39 <paczesiowa> :t throwError
19:01:40 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
19:01:43 <sw17ch> newsham, since Hawaii is a small place, do you know an Alan Ritari?
19:01:50 <newsham> i do not.
19:01:54 <sw17ch> darn
19:01:59 <shapr> Me neither... he must not live in Boston.
19:02:01 <paczesiowa> :t throwError ""
19:02:02 <lambdabot> forall (m :: * -> *) a. (MonadError [Char] m) => m a
19:02:05 <shapr> Since I know everyone in Boston, obviously.
19:02:17 <shapr> Actually, I do wish I knew a few more people in Boston.
19:02:57 <sw17ch> does the author of Language.C hang out in here?
19:03:02 <paczesiowa> sw17ch: :t act
19:03:12 <shapr> Ooh, I haven't tried Language.C yet, are there good examples?
19:03:19 <shapr> Does it work with the Linux kernel source yet?
19:03:28 <shapr> I'd enjoy reporting several hundred bugs at once.
19:03:59 <dmwit> shapr: To the Linux kernel, or to the Language.C guys? =P
19:04:05 <shapr> I'm not picky.
19:04:11 * Twey grins.
19:04:18 <paczesiowa> sw17ch: somehow it get IOError from other computation, can't tell more without all the types
19:04:50 <dcoutts> shapr: it should do, I wrote the C parser it started from and it could parse the whole kernel, glibc and the rest of the gentoo base system packages.
19:04:59 <shapr> Wow, awesome!
19:05:35 <dmwit> Compiling is a lot harder than parsing, I guess.
19:05:38 <shapr> I wonder if we can kick Coverity in the butt.
19:05:54 <paczesiowa> proof by authority?
19:05:55 <SamB_XP> shapr: eh?
19:06:03 <dmwit> (Parsing is still pretty painful, though, so mega props to dcoutts etc.)
19:06:07 <shapr> @go coverity
19:06:09 <lambdabot> http://www.coverity.com/
19:06:09 <lambdabot> Title: Static source code analysis, static analysis, software quality tools by Coverity ...
19:06:20 <shapr> @go coverity linux
19:06:22 <lambdabot> No Result Found.
19:06:22 <dcoutts> shapr: I doubt it. What I had was just a parser + what c2hs does with it after.
19:06:46 <dcoutts> shapr: the gsoc project was to make it into a nice lib interface and provide a bit more post-parsing infrastructure
19:06:58 <newsham> shapr: prefast probably kicks coverity in the butt
19:07:05 <newsham> err.. prefix
19:07:06 <sw17ch> paczesiowa, act :: PaStream a -> Ptr () -> Int
19:07:10 <sw17ch> or something close
19:07:29 <sw17ch> woops
19:07:30 <sw17ch> almost
19:07:47 <sw17ch> that's not right at all
19:07:55 <paczesiowa> ?
19:07:59 <sw17ch> paczesiowa, act :: Ptr () -> ErrorCode
19:08:17 <dcoutts> dmwit: aye, C parsing is a major pita. declarator syntax is horrible, it's not LALR and needs a 'stateful' lexer
19:08:32 <newsham> parsing is but a minor step in the whole static analysis scheme, though.
19:08:37 <paczesiowa> sw17ch: IO ErrorCode?
19:08:42 <dmwit> eww
19:08:54 <newsham> there's some public/free static analysis stuff written in ocaml using CIL.
19:08:58 <dmwit> Oh, declarator is #define?
19:08:59 <sw17ch> umm yes, sorry
19:09:11 <paczesiowa> @src ErrorCode
19:09:12 <lambdabot> Source not found. Maybe you made a typo?
19:09:14 <sw17ch> shapr, i love the C pretty printer in Language.C
19:09:18 <dmwit> Then yeah, I guess I would even believe non-context-free.
19:09:18 <sw17ch> paczesiowa, i'm sorry, that's my own invention
19:09:19 <dcoutts> dmwit: no, variable/function declarations
19:09:24 <dmwit> oh
19:09:30 <dmwit> Really??
19:09:42 <dcoutts> dmwit: like "volitile unsigned char *a[]"
19:09:49 <paczesiowa> :t allocaArray
19:10:19 <sw17ch> paczesiowa, Foreign.Marshal.Array.	allocaArray	:: Storable a => Int -> ( Ptr a -> IO b) -> IO b
19:10:27 <newsham> dcoutts: stateful because typedef?
19:11:01 <sw17ch> paczesiowa, i did communicate that the strMsg makes it work, right?
19:11:07 * sw17ch goes back to make sure
19:11:28 <dcoutts> newsham: right, you can't tell if a token is a type name or not lexically, only by having seen it earlier. And typedef is scoped, so tokens can switch from ordinary names to type names and back again :-)
19:11:29 <paczesiowa> sw17ch: sorry, can't see the reason why it didn't work. I'd need more context
19:11:49 <sw17ch> *did* work
19:11:50 <newsham> scoped in C?  i thought just c++
19:11:59 <newsham> is that some new C99 type thing?
19:12:00 <paczesiowa> sw17ch: and come on! r <- ...; return r ??
19:12:01 <sw17ch> i just want to know why it *did* work instead of just taking the answer :)
19:12:23 * sw17ch blushes
19:12:29 <dcoutts> newsham: so the lexer needs a stack of sets of typedef'ed names and the parser needs to tell the lexer each time it sees a new typedefed name, and it has to push/pop scopes.
19:12:45 <sw17ch> i do a lot of that out of habit for some reason
19:13:09 <dcoutts> newsham: no, as I recall it's typedefs inside structs or functions or something
19:13:24 <newsham> hmm.. tpyedefs in structs and functions!?
19:13:31 <paczesiowa> sw17ch: I know!
19:13:48 * ddarius also doesn't know what dcoutts is talking about.
19:13:49 <paczesiowa> throwError (show err) was lifted!
19:14:00 <paczesiowa> you lift before case
19:14:34 <paczesiowa> so that was throwError inside IO
19:14:41 <paczesiowa> then lifted to ErrorT
19:14:54 <paczesiowa> so strMsg is wrong fix
19:14:57 <sw17ch> paczesiowa, oh wow, i see it
19:14:58 <dcoutts> newsham: you can have local typedefs in any { .. } block in C.
19:15:52 <newsham> could you show me an example?
19:15:55 * lispy is really sick of overly clever code :( :(
19:16:02 <paczesiowa> now I don't know how on earth did that strMsg fix anything
19:16:06 <dcoutts> newsham: or perhaps I'm forgetting and it's the otherway around and one can have local variables shadow global typedefs, it's been a while since I looked at this.
19:16:15 <sw17ch> hahaha
19:16:27 <sw17ch> and now i'm not sure how to fix anything :)
19:16:39 <paczesiowa> and a little bit ashamed that random hack did typecheck
19:17:05 <paczesiowa> sw17ch: wait
19:17:28 <paczesiowa> sw17ch: false alarm I got whitespace wrong
19:17:38 <sw17ch> ...was it good the first time?
19:17:55 <sw17ch> because i'm starting to think the first way was right...
19:17:56 <paczesiowa> now it's personal! gimme a min
19:17:59 <newsham> hmm.. sure enough, i can shadow a typedef with a local var.
19:18:11 <newsham> i thought the namespaces were separate
19:18:27 <newsham> i wonder if this is k&r, or recent.
19:18:35 <dcoutts> newsham: so that alone means we need a stack of names, I'm now not sure about the local typedefs, but the ability to shadow them is enough.
19:18:39 <paczesiowa> sw17ch: now I know!
19:18:47 <paczesiowa> :t peekArray
19:18:48 <newsham> *nod*
19:19:00 <newsham> i'm a bit suprised.. wasnt aware of that
19:19:01 <sw17ch> lambdabot died?
19:19:10 <lispy> ?bot
19:19:10 <lambdabot> :)
19:19:16 <sw17ch> @type peekArray
19:19:17 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:19:22 <sw17ch> D:
19:19:24 <lispy> sw17ch: not died so much as stoped giving type errors perhaps?
19:19:30 <dcoutts> newsham: I don't think they're separate, or could be separate, there are examples that parse (differently) even if you switch a name from being a name to a typedef.
19:19:33 <sw17ch> Foreign.Marshal.Array.peekArray	:: Storable a => Int -> Ptr a -> IO [a]
19:19:40 <paczesiowa> peekArray len ptr :: IO, so peekArray len ptr >>= return . (chunk chns) :: IO so  throwError (show err) goes in IO too
19:20:04 <sw17ch> mmm
19:20:37 <paczesiowa> lift peekArray len ptr >>= return . (chunk chns) or just  peekArray len ptr should be the same
19:20:50 <paczesiowa> return will adapt
19:21:54 <dmwit> fmap (chunk chns) (lift peekArray len ptr)
19:22:18 <dmwit> oops
19:23:01 <lispy> fmap it up yo
19:23:04 <sw17ch> i'm still not sure whether i'm supposed to have the strMsg or not :)
19:23:18 <paczesiowa> sw17ch: wait a min
19:23:45 <paczesiowa> you want withPtr to work in IO?
19:23:50 <paczesiowa> or ErrorT?
19:24:09 <sw17ch> withPtr in ErrorT
19:24:35 <sw17ch> i need a readStream_ffi failure to send the error all the way back out
19:24:43 <paczesiowa> but allocaArray takes IO
19:24:57 <paczesiowa> you'd have to runErrorT it
19:25:05 <sw17ch> ... that'd be fine
19:25:28 * sw17ch keeps forgetting that part
19:26:13 <paczesiowa> so act returns pure errror and you have to decide to throw it as monad error in one of two monads
19:26:30 <sw17ch> paczesiowa, oh, i think i see now...
19:26:39 <sw17ch> i'm stepping into IO, so i actually do need to lift the error out my self
19:26:52 <sw17ch> and outside decide what to do with it
19:26:56 <paczesiowa> damn, couldn't you just write some php with regexes?
19:27:20 <adu> wow i didn't know monad bigotry caused to many problems...
19:27:50 <paczesiowa> I'll get some coffe and think some more about it
19:28:26 <sw17ch> i'm still quite curious how the strMsg played the part of magic and caused everything to go away... and i'm wondering if that's so bad :)
19:28:59 <adu> why is there a tendency to resort to PHP?
19:29:17 <newsham> its a language of resort...
19:29:46 <dmwit> PHP just allows more wrong programs than Haskell does, that's all.
19:29:49 <Guest71909> in case anybody was interested, i found a reasonable (non-haskell) implementation of the inverse error function on the web. the haskell is at http://hpaste.org/9657#a0
19:30:02 <newsham> have you ever heard of someone resorting to haskell?
19:30:09 <Guest71909> hmm. why am i no longer "rog"?
19:30:12 <adu> newsham: I've always thought of Haskell as a resort and PHP as hell...
19:30:25 <dmwit> Guest71909: Maybe the real rog ghosted you?
19:30:33 <dmwit> (Dunno if you are the real rog or not. =)
19:30:45 <Guest71909> it's entirely possible. what's "real"?
19:30:47 * adu doesn't even know php
19:30:54 <dmwit> Guest71909: Registered with NickServ.
19:30:55 * sw17ch thinks adu is lucky
19:31:04 <sw17ch> PHP is one of those things you can't unsee
19:31:06 <newsham> if you're resorting to something, obviously its not a top notch first choice
19:31:15 <dmwit> Guest71909: Did you get a server message like "That nick belongs to somebody else." when you logged in as rog?
19:31:19 <newsham> so it follows that php is often the language of resort
19:31:23 <dcoutts> I had a job once where I used php, it's really terrible for functional programming, though I did try
19:31:30 <adu> sw17ch: all I know about php is what ppl tell me, and I usually only hear the bad parts
19:31:50 <paczesiowa> :t throwError
19:31:51 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
19:32:01 <paczesiowa> @instances MonadError
19:32:02 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
19:32:07 <sw17ch> paczesiowa, am i right in understanding it's 4:30 AM for you?
19:32:08 <adu> sw17ch: like how it doesn't have the fundamental list type, only (Map Int a)
19:32:29 <Guest71909> dmit: i don't think so. but i haven't "registered" with any authority. is there some public key scheme behind the nickname thing then?
19:32:36 <dmwit> Guest71909: As there is a Rog logged in and identified to NickServ right now, that's almost certainly what happened.
19:32:43 <sw17ch> adu, i think the worst part is (0 == "" == "0" == null)
19:32:50 <adu> sw17ch: lolololol
19:32:59 <paczesiowa> sw17ch: yeah, but I'm pathetic no-life loser so I can sleep until 5-6 pm
19:33:06 <newsham> 0 + "" and "0"+1
19:33:10 <lispy> dcoutts: is php good at any particular type of programmer?
19:33:15 <lispy> dcoutts: er programming*
19:33:25 <dmwit> Guest71909: "/msg NickServ help" for more information, plus Google is your friend.
19:33:29 <sw17ch> lispy, is ubiquitous
19:33:33 <sw17ch> but no
19:33:34 <newsham> sw17ch: thats not all that uncommon, though.. php isnt alone
19:34:00 <dcoutts> lispy: it's not too bad at it's niche of quickly hacked together web pages that talk to db's.
19:34:07 <dmwit> javascript does something like that.
19:34:09 <paczesiowa> @info IOError
19:34:10 <lambdabot> IOError
19:34:17 <Guest71909> dmwit: thanks. (google "nicksrv" was surprisingly unhelpful)
19:34:23 * sw17ch likes JavaScript
19:34:33 <paczesiowa> sw17ch: I get it now
19:34:43 <dcoutts> lispy: but it quickly becomes annoying with the lack of abstraction and the model that maps each file to a single url/page
19:34:43 <dmwit> sw17ch: me too =)
19:34:45 <sw17ch> paczesiowa, do tell, i'm at a loss
19:34:45 <paczesiowa> withPtr was in IO
19:34:53 <dmwit> sw17ch: It's both popular and functional... neat!
19:35:06 <paczesiowa> throwError works in IO
19:35:09 <sw17ch> dmwit, it's best used in combination with Prototype or JQuery
19:35:11 <dcoutts> lispy: I've recently been writing a web app in Haskell and it's actually really pleasant.
19:35:22 <lispy> dcoutts: what framework do you use?
19:35:24 <lispy> janus?
19:35:28 <dcoutts> lispy: happs
19:35:29 <adu> JavaScript is getting better to, especially when  ES3 requires types
19:35:29 <dmwit> sw17ch: I just started playing with jquery this summer.  It's nice.
19:35:33 <sw17ch> paczesiowa, so how do i remedy it?
19:35:37 <paczesiowa> > print 1; throwError ""
19:35:38 <lambdabot>  Parse error at ";" (column 8)
19:35:44 <paczesiowa> > print 1 >> throwError ""
19:35:46 <lambdabot>  Couldn't match expected type `[Char]'
19:35:49 <sw17ch> $R(1,100).map(function(v){return v * 2;});
19:35:53 <sw17ch> i love Prototype
19:35:54 <paczesiowa> > print 1 >> throwError (strMsg "")
19:35:56 <lambdabot>  Add a type signature
19:36:16 <paczesiowa> > print 1 >> throwError (strMsg "") >> return 2
19:36:18 <lambdabot>  Exception: "<IO Integer>"
19:36:24 <sw17ch> ohh...
19:36:29 <sw17ch> so it typechecks/compiles
19:36:33 <sw17ch> but would not have done what i expected
19:36:37 <adu> > toDyn (5::Int)
19:36:39 <lambdabot>  <<Int>>
19:36:43 <paczesiowa> wait
19:36:48 <paczesiowa> :t print 1 >> throwError (strMsg "") >> return 2
19:36:49 <sw17ch> @src toDyn
19:36:50 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
19:36:50 <lambdabot> forall t. (Num t) => IO t
19:36:55 <ddarius> > fix toDyn
19:36:56 <paczesiowa> > print 1 >> throwError (strMsg "") >> return 2
19:36:57 <lambdabot>  <<Dynamic>>
19:36:59 <lambdabot>  Exception: "<IO Integer>"
19:37:05 <paczesiowa> wtf?
19:37:05 <dcoutts> lispy: the basic architecture seems such a good idea and seems to work out in practise so far. No dbs, just Haskell types, maps etc. Atomic state updates.
19:37:25 <dcoutts> lispy: I've not tried janus so I can't make a fair comparison.
19:37:27 <paczesiowa> where does that Exception come from?
19:37:36 <paczesiowa> lambdabot does my IO?
19:37:37 <sw17ch> throwError probably defaults to fail
19:37:41 <sw17ch> oh, good point
19:37:44 <sw17ch> ???
19:37:51 <sw17ch> > putStrLn "?"
19:37:53 <paczesiowa> > print 2
19:37:53 <lambdabot>  Exception: "<IO ()>"
19:37:55 <lambdabot>  Exception: "<IO ()>"
19:37:58 <sw17ch> !
19:38:00 <dmwit> ?undefine
19:38:01 <lambdabot> Undefined.
19:38:05 <dmwit> > print 2
19:38:06 <paczesiowa> > print 2
19:38:06 <lambdabot>  Exception: "<IO ()>"
19:38:08 <lambdabot>  Exception: "<IO ()>"
19:38:10 <dmwit> huh
19:38:13 <dmwit> I blame Cale.
19:38:19 * sw17ch thinks that there be scary foo at work
19:38:24 <adu> > show 2
19:38:26 <lambdabot>  "2"
19:38:29 <adu> :)
19:38:31 <dmwit> Oh, I bet he's switching to mueval or something like that!
19:38:41 <paczesiowa> :t print 1 >> throwError (strMsg "") >> return 2
19:38:43 <lambdabot> forall t. (Num t) => IO t
19:38:46 <paczesiowa> :t print 1 >> throwError ("") >> return 2
19:38:50 <dmwit> adu: It used to print <IO ()> with no exception, that's what's confusing us.
19:38:54 <sw17ch> paczesiowa, so any way, i'm having a hard time pulling my code apart to fix this
19:39:02 <paczesiowa> sw17ch: that's how it fixed that
19:39:03 <adu> dmwit: o
19:39:10 <sw17ch> dmwit, look up plotr
19:39:15 <lispy> ddarius: okay, I haven't used either, but there is this idea some of us have had that I wanted try out if I ever find time
19:39:18 <lispy> er
19:39:19 <sw17ch> it's a javascript library that's just fantastic
19:39:23 <lispy> ddarius: sorry that was for dcoutts
19:39:26 <sw17ch> paczesiowa, mmm...
19:39:28 <paczesiowa> String isn't IOError
19:39:30 <lispy> dcoutts: ^^
19:39:42 <dmwit> sw17ch: Also pretty looking, but a bit more specific than jquery, I guess.
19:39:46 <paczesiowa> you can't throwError it inside IO
19:39:49 <sw17ch> paczesiowa, but i'm still pretty sure it wasn't doing what i thought
19:39:52 <dcoutts> lispy: yeah? what idea is that?
19:39:56 <dmwit> There's not really that much demand for nice-looking charts, I think.
19:40:08 <paczesiowa> sw17ch: yes, you'd get runtime error
19:40:26 <lispy> dcoutts: I don't know if janus or happs is better.  Very likely not everyone in the group will want to learn Haskell though as I'm the only intermediate haskeller and out of 3 other people only one of them has used haskell at all
19:40:29 <sw17ch> dmwit, hehe, yeah, it's just really nifty. i'm using it for my current project at work and i'm trying to convince the customer/my boss to donate to the guy/project
19:40:32 <paczesiowa> you can fix it in two ways
19:40:48 <dmwit> sw17ch: Oh, I hope it's not hard to convince them.
19:40:58 <paczesiowa> problem is you have to be in IO to make it a callback
19:41:02 <dmwit> A good library is worth quite a lot of money to most companies.
19:41:05 <lispy> dcoutts: a web or phone based multiplayer game...turned based like kingdomofloathing
19:41:15 <lispy> dcoutts: the idea is that it's free to play, but if you pay you get perks
19:41:24 <dcoutts> lispy: oh, cool :-)
19:41:32 <sw17ch> dmwit, it's saved the customer a few weeks of my time @ $110 an hour
19:41:33 <paczesiowa> you can catch that runtime exception and wrap it in ErrorT
19:41:45 <ddarius> lispy: perks like what?
19:41:56 <lispy> extra turns or buffs
19:42:06 <lispy> just little things taht cost < $5 each
19:42:10 <adu> A good library is hard to come by
19:42:12 <sw17ch> paczesiowa, i'm thinking i'll try and return Left/Right inside, unwrap it, and throwError outside the allocaArray
19:42:13 <dmwit> sw17ch: Right.  Also... wow!  That's some dough.
19:42:18 <paczesiowa> or let that callbacky withPtr return Either Error a inside IO and patternmatch on that
19:42:33 <sw17ch> dmwit, i work for an embedded engineer. i'm a "specialist" apparently... it's really a great job though
19:42:46 <sw17ch> paczesiowa, i pick version 2
19:43:02 <adu> A good library means the parts you want to customize have parameters, and the parts you don't care about have defaults, which is nearly impossible to find
19:43:08 <paczesiowa> if you're lucky you can just wrap it with ErrorT constructor
19:43:16 <paczesiowa> if it's exported
19:43:19 <adu> most of the time I find the parts I want to customize are not parameterized
19:43:34 <adu> and the parts I don't care about require explicit arguments
19:43:47 <lispy> ddarius, dcoutts: the idea is just to make a little side money with a fun project
19:43:58 <dcoutts> lispy: right
19:44:05 <sw17ch> my job is to make the 8 bit microprocessors understand what the HTTP protocol is
19:44:05 <lispy> ddarius, dcoutts: and if it never gets profitable, oh well.  We still have day jobs :)
19:44:41 <dcoutts> lispy: so I was writing a new impl of the hackage-server, rather than the current apache+cgi+filesystem impl.
19:45:12 <dcoutts> the idea being that it'll be easier to extend with all the cool features that everyone wants on hackage
19:45:21 <dcoutts> and also easier to deploy
19:45:33 <lispy> nice
19:45:48 <mmorrow> @ty TOD 0 0
19:45:49 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:46:02 <lispy> dcoutts: my #1 concern with happs or janus or any long running haskell process is space leaks
19:46:06 <mmorrow> > TOD 0 0
19:46:08 <lambdabot>   Not in scope: data constructor `TOD'
19:46:17 <lispy> dcoutts: I've found laziness to be double edged
19:46:18 <adu> who is Ross Paterson?
19:46:44 <dcoutts> lispy: so you have fairly tight state management anyway because in happs at least it's all logged and single threaded
19:46:58 <dcoutts> lispy: so the only thing to watch for is eg updating maps and making sure the old elements go away
19:47:16 <paczesiowa> sw17ch: http://hpaste.org/9656#a1
19:47:33 <mmorrow> this is handy
19:47:35 <mmorrow> e2c :: EpochTime -> ClockTime
19:47:35 <mmorrow> e2c = flip TOD 0 . toInteger . fromEnum
19:47:55 <dcoutts> lispy: so it's only state updates that you have to audit for that kind of thing.
19:47:55 <mmorrow> System.Time(ClockTime(TOD))        System.Posix.Types(EpochTime)
19:48:17 <paczesiowa> sw17ch: does it work?
19:48:21 <lispy> dcoutts: ah, that's not so bad I guess
19:48:24 <sw17ch> paczesiowa, i just got it, pasting
19:49:09 <dcoutts> lispy: but eg, Data.Map.insertWith is a killer since it applies the combining function lazily.
19:49:36 <sw17ch> paczesiowa, wow, just noticed you pasted something too, i have my own, i'm comparing them
19:49:39 <sw17ch> http://hpaste.org/9656#a2
19:49:53 <paczesiowa> you can make it much shorter but you'd be using three different binds in 4 lines of code
19:51:28 <paczesiowa> that last piece of code is exactly code that ErrorT abstracts so you can just wrap it in ErrorT constructor
19:51:50 <paczesiowa> at least, I think so
19:51:59 * sw17ch tries...
19:52:23 * lispy is really stumped by this type error
19:52:43 <sw17ch> it's not quite it
19:52:54 <paczesiowa> which version?
19:53:15 <ddarius> lispy: The problem is obviously the types.  You should get rid of them.
19:53:33 <paczesiowa> how dare you:)
19:54:01 <lispy> Yeah, actually the problem is that...after I commute these patches around there doesn't seem to be any way to 1) do what the code does 2) satisfy david's assertion about what it should do
19:56:13 <paczesiowa> sw17ch: so?
19:56:14 <sw17ch> paczesiowa, were you saying to wrap the result of liftIO in ErrorT? or something else
19:56:42 <paczesiowa> sw17ch: does your version work?
19:57:05 <sw17ch> yes, mine works just great
19:57:14 <sw17ch> but i can't replace my case at the bottom with an ErrorT r
19:57:19 <paczesiowa> sw17ch: ErrorT cons already is lifting so you should put it instead of liftIO
19:57:34 <paczesiowa> sw17ch: does my hpasted version work?
19:58:09 <mmorrow> that reminds me of something that came in handy earler
19:58:12 * mmorrow gets it
19:59:01 <sw17ch> paczesiowa, yes, yours works too
19:59:08 <mmorrow> ioM :: (MonadIO m) => IO a -> m a
19:59:08 <mmorrow> ioM io = let m = unsafePerformIO io in m `seq` return m
19:59:35 <paczesiowa> mmorrow: you had to exit from irc to get some code?
19:59:53 <sw17ch> paczesiowa, actually, i like yours a lot better
20:00:08 <mmorrow> heh, i'm slight drunk and was hitting random button without abandon (all not on purpose)
20:00:16 <mmorrow> errr
20:01:01 <paczesiowa> sw17ch: it looks nicer but probably it's worse. if internal representation changes your code'll broke
20:01:24 <sw17ch> hmm...
20:01:32 <dmwit> :t liftIO
20:01:33 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:01:33 <paczesiowa> or if they unexport ErrorT constructor
20:01:46 <sw17ch> paczesiowa, that would make me sad
20:01:54 <mmorrow> s/without abandon/with abandon/  ;)
20:01:55 <sw17ch> but yeah, probably better to be explicit about it
20:01:55 <dmwit> Isn't liftIO the whole point of MonadIO?  Why do you need ioM?
20:02:17 <paczesiowa> sw17ch: but I love this kind of usage of ErrorT and MaybeT
20:02:27 <mmorrow> dmwit: for functions which take callback that are IO
20:02:32 <mmorrow> +s
20:02:39 <paczesiowa> it is pure and dirty at the same time!
20:02:57 <sw17ch> :)
20:03:02 <mmorrow> but it's the only option at the yet still the same time :)
20:03:16 <sw17ch> woop, i gotta go for tonight, thanks again paczesiowa
20:03:18 <sw17ch> paczesiowa++
20:03:23 * dmwit still doesn't get it
20:03:25 <paczesiowa> anyway there was some mailing list post
20:03:47 <paczesiowa> about threading 1 monad inside other exactly for callbacks
20:04:07 <mmorrow> yeah, quicksilvers thing
20:04:14 <mmorrow> it's nice
20:04:26 <paczesiowa> it was too complicated:)
20:04:31 <mmorrow> heh
20:05:12 <mmorrow> i haven't fully worked through the whole thing yet :)
20:05:13 <paczesiowa> sw17ch: anyway, that was some scary error:)
20:05:20 <mmorrow> just picked up tidbit here tidbit there
20:08:42 <mmorrow> dmwit: err, as i said i'm slightly non-sober, so i may have flipped that ... too much for right now ... but /the point/ (or something) of ioM, is that it is the same exact thing that unsafeInterleaveIO, except ioM returns into some MonadIO, whereas unsafeInterleaveIO (obviously) return into IO
20:09:38 <dmwit> mmm
20:09:45 <dmwit> :t unsafeInterleaveIO
20:09:49 <Armored_Azrael1> Is there any package that derives Enum (a, b) from Enum a and Enum b?
20:09:57 * mmorrow is pulling up the implem right now
20:10:05 <mmorrow> oh, so to all..
20:10:15 <dmwit> Armored_Azrael1: It's not possible in general.
20:10:19 <dmwit> Armored_Azrael1: You need Bounded a.
20:10:22 <hodgekin_> foo
20:10:23 <dmwit> err...
20:10:24 <dmwit> Bounded b
20:10:29 <dons> nice, twanvl http://www.reddit.com/comments/6weld/a_generic_merge_function/
20:10:47 <mmorrow> i'm going the (eventually) have every file in ghc + the libs it comes with HsColoured to html and here (i just the base lib as of now):     http://moonpatio.com/code/haskell/libraries/base-html/
20:10:52 <twanvl> thanks
20:10:52 <lambdabot> Title: Index of /code/haskell/libraries/base-html
20:11:27 <Armored_Azrael1> dmwit: Couldn't one just have the caveat that if one uses an unbounded member of the ordered pair, then infinite enumerations would all have the same value for one or the other, as an infinite enumeration would never actually "get there" ?
20:11:48 <dmwit> Armored_Azrael1: ewww
20:12:11 <dons> so who's going to be the first person to glue Language.C to Harpy's Language.X86 ?
20:12:12 <dmwit> Armored_Azrael1: Actually, you can probably even do a reasonable job with unbounded a, b, using some kind of diagonalization.
20:12:29 <dons> your challenge: write the function :: C_AST -> [Asm]
20:12:46 <Armored_Azrael1> dmwit: Yeah, I was kind of thinking that, but then I realized that the diagonalization just requires Ord and nothing else, which makes me think there's a good reason not to do it..
20:13:13 <Armored_Azrael1> dons: Without using unsafePerformIO and System.Cmd ?
20:13:15 <dmwit> :t unsafeInterleaveIO -- never did get the answer to this one, where's my bot?
20:13:34 <mmorrow> dmwit: hmm, i know it was implemented as exactly that *somewhere*, but apparently not in current ghc-HEAD (it's probably equiv or close to it) ... but i know i saw unsafeInterleaveIO implemented like that /somewhere/
20:13:37 <lispy> dons: I'll be excited when GHC compiles the C compiler that compiles it :)
20:13:48 <mmorrow> dmwit: the source : http://moonpatio.com/code/haskell/libraries/base-html/GHC/IOBase.lhs.html
20:13:49 <lispy> dons: well, it's C bits anyway
20:13:50 <dons> Armored_Azrael1: they're just two libraries
20:13:50 <lambdabot> Title: Haskell code, http://tinyurl.com/65p26a
20:13:54 <dons> one parsers C, and gives you an AST
20:14:05 <dons> the other takes assembly instructions, and compiles them to machine code
20:14:14 <dons> so you fill in the gap
20:14:17 <Armored_Azrael1> dons: I know, my joke was that one would just output the AST as C code, compile them with gcc, and parse them back in.
20:14:20 <dons> and we've a C compiler :)
20:14:29 <dons> heh
20:14:29 <dmwit> :t liftM . unsafeInterleaveIO
20:14:37 <dmwit> err...
20:14:41 <dmwit> :t liftIO . unsafeInterleaveIO
20:14:44 <dmwit> bah
20:14:47 <dmwit> ?type x
20:14:48 <mmorrow> hehe
20:14:48 <lambdabot> Expr
20:14:49 <lispy> dons: well, you still need a linker
20:14:55 <mmorrow> unsafeInterleaveIO :: IO a -> IO a
20:14:59 <dmwit> ?type liftIO . unsafeInterleaveIO
20:15:00 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:15:01 <Armored_Azrael1> lispy: Linkers are substantially easier than compilers.
20:25:46 <mmorrow> ?type (liftIO . unsafeInterleaveIO) :: (MonadIO m) => IO a -> m a
20:25:47 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:25:59 <mmorrow> ?type (liftIO . unsafeInterleaveIO) :: IO a -> IO a
20:26:00 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:29:02 <mmorrow> ooh, here's the new Control.Exception  http://moonpatio.com/code/haskell/libraries/base-html/Control/Exception.hs.html
20:29:04 <lambdabot> Title: Haskell code, http://tinyurl.com/5bx4q8
20:29:22 <mmorrow> (compare to http://moonpatio.com/code/haskell/libraries/base-html/Control/OldException.hs.html)
20:29:24 <lambdabot> Title: Haskell code, http://tinyurl.com/62ahwj
21:01:29 <dons> anyone played with Language.C yet?
21:02:07 <Trinithis> what is it?
21:02:16 <shapr> darcs get http://code.haskell.org/language-c
21:02:27 <lambdabot> Title: Index of /language-c
21:02:29 <mmorrow> dons: not yet. i've got quasiquoter construction/auto-generation down to almost a science though ...
21:03:27 <dons> mm...
21:03:36 <mmorrow> 10 minutes tops. uses igloo's th-lift library heavily
21:03:38 <dons> yes, i'd think there's a lot of scope for nice edsl syntax on top of this.
21:04:03 <ddarius> Inline C.  Just what we need...
21:04:10 <mmorrow> heh
21:04:43 <dons> a cute syntax for harpy
21:04:46 <mmorrow> also, i finally setup a blog. will be updating it often. http://moonpatio.com/blog/
21:04:48 <lambdabot> Title: moonpatio
21:05:04 <dons> a code only blog?
21:05:08 <mmorrow> dons: oh yeh, harpy is the perfect candidate.
21:05:20 <mmorrow> heh
21:05:49 <mmorrow> i plan to write about practical TH
21:38:00 <dmwit> Can GHC fuse list operations?  It would cool to be able to say so here:
21:38:25 <dmwit> http://www.reddit.com/comments/6wdvz/functional_code_good_code/c051stk?context=2
21:38:26 <lambdabot> Title: username223 comments on Functional code != Good code, http://tinyurl.com/59cyk7
21:39:14 <shepheb> dmwit: dons has posted some examples where GHC's fused assembly is all but identical to that generated by gcc.
21:39:42 <dmwit> I thought so, but now I'm wondering whether that was in any of the stable GHC's.
21:39:59 <dmwit> (After looking at http://hackage.haskell.org/trac/ghc/ticket/915 which seems not so certain about it being implemented.)
21:40:04 <lambdabot> Title: #915 (Implement list fusion using streams instead of foldr/build) - GHC - Trac
21:40:30 <dmwit> I guess it's a library, though.
21:45:27 <sw17ch> dons: this is 40 minutes ago, but i've played with Language.C a bit
22:54:12 <Pegazus> Hi!
22:54:14 <Lamperi> Saatko palkkaa?
23:03:52 <b\6> http://hpaste.org/9660  please take a look and unscrewup
23:05:05 <dibblego> are you aware that Might is equivalent to Maybe?
23:05:29 <dibblego> io = return
23:05:42 <dibblego> f0 = f1?
23:06:33 <dibblego> why put f0, f1 and f2 in IO to begin with?
23:06:51 <b\6> they just are. they do stuff with sdl.
23:07:35 <dibblego> I think you might want foldM
23:07:45 <b\6> yeah, tried a lot.
23:07:58 <dibblego> though really this looks like an error applicative or something
23:09:09 <funktio> isn't f the same as liftM2?
23:09:32 <dibblego> just about
23:09:46 <funktio> liftM2 (&&*), that is
23:09:50 <dibblego> liftMs (&&*)
23:09:53 <dibblego> liftM2 (&&*)
23:10:14 <funktio> and (&&*) looks a bit like mplus
23:10:36 <b\6> well, mplus doesn't short circuit on the 'zero' thing.
23:10:47 <b\6> i need more like Bool && behavior.
23:10:53 <b\6> i'll study liftM2. thanks.
23:17:02 <quicksilver> > Nothing `mplus` Just 4
23:17:04 <lambdabot>  Just 4
23:17:19 <quicksilver> > Nothing >> Just 4
23:17:21 <lambdabot>  Nothing
23:17:36 <quicksilver> b\6: (>>) for Maybe (similarly for Either String) shortcircuits on the zero.
23:17:55 <quicksilver> b\6: so your &&* is like the monadic sequence for Maybe
23:17:59 <quicksilver> (or Either String)
23:18:26 <Pegazus> hey! anyone here is in the mood to explain me a little about monads?
23:19:52 <quicksilver> b\6: and your "go" is just sequence [f0,f1,f2]
23:19:58 <quicksilver> in the ErrorT IO monad.
23:20:18 <quicksilver> b\6: I'm not sure if it's helpful or not to realise that what you are doing already has another name ;)
23:22:09 <b\6> quicksilver: hmm, ok. yeah, that's helpful.
23:22:44 <b\6> i see now why Nothing >> Just x short circuits like i want.
23:23:37 <b\6> i mean, yeah, i don't want to do it like this. still having problems working with monads. thanks.
23:26:25 <twanvl> Pegazus: what do you want to know? And have you read one of the many monad tutorials out there?
23:32:49 <|Steve|> > Nothing >> Just 5
23:32:51 <lambdabot>  Nothing
