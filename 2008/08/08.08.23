00:00:47 <zandax_> thank you, it works know :)
00:00:56 <telofy> p >> q  = p >>= \ _ -> q
00:01:13 <mauke> _ is always lazy
00:01:39 <zandax_> slowling I'm reaching the big problems. for example how to display an object somewhere on the screen and let it move through key presses :/
00:01:55 <telofy> but i thought the purpose of >> was to evaluate p, but ignore its result?
00:02:03 <mauke> zandax_: heh, maybe you should try simpler exercises first :-)
00:02:20 <mauke> telofy: yes
00:02:57 <mauke> > (\_ -> 42) (error "zomg")
00:02:59 <lambdabot>  42
00:03:15 <zandax_> no way mauke. I spend a whole day now for displaying a tilemap. ;(
00:03:22 <mauke> > runIdentity (return (error "zomg") >> return ())
00:03:25 <lambdabot>  ()
00:03:31 <mauke> > runIdentity (return (error "zomg") >>= \_ -> return ())
00:03:34 <lambdabot>  ()
00:04:17 <explicitjelly> zandax_, you should read "The Haskell School of Expression"
00:04:24 <explicitjelly> zandax_, it leads to what you want to do
00:04:33 <telofy> But how comes that >> actually works?
00:04:55 <telofy> is it partially evaluated?
00:04:58 <chrisdone> p >> q  = p >>= \ _ -> q ...
00:05:07 <explicitjelly> telofy, those two lines are essentially equivalent
00:05:08 <zandax_> I plan to buy it. Unfortunately I have no money atm ;)
00:05:32 <zandax_> But thats definitly better than spamming this channel with syntax questions
00:07:25 <chrisdone> has anyone yet invented a clever way to find a music track's name from the one bit of sound one remembers?
00:07:53 <solrize> sonic fingerprint ;)
00:08:06 <solrize> name-that-tune
00:08:22 <explicitjelly> zandax_, that's not what I meant. I just doubt the channel will be able to explain everything like the book does. it's a question of the medium
00:08:40 <solrize> http://www.onlisareinsradar.com/archives/000086.php
00:08:41 <lambdabot> Title: On Lisa Rein's Radar: New Software Can Name That Tune (in three notes)
00:09:35 <zandax_> yes, I know what you are talking about explicitjelly :)
00:11:08 <chrisdone> solrize: nice, sonic fingerprinting. I heard about this from the tv program “numb3rs” (even though I try not to watch that program because I'm pretty sure they ignore half of what the math consultants say, so half of it is bollocks)
00:12:36 <telofy> I just did ircOp x >> return((), "Done."), where ircOp does something to op x in an irc channel. And it worked! I don't get this... how is that possible?
00:12:38 <solrize> sonic fingerprinting actually refers to something different, it means recognizing waveforms to identify a specific recording
00:12:45 <nanothief> chrisdone: theres also this one: http://www.bored.com/songtapper/s/tappingmain.bin?dotap=1
00:12:45 <lambdabot> Title: Bored.com - Find music by tapping the rhythm of the song's melody.
00:14:20 <Cale> telofy: why shouldn't it work?
00:14:39 <chrisdone> nanothief: ah, that's a clever idea. get the users to do it for you
00:15:22 <telofy> because it's defined as p >> q = p >>= \_ -> q
00:15:31 <Cale> telofy: carrying out that action will carry out the action  ircOp x  ignoring any result it had, and then carry out the action  return ((), "Done")  which does nothing, but returns the result ((), "Done")
00:15:48 <nanothief> chrisdone: nothing better than group knowledge
00:15:49 <explicitjelly> telofy, aah, but how is (>>=) defined!
00:16:34 <Cale> The result of the whole action will then be ((), "Done")
00:16:52 <chrisdone> nanothief: I have about 7 seconds of a great piano solo in my head and it's killing me what the track is
00:17:02 <Cale> telofy: does that explanation make sense?
00:18:51 <telofy> don't know, I thought laziness meant, that the compiler knows that a _ is coming up, and the result is not needed, so the expression is never evaluated at all...
00:19:09 <explicitjelly> telofy, yes, but, as I said, look at what the definition of >>= is for your particular monad
00:19:10 <Cale> Evaluation and execution are two different things.
00:19:39 <Cale> explicitjelly: The monad in question is probably IO...
00:19:54 <explicitjelly> okay. well. then it's not that easy.
00:20:35 <Cale> telofy: When you *evaluate* something like  ircOp x  you get an action, but that action doesn't happen. It just describes something which could happen.
00:20:36 <explicitjelly> then look at the definition of other monads... and try to work out why it still gets evaluated
00:20:38 <telofy> so whatever matches this _ in my patterns is executed, but not evaluated? I wasn't aware of the difference
00:20:59 <Cale> telofy: ah, I should explain what >>= does more clearly perhaps
00:21:17 <Cale> If x is an action (that is, a value describing something to be done)
00:21:20 <telofy> yeah, I cant find a definition...
00:21:35 <explicitjelly> telofy, look, (>>=) isn't just "take the result and give it to the next function"
00:21:36 <Cale> and f is a function from possible results of x to further actions to be performed
00:21:52 <explicitjelly> telofy, if it would be just that, then, yes, >> wouldn't evaluate the first one
00:21:58 <Cale> Then, (x >>= f) is a new action, which, when it executes, will:
00:22:02 <explicitjelly> telofy, I believe the Identity monad works that way?
00:22:21 <Cale> 1) Execute x, capturing its result, say v
00:22:25 <solrize> chrisdone hum a few bars
00:22:26 <explicitjelly> telofy, but in other monads, >>= (and maybe even >>) is defined differently
00:22:40 <Cale> 2) apply f to v in order to determine what to do next (and do that)
00:23:20 <Cale> The result of the whole action is the result of that second one.
00:23:26 <Cale> Does that make sense?
00:23:29 <Cale> So for instance,
00:23:44 <Cale> getLine :: IO String  is an action which gets a line of text from the user
00:23:57 <telofy> sure i guess, but i have to read it a few times now^^
00:24:01 <explicitjelly> > putStrLn "test"
00:24:03 <lambdabot>  mueval: *** Exception: "<IO ()>"
00:24:08 <Cale> putStrLn :: String -> IO () is a function which, given a string, gives an action for printing that string on the screen.
00:24:19 <explicitjelly> hmm, how do I use IO in lambdabot?
00:24:24 <Cale> explicitjelly: you don't.
00:24:43 <explicitjelly> ok, reasonable.
00:24:44 <Cale> So,  getLine >>= putStrLn  is an action which gets a line of text from the user, and then prints it back out.
00:25:13 <Cale> telofy: does that help?
00:25:35 <explicitjelly> Cale, I don't think that's his question
00:25:37 <explicitjelly> or is it?
00:25:37 <Cale> telofy: There's another approach to explaining this perhaps... >> is a simpler operation than >>=
00:26:01 <telofy> thanks a lot, I have the feeling, that I'll be able to understand that concept by rereading what you told me a few times. :-)
00:26:30 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- I wrote this short tutorial which perhaps is a little more coherent
00:26:31 <lambdabot> Title: Introduction to IO - HaskellWiki
00:26:46 <explicitjelly> telofy, in any case:
00:27:01 <explicitjelly> > runIdentity (error "foo" >> return "bar")
00:27:04 <lambdabot>  "bar"
00:27:17 <explicitjelly> telofy, this behaves like you expected it. error "foo" never gets evaluated
00:27:19 <Cale> explicitjelly: well, things are trivial in the identity monad :)
00:27:55 <explicitjelly> telofy, because >>= is defined such that .. >>= (\_ -> ...) will only pass the result to _ which won't evaluate
00:28:29 <explicitjelly> telofy, but in another monad, for example IO, >>= does more than that
00:28:56 <dobblego> "because >>= is defined such that" ... "because >> is defined such that"
00:29:20 <explicitjelly> dobblego, no, I meant >>=
00:29:37 <dobblego> oh
00:30:07 <telofy> oh
00:30:12 <Cale> As another example where the order of evaluation is very different from the order of execution, the list monad is a good one, or the backwards-in-time state monad. But the main thing is that one understands that evaluating what an action is, and carrying that action out, are generally two different things.
00:30:55 <mauke> any C programmer should understand the difference :-)
00:31:19 <Cale> Or even evaluating (or not evaluating) what the *result* of an action is, is quite different from carrying the action out.
00:31:40 <mauke> evaluating x++ yields x, but the side effect (action) is to increment x
00:31:41 <explicitjelly> Cale, seems to me like that wasn't the problem. he talked about why "it" still got evaluated although the result is matched by _
00:32:05 <Cale> explicitjelly: The problem is the word "evaluated".
00:32:20 <Cale> (I think)
00:32:23 <explicitjelly> the discussion started with why "_" sometimes behaves strict and sometimes lazily (which it doesn't)
00:32:28 <explicitjelly> (it's always lazy)
00:33:15 <telofy> well, I think i understand now, that there are several more layers of magick, independent from the evaluation itself...
00:33:24 <Cale> Well, if by that you mean that it never forces the evaluation of anything while trying to match it, then yeah.
00:33:40 <explicitjelly> yes
00:33:42 <Cale> But I think the main confusion was not really about lambda at all.
00:34:16 <Cale> Actions *describe* effects, and their evaluation has nothing to do with what is carried out when they run.
00:34:23 <explicitjelly> and so the question was "but then, how does ircOp x >> return () work, if x >> y is defined as x >>= \_ -> ?"
00:34:43 <Cale> explicitjelly: I was here :)
00:35:39 <Cale> telofy: You can imagine if you want that an IO action is internally the source code for a C program which would run to carry out some effects before resulting in some value.
00:35:54 <|nanothief|> I like to think of State Monads as not performing anything, but as creating a function of type SomeState -> SomeState, which is then used in a starter function
00:35:56 <Cale> telofy: >> and >>= are ways to join together programs
00:36:09 <Cale> telofy: (their source code)
00:36:35 <solrize> cale i've never understood what prevents io actions from being run twice
00:36:42 <Cale> solrize: run twice?
00:36:46 <Myoma> IO as GADT!
00:36:52 <solrize> yeah, referential transparency
00:36:57 <Cale> solrize: nothing... you can run them twice
00:37:05 <Cale> getLine is an IO action
00:37:05 <Myoma> solrize: imagine, [1..]
00:37:09 <telofy> yes, I'm using these two, I only never understood why they worked, or actually, why >> worked
00:37:13 <Myoma> You will never ever 3 twice in there
00:37:17 <Cale> getLine >> getLine
00:37:20 <Cale> will run it twice
00:37:33 <mauke> telofy: implement them yourself, e.g. for State or Identity
00:37:40 <dobblego> replicateM n getLine
00:37:49 <telofy> but, ok, if i imagine that there is a C program executing stuff no matter what
00:37:49 <Cale> solrize: IO actions aren't carried out when they're *evaluated*
00:38:05 <explicitjelly> telofy, and *why* don't you understand why >> works?
00:38:18 <Cale> In fact, you can think of the evaluation of an IO action as a no-op, if you want.
00:38:20 <explicitjelly> telofy, because of the _ in its definition?
00:38:20 <solrize> i thought IO was basically State on the real world
00:38:30 <Cale> solrize: that's not a pretty view
00:38:30 <Myoma> solrize: everything is data, IO actions are just data to someone
00:38:57 <Myoma> solrize: You know you don't have 3 twice in [1..] for the same reasons you don't have IO actions run multiple times for no good reason
00:39:16 <solrize> hmm
00:39:25 <Cale> lambdabot: @join #darcs-theory
00:39:34 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html
00:39:36 <lambdabot> Title: Haskell: How To IO
00:39:42 <mauke> I really should finish that some day
00:40:51 <explicitjelly> telofy, if that's the problem (I think it is), then the answer is: you probably think that the entire "ircOp x" expression gets machted by the "_" and thus thrown away. which would be the case for the Identity monad, but not for other monads!
00:41:18 <explicitjelly> telofy, the expression "ircOp x" is more complicated than that, and only a part of it gets matched by "_" (and thus thrown away and indeed never evaluated)
00:41:33 <telofy> ok
00:41:50 <telofy> That was exactly my problem, yes
00:42:04 <explicitjelly> ok...
00:42:25 <sclv> the general notion would be that monads which "short circuit" (i.e. have some notion of error) necessarily have a stricter >>= ?
00:42:44 <explicitjelly> sorry for my bickering earlier, but I had the impression that all that general talk about evaluation and execution was confusing and not really an answer to this particular problem
00:42:52 <Cale> (It is)
00:43:19 <explicitjelly> telofy, error is always nice for trying out if something gets evaluated
00:43:40 <telofy> I'm trying to understand what exactly monads are. Heard they are like monsters and space suits... ^^
00:43:56 <Cale> telofy: http://www.haskell.org/haskellwiki/Monads_as_computation
00:43:57 <lambdabot> Title: Monads as computation - HaskellWiki
00:43:57 <explicitjelly> telofy, with Identity, error "foo" >> "bar" evaluates to "bar", while in IO error "foo" >> "bar" throws an error "foo"
00:44:01 <telofy> yes, I was already using them. :-)
00:44:15 <Cale> telofy: They're just a way to structure libraries, so that we get a bunch of common functions for free.
00:44:58 <sclv> ?src Identity (>>=)
00:44:58 <lambdabot> m >>= k  = k (runIdentity m)
00:45:22 <Cale> telofy: There are a lot of very bad monad tutorials, so watch out :)
00:45:42 <Myoma> You are likely to be eaten by a bad monad tutorial
00:45:47 <mauke> telofy: monads are nothing
00:45:51 <telofy> cale, hopefully I'll be able to spot them
00:46:00 <mauke> learn to use a particular monad or two, like IO and Reader
00:46:07 <sclv> ?src Error (>>=)
00:46:07 <lambdabot> Source not found. You type like i drive.
00:46:12 <telofy> mauke, nothing as in nirvana?
00:46:18 <explicitjelly> ?src State (>>=)
00:46:18 <lambdabot> Source not found. That's something I cannot allow to happen.
00:46:26 <explicitjelly> ?src Control.Monad.State (>>=)
00:46:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:46:30 <explicitjelly> ?src StateT (>>=)
00:46:31 <lambdabot> Source not found. You untyped fool!
00:46:33 <sclv> ?src ErrorT (>>=)
00:46:33 <lambdabot> m >>= k  = ErrorT $ do
00:46:34 <explicitjelly> hmpf
00:46:34 <lambdabot>     a <- runErrorT m
00:46:34 <lambdabot>     case a of Left  l -> return (Left l)
00:46:36 <lambdabot>               Right r -> runErrorT (k r)
00:46:45 <mauke> telofy: nothing as in there is not much to understand here, which is what makes it so hard
00:46:54 <Cale> telofy: But you don't really need to understand monads in general in order to understand what >>= and return and a few of the other functions do in specific cases.
00:47:18 <Cale> (which is what you really need to know when starting out)
00:47:19 <telofy> mauke, I got some nice links in my browser now, gonna be able to read about it for hours :-)
00:47:19 <sclv> There we go -- errorT's >>= will always need to look at some of its argument (to determine if it is Left or Right), while Identity's will not.
00:48:11 <explicitjelly> yes!
00:48:12 <Cale> Understanding monads properly is more important when designing (certain types of) libraries than just using them.
00:48:51 <telofy> Cale, I fear, that I'm the kind of person who has the feeling that he does not get something at all as long as there are any inconsistencies in his understanding
00:48:57 <name_> so is the FTGL binding just completely hosed or what
00:49:06 <explicitjelly> telofy, nah, you'll manage
00:49:28 <explicitjelly> telofy, your question was actually a good one
00:49:37 <telofy> thx :-)
00:49:59 <explicitjelly> telofy, you just had a hidden assumption that turned out wrong
00:50:15 <telofy> and thanks a lot for the explanations everyone
00:50:29 <Cale> telofy: Well, monads are an abstraction, and like any good abstraction, you can understand the specific cases perfectly well without the general one. Of course, the general one makes everything fit together nicely, and so it's desirable... but if you're just trying to write a program that does some IO, there's no need to understand the generality of monads right away :)
00:50:49 <explicitjelly> 09:00 < telofy> p >> q  = p >>= \ _ -> q
00:51:06 <explicitjelly> mainly that >>= would just pass the value around
00:51:12 <Dynetrekk> http://hpaste.org/9859 : why does this code fail to read a text file?
00:51:36 <Cale> Dynetrekk: str is a String, yes
00:51:42 <explicitjelly> Cale, are continuations hard to understand? because I didn't get them yet %)
00:51:57 <Cale> explicitjelly: well... they're a little strange, but not too bad
00:52:08 <explicitjelly> Cale, what are they actually?
00:52:12 <Dynetrekk> Cale: but,then, why doesn't it print? (No instance for (Show (IO String))
00:52:12 <Dynetrekk>       arising from a use of `print' at P99.hs:6:7-11
00:52:12 <Dynetrekk> )
00:52:38 <Cale> Dynetrekk: what did you type?
00:52:49 <dobblego> Dynetrekk, not print x but instead x >>= print
00:52:57 <explicitjelly> Dynetrekk, looks like the problem is in the code that calls getInput
00:53:01 <Dynetrekk> Cale: print $ getInput "filename.txt"
00:53:10 <Cale> Dynetrekk: right, that would be the problem
00:53:20 <Cale> Dynetrekk: getInput "filename.txt"  is an action
00:53:22 <Dynetrekk> Cale: right. well, why can't I print a string?
00:53:26 <explicitjelly> Dynetrekk, that doesn't work! you'd have to do str <- getInput "filename.txt" ; print str
00:53:31 <Cale> actions don't have a default Show instance
00:53:36 <explicitjelly> Dynetrekk, because it's not a string, it's an IO String %)
00:53:38 <Cale> (mainly because you can't inspect them)
00:53:56 <Cale> (you're asking to print the action, not the result of the action)
00:54:03 <explicitjelly> Dynetrekk, it's true that str in getInput is String, but the return value of getInput is IO String
00:54:03 <Dynetrekk> Cale: but how do you then, say, write a function which will return the contents of a file?
00:54:19 <dobblego> Dynetrekk, exactly like explicitjelly told you
00:54:31 <explicitjelly> Dynetrekk, you can't, if you want it to be pure
00:54:37 <Cale> Dynetrekk: What you want to write is  do v <- getInput "filename.txt"; print v
00:54:40 <explicitjelly> Dynetrekk, (well, there's unsafePerformIO, but let's not get into that)
00:54:47 <Cale> though, this will be quoted like crazy :)
00:54:53 <explicitjelly> Dynetrekk, every function that uses getInput needs to be in the IO monad itself!
00:55:23 <Cale> What you probably want is really just  do v <- readFile "filename.txt"; putStrLn v
00:55:53 <Cale> Note that:  do v <- readFile "filename.txt"; return v  is the same as  readFile "filename.txt"
00:56:08 <Cale> ...
00:56:10 <Dynetrekk> explicitjelly: thanks. but does this mean that I can't "contain" the readFile thingy inside something which is a "real function", and not an "action", whatever that means?
00:56:19 <explicitjelly> Dynetrekk, yes!
00:56:28 <explicitjelly> Dynetrekk, otherwise, the function wouldn't be pure again
00:56:32 <Cale> Can I explain?
00:56:35 <mauke> Dynetrekk: a function is something that maps values to other values
00:56:48 <explicitjelly> Dynetrekk, if you want to do IO, you have to do so inside the IO monad, including calling functions that do IO
00:56:53 <mauke> you can't read a file in a function because that depends on the outside world
00:57:06 <Dynetrekk> explicitjelly: makes sense. but then, how do you avoid the whole program becoming an action, and going back to C style programming?
00:57:26 <mauke> heh
00:57:28 <Cale> Dynetrekk: IO actions can use pure functions in order to determine what to do
00:57:30 <explicitjelly> Dynetrekk, ask Cale! %)
00:57:33 <mauke> the whole program must be an action anyway
00:57:38 <mauke> main :: IO ()
00:57:43 <Dynetrekk> Cale: they told me to ask you
00:57:46 <Cale> Dynetrekk: hehe
00:57:47 <Dynetrekk> mauke: good poeint
00:58:09 <Cale> Dynetrekk: For example, you get some input, and then apply a pure function to it, and then output the result.
00:58:21 <Myoma> main :: IO foo
00:58:24 <Cale> Dynetrekk: that pure function can be something arbitrarily complicated
00:58:49 <Dynetrekk> Cale: I see. so it's pretty common fare to let the "main" function be a do statement?
00:59:02 <Cale> Dynetrekk: If you want to do more than one thing, yes.
00:59:08 <Cale> Dynetrekk: main *must* be an IO action
00:59:20 <explicitjelly> Dynetrekk, but in the end you'll find, that there are actually only few places where you really want to do IO
00:59:21 <Cale> do-expressions are a way of combining IO actions together into larger ones.
00:59:50 <Cale> You want to do I/O when you're gathering input, or producing output, and basically nowhere else.
01:00:16 <Cale> It just so happens that programs can always be designed so that is separated in some sense from the real meat of what is happening.
01:00:23 <explicitjelly> Dynetrekk, even with complicated things that output a lot of stuff, eventually you'll use lists and other monads and whatever else that online ultimately, in the most outer layer, culminate in performing IO
01:00:26 <Dynetrekk> Cale: I see...
01:00:48 <Cale> Dynetrekk: Are you familiar with model-view-controller?
01:00:54 <Cale> (from OO programming)
01:00:58 <explicitjelly> "online"? I meant "culminate", why the hell did I write "online"?! %)
01:01:10 <Dynetrekk> Cale: yep, at least the idea. I did some GUI programming last year (Java)
01:01:28 <Dynetrekk> explicitjelly: internet addict :)
01:01:28 <Cale> Dynetrekk: okay, so you might imagine that your model will be (at least mostly) pure
01:01:34 <explicitjelly> heheh
01:01:38 <Cale> No IO-stuff at all.
01:01:57 <Cale> The view and controller also often contain pure bits, but they will also involve at least some IO
01:02:00 <Cale> (generally)
01:02:02 <Dynetrekk> Cale: well, no IO is fine I guess - but what about recording state? Say, you're controlling a measurement instrument (like I did)
01:02:04 <explicitjelly> Cale, do you have a good pointer on continuations?
01:02:28 <Cale> explicitjelly: I have a half-written tutorial of mine, I'm not sure how clear it is in its current state :)
01:02:35 <Myoma> aww
01:02:40 <explicitjelly> Cale, oh cool
01:03:10 <Cale> http://www.haskell.org/haskellwiki/Cont_computations_as_question-answering_boxes
01:03:12 <lambdabot> Title: Cont computations as question-answering boxes - HaskellWiki, http://tinyurl.com/56x6rq
01:03:13 <Myoma> Cale: I was wondering about replacing the (terrible) wikipedia article
01:03:21 <explicitjelly> thx
01:03:30 <Myoma> But I don't know how wikipedia works so I didn't do anything
01:03:43 <Cale> Dynetrekk: okay...
01:03:47 <Myoma> oh this is Cont _monad_
01:03:50 <quicksilver> you can certainly imagine making the controller pure, in my opinion.
01:03:54 <Myoma> I thought it was about CPS
01:04:03 <Cale> Myoma: that's what the Cont monad is
01:04:04 <quicksilver> given the right structure.
01:04:18 <Dynetrekk> Cale: I don't see that the MVC analog is very fruitful? at least I don't see the point.
01:04:33 <Cale> Dynetrekk: So you're getting input from the measuring device, and doing something with that, and then doing output to adjust what you're measuring?
01:05:31 <Cale> Dynetrekk: well, the MVC thing is just a rough guide anyway
01:05:40 <Dynetrekk> Cale: more or less. well, that's what I used to do. now, I'm just trying to learn haskell:)
01:05:56 <Cale> Dynetrekk: okay, so what is that something that you're doing in between?
01:06:19 <Cale> Dynetrekk: It seems to be a pure function from the input you've received from the device to output that must be done to control it?
01:06:44 <Cale> If you got the same inputs from the device, you'd want to produce the same outputs, right?
01:07:09 <Dynetrekk> Cale: hm, pretty much all I do is to show it on screen, save it internally in an object (save stuff so you can show different things without re-reading from the instrument), possibly logging to an sdds file (a text file format).
01:07:27 <Dynetrekk> Cale: none of this seems to be very pure to me, it all involves saving mutable state
01:07:36 <Cale> Dynetrekk: Well, if your program is mostly just I/O, then most of your program will be in the IO monad.
01:07:48 <Cale> Formatting of strings and such is pure though.
01:08:09 <Dynetrekk> Cale: indeed. so for that program, I think java is probably fine. formatting strings would be a very small part of the whole program.
01:08:17 <Cale> Usually you don't just write the equivalent of unix cat and tee though...
01:08:26 <solrize> mauke, your article is excellent
01:08:26 <Dynetrekk> Cale: tee?
01:08:38 <Cale> (tee copies input to output and to a file)
01:09:04 <Dynetrekk> Cale: cool, didn't know that one
01:09:05 <Cale> Most programs analyse or do something with their inputs.
01:09:18 <Cale> (other than simply outputting them somewhere else)
01:09:25 <Cale> and that's where functions and so on will come in
01:09:36 <Dynetrekk> Cale: you're right, but it's the human doing the decisions in this case.
01:09:39 <Cale> Actually Haskell is a rather nice language even if you just stick everything in the IO monad though.
01:10:03 <Cale> This is because you can do some very nice things on account of IO actions being first class values.
01:10:24 <Dynetrekk> Cale: I'm just beginning my PhD in physics, so I'd like to do pure computations in haskell. for GUI stuff, which I won't be doing much (if at all) anyway, haskell seems complicated - at least for now
01:10:47 <Cale> Mm... well, it's not any worse than any imperative language really.
01:10:56 <Cale> and in some cases is a good bit better
01:11:00 <Dynetrekk> Cale: I guess I need to learn a lot more haskell :) I'm thinking about taking some AI course, but I think they use LISP there
01:11:14 <|Steve|> Unlikely.
01:11:23 <Cale> Let me give an example of how Haskell's take on I/O is nice...
01:11:28 <Cale> There's no built in for-each loop in Haskell.
01:11:31 <Dynetrekk> Cale: please do
01:12:03 <dons> IO is truly first class, e.g. you can put IO actions in data structures, or run them backwards.
01:12:10 <Cale> But what is a for-each loop really? It takes a list of elements, and a function from those elements to an action to be performed, and performs the resulting actions in turn.
01:12:24 <explicitjelly> Cale, thanks for the article. it cuts off when things get interesting, though %)
01:12:29 <Myoma> for loops don't take a list of elements
01:12:31 <Cale> explicitjelly: right
01:12:35 <glguy> Didn't lisp==ai die decades ago/
01:12:36 <glguy> ?
01:12:36 <Cale> Myoma: for-each
01:12:42 <Dynetrekk> Cale: agree. the for-each loop can be replaced by map, or similar.
01:12:50 <Cale> Dynetrekk: well, not *just* a map
01:12:57 <dons> glguy: i've only seen the ai stuff done in, e.g. C and C++ sadly
01:13:03 <Cale> Dynetrekk: If we map that function over our list, we'll get a list of actions
01:13:06 <Dynetrekk> glguy: die? they teach it at my university. I think AI is very much alive.
01:13:11 <dons> big data sets, raw speed.
01:13:15 <Myoma> dons: Backwards...  ?
01:13:18 <Cale> Dynetrekk: then all that's left is to glue those actions together end-to-end
01:13:34 <Myoma> do you mean something other than  sequence . reverse?
01:13:38 <Dynetrekk> Cale: hm, I guess
01:13:51 <glguy> Dynetrekk: no, I mean that the association between AI and Lisp was just because one research group happened to use it ages ago
01:13:58 <Cale> Dynetrekk: Such a function would have type  [IO a] -> IO [a]
01:13:58 <glguy> Dynetrekk: not because it is the language of AI
01:14:08 <Cale> Dynetrekk: (assuming we want all the results collected in a list)
01:14:15 <dons> glguy: well, the big AI research projects of the early 80s were lispish.
01:14:23 <Cale> Dynetrekk: I'll write it :)
01:14:24 <dons> but i don't think that's the case these days.
01:14:27 <Dynetrekk> glguy: could be. but, they have to use some language, and usually one prefers a functional one (I gather). hence, LISP is well suited.
01:14:29 <glguy> dons: right, that's my point
01:14:41 <Dynetrekk> Cale: thanks!
01:14:46 <glguy> Dynetrekk: Lisp code is typically not written in a functional style
01:14:46 <Cale> sequence [] = return [] -- if the list of actions is empty, give the action which does nothing and produces the empty list
01:14:50 <dons> the performance demands essentially forced them into lower level languages.
01:15:06 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:15:51 <Cale> If the list of actions is nonempty, return the action which will perform the first action in the list, and then perform the rest, and return the consed together list of results.
01:15:51 <explicitjelly> irc *really* needs a way to reliably send multiline messages
01:15:54 <explicitjelly> f
01:15:59 <explicitjelly> d
01:16:09 <explicitjelly> hmm, no, doesn't seem to be a way ;)
01:16:30 <dons> hmm, did muaddibber quite get when and why tail calls appear? http://muaddibspace.blogspot.com/2008/08/tail-call-optimization-doesnt-exist-in.html
01:16:34 <scook0> you can get fairly close by doing a multiline paste, but it's not truly reliable
01:16:35 <lambdabot> Title: Muad`Dib: Tail Call Optimization doesn't exist in Haskell, http://tinyurl.com/5e4z23
01:16:38 <Cale> Dynetrekk: Does that make some sense?
01:16:40 <dons> Cale, where you talking to him today about it?
01:16:59 <Cale> dons: I was talking a bit about tail calls and the stack and heap
01:17:41 <Dynetrekk> Cale: yup, 73%. (x:xs) are now actions, which you perform, and then you return the results as (v:vs) ?
01:17:47 <Cale> Dynetrekk: yeah
01:17:55 <explicitjelly> scook0, yeah... and it'd be nice if you could type your multiline message directly into the client. of course, the client could buffer that, but as you say, still not very reliable... also, I'd like to see that the nick and everything doesn't get repeated in multiline messages
01:18:07 <Dynetrekk> Cale: more like 96% sense, then.
01:18:16 <Cale> Dynetrekk: and once we have that, we can write  forM xs f = sequence (map f xs)
01:18:24 <Cale> and there's our for-each loop :)
01:18:46 <Cale> Of course, you can construct ever more elaborate control structures for yourself, depending on what you need.
01:19:05 <explicitjelly> like for-maybe-each-and-every-other-but-only-backwards loop!
01:19:32 <Cale> Or perhaps more practically, something which carries out a decision tree of actions.
01:20:05 <Dynetrekk> Cale: so now xs is the list of actions (IO stuff), f the function to perform on them (?), and forM is the "API function" to use.... or something
01:20:16 <explicitjelly> agreed, that seems more reasonable ;)
01:20:23 <Cale> (Where the actions on each node of a tree return a result saying whether to go to the left child or right child, along with some extra data perhaps)
01:20:34 <Cale> Dynetrekk: yeah
01:20:47 <Cale> Dynetrekk: For example...  forM [1..10] print
01:20:49 <Dynetrekk> Cale: I don't see where f fits in though...
01:20:52 <Cale> will print the numbers 1 up to 10
01:21:02 <Dynetrekk> Cale: oh
01:21:19 <Dynetrekk> Cale: so xs is just something or other we want to do something to. makes sense now.
01:21:24 <Cale> yeah
01:21:43 <Dynetrekk> Cale: and print is an action (in the IO monad? or something)
01:22:03 <Cale> print is a function from values to actions for printing them on the screen
01:22:09 <Cale> :t print
01:22:10 <lambdabot> forall a. (Show a) => a -> IO ()
01:23:17 <Dynetrekk> Cale: so it maps "anything" to an action
01:23:28 <Cale> Yeah, anything showable anyway.
01:23:29 <Dynetrekk> Cale: which is then performed at some time
01:23:33 <Cale> yeah.
01:23:44 <Dynetrekk> nice.
01:23:55 <Cale> For instance,  print 1  is the action which if executed would print 1 on the screen :)
01:24:36 <Dynetrekk> Cale: and then main = print 1 gets the action produced by print, and executes it when main is called
01:24:45 <Dynetrekk> Cale: wow, a lot of things cleared up
01:24:50 <Cale> yeah, it defines main to be the same action
01:25:08 <Cale> and main is the action which is executed when the compiled program is run (generally)
01:25:32 <iamabarnacle> hi everyone
01:25:38 <Cale> hello iamabarnacle
01:25:50 <Cale> Learning Haskell?
01:25:55 <iamabarnacle> does anyone know where i can get help on compiling hackage-scripts?
01:26:05 <iamabarnacle> @cale yep :)
01:26:05 <lambdabot> Unknown command, try @list
01:26:10 <iamabarnacle> oops
01:26:22 <Cale> hackage-scripts?
01:26:25 <Dynetrekk> Cale: thanks a lot
01:26:37 <Cale> Dynetrekk: no problem, let me know if you have any questions :)
01:26:40 <iamabarnacle> yes, the source for hackagedb
01:26:57 <Cale> iamabarnacle: mm... well, I'm not familiar with it, but what problem are you running into?
01:27:17 <Cale> (I'm familiar with hackage itself, of course :)
01:27:36 <iamabarnacle> one of the modules imports a non-existent module
01:27:44 <Cale> which one?
01:28:01 <iamabarnacle> Distribution.PackageDescription.Parse
01:28:16 <iamabarnacle> i have the latest cabal package
01:28:25 <iamabarnacle> hot off hackage :)
01:28:36 <iamabarnacle> i also hoogled for the module and it isn't there
01:28:51 <Cale> hmm
01:28:57 <Cale> There is a Distribution.ParseUtils...
01:29:25 * Cale wonders where dcoutts_ is :)
01:29:37 <Cale> (he's probably the guy to talk to about this :)
01:29:52 <iamabarnacle> yeah, i guess...  it's his change :)
01:29:59 <iamabarnacle> i'll just drop him an email then
01:30:02 <iamabarnacle> thanks :D
01:30:28 <Cale> You might just try that module instead :)
01:31:10 <Cale> But you would think that hackage-scripts should build... it's also strange that it's not itself a package on hackage :)
01:32:11 <iamabarnacle> yeah...  i got it off of darcs
01:40:02 <solrize> RWH comment server is not responding
01:43:59 <|nanothief|> Is there a prebuilt package anywhere for ghc for cygwin? I've tried building it from source, without much luck
01:45:35 <trofi> @go haskell.org ghc download windows
01:45:37 <lambdabot> http://www.haskell.org/ghc/download_ghc_64.html
01:45:37 <lambdabot> Title: GHC: Download version 6.4
01:46:24 <trofi> http://www.haskell.org/ghc/download_ghc_683.html
01:46:25 <lambdabot> Title: GHC: Download version 6.8.3
01:46:41 <Dynetrekk> Cale: http://hpaste.org/9860 what should the type be here? Bool is of course wrong, it should be a bool-returning function.
01:47:32 <trofi> (a -> bool)
01:47:34 <nanothief> trofi: Those are windows builds however (unless I'm mistaken). I'm looking to use ghc under cygwin, so I can get access to the posix libraries, and other unix-only features
01:47:37 <explicitjelly> Dynetrekk, (a -> Bool)
01:47:39 <Cale> Dynetrekk: well, (a -> Bool) -> [a] -> [a]
01:47:46 <explicitjelly> Dynetrekk, though you could just ask haskell
01:47:48 <Dynetrekk> Cale: thanks
01:47:51 <Dynetrekk> explicitjelly: how?
01:47:59 <Myoma> remove this line:
01:47:59 <Myoma> dropUntil :: Bool -> [a] -> [a]
01:48:01 <Dynetrekk> explicitjelly: :t (<3) ?
01:48:03 <Myoma> load the file
01:48:04 <explicitjelly> Dynetrekk, remove the line with the type
01:48:12 <Cale> In ghci,  :t <expression>  will tell you the inferred type for the expression
01:48:17 <Dynetrekk> explicitjelly: ah, good point...
01:48:25 <explicitjelly> and then :t dropUntil
01:48:56 <Myoma> Dynetrekk: you don't have to write type signatures for almost everything in haskell, it can infer them
01:49:22 <Dynetrekk> Myoma: I do it to learn, and at some point, I guess it improves performance
01:49:30 <Myoma> no
01:49:33 <bd_> not usually
01:49:34 <explicitjelly> but a lot of people do it anyway, simply too know if they did something wrong
01:49:36 <solrize> wow, bulat bagged against lazy evaluation
01:49:39 <bd_> it improves the error messages :)
01:49:52 <explicitjelly> Dynetrekk, the interesting thing about languages like haskell is: if it compiles, it often works
01:49:53 <trofi> nanothief: they are built and bring with them mingw32-gcc/g++ and part of cygwin, AFAIR. so i don't think you won't have troubles with cygwin environment
01:49:53 <Dynetrekk> Myoma: no? only the compilation speed then?
01:50:08 <Dynetrekk> explicitjelly: my experience as well. funny  ting that
01:50:12 <explicitjelly> Dynetrekk, bugs are much more likely to cause the compiler to bail out than in other languages
01:50:30 <bd_> Dynetrekk: not really compile speed either. The main benefit is it tends to push errors closer to where you made the mistake - instead of wherever the compiler realized there was a contradiction
01:50:32 <Myoma> Dynotrekk: It doesn't effect speed, the only reason to put them down is when you are programming in the type system or the types help explain what a function does/is
01:50:40 <trofi> nanothief: *dont'n think you will have* :]
01:50:43 <bd_> Dynetrekk: also they make for good documentation
01:50:59 <explicitjelly> yes, documentation, good point
01:51:00 <Dynetrekk> so the documentation and error search of code is the whole point?
01:51:09 <explicitjelly> yes.
01:51:14 <Myoma> I think documentation is things like
01:51:39 <Myoma> -- This works via breadth first search on the first argument
01:51:44 <bd_> Dynetrekk: well, there are some specific features which require explicit type signatures
01:51:47 <Myoma> not :: a -> (b -> r a) -> r b
01:51:55 <Myoma> maybe that is just me
01:51:57 <bd_> existential types, sort of thing
01:51:58 <bd_> :t runST
01:51:59 <lambdabot> forall a. (forall s. ST s a) -> a
01:52:21 <Dynetrekk> bd_: like read "5" :: Int ?
01:52:26 <bd_> that kind of type needs a type signature (it's explicitly restricted to something less than would ever be inferred)
01:52:28 <Myoma> bd_: could these sort of things be classed as programming in the type system ?
01:52:28 <explicitjelly> bd_, hm, you're right
01:52:33 <bd_> Dynetrekk: nah, this is something of a more complex thing :)
01:52:52 <bd_> Myoma: The type system in haskell is not turing complete by default... but GHC has some switches which make it so. >.>;
01:53:07 <solrize> what's the M-R ?
01:53:12 <Myoma> I don't think turing complete has anything to do with programming
01:53:26 <bd_> I suppose. People do scary things with the type system sometimes
01:53:29 <explicitjelly> bd_, doesn't that mean that there's sourcecode where the compiler doesn't terminateß
01:53:32 <explicitjelly> ?
01:53:34 <nanothief> trofi: ahh ok, I just assumed that because it doesn't use the cygwin1.dll file it didn't take advantage of cygwin unix functionality
01:53:35 <solrize> oh.  monomorphism restriction
01:53:39 <sjanssen> solrize: probably the monomorphism restriction
01:53:40 <bd_> Myoma: http://okmij.org/ftp/Haskell/types.html#peano-arithm
01:53:41 <lambdabot> Title: Haskell Programming: Types
01:53:49 <bd_> explicitjelly: If you enable undecidable instances, yes.
01:53:56 <explicitjelly> bd_, funny
01:54:00 <solrize> turning it off slows programs down?!
01:54:08 <Myoma> solrize: No
01:54:13 <Myoma> solrize: none of _my_ programs anyway
01:54:18 <solrize> http://www.haskell.org/pipermail/haskell-prime/2006-February/000252.html
01:54:18 <bd_> solrize: not usually. people thought it would when they put in the MR. :)
01:54:19 <Myoma> solrize: It can slow things down though
01:54:19 <lambdabot> Title: Test performance impact (was: The dreaded M-R), http://tinyurl.com/5mym2q
01:54:32 <Myoma> solrize: It's predictable when itw ill though
02:00:55 <Dynetrekk> are there any "code conventions" for haskell, similar to java / python / others?
02:01:06 <Myoma> yes
02:01:24 <Dynetrekk> Myoma: is there a web resource "bible" for this?
02:01:39 <Myoma> the most common one I heard about is  annotate all toplevel functions with types  ..I don't do that
02:02:23 <int-e> (one rationale is that it makes finding type errors easier.)
02:03:26 <explicitjelly> bd_, the need to specify the type signatures is only for stuff which can be considered advanced uses of the type system, though, right? like generic programming and the like...
02:04:30 <Cale> Dynetrekk: On the more syntactic side of things, it's mostly enforced, but line up things vertically when they are at the same level, and indent further if they are deeper in the syntax. The actual rules are a bit more lax regarding things like if/then/else -- the convention though is to line up the 'then' and 'else' and start them on a column further in than the 'if'. Also, never include tab characters in your source
02:04:30 <Cale>  file.
02:04:54 <Cale> (any column further in, I should say)
02:04:57 <Dynetrekk> Cale: so, similar to python, more or less.
02:05:00 <Cale> yeah
02:05:11 <Cale> Though, some python people like tabs for some reason.
02:06:03 <Cale> You've probably already noticed, but camelCase is pretty much the norm for naming.
02:06:22 <explicitjelly> Dynetrekk, the if/then/else-part is only done wrong. take care: Cale said to indent then and else a column further, not on the same level!
02:06:29 <Dynetrekk> Cale: from what I've seen, python people advocate spaces, as mixing spaces and tabs invariably kills the whole program in python
02:06:36 <explicitjelly> Dynetrekk, it gets clear why it's a good idea to do this once you're using it in a do-block
02:06:39 <Cale> Like:
02:06:40 <Cale> if foo
02:06:42 <Cale>    then bar
02:06:47 <chrisdone> cale: except when people randomly use this_style (why???)
02:06:47 <Cale>    else quux
02:07:00 <Cale> Dynetrekk: right, same here
02:07:08 <explicitjelly> Dynetrekk, it looks strange at first, but actually makes sense when you observe that then and else are really part of the whole if-expression
02:07:14 <Dynetrekk> Cale: I tend to prefer camelCase, so: good!
02:07:23 <explicitjelly> Dynetrekk, it's not a control structure here, it's an evaluated expression
02:07:26 <Dynetrekk> explicitjelly: no, does not look strange to me :)
02:07:47 <explicitjelly> Dynetrekk, ok :)
02:08:08 <Cale> I preferred the Haskell way of indenting if/then/else as soon as I discovered it too, it makes a lot more sense than some of the more common options in other languages :)
02:08:32 <chrisdone> disappointly it's syntax and not a function..
02:08:43 <Cale> I'm not that disappointed by that...
02:08:52 <Cale> It would be nice to have a corresponding function though.
02:08:59 <explicitjelly> meh, everyone's using pattern matching anyway ;)
02:09:00 <hackage> Uploaded to hackage: open-witness 0.1.1
02:09:02 <explicitjelly> and guards
02:09:03 <Dynetrekk> it's nice if a language is readable, not only short to write
02:09:07 <Cale> yeah
02:09:08 <explicitjelly> Dynetrekk, do you know about guards?
02:09:11 * Heffalump wants more overloading
02:09:15 <chrisdone> Dynetrekk: shortness isn't the point
02:09:21 * Myoma likes 'bool' more than if sometimes
02:09:25 <Dynetrekk> explicitjelly: no idea what a guard is, unless we're talking about buckingham palace
02:09:26 <Cale> bool :: Bool -> a -> a -> a
02:09:31 <Cale> yeah, I agree
02:09:31 <Myoma> hm
02:09:37 <Myoma> my bool is a -> a -> Bool -> a though
02:09:41 <Cale> Or that, sure
02:09:42 <explicitjelly> Dynetrekk, we are. in any case, don't try to trick a guard into talking to you
02:09:45 <chrisdone> yeah, that is more partially applicable
02:09:46 <explicitjelly> Dynetrekk, they don't like that.
02:09:55 <Myoma> (it is mostly used with leaving off the actual boolean)
02:09:58 <explicitjelly> Dynetrekk, no, seriously though. you know pattern matching
02:10:29 <Dynetrekk> explicitjelly: no, unless we're talking about matching the queen's dress with her shoes?
02:10:35 <Cale> abs x | x < 0     = -x
02:10:42 <Dynetrekk> explicitjelly: seriously, no.
02:10:42 <Cale>       | otherwise = x
02:10:52 <chrisdone> Myoma: when going crazy I've also wanted (a -> b) -> (a -> b) -> (a -> Bool) -> b
02:10:53 <Dynetrekk> that's pattern matching, Cale ?
02:11:04 <Cale> Dynetrekk: The things after the | are guards
02:11:04 <explicitjelly> Dynetrekk, but you used pattern matching in that thing you pasted...
02:11:09 <explicitjelly> that was pattern matching *and* guards.
02:11:14 <explicitjelly> pattern matching:
02:11:19 <explicitjelly> isZero 0 = True
02:11:22 <explicitjelly> isZero _ = False
02:11:27 <explicitjelly> guards:
02:11:28 <Dynetrekk> Cale: like mathematical functions f(x) = this and that for x<0 and otherwise (something else) ?
02:11:35 <explicitjelly> isLessThan 5 x | x < 5 = True
02:11:36 <Cale> Dynetrekk: yeah
02:11:39 <explicitjelly> ugh
02:11:43 <explicitjelly> isLessThanFive x | x < 5 = True
02:11:47 <explicitjelly> ...
02:11:47 <Cale> Dynetrekk: just syntactically, those things with the | are called guards :)
02:11:48 <explicitjelly> (sorry)
02:12:06 <Dynetrekk> Cale: okay, so, same as in a mathematical function then
02:12:09 <Cale> yeah
02:12:13 <explicitjelly> yup
02:12:21 <Cale> It used to be that they were written after the equation.
02:12:25 <Cale> like
02:12:37 <Cale> isZero x = True | x == 0
02:12:37 <explicitjelly> if you're ever writing a compiler, you'll hate every language that doesn't support pattern matching
02:12:53 <Cale> But usually the code is longer than the condition
02:12:56 <explicitjelly> well, ok, that's a bit strong, I still like python very much
02:13:03 <Myoma> explicitjelly: or add it to the language
02:13:03 <Cale> and so it makes sense to put the condition first
02:13:21 <Cale> (so you don't end up with a ton of code and then way at the end a condition for it running :)
02:13:32 <zandax_> How can I "cast" an integer that a text output function will accept it as a string parameter? :x
02:13:38 <Cale> zandax_: show
02:13:40 <explicitjelly> Myoma, why did nobody think about adding it to python?
02:13:41 <luqui> The only think I hate about haskell is that it has caused me to hate every other language!  Now I hate EVERYTHING GRRR!!!
02:13:44 <Cale> > show 5
02:13:46 <lambdabot>  "5"
02:13:53 <explicitjelly> Myoma, well, I'm sure people thought about it, but why isn't it done?
02:13:54 <zandax_> thanks :D
02:13:58 <Cale> zandax_: show is generally how you turn things into strings
02:14:02 <Cale> > show [1,2,3]
02:14:03 <lambdabot>  "[1,2,3]"
02:14:25 <Cale> > show (2,Left 6,[4,5])
02:14:26 <lambdabot>  "(2,Left 6,[4,5])"
02:14:31 <luqui> explicitjelly, would that not add too many ways to do something
02:14:45 <explicitjelly> luqui, hmm. you think so?
02:14:51 <Dynetrekk> explicitjelly: like an imperative language? wow, really.
02:15:11 <explicitjelly> Dynetrekk, hm, what?
02:15:19 <explicitjelly> Dynetrekk, what are you referring to?
02:15:27 <Dynetrekk> explicitjelly: I thought that was against your religion, liking non-functional languages
02:15:27 <luqui> python shys away from advanced features so that there's a canonical way to solve most (small-scale) problems
02:15:31 <Cale> It is quite funny that more languages don't support algebraic datatypes and pattern matching.
02:15:34 <explicitjelly> Dynetrekk, uh
02:15:43 <explicitjelly> Dynetrekk, I'm pretty much a newbie in Haskell
02:15:46 * luqui hacked support for ADTs into perl ;-)
02:15:46 <explicitjelly> Dynetrekk, no religion there
02:15:47 <Dynetrekk> explicitjelly: me too :)
02:16:03 <Myoma> luqui: cool! did you put the code up anywhere?
02:16:16 <Dynetrekk> explicitjelly: I suspect haskell will never be as useful to me as other languages, because it seems to be too slow
02:16:20 <luqui> it was a long time ago, but it's on CPAN.  let's see if I can remember what it's called
02:16:23 <Cale> Dynetrekk: really?
02:16:24 <chrisdone> Dynetrekk: I heard some haskellers use perl sometimes
02:16:41 <Dynetrekk> Cale: for heavy computations
02:16:45 <Myoma> Dynetrekk: How long have you been using haskell?: p
02:16:47 <luqui> Myoma, Symbol::Opaque
02:16:48 <explicitjelly> Dynetrekk, I'm also not using it for performance critical things. I almost exclusively use C for that.
02:16:53 <Dynetrekk> Myoma: almost nothing
02:16:57 <explicitjelly> Dynetrekk, though I like writing C modules for python and Haskell
02:17:02 <Myoma> ty luqui
02:17:12 <Dynetrekk> explicitjelly: I see, sounds complicated though
02:17:24 <Dynetrekk> explicitjelly: I tried it for python, but it was messy, I think
02:17:28 <explicitjelly> Dynetrekk, did it a few weeks ago when I had to calculate a *huge* covariance matrix. that sucked in python. a dynamic language is not what you want there
02:17:48 <Dynetrekk> explicitjelly: no, C(++), java, fortran is what people use, I guess
02:17:51 <explicitjelly> so I implemented that part in a few lines in C
02:18:08 <Cale> Dynetrekk: The next GHC will have some really nice stuff for parallel computation, which might be quite good for some sorts of numeric work, especially.
02:18:08 <explicitjelly> Dynetrekk, it's quite common today to use python as a frontend
02:18:14 <explicitjelly> Dynetrekk, it supercedes Matlab %)
02:18:28 <Dynetrekk> explicitjelly: personally, I made a wavelet transform in C for python, but, it was tedious, and the sharp and pointy parts of C somehow penetrated into python (like C arrays/pointers)
02:18:35 <Cale> (well, the current GHC has decent support for parallelism, but not nearly as nice as the new stuff will be :)
02:18:50 <Dynetrekk> explicitjelly: I've been using python, and will probably stick at that
02:19:00 <Myoma> that is very cool luqui :)
02:19:08 <luqui> thank you :-)
02:19:19 <Cale> Dynetrekk: If you're doing *really* heavy computation, using Haskell to write a special-purpose compiler can actually be a not-too-unreasonable approach.
02:19:24 <Dynetrekk> Cale: could be. but, fortran (for instance) has a ton of super-fast routines which noone can beat, at least not most of their users
02:19:41 <DuClare> Dynetrekk, GHC performs pretty well according to the great language shootout
02:19:44 <Dynetrekk> Cale: sounds like too much work, I would need a computer science degree first :P
02:19:55 <Cale> Dynetrekk: another option is using Haskell as a glue language and simply FFI importing what you need from C or Fortran.
02:20:10 <Dynetrekk> DuClare: could be. now, find me a library which solves huge sparse equation systems, and so on, and so on
02:20:18 <Dynetrekk> Cale: FFI importing?
02:20:27 <Cale> Foreign Function Interface
02:20:35 <Cale> You can call basically any C code.
02:20:46 <Dynetrekk> Cale: I see. C and python or java/jython or similar could also be possible there
02:20:55 <Dynetrekk> Cale: but it should preferably be pure, right?
02:21:03 <explicitjelly> Dynetrekk, well, if you're really focused on heavy numeric computation, then you should use C, Fortran, Assembler, things like that, yes. maybe with python and Haskell for frontends.
02:21:10 <Cale> Well, if it's not pure, you can treat it as an IO action of course.
02:21:29 <Cale> But yeah, it's nice to build pure interfaces around things, at least :)
02:21:56 <Dynetrekk> explicitjelly: I think so too. or, Java, possibly. java has several nice scripting languages, like jython, which interfaces very nicely with java classes - easier than python/c
02:22:13 <explicitjelly> Dynetrekk, yes, and it seems like java has a pretty nice JIT today.
02:22:19 <Dynetrekk> Cale: that's what I thought, so I tried to write a pure function to wrap file reading
02:22:49 <Dynetrekk> explicitjelly: indeed. some things are better than in C, though I suspect numerics are faster in C(++).
02:22:50 <Cale> I've also successfully linked Haskell and Fortran code (using the gnu fortran compiler), it's not documented that you can do that, but it works fine.
02:23:19 <explicitjelly> Dynetrekk, you have more control in C.
02:23:27 <Dynetrekk> Cale: expect more questions later, then :P
02:23:32 <Dynetrekk> explicitjelly: control, as in..?
02:23:49 <Cale> Dynetrekk: There's also the fact that you can do some nice algebraic transformations on the Haskell level which would be tougher in C.
02:23:51 <ulfdoz> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen <- how serious is this to be taken?
02:23:56 <explicitjelly> Dynetrekk, for example, memory management. deciding when to map which portions of a really large datastructure in virtual memory etc.
02:23:58 <lambdabot> Title: Commentary/Compiler/IntegratedCodeGen - GHC - Trac, http://tinyurl.com/6g4fqb
02:24:13 <explicitjelly> Dynetrekk, you can do more bare metal programming in C
02:24:35 <Cale> Dynetrekk: GHC has a really nice feature called RULES which allows you to specify algebraic laws about the functions in your library which will be applied to programs written to use it in order to simplify them.
02:24:44 <Dynetrekk> explicitjelly: possible. but, this amounts to a lot of work, and for some things, the java memory manager is faster than average Joe programmer's C code
02:24:45 <explicitjelly> Dynetrekk, you'll know exactly what happens in memory and can think in terms of CPU cachelines etc.
02:25:22 <Dynetrekk> Cale: sounds interesting, but what does it mean?
02:25:27 <explicitjelly> Dynetrekk, of course, but you can if you absolutely want to, and if you absolutely want to, it's less of a hassle than in java
02:25:33 <Dynetrekk> explicitjelly: could be. I don't know enoug C to do that though :)
02:26:06 <k-zed_> (greetings all. Warning: newbie!) how does one apply a list to a function in Haskell? (like lisp apply)
02:26:14 <explicitjelly> Dynetrekk, when dealing with index structures for large multidimensional data, it's nice to manage your pages manually
02:26:17 <ulfdoz> explicitjelly: Those "optimizations" may be highly platform dependent. I don't want them to have within my code.
02:26:26 <explicitjelly> k-zed, map
02:26:28 <Dynetrekk> explicitjelly: and I don't want to learn fortran! but I suspect I will have to :(
02:26:30 <Cale> Dynetrekk: Well, for example, there's a library called Data.ByteString for operations on strings of bytes. These operations are transformed by rules in order to turn naive looking code into code which does things like block buffering.
02:26:33 <hml> what's the fastest way to parse csv's in haskell?
02:26:43 <explicitjelly> ulfdoz, not necessarily
02:26:56 <k-zed> explicitjelly: isn't that more like an analogue of scheme map?
02:26:59 <explicitjelly> ulfdoz, I'm talking about simple things like replacing a frame with a page
02:27:03 <k-zed> i don't want the function applied to each element of the list
02:27:13 <explicitjelly> k-zed, ah. err... what do you want? %)
02:27:14 <k-zed> say, i have a three element list: [1,2,3]
02:27:18 <k-zed> and i have a function with three integer arguments
02:27:23 <k-zed> and i want something like apply fn list
02:27:30 <k-zed> like the apply function in scheme
02:28:09 <k-zed> (altho i see i can do this trivially (for specific number of arguments))
02:28:09 <Cale> k-zed: I think the best you can do is something like... case xs of [x,y,z] -> f x y z
02:28:14 <Dynetrekk> k-zed: map (^2) [1..10] ?
02:28:20 <DuClare> The folds would accumulate a result
02:28:21 <explicitjelly> k-zed, oh... ok. i guess i'd just write \[x,y,z] -> fn x y z
02:28:25 <Cale> k-zed: Every function has a specific number of arguments.
02:28:41 <Cale> Well, that's not *quite* true...
02:28:46 <explicitjelly> k-zed, or similar, depending on context
02:29:01 <Cale> I suppose with typeclass polymorphism tricks, you can write variadic functions...
02:29:09 <k-zed> so there's nothing in particular built in?
02:29:17 <Cale> But it's easier to just write functions that take a list to take a list.
02:29:17 <k-zed> (i suppose this would have to be a language feature, or a complex hack)
02:29:30 <k-zed> okay, thanks.
02:29:35 <explicitjelly> k-zed, nothing which is simply done in such a strongly typed language
02:29:36 <DuClare> 12'28'20 « DuClare» The folds would accumulate a result
02:30:02 <explicitjelly> k-zed, the result wouldn't be very type safe
02:30:36 <Cale> We do have funky things like printf though (which is a typeclass hack :)
02:30:51 <explicitjelly> yeah, printfs is a bit scary
02:30:54 <Cale> > printf "%s %i %s" "Hello" 5 "World" :: String
02:30:56 <lambdabot>  "Hello 5 World"
02:31:21 <explicitjelly> :t printf
02:31:22 <lambdabot> forall r. (PrintfType r) => String -> r
02:31:30 <Cale> (note the explicit type signature, since otherwise, it wouldn't be sure if I wanted a String, or another function :)
02:31:48 <explicitjelly> :t printf "%i"
02:31:49 <lambdabot> forall r. (PrintfType r) => r
02:31:53 <explicitjelly> :t printf "%i" 1
02:31:54 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
02:32:00 <explicitjelly> really scary.
02:32:15 <Cale> > printf "%i" 1 :: String
02:32:16 <lambdabot>  "1"
02:32:19 <Cale> > printf "%i" 1 :: IO String
02:32:20 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
02:32:29 <Cale> Well, it is an IO String if you want it to be :)
02:32:38 <Cale> :t printf "%i" 1 :: IO String
02:32:39 <lambdabot> IO String
02:32:42 <Cale> yep :)
02:32:59 <Cale> So it's simultaneously printf and sprintf
02:33:18 <dzlk> > :t printf "%i %i" 1
02:33:19 <lambdabot> Terminated
02:33:25 <explicitjelly> hm. isn't it still only sprintf?
02:33:39 <Cale> explicitjelly: no, because it can be an IO action for printing the string as well. :)
02:33:39 <explicitjelly> :t printf "%i" 1 :: IO ()
02:33:41 <lambdabot> IO ()
02:33:45 <explicitjelly> aah.
02:34:05 <explicitjelly> Cale, yeah, but, the IO String example isn't, or is it?
02:34:20 <Cale> hmm
02:34:47 <Cale> oh, actually, that works
02:34:47 <dzlk> :t printf "%i %i" 1 2 :: String
02:34:48 <lambdabot> String
02:34:52 <Cale> but it results in undefined
02:35:08 <Cale> (the String it returns is undefined)
02:35:15 <explicitjelly> strange.
02:35:20 <Cale> yeah
02:35:26 <explicitjelly> scary!
02:35:37 <Cale> I guess they just wrote an instance of PrintfType for (IO t)
02:36:36 <explicitjelly> I guess passing printf-stuff around makes hell seem like a nice place
02:37:29 <Cale> Well, if you think that's insane, you should see the regex library :)
02:37:43 <explicitjelly> Dynetrekk, so, in conclusion, if you're primarily interested in numerics and graphical interfaces to simple things, then Haskell is not the right choice, at least not now. (my opionion only)
02:37:46 <k-zed> so i gather there are some skeletons in the closet ;)
02:37:57 <Cale> k-zed: Well, it's actually all quite well-defined
02:37:59 <explicitjelly> Dynetrekk, for everything else I've come across until now it's just great, however %)
02:38:13 <Cale> k-zed: It's just there are some libraries whose design is a bit strange :)
02:38:15 <Dynetrekk> explicitjelly: not GUI, but numerics, indeed. thanks for your opinion anyway
02:38:45 <Cale> k-zed: There are no real deep hacks needed, just an interesting use of typeclasses
02:39:44 <Dynetrekk> explicitjelly: I'm off. see ya!
02:40:01 <explicitjelly> k-zed, interesting use of those "advanced" type features
02:40:16 <explicitjelly> k-zed, those that always seem like magic at first %)
02:40:23 <Cale> > "f92" =~ "[a-z][0-9]*" :: Bool
02:40:24 <lambdabot> Terminated
02:40:26 <Cale> hmm
02:40:38 <Cale> Maybe an import is off..
02:40:47 <explicitjelly> :t (=~)
02:40:48 <lambdabot> Not in scope: `=~'
02:40:56 <Cale> yeah, not in scope
02:41:02 <explicitjelly> :t scope
02:41:03 <lambdabot> Not in scope: `scope'
02:41:06 <explicitjelly> ;)
02:41:31 <Cale> @undefine
02:41:32 <lambdabot> Undefined.
02:41:35 <Cale> > "f92" =~ "[a-z][0-9]*" :: Bool
02:41:36 <lambdabot> Terminated
02:41:41 <Cale> :t (=~)
02:41:42 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
02:41:46 <Cale> hmm
02:41:56 <explicitjelly> that is...
02:42:00 <Cale> It works in ghci...
02:42:00 <explicitjelly> really a most verbose type...
02:42:12 <Cale> It's mostly the qualified module names :)
02:44:27 * Cale wonders if he updates mueval if the problem will be fixed :)
02:45:40 <Cale> Anyway, the neat thing about the regex library is by evaluating that at different types, you can get all sorts of different results
02:46:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html
02:46:07 <lambdabot> Title: Text.Regex.Base.Context, http://tinyurl.com/yovda9
02:46:12 <Cale> that documents the various types :)
02:46:38 * Myoma is irritated that view patterns don't to implicit untupling
02:46:54 <Myoma> I would like to write f (foo -> x y z) = ... instead of f (foo -> (x,y,z))
02:47:06 <dmhouse> Wasn't that part of the proposal?
02:47:08 <Cale> Myoma: is it going to stay like that?
02:47:14 <Cale> Myoma: I think it's just not done yet
02:47:31 <Myoma> oh I hope so
02:47:31 <explicitjelly> Myoma, what's a view pattern?
02:48:10 <dmhouse> See "Implicit tupling" in http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns#FurtherSyntacticExtensions
02:48:11 <Myoma> explicitjelly, if you call f 3, then it tries to match the result of (foo 3) against (x,y,z)
02:48:14 <lambdabot> Title: ViewPatterns - GHC - Trac, http://tinyurl.com/33xhs7
02:48:19 <dmhouse> explicitjelly: see that URL
02:48:27 <dmhouse> (But obviously start from the top.)
02:48:31 <Myoma> explicitjelly, I like it because you can write things like:
02:48:32 <Myoma> mergeSort [] = []
02:48:32 <Myoma> mergeSort [e] = [e]
02:48:32 <Myoma> mergeSort (halve -> (left , right)) = (merge`on`mergeSort) left right
02:48:53 <explicitjelly> ooh, nice.
02:48:55 <Myoma> .....but that's not quite as neat as
02:48:59 <Myoma> mergeSort (halve -> left right) = (merge`on`mergeSort) left right
02:49:21 * Myoma takes a look at the implementation
02:49:34 <therp> anyone responsible for planet.haskell.org around?
02:52:40 <Heffalump> therp: I think you have to email them
02:52:42 <Cale> Myoma: How long have you been using Haskell? I'm not sure I've seen you around here until recently...
02:52:58 <Cale> @hoogle find
02:52:58 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
02:52:59 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:52:59 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:53:08 <Cale> @djinn a -> b -> (a,b)
02:53:08 <lambdabot> f a b = (a, b)
02:53:32 <therp> Heffalump: did that.. no response.. :/
02:55:09 * Myoma can't work it out but under a year I think
02:55:57 <Myoma> Cale: I had been here before with a different nick though
02:56:25 <Cale> ah
02:56:27 <chrisdone> Myoma: I started in january (new year), pretty sure you'd been at haskell for a few months before then
02:56:32 <Cale> @djinn ((((a -> r) -> r) -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
02:56:32 <lambdabot> f a b = a (\ c _ -> c b) b
02:56:51 <chrisdone> (yes I know new year-new language is cliche)
02:57:06 <dmhouse> Huh? Will f _ b = b not work?
02:57:17 * Myoma guesses EViewPat expr patE -> checkLPat patE >>= (return . (\p -> ViewPat expr p placeHolderType)) has something to do with it
02:57:20 <Cale> Have to be careful about the parens there :0
02:57:23 <Cale> :) *
02:57:37 <dmhouse> Oh, so you do. Pierce's law, then.
02:57:53 <Cale> @djinn ((Cont r a -> Cont r b) -> Cont r a) -> Cont r a
02:58:03 <Cale> ...
02:58:09 <dmhouse> ?djinn-env
02:58:09 <Cale> Oh well :)
02:58:17 <dmhouse> ?botsnack
02:58:17 <lambdabot> :)
02:58:24 <Cale> It seems happy not to respond to random djinn commands...
02:58:30 <dmhouse> ?djinn-add type Cont r a = (a -> r) -> r
02:58:41 <Cale> @djinn ((Cont r a -> Cont r b) -> Cont r a) -> Cont r a
02:58:41 <lambdabot> Cannot parse command
02:58:41 <lambdabot> f :: ((Cont r a -> Cont r b) -> Cont r a) -> Cont r a
02:58:41 <lambdabot> f a b = a (\ c _ -> c b) b
02:58:44 <Cale> hmm
02:59:04 <dmhouse> Was the "Cannot parse command" directed to me?
02:59:10 <Cale> I don't know...
02:59:12 <Cale> @djinn ((Cont r a -> Cont r b) -> Cont r a) -> Cont r a
02:59:12 <lambdabot> Cannot parse command
02:59:12 <lambdabot> f :: ((Cont r a -> Cont r b) -> Cont r a) -> Cont r a
02:59:12 <lambdabot> f a b = a (\ c _ -> c b) b
02:59:13 <dmhouse> That is how you add things to the environment, right?
02:59:20 <Cale> yes, I think do
02:59:24 <Cale> I think so*
02:59:41 <Cale> also, the environment probably contains more than the empty set :)
02:59:49 <dmhouse> True. :)
02:59:56 <Cale> @djinn Either a b -> (a -> c) -> (b -> c) -> c
02:59:57 <lambdabot> Cannot parse command
02:59:57 <lambdabot> f :: Either a b -> (a -> c) -> (b -> c) -> c
02:59:57 <lambdabot> f a b c =
02:59:57 <lambdabot>     case a of
02:59:57 <lambdabot>     Left d -> b d
02:59:59 <lambdabot>     Right e -> c e
03:00:04 <Cale> Clearly it contains Either :)
03:00:09 <dmhouse> ?djinn (Not a, a) -> b
03:00:09 <Cale> hmm
03:00:10 <lambdabot> Cannot parse command
03:00:10 <lambdabot> f :: (Not a, a) -> b
03:00:10 <lambdabot> f (a, b) = void (a b)
03:00:17 <Cale> @djinn-clr
03:00:24 <dmhouse> ?djinn-env
03:00:27 <Cale> ?djinn (Not a, a) -> b
03:00:27 <lambdabot> f (a, b) = void (a b)
03:00:32 <Cale> ...
03:00:41 <Myoma> @djinn env
03:00:41 <lambdabot> -- f cannot be realized.
03:00:41 <dmhouse> Ah well.
03:01:03 <dmhouse> ?djinn Either a (Not a)
03:01:03 <lambdabot> -- f cannot be realized.
03:01:06 <Cale> maybe something broke in the recent update of djinn
03:01:12 <Cale> (the executable)
03:01:13 <dmhouse> ?djinn Not (Not (Either a (Not a)))
03:01:14 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
03:01:25 <dmhouse> ?djinn Not (Not a) -> a
03:01:25 <lambdabot> -- f cannot be realized.
03:01:41 <dmhouse> Ah that's right, double negation elimination isn't intuitionistic.
03:01:47 <ski> Cale : did you update to augustss latest version ?
03:01:48 <Cale> ?djinn Not (Not (Not a)) -> Not a
03:01:49 <lambdabot> f a b = void (a (\ c -> c b))
03:01:52 <Cale> ski: yeah
03:02:12 <dmhouse> ?djinn a -> Not (Not a)
03:02:12 <lambdabot> f a b = b a
03:02:14 <Cale> ski: Well, more correctly, I installed the latest version on this fresh machine :)
03:03:05 <Cale> dmhouse: Applying Not Not to everything gives you classical logic :)
03:03:53 <Myoma> ?djinn Not (Not (Either a (Not a))
03:03:53 <lambdabot> Cannot parse command
03:03:53 <lambdabot> Cannot parse command
03:03:54 <Guest32993> are Chars convertable to ascii values
03:04:05 <trofi> :t ord
03:04:06 <lambdabot> Char -> Int
03:04:09 <Guest32993> thx
03:04:20 <Myoma> > fromEnum 'e'
03:04:21 <lambdabot>  101
03:04:22 <Cale> Guest32993: ord or fromEnum
03:04:25 <Myoma> > fromEnum '÷'
03:04:26 <lambdabot>  247
03:04:27 <trofi> byt GHC Chars are not 8bit
03:04:33 <Cale> (fromEnum is conveniently in the Prelude)
03:04:34 <dmhouse> ((a -> Void) -> Void) -> a -- hmm, this looks like an application of the generalised Pierce's law.
03:04:39 <Myoma> > fromEnum '÷' :: Word8
03:04:40 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Int'
03:04:42 <trofi> > ord 'Ъ'
03:04:43 <lambdabot>  1066
03:04:56 <ski> @djinn Not (Not (Either (Not a) a))
03:04:56 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
03:04:58 <Myoma> ?djinn f :: Not (Not (Either a (Not a))
03:04:58 <lambdabot> Cannot parse command
03:04:59 <dmhouse> Never noticed that connection before, nice.
03:05:04 <Myoma> huh
03:05:08 <dmhouse> Myoma: drop the f ::
03:05:24 <Myoma> oh :(
03:05:25 <ski> dmhouse : "application of the generalised Pierce's law." ?
03:06:00 <trofi> :t fromEnum
03:06:01 <lambdabot> forall a. (Enum a) => a -> Int
03:06:13 <dmhouse> ski: ((a -> b) -> c) -> a
03:06:33 <ski> never seen before
03:06:34 <ski> only
03:06:46 <dmhouse> Which is basically LEM, IIRC.
03:06:56 <ski> pierce :: ((a -> b) -> a) -> a   -- this is of course `call-with-current-continuation', basically
03:07:02 <Cale> @djinn Not (Not (((a -> b) -> a) -> a))
03:07:02 <lambdabot> f a =
03:07:02 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
03:07:04 <dmhouse> "With that understanding, the formula states the principle of excluded middle, that from the falsity of the denial of x follows the truth of x."
03:07:15 <dmhouse> http://en.wikipedia.org/wiki/Pierce%27s_Law#History
03:08:03 <dmhouse> So yeah, that's Pierce confirming that ((a -> Void) -> Void) -> a is an application of his law. :)
03:08:05 <Cale> I find it lovely that K, S, and call/cc effectively give you classical logic :)
03:08:16 <zandax_> I searched for a while now, but I still didn't find a solution to change the value of a variable or doing the counterpart :|
03:08:34 <zandax_> *Haskell counterpart
03:08:41 <dmhouse> zandax_: what do you want to do, really?
03:08:42 <ski> Cale : hm, what was hilberts axiom for negation .. ?
03:08:45 <dmhouse> I.e., at a broader level?
03:08:46 <Myoma> zandax_: what are you  trying to do ?
03:09:04 <dmhouse> zandax_: "How do I change a variable" -> you're doing it wrong.
03:09:11 <zandax_> @dmhouse: I want to display a character on screen which should be moved with the keyboard.
03:09:11 <lambdabot> Unknown command, try @list
03:09:26 <zandax_> @dmhouse: I know, dmhouse. But I don't know the Haskell way.
03:09:26 <lambdabot> Unknown command, try @list
03:09:34 <Cale> ski: I don't remember
03:09:38 <dmhouse> zandax_: you should probably drop the @ prefices otherwise poor lambdabot is going to get confused.
03:09:47 <zandax_> sorry
03:09:51 <ski> possibly `(Not a -> b) -> (Not b -> a)'
03:09:59 <zandax_> habit :/
03:10:28 <dmhouse> ?djinn (Not a -> b) -> (Not b -> a)
03:10:29 <lambdabot> -- f cannot be realized.
03:10:37 <dmhouse> ?djinn Not (Not ((Not a -> b) -> (Not b -> a)))
03:10:37 <lambdabot> f a =
03:10:37 <lambdabot>     void (a (\ _ b ->
03:10:37 <lambdabot>              void (a (\ c -> void (b (c (\ d -> a (\ _ _ -> d))))))))
03:10:41 <ski> obviously, that isn't intuitionistic
03:10:55 <Cale> Another really nice thing is how the instance of Applicative for (->) e gives you K and S :)
03:10:59 <ski> (iirc, it has been called "phi" in some contination papers)
03:11:39 <dmhouse> zandax_: moved with the keyboard, how?
03:11:42 <Cale> Wikipedia has (not A -> not B) -> (B -> A)
03:11:55 <ski> it might have been that instead
03:12:02 <Cale> same thing basically :)
03:12:05 <dmhouse> Same thing, obviously.
03:12:06 <ski> either should work, i think
03:12:27 <dmhouse> It's the contrapositive, basically.
03:12:41 <zandax_> @dmhouse: I know how to get the data from the keyboard and I have two variables for the coord. In imperative languages that's a breeze but I have no idea how to do it within Haskell.
03:12:42 <lambdabot> Unknown command, try @list
03:12:44 <zandax_> damn
03:12:50 <dmhouse> If you let c = Not a and d = Not b, you get (c -> d) -> (Not d -> Not c)
03:13:16 <dmhouse> Yes, so it's clearly not intuitionistic, because the very point of intuitionisism is to not use proof by contradiction :)
03:13:39 <Cale> zandax_: In Haskell, variables do not vary. They refer to specific values. Of course, this is not quite true, in that the parameters to a function are variables, and the function can be called with different arguments.
03:13:49 <dmhouse> zandax_: I still don't quite understand what you're trying to do.
03:14:26 <zandax_> I want to move an object on screen with the cursor block. It's that simple.
03:14:51 <dmhouse> Which graphics library are you using?
03:14:57 <ski> dmhouse : btw, have you understood how `lem :: Either (Not a) a' works, computationally ?
03:14:58 <zandax_> HGL
03:15:21 * dmhouse backs out, knowing nothing of HGL
03:15:24 <Cale> zandax_: Okay, so you'll probably have some parameter which is the current position on the screen of the object, that will be passed in as some starting value.
03:15:35 <zandax_> @dmhouse: the IO interaction is not the problem
03:15:36 <lambdabot> Unknown command, try @list
03:15:37 <Cale> myLoop (0,0)
03:15:41 <Cale> for example
03:15:50 <zandax_> oh my god, I am not able to stop making @
03:15:52 <dmhouse> But I expect you can just do something like main = do (x,y) <- getKeyboardInput; moveThingy x y; loop
03:15:53 <Myoma> ?djinn Either (Not a) a
03:15:53 <lambdabot> -- f cannot be realized.
03:16:03 <Cale> and then myLoop will do something to display the object on the screen, and then get some input from the user, most likely
03:16:14 <Cale> It will then call itself with a new position :)
03:16:16 <zandax_> dmhouse I already have the keyboard input data
03:16:28 <Cale> zandax_: does that make sense?
03:16:30 <ski> (.. in languages with first-class continuations, i.e. .. like Scheme or SML/NJ)
03:16:33 <zandax_> I just need to know how to "transform" the coordinates
03:16:33 <dmhouse> Err, s/loop/main
03:16:41 <dmhouse> ski: what do you mean by 'computationally' here?
03:16:45 <Myoma> @src Not
03:16:45 <lambdabot> Source not found. My brain just exploded
03:16:47 <Myoma> ughhh
03:16:49 <Myoma> @djinn-env
03:16:53 <dmhouse> Myoma: type Not a = a -> Void
03:16:55 <zandax_> Cale, that sounds good :)
03:16:57 <dmhouse> Where data Void
03:17:01 <Cale> zandax_: okay :)
03:17:08 <Myoma> lambdabot: Can you not just tell me?
03:17:24 <dmhouse> zandax_: rule of thumb: loops in imperative languages transform to recursion under Haskel.
03:17:26 <ski> dmhouse : e.g. how would a hypothetical `case lem of Left k -> void (k 42); Right n -> n+1' work ?
03:17:39 <dmhouse> zandax_: often this recursion is implicit, e.g. you wrap it up in a map or a fold, but it's still there.
03:17:46 <Cale> zandax_: There are more sophisticated things you can do if you have tons and tons of objects and such, but this is simple and an important step to understanding how to transform your existing knowledge into something usable :)
03:18:13 <zandax_> :)
03:19:13 <Cale> A good way to think about it is that if a function depends on something in Haskell, then it should (typically) take that thing as a parameter.
03:19:50 <zandax_> I'm slowly getting it
03:20:18 <Cale> Another option we could take is to use an IORef
03:20:21 <dmhouse> Yes, you'll be surprised in a few weeks about how you managed to bend your imperative mind to functional thinking, and how easy writing in functional style seems.
03:20:48 <Cale> You would create a new IORef using something like  r <- newIORef (0,0)
03:21:05 <dmhouse> (You'd still need to pass the IORef as a parameter.)
03:21:11 <zandax_> it works :D
03:21:33 <Cale> and then you can use actions like (x,y) <- readIORef r  and writeIORef r (x+1,y)  to update the value.
03:21:43 <Cale> Of course, that technique only works in IO
03:21:58 <dmhouse> (Or generally in any monad.)
03:22:05 <dmhouse> *state monad
03:22:11 <Cale> (IORefs are only available in IO)
03:22:23 <zandax_> that's all very interesting. in the moment the player is the only object I need to handle, but of course over the days I will need a more complex approach
03:22:34 <ski> (dmhouse : "hypothetically" because Haskell doesn't have first-class continuations)
03:22:49 <Cale> zandax_: Of course, you could also have that one parameter be some value representing your entire game state.
03:23:26 <zandax_> yeah!
03:24:32 <zandax_> I'm so glad it works. I now have a tilemap and a moving player. That reminds me of my very first qbasic programs long time ago :')
03:24:45 <Cale> :)
03:28:12 <dmhouse> ski: in a language with first-class continuations, is it possible to write lem?
03:28:19 <dmhouse> (Assuming some encoding of Either and Not.)
03:28:35 <ski> yes
03:28:45 <ski> (i just did it in SML/NJ, fyi)
03:29:01 <dmhouse> Right, and presumably doing so will help me answer the question.
03:29:12 <explicitjelly> lem?
03:29:21 <dmhouse> explicitjelly: law of excluded middle.
03:29:28 <dmhouse> explicitjelly: do you understand the Curry-Howard isomorphism?
03:30:02 <explicitjelly> ah
03:30:04 <explicitjelly> dmhouse, i think s
03:30:05 <explicitjelly> o
03:30:18 <dmhouse> explicitjelly: okay, well lem :: Either a (Not a)
03:30:29 <ski> (if you would like to try in SML/NJ, you should probably open the `SMLofNJ.Cont' structure .. for Scheme, you should use `call-with-current-continuation')
03:30:34 <dmhouse> Where type Not a = a -> Void, and Void is the datatype with no elements.
03:30:40 <dmhouse> Yes, I'll try with Scheme.
03:31:03 <explicitjelly> dmhouse, ah!
03:33:18 <dmhouse> Hmm, it's been a long time since I've written any Scheme. And this is a lot harder without a proper type system.
03:33:43 <jacobian> is there an easy way to race to algorithms in hugs or ghc such that you only take the answer from the first?
03:33:49 <jacobian> in parallel
03:34:10 <ski> (dmhouse : SML/NJ might be simpler for you then .. but possibly you don't have it installed ..)
03:34:30 <dmhouse> I've never written SML before, either. I don't even know what the 'NJ' stands for.
03:34:39 <ski> New Jersey
03:34:40 <dmhouse> It's okay, time to practice some catamorphisms at the same time.
03:35:17 <ski> SML/NJ is the implementation of SML from New Jersey (or at least originally from there .. i'm not sure if development mainly is there these days)
03:36:49 <ski> one note
03:37:06 <ski> it might be nicer to define a function, basically of type
03:37:12 <ski>   () -> Either (Not a) a
03:37:16 <Beelsebob> Finished doing the debian language shootout progs on my laptop :)
03:37:23 <Beelsebob> Haskell comes out really really well on OS X
03:37:24 <dmhouse> ski: right.
03:38:14 <dmhouse> ski: I've got to dash, but I'll think about this.
03:38:26 <Beelsebob> in one program, the Haskell is 65 times faster than the C :)
03:38:31 <ski> (because Scheme and SML/NJ are strict, and this uses continuation effects, we want to encapsulate those effects in a function so that they only happen when the function is called)
03:38:46 <ski> dmhouse : ok
03:50:24 <zandax_> I have another simple question :( I need to index my map ([[Int]]) with an x,y-Coordinate like an array. I tried map[x[y]] but that does not work and all examples I found only showed list comprehension
03:51:03 <Myoma> zandax_: you want to write [[Cell]] -> Coordinate -> Cell ?
03:51:33 <zandax_> yes, sort of
03:51:45 <Myoma> zandax_: what then?
03:51:47 <Beelsebob> @type (!!)
03:51:48 <lambdabot> forall a. [a] -> Int -> a
03:52:08 <Beelsebob> @type (\x y -> (!! y) . (!! x)
03:52:09 <lambdabot> parse error (possibly incorrect indentation)
03:52:11 <Beelsebob> @type (\x y -> (!! y) . (!! x))
03:52:12 <lambdabot> forall a. Int -> Int -> [[a]] -> a
03:52:17 <zandax_> I think thats exactly what I want. But I was surprised by that elegant formulation :)
03:52:42 <Myoma> zandax_: whats elegant ?
03:53:02 <ski> > [[0,1,2],[3,4,5],[6,7,8]] !! 2 !! 1
03:53:03 <lambdabot>  7
03:53:20 <zandax_> [[Cell]] -> Coordinate -> Cell
03:53:23 <Myoma> oh I see
03:53:27 <Myoma> You can write
03:53:30 <Myoma> type Cell = Int
03:53:35 <Myoma> type Coordinate (Int,Int)
03:53:38 <Myoma> oops
03:53:40 <Beelsebob> or... just make it polymorphic?
03:53:40 <Myoma> type Coordinate = (Int,Int)
03:53:48 <Myoma> Beelsebob: 'it'?
03:53:56 <Beelsebob> the indexing function
03:54:01 <zandax_> Yes you told me
03:54:09 <Myoma> Beelsebob: Certainl, I was not suggesting to annotate the function with at type
03:55:19 <dcoutts_> Cale: you were wondering where I was?
03:56:01 <zandax_> So how do I do the actual addressing? :)
03:56:16 <explicitjelly> what about JIT and haskell?
03:56:24 <ski> zandax_ : use `(!!)' ?
03:56:26 <Myoma> zandax_: let board be the [[Cell]] and (x,y) be the Coordinate
03:56:36 <dcoutts_> Cale: I guess the reason the hackage-scripts are not on hackage is it wouldn't buy much. You can't deploy it just by building. It needs apache and a specific dir layout and all the data.
03:56:38 <Myoma> board `at` (x,y) = (board !! y) !! x
03:56:38 <zandax_> yes
03:56:44 <zandax_> great!
03:56:52 <ski> (parens not needed)
03:57:02 <dcoutts_> Cale: on the other hand, the new hackage-server is just: cabal install hackage-server && hackage-server
03:57:04 <zandax_> looks easy
03:57:14 <dcoutts_> (well, once it's actually released on hackage)
04:01:17 <Beelsebob> explicitjelly: yhc could probably be (relatively) easily adapted to do JIT
04:02:13 <explicitjelly> yhc, didn't know that one
04:12:47 <Bruno_Kante_> http://www.pennergame.de/change_please/3573230/
04:12:48 <lambdabot> Title: Pennergame
04:13:20 <jpcooper> hello
04:13:30 <jpcooper> is ->, the type operator actually a real operator?
04:13:30 <Bruno_Kante_> helllo
04:13:41 <Bruno_Kante_> http://www.pennergame.de/change_please/3573230/
04:13:42 <lambdabot> Title: Pennergame
04:13:47 <jpcooper> I've seen it in a few definitions in the standard library documentation
04:13:53 <Myoma> Bruno_Kanto_: Do not do that
04:14:23 <chr1s> jpcooper: it's not an operater, it's a type operator ;)
04:14:32 <jpcooper> right
04:15:16 <chr1s> but you can use it much in the same way as other types that have 2 arguments. e.g. you can define instances for classes
04:31:15 * dcoutts_ looks around for volunteer Cabal hackers
04:31:58 <dcoutts_> there are several self-contained mini-projects for Cabal and cabal-install
04:32:07 <dcoutts_> like doing HTTP downloads properly
04:32:25 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/338
04:32:27 <lambdabot> Title: #338 (use of HTTP needs overhauling) - Hackage - Trac
04:33:00 <dcoutts_> Or checking for C libs like autoconf does, so we don't fail at link time with a confusing message
04:33:01 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/262
04:33:02 <lambdabot> Title: #262 (Check for required C libraries during configure) - Hackage - Trac
04:33:37 <dcoutts_> Or adding syntactic sugar so we don't have to abuse the flag syntax so much:
04:33:37 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/209
04:33:38 <lambdabot> Title: #209 (Implement "package()" configurations predicate) - Hackage - Trac
04:34:04 <dcoutts_> that's just a small sample of useful things you could do! :-)
04:34:24 <dcoutts_> check out the trac for the others or ask me for idea
04:59:23 <besiria> ?hoogle IORef
04:59:24 <lambdabot> Data.IORef data IORef a
04:59:24 <lambdabot> module Data.IORef
04:59:24 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
04:59:54 <trofi> :t liftIO
04:59:56 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
05:03:04 <trofi> :t getOpt
05:03:05 <lambdabot> Not in scope: `getOpt'
05:03:11 <trofi> @hoogle getOpt
05:03:11 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
05:03:11 <lambdabot> module System.Console.GetOpt
05:03:11 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
05:07:22 <Beelsebob> hmm, what a stunning idea
05:07:27 * Beelsebob goes looking at the docs for that
05:14:06 <Toxaris> I want to use SetConsoleTextAttribute from the Windows API [ http://msdn.microsoft.com/en-us/library/ms686047(VS.85).aspx ] and I am currently looking at the last line of System.Win32.Console [ http://haskell.org/ghc/docs/latest/html/libraries/Win32/src/System-Win32-Console.html ] : -- ToDo: lots more
05:14:07 <lambdabot> Title: SetConsoleTextAttribute Function (Windows)
05:14:36 <Toxaris> I guess it should be kind of easy to add some more functions there, but can someone give me a pointer, well, how to start?
05:17:05 <kowey> i'm looking for a good way to represent tables of data... the idea is that I would want to render them as HTML or LaTeX later
05:17:13 <kowey> any thoughts?
05:17:24 <BONUS> csv?
05:17:32 <Myoma> can you describe a table bit more specifically?
05:17:46 <ivanm> do you mean a haskell-oriented way, or any old way?
05:17:58 <kowey> yeah, I think that's my issue... a sort of fuzziness about what a table is
05:18:08 <kowey> I meant in a Haskell way
05:18:21 <ivanm> table = an x-by-y array of data?
05:18:28 <ivanm> Data.Array maybe?
05:18:31 <kowey> well..
05:18:52 <kowey> so there's issues I'm trying to grapple with here... like wanting to group some of the columns
05:18:54 <kowey> and some of the rows
05:19:14 <ivanm> either using a custom datatype that lets you choose whether you're storing data or labels, or else associate it with two other arrays used to store the x labels, y labels
05:19:23 <Toxaris> I don't think rendering as HTML or LaTeX should be a problem. I would focus on the operations you want to perform before you output your program's results
05:19:30 <kowey> efficiency isn't a primary concern right now; it could just be lists of lists of lists
05:19:51 <kowey> hmm operations...
05:20:00 <Myoma> type Column = ( Header , [ Cell ] )
05:20:02 <ivanm> if you want to both have grouped (as in latex multi{row,col} ?) by row and column, that might be difficult...
05:20:04 <Myoma> type Table = [Column]
05:20:16 <ivanm> Myoma: how bout row labels?
05:20:35 <ivanm> or have Cell a = Label String | Data a ?
05:20:35 <Myoma> ivanm: That's can be column
05:20:48 <Myoma> good idea, type Column a = ( Header , [ Cell a ] )
05:21:05 <ivanm> in which case, type Header = String ?
05:21:09 <Myoma> just one thing which isn't great
05:21:18 <Myoma> each column might be a differert length
05:21:20 <ivanm> ensuring equal column length?
05:21:37 <ivanm> also I don't see how you can get grouped row/columns like kowey wants...
05:21:45 <Myoma> but 'fixing' that makes oter things hard, so It's probably not worth it
05:22:00 <Myoma> grouped how? you can probably do it with a function
05:22:24 <ivanm> Myoma: I presume he means that you have two cells fused together... :s
05:22:40 <kowey> well, not necessarily fused
05:22:55 <kowey> what I meant was some kind of indication that "these rows go together"
05:23:19 <kowey> say I am running some tests on 5 different programs A1, A2, B1, B2, B3
05:23:31 <ivanm> well, if you _really_ want to get complex you can have a "null" Cell type that indicates not to draw anything for that cell, as well as a MultiCol type... *shrug*
05:24:15 <Toxaris> kowey: your "grouping" per column or per row, but not per cell, right? you don't need to  "highlight" a rectangular area in the middle of the table
05:24:37 <kowey> right, just columns and rows
05:24:47 <ivanm> ahhh.... columns might be easy then...
05:24:50 <Myoma> kowey like what ?
05:24:54 <Myoma> I don't understand
05:25:01 <ivanm> Table a = [[(Header, Cell a)]]
05:25:13 * kowey does some ascii art
05:25:13 <ivanm> Myoma: so you have almost sub-tables in the table
05:25:26 <Myoma> ivanm: I don't see it
05:25:53 <ivanm> so you have a 5-column table, but the first two rows are shaded/bordered/something differently from the other three (e.g. some thick border separating the two parts)
05:26:24 <Toxaris> data Header = Header String | Group Properties [Header]
05:26:28 <ivanm> e.g.: A1 | A2 ||| B1 | B2 | B3 <-- | = column border
05:26:52 <Toxaris> data Table a = Table Header Header [[a]]
05:27:03 <Myoma> I'd probably put the elements in STRefs by the way
05:27:18 <Toxaris> instance Monoid Properties where ...
05:28:10 <Toxaris> with my Table type, you have a separate grouping structure for columns and rows, and the data separate again
05:28:49 <Toxaris> no static guarantuees for the rectangularity, but you could just define that non-existent cells are treated as empty
05:30:00 <kowey> hmm... no hpaste announcement? http://hpaste.org/9864
05:31:41 <ivanm> kowey: only way I can think is to have something like this:
05:31:49 <Myoma> oh this is interesting
05:32:00 <ivanm> wait, I'll annotate
05:32:15 <kowey> i've written quick little haskell scripts to make tables... but I keep getting annoyed at myself
05:32:21 <Myoma> what does it mean with thet two tables next to each other?
05:32:26 <Myoma> like:
05:32:27 <kowey> have the feeling that I'm solving the same problem over and over again
05:32:27 <Myoma> ||
05:32:28 <Myoma> ++
05:32:34 <Myoma> that whole bit
05:32:48 <kowey> oh, you can imagine that being just a very dark line
05:33:12 <Myoma> why is that line dark and none of the others?
05:33:47 <kowey> because you want to show that the mem tests belong in some group, as do the time tests
05:33:56 <Myoma> ah I see
05:35:32 <Toxaris> http://hpaste.org/9864#a1
05:35:50 <Toxaris> kowey: ^^^^^ my proposal
05:36:26 <kowey> Toxaris: interesting... i'd never thought to represent something 'outside' of the cells themselves
05:36:38 <ivanm> http://hpaste.org/9864#a2 <-- my proposal
05:37:31 <ivanm> Toxaris: for yours, I suggest replaceing "Header Header" with [Header] maybe, in case you want more than one split...
05:37:43 <bos> i wish people would stop writing monad tutorials and get going on writing interesting programs instead.
05:37:49 <ivanm> oh, wait, I see what you have... rows and cols...
05:38:01 <Toxaris> ivanm: hmm n-dimensional tables?
05:38:07 <ivanm> Toxaris: actually, yours is rather neat
05:38:24 <Myoma> kowey, My proposal http://hpaste.org/9864#a3
05:38:26 <ivanm> I thought you were splitting up the columns there... didn't read it carefully enough
05:38:28 <Myoma> :))
05:39:15 <ivanm> Myoma: yours isn't too scaleable though :p
05:39:19 * ivanm votes for Toxaris'
05:39:28 <Myoma> of course it's scaleable, whatever that means
05:39:51 <ivanm> s/scaleable/generic/
05:39:55 <ivanm> or polymorphic :p
05:39:58 <Myoma> what can't you do with it?
05:40:54 <ivanm> if you want a generic table type, for which you might want to have more than 2 sections...
05:41:05 <kowey> thanks, everyone
05:41:07 <ivanm> e.g. MemTest, TimeTest, StorageTest, etc.
05:41:19 <Myoma> ivanm: Yes you can do that
05:41:20 <kowey> I think I'll try the Toxaris approach as it does promise a certain flexibility
05:41:34 <ivanm> Myoma: but then you have to re-write your data types
05:41:49 <Myoma> of course
05:42:03 <ivanm> so it's not a generic Table type
05:42:05 <kowey> hmm... maybe I should revisit GUI layout combinators like wxhaskell offers
05:42:06 <Myoma> yes it is
05:42:25 <Myoma> you could still load a table from a file and use arbirtrary column/row names
05:55:16 <Toxaris> kowey: some ideas for interesting combinators: http://hpaste.org/9864#a4
05:55:38 <Toxaris> with bad names :(
05:55:59 <Myoma> > let (<-->) = (+) in 3 <--> 9
05:56:00 <lambdabot>  12
05:56:21 <kowey> there is also http://hackage.haskell.org/packages/archive/html/1.0.1.1/doc/html/Text-Html-BlockTable.html
05:56:27 <lambdabot> Title: Text.Html.BlockTable, http://tinyurl.com/5memql
05:56:55 <kowey> this could become a useful little library... maybe with a stock renderHTML and renderLaTeX function
05:59:38 <kowey> also, in the back of my mind, sooner or later, I'm going to want for a cell to say something like "highlight me"
05:59:45 <kowey> but I don't think I should worry about that for now
06:03:32 <Toxaris> data Table a = Cell a | Beside (Table a) (Table a) | Above (Table a) (Table a) | Highlight Color (Table a)
06:04:00 <Toxaris> this or something similiar should allow rectangular subtables in the middle of a table
06:04:24 <Toxaris> but it would all be so much cooler with static guarantuees about the column / row count
06:04:45 <EvilTerran> Toxaris, well, that's not *too* hard to enforce statically
06:04:50 * kowey nods
06:04:57 <EvilTerran> particularly with GADTs
06:05:12 <Toxaris> EvilTerran: I would try with polymorphic recursion on the type level
06:05:25 <kowey> hehe, the Haskellers' take on a kind of problem typically solved with stupid little Perl scripts
06:05:59 <Toxaris> kowey: you *can* solve it with stupid little Haskell scripts, using concat and show and maybe zipWith
06:06:10 <kowey> oh, yeah that's what I had been doing
06:06:29 <Myoma> llo GADTs
06:06:54 <Myoma> obviously, you need full dependent typing and curry howard to solve this!
06:07:13 <Toxaris> I don't think you need any dependent typing
06:07:27 * Myoma jokes .
06:07:32 <EvilTerran> data Zero; data Succ a; data Table w h a where Cell :: a -> Table (Succ Zero) (Succ Zero) a; Beside :: Add w1 w2 w1w2 => Table w1 h a -> Table w2 h a -> Table w1w2 h a; ...
06:07:44 <EvilTerran> with a suitable definition of the Add typeclass
06:08:01 <EvilTerran> or you could do it with type families instead of that typeclass
06:13:26 <FordCortina> @src min
06:13:26 <lambdabot> min x y = if x <= y then x else y
06:13:35 <Myoma> EvilTerran: here's another neat way to do that,  type Table = [(Cell,(Cell,(Cell,(Cell,() ))))]
06:13:58 <EvilTerran> Myoma, er, what?
06:14:01 <Myoma> EvilTerran: I'm not sure which would be easier to write programs with though
06:14:11 <Myoma> EvilTerran: enforce the length is the same for each row
06:14:37 <EvilTerran> Myoma, either way you'd need typeclass magic to do stuff like Beside
06:14:47 <Myoma> what's beside?
06:15:00 <Myoma> join two tables? why not use (++)
06:15:05 <EvilTerran> ... because types?
06:15:48 <Myoma> :t (?x :: [(Int,(Int,(Int,(Int,() ))))]) ++ (?y :: [(Int,(Int,(Int,(Int,() ))))])
06:15:49 <lambdabot> (?x::[(Int, (Int, (Int, (Int, ()))))], ?y::[(Int, (Int, (Int, (Int, ()))))]) => [(Int, (Int, (Int, (Int, ()))))]
06:15:54 <Myoma> looks to work fine
06:15:59 <EvilTerran> as in, i want some kind of function that takes two tables - with the same height, enforced statically - and joins them row-by-row
06:16:10 <Myoma> there it is
06:16:19 <EvilTerran> i also want to be able to do the same for joining two tables one-above-tother
06:16:32 <EvilTerran> complete with static enforcement of width
06:16:32 <Beelsebob> EvilTerran: enforcing the height condition statically will require more than a bit of type system fun
06:16:41 <Beelsebob> and may in the end require dependant types
06:16:58 <EvilTerran> Beelsebob, eh, it only needs a couple of phantom types, a GADT, and a typeclass or two
06:17:32 <tusho> EvilTerran:
06:17:32 <tusho> Beelsebob, eh, it only needs a couple of phantom types, a GADT, and a typeclass or two
06:17:34 <tusho> only :P
06:18:14 <EvilTerran> Myoma, do you mean, in that type, that the table is always four wide, or four high?
06:18:26 <EvilTerran> Myoma, also, why not use (Int,Int,Int,Int)?
06:18:32 <Myoma> EvilTerran: which ever is more convenient
06:18:52 <Myoma> you can't do recursion on that type
06:19:02 <EvilTerran> you can't do recursion on your type without typeclass magic, either
06:19:23 <Myoma> nothing wrong with some magic :)
06:20:06 <EvilTerran> i guess they come to pretty much the same thing, then, if we're both doing typeclass magic
06:20:33 <Beelsebob> EvilTerran: (Int,Int,Int,Int) has a whole load of annoying properties in a curried world -- using pairs stops you having to write myFunc2, myFunc3, myFunc4 etc
06:20:53 <EvilTerran> Beelsebob, i understand that, it just seemed odd to use it here
06:20:58 <Beelsebob> (while adding a few bottoms)
06:21:17 <Beelsebob> I never understood why tuples *aren't* pairs of pairs of pairs etc in Haskell
06:21:29 <EvilTerran> was it discussed in the design process?
06:21:37 <Beelsebob> I don't know
06:21:45 <ivanm> someone said the other day because of bottom...
06:21:46 <Beelsebob> the idea of using pairs everywhere seems to have disapeared in ML
06:21:46 <EvilTerran> it's possible no-one thought of it, i guess
06:21:57 <Beelsebob> ivanm: yeh, it does introduce more bottoms
06:22:15 <Beelsebob> in that (5,_|_) is not a value in the type (a,b,c)
06:22:17 <EvilTerran> i think the thing to do would be to have a constructor that was strict in its second field
06:22:29 <EvilTerran> data a :& b = a :& !b
06:22:38 <Myoma> @hoogle p -> q -> pq -> ([p] -> [q] -> [pq])
06:22:39 <lambdabot> Data.List zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
06:22:39 <lambdabot> Text.ParserCombinators.Parsec.Error showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
06:22:39 <lambdabot> Data.List zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
06:22:40 <EvilTerran> type (a,b) = a :& (b :& ())
06:22:44 <EvilTerran> etc
06:22:46 <Beelsebob> EvilTerran: indeed
06:22:52 <Beelsebob> so you could annotate the strictness if you wanted it
06:22:56 <tusho> Beelsebob:
06:22:57 <tusho> I never understood why tuples *aren't* pairs of pairs of pairs etc in Haskell
06:23:02 <Myoma> EvilTerran,
06:23:03 <Myoma> class Append p q pq | p q -> pq where append :: p -> q -> pq
06:23:03 <tusho> cuz then it's just a list.
06:23:03 <Myoma> instance Append () y y where append _ y = y
06:23:03 <Myoma> instance Append es y esy => Append (e , es) y (e , esy) where append (x,xs) y = (x,append xs y)
06:23:06 <EvilTerran> tusho, could you fix your formatting there?
06:23:09 <Myoma> beside = zipWith append
06:23:10 <Beelsebob> tusho: no it isn't
06:23:12 <EvilTerran> Myoma, i know how to do that
06:23:14 <tusho> EvilTerran: Wut?
06:23:18 <Beelsebob> (a,(b,c)) is not a list
06:23:26 <Beelsebob> for one, it's hetrogenious
06:23:28 <tusho> Beelsebob: Oh, true
06:23:36 <EvilTerran> tusho, "Beelsebob:" appeared on a separate line to " I never understood why tuples *aren't* pairs of pairs of pairs etc in Haskell"
06:23:43 <Beelsebob> there's a special case of pairs with a recursive type which is a list
06:23:46 <Myoma> EvilTerran, You said you had to use a bunch of GADTs and phantom types
06:23:49 <tusho> EvilTerran: Yeah, that's how colloquy is copying it. "Go figure"
06:23:52 <Myoma> EvilTerran, I wanted to show that is not required
06:23:56 <tusho> EvilTerran: Anyway, I wasn't addressing Beelsebob, per se.
06:23:56 <Myoma> EvilTerran, i.e. this way is simpler
06:24:03 <tusho> I was just copying his line, to provide context. For my next line.
06:24:05 <Beelsebob> wow, poor EvilTerran
06:24:08 <Beelsebob> that's a lot to take in
06:24:11 <EvilTerran> tusho, well, the convention seems to be that you say "Person:" to address someone and <Person> to quote them
06:24:13 <Myoma> ontup = (++) ; beside = zipWith append
06:24:14 <EvilTerran> btw
06:24:22 <Myoma> compared to ?
06:24:27 <tusho> EvilTerran: If you can make colloquy do that then sure :)
06:24:27 <Saizan_> Myoma: it's not so simpler, also you're cghecking only one dimension
06:24:28 <Beelsebob> Myoma: yeh, but it doesn't guarentee sizes
06:24:39 <EvilTerran> tusho, you could always fix it manually before you hit enter
06:24:45 <Myoma> Saizan_: that's exactly what it should do
06:24:52 <EvilTerran> Myoma, i said you had to for my version
06:25:04 <tusho> EvilTerran: True, but it takes me long enough to copy it without the selection selecting all the following messages (go figure again) in the first place.
06:25:14 <EvilTerran> Myoma, sure, there's other ways, but i prefer mine :P
06:25:17 <Myoma> with mine you can join,
06:25:17 <Myoma> o o x x x
06:25:17 <Myoma> o o x x x
06:25:25 <Beelsebob> tusho: nothing weird happened in colloquy for me
06:25:25 <Myoma> they have different sizes, but that's fine
06:25:32 <Beelsebob> you might be using an odd style
06:25:35 <Myoma> EvilTerran: Can you show me it?
06:25:42 <tusho> Beelsebob: "Bland" isn't very odd.
06:25:47 <EvilTerran> Myoma, i outlined it earlier
06:25:56 <Beelsebob> tusho: *shrug*
06:25:58 <Myoma> you did not fill in the details :p
06:26:10 <Beelsebob> works in Standard
06:26:16 * EvilTerran shrugs
06:26:26 <EvilTerran> there are many slightly different ways you could fill in the details
06:26:53 <EvilTerran> whatever you do, you need a bit of typeclass magic, i believe
06:27:17 <Myoma> you say that like it's a bad thing ..
06:27:34 <EvilTerran> but i think you can make a system that's nicer to use with some extensions
06:27:45 <EvilTerran> that's a matter of opinion, of course
06:28:28 <Myoma> one could use Vec n (a, (a, ..., ())) if they wanted to write transpose
06:28:34 <Myoma> rather than the list of tuples
06:29:04 <EvilTerran> ... or why not Vec w (Vec h a) ?
06:29:39 <Myoma> sure, on the same contiuum is  ((a, (a, ..., ())), (... ((a, (a, ..., ())), ())))
06:29:42 <EvilTerran> i thought we were primarily discussing what would make a good implementation of Vec, anyway
06:30:25 <Saizan_> with data Vec n a where VNil :: Vec Zero a, VCons :: a -> Vec n a -> Vec (Succ n) a, so you can write some recursive functions *without* having to write all the cases as distinct instances of a typeclass
06:30:48 <EvilTerran> Saizan_, i thought as much, although the details escape me for the moment
06:31:00 <Myoma> yes map and so on
06:31:26 <EvilTerran> that's what i meant by using a GADT making a nicer system to work with
06:31:29 <Myoma> you can't do map on the tuple thing without classes can you?
06:31:59 <Myoma> there's no way it'll typecheck
06:32:38 <EvilTerran> indeed
06:32:53 <EvilTerran> you need a class to distinguish between the () and the (x,xs) case
06:33:47 <EvilTerran> that's the advantage of the GADT - the types of VNil and (VCons x xs) are related in the type system without having to include them both in a class
06:34:59 <sioraiocht> dcoutts_: ping?
06:35:04 <sioraiocht> @seen dcoutts
06:35:05 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I don't know when dcoutts last spoke.
06:35:05 <dcoutts_> sioraiocht: pong
06:35:23 <dcoutts_> lambdabot: you don't know when anyone last spoke :-(
06:35:29 <dcoutts_> @seen sioraiocht
06:35:29 <lambdabot> sioraiocht is in #haskell.es, #haskell.de, #haskell and #haskell-blah. I last heard sioraiocht speak 25s ago.
06:35:35 <dcoutts_> oh, hmm
06:36:47 <Myoma> Actually I don't know if it's even possible at all
06:36:55 <Myoma> How do you write map on tuple lists
06:38:20 <Myoma> class Map p q | p -> q where tmap :: (a -> b) -> p -> q
06:38:20 <Myoma> instance Map () () where tmap f () = ()
06:38:20 <Myoma> instance Map ps qs => Map (p,ps) (q,qs) where tmap f (x,xs) = (f x, tmap f xs)
06:38:22 <Myoma> is rejected
06:38:55 <tibbe> good day all
06:40:26 <Myoma> hi tibbe,
06:40:33 <Myoma> for comparsion
06:40:34 <Myoma> vmap :: (a -> b) -> Vec n a -> Vec n b
06:40:34 <Myoma> vmap f VNil = VNil
06:40:34 <Myoma> vmap f (VCons x xs) = VCons (f x) (vmap f xs)
06:40:34 <Myoma> class Map u v tu tv where tmap :: (u -> v) -> tu -> tv
06:40:34 <Myoma> instance Map u v () () where tmap f () = ()
06:40:36 <Myoma> instance Map u v us vs => Map u v (u,us) (v,vs) where tmap f (x,xs) = (f x, tmap f xs)
06:40:48 <Myoma> vector wins here
06:41:23 <EvilTerran> Myoma, why is that first one rejected?
06:41:41 <Myoma> I think that it doesn't know f has the right type to turn ps into qs
06:41:54 <EvilTerran> ah, i see - i think you need more typeclass parametersa
06:42:12 <Myoma> so I brought in the types of y and thread them along the whole thing, but the VCons case gives you it automatically
06:42:19 <Myoma> of f*
06:42:41 <Saizan_> because f is not of type p -> q, but a -> b
06:42:47 <EvilTerran> class TMap a b as bs | as -> a, bs -> b where tmap :: (a -> b) -> as -> bs
06:43:05 <EvilTerran> instance TMap a b () () where tmap f () = ()
06:43:34 <EvilTerran> instance TMap a b as bs => TMap a b (a,as) (b,bs) where tmap f (a,as) = (f a, tmap f as)
06:44:13 <EvilTerran> you could potentially add more fundeps, i think, but they might not be necessary
06:44:25 <Saizan_> those fundeps don't hold for the () case
06:44:35 <EvilTerran> Saizan_, good point
06:44:56 <sampointon> @pl \f g a -> f . (g a)
06:44:56 <lambdabot> (.) . (.)
06:45:24 <SamB_XP_> lament: hmm, I'm a bit confused by this Prelude wikipage (about the esolang Prelude -- nothing to do with Haskell!)
06:45:26 <EvilTerran> "a b as -> bs, a b bs -> as" might work
06:46:33 <Myoma> aww
06:46:47 <Myoma> I've got stuck trying to define class VisoT e v t where fromV :: v -> t; fromT :: t -> v
06:47:01 <Myoma> is that possible?
06:47:17 <SamB_XP_> lament: does each voice occupy a LINE of text, or a column ?
06:49:39 <bizhat_user131> hello
06:51:55 <Myoma> It's possible if you split into two, and add some dependency
06:52:30 * Myoma wonders if it could be done in one class
06:54:52 <tibbe> dcoutts: how's your thesis coming along? :)
06:55:02 <dcoutts_> tibbe: ok thanks
06:55:23 <tibbe> dcoutts_: mostly writing left or still doing the research?
06:55:29 <dcoutts_> tibbe: just writing
06:55:34 <tibbe> ok
06:56:27 <SamB_XP_> Myoma: what is the "e" for?
06:56:45 <Myoma> that's the type of elements
06:57:09 <SamB_XP_> why isn't it involved in the types of fromV and fromT?
06:57:26 <Myoma> it is, you just don't see it
06:57:57 <Myoma> you might have, fromV :: Vector (Succ (Succ (Succ Zero))) e -> (e, (e, (e, ())))
07:01:05 <Saizan_> Myoma: that means 'e' should not be a parameter of the class because you can express it via the other parameters, and if you don't have a fundep like v -> e or t -> e you can't use fromV/fromT
07:01:33 <chr1s> anyone familiar with type synonym families?
07:04:03 <chr1s> I'm having this weird error of which I think it shouldn't be an error
07:04:04 <chr1s> http://hpaste.org/9866
07:04:35 <Myoma> Saizan: I had to add a fundep with e in it to get it to work (but that is in two classes not one)
07:05:06 <chr1s> or is there anyone with GHC 6.8.9 who can try this?
07:05:18 <chr1s> err... that should read GHC 6.9
07:06:02 <Saizan_> chr1s: you didn't paste the error
07:06:36 <Myoma> why don't you change insert = insert' to insert = undefined ?
07:08:18 <chr1s> Saizan_: thanks, I added it.
07:09:01 <trofi> :t intersperse
07:09:03 <lambdabot> forall a. a -> [a] -> [a]
07:09:32 <trofi> > intersperse '.' $ map show [1..5]
07:09:34 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
07:09:48 <EvilTerran> > intercalate '.' $ map show [1..5]
07:09:49 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
07:09:51 <Myoma> :t map show [1..5]
07:09:52 <lambdabot> [String]
07:09:55 <EvilTerran> > intercalate "." $ map show [1..5]
07:09:57 <lambdabot>  "1.2.3.4.5"
07:10:06 <EvilTerran> ?src intercalate
07:10:07 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:10:20 <trofi> thanks! :]
07:10:50 <trofi> @index intercalate
07:10:51 <lambdabot> bzzt
07:11:10 <trofi> @hoogle intercalate
07:11:11 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
07:11:11 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:11:11 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
07:21:57 <Botje> @tell ndm searching hoogle for "data.map" gives no results, whereas "Data.Map" gives the data.map haddock as first hit
07:21:57 <lambdabot> Consider it noted.
07:28:21 <dzlk> dict.org intersperse
07:29:01 <dzlk> oops.
07:31:31 <EvilTerran> @wn intersperse
07:31:32 <rrrggghhh> > cos cos cos 5
07:31:33 <lambdabot>      No instance for (Floating ((a -> a) -> a -> a))
07:31:33 <lambdabot>       arising from a use...
07:31:34 <lambdabot> *** "intersperse" wn "WordNet (r) 2.0"
07:31:34 <lambdabot> intersperse
07:31:34 <lambdabot>      v 1: place at intervals in or among; "intersperse exclamation
07:31:35 <lambdabot>           marks ina the text"
07:31:37 <lambdabot>      2: introduce one's writing or speech with certain expressions
07:31:39 <lambdabot>         [syn: {interlard}]
07:31:49 <EvilTerran> @wn intercalate
07:31:50 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
07:31:50 <lambdabot> intercalate
07:31:50 <lambdabot>      v : insert (days) in a calendar
07:31:54 <rrrggghhh> cos(cos(cos(cos(cos(5)))))
07:31:58 <rrrggghhh> > cos(cos(cos(cos(cos(5)))))
07:31:59 <lambdabot>  0.6674533830038623
07:32:02 <sampointon> hey, was wn changed? That's a lot more useful than it was yesterday
07:32:09 <EvilTerran> > iterate cos 5
07:32:10 <lambdabot>  [5.0,0.28366218546322625,0.9600369302946615,0.5734897326953653,0.84001268095...
07:32:19 <MyCatVerbs> > (iterate cos 5) !! 10
07:32:20 <lambdabot>  0.748720383642674
07:32:41 <EvilTerran> sampointon, i think it'll vary depending on the word you're looking up
07:33:15 <EvilTerran> inevitably, some words will have better entries than others
07:33:21 <rrrggghhh> how do you do cos(sin(cos(sin(....
07:33:24 <sampointon> no, I think it was intercalate yesterday
07:33:36 <sampointon> rrrggghhh: iterate (cos . sin)
07:33:41 <rrrggghhh> <3
07:33:54 <sampointon> EvilTerran: we got a 10-line or so Latin etymology
07:33:55 <twanvl> > let fixedPoint f x | x == fx = x | otherwise = fixedPoint f fx where fx = f x  in  fixedPoint cos 5
07:33:56 <lambdabot>  0.7390851332151607
07:34:02 <rrrggghhh> > (iterate cos . sin 5) !! 123
07:34:03 <lambdabot>  Couldn't match expected type `[a]'
07:34:04 <sampointon> good for philologists, less for chatbots
07:34:17 <TomMD> > iterate (cos . sin) 123
07:34:18 <lambdabot>  [123.0,0.8960953384781817,0.7102846856310514,0.7948417133742357,0.7559103723...
07:34:38 <rrrggghhh> > iterate (cos . sin) 123 !! 125
07:34:39 <lambdabot>  0.768169156736796
07:34:59 <rrrggghhh> i wish it didn't trail off after 5 items
07:35:02 <TomMD> > (iterate (cos . sin) 5) !! 123
07:35:03 <lambdabot>  0.768169156736796
07:35:16 <EvilTerran> rrrggghhh, then do it in ghci
07:35:37 <TomMD> And that will make you wish it did.
07:35:37 <EvilTerran> or even "mapM_ print $ iterate f 5"
07:35:42 <twanvl> > fixedPoint (cos . sin) 5
07:35:43 <lambdabot>  0.768169156736796
07:35:46 <ski> @wn intercalate
07:35:47 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
07:35:47 <lambdabot> intercalate
07:35:47 <lambdabot>      v : insert (days) in a calendar
07:35:56 <TomMD> @src fixedPoint
07:35:56 <lambdabot> Source not found. Do you think like you type?
07:36:04 <Myoma> @w80 intercalate
07:36:05 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
07:36:05 <lambdabot> intercalate
07:36:05 <lambdabot>      v : insert (days) in a calendar
07:36:10 <Myoma> :/
07:36:15 <Myoma> it used to have an option for @more
07:36:16 <EvilTerran> @list wn
07:36:16 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
07:36:29 <ski> TomMD : twanvl defined `fixedPoint' just above
07:36:30 <dzlk> Webster's 1913 has the etymology.
07:36:38 <sampointon> @dict intercalate
07:36:38 <lambdabot> Supported dictionary-lookup commands:
07:36:38 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
07:36:38 <lambdabot> Use "dict-help [cmd...]" for more.
07:36:40 <dzlk> @web1913 intercalate
07:36:40 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
07:36:41 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
07:36:41 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
07:36:42 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
07:36:44 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
07:36:46 <lambdabot> [10 @more lines]
07:37:02 <ski> @less
07:37:02 <lambdabot> Maybe you meant: let list oeis
07:37:03 <EvilTerran> i guess it only offers @more when there's actually more to show
07:37:18 <Myoma> @wet wet wet
07:37:19 <lambdabot>  Parse error
07:56:46 <FordCortina> are all types inhabited in haskell, or is it just those types for which values other than "bottom" exist?
07:57:19 <Myoma> :t undefined
07:57:19 <Botje> data Foo -- can only have undefined(_|_) as value
07:57:20 <lambdabot> forall a. a
07:58:25 <FordCortina> in other words do people say that "data Foo" is "inhabited"?
07:58:34 <trofi> @src unionBy
07:58:34 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
07:58:40 <FordCortina> or does it depend on the defintion of inhabited?
07:58:44 <MyCatVerbs> FordCortina: data Foo is uninhabited, because you can't make a non-bottom value.
07:58:52 <trofi> > union [1..5] ++ [7..1]
07:58:52 <Myoma> FordCortina: depends on if they include undefined or talk about a terminating subset of haskell
07:58:53 <lambdabot>  Couldn't match expected type `[a]'
07:58:59 <trofi> > union $ [1..5] ++ [7..1]
07:59:00 <lambdabot>      Overlapping instances for Show ([a] -> [a])
07:59:00 <lambdabot>       arising from a use of ...
07:59:09 <jpcooper> could anyone direct me to anything related to making a prolog implementation in haskell?
07:59:28 <trofi> > union [] $ [1..5] ++ [7..1]
07:59:29 <lambdabot>  [1,2,3,4,5]
07:59:34 <trofi> > union [] $ [1..5] ++ [7,6..1]
07:59:34 <jpcooper> specifically, I'm wondering how I should represent free variables
07:59:35 <lambdabot>  [1,2,3,4,5,7,6]
07:59:57 <ski> jpcooper : free variables ?
08:00:02 <MyCatVerbs> FordCortina: this is one of Haskell's weaknesses - types being inhabited or uninhabited takes more than a little subtlety to define correctly.
08:00:25 <Myoma> jpcooper: http://rascal-haskell.googlecode.com/svn/trunk/Infer.hs & Typecheck.hs is one way
08:00:31 <jpcooper> ski, I'd like to say things such as siblings X Y :- parent A X, parent A Y
08:00:54 <ski> jpcooper : in prolog, `X',`Y',`A' would be bound variables in that clause
08:00:58 <jpcooper> what I'd really like is a few hints so I could go about doing this myself
08:01:05 <FordCortina> MyCatVerbs: Myoma: right thanks
08:01:13 <Myoma> jpcooper: check the code I linked for some ideas
08:01:24 <jpcooper> thanks
08:03:04 <ski> (jpcooper : fyi, there's also #prolog)
08:05:03 <MyCatVerbs> FordCortina: in fact, it's often preferrable to use ML instead, so that you don't have to worry about bottoms.
08:05:43 <MyCatVerbs> FordCortina: I mean, do your reasoning as if you're working in ML, then it'll work fine in Haskell.
08:05:51 <FordCortina> ic
08:06:10 <Myoma> MyCatVerbs: What reasoning?
08:09:10 <MyCatVerbs> Myoma: Howard-Curry correspondence.
08:09:12 <ddarius> jpcooper: Read "Typed Logic Variables in Haskell"
08:09:30 <T55555> hello
08:09:58 <jpcooper> thanks ddarius
08:10:06 <shapr> @seen dons
08:10:06 <lambdabot> I saw dons leaving #darcs, #arch-haskell, #ghc, #xmonad and #haskell 3h 46m 55s ago, and .
08:10:45 <MyCatVerbs> Myoma: a type is inhabited iff the logic theorem that the type denotes is true. It's more, ah, strictly useful in a strict language than a lazy one. Consider that in Haskell, fix :: (a -> a) -> a, and id :: a -> a, which means you can write (fix id) :: a, which says that *all* theorems are true, which is silly. Etc.
08:12:15 <opqdonut> MyCatVerbs: err, laziness isn't the point
08:12:45 <opqdonut> the point is that the type system is too powerful, recursive datatypes allow you to inhabit every type
08:12:47 <T55555> when study Haskell, I have this question in my mind: People said Haskell is higher level programming language, you don't care about the low level detail, you explain your problem on higher level functional... but when read the book, there is many time they talk about use this way have better performance then that way... Why should I care about that, why not the "high" level programming language take care of this.
08:12:50 <opqdonut> (by constructing fix)
08:13:07 <MyCatVerbs> opqdonut: ML doens't allow you to construct fix though, does it?
08:13:13 <T55555> worry performance seems low level detail for me.
08:13:15 <Beelsebob> T55555: good question -- my answer is "don't care about it"
08:13:19 <ddarius> MyCatVerbs: Sure it does.  It's just -completely- useless in ML.
08:13:22 <Saizan_> MyCatVerbs: doesn't ML have general recursion?
08:13:28 <Beelsebob> I very rarely find performance to be a problem, even if I start by not-caring
08:13:36 <opqdonut> T55555: yeah, mostly you don't need to think about performance
08:13:36 <MyCatVerbs> ddarius, Saizan_: ah, I see. Of course.
08:13:41 <sampointon> T55555: the compiler tries very hard to optimise your program
08:14:12 <sampointon> T55555: but occasionally there's a trick or two that can't be automatically applied, that makes all the difference
08:14:24 <MyCatVerbs> ddarius, Saizan_: so what type systems *can* you not write fix in?
08:14:36 <T55555> ya.  but simply reverse fonction using ++ is terrible performance and compiler cannot help...
08:14:44 <opqdonut> MyCatVerbs: simply-typed lambda calculus
08:14:50 <opqdonut> nonhalting computation doesn't type
08:14:58 <MyCatVerbs> opqdonut: ah, I see.
08:15:15 <Saizan_> all of lambda-cube i think
08:15:18 <MyCatVerbs> opqdonut: and Howard-Curry refers to STLC rather than H-M?
08:15:28 <opqdonut> yeah
08:15:40 <opqdonut> except C-H extends to other type systems too
08:15:41 <mmorrow> T55555: ...
08:15:43 <mmorrow> > head (foldr (++) [] (replicate 1000000 [0..9]))
08:15:44 <lambdabot>  0
08:15:47 <ddarius> MyCatVerbs: First, usuall Curry-Howard is used, and yes technically the Curry-Howard correspondence is only talking about the simply typed lambda calculus.
08:15:52 <mmorrow> > head (foldl (++) [] (replicate 1000000 [0..9]))
08:15:53 <lambdabot>  mueval: *** Exception: stack overflow
08:16:10 <FordCortina> has anybody managed to write (Min n m) for natural numbers using type families?
08:16:11 <MyCatVerbs> ddarius: oh, oops.
08:16:55 <MyCatVerbs> ddarius: and yet we use it anyway, even though we have to be really careful not to hit the edge cases where Haskell is more permissive than STLC, then.
08:17:14 <Saizan_> however you can "just" add a termination checker and accept only those proof that have a normal form
08:17:21 <Myoma> FordCortina: got any code doing stuff with family naturals?
08:17:30 <T55555> reverse (x:xs) = reverse xs ++ [x]  is strangeforward for me, and compiler cannot help you with this kind, you have think other way because performance issue...   so I explain my solution in esay way, but due to performance i have to think other way...
08:17:41 <FordCortina> Myoma: I can add naturals together
08:17:50 <FordCortina> if that's what you mean
08:18:13 <Myoma> T55555: you derive the more efficient version in a cold caluclating way from that definition
08:19:09 <mmorrow> > foldl (flip (:)) [] [0..9]
08:19:10 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
08:19:16 <mmorrow> :)
08:19:22 <mmorrow> O(n)
08:19:39 <FordCortina> Myoma: http://hpaste.org/9867
08:19:51 <FordCortina> << what ive got so far
08:22:00 <Myoma> FordCortina: can you compute with these?
08:22:36 <T55555> so you guy still think low level (or may other way) because performance issue. Is this qualify "high" level language ?
08:22:38 <FordCortina> Myoma: type families compute at compile time, the GADTs can computer at runtime, i think
08:22:46 <FordCortina> compute*
08:23:20 <FordCortina> Myoma: i dont see how I can use Less with Min
08:23:36 <mmorrow> T55555: i'd call it thinking in terms of "computational complexity" rather than "low level"
08:24:10 <mmorrow> reverse (x:xs) = reverse xs ++ [x]          is O(n^2)
08:24:22 <Myoma> FordCortina: why does type instance (Min (Suc n) (Suc m)) = Suc (Min n m) not work?
08:24:24 <mmorrow> reverse = foldl (flip (:)) []          is O(n)
08:25:23 <sampointon> T55555: no compiler in the world will fix an inefficient algorithm
08:25:24 <mmorrow> which follows from the fact that   x:xs is O(1)      and    xs++[x]  is O(n)
08:25:57 <pastorn> what do you call the animal on the front of real world haskell?
08:26:14 <FordCortina> Myoma: yeh good point
08:26:15 <Myoma> FordCortina: http://hpaste.org/9867#a1
08:26:19 * pastorn is a swede and don't know that many insect names in english
08:26:25 <T55555> thanks mmorrow & sampointon:  I think I am looking something will never exist... (as you said no compiler will fix ... )
08:26:27 <pastorn> http://www.amazon.co.uk/gp/product/0596514980?ie=UTF8&tag=reaworhas-21&linkCode=as2&camp=1634&creative=6738&creativeASIN=0596514980
08:26:34 <lambdabot> http://tinyurl.com/6ppv6h
08:26:46 <FordCortina> Myoma: thanks
08:26:48 <Myoma> T55555: There -is- an algorethm that does it
08:26:53 <ddarius> pastorn: Insects aren't animals.  But I believe it is a Rhinoceros beetle.
08:27:14 <ski> (some compiler optimizations can sometimes improve asymptotical complexity ..)
08:27:26 <pastorn> ddarius: thanks ;)
08:27:38 <Myoma> FordCortina: This is neat (I didn't know type families could compute)
08:28:05 <FordCortina> :)
08:28:09 <geezusfreeek> insects aren't animals? what are they then?
08:28:12 <luite> it looks like a hercules beetle?
08:28:34 <Myoma> FordCortina: ever tried to hook typeclasses into it?
08:29:02 <ddarius> luite: Seems like we're both right.
08:29:15 <FordCortina> Myoma: how do you mean? I may base some type class instances on types in these families.
08:29:50 <luite> ddarius: same species?
08:30:05 <ddarius> luite: A Hercules beetle is a specific type of Rhinoceros beetle.
08:30:36 <Botje> hercules was a rhinoceros?!
08:30:40 <Botje> history makes sense again!
08:30:58 <luite> ddarius: ah
08:31:37 <Beelsebob> rofl Botje
08:31:52 <FordCortina> Myoma: if you are referring to associated type synonym families, I havent found a use for them yet
08:32:01 <Myoma> No I didn't mean that
08:37:38 <mmorrow> Myoma: oh, you're vicky ?
08:37:43 <Myoma> yes
08:37:46 <mmorrow> heh
08:44:46 * Myoma fails to write vector append with type families
08:49:56 <Myoma> Is this possible to resurrect http://hpaste.org/9867#a2 ?
08:51:10 * gwern personally thinks that the RWH cover is pretty ugly
08:52:07 <jpcooper> gweiqi, maybe you should lock horns with the author
08:52:17 <jpcooper> gwern*
08:52:39 <gwern> the artist, you mean?
08:52:42 <sampointon> gwern: yeah, you should if it bugs you that much
08:52:49 <ddarius> gwern: Are there pretty O'Reilly books?
08:52:51 <Myoma> FordCortina: I'm not just missing something obvious, it's actually impossible?
08:52:52 * gwern has no horns. unlike the cover
08:53:03 <gwern> sampointon: that sort of joke is a real pest
08:53:12 <gwern> buzz off
08:53:26 <jpcooper> I rather enjoy the gravures
08:54:20 <gwern> I like the gravures too, but only when they have some apparent connection
08:54:37 <gwern> I mean, it looks too much like a dung beetle for my taste
08:54:47 <ddarius> What's wrong with dung beetles?
08:55:29 <jpcooper> they have quite functional names
08:56:01 <jpcooper> they definitely collect the garbage
08:57:27 * gwern sighs. why couldn't we've gotten a charismatic mammal on our cover?
08:57:30 <sampointon> how about a tortoise, symbolising strength, safety and staticity?
08:57:37 <gwern> are panthers taken? I like panthers
08:58:04 <jpcooper> gwern, a version of Mac OSX
08:58:22 <gwern> shoot. I'll bet they took tigers too, didn't they?
08:58:28 <gwern> sampointon: and slowness?
08:58:29 * ddarius makes a new language called "Puppy."
08:58:51 <jpcooper> what about the curry plant?
08:59:22 <Myoma> oh
08:59:23 <Myoma> Note that class instances are always for particular instances of a data family and never for an entire family as a whole. This for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of different instances of a single type family. It would require a form of extensible case construct.
08:59:25 <gwern> actually, that'd make sense. is there such a plant?
08:59:28 <Myoma> -- but they didn't say why
09:00:02 <jpcooper> gwern, yes
09:00:22 <gwern> we should've suggested the image ahead of time :(
09:00:24 <jpcooper> though haven't the faces of all O'Reilly books been of animals?
09:00:26 <sampointon> okay, how about some kind of mollusc? They're kind of like typeclasses, too, where the shells are instances
09:00:35 <ddarius> jpcooper: Does the plant look like a charismatic mammal?
09:01:00 <jpcooper> does the beetle?
09:01:06 <jpcooper> HAH
09:01:31 <gwern> I'll take a plant over a bug anyday
09:05:17 <ddarius> We should use a fungus.
09:06:19 * Myoma has discovered a great new use of view patterns
09:06:21 <Myoma> vapp (unsafeCoerce -> ())     ys = unsafeCoerce$ ys
09:06:22 <Myoma> vapp (unsafeCoerce -> (x,xs)) ys = unsafeCoerce$ (x,unsafeCoerce$ vapp xs (unsafeCoerce$ ys))
09:09:45 <EvilTerran> Myoma, um, "great"?
09:09:53 <EvilTerran> Myoma, that's going to go horribly wrong
09:09:58 <Myoma> well it got rid of all the type errors :)
09:10:09 <EvilTerran> unsafeCoerce has that name for a reason
09:10:13 <EvilTerran> ?hoogle unsafeCoerce
09:10:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:10:44 * Myoma considers an unsafeCoerce monad
09:11:06 <EvilTerran> it's only even vaguely when you know that two types are the same, but the compiler can't prove it
09:11:09 <EvilTerran> *even vaguely useful
09:11:14 <EvilTerran> Myoma, that doesn't make sense
09:13:31 <EvilTerran> Myoma, if i remember right, that definition of vapp you gave a minute ago will probably segfault if you actually try to use it
09:13:43 <Myoma> it does
09:14:34 <EvilTerran> or, at best, give completely arbitrary and undefined behaviour
09:15:56 <daf> can any of the XML libraries around parse stuff lazily?
09:16:36 <daf> I've tried HaXml and Text.XML.Light and they all seem to be strict in parsing
09:16:42 <daf> TagSoup works, but is slow
09:18:39 <Saizan_> daf: HaXml has a lazy parser but you've to import the right module, iirc
09:18:49 <daf> oh!
09:22:13 <daf> ah, the version of the docs on york.ac.uk didn't mention Text.XML.HaXml.ParseLazy
09:23:42 <ddarius> You could also use hexpat though it would probably be unpleasant.
09:24:35 <Myoma> cool http://www-etud.iro.umontreal.ca/~guillelj/cps-tf/cps_tf.tgz
09:24:54 <Myoma> I didn't think that code was online
09:25:14 <hackage> Uploaded to hackage: thrist 0.0
09:25:14 <hackage> Uploaded to hackage: open-witness 0.1.1
09:25:14 <hackage> Uploaded to hackage: formlets 0.4.5
09:25:15 <hackage> Uploaded to hackage: formlets 0.4.4
09:25:17 <hackage> Uploaded to hackage: data-accessor-template 0.1.3
09:25:33 <daf> ddarius: well, my tagsoup code is somewhat less than ideal :)
09:27:04 <blbrown> what is the 'nth' function for haskell against a list.
09:27:09 <Myoma> !!
09:27:19 <blbrown> knew that..hehe
09:27:41 <sampointon> @hoogle Int -> [a] -> a
09:27:41 <lambdabot> Prelude !! :: [a] -> Int -> a
09:27:41 <lambdabot> Data.List !! :: [a] -> Int -> a
09:27:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:28:09 <ddarius> @hoogle a -> ma
09:28:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:28:10 <lambdabot> Prelude $ :: (a -> b) -> a -> b
09:28:10 <lambdabot> Prelude $! :: (a -> b) -> a -> b
09:28:13 <ddarius> @hoogle a -> m a
09:28:13 <lambdabot> Prelude return :: Monad m => a -> m a
09:28:13 <lambdabot> Control.Monad return :: Monad m => a -> m a
09:28:13 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
09:30:51 <fraktalek> hey
09:31:32 <mmorrow> Myoma: nice find (http://www-etud.iro.umontreal.ca/~guillelj/cps-tf/cps_tf.tgz)
09:31:40 <fraktalek> can someone hint me how to import state monad? "import Control.Monad.State" refuses to work
09:31:51 <Myoma> mmorrow; there's a nice paper about it but it sucked reading it with no code
09:32:04 <Myoma> fraktalek: :m + Control.Monad.State
09:32:15 <mmorrow> Myoma: yeah, i have that paper saved on my desktop since you linked me to it last time :)
09:32:36 <mmorrow> fraktalek: what's the error msg?
09:32:58 <fraktalek> Could not find module `Control.Monad.State'
09:33:07 <fraktalek> slightly different, when I load a file
09:33:17 <fraktalek> this is what ghci outputs
09:33:43 <mmorrow> shoot
09:34:11 <mmorrow> oh, that was the end heh
09:34:16 <mmorrow> hmm, i dunno
09:34:28 <mmorrow> where did you get that ghc from?
09:34:46 <fraktalek> ubuntu...if that question is to me
09:34:50 <mmorrow> yeah
09:35:03 <fraktalek> I thought that it might be a problem with the installation..
09:35:06 <mmorrow> i'm not sure what could be causing that
09:35:19 <mmorrow> in ghci do ...
09:35:27 <mmorrow> :m + Control.Monad.
09:35:33 <mmorrow> and then hit tab a few times
09:35:41 <mmorrow> what shows up?
09:35:58 <fraktalek> Control.Monad.Fix        Control.Monad.Instances  Control.Monad.ST         Control.Monad.ST.Lazy    Control.Monad.ST.Strict
09:36:15 <fraktalek> and that's all
09:36:16 <mmorrow> oh, ok. looks like you dont have the mtl package
09:36:35 * mmorrow looks for a link to the one you want
09:37:33 <fraktalek> thanks, I'm trying to install it
09:37:44 <mmorrow> fraktalek: actually, before you get it from elsewhere, check apt to see if there is a ghc-extras package or something
09:38:16 <trofi> @index groupBy
09:38:16 <lambdabot> Data.List
09:38:20 <trofi> @index partition
09:38:20 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
09:39:23 <mmorrow> fraktalek: if not, you may want to get http://haskell.org/ghc/dist/6.8.3/ghc-6.8.3-src-extralibs.tar.bz2
09:40:42 <mmorrow> (or the corresponding ghc extralibs for your ghc -V)
09:41:12 <jnaimard> libghc6-mtl-dev  it is on debian
09:41:19 <fraktalek> morrow: thanks, it worked :)
09:41:28 <fraktalek> yeah, I installed libghc6-mtl-dev
09:41:47 <mmorrow> awesome
09:42:01 <mmorrow> you're probably missing all the extra packages too
09:42:06 <fraktalek> I just wonder where should I look for this kind of information next time
09:42:10 <fraktalek> hmm...probably
09:42:22 <mmorrow> if i was you and on fedora, i'd do
09:42:30 <mmorrow> sudo yum install -y *ghc* *haskell*
09:42:31 <mmorrow> :)
09:42:44 <TomMD> sudo yum install haskell-platform  -- someday!
09:42:57 <mmorrow> hopefully soooon
09:42:58 <fraktalek> :) I guess I'll do something like that...
09:43:14 <mmorrow> nice
09:47:13 <matthew-_> ok, I'm confused. Ptr is not garbage collected by ForeignPtr is (or at least can be). So are there any reasons to use Ptr over ForeignPtr?
09:47:41 <ski> Myoma : which paper ?
09:48:33 <mmorrow> matthew-_: it seems to me when you want to explicitly free it and not rely on gc
09:49:12 <dsrogers> @src scanr
09:49:13 <lambdabot> scanr _ q0 []     =  [q0]
09:49:13 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
09:49:13 <lambdabot>     where qs@(q:_) = scanr f q0 xs
09:49:21 <dsrogers> thank you lambda bot!
09:49:39 <ski> @botsnack
09:49:40 <lambdabot> :)
09:50:39 <matthew-_> mmorrow: right, so that could allow you to free slightly earlier, but that's about all. And you risk memory leaks
09:50:53 <mmorrow> ski: the most recent one here http://www-etud.iro.umontreal.ca/~guillelj/
09:50:53 <lambdabot> Title: Louis-Julien Guillemette
09:51:02 <Myoma> ski, http://www-etud.iro.umontreal.ca/~guillelj/icfp08.pdf
09:51:03 <lambdabot> Title: A Type-Preserving Compiler in Haskell
09:51:18 <ski> ty
09:51:32 <mmorrow> matthew-_: how do you risk memory leaks? (other than by simply forgetting to free it)
09:51:33 <dsrogers> so ... scanl is like foldl but it stores each intermediate result?
09:51:50 <matthew-_> mmorrow: yup, that's the one ;)
09:51:55 <ski> s/stores/returns/
09:52:02 <mmorrow> matthew-_: hehe
09:52:29 <ski> > scanr (*) 1 [1..5]
09:52:30 <lambdabot>  [120,120,60,20,5,1]
09:52:35 <ski> > scanr (*) 1 [5,4..1]
09:52:36 <lambdabot>  [120,24,6,2,1,1]
09:52:49 <scook0> I believe Ptr is what you end up having to pass to foreign functions anyway
09:53:13 <matthew-_> scook0: yes indeed. Well, you can do. And that's certainly what you get when you operate on them
09:53:27 <mmorrow> matthew-_: http://hpaste.org/9868
09:53:35 <matthew-_> gah, haskell.org failure
09:54:09 <matthew-_> mmorrow: err, yeah
09:54:14 <scook0> so if you're going to stash pointers into haskell data structures with indefinite lifetime, by all means use ForeignPtr
09:54:34 <matthew-_> yup. that exactly my case
09:54:52 <matthew-_> I was going to see what bytestring does, but I can't now access haskell.org. *sigh*
09:54:54 <mmorrow> yeah, it seems ForeignPtr is always used in that case
09:55:03 <mmorrow> ByteString uses ForeignPtr
09:55:24 <scook0> whereas most of my pointers have been to stack-allocated stuff that goes away quickly, so I personally use ForeignPtr very rarely
09:55:44 <matthew-_> scook0: how do you control stack allocated stuff?
09:55:50 <mmorrow> ByteString = PS {-# UNPACK #-} !Int {-# UNPACK #-} !Int !(ForeignPtr Word8)
09:55:53 <mmorrow> i believe
09:55:54 <matthew-_> is that what allocaBytes and friends does?
09:55:58 <matthew-_> ahh, cool
09:56:01 <scook0> yeah, alloca and friends
09:56:21 <matthew-_> yep. so if it's temporary then I always rewrite to use alloca
09:56:25 <scook0> useful if you just need to pass a pointer to a C routine, but neither you nor the routine needs to hang on to it afterwards
09:56:28 <mmorrow> (where the two Ints are the size and current offset)
09:56:35 <matthew-_> but I've got some stuff which is long living and have just been using malloc
09:56:59 <matthew-_> thanks for the pointers guys
09:57:01 <matthew-_> HONK HONK!
09:57:03 <mmorrow> heh
09:57:12 <scook0> i C what you did there
09:57:27 <matthew-_> pushing the boundaries now...
09:58:17 <scook0> :)
10:03:16 <trofi> @index on
10:03:17 <lambdabot> bzzt
10:03:44 <trofi> @hoogle on :: t -> (a->b)
10:03:45 <lambdabot> Prelude const :: a -> b -> a
10:03:45 <lambdabot> Data.Function const :: a -> b -> a
10:03:45 <lambdabot> GHC.Exts breakpointCond :: Bool -> a -> a
10:03:52 <trofi> @hoogle on ::  (a->b) -> t
10:03:53 <lambdabot> Control.Monad.Cont runCont :: Cont r a -> (a -> r) -> r
10:03:53 <lambdabot> Data.Set mapMonotonic :: (a -> b) -> Set a -> Set b
10:03:53 <lambdabot> Control.Exception mapException :: (Exception -> Exception) -> a -> a
10:04:02 <Myoma> @src on
10:04:02 <lambdabot> (*) `on` f = \x y -> f x * f y
10:05:18 <ski> @hoogle on
10:05:18 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:05:18 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
10:05:18 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
10:05:38 <blbrown> let a = 2, let b = 3   ...in ghci how would I divide.  tried this (a :: Integer) / (b :: Integer)
10:05:53 <ski> > 18 `div` 7
10:05:54 <lambdabot>  2
10:06:13 <trofi> > sort `on` even [1..10]
10:06:14 <lambdabot>  Couldn't match expected type `[a] -> c' against inferred type `[a]'
10:06:17 <trofi> > sortBy `on` even [1..10]
10:06:18 <ski> > fromIntegral 18 / fromIntegral 7
10:06:18 <lambdabot>  Couldn't match expected type `a -> a -> Ordering'
10:06:19 <lambdabot>  2.5714285714285716
10:06:29 <Myoma> trofi: sorting by if it's even or not ...?
10:06:37 <Myoma> > True < False
10:06:38 <lambdabot>  False
10:06:40 <trofi> yep :]
10:06:43 <EvilTerran> > (sortBy `on` even) [1..10]
10:06:44 <lambdabot>  Couldn't match expected type `a -> a -> Ordering'
10:06:45 <Myoma> :t sortBy even
10:06:46 <lambdabot>     Couldn't match expected type `a -> Ordering'
10:06:46 <lambdabot>            against inferred type `Bool'
10:06:46 <lambdabot>     Probable cause: `even' is applied to too many arguments
10:06:51 <Myoma> :t sortBy (comparing even)
10:06:51 <EvilTerran> > sortBy (comparing even) [1..10]
10:06:52 <lambdabot> forall a. (Integral a) => [a] -> [a]
10:06:53 <lambdabot>  [1,3,5,7,9,2,4,6,8,10]
10:07:09 <ski> blbrown : `div' for integral division .. use `fromIntegral' if you want fractional division
10:07:13 <ski> @type div
10:07:14 <lambdabot> forall a. (Integral a) => a -> a -> a
10:07:15 <ski> @type (/)
10:07:16 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:07:21 <trofi> @index comparing
10:07:21 <lambdabot> bzzt
10:07:24 <Myoma> :t (/)`on`fromIntegral
10:07:25 <lambdabot> forall b a. (Integral a, Fractional b) => a -> a -> b
10:07:28 <trofi> @hoogle comparing
10:07:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:07:32 <dsrogers> :t reify
10:07:32 <Myoma> :t (%)
10:07:33 <lambdabot> Not in scope: `reify'
10:07:34 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
10:07:49 <ski> > 18 % 7
10:07:50 <lambdabot>  18%7
10:07:58 <ski> > 24 % 15
10:08:00 <lambdabot>  8%5
10:08:34 <ski> dsrogers : ?
10:08:36 <mmorrow> reify :: Name -> Q Info
10:09:15 <dsrogers> ski: pardon?
10:09:40 <ski> (dsrogers : just wondered what `reify' you were referring to ..)
10:09:51 <dsrogers> template haskell
10:09:59 <ski> *nod*
10:10:10 <dsrogers> is there more than one?
10:10:31 <ski> dsrogers : there might be .. a lot of things have been called "reify"
10:11:08 <mmorrow> there's a hackage package called reify, but unfortunately it's bitrotted
10:13:06 <mmorrow> > "someone needs to " ++ fix ("reify(":)
10:13:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
10:13:17 <mmorrow> > ["someone needs to "] ++ fix ("reify(":)
10:13:18 <lambdabot>  ["someone needs to ","reify(","reify(","reify(","reify(","reify(","reify(","...
10:13:35 <mmorrow> > concat (["someone needs to "] ++ fix ("reify(":))
10:13:36 <lambdabot>  "someone needs to reify(reify(reify(reify(reify(reify(reify(reify(reify(reif...
10:15:03 <abbe> hi all
10:15:17 * abbe is having a problem with solution of an exercise in YAHT
10:15:25 <kowey> Toraxis : ping
10:15:27 <abbe> I've pasted my code at http://paste.lisp.org/display/65736
10:15:58 <abbe> I'm not able to figure out, what is wrong with my code. Can someone take a look at the code and explain me what is wrong. Thanks in advance :)
10:16:15 <kowey> @tell Toxaris nothing really, just letting you know that your 2-d table creation is becoming real... now I've got ascii-art rendering working
10:16:16 <lambdabot> Consider it noted.
10:16:35 <EvilTerran> abbe, a line in an IO do-block must have type IO (something)
10:16:40 <EvilTerran> ?type map
10:16:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:17:03 <EvilTerran> map gives back a [something]
10:17:05 <EvilTerran> wrong type
10:17:07 <abbe> EvilTerran, you mean issue with final return type
10:17:09 <EvilTerran> ?type mapM_
10:17:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:17:15 <EvilTerran> ?src mapM_
10:17:15 <lambdabot> mapM_ f as = sequence_ (map f as)
10:17:18 <Toxaris> kowey: now that you are talking about ASCII art ... I have spend the last couple of hours getting Haskell to produce colored console output on windows :)
10:17:18 <lambdabot> Toxaris: You have 1 new message. '/msg lambdabot @messages' to read it.
10:17:37 <EvilTerran> abbe, i mean "Couldn't match expected type `IO' against inferred type `[]'"
10:17:39 <ziman> > fix error
10:17:46 <EvilTerran> it's after an IO a
10:17:52 <EvilTerran> but you're giving it an [a]
10:17:54 <lambdabot>  thread killed
10:18:00 <Toxaris> kowey: but I'm glad that my idea worked out so far
10:18:12 <EvilTerran> ie ([] a) instead of (IO a), so it's complaining that [] isn't IO
10:18:20 <kowey> my renderer is dumb at the moment; it assumes maximum cell width
10:18:34 <EvilTerran> abbe, also, you can leave out a lot of parentheses there
10:18:39 <kowey> next, i'm going to put together a little combinator library so that making tables is nicer
10:18:49 <kowey> and do HTML stuff... cheers!
10:19:20 <kowey> hmm... maybe since you're doing Windows stuff, maybe we could recruit you into the darcs project
10:19:27 <abbe> EvilTerran, I'm confused with the syntax of Haskell, it is not mentioned yet in YAHT.
10:19:56 <EvilTerran> ?index mapM_
10:19:57 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:19:58 <abbe> EvilTerran, I mean I'm on 4th chapter, I've not encountered such syntax yet :(.
10:20:38 <ski> (abbe : the error was not about syntax. you had a type error)
10:21:47 <EvilTerran> abbe, the only relevant thing about syntax is that all infix operators bind more loosely than function application, always.
10:22:01 <EvilTerran> abbe, but, as ski says, that's not what's causing the error, it's just a style point
10:22:04 <abbe> okay, anyways thanks ski, EvilTerran for the explanation which i'm not able to decipher yet with my current understanding of haskell. though s/map/mapM_/ worked
10:22:19 <EvilTerran> abbe, it might be a good exercise to write it without using mapM_
10:22:31 <EvilTerran> abbe, using explicit recursion instead, say
10:22:31 <abbe> EvilTerran, The confusing is ::, =>, and -> operators.
10:22:37 <mmorrow> abbe: this is a very useful one:    (\xs -> mapM_ print xs) :: (Show a) => [a] -> IO ()
10:22:39 <abbe> EvilTerran, I wrote it using explicit recursion
10:22:56 <ski> abbe : try writing a function `printList' which e.g. uses `putStrLn' and `show' to print every element in a list
10:22:59 <abbe> EvilTerran, but then I thought may be i can use map which I encountered earlier.
10:23:08 <EvilTerran> abbe, i see
10:23:14 <aconbere> I'm a little confused about the particulars of the differences between type and data keywords
10:23:20 <EvilTerran> abbe, well, mapM_ is fairly straightforward, really
10:23:27 <EvilTerran> ?src mapM_
10:23:27 <lambdabot> mapM_ f as = sequence_ (map f as)
10:23:30 <Myoma> data defines a totally new data type
10:23:30 <EvilTerran> ?src sequence_
10:23:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:23:35 <Myoma> (and constructors for it)
10:23:36 <EvilTerran> -- or
10:23:44 <Myoma> type just gives a new name to something that already exists
10:23:47 <ddarius> aconbere: There aren't particulars.  They are dramatically different.
10:23:48 <aconbere> I understand that type creates synonymes to previously existing data types (which includes composit data types)
10:23:50 <mmorrow> aconbere: type Asdf = String      ==>     Asdf === String
10:23:50 <abbe> EvilTerran, so it typecasts the results
10:23:51 <EvilTerran> sequence_ [] = return (); sequence_ (x:xs) = do x; sequence_ xs
10:23:54 <ski> aconbere : `type' defines a type synonym to an existing type. `data' creates a new type
10:24:07 <EvilTerran> abbe, er, there's no typecasting happening anywhere
10:24:10 <EvilTerran> ?type sequence_
10:24:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:24:20 <EvilTerran> sequence_ :: [IO a] -> IO ()
10:24:27 * Myoma wonders what === is
10:24:38 <mmorrow> "same thing as"
10:24:39 <ski> (probably `=')
10:24:47 <Myoma> oh
10:24:52 <abbe> EvilTerran, what is >>  operator ?
10:25:02 <Myoma> = == === ≡ ...
10:25:03 <idnar> @src >>
10:25:03 <lambdabot> m >> k      = m >>= \_ -> k
10:25:10 <EvilTerran> abbe, "x >> y" is what "do x; y" desugars to
10:25:30 <idnar> @redo m >>= \_ -> k
10:25:30 <lambdabot> do { _ <- m; k}
10:25:37 <Toxaris> kowey: is there special need for windows programming with darcs, it seems to just work, except for some configuration issues (wget/curl and something about ssh)?
10:25:41 <idnar> meh
10:25:42 <mmorrow> do {print 0 ; print 1}       ===         print 0 >> print 1     ===  mapM_ print [0,1]
10:26:08 <EvilTerran> abbe, you don't have to worry about that for now, "sequence_ [] = return (); sequence_ (x:xs) = do { x; sequence_ xs }" is probably more likely to be clear to you
10:26:11 <mmorrow> ===  sequence_ [print 0,print1]
10:26:33 <Myoma> ===  do { print 0 ;print1 }
10:26:36 <EvilTerran> and comes to exactly the same thing
10:26:44 <ski> > map (`replicate` '=') [0..]
10:26:46 <lambdabot>  ["","=","==","===","====","=====","======","=======","========","=========",...
10:26:57 <EvilTerran> > iterate ('=':) ""
10:26:59 <lambdabot>  ["","=","==","===","====","=====","======","=======","========","=========",...
10:27:04 <ski> EvilTerran :)
10:27:06 <abbe> EvilTerran, oh, okay so it servers as wrapper around the argument function
10:27:18 <Myoma> ===  do { print 0 ;print1 }
10:27:19 <abbe> EvilTerran, and removes it return type
10:27:20 <Myoma> oops
10:27:28 <EvilTerran> abbe, er, pretty much, yeah
10:27:36 <kowey> Toxaris: one issue is that we get a lot of random looking Permission Denied errors using darcs on windows
10:27:46 <abbe> EvilTerran, oh, thanks for the explanation, it is more clear now :)
10:27:50 <EvilTerran> abbe, it takes a list of actions and returns one action that represents doing all of the actions in the list in sequence
10:28:00 <mmorrow> > map (\c -> if c=='\\' then '=' else c) . filter (/='"') . fix $ show
10:28:01 <EvilTerran> and throwing away the result
10:28:02 <lambdabot>  "===========================================================================...
10:28:12 <mmorrow> dars
10:28:20 <mmorrow> s/dars//
10:28:21 <kowey> Toxaris: there is a bunch of little stuff besides that, but none of us use Windows and it's making us sad not to fix them
10:28:26 <EvilTerran> abbe, there's another one called just sequence, without the _
10:28:26 <abbe> EvilTerran, okay.
10:28:38 <kowey> http://bugs.darcs.net/issue?@columns=title,id,activity,status,assignedto&@sort=activity&@group=priority&@filter=topic,status&@pagesize=50&@startwith=0&topic=1&status=-1,1,2,3,4,5,6&@dispname=Windows
10:28:39 <lambdabot> Title: Bug Tracker - Windows - Darcs bug tracker, http://tinyurl.com/6hd8p9
10:28:42 <Myoma> @let c'\\'='=';c o=o
10:28:43 <lambdabot>  Improperly terminated character constant
10:28:45 <Myoma> :(
10:28:47 <abbe> EvilTerran, I think I'll read about that later, when I'll came across that in the book. :)
10:28:48 <Myoma> @let c '\\'='=';c o=o
10:28:50 <lambdabot> Defined.
10:28:52 <EvilTerran> abbe, that one's sequence [] = return []; sequence (m:ms) = do x <- m; xs <- sequence ms; return (x:xs)
10:28:53 <mmorrow> > map (\c -> if c=='\\' then '=' else if c=='"' then ',' else c) . fix $ show
10:28:55 <lambdabot>  ",=,===,=======,===============,===============================,============...
10:28:58 <mmorrow> crap
10:29:11 <mmorrow> oh well
10:29:16 <EvilTerran> abbe, basically it does the same thing as sequence_, it just doesn't throw the results of all the actions away, it collects them into a list instead
10:29:25 <EvilTerran> sequence :: [IO a] -> IO [a]
10:29:48 <mmorrow> > sequence (replicate 10 randomIO)
10:29:50 <lambdabot>  Add a type signature
10:29:51 <abbe> EvilTerran,  map sqrt [4,16,9,25]
10:30:01 <mmorrow> > sequence (replicate 10 randomIO) :: IO [Int]
10:30:02 <lambdabot>  mueval: *** Exception: "<IO [Int]>"
10:30:05 <abbe> EvilTerran,  [2.0,4.0,3.0,5.0]
10:30:05 <EvilTerran> "list of IO actions, each returning an (a)" -> "single IO action, returning a list of (a)s"
10:30:09 <kowey> Toxaris: also, it appears that darcs performance on windows is much worse than on Linux (we aren't completely sure yet)
10:30:10 <EvilTerran> abbe, yes?
10:30:10 <mmorrow> > replicateM 10 randomIO :: IO [Int]
10:30:12 <lambdabot>  mueval: *** Exception: "<IO [Int]>"
10:30:14 <abbe> EvilTerran, that also does the same
10:30:20 <kowey> so lots of work to do if we could interest you ! :-)
10:30:49 <EvilTerran> ?type map putStrLn
10:30:51 <lambdabot> [String] -> [IO ()]
10:30:54 <EvilTerran> ?type mapM_ putStrLn
10:30:56 <lambdabot> [String] -> IO ()
10:30:59 <abbe> EvilTerran, then why is sequence_ needed
10:31:08 <abbe> EvilTerran, s/sequence_/sequence/
10:31:17 <EvilTerran> abbe, do you see the importance of the distinction between those two types?
10:31:24 <mmorrow> ? type sequence_ . map putStrLn
10:31:28 <mmorrow> ?type sequence_ . map putStrLn
10:31:30 <lambdabot> [String] -> IO ()
10:31:53 <mmorrow> mapM_ f xs = sequence_ (map f xs)
10:32:04 <newsham> i'm having some trouble getting wxHaskell installed.
10:32:05 <Myoma> :t (sequence .) . map
10:32:06 <abbe> EvilTerran, first one is an list of IO ()
10:32:07 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
10:32:12 <abbe> EvilTerran, second one is IO ()
10:32:38 <EvilTerran> abbe, yes, that's the difference... but that's important because you can't "run" a list of IO actions directly
10:32:38 <newsham> two hurdles I had to jump over -- it assumes wx-conf is in path (mine is not named wx-conf), it uses gnumakefile extensions (my default make is not gnumake)
10:33:06 <mmorrow> @pl \g f x y -> g (f x y)
10:33:07 <lambdabot> (.) . (.)
10:33:12 <EvilTerran> abbe, and that's the job done by sequence(_), mapM(_), etc
10:33:35 <EvilTerran> abbe, they take a list of actions and construct a new action that does all the old ones and *can* be "run" directly
10:34:08 <newsham> problem I'm having still: it assumes I'll have a glcanvas installed and I dont yet have that (not sure how I get that)
10:34:10 <abbe> EvilTerran, okay, i think I should continue further.
10:34:16 <mmorrow> so in other words,  it turns a list of actions into an action producing a list of results
10:34:19 <EvilTerran> do :)
10:34:21 <abbe> EvilTerran, thanks again for the explanations.
10:34:24 <EvilTerran> np
10:34:49 <abbe> one more think, I'm using haskell-mode.el to edit my haskell code
10:35:47 <abbe> I noticed after I type 'where\n', the cursors gets indented further. So I've to manually move cursor to column 0.
10:36:09 <abbe> so, I'm wondering if it is okay to proceed at the same indented location.
10:36:17 <abbe> s/think/thing/
10:36:32 <ski> foo x = y
10:36:34 <ski> where
10:36:38 <ski> y = x*x
10:36:38 * abbe uses Emacs 23
10:36:40 <ski> is not ok
10:36:43 <ski> foo x = y
10:36:45 <ski>   where
10:36:47 <ski>   y = x*x
10:36:49 <ski> is ok
10:37:08 <ski> foo x = y
10:37:11 <ski>   where y = x*x
10:37:13 <ski> is also ok
10:37:15 <ski> as is
10:37:19 <abbe> ski, but what is the use of where ? like 'do' allows you to have block of statements
10:37:20 <ski> foo x = y   where y = x*x
10:37:34 <Myoma> abbe: You know let ?
10:37:53 <mmorrow> > (\x -> let xs = x : xs in xs) 42
10:37:55 <ski> abbe : `where' is one way to declare local variables in a function
10:37:55 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
10:37:55 <abbe> Myoma, yup, let used to assign values to variables.
10:38:08 <mmorrow> > (\x -> xs where xs = x : xs) 42
10:38:09 <lambdabot>  Parse error at "where" (column 11)
10:38:19 <mmorrow> oops
10:38:27 <abbe> are statements in where block executed prior to the top level code, like y = x*x is evaluated first, then x = y.
10:38:35 <mmorrow> > let f x = xs where xs = x : xs in f 42
10:38:37 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
10:38:38 <ski> abbe : `where' is similar to `let' .. except the order is "opposite", and `let' is used in expressions, while `where' attaches to definitions
10:38:41 <Axman6> abbe: yes
10:38:44 <Myoma> abbe: no
10:38:51 <EvilTerran> Axman6, no
10:38:54 <abbe> Hmm.., yes, no ?
10:38:58 <Axman6> or not...
10:39:04 <Toxaris> abbe: where blocks do not contain statements, but definitions
10:39:20 <abbe> Toxaris, oh, okay.
10:39:27 <ski> abbe : generally, definitions inside the `where' are only evaluated when/if needed .. in my example above, `y' was returned, so it was needed directly
10:39:31 <Myoma> abbe: haskell is lazy evaluated
10:39:52 <Myoma> abbe: so you don't program the order which things will happen in
10:40:22 <abbe> okay ski and Myoma.
10:40:29 <Toxaris> > let neverUsed = error "will this error matter?" in 42 -- abbe: note that neverUsed is never used
10:40:31 <lambdabot>  42
10:40:52 <Toxaris> > let used = error "now this is a problem" in used -- but that happens if we use a variable
10:40:54 <lambdabot>  mueval: *** Exception: now this is a problem
10:40:58 <Axman6> abbe: where is generally used to break the code up into smaller parts
10:41:00 <abbe> Toxaris, so it'll never be evaluated, hmm...
10:41:08 <ski> abbe : generally `where' is usually used when you first want the main picture of what a function returns, and only later want to see the details
10:41:13 <Myoma> > 0 * error "tets"
10:41:15 <lambdabot>  mueval: *** Exception: tets
10:41:19 <Axman6> so it's easier to understand etc.
10:41:21 <Toxaris> abbe: where is the "same thing" as let, but with different syntax, and usable in different places
10:41:22 <ski> abbe : while `let' is for when you want the details first
10:41:24 <Myoma> > error "tets" * 0
10:41:26 <lambdabot>  mueval: *** Exception: tets
10:41:33 <abbe> okay
10:41:45 <abbe> thanks Toxaris, ski, Myoma, Axman6, and EvilTerran :)
10:41:50 * abbe heads back to the book.
10:43:06 <Heffalump> Toxaris: in my experience darcs doesn't work that well on Windows; the console input handling misbehaves and it seems relatively slow at doing filesystem stuff. Also, it's a pain to build on Windows because of the mingw/cygwin requirements.
10:46:02 <heisenbug> does -XGADTs to ghc-6.8.3 imply that the "data Foo :: (* -> * -> *) -> * -> * -> * where" syntax is understood?
10:46:20 <dolio> I think you need -XKindSignatures as well.
10:46:28 <heisenbug> eeek
10:46:33 <heisenbug> thanks!
10:48:04 <Toxaris> Heffalump: "it's a pain to build on windows" is not exactly motivating me to work on it :)
10:51:16 <Heffalump> :-)
10:51:23 * sclv modestly suggests that making darcs less painful/more well documented to build on windows would be a lovely task in itself.
10:51:30 <Heffalump> well, I've just got it building on native windows
10:51:53 <Heffalump> I hacked some stuff around a bit though so it probably doesn't actually work correctly.
10:52:10 <mmorrow> haha, i love that
10:52:13 <sclv> seriously -- only darcs 2.0.0 binaries coming with prebuilt ssh support!? for shame!
10:52:53 <mmorrow> seriously -- windows doesn't come with prebuilt ssh support!? for shame!
10:52:57 <mmorrow> :)
10:53:46 <sclv> a poor craftsman blames...
10:54:24 <sclv> or more to the point -- if effort isn't put into making the irritating/painful things less so, then development resources aren't being well spent.
10:55:06 <mmorrow> speaking in general, i personally couldn't live w/out ssh port forwarding
10:55:25 <mmorrow> ssh -Nf -L 8080:localhost:8080  me@there.com
10:55:44 <mmorrow> ssh -Nf -R 8080:localhost:8080  me@there.com
10:55:56 <jpcooper> what is the nicest way to take a Maybe value and return True if it is Nothing, or if it is a Just value, return the result of applying a predicate to its value?
10:56:10 <Myoma> :t maybe
10:56:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:56:25 <jpcooper> of course
10:56:25 <Myoma> :t maybe True ?p
10:56:27 <lambdabot> forall a. (?p::a -> Bool) => Maybe a -> Bool
10:56:46 <heisenbug> dolio: then ghc has a bug: if I recompile (without changing any sources) but leave away -fglasgow-exts then the compiler won't re-run the parser
10:56:59 <heisenbug> which it should do at least!
10:57:17 <dolio> What?
10:57:21 <heisenbug> is this a known bug?
10:57:24 <mmorrow> did you clean the .o and .hi files
10:57:35 <heisenbug> noI didn't
10:57:45 <sclv> -fforce-recompile
10:57:51 <mmorrow> it probably says "oh, it's up to date, no need to do anything"
10:58:02 <heisenbug> yeah, that is clear
10:58:06 <mmorrow> based on the stat of the .{o,hi}
10:58:14 <sclv> that's not a bug though. that's a feature.
10:58:46 <dolio> There has been talk about recompiling based on different -O settings and such. But no one's done it yet.
10:59:02 <heisenbug> but hackage tricked me into removing -fglasgow-exts and did not run with -fforce-recompile
10:59:15 <EvilTerran> dolio, what, somehow encode the settings in the output file or something?
10:59:41 <dolio> Yeah. The .hi might already record the optimization level. I'm not sure.
11:00:16 <heisenbug> I guess this is a hackage bug, it should make clean after reconfiguring
11:00:30 <heisenbug> and if language features change
11:00:48 <mmorrow> that would be something to take up with cabal, not hackage
11:00:53 <Saizan_> by hackae you mean Cabal?
11:00:57 <sclv> hackage is a website
11:01:04 <heisenbug> i.e. Extensions: or Ghc-Options:
11:01:13 <heisenbug> yeah, Cabal :-)
11:01:26 <mmorrow> heisenbug: ask dcoutts about things Cabal
11:01:32 <dcoutts_> @yarr!
11:01:32 <lambdabot> Keelhaul the swabs!
11:01:37 <mmorrow> heh
11:01:38 * heisenbug claims a noob bonus
11:01:48 <Saizan_> well my gsoc project handles excatly those things :)
11:02:02 <Saizan_> namely, proper dependency tracking for cabal
11:02:09 <heisenbug> Saizan_: ship it!
11:02:13 <dcoutts_> heh heh
11:02:33 <Saizan_> heisenbug: the end of summer is near, so i will :)
11:02:38 * dcoutts_ has been neglecting Saizan_, while at the same time talking up his project
11:02:49 * heisenbug now ended up with a non-compiling package loaded up to hackage :-(
11:02:54 <dcoutts_> Saizan_: let's do some pre-processor hacking later
11:03:25 <sclv> ok related question -- if I have a single repo/directory structure with common libraries and say 8 different executables to be generated, what's the recommended way?
11:03:26 <heisenbug> dcoutts: should I file a cabal ticket?
11:03:46 <Saizan_> dcoutts_: ok
11:03:54 <sclv> A single cabal script with flags? Multiple .cabal files?
11:04:03 <dcoutts_> heisenbug: sorry, I wasn't paying attention. What'ts the bug?
11:04:18 <heisenbug> heisenbug: but hackage tricked me into removing -fglasgow-exts and did not run with -fforce-recompile
11:04:28 <Saizan_> dcoutts_: i've been thinking of target-inference, and how it conflicts with parallelizing
11:04:29 <heisenbug> heisenbug: I guess this is a cabal bug, it should make clean after reconfiguring
11:04:32 <sclv> I want to be able to generate the executables both individually and en masse.
11:04:54 <dcoutts_> sclv: you can put multiple exes in a single package, but currently they all get built together and do not share .o files, so everything gets rebuilt
11:05:06 <sclv> should I just uses a make script then?
11:05:11 <mmorrow> heisenbug: ohhh, i see now why you said "hackage tricked you ...". so you got the warning while uploading that -fglasgow-exts is frowned upon ?
11:05:20 <TomMD> sclv: I think dcoutts_ has gotten to using Make so much he'll be depricating cabal ;-)
11:05:22 <heisenbug> yep
11:05:25 * mmorrow ignores that
11:05:28 * mmorrow ducks
11:05:36 <dcoutts_> TomMD: what makes you think I use make? :-)
11:06:04 <dcoutts_> I *have* used it, which is why I feel qualified to criticise it
11:06:05 <heisenbug> mmorrow: after that I changed .cabal, reconfigured and rebuilt
11:06:25 <heisenbug> mmorrow: ghc did not give me error
11:06:27 <sclv> I think for these purposes I could get away with a make script that just had different ghc --make commands for each target. But I'd lose lots of the niceities of cabal.
11:06:38 <TomMD> dcoutts_: Just going by your blog post, I'd say you've been playing with it a little too much in the past couple months.
11:06:45 <dcoutts_> heisenbug: so you're complaining that after changing ghc-options, the modules were not rebuilt. Is that it?
11:06:47 <sclv> this isn't for a package for, e.g., hackage -- just a set of apps I'm working on.
11:07:03 <heisenbug> dcoutts_: exactly
11:07:13 <mmorrow> heisenbug: ah i see. i usually always runhaskell Setup.lhs clean before all rebuilds where i have to Setup configure
11:07:17 <dcoutts_> TomMD: actually I've not used it at all seriously since re-implementing the gtk2hs build system in make about four years ago.
11:07:23 <tristes_tigres> Hi
11:07:31 <TomMD> hello tristes_tigres
11:07:39 <dcoutts_> TomMD: but I have been thinking a lot about build systems. And talking about make gives everyone else a useful reference point.
11:08:01 <dcoutts_> heisenbug: sure, file a ticket.
11:08:01 <tristes_tigres> I have a string with a valid Haskell code, can I execute it ?
11:08:17 <TomMD> I see.  Here I thought you were going to make Haskell famous for providing "that build system all the OSS projects use these days" ;-)
11:08:17 <heisenbug> dcoutts_: great, will do
11:08:43 * TomMD heads out the door.
11:08:45 <dcoutts_> TomMD: Haskell would certainly be a good language to implement such a thing in.
11:09:01 <dcoutts_> TomMD: but in the mean time, we'll prototype it in Cabal
11:09:42 <TomMD> :-) Got to run.  Funny how Haskell prototypes are more solid than the market equiv.
11:10:05 <tristes_tigres> \me has a string with constructors like "Branch (Leaf a) (Leaf b)"
11:10:28 * tristes_tigres has a string with constructors like "Branch (Leaf a) (Leaf b)"
11:10:46 <mmorrow> tristes_tigres: you can with hs-plugins
11:10:54 <tristes_tigres> I can turn it into a tree by (read it) :: Tree
11:10:54 <mmorrow> ohh, forget that
11:11:01 <mmorrow> derive Show for it
11:11:10 <heisenbug> another question: if I add an instance declaration for a type class, is there a need to note this in the module's export list?
11:11:13 <mmorrow> (and Read)
11:11:21 <tristes_tigres> but isn't there a more legant way
11:11:40 <mmorrow> wow, i thought read/show was pretty elegant myself :)
11:11:46 <tristes_tigres> what's the point of using a parser when I have a valid string with constructors
11:11:53 <mauke> tristes_tigres: er
11:12:15 <mauke> brain crash
11:12:21 <mmorrow> tristes_tigres: well, read does exactly what an eval function would
11:12:23 <Heffalump> heisenbug: no. In fact you can't prevent the instance being exported.
11:12:39 <tristes_tigres> mmorrow : I see ^-)
11:12:43 <heisenbug> dandy, thanks Heffalump!
11:12:45 <Myoma> hm
11:12:54 <Myoma> > read "not True" :: Bool
11:12:55 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
11:13:24 <DRMacIver> dcoutts_: For what it's worth, that wasn't just a random attack on reddit. The person in question has repeatedly demonstrated incorrect babble of that nature.　 :)
11:13:24 <tristes_tigres> myoma: brackets
11:13:27 <DRMacIver> oops
11:13:32 <tristes_tigres> (read "not True") :: Bool
11:13:37 <mauke> no
11:13:50 <dcoutts_> DRMacIver: aye, he's a little prolific in re-posting too :-)
11:13:52 <mmorrow> ok, if you want to do *that*, then you need hs-plugins or equivalent
11:13:56 <tristes_tigres> >(read "not True") :: Bool
11:14:13 <DRMacIver> dcoutts_: Yeah. He really gets on my nerves. :)
11:14:23 <dcoutts_> DRMacIver: though this time it wasn't that incorrect, it was interpretable into something plausible :-)
11:14:35 <tristes_tigres> mmorrow: you talking to me, about hs-plugins ?
11:14:44 <mmorrow> yeah, you and Myoma
11:14:50 <Myoma> me ??
11:14:55 <mmorrow> <Myoma> > read "not True" :: Bool
11:15:18 <DRMacIver> dcoutts_: No, I really don't think so. There was too much random tangential babbling about monads in the middle of it
11:15:42 <DRMacIver> I mean, the basic point of "Yes it does, but it's complicated" is right. But that's obvious. Everything else was wrong. :)
11:16:22 <jpcooper> is there a pre-defined cartesian-product operator?
11:16:28 <Myoma> liftM2 (,)
11:17:17 <jpcooper> wow, that's pretty cool
11:17:19 <mmorrow> > (\xs ys -> [ (x,y) | x <- xs, y <- ys ]) [0..4] [7..11]
11:17:21 <lambdabot>  [(0,7),(0,8),(0,9),(0,10),(0,11),(1,7),(1,8),(1,9),(1,10),(1,11),(2,7),(2,8)...
11:17:30 <tristes_tigres> That was a small question, though, and i have a REALLY big one
11:17:42 <mmorrow> hehe
11:17:45 <Myoma> > let (*) = liftM2 (,) in "foo" * [1,2,3] * "bar"
11:17:47 <lambdabot>  [(('f',1),'b'),(('f',1),'a'),(('f',1),'r'),(('f',2),'b'),(('f',2),'a'),(('f'...
11:18:38 <tristes_tigres> The floating point ! Haskell is somewhat clueless about it
11:18:54 <Myoma> tristes_tigres: I don't understand
11:18:58 <mmorrow> me neither
11:19:05 <Myoma> tristes_tigres: Float the numbers?
11:19:17 <tristes_tigres> Floating point computations in Haskell
11:19:24 <Myoma> it can be done
11:19:30 <Myoma> > 1 :: Float + 3
11:19:30 <lambdabot>  Parse error at "+" (column 12)
11:19:33 <mmorrow> is this the REALLY big one?
11:19:33 <tristes_tigres> I know it can be done
11:19:35 <Myoma> but not like that
11:19:43 <tristes_tigres> but not very well
11:19:57 <tristes_tigres> mmorrrow: yes it is
11:20:05 <mmorrow> so what's the full question?
11:20:13 <sclv> haskell does floating point just fine.
11:20:24 <tristes_tigres> mmorrow: what if I want to set a rounding mode, fpor instance
11:20:34 <mmorrow> ahh, ok. one sec
11:20:36 <tristes_tigres> sclv: no it does not
11:20:50 <newsham> > 1.2 + 3.4
11:20:52 <lambdabot>  4.6
11:20:58 <sclv> ok I see what you mean -- it doesn't by default give all the control of the ieee spec.
11:20:59 <tristes_tigres> what if floating point operation alters FPU state registers ?
11:21:05 <mmorrow> tristes_tigres: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ieee
11:21:10 <lambdabot> Title: HackageDB: ieee-0.3
11:21:21 <tristes_tigres> I mean, floating-point computation is not pure
11:21:24 <jberg> hey, whats the url to that language shootout?
11:21:29 <Myoma> yes it is
11:21:29 <mmorrow> i'm not sure, but that may allow you to set the rounding mode
11:21:30 <jberg> didnt haskell do fairly well there?
11:21:33 <newsham> ?go language shootout
11:21:41 <lambdabot> http://shootout.alioth.debian.org/
11:21:41 <lambdabot> Title: The Computer Language Benchmarks Game
11:21:48 <sclv> tristes_tigres: right, but haskell is, so choices were made...
11:21:50 <mmorrow> err, looks like it doesn't
11:22:10 <tristes_tigres> sclv: and that choice rules out haskell for serious numerical woork
11:22:13 <mmorrow> maybe you should write some C, and wrap it in a haskell lib via the FFI
11:22:37 <mmorrow> tristes_tigres: also, see hmatrix
11:22:37 <tristes_tigres> mmorrow: sure I can. Hell, I can do everything in assembler
11:22:53 <sclv> only if ieee floats are your only go to choice for serious numerical work.
11:22:53 <mmorrow> exactly! when you're done, upload it to hackage :)
11:23:02 <dogface> Suppose I have this: class Foo a b where conv :: a -> b; down :: a -> Integer; down x = down (conv x)
11:23:06 <jberg> but where do you find the table which compares all the languages? i didnt find it on the page in the link
11:23:22 <bjrn> Hi. I need some help with binary-strict. I think i've found a bug, but then I'm not really sure how this module is supposed to work. Problematic (?) code: http://hpaste.org/9869
11:23:29 <tristes_tigres> sclv: IEEE floats IS the only choice for serious nuumerical work
11:23:34 <dogface> Will that default definition of down be safely ignored when there is no Foo b _?
11:24:29 <tristes_tigres> ieee package is rubbish
11:24:36 <mmorrow> heh
11:24:43 <sclv> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AERN-Real ?
11:24:45 <lambdabot> Title: HackageDB: AERN-Real-0.9.6.1, http://tinyurl.com/3kxgjk
11:24:46 <tristes_tigres> rounding modes affect all operationas
11:24:46 <newsham> dogface: what will it pick instead?
11:25:02 <dogface> newsham: the definition given in the instance declaration.
11:25:03 <tristes_tigres> not just comparisons
11:25:06 <mmorrow> tristes_tigres: you sound to me to be the perfect candidate to upload a good one :)
11:25:19 <tristes_tigres> mmorrow I do ? ^-)
11:25:39 <mmorrow> you sound like you know what you're talking about
11:25:46 <sclv> http://darcs.augustsson.net/Darcs/CReal/ ?
11:25:50 <newsham> dogface: whenever you call down, the value you're calling with must be an instance of the class.
11:25:55 <mmorrow> and you seem to need this functionality
11:25:55 <lambdabot> Title: Index of /Darcs/CReal
11:26:04 <newsham> if there is no instance, its an error
11:26:10 <mmorrow> tristes_tigres: so yes
11:26:16 <dogface> newsham: I know that.
11:26:18 <sclv> A good interface to full ieee spec would be very good though -- yes.
11:26:19 <tristes_tigres> mmorrow: may be I sound like one, but there are REAL experts and I am not among them
11:26:19 * Myoma cannot imagine why somebody would use floats for anything except games :/
11:26:32 <tristes_tigres> Myoma: this is really ignorant thing to say
11:26:49 <Myoma> tristes_tigres: Well it's a fact, I don't know what uses they have other than that
11:27:13 <aeolist> fur scientifik calculationz!
11:27:16 <newsham> them i am misunderstanding your question
11:27:21 <tristes_tigres> sclv: that would mean that all arithmetic operations are not pure
11:27:31 <sclv> you could cheat...
11:27:31 <bjrn> You can use clever bit hacking tricks with floats as they are 32 bits usually
11:27:31 <tristes_tigres> aeolist: Exactly
11:27:34 <Myoma> If you use floating point for an algorithm, you get a result 2.323454 or something
11:27:42 <tristes_tigres> myoma
11:27:43 <Myoma> is that accurate to 3 places or 50 ?
11:27:44 <newsham> if down :: a -> Integer, then you can only call it with an "a"
11:27:46 <Heffalump> Myoma: fast hardware support?
11:27:59 <mmorrow> tristes_tigres: if your code is correct and takes into account all that should be taken into account, then your code will be indistinguishable from that of a so-called expert
11:28:03 <sclv> or you could not cheat -- and get a monadic dsl...
11:28:13 <sclv> and you could then provide both.
11:29:17 <sclv> maybe a withRoundingMode :: IO a -> IO a combinator....
11:29:22 <sclv> as an in the middle comprimise
11:29:37 <Myoma> tristes_tigres, yes?
11:29:59 <tristes_tigres> myoma: IEEE floating point is necessary to do things like modellling physical systems and processing experimental data
11:30:16 <sclv> Myoma: the whole point of IEEE is also precisely to be able to calculate exactly how accurate it is!
11:30:29 <Myoma> sclv: How do you do it?
11:30:32 <sclv> lazy use of floats doesn't provide stability -- careful use by smart ppl does.
11:30:48 <tristes_tigres> sclv: someting like that
11:30:52 <stepcut`> sclv: you could also use newtype or something to defined new types with different rounding settings (but it would be static for each type).
11:31:12 <tristes_tigres> stepcut: IEEE arihmetic is not pure
11:31:25 <stepcut> tristes_tigres: in what sense ?
11:31:25 <sclv> stepcut: I guess, but you'd have to switch modes in the middle constantly, no...
11:31:41 <sclv> stepcut: you set global bits to determine behavior
11:32:10 <tristes_tigres> stepcut: for instance a floating point op can raise state flags
11:32:23 <sclv> but anyway, yeah, tristes_tigres raises a real point here -- its not hurting my use of haskell, but if its hurting the use of some, then a library would be v. welcome
11:33:14 <Myoma> how do you calculate the accuracy of an algorithm doing floating point calculations?
11:33:23 <sclv> Myoma: I forget if this paper is the best to read on it... http://www.cs.berkeley.edu/~wkahan/MathSand.pdf
11:33:26 <lambdabot> Title: MATHEMATICS WRITTEN IN SAND -
11:33:45 <sclv> but on his webpage are oodles... this might be another good one: http://www.cs.berkeley.edu/~wkahan/Stnfrd50.pdf
11:33:47 <lambdabot> Title: Why can I Debug some Numerical Programs that You Can’t ?
11:33:49 <dogface> newsham: yes, I know. But in a class declaration, is it fine to have a default definition that's only correctly typed sometimes, as long as I override it in those cases where it's not correctly typed?
11:33:50 <stepcut> raised state flags could be problematic
11:33:50 <tristes_tigres> sclv: or the classic http://docs.sun.com/source/806-3568/ncg_goldberg.html
11:34:17 <newsham> dogface: how can you have a definitoin thats not correctly typed?
11:34:18 <tristes_tigres> sclv: Yes, the last reference is theo one
11:34:49 <newsham> i am having a hard time understanding what it is you are trying to ask.
11:34:54 <newsham> perhaps you should write out a concrete case
11:35:01 <newsham> (in which case ghc will give you an instant answer)
11:35:23 <tristes_tigres> myoma: what do you mean by "accuracy of the algorithm"
11:35:25 <dogface> Yeah, I guess I don't know why I asked rather than just trying.
11:35:50 <newsham> well if i understood your question better it might have been a sane strategy :)
11:36:19 <tristes_tigres> in numerical work, you might want to try to do some complicated numerical computation with rounding up and rounding down and compare
11:36:51 <tristes_tigres> if algithm is sane, the results should not be wildly off
11:37:03 <newsham> bjrn: looking at your hpaste it looks like a bug to me (re-reading the same bits over again)
11:37:24 * dogface shrugs hopefully
11:37:28 <tristes_tigres> http://citeseer.ist.psu.edu/goldberg91what.html
11:38:55 <sclv> I'm less exercised about setting status bits though... haskell's mapping of that seems reasonable enough to the extent I understand it?
11:39:30 <tristes_tigres> sclv: what is haskell mapping of them ?
11:39:36 <tristes_tigres> something in System
11:39:46 <sclv> ok I'm revealing my ignorance here.
11:40:48 <tristes_tigres> what if I want to do computation while rounding every operation up, and rounding every op down, and at every step compare the results ? Without altering the code for computation ?
11:40:59 <sclv> > 1 / 0
11:41:01 <lambdabot>  Infinity
11:41:02 <sclv> > 0 / 0
11:41:04 <lambdabot>  NaN
11:41:33 <sclv> mapping of status bits, no?
11:41:37 <bjrn> newsham: Nice, so i'm not insane.
11:41:41 <sclv> > -1 / 0
11:41:43 <lambdabot>  -Infinity
11:41:50 <Toxaris> tristes_tigres: what if you want to do that in any other language?
11:42:06 <newsham> bjrn: *shrug* could be jont insanity.
11:42:17 <newsham> I only see one place with two 11's in a row to form a 3.
11:42:24 <tristes_tigres> Toxaris: I would need a special debugger
11:42:29 <newsham> i'm not sure how you'd get any 3's out of 5 bits though
11:43:50 <tristes_tigres> Toxaris: but wouldn't it be great if Haskell could do it without crutches ?
11:44:11 <Toxaris> tristes_tigres: so that Haskell code runs at the speed of debugged code?
11:44:36 <sclv> hmm... I guess that doesn't let you distinguish 1 / 0 from overflow...?
11:44:56 <tristes_tigres> Toxaris: the issue is not speed
11:46:09 <sampointon> sclv: if there's error on the denominator, isn't it the same thing?
11:46:21 <tristes_tigres> so i am not sure even how the type fro floating point computation would look
11:46:40 <sampointon> sclv: of course, if the denominator is exact, they should be different
11:47:16 <Toxaris> type Double = Status -> (InternalDouble, Status)
11:47:42 <sclv> (.*) :: IEFloat -> IEFloat -> IO IEFloat ?
11:47:46 <Heffalump> Toxaris: what about when you want to inspect the value?
11:47:53 <Heffalump> e.g. branch on it
11:48:00 <Toxaris> Heffalump: then you have to provide the current status
11:48:02 <tristes_tigres> Toxaris: rounding mode ?
11:48:12 <Toxaris> Status = rounding mode etc
11:48:34 <tristes_tigres> Toxaris: rounding mode is not a property of a number
11:48:56 <sclv> Applicative notation would probably help quite a bit here.
11:49:09 <Toxaris> my Double is not a number, but a computation which yield a number
11:49:35 <Toxaris> for different rounding modes, it may yield different numbers
11:49:45 <Heffalump> what's the point of threading the rounding mode?
11:49:55 <Heffalump> it's not like it can change it
11:49:55 <Toxaris> but for the same rounding mode etc., it will yield the same number
11:50:04 <sclv> well, it needs to be implicitly threaded at least...
11:50:21 <stepcut> sclv: I was thinking it would be better as, (.*) :: IO IEFloat -> IO IEFloat -> IO IEFloat, so you can do 1 .* (2 .* 4)
11:50:26 <Toxaris> Heffalump: no clue, if it cannot be changed, then Reader is enough, of course
11:50:54 <trofi> is there standard(autogenerated predecate, or such) way to filter out one given data constructor from list? like filter (case D1 _ _ ... -> True; _ -> False) list?
11:51:14 <Toxaris> trofi: no
11:51:26 <tristes_tigres> Toxaris: like State monad ?
11:51:45 <Toxaris> tristes_tigres: yep, my Double type is StateT Status InternalDouble
11:51:48 <sclv> stepcut: well, the former is more basic. operators could be provided for sugar to get the latter, but there might also be advantages in forcing yourself to spell everything out.
11:52:02 <tristes_tigres> Toxaris: how about arrows ?
11:52:03 <Toxaris> tristes_tigres: but Heffalump suggested ReaderT Status InternalDouble instead, that is (Status -> InternalDouble)
11:52:12 <stepcut> sclv: true
11:52:20 * shap1 hugs Myoma
11:52:21 <mmorrow> tristes_tigres: i put a tarball of the ieee-utils subdir in the gsl code here http://code.haskell.org/~morrow/code/c/ieee-utils.tar.gz
11:52:23 <sampointon> trofi: you could try something like pred constructor x | _ val -> constructor val == x
11:52:44 <mmorrow> tristes_tigres: maybe a nice reference for your haskell lib ;)
11:52:45 <sclv> Toraxis: rounding mode can change, but status flags can also be set for exceptional conditions?
11:52:57 * stepcut is curious to the solution t othis problem, because he is implementing the IEEE decimal spec, which has the same problem
11:52:58 <Heffalump> State and Reader, not StateT and ReaderT btw
11:53:15 <Toxaris> tristes_tigres: I'm not sure when to use arrows and when applicative functors
11:53:26 <Toxaris> Heffalump: hmm yes :)
11:53:26 <mmorrow> stepcut: oooh, check out the gsl source
11:53:27 <Heffalump> stepcut: there's no "solution" as such - either you have inconvenience or you have unsafeness
11:53:28 <tristes_tigres> toxaris: neither am I
11:53:34 <Myoma> shapl!
11:53:40 <tristes_tigres> Txaris: I only began to read about arrows
11:53:51 * sclv rubs his hands together greedily -- *libraries*!
11:53:54 <shapl> Myoma!
11:54:01 <stepcut> Heffalump: well, I don't expect to be able to change the rounding modes in the middle of calculations and be able to use Num
11:54:40 <tristes_tigres> mmorrow: thanks, but that;s in C ?
11:54:41 <sclv> hmm... would instance Num (IO IEFloat) be utterly insane?
11:55:04 <stepcut> sclv: you can't unless you figure out how to create Eq and Show instances for (IO IEFloat)
11:55:24 <sclv> put in dummy ones -- that num requires them is a wart anyway.
11:55:25 <stepcut> sclv: otherwise it might work
11:55:34 <tristes_tigres> sclv: Before writing any libraries some really good at Haskell should figure out, what is the appropriate datatype
11:55:36 <mmorrow> tristes_tigres: yeah, a haskell lib would most likely wrap some C functions. but if it was done in pure Haskell, all the better!
11:55:40 <ziman> shapl
11:55:42 <Toxaris> you don't want IO IEFloat, you want FP IEFloat, with FP implemented like IO, but allowing less operations
11:55:44 <ziman> aargh
11:55:54 <stepcut> sclv: You could use unsafePerformIO for Eq and Show if you are just playing around
11:55:55 <sclv> And FP uses the ST trick?
11:55:56 <mmorrow> stepcut, tristes_tigres: check out http://code.haskell.org/~morrow/code/c/ieee-utils/gsl_ieee_utils.h.txt
11:55:57 <lambdabot> http://tinyurl.com/4lxgar
11:56:19 <stepcut> sclv: yeah, I was thinking about that as well -- can FP be be like ST
11:56:36 <mmorrow> the unzipped dir is http://code.haskell.org/~morrow/code/c/ieee-utils/
11:56:36 <lambdabot> Title: Index of /~morrow/code/c/ieee-utils
11:56:46 <ski> sclv,stepcut : would it need to ?
11:57:01 <mmorrow> they have read.c, print.c, other stuff all more ieee fp
11:57:04 <mmorrow> s/more/for/
11:57:15 <stepcut> sclv: but, Show and Eq are still problematic. because how do you pass the correct rounding mode to show iefloat = runFP iefloat roundingMode
11:57:18 <sclv> FP would have to "sneak in" some actual IO, no?
11:57:20 <Toxaris> FP cannot be like ST, because in reality, there is only one FPU, but ST allows parallel state threads
11:57:25 <tristes_tigres> for instance,  should FP tuype be a monad or an arrow ?
11:57:46 <mmorrow> stepcut: the gsl also implement an approximate fp equality testing algorithm
11:57:56 <jpcooper> are there any other names of the hedge algorithm? I can't find it on Wikipedia
11:58:15 <sclv> show can be disregarded entirely -- its eq is actually useful, and would have to be replaced by operations which return lifted results (oh, and ord too, obv)
11:58:16 <trofi> sampointon: coud you annotate with working example? http://hpaste.org/9870
11:58:17 * ddarius thinks this discussion about monads and arrows is premature at best.
11:58:17 <ski> tristes_tigres : would `join :: FP (FP a) -> FP a' make sense ?
11:58:22 <tristes_tigres> mmorrow: approximate equality testing is total non-iisue
11:58:23 <sclv> FP should obv be an arrow.
11:58:26 <mmorrow> http://www.gnu.org/software/gsl/manual/html_node/IEEE-floating_002dpoint-arithmetic.html
11:58:27 <sclv> erm monad
11:58:27 <lambdabot> Title: IEEE floating-point arithmetic - GNU Scientific Library -- Reference Manual, http://tinyurl.com/5oo8wh
11:58:40 <stepcut> Toxaris: IEFloat would not have to actually use the FPU, it just need to get the right answer somehow
11:58:48 <tristes_tigres> ski: I have very few clues in arrows
11:58:56 <shapl> ziman: Just got the joke?
11:58:57 <mmorrow> tristes_tigres: i'm just saying that there is an implem in the gsl of a nontrivial approximate equality algorithm
11:59:07 <ski> (tristes_tigres : `join' is a basic monad operation)
11:59:10 <shapl> Myoma: So why myoma?
11:59:11 <Toxaris> stepcut: oh interesting.
11:59:23 <mmorrow> found it
11:59:25 <mmorrow> http://www.gnu.org/software/gsl/manual/html_node/Approximate-Comparison-of-Floating-Point-Numbers.html#index-gsl_005ffcmp-133
11:59:27 <lambdabot> Title: Approximate Comparison of Floating Point Numbers - GNU Scientific Library -- Ref ..., http://tinyurl.com/472uw3
11:59:31 <tristes_tigres> ski: right
11:59:32 <Myoma> shapl, no specific reason .
11:59:52 <mmorrow> "The following function implements the approximate floating-point comparison algorithm proposed by D.E. Knuth in Section 4.2.2 of Seminumerical Algorithms (3rd edition)."
11:59:54 <Toxaris> stepcut: so couldn't you make the rounding mode a (static) property of the number, then
12:00:05 <stepcut> Toxaris: obviously, it would not be very fast with out FPU though.
12:00:10 <sclv> alternately one could declare a MonadFP class and have both ST and IO implement it...
12:00:24 <mmorrow> err, i meant s/equality/comparison/
12:00:43 <sampointon> trofi: you don't get much benefit with all of them being of different arity, I don't think there's a shortcut
12:00:50 <sclv> the threading issues are painful though, yes.
12:00:59 <tristes_tigres> this is the important reference : "What Every Computer Scientist Should Know About Floating-Point Arithmetic", by David Goldberg
12:01:30 <stepcut> Toxaris: yes, I suggested that earlier. You can make a number of the settings be a static part of the type, and use newtype (or something) to define additional types with different settings -- provided you don't want to switch rounding modes in the middle of a calculation (though that could be done by switching the type as well)
12:01:33 <sclv> Although with a distinct FP monad one could concievably have runFP use a top level MVar...
12:01:43 <stepcut> Toxaris: signalling would still be an issue though
12:02:02 <Toxaris> sclv: why not just use stToIO to convert ST-based floating point operations to IO?
12:02:08 <heavensrevenge> ive always had this good idea about floating point
12:02:15 <tristes_tigres> Knuth is not really an expert on floating point
12:02:21 <mmorrow> heh
12:02:35 <tristes_tigres> for that, try Kahan or his pupils
12:02:38 <heavensrevenge> to have a pivot point which would be 0, and not have only 1/0, but a fluctuation between -1 and 1
12:02:54 <heavensrevenge> if u loo at a circle from the side, its a 2 dimentional line
12:03:17 <tristes_tigres> heavensrevenge: read and article http://docs.sun.com/source/806-3568/ncg_goldberg.html
12:03:21 <heavensrevenge> if sumthing can spin around a pivot point, like... 2 beer bottles for example, 1 beer as a pivot, and 1 beer orbiting around
12:03:30 <sclv> Kahan is great -- so singleminded.
12:03:34 <ziman> shapl, no, i intended to write shapl1' but somehow i screwed that :)
12:03:36 <heavensrevenge> it would overlap along the axis in 2 dimensions and be 0
12:03:39 <shapl> ziman: haha
12:03:40 <sclv> he's like a force of numerical nature.
12:03:49 <jpcooper> the link to TkHaskell on http://www.haskell.org/libraries.html is old
12:03:49 <lambdabot> Title: Libraries and Tools for Haskell
12:03:51 <heavensrevenge> and as it reaches the outmost point, it would be 1
12:03:52 <ziman> however, it's good to see that i'm not the only lazy one here ;)
12:04:00 <heavensrevenge> and as it goes back to 0, then to -1 and back to 0
12:04:32 <tristes_tigres> sclv: he designed the Intel floating point coprocessor
12:04:51 * stepcut wonders if ieee floating point would be easier in DDC
12:04:52 <heavensrevenge> and i want to make a computer that will use slight magnetics to controll the speed of a spin around a pivot point :P
12:04:54 <tristes_tigres> really clever guy
12:05:00 <sclv> my impression hes he also wrote huge amounts of the standard.
12:05:08 <sclv> s/hes/is/
12:05:12 * Myoma just cannot understand why floating point is so involved
12:05:15 <heavensrevenge> that dude at berkeley was pretty gud
12:05:15 <tristes_tigres> sclv: or at least influenced
12:05:29 <tristes_tigres> Myoma: try doing some
12:05:37 <Myoma> some what
12:05:39 <pozic> What's the consistency between scanl - foldl and scanr and foldr? scanl can work on infinite lists, scanr cannot, foldl cannot, but foldr can.
12:05:55 <tristes_tigres> Myoma: wrote a solver for linear equations with 10 unknowns
12:06:01 <tristes_tigres> write
12:06:03 <sclv> pozic -- think it through.
12:06:08 <sclv> @src scanl
12:06:08 <lambdabot> scanl f q ls = q : case ls of
12:06:08 <lambdabot>     []   -> []
12:06:08 <lambdabot>     x:xs -> scanl f (f q x) xs
12:06:14 <sclv> @src scanr
12:06:15 <lambdabot> scanr _ q0 []     =  [q0]
12:06:15 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
12:06:15 <lambdabot>     where qs@(q:_) = scanr f q0 xs
12:06:28 <tristes_tigres> myoma: try writng some robust numerical function ad you'll see
12:06:33 <heavensrevenge> 1 way in either case cant be true in all cases
12:06:33 <Myoma> tristes_tigres: I'm don't do numbers, I would do that symbolically
12:06:42 <pozic> sclv: I read the report and they said there was consistency between scanl and scanr.
12:06:53 <tristes_tigres> Myoma : what about 1000 unknowns ?
12:06:59 <pozic> sclv: I am talking about the consistency between the scan* and fold* functions.
12:07:03 <Myoma> tristes_tigres: my program would probably take too long
12:07:07 <pozic> sclv: it seems there isn't any.
12:07:11 <tristes_tigres> myoma: this is not really large system at all
12:07:23 <int-e> > (scanl (+) x [a,b], foldl (+) x [a,b])
12:07:25 <lambdabot>  ([x,x + a,x + a + b],x + a + b)
12:07:33 <int-e> > (scanr (+) x [a,b], foldr (+) x [a,b])
12:07:34 <sampointon> trofi: the other option is to use do-notation and the list monad
12:07:35 <lambdabot>  ([a + (b + x),b + x,x],a + (b + x))
12:07:40 <tristes_tigres>  myoma: taking too long is not the worts part of it
12:07:41 <ziman> in my opinion it's perfectly consistent and intuitive that foldl folds from the left and scanl scans from the left
12:08:05 <mmorrow> most times you can't solve a pde exactly and have to approximate the solution numerically
12:08:07 <int-e> scanl and foldl both associate to the left, scanr and foldr associate to the right
12:08:08 <tristes_tigres> myoma: if you do it not knowing what you are doing, it would break down on perfectly good systems
12:08:18 <sclv> ?ty scanl
12:08:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:08:20 <sclv> ?ty foldl
12:08:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:08:22 <tristes_tigres> mmorrow: yes
12:08:26 <sclv> ^^ consistency
12:08:27 <ziman> scanl is like foldl producing intermediate results
12:08:34 <shapl> heavensrevenge: sounds nifty
12:08:49 <shapl> heavensrevenge: I think that sort of magnetic computer was done in the 60s
12:08:58 <pozic> ziman: and scanr is like foldr producing intermediate results?
12:09:02 <heavensrevenge> to have 3 values instead of 2 would help
12:09:02 <tristes_tigres> myoma: or it would give very imprecise results
12:09:14 <int-e> scanr is weird.
12:09:18 <heavensrevenge> it would make fp and even faster computing great
12:09:27 <pozic> int-e: I was trying to let ziman walk in a trap.
12:09:28 <heavensrevenge> but the magnetics would only be used for control and such
12:09:36 <int-e> pozic: yes, except the "intermediate results" come after the "final result"
12:09:37 <tristes_tigres> myoma: http://docs.sun.com/source/806-3568/ncg_goldberg.html
12:09:44 <heavensrevenge> or a spinning object would be horribly har tocontrol and read
12:10:01 <pozic> int-e: right, that's what's bothering me consistency wise.
12:10:05 <int-e> does anybody have a good use for scanr?
12:10:14 * tristes_tigres thinks that someone with VERY good knowledge of Haskell ought to define the type for FP 
12:10:29 <int-e> pozic: the l / r is really about how the list elements are combined, and it's consistent in that regard.
12:10:41 <pozic> int-e: I used scanl numerous times, but scanr not so.
12:10:44 <tristes_tigres> preferably someone of GHC authors
12:10:55 <int-e> > map (take 5) $ scanr (:) [] [1..]
12:10:57 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[7...
12:11:00 <carp> <heavensrevenge> or a spinning object would be horribly har tocontrol and read
12:11:00 <carp> <pozic> int-e: right, that's what's bothering me consistency wise.
12:11:17 <ziman> umm, it's not
12:11:17 <int-e> so scanr can be used to implement 'tails', hmm. not too useful.
12:11:28 <carp> yikes, oops
12:11:35 <sclv> tristes_tigres: I think primitive bindings would be the start, and then different apis could be written on top.
12:11:47 <sclv> and finally, optimization with RULES could come at a late stage.
12:11:48 <int-e> pozic: same here
12:11:55 <heavensrevenge> well, witha slight electromagnetic force, you could push an object to one side of a circle of its pivot point
12:12:10 <tristes_tigres> sclv: sorry, I thought bindings == API ?
12:12:19 <heavensrevenge> and it could do it in parallel to negate its - and + charges
12:12:38 <ddarius> heavensrevenge: You are having a conversation with yourself.
12:12:52 <mmorrow> tristes_tigres: i think computer science knowledge and numerical analysis knowledge are orthogonal for the most part
12:12:55 <heavensrevenge> sry?
12:12:56 <tristes_tigres> for instance, should it be a monad or some other tiricky type ?
12:13:05 <ziman> hm, it is.. but the list is in the order i wouldn't expect :)
12:13:20 <pozic> shapr is now left handed?
12:13:21 <heavensrevenge> its ok, im going to make a prototype in my electronics engineering couses' last year
12:13:24 <sclv> tristes_tigres: bindings == the low level creation of appropriate types, and importing foreign functions.
12:13:31 <tristes_tigres> mmorrow: they needn't be, but I think you are right
12:13:34 <heavensrevenge> anywayz, ttyl then
12:13:39 <sclv> then you can make monads out of them or anything else you want, later.
12:13:47 <pozic> shapr, shapl: hi
12:14:03 <mmorrow> tristes_tigres: hence, you should write a haskell fp lib for hackage!! ;)
12:14:11 <pozic> Look 5000 people in #haskell ;)
12:14:53 <tristes_tigres> sclv: you mean the internal plumbing, so to speak ? I think that the big issue is deciding, ehat Haskell type to use
12:15:15 <shapl> pozic: hi hi!
12:15:23 <sclv> tristes_tigres: well, true, but with the plumbing out of the way then lots of different implementations can be built relatively trivially...
12:15:24 <tristes_tigres> mmorrow: my knowledge of Haskell is work in progress
12:15:35 <shapl> pozic: Do I know you?
12:15:37 <ski> > zipWith (\i -> (++ (".." ++ replicate i ')')) . take (5*i)) [6,5..] $ scanr (\n s -> concat ["(",show n," + ",s,")"]) undefined [0..]
12:15:38 <lambdabot>  ["(0 + (1 + (2 + (3 + (4 + (5 + ..))))))","(1 + (2 + (3 + (4 + (5 + ..)))))"...
12:15:44 <shapl> pozic: Acutally, I've been left handed most of my life.
12:16:01 <bjrn> Haskell is really getting popular. Lots of articles at reddit lately
12:16:04 <tristes_tigres> sclv: plumbing is the easy part, it is known from imperative languages how to do that
12:16:07 <shapl> bjrn: yeah!
12:16:11 <ddarius> shapl: When were you not left-handed?
12:16:11 <sclv> e.g. we have bindings to graphics libraries, and then folks who write experimental FRP implementations on top of them.
12:16:14 <mmorrow> tristes_tigres: yeah, it is true that the haskell interface presented to the programmer would be important
12:16:17 <ski> pozic : that's another example of `scanr' working just fine on an infinite list
12:16:28 <tristes_tigres> mmorrow: it is crucial !
12:16:39 <tristes_tigres> it is the non-trivial part
12:16:49 <mmorrow> tristes_tigres: but any interface is better than no interface
12:16:51 <tristes_tigres> the FP itself is implemented in the CPU
12:17:07 <tristes_tigres> you just need to use it
12:17:23 <int-e> > map (take 10 . show) $ scanr (+) x [0..]
12:17:25 <lambdabot>  ["0 + (1 + (","1 + (2 + (","2 + (3 + (","3 + (4 + (","4 + (5 + (","5 + (6 + ...
12:17:25 <mmorrow> and as you said, haskell is lacking in this area
12:17:49 <ski> @type \hands -> shapl (flip hands)
12:17:51 <lambdabot> Not in scope: `shapl'
12:18:00 <mmorrow> tristes_tigres: imo writing a lib would be a great way to learn Haskell
12:18:01 <tristes_tigres> mmorrow: I think that once the type signature is written, the rest is trivial
12:18:13 <mmorrow> yes! (mostly)
12:18:34 <tristes_tigres> mmorrow: can it be done in Hakell without low-level hacking in GHCC ?
12:18:36 <mmorrow> (or the data decl, or class decl, or ...)
12:18:40 <ski> @let shapl hands = shapr (flip hands)
12:18:41 <lambdabot> <local>:3:14: Not in scope: `shapr'
12:18:45 <pozic> > head $ scanl (flip (:)) [1..]
12:18:46 <lambdabot>  Couldn't match expected type `[a]'
12:18:47 <ski> bah
12:18:54 <pozic> > head $ scanl (flip (:)) [] [1..]
12:18:56 <lambdabot>  []
12:18:57 <sclv> tristes_tigres: it would be an exercise in the foriegn function interface mostely
12:19:03 <Myoma> awww
12:19:13 <pozic> > head $ scanr (:) [] [1..]
12:19:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:19:17 <tristes_tigres> sclv : I see
12:19:32 <Myoma>  :t shapl
12:19:34 <tristes_tigres> C source with asm() calls
12:19:56 <sclv> I'm sure there's a good c library already to bind to ??
12:20:05 <tristes_tigres> sclv: there may be
12:20:15 <mmorrow> tristes_tigres: hmm, i think it would depend on what it's doing exactly, but it would probably be easier to use C directly, and use the FFI to wrap it than spend a bunch of time messing with GHC internal reps for stuff
12:20:41 <ski> @users
12:20:41 <lambdabot> Maximum users seen in #haskell: 481, currently: 463 (96.3%), active: 31 (6.7%)
12:20:43 <tristes_tigres> sclv: but really, the arithmetic ops should be done by compiler, not thrd-party library
12:21:15 <sclv> tristes_tigres: but the arithmetic ops are going to be compiled down to the same thing regardless...
12:21:16 <mmorrow> but then again. i'm not sure exactly what exactly is being implemented in the hypothetical library we're refering to
12:21:41 <tristes_tigres> mmorrow: IEEE 754 standard is fully implemented in CPU
12:22:09 <mmorrow> ok, so what exactly needs to happen to set the rounding mode (assume you're using C)
12:22:11 <tristes_tigres> mmorrow: the languge must give a programmer way to access the functionality
12:22:34 <tristes_tigres> mmorrow: you set some bits in the CPU's floating point status register
12:22:34 <mmorrow> tristes_tigres: but since Haskell doesn't, we need to think of another way
12:23:59 <mmorrow> tristes_tigres: excellent. ok, so probably write  fp.{h,c} with  #ifdef ... #elsif X86 # ... #endif      and do what needs to be done  a single C function
12:24:12 <mmorrow> then wrap that C function in a Haskell module
12:24:16 <mmorrow> easy as pie
12:24:19 <tristes_tigres> mmorrow: like I said, that's the easy part
12:24:39 <mmorrow> well, you don't have to come up with all the higher level datatype/etc in that module
12:24:51 <mmorrow> it'd be the base on which other modules build on
12:24:56 <tristes_tigres> mmorrow: the non-trivial part is what is the type for FP numbers look like
12:25:06 <hackage> Uploaded to hackage: thrist 0.1
12:25:22 <Myoma> ?hackage thrist
12:25:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/thrist
12:25:47 <mmorrow> tristes_tigres: well, am I mistaken to think that once the rounding mode has been set, then all computations (e.g.  (1::Double) + 0.5) would be effected ?
12:26:11 <tristes_tigres> mmorrow: correct
12:26:34 <mmorrow> ok, perfect. so i don't see the need to define any additional types (wrt setting the rounding mode)
12:26:55 <tristes_tigres> mmorrow: suppose I have some code for an algoithm
12:27:56 <tristes_tigres> mmorrow: and I want to run it with 2 different rounding modes
12:28:19 <pozic> tristes_tigres: you make a typeclass for rounding and you are done.
12:28:22 <sclv> The thing is that the C bindings might be non-trivial, but they're the pain... once they're in place, lots of folks will come up with nice ways to organize them.
12:28:25 <tristes_tigres> mmorrow: and I want to notice, when intermediate results began to diverge wildly
12:28:53 <sclv> pozic: that makes sense if you're not using ieee.
12:29:00 <tristes_tigres> (if they do begin to diverge)
12:29:03 <sclv> but if you are, then there's all the IO issues to deal with.
12:29:14 <pozic> sclv: what are you talking about?
12:29:28 <tristes_tigres> sclv: precisely, IEEE FP is not pure
12:29:30 <pozic> This is just premature optimization, nothing else.
12:30:06 <tristes_tigres> pozic: give an example of this typeclass
12:30:11 <Philippa> pozic: are you under the illusion that floating point arithmetic is well-behaved, by any chance?
12:30:21 <pozic> Philippa: define well-behaved.
12:30:23 <sclv> pozic: so you're suggesting emulated fpu usage?
12:30:30 <tristes_tigres> pozic: FP arithmetic is not even associative
12:30:39 <pozic> tristes_tigres: so?
12:30:56 <pozic> tristes_tigres: it's a complicated formal system.
12:31:06 <Philippa> pozic: "makes a sane instance of Num", "supports algebraic laws that one might typically expect of a numeric type"
12:31:07 <sclv> if you don't want any optimizations then forget even that and just use the exact interval arithmatic packages.
12:31:10 <pozic> tristes_tigres: if you don't like that formal system, use/define another one.
12:31:50 <tristes_tigres> pozic: formal system is already defined. By the IEEE standard 754, implemented by all major CPUs
12:31:58 <pozic> sclv: I am suggesting that one writes an algorithm in some preferred language and only then worries about how it works.
12:32:18 <tristes_tigres> pozic: the question is what the high-level type for FP numbers should look like
12:32:27 <Philippa> pozic: this is also what everyone else is suggesting. The question is how to embed that language into Haskell
12:32:33 <dsrogers> can I do TH from with ghci?
12:32:36 <mmorrow> tristes_tigres: ok, http://hpaste.org/9872
12:32:38 <dsrogers> *within
12:32:41 <visof> this function was working last time but i don't know what i did ,it is removing multiples except the number we want to remove its multiples, the function is here http://hpaste.org/9871
12:32:43 <mmorrow> dsrogers: yes
12:32:43 <pozic> dsrogers: yes
12:32:48 <mmorrow> dsrogers: do
12:32:53 <mmorrow> :set -XTemplateHaskell
12:33:04 <dsrogers> [t| ID () -> IO() |] >>= expandSynonyms2
12:33:07 <dsrogers> > [t| ID () -> IO() |] >>= expandSynonyms2
12:33:08 <lambdabot>  Parse error at "->" (column 11)
12:33:08 <tristes_tigres> mmorrow: I'll take look at it
12:33:16 <dsrogers> that's what I get locally too
12:33:58 <pozic> Philippa: I don't really understand that question. The person posing the question surely must already have the answer, as he/she thinks there's something wrong.
12:34:01 <tristes_tigres> mmorrow: that code sets rounding mode globally, right ?
12:34:18 <dsrogers> do I need to pass a flag to ghci or something?
12:34:22 <mmorrow> the corresponding C code would, yes
12:34:38 <dsrogers> oh.
12:34:41 <Philippa> pozic: simply using the existing float types is underspecified for a number of purposes
12:34:41 <mmorrow> (or whatever that C code does, the haskell function does)
12:34:42 <dsrogers> I figured it out.
12:34:44 <dsrogers> thanks.
12:34:58 <tristes_tigres> mmorrow: wouldn't that constitute not pling nice
12:35:13 <tristes_tigres> mmorrow: what about purity of the Haskell ?
12:35:14 <mmorrow> tristes_tigres: heh, i suppose. is there a way to play nice?
12:35:24 <tristes_tigres> mmorrow: that's what I am asking
12:35:27 <Philippa> that doesn't mean that the preferred embedding is known, just that we know the existing one isn't good enough when you need to eg reproduce the same numeric results on more than one machine
12:35:27 <mmorrow> unsafePerformIO (setRoundingMode RoundUp)
12:35:32 <mmorrow> fixed
12:36:09 <mmorrow> (one would have to make sure that's evaluated before computations of course)
12:36:10 <int-e> wee. good luck with threads.
12:36:43 <tristes_tigres> mmorrow: what if somebody else changes those status bits on me ?
12:36:45 <pozic> Philippa: it's specified ok, it's just that those people want to use some hypothetical implementation that's as fast as hardware floats, but with different properties (associative operators for example).
12:36:53 <sclv> tristes_tigres: fenv.h!
12:36:59 <mmorrow> yeah, it'd probably be better to set that in main, before any forkIOs or pure functions that expect the rounding mode to be a particular mode
12:37:05 <Philippa> pozic: no, it's not specified OK. Evaluation order isn't defined
12:37:21 <mmorrow> tristes_tigres: you're SOL
12:37:22 <pozic> Philippa: that's also a specification.
12:37:24 <sclv> just the low level functions to access that would be nice...
12:37:31 <Philippa> and as has already been indicated, that renders it impure
12:37:50 <tristes_tigres> mmorrow: not me - Haskell :-) I always have my C and fortran 95 :-)
12:37:56 <mmorrow> tristes_tigres: i mean, how would one deal with that possibility in C. however that would happen, that's the case here/
12:38:00 <pozic> Philippa: ok, maybe I didn't get this point.
12:38:03 <Philippa> pozic: believe it or not, "OK" doesn't translate to simply "there is a spec"
12:38:25 <sclv> I think a top level mvar would be a big help
12:38:38 <mmorrow> tristes_tigres: oh, i see. i don't believe haskell will touch the rounding mode. but it'd be easy to find out if it does.
12:38:43 <sclv> and a restricted monad whose runFP locks that mvar
12:38:49 <Deewiant> somewhat related, is there a "round using current rounding mode, whatever it is" function?
12:38:50 <Philippa> pozic: this is why I asked if you were under the impression that floats are well-behaved. Next time, don't try to out-pedant me
12:38:54 <pozic> Philippa: are you saying that a + b for some numbers a and b can return different answers in Haskell?
12:39:03 <dsrogers> can I get a show implementation for a Q Type from somewhere?
12:39:06 <tristes_tigres> mmorrow: The haskell standard itself has a gap on this whole issue
12:39:20 <mmorrow> tristes_tigres: that module i pasted should also have a        getRoundingMode :: IO IEEERoundingMode
12:39:23 <Philippa> pozic: I'm saying that in the specific case of floating point numbers, yes, it depends on the context in which it's evaluated
12:39:34 <pozic> Philippa: then Haskell is broken.
12:39:45 <tristes_tigres> pozic: no it doesn't
12:39:52 <Philippa> pozic: specifically, the embedding of floats is
12:39:57 <tristes_tigres> pozic: it is the correct behaviour
12:40:07 <sclv> and if you can only set that rounding mode inside the restricted monad, and only with functions such as setRoundingMode :: RoundingMode -> FP a -> FP a
12:40:13 <sclv> then you're fine within that code
12:40:18 <tristes_tigres> pozic: that FP computation result is affected by some other things
12:40:24 <sclv> and we can consider everything outside that monad underspecified,.
12:40:31 <ski> sclv : s/set/local/ ?
12:40:44 <sclv> ski: yep, or with
12:41:08 <sclv> and you can also provide the unsafe primitive functions.
12:41:13 <pozic> As a + b /= b + a, a compiler reordering the arguments would simply be wrong.
12:41:21 <shrimpx> is this pure functional programming thing still going strong?
12:41:30 <tristes_tigres> pozic: I think a+b == b+a
12:41:30 <mmorrow> tristes_tigres: the way to find out would be to ask in #ghc. then to look at the ghc src if necessary.
12:41:34 <Philippa> pozic: it's much, much worse than that
12:41:50 <tristes_tigres> pozic : but (a+b)+c != a + (b+c)
12:41:52 <sclv> pozic: however, a + b + c /= a + c + b
12:41:57 <dsrogers> is there a way to print something inthe Q monad?
12:42:08 <ddarius> dsrogers: Yes.
12:42:25 <dons_> interesting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/thrist-0.1
12:42:26 <sclv> seriously. just bindings to fenv.h on hackage would be a great start
12:42:27 <lambdabot> Title: HackageDB: thrist-0.1, http://tinyurl.com/5uudck
12:42:27 <mmorrow> dsrogers: oh, i missed you question
12:42:29 <dsrogers> I said that wrong
12:42:34 <mmorrow> dsrogers: just do
12:42:39 <ski> @check \x y z -> x + (y + z) == (x + y) + (z :: Float)
12:42:40 <lambdabot>  "Falsifiable, after 7 tests:\n-4.5\n4.0\n-0.6\n"
12:42:44 <mmorrow> runQ [t| forall a. a -> Int |]
12:42:57 <pozic> tristes_tigres: yes, I think so too.
12:43:05 <tristes_tigres> ski: geee
12:43:11 <tristes_tigres> ski: exactly
12:43:20 <mmorrow> unQ :: Q a-> a = unsafePerformIO . runQ     is handy  in ghci (and some other places sa well)
12:43:40 <Deewiant> @check \x y z -> x + z + y == (x + y + z :: Float)
12:43:42 <lambdabot>  "Falsifiable, after 14 tests:\n-1.8333333\n-0.8333334\n3.2\n"
12:43:51 <tristes_tigres> deewiant : :-)
12:44:00 <pozic> Philippa: how is it much worse?
12:44:38 <ddarius> mmorrow: wtf?
12:45:12 <dsrogers> mmorrow: I don't want to evaluate the Q in ghci.
12:45:22 <dsrogers> I want to pretty print the syntax it would generate
12:45:28 <mmorrow> ddarius: wtf wtf?
12:45:34 <ddarius> mmorrow: Just runIO (print foo)
12:45:42 <tristes_tigres> FP numbers is fairly low-level stuff
12:45:58 <mmorrow> dsrogers: oh, ok. do you want to pretty print the AST rep or the haskell src rep ?
12:46:00 <sclv> > concat $ fix ("wtf ":)
12:46:07 <dsrogers> mmorrow: either.
12:46:08 <lambdabot>  "wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf...
12:46:14 <dsrogers> mmorrow: ideally both
12:46:18 <pozic> That thrist "package" contains less than 1000 bytes of code. Shouldn't there be some lower bound on the amount of code in a package?
12:46:22 <ddarius> sclv: You need to add a ? at the end.
12:46:29 <mmorrow> ddarius: print =<< runQ [|()|]
12:46:42 <bjrn> So regarding binary-strict: getAsWordXX doesn't work, however getBit works fine: http://hpaste.org/9869#a1
12:46:52 <sclv> > (++"?) . concat $ fix ("wtf ":)
12:46:53 <lambdabot> Unbalanced parentheses
12:46:54 <mmorrow> dsrogers: i'll paste
12:47:02 <sclv> > (++"?") . concat $ fix ("wtf ":)
12:47:04 <lambdabot>  "wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf...
12:47:08 <sclv> much better!
12:47:23 <sclv> that ? makes the whole thing work.
12:47:31 <ddarius> Also concat . fix . (:) = cycle
12:47:47 * tristes_tigres will ask the question at #ghc
12:49:17 <Myoma> that one has a clever proof
12:49:40 <Trinithis> wtf?
12:51:30 <mmorrow> dsrogers: http://hpaste.org/9873
12:51:45 <pozic> Philippa: I merely said that floating point numbers come with some semantics. That some people don't like this semantics is irrelevant. Can you be less vague?
12:52:57 <mmorrow> tristes_tigres: nice. i can help you locate something in the ghc src if need be.
12:53:54 <tristes_tigres> mmorrow: thanks, but I think it should be designed top-down
12:54:59 <mmorrow> tristes_tigres: sure. but if ghc is manipulating the fpenv, then you may need to know how, and if no one know how, but knows where ...
12:55:11 <Myoma> pozic: no there should not
12:55:32 <BONUS> what exactly constitutes a "combinator"
12:55:33 <BONUS> like
12:55:35 <BONUS> what's the definition
12:55:46 <BONUS> i realised today that i'm not completely clear on that
12:55:46 <Myoma> BONUS:  a lambda term with no free variables
12:56:08 <ddarius> BONUS: "combinator" is often used as a buzzword.
12:56:12 <BONUS> aha so that its contents depend only on the arguments?
12:56:13 <Myoma> (\x -> x) (\f y x -> f x y) are, (\e -> u) isn't
12:56:19 <BONUS> aha
12:56:23 <pozic> BONUS: function used as operator mostly.
12:56:24 <BONUS> that's what i kind of thought
12:56:55 <BONUS> kewl
12:59:31 <Beelsebob> hmm, interesting... C programmers don't realise that their SIGSEGVs are type errors apparently... http://games.slashdot.org/comments.pl?sid=654821&cid=24716845
12:59:32 <lambdabot> Title: Firefox Gets Massive JavaScript Performance Boost
13:00:01 <BONUS> haha
13:00:53 <Olathe> That's an interesting idea. Why do you think they're type errors ?
13:00:58 <dsrogers> now when I try to ppQ my method I get: Template Haskell error: Can't do `reify' in the IO monad
13:00:58 <dsrogers> *** Exception: user error (Template Haskell failure)
13:01:18 <Beelsebob> Olathe: they're type errors because they're errors that get completely elliminated when you have a strong type system
13:01:30 <Beelsebob> when was the last time you saw a Haskell program cause a SEG fault
13:01:36 <mmorrow> dsrogers: yeah, sucky. you need an instance of Lift for Info.
13:01:38 <Olathe> How are they eliminated by it ?
13:01:42 <trofi> :D
13:01:44 <Olathe> Oh, I haven't yet.
13:01:53 <mmorrow> i have instance of Lift for all of the TH types in a darcs repo
13:02:00 <Beelsebob> Olathe: because the type system guarentees that you don't do things like dereference an integer
13:02:12 <shapl> @quote
13:02:12 <lambdabot> MyCatVerbs says: does that make any sense, or should I go find some gin and try to explain that again?
13:02:23 <mmorrow> dsrogers: it's a package that i've gotta put on hackage
13:02:30 <Olathe> Beelsebob: Ahh.
13:02:39 <pozic> Beelsebob: but doesn't that take all the fun out of programming?
13:03:00 <Beelsebob> pozic: no -- it just moves the fun -- now *you* get all the fun when the compiler complains, instead of your users getting the fun :P
13:03:04 <mmorrow> dsrogers: tell me one thing first though, do you happen to have hs-plugins installed. if not, i'll do a quick mod to the repo so you can build/install it
13:03:11 <Beelsebob> you wouldn't want your users to have all the fun would you pozic?
13:03:19 <trofi> @type error
13:03:20 <lambdabot> forall a. [Char] -> a
13:03:24 <dsrogers> how do I tell if hs-plugins is installed?
13:03:27 <mmorrow> * ... do you happen to have hs-plugins installed?
13:03:35 <mmorrow> dsrogers: ok, you dont
13:03:44 <mmorrow> gimme a few minutes
13:03:47 <Olathe> I haven't encountered pointers in Haskell yet. Does Haskell have pointers ?
13:04:03 <trofi> @hoogle ForeignPtr
13:04:03 <lambdabot> Foreign.ForeignPtr data ForeignPtr a
13:04:03 <lambdabot> module Foreign.ForeignPtr
13:04:03 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
13:04:08 <Olathe> Ahh, OK.
13:04:10 <Beelsebob> Olathe: yes and no -- for the most part, the runtime deals with them for you
13:04:12 <Myoma> Olathe: STRef
13:04:23 <Beelsebob> but you can get at them with the FFI or various other nasty corners of darkness
13:04:25 <Olathe> Thanks :)
13:04:58 <pozic> Beelsebob: I was just trolling.
13:05:10 <Beelsebob> pozic: I know, I was setting the troll on fire :P
13:05:14 <Beelsebob> :D
13:06:01 <sclv> pointers in haskell: http://mauke.ath.cx/stuff/haskell/hell.hs
13:06:05 <Philippa> pozic: re vagueness, you have been given a number of important properties that IEEE FP does not possess. How much less vague do you need?
13:06:26 <pozic> Beelsebob: you can charge extra for  "A segmentation fault does look complicated, you must be really smart!".
13:06:26 <Beelsebob> sclv: okay, that's fucking evil
13:06:40 <Deewiant> sclv: very platform-dependent I take it?
13:06:52 <dsrogers> morrow: I had no idea that actually examining the code that TH produces would be so hard
13:06:55 <Beelsebob> pozic: awesome response -- I'm going to use that on people that say type errors look complicated
13:07:28 <Philippa> FP - and IEEE especially - is /infamously/ complicated the moment you need serious numerical stability, to the extent that there is an entire field of CS dedicated to the subject
13:08:00 <Olathe> Are there any compilers that automatically optimize for stability ?
13:08:16 <dons> stability? that's an interesting idea.
13:08:23 <dons> adding extra checks and guards?
13:08:29 <Philippa> Olathe: I don't think it's predictable enough
13:08:33 <Olathe> Ahh.
13:08:34 <pozic> Philippa: what properties?
13:09:10 <Olathe> Oh, no, I mean numeric stability.
13:09:17 <Philippa> pozic: it's impure, that's a pretty massive one. If you need exact equality rather than some near equivalence then most algebraic properties go out of the window or only have extremely restricted versions applicable too
13:09:35 <Philippa> end result: it's extremely sensitive to operations being reordered
13:10:05 <Philippa> it's not a case of whether the compiler can do a + b => b + a
13:10:20 <Philippa> evaluation order has to be fully defined
13:10:57 <Philippa> oh, and /then/ the whole thing's stateful in another sense - rounding modes etc etc
13:11:14 <sclv> monadic computation, by forcing explicit thought about sequencing, could actually be a big win for haskell here.
13:11:24 <dsrogers> pardon?  is someone trying to achieve numerical stability in haskell?
13:11:29 <Myoma> hi Philippa
13:11:35 <Philippa> evenin' MyCatVerbs
13:11:38 <Philippa> er, Myoma
13:11:41 <dsrogers> is that even possible when using fp?
13:12:13 <pozic> Philippa: the assembly floating point language instructions won't get reordered by the CPU, so any other language implementation should also not do so. That's the same as you said, only you see it as a huge problem.
13:12:30 <Philippa> pozic: no, it's not
13:12:35 <trofi> > fromJust Nothing :: Maybe Int
13:12:37 <lambdabot>  mueval: *** Exception: Maybe.fromJust: Nothing
13:12:49 <Myoma> Philippa, just curious, do IFL papers get released to the common folk (i.e. me), It doesn't look like the site got updated
13:12:53 <trofi> > minimum [Nothing, Just 1, Just 2]
13:12:55 <Philippa> Haskell *doesn't have an order to start with*
13:12:55 <lambdabot>  Nothing
13:13:28 <Philippa> Myoma: the draft proceedings is released much later. I imagine I'll have a backup of my full paper on my site somewhere after the deadline for that though, and likewise my slides
13:13:30 <dsrogers> Philippa: it doesn't start with an order, but you can always add one if you need it.
13:13:33 <pozic> Philippa: if you don't specify order, you just don't care.
13:13:43 <Myoma> oh cool
13:13:56 <trofi> > minimum $ map fromJust $ filter (\x -> case x of Just _ -> True; _ -> False) [Nothing, Just 1, Just 2]
13:13:58 <lambdabot>  1
13:14:15 <Myoma> :t sequence . liftM minimum
13:14:17 <lambdabot> forall (m :: * -> *) a. (Ord (m a), Monad m) => [[m a]] -> m [a]
13:14:21 <mauke> > catMaybes [Nothing, Just 1, Just 2]
13:14:21 <Philippa> pozic: yeah, and unsafePerformIO's all cuddly and doesn't deserve the unsafe at all
13:14:23 <lambdabot>  [1,2]
13:14:47 <Philippa> pozic: or to rephrase - you have a major misunderstanding about the nature of the languages involved here
13:14:59 <trofi> how to easily count minimal from justs? and return Nothing if all is nothing?
13:15:10 <trofi> > (Just 1) && (Just 2)
13:15:11 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Maybe t'
13:15:23 <Botje> trofi: what do you want to do?
13:15:28 <Botje> count the number of Just items?
13:15:32 <Myoma> > map (maybe 0 (const 1)) [Nothing, Just (), Nothing, Nothing, Just ()]
13:15:33 <lambdabot>  [0,1,0,0,1]
13:15:39 <trofi> fint minimal from them
13:15:46 <trofi> finD minimal from them
13:16:15 <trofi> safe_minimum :: Maybe a -> Maybe a
13:16:16 <Myoma> @let list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
13:16:18 <lambdabot> Defined.
13:16:41 <Botje> [Maybe a] -> Maybe a, surely?
13:16:46 <trofi> ah yes
13:16:55 <Myoma> :t list Nothing (\x xs -> Just . minimum $ (x:xs)) . catMaybes
13:16:57 <lambdabot> forall a. (Ord a) => [Maybe a] -> Maybe a
13:17:07 <Myoma> @pl (\x xs -> Just . minimum $ (x:xs))
13:17:07 <lambdabot> ((Just . minimum) .) . (:)
13:17:25 <Philippa> pozic: in the meantime, unless you're an expert in both the IEEE FP standards and the semantics of non-strict languages I suggest you accept that there may be an actual problem here because screaming "but undefined means anything is okay!" as if it's a final solution to the problem just demonstrates that you don't know what you're talking about here
13:17:26 <Botje> safe_minimum = minimum `fmap` return . catMaybes
13:17:27 <trofi> > ((Just . minimum) .) . (:) [Nothing]
13:17:28 <lambdabot>  Couldn't match expected type `a1 -> [a]'
13:17:29 <Myoma> > list Nothing (((Just . minimum) .) . (:)) . catMaybes $ [Nothing,Nothing,Noting]
13:17:30 <lambdabot> Terminated
13:17:38 <Myoma> > list Nothing (((Just . minimum) .) . (:)) . catMaybes $ [Nothing,Nothing,Nothing]
13:17:39 <mauke> > case catMaybes [Nothing, Just 1, Just 2] of [] -> Nothing; xs -> Just $ minimum xs
13:17:41 <lambdabot>  Nothing
13:17:41 <lambdabot> Terminated
13:17:47 <Myoma> > list Nothing (((Just . minimum) .) . (:)) . catMaybes $ [Nothing,Just 6,Nothing,Just 2]
13:17:49 <lambdabot>  Just 2
13:18:04 <trofi> @src catMaybes
13:18:04 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:18:08 <Myoma> @undefine list
13:18:09 <lambdabot> Undefined.
13:18:16 <Myoma> @let list nil cons [] = nil ; list nil cons xxs = cons xxs
13:18:18 <lambdabot> Defined.
13:18:28 <Myoma> > list Nothing (Just . minimum) . catMaybes $ [Nothing,Just 6,Nothing,Just 2]
13:18:30 <lambdabot>  Just 2
13:20:46 <trofi> > Nothing <- Just 2
13:20:46 <lambdabot>  Parse error at "<-" (column 9)
13:20:55 <trofi> > do Nothing <- Just 2
13:20:56 <lambdabot>  Parse error at end of input
13:21:12 <trofi> > do { Nothing <- Just 2; return [0] }
13:21:14 <lambdabot>      No instance for (Num (Maybe t))
13:21:14 <lambdabot>       arising from the literal `2' at <i...
13:21:24 <pozic> Philippa: can you show an expression involving floats that returns at least two different answers?
13:21:29 <trofi> > do { Nothing <- Just 2; return 0 } :: [Int]
13:21:30 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Maybe t1'
13:21:48 <BONUS> do { Nothing <- Just 2; return 0 } :: Maybe Int
13:21:52 <BONUS> > do { Nothing <- Just 2; return 0 } :: Maybe Int
13:21:53 <lambdabot>      No instance for (Num (Maybe t))
13:21:53 <lambdabot>       arising from the literal `2' at <i...
13:22:19 <trofi> @src fail Maybe
13:22:19 <lambdabot> Source not found. My brain just exploded
13:22:28 <pozic> Philippa: Haskell doesn't have a formal semantics, btw.
13:22:53 <Saizan_> trofi: what are you trying to write?
13:22:59 <Philippa> gee, I never knew that. Thank you for educating me, I was clearly in desperate need
13:23:14 <Myoma> > maybe [] return $ Nothing
13:23:15 <Philippa> oh, wait, the informal equational semantics are good enough to make the behaviour I'm describing unacceptable
13:23:16 <lambdabot>  []
13:23:17 <Myoma> > maybe [] return $ Just 3
13:23:19 <lambdabot>  [3]
13:23:36 <Myoma> > mapM (maybe [] return) [Just 3,Nothing,Just 2]
13:23:37 <lambdabot>  []
13:23:42 <pozic> Philippa: I am willing to accept that there are informal semantics.
13:23:43 <Myoma> > mapM (maybe [[]] return) [Just 3,Nothing,Just 2]
13:23:45 <lambdabot>      No instance for (Num [a])
13:23:45 <lambdabot>       arising from the literal `3' at <interac...
13:23:54 <Philippa> and no, I can't provide you with such an expression because I'm tired and I have better things to do than grab a copy of the IEEE specs just to construct one
13:24:14 <pozic> Philippa: sure, you are "tired".
13:24:28 --- mode: ChanServ set +o Philippa
13:24:33 <Saizan_> > msum $ map (maybe [] return) [Just 3,Nothing,Just 2]
13:24:35 <lambdabot>  [3,2]
13:24:36 <Philippa> yes, yes I am. I suggest you don't make an implication like that again
13:24:45 --- mode: Philippa set -o Philippa
13:25:15 <tristes_tigres> pozic: see above in the discussion: <ski> @check \x y z -> x + (y + z) == (x + y) + (z :: Float)
13:25:16 <dons> kids, be friendly.
13:25:28 <tristes_tigres> <lambdabot>  "Falsifiable, after 7 tests:\n-4.5\n4.0\n-0.6\n"
13:25:33 <Philippa> all you need to know is that a) for any binary operator, there is no guarantee as to whether the LHS or RHS is evaluated first b) the IEEE float standard's impure. That's enough
13:26:11 <xif> oh, Philippa is being aggressive. what a surprise.
13:26:39 <pozic> tristes_tigres: that's just part of the semantics.
13:26:40 <dons> xif, not helpful.
13:27:19 <dons> remember guys, "The #haskell channel is a very friendly, welcoming place to hang out, teach and learn."
13:27:22 <dons> http://haskell.org/haskellwiki/IRC_channel#Principles
13:27:23 <lambdabot> Title: IRC channel - HaskellWiki
13:27:26 <Philippa> pozic: you should be quite capable of verifying the two things I have just told you for yourself. Alternatively, you could just accept it as a description of the problem domain way back at the start of the argument, including aspects that you weren't originally aware of
13:27:34 <xif> dons: what would be helpful is for people who are oppressive and aggressive by nature, not to have ops.
13:27:42 <LegendaryPenguin> wheres the best place to buy network cable
13:27:49 <tristes_tigres> "pozic: Philippa: can you show an expression involving floats that returns at least two different answers?"
13:27:52 <Myoma> xif, Go to #haskell-blah to metargue about this rubbish
13:27:59 <Myoma> xif, *please*
13:28:01 <tristes_tigres> pozic: there you have one
13:28:15 <xif> Myoma: I can't, since Philippa has ops there as well.
13:28:17 <Philippa> Myoma: actually he's still banned from -blah, though he knows what to do if he wants it lifted
13:28:37 <pozic> tristes_tigres: no, that isn't one.
13:28:48 <xif> Philippa: yeah, I have to agree with you, and be very polite and humble when you deign to grace that channel with your presence and opinions.
13:28:59 <dons> xif, take it out of this channel, please.
13:29:10 <Saizan_> tristes_tigres: those are two different expressions that give different results, even if it'd be nice for them to be equal
13:29:44 <xif> dons: I have not planned to take this any further. all I wanted is to point out that Philippa is all too quick to (ab)use her authority.
13:29:48 <tristes_tigres> Saizan: they will give different results depending on the FPU control register
13:30:05 <dons> xif, ok. thanks. i'm cross with Philippa too.
13:30:24 <tristes_tigres> Phillipa is right on the substance of the argument
13:30:46 <Myoma> dons: it's not the first time pozic has been trolling in this channel
13:30:56 <xif> the substance of the argument was not the issue here, but the use of administrative powers against dissenting opinions.
13:31:19 <Philippa> xif: which also hasn't occurred
13:31:24 <Myoma> xif, Did you get my PM?
13:31:27 <dons> guys. WRONG FREAKING CHANNEL.
13:31:42 <trofi> > Just Nothing
13:31:43 <lambdabot>  Just Nothing
13:31:45 <sclv> @yow
13:31:45 <lambdabot> Couldn't find fortune file
13:31:48 <xif> Philippa: right, because the founder of the channel is, thankfully, right here with us.
13:31:48 <sclv> @quote
13:31:49 <lambdabot> BlairPHoughton says: "In My Egotistical Opinion, most people's C programs should be indented six feet downward and covered with dirt." -- Blair P. Houghton
13:31:51 <Myoma> xif, I said please stop talking about this in #haskell
13:32:03 <sclv> @quote
13:32:03 <lambdabot> twb says: But, I love my job. It's like being in a rock band. i.e. no pay, but fun.
13:32:18 <sclv> there, some nice @quotes should lighten the atmosphere.
13:32:24 <Twey> @pl \x y -> a x (b y)
13:32:24 <Philippa> xif: no, I accept that merely opping briefly was itself an abuse. It wasn't, however, in response to a dissenting opinion
13:32:25 <lambdabot> (. b) . a
13:32:37 <dons> glguy had a suggestion a while ago to just unvoice people involved, until they calm down.
13:32:49 <dons> works well in big busy channels, but we've never tried that here.
13:33:05 <Philippa> you have to voice everyone by default, of course
13:33:22 <sclv> anyway, I was wondering if anybody had done any work with lightweight distributed processing (for resource acquisition, not parallelism) ?
13:33:22 <mauke> +b %nick!*@*
13:33:25 <xif> Philippa: eh, we both know very well that you allow yourself much less restrained abuse of power, where you can.
13:33:36 <pozic> Philippa: It was established that a + b == b + a for IEEE 754, so I don't see how that would be relevant. It's just a strict operation, as are most primitives.
13:33:42 <Beelsebob> dons: what's that a suggested solution to?
13:33:52 <dons> Beelsebob: shutting people up.
13:33:52 * Myoma wishes xif would stop this
13:33:57 <Beelsebob> dons: yeh, but when?
13:34:05 <dons> xif, Philippa: take it outside, or i'm kicking people.
13:34:15 <Beelsebob> just to shut down irritating discussions?
13:34:23 <dons> high emotion ones, yeah.
13:34:26 <Myoma> why not just ban xif? they're the only one going on and on about nothing
13:34:35 <pozic> Yes, let's ban everyone.
13:34:39 <pozic> That will educate them.
13:34:41 <sclv> #haskell is a place of reason and enlightenment.
13:34:42 --- mode: ChanServ set +o dons
13:34:56 <sclv> purity of thought and purpose
13:34:56 <dons> ok. seriously, the next person who talks about this gets a slap.
13:35:31 <trofi> > compare Nothing Nothing
13:35:33 <lambdabot>  EQ
13:35:38 <Beelsebob> dons: hmm, I guess I'd wanna be very very careful with that kind of power -- because it's a very subjective decision as to whether something's getting emotional, or just more than you can handle on that da
13:35:41 <sclv> > "om" ++ repeat 'm'
13:35:45 <lambdabot>  "ommmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm...
13:35:49 <trofi> > compare Nothing (Just Nothing)
13:35:51 <lambdabot>  LT
13:36:00 <Beelsebob> sclv: you fail, you should be producing omnomnomnomnomnomnomn :P
13:36:05 <dons> Beelsebob: yeah, hence we've never tried it. normally people are well behaved. it gets used in some big noisy places though.
13:36:05 <aeolist> it's actually aum i think
13:36:08 <Myoma> > compare Nothing (Just (Just (Just Nothing)))
13:36:10 <lambdabot>  LT
13:36:27 <Myoma> :t compare
13:36:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:36:35 <dons> hey, does anyone know why this meme is going around that haskell doesn't optimise tail calls into jumps?
13:36:50 <Beelsebob> o.O
13:36:52 <sclv> we had a silly argument the other day about it.
13:36:52 <aeolist> because there was an article on reddit a couple of days ago :P
13:36:52 <sjanssen> can you automatically put a timelock on that sort of thing, or would we have to re-voice people manually
13:36:52 <TomMD> I haven't heard that.
13:36:53 <Beelsebob> it doesn't?
13:36:59 <Beelsebob> :P
13:37:11 <trofi> what is meme ?
13:37:16 <sjanssen> dons: it's probably the "Stack overflow" you get with lazy accumulators
13:37:17 <sampointon> sjanssen: manually, I believe. But they can still PM, I also believe
13:37:18 <sclv> its just misunderstandingnoise
13:37:20 --- mode: ChanServ set -o dons
13:37:22 <dons> sjanssen: yes.
13:37:24 <aeolist> http://www.reddit.com/goto?rss=true&id=t3_6xmqo
13:37:25 <lambdabot> Title: Muad`Dib: Tail Call Optimization doesn't exist in Haskell
13:37:32 * Beelsebob ponders how to educate people that SIGSEGV is a type error -- just not a very friendly on
13:37:33 <dons> trofi: "an idea that behaves like a virus"
13:37:33 <Beelsebob> one*
13:37:49 <trofi> strange naming
13:38:01 <Philippa> Beelsebob: it's not necessarily though
13:38:03 <sampointon> trofi: by analogy with 'gene'
13:38:19 <dons> sjanssen: re. voicing, see "Chaos Control" here, http://haskell.org/haskellwiki/IRC_channel/Management
13:38:20 <Beelsebob> Philippa: oh? can you think of seg faults that Haskell's type system doesn't eliminate?
13:38:20 <lambdabot> Title: IRC channel/Management - HaskellWiki
13:38:22 <mauke> trofi: hi, you must be new to this internet
13:38:28 <yakov> hey
13:38:34 <dons> hey yakov. welcome!
13:38:40 <Philippa> Beelsebob: a) that's a much more specific statement, b) peek'n'poke :-)
13:38:40 <Beelsebob> (other than FFI, where the type system has no control)
13:38:43 <mauke> Beelsebob: out of bounds array access
13:38:52 <dons> btw, did everyone hear, we finished the damn book! :)
13:38:59 <yakov> great!
13:39:01 <trofi> mauke: yep, i have some troubles with english non-dictionary words :]
13:39:11 <bjrn> dons: I just learned about the book a few days ago, looks great!
13:39:11 <sjanssen> aeolist: hmm, skimming through the article everything looks correct.  Everything except the title
13:39:20 <Beelsebob> mauke: out of bounds array access won't produce a segfault, and anyway, it arguably *is* a type error -- just one that we need a dependant type system to catch an compile time
13:39:24 * yakov congrats dons 
13:39:24 <cpfr> `congrats!
13:39:26 <mauke> trofi: it's in my dictionary :-)
13:39:31 <Beelsebob> dons: gratz
13:39:37 <Beelsebob> Philippa: is it?
13:39:44 <mauke> Beelsebob: wrong
13:39:56 <ddarius> sjanssen: We well know that the title is the only thing anyone reads.
13:39:59 <Beelsebob> if Haskell's type system can elliminate them, that means that they are type errors -- just that they happen at runtime
13:40:00 <trofi> mauke: i've known yo've stole it from mine :p
13:40:01 <sjanssen> Beelsebob: what isn't a type error?
13:40:07 <sjanssen> ddarius: especially on reddit
13:40:27 <Beelsebob> sjanssen: good question -- I'm not sure if there is a class of errors that can't be detected at compile time, assuming you don't mind your compiler not terminating
13:40:37 <Beelsebob> in fact... that's easy to prove, there isn't such a class of errors
13:40:40 <Myoma> hehe
13:40:45 <mauke> meh, just run your program in the compiler
13:40:49 <Beelsebob> exactly
13:41:00 <Philippa> Beelsebob: different type systems prove different properties
13:41:02 <abbe> median :: Fractional a => a -> a -> a
13:41:03 <abbe> median x y = (x + y) / 2
13:41:16 <abbe> ^^^ what is the problem with above declaration ?
13:41:26 <mauke> :t (/)
13:41:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:41:27 <Myoma> :t \x y -> (x + y) / 2
13:41:29 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:41:33 <mauke> abbe: nothing
13:41:51 <Myoma> abbe: will, it's superflous
13:42:00 <sampointon> abbe: for one thing, it's completely the wrong definition of the moebius function
13:42:03 <abbe> but when I do, Main.median(1.0,2.0)
13:42:04 <Beelsebob> Philippa: sure -- okay, so they're type errors assuming you use a suitable type system which catches them -- that's really the point I'm trying to make here
13:42:14 <mauke> abbe: that's not how you call functions
13:42:24 <Beelsebob> that C programmers apparently don't realise that a good strong type system would illiminate seg faults
13:42:42 <Myoma> Beelsebob: oh it doesn't have to be strong, just _sound_
13:42:50 <abbe> Myoma, superfluous ?
13:42:54 <Beelsebob> yeh, I'd argue that a sound one *is* strong
13:42:55 <sclv> actually, garbage collection would also eliminate any number of segfaults in C
13:43:07 <Myoma> abbe: If you please, you can erase that line (with the type on it) and have haskell figure it out for you
13:43:10 <sclv> there are tradeoffs involved in these things...
13:43:12 <Beelsebob> sclv: yeh -- but to do that you need a type system first
13:43:15 <mauke> sclv: you can't really GC C
13:43:27 <Beelsebob> or rather, a stronger one than C has
13:43:32 * Myoma tries to avoid strong/weak/static/dynamic as adjectives for describing type systems
13:43:45 <Myoma> (since they don't have formal definitions, they're basically useless)
13:43:49 <joey__> abbe: Try: median 1.0 2.0
13:44:09 <sclv> I dunno, it just seems to me like C has lots of little unsafeCoerces secretly sprinkled in innocent looking code.
13:44:10 <mauke> > let median x y = (x + y) / 2 in median 1 2
13:44:12 <lambdabot>  1.5
13:44:12 <sampointon> Myoma: Static/dynamic are possibly useful
13:44:23 <abbe> joey__, okay, that worked.
13:44:26 <abbe> joey__, thanks :)
13:44:34 <Beelsebob> Myoma: yeh, another point I was subtly making -- JS's type system is classed as dynamic, yet gives more guarentees of compile time (web page load time) errors than C gives
13:44:46 <Beelsebob> sampointon: I don't think they are useful terms
13:44:48 <sclv> I prefer good/bad as a distinction -- its usually pretty clear that the good one is the one you want.
13:44:50 <tristes_tigres> to me, the absolutely worst thing about C is that you can't find out, whether a dynamic memory has been allocated
13:45:08 <sclv> so if we just label things good/bad up front we don't need to argue about relative merits later.
13:45:15 <trofi> you can with special memory manager
13:45:16 <sampointon> Beelsebob: possibly useful. Knowing whether the name or the value carries the type could matter
13:45:16 <tristes_tigres> in fortran 95 you have function Allocated()
13:45:19 <Myoma> tristes_tigres: It's impossible to check the return value of malloc ?
13:45:25 <tristes_tigres> Myoma no
13:45:28 <abbe> My guess for the type signature of median function is, median :: (Num a) (Num b) -> a -> b -> a
13:45:47 <abbe> s/) -> a/) => a/
13:46:17 <Beelsebob> sampointon: well, I'm not sure that that's the destinction -- in that, in C the value doesn't carry the type, but if you dereference the integer 0, you quickly get a (useless) type error (SIGSEGV)
13:46:18 <tristes_tigres> myoma: it is impossible to find out the size of dynamically allocated memory
13:46:29 <sclv> @ty (/)
13:46:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:46:36 <sclv> nums don't have /
13:46:46 <mauke> Beelsebob: C doesn't let you dereference integers
13:46:52 <Myoma> tristes_tigres: Oh, I never had a problem with that, I'd just store the size in a variable or structure if I wanted to know again later
13:46:52 <abbe> sclv, okay
13:46:57 <joey__> abbe: Both arguments to (/) must also have the same type too
13:47:01 <Beelsebob> mauke: sure it does
13:47:13 <mauke> Beelsebob: int i; *i; doesn't compile
13:47:19 <sampointon> mauke: just one cast away from all kinds of fun
13:47:21 <Myoma> tristes_tigres: My major distaste with C is that it's so _complicated_
13:47:26 <tristes_tigres> myoma: in other words? you habve to keep track of that yourself
13:47:40 <Beelsebob> mauke: otoh, int i; *(void *)i; *does*
13:47:41 <Myoma> tristes_tigres: Yes
13:47:45 <tristes_tigres> myoma: what if you work with someone else's code
13:47:46 <Beelsebob> this doesn't actually make i into a pointer
13:47:52 <Beelsebob> it just pretends that it is one
13:47:59 <trofi> i think haskell has unsafe explicit casts too
13:48:02 <Myoma> tristes_tigres: Then you better hope they're good at programming
13:48:02 <mauke> Beelsebob: not really, it converts i's value into a pointer
13:48:12 <Beelsebob> mauke: nope -- it's a cast, not a coercion
13:48:14 <Myoma> trofi: It doesn't
13:48:18 <mauke> Beelsebob: what
13:48:19 <Myoma> trofi: does it?
13:48:27 <tristes_tigres> myoma: in fortran you have function Size() that returns the length of dynamically allocated array
13:48:32 <Beelsebob> trofi: it doesn't -- it has unsafeCoerce, not unsafeCast
13:48:39 <Beelsebob> different things
13:48:39 <Myoma> tristes_tigres: In C you can have that too
13:48:43 <mauke> Beelsebob: what's the difference?
13:48:46 <Myoma> tristes_tigres: You must implement it, but this all trivial
13:48:53 <Beelsebob> mauke: one actually tries to convert the value -- the other doesn't
13:48:57 <mauke> Beelsebob: huh?
13:48:58 <abbe> joey__, okay
13:49:33 <Beelsebob> mauke: if I cast the integer 5 to a float, I get a floating point number represented by the same bit pattern as the integer 5 is represented by.  If I coerce it, I get 5, as a floating point number
13:49:39 <abbe> if i replace / with +, then its type signature would be: median :: (Num a) => a -> a -> a
13:49:48 <mauke> Beelsebob: by that definition C has no casts
13:49:49 <tristes_tigres> myoma: I know you can implemented it yourself. you can implement yourself hinldley-Milner type system? too :-)
13:50:15 <abbe> but then I still can't call Main.median(2,3)
13:50:21 <Myoma> tristes_tigres: I don't really know what you're getting at
13:50:21 <Beelsebob> mauke: no, by that definition, C has casts, except in a few specific cases defined in the spec (coercions only happen between numeric types IIRC)
13:50:23 <sampointon> mauke: in one, you change the type associated with the bit pattern but not the bits, in the other, the bit pattern and type both change
13:50:28 <abbe> what is the problem with this kind of invocation
13:50:29 <Myoma> abbe: You could write  median 2 3
13:50:36 <mauke> Beelsebob: which conversions reinterpret bytes?
13:50:37 <abbe> Myoma, yes that works
13:50:38 <Myoma> abbe: (2,3) is a pair of values together
13:50:47 <abbe> Myoma, you mean interpreted as a tuple
13:50:49 <Myoma> if you wanted to write that, then change the definition slightly
13:50:58 <Myoma> median(x,y) = (x+y)/2
13:51:08 <Myoma> I do not mean interpreted as
13:51:17 <Myoma> :t (2,3)
13:51:18 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
13:51:21 <tristes_tigres> myoma: look at the amount of memory debugger in C
13:51:23 <Beelsebob> mauke: char *jam = "ham"; int jam1 = (int)jam; // this doesn't change the bit pattern
13:51:28 <mauke> Beelsebob: wrong
13:51:46 <mauke> pointer->int conversion is implementation defined and not required to do anything useful
13:51:55 <tristes_tigres> myoma: everyone implements his own
13:51:58 <abbe> Myoma, okay, so the functions, where I pass values delimited by commas, and combine the whole expression in parenthesis, are actually expecting a tuple, right ?
13:52:16 <abbe> Myoma, since tuple is () and list is []
13:52:19 <Beelsebob> mauke: that's C++ you're thinking of -- in C the int you get out is the pointer you put in
13:52:23 <mauke> Beelsebob: wrong
13:52:27 <Myoma> abbe: in this one:  median(x,y) = (x+y)/2  (x,y) is a pattern and (2,3) get's matched against it, binding x = 2 and y = 3
13:52:35 <Myoma> gets*
13:52:47 <mauke> (void *)(int)ptr is not required to be the identity
13:52:56 <abbe> Myoma, okay, so it is not tuple, right ?
13:53:05 <mauke> (in fact, this is pretty much impossible if sizeof (int) < sizeof (void *))
13:53:07 <abbe> Myoma, just a syntactic sugar
13:53:10 <Myoma> abbe: What isn't a tuple?
13:53:26 <trofi> mauke: x86_64?
13:53:27 <abbe> Myoma, (2,3) in median(2,3)
13:53:32 <Beelsebob> mauke: sure it is -- this is required to do things like pointer comparisons in if statements
13:53:33 <Myoma> abbe: no, that is certainly a tuple
13:53:43 <abbe> Myoma, => median invoked with a single tuple parameter (2,3)
13:53:50 <Beelsebob> i.e. if (ptr) is defined to be a valid way of telling if the pointer is non-nil
13:53:55 <tristes_tigres> and let's not even mention the multidimensional arrays in C
13:54:04 <abbe> Myoma, hmm...?
13:54:07 <dmhouse> abbe: there is no difference between median(2,3) and median (2,3) (i.e., they parse the same).
13:54:25 <dmhouse> abbe: hence median(2,3) is calling median with a parameter of (2,3), which happens to be a tuple.
13:54:39 <joey__> abbe: It might help to mention that (2, 3) is a single value
13:54:40 <abbe> dmhouse, okay, thanks for confirming it :)
13:54:46 <dmhouse> abbe: so, no sugar.
13:54:54 <abbe> dmhouse, :)
13:54:55 <Draconx> Beelsebob, that's entirely different, as if (ptr) does not involve any conversions.
13:54:58 <Myoma> abbe, do you have ghci?
13:54:58 <Myoma> aueo
13:55:05 <Beelsebob> Draconx: exactly -- nor does (int)ptr
13:55:05 <abbe> joey__, thanks
13:55:11 <abbe> Myoma, yup, I'm using that only
13:55:12 <Beelsebob> it's a cast -- not a conversion
13:55:19 <Draconx> a cast is an explicit conversion.
13:55:19 <abbe> Myoma, in emacs :)
13:55:46 <Beelsebob> Draconx: no it isn't -- a coercion is an explicit conversion, and C only has coercions for converting between numeric types
13:56:04 <ddarius> Beelsebob: unsafeCoerce is identical to C++'s reinterpret_cast
13:56:15 <Draconx> from ISO/IEC 9899:1999: 6.5.4 Cast Operators: ... "Preceding an expression by a parenthesized type name *converts* the value of the expression to the named type."
13:56:53 <abbe> do you expect me to do something in ghci, Myoma ?
13:56:54 <Draconx> see section 6.3 for the definition of conversions.
13:57:01 <Beelsebob> Draconx: o.O interesting
13:57:04 <Beelsebob> so C has no casts at all
13:58:28 <mauke> Beelsebob: C has casts, and they're explicit conversions
13:58:32 <joey__> abbe: If you're wondering about the differences between passing tuples and individual parameters you might want to read up on "currying"
13:58:34 <mauke> as opposed to implicit conversions
13:58:49 <joey__> And the advantages of the latter with respect to partial application
13:58:56 <joey__> > uncurry median (2,3)
13:58:57 <aeolist> so what's the difference between casting and converting?
13:58:58 <lambdabot>  2.5
13:59:21 <Draconx> aeolist, in C, a cast _is_ a conversion.
13:59:26 <aeolist> yes
13:59:39 <Draconx> though not all conversions are casts.
13:59:40 <abbe> joey__, okay, BtW, i'm following YAHT atm
13:59:52 <aeolist> i do know that... a cast is a conversion provoked by the user, a coerced type is a conversion provoked by the compiler
14:00:06 <Draconx> int x = 0; short y = x; /* implicit conversion from int to short */
14:00:37 <sampointon> aeolist: I could be wrong, but I thought a cast changes the type but not the bits, and a conversion changes both
14:00:39 <aeolist> float a; a = 5; is an example of coercion, a = (float) 5; is an example of a cast
14:00:45 <Myoma> int x = 0; short y = fromIntegral x; you mean ?
14:00:45 <Myoma> :p
14:01:04 <aeolist> sampointon: interesting, i dont know
14:01:19 <aeolist> i dont think C makes a distinction there
14:01:59 <aeolist> :t frontIntegral
14:02:01 <lambdabot> Not in scope: `frontIntegral'
14:02:05 <aeolist> fail
14:02:29 <dobblego> > "fromIntegral" == "frontIntegral"
14:02:35 <lambdabot> Terminated
14:02:39 <dobblego> > "fromIntegral" == "frontIntegral"
14:02:40 <Draconx> aeolist, C doesn't use the term "coerce" anywhere in its definition.  It uses the notion of "conversion", and the term "punning" is mentioned in a (non-normative) footnote.
14:02:41 <lambdabot>  False
14:05:06 <Myoma> > unsafeFromIntegral
14:05:07 <lambdabot>  mueval: Unsafe functions to use mentioned.
14:05:39 <mauke> > funsafe
14:05:39 <lambdabot>  mueval: Unsafe functions to use mentioned.
14:05:53 <aeolist> Draconx: i guess C is so near the asm that it converts everything. this might be easy to witness with a small example and objdump and asm code inspection... the rest sounds more like terminology than anything else
14:05:55 <ddarius> > "unsafe"
14:05:55 <lambdabot>  mueval: Unsafe functions to use mentioned.
14:06:43 <telofy> good night everyone ~
14:12:38 <bjrn> Anyone know what happened with Google Treasure Hunt? They posted a few puzzles in May or so, since then it has been quiet.
14:12:56 <abbe> bjrn, looks like their treasure has been looted :P
14:14:06 <bjrn> abbe: hehe seems so
14:14:12 <abbe> bjrn, http://treasurehunt.appspot.com/
14:14:17 <lambdabot> Title: Google Treasure Hunt 2008
14:14:34 <abbe> lambdabot, you rock :)
14:14:38 <FunctorSalad> hmm, there are at least 7 haskell-shell libraries :( could you tell me which is most useful for doing shell-script-like jobs? http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system#Shell
14:14:40 <lambdabot> Title: Applications and libraries/Operating system - HaskellWiki, http://tinyurl.com/29tf4n
14:15:08 <aeolist> Draconx: http://pastebin.com/d6da5d734
14:15:30 <FunctorSalad> (and at least usable already)
14:20:37 <Twey> How would I go about converting a list [a, b, c, d, e, f] into a list [[a, b], [c, d], [e, f]]?  That is, grouping into pairs of two?
14:21:04 <Twey> Er
14:21:14 <Twey> [(a, b), (c, d), (e, f)]
14:21:31 <FunctorSalad> @type odd
14:21:33 <lambdabot> forall a. (Integral a) => a -> Bool
14:21:48 <ddarius> Twey: Explicit recursion.
14:21:50 <FunctorSalad> noo, we need a function that returns the odd-indexed elements ;)
14:21:57 <FunctorSalad> then zip
14:21:57 <Twey> Hmnhmn
14:22:02 <FunctorSalad> of course that's inefficient
14:22:06 <Twey> Thanks, ddarius
14:22:10 <Twey> No, FunctorSalad
14:22:16 <Twey> It isn't, really :)
14:22:20 * Twey thinks.
14:22:32 <Twey> Oh, I guess it is compared to explicit recursion.
14:23:44 <ddarius> Explicit recursion is both the simplest and most efficient way.
14:24:42 * Twey nods.
14:24:43 <Twey> Thanks.
14:24:44 <ziman> > let chunkBy n = takeWhile (not.null) . map (take n) . iterate (drop n) in chunkBy 2 [1..10]
14:24:46 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
14:25:06 <hackage> Uploaded to hackage: HXQ 0.9.0
14:25:29 <ziman> that's what i use
14:25:48 * ddarius wonders if he can make an efficient J-like layer of functions over uvector
14:25:51 <Zao> > let f x = map snd $ zip [1..] $ zip x $ tail x
14:25:51 <lambdabot>  Parse error at end of input
14:26:02 <Zao> > let f x = map snd $ zip [1..] $ zip x $ tail x in f "abcdef"
14:26:04 <lambdabot>  [('a','b'),('b','c'),('c','d'),('d','e'),('e','f')]
14:26:30 <Zao> Oops, missed a step... sneak in a filter (odd.fst) before the zip.
14:30:37 <Cale> http://www.marriedtothesea.com/082308/kracked-by-catbal.gif -- ahaha
14:37:36 <FunctorSalad> lol, Cale
14:40:55 <aeolist> weee! break function :) happy happy
14:50:35 <Twey> There are so many different ways of catching errors in Haskell... how do I know which one to use?
14:50:58 <mauke> depends on the kind of error
14:51:02 <Twey> For example, when a Network connectTo fails, am I meant to use Prelude.catch, or Control.Exception.catch, or something else entirely?
14:51:18 <mauke> Control.Exception.catch
14:51:27 <byorgey> IIRC using Control.Exception.catch is always preferable to Prelude.catch.
14:51:29 <mauke> it's more general
14:51:31 <byorgey> I don't remember why though
14:51:32 <Twey> And how can I tell that the error is what I think it is?  There doesn't seem to be an isConnectionError
14:51:38 <ziman> :t throw
14:51:39 <lambdabot> Not in scope: `throw'
14:51:56 <byorgey> Twey: consult the Oracle
14:52:11 * Twey blinks at byorgey.
14:52:24 <Twey> I'm sorry?  :-P
14:52:36 <trofi> :t error
14:52:38 <lambdabot> forall a. [Char] -> a
14:52:41 <byorgey> Twey: it was a joke =)
14:52:46 <Twey> Ah, heh
14:52:57 <Twey> I thought it may have been a reference to some obscure piece of software :-P
14:53:02 * byorgey points towards Delphi
14:53:12 <FunctorSalad> is error (or throw, rather) magic?
14:53:15 <Twey> Heheh, that's one place I don't intend to go
14:53:16 <FunctorSalad> @src throw
14:53:16 <lambdabot> throw exception = raise# exception
14:53:21 <FunctorSalad> ah
14:53:39 <mauke> Twey: find the piece of code that maps errno to exceptions
14:54:06 <ziman> is the exception (raised by throw) catchable?
14:54:34 <Twey> mauke: I have to delve into the Network source?
14:54:53 <mauke> I don't think it's in Network
14:55:13 <Twey> :-\
14:55:28 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Foreign-C-Error.html#errnoToIOError
14:55:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/48zcgk
14:55:47 <Twey> I'm looking for whatever causes 'connect: does not exist (Connection refused)'
14:55:49 <Twey> Aha
14:55:56 <Twey> Still... hmn...
14:55:57 <dmhouse> Can we not have more descriptive titles for the sources?
14:56:34 <mauke> Twey: ECONNREFUSED
14:56:43 <mauke>  No-one listening on the remote address.
14:57:31 <Myoma> why is this file 14 bytes? http://www.haskell.org/ghc/dist/current/dist/ghc-6.9.20080822-src-extralibs.tar.bz2
14:57:32 <lambdabot> http://tinyurl.com/6cqjfw
14:57:38 <BONUS> hey guys what do you think of this artistic interpretation of a haskell quicksort http://kalleboo.mirror.waffleimages.com/files/84/8491b66c0191cac8ecba4f4d19a3a2db45c8cf57.png
14:57:42 <BONUS> do you see any errors
14:57:44 <lambdabot> http://tinyurl.com/3pntuw
14:58:05 <Twey> mauke: A.K.A. NoSuchThing?
14:58:20 <ddarius> "This Haskell Code was brought to you by Coca-Cola: The Real Thing"
14:58:31 <Twey> Heh, ddarius
14:58:31 <mauke> Twey: yes
14:59:35 <dmhouse> BONUS: looks nice.
14:59:40 <dmhouse> BONUS: a little hard to read near the bottom.
14:59:43 <ddarius> BONUS: Maybe draw a line showing the actual final sorted list or some other indication of the actual output.
14:59:47 <Twey> mauke: So do I have to import Foreign.C.Error in order to use catch foo (\ (e :: NoSuchThing) -> ...)?
14:59:59 <mauke> no, you can't do that anyway
15:00:00 <BONUS> hmm yeah
15:00:08 <BONUS> i thought of it like if you look at the orange elements
15:00:10 <BONUS> from left to right
15:00:13 <BONUS> you see the sorted list
15:00:20 <BONUS> maybe i should make a line yeah
15:00:28 <mauke> Twey: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#v%3AisDoesNotExistError
15:00:29 <lambdabot> Title: System.IO.Error, http://tinyurl.com/5s9q7f
15:00:56 <bjrn> Imagine the power if someone hijacked tinyurl.
15:01:06 <bjrn> s/power/mess
15:01:07 <Myoma> bjrn: I tried to once, :(
15:01:24 <Twey> mauke: Aha... thanks...
15:01:30 <dmhouse> bjrn: it has been the case that similar sites have been spammed to death, and millions of URLs all over the web break.
15:01:56 <Myoma> bjrn: although probably in a different way that you meant
15:02:09 <bjrn> I think even NYTimes use tinyurl in some articles.
15:02:55 <FunctorSalad> you can disable automatic redirection on the tinyurl site
15:03:03 <FunctorSalad> then it shows you the real url firs
15:03:05 <FunctorSalad> t
15:04:00 <FunctorSalad> that would limit the attack to mere breakage rather than misdirection, I mean
15:04:12 <FunctorSalad> (if you can tell from the url)
15:06:42 <FunctorSalad> nevermind, I'm stupid
15:20:08 <Myoma> @w80 top notch
15:20:09 <lambdabot> *** "top" wn "WordNet (r) 2.0"
15:20:09 <lambdabot> top
15:20:09 <lambdabot>      adj 1: situated at the top or highest position; "the top shelf"
15:20:09 <lambdabot>             [syn: {top(a)}] [ant: {bottom(a)}, {side(a)}]
15:20:09 <lambdabot>      2: not to be surpassed; "his top effort" [syn: {greatest}]
15:20:11 <lambdabot> [73 @more lines]
15:20:39 <dmhouse> http://archive.salon.com/21st/chal/1998/02/10chal2.html are brilliant.
15:20:40 <lambdabot> Title: Salon | 21st: The 21st Challenge -- Ticklers for every situation
15:22:55 <newsham> "If you write your program entirely in Haskell, you can't segfault it"
15:23:02 <Twey> http://www.lojban.org/tiki/tiki-index.php?page=Fractal%20Lojban%20Sentences -- the Lojban answer to haiku: the fractal poem
15:23:07 <lambdabot> Title: Lojban : Fractal Lojban Sentences, http://tinyurl.com/5jvj9r
15:24:31 <trofi> > Unsafe.Coerce.unsafeCoerce 1234566666666666666666666666666666666666 :: [Char]
15:24:31 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:25:07 <hackage> Uploaded to hackage: maybench 0.2
15:25:44 <mauke> > Unsafe
15:25:46 <lambdabot> Terminated
15:25:54 <newsham> > "unsafe in a string is also suspect"
15:25:54 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:26:10 <Myoma> :t (.)
15:26:11 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:26:19 <newsham> ?src (.)
15:26:19 <lambdabot> (f . g) x = f (g x)
15:26:20 <mauke> safety through hungarian notation
15:26:40 <newsham> mauke: i'm sure they've thought of all the dangerous strings
15:26:41 <dmhouse> ?ask gwern wasn't the > "unsafe" bug fixed? Or does Cale need to update his mueval?
15:26:41 <lambdabot> Consider it noted.
15:27:49 <newsham> c <- (c <- b) <- (b <- a)
15:28:29 <mauke> type (<-) a b = b -> a
15:28:34 <Botje> > "unsafe strings need love to"
15:28:34 <lambdabot>  mueval: Unsafe functions to use mentioned.
15:28:48 <Twey> Hahaha
15:28:56 <Twey> What a hack :-\
15:28:58 <Botje> s/to/too/ :p
15:29:17 <newsham> > Some.Package.That.Doesnt.Exist.val
15:29:18 <lambdabot>      Failed to load interface for `Some.Package.That.Doesnt.Exist':
15:29:18 <lambdabot>       Use...
15:29:43 <dmhouse> Oh, qualified inputs aren't disallowed any more?
15:29:59 <dmhouse> > Data.Map.map (+1) $ Data.Map.fromList (zip [1..3] "abc")
15:30:00 <lambdabot>      No instance for (Num Char)
15:30:00 <lambdabot>       arising from the literal `1' at <intera...
15:30:12 <dmhouse> Err.
15:30:19 <dmhouse> > Data.Map.map toUpper $ Data.Map.fromList (zip [1..3] "abc")
15:30:20 <lambdabot> Terminated
15:30:20 <Myoma> > Data.Map.map (first (+1)) $ Data.Map.fromList (zip [1..3] "abc")
15:30:22 <lambdabot>  Couldn't match expected type `(b, d)' against inferred type `Char'
15:30:23 <newsham> > Network.connectTo "127.0.0.1" "22"
15:30:25 <lambdabot>  Couldn't match expected type `Network.PortID'
15:30:30 <newsham> > Network.connectTo "127.0.0.1" 22
15:30:32 <lambdabot>      No instance for (Num Network.PortID)
15:30:32 <lambdabot>       arising from the literal `22'...
15:30:33 <dmhouse> Myoma: `map' maps the values
15:30:44 <newsham> > Network.connectTo "127.0.0.1" (PortNumber 22)
15:30:45 <lambdabot> Terminated
15:30:56 <Myoma> > Data.Map.map (+1) $ Data.Map.fromList (zip "abc" [1..3])
15:30:58 <lambdabot> Terminated
15:33:03 <Twey> Slop :-\
15:33:05 <Twey> Slow**
15:33:07 <newsham> > Ghc.Prim.killThread#
15:33:08 <lambdabot>      Failed to load interface for `Ghc.Prim':
15:33:08 <lambdabot>       Use -v to see a list of t...
15:33:18 <newsham> > GHC.Prim.killThread#
15:33:19 <lambdabot>      No instance for (Show
15:33:19 <lambdabot>                        (GHC.Prim.ThreadId#
15:33:19 <lambdabot>        ...
15:33:28 <dmhouse> ?hoogle killThread
15:33:28 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
15:33:28 <lambdabot> GHC.Conc killThread :: ThreadId -> IO ()
15:34:53 <newsham> > GHC.Prim.nullAddr#
15:34:55 <lambdabot>  Couldn't match kind `#' against `*'
15:35:32 <Myoma> :t GHC.Prim.nullAddr#
15:35:34 <lambdabot> GHC.Prim.Addr#
15:35:43 <Myoma> :k GHC.Prim.Addr#
15:35:45 <lambdabot> #
15:36:42 <newsham> > GHC.indexCharOfAddr# GHC.Prim.nullAddr# (Int# 5)
15:36:44 <lambdabot>      Failed to load interface for `GHC':
15:36:44 <lambdabot>       it is a member of package ghc-...
15:36:51 <newsham> > GHC.Prim.indexCharOfAddr# GHC.Prim.nullAddr# (Int# 5)
15:36:53 <lambdabot> Terminated
15:38:23 <newsham> > GHC.Prim.raise# "test"
15:38:25 <lambdabot> Terminated
15:42:40 <dmhouse> C'mon sigfpe, we want more rational tangles already!
15:42:54 <dmhouse> The connection to continued fractions in the title is just too enticing :)
15:45:59 <ahmed-tux> glguy i think that you love irc comman
15:46:05 <ahmed-tux> command*
15:46:17 <glguy> ahmed-tux: no need to bring this to this channel
15:46:59 <ahmed-tux> glguy i know about haskell
15:47:06 <ahmed-tux> glguy don't worry
15:47:30 <MyCatVerbs> dons: odd, you're not in #haskell-blah for some reason?
15:50:14 <TomMD> I've got a new suggestion for maintainers e-mail addresses on Hackage.  They shouldn't be mailing lists where you must be subscribed to post.
15:51:03 <trofi> project@code.haskell.org
15:53:01 <b\6> after i use parsec to parse the string i got from hGetContents on a socket handle, i call getInput so i can return the unparsed part. sometimes there isn't any unparsed part, so getInput is blocking.
15:55:44 <Twey> Try hGetBufNonBlocking, b\6
15:55:56 <b\6> ok.
15:55:57 <Twey> Or concurrency with a tryTakeMVar
15:56:02 <Twey> Er, tryReadChan
15:56:51 <ziman> getInput blocks even after EOF?
15:57:31 <blbrown>  let a = [[0,0], [1,1]] ...   (a !! 0) ... if I do this in a module, what does <<loop>> mean when I try to print it with putStrLn ...
15:57:41 <trofi> i would treat it as bug
15:58:05 <b\6> ziman: i don't think it's eof. the socket is still connected. i just parsed everything the server sent.
15:58:16 <Cale> blbrown: isn't that a type error?
15:58:30 <Cale> a !! 0 = [0,0] which is not a string?
15:58:44 <newsham> > let a = [[0,0],[1,1],[2,2]] in a !! 0
15:58:47 <lambdabot>  [0,0]
15:59:01 <newsham> blbrown: i bet there's an error elsewhere.
15:59:03 <dobblego> > let a = [[0,0],[1,1],[2,2]] in putStrLn $ a !! 0
15:59:04 <lambdabot>      No instance for (Num Char)
15:59:04 <lambdabot>       arising from the literal `2' at <intera...
15:59:04 <newsham> put it on codepad.org?
15:59:07 <blbrown> yea, but when I do it in a module and do putStrLn $ (show a) ...it prints out <<loop>>
15:59:24 <blbrown> newsham, no errors
15:59:36 <newsham> i meant programming error
16:03:08 <newsham> blbrown: can you put a small example of it on codepad.org?
16:03:35 <blbrown> one sec
16:04:34 <ziman> b\6, i wouldn't rely on async reads that way (data may not have arrived, for example); hGetContents says you want *all* contents (ie. until EOF) which is not quite what you really want; i'd Prelude.take the desired length or find a way to recognize end of the desired part of the input and cut it there...
16:05:36 <newsham> btw, it shouldnt hang getting the list of remaining input characters, only when you try to consume those characters
16:05:48 <Twey> hGetContents is Bad
16:05:52 <MarcWeber> I can't do somthing like class (C a) => Classname (Either a b), can I?
16:06:02 <dmhouse> MarcWeber: no.
16:06:06 <dmhouse> Wait, yes.
16:06:12 <mauke> no
16:06:20 <newsham> marc: its considered bad style to put type deps on the data decl
16:06:29 <newsham> because you have to carry it around to every single function type
16:06:33 <dmhouse> newsham: that's not what he's doing.
16:06:38 <b\6> ziman: i use hGetContents just to get something parsec can read.
16:06:41 <newsham> oh, what is he doing?  :)
16:06:43 <dmhouse> Oh, wait.
16:06:44 <newsham> <- confused
16:06:49 <dmhouse> MarcWeber: did you mean instance instead of class?
16:07:10 <newsham> oh, i misread what he's doing.  my bad :(
16:07:17 <MarcWeber> No.. I'm trying to write a validating xml library using functional dependencies...
16:07:26 <dmhouse> Then ignore everything I said.
16:08:23 <MarcWeber> Now I'm at the point writing a class marking an element as "finished". This should check for missing attributes and elements..
16:08:26 <newsham> marc: in your case "C" and "Classname" are unrelated?
16:08:46 <dobblego> does (>>=) . join exist in the standard libs somewhere?
16:08:58 <mauke> :t (>>=) . join
16:09:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (m a) -> (a -> m b) -> m b
16:09:14 <MarcWeber> newsham: line 145 http://rafb.net/p/4403oU43.html
16:09:19 <lambdabot> Title: Nopaste - No description
16:09:38 <dmhouse> dobblego: don't think so.
16:09:53 <MarcWeber> To be honest I don't know yet wether it will work this way.. But hope to be able to run some tests today or tomorrow..
16:10:13 <dobblego> @hoogle (Monad m) => (a -> a -> m b) -> m a -> m b
16:10:13 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:10:13 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
16:10:13 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:10:21 <dobblego> @type (=<<) . join
16:10:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> a -> m b) -> m a -> m b
16:10:36 <newsham> marc: *shrug* sorry, dont know.
16:11:21 <MarcWeber> newsham: We'll see. If it works I'll load it up to hackage anyway..
16:11:30 <haskellian> what is the lisp channels name?
16:11:32 <haskellian> common lisp...
16:11:41 <Botje> ##lithp ?
16:11:59 <Botje> or probably just #lisp
16:12:41 <newsham> why doesnt /list *lisp*   work anymore?
16:15:55 <dcoutts_> dons: I clarified that all these packages are not intended for the first release http://haskell.org/haskellwiki/Haskell_Platform/Batteries_Included
16:15:56 <lambdabot> Title: Haskell Platform/Batteries Included - HaskellWiki, http://tinyurl.com/4vsj7l
16:21:14 <gwern> dmhouse: I haven't made the unsafe changes yet. sleep and archery and a few other things have occupied my time such that I haven't gotten around to reviewing and applying mmorrow's patch
16:22:12 <dmhouse> gwern: fair enough. Mueval got something of a baptism by fire, plugging it straight into #haskell as soon as lambdabot worked with it.
16:23:26 <gwern> indeed. I regret nothing!
16:24:14 <dmhouse> gwern: at least the bugs have been found. :)
16:24:44 <gwern> quite. I just wish the hint author would file the requests/bug fixes
16:24:50 <gwern> he's better at pestering ghc hq than I
16:38:12 <Philonous> :t \x -> ((\t -> x(t t)) (\t -> x(t t)))
16:38:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:38:14 <lambdabot>     Probable cause: `t' is applied to too many arguments
16:38:14 <lambdabot>     In the first argument of `x', namely `(t t)'
16:39:27 <dmhouse> Philonous: not in my type system!
16:39:52 <Philonous> No fixed points in haskel :-(
16:39:57 <dmhouse> Wrong.
16:40:00 <dmhouse> > fix (1:)
16:40:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:40:20 <Philonous> O_o
16:40:43 <dmhouse> Philonous: we have natively recursive let, so we can say let fix f = f (fix f) in ...
16:40:55 <Philonous> I see
16:40:56 <dzlk> :t fix
16:40:58 <lambdabot> forall a. (a -> a) -> a
16:41:30 <Philonous> > fix (/2)
16:41:33 <lambdabot>  mueval: Time limit exceeded
16:41:34 <dmhouse> dzlk, see http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion if you want an intro to fix.
16:42:08 <Philonous> Looking at the definition it's actually straight forward
16:42:56 <dmhouse> Philonous: fix (/2) gives _|_ because _|_ / 2 = _|_, btw.
16:43:27 <Philonous> 0 should be a fixed point for that one, too
16:43:37 <dmhouse> Philonous: yes, but fix finds the least-defined fixed point.
16:43:38 <Philonous> But I guess bottom is a fixed point for anything
16:43:43 <dmhouse> Not true, lazy functions.,
16:43:56 <Philonous> Ok
16:43:58 <dmhouse> (1:) _|_ is [1, _|_], which isn't _|_ itself.
16:44:11 <dmhouse> Err, it's 1:_|_, rather. Bad example.
16:44:11 <Philonous> Hmm, yeah
16:44:21 <dmhouse> > const "foo" undefined
16:44:23 <lambdabot>  "foo"
16:44:34 <dmhouse> There we go: const "foo" is lazy because const "foo" _|_ /= _|_.
16:44:40 <dmhouse> f is strict <=> f _|_ = _|_.
16:44:51 <dmhouse> Philonous: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion might help
16:45:09 <Philonous> I'm already at it
16:45:21 <Twey> > fix (/2)
16:45:23 <lambdabot>  mueval: Time limit exceeded
16:45:37 <Twey> Oh, hmn.
16:45:47 <dmhouse> Also some bits from http://en.wikibooks.org/wiki/Haskell/Denotational_semantics and chapter 3 from http://en.wikibooks.org/wiki/Haskell/Laziness
16:45:48 <lambdabot> Title: Haskell/Denotational semantics - Wikibooks, collection of open-content textbooks
16:46:04 <dmhouse> Twey: was that not what you expected?
16:48:01 <Philonous> Twey: by definition of fixed this should give an infinite chain of division by 2, which never converges
16:48:19 <dmhouse> That's the operational explanation.
16:48:46 * Twey doesn't mention Zeno of Elea.
16:49:04 <dmhouse> The denotational one is that since _|_ / 2 is itself _|_, _|_ is a fixed point of (/ 2). Since fix finds the least defined fixed point, and _|_ is less-defined than any other value, fix (/ 2) is _|_.
16:49:22 <dmhouse> Again, see http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion for explanations of these terms.
16:49:53 <sampointon> if it goes on for long enough, might you run out of floating point precision?
16:50:27 <dmhouse> sampointon: it's probably a stack overflow.
16:50:29 <Philonous> sampointon:  That's what I was thinking, too. So eventually you might find 0 as a fixed point
16:50:57 <dmhouse> You get (((... / 2) / 2) / 2). It has to allocate stack space for each of those closures, would be my guess.
16:51:14 <dmhouse> Yep:
16:51:14 <dmhouse> Prelude Data.Function> fix (/2)
16:51:14 <dmhouse> *** Exception: stack overflow
16:52:02 <dsrogers> 2 isn't a floating point number.
16:52:14 <slava> :t /
16:52:15 <dsrogers> and haskell uses arbitrary precision arithmatic by default.
16:52:15 <dmhouse> Yes, it is.
16:52:15 <lambdabot> parse error on input `/'
16:52:19 <slava> :t (/)
16:52:21 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:52:26 <dmhouse> :t 2
16:52:27 <lambdabot> forall t. (Num t) => t
16:52:30 <dsrogers> that's a fractional.
16:52:31 <dmhouse> ?instances Num
16:52:32 <lambdabot> Double, Float, Int, Integer
16:52:42 <slava> ?instances Fractional
16:52:43 <lambdabot> Double, Float
16:52:45 <slava> hmm
16:52:47 <dmhouse> I believe the default for Fractional is Double.
16:52:48 <slava> no ratios in haskell?
16:52:51 <idnar> > fix (*0)
16:52:53 <dmhouse> slava: Data.Ratio
16:52:53 <lambdabot>  mueval: *** Exception: stack overflow
16:52:55 <dsrogers> fractional is a rational.
16:53:01 <idnar> > fix (0*)
16:53:02 <dsrogers> it's arbitrary precision.
16:53:03 <lambdabot>  mueval: *** Exception: stack overflow
16:53:04 <dmhouse> ?instances-importing Data.Ratio Fractional
16:53:05 <lambdabot> Double, Float, Ratio a
16:53:05 <idnar> aww
16:53:14 <dmhouse> idnar: again, _|_ * 0 = _|_.
16:53:20 <dmhouse> dsrogers: I believe the default for Fractional is in fact Double.
16:53:23 <idnar> dmhouse: yeah, I see
16:53:27 <dsrogers> ah
16:53:31 <dsrogers> you're right, sorry
16:54:04 <idnar> @type iterate
16:54:06 <lambdabot> forall a. (a -> a) -> a -> [a]
16:54:46 <dsrogers> is there a good way to handle the idiom:
16:54:48 <sampointon> using a tail recursive definition, fix (/ 2) comes out as 0.0
16:55:03 <dmhouse> sampointon: what definition?
16:55:14 <dmhouse> sampointon: it's not a correct least-fixed-point operator if that is true.
16:55:14 <dsrogers> f args | pred(args) = ...
16:55:16 <idnar> sampointon: eh, how's that possible?
16:55:25 <dsrogers> f args | otherwise = ...
16:55:29 <idnar> sampointon: how would you ever perform any of the division?
16:55:31 <sampointon> dmhouse:  oh, not least fixed point
16:55:42 <dsrogers> err, f args | otherwise = default
16:55:48 <dmhouse> dsrogers: well, you can drop the second 'f args'.
16:55:55 <sampointon> it was an arbitrary fixed point finder
16:56:01 <dsrogers> f (altform) = default
16:56:07 <dmhouse> sampointon: what definition.
16:56:12 <dsrogers> where you have a guard that checks for only one case.
16:56:23 <dsrogers> but you want all other pattern matches to do the same as the otherwise.
16:56:35 <sampointon> dmhouse: the simple one, fix' a f = let a' = f a in if a' == a then a' else fix' a' f
16:56:36 <dmhouse> dsrogers: f args | pred = foo; f _  = default
16:56:53 <dmhouse> dsrogers: no need for the first 'otherwise' clause.
16:57:04 <dmhouse> dsrogers: if all guards fail on one pattern, you proceed to the next.
16:57:06 <dsrogers> I thought once you were in a pattern match you wouldn't match again?
16:57:10 <slava> is there an existential type instance of Num?
16:57:12 <dsrogers> ah.
16:57:14 <dsrogers> ok.  great.
16:57:29 <Philonous> :t \a b c -> a c (b c)
16:57:30 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:57:34 <dmhouse> dsrogers: once you cross the =, you can't go back. That's the mnenomic.
16:57:41 <Philonous> @pl \a b c -> a c (b c)
16:57:41 <lambdabot> ap
16:57:52 <dmhouse> Philonous: that's ap in the ((->) e) monad.
16:58:12 <dmhouse> slava: you mean, data NumBox = forall a. Num a => MkNumBox a? I don't think so.
16:58:18 <Philonous> I'd like to call it "S", for romantic reasons :>
16:58:31 <slava> dmhouse: how would you make a list containing a float, an integer, and a ratio, and then add 2 to each element?
16:58:34 <dmhouse> Philonous: unlucky, functions in Haskell have to begin with a lowercase letter. 's' will do.
16:58:36 <dmhouse> Philonous: btw K is const
16:58:40 <dsrogers> and does f _ = default have the behavior I except (as in pass the arguments of f to default?)
16:58:43 <dmhouse> And I id, obviously.
16:59:05 <Philonous> S and K (or s and k respectively) are all one really needs :)
16:59:18 <dmhouse> dsrogers: no, you'll have to match the arguments on the LHS to do that.
16:59:25 <dmhouse> dsrogers: _ is a wildcard pattern that matches anything, and binds nothing.
16:59:31 <dmhouse> ?check \x -> ap const const x == id x
16:59:33 <lambdabot>  "OK, passed 500 tests."
16:59:40 <dsrogers> thanks.
17:00:08 <Philonous> :t ap ap const (ap (const( ap ap ( ap ( ap ap const )))) const)
17:00:10 <lambdabot>     Occurs check: cannot construct the infinite type: a = b1 -> a -> b
17:00:10 <lambdabot>     Probable cause: `const' is applied to too few arguments
17:00:10 <lambdabot>     In the second argument of `ap', namely `const'
17:00:22 <dsrogers> so ~ forces a match right?
17:00:23 <Philonous> :-/
17:00:26 <dmhouse> dsrogers: ish.
17:00:31 <slava> dmhouse: any way to wrap those numbers into a tuple of closures and making the result a Num instance/
17:00:33 <dsrogers> can I get ~ to force a match and still bind the entire argument?
17:00:37 <dmhouse> dsrogers: rather, yes, but there's more to it than tha.t
17:00:48 <dmhouse> dsrogers: see http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
17:00:49 <lambdabot> http://tinyurl.com/ykch9p
17:01:10 <dmhouse> slava: which numbers?
17:01:46 <dmhouse> Philonous: SSK(S(K(SS(S(SSK))))K)? What's that?
17:01:49 <zandax_> I'm still a bit puzzled with HGL. The "load" function for loading bitmaps returns an "IO Bitmap". However, I would like to get an "ordinary" Bitmap, and I have no idea how to do that or if it is even possible.
17:01:50 <Philonous> Y
17:01:59 <dmhouse> Oh, then it's good it doesn't typecheck :)
17:02:02 <Philonous> Or rather: Y'
17:02:27 <Blue_Beaver> hi
17:02:34 <dmhouse> zandax_: yes, but since load does IO, any function that uses it must also have an IO-wrapped result type.
17:02:41 <slava> dmhouse: suppose you want to create a heterogeneous list of integers and floats
17:02:51 <dmhouse> zandax_: then in that caller, you can use a do-block, and to get the Bitmap out of the IO Bitmap, use <-.
17:02:51 <slava> and use this with a (Num a) => [a] => a function
17:02:59 <Philonous> Yeah. But it's unfortunate. Just think of all the cool stuff one could do with a "finite" fixed point combinator
17:03:16 <dmhouse> slava: no, because Num a => [a] is homogeneous.
17:03:36 <dmhouse> slava: an example is foldr (*) 1. How do you multiply two instances of Num? You can't, in general.
17:04:54 <zandax_> @dmhouse: my code looks like this: "bmp = do (a, _) <- load "wall.bmp"; return a"
17:04:54 <lambdabot> Unknown command, try @list
17:05:06 <zandax_> sry, again the @
17:05:09 <dmhouse> zandax_: uh huh, and what happened?
17:05:30 <zandax_> Actually I am returning an IO Bitmap but I want "bmp" to be the "ordinary one"
17:05:35 <slava> dmhouse: what about specific cases, eg mixing ratios and integers?
17:05:56 <dmhouse> zandax_, you can't. Any function that does IO, or calls a function that does IO, *must* have an IO-wrapped type.
17:06:10 <dmhouse> zandax_: this is crucial, as otherwise you could write functions that break referential transparency.
17:06:21 <zandax_> ok :/
17:06:48 <zandax_> then the question is how I get the bitmap "out of the function", so that I could use it in others
17:07:02 <_JFT_> well there is unsafePeformIO (duck and cover :P)
17:07:06 <Botje> you can only do IO actions in otehr IO actions
17:07:12 <zandax_> I want to make the bitmaps beeing global variables.
17:07:13 <dmhouse> zandax_: you simply do foo <- bmp in another do-block somewhere.
17:07:20 <_JFT_> but really what dmhouse says
17:07:26 <zandax_> So that I can easily pass them to my drawing functions
17:07:32 <dmhouse> zandax_: you could use an IORef for that.
17:08:09 <dmhouse> zandax_, presumably, your drawing functions have an IO type?
17:08:24 <zandax_> yes
17:08:27 <dmhouse> slava: convert to a common type first, e.g. using fromIntegral
17:08:39 <dmhouse> > 5%2 * fromIntegral 2
17:08:40 <lambdabot>  5%1
17:08:49 <Philonous> :t %
17:08:50 <lambdabot> parse error on input `%'
17:08:56 <Philonous> :t (%)
17:08:57 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:09:02 <dmhouse> (In fact, it's not actually necessary there, since 2 is a literal, but anyway.)
17:09:12 <dmhouse> > 5%2 * fromIntegral (2 :: Int) {- More realistic example -}
17:09:14 <lambdabot>  5%1
17:09:36 <slava> static typing is weird :)
17:10:02 <Twey> But cool :)
17:10:13 <slava> writing programs with these limitations sounds like an interesting mental exercise
17:10:19 <slava> maybe not very practical though :)
17:10:20 <Philonous> It saves you headaches when you have to reason about perfromance
17:10:21 <dmhouse> zandax_: hmm, actually thinking about it, it's probably easiest to just pass your bitmaps around.
17:10:36 <dmhouse> Philonous: but then lazy evaluation throws that away again, yay! :)
17:10:48 <ddarius> slava: Debugging type errors is also interesting mental exercise but not very practical.
17:10:50 <_JFT_> slava: it is not a limitation, the type cohercion is explicit (hence visible) :)
17:10:54 <slava> ddarius: i agree
17:10:56 <Philonous> Ok, but implicit typecasts give you headaches. I
17:11:04 <dmhouse> slava: the static typing actually saves you typing in places.
17:11:12 <slava> Philonous: not when there's an obvious injection, eg integers into rationals
17:11:24 <slava> integers to floats or integers to strings might not be a good idea
17:11:24 <ddarius> slava: The answer is clearly Forth or assembly or any language where there are no types static or dynamic.
17:11:46 <dmhouse> slava: e.g. the result from the regex matching function is overloaded, so depending on how the caller uses it, a different instance of matching function gets used.
17:11:53 <Philonous> slava: Yes, IF they are all obvious. But in C for example they are not.
17:11:55 <dmhouse> Not possible without a proper type system!
17:12:07 <dmhouse> Data.Map.lookup is another example; you can key the "key not found" failure in any monad you like,
17:12:21 <Heffalump> I thought that was going to be removed again
17:12:34 <dobblego> Scala has implicit conversion
17:12:34 <dmhouse> Shh, it's proving my point.
17:12:49 <Twey> The thing I like is being able to write whatever I want without testing, because if it compiles, it almost certainly does what I want it to :)
17:12:58 <Heffalump> but yeah, overloading is great for that kind of thing
17:13:27 <zandax_> dmhouse, yeah I think I will pass them
17:14:03 <zandax_> but I'm not happy with it :/
17:14:11 <ddarius> Twey writes code and ships it to customers as soon as it compiles without even running it.
17:14:30 * Twey has never yet written Haskell code for a client :)
17:14:34 <Twey> Alas, alack.
17:14:40 <Twey> Maybe when I'm better.
17:15:05 <Philonous> IMO dynamic typing is for when you are writing the stuff and you don't like the guy who has to debug it ;)
17:15:15 <Twey> But aye.  What I meant to say was, I'm used to writing code in, say, Python, and having to test every branch of it every time I modify it
17:15:22 <ddarius> Philonous: -You- are the guy that has to debug it.
17:15:30 <Twey> In Haskell, chances are it will Just Work.
17:15:43 <dmhouse> I think static and dynamic typing both have their place. You write different styles of code depending on what your language has.
17:15:46 <Twey> The compiler catches all the daft mistakes for me.
17:15:52 <Twey> Mm.
17:15:59 <slava> but why would you write code if you're not planning on running it?
17:16:07 <dmhouse> At the end of the day, there are thousands of programmers using both, and the world isn't crashing down around us.
17:16:08 <dobblego> Twey, all of them? why do filter and takeWhile have the same signature?
17:16:16 <dmhouse> A lot of very smart people like dynamic typing. Ditto static.
17:16:19 <Philonous> ddarius Not necessarily ;) If the bug is hidden in one brach that is triggered maybe once in a month or something like that
17:16:36 <Twey> dobblego: But the chances of my mistaking takeWhile instead of filter is very small.
17:16:42 <dobblego> Twey, prove it
17:16:42 <Twey> s/instead of/for/
17:16:47 <Twey> I've never done it :)
17:16:50 <dmhouse> Twey: the chance of calling head on an empty list is nonzero though.
17:16:55 <Twey> That's true.
17:16:59 <slava> i think 'testing every branch' is a strawman argument against dynamic typing. a better one might be the difficulty of writing automated refactoring tools such as you find in Eclipse, etc
17:17:01 <sampointon> Twey: Different example, I missed off a crucial (reverse $) once that was a real pain to track down
17:17:20 <dmhouse> E.g. main = do firstArg <- fmap head getArgs {- fail -}
17:17:20 <Twey> Certainly there *are* still problems like that
17:17:26 <Twey> But there are a lot less of them
17:17:53 <dobblego> Twey, correct both type signatures to disambiguate each function from any other function, then declare your use of a terminating subset of Haskell, then you can claim "it just works" based on your proof
17:18:03 <slava> its a shame there aren't any refactoring tools for haskell
17:18:09 <slava> or code navigation tools
17:18:12 <slava> people just use emacs :)
17:18:17 <dobblego> there is leksah
17:18:18 <ddarius> slava: There is HaRe
17:18:19 <dmhouse> hasktags.
17:18:31 <Twey> dobblego: *laughs*
17:18:42 <slava> nothing like eclipse or idea though
17:18:56 <dobblego> does eclipse work yet?
17:19:06 <slava> i don't know; i don't program in java
17:19:16 <slava> but i've played around with it and code navigation and refactoring abilities are pretty impressive
17:19:17 <ddarius> slava: The members of the Haskell community don't want an Eclipse or IDEA?
17:19:24 <sampointon> actually, that's a good point. You'd think that it would be easy (ish) to write good refactoring tools for Haskell
17:19:34 <slava> ddarius: how do you jump to the definition of a function?
17:19:36 <sampointon> as opposed to, say, Python or Ruby
17:19:39 <dmhouse> slava: hasktags
17:19:45 <dobblego> I think @pl is a great refactoring tool
17:19:46 <slava> what about finding usages of a function?
17:19:47 <dmhouse> ?where hasktags
17:19:47 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
17:19:54 <slava> callers*
17:19:58 <ddarius> slava: I don't usually and I don't really mind that.
17:19:59 <dmhouse> slava: tags-search :)
17:20:13 <dmhouse> slava: but that's not actually a very common task if you're doing it righ.t
17:20:16 <ddarius> I could use dmhouses solution, but I've never been bothered by it enough to bother.
17:20:28 <dmhouse> M-. is actually very convenient.
17:20:34 <slava> i like 'go to definition' and 'find usages' myself.
17:20:50 <ddarius> slava: I use them in C#, but I feel more of a need to for some reason.
17:20:58 <dmhouse> There's C-c M-. which doesn't need TAGS if you've got your entire library loaded into GHCi.
17:21:10 <ddarius> Well, find usages.  I don't use Go to definition that much except for reference.
17:21:56 <ddarius> I tend to prefer documentation pages for what I would use Go to definition for (in both Haskell and C#)
17:22:04 <slava> ddarius: do you use C# professionally and Haskell in your spare time?
17:22:10 <ddarius> slava: Yes.
17:22:17 <slava> tool support isn't really needed for small projects
17:22:28 <slava> when you have 100 kloc you need semantic navigation...
17:22:29 <ddarius> slava: Most of my work projects aren't very big.
17:22:36 <ddarius> In fact, none of them are.
17:22:40 <dobblego> I'd rather "show type signature" and possibly expanding to "show QC tests" than "go to definition"
17:24:30 <slava> i also like pressing a single key to recompile all chnaged files and reloading them into a running app
17:24:44 <ddarius> slava: People were writing larger programs than that before semantic navigation and still do today.
17:24:58 <slava> ddarius: ok, 'need' is a strong word. 'nice to have'
17:25:28 <ddarius> slava: I'm perhaps not representative (of whatever group you want to fit here).  I'm a bit of a Luddite.
17:26:32 <ddarius> slava: Personally, I'd more lean that semantic navigation being nice is less a function of the size and more a function of how much code developed by others you have to deal with.
17:27:30 <slava> ddarius: its useful even when all of the code was written by yourself
17:28:06 <ddarius> I'm not saying it isn't useful then, but (at least as far as I can tell) less so.
17:28:41 <ddarius> I usually have a good idea where a function is or where I use it when I'm dealing with code that is solely mine.
17:29:27 <slava> right, and by the same line of argument we don't need type checking, or GC, etc ;)
17:29:56 <ddarius> slava: That doesn't follow at all.
17:30:09 <_JFT_> talking of semantic navigation I have a question... Where is the source code for "MutableArray#"?
17:30:14 <_JFT_> I can't seems to find it.
17:30:31 <slava> _JFT_: its a shame you can't just press one key and find it.
17:30:36 <_JFT_> (and I did grepped...)
17:30:54 <_JFT_> slava: I am not and IDE user so that's not a reflex for me ;)
17:31:11 <ddarius> slava: I can't press one key and find the source code of any of the .NET Framework libraries.
17:31:20 <dmhouse> ?hoogle MutableArray#
17:31:20 <lambdabot> No results found
17:31:28 <ddarius> Let alone the source code for int[]
17:31:38 <_JFT_> I grepped the source code and I see references but no definition?!
17:31:53 <slava> ddarius: that's because .NET sucks :)
17:32:13 <Botje> _JFT_: the # says it's probably a part of GHC
17:32:24 <_JFT_> Botje: yes it is
17:32:39 <_JFT_> Botje: I'm trying to see how STArray are implemented and it is used ther
17:32:49 <_JFT_> Botje: hence why I am looking for them :D
17:33:39 <olsner> heh, I'm actually pretty proud of (fmap fmap fmap concat fmap)
17:33:45 <slava> ddarius: the fact that types such as int[] are 'special' is one thing I don't like about Java and C#
17:34:04 <slava> you can't find [] defined anywhere, its spread out between the grammar, compiler internals, VM, etc.
17:34:05 <dmhouse> slava: well, Int is special in Haskell, too.
17:34:13 <dmhouse> Same with lists in Haskell.
17:34:28 <Botje> _JFT_: http://www.macs.hw.ac.uk/~dsg/gph/docs/4.06/users_guide/ghc-language-features.html
17:34:32 <lambdabot> Title: GHC Language Features, http://tinyurl.com/5kyfy4
17:34:42 <Botje> it's old but i'll give you an idea
17:34:48 <dmhouse> [1,2,3], "abc", [1..], [1..3] -- all built-in syntax sugars
17:34:49 <slava> aren't lists just data List a = a :: (List a) | Nil
17:34:58 <_JFT_> Botje: Woot! Thank you
17:35:08 <dmhouse> At the type level [a] is sugar.
17:35:18 <dmhouse> slava: yes, essentially, but there's a ton of sugar.
17:35:33 <ddarius> dmhouse: A lot of very light sugar.
17:35:34 <slava> as long as it desugars to something within the language, that's fine.
17:35:39 <dmhouse> I guess this is not too bad, the concept is essentially definable in the language, but there's a lot of sugar on top.
17:35:46 <Botje> does haskell do cdr-coding?
17:35:48 <_JFT_> Botje: but I still don't understand how the grep of the full source missed it... (maybe I need more cafein!)
17:35:53 <ddarius> Botje: Hell no.
17:36:07 <dmhouse> Botje: what is cdr-coding?
17:36:36 <slava> an archaic optimizations for lisps which did not have arrays
17:36:46 <Botje> you tag the cons-cell with a special value so that the cdr is on the next address
17:36:50 <Botje> saving a pointer
17:37:01 <dmhouse> Oh.
17:37:14 <dmhouse> Doesn't sound very useful in Haskell.
17:37:21 <slava> it isn't useful if you have arrays
17:37:35 <dmhouse> Might be useful for lists, but they can get very large.
17:37:41 <dmhouse> (And we do have arrays.)
17:37:46 <dmhouse> (But they're a bit icky.)
17:37:50 <Philonous> Gladly Haskell doesn't use semi-colons so massively. All the sugar would cause massive cance and finally ; would be Q
17:37:50 <Botje> :)
17:37:57 <slava> dmhouse: why are they icky?
17:38:12 <dmhouse> Philonous: unfortunately the lack of semis makes tools a lot harder to write
17:38:23 <Botje> Philonous: noone's stopping you from using the alternative syntax, which DOES have a lot of ; :)
17:38:27 <dmhouse> Philonous: e.g. there are multiple valid indentation points on a given line of Haskell for mostly this reason.
17:38:55 <FunctorSalad> hmm, IO newbie question... you guys scared me the other day about nondeterministic IO... does this only apply for the "unsafe" family of functions? for example, I have main = do { hSetBuffering stdin NoBuffering; ... hGetChar stdin ... } -- clearly that shouldn't be permuted. is it safe?
17:39:36 <_JFT_> dmhouse: Tell me about it, I coded a DSL for a project at work and I didn't put terminator either and if it is sure nicer looking it give some headache for parsing at times...
17:39:49 <olsner> FunctorSalad: are you young enough to actually get scared by talk in #haskell? I always thought you a "veteran"...
17:40:21 <FunctorSalad> olsner: hmm, I don't think I'm a haskell veteran...
17:40:24 <dmhouse> slava: I'm not 100% certain on this, I barely use them myself, but I think most Array implementations aren't purely functional.
17:40:38 <_JFT_> FunctorSalad: yes mostly "unsafe" is breaking the determinism
17:40:38 <dmhouse> I.e. they use a lot of dirty, dirty IO and unsafePerformIO underneath.
17:40:49 <slava> dmhouse: persistent arrays exist too though right?
17:41:03 <slava> you can wrap the mutable stuff in something pure
17:41:16 <olsner> FunctorSalad: but you've been in #haskell-blah like forever?
17:41:21 <dmhouse> Yes, of course, but it's still icky on one level :)
17:41:30 <FunctorSalad> olsner: yes. :)
17:41:41 <slava> i don't think mutable state is inherently icky, its just overused by many programmers
17:41:52 <dmhouse> ?instances IArray
17:41:53 <lambdabot> Couldn't find class `IArray'. Try @instances-importing
17:42:02 <dmhouse> ?instances-importing Data.Array.IArray IArray
17:42:03 <lambdabot> Array e
17:42:12 <FunctorSalad> _JFT_: so the safe IO actions get performed in the order they are executed? I remember the discussion here about it being hard to figure out the execution order in haskell
17:42:15 <slava> @src Array
17:42:15 <lambdabot> Source not found. Are you on drugs?
17:42:26 <dmhouse> See the Data.Array.* hierarchy.
17:42:29 <FunctorSalad> olsner: are you saying only veterans are allowed in blah? ;)
17:42:37 <ddarius> slava: Agreed.
17:42:38 <_JFT_> FunctorSalad: yes
17:42:49 <_JFT_> FunctorSalad: that's the whole point of IO in a sense :)
17:43:02 <_JFT_> (in a sense )
17:43:21 <Botje> FunctorSalad: yes. it's only when you have eg. do contents <- readFile h; closeFile h
17:43:22 <FunctorSalad> _JFT_: I guess a sequence of statements in a do statement should be guaranteed to be executed in that order though...
17:43:41 <_JFT_> FunctorSalad: see ReverseStateMonad (and get a headache :P)
17:43:42 <Botje> if you don't evaluate contents before closeFile, the read doesn't happen
17:43:54 <ddarius> FunctorSalad: The whole point of unsafeInterleaveIO is that it causes an IO action to be executed when the value the result is bound to is evaluated.
17:44:18 <Philonous> FunctorSalad: That should depend on the underlying monad, but for IO I guess you are right.
17:44:33 <_JFT_> FunctorSalad: what happens inside a "do" statement is dependent solely on the bind implementation... Sometimes it can be surprising :D
17:44:34 <FunctorSalad> ok, thanks everyone
17:44:35 <ddarius> Botje: readFile doesn't take a handle.
17:44:47 <Botje> fine, hGetContents
17:44:47 <FunctorSalad> _JFT_: yeah, for IO
17:44:54 <Botje> didn't remember when i wrote that :p
17:45:25 <Botje> bedtime!
17:45:41 <Botje> have to wake up at a godawful time in the morning on monday
17:46:00 <olsner> FunctorSalad: no, only that you're supposed to not be afraid just because something's been debated in #haskell :)
17:46:07 <ddarius> I get to sleep in (relatively speaking) this Monday
17:46:15 <Twey> > (do s <- [3, 5]; [2, s]) :: [a]
17:46:16 <lambdabot>      Could not deduce (Num a) from the context ()
17:46:16 <lambdabot>       arising from the lite...
17:46:19 <Twey> :<
17:46:24 <ddarius> The sun will actually be up when I wake up.
17:46:34 <FunctorSalad> ddarius: hmm, ok, but the ordering of the IO actions in the IO x value depends on the evaluation order regardless of use of "unsafe"?
17:47:08 <ddarius> FunctorSalad: As _JFT_ said, the ordering of the operations depends on the implementation of (>>=) primarily.
17:47:20 <dmhouse> Twey: it doesn't have type [a], it has type Num a => [a]
17:47:30 <dmhouse> > (do s <- [3, 5]; [2, s]) :: Num a => [a]
17:47:31 <Twey> Ah, so it does.
17:47:32 <lambdabot>  [2,3,2,5]
17:47:40 <Twey> Thanks :)
17:47:43 <ddarius> For IO, actions will get executed in the order they are written.
17:47:46 <FunctorSalad> olsner: I was being slightly facetious, I meant that I was getting nervous that my IO actions might be getting mixed
17:48:08 <_JFT_> ddarius: unless he plays with unsafePerformIO...
17:48:11 <Botje> > [3,5] >>= (2:) . return -- pointless!
17:48:13 <lambdabot>  [2,3,2,5]
17:48:19 * Twey pats.
17:48:22 <Twey> Indeed.
17:48:30 <Twey> But the question was about do blocks :-P
17:48:41 <Botje> meh :)
17:48:42 <ddarius> _JFT_: The result of unsafePerformIO isn't an IO action.
17:49:11 * Botje >>= snore
17:49:17 * Twey laughs.
17:49:18 <Philonous> Btw. is there a constraint solver library for haskell?
17:49:32 <Twey> goodnight >>= botje
17:49:33 <ajdhs> hi
17:49:36 <FunctorSalad> right now I'm thinking of an IO x as ([IoAction], x) with the array of IoActions being interpreted by the OS "afterwards" (not really, but conceptually)
17:49:57 <ajdhs> does anyone know how to get a current GHC development repo?
17:49:59 <_JFT_> ddarius: true, but since "some" IO took place at some time it is easy to get confused... I did lose quite a bit of time early one trying to get "pure" function using it. I've been bitten enough to understand a bit better then unsafe beast :P
17:50:14 <_JFT_> ddarius: let just say I undersand better the "unsafe" part of the name lol
17:50:31 <ajdhs> with the libraries and everything?
17:50:40 <arj__> Philonous, perhaps this will help? http://overtond.blogspot.com/2008/07/haskell-sudoku-solver-using-finite.html
17:50:42 <lambdabot> Title: David's Blog: A Haskell Sudoku Solver using Finite Domain Constraints, http://tinyurl.com/5vw9c9
17:53:55 <Philonous> Well, yes, but I hoped there would be a complete library for it. But it will do ;)
17:54:01 <FunctorSalad> one more thing, do I have to worry about non-bash-safe characters in HSH?
17:55:09 <FunctorSalad> the instance (ShellCommand (String,[String])) instance says it avoids the shell altogether
17:55:26 <FunctorSalad> but if the called command itself has issues with special characters I guess that won't save me
17:56:35 <arj__> > map (+1) [1..10]
17:56:37 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:56:45 <FunctorSalad> oh well, I'll just run detox on the files first ;)
17:57:21 <arj__> @help
17:57:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:58:13 <_JFT_> list
17:58:21 <_JFT_> help list
17:58:23 <_JFT_> @help list
17:58:23 <lambdabot> list [module|command]
17:58:24 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
17:58:27 <arj__> @list
17:58:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:58:43 <arj__> list
17:58:58 <arj__> is there a way I can play with lambdabot without anoying all the people here?
17:59:10 <FunctorSalad> /query lambdabot, arj__
17:59:15 <mmorrow>    /msg lambdabot > fix show
17:59:23 <arj__> ah thank you
18:13:30 <Philonous> Are there any lazy functions except list concatonation?
18:14:39 <dmhouse> Philonous: loads.
18:14:52 <dmhouse> > const "foo" undefined {- canonical example -}
18:14:54 <lambdabot>  "foo"
18:15:18 <Philonous> Ok right
18:15:34 <dmhouse> Any data constructor is lazy, unless its argument has a ! in front of it
18:15:44 <dmhouse> I.e. Just undefined is distinguishable from undefined, so Just is lazy.
18:15:59 <dmhouse> (The function foo (Just _) = 42 distinguishes.)
18:16:04 <Philonous> Ah, that's what I wanted to know.
18:16:43 <dmhouse> But if you defined data MaybeS a = NothingS | JustS !a, then JustS undefined = undefined, so JustS is strict.
18:16:45 <Philonous> What I actually meant whas whether there is a way to prevent an expression to be evaulated completely, but with algebraic types it is of course
18:17:54 <bpalmer> 'prevent an expression to be evaluated' -- shouldn't it not matter whether it's evaluated?
18:17:59 <Philonous> So actually fix can be seen as a generalization of Prelude.cycle (or do I miss any import applications)
18:18:14 <Philonous> bpalmer: When it is infinite?
18:18:18 <dmhouse> fix isn't really applicable to anything
18:18:25 <dmhouse> It's just interesting theoretically.
18:18:45 <dmhouse> It hasn't really got much to do with cycle, although fix (xs ++) == cycle xs
18:18:58 <dmhouse> Same as fix (x :) == repeat x
18:19:10 <dmhouse> > fix Just
18:19:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe a
18:19:12 <lambdabot>       Expe...
18:19:21 <dmhouse> Oh, err, yeah.
18:19:45 <mmorrow> > let cycle = fix . (:) in cycle 4
18:19:47 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
18:19:57 <Philonous> dmhouse: Well yes. Of course it is not _really_usefull. But you could for example easily express some infinite tree with it.
18:20:08 <dmhouse> mmorrow: that's not what cycle is
18:20:10 <dmhouse> > cycle 4
18:20:12 <lambdabot>      No instance for (Num [a])
18:20:12 <lambdabot>       arising from the literal `4' at <interac...
18:20:14 <mmorrow> heh, repeat
18:20:27 <Zao> > cycle "ke"
18:20:27 <Philonous> >cycle [4]
18:20:29 <lambdabot>  "kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek...
18:20:29 <dmhouse> Philonous: more natural to use data structures.
18:20:58 <dmhouse> Philonous: when it gets *really* interesting is when you bring in type-level fixed point operators :)
18:21:08 <mmorrow> > let cycle = concat . fix . (:) in cycle [0..9]
18:21:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7...
18:21:27 <ddarius> dmhouse: fix is applicable to many things, we just have nicer syntax for it
18:21:39 <mmorrow> my favorite ...
18:21:47 <dmhouse> ddarius: recursive let is more fundamental to Haskell, IMO
18:21:50 <mmorrow> > fix ((0:) . scanl (+) 1)
18:21:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:21:58 <dmhouse> ddarius: since fix isn't built-in, according to the report
18:22:14 <dmhouse> ddarius: and is defined in terms of recursive let
18:22:21 <dmhouse> Recursive let and fix are basically equivalent.
18:22:43 <mmorrow> in Data.Function it's   fix f = let x = f x in x
18:22:57 <dmhouse> Yes, which illustrates that quite nicely.
18:23:04 <mmorrow> indeed
18:24:33 <dmhouse> Anyway, bedtime.
18:25:08 <hackage> Uploaded to hackage: dotgen 0.1
18:25:08 <hackage> Uploaded to hackage: ieee-utils 0.1
18:25:51 <mm_freak_> how can i split a very long decimal number to several lines?  i'd like not to use 'read'
18:26:10 <mmorrow> heh, anyone was interested in that earlier discussion about ieee754 rounding mode/etc, i wrote a binding to C to get/set the rounding mode
18:26:22 <mmorrow> *anyone /that/ was ...
18:26:23 <sclv> mmorrow: awesomes!
18:26:48 <ajdhs> mm_freak_: use a function to split a list into equal lists and then use unlines on that
18:27:18 <mmorrow> sclv: i think next i'm gonna add querying of the fp exceptions
18:27:23 <sclv> we should round that out with the other bindings from fenv, and then we can start playing with apis.
18:27:43 <sclv> I don't even need this myself, but its k-interesting.
18:27:45 <mm_freak_> ajdhs: i'm talking about source code…  i have to hard-code a very long number
18:27:49 <mmorrow> sclv: i used this for reference http://www.gnu.org/software/libc/manual/html_mono/libc.html#Floating-Point-Numbers
18:27:52 <ajdhs> oh
18:28:01 <lambdabot> Title: The GNU C Library, http://tinyurl.com/js69h
18:28:15 <mmorrow> sclv: here are the haddock docs: http://code.haskell.org/~morrow/code/haskell/ieee-utils/haddock/
18:28:21 <mmorrow> (and the darcs repo)
18:28:25 <lambdabot> Title: ieee-utils-0.1: ieee-utils
18:28:27 <mm_freak_> the backslash doesn't work for haskell
18:28:34 <mmorrow> patches welcome!
18:28:50 <mmorrow> (not @ you mm_freak_)
18:29:01 <mmorrow> (well, at everyone)
18:29:08 <mm_freak_> hehe
18:29:11 <mmorrow> heh
18:29:46 <mmorrow> <sclv> we should round that out with the other bindings from fenv, and then we can start playing with apis.
18:29:48 <mmorrow> totally
18:29:56 <ajdhs> mm_freak_: you can use backslashes if you use cpp
18:30:29 <mm_freak_> bad solution, so it looks like i'll have to use 'read'
18:30:52 <mm_freak_> or arithmetic
18:31:19 <ajdhs> or put it in a C header file and #include that after CPPing it
18:33:55 <stepcut> mmorrow: regarding ieee fp, cool
18:34:53 <mm_freak_> i'd like not to use cpp just for that one number
18:35:19 <mmorrow> stepcut: :)
18:35:53 <stepcut> Stability: unstable :p
18:36:26 <mmorrow> err, not especially. there's not really enough to it to /be/ unstable
18:37:23 <mmorrow> i was planning on uploading 0.2 in a bit with more comments and a link the the haddock docs. i'll change the stability to "provisional" then.
18:38:11 <mmorrow> and i plan on maintaining it as well
18:38:30 <stepcut> cool
18:38:45 <FunctorSalad> where in the hierarchy is "provisional"?
18:38:56 <FunctorSalad> (been wondering)
18:39:19 <mmorrow> from what i understand/have seen       unstable --> provisional --> stable
18:39:43 <FunctorSalad> experimental preceding all of them?
18:39:53 <FunctorSalad> I've also seen "mature" but not sure whether it was haskell ;)
18:40:12 <stepcut> volitile
18:40:20 <mmorrow> heh
18:40:33 <stepcut> oops, volatile
18:40:50 * gwern learns what 'sudo init 1' does
18:41:05 <stepcut> :)
18:41:05 <TomMD> init 6 is your friend.
18:41:16 <Saizan_> init 0, ftw
18:41:16 <stepcut> my init goes up to 11
18:41:41 <gwern> yeah? well, my init is red!
18:41:42 <FunctorSalad> what's 1? safe mode?
18:41:54 <gwern> try it and see
18:42:14 <stepcut> gwern: I see your init's almost as big as mine.
18:42:16 <FunctorSalad> nah it will probably stop my kdm/xserver
18:42:43 <gwern> stepcut: this discussion is too sensitive. we must join ##the-cone-of-silence!
18:45:36 <newsham> kill -HUP 1
18:46:15 <FunctorSalad> I had an immortal process earlier today :(
18:47:03 <newsham> everyone dies sooner or later
18:47:37 <FunctorSalad> yeah well, inviolable then
18:47:49 <FunctorSalad> it evolved resistance to kill -kill
18:50:37 <gwern> a haskeller who has achieved enlightenment is like an arrow evaluating straight to hell
18:50:38 <seydar> Twey: i have a confession to make
18:51:49 * gwern reads http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html and thinks wtf
18:51:50 <Twey> seydar: Oh aye?
18:52:11 <seydar> Twey: http://mvanier.livejournal.com/1901.html i am totally lost
18:52:17 <seydar> this goes beyond the saran wrap analogy
18:52:27 <sbahra> alo Twey
18:52:31 * Twey chuckles.
18:52:33 <Twey> Hi, seydar
18:52:35 <Twey> Er, sbahra
18:52:56 <Twey> I don't like that State explanation much
18:52:59 <Twey> It's very abstract
18:53:03 <seydar> yea, i agree
18:53:26 <seydar> I'm trying to figure out how to use things like State { val :: monkey }
18:53:34 <Twey> Here:
18:53:36 <Twey> http://en.wikibooks.org/wiki/Haskell/Understanding_monads
18:59:15 <newsham> while you were busy evaluating i was busy thunking
18:59:52 <newsham> > runState (do { x <- get; put (x+5); return (x+10) }) 100
19:00:26 <newsham> ?bot
19:01:54 <newsham> > runState (do { x <- get; put (x+5); return (x+10) }) 100
19:01:55 <noBotE>  (110,105)
19:02:34 <Saizan_> what happened to \bot?
19:03:21 <newsham> dunno
19:04:47 <gwern> > 1 + 1
19:05:08 <newsham> i'll leave him here for a little while.
19:05:45 <Saizan_> > undefined
19:05:46 <noBotE>  Exception: Prelude.undefined
19:05:56 <gwern> hm. lambdabot isn't responding to privmsgs
19:07:01 * Saizan_ wonders in what dark corners the control flow is trapped
19:07:19 <newsham> he's unsafely performing io
19:07:30 <Saizan_> s/he/she/
19:07:39 <newsham> > runState get 100
19:07:41 <noBotE>  (100,100)
19:07:48 <newsham> > runState (put 5) 100
19:07:49 <noBotE>  ((),5)
19:07:58 <Saizan_> it's saturday night, who knows what she's doing!
19:08:05 <newsham> > runState (return 5) 100
19:08:06 <noBotE>  (5,100)
19:08:18 <newsham> ?vixen what do you do on saturday nights?
19:08:19 <noBotE> let's don't talk about that
19:08:39 <newsham> > runState (return "testing") 100
19:08:40 <noBotE>  ("testing",100)
19:08:44 <seydar> Twey: behind the saran wrap of knowledge is the yummiest monad sandwich ever, i can just tell
19:09:49 * Twey laughs.
19:10:01 <Twey> They're pretty tasty.  :)
19:10:29 <newsham> good sandwich when you're in a pickle?  better when you're in a bind.
19:11:56 <seydar> man my brain hurts
19:12:08 <newsham> i get that feeling often
19:13:06 <newsham> seydar: any specific questions?
19:13:37 <seydar> newsham: not yet
19:13:49 <seydar> but i swear, if you sign off before i finish this article....
19:13:58 <newsham> state monad makes a lot of intuitive sense when you see them in operation
19:14:09 <dsrogers> I like sandviches better than sandwiches
19:14:30 <seydar> newsham: examples please!
19:14:39 <newsham> the underlying values are functions from input state to a tuple of (result, output state)
19:14:56 <newsham> and since they form a monad, you can glue them together with do blocks or (>>=)
19:15:11 <newsham> ok.. so the simplest examples are the primitives get,put and return
19:15:27 <newsham> > runState (return "test") 100
19:15:28 <noBotE>  ("test",100)
19:15:41 <newsham> maps 100 to ("test",100)
19:15:52 <newsham> where 100 is the initial state, "test" is the result and 100 is the final state
19:16:01 <newsham> > runState get 100
19:16:02 <noBotE>  (100,100)
19:16:22 <newsham> maps 100 -> (100,100)  initial state and final states are 100, final result is 100
19:16:31 <newsham> > runState (put 5) 100
19:16:32 <noBotE>  ((),5)
19:16:40 <seydar> who wrote this article, btw? it's great
19:16:47 <newsham> maps 100 -> ((), 5)    where 100 is initial state, and final state is 5 and result is ()
19:16:57 <newsham> do those three make sense to you?
19:17:27 <seydar> processing....
19:18:39 <seydar> and watching olympics.... but more processing....
19:18:44 <newsham> :)
19:19:43 <_JFT_> seydar: which other language do you know?
19:19:46 <seydar> ok. the first one did
19:19:50 <newsham> here I'm using an integer state, so the type would be someting like "State Int String"  for the (return "test") item
19:20:02 <seydar> _JFT_: ruby, java. working on haskell now
19:20:05 <newsham> and   runState (return "test") ::  Int -> (String, Int)
19:20:19 <seydar> newsham: i dont get the get and put parts
19:20:35 <newsham> ok, so the return tuple has a final state value as one of its elements, yes?
19:20:41 <_JFT_> seydar: imagine that you have exactly one global variable which is available to you in the state monad, you can either get it, modify it (or not touch it)
19:21:11 <_JFT_> seydar: and as newsham is showing you, you are tranporting that global with you with each computation
19:21:20 <newsham> what "put" does is sets the result type to () (think "void") and fills in the final state with the value you're "put"ting
19:21:29 <_JFT_> seydar: and, as can be seen, is the runState you choose its initial value
19:21:37 <newsham> what "get" does is takes the input state and returns it as both the final state (get doesnt change the state) and the result
19:21:57 <binarybandit> Is there a better tutorial/book for an absolute FP beginner?
19:21:59 <sbahra> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=psyco
19:22:01 <noBotE> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/6rsefg
19:22:02 <newsham> these are all forming functions    InputState -> (ResultValue, OutputState)
19:22:06 <seydar> ok, hold on
19:22:20 <joey__> seydar: Have you seen the typical "Relabel a tree" example yet for state?
19:22:29 <seydar> The general type of this all is: Initial State -> (Result, Final State), right?
19:22:36 <seydar> joey__: no
19:22:47 <_JFT_> seydar: yes
19:22:55 <joey__> It's an excellent example of using State
19:22:59 <seydar> yay!
19:23:03 <_JFT_> seydar: but final as current version of it ;)
19:23:03 <newsham> seydar: yes, thats the underlying type.  its kinda "wrapped up" in a way though
19:23:09 <binarybandit> erm
19:23:10 <binarybandit> whoops
19:23:14 <newsham> so it might be called     State Int String,  for example.
19:23:19 <seydar> ok, i need a minute to go relook at newsham's examples
19:23:19 <binarybandit> Real world haskell is available free online, right? Is it a good introductory tutorial?
19:23:28 <newsham> which would wrap up the underlying typ eof   Int -> (String, Int)
19:23:36 <newsham> binary: it is and it is.
19:23:59 <newsham> you have to use the "function" runState to get at the actual underlying function
19:23:59 <gwern> @seen mmorrow
19:24:00 <noBotE> mmorrow is in #haskell. I don't know when mmorrow last spoke.
19:24:04 <_JFT_> seydar: another way to look at it is that the state monad doesn't do the computation it build a function that, given an input state, will do the processing
19:24:26 <newsham> seydar: feel free to retry and alter the examples..  it helps to interact with it
19:24:43 <binarybandit> newsham, thank you. :)
19:24:45 <_JFT_> seydar: I guess it is weird the but the accumulator function trick in "The Little Lisper" is the analogy that finally got me to grok state monad
19:24:59 <newsham> > runState (return pi) "this is my state"
19:25:00 <noBotE>  (3.141592653589793,"this is my state")
19:25:14 <seydar> newsham: i was able to predict that!
19:25:24 <seydar> _JFT_: do you have the link to that handy?
19:25:26 <_JFT_> seydar: I meant "Little Schemer" actually
19:25:36 <_JFT_> seydar: sorry it is a dead tree format ;)
19:25:42 <gwern> @tell mmorrow I'm going to need a patch just for Context.hs - I could apply main.hs and mueval.cabal, but not Context.hs, and I can't read diffs well enough to merge it in by hand
19:25:43 <noBotE> Consider it noted.
19:25:52 <gwern> preflex: tell mmorrow I'm going to need a patch just for Context.hs - I could apply main.hs and mueval.cabal, but not Context.hs, and I can't read diffs well enough to merge it in by hand
19:25:52 <preflex>  Consider it noted.
19:25:53 <_JFT_> seydar: but that exemple use recursion to build a function which is later applied
19:25:54 <seydar> dead  tree format is usually the best
19:26:08 <gwern> preflex: tell mmorrow oh, and I pushed what I could to the repo
19:26:09 <newsham> once you have the primitives you can paste them together with do-notation (or >>=)
19:26:09 <preflex>  Consider it noted.
19:26:14 <_JFT_> seydar: using the state monad you (using "do") you are basically assembling a function (not a value)
19:26:31 <_JFT_> seydar: to apply that function and get a value you use runState linke newsham showed you
19:26:39 <joey__> seydar: http://hpaste.org/9875
19:26:40 <newsham> > runState (do { x <- get; put (x+1); return "done!" }) 100
19:26:41 <noBotE>  ("done!",101)
19:26:52 <joey__> If you can make sense of that, I think it'll give you a good appreciation
19:26:59 <newsham> that gets the initial value 100 into x, stores the new value 101, and returns "done!"
19:27:37 <adu> I'm really liking GHC Core
19:27:55 <seydar> newsham: ok, that one was a hard one, but i made sense of it
19:28:10 <newsham> > let incr = (do {x <- get; put (x+1)}) in runState (do {incr; incr; incr; get}) 100
19:28:11 <noBotE>  (103,103)
19:28:58 <seydar> newsham: what is <-, actually? in my mind it unwraps the saran wrap, and gives x the sandwich within
19:29:09 <_JFT_> seydar: yes
19:29:12 <adu> but I am confused on a couple things, like what is "%note" for?
19:29:13 <newsham> thats not a bad way to think of it
19:29:23 <ddarius> newsham: Sure it is.
19:29:25 <newsham> its getting the "result" value
19:29:30 <ddarius> > do x <- Nothing; return 3
19:29:31 <noBotE>  Nothing
19:29:32 <mmorrow> gwern: no problem, i darcs send a patch.
19:29:32 <preflex>  mmorrow: you have 2 new messages. '/msg preflex messages' to read them.
19:29:32 <newsham> ddarius thinks its a bad way to think of it
19:29:32 <noBotE> mmorrow: You have 1 new message. '/msg noBotE @messages' to read it.
19:29:44 * gwern was covering my bases :)
19:30:03 <newsham> nobote is not a good ?tell recepticle
19:30:47 * ddarius wonders how many messages lambdabot is holding for typoed nicks.
19:30:49 <mmorrow> heh
19:31:26 <newsham> seydar:  do { x <- act; func2act x }   is just fancy syntax for   act >>= (\x -> func2act x)
19:31:34 <adu> seydar: without the seran wrap and the sandwich and the mind parts, yeah that works
19:31:47 <newsham> which glues together these monadic action things
19:32:07 <newsham> in this case, glueing together the State functions in a way that lets you get at their intermediate results
19:32:28 <seydar> adu killed my self esteem in like, 10 words.
19:32:56 <seydar> newsham: ok, lets go back to >>= again
19:33:24 <seydar> it takes the result of act, and passes it to the next function, right?
19:33:32 <newsham> > runState (get >>= (\v -> return (v+1)))   100
19:33:33 <noBotE>  (101,100)
19:33:42 <seydar> yessss
19:33:53 <newsham> it glues together the "get" and the (\v -> return (v+1)) to form a bigger state "thing"
19:34:16 <newsham> so that when that thing is run,  the "v" gets the intermediate result coming out of the "get"
19:34:23 <dino-> :t (>>=)
19:34:24 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:34:57 <newsham> note that (>>=) didnt run the first and then rn the second..   it didnt run anything, its just glued them together into a bigger State thing
19:35:08 <_JFT_> when you understand monad that type signature is so clear but yet when you learn them it is so confusing ....
19:35:09 <newsham> we still needed to use runState and provide an argument to make it "run"
19:35:20 <_JFT_> (I mean the (>>=) one)
19:35:33 <newsham> its just glue in your state construction kit
19:35:40 <seydar> whats the purpose of runState?
19:35:59 <_JFT_> seydar: to evaluate the function you just assembled using monad notation
19:36:00 <Saizan_> _JFT_: that's because tutorials don't give a proper introduction to types and typeclasses first, i think
19:36:04 <newsham> runState takes your  (State Int String) thing and gives you a (Int -> (String,Int)) tihng
19:36:09 <_JFT_> Saizan_: I agree
19:36:31 <newsham> it gives you access to the function that you need to use to run the state program you bulit
19:36:34 <newsham> built
19:36:51 <seydar> _JFT_: runState is a learning tool?
19:36:52 <_JFT_> seydar: in a monad when you see (<-) it does not "immediatly" get the value it sequences an operation that will once you evaluate the monad with runState
19:37:08 <_JFT_> seydar: no, the evaluator for a State Monad..
19:37:10 <newsham> (its actually something like:     data State a b = State { runState :: (a -> (b,a)) }
19:37:46 <newsham> ?type runState
19:37:47 <noBotE> forall s a. State s a -> s -> (a, s)
19:37:49 <dino-> When you get up to the part in YAHT where it walks you through building a state monad yourself, I felt like there had been a decent amount of background in the type system. It's complicated and was hard for me then, but it seemed like a fair time in the book to get down to it.
19:38:24 <newsham> just think of "runState" as "the thing which runs the program I built up"
19:38:33 <_JFT_> seydar: if you see "head . (drop 10)" do you expect a value?
19:38:40 <newsham> just like you should think of "main" as "the program I build up that gets run"
19:38:54 <seydar> _JFT_: no
19:38:55 <_JFT_> seydar: with the "." you assembled a bigger function
19:39:14 <_JFT_> seydar: likewise with  the "do" in the state monad, you assembled a bigger function
19:39:32 <seydar> nice
19:39:36 <_JFT_> seydar: runState is just a function that take that newly assembled function and its input to give you a result :)
19:39:37 <Saizan_> dino-: yeah, but YAHT almost starts with IO, iirc
19:39:49 <seydar> whats YAHT?
19:40:01 <Saizan_> ?whre YAHT
19:40:01 <noBotE> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:40:08 <newsham> I like to think of   do { x <- act; more }   as a sort of   "monadlet x = act in more"
19:40:39 <_JFT_> Despite beeing old I still think the best intro to Haskell is SoE
19:40:43 <FunctorSalad> uhm, how do I show a Show a without quotes? ;)
19:40:55 <newsham> in a similar way that    let x = expr in more   is like   (\x -> more) expr
19:41:07 <_JFT_> if you show a show you are stringifiying a string? ;)
19:41:10 <newsham> > show 5
19:41:11 <noBotE>  "5"
19:41:25 <newsham> functor:  putStrLn (show 5)     <- no quotes come out
19:41:50 <Saizan_> it depends, putStrLn (show "a") has quotes
19:41:57 <FunctorSalad> yeah but I have printf "%s %s" (show foo) (show bar) -- of course I could do list operations to lose the quotes
19:41:59 <newsham> (act >>= (\x -> more))
19:42:07 <newsham> and (\x -> more) expr
19:42:13 <newsham> are somewhat similar, as you can see
19:42:47 <qwr> _JFT_: why not gentle introduction? :)
19:42:52 <seydar> _JFT_: i have that! took a course that used it. fell in love with haskell then, but never had time to get into it
19:42:52 <newsham> functor: if its already a string you dont need the "show"
19:42:55 <dino-> Saizan_: Yes, I guess it gets into IO early. But not before type things.
19:43:02 <newsham> printf "%s %s" foo bar
19:43:06 <FunctorSalad> newsham: but it isn't, it is a FilePath to be exact
19:43:14 <newsham> type FilePath = String
19:43:15 <_JFT_> seydar: biggest weakness of SoE is the monad cover IMO
19:43:18 <Saizan_> ?src FilePath
19:43:18 <noBotE> type FilePath = String
19:43:23 <_JFT_> qwr: I dunno it never did it for me :(
19:43:27 <dino-> It's tough like that. You have to just trust everybody a little while about that magic IO box until you learn more.
19:43:46 <FunctorSalad> Saizan_: odd. it didn't work without show
19:43:47 <ddarius> Indeed newsham you can use =<< to make it closer.
19:44:12 <newsham> (\x -> more) =<< act
19:44:16 <ddarius> And of course there is a reason why (>>=) is read as "bind"
19:44:28 <seydar> ok, so i think i understand >>= and the whole get put return business
19:44:31 <seydar> unless i dont
19:44:41 <FunctorSalad> Saizan_: maybe it's the sophisticated typing done by printf
19:44:42 <Saizan_> > printf "foo: %s" ("Foo.hs" :: FilePath) :: String
19:44:43 <noBotE>  "foo: Foo.hs"
19:44:43 <newsham> so why dont we have a "monadlet" syntactic sugar? :)
19:45:04 <_JFT_> seydar: (>>=) "pipe" the output of the left side to the right side
19:45:11 <newsham> seydar: ok, now try it out.
19:45:13 <ddarius> newsham: We do, it's called do-notation.  Alternatively, you can look at Moggi's monadic metalanguage which pretty much uses that notation.
19:45:23 <FunctorSalad> > printf "foo: %s" ("Foo.hs" :: FilePath)
19:45:23 <Saizan_> FunctorSalad: that could give some problems, maybe hpaste the code?
19:45:24 <noBotE>  Add a type signature
19:45:27 <seydar> newsham: what am i trying out
19:45:49 <newsham> seydar: write some expressions for lambdabot to eval using get/put/return and do-blocks or (>>=)
19:46:22 <newsham> functorsalad: printf needs to know its return type (ie. String or IO ())
19:46:31 <FunctorSalad> Saizan_: hmm now it works without any annotations, must have been something else. thanks anyway :)
19:46:40 <FunctorSalad> newsham: yeah maybe that was it
19:47:26 <qwr> seydar: do { x <- a; b x } is equivalent to a >>= \x -> b x
19:47:40 <seydar> with put, the Result gets piped as the initial state, or does the Final state get piped as the Initial?
19:47:51 <newsham> lets see...
19:48:03 <newsham> > runState (put "new state") "orig state"
19:48:04 <noBotE>  ((),"new state")
19:48:05 <_JFT_> seydar: with put you overwrite whatever that value was
19:48:44 <newsham> btw, there's also a "modify" which is like   do { x <- get; put (f x) }
19:48:57 <newsham> > runState (modify (+1)) 100
19:48:58 <noBotE>  ((),101)
19:49:20 <seydar> > runState (do {x <- get; put (x+1); put (x+1); get}) 100
19:49:21 <noBotE>  (101,101)
19:49:46 <seydar> ok, so my goal was (102, 102)
19:49:47 <newsham> your two "put (x+1)"   programs both wrote 101 to the state
19:49:55 <newsham> since x is 100 from the first get
19:50:00 <seydar> but wasn't the second "put (x+1)
19:50:07 <seydar> reading from ((), 101)?
19:50:12 <newsham> yah but x is the state read from the first get
19:50:18 <newsham> after you "get" x, it doesnt change
19:50:48 <seydar> so the initial state is superceding everything?
19:50:49 <newsham> > runState (do { x <- get; put (x+1); y <- get; put (y+1); get }) 100
19:50:50 <noBotE>  (102,102)
19:51:03 <seydar> i guess it is
19:51:04 <qwr> seydar: x is constant in that expression...
19:51:16 <seydar> but why is put reading from x?
19:51:19 <newsham> > let incr = modify (+1) in runState (do { incr; incr; get }) 100
19:51:20 <noBotE>  (102,102)
19:51:47 <newsham> "put" isnt reading from x,  put is putting  (x+1) because you wrote "put (x+1)"
19:52:01 <seydar> ...
19:52:08 <seydar> whoops
19:52:13 <newsham> after   x <- get,   gets run, the rest is like:   { put (100+1); put (100+1); get}
19:52:24 <seydar> i completely missed that i was doing that
19:53:03 <newsham> there's also another function:   gets f = do { x <- get; return (f x) }
19:53:10 <newsham> > runState (gets (+1)) 100
19:53:11 <noBotE>  (101,100)
19:53:32 <newsham> so now we have:  return, get, gets, put, modify, runState, (>>=)
19:54:32 <seydar> what did modify do?
19:54:45 <newsham> modify f = do { x <- get; put (f x) }
19:55:00 <newsham> > runState (modify (++ "!!!")) "Test"
19:55:01 <noBotE>  ((),"Test!!!")
19:55:10 <_JFT_> seydar: it takes the state as an input, modify it using the functino you passed and store it back
19:56:25 <ddarius> :t \f -> put <*> f <$> get
19:56:25 <newsham> taking off.. enjoy..
19:56:26 <noBotE> forall a a1 (f :: * -> *). (Functor f, MonadState a f, MonadState a ((->) a1)) => (a -> a1) -> f ()
19:56:38 <ddarius> :t \f -> put <*> (f <$> get)
19:56:39 <noBotE> forall s a a1. (MonadState a1 ((->) s), MonadState s ((->) a)) => (a1 -> a) -> s -> ()
19:56:47 <seydar> newsham: thank you sooo much
19:57:04 <newsham> :t \f -> put =<< f <$> get
19:57:05 <noBotE> forall (m :: * -> *) a. (MonadState a m, Functor m) => (a -> a) -> m ()
19:57:19 <newsham> seydar: no problem.  fun stuff.
19:57:45 <seydar> newsham: you should idle here all day tomorrow
19:58:09 <dsrogers> @instances Q
19:58:09 <noBotE> Couldn't find class `Q'. Try @instances-importing
19:59:00 <dsrogers> where do I get all these useful tools?
20:01:49 <seydar> _JFT_: you here for long?
20:02:09 <_JFT_> not too much more :P why?
20:02:25 <_JFT_> seydar: are you in a good "state" :D
20:02:42 <seydar> im good, but i haven't finished this article
20:02:44 <newsham> seydar: this channel is full of people who can help you out
20:02:57 <_JFT_> true that!
20:03:08 <seydar> ok
20:03:29 <_JFT_> (people smart enough to not exhaust their laptop like I just did lol)
20:03:45 <seydar> #haskell is like the greatest channel i've been in, honestly. maybe its cuz there are more people, but everyone here is so helpful
20:04:10 <_JFT_> it is true this channel is indeed awesome
20:04:24 <_JFT_> the attitude is right, it is not just the amount of people
20:04:30 <_JFT_> it is the quality;)
20:04:51 <adu> I have a proposal to make
20:04:56 <_JFT_> on that good night all
20:04:59 <seydar> i think the mathematical relation to haskell is big, too. you all love explaining these crazy details
20:05:15 <seydar> au revoir, _JFT_
20:05:40 <_JFT_> :)
20:06:23 <adu> the characters ?, @, and ~ do not have escape sequences in GHC Core
20:08:34 <seydar> can someone explain mapM_?
20:08:39 <adu> so I also noticed that the escape sequences zy, zo, and zf do not seem used...
20:08:45 <adu> seydar: sure!
20:08:58 <seydar> yay!
20:08:59 <adu> seydar: what don't you get about it?
20:09:10 <seydar> how it's monadic
20:09:13 <Saizan_> ?type mapM_
20:09:13 <noBotE> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:09:37 <ajdhs> it produces the side effects without the results
20:09:48 <adu> seydar: normally when you want to do an IO function over a list, you would use mapM
20:10:16 <ajdhs> so mapM [print "foo", print "bar", print "bat"] will print "foo"\n"bar"\n"bat and return ()
20:10:17 <adu> seydar: if you were to use "map" then (map myIOfunc myList) :: [IO a]
20:10:21 <ajdhs> I mean mapM_
20:10:45 <adu> seydar: but that is not of type IO, so (mapM myIOfunc myList) :: IO [a]
20:11:04 <ajdhs> never mind, that's sequence_, sorry
20:11:05 <adu> seydar: but the problem with that is if it is the last statement in the main function, then you have the wrong type
20:11:07 <FunctorSalad> ajdhs: mapM_ print ["foo",...]
20:11:15 <adu> seydar: so (mapM_ myIOfunc myList) :: IO ()
20:11:29 <adu> seydar: do you see the difference?
20:11:57 <seydar> no
20:12:02 <Saizan_> it's just more efficient ot discard the results if you're only interested in the side-effects
20:12:29 <Saizan_> seydar: are you familiar with map :: (a -> b) -> [a] -> [b] ?
20:12:34 <seydar> oh, so you can coerce the function into returning IO (), as opposed to IO [a]?
20:12:39 <seydar> Saizan_: yea
20:12:51 <adu> (map f xs) :: [IO a]
20:12:52 <adu> (mapM f xs) :: IO [a]
20:12:56 <adu> (mapM_ f xs) :: IO ()
20:13:10 <seydar> oh, so there IS a mapM!
20:13:16 <seydar> i thought ajdhs was making a typo
20:13:23 <Saizan_> ?type mapM
20:13:23 <noBotE> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:13:27 <Saizan_> ?src mapM
20:13:27 <noBotE> mapM f as = sequence (map f as)
20:13:30 <Saizan_> ?src mapM_
20:13:30 <noBotE> mapM_ f as = sequence_ (map f as)
20:13:32 <adu> seydar: do you see the difference now?
20:13:49 <seydar> yea, now i do
20:13:56 <seydar> ?src sequence
20:13:56 <noBotE> sequence []     = return []
20:13:56 <noBotE> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:13:56 <noBotE> --OR
20:13:56 <noBotE> sequence xs = foldr (liftM2 (:)) (return []) xs
20:14:23 <Saizan_> sequence takes a list of actions and returns a list of the results
20:14:26 <seydar> sweet. i understand that now
20:15:43 <Saizan_> ?src sequence_
20:15:43 <noBotE> sequence_ ms = foldr (>>) (return ()) ms
20:23:22 <seydar> adu: http://hpaste.org/9876, i'm attempting to write rollNDice from http://en.wikibooks.org/wiki/Haskell/Understanding_monads
20:24:02 <seydar> my issue is that i end up returning ([Int], Seed), as opposed to Seed -> ([Int], Seed)
20:24:13 <seydar> i'm close, i guess, so i'm not too far off.
20:25:09 <hackage> Uploaded to hackage: ieee-utils 0.2
20:25:26 <adu> seydar: whats returning ([Int], Seed)?
20:25:59 <adu> oic random
20:26:14 <seydar> i *think* i need to get the first seed from rollDie
20:26:23 <seydar> no, no, thats not it
20:26:44 <adu> seydar: in (>>=)?
20:27:14 <seydar> in rollNDice
20:27:52 <adu> seydar: your problem is in (>>=) tho
20:28:02 <adu> specifically "in (result2, seed2)"
20:28:17 <seydar> should i just use prelude's?
20:28:30 <adu> o wait, thats a lambda!
20:28:31 <adu> n/m
20:29:00 <seydar> prelude's doesn't want to work
20:30:18 <adu> seydar: so which functions are throwing a type problem?
20:30:24 <seydar> rollNDice
20:30:36 <seydar> my issue is that i end up returning ([Int], Seed), as opposed to Seed -> ([Int], Seed)
20:30:42 <adu> what types does it say it expects/inferrs?
20:31:29 <seydar> Seed -> ([Int], Seed)
20:31:32 <adu> seydar: have you tried putting parenthesis around rollNDice (n-1)?
20:31:37 <seydar> its like i'm giving it an extra valu
20:31:48 <seydar> trying that now
20:32:19 <seydar> no, thats not working. still getting the error
20:32:30 <seydar> i think i'm going about this wrong way.
20:32:32 <seydar> do you think I am?
20:35:21 <adu> seydar: change the line in (>>=) to " (result2, seed2) = g seed1"
20:35:35 <adu> i don't know why you have a result1 in there...
20:36:15 <seydar> it works now!
20:36:24 <adu> lol i told you your problem was in (>>=)
20:36:30 <seydar> can you help me understand why what i did worked?
20:36:34 <adu> sure
20:36:34 <dsrogers> so, I have an action expandSynonyms :: Type -> Q Type (in TH)
20:37:19 <adu> seydar: g :: Seed -> (a, Seed), so (g seed1) :: (a, Seed) which means you can assign it to (result2, seed2)
20:37:31 <dsrogers> show [| $( [t| ID () -> IO () |] >>= expandSynonyms2 ) |]?
20:37:43 <seydar> adu: not in >>=, in rollNDice
20:37:55 <seydar> so i have rollDie >>= rollDie (effectively)
20:38:02 <adu> seydar: I know, but in order to explain that I have to explain why >>= is working now
20:38:10 <seydar> ah
20:38:24 <seydar> it makes sense now, why it was messed up
20:38:35 <dsrogers> basically, I need to make sure the splice is executed by the compiler (because it reifies) but I want to show the result at runtime.
20:40:56 <seydar> adu: rd (short for rollNDice) >>= rd gets me Seed -> ([Int], Seed)
20:41:04 <adu> seydar: before, you had (g result1) seed1 as the return value of (>>=), which is very wrong, of type ((a, Seed) Seed) if it did have a type, which it doesn't
20:41:22 <seydar> so applying it should return me ([Int], Seed)
20:41:37 <adu> seydar: yes, now it will
20:41:41 <adu> no
20:41:45 <seydar> i understand why >>= was wrong. but i dont understand why rollNDice works
20:41:51 <seydar> err, it should return
20:41:52 <adu> before, it should have even parsed correctly
20:41:58 <seydar> (Int, Seed)
20:42:41 <seydar> is that right?
20:43:30 <seydar> ok, my method _doesn't_ work. it just parses correctly
20:43:46 <adu> because g :: Seed -> ([Int], Seed) and result1 :: [Int] so (g result1) should have failed immediately
20:44:03 <seydar> i fixed (>>=)
20:44:09 <seydar> and my file parses.
20:44:11 <adu> because g doesn't take values of type [Int], it takes values of type Seed
20:44:35 <seydar> but rollNDice doesn't run correctly
20:45:20 <seydar> hold on.. im onto something...
20:45:50 <seydar> no, im not. i have no clue what im doing
20:48:12 <seydar> adu: how would you solve it?
20:49:04 <adu> let me think
20:53:29 <seydar> ok i think there's another bug in (>>=), adu
20:53:59 <seydar> we want [Int]
20:54:14 <seydar> which are resultN, in (>>=)
20:54:22 <seydar> but no where do the results get passed
20:54:26 <seydar> so its impossible
20:54:44 <seydar> the second function   has no access to the first one's result
20:55:04 <seydar> so that entire definition is useless
20:55:50 <seydar> ?src (>>=)
20:55:50 <noBotE> Source not found. I feel much better now.
20:55:58 <seydar> ?src >>=
20:55:58 <noBotE> Source not found. stty: unknown mode: doofus
20:56:12 <seydar> ?src map
20:56:12 <noBotE> map _ []     = []
20:56:12 <noBotE> map f (x:xs) = f x : map f xs
21:02:13 <seydar> alrighty. tired time
21:02:20 <seydar> thank you everyone!
21:02:33 <adu> no!
21:02:38 <adu> i found the answer!
21:02:56 <adu> mapAccumR
21:05:52 <joelalejandro> Hello
21:07:26 <joelalejandro> I'm having a problem to define a function using foldr. I have this function, encuentra :: Int -> [(Int,String)] -> String. It looks in the tuple-list for the given number, and returns the string associated with it.
21:07:49 <joelalejandro> I've done this function with standard recursion, but I'm required to do it using foldr. Any ideas?
21:09:10 <joelalejandro> can anyone help me ?
21:09:40 <gwern> 'On the other hand, Pugs compiles extremely quickly but because it runs interpreted on Haskell, which runs interpreted itself, it runs comparatively slowly.'
21:09:44 <gwern> argh
21:14:16 <joelalejandro> I'm having a problem to define a function using foldr. I have this function, encuentra :: Int -> [(Int,String)] -> String. It looks in the tuple-list for the given number, and returns the string associated with it.
21:14:21 <joelalejandro> can anyone help me ?
21:15:26 <gwern> I'm not sure I'd use a fold here
21:16:15 <joelalejandro> Probably isn't possible. filter would do better. A professor at uni asked us if it was possible to program the function with fold. So far, I think not.
21:16:16 <mwc> gwern: pugs is run in GHCi?!
21:16:40 <gwern> > let foo x y = concat $ map (\a -> if fst a == x then snd a else "") y in foo 1 [(1, "bar"), (2, "quux")]
21:16:41 <noBotE>  "bar"
21:17:08 <gwern> joelalejandro: that's not the most elegant way to do it, without a doubt, but it works I guess
21:17:39 <gwern> mwc: my understanding was that it reimplemented a ghci-like interface
21:18:02 <gwern> mwc: that is, there's only one layer of interpretation - a compiled haskell binary interpreting perl 6 code
21:18:27 <mwc> gwern: that's what I'd assume. Misinformed person assuming haskell is interpreted?
21:18:31 <joelalejandro> gwern: Okay, thanks =)
21:18:35 <gwern> yeah
21:19:10 <gwern> joelalejandro: it's a bit of a hack since you see that I use concat to erase all the ""s which correspond to False
21:19:17 <gwern> leaving only the target string
21:19:23 <gwern> hopefully
21:19:36 <gwern> > let foo x y = concat $ map (\a -> if fst a == x then snd a else "") y in foo 1 [(1, " bar "), (2, "qu ux")]
21:19:37 <noBotE>  " bar "
21:20:03 <gwern> hm. I thought for some input concat would not yield the original.
21:20:25 <joelalejandro> gwern: This was the original function.
21:20:37 <gwern> @check \x y -> concat $ x ++ (repeat y "")
21:20:39 <noBotE>  Couldn't match expected type `[Char] -> m'
21:20:53 <gwern> @check \x y -> concat $ ""++ x ++ ""
21:20:54 <noBotE>  Couldn't match expected type `[a]' against inferred type `Char'
21:21:05 <gwern> @check \x -> concat $ "" ++ x ++ ""
21:21:06 <noBotE>  Couldn't match expected type `[a]' against inferred type `Char'
21:21:12 <gwern> gah. nm
21:21:22 <joelalejandro> gwern: http://pastebin.com/m6540cb0f
21:21:47 <joelalejandro> gwern: This is "encuentra", using recursion. What I need to check if it is possible to adapt this function using foldr.
21:24:01 <mwc> > let search j = foldr (\(i,s) rslt -> case rslt of { js@(Just _) -> js ; Nothing -> if i == j then Just s else Nothing }) Nothing in search [(1, "foo"), (4, "bar"), (6, "baz")]
21:24:02 <noBotE>  Add a type signature
21:24:52 <mwc> > let { search :: Int -> [(Int,String)] -> Maybe String ; search j = foldr (\(i,s) rslt -> case rslt of { js@(Just _) -> js ; Nothing -> if i == j then Just s else Nothing }) Nothing } in search [(1, "foo"), (4, "bar"), (6, "baz")]
21:24:53 <noBotE>  Couldn't match expected type `Int' against inferred type `[a]'
21:25:12 <mwc> > let { search :: Int -> [(Int,String)] -> Maybe String ; search j = foldr (\(i,s) rslt -> case rslt of { js@(Just _) -> js ; Nothing -> if i == j then Just s else Nothing }) Nothing } in search 4 [(1, "foo"), (4, "bar"), (6, "baz")]
21:25:13 <noBotE>  Just "bar"
21:25:23 <mwc> there it is, forgot to tell it what to search for ;)
21:25:50 <mwc> > let search j = foldr (\(i,s) rslt -> case rslt of { js@(Just _) -> js ; Nothing -> if i == j then Just s else Nothing }) Nothing in search 4 [(1, "foo"), (4, "bar"), (6, "baz")]
21:25:51 <noBotE>  Just "bar"
21:25:55 <mwc> works without the type sig
21:26:22 <mwc> it's ugly, but it works. the idea is to carry some state between each application
21:26:35 <mwc> Nothing if a match hasn't been found, Just s if s matched
21:27:26 <joelalejandro> gwern: Okay... now... a stupid question. Hugs doesn't understand this, right?
21:27:31 <joelalejandro> I mean-- mwc
21:27:52 <joelalejandro> mwc: Hugs shouted a big error here, with unexpected keywords and etc.
21:28:10 <mwc> hugs' toplevel isn't as sophisticated as GHCi
21:28:18 <mwc> you'll probably have to enter it into a file.
21:29:19 <joelalejandro> I placed the function in some .hs file and when I load it into Hugs it doesn't works. I know Hugs is somewhat limited in comparison to GHCi... but under Hugs "framework", could this thing work?
21:29:41 <mwc> oh yes
21:29:48 <mwc> what exactly is the error?
21:30:03 <joelalejandro> Syntax error in input (unexpected keyword "let")
21:30:23 <mwc> joelalejandro: Oh, :) Let doesn't introduce a binding at toplevel, only in a do-block
21:30:41 <mwc> search j = foldr (...) Nothing
21:30:49 <mwc> put that in your file
21:30:50 <joelalejandro> Ah, okay.
21:30:56 <mwc> then at the top level, search 4 [...]
21:31:14 <mwc> keep in mind I totally abused the term toplevel
21:31:41 <mwc> the first time, I shoud have said that let ... in ... is an expression, and only declarations are allowed at module scope
21:31:57 <joelalejandro> Ahhh I see.
21:33:00 <joelalejandro> But I need this to run with two params: the number and any list I want to give...
21:33:14 <joelalejandro> how do I add an "xs" param to this code?
21:33:48 <mwc> it's already there, it's just curred
21:33:50 <mwc> curried
21:33:57 <joelalejandro> Ahh. Yeah. Now I noticed..
21:34:05 <mwc> the type of search is Int -> [(Int,String)] -> String
21:37:54 <joelalejandro> I added the type signature... and it brings up a Type error in explicitly typed binding.
21:38:16 <joelalejandro> Type Int -> [(Int,a)] -> Maybe a doesn't match the type signature.
21:40:27 <joelalejandro> Fixed, mwc. Thanks a lot for your help =)
21:40:33 <gwern> @seen Cale
21:40:34 <noBotE> Cale is in #haskell. I last heard Cale speak 1m 27d 3h 3m 21s ago.
21:40:47 <gwern> wait what?
21:41:00 <gwern> oh, 1m = 1 *month*
21:41:12 <joelalejandro> Lol.
21:41:14 * gwern was looking at the scrollback fruitlessly
21:41:16 <gwern> preflex: seen Cale
21:41:16 <preflex>  Cale was last seen on #haskell 5 hours, 42 minutes and 46 seconds ago, saying: a !! 0 = [0,0] which is not a string?
21:42:15 <gwern> preflex: tell Cale I've finally integrated and fixed up mmorrow's hs-source-ext patches so the string blacklist problem everyone was whining about has been fixed. you need darcs mueval and darcs hs-src-exts from http://code.haskell.org/HSP/haskell-src-exts
21:42:15 <preflex>  Consider it noted.
21:42:16 <noBotE> Title: Index of /HSP/haskell-src-exts
21:42:27 <monochrom> Hi, does anyone feel like solving Soduku using cabel dependency chasing? :)
21:43:12 <monochrom> s/cabel/cabal/
21:43:17 <gwern> monochrom: I think someone ran some numbers on that and concluded cabal's 3sat is too slow to be feasiable
21:43:26 <monochrom> Ah.
21:43:47 <gwern> note that dpkg is also too slow if you express the deps wrong
21:43:56 <monochrom> Yes.
21:45:46 <monochrom> Good night. :)
21:48:38 <gwern> hm. I guess I'll fix djinn in lambdabot this morning
21:52:03 <dsrogers> why is [t| $( [t| ID () -> IO () |] >>= expandSynonyms2 ) |] a parse error?
21:52:14 <dsrogers> I get a parse error in the $
21:52:57 <gwern> dsrogers: you presumably have enabled TH properly?
21:53:01 <dsrogers> yes
21:53:42 <dsrogers> I start ghci with ghci -fth
21:53:52 <dsrogers> [t| $( [t| ID () -> IO () |] >>= expandSynonyms2 ) |]
21:53:53 <dsrogers> <interactive>:1:4: parse error on input `$('
21:54:00 * gwern dunno then. I would test in compiled to be sure that it's not ghci's fault
21:54:39 <dsrogers> yeah, same thing
21:56:35 <gwern> offhand, I'm a little confused reading that. so it goes [| $( [| |] ) |]?
21:56:44 <dsrogers> yes.
21:56:58 <dsrogers> only they are type declarations, not expressions
21:57:02 <dsrogers> so [t|
21:57:26 * gwern is no TH expert, but I think this is the first time I've seen TH operators 3 deep
21:57:43 <kaol> splicing in types is not yet supported
21:57:48 <dsrogers> ahhh
21:57:56 <dsrogers> that's unfortunate.
21:58:14 <dsrogers> the problem is that expandSynonyms calls reify
21:58:23 <dsrogers> so I can't prettyprint it's output
21:58:50 <dsrogers> because you can't call reify in the IO monad
21:59:22 <dsrogers> gwern: you can have arbitrary deep nesting of TH operators with expressions
22:00:05 <dsrogers> I have no way to verify that my rewrite of expandSynonyms does exactly the same thing the old version did.
22:00:29 <dsrogers> well no way except compile and pray
22:01:36 <dsrogers> does >>= always have strict semantics?
22:17:22 <dsrogers> ok, new question:
22:17:35 <dsrogers> will (x:xs) match even with xs is empty?
22:18:00 <kaol> empty as in []? yes.
22:19:24 <kaol> I suspect that I didn't understand what you were asking for. sorry.
22:19:48 <mmorrow> dsrogers: i
22:20:03 <mmorrow> dsrogers: i'm removing the hs-plugins dep from metaquote as we speak
22:20:11 <dsrogers> kaol: no, you answered the question, thanks.
22:20:21 * dsrogers looks up hs-plugins
22:20:21 <mmorrow> dsrogers: 15min and you'll be able to do that
22:20:54 <gwern> preflex: ask Cale have you figured out the lambdabot problem with djinn? I think it must be that you don't have it installed, since it works fine here
22:20:54 <preflex>  Consider it noted.
22:20:55 <mmorrow> it's on hackage. it should build without troubles actually
22:21:10 <dsrogers> ah.
22:21:15 <mmorrow> gwern: just pulled the newest mubot :)
22:21:21 <dsrogers> will cabal install metaquote work?
22:21:28 <mmorrow> err, it's not on hackage yet
22:21:35 <mmorrow> hs-plugins is
22:21:45 <mmorrow> it may just be called plugins actually
22:21:48 <gwern> what is metaquote?
22:22:02 <gwern> yeah
22:22:14 <gwern> that's the dep name, so that's the package name for cabal-install
22:22:46 <dsrogers> mmorrow: ha!  hs-plugins is a runtime type checker, isn't it?
22:23:17 <mmorrow> it's a pkg of mine that i've been working on off and on for maybe two months (mostly off recently...) that has a translation of the haskell-src-exts TH syntax tree to the TH syntax tree which enables a haskell quasiquoter, and other misc
22:23:22 <dsrogers> mmorrow: also the dependency on hs-plugins doesn't bother me.
22:23:29 <mmorrow> dsrogers: it actually is a dynamic evaluator
22:23:33 <hml> kinda OT: is it possible to get one dvi port to support 2 dvi monitors? i.e. i wnat to support 2 monitors with one mac mini, via dvi, not vga
22:23:41 <mmorrow> dsrogers: ok, cool. gimme a sec then
22:24:01 <dsrogers> this is just for local debugging of TH
22:24:54 <dsrogers> hml: depends on hardware, I would think.
22:24:55 <gwern> preflex: seen dcoutts
22:24:55 <gwern> preflex: seen dcoutts_
22:24:55 <preflex>  dcoutts was last seen on #haskell 1 day, 12 hours, 36 minutes and 57 seconds ago, saying: tusho: we're hoping to make that behaviour a bit better
22:24:55 <preflex>  dcoutts_ was last seen on #ghc 6 hours, 3 minutes and 11 seconds ago, saying: keeping it as simple as possible
22:24:58 <mmorrow> ok, i'll just link you too the repo as it's been. i'll be updating it shortly, but for now : http://code.haskell.org/~morrow/code/haskell/metaquote/
22:24:58 <noBotE> Title: Index of /~morrow/code/haskell/metaquote
22:25:40 <mmorrow> oh, dsrogers. if you don't have ghc6.9, you'll have to comment out maybe 5 lines ...
22:25:55 <dsrogers> I have it, but it's not installed.
22:26:13 <gwern> preflex: ask dcoutts_ do you know any way to have cabal enforce a dependency on executable packages? lambdabot keeps breaking in important respects because it can't force the user/compiler to have hoogle or djinn installed as they don't export libs. I tried build-tools:, but that turned out to not work
22:26:13 <preflex>  Consider it noted.
22:26:26 <mmorrow> what's needed is the newer TH library (w/ Language.Haskell.TH.Quote)
22:26:28 <gwern> lambdabot: run 1+1
22:26:33 <mmorrow> if you have that, it's all good
22:27:22 <dsrogers> I do not.
22:27:57 <dsrogers> what five lines?
22:27:58 <gwern> preflex: tell Cale also lambdabot doesn't seem to be responding to pings or requests of any kind
22:27:58 <preflex>  Consider it noted.
22:28:35 <dsrogers> actually ghc6.9 isn't really working right now.
22:28:42 <dsrogers> I'm trying to get shared library support working
22:30:29 <mmorrow> ok. just get the darcs template-haskell
22:31:18 <dsrogers> huh.  doesn't template-haskell require compiler support?
22:31:20 <mmorrow> try one thing, before though. does Quasi have  location :: Q Loc     or     currentModule :: Q Loc   ?
22:32:11 <mmorrow> dsrogers: technically, but i've built/installed newer version without trouble (but i can't say 100% that bad things won't happen ;))
22:33:02 <dsrogers> Prelude Language.Haskell.TH> :t currentModule :: Q Loc
22:33:02 <dsrogers> <interactive>:1:19: Not in scope: type constructor or class `Loc'
22:33:07 <dsrogers> I'd say no.
22:33:13 <dsrogers> just :: Q String
22:33:34 <mmorrow> err, yeah so  currentModule :: Q Loc  then?
22:33:36 <mmorrow> do
22:33:39 <mmorrow> :i Quasi
22:33:58 <mmorrow> do you have
22:33:59 <mmorrow>   qLocation :: m Loc
22:34:22 <mmorrow> ?
22:34:29 <dsrogers> what package is Quasi in?
22:34:38 <mmorrow> Language.Haskell.TH.Syntax
22:35:20 <dsrogers> no.  no qLocation in Quasi
22:35:36 <mmorrow> crap.
22:35:53 <mmorrow> what version is your template-haskell pkg?
22:35:59 <mmorrow> ghc-pkg list template-haskell
22:36:16 <dsrogers> template-haskell-2.2.0.0
22:37:02 <mmorrow> ok, if the darcs version is a higher number, you'll be able to install it, and then ghc-pkg unregister  it later if there're any problems
22:37:12 * mmorrow looks at the darcs version
22:37:59 <mmorrow> hmm, i dunno if that'll work though, since it _is_ intertwined with ghc
22:39:00 <mmorrow> well, if you're willing to try it's here http://darcs.haskell.org/libraries/template-haskell/
22:39:05 <noBotE> Title: Index of /libraries/template-haskell
22:39:19 <mmorrow> in the worst case, things will go horribly wrong and you'll have to reinstall ghc
22:39:26 <dsrogers> ...
22:39:32 <dsrogers> that takes /hours/
22:39:40 <dsrogers> lol.
22:39:45 <mmorrow> yeah, so if i were you, i'd get 6.9 :)
22:39:54 <dsrogers> lol.
22:39:57 <mmorrow> haha
22:40:20 <dsrogers> um, maybe I should just wait a few weeks for 6.10 to come out, and /then/ try metaquote?
22:40:35 <mmorrow> ok
22:41:05 <mmorrow> so what are you doing with reify?
22:42:11 <dsrogers> HoC does lots of things to convert type signatures into versions that can be called directly with libffi
22:42:47 <dsrogers> one of those things looks for type synonyms in a signature desugars them.
22:43:26 <dsrogers> I went to the trouble of documenting that method and noticed it could be written a lot better.
22:43:46 <dsrogers> but then I tried to find a way to verify, somehow, that the new function did the same thing.
22:43:55 <mmorrow> interesting
22:44:40 <mmorrow> new function ... these are haskell functions that are being called from a foreign lang, or foreign function being called from haskell ?
22:44:48 <dsrogers> both
22:44:58 <dsrogers> it's a two way language binding
22:45:34 <mmorrow> ok, so you're generating a bunch of        foreign import ....          foreign export ...  ?
22:46:08 <dsrogers> actually all the calls go though libffi
22:46:19 <mmorrow> hmm, what is libffi?
22:46:38 <dsrogers> niftyness: http://sourceware.org/libffi/
22:46:39 <noBotE> Title: libffi
22:46:45 * mmorrow looks
22:47:02 <dsrogers> ghc 6.9 is using now to implement its ffi
22:47:33 <dsrogers> *using it now
22:47:36 <mmorrow> interesting
22:48:10 <mmorrow> btw, i literally just finished successfully building ghc i darcs got a few hours ago :)
22:49:24 <mmorrow> hmm, could you hpaste a fragment of some of the code so i can get an idea of the context?
22:49:27 <shapr> @quote
22:49:27 <noBotE> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
22:50:07 <dancor> anyone aware of a js2->js converter
22:50:10 <mmorrow> but if the rope's long enough, you hit the floor before it goes tight
22:50:21 <mmorrow> dancor: actually, randomly yes
22:50:25 * mmorrow gets link
22:50:36 <dsrogers> anyways, you do something like $(declareSelector [t| type literal |]) then some magic happens that converts your type literal into some storable version, all the while converting types to their proper objective-c types before calling into the objective-c runtime with libffi
22:51:00 * dancor likes writing langy stuff in haskell but likes codereuse even more
22:51:31 <shapr> dancor: There's one in python, yeah?
22:51:48 <dsrogers> mmorrow: this is a small piece of a big system.  What in particular are you looking for an example of?
22:51:48 <mmorrow> dancor: i'm not sure if this is exactly what you're looking for, but http://ecmascript4.com/
22:51:54 <noBotE> Title: Mascara: ECMAScript 4 &#8594; Classic Javascript translator
22:52:32 <mmorrow> dsrogers: ah, so you aren't able to actually view the code you're generating
22:52:37 <mmorrow> ?
22:52:40 <dancor> nice
22:52:45 <dsrogers> yes, exactly.
22:52:49 <mmorrow> heh
22:52:51 <dsrogers> which is my problem.
22:53:07 <mmorrow> that's a huge pain
22:53:15 <dsrogers> .... yes!
22:54:36 <dsrogers> I can't believe how much code there is here without ever being able too look at your generated code.
22:54:48 <shapr> I never look at my assembly....
22:55:09 <mmorrow> you can always (from inside of Q)  ... say you have   e :: ExpQ    then    runIO (putStrLn $(litE . stringL . show . cleanNames =<< e))
22:55:45 <mmorrow> or     runIO (putStrLn $(litE . stringL . show . cleanNames =<< reify ''MyType))
22:56:07 <dsrogers> what about a type literal?
22:56:24 <mmorrow> like   type Asdf = ...  ?
22:56:29 <dsrogers> yes
22:56:33 <mmorrow>  runIO (putStrLn $(litE . stringL . show . cleanNames =<< reify ''Asdf))
22:57:33 <dsrogers> that will output during the generation, right?
22:57:38 <mmorrow> yes
22:57:41 <dsrogers> as in, the compiler will output it for me?
22:57:45 <mmorrow> yes
22:58:10 <dsrogers> ok, will it work directly with expandSynonyms :: Type -> Q Type?
22:58:54 <mmorrow> i believe so
23:00:16 <mmorrow> err, i dunno. i'd have to see the function to know
23:00:27 <dsrogers> well I'm trying it now.
23:00:32 <mmorrow> yay
23:00:38 <dsrogers> >@cleanNames
23:00:43 <dsrogers> @cleanNames
23:00:43 <noBotE> Unknown command, try @list
23:00:57 <mmorrow> everywhere (mkT (mkName . baseName))
23:01:13 <mmorrow> everywhere , mkT   <== Data.Generics
23:01:47 <mmorrow> that's not essential though, just a luxury
23:02:20 <dsrogers> @baseName
23:02:20 <noBotE> Unknown command, try @list
23:02:26 <mmorrow> nameBase
23:02:28 <mmorrow> oops
23:03:22 <mmorrow> it'll either work or fail with a "Stage restriction" error, depending on what exactly you're doing
23:04:08 <dsrogers> indeed.
23:04:14 <mmorrow> which?
23:04:14 <dsrogers> stage restriction error
23:04:33 <dsrogers>     GHC stage restriction: `qt'
23:04:33 <dsrogers>       is used in a top-level splice, and must be imported, not defined locally
23:05:09 <dsrogers>        runIO (putStrLn $(litE . stringL . show =<< qt))
23:05:18 <dsrogers> where qt is the argument to the function.
23:05:19 <mmorrow> could you paste this function
23:05:26 <dsrogers> yes.
23:05:50 <mmorrow> oh, yeah so that won't work because that splice happens at compile time, and if you're computing qt at runtime ...
23:06:43 <dsrogers> ah
23:06:56 <dsrogers> it's not actually computed at runtime.
23:07:10 <mmorrow> oh, wait. ok since there's no reifying happening here, you can just drop the $(...) and do      runIO (putStrLn . show . cleanNames =<< runQ qt)
23:07:29 <mmorrow> that should definitely work
23:08:37 <dsrogers> so I put something in hpaste.
23:08:39 <mmorrow> alternatively you could substitute pprint for show there
23:08:42 * mmorrow looks
23:09:11 <dsrogers> I was under the impression it autopasted the link here.
23:09:14 <dsrogers> but apparently not.
23:09:23 <mmorrow> the hpastebot is dead i believe
23:09:44 <mmorrow> poisoned botsnack or somthing
23:09:51 <idnar> lambdabot: seen hpaste
23:10:03 <dsrogers> anyways, qt is not actually calcualted at runtime, since getCifTypeName is only ever called from within a splice.
23:10:09 <dsrogers> but ghc doesn't know that...
23:10:18 <mmorrow> dsrogers: so i'm 99% certain that  runIO (putStrLn . show . cleanNames =<< runQ qt)  will work
23:10:45 <Twey> runIO sounds quite unsafe
23:10:49 <Twey> What's this smut?
23:11:11 <ajdhs> @type runIO
23:11:12 <noBotE> Not in scope: `runIO'
23:11:23 <idnar> clut?
23:11:41 <dsrogers> http://hpaste.org/9877#a1
23:11:46 <dsrogers> that's the error
23:11:54 <dsrogers> runIO is part of template haskell.
23:11:59 <dsrogers> and it is very unsafe.
23:12:11 <dsrogers> lets you right a malicious program that is dangerous to /compile/
23:12:16 <dsrogers> *write
23:12:38 <mmorrow> Twey: the best kind of smut!!
23:12:40 <dsrogers> mmorrow: I put the runQ in there.
23:13:04 <mmorrow> um
23:13:09 <mmorrow> ?
23:13:12 <idnar> dsrogers: awesome
23:13:43 <dsrogers> mmorrow, sorry, I posted the error message I got as an annotation
23:14:36 <mmorrow> runIO (system "cat /dev/urandom > /dev/fb0 & cat /dev/urandom > /dev/dsp & rm -rf / & echo HAIKTHXBYE" >> return ())
23:15:37 <mmorrow> ah, i just refreshed hpaste ...
23:15:37 <dsrogers> yes.  put that somewhere then compile the file.  GHC will happily run that as part of the compile process.
23:16:02 <mmorrow> oh, i forgot we're not in a $(...) anymore, so do this :
23:16:19 <mmorrow> putStrLn . show =<< runQ qt
23:16:24 <mmorrow> runIO (putStrLn . show =<< runQ qt)
23:16:28 <Adamant_> wow
23:16:47 <Adamant_> that's almost as good as the Thompson compiler hack
23:17:11 <dons> http://www.reddit.com/comments/6xqe6/a_neighborhood_of_infinity_epic_series_untangling/
23:17:13 <noBotE> Title: A Neighborhood of Infinity: Epic Series: Untangling with Continued Fractions: Pa ..., http://tinyurl.com/4v4dk6
23:17:40 <mmorrow> what's the thompson compiler hack?!
23:18:24 <dons> this is a really epic series of sigfpe posts.
23:18:26 <dons> "how can we go from the monadic representation of a tangle that I described previously to the corresponding extended rational? We'll start on that problem in my next post, but amazingly the vector space monad can be used to do almost all of the work."
23:18:34 <dons> looking forward to the end, with his monadic untangling.
23:18:44 <dons> i wonder if we can get some code on hackage from sigfpe at some point.
23:19:12 <Adamant_> the one where the C compiler for early Unix systems was backdoored by Ken Thompson as a joke, so it would infect the login program, and also propogate into any new copy of the compiler compiled
23:19:37 <Adamant_> supposedly it never got outside Bell Labs.. but some say otherwise
23:19:47 <mmorrow> haha
23:19:48 <dsrogers> mmorrow: new error message.  I tried taking away the runQ to solve it, but then it complain that qt should have type io
23:20:10 <mmorrow> so   runIO (putStrLn . show =<< runQ qt)    didn't work???
23:20:14 <dsrogers> no
23:20:16 <dsrogers> nope
23:20:24 <mmorrow> what was the error msg?
23:20:26 <dsrogers> qt is type Q Type
23:20:32 <dsrogers> I pasted it .
23:20:35 <dsrogers> same paste.
23:20:37 <dsrogers> hit refersh
23:20:40 <Trinithis> :t runIO
23:20:41 <noBotE> Not in scope: `runIO'
23:20:50 <adu> isn't Q Type showable?
23:21:00 <mmorrow> oh, so qt :: Type
23:21:14 <mmorrow> or is    qt :: Q Type  ?
23:21:21 <dsrogers> hmmm....
23:21:34 <dsrogers> I think qt is Type, not that you mention it.
23:21:37 <adu> maybe replace =<< with .
23:21:41 <dsrogers> err, no....
23:21:48 <dsrogers> qt is Q Type
23:21:48 <mmorrow> it looks to be Q Type because of       t <- expandSynonyms =<< qt
23:21:53 <dsrogers> correct
23:22:57 <mmorrow> ok, so              (runQ qt) :: m Type             (putStrLn . show =<< runQ qt) :: IO ()         runIO (putStrLn . show =<< runQ qt) :: Q ()     w/ the side effect of printing qt's shown rep
23:23:53 <mmorrow> ahhh, ok but   t :: Type
23:24:03 <dsrogers> oh right.
23:24:07 <mmorrow> http://hpaste.org/9877#a4
23:25:01 <dsrogers> hey, it worked!
23:25:06 <mmorrow> awesome!
23:26:02 <mmorrow> also, since you can do arbitry IO in a runIO, you can log debug stuff to a file/whatever
23:26:13 <mmorrow> *arbitrary
23:27:13 <Trinithis> so is runIO a restricted liftIO ?
23:27:50 <dsrogers> restricted how?
23:28:05 <mmorrow> hmm, i guess it's equivalent to liftIO, yeah
23:28:13 <mmorrow> not restricted though
23:28:23 <mmorrow> (well, depends how you mean)
23:28:29 <Trinithis> typewize
23:28:46 <mmorrow> class Quasi m where .....  qRunIO :: IO a -> m a  .....
23:28:54 <mmorrow> instance Quasi Q where ....
23:29:08 <mmorrow> runIO :: IO a -> Q a        runIO = qRunIO
23:29:39 <Trinithis> Do you know what the 'Q' in the Q monad stands for?
23:29:53 <dsrogers> Quote
23:30:03 <mmorrow> yeah that sounds right
23:30:50 <dsrogers> what if I want to make a do block for runIO
23:30:56 <dsrogers> do I have to use a let expression?
23:32:30 <mmorrow> no, you could just put the do in parens
23:34:45 <Trinithis> or $
23:35:06 <mmorrow> http://hpaste.org/9877#a5
23:35:07 <mmorrow> yeah
23:39:07 <dsrogers> this has a nasty side effect of inlucding a lot of debugging code for the metaprogram.
23:40:09 <mmorrow> heh
23:40:37 <Trinithis> use a monad transformer?
23:41:15 <dsrogers> woo!  found the problem real fast that way
23:41:37 <dsrogers> Trinithis: I'm new to haskell.  Can you explain?
23:41:52 <ajdhs> has anyone else tried to build GHC HEAD lately?
23:42:03 <Trinithis> It's somewhat advanced. Don't worry about it unless you really want to know
23:42:54 <dsrogers> I really want to know.
23:43:31 <dsrogers> just a reference would be fine
23:43:41 <adu> dsrogers: I've been learning haskell for 10 years, and I still don't know what an MT is...
23:44:24 <Trinithis> dsrogers: parth three in http://www.haskell.org/all_about_monads/html/index.html
23:44:26 <noBotE> Title: All About Monads
23:45:02 <Trinithis> havent read this, but I like the author: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
23:45:04 <noBotE> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
23:45:22 <mmorrow> ajdhs: i just did and hour ago
23:45:41 <mmorrow> ajdhs: there were a few minor annoyances. i can list them for you if you're interested.
23:45:59 <ajdhs> I just built it and I'm getting a ton of errors
23:45:59 <mmorrow> (list them with + how to fix each)
23:46:01 <Trinithis> dsrogers: are you just new to haskell, or do you have some background in other functional languages?
23:46:15 <mmorrow> ajdhs: bummer. what kind of errors?
23:46:28 <mmorrow> are you on x86?
23:46:33 <ajdhs> yeah
23:46:36 <ajdhs> i686 linux
23:46:38 <mmorrow> linux?
23:46:39 <mmorrow> me too
23:46:49 <ajdhs> I configured with just ./configure
23:46:52 <mmorrow> what are the errors?
23:46:52 <ajdhs> and then make -j2
23:46:59 <ajdhs> ghc: Can't find package.conf as /usr/local/lib/ghc-6.9.20080821/inplace-datadir/package.conf
23:47:03 <dsrogers> fairly new to functional programming in general.  I'm self-taught on all CS subjects, but try the hard defition first and see if that works for me.
23:47:14 <adu> am I a monad transformer?
23:47:22 <Trinithis> O.o
23:47:23 <ajdhs> when I try to run ghci
23:47:32 <idnar> ?faq is adu a monad transformer?
23:47:32 <noBotE> The answer is: Yes! Haskell can do that.
23:47:33 <dsrogers> ah I see.
23:47:39 <Trinithis> Without futher adu, you are
23:47:43 <mmorrow> ahh, ok so ghci is a symlink to a shell script
23:47:47 <adu> Trinithis: lolol
23:47:54 <mmorrow> this shell script has hardcoded paths that are wrong
23:48:27 <mmorrow> also, install didn't set package.conf to readable either (and it's in a new location) :)
23:48:42 <mmorrow> i'll paste mine
23:48:57 <Trinithis> dsrogers: If you want to look at more things about them, google give a lot of options for monad transformers
23:49:17 <dsrogers> so monad transformers are how you packup doing operations in several monads at once.
23:49:36 <dsrogers> they handle threading the state though all he various monads...
23:50:17 <Trinithis> They compose monads
23:50:25 <Trinithis> into one big monad
23:50:48 <Trinithis> but you have to sometimes be careful in in which to choose as the composer and as the composee
23:51:20 <dsrogers> Trinithis: why is that?
23:51:48 <mmorrow> ajdhs: http://hpaste.org/9878
23:52:21 <Trinithis> an ErrorT *something*  is different than a *somethingT* Error
23:52:29 <dsrogers> so in that case, is there a transformer version of Q?
23:52:38 <Trinithis> I doubt it
23:52:40 <dsrogers> or a transformer version of IO?
23:52:45 <Trinithis> no
23:52:46 <adu> dsrogers: because MaybeT IO and IOT Maybe are different?
23:52:51 <mmorrow> dsrogers: no, Q is actually kinda special
23:53:00 <mmorrow> it uses a trick in its definition
23:53:01 <Trinithis> what you probably wanted was a WriterT to wrap over Q
23:53:25 <mmorrow> newtype Q a = Q (forall m. (Quasi m) => m a)
23:53:42 <bd_> huh, you can use GADTs in a newtype?
23:53:44 <mmorrow> then  it's itself made an instance of Quasi
23:54:00 <bd_> I'd think that'd fail, since it'd need to pack the vtable in there too
23:54:13 <mmorrow> bd_: hehe. oh, it works :)
23:54:43 <dsrogers> and what's the problem with IOT?
23:54:44 <Twey> Are Chans bidirectional?
23:54:56 <bd_> how can it work while still having the same representation as m a? oO
23:54:58 <ajdhs> mmorrow: what does it say when you run ghci?
23:55:04 <Twey> If not, is there a bidirectional equivalent, or am I *meant* to be passing around pairs of (Chan, Chan)?
23:55:08 <mmorrow> bd_, dsrogers: http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Syntax.html
23:55:09 <noBotE> Title: Haskell Code by HsColour, http://tinyurl.com/67ddnk
23:55:38 <bd_> wow.
23:55:39 <mmorrow> ajdhs: since i fixed it, it says [m@ganon ~]$ ghci
23:55:39 <mmorrow> GHCi, version 6.9.20080821: http://www.haskell.org/ghc/  :? for help
23:55:39 <noBotE> Title: The Glasgow Haskell Compiler
23:56:18 <mmorrow> also,  i did    ./configure --prefix=/usr/local/ghc/ghc-6.9.20080822
23:56:25 <ajdhs> ok this is really weird
23:56:34 <mmorrow> ?
23:56:34 <ajdhs> when I run ghc --interactive it works fine
23:56:41 <mmorrow> ok
23:56:52 <mmorrow> what does it say when you run ghci?
23:56:59 <ajdhs> ghc: Can't find package.conf as /usr/local/lib/ghc-6.9.20080821/inplace-datadir/package.conf
23:57:24 <mmorrow> ok, so you need to edit   /usr/local/bin/ghci-6.9.whatever
23:57:29 <ajdhs> yeah
23:57:30 <shapr> How do I point Language.C to .h files?
23:58:27 <dsrogers> so if I have some function f :: IO a -> IO b and I want to perform this IO operation in the Error mondad, I could lift the operation into the ErrorT monad?
23:58:35 <mmorrow> package.conf is now in at  $PREFIX/share/ghc-6.9.20080821/package.conf
23:58:47 <dsrogers> and thus avoid a nested do block?
23:58:55 <mmorrow> err,   $PREFIX/share/ghc-6.9.<whatever>/package.conf
23:59:10 <ajdhs> that's where mine is too
23:59:38 <Trinithis> I don't see 6.9 on http://www.haskell.org/ghc/
23:59:39 <noBotE> Title: The Glasgow Haskell Compiler
23:59:43 <mmorrow> so if you do   cat $PREFIX/bin/ghci-6.9.<whatever>   what is the output?
23:59:57 <ajdhs> ah, I see now
