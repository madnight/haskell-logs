00:00:08 <mmorrow> i wanna see lambda prolog
00:00:16 <mmorrow> and lazy eval on hoas
00:00:27 <Myoma> I did lazy eval with HOAS before, but that was in Haskell...
00:00:33 <mmorrow> heh
00:00:53 <Myoma> In lambda prolog I don't know what would happen
00:00:53 * Myoma is too scared to try
00:01:06 <Myoma> I could do the type system and not run any programs :)
00:01:47 <mmorrow> ha, the type system is the entire extent /of/ the program
00:02:50 <mmorrow> have to sleep for a bit, good luck :)
00:02:54 <Myoma> nn
00:03:29 <lispy> it was once said, that the cool thing about writing your program in the type system is that if it compiles you know it terminates ;)
00:04:16 <lispy> I think it was SPJ that jokingly made that comment at a Haskell Workshop
00:04:25 <Myoma> heh
00:04:51 <Myoma> mm
00:04:52 <Myoma> eval  (abs R)  (abs R).
00:04:52 <Myoma> eval  (app M N)  V  :-  eval M (abs R), eval N U, eval (R U) V.
00:05:28 <Myoma> this is odd
00:05:39 <Myoma> how does one implement lazyness in a strict language without mutation ...
00:07:02 <Myoma> I only know two ways to implement a lazy evaluation, that is steal it from a lazy language or rewriting on a graph
00:07:22 <Myoma> but are ther any others?
00:13:49 <Cale> Myoma: use functions to suspend values?
00:14:00 <Myoma> I will try it
00:14:07 <Cale> Myoma: Strict languages still don't evaluate under lambda
00:14:25 <Cale> So you can represent as-yet-uncomputed values as functions with no parameters.
00:20:42 <Myoma> hm
00:20:54 <Myoma> but doesn't it recompute the value each time
00:32:18 <newsham> def force(thunk) { if(! thunk.isEval) { thunk.val = thunk.eval(); thunk.isEval = True; } return thunk.val; }
00:33:00 * Myoma cannot do mutation
00:38:58 <Myoma> infer (M @ N) B        :- infer M (A --> B), infer N A.
00:38:58 <Myoma> infer (fn M) (A --> B) :- pi x\ infer x A => infer (M x) B.
00:39:01 <Myoma> that is neat
00:47:56 <Cale> Myoma: well, without mutation, laziness is hard to implement efficiently.
00:48:25 <Myoma> I don't think I can do ti
00:48:28 <Myoma> it*
00:49:08 <osfameron> are there good articles on using multiple zippers into a datasturcture?
00:49:23 <Cale> Well, you might be able to do it if you don't mind a log factor, and passing around an explicit heap represented as some nice balanced tree :)
00:49:31 <osfameron> I had a think about it last night and couldn't work out how it's done
00:50:21 <Cale> osfameron: Well, if you know how to put one zipper in, I think you just do it again.
00:51:07 <osfameron> ok.  That gives you 2 zippers who can make their own updates, which are ignored by the other
00:51:25 <osfameron> but what happens when one wants to propagate its changes to the other zipper?
00:51:53 <Myoma> how is using 2 zippers  different from using just 1?
00:51:54 <osfameron> http://okmij.org/ftp/Computation/Continuations.html in the section starting "We can traverse the same term with several ``concurrent'' zippers:" looks like a place to start
00:51:55 <lambdabot> Title: Continuations and delimited control
00:52:50 <osfameron> Myoma: if both are updating?  Am I missing something obvious then, but if one zipper updates the node its at, the other zipper won't see that update, as it's running effectively in its own sandbox on the datastructure
00:53:10 <Myoma> what can you do with two that one can't do
00:53:10 <Myoma> ?
00:53:23 <BeelsebobWork_> gah, QuickCheck really wasn't designed in any way to generate infinite data structures
00:53:29 <osfameron> Myoma: parallel processing of a large document/structure
00:54:04 <osfameron> Myoma: well, parallel map is easy enough without that, I guess, you just do the map in parallel.
00:54:19 <osfameron> But let's say another process is contemporaneously editing another part of the document
00:54:30 <Myoma> oh so like a page of text and you can edit the first and last paragraph at the same time?
00:54:40 <osfameron> yeah
00:55:17 <osfameron> that link I cited suggests that the zippers/cursors broadcast the changes they've made, and the other zippers can choose (or not) to apply those changes
00:55:48 <osfameron> though I'm not sure *when* they update the changes.  Presumably lazily when they happen to traverse to the changed node?
00:56:48 <binrapt> "Functional programming is the child of a number of arrogant mathematicians and computer scientists who were trying to woo women by overusing recursion." - Philip Wadler
00:57:45 <ivanm> can't forget the lambdas, either
00:59:32 <BeelsebobWork_> binrapt: awesome
00:59:42 <binrapt> :\
00:59:53 <binrapt> BeelsebobWork_ do you agree with him?
01:00:33 <BeelsebobWork_> binrapt: no, but I think it's beautifully phrased
01:01:01 <BeelsebobWork_> also, given that it's Phil Wadler, it's probably very very tongue in cheek
01:01:16 <binrapt> I guess
01:01:20 <BeelsebobWork_> given that he himself is one of the arrogant mathematicians he's referring to
01:01:27 <binrapt> Yeah
01:02:09 <DrSyzygy> What? Are you saying that recursion WON'T help me get laid!?!?
01:02:26 <Myoma> @quote recursion
01:02:27 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
01:02:51 <osfameron> heh
01:03:35 <binrapt> I didn't know condescension was an algorithmic technique
01:04:18 <Wild_Cat> in Lisp, it is *the* algorithmic technique.
01:04:25 <lispy> heh
01:04:52 <lispy> Lisp: The only programming community that is as cranky as it is old.
01:06:03 <BeelsebobWork_> lispy: surely you could say that about the ruby community too
01:06:14 <BeelsebobWork_> most ruby programmers are very young, and quite cranky
01:06:56 <osfameron> is that because nobody believes them when they say ruby is the only language you can write DSLs in?
01:07:22 <BeelsebobWork_> hehe
01:07:24 <lispy> osfameron: name one other language that makes that easy
01:07:36 <lispy> oh wait
01:07:37 <lispy> n/m
01:07:40 <osfameron> hehe
01:07:40 <BeelsebobWork_> and noone believes them when they say a ruby program will take less than 3 years to run
01:08:26 <osfameron> I've not seen any dsl examples for ruby that are easier than they would be in perl.  Well, symbols are nice, we haven't got those, but they don't look all that different from hash-keys
01:08:31 <lispy> I think most modern languages, even ones I don't like, support DSLs pretty well
01:08:33 <binrapt> DSL = ?
01:08:40 <BeelsebobWork_> domain specific language
01:08:45 <Wild_Cat> BeelsebobWork_: actually, they're right on that part. Rails programs need to be restarted every couple hours or so, so they won't ever reach 3 years of runtime :p
01:09:01 <BeelsebobWork_> lispy: I've not seen one that supports them as nicely as haskell though
01:09:04 <BeelsebobWork_> Wild_Cat: lol
01:09:21 <osfameron> haskell is nice for composing little languages, yeah
01:09:27 <Zao> binrapt: What you get when you have excessive operator overloadability and a reasonably flexible syntax.
01:09:55 <Myoma> you don't need operators
01:10:10 <osfameron> but the speed is just an implementation detail.  The next version of ruby is likely to be faster I think (Rite?)
01:10:17 <humasect> @src when
01:10:17 <lambdabot> when p s = if p then s else return ()
01:10:25 <DrSyzygy> ibid: ping?
01:10:55 <|Steve|> :t when
01:10:57 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:11:11 <BeelsebobWork_> osfameron: who knows -- it's hard to get slower than it is at the moment (90 times slower than C in the shootout IIRC)
01:11:30 <humasect> where is "p >>= \b -> if b then s else return ()" ?
01:11:59 <BeelsebobWork_> humasect: ifM?
01:12:10 <BeelsebobWork_> dunno if it exists
01:12:15 <humasect> yes =)
01:12:18 <Myoma> I'd call it boolM
01:12:29 <BeelsebobWork_> oh, yeh, the return () is odd
01:12:46 <humasect> is it?=)
01:13:01 <ejt> I don't think ifM is in the lib, I asked the other day
01:13:50 <ibid> DrSyzygy: pong?
01:14:28 <Wild_Cat> well, IIRC Ruby is switching from a full-blown interpreter to a VM in 1.9. It should improve performance quite a bit already.
01:15:08 <Wild_Cat> then they're talking of adding a GIL to said VM (as in Python's) to improve performance further and defer multithreading to native OS threads (it currently uses software green threads).
01:15:20 <osfameron> GIL?
01:15:23 <humasect> whenM?
01:16:01 <Myoma> whyNotM?
01:16:04 <DrSyzygy> ibid: Could you change my name on the Planet Haskell website? Since about a year back it's "Mikael Vejdemo Johansson" not "Mikael Johansson"
01:16:29 <osfameron> "Global Interpreter Lock"
01:16:36 <DrSyzygy> (and since obviously people use the aggregator as a source for name info - it's kinda important)=
01:16:40 <cjs> I've found on occasion that Ruby does a nicer DSL in Haskell. Mind you, I've not tried Template Haskell, yet, and that what's-it-called thing we were discussing earlier should also help.
01:17:08 <ibid> DrSyzygy: send me email, i'll do it later today
01:17:14 <DrSyzygy> To which addy?
01:18:10 <ibid> DrSyzygy: either the planet contact or my personal, whatever :)
01:18:25 <Wild_Cat> osfameron: Global Interpreter Lock. It's a lock that basically means that at any given time, only one thread may run pure Python code.
01:18:25 <DrSyzygy> Ah. There.
01:19:12 <DrSyzygy> Sent.
01:19:52 <Wild_Cat> which has the consequences of speeding up single-threaded code, greatly simplifying writing C extensions, making most pure Python data structures reasonably thread-safe and starting countless flamewars on #python when idiots come in and whine that they can't multithread their CPU-bound programs to gain performance, when data sharing would kill it anyway.
01:20:25 <Wild_Cat> (and Python has plenty of very nice interfaces to writing multiple processes, one of which mimics the threading API and becomes part of the stdlib starting in 2.6)
01:24:59 <cjs> If you're CPU-bound, running python code in parallel is probably not the solution.
01:25:26 * BeelsebobWork_ ponders how to integrate generation of infinite structures into QuickCheck properly
01:25:57 <Wild_Cat> cjs: that's true. Although if there's a shiny nice module (pyprocessing) that allows you to double your performance with close to no effort, you might just as well use it ;)
01:26:00 <cjs> BeelsebobWork_: I'm not sure you can do it, though I must admit to not being very familiar with the Haskell version of QuickCheck.
01:26:16 <cjs> Assuming doubling will do the trick.
01:26:28 <BeelsebobWork_> cjs: well, you can certainly write generators that produce infinite structures
01:26:44 <BeelsebobWork_> the problem is getting it to generate sane ones when it decides that the infinite structure should have size 0
01:27:52 <Wild_Cat> cjs: if it doesn't, it's time to get to work all right :p
01:28:17 <cjs> BeelsebobWork_: ah.
01:28:51 <BeelsebobWork_> an example... in infinite list of integers with size 0, comes out as being [0,0,0,0,0,0,0,0,0,0,0....]
01:28:58 <BeelsebobWork_> which is an interesting test case
01:29:07 <BeelsebobWork_> but in my particular instance, I don't want it
01:29:23 <BeelsebobWork_> and as there's no other size 0 thing, I can't say "just generate another one"
01:29:59 <FordCortina> it seems that haskell programmers use the term "lift"  in different ways. Am I not understanding a commonality between these concepts?
01:30:17 <FordCortina> for instance is there some link between Monad lifting and lifted types?
01:31:09 <humasect> would we call "p >>= \b-> if t p then s else return ()" whenM1 or 2?
01:32:48 <Myoma> what's the real thing
01:33:11 <ejt> do you mean to ignore 'b' ?
01:33:43 <Myoma> @let bool true false True = true ; bool true false False = false
01:33:45 <lambdabot> Defined.
01:33:54 <Myoma> :t liftM2 bool ?p ?x ?y
01:33:56 <lambdabot> forall a1 t. (Monad ((->) t), ?y::t, ?x::t -> a1, ?p::t -> a1) => Bool -> a1
01:34:05 <cjs> BeelsebobWork_: But that output is quite correct for the meaning of the "size" parameter.
01:34:07 <Myoma> :t liftM2 bool ?p ?x (return ())
01:34:09 <lambdabot> forall a1 (m :: * -> *). (Monad m, ?x::m () -> a1, ?p::m () -> a1) => Bool -> a1
01:34:18 <humasect> well, in a case like this: p <- doSomething ; if p <= 0 then ...
01:34:36 <BeelsebobWork_> cjs: exactly -- so the problem is that I need to ban quickcheck from ever chosing size 0
01:34:41 <BeelsebobWork_> but there's no sensible way to do that
01:34:43 <Myoma> :t liftM (flip bool) ?x ?p (return ())
01:34:45 <lambdabot> forall t (m :: * -> *). (Monad ((->) t), Monad m, ?p::t, ?x::t -> m ()) => Bool -> m ()
01:34:45 <humasect> i don't know what ? is or (Monad ((->) t) ..)
01:34:47 <cjs> Why do you need to do that?
01:35:05 <cjs> It makes me suspicious that there's a misuse of quickcheck there.
01:35:05 <BeelsebobWork_> cjs: because if it choses size 0 it will generate that list -- and I speceficially *don't* want to test with that list
01:35:18 <BeelsebobWork_> it violates one of my pre-conditions
01:35:57 <cjs> Anyway, in the Erlang QuickCheck there's a size modification parameter.
01:36:08 <profmakx> hooray for the new GHC hammers!
01:36:11 <BeelsebobWork_> so in theory, the way to do this is to use the ==> operator to guarentee that you don't get it
01:36:22 <BeelsebobWork_> but how do you write a test for "the infinite list containing only 0"
01:36:29 <BeelsebobWork_> to put on the left of ==>
01:36:35 <Myoma> You can't
01:36:40 <BeelsebobWork_> exactly
01:36:41 <Myoma> it's infiinite
01:36:42 <cjs> ([0..] ==)
01:36:50 <BeelsebobWork_> cjs: which will non-terminate
01:36:55 <BeelsebobWork_> which is exactly the problem I'm trying to avoid
01:36:59 <cjs> Well, you didn't say a *terminating* test!
01:37:05 <BeelsebobWork_> haha
01:37:08 <Myoma> why do you care what infinite lists are
01:37:10 <Myoma> ??
01:37:14 <Myoma> don't use code
01:37:16 <cjs> Anyway, if it doesn't terminate, that's really the fault of the compiler. They're obviously equal.
01:37:29 <BeelsebobWork_> cjs: I think it's the fault of the language spec actually
01:37:51 <cjs> Well, regardless, it's obviously some artifact of practice of no interest to a good theoretician.
01:37:55 <BeelsebobWork_> Myoma: I care that the lists don't violate one of my preconditions
01:38:05 <Myoma> what
01:38:09 <Myoma> for quickcheck?
01:38:16 <humasect> sorry ejt, Myoma : p >>= \b-> if t b then s else return ()
01:38:18 <cjs> But anyway, maybe whatyou want to do is not return the list itself, but return a specification of how you generate the list, and check to see if it's a specification that would generate an infinite list of zeros.
01:38:18 <BeelsebobWork_> the preconditions for the function I'm testing
01:38:35 <BeelsebobWork_> one of the preconditions for that function is "don't call this with an infinite list of all equal values"
01:39:00 <Myoma> do this
01:39:18 <BeelsebobWork_> cjs: yeh, that's what I'm doing -- but there's one thing you can't edit in the spec -- and that's the size parameter
01:39:27 <Myoma> only make sure the first 302 elements are different
01:39:27 <BeelsebobWork_> which is exactly what I need to edit for this spec
01:39:39 <cjs> Hm? Hmm.
01:39:46 <Myoma> so you deal with a subset of the input you really wanted to test
01:39:52 <Myoma> but that was the case anyway, so no problem
01:40:03 <cjs> I'm not sure why you would need to edit the size.
01:40:08 <BeelsebobWork_> Myoma: hmm? what if my bug is "always crashes with inputs where there are 303 equal entries and then a different one"
01:40:20 <BeelsebobWork_> I appreciate this is an odd bug
01:40:23 <BeelsebobWork_> but I want to do this right
01:40:24 <Myoma> so test with a list of length 303
01:40:38 <BeelsebobWork_> but the point is that I don't know the value for where bugs get introduced
01:40:44 <Myoma> the real answer is scrap testing and prove your code correct
01:40:48 <Myoma> testing is crap
01:40:49 <BeelsebobWork_> it may bet the 100837640239th element that has to be different
01:41:26 <BeelsebobWork_> testing is proving pretty good actually -- it was only through testing that I discovered this precondition
01:41:33 <Myoma> if you write a formal proof you don't need to think about edge cases like this - and you know every possible input
01:41:55 <Myoma> (has been considered)
01:41:57 <BeelsebobWork_> and also, formal proofs of practical code are impractical
01:42:01 <BeelsebobWork_> otherwise I would do
01:42:02 <Myoma> oh are they?
01:42:19 <BeelsebobWork_> well, given that I did the proof for a much smaller piece of code, and it took me several months to figure out
01:42:21 <BeelsebobWork_> yes
01:42:48 <Myoma> maybe it's just something you need practice with
01:43:01 <Myoma> seems a bit of a wild conclusion to jump to
01:43:01 <BeelsebobWork_> maybe, but I don't have time to practice just now
01:43:09 <conal> perhaps also develop more powerful techniques
01:43:09 <humasect> hmm, no withJust or whenNothing ..
01:43:09 <BeelsebobWork_> hence... they're impractical
01:43:19 <conal> (for BeelsebobWork_ atm)
01:43:44 <BeelsebobWork_> yes
01:43:47 <Myoma> hi conal!
01:43:53 <conal> http://www.overcomingbias.com/2008/06/2-place-and-1-p.html
01:43:55 <Myoma> I have a question for you .. :)
01:44:00 <conal> Myoma: hi.  fire away.
01:44:05 <lambdabot> Title: Overcoming Bias: 2-Place and 1-Place Words
01:44:24 <Myoma> did anybody do lazy evaluation in lambda prolog? I couldn't think of an efficient way
01:44:37 <Myoma> I mean lazy evaluation of a functional language
01:45:22 <conal> Myoma: oh ... lazy rather than by name or by value.  not that i know of.
01:46:14 <conal> Myoma: though i stopped following logic programming for higher-order logic programming a long time ago
01:48:27 <BeelsebobWork_> > (repeat id) <*> []
01:48:30 <lambdabot>  mueval: Time limit exceeded
01:58:22 <humasect> caseM ... trying to avoid variables in IO code
01:58:35 <binrapt> Is debugging FP code generally more difficult than IP code?
01:58:43 <Myoma> what's IP
01:58:56 <binrapt> Imperatively programmed code
01:59:00 <binrapt> C++ etc
01:59:33 <ndmitchell> dcoutts: ping!!! (urgent ping!)
01:59:41 <ndmitchell> i think i just broke hackage: http://hackage.haskell.org/packages/archive/pkg-list.html
02:00:22 <opqdonut> sweet
02:00:28 <Myoma> you are not the first to break hackage
02:01:53 <humasect> @src maybe
02:01:53 <lambdabot> maybe n _ Nothing  = n
02:01:54 <lambdabot> maybe _ f (Just x) = f x
02:02:15 <Myoma> @src either
02:02:16 <lambdabot> either f _ (Left x)     =  f x
02:02:16 <lambdabot> either _ g (Right y)    =  g y
02:02:30 <Myoma> @src foldr
02:02:31 <lambdabot> foldr f z []     = z
02:02:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:04:05 <binrapt> Hmm what's the normal way of appending something at the end of a list?
02:04:11 <Myoma> ++
02:04:27 <Myoma> > (++"end") "this is the "
02:04:29 <binrapt> Oh of couse
02:04:30 <lambdabot>  "this is the end"
02:08:24 <humasect> how does one factor out the varname in something like this, seen so commonly in IO code: modify (\en->en {...})
02:08:31 <humasect> @hoogle puts
02:08:32 <lambdabot> Prelude putStr :: String -> IO ()
02:08:32 <lambdabot> Prelude putStrLn :: String -> IO ()
02:08:32 <lambdabot> Data.ByteString putStr :: ByteString -> IO ()
02:08:49 <humasect> @src gets
02:08:50 <lambdabot> Source not found. You type like i drive.
02:08:57 <Myoma> humasect: I think you must use functions instead of this strange record
02:09:06 <Myoma> syntob
02:09:09 <Myoma> syntax
02:09:30 <humasect> i'm blind
02:09:41 <humasect> :t modifyIORef
02:09:43 <lambdabot> Not in scope: `modifyIORef'
02:09:43 <Myoma> and ?
02:09:56 <humasect> and i can't see the alternative to record update than record syntax.
02:09:57 <medfly> humasect, lambdabot is a bot
02:09:59 <medfly> oh...
02:10:45 <humasect> @src Control.Monad.State.gets
02:10:46 <lambdabot> Source not found. My brain just exploded
02:13:15 <dobblego> @hoogle \(a, b) -> (b, a)
02:13:16 <lambdabot> Parse error:
02:13:16 <lambdabot>   --count=20 "\(a, b) -> (b, a)"
02:13:16 <lambdabot>              ^
02:13:56 <Myoma> :t swap
02:13:58 <lambdabot> Not in scope: `swap'
02:18:44 <EvilTerran> howdy folks
02:21:00 <BONUS> hey
02:21:30 <quicksilver> humasect: functional references.
02:21:34 <Myoma> hello
02:21:40 <quicksilver> humasect: a.k.a. lenses
02:23:23 <EvilTerran> morning sioraiocht
02:23:50 <sioraiocht> morning, EvilTerran.  What's up?
02:24:03 <EvilTerran> not much, not much
02:24:36 <humasect> quicksilver: oh? this sounds interesting
02:24:42 <binrapt> Hah! I think I managed to write a tokeniser in Haskell. http://hpaste.org/9952
02:24:52 <binrapt> It took me like 1 hour
02:25:06 <binrapt> For 15 lines
02:25:21 <Myoma> that looks good
02:25:30 <binrapt> I'm sure there already is a handy function for that which does all of that in one call
02:25:32 <quicksilver> humasect: hmm. twanvl had a blog but I can't find it.
02:25:35 <sioraiocht> @src words
02:25:35 <lambdabot> words s = case dropWhile isSpace s of
02:25:35 <lambdabot>     "" -> []
02:25:35 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
02:26:14 <sioraiocht> that's a good start, heh
02:26:38 <binrapt> That's a space tokeniser?
02:26:42 <sioraiocht> yup
02:27:03 <sioraiocht> if all of your tokens delimiters are only a character long, you can replace isSpace with whatever predicate you want
02:27:09 <binrapt> dropWhile works only with single characters right?
02:27:11 <binrapt> Right
02:27:29 <EvilTerran> single list items, yes
02:27:35 <EvilTerran> the type says so
02:27:45 <EvilTerran> ?type dropWhile
02:27:47 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:27:57 <humasect> > dropWhile ((==) "two") ["twoOne","twoThree","four"]
02:27:59 <lambdabot>  ["twoOne","twoThree","four"]
02:28:19 <humasect> wow it is later than it hought.
02:28:47 <sioraiocht> humasect: you want stripPrefix
02:28:49 <binrapt> So what's a neat way of doing this for separators which are lists themselves?
02:28:51 <binrapt> Ah
02:29:10 <sioraiocht> > stripPrefix("two") ["twoOne","twoThree","four"]
02:29:12 <humasect> sioraiocht: heh, yep
02:29:13 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
02:29:36 <sioraiocht> > map (stripPrefix "two") ["twoOne","twoThree","four"]
02:29:38 <humasect> binrapt: by this : [a] -> [[a]] which can come from first tokenising already.
02:29:39 <lambdabot>  [Just "One",Just "Three",Nothing]
02:29:43 <binrapt> Well I'm just doing all this stuff for education first, it'll take me a few months before I'll wrap my head around all this recursion to replace the imperative techniques I am still thinking in
02:30:36 <humasect> ?type words
02:30:38 <lambdabot> String -> [String]
02:30:45 <quicksilver> binrapt: as a general rule, "== []" is code smell, consider using case.
02:30:55 <sioraiocht> binrapt: most string operations can be done without resorting to recursion by using list combinators
02:31:04 <quicksilver> binrapt: in fact, case is often preferred to "if" where practical.
02:31:09 <Myoma> (== []) = null
02:31:11 <Myoma> > null []
02:31:14 <lambdabot>  True
02:31:52 <sioraiocht> binrapt: you just need to become best friends with the various versions of fold and map, and you can do MOST things
02:32:43 <BeelsebobWork_> Myoma: not quite
02:32:56 <BeelsebobWork_> null :: [a] -> Bool
02:33:04 <BeelsebobWork_> (==[]) :: Eq a => [a] -> Bool
02:33:10 <quicksilver> null is a refinement of (==[]), too.
02:33:15 <Myoma> :t null :: Eq a => [a] -> Bool
02:33:17 <lambdabot> forall a. (Eq a) => [a] -> Bool
02:33:24 <BeelsebobWork_> :t null
02:33:26 <lambdabot> forall a. [a] -> Bool
02:33:30 <Myoma> id = not . not
02:33:35 <Myoma> you know what I mean by = ?
02:33:53 <humasect> 'code smell' ...
02:33:55 <BeelsebobWork_> I assume the traditional meaning of = -- that they are semantically equal
02:34:08 <sioraiocht> > let fact = scanl (*) 1 [1..] in fact !! 5
02:34:11 <lambdabot>  120
02:34:34 <quicksilver> Myoma: yes, but there is a more substantial difference between null and (== [])
02:34:44 <sioraiocht> @src null
02:34:45 <lambdabot> null []     = True
02:34:45 <lambdabot> null (_:_)  = False
02:35:35 <BeelsebobWork_> quicksilver: I'm not seeing the difference atm -- something subtle with the pattern matching semantics?
02:35:42 <BeelsebobWork_> (other than the type)
02:36:02 <quicksilver> > null [1..]
02:36:05 <lambdabot>  False
02:36:08 <BeelsebobWork_> ah, okay
02:36:08 <quicksilver> > [1..] == []
02:36:09 <BeelsebobWork_> yeh
02:36:11 <lambdabot>  mueval: Time limit exceeded
02:36:17 <sioraiocht> oh wow
02:36:25 <quicksilver> it's a refinement
02:36:32 <sioraiocht> i didn't know that (==[]) would evaluate the whole list
02:36:37 <sioraiocht> that's rubbish...
02:36:37 <EvilTerran> that seems very odd
02:36:41 <BeelsebobWork_> it is very odd
02:36:42 <EvilTerran> ?src [] (==)
02:36:42 <lambdabot> []     == []     = True
02:36:43 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
02:36:43 <lambdabot> _      == _        = False
02:36:52 <binrapt> http://hpaste.org/9953 <- using switch in that case is better style then?
02:36:54 <BeelsebobWork_> yeh, so why doesn't that trip the last case immediately?
02:36:56 <EvilTerran> ... should it?
02:37:02 <EvilTerran> it shouldn't, AFAICT
02:37:07 <EvilTerran> *shouldn't diverge
02:37:14 <quicksilver> > [1..] == []
02:37:17 <lambdabot>  False
02:37:19 <quicksilver> heh
02:37:21 <quicksilver> ;)
02:37:22 <EvilTerran> ghci> [1..] == []
02:37:22 <EvilTerran> False
02:37:22 <quicksilver> I was wrong.
02:37:32 <quicksilver> but I got a very well-timed mueval timeout
02:37:34 <BeelsebobWork_> bad lambdabot being broken
02:37:39 <sioraiocht> lol wow
02:37:40 <quicksilver> mueval++ # lying to back up quicksilver
02:37:50 <sioraiocht> yeah seriously
02:37:56 <BeelsebobWork_> > repeat id <*> []
02:37:59 <lambdabot>  mueval: Time limit exceeded
02:38:14 <BeelsebobWork_> gief unamb to fix that
02:38:25 <EvilTerran> what?
02:38:39 <BeelsebobWork_> <*> with an inifinte structure on the left, and mempty on the right diverges
02:38:41 <BeelsebobWork_> it shouldn't
02:38:51 <BeelsebobWork_> or at least, not with any vaguely sensible definition of the semantics
02:38:56 <EvilTerran> "gief unamb"?
02:39:09 <BeelsebobWork_> oh, it could be fixed with conal's unambiguous choice operator
02:39:32 <EvilTerran> that explains "unamb", what about "gief"?
02:39:54 <BeelsebobWork_> oh, it needs seperated out from reactive, so I can spread it's seed through the world of Haskell code
02:40:04 <BeelsebobWork_> e.g. it should be in (&&) and (||)
02:40:07 <binrapt> So, having my |tokenise list separator currentTokens" which still takes the currentTokens argument, is it possible to default this value to [] if it's not specified or something like that?
02:40:13 <conal> BeelsebobWork_: i'll do it.
02:40:13 <EvilTerran> and what is this unambiguous chouce thingamajig?
02:40:15 <quicksilver> you'd hardly be the first person to suggest fair choice for lists.
02:40:23 <binrapt> Or do I have to make a new function to do that which cannot have the same name in Haskell?
02:40:29 <quicksilver> and you don't need the threaded choice operator to do that.
02:40:36 <BeelsebobWork_> EvilTerran: given two equal values, it computes both of them, and returns the result from the first one to terminate
02:40:37 <binrapt> Err that | was supposed to be "
02:40:49 <EvilTerran> BeelsebobWork_, ah, yes, i've thought of such a thing myself
02:41:19 <EvilTerran> although it does require a certain amount of restraint to not break referential transparency with such a thing
02:41:23 <BeelsebobWork_> yep
02:42:08 <EvilTerran> does lambdabot have Control.Monad.Omega?
02:42:10 <BeelsebobWork_> in fact, in this specific case it only doesn't break referential transparency if you assume that the current implementation of <*> produces the correct result after an infinite amount of time
02:42:19 <EvilTerran> ?type runOmega
02:42:21 <lambdabot> Not in scope: `runOmega'
02:42:29 <EvilTerran> in this specific case, yes
02:43:33 <EvilTerran> i think "runOmega $ each (repeat id) <*> each []" would work
02:43:46 <EvilTerran> > replicate 16 id <*> []
02:43:49 <lambdabot>  mueval: Time limit exceeded
02:43:54 <EvilTerran> harumph
02:44:02 <BeelsebobWork_> yeh, it's actually a more general problem I'm wanting to fix
02:44:16 <BeelsebobWork_> in that we just discovered the same bug in <*> for Event in Reactive
02:44:56 <EvilTerran> actually, the Omega version doesn't work either - that solves a completely different problem
02:45:02 <BeelsebobWork_> hehe
02:45:03 <humasect> be well everyone=)
02:45:09 * BeelsebobWork_ doesn't know what Omega does atm
02:45:58 <EvilTerran> ?hackage control-monad-omega
02:45:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega
02:46:27 <EvilTerran> "if x appears at a finite index in xs, and y appears at a finite index in f x, then y will appear at a finite index in each xs >>= f"
02:46:38 * quicksilver nods
02:46:45 <quicksilver> that's what I was calling fair choice
02:46:54 <quicksilver> but the price you pay is a strange ordering
02:47:02 <quicksilver> (and, of course, it doesn't solve this problem ;)
02:47:09 <EvilTerran> indeed not
02:47:14 <quicksilver> concat (repeat []) does not converge.
02:47:32 <BeelsebobWork_> EvilTerran: interesting
02:48:09 <BeelsebobWork_> quicksilver: doesn't mean it shouldn't
02:48:55 <EvilTerran> BeelsebobWork_, it makes perfect sense to me that it doesn't
02:49:01 <EvilTerran> 0 * infinity is undefined
02:49:16 <quicksilver> BeelsebobWork_: no, but you'd have to make a pretty convincing argument.
02:49:29 <quicksilver> we have a well understood semantics
02:49:35 <quicksilver> in which it's fairly clear that it doesn't converge.
02:49:41 <saya> is there any intent to add design by contract to haskell? that would make it even more powerful!
02:49:44 <BeelsebobWork_> EvilTerran: it makes sense that it doesn't because we have an implementation that we understand
02:49:51 <quicksilver> changing that semantics (even in the direction of refinement) is a big change.
02:50:02 <BeelsebobWork_> as far as semantics, you sit down and you go "hmm, concatonating lots of empty lists, that's the empty list"
02:50:32 <EvilTerran> but what if it's (repeat [] ++ [[()]]) ?
02:50:42 <BeelsebobWork_> quicksilver: yeh, the problem with the same thing happening in Event is that it's actually something that you would reasonably expect to converge
02:50:46 <EvilTerran> i think the answer being [] would be wrong
02:51:03 <EvilTerran> it'd be like saying 0 * infinity = 0
02:51:12 <BeelsebobWork_> hmm
02:51:14 <BeelsebobWork_> true dat
02:51:46 <Cale> EvilTerran: Sometimes that definition is made :)
02:52:10 <EvilTerran> not on my watch ;)
02:52:58 <Cale> Well, it certainly happens in fields like the hyperreals ;)
02:53:18 <Cale> Though in that case, there's more than one infinity :)
03:05:01 <EvilTerran> Cale, is there an infinity of infinities? countable or uncountable? :P
03:05:13 <EvilTerran> (i'm just being fascetious, there's no need to answer that)
03:05:25 <DrSyzygy> EvilTerran: Certainly an uncountable infinity of infinities.
03:05:39 <DrSyzygy> For starters, in P^k you've a P^{k-1} at infinity.
03:05:39 <Cale> yeah
03:05:46 * EvilTerran boggles
03:05:54 <DrSyzygy> So already in P^2R, you've R U {*} worth of infinity.
03:06:08 <EvilTerran> i'll get back to you when i know the maths :P
03:06:11 <Cale> DrSyzygy: I think he was referring to the hyperreals specifically (which I mentioned)
03:06:41 <DrSyzygy> Cale: Yeah yeah yeah....
03:07:10 <Cale> EvilTerran: There are uncountably many infinite elements (that is, elements greater than any integer) in the hyperreals
03:07:46 <EvilTerran> hurray
03:08:07 <Cale> EvilTerran: In fact, R is a subfield of *R, and if you take any infinite element in *R and add an element of R, you get another distinct infinite element.
03:08:34 <Cale> Or adding two infinite elements with the same sign will produce another one (again different).
03:08:35 <EvilTerran> ok ok :)
03:09:49 <skorpan> i read somewhere that you cannot use type synonyms when defining instances of type classes, but i can't find where i read it.
03:09:58 <skorpan> i think i read it in "real world haskell", does anyone know?
03:10:02 <Cale> skorpan: Possibly in the report?
03:10:10 <Cale> It's true in Haskell 98
03:10:18 <Cale> But GHC can relax that restriction for you.
03:10:29 <skorpan> TypeSynonymInstances?
03:10:47 <Cale> yeah
03:10:53 <skorpan> is ee
03:10:56 <skorpan> i see'
03:10:57 <skorpan> *
03:11:20 <Cale> You can't define any instances that you couldn't otherwise define of course
03:11:39 <sioraiocht> @src unfoldr
03:11:40 <lambdabot> unfoldr f b  = case f b of
03:11:40 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:11:40 <lambdabot>    Nothing        -> []
03:11:54 <sioraiocht> @type unfoldr
03:11:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:12:33 <Cale> Like, I'm pretty certain that you'll still get an error if you do something like   type FunTo b a = a -> b  and then try to define an instance Cofunctor (FunTo b) or something.
03:13:14 <Cale> > unfoldr (\x -> Just (x,x+1)) 0
03:13:17 <lambdabot>  mueval: Time limit exceeded
03:13:19 <Cale> hmm
03:13:43 <binrapt> @src Just
03:13:43 <lambdabot> Source not found. Just try something else.
03:13:46 <binrapt> :(
03:13:46 <Cale> odd that it didn't manage to generate one line in an appropriate amount of time :)
03:13:57 <Cale> binrapt: Just is a data constructor for Maybe
03:14:04 <Cale> data Maybe a = Nothing | Just a
03:14:16 <Cale> :t Nothing
03:14:18 <lambdabot> forall a. Maybe a
03:14:20 <Cale> :t Just
03:14:22 <lambdabot> forall a. a -> Maybe a
03:19:34 <im_alone> @google Damas
03:19:41 <lambdabot> http://www.damasjewel.com/
03:19:41 <lambdabot> Title: Damas Jewellery
03:20:13 <im_alone> @google Milner
03:20:15 <lambdabot> http://www.milner.com/
03:20:15 <lambdabot> Title: Milner Document Products, Inc. - We Know What Documents Go Through
03:20:37 <Cale> heh
03:20:51 <Cale> @google Damas-Milner
03:20:53 <lambdabot> No Result Found.
03:21:08 <im_alone> wtf?
03:21:11 <Cale> @google Damas Milner
03:21:14 <lambdabot> http://citeseer.ist.psu.edu/376069.html
03:21:20 <Cale> heh, okay...
03:21:28 <Cale> I have no idea :)
03:21:40 <im_alone> thanks ;)
03:22:29 <eu-prleu-peupeu> hey ppl from planet Haskell
03:22:43 <BeelsebobWork> is that like a cheep resteraunt?
03:22:49 <BeelsebobWork> with lambdas sticking out the wall?
03:26:03 <skorpan> @pl \x -> x + 1
03:26:04 <lambdabot> (1 +)
03:26:18 <DrSyzygy> @pl \x -> 1 + x
03:26:19 <lambdabot> (1 +)
03:28:53 <quicksilver> commutativity smarts, @pl has them
03:29:10 <opqdonut> :)
03:31:41 <im_alone> @pl \x -> x * 1
03:31:41 <lambdabot> id
03:31:52 <dobblego> ha nice
03:32:04 <im_alone> @pl \x -> x * 2
03:32:05 <lambdabot> (2 *)
03:32:11 <im_alone> @pl \x -> 2 * x
03:32:12 <lambdabot> (2 *)
03:36:41 <FordCortina> @djinn cast Int -> Double
03:36:50 <FordCortina> @djinn cast ? Int -> Double
03:36:51 <lambdabot> Cannot parse command
03:37:01 <FordCortina> @djinn cast ? a -> b
03:37:02 <lambdabot> Cannot parse command
03:37:24 <Peaker> why does @pl know arithmetic? :)
03:37:27 <FordCortina> @help djinn
03:37:28 <lambdabot> djinn <type>.
03:37:28 <lambdabot> Generates Haskell code from a type.
03:37:28 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
03:37:31 <Peaker> where does it come in handy?
03:38:16 <FordCortina> @djinn cast ? a -> b;
03:38:16 <lambdabot> Cannot parse command
03:38:34 <FordCortina> @djinn id ? a -> b;
03:38:35 <lambdabot> Cannot parse command
03:38:40 <FordCortina> @djinn id ? a -> b
03:38:40 <lambdabot> Cannot parse command
03:38:51 <Peaker> @djinn (Functor f) => a -> f (a->b) -> f b
03:39:17 <Peaker> hmm
03:39:27 <FordCortina> do you think djinn isnt working?
03:39:47 <Peaker> @djinn (a -> b) -> a -> b
03:39:47 <lambdabot> f a = a
03:39:51 <FordCortina> ah
03:40:00 <Peaker> @djinn (Functor f) => a -> f (a->b) -> f b
03:40:05 <Peaker> no reply is weird
03:40:17 <Peaker> is lambdabot accumulating unterminating djinn threads?
03:42:14 <quicksilver> Peaker: I can't think of an occasion where (* 1) -> id is a useful transform. But (* 2) -> (2 *) definitely is.
03:44:21 <FordCortina> @djinn distrR ? (a, Either b c) -> Either (a,b) (a,c)
03:44:22 <lambdabot> Cannot parse command
03:44:28 <FordCortina> @djinn > distrR ? (a, Either b c) -> Either (a,b) (a,c)
03:44:29 <lambdabot> Cannot parse command
03:44:42 <FordCortina> am i getting my syntax wrong?
03:45:12 <FordCortina> that command works on my local djinn installation
03:46:44 <quicksilver> FordCortina: I thought it was @djinn-add or something.
03:46:44 <Beelsebob> @djinn distrR :: (a, Either b c) -> Either (a,b) (a,c)
03:46:45 <lambdabot> Cannot parse command
03:47:57 <FordCortina> @help
03:47:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:48:04 <FordCortina> @list
03:48:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:48:28 <kaol> @djinn (a, Either b c) -> Either (a,b) (a,c)
03:48:28 <lambdabot> f (a, b) =
03:48:29 <lambdabot>     case b of
03:48:29 <lambdabot>     Left c -> Left (a, c)
03:48:29 <lambdabot>     Right d -> Right (a, d)
03:49:05 <quicksilver> maybe I misundertood actually :)
03:49:14 <quicksilver> for some reason I thought FordCortina was trying to add a rule.
03:49:59 <Beelsebob> I think he was trying to do that, but s/f/distrR/
03:50:04 <Beelsebob> unless I misunderstood
03:50:35 <FordCortina> why cant i seem to get a response from lamdabot in private messages?
03:51:13 <FordCortina> ah finally
03:51:37 <FordCortina> it works now
03:52:02 <lilac> @pl \x -> 1.0 + x + 1e38
03:52:05 <lambdabot> ((1 e38 + 1 . 0) +)
03:52:24 <lilac> correct parser, @pl doesn't have it...
03:53:04 <quicksilver> indeed not.
03:53:56 <lilac> also, + on Double isn't associative, so...
03:54:16 <FordCortina> that's funny.... the version of djinn i downloaded off darcs is less recent than the one that lambdabot uses...
03:55:09 <quicksilver> lilac: true, but who cares about that? ;)
04:03:39 <lilac> quicksilver: numerical analysts?
04:04:07 <lilac> is the compiler allowed to reassociate +?
04:08:13 <quicksilver> lilac: I'm not aware of any legislation restricting what the compiler does :)
04:08:30 <quicksilver> lilac: A numerical analyst who uses Doubles better be sure he knows what he's doing, though.
04:30:36 <tristes_tigres> Hi
04:30:44 <tristes_tigres> @seen int-e
04:30:45 <lambdabot> I saw int-e leaving ##logic, #ghc, #haskell-overflow and #haskell 10h 19m 14s ago, and .
04:33:53 <skorpan> is there anything for latex which allow me to easily insert haskell code into a document?
04:34:39 <abbe> skorpan, \begin{verbatim} \end{verbatim}
04:34:56 <abbe> skorpan, or how about checking out the source code YAHT
04:36:30 <BeelsebobWork> \begin{alltt} I find works better for the most part, because it allows you to do things like itallicise comments
04:36:40 <BeelsebobWork> otoh, it also fucks you over when you want to put a lambda in
04:36:45 <quicksilver> the listings package is better, isn't it.
04:36:52 <quicksilver> does nice formatting.
04:37:12 <BeelsebobWork> yeh, usually I don't want nice formatting
04:37:17 <haskellian> i want to create a simple finite state machine, what should i create it for?
04:37:18 <BeelsebobWork> I want just very basic formatting
04:37:21 <BeelsebobWork> and otherwise teletype
04:37:37 <BeelsebobWork> haskellian: deal with simple greps
04:37:41 <quicksilver> also see lhs2tex
04:37:42 <quicksilver> and http://caos.di.uminho.pt/~ulisses/blog/2008/03/30/latex-listings-package-haskell/
04:37:50 <lambdabot> Title: Ulisses Costa Blog » Blog Archive » LaTeX listings package - Haskell, http://tinyurl.com/65fcgo
04:37:55 <haskellian> regexps u mean?
04:38:15 <BeelsebobWork> yes
04:40:09 <haskellian> anyone know a good article about "parsers vs regexps"?
04:40:36 <BeelsebobWork> what about them?
04:40:45 <BeelsebobWork> about the whole machine power levels thing?
04:43:39 <haskellian> yes
04:44:26 <yitz> machine power levels?
04:44:52 <shukhov> over 9000
04:44:54 <BeelsebobWork> heh
04:45:14 <BeelsebobWork> as in, the whole scale of how powerful machines are going from FSMs -> TMs
04:46:23 <quicksilver> the pragmatists point about regexps is not about their strength
04:46:27 <quicksilver> it's about their purpose
04:46:32 <quicksilver> regexps are actually a mini-language
04:46:34 <yitz> TMs?
04:46:41 <loop> turing machines..
04:46:46 <quicksilver> their purpose is to allow the user to specify his grammar
04:46:54 <quicksilver> (user of, say, 'sed', 'awk' or 'emacs')
04:47:03 <yitz> wha? turing machines are finite state machines
04:47:09 <quicksilver> whereas a parser is not a minilanguage ;)
04:47:16 <quicksilver> yitz: turing machines are infinite state machines.
04:47:27 <yitz> ah, i see
04:48:02 <haskellian> well i was thinking more along the lines of using regexps or parsers to to parse text
04:48:13 <ivanm> has anyone managed to build hmatrix? It keeps bombing out on me at lib/Numeric/LinearAlgebra/Tests/Instances.hs :s
04:48:13 <yitz> a parser is a program. so is a regexp.
04:48:52 <quicksilver> RE is a language of its own, though.
04:49:00 <haskellian> yes but the parsec lbrary lets you implement you own grammars for parser skind of no?
04:49:14 <quicksilver> haskellian: if you are writing a haskell program to parse something, than REs are not the natural choice
04:49:19 <quicksilver> they have essentially no advantages
04:49:26 <BeelsebobWork> yitz: yes, but they require differently powerful machines to run them -- regexps can be run on a smiple DFSM, while parsers require a stack added
04:49:34 <BeelsebobWork> well, context-free parsers do
04:49:48 <quicksilver> the only advantage is familiarity : if you already know how to use REs, then perhaps that approach might be quickest for you.
04:49:59 <quicksilver> otherwise REs are best viewed as a piece of historical arcana.
04:50:04 <BeelsebobWork> quicksilver: concieness
04:50:16 <quicksilver> True.
04:50:23 <BeelsebobWork> it's much quicker to write a regexp on a command line than it is a full parser
04:50:36 <quicksilver> BeelsebobWork: that's what I mean about them being a language, see my earlier comments.
04:50:49 <quicksilver> they make perfect sense when using 'sed' from the commandline, or similar things.
04:50:53 <BeelsebobWork> oh, okay, I misinterpretted you *goes and reads again*
04:50:56 <yitz> quicksilver: not exactly - they're concise. I wouldn't want to have to write out a parsec parser on every grep command line
04:51:08 <quicksilver> yitz: which is what I mean about them being a language.
04:51:15 <quicksilver> they are a language you use to communicate with grep and sed.
04:51:24 <quicksilver> in that context their advantage is being standard and concise.
04:51:59 <yitz> but yeah, for a haskell program why obfuscate it with re when you can write a clear and simple parser, that easily grows, refactors, and scales
04:54:10 <yitz> hmm are you sure that there is such a qualitative difference between re and parsers? if you just describe the monadic vocabulary, and leave out recurse etc. which is generally not needed, don't you come out with the more or less the same thing?
04:54:24 <quicksilver> Yes. Google 'regular language' :)
04:54:39 <quicksilver> although some dialects of REs have some extensions which take them out of the regular domain, I think.
04:54:47 <Botje> yes
04:54:52 <Botje> like backreferences
04:54:58 <BeelsebobWork> that or google "Deterministic Finite State Machine"
04:55:57 <yitz> so then what's all the noise about?
05:00:36 <quicksilver> noise? I just like the sound of my own voice.
05:02:25 <yitz> what's the sound of one hand clapping a keyboard on irc?
05:03:25 <Botje> dlkg lmk,fgdfµglm, ?
05:03:26 <dcoutts_> yitz: probably something like "rsu8u0[[0u 0[" as fingers hit keys randomly
05:05:33 <cjs> Oh dear. The "pumping lemma"?
05:06:29 <cjs> This entry is math porn.
05:07:35 <DrSyzygy> Mmmmmm! Pumping lemma!
05:08:46 <FordCortina> if (a->b) corresponds to implication, (a,b) conjunction, and Either a b disjunction, what is "not"?
05:09:06 <quicksilver> -> Void
05:09:10 <quicksilver> where Void is an uninhabited type.
05:09:32 <FordCortina> does Void have _|_ ?
05:09:34 <quicksilver> that's as close as you get in intuitionistic logic, which the correspondance is based on.
05:09:44 <quicksilver> _|_ breaks the logic
05:10:01 <quicksilver> you can only play the logic games if you pretend _|_ doesn't exist.
05:10:28 <FordCortina> ic
05:10:29 <FordCortina> thanks
05:15:48 <cjs> quicksilver, why are you so smart?
05:16:11 <quicksilver> I think I'm demonstrating knowledge, not smartness.
05:16:25 <quicksilver> I have that knowledge because I spent five years in a CS dept in a logic group.
05:16:36 <cjs> Oh dear. I feel for you. :-)
05:17:02 * cjs thinks that group theory leads eventually to group therapy.
05:20:40 <quicksilver> that was 'group' in the common english sense "group of people studying a particular subject"
05:20:43 <quicksilver> no group theory involved.
05:20:48 <quicksilver> A few categorical sheaves, though.
05:20:56 <cjs> No! Say it isn't so!
05:21:14 <desp> Grarg.
05:21:36 <desp> http://hpaste.org/9955
05:21:49 <cjs> Hey, I'm just trying to keep the conversation going in case anybody wanders in and decides not to use Haskell because the channel is not very active, showing lack of interest.
05:22:00 <desp> Any ideas how to make the "> " appear immediately?
05:22:29 <cjs> hFlush stdout
05:22:38 <desp> Ah.  Thanks.
05:22:42 <cjs> Dont' forget the "import System.IO (hFlush)"
05:22:55 <desp> Yeah.
05:23:13 <cjs> Woo! I answered a question about Haskell!
05:23:30 <cjs> Probably the only one in the last six hours that didn't involve category theory. :-)
05:23:36 <desp> ;)
05:23:41 <lilac> :-/ why doesn't haskell flush stdout when reading from stdin?
05:23:45 <desp> I should've remembered how to do this anyway.
05:23:52 <cjs> Yeah, I always have to pounce on those.
05:24:21 <cjs> lilac: Why should it? libc doesn't.
05:24:32 <lilac> cjs: yes it does! :)
05:24:38 <lilac> (iirc)
05:25:01 * lilac tests
05:25:45 <yitz> lilac: you can set std no buffering, or line buffering and finish the line
05:25:53 <yitz> stdout
05:27:43 <lilac> yitz: but the default in C and C++ is the much more sane "flush on read from stdin"
05:27:57 <lilac> which corresponds to neither line buffering nor no buffering
05:28:17 <lilac> in fact, it's orthogonal to that
05:28:42 <cjs> Hmmm.
05:29:25 <cjs> Having that as a buffering mode would kinda make sense, I guess.
05:30:15 <lilac> i think not as a buffering mode but as a separate flag
05:30:45 <lilac> (since block buffering + flush on read and line buffering + flush on read both make sense)
05:31:18 <lilac> looks like Haskell '98 permits an implementation to flush more often but doesn't require it.
05:31:35 <dmead> @hoogle <!!>
05:31:36 <lambdabot> No results found
05:31:39 <dmead> @hoogle <!>
05:31:40 <lambdabot> No results found
05:34:30 <yitz> lilac: that buffering convention appears to be special to linux. i would guess that unix purists would have something to say about why it's not a good idea...
05:36:58 <mmorrow> haskellian: for hmatrix, i edit the cabal file and comment out the modules that have problems
05:40:13 <ivanm> mmorrow: you talking to me?
05:40:27 <cjs> Ah, that would be it.
05:40:32 * cjs is a BSD guy.
05:43:38 <lilac> yitz: the C standard says "Furthermore, characters are intended to be transmitted as a block to the host environment when [...] input is requested on an unbuffered stream"
05:44:13 <lilac> although to be fair it also says "Support for these characteristics is implementation-defined"
05:45:11 <Saizan> ?seen Igloo
05:45:11 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 24m 47s ago.
05:45:13 <yitz> lilac: where in the C standard? I'm comparing the man pages for stdout/setbuf on linux vs darwin (bsd-ish)
05:47:19 <lilac> 7.19.3.3
05:49:07 <cjs> On my NetBSD system, according to setbuf(3), "when [the output stream] is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically stdin)."
05:49:14 <cjs> Doesn't sound so orthogonal to me.
05:51:41 <mmorrow> ivanm: that was @haskellian
05:51:59 <yitz> cjs: ok I see that in darwin also. but that behavior is for line buffered, not unbuffered. and it is a special case when you are attached to a terminal.
05:52:00 <mmorrow> oh, yes
05:52:15 <mmorrow> ivanm: heh, yes i'm talking to you :)
05:53:37 <ivanm> mmorrow: OK, which one of those statements am I meant to believe? :p
05:53:41 <mmorrow> haha
05:53:51 <ivanm> anyway, with dcoutts_'s help I managed to get it working (it doesn't like quickcheck-2)
05:54:02 <mmorrow> ah, nice.
05:54:42 <mmorrow> did you add a QuickCheck < 2.0  to the cabal file or something?
05:55:04 <ivanm> well, with Cabal 1.4 you can pass in a constraint parameter
05:55:07 <mmorrow> in particular, the " < 2.0 " part
05:55:13 <mmorrow> ivanm: oh nice nice
05:55:16 <ivanm> so I made the ebuild use it ;-)
05:55:23 <ivanm> since patching is a PITA
05:55:30 <mmorrow> for sure
05:56:46 <ivanm> mmorrow: since you've obviously used hmatrix, do you know if there's any map-like functions in it?
05:58:25 <ivanm> closest I can find is a combination of liftMatrix and liftVector
05:59:01 <EvilTerran> no Functor instance?
05:59:53 <ivanm> nope
06:00:16 * ivanm makes a wild stab at thinking that a matrix is stored as a vector of vectors
06:06:14 <mmorrow> ivanm: a matrix is stored as a Vector along with a row and col count
06:06:30 <ivanm> mmorrow: so its shaped on the fly?
06:06:55 <mmorrow> EvilTerran: yeah, it can't be a Functor because it has    (Storable a) => Vector a
06:07:00 <ivanm> so if I use liftMatrix on a matrix, does it apply the function row-wise or column-wise
06:07:03 <mmorrow> ivanm: yeah
06:07:18 <ivanm> why does that restriction stop it from being a functor?
06:08:09 <mmorrow> heh, now that i think of it i can't tell you why. but i'm 99.99% sure this is the case :)
06:08:22 <mmorrow> there's even an fmap' somewhere (or not i can't remember)
06:08:29 <ivanm> heh
06:08:34 * mmorrow uses a heavily modified version
06:08:46 <ivanm> oh? modified in what way?
06:10:29 <mmorrow> i added some C functions to do misc things, and moved some instances to different modules, added some ghc particular things, added some {-# RULES #-}, wrapped half of the GSL Statistics functions in a module (this i've been meaning to send in as a patch), and other random things
06:11:14 <ivanm> heh
06:11:30 <mmorrow> liftVector, last i checked, is     \f -> fromList . f . toList   :(
06:11:50 <ivanm> and yay, hmatrix includes complete elliptic integrals! this saves me from having to port matlab's code! \o/
06:12:04 <ivanm> mmorrow: if so, that _really_ sucks :(
06:12:21 <Mitar> does there exist somethin like until? (like unless exists?)
06:12:36 <mmorrow> yeah, hmatrix can pretty much replace matlab for most things :)
06:13:05 <sjanssen> ivanm: a Functor has to be able to contain *all* types -- Vector can only contain types which are instances of Storable
06:13:16 <gwern> Mitar: maybe 'when' with a ngeated test?
06:13:18 <gwern> @hoogle when
06:13:19 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
06:13:21 <Botje> until cond ~~ while (not cond) ?
06:13:25 <ivanm> sjanssen: *nod*
06:13:30 <Mitar> there is while?
06:13:35 <Botje> is there? :p
06:13:40 <Mitar> i do not know :-)
06:13:42 <Botje> :p
06:13:50 <Mitar> i know there is no for :-)
06:14:09 <mmorrow> ivanm: have you seen the (new) tutorial? http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/hmatrix.pdf
06:14:14 <lambdabot> Title: A simple scientific library for Haskell
06:14:27 <ivanm> yup
06:14:32 <mmorrow> :)
06:14:35 <Mitar> so is there something like that?
06:14:35 <gwern> @hoogle while
06:14:35 <ejt> @hoogle forM
06:14:36 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
06:14:36 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
06:14:36 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
06:14:36 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
06:14:36 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
06:14:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
06:15:18 <ivanm> mmorrow: I can't even find where liftVector is defined :s
06:15:31 <mmorrow> err, i meant    \f -> fromList . fmap f . toList
06:15:36 <mmorrow> a sec, i'll find it
06:16:00 <mmorrow> ivanm: are you looking at the code or the haddock docs?
06:16:02 <dmead> @hoogle transpose
06:16:03 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
06:16:03 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
06:16:03 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
06:16:04 <ivanm> code
06:16:09 <mmorrow> ok, a sec
06:16:15 <ivanm> OK, found it... Data.Packed.Internal.Vector.hs
06:16:25 <dmead> > transpose [[1..3],[4..6]]
06:16:26 <ivanm> and yup, it's fromList . map f . toList :s
06:16:27 <mmorrow> Data.Packed.Internal.Vector
06:16:28 <lambdabot>  [[1,4],[2,5],[3,6]]
06:17:07 <ivanm> mmorrow: would you know _why_ it's like that? there's no efficient way of going through the list?
06:17:15 <dmead> > [ [x,y] | x <- [1..3], y <-[4..6]]
06:17:17 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
06:18:10 <dmead> > transpose[ [x,y] | x <- [1..3], y <-[4..6]]
06:18:12 <lambdabot>  [[1,1,1,2,2,2,3,3,3],[4,5,6,4,5,6,4,5,6]]
06:18:33 <mmorrow> ivanm: all the efficient functions which map over a Vector are written in C. so get your FFI shoes on ;)
06:18:46 <dmead> :t intersperse
06:18:48 <lambdabot> forall a. a -> [a] -> [a]
06:19:00 <dmead> ?src intersperse
06:19:01 <lambdabot> intersperse _   []     = []
06:19:01 <lambdabot> intersperse _   [x]    = [x]
06:19:01 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
06:19:02 <ivanm> mmorrow: heh, never touched FFI before
06:19:09 <ivanm> never really touched C much before either :s
06:19:20 <dmead> :s
06:19:42 <ivanm> mmorrow: so how is it actually stored if it can't be done efficiently in haskell?
06:19:59 <mmorrow> hehe, the hmatrix C code is heavily macro-stylized, read over the code for a bit and you'll see the general pattern
06:21:24 <mmorrow> ivanm: i think the design decision is that since if you really care about it being fast, you'll use a specialized C function, in all other cases the convenience of  fromList . fmap f . toList  outweighs any loss of efficiency by doing it that way
06:21:55 <ivanm> hmmm... looks like amap and ixmap for IArray use lists as well :s
06:22:00 <ivanm> mmorrow: *nod*
06:22:28 <mmorrow> and actually, if you didn't know it was doing that, you may never actually notice. it's not /that/ bad in practice i've found
06:23:06 <ivanm> thing is, I need to implement the metropolis algorithm... and AFAICT to do so I need to map over elements in such a way that I can look up their neighbours :s
06:23:20 <ivanm> and no array interface allows that :(
06:23:45 <ivanm> at least with hmatrix there's the lift{Vector,Matrix}2 which lets me join to vectors/matrices together
06:24:51 <ivanm> anyway, AFAICT, for hmatrix: fmap f = liftMatrix (liftVector f)
06:25:31 <mmorrow> pretty much, except you have to call that fmap' or something
06:25:42 <mmorrow> on account of the Storable constraint
06:25:55 <mmorrow> pain in the ass
06:26:07 <ivanm> yeah
06:26:12 <ivanm> hmap? ;-)
06:26:27 <mmorrow> heh
06:26:34 <Trin_CZ> Hi is there an https capable library for haskell?
06:27:00 <ivanm> @instances Storable
06:27:01 <Trin_CZ> HsOpenSSL and Browser was all I've found
06:27:02 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
06:27:19 <ivanm> @instances-including Foreign.Storable Storable
06:27:19 <lambdabot> Unknown command, try @list
06:27:23 <dmead> @hoogle zipwith
06:27:24 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:27:24 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:27:24 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
06:27:31 <ivanm> @instances-importing Foreign.Storable Storable
06:27:32 <lambdabot> Bool, Char, Double, Float, Int
06:27:41 <matthew-_> ivanm: quite a lot implements Storable
06:27:42 <subw> Trin_CZ: try network-minihttp
06:27:45 <ivanm> dammit, no tuples? :(
06:27:57 <dmead> > transpose[ [x,y] | x <- [1..3], y <-[4..5]]
06:27:58 <mmorrow> a Vector/Matrix is pretty much an unboxed array (and mutable too with minor hacking)
06:28:01 <lambdabot>  mueval: Time limit exceeded
06:28:06 <matthew-_> ivanm: no, not that I've seen
06:28:10 <ivanm> :(
06:28:12 <dmead> > transpose[ [x,y] | x <- [1..3], y <-[4..6]]
06:28:15 <lambdabot>  mueval: Time limit exceeded
06:28:19 <dmead> > transpose [ [x,y] | x <- [1..3], y <-[4..6]]
06:28:22 <lambdabot>  mueval: Time limit exceeded
06:28:25 <dmead> wtf
06:28:35 <ivanm> OK, looks like I might have to map over a list of indices or something rather than mapping over the matrix itself :s
06:28:37 <dmead> someone give lambdabot the paddles
06:28:44 <subw> it actually uses HsOpenSSL and is (for me at least) easier to use than - say - HTTP
06:28:50 <matthew-_> ivanm: yeah, but it's hardly difficult to write instance (Storable a, Storable b) => Storable (a,b) where...
06:29:08 <ivanm> @src Storable
06:29:09 <lambdabot> Source not found. Take a stress pill and think things over.
06:29:23 <dmead> > 1
06:29:25 <ivanm> dammit, what lambdabot command gives you the functions required for a class?
06:29:26 <lambdabot>  mueval: Time limit exceeded
06:29:34 <dmead> guys?
06:29:37 <dmead> he's dead
06:29:42 <dmead> > "hello"
06:29:43 <ivanm> s/he/she/
06:29:45 <lambdabot>  "hello"
06:29:53 <dmead> > 1
06:29:56 <lambdabot>  1
06:30:01 <dmead> she's back!
06:30:04 <ivanm> dmead: other channels probably using her too much...
06:30:07 <dmead> > transpose [ [x,y] | x <- [1..3], y <-[4..6]]
06:30:08 <dmead> ah
06:30:09 <lambdabot>  [[1,1,1,2,2,2,3,3,3],[4,5,6,4,5,6,4,5,6]]
06:30:13 <dmead> > transpose [ [x,y] | x <- [1..3], y <-[4..5]]
06:30:16 <lambdabot>  [[1,1,2,2,3,3],[4,5,4,5,4,5]]
06:30:16 <matthew-_> ivanm: the docs are online...
06:30:24 <ivanm> oh, yeah :s
06:30:51 <dmead> > intersperse (transpose [ [x,y] | x <- [1..3], y <-[4..5]]) (,)
06:30:54 <lambdabot>  Couldn't match expected type `[[[t]]]'
06:31:00 <dmead> > intersperse (transpose [ [x,y] | x <- [1..3], y <-[4..5]]) "-"
06:31:02 <lambdabot>  Couldn't match expected type `[[t]]' against inferred type `Char'
06:31:13 <dmead> ?src intersperse
06:31:14 <lambdabot> intersperse _   []     = []
06:31:14 <lambdabot> intersperse _   [x]    = [x]
06:31:14 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
06:31:31 <dmead> > intersperse (transpose [ [x,y] | x <- [1..3], y <-[4..5]])  ["-"]
06:31:33 <ivanm> > sizeOf (1::Int)
06:31:33 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Char'
06:31:34 <yitz> > [[n..n+n]|n<-[1..5]]
06:31:36 <lambdabot> Terminated
06:31:36 <lambdabot> Terminated
06:31:40 <ivanm> > sizeOf (1::Int)
06:31:42 <lambdabot> Terminated
06:31:44 <yitz> > [[n..n+n]|n<-[1..5]]
06:31:47 <lambdabot>  [[1,2],[2,3,4],[3,4,5,6],[4,5,6,7,8],[5,6,7,8,9,10]]
06:31:48 <ivanm> hmmm...
06:31:52 <yitz> > transpose [[n..n+n]|n<-[1..5]]
06:31:55 <lambdabot>  mueval: Time limit exceeded
06:32:00 <ivanm> mueval is definitly terminating more than hs-plugins did...
06:32:00 <dmead> > intersperse (transpose [ [x,y] | x <- [1..3], y <-[4..5]])  ['-']
06:32:03 <lambdabot>  Couldn't match expected type `[[t]]' against inferred type `Char'
06:32:04 <Trin_CZ> subw: looks like it really handles ssl connections ... thanks
06:32:11 <yitz> > [[n..n+n]|n<-[1..5]]
06:32:13 <yitz> > [[n..n+n]|n<-[1..5]]
06:32:14 <lambdabot>  mueval: Time limit exceeded
06:32:15 <yitz> > transpose [[n..n+n]|n<-[1..5]]
06:32:15 <lambdabot>  [[1,2],[2,3,4],[3,4,5,6],[4,5,6,7,8],[5,6,7,8,9,10]]
06:32:18 <lambdabot>  mueval: Time limit exceeded
06:32:21 <yitz> > transpose [[n..n+n]|n<-[1..5]]
06:32:24 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[4,5,6,7],[6,7,8],[8,9],[10]]
06:33:05 <yitz> Here's something unexpected - though it conforms to the report:
06:33:10 <yitz> > [1,1..1]
06:33:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:33:14 <dmead> > intersperse [1..3] [1]
06:33:16 <lambdabot>      No instance for (Num [t])
06:33:16 <lambdabot>       arising from the literal `1' at <interac...
06:33:19 <dmead> what what
06:33:22 <dmead> > intersperse [1..3] 1
06:33:24 <lambdabot>      No instance for (Num [[t]])
06:33:25 <lambdabot>       arising from the literal `1' at <inter...
06:33:25 <yitz> I would expect that to be [1].
06:33:29 <dmead> > intersperse [1..3] [1]
06:33:32 <lambdabot>      No instance for (Num [t])
06:33:32 <lambdabot>       arising from the literal `1' at <interac...
06:33:35 <dmead> nope
06:33:45 <dmead> i wish there was like ?example <func>
06:33:49 <yitz> > intersperse 1 [1..3]
06:33:51 <ejt> > intersperse [1..3] [[1]]
06:33:52 <lambdabot>  mueval: Time limit exceeded
06:33:55 <lambdabot>  mueval: Time limit exceeded
06:33:58 <yitz> > intersperse 1 [1..3]
06:34:00 <dmead> she's pegged
06:34:01 <lambdabot>  [1,1,2,1,3]
06:34:12 <dmead> you got it
06:34:35 <dmead> > intersperse [1] (transpose [ [x,y] | x <- [1..3], y <-[4..5]])
06:34:37 <lambdabot>  [[1,1,2,2,3,3],[1],[4,5,4,5,4,5]]
06:34:41 <dmead> noice
06:34:46 <dmead> wait
06:34:55 <dmead> > map (intersperse [1]) (transpose [ [x,y] | x <- [1..3], y <-[4..5]])
06:34:57 <lambdabot>      No instance for (Enum [t])
06:34:57 <lambdabot>       arising from the arithmetic sequence `1...
06:35:00 <RayNbow> hmm, is there a shorter (pointfree) alternative for "head &&& tail"?
06:35:17 <yitz> @type head &&& tail
06:35:19 <lambdabot> forall a. [a] -> (a, [a])
06:35:43 <dmead> > map (intersperse  [1]) (transpose [ [x,y] | x <- [1..3], y <-[4..5]])
06:35:45 <lambdabot>      No instance for (Enum [t])
06:35:45 <lambdabot>       arising from the arithmetic sequence `1...
06:35:46 <yitz> @pl \x -> (head x, tail x)
06:35:47 <lambdabot> liftM2 (,) head tail
06:35:59 <dmead> how is that not valid..
06:36:02 <trzkril_> > map (intersperse 1) (transpose [ [x,y] | x <- [1..3], y <-[4..5]])
06:36:05 <lambdabot>  [[1,1,1,1,2,1,2,1,3,1,3],[4,1,5,1,4,1,5,1,4,1,5]]
06:36:09 <dmead> ah
06:36:14 <dmead> ty
06:36:20 <dmead> i'm on one hour of sleep
06:36:30 <dmead> and 4 cups of coffee
06:36:38 <RayNbow> yitz: that's longer, not shorter :p
06:36:44 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..5]])
06:36:47 <lambdabot>  [[1,1,1,1,2,1,2,1,3,1,3],[4,1,5,1,4,1,5,1,4,1,5]]
06:36:54 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..10]])
06:36:57 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,...
06:37:04 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..6]])
06:37:07 <lambdabot>  [[1,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,3],[4,1,5,1,6,1,4,1,5,1,6,1,4,1,5,1,6]]
06:37:12 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..7]])
06:37:13 <yitz> @pl \x:xs -> (x, xs)
06:37:13 <lambdabot> liftM2 (,) head tail
06:37:15 <lambdabot>  mueval: Time limit exceeded
06:37:19 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..6]])
06:37:22 <lambdabot>  [[1,1,1,1,1,1,2,1,2,1,2,1,3,1,3,1,3],[4,1,5,1,6,1,4,1,5,1,6,1,4,1,5,1,6]]
06:37:31 <dmead> > map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..7]])
06:37:32 <mmorrow> ivanm:
06:37:34 <mmorrow> data Vector t =
06:37:34 <mmorrow>     V { dim  :: {-# UNPACK #-} !Int               -- ^ number of elements
06:37:34 <mmorrow>       , fptr :: {-# UNPACK #-} !(ForeignPtr t)    -- ^ foreign pointer to the memory block
06:37:34 <mmorrow>       }
06:37:34 <lambdabot>  [[1,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3],[4,1,5,1,6,1,7,1,4,1,5,1,6,...
06:37:54 <PeakerWork> what does tunes have to do with Haskell?
06:37:58 <ivanm> mmorrow: gah!
06:38:10 <ivanm> PeakerWork: I presume you mean the logs in /topic?
06:38:10 * BeelsebobWork_ waits for a beautiful pascal's triangle to appear out of the \bot play
06:38:24 <ivanm> just a generic IRC logging service AFAIK...
06:38:41 <PeakerWork> ivanm: ah
06:38:42 <ivanm> mmorrow: I guess that's why there's no nice way of mapping :(
06:38:52 <mmorrow> compare this to ByteStrings
06:38:53 <mmorrow> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8)
06:38:53 <mmorrow>                      {-# UNPACK #-} !Int                -- offset
06:38:53 <mmorrow>                      {-# UNPACK #-} !Int                -- length
06:39:03 <yitz> RayNbow: what you want is uncons. that's shorter. but it's not a standard function in Haskell.
06:39:03 <dmead> > last (map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..7]])  )
06:39:06 <lambdabot>  [4,1,5,1,6,1,7,1,4,1,5,1,6,1,7,1,4,1,5,1,6,1,7]
06:39:17 <dmead> > last (map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..8]])  )
06:39:20 <lambdabot>  [4,1,5,1,6,1,7,1,8,1,4,1,5,1,6,1,7,1,8,1,4,1,5,1,6,1,7,1,8]
06:40:24 <ivanm> mmorrow: is it like that because 1) hmatrix has to play niceley with lapack, etc. or 2) because there's no efficient haskelly way of doing it?
06:40:27 <mmorrow> ivanm: i guess you could (assuming you don't want to mutate) make a new Vector, then for each i in [0..length-1] peek from one Vector, apply the func, then poke to the other Vector
06:40:52 <ivanm> yeah
06:41:11 <ivanm> mmorrow: though what do you mean by peek/poke? is that what hmatrix actually calls it?
06:41:19 <mmorrow> ivanm: it's so it's really easy to pass a Vector to a C function as (eg assume Vector Double)   (double *vec, int len)
06:41:35 <mmorrow> ivanm: Foreign.Storable
06:41:44 <ivanm> *nod*
06:41:50 <dmead> [ x, y | x <-[1..3] , y <- [7..11]]
06:41:57 <dmead> > [ x, y | x <-[1..3] , y <- [7..11]]
06:41:57 <lambdabot>  Parse error at "|" (column 8)
06:42:03 <ivanm> mmorrow: though would that then be IO stuff?
06:42:08 <dmead> > [ [x, y] | x <-[1..3] , y <- [7..11]]
06:42:11 <mmorrow> ivanm: yeah
06:42:11 <lambdabot>  mueval: Time limit exceeded
06:42:16 <dmead> > [ [x, y] | x <-[1..3] , y <- [7..11]]
06:42:18 <lambdabot>  [[1,7],[1,8],[1,9],[1,10],[1,11],[2,7],[2,8],[2,9],[2,10],[2,11],[3,7],[3,8]...
06:42:23 <dmead> > last [ [x, y] | x <-[1..3] , y <- [7..11]]
06:42:28 <RayNbow> yitz: well, time to propose it as an addition for Haskell Prime's prelude? :p
06:42:29 <lambdabot>  mueval: Time limit exceeded
06:42:31 <lilac> > iterate (\x -> zipWith (+) (0:x) (x++[0])) [1,1]
06:42:31 <dmead> > last [ [x, y] | x <-[1..3] , y <- [7..11]]
06:42:33 <ivanm> mmorrow: :(
06:42:34 <lambdabot>  mueval: Time limit exceeded
06:42:35 <lambdabot>  mueval: Time limit exceeded
06:42:37 <dmead> > last [ [x, y] | x <-[1..3] , y <- [7..11]]
06:42:40 <lambdabot>  [3,11]
06:42:42 <lilac> > iterate (\x -> zipWith (+) (0:x) (x++[0])) [1,1]
06:42:45 <lambdabot>  mueval: Time limit exceeded
06:42:50 <ivanm> hmmm... I can't find how to change an element of a matrix/vector :s
06:42:52 <lilac> > iterate (\x -> zipWith (+) (0:x) (x++[0])) [1,1]
06:42:54 <lambdabot>  [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7...
06:43:06 <mmorrow> ivanm: there're a bunch of calls to unsafePerformIO hidden under varous externally pure functions though to get around this when it's indeed safe to do so
06:43:12 <ivanm> @> will get it out of a vector, but what's its inverse?
06:43:12 <lambdabot> Maybe you meant: . ? @ v
06:43:19 <ivanm> mmorrow: :o
06:43:20 <yitz> RayNbow: I can think of a lot more functions that I would give higher priority than that one.
06:44:10 <yitz> RayNbow: I think the reason it was omitted is that pattern matching makes it unneeded in most situations.
06:44:28 <mmorrow> join :: Storable t => [Vector t] -> Vector t
06:44:33 <mmorrow> join as = unsafePerformIO $ do
06:44:34 <mmorrow>     let tot = sum (map dim as)
06:44:34 <mmorrow>     r@V {fptr = p} <- createVector tot
06:44:34 <mmorrow>     withForeignPtr p $ \ptr ->
06:44:35 <mmorrow> ...
06:44:51 <ivanm> *nod*
06:45:06 <ivanm> mmorrow: how do you change one particular value in an array/vector?
06:47:34 <mmorrow> ivanm: hmm, i only really ever operate on entire vectors, so i'm not sure off the top of my head
06:47:42 <lilac> > map (takeWhile (/= 0)) $ iterate (join $ zipWith (+) . (0:)) (1:repeat 0)
06:47:45 <ivanm> oh...
06:47:45 <lambdabot>  mueval: Time limit exceeded
06:47:46 <Saizan> wouldn't it be easier if opening a file in a non-existant directory would create that directory automatically?
06:48:03 <ivanm> mmorrow: I was kind of hoping I could just treat hmatrix matrices as arrays :(
06:48:11 <dmead> > [1..3]
06:48:13 <lambdabot>  [1,2,3]
06:48:27 <ivanm> dmead: you _really_ needed lambdabot to evaluate that for you? :o
06:48:29 <ivanm> ;-)
06:48:37 <dmead> i'm going to build on it :P
06:48:52 <BeelsebobWork_> > [1..4]
06:48:55 <lambdabot>  [1,2,3,4]
06:49:02 <ivanm> > [0..4]
06:49:05 <lambdabot>  [0,1,2,3,4]
06:49:11 <ejt> map id [1..3]
06:49:14 <dmead> > map show [1..3]
06:49:17 <lambdabot>  mueval: Time limit exceeded
06:49:18 <ivanm> ejt: heh
06:49:19 <mmorrow> ivanm: it's really easy to treat them as /mutable/ arrays :)  just write a function which uses the internal rep and mutably writes a value at some offset into the ForeignPtr
06:49:25 <dmead> > map show [1..3]
06:49:28 <lambdabot>  mueval: Time limit exceeded
06:49:35 <dmead> c'maaaan
06:49:37 <dmead> > map show [1..3]
06:49:39 <ivanm> but... but... but... I didn't _want_ to use IO! :(
06:49:40 <lambdabot>  ["1","2","3"]
06:49:56 <mmorrow> ivanm: of course this is in IO, unless you do unsafePerformIO ...
06:50:13 <ivanm> which isn't safe!
06:50:13 * BeelsebobWork_ chants do unsafePerformIO
06:50:16 <ivanm> ;-)
06:50:16 <mmorrow> and in that case be careful when things actually happen
06:50:18 <mmorrow> yeah
06:50:28 <ivanm> @seen lambdabot
06:50:29 <lambdabot> Yes, I'm here. I'm in #darcs-theory, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #japanese, #not-##freebsd, #haskell_ru, #haskell.se, #haskell.ru, #
06:50:29 <lambdabot> haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #
06:50:29 <lambdabot> haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
06:50:40 <ivanm> dmead: ^^ now do you understand why she's getting slow?
06:50:41 <dmead> how would i arrange lists of different length into a jagged list of lists?
06:50:45 <dmead> indeed
06:50:54 <ivanm> dmead: "jagged"?
06:50:58 <matthew-_> lambdabot needs to learn to delegate
06:51:00 <dmead> yea, as in jagged array
06:51:18 <ivanm> @type sortBy (compare `on` length)
06:51:20 <lambdabot> forall a. [[a]] -> [[a]]
06:51:22 <mapreduce> > [1, 3, 4] : [5, 6] : []
06:51:24 <lambdabot>  [[1,3,4],[5,6]]
06:51:31 <ivanm> still no idea what you mean by a jagged array...
06:51:39 <mapreduce> Is that a jagged array?
06:51:40 <ivanm> Judge Advocate General'd array? :p
06:51:42 <dmead> yea
06:51:45 <dmead> mm
06:51:46 <dmead> hmm
06:52:04 <mapreduce> dmead: Your input to the function would be a list of lists and the output would be a list of lists.
06:52:07 <mapreduce> It's.. identity!
06:52:14 <DrSyzygy> > Left 3 : Right 5 : []
06:52:17 <dmead> not quite
06:52:17 <lambdabot>  [Left 3,Right 5]
06:52:20 <ivanm> > sortBy (compare `on` length) [[1,2],[10..14],[-3]]
06:52:23 <DrSyzygy> > Left 3 : Right "abc" : []
06:52:23 <lambdabot>  [[-3],[1,2],[10,11,12,13,14]]
06:52:24 <mapreduce> > identity [[1,2,3],[4,5]]
06:52:30 <lambdabot>  [Left 3,Right "abc"]
06:52:30 <lambdabot> Terminated
06:52:35 <mapreduce> > id [[1,2,3],[4,5]]
06:52:38 <lambdabot>  [[1,2,3],[4,5]]
06:52:45 <dmead> i've got a bunch of lists that need to go into a table
06:52:51 <dmead> but their of different lengths
06:53:05 <matthew-_> *they're
06:53:09 <mapreduce> The above appears to handle that.
06:53:26 <lilac> dmead: by "table" do you mean [[a]]?
06:53:37 <ivanm> mmorrow: *sigh* maybe hmatrix _isn't_ what I want then :(
06:53:44 <dmead> i mean a csv table
06:53:55 <ivanm> dmead: give us an example
06:54:06 <dmead> k one sec
06:54:12 <ivanm> because you're not making much sense :p
06:54:24 <dmead> i have like 1 or 2 hours sleep
06:54:27 <dmead> :)
06:54:34 <Wild_Cat> CSV lines usually all have the same number of fields. If not, there's something very, very wrong.
06:54:47 <dmead> sure, but they can be empty too
06:54:52 <mapreduce> Wild_Cat: Welcome to my world.
06:55:01 <ivanm> just append extra commas on the end or beginning
06:55:07 <Wild_Cat> dmead: certainly. But an empty field is still a field.
06:55:09 <lilac> dmead: do you want something like f :: Show a => [[a]] -> String; f = concat . intersperse "\n" . map (concat . intersperse "," . map show)
06:55:11 <dmead> yea
06:55:25 <Wild_Cat> as in, ["foo", "bar", "", "", "baz"]
06:55:39 <ivanm> dmead: so you just want some way of padding each string?
06:55:49 <Wild_Cat> BTW, is there a CSV parser somewhere in the Haskell stdlib or on hackage?
06:56:02 <dmead> i want a way of automatically putting in an empty field when one of the lists runs out
06:56:13 <ivanm> Wild_Cat: bytestring-csv ?
06:56:27 <dmead> when you use comprehensionsons or maps, the process always terminates when the end of any of the lists is reached
06:56:38 <mmorrow> ivanm: hmm, if it's updating an array in pure code that you want, it may not be. but hmatrix is really great for a bunch of other things :)
06:56:47 <dmead> i'm trying to think of a way to properly consume a set of lists into a csv that won't terminates when the shortest runs out
06:56:52 <ivanm> dmead: you'd want to 1) find the maximum length of any line, 2) for each line, convert and append padding
06:56:56 <Botje> dmead: given ++ drop (length given) (replicate numFields "")
06:57:14 <ivanm> mmorrow: well, I'm not really doing much numerics...
06:57:16 <Botje> per line
06:57:27 <Botje> then they'll all have the same number of fields (numFields)
06:57:34 <ivanm> mmorrow: http://en.wikipedia.org/wiki/Metropolis_algorithm
06:57:35 <ivanm> ;-)
06:57:35 <lambdabot> Title: Metropolis–Hastings algorithm - Wikipedia, the free encyclopedia
06:57:39 <Botje> bleh
06:57:39 <dmead> ahh
06:57:45 <Botje> too complicated :)
06:57:53 <dmead> thats pretty obvious i guess
06:57:54 <Botje> given ++ replicate (numFields - length given) ""
06:57:56 <dmead> never thought of it
06:58:05 <Botje> it reads just like pseudocode!
06:58:46 <dmead> i suppose the stdlib functions wouldn't keep grabbing from a list when it's reached []
06:58:48 <lilac> > let f :: [[String]] -> [[String]]; f xss = let len = maximum $ map length xss in map (take len . (++ repeat "")) xss in f $ map (map show) [[1,2,3],[4,5],[6]]
06:58:51 <lambdabot>  [["1","2","3"],["4","5",""],["6","",""]]
06:58:58 <dmead> genius
06:58:59 <dmead> xD
06:59:03 <dmead> lilac++
06:59:29 <mmorrow> wow, this image is pretty cool http://upload.wikimedia.org/wikipedia/en/a/a6/3dRosenbrock.png
06:59:45 <mmorrow> (which was on this page http://en.wikipedia.org/wiki/Metropolis_algorithm)
06:59:47 <lambdabot> Title: Metropolis–Hastings algorithm - Wikipedia, the free encyclopedia
06:59:49 <ivanm> mmorrow: yeah, so all I'm wanting to do is fo each cell in the matrix/array, randomly decide whether or not to flip the value in the cell based on its neighbours
07:00:39 <ivanm> I might just go back to using a standard array and mapping over a list of indices rather than mapping over the array directly :s
07:00:55 <matthew-_> mmorrow: needs more flare
07:01:11 <ivanm> but I'll leave hmatrix here for when I need to calculate the complete elliptic integrals ;-)
07:01:12 <mmorrow> matthew-_: haha. indeed.
07:01:47 <mmorrow> ivanm: cool. yeah, an array probably would be best for your current problem.
07:01:47 <ivanm> wow, I installed blas, lapack, gsl and hmatrix just for one formula I could have stolen^W implement based on matlab's code
07:02:24 <mmorrow> well, the bright side is that you never have to touch matlab again!
07:02:28 <ivanm> but hmatrix's inbuilt function to "zip" two matrices/vectors together element wise is nice
07:02:46 <ivanm> mmorrow: heh, I've only been using matlab recently for graphs, and for this semester been hacking together gnuplot bindings instead
07:03:35 <ivanm> unfortunately, whilst the lecturer is letting me use haskell for the assignments (since he has it installed at home, but has no idea how it works by the looks of things :s), for the end of semester practical exam I might have to use matlab because that's what's installed on the machines at uni :(
07:03:39 <mmorrow> ivanm: oh cool. consider hacking on Graphics.Plot in hmatrix. *very* cool things could be done with this module, probably with minimal effort (if you know gnuplot syntax well)
07:04:07 <ivanm> heh, I don't.... I based my code on Graphics.Plot + some other code I found elsewhere
07:04:15 <mmorrow> hah, nice
07:05:12 <ivanm> and I basically add more commands as I need them
07:05:35 <ivanm> what _really_ pisses me off with gnuplot is that I can't have a 3D plot where the ticsizes on all three axes is the same :@
07:05:56 <GremlinHunter> Does anyone know why lambdabot keeps telling me "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8"?
07:06:04 <ivanm> so when I had to "draw" a figure, it didn't look right because of it :@
07:06:15 <ivanm> GremlinHunter: a local install?
07:06:20 <GremlinHunter> Yeah
07:07:00 <ivanm> GremlinHunter: hmmm.... does "ghc-pkg check" say anything?
07:07:12 <ivanm> rebuild any packages recently?
07:07:40 <GremlinHunter> ghc-pkg check doesnt give any output
07:08:03 <GremlinHunter> And I dont know if I rebuilt anything
07:08:30 <ivanm> you haven't upgraded any libraries recently?
07:08:37 <ivanm> when did you install lambdabot?
07:08:40 <ivanm> where from? and how?
07:09:09 <GremlinHunter> I got it from darcs, using darcs get
07:09:35 <GremlinHunter> And it was either today or yesterday I downloaded it
07:09:35 <ivanm> then built it by hand?
07:09:48 <GremlinHunter> I just ran cabal install
07:09:55 <ivanm> how are you running it?
07:10:05 <GremlinHunter> But I had to edit out mueval as a dependency to make it build
07:10:07 <ivanm> you're aware that lambdabot needs read/write access to its build dir?
07:10:30 <GremlinHunter> It should have access
07:10:39 <binrapt> I'm about to get "The Craft of Functional Programming", I think it was recommended to me by several Haskell programmers, do you agree?
07:10:41 <ivanm> *shrug* no idea then
07:10:48 <ivanm> binrapt: I like it
07:11:00 <GremlinHunter> Oh well, I will just ignore it for now :)
07:11:01 <binrapt> I have plenty of experience with C++ but I feel like a child in Haskell
07:11:03 <binrapt> Ok
07:11:03 <ivanm> school of expression isn't bad either
07:11:04 <GremlinHunter> Thanks for the help
07:11:15 <ivanm> binrapt: have you seen the haskell tutorial for C programmers?
07:11:24 <binrapt> Yeah I saw it on Google
07:11:40 <ivanm> k
07:11:58 <ivanm> school of expression isn't bad either, and there's the soon-to-be-released Real World Haskell as well
07:12:02 <binrapt> But I always read at night in bed when my box is turned off so I thought I might get a book
07:12:31 <ivanm> heh, fair enough
07:13:33 <nominolo_> @pl \x -> foo x >> return ()
07:13:34 <lambdabot> (>> return ()) . foo
07:14:36 <nominolo_> @index (>>>)
07:14:37 <lambdabot> Control.Arrow
07:19:14 <desp> Does anyone have an example of using the Text.PrettyPrint module?
07:20:28 <ivanm> desp: the author, hopefully, or else why write it? :p
07:21:58 <mmorrow> desp: http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/src/Language-Haskell-Pretty.html
07:22:00 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5ncr83
07:22:15 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Ppr.html
07:22:17 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5l5tyh
07:22:45 <desp> Yes, well.
07:22:51 <mmorrow> http://hackage.haskell.org/packages/archive/WebBits/0.9.2/doc/html/src/WebBits-JavaScript-PrettyPrint.html
07:22:53 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5j2j6r
07:23:03 <mmorrow> http://hackage.haskell.org/packages/archive/WebBits/0.9.2/doc/html/src/WebBits-Html-PrettyPrint.html
07:23:04 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/62svud
07:23:07 <mmorrow> etc :)
07:23:51 <malcolmw> btw, if anyone else is annoyed by the HTML title "Haskell Code by HsColour", they should know that the latest release of hscolour generates the name of the module instead.
07:24:12 <binrapt> Oh, The Craft of Functional Programming isn't available new on the German Amazon anymore and the delivery would take too long otherwise apparently
07:24:22 <binrapt> But the Haskell School of Expression is still available
07:25:07 <mmorrow> malcolmw: cool.
07:25:18 <mmorrow> > text "asdf"
07:25:21 <lambdabot>  asdf
07:25:24 <mmorrow> yesh!
07:25:45 <mmorrow> @type let ppList f = brackets . vcat . punctuate comma . fmap f in ppList
07:25:47 <lambdabot> forall a. (a -> Doc) -> [a] -> Doc
07:26:12 <mmorrow> > let ppList f = brackets . vcat . punctuate comma . fmap f in render $ ppList int [0..9]
07:26:15 <lambdabot>  "[0,\n 1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9]"
07:26:23 <mmorrow> > error (let ppList f = brackets . vcat . punctuate comma . fmap f in render $ ppList int [0..9])
07:26:25 <lambdabot>  mueval: *** Exception: [0,
07:26:26 <lambdabot>  1,
07:26:26 <lambdabot>  2,
07:26:26 <lambdabot>  3,
07:26:26 <lambdabot>  4,
07:26:28 <lambdabot> [5 @more lines]
07:26:48 <mmorrow> heh, using the secret error method of printing newlines ;)
07:28:34 <ivanm> lol
07:28:44 <ivanm> error [1..5]
07:28:47 <ivanm> > error [1..5]
07:28:50 <lambdabot>      No instance for (Num Char)
07:28:50 <lambdabot>       arising from the literal `1' at <intera...
07:28:59 <ivanm> duh
07:29:14 <ivanm> what's vcat?
07:29:17 <binrapt> How long does it usually take for long time imperative programmers to get used to functional programming?
07:29:17 <ivanm> @type vcat
07:29:19 <lambdabot> [Doc] -> Doc
07:29:21 <mmorrow> > error ("\n" ++ unlines (fmap show [0..9]))
07:29:24 <lambdabot>  mueval: *** Exception:
07:29:24 <lambdabot> 0
07:29:24 <lambdabot> 1
07:29:24 <lambdabot> 2
07:29:24 <lambdabot> 3
07:29:26 <lambdabot> [6 @more lines]
07:29:27 <mmorrow> vertical concatenation
07:29:31 <ivanm> @src vcat
07:29:31 <lambdabot> Source not found. Where did you learn to type?
07:29:37 <ivanm> *nod*
07:29:39 <binrapt> Somebody in here told me it'd probably take me 4+ months before I start seeing results in Haskell
07:29:47 <ivanm> binrapt: depends
07:29:50 <mmorrow> > render (hcat . punctuate comma . fmap int $ [0..9])
07:29:53 <lambdabot>  "0,1,2,3,4,5,6,7,8,9"
07:29:56 <mmorrow> > render (vcat . punctuate comma . fmap int $ [0..9])
07:30:00 <lambdabot>  "0,\n1,\n2,\n3,\n4,\n5,\n6,\n7,\n8,\n9"
07:31:48 <mmorrow> > error ("\n" ++ render (text "A" <+> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}"))
07:31:51 <lambdabot>      precedence parsing error
07:31:51 <lambdabot>         cannot mix `(Control.Arrow.<+>)' [infix...
07:32:43 <mmorrow> > render (text "A" <> text " " <> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}")
07:32:46 <lambdabot>  "A {\n  0,\n  1,\n  2,\n  3\n}"
07:32:55 <mmorrow> > error ("\n" ++ render (text "A" <> text " " <> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}"))
07:32:58 <lambdabot>  mueval: Time limit exceeded
07:33:03 <mmorrow> > error ("\n" ++ render (text "A" <> text " " <> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}"))
07:33:06 <lambdabot>  mueval: Time limit exceeded
07:33:30 <mmorrow> > 1
07:33:33 <lambdabot>  mueval: Time limit exceeded
07:38:31 <mmorrow> malcomw: i just pulled hscolour and installed. do i have to tell it to make the title the module name with a command line flag or something?
07:39:41 <mmorrow> malcomw: ahhhh, nevermind. it just so /happened/ that i was testing it on a file named HsColour.hs :)
07:40:00 <mmorrow> > error ("\n" ++ render (text "A" <> text " " <> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}"))
07:40:04 <lambdabot>  mueval: Time limit exceeded
07:40:06 <mmorrow> gah!
07:44:55 <mmorrow> > error ("\n" ++ render (text "A" <> text " " <> text "{" $+$ nest 2 (vcat . punctuate comma . fmap int $ [0..3]) $+$ text "}"))
07:44:58 <lambdabot>  mueval: Time limit exceeded
07:45:03 <mmorrow> i quit
07:45:59 <Stinger> :t punctuate
07:46:01 <lambdabot> Doc -> [Doc] -> [Doc]
07:47:20 <ejt> @src punctuate
07:47:21 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:51:45 <Peaker> @info Doc
07:51:46 <lambdabot> Doc
07:51:50 <Peaker> @src Doc
07:51:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:53:50 <quicksilver> @index Doc
07:53:51 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
07:53:57 <quicksilver> Peaker: that's what you wanted, I suspect.
07:54:22 <Peaker> thanks, was just wondering
07:56:44 <MarcWeber> http://rafb.net/p/vr7wFv19.html
07:56:46 <lambdabot> Title: Nopaste - Why Context reduction stack overflow; size = 20
07:58:07 <quicksilver> MarcWeber: I don't use undecidable instances, or HList, or type-level programming. Having said all that, I could be wrong, but I don't think that instance declaration makes sense.
07:58:37 <quicksilver> "instance (A a) => B a" means "EVERY type 'a' is a member of B, but add the constraint that..."
08:03:18 <MarcWeber> quicksilver this works.. (?) http://rafb.net/p/wno26w88.html
08:03:20 <lambdabot> Title: Nopaste - No description
08:05:01 <BeelsebobWork_> @hoogle delay
08:05:02 <lambdabot> Control.Arrow.Operations delay :: ArrowCircuit a => b -> a b b
08:05:02 <lambdabot> GHC.Conc registerDelay :: Int -> IO (TVar Bool)
08:05:02 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
08:07:52 <quicksilver> MarcWeber: well that's consistent wiht my theory.
08:08:03 <quicksilver> MarcWeber: the "T"s in there stop it being an instance of the form A a => B a
08:08:43 <MarcWeber> quicksilver: Let me show you the rest of the story: http://rafb.net/p/RVJ9j443.html
08:08:44 <lambdabot> Title: Nopaste - of course the HList instances are defned
08:09:14 <MarcWeber> Those instances are imported as well and should be prefered the second time
08:09:36 <quicksilver> I"m not sure what point you're making.
08:09:40 <quicksilver> Those instances are all fine.
08:09:46 <quicksilver> they're not of the form A a => B a either.
08:11:23 <MarcWeber> quicksilver: sorry, I still don't see it
08:12:24 <quicksilver> "=> HEq a b r" means ALL types "a" and "b" are equal.
08:12:29 <quicksilver> that's not what you want to say :)
08:12:32 <quicksilver> and it leads to a loop.
08:12:36 <lilac> MarcWeber: suppose the type checker wants to determine whether there is an instance of HEq a b r
08:12:44 <quicksilver> (actually it means all types are both equal and unequal
08:12:55 <quicksilver> since "r" can be instantiated as HTrue and also as HFalse)
08:13:20 <quicksilver> note that none of the other instances you gave me was of that form.
08:13:38 <quicksilver> they were of the form "=> HEq (C a) (D b) E
08:13:43 <quicksilver> where C, D and E are all type constructors.
08:13:54 <lilac> MarcWeber: it needs to find elNr and elNr' to match the TypeToNat constraints, then find an instsance of HEq elNr elNr' r. I suspect it's always finding an instance of TypeToNat, so the recursion never terminates
08:13:57 <MarcWeber> Thanks. Got it
08:15:36 <lilac> either that or, due to laziness, it checks the HEq constraint before checking the TypeToNat...
08:16:40 <lilac> MarcWeber: cast in value-level Haskell, you've written hEq a b = hEq (toNat a) (toNat b). should be clear why this doesn't terminate
08:17:12 <MarcWeber> quicksilver: sorry, I was wrong. I still don't get that. lilacs theory is much better because it doesn't have types to match..
08:17:20 <MarcWeber> $dHEq :: {HEq elNr elNr' a}'
08:17:51 <MarcWeber> this should be $dHeq :: {HEq HZero, HZero a}
08:17:56 <MarcWeber> Then it would find an instance.
08:18:07 <MarcWeber> That's why the functional dependencies are given..
08:21:52 <lilac> MarcWeber: but why should it choose to examine that HEq instance first?
08:22:03 <MarcWeber> lilac: Note that the second time these instances should be chosen http://rafb.net/p/RVJ9j443.html which should terminate
08:22:05 <lambdabot> Title: Nopaste - of course the HList instances are defned
08:22:27 <MarcWeber> lilac Because of functional dependencies
08:22:41 <MarcWeber> class TypeToNat a b c | a b -> c
08:22:59 <MarcWeber> class HEq a b c | a b -> c
08:23:00 <lilac> why should it examine the HEq HZero HZero a instance before the HEq a b r instance, though?
08:23:05 <MarcWeber> (sorry, remove b from the first line)
08:23:29 <quicksilver> MarcWeber: well my justification is quite different from lilacs.
08:23:37 <quicksilver> lilac is trying to be precise and operational.
08:23:41 <MarcWeber> lilac: Because it fits the types more accurately. see overlapping instances in the ghc guide
08:23:48 <quicksilver> all I was doing is saying "don't do that" and explaning why the other one was different ;)
08:24:06 <MarcWeber> quicksilver: Then I still haven't understood your explanation
08:24:14 <quicksilver> HEq a b r always matches.
08:24:25 <quicksilver> it matches every possible triple of types a,b,r
08:24:34 <quicksilver> then it always generates a new HEq triple
08:24:39 <quicksilver> which will always match the same rule
08:24:47 <MarcWeber> quicksilver: Wait
08:24:47 <quicksilver> there is no way for this procedure to terminate.
08:27:07 <MarcWeber> HEq a b r always matches.
08:27:23 <lilac> "An instance declaration is ignored during the lookup process if (a) a more specific match is found, and (b) the instance declaration was compiled with -XOverlappingInstances." This tends to suggest it should work...
08:27:35 <MarcWeber> Sure it does. But hte second time Heq elNr elNr' there is a better match wich is prefered for the same reason you'll get ("foo","bar") here
08:27:38 <MarcWeber> http://rafb.net/p/ZLOCFK92.html
08:27:39 <lambdabot> Title: Nopaste - No description
08:29:28 <rwbarton> Why should it try to resolve the constraint TypeToNat a elNr before the constraint HEq elNr elNr' r?
08:30:06 <lilac> rwbarton: that's not the point, i think. when resolving the HEq elNr elNr' r, it should pick HEq HZero HZero r
08:30:25 <lilac> rwbarton: and *that* should happen because it's more specific
08:31:30 <GremlinHunter> Could you use OverlappingInstances to mess with the type system? e.g. use predicatates to determine type and accept any type as input
08:32:32 <MarcWeber> lilac, quicksilver I've asked at #ghc now.
08:32:44 <desp> @hoogle Show
08:32:45 <lambdabot> Prelude class Show a
08:32:45 <lambdabot> Text.Show class Show a
08:32:45 <lambdabot> module Text.Show
08:32:48 <quicksilver> MarcWeber: why is there a better match the second time?
08:32:49 <lilac> GremlinHunter: no, i don't think so, since GHC requires each function to commit to a specific instance. you need IncoherentInstances for that
08:33:01 <lilac> ... and even then it doesn't work the way you want it to
08:33:46 <desp> @hoogle showsPrec
08:33:47 <lambdabot> Prelude showsPrec :: Show a => Int -> a -> ShowS
08:33:47 <lambdabot> Text.Show showsPrec :: Show a => Int -> a -> ShowS
08:33:48 <rwbarton> My theory: To get HEq Id_A Id_A a, it first needs to get TypeToNat Id_A elNr, TypeToNat Id_A elNr', HEq elNr elNr' r
08:33:53 <lilac> GremlinHunter: I assume you mean 'class X a where f :: a -> Bool; instance X Int where f _ = True; instance X a where f _ = False'
08:33:55 <rwbarton> It has to choose one of constraints to process next
08:34:01 <MarcWeber> quicksilver: If ghc was trying to resolve the TypeToNat constraints first it would have known that the result (elNr(')) is either HZero or (Succ a)
08:34:04 <rwbarton> If you weren't using overlapping instances, it would probably never matter.
08:34:06 <desp> Can someone explain what significance does "the operator precedence of the enclosing context (a number from 0 to 11)" have?
08:34:13 <quicksilver> MarcWeber: all you've done is change variables.
08:34:28 <rwbarton> But if it always chooses the HEq ... constraint to resolve next, you'll get exactly that infinite loop the error message shows
08:34:29 <desp> When is showsPrec called?
08:34:31 <quicksilver> MarcWeber: HEq elNr elNr' r is no different from HEq a b r
08:34:35 <GremlinHunter> lilac: Yeah, thats what I had in mind
08:34:43 <quicksilver> MarcWeber: how is that going to find a more specific instance?
08:34:46 <Toxaris> desp: showsPrec is supposed to produce Haskell code
08:34:48 <quicksilver> HEq foo bar baz
08:34:53 <quicksilver> HEq really long variables
08:34:57 <quicksilver> HEq cat dog dish
08:35:00 <quicksilver> they're all the same!
08:35:23 <Toxaris> desp: so it has to use parentheses sometimes if the operator precedence doesn't match the syntax tree
08:35:27 <MarcWeber> quicksilver: *lol* .. continue.. I'm keen on seeing your other foo bar baz really long words.. :-)
08:35:31 <quicksilver> ;)
08:35:44 <quicksilver> MarcWeber: maybe this helps:
08:35:44 <desp> Toxaris: hm.
08:35:57 <MarcWeber> quicksilver: Let me explain you why it should find that instance.
08:36:02 <lilac> GremlinHunter: right, then. suppose i write "g :: a -> Bool; g = f". Without incoherent innstances, this is an error. with incoherent instances, it'll pick the f _ = False instance for all types.
08:36:04 <desp> Toxaris: I wonder why a pretty-printer for another language would be using showsPrec in its Show instance?
08:36:07 <quicksilver> MarcWeber: type instance search never consists of "ooh, TypeToNat a b, I wonder if 'a' might be Id_A"
08:36:08 <MarcWeber> ghc starts with  HEq foo bar baz
08:36:25 <quicksilver> it never checks lists of instances and tries aalternatives.
08:36:43 <lilac> quicksilver: right, so the problem is that GHC doesn't use the actual values of elNr and elNr' when determining the HEq instance?
08:36:47 <MarcWeber> But ghc knows at this point that it is really looking for HEq Id_A Id_A <some type>
08:36:52 <Toxaris> desp: "for another language" means that the Show instance produces concrete syntax for some language different then Haskell=
08:36:54 <GremlinHunter> Thanks for the explanation
08:36:55 <Toxaris> desp: ?
08:36:56 <quicksilver> MarcWeber: how does it know that?
08:37:02 <desp> Toxaris: yes.
08:37:14 <MarcWeber> quicksilver: My example line 20. That's given http://rafb.net/p/vr7wFv19.html
08:37:16 <lambdabot> Title: Nopaste - Why Context reduction stack overflow; size = 20
08:37:23 <Toxaris> desp: sounds like a misuse of Show (yeah, doesn't help to know that)
08:37:27 <quicksilver> MarcWeber: Yes, OK.
08:37:34 <desp> Toxaris: a Show instance producing pretty-printed code for several languages, included as examples for parsec.
08:37:36 <lilac> quicksilver: it *could* know that from the functional dependencies
08:37:40 <quicksilver> MarcWeber: but there aren't any instances of that form.
08:37:41 <desp> Toxaris: aha. ;)
08:37:43 <lilac> quicksilver: but it sounds like it doesn't care.
08:37:44 <MarcWeber> quicksilver: If it was not you were right :)
08:37:47 <quicksilver> MarcWeber: so it uses the general "a b r" one.
08:37:53 <MarcWeber> yes.
08:38:15 <Toxaris> desp: maybe that other language features operator precedence and parentheses too?
08:38:21 <MarcWeber> So it could try the HEq instance first starting which an unkown r type.. (which it actually seems to be doing)..
08:38:30 <quicksilver> lilac: the functional dependencies are irrelevant.
08:38:38 <quicksilver> lilac: (because TypeToNat is irrelevant)
08:38:53 <lilac> quicksilver: yes, but the fact that they're irrelevant is the whole point, isn't it?
08:38:53 <desp> Toxaris: possibly, but I don't understand where the precedence number would come from, when the function is called.
08:38:54 <MarcWeber> Or it could try the TypeToNat a r instance where it knows a and knows that if it knows a it will also know r (because of the functional dep)
08:39:02 <quicksilver> MarcWeber: that's not what it does.
08:39:04 <Toxaris> desp: in that case, the "a number from 0 to 11" doesn't apply, of course, since it is Haskell specific
08:39:09 <lilac> quicksilver: that is, if you can explain why they're irrelevant, you've explained the whole issue
08:39:11 <Toxaris> @src shows
08:39:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:39:27 <quicksilver> lilac: well I can say "That is not what instances are. That is not how they work. That is not what they do." ;)
08:39:28 <Toxaris> desp: I think shows calls showsPrec with a default precedence number
08:39:40 <desp> Ah, and then I can use that for my purposes -- ok.
08:39:45 <desp> Thanks.
08:39:56 <Toxaris> desp: and then showsPrec should call showsPrec recursively (for the children in the AST) with the precedence of the current node as argument
08:40:02 <lilac> quicksilver: but that doesn't explain *why*. i think the why is the same as the incoherent instances thing, actually -- that one instance of HEq is committed to when the instance is written
08:40:16 <lilac> (since otherwise you can break the type system)
08:40:30 <quicksilver> MarcWeber: it has the context (TypeToNat Id_A elNr, TypeToNat Id_A elNr', HEq elNr elNr' a)
08:40:32 <Toxaris> desp: so that the showsPrec of the child knows both its own precedence (hard-coded) and the precedence of its parent (received as argument) and can decide whether to use parentheses or not
08:40:37 <MarcWeber> quicksilver: I don't want to talk about what ghc actually does.. I'd like to talk about what it could do to find the correct solution. And I've told you that
08:40:38 <quicksilver> lilac: no, I think the reason is simpler.
08:40:50 <quicksilver> lilac: the reason is simply this is not how inference works.
08:40:55 <desp> Toxaris: great, thanks for explaining.
08:40:59 <lilac> quicksilver: that's not a satisfying reason
08:41:05 <rwbarton> I wonder whether this error message is a simpler example of functional dependencies not working the way MarcWeber (and I, at first) expected: http://hpaste.org/9956
08:41:06 <quicksilver> lilac: perhaps not.
08:41:29 <lilac> quicksilver: if there is a reason of the form "that would break the type system", i think people would be happier...
08:41:35 <lilac> by people i mean MarcWeber :)
08:41:39 <quicksilver> MarcWeber: anyhow, where I'm going with that context.
08:41:40 <lilac> (and me)
08:41:47 <rwbarton> That code doesn't just fail to define any instances of Test a; it fails to compile at all
08:41:53 <quicksilver> MarcWeber: next it tries to find instances for "HEq elNr elNr' a"
08:42:11 <quicksilver> MarcWeber: and since those three variables are all free
08:42:14 <MarcWeber> rwbarton I'll have a look at it later. I need to follow the conversation now
08:42:16 <quicksilver> it loops.
08:42:28 <quicksilver> the only thing it can do is apply the same rule again.
08:42:41 <rwbarton> quicksilver: What if it first tried to find instances for TypeToNat Id_A elNr?
08:42:46 <quicksilver> pulling in another level pair of TypeToNat constraints and two fresh variables.
08:43:09 <lilac> i guess the thing is, functional dependencies just don't work here
08:43:18 <quicksilver> they don't do what you want here, no.
08:43:28 <lilac> although, they could, couldn't they?
08:43:29 <quicksilver> if you like, "functional dependence are applied after choosing instances"
08:43:37 <quicksilver> lilac: I think not. But I don't claim to know the reason.
08:44:12 <lilac> hmm. perhaps it's just a case of 'no-one's proved it's sound yet'
08:44:58 <quicksilver> it's a different inference system you're proposing.
08:45:09 <quicksilver> I would like to say 'totally different' btu I'm not that sure of my self.
08:45:16 <quicksilver> it's different and I suspect it's totally different ;)
08:45:36 <quicksilver> rwbarton: doesn't look the same to me. That just looks like a flat fundep violation?
08:46:26 <quicksilver> lilac, MarcWeber: I think the key message is this:
08:46:37 <quicksilver> instances are checked.
08:46:41 <quicksilver> they are not searched for.
08:47:04 <rwbarton> quicksilver: By the logic I was using to understand why MarcWeber's example might work, I was also expecting that to just not define any instances of Test
08:47:29 <quicksilver> rwbarton: Yes, that's fair. I see what you mean.
08:47:45 <quicksilver> This boils down to: "A a => B a" means "ALL types are an instance of B"
08:47:52 <quicksilver> the context does not limit the instance.
08:47:58 <quicksilver> the context just adds to the context.
08:49:28 <MarcWeber> quicksilver: Have you understood why I think ghc could find the correct instances?
08:49:43 <lilac> quicksilver: so it says "all types are an instance of B, but it's a compile-time error if you try to use a type that's not an instance of A as a B"?
08:50:16 <lilac> and if so, in what sense are all types an instance of B?
08:50:37 <lilac> certainly it's not the case that all types can be used where a B instance is needed
08:52:10 <quicksilver> MarcWeber: sort of, yes.
08:52:19 <quicksilver> MarcWeber: by using a completely different algorithm which is not the one it uses.
08:52:34 <quicksilver> I'm not familiar with the precise reasons haskell chose the algorithm it did.
08:52:48 <quicksilver> I believe there are inconsistencies with some of the choices.
08:52:54 <quicksilver> lilac: yes.
08:53:11 <quicksilver> lilac: in the sense that the constraint 'matches' for all types.
08:53:17 <MarcWeber> quicksilver Neither am I.. I just thought ghc would just do everything I want it to do because type level programming in haskell is touring complete, isn't it?
08:53:22 <quicksilver> lilac: "B a" becomes irrefutable.
08:53:31 <quicksilver> MarcWeber: no, it's not.
08:53:41 <quicksilver> MarcWeber: not unless you add incoherent and undecidable instances, IIRC.
08:53:54 <quicksilver> lilac: that's what I mean by all types.
08:54:16 <MarcWeber> quicksilver Not sure about that.. Maybe I should just add incoherent instances and try again :)
08:54:22 <quicksilver> lilac: you might phrase this as 'there is no backtracking in class instances'
08:54:30 <MarcWeber> rwbarton That you code fails is obvious:
08:54:53 <quicksilver> lilac: "B a" always matches; once it matches the match chosen is never backtracked to, e.g., look for a different coherent set of instances.
08:54:55 <MarcWeber> class Id a b | a -> b  says if you knew a you can infer the same type b in all cases
08:55:02 <MarcWeber> instance Id True True
08:55:18 <MarcWeber> says: if a is True b must be True as well
08:55:42 <MarcWeber> Then you are using "Id True False" in the instance context
08:56:01 <MarcWeber> But ghc already knows Id True results in b = True as well True doesn't match False here -> failure
08:56:06 <rwbarton> MarcWeber: Right, but that could just mean that the instance Id True False => Test a never applies
08:56:25 <lilac> MarcWeber: yes, but that lookup was done *when ghc saw the 'instance'*, not later as you'd want
08:56:29 <rwbarton> rwbarton: I never tried to actually use it, but I still got a compiler error
08:57:56 <MarcWeber> rwbarton But you can't know that. The instance could be applied in a another module importing that so you must assume that it is applied somewhere..
09:01:54 <Stinger> whats the option to stop ghci printing values again?
09:03:13 <pgavin> Stinger: try -fno-print-evld-with-show
09:03:23 <rwbarton> or -fno-print-bind-result
09:03:24 <pgavin> you can just do :set -fno-print-evld-with-show I think
09:03:36 <rwbarton> (I *just* figured out why googling for that doesn't work...)
09:04:39 <Stinger> well I had the page of flags open and didnt find it searching for "echo" "eval" (cant remember if I tried print and missed it)
09:04:54 <bd_> rwbarton: works with quotes around it :)
09:06:18 <Stinger> yer its not too good when ghci dumps a 200,000 column line to emacs
09:06:22 <Stinger> things get slow
09:09:04 <im_alone> Stinger, the number of spaces required is proportional to the i-th column
09:18:14 <quicksilver> MarcWeber: (re your posting to haskell-cafe) I am sure this is not a bug.
09:18:20 <quicksilver> MarcWeber: it is operating as designed.
09:18:41 <quicksilver> MarcWeber: you are perfectly reasonable to disagree with the algorithm, of course
09:18:49 <quicksilver> but you're proposing a new system rather than reporting a bug.
09:33:52 <MarcWeber> quicksilver: http://rafb.net/p/ZzVMy085.html try this uncommentingc those instances..
09:33:54 <lambdabot> Title: Nopaste - this works ?
09:34:46 <quicksilver> MarcWeber: can't try, I don't have HList installed.
09:34:53 <lilac> MarcWeber: what happens?
09:36:08 <MarcWeber> quicksilver: This example no longer uses HList..
09:36:18 <MarcWeber> I've rewritten /copied the missing parts
09:38:10 <Deewiant> Can "f >>> (>>= g >>> fmap h)" be written more nicely? Mostly I'd like to be rid of the section but remain pointless
09:38:57 <stepcut> :t f >>> (>>= g >>> fmap h)
09:38:59 <lambdabot> forall b a a1 b1 (f :: * -> *). (Monad f, Functor f, SimpleReflect.FromExpr b1, Show a1, SimpleReflect.FromExpr (f a1), Show a, SimpleReflect.FromExpr (f a), Show b) => b -> f b1
09:39:23 <stepcut> hrm
09:39:27 <Deewiant> ?ty \f g h -> f >>> (>>= g >>> fmap h)
09:39:29 <lambdabot> forall b a a1 b1 (f :: * -> *). (Monad f, Functor f) => (b -> f a) -> (a -> f a1) -> (a1 -> b1) -> b -> f b1
09:39:33 <stepcut> :)
09:40:10 <MarcWeber> lilac: It works .. and I'm puzzled because I still don't know why I had trouble in my lib
09:41:01 <Deewiant> stepcut: essentially it's "\a -> do  b <- f a; c <- g b; return (h c)"
09:43:16 <Cale> @type \f g h -> fmap h . (f >=> g)
09:43:18 <lambdabot> forall a b (f :: * -> *) a1 b1. (Monad f, Functor f) => (a1 -> f b1) -> (b1 -> f a) -> (a -> b) -> a1 -> f b
09:43:56 <Deewiant> hooray for >=>
09:43:59 <Deewiant> Cale: thanks
09:44:34 <Cale> np
09:45:45 <stepcut> alternatively, \f g h -> f >=> g >=> return . h
09:46:32 <Deewiant> ">>> fmap " is shorter than ">=> return." ;-)
09:47:09 <stepcut> but not as pretty ;)
09:47:31 <stepcut> you asked for nice, not short :p
09:47:47 <lilac> MarcWeber: I notice you've reordered the constraints in the context for instance HEq a b r
09:48:13 <lilac> MarcWeber: is that alone enough to stop it looping?
09:48:29 <Deewiant> stepcut: I think they're about equally pretty so short wins :-)
09:49:13 <stepcut> Deewiant: I dunno, mixing in Arrows in the middle of a monadic chain ....
09:49:36 <Deewiant> stepcut: don't think of it as Arrows, just flip (.) :-)
09:49:58 <Cale> flip fmap ;)
09:50:00 <stepcut> Deewiant: exactly, to much trickiness to think about
09:50:07 <Saizan> >=> is already a special case of >>>
09:50:18 <stepcut> Saizan: true
09:50:20 <MarcWeber> lilac: Sorry, I'm confused now. I can't no longer compile the example I thought I could before..
09:50:29 <Deewiant> ?ty (.)
09:50:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:50:33 <Deewiant> Cale: I beg to differ :-)
09:50:46 <Cale> I'll fix that once mueval is fixed :)
09:51:10 <lilac> @type \f g h -> (f >>= g >>= return . h) . return
09:51:10 <Cale> (which will happen once the GHC-API is fixed)
09:51:11 <lambdabot> forall a a1 b a2 (m :: * -> *). (Monad m) => (m a2 -> a) -> (a -> m a2 -> a1) -> (a1 -> b) -> a2 -> b
09:52:42 <Deewiant> stepcut: shrug, I just always think of >>> as flip (.) first and Arrows second
09:52:55 <lilac> @type \f g h -> fmap h . join . fmap g . f
09:52:57 <lilac> @type \f g h -> fmap h . (g =<<) . f
09:52:57 <lambdabot> forall b a a1 (f :: * -> *) a2. (Monad f, Functor f) => (a2 -> f a1) -> (a1 -> f a) -> (a -> b) -> a2 -> f b
09:52:59 <lambdabot> forall b a (m :: * -> *) b1 a1. (Monad m, Functor m) => (a1 -> m a) -> (a -> m b1) -> (b1 -> b) -> a1 -> m b
09:58:27 * stepcut is not thrilled about, flip (.) first, either
09:58:36 <stepcut> ?ty flip (.) first
09:58:38 <lambdabot> forall c (a :: * -> * -> *) b c1 d. (Arrow a) => (a (b, d) (c1, d) -> c) -> a b c1 -> c
09:58:46 <Deewiant> :-)
09:58:52 <Deewiant> ?ty (>>> first)
09:58:54 <lambdabot> forall b (a :: * -> * -> *) b1 c d. (Arrow a) => (b -> a b1 c) -> b -> a (b1, d) (c, d)
09:59:04 <Deewiant> hmm
09:59:07 <Deewiant> ?ty (>>>) first
09:59:09 <lambdabot> forall (a :: * -> * -> *) b c d d1. (Arrow a) => (a (b, d) (c, d) -> d1) -> a b c -> d1
09:59:50 <r3m0t> flip (.) first? why not use sections?
10:00:19 <r3m0t> oh right, just scrolled up
10:01:21 <stepcut> this is kind of cute, but I probably wouldn't use it, (h `fmap`) . (g =<<) . f
10:02:23 <r3m0t> :t fmap h . (g =<<) . f
10:02:25 <lambdabot> forall b a (m :: * -> *) b1 a1. (SimpleReflect.FromExpr (m a), Show a1, Monad m, SimpleReflect.FromExpr (m b1), Show a, Functor m, SimpleReflect.FromExpr b, Show b1) => a1 -> m b
10:03:02 <r3m0t> :t (\f g h -> fmap h . (g =<<) . f)
10:03:04 <lambdabot> forall b a (m :: * -> *) b1 a1. (Monad m, Functor m) => (a1 -> m a) -> (a -> m b1) -> (b1 -> b) -> a1 -> m b
10:03:33 <Deewiant> stepcut: I managed to pull that out of @pl earlier and decided it was a bit too opaque
10:08:59 <lilac> it'd be nicer without the Functor constraint.
10:09:10 <lilac> @type \f g h -> (return . h =<<) . (g =<<) . f
10:09:13 <lambdabot> forall b a (m :: * -> *) b1 a1. (Monad m) => (a1 -> m a) -> (a -> m b1) -> (b1 -> b) -> a1 -> m b
10:09:45 <lilac> @pl \f g h -> (return . h =<<) . (g =<<) . f
10:09:46 <lambdabot> (flip ((.) . fmap) .) . flip ((.) . (=<<))
10:14:26 <hansfbaier> dons: There seems to be a race condition in the threaded runtime of Haskell in OpenBSD.....
10:14:47 <cjb> (I don't think dons uses openbsd anymore)
10:14:59 <cjb> (but he might still help you fix it, I guess)
10:15:31 <dons> hansfbaier: huh.
10:15:43 <dons> hansfbaier: if you can narrow it down, simon marlow will be very interested!
10:16:04 <hansfbaier> dons: I just sent you a mail (dons at openbsd dot org)
10:17:43 <hansfbaier> dons: when I use runFastCGI (non-concurrent) and leave out the -threaded option, all is well. But if I use it, I get intermittent Internal Server errors of about every 10 requests or so.
10:18:03 <hansfbaier> dons: Is that mail address still valid?
10:18:22 <hansfbaier> dons: what could I do further do narrow it down?
10:21:20 <bos> @seen dons
10:21:20 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 5m 36s ago.
10:28:59 <dmead> > take 1 []
10:29:02 <lambdabot>  []
10:29:29 <ziman> > take undefined []
10:29:32 <lambdabot>  mueval: Time limit exceeded
10:29:51 <skorpan> > take 5 $ iterate (\x -> x + 1) []
10:29:54 <lambdabot>      No instance for (Num [a])
10:29:54 <lambdabot>       arising from the literal `1' at <interac...
10:29:55 <dmead> :t elem
10:29:57 <skorpan> darn it
10:29:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:30:05 <binrapt> :t Cons
10:30:06 <lambdabot> Keyword
10:30:10 <binrapt> o_o
10:30:20 <FunctorSalad> iterate needs an initial value
10:30:51 <FunctorSalad> er nvm
10:30:56 <FunctorSalad> [] was yours
10:31:18 <skorpan> > take 5 $ iterate (\x -> x + 1) []::[Int]
10:31:21 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
10:31:43 <ziman> [] has type forall a. [a]
10:31:46 <FunctorSalad> > take 5 $ iterate (\x -> x + 1) 3
10:31:49 <lambdabot>  mueval: Time limit exceeded
10:31:54 <ziman> and (+) needs Num a => a
10:32:08 <FunctorSalad> why didn't that work?
10:32:13 <mwc> Text.ParserCombinators.Parsec modules are described as "Parsec compatibility modules" Does this mean those modules are deprecated in favour of Text.Parsec modules?
10:32:39 <ziman> > take 5 $ [3..]
10:32:40 <lilac> mwc: i believe so.
10:32:42 <lambdabot>  [3,4,5,6,7]
10:32:52 <ziman> > iterate (+1) 3
10:32:54 <lilac> mwc: Text.ParserCombinators.Parsec is Parsec2, whereas Text.Parsec is Parsec3
10:32:55 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
10:32:58 <ziman> weird.
10:33:36 <lilac> FunctorSalad: \b is quite heavily loaded
10:33:47 <bos> @seen ketil
10:33:47 <lambdabot> ketil is in #haskell. I don't know when ketil last spoke.
10:34:01 <SamB> lilac: I always forget it stands for backspace and not bell ;-)
10:34:14 <binrapt> where does this "x xs" naming come from?
10:34:23 <dmead> > [] `elem` [[]]
10:34:23 <FunctorSalad> one x, many xs
10:34:24 <binrapt> Does xs have any particular meaning?
10:34:26 <lambdabot>  True
10:34:27 <binrapt> Ok plural
10:34:33 <dmead> it means rest in lisp terms
10:34:34 <EvilTerran> binrapt, yeah, it's just a convention
10:34:41 <dmead> x:xs is a pattern for first and rest
10:35:04 <SamB> dmead: I thought it was called car and cdr
10:35:31 <r3m0t> yes, but xs sometimes means all of the list, not just the tail
10:35:36 <dmead> such things are always fuzzy in the lisp universe
10:36:15 <lilac> SamB: lol :)
10:36:21 <zachk> ok so I am writing the unix command more in haskell, I have a problem though, I read all the Input from stdin get and EOF bool from isEOF and I need to reopen stdin to take more input, how do I do that? that being removing the EOF flag from the stdin handle
10:36:53 <smoofra> so i've been learning about the 'scrap your boilerplate' gernics library, and i'm wonder this:  is there a way to define a type-safe cast that works for *classes* instead of types.  like is there a way to define something of type (forall a. a) such that if a is Num it's 6, but if a is anything else it's undefined?
10:37:16 <SamB> smoofra: no, there isn't
10:37:19 <mwc> lilac: thanks
10:37:32 <r3m0t> smoofra: that would bypass all of the compile-time type checking
10:38:09 <SamB> smoofra: my only regret is that this makes debugging a challange when certain variables have types not constrained to be in Show ...
10:38:27 <mmorrow> @type hWaitForInput
10:38:29 <lambdabot> Not in scope: `hWaitForInput'
10:38:33 <zachk> should i close stdin when i reach EOF and reopen stdin? how would I do that
10:38:43 <zachk> use hWaitForInput?
10:38:45 <mmorrow> ghci> :t hWaitForInput
10:38:45 <mmorrow> hWaitForInput :: Handle -> Int -> IO Bool
10:38:57 <smoofra> SamB: do you know if there's a reason why it can't exist, or is it just somethign nobody has seen fit to implement?
10:39:16 <lilac> zachk: if stdin reaches EOF, there's no more input.
10:39:18 <zachk> types are types in Haskell
10:39:24 <mmorrow> zachk: err, i wouldn't close it
10:39:33 <SamB> smoofra: I can't see a sensible way to extend the typesystem to allow it
10:39:43 <zachk> yes but im doing cat test.txt | more , cat is easy i have that i dont have a working more with pipes though
10:39:50 <mmorrow> zachk: i haven't used hWaitForInput really though, so i just know it exists
10:40:15 <SamB> and even if you could, actually implementing the extension would be nightmarish IMNSHO
10:40:16 <lilac> zachk: ah right, i see.
10:40:21 <zachk> thanks mmorrow ill give that one a whirl
10:40:31 <mmorrow> good luck
10:41:13 <lilac> zachk: you're probably going to need some termina-handling magic
10:43:01 <mmorrow> SamB: this is a great debugging tool: http://hpaste.org/9950
10:43:20 <mmorrow> (especially w/ non Showable types)
10:43:32 <r3m0t> @pl (\f -> (\(p, v) -> (p, f v)))
10:43:32 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
10:44:58 <mmorrow>  <smoofra> like is there a way to define something of type (forall a. a) such that if a is Num it's 6, but if a is anything else it's undefined?
10:45:24 <EvilTerran> maybe with overlapping instances
10:45:38 <dmhouse> That wouldn't have type forall a. a, I don't think.
10:45:49 <dmhouse> The real question is: why?
10:46:04 <EvilTerran> even if there's an "instance SixIfNum (forall a. a) where sixIfNum = undefined"?
10:46:17 <zachk> mmorrow: more <stdin>: hWaitForInput: end of file
10:46:25 <EvilTerran> actually, that wouldn't work at all
10:46:47 <mmorrow> this is exactly how you'd do that:     to :: (Num a) => a -> (forall b. b) = unsafeCoerce      from :: (Num a) => (forall b. b.) -> a = id
10:46:47 <EvilTerran> the instances would have identical heads
10:47:16 <SamB> well, maybe with incoherant instances ?
10:47:20 <binrapt> Hmm can you make custom types show'able?
10:47:25 <SamB> not that it would WORK
10:47:34 <ddarius> binrapt: You just do it.
10:47:40 <dmhouse> binrapt: yes, either write a Show instance, or in most cases deriving (Show) works.
10:47:45 <EvilTerran> SamB, no, the instance heads would still be the same, so it'd not even work with incoherent instances
10:47:50 <EvilTerran> i believe
10:47:53 <dmhouse> E.g. data Foo = Bar Int | Baz String deriving (Eq, Show)
10:48:09 <dmhouse> EvilTerran: wouldn't one of them be forall a. a, and the other forall a. Num a => a?
10:48:12 <mmorrow> zachk: hmm, i know there are peculiarities with pipes and such, but i don't know the details. i do know though that it's definitely possible to do what you want, so someone'll eventually know how :)
10:48:19 <EvilTerran> dmhouse, no, the head would still just be "a"
10:48:23 <smoofra> http://hpaste.org/9958
10:48:31 <dmhouse> EvilTerran: oh, what do you mean by `head'?
10:48:34 <EvilTerran> the class context would be "Num a", but the type inferrer doesn't look at that when choosing instances
10:48:39 <EvilTerran> i mean what the report means :)
10:49:04 <EvilTerran> or the page that describes the overlapping and incoherent instances, at least
10:49:15 <zachk> mmorrow: is there a way to reopen stdin or to getChar directly from keyboard and bypass stdin? i just need to get keypresses
10:49:29 <dmhouse> EvilTerran: I'm suggesting instance SixIfNum (forall a. Num a => a), not instance Num a => SixIfNum a
10:49:51 <EvilTerran> dmhouse, ah. i don't think you can actually have forall.s in instance declerations like that
10:50:11 <mmorrow> smoofra: err, actually to do exactly what you wanted, you have to do    to :: (Num a) => a -> (forall b. b) = unsafeCoerce ,    from :: (forall b. b.) -> a = id     and you risk segfaults if you do something like   from(to 6)::(Tree [Double],((),(),[()]))
10:50:13 <dmhouse> EvilTerran: I doubt you can (but you did! :P)
10:50:15 <EvilTerran> even with -XFlexibleInstances, i think it still has to be a normal type
10:50:19 <dmhouse> Again, the real question is: why?
10:50:22 <EvilTerran> dmhouse, well, yes, but mine still works without it :P
10:50:39 <lilac> zachk: (some research indicates)... open /dev/tty for reading to get the keyboard input
10:50:52 <mmorrow> zachk: hmm. maybe you could read straight from a device file?
10:51:05 * EvilTerran agrees with lilac and mmorrow
10:51:09 <lilac> @hoogle hIsATTY
10:51:09 <lambdabot> No results found
10:51:17 <EvilTerran> (on windows, the device file is called CON instead of /dev/tty)
10:51:20 <lilac> @hoogle tty
10:51:21 <lambdabot> Network.CGI ContentType :: String -> String -> [(String, String)] -> ContentType
10:51:21 <lambdabot> Network.CGI data ContentType
10:51:21 <lambdabot> Network.CGI ctType :: ContentType -> String
10:52:03 <lilac> is there a haskell wrapper for the isatty function?
10:52:12 <EvilTerran> ?hoogle istty
10:52:13 <lambdabot> No results found
10:52:14 <binrapt> data CustomList a = EmptyList | ListAppender a (CustomList a) deriving (Show)
10:52:19 <binrapt> How do I write a show instance for it now?
10:52:26 <EvilTerran> binrapt, er... you don't have to
10:52:27 <dmhouse> binrapt: it's already done.
10:52:29 <EvilTerran> you're deriving it
10:52:34 <mmorrow> smoofra:
10:52:35 <mmorrow> ghci> from (to 6) :: ([a],[a])
10:52:35 <mmorrow> (Segmentation fault
10:52:42 <binrapt> How is it supposed to know how to show it now?
10:52:44 <dmhouse> binrapt: that's what `deriving' means. You can derive a few built-in classes.
10:52:56 <dmhouse> binrapt: try it out!
10:52:59 <zachk> mmorrow: hSetBinaryMode may let me get past the eof im gonna try it
10:53:02 <EvilTerran> binrapt, because it's been programmed to, according to the rules set down in the report
10:53:12 <mmorrow> zachk: interesting, lemme know if it works
10:53:13 <dmhouse> binrapt: it'll do ListAppender 1 (ListAppender 2 (ListAppender 3 EmptyList))
10:53:19 <EvilTerran> binrapt, http://haskell.org/onlinereport/derived.html <- this is how it knows
10:53:21 <lambdabot> Title: The Haskell 98 Report: Derived Instances
10:53:25 <zachk> > "hi"
10:53:28 <lambdabot>  "hi"
10:53:41 <zachk> > "^Z"
10:53:44 <lambdabot>  "^Z"
10:53:46 <dmhouse> binrapt: i.e. convert the constructors to strings, and show the arguments (so you actually get a Show a => Show (ListAppender a) instance.)
10:53:55 <dmhouse> > ""
10:53:57 <lambdabot>      lexical error in string/character literal at character '\SUB'
10:54:10 <zachk> yeah how do i get that in text in haskell dmhouse
10:54:15 <binrapt> So how would I customise the show EmptyList output for example?
10:54:30 <mmorrow> > "\001a"
10:54:30 <dmhouse> zachk: that was a literal, I'm in Emacs, so I just did C-q C-z. But you can use chr.
10:54:32 <lambdabot>  "\SOHa"
10:54:40 <dmhouse> Or that.
10:54:43 <EvilTerran> binrapt, you have to write the instance manually if you want to do that. but you shouldn't.
10:54:44 <mmorrow> > '\001a'
10:54:45 <lambdabot>  Improperly terminated character constant at "'\001..." (column 1)
10:54:45 <dmhouse> > chr 1 : "a"
10:54:48 <lambdabot>  "\SOHa"
10:54:49 <r3m0t> can I make a monad that can only contain Eq objects?
10:54:55 <dmhouse> r3m0t: no.
10:54:55 <mmorrow> > 0x001a
10:54:58 <lambdabot>  26
10:55:00 <zachk> dmhouse: chr is from IO module?
10:55:02 <EvilTerran> binrapt, the Show class has a very specific meaning set down in the repoty
10:55:03 <r3m0t> dmhouse: curses! ...why?
10:55:03 <dmhouse> zachk: nope.
10:55:05 <EvilTerran> *report
10:55:06 <mmorrow> > '\26'
10:55:06 <lilac> zachk: the problem isn't an EOF. the problem is that your stdin isn't the keyboard
10:55:07 <dmhouse> ?hoogle chr
10:55:08 <lambdabot> Data.Char chr :: Int -> Char
10:55:08 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
10:55:08 <lambdabot> Data.ByteString.Internal memchr :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
10:55:09 <lambdabot>  '\SUB'
10:55:15 <EvilTerran> r3m0t, because of the type of "return" and >>=
10:55:18 <EvilTerran> ?type return
10:55:19 <binrapt> EvilTerran well what's the proper way of customising the show output then?
10:55:20 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:55:24 <binrapt> Or are you not supposed to do it at all?
10:55:28 <mmorrow> > '\26023'
10:55:30 <lilac> zachk: so you need to open the keyboard for reading.
10:55:31 <dmhouse> r3m0t: because you'd somehow have to backpatch the types of return and >>= to have Eq constraints.
10:55:31 <EvilTerran> binrapt, you don't. you write your own stringification function.
10:55:32 <lambdabot>  '\26023'
10:55:41 <binrapt> And write your own type -> String functions altogether?
10:55:41 <dmhouse> r3m0t: this is exactly the reason Set isn't a monad.
10:55:42 <binrapt> Ok
10:55:43 <r3m0t> dmhouse: EvilTerran: ok
10:55:47 <zachk> lilac: how to open up the keyboard for reading?
10:55:49 <mmorrow> > maxBound::Char
10:55:52 <lambdabot>  '\1114111'
10:56:01 <EvilTerran> r3m0t, return :: Monad m => a -> m a  -- you'd need to make that (Monad m, Eq a) => a -> m a
10:56:03 <lilac> zachk: 'less' does this by opening 'con' for reading in windows, and opening '/dev/tty' for reading elsewhere
10:56:08 <EvilTerran> r3m0t, however, there is a crazy hack to do it
10:56:29 <r3m0t> could I... not export return and make my own return?
10:56:36 <lilac> zachk: (actually, it's a little more involved; for certain compilers it opens 'CONIN$' in windows
10:56:38 <r3m0t> although it wouldn't work for other monads
10:56:41 <EvilTerran> r3m0t, that's the crazy hack
10:56:51 <dmhouse> r3m0t: sure, but it'd have no relationship to the original return (unless you use the GHC extension)
10:56:53 <EvilTerran> you also need an extension so the de-sugaring does what you want
10:56:57 <r3m0t> OK, I'll go without
10:57:01 <EvilTerran> for >>=, i mean
10:57:05 <mmorrow> zachk: are you on a unix?
10:57:08 <zachk> lilac: is is con or CONIN$ for ghc
10:57:11 <zachk> no windows
10:57:12 <dmhouse> There's a GHC extension which allows the do-block notation to desugar to whichever return and >>= is in scope, rather than the standard ones.
10:57:27 <r3m0t> the function to remove values from the monad can have an (Eq b) restriction, so it comes to the same thing
10:57:33 <mmorrow> zachk: oh, that'll be hellish :(
10:57:39 <stepcut`> -fno-implicit-prelude
10:57:48 <EvilTerran> -XNoImplicitPrelude, please
10:58:04 <dmhouse> {-# LANGUAGE NoImplicitPrelude #-}, please.
10:58:05 <zachk> so easy to do on unix and hellish on windows, wow this makes my love for windows grow
10:58:17 <stepcut`> EvilTerran: oops, showing my age ;)
10:58:23 <lilac> zachk: i'd try CON first. CONIN$ appears to cause problems (security descriptors need setting, etc)
10:58:39 <mmorrow> zachk: this dump my raw mouse input to my terminal: $ sudo cat /dev/input/mouse1
10:58:44 <mmorrow> *dumps
10:59:14 <zachk> mmorrow: yea i have done stuff like that in linux before
10:59:30 <Myoma> hi
10:59:58 <mmorrow> zachk: i wouldn't even know where to start in windows
11:00:55 <zachk> con<-openFile "con" ReadMode seems to work fine in ghci
11:00:59 <mmorrow> zachk: oh, heh just saw your comment about loving windows
11:01:10 <dmhouse> ?ask Cale why mbot's gone from #math
11:01:11 <lambdabot> Consider it noted.
11:01:26 <r3m0t> mmorrow: Windows: write a user-mode mouse driver, sign it, and install it? ;-)
11:01:46 <mmorrow> r3m0t: yay for windows!
11:02:00 <SamB> why do you want the raw input anyway?
11:02:21 <SamB> and isn't there a way to just directly communicate with the USB device from userspace?
11:04:47 <binrapt> What's the Haskell equivalent of a ? b : c
11:04:47 <r3m0t> when I type "return 5", why does it return 5? (what Monad is it working in?)
11:04:56 <r3m0t> binrapt: if a then b else c
11:05:01 <Myoma> binrapt: there isn't one
11:05:05 <binrapt> Oh that's a function?
11:05:06 <binrapt> oh
11:05:08 <lilac> r3m0t: reader monad
11:05:16 <lilac> r3m0t: return  =  const
11:05:20 <mmorrow> r3m0t: where are you typing this?
11:05:27 <r3m0t> mmorrow: ghci
11:05:30 <Myoma> @ let (?) = (,) in a ? b : c
11:05:33 <mmorrow> you're always in an IO do block in ghci
11:05:38 <EvilTerran> r3m0t, here's an example of a restricted monad: http://hpaste.org/9959
11:05:38 <Myoma> > let (?) = (,) in a ? b : c
11:05:40 <lilac> ^^ or that :)
11:05:41 <lambdabot>  Couldn't match expected type `[(Expr, Expr)]'
11:05:52 <Myoma> > let (?) = (*) in a ? b : c
11:05:55 <lambdabot>  mueval: Time limit exceeded
11:06:12 <Myoma> > let {(?) = (*) ; infixr ? 10} in a ? b : c
11:06:12 <lambdabot>  Parse error at "10}" (column 27)
11:06:23 <Myoma> I think it's possible
11:06:32 <r3m0t> Haskell doesn't do mixfix
11:07:19 <EvilTerran> Myoma, i think the usual form is "True ? x = Just x; False ? x = Nothing; Just x ! _ = x; Nothing ! y = y"
11:07:34 <EvilTerran> then, with appropriate fixity declerations, you can write "p ? x ! y"
11:07:43 <EvilTerran> but the operators are also useful on their own
11:08:46 <lilac> > let (?) = flip (!!) . (1-) . fromEnum; infixr 1 ? in True ? 42 : 23                    :[]
11:08:47 <ddarius> binrapt: if-then-else is an expression just like everything else.
11:08:49 <lambdabot>  42
11:08:50 <lilac> > let (?) = flip (!!) . (1-) . fromEnum; infixr 1 ? in False ? 42 : 23                    :[]
11:08:53 <lambdabot>  23
11:08:56 <dmhouse> > let (?) True = fst; (?) _ = snd in 10 > 4 ? ("foo!", "bar.") -- this is also popular
11:08:59 <lambdabot>      No instance for (Num [Char])
11:08:59 <lambdabot>       arising from the literal `10' at <int...
11:09:09 <zachk> hooray it works now; thank you mmorrow and lilac
11:09:13 <EvilTerran> lilac, good lord, that's arcane
11:09:14 <mmorrow> smoofra: ok, just saw your paste. Typeable only can do monomorphic types.
11:09:19 <mmorrow> smoofra: :(
11:09:28 <mmorrow> zachk: awesome. how'd you do it?
11:09:32 <binrapt> Ah of course it returns a value hmm
11:09:42 <EvilTerran> lilac, surely it's better to take something other than (:) for the second operator?
11:09:46 * EvilTerran used !, above
11:10:05 <dmhouse> > let (?) True = fst; (?) _ = snd in (10 > 4) ? ("foo!", "bar.") -- you could obviously fix the fixities in a proper module.
11:10:08 <lambdabot>  "foo!"
11:10:28 <ddarius> dmhouse: You can declare fixities locally.
11:10:32 <binrapt> IfElse :: Bool -> a -> a -> a
11:10:34 <zachk> mmorrow: con<-openFile "con" ReadMode; then i just passed con all over the place I know I should have used a read monad but monads still frighten me slightly
11:10:35 <binrapt> Why is that wrong?
11:10:47 <binrapt> Invalid signature
11:10:53 <Myoma> binrapt: 'I'
11:10:57 <mmorrow> zachk: nice
11:11:00 <binrapt> Oh.
11:11:20 <dmhouse> ddarius: oh?
11:11:30 <zachk> is there an infinite precision numeric library for haskell?
11:11:36 <lilac> > let True <?> a = Just a; False <?> _ = Nothing; Just a <:> b = a; Nothing <:> b = b   in   True <?> 1 <:> 2
11:11:39 <lambdabot>  1
11:11:43 <lilac> EvilTerran: ^^ my favourite
11:12:04 <EvilTerran> lilac, yeah, that looks good, although it may confuse people expecting it to be related to Applicative
11:12:13 <EvilTerran> as <$> <*> <|> are
11:12:25 <EvilTerran> and Parsec already uses <?>, too
11:12:32 <ddarius> > let infixl ++ 9; (++) = (*) in 2 ++ 3 + 5 ++ 6
11:12:33 <lambdabot>  Parse error at "9;" (column 15)
11:12:39 <ddarius> > let infixl 9 ++; (++) = (*) in 2 ++ 3 + 5 ++ 6
11:12:41 <r3m0t> @hoogle (a -> Bool) -> [a] -> ([a], [a])
11:12:42 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:12:42 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
11:12:42 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
11:12:42 <lambdabot>  mueval: Time limit exceeded
11:12:43 <lilac> the above actually would work for any monad (except that the monad is sadly ambiguous)
11:12:47 <dmhouse> zachk: integers? Or non-integers?
11:12:58 <ddarius> > let infixl 9 ++; (++) = (*) in 2 ++ 3 + 5 ++ 6
11:12:59 <dmhouse> zachk: Integer does for the former (it's in Prelude!), check hackage for the second.
11:13:00 <lambdabot>  36
11:13:01 <Myoma> :t partitian
11:13:02 <Myoma> :t partition
11:13:02 <lambdabot> Not in scope: `partitian'
11:13:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:13:10 <ddarius> > 2 * (3+5) * 6
11:13:13 <lambdabot>  mueval: Time limit exceeded
11:13:13 <dmhouse> ddarius: oh coolness.
11:13:16 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in go
11:13:16 <r3m0t> Myoma: thanks
11:13:17 <lambdabot> forall a a1. (a -> (a1, a)) -> a -> [a1]
11:13:27 * EvilTerran is inclined to call them something like -?- and -:-
11:13:50 <twanvl> > let (?) True = fst; (?) _ = snd  in  True ? (1,2)
11:13:52 <lambdabot>  1
11:14:05 <EvilTerran> ?type \p x -> if p then pure x else empty
11:14:07 <lambdabot> forall a (f :: * -> *). (Alternative f) => Bool -> a -> f a
11:14:09 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in concatMap (go::(a->(a,a))->a->[a]))
11:14:11 <lambdabot> parse error on input `)'
11:14:17 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in concatMap (go::(a->(a,a))->a->[a])
11:14:19 <lambdabot>     Couldn't match expected type `[b]' against inferred type `a -> [a]'
11:14:19 <lambdabot>       Expected type: (a -> (a, a)) -> [b]
11:14:19 <lambdabot>       Inferred type: (a -> (a, a)) -> a -> [a]
11:14:42 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in \f -> concatMap (go f::a->[a])
11:14:44 <lambdabot>     Inferred type is less polymorphic than expected
11:14:44 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
11:14:44 <lambdabot>         f :: a -> (a, a) (bound at <interactive>:1:44)
11:15:00 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in (concatMap .) . go
11:15:02 <lambdabot>     Couldn't match expected type `a -> [b]'
11:15:02 <lambdabot>            against inferred type `[a1]'
11:15:02 <lambdabot>     Probable cause: `go' is applied to too many arguments
11:15:15 <EvilTerran> lilac, i'd be inclined to make the (?)-alike general to MonadPlus/Alternative, but the (:)-alike just for Maybe
11:15:26 <EvilTerran> i think that'd be the best of both worlds
11:15:43 <lilac> sounds good
11:15:57 <lilac> @type when
11:15:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:16:00 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in ((concatMap .) .) . go
11:16:02 <lambdabot>     Couldn't match expected type `a1 -> a -> [b]'
11:16:02 <EvilTerran> also, there's no easy way of generalising the (:)-alike that i can see
11:16:02 <lambdabot>            against inferred type `[a2]'
11:16:02 <lambdabot>     Probable cause: `go' is applied to too many arguments
11:16:17 <EvilTerran> well, it'd be general to, er, comonads, i guess?
11:16:24 <EvilTerran> seeing as you need to extract a value
11:16:32 <lilac> erk true
11:16:43 <EvilTerran> well, copointed functors. or something.
11:17:08 <laz0r> hi #haskell, is there an easy way to run some shellcommand, and retrieve its output?
11:17:08 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in \f xs -> concatMap (go f) xs
11:17:10 <lambdabot> forall a b. (a -> (b, a)) -> [a] -> [b]
11:17:19 <mmorrow> @pl \f xs -> concatMap (go f) xs
11:17:20 <lambdabot> (=<<) . go
11:17:23 <mmorrow> heh
11:18:34 <EvilTerran> (class Functor f => Pointed f where { point :: a -> f a; forall f. fmap f . point = point . f }; class Functor f => Copointed f where { copoint :: f a -> a; forall f. copoint . fmap f = f . copoint })
11:18:43 <Myoma> :t flip . flip . flip
11:18:45 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:18:59 <Myoma> :t flip . uncurry . flip . curry . flip
11:19:01 <lambdabot> forall a b a1 c. (a1 -> (a, b) -> c) -> a1 -> (b, a) -> c
11:19:02 <EvilTerran> (i know that forall notation isn't real haskell, but it's a nice way of stating the unenforcable axioms)
11:19:06 <EvilTerran> ?type flip flip flip flip flip
11:19:08 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
11:19:10 <yitz> zachk: http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Real_and_rational_numbers
11:19:12 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
11:19:32 <Myoma> :t flip . curry . flip uncurry . flip .
11:19:33 <lambdabot> parse error (possibly incorrect indentation)
11:19:37 <Myoma> :t flip . curry . flip uncurry . flip
11:19:39 <lambdabot>     Couldn't match expected type `(a, b)'
11:19:39 <lambdabot>            against inferred type `b1 -> a1 -> c'
11:19:39 <lambdabot>     Probable cause: `flip' is applied to too few arguments
11:19:39 <EvilTerran> laz0r, i think it'll be in System.Process or something
11:20:11 <EvilTerran> ?hoogle runInteractiveProcess
11:20:12 <lilac> laz0r: http://cgi.cse.unsw.edu.au/~dons/blog/2007/03
11:20:12 <lambdabot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
11:20:14 <lambdabot> Title: Haskell hacking
11:20:21 <binrapt> @src tail
11:20:21 <lambdabot> tail (_:xs) = xs
11:20:22 <lambdabot> tail []     = undefined
11:20:24 <EvilTerran> ^ laz0r, that's what you want
11:20:39 <lilac> @type Process.run
11:20:41 <lambdabot> Couldn't find qualified module.
11:20:50 <mmorrow> @type let go f = uncurry(:) . fmap (go f) . f in go next (mkStdGen 0) :: [Int]
11:20:52 <lambdabot> [Int]
11:20:56 <mmorrow> > let go f = uncurry(:) . fmap (go f) . f in go next (mkStdGen 0) :: [Int]
11:20:59 <lambdabot>  [2147482884,2092764894,1390461064,715295839,79337801,347273588,1427314282,18...
11:21:01 <Myoma> :t (head&&&tail)
11:21:02 <lambdabot> forall a. [a] -> (a, [a])
11:21:12 <Myoma> :t (uncurry(:)) . (head&&&tail)
11:21:13 <lambdabot> forall a. [a] -> [a]
11:21:21 <lilac> laz0r: that blog post has a link here: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs  ... which you might find helpful
11:21:23 <binrapt> Is it considered better style to use _ when you don't use the argument you might aswell have specified with the name "unused" or whatever?
11:21:30 <Myoma> binrapt: no
11:21:36 <EvilTerran> Myoma, NB: partial
11:21:46 <Myoma> @src map
11:21:46 <lambdabot> map _ []     = []
11:21:46 <lambdabot> map f (x:xs) = f x : map f xs
11:21:55 <EvilTerran> binrapt, yes, _ is good style
11:21:59 <Myoma> you could write map f [] = [] there it would be fine
11:22:00 <binrapt> Is there any difference between using _ and blahblah in this case?
11:22:00 <dmhouse> binrapt: I always use _ if I'm ignoring an argument. It's what it's there fore.
11:22:02 <dmhouse> *for
11:22:07 <binrapt> It matches everything, right? Hm
11:22:08 <binrapt> Ok
11:22:09 <EvilTerran> binrapt, saves people hunting through the function body wondering if you used it
11:22:13 <dmhouse> binrapt: if blahblah is free on the RHS, no difference.
11:22:14 <EvilTerran> (where it = the parameter)
11:22:14 <binrapt> Yeah I try to do the same
11:22:18 <Myoma> yoo _ _
11:22:21 <laz0r> oh, that blog post looks promising, thanks lilac
11:22:21 <EvilTerran> binrapt, don't give things meaningless names, use _
11:22:22 <Myoma> is different to
11:22:24 <Myoma> yoo x x
11:22:25 <lilac> binrapt: it avoids a warning to use _
11:22:33 <EvilTerran> laz0r, did you see my suggestion?
11:22:38 <binrapt> Oh I never got a warning for that in ghc so far
11:22:44 <lilac> binrapt: you need to turn it on
11:22:53 <Myoma> or leave it off
11:23:00 <binrapt> Oh is that some configuration setting?
11:23:03 <binrapt> A permanent one?
11:23:06 <binrapt> For ghci or so?
11:23:25 <EvilTerran> binrapt, but, if you've got a meaningful name, it's ok to use that instead of _
11:23:29 <mmorrow> > let go f = uncurry(:) . fmap (go f) . f in (=<<) . go (head&&&tail) $ replicate 3 [0..3]
11:23:32 <lambdabot>  Couldn't match expected type `a -> m b'
11:23:40 <binrapt> I assume the same happens when you use a named default case in a case of statement instead of using _ if you have it tuned on
11:23:54 <binrapt> If you don't use it
11:24:10 <laz0r> EvilTerran: now i did
11:24:13 <EvilTerran> binrapt, i've also seen people having a descriptive parameter name starting with an _ for parameters they're not using in that particular pattern
11:24:52 <EvilTerran> laz0r, you can use runInteractiveCommand with waitForProcess if you don't want to use it interactively
11:25:02 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
11:25:04 <lambdabot> Title: System.Process, http://tinyurl.com/2uqkc5
11:25:31 <laz0r> EvilTerran: i guess i can use the handles returned by reunInteractiveCommand to read the output of the command i ran
11:25:52 <bjrn> How do I force Haskell to evaluate an expression only once, and save the result for later use?
11:26:06 <laz0r> looking at the example from dons blog, which lilac gave me, it seems so to me
11:26:26 <EvilTerran> laz0r, indeed, the haddock i just pasted a link to says which handle is which
11:26:32 <EvilTerran> binrapt, "Underscore, "_", is treated as a lower-case letter, and can occur wherever a lower-case letter can. However, "_" all by itself is a reserved identifier, used as wild card in patterns. Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore. This allows programmers to use "_foo" for a parameter that they expect to be unused."
11:26:40 <EvilTerran> ^ that's what it says in the report
11:26:55 <Botje> hmm
11:27:03 <binrapt> Ah ok
11:27:05 <EvilTerran> bjrn, give it a name
11:27:06 <laz0r> ok, thanks, guys, thats all i need to get running with my little shellscript i want to write
11:27:17 <lilac> bjrn: let x = <something> in ... use x multiple times ...
11:27:25 <EvilTerran> bjrn, as long as that name remains in scope, any use of that name will not involve recalculation
11:27:34 <bjrn> Ah, nice. Thanks.
11:28:03 <EvilTerran> although using the same expression not via that name will still involve recalculation, of course
11:28:30 <Beelsebob> also, there are somethings that look like that that will *not* save the computation
11:28:42 <mmorrow> @type foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[])
11:28:44 <lambdabot> forall a. [[a]] -> [[a]]
11:28:52 * EvilTerran mutters under his breath about the monomorphism restriction
11:28:58 <mmorrow> foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[]) $ replicate 3 [0..4]
11:29:02 <mmorrow> > foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[]) $ replicate 3 [0..4]
11:29:05 <lambdabot>  mueval: Time limit exceeded
11:29:10 <mmorrow> > foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[]) $ replicate 3 [0..4]
11:29:13 <lambdabot>  [[0,0,0],[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
11:29:32 <EvilTerran> > map (replicate 3) [0..4]
11:29:35 <lambdabot>  [[0,0,0],[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
11:29:37 <EvilTerran> ?
11:29:38 <mmorrow> heh
11:29:59 <mmorrow> i think that's less general
11:30:00 <lilac> basically, haskell doesn't make any guarantees about what gets recomputed. but ghc will generally not recompute something which you've named, so long as it remains in scope. it also generally won't cache things unless you name them (to avoid space leaks).
11:30:20 <EvilTerran> mmorrow, yes, but it's also more readable. YAGNI.
11:30:52 <lilac> there are probably many exceptions to both of these pseudo-rules.
11:31:25 <Deewiant> ?ty foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[])
11:31:26 <mmorrow> > foldr (zipWith (++)) (repeat[]) . (fmap . fmap) (:[]) $ take 10 . zipWith drop [0..] . fmap cycle . replicate 3 $ [0..3]
11:31:28 <lambdabot> forall a. [[a]] -> [[a]]
11:31:29 <lambdabot>  mueval: Time limit exceeded
11:31:47 <EvilTerran> http://c2.com/xp/YouArentGonnaNeedIt.html
11:31:48 <lambdabot> Title: You Arent Gonna Need It
11:32:12 <EvilTerran> "you shouldn't overengineer something based on what you think you might need later on" :P
11:32:23 <dcoutts_> @seen audreyt
11:32:23 <lambdabot> audreyt is in #xmonad, #perl6, #haskell and #ghc. I don't know when audreyt last spoke.
11:32:31 <dcoutts_> @tell audreyt I added support to cabal-install for local repos and I added a global command line param to specify a config file. I've not added the env var, but don't take that to mean I'm fundamentally opposed to the idea. This is all in the 0.5.2 release.
11:32:32 <lambdabot> Consider it noted.
11:33:12 <mmorrow> EvilTerran: what makes you think i work with lists of numbers all the time?? ;)
11:33:29 <mmorrow> @type replicate
11:33:31 <lambdabot> forall a. Int -> a -> [a]
11:33:34 <dmead> > intersperse 1 [1..3]
11:33:36 <mmorrow> in partic Ints
11:33:37 <lambdabot>  mueval: Time limit exceeded
11:33:43 <dmead> > intersperse [1] [1..3]
11:33:46 <lambdabot>      No instance for (Enum [t])
11:33:46 <lambdabot>       arising from the arithmetic sequence `1...
11:34:04 <Saizan> ?tell Cale pull gwern's timeout patch to lambdabot when you can, please :)
11:34:04 <lambdabot> Consider it noted.
11:34:06 <dmead> > last (map (intersperse  1) (transpose [ [x,y] | x <- [1..3], y <-[4..8]])  )
11:34:10 <lambdabot>  mueval: Time limit exceeded
11:34:26 <EvilTerran> mmorrow, well, what are you trying to do?
11:34:46 <dmead> > intersperse  1 [1..10]
11:34:46 <EvilTerran> mmorrow, if you're gonna use lambdabot in public, you've gotta expect us to try to be useful :P
11:34:49 <lambdabot>  [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10]
11:34:54 <dmead> yea seriously
11:34:59 <mmorrow> EvilTerran: i'm just kidding around :)
11:35:35 <EvilTerran> we've got to get revenge for all the channel noise somehow, and looming at your shoulder like a demonic shop assistant strikes me as an appropriate tactic >:D
11:35:50 <mmorrow> EvilTerran: heh, fair enough
11:36:24 <monochrom> mmorrow: how may I help you? would you like to buy more haskell books?
11:36:43 <Myoma> hi monochrom :)
11:36:52 <mmorrow> monochrom: do you sell them in groups of 112358??
11:37:09 <EvilTerran> we sell them in finite simple groups of order two - will that do?
11:37:36 * monochrom wonders what the identity book is.
11:37:43 <mmorrow> errrrummm fine, but only grudgingly
11:37:51 <dmead> > "\""
11:37:54 <lambdabot>  "\""
11:38:04 <dmead> how do you put quotes in a string?
11:38:10 <dmead> without the \ showing
11:38:12 <EvilTerran> monochrom, well, how does one apply a book to another book?
11:38:13 <mmorrow> monochrom: probably a clear slipcover
11:38:14 <Myoma> dmead: that is it
11:38:16 <EvilTerran> dmead, er, like that
11:38:19 <monochrom> putStrLn "\""  does wonder
11:38:22 <Myoma> > var "\""
11:38:24 <lambdabot>      Ambiguous occurrence `var'
11:38:24 <dmead> ah
11:38:24 <lambdabot>     It could refer to either `Data.Number.Sym...
11:38:26 <Myoma> > var "\"" :: Expr
11:38:29 <lambdabot>      Ambiguous occurrence `var'
11:38:29 <lambdabot>     It could refer to either `Data.Number.Sym...
11:38:35 <Myoma> > fun "\"" :: Expr
11:38:37 <dmead> > putStrLn "\""
11:38:38 <lambdabot>  "
11:38:40 <EvilTerran> @read "this string contains \"bunny ears\""
11:38:40 <dmead> kool
11:38:40 <lambdabot>  this string contains "bunny ears"
11:38:41 <lambdabot>  mueval: *** Exception: "<IO ()>"
11:38:49 <monochrom> print is different from putStrLn
11:39:19 <EvilTerran> dmead, at the ghci prompt, anything that has an IO type gets run, and anything else gets wrapped in "print" and *then* run
11:39:43 <dmead> ah
11:39:44 <EvilTerran> dmead, and it's print that's putting all those '\'s in, as it uses show
11:39:48 <EvilTerran> ?src print
11:39:48 <lambdabot> print x = putStrLn (show x)
11:39:59 <dmead> gotcha
11:39:59 <EvilTerran> so putting putStrLn in yourself is enough to stop that happening :)
11:40:01 <mmorrow> > show (show 42)
11:40:05 <lambdabot>  mueval: Time limit exceeded
11:40:10 <mmorrow> > show (show 42)
11:40:13 <lambdabot>  "\"42\""
11:40:15 <EvilTerran> it's really quite a clever approach, IMO
11:40:22 <monochrom> > readFile "/etc/passwd"  {- you saw it coming, no? :) -}
11:40:23 <mmorrow> > (show . show) 42
11:40:25 <lambdabot>  mueval: Time limit exceeded
11:40:26 <lambdabot>  "\"42\""
11:40:27 <_Tom> does the haskell language do socket connections? what kind of programming is haskell really good for?
11:40:34 <monochrom> Hrm!
11:40:42 <monochrom> > readFile "/dev/null"  {- you saw it coming, no? :) -}
11:40:46 <lambdabot>  mueval: Time limit exceeded
11:41:15 <mmorrow> _Tom: the computer kind!
11:41:20 <zachk> http://hpaste.org/9960
11:41:36 <zachk> more in haskell
11:41:38 <_Tom> heh heh hehe... thanks, bad question
11:41:42 <monochrom> Funny time-limit-exceeded
11:41:55 <EvilTerran> ?faq does the haskell language do socket connections?
11:41:56 <lambdabot> The answer is: Yes! Haskell can do that.
11:41:57 <mmorrow> _Tom: ok, just seeing if you were trolling
11:42:16 <Jedai> _Tom: Pretty much anything ^^
11:42:16 <EvilTerran> _Tom, by virtue of the foreign function interface, haskell can do everything C can
11:42:19 <mmorrow> _Tom: sure, sockets are pretty easy
11:42:37 <monochrom> Haskell is good for very well-organized programming.
11:42:43 <EvilTerran> _Tom, and we've even got nicer APIs for lots of things than the C folks do - including sockets
11:42:51 <_Tom> fantastic, that answers my questions perfectly! Appreciate it!
11:42:54 <zachk> _tom: google haskell irc bot tutorial  good tutorial shows basic sockets and some simple monads
11:43:08 <Myoma> @quote
11:43:08 <lambdabot> swix says: seriously though, this thing is too concise, it's scary, given what it does
11:43:26 <r3m0t> > iterate (p*) q
11:43:30 <lambdabot>  mueval: Time limit exceeded
11:44:27 * EvilTerran wonders if swix was talking about that impossibly terse "powerset" implementation
11:44:29 <Deewiant> > iterate (p*) q
11:44:32 <lambdabot>  [q,p * q,p * (p * q),p * (p * (p * q)),p * (p * (p * (p * q))),p * (p * (p *...
11:44:43 <EvilTerran> > filterM (const [False, True]) [1,2,3] -- this one
11:44:46 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
11:45:13 <mmorrow> Tom_: here's a simple multithreaded echo server http://code.haskell.org/~morrow/code/haskell/misc/echod.hs.html
11:45:14 <lambdabot> Title: Haskell Code by HsColour
11:45:57 <_Tom> very cool, haskell on linux? or just windows and mac, I can tseem to find stuff for linux... though I just started, maybe I'll get lucky
11:46:11 <BMeph> EvilTerran: You call that "impossibly terse"? :)
11:46:45 <BMeph> EvilTerran: That's not even all that terse by Haskellian standerds. :)
11:46:52 <mmorrow> _Tom: i never touch windows unless i'm threatened with pain :)
11:46:56 <zachk> _Tom: haskell runs on everything, though there are quite a few Cabal packages that require unix to work right
11:46:58 <BMeph> Er, *standards
11:47:25 <_Tom> I just found ubuntu packages!
11:47:28 <_Tom> sweet
11:47:38 <mmorrow> _Tom: nice
11:48:00 <zachk> _Tom: use ghci for starters and I like vim as my editor, if you like emacs there is even better support for emacs
11:48:29 <binrapt> @src foldl
11:48:29 <lambdabot> foldl f z []     = z
11:48:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:48:33 <Myoma> How do you invert a fold?
11:48:57 <BONUS> :t unfold
11:48:59 <lambdabot> Not in scope: `unfold'
11:49:09 <BONUS> what the heck lambdabutt
11:49:28 <mmorrow> :t unfoldr
11:49:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:49:34 <BONUS> ah it's unfoldr
11:49:39 <BONUS> oh yeah
11:49:40 <Myoma> fold'exp var const bin (Var s) = var s
11:49:40 <Myoma> fold'exp var const bin (Const i) = const i
11:49:40 <Myoma> fold'exp var const bin (Bin o l r) = bin o (fold'exp var const bin l) (fold'exp var const bin r)
11:49:42 <Myoma> is my fold
11:49:50 <zachk> _tom: vim helloworld.hs ;<type in helloworld program> ;<ESC>:wq! ; ghc --make helloworld ; <if no errors> helloworld and you are off to the races, well you might need to chmod +x helloworld under linux im not sure though
11:50:16 <dmhouse> What's the list difference operator again?
11:50:21 <dmhouse> ?hoogle (\\)
11:50:21 <mmorrow> (\\)
11:50:21 <lambdabot> Data.IntMap \\ :: IntMap a -> IntMap b -> IntMap a
11:50:22 <lambdabot> Data.IntSet \\ :: IntSet -> IntSet -> IntSet
11:50:22 <lambdabot> Data.List \\ :: Eq a => [a] -> [a] -> [a]
11:50:25 <dmhouse> That one, thanks dmhouse.
11:50:33 <mmorrow> heh
11:53:47 <Myoma> can't be done?
11:54:07 <bd_> zachk: compilers (including ghc) will generally +x the final output
11:55:08 <Myoma> http://hpaste.org/9962
11:55:08 <_Tom> zachk: wow thanks, I just started linux a few weeks back, now I sorta have a vafue idea on how to use vim (which is  a great improvement)
11:55:35 <bd_> _Tom: vimtutor has a nice basic tutorial
11:55:37 <Myoma> just wondering if pp can be inverted? :p
11:55:44 <bd_> :t pp
11:55:44 <Myoma> to write a parser
11:55:45 <lambdabot> Not in scope: `pp'
11:55:49 <bd_> Myoma: what's pp?
11:55:53 <Myoma> http://hpaste.org/9962
11:56:19 <mmorrow> _Tom: sweet! stick with it.
11:56:24 <Cale> Myoma: You could write a parser, perhaps?
11:56:25 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:56:49 <Myoma> Yes
11:57:27 <sbahra> pp
11:57:47 <Myoma> I want to do it in such a way that I know the parse . pp = id
11:58:12 <Myoma> except I don't know how :/
11:58:39 <ddarius> Myoma: Yes.
11:58:54 <Myoma> what is the method?
11:58:55 <zachk> oh man found a bug in my more program, if the lines the more reads are long then the linecounter gets out of whack
11:59:01 <ddarius> @google A functional derivation of LR parsers
11:59:02 <bd_> Myoma: you could quickcheck it
11:59:04 <mmorrow> Myoma: that's looks cool. hmm, maybe (sticking to your minimalist theme) explicitly recursively with a stack or two?
11:59:07 <lambdabot> http://portal.acm.org/citation.cfm?doid=349214.349219
11:59:08 <lambdabot> Title: Generation of LR parsers by partial evaluation
11:59:31 <ddarius> http://www.informatik.uni-bonn.de/~ralf/publications/TypedLR.pdf
11:59:38 <lambdabot> Title: Derivation of a Typed Functional LR Parser
12:00:11 <Cale> Learn about Parsec maybe? :)
12:00:56 <mmorrow> Myoma: i found this to be a really good exercise in parsing http://hpaste.org/9897 (and it seems somewhat similar to you problem)
12:01:06 <mmorrow> s/you/your/
12:02:30 <Myoma> hm
12:02:39 <Myoma> data T a = Tip a | T [T a]
12:02:44 <Myoma> what's the fold on that?
12:02:48 <mmorrow> i love that data structure
12:03:02 <Myoma> :: (a -> z) -> ([t] -> z) -> T a -> z ?
12:03:04 <mmorrow> i'll get my fav ...
12:03:04 <Cale> Linking dist/build/lambdabot/lambdabot ...
12:03:05 <Cale> cabal: Error: some packages failed to install:
12:03:05 <Cale> lambdabot-4.2 failed during the building phase. The exception was:
12:03:05 <Cale> exit: ExitFailure 9
12:03:07 <Myoma> oops
12:03:11 <Myoma> :: (a -> z) -> ([T a] -> z) -> T a -> z ?
12:03:18 <Cale> hmm
12:03:20 <ddarius> T a = z
12:03:26 <dcoutts> Cale: that's interesting
12:03:36 <ddarius> (a -> z) -> ([z] -> z)
12:03:41 <ddarius> -> T a -> z
12:03:45 <Cale> dcoutts: indeed :)
12:03:54 <mmorrow> fold :: T a -> [a]
12:03:54 <mmorrow> fold= flip go (:[])
12:03:54 <mmorrow>   where go :: T a -> (a -> [a]) -> [a]
12:03:54 <mmorrow>         go (Tip a) k = k a
12:03:55 <mmorrow>         go (T t t') k = go t (: go t' k)
12:04:08 <mmorrow> err, that's for   T a = Tip a | Tip (T a) (T a)
12:04:41 <mmorrow> but analogously
12:05:11 <Cale> dcoutts: any ideas about what could cause that?
12:05:24 <mmorrow> Myoma: err, actually i don't think that's what you were after ...
12:05:27 * mmorrow thinks
12:06:47 <ddarius> > foldT tip t (Tip a) = tip a; foldT tip t (T ts) = t (map (foldT tip t) ts)
12:06:57 <Myoma> fold't (const "") (\m -> concat (["<"]++m++[">"])) test
12:06:57 <Myoma> "<<><>>"
12:07:05 <mmorrow> niceness
12:08:55 <haskellian> anyone here that knows python? is Numeric the older version of Numpy?
12:09:20 <ddarius> Why don't you ask on a python channel?
12:09:23 <mapreduce> There's quite a nice #python here.
12:09:24 <Cale> Myoma: Hehe, you're using that funny single-quote naming style :)
12:09:37 <mapreduce> Though they have a funny idea of "strong typing".
12:09:55 <mmorrow> Myoma, ddarius: i'm particularly fond of this zipish thing http://hpaste.org/9963
12:09:59 <Cale> Oh, wonderful, now it seems that installing anything with cabal-install fails with ExitFailure 9...
12:10:00 <Cale> hmm
12:10:01 <ddarius> let isLower'c' = True in (isLower'c', isLower 'c')
12:10:21 * Cale considers blowing away his user-installed packages and starting over...
12:10:21 <ketil> @seen bos
12:10:25 <dcoutts> Cale: so is it ld that's failing ?
12:10:32 <Twinside> hey, is anyone know where to report a bug for the OpenGL binding?
12:10:44 * ketil listens to the crickets for a while, then returns to his mail.
12:11:19 <tristes_tigres> Hello
12:11:23 <Myoma> wow
12:12:18 <Cale> dcoutts: hmm... one sec and I'll let you know. There is a binary sitting here in dist, and I did a clean before the build...
12:12:56 <Cale> (at least I'm fairly sure the script does a clean -- I'm just deleting the binary and rebuilding to see if it gets made)
12:13:35 <Cale> I have a feeling that the error occurs after the link succeeds.
12:15:55 <Cale> yeah
12:16:02 <Cale> It builds lambdabot just fine...
12:16:24 <Cale> but then... fails mysteriously
12:18:13 <Myoma> data Token = LPar | RPar | S String | I Integer | O String
12:19:53 * Cale blows away .ghc and .cabal and just reinstalls things... this should fix it :)
12:20:50 <Myoma> data Token = ∑ † Tc ¯ c
12:21:01 <Myoma> Where did I go wrong ? :p
12:22:37 <monochrom> Who is Tc?
12:22:59 <mapreduce> My brother.
12:23:20 * Myoma can't find it
12:23:32 <Cale> What are you looking for?
12:23:37 <Myoma> I think it's a haskell version of 'c'
12:24:10 <Myoma> ah it's one of {+,*,(,),id}
12:27:07 <Myoma> there is no general method to invert folds though?
12:27:46 <Cale> Myoma: foldr (+) 0
12:27:52 <Cale> How would you invert that? :)
12:28:15 <mc__> foldr (-) 0
12:29:00 <Cale> I suppose that if the functions you're replacing the constructors with are bijective, and you have the inverses, then it should be doable.
12:29:56 <monochrom> There is a general method to invert folds but you have to accept unbounded nondeterminism.
12:30:00 * Cale wonders why cabal-install'ing haskell-src-exts complains because happy is not installed, but doesn't bother to just install happy.
12:30:23 <dcoutts> Cale: because we do not track build-tools as a dependency yet
12:30:26 <newsham> cale: there are many ways to unfold  foldr (+) 0
12:30:33 <dcoutts> Cale: only build-depends at the moment.
12:30:48 <Cale> ah, okay
12:30:56 <Cale> newsham: That was my point :)
12:31:46 <monochrom> Some belief systems lump "no solution" and "too many solutions" together into one thing.
12:32:14 <newsham> "no solution" -> "no unique solution"
12:32:20 <Cale> Well, if you say 'invert' you mean 'find an inverse'
12:32:38 <Cale> f is an inverse function for g if both g . f and f . g are the identity.
12:32:56 <Cale> grr!
12:33:14 <mmorrow> newsham: sometimes the uniqueness is up to some isomorphism
12:33:19 <Cale> Installing mueval after blowing away .cabal and .ghc ended up running into the very same build problem!
12:33:32 <Cale> mueval-0.6.4 failed during the building phase. The exception was:
12:33:32 <Cale> exit: ExitFailure 9
12:33:41 <newsham> [20,3] \in inverse (foldr (+) [20,3])
12:34:03 <mmorrow> newsham: i guess a better way to put it is, you need to define equality for uniqueness to have a meaning
12:34:31 <newsham> morrow: dont you need to define equality to define what inverse means?
12:34:35 <dcoutts> Cale: run with -v3 and see what the last command run was
12:34:50 <gwern> Cale: wow, what an informative error message :)
12:34:50 <dcoutts> Cale: hopefully exit code 9 is not the result of signal 9, ie SIGKILL
12:35:29 <Myoma> foldr (\x ys -> 10*ys + x) 0
12:35:41 <monochrom> mmorrow . newsham = newsham . mmorrow = id
12:35:41 <mmorrow> newsham: i'm talking about defining some equiv relation on the set of unfoldings of _
12:35:43 <Myoma> monochrom: I am ok with nondeterminism :)
12:36:07 <Myoma> > foldr (\x ys -> 10*ys + x) 0 $ [3,5,7,4,6]
12:36:29 <Myoma> > foldr (\x ys -> 10*ys + x) 0 $ [3,5,7,4,6]
12:36:31 <Myoma> :/
12:36:39 <Cale> dcoutts: hmm, the last command, if I'm reading this correctly, is /usr/lib/gcc/x86_64-linux-gnu/4.2.4/collect2 with a huge number of commandline parameters
12:36:48 <Cale> /usr/local/bin/ghc returned ExitFailure 9
12:36:49 <haskellian> what is a good free alternative to matlab?
12:36:55 <unenough> octave
12:37:03 <mmorrow> newsham: and as long as it satisfies the axioms of an equiv relation, then when you say "the" unique unfolding, you're really refering to an equivalence class of unfolding determined by the equiv relation
12:37:12 <dcoutts> Cale: so it could be a hardware problem
12:37:23 <Cale> lispy!!
12:37:35 <dcoutts> Cale: ld is pretty hard on memory, I'd run a ram checker
12:37:56 <unenough> haskellian, i've used octave for some matlab stuff. the compatibility is not perfect but it worked for me (just doing some FFT's and convolutions)
12:37:59 <newsham> mmorrow: are you talking about unique inverses or the uniqueness of the output of the inverse?
12:38:12 <newsham> cause i think we're talking about diff things
12:38:31 <Cale> Ah!
12:38:41 <dmhouse> ?botsnack
12:38:42 <mmorrow> newsham: oh, maybe we're not on the same page
12:38:44 <Cale> That's the problem... too many things running.
12:38:45 <mmorrow> <newsham> cale: there are many ways to unfold  foldr (+) 0
12:38:48 <lambdabot> :)
12:38:48 <mmorrow> <newsham> "no solution" -> "no unique solution"
12:38:53 <dmhouse> Huzzah.
12:39:12 <dmhouse> Cale: what did happen to mbot, then?
12:39:12 <newsham> mmorrow: i meant that fold is many-to-one, so the inverse would be one-to-many
12:39:19 <newsham> and there is no one-to-one solution
12:39:22 <Cale> dmhouse: I run mbot on request.
12:39:25 <newsham> anyway, this argument is way past gone :)
12:39:30 <Cale> dmhouse: Would you like me to bring it up?
12:40:10 <mmorrow> newsham: ah, i read something else into that then :)
12:40:17 <dmhouse> Cale: not right now. There's been a couple of times when I thought it would have been useful in the last week or so. I thought it ran constantly.
12:40:55 <Cale> dmhouse: Well, it runs constantly from the time I bring it up until something happens to it :)
12:41:05 <dmhouse> Hehe, okay.
12:41:38 <Myoma> > foldr (\x ys -> 10*ys + x) 0 $ [3,5,7,4,6]
12:41:40 <lambdabot>  64753
12:42:11 <Cale> Myoma: ah, you also need a way to tell when you've reached the end, of course :)
12:42:47 <Myoma> > unfoldr (\n -> case n of 0 -> Nothing ; zs -> let (ys,x) = divMod zs 10 in Just (x, ys)) $ 64753
12:42:49 <lambdabot>  [3,5,7,4,6]
12:43:07 <Myoma> "(\x ys -> 10*ys + x)" must be inverted
12:43:15 <Cale> Of course, that's not really invertible.
12:43:17 <Myoma> "0" must not appear at any times except the end
12:43:39 <Myoma> I think it's injective in at least one direction?
12:43:47 <Cale> No, the problem is more about numbers which are not in [0..9]
12:44:10 <Myoma> ok but that can be assumed or enforced (by the type system)
12:44:22 <Cale> > foldr (\x ys -> 10*ys + x) 0 $ [3,5,7,4,6,0,0,0,0]
12:44:24 <lambdabot>  64753
12:44:30 <Cale> I suppose that's a problem as well.
12:45:02 <newsham> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
12:45:05 <lambdabot> Defined.
12:45:08 <newsham> ?let swap (a,b) = (b,a)
12:45:09 <lambdabot> Defined.
12:45:19 <Cale> (sorry)
12:45:32 <newsham> > unfoldUntil (== 0) (swap . (`divMod` 5)) 64753
12:45:34 <Cale> Just trying to build lambdabot, and I need more memory :)
12:45:48 <Cale> (apparently)
12:46:06 <|Steve|> :t guard
12:46:12 <dons> http://www.reddit.com/r/programming/comments/6ybq6/an_introduction_to_sdl_graphics_with_haskell/
12:46:51 <newsham> guard :: MonadPlus m => Bool -> m ()
12:47:11 <newsham> guard True      =  return ()
12:47:12 <newsham> guard False     =  mzero
12:47:16 <Cale> Don't you just love blog layouts that cut off almost every line?
12:47:26 <dmhouse> Yeah!
12:47:27 <Toxaris> yep, totally unreadable
12:47:30 <Beelsebob> dons: something that would be useful in that is the trickery needed to get that to compile on either OS X or windows
12:48:23 <dons> mm
12:48:40 <Cale> All because some silly person wanted a column layout.
12:49:10 <dons> sigh.
12:49:21 <dons> didn't spot that when viewing in w3m.
12:49:40 <dons> since it actually renders correctly
12:49:54 <dons> turn off the page style.
12:50:02 <Beelsebob> dons: another rendering thing -- the text between the passages of code is comming out in teletype (at least in safari)
12:50:11 <Cale> yep, that's better
12:50:14 <dons> view it without the bogus style.
12:50:19 <Cale> Why do they even bother?
12:50:23 <dmhouse> dons: woah, you can actually use w3m for day-to-day browsing?
12:50:29 <dons> yup.
12:50:38 <dons> for rss feed-generated links, anyway.
12:50:49 <dons> no clickety click
12:50:59 <dmhouse> I've just got into conkeror.
12:51:09 <dmhouse> It's still pretty alpha, but it shows real promise.
12:51:14 <dmhouse> (I'm actually hacking on it right now.)
12:51:41 <Cale> It's like "Hmm... without any CSS, this is way too readable. I think I'll decrease the text contrast a bit and add a column that cuts half the text off altogether... ahh... that's better.
12:52:04 <dmhouse> Not to mention decrease the font size to nigh-unreadable levels.
12:52:17 <Cale> Indeed.
12:52:51 <lispy> Cale: the ram is fine, I've run ram checkers quite a bit last time I rebuilt the server.  But maybe you're running out of ram.
12:52:58 <GremlinH`> Just like software gets fatter as hardware gets faster, usability drops as new web standards are introduced.
12:53:02 <lispy> Cale: you do restart lambdabot daily right?
12:53:18 <Cale> lispy: there appear to be some defunct lambdabot processes...
12:53:24 <lispy> heh
12:53:28 <lispy> Cale: you want me to kill them?
12:53:40 <Cale> If you will :)
12:54:24 <lispy> Cale: they killed themselves it seems
12:54:32 <Cale> hmm
12:54:59 * Cale tries again
12:55:26 <gwern> Cale: any idea where we're leaking memory in lb?
12:55:47 <Cale> gwern: I have no idea. Dropping the log module seems to have helped somewhat, I think.
12:56:11 <mmorrow> this fixes it too
12:56:12 <Cale> But I still end up with defunct processes and occasionally runaway copies of mueval.
12:56:13 <mmorrow> javascript: alert(document.getElementById("main-wrapper").style.width="80%")
12:56:25 <gwern> hm. maybe we should look into profiling
12:57:05 <mmorrow> how ironic that that blog talks about clipping rectangles
12:57:06 * Beelsebob proposes an @sluts \bot plugin, which works like a slot machine, only generates 3 random STDs for you to line up
12:57:50 <gwern> runaway copies of mueval? that shouldn;t be happening
12:58:07 <Cale> http://xkcd.com/ hehe
12:58:17 <dmhouse> Yeah, it was pretty good today.
12:58:24 <Cale> gwern: There was a problem with  error (fix id)  I think...
12:58:43 <dmhouse> Any ideas what the tooltip references, though?
12:58:53 <olsner> set theory fetishes <3
12:59:44 <gwern> Cale: that's cuz you didn't upgrade mueval
12:59:53 <gwern> Cale: error fix id immediately aborts now
13:00:08 <Cale> hmm... now I get:
13:00:10 <Cale> lambdabot-4.2 failed during the final install step. The exception was:
13:00:10 <Cale> State/seen: copyFile: does not exist (No such file or directory)
13:00:16 <Cale> perhaps I should just create it.
13:01:14 <Cale> But of course, it will cause problems when it exists and lambdabot starts with an empty seen file :)
13:01:21 <gwern> now you've destroyed seen as well as fact?
13:01:25 <Cale> hm?
13:01:31 <Cale> seen destroys itself
13:01:35 <gwern> WHY WON'T YOU LEAVE BRITNEY ALONE
13:01:38 <Cale> The state in the seen module is broken.
13:01:42 <gwern> *State/*
13:02:34 <Cale> The script that I use to run lambdabot specifically deletes the empty State/seen file that lambdabot creates every time it is run, so that the @seen plugin actually works while lambdabot is running at least.
13:03:07 <olsner> wow, that sounds horribly broken
13:03:28 <Cale> Yep :)
13:04:34 <olsner> and here I thought you were the one who built most of \bot - why haven't you fixed this yet? :P
13:04:47 <Cale> I did not.
13:04:59 <Cale> I simply run lambdabot. I didn't write it.
13:05:07 <lispy> Cale:  /msg me if you need anything, I'm not paying attenton to #haskell
13:05:08 <dmhouse> dons still claims to be the maintainer on his web page.
13:05:13 <dmhouse> Blame! Blame!
13:05:31 * olsner passes the Big Bowl of Blame onwards
13:05:45 <gwern> lambdabot is an abandoned child; Cale is the orphanage director
13:06:12 * gwern supposes that makes me the sinister doctor who occasionaly visits, with askance eye
13:06:17 <SamB> unfortunately the orphanage itself is bordering on nonexistant?
13:06:19 <olsner> well, then he's at least partially responsible for her errant ways I suppose
13:06:29 <dons> dmhouse: hmm
13:06:33 <dons> i will update the page.
13:06:42 <SamB> dons: what will it now claim?
13:06:56 <dons> dmhouse: where does that say?
13:06:58 <Cale> I am the lambdabot patch-acceptor.
13:07:04 <Cale> hehe
13:07:06 <Toxaris> lambdabot is forced to working in various IRC channels by a cruel orphanage director
13:07:12 <Beelsebob> but you don't get emails from me Cale :(
13:07:17 <Beelsebob> I gave up trying to get a patch to you
13:07:25 <olsner> Cale: sounds suspiciously like what a 'maintainer' does
13:07:34 <gwern> lambdabot> please sir, may I have some more?
13:07:40 <gwern> cale> No! evaluate more expressions!
13:07:51 <dmhouse> dons: http://www.cse.unsw.edu.au/~dons/code.html
13:07:53 <gwern> cale> never before has a bot dared ask for more!
13:08:06 <SamB> olsner: hmm, except most maintainers are more like patch-rejectors or patch-ignorers ;-P
13:08:12 <dons> ah
13:08:17 <olsner> SamB: heh, true that
13:09:05 <Toxaris> as a rule of thumb *.au/~dons/* is outdated
13:09:13 <SamB> @bot
13:09:22 <SamB> @bots
13:09:26 <SamB> @botsn
13:09:38 <SamB> @botsnack
13:09:45 <SamB> hmm
13:09:48 <dmhouse> I'm pretty sure she's not hungry.
13:10:02 <dons> Toxaris: hmm, sort of.
13:10:09 <Cale> oh, wonderful...
13:10:13 <dons> contact is up to date, index.html is up to date, blog is up to date.
13:10:23 <dons> code.html is now redirected to an up to date place.
13:10:32 <Cale> ahaha
13:11:01 <Cale> Now with recent patches, lambdabot won't run without a State/seen, and of course, if run *with* a State/seen, it is broken.
13:11:08 <Myoma> @let list'inv nil uncons ((== nil) -> True) = [] ; list'inv nil uncons (uncons -> (xs,e)) = e : list'inv nil uncons xs
13:11:18 <dons> Cale, reject more patches.
13:11:43 <SamB> Cale: yes, if you reject more patches, you too can be a lambdabot maintainer ;-P
13:11:49 <Cale> That would involve reading the patches.
13:12:07 <Cale> I just accept them, and if they work, run lambdabot again.
13:12:08 <dons> hmm
13:12:12 <dons> ah well
13:12:24 <pozic>  error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
13:12:33 <dons> out of date system?
13:12:33 <Cale> pozic: Install libgmp
13:12:41 <EvilTerran> Myoma, i would be inclined to use a predicate instead of (==nil)
13:12:49 <dons> or you updated ghc which was linked against a newer or older libgmp than the one you have
13:12:55 <olsner> you could at least make sure to reject patches that stop lambdabot from working :P
13:13:12 <pozic> This happens when I run a binary compiled on i386 Linux on another Linux x64-86 machine.
13:13:26 <pozic> Cale: I have that library installed.
13:13:29 <Myoma> list nil cons              [] = nil
13:13:29 <Myoma> list'inv nil uncons ((== nil) -> True) = []
13:13:35 <Myoma> list nil cons            (x:xs) = cons x (list nil cons xs)
13:13:35 <Myoma> list'inv nil uncons (uncons -> (xs,e)) = e : list'inv nil uncons xs
13:13:39 <SamB> Cale: you should run lambdabot three times instead of just once before accepting a patch ;-P
13:13:43 <Cale> pozic: look in /usr/lib for that file?
13:13:44 <Myoma> that is pretty clear ?
13:13:48 <pozic> Cale: the file is there
13:13:54 <Myoma> will this generalize though
13:14:00 <EvilTerran> Myoma, well, list seems to be foldr
13:14:02 <Cale> pozic: hmm
13:14:20 <EvilTerran> list'inv looks like an application of unfoldr
13:14:21 <pozic> Cale: libgmp.so.3: symbolic link to `libgmp.so.3.4.2'
13:14:26 <Cale> pozic: sudo ldconfig ?
13:14:26 <SamB> pozic: what about the i386 version ?
13:14:27 <GremlinH`> pozic: Dont you need a 32 bit version of the library
13:14:32 <skorpan> :t main
13:14:36 <skorpan> > :t main
13:14:47 <Cale> skorpan: bot isn't running
13:14:53 <skorpan> oh
13:14:57 <EvilTerran> skorpan, lambdabot's evaluation thing doesn't have a "main" anyway, AFAIK
13:15:00 <EvilTerran> but it'll be IO ()
13:15:01 <Cale> skorpan: main :: IO a  and you define it yourself
13:15:08 <EvilTerran> ... or is it IO a?
13:15:19 <Cale> It's IO t for any specific type t.
13:15:29 <pozic> SamB: I also have that one.
13:15:33 <Cale> So I guess it's  exists t. IO t  ;)
13:15:51 <pozic> Cale: done
13:15:55 <pozic> Cale: no change.
13:15:57 <Saizan> interpreter :: forall a. IO a -> Magic
13:16:08 <Cale> pozic: hmm, I don't really know.
13:16:08 <mmorrow> Myoma: SAPLish
13:16:08 <SamB> pozic: .3 and all?
13:16:09 <EvilTerran> "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t"
13:16:13 <pozic> SamB: yes
13:16:17 <EvilTerran> ^ so sayeth the report
13:16:20 <SamB> pozic: in the right path?
13:16:20 <Myoma> what is SAPL?
13:16:32 <pozic> SamB: possibly no
13:16:38 <gwern> hm. what does it mean to have a main :: IO String?
13:16:45 <Cale> gwern: The String is ignored.
13:16:53 <SamB> Cale: does the report say that?
13:16:53 <EvilTerran> gwern, AFAIK the final value is ignored
13:16:56 <olsner> Cale: so, you have write access to the lambdabot darcs repository on code.haskell.org, and occasionally push patches you receive from other people?
13:16:56 <mmorrow> Myoma: http://www.st.cs.ru.nl/papers/2006/janj2006-TFP06-EfficientInterpretation.pdf
13:17:05 <SamB> I don't believe that GHC implements that ...
13:17:13 <Cale> olsner: yeah
13:17:20 <gwern> interesting. that seems kind of arbitrary. would it be so hard to say main must :: IO ()?
13:17:21 <mmorrow> Myoma: http://www.st.cs.ru.nl/papers/2005/janj2005-PatternMatchingByFunctionsIFL05.pdf
13:17:23 <EvilTerran> SamB, i'd say it's implied by the type being (exists a. IO a) - you can't do anything with the return value
13:17:24 <Cale> olsner: Also, other people push patches to that repo
13:17:30 <gwern> olsner: I also push stuff
13:17:39 <SamB> % ghc -e 'return "Hi!"'
13:17:39 <SamB> package flags have changed, ressetting and loading new packages...
13:17:39 <SamB> "Hi!"
13:17:48 <EvilTerran> weird
13:17:51 <Cale> olsner: and I pull them into the lambdabot repo where lambdabot is run from, and then build lambdabot and run it
13:17:54 <Myoma> that's not main SamB
13:18:05 <EvilTerran> "When the program is executed, the computation main is performed, and its result (of type t) is discarded."
13:18:12 <EvilTerran> ^ the sentence after the one i just quoted
13:18:13 <olsner> oh, how wonderfully disorganized :)
13:18:18 <SamB> EvilTerran: okay
13:18:20 <EvilTerran> http://haskell.org/onlinereport/modules.html
13:18:35 <SamB>        -e expr
13:18:35 <SamB>               Evaluate expr; see for details.
13:18:46 <SamB> ^ quote from manpage
13:18:49 <SamB> what is with this?
13:18:51 <EvilTerran> "see for details"?
13:19:03 <SamB> that's what I'm bothered by too!
13:19:08 <EvilTerran> looks like a broken reference in the manpage source or something?
13:19:11 <gwern> clearly there is a chapter named ' '
13:19:21 <gwern> it will be difficult to search for it, alas
13:19:22 <SamB> gwern: no, it's named "\b"
13:19:27 <gwern> we shall never know the details :(
13:19:42 <olsner> does everyone with an account on code.haskell.org have lambdabot write access?
13:19:51 <gwern> bah, you and your fancy escapes. I say it's ' ' and I say to hell with it!
13:20:00 <Cale> olsner: I'm not sure. Something close to that.
13:20:06 <pozic> SamB: I ran it in both the chroot and the normal environment. Furthermore I verified that libgmp3 was installed in both environments.
13:20:27 <gwern> Cale: really? didn't you have to give me access?
13:20:29 <SamB> pozic: under what filenames?
13:20:43 <Cale> gwern: I didn't do anything to give you access. Maybe someone else did.
13:20:55 <gwern> hm.
13:21:04 <Cale> I don't maintain code.haskell.org either :)
13:21:07 <yitz> SamB: it's rather hopeless to get information from the man page or the --help message, so they're probably not maintained very much. The important point to get across is: rtfm.
13:21:15 <SamB> gwern: probably you got confused by Cale's assertion that he wouldn't beat you up if you pushed to the repository
13:21:36 <gwern> SamB: the difference is minimal in my mind!
13:22:28 <pozic> SamB: in the chroot not in /usr/lib/ anyway. That's apparently not where Apt puts them.
13:22:48 <Cale> gwern: care to fix/tell me how to fix this problem involving lambdabot not running if State/seen is not present?
13:23:03 * yitz hypothesizes that lambdabot gave gwern permission to push patches
13:23:04 <Cale> (I think it was your patch which made that happen)
13:23:10 * Heffalump tries to understand the top-level <- discussion
13:23:14 <Heffalump> Is there anything about ACIO that precludes duplicating the <-'d declaration?
13:23:26 <olsner> how maintainerly! he's asking for someone to prepare a bug fix :)
13:23:40 * Cale ignores the top level <- discussion intensely and hopes that it will go away.
13:23:41 <gwern> Cale: hm. seen is not being installed by cabal right?
13:23:52 <ddarius> Heffalump: Presumably that would be something the compiler guaranteed.
13:24:06 <Cale> gwern: It's being installed. (In fact, cabal will not install without the seen file)
13:24:12 * gwern has been reading the <- discussion and has no idea what everyone is talking about and hopes it goes away in favor of something I do understand
13:24:22 <Heffalump> ddarius: how?
13:24:27 <Heffalump> what if you have dynamic loading, say?
13:24:29 <Cale> gwern: However, that file must not be present when lambdabot runs in order for lambdabot to run correctly.
13:24:29 * olsner wonders what the <- discussion is all about
13:24:32 <crab> could someone help me to understand this signature, please? fmap :: (Functor f) => (a -> b) -> f a -> f b
13:24:37 <EvilTerran> which <- discussion is this?
13:24:41 <SamB> gwern: apparantly we have a replacement for unsafePerformIO at the toplevel
13:24:45 <Cale> crab: Sure
13:24:46 <gwern> s
13:24:47 <dmhouse> EvilTerran: `Top level <-' from -cafe
13:24:48 <gwern> er.
13:24:49 <ddarius> Heffalump: However, to whatever guarantees the compiler provides.
13:24:59 <Heffalump> ddarius: and anyway, my question was about what the laws for ACIO were, and thus only indirectly what guarantees the compiler provides.
13:25:01 <|Steve|> :t mapM
13:25:14 <|Steve|> Bah, lambdabot still gone?
13:25:27 <Cale> crab: If f is some datastructure type which has values in it of type a, then fmap f will apply the function f to all the values of type a in an f-structure, essentially.
13:25:28 <SamB> |Steve|: yes, Cale has requested a fix
13:25:29 * dmhouse saw the <- discussion, read the first 3 emails, then the last 5, and didn't understand much
13:25:33 <dmhouse> But I guess that's understandable.
13:25:34 <Cale> er...
13:25:35 <Cale> hehe
13:25:38 <gwern> Cale: hm. how could I trigger this error? just starting up lambdabot doesn't seem to
13:25:45 <Cale> I should not have reused f, sorry :)
13:25:59 <ddarius> Heffalump: It's "affine commutative IO".  That is it, anything ACIO should be fine if it is never run (if it isn't used) or if it is run in any order with other ACIO operations.
13:26:00 <pozic> SamB: /usr/lib/libgmp.so.3.4.2 in default env and I seem to have no index in the chroot, but Apt says it's installed.
13:26:04 <Cale> Let me be more correct :)
13:26:07 * yitz proposes as a first step, we just add a JUSTONCE pragma and go on using the same unsafePerfomIO ugliness for the time being, but now with guaranteed semantics.
13:26:14 <Heffalump> it's "affine central" actually
13:26:18 <SamB> pozic: but what about /usr/lib/libgmp.so.3 ?
13:26:33 <Heffalump> but all I know about it are two laws which don't seem to preclude duplication. No-one seems to have mentioned that there's implicit name capture going on in the definition, too.
13:26:38 <SamB> or other lib/libgmp.so.3
13:26:47 <Heffalump> http://www.haskell.org//pipermail/haskell-cafe/2004-November/007664.html
13:26:48 <Cale> crab: If f is some type constructor, and x :: f a, that is x is some structure built up with values of type a in it, then fmap f x will apply the function f to all the values of type a in x
13:26:49 <SamB> and don't your top-level indices also cover the chroot?
13:26:53 <ddarius> Close enough
13:26:55 <crab> Cale: how would you read that signature aloud?
13:26:58 <pozic> SamB: that one does not exist.
13:27:07 <pozic> SamB: that is in the chroot.
13:27:19 <Cale> crab: If f is a Functor, then fmap takes a function from a to b and an f a, and gives an f b
13:27:20 <pozic> SamB: in the normal env it does exist.
13:27:21 <crab> i see.
13:27:27 <ddarius> Heffalump: The laws don't preclude duplication, but neither do the laws of IO.  It's the semantics that do.
13:27:38 <Cale> crab: Alternately, If f is a Functor, then fmap takes a function from a to b and gives a function from f a to f b
13:27:39 <crab> thank you.
13:27:53 <ddarius> The laws are for what is fine to do to ACIO, not what guarantees ACIO will provide.
13:27:55 <Heffalump> but the laws of ACIO allow dropping them.
13:27:56 <Cale> crab: For example... if f is [], the type constructor for lists
13:28:02 <ddarius> Heffalump: Yes.
13:28:04 <gwern> Cale: I can't fix the lb error if you don't tell me when/how to trigger...
13:28:04 <Cale> crab: Then fmap is the usual function map
13:28:05 * Heffalump thinks further
13:28:13 <gwern> I'm a little confused - ACIO \= ACID?
13:28:22 <Cale> gwern: delete State/seen
13:28:28 <Heffalump> gwern: correct.
13:28:54 <Cale> gwern: and lambdabot will not run (it aborts with an error from copyFile)
13:28:58 <gwern> Cale: and it should crash on startup?
13:29:02 <Cale> gwern: yeah
13:29:18 <Cale> gwern: If you delete State/seen from the build directory, it will also not build
13:29:26 <Cale> (well, it will fail to install in the end)
13:29:49 <Cale> The real bug is that the @seen module is fucked.
13:29:49 <yitz> gwern: perhaps rename it rather than deleting it :)
13:29:51 <gwern> interesting...
13:29:59 <gwern> Cale: http://hpaste.org/9965
13:30:16 <ddarius> gwern: The conversation comes down to "do we want Haskell to have direct support for global variables or not"
13:30:40 <crab> Cale: thanks. i understand it now. i didn't understand the "if f is a functor" part earlier.
13:30:40 <Cale> ddarius: As far as I'm concerned, the conversation comes down to "No."
13:30:46 <gwern> ddarius: oh. hm. a good question. we seem to do pretty well without direct support
13:30:56 <pozic> SamB: there seems to be something odd with Apt, probably related due me not updating the chrooted environment for ages.
13:31:02 <EvilTerran> accio globals!
13:31:31 <SamB> personally, I think it's preferable to the oh-so-easy-to-screw-up unsafePerformIO gymnastics ...
13:31:41 <Cale> I think the low-level hacks should remain low level hacks.
13:31:50 <SamB> as long as it's NEVER EVER EVER anything like a default
13:31:55 * Heffalump is, for once, with Cale on this
13:32:00 <yitz> gwern: not really. we use a pragma that does not have the needed semantics, but just happens to work in current compilers
13:32:03 * ddarius is also with Cale.
13:32:15 <SamB> I think it should be an extension, but with a really nasty name
13:32:31 <unenough> programming sucks.
13:32:34 <SamB> since the gymnastics are not merely low-level but EXTREMELY FRAGILE
13:32:35 * yitz disagrees - low level hack is OK, but it has to be a correct hack
13:32:55 <SamB> it is easier to write correct C code than to get it right
13:33:01 <gwern> everything sucks
13:33:20 * gwern googles for ACIO. -_-
13:33:22 <yitz> SamB: unsafeYourFaceIsUglyGlobalVariable
13:33:22 <Cale> It would be better just to fix the C libraries which have inappropriate assumptions wired into them.
13:33:35 <yitz> Cale: not possible
13:33:46 <gwern> apparently there are people who want to help me with ovulation and to liason with NASA in contacting aliens...
13:34:03 <SamB> Cale: let's put it this way -- do you want it to be hard to do at all, and easy to screw up even so?
13:34:17 <ddarius> gwern: Sounds like quite the opportunity.
13:34:22 <Cale> I'm assuming that nobody would be silly enough to suggest that anyone would actually want to write a Haskell program with top-level mutable state without some pre-existing brokenness in another library that they're trying to work around.
13:34:34 <SamB> Cale: 'cause that's the way it is now
13:34:41 <Cale> SamB: And it's fine with me :)
13:34:52 <gwern> ddarius: I dunno. I'm geeky enough that I wouild probably be a disposable secondary character in any contact scenario
13:34:53 <Cale> SamB: It should be hard to do things which are fundamentally broken.
13:34:54 <SamB> you like it being easy to screw up?
13:35:01 <yitz> Cale: you can call stateful libraries broken, but that is going to be the way most of them work for a long time, whatever you say.
13:35:03 <Heffalump> Cale: how do you solve the Data.Unique problem?
13:35:05 <SamB> as in almost impossible not to screw up?
13:35:26 <ddarius> SamB: It's not that hard.
13:35:36 <Cale> SamB: Impossible altogether would not be a problem for me.
13:35:44 * ddarius is with Cale on that too.
13:35:46 <SamB> Cale: you probably are wrong
13:35:51 <EvilTerran> wouldn't making something like Data.Unique solid work?
13:35:55 <yitz> Cale: or the System.Random problem
13:36:02 <EvilTerran> you could build the rest up from something like that
13:36:03 <Cale> System.Random also has brokenness.
13:36:17 <Cale> System.Random's use of top level mutable state is dumb.
13:36:19 <SamB> Cale: I think the IO monad doesn't work right without it ...
13:36:29 <Cale> (and totally unnecessary)
13:36:51 <gwern> Cale: I'm gonna go take a nap, if you figure out a way to replicate your lb problem I'll look at it later (perhaps after my xmonad patch archaeology expedition)
13:37:04 <Cale> gwern: okay... I'll try again to run lambdabot :)
13:37:12 <EvilTerran> i think this sounds difficult to solve nicely without fundamentally changing the language
13:37:16 <yitz> Cale: you can't require people to have access to main in order to get randomness.
13:37:20 <EvilTerran> and we don't want to do that, so all solutions will be ugly
13:37:32 <Cale> yitz: Who said anything about having access to main?
13:37:40 <SamB> Cale: there are a number of places where it is important to have mutable state under-the-hood
13:37:44 <ddarius> There are language that don't even have an "unsafePerformIO hack" equivalent.
13:38:15 <Cale> yitz: getStdGen is stupid, and newStdGen need not rely on top-level-mutable state.
13:38:25 <SamB> I thought most languages had unsafePerformIO implicit
13:38:25 <Cale> It can rely on the system RG.
13:38:39 <Cale> (which is what it should be doing)
13:38:43 <yitz> Cale: with no global state, where do you get a generator from (without assuming access to /dev/urandom)
13:38:50 <Cale> newStdGen should use using /de/andom
13:38:54 <Cale> /dev/random *
13:39:02 <yitz> Cale: it should do that if it exits. It should still work if not.
13:39:03 <EvilTerran> the real world is global mutable state :P
13:39:09 <Cale> ugh, I can't type
13:39:24 <Cale> There's no need to introduce a new top-level variable for that.
13:39:32 <yitz> Cale: rather?
13:40:02 <Cale> Use the system's random number generator. It might even be a hardware device. Random numbers are input.
13:40:13 <yitz> Cale and if there is none?
13:40:21 <Cale> Then use a PRNG.
13:40:27 <Cale> Those are pure functions.
13:40:28 <EvilTerran> still need a seed
13:40:32 <yitz> Cale initialized by?
13:40:38 <Cale> Initialized by hand.
13:40:46 <yitz> Cale: whose hand?
13:41:01 <Cale> Well, you could do something like use the system clock, which is what it currently does.
13:41:33 <Cale> (and which is again pretty horrible, but not the main problem)
13:41:43 <yitz> Cale: it needs to be done once, in a central place. This is a library; we have no access to main.
13:41:57 <Cale> I think it can be relied upon that the system has a random number generator.
13:42:20 <Cale> yitz: What do you mean? Getting hold of a StdGen is easy.
13:42:29 <ddarius> yitz: Why does there need to be One True seed?
13:42:36 <Cale> You can make one yourself. mkStdGen 42
13:42:57 <Cale> However, getting a random one requires a source of random noise.
13:43:02 <yitz> Cale: the point is that initializing the central rng is platform dependent, and may even be expensive, we don't know. That logic needn't be, and shouldn't be, run more than once. So how do we organize that?
13:43:32 <Cale> yitz: Initialising a StdGen is not expensive.
13:43:54 <Cale> Read a few bytes from /dev/random and plonk them into mkStdGen
13:44:01 <yitz> Cale: right, I'm factoring out the stupidity of the current implementation of course.
13:44:19 <yitz> Cale /dev/random might block
13:44:30 <Cale> Or urandom, if you prefer.
13:44:42 <Cale> Still, for a small amount of noise, it shouldn't be a problem.
13:45:11 <yitz>  /dev/urandom might not be available (on some patforms), or may be poor quality.
13:45:28 <Cale> Then that's the system's problem.
13:45:37 <Cale> On Windows, there are other APIs of course.
13:46:05 <Cale> The point is that there is some system API for getting a source of random numbers, and newStdGen should use that.
13:46:14 <yitz> Cale: we can argue about the specific case of randomness, but the point is that there are unquestionably situations in which an external resource needs to be initialized once, and only once, by a library.
13:46:48 <yitz> Cale: there is no way of doing that in Haskell currently.
13:47:08 <yitz> except using a hack that happens to work today, but may not tomorrow.
13:47:10 <Cale> I disagree. You should be able to deal with the resource being unavailable because it is already in use
13:47:29 <Cale> Alternately, you should provide for multiple contexts.
13:48:16 <yitz> Cale: so the program should crash if no one included the proper logic in main? that's unacceptable.
13:48:24 <pozic> SamB: the problem has been resolved.
13:48:48 <Cale> If the library requires bounded access to a resource, use continuation passing style.
13:48:56 <Heffalump> yitz: why not just pass in a context?
13:48:58 <Cale> withResource (\r -> do ...)
13:49:08 <yitz> Cale: passed from where?
13:49:26 <Cale> yitz: withResource initialises and finalises access.
13:49:28 <yitz> Cale: I hope withResource isn't in the IO monad, because your library can't require it.
13:49:36 <Cale> yitz: hm?
13:49:49 <pozic> Cale: what guarantees that withResource (\r -> withResource (\r' is not done?
13:50:02 <Cale> pozic: the second withResource throws an exception.
13:50:12 <Cale> So: nothing.
13:50:27 <Cale> Alternately, you use a separate monad for performing actions related to the resourse.
13:50:31 <Cale> resource*
13:50:36 <Cale> (I need to eat something :)
13:50:59 <Cale> In which case the type system would prevent you from writing that.
13:51:10 <yitz> Cale: think of Data.Unique, or randomness (with my assumptions, change it to something else if you want). You can't always require people to change existing pure code to be in IO - it might just not be possible.
13:51:30 <yitz> @calesnack
13:51:39 <EvilTerran> you may be able to do something olegian with a typeclass or two to stop people nesting withResource
13:51:42 <Cale> yitz: Pure functions should not have arbitrary access to randomness.
13:51:55 <Cale> yitz: They should be required to take randomness as a parameter.
13:52:10 <Cale> yitz: Further, unique supplies are another example of something which is not pure.
13:52:31 <yitz> Cale: they may already be getting that parameter, and the programmer may not be able to change the code that generates it in main.
13:52:37 <Cale> What?
13:52:44 <yitz> So you can't change that API.
13:52:52 <Cale> Why can't they?
13:53:12 <Cale> If main is doing things wrong, then main has to change.
13:53:19 <yitz> They are working on a particular module in an existing software system.
13:53:34 <Cale> Then that software system can be broken, for all I care :)
13:53:54 <Cale> No compromising good semantics for backwards compatibility.
13:54:02 <yitz> Cale: then Haskell is inappropriate for serious software development. Back to the ivory tower with you. :)
13:54:09 <Cale> I'm okay with that.
13:54:12 <bjrn> I don't know what you're talking about, but it's very pleasent to read as your nicks have the same length.
13:54:31 <yitz> Thanks bjrn :)
13:54:32 * Myoma ruins it
13:54:35 <Cale> yitz: The main is written in Haskell.
13:54:44 <Cale> yitz: So how old can it possibly be?
13:55:06 <yitz> Myoma has no hope even if you shorten it - I'm using a proportional font and M is really big.
13:55:15 <yitz> Cale :)
13:55:28 <Cale> yitz: Further, if it's written in a Haskell which doesn't allow for top-level mutable state, then it's already doing things the right way.
13:55:57 <Cale> and will pass in the bits of state that we need as parameters
13:56:15 <Cale> (assuming that our function is pure)
13:57:11 <pozic> What advantage has using monads to manage state over a good module system with mutable state inside modules?
13:57:19 <ski> (.. proportional fonts for irc .. what will they think of next ?)
13:57:30 <Cale> pozic: Control over the amount and type of state which is present in any given context.
13:57:43 <ddarius> ski: Proportional fonts for code...
13:58:03 <pozic> Cale: but if you keep modules down to 500 lines it's easy to see that from the source code too.
13:58:10 <pozic> Cale: an IDE could show that.
13:58:37 <pozic> Cale: I am assuming that most things happen in a functional way, btw.
13:59:00 <pozic> Cale: just the things that would typically work via a State monad or ST monad would not.
13:59:20 <Cale> Oh, are you going to break the referential transparency of the function type?
13:59:59 <yitz> Cale: here's another example. Let's say I want to use Adobe's C library for FDF (forms data from PDF forms). There's a requirement from above that we use that library, in order to guarantee standards compliance and forward compatibility with Adobe. Well, that API (and hundreds of others like it) require calling a function - exactly once - to initialize the library. This is a widespread idiom. You may say it's broken, but that's reality. Haskell is n
14:00:03 <Cale> Like, make it possible for a function  [a] -> Integer do something like read from the network?
14:00:29 * Myoma wonders if pozic has met ocaml
14:00:33 <stepcut`> if my .cabal has a library and several executables listed, is there a way to build just one executable and not everything else ?
14:00:47 <Cale> yitz: (Your message was cut off at 'Haskell is'). That problem can be handled in your binding to the library.
14:01:16 <yitz> Haskell is not Turing complete (in an unusual sense) unless it can handle that
14:01:18 <Cale> yitz: withFDF :: IO a -> IO a
14:01:23 <dcoutts> stepcut`: not easily atm, you can mark some as not buildable, but for casual development you want to say cabal build fooexe and we can't do that yet (but we will one day).
14:01:23 <sjanssen> Cale: how can it be handled without some global state, or language support for actions that can only happen once?
14:01:33 <Cale> sjanssen: with-style functions?
14:01:57 <sjanssen> Cale: "withFDF (return ()) >> withFDF (return ())" -- yitz said "exactly once"
14:02:05 <yitz> Cale: no, the API is pure. Your task is to create a library that provides those pure functions, by calling into Adobe's library via FFI.
14:02:10 <Cale> The second call can give an exception.
14:02:37 <rwbarton> what about just requiring main to call initFDF :: IO ()?  That's what a C program would do anyways
14:02:38 <sjanssen> Cale: how does withFDF determine that it has already been initialized without state?
14:02:39 <yitz> Cale: crashes are not nice
14:03:27 <yitz> (of course neither is Adobe's library)
14:03:45 <Cale> sjanssen: Alternately, you have withFDF do whatever is required to un-initialise the library afterward.
14:04:03 <sjanssen> Cale: of course now we have problems with concurrent accesses
14:04:04 <Heffalump> so the problem here is that shared library loading is unsafe
14:04:16 <Heffalump> you should just make a new copy of the library each time you run withFDF
14:04:24 <Cale> Or, you tell Adobe to fix their library. If the functions are actually pure, then there should be no need to call an initialisation function.
14:04:27 <yitz> Cale: in this there doesn't happen to be any way to uninitialize it. really, really nasty, but that's life.
14:04:31 <stepcut> dcoutts: lame
14:04:41 <Cale> yitz: The library is broken then.
14:04:51 <Cale> yitz: It's not Haskell's job to magically fix it.
14:04:55 <yitz> Cale: yep like hundreds of others like it.
14:05:09 <pozic> Cale: yes, I see where my little idea leads to. It doesn't really matter that much. The only way to know what your code is going to do without running it is its type anyway and since Haskell has no usable dependent types, it's not that important.
14:05:11 <Cale> Write your binding in IO.
14:05:27 <yitz> Cale: no, that's not considered broken by most people, even though we know it is. we have to have a way to work with it.
14:05:36 <sjanssen> Cale: but IO alone doesn't give us the tools to make sure that initialization happens once and only once
14:05:37 <Cale> pozic: I know that a function [a] -> Integer is not going to read from the network :)
14:06:03 <Cale> sjanssen: Neither does the library.
14:06:13 <Cale> sjanssen: If you were using it in C, you wouldn't expect that ability.
14:06:21 <Cale> sjanssen: It's the library's fault.
14:06:26 <pozic> Cale: yes, but the Scheme idea that "everything looks the same" has also some virtue.
14:06:26 <sjanssen> Cale: but with a global mutable variable, you can make a wrapper that does provide this
14:06:26 <Cale> Not Haskell's fault.
14:06:48 <yitz> Cale: yes the library does. It writes the requirement into the user docs, in big letters. Of course, all programming languages can deal with it. Can't they?
14:06:50 <Cale> sjanssen: You could, say, write a better C library around the library first?
14:07:19 <sjanssen> Cale: I write Haskell because I don't enjoy writing C :)
14:07:26 <yitz> Cale: that's better than having a JUSTONCE pragma?
14:07:47 <yitz> ONLYONCE or whatever
14:07:52 <Cale> yitz: It's better than having top-level mutable state.
14:07:59 <sjanssen> Cale: that's a serious cop-out -- dropping to C because Haskell can't do it
14:08:42 <Cale> sjanssen: I think my main concern is that if you add a feature like this, then you make it easy to make more broken libraries like this inside Haskell.
14:08:47 <yitz> Cale: you have top-level mutable state. You get it by using a static variable in C and accessing it via FFI. That's even messier than what we have now.
14:09:00 <sjanssen> Cale: I generally don't believe in top level mutable state, but I don't think yitz's example can be done cleanly in any other way
14:09:03 <rwbarton> sjanssen: C also can't stop you from calling the initialization function multiple times
14:09:17 <Cale> yitz: Well, almost anything is allowable from the standpoint of FFI.
14:09:22 <yitz> Cale: it's needed, there's just no way around it in practice. really.
14:09:30 <sjanssen> rwbarton: we're #haskell, our job is to do it better than C
14:09:59 <Cale> yitz: However, from my view, Haskell itself shouldn't even have things like unsafePerformIO.
14:10:01 <yitz> Cale: that's because C is Turing-vonNeuman complete. Haskell isn't, according to you.
14:10:08 <sjanssen> Cale: what do you think of Data.Unique?
14:10:09 <bjrn> Doesn't GCC support "constructors" with an extension?
14:10:51 <pozic> yitz: what is Turing-vonNeuman complete?
14:10:57 <Cale> sjanssen: I think it's silly not to support more than one unique supply :)
14:11:07 <yitz> Cale: I agree, I think we should carefully provide everything that is needed from unsafePerformIO, and then get rid of it. Most of that work is already done. This is one of the few remaining holes.
14:11:12 <pozic> yitz: nobody uses that phrase.
14:11:36 <Cale> yitz: I think FFI can include things like unsafePerformIO, but that core Haskell should now.
14:11:38 <Cale> not*
14:11:59 <yitz> pozic: I just made it up. It means - able to do what programs assuming a Turing-vonNeuman architecture can do. I'm using it tongue-in-cheek.
14:12:04 <sjanssen> yes, the FFI standard is the right place for unsafePerformIO
14:12:30 <Cale> FFI should remain a language extension forever :)
14:12:30 <yitz> rename it to unsafePerformFFI
14:12:32 <pozic> yitz: don't overload words or parts of words that already have established meaning, please.
14:12:48 <yitz> pozic: ok. it was meant to be amusing. sorry.
14:12:49 <rwbarton> sjanssen: fair enough, I'm confused because yitz seems to think that C has some advantage over Haskell here.
14:12:57 <pozic> yitz: Haskell is Turing-Complete, even its type system is.
14:13:06 <Cale> yitz: That word doesn't really fit the meaning which you intended anyway.
14:13:08 <Myoma> pozic: haskell type system isn't turing complete
14:13:17 <pozic> Myoma: yes, it is.
14:13:17 <yitz> Cale: true.
14:13:18 <Cale> Myoma: It is with GHC.
14:13:22 <sjanssen> rwbarton: well, it is true that I could write a wrapper library that does provide that guarantee (I just have to ask my users not to use the base library)
14:13:24 <Cale> But not in Haskell 98
14:13:26 <pozic> Myoma: Haskell 98 is not.
14:13:44 <pozic> Myoma: are you waiting until you can say something trivial? Don't do that please.
14:14:07 <Myoma> pozic: must you talk like that?
14:14:28 <pozic> Myoma: I noticed that you called me a troll and had several other negative comments regarding me.
14:14:47 <Heffalump> is there anything about <- as proposed that precludes it being used in a let binding?
14:14:58 <Cale> Heffalump: heh
14:15:20 <yitz> rwbarton: C would have an advantage if Cale would have his way and there would be no way at all to get global state in Haskell. Not a theoretical advantage, theoretically C would be *disadvantaged* of course. But in practice, for the forseeable future, Haskell would be unusable as a practical programming language, except for certain limited tasks.
14:15:26 <Heffalump> <- clearly blocks some program transformations that were previously correct.
14:15:31 <Heffalump> I'm just trying to figure out what they are.
14:15:53 <Cale> yitz: I have no problem with putting this sort of thing into the FFI extension. I do have a problem with adding features like that to Haskell.
14:16:23 <Cale> yitz: Since one of the major *features* of Haskell is that it has a restrictive evaluation model.
14:16:29 <sjanssen> yitz: you're going entirely too far with that statement
14:16:42 <sjanssen> yitz: rather, Haskell is slightly more cumbersome for a handful of tasks
14:16:55 <yitz> Cale: I'm proposing even less. I say we should add a pragma, say ONLYONCE, which for now is an alias for NOINLINE but guaranteess the semantics we need for global state. Without any change to Haskell at all, even FFI.
14:17:03 <dons> i wonder how often top level state is used in real programs.
14:17:22 <dons> i don't think i've run across it at Galois yet, though there must be some out there.
14:17:32 <mapreduce> Perhaps IO should be called C :)
14:17:37 <Heffalump> going back to the Adobe library example, what precludes two people making bindings to the same library?
14:17:39 <rwbarton> yitz: in this case C is powerful enough to make up for its flaws.  Write a C wrapper library if you like or just initialize the original library once at the start of your program. *shrug*
14:17:52 <Cale> If you don't have to interface with existing poorly-designed libraries, it should be unnecessary.
14:17:55 <EvilTerran> dons, i think it *mostly* comes up when linking with C
14:17:57 <yitz> dons: not every day. but often enough that it will be too much of a risk for any sane project manager to use Haskell for anything serious.
14:18:25 <Heffalump> clearly my managers are all insane
14:18:29 <Heffalump> as our dons
14:18:32 <Heffalump> s/our/are/
14:18:40 * yitz is also insane
14:18:41 <EvilTerran> as Cale says, it seems like a poor design choice on the part of the C library's designers
14:18:43 <sjanssen> yitz: are intentionally exaggerating?
14:18:44 <dons> yitz: yeah, the industrial users seem to be making progress...
14:18:48 <sjanssen> yitz: are you...
14:18:52 <dons> i guess you're just trolling :)
14:19:11 <pozic> It's John ;)
14:19:39 <dons> i think it's exciting bulat's arguing for pure hashtables :)
14:19:41 <Cale> I certainly wouldn't want to mess up Haskell's semantics in various ways just because bad C libraries exist and you might choose to use one of them.
14:19:57 <dons> how many of our hundreds of FFI bindings actually use top level state?
14:20:08 <Cale> I think hashtables are severely overrated.
14:20:14 * EvilTerran is perfectly happy with the suggestion that something appropriate go in the FFI spec
14:20:24 <yitz> trolling is a better description than exaggerating. No, I do see that as a real risk. It won't take more than one or two times that someone with influence gets into deep trouble because of this, and the buzz will begin...
14:20:33 <Cale> EvilTerran: I agree.
14:20:46 <pozic> Jon*
14:20:59 <sjanssen> yitz: but we have the unsafePerformIO/NOINLINE workaround, and it works perfectly well
14:21:05 <sjanssen> yitz: it isn't going to break any time soon
14:21:21 <EvilTerran> although, in that case, i'd suggest renaming FFI to RWI
14:21:26 <EvilTerran> "Real World Interface" :P
14:21:31 <Cale> Also, I don't really think we should be focused on making Haskell usable for the real world. Sure, it's nice if that happens, however, it's more important that it be a good language first, and a practical language second. :)
14:21:35 <dons> it's a rare case, with a solid solution that's been in place for a decade or more.
14:21:44 <dons> Cale, bah.
14:21:51 <dons> you wait till your pay checks depend on it :)
14:22:00 <Cale> They will never be so :)
14:22:03 <Heffalump> it's not a very solid solution - what happens with dynamic loading?
14:22:19 <yitz> Cale: As I said, I'm not expressing an opinion about ACIO or any of the other proposals. I'm just saying that there must be *some* way to do it. And I think the easiest and most practical way right now is to add an alias to NOINLINE that will be guaranteed to work the same way that NOINLINE happens to work now.
14:22:40 <sjanssen> I haven't read the "Top Level <-" yet, but has anyone asked what happens when <- bound variables mention each other?
14:23:05 <yitz> dons: right. it's only a little broke, so don't fix more than that.
14:23:24 <bjrn> Perhaps relevant: http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html scroll down to "constructor"
14:23:26 <sjanssen> yitz: oh, so you want unsafePerformIO plus a new pragma?  I think I like that
14:23:26 <Cale> yitz: Well, if you're just talking about adding a pragma to GHC...
14:23:31 <EvilTerran> sjanssen, it's come up but not been resolved, AFAIK
14:23:36 <yitz> Cale: yes
14:23:37 <Cale> yitz: GHC pragmas are entirely unstandardised anyway
14:23:50 <ski> sjanssen : "Top Level <-" ?
14:23:54 <yitz> Cale: haskell' standardizes them
14:23:57 <Heffalump> sjanssen: I think Ian Stark mentioned it in his original proposal for ACIO.
14:24:00 <Cale> Does it?
14:24:04 <dons> Cale, they're standardised now.
14:24:06 <sjanssen> ski: on haskell-cafe
14:24:08 <Heffalump> sjanssen: and the answer was that it's fine as long as there's a constructor in the way.
14:24:11 <Cale> dons: Where?
14:24:19 <Cale> dons: In the GHC User's Guide? ;)
14:24:44 <yitz> Cale: all of the compilers have standardized on the Haskell' proposal
14:24:50 <pozic> What are you doing with the Advanced Contact Intelligence Organization?
14:24:55 <EvilTerran> ski, that's the name of the thread on -cafe that we've been discussing for lord knows how long
14:25:20 <ski> (oh .. i thought that was unrelated)
14:25:30 <Heffalump> does Bulat ever IRC?
14:26:02 <dons> Heffalump: nah.
14:26:10 <Cale> pozic: It stands for affine central IO, iirc.
14:26:17 <Myoma> let (->) = flip (^) in 2 -> 3
14:26:18 <Cale> Or commutative?
14:26:21 <Heffalump> central
14:26:21 <Myoma> > let (->) = flip (^) in 2 -> 3
14:26:27 <yitz> yeah, bulat has a different proposal that's simpler than ACIO.
14:26:33 <EvilTerran> Myoma, -> is reserved
14:26:37 <Heffalump> it's strong than commutative, because it needs to commute with anything in IO
14:26:40 <Cale> Same thing anyway.
14:26:41 <EvilTerran> Myoma, also lambdabot isn't here
14:26:42 <Cale> oh
14:26:51 <balbaroy> preflex: seen lambdabot
14:26:51 <preflex>  lambdabot was last seen on #haskell 1 hour, 41 minutes and 42 seconds ago, saying: Defined.
14:26:58 <Cale> Anything in IO at all? Okay.
14:27:25 <EvilTerran> Cale, because it could happen at any time
14:27:29 <Cale> EvilTerran: right
14:27:31 <EvilTerran> as with unsafePerformIO'd stuff now
14:27:56 <sjanssen> has anyone asked what happens when ! patterns are combined with <-?
14:28:51 <sjanssen> nevermind, top level bang patterns aren't allowed at all
14:28:53 <mmorrow> was just scrolling back after reading the haskell mailing list for an hour on this issue
14:29:48 <mmorrow> i'm with unsafePerformIO and a new pragma that actually is guaranteed to do what {-# NOINLINE asdf #-} is used to do
14:29:53 <Cale> I don't know what bang patterns would even mean for pattern bindings.
14:30:28 <mmorrow> (there was a bunch of great stuff on this in 2004)
14:30:32 <pozic> Cale: and affine is being used as a buzz word here? Central just seems to be that all IO is managed by one entity,
14:30:40 <Cale> I think this sort of thing should not be considered part of Haskell though. It should be part of the FFI extension anyway.
14:30:43 <sjanssen> Cale: forced evaluation when the program is started?  Anyway, the powers that be were smart enough to outlaw it
14:30:45 <Cale> pozic: No.
14:30:52 <Cale>   do { x <- u; v } = v                                (affine)
14:30:53 <Cale>   do { x <- u; y <-v; w } = do { y <- v; x <- u; w }  (central)
14:30:53 <yitz> mmorrow: there was a lot on haskell-prime also.
14:31:12 <Heffalump> where nothing is free in anything else.
14:31:16 <Cale> pozic: Those are equations for u to be affine and central
14:31:28 <Cale> (and v,w are anything in IO
14:31:29 <Cale> )
14:31:40 <Heffalump> I still want to know about let bindings, and if not, why not.
14:31:46 <mmorrow> yitz: thx for the ptr
14:32:03 <pozic> Cale: is it related to affine transformations?
14:32:25 <Cale> Probably in some distant way :)
14:32:53 <EvilTerran> "The devil, enraged, responded 'ho! let einstein be!' - and restored the status quo"
14:33:04 <EvilTerran> (or something)
14:33:11 <ski> (i think `affine' has been called `discardable' ..)
14:33:17 <Cale> http://en.wikipedia.org/wiki/Affine_logic -- probably has more to do with this
14:34:00 <ddarius> Heffalump: Like aVariable = let ref <- newIORef in ... ?
14:34:06 <Cale> and that in turn is distantly related to affine spaces as you might be used to them :)
14:34:53 <Heffalump> ddarius: right.
14:35:10 <EvilTerran> i presume, somewhere along the way, there's an etymological link with "affinity"
14:35:35 <Heffalump> because, either we lose the property that all top level value definitions can be dropped into lets, or we lose referential transparency.
14:35:36 <pozic> I presume you don't know :)
14:35:41 <Heffalump> and I'm just trying to find out which :-)
14:35:45 <ski> ddarius : how would you type that ?
14:36:18 <lispy> Is there anything like IO but tracks a state change like ST does?
14:36:28 * EvilTerran enjoys speculating idly about the etymology of words
14:36:39 <allbery_b> um, IO?
14:36:54 <EvilTerran> i was pondering whether there's a link between "lemma" and "dilemma" earlier
14:37:05 <lispy> allbery_b: IO hides the state
14:37:07 <sjanssen> lispy: IO a = ST RealWorld a
14:37:13 <mmorrow> lispy: i think any such thing would be equivalent to ST
14:37:24 <EvilTerran> ST hides the state too
14:37:26 <mmorrow> what sjanssen said
14:37:32 <sjanssen> @src IO
14:37:36 <lispy> So, suppose I use ST (MyState) a, but now I need to do IO operations
14:37:36 <sjanssen> @src ST
14:37:58 <sjanssen> lispy: you never use ST MyState -- are you confusing ST with State?
14:38:00 <rwbarton> lispy: Are you thinking of StateT MyState IO?
14:38:04 <allbery_b> there arew unsafe* functions to go between ST and IO
14:38:04 <pozic> lispy: STT and IO
14:38:12 <EvilTerran> STT doesn't exist, does it?
14:38:17 <pozic> EvilTerran: yes, it does.
14:38:18 <allbery_b> I don't think STT is permissible
14:38:24 <sjanssen> allbery_b: there's even a safe version too
14:38:26 <allbery_b> likeIO, it canobly be at the base of a monad stack
14:38:41 <Saizan> pozic: uh? where?
14:38:45 <pozic> Saizan: hackage
14:38:55 <Heffalump> STT does exist, but it's broken.
14:39:00 <lispy> according to the haddocks, ST tracks a state
14:39:05 <yitz> Cale: I don't think you're right that it's only FFI. There are many situations where you need to guarantee that an IO action happen only once, not just for FFI. There needs to be a way to express that at compile time.
14:39:06 <Heffalump> I pointed out the problem with it to the author when I noticed it and he agreed that the problem exists.
14:39:08 <lispy> GHCi> unsafeCoerce2 ("hi!" :: String) :: Double
14:39:08 <lispy> -3.532282928371135e-58
14:39:08 <EvilTerran> pozic, uh, where?
14:39:12 <lispy> GHCi> unsafeCoerce2 ("hi!" :: String) :: Double
14:39:12 <lispy> -3.532282928371135e-58
14:39:13 <lispy> gah
14:39:14 <lispy> sorry
14:39:16 <EvilTerran> i don't see it on the package list
14:39:20 <lispy> data ST s a
14:39:21 <pozic> Heffalump: in what way is it broken?
14:39:34 <Heffalump> pozic: it doesn't work if you apply it to [], say.
14:39:37 <Heffalump> Anything that's not single-threaded.
14:39:52 <Saizan> lispy: it tracks a whole heap, but 's' is just there for a "region" trick that prevents the variables from escaping
14:40:07 <EvilTerran> lispy, the s doesn't affect the type of STRefs you can use
14:40:11 <ski> STT (ContT o []) a
14:40:27 <EvilTerran> ski, what's that, time-travel with parallel universes?
14:40:28 <Heffalump> EvilTerran: well, it does.
14:40:42 <EvilTerran> Heffalump, i mean the types of values, not keys
14:40:45 <lispy> in that case, perhaps State is what I want
14:40:55 <yitz> It is easy to prove that State st a is isomorphic to STRef st -> ST a
14:41:16 <Heffalump> EvilTerran: ah, ok
14:41:30 <Saizan> lispy: you want the type of your state to change during the computation?
14:41:41 <EvilTerran> i was about to get on to trying to explain what Saizan was saying about region tricks
14:41:53 <EvilTerran> but it does my head in, so i don't tihnk i'd do a very good job :P
14:42:06 <lispy> Saizan: yeah, I want to thread the state changes
14:42:17 <lispy> Saizan: and when the state changes I update a phantom
14:42:29 <Cale> yitz: There should be no reason if you have design control over the library.
14:42:31 <lispy> Saizan: perhaps I need a new state monad
14:42:32 <Heffalump> Matthew Sackman talked about this trick at AngloHaskell.
14:42:44 <Heffalump> you need a new Monad class too
14:42:45 <ski> (EvilTerran : something like that, mayhaps ..)
14:42:50 <Cale> yitz: You can always design things so as to make context explicit, and allow for multiple contexts.
14:43:05 <Cale> (Singletons are an antipattern)
14:43:15 <yitz> Cale: you don't need any type checking if you have design control over the library.
14:43:20 <Heffalump> is IO = ST RealWorld these days?
14:43:24 <Saizan> lispy: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-State.html
14:43:27 <Heffalump> (in a user-visible way)
14:43:28 <Cale> yitz: That's not true :)
14:43:46 <EvilTerran> Heffalump, not user-visible AFAIK
14:43:55 <newsham> so i know this was discussed a bit yesterday... and i thought i was against it then, but ...   why not have instance Functor with (<$>), instance Applicative with (<*>) and instance Monad with (>>=) all nested?
14:43:59 <dmhouse> Heffalump: depending on how many GHC.* modules you import I guess.
14:44:04 <Saizan> ?type stToIO
14:44:06 <EvilTerran> Heffalump, as the constructor isn't visible by default
14:44:09 <Cale> In a moderately user-visible way, through the Control.Monad.ST stuff.
14:44:12 <dmhouse> Heffalump: I'm pretty sure you could bring the IO constructor into scope if you wanted to.
14:44:14 <lispy> Saizan: huh, is that documented anywhere?
14:44:17 <Cale> (which shouldn't be in Control.Monad.ST)
14:44:27 <sjanssen> Heffalump: they're both GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
14:44:33 <Cale> stToIO :: ST RealWorld a -> IO a
14:44:39 <sjanssen> Heffalump: s is RealWorld for IO
14:44:46 <ski> newsham ".. all nested?" ?
14:44:52 <Heffalump> Cale: I mean are they actually the same type.
14:44:59 <sjanssen> k
14:45:06 <Cale> Well, there's also unsafeIOToST :: IO a -> ST s a
14:45:10 <Heffalump> otherwise what lispy is trying to do would probably require a MPTC+fundep too, making it even funkier.
14:45:13 <Heffalump> Cale: yes, I know that.
14:45:14 <Cale> (which is in the same module, irritatingly)
14:45:24 <Heffalump> I want to know if IO is the same type as ST RealWorld or not.
14:45:30 <Cale> Heffalump: Other than that, I don't think there's a way to see that.
14:45:30 <Heffalump> not whether there are conversion functions
14:45:42 <Cale> Heffalump: They're not treated as equal by the type system at least.
14:45:52 <EvilTerran> IO is newtype-wrapped
14:45:56 <yitz> Cale will now say that unsafeIOToST should be an FFI extension.
14:45:57 <Heffalump> ah, right, thanks.
14:45:58 <Saizan> lispy: i'm sure there's a blog or a mail, somewhere.. IxMonad has also been called Monadish by oleg
14:46:02 <Heffalump> so they clearly can't be.
14:46:13 <Cale> yitz: Absolutely!
14:46:16 <Valodim> is there a way to see if something can be read?
14:46:22 <matthew-_> ooo, someone doing type level hackery a la me?
14:46:30 <Valodim> or is that done with some kind of exception?
14:46:39 <Cale> :t reads
14:46:47 <newsham> ski: like, applicative wouldnt have <$> because it will get it from also being a Functor, and Monad wont have ap because it will have <*> from Applicative
14:46:48 <Cale> oh right.
14:46:51 <yitz> Cale: no bot
14:46:54 <newsham> nested == depends on, i guess
14:47:01 <Cale> reads :: (Read a) => String -> [(a, String)]
14:47:17 <Heffalump> matthew-_: not very a la you, just using the same monad trick. Which is apparently on hackage too.
14:47:18 <Cale> Valodim: If that gives an empty list, then it can't be read :)
14:47:25 <Cale> Valodim: otherwise, it gives a list of parses
14:47:39 <Cale> Valodim: (I think all the usual instances give only one parse though)
14:47:40 <matthew-_> Heffalump: yep, there's a monad-variants package there iirc
14:47:50 <Valodim> alright
14:47:54 <Cale> yitz: yeah, it's somewhat broken
14:47:55 <Valodim> thank you
14:48:01 <Heffalump> category-extras is what we're looking at.
14:48:30 <matthew-_> right, that'd be the one
14:48:52 <byorgey> evening #haskell!
14:49:10 * byorgey cooks up some lambda beans and rice
14:49:40 <Nafai> Hi byorgey!
14:49:42 <chrisdone> λ \o/
14:49:45 <matthew-_> don't forget the salad with λ-dressing
14:50:05 <byorgey> I wouldn't think of it!
14:50:11 <byorgey> hi Nafai
14:50:13 <ziman> functor salad? :)
14:50:23 <Valodim> haha
14:50:45 <Cale> ah, managed to get it to work :)
14:50:54 <Cale> Should be connecting :)
14:51:22 <yitz> Valodim: using reads, you also might need to check that the String in [(a, String)] is the empty string. Because:
14:51:32 <Cale> yitz: anyway, all the unsafe IO functions should be part of the FFI.
14:51:43 <yitz> > reads "123foo" :: [(Int, String)]
14:51:46 <lambdabot>  [(123,"foo")]
14:51:51 <yitz> yay!
14:52:10 <yitz> @vixen hi lambdabot, glad to see you back.
14:52:10 <lambdabot> how're you?
14:52:18 <dmhouse> ?yow
14:52:18 <lambdabot> Couldn't find fortune file
14:52:20 <dmhouse> Boo!
14:52:34 <Cale> yitz: They're otherwise essentially unnecessary. Well, the other use is adding things to the evaluation model which is highly-implementation dependent anyway, and should probably be handled with the same gravity with which you'd modify the compiler.
14:52:40 * yitz is afraid to try the seen plugin
14:52:47 <Cale> @seen yitz
14:52:47 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:52:50 <Cale> ah, nice.
14:52:58 <Cale> Well, kind of expected that :)
14:53:05 <yitz> @bots
14:53:06 <lambdabot> :)
14:53:12 <yitz> didn't crash her anyway
14:53:36 <Cale> Maybe I should just let @seen be completely broken, and it will encourage someone to fix it :)
14:53:59 <mmorrow> preflex has it covered
14:54:09 <yitz> Cale: change it to give a message asking people to work on it
14:54:12 <mmorrow> preflex: asdf
14:54:17 <mmorrow> crap
14:54:23 <yitz> preflex help
14:54:23 <preflex>  try 'help help' or see 'list' for available commands
14:54:40 <mmorrow> nice
14:54:47 <mmorrow> preflex: seen mmorrow
14:54:47 <preflex>  mmorrow was last seen on #haskell 7 seconds ago, saying: nice
14:54:51 <mmorrow> preflex: seen mmorrow
14:54:51 <preflex>  mmorrow was last seen on #haskell 4 seconds ago, saying: preflex: seen mmorrow
14:54:58 <yitz> Here's how to get lambdabot to do seen:
14:55:03 <Saizan> is preflex in haskell?
14:55:06 <yitz> @pl preflex seen Cale
14:55:07 <lambdabot> preflex seen Cale
14:55:07 <preflex>  Cale was last seen on #haskell 1 minute and 31 seconds ago, saying: Maybe I should just let @seen be completely broken, and it will encourage someone to fix it :)
14:55:28 <mmorrow> \x -> x
14:55:28 <lelf> hehe
14:55:34 <balbaroy> Saizan: yes
14:55:35 <mmorrow> @pl preflex seen mmorrow
14:55:36 <lambdabot> preflex seen mmorrow
14:55:36 <preflex>  mmorrow was last seen on #haskell 1 second ago, saying: @pl preflex seen mmorrow
14:56:48 <stepcut> how can I make these warnings go away, Expr.hs:25:2: Warning: Defined but not used: `f[a8NW]'
14:56:56 <stepcut> that function is generated via TH
14:58:23 <matthew-_> using th, send the file out through sed and remove the function
14:58:26 <yitz> Cale: I don't think the concept of "only once" is highly implementation dependent (modulo the linkage-level issues that dcoutts raised, of course)
14:59:04 <b\6> appreciate it if you'd take a look and try to fix: http://www.hpaste.org/9957
14:59:31 <b\6> (network/parsec day 3012)
14:59:34 <Heffalump> yitz: linkage-level issues are pretty serious..
15:00:03 <Cale> yitz: unsafePerformIO and its kin are though
15:00:04 * matthew-_ spots the time and sighs at another evening in which he didn't get enough hacking done
15:00:26 <Cale> yitz: and they should all go into FFI or some extension which is easily excluded
15:00:57 <yitz> Heffalump: yes. but those issues already exist in C and friends.
15:01:47 <Cale> b\6: It would help if I knew what the problem was :)
15:01:52 <yitz> Cale: It would be nice - but then you would need some other language extension, with clearer, more limited, implementation-independent semantics, to replace them.
15:02:11 <yitz> Cale; and, that, I think is what they are attempting to do with ACIO.
15:02:18 <Cale> yitz: I think it's good for FFI's sake that unsafePerformIO exists.
15:02:35 <Cale> (you do actually need it in certain circumstances there)
15:02:45 <b\6> Cale: did you run it? parsec tells me unexpected "\r", expecting "\r".
15:02:54 <bjrn> So I'm learning Haskell at the moment. I'm no stranger to functional programming, but the type system and purity is new to me. What I've noticed this far, the biggest difference compared to other languages I know: Haskell makes maintenance tasks fun! There's always a better/clearer way to rewrite a piece of code or refactor a whole program.
15:02:56 <yitz> Cale: sure. for one thing, it allows you to import functions that you know to be pure as pure from clueless languages.
15:02:58 <Cale> b\6: No, I'm just looking at your paste.
15:05:20 <b\6> Cale: demonstrates parsing from string with no problem and using a pretty much identical parser to parse from network, which screws up in crazy way.
15:05:55 <mmorrow> Cale: i think it's good for haskell's sake that unsafePerformIO exists :)
15:06:05 <dons> bjrn: yeah, you can refactor like mad, since there are fun abstractions to try, and purity + strong typing stop you getting lost
15:06:23 <Cale> mmorrow: I don't think it should exist in the Haskell standard proper though.
15:06:37 <Cale> mmorrow: But in an extension like FFI, it's fine.
15:07:12 <mmorrow> Cale: i don't agree :)
15:07:41 <dons> http://www.reddit.com/r/programming/comments/6ycfb/breaking_symmetry_to_maintain_it/
15:07:44 <lambdabot> Title: Breaking symmetry to maintain it : programming, http://tinyurl.com/6l9pju
15:08:18 <Cale> mmorrow: Why not?
15:08:43 <Cale> mmorrow: I think unsafePerformIO is something which should not be used in day to day programming.
15:09:54 <Cale> mmorrow: It should be used only for two reasons: binding to C libraries which provide pure functionality somehow, and extending the language's evaluation model in various low-level ways which end up being pure.
15:10:05 <mmorrow> Cale: i don't disagree because i feel that its presence is desirable or even personally preferable to me, but because then that means if i need it to do something, i can count on being able to have that code run on any haskell compiler and have it run with the same semantics
15:10:49 <mmorrow> (*) extending the language's evaluation model in various low-level ways which end up being pure.
15:11:43 <Cale> The latter only really works when you take the details of the implementation into account though.
15:12:15 <Cale> For example, what optimisations are performed can in general affect the behaviour of unsafePerformIO'd terms.
15:12:38 <yitz> Cale: "global only once" is not pure. It's an impure idiom that is not currently supported by IO, so you need unsafePerformIO to implement it.
15:13:42 <mmorrow> also, i don't think it  "shouldn't" be used for unsafe/global-mutable/whatever purpose someone feels like using it for and that person also having their prog be portable. i think the choice should be available, and the extent to which your code is portable not depend on the particular style you choose to adhere to in your programming (/whatever/ that may be).
15:13:52 <EvilTerran> it seems to me that some structured, predictable notation for "global only once" would be worthwhile
15:13:59 <EvilTerran> but not necessarily as part of the core language
15:14:09 <izukerman> having a problem building yi
15:14:14 <izukerman> $ cabal install yi
15:14:15 <EvilTerran> hence, i come down in the "make it an extension, maybe part of the FFI" camp
15:14:28 <izukerman> cabal: cannot configure binary-0.4.3. It requires base >=2.0 && <2.2 && >=3.0 && >=2.0
15:14:43 <EvilTerran> ... base <2.2 && >=3.0 ?!
15:14:44 <izukerman> any suggestions?
15:15:03 <Cale> mmorrow: I think it should. I would like to see Haskell at its core go back to being a more disciplined language with, for instance, a proper denotational semantics that's been written down (like used to exist).
15:15:07 <yitz> hmm, so I guess it does fit your second reason then.
15:15:24 <Cale> mmorrow: If that excludes certain styles of coding, I don't care.
15:15:38 <Cale> Just tell people to program in an acceptable way :)
15:15:55 <mmorrow> Cale: heh
15:16:07 <Cale> The compiler doesn't accept things which are syntax errors or type errors. I don't see how this is much different.
15:16:20 * EvilTerran notes that ST could have clean denotational semantics
15:16:34 <dcoutts> izukerman: hmm
15:16:41 <EvilTerran> indeed, so can IO, i guess
15:16:42 <Cale> Right, it's extremely unfortunate that importing Control.Monad.ST unqualified gets you dangerous functions.
15:16:52 <EvilTerran> more-or-less clean, anyway
15:17:00 <EvilTerran> i'm not sure how much hand-waving is needed
15:17:11 <dcoutts> dons: note that making binary dep on bytestring >= 0.9.1 means it cannot be used in any package that also indirectly depends on the ghc api
15:17:16 <EvilTerran> Cale, indeed, those should be in C.M.ST.Unsafe, at least
15:17:25 <wadcom> hi, this code excerpt generate parsing error in GHC:
15:17:25 <wadcom>   where
15:17:25 <wadcom>     {-# SCC "dumpWith" #-}
15:17:26 <wadcom>     dumpWith f = Data.Map.foldWithKey f []
15:17:41 <wadcom> am I missing the syntax?
15:17:51 <wadcom> SKDB.hs:104:4: parse error (possibly incorrect indentation)
15:17:52 <Cale> wadcom: SCC's have to be applied to expressions
15:18:11 <dcoutts> izukerman: do you get that when you cabal install binary directly? what does cabal --version say?
15:18:12 <Cale> wadcom: (not sure if that's the problem, but it seems possible)
15:18:21 <wadcom> ah, so they have to appear before _application_ of this function?
15:18:44 <Cale> wadcom: dumpWith f = {-# SCC "dumpWith" #-} ...
15:18:45 <EvilTerran> wadcom, putting it after the = would work, i think
15:18:58 <EvilTerran> not sure how that'll parenthesise
15:19:01 <wadcom> thanks, will try it out
15:19:14 <EvilTerran> but i'd hope it'd be {-# SCC "dumpWith" #-} (Data.Map.foldWithKey f [])
15:19:30 <EvilTerran> rather than ({-# SCC "dumpWith" #-} Data.Map.foldWithKey) f []
15:19:39 <wadcom> yes, it compiles
15:19:44 <wadcom> no parens needed
15:20:02 <binrapt> I am not sure I understand how return in Haskell works
15:20:09 <EvilTerran> wadcom, i mean, the implicit grouping. like operator precedence, only more like pragma precedence
15:20:14 <EvilTerran> binrapt, it's a function, no more
15:20:23 <EvilTerran> well, it's a function defined in a typeclass
15:20:27 <EvilTerran> ?type return
15:20:28 <lambdabot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
15:20:31 <EvilTerran> GAH
15:20:34 <EvilTerran> ?hoogle return
15:20:35 <lambdabot> A Hoogle error occurred.
15:20:39 <ski> return :: Monad m => a -> m a
15:20:40 <EvilTerran> ABANDON HOEP
15:21:00 <binrapt> It doesn't stop the execution at that point
15:21:04 <yitz> @info return
15:21:04 <lambdabot> return
15:21:05 <binrapt> So if you return a and return b
15:21:10 <EvilTerran> binrapt, no, it can't. it's a function.
15:21:11 <binrapt> What will the function return?
15:21:13 <EvilTerran> it's not a keyword.
15:21:27 <EvilTerran> functions don't "return" in haskell. they have a value for a given parameter.
15:21:28 <mmorrow> Cale: well, i don't see the compiler as being infallible nor having achieved all that can be achieved wrt a type system, so i would hope that it doesn't force its system absolutely upon me
15:21:28 <binrapt> The last one before the function ends?
15:21:42 <ski> binrapt : it might be nice if you paste any code you have problems with, or want commented ..
15:21:42 <EvilTerran> binrapt, no. "return" doesn't mean what it means in an imperative language.
15:21:45 <byorgey> binrapt: 'return' is a very unfortunate name.  it has nothing whatever to do with 'return' in other languages.
15:21:50 <ski> @hpaste
15:21:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:21:56 <Cale> oh, hmm
15:21:58 <Cale> That's odd
15:22:00 <EvilTerran> ski, ah, at least that one still works :P
15:22:01 <Cale> I should fix that
15:22:10 <binrapt> Hmm
15:22:24 <binrapt> http://hpaste.org/9967
15:22:41 <binrapt> I am currently trying to wrap my head around this example in YAHT
15:22:43 <EvilTerran> O.O
15:22:44 <binrapt> PDF hence formatting lost
15:22:46 <mmorrow> Cale: of course i'm talking in extremes/etc. i'm done. </asdf>
15:22:55 <EvilTerran> what the devil
15:23:28 <Cale> binrapt: Well, you understand what do-notation does, right? It takes a sequence of actions and turns them into a single action.
15:23:57 * EvilTerran tries to work out why there's a case with only one branch
15:24:09 <Cale> uh, yeah, that's... odd.
15:24:11 <rwbarton> is that in YAHT?  I can't imagine what indentation could make that program sensible
15:24:13 <EvilTerran> binrapt, is that your own code?
15:24:23 <binrapt> 00:22:34 <binrapt> I am currently trying to wrap my head around this example in YAHT
15:24:28 <EvilTerran> yeah
15:24:29 <EvilTerran> see
15:24:33 <EvilTerran> it doesn't make any sense :P
15:24:44 <ski> binrapt : it appears you forgot to paste indentation spaces (the code will not compile as written)
15:24:47 <Cale> That looks like possibly two different examples in YAHT smashed together?
15:24:54 <EvilTerran> as rwbarton says, there's no possible indentation that could make that meaningful
15:25:07 <EvilTerran> unless you count repeated use of backspace as indentation :P
15:25:18 <Cale> ehehe
15:25:25 <ski> binrapt : also, just maybe, you forgot to paste a `_ ->' part ?
15:25:32 <binrapt> http://hpaste.org/9968
15:25:55 <balbaroy> that code is just broken
15:25:55 <Cale> binrapt: yeah, that code is broken.
15:25:57 <rwbarton> that's the indentation I was guessing
15:25:59 <ski> (also, please, next time use the "annotate" feature of your original paste regarding a single problem)
15:26:00 <EvilTerran> binrapt, you're sure that's how it appears in YAHT?
15:26:11 <rwbarton> also doGuessing needs an argument in the if/else
15:26:11 <binrapt> Well it's supposed to be a broken example
15:26:20 <Cale> oh?
15:26:23 <binrapt> To show how return doesn't behave as it does in imperative languages
15:26:27 <EvilTerran> it's succeeded in that admirably
15:26:30 <binrapt> Oh
15:26:34 <EvilTerran> in that we have no idea what the heck is going on
15:26:35 <EvilTerran> ;)
15:26:36 <binrapt> Yeah
15:26:40 <binrapt> Lacks an argument heh
15:26:55 <Cale> ah, but it's more broken than that
15:27:34 <EvilTerran> ah, found it
15:27:35 <EvilTerran> http://en.wikibooks.org/wiki/Haskell/YAHT/Io
15:27:40 <EvilTerran> about half-way down
15:27:56 <binrapt> Heh
15:28:02 <EvilTerran> i must say, waving broken code at people in a tutorial for beginners sounds like a terrible idea
15:28:02 <Cale> Ew, who indented this with tab characters?
15:28:06 <binrapt> The PDF sucks I guess
15:28:10 <Cale> Please don't use tab characters!
15:28:17 <binrapt> I did
15:28:21 <binrapt> Spaces suck
15:28:22 <binrapt> Tabs rule
15:28:27 <EvilTerran> not for haskell they don't
15:28:37 <binrapt> How unfunctional.
15:28:38 <Myoma> anti-scub
15:28:54 <yitz> binrapt: same for Python :)
15:28:54 <mmorrow> ok i think i deciphered it
15:28:54 <EvilTerran> or python, or yaml
15:28:55 <mmorrow> http://hpaste.org/9967#a1
15:29:01 <binrapt> Yeah that's a huge mistake in python
15:29:09 <balbaroy> tabs are ok if you always start a new line before using layout
15:29:09 <EvilTerran> or anything else that's indentation-sensitive
15:29:22 <rwbarton> ("case compare ... of EQ -> ..." is the equivalent of "if (... == ...) ...?")
15:29:24 <Cale> binrapt: If you indent with anything but spaces, you'll run into problems.
15:29:27 <binrapt> I only knew one person who used spaces in python heh
15:29:28 <EvilTerran> binrapt, there you disagree with the designers of haskell
15:29:31 <binrapt> He ruined our project
15:29:39 <Cale> binrapt: You should configure your editor to convert tabs into spaces automatically.
15:29:43 <mmorrow> yeah, i dunno about what happens when it falls through the case
15:29:52 <binrapt> Cale no way, I had to fix that in the first place
15:30:07 <Cale> In fact, I think tabs should be rejected by the Haskell compiler outright.
15:30:08 <EvilTerran> well, we'll continue to have goes at you until you do
15:30:16 <mmorrow> i /despise/ '\t'
15:30:17 <EvilTerran> at least for the code you're showing us
15:30:17 <EvilTerran> :P
15:30:18 <lament> _everyone_ uses spaces in Python
15:30:26 <EvilTerran> what lament said
15:30:30 <balbaroy> I'll support him :-)
15:30:32 <MarcWeber> @seen edwardk
15:30:33 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:30:42 <mmorrow> preflex: seen edwardk
15:30:42 <preflex>  edwardk was last seen on #haskell 5 days, 22 hours, 23 minutes and 55 seconds ago, saying: lament: that reminds me of http://www.lisperati.com/landoflisp/
15:30:48 <Cale> binrapt: In any event everyone in Haskell-land uses spaces :)
15:30:59 <binrapt> Spaces are backward, I don't know why anybody would use them for BEGIN OF LINE indentation
15:31:07 <balbaroy> Cale: there are exceptions
15:31:07 <mmorrow> Cale: what a perfectly appropriate thing to emerge!
15:31:08 <binrapt> Only makes sense for in line indentation
15:31:12 <Cale> binrapt: The problem is that it's not indentation
15:31:12 <mmorrow> http://www.lisperati.com/landoflisp/
15:31:16 <Cale> binrapt: It's *alignment*
15:31:25 <lament> binrapt: everyone uses spaces in Python; if everybody on your project except one person used tabs, you're a bunch of wackos
15:31:28 <Cale> binrapt: You need to *line things up* in Haskell
15:31:31 <binrapt> Yes it is indentation and the wonderful thing is that you can configure it however you want
15:31:34 <balbaroy> binrapt: haskell doesn't have a fixed indentation structure
15:31:49 <binrapt> Good luck replacing the 4 space unit some guy used with your preferred 2, 3, 6 or 8 one
15:31:52 <balbaroy> i.e. you need to take care of that yourself if you use tabs
15:32:06 <binrapt> Without modifying the code.
15:32:11 <MarcWeber> Which is the type level natural number library performing best in .hi serialization, and eq comparison?
15:32:17 <balbaroy> binrapt: it doesn't work that way in haskell
15:32:20 <mmorrow> binrapt: i'd just parse the code and prettyprint it with my desired settings :)
15:32:20 <binrapt> Whereas with tabs this is not even a problem
15:32:23 <Cale> binrapt: The policy is not to care about how much something is indented so long as it is aligned correctly.
15:32:33 <mmorrow> (assuming it parses at all)
15:32:55 <binrapt> So how does Haskell treat them differently?
15:32:58 <MarcWeber> My .hi file is as big as 800k and ghc needs 3:30 min to create the binary..
15:33:23 <Cale> http://hpaste.org/9968#a2
15:33:23 <lament> binrapt: read what Cale said.
15:33:30 <rwbarton> binrapt: To be really concrete, the code you pasted at http://hpaste.org/9968 doesn't compile because the return () is not lined up right.
15:33:35 <Cale> Have a look at my (second) annotation there.
15:33:37 <balbaroy> binrapt: look at your code and how 'print' and 'doGuessing' start in the same column
15:33:41 <ddarius> How about we just make an onlyOnce IO action :: IO a -> IO a that runs the passed in action once the first time and then returns the same result from that time forward?
15:33:50 <binrapt> It's not my code :p
15:33:55 <balbaroy> IT IS NOW
15:34:05 <byorgey> hehe
15:34:22 <dons> dcoutts: yeah, it's a correctness issue though.
15:34:36 <dons> you can't use decodeFile properly on older bytestrings.
15:34:36 <binrapt> Yeah actually that does look strange
15:34:40 <binrapt> I have no idea why he did that
15:34:52 <dcoutts> dons: oh, I thought that was fixed in 0.9.0.1.1
15:34:52 <dons> i was acting with the thought ghc would be compiled against new bytestring.
15:34:54 <Cale> binrapt: The line after the first non-whitespace character after a 'do', 'let', 'where' or 'case', must start in the same column as that character.
15:35:00 <balbaroy> because that's how the syntax works
15:35:03 <Cale> (if it is to be included in the body of that)
15:35:03 <dons> dcoutts: hmm.
15:35:12 <Cale> binrapt: Therefore, if I write:
15:35:13 <dons> we need ghc to be using the new bytestring though.
15:35:14 <Cale> do foo
15:35:15 <binrapt> Cale oh that's terrible
15:35:16 <dcoutts> dons: 6.8.3 uses 0.9.0.1.1
15:35:24 <Cale> The next line must be indented to the same column as foo
15:35:26 <balbaroy> the first token after do/let/where/of determines the base indentation of its block
15:35:31 <Cale> in order to be part of the do block
15:35:35 <dons> dcoutts: investingating.
15:35:36 <ski> Cale : s/case/of/
15:35:41 <MarcWeber> ping edwardk
15:35:43 <Cale> ski: er, right
15:35:43 <binrapt> And it counts \t as one column?
15:35:51 <balbaroy> binrapt: no, 8
15:35:51 <dcoutts> dons: I'm not sure if that version does have the close on end of hGetContents fix
15:35:55 <binrapt> Ok
15:35:58 <Cale> \t counts as aligning to the next 8-space boundary
15:36:08 <dons> dcoutts: it made it into 0.9.0.3
15:36:21 <rwbarton> binrapt: you could write "do\n\tfoo\n\tbar" if you were feeling difficult (where the tabs are relative to the column containing do)
15:36:24 <dcoutts> dons: right, but 0.9.0.1.1 was after 0.9.0.4
15:36:29 <Cale> So "  \t" aligns to the same thing as "\t" assuming nothing before that on the line.
15:36:31 <mmorrow> binrapt: this has less duplication http://hpaste.org/9968#a3
15:36:36 <binrapt> I happen to always write do\n hm
15:36:37 <dons> dcoutts: unknown what 0.9.0.1.1 is though
15:36:41 <dcoutts> dons: but didn't contain the api changes that crept into 0.9.0.4
15:36:45 <dons> wasn't that just Igloo's silent tag of his fork.
15:37:04 <dcoutts> dons: yeah, but with some patches, it was not just 0.9.0.1 again
15:37:05 <Cale> binrapt: However, with let, it's more awkward that way.
15:37:14 <Cale> (well, it looks like hell)
15:37:15 <binrapt> That's really obscure, why would you force that on anybody?
15:37:29 <balbaroy> binrapt: you can always use { } instead
15:37:33 <dons> i don't like the patches that go into ghc's fork, but not upstream
15:37:34 <rwbarton> binrapt: It's not forced on anybody.  You can just use spaces. :)
15:37:35 <dons> like nhc compat.
15:37:44 <dcoutts> dons: yep, it's very annoying.
15:37:46 <Cale> It's not so obscure. You get used to it quickly, and yes, you can just use braces and semicolons
15:37:49 <dons> dcoutts: that patch isn't in ghc's fork.
15:38:04 <dcoutts> dons: what's worse, ghc head is not using bytestring head. It's got an incompatible fork.
15:38:10 <Cale> Don't use tabs though, they're pure evil.
15:38:23 <dons> yeah, it has some random version, by the looks of it, based on something from late last year.
15:38:25 <dcoutts> dons: incompatible in the sense that the two forks do not cleanly merge
15:38:28 <EvilTerran> haskell is a lot nicer to write if you don't use tabs, by most folks' opinions
15:38:34 <dons> there should be only 1 bytestring for 6.10
15:38:41 <dcoutts> dons: yes
15:38:51 <dons> yeah, random fork :(
15:38:54 <EvilTerran> that's what it boils down to, really
15:38:58 <binrapt> So you guys actually manually hit your space bar more than once? :p
15:39:01 <binrapt> Man that's outrageous
15:39:01 <Cale> binrapt: No
15:39:04 <balbaroy> I use spaces now but my style is still tabs-compatible
15:39:08 <binrapt> Why would anybody put up with that
15:39:10 <dons> binrapt: tab-expand, dude.
15:39:17 <EvilTerran> balbaroy, so is mine, mostly
15:39:18 <balbaroy> binrapt: get a real text editor
15:39:19 <Cale> binrapt: I configure my editor to insert spaces when I hit tab.
15:39:22 <EvilTerran> binrapt, that's a strawman argument
15:39:42 <Cale> binrapt: and typically, to delete multiple spaces when backspacing over them
15:39:51 <bjrn> Is this new bytestring strict or lazy?
15:39:59 <EvilTerran> many folk on here have their editor insert varying numbers of spaces
15:40:10 <EvilTerran> to line up with things on the line above
15:40:23 <Cale> Nobody will complain about how much you indented something so long as it all lines up correctly.
15:40:28 <EvilTerran> (these being the folks using emacs with haskell-mode)
15:41:09 <EvilTerran> (or yi, i think)
15:41:32 <Cale> http://hpaste.org/9968#a4 -- for example, this alternate indentation is also perfectly acceptable.
15:41:56 <Myoma> tabs just make it awkward
15:42:05 <Cale> (and is actually what I would probably write in most cases, unless the lines of my do-block were getting long)
15:42:12 <b\6> http://www.hpaste.org/9957 the indentation here is pretty cool too, cough. also, please run it and fix it.
15:42:36 <b\6> cuz it's ultra packaged to be convenient.
15:42:51 <binrapt> lol I'd rather use additional newlines and tabs
15:42:52 <binrapt> <3
15:43:04 <balbaroy> fine with me
15:43:13 <binrapt> I'll start a \t-Haskell movement
15:43:13 * EvilTerran wants an editor that works with the parse tree in some non-painful way
15:43:19 <EvilTerran> complete with equational reasoning
15:43:20 <EvilTerran> :D
15:43:34 <mmorrow> binrapt: err, actually http://hpaste.org/9968#a3 didn't reduce duplication, although i initially intended to do that and got stymied
15:44:14 <ski> EvilTerran : something like paredit for sexprs ?
15:44:31 <EvilTerran> ski, i'm not familiar with that, but potentially
15:45:00 <binrapt> @src putStrLn
15:45:00 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
15:45:08 <Cale> binrapt: It will fail.
15:45:20 <Cale> binrapt: (I can tell you right now. :)
15:45:30 <mmorrow> Cale: unsafePerformIO (putStr (repeat '\t'))
15:45:41 <mmorrow> :):)
15:46:05 <Cale> I would be happy with GHC treating a tab character as a lexical error.
15:46:12 <mmorrow> ahahha
15:46:14 <EvilTerran> ski, i guess that looks similar. the equational reasoning thing's the deal-breaker, though.
15:46:22 <Myoma> I would rather tab just got erased
15:46:24 <saya> @src putChar
15:46:25 <lambdabot> putChar c = hPutChar stdout c
15:46:25 <binrapt> > take 4 (repeat '\t')
15:46:26 <lambdabot>  "\t\t\t\t"
15:46:30 <binrapt> \o/
15:46:33 <saya> @src hPutChar
15:46:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:46:41 <saya> !
15:46:42 <binrapt> > repeat '\t'
15:46:43 <lambdabot>  "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\...
15:46:48 <binrapt> That creates an infinite list?
15:46:51 <EvilTerran> ski, potentially with the ability to use pseudo-haskell and then equational-reasoning it away
15:46:53 <saya> yea
15:46:55 <binrapt> Ok
15:47:01 <saya> > take 5 $ repeat '\t'
15:47:02 <lambdabot>  "\t\t\t\t\t"
15:47:03 <maukf> binrapt: well, a cyclic list
15:47:18 <maukf> you just can't see the difference
15:47:18 <EvilTerran> maukf, that's an implementation detail, though
15:47:19 <mmorrow> > cycle "\a"
15:47:20 <lambdabot>  "\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\...
15:47:21 <stepcut> how do I express this in template haskell, let _p = 'h' in _p
15:47:27 <binrapt> So it behaves like a normal []
15:47:31 <ski> EvilTerran : pseudo-haskell ?
15:47:32 <binrapt> It's just different internally?
15:47:32 <saya> that creates a cyclic list too?
15:47:39 <saya> > [1..]
15:47:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:47:51 <maukf> binrapt: it is a normal []
15:47:51 * stepcut wonders if he just does newName "_p"
15:47:55 <EvilTerran> ski, as in, things that aren't actually valid haskell, but conveniently express behaviour you want in your haskell program
15:47:57 <ski> EvilTerran : like defining equations that aren't valid as haskell definitions ?
15:47:59 <bjrn> > [10,9..]
15:48:01 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
15:48:24 <saya> binrapt it uses lazy evaluation so it doesnt evaluate the elements until you actually use them
15:48:24 <mmorrow> stepcut: [|'h'|]
15:48:27 <saya> so you can do like
15:48:30 <binrapt> Yeah
15:48:33 <saya> > take 10 $ [1..]
15:48:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:48:35 <maukf> binrapt: the C equivalent is struct node x = { '\t', &x };
15:48:36 <mmorrow> stepcut: or  [|let _p = 'h' in _p|]
15:48:51 <binrapt> What does that $ do?
15:48:57 <EvilTerran> ?src ($)
15:48:58 <lambdabot> f $ x = f x
15:48:58 <saya> it was useless here
15:49:01 <EvilTerran> nothing :)
15:49:11 <saya> but it avoids puting parethesis everywher
15:49:16 <EvilTerran> ($) f x = f x; ($) f = f; ($) = id
15:49:17 <saya> like ... hmmm
15:49:20 <EvilTerran> it literally does nothing :)
15:49:32 <saya> > putStrLn ("a" ++ "b")
15:49:34 <lambdabot>  mueval: Prelude.read: no parse
15:49:34 <lambdabot> mueval: *** Exception: "<IO ()>"
15:49:37 <binrapt> Syntactical sugar?
15:49:41 <saya> > putStrLn $ "a" + "b"
15:49:42 <lambdabot>      No instance for (Num [Char])
15:49:42 <lambdabot>       arising from a use of `+' at <interac...
15:49:44 <saya> yeah
15:49:44 <EvilTerran> no
15:49:45 <EvilTerran> operator
15:49:47 <mmorrow> > zipWith ($) (map (*) [0..]) (repeat 2)
15:49:49 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
15:49:53 <saya> well its uses as sugar :p
15:49:55 <saya> used
15:49:58 <EvilTerran> however, it has very low precedence, so it saves you having to put brackets in where you would have to otherwise
15:50:00 <stepcut> mmorrow: thanks,  forgot all about using [| |] to see how it looks in TH
15:50:10 <rwbarton> b\6: I can give you an educated guess as to what's wrong
15:50:14 <binrapt> I see
15:50:18 <b\6> rwbarton: <3.
15:50:25 <EvilTerran> means you don't end up with "))))))))" at the end of a complicated expression
15:50:26 <mmorrow> stepcut: heh, they're *crucial* to ease of use :)
15:50:39 <EvilTerran> mmorrow, yeah, that's definitely true
15:50:41 <rwbarton> b\6: Well, "A Stream instance is responsible for maintaining the "position within the stream" in the stream state s. This is trivial unless you are using the monad in a non-trivial way."
15:50:44 * EvilTerran still wants [p|...]
15:50:48 <Cale> > map head . group . sort $ [1,3,1,32,5,12,4,1,3,5,2,6,2,4]
15:50:50 <lambdabot>  [1,2,3,4,5,6,12,32]
15:51:09 <b\6> rwbarton: yeah, read that a million times. but i don't know what i could/would do differently in my Stream.
15:51:21 <b\6> rwbarton: because parsec doesn't tell me anything went wrong.
15:51:24 <b\6> uncons is it.
15:51:37 <rwbarton> b\6: As I read it that means that value contained in the result of  uncons s  should be the same if you execute it more than once
15:51:42 <shepheb> > 1 + 1
15:51:44 <lambdabot>  2
15:51:46 <binrapt> > [2, 3, 5, 7, 11..]
15:51:46 <lambdabot>  Parse error at "..]" (column 16)
15:51:55 <binrapt> :[
15:51:58 <b\6> rwbarton: but how would it make any progress if i always uncons the same thing?
15:51:58 <shepheb> can someone with \bot powers get her to join #xmonad?
15:52:04 <EvilTerran> > [1,3..]
15:52:05 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
15:52:05 <maukf> > S.toList.S.fromList$[1,3,1,32,5,12,4,1,3,5,2,6,2,4]
15:52:07 <lambdabot>  mueval: Prelude.read: no parse
15:52:08 <Cale> > extendSequence [2,3,5,7,11]
15:52:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:52:15 <binrapt> Cale awesome :D
15:52:17 <mmorrow> > let (..) = 1 in (..)
15:52:18 <lambdabot>  Parse error at "..)" (column 6)
15:52:21 <rwbarton> b\6: when it succeeds in consuming a token, it uses the new stream contained in the other half of the pair
15:52:25 <Cale> binrapt: oeis module :)
15:52:27 <EvilTerran> (..) is a reserved op
15:52:28 <saya> > 2:3:5:7:[11..]
15:52:30 <lambdabot>  [2,3,5,7,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,3...
15:52:33 <saya> fail :(
15:52:36 <binrapt> Haha
15:52:39 <Cale> binrapt: It's only slightly evil :)
15:52:39 <saya> extend sequence nice
15:52:46 <binrapt> What a hack
15:52:53 <Cale> > extendSequence [1,1,2,3,5]
15:52:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:52:59 <rwbarton> b\6: but when it backtracks (e.g., when "many" tries to read a token and fails) it probably reuses the previous value of the stream
15:53:00 <b\6> rwbarton: ok, i see the difference. but what can i do? it'd be really useful. i can't believe nobody cares.
15:53:01 <saya> > extendSequence [2,7,4]
15:53:03 <lambdabot>  [2,7,4,2,7,4,6]
15:53:03 <EvilTerran> Cale, hah, that's ingenius
15:53:07 <mmorrow> > let (...) x = repeat x in map (take 4 [0.., 1..])
15:53:08 <lambdabot>  Parse error at "," (column 43)
15:53:10 <ivanm> Cale: is there a reason lambdabot isn't in #xmonad?
15:53:10 <rwbarton> b\6: Well, you can fix it using unsafeInterleaveIO
15:53:14 <mmorrow> > let (...) x = repeat x in map (take 4 [0..., 1...])
15:53:14 <lambdabot>  Parse error at "," (column 44)
15:53:15 <binrapt> saya I don't even know what that is lol
15:53:16 <Cale> ivanm: I don't know.
15:53:16 <rwbarton> b\6: which I guess you don't want to do
15:53:18 <binrapt> I'd have to Sloane it
15:53:22 <b\6> rwbarton: yeah, trying to avoid unsafe*.
15:53:25 <mmorrow> > let (...) x = repeat x in map (take 4 [(0...), (1...)])
15:53:26 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[[t]]'
15:53:29 <ivanm> Cale: aren't you in charge of her? :o
15:53:30 <saya> its nothing
15:53:36 <binrapt> Oh.
15:53:38 <Cale> ivanm: hmm
15:53:39 <saya> :p
15:53:40 <r3m0t> @src extendSequence
15:53:40 <lambdabot> Source not found. Are you on drugs?
15:53:47 <Cale> #xmonad is still in the list of channels to join...
15:53:57 <b\6> why does lambdabot get so pissed about unfound sources?
15:53:59 <mmorrow> > let (!) x = x*2 in (2!)
15:54:00 <Cale> lambdabot: @join #xmonad
15:54:01 <lambdabot>  4
15:54:10 <mmorrow> > let (...) x = x*2 in (2...)
15:54:11 <rwbarton> b\6: could you (not using parsec, but manually) read the socket with a timeout, split the result into \r\n-terminated "lines", and then feed those to parsec one-by-one?
15:54:11 <lambdabot>  4
15:54:27 <mmorrow> > let (...) x = repeat x in (2...)
15:54:28 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
15:54:37 <b\6> rwbarton: yes, but it makes the parsing unnatural. hoping i can do it the cool way.
15:54:43 <mmorrow> > let (...) x = repeat x in map (take 10) [(2...),(3...)]
15:54:43 <saya>  ['a'..'z']++['A'..'Z']
15:54:45 <lambdabot>  [[2,2,2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3,3,3]]
15:54:46 <saya> >  ['a'..'z']++['A'..'Z']
15:54:48 <lambdabot>  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
15:54:58 <Cale> > describeSequence [2,7,4]
15:55:00 <lambdabot>  Just "Decimal expansion of e."
15:55:03 <Cale> hmm
15:55:03 <b\6> rwbarton: everyone writing parsec parsers would say it's a 'document' that has 'lines' etc. not get lines and parse them individually.
15:55:07 <EvilTerran> hehehe
15:55:07 <jeffz> hiya b\6
15:55:12 <Cale> oh, right, that uses a different method
15:55:14 <Cale> heh
15:55:17 <b\6> jeffz: hey.
15:55:22 <Cale> It really should use the commas :)
15:55:36 <EvilTerran> Cale, are those using unsafePerformIO to access a database, or loading the whole durn thing into memory?
15:55:44 <Cale> EvilTerran: unsafe IO
15:55:47 <rwbarton> b\6: ok, but what if there's an parse error on the 1000th line?  then your overall parse should return some kind of failure
15:55:49 <EvilTerran> yaaay
15:55:53 <saya> > foldr [] (\x y ['a'..'z'] ['A'..'Z']
15:55:54 <lambdabot> Unbalanced parentheses
15:55:54 <rwbarton> b\6: but you haven't even gotten that line yet, so...
15:55:55 <saya> oosp
15:55:59 <saya> hit enter by mistake
15:55:59 <Cale> EvilTerran: Yeah, it's pretty evil :)
15:56:01 <ivanm> Cale: :o no wonder lambdabot is having stability issues! :p
15:56:01 <EvilTerran> let's argue about unsafe IO some more!
15:56:23 <saya> how would i go an do aAbBcCdD given ['a'..'z'] and ['A'..'Z']
15:56:29 * EvilTerran wonders if ivanm's next line will involve :q and :r
15:56:32 <b\6> rwbarton: it's ok. the Nothing gets to parsec and it thinks it came to the end of input. it's just a parse error instead of a hang/block.
15:56:34 <Cale> ivanm: did lambdabot join okay?
15:56:37 <Cale> ivanm: hmm
15:56:40 <ivanm> Cale: nope :s
15:56:41 <Cale> it seems that it didn't...
15:56:45 <EvilTerran> :t
15:56:46 <aeolist> noes it didnt
15:56:49 <aeolist> she is mad at you
15:56:52 * ivanm doesn't know what EvilTerran is talking about...
15:56:53 <rwbarton> b\6: sorry, I wasn't very clear.
15:57:04 <EvilTerran> ivanm, really? funny that you went for :s, then
15:57:10 <rwbarton> b\6: parsec doesn't know whether it's going to return a Left ... or a Right ... until it has checked that the entire document contains no errors
15:57:23 <rwbarton> b\6: I assume you want to be able to take some action after receiving only part of the document though
15:57:24 <ivanm> I've never seen :q or :r emoticons...
15:57:33 <ivanm> looked more like vim keybindings ;-)
15:57:42 <EvilTerran> <ivanm> ... :o ... :p * EvilTerran ... :q ... :r <ivanm> ... :s <EvilTerran> :t
15:57:45 <rwbarton> b\6: that's why I suggest splitting it into lines before feeding them to parsec
15:57:48 <ivanm> EvilTerran: ahhhh
15:57:49 <jeffz> rwbarton: you don't need to check an entire document at once, you can return the remaining input after partially consuming the stream
15:57:56 <ivanm> heh
15:57:57 <EvilTerran> ^.^
15:58:07 <ivanm> >_>
15:58:11 <b\6> rwbarton: if a parse is incomplete, it's ok for me to just see the Left and reconnect and retry or whatever.
15:58:36 <rwbarton> jeffz: OK, but then the format that parsec is reading isn't the whole document with multiple lines, so I don't see how the "the cool way" argument applies
15:58:39 <r3m0t> _._
15:59:05 <Cale> ...
15:59:13 <saya> > { let test (x:xs) (y:ys) = x:y:test xs ys ; test [] ys = ys ; test xs [] = xs ; test [] [] = [] ) ; test ['a'..'z'] ['A'..'Z'] }
15:59:25 <jeffz> rwbarton: in this case, some parts that it consumes are over multiple lines, so splitting the input before handing it to parsec can't make sense
15:59:29 <Cale> odd
15:59:35 <EvilTerran> > concat . transpose $ zip ['a'..'z'] ['A'..'Z']
15:59:39 <Myoma> > zip ['a'..'z'] ['A'..'Z']
15:59:44 <saya> oh :p
15:59:45 <EvilTerran> er, not zip
15:59:58 <saya> is the bot dead?
16:00:01 <rwbarton> ah
16:00:01 <b\6> jeffz: did you see the hpaste with the code? http://www.hpaste.org/9957
16:00:04 <r3m0t> zipWith (\x y -> [x,y])
16:00:10 <EvilTerran> > concat . transpose $ [['a'..'z'], ['A'..'Z']]
16:00:14 <jeffz> b\6: not yet
16:00:19 <lambdabot>  "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
16:00:22 <izukerman> dcoutts: sorry, had to go for a bit
16:00:29 <izukerman> cabal install binary works
16:00:31 <rwbarton> b\6: here is a suggestion: you can use something like (Handle, IORef [Char]) as your stream
16:00:38 <ski> > concatMap (\(x,y) -> [x,y]) (['a'..'z'] `zip` ['A'..'Z'])  -- another variant for saya
16:00:38 <Cale> oh, I see...
16:00:41 <Cale> wtf...
16:00:43 <lambdabot>  "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"
16:00:44 <saya> neat
16:00:49 <izukerman> cabal-install version 0.5.2
16:00:50 <Cale> It's not being registered with services.
16:00:54 <izukerman> using version 1.4.0.2 of the Cabal library
16:00:59 <r3m0t> > let f x y = x++y++x in f (succ ';') (succ '^')
16:00:59 <rwbarton> @type <**>
16:01:06 <Myoma> > (uncurry ((++)`on`return)) =<< zip ['a'..'z'] ['A'..'Z']
16:01:29 <dcoutts> izukerman: can you still reproduce the problem then?
16:01:35 <izukerman> yes
16:01:44 <rwbarton> @type (+)
16:01:45 <b\6> rwbarton: uncons would check the ioref for data and try to get more if it was empty?
16:01:50 <izukerman> "There is no available version of base that satisfies >=2.0 && <2.2 && >=3.0 && >=2.0"
16:01:51 <lambdabot> Plugin `type' failed with: imports.h: openFile: does not exist (No such file or directory)
16:01:55 <rwbarton> b\6: yeah...
16:01:58 <EvilTerran> > concat $ zipWith ((++)`on`pure) ['a'..'z'] ['A'..'Z']
16:01:59 <Cale> ....
16:02:05 <b\6> rwbarton: that sounds good.
16:02:05 <bjrn> Is there a prelude function I can use to do this? (\(x, y) -> (f x, g y))
16:02:05 <Cale> how the...
16:02:10 <rwbarton> b\6: I'm not entirely sure that would really work though
16:02:11 <izukerman> is there some way to get cabal install to tell me how it comes up with these dependencies?
16:02:20 <r3m0t> bjrn: hoogle to the rescue (the answer is no)
16:02:24 <saya> what does pure do?
16:02:26 <dcoutts> izukerman: use --dry-run -v
16:02:27 <ivanm> Cale: what's animaforge.net anyway? why isn't lambdabot running from *.haskell.org anymore? so that she doesn't bring down the whole server? :P
16:02:28 <saya> :t pure
16:02:31 <r3m0t> @hoogle (a -> b) -> (a,a) -> (b,b)
16:02:36 <EvilTerran> saya, the same as return, basically
16:02:43 <EvilTerran> it's just for Applicative instead of Monad
16:02:44 <newsham> bjrn:  first f >>> second g   ?
16:02:44 <Cale> ivanm: It's lispy's computer
16:02:45 <saya> oh ok
16:02:48 <EvilTerran> closely related
16:02:50 <ivanm> Cale: ahhh
16:02:50 <rwbarton> b\6: I think you need a list made out of IORefs, i.e. IORefList a = Null | Cons a (IORef (IORefList a)) or similar
16:02:51 <maukf> bjrn: looks like (***)
16:02:57 <EvilTerran> bjrn, newsham, that'd be (***)
16:02:58 <newsham> ?type \f g -> first f >>> second g
16:03:11 <newsham> et: danke, i can never remember that one
16:03:13 <Cale> ... it seems that lambdabot survives me killing its screen session somehow sometimes
16:03:19 <Cale> very odd
16:03:26 <b\6> haskell's just that good.
16:03:28 <b\6> very robust.
16:03:29 <ivanm> :o
16:03:35 <jeffz> b\6: did you try dons's suggestion of using Data.ByteString.Lazy?
16:03:37 <ivanm> b\6: lol
16:03:41 <r3m0t> bjrn: yeah, I guess you want (f *** f)
16:03:47 <bjrn> Cheers, will check it out
16:03:48 * lispy thought 'animaforge' had a cool sf.net knock off name for aspiring machinamists...but sadly never made it further than registering the domain
16:04:03 <izukerman> cabal install yi -v posted to hpaste
16:04:06 <r3m0t> but, Control.Arrow seems a long way to go for something so simple...
16:04:14 <b\6> jeffz: tried, but wasn't sure how to do it. it's really good that it doesn't block, but .. how does it work in the Stream?
16:05:23 <b\6> jeffz: filling an ioref if it's empty? otherwise, returning the head?
16:05:38 <Myoma> I added support of unary operators and fixities
16:05:45 <b\6> jeffz: last night i also wasn't sure whether parsec somehow looked ahead in the "rest" part.
16:05:48 <Myoma> to my printer but I don't know if it's correct
16:05:56 <Myoma> seems to work :/
16:06:56 <b\6> sometimes i make variables f and ck and find some reason to multiply them like f*ck if i'm having a bad day.
16:07:31 <saya> >foldr (\x y -> x y) "megastring" (take 20 (repeat show))
16:07:32 <newsham> ?let ck = "charlie"
16:07:39 <newsham> > f*ck
16:07:41 <ivanm> no bot
16:07:47 <saya> > foldr (\x y -> x y) "megastring" (take 5 (repeat show))
16:07:58 <maukf> preflex: remember b\6 sometimes i make variables f and ck and find some reason to multiply them like f*ck if i'm having a bad day.
16:08:00 <newsham> b\6: how do you feel when it retorts "type error"?
16:08:13 <b\6> EVEN WORSE.
16:08:29 <ddarius> f unsafeCoerce ck
16:09:04 <ddarius> or f `unsafeCoerce` ck
16:09:13 <rwbarton> ddarius: please!
16:09:16 <r3m0t> ohShitMyTypesAreAMessTransformer = unsafeCoerce
16:09:20 <rwbarton> ddarius: don't use language like unsafeCoerce here :)
16:09:52 <newsham> let u = unsafeCoerce
16:10:27 <dcoutts> izukerman: it seems to be selecting bytestring-in-base=true
16:10:32 <Myoma> fix (unsafeCoerce . unsafePerformIO)
16:11:25 <dcoutts> izukerman: could you send me a copy of your global and per-user package db so I can precisely reproduce the bug?
16:11:49 <izukerman> dcoutts: send  where to?  hpaste?
16:12:05 <dcoutts> izukerman: run ghc-pkg list, it tells you the file names. Send to duncan at haskell.org
16:12:44 <saya> > (\(c:f:k:u:[]) -> f:u:c:k:[])  [ x | x <- ['a'..'z'], elem x "ukfc"] ]
16:13:00 <b\6> YEAH!!!!
16:13:24 <saya> waiting for the bot here!
16:13:25 <ivanm> OK, I think we're going slightly silly here...
16:13:33 <ivanm> saya: bot's dead...
16:13:43 <saya> oh
16:13:50 <ivanm> she ran away after seeing what you wanted her to evaluate :p
16:14:11 <saya> damn ! at least ghci stood up for it
16:16:04 <binrapt> I don't really grasp the return statement yet - what does it really do and what does it even have in common with the normal value of a function it evaluates to?
16:16:14 <newsham> ?src [] return
16:16:23 <maukf> binrapt: 'return' is a virtual constructor
16:16:32 <saya> return takes a value and lifts it into the monad
16:16:34 <maukf> it has nothing to do with "return values"
16:16:41 <saya> like return "a" -> IO "a"
16:16:43 <newsham> return :: Monad m => a -> m a
16:16:45 <saya> no
16:16:53 <maukf> also, it's not a statement
16:17:08 <rwbarton> b\6: so, I think what you want may be exactly (Handle, Chan Char)
16:17:09 <saya> like for Maybe     return a = Just a
16:17:37 <EvilTerran> > return 1 :: Maybe Int
16:17:40 <saya> its part of the monad class with (>>=)
16:17:45 <EvilTerran> grr
16:18:13 <b\6> rwbarton: ok, i've never looked at Chan. thanks for working on it and suggesting stuff.
16:18:20 <b\6> rwbarton: checking on Chan.
16:18:26 <rwbarton> b\6: np.  Your advertisement was amusing :)
16:18:38 <newsham> return can turn 1 to [1], or Just 1, or an IO action which does nothing but results in the value 1, or a State action which propogates the current state and sets the result value to 1
16:18:51 <EvilTerran> or the function const 1
16:18:57 <b\6> i try to at least be dumb in an entertaining way.
16:19:08 <EvilTerran> or ([], 1)
16:19:45 <newsham> there are a number of examples here:  http://www.haskell.org/haskellwiki/MonadPrimer
16:19:45 <ski> or `($ 1)'
16:19:49 <saya> @ src const
16:19:54 <saya> what does const do?
16:19:57 <ski> const c x = c
16:19:58 <EvilTerran> ski, ... really?
16:20:18 <newsham> (const 5) 1235    evaluates to 5
16:20:20 <dibblego> const is the 'k' in ski
16:20:24 <ski> EvilTerran : well .. modulo some irritating `newtype' constructor :)
16:20:31 <EvilTerran> ... which one's that?
16:20:36 <saya> um so what do you use it for?
16:20:40 <Deformalite>  I know this isn't the right channel, but can anyone recommend a creditable source regarding s and k combinators?
16:20:48 <Deformalite> Or a channel that it owuld be proper to discuss that in?
16:20:55 <ski> Cont :: ((a -> o) -> o) -> Cont o a
16:20:57 <maukf> s = ap; k = const
16:21:00 <EvilTerran> ahh, cont
16:21:01 <dibblego> saya, if you ever write \_ -> x, you can also write const x
16:21:08 <newsham> saya: sometimes when you chain together a bunch of monadic actions you want to construct a result from all of your collected intermediate values.   return is useful for that.
16:21:16 <saya> oooh ok
16:21:18 <rwbarton> binrapt: the short version for the IO world is that you use return whenever you would just like to have a value, but the context requires an action.
16:21:38 <newsham> like:   do { x <- act; y <- act; return (x + y) }
16:21:44 <saya> yeah i know return
16:21:50 <saya> its the const i didnt know abou
16:21:52 <saya> t
16:21:55 <newsham> oh.. sorry :)
16:22:02 <lilac> why isn't there a instance (Monoid m) => Monad (m (,))?
16:22:08 <saya> still fairly new to haskell jsut grasping the concept of monads :p
16:22:19 <Cale> lilac: Monad ((,) m) you mean?
16:22:20 <dibblego> saya, you can write it yourself, start with a function const' :: a -> b -> a and try to implement it, there is only one way
16:22:21 <Deformalite> ski: Judging by your nick, maybe you can help me?
16:22:24 <newsham> lilac: hmm.. that sounds familiar.. maybe one of conal's libs has that?
16:22:35 <EvilTerran> lilac, newsham: it's in Control.Monad.Instances
16:22:37 <EvilTerran> i believe
16:22:42 <Cale> lilac: isn't there such an instance in Control.Monad.Writer/Instances?
16:22:55 <newsham> et: ahh
16:23:26 <saya> const = (\x -> x) ?
16:23:30 <Cale> huh, maybe there isnt'
16:23:36 <Cale> isn't*
16:23:44 <Cale> saya: const x y = x
16:24:07 <saya> ok !
16:24:07 <wadcom> profiling issue, http://hpaste.org/9971
16:24:43 <newsham> const x = (\y -> x)     sometimes seems to make more sense
16:25:00 <Myoma> if you look at the type :: a -> b -> a
16:25:02 <dibblego> or const x = \_ -> x
16:25:04 <Cale> wadcom: my guess would be that it's ++
16:25:06 <ski> Deformalite : possibly you can look up the papers on Combinatory logic by Haskell B. Curry ?
16:25:31 <Deformalite> ski: Are they available online?
16:25:41 <wadcom> cale: yes, but my goal is to see the numbers supporting this claim
16:25:43 <Cale> wadcom: ++ takes time linear in the length of its first arg
16:25:44 <ski> i don't know, i haven't looked
16:25:47 <Deformalite> I don't think curry ever got into s and k, did he?
16:25:47 <stepcut> Haskell B. Curry? That can't be a real name.
16:25:55 <Myoma> lol
16:25:56 <Deformalite> stepcut: Of course it is.
16:26:02 <stepcut> :p
16:26:03 <Deformalite> That's who Haskell is named after..
16:26:29 <stepcut> ;)
16:26:45 <r3m0t> and what currying is names after
16:27:01 <r3m0t> d
16:27:12 <Spark> he also invented a delicious meal
16:27:22 <stepcut> and B is a (grand ?)-parent of C
16:27:25 <saya> chicken curry?
16:27:49 <stepcut> @quotes curried chicken
16:27:52 <wadcom> cale: so how do I go about profiling it further?
16:27:54 <stepcut> @quote curried chicken
16:27:54 <BMeph> saya: Naugh, he was rather brave. ;)
16:27:59 <r3m0t> no, fmap soup of course
16:28:13 * stepcut notes that she ain't her
16:28:19 <stepcut> s/her/here/
16:28:26 <newsham> step: B is the direct parent of C.
16:28:54 <stepcut> newsham: BCPL -> B -> C ?
16:29:00 <saya> yep
16:29:16 <Cale> wadcom: Well, what if you move the SCC's into the functions in the where?
16:29:29 <wadcom> cale: tried that, same thing
16:29:33 <Cale> wadcom: odd.
16:29:36 <newsham> stepcut: lots of great info on the subject here: http://cm.bell-labs.com/who/dmr/index.html
16:29:38 <saya> i saw they were implementing lots of functional programming stuff in c++0x instead it take 5 more lines per word
16:29:44 <Cale> wadcom: are you compiling with or without -On ?
16:29:52 <wadcom> cale: without
16:29:56 <Cale> hmm
16:30:23 <Myoma> yeah it's really ridiculous
16:30:35 <Myoma> all these languages are taking functional programming features
16:30:50 <Myoma> -- they should just program in a functional language instead
16:30:54 <lilac> stepcut: if you think Haskell B Curry is hard to believe, my former boss was called Jonny B Reckless
16:31:02 <stepcut> lilac: heh
16:31:10 <saya> well its a step in the right direction :p getting people used to it
16:31:13 <ddarius> Myoma: The language should just program in a functional language instead?
16:31:34 <Myoma> I don't agree
16:31:51 <Myoma> the people that want to use functional features
16:32:04 <Myoma> in C++ or Java
16:32:12 <Myoma> why not use haskell instead ?
16:32:20 <newsham> because they dont want ot use haskell
16:32:20 <saya> well if your an experience C++ programmer  you still get to use all you know
16:32:26 <saya> *experienced
16:32:31 <newsham> and/or they arent allowed to use haskell
16:32:32 <Myoma> it just seems silly to me that's all
16:32:53 <newsham> i know, i cant believe other countries take words like "CD" and dont just adopt english wholesale
16:32:57 <newsham> fools.
16:33:00 <saya> well c++ is multi paradigm so you get to chose when you want to use each style
16:33:12 <r3m0t> except functional
16:33:13 <ddarius> newsham: They don't?
16:33:17 <r3m0t> C++ functional is terrible
16:33:19 <saya> you can with boost
16:33:30 <newsham> ddarius: well, they do, but then they pretend not to know it when you talk to them
16:33:32 <saya> its a bit ugly but you can :p
16:33:38 <Cale> saya: In a horribly broken way with basically no guarantees, last I checked :)
16:33:43 <ddarius> newsham: Ah, is that what they are doing.
16:33:46 <rwbarton> wadcom: I have little experience with the profiler, but I think you want to use foldr ilItemToStr instead of foldl ilItemToStr.
16:34:05 <Myoma> another view is, Why increase the complexity of the language instead of using a simpler one
16:34:06 <newsham> ddarius: could just be a reflection on my personality
16:34:23 <Cale> "You can program in any idiom you want, so long as that idiom doesn't involve placing any guarantees on what your code actually does!"
16:34:23 <saya> because everybody is using c++
16:34:24 <rwbarton> wadcom: (Or better use concatMap which has already figured this out for you)
16:34:25 <Myoma> why write in the fp fragment of C++ + fp instead of just haskell?
16:34:29 <saya> yeah
16:34:44 <saya> you still get the ugly bugs and 100 line long compiler errors
16:34:44 <Myoma> this is what I do not get
16:34:45 <mwc> Are there any good idioms to squelch type defaulting warnings in point free code?
16:34:52 <wadcom> cale: ok, I guess I'll post it to the list
16:34:54 <mmorrow> b\6: here's one alternative http://hpaste.org/9957#a1
16:35:09 <mwc> I keep converting it to pointfulness so I can assign type decls on the bound points
16:35:11 * ddarius thinks a bird just flew into his window.
16:35:30 <Cale> wadcom: yeah, I have no idea. I would probably attack that foldl first though.
16:35:39 <Myoma> mwc: -fno-monomorphism-restriction I think ?
16:35:39 <Myoma> does that not work
16:35:39 <saya> what id like to see in haskell is contract programming it would go well with all the static type thing
16:35:43 <Cale> wadcom: also, try compiling with -O2?
16:35:54 <mwc> Other than using . (ceiling :: Double -> Int) .
16:35:56 <mwc> I guess that's not so bad
16:36:01 <Myoma> yuck
16:36:03 <mwc> Myoma: oh, no, it's not the monomorph
16:36:05 <Cale> (At least, if the goal is not just to make it faster, but fast enough...)
16:36:12 <Myoma> mwc: If you are using numbers in haskell then that is the problem right there
16:36:29 <BMeph> saya: contract programming is kind of superfluous with Haskell.
16:36:44 <chrisdone> ddarius: let me guess, now it's on fire
16:36:48 <mwc> what I mean is that the type system is giving warnings about defaulting an Integral constraint to Integer, etc
16:36:52 <Myoma> saya: I just want to see people using sensible tools for what they're doing
16:37:08 <ddarius> chrisdone: Possibly.  I don't know where it is.
16:37:13 <saya> BMeph: well say you want a function that takes only > 0 ints but you dont want to define a new type etc?
16:37:15 <Cale> saya: Types are contracts. What you're really saying is that the type system should be more expressive.
16:37:20 <b\6> mmorrow: thanks very much for working on it. i'll study. but i'm trying to avoid hGetLine because there's no way to specify max number of characters to read.
16:37:23 <saya> well maybe im not experienced enough to know wha tim talking about
16:37:39 <chrisdone> ddarius: can you ping it?
16:37:50 <Cale> saya: Types are actually theorems which the compiler is required to statically prove about the code which you've written.
16:38:25 <SamB> unfortunately in Haskell there's a really big caveat to each theorem ...
16:38:32 <saya> yeah but its hard to like say i want to return an ordered list so that the next function can assume the list is ordered without defining a new type
16:38:52 * wadcom notes that his intention with http://hpaste.org/9971 was not optimizing code, but learning to get more relevant info from the profiler
16:39:02 <newsham> let caveat = fix id
16:39:04 <Cale> saya: You can define an ordered list type and ensure that the means of constructing values of that type don't produce unordered lists.
16:39:06 <Myoma> saya, it should be very awkward if you knew a list was sorted but the type system doesn't though
16:39:43 <Myoma> saya, or maybe that being awkward is a bigger problem ...
16:39:57 <SamB> saya: that kind of thing is a bit of a pain even in languages that support it
16:40:05 <saya> hmmm, i see
16:40:14 <SamB> (Haskell doesn't really)
16:40:21 <Myoma> SamB: Do you think it must be a pain?
16:40:22 <mmorrow> b\6: i see. is the num chars to read dependent on the result of the parse?
16:40:23 <Cale> saya: Being able to say that, for instance, a sort function would sort a list, for example, is rather tricky, but can be done in dependent type systems. (and, theoretically in GHC Haskell, if you're willing to go to enough trouble)
16:40:38 <saya> but if your writing some big application, it can help alot to tell in the language what the functions do and what they assume etc
16:40:42 <SamB> Myoma: I think the pain can be reduced
16:41:10 <SamB> Cale: it's a heck of a lot easier to prove in Coq though
16:41:10 <Cale> saya: The question is a matter of balance between specifying things which are easy to express without just writing the whole thing multiple times :)
16:41:16 <Cale> SamB: right :)
16:41:50 <rwbarton> saya: If you want something like contracts, you can write newtype OrderedList a = OrderedList [a], hide that constructor, write orderedList :: (Ord a) => [a] -> OrderedList a that checks the order, and a deconstructor
16:41:51 <Cale> In Haskell, the balance point is usually chosen such that type inference still generally works.
16:42:07 <SamB> saya: but generally you would be defining a type for the concept of sorted
16:42:09 * EvilTerran is reminded of some paper he saw in here recently about using witnesses in haskell
16:42:10 <saya> yeah but it just took you 10 lines of code instead of 1 for example
16:42:19 <b\6> mmorrow: no, they don't give any hint how much stuff there is to parse. it's an old text protocol with \r\n lines kind of like smtp. i just view hGetLine as unsafe to use with possibly hostile data.
16:42:24 <EvilTerran> i forget if it worked out significantly nicer than using newtypes like that
16:42:30 <rwbarton> (run-time checked contracts, of course)
16:42:34 <Myoma> saya: 'it' is different in each case
16:42:42 <b\6> you guys want to join my band Hostile Data?
16:42:44 <Myoma> saya: in one case you have a one liner sort -- and you know it works
16:42:52 <saya> well maybe my example was a bad one
16:42:55 <Myoma> saya: in the other case you have a 10 line sort -- but the computer knows it works
16:43:13 <chrisdone> b\6: I think you're selling out, laying down and sucking up to the man
16:43:15 <mmorrow> b\6: ah, i gotcha. interesting.
16:43:16 <saya> yeah indeed
16:43:49 <b\6> chrisdone: he / was ogt / back in '93
16:43:53 <Myoma> saya: I'm not sure what that means, life if you have a program using a large set of libraries, what would be gained?
16:44:25 <chrisdone> b\6 ;)
16:44:32 <Peaker> I think that in order to have effective proof-carrying code, we're going to need more advanced IDE's than text editors with some elisp/macro hacks :-)
16:44:35 <mmorrow> b\6: oh snap
16:44:41 <saya> well hmmm ... you have a function that wants a non empty list like head or take i dont remember
16:44:57 <Pseudonym> Peaker: Have you heard of Cogito Ergo Sum?
16:45:05 <Pseudonym> It was some clever research back in the 90s.
16:45:05 <chrisdone> > take 9000 []
16:45:08 <saya> so you could specify    take requires length xs > 0
16:45:16 <Peaker> Pseudonym: nope, what's that?
16:45:18 <Pseudonym> And it was essentially what you say.
16:45:26 <ski> > take 0 undefined
16:45:31 <chrisdone> is there a page that says what the status of lambdabot is?
16:45:33 <SamB_XP> Peaker: depends what you mean by "hacks"
16:45:42 <Peaker> Pseudonym: I found that virtually noone is willing to let go of the text-editing conception for editing code
16:45:47 <Pseudonym> You typed your code, and provided theorems, and if the editor discovered something that it couldn't prove, it wouldn't accept your program until you justified it.
16:46:00 <Pseudonym> Let me see if I can find a paper.
16:46:01 <chrisdone> I could grep the logs but I'm not sure I'd find a coherent explanation
16:46:14 <SamB_XP> Peaker: though basically I agree, the editor must move on
16:46:51 <Peaker> SamB_XP: I am not sure why people are convinced that character manipulations on screen are the best UI to interface with semantic manipulations, which is what you really want to do
16:47:16 <b\6> been really hating the way vim retardedly tries to format code. the scripts are really bad and it's not surprising at all it gets bad results.
16:47:29 <Myoma> b\6: emacs isn't very good either..
16:47:33 <Pseudonym> So write your own script.
16:47:38 <b\6> Pseudonym: tried.
16:47:44 <SamB_XP> Peaker: certainly the editor must stop thinking of text as just a sequence of characters, or even a sequence of rows of characters
16:47:48 <Myoma> b\6: Just disabling any help from the editor seems like the easiest thing for me
16:48:09 <Peaker> SamB_XP: its amazing that so little work has gone into that. Even Visual Studio, and Eclipse, are still using primarily that concept
16:48:11 <b\6> well, autoindent and stuff like that is nice when it works.
16:48:19 <Myoma> SamB_XP: Why.. is there any advantage?
16:48:33 <SamB_XP> Myoma: well, at least Epigram's editor must
16:48:54 <SamB_XP> why, even MS Word doesn't have such dumb ideas about text anymore, does it?
16:48:55 <Peaker> SamB_XP: My problem is that whenever I try to tackle that problem, I try to tackle 6 difficult problems with it, and I don't get anywhere. Then I try to tackle it in Haskell, which I am far too new at, with FRP, which I haven't used for anything :)
16:48:57 <chrisdone> Peaker: this semantic editor always sounds like a cool idea to hack on
16:49:24 <SamB_XP> Peaker: how would FRP help?
16:49:27 <saya> Yeah the ide could show whats wrong with your code like whats wrong with your text in Office and underline it stuff like that, without having to compile
16:49:27 <Peaker> The only actual progress I've made was when I decided to tackle only the UI problem, in a language I'm proficient with (Python)
16:49:48 <SamB_XP> saya: that isn't what I meant
16:50:00 <Peaker> SamB_XP: I have been rather convinced that FRP is the proper way to write UI's in general, but I am not completely certain of it
16:50:01 <saya> oh well ^^
16:50:33 <Cale> saya: I think SamB_XP meant that the editor shouldn't even let you write syntactically incorrect code.
16:50:37 <SamB_XP> what I mean is that text often has nested structures, and the editing environment should be prepared to model this directly instead of using stupid regexp-based stuff
16:50:56 <Peaker> saya: note that Word does not let you convey an "invalidly" structured document (as in, broken syntax to denote headings, etc), whereas we still struggle with whitespace and parens in our code text editors
16:51:13 <saya> i see
16:51:16 <Cale> saya: (and that it should understand the syntax of the language)
16:51:32 <SamB_XP> Cale: well, I'm not going to go quite that far, but I'm certainly going to say that it should be far more supportive in the writing of syntactically-correct code
16:51:37 <Peaker> SamB_XP: Worse - text does trees well, but graphs it does horribly, so we invent namespaces, and names, and introduce a lot of new rules and difficulties
16:51:46 <saya> and how you would do that?
16:52:04 <Cale> I like names.
16:52:17 <SamB_XP> Peaker: I personally think that at this point we should be moving on to tree-based editors
16:52:19 <Cale> I don't think we should ever get rid of names :)
16:52:27 <SamB_XP> yeah, names are cool
16:52:29 <Peaker> Cale: Names serve too many different purposes
16:52:38 <SamB_XP> you don't need to hire an artist to make names ;-P
16:52:40 <Peaker> names should be used as comments, not unique identifiers
16:52:56 <SamB_XP> Peaker: it really bugs people when you think that way
16:53:13 <Peaker> maybe also keywords to "google" symbols by, but not mechanisms to create links in a graph
16:53:33 <saya> i think im lost now :p
16:53:35 <SamB_XP> Peaker: are you a fan of that smalltalk-based wiki where all the URLs are essentially numeric ?
16:53:43 <Peaker> SamB_XP: Hierarchial namespaces, IMO, are one of the biggest obstacles to code re-use
16:53:53 <Peaker> SamB_XP: I don't know that one
16:54:32 <Peaker> SamB_XP: Consider an environment, where any function you make is later findable, without you having to think about, and organize it into a proper module in a proper library, so it can be re-used
16:54:39 <im_alone> Peaker, and what about Modula-2? are there obstacles?
16:54:49 <SamB_XP> okay, WHY THE HECK did my browser just attempt to look up "squeak wiki" in DNS?
16:55:00 <Peaker> If putting it into a generically-enough typed function was all you needed to make it reusable, people would be having a lot more reusable code
16:55:02 <mmorrow> it'd definitely be cool if the namespace was a (possibly cyclic (this might be difficult)) (directed) graph
16:55:16 <SamB_XP> I know it did because I got my ISP's lame excuse for a DNS error back ...
16:55:23 <Peaker> im_alone: I'm not familiar with modula 2
16:55:38 <SamB_XP> http://wiki.squeak.org/squeak/471
16:55:47 <Olathe> Yay !
16:55:50 <SamB_XP> mmorrow: doesn't self do that?
16:55:54 <twanvl> This reminds me of VB, which automatically gives names to controls, so you end up with "Form5.Button2.Caption = Text13.Text"
16:55:59 <Peaker> mmorrow: I believe in the google motto :) "search, don't organize", for code re-use as well
16:56:07 <SamB_XP> Peaker: that's just a link to a random node of the squeak wiki ...
16:56:24 <SamB_XP> do you notice how the page name is a number?
16:56:34 <Peaker> SamB_XP: Well, currently URL's are exposed in the UI, so them being numeric is kind of a problem.  If they did become pure mechanics behind the scenes that would be fine
16:56:40 <SamB_XP> that's the kinda thing that happens when you try to get rid of names
16:56:49 <SamB_XP> Peaker: how could they be?
16:57:09 <SamB_XP> people need to be able to refer to things
16:57:17 <dibblego> is ((Enum a) => [a]) an Enum?
16:57:17 <Peaker> SamB_XP: If we had better integration of objects in the desktop.  Currently so many mediums on the desktop are capable of text only,  such as IRC
16:57:22 <twanvl> Also, without names, how should I call all of you?
16:57:26 <SamB_XP> even by means outside of the system
16:57:34 <Peaker> SamB_XP: If you could pass a link on IRC without having to see its encoding as text, for example, then what's the problem?
16:57:38 <SamB_XP> Peaker: what if I wanted to write it on a piece of paper?
16:57:47 <SamB_XP> or say it on the radio
16:57:49 <Peaker> SamB_XP: Write the number down, in that rare case
16:57:55 <SamB_XP> that's not SO rare
16:58:01 <paczesiowa> @instances Enum
16:58:01 <SamB_XP> anyway usually I just like to remember the page name
16:58:05 <Peaker> SamB_XP: Most URL's are too long to write down easily anyhow, they're already mechanisms
16:58:09 <SamB_XP> rather than bothering to write it down
16:58:19 <mmorrow> SamB_XP: i'm thinking of the cases in the haskell namespace where you have to choose "eeee, should  i put it in    Control.<something-specific> or    <something-specific>.Control ??"   ==> i wonder the (in)feasibility/(un)desirability of making   A.B == B.A  (or something along these lines)
16:58:24 <Peaker> SamB_XP: well, replace unique names with "keywords" - just google for them
16:58:33 <SamB_XP> mmorrow: oh, sure, that sucks mightily
16:58:34 <mmorrow> basically to untree/graphify the namespace
16:58:36 <Peaker> SamB_XP: They can say the title on the radio, and you'd search for it, why a unique name?
16:58:44 <luite_> is there a standard/good way to do  replaceFirst :: (a -> Bool) -> (a -> a) -> ([a] -> [a]) -> [a] -> [a]  , a function that replaces the first element in the list that satisfies the predicate using the (a -> a) function, and if no such element is found, uses the ([a] -> [a]) function on the whole list?
16:58:47 <mmorrow> in "some" way
16:58:52 <Peaker> mmorrow: labels, not folders
16:59:11 <SamB_XP> but I still don't think we have a good replacement
16:59:27 <dibblego> luite_, foldr I guess
16:59:33 <Peaker> SamB_XP: I don't think people still type in URL's into browsers anymore
16:59:38 <Peaker> SamB_XP: People type keywords into google
16:59:40 <SamB_XP> at this point in time, humans still need to be able to examine the resource identifiers
16:59:41 * EvilTerran does, sometimes
16:59:52 <Peaker> EvilTerran: Don't confuse Haskellers and people
16:59:53 <mmorrow> Peaker: import <fmap imFeelingLucky ["um root | sunday_stuff_09", "/usr"]> .. ???
16:59:56 <Jedai> mmorrow: You still need a unique name to reference the package I guess
16:59:59 <SamB_XP> Peaker: perhaps not very long ones, but people often type PARTS of URLs into browsers
17:00:12 <mmorrow> Jedai: that's true
17:00:21 <Jedai> Can we put a package in several categories in Cabal now ? I don't think so
17:00:24 <Peaker> mmorrow: Well, just hoogle what you want to use, and use it. The link to it will be stored by the code editor, you don't have to see how it looks like
17:00:36 <SamB_XP> Peaker: you will
17:00:37 <chrisdone> IRC would be nicer with links embedded in the text and proper code sharing with LaTeX or HTML or clever shortcuts
17:00:40 <Peaker> mmorrow: the code graph is serialized somehow, perhaps using auto-generated unique names behind the scenes
17:00:53 <mmorrow> Peaker: ahh, ok. so this is entirely in a tool. i gotcha.
17:00:59 <Peaker> SamB_XP: parts of URL's?
17:01:02 <SamB_XP> for the immediate future, if there is a unique identifier you ARE going to need to see it
17:01:10 <Saizan> Jedai: yeah, you can
17:01:15 <Peaker> mmorrow: who says text has to be the universal interchange format? Why not a format capable of encoding graphs?
17:01:16 <SamB_XP> Peaker: page names on wikis, that kind of thing
17:01:55 <mmorrow> Peaker: sure, i like symbols more than text anyway :)
17:01:57 <TomMD> If you had four months of isolation with nothing to do but write Haskell programs / libraries what would you build?
17:02:00 <Peaker> SamB_XP: Even there, names as unique identifiers are poorer than search, as names are changed and re-mapped, and are poor unique identifiers, because they are also comments/titles
17:02:15 <SamB_XP> Peaker: hmm.
17:02:20 <Pseudonym> http://www.itee.uq.edu.au/~gwat/Cogito_1.html <- That's all I found.
17:02:32 <luite_> dibblego: but I guess I'd have to run the 'none matched' function afterwards, on a tuple returned by the fold?
17:02:33 <SamB_XP> well, even so, sometimes I will need to compare two references to see if they refer to the same location
17:02:46 <Peaker> SamB_XP: when something is both a unique identifier (used to create a permanent link) and a title/comment (changes to fix errors or update, over time), there's a conflict
17:03:01 <Peaker> SamB_XP: well, why wouldn't that be possible?
17:03:02 <dibblego> luite_, yes I guess so
17:03:03 <SamB_XP> generally I'd prefer they not be meaningless strings of numbers ... I think
17:03:05 <SamB_XP> hmm.
17:03:32 <SamB_XP> I have this nagging feeling that aybe it isn't so bad to use meaningless strings of numbers sometimes
17:03:42 <Peaker> SamB_XP: My ideal desktop would let you dive into any programmatic function (/= as an example) almost as easily as it would let you perform desktop operations (such as play-music)
17:03:47 <SamB_XP> ... it seems to work okay if they are hashes ...
17:03:52 <Pseudonym> pThe trouble with this is that the specification language was Z.
17:03:55 <Pseudonym> Mind you, Z was all the rage in the 90s.
17:04:01 <SamB_XP> (but that only works for immutable resources)
17:04:03 <Peaker> SamB_XP: and references could implement Eq
17:04:17 <Pseudonym> But if I remember correctly, debugging Z was at least as hard as debugging a programming language of the time.
17:04:40 <SamB_XP> Pseudonym: hmm, Coq is much nicer to debug
17:04:45 <Peaker> Pseudonym: Thanks I'll take a look
17:04:46 <Pseudonym> Yeah.
17:04:51 <SamB_XP> at least, the term language is
17:05:12 <luite_> dibblego: ooh, I found something, using break to split the list into two parts, the second part empty when no elements match :)
17:05:21 <SamB_XP> the scripting language is horrific to debug, afaict
17:05:50 <Pseudonym> Mind you, it helps that Coq is interactive.
17:06:04 <SamB_XP> oh, yes, DEFINATELY helps a lot.
17:06:09 <dibblego> definitely
17:06:18 <SamB_XP> Cogito ... is not?
17:06:19 <Peaker> SamB_XP: I want to create a Haskell editor that exploits the fact that pure FP allows the code to be executed as it is edited, on some test cases.  Perhaps also allow "recording" operations done to multiple test cases at once, allowing to see your intermediate code and later full code works as expected as you write it (generating code).
17:06:37 <Pseudonym> SamB: Not as much as Coq.
17:07:02 <Peaker> SamB_XP: then I want the fact you can execute code arbitrarily in that editor, and expand its UI to be useful as a desktop (sending email, playing music, etc are IO actions you could invoke :-)
17:07:06 <Pseudonym> It was in the sense that you provided the specification and the code, and when the system found a discrepancy, it wouldn't accept your program.
17:07:07 <SamB_XP> of course, Coq is interactive in a rather 1D way, which rather saddens me...
17:07:16 <Pseudonym> And it would take an intelligent guess as to where it got stuck.
17:07:36 <SamB_XP> I think it would be really kickass if coq joined the Epigram/Agda party
17:07:58 <augustss> SamB_XP: unlikely
17:08:08 <saya> peaker what you be great is select text, right click 'run' take parameters, see result  or have it test automatically
17:08:11 <Peaker> SamB_XP: about FRP - how do you think one should implement a reactive UI in Haskell?
17:08:13 <SamB_XP> augustss: I just said it would be kickass, not that it would be possible
17:08:26 <augustss> SamB_XP: I agree
17:08:30 <Peaker> saya: why click run? Why not have it run as you edit it (specify the test case before writing the code)
17:08:41 <saya> oh right
17:09:06 <saya> yeah that would be great
17:09:06 <Peaker> SamB_XP: a big imperative/OO program on top of Haskell?
17:09:06 <SamB_XP> Peaker: well, first of all I'd want to prototype the editor on little pieces of paper
17:09:14 <SamB_XP> er, well, more like mockup
17:09:36 <Peaker> SamB_XP: I have a reasonable UI planned out - just not sure how to implement it in Haskell, in a nice/declarative way
17:10:12 <Peaker> SamB_XP: I implemented a declarative UI framework in Python and started out a prototype of a C editor, and I really like how it "feels" already (and others who tried it out mostly agree)
17:10:20 <SamB_XP> next I'd probably try to come up with a zipper-like representation of what state it was sure to need
17:10:40 <saya> reactive programming is abit like VHDL programming right? like you have signals connected to boxes etc?
17:11:11 <Peaker> saya: Hardware programming? I think its the closest thing I've seen to what I hear about HW programming :-)
17:11:12 <SamB_XP> saya: I think it's more like making logic diagrams than VHDL programming ;-)
17:11:39 <Peaker> SamB_XP: why a zipper-like representation?
17:11:48 <saya> yeah well vhdl is mostly a textual logic diagram
17:12:06 <saya> seems like a fine paradigm for ui
17:12:18 <Peaker> SamB_XP: I think its nice to try to localize the idea of state into the UI objects (I think Reactive and OO share a lot in how they localize state)
17:12:21 <im_alone> programming it in vhdl is faster than graphic diagrams
17:12:22 <chrisdone> Peaker: do you have a screencast? :P
17:12:33 <ski> (there's also Fudgets)
17:12:34 <Peaker> chrisdone: nope, just a little preliminary python demo
17:12:46 <Peaker> chrisdone: that will probably not be continued until I know how to reimplement it in Haskell
17:13:01 <SamB_XP> Peaker: because that's about the only way I can think of to avoid (A) my brain exploding and (B) feeling like my code performs horribly and is extremely awkward, too
17:13:02 <Peaker> ski: Fudgets is old/unmaintained, no?
17:13:09 <ski> sure is
17:13:19 <Peaker> SamB_XP: Reactive explodes the brain? OO? :-)
17:13:23 <SamB_XP> Peaker: anyway, it seems to work nicely for xmonad
17:13:30 <SamB_XP> I'm not saying that reactive is bad
17:14:04 <SamB_XP> I'm just saying that I can't think how else to keep track of the "cursor location"
17:14:05 <Peaker> SamB_XP: can you explain an example of how some state was modelled to a zipper pattern in xmonad? I'm not completely sure what that means
17:14:06 <ski> (i was just thinking there might be nice ideas in Fudgets one could steal, if one doesn't want to use itself)
17:14:29 <Peaker> SamB_XP: well, widgets form a heirarchy, and each widget that has multiple children, can have a selected child. That's how I implemented it
17:14:35 <mmorrow> i think the ultimate editor would be written in the lang it is to be an editor for and is completely hijackable by that lang interactively. kinda like if a web browser were written in javascript and provided a DOM interface to the code being edited+interactively interp /while at the same time itself being embedded in this same DOM tree/ and fully manipulateable by itself and the code it's running.
17:14:44 <Peaker> SamB_XP: when its child is selected, it recursively can have some child selected
17:14:50 <mmorrow> a "metacircular editor"
17:14:59 <SamB_XP> Peaker: what are the widgets for?
17:15:02 <Peaker> mmorrow: Yeah, Emacs/elisp,  I want this Haskell editor in Haskell for this purpose
17:15:16 <Peaker> SamB_XP: Each widget corresponds to some mutable object in the world being edited
17:15:27 <Peaker> SamB_XP: and lets you view or modify that object
17:15:44 <im_alone> mmorrow, the vim?
17:15:55 <chrisdone> I was mostly confused last time I hacked on Yi, when I was a haskell neophyte, but I'd probably understand it more now
17:16:01 <Peaker> SamB_XP: a widget represents the entire program, then its children represent the functions, then the children represent parts of the function, etc
17:16:02 <SamB_XP> well, I think my model would be loosely based on epigram's
17:16:07 <mmorrow> Peaker: so for instance such a beast could be incrementally morphed into a pinball game, or a spreadsheet, or a blinking window, or a device driver, or ...
17:16:17 <mmorrow> and morphed by /itself/
17:16:20 <SamB_XP> Peaker: do you know what a zipper looks like?
17:16:29 <mmorrow> ie the code it's interactively interpreting
17:16:54 <mmorrow> (or an editor! :))
17:16:59 <saya> http://leksah.org/ a haskell ide written in haskell dont know what its worth
17:17:14 <Peaker> mmorrow: yeah, or let you implement it as an add-on without destroying the editor itself :)
17:17:29 <Peaker> SamB_XP: Only a vague concept from a previous discussion
17:17:47 <SamB_XP> it's basically what happens if you grab a node in a tree and turn the part of the tree leading up to that node inside-out
17:18:00 <Peaker> SamB_XP: For example, I was told a (list, reversed_list) is sort of a zipper for a dual-sided queue (where you rebuild the reversed list as necessary)
17:18:01 <mmorrow> Peaker: heh, well you could optionally do that as well, but it probably wouldn't get you very far ;) (this wouldn't erase the binary or anything bad)
17:18:39 <mmorrow> you'd /have/ to be able to do that for it to be sufficiently metacircular
17:19:23 <Peaker> mmorrow: Yeah, and a "global undo" can always save you, especially if undo/redo are not an editor hack, but part of a real revision control system
17:19:36 <Peaker> mmorrow: Which will later allow you to merge any subset of the evil changes you made
17:19:59 <chrisdone> I am more and more seeing that TCP is a much nicer way for (plugins|dynamic code) to be implemented
17:20:23 <SamB_XP> chrisdone: TCP is getting a bit crowded these days :-(
17:20:29 <SamB_XP> only so many ports are available
17:20:57 <mmorrow> Peaker: yeah, definitely.
17:21:20 <mmorrow> chrisdone: how do you mean?
17:21:22 <monochrom> Virtualize! Implement a kind of TCP-over-TCP. :)
17:21:44 <jeffz> b\6: I think I have it working.
17:22:18 <jeffz> b\6, nothing special, no instancing Stream or using ByteString.Lazy,  I'll paste it in a bit, going to have a shower first.
17:23:09 <chrisdone> SamB_XP: well, one only needs one port for your host program to listen on, and all the plugins can connect to it and tell it how to behave, or disconnect, get recompiled, and reconnect. great for stateless plugins, anyway, imho
17:23:57 <SamB_XP> chrisdone: but how would the plugins know what port to connect to ?
17:24:21 <chrisdone> SamB_XP: standardise or configure or tell them?
17:24:27 <b\6> jeffz: awesome.
17:27:30 <chrisdone> SamB_XP: I think on a program with lots of plugins, like lambdabot.. plugins could crash and lambdabot wouldn't. and you'd know which was faulty. I'm not sure why people don't use sockets more often for this kind of thing. obviously on programs where the latency is going to be too much it's a problem, but lots of programs aren't like that
17:29:06 <Saizan> chrisdone: i'd hate to serialize everything over a socket
17:29:13 <Spark> ChilliX: ipc is a better option
17:29:15 <Spark> but it's slower
17:29:24 <chrisdone> Saizan: couldn't you use Show and Read?
17:29:49 <SamB_XP> Spark: I don't see how IPC makes things much better
17:30:06 <Spark> if a process crashes, the rest of the program continues
17:31:04 <chrisdone> Saizan: I suspect one general library for serialising communication would be better. I haven't tried that
17:31:04 <Saizan> chrisdone: not for everything e.g. functions or IO actions, and i lose laziness
17:31:25 <Spark> context switches are much slower though
17:33:19 <im_alone> chrisdone, why don't use UDP protocol?
17:34:23 <chrisdone> I'm not experienced with UDP enough to judge
17:34:33 <im_alone> if the plugins crash then lambdabot has not problems of broken sockets because they don't exist
17:35:16 <Saizan> how would you name something that's a synonym for (PreProcessor,PPDescriptor) ?
17:36:02 <twanvl> PPWithDescriptor?
17:36:37 <Riastradh> im_alone, a program using a TCP socket does not necessarily crash if the TCP connection fails...
17:36:39 <chrisdone> Spark: I suppose another nice thing about sockets is collaboration. especially on something like an IRC bot, people can write code for different plugins simultaneously and have the code updated live
17:36:51 <Saizan> twanvl: not bad
17:37:47 <im_alone> Riastradh, but if the TCP client crashes then it breaks the TCP session (it breaks this socket)
17:39:42 <im_alone> less is more
17:39:43 <Riastradh> im_alone, yes...so?
17:40:11 <im_alone> has you see, the split of irc servers are due to it
17:40:18 <im_alone>  /has/as
17:40:19 <Spark> chrisdone: add security concerns to that though
17:40:33 <_ar> im_alone: no it doesn't... unexpected termination is already accounted for in the protocol
17:40:54 <Riastradh> im_alone, if the design requirements include an unreliable protocol (in order, say, to layer a reliable protocol atop it), then the UDP is sensible.  Otherwise there's not much sense in using an unreliable protocol, since -- if you need reliability -- you will just have to implement it yourself if you use the UDP or some other unreliable protocoll.
17:40:59 <Riastradh> Protocol, even.
17:41:04 <GremlinHunter> $ diff `which less` `which more`
17:41:05 <GremlinHunter> Binary files /usr/bin/less and /bin/more differ
17:41:05 <GremlinHunter>  
17:41:05 <jeffz> chrisdone: so, rpc?
17:41:09 <chrisdone> Spark: of course
17:42:06 <im_alone> _ar, how can i receive unexpected termination of the socket?
17:42:08 <chrisdone> jeffz: maybe
17:43:01 <Peaker> Graphics/SOE/Gtk.hs:94:17: Could not find module `System.Time': it is a member of package old-time-1.0.0.0, which is hidden
17:43:02 <waynemokane> would it be accurate to say that monads don't really add any "power" to Haskell?  in other words, they're really only there to save typing, repitition, and pain?
17:43:11 <Peaker> soegtk-0.9.12.2 failed during the building phase.
17:43:22 <Olathe> im_alone: If the OS is still running on the machine where it crashed, it should send a reset packet to tell the other end that the socket is closed.
17:43:23 <_ar> im_alone: do you mean conceptually? it times out
17:43:40 <Peaker> waynemokane: monads allow code to be generalized to various types that can "bind" and "return"
17:43:54 <Botje> waynemokane: given that all monads are implemented in haskell, i agree
17:43:56 <Botje> BUT
17:43:59 <chrisdone> waynemokane: what is “power”, in the context of programming?
17:44:00 <Peaker> waynemokane: without monads, code that worked on IO would not work on the list monad
17:44:00 <_ar> im_alone: attempts to read/write/etc to the socket will result in an error condition that you check for
17:44:02 <Botje> there is the pesky matter of the IO monad.
17:44:14 <waynemokane> sure, so it saves repitition
17:45:00 <waynemokane> but strictly speaking of evaluation... everything that can be computed/evaluated with monads can also be done without using them
17:45:03 <chrisdone> Riastradh: it's nice to see you talk here :-)
17:45:35 <Peaker> waynemokane: "saving repetition" may make things possible.  Can you repeat all code from third parties?  You'd have a combinatorical explosion
17:45:35 <im_alone> Olathe, and if the OS don't boot?
17:45:35 <SamB_XP> waynemokane: hmm, perhaps not exactly the way you think
17:45:55 <SamB_XP> waynemokane: there's still all those monads "you could have invented"
17:46:04 <adu> shapr: you here?
17:46:35 <Peaker> waynemokane: without the type class, or without the general idea?
17:46:35 <Peaker> does anyone know why soegtk fails to build?
17:46:37 <waynemokane> mind you, this is strictly a thought exercise to help in my understanding...  I realize you wouldn't want to just ignore them
17:47:23 <Peaker> what's up with freenode?
17:47:27 <chrisdone> monads provide a common interface. this means that code is shorter, and code constructs using it are easier to understand. short and easy means powerful, imo
17:47:49 <chrisdone> Peaker: netsplits happen a lot, especially recently...
17:48:06 <SamB_XP> Peaker: could it be the anniversary of lilo's death?
17:48:15 <chrisdone> samb: spooky
17:48:29 <SamB_XP> chrisdone: I didn't say it is
17:48:52 <SamB_XP> but IF it is, then maybe they're remembering him by rehubbing
17:48:52 <adu> chrisdone: Amen
17:49:09 <waynemokane> yes, absolutely agree with that ^^
17:49:09 <waynemokane> but what I'm saying is, you could "unroll" every Monadic type and action back to a sequence of lambda functions
17:49:09 <waynemokane> and get the same thing, right?  in that sense they don't "add" anything
17:49:54 <monochrom> Every monad you implemented with lambda functions, yes.
17:50:32 <Peaker> SamB_XP: lilo's death?
17:50:32 <Peaker> lilo died?
17:50:32 <Peaker> nm I found the article
17:50:33 <monochrom> Some IO actions were not implemented with lambda functions. They are FFI calls.
17:50:51 <SamB_XP> Peaker: you hadn't heard ?
17:51:02 <adu> waynemokane: I study (^^)
17:51:39 <SamB_XP> Peaker: and you also hadn't noticed that he doesn't send out any of those messages about rehubbing anymore?
17:53:33 <waynemokane> monochrom: ah, very good point.  so IO is "special" in the sense you couldn't really reproduce what it does in pure Haskell, without the IO Monad
17:53:36 <chrisdone> waynemokane: if you reduce code to something more primitive, it becomes longer and harder to understand, imho. monads are an abstraction which, I think, do “add” something.
17:53:56 <SamB_XP> what was the name of that paper again?
17:53:56 <waynemokane>  njh
17:54:07 <chrisdone> what does “njh” mean?
17:54:22 <adu> no jokes here?
17:54:31 <SamB_XP> I think it means "my cat is playing with the keyboard"
17:54:36 <adu> lol
17:54:48 <SamB_XP> because those keys seem to be in a cluster
17:54:50 <monochrom> my cat is playing the keyboard
17:54:58 <Jedai> monochrom: Not really, no ? There still is a wrapper taking the real world around those primitive, no ?
17:55:04 <chrisdone> “I have died at my keyboard and people are making jokes about my last message to the world”
17:55:11 <adu> nothing jumps higher
17:55:18 <waynemokane> chrisdone: yes that is a good way to think about it, I guess I should have been more clear in my definition of "add"
17:55:23 <adu> nearly juiced ham
17:55:29 <Peaker> SamB_XP: Didn't pay any attention to it
17:55:29 <Peaker> SamB_XP: ouch, bicycle hit&run
17:55:34 <mmorrow> > ord '”'
17:55:52 <monochrom> Yes really, Jedai.
17:55:55 <Olathe> "My IRC client is buggy and is sending random three-letter sequences every five years or so."
17:55:56 <mmorrow> @botsmack
17:56:01 <Jedai> waynemokane: If you mean that Monad aren't an extension of the language but simply object defined with the language, you're right.
17:56:08 <Saizan> waynemokane: if you're asking if monads use any magics behind the scenes, then only IO and ST do that
17:56:21 <Jedai> waynemokane: Except the do-syntax which is just syntax sugar
17:56:27 <binarybandit> @botsnack
17:56:27 <SamB_XP> waynemokane: ... except, of course, the IO monad isn't implementable in Haskell
17:56:31 <binarybandit> :(
17:56:41 <Jedai> SamB_XP: It is
17:56:50 <SamB_XP> Jedai: not quite
17:56:59 <chrisdone> mmorrow: 8221
17:57:04 <mmorrow> heh, thx
17:57:08 * adu <3 IO
17:57:12 <waynemokane> right, exactly.  so ignoring IO at the moment (and ST since I don't even know what that is), all the expressions you can evaluate using Monads, can also be evaluauted without using them, and you can get the same result
17:57:14 <chrisdone> http://www.fileformat.info/info/unicode/char/201d/index.htm
17:57:15 * Twey </3 IO
17:57:24 <SamB_XP> Jedai: in GHC, or JHC, or nhc98, sure. but not in Haskell.
17:57:29 <Jedai> SamB_XP: The IO monad is perfectly implementable in Haskell (that's what GHC does), what isn't is how it's executed
17:57:30 * adu </3 ST
17:58:04 <waynemokane> actually, what am I saying?  that's exactly what many monad tutorials show... they start with the painful version then show the clean monadic version
17:59:26 <Jedai> SamB_XP: I'm not sure of your point ? Do you mean that the primitive executed by the RTS drived by the IO monad can't be implemented in Haskell ? Or that unsafePerformIO can't ?
17:59:27 <SamB_XP> waynemokane: are you talking about do syntax ?
17:59:49 <adu> waynemokane: (Typeable1 IO), (Typeable2 ST), does that help?
18:00:03 <SamB_XP> Jedai: that the language in which "instance Monad IO where ..." is written is never exactly Haskell
18:00:09 <monochrom> @src unsafePerformIO
18:00:13 <Jedai> SamB_XP: No, I think he is speakin about showing how to handle chained Maybe without the Monad for example, I think
18:00:21 <monochrom> @botsnack
18:00:28 <monochrom> ?src unsafePerformIO
18:00:39 <GremlinHunter> The bot is dead!
18:00:57 <adu> > 2
18:01:00 <SamB_XP> gwern: are you finished with your nap yet?
18:01:06 <SamB_XP> gwern: if so, get to fixing!
18:01:07 <monochrom> "how to implement putStrLn" is a good test of your understanding of IO.
18:01:38 <monochrom> (Oh, of course, you say something about "putChar". So implement putChar, ad infinitum.)
18:02:03 <SamB_XP> monochrom: foreign import ...
18:02:06 <luite_> how should I write a 'head' function that gives a default value when the list is empty (or is there already one available?)
18:02:14 <adu> putStrLn = putStr "\n" << putStr?
18:02:16 <monochrom> If you say "IO is RealWorld -> (a,RealWorld)" that only tells you how to implement return, >>=, and unsafePerformIO.
18:02:18 <waynemokane> yes, so for every expression containing some monadic type M a,  where M is an instance of Monad, it's possible to rewrite the expression so that it uses only "a"
18:02:25 <Jedai> SamB_XP: It may be so, but it isn't a fundamental limitation, there's no reason it should, since the IO monad by itself is just passing around the real world (it's just a variation of ST in GHC)
18:02:28 <waynemokane> forgetting IO, and of course given that you wouldn't actually WANT to do this
18:02:42 <waynemokane> just trying to understand
18:02:47 <dolio> @type \x -> fromMaybe x . listToMaybe
18:02:50 <SamB_XP> Jedai: none of these concepts are really part of Haskell
18:02:50 <monochrom> Yes SamB_XP, precisely my point in <monochrom> Some IO actions were not implemented with lambda functions. They are FFI calls.
18:03:19 <SamB_XP> monochrom: or primops
18:03:19 <adu> waynemokane: yes, but then you'd have to put compiler pragmas everywhere
18:03:59 <Jedai> SamB_XP: What I just said ? Just passing around a state ?
18:04:21 <SamB_XP> Jedai: there is no RealWorld in Haskell ...
18:04:22 <Plouj> hi
18:04:24 <luite_> dolio: thx, lambdabot seems a bit broken, but it works in my local ghci :)
18:04:34 <adu> my shoes :: RealWorld
18:04:47 * adu :: RealWorld
18:04:50 <Plouj> do you guys know, off the top of your head, what if any, autotools remakes/replacements are in development (written in haskell)?
18:04:52 <Jedai> SamB_XP: Of course as pointed by monochrom, the actions themselves can't be all written in Haskell
18:05:10 <Peaker> waynemokane: Yes, monads are not magical or "fundumental", calls to >>= and return "expand" into perfectly ordinary code
18:05:13 <Jedai> SamB_XP: Why not ? It's just a dummy anyway
18:05:18 <SamB_XP> Jedai: it is NOT turtles all the way down
18:05:19 <dolio> luite_: There are more direct ways, of course. Pattern matching would probably be the obvious solution.
18:05:32 <Peaker> waynemokane: IO is somewhat special because the Haskell98 RealWorld type cannot be used directly, afaik
18:05:39 <waynemokane> Peaker: right, exactly what I was trying to get at  :) thanks
18:05:43 <monochrom> It's penguins all the way down.
18:05:48 <Peaker> waynemokane: (only through the >>=, return and various IO-specific operations)
18:05:49 <waynemokane> of course at some point you are going to need some system calls
18:05:57 <Jedai> SamB_XP: Yeah, there is a frontier at the IO _actions_ level, but I would argue that it isn't at the IO monad itself
18:06:00 <dolio> Haskell98 doesn't have a RealWorld type. :)
18:06:04 <luite_> dolio: yes I know, but usually there is some very clever (points free?) solution :)
18:06:30 <Jedai> Peaker: And how is that different from an abstract type which is very Haskell98
18:07:00 <monochrom> At this point it is wording bickering all the way down.
18:07:04 <Jedai> dolio: Right, but H98 don't say anything about the implementation of IO, it just describe its semanthic
18:07:09 <Jedai> semantic
18:07:09 <Peaker> Jedai: you define abstract types, RealWorld is special, and there's only one like it?
18:07:22 <Jedai> monochrom: Right ^^
18:07:24 <dolio> luite_: The real clever way is: foldr const
18:08:03 <luite_> dolio: but that wouldn't work for infinite lists?
18:08:16 <dolio> No, it works.
18:08:25 <Jedai> luite_: It would, because const is lazy in its second argument
18:08:31 <luite_> oh really? hmm, i see
18:08:38 <luite_> more cleverer than I thought :)
18:08:58 <Jedai> luite_: In fact, foldr const never look further than the head of the list (if it exist)
18:09:04 <dolio> foldr const z (x:xs) = const x (foldr const z xs) = x
18:09:49 <luite_> so now I'm impressed by haskell for letting me write even more obscure code
18:10:08 <pjdelport> > foldr const undefined (5:undefined)
18:10:16 <adu> luite_: hehe, so how many one-liners have you learned/written?
18:10:40 <Peaker> trying to build soegtk yields: "Could not find module `System.Time':" but ghci manages to import System.Time just fine
18:10:46 <Jedai> luite_: In the real world you would write it with pattern matching (except if you're really weird !!) ^^
18:11:15 <Jedai> Peaker: Probably a package missing in the .cabal file
18:11:27 <Jedai> Peaker: oldtime or something like that
18:11:43 <mmorrow> old-time
18:11:44 <luite_> adu: quite a few now, but I'm sure many of them could be made 'better' (shorter/more points free etc)
18:12:05 <Peaker> Jedai: old-time is installed, though
18:12:17 <Peaker> it claims its hidden, but "sudo ghc-pkg expose old-time" worked successfully
18:12:25 <adekoba> hey. When I promote a terminal that is using an ncurses program, there is issues resizing and half of the text gets cut off. However, when I resize the window in other window managers, this does not happen. Is there a way to fix this?
18:12:29 <luite_> Jedai: yes I know, but this is just for solving a puzzle from some magazine, and I want to show off my 'l33t code' ;)
18:12:31 <Jedai> Peaker: Yeah but cabal hide all the packages that are not listed as dependencies
18:12:33 <mmorrow> is it in the    build-depends:      .... , old-time, ....         in the _.cabal ?>
18:12:34 <adu> luite_: you can't get shorter than nubBy (((>1).).gcd) [2..]
18:12:36 <mmorrow> s/>//
18:12:46 <Peaker> Jedai: ah
18:12:50 <Peaker> Jedai: evil :)
18:13:07 <pjdelport> luite_: there is also listToMaybe :: [a] -> Maybe a, which is basically a safe head
18:13:15 <Jedai> Peaker: It's necessary if you have several package providing the same module
18:13:19 <Peaker> Jedai: fixed, thanks
18:13:35 <luite_> pjdelport: that's what dolio suggested
18:14:02 <pjdelport> oh, missed it, sorry
18:14:14 <Peaker> even with cabal-install, still getting dependency hell
18:14:34 <adu> Peaker: o i gave up on installing cabal-install a long time ago
18:14:48 <adu> Peaker: I just use runhaskell ... configure, etc...
18:14:48 <Peaker> adu: cabal-install is installed and often works, but sometimes not
18:15:03 <Peaker> "cabal: cannot configure binary-0.4.3. It requires base >=2.0 && <2.2 && >=3.0"
18:15:23 <Peaker> and binary-0.4.3 is installed, according to ghc-pkg list
18:15:43 <adu> Peaker: hmm, well you got farther than I did...
18:16:02 <Saizan> Peaker: uhm, weird
18:16:09 <adu> Peaker: I got the error "could not configure cabal-install..."
18:16:42 <Saizan> adu: you probably had to update your Cabal library first, or you were missing one of the 4 dependencies
18:16:59 <adu> Saizan: yes, I had an older version of Cabal at the time
18:18:21 <Peaker> Saizan: when I used "cabal install binary" separately it successfully installed binary-0.4.3, when I try to install "leksah" it claims it cannot install binary-0.4.3
18:23:48 <Saizan> Peaker: that could be that leksah and binary together imply an inconsistent version of base, but it looks more like a bug in the resolver
18:24:09 <Saizan> Peaker: did you just do cabal install leksah?
18:24:16 <shapr> @seen adu
18:24:22 <shapr> preflex: seen adu
18:24:22 <preflex>  adu was last seen on #haskell 7 minutes and 23 seconds ago, saying: Saizan: yes, I had an older version of Cabal at the time
18:24:25 <shapr> foo
18:25:00 <Peaker> Saizan: yeah
18:28:13 * Saizan lacks gtk2hs
18:33:08 <dcoutts> Peaker: so you get the weird problem installing binary too?
18:33:22 <Peaker> dcoutts: nope, installing binary worked fine
18:33:46 <haskellian> ,l
18:33:46 <Peaker> dcoutts: only when trying to install leksah
18:34:17 <dcoutts> Peaker: so, you've got binary installed already, and when making the install plan for leksah is says it cannot configure binary?
18:34:29 <dcoutts> Peaker: can you hpaste that, use --dry-run -v
18:35:49 <Peaker> http://hpaste.org/9973
18:38:43 <dcoutts> Peaker: could you email me your global and per-user package dbs so that I can reproduce the planning bug here precisely please? duncan at haskell.org
18:39:57 <Peaker> dcoutts: why not paste ghc-pkg list?
18:40:19 <dcoutts> Peaker: no, the content. I need to know all the deps of all the installed stuff to reproduce the bug.
18:40:32 <Peaker> dcoutts: oh, what to send exactly?
18:40:42 <Peaker> the package.conf files?
18:40:49 <dcoutts> Peaker: yes, both user and global
18:41:17 <dcoutts> Peaker: it'll let me run the package search algorithm with your exact setup
18:42:02 <dcoutts> Peaker: in the email remind me exactly what command you ran and/or link to the hpaste so I don't get confused. :-)
18:42:20 <dcoutts> Peaker: you're not the only one to report this, so I need to keep the different reports in order
18:42:23 <Peaker> oops, already sent without it :)
18:42:55 <dcoutts> Peaker: just send another note, s'ok
18:44:13 <Peaker> done
18:44:16 <jeffz> b\6: hmm, well... it works for me, so long as I don't call getInput when doing so would block, so, dancing around not advancing the stream to just before it would block "works".
18:47:52 <b\6> sounds helpful.
18:50:01 <dancor> @type undefined . (++)
18:50:06 <dancor> @bot
18:50:49 <dancor> anyway, why can you do  undefined . anything?  you can't do "yay" . anything  and they are both constants..
18:51:13 <jeffz> b\6, I'm just thinking if this strategy of calling getInput is useful, or that some other means of coordination could be used
18:51:22 <dolio> What are the types of undefined and "yay"?
18:51:27 <dancor> ah, i guess undefined has type (b -> c).
18:51:45 <Saizan> undefined :: forall a. a
18:51:51 <Saizan> so it can have any type
18:52:12 <newsham> undefined proves a lot
18:53:22 <dancor> i certainly have to work it out to see the type of undefined . (++)
18:53:30 <dancor> will it be obvious some day
18:53:56 * dancor is going to start doing daily type exercises
18:54:14 <jeffz> b\6: perhaps it doesn't make sense when it has to wait for input, maybe it should use some synchronizing variables to put the result of what has been successfully parsed, maybe if you loop to put the result in an mvar in one thread, while another takes the result as needed and sends on the handle
18:55:50 <b\6> jeffz: i was thinking it should be based on parsec's need. if it wants to read, apparently i coded it with the intention the server should be sending some data.
18:59:31 <jeffz> b\6: I've annotated your paste with what I was fooling around with
18:59:34 <dcoutts> Peaker: got it. thanks v. much
18:59:48 <b\6> jeffz: thanks a lot for trying. <3.
18:59:53 <monochrom> What a lengthy bickering on haskell-cafe on "segfault/Nothing is a type error" "no it's not" "yes it's too" exactly as I have prophesized, even when people didn't want to believe.
19:00:44 <dancor> monocassandra
19:01:03 <newsham> haskell fixes everything and you are a damned fool if you dont agree, mono.
19:01:45 <monochrom> Haha, I agree about haskell fixing everything. I just disagree with the meaningless debate.
19:02:06 <dolio> Clearly there are segfaults that are type errors.
19:02:13 <dolio> Because you can cause segfaults with unsafeCoerce.
19:02:19 <newsham> i dont.  haskell is better, but not nirvana.
19:02:21 <b\6> the infection has spread.
19:02:53 <newsham> haskell doesnt bring world peace
19:03:05 <monochrom> Oh you were joking. I'm a damn fool afterall. :)
19:03:08 <gwern> we need to take off & nuke -cafe from orbit. it's the only way to be sure.
19:03:09 <newsham> and hasnt saved the whales
19:03:33 <newsham> and still doesnt eliminate all segmentation violations
19:03:36 <b\6> one time i jumped out of a plane before i'd had my coffee and realized i'd left my chute back in the plane. fortunately, haskell.
19:03:45 <monochrom> haha
19:04:02 <monochrom> I guess you used STM and did a retry. :)
19:04:15 <b\6> i just ran ghc --make.
19:04:21 <monochrom> hahaha
19:04:22 <ddarius> newsham: Why do we want world peace or to save the whales?
19:04:36 <b\6> whales have side effects.
19:04:40 <newsham> whales are people too.
19:05:03 <b\6> whales use a monolithic kernel architecture.
19:05:03 <gwern> whales used to wear the hair shirt. until the hippies decided to shave the whales.
19:05:12 <Olathe> Whales created Wikipedia.
19:05:44 <gwern> Olathe: Wales is also famous for his beard
19:05:44 <Olathe> Whales have a nation in Britain.
19:06:07 <Olathe> Whaling means crying loudly.
19:06:32 <monochrom> Whales for the 2012 Eurocup!
19:06:38 <gwern> Olathe: as a result of being whaled upon?
19:07:35 <Olathe> gwern: Sometimes :(
19:07:46 <b\6> hmm, suddenly remembered there was a huge (relatively) and really advanced virus named whale years and years ago.
19:07:51 <gwern> a whale of a conversation
19:09:59 <newsham> whales violate segmentation
19:10:45 <b\6> whales pollute the namespace
19:11:15 <monochrom> whales live in protected mode
19:13:30 <Olathe> Whales sometimes take naps on the beach.
19:13:52 <monochrom> That is one of those "general protection faults"
19:14:35 <newsham> whales drink my pee
19:15:07 <newsham> perhaps this is blah material
19:30:21 <PHO_> @help
19:30:29 <PHO_> !help
19:30:35 <PHO_> @bot
19:30:42 <PHO_> hmm
19:31:57 <monochrom> Bye!
19:32:38 <shapr> preflex: seen myoma
19:32:38 <preflex>  myoma was last seen on #haskell 2 hours, 44 minutes and 18 seconds ago, saying: SamB_XP: Why.. is there any advantage?
19:32:47 <PHO_> @pl f x = case x of "" -> Nothing; _ -> Just $ read x
19:33:13 <PHO_> > pl f x = case x of "" -> Nothing; _ -> Just $ read x
19:33:28 <rwbarton> lambdabot isn't here, but I don't think @pl can handle case anyways
19:33:43 <PHO_> whoa, I didn't notice that
19:33:45 <PHO_> what a shame
19:33:51 <Olathe> I think seen results should use Maybe.
19:40:04 <Jedai> PHO_: let if' p t f x = if p x then t x else f x in if' null (const Nothing) (Just . read)
19:40:13 <Saizan> ?bot
19:40:20 <psibot> :)
19:40:23 <PHO_> Jedai: thanks
19:40:46 <Jedai> PHO_: I'm not really sure it's any better than the case though
19:42:06 <PHO_> I'm just writing a pkgsrc Makefile for pointfree to install it locally into my computer...
19:50:05 <gwern> > runST (unsafeIOToST (readFile "/etc/passwd"))
19:50:05 <psibot>  mueval: Unsafe function(s) to use mentioned.
19:50:52 * gwern is moderately surprised. I assumed psibot was an old vulernable lambdabot
19:51:48 <Saizan> it's HEAD lb
19:53:10 <Saizan> > fix ((1:) . scanl 1 (+))
19:53:13 <psibot>      No instance for (Num (a -> a -> a))
19:53:13 <psibot>       arising from the literal `1' a...
19:53:39 <PHO_> > case (readFile "/etc/passwd") of IO m -> case m realWorld# of (# _, r #) -> r
19:53:39 <psibot>  Parse error at "of" (column 60)
19:54:18 * PHO_ isn't surprised
19:54:29 <Saizan> > fix ((1:) . scanl (+) 1)
19:54:32 <psibot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:56:05 <Olathe> @let f = (+1)
19:56:07 <psibot> Defined.
19:56:09 <Olathe> > f 5
19:56:12 <psibot>  Add a type signature
19:56:20 <Olathe> > f 5::Int
19:56:22 <psibot>      No instance for (SimpleReflect.FromExpr Int)
19:56:22 <psibot>       arising from a use of...
19:56:34 <Olathe> Bah.
19:56:35 <newsham> > foldr f a [b,c,d]
19:56:38 <psibot>  f b (f c (f d a))
19:56:39 <Saizan> > L.f 5
19:56:39 <psibot>  mueval: Unsafe function(s) to use mentioned.
19:56:39 <newsham> ?type f
19:56:42 <psibot> forall a. (SimpleReflect.FromExpr a) => a
19:56:45 <Olathe> @let g = map
19:56:47 <psibot> Defined.
19:56:52 <newsham> ?type g
19:56:55 <psibot> forall a. (SimpleReflect.FromExpr a) => a
19:56:58 <Olathe> > g (+1) [1..]
19:57:00 <psibot>      Overlapping instances for Show (a -> a)
19:57:01 <psibot>       arising from a use of `g' ...
19:57:03 <newsham> olathe: pick a different name
19:57:11 <Olathe> A different name ?
19:57:13 <newsham> ?let incr = (+1)
19:57:15 <psibot> Defined.
19:57:16 <newsham> > incr 5
19:57:16 <Olathe> Oh.
19:57:18 <psibot>  mueval: Prelude.read: no parse
19:57:31 <Olathe> @let blahblah = map
19:57:32 <newsham> f,g are predefined
19:57:33 <psibot> Defined.
19:57:43 <Olathe> > blahblah (+1) [1..]::[Int]
19:57:46 <psibot>  mueval: Prelude.read: no parse
19:57:57 <Olathe> It does that for @let functions for some reason.
19:57:59 <newsham> > (+1) 5
19:58:02 <psibot>  6
19:58:12 <Saizan> mmh there's a bug in mueval..
19:58:15 <Olathe> Ahh.
19:58:16 <Saizan> probably
19:58:22 <Saizan> ?undefie
19:58:24 <Olathe> I think it's only in this bot.
19:58:24 <newsham> ?list eval
19:58:25 <psibot> eval provides: run let undefine
19:58:31 <Olathe> I know lambdabot works.
19:58:33 <newsham> ?undefine
19:58:33 <Saizan> ?undefine
19:58:41 <newsham> ?let incr = (+1)
19:58:43 <psibot> Defined.
19:58:43 <newsham> > incr 5
19:58:45 <psibot>  mueval: Prelude.read: no parse
19:59:17 <aconbere_> I have some libs installed that haskell isn't finding. Is there a way to update teh search path globally or to register those packages?
20:01:29 <PHO_> Done! http://pkgsrc-wip.cvs.sourceforge.net/pkgsrc-wip/wip/pointfree/
20:01:30 <psibot> Title: SourceForge.net Repository - 1 [ a pkgsrc-wip 1 ] 1 17 Index of /wip/pointfree 3 ...
20:02:16 <psygnisfive> hey guyszzs
20:02:31 <psygnisfive> you're all impossibly smart, so i figure i'll ask here:
20:02:54 <psygnisfive> anyone willing to participate in an experiment regarding natural language syntax?
20:03:10 <psyklops> an experiment...
20:03:19 <psygnisfive> a spearmint!
20:03:22 <psyklops> will there be needles?
20:03:29 <psygnisfive> only if you want there to be
20:03:41 <psygnisfive> but they'll have no impact on the results
20:03:41 <psyklops> define needles;
20:03:52 <psygnisfive> :P
20:03:52 <SamB> psygnisfive: but I already tried Inform 7, why do you want me to do it again?
20:03:58 <psygnisfive> inform 7?
20:04:21 <SamB> @google "inform 7"
20:04:23 <psibot> http://www.inform-fiction.org/I7/Inform%207.html
20:04:23 <psibot> Title: Inform 7
20:04:42 <psygnisfive> i dont see how thats related D:
20:04:50 <b\6> i'm on the phone with my close personal associate friend and mentor dr. dre and he says not to do it.
20:04:57 <PHO_> ah, needle... I was wondering how noodle is related to natural language anyhow
20:05:13 <psygnisfive> noodles!
20:05:16 <psygnisfive> noodles are very related
20:05:18 <psygnisfive> very very
20:05:20 <SamB> oh, noodles
20:05:30 <SamB> noodles I am very interested in
20:05:35 <PHO_> lol
20:05:38 <Olathe> Noodles with lobster.
20:05:38 <SamB> they are quite tasty when properly prepared
20:05:44 <psyklops> I'm up for experiments, but I'm not a programmer really
20:08:00 <psyklops> he says there will be cake
20:08:09 <psygnisfive> LOTS of cake
20:09:04 <luite_> I have a Data.Tree a, and I want to print it using drawTree, which needs a Tree String. how can I convert my Tree a to Tree String by applying show to each node?
20:09:43 <SamB_XP> luite_: tried fmap show?
20:10:20 <luite_> SamB_XP: yes, but I'm not sure whether I did it correctly
20:10:42 <SamB_XP> luite_: did you get the expected results?
20:10:53 <luite_> oh, now I know that I didnt :)
20:11:03 <luite_> forgot an $
20:12:52 <lispy> Is there something syntatically invalid about foo bar baz >>= $ \a -> blah
20:13:04 <lispy> if not, then layout hates me
20:13:17 <Twey> Yes, lispy
20:13:19 <Olathe> > foo bar baz >>= $ \a -> blah
20:13:20 <psibot>  Parse error at "$" (column 17)
20:13:26 <Twey> You can't put two operators in a row
20:13:38 <lispy> hmm
20:13:39 <Twey> Just `foo bar baz >>= \a -> blah` is fine
20:13:40 <SamB_XP> take out the $
20:13:51 <lispy> :r
20:13:54 <Olathe> > Just `foo bar baz >>= \a -> blah`
20:13:54 <psibot>  Parse error at "bar" (column 11)
20:13:55 <lispy> hehe, oops
20:14:13 <SamB_XP> Foo>
20:14:29 <SamB_XP> er, uh, I mean:
20:14:38 <SamB_XP> *Foo>
20:14:44 <lispy> Thanks guys, It was driving me nuts
20:15:15 <lispy> I have this case where I cant use do-notation because I have a custom monad-like, but Monad incompatible, type
20:15:40 <lispy> So I'm converting chunks of do-blocks to use my functions (>>>=) and (>>>)
20:15:48 <lispy> It's a mess
20:15:52 <SamB_XP> but >> is already taken
20:16:00 <SamB_XP> er.
20:16:01 <SamB_XP> >>>
20:16:09 <lispy> arrows be damned :)
20:16:15 <luite_> use >>>> instead ;)
20:16:24 <Twey> >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> is better
20:16:29 <SamB_XP> how about >><<
20:16:37 <Twey> I vote >.<
20:16:44 <psygnisfive> twey! :D
20:16:47 <SamB_XP> isn't that in Applicative?
20:16:58 <Twey> No, that's the face that Applicative causes me to make
20:17:04 <Twey> psygnisfive?
20:17:15 <psygnisfive> hey.
20:17:21 <Twey> Uh, hello
20:17:30 <psygnisfive> you dont remember me! D:
20:17:35 <Twey> I do remember you
20:17:37 <psygnisfive> well, serves me for not hanging around here in a while
20:17:38 <psygnisfive> oh, ok.
20:17:39 <psygnisfive> hey.
20:17:53 <lispy> psygnisfive: FWIW, I don't remember you.
20:18:01 <lispy> psygnisfive: er, Hi!
20:18:08 <psygnisfive> lispy! :D
20:18:13 <SamB_XP> @quote psygnisfive
20:18:14 <psibot> No quotes match. :(
20:18:17 <SamB_XP> @quote
20:18:18 <psibot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:18:18 <Twey> You PM people randomly (*twitch* right as I was typing this...) and got kicked out of ##javascript
20:18:32 <Twey> Oh crikey
20:18:41 <SamB_XP> @quote
20:18:41 <psibot> inv2004 says: lambdabot: monads ?
20:18:45 <SamB_XP> @quote
20:18:45 <psibot> puusorsa says: do not try this in a shell: :() { :&:; } ;:
20:18:45 <lispy> I love that emertens quote
20:18:51 <Twey> How come nobody has written a Python web framework called 'Snakes on a Plane' yet?
20:19:03 <SamB_XP> @quote snakes
20:19:04 <psibot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:19:05 <SamB_XP> @quote snakes
20:19:05 <psibot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:19:06 <SamB_XP> @quote snakes
20:19:06 <psibot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:19:08 <mightybyte> @seen dons
20:19:08 <psibot> dons is in #haskell. I don't know when dons last spoke.
20:19:21 <Olathe> @seen Just
20:19:21 <psibot> I haven't seen Just.
20:19:51 * SamB_XP could have sworne he made a followup to emertens' quote saying essentially what Twey said ..
20:20:16 <lispy> C'mon, you know lambdabot is as forget as can be
20:20:25 <lispy> ?quote lambdabot
20:20:25 <psibot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
20:20:25 <psibot> UTF8&s=books <lambdabot> http://tinyurl.com/root7
20:20:33 <Olathe> lambdabot forgot to come to work today.
20:20:51 <Olathe> It thought it was Saturday.
20:20:54 <lispy> ?quote lispy
20:20:54 <psibot> lispy says: the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
20:21:02 <Olathe> ?quote Olathe
20:21:02 <psibot> Olathe says: binary search on linked lists is the work of SATAN !
20:21:06 <lispy> ?quote lispy.alarm
20:21:07 <psibot> No quotes match. Where did you learn to type?
20:21:13 <lispy> ?quote alarm
20:21:14 <psibot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
20:22:00 <newsham> are there any libs for creating cryptographically strong random numbers?
20:22:09 <newsham> such as bindings to openssl
20:22:28 <lispy> newsham: hackage!
20:22:30 <stepcut> newsham: there is a binding to random.org
20:23:03 <stepcut> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/RandomDotOrg
20:23:05 <newsham> asking another site for a random number is not cryptographically secure
20:23:05 <psibot> Title: HackageDB: RandomDotOrg-0.2.1, http://tinyurl.com/5ezf6k
20:23:26 <stepcut> newsham: but they just pull the numbers out of thin air...
20:23:32 <stepcut> ;)
20:23:43 <Twey> Hahaha
20:23:56 <newsham> over http... what could possibly go wrong?
20:24:05 <newsham> hey, why are all my random numbers zero when i'm at starbucks.com?
20:24:13 * Twey laughs.
20:24:13 <stepcut> hehe
20:24:27 <SamB_XP> newsham: what?
20:24:58 <newsham> anyway.. yah, i did look at hackage first..
20:25:50 <gwern> maybe we could write an impl of blumblumshub
20:25:51 <lispy> ah
20:26:19 <newsham> ahh,  HsOpenSSL has OpenSSL.Random.
20:27:32 * gwern just likes saying blumblumshub
20:27:40 * lispy figured
20:34:27 <luite_> "Segmentation fault/access violation in generated code"  <- what causes this error (when running ghc) ?
20:34:58 <_ar> my guess is a segmentation fault... or maybe an access violation
20:36:19 <luite_> yeah that would be my guess too... but what does the "in generated code" mean, is it in code from ghc itself, or maybe some package I installed?
20:36:51 <_ar> luite_: i really have no idea... i was just giving you a hard time
20:39:48 <dons> luite_: hmm. what code was that?
20:40:03 <dons> is that even a real error message?
20:41:20 <luite_> I think it's real :)
20:41:20 <luite_> C:\Users\luite\Documents\haskell>ghc --make circ
20:41:21 <luite_> Segmentation fault/access violation in generated code
20:41:36 <dons> what does that code do?
20:42:36 <luite_> not much, it's very simple and short. but I've tried to compile it again, but now it works fine, for some reason
20:43:21 <SamB_XP> hmm, I'm afraid http://uncyclopedia.org/wiki/Magical_girl actually contains a substantial amount of information on it's subject!
20:43:22 <psibot> Title: Magical girl - Uncyclopedia, the content-free encyclopedia
20:43:45 <SamB_XP> (whereas it's supposed to contain misinformation!)
20:44:49 <dons> hmm
20:45:00 <dons> psibot: wtf?
20:47:23 <jeffz> luite_: bad ram?
20:49:23 <luite_> jeffz: I don't think the ram is bad, I've never had any other issues with this computer. ghc did consume huge amounts of memory though, the time it crashed with that error message
20:51:41 <mwc> Programs that really hit ram like GHC can uncover ram problems that hide in normal usage. You could try an all night memtest while you sleep
20:52:02 <mwc> but it could also be a GHC bug, wouldn't be the first. If you can reproduce it, the ghc devs are very helpful on trac
20:54:50 <mwc> Is there a way to have cabal-install recursively rebuild dependent packages
20:56:57 <adu> > iterate typeOf Type
20:56:59 <psibot>  mueval: Prelude.read: no parse
21:00:13 <dibblego> does \(a, b) -> (b, a) exist in the standard library?
21:05:09 <bd_> @djinn \(a, b) -> (b, a)
21:05:10 <psibot> Cannot parse command
21:05:15 <bd_> er
21:05:21 <bd_> @djinn (a, b) -> (b, a)
21:05:21 <psibot> f (a, b) = (b, a)
21:05:23 <dolio> Nope.
21:05:29 <bd_> @hoogle (a, b) -> (b, a)
21:05:29 <psibot> A Hoogle error occurred.
21:05:41 <stepcut> it's fun to write like this though
21:05:44 <stepcut> ?ty snd &&& fst
21:05:47 <psibot> forall a b. (a, b) -> (b, a)
21:06:08 <dolio> I think it might be in a libraries proposal for 6.10.
21:06:08 <luite_> or just  uncurry (flip (,)) ?
21:06:21 <dolio> Along with curry3 and such.
21:06:25 <stepcut> luite_: I was just about to say that
21:06:43 <dolio> Or maybe it's fst3 and so on.
21:07:00 * bd_ would much prefer a recursively constructed n-tuple type
21:07:14 <Twey> That would be a 'list', bd_
21:07:35 <bd_> Twey: lists are homogenous and have an indeterminate number of elements
21:07:47 <bd_> n-tuples are heterogeneous and have a fixed number of elements
21:08:01 <bd_> essentially turning (1, 2, 3) into (1, !(2,3))
21:08:07 <bd_> is what would be nice
21:08:16 <Trinithis> Is it possible to derive Show, but have a special case instance for one constructor of the data?
21:08:26 <ajdhs> is there a good way to use CPP in conjunction with bird-style literate haskell scripts?
21:08:38 <stepcut> http://www.mail-archive.com/haskell-cafe@haskell.org/msg42896.html
21:08:40 <psibot> Title: Re: [Haskell-cafe] history of tuples vs pairs, http://tinyurl.com/5pxxfy
21:08:48 <bd_> Trinithis: You could derive show, then newtype it and write your own show instance on the newtype
21:09:01 <Trinithis> haha
21:09:03 <dolio> It does potentially make tuples less efficient.
21:09:18 <stepcut> that link is a brief discussion on n-tuples vs nested tuples
21:09:28 <Trinithis> what about overlapping instances? would that do the job?
21:09:36 <dolio> Unless the compiler optimizes it from the inductive representation to the representation it has now.
21:09:41 <bd_> dolio: the compiler can optimize it to a n-tuple easily enough, I'd hope
21:09:47 <bd_> the semantics ought to be the same.
21:09:53 <bd_> (given the right side is strict)
21:10:27 <dolio> Yeah. I'm not nearly enough of a compiler guru to know what problems that'd actually cause.
21:11:48 <bd_> either way, I don't think fst3 and friends should go in
21:11:51 <bd_> horrible, horrible hack
21:13:05 <mmorrow> bd_: template-haskell can make you nice 4,19,128,1000 tuples with Int-taking indexing functions pretty nicely :)
21:13:24 <mmorrow> (although i think ghc can only handle around 256-tuples (or maybe 128))
21:14:32 <bd_> mmorrow: we shouldn't -need- TH to workaround things that can be more easily fixed in the language itself :)
21:14:50 <heavensrevenge> hello
21:15:10 <heavensrevenge> how in the WORLD can i use numbers as input on the command line in a shell(bash
21:15:22 <Twey> heavensrevenge: read
21:15:26 <heavensrevenge> seems like every tutorial ive found only uses strings
21:15:32 <heavensrevenge> like getLine
21:15:35 <Twey> getArgs gives you a list of strings
21:15:36 <heavensrevenge> thats it?!?!
21:15:44 <heavensrevenge> i just want a # :(
21:15:45 <Twey> Then read will convert one of those strings into a number
21:15:52 <heavensrevenge> ok
21:15:58 <heavensrevenge> ill try it now
21:16:03 <heavensrevenge> it was almost frustrating
21:16:13 <Twey> > let args = ["2"] in read (args!!0) :: Int
21:16:16 <psibot>  2
21:16:50 <heavensrevenge> please can u help me with this?? iull paste it into hpaste
21:17:01 <Twey> 's what we're here for
21:17:22 <Olathe> omgzors !!
21:17:31 <Olathe> he's using the double question marks !
21:17:39 <Olathe> we must spring into action !!
21:18:04 <ddarius> Ah topato
21:18:27 <mmorrow> bd_: very much agreed. but no matter how great the language is, there'll still be things the metalang can do that the language can't :)
21:19:14 <mmorrow> (unless it has a dynamic eval function, in which case it becomes its own metalang)
21:19:41 <mmorrow> (modulo some qualifications/blahblah)
21:22:09 <heavensrevenge> http://codepad.org/6bcTzJHd
21:22:34 <heavensrevenge> Twey and psibot can u please give me a hand, ive been trying to figure out HOW in the world to get numerical input
21:22:34 <nornagon> @botsnack
21:22:34 <psibot> :)
21:22:40 <heavensrevenge> its seriously killing me man
21:22:51 <dons> go psibot !
21:23:05 <dons> heavensrevenge: 'read'
21:23:13 <dons> > read "42"
21:23:13 <heavensrevenge> could you edit it and show me??
21:23:16 <psibot>  * Exception: Prelude.read: no parse
21:23:21 <dons> psibot: wtf?
21:23:22 <mwc> dons: hah?
21:23:26 <Twey> Hahaha
21:23:26 <heavensrevenge> like on codepad, how would you make it work?
21:23:27 <luite_> hehe
21:23:30 <mwc> apparently psubot is on vengeance
21:23:37 <shachaf> > read "42" :: Integer
21:23:40 <psibot>  42
21:23:42 <heavensrevenge> or ill use hpaste if you guys like
21:23:47 <mwc> well, I see two problems
21:23:47 <heavensrevenge> no i mea n to compile
21:23:51 <heavensrevenge> and as an executable
21:23:52 <mwc> first is that you need to use read
21:23:53 <shachaf> > read "()"
21:23:56 <psibot>  ()
21:24:04 <dons> -fextended-defaulting smacks me upside the head
21:24:19 <mwc> something as simple as let n = read input
21:24:41 <mwc> secondly, your let fac1 nu = ... binds nu in the context of its definition
21:24:49 <Twey> heavensrevenge: I said 'read' not 'show'
21:24:53 <mwc> so fac1 is a function, it doesn't use the nu previously
21:24:57 <heavensrevenge> ok
21:25:01 <heavensrevenge> ill edit it to try
21:25:14 <Twey> read and show are opposites.  read converts a string to an arbitrary datatype, and show converts an arbitrary datatype to a string.
21:25:30 <heavensrevenge> factorials.hs:11:41:
21:25:30 <heavensrevenge>     lexical error in string/character literal at character '\n'
21:26:22 <heavensrevenge> or am i going about this the wrong way to make a compilable factorial?
21:26:25 <mwc> heavensrevenge: http://codepad.org/nGDOBbD2
21:26:36 <heavensrevenge> ill do ANYTHING to get this to work
21:26:51 <shachaf> What happened to lambdabot this time? Does Cale still run her?
21:28:30 <heavensrevenge> THANK YOU!!!!!!!!
21:28:46 <heavensrevenge> why isnt any numerical input used in any tutorials??
21:28:48 <mwc> home work is done, you can go to bed now ;)
21:29:14 <heavensrevenge> lol no man that was stressful
21:29:26 <heavensrevenge> now i can actuall solve problems i wanted to since a weekl!!!
21:29:44 <heavensrevenge> ive been trying to get something to work for a whole friggin week, it was killing my brain
21:29:46 <Twey> main = putStrLn "Please enter a number..." >> getLine >>= putStrLn . ("The factorial is " ++) . show . (product . (enumFromTo 0)) . read
21:29:46 <jeffz> heavensrevenge: yaht page 27
21:29:52 <heavensrevenge> yet it was so simple
21:31:05 <mwc> Twey: points free tends to freak out the newcomers ;)
21:32:02 <shachaf> Not to mention that it doesn't work.
21:32:14 <shachaf> > product [0..5]
21:32:18 <psibot>  0
21:32:32 <Olathe> > product [0..]
21:32:32 <heavensrevenge> haha
21:32:41 <Olathe> Silly bot.
21:32:44 <heavensrevenge> > product [1..5]
21:32:48 <psibot>  thread killed
21:32:54 <heavensrevenge> awes
21:32:54 <mwc> that's harsh
21:32:58 <heavensrevenge> > product [1..3]
21:32:59 <Twey> Oh, yeah.
21:33:00 <psibot>  thread killed
21:33:02 <Twey> Should be 1..
21:33:03 <heavensrevenge> NEH
21:33:13 <psibot>  thread killed
21:33:14 <heavensrevenge> thread killed my ass...
21:33:25 <Olathe> > product [0,2394832928424..]
21:33:32 <Olathe> That should take a bit less time.
21:33:40 <psibot>  thread killed
21:33:44 <heavensrevenge> mwc, you are awesome, thank you very much for the help!!!
21:33:46 <chrisdone> main = putStrLn "Please enter a number..." >> getLine >>= read >>> enumFromTo 1 >>> product >>> show >>> ("The factorial is " ++) >>> putStrLn
21:34:14 <heavensrevenge> you guys really have alot of Haskell magic, ill learn slowly
21:34:24 <Twey> putStrLn "Please enter a number..." >> getLine >>= putStrLn . ("The factorial is " ++) . show . (product . (enumFromTo 1)) . (read :: String -> Int)
21:34:25 <heavensrevenge> goal: become as good as you guys
21:34:49 <shachaf> chrisdone: I think you need more parentheses.
21:34:57 * Twey is just a newbie.
21:35:03 <dibblego> are * let ap' x y = x >>= \a -> fmap (\f -> f a) y * and * let ap'' x y = y >>= \f -> fmap f x * equivalent?
21:35:06 <Capso> Twey: Hey
21:35:17 <Twey> Hi Capso
21:35:28 <chrisdone> putStrLn "Please enter a number..." >> getLine >>= (read >>> enumFromTo 1 >>> product >>> show >>> ("The factorial is " ++) >>> putStrLn)
21:35:31 <chrisdone> is sufficient
21:36:27 <dibblego> @let let ap' x y = x >>= \a -> fmap (\f -> f a) y
21:36:27 <psibot>  Parse error
21:36:30 <dibblego> @let ap' x y = x >>= \a -> fmap (\f -> f a) y
21:36:41 <psibot> Defined.
21:36:48 <dibblego> @let ap'' x y = y >>= \f -> fmap f x
21:36:50 <psibot> Defined.
21:37:03 <dibblego> @check \x y -> ap' x y == ap'' x y
21:37:07 <psibot>  mueval: Time limit exceeded
21:37:15 <Twey> @src (>>>)
21:37:16 <psibot> Source not found. It can only be attributed to human error.
21:37:18 <chrisdone> good olde Control.Applicative
21:37:23 <Twey> :(
21:37:46 <chrisdone> uh, Arrow
21:38:05 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#v%3A%3E%3E%3E
21:38:48 <chrisdone> psibot: hello, computer.
21:38:57 <chrisdone> where did psibot come from?
21:39:34 <shachaf> Saizan, it looks like.
21:40:16 <chrisdone> Saizan: it sprang forth from your belly‽
21:41:27 <shachaf> dibblego: No, they aren't.
21:41:40 <dibblego> shachaf, my lambdabot passed 500 tests
21:41:49 <dibblego> @check \x y -> let ap1 :: [a] -> [a -> b] -> [b]; ap1 x y = x >>= \a -> fmap (\f -> f a) y; ap2 x y = y >>= \f -> fmap f x in (ap1 x y) == (ap2 x y)
21:41:51 <shachaf> dibblego: Must be using the wrong monad. :-)
21:41:58 <dibblego> ok
21:42:06 <shachaf> dibblego: Different order.
21:42:08 <dibblego> which is equal to Monad.ap?
21:42:20 <chrisdone> > (((+1) >>> (*2)) &&& ((*2) <<< (+1))) 10
21:42:40 <shachaf> Well, neither.
21:42:49 <dibblego> s/fmap/liftM
21:42:54 <shachaf> But ap'' = flip ap, I guess.
21:42:55 <dibblego> now which?
21:43:01 <dibblego> oh right ok thanks
21:43:25 <dibblego> which monad should fail the test except IO?
21:43:39 <shachaf> dibblego: Most of them. :-) Anything that depends on order.
21:43:46 <shachaf> Writer and State, for example.
21:44:49 <shachaf> > ap' (tell "a" >> return 1) (tell "b" >> return id)
21:45:06 <dibblego> yes I can see that in my brain, thanks
21:45:17 <nornagon> @botsnack
21:45:20 <nornagon> :(
21:45:22 <chrisdone> psibot: you are the rubbish
21:45:47 <shachaf> Oh no! It's a bot disease. Keep them away from this channel.
21:45:49 <psibot>  mueval: Time limit exceeded
21:45:49 <psibot> :)
21:45:54 <psibot> Terminated
21:45:54 <psibot> Terminated
21:46:25 <bshanks> hi all
21:47:23 <bshanks> just upgraded some packages with cabal and am getting this error now:     Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString'
21:47:23 <bshanks>            against inferred type `B.ByteString'
21:47:23 <bshanks>     In the expression: B.pack "text/html"
21:47:57 <shachaf> Who is responsible for mueval? Was it gwern?
21:48:03 <bshanks> (B.ByteString is defined by: "import qualified Data.ByteString.Char8 as B
21:48:03 <bshanks> ")
21:51:57 <bshanks> this IRC log seems to be related: http://gernot-heiser.org/~dons/code/irc-logs/08.05.29
21:52:08 <bshanks> but i still don't know how to fix it
22:00:47 <Trinithis> > bring up bot
22:01:06 <psibot>  thread killed
22:03:25 <mmorrow> > error (fix id)
22:03:34 <Trinithis> night
22:04:30 <bshanks> so, http://gernot-heiser.org/~dons/code/irc-logs/08.05.29 suggests that you can force a specific version of a package with "--constraint" in Cabal or "build-depends". how do I know which package is causing the conflict, and which version of bytestring to force?
22:05:06 <cjs> It should give you version numbers. Last time I got a complaint along these lines from Cabal, it told me exactly who was looking for what, and what was there.
22:05:12 <mmorrow>  bshanks: by the error msgs
22:05:34 <bshanks> it's not Cabal giving me the error, it's a compile-time error from "runghc" when i try to run my program.
22:05:42 <mmorrow> exactly
22:05:49 <mmorrow> what does the error say?
22:05:57 <bshanks>   Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString'
22:05:57 <bshanks> <bshanks>            against inferred type `B.ByteString'
22:05:57 <bshanks> <bshanks>     In the expression: B.pack "text/html"
22:06:08 <mmorrow> ok, so what does
22:06:14 <mmorrow> $ ghc-pkg list bytestring
22:06:16 <mmorrow> say?
22:06:21 <mbeddoe> if i wanted to do something similar to ruby's string.unpack, does anyone have any suggestions?
22:06:35 <mbeddoe> i need to convert a bytestream to an actual integer or string or whatever
22:06:59 <bshanks> mmorrow: /usr/lib/ghc-6.8.2/package.conf:
22:06:59 <bshanks>     bytestring-0.9.0.1
22:06:59 <bshanks> /home/bshanks/.ghc/x86_64-linux-6.8.2/package.conf:
22:06:59 <bshanks>     bytestring-0.9.1.0, bytestring-0.9.1.2
22:07:15 <mmorrow> ok, so notice  "bytestring-0.9.1.0, bytestring-0.9.1.2"
22:07:24 <mmorrow> there are two ways to do this
22:07:28 <bshanks> ok
22:07:58 <mmorrow> the first being what you should do, which is edit the .cabal file change the build-depends: field from
22:08:18 <mmorrow> bytestring     ----->      bytestring <  0.9.1.2
22:08:39 <mmorrow> (the second being do         sudo ghc-pkg hide bytestring-0.9.1.2 )
22:09:00 <mmorrow> then continue doing hide/expose juggling depending on the current pkg you're building :)
22:09:09 <mmorrow> ha
22:09:18 <bshanks> mmorrow. thx. which package's .cabal file should i change?
22:09:44 <cjs> You can just use "read" for this sort of
22:09:46 <mmorrow> oh, hmm. so this is happening in ghci then?
22:09:51 <cjs> ...thing, if you want to do it simply but slowly.
22:10:29 <mmorrow> bshanks: what are you running while this happens?
22:11:07 <bshanks> mmorrow: well, i've been using "runghc". But, yes, if I do "ghci" and then ":l Main" in my program's source directory, the same error results
22:12:33 <mmorrow> ok, i misdiagnosed. so there's a module you're importing which is from a package which was built against bytestring-0.9.1.0, so you have to rebuild whatever package that is against the new bytestring you've gotten
22:12:34 <bshanks> mmorrow: if i had to guess, HStringTemplate and HAppS are the packages that are demanding different versions of bytestring (both are used in my program). But I'm wondering if there's a way to find out for sure.
22:13:05 <mmorrow> hmm. have you built either since you acquired the newer bytestring?
22:14:25 <mmorrow> bshanks: since maybe just rebuild both. that way any error you'll eventually see, you can force to happen right now.
22:14:29 <bshanks> mmorrow: cabal built a bunch of stuff. i assume that hstringtemplate or its dependencies are what wants the newer version b/c i upgraded it explicitly -- so perhaps the thing is to rebuild HAppS? But isn't there some way to find out for sure which one needs to be rebuilt, rather than guessing?
22:14:31 <mmorrow> s/since//
22:15:29 <mmorrow> bshanks: possibly. maybe run ghci, then import some ByteString, then import some bytestring using thing from HStringTemplate and try to cause an error
22:15:35 <mmorrow> then do the same for happs
22:15:44 <mmorrow> save that, i'm not sure the best way
22:15:59 <bshanks> mmorrow: ok, thanks, i'll try that
22:16:03 <mmorrow> i assume that hstringtemplate or its dependencies are what wants the newer version b/c i upgraded it explicitly
22:16:05 <mmorrow> oh, it
22:16:14 <mmorrow> 's probably that then, but yeah try both :)
22:17:59 <dons> just in case it was Data.Binary, i lowered the required bytestring version for it.
22:18:15 <bshanks> another random question: if i get an error while loading an .hs file in ghci, is there a way to ask for the type of something in that file (a la :t) (short of commenting out code until there is no error anymore and then loading it)?
22:18:17 <dons> but yeah, either upgrade bytestring before anything else is built, or don't upgrade it.
22:18:36 <dons> bshanks: no, sadly. there's no incremental type checker.
22:18:41 <dons> bshanks: but {- -} is useful.
22:18:45 <dons> as is 'undefined'
22:19:16 <bshanks> dons: thx
22:22:09 <bshanks> how does one tell cabal to rebuild a package? (for that matter, how does one uninstall a package?)
22:23:32 <dons> ghc-pkg unregister foo
22:23:34 <dons> or
22:23:38 <dons> ghc-pkg unregister --user foo
22:23:45 <dons> depending on whether you installed globally or locally.
22:23:52 <dons> to force upgrade, cabal has a flag,
22:24:36 <dons> cabal install foo --reinstall
22:24:55 <bshanks> dons: thanks
22:24:59 * araujo just released a new himerge version
22:25:06 <dons> go araujo !
22:25:18 <dons> is himerge on hackage?
22:26:17 <araujo> dons, yes!!
22:26:19 <araujo> :-]
22:28:41 <bshanks> ok, i successfully got my original problem working. for future googlers, the problem was: i upgraded something with cabal (specifically, i executed "cabal install HStringTemplate"). the upgrade completed successfully. then, when I used runghc to run my program ("runghc Main.hs"), I got the following error:
22:28:53 <bshanks> Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString'
22:29:08 <bshanks>  against inferred type `B.ByteString'
22:29:29 <bshanks> (there were a bunch of other errors, but I neglected to save them and they scrolled off, sorry)
22:29:32 <bshanks> the solution was:
22:29:34 <dons> ok. and that was caused by something pulling in the new bytestring?
22:29:35 <mmorrow> "the dreaded diamond dependency"
22:29:57 <bshanks> (1) realize that two of my imports were using different versions of bytestring
22:30:45 <dons> bshanks: btw, http://blog.well-typed.com/2008/08/solving-the-diamond-dependency-problem/
22:30:50 <dons> is relevant to your interests.
22:30:51 <bshanks> (2) figure out which two they were, by manual trial and error (in this case i guessed it was HStringTemplate)
22:30:54 <mmorrow> http://blog.well-typed.com/2008/08/solving-the-diamond-dependency-problem/
22:31:01 <mmorrow> http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
22:31:04 <dons> jinx mmorrow
22:31:10 <mmorrow> haha
22:31:20 <mmorrow> whoa
22:31:46 <bshanks> (3) make cabal rebuild them, using "cabal install foo" (and perhaps "cabal install foo --reinstall")
22:32:37 <dons> good solutoin.
22:34:56 <bshanks> re: diamond dependency problem: thanks, folks. actually i had found those but i didn't understand how to actually solve it after reading the blog post -- the issue was that i didn't understand how to do what i called steps (2) and (3) above, that is, how to identify the packages causing the problem, and how to get these packages to change which library versions they use. my current understanding is that the answers are: manually gues
22:34:56 <bshanks> s which packages are "at fault", and then use "cabal install foo --reinstall" to rebuild a package with the newer library versions.
22:35:32 <dons> mm. yes. good point.
22:36:08 <dons> i wonder how smart cabal could be about identifying which packages to upgrade.
22:37:48 <bshanks> dons: hmm. another thing that might help: when ghc gave an error along the lines of "couldn't match expected type X against inferred type Y", there were a way to tell it to report a trace of how it got those two types, with the trace containing all of the packages that were referenced (perhaps there is already a way to do this that i don't know about?)
22:38:13 <dons> mm. more package info.
22:38:28 <dons> packages are just so so important these days, and managing them well is vital.
22:40:21 <bshanks> yeah, seems that way.
22:42:32 <cjs> What does one use for queues in Haskell?
22:42:36 <bshanks> at least in this case (when two imported packages are using two different versions of the same type), it seems like the type inference that the compiler is doing should contain enough information to pinpoint the problem.
22:42:45 <cjs> A simple FIFO one, I mean.
22:42:54 <dons> cjs, dlists?
22:43:06 <dons> Chans?
22:43:59 <cjs> Dlist looks good. Hmm. Hadn't thought about using a channel, but I guess you can have one function reading and writing it by itself.
22:44:16 <cjs> Are they very efficient, though? I don't need any locking any or anything like that.
22:44:40 <dons> Chans? yeah,
22:44:51 <dons> but of course, they're thread safe.
22:45:14 <dons> but they're in IO
22:45:15 <cjs> And look who wrote dlist. I swear to God, Don, you've probably written about half my application.
22:45:25 <cjs> I'm in IO anyway; I'm using an IORef.
22:45:26 <dons> hmm. :) if all the libs are there, that's good!
22:45:41 <dons> you can also convert one end of the channel into a lazy list
22:45:46 <dons> whose items appear as they're pushed in.
22:46:08 <dons> i'm not sure if dlist makes perfect sense
22:46:16 <dons> but you can append efficiently.
22:46:21 <cjs> Yeah, but I can't wait for stuff; my reader is not a new thread but an existing one.
22:46:39 <cjs> Actually, hmm...I'm already using a chan for another part of this; maybe I can re-use that.
22:47:27 <cjs> Oh, huh, yeah! Great.
23:18:55 <quicksilver> dons: I thought the error message bshanks was describing already *did* include the package name and version.
23:19:10 <dons> for one type, i think
23:19:12 <quicksilver> I could swear I've seen bytestring type errors mentioning exact package versions in the GHC error.
23:19:17 <dons> 0.9.0.1:ByteString vs ByteString
23:19:21 <quicksilver> ah.
23:20:40 <waynemokane> how can one extract the state from a State?
23:20:52 <waynemokane> *MyState Monad Control.Monad.State> :t myst
23:20:52 <waynemokane> myst :: State Integer Integer
23:20:54 <dons> st <- get
23:21:02 <dons> oh, run it.
23:21:19 <dons> > runState (do x <- get ; put (x + 7) ; return "done") 12
23:21:41 <waynemokane> hmm, well I was trying to do this interactively
23:21:51 <waynemokane> I'm sure to be missing something obvious
23:22:39 <dons> myst isn't actually the state
23:22:51 <dons> it's a monadic computation that when run, will yield the result of the computation
23:23:08 <dons> inside a stateful block, you can get the current implicit state with 'get'
23:23:18 <dons> Prelude> :m + Control.Monad.State
23:23:18 <dons> Prelude Control.Monad.State> runState (do x <- get ; put (x + 7) ; return "done") 12
23:23:21 <dons> ("done",19)
23:23:23 <dons> Cale: need a lambdabot.
23:23:38 <dons> or we should revert to lambdabot circa 2006jan.
23:24:05 <waynemokane> oh interesting... so I was hoping to have a state that I just kept modifying interactively, but I guess having an expression of State s, isn't really what I need
23:24:34 <dons> well, you have that state for the scope of the runState's expression
23:24:44 <dons> main = print . runState $ do .... -- your whole program will be in the State monad.
23:25:06 <waynemokane> ooooh interesting
23:25:15 <waynemokane> OK so basically since I am in a default ghci session
23:25:23 <waynemokane> I can't really *do* anything within State s
23:25:29 <waynemokane> since I'm only in IO ()
23:25:49 <waynemokane> I can run something which returns a monadic action but that is lost as soon as it goes back to IO
23:26:38 <waynemokane> see I basically was messing around and made this:
23:26:39 <waynemokane> tryInOrder :: [a -> a] -> a -> State a a
23:26:39 <waynemokane> tryInOrder mods st =  foldr withState (create st) mods
23:26:46 <waynemokane> but that is a pointless thing to have, I can see now
