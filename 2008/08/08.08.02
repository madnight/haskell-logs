00:02:51 <adu> @karma Data.Sequence
00:02:52 <lambdabot> Data.Sequence has a karma of 0
00:03:01 <sjanssen> @karma Monoid
00:03:02 <lambdabot> Monoid has a karma of 0
00:03:07 <sjanssen> @karma monoid
00:03:07 <lambdabot> monoid has a karma of 0
00:03:16 <adu> Data.Sequence++
00:03:26 <adu> @karma Data.Sequence
00:03:26 <lambdabot> Data.Sequence has a karma of 1
00:03:33 <adu> @karma adu
00:03:33 <lambdabot> You have a karma of 0
00:03:37 <adu> :(
00:04:09 <adu> @karma sjanssen
00:04:09 <lambdabot> sjanssen has a karma of 0
00:04:16 <sjanssen> @karma dons
00:04:16 <lambdabot> dons has a karma of 2
00:04:21 <adu> heh
00:04:21 <sjanssen> now we know it's broken.
00:04:35 <adu> sjanssen++
00:04:39 <sjanssen> adu: dons used to have more than 100 karma points
00:04:39 <adu> @karma sjanssen
00:04:39 <lambdabot> sjanssen has a karma of 1
00:04:49 <sjanssen> lambdabot forgets things all the time
00:04:50 <adu> lol
00:05:00 <adu> adu--
00:05:04 <adu> @karma adu
00:05:04 <lambdabot> You have a karma of 0
00:05:09 <adu> adu--
00:05:12 <adu> @karma adu
00:05:12 <lambdabot> You have a karma of 0
00:05:16 <sjanssen> hmm
00:05:34 <Jedai> I don't think you can change your own karma
00:05:37 <Jedai> adu++
00:05:37 <jeffwheeler> I'm having some trouble compiling some code in OS X. Running my code with 'runhaskell' works fine, but compiling with 'ghc sourcefile' (or with -o), I get this error: http://pastie.org/246082.
00:05:38 <lambdabot> Title: #246082 - Pastie
00:05:43 <Jedai> @karma adu
00:05:43 <lambdabot> adu has a karma of 1
00:05:49 <kristofer> yo
00:05:53 <jeffwheeler> It appears to be related to some parsec linking.
00:06:05 <sjanssen> jeffwheeler: use --make or -package parsec
00:06:31 <adu> Jedai: have you tried "ghc --make ....hs"
00:06:32 <jeffwheeler> sjanssen: ah, perfect; thanks :)
00:06:41 <jeffwheeler> (and adu)
00:07:22 <sjanssen> jeffwheeler: if you're used to C, forgetting -package is like forgetting to pass -l to gcc
00:07:35 <kristofer> I'm getting this.. 'failed to load interface for SOEGraphics'.
00:07:46 <jeffwheeler> sjanssen: whenever I've had more than one file to compile, I used Make --- I've never done anything complicated :)
00:07:50 <sjanssen> and --make means "figure it out for me"
00:08:12 <adu> jeffwheeler: is croptriangles.o doing vector graphics? or fringe ufology?
00:08:26 * sjanssen hopes for the latter
00:08:36 <sjanssen> adu++ you earned that
00:08:50 <jeffwheeler> adu: I was playing with a problem from the Google Code Jam a few days ago; I didn't participate, but you can still submit solutions for the fun of it (and it'll check them)
00:08:51 <adu> :)
00:09:17 <jeffwheeler> adu: unfortunately, my solution is far, far too slow :D
00:10:35 <jeffwheeler> I have no idea if it'll even be finished when I wake up tomorrow. :P
00:10:51 <kristofer> I just wanted to know more about soegraphics.. I'm trying to work though "The Haskell School of Expression" by Paul Hudak and I can't seem to get any further here.
00:12:30 <adu> wow, the code jam is actually about fringe ufology...
00:12:49 <sjanssen> kristofer: SOEGraphics is not necessarily packaged with your Haskell system, you probably need to install it
00:13:43 <adu> (Round 1B)
00:13:44 <sjanssen> @google soe graphics site:hackage.haskell.org
00:13:45 <lambdabot> No Result Found.
00:13:52 <sjanssen> @google soe site:hackage.haskell.org
00:13:52 <lambdabot> No Result Found.
00:14:04 <jeffz> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk
00:14:04 <lambdabot> Title: HackageDB: soegtk-0.9.12.2
00:14:16 * jeffz puts lambdabot out of a job.
00:14:46 <sjanssen>  @google sucks sometimes, and I'm not sure why
00:15:02 <adu> has anyone here heard of cuil?
00:15:09 <jeffz> adu, yes
00:15:11 <jeffwheeler> adu: worst results ever
00:15:42 <sjanssen> the actual google.com search page returns useful results, but lambdabot fails for the same query
00:16:11 <jeffwheeler> Did anybody see Yuil? It was a Yahoo person's recreation that actually had good results, but looked identical and used Yahoo's BOSS API.
00:16:15 <jeffwheeler> It was pretty darn funny.
00:16:30 <dibblego> why does xmonad seem to release every month up until Mar 2008 (0.7); is this the recommended version for a first time user?
00:18:05 <adu> lol cuil.com shows a creditcard for the haskell98 tutorial lol
00:18:22 <kristofer> aha! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL
00:18:22 <lambdabot> Title: HackageDB: HGL-3.2.0.0
00:33:01 <Jedai> dibblego: You can pretty much go for the last release in XMonad case, it has a comprehensive testsuite and some other tools that ensures that it is pretty stable
00:33:26 <dibblego> ok ta
00:38:21 <jeffwheeler> Is the best way to test a non-Integral-typed number for being a number to round, and then test for equality?
00:38:29 <jeffwheeler> Or . . . I'm sure there's gotta be a better way.
00:38:50 <jeffwheeler> I mean, how can I see that 4.0 is integral, while 4.1 is not.
00:43:45 <haskellator> is there a multi break?  like applying unfoldr and break on a list .. like "asdf#qwer#kh" to give [ "asdf" ,"#qwer","#kh"]
00:44:42 <david48> haskellator: I think I remember a post about it on haskell-cafe
00:44:50 <haskellator> basically im trying to use unfoldr and break, but it seems to me there might already be something to do that.
00:45:04 <opqdonut> haskellator: no, nothing out of the box
00:45:16 <opqdonut> tho there are multiple cute oneliners
00:45:26 <haskellator> example please ?
00:45:30 <RayNbow> haskellator: you could try using groupBy?
00:45:43 <haskellator> problem is groupBy needs a function that takes two parms
00:45:55 <haskellator> > groupBy (\x y-> y == '#') " qwer#pou#134"
00:45:56 <lambdabot>  [" ","q","w","e","r#","p","o","u#","1","3","4"]
00:48:59 <RayNbow> > groupBy (\x y-> y /= '#') " qwer#pou#134"
00:49:00 <lambdabot>  [" qwer","#pou","#134"]
00:49:09 <RayNbow> ^ haskellator?
00:49:46 <haskellator> dunks head in shame
00:49:51 * haskellator dunks head in shame
00:49:59 <david48> doh, me too.
00:50:04 <cjs> Oh Lord. I just realized the true historical ramifications of my, "keep lines less than 80 columns" policy.
00:50:26 * RayNbow had to look up the definition of groupBy and span though :p
00:50:49 <haskellator> @check groupBy (\x y-> y /= '#')
00:50:51 <lambdabot>   add an instance declaration for (Testable [[Char]])     In the expression:,...
00:51:02 <haskellator> how do i have lbot test this?
00:51:04 <cjs> On the other hand, that I came here to say that introduced me to groupBy and a cool way to use it, so, I'm now happy.
00:51:55 <RayNbow> haskellator: what exactly do you want to test?
00:52:14 <haskellator> actually i just did manually on all the cases i run into
00:52:44 <haskellator> but i saw some one use @check or something similar and lambda bot generated a few hundred test cases for a function he was showing
00:53:43 <RayNbow> @check \xs ys -> reverse (xs ++ ys) == (reverse ys ++ reverse xs)
00:53:44 <lambdabot>  OK, passed 500 tests.
00:53:58 <RayNbow> you need to check a function that evaluates to a bool
00:54:02 <RayNbow> :t \xs ys -> reverse (xs ++ ys) == (reverse ys ++ reverse xs)
00:54:03 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
00:54:06 <cjs> Ah, that's QuickCheck.
00:54:38 <dolio> Not necessarily a Bool.
00:55:04 <kristofer> can somebody give me a hand with this? http://hpaste.org/9336
00:55:30 <haskellator> thanks RayNbow , ill go to bed now. 1 AM!! but i cant shift the blame for my stupidity/oversight to the time .. or lack of sleep
00:55:33 <haskellator> bye
00:55:49 <jeffz> kristofer: try ghc --make
00:55:53 <dolio> @check ()
00:55:54 <lambdabot>  Arguments exhausted after 0 tests.
00:56:31 <kristofer> jeffz: that doesn't give me a binary to run though?
00:56:54 <jeffz> kristofer: hmm? ghc --make foo.hs, shoudl produce foo
00:57:21 <kristofer> I ended up with simplegraphics.hi, and simplegraphics.o
00:57:44 <RayNbow> dolio: well, I don't have much experience with QC yet... but I know that a -> b -> Bool are Testable :)
00:58:03 <jeffz> kristofer: do you have a module with a main function?
00:58:03 <dolio> Yeah. There's a class for it.
00:58:15 <dolio> Bool is one Testable. So is () (although I don't know what good that is).
00:58:19 <kristofer> jeffz: yep
00:59:53 <glguy> Can anyone think of a reason for me to not add the BaseM (ST s) (ST s) instance to monadLib?
01:00:09 <glguy> I'd ask Iavor, but he's still out on holiday
01:00:43 <dolio> I was thinking about it when you mentioned it the other day, and I couldn't think of any.
01:01:19 <kristofer> jeffz: any other ideas?
01:01:28 <jeffz> kristofer: fresh out.
01:01:31 <glguy> I guess that bumps 3.4.4 to 3.4.5
01:04:00 <rwbarton> kristofer: is simplegraphics.hs the file with your Main module?
01:04:08 <kristofer> yeah
01:04:13 <dons> glguy: instances are probably ok.
01:04:15 <rwbarton> have you tried ghc --make simplegraphics ?
01:04:52 <kristofer> rwbarton: I'm still getting the .hi and the .o files, but no binary
01:05:06 <rwbarton> oh, try ghc --make -o simplegraphics
01:05:31 <glguy> oops, permissions got messed up on darcs.h.o/packages/monadLib
01:05:41 <glguy> I'll have to wait for yav to come home
01:07:50 <kristofer> it must be something with the code.. do I need to create a Main module or something? there's a main() function in the SimpleGraphics module
01:08:23 <rwbarton> I think main needs to be in a module called Main, otherwise it's just another function
01:08:45 <rwbarton> i.e., yes :)
01:09:06 <rwbarton> (You can probably give ghc an option to change its idea of what the main function should be called)
01:19:53 <kristofer> hmm... now I'm getting this type issue. Couldn't match expected type IO a against inferred type () -> IO () when checking the type of function main
01:24:32 <rwbarton> You should write main = do ..., not main () = do ...
01:24:51 <glguy> http://hpaste.org/9337#a1
01:25:09 <glguy> could someone help me to understand why it is the case that runA2 causes this error while runA1 works?
01:25:33 <dons> that's weird.
01:26:07 <glguy> http://hpaste.org/9337#a2
01:26:11 <glguy> that one works too
01:26:24 <glguy> which seems like it ought to be the same as #2
01:26:25 <dons> super weird.
01:27:01 <dons>   \ (@ a_a6e) (a_a5V :: forall s_a5S. WeirdType.A s_a5S a_a6e) ->
01:27:02 <dons>     case a_a5V @ Any of tpl_B2 { WeirdType.A ipv_B3 -> ipv_B3 }
01:27:07 <dons> is runA1
01:27:12 <dons>   \ (@ a_a69) (a_a5X :: forall s_a5O. WeirdType.A s_a5O a_a69) ->
01:27:12 <dons>     case a_a5X @ Any of wild_B1 { WeirdType.A x_a5Z -> x_a5Z }
01:27:15 <dons> is runA3
01:27:23 <glguy> identical
01:29:07 <dons> what's the type of unA ?
01:29:23 <glguy> *WeirdType> :t unA
01:29:23 <dons> unA :: A s a -> a, hmm
01:29:24 <glguy> unA :: A s a -> a
01:29:39 <dons> runA2 :: A s a -> a
01:30:48 <glguy> runA4 :: (forall s. A s a) -> a
01:30:48 <glguy> runA4 a = let A x = a in x
01:30:50 <glguy> also works :)
01:31:24 <dons> note they all type check with runA1 :: (A s a) -> a
01:31:27 <nominolo> it's of course a type-checker issue
01:31:36 <dons> nominolo: a bug, you think?
01:31:42 <dons> in the checking of patterns?
01:31:45 <glguy> runA5 :: (forall s. A s a) -> a
01:31:46 <glguy> runA5 a = go a
01:31:46 <glguy>   where go (A a) = a
01:31:47 <glguy> that works
01:31:54 <dons> ok.
01:31:54 <nominolo> not sure if it's a bug, but certainly a border case
01:31:56 <glguy> so I can do the pattern match in a function argument
01:31:57 <dons> yeah.
01:32:02 <glguy> just not the one with the type on it
01:32:14 <dons> glguy: so check against head, then if it fails, file a bug report.
01:32:21 <dons> or ask someone with the head to check.
01:32:38 <dons> nominolo: this is what happens when you write type checkers on the src-level AST, not core :)
01:32:46 <glguy> do we have head laying around somewhere?
01:32:52 <glguy> on one of the machines at work maybe?
01:32:55 <dons> glguy: we don't, igloo does.
01:33:02 <dons> there's binaries too.
01:34:14 <nominolo> my head is currently broken
01:34:20 <glguy> I've run into this  before and I always assumed I didn't understand rank-2 types well enough
01:34:26 <glguy> didn't occur that it might be a bug
01:34:28 <dons> nominolo: :)
01:34:53 <chrisdone> @type \(State s a) -> (a,s)
01:34:54 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
01:34:55 <nominolo> dons: hm, lemme check, maybe i have the binary somewhere
01:35:14 <chrisdone> @type \s -> runState s
01:35:15 <lambdabot> forall s a. State s a -> s -> (a, s)
01:35:26 <glguy> checking for path to top of build tree... ./configure: line 2696: utils/pwd/pwd: cannot execute binary file
01:35:27 <glguy> huh?
01:35:35 <glguy> it uses a local pwd binary??
01:36:18 <rwbarton> is that a recent HEAD snapshot?
01:36:42 <rwbarton> they've been broken like that.  I think you can just delete utils/pwd/pwd, or maybe delete it and then remake it
01:36:43 <glguy> yes, and I seem to have fixed the issue by deleting that file
01:37:01 <glguy> it was an amd64 linux binary
01:37:11 <nominolo> glguy: same with head from a week ago
01:37:27 <glguy> how does head and make -j3 get along?
01:38:03 <nominolo> works
01:38:52 <nominolo> yes, ghc comes with those weird binaries.  not sure why
01:39:06 <nominolo> probably accident
01:39:13 <glguy> dons: is the consequence of doing the type-checking at the core level that you can't give pretty error messages?
01:39:18 <dons> right.
01:39:22 <dons> exactly that.
01:39:37 <dons> so if you think the current errors are hard, disable the type checker and use -dcore-lint :)
01:39:45 <nominolo> glguy: well, it's a lot trickier
01:39:48 <glguy> I'd be happy with just line numbers
01:39:56 <dons> glguy is hardcore haskell man.
01:40:20 <glguy> I guess I'd have to relearn the shapes of the error messages
01:40:30 <dons> yeah. i'm sure it would be doable.
01:40:40 <glguy> I use EDD, a friend of TDD
01:40:49 <dons> mm.
01:40:56 <glguy> error driven development
01:41:13 <nominolo> TODO-list = compiler errors?
01:41:19 <glguy> yeah
01:41:32 <nominolo> works rather well in haskell
01:41:39 <glguy> make the change in the most central component
01:41:41 <dons> ?quote drunk
01:41:41 <lambdabot> Raguel says: does it unsettle anyone that there isn't a formal semantics for haskell? its like someone got drunk, invented a gadget, then when he woke up, couldn't quite draw a blueprint
01:41:45 <glguy> and then follow the path of destruction!
01:41:47 <dons> hmm. not that one.
01:41:54 <dons> glguy: :)
01:42:02 <dons> ?quote drunk
01:42:02 <lambdabot> Raguel says: does it unsettle anyone that there isn't a formal semantics for haskell? its like someone got drunk, invented a gadget, then when he woke up, couldn't quite draw a blueprint
01:42:06 <dons> nope. hmm
01:42:13 <glguy> ?quote drunk
01:42:14 <lambdabot> Raguel says: does it unsettle anyone that there isn't a formal semantics for haskell? its like someone got drunk, invented a gadget, then when he woke up, couldn't quite draw a blueprint
01:42:14 <glguy> !
01:42:23 <glguy> dons: are you trying to say you are drunk?
01:42:28 <dons> there used to be a good quote about types being the only way you can code drunk.
01:42:44 <nominolo> how many languages have a formal semantics?
01:42:48 <dons> open editor. delete something. follow path of destruction.
01:42:56 <nominolo> scheme has operational semantics
01:43:08 <dons> there's an implementation of core in twelf.
01:43:12 <glguy> doesn't at least one of the MLs?
01:43:13 <nominolo> SML has some subset verified
01:43:26 <dons> but there's no official static and dynamic semantics in the report, we all work from.
01:43:34 <dons> instead, its scattered around dozens of papers.
01:43:34 <nominolo> don't know about semantics, and if so, which style
01:44:10 <nominolo> but it's been designed with some equalities in mind.  but then came seq...
01:44:43 <dons> without seq, life would be boring.
01:44:54 <nominolo> glguy: i'd say file it as bug and let SPJ fix it or explain it :)
01:45:01 <dons> can't make reasoning too easy now, can we. :)
01:45:14 <dons> ?bug
01:45:15 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
01:45:16 <glguy> nominolo: I'll do that after I check against head
01:45:25 <nominolo> no, otherwise Filinski wouldn't have anything to do
01:45:35 <nominolo> glguy: i just checked with head
01:45:40 <dons> and janis voightlander would have no career at all!
01:45:43 <nominolo> from a week ago
01:45:54 <dons> what would he do without seq to complicate life.
01:46:01 <glguy> You wouldn't have happened to search the bug list to see if this is already listed, would you?
01:46:02 <glguy> :)
01:46:09 <nominolo> glguy: no
01:46:24 <dons> glguy: pretty hard to know. maybe hunt around bugs relating to "impredicativity"
01:46:27 <dons> and rank.
01:46:37 <nominolo> dons: janis is... well... janis
01:46:46 <glguy> http://hackage.haskell.org/trac/ghc/ticket/1123
01:46:48 <lambdabot> Title: #1123 (Impredicativity bug: forall not hoisted properly) - GHC - Trac
01:47:08 <dons> hehe
01:47:42 <dons> there's been a few wibbles like this.
01:47:44 <nominolo> glguy: add your example as a comment
01:47:53 <dons> runST $ do foo works now, but other things got weirder.
01:48:15 <nominolo> "opened 2 years ago"
01:49:14 <nominolo> maybe we're switching to MLF one day
01:50:17 <dons> i wonder if we could get a paper published about a new type system called MILF
01:50:59 <nominolo> no, it'd end like this: http://xkcd.com/410/
01:50:59 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:51:30 <dons> heh
01:51:31 <glguy> I can't figure out my bug track password :(
01:51:44 <dons> guest guest ?
01:52:07 <glguy> cool
01:52:11 <dons> sign it with your name at the end, if you do.
01:52:27 <dons> or put your mail in the cc.
01:54:54 <dons> glguy: is that an email from iavor i see on the mailing list?
01:55:09 <dons> Date: Sat, 2 Aug 2008 10:03:33 +0200
01:55:22 <dons> +2 !
01:56:20 <glguy> 52 mintues ago
01:56:51 <dons> so that timezone is for right continent.
01:57:16 <dons> he's found the internet
01:57:52 <glguy> imagine, not in the US and still has electricity and internet access
01:58:17 <glguy> maybe a military base or embassy?
01:58:20 <dons> right, and not namibia (GMT+1), but south africa or botswana
01:58:29 <dons> internet cafe, my guess.
02:00:27 * nominolo is in GMT+02
02:01:24 <RayNbow> ah, nominolo is in a neighbouring country :)  (or at least from my POV)
02:02:32 <glguy> I'm still not comfortable putting the $ after runST
02:02:42 <glguy> seems like black magic
02:02:44 <glguy> evil!
02:03:05 <Deewiant> just imagine it's an identifier
02:03:06 <Deewiant> runST$
02:03:06 <dolio> I'm pretty sure they removed the magic that makes $ work with runST.
02:03:20 <dolio> If not in 6.8.x, then in 6.9.
02:04:58 <dons> glguy: yeah, i don't either.
02:06:25 <glguy> dons: I went digging in uvector to see how you were getting the quantified s out of your array types
02:06:45 <glguy> but decided that I wasn't ready to add unsafeCoerce# to the code
02:07:14 <glguy> Package contains no library to register: ghc-bin-6.9...
02:07:19 <glguy> my head build stops here
02:07:24 <glguy> does that look familiar to anyone?
02:07:47 <dolio> I don't think head has been building for a while.
02:08:30 <glguy> GHC is dying!
02:08:38 <glguy> a compiler that doesn't compile?
02:08:50 <glguy> types that don't check
02:08:56 <dolio> I was getting unresolved symbols a couple weeks ago, which may have been resolved, but I've talked to people who've tried more recently, and it didn't build for them, either.
02:08:57 * glguy curls in a corner
02:15:40 <glguy> MonadLib.Derive = great success
02:18:57 <Axman6> > great success
02:19:00 <lambdabot>   Not in scope: `success'
02:19:14 <Axman6> ah, we'll get there one day
02:19:25 <Axman6> >let success = True
02:19:28 <Deewiant> > great fail
02:19:29 <lambdabot>   Not in scope: `great'
02:23:15 <monn> anyone qualify for the next round of GCJ 2008?
02:23:32 <Axman6> google code jam?
02:23:55 <Axman6> i won a google t-shirt when they gave a talk at uni
02:24:45 <monn> Yup, google code jam
02:24:53 <adu> are there any functions from ProcessHandle to ProcessID?
02:27:27 <adu> so frustrating
02:32:11 <DRMacIver> Hm. Where do I find the haskell cairo bindings? I thought they were part of gtk2hs, but I'm trying ot get hschart up and running and cabal install doesn't seem to think I have cario installed despite having gtk2hs so I guess not.
02:32:18 <DRMacIver> err. just chart
02:32:58 <dons> DRMacIver: maybe you didn't build the cairo component, its a sub package
02:33:10 <DRMacIver> Ah, that's possible. I just did a standard make install on it
02:33:33 <adu> http://www.cairographics.org/hscairo/
02:33:34 <lambdabot> Title: Haskell bindings
02:34:23 <adu> @hoogle ProcessHandle -> ProcessID
02:34:23 <lambdabot> No matches, try a more general search
02:34:28 <DRMacIver> adu: The darcs links on there are deceased
02:34:35 <adu> o
02:34:37 <adu> oops
02:34:49 <DRMacIver> Hm. Actually cabal install doesn't seem to be able to see gtk2hs at all
02:34:53 <adu> @hoogle ProcessHandle -> IO ProcessID
02:34:54 <lambdabot> No matches, try a more general search
02:35:19 <adu> @hoogle IO ProcessID
02:35:19 <lambdabot> No matches, try a more general search
02:35:30 <Deewiant> @hoogle ProcessHandle
02:35:31 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
02:35:32 <Deewiant> @hoogle ProcessID
02:35:32 <lambdabot> System.Posix.Types.ProcessID :: type ProcessID
02:36:36 <DRMacIver> Hm. Looks like gtk2hs just isn't properly installed. WEird, as the make install claimed to work fine
02:36:56 <adu> @hoogle ProcessHandle -> a
02:36:57 <lambdabot> No matches, try a more general search
02:47:28 <nominolo> glguy: that's no error
02:47:37 <nominolo> glguy: it's just a note from cabal
02:48:16 <nominolo> the binary is at ghc/stage2-inplace/ghc
02:49:18 <nominolo> dolio: are you on mac?  if you update the libraries/Cabal it should work now
02:50:29 <dolio> I'm on Linux.
02:50:35 <DRMacIver> Sigh. Why is gtk2hs so difficult to install?
02:51:05 <nominolo> because it's not cabalised yet
02:51:09 <DRMacIver> Every time I think "Oh, package X looks interesting. Hm, it depends on gtk2hs. I guess I'll have another go at installing that" for a variety of graphics related things dismal failure ensues.
02:51:27 <DRMacIver> nominolo: No, it's not just that. There are plenty of things which are make based installs and works fine.
02:51:44 <DRMacIver> Yet as far as I can remember I have never successfully managed to get gtk2hs to build.
02:52:10 <nominolo> mostly worked for me
02:52:46 <DRMacIver> Never worked for me. The install inevitably fails with a variety of obscure error messages.
02:52:57 <DRMacIver> It's currently complaining about undefined references in the prettyprint library.
02:59:27 * DRMacIver sighs and prepares to try it on a fresh install of GHC. I needed to upgrade anyway.
03:00:16 <DRMacIver> You know, this is a large part of why I write Haskell as infrequently as I do. I was hoping cabal install would fix the dependency hell I inevitably end up in, but it just seems to have shifted it around in the best of cases (and in things which aren't cabalised of course helps not at all).
03:00:18 <dolio> A few days ago, I decided to install the binary packages for 6.8.3 (I'm on Ubuntu, so they won't get it for months)...
03:00:31 <dolio> And I decided to uninstall 6.8.2.
03:01:21 <dolio> But apparently, the dependencies on the gtkhs packages had become screwed up, which both prevented them from uninstalling, and somehow prevented them from being fixed, despite lots of trying on my part.
03:01:53 <dolio> Totally blocking any other packages from being installed, too.
03:01:57 <dolio> Quite a bad situation.
03:37:18 <pozic> Is there some higher level API built on GTK2HS?
03:37:20 <audreyt> dcoutts_: any news on the local mirror repos support?
03:37:56 <dolio> Conal's stuff might have a GTK backend. I can't remember.
03:38:13 <pozic> I need to specify where to place a widget in a table, but tableAttachDefaults is not that nice.
03:39:15 <dolio> Oh, nope, it's wxWidgets.
04:06:09 <DRMacIver> Hurray. gtk2hs successfully installed.
04:06:24 <DRMacIver> All it required was me to reinstall ghc from scratch and install on the fresh copy. Sigh. :)
04:09:53 <pozic> DRMacIver: why was that needed?
04:09:59 <DRMacIver> pozic: buggered if I know.
04:10:42 <DRMacIver> gtk2hs was failing with weird errors about symbols in the pretty print library. I vaguely recalled having had trouble with similar errors before (though thought I'd done a clean reinstall since) so thought I'd try upgrading to see if that fixed the problem. It did.
04:21:33 <paolino> Is there a list monad idiom to produce \f xs -> [f x y | (x:ys) <- tails xs , y <- ys]?
04:22:51 <paolino> are those named 2-combinations ?
04:30:42 <xerox> > [(x,y) | (x:ys) <- tails [1..3], y <- ys]
04:30:43 <lambdabot>  [(1,2),(1,3),(2,3)]
04:35:21 <chrisdone> > [(x,y) | (x:ys) <- tails [1..4], y <- ys]
04:35:22 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
04:44:34 <Peaker> @src tails
04:44:35 <lambdabot> tails []         = [[]]
04:44:35 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
04:45:11 <Peaker> @type (iterate tail)
04:45:13 <lambdabot> forall a. [a] -> [[a]]
04:45:15 <Peaker> @type tails
04:45:16 <lambdabot> forall a. [a] -> [[a]]
04:45:43 <Peaker> > (iterate tail) [1,2,3]
04:45:44 <lambdabot>  [[1,2,3],[2,3],[3],[],Exception: Prelude.tail: empty list
04:45:50 <Peaker> oh :)
04:46:00 <Peaker> > tails [1,2,3]
04:46:00 <lambdabot>  [[1,2,3],[2,3],[3],[]]
04:46:28 <Peaker> > (takeUntil null . iterate tail) [1,2,3]
04:46:28 <lambdabot>   Not in scope: `takeUntil'
04:46:37 <Peaker> > (takeWhile (not . null) . iterate tail) [1,2,3]
04:46:38 <lambdabot>  [[1,2,3],[2,3],[3]]
04:46:57 <Peaker> tails = takeWhile (not . null) . iterate tail
04:46:59 <Cale> takeUntil used to be in the list library
04:47:12 <Cale> > tails [1,2,3]
04:47:13 <lambdabot>  [[1,2,3],[2,3],[3],[]]
04:47:30 <Peaker> I don't think there needs to be both takeWhile and takeUntil - its nicer to encourage a uniform style, imo
04:47:40 <Cale> takeUntil was different
04:47:46 <ivanm> Cale: what's takeUntil?
04:47:57 <Peaker> Cale: Yeah, was trying to find a @pl for tails, instead of a recursive definition
04:47:58 <Cale> It included the element which caused the condition to fail.
04:48:07 <ivanm> ahhh
04:48:09 <ivanm> yes, that's handy
04:48:27 <ivanm> a couple of months ago someone here and I were trying to define something like that
04:49:20 <ivanm> takeWhile = init . takeUntil ?
04:49:51 <Cale> yeah, seems right
04:50:27 <Peaker> do people generally use rewrite-rules in their code for optimizations, or do only prominent ghc hackers do that? :-)
04:50:39 <ivanm> so if you wanted to have a uniform style, you should really define not takeUntil and not takeWhile!
04:51:00 <ivanm> actually, that isn't quite right... that fails for when all of the list fulfill the criteria
04:51:27 <gwern> @seen chrisdone
04:51:27 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
04:51:36 <ivanm> preflex: seen chrisdone
04:51:36 <preflex>  chrisdone was last seen on #haskell 16 minutes and 14 seconds ago, saying: > [(x,y) | (x:ys) <- tails [1..4], y <- ys]
04:51:39 <gwern> preflex: seen chrisdone
04:51:39 <preflex>  chrisdone was last seen on #haskell 16 minutes and 17 seconds ago, saying: > [(x,y) | (x:ys) <- tails [1..4], y <- ys]
04:51:42 <pozic> Peaker: I don't think there is any library on Hackage that uses rewrite rules, not written for a research paper.
04:52:05 <Cale> :t until
04:52:06 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
04:52:24 <gwern> chrisdone: darcs is on hackage :)
04:53:22 <gwern> pozic: well, that's not terribly surprising. rewrite rules are not useful in apps, and imo most of the data structures eitehr aren't obvious how you would use'em, or were written before knowledhe of them became common, or the authors just don't know/don't care
04:53:39 <ivanm> gwern: darcs now uses cabal?
04:53:54 <gwern> there's currently no way to say to yourself 'oh my datastructure library could really use such and such a rewrite rule'
04:53:55 <Cale> hmm, maybe takeUntil was never in the standard...
04:54:06 <gwern> ivanm: no. I maintain a fork which does
04:54:10 <ivanm> ahhh
04:54:13 <Cale> I seem to remember some version of the Prelude/List library including it
04:54:18 <gwern> ivanm: I'm not sure how well it works. It works for me, and a few other people
04:54:33 <ivanm> how much work did you have to do to get it working?
04:54:46 <gwern> now, if we had some sort of profiler which could recommend rules... but that sounds impossibly difficult
04:54:50 <gwern> ivanm: a lot
04:55:04 <gwern> ivanm: if you're interested, I could send you my patches
04:55:18 <ivanm> nah, not _that_ interested
04:55:30 <Cale> pozic: Data.ByteString was written for a research paper, but it's also quite practical.
04:55:43 <ivanm> when I saw you saying it's on hackage, I then thought we could switch the gentoo ebuilds for darcs to start using cabal
04:55:53 <gwern> @tell chrisdone darcs is on hackage, under darcs-cabalized. I maintained a cabalized fork of darcs. if you want I could send you the patches - cabalizing darcs is fairly hard
04:55:53 <ivanm> but if its a fork, then we might stick with the "official" build system
04:55:53 <lambdabot> Consider it noted.
04:56:01 <pozic> Cale: I know.
04:56:36 <gwern> ivanm: mm. I dunno. I 'hardwire' some of the configure stuff, so if gentoo seriously exploits the 'you can use Wget! - or curl! - or libwww!' kind of stuff, you'd want to avoid it
04:56:55 <ivanm> yeah
04:57:42 <ivanm> gwern: why do you have version 2.0.2.2 when upstream only has 2.0.2 ?
04:57:58 <gwern> ivanm: local versioning
04:58:03 <ivanm> ahhh
04:58:10 <gwern> .0 and .1 were screwy in ways
04:58:18 <ivanm> when I saw that, I thought there must have been an upstream release ;-)
04:58:25 <gwern> so I continued cabalizing and hacking until it worked, at which point it became .2
04:58:49 <ivanm> why did you release it if it didn't work? :s
04:59:12 <gwern> I forget. perhaps I didn't realize it for a while
04:59:19 <ivanm> actually... we don't give users the option of wget vs curl vs libwww :s
04:59:22 <ivanm> we just use curl...
05:00:02 <gwern> @ask chrisdone I presume you sent your GOA patches to dons?
05:00:02 <lambdabot> Consider it noted.
05:00:28 <ivanm> surely dons read chrisdone's blog post!
05:00:43 <ivanm> after all, he somehow manages to find and read _everything_ haskell related!
05:00:50 <ivanm> and reddit it whilst he's at it...
05:05:38 <paolino> > (id *** head) $ break (==4) [1..10]
05:05:39 <lambdabot>  ([1,2,3],4)
05:06:01 <paolino> takeUntil is  nicer
05:06:18 <ivanm> > (second head) $ break (==4) [1..10]
05:06:19 <lambdabot>  ([1,2,3],4)
05:09:50 <gwern> @ask dcoutts is it a known problem that haddock seems to fail for cabal-install darcs? 'Distribution/Client/Reporting.hs:104:4: parse error on input `-- | Which build tools we were using (with versions) --    tools      :: [PackageIdentifier],' haddock: Failed to load all needed modules'
05:09:51 <lambdabot> Consider it noted.
05:10:28 <pozic> gwern: I guess RULES exists because a real partial evaluation system is too slow or to difficult to make.
05:10:58 <pozic> gwern: lots of the rules in the bytestring library can be automated I think.
05:11:59 <newsham> *yawn*
05:12:35 <DRMacIver> The charts library is pretty nice.
05:12:42 <DRMacIver> At least, the basics of it.
05:12:43 <dcoutts> gwern: I've not been regularly running haddock on cabal-install dev version and I don't use haddock 2
05:12:43 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
05:12:55 <pozic> DRMacIver: it sortof works, yes.
05:13:05 <pozic> DRMacIver: but far from ideal.
05:13:22 <DRMacIver> pozic: I'm not sure I've encountered a charts library I'd consider ideal. :)
05:13:41 <pozic> DRMacIver: roconnor and I discussed that yesterday already :)
05:14:20 <DRMacIver> My metric was: I needed a dumb chart generation utility. After about half an hour playing with the chart library I had the utility I needed.
05:14:23 <gwern> dcoutts: hm. I'm using 2.1.0
05:15:14 <DRMacIver> As an idle note, is anyone aware of something that just takes a CSV file and outputs it as a chart, using the first column as X values and the remaining column as data fields. I was vaguely appalled that I couldn't find an easy way to do that without writing code.
05:15:18 * ivanm just wished charts had the ability to do 3D graphs :s
05:15:42 <ivanm> gwern: well, I'm testing out haddock-2 for gentoo, and there's quite a few packages that don't work...
05:15:42 <david48> gwern: haddock 2.2.0 builds just fine
05:15:49 <DRMacIver> The only thing I could find was a perl script which upon trying to use required me to install the entire world via CPAN, which then failed midway through installing.
05:16:05 <ivanm> then again, it seems to be from a bug in haddock-2... :s
05:16:45 <pozic> DRMacIver: open gnumeric, copy stuff, open editor, paste stuff, save to foobar, gnuplot plot('foobar')
05:16:54 <newsham> drmac: gnuplot probably can do it
05:16:59 <DRMacIver> newsham: Curiously, not.
05:17:14 <DRMacIver> It doesn't appear to understand CSV without a reasonable amount of work to get it to do it
05:17:32 <newsham> there's a way to tell it how to parse input with a format string I believe
05:17:44 <ivanm> _is_ there haskell bindings for gnuplot?
05:17:44 <DRMacIver> pozic: You lost me at "copy stuff". If I can't do it from the command line I'm not that interested. :)
05:17:52 <ivanm> at least some way of automating the drawing of plots?
05:17:56 <gwern> *are
05:18:19 <pozic> DRMacIver: It's trivial to write such a program, though.
05:18:29 <ivanm> gwern: whatever :p
05:18:31 <pozic> DRMacIver: there is a library on hackage to read CVS files already.
05:18:33 <DRMacIver> pozic: Yes. And I did write such a program.
05:18:47 <pozic> DRMacIver: ok, so did I :P.
05:18:54 <DRMacIver> I was just surprised that such a thing didn't exist in some easily distributed form and was wondering if I was missing something.
05:18:55 <pozic> DRMacIver: inventing the wheel a million times.
05:19:09 <DRMacIver> pozic: I'd have been quite happy to use someone else's wheel if they'd made it available!
05:19:20 * DRMacIver actively resisted the idea of writing code to do this for that very reason
05:20:28 <pozic> DRMacIver: the problem is: why would someone release a library?
05:20:31 <DRMacIver> newsham: RE gnuplot, I tried to figure out its input handling capability, but I couldn't find anything that suggested I could get it to dynamically depend on the number of columns, parse headers sensibly, etc.
05:20:41 <DRMacIver> pozic: I'm not asking for a library. I'm asking for a tool. :)
05:21:01 <DRMacIver> And it sounds like a really handy tool to have available at one's fingertips.
05:21:04 <pozic> DRMacIver: ok, why would someone write such a tool?
05:21:28 <newsham> http://www.cs.waikato.ac.nz/~fracpete/programming/csv2gnuplot/
05:21:29 <lambdabot> Title: csv2gnuplot.sh - HOWTO
05:21:31 <DRMacIver> Um. Because they have a bunch of csv files (a really obvious solution for storing numeric tabular data) and want a bunch of line charts?
05:21:35 <DRMacIver> newsham: Thanks
05:21:36 <newsham> apparently this tool is commonly written :)
05:21:59 <pozic> DRMacIver: yes, that's why they would write and use it, but not why they would distribute it.
05:22:38 <DRMacIver> pozic: I don't understand your point. Why does anyone distribute anything open source?
05:22:48 <DRMacIver> newsham: Thanks. That should be a much better solution.
05:22:50 <newsham>  If a format is specified, each datafile record is read using the C library's
05:22:50 <newsham>  'scanf' function, with the specified format string.  Otherwise the record is
05:22:51 <newsham>  read and broken into columns at spaces or tabs.
05:22:58 <newsham> (see "help plot using")
05:23:54 <DRMacIver> newsham: *shrug* it seemed to get confused regardless of what I tried. I'm fully prepared to acknowledge that I was probably doing something wrong, but at the same time the application and documentation didn't exactly make it easy to figure out how to do it right. :)
05:24:24 <DRMacIver> newsham: Anyway, thanks for the csv2gnuplot link. That looks really useful.
05:24:25 <newsham> sounds like it should be easy enough if you're familiar with using scanf for parsing input
05:24:28 <pozic> DRMacIver: some do it for ideal reasons, some for promotion, but you can't live of that. "Support" is only needed for applications/libraries that are not documented.
05:24:56 <pozic> DRMacIver: only non-core tools get released, which is mostly the most mundane easy stuff there is.
05:25:20 <DRMacIver> newsham: But I don't want to use scanf for parsing input because the number of columns is not defined ahead of time.
05:25:25 <pozic> DRMacIver: there are also some dynamics w.r.t. what other "communities" are releasing.
05:26:11 <newsham> so you define one scanf string for each particular file you want to plot
05:26:14 <DRMacIver> pozic: I'm still totally failing to see your point. It's a general purpose tool which would be widely useful and is easy to right. Stuff like that gets released *all the time*. Just look at the number of random little things in your average linux distribution's package manager.
05:27:10 <pozic> DRMacIver: there aren't that many applications that solve some problem completely.
05:27:35 <pozic> DRMacIver: take gnuplot for example.
05:27:36 <DRMacIver> newsham: No, that's a stupid solution and has nothing to recommend it over actually writing a tool to do what I want. The files all have the same obvious format. A good solution should not require special casing each one.
05:28:03 <newsham> so write a tool to spit out a one-liner plot command with format string for each file
05:28:15 <newsham> which will also be a one liner :)
05:29:04 <DRMacIver> pozic: I'm not asking for a general purpose tool. I'm asking for an extremely special purpose tool for a special purpose which happens to be extremely common.
05:29:24 <DRMacIver> "Do only one thing and do it well". It's very unixy. :)
05:29:38 <newsham> gnuplot is not very unixy.  its very gnu.
05:29:58 <paolino> anyone like to help me with http://haskell.org/haskellwiki/Google_Code_Jam/Number_sets?
05:29:59 <lambdabot> Title: Google Code Jam/Number sets - HaskellWiki
05:30:01 <DRMacIver> Yes, I noticed.
05:30:09 <pozic> DRMacIver: I was thinking of a plot application that takes as input data and tries very hard to make something good out of it.
05:30:09 <DRMacIver> Fortunately, involving gnuplot in any way is not on my requirements list.
05:30:41 <DRMacIver> pozic: I wasn't. I was thinking of a plot application that takes one very specific style of CSV format (which happens to be a really common one) and spits out a line chart for it.
05:31:37 <DRMacIver> Anyway, I've hacked together the basics of just such a thing. I might put it on hackage at some point once it's a little less special purpose (e.g. once it can handle command line arguments sensibly. :) )
05:31:38 <pozic> newsham: it doesn't even have a GNU license.
05:32:09 <ivanm> it has a "you can hack the code, but can't actually release the end result, just patches of it" license :s
05:32:12 <newsham> but it has all of the gnu featuritus.
05:32:25 <newsham> more cmd line options than gnu cat
05:32:34 <ivanm> problem is, it's been around so long and is used so much that people live with it rather than replacing it :s
05:33:44 <pozic> newsham: it has so many options, because people need access to the knobs, because every user wants something else.
05:34:41 <pozic> TeX doesn't have lots of options for the simple reason that one guy determined "this is how a document should look like".
05:34:52 <pozic> For plots there is no such thing.
05:35:02 <paolino> I was looking from a function from a list of tuples representing 2 elements subsets to the number of non intersecting subsets of those elements
05:35:02 <paolino> like ﻿ [(11,13),(11,17),(11,19),(11,23),(13,17),(13,19)] -> 1
05:35:02 <paolino> ﻿ [(11,23),(13,19)] -> 2
05:35:03 <newsham> and yet all gnuplot charts still look alike :)
05:35:33 <pozic> newsham: :)
05:35:38 <jpcooper> hello
05:35:49 <jpcooper> is there a function to get the third element of a triple?
05:35:57 <jpcooper> or should I just do pattern matching?
05:36:07 <r3m0t> pattern matching I believe
05:36:39 <Axman6> (\(_,_,x) -> x) would do it
05:37:01 <Axman6> you know, there was a lot more typing there than i anticipated
05:37:25 <Peaker> if tuples were always 2-tuples... :-)
05:37:38 <Peaker> snd . snd
05:37:42 <r3m0t> > (snd.snd) (1,2,3)
05:37:43 <lambdabot>  Couldn't match expected type `(a1, (a, b))'
05:37:54 <r3m0t> > (snd.snd) ((1,2),3) -- whoops silly me
05:37:55 <Peaker> that's why I said "if" :-)
05:37:55 <lambdabot>   add an instance declaration for (Num (a, b))
05:37:56 <newsham> > (snd.snd) (1,(2,3))
05:37:57 <lambdabot>  3
05:38:04 <r3m0t> righty
05:38:34 <newsham> righty tighty
05:39:03 <Peaker> I think ML, OCaml do this? Why did Haskell choose to use the weird n-tuples?
05:39:13 <Peaker> what advantages does it have?
05:39:43 <paolino> they map to records ?
05:40:42 <Peaker> Maybe instead of records being like tuples, Haskell should have had Data Constructors with optional/mandatory parameter names?
05:40:57 <Axman6> @src (.)
05:40:58 <lambdabot> (f . g) x = f (g x)
05:40:58 <lambdabot> -- In lambdabot, it's been generalised to:
05:40:58 <lambdabot> (.) = fmap
05:40:59 <Axman6> @src ($)
05:40:59 <lambdabot> f $ x = f x
05:41:18 <Axman6> ah, i see the subtle difference there...
05:41:36 <Peaker> Axman6: What's the similarity? :)
05:41:41 <Axman6> think i've been using $ where i should've been using . a lot...
05:42:38 <newsham> f $ g x == f (g x),  (f. g) x == f (g x)
05:42:47 <newsham> seems pretty similar to me
05:43:16 <r3m0t> if you've been writing f x = g $ h $ j $ x, you can write f = g . h . j
05:43:20 <r3m0t> which is nicer
05:43:44 <Peaker> newsham: yeah, its not easy to spot from the @src, imo :)
05:43:45 <hml> i
05:44:00 <hml> what scripts should i use when editin ]haskell in emacs?
05:44:18 <Peaker> yeah, . is like the points-free $
05:44:35 <Peaker> hml: I think haskell-mode is the "official" emacs one?
05:46:23 <hml> thanks
05:46:23 <Axman6> > take 4 . repeat 'a'
05:46:24 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
05:46:30 <Axman6> > take 4 . repeat 1
05:46:31 <lambdabot>   add an instance declaration for (Num [a])
05:46:38 <Axman6> > take 4 $ repeat 1
05:46:39 <lambdabot>  [1,1,1,1]
05:46:45 <newsham> > (take 4 . repeat) 1
05:46:46 <lambdabot>  [1,1,1,1]
05:46:52 <Axman6> ok, now that's why i use $
05:46:52 <ivanm> > replicate 4 1
05:46:53 <lambdabot>  [1,1,1,1]
05:47:05 <newsham> > let f = take 4 . repeat in f 1
05:47:06 <lambdabot>  [1,1,1,1]
05:47:41 <Axman6> the whole not using f x = ... x annoys me for some reason
05:47:51 <Axman6> how do you know what it takes! :o
05:48:06 <Axman6> and yes, i am being silly, but still, it annoys me
05:48:06 <newsham> because you were a good programmer and you wrote the type signature out
05:48:09 <ivanm> Axman6: well, this way it independent of variable name!
05:48:25 <nax> hello
05:48:25 <r3m0t> Axman6: I like it, but usually only for one parameter
05:48:28 <r3m0t> hi nax
05:49:55 <Peaker> Axman6 has a point. Types are sometimes less descriptive than a point-name of an argument
05:50:29 <Axman6> we were encouraged to use meaningful names for variables in our comp course
05:50:47 <Axman6> like put (x,y) = ...x y
05:50:52 <Axman6> ot
05:50:54 <Axman6> or..
05:50:56 <Axman6> um
05:51:13 <Axman6> something that is actually meaningful (that was a particularly bad example)
05:51:20 <nax> how does thread safety work with foreign functions? there doesn't seem to be a way to specify if foreign functions are thread safe or not.
05:52:07 <newsham> fst (firstTupleElement, secondTupleElement) = firstTupleElement
05:52:43 <Philippa_> Axman6: presumably that was putPixel or equivalent?
05:52:46 <shapr> @yow
05:52:47 <lambdabot> Couldn't find fortune file
05:52:47 <Axman6> or, fst (first, second) = first
05:53:01 <Axman6> Philippa_: well, putting on an othello board
05:53:05 <Philippa_> same difference
05:53:13 <Axman6> but yeah
05:53:43 <Axman6> i made a quite nice othello game really. i don't think i coded it very well, but it plays against the player, and shows two boards at once (your move, and the computers)
05:54:05 <r3m0t> newsham: even better, fst (first, _) = first
05:54:29 <newsham> dont you think  unusedSecondTupleElement is more descriptive?
05:54:51 <r3m0t> no
05:55:03 <r3m0t> but at least you are thinking in new ways
05:55:36 <Peaker> newsham: its clear from the surrounding tuple that its a "tupleElement" so that's redundant
05:55:48 <Peaker> newsham: so (first, _second)  where _ convention means unused would be nice
05:56:17 <newsham> perhaps some sort of UNUSEDARG(secondTupleElement) macro is in order.
05:56:31 <Peaker> trying to take descriptiveness to the "extreme" to show it doesn't work - usually just replaces descriptiveness with redundancy, which are not the same thing :)  The information should appear once, not zero times, and not twice
05:56:34 <newsham> clearly more letters are more descriptive
05:56:36 <r3m0t> #define UNUSEDARG((.*)) _
05:56:44 <Peaker> newsham: that's a strawman
05:56:55 <newsham> works for scaring away the crows
05:57:04 <Peaker> heh
05:57:20 <Peaker> newsham: everyone agrees more letters/verbosity is a disadvantage. Some just think that minimizing letter-counts is not the ONLY goal..
05:57:39 <Peaker> newsham: if it kills the self-descriptive nature of the code, for example
05:58:44 <Peaker> The thing is -- @pl is nicer for various reasons, but since its possible to represent the same @pl'd code with descriptive point-names, without losing these advantages (automatic conversion to @pl can occur), then why not?
05:58:57 <znutar> I thnk points free is great because it gives the kind of people who like that sort of thing something to play with, and hopefully keeps them away from doing real work
05:59:06 <Peaker> znutar: :-)
05:59:13 <newsham> sometimes points-free is just as descriptive
05:59:33 <newsham> [02:46] < Axman6> the whole not using f x = ... x annoys me for some reason
05:59:40 <newsham> it just takes some getting used to
05:59:47 <Axman6> yeah
05:59:51 <ivanm> it makes joining functions together _much_ easier
06:00:58 <Peaker> Beelsebob: hey - did you friend make some progress with that FRP tutorial?
06:01:34 <gwern> @pl f x y = foo x $ bar . id y
06:01:35 <lambdabot> f = (. (bar .)) . foo
06:01:47 <ivanm> if it wasn't for the fact that you couldn't guarantee that the types would be the same, it'd be kinda cool if you could have some kind of function like: compose fns = foldr (.) id fns
06:01:49 <gwern> @unpl f = (. (bar .)) . foo
06:01:49 <lambdabot> f e h = foo e (\ k -> bar (h k))
06:01:54 <Beelsebob> Peaker: at the moment, he's working on producing a good collection of examples -- which are flagging a few things that Conal needs to fix
06:02:07 <newsham> also there are lots of programmers out there making their living writing code with variables that are way more descriptive than they need to be
06:02:11 <Peaker> Beelsebob: cool
06:02:11 <gwern> hum. interesting unpl
06:02:12 <Beelsebob> they've been having long discussions about exactly what the nicest/best way to do things is
06:02:34 <newsham> and unfortunately i have to read a lot of it
06:02:46 <nax> Beelsebob: which FRP library is it?
06:02:55 <Beelsebob> nax: reactive
06:02:57 <Peaker> newsham: something cannot be too "descriptive", it can be more than descriptive, in which case it is redundant, not "too descriptive"
06:03:46 <newsham> http://www.davidflanagan.com/blog/000017.html
06:03:46 <lambdabot> Title: davidflanagan.com: Longest Java Class Name
06:04:14 <Peaker> newsham: my main problem with Haskell code is the single-letter type-variable and variable names.. Also single-letter abbreviations in many function names. I dislike having to use external documentation, after having become used to being able to use my Python libraries without resorting to any documentation, simply because of useful names
06:04:29 <Philippa_> Peaker: you can most certainly overdescribe things to a given reader
06:04:43 <newsham> single letter variables names are often more than enough
06:04:49 <newsham> and sometimes even too much.. points free please :)
06:04:54 <Philippa_> sure, it's characterised by redundant info, but it's redundant in the context of the conversation, not necessarily in the description itself
06:04:55 <Peaker> Philippa_: What I'm claiming is that what some people call "over-describing" is in fact "redundancy" -- and is beyond description
06:05:13 <Peaker> Philippa_: examples?
06:05:30 <Peaker> Philippa_: context IS part of the information available - so it is absolutely redundant if it is redundant to context
06:05:54 <Peaker> newsham: Reactive's use of names like: forkR and forkE mean that I have to read more documentation in order to use it
06:05:57 <gwern> I think short names in haskell are a borrowing from math - when your operators and standard functions are so short, it feels foolish and ugly to have names longer than, say, 6 letters
06:06:26 <Philippa_> Peaker: making things absolute just by applying the context is formally accurate but loses informal information...
06:06:27 <Peaker> newsham: A fully descriptive name of what kind of thing the function does would mean people can simply use it -- or rename it in their own code to "shorten it" for their own specific purpose
06:06:38 <Philippa_> and in many cases there is no single context that applies
06:07:00 <Philippa_> anything that will be read by more than one person, or even by the same person in different contexts...
06:07:17 <Peaker> Philippa_: then indeed it makes sense to repeat that information in the description - or try to redesign the code so that it is more general and thus shorten the necessary description
06:08:03 <Peaker> newsham: Yampa's "dpSwitch" instead of "delayedParallelSwitch" annoys me, for example :)
06:08:05 <Philippa_> who said anything about "repeat"?
06:08:51 <Peaker> gwern: foolish in what way?  Single words in English have far more letters for basic concepts, is that foolish too?
06:08:56 <newsham> > repeat "pete and repeat went into the store, pete came out, who was left?"
06:08:57 <lambdabot>  ["pete and repeat went into the store, pete came out, who was left?","pete a...
06:09:01 <nax> Peaker: is your problem with reading code or writing code?
06:09:10 <Peaker> nax: Reading code
06:09:27 <Philippa_> Peaker: could you try to lower the level of (perceived) intellectual aggression there a little?
06:09:29 <Peaker> I think readability is far more important than writability. I think that's one of the main insights that made Python successful
06:09:53 <Peaker> Philippa_: ok
06:09:56 <gwern> Peaker: I would argue so, yes. there's much redundancy there
06:10:33 <Philippa_> having a completely fresh glyph each time is a PITA
06:10:48 <Philippa_> computers might work that way, but we work on small data sets at a time and shitloads of associations
06:10:48 <r3m0t> > map (++" went into the store") (cycle ["pete","repeat"])
06:10:49 <lambdabot>  ["pete went into the store","repeat went into the store","pete went into the...
06:10:50 <Peaker> gwern: If English had proper huffman coding, we'd have short words for the often-used things, and long words for rare things, but English is broken :)  I don't think an English-based programming language should try to fix that
06:10:51 <gwern> Peaker: one thing I've long wanted to do is to add error-checking letters to english words or sentences - I figure with more than 20 letters and shifts, you could get a lot of checking/correction in a single character
06:11:16 <Philippa_> Peaker: once upon a time it did. Welcome to evolution: it fucks things up too
06:11:29 <gwern> and then you could try cool optimizations like correcting for more common transcription or spelling errors instead of assuming all kinds of errors are equally likely!
06:11:34 <gwern> there's a lot of possibility there
06:12:17 <Peaker> Philippa_: I think the right thing to do is just give up on the not-so-important goal of having short-words and short descriptions. I think the other advantages/disadvantages make the effects of short/long descriptions completely negligible
06:12:49 <newsham> ecc.huffman.english
06:12:57 <Philippa_> whereas for symbolic manipulation purposes I highly agree. Most modern Java code makes me want to vomit because of all the mental indirection I have to do just to follow WTF's going on!
06:13:22 <Philippa_> this.that.other.more.fucking.indirection.frob
06:13:25 <Peaker> the ability to read code with little dependence on documentation, the ability to grep for things, the ability to understand the working assumptions from the names, the making of many comments unnecessary - these are all each more important than "short cute names"
06:13:57 <Philippa_> where documentation exists and can be readily accessed, being able to work without it straight away isn't a big deal
06:14:11 <Philippa_> binding structure-aware grepping would help, sure
06:14:22 <Peaker> Philippa_: Documentation is never as easy to read, access and maintain as the code/api is
06:14:29 <newsham> as.map(new F<String,Unit>() {public Unit call(String arg) {System.out.println("arg: " + arg);return Unit.unit;}});
06:14:37 <Philippa_> trust me, documentation is *often* easier to read for interesting code
06:14:50 <Philippa_> and for my purposes frequently as easy to access
06:14:54 <Philippa_> maintenance I'll give you
06:15:08 <newsham> wtf isnt the documentation in the code in the first place?
06:15:27 <Philippa_> now, I'd like a good way to tell an editor or IDE "here's the longhand version of this short identifier"
06:15:35 <Peaker> Philippa_: I meant ease of access there, but I already mentioned that, so I can take "easier to read" back :-)  You want to read 2 things out of the code - how it works - what API/contracts it abides to.  The first is easier to read in docs, the latter is just as easy to read in properly-named code
06:15:42 <Philippa_> not least because having to think with the long identifier actually clogs up my mental purposes
06:15:54 <dmcgettigan> Ha, I clicked into this channel by mistake. I remember doing haskell in college. Whats it used for in the real world?
06:16:10 <gwern> dmcgettigan: programming
06:16:10 <Philippa_> properly-named code alone will tell you fuck all about non-trivial contracts
06:16:13 <Peaker> Philippa_: I believe IDE's should be much more powerful in this regard too
06:16:20 <dmcgettigan> programming what?
06:16:21 <Philippa_> *mental processes
06:16:22 <newsham> real world haskell
06:16:27 <Philippa_> ...see?
06:16:45 <Peaker> Philippa_: I think properly (perhaps carefully)-named code will tell you everything you need to know about the contracts that is not already spelled out by the types
06:16:47 <Philippa_> Thing is, it should still be safe for me to code with my brain throwing up lots of little errors like that
06:16:51 <dmcgettigan> I think i used it to model somethig simple like a vending machine. the logic of it.
06:17:05 <Philippa_> Peaker: I think you've never seen a really complicated contract, then
06:17:15 <newsham> ?faq can haskell be used to write dmcgettigan's programs?
06:17:15 <lambdabot> The answer is: Yes! Haskell can do that.
06:17:18 <chrisdone> types are so helpful for documentation
06:17:18 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:17:20 <Peaker> Philippa_: perhaps, I take great care in making my contracts simple
06:17:35 <Philippa_> repeat after me: not all code looks like mine, not all code /should/ look like mine
06:17:53 <dmcgettigan> is anyone in here under 30?
06:17:59 <Philippa_> dmcgettigan: plenty of people
06:18:09 <dmcgettigan> yeah, im suprised
06:18:10 <Philippa_> I'm pretty sure we've more than one teenager, even
06:18:14 <dmcgettigan> wow
06:18:18 <jansz> @pl (\c -> fromJust . findIndex (==c) $ xs )
06:18:18 <lambdabot> flip (fromJust .) xs . findIndex . (==)
06:18:20 <Peaker> Philippa_: if I didn't believe I was doing things the right way, I'd change my ways.. So ofcourse I believe the ways I write code is how I believe it should be written, and will try to convince my coworkers to write like that too
06:18:24 <Axman6> dmcgettigan: i am
06:18:45 <drigz> dmcgettigan: i turned 20 a week or two ago
06:18:50 <dmcgettigan> so whats so great about haskell Axman6 ?
06:19:02 <BONUS> hey, hmm, what are the monoid laws
06:19:03 <Axman6> it's easy to read, and quite fast
06:19:14 <dmcgettigan> What have you used it for?
06:19:17 <Axman6> very easy to understand once you know it
06:19:28 <Philippa_> Peaker: you haven't seen all possible classes of coding problem. Nobody has. You may be able to take ideal world stabs, you /cannot/ do the same for the world we actually live in
06:19:34 <Philippa_> this is an idea it's a good idea to get used to
06:19:35 <Peaker> Philippa_: indeed some contracts need a couple of comments because it is difficult to encode that information into the names, but that's a bad sign
06:19:49 <Axman6> not that much really. we learnt it as part of our comp course, and now we're doing java, so not much time for haskell :\
06:19:51 <newsham> http://www.haskell.org/haskellwiki/Introduction
06:19:52 <lambdabot> Title: Introduction - HaskellWiki
06:19:59 <Axman6> been doing project euler problems in it though
06:20:15 <chrisdone> comments are usually the “why”...
06:20:27 <dmcgettigan> Guy called Richard Lawler from DIT, in Dublin was my lecturer. He seemed to know his stuff.
06:20:29 <chrisdone> the “how” and “what” are in the code
06:21:00 <Peaker> Philippa_: I don't claim to have all the answers - but I do think contracts can be made simple in virtually all cases (that's from my empiric experience)
06:21:02 <drigz> chrisdone: what characters are those? (not the letters or spaces)
06:21:10 <newsham> "In particular, strong typing means no core dumps!"
06:21:25 <Axman6> dmcgettigan: lecturers who use haskell tend to do that :P
06:21:42 <newsham> *peers at core dump*
06:21:44 <Peaker> newsham: doesn't Haskell have some unsafe array stuff that leads to core dumps?
06:21:49 <Axman6> so, what do you people use haskell for in the real world anyway?
06:22:08 <drigz> Peaker: the unsafe stuff breaks the typing
06:22:25 <drigz> Peaker: so you could argue that you won't get core dumps if you adhere to strong typing
06:22:27 <Philippa_> Peaker: if you're working on something cutting edge, the problem isn't whether they can but when they can
06:22:55 <Peaker> Philippa_: not sure what you mean there
06:22:56 <Philippa_> the answer is "probably not on the first pass"
06:23:01 <chrisdone> drigz: left quote and right quote
06:23:11 <Philippa_> sometimes you're working with things that aren't well-understood yet
06:23:15 <drigz> chrisdone: ok, thanks
06:23:18 <Peaker> Philippa_: oh - ofcourse its very difficult to get things right before a couple of re-writes
06:23:23 <Philippa_> more often, with things that aren't within your own team
06:23:43 <newsham> http://www.haskell.org/haskellwiki/Haskell_in_practice
06:23:44 <lambdabot> Title: Haskell in practice - HaskellWiki
06:23:45 <Philippa_> sometimes your project doesn't have time for rewrites of that scale and especially not while retaining appropriate performance
06:23:50 <Philippa_> (yes, that even happens in Haskell)
06:23:54 <Axman6> cheers newsham
06:24:01 <qebab> just out of curiousity, what are the 'chances' of finding a job where you get to work with a language like haskell?
06:24:09 <dmcgettigan> Axman6: I remember what I used it for in college. To compare the different sorting algos
06:24:10 <Philippa_> good practices have to be able to survive that kind of pressure without falling apart
06:24:10 <qebab> as in, are there plenty, or very few?
06:24:30 <Philippa_> qebab: for 'a language like', if you're good and willing to look you should be able to find one
06:24:31 <newsham> http://www.haskell.org/haskellwiki/Jobs
06:24:32 <lambdabot> Title: Jobs - HaskellWiki
06:24:41 <Peaker> Philippa_: I think more often than not, when a developer screams for a rewrite - it SAVES time to let him do it, rather than waste time - in the medium and long run
06:25:07 <Philippa_> Peaker: welcome to the world, we get forced into poor medium-to-long term choices for the sake of not sinking in the immediate once in a while
06:25:25 <nax> rewrites can be very risky
06:25:26 <Philippa_> and sure, some of those can be handled the other way but some can't
06:25:32 <Peaker> Philippa_: That's when I quit my job and go elsewhere, I think :-)
06:26:04 <newsham> quitter!  ;-)
06:26:10 <Philippa_> so much for reality-resistant practices :-)
06:26:14 <Peaker> (If I consistently disagree with management, I'd change jobs.  This hasn't happened yet)
06:26:14 <paolino> @wishList (+) listUnfoldr f = unfoldr $ liftM2 (>>) (guard . not . null) (Just . f)
06:26:14 <lambdabot> Unknown command, try @list
06:26:21 * Philippa_ nods
06:26:25 <Philippa_> it's not necessarily about consistently though
06:26:33 <newsham> wishlist (+) ?
06:26:36 <EvilTerran> paolino, what?
06:26:55 <paolino> nm, newbies folies
06:27:11 <Philippa_> it's about: we've still got these two modules that're hellish because someone's methods broke down and now they need a from-scratch rewrite rather than a mere merciless refactoring
06:27:29 <Philippa_> your accumulation rate may be lower, but you still accumulate them
06:28:37 <newsham> unfoldrp p f = unfoldr (\x -> guard (p x) >> f x)
06:30:11 <paolino> it's like when I hit same function too many times in a few weeks I think it's useful, which is probably not true
06:31:21 <Peaker> Philippa_: do you think the Haskell community focuses more on the writability of software, or the readability?
06:32:13 <newsham> peaker: about average, across the community.
06:33:06 <Philippa_> though I'd add that we're picky about the correctness part of writeability in circumstances where it's somewhat hairy. Sometimes you really do have to come back and make it readable-to-others later to keep your head around it
06:33:39 <Philippa_> sometimes you get nagged for a release first!
06:33:50 <Peaker> imo, this is the Python lesson - that writability is much less important than readability. It doesn't matter if it takes 2 or 3 times longer to write, if it is somewhat easier to read, later. It will be read far more than it is written
06:34:03 <Philippa_> Python can kiss my arse on that one
06:34:10 <Philippa_> not everyone has the same experience that way
06:34:34 <Philippa_> I have in excess of an order of magnitude more good reading time than good writing for example
06:34:54 <Philippa_> which isn't to say that it shouldn't be written on the basis it needs to be read
06:35:06 <Philippa_> but /damn/ Python's means in that regards are horrible for a lot of code
06:35:20 <Philippa_> (not infrequently for writeability too, but hey)
06:35:35 <Philippa_> the 'target audience' issue needs considering, too
06:35:46 <Peaker> Philippa_: can you name some specific issues that bother you?
06:36:02 <Philippa_> I (attempt to) use bigger identifiers in tutorial code, for example
06:36:32 <Philippa_> Peaker: "don't use that abstraction that's the way you think about it!" - utter death when I'm trying to get something written
06:37:15 <Peaker> Philippa_: You can use that abstraction - if you create nice classes to represent it - and properly name them
06:37:17 <Philippa_> I have a habit of using initialled identifiers - especially in pattern matches - rather than the full names because I need to not pull in the additional conceptual weight that an english name'd have when I work with it
06:37:44 <Philippa_> no, I really can't half the time. Sorry, but Python's /shite/ for AST manipulation
06:37:50 <Peaker> but the initials already pull that conceptual weight by representing those words?
06:38:23 <Philippa_> no. The linguistic-meaning-of-words is two hops removed so they actually just pull the concept they actually represent rather than the related stuff
06:38:28 <Peaker> you are just adding a bit more weight by having to go look up what these initials mean (adding an error-prone stage too)
06:38:41 <Philippa_> er, no. Actually IME I can read the code years later
06:38:48 <drigz> Philippa_: just look at the type signature :p
06:38:55 <drigz> sorry, Peaker: ...
06:39:09 * Cale often uses single letter variable names with no meaning
06:39:26 <Philippa_> yeah. Sometimes it's /the right thing/. It helps that the alphabet has an ordering on letters, mind
06:39:29 <Cale> Particularly when pattern matching
06:39:29 <Peaker> drigz: that's great - the types don't always tell the full story (I'd love to use @djinn to write my software :-)
06:39:37 <Philippa_> fst (x,y) = x works fine for a lot of people
06:39:55 <gwern> @hoogle lookup
06:39:55 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:39:55 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:39:55 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:40:12 <Axman6> fst (x,_) = x can be even more meaningful
06:40:22 <gwern> shoot. what's a function in Data.Map that clashes with the Prelude?
06:40:34 <paolino> filter
06:40:37 <paolino> map
06:40:38 <Peaker> Philippa_: sure, I have little problem with one-letter-names that are only meant to establish a link between two positions in _very short_ code.  If they are used in longer code, or represent something that isn't clear - Don't add a comment to explain what "x" holds, name "x" properly
06:40:40 <Philippa_> true. I don't use _ as much as I should
06:41:01 <Axman6> explicitly says you only care about the first element
06:41:02 <Philippa_> Peaker: definitions of "very short" vary
06:41:05 <gwern> thanks
06:41:17 <gwern> -Wall forces me to use _ as often as I should :)
06:41:38 <Cale>     witness p = let a = witness (\x -> p (x:witness (\xs -> p (x:xs))))
06:41:38 <Cale>                 in a : witness (\xs -> p (a:xs))
06:41:41 <Philippa_> sometimes the reinforcement that a given position in a pattern serves the same role in each case is useful
06:41:43 <Peaker> Philippa_: and since short code often grows to be long code, I try to use proper names even in short code:  fst (first, _second) = first -- is just as good, but can grow more easily
06:42:01 <Cale> Just try and name those variables meaningfully :)
06:42:26 <paolino> gwern : worse is with Data.Map with Data.List
06:42:28 <gwern> > map id $ empty
06:42:29 <lambdabot>   add an instance declaration for (Show (f a))
06:42:38 <Philippa_> Cale: I bet you could assign more meaning to p (to people who don't do quite as much work with such things, as it'll already carry that meaning to those who do) easily enough
06:42:45 <gwern> > Data.Map.map id $ Data.Map.empty
06:42:46 <lambdabot>   Not in scope: `Data.Map.empty'
06:42:52 <paolino> and empty in Control.Applicative
06:43:01 <gwern> :t Data.Map.empty
06:43:02 <lambdabot> forall k a. M.Map k a
06:43:08 <Philippa_> type variables often want to remain single letters, too
06:43:11 <gwern> > Data.Map.map id $ empty
06:43:12 <lambdabot>   Not in scope: `Data.Map.map'
06:43:13 <Axman6> Cale: how about you make a meaningful function :o
06:43:15 <Cale> Philippa_: that's true, I could call it predicate or something :)
06:43:18 <Peaker> Cale: I think "i" in C (loop iterator) and "x:xs" in Haskell are fine, as there is no more meaning to convey here besides "the list", and they do convey that information, by convention
06:43:36 <gwern> hm. does lambdabot not have Data.Map?
06:43:38 <Axman6> Peaker: agreed
06:43:42 <gwern> :t Map.map
06:43:45 <gwern> :t Data.Map.map
06:43:46 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
06:43:47 <gwern> :t map
06:43:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:44:08 <gwern> > Map.map id $ empty
06:44:09 <lambdabot>   Not in scope: `Map.map'
06:44:13 <Philippa_> now, badly-named functions I have very little time for
06:44:18 * gwern sighs
06:44:44 <Axman6> Cale: what's that supposed to do anyway?
06:44:50 <Philippa_> (though sometimes, "frob" and a one-line conceptual comment is better for a one-shot local function)
06:44:56 <Peaker> Philippa_: I should disclaim that I have limited Haskell experience, and am speaking about other languages. Maybe in Haskell the ideal naming schemes/conventions differ
06:45:14 <Cale> Axman6: Oh, I suppose I should mention that it's an instance of a class...
06:45:20 <Cale> class Witness a where
06:45:20 <Cale>     witness :: (a -> Bool) -> a
06:45:22 <Philippa_> the preferred code density in Haskell is certainly very different
06:45:24 <ski> (meaningless identifiers are better than misleading identifiers)
06:45:34 <Philippa_> and the denser the code, the more big identifiers get in the way
06:45:46 <Cale> Specifically,  instance Witness a => Witness [a]
06:45:55 <Philippa_> if they get long enough they actually start to affect layout and thus visual cues as to code structure
06:46:05 <ski> Cale> :t witness
06:46:10 <Philippa_> which is something that infuriates me about Java code where this often seems to be acceptable
06:46:17 <Peaker> Cale: what does witness do?
06:46:19 <Philippa_> but no, gotta qualify everything
06:46:42 <Axman6> Cale: you're crazy man :)
06:46:45 <Cale> Peaker: It takes a total predicate, and finds a value for which that predicate is True.
06:47:20 <Philippa_> or to put it another way, finds a witness that the predicate is satisfiable
06:47:30 <Cale> right :)
06:47:49 <Philippa_> IOW: the name is plenty descriptive if you know the domain
06:48:11 <Axman6> Cale: could you give an example?
06:48:21 <kryptiskt> a nice java rant about Java misuse of "abstraction" http://zedshaw.com/rants/indirection_is_not_abstraction.html
06:48:22 <ski> Cale : that seems similar to universal quantification over Baire space and such things ..
06:48:22 <lambdabot> Title: ZSFA -- Indirection Is Not Abstraction
06:48:31 <Peaker> > witness (>5) :: Int
06:48:33 <lambdabot>   Not in scope: `witness'
06:48:48 <Axman6> so it might find 6?
06:49:09 <Axman6> or any number that's greater than 5?
06:49:11 <Cale> yeah.
06:49:19 <r3m0t> Cale: how does it work?
06:49:19 <BONUS> why does the writer environment of the Writer monad have to be a Monoid instance? MonadPlus makes more sense to me
06:49:20 <Axman6> or all numbers that are greater than 5...
06:49:29 <Peaker> Axman6: just one number
06:49:39 <Philippa_> BONUS: MonadPlus just gives you a monoid anyway, and monoid is more general
06:49:52 <BONUS> aha
06:49:58 <Cale> There was a nice blog post about this a while back called "Seemingly impossible functional programs"
06:50:03 <Axman6> so what would witness (>5) equal then?
06:50:14 <Cale> Axman6: Well, depends on the instance for Int
06:50:35 <Axman6> eh?
06:50:49 <Peaker> You could have   instance Enum a => Witness a where ... ?
06:51:04 <Cale> (Enum a, Bounded a) => Witness a,  I suppose
06:51:20 <Cale> In which case, if it traversed them from lowest to highest, you'd get 6.
06:51:28 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
06:51:30 <lambdabot> Title: Mathematics and Computation  Seemingly impossible functional programs, http://tinyurl.com/2umqwh
06:51:58 <Axman6> kryptiskt: what an awesome blog
06:52:44 <Philippa_> to go back a little: I'm probably slightly unreasonably irritable about Python because for a lot of tasks it forces code that stops you seeing the woods for the trees, largely because the BDFL holds the view that the Right Thing is too complicated because it's not standard OO/imperative fare
06:52:56 <ski> Cale : right .. i thought it looked like Martin Escard :)
06:53:01 <Cale> ski: :)
06:53:13 <ski> (just couldn't recall his name)
06:53:18 <Cale> ski: Yeah, it's my own adaptation of those ideas.
06:53:49 <idnar> Philippa_: there is a (relatively small, I suppose) community of Python coders who aren't terribly happy with soem of those decisions :P
06:53:53 <idnar> *some
06:54:33 <Peaker> Philippa_: examples?
06:54:35 <Philippa_> idnar: I'm aware. You could build a good language by starting with extensible records and variants, and an MLish functional-imperative core and sugaring from there
06:55:02 <idnar> Philippa_: heh
06:55:21 <Philippa_> Peaker: in short, anything algebraic sucks. Every time someone has to use the visitor pattern, god not only kills a kitten but disembowels it and sends it back to the owner
06:55:36 <mg5000> someone able to tell me how do i get a char out of a string ?
06:55:46 <Peaker> Philippa_: the visitor pattern is really just a workaround for the lack of multi-methods - and Python has better workarounds than that
06:55:53 <gwern> mg5000: which one?
06:55:56 <Philippa_> mg5000: there's an infinity of ways to do it. Which one?
06:56:05 <mg5000> i want to seperate the string "test" in t e s t as char
06:56:13 <idnar> Peaker: I'm not sure if that's true, but I don't think Python has *any* good "workarounds" for the lack of multi-methods
06:56:15 <mg5000> i dont know any
06:56:25 <Peaker> idnar: for one, there are multi-method implementations
06:56:32 <Philippa_> Peaker: no, it's a work-around for extensible variants. Multi-methods're just a more tolerable one with additional uses
06:56:33 <idnar> Peaker: that's not a workaround, then :P
06:56:34 <mg5000> so please be kind and post something that could be understandable for me
06:56:36 <gwern> mg5000: "test" == 't':'e':'
06:56:41 <gwern> s':'t':[]
06:56:58 <mg5000> ok thx will try that -... (qwern)
06:56:58 <Philippa_> (okay, it's a workaround for a full solution to the expression problem, but in this context it's a workaround just for plain algebraic datatypes and pattern-matching)
06:57:27 <gwern> > "test" !! 3
06:57:29 <lambdabot>  't'
06:57:34 <gwern> > head  "test"
06:57:35 <lambdabot>  't'
06:57:38 <ski> > ['t','e','s','t']
06:57:39 <lambdabot>  "test"
06:57:42 <ski> > ['t','e','s','t'] == "test"
06:57:44 <lambdabot>  True
06:57:48 <Philippa_> multimethods /also/ suck as a means of pattern-matching
06:58:10 <gwern> > let foo (a:b:c:ds) = a in "test"
06:58:12 <lambdabot>  "test"
06:58:19 <gwern> > let foo (a:b:c:ds) = a in foo "test"
06:58:21 <lambdabot>  't'
06:58:27 <mg5000> how can i do that with any possible sting _
06:58:39 <nax> how does thread safety work with foreign functions? there doesn't seem to be a way to specify if foreign functions are thread safe or not.
06:58:41 <chrisdone> (a:_)
06:58:41 <ski> mg5000 : every string is a list, just use list operations
06:59:04 <Axman6> mg5000: a string is just a list of Chars
06:59:07 <chrisdone> probably best to use foo = take 1
06:59:20 <mg5000> so my signature should look like this : somefunc::[String]->Char
06:59:30 <chrisdone> what if your string is empty?
06:59:31 <Axman6> i doubt it
06:59:42 <Peaker> Philippa_: When writing Python, I don't often find myself wishing for pattern matching (the useful tuple unpacking I do have)
06:59:42 <idnar> mg5000: I would think that would be [Char] or String (those are the same thing)
06:59:43 <ski> mg5000 : *which* character out of the string do you want ?
06:59:44 <gwern> > take 1 []
06:59:45 <lambdabot>  []
06:59:49 <Axman6> mg5000: give an example of what you want
07:00:04 <mg5000> or like that ? somefunc::[String]->[Char]
07:00:23 <Philippa_> Peaker: Congratulations. How much time do you spend working on naturally algebraic problems in Python?
07:00:35 <Axman6> mg5000: do you get that "test" = ['t','e','s','t',']?
07:00:36 <chrisdone> > let foo :: String -> String; foo = take 1 in foo "hello"
07:00:36 <Philippa_> heck, would you know naturally algebraic if you saw it?
07:00:37 <lambdabot>  "h"
07:00:39 <chrisdone> > let foo :: String -> String; foo = take 1 in foo ""
07:00:42 <lambdabot>  ""
07:00:49 <Peaker> Philippa_: What is a "naturally algebraic problem"?
07:00:56 <Philippa_> that'd be a "no"
07:00:58 <mg5000> i just want to convert a given string into chars and then print out the ascii codes for the letters
07:00:59 <Peaker> Philippa_: Right
07:01:04 <mg5000> as int
07:01:07 <Philippa_> a problem where one of the main structures involved is an algebra
07:01:08 <Deewiant> > map ord "foo"
07:01:09 <lambdabot>  [102,111,111]
07:01:22 <Philippa_> (and where you haven't had to go through unnatural contortions to make it one)
07:01:25 <chrisdone> :t ord
07:01:26 <lambdabot> Char -> Int
07:01:56 <Peaker> Philippa_: can you name some real-world problems?
07:01:57 <chrisdone> mg5000: a String is already Chars, String is a type synonym for [Char], which is a list of Chars
07:02:09 <Philippa_> the vast majority of (programming) language manipulation problems are about kicking algebras around, for example
07:02:15 <mg5000> ah thx thats nice to know
07:02:29 <Philippa_> (okay, so you need a parser somewhere and a prettyprinter somewhere, but all that stuff in the middle is algebraic)
07:02:32 <mg5000> so my signatur should look like this
07:02:43 <ski> mg5000 : ok. first your string already *is* a list of characters, so no conversion needed there .. then, as chrisdone noted, use the `ord' function for converting a character to an integer code
07:02:46 <mg5000> somefunc::[Char]->[Int]
07:02:55 <chrisdone> that's right
07:02:57 <Deewiant> ?ty map ord
07:02:58 <lambdabot> forall (f :: * -> *). (Functor f) => f Char -> f Int
07:03:07 <Deewiant> sigh
07:03:14 <Deewiant> ?ty Prelude.map ord
07:03:15 <lambdabot> [Char] -> [Int]
07:03:23 <mg5000> but before all this i have to get somehow every single letter to convert is via ord
07:03:27 <Philippa_> while we're at it, things like the command pattern are actually more naturally algebraic in nature
07:03:32 <ski> > map ord "test"
07:03:33 <lambdabot>  [116,101,115,116]
07:03:42 <Peaker> Philippa_: so you would say elaborate parsers/builders for binary structures would be inadequate in Python, for example?
07:03:50 <chrisdone> mg5000: use the `map' function which applies a function to each element in a list
07:03:56 <Axman6> map ord "test"
07:03:59 <Axman6> whoops
07:04:13 <Philippa_> Peaker: No, and I'd thank you to be a bit more careful in a) reading with I wrote and b) looking for counterexamples. Try not to do the latter on the assumption I'm stupid or ignorant, thankyouverymuch
07:04:18 <Axman6> > map (print.ord) "test"
07:04:20 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>]
07:04:21 <Philippa_> *reading what I wrote
07:04:24 <Axman6> yay
07:04:27 <Axman6> heh
07:04:32 <chrisdone> > map ord ['t','e','s','t']
07:04:33 <lambdabot>  [116,101,115,116]
07:04:40 <Peaker> Philippa_: I am just trying to understand what you're saying w.r.t some real world examples
07:04:46 <chrisdone> > ['t','e','s','t'] == "test"
07:04:48 <lambdabot>  True
07:04:56 <Philippa_> Peaker: how much do you know about interpreter and compiler innards?
07:05:09 <Peaker> Philippa_: as in: Instead of bitching about Python's abstract inadequacy in dealing with "naturally algabraic problems" - why can't you name some real-world examples instead?
07:05:16 <Philippa_> I *did*, you moron
07:05:31 <Philippa_> "<Philippa_> the vast majority of (programming) language manipulation problems are about kicking algebras around, for example"
07:05:33 <mg5000> thats nice :) thank you
07:05:34 <mg5000> map ord "test"
07:05:36 <mg5000> works
07:05:45 <chrisdone> welcome
07:05:52 <Peaker> Philippa_: a "language manipulation problem" is still a bit abstract
07:05:56 <Axman6> > ['t','e','\n','s','t']
07:05:57 <lambdabot>  "te\nst"
07:06:04 <Philippa_> if that's not specific enough for you, /ask for clarification and examples/, don't assume it's more of the same
07:06:09 <ski> mg5000 : if you haven't noticed yet, these lines starting with `> ' are commands to lambdabot to evaluate a haskell expression, and lambdabot then prints the answer, like with hugs or ghci if you have used any of them
07:06:20 <Philippa_> right. So: typecheckers, interpreters, compilers, anything vaguely related
07:06:50 <Philippa_> what's more surprising is how often you find that you've got something that's turning into one of the above in the middle of a more conventional application (only not for a general purpose programming language)
07:06:58 <Peaker> Philippa_: So, you are saying that writing interpreters in Python is inadequate?
07:07:15 <Philippa_> to the point where there are multiple design patterns for handling such things via OO encodings in the GoF book
07:07:23 <Philippa_> no, I'm saying that Python is a PITA for writing them in
07:08:01 <mg5000> thx guys :) at last it works  :
07:08:02 <mg5000> myfunc::[Char]->[Int]myfunc x = map ord x
07:08:04 <Peaker> Philippa_: I disagree
07:08:07 <pozic> How do you encode an algebraic datatype in Python anyway?
07:08:15 * pozic is no Python expert
07:08:27 <Peaker> pozic: Python just gave up on the typing problem - it uses duck-typing instead
07:08:57 <Philippa_> Peaker: congratulations, presumably I can't encode a list either and just use duck-typing instead
07:09:09 <mg5000> next questions is how do i create a funtion thats counts to the infinity ?
07:09:17 <Axman6> mg5000: map (print.ord) x may do what you want too. not sure
07:09:17 <Philippa_> datatypes don't require static typing
07:09:18 <mg5000> counter::Int->[Int]counter x =
07:09:25 <Philippa_> *typechecking them* does
07:09:35 <Axman6> mg5000: [1..]
07:09:36 <Peaker> Philippa_: can't encode a list? What do you mean?
07:09:40 <ski> > let counter x = [x..] in counter 10
07:09:41 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:09:48 <Philippa_> Apparently you're impervious to sarcasm as well
07:10:07 <Peaker> Philippa_: I don't understand what you were trying to say there, with or without sarcasm
07:10:08 <Philippa_> I'm saying that you clearly /can/ encode a list, or any algebraic datatype, if you're willing to do the work. It's not about typechecking.
07:10:29 <Philippa_> and "use duck-typing" is irrelevant
07:10:43 <mg5000> let counter x = [x..] WORKS but for what is in counter 10 ?
07:10:44 <Peaker> Philippa_: Python programs are not very much longer than their Haskell counterparts, in all examples I've seen - so I am not sure what extra work you're referring to
07:11:21 <Philippa_> now, as you're so certain writing interpreters in Python's fine: given the appropriate term datatype encoded already, how about a quickie eager lambda calculus interpreter?
07:11:27 <Philippa_> Just variables, applications and lambdas
07:11:47 <ski> mg5000 : lambdabot requires me to give it an expression to evaluate .. in a source file, you can just put `counter x = [x..]' as a definition
07:12:19 <mg5000> what is lamdabot ?
07:12:29 <ski> @botsnack
07:12:29 <lambdabot> :)
07:12:35 <ski> > "Hi there !"
07:12:36 <lambdabot>  "Hi there !"
07:12:38 <mg5000> @botsnack
07:12:38 <lambdabot> :)
07:12:44 <gwern> lambdabot was a scientist
07:12:45 <Peaker> Philippa_: a quick search reveals: http://www.faqts.com/knowledge_base/view.phtml/aid/4404 -- in my opinion it could be much nicer by separating the parsing from the executing, and being more OO
07:12:46 <lambdabot> Title: FAQTs - Knowledge Base - View Entry - Lambda calculus interpreter (was: Turing c ...
07:12:51 <gwern> a scientist who grew fed up with the world
07:12:56 <ski> mg5000 : lambdabot is a bot that can evaluate haskell expressions (amongst other things)
07:13:01 <gwern> and one day lambdabot said, 'I will stop the motor of the world!'
07:13:04 <gwern> and so he did
07:13:13 <Philippa_> Peaker: the haskell version, given the datatype declarations, is /a handful of lines/
07:13:21 <mg5000> how do i use lamdabot ?
07:13:27 <Philippa_> the datatype declarations push you into the ballpark of 10 or so
07:13:32 <dino-> > filterM (const [True, False]) "abc"
07:13:33 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
07:13:33 <Philippa_> (yes, I'm assuming you've got it parsed already)
07:14:00 <Philippa_> not only that, but those handful of lines perfectly represent what's relevant
07:14:48 <jpcooper> @hoogle Float -> Int
07:14:48 <lambdabot> No matches, try a more general search
07:14:49 <mg5000> ord 'a'
07:15:01 <jpcooper> are there any rounding functions?
07:15:03 <Peaker> Philippa_: link the Haskell program, I'll try to see how a Python equivalent looks like
07:15:09 <mg5000> @botsnack ord 'a'
07:15:09 <lambdabot> :)
07:15:14 <Deewiant> > ord 'a'
07:15:16 <lambdabot>  97
07:15:22 <ski> mg5000 : either see what other people do to make lambdabot respond .. or ask specifically .. oh, that's what you're doing ! .. ok, so to get lambdabot to try evaluate an expression `1 + 2' for you, try typing `> 1 + 2' .. the `> ' prefix tells lambdabot to try to evaluate it as an expression
07:15:22 <mg5000> >ord 'a'
07:15:30 <Deewiant> > ord 'a'
07:15:31 <lambdabot>  97
07:15:33 <ski> you need a space after the `>'
07:15:49 <Philippa_> okay, you'll get it with datatype declarations and imports
07:15:50 <Zao> jpcooper: A fair bunch in the prelude, I believe.
07:15:51 <mg5000> >ord 'a'
07:16:01 <mg5000> > ord 'a'
07:16:02 <lambdabot>  97
07:16:06 <mg5000> ah thx :)
07:16:08 <Zao> jpcooper: round, ceiling, floor and whatnot
07:16:30 <Zao> jpcooper: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AproperFraction
07:16:31 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
07:16:31 <drigz> @hoogle ceiling
07:16:31 <jpcooper> excellent
07:16:31 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
07:16:36 <mg5000> > counter x =  [x..]
07:16:37 <lambdabot>  Parse error at "=" (column 11)
07:16:37 <jpcooper> thanks
07:16:43 <mg5000> > counter 5
07:16:44 <lambdabot>   Not in scope: `counter'
07:16:50 <ski> mg5000 : only expression after the `> ' .. no definitions
07:17:07 <ski> if you want to make a local definition use `let <definition> in <expression>' like :
07:17:10 <r3m0t> what's the function r where r "42 35" = (42, " 35")
07:17:16 <drigz> > let counter x = [x..] in counter 5
07:17:17 <ski> > let  counter x = [x..]  in  counter 10
07:17:17 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
07:17:18 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:17:29 <mg5000> > > let  counter x = [x..]  in  counter 10
07:17:29 <lambdabot>   parse error on input `>'
07:17:35 <mg5000> > let  counter x = [x..]  in  counter 10
07:17:36 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:17:45 <pozic> r3m0t: that already compiles, but that's now what you meant.
07:17:46 <ski> > (reads :: ReadS Int) "42 35"
07:17:47 <lambdabot>  [(42," 35")]
07:17:49 <drigz> > break (==' ') "42 35"
07:17:50 <lambdabot>  ("42"," 35")
07:17:53 <mg5000> ah :)
07:17:54 <Peaker> Philippa_: ironically, its easier to find a working lambda calculus interpreter in Python than it is to find one in Haskell, it seems
07:17:56 <pozic> not*
07:18:00 <ski> r3m0t : saw that ?
07:18:06 <pozic> Peaker: it's not smart to say that.
07:18:08 <r3m0t> ski: thanks
07:18:10 <drigz> r3m0t: misread, soory
07:18:12 <drigz> *sorry
07:18:26 <Peaker> pozic: why?
07:18:33 <pozic> Peaker: ask Philippa_, if you dare.
07:18:38 <Axman6> > let x = -1
07:18:38 <lambdabot>  Parse error at end of input
07:18:42 <Axman6> damn
07:18:45 <gwern> Peaker: how is that true? we have at least 2 lambdab calculus interpreters on hackage
07:19:01 <Axman6> my scheme to redefine x was foiled once again!
07:19:05 <Peaker> gwern: I wrote "it seems", because that's how it seemed in a google search. Perhaps hackage is not indexed properly
07:19:06 <ski> r3m0t : you get an empty list when there's no possible parsing .. and several elements when there's several possible ways of parsing .. usually at top-level you are only interested in pairs with second part being the empty string, though ..
07:19:11 <gwern> to say nothing of the many toy examples on hackage
07:19:18 <gwern> @let x = (-1)
07:19:19 <lambdabot> Defined.
07:19:25 <gwern> > 1 + x
07:19:26 <ski> > x + y
07:19:26 <lambdabot> Terminated
07:19:27 <lambdabot> Terminated
07:19:34 <Axman6> :0
07:19:38 <gwern> > x
07:19:39 <lambdabot> Terminated
07:19:40 <Axman6> what have i done!
07:19:43 <Deewiant> > 1+1
07:19:44 <lambdabot>  2
07:19:58 <Deewiant> > 1+x
07:19:58 <lambdabot> Terminated
07:19:59 <Axman6> > [x..]
07:19:59 <lambdabot> Terminated
07:20:00 <ski> lambdabot should have a meter that tells how busy it (or its host) is
07:20:01 <Deewiant> @undef
07:20:02 <lambdabot> Undefined.
07:20:09 <Deewiant> > let x = (-1) in 1 + x
07:20:10 <lambdabot>  0
07:20:12 <Axman6> > [x..]
07:20:12 <gwern> Axman6: you maniac! you blew it up! you blew it all up! goddamn you to hell!
07:20:13 <lambdabot>  [Exception: not a number
07:20:14 <xerox> ?load
07:20:15 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
07:20:28 <Deewiant> lambdabot is so broken these days :-/
07:20:50 <Axman6> is .. a function? or one of the few things that aren't...
07:21:06 <nax> has anyone used the YHC javascript compiler target?
07:21:06 <r3m0t> no, it's a sugar
07:21:13 <r3m0t> > enumFrom (-1)
07:21:13 <Cale> :t enumFromTo
07:21:14 <lambdabot> forall a. (Enum a) => a -> a -> [a]
07:21:14 <lambdabot>  [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
07:21:15 <Deewiant> it's syntax sugar for the enumFrom* family of functions
07:21:15 <gwern> something to do with the Enum type class
07:21:28 <r3m0t> > enumFromThen 'a' 'c'
07:21:28 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
07:21:29 <ski> Axman6 : `[x..]' is syntactic sugar for `enumFrom x'
07:21:34 <ski> @src Enum
07:21:34 <lambdabot> class  Enum a   where
07:21:34 <lambdabot>     succ                     :: a -> a
07:21:34 <lambdabot>     pred                     :: a -> a
07:21:34 <lambdabot>     toEnum                   :: Int -> a
07:21:36 <lambdabot>     fromEnum                 :: a -> Int
07:21:36 <Axman6> ah, nice
07:21:38 <lambdabot> [3 @more lines]
07:21:40 <ski> @more
07:21:40 <lambdabot>     enumFrom                 :: a -> [a]
07:21:42 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
07:21:44 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
07:22:14 <Axman6> @src (+)
07:22:14 <lambdabot> Source not found.
07:22:18 <Axman6> lame
07:22:23 <Axman6> ok, how is + defined?
07:23:10 <ski> `(+)' is overloaded
07:23:18 <r3m0t> it's defined in each Num class
07:23:22 <ski> defined differently for different types
07:23:48 <ski> lambdabot doesn't seem to index `Num' instance source at the moment, though ..
07:23:51 <dcoutts> audreyt: ping
07:24:12 <Axman6> ski: well it should :( i'm curious
07:24:15 <r3m0t> well, it's defined in primitives
07:24:28 <r3m0t> i.e. in the source code of GHC or Hugs or any other system
07:25:40 <ski> well, not all `Num' types are primitive
07:25:56 <r3m0t> @scr ((+) :: Complex -> Complex -> Complex)
07:25:56 <lambdabot> Maybe you meant: arr rc src
07:26:00 <ski> e.g. `Complex' `(+)' should be defined something like
07:26:01 <ski>  (re0 :+ im0) + (re1 :+ im1) = (re0 + re1) :+ (im0 + im1)
07:26:03 <r3m0t> @src ((+) :: Complex -> Complex -> Complex)
07:26:03 <lambdabot> Source not found. My pet ferret can type better than you!
07:26:14 <r3m0t> @src ((+) :: Complex Float -> Complex Float -> Complex Float)
07:26:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:26:20 <r3m0t> yeah, tru dat
07:26:21 <ski> if lambdabot would index this, it could be fetched by
07:26:25 <ski> @src Complex (+)
07:26:26 <lambdabot> Source not found. Maybe you made a typo?
07:26:39 <ski> but it doesn't, so it couldn't
07:27:01 <ski> compare with the `Monad' class
07:27:06 <ski> @src [] return
07:27:06 <lambdabot> return x    = [x]
07:27:09 <ski> @src Maybe return
07:27:09 <lambdabot> return              = Just
07:27:12 <ski> @src Maybe (>>=)
07:27:12 <lambdabot> (Just x) >>= k      = k x
07:27:12 <lambdabot> Nothing  >>= _      = Nothing
07:27:26 <r3m0t> @src [] (>>=)
07:27:26 <lambdabot> xs >>= f     = concatMap f xs
07:27:27 <Deewiant> @src Maybe fail
07:27:27 <lambdabot> fail _      = Nothing
07:27:36 <r3m0t> @src lambdabot
07:27:36 <lambdabot> Source not found. You type like i drive.
07:27:41 <ski> @src [] fmap
07:27:42 <lambdabot> fmap = map
07:27:44 <ski> @src Maybe fmap
07:27:45 <lambdabot> fmap _ Nothing       = Nothing
07:27:45 <lambdabot> fmap f (Just a)      = Just (f a)
07:29:18 <Axman6> oh no!
07:29:19 <Axman6> module Int ( module Data.Int ) where
07:29:19 <Axman6> import Data.Int
07:29:34 <Axman6> in /Users/Axman/compiled-projects/ghc-6.8.3.20080617/libraries/haskell98/Int.hs
07:29:56 <ski> @src Int
07:29:56 <lambdabot> data Int = I# Int#
07:29:56 <Philippa_> Peaker: http://hpaste.org/9341
07:30:25 <Philippa_> delay because I wrote it off the top of my head and was a little distracted
07:31:09 <Philippa_> I could take a line out of eval at first glance, but that code's more readable
07:31:17 <Axman6> > 'a' + 'b'
07:31:18 <lambdabot>   add an instance declaration for (Num Char)
07:31:18 <lambdabot>     In the expression: 'a' + 'b'...
07:31:40 <EvilTerran> Axman6, what would you expect that to mean?
07:31:45 <Deewiant> > chr $ ((+) `on` ord) 'a' 'b'
07:31:46 <lambdabot>  '\195'
07:31:47 <Axman6> c? :P
07:32:13 <Philippa_> the closure encoding is, admittedly, mildly naughty. But I've not gone and used pointless trickery to make the App case a one-liner
07:32:18 <Axman6> pretty sure my lecturer would've slapped me over the head for that
07:33:31 <Philippa_> Peaker: it's easier for Python partly because Python isn't a derivative of the lambda calculus, you realise?
07:33:35 <r3m0t> > let f x = fromEnum x - fromEnum 'a' in (toEnum $ ((+) `on` fromEnum) 'a' 'b')::Char
07:33:36 <lambdabot>  '\195'
07:33:40 <r3m0t> > let f x = fromEnum x - fromEnum 'a' in (toEnum $ ((+) `on` f) 'a' 'b')::Char
07:33:41 <lambdabot>  '\SOH'
07:33:48 <r3m0t> huh?
07:34:02 <Deewiant> > ord '\SOH'
07:34:03 <lambdabot>  1
07:34:17 <Peaker> Philippa_: why would that make it easier?
07:34:23 <r3m0t> > let f x = fromEnum x - fromEnum 'a'; g x = toEnum (x + fromEnum 'a') in (g $ ((+) `on` f) 'a' 'b')::Char
07:34:24 <lambdabot>  'b'
07:34:32 <Philippa_> because that means there are shitloads of hits for "haskell lambda calculus" that aren't interpreters
07:34:35 <ski> > ['\0'..]
07:34:36 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
07:34:40 <Philippa_> and they're relevant for a good many purposes
07:34:46 <r3m0t> my code now makes sense
07:35:02 <r3m0t> > let f x = fromEnum x - fromEnum 'a' + 1; g x = toEnum (x + fromEnum 'a' - 1) in (g $ ((+) `on` f) 'a' 'b')::Char
07:35:02 <Philippa_> that is: it's easier to find lambda calculus interpreters in Python because it's easier on the search engines
07:35:03 <lambdabot>  'c'
07:35:12 <r3m0t> > let f x = fromEnum x - fromEnum 'a' + 1; g x = toEnum (x + fromEnum 'a' - 1) in (g $ ((+) `on` f) 'c' 'e')::Char
07:35:13 <lambdabot>  'h'
07:35:15 <Philippa_> also: because they're generally considered trivial and thus buried somewhere in a tutorial
07:35:22 <r3m0t> > ['a'..'h']
07:35:23 <lambdabot>  "abcdefgh"
07:35:39 <Philippa_> if you want a parser I can go trim a pile of my existing Parsec code and you'll even get some sugar btw
07:35:52 <Philippa_> but I figured we're comparing evaluators, so no point
07:38:00 <Philippa_> anyway, can you get near? If not, can you see why I would get very impatient with languages that can't do that when working with bigger languages and more complicated operations on them?
07:38:31 <ski> r3m0t : why the `+ 1' and `- 1' ?
07:38:46 <r3m0t> ski: so that f 'a' = 1
07:39:16 <r3m0t> although I could have checked
07:39:18 <r3m0t> > pred 'a'
07:39:24 <lambdabot>  '`'
07:40:03 <Philippa_> note that by 'near' I mean not only in compactness but in ease of reading the relevant details
07:40:20 <ski> r3m0t : 1-counting heathen ;)
07:40:30 <r3m0t> ski: ok, ok
07:40:40 * Philippa_ should probably check if there's a function for maybe _ _ . lookup sometime, too
07:40:50 <r3m0t> > let base = pred 'a'; f x = fromEnum x - fromEnum base; g x = toEnum (x + fromEnum base) in (g $ ((+) `on` f) 'c' 'e')::Char
07:40:51 <lambdabot>  'h'
07:41:37 <r3m0t> @hoogle (Eq a) => a -> [(a, b)] -> b
07:41:38 <lambdabot> No matches, try a more general search
07:42:20 * ski realizes Philippa_ probably doesn't mean `compactness' as in topology ..
07:42:31 <r3m0t> oops
07:42:57 <Philippa_> ski: heh. Out of interest, is it possible to relate the topological definition to the one I'm using without going through the general English definition?
07:43:37 <atp> > head . map (snd) . filter (\x -> fst x == 3) $ [(1, "hello"), (5, "bye"), (3, "yo")]
07:43:38 <lambdabot>  "yo"
07:44:22 <Philippa_> Peaker: that evaluator is if not the language processing "Hello World" then the program after it (an equivalent for a first-order language is easier)
07:44:42 <atp> :t \a -> head . map (snd) . filter (\x -> fst x == a)
07:44:43 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> b
07:44:50 <Philippa_> just to help you picture the kinds of complexity involved in 'real work'
07:44:56 <ski> Philippa_ : well, i'm not sure exactly what definition you're using .. i was just initially thinking you must make some interesting connections between `near' there and neighbourhoods and compactness :)
07:44:57 <xerox> > find (\x -> fst x == 3) [(1, "hello"), (5, "bye"), (3, "yo")]
07:44:58 <lambdabot>  Just (3,"yo")
07:45:59 <twanvl> Philippa_: your evaluator doesn't look all that eager to me
07:46:20 <Philippa_> twanvl: I may've blown it, wasn't thinking too hard. Feel free to fix it
07:46:57 <atp> :t safeHead
07:47:53 <twanvl> right now you get the same evaluation order as Haskell, you could 'fix' it with a seq
07:48:18 <ski> twanvl : it is eager in some sense .. i.e. `i' in the environment is bound to the evaluated expression .. only the computing of that expression is done lazily
07:48:44 <ski> but yes, wrt termination
07:49:26 <plaeremans> hi guys I'm trying to run Yi after cabal installing it on OS X 10.5
07:49:33 <plaeremans> but I get this :
07:49:35 <plaeremans> Launching custom yi: "/Users/pieter/.yi/yi-i386-darwin"
07:49:35 <plaeremans> yi: /Users/pieter/.yi/yi-i386-darwin: executeFile: does not exist (No such file or directory)
07:49:36 <Philippa_> I figure a bang pattern's probably more appropriate, but hey. End of nitpick, it's not like it's the first silly mistake I've made this afternoon :-)
07:49:52 <Philippa_> ...*hah*
07:49:58 <Philippa_> someone's ducking the discussion
07:50:52 * shapr ducks
07:51:00 * shapr hugs vixey 
07:51:10 * Philippa_ aims low and gooses
07:51:10 <ski> morning vixey
07:51:26 <vixey> hi hi
07:51:28 * vixey hugs shapr
07:51:41 <shapr> yay!
07:51:53 <shapr> vixey: When are you coming to Boston to visit? :-)
07:52:37 <vixey> mm boston is pretty far
07:52:47 <shapr> It'll be fun!
07:53:13 <shapr> There's lots of nifty stuff in Boston.
07:53:25 <atp> lots of pretty girls in boston
07:53:51 <shapr> And cool code too
07:54:43 <atp> yeah, but there's cool code in the uk
07:54:46 <atp> not so much pretty girls :)
07:55:20 * shapr shrugs
07:55:33 <shapr> I think there are interesting people everywhere.
07:55:55 <Philippa_> atp: I disagree. Okay, my girlfriend might not appreciate it if I didn't, but still - no shortage of pretty people where I am
07:56:21 <atp> it was sort of a joke
07:56:32 <atp> perhaps not very funny
07:57:31 <Philippa_> it's got hints of "OMG, a girl on the internet!!!" about it
08:00:42 <Shiruka> I thought it was joking with some british stereotypes.. not much to do with the interweb?
08:01:34 <jpcooper> Shiruka, maybe such statements, even if stereotypical, aren't to be taken seriously?
08:02:15 <nax> holy shit vim just went bananas and then segfaulted on me for the first time ever
08:02:31 * Shiruka doesn't usually take jokes seriously..
08:03:41 <BONUS> has anyone ever mentioned that it's ironic that kind errors are never really kind
08:04:06 <Shiruka> nax: might I point thee to the holy church of emacs?
08:04:42 <Shiruka> ... although emacs has crashed on me a bazillion times, so maybe it's not a solution :-P
08:04:52 <shapr> I've only had emacs crash on my once.
08:04:59 <BONUS> i never got a vim crash
08:05:12 <Shiruka> there was a time when emacs didn't particularly like UTF-8
08:05:55 <Shiruka> so I switched to xemacs, until that started crashing for some other strange reason (XIM?), and then switched back to emacs, which had been fixed in the meanwhile.. (-.-
08:06:06 <shapr> Now there's Yi!
08:06:21 * ski hands Shiruka a `)'
08:07:02 <jpcooper> YAY to forfeiting emacs just because it's written in our favoured language!
08:07:11 <jpcooper> (Yi)
08:07:14 * Shiruka looks at the strange symbol uncomprehendingly. How on earth did you flip ( horizontally?! :-O
08:07:39 <shapr> jpcooper: My reasons for abandoning emacs are legion.
08:07:45 <jpcooper> oh, okay then
08:07:47 <Philippa_> jpcooper: well, to be fair it's that and it has at least the potential to be all emacs is only better for numerous purposes
08:08:00 <shapr> jpcooper: I actually wrote a long post about it on the original Yi mailing list.
08:08:22 <jpcooper> does Yi have a haskell interaction mode?
08:13:44 <Philippa_> jpcooper: if it doesn't it should be easy to add given that yi:haskell::emacs:elisp
08:14:02 <painy> does anyone know how to convert a long int into a string in C++?
08:14:20 <jpcooper> Philippa_, yeah
08:14:26 <gwern> Philippa_: I'd hardly say it's as easy to add eval for haskell as it is for elisp...
08:14:32 <ibid> painy: using the string streams is the usual choice
08:14:45 <ibid> painy: i believe there is an example in the C++ FAQ
08:14:52 <painy> okay i'll give it a shot
08:14:57 <ibid> (comp.lang.c++ FAQ, to be precise)
08:15:07 <Shiruka> yi:haskell :: emacs:elisp <-- this type declaration doesn't parse
08:15:27 <Philippa_> gwern: not the point - it's basically already there
08:15:58 <painy> which part, ibid?
08:16:05 <gwern> what? what advantage does a compiled haskell app have over anything else? the ghc api integration is not much better than calling 'ghc -e'
08:16:07 <painy> (of the FAQS listed there)
08:16:14 <gwern> basically there indeed...
08:17:04 <Philippa_> gwern: you do realise what's being compared to, yes? Something that just calls ghc -e?
08:17:34 <Philippa_> and getting a haskell value back, even wrapped in a dynamic, is a big improvement on text output only
08:17:46 <gwern> something written in anything can call ghc -e; being written in haskell gives yi no especially edge
08:18:20 <gwern> Philippa_: the ghc api and trying to get an eval is responsible for *so* much breakage in yi. yi would've been better off up till now parsing string output
08:19:14 <ibid> painy: http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.1
08:19:15 <lambdabot> Title: [39] Miscellaneous technical issues, C++ FAQ Lite, http://tinyurl.com/yv8kl
08:19:51 <Philippa_> gwern: okay, so the currently implementation is getting hit by upstream stability issues, yes? Admittedly my "should" is taking a somewhat different tone here, but still
08:20:21 <Philippa_> it very much is an advantage when you can then pipe it through your own compiled tools within the editor without having to muck around with a pile of boundaries
08:20:41 <sw17ch> a continuous callback in FFI is generally frowned upon right?
08:20:53 <Philippa_> to the extent that you can't, yi is currently broken
08:22:12 <gwern> Philippa_: not just stability, but issues like the diamond dependency problem
08:24:07 <Shiruka> gwern: "would've been better of up till now" -- so things are looking better now?-)
08:24:14 <Shiruka> *off
08:24:15 <Philippa_> I'm probably being dumb here: where, and why isn't it an issue for emacs/elisp?
08:25:33 <Shiruka> eval tends to be well supported in lisps
09:06:56 <gwern> Shiruka: no, I qualify my statement because it's possible that 6.10 & newer cabals & packages like Hint will ameliorate the situation
09:07:01 <gwern> though they haven't yet
09:14:35 <zachk> @src zip
09:14:36 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:14:36 <lambdabot> zip _      _      = []
09:20:58 <nottha_k> i'm looking at the numeric prelude in hackage. it looks like to use the multiplication function in ring you would need to objects of the same type.
09:21:23 <nottha_k> how would you do something like a scalar times a vector?
09:34:31 <jaj> nottha_k: you could make your vector an instance of the Num class
09:35:14 <jaj> but it would probably be better to define your own operator
09:35:35 <drigz> @type (*)
09:35:36 <lambdabot> forall a. (Num a) => a -> a -> a
09:35:46 <SamB_XP> nottha_k: that's the way a ring is, yes
09:36:03 <SamB_XP> you probably want to be making a vector space rather than a ring, yes?
09:36:09 <vixey> > let (x,y,z) *. k = (x*k,y*k,z*k) in (2,3,4) *. 7
09:36:10 <lambdabot>  (14,21,28)
09:37:05 <nottha_k> so its an inherently different operation. it doesn't really fit into the notion of the ring? i was hoping a ring was some magical higher level of abtraction that would let me overload the (*) operator
09:38:59 <SamB_XP> hehe, you have much to learn of abstract algebra
09:39:20 <nottha_k> yup
09:43:35 <ski> nottha_k : a vector space builds on a ring (indeed a field), and adds another carrier and a couple of operations, including scalar multiplication
09:44:06 <SamB_XP> does it have to be a field?
09:44:52 <ski> if it's only a ring, then you get a module (specifically a left or right module, depending on the order in the scalar multiplication)
09:45:05 <SamB_XP> order ??
09:45:49 <ski> vixey's `(*.)' could be the scalar multiplication in a right module (if i'm not mixing them up)
09:46:03 <ski> a `(.*)' would be for a left module
09:46:25 <ski> obviously if the ring multiplication is commutative, it's isomorphic
09:47:25 <SamB_XP> what do you call a both-left-and-right module ?
09:48:15 <ski> you mean if you have both scalar multiplication on the left and on the right, with multiplication on scalars not necessarily being commutative ?
09:48:40 <SamB_XP> yeah
09:48:50 <ski> i don't know
09:49:04 <zachk> #math :D
09:49:06 * ski invokes the wikipedia page on modules
09:49:33 <ski> (presumably you'd want some coherence axioms relating the two scalar multiplications)
09:49:49 <zachk> whats the non-scalar
09:49:53 <SamB_XP> I'm guessing if you base your module on a commutative ring, it is called a "commutative module", among other things ...
09:50:11 <SamB_XP> zachk: we are discussing programming, can't you tell?
09:50:27 <nottha_k> even if a vector space is built up from a ring, its still a different operation right? it would need a different operator?
09:50:42 <ski> aha ! "A bimodule is a module which is a left module and a right module such that the two multiplications are compatible."
09:50:44 <SamB_XP> nottha_k: quite so
09:50:48 <zachk> SamB_XP: ahh
09:51:00 <ski> also "If R is commutative, then left R-modules are the same as right R-modules and are simply called R-modules."
09:51:03 <SamB_XP> ski: hmm, bimodule was one of the things that came to mind ...
09:51:13 <Toxaris> nottha_k: basically, yes. you could do some tricks with type classes, but that would be Wrong (tm), because it *is* a different operator conceptually
09:51:14 <zachk> well im pretty sure scalar multiplication on a vector is commutative
09:51:18 <SamB_XP> just as a possible thing I might name such a concept
09:51:32 <nottha_k> is the math convention of using the same one just a bastardization?
09:51:50 <zachk> sort of but not really
09:51:55 <SamB_XP> math convention is all about abuse of notation
09:52:08 <SamB_XP> (there is only so much notation to go around!)
09:52:11 * zachk thinks SamB_XP speaks the Truth 
09:52:27 <zachk> they even abuse parentheses though not as bad as lispers, yet
09:53:06 <ski> lispers abuse brackets ?
09:53:12 <zachk> when you get to rings the + and * sort of work as expected because * distributes over the + operator
09:53:20 <Toxaris> nottha_k: I don't think such a math convention exists. Back in school, we used different signs for the various multiplications
09:53:37 <SamB_XP> Toxaris: you used signs for multiplication?
09:53:39 <Toxaris> nottha_k: and in university, we used other different signs
09:53:56 <SamB_XP> you know, I would have assumed by school you *meant* university ...
09:54:07 <SamB_XP> (except I always call it college)
09:54:19 <Toxaris> SamB_XP: yes, to make clear which one it is. they could all be abbreviated by nothing
09:54:27 <vixey> to me, school, university and college are 3 different things
09:54:43 <Toxaris> I don't understand the anglosaxon education system at all
09:55:09 <vixey> it is very strange to me that somebody would use all 3 words with the same meaning
09:55:25 <SamB_XP> well, I don't actually use the word university ...
09:55:36 <Toxaris> so "in school" means "when i was 6 to 19 years old" and "in university" means "when i was 19 to 25 years old"
09:56:33 <Toxaris> (I'm always wondering why I spend so much time in university/college/whatever)
09:57:11 <SamB_XP> for me it is 17-21 so far, -22 on the 26th ...
09:57:14 <drigz> vixey: having spent too much time on the internet, i now understand college to mean uni, but i agree with you overall
09:57:46 <encryptio> by that definition, i've never been "in school"
09:57:50 <SamB_XP> what does college mean if it doesn't mean the smae as university ...
09:58:05 <SamB_XP> encryptio: what, you skipped from 5 to 20?
09:58:15 <Philippa_> Toxaris: there is no one anglosaxon educational system
09:58:20 <encryptio> SamB_XP: basically, yes.
09:58:20 <Philippa_> the UK and the US are very different, for example
09:58:38 <Toxaris> Philippa_: oh, that may be the source of my ignorance towards it
09:58:46 <SamB_XP> did I mention that my major does not require a spelling class?
09:58:50 <drigz> SamB_XP: i think college is used by some to mean secondary school, which is about the same as high school
09:59:10 <SamB_XP> drigz: I bet it's more like college is here
09:59:20 <drigz> i get the impression that 'school' is for 'kids'
09:59:33 <SamB_XP> (american education seems really lame to me)
10:00:01 <Philippa_> generally in the UK, yes. There are colleges of both "further education" and "higher education", though the latter tend to be part of a collegiate university (but not always)
10:00:11 * sfultong 's been reading all the back-and-forth on reddit about design patterns
10:00:13 <SamB_XP> 'round here, they're still kids when they reach what we call college
10:00:40 <zachk> in the USA i still consider the people who get into college or uni to be kids
10:00:41 <Toxaris> drigz: depends on how you define "kids"
10:00:44 <Philippa_> *nod*. A year or two older here generally - some unis just won't accept someone who isn't legally an adult however smart
10:00:47 <drigz> SamB_XP: where's 'here'?
10:01:01 <SamB_XP> Toxaris: not so much that as how slowly people mature ;-P
10:01:13 <SamB_XP> drigz: South Eastern Pennsylvania
10:01:18 <Philippa_> there's still a big difference between those who took a year out before uni and those who didn't
10:01:30 * zachk wishes he had taken a year out 
10:01:31 <SamB_XP> (as in "SEPTA")
10:01:37 <drigz> Philippa_: and no uni should, IMO
10:02:01 <zachk> a 17 year old with a phd is quite useless to society these days
10:02:04 <SamB_XP> Philippa_: there's a big difference between majority and adulthood
10:02:16 <Toxaris> drigz: why? how is the legal status of the student relevant for anything except buying beer?
10:02:31 <SamB_XP> Toxaris: majority isn't enough to buy beer 'round here anyway
10:02:36 <drigz> Toxaris: they can't buy beer? :p
10:02:51 <zachk> beer < 0
10:02:59 <SamB_XP> you need to be 21 to legally buy beer here
10:03:10 <SamB_XP> not that I care, since I don't want to buy any beer
10:03:19 <Toxaris> drigz: I assumed they may be not allowed to. Back home in Germany, you are allowed to buy beer at the age of 16
10:03:40 <jamii> Hmm. Data.Map is acting weirdly
10:03:41 <drigz> it's probably because you don't really hear about the success stories, but everyone i've heard about who entered uni at well sub 18 did so because they were pressured by their parents to do so
10:03:49 <drigz> and their age meant that they had to be excluded socially
10:03:58 <gwern> 'First, it's clear that views like hers would put Jesus on that cross again. Second, thy loom and churn best be still, come the Sabbath. Third, you can get on board or get left behind, because that Christian Nation Express is pulling out of the station!'
10:03:59 <jamii> *Main> Data.List.lookup "cBray" $ M.toList mp
10:03:59 <jamii> Just ()
10:03:59 <jamii> *Main> M.lookup "cBray" mp :: Maybe ()
10:03:59 <jamii> Nothing
10:04:00 <gwern> hm. not long enough
10:04:12 <drigz> i'm applying this to UK uni's, those being the only ones i know about the social scenes of
10:04:25 <gwern> er. mischan
10:04:38 <Toxaris> one of my class mates in "school between age 10 and 19" has taken university courses parallel to going to school
10:06:17 <Toxaris> I don't think he was more or less socially excluded because of that
10:06:37 <drigz> Toxaris: parallelising seems like it would be a very good compromise
10:06:49 <Toxaris> but it's not the same as going to uni full-time, of course
10:06:53 <SamB_XP> indeed
10:07:23 <drigz> Toxaris: also, a lot of people have to move to where they go to uni, meaning they have to find new friends or do without
10:08:31 <SamB_XP> thankfully the greater philadelphia area is chock full of so-called "universities"
10:08:48 <Toxaris> on the other hand, I have started uni with 19 as I'm supposed to do in Germany, and always was socially excluded because I'm a nerd and don't care about my stupid co-students. it did not help me in any way to stay two more years in school, learning not that much and being socially excluded because I'm a nerd etc.
10:09:19 <sw17ch> Toxaris, i was in a department full of nerds...
10:09:26 <sw17ch> myself included
10:09:28 <SamB_XP> hmm, I'm majoring in electrical engineering
10:09:31 <Toxaris> sw17ch: happy you!
10:09:49 <SamB_XP> all we have is nerds, and people who probably shouldn't be in this major
10:09:53 <SamB_XP> afaict
10:10:16 <drigz> SamB_XP: depends on your definition of nerd, i guess
10:10:19 <sw17ch> SamB_XP, the guys who were good were the ones who had been working on computers since well before college
10:10:29 <Toxaris> but its fine for me, I'm now doing my phd, and since stupid students don't do that, I have much more sensible colleagues whom I can care about
10:10:40 <sw17ch> i suppose i should mention that the two girls in the department were way better than the rest of us
10:10:54 <sw17ch> I've seen some pretty dumb PhD's
10:12:33 <SamB_XP> hmm, yeah, what is a nerd?
10:12:54 <sw17ch> someone who pursues academic things as opposed to oblong balls
10:13:23 <drigz> here, half the people studying engineering go and work in the city, and i guess the other half enjoy engineering enough to want to spend their life doing it
10:13:27 <MyCatVerbs> SamB_XP: a compliment, if you use it within my earshot.
10:13:33 <drigz> and that probably qualifies you as a nerd for many
10:14:04 <Elly> #haskell: the rapture of the nerds :)
10:17:05 <Shiruka> nerd = someone who does something not easily appreciated by the uninitiated that most people don't do
10:17:34 * ski wonders what jones- is up to .. feeding the whole source of GHC onto some unsuspecting chatters ?
10:17:35 <Toxaris> SamB_XP: interesting question. I have heart theories connecting nerdism with http://en.wikipedia.org/wiki/Asperger_syndrome
10:17:35 <lambdabot> Title: Asperger syndrome - Wikipedia, the free encyclopedia
10:17:39 <Philippa_> around here that'd be geek - nerd implies worse social skills, more obsession etc
10:17:48 <Philippa_> Toxaris: you're wrong. HTH HAND
10:17:58 <Philippa_> sorry, /they're/ wrong
10:18:13 <Toxaris> Philippa_: thanks. I tried to phrase it very weak.
10:18:29 <Toxaris> Philippa_: "HAND"?
10:18:35 <Philippa_> Have A Nice Day
10:18:53 <Toxaris> Philippa_: meaning? "don't ever say that again"?
10:19:05 <sw17ch> perhaps i've un-nerded a bit over the years...
10:19:10 <MyCatVerbs> Toxaris: meaning, insincerely, "Have A Nice Day".
10:19:14 <zachk> can i use ? marks in my identifiers for functions/variables in haskell
10:19:23 <Shiruka> HTH HAND = I'm sure this don't help any and I hope I ruined your day
10:19:24 <sw17ch> at least my boss perceives me as having social skills...
10:19:24 <vixey> zachk: operators
10:19:28 <MyCatVerbs> Toxaris: it's the traditional insincerity that's the main payload.
10:19:47 <ski> > let (!?*) = 42 in (!?*)
10:19:48 <lambdabot>  42
10:20:33 * Toxaris is confused
10:20:34 <SamB_XP> I aspire to have social skills one day
10:20:52 <Shiruka> social skills = social engineering skills?
10:21:05 <ski> obviously
10:21:43 <BONUS> is there a MaybeT
10:21:50 <BONUS> in the standard library? and if not, why not?
10:21:51 <vixey> No it the standard libraries
10:21:57 <vixey> you could use ErrorT
10:21:58 <Toxaris> BONUS: somehwere on the wiki there is one
10:22:00 <zachk> social skills=knowing how to become inebriated in a socially acceptable way
10:22:59 <dino-> BONUS: There are some additional monads like MaybeT here: http://haskell.org/haskellwiki/New_monads
10:23:00 <lambdabot> Title: New monads - HaskellWiki
10:23:04 <BONUS> if i want nondeterministic stateful computations that can fail, I'm assuming the stack to use is type X s a = StateT s (ListT (Either String)) a
10:23:05 <BONUS> ah
10:23:06 <BONUS> cool
10:23:22 <sw17ch> zachk, that's an incredible definition
10:23:24 <vixey> @faq can #haskell teach you social skills?
10:23:24 <lambdabot> The answer is: Yes! Haskell can do that.
10:24:10 <ski> @faq can #haskell make you unlearn social skills ?
10:24:11 <lambdabot> The answer is: Yes! Haskell can do that.
10:24:12 <vixey> BONUS: they say ListT is rubbish
10:24:15 <Shiruka> @faq can you define social skills as a monad in Haskell?
10:24:15 <lambdabot> The answer is: Yes! Haskell can do that.
10:24:19 <sw17ch> one of the main keys to un-nerding is to shed a lot of arrogance
10:24:31 <vixey> so.. unless you are dealing with a strict language maybe ListT is not good, I'm not sure
10:24:36 <zachk> sw17ch: are you being sarcastic or do you really love it :D
10:24:58 <Toxaris> maybe he cannot believe it?
10:25:07 <BONUS> hmm
10:25:09 <sw17ch> zachk, if you can get drunk, and not ruin your reputation, you're good
10:25:18 <sfultong> why would you want to shed arrogance?
10:25:19 <ski> vixey : i don't think strictness is relevant here .. just that `ListT' doesn't generally produce monads, because of ordering
10:25:24 <zachk> exactly, apply to all substances
10:25:33 <vixey> oh
10:25:35 <BONUS> but what would you use then?
10:25:59 <Shiruka> excess join flood..
10:26:09 <ski> BONUS : do you need multiple alternative solutions ? or just failing ?
10:26:33 <sw17ch> sfultong, well, if i'm making it plainly clear that i'm smarter than you, i'm bound to make you feel inferior/offended...
10:26:36 <BONUS> yeah multiple alternative solutions and failing
10:26:42 <sw17ch> so right away, you alienate people
10:26:48 <BONUS> so that an empty result list is not really a failure
10:26:49 <ski> BONUS : or, hm .. by "failing" you apparently meant exceptions
10:26:51 <BONUS> just an empty result list
10:26:52 <BONUS> yeah
10:26:53 <Philippa_> Toxaris: Shiruka's explanation ("I'm sure this don't help any and I hope I ruined your day") is more or less right, though "I hope I ruined your day" may or may not be stronger than the intention
10:27:04 <BONUS> either Either or Maybe is fine with me
10:27:27 <ski> @kind Either Either Maybe
10:27:28 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
10:27:47 <Toxaris> Philippa_: so you may be interested to hear that you succeeded, since i'm thinking now about whether I insulted you or not.
10:28:08 <Toxaris> Philippa_: not to mention that you totally suppressed discussion of the topic
10:28:44 <Toxaris> Philippa_: anyway, thanks for explaining the acronym.
10:28:58 <Philippa_> Toxaris: not massively insulted. As for suppression, counterarguments're possible - but the flat statement's effectively a warning to be a little careful
10:29:12 <ski> BONUS : so, to make this clear :
10:29:19 <ski> (a) you want to have the possibility of "failure" (`Maybe' or `Either x')
10:29:29 <BONUS> yeah
10:29:50 <Philippa_> a relevant datapoint (that I think you're aware of) is that I'm aspie - I do actually have a bit more of a right to authoritative statements and a lot of the nerd-linked-to-aspie stuff ducks a large pile of issues
10:29:55 <sfultong> sw17ch: If you make it plainly clear that you're smarter that me, I would hope to spend time around you and learn something.  If you make it clear that you think you're unquestionably smarter than me, then perhaps I'd be offended.
10:29:56 <ski> (b) *additionally* you want the possibility of multiple solutions. and you *either* get a single failure, or some number (possibly zero) of solutions
10:30:02 <BONUS> yup
10:30:04 <Toxaris> Philippa_: yeah I am
10:30:12 <BONUS> like a StateT s [] a
10:30:25 <ski> (c) also, you want to carry some state around .. and you want this state to be lost on failure and duplicated on multiple solutions
10:30:25 <BONUS> only it can like totally blow up
10:30:32 <ski> BONUS : is that right ?
10:30:39 <BONUS> yup
10:31:01 <Shiruka> it's ok to make it plainly clear that you're smarter, it's not so ok to make it plainly clear that you're more arrogant
10:31:40 <sw17ch> sfultong, the main reason i hang out in here is that the vast majority of the members *are* smarter than me, but unlike the Thunar mailing list, they don't mind helping me when i'm less than intelligent. :)
10:31:45 <Philippa_> or more generally to indicate that the other party is too stupid to have an opinion
10:31:47 <ski> BONUS : ok .. so the remaining question then is whether your `StateT s (ListT (Either String))' fails to be a monad, or not
10:31:50 <sfultong> well, one can be arrogant and humble... I don't see why it has to be XOR
10:31:58 <Philippa_> (now, there are opinions that some people don't know enough to reasonably hold...)
10:32:22 <BONUS> hmm
10:32:25 <Shiruka> being arrogant and humble about the same atomic thing sounds like a contradiction to me
10:32:28 <BONUS> i hope not!
10:32:29 <drigz> can we kickban jones- or something?
10:32:38 <vixey> drigz: ask in #freenode
10:32:42 <BONUS> is there anything especially un-monadic about ListT?
10:32:45 <Philippa_> vixey: we can from this chan
10:32:49 <ski> @get-shapr
10:32:50 <lambdabot> shapr!!
10:32:58 --- mode: ChanServ set +o Philippa_
10:33:20 <ski> well, apparently premature yelling :/
10:33:22 --- mode: Philippa_ set +b *!*@cs181102007.pp.htv.fi
10:33:38 --- mode: Philippa_ set -o Philippa_
10:33:48 <sfultong> Shiruka: about the same thing, yes.  I think arrogance becomes a problem when it bleeds from one topic to another
10:33:48 <drigz> i'm reading the /ignore help
10:33:52 <drigz> decided it would be easier
10:34:28 <Philippa_> arrogance in any topic is a problem. No such thing as justified arrogance, arrogance is the point where it stops /being/ justified
10:34:34 <Toxaris> Philippa_: well, my datapoint is less dramatic and, more importantly, less authorized by diagnosis. I'm just a nerd with no friends, who read about this assumed-by-some-people nerd-asperger connection, did one of these Internet-based do-it-yourself screening tests with the result "ask a doctor if you care", decided not to so, but feeling better nevertheless by knowing that there *may* be some pattern in me not having friends
10:34:40 * ski tries to recall the conditions for `ListT' to be well-behaved
10:34:58 <Shiruka> Philippa_: depends on the context, but I agree that generally avoiding being arrogant is a good strateg
10:35:06 <Philippa_> Toxaris: In most cases there's a pattern regardless of what it is
10:35:31 <Toxaris> Philippa_: so I feel justified in pointing out this possible connection which may be relevant to possible nerds maybe feeling bad, since it helped me to read about it
10:35:37 <sfultong> alright, now you've made me actually have to look up the definition of arrogance
10:35:52 <Toxaris> Philippa_: I'm totally aware that that's voodoo, but hey, if it helps
10:36:12 <Shiruka> arrogance, n. the quality of being a dick
10:36:17 <Philippa_> some of the voodoo ends up doing harm. I have /hell/ getting people to take some of the issues caused by being aspie seriously
10:36:34 <Philippa_> they just see the silly valley hype and the wave of self-diagnoses
10:38:13 <sfultong> mmm, all this talk is good here, but wasn't there once a rule about minimizing un-haskelly chat here?
10:38:54 <Philippa_> sfultong: give or take, and FCVO "un-haskelly"
10:39:01 <dcoutts> of course there's always, #haskell-blah which is strictly for un-haskelly chat :-)
10:39:02 <Philippa_> those values seem to've got wider lately
10:39:42 <drigz> sfultong: it was a quiet day til this conversation started, so i think it's a "if someone wants to talk about haskell they can politely ask everyone to move to -blah"
10:39:47 <Philippa_> <BONUS> is there anything especially un-monadic about ListT? <- I have a feeling that it's possible to end up with something that's not actually a monad with it
10:39:47 <sfultong> I like the idea of #haskell-blah, but every time I've been there it's been dead
10:39:50 <drigz> maybe that was a polite asking?
10:40:06 <Philippa_> sfultong: it's somewhere to lurk or raise something yourself - conversation's intermittent
10:41:04 <sfultong> drigz:  I guess... I don't really mind, but I'd like #haskell-blah to be more active
10:41:08 <ski> BONUS,Philippa_ : iirc, the problem was when `m' wasn't commutative .. then `ListT m' could fail being a monad
10:41:28 <drigz> Philippa_: surely that is kind of the opposite of the point of a random chat channel?
10:41:50 <ddarius> #haskell-blah is not something one should want to be continually active...
10:41:50 <Philippa_> drigz: I mean - that's what you do when it's quiet
10:41:55 <Toxaris> Philippa_: I think I see your point, but I'm not sure what to do about it. would it help if I modified my voodoo to "... a weak variant of asperger ..."?
10:42:20 <Philippa_> Toxaris: use a longer sentence, write the disclaimer out explicitly?
10:42:20 <sfultong> ddarius: please explain
10:42:29 <drigz> Philippa_: i think that since OT conversations tend to branch from on T conversations, there should be a 'moving' protocol
10:42:37 <drigz> but i don't actually mind :p
10:42:48 <ddarius> sfultong: Hang around #haskell-blah long enough and you'd understand.
10:43:00 <Philippa_> drigz: " -> -blah" or similar, generally
10:44:58 * Shiruka is waiting expectantly this metadiscussion to move on to metametadiscussion and then recurse until stack overflow
10:45:24 <Toxaris> Shiruka goes meta in a different dimension by talking about meta-ness
10:45:35 <drigz> Shiruka: we could probably optimise to tail recursion - we don't need to return to the conversation about social skills
10:45:41 <drigz> (in fact, it's probably for the best if we don't)
10:45:48 <sfultong> hehe, good point
10:45:55 <EvilTerran> ... which conversation was this?
10:45:59 <EvilTerran> i think it's gone off the top of my scrollback
10:46:02 <EvilTerran> :P
10:46:22 <Shiruka> your stack leaks from the bottom
10:47:18 <sfultong> ddarius: oh I dunno... I can be pretty obtuse :-P
10:48:10 <sfultong> have you ever worried about self-conscious stack overflow in your mind?  I have
10:48:26 <drigz> it was: conversation about haskell -> someone mentions a word like 'school' -> definitions of 'school', 'college' and 'university' across the world -> ages at which people go to university -> whether particularly young people should go to university -> social effects of their going to uni -> social effects of nerds going to uni -> social lifes of nerds -> social skills in general -> off topic conversations -> recursive conversations
10:48:32 <drigz> i believe
10:49:16 <Toxaris> was that a core dump?
10:49:21 <sfultong> hehe
10:49:27 <gwern> > 100 - 36
10:49:29 <lambdabot>  64
10:50:33 <nax> how does thread safety work with foreign functions? there doesn't seem to be a way to specify if foreign functions are thread safe or not.
10:50:50 <Shiruka> hm, the new monads look interesting :-O
10:52:13 <Shiruka> sfultong: I often worry about mental stack overflow.. the solution is to copy oldest parts of the stack to the heap (heap being paper, emacs buffer, or similar)
10:52:21 <geezusfreeek> what new monads?
10:53:11 <Toxaris> sfultong: as in: reflecting about how you reflect about how you reflect about ... you?
10:53:47 <Shiruka> geezusfreeek: http://haskell.org/haskellwiki/New_monads referred to here earlier
10:53:48 <lambdabot> Title: New monads - HaskellWiki
10:54:06 <sfultong> Shiruka: well, in my imagination, self-conscious stack overflow is in an unsafe language, so parts of my personality are overwritten
10:54:38 <Shiruka> don't worry, brain's RAID is pretty good
10:55:03 <Shiruka> at least for the important bits
10:55:23 <mmorrow> sfultong: the interesting part about that is that you wouldn't miss them, nor even know they ever existed
10:55:36 <sfultong> Toxaris: I think so, although I use the phrase "being aware" in place of "reflect"
10:56:04 <Shiruka> mmorrow: oh, but often you do know you forgot something
10:56:21 <mmorrow> Shiruka: i don't remember
10:56:27 <Shiruka> because you have a dangling reference, and the tombstone there is a dead giveaway
10:56:35 <sfultong> mmorrow: true... but I think it's in the same vein as the fear of death: it may be irrational, but it could serve a purpose
10:56:49 <Shiruka> "garbage collector was here"
10:59:06 <Toxaris> sfultong: I don't think there is a difference between "begin aware of being self-aware" and "being aware of being aware of being self-aware"
10:59:37 <mmorrow> Shiruka: i read this article (i believe in the nytimes, but it doesn't matter) about a man who had syphilus. the disease (an actual quote) "core two holes in his brain like apples", and he lost the ability to remember anything past the last 5 minutes...forever. so if he was somewhere more than 5 minutes he didn;t have the slightest clue how he got there. every 5 minutes the reporter had to introduce herself (himself?) again.
11:00:12 <mmorrow> he's one of two known cases of this ever happening
11:00:43 <gwern> > 3000 * (1/0.64)
11:00:44 <lambdabot>  4687.5
11:00:48 <gwern> syphilis is a strange disease
11:01:08 <Toxaris> sfultong: so I collapse all levels above "being self-aware" and don't need to fear about my stack. oh, and sometimes it's good to take a break; and start doing something else like cleaning the kitchen to become more world-aware again
11:01:17 <sfultong> Toxaris: why not?  and you could get rid of self-aware "being aware of being aware of being"
11:01:23 <gwern> > sqrt 46875
11:01:24 <lambdabot>  216.50635094610965
11:01:52 <mmorrow> the interesting thing was, that doctors would do experiments where they had him practice drawing stuff week after week. although he can't remember 6 minutes ago (so every time he drew he thought it was his first), he show clear improvement in his drawing skill
11:01:52 <Toxaris> sfultong: yeah, that would sound nicer :)
11:02:21 <gwern> > (216.5 * 0.64) + 216.5
11:02:23 <lambdabot>  355.06
11:02:36 <mmorrow> i took from that article that the brain is very much more that the part that contributes to consciousness
11:02:36 <Toxaris> sfultong: it's just my experience that there is no difference.
11:02:53 <gwern> this is so embarassing. I have forgotten how to solve for x in 'x + (x * 0.64) = 3000'
11:03:11 * gwern tries again
11:03:17 <vixey> x + x * 0.64 = 3000
11:03:19 <drigz> 1.64 * x = 3000 ?
11:03:21 <mmorrow> (clearly that article blew my mind)
11:03:23 <vixey> x  * 1+ x * 0.64 = 3000
11:03:31 <vixey> x * (0.64 + 1) = 3000
11:03:39 <vixey> x = 3000/1.64
11:03:54 <vixey> > let x = 3000/1.64 in x + (x * 0.64)
11:03:55 <lambdabot>  3000.0000000000005
11:03:57 <sfultong> gwern: I was wondering what you were doing.  I was thinking perhaps you were trying to subtly introduce more math into the channel and therefore reduce non-topical chat
11:04:11 <vixey> o_o
11:04:28 <Shiruka> > let x + (x * 0.64) = 3000 in x
11:04:28 <lambdabot>  Parse error in pattern at "in" (column 27)
11:04:31 <gwern> sfultong: actually, my reason for doing so is offtopic. I am calculating how many mccain shares on intrade you would need to buy to afford moving out of the US in the event of a mccain presidency
11:04:40 <Deewiant> > 3000/1.64
11:04:41 <lambdabot>  1829.268292682927
11:04:42 <Shiruka> \bot is not very good at maths! I have evidence
11:04:52 <sfultong> gwern: haha, that's great
11:05:13 <Heffalump> how much does moving outside the US cost?
11:05:14 <drigz> how would you solve x + x ^ 0.64 = 3000?
11:05:34 <gwern> Heffalump: I am assuming 3000 USD covers moving costs, visa etc. and living expenses until you find a job
11:05:43 <Heffalump> drigz: iteratively :-)
11:05:43 <drigz> is there an analytical way or would you need a numerical method?
11:05:48 <Heffalump> gwern: that sounds pretty optimistic
11:06:07 <Heffalump> perhaps if you moved to Canada
11:06:12 <gwern> Heffalump: eh. I just want to demonstrate that insurance via prediction markets may be too expensive to be feasible
11:06:34 <gwern> since I will point out that he will need to leave the 1000+ dollars invested in intrade for months
11:06:50 <gwern> (if we assume he sells out before the election, his returns are necessarily much lower)
11:07:36 <Shiruka> insurance against bad choice of president.. funny :-)
11:07:43 <Deewiant> drigz: Mathematica can't give a non-numerical answer, the best it can do is say it is a root of a polynomial (25th-degree with pretty big coefficients)
11:07:57 <Deewiant> ... which suggests to me that it probably can't be done :-)
11:08:00 <gwern> Shiruka: not at all. it's a perfectly reasonable idea, imo
11:08:08 <Deewiant> > let x = 2837.85 in x + x ^ 0.64
11:08:09 <lambdabot>  Add a type signature
11:08:10 <gwern> just not quite feasible
11:08:12 <Deewiant> > let x = 2837.85 in x + x ^ 0.64 :: CReal
11:08:13 <lambdabot>  Add a type signature
11:08:23 <Deewiant> > let x = 2837.85 in x + x ** 0.64
11:08:24 <lambdabot>  2999.9986134053397
11:08:35 <sw17ch> :t (^)
11:08:36 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:08:49 <dmwit> Deewiant: 25th degree shouldn't surprise you:
11:08:52 <dmwit> > 16 / 25
11:08:52 <lambdabot>  0.64
11:09:09 <Deewiant> what's the significance of 16
11:09:10 <Toxaris> gwern: I pay 460 USD a month for one-room student accomodation with shared kitchen in Denmark, just to give you some numbers :)
11:09:20 <dmwit> Deewiant: no significance, really
11:09:21 <Deewiant> I guess nothing
11:09:26 <Deewiant> yeah, silly question :-)
11:09:46 <dmwit> "not divisible by 5" is the significance ;-)
11:09:53 <Deewiant> :-)
11:09:54 <Toxaris> gwern: so I don't think you could go far with 3000 USD
11:10:13 <sw17ch> @index alloca
11:10:13 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
11:10:18 <Deewiant> > 0.64 :: Ratio Int
11:10:19 <lambdabot>  16%25
11:10:37 <easytige`> can you do something like `equal x y = (x == y == z)` ?
11:10:45 <gwern> Toxaris: this is obviously an american; 3000 seems on the low end for moving to canada or mexico, but doable
11:10:53 <vixey> no
11:10:54 <dmwit> easytige`: For Bool, sure.  But it's not what you want.
11:10:56 <Deewiant> easytige`: you can do (x == y && y == z)
11:11:04 <BONUS> but where is the z
11:11:12 <dmwit> BONUS: top-level binding ;-)
11:11:15 <easytige`> BONUS: typo
11:11:18 <BONUS> hehe
11:11:28 <easytige`> yea.. just wondering. i may make no sense
11:11:31 <dmwit> easytige`: You might also like:
11:11:34 <Deewiant> hm, can that be expressed as a neat fold
11:11:43 <dmwit> :t and . zipWith (==) . ap zip tail
11:11:47 <dmwit> oops
11:11:53 <dmwit> :t and . ap (zipWith (==)) tail
11:11:54 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:11:54 <Shiruka> easytige`: it makes sense but haskell doesn't do that
11:11:56 <ziman> :t ap zip tail
11:11:57 <lambdabot> forall b. [b] -> [(b, b)]
11:12:05 <Deewiant> hmm
11:12:18 <Deewiant> > (zipWith (==) <*> tail) [x,y,z]
11:12:19 <lambdabot>  [False,False]
11:12:33 <vixey> > let list [x,y,z] in foldr ((&&).(==head list)) True list
11:12:33 <lambdabot>  Parse error at "in" (column 18)
11:12:35 <easytige`> Just doing an exercise in a book. We havn't been told about Zip yet :)
11:12:42 <Shiruka> (some languages do, e.g. in python "a <= b < c == d < e <= f" is legal and does what you expect)
11:12:42 <vixey> > let list = [x,y,z] in foldr ((&&).(==head list)) True list
11:12:44 <lambdabot>  False
11:12:45 <Deewiant> > (zipWith (f) <*> tail) [a,b,c,d,e,x] :: [Expr]
11:12:46 <lambdabot>  [f a b,f b c,f c d,f d e,f e x]
11:13:05 <dmwit> Deewiant: pretty cute, huh?
11:13:26 <Deewiant> yeah, zip`ap`tail is the win :-)
11:13:32 <Deewiant> @quote aztec
11:13:32 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:13:38 <gwern> http://www.reddit.com/comments/6ul2q/man_bets_1000_the_large_hadron_collider_will/c04wnwl
11:13:39 <lambdabot> Title: quasiperiodic comments on Man bets $1000 the Large Hadron Collider will destroy  ..., http://tinyurl.com/6xk62o
11:13:39 <Deewiant> ^^
11:13:52 <dmwit> heh
11:14:05 <Shiruka> man wants publicity, news on 11 :-)
11:14:18 <drigz> > let solve f x dx = let fx = f x; df = f(x+dx) - f x in if abs fx<1e-6 then x else solve f (x-fx*dx/df) dx in solve (\x -> x + x**0.64 - 3000) 0 1e-6
11:14:20 <lambdabot>  2837.8513374397594
11:14:21 <Shiruka> *at :-<
11:14:36 <vixey> drigz++
11:14:45 <drigz> whooo!!!!
11:14:47 <drigz> @karma drigz
11:14:48 <lambdabot> You have a karma of 1
11:14:50 <drigz> yeah!
11:15:03 <vixey> I like that example
11:15:40 <newsham> drigz:  http://conal.net/blog/posts/beautiful-differentiation/
11:15:41 <lambdabot> Title: Conal Elliott  Beautiful differentiation
11:16:44 <lelf> > take 10 $ drop 10 $ iterate (\x -> 3000-x**0.64) 1
11:16:46 <lambdabot>  [2837.8513376781416,2837.8513376781607,2837.8513376781602,2837.8513376781602...
11:17:33 <vixey> > let mend f = iterate f 1 !! 100 in mend (\x -> 3000-x**0.64)
11:17:34 <lambdabot>  2837.8513376781602
11:17:36 <slowriot> Does anyone know of a good forum or newsgroup for low-level multicore programming?
11:17:55 <easytige`> #erlang?
11:18:12 <Shiruka> erlang is hardly low-level..
11:18:24 <easytige`> well what is low level?
11:18:29 <BONUS> graphics programming i recon
11:18:32 <sw17ch> how low level?
11:18:38 <dmwit> > let mend f = iterate f 1 !! 100 in mend (\x -> cos (pi * x / 2))
11:18:39 <lambdabot>  1.0
11:18:39 <easytige`> ahh. cuda and so on?
11:18:43 <sw17ch> like... 4 8-bit micros on an ASIC?
11:18:46 <dmwit> > let mend f = iterate f 1 !! 101 in mend (\x -> cos (pi * x / 2))
11:18:47 <lambdabot>  6.123031769111886e-17
11:18:47 <slowriot> I'm making my own locks in C#, and soon I want to try making some concurrent data structures. Tha's what I mean by low-level.
11:18:48 <BONUS> yeah
11:19:03 <sw17ch> oh dear
11:19:13 * sw17ch is an embedded software engineer...
11:19:30 <slowriot> okay, maybe not so low level
11:19:36 <sw17ch> :)
11:19:42 <slowriot> know of any good forums or newsgroups for that, though?
11:19:50 <BONUS> dunno bro
11:19:51 <dmwit> No matter how low you think your level is, there's engineers working at a lower level.
11:20:17 <dmwit> But really, unless you're writing your own operating system, you can't do much in the way of "creating your own locks".
11:20:19 <sw17ch> dmwit, yeah, i get a *compiler*... the board designers at work laugh at me
11:20:25 <dmwit> You just call the OS' lock functions.
11:20:27 <dmwit> that's it
11:20:46 <slowriot> dmwit: it's good to know how they work, though, isn't it?
11:20:49 <dmwit> sw17ch: =P
11:20:56 <dmwit> slowriot: Do you know how they work?
11:21:02 <slowriot> no
11:21:18 <sw17ch> doesn't a lock usually force a thread yield?
11:21:27 <sw17ch> and/or a temporary block each time the object is used?
11:21:32 <dmwit> slowriot: http://www.stanford.edu/class/cs140/ # lecture notes, programming assignments, etc.
11:21:33 <lambdabot> Title: CS 140 Operating Systems and Systems Programming
11:21:46 <sw17ch> and/or if you have an atomic operation instruction...
11:21:47 <Shiruka> ah, but the board designers already know how the low-level stuff works, physicists despise them for taking all the credit for trivial applications of their hard work
11:21:59 <slowriot> I know how to use them, I want to know how they're implemented.
11:22:23 <dmwit> slowriot: In CS140, I implemented an operating system.  The first assignment was synchronization stuff.
11:22:34 <dmwit> So you only have to make it through 1/4 of that course to know how to implement locks.
11:22:57 <dmwit> You don't even need the "recommended" book or to attend the actual physical lectures (I sure didn't).
11:23:05 * sw17ch would have loved to have gone to stanford 
11:23:11 <slowriot> okay. What if my lock performs poorly, how do I trouble shoot it? I have tried to minimize the amount of bus traffic.
11:23:34 <Shiruka> try to avoid locks
11:23:36 <slowriot> it works fine at first, but after awhile, it gets into an exteremly slow state. '
11:24:06 <newsham> some locks yield, some do not.
11:24:12 <newsham> some you can implement directly in userland without OS support
11:25:11 <newsham> slowriot: for stuff like that, you probably want an architecture group.  there's one on usenet whose name I dont exactly remember (comp.arch ?)
11:25:20 <newsham> thats hennessey and patterson type stuff
11:25:29 <Shiruka> if it slows down without the number of hammerers rising, then it sounds like a bug..
11:25:34 <dmwit> newsham: Even futex go to the OS to break ties, don't they?
11:25:56 <newsham> dmwit: you can implement spin locks in userland without OS support.
11:26:02 <newsham> since you just.. spin.
11:26:29 <newsham> but might not be so performant without os helping out :)
11:27:06 <dmwit> right
11:27:10 <slowriot> newsham: thanks
11:27:11 <dmwit> bit of a waste of CPU
11:28:04 <newsham> dmwit: unless you're on a smp/multicore system and its often the case that there's contention.
11:28:08 <Shiruka> even completely userland locks have a penalty, best to avoid locking at all if possible
11:28:30 <newsham> locks are hard to use and also have penalty.  avoiding is a great strategy :)
11:28:41 <newsham> (although avoiding can be hard too)
11:29:35 <newsham> but we're in #haskell, and we have great TVars and MVars so we dont talk about such things :)
11:30:06 <dmwit> hear hear!
11:30:17 * Shiruka thinks STM sounds like and interesting approach, though he hasn't used them yet
11:31:27 * sw17ch likes MVars
11:32:56 <Shiruka> there's the practical and the interesting, the intersection of which is very small
11:33:03 <Shiruka> but interesting is more interesting!
11:34:24 <Shiruka> (for some definitions of interesting, not necessarily the same at every point of use)
11:35:14 <sw17ch> FunPtr's do not live up to their name
11:35:55 <BONUS> haha
11:36:25 <Beelsebob> rofl
11:36:39 <Beelsebob> @quote sw17ch FunPtrs do not live up to their name
11:36:40 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
11:36:48 <Beelsebob> @quote+ sw17ch FunPtrs do not live up to their name
11:36:48 <lambdabot> No quotes for this person. Take a stress pill and think things over.
11:37:00 <vixey> remember
11:37:03 <Beelsebob> ah
11:37:11 <Beelsebob> @remember sw17ch FunPtrs do not live up to their name
11:37:11 <lambdabot> I will never forget.
11:37:16 <sw17ch> :)
11:40:57 <byte-> hello
11:41:02 <sw17ch> bonjour
11:41:30 <byte-> is there a quicker way to do "do{ x <- blah1; blah2; return x}" ?
11:41:44 <newsham> ?src (<<)
11:41:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:41:45 <byte-> i want to sequence two operations and return the first
11:41:55 <newsham> byte-: I think that's (<<) from the parsec lib
11:42:00 <newsham> (i think the parsec lib)
11:42:07 <ddarius> byte-: <*
11:42:14 <ddarius> :t (<*)
11:42:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:42:19 <newsham> ?hoogle (<*)
11:42:20 <drigz> @pl \x a b -> do { x <- a ; b ; return x }
11:42:20 <lambdabot> Control.Applicative.(<*) :: Applicative f => f a -> f b -> f a
11:42:20 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:42:20 <lambdabot> Control.Applicative.(<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:42:20 <lambdabot> (line 1, column 14):
11:42:22 <lambdabot> unexpected "{"
11:42:26 <newsham> hmm good to know
11:42:26 <lambdabot> expecting variable, "(", operator or end of input
11:42:31 <newsham> prob better terminology than (<<)
11:43:22 <EvilTerran> also might be better to use (*>) over (>>), particularly if large sections don't use (>>=) at all
11:43:35 <EvilTerran> because then you could generalise to an applicative :P
11:43:48 <newsham> my code is being more strict than it should be.  any ideas?  http://hpaste.org/9346
11:44:06 <newsham> in particular the:   (:) <$> recv s 1 <*> recvStuff s    line (I think)
11:44:09 <ddarius> newsham: Perform a coup
11:44:45 <byte-> sweet
11:44:47 <byte-> thanks guys
11:45:36 <ddarius> newsham: Why do you think it should be lazy at all?
11:45:41 <newsham> to test i did "nc -l 8001" and after connect typed "te\nst\in\g<eof>" and didnt get any output until the eof.
11:46:03 <newsham> ddarius: why cant it emit the first string as soon as its received?
11:46:28 <Shiruka> sometimes the use of infix operators evokes images of Perl..
11:46:37 <newsham> hmm.. and why am i using so many nested catches :)
11:46:41 * sw17ch loves nc
11:47:24 <ddarius> newsham: That line is equivalent to do x <- recv s 1; xs <- recvStuff s; return (x:xs).  It's not going to get to the "return" part until after it's finished all of recvStuff
11:47:45 <newsham> hrmm..
11:48:15 <newsham> how can i make it more lazy?
11:48:20 <ddarius> unsafeInterleaveIO
11:48:28 <newsham> eek!
11:48:28 <Shiruka> maybe Haskell is secretly the real Parrot -- the amalgamation of Perl and Python ;-)
11:48:54 <newsham> is bcpl the real C?
11:49:00 <thetallguy> wash your mouth out with soap
11:49:30 <mrd> SOAP? eww
11:49:37 <jpcooper> could anyone give a hint as to how to swap the elements of a pair, with arrows?
11:49:48 <ddarius> arr swap
11:49:52 <thetallguy> mrd: :-) yeah, just as bad
11:50:04 <jpcooper> ddarius, I thought I might have to construct my own thing
11:50:17 <jpcooper> @hoogle swap
11:50:17 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
11:50:17 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
11:50:27 <thetallguy> > fix (scanl (*) 2)
11:50:28 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
11:51:06 <ddarius> swap isn't predefined, but it's definition is obvious.
11:51:09 <thetallguy> >fix (scanl (+) 0.5)
11:51:20 <jpcooper> ddarius, sure, but can it be done with arrows alone?
11:51:22 <newsham> my code used to be:   recv >>= process >>= send    and I'm trying to convert it to   recvs >>= mapM_ (\x -> process x >>= send)
11:51:31 <jpcooper> I'm guessing not
11:51:33 <newsham> but unsafe* feels like a step backwards
11:51:45 <newsham> err.. the first one should have a forever $ ...   at the start
11:53:08 <ddarius> jpcooper: Your question doesn't make much sense.
11:53:37 <jpcooper> never mind
11:53:46 <pejo> Anyone happen to know if i can pipe the output from ghc into ghc-core immediately instead of using ghc-core as a wrapper?
11:53:56 <jpcooper> I thought there might be some cool routing thing which I could do
11:54:51 <ddarius> jpcooper: The "cool routing thing" that you could do would be equivalent via the arrow laws to arr swap
11:55:07 <ski> (.. `unsafeInterleaveIO' really should be renamed .. it seems to scare people from considering it)
11:55:17 <jpcooper> okay
11:55:20 <ddarius> ski: That's the intent of the name.
11:55:33 <ski> ddarius : but is it justified ?
11:55:46 <ddarius> ski: Yes.
11:55:51 <ski> why ?
11:57:13 <Shiruka> seems more unsafe than unsafePerformIO to me, with that the unsafe IO is at least explicit where it's done, with unsafeInterleaveIO there's magic unsafePerformIO in pure code
11:58:35 <Shiruka> (okay, maybe it's not so clear cut, but that's one viewpoint :-)
11:58:41 <ddarius> ski: If nothing else, it makes your code dependent on the particular evaluation order of the implementation and this clearly has noticable effects as plenty of people get bitten by unsafeInterleaveIO induced issues.
11:59:03 <ski> i haven't seen that `unsafeInterleaveIO' can be used to break the declarative semantics .. while `unsafePerformIO' can .. (even breaks type-preservation)
12:00:50 <ski> ddarius : ok. i don't agree that warrants the `unsafe' prefix, but i can respect the position, i suppose
12:01:17 <ddarius> It causes a lot more trouble that reallyUnsafePtrEq
12:01:42 <Shiruka> why is that one named reallyUnsafe instead of just unsafe, btw?
12:01:57 <Shiruka> I can't see how it's more unsafe than unsafePerformIO..
12:02:15 <ski> Shiruka : just a guess .. possibly it can behave differently wrt boxed and unboxed things
12:02:21 <ddarius> Shiruka: The creator of it was nuttier than most Haskellers.
12:02:31 * sw17ch grumbles more about FunPtr's...
12:02:34 <ddarius> That's (a paraphrase of) what I heard.
12:02:35 <Shiruka> ddarius: :-D
12:02:43 * sw17ch tries to avoid castPtr then gives up[
12:02:52 <ddarius> reallyUnsafePtrEq probably doesn't do what you expect most of the time.
12:02:54 <ski> ddarius : i'd assume that's because `reallyUnsafePtrEq' is less called for ..
12:04:36 <ahunter2> Hey, anyone else just do Google Code Jam with Haskell?  Looking for interesting solutions, to improve my Haskelling :P
12:04:47 <sw17ch> up till now, i'd never had a monomorphism restriction... have i arrived?
12:04:53 <sw17ch> (in other words, just had one)
12:04:57 <Shiruka> ddarius: funny that it's completely undocumented, usually one would expect counterintuitive behavior to be the most documented
12:05:22 <Shiruka> instead of just sticking a mystifying reallyCounterIntuitiveISwear prefix on it :-P
12:05:51 <ski> Shiruka : Security Through Obscurity [tm] .. they expect you to not use it, by not documenting it
12:06:18 <ddarius> Shiruka: To accurately document it would require keeping a comment inline with many implementation decisions of GHC.
12:06:25 <ddarius> And would still be about useless.
12:06:30 <ski> (or they might just feel it's not standard/stable enough to document it (yet), or they maybe haven't had time yet .. take your pick)
12:06:39 <ejt> Word32 etc are unsigned, is there a signed version anywhere ?
12:06:58 <ski> Int32
12:07:20 <ejt> doh, thanks
12:07:25 <sw17ch> @indes maybeWith
12:07:25 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
12:07:35 <sw17ch> @index == @indes... odd
12:07:36 <lambdabot> bzzt
12:07:56 <ski> lambdabot has dwim
12:10:20 <newsham> using unsafeInterleaveIO, seems to work -- http://hpaste.org/9346#a1
12:10:25 <newsham> can it be more elegant?
12:12:58 * sw17ch used castPtrToFunPtr... he feels dirty
12:13:21 <newsham> i think i'll just avoid this solution and make something tha returns Maybe x   for reading x or eof
12:13:59 <jpcooper> could anyone link me to some guidelines on how to split statements into multiple lines? I have a rather slim screen.
12:14:26 <Stinger> let? :)
12:14:34 <sebaseba> where?
12:14:36 <jpcooper> aah, but then I can't look cool
12:14:58 <jpcooper> I guess it will have to be so, though
12:15:02 <Stinger> I have problems like that, where my lines end up 160 characters long cause I'm trying to be too clever (and probably failing)
12:16:41 <ddarius> newsham: Look at Oleg's left fold enumerators and/or the CC-delcont stuff
12:17:09 <ddarius> jpcooper: Ever program Lisp/Scheme?
12:17:19 <jpcooper> I do it for work :)
12:17:38 * ski usually keeps lines under eighty characters, and tries to be under seventy-two
12:17:54 <ddarius> jpcooper: Then use the same rules as you would use for large Lisp expressions.
12:18:02 <jpcooper> ski, you try using a 14.1 inch screen :p
12:18:15 <jpcooper> sure
12:18:25 <jpcooper> I split them on to multiple lines
12:18:37 * ddarius uses a laptop and usually tries to keep lines under the width of the screen.
12:18:38 * ski is not sure how much 14.1 inches is
12:18:42 <nax> DontUseMassiveMonsterLongNames
12:19:01 <vixey> do use long names
12:19:05 <ski> call-with-current-continuation !
12:19:15 <Zao> let f x y z x' y' z' = ...
12:19:32 <ddarius> let f x x' x'' x''' x'''' = ...
12:20:35 <Zao> :t \s a -> \i j k l -> runReaderT (a i j k l) s
12:20:36 <lambdabot> forall t t1 t2 t3 r (m :: * -> *) a. r -> (t -> t1 -> t2 -> t3 -> ReaderT r m a) -> t -> t1 -> t2 -> t3 -> m a
12:20:42 <ski> jpcooper : are you running X or not ? how many characters can you fit in the width of that screen, using your fixed-width font of choice ?
12:20:49 <newsham> ddarius: where would I find those?
12:20:58 <Zao> I went with the more readable following instead: flip (flip . ((flip . ((flip . ((flip . (runReaderT .)) .)) .)) .))
12:21:15 <jpcooper> ski, I don't know. I'll just use lets
12:21:59 <vixey> Zao, why not use (,,)'s ?
12:22:11 <vixey> infact (,,,)
12:22:18 <ddarius> @google oleg left fold enumerator
12:22:19 <lambdabot> http://okmij.org/ftp/Haskell/fold-stream.lhs
12:22:30 <ddarius> @hackage cc-delcont
12:22:30 <newsham> whoa, google
12:22:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cc-delcont
12:23:06 <ddarius> @hackage CC-delcont
12:23:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont
12:23:15 <newsham> danke.  gotta run.
12:29:41 <Zao> vixey: Because I didn't know about it, nor know how to use it, nor had any useful way to coax any out of lambdabot :)
12:30:52 <sw17ch> is there a peekptr?
12:31:42 <glguy> There is a peek
12:32:34 <glguy> :t Foreign.peek
12:32:34 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
12:33:26 * sw17ch wonders how he misses these things
12:35:01 <ski> you might try reading the FFI addenda
12:35:14 <ddarius> You should have already read the FFI addenda
12:35:34 <nax> what about specifying if foreign functions are thread safe?
12:36:14 <sw17ch> ddarius, yeah, what happend was i had typed peke
12:36:28 <sw17ch> and i was just confirming my hunch
12:38:05 * sw17ch is 76% through portaudio.h
12:38:50 <ilyak_> Wow, it's actually possible to use non-latin characters with ghc
12:44:11 <ilyak_> I mean, in names.
12:45:21 <ski> emma : learning haskell now ? or just visiting ?
12:45:44 <gwern> dum de dum dum. almost done cleaning up GeomAlgLib
12:46:00 <gwern> how nice to find that the author did the hard work of updating it, even if the cabalization is bad
12:47:30 <mmorrow> sw17ch: speaking of funptr fun: http://code.haskell.org/~morrow/code/haskell/misc/Call.html   (also, some useful comments at the end pasted from the docs)
12:50:09 <mmorrow> i can stop being amused that this is x86 helloword as a :: [Word8]
12:50:12 <mmorrow> > [232,14,0,0,0,72,101,108,108,111,44,32,119,111,114,108,100,33,10,186,14,0,0,0,89,187,1,0,0,0,184,4,0,0,0,205,128,49,192,195]
12:50:17 <lambdabot>  [232,14,0,0,0,72,101,108,108,111,44,32,119,111,114,108,100,33,10,186,14,0,0,...
12:50:38 <mmorrow> heh, i mean't *can't*
12:59:45 <pejo> Is there a standard environment variable that (might) point out the ghc executable to use?
13:00:07 <Baughn> @src groupBy
13:00:07 <lambdabot> groupBy _  []       =  []
13:00:07 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:00:07 <lambdabot>     where (ys,zs) = span (eq x) xs
13:00:13 <Baughn> pejo: /usr/bin/env runghc
13:00:27 <Baughn> Or some such
13:00:41 <Baughn> pejo: In practice, the ghc "executable" is a script that sets those variables.
13:01:30 <pejo> Baughn, yes, I wanted to point out a different script though, without messing with my PATH.
13:01:51 <Baughn> pejo: So pass a full path?
13:01:53 <gwern> @tell dons I've finished improving GeomAlgLib to Hackage standards. I'm just blocked on the author replying now
13:01:53 <lambdabot> Consider it noted.
13:02:27 <Baughn> pejo: Let's start over. *Why* do you want to do this?
13:03:47 <Baughn> @src words
13:03:48 <lambdabot> words s = case dropWhile isSpace s of
13:03:48 <lambdabot>     "" -> []
13:03:48 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:05:22 <pejo> Baughn, if there was such a variable I could just type ghc-core test.hs.
13:05:50 <Baughn> pejo: Well, what's wrong with ghc test.hs?
13:07:26 <pejo> Baughn, that won't execute ghc-core. I get the point, there isn't any standard environment variable readily available.
13:08:48 <Baughn> pejo: Well, except for PATH, yes.
13:09:21 <Baughn> You could of course write a script that looked for a variable, prepended it to the path and /then/ ran ghc
13:09:40 <Shiruka> export GHC_PATH=`which ghc`
13:10:54 <Shiruka> or hm, did you want to change the ghc used by something instead of finding where ghc is..?
13:11:53 <pejo> Shiruka, yes.
13:12:23 <Shiruka> ghc-core apparently has option --with-ghc
13:12:28 <Shiruka>              --with-ghc=PROGRAM  Ghc executable to use.
13:21:11 <mmorrow> pejo: maybe this helps somehow? to find my package.conf i do:
13:21:21 <mmorrow> ls -l `eval 'dirname \`which ghc\`'`/../lib/ghc-`ghc -V | tr ' ' '\n' | tac | head -1`/package.conf
13:21:25 <mmorrow> (hehe)
13:22:55 <easytige`> im following a haskell book and its started using `ord`, however hugs doesnt have ord.. do i need to include something
13:23:17 <mmorrow> > map ord ['a'..'z']
13:23:20 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
13:23:28 <mmorrow> > map chr [0..]
13:23:29 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
13:23:35 <mmorrow> > map chr [97..]
13:23:35 <allbery_b> @index ord
13:23:35 <lambdabot> Data.Char
13:23:36 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
13:23:37 <dmwit> mmorrow: "tr ' ' '\n' | tac | head -1" -> "ghc -e 'interact . last . words'"
13:23:50 <allbery_b> in H98 mode that's Char
13:23:52 <dmwit> err
13:23:56 * easytige` confused
13:23:56 <dmwit> interact $ last . words
13:24:04 <mmorrow> dmwit: ah, you are sly like a night fox!
13:24:15 <dmwit> easytige`: import Data.Char
13:24:21 <dmwit> oh
13:24:22 <dmwit> hugs
13:24:28 <dmwit> easytige`: import Char
13:24:38 <mmorrow> i totally have to use ghc -e " ... " more
13:24:39 <dmwit> The syntax might me
13:24:43 <dmwit> :m + Char
13:24:49 <Shiruka> (O_O; \SOH, \STX, \ETX, \EOT, \ENQ, \ACK.. those are more obfuscatory than the numeric values would be :-P
13:24:51 <RayNbow> :l Char
13:24:53 <RayNbow> in Hugs
13:25:07 <RayNbow> it doesn't automatically load the module when you use :m
13:25:31 <easytige`> thanks guys
13:25:38 <RayNbow> btw, loading Data.Char also works in Hugs
13:27:47 <Baughn> Shiruka: True. It doesn't seem right to have control characters in the /charset/ anymore, does it?
13:29:30 <Shiruka> well, \NUL and \a\b\t\n\v\f\r at least are fairly common (although I prefer \0 for \NUL anyway, \NUL makes about as much sense to me as \ZERO, \ONE, \TWO, \THREE, etc. would)
13:29:48 <allbery_b> RayNBow: only in extended mode; Haskell98 mode doesn't allow hierarchical packages
13:29:56 <allbery_b> and last I checked Hugs defaulted to H98
13:30:08 <Baughn> \0 is out-of-band data denoting "end of string", in.. some formats. It doesn't belong in the charset either
13:30:32 <Baughn> \a is at least sort of printable, and \n is fine. \r and \b annoy me.
13:30:45 <RayNbow> allbery_b: I'm using -- Hugs Version 20051031
13:30:47 <Shiruka> charset is a compromise anyway
13:31:07 <Baughn> Sure, but it's a thirty year old compromise that doesn't fit very well anymore. :/
13:31:14 <RayNbow> oh wait... that's the command line version...
13:31:18 <allbery_b> it's a flag (-98 / +98)
13:31:26 <RayNbow> the GUI version I have is Sep 2006
13:31:27 <Shiruka> well, in unicode you have stuff like compositing characters etc. too
13:31:42 <Shiruka> which are sort of instructions instead of plain data points
13:31:54 <dmwit> Yes, but the committee agrees they were mostly a mistake.
13:32:13 <dmwit> They were trying to fit Unicode into a too-small byte size at the time.
13:32:24 <RayNbow> allbery_b: in both modes :l Data.Char works
13:32:37 <allbery_b> huh.  technically that's a bug
13:32:55 <allbery_b> (the module name Data.Char is not legal in H98)
13:33:13 <Baughn> Shiruka: The metric I'm using is "does this make sense in a text editor?".
13:33:38 <Shiruka> fair enough :-)
13:33:45 <Baughn> Compositing characters is weird, but it does /make sense/. \b or \r? Just silly. \0? That's what end-of-file exceptions are for.
13:33:45 <mmorrow> > mapM_ putChar (fix ('\a':))
13:33:47 <lambdabot>  <IO ()>
13:34:00 <Shiruka> text editor's a compromise too, but at least it's a bit more tangible than a character set in the abstract
13:35:18 <Shiruka> \t should also die
13:35:49 <Baughn> I'd like to see a charset where \0 denotes a printable character become popular. It'd get rid of C, if nothing else. :D
13:36:09 <Zao> Baughn: \0 could be some form of whitespace.
13:36:14 <Zao> Zero-width, maybe :)
13:36:27 <Baughn> Zao: Nah. I figure it should be A
13:36:46 <Baughn> Make it easy to sort strings. ;)
13:36:52 <Shiruka> having a character for denoting end of stream is not all that nonsensical
13:37:02 <Shiruka> it's common enough in data compression for instance
13:37:04 <Baughn> Putting it in the charset /is/
13:37:07 <Shiruka> to know when to stop decoding
13:37:51 <Baughn> So you can use an escape character. Unicode has 0xffff reserved for exactly that purpose - it's not valid, so using that as escape means you don't use any extra space
13:37:54 <Baughn> Or prepend the length
13:38:01 <allbery_b> Apple BASIC's CHR$(0) was a printing character...
13:38:06 <Baughn> But don't break the layering, please. ;_;
13:38:09 <mmorrow> i think there should be more chars that make a terrible screeching noise
13:38:18 <mmorrow> like '\a' for instance
13:38:32 <Baughn> Make 128 output "I can't do that, Dave"?
13:38:42 <Shiruka> yes, we really need a character for Windows start-up sound
13:39:01 <dmwit> We need a character that flashes the screen.
13:39:02 <mmorrow> haha, yeah. and some chars output evil robot oneliners
13:39:03 <Shiruka> it would produce the Ubuntu start-up sound on Ubuntu, of course.. and similarly for all other OS's
13:39:12 <dmwit> And one that turns the numlock on and off for a bit.
13:39:23 <mmorrow> i want one that makes me a smmich
13:39:48 <Shiruka> and one character could have undefined behavior
13:39:59 <Shiruka> we could launch nethack when we find it in the data stream
13:40:00 <dmwit> Shiruka: That's damn near all of them.
13:42:07 <mmorrow> does anyone know the preflex darcs repo url off hand?
13:42:18 <mmorrow> preflex: darcs
13:42:26 <dmwit> mmorrow: doesn't exist
13:42:26 <mmorrow> @seen preflex
13:42:26 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:42:45 <dmwit> mauke never made anything public, as far as I know
13:42:56 <mmorrow> dmwit: hmm, what was mauke's website url again...mauke.ath.cx?
13:43:04 <dmwit> sounds familiar
13:44:04 <mmorrow> dang i think it's down
13:44:22 <dmwit> Looking for a bot to hack on?
13:44:24 <mmorrow> i need a bot...
13:44:43 <mmorrow> yeah, i want one that can in particular eval code
13:44:53 <mmorrow> (err, so i guess that's just lambdabot)
13:45:26 <dmwit> Maybe ask gwern if he's got mubot+mueval going?
13:45:38 <dmwit> You could also ask somebody to tell \bot to join whatever channel you want it on.
13:45:50 <mmorrow> that'd be handy if somehow the print/put_ functions were redefined so they're safe and also print what they should
13:46:12 <dmwit> Use show/var instead.
13:46:18 <mmorrow> so then you could print unicode (assuming System.IO.UTF8)
13:46:25 <dmwit> oh
13:46:33 <Baughn> mmorrow: You want a \bot? Where?
13:46:35 <dmwit> That's a totally separate issue, I think.
13:46:57 <mmorrow> (i also wanna to be able to eval code w/ TH syntax in-channel)
13:47:25 <mmorrow> yeah, gwern said it's not quite ready
13:48:37 * mmorrow gets lambdabot
13:49:27 <yaru1022> hi
13:49:33 <Twey> Hullo
13:50:16 <yaru1022> is there apt-like program for haskell? package manager that downloads source code and installs pacakages automatically?
13:50:22 <Zao> yaru1022: cabal-install
13:50:47 <mmorrow> Baughn: oh, thanks but i want one to be the first member of my havok-wreaking soon-to-be robot legion :)
13:50:57 <yaru1022> Zao, thanks. I'll read up on it.
13:51:24 <Shiruka> but cabal will only install cabal-approved packages ;-)
13:51:56 <mmorrow> Baughn: oh, wait...i seem to recall you had a hand in lambdabot?
13:52:06 <Baughn> Shiruka: Well, it'll also handiliy configure, build, download dependencies and install anything you've got a local .cabal file for?
13:52:33 <Baughn> mmorrow: Only recently. No, I was asking if you wanted Cheiron to join your channel - that's a \bot
13:53:16 <Shiruka> Baughn: that's almost like saying there's no cabal
13:53:16 <mmorrow> Baughn: oh cool. did you write Cheiron? is it an lb fork?
13:53:40 <yitz> Shiruka: well, apt also only installs programs that are appropriate and, er, apt.
13:53:51 <Shiruka> haha
13:53:53 <Baughn> mmorrow: It's a lb I'm using for development of lb. Not really fork; I'm rewriting seen, lately.
13:53:53 <mmorrow> Baughn: (in particular i want to acquire a bot in order to hack on the haskell that it evals)
13:54:08 <yitz> hi Twey
13:54:31 <dibblego> @type Prelude.(.)
13:54:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:54:42 <dibblego> how do I get lambdabot to show the normal signature?
13:54:46 <Baughn> mmorrow: It'll work precisely like lambdabot, for the most part. If you want it, I'll give you admin privileges on it; if not, or you want to actually edit the code, get your own. :P
13:54:50 <vixey> :t Prelude..
13:54:52 <Twey> Hello, yitz
13:54:58 <Baughn> @type (Prelude..)
13:54:58 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:55:03 <dibblego> ah cheers
13:55:10 <dibblego> @type flip (Prelude..)
13:55:11 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
13:55:24 <Baughn> mmorrow: (Well, except cheiron isn't memory or cpu-limited like lb is)
13:55:32 <vixey> :t .
13:55:36 <mmorrow> Baughn: yeah, i wanna actually get my own. should i get Cheiron instead of lb?
13:55:47 <Baughn> mmorrow: No. Get lb.
13:55:55 <mmorrow> Baughn: ah, ok.
13:56:19 <Baughn> Unless you /really/ want to deal with upgrading sqlite databases every few versions.. ;)
13:57:05 <mmorrow> sounds like candycanes and fluffy white clouds #!
13:57:16 <Baughn> @type (.)
13:57:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:57:34 <Baughn> > (+1) . [1..5]
13:57:35 <lambdabot>  [2,3,4,5,6]
13:57:39 * Baughn groans
13:58:04 <vixey> > Just "foo" ++ Just "bar"
13:58:05 <lambdabot>  Just "foobar"
13:58:41 <Baughn> ++ being concatenation-in-general is reasonable enough
13:58:59 <ziman> > (
13:58:59 <lambdabot> Unbalanced parentheses
13:59:06 <Baughn> But . being functor application? It's /supposed/ to be /function/ /composition/!
13:59:16 <ziman> > ("bar" ++) . Just "foo"
13:59:17 <lambdabot>  Just "barfoo"
13:59:39 <vixey> functor map
13:59:48 <Heffalump> Baughn: blame Cale
14:00:01 <Baughn> Heffalump: Don't worry, I always do
14:00:07 * Heffalump too :-)
14:00:12 <Cale> Baughn: function composition is an instance of functor application :)
14:00:36 <Baughn> Cale: <$> exists, and there's something to be said for not using `dwim` all the time. ;_;
14:01:13 * Baughn imagines class DWIM, with instances for just about every pair of types in existence
14:01:22 <Heffalump> :-)
14:01:25 <Cale> One of the things that convinced me this is a nice thing is that one of the laws that functors have to satisfy is that  fmap (f . g) x = fmap f (fmap g x)
14:01:45 <Cale> Note that rewriting that using (.) for fmap gives:  (f . g) . x = f . (g . x)
14:02:35 <Baughn> It makes type errors harder to read, though. Worse, sometimes it removes them
14:02:45 <rwbarton> Cale: maybe it's better to think of x as a functor * -> C, and of functor application as a special case of functor composition
14:02:52 <vixey> :t 7 . ""
14:02:56 <lambdabot> forall b. (Num (Char -> b)) => [b]
14:02:57 <Cale> So the operation remains associative. Note also that one can always determine the functor in question by the type of the last thing in the chain of (.)'s.
14:03:10 <Heffalump> if said thing isn't overloaded
14:03:10 <Baughn> I think function types are sufficiently common in haskell that having a dedicated function-only specialization of <$> makes sense. ;)
14:03:36 <Cale> Heffalump: well, yes, if it's overloaded, then you get an overloaded result.
14:04:04 <Cale> But it's not *so* often that you have non-contrived cases like that.
14:04:27 <Heffalump> since the last time I complained about this, I've actually observed people getting confused by it
14:05:05 <Baughn> The mathematical meaning of . is defined to be the one in the prelude, too
14:05:13 <Cale> Heffalump: Were functors promptly explained to these people?
14:05:21 <Baughn> > ((+2) Prelude.. (+3)) 5
14:05:22 <lambdabot>   Not in scope: `Prelude..'
14:05:31 <Baughn> > ((+2) (Prelude..) (+3)) 5
14:05:32 <Heffalump> I can't remember. I doubt they were relevant to what they were doing..
14:05:32 <lambdabot>   Not in scope: `Prelude..'
14:05:37 <Baughn> > ((+2) .. (+3)) 5
14:05:37 <lambdabot>  Parse error at ".." (column 7)
14:05:41 <Baughn> > ((+2) P.. (+3)) 5
14:05:42 <lambdabot>  10
14:05:55 <Cale> > ((+2) . (+3)) 5
14:05:56 <lambdabot>  10
14:05:56 <Heffalump> the fact that function composition happens to be one instance of fmap is completely irrelevant if you just want to do stuff with functions
14:06:14 <yitz> I'll be even more argumentative - I think that while the monad instance for (->) is a cute hack, in real life programming it really gets in the way.
14:06:25 <Cale> yitz: oh?
14:06:29 <Cale> yitz: How so?
14:06:30 <mmorrow> yits: hmm
14:06:35 <Heffalump> error messages again, I'd guess
14:06:49 <Cale> It's not like the error messages are that bad.
14:06:49 <Heffalump> and I'm somewhat inclined to agree - it can cause some quite odd ones
14:06:54 <vixey> it's ((->)e)
14:07:01 <Baughn> Error messages, yep. I've seen some completely inexplicable ones
14:07:12 <Cale> Like what?
14:07:15 <Baughn> I end up having to tag everything with explicit types just to figure out where it's going wrong
14:07:26 <Baughn> ..not today, though
14:07:30 <RayNbow> > sequence [even,odd] 3
14:07:31 <lambdabot>  [False,True]
14:08:48 <mmorrow> > (`id`3) `fmap` [even,odd]
14:08:49 <lambdabot>  [False,True]
14:09:16 <mmorrow> > ($ 3) `fmap` [even,odd]
14:09:17 <lambdabot>  [False,True]
14:09:23 <vixey> > ($ 3) . [even,odd]
14:09:24 <lambdabot>  [False,True]
14:09:30 <mmorrow> heh
14:09:58 <Baughn> > 3 . [even,odd]
14:09:58 <lambdabot>        add an instance declaration for (Num ((a -> Bool) -> b))
14:10:01 <RayNbow> > (+3) . [1,2,3]
14:10:03 <lambdabot>  [4,5,6]
14:10:11 <Baughn> Hm. Missing an instance.
14:10:17 <ahunter3> > zip <*> tail [1,2,3,45]
14:10:17 <lambdabot>  Couldn't match expected type `[a] -> [b]'
14:10:18 <yitz> Cale: just like defining (.) as fmap - it obscures the meaning of programs, making debugging harder. And even making refactoring harder, losing whatever advantage you gained by the generality.
14:10:20 <RayNbow> @src fmap
14:10:20 <lambdabot> Source not found. There are some things that I just don't know.
14:10:21 <vixey> > 3 + "fish"
14:10:22 <lambdabot>   add an instance declaration for (Num [Char])
14:10:25 <vixey> Baughn, ^
14:10:28 <ahunter3> > zip <*> tail $ [1,2,3,4,5]
14:10:29 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
14:10:35 <RayNbow> @src (.)
14:10:35 <lambdabot> (f . g) x = f (g x)
14:10:35 <lambdabot> -- In lambdabot, it's been generalised to:
14:10:35 <lambdabot> (.) = fmap
14:10:39 <Heffalump> > length 5
14:10:39 <ahunter3> Can someone help explain to me why that works?  I'm still fuzzy on applicative
14:10:40 <lambdabot>   add an instance declaration for (Num [a])
14:10:49 <Baughn> vixey: Yes, that should be 7
14:10:56 <vixey> :t zip <*> tail
14:10:57 <lambdabot> forall b. [b] -> [(b, b)]
14:11:09 <vixey> @src (<*>)
14:11:10 <lambdabot> Source not found. That's something I cannot allow to happen.
14:11:32 <dibblego> I have a noob confused by the fact that I had to qualify with Prelude..
14:12:11 <rwbarton> > length . words "this is a test"
14:12:12 <lambdabot>  [4,2,1,4]
14:12:51 <Heffalump> ahunter3: I guess it ends up in the reader monad
14:13:12 <Cale> Guest76199: can you explain why?
14:13:19 <Heffalump> the list becomes the thing that's passed in to the reader
14:13:33 <Heffalump> tail takes one argument from the reader
14:13:40 <ddarius> Heffalump: Yes.
14:13:46 <Heffalump> zip takes two arguments; the first comes from tail, and the second from the reader
14:13:50 * Baughn feels that the current (.) is mashing everything together, a bit like http://lh4.google.ca/abramsv/R7OtoaoD1mI/AAAAAAAAIXU/YsjMLENhilA/s1600-h/1001.jpg
14:13:53 <ddarius> (<*>) = ap = S in the reader monad
14:14:01 <lambdabot> Title: 1001.jpg (image), http://tinyurl.com/6gvmvg
14:14:31 <Heffalump> oh, except my explanation would produce the pairs the other way round
14:14:55 <ahunter3> Heffalump: also: wtf, how did we get Reader out of there?  Seems a bit magic...
14:15:09 <Heffalump> ahunter3: Reader is just (e ->)
14:15:25 <Heffalump> so if you have a monad/applicative instance for that then it just happens
14:16:23 <ahunter3> ic
14:16:25 <Heffalump> @type <$>
14:16:25 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:16:26 <rwbarton> f <*> g is supposed to be some kind of "lifted" application of f to g; in the ((->) e) case it's \x -> (f x) (g x)
14:16:26 <yitz> Sorry Cale, just switched computers
14:16:34 <Heffalump> :t <$>
14:16:44 <Cale> yitz: ah
14:16:55 <Heffalump> well, anyway, its got type m (a -> b) -> m a -> m b
14:16:59 <Cale> yitz: anyway, I haven't experienced any of those problems using (.) as fmap
14:17:11 <Cale> yitz: Could you explain what causes them?
14:17:13 <Heffalump> so if m x = e -> x, then it ends up as (e -> a -> b) -> (e -> a) -> (e -> b)
14:17:14 <RayNbow> > liftM2 (*) succ (*3)   $   5
14:17:15 <lambdabot>  90
14:17:37 <RayNbow> > liftA2 (*) succ (*3)   $   5
14:17:38 <lambdabot>  90
14:17:41 <RayNbow> wow, magic... :p
14:18:31 <ahunter3> Heffalump: at some poitn are we using the Monad or Applicative instance for [t]?
14:18:37 <Heffalump> ahunter3: no
14:18:43 <Heffalump> just the one for (e ->)
14:18:59 <Cale> yitz: For example, a nice case is applying functions to the results of IO actions. It's nice to be able to write things like  ls <- lines . readFile f
14:19:15 <Cale> Rather than using fmap or liftM
14:19:37 <ahunter3> dumb Q: don't suppsoe there's some magic way to get GHC to dump what instances it inferred for various typeclass uses?
14:19:42 <dibblego> . is so much nicer than fmap
14:20:15 <yitz> well, for example, the average person has to apply some real mental energy to first understand what zip `ap` tail, join, etc. mean. Once you get used to it it's not bad but it adds to the barrier to entry for understanding your program. As such, it will lead to confusion and errors. otoh, the same program written in the straightforward way is ovious to all.
14:20:20 <Heffalump> Cale: that code makes no sense to me
14:20:31 <rwbarton> Cale: that code is really misleading
14:20:34 <Cale> Heffalump: Which code?
14:20:40 <Baughn> @type zip `ap` tail
14:20:41 <lambdabot> forall b. [b] -> [(b, b)]
14:20:46 <Cale> ls <- lines . readFile f ?
14:20:55 <yitz> s/ovious/obvious/
14:21:10 <Baughn> > zip `ap` tail $ [1..4] -- Normal person here
14:21:11 <Cale> It's clear what functor is in use here.
14:21:11 <lambdabot>  [(1,2),(2,3),(3,4)]
14:21:16 <rwbarton> Cale: because in a strict, non-monad-using language you might write (lines . readFile) f
14:21:27 <Baughn> @type ap
14:21:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:21:38 <mmorrow> > join ((*) . (*3) . succ) 5
14:21:39 <lambdabot>  90
14:21:45 <Cale> rwbarton: I hadn't even thought of that :)
14:21:45 <ahunter3> ok, Ithink I see
14:21:50 <ahunter3> it's reducing it to:
14:22:01 <ahunter3> > (\x -> zip x (tail x)) [1,2,3,4,5]
14:22:02 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
14:22:06 <ziman> :t (<$>)
14:22:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:22:23 <Heffalump> ahunter3: right
14:22:34 <Cale> rwbarton: However, it's clear which Functor instance is being applied in context, since you're in a do-block, so as long as you can parse Haskell expressions, you can see that it must be producing an IO action.
14:22:56 <Baughn> ..so ap is using the (->r) monad here, right?
14:22:58 <ziman> i'd expect a $ there
14:23:09 <Cale> (well, supposing that it's an IO do-block, of course, which it is :)
14:23:33 <mmorrow> > join (,) 0
14:23:34 <lambdabot>  (0,0)
14:23:46 <Cale> Heffalump: Would you like me to explain?
14:23:48 <RayNbow> about (.) = fmap, are there any plans for using this definition in Haskell'?
14:23:58 <Cale> Heffalump: it's the same as  fmap lines (readFile f)
14:24:16 <Baughn> > (*) `ap` id . [1..5]
14:24:16 <lambdabot>      precedence parsing error
14:24:16 <lambdabot>         cannot mix `ap' [infixl 9] and `(.)' [i...
14:24:22 <mmorrow> well (.) is a class method of Category now
14:24:22 <Baughn> > ((*) `ap` id) . [1..5]
14:24:23 <lambdabot>  [1,4,9,16,25]
14:24:25 <Cale> RayNbow: That would be cool, but Haskell' is about standardising current practice, not so much about redefining it.
14:24:39 <Heffalump> Cale: I mean that it makes no intuitive sense to me
14:24:54 <ziman> > (join (*)) . [1..5]
14:24:55 <lambdabot>  [1,4,9,16,25]
14:24:55 * rwbarton doesn't see what's wrong with lines <$> readFile f
14:25:05 <yitz> RayNbow: also, no one has really started working yet on library stuff for Haskell', as far as I've heard. Is that correct?
14:25:06 <RayNbow> Cale: isn't lambdabot = current practice? :p
14:25:18 <Cale> rwbarton: It's nice to have a lightweight notation for such a common operation.
14:25:22 <Heffalump> yitz: some bits and pieces have happened
14:25:26 <Baughn> > ((*) `ap` succ) . [1..5] -- Triangle areas!
14:25:26 <Heffalump> <$> is lightweight
14:25:27 <lambdabot>  [2,6,12,20,30]
14:26:02 <RayNbow> yitz: I have no idea about Haskell Prime's progress
14:26:07 <Cale> Heffalump: Not compared with .
14:26:10 <Baughn> But, okay. Are there any other common applications for ap /other/ than the reader monad?
14:26:12 <RayNbow> (Haskell''s <-- looks weird :p)
14:26:42 <Cale> Baughn: it kind of allows for a generalisation of liftMn
14:27:04 <Cale> return f `ap` x `ap` y `ap` z  is the same as  liftM3 f x y z
14:27:15 <Baughn> Hm. Of course.
14:27:47 * Baughn feels like he just scaled a cliff. Some learning "curve"
14:27:47 <bos> @seen sioraiocht
14:27:47 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:27:48 <yitz> RayNbow: should be written with a space - Haskell' 's - or parens - (Haskell')'s
14:28:09 <bos> dammit, lambdabot's @seen has been broken for months now.
14:28:12 <Baughn> Cale: Think maybe you should rm -f State/seen at startup?
14:28:19 <Cale> Baughn: yeah...
14:28:40 <Baughn> Cale: I think I'll have a replacement to you by the end of tomorrow, though
14:28:56 <RayNbow> yitz: I'm not familiar with these special cases in the English language :p
14:29:01 <stepcut> does ghc-paths require 6.8.3 ? I get the error, Setup.hs:7:7: Could not find module `Distribution.Simple.PackageIndex'
14:29:20 <Cale> Baughn: cool
14:29:24 <yitz> Cale - see, if even Baughn feels effort here, what does this do for the usefulness of Haskell in the field?
14:29:43 <Baughn> yitz: Now, now. I'm hardly the most exalted of haskell hackers
14:29:55 <Cale> yitz: It might be strange if you're used to (.) as composition only, but I think it's easy enough to get used to.
14:30:03 <Cale> Especially if functors are explained
14:30:07 <yitz> RayNbow: it's not English syntax. I was suggesting using the Haskell lexer to solve this problem. :)
14:30:12 <Baughn> If I'd actually /tried/ to learn these things, I'd probably be fine
14:30:38 <Baughn> yitz: Oh, and my disagreement with . isn't that it's hard to understand, just that it breaks the common assumption that it works like in math
14:30:43 <Baughn> Plus, we already have <$>
14:30:56 <Baughn> Which is prettier, yet suggests greater complexity
14:31:08 <Cale> Note that you can think of function composition as applying a function to all the results of another function, just like you can think of map as applying a function to all the elements of a list, or fmap applying a function to all the elements of some other datastructure.
14:31:10 <rwbarton> I suppose in math, functor application and functor composition are both usually written with no symbol, just juxtaposition
14:31:26 <Cale> rwbarton: yeah
14:31:46 <Twey> Funny, we always wrote them with brackets
14:31:49 <yitz> rwbarton: composition is center dot
14:31:56 <Twey> f(x) = x * 2
14:31:56 <rwbarton> Cale: If I could also write f . x for f x, I'd be more sympathetic :)
14:32:06 <ddarius> Cale: In some cases.  There are plenty of different notations used.
14:32:08 <Cale> rwbarton: and things aren't really perfect in mathematics with regard to composition either... I've seen  f . g (x) written a lot of times where people mean (f . g)(x)
14:32:17 <Baughn> > (+1) . 2
14:32:17 <lambdabot>   add an instance declaration for (Num (f a))
14:32:31 <mmorrow> > (uncurry . flip . curry . uncurry) (,) (0,"asdf")
14:32:32 <lambdabot>  ("asdf",0)
14:32:41 <rwbarton> Cale: Sure, the thing is humans' type checkers run in parallel with parsing :)
14:32:49 <matthew-_> > let (.) = id in (+1) . 2
14:32:50 <lambdabot>  3
14:33:08 <Cale> rwbarton: right
14:33:31 <Cale> rwbarton: and it's fine if you treat function composition as binding more tightly than application
14:33:40 <Cale> But it's strange to me whenever I see it now :)
14:34:16 <yitz> Face it. If you want people to understand your program you will never write ((*) `ap` succ) . [1..5], you will write [x*(x+1) | x <- [1..5]]
14:35:59 <rwbarton> yitz: Of course.  I think zip`ap`tail has become an idiom though
14:36:25 <Twey> @src ap
14:36:25 <lambdabot> ap = liftM2 id
14:36:27 <glguy> at least for the irc channel
14:36:28 <Twey> :t ap
14:36:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:36:31 <mmorrow> heh, me too. it definitely use it. i never use ap otherwise though.
14:36:49 <rwbarton> I used it just today in fact :)
14:36:50 <mmorrow> not for any particular reason though, just that i have other ways
14:36:54 <yitz> rwbarton: yeah, mainly here. I wouldn't use it in a program.
14:37:06 * glguy has a patch in xmonad removing an instance of that
14:37:17 <mmorrow> maybe [] (:[]) (Just 42)
14:37:19 <mmorrow> > maybe [] (:[]) (Just 42)
14:37:20 <lambdabot>  [42]
14:37:29 <mmorrow> > return . (:[]) =<< Just 42
14:37:30 <lambdabot>  Just [42]
14:37:35 <mmorrow> oops
14:37:38 <Cale> yitz: But what about more common cases of fmap?
14:37:44 <yitz> mmorrow: maybeToList
14:38:01 <mmorrow> yitz: you mean this:
14:38:03 <mmorrow> > maybe [] (:[]) (Just 42)
14:38:03 <Cale> yitz: (Like the example I gave)
14:38:03 <lambdabot>  [42]
14:38:11 <mmorrow> maybe is all you need
14:38:21 <yitz> Cale: I agree with Baughn, <$> is just fine for that, and worthwhile to distinguish from (.) for clarity.
14:38:31 <mmorrow> > maybe False (const True) (Just 42)
14:38:32 <lambdabot>  True
14:38:50 <Baughn> > cast (Just 42)
14:38:51 <lambdabot>  Nothing
14:39:01 <Baughn> .what'd I just do?
14:39:08 <ziman> :t cast
14:39:09 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
14:39:24 <Baughn> > cast (+1) :: Int
14:39:24 <lambdabot>  Couldn't match expected type `Int' against inferred type `Maybe b'
14:39:28 <Baughn> > cast (+1) :: Maybe Int
14:39:29 <lambdabot>  Nothing
14:39:32 <mmorrow> > either (const Nothing) Just (Right 9234)
14:39:33 <lambdabot>  Just 9234
14:39:48 <yitz> For this channel, the (->) instance and (.)=<$> generate some provocative discussion and learning, so they are useful. It would be nice to be able to turn them on and off though.
14:39:56 <mmorrow> > either (const []) return (Left "asdfgfdsa")
14:39:57 <lambdabot>  []
14:40:12 <Cale> yitz: Yeah, we were thinking it would be cool to have > and ] or some such.
14:40:49 <Cale> yitz: So that an environment very similar to what one would find in ghci with only standard packages was available.
14:41:37 <rwbarton> *Cale> (+1) . [1,2,3]    -- :)
14:41:42 <mmorrow> yitz: bear in mind that everyone had their own subset of the whole they program in. for instance, i never use the Applicative class, nor Traversable, nor ... because i have my preferred equivalents
14:41:50 <cnwdup> How do I cast a Double to a GLfloat? \-: I somehow get confused by Haskell's number type conversion.
14:42:03 <easytige`> how do i get a function to return a float. say (x+y)/3 ? My book syays fromInt is defunt.
14:42:09 <Cale> yitz: I do think that the (->) e monad is really handy though.
14:42:12 <mmorrow> yitz: (as you do too)
14:42:20 <Cale> easytige`: fromIntegral
14:42:29 <mmorrow> yitz: s/had/has/
14:42:34 <Baughn> @src Floating
14:42:35 <lambdabot> class  (Fractional a) => Floating a  where
14:42:35 <lambdabot>     pi                                                      :: a
14:42:35 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
14:42:35 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
14:42:35 <lambdabot>     (**), logBase                                           :: a -> a -> a
14:42:46 <Baughn> @src Fractional
14:42:47 <lambdabot> class  (Num a) => Fractional a  where
14:42:47 <lambdabot>     (/)             :: a -> a -> a
14:42:47 <lambdabot>     recip           :: a -> a
14:42:47 <lambdabot>     fromRational    :: Rational -> a
14:43:01 <Cale> cnwdup: realToFrac
14:43:01 <easytige`> "= fromIntegral((x + y +z) / 3)" doesnt work
14:43:14 <yitz> mmorrow: s: string not found
14:43:27 <cnwdup> cale: thank you (-:
14:43:31 <Baughn> > fromIntegral 2.3 :: Double
14:43:32 <lambdabot>  Add a type signature
14:43:35 <rwbarton> easytige`: Right, you can't use / on Integers (like x + y + z)
14:43:35 <bos> dcoutts: ping
14:43:50 <easytige`> ahhh div. thanks rwbarton
14:43:59 <mmorrow> yitz: heh, i was referring to blahabl it's not really important :)
14:44:01 <rwbarton> div throws away the remained.
14:44:04 <rwbarton> *remainder
14:44:11 <Cale> For those struggling with numeric conversions, there are really two functions you need to know: fromIntegral (for converting from an integer-like type to any numeric type), and realToFrac (for converting between most fractional types)
14:44:17 <rwbarton> You probably want ... = (fromIntegral (x + y + z)) / 3
14:45:54 <yitz> Cale: the (->) is a good teaching tool, but I don't think it's so handy for real programming work. The Reader monad is better.
14:46:01 <dons> cute stuff, http://www.reddit.com/comments/6umvp/using_haskell_as_prolog/
14:46:01 <lambdabot> Title: Using Haskell as Prolog : reddit.com
14:46:31 <Cale> yitz: The reader monad has way too much syntactic overhead for some uses.
14:47:08 <Cale> It's nice to be able to use things like sequence, liftM2 and such in the (->) e monad.
14:47:30 <Cale> Without having to wrap everything :)
14:48:21 <mmorrow> i prefer not to use monads at all unless i'm actually performing side-effects
14:48:33 <mmorrow> :t mapAccumL
14:48:34 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:48:41 <mmorrow> (etc)
14:49:04 <yitz> Cale: I wouldn't use either in those cases. I would write functions whose meanings are absolutely transparent to anyone reading them.
14:49:30 <Cale> yitz: the meanings of those functions are absolutely transparent once you learn them :)
14:49:37 <Cale> :t runCont (sequence (map Cont xs))
14:49:45 <Cale> ...
14:49:51 <mmorrow> ah, i make an exception for the Cont monad
14:50:16 <Cale> mmorrow: Yeah, that function is much harder to write without the Cont monad. :)
14:50:16 <mmorrow> because without it it would be impossible   (ly difficult)
14:50:24 <yitz> dons: yeah. I'd like to see it from the other direction - what would prolog look like without its built-in imperative bias? That would be cool.
14:50:49 <Cale> [(r -> b) -> b] -> ([r] -> b) -> b
14:51:01 <mmorrow> hehe
14:51:03 <Cale> :t runCont
14:51:04 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
14:51:06 <Cale> hmm
14:51:13 <yitz> Cale: true. once you learn them. one more barrier to entry. and it's not like you're adding that much.
14:51:23 <Cale> :t \xs -> runCont (sequence (map Cont xs))
14:51:23 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
14:51:41 <mmorrow> ooh, that's an interesting one
14:51:49 <mmorrow> have to think about it for a sec
14:52:10 <mmorrow> oh, so.
14:52:21 <mmorrow> :t \xs -> runCont (sequence (map return xs))
14:52:22 <lambdabot> forall a r. [a] -> ([a] -> r) -> r
14:52:26 <mmorrow> oh
14:53:05 <hml> wow, did haskell really rip off it
14:53:25 <hml> its typing from ocaml?
14:53:32 <hml> or was hasekll first}
14:53:41 <yitz> hml: both took it from ML
14:53:45 <petekaz> http://hpaste.org/9350 <- I'm reading RWH chapter on quickcheck but I'm still not sure how I can use quickcheck to test this function.  I'm unsure of what type of properties I should be writing as to test the property I need to rewrite the same logic that the orginal function did.  Am I thiking about this the wrong way?
14:54:37 <mmorrow> > let f = (xs -> runCont (sequence (map Cont xs))) (map (*) [0..9]) in map f (replicate 4 (replicate 8  2))
14:54:37 <lambdabot>  Parse error at "->" (column 13)
14:54:43 <mmorrow> > let f = (\xs -> runCont (sequence (map Cont xs))) (map (*) [0..9]) in map f (replicate 4 (replicate 8  2))
14:54:43 <lambdabot>      Occurs check: cannot construct the infinite type: r = a -> r
14:54:43 <lambdabot>       Expec...
14:55:15 <ddarius> petekaz: imapseq [n..m] == show n ++ ":" show m
14:55:15 <mmorrow> > let f = (\xs -> runCont (sequence (map Cont xs))) (map (*) [0..9]) in f sum [0..9]
14:55:16 <lambdabot>      Occurs check: cannot construct the infinite type: r = a -> r
14:55:16 <lambdabot>       Expec...
14:55:20 <Cale> hml: "Rip off" is a bit strong, but yeah. If you want to use "rip off", you might as well say that Haskell ripped off Miranda for almost everything :) (apart from all the new features)
14:55:32 <mmorrow> :t let f = (\xs -> runCont (sequence (map Cont xs))) (map (*) [0..9]) in f
14:56:08 <Baughn> petekaz: Normally there are simpler properties you can check, or properties you can check with less logic, or at least properties you can check with /different/ logic
14:56:14 <ddarius> Good language designers try to rip off as much as possible.
14:56:43 <Baughn> petekaz: In this one, how about writing a decompressor for your RLE encoding and comparing it to the original?
14:56:56 <Cale> petekaz: Start by writing the function that goes in the other direction, and test that they compose to the identity in both ways.
14:57:03 <petekaz> ddarius/baughn: I see. no need to test the whole thing. So another test/property might be taking the min of the int list, and seeing if it is the same as the 1st char of the resulting string.
14:57:41 <ddarius> petekaz: Yes.  You are testing properties.  No property needs to be a complete specification.
14:57:54 <petekaz> got it.
14:58:02 <ddarius> Ideally, the entirety of them will be or will at least specify everything that is important.
14:58:42 <petekaz> thanks for the feedback!
14:58:45 <Baughn> petekaz: If you /can't/ figure out a simpler property to check, you should at least be able to write supposedly equivalent functions that do the same thing /differently/, preferably written by different people
14:58:53 <Baughn> Then you use quickcheck to check for function equality
15:01:37 <ddarius> As a degenerate case, you can write unit tests as quickcheck properties.
15:02:17 <mmorrow> > let f = \xs -> runCont (sequence (map Cont xs)) ; g = f (replicate 10 ($ 2)) in g (scanl (+) 0)
15:02:18 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20]
15:02:22 <mmorrow> finally
15:02:36 <Cale> @unpl ((runState .) .) . foldM . ((State .) .)
15:02:36 <lambdabot> (\ g m p -> runState (foldM (\ s v -> (State) (g s v)) m p))
15:02:50 <Cale> heh, I actually had an easier time writing that points-free
15:03:32 <Cale> :t ((runState .) .) . foldM . ((State .) .)
15:03:32 <lambdabot> forall b s a. (a -> b -> s -> (a, s)) -> a -> [b] -> s -> (a, s)
15:03:36 <mmorrow> Cale: i usually do for most things (save pathological cases)
15:04:17 <Cale> :t map (map runState) . foldM . map (map State)
15:04:18 <lambdabot> forall b s a. (a -> b -> s -> (a, s)) -> a -> [b] -> s -> (a, s)
15:04:20 <Cale> :)
15:04:26 <mmorrow> heh
15:05:03 <Cale> It's nice to have options :)
15:05:22 <mmorrow> recently i'v taken a liking to shifting the (f)maps to:
15:05:42 <mmorrow> :t (map . map) runState . foldM . (map .map) State
15:05:43 <lambdabot> forall b s a. (a -> b -> s -> (a, s)) -> a -> [b] -> s -> (a, s)
15:05:56 <Cale> :)
15:06:09 <Baughn> "Haskell: There's (`ap` id) ways to do it."
15:07:06 <ziman> :t (+1) `ap` id
15:07:23 <yitz> Cale: It's nice to have options? that's what opponents to type checking say. :)
15:07:25 <Baughn> Use @type
15:07:37 <ddarius> ap id id (ap id id)
15:07:54 <ziman> @type (+1) `ap` id
15:07:54 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
15:08:16 <yitz> @type (`ap` id)
15:08:17 <lambdabot> forall b a. (a -> a -> b) -> a -> b
15:08:49 <mmorrow> > zipWith (==) (fmap (join (*)) [0..]) (fmap (`ap`id) [0..])
15:08:49 <lambdabot>   add an instance declaration for (Num (a -> a -> b))
15:08:49 <lambdabot>     In the expression: 0
15:09:00 <mmorrow> > zipWith (==) (fmap (join (*)) [0..]) (fmap ((`ap`id)(*)) [0..])
15:09:01 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
15:10:51 <Baughn> @quickcheck \x -> ((*)`ap`id)x == (join(*))x
15:10:51 <lambdabot> Unknown command, try @list
15:10:58 <Baughn> @check \x -> ((*)`ap`id)x == (join(*))x
15:11:00 <lambdabot>  OK, passed 500 tests.
15:16:55 <mmorrow> > (`ap`(+1))(*)8
15:16:56 <lambdabot>  72
15:16:58 <mmorrow> > (id=<<(*).(+1))8
15:16:59 <lambdabot>  72
15:17:42 <mmorrow> > join((*).(+1))8
15:17:43 <lambdabot>  72
15:18:18 <mmorrow> > ((*)=<<(+1))8
15:18:19 <lambdabot>  72
15:18:48 <EvilTerran> > ((*)=<<(+1))x
15:18:49 <lambdabot> Terminated
15:18:53 <EvilTerran> > ((*)=<<(+1))x :: Expr
15:18:54 <lambdabot> Terminated
15:18:55 <EvilTerran> wat
15:19:13 <mmorrow> > (g=<<f)x
15:19:14 <lambdabot> Terminated
15:19:44 <mmorrow> heh, i'd be way surprised if there was an instance to handle that
15:20:19 <mmorrow> actually, i think with just f,g,x you can't know how to do it
15:23:16 <rwbarton> > x * (x+1)
15:23:17 <lambdabot> Terminated
15:23:18 <rwbarton> > x
15:23:19 <lambdabot> Terminated
15:23:33 <rwbarton> > f x
15:23:34 <lambdabot> Terminated
15:26:46 <mmorrow> > let shift f=Cont(\k->runCont(f(Cont . flip id . k))id) in (\n->(return.(*2)=<<shift(\k->k n>>=k>>=k>>=k))`runCont`id)8
15:26:47 <lambdabot>  128
15:26:51 <mmorrow> lol
15:27:41 <dmwit> > x * (x + 1)
15:27:42 <lambdabot> Terminated
15:27:47 <dmwit> ?undefine
15:27:48 <lambdabot> Undefined.
15:27:49 <dmwit> > x * (x + 1)
15:27:50 <lambdabot>  x * (x + 1)
15:27:54 <mmorrow> ahh
15:27:58 <mmorrow> > (g=<<f)x
15:27:59 <lambdabot>  Add a type signature
15:28:03 <mmorrow> > (g=<<f)x :: Expr
15:28:04 <lambdabot>  Add a type signature
15:28:20 <mmorrow> > (g=<<f)x :: [Expr]
15:28:21 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
15:28:28 <dcoutts_> bos: pong
15:31:39 <gwern> lol
15:31:42 <gwern> 'cabal: dependencies conflict: mueval-0.5 requires bytestring ==0.9.1.0 however
15:31:43 <gwern> bytestring-0.9.1.0 was excluded because mueval-0.5 requires bytestring
15:31:43 <gwern> ==0.9.0.1
15:32:00 <gwern> I can't even cabal-install my own program because of bytestring
15:32:45 <dmwit> How did you get a dependency on two versions of the same library?
15:32:54 * gwern doesn't know
15:33:01 <aFlag> what would you guys recommend me for parsing and processing web pages?
15:33:08 <gwern> bytestring moves in mysterious ways
15:33:40 <dmwit> aFlag: tag soup/beautiful soup/whatever it's called
15:33:46 <dcoutts_> gwern: mm, that's an interesting one
15:34:16 <dcoutts_> gwern: would you be able to save the details and send them to me
15:34:26 <gwern> dcoutts_: I'll hpaste something
15:34:41 <gwern> right now I'm dealing with Jeremey Shaw's problem with ghc-paths
15:34:44 <dcoutts_> gwern: the planning log with -v would be handy
15:34:48 <gwern> which blocks hint/mueval
15:35:43 <gwern> http://hpaste.org/9351
15:35:48 <Quylui> j/ #python
15:35:50 <Quylui> oops
15:36:14 <gwern> heretic!
15:36:35 <gwern> dcoutts_: btw, do you know what's wrong with ghc-paths? it no longer seems to install which is odd
15:37:08 <dcoutts_> gwern: I've hear other people report that, what is the symptom?
15:37:12 <gwern> since it installed before
15:37:24 <gwern> dcoutts_: it just seems to call stuff in Setup.hs which is never avalable
15:37:33 <gwern> in 1.2.3, it calls a module which doesn'texist
15:37:41 <dcoutts_> gwern: it uses things from Cabal-1.4, that's the issue
15:37:45 <dcoutts_> in it's Setup.hs
15:37:51 <gwern> in 1.4 and up, it uses functions and data constructors which aren't available
15:38:03 <gwern> and I dunno about 1.3, that's broken here
15:38:10 <dons> aFlag: libdownload ? it wraps up curl and tagsoup
15:40:23 <dcoutts_> dons: hmm, that's not especially compositional
15:41:39 <stepcut> dons: You say that I should be using the ghc-api instead of hs-plugins, hsplugins seems to depend on ghc-pai already ?
15:41:54 <dcoutts_> dons: how about just openURI :: URI -> IO ByteString ?
15:42:15 <dcoutts_> or downloadURI since it's not an open/close sort of thing
15:46:00 <dons> dcoutts_: there's all those interfaces provided.
15:46:16 <dcoutts_> dons: aye, my point is that's too many
15:46:31 <dons> http://hackage.haskell.org/packages/archive/download-curl/0.1/doc/html/Network-Curl-Download.html
15:46:32 <lambdabot> Title: Network.Curl.Download, http://tinyurl.com/6rp8z6
15:46:42 <dons> ah well, its about saving some time.
15:46:45 <dcoutts_> dons: isn't openAsTags uri = asTags <$> downloadURI uri
15:47:08 <dons> yupopenAsTags s = (fmap TagSoup.parseTags) `fmap` openURIString s
15:47:12 <dons> so close.
15:47:13 <dcoutts_> dons: but it means deps on three random packages
15:47:24 <dons> s/random/carefully chosen/
15:47:26 <dcoutts_> it's not doing one job
15:47:33 <dcoutts_> and using composition
15:47:56 <dons> its a port of the hpricot lib from ruby, which offers a similar interface. don't use the wrappers if you don't like 'em
15:48:14 <dcoutts_> dons: you'd never get it past the Data.List scrutiny committee ;-)
15:48:26 <dons> right. its a glue library.
15:48:31 <dmwit> The two rules of open source:
15:48:36 <dmwit> 1. If you don't like it, fix it.
15:48:39 <dons> bundling up the common practice
15:48:44 <dmwit> 2. If you don't like it and won't fix it, don't use it.
15:48:57 <dons> "The basic interface to network content
15:48:58 <dons> Parsers for common formats "
15:49:07 <dcoutts_> dons: we don't bundle map . filter, we just use (.), <$>,  >>=  whatever
15:49:36 <dcoutts_> dons: perhaps ruby do it because they don't have a culture of composition
15:49:45 <edwardk> is jhc the only compiler out there using boquist's GRIN at the moment?
15:49:48 <dmwit> dcoutts_: List comprehensions are, arguably, a bundling of map and filter.
15:50:00 <gwern> edwardk: only one I've ever heard of
15:50:04 <dcoutts_> dmwit: but they're not fixed function
15:50:08 <gwern> edwardk: you plan on working on it and making it usable?
15:50:10 <edwardk> gwern: kinda figured, just thought i'd check
15:50:14 <edwardk> gwern: not exactly
15:50:22 <gwern> dcoutts_: obviously ruby has solid its soul for success!
15:50:49 <gwern> edwardk: aw :( it'd be neat if jhc finally got some libraries beyond the prelude or whatever. I'd like to see its results on the programming shoout
15:50:49 <dons> dcoutts_: it's like providing encodeFile and decodeFile
15:50:54 <stepcut> gwern: does mueval/hint require ghc > 6.8.2 ? I can't get ghc-paths to compile even with the latest Cabal ?
15:51:00 <dons> sometimes there simply are sensible defaults.
15:51:07 <dcoutts_> dons: yeah, I wasn't so sure about them ;-)
15:51:14 <dcoutts_> dons: and we didn't have <$> at the time
15:51:14 <dmwit> dcoutts_: I'm just saying, you chose a bad example, because it's *already* bundled by the language.  But, for example, we bundle lots of things like "nubBy (==)", even though it's so compositionally simple.
15:51:31 <dons> if i can make one python or ruby convert's life easier, then i'm happy
15:51:38 <dcoutts_> dmwit: no, list comps are a flexible mixture, they're not fixed combinations
15:51:53 <gwern> stepcut: I dunno what's with ghc-paths. it worked with 6.8.2 back when I installed it for 0.1, and I haven't installed anything higher
15:51:54 <dons> who'd have thought we'd see a day when libraries were too useful
15:52:04 <gwern> stepcut: I use 6.8.2; mueval had better work in it
15:52:10 <dcoutts_> dons: they can become overwhelming if there are too many names
15:52:12 <gwern> stepcut: strangely, jeremey shaw just emailed me about that
15:52:14 <dons> i think this is a common patter, though, dcoutts_
15:52:22 <dons> even the pretty printer library has render, pretty, show, ..
15:52:37 <dons> which just tacks on some glue in front of the lib.
15:52:39 * stepcut is jeremy shaw
15:52:50 * dons is jeremy shaw
15:52:53 <edwardk> gwern: i'm playing with a couple of virtual machines for kata, and right now i'm pretty much working with a spineless tagless g-machine clone, i was thinkign about grin, because it opens up more low level optimizations and with the 'sea of constructors' i have i think i need them more
15:52:53 <dons> oh wait, no.
15:52:58 <dcoutts_> dons: but they don't pull in whole packages for the sake of one composition
15:53:01 <gwern> no, *I* am jeremey shaw!
15:53:19 <stepcut> gwern: ok, I tried 0.1.0.1, but didn't go all the way back to 0.1. I'll try that now.
15:53:20 <dcoutts_> gwern: and so's your wife?
15:53:28 <gwern> edwardk: what is kata? I'ven't heard of't
15:53:35 <dons> dcoutts_: that's your fault for making packages so cheap.
15:53:40 <edwardk> gwern: its my toy untyped haskell-alike
15:53:41 <gwern> dcoutts_: yes. she is spartacus^Wshaw as well
15:53:43 * dons treats the package system like functions now.
15:53:48 <dcoutts_> dons: heh
15:54:10 <gwern> dcoutts_: oh, I saw a useless use of packages today you would like
15:54:31 <dons> we need a nice glue layer between gtk2hs and hipmunk
15:54:39 <dons> so i can just open up a window with hipmunk physics running in it
15:54:46 <gwern> GeomAlgLib pulled in 'ghc' for the sake of a single use 'maybeToBool', a two line function which goes 'maybe Just a = True; maybe Nothing = False'
15:54:52 <dons> gwern: heh
15:55:05 <gwern> I was gobsmacked when I saw that *that* was why it dependended on ghc
15:55:14 <dcoutts_> dons: I guess my point is, I think we should aim higher for standard platform libs, things that are generally useful and compsable
15:55:22 <gwern> dons: are you thinking what I'm thinking?
15:55:31 <dcoutts_> dons: and wherever possible try to use portable implementations
15:55:37 <dons> yep.
15:55:47 <dcoutts_> dons: eg, we're not putting enough work into the HTTP lib
15:55:48 <gwern> chipmunk xmonad layout!
15:55:56 <dons> right. that's a main problem.
15:56:05 <gwern> you drag frames around with your mouse, and they fall down and jumble
15:56:09 <edwardk> gwern: anyways pretty much the main reason i like grin has nothing to do with its penchant for small executables and how well it works in closed world optimization, its mostly that it doesn't take almost every single jump indirectly through a pointer.
15:56:16 <gwern> all in ultra realistic 2d physics!
15:56:27 <dcoutts_> dons: it's actually pretty good, it handles quite a bit of stuff, like proxies and redirects
15:56:32 <gwern> edwardk: good for pipelining?
15:56:38 <dcoutts_> dons: it'd be great to have a downloadURI on top of that
15:56:48 <dons> dcoutts_: iirc, error handling is awkward and strings are inefficient
15:56:54 <edwardk> gwern: can't branch predict if you have no idea where you're going ;)
15:57:00 <dcoutts_> dons: yes, we should use bytestrings of course
15:57:26 <dcoutts_> dons: and perhaps error handling needs improveing, but we don't need curl and indeed I don't see that curl makes error handling better
15:57:43 <dcoutts_> dons: and it's not portable, we can't use curl in cabal-install for example
15:57:45 <dons> yep. curl's just nice and efficient. chunkwise filling via call backs.
15:57:53 <dcoutts_> so we have to have a decent http package anyway
15:57:55 <gwern> edwardk: I really think we could totally clean up using jhc in the shootout
15:58:08 <gwern> it's a real pity meachem is so anti-cabal
15:58:16 <gwern> jhc doesn't look terribly hard to cabalize
15:58:21 <dcoutts_> dons: right, and there's no reason we cannot do that in Haskell with bytestrings
15:58:22 <magthe> anyone who knows if the authore of HaXR, Bjorn Bringert, doesn't happen to frequent #haskell?
15:58:34 <dons> dcoutts_: right.
15:58:34 <dmwit> ?seen bringert
15:58:34 <lambdabot> I haven't seen bringert.
15:58:37 <edwardk> i'm just a bit paranoid because unlike the stg i don't see how it can work with untagged data and garbage collection
15:58:40 <dcoutts_> magthe: he's here quite a bit as 'bringert'
15:58:41 <gwern> preflex: seen bringert
15:58:41 <preflex>  bringert was last seen on #ghc 13 days, 7 hours, 44 minutes and 30 seconds ago, saying: dcoutts: sounds ok
15:58:53 <kryptiskt> edwardk, ehc uses GRIN
15:59:04 <gwern> kryptiskt: it does? interesting
15:59:07 <edwardk> kryptiskt: thanks =)
15:59:09 <magthe> dcoutts: ah, cool, thanks... was just wondering if my two patches t HaXR made it into his mail box
15:59:11 <edwardk> checking now
15:59:49 * magthe hopes for better luck next time and leaves
16:00:12 <ddarius> @dice 1d2
16:00:13 <lambdabot> 1d2 => 2
16:00:50 <ddarius> @dice 1d2
16:00:50 <lambdabot> 1d2 => 2
16:00:51 <gwern> dcoutts_: any idea aboutmueval or ghc-paths?
16:01:08 <dcoutts_> dons: I'll stop complaining now :-) I don't mean to sound so critical, I just think perhaps we should encourage people to concentrate their efforts a bit more so we get some canonical excellent libs rather than lots of bindings.
16:01:31 <dcoutts_> gwern: I've not looked at the details
16:01:31 <edwardk> hrmm does anyone know the license for ehc, skimming the source repository doesn't tell me
16:01:42 <stepcut> gwern: it seems that, ghc-paths 0.1 + Cabal 1.4.0.1 + ghc 6.8.2, works
16:02:01 <gwern> stepcut: hm. I is fetching 1.4 now, but is taking a while
16:02:02 <stepcut> gwern: but not any combination of newer ghc-paths or older Cabal
16:02:08 <dons> dcoutts_: sure.
16:02:15 <gwern> edwardk: it's a mix
16:02:37 <gwern> edwardk: mostly GPL, with some BSD and latex mixed in
16:02:40 <gwern> edwardk: recursive grep is your friend
16:02:48 <stepcut> gwern: does hint/mueval provide any dynamic loading capabilities (similar to hsplugins ?)
16:02:59 <edwardk> gwern: ok, shucks, so with gpl in there it might as well be gpl through and through
16:03:16 <gwern> edwardk: incidentally, what svn repo are you using?
16:03:29 <gwern> stepcut: mm, what do you mean? mueval invocations are one-shot
16:03:50 <gwern> you run it with an expression, and it prints out stuff and exits
16:03:53 <edwardk> https://svn.cs.uu.nl:12443/repos/EHC/trunk/EHC/
16:04:24 <gwern> yeah, thought so
16:04:27 <name_> can someone explain the point of callCC to me. the wikibook article equates it to an imperative "return" statement. but couldnt you just use a switch statement to branch?
16:04:33 <stepcut> gwern: I am thinking it might be nice to do dynamically loadable plugins (like hsplugins), but safe, like mueval.
16:04:40 <stepcut> gwern: not required though.
16:05:17 <gwern> stepcut: well, I *think* what you could do is use the mueval library and call limitResources before you call interpreter
16:05:55 * edwardk feels somewhat dirty having just reintroduced types to his toy compiler today after being so proud of not having them this entire time. if only to allow me to have some unboxed types internally =)
16:06:07 <stepcut> gwern: ok. I'll look into that. I guess the resource limits thing would be a bit tricky with dynamic loading. Perhaps keeping things as a separate process is better.
16:06:07 <gwern> but limitResources would apply to the whole of the program, so I guess one would need a unlimitResources for when your interpreter returns
16:06:21 <gwern> but on the other hand, it's all error and putStr, so interpreter is ()
16:06:30 <ddarius> edwardk: You mean into the language?  Who cares what the compiler does?
16:07:07 <stepcut> gwern: I get this error no matter what I do:
16:07:08 <stepcut> $ mueval -e '1 + 1'
16:07:08 <stepcut> mueval: Expression did not compile.
16:07:13 <edwardk> ddarius: well they bubble up to the surface of the language because you indicate that a constructor for Ints holds an unboxed integer inside it, etc.
16:07:15 <stepcut> did I break it ?
16:07:21 <gwern> stepcut: yeah. I thought about keeping it in the same process, just forkIO'd, and concluded that it's a risk and makes engineering much more difficult. with mueval as a separate process, you get perfect memory protection and you can easily exploit all the OS per-process protections
16:07:30 <gwern> stepcut: what does ./tests.sh do?
16:07:48 <stepcut> same
16:07:56 <stepcut> mueval: Expression did not compile.
16:07:56 <stepcut> mueval: Time limit exceeded
16:08:15 <gwern> hm... it compiled with no problem?
16:08:19 <stepcut> yeah
16:08:21 <gwern> latest mueval?
16:09:06 <stepcut> latest everything from hackage, except ghc-paths (mueval, hint, show, smalcheck)
16:09:36 <gwern> stepcut: I've long suspected that my resource limits are too tight for anyone else's system. could you try commenting out limitResources in Interpreter.hs?
16:10:17 <sjanssen> gwern: do you still have file resource limits in there?
16:10:18 <stepcut> gwern: that fixed it.
16:10:49 <gwern> sjanssen: I had to loosen them because of the GHC API difficult. hint got around it by writing out  a temporary file :(
16:11:14 <sjanssen> gwern: you should really ditch those
16:11:22 <gwern> stepcut: aha, I thought as much. I'd be appreciative if you could iteratively narrow it down to the precise rlimit which is problematic. a working value would be even more awesome
16:11:27 <sjanssen> gwern: they provide a false sense of security, IMO
16:11:33 <gwern> sjanssen: I just find it hard to abandon a security measure
16:12:12 <sjanssen> gwern: but it isn't a real security measure, what will your response be when stepcut finds out that he needed just one extra file opened?
16:12:24 <gwern> what do I write in the patch? 'Interpreter.hs: made mueval less secure'
16:12:41 <dmwit> "more honest"
16:12:41 <gwern> sjanssen: I tell him to increment it? or I increment it in the darcs repo
16:13:01 <sjanssen> gwern: you'll bump the file limit, making every machine that mueval currently runs on less safe (according to you)
16:13:35 <gwern> sjanssen: well, it certainly would make it less safe for me - that's one more file an evil mueval could open on my machine which it wouldn't've been able to
16:13:44 <sjanssen> gwern: in fact, I bet there are setups that require less open files than yours, meaning that the protection was empty in the first place
16:14:17 <gwern> sjanssen: are you going to argue next that timeouts provide a false sense of security as well?
16:14:25 <sjanssen> no
16:14:53 <gwern> but surely there are evil expressions which would take less than 5 seconds and good expressions which take more?
16:16:16 <sjanssen> an expression that takes more than 5 seconds is "evil" anyway -- at least if you ever want to use it in an IRC bot
16:17:47 <gwern> I could wish for better errors frmo Hint tho. compilation failed is unhelpful
16:18:34 <gwern> stepcut: any idea which limit it is?
16:18:39 <stepcut> gwern:  it appears that all the limits except StackSize and CoreFileSize are too tight, gotta make pizza now though, bbl
16:19:18 <gwern> stepcut: sure. if you figure out new limits, I'll apply'em
16:19:22 <sjanssen> gwern: you're going to be getting emails for years asking to bump the file limit :)
16:19:40 <gwern> sjanssen: absurd! surely there is a number which works for all
16:19:48 <sjanssen> gwern: I doubt it
16:20:04 <osfameron> ooo, using lazy calculation to model waiting on forked processes is quite cute
16:20:09 <dmwit> 2^16 files ought to be enough for anybody
16:20:15 <gwern> well, how many files could the ghc api possibly need to open?
16:20:45 <sjanssen> gwern: tons of 'em
16:20:53 <gwern> :(
16:21:16 <sjanssen> package conf files (one system and one per-user -- this may get worse if GHC moves to one file per package), it has to open object files for libraries
16:21:28 <gwern> (if only there was some way to statically link in all the whitelisted libraries & pkg.confs so no disk access would be needed)
16:21:41 <gwern> one file epr package? oh no
16:22:31 <sjanssen> gwern: dcoutts has been asking for faster ghc-pkg operations, a file-per-package is one way to do that
16:23:47 <gwern> why would it? wouldn't they be small files and so you'd incur overhead for each one, compared to reading in 1 or 2 not-quite-so-small files?
16:23:49 <sjanssen> gwern: does mueval disable TH?
16:24:04 <gwern> sjanssen: yes. mauke mentioned that he has an idea for how to do TH tho
16:24:11 <sjanssen> gwern: the advantage is that you only have to read files for the packages you're interested in
16:24:23 <gwern> at least, I thought it doesn't do TH. if you've done th in mueval I'd appreciate knowing
16:24:39 <gwern> default th is unsafe iirc, so that'd be a problem
16:25:17 <ziman> :t (<*>)
16:25:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:25:26 <sjanssen> gwern: yeah, it can run IO
16:26:15 <sjanssen> if only yhc didn't suck, it'd be perfect for safely running code
16:26:44 <nax> anyone have experience with the YHC javascript target?
16:27:55 <gwern> nax: I once saw it on reddit
16:28:06 <gwern> it seemed to work for basic expressions, fwiw
16:28:20 <nax> i can't get it working
16:29:09 <mmorrow> nax: i've built it successfully and experimented with using it
16:29:18 <mmorrow> nax: what's broken
16:29:20 <mmorrow> ?
16:29:38 <nax> something about it needing the filepath package
16:30:46 <mmorrow> so what stage are you at?   (1)build yhc   (2)build the yhcjs,pgbuild,..     (3)compile .hs files ... (.js,.html)   ?
16:32:21 <mmorrow> sjanssen: yeah, yhc is brutal compared to ghc
16:33:06 <nax> i think I succesfully completed (1) and am stuck on (2)
16:33:36 <mmorrow> what ghc version do you have and can you hpaste to error output?
16:34:27 <mmorrow> ... and can you hpaste _the_ error output?
16:35:16 <nax> ghc 6.6
16:36:33 <nax> http://hpaste.org/9353
16:36:54 <mmorrow> nax: hmm, i haven't built it with a ghc < 6.8, so i'd suggest you get a 6.8 so you can be sure to have up to date libraries/etc
16:37:40 <mmorrow> honestly, i wouldn't even waste any more time trying to get it to work with 6.6 (although i'm sure you *could* do it, i personally wouldn
16:37:44 <mmorrow> 't want to)
16:38:23 <nax> what i don't understand is why is ghc needed at this stage, why isn't yhc itself used?
16:39:12 <mmorrow> yeah, definitely get 6.8. And, you need a very specific version of hxt (haskell xml toolkit) to get it to build
16:39:37 <gwern> stepcut: you're right, Cabal-1.4.0.1 does work with 0.1 ghc-paths
16:39:40 <nax> hm... ok. do we know when the next version of ghc will be released? i don't want to upgrade now if there is a new version coming soon
16:39:48 <stepcut> gwern: sweet
16:40:09 <gwern> 0.1.0.2 also seems to work with't
16:40:28 <gwern> nax: 6.8.3 just came out relatively recently. I don't think we can expect 6.10 for many months
16:40:43 <mmorrow> nax: so, yhc2js and pgbuild are intended to be built with ghc. the only thing yhc is actually used for is to parse/typecheck/etc the haskell code to-be-trans-to-js, then translate *that* to "yhccore" (a simplified haskell syntax), which is then finally trans to js
16:40:52 <gwern> stepcut: did you email the author to ask him to have more refined cabal deps?
16:41:10 <stepcut> gwern: not yet
16:41:15 <mmorrow> i'll check what hxt you need real quick
16:41:26 <nax> mmorrow: ok thanks
16:41:32 <gwern> stepcut: are you going to?
16:41:53 <nax> i remember reading on a mailing list that there are all these conflict problems with latest bytestring and ghc and cabal. are all these issues now cleared up?
16:41:57 <stepcut> gwern: it seems that setting *any* TotalMemory limit breaks things for me
16:42:14 <gwern> stepcut: really? any at all? even a ridiculously high one?
16:43:11 <mmorrow> nax: oops, i meant *HaXml*, not hxt.    you need  HaXml-1.13.3
16:43:36 <stepcut> gwern: yeah, I tried 256^256
16:43:41 <stepcut> > 256^256
16:43:45 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
16:44:04 <gwern> ok. is that the only problematic limit?
16:44:15 <gwern> stepcut: also, is this 32-bit or 6-4bit? I vaguely recall something
16:44:23 <mmorrow> nax: the hackage HaXml version is _not_ the one you want.  it's here:  http://www.haskell.org/HaXml/HaXml-1.13.3.tar.gz
16:44:33 <stepcut> gwern: 32-bit, dual core
16:44:59 <nax> mmorrow: is this needed only for pgbuild? i think i want only yhc2js and not pgbuild
16:45:16 <mmorrow> nax: yeah, i believe only for pgbuild
16:45:17 <gwern> hm. I do remember something about 34-bits and the memory limits, but not anything more
16:45:47 <stepcut> gwern: the openfiles limit seems to break it as well.
16:46:01 <stepcut> even with a limit of 1,000,000
16:46:05 <mmorrow> nax: the only thing is, the whole runtime + your translated code go in the html file that pgbuild generates
16:46:13 <gwern> shoot
16:46:20 <gwern> stepcut: what system are you on anyway?
16:46:28 <gwern> I thought rlimits were POSIX
16:46:34 <mmorrow> so you may be able to do what you want without it, but it probably won't be not hard ;)
16:46:48 <stepcut> gwern: ubuntu hardy, Linux lain 2.6.24-18-generic #1 SMP Wed May 28 20:27:26 UTC 2008 i686 GNU/Linux, dual core centrino, lenovo T61, 1GB RAM
16:47:16 <nax> mmorrow: first i want to evaluate the generated js and see if it's suitable for me
16:47:18 <gwern> strange, I'm on hardy too
16:47:33 <gwern> stepcut: ok, so openfiles and totalmemory, that it?
16:47:47 <dmwit> :t sum . map (const 1)
16:47:47 <lambdabot> forall a a1. (Num a) => [a1] -> a
16:47:55 <dmwit> ?src genericLength
16:47:55 <lambdabot> genericLength []    = 0
16:47:55 <lambdabot> genericLength (_:l) = 1 + genericLength l
16:48:07 <mmorrow> nax: gimme a sec, i'll paste some examples
16:48:18 <stepcut> gwern: FileSize
16:48:47 <gwern> ...
16:49:05 <stepcut> gwern: specifically, ResourceFileSize
16:50:21 <stepcut> gwern: and ResourceCPUTime
16:50:36 <stepcut> gwern: it seems like if I set any limit for any of those I get the Expression did not compile error
16:50:36 <gwern> stepcut: perhaps you should instead tell me which ones don't cause problems
16:51:00 <stepcut> StackSize, DataSize, and CoreFileSize seemed to be usuable
16:51:23 <stepcut> though, maybe only after I jacked up the dataSizeLimitHard value
16:51:35 <stepcut> the other others seem to kill it no matter what the limit is at
16:51:37 <stepcut> not sure why
16:54:12 <stepcut> gwern: but, here is the thing
16:56:29 <gwern> yes?
16:58:05 <stepcut> gwern: mueval: Expression did not compile: setResourceLimit: invalid argument (Invalid argument)
16:58:45 * glguy wishes that he could write: f :: exists a. Int -> M s a -> a  (instead of always translating into foralls)
16:58:53 <glguy> errr, exists s
16:59:05 <gwern> stepcut: interesting
16:59:50 <ddarius> glguy: Install hbc.
16:59:55 <dolio> @quote simonpj existential
16:59:55 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
17:00:18 <stepcut> gwern: if I set the ResourceTotalMemory limit to 0, then I just get an out of memory error, but any other value gives the 'invalid argument' error
17:00:56 <nax> mmorrow: ok cool thanks. what would be really sweet would be a webform where you could paste a haskell function and see the javascript that is compiled from it
17:01:39 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/Man_or_boy_test#Haskell
17:01:40 <lambdabot> http://tinyurl.com/6fen5r
17:01:48 <stepcut> gwern: ResourceLimitInfinity seems to  fail as well
17:01:59 <stepcut> gwern: I am thinking this might be a bug in the Posix binding ?
17:02:31 <stepcut> gwern: I'm guessing the resource limit code has not actually been used that much...
17:03:41 <stepcut> gwern: or perhaps there is something funny going on because my ghc was compiled under xen, and the resource limits structs have different offsets ?
17:03:58 <gwern> stepcut: might I suggest writing a small program which calls your erroneous problem? I doubt the ghc devs would care if you write 'i has a problem  in mueval'
17:04:02 <gwern> they like small examples
17:04:07 <stepcut> gwern: :)
17:05:58 <gwern> stepcut: I'm gonna email marlow about ghc-paths
17:06:12 <stepcut> gwern: cool
17:08:02 <stepcut> gwern: the miminal test cases is pretty simple, main = setResourceLimit ResourceTotalMemory (ResourceLimits ResourceLimitInfinity ResourceLimitInfinity)
17:08:19 <stepcut> gwern: I take it that works for you ? (for me, under GHCi, I get, *** Exception: setResourceLimit: invalid argument (Invalid argument))
17:08:22 <gwern> that satisfies main :: IO ()?
17:08:55 <stepcut> gwern: yes. setResourceLimit :: Resource -> ResourceLimits -> IO ()
17:08:57 <mmorrow> nax: ok these 6 file are from a tutorial on the haskell.org wiki (# 6 doesn't seem to actually work, you'll see), so in this directory are all the various files related in the build process + the output html files:
17:08:59 <mmorrow> http://lunar.moonpatio.com/yhcjs/yhcjs-eg-080802/
17:09:04 <gwern> I get permission denied
17:09:08 <gwern> nothing about invalid args
17:09:15 <stepcut> gwern: interesting
17:09:31 <gwern> works fine under sudo
17:09:42 <mmorrow> nax: if that doesn't resolve for some reason, use http://207.58.166.174/yhcjs/yhcjs-eg-080802/
17:09:43 <lambdabot> Title: Index of /yhcjs/yhcjs-eg-080802
17:10:36 <mmorrow> nax: yeah, a web interface would be really cool. there actually is one by one of the authors of yhcjs (dimitry), but it's somewhat slow :(
17:10:46 <mmorrow> nax: anyway, good luck
17:11:04 <stepcut> gwern: I get invalid argument either way.
17:12:08 <nax> mmorrow: cool thanks. i'm working on a medium sized project and already have written thousands of lines of javascript. it's starting to get messy, if haskell can be used then it would rock
17:12:43 <gwern> @seen lemmih
17:12:43 <lambdabot> I saw lemmih leaving #haskell 1h 14m 50s ago, and .
17:13:11 <gwern> @tell lemmih hey, do you know that one cannot cabal-install SDL because of a missing Setup.hs?
17:13:11 <lambdabot> Consider it noted.
17:14:09 <mmorrow> nax: frig yeah. i've been having to start using javascript lately also and the prospect of having a bunch of it under control looks grim
17:14:42 <gwern> @tell lemmih at least, there is none if you don't have the sdl lib installed - which leads to a misleading error message
17:14:43 <lambdabot> Consider it noted.
17:15:29 <mmorrow> nax: you should hang out in #webhaskell, we just started it the other day. already devious schemes and so on ;)
17:15:32 * gwern plays a terrible game. http://people.cs.uu.nl/stefan/downloads/gameloop.html
17:15:32 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: Simple Maze Game
17:15:50 <gwern> I was going to cabalize it, but it's not even worthwhile sending the author a fix
17:15:58 <dcoutts> gwern: are you sure? are you using darcs version of cabal-install ?
17:16:32 <gwern> dcoutts: it seems SDL configure script autogenerates a setup.lhs
17:16:33 <gwern> or something
17:16:53 <dcoutts> gwern: I ask because I introduced and have just now identified a bug in the darcs cabal-install to do with finding Setup.hs of tarball packages
17:17:23 <gwern> dcoutts: yes, I used a darcs as of a few hours ago
17:17:36 <dcoutts> gwern: ok, it's probably my fault then
17:17:48 <dcoutts> gwern: I'll tell you when to pull the fix
17:18:27 <gwern> @tell lemmih dcoutts says it may be his fault/cabal-install's fault tho
17:18:28 <lambdabot> Consider it noted.
17:18:50 <nax> dcoutts: did you make the gtk2hs windows installer?
17:19:09 <dcoutts> nax: yep, though I didn't actually do the build for the most recent release
17:19:21 <dcoutts> gwern: he's sitting next to me, he knows :-)
17:19:29 <nax> dcoutts: could an SDL windows installer be done in the same way?
17:19:31 <stepcut> gwern: aha, I believe my version of ghc was built on a 64-bit machine :(
17:19:38 <gwern> dcoutts: the protocols must be followed!
17:19:41 <dcoutts> nax: yep
17:19:43 <dcoutts> gwern: ;-)
17:19:55 <gwern> formalities observed, etc.
17:20:15 <dcoutts> nax: the ghc installer uses the same thing, InnoSetup, it's open source, uses pascal/delphi scripting
17:20:42 <gwern> @tell dons I'm going to punt on http://haskell.org/haskellwiki/Bullet - I don't have Bullet installed and ubuntu doesn't have it
17:20:43 <lambdabot> Consider it noted.
17:21:04 <nax> dcoutts: do you think it's a good idea to have such an installer for SDL? i think lots of people have problems compiling it on windows
17:21:27 <dcoutts> nax: perhaps
17:22:02 <nax> dcoutts: where could such an installer be hosted? SDL doesn't even seem to have a homepage! :O
17:22:22 <dcoutts> nax: no idea, sorry
17:32:25 <ahunter1> Hey, does anyone know of a good linear programming library?
17:33:48 <dcoutts> gwern: ok, see if that works now, darcs pull latest cabal-install
17:35:12 <dcoutts> gwern: btw, you might like to test the new symlink-bindir feature, eg add this to the end of your .cabal/config file: symlink-bindir: /home/name/bin
17:35:56 <dcoutts> gwern: it'll add symlinks from ~/bin to ~/.cabal/bin, and it'll be careful not to overwrite anything that you have there already
17:36:04 <dcoutts> it'll only overwrite its own symlinks
17:36:44 <dcoutts> I'll turn this feature on by default at some point, so that cabal installs binaries somewhere that's actually on your path
17:46:45 * sm gets hold of some bindings to allegro game lib .. looks like a fixer-upper
17:50:19 <adu> ahunter: ya, but its for Fortran
17:50:26 <nax> allegro is awesome stuff. but old :)
17:52:36 <sm> I just learned it.. seems to work really well for typical games
17:52:47 <sm> an effective DSL
17:53:24 <sm> I have the impression SDL provides less framework
17:54:15 <nax> SDL itself is very barebones, just the nuts&bolts of what you need. but there are addon libraries for SDL that give you a lot more tools. SDL_image, SDL_mixer, SDL_graphics
17:54:34 <nax> i think the main ones even have haskell bindings
17:56:23 <nax> in terms of graphics, SDL pretty much only lets you write to memory buffers of surfaces and do blits. allegro lets you draw graphics primitives(lines, circles), it can rotate and scale images, it has some 3D routines, and it even has GUI stuff for forms and buttons
18:00:20 <Trinithis> I get the following error when I try installing GHC on Ubuntu: http://hpaste.org/9355     Any ideas?
18:02:01 <name_> can anyone explain to my why callCC isnt useless?
18:02:07 <name_> me*
18:02:21 <gwern> Trinithis: try symlinking the pwd to /bin/pwd if you don't want to try fixing the gmp problem
18:02:38 <Trinithis> gwern: english :D?
18:03:03 <Trinithis> name_: http://www.haskell.org/all_about_monads/html/contmonad.html
18:03:04 <lambdabot> Title: The Continuation monad
18:03:10 <gwern> that was perfect english
18:03:14 <gwern> minus a comma, perhaps
18:03:28 <dublpaws> theory question: is there a way to determine if two programs are equivalent without running them?
18:03:47 <name_> yea but isnt it redundant
18:03:49 <name_> for example: http://hpaste.org/9356
18:04:00 <gwern> dublpaws: not without restrictions on your domain, else it sounds like a halting problem
18:04:02 <name_> why would you bother nesting callCC's when you can just pattern match
18:04:08 <Trinithis> What is symlinking?
18:04:22 <dublpaws> gwern: ok, thanks.
18:05:18 <sal23> Trinithis: symbolic link, http://kb.iu.edu/data/abbe.html
18:05:22 <lambdabot> Title: In Unix, what is a symbolic link, and how do I create one? - Knowledge Base
18:05:28 <jsnx> preflex: msg Cale I never did get it sorted out
18:05:47 <jsnx> preflex: help
18:05:47 <preflex>  try 'help help' or see 'list' for available commands
18:05:51 <jsnx> preflex: list
18:05:51 <preflex>  Cdecl: [cdecl]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
18:06:03 <Trinithis> sal23: thx
18:06:33 <jsnx> bah
18:07:00 <jsnx> is there a good category theory mailing list? one open to amateurs?
18:08:35 <jsnx> lambdabot: help
18:23:53 <Cale> jsnx: hm?
18:24:02 <Cale> jsnx: Oh, yes, you had a question?
18:42:22 <CosmicRay> I missed the ghc darcs/git/mercurial discussion.  is it still ongoing somewhere
18:44:17 <stepcut> CosmicRay: sometimes in #ghc
18:45:45 <stepcut> CosmicRay: and remember, all revision control systems suck. Some just suck less for your particular needs ;)
18:46:46 <jeffz> CosmicRay: http://haskell.org/~duncan/ghc/%23ghc-2008-07-16.log
18:47:10 <CosmicRay> stepcut: I am well aware of this ;-) http://changelog.complete.org/posts/698-If-Version-Control-Systems-were-Airlines.html
18:47:12 <lambdabot> Title: If Version Control Systems were Airlines - The Changelog, http://tinyurl.com/ytwxyo
18:47:25 <stepcut> CosmicRay: yeah, I have read almost all your posts on RCS
18:47:40 <stepcut> CosmicRay: the airline one is probably the best ;)
18:48:03 <CosmicRay> thanks ;-)
19:05:55 <aFlag> I didn't understand most of that airline stuff :(. I have used git, darcs and subversion.
19:06:01 <aFlag> but even then I was kinda lost hehe
19:12:28 <the_edge> @pl \x -> f (g x)
19:12:29 <lambdabot> f . g
19:16:35 <Botje> the bin laden image for ghc has disappeared
19:16:46 <stepcut> heh
19:16:52 <Botje> no it's on the glasgow centre for the child and society :)
19:16:58 <stepcut> haha
19:18:45 <Botje> okay
19:18:46 <Botje> BED TIME
19:21:00 <stepcut> hrm, it seems like if I add an inotify watch right *after* a file has been modified, I will still get the watch event
19:25:37 <stepcut> I take it back, something else funny is happening with this code
19:44:54 <name_> why would you bother nesting callCC's when you can just pattern match
19:44:57 <name_> oops
19:45:09 <name_> alt-tab + up + enter'd in wrong window haha
19:48:04 <aFlag> are you some sort of octopus?
20:04:05 <roconnor> > exp(pi) - pi
20:04:10 <lambdabot>  19.999099979189474
20:06:15 <ddarius> > iterate (\x -> exp x - x) 1
20:06:16 <lambdabot>  [1.0,1.718281828459045,3.856659696301835,43.45040748963338,7.417750289644537...
20:06:38 <ddarius> > iterate (\x -> exp x - x) 0
20:06:39 <lambdabot>  [0.0,1.0,1.718281828459045,3.856659696301835,43.45040748963338,7.41775028964...
20:07:16 * Shiruka is reminded of some joke about testing floating point routine accuracy..
20:08:25 <Shiruka> where someone told ppl testing those that an expression like "exp(pi)-pi" that produces a close-to-integer value is a test that should really produce the int value, and the ppl spent a long time trying to figure out what was wrong in their routines :-P
20:12:09 <lispy> Shiruka: oh, I think that joke was on xkcd
20:13:02 <Shiruka> hmm, might be.. xkcd is very good :->
20:13:06 <roconnor> > (1+1)*((1+1)*(1+(1+1)*(1+1)))
20:13:07 <lambdabot>  20
20:13:11 <jeffz> xkcd is average
20:13:32 <roconnor> this example is in the paper I'm writing
20:13:35 <dolio> It's only good until you realize he repeats the same 5 things over and over. :)
20:13:36 <roconnor> Example xkcd217 : (exp PI - PI < 20).
20:13:36 <roconnor> R_solve_ineq (1#1)%Qpos.
20:13:36 <roconnor> Qed.
20:14:15 <Shiruka> dolio: same 5 things?-)
20:14:42 <dolio> Ideas, premises?
20:15:11 <Shiruka> I thought you'd have a list
20:15:36 <Shiruka> jeffz: what's better?-)
20:15:42 <dolio> No. It was just a snide remark.
20:17:51 <Shiruka> (other than grepping wikipedia talk pages for funny comments by silly people)
20:20:25 <jeffz> Shiruka: hmm, trying to remember the name, I think it went offline, it was named after a haskell type
20:20:58 <Shiruka> not very useful if you can't read it online :-<
20:32:27 <aFlag> is exp pi - pi exactly 20?
20:32:46 <dolio> No.
20:32:57 <roconnor> once again:
20:32:59 <roconnor> Example xkcd217B : (exp PI - PI < 20).
20:32:59 <roconnor> R_solve_ineq (1#1)%Qpos.
20:33:00 <roconnor> Qed.
20:33:02 <roconnor> :)
20:33:18 <aFlag> I didn't understand that :P
20:33:43 <roconnor> It's a proof in Coq that (exp PI - PI < 20).
20:34:07 <Shiruka> ! can it prove that completely automatically without any lemmas?
20:34:27 <roconnor> using our tactic it can
20:34:34 <roconnor> which uses some lemmas
20:35:14 <Shiruka> what does the tactic do? compute up to n significant digits and conclude it's false?
20:35:20 <roconnor> right
20:35:38 <roconnor> > exp pi - pi - 20 :: CReal
20:35:45 <lambdabot>  -0.0009000208105242327335570153309555039311
20:36:06 <roconnor> it more or less computs that, and eventually sees that it is less than 0.
20:36:47 <aFlag> what's that coq thing?
20:37:03 <Shiruka> coq is an interactive proof system
20:37:09 <Shiruka> written in ocaml
20:37:53 <Shiruka> which uses a wonky type system instead of just using ZFC like all systems which anybody uses do ;-)
20:38:26 <aFlag> hm and it proves things?
20:38:39 <Shiruka> you prove things to it and it verifies
20:39:08 <aFlag> hm
20:39:13 <Shiruka> you can write programs to help you construct the proofs though
20:39:17 <roconnor> wonky type system?
20:39:24 <roconnor> :)
20:39:35 <dolio> Like, a type system grounded in type theory?
20:39:39 <dolio> The humanity.
20:39:40 <Shiruka> wonky type system is here defined to be any type system at all instead of "just using ZFC" ;-)
20:39:54 <roconnor> :)
20:40:14 <roconnor> ZFC is a great logical system, so long as you don't actually use it.
20:40:54 <Shiruka> can't resist the jibe as most romantic math is supposedly based on ZFC, yet all formal systems people love to use type systems (preferably ones they developed) instead :-)
20:41:35 <ddarius> Shiruka: I think the only thing that claims to be based on ZFC (or something similar) is Z.
20:42:04 <roconnor> Mizar is based on a varient of ZFC.
20:42:17 <roconnor> probably close enough to make Shiruka happy.
20:42:22 <Shiruka> there's ZFC for Isabelle, but nobody uses it AFAICS
20:43:40 * roconnor shivers of the though about cutting out a hole in the rational number to stick in the integers so that Z is a subset of Q.
20:45:08 <Shiruka> my (perhaps not very accurate!) image of Mizar is "the math is nice but the system is some closed-source thingy that runs only on DOS boxen last manufactured in 1975 or something"
20:45:46 <Shiruka> (and no tactics)
20:46:07 <roconnor> I would say that the math is traditional rather that it is nice. :)
20:46:20 <roconnor> other than that, it sounds about right. :P
20:46:28 <Shiruka> nice is hereby defined equal to traditional ;-P
20:46:50 <roconnor> @quote McKinna
20:46:50 <lambdabot> No quotes match.
20:46:54 <roconnor> damn
20:47:01 <roconnor> my quote is always lost
20:47:23 <Shiruka> btw, this tactic of yours.. is it part of some project somewhere on the intarwebs?-)
20:47:34 <roconnor> It will be
20:49:00 <roconnor> 02:06:39 <swiert> damn. James McKinna has a nice quote about "equality divides us".
20:49:32 <Shiruka> it's been a while since I looked at proof systems, but Isabelle/Isar seemed the most user-friendly to me at the time
20:50:02 <Shiruka> it seems like many haskellers prefer coq though - is it because of the generating-programs thing?
20:50:45 <roconnor> @remember JamesMckinna We are once again left with the miserable prospect that it is equality that divides us.
20:50:46 <lambdabot> Good to know.
20:51:39 <Shiruka> sounds like a lamentation of a constructivist :-P
20:51:41 <roconnor> Shiruka: I guess so, or that Coq has computational semantics, which is related.
20:53:44 <newsham> shiruka: haskellers dont prefer agda?
20:53:55 <Shiruka> that, too
20:54:12 <roconnor> agda might not be a proof system.
20:54:27 <newsham> sorry, came in mid conversation.
20:54:31 <newsham> why not a proof system?
20:54:49 <roconnor> newsham: well, for one, I understand that it supports general recursion.
20:54:54 <dolio> Agda aims more at being a programming language.
20:55:02 <roconnor> although perhaps it frowns on it.
20:55:23 <newsham> roconnor: you have to provide termination proof by structural recursion unless you specify a flag to disable that check
20:55:24 <dolio> It flags things that don't pass the termination/productivity checker.
20:55:40 <roconnor> (general recursion via non-monotonic inductive types)
20:56:10 <roconnor> data Mu a = Mu (a -> Mu a)
20:56:30 <mmorrow> data Um b = Um (Um b -> b)
20:56:33 <newsham> *shrug* i dont know such things
20:56:36 <roconnor> er
20:56:38 <mmorrow> (i couldn't resist)
20:56:41 <roconnor> right, what mmorrow said
20:57:04 <dolio> That's not strictly positive.
20:57:17 <mmorrow> if i corrected you it was completely unitentional
20:57:26 <roconnor> dolio: does agda check for that?
20:57:30 <dolio> Yes.
20:57:31 <newsham> anyone wanna critique a server i wrote?  looking for was to make it faster and/or simpler.
20:57:34 <roconnor> oh
20:57:40 <newsham> ways
20:57:42 <roconnor> well, then I take it back.
20:57:43 <mmorrow> i just wanted to provide a dual datatype and say "um" in the same line
20:57:46 <dolio> Totally ruins a lot of fun stuff you can do in haskell, to. :)
20:59:00 <roconnor> mmorrow: well, you managed to correct me. :)
21:00:47 <dolio> I'm not sure if there's a way to turn off the check for strict positivity, either.
21:00:48 <mmorrow> roconnor: like i said, that was my intention all along
21:00:53 <mmorrow> ;)
21:00:55 <newsham> so is agda unsound?
21:00:56 <dolio> There is a flag for Set : Set.
21:02:13 <roconnor> ah set in set
21:02:18 <roconnor> I knew there was something :D
21:02:31 <newsham> right, but thats only if you say --shoot-myself-in-foot
21:02:36 <roconnor> How can it be a flag?
21:02:37 <dolio> Heh.
21:02:46 <roconnor> is Agda predicative otherwise?
21:02:55 <dolio> Yeah.
21:03:02 <roconnor> ah
21:03:03 <roconnor> cool
21:04:13 <Shiruka> Set : Set is enabled by the --russell flag?
21:05:17 <mmorrow> > let xs = [0..] in [ x | x <- xs, not (x `elem` xs) ]
21:05:27 * Shiruka doesn't quite know what that notation means, but sounds vaguely paradoxey
21:05:32 <lambdabot>  thread killed
21:08:48 <roconnor> the paradox is subtle
21:08:53 <roconnor> but real
21:09:54 <lispy> hmm...ambiguous type variable?
21:11:34 <mmorrow> X = { x | x ∉ X }
21:12:14 <bd_> that's not a very subtle paradox, really.
21:12:24 <roconnor> mmorrow: subtler
21:12:24 <Shiruka> does "Set : Set" allow the usual russell paradox in agda?
21:12:31 <roconnor> nope
21:12:40 <mmorrow> whoever decided that there should be the large ∉, but not a small ∊ "not an elem" definitely doesn't get my vote for voting's sake
21:12:44 <roconnor> It allows Girard's paradox
21:12:59 <bd_> hm wait
21:13:17 <roconnor> which allows you to construct the ordinal of all ordinals
21:13:28 <bd_> let xs = [0..] in [ x | x <- xs, not (x `elem` xs) ] <--  X = {x | x e xs and x !e xs } ?
21:13:29 <dolio> http://article.gmane.org/gmane.comp.lang.agda/159
21:13:31 <lambdabot> Title: Gmane -- Mail To News And Back Again
21:13:34 <bd_> therefore X = {}
21:13:51 <dolio> Apparently gmane doesn't like unicode.
21:14:32 <mmorrow> bd_: that construction is in the context of "the set of all sets"
21:14:33 <roconnor> Ah, tony's paradox is apparently simpler
21:15:01 <bd_> mmorrow: hm? surely whatever xs may be, X = {}?
21:15:54 <adu> shouldn't the topic be Topic {title="...", subtitle="...", url="...", paste="...", logs="..."}?
21:17:02 <newsham> instance Binary Topic where
21:18:05 <adu> or fromList [(Title, "..."), (Subtitle, "...")]
21:18:15 <mmorrow> bd_: but the parabox is that the fact that  the x in X = { x <--here | x /e X } is in the braces where it is, means that is *is* an elem of X. so i guess the confusion is on account of the haskell analog being "almost" a perfect analogy, but "not quite"
21:18:21 <mmorrow> heh, parabox
21:18:30 <adu> type Topic = Map TopicKey String
21:19:00 <Shiruka> paraboxical thinking
21:19:14 <mmorrow> THINK OUTSIDE OF THE PARABOX!
21:21:56 <mmorrow> bd_: being more clear/correct....  we have a set X.  suppose we fix some x.  now, suppose x *is* an element of x. then it is not. now, suppose x is *not* an element of x. then it is.
21:22:09 <mmorrow> typo
21:22:12 <mmorrow> fixing...
21:22:27 <mmorrow> bd_: being more clear/correct....  we have a set X.  suppose we fix some x.  now, suppose x *is* an element of X. then it is not. now, suppose x is *not* an element of X. then it is.
21:22:41 <mmorrow> (just forgot to capitalize the X s)
21:22:49 <bd_> hmm
21:23:01 <bd_> surely the conclusion should be that 'x' doesn't exist, and thus X = {} ?
21:23:12 <Shiruka> "think outside the box" is more tersely expressed as "think paranormally"
21:23:22 <bd_> (x e X => (x !e X)) => (X = {})
21:23:22 <mmorrow> but x exists because it is not nothing
21:23:46 <mmorrow> if it was nothing, then we couldn't have refered to it
21:24:04 <bd_> mmorrow: which means our assumption that x exists is incorrect (ie, we can prove there to be no such x via proof by contradiction)
21:24:14 <mmorrow> db_: ok, let x = {}.
21:24:39 <mmorrow> (or something)
21:24:47 <bd_> I suppose it'd help if we were more rigorous about our assumptions - my reading of the haskell one is that  forall x. (x e xs') <=> (x e xs AND x !e xs)
21:24:54 <adu> Shiruka: there is no box
21:24:57 <bd_> where xs' is the unnamed result
21:26:21 <Shiruka> the ideal proof system for haskellers would be based on category theory anyway
21:26:38 <mmorrow> bd_: err.         if x `elem` xs then not (x `elem` xs)                  it not (x `elem` xs) then x `elem` xs
21:27:07 <bd_> mmorrow: Okay, but that's not what the haskell one says...?
21:27:12 <mmorrow> exactly
21:27:17 * bd_ is confused now
21:27:38 <mmorrow> paradoxical one might say
21:27:57 <bd_> right, I'm just not seeing the connection to that haskell list comprehension :)
21:28:38 <mmorrow> the punchline is that to  say   "there exists a set of all sets" is *equivalent* to saying there exists X = { x | not (x `elem` X) }
21:28:50 <mmorrow> thus, there does not exist a set of all sets
21:29:13 <bd_> wait, how did we get here? I think we've been talking about different things the whole time XD
21:29:27 <Shiruka> proofs would be expressed in the proof monad to enforce their sequentiality and end with qedM (quod erat demonadstrum)
21:29:46 <mmorrow> heh, true
21:30:24 <mmorrow> bd_: the connection between these two follows from:
21:30:26 <mmorrow>  we have a set X.  suppose we fix some x.  now, suppose x *is* an element of X. then it is not. now, suppose x is *not* an element of X. then it is.
21:30:54 <bd_> therefore set X cannot exist as stated?
21:31:28 <mmorrow> the above impossible situation is that which a set X of all sets finds itself in
21:31:55 <dolio> Shouldn't it be: X = { x | x ∉ x }?
21:32:23 <mmorrow> yeah, if i didn't say that at some point i unsafePerformedTypo
21:32:25 <dolio> X = { x | x ∉ X } Is the set of all xs that aren't in X, which is {}.
21:32:49 <bd_> well, I think this might depend on our definition of 'set of all sets'
21:32:49 <sebaseba> a CS question for the Masters of #haskell: if I'm using Data.Map and I find out that I need to map over the elements in the Map in the same order they were inserted, does that mean I need another data structure? Or is there a simple way to adapt Data.Map to my needs?
21:32:50 <mmorrow> dolio: ahhh, but the catch is:
21:32:57 <bd_> consider X s.t:   forall x. (x = {} or (exists x'. x' E x) <=> x E X)
21:33:08 <bd_> how is X paradoxial?
21:33:13 <dolio> So the Haskell equivalent would be 'x = [ y | y <- universe, not (y `elem` y)]' but that fails to the occurs check.
21:33:18 <mmorrow> if there is some x *not* in X, then it is *in* x. but if it is *in* X, then it is *not* in X.
21:34:00 <Cale> sebaseba: How does it matter what order you map a function over the elements?
21:34:01 <lispy> sebaseba: if you need to map them in insertion order that sounds more like a list
21:34:06 <Cale> sebaseba: or do you mean fold?
21:34:14 <mmorrow> (i should have capitalized the small x in the middle there, but it should be clear)
21:34:37 <bd_> mmorrow: I'm just not seeing how that necessarily describes a set of all sets.
21:34:51 <bd_> mmorrow: I'm sure there will be some elements with undefined membership, of course
21:34:53 <rwbarton> X = { x | x ∉ X } is paradoxical in the same way that n = n + 1 is paradoxical--it's an ill-formed definition
21:34:59 <dons> gwern: re. bullet, looks pretty awesome, shouldn't be too hard to build from http://code.google.com/p/bullet/
21:34:59 <lambdabot> Title: bullet - Google Code
21:35:03 <sebaseba> Cale, lispy: I thought of using list, but I need to do lookups of keys of type String. surely Map is better for that than an assoc list?
21:35:27 <Shiruka> you could keep a separate list or use keys that are tuples of (key, someMonotonicFunction sizeOfMap)
21:35:32 <roconnor> something tells me we aren't discussing the Hurkens-Girard paradox
21:35:39 <bd_> mmorrow: looking again at the definition I proposed -- forall x. (x = {} or (exists x'. x' E x) <=> x E X) -- clearly any well-defined set should be in X; that is, the nil set, plus anything containing any element.
21:36:04 <bd_> "Sets" with ill-defined membership have ill-defined setness. No problem, surely? :)
21:36:09 <Cale> sebaseba: Map seems mostly okay, but what exactly do you mean about this mapping over the elements in a particular order?
21:36:34 <sebaseba> Shiruka: yes, I thought of that too, sounds simple enough
21:37:03 <Shiruka> erm.. except that the tuple "solution" doesn't solve anything (-.-;
21:37:05 <Cale> Or just keep a Map along with a list of the same elements.
21:37:27 <mmorrow> bd_: i think the nit we're picking has to do with the subtle difference in meaning of math "list comprehensions" and haskell list comprehensions
21:37:40 <Cale> (the list encoding the order, the Map being for fast lookup)
21:37:54 <sebaseba> Cale; the original Map is an environment of a language I'm building a compiler for, and the elements in Map might refer to previous elements already inserted in the Map
21:38:10 <bd_> mmorrow: Mostly what I'm confused about is why you'd define something like 'x = [ y | y <- universe, not (y `elem` y)]' - after all, a set can contain itself.
21:38:27 <lispy> sebaseba: that sounds like something the reader monad was designed for
21:38:32 <sebaseba> Cale: I hadn't thought of the list + Map idea. Cool!
21:38:50 <mmorrow> bd_: i also as always admit the possibility that i've made a mistake in my logic and am hopelessly driving us both to the brink of confusion ;)
21:39:23 <Cale> sebaseba: but when you're mapping a function over the map, you can pass the whole map down to each function application
21:39:30 <bd_> mmorrow: Er, I'm not seeing where the logic is in scrollback, really XD
21:39:54 <mmorrow> but i don't believe i have (made a major error in my logic), but i'm now totally confusing myself in my head
21:40:01 <Cale> Like  M.map (f myMap) myMap
21:40:26 <bd_> mmorrow: is 'x = [ y | y <- universe, not (y `elem` y)]' supposed to describe a set of all sets...?
21:40:42 <mmorrow> lemme do a quick wikipedia grope.
21:40:45 <dolio> It's the set of all non-self-inclusive sets.
21:40:51 <bd_> since X = {X}, this is not a correct definition for 'set of all sets'
21:40:53 <dolio> Which is what Russel's paradox is about.
21:40:56 <bd_> ahh
21:41:02 <bd_> okay, now it makes sense
21:41:15 <lispy> sebaseba: if i get what you're doing, then you have an environment (your map) and you want to extend it as the scope levels increase, then you want to remove stuff as you leave scopes
21:41:51 <sebaseba> Cale, lispy: I am confused. I want to convert a Map A to a Map B. The elements in A might refer to "previous" elements in A, but I can only transform those guys into B if those elements they refer to have already been inserted in B. phew!
21:42:32 <bd_> sebaseba: if you mean, the values in A lazily refer to the final value of A, then there shouldn't be a problem with what order you insert into B, I'd think?
21:42:36 <Cale> sebaseba: If you're doing it all at once, does it really matter?
21:42:40 <sebaseba> lispy: actually, there is only a single scope
21:43:16 <lispy> maybe a multimap would be better
21:43:21 <sebaseba> Cale: I have two environments A and B because I need the IO monad to build B
21:43:24 <lispy> does Haskell have a standard multimap?
21:43:33 <sebaseba> A is built in the parsing stage
21:43:37 <bd_> lispy: Data.Map.Map Key [Value] ?
21:43:38 <Cale> lispy: I use  Map a (Set a)
21:43:45 <mmorrow> dolio: ahhhh, there we go.
21:44:05 <Cale> (or b)
21:44:15 <mmorrow> *that* is the critical piece
21:44:17 <Cale> sebaseba: hmm
21:44:23 <lispy> it seems that bd_ solution would work nice here for a sufficently defined lookup
21:44:44 <lispy> lookupfirst, lookuplast might be all sebaseba needs
21:45:03 <dolio> Do you even get definitions like 'x = [y | y <- universe, not (y `elem` x)]' in set theory? It refers to itself in its definition.
21:45:34 <sebaseba> lispy: lookupfirst, lookuplast? Me no understand ;(
21:45:41 <bd_> dolio: "Assume there exists x such that x = [y | y <- universe, not (y `elem` x)]."
21:45:53 <lispy> :t lookup
21:45:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:46:03 <dolio> I mean 'x = [y | y <- universe, y `elem` x]' has the same problem. You'll never finish computing the elements of x.
21:46:30 <QtPlatypus> dolio: Not in ZFC.  Nive set theory has them but maths doesn't use nive theory for just that reson.
21:46:34 <Cale> Set theory isn't bound by petty matters like computation :)
21:46:45 <bd_> dolio: well, set comprehension notation is shorthand. The real definition would be something like forall e. e E x <=> (e E universe AND not (e E x))
21:47:02 <lispy> sebaseba: I might not understand what you want to do, but if you used Map Key [Value], then you could see if it's in A by seeing if the list has at least one element.  And check if it's in B by seeing if the list has 2 or more elements
21:47:04 <bd_> there's no ordering to how you produce the values, after all
21:47:51 <mmorrow> bd_: and the "subtle" difference between (as i called it) math "list comprehensions" and haskell list comprehensions is put in to words by wikipedia as:  "...the paradox requires nothing more than first-order logic with ***the unrestricted use of set abstraction***."
21:47:55 <dolio> Well, I wasn't sure even in naive set theory whether you could use a set in the predicates of its own definition.
21:48:04 <dolio> That seems like it'd obviously lead to problems.
21:48:11 <ski> mmorrow : in Quine's NF Set Theory, there is a universal set
21:48:11 <dolio> Russel's paradox is more subtle.
21:48:15 <Cale> Wait, what is it that's really being discussed here?
21:48:18 <lispy> data Env a = A a | AandB a a -- this might help too
21:48:22 <Cale> Russel's paradox?
21:48:49 <dolio> I thought so. It started from Girard's paradox.
21:49:18 <mmorrow> ski: interesting. is there a catch? (slash what is the definition of this universal set?)
21:49:47 <sebaseba> lispy, Cale: I'm trying to understand your ideas, this might take some time :)
21:49:58 <ski> mmorrow : the universal set is `{ x | x = x }', or simpler `{ x | true }', of course
21:50:18 <Cale> Well, having a set of all sets is not necessarily a problem, it's when you're allowed to apply comprehension to that where the problems begin. Being able to ask for the set of all sets satisfying some arbitrary criterion is too powerful not to cause a contradiction :)
21:50:36 <mmorrow> ski: ahh, i see. so it's really only exists "up to isomorphism"
21:50:50 <lispy> sebaseba: Well, I don't presume to know how to solve your problem, but I get the feeling you're doing something the hard way.  That is, there is probably an elegant solution using standard tools, that's why they exist...they have clever uses.
21:50:51 <ski> mmorrow : the idea is that each formula occurance must have a stratification
21:50:55 <Cale> Well, you also have the matter in ZFC that foundation excludes any sets which contain themselves.
21:50:58 <mmorrow> (or rather, is really only unique...)
21:51:16 <ski> mmorrow : so then it uses unrestricted comprehension with that
21:51:27 <Cale> (those also wouldn't on their own cause any problems -- A = {A} isn't a problem for consistency, it's just not the sort of object we want to call a set)
21:51:29 * roconnor shaves all people who don't shave themselves.
21:51:51 <mmorrow> ski: hm. do you have a choice link to a good overview of this?
21:52:14 * lispy thinks of x rated comments about shaving members of the opposite sex, but realizes this is not #haskell-blah and lets roconnor's comment slide :)
21:52:30 <Cale> In the words of a friend, Foundation is what keeps set theory from being a fucked up version of graph theory.
21:52:30 * mmorrow needs to sleeeeeep
21:52:30 <ski> mmorrow : not handy, no .. wp has some info on it
21:52:39 <ski> http://en.wikipedia.org/wiki/New_Foundations
21:52:39 <lambdabot> Title: New Foundations - Wikipedia, the free encyclopedia
21:52:50 <lispy> Cale: interesting
21:52:55 <sebaseba> lispy: I suspect so too.
21:53:08 <mmorrow> ski: cool. thx for the Ptr Quine
21:53:17 * mmorrow sleeps
21:53:24 <Cale> (It prevents all cycles of membership)
21:53:45 <ski> there's also a "positive set theory" which has restrictions on negations, which admits a universal set
21:54:26 * roconnor finds the impedicativity in ZFC's comprehension axiom ... unsettling.
21:54:52 <ski> Cale : then i take your friend doesn't like Aczel's Anti-Foundation axiom ? :)
21:55:03 <roconnor> OTOH, I'd find the impredicativity in the induction schema in Peano arithmetic unsettling if I didn't know better.
21:55:18 <Shiruka> roconnor: use it to device a proof that ZFC is inconsistent, instant fame :-)
21:55:24 <Shiruka> *devise
21:55:31 <roconnor> Shiruka: I've tried.
21:55:44 <roconnor> Just not hard enough.
21:56:07 <roconnor> If ZFC is inconsistent, that's where I'd put my money on the problem coming from.
21:57:16 <roconnor> well, actually the impredicativity in the collection axioms may be even more scary.
21:57:31 <ski> roconnor : there's some constructivists how take the impredicativity in induction more seriously, istr
21:57:44 <ski> s/how take/that takes/
21:58:25 <Shiruka> constructivists should take all foundational matters seriously or there isn't much point :-P
21:58:36 <Cale> ski: Well, he probably finds it somewhat interesting, but I'd have to ask him. He likes playing around with large cardinals :)
21:59:13 <ski> o-k
21:59:23 <Cale> (as in, ones which require axioms to introduce :)
21:59:28 <ddarius> It's isn't comprehension that causes problems, it's negation.
21:59:47 <Cale> ddarius: hehe
22:00:01 * ski has a book here on predicative arithmetic, by edward nelson, which he should take some time to read through
22:00:07 <Shiruka> negation of comprehension, i.e. incomprehension, does indeed cause problems
22:00:24 <sebaseba> Cale, lispy: I posted a small sample here: http://hpaste.org/9358
22:00:37 <sebaseba> of the code I'm trying to compile from
22:03:09 * Cale likes the idea of global choice / global well-ordering :)
22:04:19 * roconnor finds the idea of distiguishing one of several indistinguishable elements, also unsettling, but in a different way.
22:05:48 <name_> is there a way to transform a constructor argument within the constructor. like have Con 1 (1 +  1) produce Con 1 2 when constructed with Con 1 1
22:05:59 * Shiruka finds the idea of inequal indistinguishable mathematical elements weird
22:06:20 <Cale> name_: what?
22:06:44 <roconnor> Shiruka: so do I.  I haven't quite figured it out.  I'm guessing that they differ by predicates that are impossible to state.
22:06:53 <Cale> name_: Con 1 (1 + 1) should give Con 1 2 already
22:06:54 <roconnor> but I'm not sure.
22:07:03 <Cale> name_: But I don't understand what you mean by that last part.
22:07:05 <name_> yea but i want to be able to do Con 1 1 and get Con 1 2
22:07:21 <name_> so the constructor knows to do (1 + 1) on the 2nd arg
22:07:22 <lispy> name_: use a custom constructor function and only export the constructor if you want to
22:07:34 <Cale> name_: oh, okay, you can't do that, however, you can create a function con which applies the transformation
22:08:18 <Cale> name_: that is, write something like  con x y = Con x (y + 1)  and possibly only export  con  and not  Con  from the module.
22:08:33 <name_> ah ok
22:08:35 <name_> thanks
22:09:06 <Cale> name_: of course, you won't be allowed to pattern match using con...
22:09:06 <lispy> name_: the drawback to not exporting Con is that you won't be able to use pattern matching outside of that module
22:09:29 <TSC> lispy,Cale: what about the new view patterns?
22:09:33 <lispy> name_: generally con is refered to as a smart constructor
22:09:49 <lispy> TSC: I'm ignorant, I can't comment :)
22:09:59 <TSC> Me too (:
22:10:00 <Cale> TSC: well, they'd let you pattern match on the results of functions
22:10:14 <roconnor> stupid non-recursive branches in recursive trees.
22:10:29 <Cale> So if you had some  f (Con x y) = (x,y), then you could write  g (f -> (x,y)) = ...
22:10:36 <TSC> Are the view patterns only in not-yet-released GHC?
22:10:41 <Cale> Yes.
22:10:47 <TSC> Thanks
22:10:50 <Cale> (They'll be in 6.10
22:10:51 <Cale> )
22:10:58 <dolio> Oh, that reminds me...
22:11:09 <dolio> mmorrow: You gotten 6.9 to compile yet?
22:11:32 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns -- iirc, this page was a decent tutorial on them.
22:11:35 <lambdabot> Title: ViewPatterns - GHC - Trac
22:11:45 <ski> Shiruka : well, the idea of abstract sets is that you've abstracted away all concrete details (internal structure) about the elements .. but you can still keep external properties like inequality around separatedly
22:11:49 <Cale> (my intertubes are a bit clogged)
22:12:41 <Shiruka> intertubes :-D first thought of youtube before recalling an old /. meme
22:12:56 <roconnor> Cale: have any example of where I'd want to use ViewPatterns over Pattern Gaurds?
22:13:10 <Cale> roconnor: well, you can nest view patterns, for one
22:13:10 <mmorrow> dolio: the last successful build i did was ghc-6.9.20080619  , but i've only tried and failed with an error once since then (last week) and under "possibly i botched it separate of ghc" circumstances
22:13:20 <Cale> roconnor: also, the syntax is a bit prettier
22:13:30 <roconnor> oh
22:13:34 <ski> Cale : hm, what's the relation between those `f' and `g' ?
22:13:38 <roconnor> nesting sounds like a good argument
22:14:02 <Cale> ski: f is applied to g's parameter in order to construct a tuple which is pattern matched against (x,y)
22:14:07 <roconnor> also true about the syntax being prettier
22:14:16 <roconnor> although, it is also kinda ugly syntax too
22:14:28 <ski> Cale : ok, basically transformational patterns, then ?
22:14:32 <dolio> Are pattern guards only run once in appropriate circumstances? I can't recall.
22:14:38 <MyCatVerbs> ski: syntactic sugar, really.
22:14:43 <dolio> Er, view patterns, that is.
22:14:48 <dolio> I assume pattern guards aren't.
22:15:17 <MyCatVerbs> ski: foo (f -> bar) = baz; is equivalent to foo arg = case f arg of bar -> baz
22:15:19 <Cale> Pattern guards are also syntax sugar.
22:15:20 <roconnor> damn it, views had better terminate. :D
22:15:55 <Cale> roconnor: Their termination is as guaranteed as the termination of the functions that you apply :)
22:16:04 <MyCatVerbs> roconnor: this isn't TFP, comrade. *Nothing* is guaranteed not to terminate. What d'you think we have laziness for?
22:16:05 <lispy> what about strictness?
22:16:18 <MyCatVerbs> dolio: pattern guards? Bah! Big ol' string of if then else. :)
22:16:37 <lispy> pattern guards can be handy thouh
22:16:43 <lispy> I do like them as-is
22:16:45 <mmorrow> dolio: i just started a build on ghc-HEAD as of a few days ago. i'll report manana
22:16:49 <roconnor> But of all things that ought to terminate by the grace of Dijkstra, views ought to.
22:16:55 <dolio> mmorrow: Thanks.
22:16:59 <Cale> Oh, there's another detail about view patterns.
22:17:05 <Cale> Maybe is special
22:17:17 <roconnor> oh?
22:17:23 <Cale> => in place of that ->  will automatically unravel a Maybe
22:17:24 <dolio> That wiki page says it tries to avoid recomputing things.
22:17:25 <roconnor> Maybe is the fail of view patterns?
22:17:33 <Cale> (where Nothing is a failure to match)
22:17:53 <roconnor> well, so long as the syntax changes.
22:18:10 <Cale> Yeah, it's kind of nice actually.
22:18:23 <roconnor> Obviously the view should simply be in Maybe pattern guard.
22:18:31 <roconnor> ...
22:18:37 <roconnor> not sure if that actually makes sense
22:19:11 <MyCatVerbs> Cale: personally, I distrust that one. To me it seems like a little too much sugar. (Not like it's hard to type -> Just foo instead of => foo).
22:19:28 <MyCatVerbs> I'd be surprised if it had any practical fallout, though.
22:19:41 <dolio> So 'f (expensive -> Left foo) = ... ; f (expensive -> Right bar) = ...' should only call expensive once, ideally.
22:19:48 <Cale> It helps reduce noise in that common case.
22:20:09 <Cale> dolio: yeah, I think they're arranging for that to be the case.
22:21:28 <roconnor> I guess the semantics doesn't change
22:21:36 <Cale> Also, they're going to have a not-yet-totally-agreed-upon typeclass containing a method called view which supplies a default view
22:21:50 <roconnor> so they don't really need to mention the sharing in the formal spec?
22:21:52 <roconnor> do they?
22:21:55 <Cale> To be used when you leave the left hand side of the -> empty.
22:22:03 <Cale> roconnor: I suppose not :)
22:23:06 <roconnor> that will simplify the spec.
22:23:27 * roconnor dreams for a magic CSE algorithm to make everything better.
22:23:28 <Cale> There are funny cases with regard to repeating/not-repeating computation.
22:23:39 <Cale> Because the view might be a class method.
22:24:00 <Cale> So it's not a purely-syntactic thing, you have to look at the types to decide if you can common things up.
22:24:25 <ddarius> ski: Yes.  View patterns are a retooling of transformational patterns.
22:24:26 <Cale> f (view -> 1) = 1
22:24:26 <Cale> f (view -> "hi") = 2
22:24:36 <ddarius> TSC: It's important to note view patterns are not views.
22:24:59 <roconnor> Cale: but you can look at the type parameters in the core, right?
22:25:09 <roconnor> a common expression would be a common expression in the core.
22:25:17 <Cale> roconnor: You should be able to, yeah :)
22:26:12 * roconnor tosses F's around the room
22:28:19 <Cale> and just think, we'll be able to have quasiquoted things to construct view functions for us ;)
22:28:50 <roconnor> what's this quasiquoting?
22:28:57 <roconnor> it sounds scary
22:29:10 <ddarius> roconnor: quasiquoting:TH::reader macros:lisp macros
22:29:13 <Cale> It is a bit scary, actually.
22:29:19 <Cale> http://www.haskell.org/haskellwiki/Quasiquotation
22:29:20 <lambdabot> Title: Quasiquotation - HaskellWiki
22:29:27 <roconnor> lisp macros are scary
22:29:29 <lispy> if what ddarius says is true, then yes, scary
22:29:46 <lispy> reader macros != lisp macros
22:29:51 <lispy> (just to be clear)
22:30:04 <roconnor> oh
22:30:18 * roconnor reparses
22:30:38 * roconnor doesn't know what reader macros are
22:30:42 <lispy> reader macros are from lisp land, but they are not what people mean when they say lisp macro
22:31:15 <lispy> I didn't study them much, but the way I internalized them was that you could change the parser via macros
22:32:17 <dolio> It's not quite as scary as reader macros, is it? I mean, at least the GHC quasiquoting is clearly delineated by ugly brackets and such. :)
22:32:37 <Shiruka> nice rationalization :-)
22:33:08 * Shiruka thinks ugliness is not nice, although it's just a few extra characters :-<
22:35:01 <roconnor> every time I read SYB, I think of McBride throwing up.
22:35:04 <Cale> roconnor: Basically, it gives you this kind of bracket with two parts: the name of a parser, and an arbitrary string. The parser is applied to the string to generate a Haskell AST which is spliced in. That Haskell AST can in addition to normal syntax include antiquoted bits.
22:35:08 <roconnor> That always turns me off.
22:35:41 <ddarius> dolio: In practice reader macros are also marked and delimited.
22:35:56 <dolio> Ah. That would make sense.
22:37:04 <Cale> roconnor: So you can even use it to generate patterns, with antiquoted variable names :)
22:38:01 <Cale> (which need not actually appear in the string)
22:38:04 <roconnor> that sounds almost useful.
22:38:27 <ddarius> @where quasiquoting
22:38:28 <lambdabot> I know nothing about quasiquoting.
22:38:31 <ddarius> @where quasiquotation
22:38:31 <lambdabot> I know nothing about quasiquotation.
22:38:34 <Cale> http://www.haskell.org/haskellwiki/Quasiquotation
22:38:35 <lambdabot> Title: Quasiquotation - HaskellWiki
22:42:10 <ahunter1> Is there any good documentation for how to go about writing an interface-for-common-C-library Haskell library?
22:43:27 <ddarius> @where ffi
22:43:27 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
22:43:47 <ahunter1> thanks
22:44:04 <Axman6> I take it UNSW has a very large haskell community
22:45:07 <Axman6> or, active at least
22:45:53 <Axman6> i have a friend who just moved from UNSW to ANU with the rest of us. after hearing how much haskell stuff comes from there, i wish i'd gone there :\
22:52:21 <hackage> Uploaded to hackage: ghc-core 0.3.0.1
22:52:21 <hackage> Uploaded to hackage: permutation 0.1
22:52:21 <hackage> Uploaded to hackage: ieee 0.3
22:52:22 <hackage> Uploaded to hackage: logfloat 0.8.1
22:52:24 <hackage> Uploaded to hackage: PageIO 0.0.3
22:52:46 <dolio> Whoa.
22:53:00 <Shiruka> can you escape the io monad in ghci, except with :load? (e.g. to define new data types)
22:53:32 <dolio> No, ghci just evaluates expressions as far as I know.
22:55:24 <Shiruka> I guess the :def solution is as good as it gets, then..
22:58:00 <atp> man, why is sigfpe so awesome
22:58:31 <TSC> The floating point error?
22:58:40 <atp> no, dan piponi
22:58:43 <atp> pipponi?
22:58:45 <dolio> The man, the myth, the legend.
22:59:06 <atp> piponi, i was right the first time
22:59:09 <atp> he's a very smart guy
22:59:25 <ski> ddarius : ty
23:01:57 <Axman6> atp: link? nothing very helpful came up...
23:02:57 <Axman6> ah, think i've got it
23:03:52 <Axman6> heh, i'm pretty sure i was going to make another equibot a while ago using his stuff.
23:06:31 <orzo> does anybody code for openmoko distributions using haskell?
23:06:37 <orzo> is it suitable?
23:14:55 <dainanaki> could somebody explain to me the point of using let expressions like this:
23:15:24 <dainanaki> let Just x = lookup "bar" [("foo",1),("bar",2),("baz",3)]
23:15:33 <dainanaki> why not leave off the Just
23:15:42 <dainanaki> and have x equal all of that?
23:17:08 <orzo> lookup is a function that probably returns Nothing if "bar" isnt in the loop, if you leave  off Just, then x will = Just whatever, if you keep just then x will be just 2 in this case
23:17:34 <orzo> but if you use Just taht way and lookup returns Nothing, then tehre is an exception at runtime
23:18:04 <glguy> @seen dons
23:18:04 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 41m 6s ago.
23:18:04 <dainanaki> oh!
23:18:13 <dainanaki> ok that makes sense
23:18:28 <orzo> its actually safer to not use Just like that
23:18:33 <glguy> Would anyone care to recommend a good core colorizer and viewer script?
23:18:36 <orzo> its an irrefutable pattern
23:18:48 <orzo> i prefer to turn on warnings about irrifutable patterns because they have bitten me
23:18:57 <dainanaki> mhmm
23:19:09 <dainanaki> ok that was the example in the wikibook
23:19:22 <dainanaki> So I was figuring out the point of that
23:19:46 <dainanaki> I've never used left-side pattern matching in a let-binding
23:20:06 <dainanaki> I've seen this before too:
23:20:13 <dainanaki> let (a,b) = ...
23:20:24 <dainanaki> obviously ... is some sort of definition
23:20:48 <dainanaki> but i don't entirely see the inherent utility of doing that
23:20:51 <rwbarton> Right, same idea
23:21:14 <orzo> well
23:21:19 <orzo> that's better
23:21:22 <orzo> actually
23:21:26 <orzo> i dont mind let (a,b) =
23:21:48 <rwbarton> If you're going to then write some complicated expression which uses a and b many times, it's easier not to have to write "fst pair" and "snd pair"
23:22:01 <dainanaki> ok, i see
23:22:21 <dainanaki> that's been a source of confusion for me for a while
23:22:28 <orzo> its typical in other languages like python too
23:22:56 <dainanaki> haskell is my second real language
23:23:12 <dainanaki> i only really know java very well
23:23:29 <dainanaki> Although, I'm definitely in love with Haskell
23:23:32 <orzo> i know java less and less everyday
23:23:35 <orzo> heh
23:23:39 <dainanaki> haha as do I
23:23:59 <dainanaki> the more I learn about Haskell, the less I remember of how to program imperatively
23:24:18 <orzo> well i use c++ a lot
23:24:23 <orzo> for work
23:25:05 <orzo> i used to use python a lot for quickies
23:25:24 <orzo> i'm finding haskell is sometimes pretty good for certain quickies
23:25:27 <dainanaki> I'm going into university this year, so I don't really have a job yet
23:25:45 <dainanaki> but I'm a hobbyist haskeller for now
23:26:08 <orzo> i have incorporated haskell into my company's code base
23:26:18 <orzo> so they'll be wanting to hire haskellers in the future ;)
23:27:26 <orzo> hm
23:27:27 <orzo> in fact
23:27:44 <orzo> you should send a resume to my company so that my boss thinks haskellers are more common
23:27:50 <orzo> heh
23:28:03 <dainanaki> lol
23:28:18 <dainanaki> I'd feel better about that if I had a better grasp on monads
23:28:21 <dainanaki> among other things
23:28:35 <orzo> well you'll have a better grasp on it than i do pretty soon i'm sure
23:28:39 <dainanaki> I still can't figure out what the point of the id function is
23:28:43 <orzo> i dont really know monads well
23:28:59 <Cale> dainanaki: It is the identity for composition
23:29:01 <orzo> i'm not really a guru
23:29:04 <orzo> i just like to live dangerously
23:29:18 <Cale> dainanaki: for any function f,  f . id and id . f  are both equal to f
23:29:22 <dainanaki> Cale: sorry, I phrased that poorly. I get what it is, I just don't get the point of it
23:29:26 <glguy> dainanaki: here's a practical example:
23:29:40 <glguy> I have a function, newArr that takes a size an a function
23:29:45 <glguy> from indexes to values
23:30:02 <glguy> if I want to initialize it with indexes equaling values
23:30:04 <glguy> I use "id"
23:30:10 <glguy> newArr 5 id
23:30:21 <glguy> is an array initialized to; {0,1,2,3,4}
23:30:44 <dainanaki> oh, ok
23:30:53 <dainanaki> that's sensible
23:31:25 <Cale> Or suppose you want to write a function which takes a list of functions and composes them together end to end... what should it produce when given the empty list? (or as a recursive base case)
23:31:53 <glguy> undefined!
23:31:56 <glguy> oh, wait ;)
23:32:01 <dainanaki> haha
23:32:15 <dainanaki> I'm going out on a limb here and saying id?
23:32:20 <Cale> yes :)
23:32:58 <orzo> I run ghc 6.8.3 for ppc on an intel mac
23:33:06 <orzo> it seems to have bugs
23:33:07 * MyCatVerbs suggests (\r -> unsafePerformIO (hPutStrLn stderr "Wheeee!" >> return r)).
23:33:11 <dainanaki> why do you do that orzo?
23:33:15 <orzo> it freezes and crashes sometimes
23:33:26 <orzo> to make universal binaries, dainanaki
23:33:31 <dainanaki> ah
23:33:33 <orzo> are you familiar with mac os x coding?
23:33:33 <Cale> > foldr (.) id [(+1), (*10), (+5)] 3
23:33:39 <lambdabot>  81
23:33:41 <orzo> ghc doesn't cross compile
23:33:47 <dainanaki> orzo, yes I run ghc 6.8.3 on my mac too
23:33:54 <dainanaki> I just don't make universals
23:33:55 <orzo> so i have to run the ppc version of it in order to acheive cross compiling
23:34:05 <orzo> well i have to make universals for work
23:34:15 <dainanaki> sounds good
23:34:33 <orzo> it woudl be good if it worked perfectly
23:35:09 <orzo> but either 6.8.3 ghc has issues that earlier builds didn't, or the the cross compling method introduces some destabling aspect
23:35:35 <orzo> i use a slightly older build to compiel teh intel portions heh
23:35:35 <dainanaki> i've found that 6.8.3 upsets a decent amount of haskell code
23:35:48 <dainanaki> for example, haddock won't compile
23:36:35 <orzo> well, i'm not talking about that.  It compiles my code, most much of the time, but occasionally it freezes or crashes with some internal ghc error.  I just restart the build and it works
23:36:45 <dainanaki> ah
23:36:55 <orzo> but its embarassing for haskell to cause problems
23:37:02 <orzo> cause i'm sort of on a limb here, ya know
23:37:18 <orzo> heh
23:37:26 <dainanaki> ha indeed
23:38:09 <dainanaki> i'm surprised you can't output the code to hc files and then use gcc to compile for ppc and intel
23:38:37 <dons> glguy: ?
23:39:07 <glguy> Do you have your code script somewhere
23:39:16 <dons>  code script?
23:39:48 <orzo> dainanaki: i cannot because ghc does some extra tweeking of the otuput even when i tell it --via-c
23:40:02 <glguy> core
23:40:05 <glguy> core script
23:40:05 <dainanaki> orzo, oh that's a bummer
23:40:14 <glguy> color and mangling
23:40:17 <dons> oh, ghc-core.
23:40:19 <dons> its on hackage.
23:40:26 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core-0.3.0.1
23:40:26 <glguy> did the core get harder to read in 6.8.3
23:40:27 <lambdabot> Title: HackageDB: ghc-core-0.3.0.1, http://tinyurl.com/6xl99d
23:40:34 <dons> glguy: hmm. doubt it.
23:41:07 <glguy> seems like since 6.8.2 to 6.8.3 things changed, the type annotations seem strange to me
23:41:24 <dons> interesting.
23:41:24 <glguy> maybe its just because this code is using ST
23:41:50 <dons> i think only a few optimisation tweaks changed.
23:42:24 <orzo> i have a linux based smartphone running openmoko software.  It's an arm processor.  Any way to use haskell on that?
23:42:28 <jansz> @pl (\x -> x ++ [f x])
23:42:28 <lambdabot> ap (++) (return . f)
23:42:37 <dons> orzo: hugs and nhc will run there.
23:43:18 <orzo> thanks, dons
23:43:49 <glguy> dons: does ghc-core depend on an older hscolour becuase hscolour is a lot different now?
23:45:01 <orzo> i see hugs is packaged in openembedded :)
23:46:02 <orzo> are there dbus bindings for hugs?
23:47:08 <orzo> openmoko is apparently building a dbus infrastructure for the phone and using python for speedy devel
23:47:31 <cjb> orzo: indeed they are!  ;-)
23:47:41 <orzo> heh
23:47:50 <orzo> didn't see you there
23:48:02 <cjb> orzo: haskell works well on the ARM, people have used it on the Nokia tablets and the iPhone
23:48:11 <cjb> I think it goes -fvia-c or something, though
23:48:34 <orzo> cjb, what haskell?  ghc?
23:49:19 <dolio> glguy: At the very least, 'hscolour' has a different type in the new version.
23:49:41 <jansz> @pl (\x -> x ++ [h.g .map f $ x])
23:49:41 <lambdabot> ap (++) (return . h . g . map f)
23:49:43 <orzo> python is a good idea because its sort of a pain to cross compile everything, but hugs might be a better idea because python is probably a lot mroe prone to run time errors
23:49:46 <motus2> orzo: on Nokia, there's hugs, but no ghc yet
23:52:06 <orzo> i have a lot of experience with python run time errors, heh
23:53:03 <orzo> its like you code soemthing that works 99% of the time, but you never know what lurking bugs are in there
23:53:15 <Elly> that's why type systems are so awesome :D
23:53:28 <orzo> i had a python program crash on me the other day because i forgot to import a module bringing some symbol into scope
23:53:50 <orzo> but it was ages since i wrote the code
23:54:37 <glguy> run-time really is the best time to find out about scope problems
23:54:52 <ddarius> dainanaki: In general it is a good idea to include "trivial" cases of functions (like id and const) in libraries you design.
23:55:01 <jansz> @pl (\xs -> xs ++ [h.g .map f $ xs])
23:55:01 <lambdabot> ap (++) (return . h . g . map f)
23:55:05 <sjanssen> @remember glguy run-time really is the best time to find out about scope problems
23:55:06 <lambdabot> Okay.
23:55:09 <sjanssen> @flush
23:55:23 <orzo> was that a joke, heh
23:55:47 <dainanaki> ddarius: how exactly do you mean?
23:55:49 <sjanssen> orzo: I hope so, otherwise we have to take glguy's #haskell membership card away
23:55:56 <orzo> heh
23:56:08 <glguy> You'll have to pry it out of my cold, typesafe hands
23:57:35 <orzo> its sort of worrysome that openmoko is enthusiastic about python.  The endusers are the ones that are going to discover the hidden obscure but totally trivial bugs down the road
23:59:15 <orzo> hm
23:59:16 <cjb> OLPC uses Python too.
23:59:26 <orzo> i've seen bitbake crash with python runtime exceptions
23:59:27 <ski> dainanaki : e.g. in a datatype for documents with layout, it can be useful to include a constant for the empty document
23:59:28 <sjanssen> yeah, though you've got to realize what the alternatives are
23:59:39 <cjb> And no-one uses Haskell.  So you might be more introspective about why people are choosing python.  :)
23:59:51 <sjanssen> C isn't really better -- a segfault is just as bad as a scope error
