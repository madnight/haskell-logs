00:00:21 <lispy> dons: so is it common for different datastructures to have wildly different zipper interfaces?
00:00:33 <lispy> dons: or are they mostly the same?
00:00:36 <janszn> @pl (\xs -> zip xs (zipWith (++) (inits xs) (tail (tails xs))))
00:00:37 <lambdabot> ap zip (ap (zipWith (++) . inits) (tail . tails))
00:01:16 <codacola> >foldr (+) [1,2,3,4,5]
00:06:57 <moozilla> > 0x12345 .&. 0x0FFF
00:06:58 <lambdabot>  Add a type signature
00:07:03 <moozilla> > 0x12345 .&. 0x0FFF :: Int
00:07:05 <lambdabot>  837
00:07:19 <moozilla> @pl 0x12345 .&. 0x0FFF :: Int
00:07:20 <lambdabot> 74565 .&. 4095 :: Int
00:11:15 <dons> lispy, they're mostly the same. parent, child, left, right.
00:11:52 <lispy> dons: ah, so making a type class should be reasonable
00:12:21 <lispy> and I should look at sequence sometime
00:12:37 <lispy> Actually, I would like to add our forward and backward lists as a standard library
00:12:42 <lispy> and remove it from darcs
00:12:53 <lispy> and make it zipperable, tec
00:24:08 <codacola> ok im conufsed. why does haskell claim 1.0 is a double and not a float?
00:24:40 <dons> it's just a floating point literal
00:24:45 <dons> so it's overloaded.
00:24:48 <lispy> > 1.0 :: Float
00:24:50 <dons> by default it defaults to Double
00:24:51 <lambdabot>  1.0
00:24:54 <dons> :t 1.0
00:24:54 <Deewiant> ?ty 1.0
00:24:55 <lambdabot> forall t. (Fractional t) => t
00:24:56 <lambdabot> forall t. (Fractional t) => t
00:25:01 <dons> but see, it's polymorphic :)
00:25:03 <dons> :t 1
00:25:04 <lambdabot> forall t. (Num t) => t
00:25:06 <dons> :t 1 :: Double
00:25:07 <lambdabot> Double
00:25:11 <dons> pretty funky.
00:25:23 <dons> you could make strings an instance of numeric literals, if you want :)
00:26:03 <codacola> ok another question, do people here prefer to have spaces between their function definitions of teh same function (with different patterns)?
00:26:10 <codacola> well lines between
00:26:20 <janszn> @pl (\xs -> zip xs (map (flip delete xs) xs))
00:26:20 <lambdabot> ap zip (map =<< flip delete)
00:26:22 <dons> nope.
00:26:27 <dons> f [] = 0
00:26:32 <dons> f (_:xs) = 1 + f xs
00:26:59 <codacola> weird, i find it more readable if i have spaces
00:27:19 <dons> i guess you get used to it.
00:27:28 <dons> f ys = case ys of
00:27:30 <dons>   [] -> 0
00:27:37 <dons>    (_:xs) = 1 + f xs
00:30:39 <codacola> http://pastebin.com/d66dbfc3 <- an example from what im writing now
00:31:18 <Bacta> what's ur fav posish?
00:31:20 <Bacta> that's cool with me
00:31:27 <Bacta> it's not my favourite but i'll do it for you
00:31:42 <Bacta> whats your favourite dish? i'm not gonna cook it but i'll order it from ZANZIBARR
00:31:48 <Bacta> and then i'm gonna love you completely
00:31:54 <lispy> dons: kick please?
00:31:54 <Bacta> and then i'll fucking fuck you discretely
00:32:00 <Bacta> and then i'll fucking bone you completely
00:32:08 <Bacta> and then, i'm gonna fuckkkkkkkkkkkkkkkkk youuuuuuuuuuuuuuu harddddddddddddddddddddddddd
00:32:11 <codacola> arent those teh same thing?
00:32:13 <Bacta> harrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrddddddddddddddddddddddddddddddddddddddddddddddddd
00:32:39 --- mode: ChanServ set +o dons
00:32:42 --- mode: dons set +b *!*n=Thomas@unaffiliated/bacta
00:32:42 --- kick: Bacta was kicked by dons (dons)
00:32:53 <codacola> hm, i really should use a fold for multiplying vectors
00:33:05 <lispy> dons: thanks, I'mm too slow...was just reading how to do a kick on the freenode page :)
00:33:21 <dons> wow, now he's privmsging me.
00:33:22 <dons> awesome.
00:33:43 <glguy> --> -ops
00:34:30 <lispy> I need to make a cheat sheet of the commands
00:34:41 <lispy> I don't use them enough to remember them
00:36:36 --- mode: ChanServ set +o lispy
00:37:07 --- mode: ChanServ set +o lispy
00:37:18 <codacola> lispy: oh oh! use haskell!
00:37:26 <|Steve|> discretely, eh?
00:38:27 <|Steve|> /kick is hard to remember?
00:38:31 <|Steve|> /kickban?
00:38:39 --- mode: ChanServ set -o dons
00:38:52 --- mode: ChanServ set -o lispy
00:40:38 <|Steve|> :t liftIO
00:40:40 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:41:27 <wolgo> how common is it to have to use an if statement to check inequalities for a large number of objects?
00:41:37 <wolgo> err values, sorry
00:42:18 <|Steve|> What do you mean?
00:43:09 <codacola> yay
00:43:14 <codacola> got an error ive never had before
00:44:03 <wolgo> like take N number of integers and pair that largest and smallest numbers
00:44:31 <wolgo> there are some exercises I am working through that are these ridiculously long if then else if then else chains and this tedium sucks
00:44:41 <wolgo> that have*
00:45:07 <codacola> Cannot use type synonym in instance head
00:45:20 <wolgo> I guess the point is to teach the use of control structures but this is ridiculous.
00:45:56 * codacola hasnt used if statements in haskell yet
00:46:02 <wagle> this is sortas programming languages issue:  i want a command/function in bash that takes a string as input, and outputs a string (with escapes, etc) that when read back in (as an argument), will be parsed as a single argument..  i've searched and googled around, and havent found anything..  any ideas on what sorts of keywords i might look for?
00:46:03 <|Steve|> > let xs = [1,8,2,8,7,2,9,10] in zip (reverse $ sort xs) (sort xs)
00:46:05 <lambdabot>  [(10,1),(9,2),(8,2),(8,7),(7,8),(2,8),(2,9),(1,10)]
00:46:40 <|Steve|> wagle: Read in how?
00:46:44 <atp> wolgo: i think if you're doing stuff with long chains of if statements, you're probably doing it wrong
00:46:47 <lispy> > 1/0 - 10
00:46:49 <lambdabot>  Infinity
00:47:21 <wagle> input string is $foo'baz
00:47:28 <wolgo> atp: well that is the solution the book has :) so the book is doing it wrong and I agree hahah
00:47:39 <wagle> output string is '$foo\'baz'
00:47:40 <atp> wolgo: most likely
00:47:52 <wagle> or maybe \$foo\'baz
00:47:53 <wolgo> The topic is control structures
00:48:12 <wolgo> so there is this exercise, given N numbers take the largest and smallest
00:48:28 <wolgo> And it is tedious
00:48:52 <|Steve|> > maximum [4,28,9,10,02,48]
00:48:53 <wolgo> I hope that the next 3.5 years of CS is not like this. I will switch to math
00:48:54 <lambdabot>  48
00:48:59 <codacola> instance Num [Float] where <- whats wrong with that?
00:49:05 --- mode: ChanServ set +o dons
00:49:12 --- mode: dons set -b *!*n=Thomas@unaffiliated/bacta
00:49:12 <wolgo> I would just use the std lib functions
00:49:16 --- mode: ChanServ set -o dons
00:49:16 <atp> codacola: you'll need to newtype it
00:49:20 <wagle> spaces in the string would cause the string being echo'd to be read in as multiple arguments
00:49:42 <|Steve|> wagle: Once again, read by what?
00:50:08 <wagle> i used the word read above
00:50:20 <codacola> atp: ok, now im confused
00:51:04 <|Steve|> Yes you did and you didn't answer my question so I've decided to not care.
00:51:33 <name_> anyone know how to get the hOpengl renderString to actually work haha
00:51:41 <name_> guess its in the glut binding but w/e
00:52:35 <wagle> actually, you didnt read my question, so you wouldnt have helped anyway..  thanks!
00:53:07 --- mode: ChanServ set +o glguy
00:53:12 --- mode: glguy set -b *!*@84.79.67.*
00:53:23 --- mode: glguy set -o glguy
00:54:37 <atp> codacola: you can't generally make [Float] or [Integer] or [String] or whatever instances of a class, without using a ghc extension that allows it
00:54:52 <|Steve|> I did read your question, you asked about output to be read by something as a single argument without saying what that something was.
00:54:54 <atp> codacola: you can use the extension, and nothing will break, if you want.  but it won't be valid haskell 98
00:55:23 <atp> codacola: what you can do however is say newtype FList = FList [Float] or something and then make FList an instance
00:55:44 <codacola> ok, so ive got a type Vector = [Float], to make haskell 98 code, can i not include them in the num class?
00:55:58 <codacola> hm
00:56:37 <wolgo> Can someone give me some advice? When writing sorting algorithms for huge lists does one use a bunch of if then else statements? This will determine my academic career hahah
00:56:45 <codacola> ok, the "newtype" keyword seems a lot like the data one....
00:56:58 <atp> codacola: it is similar
00:57:08 <atp> codacola: but newtype creates a type isomorphism
00:57:17 <atp> codacola: whereas data does not create an isomorphism
00:57:28 <atp> codacola: this is a subtle distinction and one you don't need to worry about if you don't want
00:57:59 <atp> codacola: if you prefer, you can think of newtype as a special, more efficient "data" that is more restrictive (you cannot do newtype Foo = Bar | Baz, for example)
00:57:59 <jeffz> wolgo: have you read an introductory tutorial on Haskell yet?  doing so would have introduced you to using case and pattern matching
00:58:06 <|Steve|> wolgo: No, we use sorts like merge sort.
00:58:32 <wolgo> oooo shiny
00:58:48 <wolgo> literate programs has a quicksort that is made of list comprehensions
00:59:08 <wolgo> Actually I am learning ML, but this room has more activity (sorry)
01:00:14 <|Steve|> > let qs [] = []; qs (x:xs) = (qs (filter (<=x) xs)) ++ x:(qs filter (>x) xs) in qs [1,8,2,0,7,8,29,0,7]
01:00:16 <lambdabot>  Couldn't match expected type `(a -> Bool) -> [a] -> [a]'
01:00:30 <codacola> atp: heh sorry missed all of that., went ahead and started using data :P
01:00:32 <|Steve|> > let qs [] = []; qs (x:xs) = (qs (filter (<=x) xs)) ++ x:(qs (filter (>x) xs)) in qs [1,8,2,0,7,8,29,0,7]
01:00:34 <lambdabot>  [0,0,1,2,7,7,8,8,29]
01:00:34 <codacola> now ive gotta define it over Eq
01:00:35 <jeffz> I don't get literateprograms, why don't they just contribute to rosettacode?
01:01:13 <wolgo> wow that does it
01:01:19 <wolgo> this ml book is garbage
01:02:01 <besiria> xb
01:02:13 <besiria> ah those emacs keybindings
01:02:21 <wolgo> Thanks |Steve| for opening my eyes.
01:02:33 <|Steve|> wolgo: np.
01:02:48 <wolgo> not to mention mlton takes FOREVER to create bytecode
01:03:39 <|Steve|> Reminds me of the question we asked of the programming language undergrads earlier this summer: write a merge function and a merge sort function using merge in scheme. More than one student wrote merge in terms of the builtin sort function.
01:03:40 <besiria> i can't even build mlton. mayb i need some extra gigs of ram
01:04:01 <dons> wolgo: hah
01:04:12 <dons> wolgo: RWH is waiting for you :)
01:04:17 <|Steve|> Something like (define (merge lst1 lst2) (sort (append lst1 lst2)))
01:04:32 <dzlk> scheme has a built-in sort function?
01:04:41 <|Steve|> plt scheme does at least.
01:04:48 <dzlk> ah.
01:05:20 <|Steve|> It might take a binary function to use as a sorter.
01:05:52 <|Steve|> In fact, I think it something like (sort lst <), but I tend to forget scheme as soon as I finish teaching it.
01:06:02 <|Steve|> s/it/it is/
01:06:46 <erikc_> how are multi-parameter type class functions implemented under the covers? are multiple dictionaries passed? how are those combined to point to a single function to dispatch to?
01:06:51 <lispy> what is the O of intersect?
01:06:51 <|Steve|> Yeah, that works in guile (I don't seem to have mzscheme installed any more).
01:06:56 <lispy> ?src intersect
01:06:56 <lambdabot> intersect = intersectBy (==)
01:07:02 <lispy> :t intersect
01:07:03 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
01:07:05 <|Steve|> The O of intersect?
01:07:11 <lispy> yeah the big-O
01:07:29 <|Steve|> Presumably O(n log n) in general.
01:07:32 <dzlk> hm, chicken has it too. I never knew it existed.
01:07:48 <|Steve|> @src intersectBy
01:07:48 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
01:07:54 <lispy> |Steve|: but it only uses Eq, so hmm
01:08:00 <|Steve|> Oh, right, so quadratic.
01:09:01 <lispy> I doubt I have an Ord instaenc
01:09:10 <lispy> I may be stuck with quadratic
01:09:34 <|Steve|> The definition given there is clearly O(nm) where xs has size n and ys has size m.
01:10:10 <|Steve|> > take 10 $ intersect [1..] [1,3..]
01:10:13 <lambdabot>  [1
01:10:26 <|Steve|> > take 10 $ intersect [1,3..] [1..]
01:10:28 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
01:10:29 <lispy> oh, no I do have an ord instance
01:10:44 <lispy> But sorting these guys might actually be slower
01:11:02 <|Steve|> That's pretty lame. I can intersect with an infinite list but only if it's in the right order.
01:11:15 <dons> heh
01:11:20 <dons> infinity is so lame.
01:11:44 <lispy> ?quote infinite
01:11:45 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
01:11:45 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
01:11:54 <lispy> ?quote lispy.infinite
01:11:55 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
01:11:58 <lispy> ah well
01:12:06 <lispy> it's lost forever :)
01:15:47 <codacola> ok, if i want a list in a datatype would i generally use a recursive data structure? eg data Vector = Vector Float Vector | NullVector ?
01:26:50 --- mode: irc.freenode.net set +o ChanServ
01:28:22 <wolgo> Yeah
01:28:33 <wolgo> I am just going to dedicate myself to haskell
01:28:48 <wolgo> this other stuff is garbage and does nothing but confuse noobs like me
01:28:56 <codacola> ?
01:29:26 <codacola> this is why popularity is bad. whenever theres a netsplit people lose their buffers
01:31:32 <codacola> class Num
01:37:55 <dons> heya tibbe
01:38:07 <dons> codacola: heh. there are logs though
01:39:15 <glguy> codacola: I tend to re-using the existing data types, so: newtype Vector a = Vector [a]
01:40:25 <codacola> glguy: this is a good way for me to get into both classes and data types
01:44:23 <besiria> wow , there is no darcs2 ebuild in portage. i'm shocked
01:45:45 <sereven> besiria: 2.0.0 and 2.0.0 are ~arch in haskell overlay
01:45:59 <sereven> err 2.0.2
01:46:05 <quicksilver> codacola: if you reuse an existing recursive type ([a]) you can reuse existing useful functions like map and fold.
01:46:06 <codacola> never knew haskell could be so much fun
01:46:21 <quicksilver> codacola: if you define your own new recursive type you have to write them again
01:46:38 <codacola> quicksilver: if i dont do it this way i wont learn anything about data types
01:46:54 <codacola> im not making somethingt o be useful,im making something to learn
01:48:22 <quicksilver> in that case, yes.
01:49:01 <codacola> oh bugger, * has to return another Vector
01:49:22 <codacola> then again, a scaler is a vector
01:50:40 <quicksilver> vectors don't make very natural instances of Num
01:50:52 <quicksilver> although you maye find it interesting to explore :)
01:51:38 <codacola> http://pastebin.com/d1a37386
01:51:40 <codacola> so far
01:53:25 <besiria> sereven: would it be better to try darcs-cabalized?
01:54:09 <quicksilver> I personal use different operators for vectors
01:54:20 <quicksilver> ^+^, ^-^, *^ and ^/
01:54:32 <quicksilver> ^*^ for x-product for 3-vectors.
01:54:37 <quicksilver> ^.^
01:56:00 <codacola> can i ask why?
01:56:00 <ndmitchell> @seen dcoutts
01:56:01 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
01:56:04 <ndmitchell> @seen dcoutts_
01:56:05 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 15h 5m 59s ago.
01:58:27 <besiria> what if i have multiple versions of a package installed? would it pick the most recent version by default when i import it
02:01:27 <sereven> besiria: afaik portage uses caball install it just saves you some typing if you want a system wide install. If you want user, then yeah use cabal install. I'm no haskell portage guru. The few times I've had multiple versions I've used ghc-pkg to configure them. #gentoo-haskell is where the gentoo haskell devs hang out.
02:01:55 <quicksilver> codacola: because Num isn't a good match :)
02:02:03 <codacola> ah
02:02:17 <quicksilver> because * doesn't make sense between all vectors (just 3-vectors)
02:02:22 <besiria> sereven: ty
02:02:29 <quicksilver> because you also want scalar multiplication (and possibly division)
02:02:35 <codacola> quicksilver: out of curosity. are lists simply a recursive type with [] being a constructor?
02:02:58 <quicksilver> yes.
02:03:09 <quicksilver> they have a bit of special syntax, but otherwise they are normal
02:03:21 <quicksilver> data [a] = [] | (a : [a])
02:03:36 <quicksilver> -- not actually legal haskell because [] and : are reserved.
02:03:38 <quicksilver> but that's the idea.
02:03:44 <codacola> ah
02:03:52 <quicksilver> Of course you can't define your own 'outfix' operators like [.]
02:04:03 <quicksilver> but syntax aside lists aren't special.
02:04:13 <dmhouse> [a, b, c] is also sugar
02:04:16 <dmhouse> As is "abc".
02:04:33 <dmhouse> (For a:b:c:[] and 'a':'b':'c':[] respectively.)
02:05:48 <dmhouse> codacola: Num is really for fields
02:06:19 <codacola> still, im going to ignore practical advise and do it anyway for the sake of learning :P
02:06:31 <quicksilver> it's a perfectly interesting exercise.
02:06:47 <quicksilver> you'll learn some things about the problems with Num ;)
02:07:15 <codacola> my last haskell lab took 2 hours when it should have taken 1. got lectured on not using vista
02:07:44 <dmhouse> codacola: if you want a better fitting exercise, you could make an instance of Num for Z/Z_p
02:07:56 <dmhouse> I.e. modular arithmetic modulo a prime, which forms a field.
02:07:57 * quicksilver sheds tears at the idea of a computer lab suggesting you should use vista.
02:09:29 <codacola> quicksilver: no no, he was telling me not to use vista
02:10:21 <codacola> i said "where are the msdn dvd images?" and he gave me a speech on "tell all your friends...." (in a very obviously dull voice) then said "you look very happy, what do you want?"
02:10:26 <codacola> is aid "vista and visual studio"
02:10:47 <codacola> he said "would you like a sticker" and showed me a "bad vista" sticker. then gave me a speech on why not to use vista
02:11:25 <Zao> codacola: So just ignore the ignorant git?
02:11:44 <Zao> You should take some time and insult his distro of choice.
02:12:20 <codacola> Zao: no, he goes "why do you want vs anyway? you should use linux to develop" and i said "i do, but monodevelop sucks"
02:12:31 <codacola> so then he suggested i use a virtual machine
02:12:37 <codacola> windows runs slow enough as it is :|
02:12:53 <codacola> anyways, he uses gentoo. didnt really feel like insulting it
02:13:11 <dmhouse> Too easy a target?
02:13:24 <codacola> its gentoo, everyone hates gentoo
02:13:29 <codacola> plus i was getting sick of his speech
02:14:13 <codacola> then he showed me notepad+, and i said "not as nice as vim with bash". that shocked him. "where do you work?" "i dont" "but you use vim?" "yeha...." "where?" "at home...."
02:15:09 <codacola> then got told i should use kate instead
02:15:22 <dmhouse> Heh.
02:16:00 <codacola> in anycase, i got my sticker
02:16:10 <codacola> after he was finished i said "can i still have my sticker too?"
02:16:25 <codacola> he promised me a sticker if i signed up to badvista.org
02:17:29 <jeffz> freedom before convenience doesn't work for everyone.
02:21:11 * codacola waits for ms to make a haskell compiler
02:23:17 <jeffz> codacola: Microsoft Research employs people to work on GHC
02:23:30 <astrobunny> hrh
02:23:33 <codacola> cool. thye should integrate it into cs
02:23:34 <astrobunny> heh*
02:23:34 <codacola> vs
02:23:40 <astrobunny> really?
02:23:40 <lispy> codacola: they did
02:23:45 <lispy> codacola: visual haskell existst
02:23:47 <codacola> they did?
02:23:48 <astrobunny> i thought they were doing F#
02:23:53 <codacola> cool
02:23:55 <codacola> must learn more
02:23:58 <astrobunny> are they working on haskell too?
02:24:00 <codacola> should learn f# too
02:24:45 <lispy> F# is very similar to ocaml
02:24:55 <lispy> so if you know that language it will be familiar
02:25:10 <lispy> but, I think they're making some headway now into improving it over standard ocaml
02:25:17 <lispy> I hope they add type classes
02:25:40 <codacola> no idea what ocaml is
02:25:51 <codacola> how similiar is f# to haskell?
02:26:01 <dobblego> very dissimilar
02:26:07 <Heffalump> not very, apart from being a functional language
02:26:18 <Heffalump> F# is fully .NET integrated
02:26:19 <flux> well, F# and haskell are more similar than, say, C++ and haskell?
02:26:21 <Heffalump> F# is strict
02:26:28 <Heffalump> Haskell has a much richer type system and is lazy
02:26:48 <flux> depends perhaps what one views as a distinctive characteristics, though
02:26:54 <codacola> hm, so i could use f# with asp?
02:26:58 <Mr_Awesome> haskell has the richest type system of any language i've ever used
02:29:14 <lispy> if F# had GADTs, existential types and type classes, I'd probably be pushing for it very hard where I work since we seem to be pretty .NET friendly.  But, ya, maybe I should push for it anyway.
02:29:26 <Heffalump> it has the richest type system of any language in significant use, perhaps excepting the theorem provers
02:29:48 <Heffalump> you can nearly simulate type classes with reflection, just without static safety
02:30:10 <lispy> type classes are already unsafe in some ways
02:30:27 <dmhouse> lispy: in what ways?
02:31:01 <lispy> It's hard to explain this.  Either poorly designed class interface or poorly thoughtout instances leads to a leaky abstraction
02:31:18 <lispy> So, then if you use that type class methods but get an "unexpected" instance you could get unplanned for behavior
02:31:24 <Heffalump> that's not unsafe in the same way as "this might fail at runtime" is. Though you can get that with defaulting.
02:31:27 <Heffalump> or lack thereof
02:32:27 <lispy> Heffalump: I had some problems in Darcs recently where I accidentally caused the wrong instances of RepoPatch to be inferred and it did cause run-time errors because then darcs parsed the wrong type of data :)
02:32:48 <lispy> (differen than the type of run-time error you mean, I know)
02:32:55 <lispy> in my cause it's because my abstraction was a bit leaky
02:33:34 <eu-prleu-peupeu> hello people from planet Haskell
02:34:03 <lispy> But, type classes would still go a long way to improving ocaml.  It would allow for "overloading" which is one of the biggest critcisms of the language
02:34:49 <lispy> My next nitpick with ocaml is that pattern matching isn't as convienent as it is in Haskell
02:35:01 <lispy> but for the most part it's a cool language
02:35:10 <lispy> if I didn't have haskell I'd probably be hacking ocmal
02:35:13 <eu-prleu-peupeu> well, i really dislike the "rec" and the "+." stuff in Ocaml :/
02:35:13 <lispy> er ocaml
02:35:26 <besiria> is there a big diff between ocaml and sml?
02:35:37 <lispy> The "+." could be fixed with type classes
02:35:51 <lispy> besiria: i'm not sure, I think ocaml adds objects
02:35:57 <lispy> besiria: like OO style things
02:35:59 <codacola> eu-prleu-peupeu: do you like f#?
02:36:14 <eu-prleu-peupeu> i haven't done anything in f# :/
02:36:25 <besiria> for the functional stuff, i prefer sml cause i find the ocaml syntax a bit awkard, but that's just me
02:36:51 <eu-prleu-peupeu> i tend to avoid .net stuff, because of m$ past :/
02:36:55 <lispy> http://research.microsoft.com/fsharp/language-compare.aspx
02:37:00 <codacola> thats weird, i dont recall f# being in the "other languages" option in vs 2008
02:37:21 <codacola> and cant really check until i reboot
02:37:50 <lispy> I wonder if the F# impl is under any sort of shared source license
02:38:02 <lispy> codacola: you need to go download it
02:38:05 <lispy> codacola: it's not bundlede
02:39:12 <povman> hi - does anyone know where the haskell nehe tutorials are? i remember them being somewhere on haskell.org
02:39:34 <lispy> povman: I have them on my server, maybe they made it to hackage
02:39:37 <lispy> ?where nehe-tuts
02:39:37 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
02:39:46 <povman> :-O
02:39:51 * lispy started them
02:40:04 <povman> 1337, thanks you're awesome etc
02:40:11 <lispy> heeh, you're welcome
02:40:19 <jeffz> lispy++
02:40:20 <lispy> you should write the next tutorial and send me the patches :)
02:40:27 <lispy> I never finished
02:40:34 <povman> maybe
02:40:43 <povman> i actually got up to 6 before realising someone had already done them
02:40:45 <lispy> there is no try, do or do not -- yoda ;)
02:40:57 <lispy> hah, cool
02:41:04 <codacola> lispy: then how the hell did 2008 end up as over 1 gig?
02:41:15 <lispy> codacola: lol, no idea
02:41:39 <codacola> i also grabbed sql server and xp
02:41:58 <codacola> though cant use xp on here, still cant find drivers
02:42:28 * lispy hugs his overpriced macbook pro
02:42:49 <mornfall> Oh. GL 3 has been released. Interesting.
02:43:04 <lispy> mornfall: yes and we need someone to update HOpenGL, is that you?
02:43:26 <lispy> let's get coding people!
02:43:38 <lispy> type it! type it! c'mon!
02:43:46 <codacola> lispy: i got an hp dv6000, lovely system, but no drivers for xp as far as i can see
02:43:51 <quicksilver> GL3 doesn't add much that hopengl would care about.
02:44:03 <quicksilver> a couple of new texture types
02:44:20 <quicksilver> some new glsl stuff but that doesn't actually matter since hopengl just passes the GLSL through as text to the driver anyway.
02:44:40 <mornfall> lispy: No not me. I know zilch about GL (or HOpenGL). And, -ENOTIME. You want me on darcs, seriously. :)
02:44:45 <quicksilver> hopengl support for some of the recent extentions would be nice though: FBOs and MRT.
02:44:55 <lispy> mornfall: darcs it is :)
02:45:01 <lispy> mornfall: You'll hear no complaints
02:45:09 <codacola> hm, i really should look at opengl someday
02:45:28 <lispy> but, mornfall brings up a good point.  we need more people on darcs
02:46:23 <mornfall> lispy: That, or extending the day to 40+ hours. I guess the "more people" approach wins...
02:46:45 <lispy> mornfall: parallelism
02:48:36 <codacola> anyone know what features business vista lacks over ultimate?
02:49:03 <jeffz> codacola: you could try asking in a channel where it's on-topic like #windows
02:49:20 <Zao> Or -blah
02:56:42 <lispy> g'niht
02:56:48 <lispy> g'night*
02:58:30 <povman> apparently lots of people are disappointed by gl3
02:59:30 <znutar> yeah, I read that.  No idea why, though.
03:04:01 <znutar> ah, they didn't do the changes to immutable atomically created object management
05:17:34 <hask> why are so many haskell-papers published in postscript and no alternatives? html and if not pdf over ps please...
05:18:00 <dmhouse> Really? Most Haskell papers I've found have PDF versions.
05:18:02 <gweiqi> you can make a pdf from ps using ghostscript
05:18:12 <dmhouse> hask: what's wrong with PS anyway?
05:18:16 <quicksilver> PS has been the traditional format for LaTeX for quite a while now.
05:18:22 <quicksilver> just run ps2pdf if you prefer pdf.
05:18:40 <gweiqi> he might be on windows
05:18:52 * kowey lobbies for putting the .tex online as well for blind haskellers ;-)
05:18:58 <ivanm> dmhouse: you can search pdf...
05:19:02 <dzlk> there's a ghostscript for windows.
05:19:06 <ivanm> you can copy text out of pdf...
05:19:22 <ivanm> the pdf viewers are usually better than the ps ones (continous page views!)
05:20:21 <dmhouse> ivanm: I have all three of those features in my PS viewer.
05:20:34 <dmhouse> In fact, I'm pretty sure it's the same feature that reads PDFs and PSs.
05:20:50 <dmhouse> (Evince for GNOME, by the way.)
05:21:07 <dmhouse> Oh, wait a minute.
05:21:07 <ivanm> yeah, I'm using okular inside xfce
05:21:17 <ivanm> but you still can't search the ps files in evince IIRC...
05:21:26 <dmhouse> You're right about the first two. Hmm. I wonder why I've never noticed that before.
05:21:29 <mmorrow> heh, i was just dealing with a pdf annoyance
05:21:40 <ivanm> okular can if you open the ps file as pdf (which it does so by running ps2pdf on it AFAIK...)
05:21:49 <ivanm> mmorrow: oh? like what?
05:22:37 <mmorrow> so i got the huge unicode chart pdf, and wanted to extract the individual images of each char
05:22:44 <mmorrow> but the pdf was encrypted ...
05:22:51 <ivanm> ahhhh
05:22:57 <ivanm> that's one advantage of ps over pdf...
05:23:12 <ivanm> mmorrow: were you able to print the pdf to a pdf-printer?
05:23:49 <mmorrow> so first do   pdf2ps _.pdf _.ps, then pdfopt  for good measure. finally, just do  pdf2html ... and all the desired images are dumped to the pwd :)
05:23:58 <ivanm> heh
05:23:59 <mmorrow> haha!
05:24:37 <mmorrow> i ran out of disc space after 2GB with the unicode dump. gonna have to wait until i can dump somewhere other than my laptop
05:24:41 <ivanm> or just open it in a pdf viewer that can ignore drm... >_>
05:24:45 <ivanm> heh
05:24:56 <mmorrow> exactly
05:25:56 <mmorrow> i'm not sure i'd call it "drm", though (although i noticed at least on prog had a -nodrm option) ... it's more "encryption"
05:26:30 <mmorrow> although drm *is* encryption, the fact that the owner encrypted it makes it different
05:26:30 <ivanm> well, it has to unencrypt it to view it... then it just ignores the Digital Restriction Management garbage... ;-)
05:26:45 <ivanm> it restricts what you can do with it, ergo it's DRM :p
05:27:34 <Zao> ivanm: Doesn't the R usually stand for Rights?
05:27:48 <mmorrow> ha, apparently adobe just indicates in the pdf whether to "not allow printing" or ,..., but it's up to the viewer to say "sorry, i can't do that, dave"
05:27:49 <ski> only in newspeak
05:28:08 * mmorrow gets the links he collected on pdf encryption
05:28:11 * Zao sets the evil bit on all ski's packets.
05:28:13 <ivanm> Zao: I like RMS' view on it ;-)
05:28:53 <dmhouse> mmorrow: well, the viewer has to display the PDF somehow. How could you write a document format which allowed itself to be displayed, but not to be printed?
05:29:05 <mmorrow> unless it's one of the newest adobe pdf version, which optionally use aes, it'll take worst case 2-3 days to break any pdf
05:30:11 <mmorrow> dmhouse. exactly, the viewer is supposed to just not allow it. /that's/ the drm'y crap. and in this case, adobe feels a stern warning will suffice
05:30:33 <mmorrow> but, aside from that, you can actually /encrypt/ the pdf
05:30:37 <ivanm> "Oi, you, you're not meant to be doing that! Naughty, naughty!" :p
05:30:51 * Zao notes the massive amount of on topic chat currently going on.
05:31:03 <ivanm> on-topic chat? where?
05:31:07 * ivanm looks around
05:31:25 <ivanm> Zao: I thought the unofficial policy was, if there's no on-topic chat then off-topic is permissible...
05:32:37 <mmorrow> one app that breaks pdf encryption, trying varous sly ways at first, and resorting to a brute force attack in the worst case, and is marketed to police/whatever is going for $999.99 USD ...
05:33:00 <ivanm> wtf?
05:33:05 <jeffz> that's a nice price tag
05:33:06 <mmorrow> sounds like a pretty lucrative area
05:33:11 <ivanm> they've obviously never used linux pdf viewers ;-)
05:33:16 <dmhouse> "Sly ways" = try "password1234"
05:33:24 <ivanm> well, they don't actually break the encryption AFAIK
05:33:29 <profmakx> have you read about the i-am-rich application for the iPhone?
05:33:32 <mmorrow> heh. it's different if it's /encrypted/. you cannot view it in this case
05:33:34 <profmakx> _thats_ a nice price tag
05:33:36 <ivanm> profmakx: heh, yeah
05:33:54 <dmhouse> ?go i am rich iphone
05:33:57 <lambdabot> http://www.foxnews.com/story/0,2933,398903,00.html
05:33:57 <lambdabot> Title: FOXNews.com - 'I Am Rich' iPhone Application Retails for $1,000 - Science News | ...
05:34:00 * ivanm wonders if that app can be beaten by mv _.pdf _.abc
05:34:30 <ski> afternoon, esap
05:34:43 <mmorrow> if both the user *and* the owner passwds are set, it requires a brute force search
05:34:57 <esap> ski: afternoon
05:34:58 <mmorrow> 2-4 days worst case on a nice desktop
05:35:06 <esap> ski: what's up?
05:35:30 <mmorrow> so the moral ... never rely on pdf encryption to hide anything !
05:35:38 <ski> esap : trying to work some on a logic programming language
05:35:57 <esap> ski: which one?
05:36:16 <ski> esap : a new one i'm trying to design
05:36:24 <ski> (for experimentation)
05:36:30 <esap> ski: ah ok
05:37:22 <mmorrow> here are those links
05:37:23 <mmorrow> http://www-2.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
05:37:25 <lambdabot> http://tinyurl.com/7ubkw
05:37:32 <esap> ski: My approach is to embed a logic programming language in the language as a subset....
05:37:36 <mmorrow> http://www.net-security.org/secworld.php?id=4907
05:37:48 <lambdabot> Title: Break 40-bit Adobe PDF encryption in minutes
05:37:56 <mmorrow> ^^^ this is the remendously overpriced moneymaker
05:38:08 <mmorrow> (minutes is the trivial case)
05:38:23 <ski> (esap : in which language ?)
05:38:31 <esap> ski: Though that's just a concept, not implemented yet.
05:38:55 <esap> ski: My language that's based on category theory.
05:39:10 <ski> esap : i want to experiment with open and closed predicates .. so i need some kind of custom static checking system
05:39:16 <ski> esap : allegories ?
05:39:43 <esap> ski: I don't understand allegories well enough to be able to implement them...
05:40:09 <ski> ok
05:40:52 <esap> ski: Adjunctions are the basis for the language.
05:40:59 <ski> how fares your language, then ?
05:41:14 <esap> ski: I've just started on an interpreter
05:41:37 <esap> ski: So that I'd be able to run something on it...
05:42:41 <esap> ski: I've been thinking of natural transformations as a basis for the interpreter. There would be primitive natural transformations that are implemented in the interpreter.
05:42:44 <ski> are you going to have inductive and coinductive datatypes like Charity ?
05:43:19 <esap> ski: Well not quite like Charity, but yes.
05:44:13 <hask> wow seruously ridic ghostscript fails to install
05:44:36 <hask> is there a cygwin program to read ghostscript in the shell?
05:46:10 <ski> hm .. which language would the interpreter be written in ?
05:46:36 <esap> ski: I'm planning on writing it in C.
05:46:43 <ski> .. or maybe you meant that the interpreter would interpret natural transformations .. as opposed to being defined as one ?
05:47:00 <esap> ski: yes, the interpreter would interpret natural transformations.
05:47:27 * ski was thinking of the interpreter as some kind of initial natural transformation ..
05:48:07 <mmorrow> it'd be nice if it could interpret itself after a bootstrapping stage :)
05:48:49 <ski> (mmorrow : that's what i'm aiming for, anyway ..)
05:48:54 <esap> ski: The natural transformations are nice, because for every adjunction there are two natural transformations which can be used to implement the feature described by the adjunction.
05:48:57 <ski> (well, almost)
05:49:26 <quicksilver> write an interpreter in C? ouch...
05:49:31 <ski> itym the unit and the counit
05:49:41 <esap> ski: yes
05:50:15 <esap> quicksilver: Well I agree, it's a pain. But I don't see very good alternatives.
05:50:59 <ski> how do the unit and the counit differ, in the typical features you have in mind ?
05:51:20 <ski> (as you said they could be used to implement the feature)
05:51:36 <ski> F |-- G
05:51:46 <ski> eta : 1 >-> G . F
05:51:56 <ski> epsilon : F . G >-> 1
05:52:32 <ski> i assume categorical products will be one example, and exponentials another, yes ?
05:53:03 <esap> ski: well think of - x A -| A => -. The unit is: unit t = \x -> (x,t) and the counit: counit (x,f) = f x
05:53:13 <ski> *nod*
05:53:30 <ski> (er, right, s/|--/--|/ ..)
05:53:31 <quicksilver> esap: well myself I'd rather write an interpreter in haskell...
05:54:48 <ski> (esap : actually s/- x A/A x -/ for your `unit' and `counit' :)
05:54:50 <esap> quicksilver: Well I've actually thought of doing that as well. But I do need speed for it and I'm not sure even GHC's optimizations will do..
05:54:58 <vixey> quicksilver: charity is written in C :P
05:55:09 <quicksilver> vixey: so is hugs.
05:55:14 <esap> ski: oh, do I have it backwards? :-)
05:55:20 <quicksilver> I'm not suggesting it's impossible.
05:55:25 <quicksilver> I'm just suggesting it's "ouch".
05:55:56 <vixey> esap: You are using a specific programming language because of the speed it gets you?
05:56:10 <quicksilver> esap: I would say ghci is a fairly fast and capable interpreter, and ghci is written in haskell :)
05:56:29 <esap> vixey: not really.
05:56:34 <SamB_XP> quicksilver: parts of it...
05:56:38 <quicksilver> Of course I don't know what you need speed for; what things you envisage using your language for that will bottleneck on speed.
05:56:46 <quicksilver> SamB_XP: The largest parts.
05:57:40 <esap> vixey: there are many reasons.
05:57:58 * vixey can only think of reasons why C is completely unsuitable
05:58:00 <SamB_XP> but, you know, it influences more-or-less the whole RTS design ...
05:59:13 <ski> (possibly esap wants to build a low-level state-machine, with explicit control over stack allocation ?)
06:01:01 <esap> ski: yes, that's one point. I need the power to decide what things go where. Because I want to be able to design low level things like schedulers and garbage collection myself.
06:02:00 <esap> And I'm pretty sure that being able to implement concurrency well I need the ability to work at a very low level of abstraction.
06:02:24 <esap> the primitives in the language are not something you would find in a high-level language
06:03:03 <esap> I'm writing the high-level language on top of the core
06:03:10 <ski> how will the language look like ?
06:03:22 <ski> composition, application, or both ?
06:03:36 <mmorrow> esap: this is pretty interesting http://darcs.haskell.org/ghc/rts/Interpreter.c
06:04:11 <mmorrow> (i'm not sure the extent to which that code is used in ghci in its current form)
06:05:02 <esap> ski: Well I'm planning on using a set of natural transformations generated from the basic adjunctions as the basis for the language to be interpreted.
06:05:30 <quicksilver> esap: what you say makes sense although starts to sound more like a compiler than an interpreter, if those are your goals.
06:05:38 <quicksilver> a appreciate it's a continuum.
06:06:21 <mmorrow> esap: c-- may also be applicable. it looks pretty cool ... http://www.cminusminus.org/
06:06:23 <quicksilver> I might personal tend towards writing the low level structure (the 'RTS') in C and still writing the parsing/optimising/code generation in a alanguage like haskell.
06:06:30 <lambdabot> Title: C-- Home
06:06:56 <esap> ski: The parse tree for whole (high-level) language is http://www.kotiposti.net/epulkkin/TSynTree.txt  Still under development though
06:07:51 <esap> ski: see "SAdjunction" and "SNaturalTransformation". Those are the things that will be in the interpreter.
06:10:06 <ski> `0 -| ! : C -> C' for `SInitialObjects' signifying ?
06:10:37 <esap> ski: it's the adjunction that's used to define initial objects
06:11:05 <esap> ski:  !(A) = ()
06:11:28 <ski> shouldn't it be `0 -| ! : C -> 1' ?
06:11:54 <ski> (and `1 -> C' for the `STerminalObjects' case)
06:12:05 <esap> ski: hmm.. good point
06:12:14 <esap> ski: I think it's possible
06:12:39 <ski> (or however you want to write the unit category to that `x' product)
06:12:50 <dcoutts> @seen eivuokko
06:12:50 <lambdabot> I haven't seen eivuokko.
06:13:51 <esap> ski: Another thing is, that will actually be included in the 'SLimits' and 'SColimits' cases [obviously]
06:14:25 <ski> but maybe you need a base case internally ?
06:15:05 <esap> ski: true. I could implement SLimits and SColimits as syntactic sugar.
06:15:40 <esap> ski: the interpreter is not yet well thought out so I'm not decided on which parts to implement first.
06:15:57 <ski> how about `SDiscreteObjects  :: SAdjunction -- dis -| ob , ob : Cat -> Set' ?
06:16:41 <ski> what is this for ?
06:16:42 <esap> ski: ob is the functor taking a category to the "set" of objects in the category.
06:17:06 <ski> so what is `ob , ob', then ?
06:17:23 <esap> ski: notation. the adjunction is   dis -| ob
06:17:34 <ski> ohh
06:17:35 <esap> ski: I'm saying that 'ob : Cat -> Set'
06:18:11 <ski> (you weren't noting in that way in the previous cases)
06:18:16 <esap> ski: I can't never remember which way that functor is so need to be explicit :-)
06:19:13 <ski> (`dis -| ob : Set -> Cat' would be consistent with the earlier ones ..)
06:20:25 <esap> ski: hehe right. But I actually had it like that and confused that so many times [went changing it from dis -| ob : Cat -> Set  to  dis -| ob : Set -> Cat   and vice versa many times...
06:20:38 <ski> hm `SInitialObjects', et.c. doesn't take a `SCategory' as argument ..
06:21:11 <ski> (but `SPartialObjects' do)
06:22:14 <ski> `[I,C]' ?
06:22:26 <esap> ski: I have to say that's something that's not yet well thought out. The original idea was that the 'C' category need not be as parameter. But It's been confused as to how I should have it. Anyway I need the ability to be able to deduce both categories from the syntax.
06:22:39 <esap> ski: [I,C] is the category of functors from I to C.
06:22:55 <ski> oh, exponential
06:23:06 <esap> ski : exponential in Cat.
06:23:17 <ski> yes
06:25:26 <ski> the `x' in `_ x (x :: A)  -| (x :: A) => _ : C -> C' is for ?
06:25:51 <ski> hm
06:25:56 <esap> ski: dependent types. Though I have to say I should think of that part more.
06:26:05 <esap> ski: probably that's not correct.
06:26:19 <ski> i suppose the name is free in the `SFunctor'
06:27:15 <esap> ski: Ah, the thing is, I'm representing objects as functors 1 -> C, which is why SFunctor appears in many places where objects should appear.
06:28:12 <esap> ski: that's also a nice generalization for many of the operations
06:28:39 <ski> in some sense that should be right, i think .. but i'm not sure if your encoding attempt of it is :)
06:29:54 <ski> "TODO: Kan extensions! Kan extensions can express all concepts!" :D
06:30:09 <esap> I've purposefully left some of the data in the adjunction unspecified. I'll find when I'm doing the interpreter what data is needed.
06:31:31 <esap> ski: Kan extensions are a kind of generalization of adjunctions
06:31:36 <ski> yes
06:32:24 <esap> ski: I think the transition from objects -> functors takes adjunctions to kan extensions
06:32:37 <ski> `SIdentityTransform :: SFunctor -> SNaturalTransformation' looks strange to me
06:32:38 <ski> hm
06:33:30 <ski> say
06:33:36 <ski>   F : C >-> D
06:33:41 <esap> ski: it's the identity transform F -> F  (the argument is 'F').
06:33:50 <ski> what does `SIdentityTransform' of `F' singify ?
06:33:58 <ski> s/singify/signify/
06:34:42 <esap> ski: I[F] : F -> F, I[F]_A : F A -> F A
06:35:02 <ski> hm, *nod*
06:35:26 <ski> right
06:35:53 <esap> ski: that needs to be a primitive I think
06:36:57 <esap> ski: Actually, now that I think of it, maybe Counit of I -| I might do....
06:37:55 <esap> I mean actually, unit o counit  of I -| I
06:38:07 <esap> ugh, counit o unit I mean
06:40:14 <ski>   newtype SArrow = SArrow SNaturalTransformation
06:41:25 <esap> ski: yes. an arrow A -> B in category C is a natural transformation A -> B : 1 -> C
06:41:47 <ski> m
06:42:37 <ski> hm, so it seems you're representing the internal structure of a category by external means (functors, natural transformations)
06:42:57 <ski> effectively reducing to `Cat' (and maybe some friends)
06:42:58 <esap> ski: exactly. Basically I'm implementing the Cat category.
06:43:57 <esap> ski: Then I'm going to have syntactic sugar for the internal structure.
06:44:10 <ski> *nod*
06:44:42 <esap> It's actually interesting to see if this approach will work for everything. There could be some strangeness with respect to abstract vs. concrete things.
06:45:39 <ski>   SFunctorAppTransform j alfa = SHorizontalCompose (SIdentityTransform j) alfa
06:45:40 <ski> ?
06:47:04 <esap> could be
06:47:35 <esap> I do have many things there that are not as simple as they should be
06:47:52 <esap> some old things that are not necessarily any more needed.
06:48:49 <esap> When I bump into some new things that I analyze, I usually always write it here first and see if anything useful comes out of it.
06:49:15 <ski> is there a difference between `SFunctorApplyTransform' and `SFunctorAppTransform' ?
06:51:15 <esap> I think originally the difference was that in SFunctorApplyTransform, the natural transformation is interpreted as an arrow.
06:51:31 <esap> but I'm no longer sure if it's needed.
06:52:07 <esap> this appeared when I combined "arrow" and "naturaltransformation" into the same concept.
06:52:21 <matthew-_> right, I need help
06:52:42 <matthew-_> > let h 1 = [1]; h n = (h (n-1)) ++ (n : (h (n-1))) in h 5
06:52:45 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
06:52:56 <matthew-_> I want to turn that function into a streaming version
06:53:06 <matthew-_> such that it's effectively an infinite list
06:53:41 <matthew-_> > let h 1 = [1]; h n = (h (n-1)) ++ (n : (h (n-1))); h' = h (maxBound::Int) in take 5 h'
06:53:44 <lambdabot>  Exception: stack overflow
06:53:46 <matthew-_> because that doesn't work
06:53:57 <matthew-_> so, my little brain seems to not be agreeable to this task
06:54:01 <matthew-_> any takers?
06:54:11 <rwbarton> matthew-_: I think you need to do it semi-manually
06:54:49 <rwbarton> > let h 1 = [1]; h n = (h (n-1)) ++ (n : (h (n-1))) in [1] ++ [2] ++ h 1 ++ [3] ++ h 2 ++ [4] ++ h 3 ++ [5] ++ h 4 -- ++ ...
06:54:51 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
06:54:59 <ski> esap : ok
06:55:52 <rwbarton> > let h 1 = [1]; h n = (h (n-1)) ++ (n : (h (n-1))) in [1] ++ concat [ [n+1] ++ h n | n <- [1..] ]
06:55:54 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
06:56:05 <matthew-_> awesome, you gain many cookies ;)
06:56:08 <matthew-_> rwbarton++
06:56:13 <ski> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); let foo = repeat 0 /\/ map (1+) foo in foo
06:56:14 <lambdabot>  Parse error at "let" (column 54)
06:56:25 <ski> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); foo = repeat 0 /\/ map (1+) foo in foo
06:56:27 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
06:56:31 <vixey> wow
06:56:42 <ski> matthew-_ : is that ok ?
06:56:55 <matthew-_> ski, you want a cookie too? ;) Yes, that's great too
06:56:57 <rwbarton> Oh, that's nicer (you can change repeat 0 to repeat 1)
06:57:12 <matthew-_> ski++
06:58:04 <matthew-_> how on earth did you do that?
06:58:13 <matthew-_> I can barely understand that even now
06:58:19 <matthew-_> and I know what it's meant to do!
06:58:23 <vixey> @let let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs)
06:58:24 <lambdabot>  Parse error
06:58:27 <vixey> @let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs)
06:58:29 <lambdabot> Defined.
06:58:46 <ski> > map (fix $ \f x -> if odd x then 0 else 1 + f (x `div` 2)) [1..]   -- yet another variant
06:58:48 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
06:59:33 <matthew-_> ahh, yes I tried to get close to that version, and failed
06:59:39 <vixey> @oies 0 1 0 2 0 1 0 3
06:59:41 <ski> matthew-_ : just pattern recognition
06:59:46 <lambdabot> Exponent of highest power of 2 dividing n (the binary carry sequence).
06:59:48 <lambdabot> [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,...
07:00:05 <ski> (matthew-_ : adn, well .. i've played with this sequence before :)
07:01:29 <rwbarton> > intersperse 1 (2:undefined) -- shouldn't this be 2:1:undefined?
07:01:31 <lambdabot>  Exception: Prelude.undefined
07:01:36 <ski> matthew-_ : every other element is `0', the rest are the same as all elements, except offby1
07:01:44 <vixey> @src intersperse
07:01:44 <lambdabot> intersperse _   []     = []
07:01:44 <lambdabot> intersperse _   [x]    = [x]
07:01:44 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:02:01 <vixey> > case (2:undefined) of [x] -> True ; _ -> False
07:02:03 <lambdabot>  Exception: Prelude.undefined
07:02:09 <vixey> > case undefined of [] -> True ; _ -> False
07:02:11 <lambdabot>  Exception: Prelude.undefined
07:02:37 <rwbarton> Right, I understand why it doesn't work; I think the definition of intersperse isn't quite right
07:02:53 <vixey> you can factor both defs into one
07:03:02 <vixey> what do you gain?
07:03:37 <vixey> more lazy?
07:03:42 <rwbarton> right
07:03:49 <vixey> is that a good thing
07:03:50 <vixey> ?
07:03:56 <ski> matthew-_ : Excercise. code an infinite stream for
07:03:57 <ski> > let h 0 = [0]; h n = h (n-1) ++ map (1+) (h (n-1)) in h 4
07:03:59 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4]
07:04:53 <rwbarton> @let intersperse' _ [] = [] ; intersperse' sep (x:xs) = x : (case xs of [] -> [] ; _ -> sep : intersperse' sep xs)
07:04:54 <lambdabot> Defined.
07:05:07 <rwbarton> > fix ((1 :) . intersperse' 1 . map (1+))
07:05:09 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
07:05:13 <rwbarton> > fix ((1 :) . intersperse 1 . map (1+))
07:05:27 <vixey> oh!
07:05:28 <lambdabot>  thread killed
07:05:32 <ski> (nice
07:05:37 <ski> )
07:06:03 <vixey> rwbarton: Maybe you can email the libraries list ?
07:07:14 <rwbarton> vixey: Yeah, I will
07:07:38 <ski> (of course not only matthew-_ are allowed to try the exercise above ..)
07:10:29 <rwbarton> vixey: It seems someone has already proposed this change in March 2004 :/
07:10:45 <Deewiant> and what happened then
07:10:57 <matthew-_> ski: right, well the 2nd half is just the first half + 1 so x ++ (map succ x).... he says hopefully
07:11:33 <ski> > fix (\xs -> xs ++ map succ xs)
07:11:35 <lambdabot>   add an instance declaration for (Monoid (f a))
07:12:23 <ski> mrf?
07:12:28 <ski> > fix (\xs -> xs ++ map succ xs) :: [Integer]
07:12:44 <lambdabot>  thread killed
07:13:02 <Deewiant> > fix (\xs -> 0 : (xs ++ map succ xs))
07:13:04 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:13:04 <rwbarton> Deewiant: There was one response with a slightly modified proposal, and then no follow-up
07:13:25 <Deewiant> rwbarton: so it was just forgotten about, so post more messages and complain
07:13:30 <rwbarton> Deewiant: OK
07:16:09 <mopped> I'm going on a 10 hour flight come monday - Is there an equivelent to 'Thinking C++/Python' for Haskell that I can work through to pass the hours? I have no knowledge of the language FYI :P
07:16:29 <Botje> YAHT is good
07:18:00 <matthew-_> ski: ok, I'm stumped
07:18:07 <matthew-_> I think I want to use iterate
07:18:34 <matthew-_> no I don't
07:18:43 <ski> matthew-_ : what happens if you take every other element of the stream ?
07:19:25 <czShadoW> @src iterate
07:19:25 <lambdabot> iterate f x =  x : iterate f (f x)
07:19:30 <hackage> Uploaded to hackage: non-negative 0.0.3
07:19:52 <matthew-_> it's the same pattern
07:19:53 <guenni> dcoutts_: ping
07:20:56 <matthew-_> ahh, and the other ones are the next thing
07:21:08 <guenni> has anybody here successfully compiled a recent gtk2hs on WinXP
07:21:13 <guenni> ?
07:21:42 <cjb> lll
07:22:22 <hask> I cant install the binary library, sit here any other way of serializing data?
07:22:41 <hask> this is really annoying me, anyone installe dthe binary package on windows that can help me?
07:22:47 <cjs> Damn, Data.Binary does rock and roll.
07:22:52 <hask> yes
07:22:54 <cjs> So what's the issue?
07:23:08 <hask> im trying to install on vista
07:23:21 * cjs contemplates running very far, very fast.
07:23:30 <hask> i do runhaskell configure+build but then running install it fails
07:23:44 <cjs> Can you do a pastebin of the failure messages?
07:23:50 <hask> looks into the wrong directory, program files/haskell when I have c/ghc/
07:24:00 <cjs> I don't know if I'll be able to help, being a Unix guy, but I'll offer you any clues I can.
07:24:09 <hask> cjs sure ill post to hpaste
07:26:00 <lasts> @src fix
07:26:01 <lambdabot> fix f = let x = f x in x
07:27:35 <hask> http://hpaste.org/9678
07:27:40 <hask> cjs: http://hpaste.org/9678
07:28:28 <cjs> Does C:\Program Files\Haskell exit right now?
07:28:33 <smg> Deewiant: how about repeat 0 ?
07:28:36 <cjs> s/exit/exist/
07:29:09 <hask> cjs: does not exist
07:29:11 <Deewiant> smg: just adapting ski's piece :-)
07:29:33 <hask> http://hpaste.org/9679
07:29:53 <hask> I have tried changing those to c:/ghc-6.8.3/ and /bin etc btu still doesn't work
07:30:05 <twanvl> haks: what if you mkdir "C:\program files\haskell"?
07:30:28 <hask> but it shouldn't be there at all no? i have my haskell in c:/ghc
07:30:33 <cjs> Ah, hmm. Can you create it by hand? I'm guessing not.
07:30:45 <hask> yes i can i guess
07:30:49 <hask> will that give access?
07:32:23 <hask> i created it and not it doesnt complaing about access to program files\haskell but \program files\haskell\doc
07:32:31 <hask> can I manually create the whole shebang?
07:33:20 <hask> then it complains about \binary-0.4.2 when i create doc
07:33:41 <cjs> Well, I'm not sure how to debug this, so I'd start creating all of the dirs it wants and see what happens.
07:34:19 <twanvl> hask: you can try runing setup configure --prefix C:\ghc
07:35:03 <twanvl> although you might not want to install your libraries in the ghc dir
07:38:10 <ski> matthew-_ : yes .. maybe you can use this observation to define the stream .. ?
07:39:59 <hask> twan: ill try, thanks
07:40:27 <hask> twan: why not? stdlib is there, maybe i should create a separate folder fo 3rdpart libs
07:40:28 <jdm> http://hpaste.org/9680
07:40:35 <jdm> does what I'm trying to do actually make sense?
07:41:05 * vixey gives up
07:41:06 <vixey> !
07:41:15 <jdm> if attaching to the gdb process succeeds, I want to store the handle in the thing, or just ignore it if it fails
07:41:36 <jdm> it's not building right now, of course, because dealing with Either is confusing
07:41:41 <vixey> > (let r = list ++ map (+1) list in take (length r `div` 2) r ++ drop (length r `div` 2) (dup' r)) [0]
07:41:43 <lambdabot>   Not in scope: `dup''
07:41:55 <vixey> > let dup' list = let r = list ++ map (+1) list in take (length r `div` 2) r ++ drop (length r `div` 2) (dup' r) in dup' [0]
07:41:57 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
07:42:02 <vixey> I couldn't do a good solution though
07:42:50 <jdm> GDBMI.attach returns IO (Either String (GDB, MIOutput))
07:43:29 <jdm>  Couldn't match expected type `Either String (GDBMI.GDB, GDBMI.MIOutput)' against inferred type `(a, b)'
07:47:41 <Botje> sure about the type of attach?
07:47:46 <jdm> yep
07:48:06 <ekidd> Is there a downloadable version of the ghc documentation, or do I need to generate it with Haddock?
07:48:57 <ekidd> Never mind! Found one.
07:53:22 <jdm> anybody help me understand the error? :(
07:55:15 <ski> matthew-_ : did you give up, too ?
07:56:00 <ski> jdm : you are given an `Either blah bleh', you must handle that
07:57:09 <jdm> yeah, I know that
07:57:17 <besiria> i'm finding hard to process unicode with haskell. can you point me to a particular library?
07:57:20 <jdm> but the way I tried to do it in the paste isn't working, and I don't know why
07:57:40 <ski> oh, there's a paste .. i didn't notice
07:59:52 <gwern> besiria: process unicode? what do you mean
07:59:58 <ski> jdm : oh .. you're missing the `IO' in the return type
08:00:00 <gwern> unicode IO is generally done with utf8-string
08:00:24 <Zao> Internally, Char represents an unicode codepoint.
08:00:36 <jdm> it's the case pattern that's erroring right now though
08:00:38 <Zao> It's generally the input and output that's bothersome.
08:00:49 <besiria> ok i'm looking at utf8-string right now
08:01:14 <jdm>  Couldn't match expected type `Either                                     String (GDBMI.GDB, GDBMI.MIOutput)'            against inferred type `(a, b)'     In the pattern: (gdb, log)     In the pattern: Right (gdb, log)     In a case alternative: (Right (gdb, log)) -> env {envGDB = gdb}
08:01:20 <jdm> that didn't turn out nicely
08:01:22 <besiria> basically i mean open some url and get search for some utf8 strings
08:02:54 <ski> jdm : `GDBMI.attach Nothing pid' is an `IO'-action, yes ?
08:03:00 <jdm> yes
08:03:22 <jdm> oh right, I tried adding liftIO before (GDBMI.attach Nothing pid)
08:03:29 <jdm> and it gave me my present error
08:03:47 <r3m0t> google: liftio
08:03:50 <r3m0t> did you mean: gifart
08:04:13 <ski> jdm : could you give me the type of `GDBMI.attach' ?
08:04:23 <jdm> http://hackage.haskell.org/packages/archive/hgdbmi/0.1/doc/html/GDBMI.html#t%3AGDB
08:04:35 <lambdabot> Title: GDBMI, http://tinyurl.com/5qectx
08:05:50 <trofi> @src <$>
08:05:50 <lambdabot> f <$> a = fmap f a
08:05:53 <besiria> i'm using System.IO.UTF8 for basic IO reading, printing but the output is still sth like this : "\966\945\963\966\963\945\940"
08:06:32 <ski> jdm : <http://hpaste.org/9680#a1>
08:06:37 <rwbarton> besiria: are you using show? (or print?)
08:06:44 <trofi> import System.IO.UTF8 (putStr)
08:08:27 <besiria> trofi: it seems that with putStr the string gets printed right
08:08:33 <jdm> ski: well, that got rid of errors from startGDB, so thank you
08:08:50 <jdm> now I need to figure out how I can use an IO env in the rest of the program
08:09:08 <besiria> is it necessary to Codec.Binary.UTF8.encodeString ? i mean what is the purpose of this function
08:09:37 <chrisdone> hey chr1s
08:09:44 <ski> jdm : if you want to use `attach' there, you're stuck with `IO'
08:10:20 <jdm> any thoughts on how I can fix this line then?
08:10:21 <jdm> GDBMI.MIOutput log out <- ErrorT $ GDBMI.runCommand cmd (envGDB env')
08:10:38 <jdm> let env' = liftIO $ startGDB pid env
08:13:09 <ski> @hoogle liftIO
08:13:09 <lambdabot> A Hoogle error occurred.
08:13:10 <ruddel> everytime i look at haskell syntax i get a high
08:13:24 <vixey> @src Functor
08:13:25 <lambdabot> class  Functor f  where
08:13:25 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:13:28 <ruddel> now is time that i actually learn it
08:13:39 <ski> @type Control.Monad.Trans.liftIO
08:13:40 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
08:14:01 <ski> jdm : what is the problem with those two lines ?
08:14:10 <ski> oh, right
08:14:23 <ski>   env' <- liftIO $ startGDB pid env
08:14:24 <jdm>     Couldn't match expected type `InterpEnv'            against inferred type `m InterpEnv'     In the first argument of `envGDB', namely `(liftIO env')'
08:14:44 <ski> you probably should use `<-', there, not `let' and `='
08:14:50 <jdm> hrm
08:15:27 <jdm> oh hey, no more error :)
08:15:37 <ski> (`startGDB' might have some effects, so you should run the action)
08:15:45 <ski> jdm : yes ?
08:15:53 <jdm> yeah, the change to <- worked
08:16:08 <jdm> thanks!
08:26:26 <chylli> why flip.openFile has error ?
08:26:34 <chylli> :t flip.openFile
08:26:58 <trofi> @type flip
08:27:00 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:27:05 <besiria> what is the easiest way to parse an html file? maybe TagSoup?
08:27:14 <sclv> ?hoogle openFile
08:27:15 <lambdabot> A Hoogle error occurred.
08:27:17 <ski> @type System.IO.openFile
08:27:19 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
08:27:22 <sclv> :- (
08:27:33 <ski> chylli : maybe you want `flip openFile' ?
08:27:40 <chylli> oh yeah
08:27:41 <chylli> thanks
08:27:45 <sclv> I don't hang out for irc for a bit and I forget which lambabot features are broken at any given moment
08:33:25 <chylli> ski: can you help me to look at this slice of program ? http://hpaste.org/9682
08:34:02 <chylli> I mkfifo /tmp/a /tmp/b tmp/c
08:34:09 <chylli> and runhaskell this program.
08:34:26 <chylli> but I got :test.hs: /tmp/a: hGetChar: end of file
08:34:26 <ski> well, usually it is better to allow as many people as possible to look at problems ..
08:34:36 <chylli> why not it is blocked ?
08:34:45 <chylli> ok sorry.
08:35:21 <chylli> who can help me to look at this program ?  http://hpaste.org/9682
08:35:27 <ski>   ((flip  openFile) ReadMode)
08:35:30 <ski> can be written as
08:35:37 <ski>   (`openFile` ReadMode)
08:35:51 <chylli> ski: thanks.
08:36:24 <chylli> but why hGetchar dont blocked when there is no content in pipe ?
08:36:58 <ski> the `let readF h = ...; threads <- mapM readF handles' part can be rewritten as `threads <- forM handles $ \h -> do ...'
08:36:59 <AtnNn> chylli: that's how fifos work
08:37:23 <chylli> AtnNn: but tail /tmp/a will be blocked...
08:37:50 <chylli> ski: thanks again.
08:38:19 <rwbarton> chylli: just in case: your hpaste is called 'forkIO test', but you know it doesn't actually use forkIO, right? :)
08:38:59 <chylli> rwbarton: I think I has used forkIO ?
08:39:18 <chrisdone> i can has threads?
08:39:40 <AtnNn> chylli: it depends how you write to the fifo
08:39:41 <chylli> rwbarton: faint. i forget it
08:40:11 <chylli> AtnNn: I think I will 'runhaskell program.hs' then 'echo > /tmp/a'
08:40:22 <chylli> sorry, 'echo "hello" >/tmp/a'
08:42:15 <AtnNn> chylli: after echo closes the file, reading more than "hello\n" will read EOF
08:43:03 <chylli> AtnNn: but I hasn't run echo yet, it has showed error.
08:46:21 <haskellian> is the lazy evaluation tricking me? I do some parsing of big files and it goes superquick, then when I need to print the length of the list I created, then i t is very slow
08:46:43 <cjs> Definition of the day: (/) = (</>)
08:47:00 <AtnNn> chylli: you're right, it's weird
08:47:03 <haskellian> i get the impression sometimes that lazy eval can be hard to reason about when it comes to performance?
08:47:19 <cjs> It can more often just not work.
08:48:13 <AtnNn> chylli: it's because ghc uses non-blocking file io by default
08:48:50 <chylli> AtnNn: really ? I think I has read doc of System.IO carefully.
08:49:29 <chylli> AtnNn: and I remembered I used it to read socket handle before, and it do be blocked.
08:51:55 <besiria> how can i safely remove the user's cabal installed packages? ghc-pkg list reports two  packages.conf and i only want the global one
08:54:55 <vixey> :t (</>)
08:54:55 <cjs> -no-user-packages?
08:55:08 <vixey> haskellian: Yes
08:55:29 <cjs> vixey: it's the path concat operator from FilePath or whatever it is.
08:56:26 <dcoutts> besiria: do you mean you want to ignore the per-user ones or you want to uninstall them?
08:56:42 <dcoutts> guenni: pong
08:56:49 <cjs> @quote imperative
08:56:49 <lambdabot> bos says: imperative languages only go up to ten
08:56:58 <AtnNn> chylli: you can use System.Posix: do fd <- openFd "fa" ReadOnly Nothing defaultFileFlags; fmap fst $ fdRead fd 1
08:57:00 <guenni> dcoutts: hi
08:57:02 <cjs> @quote imperative jones
08:57:02 <lambdabot> No quotes for this person. Take a stress pill and think things over.
08:57:10 <cjs> What's the SPJ one?
08:57:13 <vixey> @quote jonkes
08:57:14 <lambdabot> No quotes match. Where did you learn to type?
08:57:16 <vixey> @quote jones
08:57:17 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
08:57:29 <besiria> dcoutts: both
08:57:37 <guenni> dcoutts: am I the only one who thinks that compiling on Windows seriously sucks?
08:58:19 <dcoutts> besiria: ok, when compiling use -no-user-package-conf
08:58:25 <haskellian> @quote jones
08:58:26 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
08:58:26 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
08:58:26 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
08:58:29 <guenni> dcoutts: I'm trying to install leksah
08:58:30 <dcoutts> guenni: heh, nope.
08:58:37 <besiria> dcoutts: works with ghci also?
08:58:37 <guenni> on Windows
08:58:39 <jdavis_> I seem to remember there was a free haskell book available online, but I can't seem to find it. Does someone have a link?
08:58:40 <chylli> AtnNn: ok, I just test, to see how to implement a haskell version of 'select'
08:58:41 <Deewiant> compiling with GHC works rather well in my opinion
08:58:44 <dcoutts> besiria: should do
08:58:49 <guenni> pain in the ass
08:58:49 <dcoutts> guenni: right
08:58:52 <Deewiant> compiling in general is a different story, of course ;-)
08:58:53 <haskellian> @quote jones
08:58:54 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
08:59:15 <besiria> dcoutts: ok works, but how about deleting them from ~/.ghc
08:59:20 <dcoutts> guenni: so, you've got mingw + msys and the gtk2hs tarball and the gtk sdk...
08:59:34 <dcoutts> besiria: you can unregister them using ghc-pkg unregister --user $pkgname
08:59:39 <guenni> dcoutts: right
08:59:40 <ski> "Please talk to your son or daughter about parametric polymorphism." -- Dave Benjamin
08:59:55 <besiria> dcoutts: any efficient way to remove all user package.conf?
09:00:01 <dcoutts> besiria: as for deleting the files, they're probably under ~/.cabal/lib/$pkgid
09:00:10 <dcoutts> besiria: sure, rm -r ~/.ghc
09:00:26 <guenni> dcoutts: but no joy
09:00:27 <cjs> jdavis_: _Real World Haskell_?
09:00:33 <besiria> dcoutts:  is it safe to do so?
09:00:36 <dcoutts> besiria: any particular reason you don't want the per-user install?
09:00:50 <besiria> dcoutts: because i'm seeing right now that i have duplicates
09:00:52 <jdavis_> cjs: thanks
09:01:07 <dcoutts> besiria: you'll loose all per-user registered packages for all versions of ghc you have ever installed
09:01:08 <besiria> dcoutts: and after all, i am used to have one site-packages dir (python,lisp)
09:01:30 <besiria> dcoutts: sounds fair to me, i will reinstall them globally
09:01:44 <besiria> dcoutts: is there a way to provide default to cabal install ?
09:01:54 <dcoutts> besiria: honestly I think there's very little advantage to doing global installs most of the time
09:02:18 <dcoutts> besiria: sure use --global or to make it persistent set the equivalent option in the ~/.cabal/config
09:02:19 <jdavis_> cjs: I'm not sure this is the book I remember, but it's helpful anyway.
09:02:44 <dcoutts> besiria: you may also want to use the --root-cmd=sudo option, so you can build as you and install as root
09:02:55 <dcoutts> guenni: ok, so where did it go wrong?
09:03:14 <guenni> well actually about that gtk sdk ...
09:03:15 <chris2> that sarah quote reminds me of weizenbaum's daughter asking, "dad, what time is it? and i dont want to know how a clock works!"
09:03:33 <guenni> dcoutts: I might not have the right one
09:04:21 <besiria> how can i default to --global? in .cabal/config
09:04:42 <dcoutts> besiria: user-install: False
09:04:52 <guenni> dcoutts: would you happen to know which one to use?
09:05:02 <dcoutts> besiria: the default --prefix for --global installs will be /usr/local
09:05:28 <dcoutts> guenni: I think it was one from the official gtk site pgavin would know which one for sure.
09:05:45 <dcoutts> guenni: for the previous release of gtk2hs I used the one I put together here: http://haskell.org/gtk2hs/win32/
09:05:46 <lambdabot> Title: Index of /gtk2hs/win32
09:06:14 <besiria> dcoutts: ok done that. and how do i change the default prefix ?
09:06:25 <dcoutts> besiria: global-prefix:
09:07:00 <guenni> dcoutts: that might me the problem, I used a binary installer
09:07:01 <dcoutts> besiria: I'm working on making the config file self-documenting you'll be glad to hear :-)
09:07:20 <dcoutts> guenni: oh, that'll be missing all the dev libs and headers files
09:07:22 <besiria> dcoutts: ty very much. is it safe to remove now .cabal/lib/ ? i've rm ~/.ghc
09:07:28 <dcoutts> guenni: and missing pkg-config
09:08:03 <dcoutts> besiria: yep, you can remove everything in ~/.cabal except config and the packages/ dir (as that caches the downloaded tarballs)
09:08:19 <dcoutts> and contains the index of known packages
09:10:07 <besiria> dcoutts: never thought that a couple of rm would be safe :)
09:10:16 <dcoutts> heh
09:10:28 <besiria> dcoutts: thx anyway. it's just me. i am used to site dirs
09:11:49 <besiria> dcoutts: and sth that i'm not sure : anything listed inside curly braces in ghc-pkg list is a hidden pkg?
09:12:18 <dcoutts> besiria: no, that means broken. See ghc-pkg check
09:12:34 <besiria> dcoutts: omg
09:13:59 <guenni> dcoutts: you know this is really embarassing, I spent a day and got nowhere, and now it seems to compile with nps
09:14:08 <dcoutts> guenni: yay
09:14:41 <guenni> dcoutts: thx
09:14:49 <dcoutts> np
09:14:56 <besiria> dcoutts: can u talk a look in this plz http://hpaste.org/9683
09:16:20 <gwern> @seen nomeata
09:16:20 <lambdabot> I saw nomeata leaving #xmonad, #haskell and #darcs 12h 2m 34s ago, and .
09:17:02 <gwern> @ask nomeata Is darcswatch still working? I have one patch which gmail says got sent to xmonad & darcswatch, but I don't see it in either my page or the xmonad page
09:17:03 <lambdabot> Consider it noted.
09:17:44 <besiria> dcoutts: i'm missing bytestring-0.9.0.1 but i already got a newer version
09:18:23 <dcoutts> besiria: right, so you unregistered bytestring-0.9.0.1, but may other packages still depended on that version. They are all therefore broken.
09:18:53 <dcoutts> besiria: I filed a ghc ticket the other day to have ghc-pkg warn people when they were doing this.
09:18:55 <besiria> dcoutts: y that must be the case
09:19:31 <besiria> dcoutts: what if i reinstall that particular version
09:19:31 <hackage> Uploaded to hackage: url 1.0.1
09:19:41 <dcoutts> besiria: it might or might not work.
09:19:58 <dcoutts> besiria: it'd have to be built using the same compiler options for it to produce the same ABI
09:20:34 <besiria> dcoutts: what if i reregister bytestring-0.9.01? is that possible
09:20:45 <dcoutts> besiria: you'll still have the files for the package on disk (because they're bundled with ghc itself) so it's possible to re-register, but not trivial
09:21:24 <dcoutts> besiria: the ghc api package is the the tricky one, all the others you can easily rebuild using cabal upgrade
09:21:31 <dcoutts> but the ghc api package cannot be rebuilt
09:21:43 <dcoutts> not without reinstalling ghc
09:21:56 <besiria> dcoutts: so you recommend a clean reinstall?
09:22:52 <dcoutts> besiria: if that's not too hard yeah. If you'd have to rebuild from source then it's probably quicker to work out how to re-register.
09:23:00 <besiria> dcoutts: so i should avoid unregistering any pkg even if there is a newer version of it
09:23:19 <besiria> dcoutts: well i'm on gentoo so rebuilding
09:23:21 <dcoutts> besiria: that's certainly the case for the versions of the packages that come with ghc itself
09:23:28 <dcoutts> besiria: ah! then you're in luck
09:23:42 <besiria> dcoutts: any way i'm rebuilding np. i should learn from my mistakes
09:24:06 <besiria> dcoutts: but you should add that warning you said earlier. it is crucial
09:24:08 <dcoutts> besiria: you can revert to a clean package db by copying the package.conf.shipped over package.conf
09:24:25 <dcoutts> besiria: yep, I filed the ticket and it's been done. It'll be in 6.10
09:24:50 <besiria> dcoutts: ok that's nice. thx
09:25:11 <dcoutts> besiria: in the /usr/lib/ghc-6.8.2/ there is the package.conf, that's the global db and the gentoo package saves a copy of the original as package.conf.shipped
09:25:29 <dcoutts> besiria: so literally cp that over the current version and you revert to a clean set of core libs
09:25:42 <dcoutts> besiria: you'll have to reinstall any other libs
09:25:48 <besiria> dcoutts: that will work?
09:25:51 <dcoutts> besiria: yes
09:26:10 <dcoutts> besiria: we made the ghc ebuild save a copy for specifically this kind of problem.
09:26:24 <dcoutts> I've used it on more than one occasion
09:26:38 <dcoutts> saved me from hours of recompiling
09:26:38 <besiria> well i'm on 64 should i use /usr/lib64 ? this is what ghc-pkg list is reporting
09:26:43 <dcoutts> besiria: yep
09:26:52 <dcoutts> besiria: I was just guessing the path
09:27:15 <besiria> why /usr/lib/ghc.. exists? for running some 32bitcode?
09:27:37 <dcoutts> besiria: well on my gentoo amd64 box /usr/lib  is just a symlink to /usr/lib64
09:28:06 <jpcooper> hello
09:28:09 <besiria> dcoutts: well stupid of me , same is here
09:28:19 <mwc> what's the secret to getting haddock 2.1 installed with GHC 6.8.3? I've read that you need to build GHC, then haddock, then rebuild GHC
09:28:20 <jpcooper> are monad transformers just a way to allow the extraction of values from two or more monads?
09:28:20 <dcoutts> besiria: but you can set up multi-lib where you get 32bit ones too in a different lib dir
09:28:45 <besiria> dcoutts: well i'm not concerned about this now ... everything looks fine now
09:28:49 <mwc> if I change any build flags between GHC builds (ie, build the first GHC quickly,) will I break haddock?
09:29:11 <dcoutts> mwc: no, it's just the ghc version it's sensitive to, since that determines the .hi binary format
09:29:12 <besiria> dcoutts: and what about (ghc-6.8.2) in ghc-pkg list? is that hidden or still broken
09:29:20 <mwc> jpcooper: no, a monad transformer is used to compose monads, you wrap one monadic computation in another monad
09:29:32 <dcoutts> besiria: that's just hidden, {} indicates broken
09:29:34 <jpcooper> okay
09:30:08 <mwc> dcoutts: ok, so .hi isn't fragile binary format intimately linked to GHc's internal binary layout? ;)
09:30:36 <dcoutts> mwc: yes it's a binary format intimately linked to ghc
09:30:40 <besiria> dcoutts: well what if i have multiple versions listed on ghc-pkg list? the compiler will use the most recent one when linking?
09:30:47 <mwc> jpcooper: the key thing to understand about MT is that they're stacked. So you put an outer monad around a monadic computation, then that's the first one that comes out. A good example is something like StateT Foo IO a
09:31:08 <dcoutts> mwc: all clients of the ghc api have this issue (including ghc itself) they cannot read .hi files from different ghc versions.
09:31:17 <mwc> dcoutts: yeah, but I mean, it's consistent across versions of GHC, individual builds won't break it
09:31:27 <dcoutts> besiria: yep, unless you specify -package foo-1.0 exact versions
09:31:41 <mwc> Geez, haddock oughta just be folded into GHC
09:31:52 <jpcooper> mwc, yes, I think I understand that now
09:32:00 <dcoutts> mwc: it's consistent within a version of ghc, using different compile flags do not alter the binary format.
09:32:13 <jpcooper> I was hoping to be able to do things with Maybe values in ReaderT X Maybe Y
09:32:24 <jpcooper> but I figure they all have to be in the same ReaderT monad
09:32:38 <besiria> dcoutts: ok, i did a cabal upgrade but didn't brought up the Cabal1.4.0.1 . i'm still seeing listed only 1.2.3.0
09:33:24 <dcoutts> besiria: via cabal ebuild ?
09:33:39 <besiria> dcoutts: the cabal-install thing
09:33:50 <besiria> dcoutts: cabal update && cabal upgrade
09:34:16 <dcoutts> besiria: 'k, and it says it worked, didn't report any failures at the end?
09:34:36 <besiria> dcoutts: nope, just grabbed the new bytestring0.9.1.0
09:34:38 <dcoutts> besiria: and you edited the config to do global installs or is it doing per-user installs again?
09:34:44 <besiria> dcoutts: global
09:34:56 <lumi> Hi, does anyone have any experience with the wxcore package?
09:35:14 <dcoutts> besiria: so does cabal upgrade --dry-run still say it'll upgrade Cabal?
09:35:16 <lumi> It doesn't build for me from hackage
09:35:38 <dcoutts> lumi: that package is broken for per-user installs (because it uses makefiles).
09:35:44 <besiria> Resolving dependencies...
09:35:44 <besiria> No packages to be installed.
09:35:44 <besiria>  
09:36:01 <dcoutts> besiria: are you sure ghc-pkg list Cabal only reports the one version?
09:36:16 <dcoutts> besiria: and you've only got one version of ghc installed ?
09:36:39 <dcoutts> besiria: Cabal just relies on ghc-pkg to tell it what's installed. There's no other hidden state.
09:37:13 <lumi> dcoutts: Thanks, what should I do to install it systemwide?
09:37:28 <dcoutts> lumi: I believe that's supposed to work
09:38:20 <lumi> dcoutts: cabal install --global wxcore should work? Because it doesn't
09:38:49 <dcoutts> lumi: it might if you run it with sudo or --root-cmd=sudo
09:38:59 <dcoutts> otherwise you'd get permission problems
09:39:14 <besiria> dcoutts: i'm absolutely sure. and i'm one version of ghc
09:39:40 <besiria> dcoutts: maybe is it because cabal-install was built against Cabal1.4.0 ?
09:39:45 <lumi> dcoutts: That's not it, it doesn't even build
09:39:51 <besiria> dcoutts: and now i'm on package.conf.shipped
09:40:33 <dcoutts> besiria: cabal-install was built against Cabal-1.4.x but that doesn't change how Cabal knows what is installed
09:40:49 <dcoutts> besiria: perhaps you can use hpaste and show the output of ghc-pkg list
09:40:51 <besiria> dcoutts: y you must be right, but it still can't see 1.4.0
09:40:52 <dcoutts> @hpaste
09:40:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:41:15 <dcoutts> lumi: then I don't know. I'm not a wx expert.
09:41:45 <haskellian> SERIOUSLY, should I consider switching to Steel Bank Common Lisp form haskell? I love haskell and think it is the most exciting language there is but I find it hard to reason about performance and I don't know if I will run into a huge wall later on...
09:41:48 <lumi> dcoutts: Thanks
09:42:11 <vixey> haskellian: Do whatever you like
09:42:25 <vixey> haskellian: Which suits what you are doing best? use that one
09:42:26 <haskellian> doing the netflix-challenge, datyamining+machine learning, finished the parsing but seems slow even after changing to byetstrings
09:42:34 <haskellian> vixey: that's what im asking
09:42:44 <haskellian> not sure, lisp will porb be great
09:42:47 <haskellian> probably
09:42:48 <besiria> dcoutts: http://hpaste.org/9685
09:43:01 <haskellian> but I really like Haskell, just not sure about performance
09:43:14 <dcoutts> haskellian: reasoning about performance is generally difficult (that's why there are plenty of uni courses covering it). Reasoning about low level haskell code gets easier with experience and understanding the evaluation order.
09:43:17 <shapr> @yow !
09:43:18 <lambdabot> Couldn't find fortune file
09:43:19 <shapr> aww
09:43:29 * shapr hugs vixey 
09:43:47 <vixey> shapr :)) *hug*
09:43:49 <dcoutts> haskellian: once I figured out to read evaluation order by looking at demand from the result of a function then it all becomes a lot clearer.
09:44:28 <haskellian> it is more about the laziness i think, I dont ahve a problem with counting Big O of fucntional languages
09:44:30 <dcoutts> besiria: and there is no per-user package db?
09:44:48 <dcoutts> haskellian: that's where understanding evaluation order really helps.
09:44:51 <ddarius> haskellian: He was talking about laziness.
09:45:10 <besiria> dcoutts: see this also http://hpaste.org/9686
09:46:04 <dcoutts> haskellian: you look at a function. you know that the result of the function will be demanded (otherwise the function would not even be called) and you look at exactly what needs to be evaluated to produce the result. That lets you work out which bits will remain lazily suspended and which will be fully evaluated.
09:46:15 <besiria> dcoutts: no there isn't , i deleted all ~/.cabal/lib files etc
09:47:02 <dcoutts> besiria: ok, so cabal also realises you've only got Cabal 1.2.x installed then.
09:47:17 <haskellian> ok thanks
09:47:34 <haskellian> i will try
09:47:45 <besiria> dcoutts: y , but cabal upgrade doesn't want to grab the new one
09:48:04 <dcoutts> besiria: try cabal install --dry-run Cabal
09:48:29 <besiria> Resolving dependencies...
09:48:30 <besiria> In order, the following would be installed:
09:48:30 <besiria> Cabal-1.4.0.1
09:48:30 <besiria>  
09:48:41 <besiria> dcoutts:  should i install it?
09:48:54 <dcoutts> besiria: if you like
09:49:23 <besiria> dcoutts: y it's fetching and building
09:49:34 <besiria> dcoutts: just cabal upgrade won't see it
09:49:42 <dcoutts> haskellian: here's an example: foo x = let y = 1+x in Just y.  So what gets evaluated there when I call foo 1?
09:50:13 <dcoutts> besiria: I'm not sure what was going on, you can see what it's doing if you cabal upgrade --dry-run -v
09:51:23 <dcoutts> besiria: ah! I know. the ghc package depends on exactly Cabal-1.2.3.0 and the ghc package cannot be upgraded/rebuilt. So cabal upgrade cannot find a consistent install plan that includes ghc and Cabal-1.4, but it does work with 1.2, so it chooses not to upgrade.
09:51:38 <dcoutts> besiria: so cabal-install was quite correct.
09:51:44 <Philonous> haskellian: Maybe you want to have a look at Ocaml, too. It's strict, so reasoning about performance should be a little easier (and according to the language shootout it performs pretty well, even compared to C)
09:52:24 <besiria> dcoutts: so shouldn't i install Cabal1.4.0?
09:52:32 <cjs> Hey, sort of a Data.Binary question here.
09:53:16 <cjs> So I've got Transaction set up as an instance of Data.Binary, and encode and decode seem to work ok, but I'd like to read a file that's a list of zero or more Transactions.
09:53:43 <cjs> Should 'decodeFile path :: IO [Transaction]' work for me? Or will it fail if there's not at least one transaction in a file?
09:54:17 <cjs> Or is the [a] instance of Binary more than just a sequence of "a"s up to the end of file?
09:54:20 <ddarius> cjs: Unless the Transactions are written out using the [] Binary instance, it will fail regardless.
09:54:39 <cjs> Ah. So what's the recommend way to read just plain Transactions until EOF?
09:55:08 <dcoutts> besiria: it's fine
09:55:12 <cjs> Oh, and how do I add a quote?
09:55:43 <vixey> I don't think a monad transformer wraps monads
09:55:56 <cjs> As a lazy list, ideally. (The Transactions thing, not the quote thing.)
09:55:56 <vixey> [Just a] is different to ListT (Maybe a)
09:56:22 <besiria> dcoutts: that means tha cabal-install will never update Cabal unless explicitly told to do so?
09:56:31 <cjs> A monad transformer makes a new monad from which you can access the, er, "sub-monads," doesn't it?
09:56:38 <dcoutts> besiria: the thing is, when you ask cabal-install to install something, it has to be slightly conservative and the only way it can be sure that things will build correctly is if there is at most one version of each package in the installation plan (including all transitive deps)
09:56:41 <ruddel> wow, haskell IS easy to read
09:56:48 <trofi> yep
09:56:52 <cjs> Yup!
09:57:00 <vixey> no it's not :P
09:57:17 <ruddel> vixey, are you dyslexic?
09:57:18 <ruddel> :P
09:57:20 <cjs> I was a little put off by some things in Haskell syntax at first, but now I'm addicted to it.
09:57:22 <besiria> dcoutts: ok got it
09:57:36 <dcoutts> besiria: you can have any number of libs installed at once, but if you want to build something that depends on the ghc package and also on the Cabal lib, then cabal-install will pick the version of Cabal that is consistent with the ghc package.
09:58:00 <mopped> Would you reccomend any books for a crash-course cjs? Got a flight which I need to burn time on :P
09:58:23 <cjs> Jeez...I guess I should write up my Haskell reading list.
09:58:30 <dcoutts> besiria: what makes it tricky is that the ghc package cannot be rebuilt, so the things it depends on are kind of fixed. It's not a problem for other packages since generally they can be rebuilt against different versions of their deps.
09:58:51 <ruddel> i'm going to read everything and anything written on haskell =p so i wont need your list
09:59:00 <cjs> The issue with a flight is you probably can't play with a Haskell interpreter whilst you're on it, right?
09:59:02 <besiria> dcoutts: but ghc pkg is not used very much, isn't it?
09:59:16 <mopped> mmm, I was under the impression I could
09:59:23 <mopped> Or do security not allow laptops?
09:59:24 <dcoutts> besiria: it's a lower level tool, so doesn't need to be used directly that often
09:59:45 <cjs> I found Graham Hutton's book very helpful. But Hudak's was the one where I looked through it (reasonably deeply, but didn't actually program along) and thought, "Wow, Haskell can do some amazing shit."
10:00:11 <cjs> mopped: Depends on how much battery you have, &c.
10:00:19 <mopped> True :)
10:00:25 <mopped> Might take a spare! (or two)
10:00:41 <besiria> dcoutts: ok never used that ghc pkg exposed modules. but does it happen to be used by another pkg? or is it because it's hidden it reassures that i'm not using it when building sth
10:00:50 <mopped> I'm only really comfortable with python and I'd like to have a go at a functional language, I'll have a look at hudaks
10:00:55 <cjs> I've never had much luck with laptops on aeroplanes, but then again, I always have oldish ones where the battery is good for about 30 min.
10:01:27 <cjs> Hudak is the, "whoa, freaky, and I don't understand yet" book. Hutton's will get you going quite nicely if you program along with him and do the exercises.
10:01:41 <cjs> Also, if you're not a big functional guy yet, _The Little Schemer_ is fantastic.
10:01:55 <cjs> And a lot of that one can be done on paper.
10:02:01 <ddarius> cjs: By repeatedly using lookAheadM, you should be able to make a parser that will parse a sequence of Transactions.
10:02:01 <dcoutts> besiria: it means the modules in the hidden package are not automagically available in ghci, or via ghc --make. It's usually because the package has modules that might clash with your own or ones from other packages, eg because it doesn't use hierarchical module names
10:02:15 <cjs> lookAheadM. Hmm.
10:02:38 <cjs> ddarius: What package is that from?
10:02:47 <besiria> dcoutts: ok ty very much for your help, everything seems fine here and i got the global layout that i wanted
10:02:50 <cjs> (Hoogle is not giving me much love these days.)
10:02:52 <ddarius> cjs: It's part of the binary package.
10:02:58 <dcoutts> besiria: great
10:02:58 <ddarius> It's in Data.Binary.Get
10:03:37 <mopped> The Little Schemer will be perfectly fine when using Haskell as my first language cjs?
10:03:48 <vixey> no
10:03:53 <mopped> ok
10:03:56 <cjs> Yes. It's the basics of any functional language.
10:04:07 <vixey> little schemer has a derivation of y in it doesn't it?
10:04:18 <cjs> If you don't deeply understand recursion, &ct,...
10:04:27 <cjs> Yes. The "Lambda the Ultimate" chapter.
10:05:33 <cjs> ddarius: Thanks. I'll play with that a bit.
10:06:24 <sm> morning all
10:06:36 <TomMD> morning
10:07:33 <TomMD> Well, 2 Gills down, three to go.
10:07:37 <cjs> One of the things I noticed about learning Haskell is that a lot of the stuff in it, even MONADS and other scary stuff like that, is just code, really. There's nothing all that special about the language except that it somewhat more nicely than Java (in terms of how ugly the syntax is) supports a certain style of coding. And _The Little Schemer_ teaches you about some of the basic, natural techniques that you use in that style.
10:07:59 <cjs> Gah, I should just do a blog entry on this. One day.
10:08:36 <TomMD> Nah, just write code.  Less talk, more code, thats what the world needs ;-)
10:09:01 <vixey> a lot of monads aren't code
10:09:16 <vixey> like (>>= return) = id isn't written down anywhere
10:10:36 * sm mutters less talk, less code
10:10:43 <cjs> Wow, I never really looked at all the interesting stuff in Data.Binary.Get. This is serious rock and roll. LIke, with double bass drums.
10:10:50 <ddarius> vixey: That's not different from most libraries/frameworks/etc.
10:10:56 <cjs> Working on the code thing....
10:11:30 <cjs> The world needs a much better mailing list manager, and Haskell is the language in which to do it.
10:12:31 <gwern> sounds like a lot of work
10:12:36 <cjs> Speaking of which, anybody got a good idea about how to generate an MD5 digest of stuff as I read it through Data.Binary?
10:12:39 <gwern> how would you do it better?
10:12:42 <cjs> gwern: Not too bad, actually.
10:13:12 <cjs> First of all, entirely distributed. A "subscribe" is just a timestamped transaction propagated between the nodes in a cluster.
10:14:30 <ddarius> cjs: There are plenty of MD5 libraries on hackage and elsewhere.
10:14:46 <haskellian> how do i get my load-path in emacs?
10:14:54 <vixey> M-x ielm
10:15:00 <vixey> IELM> load-path
10:15:07 <cjs> ddarius: Yes, we just started using that pure one today.
10:15:37 <haskellian> how do i add something to it?
10:16:06 <cjs> ddarius: But what I want to do is, while I'm reading or writing in the Get or Put monad, be able to at the end (though I'm guessing that at any point would be just as easy) to get the MD5 digest of what I've just written.
10:16:23 <ddarius> cjs: That should be trivial.
10:17:48 <cjs> Meaning for me, not *too* hard. :-)
10:17:57 <cjs> Anyway, here's what we do now: http://hpaste.org/9687
10:18:03 <cjs> And that's just wrong.
10:19:40 <gneek> Hello everyone, I'm trying to compile a something, but ./configure is telling me that I need some GHC package called "mlt". Does anyone know where I can get it?
10:20:03 <vixey> are you sure it's not actually mtl ?
10:20:13 <gneek> oh yeah, sorry
10:20:20 <trofi> @package mtl
10:20:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
10:20:28 <gneek> thanks
10:20:29 <erikc> mmm, mlt, mutton lettuce tomato
10:21:12 <ddarius> cjs: That should be more or less fine.
10:22:08 <cjs> ddarius: It works ok. But it would be much cooler if we combined it with a monad that did an update of the MD5 digest every time we put.
10:23:57 <ddarius> cjs: You could use StateT MD5Context PutM if you wanted to.
10:25:15 <cjs> Ooo! See, that's what I'm looking for!
10:26:37 <TomMD> would that be strict or would the MD5 computation be delayed?
10:27:43 <cjs> Hmm, come to think of it, I need access to the current MD5 digest from within the monad....
10:27:44 <ddarius> js: If you were to do that, I would only use it locally to handle tdata (and maybe orig and/or ts) assuming those are potentially large chunks of data.
10:28:39 <cjs> I have to md5 the whole lot of it, including the length. But yeah, just within there. The next Transaction is entirely independent.
10:31:48 <lispy> Has anyone ever made a list type class in haskell and then made all the standard list functions use that instead of [a]?
10:32:01 <ddarius> lispy: Yes.
10:32:05 <ddarius> More or less.
10:32:07 <TomMD> If its just a state monad of MD5Context, is there an issue with: get >>= return . MD5Finalize
10:32:19 <lispy> ddarius: how does it play out?  pretty good for people that want to make list-like types?
10:32:34 <TomMD> Wouldn't the dictionaries kill you?
10:32:37 <cjs> Basically, all I want is to do a "putMD5" immediately after the last line of putMostOfIt.
10:32:58 <cjs> TomMD: Howso?
10:33:04 <TomMD> putMD5 = get >>= put . md5Finalize
10:33:28 <cjs> Damn, that's it, isn't it?
10:33:31 <TomMD> cjs: sorry, I was talking about the list type class line from lispy.
10:34:10 <TomMD> Yes, but I am growing weary of the dual use of 'get' as in State monad and 'get' as in Data.Binary.
10:34:14 <lispy> TomMD: we don't seem to have that problem with (+)
10:34:17 <cjs> Oops. :-) Still like the other comment, though.
10:34:21 <TomMD> The fact that you are using both will make this ugly, now?
10:34:24 <TomMD> s/now/no/
10:34:41 <ddarius> lispy: Edison does that, but edison never seem to be very popular.
10:34:47 <cjs> Hmm. Well, I only need the State one once, so doing a qualified import won't kill me.
10:34:57 <ddarius> lispy: But it shouldn't really make a difference to the user.
10:35:40 <cjs> And you know, I find it hard to be grumpy about this sort of stuff when it's all so much nicer than any of the other languages I program in.
10:35:44 <ddarius> cjs: I'm not sure it would actually be any more efficient to do things that way as you still need the bytestring output anyway.
10:35:53 <TomMD> cjs: Is this for some library/prog that will appear on hackage?  I'm curious now.
10:36:30 <cjs> ddarius: I'm not concerned about making more efficient, really, just nicer.
10:37:00 <ddarius> cjs: The way you have it is perfectly reasonably (though I'd inline most of the lets)
10:37:17 <ddarius> Well one of them.
10:37:57 <cjs> TomMD: It might well. It's for an open-source mailing list manager that is distributed. "subscribe joe@example.com" etc. is a timestamped transaction, and we scoot these back and forth between the nodes in the cluster. You get the current list of subscribers by playing your current transaction log, that being the combined result of your transactions and all of the other ones you've gotten from other nodes in the cluster.
10:37:59 <ddarius> cjs: You can easily make a putWithMD5 function.
10:38:31 <cjs> ddarius: Really!
10:38:45 <cjs> Huh, should have thought of that.
10:39:13 <cjs> ddarius: BTW, the lets are mostly for documentation purposes. Actually, the type bit should probably be a separate instance of Binary.
10:39:14 <TomMD> Something like: putWithMD5 b = let bs = encode b in putLazyByteString bs >> put (md5 bs)
10:40:09 <TomMD> err, I guess the 'in' is not needed, but hey... irc.
10:40:26 <ddarius> The 'in' is needed.
10:46:43 <cjs> Hmm. I wonder if it would be possible to completely document a project as text in LHS files.
10:47:44 <TomMD> cjs: Sure, but I don't know how you can embed svg diagrams ;-)
10:48:01 <TomMD> I like diagrams of my program, and lhs doesn't quite get me there.
10:48:42 <cjs> Who needs SVG? We can do ASCII art!
10:49:28 <cjs> (No joke, we'll probably do this for the transaction log format. I must have read too many RFCs as a kid.)
10:50:39 <TomMD> cjs: ASCII arts use in specifying buffer/packet layouts in IETF documents is dying.  Just look at the recent packetBB proposals to see what I mean.
10:50:45 <TomMD> So sad
10:50:48 <cjs> But I was thinking more about whether one can really do a proper explanation, for those not in the know, of something sophisticated such as a distributed system by documenting along with the code.
10:51:13 <erikc> ascii art is nice, limited palette is good for the creative soul
10:51:18 <cjs> I guess if you can get the code to a high enough level, you probably can, but I'm thinking it's probably not the way I would write a book about the thing.
10:51:28 <newsham> notice a decline in the quality of the RFCs at the same time...
10:53:28 <cjs> TomMD: Are you kidding me? draft-ietf-manet-packetbb-14 has classic RFC art on pages 33 onwards.
10:56:47 <erikc> anyone know of any haskell-using companies in the vancouver area? or fp-using companies in general?
10:56:58 <erikc> my c++ days are numbered
10:58:55 <dsrogers> Is there any discussion of it RT extensions are possible in a language like haskell?
10:59:23 <newsham> real-time?
10:59:38 <dsrogers> yes
10:59:39 <rwbarton> Should I be able to darcs get the HEAD version of the base library and build it using ghc 6.8.2?
10:59:49 <newsham> i dont know, but i would think garbage collection would pose a challenge.
11:00:14 <dsrogers> well, you'd obviously have to be able to restrict when the GC could operate.
11:00:39 <erikc> dsrogers: there is an SPJ paper on real time haskell, but to my knowledge the result of that work isnt in ghc
11:00:46 <lispy> nhc used to do embeded haskell, dunno about real-time
11:01:16 <erikc> soft or hard real time?
11:01:22 <newsham> google turns this up http://mikeburrell.wordpress.com/2007/02/01/real-time-haskell/
11:01:27 <lambdabot> Title: Real-time Haskell?  Closure Sale
11:01:44 <dsrogers> oh noes!  closures are not being strongly considered for java 7 anymore...
11:01:46 <erikc> http://research.microsoft.com/~simonpj/papers/non-stop/index.htm
11:01:47 <lambdabot> Title: Simon Peyton Jones: papers
11:02:19 <rwbarton> I get these errors: http://hpaste.org/9688
11:03:02 <vixey> closures aren't idiomatic java
11:03:03 <lispy> dsrogers: heh, makes me wonder if they had impl problems
11:03:29 <dsrogers> vixey: who cares!  I'd use 'em!
11:03:33 <TomMD> cjs: notice how they are secondary material relegated to Appendix D now.  The main material is all text
11:03:44 <vixey> just don't use java if you want to do functional programming
11:03:49 <dkirk> i figured they wouldn't get the issues ironed out in the J7 timeframe
11:03:50 <erikc> ecmascript 4.0 is dead?
11:03:57 <dsrogers> vixey: I have a day job.
11:04:01 <TomMD> I don't recall this appendix being so large, but last I looked was an older version.
11:04:23 <newsham> can someone make lambdabot ?leave #haskell-blah temporarily?
11:04:27 <cjs> TomMD: Yes. I think that they wanted to give it a special section all its own, it was so pretty. :-)
11:04:31 <dsrogers> work doesn't care what language I use, as long as it runs on the jvm or is commonly available.
11:04:32 <TomMD> lol
11:04:39 <lispy> could someone part lambdac from #haskell-blah please
11:04:45 <cjs> (Actually, it's pretty ugly. Make me think that the proposed format is bad, actually.)
11:05:00 <dkirk> dsrogers: use rhino, perhaps?
11:05:09 <TomMD> cjs: Yes, it is a distilled protocol from AODV/OLSR etc.
11:05:19 <dsrogers> dkirk: actually I can do that....
11:05:24 <TomMD> A bit bloated in its attempt to be everything, but thats OT.
11:05:30 <newsham> ?bot
11:05:31 <lambdabot> :)
11:05:34 <dkirk> i've done that to good effect to get round the lack of closures
11:07:04 <ddarius> @google real time frp
11:07:13 <lambdabot> http://citeseer.ist.psu.edu/440607.html
11:07:13 <lambdabot> Title: Real-time FRP - CiteSeerX
11:07:58 <cjs> TomMD: Hey, it's a "new" network protocol. You gotta do that, or IPv6 is going to leave you in the dust. :-)
11:16:30 <newsham> "A programming language is low level when its programs require attention to the irrelevant".  wow, good quote.
11:16:54 <TomMD> Where is that from, newsham.
11:17:05 <vixey> every language is low levela then ..
11:17:14 <newsham> -Alan Perlis,  quoted in courtney/elliott's genuinely functional guis
11:17:28 <koeien37> define "relevant"
11:17:39 <newsham> thats the next sentence, koe
11:17:43 <newsham> :)
11:17:46 <Korollary> low level concerns can be very relevant
11:17:50 <newsham> "But how should we decide what is relevant?"
11:18:47 <vixey> kind of amusing video  by the way http://rocky.dlib.vt.edu/~cs4624/spring_2001/history_of_prog_lang/perlis.html
11:18:49 <lambdabot> Title: Alan Perlis, http://tinyurl.com/6krghx
11:19:39 <cjs> I have Perlis's quotes as my fortune file.
11:21:06 <TomMD> ?quote newsham
11:21:07 <lambdabot> newsham says: so the key to immortality is ambiguous naming?
11:21:21 <TomMD> What an insight!
11:22:07 <Korollary> It's a question
11:22:13 <newsham> is it?
11:22:17 <Korollary> Yes?
11:22:26 <newsham> isnt everything a question?
11:22:44 <Lycurgus> I thought it was "don't die"
11:22:57 <Lycurgus> .
11:22:58 <newsham> ?quote die
11:22:59 <lambdabot> dons says: so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
11:23:00 <Korollary> I thought it was your body never being found.
11:24:02 <ddarius> @quote \<die\>
11:24:03 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
11:24:03 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
11:24:03 <lambdabot> do after the heat death of the universe
11:24:13 <Lycurgus> (you know "the real death", principled form breaches permitted on a case-by-case basis)
11:26:59 <chrisdone> what's that algorithm called to see if a list is cyclic?
11:27:21 <newsham> cycle/loop detection?
11:27:24 <chrisdone> yeah
11:27:26 <ddarius> "chasing pointers" or something like that?
11:27:28 <Lycurgus> occurs check?
11:27:30 <chrisdone> ahhh, thanks
11:27:33 <chrisdone> ddarius: that's the one
11:27:42 <cjs> Are we done with the Rosencrantz and Guildenstern bit now?
11:27:49 <vixey> :S ?
11:27:51 <vixey> what
11:28:07 <cjs> In the old days we used to say, SP.
11:29:05 <Lycurgus> relevant would mean essential to the tihing at hand
11:29:09 <Lycurgus> *thing
11:29:36 <TomMD> ?quote PhD
11:29:37 <lambdabot> sioraiocht says: was dons PhD in writing random haskell libraries?
11:29:39 <Lycurgus> so a programming language that allowed programming in natural language in specific problem domains
11:29:48 <sioraiocht> lol
11:29:54 <TomMD> thats a good one.
11:29:58 <Lycurgus> would eschew the detail irrelevant to a non-programmier
11:30:11 <newsham> i'd buy that
11:30:18 <vixey> goshhhh everybody here has a PhD except me
11:30:27 <vixey> that's probably why I am here
11:30:28 <sioraiocht> vixey: I'm PhDless, for now
11:30:33 <newsham> i have a lowly masters degree
11:30:37 <newsham> which means i probably make more money
11:30:42 <Korollary> I have street cred
11:30:47 <vixey> ooh
11:30:47 * ddarius has no degree.
11:30:59 <newsham> ddarius sometimes gives the fifth degree
11:31:03 <Korollary> ddarius: but you're licensed to kill
11:31:04 * Lycurgus is off grid but does have a 4-year degree.
11:31:05 * sioraiocht will finish his masters degree in 3 weeks
11:31:10 <newsham> sior: congrats
11:31:15 <TomMD> good work
11:31:19 <ddarius> Korollary: That does always make up for a lack of formal education.
11:31:23 <sioraiocht> newsham: thanks, heh, I start my PhD 3 weeks later
11:31:39 <TomMD> "PhD students have life easy" -- dons
11:31:39 <newsham> glutton for punishment? :)  best of luck!
11:31:49 <erikc> is applying/going for a phd without a masters suicidal?
11:31:50 <newsham> have you decided on a topic?
11:31:53 <erikc> cause its an option im looking at
11:31:54 <sioraiocht> erikc: no
11:31:59 <sioraiocht> erikc: it's quite common
11:32:00 <Lycurgus> from what I've seen academe is lttle better than industry and often as not indistinct from it
11:32:07 <erikc> k
11:32:11 <sioraiocht> newsham: yes, contract based verification using type systems
11:32:11 <TomMD> ddarius: Are you an officer or is this an inside joke?
11:32:24 <newsham> neat.
11:32:45 <Lycurgus> (maybe worse in some aspects)
11:32:52 <sioraiocht> erikc: I only chose to an MSc first because I had no thesis for my bachelor's
11:33:45 <TomMD> sioraiocht: You must have seen Dana Xu's work then, right?
11:33:55 <sioraiocht> TomMD: yes I have
11:33:56 <dsrogers> how do I tell if ghc on my platform  is using native code compiling?
11:33:59 <newsham> is she the one that did extended static checker?
11:34:17 <newsham> (or is Dana a guys name in this context?)
11:34:17 <TomMD> Yes
11:34:17 <sioraiocht> newsham: yes
11:34:18 <trofi> @src Arbitrary
11:34:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:34:24 <TomMD> No, she is a she
11:34:40 <sioraiocht> newsham: no, it's an English pseudonym for a Chinese woman, heh
11:34:52 * TomMD heads out to lunch, later
11:34:52 <newsham> its weird that they do that...
11:35:14 <sioraiocht> newsham: I know, they often seem to choose names that are a generation old
11:35:15 <newsham> <- *hearts* code audits with comments by very english first names and very chinese last names
11:35:50 <Korollary> newsham: I have many coworkers with such names
11:36:14 <ddarius> TomMD: I'm an enlisted member of the United States Air Force.
11:36:25 <cjs> That Perlis video is great!
11:36:43 <sioraiocht> ddarius: any chance you work for AFRL?
11:36:58 <newsham> ddarius: any plans to join cyber command?
11:37:18 <ddarius> newsham: If I were to stay in, I probably would.
11:37:24 <ddarius> sioraiocht: No.
11:37:28 <Korollary> omg ddarius on his way out?
11:37:35 <cjs> Hey, I just attended a talk by Dana the other day!
11:37:36 <Korollary> private sector beware
11:37:42 <newsham> it would be awesome to see ddarius flying through the cyber
11:37:43 <ddarius> Korollary: In a few days I'll be exactly half way through my enlistment.
11:37:45 <newsham> dominating
11:38:08 <cjs> I've no idea why she was in Tokyo, but if she gets her new project cleaned up pretty well, QuickCheck is toast.
11:39:34 <cjs> Well, that's probably going a little far, but she's working on some pretty cool shit.
11:39:43 <Heffalump> I have an up to date GHC build tree, that first fails to build because libraries/bootstrapping is present, and then when I remove that fails to build because of a lack of Exception.onException somewhere inside cabal.
11:40:06 <Heffalump> anyone know why?
11:40:12 <dcoutts_> Heffalump: ask Igloo
11:40:58 <Igloo> Heffalump: All your repos are up-to-date?
11:41:02 <Heffalump> Igloo: yep
11:41:11 <Heffalump> this has been happening for well over a week, FWIW
11:41:13 <Igloo> Are you starting from distclean?
11:41:48 <Heffalump> ah. No. /me tries that.
11:41:49 <guenni> dcoutts: ping
11:41:53 <dcoutts_> guenni: pong
11:42:23 <guenni> dcoutts: the build went fine, but the install failed: http://hpaste.org/9689
11:42:58 <Heffalump> nope, still fails with the onException problem (make distclean ; ./configure --prefix=something ; make)
11:43:02 <haskellian> why  is this causing tack overflow?it is tailrecursive isnt it? http://hpaste.org/9690
11:43:18 <vixey> haskellian: Wrong channel
11:43:19 <eu-prleu-peupeu> is it possible to have in haskell a function like this: add :: Num a => vec a->b->vec a, and then another function like this: add :: Num a => vec a->vec a->vec a  on the same type class ?!
11:43:31 <eu-prleu-peupeu> because ghc complaints about the name... that they collide :/
11:43:31 <dcoutts_> guenni: I've never really tested install with registration on windows since we only use it to generate install images for the installer. So you probably want to do what the scripts in the tools/win32  dir do. I think they --enable-packager-mode and do a make install using DESTDIR=something
11:43:36 <vixey> haskellian: Also don't write scheme code in common lisp, that's weird
11:43:48 <vixey> haskellian: (Use labels instead of defun)
11:44:02 <dcoutts_> guenni: then you'd have to manually register each of the packages in order (which is what the installer does)
11:44:25 <guenni> dcoutts: thx I'll try that
11:44:33 <dcoutts_> guenni: oh, hmm. --enable-packager-mode on windows means the package config files are relocatable and need a var substituting into them before registration
11:44:39 <rwbarton> eu-prleu-peupeu: no.  what are you trying to do?
11:44:49 <eu-prleu-peupeu> hmm
11:44:52 <dcoutts_> guenni: which is another thing the installer does once it knows where the user wanted to install to
11:44:54 <eu-prleu-peupeu> scalar add, and vector add
11:44:58 <eu-prleu-peupeu> with the same name
11:45:06 * ddarius would recommend using Scheme instead of Common Lisp...
11:45:19 <dcoutts_> guenni: the scripts in tools/win32 should provide a good hint since that's what we actually build with.
11:45:22 <haskellian> viexy: huh? labels?
11:45:32 <eu-prleu-peupeu> ...i just thought, C++ allows functions with the same name but different type sigs... (C doesn't), so...
11:45:35 <rwbarton> eu-prleu-peupeu: there's no such thing as scalar add -- and that type is too general to be useful
11:45:47 <dcoutts_> guenni: the ones called win32-*.sh, the others are for building the gtk sdk
11:46:12 <eu-prleu-peupeu> rwbarton: if a user wants to add a scalar to every vector coordinate, then it is useful (specially in multiplication)
11:46:46 <rwbarton> eu-prleu-peupeu: C++ knows the type of the arguments to the function before it decides which to use, but in Haskell type inference doesn't proceed in a single direction like that, so it would be very difficult in the presence of multiple types for the same value
11:47:02 <guenni> dcoutts: do you know why sourceview was left out?
11:47:18 <dcoutts_> guenni: not exactly, you'd have to ask pgavin
11:47:44 <dcoutts_> guenni: he said he had some problem with it. I don't know. I know it was in 0.9.12.1 using the gtk sdk you're now using.
11:48:14 <rwbarton> eu-prleu-peupeu: Imagine you have f :: a -> b, f :: a -> c, g :: b -> d, g :: c -> d.  What does g . f mean?
11:48:25 <guenni> well in that case I think I'll just save myself all that trouble and use that version
11:48:50 <dcoutts_> guenni: there's an installer for that for ghc 6.8.1 or .2, not .3
11:49:05 <eu-prleu-peupeu> hmm
11:49:12 <eu-prleu-peupeu> ah yess
11:49:13 <eu-prleu-peupeu> ok
11:49:17 <eu-prleu-peupeu> thanks rwbarton
11:49:18 <eu-prleu-peupeu> :)
11:49:21 <guenni> well I'll downgrade then
11:49:29 <eu-prleu-peupeu> my mind is still stuck on procedural way of thinking so... :P
11:49:31 <eu-prleu-peupeu> hehehe
11:49:39 <dcoutts_> guenni: the 0.9.12.1.exe from the gtk2hs website is for 6.8.1, and for 6.8.2 use http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
11:50:33 <guenni> thanks bigtime
11:52:41 <lispy> if your accumulator is a list then making the accumulator strict in pointless, right?
11:53:40 <cjs> Depends on if you're evaluating the list, I would think.
11:53:50 <tehgeekmeister> is there a way to do multiline matching with Text.RegexPR?  or is there another regex library that can do multiline matching?
11:53:59 <sioraiocht> lispy: do you plan on using  your accumulator?
11:54:27 <lispy> sioraiocht: well, i constructed it and returned it, so presumably the consumer will eventually look at it
11:55:39 <rwbarton> lispy: if your recursive function only builds the list using (:) and never pattern matches on it, then whether it's strict or not will make very little difference
11:56:37 <lispy> rwbarton: gotcha.  So if you use large thunks when you cons together the elements that colud be bad.
11:57:13 <lispy> But if you do pattern match on it, you might as well make it strict?
11:57:55 <rwbarton> I'm not sure what I can say in general.  I could give a silly example where the accumulator needs to be strict
12:00:18 <rwbarton> I don't think it will ever hurt to make it strict, but it usually won't be necessary.  It would only affect the spine of the list, not its elements.
12:02:29 <rwbarton> An unforced application of (:) and an evaluated application of (:) are both basically a pair of pointers--(:) differs from (+) in that way.
12:03:00 <trofi> @pl \n -> if n == 0 then False else True
12:03:00 <lambdabot> flip (flip if' False . (0 ==)) True
12:03:20 <Deewiant> (/= 0)
12:03:29 <trofi> yep
12:03:56 <trofi> copy/pasted it from realworldhaskell :\
12:04:39 <dons> trofi: ?
12:04:50 <trofi> http://book.realworldhaskell.org/beta/testing.html - in the middle :]
12:04:51 <lambdabot> Title: Chapter 13. Testing and quality assurance
12:04:56 <eu-prleu-peupeu> what is it that function signum does ?
12:04:58 <dons> yeah, that's been changed.
12:05:02 <eu-prleu-peupeu> oh
12:05:03 <trofi> oh
12:05:06 <eu-prleu-peupeu> i've seen it on the report
12:05:07 <eu-prleu-peupeu> thanks
12:05:08 <eu-prleu-peupeu> :P
12:05:09 <Deewiant> > signum (-1)
12:05:10 <dons> the intent was to try to be clear about how the genreation worked
12:05:11 <lambdabot>  -1
12:05:15 <eu-prleu-peupeu> yes yes
12:05:15 <Deewiant> > signum (-2)
12:05:17 <lambdabot>  -1
12:05:19 <eu-prleu-peupeu> thanks Deewiant
12:05:30 <Deewiant> oh, right, you saw it
12:05:43 <Deewiant> but yeah, returns the sign :-)
12:06:10 --- mode: ChanServ set +o dons
12:06:21 <trofi> dons: i've sent you a letter yesterday about hs-plugins. could you enlighthen me a little about?
12:06:48 --- mode: ChanServ set -o dons
12:06:54 <dons> hang on. busy... but yes. i'll reply
12:07:05 <trofi> thanks! :]
12:07:12 --- mode: ChanServ set +o dons
12:07:16 * ddarius writes dons a paper letter.
12:07:18 <dsrogers> does the ghc linker understand how to make static and dynamic packages play nice with one another?
12:07:19 --- mode: ChanServ set -o dons
12:07:57 <dons> dsrogers: to some extent
12:09:01 <dsrogers> I'm trying to build a particular HOC library as dynamic.  When I attempt to load it to compile something that depends on it, ghc complains about a function in base::Forgien as missing
12:12:25 <tehgeekmeister> what's a single ascii character that's unlikely to occur in a wikipedia dump that i can replace the newlines with in order to emulate multiline matching?
12:12:53 <dons> \NUL ?
12:13:01 <monochrom> \
12:13:29 <dons> > '\EOT'
12:13:30 <trofi> you can reserve any symbol for prefix purposes
12:13:31 <lambdabot>  '\EOT'
12:13:50 <r3m0t> > '\EOF'
12:13:50 <lambdabot>  Illegal escape sequence at "'\EOF..." (column 1)
12:14:00 <dons> device control 1 ?
12:14:02 <tehgeekmeister> dons: ah, okay, was avoiding that because of remembering how c strings are terminated by null
12:14:06 <dons> > '\DC1'
12:14:08 <lambdabot>  '\DC1'
12:14:09 <tehgeekmeister> dons: should've figured haskell didn't do that
12:14:27 <dons> end of bulk transfer?
12:14:29 <dons> > '\ETB'
12:14:31 <lambdabot>  '\ETB'
12:14:36 <dons> these are great :)
12:15:07 <ddarius> > '\BTB'
12:15:08 <lambdabot>  Illegal escape sequence at "'\BTB..." (column 1)
12:15:10 <trofi> @type isPunct
12:15:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:15:14 <ddarius> > '\&'
12:15:15 <lambdabot>  Illegal escape sequence at "'\&'" (column 1)
12:15:37 <rwbarton> > "\&"
12:15:39 <lambdabot>  ""
12:15:40 <trofi> @type isPrint
12:15:40 <monochrom> I still like my \ . It makes people's life hard.
12:15:41 <lambdabot> Char -> Bool
12:16:02 <ddarius> > "\&\&\&\&\&\&"
12:16:04 <lambdabot>  ""
12:16:06 <trofi> > take 10 $ filter (isPrint.char) [0..]
12:16:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `Doc'
12:16:10 <rwbarton> I've never understood why \& exists
12:16:16 <tehgeekmeister> > "^nul"
12:16:18 <lambdabot>  "^nul"
12:16:22 <trofi> @type chr
12:16:23 <tehgeekmeister> huh, doesn't do it here
12:16:24 <lambdabot> Int -> Char
12:16:34 <trofi> > take 10 $ filter (not.isPrint.chr) [0..]
12:16:36 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
12:16:37 <tehgeekmeister> > "\^nul"
12:16:38 <lambdabot>  Illegal control character at ""\^nu..." (column 1)
12:16:41 <ddarius> rwbarton: Some named escape codes overlap with hexadecimal ones.
12:16:46 <ddarius> Or something like that.
12:16:48 <tehgeekmeister> > "\^NUL"
12:16:50 <trofi> > take 10 $ filter (not.isPrint) $ chr.[0..]
12:16:51 <lambdabot>  "\SOUL"
12:16:52 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t"
12:16:53 <tehgeekmeister> yes!
12:17:15 <tehgeekmeister> "\^NUL" == "\SOUL", according to haskell.
12:17:30 <tehgeekmeister> apparently.
12:17:31 <rwbarton> ddarius: so it's there to terminate a \... sequence or something?
12:17:52 <ddarius> http://www.haskell.org/onlinereport/lexemes.html See section 2.6
12:17:56 <r3m0t> > filter (not.isPrint) $ chr.[0..]
12:17:56 <monochrom> "\NUL\SOH\CAH\TOA..."
12:17:58 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
12:18:18 <tehgeekmeister> well, okay, "\^NUL" prints as "\SOUL" apparently.
12:18:19 <r3m0t> SOHCAHTOA? ;-)
12:18:19 <rwbarton> I see.  (Eww)
12:18:24 <monochrom> Yeah!
12:18:29 <rwbarton> > "\SO\&H"
12:18:31 <lambdabot>  "\SO\&H"
12:19:09 <bd_> > map fromEnum "\^NUL"
12:19:10 <lambdabot>  [14,85,76]
12:19:26 <bd_> > map (\v -> [toEnum v :: Char]) $ map fromEnum "\^NUL"
12:19:28 <lambdabot>  ["\SO","U","L"]
12:19:37 <bd_> heh, weird
12:19:47 <bd_> ah, \^N
12:20:36 <trofi> @type liftM
12:20:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:20:48 <dsrogers> ok, so it appears that even though ghci loads them, ghc is not linking in the static dependencies of a shared library.  is this a known limitation?
12:20:55 <trofi> > liftM (\x -> return [x]) "hello"
12:20:57 <lambdabot>   add an instance declaration for (Show (m [Char]))
12:21:12 <trofi> > liftM (\x -> return [x]) "hello" :: [Char
12:21:13 <lambdabot>  Parse error at end of input
12:21:15 <trofi> > liftM (\x -> return [x]) "hello" :: [[Char]]
12:21:17 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
12:21:45 <ddarius> > liftM (return . return) "hello" :: [[[Char]]]
12:21:48 <lambdabot>  [["h"],["e"],["l"],["l"],["o"]]
12:22:06 <trofi> "hello" >>= \x -> return [[x]]
12:22:11 <trofi> > "hello" >>= \x -> return [[x]]
12:22:14 <lambdabot>  [["h"],["e"],["l"],["l"],["o"]]
12:22:36 <ddarius> > "hello" >>= return . return . return
12:22:38 <lambdabot>   add an instance declaration for (Show (m (m1 Char)))
12:22:46 <trofi> @pl "hello" >>= \x -> return [[x]]
12:22:47 <lambdabot> (return . return) `fmap` "hello"
12:23:59 <r3m0t> > (\x -> return [[x]]) 1 == ((:[]).(:[])) 1
12:24:00 <lambdabot>   add an instance declaration for (Num [t])
12:24:48 <trofi> @hoogle m a -> m m a
12:24:48 <lambdabot> A Hoogle error occurred.
12:25:37 <vixey> join
12:25:39 <vixey> trofi:
12:25:43 <vixey> m m a = m (m a)
12:25:47 <vixey> oh wait no it doesn't :P
12:25:54 <vixey> m m a = (m m) a
12:26:03 <vixey> but join :: m (m a) -> m a
12:26:12 <vixey> return :: a -> m a
12:26:24 <vixey> if you let a = m b
12:26:37 <guenni> that's nice, 2 days wasted
12:26:46 <vixey> guenni: It wasn't quite 2 days..
12:26:48 <vixey> :)
12:26:49 <guenni> nothing whatsoever achieved
12:27:10 <guenni> vixey: trust me it was more than that
12:27:12 <trofi> i'd like to raise monad order (thought there was easy function)
12:27:27 <osfameron> is there an existing haskell library for calculating mortgage payments?
12:27:27 <vixey> trofi: return
12:27:33 <osfameron> e.g. pmt and fv functions?
12:27:37 <trofi> > return."hello"
12:27:38 <lambdabot>   add an instance declaration for (Show (m Char))
12:27:44 <guenni> not that I would have spent those 2 days trying to get laid but still
12:27:56 <monochrom> No . please
12:27:59 <osfameron> I have an idea haskell would be more sophisticated than what's in Excel/OOCalc, but can't find any pre-written libs on hackage for it
12:28:20 <madhadron> osfameron, Are they really that complicated?
12:28:31 <trofi> @type zip
12:28:32 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:28:37 <desp> Hi.  Is there an up-to-date tutorial somewhere on writing a parser/compiler in Haskell?
12:28:41 <osfameron> madhadron: well, not *that* complicated
12:28:59 <ddarius> guenni: Now you know better.
12:29:04 <osfameron> madhadron: but for example to write pmt function you need to worry about payment periods, which I'd like to abstract to monthly transparently, etc.
12:29:12 <tusho> "Type inference is undecidable in Haskell." lol comp.lang.lisp
12:29:13 <monochrom> Haskellers are so rich they buy houses without mortgage. :)
12:29:17 <trofi> @type lift
12:29:18 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
12:29:28 <madhadron> monochrom, Or are students and rent
12:29:37 <osfameron> and the fv function needs to know about things like when the payment is made (before/after period?) and how often interest is compounded
12:29:42 <monochrom> Haskellers are so poor they aren't in the mortgage business. :) :)
12:29:58 <osfameron> I've written pmt, but I haven't yet worked out a definition of fv from the wikipedia description
12:30:21 <madhadron> osfameron, You probably have found one of those ugly little corners where there is insufficient category theory and too many complications to have been done by natural selection.
12:30:26 <osfameron> well, I'm hoping to be a *little* less poor, by choosing the next mortgage product when ours runs out in october...
12:30:35 <osfameron> madhadron: you mean becuase it's useful to real people? ;-P
12:30:59 <madhadron> osfameron, Well, partially, but the lack of category theory is more of a showstopper.
12:31:02 <osfameron> I will submit it when I'm done then, to great acclaim and imense riches!
12:31:07 <osfameron> *immense
12:31:43 <monochrom> Bankers don't have a good reputation these days. Forget acclaim.
12:31:58 <madhadron> Though I bet you could treat the FV as a 2-ary function on time and a lattice of successively finer topologies of time intervals...
12:32:03 <r3m0t> osfameron: [[Future value]] already has the PHP code
12:32:11 <trofi> @do m >>= \x -> return [[x]]
12:32:12 <lambdabot> m >>= \x -> return [[x]] not available
12:32:18 <osfameron> r3m0t: yeah, cos PHP is such a good language for describing algorithms
12:32:27 <r3m0t> fv p i t = p * ((1+i)^t
12:32:30 <osfameron> the PMT article has something written in VB.net
12:32:32 * osfameron cries
12:32:36 <rwbarton> @redo  m >>= \x -> return [[x]]
12:32:37 <lambdabot> do { x <- m; return [[x]]}
12:32:52 <osfameron> I mean, even C would be clear...  it's just arithmetic
12:33:02 <r3m0t> all you need is an exponentiation function
12:33:07 <osfameron> yeah
12:33:07 <monochrom> PHPers and VBers got hired by bankers, that's why. Or even better, bankers like PHP and VB, they do it themselves.
12:33:16 <r3m0t> ...which Prelude has
12:33:35 <osfameron> I just need a function that gives me the payment schedule as a stream
12:33:52 <r3m0t> osfameron: you mean a list?
12:33:56 <profmakx> osfameron  like the fibonacci series?
12:34:09 <osfameron> but which can do things like "Assuming interest rate of 6% for 3 years, followed by 7% for next 2 years, but overpaying 500) etc.
12:34:50 <trofi> > liftM return "hi"
12:34:50 <monochrom> In your Haskell code you can add sophistication for numerical accuracy.  (1+0.04)^10 is not easy to compute.
12:34:51 <lambdabot>   add an instance declaration for (Show (m Char))
12:35:03 <trofi> > (liftM return). "hi"
12:35:04 <dsrogers> oh I see.
12:35:05 <lambdabot>  Couldn't match expected type `m a1' against inferred type `Char'
12:35:07 <profmakx> oh
12:35:13 <r3m0t> ok, monthly repayments with those rates on 10000
12:35:24 <r3m0t> best to calculate the outstanding payment
12:35:47 <trofi> > (1+0.04)**10 :: CReal
12:35:50 <lambdabot>  1.48024428491834392576
12:35:57 <monochrom> How accurate is it?
12:36:05 <vixey> 100%
12:36:26 <int-e> > (1+0.04)^10 :: Rational
12:36:28 <lambdabot>  141167095653376%95367431640625
12:36:33 <monochrom> Oh CReal.
12:36:56 <trofi> > ((1 :: CReal)+0.04)**10
12:36:58 <lambdabot>  1.48024428491834392576
12:37:05 <matthew-_> @seen ski
12:37:06 <lambdabot> ski is in #haskell.hr, ##logic, #haskell-overflow and #haskell. I last heard ski speak 3h 37m 24s ago.
12:37:24 <osfameron> what's CReal?
12:37:26 <trofi> @package numbers
12:37:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
12:37:27 <monochrom> OK I love you. :)
12:37:35 <monochrom> http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-CReal.html
12:37:36 <cjay> sounds like cereal :)
12:37:37 <lambdabot> Title: Data.Number.CReal, http://tinyurl.com/5o8mj8
12:38:07 <matthew-_> right, you remember that function I had before?
12:38:08 <osfameron> "(constructive) real numbers." ?
12:38:09 <matthew-_> > let h 1 = [1]; h n = (h (n-1)) ++ (n : (h (n-1))) in h 5
12:38:11 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
12:38:14 <ddarius> cjay: Then you pronounce "real" funny (or "cereal" funny)
12:38:24 <matthew-_> and then you transformed it to a streaming version, which was cool
12:38:41 <matthew-_> well I actually need an step function from it
12:39:06 <matthew-_> such that I have the index into the list and need to calculate the corresponding value, but without forming the rest of the list head
12:40:17 <trofi> @help hackage
12:40:18 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(22,19)-(45,62): Non-exhaustive patterns in case
12:41:05 <vixey> matthew-: ski gave code for that
12:41:11 <trofi> @help help
12:41:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:41:18 <rwbarton> > showCReal 100 pi
12:41:20 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
12:41:34 <matthew-_> vixey: ahh, ok thanks for the reminder, I'll dig it out
12:41:34 <monochrom> > ((1+0.04)**20 :: CReal, (1+0.04)**20 :: Double)
12:41:35 <r3m0t> :t showCReal
12:41:37 <lambdabot>  (2.1911231430334193505480762776602883915776,2.191123143033421)
12:41:37 <lambdabot> Int -> CReal -> String
12:41:49 <lispy> We need someone to work on the darcs-benchmark component of maybench.  Any one interested?
12:41:50 <vixey> matthew-: did you make the other sequence? I gave up on it :p
12:42:03 <monochrom> > ((1+0.04)**100 :: CReal, (1+0.04)**100 :: Double)
12:42:05 <lambdabot>  (50.5049481842694126040487171314144660060729,50.50494818426959)
12:42:14 <matthew-_> vixey: yeah, I gave up too. But then I'm busy working on other things so was lacking motivation ;)
12:42:21 <lispy> I should say more people as you wouldn't be alone
12:42:28 <monochrom> OK you can argue that the Double gives enough good digits.
12:42:33 <madhadron> I'm having to add a lot of basic packages to hs-plugins's cabal file.  Is there a generic package name for all the GHC basic libraries?
12:42:46 <rwbarton> ((1+0.001)**1000 :: CReal, (1+0.001)**1000 :: Double)
12:42:49 <rwbarton> > ((1+0.001)**1000 :: CReal, (1+0.001)**1000 :: Double)
12:42:51 <lambdabot>  (2.7169239322358924573830881219475771889643,2.7169239322355936)
12:44:43 <ddarius> > let f n = f' (n-1) [n]; f' n ns = f (n-1) $ intersperse n ns in f 5
12:44:45 <lambdabot>      Occurs check: cannot construct the infinite type: b = [a] -> b
12:44:45 <lambdabot>     Proba...
12:45:05 <ddarius> > let f n = f' (n-1) [n]; f' n ns = f' (n-1) $ intersperse n ns in f 5
12:45:12 <lambdabot>  Exception: Time limit exceeded
12:45:20 <ddarius> > let f n = f' (n-1) [n]; f' n ns = f' (n-1) $ intersperse n ns; f' 0 ns = ns in f 5
12:45:22 <lambdabot>      Warning: Pattern match(es) are overlapped
12:45:22 <lambdabot>              In the definition...
12:45:42 <ddarius> > let f n = f' (n-1) [n]; f' 0 ns = ns; f' n ns = f' (n-1) $ intersperse n ns in f 5
12:45:44 <lambdabot>  [5]
12:47:07 <rwbarton> matthew-_: if you just want to get the nth element, that has to do with the number of times 2 divides n+1
12:47:37 <ddarius> > let f n = f' (n-1) [n]; f' 0 ns = ns; f' n ns = f' (n-1) $ intersperse' n ns; intersperse' x [] = [x]; intersperse' x (y:ys) = x:y:intersperse' x ys in f 5 -- last time
12:47:39 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
12:48:26 <dsrogers> oooooo.
12:48:32 <madhadron> Wouldn't it be easier just to zip and flatten a couple of times?
12:49:21 <ddarius> Curse the lack of a binary tree data type.
12:49:21 <int-e> > (1+0.1^1000 :: CReal) == 1
12:49:23 <lambdabot>  True
12:51:17 <ddarius> data Tree a = Leaf a | Node (Tree a) a (Tree a); buildTree 1 = Leaf 1; buildTree n = Node sub n sub where sub = buildTree (n-1); inOrder (Leaf x) = (x:); inOrder (Node l x r) = inOrder l . (x:) . inOrder r
12:53:19 <monochrom> Interesting sequence.
12:53:40 <haskellian> is there optional parameters in haskell? i would guess not because of something with purity
12:53:53 <ddarius> haskellian: Purity has nothing to do with it.
12:54:42 <madhadron> haskellian, Nope, and it's not purity.  It's well defined types.
12:54:46 <monochrom> optional parameters have harder types
12:55:04 <madhadron> If you had an optional parameter a function could be A -> B -> C or A -> C
12:55:05 <ddarius> > let f 1 = (1:); f n = s . (n:) . s where s = f (n-1) in f 5 []
12:55:07 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
12:55:51 <vixey> :t join ($ ?x)
12:56:23 <dons> f Nothing = 1
12:56:28 <dons> f (Just x) = 2
12:56:34 <dons> -- typed optional parameters :)
12:57:05 <dsrogers> ah I see at last.  If I'm going to build a dynamic haskell library among a bunch of static haskell libraries, I need to statically link the dependenices into my haskell library
12:57:20 <monochrom> ocaml uses syntactic sugar to do optional parameters. An optional parameter of type X is translated to a mandatory parameter of type Maybe X. It also unsatisfactorily guesses when you say "f x" whether you mean currying or leaving out optional parameters.
12:57:47 <GrayShade> can anyone give me any tips on making this source more ..ahem.. 'readable'? http://pastebin.com/d3c08954b
12:58:13 <GrayShade> (i. e. not replacing "makeGroup xs = (head xs, length xs)" with head &&& length)
12:58:37 <monochrom> Very few ocamlers use currying, so you can always guess leaving out optional parameters. Most haskellers use currying, so you can't make optional parameter practical.
12:59:09 <dsrogers> that's painful
13:00:08 <Philippa> lack of currying's painful too, though
13:00:27 <Philippa> and in a lot of situations there're good ways to handle the equivalent of optional parameters
13:00:32 <Philippa> eg the way Parsec handles error
13:00:34 <Philippa> *errors
13:01:06 <ddarius> Haskell libraries tend to take a combinatorial approach rather than an uber-function approach.
13:01:07 <TomMD> I remember life with optional parameters.   I'd see great code like: doFoo(var, st, opt /* implicit True for our toggle */);
13:01:21 <madhadron> dsrogers, By dynamic Haskell library as opposed to static, you mean one dynamically loaded or do you mean static vs dynamic for the compiler?
13:01:26 <TomMD> Its great to see those comments that destroy the value of the parameter being optional.
13:01:31 <Philonous> Isn't there a difference between currying and partial application? Afaik is currying the transition from "(a,b)->c" to "a -> b -> c". Isn't it?
13:01:58 <dsrogers> madhadron: well if it is dynamic to the compiler, isn't it also dynamically loaded.
13:02:15 <GrayShade> Philonous: partial application would be ((a, b) -> c) -> b -> a -> c
13:02:17 <Philippa> Philonous: there is a difference, yes. People more generally use "currying" to mean "using the curried version" though
13:02:18 <ddarius> Philonous: Yes it is.
13:02:23 <erikc> tommd: the class im looking at right now has a constructor with 6 required, 12 optional parameters...
13:02:35 <TomMD> That would matter much more, yes.
13:02:39 <ddarius> GrayShade: Partial application is just applying a curried function.
13:02:44 <dsrogers> madhadron: basically, I have a library libHOC.dylib, and a ghc-pkg to go along with it.  If I link in the HOC package, I get link errors from packages that libHOC.dylib depends on.
13:02:44 <jnordenberg> is there a language that allows objects to be encoded as functions? ie, a -> b where b = ... if a = ..., etc
13:02:51 <ddarius> Philippa: And they should stop doing that.
13:03:00 <monochrom> I don't miss optional parameters.  Suppose I am given "f x y z t u" and I find that 40% of the time I call it as "f x 0 z True u".  I locally define "g x z u = f x 0 z True u", problem solved.
13:03:15 <Philippa> ddarius: *nod*
13:03:21 <GrayShade> ddarius: that's what I tried to say with the signature
13:03:22 <dsrogers> madhadron: I believe the problem is that the libHOC.dylib dependencies are all static, and so must be linked in.
13:03:25 <TomMD> erikc: Don't get me wrong - about the first thing I noticed when I started with Haskell was the lack of optional params.  And I didn't miss the fact that OCaml includes them.  But I really liked the easy partial application.
13:03:36 <agcorona> by the way, any idea about when dynamic linking will be available for GHC?
13:03:47 <Philonous> I was just a little confused because currying and partial application seem to be used synonymously here
13:03:55 <madhadron> dsrogers, Do you think this is a general problem, or MacOS library hell?
13:03:59 <monochrom> Oh oops, I mean partial application all along. :)
13:04:14 <madhadron> Philonous, Well, they're isomorphic if you squint just right
13:04:21 <monochrom> hehe
13:04:29 <dsrogers> madhadron: not sure.
13:04:32 <erikc> tommd: oh, i hate optional params :), and there is a tendency for them to grow like fungus because once one parameter is optional, people tend to make all subsequent parameters optional as things grow
13:04:40 <osfameron> yeah
13:04:43 <dsrogers> madhadron: I'm guessing it's general.
13:04:43 <ddarius> Currying is what curry does, partial application is what application does.
13:04:50 <osfameron> they seem like a great idea at the time, but combinators are saner
13:04:53 <Philippa> madhadron: that means "not isomorphic" :-) I pretty much ranted about that kind of use during the open session at AH, actually
13:05:03 <Philonous> I didn't mean to be a smart-ass, sorry ;)
13:05:13 <Philippa> Philonous: sensible question
13:05:34 <lispy> request for hackers (RFH) http://code.haskell.org/maybench/darcs-benchmark/README
13:05:36 <ddarius> Optional and keyword parameters tend to be replaced by collections of functions that handle the different aspects.
13:05:38 * madhadron grins and scribbles pseudo-isomorphisms in crayon.
13:06:16 <dsrogers> madhadron: it's a compliant from the dynamic linker.  This means that all the undefined symbols are expected to be able to be resolved dynamic and failing.  So the failure is coming from dyld.
13:06:22 <Philippa> madhadron: I'm pretty sure there's a bunch of related morphisms one of which does apply :-) Partial application is encodable in terms of currying, I don't think the reverse holds?
13:06:31 <madhadron> dsrogers, I remember reading in the dynamic architecture paper that anything you want to be both in dynamic code and static has to have two copies in memory.
13:07:04 <ddarius> 2D geometry gives a good example.  Instead of circle(radius = 5, center = (1,2), color = red) you tend to have: translate (1,2) $ scale 5 $ setColor red unitCircle
13:07:08 <jn> is there a language that allows "type discrete" functions?
13:07:09 <madhadron> Philippa, It is encodaable in currying + Forth
13:07:16 <TomMD> ddarius: usaf?  Where at?
13:07:34 <dsrogers> madhadron: ah.  That is equivilent to what I've found.
13:07:57 <ddarius> TomMD: Goodfellow AFB in Texas.
13:08:07 <Philippa> madhadron: you can build the argument-rearranging functions however you like
13:08:39 <Philippa> note that "in terms of" doesn't mean "using nothing else"
13:09:19 <madhadron> Philippa, Ah, so in a pseudo-closed calculus (:
13:09:21 <dsrogers> madhadron: no, wait.  It's worse than that.  You'll need a copy in memory of every static dependency of every dynamic object.
13:09:56 <madhadron> dsrogers, Here I've been thinking about trying to build a proper Smalltalk like Haskell environment and this is awaiting me.  Joy.
13:10:12 <Philippa> madhadron: in some host language supporting currying - any "conventional" lambda calculus will do nicely - plus some means of specifying the appropriate rewrite
13:10:32 <dsrogers> madhadron: well the correct solution is to make dynamic libraries work and built on your platform.
13:10:36 <Philippa> I don't think you can do the reverse without adding features that make the partial application needless
13:10:55 <madhadron> Philippa, <nods>  But in Haskell, there's a nice little chunk of Forth floating around the type system.
13:11:05 <dsrogers> dsrogers: if all your dependencies are dynamic, you're all set!
13:11:35 <madhadron> dsrogers, And this is going to be painful on MacOS?
13:11:41 <Philippa> madhadron: er, no. You don't need to mess around with anything type-level. Yes, you can build some of the typical Forth operators on function application, you can also just build the end result in a pointed manner
13:12:13 <Philippa> as in, a string of lambdas for the parms you haven't applied yet and then an appropriate string of applications
13:12:14 <madhadron> Philippa, Excuse me, not in the type system, just floating around treating type slots as stack elements.
13:12:17 <dsrogers> madhadron: apparently building dynamic objects are supported on mac os x.  I don't see where the magic is to make the core ghc and cabal libraries build dynamically though
13:12:39 <dsrogers> madhadron: presumably there is a configure flag or something
13:13:01 <madhadron> Philippa, I'm just being a little goofy.  Bits of Forth in one of the most mathematical languages around today amuses me.
13:13:06 <Philippa> madhadron: trust me, you're digging yourself into a pit trying to make that statement cleanly :-)
13:13:18 <Philippa> it shouldn't: ever met Joy?
13:13:26 <Philippa> well, it shouldn't /surprise/ you
13:13:32 <madhadron> Philippa, Yup.  Nice language.
13:13:39 <Philippa> yeah. There's your missing link
13:13:42 <madhadron> But on the other hand you have ColorForth
13:13:52 <Philippa> *nod*
13:14:27 <Philippa> still. The forth ops also have equivalents in lisp (operating on lists) don't they? Or if they're not in the standard libs they're sure easy to define
13:14:56 <Philippa> besides. Forth : Hardware :: Haskell : Maths
13:15:00 <madhadron> Philippa, Not really in the core language, but they're very easy to define, sure.
13:15:09 <Philippa> (which is to say, both build from a low level on their base...)
13:15:18 <Philippa> they're not in Haskell's core language either
13:15:29 <madhadron> Oh, they're a GHC extension?
13:15:40 <madhadron> There's one problem with that analogy...
13:15:42 <Philippa> they're all just library functions
13:15:48 <madhadron> Haskell hasn't mutated Maths to match its view of reality.
13:15:52 <jn> by "type discrete" i mean is a function which return type depends on the argument type, for example a function that returns an Int when given a Float argument and returns a Float when given an Int argument
13:16:10 <Philippa> madhadron: ...I wouldn't be too sure about that
13:16:11 <ddarius> madhadron: Neither has Forth.
13:16:26 <ddarius> (for hardware that is)
13:16:32 <madhadron> ddarius, Have you seen the specs on the SeaForth chip?
13:16:41 <Philippa> madhadron: Reduceron
13:17:13 <ddarius> madhadron: There are some stack processors, but they aren't the majority even in the embedded world I'm pretty certain.
13:17:30 <Philippa> mmm. "Someone built stuff specialised for us" isn't a big deal
13:17:44 <madhadron> ddarius, That's true, and mostly have nothing to do with Forth.
13:17:58 <madhadron> Philippa, Ooo...I hadn't seen that yet (somehow).
13:18:29 <Philippa> madhadron: mathematical work on the semantics of GADTs came after Haskell first had them too, IIRC
13:18:43 <vixey> after ? :S
13:18:47 <madhadron> ddarius, If you trace Charles Moore's designs, opcodes and registers have come and gone based on his programming style in a given decade.
13:18:49 <vixey> that's odd
13:19:14 <madhadron> Philippa, Fair 'nuff.  But the monads were there, waiting.
13:19:21 <Philippa> so was the stack
13:19:33 <hackage> Uploaded to hackage: foo 1.0
13:19:37 <Philippa> so was RPN, too
13:19:45 * madhadron yields.
13:20:43 <TomMD> @package foo
13:20:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/foo
13:21:25 <TomMD> Thats a really unfortunate choice for a name.
13:22:07 <madhadron> Anyone else ever noticeed the parallel between foo and bar to FUBAR and bra and ket in Dirac notation?
13:22:36 <TomMD> ?bot
13:22:37 <lambdabot> :)
13:22:54 <TomMD> hummm.  'hackage' is a liar.
13:22:56 <dons> "Foo (abbreviation from football) is a playing machine of Paper Soccer"
13:23:11 <dons> playing machines rock
13:23:24 <madhadron> playing machine?
13:23:26 <TomMD> ok, ok, I'll give it an honest try.
13:23:39 <dons> machines that play, madhadron
13:23:53 <TomMD> "cabal install foo" there is a line I never thought I'd type
13:24:04 <madhadron> ...thanks, dons.
13:25:01 <madhadron> Anyway, bedtime here in Switzerland.
13:25:27 <jn> is there a channel for general programming language discussion?
13:25:58 <vixey> jn: I don't think so
13:26:02 <vixey> jn: why?
13:26:26 <TomMD> well, people inhabit ##programming.  Not sure what the discussion is there
13:26:38 <sonnyjim> Hi
13:26:47 <ddarius> For programming language theory there is #ltu somewhere (probably here)
13:26:49 <vixey> it's not about programming languages
13:26:55 <TomMD> hello sonnyjim.  Before you ask, yes you can ask a question ;-)
13:27:09 <jn> vixey: im interested in a specific concept, dont know if it exists in any programming language
13:27:16 <vixey> jn: What is it?
13:27:52 <jn> vixey: functions which return type depends on the argument type
13:28:09 <dons> ok
13:28:18 <vixey> jn: It's called dependent types
13:29:04 <jn> vixey: ok, basically it would allow you to encode an object (in OO) as a function
13:29:11 <dons> well, not quite, right? the return type depends on the argument *value*
13:29:16 <dons> like printf.
13:29:17 <vixey> jn, would it ?
13:29:29 <dons> but just having  the  return type be determined by the argument type, well, that's not too hard.
13:29:32 <TomMD> jn: You can do what your probably looking for using SPJ's recent work on type families.
13:29:44 <osfameron> jn: Damian Conway showed how the Perl equivalent (Contextual::Return) can be used to fake an OO framework :-)
13:29:46 <dons> class Return a b | a -> b  where f :: a -> b
13:30:56 <jn> vixey: an object is an entity that can recieve messages, now if each message is encoded as a type you can easily see that an object is a function which return type depends on the argument type
13:31:47 <vixey> jn, yeah that makes sense
13:32:07 <erikc> jn: only if you abandon the concept of 'identity' for objects
13:32:13 <rwbarton> jn: You could also use a tuple of functions, one for each kind of message, and indeed that's basically how C++ works
13:32:15 <jn> i was just wondering if there is a language where this type of function composition is allowed
13:32:35 <erikc> since objects have state and functions dont
13:32:39 <vixey> ?go hotter than haskell
13:32:40 <rwbarton> jn: well, obviously Scheme or any other language without static typing :)
13:32:50 <lambdabot> http://www.cs.chalmers.se/~augustss/cayenne/
13:32:50 <lambdabot> Title: Cayenne
13:32:54 <mattam> each message as a different type and not a type of all messages ?
13:32:56 <jn> erikc: identity is not essential
13:32:59 <erikc> ok
13:33:23 <jn> rwbarton: i still want static typing :)
13:33:39 <vixey> jn, check out cayenne, maybe you can try out what you suggested
13:33:48 <ddarius> jn: What about subtyping, inheritance, encapsulation, method override, etc.?
13:34:25 <jn> ddarius: inheritance => delegation, encapsulation => closure etc
13:34:57 <ddarius> No subtyping then?
13:35:13 <jn> you can have subtyping
13:35:22 <TomMD> ddarius: Hope you don't mind me asking, but do you use Haskell in a professional setting?  Or is it more of a large hobby / side effort?
13:35:42 <ddarius> TomMD: I don't use Haskell professionally.
13:35:44 <erikc> jn: some of what you describe also falls under the substructural typing heading
13:36:05 <TomMD> ddarius: But like everyone else here, you would like to? ;-)
13:36:22 <jn> ddarius: for example, lets say the you have a function "int -> int" and one "float -> float", now combine them to one function: "int -> int | float -> float"
13:36:51 <vixey> jn, messageType Foo = int -> int
13:36:53 <dons> ddarius: are you just unable to use it, due to circumstance?
13:36:58 <vixey> jn, messageType Bar = float -> float
13:37:13 <vixey> jn, object :: forall message, messageType message
13:37:55 <jn> vixey: hmm, i dont follow
13:37:57 <rwbarton> jn: sounds like intersection types
13:37:57 <mattam> jn: In functionnal languages, we usually dispatch on values and not types.. You would need a datatype of messages like the Foo | Bar of vixey
13:38:15 <vixey> jn, you have computation at type level
13:38:24 <vixey> isn't that what you were just asking about?
13:38:32 <jn> mattam: OO dispatch is runtime type dispatch
13:38:34 <vixey> you probably can look at cayenne to try this out
13:38:54 <ddarius> TomMD: I don't actually think using Haskell would make doing what I do currently easier.
13:39:02 <mattam> jn: precisely, that's not what you would get here.
13:39:24 <jn> mattam: yes it is, if you pass functions instead of objects
13:39:36 <ddarius> dons: There is no way I could use Haskell for anything other than maybe support for another project.
13:39:40 <mattam> With typeclasses you get compile-time type dispatch.
13:40:02 <jn> mattam: im not talking about type classes :)
13:40:07 <stepcut> ugh, someone needs to fix haskell-mode so that it recognizes, ^>$ as being a valid prompt
13:40:17 <mattam> jn: Now I don't follow. Passing functions where?
13:40:22 * stepcut may just be that someone
13:40:25 <dons> ddarius: what kinds of things do you work on?
13:40:33 <rwbarton> vixey: in "object :: forall message, messageType message", is message ranging over a set of types or a set of values?  (i.e. what are Foo and Bar?)
13:40:36 <jn> mattam: to another function, HOF
13:40:38 <dons> yes, support tools, testing, scripts. that's always a nice road in.
13:41:48 <jn> mattam: its a way of unifying functions and objects through more advanced functions types really
13:41:59 <twanvl> You can simulate most parts of OO in Haskell:  data Base = Derived { doStuff :: Int -> Int } | Derived2 { doStuff :: Int -> Int }
13:42:25 <erikc> twanvl: as long as your inheritance tree is closed
13:42:26 <ddarius> dons: The main issue is the environment that I work in is heavily Microsoft.
13:42:30 <newsham> any lambdabot or lambdac operators awake?  please ?part #haskell-blah
13:42:38 <mattam> jn: You're not saying that you can do runtime type dispatch in Haskell, right? You just suggest adding this or finding another language doing it?
13:43:27 <newsham> (cleanup on aisle six)
13:43:47 <TomMD> ddarius: But if it were your choice, a professional Haskell project would be of interest to you I take it.  Curiously,  you say 'heavily Microsoft' as though that precludes Haskell - are things still that bad?
13:43:48 <dons> ddarius: ok. so the problem is bindings to windows libraries?
13:44:11 <dons> yeah, credit suisse survives somehow, so i wonder what the barrier is.
13:44:12 * twifkak learns the hard way that main need not be IO ()
13:44:13 <jn> mattam: Haskell is too limited (i think) to encode these types, i looking for a language where its possible to encode a function type "a -> b, where b = int if a = float, b = float if a = int"
13:44:24 <dons> jn that's almost trivial
13:44:45 <dons> type classes plus associated types, or functional dependencies
13:44:47 <TomMD> dons: FWIW, last time I tried to combine windows + Haskell it failed because of poor SQL bindings (windows only bug).
13:44:50 <dons> do you want some code to implement it?
13:44:51 <ddarius> dons: Integration with the whole Microsoft platform.  IIS, Sql Server, .NET etc.  But that's just me.  Another issue would be training.
13:45:02 <dons> yep. fair enough.
13:45:12 <dons> so that's what the F# guys hope to be their niche.
13:45:23 <dons> FP for those with windows lock in.
13:45:41 <dons> sigh. more lock in.
13:45:49 <jn> dons: thing is, type classes arent needed
13:45:50 <dons> jn , do you know how to proceed on this?
13:46:01 <Philippa> yeah. Worst bit is, I might use F# for XNA development at some point
13:46:20 <erikc> XNA is like DNA, but cooler
13:46:28 <dsrogers> question: does ghc -fPIC actually work on any platforms right now?
13:46:39 <ddarius> TomMD: I certainly wouldn't mind doing a professional Haskell project, but for what I am doing currently, C# is not bad.
13:46:57 <ddarius> erikc: eXtreme Nucleic Acid
13:47:02 <erikc> haha
13:47:07 <newsham> professional haskell project?  sign me up for that.
13:47:35 <jn> dons: lets take an example, how would you write a function that combined to other functions into one function in Haskell?
13:47:42 <jn> two other
13:47:47 <dons> with (.)
13:47:51 <newsham> ?src (.)
13:47:52 <lambdabot> (f . g) x = f (g x)
13:47:52 <lambdabot> -- In lambdabot, it's been generalised to:
13:47:52 <lambdabot> (.) = fmap
13:47:56 <Twey> jn: compose = .
13:47:58 <Twey> Er
13:47:59 <Twey> (.)
13:48:14 <ddarius> If C# had more type inference and TCO, I'd be pretty happy with it.
13:48:17 <dons> it's a functional language, right?
13:48:20 <jn> dons: the result should be a function that calls either function depending on argument type
13:48:23 <dons> so function composition is super cheap.
13:48:30 <mattam> dons: I think jn asks for a language where you can express overloading in the types directly.
13:48:46 <dons> so isn't that what type classes are for?
13:49:03 <dons> or you want implicit type classes for some strange composition case?
13:49:05 <vixey> jn: Not sure if you missed it twice or not, but I mentioned to check out cayenne
13:49:11 <Philippa> ddarius: point, I'll have to remember there's no TCO 'til there is :-(
13:49:20 <jn> vixey: thanks for the pointer, ill check it out
13:49:37 <newsham> jn: so like   either (Left x) f g = f x; either (Right x) f g = g x   ?
13:49:45 <ddarius> Philippa: From what I hear, the 64-bit versions do have TCO as a matter of course.
13:50:02 <erikc> whats TCO?
13:50:02 <mattam> Something like intersection types where you can specify (int -> int & bool -> string).
13:50:19 <trofi> @jargon TCO
13:50:24 <ddarius> erikc: Tail Call Optimization
13:50:36 <lambdabot> Error: thread killed
13:50:37 <erikc> ah, right
13:50:44 <erikc> mattam: isnt that c++ function overloading?
13:51:25 <mattam> erikc: Indeed, I think that's what jn is asking for.
13:51:38 <jn> mattam, newsham: the type of the function should be: (a1 -> b1) -> (a2 -> b2) -> (a1 -> b1 | a2 -> b2)
13:52:07 <erikc> it has sorta bugged me that i cant do things in haskell like (-) :: Point -> Point -> Vector, for linear algebra (at least, i need a different operator, or a qualified (-))
13:52:07 <rwbarton> jn: What should happen if a1 == a2?
13:52:08 <newsham> ?djinn (a1 -> b1) -> (a2 -> b2) -> Either (a1 -> b1) (a2 -> b2)
13:52:08 <lambdabot> Plugin `djinn' failed with: Prelude.tail: empty list
13:52:26 <jn> rwbarton: compile time error
13:52:39 <mattam> jn: and the composed function can be applied to objects of type a1 or a2.
13:52:51 <ddarius> erikc: Clearly we need to pull (-) into an AdditiveTorsor superclass of Num.
13:52:53 <jn> mattam: yep, its an "object" in OO terms
13:52:58 <rwbarton> jn: So I can only apply this function when a1 and a2 are known not to unify
13:53:10 <haskellian> I thought Data.binary was strict, is it lazy?
13:53:34 <jn> rwbarton: yes, same rules as if you where to define an interface in Java for example
13:53:38 <erikc> ddarius: are you being facetious? :)
13:53:40 <dons> haskellian: it is lazy.
13:53:46 <vixey> I tried to make a better number setup in haskell
13:53:54 <ddarius> erikc: ... I'm not sure ...
13:54:06 <vixey> i.e. use a lattice of types ordered by inclusion and have implicit promotion by typeclass dispatch
13:54:21 <vixey> I ended up having to use undeciable instances :/
13:54:37 <vixey> (the flag, not the class setup)
13:55:16 <newsham> jn:   pick f g = Left f     fits your type above
13:55:25 <newsham> though i dont think thats what you meant
13:55:34 <newsham> are you asking how to do polymorphism?
13:56:05 <newsham> like:   foo :: Float -> Int   and  foo :: Double -> Int ?
13:56:29 <mmorrow> jn: something like this?  http://hpaste.org/9692
13:56:38 <jn> newsham: yes, its object polymoprhism, you can send mutiple types of messages to an object
13:57:14 <mattam> jn: I think your "|" operator is known as type intersection in the literature. Have a look at CDuce: www.cduce.org, a functional language with such type operator.
13:57:15 <newsham> you could define a type that includes all message types
13:57:20 <erikc> cause in c++ i have separate types for Vector, NDVector (non-degenerate) and NVector (normalized), and the normalize operation only exists for NDVector, and (-) for Point yields a Vector, so you need to explicit cast + handle error to normalize the different between points
13:57:27 <newsham> data Msg = DoThis | DoThat Int | GoToSleep Float
13:57:33 <erikc> which i guess is a sort of poor man's dependent types
13:57:42 <newsham> then foo :: Msg -> Result
13:58:00 <newsham> foo DoThis = ...;  foo (DoThat n) = ...
13:58:18 <vixey> data Msg result where DoThis :: Msg Int ; DoThat :: Int -> Float ...
13:58:24 <vixey> foo :: Msg result -> result
13:59:14 <jn> vixey, newsham: its not very flexible, you want to add new message types in other modules for example
13:59:41 <jn> subtyping
13:59:49 <erikc> i think what you are after is too dynamic for static typing
13:59:53 <vixey> jn: take a look at java
14:00:05 <vixey> typed OO can be done
14:00:14 <newsham> data ExtMsg = NormMsg Msg | MoreMsg | TypesHere
14:00:29 <rwbarton> what's the LANGUAGE that lets me use forall and higher-order types?
14:00:39 <vixey> RankNTypes is one
14:01:03 <rwbarton> thanks vixey
14:01:20 <jn> erikc: no, clearly it can be statically type checked (many OO languages are)
14:01:38 <jn> im merely trying to unify objects and functions
14:01:43 <vixey> jn: they do dynamic checks too
14:01:47 <newsham> jn: whats an object?
14:01:50 <vixey> jn: Do you know scheme ?
14:02:08 <jn> vixey: a little, i know Java and Scala mostly
14:02:16 <newsham> jn: type classes might be more o f what you're after?
14:02:24 <newsham> you can define a type class, which s sort of like a java interface
14:02:26 <ddarius> jn: Have you looked at the sigma calculus and encodings of it into typed lambda calculi?
14:02:43 <newsham> and then you can define instances of those (like objects that derive an interface in java)
14:02:46 <jn> newsham: an object is a function with the type: Msg1 -> ReturnType1 | Msg2 -> ReturnType2 | ...
14:03:02 <rwbarton> jn: one can force Haskell type classes to do something like what you want, see http://hpaste.org/9692#a1
14:03:16 <ddarius> jn: You probably also want to look at the & calculus.
14:03:40 <sjanssen> perhaps an object is an HList of functions?
14:04:01 <newsham> jn: where's the object state?
14:04:25 <newsham> do you mean:    obj -> Msg1 -> Ret1 ?
14:04:27 <jn> newsham: the object state is encapsulated in closures of lambda functions
14:04:37 <newsham> jn: so the state is immutable?
14:05:00 <jn> newsham: not necessarily, you can have IORefs etc
14:05:01 <vixey> you can't do that in haskell
14:05:08 <newsham> so all the return types are IO ?
14:05:16 <jn> newsham: depends
14:05:23 <vixey> they should be in OO
14:05:25 <newsham> it sounds like you're trying really hard to map java onto haskell
14:05:25 <vixey> :)
14:05:30 <newsham> which you can do.. but it might not be the best approach
14:05:44 <monochrom> "Think Different" :)
14:06:10 <newsham> class MyInterface where { call1 :: Obj -> Msg1 -> IO Result1;  call2 :: Obj -> Msg2 -> IO Result2; }
14:06:39 <newsham> err..  shoulda been   MyInterface obj,  and lowercase Obj
14:06:40 <jn> newsham: im not trying to do anything in Haskell :) im merely seeing the value of dynamic dispatch and trying to define a minimal language which supports this
14:07:12 <monochrom> typeclass is dynamic dispatch when unoptimized
14:07:47 <jn> monochrom: yes, but type class dispatch can be resolved at compile time -> not the same as dynamic dispatch
14:07:54 <ddarius> jn: Have you looked at the languages I mentioned above?
14:08:19 <Heffalump> jn: not in the case of polymorphic recursion
14:08:25 <newsham> you might also want to look at java.  it seems ot do what you want ;-)
14:08:42 <jn> newsham: Java is not beautiful :)
14:08:49 <monochrom> Add existential type to prevent compile-time specialization.
14:08:51 <tusho> i'd be curious to know how haskellites would refactor this
14:08:53 <tusho> handle (Message _ "PRIVMSG" [chan, msg]) | chan `elem` channels config = ...
14:09:00 <tusho> it's really quite ugly and goes over 80 lines
14:09:07 <tusho> err
14:09:08 <tusho> 80 chars
14:09:13 <newsham> also when you do:    blah :: MyInterface a => a -> IO b
14:09:17 <newsham> that wont be statically dispatched
14:09:37 <ddarius> tusho: Just put a newline before the |
14:09:52 <monochrom> http://www.haskell.org/haskellwiki/Existential_type has classical examples.
14:09:52 <tusho> ddarius: yeah. the structure just kind of irks me, though
14:09:54 <lambdabot> Title: Existential type - HaskellWiki
14:10:51 <jn> ddarius: no, thanks for the pointers
14:10:59 <monochrom> Haskell has all the OO except syntactic support for inheritance, i.e., you have to write lots of forwarder boilerplates yourself.
14:11:22 <monochrom> (I probably don't mean Haskell 98.)
14:13:41 <ddarius> monochrom: Haskell completely lacks subtyping.
14:14:09 <monochrom> Don't subtype. Use subtypeclass.
14:15:03 <ddarius> And when I have a list of existential boxes of Numable things and I want to pass that to something that takes a list of Showable things?
14:15:39 <ddarius> If you are willing the explicitly insert coercions, you can achieve a pretty featureful OO language albeit an ugly one.
14:16:03 <tusho> elliottt: network.irc is broken
14:16:05 <tusho> it's parsing everything as Nothing
14:16:17 <jn> monochrom: basically functions and closures is enough for a OO language, as long as you can unify functions
14:16:21 <stepcut> tusho: I do it like this, but it's still too ugly, http://src.seereason.com/happs-bot/
14:16:22 <lambdabot> Title: Index of /happs-bot
14:17:12 <gwern> there's something distinctly odd about writing an irc bot in a web framework, if I guess happs-bot's purpose aright...
14:17:26 <stepcut> :)
14:17:39 <jn> monochrom: well, you need to be able to define new types as well
14:17:41 <stepcut> easy way to get a bot with multimaster replication
14:18:00 <stepcut> gwern: anyway, I don't use the module that is web specific
14:18:13 <monochrom> IIRC "class Show n => Num n" is an axiom.
14:18:32 <gwern> stepcut: I suppose so. I just don't understand happs, i guess
14:18:44 <gwern> stepcut: is this happs-bot implmenting dons wishlist?
14:18:49 <erikc> jn: so you want to be able to expand the messages an object accepts at runtime?
14:19:13 <ddarius> monochrom: Indeed. But there is no automatic conversion from data Numable = forall a.Num a => Numable a to data Showable = forall a. Show a => Showable a
14:19:17 <stepcut> gwern: i didn't know he had a wishlist, is it published ?
14:19:29 <gwern> stepcut: he's gone over it a few times in #haskell
14:19:43 <gwern> I don't think he's mentioned it anywhere more durable
14:19:46 <gwern> ask him?
14:19:50 <gwern> @seen dons
14:19:50 <monochrom> Add boilerplate code to declare "instance Show Numable" and "instance Num Numable".
14:19:50 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 6m 27s ago.
14:20:16 <gwern> well, there you go stepcut
14:20:25 <ddarius> monochrom: That doesn't help if I have a function: f :: [Showable] -> String
14:20:35 <monochrom> Your "function that takes Showable" should never have been written. You're supposed to write "function that takes Show".
14:20:41 <mmorrow> jn: it's not the case that there doen't exist a type which will encompass all possible new message types.
14:21:08 <mmorrow> so you can have something like data BaseMsg a = A (a -> [a] -> ...) | B (BaseMsg (BaseMsg [a]) -> a) | ..
14:21:25 <mmorrow> and then
14:21:30 <mmorrow> newtype Msg b = Msg (forall a. (a, a -> BaseMsg b))
14:21:36 <stepcut> gwern: this bot has two primary advantages over lambdabot: it supports multimaster replication across servers -- so that bots can be run on different machines on  different networks, but keep their databases in-sync. it also supports more pervasive multithreading, so that multiple commands can be processed in parallel instead of having @eval block things up
14:21:38 <ddarius> monochrom: Using map show wouldn't help too much because then I couldn't have a list of arbitrary showable things.
14:21:43 <mmorrow> now you for any new message type NewMsg, you just implement NewMsg -> BaseMsg b,you can wrap that in a Msg b
14:22:08 <mmorrow> so Msg b is injective
14:22:33 <stepcut> gwern: but, currently the only command it supports is get-shapr (unfortunately, it has yet to actually get shapr)
14:22:40 <gwern> stepcut: those are nice features
14:22:43 <gwern> get-shapr?
14:22:46 <Heffalump> stepcut: can you have two copies of the bot on one channel and have them coordinate which one will actually respond?
14:22:57 <Heffalump> (with appropriate handling for when one has fallen over)
14:23:09 * gwern goes for dinner
14:23:19 <stepcut> Heffalump: not yet, but that is the plan. Currently they only respond to requests directed to them by name
14:23:20 <mmorrow> haha, the bots'll be whispering all menacingly over in the corner ...
14:24:50 <stepcut> mmorrow: indeed. electing a leader amongst themselves.
14:24:59 <mmorrow> jn: err, maybe that should be   Msg b = forall a. Msg (a, a ->  b) ...
14:25:08 <monochrom> ddarius: Sorry I don't understand the question.
14:25:08 <mmorrow> jn: depends what you want
14:25:20 <mmorrow> stepcut: haha, botwars!!
14:25:38 <ddarius> monochrom: I didn't ask a question.  The issue is in OO language upcasting is implicit and in Haskell it would need to be explicit.
14:25:38 <stepcut> Heffalump: i also plan to support have multiple bots on completely different servers (for example, one on irc, and another one on jabber), but allow for shared state
14:26:01 <monochrom> Yes. I contend that you seldom upcast.
14:26:55 <ddarius> I contend that any time you are actually using OO you are upcasting.
14:26:59 <Heffalump> right, that was the way I read what you said above about "different networks"
14:27:25 <Heffalump> well, I read it as "different IRC networks" but other protocols are an obvious extension once you have the basic principle working
14:28:09 <tusho> where are the Control.Alternative docs?
14:28:09 <stepcut> Heffalump: ah, I meant different ISPs when I said that, but I do plan for different (irc) networks as well.
14:28:11 <tusho> hard to google
14:28:36 <stepcut> Heffalump: or even a separate bot process per channel, but with shared state so that @seen works across multiple channels.
14:28:40 <haskellian> how do I pattern match a list with one element?
14:28:49 <monochrom> OK, I mean this. You seldom upcast types. You always upcast interfaces.  In Haskell the later needs no extra coding.
14:28:51 <|Steve|> foo [x] = x
14:28:59 <monochrom> Or rather I mean needs no coercion.
14:29:11 <vixey> foo ?
14:29:12 <|Steve|> > let foo [x] = x in foo [42]
14:29:14 <lambdabot>  42
14:30:02 <|Steve|> > case [42] of [x] -> x; _ -> 0
14:30:04 <lambdabot>  42
14:30:52 <vixey> > case [foo] of [
14:30:53 <lambdabot>  Parse error at end of input
14:32:34 <monochrom> Suppose you write in Eclipse and you have type Editor and corresponding interface IEditor to go with it. I repeat corresponding, to go with it. Then you usually write operations for IEditor, you seldom specification take Editor. Henceforth you don't limit this operation to subtypes of Editor; you only limit it to subinterfaces of IEditor.
14:32:52 <monochrom> s/specification/specifically/
14:33:09 <haskellian> but they overlap, i want to mathc against one listelem
14:33:17 <tusho> http://hpaste.org/9693 how I'd like to be able to write this IRC handler
14:33:34 <tusho> gah, doesn't parse
14:33:48 <tusho> ah
14:33:49 <tusho> an extra $
14:34:02 <trofi> > let [1,2,3
14:34:03 <lambdabot>  Parse error at end of input
14:34:40 <trofi> > let x = [1,2,3] in case x of (y:[]) -> "One"; (y:ys) -> "More"
14:34:42 <lambdabot>  "More"
14:34:45 <trofi> > let x = [1] in case x of (y:[]) -> "One"; (y:ys) -> "More"
14:34:47 <lambdabot>  "One"
14:36:22 <yitz> let howMany [] = "None; howMany [_] = "One"; howMany _ = "More" in howMany [1,2,3]
14:36:33 <yitz> let howMany [] = "None; howMany [_] = "One"; howMany _ = "More" in howMany [1]
14:36:44 <yitz> > let howMany [] = "None; howMany [_] = "One"; howMany _ = "More" in howMany [1,2,3]
14:36:44 <lambdabot>  Improperly terminated string at """ (column 63)
14:37:02 <yitz> > let howMany [] = "None"; howMany [_] = "One"; howMany _ = "More" in howMany [1,2,3]
14:37:04 <lambdabot>  "More"
14:37:07 <yitz> > let howMany [] = "None"; howMany [_] = "One"; howMany _ = "More" in howMany [1]
14:37:09 <lambdabot>  "One"
14:37:11 <yitz> > let howMany [] = "None"; howMany [_] = "One"; howMany _ = "More" in howMany []
14:37:12 <lambdabot>  "None"
14:37:54 <vixey> woah
14:38:39 <yitz> haskellian: I'm not sure what you want, but is anything that we've shown you so far helpful?
14:40:11 <byorgey> vixey: ?
14:40:59 <trofi> > let x = [] in case x of (y:[]) -> "One"; (y:ys) -> "More"
14:41:01 <lambdabot>   Non-exhaustive patterns in case
14:44:16 <blarz> hi
14:48:41 <carllerche> join erlang
14:48:58 <mmorrow> rwbarton: cool, just saw your paste. that reminds me of a section of this paper (section 4.2)  http://research.microsoft.com/~simonpj/papers/assoc-types/ifl2007.pdf
14:49:12 <mmorrow>     In general, we can replace an n-ary type function with an (n + 1)-ary type
14:49:12 <mmorrow> class, with a functional dependency from the n first arguments to the last one
14:49:12 <mmorrow> ...
14:50:41 <mmorrow> not sure about the converse
14:50:45 <yitz> hi blarz
14:50:58 <tusho> @seen elliottt
14:50:58 <lambdabot> elliottt is in #xmonad and #haskell. I don't know when elliottt last spoke.
14:51:01 <tusho> beh
14:51:27 <stepcut> > (\x -> x >>= id) ["erlang"]
14:51:29 <lambdabot>  "erlang"
14:51:33 <stepcut> done.
14:51:44 <trofi> @type join
14:51:44 <blarz> what's the deal with erlang?
14:51:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:52:06 <trofi> @let erlang = []
14:52:07 <lambdabot> Defined.
14:52:13 <mmorrow> > (id=<<) (*) 8
14:52:15 <lambdabot>  64
14:52:42 <mmorrow> > (id=<<) (Just Nothing)
14:52:44 <lambdabot>  Nothing
14:52:54 <twanvl> ?src join
14:52:54 <lambdabot> join x =  x >>= id
14:52:58 <yitz> > join (*) 8
14:53:00 <lambdabot>  64
14:54:30 <blarz> did the channel got flooded, I just read about IRC/management on the wiki
14:54:44 <shapr> flooded?
14:55:48 <blarz> seems like it didn't ;) just wanted to know what's the matter with this article
14:57:10 <stepcut>  #haskell-blah had a bot-loop an hour or so ago... is that what you mean ?
14:57:32 <blarz> http://haskell.org/haskellwiki/IRC_channel/Management
14:57:33 <lambdabot> Title: IRC channel/Management - HaskellWiki
14:57:36 <blarz> that's what I mean :)
15:00:24 <stepcut> ah
15:00:55 <blarz> perhaps I just got it all wrong
15:01:23 <stepcut> blarz: I suspect it is probably just referring to the types on things that happen when you have a channel with ~500 users
15:01:57 <stepcut> blarz: including people unknowingly causing trouble
15:01:59 <rwbarton> blarz: sometimes botnets do a mass join and spam the channel, or something
15:05:42 <trofi> @src ixmap
15:05:43 <lambdabot> Source not found. My mind is going. I can feel it.
15:06:09 <blarz> I see
15:14:35 <tusho> Can I add to the module search path with a {-# ... #-}?
15:15:44 <stepcut> tusho: I wish...
15:15:46 <twanvl> {-# OPTIONS_GHC -isomedir #-}
15:16:04 <stepcut> twanvl: that never seems to work for me
15:16:06 <lispy> do I have to recompile haddock for every version of ghc?
15:16:19 <stepcut> lispy: yes
15:16:19 <lispy> I'm getting a bad interface file in Prelude.hi
15:16:22 <twanvl> stepcut: you might be right, I have never tried it
15:16:45 <tusho> right, doesn't work
15:16:46 <stepcut> lispy: It makes upgrading GHC tricky because haddock breaks in the middle
15:16:53 <tusho> but I have Foo.hs
15:17:02 <tusho> and c-c l cds to ~/.cabal
15:17:03 <tusho> :(
15:17:16 <stepcut> tusho: yes, that is a new feature which annoys me greatly
15:17:30 <dcoutts_> tusho, stepcut: upgrade your haskell mode to a non-broken version
15:17:35 <stepcut> tusho: if it lookd at Hs-Source-Dirs in .cabal and adde those, it might be aok
15:17:40 <tusho> dcoutts_: that is work dude.
15:17:42 <tusho> :)
15:17:53 <stepcut> dcoutts_: where do we get the unbroken version? I want to add another fix as well ?
15:18:27 <dcoutts_> stepcut: I've no idea, I don't use emacs, but I've seen everyone tripping over this bug and people tell me there is a non-broken version, perhaps not released.
15:18:38 <dcoutts_> it's looking (in a broken way) for a .cabal file in the current dir, or in one of the parent dirs
15:18:57 <stepcut> dcoutts_: the problem I have is there are too many places to get it. tarballs, tla archives, cvs. Not sure what is the real version anymore :(
15:19:02 <dcoutts_> it gets up to your home dir and thinks the ~/.cabal/ dir is a foo.cabal file but with no name
15:19:11 <stepcut> dcoutts_: no, that is a different problem
15:19:19 <dcoutts_> stepcut: I've really no idea, I don't use it.
15:19:31 <dcoutts_> stepcut: oh, ok, my mistake
15:19:51 <stepcut> dcoutts_: the problem is, if you put your src in src/, it cds to the directory that the .cabal file is in, and now it can't find any source, because its all under src/
15:19:54 <dcoutts_> cd'ing to ~/.cabal seems to be the usual symptom of that bug
15:20:20 <stepcut> dcoutts_: right.
15:20:26 <dcoutts_> stepcut: right, that'd be ok if it looks at the src-dirs field
15:20:44 <stepcut> dcoutts_: yeah
15:20:55 <dcoutts_> and you find that it doesn't
15:21:00 * tusho just runs ghci seperately
15:21:11 <stepcut> dcoutts_: even if you do :cd src, it overrides it. so the only fix is to do :set -isrc
15:21:15 <dcoutts_> stepcut: what does it use to read the .cabal file? any idea who I should shout at? :-)
15:21:33 <dcoutts_> erm, I mean send advice to
15:21:48 <stepcut> dcoutts_: I don't think it reads the .cabal at all. It just adds, :cd `dirname fil.cabal`, before loading the file
15:22:04 <dcoutts_> doh!
15:22:12 <lumi> Do you ever feel like you could use a (sanely named) prog1 for monads?
15:22:32 <dcoutts_> stepcut: that is pretty broken. :-(
15:22:48 <stepcut> tusho: you can do, :set -isrc, by hand in ghci and then C-c C-l will work
15:23:04 <stepcut> dcoutts_: yes. It's sort of a good idea, but not done very well
15:23:32 <dcoutts_> stepcut: I thought there was this 'shim' thing that used the Cabal lib to do things properly?
15:23:37 <stepcut> dcoutts_: yi ought to be able to do a better job, since it can use libghc6-cabal to actually read the stuff ;)
15:23:51 <dcoutts_> right, using the Cabal lib is the obvious thing to do
15:23:55 <ddarius> lumi: (<*)
15:24:05 <stepcut> dcoutts_: dunno, I have not looked at the source.
15:25:46 <dmhouse> lumi: yeah, I've wanted that a few times. Something like returning :: Monad m => m a -> (a -> m b) -> m a
15:26:04 <dmhouse> I.e. returning fooAction $ \resultOfFoo -> do ...
15:26:59 <jberg> is there a haskell mode for looking up documentation on haskell functions?
15:27:25 <dmhouse> jberg: Emacs' haskell-mode has hoogle integraiton
15:27:43 <jberg> dmhouse: hm, do you know how?
15:27:59 <dmhouse> jberg: http://haskell.org/haskellwiki/Hoogle#Emacs_Integration
15:28:02 <rwbarton> dmhouse: Does that work for you?  It didn't for me
15:28:08 <lambdabot> Title: Hoogle - HaskellWiki
15:28:12 <jberg> thanks
15:28:39 <trofi> @instances Ix
15:28:40 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:29:01 <lumi> dmhouse: Yeah, and that's a good name for that :)
15:29:27 <dmhouse> rwbarton: does it not? What error does it give? I have to admit, I haven't tried it recently. It ought to work, though.
15:30:20 <rwbarton> dmhouse: I've modified mine, but as I recall I just got an empty result buffer
15:30:52 <dmhouse> rwbarton: and you obviously were good and sent your modifications as a diff to Stefan, right? ;)
15:31:37 <dmhouse> I also wrote a hoogle.el for before the integration existed, which works AFAIK. I've deprecated it now in favour of haskell-mode's integration, though. (It should still be on the wiki for reference.)
15:32:29 <dmhouse> rwbarton: hmm, no, definitely works for me. Type "foo = map", M-x haskell-mode RET, M-x haskell-hoogle RET, look at Firefox.
15:33:01 <rwbarton> dmhouse: Oh, I wanted the command-line hoogle, not in-browser (I can already do that by typing 'h map' into the address bar)
15:33:17 <dmhouse> There might be a config variable for that. /me looks
15:33:51 <dmhouse> Yes, looks like it will find a hoogle command if you have one installed locally.
15:33:57 <rwbarton> dmhouse: I just replaced the relevant code with (let ((manual-program haskell-hoogle-command)) (man query))   :)
15:34:48 <dmhouse> Lemme download Hoogle and see if it works.
15:34:57 <jberg> hm yeah, i wanted the documentation in an emacs buffer as well, not in firefox
15:35:01 <jberg> not a big deal though
15:35:05 <dmhouse> Woah, did I just set "lemme"? Sorry, I'm tired. Let me.
15:37:15 <lispy> I have ghc-paths, but haddock build, this is so weird
15:37:43 <lispy> er haddock won't build
15:39:43 <tusho> anyone have comments on http://hpaste.org/9694? I think it's nice and haskelly
15:39:54 <tusho> seems elegant to me and least
15:42:14 <rwbarton> tusho: cool, seems like there should be a monad there (like parsec)
15:42:27 <tusho> rwbarton: i don't really see why :)
15:42:30 <tusho> it's a simple model
15:42:43 <tusho> you get a command in, which you parse with some nested stuff and alternative
15:42:53 <tusho> then you are in IO (for IOy botty stuff) and return the stream of commands to which to reply with
15:43:04 <tusho> i can't really think what extra I'd put in a monad
15:43:43 <rwbarton> tusho: handle = (do { cmd "PRIVMSG" ; chan <- arg ; guard (chan `elem` channels config) ; msg <- arg ; return (return [C.privmsg chan msg]) }) <|> ...
15:44:09 <rwbarton> (maybe just one return)
15:44:45 <tusho> rwbarton: ah not sure about that
15:44:54 <tusho> I modeled this thing after hvac
15:44:56 <tusho> and I think it's nicely concise
15:44:58 <rwbarton> i.e. it seems like (probably after redefining cmd and arg) you should be able to write the above code
15:45:12 <tusho> hvac is effectively the same
15:45:28 <tibbe> anyone know how to convince the emacs haskell mode to only insert 2 spaces for indentation?
15:45:38 <stepcut> tusho: is the source available for what you've done ?
15:45:43 <Apocalisp> @let hamilton x = let every _ [] = []; every n x = head x : every n (drop n x); f (x, n, y, p) = (reverse x, if p then n else n + 1, tail . every n $ reverse x, not p); thrd (_, _, x, _) = x in join . map thrd $ takeWhile (not . null . thrd) $ (\x -> iterate f (x,2,x,True)) x
15:45:44 <lambdabot> <local>:9:0:     Warning: Pattern match(es) are overlapped              In th...
15:45:53 <tusho> stepcut: IRCHandler, yes, but I think it can be refactored
15:46:00 <tusho> i'll paste it as it is now
15:46:04 <stepcut> tusho: ok, I'll check back later
15:46:19 <tusho> http://hpaste.org/9695
15:46:20 <tusho> very trivial
15:46:26 <Apocalisp> > hamilton "123"
15:46:28 <lambdabot>  "12313"
15:46:33 <tusho> i think cmd can be rewritten using assuming
15:46:54 <Apocalisp> @check \l -> null $ let e (a1, b1) (a2, b2) = a1 == b2 && a2 == b1 || a1 == a1 && a2 == a1; (<**>) x y = x >>= \a -> map (\b -> (b,a)) y; dup x = filter (\(a,b) -> a /= b) $ nubBy e x in (\x -> deleteFirstsBy e (dup (x <**> x)) ((\y -> dup (zip y (tail y))) (hamilton x))) l
15:46:56 <lambdabot>  OK, passed 500 tests.
15:47:04 <tusho> stepcut: in case you didn't see i just pasted it
15:47:07 <stepcut> tusho: looks cool. I'll check back later. I need something similar for my bot as well, but it is not an area I feel the need to develop something new in ;)
15:47:13 <tusho> :)
15:47:17 <Apocalisp> yay! Hamilton path heuristic for teh win.
15:47:21 <stepcut> tusho: do you allow multiple matches ?
15:47:22 <vixey> Apocalisp, http://hpaste.org/9635
15:47:28 <tusho> stepcut: no, not right now
15:47:30 <tusho> I might add 'either'
15:47:32 <tusho> so you can do
15:47:38 <tusho> either (cmd "PRIVMSG") (cmd "FOOMSG") $ ...
15:47:46 <tusho> or ... something
15:48:17 <stepcut> tusho: I want to have multiple handlers for the same incoming message. For example, all incoming messages so go to the logger, even if someone else matched on the incoming message already
15:48:32 <tusho> stepcut: ah, right
15:48:45 <tusho> stepcut: you would put the logger at the top
15:48:49 <tusho> and instead of "ok"
15:48:51 <tusho> do "okAndContinue"
15:48:54 <tusho> (which is fairly trivial to write)
15:48:59 <tusho> (I ... think)
15:49:02 <Apocalisp> vixey: I don't totally understand that.
15:49:26 <Apocalisp> What are graph1, graph2, etc?
15:49:52 <stepcut> tusho: hrm. My current hypothesis is that it should always continue. But I have not looked closely at what you have done.
15:50:06 <tusho> stepcut: Actually, you're probably right.
15:50:11 <tusho> That would go against the spirit of Alternative, though.
15:50:23 <tusho> Which is "select one of these."
15:50:34 <tusho> Not too much of a problem.
15:50:39 <tusho> I can just write my own thingy
15:50:45 <tusho> <&> or something.
15:51:02 <tusho> @hoogle a -> [a] -> [[a]]
15:51:03 <lambdabot> A Hoogle error occurred.
15:51:06 <tusho> :|
15:51:12 <stepcut> tusho: for something like HTTP, you do want to select one, because it only makes sense to return one page per request. But for the bots, i think it makes since to allow multiple matches by default.
15:51:20 <tusho> stepcut: Yeah, agreed.
15:52:50 <tusho> @hoogle a -> [a] -> [[a]]
15:52:51 <lambdabot> A Hoogle error occurred.
15:53:34 <tusho> :\
15:53:37 <stepcut> tusho: the (horrid) example I posted in my bot also allows for nested matching. So you can stick all the handlers that match on, cmd "PRIVMSG", under one node of the tree and only have to match once on "PRIVMSG" then.
15:53:53 <tusho> stepcut: Yes, I'll probably roll my own with that.
15:53:57 <tusho> For now, though, I'm happy with this solution.
15:54:07 <lispy> ?vixen Why no hoogle love?
15:54:07 <lambdabot> i didn't think so
15:54:14 <tusho> (It's the first Haskell IRC code I've wrote that *feels* idiomatic)
15:54:14 <stepcut> tusho: ok, I'll check back in later and see if you have something I can use
15:54:17 <Apocalisp> vixey: I'm pretty happy with my optimization, but yours looks really nice and terse.
15:54:28 <tusho> stepcut: I hope so :)
15:59:21 <tusho> So what is the "split" function I'm thinking of?
15:59:24 <tusho> (a -> [a] -> [[a]])
15:59:32 <trofi> @src split
15:59:33 <lambdabot> Source not found. My brain just exploded
16:01:34 * lispy sometimes wishes type sigs had an equivalent to ($)
16:01:48 <EvilRanter> tusho, nonexistant
16:01:54 <tusho> EvilRanter: Bah.
16:02:30 <EvilRanter> lispy, "infixr 0 :$; type a :$ b = a b"
16:02:47 <tusho> EvilRanter: what should I use instead?
16:02:48 <lispy> EvilRanter: oh, does that work?
16:02:54 * lispy tries it
16:02:59 <yitz> tibbe: I just use two spaces manually once or twice. After that, haskell-mode seems to figure it out on its own.
16:03:19 <EvilRanter> tusho, define something - usually with span or break and explicit recursion - that has the exact semantics you want
16:03:28 <tusho> EvilRanter: Oh, wait, "lines".
16:03:29 <tusho> XD
16:03:32 <EvilRanter> ...
16:03:40 <tusho> Sorry.
16:03:42 <tusho> it's midnight.
16:03:43 <EvilRanter> heh
16:03:50 <EvilRanter> indeed it is :)
16:03:54 <tibbe> yitz: hmm, ok
16:04:27 <lispy> EvilRanter: doesn't work exactly
16:04:40 <EvilTerran> lispy, no?
16:04:40 <lispy> FlippedSeal (RL (PatchInfoAnd p)) a
16:04:56 <lispy> I changed to FlippedSeal :$ RL (PatchInfoAnd p)) a
16:05:09 <EvilTerran> ... that's different
16:05:11 <lispy> Oh hmm...
16:05:15 <lispy> wouldn't have worked here anyway I guess
16:05:16 <vixey> (FlippedSeal :$ RL (PatchInfoAnd p))) a
16:05:21 <EvilTerran> that's the brackets don't match
16:05:52 <lispy> alright, I'll keep it in mind, but maybe it's not so helpful for me
16:07:59 <Apocalisp> > describeSequence . take 20 $ map (\n -> fromIntegral .  length $ hamilton [1..n]) [0..]
16:08:02 <lambdabot>  Nothing
16:08:11 <Apocalisp> boo!
16:08:13 <EvilTerran> ... what?
16:08:36 <haskellian> if acc is big and lastTwo is small, then acc++lastTwo is faster than using : no?
16:08:42 <haskellian> right?
16:09:00 <haskellian> (I know normally : is faster than ++)
16:09:16 <Philonous> :t (:)
16:09:17 <lambdabot> forall a. a -> [a] -> [a]
16:09:22 <haskellian> and man, after using haskell for a while all other languages feel like a cripple to the mind
16:09:32 <Philonous> : doesnt work on lists but on elementslists
16:09:36 <dmhouse> ?src (++)
16:09:36 <haskellian> :t (:)
16:09:37 <lambdabot> []     ++ ys = ys
16:09:37 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:09:37 <lambdabot> -- OR
16:09:37 <lambdabot> xs ++ ys = foldr (:) ys xs
16:09:37 <lambdabot> -- In lambdabot, this is generalised to:
16:09:38 <lambdabot> (++) = mappend
16:09:40 <lambdabot> forall a. a -> [a] -> [a]
16:09:49 <Philonous> elements+lists
16:09:57 <dmhouse> haskellian: ++ uses : internally
16:10:04 <Philonous> So you cant concat lists with (:)
16:10:18 <Philonous> Except recursively of course
16:10:32 <Philonous> And I guess that's what ++ does anyway.
16:10:37 <vixey> the normal (++) does :)
16:10:39 <dzlk> I still enjoy scheme but after doing haskell for awhile any dynamically typed language just feels ... fragile.
16:10:43 <vixey> the fast (++) doesn't
16:10:45 <yitz> vixey: hehe
16:11:05 <yitz> ah, I thought you were referring to Caleskell.
16:11:10 <vixey> dzlk: Yeah, don't touch any of thos proof assistants
16:11:14 <lispy> dzlk: yeah, I feel that way too
16:11:18 <haskellian> concat = foldl (++) []
16:11:22 <vixey> dzlk: Haskell will feel like scheme does to you now :P
16:11:47 <haskellian> haskell is static typing done right
16:11:48 <dmhouse> dzlk: well Scheme's a nice language (in theory, at least).
16:11:49 <lispy> dzlk: it's especially annoying for my manager because I then pass on all the whinning about python to him :)
16:11:57 <haskellian> best of both worlds, non-verbose+ a lil safer
16:14:06 <vixey> hm
16:14:11 <rwbarton> heck, python doesn't even tell you about misspelled variable names until run-time.  That's not exactly modern technology :P
16:14:25 <vixey> mmorow: Do you remember that thing a while ago about simplifying boolean expressions?
16:14:36 <vixey> mmorow: and we had to do a few tricky things to ensure termination
16:14:54 <vixey> mmorrow *
16:17:22 <yitz> rwbarton: well, you always run your unit tests at compile time. hopefully, you catch misspelled variable names then.
16:23:02 <mmorrow> interesting...  -XPackageImports  =>  http://hpaste.org/9696
16:23:31 <vixey> hey mmorrow,
16:24:04 <vixey> do you remember the thing about simplifying boolean expressions ? and all the complication involved in being sure it terminates
16:25:34 <dons> Igloo: so how many haskell libs and apps are in debian now?
16:25:55 <dons> harrop uses the lack of debian installs to hit us over the head, and i think its directly related to how many packages there.
16:26:10 * Igloo has no idea
16:26:13 <dons> 493 arch haskell packages, fwiw.
16:26:27 <dons> do we have someone who's sole job in life is to put new packages into debian?
16:26:49 <lispy> but, do we care what Harrop says?
16:26:57 <dons> we can counter long term trends.
16:27:10 <dons> library platform in every distro. 500 packages for every child.
16:27:17 <dons> a compiler in every house.
16:27:22 <lispy> No distro left behind!
16:27:42 <dons> lambdas you can believe in!
16:27:45 <dons> yes we can!
16:27:52 <vixey> maybe it wasn't your code :s
16:27:58 <wjt> OPC?
16:28:05 <lispy> ?faq Can you put a Haskell compiler in every home?
16:28:05 <lambdabot> The answer is: Yes! Haskell can do that.
16:28:21 <dons> Igloo: so is there a "debian team" that tries to get new libs and apps in?
16:28:27 <dons> or is it more of an on demand, ad hoc process?
16:29:37 * lispy begins to seriously wonder how some of this code is supposed to hold together
16:29:51 <Igloo> dons: People upload what they want to upload
16:30:25 <dons> hm. i wonder if a more focused effort is needed. the ocaml guys seem to be rather coordinated
16:30:40 <vixey> focused on what?
16:31:10 <dons> focused on the prize of having all the libs and tools readily available in debian
16:31:28 <yitz> Igloo: for a straightforward hackage package, is there a trivial way to make it into a Debian package?
16:31:39 <Heffalump> dcoutts_ is the one to ask about that
16:31:47 <dons> yes, automation is required. the arch packages are done entirely via a script
16:32:05 <dons> it waits for uploads, pulls them from hackage, builds a new package, tests it, then i upload to the main repo.
16:32:06 <vixey> I wish I could run debian
16:32:27 <yitz> vixey: why can't you?
16:32:31 <dons> with automation, i think it's a one man job to maintain a hackage<-> distro mapping
16:32:41 <tehgeekmeister> is there a way to do global substitution with the pcre regex library?
16:32:46 <vixey> I don't know, I tried to boot off a debian CD but it's just blank
16:32:58 <dons> tehgeekmeister: in a loop, yeah.
16:33:00 <stepcut> yitz: cabal-debian
16:33:05 <ski> matthew-_ : pong
16:33:21 <tehgeekmeister> dons: ?
16:33:22 <stepcut> yitz: but installing cabal-debian is a bit of work right new :(
16:33:23 <Trinithis> I was glancing at the monad section in real world haskell, and noticed that it said that chaining a bunch of Maybes will continue to the end of the >>= chain even if a Nothing appears. Is this true? I would have thought it would short-curcuit
16:33:25 <stepcut> s/new/now/
16:33:27 <dons> i really think the goal should be: anything you can build, should be in debian.
16:33:44 <stepcut> dons: we (at seereason) have almost all the pieces in place for that
16:33:52 <wolgo> quit
16:33:53 <dons> exciting, stepcut!
16:34:00 <yitz> stepcut: why should it require work?
16:34:03 <ski> Trinithis : depends on what you mean ..
16:34:15 <dons> so enough that one person can hit a button, and spit out a new .deb, given a .cabal file?
16:34:28 <Igloo> dons: It's not possible to make good enough quality Debian packages with a script. For example, your X11 package claims that it is "copyright: Alastair Reid, 1999-2003, libraries@haskell.org 2003-2007", but you can find many other copyright notices in the code
16:34:30 <stepcut> yitz: you have to build some dependencies, that is all
16:34:34 <Trinithis> Nothing >>= a >>= b >>= c -- this will go all the way to c
16:34:53 <Trinithis> I dont think so tho
16:34:53 <vixey> c isn't evalutaed in that
16:34:54 <Igloo> The automatable bits are automated, though
16:35:00 <vixey> because Nothing >>= _ = Nothing
16:35:02 <ski> Trinithis : when it encounters a `Nothing' it won't execute any of the right-hand-sides of the `(>>=)'
16:35:04 <stepcut> yitz: start here, and chase dependencies until working, http://src.seereason.com/cabal-debian
16:35:07 <lambdabot> Title: Index of /cabal-debian
16:35:12 <dons> is an effort made to bring new packages into debian as they arrive on hackage?
16:35:16 <Trinithis> Alright, that's what I thought. Thanks
16:35:20 <yitz> Igloo why isn't the copyright notice in the cabal file good enough?
16:35:30 <Igloo> yitz: Because it's wrong
16:35:34 <haskellian> if i have a datatype that contains both ints and ByteStrings, can I serialize both? or I first have to convert the data itself to a bytestring? how then?
16:35:38 <Heffalump> dons: what apps should be in debian that aren't?
16:35:40 <dons> yitz: is cabal-debian on hackage?
16:35:52 <stepcut> dons: we have cabal package->debian package, and autobuild debian package working. The download packages from cabal automatically, and update autobuilder list is not done
16:35:55 <yitz> stepcut?
16:36:08 <dons> Heffalump: i don't know! we've 600 packages on hackage. 500 are in arch now. how many are in debian? > 100 ? > 50?
16:36:11 <ski> Trinithis : however in `((Nothing >>= a) >>= b) >>= c', all the `(>>=)' themselves on the "way up" will still check that the left argument returned `Nothing' before returning `Nothing' themselves
16:36:19 <Heffalump> apps, not libraries
16:36:22 <stepcut> cabal-debian is not on hackage yet, because we were restructuring some libraries it depends on, so we can upload everything to hackage
16:36:25 <ski> Trinithis : mayhaps they had that in mind ..
16:36:26 <Heffalump> I'm questioning the existence of such things
16:36:31 <dons> stepcut: woot!
16:36:35 <Trinithis> I see
16:36:40 <dons> Heffalump: ok. let's see.
16:36:48 <dons> the libraries need to be there too, of course.
16:36:58 <Trinithis> ski: Is there ever a point to doing that though?
16:37:04 <dons> so if someone searches for say, xml or biology, they find haxml and haskell-bio
16:37:07 <ski> Trinithis : using continuations, one can avoid this, having the `Nothing' so to speak "jump directly" up to the nearest "exception handler"
16:37:13 * stepcut looks forward to cabal-debian appearing in arch
16:37:21 <dons> stepcut: yeah, i can add it if you put it on hackage.
16:37:44 <stepcut> ;)
16:37:49 <dons> http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=arch-haskell&SeB=m&SB=n&SO=a&PP=100&do_Search=Go
16:37:57 <dons> so things with "haskell-" are libs
16:38:30 <Trinithis> ski: nevermind. The monad laws answer my question
16:38:43 <yitz> dons: on debian, there are separate packages libghc6-*, libhugs-* for each package.
16:38:59 <stepcut> yitz: separate binary packages, but a single source package
16:39:07 <yitz> yeah
16:39:19 <stepcut> yitz: cabal-debian does that automatically
16:39:25 <tehgeekmeister> dons: you mean using the loop from Control.Arrow?
16:39:28 <ski> Trinithis : i'm not sure what "that" in "Is there ever a point to doing that" referred to ..
16:39:31 <dons> tehgeekmeister: no, just writing a loop
16:39:31 <yitz> stepcut: this is sounding better and better
16:39:42 <tehgeekmeister> dons: oh, okay
16:39:47 <dons> stepcut: so you think this will be the equivalent of cabal2arch ?
16:39:53 <stepcut> yitz: you probably need the patched version of haskell-debian from seereason.com
16:40:01 <dons> all automated, all the time. and one person can get everything into .deb form?
16:40:10 <stepcut> dons: hopefully
16:40:16 <dons> great. that's exciting.
16:40:29 <yitz> and then, on to ubuntu...
16:40:32 <dons> right.
16:41:08 <stepcut> dons: ideally you will be able to do, cabal-debian-install <some package on hackage> and it will either install the debs (if already built) or chase down all the required packages, convert them, build them, upload them, and install them
16:41:10 <yitz> shall we sing? "We're marching to Pretoria..."
16:41:27 <stepcut> yitz: cabal-debian has primarily been tested against ubuntu hardy
16:42:33 <yitz> stepcut: hmm, don't we need to do one distro at a time to avoid making a mess of dependencies?
16:43:02 <dons> that's great stepcut.
16:43:14 <dons> native distro packages are just so so important if you're trying to get new haskell apps out.
16:43:22 <dons> users have to be able to easily satisfy any dep they need
16:43:25 <Trinithis> ski: Let me clarify: (Nothing >>= a) >>= b {VS} Nothing >>= (a >>= b)
16:43:26 <stepcut> yitz: probably. We only care about hardy at the moment, and our archive is not really public.
16:43:39 <vixey> >>= is associative
16:43:41 <Trinithis> ski: but they are guaranteed to be equivalent
16:43:41 <vixey> that's a monad law
16:43:52 <stepcut> yitz: though the number scheme used should avoid conflicts, and allow debian or ubunto to trump us automatically
16:44:03 <ski> Trinithis : yes .. but the former is more efficient than the latter
16:44:13 <yitz> stepcut: ok. so ubuntu first, then kubuntu, then debian unstable?
16:44:21 <Trinithis> how so?
16:44:39 <dcoutts> excellent
16:44:40 <dcoutts> dons: yeah, this is definitely what we should be doing for all distros
16:44:41 <ski> (also the latter should really be `Nothing >>= \x -> (a x >>= b)')
16:44:46 <dcoutts> dons: that and cabal-install really are the killer features of the whole Cabal/Hackage architecture
16:45:02 <stepcut> yitz: well, after we get the tools released, the next step is to fix them to follow policy (if they don't already), and then coordinate efforts amongst the different distros
16:45:11 <ski> Trinithis : err, sorry. i meant the latter is more efficient than the former
16:45:18 <Trinithis> ;D
16:46:01 <lumi> ski: So the second one does nothing more efficiently?
16:46:08 <yitz> stepcut: yeah, and that pretty much implies that order. because you've got much of the ubuntu policy out of the box.
16:46:09 <stepcut> yitz: our (seereason's) hope is to provide some good tools to the maintainers work more efficiently, but we have no desire to take over the process.
16:46:14 <ski> lumi : indeed !
16:46:18 <vixey> @check 0 + 0 == 0
16:46:19 <lambdabot>  OK, passed 500 tests.
16:47:05 <ski> lumi : though to notice it, you should have a chain of `n' binds, where `n' approaches infinity
16:47:32 <stepcut> yitz: and to allow us to package up the stuff that isn't into debian/ubuntu quickly and easily so that it does not interfer with development
16:47:51 <ski> @check \x -> x == x/3 + x/3 + x/3
16:47:53 <lambdabot>  Falsifiable, after 2 tests: 1.8
16:48:07 <vixey> @check \x -> (x::CReal) == x/3 + x/3 + x/3
16:48:08 <lambdabot>   add an instance declaration for (Arbitrary CReal)     In the expression: le...
16:48:11 <vixey> >:|
16:48:13 <yitz> stepcut: so you can use it in-house even before things get uploaded.
16:48:27 <stepcut> yitz: right
16:48:58 <yitz> stepcut: yeah, but the side-effect goodness for the community is huge.
16:49:00 <haskellian> Can this be serialized with Data.Binary ? http://hpaste.org/9698
16:49:18 <stepcut> yitz: also, cabal-debian does what it can given the information that is available in the .cabal file. But for a proper debian package, some additional attention to detail will usually be required.
16:49:23 <haskellian> I ahve to write m,y own serialization for something?
16:49:38 <ski> Trinithis : anyway, in `ContT o Maybe', you'll automatically get the efficiency aforementioned ..
16:49:47 <yitz> stepcut: especially wrt licencing/freeness, I suppose.
16:50:04 <stepcut> yitz: but, packages created by cabal-debian and built by the autobuilder, should be able to gracefully upgrade if debian/ubuntu releases a version
16:50:22 <stepcut> yitz: or the short/long descriptions in the control file
16:50:58 <yitz> stepcut: how much outside information does cabal-debian need to be able to match up cabal deps to deb deps?
16:51:22 <stepcut> yitz: your status file
16:51:37 <yitz> that's enough?
16:51:56 <stepcut> yitz: and your ghc-pkg.conf probably
16:52:19 <dons> haskellian: just use Data.Binary
16:52:55 <stepcut> yitz: perhaps. I am not sure exactly how it works. But I know that it has a way to map cabal deps back to the debian packages that provide them
16:53:24 <yitz> stepcut: so it looks into the status file, guess the corresponding ghc pkg names? or does it dig down into deb pkg contents? or what?
16:53:41 <yitz> stepcut: sounds really cool
16:53:55 <stepcut> yitz: i think it calls dpkg -S to find the binary that provides the library
16:54:14 <yitz> dons: does your script have to do a huge amount of work to match up cabal deps to arch deps?
16:55:40 <dcoutts> yitz: we should do more reverse dep matching, eg a .cabal file says it needs a C lib and some header files. We should match those to packages that provide those files.
16:56:40 <yitz> dcoutts: oh, that's way beyond what I was thinking. I'm hoping to get basic pure Haskell cabal working.
16:57:28 <dcoutts> yitz: oh, then that just relies on a naming convention
16:58:05 <dcoutts> yitz: build-depends: foo becomes ... eg on gentoo it's "dev-haskell/foo" on debian it's ghc6-foo-dev or whatever
16:58:59 <dons> yitz: it uses a standard naming convention for arch deps
16:59:28 <yitz> hmm, if each hackage creates a new debian source package, there
16:59:39 <stepcut> dons: does arch record what package an installed file comes from ?
16:59:58 <dons> yeah.
17:00:06 <yitz> is some bureacracy that has to be done to get it added. :/
17:00:41 <stepcut> yitz: yes. though our tool chain provides everything you need to maintain your own apt-get repository
17:01:13 <stepcut> yitz: or, if you are just using cabal-debian, you can just do, debi to install the packages after you build them
17:01:52 <tehgeekmeister> dons: it seems like i'm going to have to re-scan the entire text (up until a match) for every match if i use the loop;; sorry to be such a newb, but would you mind explaining to me an efficient way of doing this?  i'm using Text.RegexPR right now, but it's going very slow so I'm trying to switch to a better regex library.
17:02:39 <yitz> stepcut: yeah, for local work it's all you need.
17:03:27 <stepcut> yitz: right. I usually just use cabal-debian to build stuff locally. And then if I am going to use it, I commit the stuff to source control, and update the build spec.
17:04:17 <sbahra> vixey, what do you mean?
17:04:20 <stepcut> dons: do you also build an arch live CD with all the haskell stuff installed ?
17:04:34 <sbahra> vixey, "do you remember the thing about simplifying boolean expressions ? and all the complication involved in being sure it terminates"
17:04:52 <sbahra> vixey, in general?
17:04:55 <stepcut> sbahra: is there a good solution to that ?
17:05:16 <sbahra> Well, I only had to do this for a class.
17:05:20 <sbahra> And we used "karnaugh maps".
17:05:27 <dons> stepcut: no, i don't do live cds.
17:05:35 <stepcut> dons: :p
17:08:04 <sbahra> stepcut, a straight implementation of them wouldn't perform very well.
17:08:48 <stepcut> sbahra: ah. i think the problem I am running into is different.
17:09:00 <stepcut> sbahra: though, perhaps related.
17:09:06 <vixey> sbahra: I can't find the code
17:09:18 <sbahra> vixey, you write it
17:09:26 * stepcut is working on a blog post about the problem he keeps running into
17:15:53 <yitz> dcoutts: perhaps cabal should enforce that if certain known licenses are used, that the correct LICENSE file exists? that could help this sort of automation.
17:17:41 <dcoutts> yitz: I don't know how we can check correctness, the license content can vary, esp for BSD since it contains people's names
17:17:58 <dcoutts> yitz: we complain if the LICENSE is absent
17:18:31 <dcoutts> yitz: a clever program could do this with hackage, it could download the .cabal file and license and compare them and upload it's opinion
17:18:46 <dcoutts> yitz: at least with the new hackage server we could do that easily
17:19:09 <stepcut> yitz: i think cabal-debian does something sensible with the licenes field
17:19:23 <ski> sbahra : istr there's something called McCluskley's method ..
17:19:30 <stepcut> dcoutts: virtualrms ?
17:19:55 <dcoutts> stepcut: never heard of it, but if it does that then it'd make writing the checker client easier.
17:19:59 <sbahra> ski, http://en.wikipedia.org/wiki/Quine-McCluskey_algorithm
17:20:00 <stepcut> http://en.wikipedia.org/wiki/Vrms
17:20:00 <lambdabot> Title: QuineMcCluskey algorithm - Wikipedia, the free encyclopedia
17:20:01 <lambdabot> Title: vrms - Wikipedia, the free encyclopedia
17:20:03 <sbahra> ski, reading now
17:20:30 <sbahra> quine ftw
17:20:31 <sbahra> ;]
17:20:35 * stepcut does not really know what vrms actually does
17:21:10 <dcoutts> stepcut: oh, seems it just lists packages from non-free, it doesn't look at license files
17:22:49 <yitz> stepcut: for uploading to a distro, we can't just rely on the license field. it has to be checked. it would be nice if that is also automated for a significant percentage of packages.
17:23:42 <sbahra> ski, seems it would be much easier to program than a karnaugh
17:23:49 <ski> yes
17:24:58 <stepcut> yitz: right, vrms may or may not contain something that verifies the license files
17:25:51 <stepcut> vrms may only look at the dependencies and see if stuff in free depends on things in non-free, or something like that
17:26:38 <stepcut> I wonder if there is any good general purpose fuzzy text matching packages on hackage
17:29:23 <yitz> dcoutts: my idea was to enforce this at package creation time. if we only check for the license file at upload-to-distro time, we are far less likely to find and/or recognize the correct license file.
17:30:08 <dcoutts> yitz: if we accumulate a lot of these complex tests then the place to put them is not in Cabal or in the upload checks but in a staging phase for new packages
17:30:42 <dcoutts> yitz: clearly the Cabal lib cannot be parsing LICENSE files and making hard decisions on the basis of that.
17:31:06 <yitz> dcoutts: it would work like this: we bless certain license names, and for those we require *exactly* a certain LICENSE file in the root.
17:31:09 <dcoutts> yitz: but a special hackage client could flag up suspicious cases
17:31:17 <dcoutts> yitz: that does not work for BSD
17:31:24 <yitz> why?
17:31:37 <dcoutts> yitz: because the content varies
17:31:48 <yitz> hmm.
17:32:41 <yitz> so we would have to bless certain popular specific variations on bsd. if they do something else, we would have to revert to manual checking.
17:32:52 <sbahra> BSD is dead.
17:33:23 <dcoutts> yitz: the authors names are in the BSD license file, that's what makes them vary
17:33:25 <sbahra> yitz, what do you guys need to do exactly?
17:33:48 <sbahra> Oh, BSD license variations. :-) I thought you were talking about FreeBSD/NetBSD package management.
17:33:58 <dcoutts> yitz: I'm greatly in favour of marking packages with lots of extra bits of meta data that gets set by various different measures/tests. We can then use those to create various subsets of hackage that pass various QA measures.
17:34:41 <yitz> sbahra: in as many cases as possible, we want to verify without human intervention that the package really is being released under the license that is claimed in the cabal file.
17:35:17 <dcoutts> yitz: and this is a nice candidate for that. We can have a client that checks licenses and flags up dodgy cases. Then eg packages in some of the inner QA circles need to not have such dodgy uses.
17:36:03 <yitz> dcoutts: I don't just want to gather metadata. I want to find a way to encourage people to include a LICENSE file that can automatically be verified against their claim in the cabal file.
17:36:32 <dcoutts> yitz: gathering the data allows one to exert the pressure to have things done right
17:36:44 <sbahra> yitz, I see.
17:36:53 * sbahra agrees with dcoutts 
17:36:54 <dcoutts> yitz: this is not a case that can be checked with 100% certainty
17:37:00 <yitz> dcoutts: once we have to flag it as dodgy, it's too late. that will happen all too often unless there is some easy and obvious way for people to make the right choice to begin with.
17:37:09 <dcoutts> yitz: not so
17:37:26 <yitz> dcoutts: no definitely not 100%.
17:37:45 <dcoutts> yitz: we can publish on the main hackage list only packages passing certain QA standards. Users can choose to look at everything or only filtered subsets.
17:38:05 <dcoutts> yitz: we can also have a staging area where we do extra checks and packages that do not pass do not graduate
17:38:11 <yitz> dcoutts: yeah, that's definitely a good idea. i'm looking for something else though.
17:38:23 <dcoutts> yitz: good luck
17:38:53 <dcoutts> yitz: I cannot see how it can ever be more than heuristic, though it could probably achieve pretty good accuracy
17:39:36 <dcoutts> yitz: good enough to provide useful info, but my intuition is that it'd not be enough to be completely confident in excluding some upload synchronously
17:40:08 <yitz> dcoutts: all it means is that if you write, e.g., "gpl2", then you must have a certain file. If you want to write "gpl2, of sorts", that's fine.
17:40:28 <dcoutts> yitz: we also have to be careful to not make the initial bar too high. But we can make a whole series of hoops to jump through, and encourage maintainers to jump through them.
17:40:29 <stepcut> yitz: there are lots of versions of gpl2 though, because they kept changes address and stuff
17:40:46 <stepcut> of course, you should use the one with the current address ;)
17:40:56 <dcoutts> yitz: Cabal and hackage will already complain if you use license: gpl2, because it does not parse
17:41:02 <dcoutts> yitz: it's not a free-form field
17:41:28 <dcoutts> yitz: it's an enumeration with an other
17:41:31 <stepcut> dcoutts: right, but it does not check the License-File: LICENSE points to a file that actually contains GPL2
17:41:32 <yitz> dcoutts: it's not? didn't it used to be?
17:41:37 <dcoutts> stepcut: indeed
17:41:42 <dcoutts> yitz: no, never
17:42:35 <yitz> dcoutts: so if I want to release under some bizarre Creative Commons combination, for example, I can't do that?
17:42:39 <dcoutts> yitz: well it could have been some time long ago, but not since hackage that's for certain.
17:43:18 <dcoutts> yitz: you can use "license: OtherLicense" and use the "license-file: "
17:43:36 <yitz> ah, so that's effectively free form then.
17:43:52 <haskellian> CAN I SERIALIZE THIS: http://hpaste.org/9698   ????
17:44:13 <yitz> dcoutts: so what's the problem with requiring the correct license file?
17:44:14 <dcoutts> yitz: certainly, you can use whatever license you like, but we at least all agree on the same name for the same license in the common cases.
17:44:27 <yitz> dcoutts: perfect
17:44:48 <dcoutts> yitz: it's not possible to enforce with complete certainty, as we've already discussed.
17:46:07 <dcoutts> yitz: Cabal/Hackage currently goes as far as enforcing common license names and that if the user specifies a license file that it does actually exist.
17:46:09 <yitz> dcoutts: for known licenses with know files, you can. so do it then. when you can't - don't. that will still get us auto package upload in most cases, as opposed to usually manual as now (probably).
17:47:02 <dcoutts> yitz: but as we've said, in the number one most common case, of BSD we cannot enforce it because the content varies because it includes author names and copyright dates
17:47:32 <haskellian> CAN I SERIALIZE THIS: http://hpaste.org/9698   ????
17:47:37 <dcoutts> yitz: if we check them on hackage and only bother to package things in the inner subsets of QA then we get the same advantage
17:47:55 <dcoutts> yitz: that's one of the carrots we can use for jumping through the QA hoops
17:48:11 <dcoutts> haskellian: use show
17:48:13 <haskellian> encodeFile :: Binary a => FilePath -> a -> IO () , is a = what is to be serialized?
17:48:24 <dcoutts> haskellian: ahh, binary serialisation
17:48:25 <glguy> date as bytestring?
17:48:30 <haskellian> docutts: Binary.show? because normal show is sick sick slow
17:48:34 <dcoutts> harinath: and you don't need to shout :-)
17:49:11 <haskellian> glguy: I have a list of data that contains ints and bytestrings
17:49:17 <dcoutts> haskellian: so yes, you can use Data.Binary for serialsing that record, just put each member in turn and do the reverse for get.
17:49:38 <dcoutts> haskellian: perhaps you just need to see an example of Binary instances
17:50:34 <dons> haskellian: yeah, you're not asking "can i serialise this". you're asking "please show me how"
17:50:39 <dcoutts> dons: you can't upload foo-1.0 !! you're stealing our meta package names! :-) it's like registering example.com :-)
17:51:50 <yitz> dcoutts: I suppose - if there's enough of an incentive that people will usually do it. For now, though, it means that uploading all of the current packages to debian will be a lot of manual work.
17:52:26 <dcoutts> yitz: right, that's my plan to drive up QA standards and do it centrally so that each distro packing group do not have to do that
17:52:45 <dons> dcoutts: the package is called foo(tball) apparently.
17:52:47 <yitz> dons: is that an upgrade to hnop? perhaps you should speak to the owner of that package.
17:52:52 <dcoutts> yitz: and my approach is to do it by measuring these things automatically and using carrot and stick
17:53:02 <dons> it's a football game.
17:53:05 <dons> called foo.
17:53:11 <dons> srsly.
17:53:12 <dcoutts> dons: grr ;-)
17:53:16 <yitz> oh.
17:53:34 <dcoutts> dons: next up, bar, a drinking game using OpenGL!!
17:53:41 <yitz> s/foo/foo-football/
17:54:11 <dons> haskellian: http://hpaste.org/9698#a1
17:54:23 <dons> haskellian: now you can use encode and decode to generate those things
17:54:26 <nolrai_East> is there a standard type for obligatory infinite lists?
17:55:02 <dons> Stream
17:55:02 <yitz> I think I'm going to upload a package with software for needlepoint. Hmm, I'll call it - "string" !
17:55:11 <dons> good thinking, yitz.
17:55:39 <nolrai_East> dons: ah yes!
17:55:42 <nolrai_East> dons++
17:56:06 <nolrai_East> my mother does needlepoint.
17:56:07 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Stream-0.2.6
17:56:09 <lambdabot> Title: HackageDB: Stream-0.2.6, http://tinyurl.com/6evr7y
17:57:19 * ddarius will write a library for the Package Transform and upload the package package.
17:58:05 <yitz> dcoutts: there is a bit of a conflict of interest here. we want it to be really easy to upload to hackage. so the carrot and stick can't be too strong. so in practice most people won't do it.
17:58:30 * ddarius has wanted to write software for knitting and crochet.
17:58:40 <dcoutts> hmm, how do we get package baz I wonder
17:58:47 <yitz> dcoutts: whereas for the license, we're only talking about one tiny point that's easy. but we want to be really strict with it.
17:59:00 <dcoutts> yitz: I think social pressure and pressure to get into distros are stronger than you think
17:59:28 <yitz> dcoutts: ok i hope so
17:59:32 <dcoutts> yitz: you think it's easier than I do, I think we can only resolve that using real code.
18:00:02 <dons> social pressure is great for cleaning up things.
18:00:13 <dons> i send build failure logs to every maintainer who uploads a new package that breaks now
18:00:24 <dons> they're very keen to fix things.
18:00:36 <lispy> dons: I did find a paper about generalized zippers, BTW
18:00:41 <dons> cool
18:00:47 <yitz> dcoutts: well you say that bsd is a problem. though even then, there's probably a way to get around that one special case.
18:00:50 <ddarius> lispy: Title?
18:00:55 <dcoutts> yitz: if we make all these QA indicators and summaries of them available to users browsing on hackage then it influences their decisions and that piques the pride of package maintainers
18:01:00 <lispy> it looked sort of heavy weight, though...they went into all this jazz about differentiation
18:01:27 <dcoutts> dons: right, and once we have sufficiently reliable automated build logs like that we can send reports automatically
18:01:30 <lispy> ddarius: http://okmij.org/ftp/Computation/Continuations.html#zipper
18:01:31 <lambdabot> Title: Continuations and delimited control
18:01:52 <lispy> actually maybe it was just the wikibook that talk about differentiation
18:02:01 <yitz> dcoutts: but in general - it is really simple. we say - here are some license files. copy one literally into your tree, and tell us which one. or say "other" and you're on your own.
18:02:12 <lispy> "Our zipper is polymorphic over the data structure to traverse, and the zipper creation procedure is generic and does not depend on the data structure at all."
18:02:26 <ddarius> I remember that one.
18:02:40 <Philonous> I am still wondering where the connection between type differentiation and calculus is. It can't be a coincidense, can it?
18:02:52 <dcoutts> yitz: yeah, I think we could have code to do it pretty well, good enough to be useful and only very occasionally require manual override to say the license is ok even though the tool flagged it up as suspicious
18:02:55 <yitz> dcoutts: I agree though that the QA incetive idea is great
18:03:01 <lispy> Philonous: I think this explains it: http://en.wikibooks.org/wiki/Haskell/Zippers
18:03:03 <dcoutts> yitz: oh sure, we can make it easier to start, integrating an improved mkcabal into cabal-install will help there.
18:03:09 <ddarius> Philonous: Both operations are derivation and they very roughly express the same idea.
18:03:13 <lispy> Philonous: at least they have a long section on differentiation
18:03:44 <ddarius> Philonous: Type differentiation wasn't called type differentation for no reason.  There are also much more direct connections via combinatorics and generating functions.
18:04:12 <dcoutts> yitz: so mkcabal does do this already, provide license templates. We just need to prod dons 'til he sends patches to integrate it into cabal-install
18:05:57 <yitz> dcoutts: ok, there we go. once the creation part is automated, people have to go out of their way to mess up the license. so we can *rely* on their being lazy. :)
18:06:24 <dcoutts> yitz: right :-)
18:09:40 <Philonous> lispy - at first glimpse this paper doesn't seem to go into details how type derivation and calculus are connected. Are there any in-depth papers on that topic? I can grasp that they are related - but not exactly how. And I don't want to do all the math by myself :>
18:10:07 <lispy> Philonous: I'm not much of a type theorist.  But maybe ddarius knows.
18:12:27 <Philonous> ddarius: Can you give me a hint where to look for more detailes information on that topic? (Or for that matter: can you recommend any books on (advanced) type theory? )
18:13:10 <ddarius> This isn't really type theory stuff.
18:13:38 <ddarius> This paper does somewhat address this issue directly. http://www.cas.mcmaster.ca/~carette/species/
18:13:39 <lambdabot> Title: Species: making analytic functors practical for functional programming
18:14:03 <rwbarton> Philonous: In some sense, you just have to verify that d/dX (X^n) = n X^(n-1) matches the type-theoretic interpretation and the rest is formal.  But that's not a very satisfying explanation
18:14:27 <Philonous> Thanks
18:14:31 <nolrai_East> @src fmap
18:14:32 <lambdabot> Source not found. You untyped fool!
18:14:36 <monochrom> Don't expect it to be too deep.
18:14:42 <ddarius> Personally, I'd recommend reading the beginning of generatingfunctionology, dispguide.com, something on complex analysis etc.
18:14:50 <ddarius> s/dispguide.com/dspguide.com
18:15:39 <ddarius> Generating functions, complex analysis, and the Z-transform (and so the Laplace transform and the Mellin transform and the Fourier transform) are all intimately related.
18:16:10 <ddarius> Combinatorics is also mixed into that, though I'm not as knowledgable about that.  Cale is though.
18:16:39 <Philonous> Thanks again
18:18:05 <ddarius> Those ideas are at the center of a hub of mathematical ideas that span from applications in electrical engineering to theoretical problems such as the Riemann Hypothesis in number theory.
18:18:58 <nolrai_East> whats the type class that fmap is in? Mappable?
18:19:03 <kpreid> Functor
18:19:04 <kpreid> :t fmap
18:19:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:19:14 <nolrai_East> thanks
18:19:30 <chrisdone> good day, chaps
18:19:36 <hackage> Uploaded to hackage: roguestar-engine 0.2.2
18:19:36 <hackage> Uploaded to hackage: roguestar-gl 0.2.2
18:19:36 <hackage> Uploaded to hackage: rsagl 0.2.2
18:20:03 <lispy> roguestar??
18:20:37 <lispy> "Roguestar is a science fiction themed roguelike (turn-based, chessboard-tiled, role playing) game written in Haskell. This package provides the core game engine; you'll probably want to also install the OpenGL client. "
18:20:41 <lispy> Cool
18:22:40 <ddarius> Philonous: As for type theory, the modern recommendations are TAPL and ATTAPL.
18:22:43 <nolrai_East> Why is stream a member of Eq and Show?
18:23:21 <ddarius> nolrai_East: What's wrong with that?
18:23:24 <nolrai_East> err show i can see
18:23:37 <ddarius> Equality is, of course, only semi-decidable.
18:26:04 <nolrai_East> ehh, just feels like an easy way to get bugs.
18:26:12 <mmorrow> <vixey> do you remember the thing about simplifying boolean expressions ? and all the complication involved in being sure it terminates
18:26:19 <mmorrow> vixey: yes i do
18:27:10 <rwbarton> Philonous: Taking the derivative of a function of x is like replacing x by x + dx and then looking at the term with just one dx factor.  Similarly we can take a data structure of x's, and replace each x by either an x or a dx, and look at the possibilities with just one dx, and wherever that dx is becomes the "hole".
18:27:19 <koninkje> So, to resolve the issue of portable infinity/notANumber for Ratios while keeping polymorphism, I'm considering introducing a new typeclass. Other than GHC.Real and RealFrac, is there anything like that already out there?
18:27:33 <ddarius> nolrai_East: We have equality on lists too and just as semi-decidable
18:28:29 <Philonous> rwbarton: That makes sense
18:28:59 <rwbarton> (Probably sigfpe's blog has a post that says as much)
18:29:17 <lispy> rwbarton: hehe
18:29:18 <Philonous> Ah, I was looking at it from the wrong angle.
18:29:42 <lispy> rwbarton: he does have a cool blog doesn't he
18:30:14 <ddarius> rwbarton: The definition of differentiation in the paper I referenced is very similar to what you've said.
18:30:32 <rwbarton> lispy: Yes, it's one that I read independently of HWN.
18:31:35 * allbery_b thinks he may finally really have a working solari 9 ghc 6.8.2
18:31:35 <nolrai_East> ddarius: true, but its not just as semi-deciable. err I guess it is, but does always return on finite lists. meh.
18:31:47 <allbery_b> (now to make it work for 6.8.3...meh)
18:34:41 <allbery_b> two minor changes needed to make it work properly without a couple tiny hacks (lik forcing the right gcc to be used)
18:35:33 <|Steve|> > log .05
18:35:35 <lambdabot>   add an instance declaration for (Num (f a))
18:35:40 <nolrai_East> Its anoying that you cant pattern match on <:>.
18:36:08 <ski> rwbarton : infinitesimal types ftw :)
18:36:09 <|Steve|> > log 0.05
18:36:11 <lambdabot>  -2.995732273553991
18:37:01 <ski> nolrai_East : `(<:>)' being ?
18:37:23 <nolrai_East> ski: (:) for streams.
18:37:57 <nolrai_East> I guesing it was writen before infix constructors.
18:38:12 <ski> @hoogle Stream
18:38:13 <lambdabot> A Hoogle error occurred.
18:38:38 <nolrai_East> A stream is an obligatory infinite list.
18:38:38 * ski didn't know there was a stream type in standard libs ..
18:38:41 <ddarius> nolrai_East: Use view patterns.
18:38:42 <dons> hey, this looks nice, http://breds.ru/haskell-xmpp/
18:38:45 <dons> adept++
18:38:56 <nolrai_East> thanks.
18:38:58 <ski> nolrai_East : a haskell list is a potentially finite stream :)
18:39:11 <tehgeekmeister> is there a way to gather information on how quickly the runtime is processing a file?  i can let the command run out entirely, but i'd like to be able to see improvements/regressions in running speed without having to let the program run for twenty minutes each time.
18:39:31 <bd_> tehgeekmeister: Well, you could add code to measure it...
18:39:48 <bd_> I suppose it depends on what/how your code is processing it
18:40:47 <tehgeekmeister> i'm processing an xml dump of a wikipedia file, and the code has gotten significantly slower in the last two or three revisions, but i want to know how much slower
18:41:03 <tehgeekmeister> and yes, i could write code to measure it, but i'm not going to do that if haskell can already tell me.  =P
18:44:55 <rwbarton> tehgeekmeister: hmm, on linux you may be able to use lsof and /proc/<pid>/fdinfo/<fd> to figure out how much of the file your program has read
18:45:18 <tehgeekmeister> rwbarton: that sounds good
18:46:41 <rwbarton> tehgeekmeister: Yeah, so lsof -p <pid> to figure out what file handle has the input open and then cat /proc/<pid>/fdinfo/<fd> to get the offset
18:46:59 <tormentor> Why doesn't this do what I think it should?
18:47:08 <tormentor> seqmap :: (Monad m) => (a -> m b) -> [a] -> m b
18:47:08 <tormentor> seqmap = sequence . map
18:47:18 <rwbarton> tehgeekmeister: I'm sure there are caveats about the file pointer in the kernel vs. haskell buffering and so on
18:47:41 <rwbarton> :t sequence . map
18:47:54 <tormentor> Oh wait...  (f . g) a b
18:48:09 <tormentor> Is like f (g a) b
18:48:10 <tormentor> right?
18:48:19 <rwbarton> tormentor: Yes
18:48:32 <rwbarton> :t \f x -> sequence (map f x)
18:48:33 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
18:49:17 <Trinithis> @let dot = (.).(.)
18:49:18 <lambdabot> <local>:10:6:     Ambiguous type variable `f' in the constraint:       `Funct...
18:49:32 <dons> tehgeekmeister: just use the profiler?
18:49:37 <dons> tehgeekmeister: or time the computation.
18:50:02 <tehgeekmeister> dons: the profiler would do it, i just don't want to have to go thru the whole file each time, which is how timing would do it.  it takes about twenty minutes per run right now.
18:50:15 <Trinithis> tormentor: sequence . map doesnt work because of .'s type. What you want is sequence `dot` map where dot = (.).(.)
18:50:23 <tehgeekmeister> dons: i just didn't know if the profiler would do it, so i asked;; i'll look into how to do that now.
18:50:44 <rwbarton> tehgeekmeister: easiest is probably just to prepare a smaller input file.
18:50:52 <lispy> I Bet there's an arrow for (.).(.)
18:50:58 <lispy> :t (.).(.)
18:50:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:51:04 <tehgeekmeister> rwbarton: good idea.
18:52:26 <sereven> dcoutts, yitz, Parts 2 and 3 of article by developer working with several distributions and multiple projects http://lwn.net/Articles/277132/  http://lwn.net/Articles/277132/
18:52:31 <lambdabot> Title: Distribution-friendly projects Part 2 [LWN.net]
18:53:25 <yitz> sereven: thanks
18:53:42 <tormentor> Trinithis: I don't quite follow that and rwbarton's example is simple and fairly concise.
18:54:07 <sereven> yitz: yw. nice synchronicity was referred to in today's blog post by that dev.
18:54:13 <Trinithis> . applies 1 argument. dot is the same thing, but takes 2
18:54:43 <Trinithis> @src Prelude.(.)
18:54:43 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:56:02 <tormentor> I see.
18:56:05 <Trinithis> tormentor: f `dot` g = \x y -> f $ g x y
18:57:17 <twanvl> or quit obfuscating, and just write seqmap f = sequence . map f
18:57:34 <Trinithis> dot is a nice combinator. I uise it a lot
18:58:17 <Trinithis> And to make it better give it a fixity decl: infixr 9 `dot`
18:58:44 <twanvl> dot should be called dot2 or something, since (.) is often pronounced as "dot" already
19:02:28 <nolrai_East> @let dot = (.).(.)
19:02:29 <lambdabot> <local>:10:6:     Ambiguous type variable `f' in the constraint:       `Funct...
19:02:48 <nolrai_East> hmm
19:03:25 <nolrai_East> :t (((.).(.)) . ((.).(.)))
19:03:26 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
19:03:52 <nolrai_East> :t (((.).(.)) ((.).(.)) ((.).(.)))
19:03:54 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) a1 b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a1 -> b) -> (a -> f2 a1) -> f (f1 a) -> f (f1 (f2 b))
19:04:10 <rwbarton> @unpl (((.).(.)) ((.).(.)) ((.).(.)))
19:04:10 <lambdabot> (\ c f h i l r -> c (f (h i l) r))
19:04:12 <twanvl> @let dot = (.)(.)(.)::(b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:04:13 <lambdabot> Defined.
19:04:36 <nolrai_East> :t (dot . dot)
19:04:38 <lambdabot> forall a a1 b c a11 a12. (b -> c) -> (a -> a1 -> a11 -> a12 -> b) -> a -> a1 -> a11 -> a12 -> c
19:05:16 <nolrai_East> :t (dot `dot` dot)
19:05:18 <lambdabot> forall a a1 b c a11 a12. (b -> c) -> (a11 -> a12 -> b) -> (a -> a1 -> a11) -> a -> a1 -> a12 -> c
19:05:28 <Trinithis> :t take 1 $ iterate (.) (.)
19:05:37 <Trinithis> :t take 2 $ iterate (.) (.)
19:08:34 <Trinithis> :t take 2 $ iterate (.) id
19:08:57 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/monadPrimer.hs
19:09:31 <Trinithis> what's that for?
19:10:34 <twanvl> Trinithis: (.) doesn't have type a -> a, so you can't iterate it
19:11:12 <lispy> :t iterate
19:11:13 <lambdabot> forall a. (a -> a) -> a -> [a]
19:11:20 <lispy> :t fix
19:11:22 <lambdabot> forall a. (a -> a) -> a
19:11:31 <Trinithis> @ty (.)(.)
19:11:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
19:11:45 <lispy> :t iterate fix
19:11:46 <Trinithis> :t take 2 $ iterate ((.)(.)) (.)
19:14:55 <tehgeekmeister> okay, it's too slow: it's taken over thirteen minutes already just on the first million lines...
19:16:56 <mmorrow> tehgeekmeister: what are you parsing with?
19:17:02 <tehgeekmeister> http://hpaste.org/9699 <== anyone have suggestions how to speed this up?
19:17:14 <tehgeekmeister> mmorrow: combination of tagsoup and regexps
19:17:22 <yitz> @type (.)((.)(.))
19:17:23 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f2 (f1 (a -> b)) -> f2 (f1 (f a -> f b))
19:17:35 <tehgeekmeister> mmorrow: tagsoup strips all the xml down to the article contents, and regexps get rid of the wikipedia markup
19:17:41 <yitz> @type (.)(.)(.)(.)
19:17:43 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
19:18:01 <yitz> same
19:18:03 <dons> tehgeekmeister: tagsoup on String?
19:18:07 <dons> is this the 4G file again?
19:18:17 <tehgeekmeister> yes
19:18:19 <Trinithis> @let (#) = Prelude.(.)
19:18:20 <lambdabot> <local>:12:6: Not in scope: data constructor `Prelude'
19:18:32 <dons> what regex engine is Text.RegexPR using?
19:18:44 <dons> you're going to need lazy bytestrings, no matter what here.
19:19:04 <Trinithis> @ty (#)
19:19:05 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:19:18 <tehgeekmeister> dons: that's what i wanted to use, but i wasn't aware i could with tagsoup?
19:19:20 <dons> so in this code, you're parsing String, and constantly packing to C strings to do regex matching.
19:19:30 <dons> tehgeekmeister: right, you can't. its for small web files.
19:19:44 <Trinithis> @let f # g = \x -> f $ g x
19:19:45 <lambdabot> <local>:11:0:     Warning: Pattern match(es) are overlapped              In t...
19:19:57 <dons> tehgeekmeister: now, pcre-light has a bytestring non-copying pcre backend
19:20:00 <Trinithis> @ty (#)
19:20:01 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
19:20:07 <dons> but no standard substitution mechanism.
19:20:27 <tehgeekmeister> dons: that's the problem, i'm not quite up to being able to write the substitution mechanism yet
19:21:11 <dons> at least you'll be able to process the files at C speed with lazy bytestrings. but the analysis will take more effort. avoiding Strings are key here, and packing/unpacking overhead.
19:21:18 <mmorrow> tehgeekmeister: hmm, i'd try to bytestrings if at all possible, and also check if the particular regex lib you're using is the fastest (assuming you're set on using regexes)
19:21:31 <mmorrow> *try to use bytestrings ...
19:21:55 <mmorrow> i'm not familiar with RegexPR
19:21:56 <dons> I don't know anything about this RegexPR lib
19:21:57 <tehgeekmeister> mmorrow: i'd avoid regexes if i knew how to write a nice function that lazily scans over a string/list and modifies it as it goes, but i don't know how.
19:22:14 <dons> so you can certainly transform a lazy bytestring stream wise
19:22:16 <tehgeekmeister> it was the only one i found that had a global substitution mechanism
19:22:41 <tehgeekmeister> dons: that's what i'd like to do, but i've not found any tutorials that cover how to do such a thing, and don't have a clue how to do it in haskell myself yet
19:22:42 <dons> hmm. so we need an efficient, lazy stream-based substitution on lazy bytestrings eh?
19:22:52 <tehgeekmeister> yes!
19:23:02 <dons> tehgeekmeister: it's a matter of writing list-like loops over the bytestring
19:23:20 <dons> take/drop/ and pattern matching.
19:23:53 <dons> i wonder if there's a restartable regex lib of any note
19:24:07 <tehgeekmeister> and somehow fusing these so it ends up being only one iteration over the list?  will composition do for that?
19:24:08 <dons> pcre is rather focused on strict bytestrings.
19:24:34 <dons> tehgeekmeister: laziness helps with that.
19:24:42 <dons> each chunk is processed through the pipeline in turn
19:24:47 <tehgeekmeister> that's what i thot
19:25:02 <tehgeekmeister> which is why i wrote my code the way i did
19:25:07 <dons> but Strings are too inefficient here, linked lists per character
19:25:16 <tehgeekmeister> i'm sure most of the overhead is in the libraries i'm using, not the layout of my code itself
19:25:18 <dons> you need lazy bytestrings, lazy lists of strict chunks.
19:25:23 <tehgeekmeister> right
19:25:25 <dons> the overhead of String.
19:25:37 <tehgeekmeister> right, string as well
19:26:04 <dons> if you find stack overflows in lib functions that you try, that would be interesting to send back to the authors of the packages.
19:26:17 <tehgeekmeister> none have overflowed yet
19:26:28 <tehgeekmeister> and i HAVE processed the entire file, when i had fewer regexps in the picture
19:26:40 <lispy> dons: have you ever thought about that in most languages the solution to HUGE strings (aka ropes) is usually a tree of character arrays, but here in Haskell you guys did lists of characters arrays
19:26:44 <dons> ok
19:26:53 <dons> yeah, lispy.
19:26:58 <dons> we need ropes too
19:27:01 <tehgeekmeister> when i was just using tagsoup i could process the entire file in about 15 minutes
19:27:12 <tehgeekmeister> before the regexps were brought in
19:27:15 <mmorrow> tehgeekmeister: yeah, essentially your prog's perf is completely dependent of the performance of whatever regex lib you use
19:27:18 <|Steve|> > 1 - (exp (-3/(0.05/0.14)))
19:27:20 <lambdabot>  0.9997751326758212
19:27:39 <tehgeekmeister> mmorrow: right, which is the major hangup right now.
19:27:57 <nolrai_East> > (exp (-3/(0.05/0.14)))
19:27:59 <lambdabot>  2.248673241788482e-4
19:28:10 <dons> mmorrow: and the data packing overhead
19:28:23 <Trinithis> @ty (.)(.)(.)(.)(.)(.)(.)(.)
19:28:25 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:28:28 <Trinithis> @ty (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
19:28:29 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:28:33 <mmorrow> i can't decide what i'd use if i were you. i'm choosing between alex, bytestringreadp, or by hand with bytestrings
19:28:38 <mmorrow> tehgeekmeister: ^
19:28:43 <Trinithis> haha they repeat!
19:28:47 <dons> i'd probably see how far i got by hand
19:28:53 <dons> then try the alex tokeniser
19:29:00 <dons> regex + tokens, shouldn't be too hard.
19:29:08 <ddarius> lispy: lists are better for linear processing
19:29:11 <|Steve|> > 1 - (exp (-3/(0.05*7)))
19:29:13 <lambdabot>  0.9998105581747672
19:29:53 <mmorrow> yeah, judging from those regexes, it seems like Bytestring take/drop/takeWhile/.. would get you pretty far
19:30:15 <tehgeekmeister> mmorrow: in the same sort of way i used takeWhile in grabArticles?
19:30:23 * mmorrow looks
19:30:47 <lispy> ddarius: I'm not suggesting it was a bad design, more than it's interesting that haskell lended itself to this design
19:31:08 <tehgeekmeister> mmorrow: wait, but that's only going to find me the section of the list i want, it's not going to perform substitution...
19:31:16 <|Steve|> > 1 - (exp (-1/(0.05*7)))
19:31:18 <lambdabot>  0.9425673807323827
19:31:39 <newsham> anything important missing?  http://www.haskell.org/haskellwiki/MonadPrimer
19:31:40 <lambdabot> Title: MonadPrimer - HaskellWiki
19:32:33 <|Steve|> > 1 - (exp (-1/(0.5*7)))
19:32:35 <lambdabot>  0.248522706924714
19:33:07 <mmorrow> tehgeekmeister: hmm, i'm still thinking about the takeWhile/.. strategy. the substitutions shouldn't be that bad though
19:33:21 <|Steve|> > 1 - (exp (-1/(0.02*7)))
19:33:24 <lambdabot>  0.99920950967688
19:33:47 <mmorrow> tehgeekmeister: i'll think about it
19:36:52 <LegendaryPenguin> what's wrong with if ([] == xs)
19:37:07 <ddarius> lispy: My point was that lazy bytestrings solve a different problem than ropes.  The problem they solve is usually solved differently in imperative languages.  Usually you'd have a buffer that you'd fill, process, repeat.  To encapsulate this in a data structure would require mimicking laziness.  Lazy bytestrings are simply another example of a lazy language using data structures as control structures.
19:37:34 <nolrai_East> is there an easy way to add a prefix to a stream?
19:37:35 <bos> @sec foldM
19:37:35 <lambdabot> foldM _ a []     = return a
19:37:35 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
19:37:37 <ddarius> > null [id, (1+)]
19:37:39 <lambdabot>  False
19:37:54 <ddarius> > [] == [id, (1+)]
19:37:56 <lambdabot>   add an instance declaration for (Eq (a -> a))
19:37:56 <lambdabot>     In the expression: [] == ...
19:38:12 <ddarius> @src (++)
19:38:13 <lambdabot> []     ++ ys = ys
19:38:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:38:13 <lambdabot> -- OR
19:38:13 <lambdabot> xs ++ ys = foldr (:) ys xs
19:38:13 <lambdabot> -- In lambdabot, this is generalised to:
19:38:15 <lambdabot> (++) = mappend
19:38:41 <ddarius> nolrai_East: Take the second definition and simply have ys be a stream and (:) be (<:>)
19:38:49 <nolrai_East> Is @sec diferent from @src?
19:39:13 <nolrai_East> thanks
19:39:18 <newsham> ?help sec
19:39:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:39:37 <ddarius> lambdabot: @help newsham
19:39:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:39:47 <nolrai_East> ?help src
19:39:47 <lambdabot> src <id>. Display the implementation of a standard function
19:40:11 <nolrai_East> so what is sec?
19:40:15 <ruddel> i'm trying to download prerequisites for HDBC-ODBC but ...
19:40:16 <ruddel> Download and install MDAC/ODBC Software Development Kit, from a link on this page:
19:40:16 <ruddel> http://msdn.microsoft.com/data/ref/mdac/downloads/
19:40:17 <lambdabot> Title: Content not found
19:40:19 <ruddel> is not found
19:40:20 <ruddel> =(
19:40:27 <ddarius> nolrai_East: Lambdabot handles misspellings.
19:40:38 <ddarius> @quite
19:40:38 <lambdabot> Maybe you meant: quit quote
19:40:41 <ruddel> this is information is from haskell.org
19:40:45 <nolrai_East> Sweet
19:40:53 <ruddel> i want to use HDBC-ODBC only for MySQL
19:41:25 <ruddel> (sorry for spamming)
19:42:20 <ddarius> ruddel: Use the search on MSDN
19:43:40 <ruddel> ok
19:44:04 <tehgeekmeister> mmorrow: okay, thanks.
19:44:46 <nolrai_East> > do {let s = error "error"; let s = 1; return s;}
19:44:46 <lambdabot>  Parse error at "let" (column 28)
19:45:17 <nolrai_East> > do {let s = 1; return s;}
19:45:17 <lambdabot>  Parse error at ";}" (column 24)
19:45:20 <nolrai_East> > do {let s = 1; return s}
19:45:21 <lambdabot>  Parse error at "}" (column 24)
19:45:41 <nolrai_East> never mind
19:46:48 <ruddel> ddarius, no such luck :(
19:46:53 <ruddel> maybe they got rid of it
19:46:58 <ruddel> stupid microsoft
19:47:40 <ddarius> @google "MDAC/ODBC Software Development Kit"
19:47:43 <lambdabot> http://www.haskell.org/haskellwiki/HDBC-ODBC_under_Windows
19:47:43 <lambdabot> Title: HDBC-ODBC under Windows - HaskellWiki
19:48:37 <dkirk> bos: google sees a mysql project you wrote, but darcs doesn't see it on serpentine.com...is it available/ready?
19:48:40 <ruddel> ddarius, that's where I initially went, that link is dead for it
19:51:56 <jeffz> ruddel: this could be it http://www.microsoft.com/downloads/details.aspx?familyid=5067faf8-0db4-429a-b502-de4329c8c850&displaylang=en
19:51:59 <lambdabot> http://tinyurl.com/44nkt
19:52:14 <bos> dkirk: sidetracked for a bit
19:52:23 <ruddel> http://www.microsoft.com/downloads/details.aspx?FamilyID=6c050fe3-c795-4b7d-b037-185d0506396c&DisplayLang=en found it  i think
19:52:25 <lambdabot> http://tinyurl.com/6k6ko
19:52:41 <jeffz> ruddel: that's the runtime
19:52:43 <dkirk> understandable with the excellent book and all
19:52:51 <nolrai_East> It seems odd that there isnt a safe version of (!).
19:54:05 <chylli> is there an IO action like 'select' system call ?
19:54:06 <lispy> nolrai_East: like it returns Maybe a
19:54:54 <nolrai_East> yeah.
19:57:34 <lispy> I think the biggest problem with partial functions like that is that they lack composability
19:57:44 <lispy> You need to know their domain and check it for them
19:57:52 <nolrai_East> safeLookup arr ix = if ix `inRange` range arr then return arr !! ix else fail "error msg"
19:58:51 <nolrai_East> yep. Now im not saying replace (!), as this is a place where speed matters. but..
19:59:15 <lispy> ?src (!)
19:59:16 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
19:59:49 <lispy> ?src unsafeAt
19:59:50 <lambdabot> Source not found. There are some things that I just don't know.
20:02:07 <ddarius> I'd say most uses of (!) are cases where failure would be a program error and not something recoverable.
20:02:44 <nolrai_East> Yeah, but not all.
20:03:00 <ddarius> Yes, and it is easy enough to write safeIndex when you need it.
20:03:35 <nolrai_East> But it its so easy to write why not put it in the lib?
20:03:42 <ddarius> Though more likely you would push the bounds check out further.
20:03:58 <tehgeekmeister> http://hpaste.org/9700 <== i forgot the efficient away to do this, could someone remind me?
20:04:01 <ddarius> nolrai_East: There isn't much sense in putting easy to define but rarely used functions in the standard libraries.
20:04:10 <nolrai_East> true.
20:06:52 <nolrai_East> and the pushing up a level is a good point also.
20:07:30 <blbrown> how is the text in opengl support with haskell.  I think I read somewhere that the freetype library just go upgraded?  Anyone tried it recently?
20:09:11 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FTGL
20:09:12 <lambdabot> Title: HackageDB: FTGL-1.0
20:09:15 <dons> seems nice, and just got released.
20:16:23 <dsrogers> so, can you have a declaration of the from 1 = Constructor?
20:16:36 <dsrogers> for converting a literal 1 to an enum, I suppose?
20:16:57 <ddarius> Phantom types have to be one of my most commonly used Haskell idioms.
20:17:50 <rwbarton> dsrogers: As long as it typechecks (i.e. Constructor :: a for some Num a)
20:17:59 <rwbarton> dsrogers: It doesn't do anything as far as I can tell
20:18:15 <dsrogers> how is that a phantom type?
20:18:40 <nolrai_East> I dont think it is, is it?
20:18:46 <dsrogers> I thought a phantom type was when you have a type parameter that is never used.
20:19:11 <dsrogers> it's just there to make sure the right instance is chosen.
20:19:32 <nolrai_East> ahh. that sounds useful.
20:19:50 <dsrogers> it is.
20:20:07 <dsrogers> though apparently unnecessary soon with rank N types.
20:20:19 <dsrogers> I'm not sure what the new idiom is though
20:21:31 <nolrai_East> ddarius what have you seen them used for?
20:21:35 <mmorrow> tehgeekmeister: gah, i was looking for this forever and finally found it....
20:21:39 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/extract-meta.hs.html
20:21:41 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/55mr3o
20:21:43 <mmorrow> put it there
20:21:57 <mmorrow> very dirty/quick/hackish
20:22:22 <mmorrow> handparsing of stuff to extract things in between   <del> .. <imiters>
20:22:23 <tehgeekmeister> that will take me a day or two to grok
20:22:34 <tehgeekmeister> but
20:22:36 <tehgeekmeister> thank you
20:22:39 <mmorrow> ignore the srcpositions
20:22:44 <mmorrow> that was torture
20:23:07 <mmorrow> essentially, all it's doing it looking at the first few current chars in the string
20:23:20 <mmorrow> then, based on what they are, it does something
20:23:32 <mmorrow> usually one of two or three things
20:23:39 <tehgeekmeister> and it's lazy enough for my uses?
20:24:11 <mmorrow> that would start producing results immediately
20:24:27 <tehgeekmeister> okay, cool.
20:24:32 <mmorrow> but, it just illustrates the general strategy you'd use to hand parse
20:25:33 <tehgeekmeister> right, okay, i'll look that over later.  thanks very much, i should be able to get back on track with this.
20:26:11 <mmorrow> go ('<':'m':'a':'t':'h':'>':rest) = let (stuff,restrest) = span (not (`isPrefix` "</math"<)) rest in (stuff, f stuff) : go restrest
20:27:26 <mmorrow> ok, i've a better one that's actually is tagsoup-related
20:27:30 <mmorrow> s/is/
20:29:01 <thoughtpolice> dons: that empty set comic made my day, thanks :)
20:29:57 <tehgeekmeister_> mmorrow: that one liner hurts my head
20:30:12 * tehgeekmeister_ notices he's not on his screenname
20:33:27 * tehgeekmeister_ contemplates using sed instead
20:33:45 <mmorrow> http://hpaste.org/9702
20:33:52 <mmorrow> tehgeekmeister: hah, mine too
20:34:25 <mmorrow> so, that paste pulls the time/distance info from a google maps result page
20:34:45 <mmorrow> (well, that's the extracting part at least)
20:35:43 <mmorrow> there may be better ways to do that with functions tagsoup provides, i'm not sure. any way, good luck!
20:36:01 <tehgeekmeister_> mmorrow: right, i see that.  the extraction part of my code is the easiest part, tho.  i just need the contents of each <text> element.  it's removing the wikipedia markup that's a pain.
20:37:18 <mmorrow> hmm, ok. i guess i'm unclear then on your goal?
20:37:31 <wolgo> Hey I have a question.
20:37:48 <tehgeekmeister_> i'm removing all markup from a wikipedia xml dump
20:38:01 <tehgeekmeister_> to use it as a corpus for some natural language stuffs
20:38:21 <wolgo> Why doesn't haskell have "public static final abstract loopdeloop underschwang schwingschwong  int foo = 0" declarations?
20:39:07 <wolgo> It just figures out types as well as no declarations.
20:39:10 <ddarius> wolgo: Because everything is static final, there is no concept of 'abstract' and visibility is handled in module declarations.
20:39:21 <mmorrow> oh, i missed the point somewhat... how complex is this markup's syntax?
20:39:35 <wolgo> but in java you have to "write and entire paragraph before you actually define the int = 3"
20:40:44 <wolgo> Okay
20:40:50 <tehgeekmeister_> mmorrow: it's not too complicated, really.  there's a few different very, very simple different sorts of patterns i need to remove/partially remove
20:41:17 <wolgo> Well, I have been messing around with a couple of languages deciding on what I want to learn as my semi-first language and I think I am going to settle on haskell. Java is pissing me off.
20:41:39 <wolgo> I am going to have carpal tunnel before I even get into college typing this much.
20:41:42 <ddarius> Java v. Haskell is not a very fair comparison.
20:42:04 <ddarius> Why not compare with Scheme, J, Smalltalk, Prolog.
20:42:17 <wolgo> well I am a noob and typing this much is ridiculous
20:42:32 <wolgo> This is based solely on the amount of keystroks
20:42:36 <wolgo> strokes*
20:43:04 <ddarius> If you want to minimize keystrokes, J is the language for you, but beyond the core language it is insane.
20:43:30 <mmorrow> tehgeekmeister: ok, i just looked at your paste again, and i now i see what you're going for. alex may be useful. you use regexes to specify the tokens. also, it's *fast*. so if the regexes just aren't working, i guess i'd try that
20:44:02 <wolgo> Well I think Haskell will teach me a lot of stuff. I want something I can use as a vehicle to learn with. Not something that is going to obscure the details with ridiculous memorization tactics.
20:44:10 <wolgo> like remembering all these contexts
20:44:11 <wolgo> bleh
20:44:22 <wolgo> I am angry and saying stupid shit now I am going to shut up
20:44:31 <mmorrow> i've used this example alex lexer as a template to start from a bunch, it's pretty fast setup ..
20:44:38 * wolgo gets his Programming in Haskell book.
20:44:56 <wolgo> Thanks for the pointers ddarius
20:44:57 <tehgeekmeister_> mmorrow: okay, so alex should be able to do the substitution and all for me?
20:46:29 <mmorrow> it'll be able to classify the flat stream of chars into tokens of some type which you define, then you'd do it somehow there .. err, you'll see
20:46:36 <mmorrow> http://code.haskell.org/~morrow/code/haskell/hslex/
20:46:37 <lambdabot> Title: Index of /~morrow/code/haskell/hslex
20:47:04 <tehgeekmeister_> mmorrow: right, so it parses and i filter it using regular filter functions and whatnot?
20:47:08 <mmorrow> so that minirepo has an Lexer.x form alex's example folder, and a mini main.hs driver to make it go
20:47:39 <tehgeekmeister_> filter for any deletions and map for any substitutions
20:47:41 <mmorrow> tehgeekmeister: pretty much any way you can get it to do what you want, is a good way ;)
20:48:13 <tehgeekmeister_> i'm just making sure i'm not adding a whole lot of overhead again;; i've spent a week on this program so far, and don't want to start going in a new direction that'll be futile.  =P
20:49:13 <mmorrow> this won't be futile, but it may be more that 20 minutes of work. i guess it comes down to whether or not the regexes would *eventually* finish
20:50:04 <mmorrow> if it doesn't look like it, i guess you've gotta look to other options, and in that case i can say alex will definitely be able to handle the load..
20:50:27 <mmorrow> at least, i think that's what i'd try next
20:51:18 <dsrogers> :t withArray
20:52:34 <tehgeekmeister_> mmorrow: well, i let it run for 30 minutes on the first million lines and it still wasn't done...
20:52:43 <tehgeekmeister_> mmorrow: so i've lost all hope it will finish in any reasonable amount of time
20:53:13 <mmorrow> heh
20:53:23 <mmorrow> ok, so alex..
20:53:24 <mmorrow> http://darcs.haskell.org/alex/examples/words.x
20:53:33 <mmorrow> http://darcs.haskell.org/alex/examples/Tokens.x
20:53:50 <tehgeekmeister_> i don't mind putting a good amount of work in so long as it'll actually work.  i don't need it to be SCREAMING fast, either.  just reasonable.
20:54:02 <tehgeekmeister_> because once i've got it done properly, i only need to run it once
20:54:20 <tehgeekmeister_> and then i can start doing my real project.  finally.  =P
20:54:39 <mmorrow> totally, i know that feeling
20:56:00 <mmorrow> pretty much this whole directory, plus the alex manual and it'll probably take you two days *max* to have the finished and cleaned data
20:56:02 <mmorrow> http://darcs.haskell.org/alex/examples/
20:56:03 <lambdabot> Title: Index of /alex/examples
20:56:30 <mmorrow> http://haskell.org/alex/
20:56:31 <lambdabot> Title: Alex
20:56:36 <ddarius> > ord '|'
20:56:38 <lambdabot>  124
20:57:18 <ddarius> > chr 0x7E
20:57:21 <lambdabot>  '~'
20:57:29 <ddarius> > chr 0x7C
20:57:31 <lambdabot>  '|'
20:58:06 <tehgeekmeister_> mmorrow: cool, thanks.  that'll be a lot of help.
20:58:15 <mmorrow> good luck
20:58:29 <tehgeekmeister_> at the end of this, haskell will have a package to clean up wikipedia dumps, at least!
20:58:56 <wolgo> Is GHC or HUGS better for learning?
20:58:57 <mmorrow> heh, and you'll be able to throw down alex lexers in 10min flat for the next task that calls for one ;)
20:59:46 <tehgeekmeister_> wolgo: people say hugs is supposedly, but i use ghc exclusively and i'm just learning
21:00:18 <ddarius> wolgo: Use GHC
21:00:19 <wolgo> tehgeekmeister_: Are you using any books?
21:00:25 <wolgo> or just the wiki
21:00:28 <thoughtpolice> wolgo: ghc is overall the better route
21:00:33 <wolgo> Okay
21:00:37 <wolgo> I will believe you.
21:00:48 <mmorrow> oh, and use the ghc flag
21:00:50 <thoughtpolice> hugs supposedly has better err messages, but most of the GHC err messages are actually pretty comprehensible
21:00:54 <mmorrow> alex --ghc Asdf.x
21:00:59 <thoughtpolice> plus you get more libraries, extensions and a lot more speed :)
21:01:02 <ddarius> thoughtpolice: Hugs has horrible error messages.
21:01:09 <wolgo> Okay
21:01:35 <wolgo> I actually was messing with Haskell a while back but I got caught up with work and other stupid excuses
21:01:52 <thoughtpolice> ddarius: i can't verify that either way, which is why I said supposedly
21:01:59 <wolgo> I remember being confused about do notation and output
21:02:04 <ddarius> thoughtpolice: Why do you think that?
21:02:10 <wolgo> Okay here I go. Life with Haskell!
21:02:44 <thoughtpolice> ddarius: because it's only from what I've heard of those who used it, I never really did because everybody seemed to use GHC so I just went with that
21:02:51 <tehgeekmeister_> wolgo: not really, tutorials and the wiki and here
21:03:01 <tehgeekmeister_> wolgo: but i can already program in a few other languages decently
21:03:10 <wolgo> Okay
21:03:18 <wolgo> I have a very small amount of experience
21:03:27 <wolgo> I have written quite a few python programs
21:03:44 <wolgo> but I do not consider myself experienced
21:06:26 <thoughtpolice> wolgo: #haskell is friendly. so, ask questions :)
21:06:34 <dons> thoughtpolice: you're not muffin-noodle though, are you?
21:06:41 <wolgo> Okay.
21:06:46 <dons> oh maybe.
21:06:56 <thoughtpolice> dons: yeah I am
21:07:08 <dons> ;)
21:07:13 <thoughtpolice> thoughtpolice was already taken, muffin-noodle is my secondary tag because I figure not many places have it taken
21:07:31 <thoughtpolice> dons: yeah seriously, I've been in a car for like ~10 hours today so that made it all better
21:09:07 <dons> hehe
21:10:19 <koninkje> Regarding issues of infinity for Rationals, what do folks think of this: file:///Users/wren/local/haskell/cabalized/logfloat/dist/doc/html/logfloat/Data-Number-Transfinite.html
21:10:43 <wolgo> hehehe
21:11:15 <koninkje> er...
21:11:19 * koninkje puts it online
21:11:32 <nolrai_East> :t range
21:11:34 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
21:12:16 <tehgeekmeister_> wolgo: you could try writing a reasonably efficient prime number generator as a first exercise
21:12:23 <nolrai_East> :t (!)
21:12:25 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:12:32 <tehgeekmeister_> wolgo: it's not HORRIBLY hard, and it's reasonably challenging
21:12:43 <tehgeekmeister_> wolgo: there's lots of good tutorials you can steal ideas and such from, too
21:13:04 <tehgeekmeister_> wolgo: also, real world haskell is great (from what i've read so far).
21:13:14 <koninkje> here it is: http://code.haskell.org/~wren/logfloat/dist/doc/html/logfloat/Data-Number-Transfinite.html
21:13:16 <lambdabot> Title: Data.Number.Transfinite, http://tinyurl.com/6qucft
21:17:11 <dsrogers> anyone have a good nemonic for the behavior difference between foldl and foldr?
21:17:31 <dobblego> @google cale's fold diagrams
21:17:33 <lambdabot> No Result Found.
21:17:36 <dobblego> rar
21:17:40 <koninkje> "left" and "right"?
21:17:43 <koninkje> ;)
21:17:48 <dsrogers> left assoc means (((1+1)+1)+1)?
21:18:02 <dsrogers> i.e. the parens pile up on the left?
21:18:07 <dsrogers> or did I get it backwards again?
21:18:13 <koninkje> http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
21:18:48 <nolrai_East> :t inRange
21:18:49 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
21:19:04 <wolgo> Okay
21:19:07 <koninkje> or with dialog: http://cale.yi.org/index.php/Fold_Diagrams
21:19:09 <wolgo> I will check it out
21:19:17 <lambdabot> Title: Fold Diagrams - CaleWiki
21:19:58 <wolgo> So when using introducing a where clause I need to have all things that are using assignment aligned?
21:20:03 <dsrogers> thanks
21:20:10 <wolgo> I see
21:20:21 <wolgo> This is a lot less typing.
21:20:53 <koninkje> dsrogers: I'm not sure if it's a good mnemonic or not, but foldr is exactly replacing each (:) with the provided cons function, and replaces [] with the zero. foldl is the wierd one that reinterprets the structure
21:21:49 <dsrogers> ah. so foldl is the one safe for infinate data structures?
21:22:24 <wolgo> factorial n = n * factorial (n - 1), this would take a lot of typing!
21:22:26 <wolgo> haha
21:22:28 <wolgo> YES
21:22:31 <koninkje> no, foldr is safe for infinite lists
21:22:44 <koninkje> where "safe" means you can choose to only pull a little bit
21:23:02 <koninkje> for foldl you basically start at the end of the list, so if there is no end...
21:23:50 <mmorrow> > foldr f z (repeat x)
21:23:52 <lambdabot>  f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f...
21:23:57 <mmorrow> > foldl f z (repeat x)
21:23:59 <lambdabot>  Tried to use too much memory
21:24:14 <mmorrow> > foldl f z (replicate 100 x)
21:24:17 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
21:25:03 <dsrogers> > foldl f z (replicate 4 x)
21:25:05 <lambdabot>  f (f (f (f z x) x) x) x
21:25:07 <mmorrow> > foldr f z (repeat 10 x)
21:25:08 <lambdabot>  Couldn't match expected type `Expr -> [a]'
21:25:14 <mmorrow> > foldr f z (replicate 10 x)
21:25:16 <lambdabot>  f x (f x (f x (f x (f x (f x (f x (f x (f x (f x z)))))))))
21:25:22 <mmorrow> > foldr f z (replicate 4 x)
21:25:24 <lambdabot>  f x (f x (f x (f x z)))
21:25:44 <nolrai_East> > foldl f z (replicate 4 x)
21:25:46 <lambdabot>  f (f (f (f z x) x) x) x
21:26:09 <Axman6> > foldl f z [1..5]
21:26:10 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
21:26:28 <mmorrow> > foldr f z [1..5]
21:26:29 <nolrai_East> > foldr f z [1..5]
21:26:30 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
21:26:31 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
21:27:24 <nolrai_East> @src foldl
21:27:24 <lambdabot> foldl f z []     = z
21:27:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:27:35 <mmorrow> @src foldl'
21:27:36 <lambdabot> foldl' f a []     = a
21:27:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:27:43 <dsrogers> how are either one of those safe for an infinite list?
21:27:59 <nolrai_East> depends on what f is.
21:28:15 <dsrogers> oic.
21:28:23 <mmorrow> > foldr (\a _ -> a) 0 [1..]
21:28:26 <lambdabot>  1
21:28:27 <aFlag> Hm, how does it depend on f?
21:28:27 <dsrogers> if F is a constructor...
21:28:38 <nolrai_East> but for example foldr (:) [] is id
21:28:39 <aFlag> f doesn't see the list anywhere
21:28:52 <mmorrow> > foldl (flip (:)) [] [0..9]
21:28:54 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
21:29:08 <mmorrow> > foldr (:) [] [0..9]
21:29:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
21:29:58 <dsrogers> because it's only safe if f is constructing a list or other data type.
21:30:18 <dsrogers> if f is (+) you'll need a full scan of the list to get the single element.
21:30:24 <aFlag> what f would make it unsafe? Could you give me an example?
21:30:46 <mmorrow> > foldr (+) 0 [0..1000000]
21:30:48 <lambdabot>  Exception: stack overflow
21:30:53 <mmorrow> > foldl (+) 0 [0..1000000]
21:30:56 <lambdabot>  500000500000
21:31:32 <mmorrow> > foldl (++) [] (repeat [0..9])
21:31:35 <lambdabot>  Tried to use too much memory
21:31:37 <mmorrow> > foldr (++) [] (repeat [0..9])
21:31:39 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7...
21:32:01 <sbahra> >:(
21:32:09 <sbahra> > :(
21:32:10 <lambdabot> Unbalanced parentheses
21:32:19 <dsrogers> so if you're summerizing, use foldl, and if you're constructing a list, use foldr?
21:32:39 <nolrai_East> > foldr (\(l:ls) x -> x + l : l : ls) [1] [1..]
21:32:41 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
21:32:41 <lambdabot>       Expected...
21:32:59 <mmorrow> yeah, so you might look at it as depending on the associativity of the function passed as fold_'s first arg
21:33:00 <nolrai_East> > :t foldr
21:33:02 <lambdabot>   parse error on input `:'
21:33:13 <nolrai_East> :t foldr
21:33:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:33:23 <mmorrow> @src (++)
21:33:24 <lambdabot> []     ++ ys = ys
21:33:24 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:33:24 <lambdabot> -- OR
21:33:24 <lambdabot> xs ++ ys = foldr (:) ys xs
21:33:24 <lambdabot> -- In lambdabot, this is generalised to:
21:33:26 <lambdabot> (++) = mappend
21:33:30 <mmorrow> err
21:33:30 <nolrai_East> > foldr (\x (l:ls) -> x + l : l : ls) [1] [1..]
21:33:33 <lambdabot>  Exception: stack overflow
21:33:43 <nolrai_East> > foldl (\x (l:ls) -> x + l : l : ls) [1] [1..]
21:33:44 <mmorrow> infixr 5 ++
21:33:44 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:33:44 <lambdabot>       Expected...
21:33:48 <mmorrow> infixl 6 +
21:33:55 <nolrai_East> > foldl (\(l:ls) x -> x + l : l : ls) [1] [1..]
21:33:58 <lambdabot>  Tried to use too much memory
21:34:36 <mmorrow> infixr 9 .
21:35:12 <mmorrow> i got those by doing in ghci
21:35:16 <mmorrow> :i (.)
21:35:18 <mmorrow> etc
21:35:25 <mmorrow> (:info is awesome)
21:35:42 <sbahra> cool
21:36:13 <mmorrow> without :i life would be _so_ much more dificile
21:36:32 <mmorrow> +f
21:39:50 <DarkPyro> I'm sorry if this is a bad question, but I am somewhat new and someone who has been helping me isn't on at the moment. I am creating a function (digi) which has two arguments <base> and <count> where it will generate a Integer with a value of a pattern. Example: digi 1 5 = 12345. I am having issues with it though. http://hpaste.org/9703
21:41:05 <DarkPyro> Oh! Wow
21:41:09 <adu> wow?
21:41:42 <DarkPyro> Yeah, I always seem to figure it out after I post something, forgot mod. :/
21:42:30 <gwern> > let digi x y = [x..y] in digi 1 5
21:42:33 <lambdabot>  [1,2,3,4,5]
21:42:44 <shrughes> > let digi x y = read [digitToInt x .. digitToInt y] :: Integer
21:42:44 <lambdabot>  Parse error at end of input
21:42:45 <gwern> > let digi x y = show $ [x..y] in digi 1 5
21:42:47 <DarkPyro> List, not an Integer. :P It is only to learn. :/
21:42:47 <lambdabot>  "[1,2,3,4,5]"
21:42:50 <shrughes> yeah.. whatever
21:42:55 <gwern> hm.
21:42:56 <adu> i don't like div/mod/rem/quo
21:43:24 <DarkPyro> Augh, there seems to be glitches still. :/
21:43:26 <shrughes> > let digi x y = read [intToDigit x .. intToDigit y] :: Integer in digi 1 5
21:43:28 <lambdabot>  12345
21:43:45 <mmorrow> :t div/mod/rem
21:43:46 <lambdabot> forall a. (Fractional (a -> a -> a), Integral a) => a -> a -> a
21:43:49 <DarkPyro> Well I just got smacked in teh face. :/
21:43:49 <mmorrow> heh
21:43:54 <gwern> > let digi x y = init $ drop 1 $ show $ [x..y] in digi 1 5
21:43:56 <lambdabot>  "1,2,3,4,5"
21:43:59 <shrughes> using 'read' is cheating :)
21:44:01 <mmorrow> :t (div/mod/rem) 2 42
21:44:02 <lambdabot> forall a. (Fractional (a -> a -> a), Integral a) => a
21:44:04 <mmorrow> > (div/mod/rem) 2 42
21:44:06 <lambdabot>        add an instance declaration for (Fractional (a -> a -> a))
21:44:10 <adu> :t div
21:44:12 <lambdabot> forall a. (Integral a) => a -> a -> a
21:44:30 <gwern> > let digi x y = map (\x -> if x == ',' then [] else x) $ init $ drop 1 $ show $ [x..y] in digi 1 5 -- bwa ha ha
21:44:31 <DarkPyro> Alright still corrupt, but at least it is a challenge. No idea whats up at the moment. :x
21:44:32 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
21:44:45 <gwern> > let digi x y = map (\x -> if x == ',' then '' else x) $ init $ drop 1 $ show $ [x..y] in digi 1 5
21:44:46 <lambdabot>  Improperly terminated character constant at "''" (column 44)
21:44:55 <gwern> hm
21:44:59 <mmorrow> > "" == []
21:45:01 <lambdabot>  True
21:45:04 <mmorrow> > ''
21:45:05 <lambdabot>  Improperly terminated character constant at "''" (column 1)
21:45:12 <mmorrow> hehe
21:45:19 <DarkPyro> So I guess no easy way? ;)
21:45:47 <adu> > [] :: String
21:45:49 <lambdabot>  ""
21:46:01 <gwern> > let digi x y = map (\x -> if x == ',' then "" else x) $ init $ drop 1 $ show $ [x..y] in digi 1 5
21:46:03 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
21:46:18 <dsrogers> in template haskell how is TupleT type safe?  dont you have to pass the types of a tuple, not just an Int?
21:46:19 <adu> > ['h', 'e', 'l', 'l', 'o']
21:46:21 <lambdabot>  "hello"
21:46:59 <mmorrow> > [] :: [[[[[[[[[[[[[[[[[String]]]]]]]]]]]]]]]]]
21:47:01 <lambdabot>  []
21:47:09 <DarkPyro> The last iteration still screwed up.
21:47:18 <DarkPyro> 0123456788900
21:47:20 <DarkPyro> :/
21:47:41 <mmorrow> :t (concat . concat . concat . concat) ([]::[[[[a]]]])
21:47:43 <lambdabot> forall a. [a]
21:47:56 <DarkPyro> Updated: http://hpaste.org/9703#a1
21:48:38 <DarkPyro> I am a bit clueless now.
21:49:42 <DarkPyro> Nevermind. sorry.
21:50:01 <ddarius> dsrogers: TupleT 2 or whatever is just (,) not (Int, Bool)
21:51:25 <mmorrow> ghci> runQ [t| ((),Int) |]
21:51:25 <mmorrow> AppT (AppT (TupleT 2) (ConT GHC.Base.())) (ConT GHC.Base.Int)
21:52:01 <dsrogers> oh.
21:52:21 <mmorrow> cleaned up ...
21:52:22 <mmorrow> AppT (AppT (TupleT 2) (ConT ())) (ConT Int)
21:52:23 <dsrogers> ghci> (TupleT 2)
21:53:00 <mmorrow> dsrogers: this is really handy for cleaning up some of those ..
21:53:14 <dsrogers> what is really handy?
21:53:42 <mmorrow> heh, i was typing it out
21:53:46 <mmorrow> so
21:53:55 <mmorrow> :m + Data.Generics
21:54:00 <mmorrow> let cleanNames a = everywhere (mkT (mkName . nameBase)) a
21:54:15 <mmorrow> ghci> runQ [t| ((),Int) |]
21:54:15 <mmorrow> AppT (AppT (TupleT 2) (ConT GHC.Base.())) (ConT GHC.Base.Int)
21:54:23 <mmorrow> then
21:54:26 <mmorrow> ghci> return . cleanNames =<< runQ [t| ((),Int) |]
21:54:26 <mmorrow> AppT (AppT (TupleT 2) (ConT ())) (ConT Int)
21:54:36 <ddarius> mmorrow: ghci> cleanNames it
21:54:48 <mmorrow> ooh
21:55:03 <mmorrow> i don't think i've ever used 'it'
21:55:13 <dsrogers> ah
21:55:13 <mmorrow> and i should
21:55:42 <dsrogers> :t everywhere
21:55:43 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
21:55:58 <mmorrow> heh, check it out
21:56:08 <dsrogers> :i everywhere
21:56:11 <mmorrow> ghci> $(litE . stringL . show =<< reify 'it)
21:56:11 <mmorrow> "VarI it_1627398682 (ConT Language.Haskell.TH.Syntax.Type) Nothing (Fixity 9 InfixL)"
21:56:38 <mmorrow> cleaned
21:56:43 <mmorrow> ghci> $(litE . stringL . show . cleanNames =<< reify 'it)
21:56:43 <mmorrow> "VarI it (AppT (ConT []) (ConT Char)) Nothing (Fixity 9 InfixL)"
21:56:56 <adu> I've never saw such polymorphism in [] before today :)
21:57:06 <dsrogers> where is everywhere defined?
21:57:20 <mmorrow> err, Data.Generics._?_
21:57:30 <adu> Data.Generics.Schemes
21:57:31 <mmorrow> Defined in Data.Generics.Schemes
21:58:05 <mmorrow> dsroger: :info in ghci is really handy
21:58:21 <mmorrow> :i Info
21:58:26 <dsrogers> ghci> :i everywhere
21:58:47 <dsrogers> is data.generics part of TH?
21:59:03 <mmorrow> no, you gotta  :m + Data.Generics
21:59:46 <mmorrow> if you import Data.Generics   into a module, it imports all of the various Generics submods
22:00:13 <mmorrow> also, import Data.Typeable  is usually needed at some point with Data.Generics
22:00:36 <dsrogers> I'm confused.  Is Data.Generics built on the same types as TH?
22:01:08 <dsrogers> basically, I was talking about TH and you answer with Data.Generics.
22:01:12 <dsrogers> how are they related?
22:01:12 <mmorrow> oh, i see. no, it uses the typeclasses  Typeable and Data  to get the info it needs
22:01:47 <mmorrow> TH, on the other hand, is explicitly compiler supported and wired in
22:02:01 <tehgeekmeister_> mmorrow: oh, there might be a problem.  can alex do multiline matching?
22:02:07 <tehgeekmeister_> or do you know?
22:02:41 <wolgo> What is _, anything?
22:02:42 <mmorrow> it should only treat lines as anything of note if it's told to do so (i believe)
22:02:47 <DarkPyro> I did it!
22:03:15 <mmorrow> tehgeekmeister: so, maybe one of the rules is somehow implying that lines should be split?
22:03:21 <DarkPyro> > let digi b c = foldl (+) 0 (map (\x -> (mod (b + x - 1) 10) * 10 ^ (c - x)) [1 .. c]) in digi 5 10
22:03:23 <lambdabot>  5678901234
22:03:28 <DarkPyro> :)
22:03:32 <wolgo> Jesus this is so much easier for me to understand
22:03:41 <dobblego> @seen Jesus
22:03:42 <lambdabot> I haven't seen Jesus.
22:03:54 <DarkPyro> Lol.
22:04:00 <dsrogers> ah.  So you could build Data.Generics with TH instead of a compiler extension.
22:04:02 <wolgo> Okay sorry, Wolgo, this is so much easier for you to understand!
22:04:04 <tehgeekmeister_> mmorrow: there's a rule that matches "--".* and ignores it, which would mean that, if it ever matches, it'd consume the entire input unless it matches line by line
22:04:20 <DarkPyro> > let digi b c = foldl (+) 0 (map (\x -> (mod (b + x - 1) 10) * 10 ^ (c - x)) [1 .. c]) in digi 1 20
22:04:23 <lambdabot>  12345678901234567890
22:04:47 <wolgo> I have a question about recursion: Is the base case for a recursive function the identity of the set that it is operating on?
22:05:13 <dsrogers> so they both must use the same GADT for representing haskell types...
22:05:21 <mmorrow> tehgeekmeister: good point. hmm. i think it'll stop matching the .* as soon as it sees another token, though
22:07:17 <tehgeekmeister_> mmorrow: oh, right, it is a lexer, it's not just a regex library.  =P
22:07:41 <mmorrow> dsrogers: an interesting question. i'm not sure the answer, but one difference is that Generics/Typeable have a bunch of class instances that have been implemented for various datatypes, so they have access to that at runtime. TH, otoh, can't talk to the compiler at runtime because it doesn't exist.
22:07:45 <tehgeekmeister_> mmorrow: it looks like this should do what i want REALLY easily.  i'm excited.  *makes first version
22:08:09 <mmorrow> tehgeekmeister: nice! yeah, totally, alex is really handy
22:08:20 <wolgo> What is alex
22:08:34 <mmorrow> http://haskell.org/alex/
22:08:35 <lambdabot> Title: Alex
22:08:37 <adu> wolgo: do you know what lex is?
22:08:38 <dsrogers> mmorrow: right, you could use TH to generate that runtime information.
22:08:48 <wolgo> no but I am about to find out
22:09:10 <adu> wolgo: lex and yacc are classic parser generators
22:09:26 <dsrogers> how can I get ouput like:
22:09:29 <adu> wolgo: the GNU project reimplemented them as flex and bison
22:09:32 <wolgo> Oh I know what yacc it.
22:09:34 <dsrogers> > foldl f x [1..5]
22:09:36 <lambdabot>  f (f (f (f (f x 1) 2) 3) 4) 5
22:09:36 <wolgo> Okay
22:09:37 <mmorrow> dsrogers: totally. i'm very interested in that and things related also. it seems to me there's *so* many things you could do
22:09:37 <dsrogers> locally?
22:09:39 <wolgo> Cool
22:09:50 <wolgo> You guys can write those things pretty easily in Haskell?
22:09:54 <adu> wolgo: and the Haskell ppl reimplemented them as alex and happy (to generate Haskell instead of C)
22:10:05 <wolgo> Wow that is cool.
22:10:15 <wolgo> I want to make stuff like that.
22:10:19 <mmorrow> dsrogers: it's a package.. i think on hackage maybe
22:10:29 <mmorrow> i don't recall the name though
22:11:03 <dsrogers> can you do unsafePerformIO on lambda bot?
22:11:11 <mmorrow> heh, no
22:11:22 <dsrogers> geez, take away all my fun.
22:11:32 <dsrogers> I but I could use it to open a shell on the machine it's running on.
22:11:33 <adu> wolgo: what things?
22:11:34 <mmorrow> dsrogers: that reminds me though, another handy function re: TH is
22:11:43 <dsrogers> *bet
22:11:50 <mmorrow> unQ :: Q a -> a = unsafePerformIO . runQ
22:11:51 <wolgo> functions are applied like this: multiply x y -> ((multiply x) y)?
22:12:04 <adu> wolgo: yes, those are equivalent
22:12:14 <wolgo> adu: Like parsers and proving engines and cool things
22:12:17 <wolgo> adu: hehe
22:12:26 <wolgo> adu: I am preparing to go to school for cs
22:12:31 <adu> wolgo: yes, those are much easier in Haskell
22:12:46 <mmorrow> so you can do     cleanNames (unQ[|fmap id [0..9]|])     instead of    return . cleanNames =<< runQ [|fmap id [0..9]|]
22:12:56 <adu> wolgo: I'm sorry
22:13:04 <wolgo> adu: Why?>
22:13:13 <mmorrow> or   cleanNames `fmap` runQ [|fmap id [0..9]|]
22:13:14 <wolgo> for what?
22:13:20 <adu> wolgo: I have a very poor opinion of computer science
22:13:50 <wolgo> Why what happened?
22:13:51 <dsrogers> adu: O.o
22:14:24 <mmorrow> dsrogers: you could most definitely use it to open a shell
22:14:31 <adu> wolgo: I've only had one cs course, and I had to drop out because I couldn't communicate w/ my teacher
22:14:40 <wolgo> ewww
22:14:44 <wolgo> That is horrible
22:14:46 <flw> :t
22:15:00 <wolgo> I will be going to a private school so there is a really good student to teacher ratio
22:15:06 <wolgo> That is terrible, what school?
22:15:08 <flw> lambda bot is offline?
22:15:17 <ddarius> Single Poor Teacher => Entire field bad
22:15:42 <adu> wolgo: we had so many stupid arguments, like the order of execution of C's for-loops
22:15:44 <DarkPyro> > putStr "flw, lol"
22:15:46 <lambdabot>  Exception: "<IO ()>"
22:16:22 <adu> wolgo: by the time I took my first cs course I had already been programming for 5 years, so I knew more than my teacher, but I couldn't test out of it
22:16:30 <flw> > putStr "hello DarkPyro!"
22:16:32 <wolgo> Oh
22:16:32 <lambdabot>  Exception: "<IO ()>"
22:16:41 <DarkPyro> XD
22:16:46 <tehgeekmeister> is there a prelude function to strip a suffix off a list?
22:16:59 <dsrogers> take?
22:17:03 <wolgo> I get to take one class that uses functional programming that I know of
22:17:09 <dsrogers> err, drop
22:17:22 <dsrogers> > drop 5 [1..10]
22:17:24 <wolgo> One uses assembly and the others use java c cpp
22:17:24 <lambdabot>  [6,7,8,9,10]
22:17:31 <tehgeekmeister> dsrogers: i want a suffix analog of stripPrefix
22:17:58 <dsrogers> ghci>:i stripPrefix
22:18:06 <tehgeekmeister> dsrogers: i suppose i could just use the length of the suffix and drop/take
22:18:40 <dsrogers> oh, I see.
22:18:42 <tehgeekmeister> wait
22:18:43 <tehgeekmeister> no
22:18:47 <mmorrow> \suff -> reverse . stripPrefix (reverse suff) . reverse
22:18:54 <dsrogers> eeeeee.
22:18:58 <dsrogers> slooooow
22:18:59 <mmorrow> :(
22:19:00 <tehgeekmeister> that requires iterating the whole list multiple times
22:19:15 <adu> wolgo: but ya, I'm weird like that... mention anything about parser theory and higher-order functions and I'm so excited... but mention "CS" and all i can think of is that one teacher that jaded me forever...
22:19:38 <hackage> Uploaded to hackage: logfloat 0.8.5
22:19:38 <hackage> Uploaded to hackage: logfloat 0.8.4
22:19:59 <dsrogers> stripPrefix suff lst = drop (length suff) lst
22:20:00 <wolgo> You should try electrical engineering
22:20:04 <wolgo> I almost did
22:20:11 <dsrogers> that isn't what you want?
22:20:14 <wolgo> But electronics are boring and I am interested in AI
22:20:27 <adu> wolgo: hybrid
22:20:34 <wolgo> Oh cool
22:20:39 <wolgo> computer engineering?
22:20:41 <wolgo> haha
22:20:48 <mmorrow> \suff xs -> take (length xs - length suff) xs
22:20:48 <wolgo> that is what they call it at my school
22:20:52 * DarkPyro is going for electronics engineering. :/
22:21:08 <DarkPyro> Calling it boring? :P
22:21:13 <mmorrow> lists are sucky when you have to do anything at the end of them
22:21:13 <adu> wolgo: no no, i too am interested in AI, and the most promising approaches I've seen are hybrids between the classical approaches
22:21:23 <dsrogers> mmorrow: niether of our implementations actually check that the prefix is part of the list
22:21:23 <tehgeekmeister> mmorrow: agreed.
22:21:35 <dsrogers> stripPrefix (suff:rest) = rest
22:21:47 <mmorrow> dsroger: true
22:22:06 <dsrogers> stripPrefix x = x
22:22:14 <dsrogers> those two pattern matches, ftw.
22:22:15 <wolgo> adu: that is an interesting point. I was thinking something along the same lines. My school offers a hybrid of EE and CS and while I have ssaid "CS" I can still choose with little impact
22:22:23 <wolgo> I could get the best of both worlds
22:22:27 <mmorrow> i've had to write this function multiple times, and every one i've ended up doing double reverses
22:22:30 <wolgo> but I do not know
22:22:53 <tehgeekmeister> mmorrow: do you know if i can just use group matching in alex?
22:22:57 <tehgeekmeister> mmorrow: that'd solve it?
22:22:59 <ddarius> wolgo: Or the worst
22:23:32 <mmorrow> tehgeekmeister: i bet you could figure something out ..
22:23:35 <wolgo> ddarius: What?
22:23:47 <adu> wolgo: have you ever heard of CyN?
22:23:51 <ddarius> [00:22] <wolgo> I could get the best of both worlds
22:23:52 <wolgo> No
22:23:54 <dsrogers> the pattern is O(1) and the double reverse is O(2n)
22:24:01 <adu> http://www.daxtron.com/cyn.htm
22:24:01 <wolgo> ddarius: Heh nice :)
22:24:05 <tehgeekmeister> mmorrow: i can, i was just seeing if you already knew before i went searching for ages.  i'm efficiently lazy.
22:24:06 <lambdabot> Title: Special AI Tools
22:24:07 <tehgeekmeister> =P
22:24:25 <adu> wolgo: it combines the pattern-template approach with the inference-engine approach
22:24:31 <mmorrow> tehgeekmeister: heh
22:24:47 <wolgo> I am going to read about this.
22:25:15 <mmorrow> tehgeekmeister: err, so what is the exact situation?
22:25:31 <adu> wolgo: I think its possible to work ANNs in there, but i'm not quite sure where...
22:25:43 <tehgeekmeister> tehgeekmeister: i have a regex that matches between the <text> tags, and i need to strip the text tags off that match.
22:25:52 <tehgeekmeister> errr.
22:25:57 <tehgeekmeister> mmorrow: ^
22:26:25 <wolgo> Is it implied that all functions in Haskell are curried?
22:26:27 <mmorrow> ahh, that's easy!
22:26:30 <mmorrow> so..
22:26:31 <tehgeekmeister> mmorrow: since it seems alex passes the entire matched area to the code supplied
22:26:31 <tehgeekmeister> wolgo: yes
22:26:36 <wolgo> This is interesting
22:26:43 <tehgeekmeister> wolgo: look at points free stuff in the wiki, it's really cool
22:27:00 <mmorrow> have you're pattern that matches the interior of  the tags   as     @intags , then
22:27:13 <tehgeekmeister> oh!
22:27:15 <adu> wolgo: the only downside is that CyN chose OpenCyc instead of OWL, so you can't combine the pattern-template (AIML) with the knowledge-base rules
22:27:57 <mmorrow>  \<text\> @intags \<\/text\>    {\s -> InsideTextTok s}
22:28:32 <mmorrow> err, that's wrong
22:28:50 <tehgeekmeister> mmorrow: so this @name is some alex magic?  or is it @intags specifically?
22:28:50 <mmorrow> s will include the tags
22:28:55 <wolgo> Wow this is unbelievable
22:29:04 <wolgo> I cannto wait to work on this kind of stuff.
22:29:33 <mmorrow> so you'd have already defined @intags = $printable +
22:29:35 <mmorrow> (eg)
22:30:33 <wolgo> The dialog with the bot is great
22:30:46 <wolgo> It makes me feel kind of sad for her :(
22:30:59 <wolgo> She only believes she is self aware :p
22:31:00 <bos> @hoogle mplus
22:31:01 <lambdabot> A Hoogle error occurred.
22:31:06 <bos> bollocks.
22:31:06 <tehgeekmeister> mmorrow: wait, if s will include the tags, then what's the use of this @intags deal?
22:31:14 <bos> @hoogle msum
22:31:14 <lambdabot> A Hoogle error occurred.
22:31:15 <mmorrow> so in the {\s -> .... } , you might strip the "<text>" prefix off first, then hmm. maybe just keep the closing "</text>" around and strip it later (if it's too expensive to do now)?
22:31:20 <adu> wolgo: its easy, just download program D and edit the dictionary
22:31:42 <mmorrow> tehgeekmeister: yeah, it was a contrived example that ended up not working how i wanted it too ;)
22:31:49 <dsrogers> is there is an way to interpret TH besides just asking youguys?
22:31:52 <tehgeekmeister> mmorrow: okay, i dig
22:31:59 <dsrogers> I don't even know how to check it.
22:32:05 <tehgeekmeister> mmorrow: so i have to strip it manually.  that's fine.
22:32:17 <mmorrow> yeah, i believe so
22:32:40 <adu> wolgo: are you talking about alicebot?
22:32:45 <wolgo> Yeah
22:32:52 <wolgo> Haha
22:34:20 <mmorrow> tehgeekmeister: actually, wait. so the very fact that it matched, means that {\s -> <the s in here>}  has as its suffix "</text>", so you can just take (length s - length "</text>") s
22:34:50 <tehgeekmeister> mmorrow: oh, yes, which is definitely cheaper than reversing the list twice
22:34:50 <bos> boo, hiss. no instance for (Alternative STM).
22:35:05 <mmorrow> tehgeekmeister: most definitely :)
22:35:18 <sbahra> A society for the application of currying?
22:35:20 <sbahra> heh
22:35:29 <adu> wolgo: but anyways, there are 2 well-known inference-engine formats, one is Cyc and the other (more standard) one is OWL, so you might want to look into those as well
22:36:25 <sbahra> http://www.cynic.net/tsac.html
22:36:29 <adu> wolgo: one nice thing about OWL is that it is built on RDF, which defines all models in terms of triples (Subject, Predicate, Object)
22:36:37 <lambdabot> Title: Tokyo Schnfinkel Appreciation Club - Cynic Networking Laboratories
22:41:16 <bos> freebase seems to be the most accessible of the semantic web boondoggles.
22:42:16 <wolgo> This is a list of functions who take an argument of [a] and for all lists of type [a] return a list of [a] right? [[a] -> [a]]
22:42:23 <mmorrow> tehgeekmeister: ok, now i'm unconfused as to why i gave that example... so say you have  @string = ....  defined, then you can do   \" @string \"   {\s -> ...  (init . tail) $ s} . this seems to be used a fair amount in some of the alex code i've seen. i got confused for a second extending that to <..> </..>  from " .. ", but i think this'll be a nice strategy that'll come up a bunch, and now that i've explicitly described it in ver
22:42:23 <mmorrow> bose detail, i won't forget!
22:43:26 <mmorrow> so the general case would be        {\s -> ... (take n . drop m) $ s}
22:44:37 <tehgeekmeister> mmorrow: huh?
22:45:05 <adu> wolgo: no, thats not a list, that it the type signature of a list of functions who take....
22:45:49 <mmorrow> @innerstuff = [a-zA-Z_] [a-zA-Z0-9] *
22:45:50 <lambdabot> Unknown command, try @list
22:45:59 <mmorrow> then in the matching section ...
22:46:08 <wolgo> Oh right, I meant "This is the type"
22:46:12 <wolgo> Thanks
22:48:21 <mmorrow> some  @innerstuff   stuff9        {\s -> let n = length s in TSomeStuff9 . take (n - length "some" - length "stuff9") . drop (length "some") $ s}
22:49:03 <mmorrow> which is analogous to
22:49:22 <mmorrow> \" @string \"     {\s -> TString . init . tail $ s}
22:49:30 <tehgeekmeister> oh!
22:49:32 <tehgeekmeister> OH!
22:49:36 <tehgeekmeister> okay.
22:49:36 <mmorrow> hehe
22:49:41 <tehgeekmeister> thanks.
22:49:53 <sbahra> http://www.haskell.org/haskellwiki/Blog_articles/Comparisons#Prolog = 404
22:49:57 <lambdabot> Title: Blog articles/Comparisons - HaskellWiki, http://tinyurl.com/5j9deq
22:57:36 <jeffz> sbahra: try again ;)
22:58:40 <tehgeekmeister> mmorrow: any idea what the parse error at 9:18 is here ==> http://hpaste.org/9704
22:58:44 <tehgeekmeister> mmorrow: it all looks good to me?
22:59:47 * mmorrow looks
23:01:21 <tehgeekmeister> maybe alex chokes on tabs?
23:01:25 <tehgeekmeister> i used tabs instead of spaces.
23:01:29 <tehgeekmeister> i doubted it would care.
23:04:36 <|Steve|> Does Haskell assume that tabs are any particular size (e.g., the standard 8)?
23:05:24 <ddarius> Yes.
23:06:00 <adu> Steve: but that is slated to be removed in haskell-prime
23:07:17 <adu> Steve: or in other words, haskell-prime sources might not allow tabs at all
23:08:23 <adu> hmm, i wonder if theres been any talk of Haskell'''
23:08:33 <|Steve|> That's sort of dumb. Why would you disallow a tab?
23:09:11 <adu> http://hackage.haskell.org/trac/haskell-prime/wiki/Tabs
23:09:17 <lambdabot> Title: Tabs - Haskell Prime - Trac
23:11:55 <gwern> mein gott, this is a confusing problem
23:11:58 <gwern> @seen dcoutts
23:11:58 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
23:12:13 <gwern> preflex: seen dcoutts
23:12:13 <preflex>  dcoutts was last seen on #haskell 5 hours, 5 minutes and 48 seconds ago, saying: yitz: right :-)
23:12:14 <sbahra> @seen sbahra
23:12:14 <lambdabot> You are in ##logic, #haskell and #ghc. I last heard you speak just now.
23:12:35 <gwern> hmm. I guess I'll save this problem for later
23:22:26 <mmorrow> tehgeekmeister: ok, this works somewhat http://hpaste.org/9704#a1
23:22:44 <mmorrow> i've gotta brush up on alex's regex syntax
23:22:56 <tehgeekmeister> oh, so you don't just put the regex itself on the line?
23:23:03 <gwern> motherfucker! the problem was that cabal was installing to .cabal and not ~/bin like I configured it to!
23:23:03 <mmorrow> it has a couple non-standard (wrt) features
23:23:10 <gwern> goddamn, that just wasted 2 hours
23:24:16 <mmorrow> tehgeekmeister: you can, but i was trying a bunch of things in parallel to get it to work, trying to work around the parts of alex's regex syntax i'm fuzzy on
23:24:18 <gwern> the only saving grace is that I figured it out *before* I emailed the maintainer...
23:24:31 <tehgeekmeister> mmorrow: okay
23:24:37 <mmorrow> tehgeekmeister: so, to what extent that you can, i'm fuzzy
23:24:47 <tehgeekmeister> mmorrow: i tried a few different versions and had no luck yet
23:25:46 <mmorrow> oh yeah, and you're using a '?' after the .*
23:25:51 <mmorrow> ??
23:26:05 <gwern> seems kinder redundant
23:26:12 <mmorrow> i'm not familiar with that regex syntax, so that might be one thing
23:26:22 <tehgeekmeister> mmorrow: that's python/ruby syntax
23:26:27 <mmorrow> ahh
23:26:27 <tehgeekmeister> mmorrow: non-greedy matching
23:26:33 <mmorrow> oh, i see
23:27:15 <tehgeekmeister> and i think it might also be perl syntax, but i don't use it so i don't know.  i just know python and ruby both stole their syntax from perl to a large extent
23:27:36 <mmorrow> here's the syntax spec
23:27:37 <mmorrow> http://haskell.org/alex/doc/html/alex-files.html
23:27:38 <lambdabot> Title: 3.2.Syntax of Alex files
23:27:55 <tehgeekmeister> yeh, it seems kinda incomplete compared to the python spec i'm used to working with
23:28:02 <tehgeekmeister> but i've looked at it
23:28:15 <mmorrow> and here's the lexical syntax specified with itself   http://haskell.org/alex/doc/html/syntax.html
23:28:15 <lambdabot> Title: Chapter3.Alex Files
23:28:25 <tehgeekmeister> mmorrow: that makes my brain asplode
23:28:53 <mmorrow> heh
23:29:10 <mmorrow> you'll need this one if you read no others:
23:29:11 <mmorrow> http://haskell.org/alex/doc/html/regexps.html
23:29:13 <lambdabot> Title: Chapter4.Regular Expression
23:29:21 <tehgeekmeister> mmorrow: is alex non-greedy in it's matches by default?
23:30:03 <dsrogers> TH esploded my brain tonight.
23:30:16 <mmorrow> i'm somewhat unclear, i'm trying to figure out now
23:30:27 <mmorrow> dsrogers: heh
23:31:50 <mmorrow> ok, got it
23:31:56 <mmorrow> section 3.2.2
23:31:58 <mmorrow> Alex will always find the longest match. For example, if we have a rule that matches whitespace:
23:32:04 <mmorrow> http://haskell.org/alex/doc/html/alex-files.html#rules
23:32:05 <lambdabot> Title: 3.2.Syntax of Alex files
23:32:29 <dsrogers> goodnight everyone.
23:32:48 <mmorrow> then resolution of ambiguity:
23:32:50 <mmorrow> When the input stream matches more than one rule, the rule which matches the longest prefix of the input stream wins. If there are still several rules which match an equal number of characters, then the rule which appears earliest in the file wins.
23:34:45 <mmorrow> so to get the same effect as nongreedy matching, you'll have to  do   [. # \>]*   , which is alex-speak for  [^>]*
23:35:34 <mmorrow> instead of  .*?     (in this case, i'm imagining matching <text ..here.. >)
23:37:53 <gwern> > let strip = reverse . drop 3 . reverse in strip "Tmp.hs"
23:37:55 <lambdabot>  "Tmp"
23:38:02 <gwern> > let strip = reverse . drop 3 . reverse in strip "TmpModule.hs"
23:38:04 <lambdabot>  "TmpModule"
23:38:34 <gwern> > let strip = reverse . drop 3 . reverse in strip "TmpModule.lhs" --oops
23:38:36 <lambdabot>  "TmpModule."
23:40:16 <mmorrow> > let strip = takeWhile (/='.') in strip "TmpModule.lhs"
23:40:19 <lambdabot>  "TmpModule"
23:40:41 <gwern> man, I'd come up with:
23:40:43 <gwern> strip  String  String
23:40:46 <gwern> strip a = reverse $ foo $ reverse a
23:40:47 <mmorrow> heh
23:40:49 <gwern>           where foo ('s':'h':'.':xs) = xs
23:40:53 <gwern>                 foo ('s':'h':'l':'.':xs) = xs
23:41:13 <gwern> are haskell filenames allowed to have .s before the actual suffix?
23:41:27 <mmorrow> i was just trying to think about that
23:41:30 <mmorrow> i think no
23:41:44 <mmorrow> because, a module name in-file can't
23:41:53 <mmorrow> and the filename has to match the module name
23:41:53 <gwern> Foo.Bar.hs == module Foo.Bar == Foo/Bar.hs?
23:42:13 <mmorrow> hmm, i don't think
23:42:26 <mmorrow> one way to find out :)
23:43:16 <gwern> too much work
23:45:07 <tehgeekmeister> mmorrow: back, sorry
23:47:05 * tehgeekmeister wonders why they're called regular expressions when the syntax is in no way standardized across different utlilities/programming languages...
23:47:38 <Trinithis> @seen newsham
23:47:38 <lambdabot> newsham is in #haskell and #haskell-blah. I last heard newsham speak 2h 1m 32s ago.
23:48:41 <mmorrow> tehgeekmeister: heh
23:52:38 <gwern> if I have a case expression in a do, would 'return ()' on a case cause it to error out or anythng?
23:54:37 <gwern> I am trying to figure out how this could possibly throw an exception or something:
23:54:40 <gwern>                                   case lfl of
23:54:43 <gwern>                                      "" -> return ()
23:54:51 <Trinithis> undefined or error "abc"
23:55:00 <|Steve|> > do case Nothing of Nothing -> return (); Just x -> return x
23:55:02 <lambdabot>   add an instance declaration for (Show (t ()))
23:55:17 <Trinithis> _ -> default
23:56:01 <|Steve|> > do case Nothing of Nothing -> return (); Just x -> return x :: IO Int
23:56:02 <Trinithis> is your pattern match exhaustive?
23:56:03 <lambdabot>  Couldn't match expected type `()' against inferred type `Int'
23:56:09 <|Steve|> Oh, bah.
23:56:42 <|Steve|> > do case Nothing of Nothing -> return (); Just x -> putStrLn x
23:56:45 <lambdabot>  Exception: "<IO ()>"
23:56:49 <gwern> hm, using the underscore erases the exception
23:57:03 <Trinithis> What are your pattern cases?
23:57:15 <gwern> ah, so it wasn't matching anything
23:57:23 <gwern> and I guess that throws an exception
23:57:41 * gwern kind of thought the case expression would just do nothing and flow would move on
23:59:30 <Trinithis> yay for _|_
