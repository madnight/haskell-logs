00:00:03 <rwbarton> getPuzzle :: IO [(String, something, something)]
00:00:14 <rwbarton> The compiler can't guess what those something's are, and neither can I :)
00:00:21 <Quadrescence> They should be Ints
00:01:10 <rwbarton> Oh, also "read . wut x m" is wrong, "wut x m" is a value so you want "read (wut x m)"
00:01:36 <Quadrescence> Arg, I always get that wrong.
00:01:56 <rwbarton> You can either write (read (wut x m)) :: Int, or give a type annotation getPuzzle :: IO [(String, Int, Int)]
00:03:19 <Quadrescence> I did the latter.
00:04:38 <dons> here's a rather interesting archive, http://www.macs.hw.ac.uk/~dsg/gph/nofib/
00:04:39 <lambdabot> Title: Glasgow Parallel Haskell Algorithms Repository
00:04:56 <sbahra> cool dons
00:05:24 <dons> a lot of those old programs will likely run out of the box on smp ghc.
00:05:46 <sbahra> dons, how would we know if ghc was compiled with SMP support?
00:06:05 <dons> ghc is by default :)
00:06:06 <sbahra> I think mine is, since I have seen it spike to 100% CPU usage on this dual-core.
00:06:14 <sbahra> dons, figured, ok.
00:06:20 <dons> oh, you have to run parallel programs with +RTS -N2
00:06:23 <dons> to use the extra cores
00:06:30 <sbahra> Oh.
00:06:33 <dons> or some other value than 2, if you've more cores.
00:06:50 <dons> and programs are compiled with the -threaded flag
00:08:36 <slava> dons: shouldn't those be the default?
00:09:11 <dons> -threaded is slated to be the default soon, yes.
00:09:18 <dons> picking the right value of N is harder.
00:09:42 <dons> i think simon's keen to have only -threaded
00:10:26 <bos> can't blame him. maintaining two subtly incompatible runtimes can't be fun.
00:11:03 <bos> on the other hand, the non-threaded RTS is blazingly fast for concurrent operations, and the threaded RTS is much slower.
00:11:16 <dons> yeah, i think that's the main thing staying his hand.
00:11:34 <dons> i'm not sure how the parallel GC tips things
00:11:40 <dons> probably a bit more in favour of -threaded
00:12:25 <bos> of course, the concurrent performance with non-threaded doesn't matter much in practice, since usability for networking apps is hobbled by the use of select in the bowels of the RTS.
00:12:33 <Quadrescence>     Couldn't match expected type `IO [(String, Int, Int)]' against inferred type `[(String, Int, Int)]'
00:12:38 <Quadrescence> Not cool man, not cool.
00:12:56 <slava> return?
00:12:57 <heatsink> Quadrescence, return!
00:13:09 <dons> slava debugs a haskell newbie, awesome.
00:13:17 <dons> ;)
00:13:23 <Quadrescence> Obviously there is something I am not seeing.
00:13:55 <heatsink> You're using some function in IO, so you need to make it an IO computation.
00:14:05 <dons> :t return 'x'
00:14:07 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
00:14:08 <dons> :t 'x'
00:14:09 <lambdabot> Char
00:16:23 <hml> http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast5 looks like a really cool article
00:16:25 <lambdabot> Title: Haskell hacking
00:16:29 <hml> dons: are you the same as the above dones?
00:16:37 <hml> anyone else know of good haskell optimization gujides
00:16:44 <dons> unless don syme switched teams, yes.
00:17:00 <dons> :)
00:17:07 <hml> good article
00:17:28 <dons> what did you learn from it?
00:17:58 <hml> that tail recursion is good; as is strictness in inner loops
00:18:01 <paczesiowa> you're famous:)
00:18:05 <hml> there's this niced summar at the end
00:18:12 <dons> hml, cool. that's a pretty good lesson to take away
00:18:33 <hml> concrning lesson 3
00:18:42 <hml> so ghc currently compiles haskell to C
00:18:46 <hml> then passes it to the c compuiler?
00:18:49 <dons> and to assembly as well.
00:18:53 <dons> but one route is via gcc
00:19:07 <hml> so what's this 'new bleeding edge native code generator' ?
00:19:13 <hml> asm or machine code ?
00:19:20 <luqui> it's not bleeding anymore is it?
00:19:25 <dons> there's a new one, luqui
00:19:28 <luqui> ah
00:19:35 <hml> where cna i read more about this
00:19:48 <hml> (the new backend)
00:19:50 <dons> hmm, the community report had some details, and ghc-cvs has discussion
00:19:55 <dons> but it hasn't be formally released yet
00:20:15 <dons> the existing native code generator you can read about on haskell.org/ghc
00:20:18 <dons> under  the dev wiki
00:21:16 <hml> random thought: so does hasxkell's use of lists help it do bc better?
00:21:26 <hml> since lists tends to have this very 'stream' like interface
00:21:45 <dons> bc?
00:22:07 <dons> lazy lists are the essence of streams, i suppose.
00:22:54 <hml> dunno with some lists operations
00:23:09 <hml> i (naibely) think it should be possible to do reference counting on them at compile time
00:23:36 <hml> i.e. to lsee that list a --f--> list b; but list b isn't used for anythinng else except for listb --g--> list c
00:23:55 <heatsink> you mean, stream fusion? :)
00:23:57 <hml> so as i create list b elements; i can pass it to g; then throw them away?
00:24:06 * hml googles stream fusionn
00:24:35 <heatsink> actually, I think 'deforestation' is the more common term.
00:24:46 <heatsink> Less environmentally friendly though.
00:25:09 <hml> can ppl get a PhD thesis working on thesis these days?
00:25:42 <heatsink> It's hard to get a PhD thesis working on anything else.
00:26:15 <heatsink> ...thesis?
00:26:34 <hml> sorry; phd thesis working on haskell
00:26:54 <adamvo> > pred 1.1
00:26:56 <lambdabot>  0.10000000000000009
00:27:17 <heatsink> adamvo, weird.
00:28:28 <Quadrescence> Here is my not-working source, but this time I commented it up stating what it's supposed to do/what I want. http://hpaste.org/9506
00:28:28 <adamvo> Ord doesn't make that much sense on non-integers
00:28:53 <luqui> hml, ndm is, I know someone locally who is, so I'd say yes
00:29:00 <idnar> @type pred
00:29:01 <lambdabot> forall a. (Enum a) => a -> a
00:29:07 <idnar> > pred 5
00:29:08 <lambdabot>  4
00:29:15 <idnar> oh, I was thinking predicate
00:29:21 <hml> what are the big research problems concerning functional programming / haskell
00:29:22 <adamvo> s/Ord/Enum
00:29:55 <Quadrescence> > pred "heatsink"
00:29:56 <lambdabot>   add an instance declaration for (Enum [Char])
00:29:56 <lambdabot>     In the expression: pred "...
00:30:02 * sbahra thought PHd students working on their thesis do the research first
00:30:21 <Quadrescence> heatsink: I guess nothing precedes you. You must be the lowest of the low. :D
00:30:39 <rwbarton> Quadrescence: you need "IO" before the second [(String, Int, Int)] in the type signature
00:30:48 <Quadrescence> rwbarton: Okay.
00:30:50 <heatsink> Quadrescence, Nothing precedes me because I am first in everything!
00:30:59 <hml> sbahra: i'm a newb to functional programming; and am just trying to understand the field
00:31:13 <adamvo> > fromEnum 4.2
00:31:14 <lambdabot>  4
00:31:32 <sbahra> hml, http://www.haskell.org/, http://scholar.google.com/, ACM, etc.. would be a better first step.
00:31:33 <lambdabot> Title: Haskell - HaskellWiki
00:32:02 <sbahra> hml, you shouldn't expect an objective answer here, because people have different preferences in research. I'm a newbie to functional programming too, I'm just talking about research in general :-)
00:32:12 <idnar> @src length
00:32:12 <lambdabot> Source not found.
00:32:19 <Quadrescence> rwbarton: But, since the function will recur, the second argument's type [(String,Int,Int)] doesn't match IO [(String,Int,Int)]
00:32:26 <idnar> so I'm looking at that blog post by dons again
00:32:50 <idnar> "I've written these in a direct worker/wrapper transformed, recursive style." -- why write it that way instead of "directly" recursing?
00:32:52 <rwbarton> Quadrescence: Oh, also you don't want the "return $"
00:33:15 <Quadrescence> rwbarton: I think that has to do with my lack of understanding of do-blocks.
00:34:47 <idnar> eg. length Empty = 0 ; length Cons _ xs = 1 + length xs
00:34:57 <idnar> er, with some extra () probably
00:35:27 <luqui> Quadrescence, do you know how to convert between do notation and bind notation?
00:35:51 <Quadrescence> luqui: No. :(
00:36:18 <Quadrescence> What is the difference?
00:36:36 <luqui> Quadrescence, do notation is fancy syntax sugar.  bind notation is ordinary haskell (with infix operators)
00:36:38 <dobblego> do notation is "special sugar" that corresponds to bind notation
00:36:46 <rwbarton> Quadrescence: the short-cut rules of thumb are (a) in 'x <- action', x has type a and action has type IO a; (b) if x has type a then 'return x' has type IO a; (c) the type of a do block is the type of its last line
00:36:53 <Quadrescence> luqui: Oh, I am aware of this.
00:37:56 <luqui> rwbarton, hmm, I like that explanation.  Gets you flying quickly.
00:38:34 <ddarius> do-notation is very simple syntactic sugar.
00:38:59 <Quadrescence> rwbarton: As I see it, do-blocks are a sugary way of doing stuff in a procedural fashion.
00:39:08 <heatsink> idnar: There's two things about this transformation.  One is the worker/wrapper transformation, which avoids redundant parameter passing.  The other is that by making the worker tail-call itself, there is no need to build a stack during the recursion.
00:39:45 <idnar> heatsink: oh right, tail calls
00:41:17 <idnar> heatsink: hmm, so can't the compiler do that transformation automatically? ;)
00:41:24 <Quadrescence> I don't quite understand how a value is "returned" to the function (e.g., for | n > 0 = ..., what will the function actually /equal/? Or how do I make it equal what I want in a do-block)
00:41:53 <sbahra> Quadrescence, whatever is after =.
00:42:13 <Quadrescence> sbahra: Right, but if you have a do-block after the = then...
00:42:28 <luqui> Quadrescence, then it's the last thing in the block
00:42:45 <Quadrescence> That's probably what I needed to know.
00:42:45 <rwbarton> A do block is just another kind of expression.  It doesn't actually *do* stuff
00:43:02 <Quadrescence> What is "return" for, then?
00:43:04 <luqui> hmm, good name for it
00:43:09 <luqui> return :: a -> IO a
00:43:17 <sbahra> return :: (Monad m) => a -> m a
00:43:37 <heatsink> rwbarton: be { x <- getLine; putStrLn x }
00:43:50 <luqui> heheh.
00:44:06 * luqui thinks seq might have been a good name for it
00:44:37 <heatsink> That would make backward state monads even more confusing.
00:44:38 <newsham> > return 5 :: [Int]
00:44:40 <lambdabot>  [5]
00:44:43 <newsham> > return 5 :: Maybe Int
00:44:44 <lambdabot>  Just 5
00:44:48 <newsham> > return 5 :: IO Int
00:44:50 <lambdabot>  <IO Int>
00:44:52 <baaba> return is a really poor name imo
00:44:59 <luqui> heatsink, backward state?
00:45:04 <luqui> baaba, agreed
00:45:35 <baaba> i guess it was an attempt at making programmers from imperative languages more comfortable?
00:45:39 <heatsink> luqui: A state monad where each computation sees the state produced by the computation that runs _after_ it.
00:45:51 <baaba> but it seems it kinda backfired :P
00:46:14 <luqui> baaba, what would you call it?
00:46:24 <baaba> unit
00:46:28 <baaba> wrap?
00:46:29 <newsham> pure?
00:46:32 <luqui> pure is good
00:46:33 <baaba> lift?
00:46:41 <baaba> yeah pure would be nice too
00:46:53 <sbahra> baaba, hrm, how would you express some series of functions with no dependency on each other?
00:46:55 * sbahra likes do
00:46:56 * luqui loathes the names "Monad", "unit", etc.
00:47:07 <sbahra> But I'm used to the TLA notion of "actions" now, so do makes sense.
00:47:19 <luqui> mostly because I think category theorists name things poorly
00:47:26 <sbahra> s/no dep/no necessary dep/
00:47:30 <luqui> not because they should be renamed to something more evocative.  just less scary.
00:48:13 <luqui> sbahra, what do you mean?
00:49:01 <newsham> i was a sucker for do-notation when i started.
00:49:08 <Quadrescence> :t getLine
00:49:09 <lambdabot> IO String
00:49:14 <newsham> but i'm coming around to  (.) (>>=) (<$>) and (<*>)
00:49:18 <newsham> much better
00:49:29 <sbahra> luqui, well, in "pure", you have a clearly defined set of dependencies: f(o(o(d(x)))). An "action" in do simply defines a state transition (in my mind, at the least) from sAt (where s is old state, A is the action in do, t is new state)
00:49:35 <newsham> (or =<< for consistent direction)
00:49:43 <baaba> dirty? ;)
00:49:54 <paczesiowa> if smth stopped scaring you, you can always prefix it with "co" and voila - tremble in fear again
00:49:54 <baaba> do { x <- foo; dirty x }
00:50:09 <sbahra> luqui, the dependency isn't necessarily "clear" as purely functional.
00:50:38 <luqui> does this generalize to other monads?
00:50:41 <newsham> func = someact =<< f . g . h <$> someact <*> someact
00:51:12 <sbahra> luqui, I don't know enough about monads to answer this. I'm still new to haskell.
00:52:41 <heatsink> paczesiowa, quite true.
00:52:48 <ddarius> It was designed to mimic imperative notation, but it wasn't designed to make imperative programmers more comfortable.
00:56:20 <Quadrescence> Could someone tell me exactly what x <- getLine means/is doing?
00:56:44 <Zao> It "binds" the result of getLine to x.
00:56:56 <Zao> To simplify it way much.
00:57:20 <baaba> getLine >>= \x -> {- rest of do block -}
00:58:15 <baaba> where >>= for the IO monad takes the left argument which is an IO action and the right argument which is a function that accepts the result of said action, and passes the result
00:58:26 <baaba> (and indeed, for any monad at that)
00:59:48 <Quadrescence> I want to get input from the user at runtime, and store the input as a string to x.
01:00:09 <baaba> that's what it does, sorta :)
01:00:23 <Quadrescence> So, hm.
01:00:26 <baaba> just the way of storing the input to 'x' is not quite your usual assignment, but effectively a callback
01:00:42 <Quadrescence> Right
01:00:46 <baaba> you give your \x -> ... ie. the rest of the do block as a callback to >>=
01:05:04 <Quadrescence> So does x have type IO String?
01:05:17 <baaba> no, x is just String
01:05:30 <paczesiowa> "<-" eats IO
01:05:32 <rwbarton> Quadrescence: by the way, if you're trying to play with something *other* than IO, there are easier ways to do this, using interact and lines and so on
01:05:37 <ddarius> luqui: The names "monad" and "unit" are very sensible in the categorical context.
01:05:45 <baaba> the function on the right side of >>= accepts the result value of the action on the left side
01:05:58 <baaba> hence:
01:05:59 <baaba> :t >>=
01:06:04 <luqui> ddarius, okay, 'splain. why 'unit'?
01:06:06 <Quadrescence> rwbarton: I am just trying to do IO right now.
01:06:07 <baaba> erm, :type?
01:06:21 <baaba> or what as it, i haven't used lambdabot much
01:06:26 <rwbarton> :t (>>=)
01:06:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:06:33 <baaba> ah right :)
01:06:36 <Quadrescence> baaba: infix
01:06:37 <Quadrescence> yeah
01:06:50 <baaba> the (a -> m b) is your \x -> ...
01:07:18 <ayumilove> wow
01:07:20 <ayumilove> many people
01:07:30 <ayumilove> hey guys, when I type #haskell, it leads me to a blank page
01:07:33 * luqui is not playing with backward state, thanks to heatsink
01:07:36 <luqui> *now
01:07:42 <ayumilove> i had to use the "find channels" and type #haskell, then it works
01:08:06 <luqui> ayumilove, /join #haskell?
01:08:08 <baaba> sounds like an issue with your irc client
01:08:12 <baaba> (or your usage of it)
01:08:19 <ayumilove> i tried that but it leads me to a blank page,
01:08:25 <ayumilove> anyways
01:08:30 <ayumilove> good to see humans ^_^
01:08:37 <ddarius> luqui: Because it is the unit of the "multiplication" represented by mu (join).
01:08:40 <baaba> recommend getting an actual client instead of an in-browser one :P
01:08:49 <ayumilove> where to get client?
01:08:52 <luqui> ayumilove, actually, this is the channel where all the robots who have passed the turing test come
01:08:53 <ayumilove> im currently using browser
01:09:00 <sbahra> ayumilove, http://www.xchat.org/
01:09:01 <lambdabot> Title: XChat: Multiplatform Chat Program
01:09:08 <baaba> there's tons available
01:09:11 <ayumilove> hi sbahra
01:09:15 <ddarius> Indeed, a monad is a monoid object in a (endo)functor category and the unit of the monad is the unit of the multiplication.
01:09:19 <jeffz`> mibbit is pretty restrictive, as far as licensing goes... last I checked their license agreement prohibits you from studying the clients source code
01:09:32 <sbahra> ayumilove, I am a computer program written by mux to serve users new to IRC.
01:09:37 <Quadrescence> baaba: Mind taking a look? --> http://hpaste.org/9507
01:09:49 <luqui> ddarius, okay, but that's rather circular.  why 'unit' for multiplication?
01:10:43 <baaba> Quadrescence, you're not passing all the behind-the-scenes stuff of IO into getPuzzle
01:10:51 <rwbarton> The unit of a ring R can be identified with the map Z -> R sending 1 to 1, which is the unit map of R viewed as a monoid object in abelian groups
01:10:59 <ddarius> luqui: It's not circular at all.  Monoids existed before monads and the name unit comes from 1.
01:11:20 <baaba> er sorry, yes you are
01:11:23 <ddarius> The unit of a monoid behaves like 1 does under multiplication.
01:11:41 <ddarius> I don't know where the name "monoid" comes from though.
01:11:50 <baaba> Quadrescence, tell me what you expect the type of getPuzzle to be?
01:11:52 <luqui> Quadrescence, when n == 0, the result of your function is a list, not an IO list
01:11:56 <ddarius> Abstract algebra is full of seemingly meaningless names.
01:12:17 <Quadrescence> luqui: baaba: I want the result to be a list.
01:12:32 <luqui> Quadrescence, that's impossible, since your function is effectful
01:12:37 <rwbarton> Quadrescence: It can't be, because you want to do IO when n > 0
01:12:39 <luqui> only pure functions can return lists :-)
01:12:51 <luqui> (sorry for being so cryptic)
01:13:04 <ayumilove> hey guys, i have installed the xchat, so how do i use that to connect to mibbit?
01:13:08 <baaba> Quadrescence, the do block has to end in an expression of type IO x
01:13:18 <baaba> (which will also be the type of the whole block)
01:13:42 <baaba> so in your case IO [Puzzle] or whatever
01:14:05 <luqui> ddarius, yeah, I guess unit isn't obviously related to 1 to me.  but I will revise my earlier statement:  mathematicians are bad at naming things, since it's probably not possible to be good
01:14:06 <baaba> which means that you have to fix your first case in the match to get 'xs' into IO
01:14:28 <luqui> "mathematics is about giving different things the same name"  -- so what do you call two different things?
01:15:37 <ayumilove> hey guys, i have installed the xchat, so how do i use that to connect to mibbit?
01:15:46 <ayumilove> or connect to this haskell channel
01:15:59 <baaba> you connect to irc.freenode.net
01:16:05 <baaba> which is the server we're on
01:16:17 <baaba> i haven't used xchat but there's probably a tutorial on their site
01:16:30 <ayumilove> the xchat tutorial says connect to oznet
01:16:39 <baaba> connect to freenode instead :)
01:16:46 <ayumilove> ok
01:17:15 <Quadrescence> baaba: This feels contradictory /to me/. x <- getLine. x is a string. Now I pass x into getPuzzle (recursive) and it repeats until n == 0, in which case it "returns" xs, a list.
01:17:24 <ayumilove1> yay im login , thanks baaba
01:17:37 <ayumilove1> wow thats pretty tough for a irc newbie -_-
01:17:41 <baaba> Quadrescence, the thing is that your getPuzzle is also an IO action
01:18:00 <baaba> or rather, must be, because it uses getLine
01:18:06 <ayumilove1> > 1+1
01:18:08 <lambdabot>  2
01:18:19 <baaba> and it also has to have an IO type
01:18:31 <Quadrescence> baaba: So could I separate the IO from the parsing and everything's good? :D
01:18:38 <baaba> sure
01:18:45 <baaba> the quick fix is to insert 'return' in the first case
01:18:53 <baaba> n == 0 = return xs
01:18:58 <Quadrescence> hmm
01:19:16 <baaba> oh, and you'll have to change getPuzzle a bit
01:19:52 <ayumilove1> > map even [1,2[
01:19:52 <lambdabot>  Parse error at end of input
01:19:55 <ayumilove1> > map even [1,2]
01:19:56 <lambdabot>  [False,True]
01:19:59 <baaba> so in the recursive case it gets the value via <- and then concatenates it with xs
01:20:07 <baaba> (and then you return that result)
01:20:29 <baaba> x <- getPuzzle (...) (...); return (x:xs)
01:20:59 <luqui> runRState (mdo { put (x+1); x <- get; return x }) 42 -- > (42,43)
01:21:01 <luqui> my head a splode
01:21:04 <baaba> but yeah separating IO from parsing is probably easier
01:21:17 <hml> this simon  peyton jones guy is pretty cool; this awkward squard paper starts out with my favorite explaination of monads
01:21:31 <hml> just the right amount of technical detail with practical, real world example
01:21:59 <luqui> spj is quite good at explaining things
01:22:22 <Quadrescence> baaba: In BASIC this would just be ... it doesn't even matter. I'll try separating them
01:22:35 <baaba> haha, this isn't quite basic as you may have noticed ;)
01:22:36 <hml> is the type T equiv to () -> T ?
01:22:54 <Quadrescence> baaba: Yes I realized that. :D
01:23:16 <luqui> technically no, hml, but almost
01:23:28 <hml> luqui: can you expand on that?
01:23:32 <baaba> separating them would be a good thing regardless of language though, since then you immediately gain the option of alternative input mechanisms
01:23:38 <luqui> these two functions are different:  tFunc _ = t ; tFunc () = t
01:23:50 <luqui> scuse me, tFunc' () = t
01:24:01 <luqui> because tFunc undefined = t, but tFunc' undefined = undefined
01:24:42 <luqui> intuitively, tFunc' checks that its argument is actually () before returning (because in Haskell, pattern matching is defined to be strict)
01:24:56 <ayumilove1> hey guys, is it possible to use iterate + list to do fibonacci
01:25:01 <rwbarton> @src ()
01:25:02 <lambdabot> data () = ()
01:25:07 <ayumilove1> i want to place the fibonacci numbers into a list
01:25:19 <luqui> ayumilove1, yes
01:25:25 <ayumilove1> generate and place them simultaneously until it reaches nth fibonacci
01:25:36 <ayumilove1> i tried recursion it works o_o
01:25:59 <luqui> ayumilove1, iterate using the function \(x,y) -> (y,x+y)
01:26:01 <luqui> and go from there
01:26:18 <Deewiant> > fix ((0:) . scanl (+) 1)
01:26:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:26:38 <luqui> wow, that's the most concise one I've seen yet
01:26:46 <ayumilove1> i dont understand deewiant code, me newbie
01:27:00 <luqui> ayumilove1, don't worry about it :-)
01:27:43 <rwbarton> It's using a different recurrence for the fibonacci numbers
01:28:31 <Deewiant> > let f = 0 : scanl (+) 1 f in f :: [Expr]
01:28:35 <lambdabot>  [0,1,1 + 0,1 + 0 + 1,1 + 0 + 1 + (1 + 0),1 + 0 + 1 + (1 + 0) + (1 + 0 + 1),1...
01:28:43 <ayumilove1> could someone explain how this iterate works? iterate :: (a -> a) -> a -> [a]
01:28:49 <Deewiant> > iterate (+1) 0
01:28:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:29:04 <ayumilove1> what does (a->a) means?
01:29:19 <Deewiant> a function from type a to a
01:29:32 <ayumilove1> then the next a refers to?
01:29:35 <luqui> ayumilove1, a function that takes a value of a type 'a' and returns a value of that same type.  for example \x -> x+1
01:29:37 <Deewiant> the same a
01:29:46 <rwbarton> the next a is for the initial value
01:30:10 <luqui> iterate f x = [x,f(x),f(f(x)),f(f(f(x))), ...]
01:30:16 <Deewiant> > iterate f x
01:30:17 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
01:30:23 <luqui> haha
01:31:33 <hml> wow, so im on page 8 of hte awkard squard, and it just gets better
01:32:47 <ayumilove1> im stil puzzled with this function (x,y) -> (y,x+y)
01:33:52 <rwbarton> In order to compute the next fibonacci number, you need to know the previous two.  That's why you need to keep a pair
01:33:52 <hml> does the following loko correct?
01:33:54 <hml> putLine :: [Char] -> IO()
01:33:54 <hml> putLine [] = return ()
01:33:54 <hml> putLine (c:cs) = putChar c >> putLine cs
01:34:16 <hml> and that switch of the y into the front is to keep the bigger as the latter and the smaller ikn the front
01:34:21 <rwbarton> If x = f_n and y = f_{n+1}, then y = f_{n+1} and x+y = f_{n+2}
01:34:24 <paczesiowa> hml: ask ghc:)
01:35:03 <ayumilove1> umm my first 2 initial values is 0 and 1
01:35:12 <ayumilove1> iterate (0,1) (0) ?
01:35:51 <Quadrescence> the first argument has to be of type a->a
01:36:14 <Deewiant> > fix ((0:).(1:).ap (zipWith (+)) tail)
01:36:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:36:41 <sbahra> ayumilove1, you should learn about the golden ratio (there is a formula that allows you to find out Fibonacci numbers at O(1))
01:37:01 <sbahra> ayumilove1, but it is dependent on fractionals, iirc, so you will have either precision issues or performance issues.
01:37:03 <hml> hmm, is {} good notation for do, or shoudl i just use pure whitespace
01:37:18 <ayumilove1> iiirc means?
01:37:33 <sbahra> if i recall correctly
01:40:54 <ayumilove1> hmm
01:40:58 <ayumilove1> still can't get it
01:41:17 <TSC> hml: Most people use the layout rule, but some people prefer {;}
01:41:28 <sbahra> ayumilove1, I suggest a good book
01:41:48 <sbahra> ayumilove1, I am currently reading "Haskell: The Craft of Functional Programming" by simon thompson
01:41:58 <sbahra> ayumilove1, you can even download it (illegally) online for free if you're poor.
01:42:38 <luqui> ayumilove1, don't let that suggestion discourage you from asking questions.  we'll do our best to help you.
01:43:08 <Quadrescence> ayumilove1: #haskell is one of the most assisting channels :}
01:43:25 <Quadrescence> That's why they're so easy to troll. :D
01:43:35 <ayumilove1> what is troll?
01:43:40 <Quadrescence> Nothing, nevermind.
01:43:51 * luqui wishes he weren't known, because then he could do
01:43:53 <sbahra> ChanServ is a troll.
01:43:55 <ayumilove1> sbahra what is troll?
01:43:58 <luqui> hey guys, what's a functor?
01:44:26 <ivanm> ayumilove1: a troll is someone who hangs around deliberately provoking arguments, or else trying to spam people with useless garbage
01:44:40 <ayumilove1> thanks ivarm
01:44:42 <ivanm> or else it's a fictional creature from Tolkenesque fantasy
01:44:46 <ivanm> ;-)
01:44:54 <luqui> or something that hangs around under bridges
01:45:08 <ivanm> only if there's goats around though
01:45:23 <luqui> or a small creature with big poofy colorful hair
01:46:57 <Quadrescence> How nice, I just made an equivalent to zipWith. >_>
01:47:15 <Quadrescence> !src zipWith
01:47:30 <Quadrescence> is it `!' ?
01:47:37 <ivanm> luqui: no, that's not trolls...
01:47:45 <ivanm> that's trollz IIRC ;-)
01:47:51 <ivanm> @src zipWIth
01:47:51 <lambdabot> Source not found. You untyped fool!
01:47:55 <ivanm> @src zipWith
01:47:55 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:47:55 <lambdabot> zipWith _ _      _      = []
01:47:58 <luqui> and what is the singular of trollz?
01:48:07 <ivanm> luqui: trollzor? :p
01:48:10 <luqui> haha
01:48:33 * ivanm didn't work out what luqui meant till after he said he was wrong, and is quickly trying to reason why he's right
01:50:05 <luqui> I see
01:50:12 <hml> @src sequence_
01:50:14 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
01:50:14 <luqui> apology accepted.
01:50:15 <luqui> =P
01:50:34 <hml> is the point of implementing sequence_ as foldr rather than foldl so that if i send it to an infinite list, it'll produce output along the way?
01:50:37 <ivanm> @src sequence
01:50:38 <lambdabot> sequence []     = return []
01:50:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:50:38 <lambdabot> --OR
01:50:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:52:21 <ayumilove1> is it possible to use take and interate in winhugs?
01:52:32 <ayumilove1> i mean writing it in notepad and run it using winhugs
01:53:00 <ivanm> don't see why not...
01:53:10 <ayumilove1> i written "take n iterate (x+y)(x)" into notepad, but does not work, it says take not identified
01:53:20 <rwbarton> It should be.  If it's not working, try adding "import List" to the top of your haskell file
01:53:32 <ayumilove1> how do i import? im new to haskell import
01:53:44 <ayumilove1> write on top of all functions?
01:53:50 <rwbarton> Yeah, on the first line
01:54:04 <rwbarton> It shouldn't be necessary though...
01:54:22 <Deewiant> take and iterate are both in the Prelude
01:56:02 <ayumilove1> umm
01:56:09 <ayumilove1> where should i post my notepad codes?
01:56:35 <rwbarton> http://hpaste.org/new
01:56:48 <ayumilove1> thanks rwbarton
01:58:08 <ayumilove1> could someone check for me whats the problem with the code http://hpaste.org/new
01:58:19 <ayumilove1> http://hpaste.org/9508
01:59:18 <rwbarton> First of all, it doesn't know you want 'iterate (x+y) (x)' to be a single argument to take, so you should put parentheses around it
01:59:28 <besiria> why the new http://shootout.alioth.debian.org/u64q/ doesn't include haskell?
01:59:29 <lambdabot> Title: x64 Ubuntu : Intel® Q6600® Computer Language Benchmarks Game
02:00:05 <ayumilove1> you mean like this? iterate ((x+y)(x)) ?
02:00:18 <rwbarton> No, I mean take n (iterate (x+y) x)
02:00:44 <rwbarton> Second, the first argument to iterate needs to be a function.  x+y isn't a function
02:02:02 <Quadrescence> How do I write a function in lambda notation taking two arguments?
02:02:03 <ayumilove1> so i need to make a new function? like abc = x+y ?
02:02:12 <Deewiant> Quadrescence: \x y -> x+y
02:02:18 <Quadrescence> easy as pie
02:03:31 <rwbarton> ayumilove1: I'm not sure how you're expecting this to work.  Here's what iterate does:
02:03:34 <rwbarton> > iterate f x
02:03:36 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
02:03:53 <rwbarton> How can you choose x and f so that this is related to the fibonacci numbers?
02:04:17 <ayumilove1> i seen an example it says iterate (+1)(0) so i should put +(x+y) ?
02:05:11 <hml> wow, the counter of number of chars written on page 13 of awkward s1uard is awesome
02:05:15 <Quadrescence> :t foldl
02:05:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:05:53 <rwbarton> So (+1) means \x -> x + 1 -- the function that adds 1 to a value
02:06:06 <rwbarton> What are x and y supposed to be in "+(x+y)"?
02:06:26 <ayumilove1> what do you mean rwbarton?
02:06:36 <rwbarton> OK, I'm being a little difficult here
02:06:47 <rwbarton> You can't find f and x such that iterate f x = [0, 1, 1, 2, 3, 5, ..]
02:07:00 <rwbarton> What you can do is find f and x such that iterate f x = [(0, 1), (1, 1), (1, 2), (2, 3), (3, 5), ...]
02:07:13 <rwbarton> that's what I was trying to say before about remembering two values of the sequence at a time
02:07:45 <idnar> @type catMaybes
02:07:45 <lambdabot> forall a. [Maybe a] -> [a]
02:07:48 <idnar> @src catMaybes
02:07:49 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:07:52 <ayumilove1> sorry I don;t get you >.<
02:07:52 <idnar> hmm
02:07:54 <idnar> @type mconcat
02:07:55 <lambdabot> forall a. (Monoid a) => [a] -> a
02:08:09 <rwbarton> Clearly x = (0, 1); so you just need to write f such that f (0, 1) = (1, 1), f (1, 1) = (1, 2), f (1, 2) = (2, 3), f (2, 3) = (3, 5), etc.
02:08:12 <ayumilove1> you can't find f and x but i can find f and x ?
02:08:14 <idnar> @type msum
02:08:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:08:21 <rwbarton> What?
02:08:28 <idnar> isn't there a generalised form of catMaybes?
02:08:28 <rwbarton> I wrote two different things at the end of those two lines
02:08:41 <sbahra> fib n = floor (gold^n / sqrt(5) + 0.5) where gold = (1 + sqrt(5)) / 2
02:08:55 <glguy> > msum [Just 1, Nothing, Just 2]
02:08:56 <lambdabot>  Just 1
02:09:04 <glguy> not quite :)
02:09:08 <idnar> @hoogle [m a] -> [a]
02:09:09 <lambdabot> Prelude.tail :: [a] -> [a]
02:09:09 <lambdabot> Prelude.init :: [a] -> [a]
02:09:09 <lambdabot> Prelude.reverse :: [a] -> [a]
02:11:38 <ayumilove1> rwbarton, sorry I still don't understand what you are trying to say with the f(0,1) = (1,1)
02:11:44 <Quadrescence> sbahra: [fib x|x <- [1..10]]
02:11:48 <Quadrescence> winnar :D
02:11:57 <Deewiant> > let f (0,1) = (1,1) in f (0,1)
02:11:58 <lambdabot>  (1,1)
02:12:08 <rwbarton> I can't tell where you're stuck, sorry
02:12:18 <Quadrescence> rwbarton: I'm sure it's with the notation
02:12:31 <Quadrescence> I think ayumilove1 thinks f is taking two arguments
02:13:04 <Quadrescence> Since in math, f(x,y) means x and y are separate parameters for f
02:13:21 <ayumilove1> http://hpaste.org/9508#a1
02:13:32 <ayumilove1> i done some correction with the code, and it works
02:14:05 <rwbarton> It gives [0,1,2,3,4,5,...] right?
02:14:06 <Quadrescence> ayumilove1: In math, we write f(x,y) for a function of x and y. In haskell, we write f x y (or, if x and y are complicated expressions, f (x) (y))
02:14:55 <rwbarton> I think part of the problem is that in ayumilove1's example "iterate (+1) 0", (+1) is written without lambda notation
02:15:02 <ayumilove1> rwbarton, yeah, it gives that
02:15:26 <hml> hmm, why do people insist on using unsafePerformIO so much?
02:15:36 <hml> what's wrong with having the IO tag around?
02:15:37 <Quadrescence> rwbarton: I actually think (+1) is clearer for the non-mathematicians.
02:16:17 <rwbarton> Well, (+1) looks slightly "magical" ... and (+(x+y)) is clearly hoping for some deep kind of magic :)
02:16:44 <ayumilove1> i just place a + sign there hoping it would work, and it works, just recalled something that rwbarton said, function,
02:16:52 <Quadrescence> rwbarton: hahahah
02:17:14 <ayumilove1> yesterday, a good haskel helper thought be about filter and function
02:17:23 <rwbarton> ayumilove1: maybe there's an easier way to approach this
02:17:28 <ayumilove1> is it?
02:17:31 <idnar> Quadrescence: map fib [1..10] :P
02:17:47 <Quadrescence> idnar: list comprehension looks neater. :D
02:17:51 <rwbarton> ayumilove1: Let's try to write a function fib x y = [x, y, x+y, y+(x+y), ...] that is it's like a fibonacci sequence except it starts with x, y instead of 0, 1
02:17:56 <rwbarton> Ok?
02:18:09 <idnar> Quadrescence: it looks more obscure to me
02:18:15 <idnar> Quadrescence: (also it's more typing)
02:18:23 <Quadrescence> idnar: To the mathematician it looks neater. :<
02:18:33 <idnar> Quadrescence: clearly I'm not a mathematician
02:18:37 <Quadrescence> Haha
02:18:40 <Quadrescence> Neither am I
02:18:43 <idnar> Quadrescence: I think the irony here is that in Python, I would use a list comprehension instead of map()
02:18:56 * sbahra likes the book he is reading because you end up re-implementing things like iterate, map, etc...
02:19:02 <idnar> and I'm not sure I can coherently explain why
02:19:24 <idnar> I guess it's because you would usually need a lambda in python
02:20:08 <olsner> yeah, lambdas seem overly verbose in python
02:20:33 <idnar> well, I'd probably use a list comprehension instead of a lambda in Haskell, too
02:21:04 <idnar> [foo x + 5 | x <- xs] seems nicer than map (\x -> foo x + 5) xs
02:21:05 * luqui too.  I only use maps when the function has a nice pointfree form
02:21:27 <idnar> but map(lambda x: foo(x) + 5, xs) is definitely awful compared with [foo(x) + 5 for x in xs]
02:21:35 <idnar> even worse
02:21:57 <olsner> if the function you apply is just a simple pointfree expression, all you're doing with a list comprehension is adding points
02:21:59 <idnar> map(lambda x: foo(x) + 5, filter(lambda x: bar(x) < 5, xs)) compared with [foo(x) + 5 for x in xs if bar(x) < 5]
02:22:09 <idnar> olsner: yeah
02:22:26 <luqui> idnar, is that even right?  doesn't it need to be map((lambda x: foo(x) + 5), xs) to keep it from tupling?
02:22:40 <luqui> (not sure, haven't done much python)
02:23:08 <idnar> luqui: no, if you want a tuple in a lambda "body", you need () around the tuple
02:23:16 <olsner> I think lambdas bind closer than argument-list commas
02:23:18 <hml> i'm baffled by this:
02:23:19 <hml>   trace :: String -> a -> a
02:23:24 <hml>   trace s x = unsafePerformIO (putStrLn s >> return x)
02:23:25 <luqui> ok.
02:23:27 <olsner> hml: magic :D
02:23:29 <hml> so the point is that instead of writing x, which would only give the value of x,
02:23:32 <idnar> >>> lambda x: 5, 6
02:23:32 <idnar> (<function <lambda> at 0x7fb8ec3f68c0>, 6)
02:23:33 <hml> i wrote trace s x
02:23:48 <hml> so in addition to returning the value of x
02:23:54 <hml> it also prints out s ?
02:24:01 <lispy> hml: yes
02:24:09 <rwbarton> s will be printed the first time the value of x is demanded
02:24:10 <lispy> hml: it has a side-effect
02:24:12 <olsner> @quote trace
02:24:13 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
02:24:16 <sbahra> Why is id useful?
02:24:47 <luqui> > let countTrue = length . filter id in countTrue [True,False,False,True,True,False,True]
02:24:48 <lambdabot>  4
02:24:54 <lispy> sbahra: why is 0 useful in the presence of (+) ?
02:24:56 * rwbarton was also about to write "length . filter id" :)
02:25:00 <hml> i don't see why trace would increase productivity, lol
02:25:12 <idnar> what's the point of filter id?
02:25:12 <olsner> useful debugging tool
02:25:17 <Quadrescence> sbahra: When a function requires another function, but you just want a value, you use id
02:25:24 <idnar> oh right, I see
02:25:31 <idnar> I was thinking map id
02:25:33 * hml writes (1) flawless haskell code and (2) haskell code that doesnt compile
02:25:42 <luqui> sbahra, id gets more and more useful as you write more abstract code
02:25:48 * lispy tries to darcs get cabal-install and notices that it's taking way too long.  What's up with darcs.haskell.org?
02:25:52 <olsner> hml: what other kinds of haskell code are there? :P
02:26:05 <idnar> I guess the main thing about id is that it's useful if you need it :P
02:26:10 <luqui> sbahra, because it is more mathematically important than practically important
02:26:32 <thoughtpolice> lispy: it's finnicky it seems. it can take a while for e.g. ./darcs-all to run (if it even finishes, ever) in the GHC HEAD
02:26:33 <ayumilove1> brb taking a break from fibonacci
02:27:27 <olsner> thoughtpolice: shouldn't it be zomg fast now that you've switched ghc over to git? or maybe the switchover is still in-progress
02:27:37 <thoughtpolice> olsner: darcs is still required
02:27:45 <thoughtpolice> ghc switched over to git
02:27:48 <thoughtpolice> not all the libraries
02:27:55 <olsner> aah
02:27:57 <lispy> It's not darcs
02:28:04 <lispy> It's that darcs.haskell.org is being flaky
02:28:04 <Quadrescence> sbahra: If I have f :: (Int -> Int) -> Int, or something, the (Int -> Int) probably signifies some function. If I already know the value, let's say v, of this function, then I can pass `id v' into it.
02:28:27 <idnar> so they already switched?
02:28:42 <lispy> idnar: not officialy, but I think someone put up a mirror
02:28:51 <thoughtpolice> they haven't made the official switch
02:28:57 <thoughtpolice> it's going to happen sometime before 6.10
02:28:59 <lispy> idnar: a swich is planned in about 4-5 weeks though
02:29:03 <thoughtpolice> right now there's a mirror on darcs.haskell.org
02:29:05 <thoughtpolice> and github
02:29:33 <thoughtpolice> which are updated auto-magically
02:29:34 <paczesiowa> Quadrescence: don't you mean const
02:29:35 * idnar takes a bash at Project Euler 23 again
02:29:55 <Quadrescence> paczesiowa: Maybe. I'm pretending I know what I'm talking about.
02:30:06 <thoughtpolice> lispy: imo the actual server probably has something to do with it; many times when I grab stuff it can go super fast (that goes for ./darcs-all too)
02:30:10 <thoughtpolice> other times it slows to a crawl
02:30:13 <idnar> const is sort of the opposite of id
02:30:19 <lispy> thoughtpolice: right
02:30:47 <idnar> @type swap id
02:30:47 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
02:31:02 <idnar> uhm
02:31:12 <paczesiowa> id is useful to write constrained versions of id
02:31:24 <lispy> :t id id
02:31:25 <lambdabot> forall a. a -> a
02:31:26 <sioraiocht> :t flip id
02:31:26 <lambdabot> forall b c. b -> (b -> c) -> c
02:31:29 <idnar> flip!
02:31:31 <luqui> Quadrescence, yeah, id v == v, so you probably didn't mean that
02:31:32 <idnar> that's the one I wanted
02:31:36 <sioraiocht> :)
02:31:56 <ayumilove1> rwbarton I think part of the problem is that in ayumilove1's example "iterate (+1) 0", (+1) is written without lambda notation
02:32:02 <Quadrescence> luqui: Probably not. I know what I mean, I just can't put it into words. :>
02:32:10 <ayumilove1> what do you mean by lambda notation?
02:32:11 <paczesiowa> > let id' = id :: Num a => a -> a in id' 2
02:32:12 <lambdabot>  2
02:32:17 <paczesiowa> > let id' = id :: Num a => a -> a in id' ""
02:32:18 <lambdabot>   add an instance declaration for (Num [Char])
02:32:18 <lambdabot>     In the expression: let id'...
02:32:19 <rwbarton> ayumilove1: \x -> x + 1
02:32:26 <idnar> @unpl flip id
02:32:26 <lambdabot> (\ b c -> c b)
02:32:28 <thoughtpolice> ayumilove1: for example, f = \x -> x*2
02:32:43 <luqui> > flip id 1 (+1)
02:32:44 <lambdabot>  2
02:32:46 <lispy> man, cabal-install should come bundled with its deps for easy bootstrapping
02:33:06 <thoughtpolice> lispy: that would be pretty nice.
02:33:20 <ayumilove1> what does the slash do? before the x >>> example: \x
02:33:24 <luqui> @unpl (+1)
02:33:24 <lambdabot> (\ a -> a + 1)
02:33:34 <thoughtpolice> imo cabal-install needs to come with GHC, it's just a matter if HQ wants to include zlib and http in source
02:33:43 <rwbarton> "\x -> x + 1" means "the function which takes an argument x and returns x + 1"
02:33:54 <thoughtpolice> ayumilove1: it's what makes it a 'lambda'
02:33:59 <thoughtpolice> a lambda abstraction like that is a function
02:34:13 <thoughtpolice> you can think of the \ as saying "it takes the parameters" and the -> designating the actual function
02:34:24 <rwbarton> Right, \ is supposed to resemble the Greek letter lambda (λ)
02:34:27 <sioraiocht> > (\x -> x + 1) 4
02:34:28 <lambdabot>  5
02:34:55 <Quadrescence> I think I might try project euler to get better with haskell
02:35:07 <Botje> please do :)
02:35:12 <Botje> i've learned a lot that way
02:35:16 <thoughtpolice> in the very very very very few problems I did
02:35:27 <thoughtpolice> I found you can come up with some pretty nice solutions, many very elegant
02:36:12 <Quadrescence> Maybe I'll start with #201
02:36:14 <Quadrescence> :}
02:36:30 <thoughtpolice> Quadrescence: one way I like to think I've gotten better, is taking every little misc. piece of code I find and running it, modifying it, examining it, etc. etc.
02:36:47 <thoughtpolice> my ~/code/haskell/misc directory has a bunch of random stuff in there I've collected :)
02:36:58 <Quadrescence> :))
02:37:15 <ayumilove1> what is the full link for this? ~/code/haskell/mis
02:37:16 <idnar> man, what the *hell*; I just read http://www.haskell.org/haskellwiki/Talk:Euler_problems
02:37:17 <lambdabot> Title: Talk:Euler problems - HaskellWiki
02:37:18 <Quadrescence> I was playing with GHCi a little earlier, because I was frustrated with my program I'm working on.
02:37:40 <thoughtpolice> ayumilove1: it's on my computer
02:38:04 <ayumilove1> oh ok, thanks thoughtpolice and rwbarton for the lambda explanation :D newbie-friendly
02:38:15 <thoughtpolice> np
02:38:18 <Quadrescence> idnar: what?
02:38:46 <thoughtpolice> hehe, that dir has everything in there though from sorting stuff to things that make GHC mad, like rwbarton's generics code that can't compile
02:39:10 <thoughtpolice> i pifler from everywhere. :)
02:39:10 <idnar> Quadrescence: I'm just boggling at all the comments going "OMG YOU ARE RUINING PROJECT EULER FOR EVERYONE DELETE THESE PAGES *NOW*!#%!#%!#%"
02:39:43 <rwbarton> thoughtpolice: my what? :)
02:39:45 <dobblego> haha, is that still going?
02:40:00 <thoughtpolice> rwbarton: you were the one with the generics code that exposed a bug in 6.8.3's code generator weren't you?
02:40:02 <Quadrescence> idnar: Silly.
02:40:12 <rwbarton> uh... not that I recall :P
02:40:36 <thoughtpolice> hm must've mistaken names :p
02:40:44 <Quadrescence> idnar: If someone doesn't want PE to be spoiled for him/herself, then he/shouldn't be looking online.
02:40:46 <idnar> maybe I should just give up on Project Euler, though; it seem to be a lot more about maths than programming
02:41:44 <Quadrescence> idnar: Give me an example problem that seems too "mathy"
02:42:04 <DrSyzygy> I think the people who complain don't do it because they might be spoiled, but because the publication disrupts the Project Euler subculture.
02:42:09 <ayumilove1> <rwbarton> ayumilove1: Let's try to write a function fib x y = [x, y, x+y, y+(x+y), ...] that is it's like a fibonacci sequence except it starts with x, y instead of 0, 1
02:42:09 <ayumilove1> <rwbarton> Ok?
02:42:16 <idnar> Quadrescence: well, for example, I'm on problem 23 at the moment
02:42:19 <ayumilove1> write a new function?
02:42:22 <ayumilove1> o_o
02:42:34 <DrSyzygy> And I can believe and agree with that - I'm not certain that I think it merits striking it from the HaskellWiki though...
02:43:03 <rwbarton> ayumilove1: It'll be easier
02:43:24 <Quadrescence> DrSyzygy: Disrupts the subculture? How?
02:43:26 <idnar> Quadrescence: I don't see any way to solve it in a reasonable amount of time given the knowledge I have of the mathematical properties of abundant numbers (that is to say, basically nothing)
02:43:27 <ayumilove1> could you guide me on how to write that?
02:43:42 <rwbarton> OK.  Do you know about the : operator?
02:43:47 <rwbarton> > 3 : [4,4,4,4,4]
02:43:49 <lambdabot>  [3,4,4,4,4,4]
02:43:59 <DrSyzygy> Quadrescence: Because it opens up for people to "solve by search engine", thus making "being able to solve" and thus getting access to the solution forum less of an exclusive action.
02:44:06 <Quadrescence> idnar: Since they define what an abundant number is, they probably assume you don't know any properties.
02:44:25 <idnar> Quadrescence: they define what it is, yes, but that's not enough to limit the problem space
02:44:33 <idnar> Quadrescence: I dunno, maybe I'm just missing something here
02:44:36 <Quadrescence> Let me read it in full.
02:44:59 <ayumilove1> yeah i know about that, basics ^_^ like 3:4:4 = [3,4,4]
02:45:08 <DrSyzygy> > 3:4:4
02:45:09 <lambdabot>   add an instance declaration for (Num [t])
02:45:09 <Heffalump> no, 3:4:4:[] = [3,4,4]
02:45:10 <idnar> Quadrescence: but I implemented a "brute-force" solution that doesn't take into account any mathematical knowhow, and it wasn't going to run to completion any time soon
02:45:14 <DrSyzygy> Thought so.
02:45:51 <rwbarton> OK.  So we want fib x y to return a list that starts with x, so let's begin by writing   fib x y = x : ...
02:46:08 <ayumilove1> the weird thing is i could not put the number 3 at the back of the other number in the list (example: 3:4:4:[] -> [4,4,3]
02:46:33 <ayumilove1> fib x y = x : ... ok
02:46:35 <idnar> > 3:4:4:[]
02:46:37 <lambdabot>  [3,4,4]
02:46:38 <rwbarton> (Why is that weird?  3:4:4:[] can't be both [3,4,4] and [4,4,3])
02:46:51 <ayumilove1> the order of the number o_o
02:47:26 <rwbarton> OK.  So what do we know about what's supposed to go in the ...?  It's supposed to be another fibonacci-like sequence, but it starts with different values
02:47:52 <ayumilove1> yeah
02:48:09 <ayumilove1> it would keep adding the 2 numbers together
02:48:10 <Quadrescence> idnar: Have you discounted prime numbers?
02:48:13 <rwbarton> So, we just need an appropriate call to fib
02:48:26 <ayumilove1> ok
02:48:26 <rwbarton> what are the first two numbers of the rest of the sequence?
02:48:28 <DrSyzygy> ayumilove1: Try something like > let (.:.) a as = as ++ [a]
02:48:45 <ayumilove1> the first 2 numbers 0 and 1?
02:48:45 <DrSyzygy> No guarantees for efficiency.
02:49:06 <rwbarton> No, I mean we want fib x y = [x, y, x+y, y+(x+y), ...]
02:49:24 <rwbarton> And we want to write that as x : fib (...) (...)
02:49:48 <ayumilove1> oh
02:50:13 <sioraiocht> let fib x y = x : y : zipWith (+) tail fib in fib
02:50:24 <sioraiocht> let fib x y = x : y : zipWith (+) tail fib in fib 1 1
02:50:24 <rwbarton> sioraiocht: I don't think this is helpful :P
02:50:25 <Botje> fib x y = x : fib y (x+y)
02:50:28 <Botje> yay!
02:50:36 <rwbarton> Botje: yes, I know *you* know :P
02:50:36 <pozic> Is there anyone who used HList? The Hackage package does not export firstLabel so the examples from the paper also don't work.
02:50:56 <sioraiocht> rwbarton: then I don't understand h the problem, i guess?
02:51:14 <rwbarton> sioraiocht: The problem is that ayumilove1 is trying to figure out how to do this, not me :)
02:51:28 <ayumilove1> fib x y = x : fib y (x+y) how does this work o_o ?
02:52:07 <luqui> ayumilove1, you can expand it yourself
02:52:10 <pozic> ayumilove1: plug in some numbers and try it.
02:52:14 <ayumilove1> ok
02:52:33 <ayumilove1> fib 0 1 = 1 : fib 1 (0+1)
02:52:49 <sioraiocht> rwbarton: ohhh, okay
02:52:57 <rwbarton> sioraiocht: np
02:53:02 <luqui> ayumilove1, not quite =P
02:53:17 <ayumilove1> >.< ???
02:53:25 <luqui> ayumilove1, fib 0 1 = 0 : fib 1 (0+1)
02:53:28 <sioraiocht> wow, my solution is SLOW
02:54:10 <luqui> sioraiocht, I'm guessing you implemented the zip solution, but put it in a function so it doesn't memoize...
02:54:28 <sioraiocht> luqui: yeah
02:54:28 <ayumilove1> luqui, fib 0 1 = 0 : fib 1 (0+1) isnt that same like mine?
02:54:54 <luqui> you said 1 : ...
02:55:02 <luqui> minor error
02:55:15 <ayumilove1> oh haha
02:55:20 <ayumilove1> ok ok newbie mistake ^_^
02:55:29 <pozic> ones and zero all the same, except to a computer ;)
02:55:34 <pozic> zeros*
02:55:40 <ayumilove1> how do i make the font size of my xchat become bigger?
02:55:49 <ayumilove1> its too small, straining the eyes
02:56:21 <luqui> right click -> settings
02:56:25 <cjs> It seems odd to me that there's a liftIO, but no liftError :: (Error l, Monad m) => Either l r -> ErrorT l m r
02:57:04 <luqui> yeah, that would be a useful function I think...
02:57:11 <ayumilove1> thanks luqui
02:57:16 <ayumilove1> now its much better =D, big fonts
02:58:28 <ayumilove1> fib 0 1 = 0 : fib 1 (0+1), if the user wants Nth Fibonacci number, so how do i stop the loop
02:58:42 <ayumilove1> it will keep going on and on right o_o
02:58:50 <Deewiant> > [5,6,7,8] !! 2
02:58:51 <lambdabot>  7
02:58:57 <Botje> you just index the list it generates
02:59:05 <sioraiocht> take 5 [1..10]
02:59:05 <Botje> if you don't ask for the rest it won't make it
02:59:16 <sioraiocht> > take 5 [1..10]
02:59:17 <lambdabot>  [1,2,3,4,5]
02:59:23 <rwbarton> > [0..]
02:59:24 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:59:28 <rwbarton> > [0..] !! 123
02:59:29 <lambdabot>  123
02:59:33 <ayumilove1> what does the !! exclamation mark do
02:59:43 <luqui> it's just list index
02:59:55 <sioraiocht> [0..] !! 0
02:59:57 <Deewiant> (list !! n) takes the nth element of list, starting from 0
02:59:58 <sioraiocht> > [0..] !! 0
02:59:59 <luqui> > [5,6,2,4,5,7] !! 3  -- the 3rd (0-based) element
02:59:59 <lambdabot>  0
03:00:00 <lambdabot>  4
03:01:17 <ayumilove1> ok thanks luqui for explaining =D
03:01:18 <wolverian> it's !! because the operation is O(n), i.e. slow :)
03:01:24 <wolverian> (it's a warning!)
03:01:52 <opqdonut> yeah :)
03:02:00 <Botje> ayumilove1: have you read through YAHT or somesuch?
03:02:09 <ayumilove1> what is a yaht?
03:02:15 <Botje> @where yaht
03:02:15 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
03:02:17 <opqdonut> it's !! so that you'd ask what ! is
03:02:17 <ivanm> Yet Another Haskell Tutorial
03:02:27 <Botje> it's a good starting point to learn haskell
03:03:34 <ayumilove1> thanks botje
03:04:15 <ayumilove1> >
03:04:15 <ayumilove1> fib x y = x : fib y (x+y)
03:04:56 <ayumilove1> i place this code
03:04:56 <ayumilove1> fib x y = x : fib y (x+y) into my notepad and ran it, it loops non-stop o_o
03:05:11 <luqui> printing larger and larger numbers I suspect
03:05:14 <ayumilove1> do i need to create another function to stop it
03:05:14 <rwbarton> Yes, but it produces output right?
03:05:18 <ayumilove1> yeah
03:05:24 <Botje> ayumilove1: well, what did you expect?
03:05:24 <lemming5120> Hey you are English ??
03:05:24 <agh5147> Hey you are English ??
03:05:24 <agh9082> Hey you are English ??
03:05:24 <agh7361> Hey you are English ??
03:05:24 <lemming8790> Hey you are English ??
03:05:25 <agh6642> Hey you are English ??
03:05:25 <lemming5548> Hey you are English ??
03:05:25 <agh4771> Hey you are English ??
03:05:25 <agh189> Hey you are English ??
03:05:25 <lemming8845> Hey you are English ??
03:05:25 <lemming6836> Hey you are English ??
03:05:25 <lemming8886> Hey you are English ??
03:05:25 <lemming5120> Hey you are English ??
03:05:25 <agh9082> Hey you are English ??
03:05:25 <agh5147> Hey you are English ??
03:05:25 <lemming8790> Hey you are English ??
03:05:25 <lemming5548> Hey you are English ??
03:05:26 <agh6642> Hey you are English ??
03:05:26 <agh7361> Hey you are English ??
03:05:26 <agh4771> Hey you are English ??
03:05:26 <agh189> Hey you are English ??
03:05:26 <lemming8845> Hey you are English ??
03:05:26 <lemming6836> Hey you are English ??
03:05:26 <lemming8886> Hey you are English ??
03:05:26 <agh9082> Hey you are English ??
03:05:26 <lemming5120> Hey you are English ??
03:05:26 <agh5147> Hey you are English ??
03:05:26 <lemming8790> Hey you are English ??
03:05:26 <lemming5548> Hey you are English ??
03:05:27 <lemming8845> Hey you are English ??
03:05:27 <agh189> Hey you are English ??
03:05:27 <lemming8886> Hey you are English ??
03:05:27 <agh4771> Hey you are English ??
03:05:27 <lemming6836> Hey you are English ??
03:05:27 <agh6642> Hey you are English ??
03:05:27 <agh9164> Hey you are English ??
03:05:27 <agh9164> Hey you are English ??
03:05:27 <agh9164> Hey you are English ??
03:05:27 <lemming5120> Hey you are English ??
03:05:27 <agh9082> Hey you are English ??
03:05:27 <agh9082> Hey you are English ??
03:05:27 <agh5147> Hey you are English ??
03:05:27 <agh5147> Hey you are English ??
03:05:27 <lemming5120> Hey you are English ??
03:05:27 <lemming8790> Hey you are English ??
03:05:27 <lemming8790> Hey you are English ??
03:05:27 <lemming5548> Hey you are English ??
03:05:28 <agh5147> Hey you are English ??
03:05:28 <lemming5120> Hey you are English ??
03:05:28 <agh9082> Hey you are English ??
03:05:28 <lemming8790> Hey you are English ??
03:05:28 <lemming5120> Hey you are English ??
03:05:28 <agh5147> Hey you are English ??
03:05:28 <agh9082> Hey you are English ??
03:05:28 <agh189> Hey you are English ??
03:05:28 <lemming8845> Hey you are English ??
03:05:28 <lemming6836> Hey you are English ??
03:05:28 <lemming8886> Hey you are English ??
03:05:28 <lemming8790> Hey you are English ??
03:05:28 <lemming5548> Hey you are English ??
03:05:28 <lemming5548> Hey you are English ??
03:05:28 <lemming5548> Hey you are English ??
03:05:28 <agh4771> Hey you are English ??
03:05:28 <agh189> Hey you are English ??
03:05:28 <agh189> Hey you are English ??
03:05:28 <agh189> Hey you are English ??
03:05:28 <lemming8845> Hey you are English ??
03:05:28 <lemming8845> Hey you are English ??
03:05:28 <lemming8845> Hey you are English ??
03:05:28 <lemming8886> Hey you are English ??
03:05:28 <lemming8886> Hey you are English ??
03:05:28 <lemming8886> Hey you are English ??
03:05:28 <lemming6836> Hey you are English ??
03:05:28 <lemming6836> Hey you are English ??
03:05:28 <lemming6836> Hey you are English ??
03:05:28 <agh4771> Hey you are English ??
03:05:28 <agh4771> Hey you are English ??
03:05:28 <agh4771> Hey you are English ??
03:05:30 <agh9663> Hey you are English ??
03:05:30 <agh9663> Hey you are English ??
03:05:30 <agh9663> Hey you are English ??
03:05:30 <agh9663> Hey you are English ??
03:05:31 <agh9663> Hey you are English ??
03:05:31 <luqui> oh my
03:05:32 <lemming5120> Hey you are English ??
03:05:32 <agh9082> Hey you are English ??
03:05:32 <agh5147> Hey you are English ??
03:05:32 <agh5147> Hey you are English ??
03:05:32 <agh9082> Hey you are English ??
03:05:32 <lemming8790> Hey you are English ??
03:05:32 <lemming5120> Hey you are English ??
03:05:32 <lemming8790> Hey you are English ??
03:05:32 <agh7361> Hey you are English ??
03:05:32 <agh7361> Hey you are English ??
03:05:32 <agh7361> Hey you are English ??
03:05:32 <agh7361> Hey you are English ??
03:05:32 <agh7361> Hey you are English ??
03:05:33 <Botje> wtf
03:05:33 <agh4771> Hey you are English ??
03:05:33 <agh189> Hey you are English ??
03:05:33 <lemming8845> Hey you are English ??
03:05:33 <lemming6836> Hey you are English ??
03:05:33 <lemming8886> Hey you are English ??
03:05:33 <lemming5548> Hey you are English ??
03:05:33 <lemming5548> Hey you are English ??
03:05:33 <lemming8845> Hey you are English ??
03:05:33 <agh189> Hey you are English ??
03:05:33 <lemming8886> Hey you are English ??
03:05:33 <agh5147> Hey you are English ??
03:05:33 <lemming5120> Hey you are English ??
03:05:33 <agh9082> Hey you are English ??
03:05:33 <lemming5548> Hey you are English ??
03:05:33 <lemming8790> Hey you are English ??
03:05:33 <agh9663> Hey you are English ??
03:05:33 <agh7361> Hey you are English ??
03:05:33 <agh4771> Hey you are English ??
03:05:33 <lemming6836> Hey you are English ??
03:05:34 <luqui> chanserv!!!
03:05:34 <agh4771> Hey you are English ??
03:05:34 <agh189> Hey you are English ??
03:05:34 <lemming8845> Hey you are English ??
03:05:34 <lemming6836> Hey you are English ??
03:05:34 <lemming8886> Hey you are English ??
03:05:35 <agh5147> Hey you are English ??
03:05:35 <agh9082> Hey you are English ??
03:05:35 <lemming5120> Hey you are English ??
03:05:35 <lemming8790> Hey you are English ??
03:05:35 <agh9663> Hey you are English ??
03:05:35 <agh7361> Hey you are English ??
03:05:35 <lemming5548> Hey you are English ??
03:05:36 <agh4771> Hey you are English ??
03:05:36 <agh189> Hey you are English ??
03:05:36 <lemming8845> Hey you are English ??
03:05:36 <lemming6836> Hey you are English ??
03:05:36 <lemming8886> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <lemming5120> Hey you are English ??
03:05:37 <agh9082> Hey you are English ??
03:05:37 <agh5147> Hey you are English ??
03:05:37 <agh6642> Hey you are English ??
03:05:37 <agh9164> Hey you are English ??
03:05:37 <agh9663> Hey you are English ??
03:05:37 <agh7361> Hey you are English ??
03:05:37 <lemming5548> Hey you are English ??
03:05:39 <agh9164> Hey you are English ??
03:05:39 <agh7361> Hey you are English ??
03:05:44 <opqdonut> ops!
03:05:45 <Zao> cute.
03:05:46 <ayumilove1> wow what hapepn just now
03:05:58 <ayumilove1> hack?
03:06:00 <ayumilove1> o_O
03:06:04 <luqui> I've never seen that before.  some kind of evil bot
03:06:06 <sioraiocht> > let fib x y = x: fib y (x+y) in take 10 (fib 4 5)
03:06:07 <opqdonut> botnet, probably
03:06:07 <lambdabot>  [4,5,9,14,23,37,60,97,157,254]
03:06:09 <luqui> or army of bots
03:06:09 <rwbarton> ... You said you wanted a list of fibonacci numbers.  If you just want n of them, you can use take n
03:06:17 <lemming7597> Hey you are English ??
03:06:17 <lemming469> Hey you are English ??
03:06:18 <lemming7597> Hey you are English ??
03:06:18 <lemming469> Hey you are English ??
03:06:20 <lemming7597> Hey you are English ??
03:06:20 <lemming469> Hey you are English ??
03:06:21 <lemming7597> Hey you are English ??
03:06:21 <lemming469> Hey you are English ??
03:06:21 <Deewiant> @where ops
03:06:22 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
03:06:22 <lemming7597> Hey you are English ??
03:06:22 <lemming469> Hey you are English ??
03:06:37 <sioraiocht> oh dear
03:06:44 <opqdonut> indeed
03:06:45 * Zao hugs Starnes
03:06:49 --- mode: ChanServ set +o Igloo
03:06:55 <lemming2788> Hey you are English ??
03:06:55 <lemming9309> Hey you are English ??
03:06:55 <lemming8981> Hey you are English ??
03:06:57 <lemming2788> Hey you are English ??
03:06:57 <lemming9309> Hey you are English ??
03:06:57 <lemming8981> Hey you are English ??
03:06:58 <lemming17> Hey you are English ??
03:06:59 <lemming9309> Hey you are English ??
03:06:59 <lemming7597> Hey you are English ??
03:06:59 <lemming469> Hey you are English ??
03:06:59 <lemming8981> Hey you are English ??
03:06:59 <lemming2788> Hey you are English ??
03:07:00 --- mode: Igloo set +b lemming*!*@*
03:07:12 --- kick: lemming17 was kicked by Igloo (Igloo)
03:07:24 --- kick: lemming2788 was kicked by Igloo (Igloo)
03:07:26 <ayumilove1> Igloo is a haskell staff?
03:07:26 --- kick: lemming8981 was kicked by Igloo (Igloo)
03:07:33 <ayumilove1> or a bot  too
03:07:47 <Heffalump> Igloo is a person :-)
03:07:49 <luqui> no, Igloo is not a bot
03:07:58 <Igloo> An op in #haskell
03:08:03 <luqui> as far as I know :-)
03:08:53 <Heffalump> well, he didn't look like a bot when I saw him on Friday..
03:09:25 <idnar> is there a more memory-friendly way to do nub . sort?
03:09:40 <Botje> map head . group . sort
03:09:41 <Deewiant> sort . nub?
03:09:51 <ayumilove1> an op?
03:09:54 <idnar> Deewiant: that's not the same thing, is it?
03:09:56 <Heffalump> nub is silly if you'll be sorting
03:10:01 <luqui> idnar, Set.toList . Set.fromList
03:10:08 <Deewiant> @check 1 == 1 -- broken?
03:10:09 <luqui> (where Set is Data.Set)
03:10:09 <lambdabot>   Not in scope: `myquickcheck''
03:10:11 <Deewiant> meh
03:10:14 <Heffalump> since squeezing adjacent duplicates is all you need
03:10:25 <idnar> Heffalump: I thought that's what nub did
03:10:25 <Deewiant> idnar: it should be the same thing
03:10:31 <idnar> oh wait
03:10:33 <Deewiant> > nub [1,2,1]
03:10:34 <Heffalump> no, it does a quadratic scan
03:10:34 <lambdabot>  [1,2]
03:10:37 <idnar> right
03:11:02 <Deewiant> map head . group is the faster nub, for when you have an Ord instance
03:11:06 <idnar> so I could just do nub, I don't need the nub
03:11:07 <nicoo1101> What is lemming ??
03:11:09 <Deewiant> + .sort
03:11:14 <nicoo1101> Clones ?? :o
03:11:15 <idnar> *the sort
03:11:17 <idnar> except maybe I do need the sort
03:11:27 <idnar> let me try Botje's one
03:11:32 <Deewiant> if you can sort, you should use map head.group.sort
03:11:56 <Deewiant> nub is only for when you don't have an Ord instance or when you care more about typing fast than running fast :-P
03:12:00 --- mode: Igloo set -o Igloo
03:12:04 <Zao> I'd say that lemming is someone that managed to embed IO in STM.
03:12:19 <luqui> lol
03:13:20 <pozic> Why would a botnet pick #haskell to gather?
03:13:34 <idnar> is there a shorter way to write zip [1..] xs?
03:13:44 <rwbarton> @users
03:13:44 <lambdabot> Maximum users seen in #haskell: 490, currently: 452 (92.2%), active: 26 (5.8%)
03:13:45 <Botje> isn't it short enough? :)
03:13:49 <luqui> pozic, what do you mean gather?
03:14:02 <pozic> luqui: to meet
03:14:02 <idnar> Botje: I was just curious, since python has enumerato()
03:14:03 <Zao> pozic: Relatively high population, many snubbed trolls.
03:14:05 <ayumilove1> could someone check this out ? http://hpaste.org/9509
03:14:05 <idnar> err, enumerate()
03:14:14 <ayumilove1> why is it not working o_o ?
03:14:32 <pozic> Zao: they could also go to #nobodyishere.
03:14:36 <Botje> ayumilove1: uh, because x and y aren't defined?
03:14:49 <luqui> > length "zip [0..]" `compare` length "enumerate"
03:14:49 <Botje> pozic: you think spammers are THAT considerate? :)
03:14:50 <lambdabot>  EQ
03:14:56 <Botje> lol
03:15:06 <ayumilove1> Botje: so i replace x and y with 0 and 1 ?
03:15:17 <Botje> but only in "in take n (fib x y)"
03:15:19 <Botje> yes
03:15:19 <Deewiant> > length "zip[0..]" `compare` length "enumerate"
03:15:20 <lambdabot>  LT
03:15:22 <int-e> ayumilove1: let (fib x y) <-- those parentheses are too much
03:15:27 <pozic> Botje: it seems a waste of CPU time to let the bots go to places where they will be kicked anyway.
03:15:43 <Botje> i don't think those guys care
03:15:48 <Botje> they just want to annoy at all costs
03:16:06 <pozic> Botje: they don't earn money by annoying, or do they?
03:16:06 * luqui can't fathom what other goal that would have accomplished
03:16:10 <ayumilove1> thanks guys
03:16:12 <ayumilove1> it work snow
03:16:16 <ayumilove1> it works now*
03:16:18 <ayumilove1> =D
03:16:33 <Botje> all of the agh* ones were from the same host in .pl
03:16:44 <idnar> pozic: I don't think they're trying to earn money :P
03:16:44 <nicoo1101> I speack French x) I don't uderstand
03:18:16 <ayumilove1> http://hpaste.org/9509#a2 (correction) ^_^
03:18:52 <ayumilove1> kinda fun to do learn haskell in irc
03:19:05 <luqui> s/haskell//
03:19:12 <int-e> ayumilove1: now why don't you let it return an infinite list?
03:20:03 <ayumilove1> why i dont o_o
03:20:09 <ayumilove1> it will not stop?
03:20:35 <ayumilove1> int-e: is this message in red
03:20:44 <pozic> ayumilove1: int-e means that you can delay that decision to a later point.
03:20:48 <Deewiant> > let fibonacci = let fib x y = x : fib y (x+y) in fib 0 1 in take 20 fibonacci
03:20:49 <int-e> you can write  take 10 fibs  where you need it.
03:20:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
03:21:16 <pozic> ayumilove1: so the function can return an infinite number of values, but some other logic will decide how much you actually need.
03:21:36 <thoughtpolice> ayumilove1: a particularly nice thing about haskell is that it is very lazy. nothing is evaluated until it is needed, so infinite lists are practical
03:21:37 <int-e> ayumilove1: it's not red, but it's hilighted, yes. (depends on the IRC client)
03:21:47 <pozic> ayumilove1: (and thus will be computed)
03:21:48 <ayumilove1> i written it as n fibs so the user could input different n
03:21:58 <ayumilove1> so is my function lazy?
03:22:09 <ayumilove1> i do not know how haskell says its functions are lazy o_o
03:22:18 <thoughtpolice> ayumilove1: everything is lazy by default
03:22:27 <thoughtpolice> > [1..]
03:22:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:22:40 <ayumilove1> so the dot dot dot = lazy?
03:22:40 <luqui> > let x = 1:x in x
03:22:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:22:51 <thoughtpolice> ayumilove1: no, that specifies a range
03:22:53 <luqui> ayumilove1, that's lambdabot cutting off the output
03:22:55 <thoughtpolice> > [1..10]
03:22:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:23:07 <Deewiant> > [1,undefined]
03:23:08 <lambdabot>  [1,Exception: Prelude.undefined
03:23:10 <Deewiant> > head [1,undefined]
03:23:11 <luqui> what lambdabot does, more or less, is:
03:23:12 <lambdabot>  1
03:23:22 <ayumilove1> but w[1..10] << how is this define as lazy?
03:23:24 <luqui> > take 80 (show [1..]) ++ "..."
03:23:26 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:23:34 <luqui> > take 30 (show [1..]) ++ "..."
03:23:35 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13..."
03:23:39 <thoughtpolice> ayumilove1: you don't need to expliclty specify something as lazy
03:23:43 <int-e> ayumilove1: what lambdabot does there is, essentially,  take 76 (show result) ++ "..."
03:23:46 <thoughtpolice> *all* values are lazy by default
03:24:10 <ayumilove1> sorry, i still don't get the lazy part
03:24:19 <thoughtpolice> ayumilove1: for example, the value 'undefined' is just that: undefined. if you try to use it in any meaningful way
03:24:19 <Deewiant> > const [1..] 5 -- would loop forever if [1..] were evaluated
03:24:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:24:22 <thoughtpolice> it will throw an error
03:24:26 <thoughtpolice> > undefined
03:24:28 <lambdabot>  Exception: Prelude.undefined
03:24:33 <thoughtpolice> ^^ see?
03:24:48 <int-e> > let fibs = fib 0 1; fib x y = x : fib y (x+y) in take 10 fibs -- even though fibs is an infinite list, taking a finite prefix of that list terminates
03:24:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
03:24:51 <thoughtpolice> now, if you don't try to use it or don't use it in a meaningful way
03:24:53 <int-e> that's laziness.
03:24:53 <thoughtpolice> it doesn't matter
03:25:02 <int-e> or an effect of laziness
03:25:18 <thoughtpolice> for example, the 'const' function takes two values, and it always returns the first value
03:25:23 <thoughtpolice> no matter what
03:25:27 <thoughtpolice> > const 1 undefined
03:25:28 <lambdabot>  1
03:25:32 <ayumilove1> thoughtpolice: underfined??
03:25:47 <thoughtpolice> in the above, the 'undefined' value is not used
03:25:51 <thoughtpolice> so it is not evaluated
03:25:54 <luqui> undefined means "die horribly if you try to evaluate this"
03:25:54 <thoughtpolice> so no error is ever thrown
03:26:05 <Darkness3477> Hi all, I've decided to have another play around with Haskell. Any suggestions on a good ide? Am using windows at the moment, but usually am on a linux distro
03:26:24 <thoughtpolice> Darkness3477: there is a haskell IDE you might be interested in
03:26:27 <thoughtpolice> http://leksah.org
03:26:28 <lambdabot> Title: Leksah - Haskell IDE in Haskell
03:26:30 <luqui> uh... ide?  Apparently Visual Haskell is a good bad ide
03:26:58 <Darkness3477> Thanks for the link =]
03:26:59 <thoughtpolice> ayumilove1: undefined means just that, undefined. it has no meaningful value, for example, what does '1+undefined' mean?
03:27:11 <idnar> uhm
03:27:20 <rwbarton> Darkness3477: a lot of people just use emacs with haskell-mode.  It's quite convenient if you're an emacs user already
03:27:21 <ayumilove1> 1?
03:27:25 <idnar> I have "import Data.Set as Set" and "import Data.List" in my code
03:27:31 <ayumilove1> >1+undefined
03:27:36 <idnar> and I'm getting this error:
03:27:38 <idnar>     Ambiguous occurrence `filter'
03:27:38 <idnar>     It could refer to either `Data.List.filter', imported from Data.List at problem0023.hs:1:0-15
03:27:38 <Darkness3477> I do use Emacs quite a bit.
03:27:39 <thoughtpolice> > 1+undefined
03:27:41 <lambdabot>  Exception: Prelude.undefined
03:27:41 <idnar>                           or `Set.filter', imported from Data.Set at problem0023.hs:3:0-21
03:27:45 <rwbarton> idnar: import qualified Data.Set as Set
03:27:55 <idnar> rwbarton: oh right, duh
03:28:01 <rwbarton> idnar: I don't even know what "import Data.Set as Set" does :P
03:28:10 * idnar blames the Data.Set docs for confusing him
03:28:23 <lambdapants> it means you can call things in Data.Set with the prefix Set.blah
03:28:26 <lambdapants> like an oo language
03:28:31 <pozic> ayumilove1:  1 : 2 : [3] basically means 1: (Delay(2:(Delay(3:(Delay Nil <close parens>
03:28:59 <thoughtpolice> ayumilove1: like I said, all values are always lazy. nothing is evaluated until it is *absolutely needed*
03:29:06 <pozic> ayumilove1: when you later process it the Delay nodes are stripped off, by the run-time system.
03:29:06 <idnar> although it seems I was looking at outdated docs too
03:29:14 <thoughtpolice> ayumilove1: when something is absolutely needed it, the value is 'forced'
03:29:16 <thoughtpolice> so for example
03:29:19 <pozic> ayumilove1: that's how it conceptually works.
03:29:23 <ayumilove1> thanks pozic for explaining that,
03:29:36 <thoughtpolice> if you want to print 'x' to the screen, 'x' must be forced, since, well, print has to know what it is printing
03:29:38 <ayumilove1> now it makes sense :D
03:29:44 <pozic> ayumilove1: operationally it could work by proving that the delay nodes are not necessary.
03:29:59 <pozic> ayumilove1: and then it could run faster.
03:30:13 <ayumilove1> thoughtpolice: thanks, that example is newbie friendly :D
03:30:33 <thoughtpolice> ayumilove1: just remember nothing is evaluated until absolutely necessary.
03:30:39 <thoughtpolice> which is why we can have infinite lists
03:30:40 <lambdapants> > let ( x : xs ) = [ 1 , 2 ,3 ]
03:30:40 <lambdabot>  Parse error at end of input
03:31:02 <pozic> > let ( x : xs ) = [ 1 , 2 ,3 ] in x
03:31:03 <lambdabot>  1
03:31:11 <Darkness3477> Thanks for the help. Toodles, all
03:31:25 <ayumilove1> hmm have you guys used zipWidth before??
03:31:34 <luqui> zipWith you mean?
03:31:36 <int-e> zipWith, yes, plenty
03:31:42 <ayumilove1> how does it zipWith works?
03:31:43 <lambdapants> ahhh, cheers pozic.  I've never used the lambdabot before.
03:32:03 <int-e> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:32:04 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:32:15 <ayumilove1> wow we can use zipWith for fibonacci o_o ?
03:32:16 <lambdapants> > zipWith ( \ x y -> x + y ) [ 1 ,2 ,3 ] [ 1 ,1 ,1 ]
03:32:17 <lambdabot>  [2,3,4]
03:32:20 <luqui> int-e, I wouldnt' call that the best example
03:33:11 <ayumilove1> could someone explain how zipWith works in this code ? let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:33:11 <cjs> How you do you pronounce "<-"?
03:33:14 <lambdapants> I love that definition of fibs.  seen it before.  It's sort of poetic in how declaritive it is.
03:33:35 <int-e> luqui: it's a fun example though, and worth trying to understand.
03:33:38 <ayumilove1> there is a funny (+) plus sign too
03:33:49 <rwbarton> (+) means plus :)
03:33:54 <int-e> ( \ x y -> x + y ) and (+) are the same
03:33:57 <lambdapants> it makes it not infix
03:34:16 <int-e> right, x + y and (+) x y  are also the same
03:34:28 <ayumilove1> how about zipWith?
03:34:46 <lambdapants> I was attempting to demonstrate that zipWith takes a function of two arguments, then takes two lists.  it sort of maps the two lists together with the function
03:34:57 <idnar> zipWith [x..] [yxx]
03:34:59 <idnar> oops
03:35:07 <idnar> actually, that probably doesn't work anyway
03:35:15 <idnar> > [x..]
03:35:16 <lambdabot>  [Exception: not a number
03:35:22 <lambdapants> > zipWith (*) [ 1 , 2 ,3 ] [ 1 , 2 ,3 ]
03:35:23 <lambdabot>  [1,4,9]
03:35:33 <luqui> > zip [x..] [y,x,x]
03:35:34 <PeakerWork> @src zipWith
03:35:34 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:35:34 <lambdabot> zipWith _ _      _      = []
03:35:35 <lambdabot>  [(Exception: not a number
03:35:55 <int-e> ayumilove1: think about what the third elemebt of fibs is: it's the first element of fibs (i.e. 0) plus the first element of the tail of fibs (i.e. 1), that is, it's 1. then you can think about the fourth element, and so on.
03:35:56 <idnar> > zipWith (+) [x,x,x] [y,y,y]
03:35:57 <lambdabot>  [x + y,x + y,x + y]
03:36:25 <int-e> ayumilove1: there are no circular dependencies, so lazy evaluation will make the whole process work and produce the fibonacci numbers.
03:36:44 <idnar> > let xs = [x,y,z] in zipWith (+) xs (tail xs)
03:36:45 <lambdabot>  [x + y,y + z]
03:36:52 <idnar> ^^^ perhaps that's more explanatory
03:36:58 <PeakerWork> > let zipWith' f a b = map (f . uncurry) (zip a b) in zipWith' (+) [1,2,3] [3,2,1]
03:36:59 <lambdabot>  Couldn't match expected type `a -> b -> c'
03:37:07 <idnar> s/explanatory/demonstrative/
03:37:18 <int-e> PeakerWork: uncurry f
03:37:40 <PeakerWork> > let zipWith' f a b = map (uncurry f) (zip a b) in zipWith' (+) [1,2,3] [3,2,1]
03:37:41 <lambdabot>  [4,4,4]
03:37:44 <PeakerWork> ah, thanks
03:38:20 <ayumilove1> idnar: sorry, I don't understand the results [x + y,y + z]
03:38:56 <idnar> ayumilove1: okay, uhm, maybe a concrete explanation might make more sense
03:39:21 <ayumilove1> int-e: he/she says 3rd element is 1st element from list (0) + 1st element from tail list(1), 4th element? o_O
03:39:39 <idnar> ayumilove1: do you understand how zipWith works?
03:39:42 <int-e> ayumilove1: maybe I shouldn't skip the first two elements
03:39:45 <idnar> (in general, not in this specific problem)
03:39:46 <ayumilove1> no >.<
03:39:58 <idnar> do you understand how zip works?
03:40:05 <ayumilove1> i havent touch zip before
03:40:12 <idnar> okay, zip is fairly easy
03:40:21 <idnar> it takes two lists, and gives you a list of pairs:
03:40:25 <idnar> > zip [1,2,3] [4,5,6,]
03:40:25 <lambdabot>  Parse error at "]" (column 20)
03:40:27 <Quadrescence> Is there a way to make GHCi not output infinite lists...infinitely?
03:40:27 <idnar> > zip [1,2,3] [4,5,6]
03:40:28 <lambdabot>  [(1,4),(2,5),(3,6)]
03:40:32 <DrSyzygy> :t (,)
03:40:33 <int-e> ayumilove1: what's the first list element of  0 : 1 : zipWith fibs (tail fibs) ? remeber that  x : xs  is a list with first element  x  followed by the elements of  xs.
03:40:33 <lambdabot> forall a b. a -> b -> (a, b)
03:40:35 <Quadrescence> Like what lambdabot does?
03:40:54 <ayumilove1> zip [1,2,3] [4,5,6]
03:40:55 <ayumilove1> <lambdabot>  [(1,4),(2,5),(3,6)] >> this makes sense to me :D
03:40:59 <idnar> Quadrescence: take N . print :P
03:41:03 <int-e> > (42 : undefined) !! 0
03:41:04 <lambdabot>  42
03:41:05 <Quadrescence> psh
03:41:10 <lambdapants> Quadrescence... why not "take"
03:41:19 <idnar> ayumilove1: okay, so zipWith is similar to zip, except that it also takes a function
03:41:25 <Quadrescence> Just for general...experimenting
03:41:29 <DrSyzygy> > [42,undefined,12]!!2
03:41:31 <lambdabot>  12
03:41:36 <Quadrescence> so I don't have to ctrl-C it all the time
03:41:47 <int-e> > let stranfe_fibs = x : y : zipWith (+) fibs (tail strange_fibs) in strange_fibs -- sorry
03:41:48 <lambdabot>   Not in scope: `strange_fibs'
03:41:52 <idnar> ayumilove1: zipWith f [1,2,3] [4,5,6] == [f 1 4, f 2 5, f 3 6]
03:41:54 <int-e> > let strange_fibs = x : y : zipWith (+) fibs (tail strange_fibs) in strange_fibs -- sorry
03:41:55 <lambdabot>   Not in scope: `fibs'
03:41:57 <idnar> so for example, if we use (+)
03:41:59 * int-e sighs
03:42:05 <idnar> > zipWith (+) [1,2,3] [4,5,6]
03:42:06 <lambdabot>  [5,7,9]
03:42:09 <int-e> > let strange_fibs = x : y : zipWith (+) strange_fibs (tail strange_fibs) in strange_fibs -- third time's a charm?
03:42:10 <lambdabot>  [x,y,x + y,y + (x + y),x + y + (y + (x + y)),y + (x + y) + (x + y + (y + (x ...
03:42:15 <DrSyzygy> ayumilove1: zipWith recognizes that the function (,) that builds pairs is just a 2-ary function, and allows you to replace it by any other 2-ary function.
03:42:26 <idnar> that's [1+4, 2+5, 3+6]
03:42:33 <ayumilove1> idnar: oh!!! ok I understand your example, newbie friendly :D
03:42:42 <idnar> so now, in the fibs code
03:42:51 <idnar> our two lists are "fibs" and "tail fibs"
03:43:22 <idnar> do you understand what "tail" does?
03:43:34 <ayumilove1> idnar: tail is without the head (1st element) ?
03:43:39 <idnar> right
03:43:44 <ayumilove1> idnar: ok
03:43:51 <Deewiant> > iterate tail [0..]
03:43:52 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:44:00 <idnar> so we're adding the first element to the second element, the second element to the third element, the third element to the fourth element, and so on
03:44:01 <lambdapants> ( I don't mean to distract but I rather love zipWithM )
03:44:03 <Deewiant> hmm, right, bad example :-P
03:44:12 <Deewiant> > map head . iterate tail $ [0..]
03:44:14 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:44:34 <idnar> the "magic trick" is that we're defining the list recursively
03:44:47 <idnar> we only write out the first two elements explicitly
03:45:17 <lambdapants> I Have a question.  I cannot get Data.Derive to compile.  It configures without problem, then builds the first two modules, then dies silently.
03:45:26 <idnar> but since Haskell has lazy evaluation, we don't have to calculate the whole list a tonce
03:46:29 <idnar> so the first element in the result of zipWith is the third element of fibs; in order to calculate it, we add the first element of fibs to the second element of fibs
03:46:59 <idnar> the second element in the result of zipWith is the fourth element of fibs; in order to calculate it, we add the second element of fibs to the third element of fibs; and since we just calculated the third element, that's no problem
03:50:01 <ayumilove1> idnar: umm trying to digest those words
03:50:35 <idnar> ayumilove1: okay, let me know where I lost you if you can't follow all of that
03:51:47 <lambdapants> idnar: the beauty of that definition over more imperative forms is - you can see clear that you start with 0 then 1 , and then you see the zipWith, one list starts at the start of the fib set ( ie the variable fib ), the next list starts an element up ( ie,  tail fib )....... so when they are zipWithed+ the first element is added to the second element.... it is soooo close to the mathematical description it just really..
03:52:15 <ayumilove1> idnar: ok i understand the 2 sentences
03:52:33 <ayumilove1> i have written it into my notepad and ran my winhugs, it keeps looping
03:52:33 <idnar> lambdapants: yes, I think that's probably my favourite definition
03:52:49 <idnar> ayumilove1: well, it's a list of every fibonacci number
03:52:56 <idnar> ayumilove1: and there are an infinite number of fibonacci numbers
03:53:03 <idnar> ayumilove1: try printing "take 50 fibs" or something like that
03:53:09 <idnar> (that'll give you only the first 50)
03:53:10 <ayumilove1> ok
03:53:42 <ayumilove1> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049]
03:53:47 <ayumilove1> :D it works
03:53:47 <lambdapants> weeee.
03:53:56 <ayumilove1> wow take is kinda useful
03:54:14 <ayumilove1> today i learned so much stuff o_o
03:54:19 <idnar> :)
03:54:23 <lambdapants> ayumilove: maybe it would help you understand if the calc is further up the set
03:54:34 <ayumilove1> fibonacci can be done using recursion, iteration, operator and zipWith
03:54:50 <luqui> oh no!  I just realized zip is not symmetrical.  Stupid bottoms...
03:54:52 <lambdapants> > let fib = 1 : 2 : withZip fib ( tail fib ) in fib
03:54:53 <lambdabot>   Not in scope: `withZip'
03:54:59 <lambdapants> heh
03:55:22 <lambdapants> ﻿let fib = 1 : 2 : zipWith fib ( tail fib ) in fib
03:55:25 <luqui> > zip (1:2:3:[]) (4:5:6:undefined)
03:55:26 <lambdabot>  [(1,4),(2,5),(3,6)]
03:55:32 <luqui> > zip (4:5:6:undefined) (1:2:3:[])
03:55:34 <lambdabot>  [(4,1),(5,2),(6,3)Exception: Prelude.undefined
03:55:37 <lambdapants> heh
03:55:39 <rwbarton> @src zip
03:55:39 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
03:55:39 <lambdabot> zip _      _      = []
03:55:41 <lambdapants> I forgot the plus
03:55:43 <lambdapants> nevermind
03:55:50 <lambdapants> I need to build Data.Derive
03:56:02 <rwbarton> I see
03:56:10 <lambdapants> ﻿let fib = 1 : 2 : zipWith (+) fib ( tail fib ) in fib
03:56:33 <lambdapants> aye....
03:56:34 <lambdapants> but
03:56:41 <lambdapants> Data.Derive won't build!
03:56:44 <lambdapants> it dies silently
03:56:48 <lambdapants> after making two modules.
03:57:01 <idnar> > let fib = 1 : 2 : zipWith (+) fib (tail fib) in fib
03:57:02 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
03:57:03 * luqui needs to write Data.DWIM
03:57:14 <idnar> luqui: what about Control.DWIM?
03:57:21 <idnar> actually, screw DWIM
03:57:22 <luqui> oh yeah, Data.BWIM
03:57:23 <int-e> > oeis [0,1,1,2,3,5]
03:57:24 <lambdabot>   Not in scope: `oeis'
03:57:25 <idnar> I want Control.DWIW
03:57:36 <Zao> Control.Parallel.Strategies.DWIM?
03:57:40 <luqui> Relationship.BWIW
04:02:14 <lambdapants> shit!
04:02:24 <lambdapants> I just fucked my virtual server with ghc
04:02:47 <lambdapants> that means it has probably fucked a bunch of other people's too!
04:02:50 <lambdapants> aaaaaaahhh!
04:03:39 <luqui> ?
04:03:50 <lambdapants> I tried building derive-0.1
04:03:52 <lambdapants> it halted
04:03:55 <lambdapants> well
04:03:57 <lambdapants> no it didn;t
04:04:01 <lambdapants> it halted the system
04:04:03 <lambdapants> I can't even ping it
04:04:08 <Quadrescence> lambdabot: wait, derive the CAS?
04:04:22 <luqui> probably Data.Derive
04:04:23 <Quadrescence> (probably not)
04:04:26 <Quadrescence> Okay
04:04:28 <lambdapants> Data.Derive.
04:04:28 <Quadrescence> :>
04:04:36 <Quadrescence> Hah, you got me excited for a second.
04:04:44 <idnar> lambdapants: sounds like a hardware issue
04:04:47 <luqui> that's.... odd and unlikely seeming...
04:04:55 <idnar> unless your virtual server is just horribly CPU-starved
04:05:07 <lambdapants> phew... it works again....
04:05:12 <lambdapants> I can ping.
04:05:16 <lambdapants> I very nearly peed there.
04:05:23 <luqui> peeing is healthy
04:05:29 <lambdapants> not on the sofa
04:05:34 <luqui> not for the sofa
04:05:40 * idnar flanics and attempts to pee
04:06:00 * luqui ceases to exist
04:09:17 <lambdapants> maybe they rebooted it :@
04:09:44 <ayumilove1> <luqui> peeing is healthy o_o
04:10:24 <Armored_Azrael> Is there a haskell SNMP lib?
04:12:37 <lambdapants> let pee = repeat "I seriously broke a computer hundreds of miles away in england.  peeing is a good option right now" in pee
04:19:59 <Armored_Azrael> Is there a haskell SNMP lib?
04:21:01 <Botje> no(t yet)
04:22:30 <rwbarton> <dons>write one</dons>
04:22:34 <ayumilove1> lol lambdapants funny
04:22:51 <ayumilove1> hey guys, is it possible to sort the order of the number within a list?
04:23:04 <rwbarton> > sort [3, 1, 5, 2]
04:23:05 <ayumilove1> example: [1,2,3] becomes [3,2,1] ?
04:23:05 <lambdabot>  [1,2,3,5]
04:23:14 <dobblego> @type sortBy
04:23:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:23:18 <ayumilove1> >sort [9,1]
04:23:25 <ayumilove1> > sort [9,1]
04:23:26 <lambdabot>  [1,9]
04:23:46 <rwbarton> > reverse (sort [3, 1, 5, 2])
04:23:48 <lambdabot>  [5,3,2,1]
04:23:52 <ayumilove1> wow thanks
04:24:05 <ayumilove1> > reverse [1,3,5]
04:24:07 <lambdabot>  [5,3,1]
04:24:10 <ayumilove1> cool :D
04:24:18 <ayumilove1> this is fun
04:24:20 <Botje> > sortBy (flip compare) [3,1,5,2]
04:24:21 <lambdabot>  [5,3,2,1]
04:24:48 <ayumilove1> Botje: what does this do? > sortBy (flip compare) [3,1,5,2] , is it the same as reverse?
04:24:52 <Botje> yes
04:24:58 <Botje> except it doesn't do the reverse at the end
04:25:14 <ayumilove1> what do you mean by doesnt do reverse at the end?
04:25:20 <Botje> i wonder if GHC is smart enough to rewrite reverse . sort to sortBy (flip compare)
04:25:21 <lambdapants> remember it's inefficient
04:25:21 <lambdapants> when I need a lot of things sorted, ( frequently some data is associated with a number ) I use Data.Map to store them and then just query for the max and min values.
04:25:40 <Botje> ayumilove1: reverse . sort does a sort O(n log n) first
04:25:46 <Botje> and then an O(n^2) reverse
04:25:57 <Botje> whereas sortBy (flip compare) only does an O(n log n) sort
04:26:03 <Botje> (you know big-O notation, right?)
04:26:05 <rwbarton> reverse . sort /= sortBy (flip compare) when == is not equality
04:26:21 <rwbarton> > length (reverse [1..10^6])
04:26:23 <lambdabot>  1000000
04:26:24 <ayumilove1> i heard that big O describes how efficient is the code
04:26:31 <rwbarton> ^^ I don't think reverse is O(n^2) :)
04:26:41 <ayumilove1> 2n or n ^ 2 is not efficient = big
04:26:42 <lambdapants> I concur
04:26:52 <Botje> @src reverse
04:26:52 <lambdabot> reverse = foldl (flip (:)) []
04:27:00 <Botje> hmm
04:27:03 <Botje> so it isn't
04:27:05 <Botje> OR IS IT
04:27:12 <andun> no, it's not
04:27:15 <Heffalump> that's O(n)
04:27:24 <Botje> ah
04:27:26 <Botje> cool
04:27:40 <Heffalump> it's the accumulating parameter version
04:27:50 <rwbarton> Still, sortBy (flip compare) is better if you're only going to use a few elements of the result
04:27:50 <idnar> @do [x | x <- xs, x /= 5]
04:27:50 <lambdabot> [x | x <- xs, x /= 5] not available
04:27:58 <idnar> oh meh
04:28:07 <EvilTerran> @undo [x | x <- xs, x /= 5]
04:28:08 <lambdabot> concatMap (\ x -> if x /= 5 then [x] else []) xs
04:28:12 <EvilTerran> @. redo undo [x | x <- xs, x /= 5]
04:28:13 <lambdabot> concatMap (\ x -> if x /= 5 then [x] else []) xs
04:28:16 <EvilTerran> hm
04:28:27 <idnar> well, anyhow, what's the do-syntax equivalent of that?
04:28:40 <Botje> do { x <- xs; x /= 5; return x }
04:28:44 <rwbarton> do { x <- xs ; guard (x /= 5) ; return x }
04:28:50 <dmhouse> > do (x <- [1..5]; guard (x /= 5); return x)
04:28:50 <lambdabot>  Parse error at "<-" (column 7)
04:28:51 <Botje> oh yeah
04:28:54 <Quadrescence> Is there a site like http://en.literateprograms.org/Category:Programming_language:Haskell
04:28:54 <idnar> oh, guard
04:28:56 <lambdabot> Title: Category:Programming language:Haskell - LiteratePrograms, http://tinyurl.com/57nmlo
04:28:58 <Botje> need more caffeine :(
04:28:59 <idnar> @type guard
04:29:00 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:29:05 <Quadrescence> which has small codes of haskell
04:29:07 <Quadrescence> ?
04:29:14 <idnar> @index guard
04:29:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:29:28 <dmhouse> List comprehensions used to be generalised to all monads (I think they used fail rather than guard).
04:32:44 * idnar ponders
04:33:26 <ayumilove1> Botje not sleepy?
04:33:37 <Botje> not sleepy just tired
04:33:44 <ayumilove1> night?
04:33:46 <Botje> getting up before 12 is not my thing(tm)
04:34:05 <ayumilove1> sleep early and wake up early = good for health :D
04:34:18 <ayumilove1> caffeine not good for health o_o
04:35:02 <ayumilove1> > reverse [9,8,7,6]
04:35:03 <lambdabot>  [6,7,8,9]
04:35:12 <ayumilove1> > reverse [a,b,c,d]
04:35:13 <lambdabot>  [d,c,b,a]
04:35:22 <ayumilove1> > reverse  [d,c,b,a]
04:35:23 <lambdabot>  [a,b,c,d]
04:35:28 <ayumilove1> cool o_o
04:35:38 <ayumilove1> so this reverse function is the most efficient?
04:35:48 <ayumilove1> @ reverse
04:35:53 <Botje> for reversing lists? sure
04:36:00 <Botje> that's what it's made for :)
04:36:10 <ayumilove1> how do you guys make the lambdabot pops up some weird functions
04:36:18 <Botje> @src reverse
04:36:18 <ayumilove1> using the @ symbol or something like that
04:36:18 <lambdabot> reverse = foldl (flip (:)) []
04:36:38 <ayumilove1> what is that foldl doing there?
04:36:44 <ayumilove1> fold left?
04:37:06 <Botje> it's "fold towards the left"
04:37:14 <ayumilove1> example?
04:37:22 <ayumilove1> simple one would do ^_^ "
04:37:37 <Botje> > foldl f 0 [a,b,c,d] :: Expr
04:37:38 <lambdabot>  f (f (f (f 0 a) b) c) d
04:37:47 <ayumilove1> @src fold
04:37:47 <lambdabot> Source not found. Do you think like you type?
04:37:53 <ayumilove1> @src foldl
04:37:54 <lambdabot> foldl f z []     = z
04:37:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:37:55 <Botje> > foldl (flip (:)) [] [a,b,c,d] :: Expr
04:37:56 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
04:38:02 <Botje> > foldl (flip (:)) [] [a,b,c,d] :: [Expr]
04:38:04 <lambdabot>  [d,c,b,a]
04:38:10 <Botje> aww it doesn't show
04:38:52 <ayumilove1> > foldr f 0 [a,b,c,d] :: Expr
04:38:54 <lambdabot>  f a (f b (f c (f d 0)))
04:39:12 <ayumilove1> > foldr +1 0 [a,b,c,d] :: Expr
04:39:13 <lambdabot>  Couldn't match expected type `Expr'
04:39:19 <ayumilove1> o_o
04:39:31 <ayumilove1> foldr f 0 , what is f there? is it a function?
04:39:38 <ayumilove1> > foldr (+1) 0 [a,b,c,d] :: Expr
04:39:38 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `Expr'
04:39:46 <Taggnostr> hello
04:39:59 <ziman> > [a, b, c, d] :: [Expr]
04:40:00 <lambdabot>  [a,b,c,d]
04:40:05 <ziman> > [a, b, c, d] :: Expr
04:40:06 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
04:40:17 <Taggnostr> how can i check if a string starts with another substring?
04:40:22 <rwbarton> ayumilove1: f is a function with two arguments--like in "f d 0" in the middle of that expression above
04:40:59 <ayumilove1> rwbarton: ok
04:41:10 <ayumilove1> what is Expr means?
04:41:17 <ayumilove1> express?
04:41:32 <rwbarton> expression, it's lambdabot magic.
04:41:53 <ayumilove1> what is a lambdabot magic? weird lambdabot gets its name from a lamb?
04:42:00 <ayumilove1> robot lamb ?
04:42:22 <ayumilove1> lambdabot = lamb the bot?
04:42:32 <Taggnostr> lambda bot
04:42:36 <ziman> interesting :)
04:42:52 <ayumilove1> what is a lambdabot magic?
04:43:38 <ayumilove1> how do you guys calculate how efficient is a code using the big-o notation?
04:45:14 <idnar> is there an example somewhere of how to use STUArray?
04:45:57 <lambdapants> ayumilove: haskell is based on a thing called the lambda calculus
04:46:25 <ayumilove1> lambdapants: ok , oh i see
04:46:31 <lambdapants> the lambda calculus provides a foundation for compution, a - universal turing machine
04:46:42 <Taggnostr> are your pants based on that too?
04:46:43 <ayumilove1> does it provide to java , c++ and others?
04:46:55 <ayumilove1> lol taggnostr
04:47:09 <chrisdone> @seen chr1s
04:47:09 <lambdabot> chr1s is in #haskell. I last heard chr1s speak 16h 12m 29s ago.
04:47:20 <ayumilove1> @seen ayumilove1
04:47:20 <lambdabot> You are in #haskell. I last heard you speak just now.
04:47:32 <ayumilove1> @seen john
04:47:33 <lambdabot> I haven't seen john.
04:47:38 <ayumilove1> @seen lambdabot
04:47:38 <lambdabot> Yes, I'm here. I'm in #japanese, #macosx, #arch-haskell, #haskell-hac4, #gentoo-uy, #friendly-coders, #dreamlinux-es, #thunks, #haskell-hac07, #haskell_ru, #haskell.cz, #haskell.dut, #haskell.de, #
04:47:38 <lambdabot> haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell-books, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #
04:47:38 <lambdabot> unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
04:47:46 <ayumilove1> wow o_o
04:48:00 <idnar> sheesh
04:48:11 <ayumilove1> i did not know lambdabot is so active in all channels
04:48:22 <chrisdone> because sometimes unicyclists really need a purely functional programming language
04:48:24 <ayumilove1> yay learned something new with @
04:48:28 <Axman6> it sure does get around a bit
04:48:42 <ayumilove1> what is universal turing machine?
04:48:55 <ayumilove1> do you meaning turning as in cycling?
04:49:02 <thoughtpolice> @go Universal Turing Machine
04:49:04 <lambdabot> http://en.wikipedia.org/wiki/Turing_machine
04:49:04 <lambdabot> Title: Turing machine - Wikipedia, the free encyclopedia
04:49:10 <thoughtpolice> ^^ read that
04:49:17 <ayumilove1> http://google.com
04:49:17 <lambdabot> Title: Google
04:49:21 <ayumilove1> o_O
04:49:28 <ayumilove1> http://john.com
04:49:48 <thoughtpolice> ayumilove1: turing machines are simple abstract devices that can emulate and do anything a regular computer can.
04:50:00 <thoughtpolice> it's a little computer science stuff although wikipedia should be able to help
04:50:00 <ayumilove1> man, red fonts scares me -_-
04:50:20 <ayumilove1> thoughtpolice: thanks :D
04:50:35 <ayumilove1> @seen thoughtpolice
04:50:36 <lambdabot> thoughtpolice is in #ghc, #haskell-blah and #haskell. I last heard thoughtpolice speak 35s ago.
04:50:57 <ayumilove1> why there is no #winhugs?
04:51:10 <thoughtpolice> the lambda calculus is a foundation for many functional programming languages, and we call it a 'universal turing machine' because the lambda calculus too can compute anything a regular computer can
04:51:52 <thoughtpolice> ayumilove1: most people use GHC
04:52:05 <Botje> Taggnostr: if you still need it, smallstr `isPrefixOf` bigstr
04:52:08 <ayumilove1> oh, someone recommended me winhugs because newbie friendly interface
04:52:17 <Taggnostr> Botje, thanks
04:52:18 <ayumilove1> and its windows :D
04:52:18 <thoughtpolice> ayumilove1: it does. ghc is just more feature complete
04:52:25 <Botje> ayumilove1: how is that a good thing?
04:52:35 <chrisdone> chr1s: yaay you made it monadic. I'm going to try it out on my project ^___^!
04:52:52 <chr1s> chrisdone: cool!
04:53:05 <chr1s> chrisdone: let me know how it works out for you
04:53:05 <thoughtpolice> Botje: if nothing else hugs gives better type-related errors which may be better for a newbie
04:53:11 <chrisdone> chr1s: sure!
04:53:11 <thoughtpolice> GHC's type errors can be a little scarier
04:53:16 <Botje> it used to be
04:53:22 <Botje> now i'm not so sure
04:53:36 <ayumilove1> botje is a staff for haskell/
04:53:38 <ayumilove1> ?
04:53:45 <ayumilove1> you seem so experience in haskell o_o
04:53:53 <Botje> not really
04:53:54 <Axman6> staff?
04:53:59 <lambdapants> hehe
04:54:01 <Botje> i'm celebrating my one-year-of-haskell soon :P
04:54:12 <thoughtpolice> Botje: you as well? :)
04:54:19 <thoughtpolice> actually I think I hit my one year sometime around march
04:54:21 <Botje> yeah :)
04:54:21 <thoughtpolice> can't remember
04:54:36 <lambdapants> I hit year two next month :D
04:54:37 <Botje> hmm
04:54:44 <Botje> i seem to have passed it as well
04:54:57 <chrisdone> I started january
04:55:00 <lambdapants> then again I have anonymouse pants
04:55:02 <Botje> my first stored haskell program was may 1 2007
04:55:10 <Axman6> i started in feburary i think
04:55:11 <Taggnostr> Botje, <interactive>:1:6: Not in scope: `isPrefixOf'
04:55:16 <chrisdone> “new year? new language!”
04:55:19 <Botje> Taggnostr: yeah, it's in Data.List
04:55:20 <lambdapants> haskell was the second programming language I learned.  I'm only 19.
04:55:22 <thoughtpolice> Tobsan: import Data.List
04:55:28 <Axman6> @hoogle isPrefixOf
04:55:28 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:55:28 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
04:55:28 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
04:55:29 <thoughtpolice> lambdabot: the first being?
04:55:36 <lambdapants> php :p
04:55:40 <chrisdone> lambdapants: me too omfg, except I know other languages
04:55:45 * Botje is up to 14 or so
04:55:49 <dmhouse> lambdapants: nice, that's exactly the same route as me.
04:55:50 <thoughtpolice> lambdabot: hehe, php was my first language as well
04:55:52 <thoughtpolice> back in like
04:55:53 <thoughtpolice> 2002
04:55:54 <Axman6> lambdapants: only your second?
04:56:02 <dmhouse> I'm now playing with C for a university project.
04:56:02 <lambdapants> I know 7 now.
04:56:07 <thoughtpolice> when I was like 12 :p
04:56:10 <idnar> @mapM
04:56:10 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:56:14 <idnar> err
04:56:17 <idnar> @type mapM
04:56:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:56:19 <EvilTerran> my first language was AcornBasic on a BBC Micro
04:56:28 <lambdapants> that's old skool.
04:56:33 <Axman6> i'm not even sure what my first one was :o
04:56:36 <Axman6> logo? ha
04:56:41 <thoughtpolice> logo is fun stuff
04:56:47 <Axman6> playing with that when i was like 6
04:56:55 <idnar>     Could not deduce (MArray (STUArray s) e (GHC.ST.ST s))
04:56:55 <idnar>       from the context ()
04:56:56 <idnar> argh
04:57:02 <thoughtpolice> my path was something like php -> perl -> c -> ??? -> haskell
04:57:14 <lambdapants> I used to really like ruby.
04:57:14 <lambdapants> I had to use python to make some money, earlier this year.
04:57:19 <lambdapants> haskell couldn't hack it :(
04:57:20 <thoughtpolice> you may be wondering what exactly I learned and messed with in that '???' period
04:57:23 <thoughtpolice> so am i
04:57:35 <dmhouse> Everyone's paths seem to stop at Haskell. :)
04:58:04 <Axman6> i've done some ruby, C, C++, forth, (HTML? does that count? CSS?), erlang, haskell and java
04:58:06 <lambdapants> it's near perfect for writing interpreters for other languages
04:58:10 <thoughtpolice> i have still never made a dime off of any code I have written.
04:58:24 <lambdapants> erlang I'd like to learn
04:58:27 <dmhouse> HTML/CSS are markup languages, not programming languages.
04:58:42 <lambdapants> I had an idea to make an OO language in haskell
04:58:45 <Axman6> lambdapants: i really like erlang, but i miss haskell's type checking soo much :(
04:58:48 <ayumilove1> i started haskell just like 3 weeks o_o
04:58:50 <dmhouse> I'd like to play with Forth.
04:58:56 <thoughtpolice> lambdabot: erlang is very interesting, to learn some of it a while back I tried implementing a rudimentary game server
04:59:01 <ayumilove1> so many serniors here
04:59:04 <thoughtpolice> in 300 lines of code I had some very nice functionality :)
04:59:15 <Axman6> dmhouse: we used it to program some robots in year 10
04:59:23 <lambdapants> thoughtpolice: mmm, I might give it a try
04:59:53 <idnar> what's the best way to fold over an Array?
05:00:04 <thoughtpolice> in particular I managed (somehow) to hack up: load balancing, servers/nodes could be added on the fly, some statistical stuff and fairly okay fault tolerance using OTP
05:00:12 <thoughtpolice> which isn't bad for 300 loc i think
05:00:15 <idnar> repeated (!) or something?
05:00:22 <dmhouse> http://prog21.dadgum.com/33.html really intrigued me.
05:00:23 <lambdabot> Title: prog21: Understanding What It's Like to Program in Forth
05:00:53 <idnar> oh, I guess elems is fine
05:00:57 <thoughtpolice> hehe, I actually downloaded Thinking Forth today, was thinking of giving it a try. most people describe it as a very low-floor high-ceiling language
05:00:59 <Axman6> dmhouse: i read that. and remembered why i like erlang :P
05:01:12 <idnar> hrm, except that's not in IArray
05:01:13 <Axman6> well i read the code, totally forgot to read the article, ha
05:01:13 * idnar is confused
05:01:40 <thoughtpolice> ayumilove1: do not worry, just keep working at it and you will get better at haskell. we are here to help :)
05:01:47 <dmhouse> ?instances Foldable
05:01:47 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
05:01:55 <dmhouse> ?instances-importing Data.Foldable Foldable
05:01:55 <lambdabot> Maybe, []
05:02:00 <dmhouse> ?instances-importing Data.Foldable Data.Array Foldable
05:02:00 <lambdabot> Array i, Maybe, []
05:02:08 <Axman6> also, why are haskellers all so nice? it's awesome
05:02:11 <dmhouse> idnar: use the Foldable instance?
05:02:20 <thoughtpolice> Axman6: 'cause we use haskell
05:02:27 <Axman6> oh yeah
05:02:32 <thoughtpolice> :)
05:02:53 <lambdapants> haskell is a good language, everyone learns to love her bondage :p
05:03:30 <lambdapants> I'm going to go and work on this little interpreter I've been making, seeing as my website has been shelled by nazis or something
05:03:39 <lambdapants> bye!
05:03:43 <thoughtpolice> lambdapants: later
05:03:44 <Taggnostr> let count s1 s2 n = if s1 == "" then n else count (tail s1) s2 (if s2 `isPrefixOf` s1 then n+1 else n) <- how bad is this function? (it probably already exists, just playing around)
05:03:54 <ayumilove1> oh yeah, forgotten something, what does this do? !! << example fibs !! n
05:04:02 <Deewiant> > [5,4,3,2] !! 1
05:04:04 <lambdabot>  4
05:04:04 <thoughtpolice> ayumilove1: array index
05:04:09 <ayumilove1> ok
05:04:14 <ayumilove1> just remembered
05:04:15 <ayumilove1> thanks
05:04:30 <rwbarton> ayumilove1: http://www.haskell.org/hoogle/?q=%21%21
05:04:31 <lambdabot> Title: !! - Hoogle
05:04:47 <Botje> Taggnostr: if you replace "" by [] it's a bit more general
05:05:07 <Botje> also, i'd use pattern matching instead of a "" check
05:05:32 <Taggnostr> how?
05:05:43 <Botje> count [] s2 n = n
05:05:47 <thoughtpolice> count [] _ n = n
05:05:54 <ayumilove1> thanks rwbarton for the link, useful site :D
05:06:00 <thoughtpolice> i always get beaten to the punch :)
05:06:01 <ayumilove1> bookmarked
05:06:15 <Botje> count s1 s2 n = count (tail s1) s
05:06:20 <Taggnostr> yep
05:06:22 <chrisdone> hayoo is behaving odd recently. I wouldn't mind if they ditched the ajax
05:06:28 <Botje> count s1 s2 n = count (tail s1) s2 (fromEnum $ s1 `isPrefixOf` s2)
05:06:46 <Botje> meh
05:06:52 <dmhouse> Botje: +n
05:06:52 <rwbarton> count s1 s2 n = length . filter (isPrefixOf s1) $ tails s2
05:06:52 <Botje> swap s2 and s1 in the fromEnum
05:06:56 <Botje> +n, yeah
05:07:12 <Taggnostr> what is fromEnum?
05:07:17 <thoughtpolice> :t fromEnum
05:07:18 <lambdabot> forall a. (Enum a) => a -> Int
05:07:28 <Botje> > map fromEnum  [False, True]
05:07:29 <lambdabot>  [0,1]
05:07:30 <Botje> :o)
05:08:26 <Axman6> > 2^9 :: Int8
05:08:27 <lambdabot>  0
05:08:28 <Taggnostr> ok
05:08:33 <Axman6> > 2^8 :: Int8
05:08:34 <lambdabot>  0
05:08:37 <Axman6> > 2^7 :: Int8
05:08:38 <lambdabot>  -128
05:08:58 <Axman6> > 2^6 :: Int8
05:09:00 <lambdabot>  64
05:09:13 <Taggnostr> > 2^8-1 ::Int8
05:09:15 <lambdabot>  -1
05:09:28 <Axman6> > [64..128] :: [Int8]
05:09:30 <lambdabot>  []
05:09:58 <Axman6> > [32..65]] :: [Int8]
05:09:59 <lambdabot>  Parse error at "]" (column 9)
05:10:02 <Axman6> > [32..65] :: [Int8]
05:10:04 <lambdabot>  [32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,...
05:10:19 <Axman6> > [40..65] :: [Int8]
05:10:20 <lambdabot>  [40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65]
05:10:24 <ayumilove1> > 2^8
05:10:26 <lambdabot>  256
05:10:36 <ayumilove1> what does Int8 do?
05:10:42 <Deewiant> > [125..] :: [Int8]
05:10:43 <lambdabot>  [125,126,127]
05:10:45 <Axman6> it's a data type
05:10:50 <ayumilove1> oh
05:10:50 <Botje> it's a signed 8-bit number
05:11:03 <ayumilove1> >[125..]::[Int7]
05:11:08 <Axman6> 8 bit signed integer
05:11:09 <ayumilove1> >[125..]::[Int6]
05:11:10 <Botje> > [(minBound,maxBound
05:11:10 <lambdabot> Unbalanced parentheses
05:11:12 <Botje> argh
05:11:12 <chrisdone> `::' means "has type"
05:11:15 <ayumilove1> > [125..]::[Int6]
05:11:16 <lambdabot>   Not in scope: type constructor or class `Int6'
05:11:18 <Botje> > [minBound,maxBound] :: [Int8]
05:11:19 <lambdabot>  [-128,127]
05:11:24 <Axman6> there is no Int6
05:11:27 <Botje> ayumilove1: no, those don't exist :)
05:11:30 <ayumilove1> only Int8 ?
05:11:41 <Axman6> and Int16, 32, 64
05:11:46 <Axman6> and Integer
05:12:00 <Axman6> [minBound,maxBound] :: Integer
05:12:07 <Axman6> > [minBound,maxBound] :: Integer
05:12:08 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
05:12:15 <Axman6> > [minBound,maxBound] :: [Integer]
05:12:16 <lambdabot>   add an instance declaration for (Bounded Integer)
05:12:16 <lambdabot>     In the expression: mi...
05:12:18 <Botje> :)
05:12:23 <Axman6> heh, excellent
05:12:24 <Botje> Integer knows no bounds!
05:12:28 <Axman6> :o
05:12:43 <Axman6> thar be dragons thar!
05:13:53 <Axman6> anyone know how functions like sin are actually written?
05:14:18 <Axman6> (in any language really, C would proobably be most helpful)
05:14:30 <rwbarton> Using the processor's sin instruction I think
05:14:51 <Axman6> heh, ok. any idea how that works?
05:15:08 <ivanm> magic!
05:15:12 <Axman6> oh good
05:15:16 <Botje> Axman6: lookup tables are cheap
05:15:19 <ayumilove1> > [125..]::[Int8]
05:15:20 <lambdabot>  [125,126,127]
05:15:22 <Axman6> yeah
05:15:25 <ayumilove1> > [125..]::[Float8]
05:15:25 <Botje> but taylor approximation works too
05:15:26 <lambdabot>   Not in scope: type constructor or class `Float8'
05:15:32 <ayumilove1> > [125..]::[Double8]
05:15:33 <lambdabot>   Not in scope: type constructor or class `Double8'
05:15:36 <ayumilove1> o_o
05:15:49 <Botje> there's no such thing, i tell you :)
05:15:53 <rwbarton> Float8, heh
05:15:59 <Axman6> i was reading yesterday about the pentium lookup table bug
05:16:21 <Twey_> > 127 :: Int8
05:16:22 <lambdabot>  127
05:16:24 <Twey_> > 128 :: Int8
05:16:25 <lambdabot>  -128
05:16:32 <Twey_> Overflow.  Nice.
05:16:45 <ayumilove1> > 1 :: Int8
05:16:47 <lambdabot>  1
05:16:51 <ayumilove1> > -1 :: Int8
05:16:53 <lambdabot>  -1
05:16:58 <ayumilove1> > -128 :: Int8
05:16:59 <lambdabot>  -128
05:17:00 <Twey_> Thought it might throw an error.
05:17:06 <ayumilove1> > 128 :: Int8
05:17:07 <lambdabot>  -128
05:17:14 <ayumilove1> why my 128 becomes -128
05:17:36 <Axman6> it's 1000000
05:17:37 <Botje> as i said, it's a signed 8 bit number
05:17:42 <Axman6> 10000000*
05:17:47 <ayumilove1> what is 8 bit number?
05:17:48 <Axman6> which is -128
05:17:51 <ayumilove1> 128/8?
05:17:52 <Twey_> ayumilove1: http://en.wikipedia.org/wiki/Arithmetic_overflow
05:17:52 <lambdabot> Title: Arithmetic overflow - Wikipedia, the free encyclopedia
05:19:03 <Axman6> ayumilove1: do you know how numbers are representewd in binary?
05:19:03 <Axman6> -w
05:19:48 <Axman6> > maxBound :: Double
05:19:49 <lambdabot>   add an instance declaration for (Bounded Double)
05:19:49 <lambdabot>     In the expression: max...
05:19:54 <Axman6> :o
05:20:08 <Axman6> > maxBound :: Float
05:20:09 <lambdabot>   add an instance declaration for (Bounded Float)
05:20:09 <lambdabot>     In the expression: maxB...
05:20:13 <Deewiant> > showIntAtBase 2 intToDigit 16 ""
05:20:14 <lambdabot>  "10000"
05:20:16 <pozic> What form does a newtype need to have so that newtype deriving works for MonadTrans?
05:20:32 <Deewiant> Axman6: floats aren't bounded since they can represent infinity
05:20:35 <BONUS> > maxBound (4::Int)
05:20:36 <lambdabot>   add an instance declaration for (Bounded (Int -> a))
05:20:43 <BONUS> what the heck!!!
05:20:47 <Deewiant> ?ty maxBound
05:20:47 <lambdabot> forall a. (Bounded a) => a
05:20:52 <Deewiant> > maxBound :: Int
05:20:53 <lambdabot>  2147483647
05:20:57 <BONUS> oooh
05:20:57 <Axman6> Deewiant: so infinity isn't the bound?
05:20:58 <BONUS> i see
05:21:07 <BONUS> lol
05:21:07 <BONUS> stupid me
05:21:18 <Twey_> Axman6: That's basically what's meant by 'unbounded' :)
05:21:25 <Axman6> pfft
05:21:25 <Deewiant> Axman6: well, they can't represent every value between their "practical maximum" and infinity
05:22:10 <Axman6> argh, it's so cold!
05:22:20 <Axman6> it was -4 to 5C today
05:22:31 <Axman6> 2.7C right now
05:22:35 <Deewiant> that's not very cold :-)
05:22:47 <Axman6> it is if you're australian :P
05:23:01 <Axman6> even if i have lived here all my life, it's damn cold!
05:23:16 <Deewiant> below -20 is cold
05:23:27 <Axman6> the LHC is cold
05:24:02 <Axman6> http://www.boston.com/bigpicture/2008/08/the_large_hadron_collider.html some damn impressive pictures for anyone interested
05:24:03 <lambdabot> Title: Large Hadron Collider nearly ready - The Big Picture - Boston.com, http://tinyurl.com/5ov94h
05:24:53 <Axman6> > return 10 :: Maybe
05:24:53 <lambdabot>      `Maybe' is not applied to enough type arguments
05:24:53 <lambdabot>     Expected kind `?', b...
05:25:04 <Axman6> > return 10 :: Maybe Integer
05:25:05 <Deewiant> > return 10 :: Maybe Int
05:25:06 <lambdabot>  Just 10
05:25:06 <lambdabot>  Just 10
05:25:15 <Twey_> Deewiant: ... in Fahrenheit!
05:25:29 <Axman6> > return 2147483647 :: Maybe Integer
05:25:31 <lambdabot>  Just 2147483647
05:25:35 <Axman6> > return 2147483648 :: Maybe Integer
05:25:36 <lambdabot>  Just 2147483648
05:25:36 <Axman6> even
05:25:41 <Axman6> > return 2147483648 :: Maybe Int
05:25:43 <lambdabot>  Just (-2147483648)
05:28:07 <Axman6> @src (>>)
05:28:08 <lambdabot> m >> k      = m >>= \_ -> k
05:28:22 <Axman6> @src (>>=)
05:28:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:30:57 <ziman> Axman6, (>>=) is defined for each monad separately (and differently)
05:31:08 <Axman6> oh yeah, right
05:31:16 <Axman6> @src (>>=) :: Maybe a
05:31:16 <lambdabot> Source not found. You speak an infinite deal of nothing
05:31:23 <ziman> @src Maybe (>>=)
05:31:23 <lambdabot> (Just x) >>= k      = k x
05:31:23 <lambdabot> Nothing  >>= _      = Nothing
05:31:28 <ziman> @src [] (>>=)
05:31:28 <lambdabot> xs >>= f     = concatMap f xs
05:31:46 <ziman> @src ((->) e) (>>=)
05:31:46 <lambdabot> Source not found. Where did you learn to type?
05:32:26 <Axman6> [1..10] >>= (+1)
05:32:31 <Botje> f >>= g = \r -> f r (g r)
05:32:34 <Axman6> > [1..10] >>= (+1)a
05:32:35 <lambdabot>  Couldn't match expected type `t -> [b]'
05:32:40 <Axman6> > [1..10] >>= (+1)
05:32:41 <lambdabot>   add an instance declaration for (Enum [b], Num [b])
05:33:06 <Axman6> > [1..10] >>= ((+1):[])
05:33:07 <lambdabot>  Couldn't match expected type `t -> [b]'
05:33:11 <Axman6> meh
05:33:20 <ziman> > [1..10] >>= ((:[]) . (+1))
05:33:21 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:34:20 <ziman> the list monad is useful for nondeterministic computations
05:34:30 <ziman> and a fancy powerset definition
05:34:43 <ziman> > filterM (const [True, False]) [1..5]
05:34:44 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
05:34:55 <thoughtpolice> i still don't totally get the list monad
05:35:08 * thoughtpolice is a bad haskeller :(
05:36:00 <olsner> @quote list
05:36:00 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
05:36:08 <olsner> @quote list
05:36:08 <lambdabot> ghc says: Can't match unequal length lists
05:37:39 <vixey> > mapM (const [True, False]) [1..5]
05:37:40 <lambdabot>  [[True,True,True,True,True],[True,True,True,True,False],[True,True,True,Fals...
05:37:52 <vixey> > mapM (\x ->  [(x,True), (x,False)]) [1..5]
05:37:53 <lambdabot>  [[(1,True),(2,True),(3,True),(4,True),(5,True)],[(1,True),(2,True),(3,True),...
05:38:22 <vixey> > filterM (const  [True, False]) [1..5]
05:38:23 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
05:38:55 <vixey> > sequence ["abc","xyz","123"]
05:38:56 <lambdabot>  ["ax1","ax2","ax3","ay1","ay2","ay3","az1","az2","az3","bx1","bx2","bx3","by...
05:41:03 <lambdapants> something that may amuse you:
05:41:03 <lambdapants> compiling Data.Derive on my vserver led to an excessive use of memory, not only destroying my server, but half of the subnet including http://linuxvps.org.  in essence, I used ghc to shut down a datacentre.
05:41:07 <lambdabot> Title: Linux VPS
05:41:14 <ayumilove1> @seen arnar
05:41:15 <lambdabot> arnar is in #haskell. I don't know when arnar last spoke.
05:41:24 <ayumilove1> @seen vixey
05:41:24 <lambdabot> vixey is in #scala, #perl6, #haskell and ##logic. I last heard vixey speak 2m 29s ago.
05:41:39 <byorgey> lambdabot: impressive!
05:41:50 <byorgey> er, lambdapants =)
05:42:11 <thoughtpolice> lambdapants: nice
05:43:12 <byorgey> seems like a pretty poor setup if excessive memory use on one virtual server can take down a whole datacentre, though...
05:43:17 <Axman6> lambdabot: i cn h4z codz 4 2 do dis?
05:43:22 <Axman6> uhm, lambdapants
05:43:28 <byorgey> you'd think they would have safeguards to prevent those sorts of things
05:43:33 <lambdapants> That's what I thought1
05:43:56 <lambdapants> surely a user level process on one computer should not be able to shut down everything including the webserver!
05:44:10 <lambdapants> maybe they wrote it all in bash and awk and it runs in their garage.
05:44:58 <lambdapants> oh theres programming language snobbery again, I apologise
05:44:58 <byorgey> that's...kinda what it looks like, judging by their website =)
05:45:34 <vixey> lambdapants: Don't worry, You'll see what happens when somebody mentions java
05:45:51 <pozic> lambdapants: most operating systems can be brought down by a user other than root.
05:46:25 <lambdapants> pozic: I have never tried ;)
05:47:52 <Axman6> vixey: is it bad that after using java for only a little while, i no longer hate it?
05:48:18 <vixey> Axman6: Just means you're at least slightly sensible
05:48:27 <byorgey> Axman6: no, that's normal.  it's after using it for more than a little while that you start to hate it.
05:48:34 <Axman6> heh, ok, good
05:48:41 <chrisdone> chr1s: your runFormState takes an action Monad m => Form xml m a, but then inside you use evalState. how are other monads supposed to run inside it? can you explain this please?
05:49:01 <ayumilove1> even[1..25]
05:49:04 <ayumilove1> > even[1..25]
05:49:05 <lambdabot>   add an instance declaration for (Integral [t])
05:49:05 <lambdabot>     In the expression: even ...
05:49:08 <Axman6> our Java assignment this term is to write one of three games. my friend and i are going to do asteroids, which should be fun
05:49:11 <ayumilove1> > Integeral even[1..25]
05:49:12 <lambdabot>   Not in scope: data constructor `Integeral'
05:49:20 <ayumilove1> > filterl even[1..25]
05:49:21 <lambdabot>   Not in scope: `filterl'
05:49:22 <Axman6> > filter even [1..25]
05:49:23 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24]
05:49:25 <ayumilove1> > filter even[1..25]
05:49:27 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24]
05:49:30 <chrisdone> chr1s: I'd expect runStateT
05:49:35 <ayumilove1> > map even[1..25]
05:49:37 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
05:49:41 <ayumilove1> oh ok
05:50:02 <ayumilove1> filter (<2)[1..25]
05:50:05 <byorgey> Axman6: nice.  I suppose I shouldn't tell you that there's a version of asteroids on hackage already. ;)
05:50:07 <ayumilove1> > filter (<2)[1..25]
05:50:09 <lambdabot>  [1]
05:50:32 <byorgey> Axman6: and even if I did tell you, that's no reason you can't write your own of course =)
05:50:40 <Axman6> byorgey: probably wouldn't make much difference, being java n' all
05:50:48 <ayumilove1> > sum[1..25]
05:50:49 <lambdabot>  325
05:50:57 <byorgey> oh! I... completely missed the 'Java' part of your sentence =)
05:51:03 <Axman6> heh
05:51:08 <ayumilove1> hmm
05:51:10 <ayumilove1> guys
05:51:14 <byorgey> hi ayumilove1
05:51:22 <ayumilove1> what are the other prhases that i can use for list? like sum , product
05:51:29 <ayumilove1> > product [1..25]
05:51:30 <lambdabot>  15511210043330985984000000
05:51:36 <ayumilove1> > division[1..25]
05:51:37 <lambdabot>   Not in scope: `division'
05:51:45 <ayumilove1> > subtraction[1..25]
05:51:46 <lambdabot>   Not in scope: `subtraction'
05:51:56 <byorgey> well, there are folds
05:52:04 <Axman6> > foldl1 (/) [1..25]
05:52:05 <lambdabot>  6.446950284384474e-26
05:52:08 <byorgey> > foldl' (-) 0 [1..25]
05:52:09 <Axman6> whoot
05:52:09 <lambdabot>  -325
05:52:14 <lambdapants> I wrote half a multiplayer game in haskell..... with random maps, and "a star" and all sorts of crap.  But it needs a 3d engine to be cool and i wrote most of it while stoned so it's about 2000 lines
05:52:28 <Axman6> lol
05:52:32 <Axman6> > foldl1 (/) [1..100]
05:52:33 <lambdabot>  1.071510288125467e-158
05:52:39 <byorgey> > concatMap (\n -> replicate n n) [1..25]
05:52:41 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
05:52:46 <ayumilove1> >@src foldl
05:52:50 <ayumilove1> > @src foldl
05:52:51 <lambdabot>  Parse error at "@src" (column 1)
05:52:55 <ayumilove1> > @src fold
05:52:55 <lambdabot>  Parse error at "@src" (column 1)
05:52:59 <ayumilove1> o_O
05:53:00 <Axman6> @src foldl1
05:53:00 <lambdabot> foldl1 f (x:xs) = foldl f x xs
05:53:00 <lambdabot> foldl1 _ []     = undefined
05:53:09 <Axman6> @src foldl
05:53:10 <lambdabot> foldl f z []     = z
05:53:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:53:21 <Axman6> @src foldr
05:53:22 <lambdabot> foldr f z []     = z
05:53:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:53:33 <ayumilove1> @src foldr
05:53:33 <lambdabot> foldr f z []     = z
05:53:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:53:38 <ayumilove1> oh
05:53:42 <ayumilove1> @src foldr
05:53:43 <lambdabot> foldr f z []     = z
05:53:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:53:46 <ayumilove1> ah i see
05:53:51 <ayumilove1> when using @, we dont need >
05:54:00 <Axman6> yes
05:54:05 <ayumilove1> no one told me -_-
05:54:10 <Axman6>  > evaluates a haskell expression
05:54:20 <Axman6> @ is used for lambdabot commands
05:54:49 <vixey> @run 1+1
05:54:50 <lambdabot>  2
05:54:51 <ayumilove1> anyone used php and asp before?
05:55:07 <ayumilove1> to make website
05:55:07 <vixey> ayumilove1: I have used PHP but not ASP
05:55:26 <ayumilove1> i would like to make a simple website, but dont know which 1 to choose,
05:55:34 <chrisdone> use haskell, duh
05:55:34 <ayumilove1> many say php is free
05:55:39 <ayumilove1> haskell for website o_O
05:55:40 <Axman6> it is
05:55:43 <vixey> ayumilove1: to be quite honest I suggest not using either
05:55:50 <chrisdone> !!Haskell For Web Site!!
05:55:53 <ayumilove1> visey recommendation?
05:55:58 <Axman6> yeah, neither are all that easy
05:55:59 <vixey> ayumilove1: common lisp
05:56:01 <lambdapants> I've known php for years and I'd rather write a website with my arse.
05:56:16 <kryptiskt> all the cool kids are using ruby now
05:56:18 <ayumilove1> common lisp, is it popular?
05:56:33 <ayumilove1> ruby is for website?
05:56:35 <chrisdone> kryptiskt: haskell kids were cool before cool was cool
05:56:36 <lambdapants> ruby on rails is good if you are new to web development
05:56:39 <vixey> ayumilove1: ruby sucks
05:56:59 <ayumilove1> what makes common lisp > php asp.net
05:57:04 <vixey> >> x = 666; puts "x was #{x}"; 1.times {|x| 2}; puts "x is #{x}"
05:57:04 <vixey> x was 666
05:57:04 <vixey> x is 0
05:57:16 <lambdapants> vixey: you're right.  why do blocks have to be the last argument to a method??? why not have first class functions???
05:57:33 <vixey> ayumilove1: because it sucks less
05:57:43 <ayumilove1> thats not a very good reason ^_^ "
05:57:56 <chrisdone> "not sucking less" is the best reason to use anything
05:58:03 <chrisdone> uh, s/not//
05:58:03 <vixey> I thought it was a good reason
05:58:04 <Axman6> i didn't find rails all that easy to use actually
05:58:08 <Axman6> it confused me -_-
05:58:17 <lambdapants> I think the people at edinburgh university make a version of lisp for web development... theres others too
05:58:20 <Axman6> i don't like i when i'm learning something, and i suddenly fit a wall
05:58:37 <ayumilove1> you mean hit a wall?
05:58:40 <ivanm> chrisdone: why isn't it? surely you'd use the tool that is least unsuitable for the job?
05:58:44 <chrisdone> yeah, I read the first page of Why's annoying tutorial and decided it would be less laborous to write a library for haskell
05:58:48 <Axman6> speaking of lisp: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/ is pretty cool
05:58:50 <ivanm> lambdapants: you mean wadler's links project?
05:58:53 <lambdapants> Axman6: I like ruby on rails for simple apps, but I tried to write an extension to active record once and it was like brushing my teeth with a rake.
05:58:54 <ivanm> it's not lisp IIRC...
05:59:36 <Axman6> chrisdone: i was quite entertained by Why's thing actually
05:59:37 <chrisdone> ivanm: I said "sucking the least" is the best reason to use anything
05:59:50 <chrisdone> Axman6: well, I'd expect some people would be
06:01:16 <kryptiskt> I do my web programming in C (no, I'm not perverted, I do embedded stuff :-))
06:01:50 <lambdapants> that's a fine like lryptiskt :p
06:02:27 <lambdapants> you mean, for the web apps that run on routers and stuff?
06:02:39 <chrisdone> chr1s: ping?
06:03:01 <kryptiskt> configuration pages for devices you can attach to your LAN.
06:03:08 <ayumilove1> > print 1
06:03:10 <lambdabot>  <IO ()>
06:03:13 <ayumilove1> > print 2
06:03:14 <lambdabot>  <IO ()>
06:03:19 <ayumilove1> what does it mean?
06:03:23 <chrisdone> the same happens for `print 3'
06:03:27 <ayumilove1> print2
06:03:27 <tibbe_> which one i preferred: c2hs or hcs@hs ?
06:03:29 * Twey_ laughs.
06:03:30 <chrisdone> it means `print x' is an IO action
06:03:30 <lambdapants> most interesting :)
06:03:31 <ayumilove1> > print2
06:03:32 <lambdabot>   Not in scope: `print2'
06:03:39 <ivanm> chrisdone: ahh, I misread your s/not// as you saying that it _isn't_ the best reason :s
06:03:39 <ayumilove1> > print(2)
06:03:39 <Twey_> ayumilove1: It means you're getting an IO monad back.
06:03:40 <tibbe> I need to wrap C structs using FFI
06:03:40 <lambdabot>  <IO ()>
06:03:47 <idnar> @hoogle Integer -> Char
06:03:47 <lambdabot> No matches, try a more general search
06:03:51 <Twey_> Which is what's expected.
06:03:54 <ayumilove1> Twey_ what is an IO monad?
06:03:56 <idnar> @hoogle Int -> Char
06:03:57 <lambdabot> Data.Char.intToDigit :: Int -> Char
06:03:57 <lambdabot> Data.Char.chr :: Int -> Char
06:03:57 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
06:03:57 <lambdapants> I'm away! time to try happs without crashing the data-centre again......
06:04:05 <kryptiskt> tibbe. c2hs is your friend
06:04:21 <tibbe> kryptiskt: what are the pros/cons vs hcs2hs?
06:04:29 <Twey_> ayumilove1: http://www.haskell.org/haskellwiki/Introduction_to_IO
06:04:30 <lambdabot> Title: Introduction to IO - HaskellWiki
06:04:41 <ayumilove1> thanks twey!
06:04:52 <ayumilove1> imma rest ^_^
06:05:21 <chrisdone> twey: you make people sleepy
06:05:23 <kryptiskt> tibbe. eh, I know it better. I guess that's not a good reason...
06:05:31 <tibbe> ok
06:06:10 <tibbe> is it c2hs that the SoC guy is extracting the C API from?
06:17:09 <Axman6> > sqrt(2) + log 5 - 1 / (3 + sqrt(7))
06:17:10 <lambdabot>  2.846527130339491
06:18:05 <Axman6> > (sqrt(2) + log 5 - 1 / (3 + sqrt(7)))**2
06:18:06 <lambdabot>  8.102716703758777
06:18:26 <ski> > exp pi - pi
06:18:27 <lambdabot>  19.999099979189474
06:18:33 <feifei> > 1+1
06:18:34 <lambdabot>  2
06:24:29 <heavensrevenge> hello
06:27:02 <Axman6> o/
06:27:15 <esteth> Does anyone know if there's a debian package for Graphics.UI.GLUT? I've got the Graphics.Rendering.OpenGL one, but I'd rather not go from source if I can help it.
06:29:25 <gwern> libghc6-glut-dev ?
06:30:01 <esteth> D'oh. I can't beleive I didn't see that in my apt-cache search! Thanks a lot :)
06:30:47 <pozic> gwern: HList on Hackage does not export Data.HList even though it is the exposed modules list.
06:33:39 <dafra> anyone using archlinux out there ?
06:35:07 <gwern> pozic: dunno, darcs hlist exports Data.HList fine for me
06:35:18 <esteth> dafra, I have it on my laptop
06:35:21 <gwern> dafra: annoyingly many of you arch users, yes
06:35:33 <dafra> esteth: how did you install it ?
06:35:44 <dafra> esteth: ftp install failed for me
06:35:52 <esteth> I used the offline installation
06:36:00 <dafra> esteth: dependency cycle, something like that
06:36:12 <dafra> esteth: i shold try it then
06:36:34 <esteth> Once it's installed and you're online, a pacman -Syu will get you up to date anyway
06:36:36 <TomMD> dafra: There is alsa #arch-haskell, just fyi
06:36:53 <pozic> gwern: yes, but the darcs version does not export firstLabel.
06:37:28 <dafra> TomMD: the is #archlinux too, but myproblems do not interest them at all !
06:37:35 <gwern> does it make sense to? it's defined in multiple places
06:38:15 <TomMD> dafra: As a rule, arch users don't seem interested in helping with problems.  They seem to try hard to maintain the RTFM / do it yourself environment.
06:38:19 <pozic> gwern: how do you make a record with that library?
06:38:29 <gwern> I have no idea
06:38:37 <pozic> gwern: the examples from the paper don't work, since they depend on first label. Ok.
06:38:43 <esteth> #archlinux was very helpful with my wireless problem :)
06:38:50 <pozic> firstLabel*
06:39:27 <TomMD> esteth: I am speaking only from my one experience, of coarse.  Glad to see it isn't always so.
06:39:56 <dafra> TomMD: does the overlay work only with x86_64 ?
06:40:07 <dafra> TomMD: haskell overlay
06:43:36 <thoughtpolice> yes, when I used arch they were also very helpful with a few of the problems I had
06:45:03 <vixey> it says "The workaround is to register at least one package in the user package db"
06:45:08 <vixey> how do you do that with ghc-pkg?
06:46:50 <byorgey> vixey: workaround for what?
06:47:04 <thoughtpolice> vixey: ghc head?
06:47:21 <thoughtpolice> uh, I can't quite remember how I got at least one thing registered with cabal there
06:47:39 <vixey> Configuring ivor-0.1.7...
06:47:40 <vixey> Setup.lhs: ghc-pkg describe * failed
06:47:46 <vixey> and it's called ghc bug #2201
06:47:53 <thoughtpolice> i poked around until I found a file somewhere that satisified the input necessary for 'ghc-pkg register'
06:48:06 <thoughtpolice> which is basically the output from ghc-pkg describe
06:48:07 <thoughtpolice> iirc
06:48:13 <int-e> find the supposed location of the package.conf file and write [] into the file
06:49:49 <dcoutts> thoughtpolice: we've fixed it in the darcs version of Cabal
06:50:06 <dcoutts> thoughtpolice: waern implemented support for ghc-pkg dump
06:50:41 <thoughtpolice> dcoutts: cool beans, maybe time to rebuild HEAD :)
06:53:55 <thoughtpolice> dcoutts: I was thinking of maybe tackling or working on some of the minor cabal/cabal-install bugs, I was wondering if you have any general working conventions you follow to make sure your stable stuff doesn't get cluttered up? (typically I just prefix the installation somewhere like ~/ghc-head)
06:54:10 <thoughtpolice> (with everything else in ~/bin)
06:54:41 --- mode: irc.freenode.net set +o ChanServ
07:02:52 <vixey> hey why does ghc use Makefiles and all that crap?
07:02:57 <lambdapants> greetings fair citizens
07:03:20 <lambdapants> anyone got happs working on debian?
07:05:53 <lambdapants> I run my app in ghci.  It loads the packages, then segfaults before I can type anything.
07:07:47 <vixey> ok
07:07:52 <lambdapants> the weirdest thing is, I can actually run a happs application
07:07:54 <vixey> this is the full error message,
07:07:54 <vixey> cabal-bin: ghc-pkg describe * failed. If you are using ghc-6.9 and have an
07:07:55 <vixey> empty user package database then this is probably due to ghc bug #2201. The
07:07:55 <vixey> workaround is to register at least one package in the user package db.
07:08:03 <vixey> How do you solve it?
07:08:31 <vixey> inside ghc-6.9.20080719/libraries/bootstrapping.conf is just:  []
07:08:42 <lambdapants> sounds disgusting.... over my head anyway
07:08:52 <dcoutts> vixey: that's now fixed in the latest Cabal
07:08:52 <dcoutts> vixey: or use the workaround it suggests
07:09:15 <vixey> Can I install the latest cabal and this will just disappear?
07:09:22 <vixey> oh
07:09:26 <vixey> I don't know how to do the workaround
07:10:27 <vixey> dcoutts, does that mean:  darcs get --partial http://darcs.haskell.org/cabal/
07:10:28 <vixey> ?
07:10:28 <lambdabot> Title: Index of /cabal
07:11:05 <dino-> I have a couple of questions about cabal. I've been using the 1.2.3.0 that came with ghc 6.8.2. But I see shiny cli examples showing usage of cabal-setup instead of `runhaskell Setup.lhs` or similar. I don't seem to have that program, cabal-setup..
07:11:05 <ertai> I've written a parsec parser and the error message seems a little obsucure "expecting white-space, carriage return followed by linefeed, comment or <some>" since I don't have tokens and layouts, so no comments...
07:11:09 <thoughtpolice> if you just do ./darcs-all pull -a in the head's ./ it should pull the latest cabal for you
07:11:34 <dino-> Is it fairly safe for me to just install something stable like 1.4.0.1 and run with that?
07:11:43 <vixey> I don't have darcs-all
07:11:44 <thoughtpolice> dino-: install cabal 1.4.0.1
07:11:45 <Axman6> @src quot
07:11:45 <lambdabot> Source not found. That's something I cannot allow to happen.
07:11:52 <vixey> So I must get GHC from darcs instead of HEAD
07:11:53 <thoughtpolice> then you can build and use cabal-install
07:11:54 <vixey> ?
07:12:09 <thoughtpolice> vixey: if you pulled GHC from darcs i.e. http://darcs.haskell.org/ghc or whatever
07:12:09 <dcoutts> vixey: were you using the latest darcs HEAD ? If so I guess that means the fix hasn't migrated into the branch of Cabal that ghc uses yet, and you'd have to use the HEAD branch of Cabal which is not guaranteed to work with ghc.
07:12:10 <lambdabot> Title: Index of /ghc
07:12:13 <thoughtpolice> it should have the darcs all script
07:12:28 <thoughtpolice> dcoutts: oh? hm
07:12:32 <vixey> :SS....
07:12:44 <dcoutts> dino-: it's not cabal-setup. The cabal-install package provides a command line program 'cabal'.
07:14:40 <dino-> dcoutts: Ok. I only mentioned it after seeing it in Cabal docs like: "The type of build used by this package. Build types are the constructors of the BuildType type, defaulting to Custom. If this field is given a value other than Custom, some tools such as cabal-setup will be able to build the package without using the setup script."
07:15:10 <dino-> So, I should get cabal 1.4.0.1 and cabal-install 0.5.1 ?
07:15:24 <dcoutts> dino-: yep, I've updated the docs to refer to cabal-install (which replaces the earlier cabal-setup)
07:15:30 <dcoutts> dino-: yes.
07:15:39 <dino-> Great, thank you.
07:17:36 <dino-> btw, the data-files and data-dir thing is very cool with the Paths_<pkg> module. We had something similar to this way back in Java for locating static resources stored in .jar files. It's very civilized to have this ability to locate data files without resorting to something creepy like finding the bin path at runtime.
07:18:18 <dcoutts> dino-: :-)
07:18:24 <dino-> Which still may not even help you if data is stored far away, like not near /usr/share/bin or whatever
07:26:43 <lambdapants> I have a really odd problem
07:27:14 <TomMD> If I use a different compiler with cabal (ex: hugs instead of ghc) will cabal atomatically change the library locations accordingly?
07:29:50 <lambdapants> In ghci I can type
07:29:50 <lambdapants> simpleHTTP nullConf [ method GET $ ok $ toResponse "hiya!" ] and it'll work just fine
07:29:56 <vixey> yeah we should replace build systems with AIs
07:30:07 <vixey> maybe they can figure out all these silly workarounds and such for you
07:30:07 <lambdapants> but if I put it in a file and ask ghci or ghc to compile it, I get a segmentation fault
07:33:19 <thoughtpolice> lambdapants: does GHC seg fault or does the resulting application?
07:33:28 <lambdapants> ghc segfaults
07:33:35 <lambdapants> wait, I wasn't quite accurate there
07:33:42 <lambdapants> but theres still something weird afoot!
07:33:45 <lambdapants> wait a wee second...
07:33:57 <thoughtpolice> lambdapants: can you paste the result of trying to compile with ghc --make?
07:34:13 <thoughtpolice> if GHC throws some 'impossible' err or it actually segfaults then it is a bug that needs to be reported
07:34:15 <dino-> TomMD: There is a switch for configure: --ghc, --nhc, --hugs
07:35:08 <lambdapants> oooh, I get a different error sometimes...
07:35:22 <dino-> I'm no cabal-master, but this seems like in the neighborhood of setting up to build against the proper things.
07:35:38 <lambdapants> sorry for noobing but please remind me how to pastebin again
07:35:45 <dcoutts> @hpaste
07:35:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:35:49 <lambdapants> thankyou
07:36:24 <dcoutts> TomMD: the default install paths depend on the compiler you configure with.
07:36:47 <dino-> TomMD: The docs say this defaults to the impl under which the script was compiled or interpreted. i.e. what runhaskell just pointed to to run Setup.[l]hs
07:36:52 <lambdapants> http://hpaste.org/9514
07:37:14 <dcoutts> TomMD: and doing configure again (eg with a different compiler) forgets any previous configuration you used (including any manually specified paths etc)
07:37:43 <dino-> dcoutts: ah, no need to clean explicitly to re-configure. Good to know
07:37:52 <dcoutts> right
07:38:02 <dcoutts> and you can clear without cleaning the config too
07:38:07 <dcoutts> erm clean
07:38:26 <dino-> Oh? I need that kind of often.
07:38:32 <dcoutts> cabal clean -s or --save-configure
07:38:34 <dcoutts> see --help
07:38:35 <thoughtpolice> run clean with the -s option
07:38:37 <dino-> nice!
07:38:57 <dcoutts> some people think that should be the default
07:39:43 <dino-> I almost want to say this is what's meant sometimes by clean vs distclean
07:39:59 <dino-> But that sounds like not a good analogy maybe
07:40:04 <dino-> dist != configuration
07:40:09 <chrisdone> chr1s: ping
07:40:55 <dino-> But yeah, I guess I would lean towards it being keep config as default, switch for more serious clean blowing away config
07:41:15 <dino-> Regardless, it's good to have the option now. yay
07:43:49 <vixey> How does GHC build process work?
07:43:53 <lambdapants> here's a ghc error http://hpaste.org/9515a
07:44:27 <lambdapants> sorry http://hpaste.org/9515
07:44:43 <chrisdone> vixey: it conjures the spirits of the computer with its spells
07:45:36 <lambdapants> I believe it translates the normal haskell you write into just let and case statements, then to c, then to assembler
07:45:39 <TomMD> dcoutts: Thanks!  I see GHC, NHC, Hugs and JHC are all supported.  Can't wait to see more compilers added to the mix as they become available.
07:46:00 <EvilTerran> "KillerSmurf"?!
07:46:43 <dino-> So, to clarify, the cli tool 'cabal' is part of cabal-install and it uses your Cabal registered with the compiler. And I can do things like `cabal configure` `cabal build` and so on now instead of runhaskell Setup.hs ?
07:47:16 <lambdapants> EvilTerran: I thought KillerSmurf was a fine name for a functional programming journal :p
07:47:20 <thoughtpolice> lambdapants: are you using ghc 6.6 or ghc 6.8? the native code gen is the default for 6.8 and it skips the entire 'generate C' stage
07:47:25 <TomMD> dino-: I think thats correct except the Cabal used is statically linked when you compile cabal-instal.
07:47:28 <dino-> There are no longer things like cabal-install and cabal-setup CLI tools?
07:47:31 <thoughtpolice> dino-: yes
07:47:46 <chrisdone> EvilTerran: ‽
07:47:46 <thoughtpolice> dino-: yes, everything has been merged into cabal-install
07:47:50 <thoughtpolice> as well there is also cabal-upload
07:47:54 <thoughtpolice> and other various things
07:48:03 <TomMD> cabal upload is a great time saver.
07:48:09 <thoughtpolice> TomMD: seriously
07:48:11 <EvilTerran> chrisdone, er, what?
07:48:12 <dino-> Ok. Thank you.
07:48:15 <dino-> This is great stuff
07:48:30 <chrisdone> EvilTerran: the interrobang is the pinnacle of optimisation
07:48:35 <lambdapants> thoughtpolice: I'm using 6.8, but actually I was attempting to answer vixey's question which you have now so well answered.
07:48:46 <EvilTerran> chrisdone, ah, i see. not when my font doesn't have it, unfortunately =/
07:49:04 <lambdapants> Anyone got a clue how I broke ghc?  the debian packages must be ge******en.
07:49:28 <chrisdone> EvilTerran: oh ;_;
07:51:41 <guenni> hi, anybody doing lots of FFI stuff?
07:53:20 <dino-> And at this time `cabal install <FOO>` doesn't do this progression of targets: configure build test haddock install  ?
07:53:37 <chr1s> chrisdone: pong
07:53:43 <gwern> doesn't do haddock
07:53:44 <gwern> really, yet
07:53:47 <thoughtpolice> dino-: it will do all that if you use it to install something off hackage
07:54:01 <thoughtpolice> i.e. 'cabal install hnop' or whatever
07:54:06 <thoughtpolice> if you are in a local dir, then no
07:54:07 <gwern> dino-: I mean, it'll do haddock soon, hopefully. pieces are being put into place recently
07:54:41 <thoughtpolice> it can't generate haddock docs automatically for things installed off hackage, although if you're using cabal to replace the whole 'runhaskell Setup...' stuff you can do 'cabal haddock' and it'll take care of it
07:55:31 <dino-> hm, but the resulting haddock docs get installed (I thought) during the install target
07:55:46 <dino-> But the point maybe is: this stuff is being worked on now
07:56:13 <thoughtpolice> dino-: no, haddock is explicit
07:57:03 <dino-> thoughtpolice: Huh, doing that command goes all the way out to writing into /usr/local/share/doc ?
07:57:11 <dino-> Sounds like it must be configured to know that location
07:57:25 <chrisdone> chr1s: hey. I don't understand how runFormState is supposed to be used, would it be possible to have e runFormStateT? it would be nice for a checkM function to read from file or a DB, if you see what I mean
07:58:42 <dcoutts> thoughtpolice: darcs version of cabal-install has --enable-documentation (ie generates haddock docs)
07:59:20 <chrisdone> dcoutts: cool
08:00:07 <gwern> dcoutts: did you add the configu option yet?
08:00:22 <dcoutts> thoughtpolice: btw, it does it in a local dir too, "cabal install" in a local dir will do configure, build and install for the current package (and download and install deps too)
08:00:28 <dcoutts> gwern: not to the config file
08:00:39 <gwern> bah
08:01:00 <gwern> is there no clever solution where adding an option automatically creates a CLI option and a config option?
08:01:00 <thoughtpolice> dcoutts: oh it does? how nice. :)
08:01:29 <thoughtpolice> i thought it would only do that for things of hackage
08:02:09 <chr1s> chrisdone: the runFormState gives you a tuple of three things:
08:02:27 <chr1s> an extractor function, which takes CGI input and gives you something of Failing a
08:02:50 <dcoutts> gwern: yes, there is a clever solution, which is half implemented
08:02:53 <chr1s> the resulting html (in case you're using Text.XHtml.Strict.Formlets
08:03:08 <gwern> oh the pain of knowing so close yet so far
08:03:16 * gwern tears up
08:03:17 <chr1s> and the form-encoding type (which changes if you use a file-input)
08:03:31 <dcoutts> gwern: mnislaih got 2/3rds of the way there.
08:03:50 <gwern> dcoutts: and then he got eaten by a grue?
08:03:54 <dcoutts> heh heh
08:03:59 <chr1s> chrisdone: so you just need to choose the right monad to read from the DB.
08:04:04 <mnislaih> gwern: what's up ?
08:04:10 <chr1s> dcoutts: how was the AngloHaskell presentation?
08:04:16 <chr1s> any slides?
08:04:23 <dcoutts> gwern, mnislaih: http://hackage.haskell.org/trac/hackage/ticket/223
08:04:25 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
08:04:26 <gwern> mnislaih: no haddock option in .cabal/config is what is up
08:04:32 <gwern> it makes me has a sad
08:04:34 <dino-> Ok. My situation is I'm working on kind of a large project in Haskell at work. I need to set up developer systems with the proper environment (which means I'd like them to have API docs too) and also servers that will run this software. It would be great to use `cabal install ...` to do the apt-like thing everywhere. But I do need local API docs most of the time.
08:05:09 <mnislaih> oh I should take a look at that gwern
08:05:12 <dcoutts> chr1s: it went well, there's audio. No slides, we only did a 10min demo.
08:05:22 <mnislaih> but I'm rather too busy now :S
08:05:28 <dino-> It sounds like at this time with cabal-install 0.5.1 I need to do the target steps manually to get haddock. I'm sorry to belabor this, but am still confused.
08:05:45 <chr1s> dcoutts: cool!
08:05:48 <gwern> dino-: I would personally write a shell script
08:06:15 <gwern> 'alias cabal-install="cabal install --enable-documentation'; cabal-install foo && cabal-install ...'
08:06:23 <chrisdone> chr1s: hmm, thanks. let me try it
08:06:29 <gwern> or wait, cabal install takes multiple package names, no?
08:06:45 <dino-> --enable-documentation is in 0.5.1?
08:06:47 <gwern> so I guess 'cabal install --enable-documentation foo bar baz quux...' would suffice
08:07:16 <dcoutts> dino-: that's correct. The 'cabal install --enable-documentation' will be in the next version.
08:07:58 <dcoutts> dino-: ie it'll be in 0.5.2, it's not in 0.5.1
08:08:08 <dino-> dcoutts: Ok
08:08:23 <dino-> gwern: I think I will make a shell script, yeah. For now.
08:09:08 <gwern> whoa, -Wall is not happy on cabal-install
08:09:42 <gwern> and haddock is broken on darcs cabal-install, hum
08:10:03 <dcoutts> gwern: released version or devel? released only has 2 -Wall warnings.
08:10:12 <BONUS> in head :: [a] -> a
08:10:14 <gwern> darcs if course
08:10:28 <BONUS> is it correct to say that a is a type parameter
08:10:33 <dcoutts> gwern: we hacked build reporting in for AngloHaskell demo, so no time to fix -Wall
08:10:36 <BONUS> or is it more correct to say its a polymorphic type
08:10:36 <vixey> BONUS: no
08:10:42 <vixey> BONUS: a is a type variable
08:10:46 <BONUS> oh yeah
08:10:47 <dcoutts> gwern: we got it working 10 min before our presentation :-)
08:10:56 <gwern> 'Distribution/Client/Dependency/Naive.hs:122:45: Kind error: `InstallPlan.PlanPackage' is applied to too many type arguments In the type `InstallPlan.PlanPackage a' In the type `[InstallPlan.PlanPackage a]' In the type `Progress String String [InstallPlan.PlanPackage a] <document comment>''
08:11:02 <gwern> dcoutts: did it go well?
08:11:15 <dcoutts> gwern: yes :-)
08:11:22 --- mode: irc.freenode.net set +o ChanServ
08:11:24 <gwern> any video?
08:11:30 <dcoutts> gwern: audio
08:11:53 <dcoutts> it was interactive, we had a server running on Lemmih's laptop and had people connect
08:12:12 <dcoutts> and demoed generating and uploading build reports, with build logs
08:13:25 <jinjing> what is the best way to purely generate a list of random Int, from a seed?
08:13:55 <dino-> Thanks again, everyone. For helping with my many questions.
08:14:12 <vixey> the best?
08:14:16 <vixey> :t random
08:14:18 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
08:14:21 <vixey> :t unfoldr random
08:14:29 <vixey> :t unfoldr
08:14:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:14:34 <dino-> lambdapants: If you're still having that problem: yikes. I've never seen that before in Debian. But I don't install it with apt for some time now.
08:14:36 <vixey> :t unfoldr (Just . random)
08:14:37 <lambdabot> forall a b. (RandomGen b, Random a) => b -> [a]
08:14:44 <vixey> :t take ?n . unfoldr (Just . random)
08:14:47 <lambdabot> forall a b. (RandomGen b, Random a, ?n::Int) => b -> [a]
08:15:10 <lambdapants> dino: I've managed to narrow it down.... happs is not the problem
08:15:17 <lambdapants> happs is the only part that works
08:15:18 <vixey> > take 6 . unfoldr (Just . random) 42
08:15:26 <vixey> > take 6 . unfoldr (Just . random) $ 42
08:15:26 <lambdapants> all other libraries cause segfault
08:15:29 <lambdabot>   add an instance declaration for (Random [a])
08:15:29 <lambdabot>  Add a type signature
08:15:33 <vixey> :/
08:15:53 <jinjing> :/
08:15:55 <lambdapants> I get a linker error trying to make the smallest application too... :(
08:16:29 <chrisdone> one is (take 6 . (unfoldr (Just . random) 42)) the other is ((take 6 . unfoldr (Just . random)) 42)
08:16:32 <lambdapants> not enough memory, sadly
08:16:54 <vixey> @hogle random
08:16:55 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
08:16:55 <lambdabot> System.Random :: module
08:16:55 <lambdabot> System.Random.Random :: class Random a
08:17:02 <chrisdone> ha, hogle?
08:17:19 <chrisdone> @tpe map
08:17:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:17:22 <chrisdone> haha
08:17:26 <EvilTerran> ?type \f -> unfoldr (Just . f)
08:17:27 <lambdabot> forall a b. (b -> (a, b)) -> b -> [a]
08:17:29 <vixey> > take 6 . unfoldr (Just . random) $ mkStdGen 42
08:17:30 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631]
08:17:39 <vixey> > take 6 . unfoldr (Just . random) $ mkStdGen 42 :: [Bool]
08:17:41 <lambdabot>  [True,True,True,False,False,True]
08:17:49 <vixey> > take 6 . unfoldr (Just . random) $ mkStdGen 42 :: [Either Bool Integer]
08:17:50 <lambdabot>        add an instance declaration for (Random (Either Bool Integer))
08:17:53 <vixey> boooo
08:18:15 <vixey> > take 6 . unfoldr (Just . random) $ mkStdGen 42 :: String
08:18:17 <lambdabot>  "\41423\368463\206725\161530\914412\1094711"
08:18:25 <vixey> > take 6 . filter alphanum . unfoldr (Just . random) $ mkStdGen 42 :: String
08:18:26 <lambdabot>   Not in scope: `alphanum'
08:19:46 <vixey> :t random
08:19:47 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
08:19:57 <jinjing> thanks vixey
08:20:26 <Deewiant> > take 10 $ randomRs (0,10) (mkStdGen 42)
08:20:28 <lambdabot>  [4,9,3,3,5,8,6,5,4,8]
08:21:12 <jinjing> thanks Deewiant
08:21:45 <Deewiant> > take 10 $ randoms (mkStdGen 2) :: [Int]
08:21:47 <lambdabot>  [-1154341369,688281713,1285055969,1919848627,429236652,-307810364,9606349,12...
08:23:34 <tibbe> I'm getting an error from hsc2hs when using #poke, anyone have experience using hsc2hs?
08:24:01 <Botje> try #prod or #jab instead :)
08:35:44 <TomMD> tibbe: Post some code, I've been using hsc2hs lately.
08:37:23 <tibbe> TomMD: http://hpaste.org/9516
08:37:36 <tibbe> TomMD: error at the bottom
08:40:02 <tibbe> TomMD: hmm, maybe I'm missing a "struct" keyword
08:40:57 <tibbe> TomMD: looks like that was it
08:40:58 <TomMD> That sounds like a good guess.  The hsc file itself looks good, so long as the .h file matches up properly
08:41:08 <TomMD> Good
08:45:32 <thoughtpolice> hi tibbe, working on your new io lib?
08:45:41 <tibbe> thoughtpolice: yes
08:46:03 <tibbe> TomMD: the hsc2hs example I looked at used a typedef for its struct which kevent doesn't
08:46:42 <TomMD> Yeah, I got that.  My xen bindings are mostly to typedefs, but I think there are one or two odd balls.
08:47:06 <gwern> dcoutts: still around? zooko has suggested a 'unix-compat' package, and I was wondering how that would work
08:47:35 <gwern> dcoutts: since darcs apparently reimplments a good chunk of 'unix' (System.Posix.*) but for windows, he thought it'd be useful to split those out
08:48:30 <Igloo> unix-compat already exists
08:48:39 <TomMD> ?hackage unix-compat
08:48:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix-compat
08:49:54 <gwern> TomMD: yeah, but that requires you change your imports
08:50:13 <gwern> I was thinking perhaps a true unix-compat would export the same exact modules as unix
08:50:20 <gwern> or maybe unix would be portable in and of itself
08:50:28 <gwern> (that'd be good for yi, among others)
08:56:16 <gwern> for every line of code you delete, god resurrects a kitten
08:56:23 <gwern> please, won't someone think of the kittens?
08:56:25 <adekoba> I'm having trouble getting a haskell program to work with bash shell pipes. What am I doing wrong? here's a pastebin: http://hpaste.org/9517
08:56:26 <esteth> When I try to use the -make option for ghc, it claims there is no -make flag. This is probably just me trying to follow along with a guide that's way out of date, but what flag, if any, replaces it in more recent versions of ghc?
08:56:34 <adekoba> esteth: --make
08:56:51 <esteth> adekoba, Ah, silly me. Thanks :)
08:56:56 <adekoba> yep :D
08:59:00 <Cale> adekoba: I'm guessing that the output is being buffered.
08:59:34 <adekoba> Cale: I'll try setting stdout to NoBuffering then?
08:59:36 <Cale> adekoba: add System.IO to the imports, and  hSetBuffering stdout NoBuffering  and see if that changes things.
08:59:37 <Cale> yeah
09:00:34 <adekoba> Cale: that's it! Thanks, man.
09:00:42 <Cale> No problem :)
09:02:19 <gwern> @seen bringert
09:02:19 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 2h 27m 9s ago, and .
09:02:43 <gwern> gah
09:05:03 <gwern> @ask bringert For unix-compat - have you looked at the emulation of System.Posix.Files & System.Posix.IO which Darcs has bundled in it under src/win32? it's giving me trouble cabalizing, and it'd be neat if unix-compat could be comprehensive and more drop-in. as it is, I can only use PosixCompat.Files
09:05:03 <lambdabot> Consider it noted.
09:05:06 <tibbe> TomMD: is it possible to wrap a macro using the FFI / hsc2hs?
09:06:10 <gwern> @tell bringert Oh, and darcs also does System.Posix, and something called CtrlC, though I don't know if that has a unix counterpart
09:06:11 <lambdabot> Consider it noted.
09:07:15 <thoughtpolice> tibbe: currently I do not think so.
09:09:19 <olsner> woah, *reverse* state monad?
09:09:41 <dmhouse> Etats?
09:10:02 <Botje> l'Etats, c'est moi.
09:10:11 <tibbe> thoughtpolice: darn
09:10:33 <vixey> why not have -O2 by default?
09:10:37 <thoughtpolice> tibbe: yeah, it generally means you have to duplicate a lot of shit because people are pretty keen on using macro's for that kind of stuff
09:10:47 <tibbe> thoughtpolice: yeah :(
09:10:48 <thoughtpolice> especially in things like system headers
09:10:53 <tibbe> yup
09:11:43 <thoughtpolice> plus it can totally screw backwards compatibility since those macros are there (generally) to hide the stuff that may change
09:11:47 <thoughtpolice> it would really be a nice feature
09:12:05 <tibbe> yeah
09:12:10 <thoughtpolice> i'm not sure if c2hs supports it either
09:12:34 <tibbe> probably not
09:12:53 <tibbe> I have basic bindings to kqueue now, lets see if they work :)
09:13:32 <tibbe> I need to get a file handle from a haskell Socket, hmm
09:13:37 <tibbe> file descriptor I mean
09:15:25 <thoughtpolice> there's the Fd type (newtype wrapped around CInt) in System.Posix.Types but I don't know if there's a function Handle -> Fd
09:16:49 <vixey> :/
09:17:07 <vixey> I don't understand this cabal stuff
09:17:16 <vixey> is this anything to do with ghc -package <name>
09:17:17 <mmorrow> a javascript quasiquoter: http://hpaste.org/9518
09:17:28 <mmorrow> :))))
09:17:43 <vixey> cool
09:17:53 <mmorrow> it uses the WebBits parser/prettyprinter
09:17:55 <vixey> mmorrow: I have lots of trouble trying to compile things
09:18:06 <mmorrow> vixey: uhoh. like what in particular?
09:18:11 <vixey> I was trying to get Ivor so I could do something like id = [$ivor| forall a. a -> a |]
09:18:28 <mmorrow> ok
09:18:49 <mmorrow> a really handy function is this:
09:19:02 <mmorrow> unQ :: Q a -> a = unsafePerformIO . runQ
09:19:12 <tibbe> is there a way to load .hsc file from within ghci
09:19:13 <tibbe> ?
09:19:18 <thoughtpolice> mmorrow: you're all about the quasiquoting huh? :)
09:19:19 <tibbe> files*
09:19:35 <thoughtpolice> tibbe: you have to run them over with hsc2hs first iirc
09:19:47 <tibbe> thoughtpolice: that's annoying :(
09:19:53 <tibbe> C-c C-l is what I'm all about
09:19:59 <thoughtpolice> word
09:20:00 <tibbe> for quick turnaround time
09:20:06 <mmorrow> thoughtpolice: i think that it'll make some things massively easy (like saving me from doing work ;))
09:20:11 <thoughtpolice> emacs for life! :)
09:20:35 <thoughtpolice> mmorrow: i still haven't taken time to look at QQ or really TH although your QQ magic lately has gotten me thinking
09:20:40 <thoughtpolice> :)
09:21:13 <mmorrow> heh, i'm trying to spread my enthusiasm
09:21:59 <mmorrow> maybe soon, we'll have a QuasiQuoters that cooks toast for us!
09:22:05 <mmorrow> s/s//
09:22:40 <olsner> oooh, cooks toast? is that before or after it solves the halting problem? :P
09:22:52 <mmorrow> i think during ...
09:22:53 <thoughtpolice> before
09:22:58 <thoughtpolice> because you are going to need a lot of toast while you wait
09:22:59 <mmorrow> heh, all of the above
09:23:08 <EvilTerran> it makes coffee while it's solving the halting problem
09:23:12 <mmorrow> it better!!
09:23:35 <thoughtpolice> can it give me a massage?
09:23:42 <vixey> stringQQ = QuasiQuoter (litE . stringL) (litP . stringL)
09:23:51 <olsner> an endless supply of coffee and toast while solving the halting problem, that's your whole life taken care of
09:24:45 <mmorrow> there better be jam
09:24:55 <mmorrow> vixey: exactly
09:25:31 <mmorrow> vixey: so, then what datatype do you want the [$ivor||] QQ to spit out
09:26:02 <vixey> I wanted to a djinn like thing
09:26:18 <vixey> cabal or something is broken though, so I can't atm
09:27:07 <mmorrow> first, you have an AST datatype that you parse to. then derive Lift for that AST, and        Quasiquoter (lift =<< parseMyLangQ) (return . someThingBootlegProbablyToPatQ =<< parseMyLangQ)
09:28:43 <mmorrow> err
09:28:49 <mmorrow> i'll paste some stuff
09:29:04 <vixey> mostly I want to mix QQ with view patterns though
09:31:29 <mmorrow> vixey: pk, here's a lighttpd config-file qq: http://code.haskell.org/~morrow/quasiquotes/Lighttpd-Conf-QQ.hs.html
09:31:30 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5qpuzu
09:32:13 <mmorrow> in addition to whats there, i autogenerated the Lift instances for all the datatypes that make up the top-level ast type
09:33:39 <mmorrow> the auto-deriver involves plugins and all kind of circus hacks, but i'm working on getting it together to hackage .. it uses plugins + th-lift, but you may be able to use th-lift to do the same (th-lift is by Igloo and on hackage)
09:33:42 <vixey> ughhhhhh
09:33:46 <vixey> this is annoying
09:33:52 <mmorrow> heh
09:33:54 <vixey> the view patterns don't do tupling yet
09:34:00 <vixey> (foo -> x y z) is a parse error
09:34:08 <vixey> it should be equiv. to (foo -> (x,y,z))
09:34:17 <mmorrow> i haven't spent any time with view patterns yet
09:34:28 <mmorrow> i know just barely more than nothing about them
09:34:34 <chrisdone> > join (<|>) $ [1..10] >>= return . join (*)
09:34:35 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,1,4,9,16,25,36,49,64,81,100]
09:34:40 <mmorrow> i recall you explained it to me though ...
09:34:45 * vixey is annoyed about thisoae
09:35:00 <vixey> split [] = []
09:35:00 <vixey> split ('_':y) = Nothing : split y
09:35:00 <vixey> split (break (=='_') -> (x,y)) = Just x : split y
09:36:27 <mmorrow> uhh, it worked for me :)
09:36:34 <mmorrow> (i think)
09:36:43 <mmorrow> i had to do
09:36:44 <mmorrow> :set -XViewPatterns
09:36:46 <vixey> that works but I would rather write (break (=='_') -> x y)
09:36:46 <mmorrow> in ghci
09:37:00 <centrinia> mmorrow: Just because a program works doesn't mean that it is correct. ;)
09:37:11 <mmorrow> centerinia: :)
09:37:46 <mmorrow> vixey: ah, i see what you're going for. that seems like you're intending to apply the x to the y or something, though
09:38:37 <chrisdone> wow that pattern is cool
09:38:46 <mmorrow> i don't see what that's supposed to mean ... other that you're "turning the func of one arg into one of two args in the pattern match" or something
09:39:24 * mmorrow needs to rtfm
09:39:38 <chrisdone> could you have a function which can fail and thus the pattern matching would proceed to the next one?
09:39:49 <vixey> mmorrow: It's just that when you have something like,
09:40:20 <vixey> foo ([$|http://(.*)/(.*)|] -> (body,page)) = ...
09:40:22 <vixey> or
09:40:26 <vixey> foo ([$|http://(.*)/(.*)|] -> [body,page]) = ...
09:40:28 <vixey> or whatever it is
09:40:43 <vixey> You have to know the result is a tuple or a list, which is not relevant.. to matching
09:40:51 <vixey> foo ([$|http://(.*)/(.*)|] -> body page) = ...
09:41:41 <vixey> but I thought I read they had that in the manual it seems like it's not done though
09:41:53 <mmorrow> ok, i see what you're saying, but since you've named the subpieces, it seems like you're not losing anything by having the (,)/[]/whatever, and possibly gaining the ability to do
09:42:47 <mmorrow> foo ([$|http://(.*)/(.*)|] -> a@(body,b@(page,c@(body++page)))) = (((a,b),c),body,page)
09:42:53 <vixey> eee
09:43:02 <mmorrow> (i don't know if that's allowed)
09:44:03 <mmorrow> so you get to deconstruct, reconstruct, then again decostruct before getting to the func body
09:45:41 <mmorrow> ohhh, i see.
09:46:08 <mmorrow> that's definitely not allowed just like        let f a@(body,b@(page,c@(body++page))))  = ... isn't
09:54:07 <EvilTerran> well, you can't use ++ in patterns
09:54:15 <newsham> let (body++page) = "testing"  ?!
09:54:53 <newsham> [("t","testing"),("te","sting"),("tes","ting"),...]
09:55:01 <EvilTerran> you could make something like [$list|"prefix"++str++"suffix"|] usable as a pattern
09:55:55 <newsham> does that really buy you much?  to have the pattern compiler deal with it instead of a guard?
09:56:38 <newsham> f s | "test" `isPrefixOf` s = let s' = drop 4 s in ...
09:57:36 <EvilTerran> view patterns could do the same job, too
09:57:47 <EvilTerran> ?hoogle stripPrefix
09:57:48 <lambdabot> Data.List.stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
09:57:56 <EvilTerran> foo (stripPrefix "test" -> str)
09:58:04 <EvilTerran> er, foo (stripPrefix "test" -> Just str)
09:58:12 <EvilTerran> or even
09:58:31 <EvilTerran> er... not sure how you'd do suffixes
09:58:47 <newsham> just make a primitive for it..
09:58:52 <EvilTerran> indeed
09:59:41 <EvilTerran> stripSuffix suffix str = <something painful>
10:00:16 <newsham> hasPreSuffix :: String -> String -> String -> Maybe String
10:00:27 <chrisdone> chr1s: wehey I have it working: http://hpaste.org/9519 ^___^!
10:00:30 <EvilTerran> reverse <$> stripPrefix (reverse suffix) (reverse str) -- quick and dirty solution
10:00:58 <chrisdone> chr1s: ( runnable example: http://chrisdone.com:3000/register )
10:01:06 <newsham> what's the <$> do in that?  for ((->)r) ?
10:01:16 <chrisdone> <$> is a synonym for fmap
10:01:29 <newsham> so for [a]
10:01:33 <EvilTerran> for Maybe
10:01:35 <newsham> ahh
10:01:36 <newsham> danke
10:03:24 <chrisdone> ah, wtf
10:03:24 <chrisdone> Ambiguous occurrence `password'
10:03:24 <chrisdone>     It could refer to either `X.password', imported from Kibro at src/Main.hs:3:0-33
10:03:28 <chrisdone>                           or `Text.XHtml.Strict.Formlets.password', imported from Text.XHtml.Strict.Formlets at src/Main.hs:6:0-32
10:03:50 <chrisdone> X is Text.XHtml.Strict qualified
10:03:58 <chrisdone> why would that even be looked at
10:04:24 <mmorrow> hmm
10:04:28 <EvilTerran> chrisdone, did you "import qualified Text.XHtml.Strict as X", or just "import Text.XHtml.Strict as X"?
10:04:39 <mmorrow> did you actually ad "qualified" to the import line
10:04:40 <EvilTerran> with the latter version, the unqualified version is still imported
10:04:43 <chrisdone> import qualified Text.XHtml.Strict as X
10:04:44 <mmorrow> s/ad/add/
10:04:46 <newsham> is there a duplicate import thats not qualified?
10:04:46 <EvilTerran> hm
10:04:58 <chrisdone> perhaps another module has re-exported Text.XHtml.Strict
10:05:01 <chrisdone> let me see
10:05:10 <chrisdone> that would cause this, right?
10:05:15 <mmorrow> yeah
10:05:25 <EvilTerran> also, if Kibro has "module X" in its export list, i think it may get imported unqualified
10:05:27 <chrisdone> and GHC just calls it X.foo instead of <full module>.foo
10:05:48 <EvilTerran> regardless of whether you imported it to Kibro qualified or otherwise. not sure.
10:05:52 <chrisdone> ah, I think that will be it
10:06:46 <mmorrow> vixey: wow, view patterns look really useful
10:07:07 <chrisdone> yep, that was it. thanks guys
10:08:02 <EvilTerran> mmorrow, indeed - they feel a lot cleaner to me than QQs do, too
10:09:02 <PeakerWork> qualified imports should be the default...
10:09:35 <dogbite_> what's the Set data structure in haskell?
10:09:44 <dogbite_> just something so i can test membership efficiently
10:09:50 <EvilTerran> although less versatile, given that you could construct something like view patterns with QQs
10:09:52 <EvilTerran> dogbite_, Data.Set
10:09:57 <EvilTerran> ?docs Data.Set
10:09:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
10:10:07 <EvilTerran> DOH
10:10:09 <dogbite_> EvilTerran: heh
10:10:15 <dogbite_> how do people name these things
10:10:26 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
10:10:27 <lambdabot> Title: Data.Set, http://tinyurl.com/ynl5nk
10:10:28 <dogbite_> :-)
10:10:53 <EvilTerran> dogbite_, i find it helps to always have a window with http://www.haskell.org/ghc/docs/latest/html/libraries/index.html open when i'm haskelling
10:10:54 <lambdabot> Title: Haskell Hierarchical Libraries
10:12:20 <RayNbow> hmm, so there's a proposal to shrink the Prelude for Haskell'...
10:14:57 <olsner> @src on
10:14:57 <lambdabot> (*) `on` f = \x y -> f x * f y
10:15:50 <dogbite_> EvilTerran: thanks for the tip
10:17:04 <mmorrow> EvilTerran: yeah, the pattern side of QQs is definitely not straightforward (in the sense that there's not one clear-cut things to do in pattern context)
10:17:32 <mmorrow> (... clear-cut way to do things ...)
10:21:12 <mmorrow> no wonder there's no [p||] in template-haskell ;)
10:21:31 <RayNbow> hmm, and the arrow syntax proposal is rejected...
10:21:53 * EvilTerran wants [p|...|]
10:22:00 <vixey> I am kind of annoyed by Haskell'
10:22:16 <sbahra> vixey, why?
10:22:17 <dons_> what's to be annoyed by?
10:22:24 <mmorrow> EvilTerran: you can have it with an hs QQ
10:22:33 <vixey> GHC is fine :/
10:22:43 <dons> compared to the situation prior to standardisation, we now have a clear set of extensions, with known portability, and you can make an informed choice about what and which you use.
10:22:54 <sbahra> I was really turned off by functional programming with Scheme, spent years doing C. I don't regret starting to learn haskell.
10:23:14 <sbahra> I think I might reach a point where if I'm not doing C, and I am doing RAD or prototyping, it will be in haskell for sure.
10:23:14 <Heffalump> vixey: if you're happy with the language defined by GHC, you can just ignore the existence of Haskell'
10:23:26 <vixey> Heffalump: but everyone keeps talking about it :...
10:23:31 <thoughtpolice> vixey: right, but there are a lot of extensions to GHC that would be really useful to have standardized
10:23:37 <sbahra> vixey, oh, what is "Haskell'"?
10:23:42 <sbahra> vixey, versus "Haskell"
10:23:46 <dons> vixey: its the difference between -fglasgow-exts, and -XPatternGuards -XFFI and so on.
10:23:48 <vixey> sbahra: In progress restandardization of the language
10:23:49 <thoughtpolice> sbahra: new haskell standard
10:23:53 <sbahra> ah
10:23:55 <dons> in the olden days we only had -fglasgow-exts
10:24:02 * sbahra googles
10:24:07 <dons> but now you can find out and choose precisely what extensions you wish for.
10:24:26 <vixey> dons: But it's not just a list of extensions and descriptions of what they do
10:24:30 <vixey> that would be good ...
10:24:41 <dons> well, it is, really.
10:24:53 <dons> that and tool support for handling the flags.
10:24:56 <newsham> "I dont starting to learn haskell"...   how deep are you into it so far?  ;-)
10:25:13 <newsham> its kinda like crack...  it seems innocent enough at first ;-)
10:25:26 <thoughtpolice> dons: oh yeah, I wanted to mention to you for ghc-core, having it use -O2 by default isn't awesome primarily when you want to see the difference between .e.g -O and -O2, or -O0 and -O1/-O2
10:25:31 <newsham> then you're up all night reading academic papers and you wonder where your life has gone
10:25:34 <newsham> but you just cant quit
10:25:44 <RayNbow> newsham: Haskell is a mental drug :)
10:25:52 <newsham> crystal math
10:26:10 <Heffalump> vixey: well, everyone keeps talking about the Olympics, I just ignore them
10:26:18 <dons> thoughtpolice: use the ghc-core released yesterday
10:26:22 <dons> thoughtpolice: you can override the flags
10:27:04 <thoughtpolice> dons: so just 'ghc-core -- -O0' would work?
10:27:40 <dons> with ghc-core 0.4, yeah, it should.
10:28:46 <thoughtpolice> ah yes, seems to be so :)
10:37:27 <swiert> coq
10:40:42 <laz0r> what does it actually mean if some module is flagged as 'non-portable' in the docs?
10:40:54 <dmhouse> laz0r: that its portability isn't guaranteed.
10:41:04 <EvilTerran> usually that it relies on some GHC extensions
10:41:06 <dons> this is neat, http://www.reddit.com/r/programming/comments/6vplm/programs_that_run_backwards_a_reverse_state_monad/
10:41:07 <lambdabot> Title: Programs that run backwards: a *reverse* state monad : programming, http://tinyurl.com/633aoo
10:41:17 <dmhouse> So, really, nothing. It may or may not be portable. Probably that its maintainer hasn't bothered to check it.
10:41:20 <dons> laz0r: basically , you may not be able to run it in hugs or nhc.
10:41:28 <dons> the key is to check the .cabal file
10:41:39 <dmhouse> dons: yeah, saw that earlier. It's pretty nice.
10:41:53 <laz0r> ah, ok
10:47:43 * Heffalump attempts to build GHC yet again
10:48:30 <sbahra> Looking at the GHC map implementation, in my implementation I use map f [] = [] for termination. GHC uses map _ [] = [] for termination.
10:48:38 <sbahra> Is there a reason why? Is it faster?
10:49:13 <BONUS> terminology question: are overloaded function only those that are defined in typeclasses or all functions that have class constraints?
10:49:20 <BONUS> functions*
10:50:01 <gwern> @tell bringert btw, is unix-compat being BSD4 intentional?
10:50:02 <lambdabot> Consider it noted.
10:50:19 <ddarius> sbahra: It makes it cleare that f isn't used, but it is not faster in any way.
10:50:28 <olsner> can you run parsec in the list monad and get a nondeterministic all-alternatives parser?
10:50:29 <sbahra> ddarius, ah, yes.
10:51:05 <BONUS> anyone know about the overloaded functions?
10:51:22 <sbahra> ddarius, thanks.
10:51:26 <dmhouse> BONUS: what about them?
10:51:53 <dmhouse> Oh, you just asked. Depends on context, it's not standard Haskell terminology.
10:52:01 <BONUS> aha
10:52:03 <dons> Heffalump: if it doesn't build, complain on the lists.
10:52:27 <EvilTerran> olsner, that sounds like what ReadP does
10:53:22 <EvilTerran> you might be able to get a similar effect with Parsec, but it might need Parsec 3's ParseT (or whatever it's called)
10:53:39 <olsner> that's what I was thinking about
10:54:48 <olsner> maybe I'll end up having to actually think about this before writing down the solution
10:54:57 <olsner> ... how boring
10:55:37 <EvilTerran> i suspect it won't even be directly possible with that
10:56:26 <EvilTerran> considering how parsec treats choices
10:57:00 <chr1s> chrisdone: cool!
10:57:26 <chr1s> however, for non-monadic actions, you can use check and ensure instead of checkM and ensureM
10:57:41 * gwern reads reddit. oh, so Glasgow Parallel Haskell did get merged into GHC proper. that's good
10:58:04 <chr1s> chrisdone: username = input Nothing `check` ensure validUsername "Not a valid username"
10:58:36 <chr1s> chrisdone: validUsername = isJust . matchRegex ....
10:59:25 <olsner> maybe if I use another parser monad, this'll just pop out when I get the grammar down ... but it's no normal grammar this... hmm
11:00:05 <EvilTerran> olsner, you could do something similar without using monad transformers or anything
11:00:20 <EvilTerran> but you'd probably have to do things more explicitly
11:00:25 <ddarius> You could use ReadP or ReadS as EvilTerran suggested.
11:00:32 <paczesiowa> some guy on reddit just discovered haskell.org:/
11:00:49 <chrisdone> chr1s: ahh yeah. sweet :)
11:01:01 <EvilTerran> (|||) :: GenParser tok st [a] -> GenParser tok st [a] -> GenParser tok st [a] -- or something
11:01:35 <EvilTerran> but you'd need to fork the parser state somehow. not sure how you do that.
11:01:36 <gwern> @tell Igloo I'm sending you my lcs patches; I haven't gotten relicensing permission, but I'd like them backed up somewhere and also for you to see what I've been doing
11:01:36 <lambdabot> Consider it noted.
11:01:54 <TomMD> Is there any planned date that I should stop darcs pulling GHC and start git pulling it?
11:02:41 <EvilTerran> olsner, i think you'd have to do something with getInput and setInput
11:02:59 <bwr> http://hpaste.org/9520  -- would this be a use for the Maybe monad to make this nicer?
11:03:08 <olsner> oh well, my brain is shutting down due to lack of food... gonna have to go eat before continuing on this problem :)
11:03:10 <jcreigh> How can I get the number of milliseconds (or picoseconds, or whatever) since the program has started? I've tried useing getClockTime and diffClockTimes, but it appears that tdPicosec is not the total difference in picoseconds, but merely the "remainder" after the years/months/days/hours/etc are figured it.
11:03:19 <Igloo> TomMD: At the moment it's not even clear we'll be moving to git after all
11:03:20 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
11:03:30 <jcreigh> What? GHC is switching to git?
11:03:38 <chrisdone> Igloo: oh, problems in paradise?
11:03:51 <Igloo> See g-h-u@ for the discussion
11:03:53 <EvilTerran> olsner, something like: x ||| y = do input <- getInput; xs <- x; setInput input; ys <- y; return (xs ++ ys)
11:04:03 <TomMD> Igloo: It just seems that way from the weekly meetings.  I'll just keep waiting ;-)
11:04:12 <EvilTerran> olsner, but the behaviour of any implementation like that would be a bit weird if you had something like (x ||| y) >> z
11:07:36 <dmwit> Why not separate the input gathering from the input processing?
11:07:41 <dmwit> Then you don't even need (|||).
11:08:01 <EvilTerran> i'm not sure i follow
11:08:05 <dmwit> x ||| y = do input <- getInput; return (x input ++ y input)
11:08:40 <dmwit> i.e. don't let x and y be monadic actions that gather the input themselves.
11:08:49 <EvilTerran> well, the idea was kludging something so you could easily get a list of all possible parses instead of just one from a parsec parser
11:08:53 <dmwit> Let them expect to be handed the input on a (pure) silver platter.
11:09:10 <EvilTerran> but, as i said earlier, i don't think there's any easy way of doing that
11:09:33 <dmwit> I thought Parsec had an equivalent of Reader's local.
11:12:19 <TomMD> @check \x :: [Integer] -> ( > 3) . length . nub $ x
11:12:20 <lambdabot>  Parse error at "::" (column 4)
11:12:25 <EvilTerran> even with that, i don't think it'd work
11:12:51 <EvilTerran> you need something that you can use on the LHS of a >>= with sane behaviour
11:12:57 <dmwit> ?check \x -> (> 3) . length . nub $ (x :: [Integer])
11:12:57 <lambdabot>   Not in scope: `myquickcheck''
11:13:02 <TomMD> @check ( > 3) . length . nub  -- Why is this borked?
11:13:03 <lambdabot>   Not in scope: `myquickcheck''
11:13:16 <Deewiant>  @check has been broken for about a week now
11:13:19 <dmwit> I think ?check broke a few days ago.
11:13:20 <mjrosenb> is there a function like words, but it splits a string when a specific character is found?
11:13:25 <dmwit> no
11:13:39 <encryptio> splitBy, iirc
11:13:44 <EvilTerran> trickery with monad transformers would be a bit more likely to work than trying to just use the GenParser monad, i guess
11:13:44 <mjrosenb> or better yet when an (a -> Bool) is found?
11:13:49 <chrisdone> splitBy returns a tuple
11:13:53 <dmwit> mjrosenb: There are too many choices for the behavior of such a function, so it's never been put in the library.
11:14:04 <mjrosenb> dmwit: fair enough
11:14:05 <dmwit> mjrosenb: But it's easy to write using splitBy and iterate and friends.
11:14:24 <mjrosenb> what is splitBy in?
11:14:34 <dmwit> ?index splitBy
11:14:34 <lambdabot> bzzt
11:14:35 <EvilTerran> do you mean splitAt?
11:14:37 <mjrosenb> data.list
11:14:40 <EvilTerran> ?hoogle splitAt
11:14:40 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
11:14:41 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
11:14:41 <lambdabot> Data.ByteString.splitAt :: Int -> ByteString -> (ByteString, ByteString)
11:14:46 <dmwit> No
11:14:47 <EvilTerran> ?hoogle split
11:14:47 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
11:14:47 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
11:14:47 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
11:14:48 <dmwit> break
11:14:49 <dmwit> :t break
11:14:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:14:50 <dmwit> :t span
11:14:51 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:14:55 <EvilTerran> ah, yes, span and break
11:15:00 <EvilTerran> those're the ones
11:15:06 <mjrosenb> i see
11:15:36 <dmwit> > 18 * 18 * 216
11:15:38 <lambdabot>  69984
11:15:42 <mjrosenb> i assume that one eliminates the element that returned true, and the other doesn't
11:15:42 <chrisdone> :t splitRegex
11:16:00 <dmwit> mjrosenb: no
11:16:13 <chrisdone> splitRegex :: Regex -> String -> [String]
11:16:14 <dmwit> mjrosenb: span = break . (not .)
11:16:39 <mjrosenb> oic
11:16:52 <TomMD> quickCheck has been annoying me lately.  Why does something so simple (see below) not work?  I know it generates lists > 3 fairly often.
11:16:52 <TomMD> (\x -> ( ( > 3) . length . nub $ (x :: [Integer]) ) ==> True)
11:18:05 <chrisdone> dmwit: maybe there should be a wiki page (if there is not already) about split functions with suggested implementations and such?
11:18:09 <EvilTerran> ?src span
11:18:09 <lambdabot> Source not found. :(
11:18:12 <EvilTerran> ?src break
11:18:12 <lambdabot> break p =  span (not . p)
11:18:19 <dmwit> TomMD: You could use something like (\x -> [1,2,3] ++ x ==> True), maybe.
11:18:21 <chrisdone> dmwit: it would be nice to link in this channel because split crops up /all the time/
11:18:23 <dmwit> Depends what you want to test, I guess.
11:18:51 <dmwit> chrisdone: Somebody did a blog post about all the different splitBy implementations.
11:18:52 <TomMD> dmwit: That is slightly destructive as to the purpose.
11:18:55 <laz0r> what should i read when i want to know how/when/where to use Control.Monad.ST?
11:18:57 <dmwit> TomMD: /me nods
11:19:34 <laz0r> i'm currently trying around with it, but i am somewhat confused
11:19:41 <chrisdone> dmwit: oh, I'll look for it
11:19:52 <laz0r> i tried using it like Control.Monad.State, but it is... different
11:19:52 <dmwit> TomMD: But perhaps also possible: (\w x y z -> ((> 3) . length . nub . concat) [w,x,y,z] ==> True)
11:20:06 <dmwit> Just makes it less likely to fail.
11:20:17 <laz0r> i think the 'reason' for ST seems to be that you can have STRefs inside of it
11:20:27 <TomMD> dmwit: Yeah, I've been considering going that route.  It seems to be that or lazy small check.
11:20:33 <dmwit> laz0r: Right, the point of ST is to be mutable in a safe way.
11:22:38 <stulli> Is it sometimes necessary to use unsafe IO or can you always use "normal" IO?
11:22:41 <dafra> hi, anybody running archlinux out there ?
11:22:57 <dmwit> stulli: unsafe IO is primarily for the FFI
11:23:06 <dmwit> i.e. importing C functions which are, in fact, pure
11:23:14 <TomMD> dafra: Sorry I didn't respond earlier, I had stepped out.  At any rate, I don't have any archlinux advice, sorry.
11:23:21 <laz0r> mmh, i think my main reason for confusion is that ST is very similar defined like State, so like 'ST s a' where s denotes some kind of state... and then you don't get any functions to access that state
11:23:36 <dmwit> stulli: It can also be convenient for quick one-off programs that need to read a configuration file or something, but it is never *necessary*.
11:24:17 <laz0r> which makes me believe that i should not attempt to change/read the state like i am used to, but then, whats the point of having that state?
11:24:18 <dmwit> laz0r: The 's' is for-all'd in a sneaky way...
11:24:35 <dafra> TomMD: its OK
11:24:39 <stulli> dmwit, Ah, i see. I saw a program using it and i made a version without unsafe, so was unsure about how to use it
11:24:40 <dmwit> laz0r: It allows some hacks behind the scenes, basically.
11:25:07 <dmwit> ?quote oasis.*referential
11:25:07 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:25:15 <dmwit> stulli: ^_^
11:25:38 <PeakerWork> Why Haskell' and not Haskell2008?
11:25:49 <dmwit> Because it will never come out.
11:25:49 <dmhouse> It might not be finished this year.
11:25:55 <dmhouse> It certainly wasn't started this year.
11:25:57 <PeakerWork> ok, then Haskell0x? :-)
11:26:00 <dmwit> Haskell20008
11:26:20 <stepcut> Wasn't it supposed to come out for ICFP 2007 ?
11:26:21 <EvilTerran> Haskellω
11:26:29 <PeakerWork> Ok, I hope it changes names when it does come out
11:26:42 <laz0r> oh, well, i'll go for a walk and think
11:26:45 <laz0r> maybe it'll help
11:26:54 <dafra> Haskell1x
11:27:03 <stepcut> HaskellPro
11:27:05 <chrisdone> dmwit: well, I found a mailing list thread. I am surprised how many potential behaviours there are
11:27:20 <dafra> IncompatibleHaskell
11:27:42 <dmwit> chrisdone: Yeah, there really are a lot of (totally reasonable) possible implementations.
11:30:13 * vixey wants to make a language called Church
11:30:20 <chrisdone> that would be a good name
11:32:27 <chrisdone> dmwit: I wonder if a mini-language has ever been considered for it, similar to the “format” of Common Lisp, but for splitting, rather than printing
11:32:50 <gwern> splitting has cast me into despair
11:32:54 <chrisdone> haha
11:33:01 <gwern> I've put it on the sideburner while I try to build up gumption to tackle it
11:33:15 <dmwit> I guess Parsec is kind of a "splitting" language in some sense.
11:33:34 <dmwit> Also, weren't you the one who suggested splitRegex?
11:33:39 * gwern regrets that I already used up my Sayonara Zetsubous Sensei joke, since it's so appropriate for splitting
11:33:41 <chrisdone> well, I mean something that looks like J
11:33:43 <dmhouse> chrisdone: like C's scanf?
11:33:57 <chrisdone> yeah, splitRegex is alright for strings (if sometimes OTT)
11:33:57 <dmwit> Yeah, I was thinking of scanf, too.
11:34:14 <chrisdone> dmhouse: yeah, just pass a string with some symbols that have meaning
11:34:29 <chrisdone> a splitex :P
11:34:34 <dmhouse> A DSL would be nicer.
11:34:43 <gwern> you splittists!
11:34:52 <gwern> you're trying to disrupt the harmony of the haskell nation
11:34:53 <chrisdone> dmhouse: agreed, but also quite large?
11:35:13 <dmhouse> Haskell's good at those, too. So yeah, a bit like Parsec.
11:35:14 <chrisdone> dmhouse: in terms of textual size, that is
11:35:39 <dmhouse> Perhaps. But it has the advantage that more errors are caught at compile-time.
11:36:05 <dino-> Does `cabal configure --program-suffix='
11:36:07 <dino-> bah
11:36:09 <dino-> '$version'
11:36:10 <chrisdone> split (do at ","; inc terminators) "a,b,c,d" => ['a',',','b',',','c']?
11:36:11 <dino-> work?
11:36:18 <chrisdone> dmhouse: good point there
11:36:21 <dino-> I wonder if I'm using it incorrectly.
11:36:38 <chrisdone> s/","/','
11:37:22 <dino-> when I do it, I still get .../bin/foo not .../bin/foo-0.1.1
11:37:26 <dmhouse> That's quite a nice idea. I'd have two different functions, one that included the delimiters and one that didn't, though.
11:38:11 <dmhouse> And you could have split (atr ",\s*") "foo, bar,   baz,quux" -> ["foo","bar","baz","quux"]
11:39:08 <chrisdone> but splitRegex can do that
11:39:15 <chrisdone> shouldn't it be generic to work on any list?
11:39:39 <dmhouse> I guess the best solution is split (==",")
11:39:56 <dmhouse> Then you could do split (=~ ",\s*")
11:40:00 * gwern watches the discussion amusedly
11:40:27 <dmhouse> It'd have to be split :: ([a] -> Bool) -> [a] -> [[a]], though, i.e. not split (==',').
11:40:42 <chrisdone> dmhouse: oh, duh. we could just use operators
11:41:00 <dmhouse> HOFs ftw.
11:43:17 <dmwit> dmhouse: Sounds like you're going to have a very pessimistic algorithm.
11:43:29 <dmhouse> dmwit: in what way?
11:43:32 <dmwit> n^2 in the length n of the list =/
11:43:47 <dmwit> no... n^3
11:44:09 <dmwit> If you allow ([a] -> Bool), you have to examine *every sublist*.
11:44:14 <dmhouse> Yeah, I guess this is the point of L(1).
11:44:30 <dmhouse> dmwit: it's necessary in a lot of situations, though.
11:44:47 <SamB> dmhouse: use of that type is not necessary
11:44:58 <dmhouse> Err, LL(1).
11:45:03 <dmwit> But (== ",") would end up considering all these huge long lists, when only sub-lists of size one could possibly match.
11:45:03 <chrisdone> hm, that's why a DSL would do nice here
11:45:17 <chrisdone> the type would only apply if you use the function to do that kind of thing
11:45:21 <dino-> Wow, that's so weird. If I do `cabal configure --program-suffix='$version'` and then look at dist/setup-config I see progSuffix = "$version" in there...
11:45:28 <dino-> And then next step: `cabal install`
11:45:48 <dino-> does NOT use prog suffix on the binary and the dist/setup-config has progSuffix = ""
11:45:55 <dino-> without me redoing config myself
11:45:57 <dino-> :/
11:46:56 <dino-> IOW: cabal intall blows away my config
11:49:59 <Quadrescence> How would I make a precomputed table of values for fast access?
11:50:14 <Quadrescence> Or would this not be necessary since haskell is a lazy-ass language?
11:50:24 <chrisdone> a lazy ass-language
11:50:38 <chrisdone> you could make a Map
11:50:39 <Quadrescence> xkcd thx
11:51:11 * SamB demands to know which xkcd Quadrescence has found assistance in
11:51:13 <chrisdone> wow, xkcd did that joke, too? I can't make any jokes without “xkcd did it”.. similar to the simpsons for episode stories
11:51:18 <newsham> any galois people here familiar/involved with the "secure user-centric mashup applications" whitepaper?
11:51:25 <DukeDav1> Okay, I'm not amused how many dependancies cabal-install has :|
11:51:41 <Quadrescence> chrisdone: Actually, I was about to ask that.
11:51:44 <chrisdone> sudo cabal install cabal-install-install
11:51:45 <SamB> DukeDav1: is anyone?
11:51:59 <SamB> I think it should come with GHC
11:52:15 <SamB> or something
11:52:20 <thoughtpolice> SamB: word
11:52:23 <chrisdone> werd
11:52:26 <Quadrescence> How I would make a 1-to-1 lookup table that's not inefficient.
11:52:27 <thoughtpolice> that's the best plan for adoption I feel
11:52:41 <thoughtpolice> i mean right now it only needs zlib and http since everything else comes stock
11:52:43 <thoughtpolice> but still
11:52:57 <DukeDav1> chrisdone: Fail :|
11:52:59 <SamB> yeah, it's better than it has been
11:53:21 <DukeDav1> I have GHC 6.6.1
11:53:24 <newsham> quad: like Data.Map?
11:53:51 <chrisdone> DukeDav1: huh?
11:53:59 <MyCatVerbs> Quadrescence: Data.Array or Data.Map. If you have dense keys (no gaps between them), Data.Array.
11:54:03 <Quadrescence> newsham: Maybe I should look that up. I just want to make precomputed tables for easy lookup. Like, a precomputed table of values for the factorial function.
11:54:10 <DukeDav1> I don't have cabal
11:54:19 <DukeDav1> At least, I don't have a binary called cabal
11:54:28 <chrisdone> DukeDav1: well, that was a joke
11:54:30 <newsham> > M.fromList [("test", 4),("this",44),("out",3)] M.! "this"
11:54:31 <lambdabot>  44
11:54:37 <SamB> cabal is the binary for cabal-install
11:54:38 <newsham> where M is Data.Map
11:54:38 <DukeDav1> chrisdone: Oh :'(
11:54:39 <dino-> Quadrescence: I was thinking that too: if you're simply calling a pure function over and over with the same args, that's effectively 'memoized' in this language. Is that fair to say everyone?
11:54:56 <SamB> chrisdone has in fact stated the easiest way to install cabal-install
11:55:00 <vixey> dino-: No that's not true
11:55:08 <MyCatVerbs> dino-: not necessarily. Only if you have a single thunk of that function with those arguments.
11:55:13 <DukeDav1> I thought someone had written some awesome boot strapper there :)
11:55:14 <SamB> however, the easiest way to install cabal-install is with cabal-install
11:55:20 <Quadrescence> dino-: I always hear the word "memoize," but I still don't know what it means. :)
11:55:41 <MyCatVerbs> dino-: for example, let thunk = f g in ..., and then you use thunk a thousand times -- that's memoized, because thunk is shared in the expression ....
11:55:47 <chrisdone> dino-: caching values
11:55:49 <pjdelport> Quadrescence: it means just what you described;  saving ("memoizing") the results of a function for various inputs
11:55:51 <SamB> so it doesn't really do you any good unless you already have installed cabal-install
11:55:54 <newsham> memoize just means that if you ask the function for an answer, it remembers it for next time its asked the same question
11:56:07 <dino-> yeah, caching
11:56:15 <Quadrescence> Does memoize come from the word memorize? :D
11:56:18 <MyCatVerbs> dino-: however, independantly calling f g in a hundred places inside an expression, with no shared identifier to denote f g, will suck.
11:56:25 <waern> the next ghc version will ship with cabal-install, I think
11:56:34 <chrisdone> Quadrescence: it comes from memoization, which in turn comes from memoize
11:57:02 <MyCatVerbs> Quadrescence: Immutable arrays are pretty much exactly what you want for constant look-up-tables.
11:57:04 <dino-> MyCatVerbs: huh. It doesn't recognize that, if g is always the same value, that it can reduce that?
11:57:10 <thoughtpolice> waern: has GHC HQ discussed packaging zlib and cabal with the distribution?
11:57:14 * SamB throws a <<Loop>> at chrisdone 
11:57:15 <dino-> I don't really understand this. And I think I had better get with it.
11:57:34 <waern> thoughtpolice: I think so
11:57:38 <thoughtpolice> since that would be required for cabal-install
11:57:40 <thoughtpolice> but if so
11:57:43 <thoughtpolice> hell yeah. :)
11:57:47 <SamB> thoughtpolice: already packages cabal
11:57:54 <MyCatVerbs> dino-: unfortunately, no. Memoization happens on thunks. Functions don't memoize on their own.
11:58:01 <SamB> doesn't it?
11:58:20 <thoughtpolice> er
11:58:22 <SamB> MyCatVerbs: what???
11:58:23 <thoughtpolice> i meant zlib and http
11:58:25 <thoughtpolice> :p
11:58:27 <waern> thoughpolice: yep, I think the next ghc release will solve a lot of problems
11:58:30 <SamB> MyCatVerbs: you've been reading okasaki haven't you!
11:58:41 <MyCatVerbs> SamB: heheh, yes.
11:58:46 <SamB> okasaki uses the term differently from everyone else
11:58:47 <newsham> memoization: http://codepad.org/FLB0PYFL
11:58:55 <MyCatVerbs> dino-: if I say, let thingy = fib 100 in thingy + thingy * thingy -- fib 100 will get calculated once.
11:59:07 <newsham> ?dict-wn memo
11:59:07 <lambdabot> Unknown command, try @list
11:59:12 <newsham> ?wn memo
11:59:13 <lambdabot> *** "memo" wn "WordNet (r) 2.0"
11:59:13 <lambdabot> memo
11:59:13 <lambdabot>      n : a written proposal or reminder [syn: {memorandum}, {memoranda}]
11:59:23 <MyCatVerbs> dino-: if I say, (fib 100) + (fib 100) * (fib 100) -- it's possible that (fib 100) will get calculated three times.
11:59:40 <Quadrescence> Can someone point me in the correct direction to install cabal-install in Linux? I did it on windows a few weeks back (a pain in the .), and I forgot what to do, 'specially since I am on lunix.
12:00:05 <DukeDav1> Quadrescence: Well I am about to give up :|
12:00:22 <MyCatVerbs> dino-: the compiler could, in this case, optimize that to evaluate it only once, but GHC is really bad at common subexpression elimination because CSE is really hard to do without accidentally making functions stricter than they should be.
12:00:27 <Quadrescence> DukeDav1: Are you installing it in windows?
12:00:28 <chrisdone> > let foo = length $ map id [1..2000000] in foo
12:00:30 <lambdabot>  2000000
12:00:31 <chrisdone> > let foo = length $ map id [1..4000000] in foo
12:00:34 <lambdabot>  Tried to use too much memory
12:00:36 <thoughtpolice> waern: hopefully - lots of stuff is getting torn up and redone
12:00:36 <chrisdone> > let foo = length $ map id [1..2000000] in (foo,foo)
12:00:37 <newsham> quad: runhaskell Setup.hs configure    when it complains about missing packages, grab those packages and repeat
12:00:38 <lambdabot>  (2000000,2000000)
12:00:41 <tongucyumruk> Hi all, is there a way to escape a value from a monad?
12:00:41 <chrisdone> :)
12:00:45 <DukeDav1> Quadrescence: No ubuntu
12:00:46 <thoughtpolice> hopefully it is not for nothing ;) I think it *will* benefit a lot though
12:00:49 <tongucyumruk> For example
12:00:50 <chrisdone> tongucyumruk: never!
12:00:56 <SamB> Quadrescence: bug dcoutts to tell you where the latest tarball is for cabal-install, try to install it, install the packages cabal complains about, rinse, repeat
12:01:09 <Quadrescence> DukeDav1: Ah. Well, I'll tell you how my installation goes.
12:01:10 <dino-> I just installed Cabal 1.4.0.1 and cabal-install 0.5.1 on Debian. With GHC 6.8.2 already present. I did it from the .tar.gz cabalized packages I guess you'd say 'manually' with runhaskell Setup.hs ...
12:01:11 <chrisdone> SamB: I think my example is a good one of memoization
12:01:13 <thoughtpolice> tongucyumruk: generally speaking no, there isn't a function of type 'm a -> a'
12:01:16 <tongucyumruk> If you look at the code at http://tonguc.name/blog
12:01:18 <SamB> well, probably you could just find the tarball on cabal ;-)
12:01:19 <lambdabot> Title: Tonguç Yumruk'un Weblog'u
12:01:20 <SamB> er.
12:01:23 <dino-> What problems are you guys having? dependencies?
12:01:24 <SamB> hackage
12:01:30 <SamB> dino-: what else?
12:01:33 <chrisdone> thoughtpolice: fromJust
12:01:37 <tongucyumruk> I see
12:01:39 <DukeDav1> newsham: I'm current on a dep tree which goes: cabal-install -> unit -> directory -> old-time -> old-locale
12:01:43 <tongucyumruk> The thingis
12:01:46 <thoughtpolice> chrisdone: touche :p
12:01:48 <dino-> SamB: Yeah, probably the deps it needs already there (inadvertantly)
12:01:49 <chrisdone> head, etc.
12:01:57 <chrisdone> :P
12:02:00 <SamB> DukeDav1: unit?
12:02:03 <SamB> what's unit?
12:02:11 <tongucyumruk> Most of my computations are just pure functional
12:02:18 <DukeDav1> Now I just got:   Building old-time-1.0.0.0...
12:02:18 <DukeDav1> System/Time.hsc:118:7:    Could not find module `System.Locale':      it was found in multiple packages: old-locale-1.0.0.0 base
12:02:27 <DukeDav1> SamB: Sorry, typo, 'unix'
12:02:28 <dino-> MyCatVerbs: Thanks for explaining that. I've been under erroneous impressions on this stuff.
12:02:36 <SamB> DukeDav1: eh???
12:02:42 <SamB> doesn't GHC come with unix ?
12:02:51 <DukeDav1> Well apparently it's in base!
12:03:03 <SamB> DukeDav1: possibly you started with an old version of cabal-install?
12:03:09 <tongucyumruk> Whatever... Thanks a lot...
12:03:30 <SamB> % cabal --version
12:03:31 <SamB> cabal-install version 0.4.6
12:03:31 <SamB> using version 1.5.1 of the Cabal library
12:03:45 <SamB> what version are you trying to build?
12:03:50 <chrisdone> oh, crap. tongucyumruk is going to blog about how ignorant #haskell is
12:04:10 <DukeDav1> SamB: The unix I have is 2.1 (according to pkg-list) so I was grabbing a newer one from hackage     unix >=2.2&&<2.4,
12:04:41 <chrisdone> hai cale
12:04:44 * SamB tries to cabal install cabal-install
12:04:58 <SamB> hmm, 5 is building fine for me
12:05:00 <MyCatVerbs> dino-: also, if you have, say, f 0 = fib 100, f n = fib 100 + f (n-1), then it's possible that fib 100 will get calculated n times. (In this case, GHC's optimizer *will* get it, thanks to "let floating", but you can construct more complicated cases where it won't catch it).
12:05:03 <SamB> er. 0.5.0
12:05:14 <DukeDav1> SamB: Have the tar for cabal-install 0.5.2
12:05:25 <SamB> DukeDav1: hmm. maybe that's a bit too new?
12:06:10 * SamB tries pulling an updated package list
12:06:19 <chrisdone> haha, he actually has a blog (linked above). I was just joking, but maybe it will happen
12:06:24 <MyCatVerbs> dino-: er, much better example: map fib (repeat 100) -- will calculate (fib 100) for every single element of that list! (It's possible to make the optimizer beat this one easily enough, but I don't think anyone has.)
12:06:54 <Quadrescence> Oh noes, you guys are talking about what I need to know and I was in my other workspace getting the dependencies. :S
12:07:02 <MyCatVerbs> dino-: whereas let thunk = fib 100 in repeat thunk -- will calculate (fib 100) only once, no matter how many elements of the list you look at.
12:07:15 <Deewiant> MyCatVerbs: I've been thinking about writing a huge module of rewrite rules which would optimize stuff like that
12:07:30 <Deewiant> in that case, map f (repeat x) = repeat (f x)
12:07:33 <chrisdone> Deewiant: like list fusion?
12:07:38 <MyCatVerbs> Deewiant: *nodnod*
12:07:40 <DukeDav1> SamB: Yuck, 0.5.0 gives     Cabal >=1.4&&<1.5, network >=1&&<3, HTTP >=3000&&<3002, zlib >=0.4
12:07:48 <SamB> DukeDav1: hmm, when I install with the latest package list, I only get 0.5.1 -- what GHC version are you usiing ?
12:07:56 <Deewiant> chrisdone: and stuff like reverse.reverse = id, nub = map head.group.sort
12:08:01 <MyCatVerbs> chrisdone: using the same mechanism. :)
12:08:07 <DukeDav1> 6.6.1
12:08:09 <MyCatVerbs> chrisdone: but, easier, because these are rather simpler. :)
12:08:23 <SamB> DukeDav1: ah.
12:08:28 <SamB> I'm on 6.8.2
12:08:30 <DukeDav1> SamB I just realised 0.5.2 isn't in Hackage
12:08:35 <pianodogg> i wonder how often rewriting opportunities like this actually occur in "real" programs
12:08:48 <DukeDav1> I pulled it with darcs
12:08:49 <dino-> MyCatVerbs: I see. I will need to remember this. And Quadrescence: sorry for the bogus information
12:08:56 <DukeDav1> Wow
12:08:57 <dino-> Luckily people here know better
12:09:02 <DukeDav1> Ubuntu repos = behind
12:09:05 <DukeDav1> Screw it
12:09:15 <DukeDav1> I might just dist-upgrade
12:09:27 <dino-> DukeDav1: Ah I just started thiking that: don't use Debian or Ubuntu apt ghc
12:09:27 <newsham> duke: did you build ghc from srcs?
12:09:27 <chrisdone> A real program has appeared. Chris uses pokeball
12:09:42 <MyCatVerbs> Deewiant: that's going to piss off benchmarkers, y'know. "the naïve implementation, on the other hand, performs like... oh, dammit. Bloody compiler optimized it into the fast alternative."
12:09:54 <SamB> dino-: what's wrong with apt ghc?
12:09:56 <DukeDav1> newsham: Nah from Ubuntu repos
12:09:56 <newsham> did you install the ghc-extras?
12:09:59 <Quadrescence> dino-: It's alright. :D
12:10:04 <SamB> (in Debian, I mean)
12:10:12 <dino-> SamB: Well, it may be recent now, but a few months ago it was still 6.6
12:10:23 <dino-> And I suspect when we move up to another ghc, it will lag for months again
12:10:27 <MyCatVerbs> Deewiant: BTW, nub = map head . group . sort -- will actually break, because sort is strict in all the elements of the input list, whereas nub manages to work on infinite lists inputted.
12:10:28 <Deewiant> MyCatVerbs: well, the idea would be that you could import a module which contains nothing but rewrite rules
12:10:31 <DukeDav1> newsham: Can't seen a ghc-extras package
12:10:33 <dino-> I stopped letting apt manage my ghc at all
12:10:40 <Deewiant> MyCatVerbs: right, bad example :-)
12:10:53 <chrisdone> map id = id
12:11:00 <SamB> well what distros do you have in your sources.list?
12:11:00 <dino-> I don't run a sid system if I can avoid it. Too spooky.
12:11:00 <newsham> when building ghc from srcs theres a ghc-extras src tarball that contains a lot of important libraries
12:11:07 <SamB> testing, unstable, experimental?
12:11:08 <chrisdone> > map id []
12:11:09 <lambdabot>  []
12:11:10 <dino-> testing
12:11:12 <chrisdone> mmk
12:11:13 <newsham> i'm wondering if your debian package is missing those
12:11:14 <DukeDav1> newsham: Aha, sounds good
12:11:36 <DukeDav1> Considering how cheap space is it's ridiculous not just bundling all these deps
12:11:38 <MyCatVerbs> Deewiant: nub is O(k^2) where k is the position of the highest element that gets touched, or something like that. Your method is O(n*log(n)), but n is for the *whole list*, which might be much larger than k. :)
12:11:42 <dino-> newsham: Is that really better than installing the generic Linux binary ghc 6.8.2?
12:11:46 <dino-> build from src, I mean
12:11:51 <newsham> i dont know.
12:12:02 <newsham> i never installed the linux bin, and i dont normally run linux
12:12:05 <Deewiant> MyCatVerbs: yes, one has to be careful with such things. :-)
12:12:17 <MyCatVerbs> Deewiant: but you could give a version that used Data.Set to build up instead. :)
12:12:32 <TomMD> In the trivial case, is using 'dupChan' really necessary?  IOW, is there a difference between:
12:12:32 <TomMD> newChan >>= \c -> forkIO func c >> forkIO func c
12:12:32 <TomMD>     and
12:12:32 <TomMD> newChan >>= \c -> forkIO func c >> dupChan c >>= forkIO func
12:12:44 <SamB> DukeDav1: well, honestly I don't have that much space in /usr
12:12:45 <Quadrescence> :t nub
12:12:45 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:12:55 <dons> DukeDav1: as in cabal-install would provide all its own dependencies, other than ghc?
12:13:04 <newsham> > nub "now is the time for all good men to come to the aid of their country."
12:13:05 <lambdabot>  "now isthemfralgdcuy."
12:13:09 <newsham> > sort $ nub "now is the time for all good men to come to the aid of their country."
12:13:11 <lambdabot>  " .acdefghilmnorstuwy"
12:13:26 <DukeDav1> dons: Ya
12:13:35 <DukeDav1> Like a statically linked one off
12:13:37 <Quadrescence> sort $ nub "the quick brown fox jumps over the lazy dog."
12:13:52 <DukeDav1> So you could get cabal-install installed quickly
12:13:56 <pianodogg> forgot the >
12:14:01 <Quadrescence> > sort $ nub "the quick brown fox jumps over the lazy dog."
12:14:02 <lambdabot>  " .abcdefghijklmnopqrstuvwxyz"
12:14:08 <Quadrescence> winrar? I think so.
12:14:14 <dmwit> nah
12:14:32 <pianodogg> no wonder they use that sentence in font rendering tests
12:14:33 <chrisdone> > filter isLetter $ sort $ nub "the quick brown fox jumps over the lazy dog."
12:14:34 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
12:14:44 <dons> DukeDav1: the plan is to have it as a core part of the haskell platform, meaning every distro has a binary already
12:14:46 <chrisdone> pianodogg: O__________O
12:14:49 <dons> but removing the deps seems also reasonable.
12:15:20 <DukeDav1> Mmm, that would be tasty
12:15:26 <pianodogg> hey, i never noticed it before now
12:15:36 <chrisdone> hahaha, I lol'd
12:15:42 <dmhouse> > sort (nub "Big fjords vex quick waltz nymph")
12:15:43 <lambdabot>  " Bacdefghijklmnopqrstuvwxyz"
12:16:05 <dmhouse> > all (`elem` "Big fjords vex quick waltz nymph") ['a'..'z']
12:16:06 <lambdabot>  False
12:16:13 <dmhouse> > all (`elem` "big fjords vex quick waltz nymph") ['a'..'z']
12:16:14 <lambdabot>  True
12:16:26 <nominolo> dons: did you set up the ohloh page for GHC?
12:16:38 <dmwit> > length "bigfjordsvexquickwaltznymph"
12:16:40 <lambdabot>  27
12:16:45 <dmwit> Pretty close!
12:16:49 <Deewiant> two i's
12:16:54 <dmhouse> http://en.wikipedia.org/w/index.php?title=Pangram&oldid=224371823#Perfect_pangrams
12:16:55 <lambdabot> http://tinyurl.com/5ufv2j
12:17:09 <dmwit> > nub (sort "Mr. Jock, TV quiz PH.D., bags few lynx.")
12:17:10 <lambdabot>  " ,.DHJMPTVabcefgiklnoqrsuwxyz"
12:17:14 <dmwit> oops
12:17:27 <dmwit> > nub . sort . map toLower $ "Mr. Jock, TV quiz PH.D., bags few lynx."
12:17:28 <lambdabot>  " ,.abcdefghijklmnopqrstuvwxyz"
12:17:39 <dmhouse> > (length &&& \s -> all (`elem` filter isAlpha $ map toLower s) ['a'..'z']) "Jocks find quartz glyph, vex BMW."
12:17:40 <lambdabot>      The operator `elem' [infix 4] of a section
12:17:40 <lambdabot>         must have lower prece...
12:17:43 <dmwit> > length "mrjocktvquizphdbagsfewlynx"
12:17:44 <lambdabot>  26
12:17:50 <dmhouse> > (length &&& \s -> all (`elem` filter isAlpha (map toLower s)) ['a'..'z']) "Jocks find quartz glyph, vex BMW."
12:17:51 <lambdabot>  (33,True)
12:17:55 <dmhouse> Oops.
12:18:02 <gwern> faster nub is a difficult problem
12:18:21 <gwern> so far the best I've encountered is toList.fromList, but that breaks constraints
12:18:28 <dmwit> What constraints?
12:18:42 <dmwit> map head . group . sort -- stability?
12:18:47 <dino-> I see GHC is up to 6.8.3, does anybody know offhand if that still requires libreadline4?
12:18:50 <Quadrescence> What is the typical install process? configure --> ? --> ?
12:18:56 <Quadrescence> make --> install>
12:18:57 <Quadrescence> ?
12:18:59 <dmwit> build, install
12:19:01 <Quadrescence> build
12:19:02 <Deewiant> dmwit: doesn't work for infinite lists as MyCatVerbs pointed out
12:19:03 <Quadrescence> Yeah
12:19:06 <Quadrescence> Gracias
12:19:15 <dmwit> Deewiant: ah
12:19:15 <dmhouse> > let s = filter isAlpha (map toLower "Jocks find quartz glyph, vex BMW.") in (length s, all (`elem` s) ['a'..'z'])
12:19:16 <lambdabot>  (26,True)
12:19:22 <nominolo> Quadrescence: install for what?
12:19:29 <gwern> dmwit: also, map head when I've tried it has always been surprisingly slow
12:19:36 <Deewiant> dmwit: and also, if you only evaluate part of the list, nub may be faster
12:19:41 <Quadrescence> nominolo: I am installing the dependencies for cabal-install
12:19:45 <dmwit> Deewiant: right
12:19:49 <gwern> > map (+1) [1..100
12:19:49 <lambdabot>  Parse error at end of input
12:20:00 <dmwit> So, a fold that builds a set, then?
12:20:02 <Quadrescence> > map (+1) [1..100]
12:20:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
12:20:21 <nominolo> Quadrescence: configure, build, install then
12:20:45 <dmwit> :t scanl
12:20:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:20:50 <nominolo> Quadrescence: but you may want to specify a different --prefix to configure
12:20:53 <SamB> it's better to use one that just carries a Set of what it's already seen along the spine
12:21:06 <dmwit> SamB: That's what I mean.
12:21:32 <nominolo> Quadrescence: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
12:21:34 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
12:22:15 <Quadrescence> nominolo: I have installed before, I just forgot the "three magical words"
12:22:31 <nominolo> runghc Setup.hs --help :)
12:22:43 <SamB> I have nearly forgotten the "three magic words" myself
12:22:55 <SamB> cabal install is so cool -- did you know it worked in source trees as well?
12:23:07 * nominolo knows
12:23:23 <gwern> not really
12:23:29 <gwern> how does it work there?
12:23:34 <SamB> cabal install
12:24:10 <dons> nominolo: i did originally do the ohloh page yes.
12:24:12 <gwern> @tell dons I just heard back from the geomalglib guy; he says he'll merge in my changes and upload to hackage by the end of august
12:24:12 <lambdabot> Consider it noted.
12:24:18 <newsham> how do you use cabal-install to install into the system wide directory instead of in a user-specific directory?
12:24:18 <dons> gwern: ok.
12:24:18 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:24:23 <SamB> heh
12:24:25 <nominolo> dons: can you update the source repo?
12:24:34 <dons> ok. url?
12:24:39 <gwern> dammit, how do people like dons and dcoutts *do* that?
12:24:47 <SamB> gwern: hehehe
12:24:51 <nominolo> dons: the github mirror would probabbly best until we have git:// for darcs.haskell.org
12:24:54 <dmwit> newsham: Dunno, maybe pass --global?
12:25:04 <newsham> also is there a flag for profiling libs?  -p?
12:25:04 <SamB> gwern: bugged webcam
12:25:11 <nominolo> dons: git://github.com/ghc-hq/ghc.git
12:25:22 * gwern shakes fist at the invisible watchers
12:25:39 <DukeDav1> git :o
12:25:40 <DukeDav1> Shouldn't we be using that trendy Haskell vcs ?
12:25:51 <dons> nominolo: this is another argument in favour of git :) the core libs can be tracked.
12:25:56 <SamB> nominolo: he can login to the git-hq command?
12:26:06 <gwern> DukeDav1: we should, ideally, and it did
12:26:12 <nominolo> SamB: hm?
12:26:14 <dmhouse> DukeDav1: GHC switched to git last week.
12:26:18 <gwern> (unless you're being humorous and already know that)
12:26:20 <SamB> dmhouse: it did?
12:26:21 <nominolo> dons: yep. github is cool
12:26:26 <nominolo> dmhouse: well, kind of
12:26:26 <dons> nominolo: done.
12:26:39 <dons> SamB: you didn't get the memo?
12:26:42 <dons> doesn't anyone read the news/
12:26:50 <SamB> dons: it looked like you hadn't finished yet
12:26:54 <SamB> dons: where is the news/
12:27:05 <SamB> does it have an RSS feed?
12:27:11 <Igloo> dmhouse: ghc didn't switch to git yet, and may not do after all
12:27:22 <SamB> Igloo: why ever not?
12:27:25 <nominolo> dons: you are a bit too eager.  ghc *will* switch to git, but until the 6.10 branch we will use darcs
12:27:29 <Igloo> See glasgow-haskell-users@ for the discussion
12:27:30 <dmhouse> Oh, well, so much for getting your Haskell news from Reddit.
12:27:34 <dons> i'm using the git version.
12:27:48 <nominolo> dons: does it build?
12:27:49 <gwern> dmhouse: reddit did cover it
12:27:49 <gwern> twice
12:27:55 <DukeDav1> Why the move off darcs?
12:27:56 <gwern> the proposal and the announcement
12:28:05 <dmhouse> http://www.haskell.org/pipermail/cvs-ghc/2008-August/043999.html -- that was the message I recall reading
12:28:06 <lambdabot> Title: Version control systems
12:28:07 <dons> nominolo: i've not tried yet :) i'm waiting for the base libs to move into git as well, so there's some hope.
12:28:08 <pianodogg> nominolo: the real question is: does it blend?
12:28:22 <pjdelport> DukeDav1: http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation
12:28:23 <lambdabot> Title: DarcsEvaluation - GHC - Trac
12:28:24 <gwern> DukeDav1: performance problems, and occasional bugginess. the conflict problem didn't help
12:28:52 <nominolo> dons: it should, but only if you pulled from darcs.haskell.org;  there's a patch pending to fix that
12:29:05 <nominolo> pianodogg: it's quite controversial
12:29:44 <SamB> nominolo: darcs.haskell.org is so slow
12:30:07 <dons> Igloo: stalling on the move isn't helping. Will JaffaCake issue an order to move?
12:30:17 <gwern> it's also throttled, isn't it?
12:30:17 <DukeDav1> pjdelport: gwern: I see
12:30:27 <dons> gwern: not much.
12:30:42 <pianodogg> large projects are foolish if they don't use git :)
12:30:42 <nominolo> SamB: it depends.  mostly it's darcs that is slow.  but git over http isn't fast either.  git over ssh is pretty fast
12:31:07 <nominolo> gwern: a bit, yes
12:31:22 <Quadrescence> Someone give me their favorite package to install via cabal-install
12:31:25 <SamB> nominolo: I was talking about git over http from darcs.haskell.org
12:31:35 <nominolo> gwern: dons' post to reddit didn't help bandwidth either ;)  (many were testing the git repo)
12:31:42 <SamB> the fact that there's only one packfile there does NOT help
12:31:47 <gwern> heh
12:31:56 <dons> nominolo: yeah, we should have had github in place, and other mirrors.
12:32:10 <nominolo> SamB: ok.  i hope we'll have git:// soon.  i sent a request to our admin
12:32:17 <SamB> since that means that even if you pull from github first, you still end up having download that whole packfile
12:32:23 <gwern> @hoogle map
12:32:24 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
12:32:24 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
12:32:24 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
12:32:24 <roconnor> Backwards state monad programming often confuses me.
12:32:27 <gwern> @hoogle Data.Map.map
12:32:27 <lambdabot> No matches, try a more general search
12:32:46 <nominolo> SamB: no, incremental pulls work fine with the git protocol
12:32:54 <dino-> In any case, DukeDav1, I would install GHC 6.8.3 from generic Linux binary from here: http://haskell.org/ghc/download.html
12:32:54 <lambdabot> Title: The Glasgow Haskell Compiler
12:33:06 <SamB> nominolo: I know that ;-)
12:33:18 <SamB> I was still talking HTTP
12:33:23 <dons> Igloo: so what's the vote looking like? malcolm and igloo for darcs, chak, dons, rl, iavor, nominolo for git?
12:33:27 <nominolo> SamB: ah, you can keep pulling from github.  i'm keeping that in sync
12:33:30 <SamB> now, a workaround that works for ME is to use SSH instead
12:33:46 <SamB> (though I switched it back to github anyway...)
12:33:53 <nominolo> dons: dcoutts for darcs for cabal
12:33:55 <gwern> oh noes, dons voted for git?
12:33:58 <dons> and tibbe for git.
12:33:59 <gwern> traitor!
12:34:08 <dons> gwern--
12:34:09 <dino-> I'm not sure if it still requires libreadline4 like 6.8.2 does, if so you can get an old .deb that works for us with Debian lenny and Ubuntu Feisty here: http://packages.debian.org/sarge/libreadline4
12:34:09 <dmhouse> Igloo: can you reference the git discussion thread? I can't seem to find it.
12:34:11 <lambdabot> Title: Debian -- Details of package libreadline4 in sarge
12:34:11 <SamB> I don't honestly care what RCS cabal uses
12:34:24 <gwern> @karma gwern
12:34:24 <lambdabot> You have a karma of -1
12:34:25 <matthew-_> I voted for bzr. But also, I don't think I have a vote ;)
12:34:38 <nominolo> gwern++ let's be friendly
12:34:38 <gwern> wait, I was sure I had more karma than that
12:34:47 <gwern> ah well. you can't take my reddit comment karma away!
12:34:55 <dino-> Sorry, I was wrong, not Fiesty, it's Hardy
12:35:13 <nominolo> @karma gwern
12:35:13 <lambdabot> gwern has a karma of 0
12:35:31 <EvilTerran> preflex: karma gwern
12:35:31 <preflex>  karma for gwern: 6
12:35:36 <EvilTerran> there's your karma!
12:35:48 * gwern munches hungrily on't
12:35:48 <EvilTerran> preflex: karma
12:35:48 <preflex>  karma for EvilTerran: 8
12:35:57 <heatsink> I don't understand the absence of a type error, can someone help? http://hpaste.org/9521
12:36:09 <nominolo> none of the options are perfect
12:36:23 <SamB> hmm, someone who's actually subscribed to glasgow-haskll-users should reply that git has better ways to handle such things
12:36:29 <nominolo> in the end git mostly won because of the bigger community
12:36:33 <SamB> on the git and sync-all thread
12:36:39 <Igloo> dmhouse: Starts at http://www.haskell.org/pipermail/glasgow-haskell-users/2008-August/015158.html
12:36:40 <lambdabot> Title: Version control systems, http://tinyurl.com/6mnwxj
12:36:57 <Igloo> dons: It's not a vote, exactly
12:37:31 <Igloo> dons: And your list is wrong anyway, e.g. Manuel says he is not advocating to move in http://www.haskell.org/pipermail/glasgow-haskell-users/2008-August/015178.html
12:37:32 <lambdabot> Title: Version control systems, http://tinyurl.com/6pgdzo
12:37:37 <dons> yes, I can't see how this is going to resolve.
12:37:49 <dons> Igloo: he's advocating one rcs only.
12:37:56 * gwern is taking 5:2 odds on git
12:38:12 <Igloo> dons: and rl says "Maybe investing some time in fixing the most obvious darcs problems would be a better solution?" in http://www.haskell.org/pipermail/glasgow-haskell-users/2008-August/015174.html
12:38:13 <lambdabot> Title: Version control systems, http://tinyurl.com/5fv6wd
12:38:26 <gwern> finally someone says that
12:38:36 <dons> yeah, that's worked well in the past.
12:38:40 <Igloo> dons: Misrepresenting people's opinions isn't going to help
12:38:49 <dons> i was trying to summarise, Igloo.
12:39:15 <dons> given that we appeared to have reached a decision to move the compiler to git.
12:39:25 <pgavin> git seems much more stable than darcs, but I haven't used it much
12:39:32 <pgavin> darcs likes to get stuck
12:39:32 <dons> though you seem to be arguing that move's been suspended?
12:39:50 <nominolo> dons: what were the reasons for the broken darcs repos you mentioned?
12:39:57 <dino-> To add my devalued US$0.02: I'm saddened it's moving from darcs from the Haskell-solidarity point of view. But any of the other of that style are great (git, bzr, etc..)  Just please, for the love of all that is just, not svn.
12:39:59 <SamB> Igloo: the most obvious darcs problem is that it's abstraction doesn't seem to work well :-(
12:40:10 <SamB> in cases like GHC's, at least
12:40:19 <dons> nominolo: darcs breaking on merges, and conflicts, it seems. the causes are unknown, other than that we were working at the time.
12:40:32 <Igloo> dons: I think we are back in "undecided" mode, but the Simon's haven't given an opinion since the thread
12:40:50 <SamB> and ... wouldn't it make more sense to make the switch on the development branch ???
12:40:51 <dons> ok. so then it's really JaffaCake's call.
12:41:10 <dons> that's what i'm trying to work out -- how any decision is going to be made here. ultimately though, it's a ghc HQ question, effectively.
12:41:23 <dons> perhaps informed by other people doing big development work.
12:41:41 <gwern> the simons must be doing the BDFL thing - lurk and see what everyone says, and then lay down a decree from on high
12:41:43 <SamB> well, Linus seems happy, as does X.org
12:41:44 <dons> so rl, chak, nr, malcolm.
12:41:50 <pianodogg> the issues might be fundamental to the darcs world view.  why not reimplement git in haskell :)
12:41:58 <dons> Igloo: and nr was strongly in favour of a) moving , and b) moving everything?
12:41:59 <gwern> reasonable - hopefully by the time the thread is expired everyone will have vented all their spleen and no surgery would be necessary
12:42:08 <SamB> pianodogg: might be?
12:42:26 <SamB> I think it's understood that they are fundamental to darcs way of operating by now
12:42:30 <dons> while we have some people in the b) if we move => move everything camp. but contingent on the move.
12:42:43 <Quadrescence> Is an exponential search the same as an n-ary search? (I just made up the n-ary, but I'm sure it will be understood)
12:42:49 <SamB> 'twould be cool if darcs was just a way to manage patches for git ...
12:43:08 <SamB> (patches that haven't been committed yet, you know?)
12:43:19 <Igloo> dons: Ultimately it is the Simons who decide if the GHC repo moves or not, yes. It's not really clear who has the final say on the libraries
12:43:25 <pianodogg> there are already things like stacked git (stgit)
12:43:28 <nominolo> SamB: yes, except for interactive push/pull, git is a superset of darcs
12:43:35 <SamB> Igloo: upstream, of course
12:43:38 <pianodogg> but in general you just want to create a separate branch for each "patch" and manage things that way
12:43:40 <Quadrescence> Nevermind, it's not.
12:43:51 <SamB> Igloo: meaning whoever actually hacks on them
12:43:52 <nominolo> dons: SamB, i wouldn't be surprise if sooner or later git would get darcs' capabilites
12:43:54 <dons> Igloo: so didn't JaffaCake say unambiguously that the move was on?
12:44:13 <SamB> nominolo: I was thinking that maybe darcs would actually sometime become that
12:44:23 <dons> or you're saying that since the discussion continued on the list, maybe that needs to be reaffirmed?
12:44:25 <SamB> I think it's been tried before
12:44:40 <Igloo> dons: Yes, we decided to definitely move ghc only to git. I imagine that this decision will be revisited given the thread that has happened since.
12:44:50 <SamB> nominolo: git isn't a superset of darcs
12:44:50 <kowey> darcsgit was discontinued due to lack of hackers
12:44:56 <dons> "the GHC team have made a decision: we're going to switch to git"
12:45:01 <gwern> nominolo: worse is better; the needs that the Right thing satisfies will eventually be demanded by users of the Worser thing
12:45:09 <Igloo> It's possible that it will happen anyway, of course, but it seems unlikely given pretty much everyone seems to think it is the worst of the 3 ways forward
12:45:23 <nominolo> gwern: yeah. we get the usual 50% -> 90%
12:45:29 <Heffalump> does Simon PJ think that?
12:45:36 <nominolo> gwern: but i'm not sure darcs can reach 100%, either
12:45:43 <Igloo> The Simons haven't commented since the thread
12:45:44 <SamB> git uses a completely different worldview -- which seems to be impractical for ancient history, but much more practical for bleeding-edge code
12:45:47 <SamB> er.
12:45:51 <SamB> s/git/darcs/
12:46:19 <Heffalump> Igloo: right, so there might be one or two key people who don't think it the worst of the three ways
12:46:21 <gwern> it's a good question. I'm not as familiar with git as I'd liked, but everything I've heard strikes me as crude and hacky
12:46:35 <Igloo> Yes, true
12:46:36 <SamB> what are the other two ways?
12:46:49 <dons> a) stay in darcs. b) git + darcs, c) all git.
12:46:56 <sioraiocht> I quite like git
12:46:59 <SamB> gwern: the crude, hacky stuff is just the implementation
12:47:01 <dons> we've people who are for a || c, few for b. some for c) some for a
12:47:04 <pianodogg> imho, git is the very elegant version control system.  the cmdline ui is crazy though
12:47:17 <SamB> the actual concept is strikingly simple
12:47:28 <pianodogg> SamB: exactly
12:47:38 <dons> and there seems to be pretty good arguments against the b) model.
12:47:38 <SamB> and fits projects with a long history extremely well
12:47:46 <gwern> if you say so
12:47:59 <thoughtpolice> git + darcs just isn't feasible, it raises the barrier to entry, something I've already complained about on cvs-ghc in relation to the new build system infrastructure changes, it simply raises the barrier of entry
12:48:00 <dons> leaving us with the bigger step of moving libs to c) if ghc's going to work, or abandoning the move, which seems unlikely.
12:48:11 <SamB> does (b) mean use both VCS' for GHC? is that even possible?
12:48:21 <thoughtpolice> SamB: git for ghc, darcs for all the core libs
12:48:22 <nominolo> well, Git has problems with binary files, has incomplete cherry-pick, and doesn't support partial checkout
12:48:29 <thoughtpolice> the problem is the core libs and GHC affect each other deeply
12:48:36 <SamB> (b) is fine in thoughtpolice' interpretation
12:48:37 <nominolo> but bzr, mtn, hg have other problems
12:48:37 <dons> thoughtpolice: and the problem there is that typically we change base in response to ghc.
12:48:37 <Igloo> nominolo: What are git's problems with binary files?
12:48:46 <thoughtpolice> dons: right
12:48:56 <SamB> git stores binary files fine
12:49:14 <nominolo> SamB: only if you don't change them a lot
12:49:22 <dmhouse> SamB: not really, the two projects are linked quite tightly, aren't they? You don't really want people to be using two VCS systems for hacking on GHC.
12:49:27 <chrisdone> why does the degree of change matter?
12:49:33 <thoughtpolice> if we could get darcs to work better to the point of using it for GHC that would be nice, I am skeptical it can be done in the time frame before the switch
12:49:36 <thoughtpolice> dmhouse: no, you don't
12:49:37 <pianodogg> what binary files are changing all the time in ghc?
12:49:37 <SamB> dmhouse: well, I think it should be on a library-by-library basis
12:49:55 <nominolo> Igloo: not sure exactly; it works, but if you have many, people advise to use SVN for those
12:50:03 <Heffalump> a big problem of sticking with darcs is that it keeps breaking for Simon PJ
12:50:05 <nominolo> Igloo: but that's the same with darcs, i think
12:50:15 <waern> what about giving darcs some more time, perhaps until 6.12?
12:50:19 <SamB> whatever the people who actually hack on a particular library want to do, they should do
12:50:21 <nominolo> Heffalump: when did he say so?
12:50:22 <chrisdone> Heffalump: and when peyton `simon` jones gets mad..
12:50:24 <SamB> waern: no way
12:50:27 <thoughtpolice> waern: i'm not sure people are willing to put up with that
12:50:31 <thoughtpolice> it already has some bad issues now
12:50:43 <Quadrescence> hrm, maybe I should study quantum computer science.
12:50:44 <dons> Heffalump: for simonpj, and for merges from chak, rl and nr.
12:50:46 <SamB> oh, but is Simon PJ using --hashed format?
12:50:47 <Heffalump> nominolo: see the darcs bug reports
12:51:02 <SamB> or are the problems more conceptual in nature?
12:51:11 <nominolo> Heffalump: the big problem is that GHC still uses darcs1 format
12:51:15 <dons> nr's story was a bit distressing. week+ wasted on merging. chak's Fc merge had to be done by hand. and then broken repos scattered through that mess.
12:51:19 <Heffalump> I don't understand why (b) is so bad. Can't people just write some shell scripts?
12:51:27 <nominolo> the whole point is that we would have to switch the whole repo anyway
12:51:28 <Heffalump> nominolo: darcs2 runs slower for some tasks than darcs1
12:51:29 <gwern> you know dons, advocating as few dependencies as possible is the sort of philosophy that made the darcs codebase so redundant and crufty
12:51:33 <SamB> (b) is FINE
12:51:44 <Heffalump> which is why they haven't switched even to hashed format, which isn't an incompatible change
12:51:46 <nominolo> and darcs2 is not enough better than darcs1
12:51:48 <dons> gwern, we're talking about tools, not libraries.
12:51:50 <SamB> GHC itself clearly isn't working in darcs
12:52:04 <thoughtpolice> if we are going to make a move it needs to be one way or the other
12:52:12 * gwern refuses to see a distinction between tools and libraries
12:52:13 <thoughtpolice> half 'n' half is just going to cause complications
12:52:28 <thoughtpolice> and ultimately confuse people and make things harder
12:52:43 <SamB> but libraries will not just want to all use the same VCS as GHC -- at the very least, we have to let them switch over when they can manage
12:52:46 <dons> gwern, then you're silly. libraries means doubling the amount of code. remove tool deps means halving the number of tools needed.
12:53:08 <thoughtpolice> SamB: not all libraries have to switch, it's an issue of the core libs more than anything
12:53:16 <SamB> sure
12:53:20 <Heffalump> thoughtpolice: asking all the people who are happily using darcs without problems to swich is unreasonable
12:53:43 <dons> we did it for cvs though.
12:53:45 <SamB> obviously the ones that are primarily developed by "ghc-hq" should switch
12:53:53 <Heffalump> but CVS is rubbish, people were happy to get away from it
12:54:13 <newsham> there is a whole world out there beyond cvs
12:54:14 <dons> right, so the difference here is that darcs' issues affect not all devs. but those it does are doing the big things.
12:54:29 <SamB> hey, darcs' issues affected me too
12:54:38 <SamB> I wasn't even doing big things
12:54:48 <thoughtpolice> re: shell scripts to wrap functionality, it is simply hard to model parts of darcs and git in a way that the wrappers can work bidirectionally
12:54:51 <thoughtpolice> at the very least
12:54:55 <nominolo> SamB: are you a libraries committer? :)
12:54:59 <thoughtpolice> you are going to cut out the more advanced functionality of one or another
12:55:06 <thoughtpolice> so you'd have to end up learning darcs AND git anyway
12:55:16 <SamB> but only in GHC's repository have I had most of these problems
12:56:03 <nominolo> i am for moving the core libraries into GHC for the simple reason that this will solve a lot of GHC/libs consistency issues
12:56:20 <SamB> nominolo: GHC or git?
12:56:28 <nominolo> well, both
12:56:31 <SamB> WHAT?
12:56:40 <SamB> git has better facilities for that sort of thing
12:56:52 <nominolo> well, you could move it into the ghc.git repo
12:57:08 <SamB> which ones do you mean by "core"?
12:57:11 <nominolo> or you could move it into separate git repos, and use git modules
12:57:18 <nominolo> SamB: the official core-libs
12:57:25 <nominolo> the minimal libs to build ghc
12:57:32 <pianodogg> except that i don't see a reason not to have all of that in the same git repo
12:57:39 <pianodogg> yes, exactly, then you don't need submodules or whatever
12:58:06 <nominolo> pianodogg: the disadvantage is that you would have to checkout the whole ghc history to work on a single library
12:58:12 <nominolo> e.g. for a small fix
12:58:13 <Igloo> nominolo: I don't think that git-bisect (or equivalent) makes sense for something that takes as long as GHC to compile anyway
12:58:20 <SamB> nominolo: I can't find the list atm
12:58:24 <SamB> can you refresh my memory
12:58:38 <chrisdone> dons: hey remember formlets? they are sooo cool. chr1s has made them optionally monadic, see how I check the DB?<333 http://hpaste.org/9522
12:58:39 <pianodogg> but virtually everybody doing even small fixes would have a copy of the whole repo already
12:58:49 <nominolo> Igloo: it does.  maybe not for git-bisect alone, but for the buildbots at the very least
12:58:50 <pianodogg> and other people doing "small fixes" ought to have the whole thing anyway for testing, etc
12:59:02 <Igloo> nominolo: How does it help the buildbots?
12:59:03 <SamB> nominolo: I do not think that all of those should be tied to GHC in the "merge into ghc.git" manner
12:59:06 <nominolo> SamB: which list?
12:59:20 <SamB> the list of libs in core-libs
12:59:35 <SamB> oh, now I found it
12:59:45 <nominolo> Igloo: you can instruct them to build a certain version of the whole tree
12:59:58 <Heffalump> can't you just tag to get that effect?
12:59:59 <SamB> a lot of those libraries would ideally be useful in other Haskell implementations, some already are
13:00:05 <nominolo> Igloo: you don't need to be careful about in-between changes of the libraries
13:00:11 <Igloo> nominolo: Why is that useful, though?
13:00:19 <nominolo> Heffalump: you'd need cross-repo tags
13:00:26 <Heffalump> so?
13:00:26 <nominolo> Heffalump: and a lot of those
13:00:50 <SamB> I agree that git's modules should be leveraged
13:01:16 <Igloo> If we used git modules, you would still be able to get a lib's history without also getting ghc's history, right?
13:01:23 <SamB> of course
13:01:29 <nominolo> yup
13:01:42 <SamB> in fact, you don't even have to check out all of the modules if you don't want to
13:01:44 <nominolo> but you must remember to link external repos and current repo
13:02:31 <nominolo> ie., a submodule is a pointer to another repo's revision and these pointers are version-controlled
13:02:31 <sioraiocht> dcoutts_: ping?
13:03:08 <chr1s> chrisdone: thanks B)
13:03:18 <Igloo> nominolo: So why is being able to tell teh buildbots to build a certain version useful?
13:03:25 <chrisdone> chr1s: ^___^!
13:03:25 <dcoutts> sioraiocht: pong
13:04:10 <nominolo> to make sure it builds exactly the version you want.  then you can automatically run scripts that integrate successful builds into head
13:04:14 <chr1s> chrisdone: I also think they're awesome.
13:04:30 <chrisdone> chr1s: haha, yes. :P
13:04:33 <glguy> breaking a library doesn't break HEAD then
13:04:41 <nominolo> Igloo: darcs pull/push is hard to script and push/pull -a is fragile
13:04:43 <glguy> it just stops it from advancing HEAD
13:04:53 <nominolo> glguy: exactly
13:04:59 <chr1s> chrisdone: I hope they're going to write some more papers about it.
13:05:04 <dcoutts> dons: my position is that I'd rather not split the community. I'd rather not move Cabal from darcs. I'm not qualified to comment on ghc's problems with darcs since I don't hit the problems (I've never had any problems with conflicts ever). I can see the problem with using a mixture but if ghc really wants to move then that would seem to be the result.
13:05:22 <Heffalump> nominolo: what's so hard about tags, though?
13:05:25 <SamB> I agree with dcoutts
13:05:33 <dcoutts> ideally I'd like to see darcs improved, but that may or may not be possible, especially on the timescales we might want
13:05:42 <SamB> hmm.
13:05:49 <SamB> I hold two conflicting viewpoints.
13:05:53 <chrisdone> chr1s: agreed. it kind of makes you surprised people write web pages any other way
13:05:56 <dcoutts> SamB: ;-)
13:06:00 <chrisdone> chr1s: at least, willingly
13:06:04 <SamB> Obviously, git needs better modules ;-P
13:06:09 <SamB> which support darcs too
13:06:20 <chr1s> chrisdone: yeah, I know.
13:06:24 <dcoutts> SamB: clearly to need support for cleanly merging your two conflicting views, in polynomial time. :-)
13:06:32 <nominolo> Heffalump: i think it would just become messy
13:06:49 <SamB> anyway, for any libraries that do switch to git, it would be a shame not to use git's modules
13:07:07 <nominolo> Heffalump: you'd need to add new tags all the time (or move old tags which may lead to other problems)
13:07:19 <SamB> you can't move tags in git OR darcs
13:07:22 <Heffalump> I guess it depends how often you want to test
13:07:25 <SamB> not really truly
13:07:30 <Heffalump> in darcs you just add the same tag again
13:07:33 <nominolo> SamB: yes you can
13:07:35 <Heffalump> but you can obliterate old ones
13:07:39 <SamB> can't
13:07:44 <nominolo> SamB: git tag -f
13:07:47 <Heffalump> can
13:08:10 <nominolo> SamB: and darcs doesn't complain if you add the same tag again
13:08:14 <SamB> Heffalump: that would play bloody havoc with the inventories
13:08:16 <nominolo> SamB: we have it in the ghc repo
13:08:23 <Heffalump> SamB: why?
13:08:30 <nominolo> SamB: that's true.  the tools still allow it though
13:08:42 <nominolo> but in git you have to force it
13:08:46 <SamB> Heffalump: you haven't looked at the inventories?
13:09:07 <glguy> moving tags in git are called branches
13:09:09 <chrisdone> chr1s: input' is really sweet. it's like defining custom widgets. custom _composable_ widgets.
13:09:13 <SamB> nominolo: you didn't read the fine print did you ;-)
13:09:47 <nominolo> SamB: i know it's bad.  i'm just saying it's still possible.  in both
13:10:01 <SamB> nominolo: you effectively can't
13:10:15 <nominolo> why not?
13:10:18 <ddarius> After a good chunk of tedium...
13:10:19 <ddarius> @wiki QuotesPage
13:10:20 <lambdabot> http://www.haskell.org/haskellwiki/QuotesPage
13:10:21 <SamB> read the fine print
13:10:26 <nominolo> no
13:10:34 <nominolo> give me a link
13:10:46 <SamB> git-tag(1)
13:11:34 <nominolo> SamB: i've read all that!
13:11:38 <glguy> Why are we discussing moving tags?
13:12:01 <Heffalump> SamB: I know about clean tags and splitting inventories, but I don't see why that's an issue
13:12:02 <SamB>        But if you have pushed things out (or others could just read your
13:12:07 <nominolo> glguy: SamB claims you can't do it.  I'm claiming you CAN but SHOULDN'T
13:12:09 <SamB> start reading from there
13:12:27 <glguy> nominolo: OK, you win
13:12:38 <nominolo> do i get a cookie?
13:12:58 <SamB> nominolo: you didn't win with me yet
13:12:58 <glguy> deleting the locally might not be propagated upstream though
13:13:22 <nominolo> SamB: why does the existence of git tag -f invalidate my statement?
13:13:40 <SamB> nominolo: not the existance
13:13:52 <SamB> the not-changing-behind-peoples-back bit
13:14:01 * nominolo assumes this is a pointless semantics of "can" issue
13:14:06 <SamB> perhaps
13:14:10 <Quadrescence> AHhahahahah, one of the funniest things I've seen --> https://addons.mozilla.org/en-US/firefox/addon/3792
13:14:15 <glguy> but my original question why "why are we discussing it" when the right way to do this is with a new branch?
13:14:16 <SamB> I did say that you effictively can't
13:14:18 <glguy> that just trails another
13:14:24 <SamB> glguy: new tag
13:14:28 <nominolo> SamB: "can" = "the tools give you the possibility to use it"
13:14:36 <SamB> nominolo: define "use"
13:14:48 <glguy> have a "builds" branch that follows the "master" branch
13:14:49 <nominolo> COME ON!
13:15:08 <SamB> basically, what I'm saying is that you could do it but it would basically produce UB
13:15:22 <SamB> glguy: we aren't talking about that
13:15:24 <nominolo> SamB: i'm not continuing this discussion... it has become pointless minutes ago
13:15:38 <SamB> nominolo: remember, I *did* say effectively
13:15:52 <nominolo> I *didn't* say effectively
13:15:58 <waern> nominolo: how is your ghc api hacking going?
13:16:00 <Heffalump> CAN! CAN'T!
13:16:13 <glguy> BUY SELL?
13:16:13 <nominolo> waern: so-so
13:16:24 <SamB> oh, well why didn't you just agree with me when I said you can't effectively ?
13:16:29 <SamB> anyway...
13:16:47 <dons> nominolo: beware of SamB. he has far too much time on his hands, and enjoys pointless diversion
13:17:00 <SamB> I do not have too much time on my hands
13:17:02 <nominolo> [x] lesson learned
13:17:11 <SamB> I just spend it on the wrong things sometimes
13:17:22 <waern> nominolo: ok, well, I guess I will notice soon. I'll be adding support for GHC 6.9 in haddock
13:17:37 <nominolo> waern: changing error handling is very cross-cutting, in aspect-oriented programming terms
13:17:51 <waern> nominolo: yeah
13:18:01 <nominolo> waern: oh, yes, it'll break.  but the changes should be straightforward
13:18:20 <SamB> what does "cross-cutting concerns" have to do with AOP?
13:19:59 <nominolo> SamB: i think it's official AOP terminology.  but i guess it's also used generally
13:20:11 <SamB> I saw it in the GHC-commentary
13:20:19 <SamB> plus it's not even jargon
13:20:29 <SamB> it means just what it sounds like
13:20:41 <nominolo> http://en.wikipedia.org/wiki/Cross-cutting_concern
13:21:31 <dons> don't we call that kind of thing a "non-local transformation"
13:21:38 <dons> in felleisen's terms
13:22:31 <dons> from `On the Expressive Power of Programming Languages  '
13:22:34 <nominolo> dons: could be.  however you call it, i have to touch lots of files
13:22:37 <dons> :)
13:22:39 <dons> right.
13:23:21 <dons> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656
13:23:22 <lambdabot> Title: On the expressive power of programming languages - CiteSeerX
13:23:45 <SamB> dons: usually we call it a cross-cutting concern when we are talking about software we are writing
13:23:57 <SamB> non-local transformations are things *compilers* do
13:24:11 <nominolo> dons: so glad citeseer is working again
13:24:17 <chrisdone> anyone ever made a haskell API for talking to a javascript session in a browser via AJAX?
13:24:23 <dons> SamB: no, you should read that paper.
13:24:29 <SamB> dons: I did
13:25:22 <dons> then you'll know that it talks about transformations programmers have to make when writing code.
13:25:41 <SamB> hmm.
13:27:00 <SamB> well, in any case, the GHC commentary uses the term "cross-cutting concerns"
13:33:47 <dino-> I'm trying to install something with cabal install and it's stubbornly only putting the Haddock in my ~/.cabal  Tried a lot of things like configure --global and --prefix=/
13:35:30 <dcoutts> dino-: hmm? you mean it installs everything where you want except the haddock docs?
13:35:53 <dino-> No I don't think anything is going to /usr/ nothing
13:36:15 <dino->  The package is exif-3000.0.0.tar.gz
13:36:27 <dino-> from Hackage, downloaded the .gz and did it local (to be able to get haddock generated)
13:36:44 <dino-> I was just experimenting with a possible sh script that does the steps with the cli cabal tool
13:37:27 <dcoutts> dino-: it wouldn't go to /usr if you used --prefix=/
13:37:31 <dino-> But even typing the command by hand: cabal configure --global --prefix=/ ; cabal build ; cabal test ; cabal haddock ; sudo cabal install
13:37:41 <dino-> No good, only puts in my ~/.cabal
13:37:58 <dino-> Ok, also won't go in user with --global alone
13:38:16 <dcoutts> dino-: the sudo cabal install is doing the configure step with default settings
13:38:31 <dcoutts> dino-: you'd want to do sudo cabal install --global --prefix=/usr
13:38:36 <dcoutts> or better:L
13:38:57 <dcoutts> cabal install --global --prefix=/usr --root-cmd=sudo
13:39:14 <dcoutts> that way you do the build as you and only install as root
13:39:15 <dino-> I guess I'm used to native projects where you do everything but install as not-root and then the install as root.
13:39:21 <SamB> dcoutts: why isn't sudo the default?
13:39:26 <dino-> ah
13:39:35 <dcoutts> SamB: some people think it's the wrong default
13:39:43 <SamB> what is the default?
13:39:44 <Heffalump> because trying to do things as root without permission is bad
13:39:53 <SamB> hmm.
13:40:07 <dcoutts> SamB: well --user is the default, and for --global it assumes you already have perms
13:40:08 <SamB> so is fakeroot the default then?
13:40:13 <dino-> But wait, if I want things to go to the normal prefix, is --global alone good for that?
13:40:21 <SamB> no that wouldn't make any sense...
13:40:31 <dcoutts> dino-: default prefix for --global is /usr/local  as it should be.
13:40:35 <dino-> I mean, no --prefix
13:40:40 <dino-> ok, as per the docs
13:40:45 <dcoutts> right :-)
13:41:07 <dcoutts> dino-: so the confusing thing was that cabal install foo does everything in one go.
13:41:22 <dcoutts> and takes all the configure flags too
13:41:24 <dino-> Yes, but I can't use that because I want Haddock in like 95% of my installations.
13:41:40 <dcoutts> dino-: then grab the darcs version and use --enable-documentation
13:41:44 <chrisdone> sigh. I think I'm going to have to go back to college and take maths
13:42:37 <chrisdone> seems pretty sad. twenty year old with a beard. "hey, how do I solved quadratic equations?"
13:42:44 <trofimovich> > let !x = 1 in x
13:42:44 <lambdabot>  Parse error at "!x" (column 5)
13:43:01 <trofimovich> > let x = 1 in (1 :: !Int)
13:43:01 <lambdabot>  Parse error at "!Int)" (column 20)
13:43:19 <pgavin> let (!x) = 1 in x
13:43:28 <pgavin> > let (!x) = 1 in x
13:43:28 <lambdabot>  Parse error in pattern at "in" (column 14)
13:43:32 <matthew-_> > let (!) x = 1 in x ! undefined
13:43:35 <lambdabot>   add an instance declaration for (Num (a -> a1))
13:43:36 <dmhouse> They're a GHC extensions, I don't think lambdabot has them on.
13:43:45 <pgavin> > let { (!x) = 1 } in x
13:43:45 <lambdabot>  Parse error in pattern at "}" (column 16)
13:43:55 <pgavin> > let { (!x) = 1 ; } in x
13:43:55 <lambdabot>  Parse error in pattern at ";" (column 16)
13:44:00 <trofimovich> > let x = 1 in x `seq` x
13:44:01 <lambdabot>  1
13:44:30 <pgavin> > {-# LANGUAGE BangPatterns #-} let !x = 1 in x
13:44:30 <lambdabot>  Parse error at "!x" (column 35)
13:44:49 <matthew-_> cat main.hs | sed -e 's/LANGUAGE/LANGUAGE BangPatterns,/' > main.hs.new && mv main.hs.new main.hs
13:44:51 <thoughtpolice> lambdabot doesn't do pragmas
13:45:26 <trofimovich> > import System.IO
13:45:27 <lambdabot>  Parse error at "impor..." (column 1)
13:45:27 <pgavin> thoughtpolice: yeah, I didn't really expect that to work :)
13:45:55 <SamB_XP> yeah, imagine if we could use {-# TemplateHaskell #-}
13:46:09 <trofimovich> @hoogle unsafePerformIO
13:46:10 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
13:46:10 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
13:46:47 <dino-> Do I need to also sudo the install command? I get permission errors with --root-cmd=sudo
13:47:01 <SamB_XP> dino-: that's probably a bug?
13:47:08 <dino-> beats me
13:47:12 <matthew-_> SamB_XP: yeah, there are a few places, I believe, where that can cause security issues
13:47:21 <SamB_XP> dino-: ... or you just forgot to delete the root-owned files from before
13:48:07 <dino-> mm, that may be. There's a pile of root owned stuff now in my ~<notroot>/.cabal/lib
13:48:19 <newsham> Loading package unix-2.3.0.0 ... ghc-6.8.2: can't load .so/.DLL for: util (/usr/lib/libutil.so: Undefined symbol "__mb_sb_limit")
13:48:22 <tibbe> @seen dons
13:48:22 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 23m ago.
13:48:31 <dino-> It's gotten messy in there
13:48:33 <newsham> is that something I should file in ghc trac?
13:48:56 <tibbe> dons: I'm almost finished wrapping the bsd kqueue API, thought I write a benchmark using that as soon as I have time
13:49:01 <SamB_XP> that's a release version of GHC? and the latest on it's branch?
13:49:03 <matthew-_> newsham: can you repeat it?
13:49:07 <tibbe> dons: when I'm sure it's working I'll push some patches
13:49:08 <matthew-_> from a fresh install?
13:49:17 <dcoutts> dino-: if it's really bad you can always rm it and the .ghc dir, that'll loose all per-user registered packages.
13:49:24 <tibbe> dons: can't test an epoll binding on my laptop
13:49:28 <newsham> matthew: yup, but its not a small repro -- build HAppS-Data.
13:49:31 <trofimovich> @help ask
13:49:31 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
13:50:08 <matthew-_> newsham: ok, I don't know happs at all - you think the bug lies with the build for happs?
13:50:12 <dino-> dcoutts: The where the registration is contained for user, in the ~/.ghc? That's good to know.
13:50:19 <newsham> i have no idea at all, which is why I ask.
13:50:34 <newsham> but unix-2.3.0.0 is part of ghc dist (or -extras) right?
13:50:43 <dcoutts> dino-: right, use ghc-pkg list to see what's registered and where the package database files are exactly.
13:50:43 <dino-> I suppose I could blow away my entire ~/.cabal at this stage
13:50:55 <newsham> could also be ghci bug (this is freebsd/amd64 which has ghci problems)
13:50:57 <Lemmih> newsham: What happens when you load unix in ghci?
13:51:02 <dcoutts> dino-: you could save the packages dir, it's just a cache of downloaded tarballs.
13:51:06 <newsham> those "... linking ... done." messages are ghci dynamic loading, yes?
13:51:09 <newsham> ie.. TH perhaps?
13:51:32 <Lemmih> newsham: Yes, TH.
13:51:39 <dino-> dcoutts: ya, I noticed that. I'll have to add that to my nightly backup exclusions list.
13:51:51 <mauke> hi
13:51:52 <newsham> :module +System.Posix works fine
13:52:07 <mauke> I'm using the command
13:52:17 <Lemmih> newsham: Try: ghci -package unix
13:52:20 <tusho> http://luqui.org/blog/archives/2008/08/10/mindfuck-the-reverse-state-monad/
13:52:21 <tusho> WIIIIIIIIIIIN
13:52:21 <lambdabot> Title: Mindfuck: The Reverse State Monad @ The dreams that stuff is made of, http://tinyurl.com/6rl5bw
13:52:29 <mauke> I'm using the command 'cabal install ghc-paths' and getting
13:52:30 <mauke> ghc-paths-0.1.0.4 failed during the configure step. The exception was:
13:52:30 <mauke> exit: ExitFailure 1
13:52:37 <newsham> lemmih: same error
13:52:39 <Lemmih> newsham: Just loading a module won't link the package.
13:52:45 <mauke> is this a cabal-install bug?
13:52:50 <Quadrescence> It would be neat if there was a site where you could submit requests for certain code (or code snippets), and someone could reply with a code snippet as a solution to your request.
13:52:55 <newsham> no, build from srcs, not using cabal install.
13:53:07 <newsham> oh, sorry, wrong conversation
13:53:10 <dcoutts> mauke: probably not
13:53:19 <trofimovich> Quadrescence: hpaste?
13:53:22 <Lemmih> newsham: Phew, not a HAppS bug then (:
13:53:22 <mauke> dcoutts: but why doesn't it show the real error?
13:53:26 <dcoutts> mauke: more likely the package does not configure
13:53:46 <newsham> lemmih: speaking of happs bugs.. i mentioned on #happs... but some of the darcs commands on the happs.org home page dont work.
13:53:49 <mauke> a manual make says: Setup.hs:7:7: Could not find module `Distribution.Simple.PackageIndex'
13:53:50 <newsham> ie. wrong versions
13:53:56 <dcoutts> mauke: it probably does, higher up. The final message is just a summary of all packages that failed.
13:54:00 <newsham> also they dont list all packages (ie. -Util)
13:54:25 <dcoutts> mauke: right, and that message is almost certainly there higher up when you did cabal install too
13:54:28 <mauke> dcoutts: oh, d'oh. I missed one line :(.  thanks!
13:54:43 <mauke> dcoutts: no, not that message but The package requires Cabal library version -any && >=1.4 but no
13:54:59 <Lemmih> newsham: Right, the HAppS website is quite bad ATM.
13:55:24 <dcoutts> mauke: we present the summary because if you install a dozen packages then the failures will have scrolled off the screen (since we keep building other packages that don't dep on the failed ones).
13:55:41 <SamB> mauke: so it's a bug in ghc-path's .cabal file, I guess
13:56:07 <SamB> er. ghc-paths'
13:56:14 <newsham> lemmih: :(
13:56:27 <dcoutts> SamB: the Setup.hs needs Cabal-1.4
13:56:39 <mauke> dcoutts: works after 'cabal install Cabal'
13:56:54 <mauke> dcoutts: but isn't 'cabal upgrade' supposed to take care of that?
13:56:56 <dino-> Hm, I tried both $ cabal install --root-cmd=sudo
13:56:57 <dcoutts> mauke: can you run with -v and tell me what version of Cabal it decided to build the Setup using
13:57:05 <trofimovich> @type System.IO System.IO.Unsafe.unsafePerformIO (putStrLn "hi")
13:57:06 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:57:06 <dino-> and $ sudo cabal insatll --root-cmd=sudo
13:57:10 <trofimovich> @type System.IO.Unsafe.unsafePerformIO (putStrLn "hi")
13:57:11 <lambdabot> ()
13:57:11 <SamB> dcoutts: yeah
13:57:13 <dino-> And still stubbornly installs to ~
13:57:14 <SamB> that's what I mean
13:57:22 <SamB> the .cabal file should have said so!
13:57:26 <newsham> lemmih: any reason why happs uses the older version of haxml instead of the version in hackage?
13:57:26 <trofimovich> cabal install --global maybe?
13:57:44 <trofimovich> > System.IO.Unsafe.unsafePerformIO (putStrLn "hi")
13:57:44 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
13:57:48 <dcoutts> mauke: I don't think I understand. How did you have cabal-install without Cabal-1.4 ?
13:57:56 <dino-> The configure was done --global
13:57:58 <dino-> Needs it twice?
13:58:18 <dcoutts> dino-: cabal install does all of configure + build (+haddock) + install
13:58:31 <mauke> dcoutts: I think I had Cabal-1.4 and now it installed 1.4.0.1, which works
13:58:39 <Lemmih> newsham: The version we use /is/ in hackage, it's just not the most recent version.
13:58:51 <dcoutts> dino-: so doing cabal configure; cabal install looses the options specified to configure, you have to specify them to install.
13:58:52 <dino-> dcoutts: I see, even in the project top level dir.
13:59:12 <dino-> So it's not a replacement for runhaskell Setup.hs
13:59:17 <dino-> in that case
13:59:17 <newsham> lemmih: ahh.. i just didnt spec it right i guess
13:59:18 <mauke> dcoutts: so apparently SamB was right; ghc-paths should depend on >=Cabal-1.4.0.1
13:59:24 <dcoutts> mauke: hmm, did you have any other versions of Cabal registered? like 1.5
13:59:47 <Lemmih> newsham: cabal-install will install the correct version for you (:
13:59:53 <mauke> or maybe not, hmm
14:00:04 <newsham> lemmih: you mean if i cabal-install the happs packages?
14:00:11 <mauke> dcoutts: ghc-pkg list Cabal says    Cabal-1.2.4.0, Cabal-1.4.0.1
14:00:13 <Lemmih> newsham: Yes.
14:00:22 <newsham> is there a master happs package which will install all the minor packages?
14:00:23 <dcoutts> mauke: oh, so you didn't have 1.4.0.0
14:00:59 <dcoutts> mauke: in which case yes, cabal-install would have had no choice but to use Cabal-1.2.4.0 to compile the Setup.hs which doesn't have the PackageIndex module
14:01:10 <dcoutts> mauke: yes, ghc-paths is missing Cabal-version: >= 1.4
14:01:11 <Lemmih> newsham: HAppS-Server depends on everything, I believe. HAppS-State depends on everything except HAppS-Server.
14:01:21 <newsham> danke.
14:01:26 <mauke> dcoutts:  cabal-version: >= 1.4
14:01:49 <newsham> sweet, that would work if it wasnt for the unix/ghci bug :)
14:01:58 <dcoutts> mauke: oh yes, hmm.
14:01:59 <newsham> i guess i'll futz with this later.  i filed a ghc trac
14:02:05 <mauke> the dependency is specified and cabal-install reported a missing dependency
14:02:21 <mauke> I'm just used to it automatically installing dependencies
14:02:27 <SamB_XP> mauke: do you have any other versions installed in ~ or something?
14:02:28 <Lemmih> newsham: What platform are you on?
14:02:38 <newsham> freebsd 7.0  ghc-6.8.2/amd64
14:02:47 <mauke> SamB_XP: my entire ghc is in ~; every install is "global"
14:02:55 <dino-> I think it's important to be able to do the install step alone with the config that's already there.
14:02:58 <trofimovich> @type unsafePerformIO (System.IO.readFile "/etc/fstab" >>= return)
14:02:58 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:03:00 <SamB_XP> mauke: oh, it reported a missing dependency ... when was that?
14:03:06 <dcoutts> mauke: I'm still confused. You say it reported the missing dep but you also said it compiled the Setup.hs with cabal-1.2 (which failed of course).
14:03:11 <trofimovich> @type unsafePerformIO (System.IO.readFile "/etc/fstab" >>= return) :: String
14:03:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:03:31 <trofimovich> @type System.IO.unsafePerformIO (System.IO.readFile "/etc/fstab" >>= return)
14:03:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:03:33 <newsham> ?type unsafePerformIO
14:03:34 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:03:56 <trofimovich> @type id
14:03:57 <lambdabot> forall a. a -> a
14:03:59 <newsham> ?type System.IO.Unsafe.unsafePerformIO
14:03:59 <lambdabot> forall a. IO a -> a
14:04:09 <mauke> dcoutts: ah, no. I tried to build it manually, which is when it failed because of a missing module
14:04:09 <trofimovich> @type System.IO.Unsafe.unsafePerformIO (System.IO.readFile "/etc/fstab" >>= return)
14:04:10 <lambdabot> String
14:04:10 <newsham> ?type System.IO.Unsafe.unsafePerformIO (readFile "/etc/fstab" >>= return)
14:04:11 <lambdabot> String
14:04:34 <gnut> hi all
14:04:35 <dcoutts> mauke: ah ok, good. So it did the right thing except for not automatically installing a later version of the Cabal lib.
14:04:38 <newsham> > System.IO.Unsafe.unsafePerformIO $ writeFile "/tmp/gotcha" "gotcha"
14:04:39 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
14:04:53 <mauke> dcoutts: yes. and also not mentioning the missing Cabal in the failure summary
14:05:21 <dino-> Thanks for your help.
14:05:22 <SamB_XP> dcoutts: and apparantly having gone on to try and compile Setup.hs
14:05:27 <SamB_XP> or run, or whatever
14:05:28 <mauke> SamB_XP: no, that was me
14:05:31 <SamB_XP> mauke: oh
14:05:36 <SamB_XP> nvm then ;-)
14:06:03 <SamB_XP> and what does cabal --version say ?
14:06:19 <mauke> dcoutts: this is what I got at first: http://rafb.net/p/0swYi564.html
14:06:19 <lambdabot> Title: Nopaste - No description
14:07:00 <dcoutts> mauke: right, we don't know why Setup.hs failed. I don't see how we can know.
14:07:39 <dcoutts> mauke: oh, wait, right, we failed for a known reason but we didn't propagate the message.
14:07:51 <mauke> dcoutts: then: http://rafb.net/p/rBn6dV51.html
14:07:52 <lambdabot> Title: Nopaste - No description
14:08:00 <mauke> this contains a real error message but I missed it at first
14:08:27 <eu-prleu-peupeu> hello
14:08:41 <mauke> SamB_XP: by now it says: cabal-install version 0.5.1, using version 1.4.0.1 of the Cabal library
14:08:49 <eu-prleu-peupeu> check this: http://lambda-the-ultimate.org/node/2926
14:08:50 <lambdabot> Title: Lightweight Monadic Regions | Lambda the Ultimate
14:08:56 <tibbe> dons: http://www.youtube.com/watch?v=yNRS1ssLPdQ Haven't watched it yet but it might be of interest
14:08:57 <lambdabot> Title: YouTube - The New NIO, aka JSR-203
14:10:59 <eu-prleu-peupeu> what is a "sound type system" ?
14:11:35 <dons> thank tibbe. adding links to the wiki page?
14:11:53 <tibbe> dons: good idea, I'll just stick them in the reference section for now
14:11:56 <thoughtpolice> eu-prleu-peupeu: it's a very interesting paper, I actually have a copy of it up right now :)
14:11:56 <dons> yeah
14:13:07 <dons> tibbe: interesting they use closures.
14:13:31 <tibbe> dons: yes, I have an idea how a fold or map might be a really good callback for async I/O
14:13:40 <tibbe> dons: it gets called for every new chunk
14:14:00 <dons> yeah, curl works nicely like that.
14:14:31 <eu-prleu-peupeu> thoughtpolice: im reading it now... i dont know most of these concepts, but i like the concept of regions and predictable and safe allocation/deallocation
14:15:20 <tibbe> dons: added some references
14:15:33 <eu-prleu-peupeu> now i feel like i shouldn't have skipped those programming pragmatics classes :/
14:15:46 <tibbe> dons: we can use the userdata void * in the C api to attach a haskell callback to
14:16:53 <Ninju_> @hoogle
14:16:54 <lambdabot> HOOGLE - Haskell API Search
14:16:54 <lambdabot> (C) Neil Mitchell 2004-2008, York University, UK
14:16:54 <lambdabot>  
14:17:13 <Ninju_> @hoogle a -> [a] -> Bool
14:17:14 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:17:14 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:17:14 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
14:18:43 <thoughtpolice> eu-prleu-peupeu: i've found it to be one of the more approachable of oleg's work
14:18:46 <thoughtpolice> his enumerator stuff is also really cool
14:19:46 <stepcut> let's say I am implementing a computer algebra system, and I have the term, (a + b) + (a + b). The user wants to apply commute to the second (a + b) to get, (a + b) + (b + a). Any ideas how they might express that in a way the computer could understand ?
14:21:10 <matthew-_> stepcut: well hopefully, + will be suitably annotated such that commutivity is understood
14:21:40 <matthew-_> and then you just, as an optimiser, apply the bigger arg fist as it'll result in less register spilling
14:21:58 <mmorrow> stepcut: check out HERA http://code.haskell.org/HERA/
14:21:58 <lambdabot> Title: Index of /HERA
14:22:43 <mercury^> why is there a notElem when not . elem does the job?
14:23:51 <stepcut> matthew-_: what do you mean by 'understood' ?
14:23:56 <dons> mercury^: that's an odd one, yes.
14:24:00 <dons> it's an anomaly
14:26:05 <matthew-_> stepcut: um, well, I guess ultimately it would have to be an annotation that would fall right the way through to native code gen if necessary, that the function is commutitive
14:26:43 <dons> ghc's primops have those notes.
14:26:58 <dons> defaults has_side_effects = False out_of_line      = False commutable       = False needs_wrapper    = False can_fail         = False
14:27:25 <stepcut> matthew-_: there is no native code gen...
14:27:49 <matthew-_> stepcut: ok, so what do you hope to achieve
14:28:02 <dons> you're writing an interpreter, stepcut ?
14:28:03 <stepcut> computer algebra system is probably not the right description, more like a proof assistant for algebra
14:28:30 <stepcut> but, a stupid one that makes you do everything
14:28:37 <vixey> stepcut,
14:28:59 <vixey> if you were at this state:
14:28:59 <vixey> (a + b) + (a + b)
14:29:19 <vixey> = (a + b) + (b + a) by commutate
14:29:30 <vixey> you could write that ?
14:29:49 <vixey> then it could just check that actually is a valid transform
14:30:02 <matthew-_> but hopefully, by CSE, = 2 * (a + b)
14:30:13 <stepcut> vixey: well I want to have '(a + b) + (a + b)' and the the user issues a command like, 'commute the second (a + b)', and the program produces, (a + b) + (b + a)
14:30:36 <vixey> that sounds quite a bit harder to use :)
14:30:38 <mmorrow> stepcut: i just took two screenshots to save you the pain of getting HERA to work (took me a month of off-and-on trying)
14:30:40 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_0.png
14:30:43 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_1.png
14:30:44 <stepcut> vixey: it's supposed to be
14:31:00 <matthew-_> ok, so you have an expression (G)ADT and you write Plus and then commute swaps the order of the args, no?
14:31:04 <vixey> stepcut, but it seems like you could zoom into part of an expression, then do equational transforms on it and step back out
14:31:11 <chr1s> stepcut: I'm not sure if this is what you're looking for, but there's an interesting paper from some people @ UU about generic rewriting.
14:31:17 <chr1s> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-020.pdf
14:31:18 <lambdabot> Title: A Lightweight Approach to Datatype-Generic Rewriting
14:31:24 <vixey> stepcut, ccshan posted some cool stuff like this, maybe you could use the same technquies
14:31:37 <stepcut> matthew-_: well, I am concern only with the UI portion of this problem -- how does the user express their desire clearly
14:32:02 <vixey> stepcut: Wait do you want it easier or harder to use?
14:32:04 <stepcut> mmorrow: so, you are suggesting the user could interactively select the portion of the equation that wish to apply the law to ?
14:32:19 <mmorrow> stepcut:  yeah, that's hera's strategy
14:32:28 <mmorrow> notice the pulldown menu in the second screen shot
14:32:30 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_1.png
14:32:51 <mmorrow> also, notice in the main frame the "Debugging Info:"
14:32:53 <chr1s> stepcut: you might also want to look at http://ideas.cs.uu.nl/genexas/generic.php?exercisekind=Proposition%20to%20DNF
14:32:54 <lambdabot> Title: OU Exercise Assistant On-line, http://tinyurl.com/5gyrd8
14:33:00 <mmorrow> 0,0,1,2,0,1,1
14:33:15 <mmorrow> that's the path to the root of the subtree from the root of the main tree
14:33:38 <stepcut> ok, I'll look at these and see what I can adopt
14:33:39 <chr1s> that's an exercise assistant for generic exercises where you have different domains with different rewriting rules.
14:33:44 <vixey> stepcut : ?
14:35:04 <Ninju_> @hoogle [[a]] -> [a]
14:35:04 <lambdabot> Prelude.concat :: [[a]] -> [a]
14:35:04 <lambdabot> Data.List.concat :: [[a]] -> [a]
14:35:04 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
14:36:05 <stepcut> vixey: easy to use in someways, but not in others
14:37:18 <stepcut> vixey: one issue with '(a + b) + (b + a) by commute" is that it is easy to type that in in this case. But for more complex equations having to retype the whole thing would be a bit annoying?
14:37:50 <vixey> did you miss my other comments?
14:37:56 <stepcut> one issue with a graphical equation picker is how to save the steps as a text script which could be replayed later
14:38:20 <vixey> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/ is the post I was referring to
14:38:30 <stepcut> vixey: ok, I'll look at that too
14:39:00 <Halo-> It's down for me?
14:39:14 <Ninju_> @hoogle (a -> Bool) -> [a] -> Maybe a
14:39:22 <stepcut> the screenshots on this page show one possibilty, http://mathxpert.com/
14:42:00 <Shiruka> foo f = listToMaybe . filter f?
14:42:14 * Shiruka tries to imagine what else could sensibly fit that type..
14:42:55 <chr1s> stepcut: seriously, just take a look at that exercise assistant I linked above ;)
14:42:57 <Shiruka> (hm, that doesn't do what I intended anyway, on a second thought)
14:43:15 <ddarius> Ulisses Costa recently made a point-free calculator that may have some ideas.
14:43:16 <stepcut> chr1s: I am looking. So far I have not  figured out how to do anything but generate a syntax error ;)
14:43:36 <chr1s> there you can let the user rewrite things themselves, and the system will compare the rewritten version with the previous version based on a unification-algorithm
14:43:37 <Shiruka> (er, does too :-O I didn't even know listToMaybe works for lists with length > 1)
14:43:51 <chr1s> and try to find which rule you are using
14:44:03 <stepcut> chr1s: yeah -- something like that could work
14:44:20 <chr1s> stepcut: http://www.cs.uu.nl/research/techreps/repo/CS-2007/2007-017.pdf
14:44:33 <chr1s> there's a TR on the exercise assistant itself
14:44:41 <stepcut> chr1s: cool, that should help
14:44:47 <Ninju_> Shiruka: I was trying to find a method that detects the first element in a list which returns true when passed to a predicate
14:45:04 <chr1s> stepcut: what are you going to build?
14:45:04 <ddarius> http://caos.di.uminho.pt/~ulisses/blog/2008/07/29/pointfree-calculator/
14:45:11 <dmhouse> Ninju_: find
14:45:11 <Ninju_> so, detect (> 3) [1,2,3,4,5] = Just 4
14:45:17 <Ninju_> thanks
14:45:19 <dmhouse> > find (>3) [1..5]
14:45:39 <mmorrow> stepcut: HERA's wiki http://www.haskell.org/haskellwiki/Haskell_Equational_Reasoning_Assistant
14:45:44 <dmhouse> Prelude Data.List> find (>3) [1..5]
14:45:44 <dmhouse> Just 4
14:45:45 <mmorrow> paper: http://www.ittc.ku.edu/~andygill/papers/IntroHERA06.pdf
14:45:47 <Shiruka> .. doh :-)
14:46:00 <stepcut> mmorrow: thanks
14:46:02 <vininim> @bot
14:46:46 <Shiruka> find p = listToMaybe . filter p
14:46:59 <Shiruka> close enough ;-)
14:47:21 <mmorrow> good luck :)
14:53:25 <stepcut> chr1s: is there a place to submit bugs, 'Sorry, unable to fulfill your request: omething went wrong'
14:54:11 <stepcut> I don't understand why this isn't just True, 'p || r || q || r || ~r'
14:54:35 <stepcut> oh... || is probably not disjunction?
14:55:29 * stepcut finds the address to submits bugs
14:56:17 <wjt> Igloo: there's no chance of having GHC 6.8.3 in Lenny, is there?
14:56:43 <Igloo> No, sorry
14:58:17 <gwern> @seen nominolo
14:59:10 <wjt> Igloo: ah well.
14:59:45 <gwern> preflex: seen nomeata
14:59:45 <preflex>  nomeata was last seen on #xmonad 1 hour, 11 minutes and 28 seconds ago, saying: A keyboard-centric window manager is a bit misplaced on a keyboardless phone
14:59:47 <gwern> er.
14:59:49 <vixey> stepcut: got any examples you want to do?
14:59:54 <gwern> preflex: seen nominolo
14:59:54 <preflex>  nominolo was last seen on #haskell 1 hour, 35 minutes and 44 seconds ago, saying: dons: so glad citeseer is working again
14:59:55 <vixey> like equations to prove or something?
15:00:47 <stepcut> vixey: pretty much this, but better,  http://mathxpert.com/
15:00:54 <vixey> stepcut: I mean an equation
15:01:02 <vixey> to prove using it
15:01:11 <vixey> like what would you do with it?
15:01:28 <vixey> http://www.apronus.com/provenmath/fields.htm
15:01:31 <vixey> stuff like this?
15:01:40 <gwern> @ask nominolo You seem to be knowledgeable about the GHC API; is there currently anyway to do something like 'load "Data.Map"; eval "map (+1) [1..10]"' *without* erroring? as it stands, it causes an eval error because it gets conmfused between Data.Map.map and Prelude.map.
15:02:02 <gwern> @ask nominolo I guess what I want are fully qualified imports, but I haven't figured out how to do it yet
15:02:19 <stepcut> vixey: no, just a tool for beginning algebra students to use to solve simple word problems
15:02:29 <hml> is there good documentation of C pointers in the haskell ffi? i'm finding the awkward squard a bit hard to read concerning this issue
15:03:09 <lispy> hml: based on the frequency and subject of questions about FFI on haskell-cafe, there must not be a good doc
15:03:46 <hml> lispy: let's write one! here's my contribution \begin{document} ... \end{document}; the ... is left up to you
15:03:55 <lispy> hehe
15:04:10 <lispy> \include{explanation-from-hml}
15:04:20 <dcoutts> hml: the FFI spec is reasonably useful
15:04:21 <lispy> done!
15:04:34 <dcoutts> hml: and the lib docs themselves
15:04:52 <hml> \section{Solution} ask #haskell on irc.freenode.net
15:05:03 <lispy> er \#haskell
15:05:14 <lispy> you have to escape those pesky #s
15:05:15 * vixey just had a go at this program... and wants to make an example to show
15:05:51 <hml> dcoutts: what are the lib docs you're referring to?
15:05:52 <stepcut> vixey: ivan works 4 times as many hours as mary. ivan and mary work 75 hours total. How long did each of them work?
15:06:08 <vixey> hm
15:06:13 <vixey> I was thinking about a totally different program
15:06:28 <vixey> something where you have an equation or expression and do equational rewrites on it
15:06:38 <dcoutts> hml: the Foreign.* modules
15:06:46 <lispy> i = 4m, i + m = 75, 5m = 75, m = 15, i = 60
15:06:47 <gwern> stepcut: sounds like a task for prolog!
15:06:50 <hml> dcoutts: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi.pdf <-- is this the ffi spec you're referring to?
15:06:52 <dcoutts> hml: which are the libs specified by the FFI
15:06:54 <gwern> or maybe the list monad
15:06:55 <lispy> yay! I solved it!
15:06:59 * gwern is too apathetic to care
15:07:08 <stepcut> lispy: yes, but you need to prove each step :)
15:07:12 <dcoutts> hml: right, or the html version linked from haskell.org
15:07:22 <vixey> ok you actually have sets of equations
15:07:23 <lispy> stepcut: er...prove?
15:07:44 <vixey> http://joshkos.blogspot.com/2007/11/fold-fusion-strikes-back.html
15:07:52 <vixey> That's the kind of thing I was thinking
15:08:09 <stepcut> lispy: yeah, like how you got, 5m = 75, from the first two equations
15:08:20 <mauke> @bot
15:08:40 <vininim> lol at goatse operator
15:08:48 <lispy> stepcut: when you say prove, you just mean show my work then?
15:08:49 <stepcut> lispy: there is some substitution, some distribution, some simplification. There's bunch a of steps you did in your head ;)
15:09:03 <mauke> preflex: seen lambdabot
15:09:03 <preflex>  lambdabot was last seen on #haskell 33 minutes and 59 seconds ago, saying: Data.List.intercalate :: [a] -> [[a]] -> [a]
15:09:05 <stepcut> lispy: yeah, what 'law' you apply at each step
15:10:30 <lispy> stepcut: I used, argument by authority, slippery slope and strawman.
15:10:43 <vixey> gwern: Started to learn Prolog?
15:10:45 <stepcut> lispy: once you level up, you can apply more powerful transforms. 'eliminate i.  solve m.' but initially, you have to show every step
15:11:30 <lispy> stepcut: cute
15:11:53 <gwern> vixey: I wish. it's on my list, after scheme and MMIX
15:12:45 <lispy> gwern: two birds, one stone.  Write a scheme compiler for MMIX
15:12:58 <stepcut> 4m + m = 75 (by substitution), 4m + 1m = 75 (by multiplicative identity), m * (4 + 1) = 75 (by distribution), m * 5 = 75 (by additive simplification), (m * 5) / 5  = 75 / 5 (by <i forget the law>), and so on
15:12:59 <vixey> In Prolog
15:13:02 <vixey> :D
15:13:03 <gwern> learning to write compilers is also on the list :)
15:13:06 <SamB_XP> lispy: MMIX is nasty :-(
15:13:09 <lispy> vixey: no, that's 3 birds :)
15:13:17 <SamB_XP> the MMU is the craziest
15:13:26 <gwern> SamB_XP: yeah, but it's what is used in TAOCP. if I'm going to dream...
15:13:39 <stepcut> write a scheme compiler in MMIX
15:13:44 <SamB_XP> gwern: not yet is it?
15:14:06 <gwern> SamB_XP: I thought knuth had updated the volumes for mmix
15:14:25 <lispy> oh which one is the original? MIX and then MMIX?
15:14:25 <Philonous> Is there any editor/IDE you would suggest for developing haskell code? Maybe emacs?
15:14:31 <dmhouse> Philonous: Emacs.
15:14:38 <SamB_XP> MIX is the original
15:14:46 <Philonous> dmhouse: Thanks
15:14:47 <vixey> hm
15:14:54 <stepcut> Philonous: get the latest haskell-mode
15:14:57 <lispy> Philonous: emacs is fine.  I recommend using hasktags.  Visual Haskell is great if you're used to visual studio.
15:15:02 <gwern> emacs and vim are both supposed to have pretty good support
15:15:07 <dmhouse> Philonous: Emacs and Vim are the two most popular editors for Haskell. There is also a Visual Studio plugin if you lean that way.
15:15:13 <vixey> I can really see why higher order unification is nice now
15:15:13 <SamB_XP> MIX also seems crazy, but at least it isn't terribly overcomplicated the way MMIX is
15:15:29 <SamB_XP> and it only seems crazy because it's from the pre-octet era
15:15:32 <kryptiskt> Philonous, EclipseFP if you like that
15:16:10 <lispy> SamB_XP: I started to write an emulator in Haskell for MIX and it turned out to be a huge mess of instructions.  I doubt I'll ever pick up that project again...
15:16:23 <SamB_XP> MIX or MMIX?
15:16:36 <lispy> SamB_XP: whatever one the books are currently authored for
15:16:41 <SamB_XP> oh
15:16:47 <gwern> lispy: hm, that's interesting. even brainfuck interpreters look nice in haskell, so I wonder at that mess
15:16:50 <Philonous> lispy: Does Visual Haskell require a copy of MS Visial Studio?
15:17:09 <lispy> Philonous: yes, I don't know if it works with the express editions
15:17:14 <SamB_XP> lispy: well I think MMIX would be even worse
15:17:16 <stepcut> simulate MMIX in scheme and write a prolog interpreter in MMIX ?
15:17:21 <kryptiskt> Philonous, Don't use visual haskell, it's outdated
15:17:41 <lispy> gwern: I wrote an optimizing bf intpreter in haskell and that was fun
15:17:43 <kryptiskt> also it doesn't work with express
15:17:44 <Philonous> Ah ok, I'm running FreeBSD, so I think I'll stick to emacs then.
15:17:46 <Philonous> Thanks all
15:18:23 <stepcut> I tried to write a unlambda compiler in Haskell, but put it on hold until the C generation libraries are done
15:18:26 <lispy> SamB_XP: oh probably. I just got bored implementing the 100 different instructions
15:18:26 <Halo-> Does the apparent increasing C knowledge that comes with growing a big beard also apply to Haskell?
15:18:33 <stepcut> though, I could use harpy now I guess
15:18:51 <chrisdone> Halo: one cannot grow a haskell
15:19:00 <kryptiskt> So when will there be a class action suit against RMS for all RSI Emacs has caused?
15:19:00 <SamB_XP> Halo-: of course!
15:19:10 <SamB_XP> C knowlege is ever useful when hacking Haskell
15:19:11 <stepcut> Halo-: I hope not, http://research.microsoft.com/~simonpj/GIFs/spj-snow.jpg
15:19:15 <lispy> kryptiskt: hehe
15:19:43 <stepcut> kryptiskt: the real problem is the bastards that moved the control key in favor of capslock
15:20:00 <gwern> death is too good for them!
15:20:05 <chrisdone> see, there, he's probably just skiiing, but I initially thought he'd be climbing a huge mountain
15:20:34 <kryptiskt> stepcut, Good, IBM and RMS then, at least one of those two have money
15:20:47 <Halo-> Hm. Conflicting opinions. I might continue my beard adventure and see if it bears fruit.
15:20:47 <SamB_XP> stepcut: what???
15:21:03 <chrisdone> what‽
15:21:24 <chrisdone> > f
15:21:33 <SamB_XP> stepcut: the Ctrl key used to be where CapsLock is ?
15:21:36 <SamB_XP> when was that?
15:21:44 <chrisdone> lambdabot: you have rubbish hair
15:21:48 <kryptiskt> before IBM PC AT
15:21:50 <stepcut> SamB_XP: in the good old days, one moment
15:22:02 <chrisdone> > "hello‽"
15:22:03 <Halo-> I use capslock instead of shift. I find it faster and requires less stretching
15:22:12 <chrisdone> is λb dead or pretending?
15:22:18 <Draconx> I always rebind my caps lock ley to control, anyway.
15:22:22 <Halo-> I assume that's one of the reasons I've managed to type craploads and not feel any effects
15:22:30 <chrisdone> > 1
15:22:38 <Ninju_> @hoogle Ord b => (a -> b) -> [a] -> [a]
15:22:40 <chrisdone> vixey: what did you do to lambdabot?
15:22:48 <stepcut> of course, there is also this emacs friendly keyboard, http://world.std.com/~jdostale/kbd/SpaceCadet1.jpeg
15:23:01 <Ninju_> oh, is lambdabot broken? :(
15:23:32 <chrisdone> I blame vixey. she's always making lambdabot do weird stuff
15:23:42 <chrisdone> stepcut: nice
15:24:00 <Halo-> Are there Emacs foot pedals?
15:24:10 <lispy> stepcut: "Rub out" key?
15:24:12 <chrisdone> stepcut: is that a shoop or real?
15:24:13 <stepcut> SamB_XP: http://ninkendo.org/~ken/images/sun-type-6-detail.jpg
15:24:18 <stepcut> chrisdone: real
15:24:36 <chrisdone> Halo-: I chuckled
15:24:43 <stepcut> chrisdone: it's the keyboard for the symbolics lisp machine
15:25:02 <chrisdone> stepcut: I love the thumbsup/thumbsdown
15:25:13 <ddarius> So vixey, why is higher order unification nice?
15:25:15 <chrisdone> stepcut: "terminate program?"
15:25:24 <SamB_XP> stepcut: why is the Alt key to the left of the Windows key on that one?
15:26:07 <chrisdone> hahaha, a QUOTE key. amazing
15:26:16 <vixey> ddarius: describing rewriting tactics, like for an equational reasoning assistant
15:26:18 <stepcut> SamB_XP: I think that keyboard predates windows. That is a meta key
15:26:58 <chrisdone> stepcut: the Windows key is usually assigned "Super", IIRC
15:27:00 <stepcut> SamB_XP: here is a currently available keyboard which emulates that layout, http://www.fentek-ind.com/hhlite2lrg.jpg
15:27:01 * SamB_XP was kidding about it being a Windows key ;-)
15:27:20 <vixey> stuff like command(rewrite(X = Y), F(X) --> F(Y)). is a lot nicer than command(rewrite(X = Y), F_X --> F_Y) :- search_and_replace(X,Y,F_X,F_Y).
15:27:38 <SamB_XP> stepcut: what? no function keys -- F or otherwise?
15:27:45 <ddarius> vixey: Yep.  Multiset rewriting is an application of linear higher order unification.
15:27:52 * stepcut uses the windows key for xmonad
15:27:58 <SamB_XP> oh, the Fn key
15:28:04 <SamB_XP> I thought that was a laptop thing
15:28:10 <Ninju_> is there a sort function in the libraries such that I can do things like :-  f sum [[2,3], [4,5], [1,1]] -> [[1,1], [2,3], [4,5]] -- sorts the elements by their sum
15:28:11 <Ninju_> thanks
15:28:14 <stepcut> SamB_XP: on the modern keyboard, you have to hit Fn. A bit annoying, but nice if you want the smaller keyboard form factor
15:28:26 <pgavin> anyone happen to know what would happen if there was only one thread holding on to an MVar, and it called takeMVar?
15:28:35 <pgavin> does the runtime detect that the thread can never wake up?
15:28:46 <SamB_XP> at least they put the F keys on their corresponding numeric keys
15:28:55 <Halo-> Do people use function keys much though?
15:29:03 <Toxaris> Ninju_: use sortBy with comparing
15:29:13 <SamB_XP> hmm, good question ;-)
15:29:25 <SamB_XP> depends on the app I guess
15:29:31 <Ninju_> which library is it in?
15:29:45 <stepcut> SamB_XP: size comparison of sun type 6 vs hhkb, http://comedialabs.com/images-matti/hhkb.jpg
15:29:47 <Ninju_> I think I've tried sortBy before - when I was guessing at possible function names
15:29:52 <matthew-_> pgavin: yes
15:30:03 <matthew-_> it detects that it can't be woken
15:30:06 <Quadrescence> Is a priority queue just a way to know "what to do/look for next"?
15:30:07 <pgavin> matthew-_: ok
15:30:14 <matthew-_> and if that's the main thread ,the program will die
15:30:18 <matthew-_> with an error message
15:30:41 <pgavin> matthew-_: the MVar docs don't say anything about that
15:30:52 <Toxaris> Ninju_: e.g. f = sortBy (comparing sum) does what you want
15:30:56 <matthew-_> it's more to do with the ghc garbage collector
15:31:13 <SamB_XP> matthew-_: well, it's not by any means guarenteed
15:31:15 <Toxaris> Ninju_: Data.List.sortBy, Data.Ord.comparing
15:31:15 <pgavin> matthew-_: right, that's the only way it could detect that condition
15:31:24 <SamB_XP> but the GC can sometimes tell these things, yes
15:31:29 <matthew-_> SamB_XP: oh sure, sorry I should have made that clear.
15:31:30 <Toxaris> Ninju_: are you aware of http://www.haskell.org/hoogle/ ?
15:31:41 <SamB_XP> er.
15:31:44 <Ninju_> thanks
15:31:55 <SamB_XP> I should rather have directed my comment to pgavin ;-)
15:31:57 <stepcut> and the pro version: http://www.akihabaranews.com/en/news_pics/11373/3.jpg
15:32:03 <pgavin> matthew-_, SamB_XP: thanks
15:32:25 <Ninju_> Toxaris: I've used it a few times through lambdabot, but didn't realise I could do it elsewhere. Thanks.
15:32:35 <Halo-> Quick, someone tell me where Scroll Lock is on that keyboard...
15:32:39 <tehgeekmeister> i'm trying to build hexpat, but apparently i'm doing something wrong.  I've unpacked the tarball and tried running "ghc --make Setup.lhs -o setup" and it hangs in the linking stage, and "ghc Setup.lhs" and it complains about undefined references.  i have libexpat installed in my /usr/local/lib;; where do i go from here?
15:33:09 <Toxaris> Ninju_: you can even download hoogle and use it at home
15:33:43 <SamB_XP> the only thing I ever use scroll lock for is to swap computers using my KVM
15:33:59 <Toxaris> Ninju_: "cabal install hoogle" worked for me, and then "hoogle comparing" gives "Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering"
15:34:40 <Ninju_> Toxaris: I need to install cabal first
15:34:44 <gwern> tehgeekmeister: hexpat? is that from hackage?
15:34:49 <tehgeekmeister> gwern: yes
15:35:37 <Toxaris> Ninju_: hehe yeah unfortunately its not yet included with ghc
15:36:53 <gwern> tehgeekmeister: installed fine for me via cabal install
15:36:59 <gwern> perhaps the problem is your weird invocation
15:37:17 <SamB_XP> so how come sun doesn't still sell type 6s?
15:37:19 <tehgeekmeister> that's probably it, i didn't remember the right way to do it
15:37:31 <tehgeekmeister> that's what i get for neglecting haskell for months
15:37:40 <gwern> runhaskell Setup configure/build/install
15:37:59 <tehgeekmeister> ah, i just tried that
15:38:02 <tehgeekmeister> and i got this error
15:38:21 <tehgeekmeister> ghc-6.8.2: internal error: R_X86_64_32S relocation out of range: (noname) = 0x7f82eece54f8
15:39:49 <chrisdone> stepcut: sweeeet pro version. I longed for Das Keyboard for a long time. 5 minutes to be precise, before I discovered the price, and I shall rhyme in this sentence thrice
15:40:07 <chrisdone> hey ashy
15:41:22 <stepcut> chrisdone: heh
15:41:30 <olsner> chrisdone: you could also get a Model M off the internet, and if you're really into it, you can remove the removable keycaps
15:41:47 <stepcut> chrisdone: the DAS is nothing in price compared to the optimus
15:41:54 <chrisdone> olsner: I do have a Model M. it's german. got it from Unicomp. I removed the keycaps and it looked amazing, but felt less so :(
15:42:08 <chrisdone> olsner: the keys feel really tiny and kind of hurt to type on without the caps
15:42:09 <stepcut> chrisdone: http://www.legitreviews.com/article/247/1/
15:42:15 <ddarius> "If arithmetic overflow is a fatal error, some fascist pig with a read-only mind is trying to enforce machine independence. But the very ability to trap overflow is machine dependent."
15:42:35 <chrisdone> stepcut: yeah, I bet typing on it feels like crap
15:42:55 <chrisdone> ddarius: I laughed
15:42:57 <stepcut> also, if you remove (or rearrange) the keys on the model M, you will find that you really do use those little nubs on the F and J keys
15:42:59 <olsner> hmm, yeah, the keys would get smaller when removing the caps... clickykeyboards has transparent caps as well btw
15:43:32 <chrisdone> olsner: is it possible to buy caps? transparent ones would be nice
15:43:40 <stepcut> anyway, rubbing alchohol or something similar will probably remove the labels from just about any keyboard
15:43:56 <vixey> why don't you just leave them on?
15:43:57 <SamB_XP> my key labels are coming off without any effort on my part as it is
15:44:14 <chrisdone> olsner: amusingly, I had a friend round who had typed on my keyboard all night, but when he realised the keys were german he couldn't type on it
15:44:22 <stepcut> chrisdone: heh
15:44:33 <Philonous> With this keyboard the position of keys wouldn't be an issue any more: http://www.artlebedev.com/everything/optimus-tactus/
15:44:58 <EvilTerran> ... it's like a giant iphone O.o
15:45:01 <SamB_XP> I have a Q and Z, and part of the W, U, J, and a sliver of the I
15:45:07 * stepcut is still waiting for a good bluetooth chord keyboard
15:45:12 <SamB_XP> the rest of the letters are quite faded
15:45:17 <chrisdone> Philonous: tapping on a hard flat static piece of plastic all day sounds painful?
15:45:29 <stepcut> ... and for iPhone to support bluetooth keyboards :(
15:45:44 <Philonous> Yeah. But you could place your controll key wherever you want it to be :)
15:45:59 <olsner> stepcut: heh, yeah, I usually idle by tugging on those nubs and listning to the sound of the mechanism rumbling around beneath the keys
15:46:25 <stepcut> nice Model M conversion, http://steampunkworkshop.com/keyboard.shtml
15:46:43 <stepcut> olsner: aside from that, you really do use them to make sure your fingers are in the right position
15:46:48 <SamB_XP> hmm, is that optimus tactus what they use in TNG?
15:46:50 <chrisdone> stepcut: ace
15:47:49 <chrisdone> here is mine: http://i19.ebayimg.com/06/i/000/ae/37/feba_1.JPG
15:48:58 <adu> hi
15:49:04 <chrisdone> ahoy
15:49:46 <stepcut> a slightly less cool keyboard conversion, http://www.multipledigression.com/type/
15:50:08 <stepcut> but, still pretty cool
15:51:02 <chrisdone> brilliant present
15:53:54 <chrisdone> stepcut: yeah, since getting my model m I have learned to touch type with correct finger positions, so I tend to use the nubs
15:54:59 * ddarius doesn't understand people who use a computer quite a bit and can't touch type.
15:55:28 * stepcut doesn't understand people who use a computer quite a bit and can't touch type dvorak and qwerty.
15:55:29 <chrisdone> yes, it's certainly very important
15:55:46 <ddarius> stepcut: Indeed.
15:56:06 <olsner> we should bring back the touch-typing classes in school and universities
15:56:21 <stepcut> olsner: plus iPhone typing
15:56:33 <olsner> iPhone typing? I don't even know what that is
15:56:34 * vininim can't touch type dvorak
15:56:35 <chrisdone> I suspect dvorak advocates of simply typing dvorak more correctly than qwerty. there doesn't seem to be much real evidence suggesting real benefits
15:57:05 <stepcut> chrisdone: depends on what benefits you are looking for
15:57:24 <Boney> olsner: we can also teach correct spelling/grammar to kids and teach them to apply this when using MSN.
15:57:27 <stepcut> chrisdone: your fingers definitely move less distance total
15:57:40 <adu> stepcut: i use dvorak :)
15:58:36 <Boney> chrisdone: I've heard that querty can be faster because often as one finger strikes a key, often another finger on the other hand can move into position for the next key.
15:58:36 <stepcut> chrisdone: and it feels less mentally chaotic to me :)
15:58:43 <chrisdone> Boney: I think if MSN had that terribly annoying spelling notification by default then teens would have to learn to type properly because they would be sick of correcting it
15:58:44 <vininim> I don't see why someone (beside a professional typist) needs to type at 1200 wpm when you spend most of the time thinking and reading than typing.
15:59:01 <adu> in the year 2051, everyone will use Dvorak, Beta, and AmigaOS
15:59:06 <olsner> hmm, but chat is the new speak, so it'll probably never respond well to attempts at fixing it
15:59:07 <vininim> at least in the context of general computer use (even programming).
15:59:07 <chrisdone> stepcut: I'm not sure mental chaos can be quantified so well for keyboard use
15:59:11 <Boney> chrisdone: ah, A technical solution!
15:59:12 <ddarius> Boney: With Dvorak I tend to be typing multiple keys at once.
15:59:13 <stepcut> chrisdone: :p
15:59:46 <stepcut> vininim: many people I know who use dvorak switched because it feels less stressful on the hands, not because they wanted to type faster
15:59:49 <Boney> ddarius: neat,
15:59:54 <Randroid> ddarius: Another Dvorak typist. I thought I was the only one. Taught myself in the early '90s and now have lost the ability to type QWERTY except by hunt-and-peck.
16:00:07 <Boney> btw, I've never tried dvorak,
16:00:09 * jeffz`` looks for the colemak users
16:00:31 <ddarius> Randroid: There are quite a few Dvorak users here.  I did lose the ability to type QWERTY after I learned Dvorak, but I've since regained it.
16:00:35 <vixey> No I think lots of people in #haskell use dvoraj
16:00:36 <vininim> stepcut: it wouldn't cut for me though because I have to type both at english and portuguese, and the dvoraks would be quite different.
16:00:49 <olsner> vininim: I think it's more a matter of not breaking your hands when actually having to do write something
16:00:51 <stepcut> Boney: I suspect that max typing speed hits some other mental obsticle that is independent of the key positions.
16:00:56 <vixey> Boney, It is pretty fun to switch layout
16:00:58 <Randroid> jeffz``: I looked at Colemak, but at 40 years old, I don't think I've got another keyboard layout in me.
16:01:31 <Philonous> It must be painfull to relearn typing after 10 years... Just when you finally manage to find keys without looking ^^
16:01:35 <chrisdone> stepcut: there is a point about hand stress. when I didn't type properly i experienced burning sensations and shooting pains. when touch typing however this is not the case. this is why I kind of suspect people convert to dvorak without trying to type QWERTY properly. but that is just personal experience
16:01:46 <gwern> Randroid: oh don't think that way; for all you know you have another 60 years of typing in front of you, or more
16:01:51 <Boney> stepcut: that's probably true, for me the bottleneck is my vision.
16:01:53 <jeffz> Randroid: I don't blame you, I don't think I'd want to switch from qwerty even at 23.  I manage a comfortable 60wpm.
16:02:10 <ddarius> chrisdone: I could type QWERTY properly long before I ever tried Dvorak.
16:02:20 <stepcut> chrisdone: dunno, I touch typed qwerty for many years before switching. And, I actually switched twice.
16:02:24 <Randroid> gwern: Oh, it's not that I think I don't have long on this earth. I'm sure I do. It's that at 40, I don't think I have the patience or time for it.
16:02:37 <gwern> ddarius:
16:02:41 <gwern> er.
16:03:19 <gwern> Randroid: eh. I have the patience for a lot of things if the payoff accrues daily for decades, but that's just me
16:03:52 <EvilTerran> anyway, no matter how long you live, the keyboard could be superceded unexpectedly
16:04:18 <chrisdone> Microsoft Head Implants
16:04:26 <ddarius> EvilTerran: It could be, but it seems clear that it will be lasting for quite a while.
16:04:28 <gwern> EvilTerran: not a bet I would like to take, based on how the keyboard has been the major computer interface for the last... 60 years?
16:04:54 <EvilTerran> eh. technology advances exponentially.
16:04:59 <gwern> as long as we think alphabetically and program alphabetically, I will continue to take the bet that this will not be the year the keyboard is overthrown
16:05:01 <chrisdone> gwern: and judging by the cost of (admittedly shitty) keyboards
16:06:05 <ayumilove> o_o
16:06:19 <gwern> chrisdone: judging?
16:06:25 <vixey> @seen ayumilove
16:06:35 <ayumilove> @seen vixey
16:07:10 <mauke> preflex: seen vixey
16:07:10 <preflex>  vixey was last seen on #haskell 45 seconds ago, saying: @seen ayumilove
16:07:22 <gwern> @seen Zao
16:07:41 <EvilTerran> preflex: seen Zao
16:07:41 <preflex>  Zao was last seen on #haskell 12 hours, 10 minutes and 5 seconds ago, saying: Control.Parallel.Strategies.DWIM?
16:07:44 <chrisdone> gwern: keyboards are really cheap. makes sense it would take a technology to be /far/ superior or cheaper to displace it
16:07:46 <EvilTerran> heh
16:07:47 <ayumilove> what are you guys doing here?
16:07:49 <ayumilove> http://hpaste.org/9526
16:07:52 <ayumilove> can someone look into this?
16:08:08 <ayumilove> someone said to me that iterate can be used in fibonacci
16:08:22 <gwern> chrisdone: I would argue that for precision and bits per second, no other interface has come close except in very limited domains
16:08:41 <ayumilove> but it produces [0,1,2,3,4...]
16:08:53 <ayumilove> instead of [0,1,1,2,3,5..]
16:08:55 <mauke> > iterate (\(x, y) -> (y, x+y)) (0, 1)
16:09:02 <chrisdone> gwern: I suppose that is true
16:09:04 <clkao> win 4
16:09:16 <vininim> preflex: > 2
16:09:31 <chrisdone> preflex: source
16:09:46 <gwern> chrisdone: I mean, for drawing, say, I would not want to argue that keyboards are an easier way of inputing the bits than a pressure sensitive pad and a pen
16:09:47 <vininim> mm I don't think preflex is a lambdabot
16:09:50 <chrisdone> is preflex available in a repo. anywhere? preferrably darcs, not this new “git” fad?
16:09:50 <ayumilove> mauke? o_o
16:09:57 <mauke> http://mauke.ath.cx/preflex/
16:10:00 <EvilTerran> preflex: version
16:10:00 <preflex>  8.638
16:10:00 <gwern> chrisdone: yes
16:10:01 <chrisdone> thanks
16:10:06 <adekoba> the `time' package is reporting a time that is incorrect. It's exactly 4 hours off, so it sounds like a timezone issue. How can I fix this?
16:10:09 <mauke> ayumilove: yes?
16:10:14 <gwern> ?where preflex
16:10:23 <ayumilove> mauke: that iterate is for fibonacci?
16:10:25 <gwern> @help where
16:10:27 <mauke> ayumilove: yes
16:10:37 <mauke> ayumilove: you'll probably also want a map fst
16:10:42 <chrisdone> gwern: right, but you can provide a lot of meaning with a keyboard, for controlling things and for describing things
16:10:50 <mauke> [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55)...
16:11:17 <ayumilove> how do i write that in my notepad
16:11:17 <Shiruka> ayumilove: you have this: recA x y n = take n (iterate(+(x+y))x), and then call it with recA 0 1 n
16:11:43 <Shiruka> this doesn't work, because it reduces to (iterate (+(0+1)) 0 == iterate (+1) 0
16:11:48 <gwern> offhand, does anyone know any computational complexity classes like NP, where solutions are easy to check but very hard to compute? *but with the provision that it is known to not be equivalent to any easier class
16:11:56 <ayumilove> Shiruka: yeah i know, i just realized that
16:12:03 <adekoba> aha, nevermind. I needed to use Data.Time.LocalTime
16:12:20 <ayumilove> Shiruka: but could not make it Fibonacci
16:12:52 <Shiruka> the idea for fibonacci is to keep a two-tuple of the two previous values as your state
16:13:07 <vininim> gwern: isn't the provision a million dollars challenge?
16:13:20 <Shiruka> or at least mauke's version does that :-)
16:13:31 <gwern> vininim: no, I specifically want an example which is not NP or P
16:14:04 <gwern> vininim: I don't believe 'being known to not be equivalent to any easier class' is a outstanding problem for any other classes as important as NP
16:14:18 <gwern> from the little I know of computational complexity theory
16:15:14 <ayumilove> Shiruka: iterate (\(x, y) -> (y, x+y)) (0, 1) << this is somekind of lambda notation|?
16:15:26 <vixey> gwern: turing complete
16:15:28 <ayumilove> mauke: (x,y) << is a function?
16:15:32 <Shiruka> yes, the initial state is (0, 1) and (x, y) -> (y, x+y) is the transition kernel
16:15:41 <gwern> vixey: pardon?
16:15:48 <gwern> preflex: seen Zao
16:15:48 <preflex>  Zao was last seen on #haskell 12 hours, 18 minutes and 11 seconds ago, saying: Control.Parallel.Strategies.DWIM?
16:15:52 <vixey> gwern: "does anyone know any computational complexity classes like NP, where solutions are easy to check but very hard to compute"
16:15:58 <ayumilove> Shiruka: so I have to make x has (0,1) ?
16:16:06 <vixey> gwern: the class  turing complete  fits that doesn't it?
16:16:11 <gwern> vixey: knowing whether something terminates doesn't sound easy to check
16:16:28 <vixey> solutions? You just run the program
16:16:33 <gwern> > 1 + 1
16:16:35 <vixey> that's easy
16:16:46 <gwern> vixey: and what's the Big O for it terminating, exactly?
16:16:52 <vixey> what
16:17:05 <gwern> as the length of the program increases, how much longer does it take to terminate?
16:17:08 <vixey> It's a complexity -class-
16:17:17 <Shiruka> so you have (x0, y0) = (0, 1) at first, then (x1, y1) = (y0, x0+y0) = (1, 1), then (x2, y2) = (y1, x1+y1) = (1, 2), and so on
16:17:21 <gwern> mauke: does preflex do messages?
16:18:06 <mauke> gwern: no
16:18:13 <gwern> drat
16:18:16 <mauke> gwern: try MemoServ :-)
16:18:21 <gwern> I was going to bug Zao over xtris, but lambdabot is down
16:18:39 * gwern will wait. I am patient. I can wait... foreveeerrrrr.....
16:18:59 <Shiruka> ayumilove: all (iterate f s) does is produce the list [s, f s, f (f s), f (f (f s)), ...]
16:19:16 <chrisdone> gwern: oh, he's working on that again? ^_^
16:19:24 <vixey> F[0]=0;F[1]=1;F[n+2]=F[n]+F[n+1]  (0,1)=(F[0],F[1]), (x,y)=(F[n],F[n+1]) --> (y,x+y)=(F[n+1],F[n]+F[n+1])=(F[n+1],F[n+2])
16:19:33 <gwern> chrisdone: well, it's kind of done, as I understand it
16:19:36 <chrisdone> what the hell is that
16:19:37 <vixey> --> is the induction hypothesis
16:19:40 <ayumilove> Shiruka: stil confused
16:19:41 <chrisdone> gwern: sweet. repo.?
16:19:53 <vininim> gwern: you want something outside decision problems?
16:19:57 <gwern> chrisdone: heck, if I had the repo you think I'd be bothering him?
16:20:05 <gwern> I'd be doing one of my infamous NMUs
16:20:15 <ayumilove> Shiruka: but i understand that iterate is using the function (+1) to add to the others like s, fs ,f(fs)
16:20:21 <chrisdone> gwern: maybe he likes being bothered by people and you're doing in a favour
16:20:31 <vixey> gwern: that question doesn't make sense to ask about complexity classes
16:21:11 <vixey> ?go complexity zoo
16:21:20 <Shiruka> ayumilove: so what's the problem?-)
16:21:33 <gwern> vininim: well, the context is: someone is arguing that there's no useful task we could set a superintelligent AI. even if we set it NP problems its answer which we could verify in P, this doesn't test its intelligence adequately, since it could've found a P=NP algorithm and be 'cheating' us. I want a counterexample - 'yes, there is a class from which we could draw questions whose answers we could verify cheaply - it's just not P/NP, ...
16:21:35 <vixey> ayumilove: Do you understand that induction proof?
16:21:36 <ayumilove> the problem is i do not know how to make this f go along with the s
16:21:41 <gwern> ... it's foo/bar'
16:21:41 <ayumilove> in the code
16:22:12 <ayumilove> vixey: I understand the induction
16:22:20 <Shiruka> I'm not sure what you mean by that, but sounds like contrary to the point of iterate
16:23:08 <ayumilove> I understand [s, f s, f (f s), f (f (f s)), ...] but not F[0]=0;F[1]=1;F[n+2]=F[n]+F[n+1]  (0,1)=(F[0],F[1]), (x,y)=(F[n],F[n+1]) --> (y,x+y)=(F[n+1],F[n]+F[n+1])=(F[n+1],F[n+2])
16:23:11 <Shiruka> with iterate, you separate the computation into an iterative loop, initial state and state transition function
16:23:34 <vixey> ayumilove: F[0]=0;F[1]=1;F[n+2]=F[n]+F[n+1]  is the definition of the fibonacci function
16:24:29 <vixey> ayumilove: the next bit shows that starting with (0,1) and iterating the function (\(x,y) -> (y,x+y)) gives you tuples with the invarient that the next tuple's fst is the next fib
16:24:42 <vixey> invariant*
16:24:44 <gwern> vininim: was that a clear enough explanation?
16:24:57 <ayumilove> F[0]=0;
16:24:58 <ayumilove> F[1]=1; how about F[2]= ?
16:25:10 <vixey> by the definition
16:25:27 <vixey> F[2]=F[0+2]=F[0]+F[0+1]=0+1
16:26:12 <ayumilove> viexy: Sorry I do not understand with this line F[2]=F[0+2]=F[0]+F[0+1]=0+1
16:26:20 <ayumilove> too many equal signs
16:26:40 <vininim> gwern: yes, but I'm no expert. =) But for what I know there aren't a lot of problems that can't be reduced to a decision problem(like the halting problem), so "usefull tasks" that doesn't involve interaction end up reducing to optimization, decision and search.
16:26:57 <vininim> and they all can be reduced in terms of NP vs P
16:27:00 <vixey> ayumilove: a=b=c=d is short for a=b and a=c and b=d
16:27:18 <ayumilove> a=d?
16:27:49 <ayumilove> F[n+2]=F[n]+F[n+1] I just dont understand this part
16:28:07 <vixey> ayumilove: What about it?
16:28:09 <gwern> vixey: all of them? I did not know that
16:28:18 <ayumilove> F[2] = F[0]+F[1] ?
16:28:29 <vixey> yes
16:28:36 <ayumilove> please make a simpler example ^_^ " hard for newbies
16:29:36 <ayumilove> F[n+2] so if the user makes n as 3 = F[5] ?
16:29:48 <ayumilove> doesnt make sense
16:29:54 <vixey> why not?
16:32:20 <byte-> i have a quick question
16:32:46 <gwern> oh noes, those are the worst!
16:32:48 <EvilTerran> > let f(0) = 0; f(1) = 1; f(n+2) = f(n) + f(n+1) in map f [0..]
16:32:48 <byte-> is there any technical reason against creating Show instances for functions?
16:32:54 <EvilTerran> ?bot
16:32:56 <EvilTerran> dammit
16:33:24 <dons> byte-: read . show == id
16:33:25 <Toxaris> byte-: no
16:33:41 <dons> > ord -- that said, some instances of show are useful.
16:33:46 <mauke> ENOBOT
16:33:47 <byte-> dons, good point
16:33:58 <Quadrescence> Anyone familiar with the A* search algorithm?
16:34:10 <EvilTerran> if there's no Read instance, that wouldn't be a problem, though
16:34:12 <Toxaris> dons: this law is only a show stopper for Read *and* Show instances, not for Show alone
16:34:18 <gwern> Quadrescence: it's on hackage, a lot of people used it in the last ICFP, and that's it
16:34:28 <gwern> oh, and something about Djikstra and it being fast?
16:34:51 <EvilTerran> i think the main problem is the overhead of carrying around the textual data that would be necessary
16:34:54 <Quadrescence> gwern: It's a generalization of Djikstra's alg.
16:34:56 <Toxaris> > imho even this simple instance can be useful: instance Show (a -> b) where showsPrec _ _ = "<function>"
16:35:03 <ddarius> byte-: Making a useful instance is essentially impossible if you want to preserve referential transparency.
16:35:27 <EvilTerran> Toxaris, that's no good, though, 'cos the output of show is meant to be valid haskell code
16:35:29 <dons> well, that instance is already defined in Text.Show.Functions
16:35:31 <EvilTerran> that's what it says in the report, iirc
16:35:32 <byte-> ddarius, i don't follow
16:35:52 <ddarius> byte-: I made an assertion, there is nothing to follow.
16:36:00 <Toxaris> EvilTerran: hmm, yeah, that's true, but hey, who cares :)
16:36:19 <Toxaris> instance Show (a -> b) where showsPrec _ _ = "undefined" -- for those who care
16:36:24 <byte-> ddarius, i don't follow [your train of thought]
16:36:38 <byte-> ddarius, you basically just asserted that your "assertion" had nothing to understand
16:36:40 <byte-> btw
16:36:44 <EvilTerran> byte-, if two functions are equal in behaviour, you shouldn't be able to tell them apart
16:37:01 <ddarius> byte-: No, I asserted that my assertion did not include explanation.
16:37:06 <EvilTerran> but, if there were a meaningful Show instance for functions, you could construct cases that you *could* tell apart thatway
16:37:06 <SamB_XP> ddarius: maybe he wants you to defend it anyway
16:37:22 <SamB_XP> EvilTerran: what ?
16:37:22 <r3m0t> the output of show is meant to be valid Haskell? so now I know
16:37:23 <EvilTerran> even though the functions are exactly equivalent
16:37:34 <EvilTerran> SamB_XP, what?
16:37:43 <Toxaris> EvilTerran: why? a meaningful show instance could describe the behaviour, couldn't it?
16:37:56 <byte-> ddarius, ok, fair enough
16:38:13 <ayumilove> vixey: http://hpaste.org/9526#a1
16:38:21 <vixey> Toxaris: What if you go (\x -> x,3)
16:38:22 <vixey>  ?
16:38:22 <ddarius> If you restrict the class of function you want to handle, you can make meaningful instances, but that would be an extreme restriction.
16:38:33 <vixey> ayumilove: Can you paste the contents to this channel?
16:38:38 <EvilTerran> Toxaris, identifying equivalent programs is an unsolvable problem - there's no way you could have all functions with the same behaviour show to the same thing
16:38:43 <dons> the show instance could emit ghc bytecode i suppose :)
16:38:44 <ayumilove> f_list2 n = 	
16:38:44 <ayumilove> 	let recA x y n = take n (iterate (+(abc x y)) (0,0) )
16:38:44 <ayumilove> 	in recA 0 1 n
16:38:44 <ayumilove> 	where abc x y = (y,x+y)
16:38:47 <dons> Clean's does that.
16:38:58 <vixey> ayumilove: oh that + is weird
16:38:59 <Toxaris> EvilTerran: I have already given such an instance (the "undefined" one)
16:39:00 <ddarius> dons: Which would violate referential transparency in all likelihood.
16:39:08 <Toxaris> EvilTerran: ok, it is not very meaningful :)
16:39:12 <EvilTerran> Toxaris, but it's not a valid one by the report
16:39:17 <EvilTerran> or, indeed, meaningful
16:39:21 <adekoba_> Whenever I try to profile an app that imports parsec, ghc always complains that it can't find the profiling version of the library. How can I bypass this, without having to manually install every package parsec depends on?
16:39:25 <Toxaris> EvilTerran: why? undefined is haskell code, isn't it?
16:39:33 <marcot> Hello, how do I make bindings for C functions that expects a pointer to a function, using a Haskell function as a parameter of the binding.  I searched about that in gtk2hs code, but I got to connect_BOXED__BOOL, which I couldn't find where is defined.
16:39:42 <vixey> ayumilove: how about just f_list2 n = take n (iterate abc (0,0)) where abc x y = (y,x+y)  -- ?
16:39:44 <ayumilove> i do not know how to implement that stuff into iterate
16:39:47 <EvilTerran> it's got to be haskell code that evaluates to the value you passed to show, though
16:39:48 <byte-> anyway, thanks guys
16:39:54 <dons> marcot: using FunPtr ?
16:39:57 <dcoutts> marcot: those functions are generated.
16:40:05 <Toxaris> EvilTerran: iirc that is only true if both Show and Read are instantiated
16:40:13 <Toxaris> EvilTerran: but not for Show-only types
16:40:21 <Toxaris> EvilTerran: but maybe I'm wrong
16:40:25 <EvilTerran> no, you're thinking of the read.show = id rule
16:40:40 <Toxaris> hmm. yes, eval . show = id is different from read . show = id
16:40:43 <EvilTerran> indeed
16:40:50 <Toxaris> so basically we have read = eval
16:40:54 <EvilTerran> and is how Show is defined to work, iirc
16:40:55 <vixey> eval ??
16:41:01 <EvilTerran> vixey, we're being hypothetical
16:41:13 <vixey> :t eval
16:41:18 <dons> glguy: have you seen yav's $50,000,000 banknote?
16:41:19 <EvilTerran> it should probably be called unsafeEvalExpression
16:41:20 <marcot> dcoutts: hum... I'll check the compiled code.
16:41:26 <marcot> dons: I'll take a look, thanks.
16:41:26 <EvilTerran> vixey, it doesn't really exist
16:41:31 <glguy> dons: I have
16:41:35 <vixey> I still want to know what type it has
16:41:36 <glguy> dons: shame that it expired :(
16:41:43 <EvilTerran> String -> Maybe a
16:41:44 <dons> glguy: yeah, a pity.
16:41:51 <vixey> ok
16:41:53 <Toxaris> vixey: String -> a
16:41:57 <EvilTerran> perhaps Typeable a => String -> Maybe a
16:42:08 <dcoutts> marcot: see Graphics.UI.Gtk.Signals
16:42:15 <EvilTerran> or you can drop the Maybe if you don't mind blindly propagating exceptions
16:42:30 <ayumilove> f_list2 n = take n (iterate abc (0,0) )
16:42:31 <ayumilove> 	where abc x y = (y,x+y)
16:42:35 <ayumilove> o_O
16:43:57 <ayumilove> Vixey: f_list2 n = take n (iterate abc (0,1) )
16:43:58 <ayumilove> 	where abc (x,y) = (y,x+y)
16:44:05 <ayumilove> :D
16:44:19 <vixey> cool
16:44:24 <ayumilove> T_T so difficult
16:44:34 <vixey> but does it work?
16:44:36 <ayumilove> yeah
16:44:39 <Botje> ayumilove: what's difficult about it? :)
16:44:43 <ayumilove> ayumilove: how about just f_list2 n = take n (iterate abc (0,0)) where abc x y = (y,x+y)  -- ?
16:44:51 <ayumilove> sorry wrong stuff
16:44:52 <ayumilove> Main> f_list2 5
16:44:52 <ayumilove> [(0,1),(1,1),(1,2),(2,3),(3,5)]
16:44:52 <Botje> your "abc" function expresses the recurrence relation very neatly
16:45:09 <ayumilove> I always thought that iterate needs some kind of operator like +abc
16:45:21 <vixey> take n (iterate abc (0,0)) where abc x y = (y,x+y)
16:45:39 <vixey> take n (iterate abc (0,0)) where abc = \x y -> (y,x+y)
16:45:45 <vixey> take n (iterate (\x y -> (y,x+y)) (0,0))
16:45:50 <vixey> :t \n -> take n (iterate (\x y -> (y,x+y)) (0,0))
16:45:54 <vixey> <type error>
16:46:23 <vixey> oh
16:46:24 <vixey> my fault
16:46:31 <ayumilove> i am puzzled, how does abc know what to take in? like taking in the (0,1)
16:46:44 <vixey> ayumilove: iterative gives it that
16:46:45 <Botje> that's what the iterate function does
16:46:47 <Botje> @src iterate
16:46:56 <Botje> ah, no \bot?
16:47:00 <ayumilove> could you explain how this iterate works o_o,
16:47:06 <adu> @seen lambdabot
16:47:14 <dibblego> @src iterate
16:47:14 <lambdac> iterate f x =  x : iterate f (f x)
16:47:15 <EvilTerran> iterate f x = x : iterate f (f x)
16:47:21 <vixey> iterate f x = x : iterate f (f x)
16:47:22 <EvilTerran> @bot
16:47:22 <lambdac> :)
16:47:32 <Botje> TWO OF THOSE ARE NOT LAMBDABOT
16:47:32 <adu> @seen lambdac
16:47:32 <lambdac> Yes, I'm here. I'm in #haskell, #reductio and #functionaljava
16:47:43 <EvilTerran> <.<
16:47:43 <ayumilove> @lambdabot
16:47:44 <lambdac> Unknown command, try @list
16:47:47 <ayumilove> lol
16:48:02 <MyCatVerbs> Functional Java? Oh, my. :(
16:48:06 <ayumilove> gtg guys, I'll ask more question on this iterate ^_^ "
16:48:08 <vixey> @tell ayumilove bye
16:48:09 <lambdac> Consider it noted.
16:48:10 <Shiruka> something like (+1) is not in any way special, except for the syntax.. it's just a function
16:48:27 <vininim> > 1
16:48:28 <lambdac>  1
16:48:40 <chrisdone> > map f [a,b,c]
16:48:45 <lambdac>  Add a type signature
16:48:45 <Toxaris> > iterate f x
16:48:47 <lambdac>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
16:48:56 <chrisdone> > map f [a,b,c] :: [Expr]
16:48:57 <lambdac>  [f a,f b,f c]
16:49:00 <ddarius> :t map
16:49:01 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:50:45 <vininim> > filter aks_test [1..]
16:50:46 <lambdac>   Not in scope: `aks_test'
16:51:39 <vininim> should be in Prelude, imho ;)
16:52:11 <Shiruka> aks would probably be an insanely slow way to generate small primes even compared to naive methods :-)
16:52:24 <vininim> not to mention the beginning 1 for extra controversy
16:58:36 <r3m0t> how does lambabot's "abstract" behaviour work?
16:58:46 <r3m0t> > zipWith (+) [a,b,c] [d,e,f]
16:58:47 <lambdac>  [a + d,b + e,c + f]
16:58:55 <EvilTerran> ?where simplereflect
16:58:55 <lambdac> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
16:58:58 <mauke> it's actually not abstract :-)
16:58:59 <EvilTerran> with that
16:59:47 <dons> a surprising in-language approach.
17:01:20 <EvilTerran> ?type x
17:01:21 <lambdac> Expr
17:01:22 <EvilTerran> ?type f
17:01:23 <lambdac> forall a. (SimpleReflect.FromExpr a) => a
17:01:32 <EvilTerran> ?instances-importing SimpleReflect FromExpr
17:01:33 <lambdac> Couldn't find class `FromExpr'. Try @instances-importing
17:01:39 <EvilTerran> harumph
17:05:18 <yaru1022> hello
17:05:32 <dons> welcome yaru1022
17:05:58 <yaru1022> can I upgrade ghc 6.8.2 to ghc 6.8.3 using cabal upgrade or cabal install?
17:06:36 <dcoutts> yaru1022: sadly not
17:06:50 <adekoba> yaru1022: no. Try through your package manager.
17:09:37 <dons> it's a nice idea though, yaru1022
17:09:51 <yaru1022> yeah it would be awesome if we can upgrade ghc with cabal
17:10:35 <yaru1022> and also, I installed yi-0.4 with cabal install, but when I check 'yi --version', it still says 0.3.0 (which I installed manually before)
17:10:40 <dcoutts> I reckon we could at least build nhc using cabal
17:10:56 <dcoutts> cabal install nhc && cabal install --nhc base
17:11:13 <ddarius> yaru1022: The yi in your path is probably the old one while the new one is not in your path.
17:13:46 <yaru1022> how do i know where the new one is?
17:14:37 <dons> yi builds with cabal install, yeah.
17:21:04 <Quadrescence> What's a good search algorithm for a tree that has a constant number of branches N>2 per node, and heuristics are known about the lower bound of the depth of the solution?
17:21:27 <mauke> linear search
17:22:51 <dons> do you know anything about the distribution of data in the tree? is it ordered in any way?
17:23:08 <Quadrescence> Each node is derived from the parent node in a deterministic way.
17:23:50 <dons> so to find a node, you look at the parent, which tells you which branch to take?
17:24:39 <Quadrescence> If you have a node, the children are generated by a defined set of N>2 "transformations" (if that's how you want to call them)
17:24:50 <Quadrescence> The transformations are NOT dependent upon the node.
17:25:18 <Shiruka> simply search the best-looking nodes first?
17:25:56 <Quadrescence> Hmm, I'm not sure I can determine a "best looking" node.
17:26:42 <Quadrescence> If I could, then I suppose I could do that one algorithm -- uphill searching, or whatever it's called.
17:27:26 <Shiruka> I thought you could use the lower bound of depth for it
17:27:39 <Quadrescence> Well, yes, you're right.
17:29:20 <Quadrescence> Hmm, let me "switch this up."
17:29:52 <Quadrescence> Actually, I'll just think about it more. :>
17:30:13 <Shiruka> you can't really say much about general search problems, all the algorithms depend on some characteristics of the search tree
17:30:20 <Quadrescence> Right.
17:30:36 <Shiruka> even if it's something fairly general such as "it's a tree for a two-player game"
17:31:15 <Quadrescence> Some things could be ruled out, like depth-first searches.
17:33:00 <Quadrescence> Hmm, I know the initial state, and I know the goal state, maybe I could do a bidirectional search. However, I think this would trade-off speed for memory.
17:34:48 <MyCatVerbs> Quadrescence: you have to either know *something* about the tree's structure, or else you have a problem where there's no possible solution better than breadth-first exhaustive search. Surely no one's stuck you with *that*, have they?
17:34:49 <Shiruka> sounds like you're doing route finding in a graph.. if you have a heuristic for lower bound, wouldn't A* apply?
17:35:31 <Shiruka> (lower bound distance, that is)
17:35:38 <yaru1022> hey, by the way, if I install ghc-6.8.3, do I need to install all the packages again?
17:35:45 <yaru1022> right now I have 6.8.2
17:35:49 <MyCatVerbs> yaru1022: yes.
17:35:54 <mauke> yes
17:36:29 <Quadrescence> MyCatVerbs: Shiruka: I've talked about it before  (a while ago) in here. It's a Rubik's Cube solving algorithm. Of course it's not pure brute force, I have other tricks. So ignore that it's a Rubik's cube, and just think about the _concept_
17:37:08 <Shiruka> ah, so it is indeed route finding in a graph :-)
17:37:37 <Quadrescence> I could start with the solved state at the root, apply all possible moves, and repeat until I find the desired mixed state
17:37:39 <EvilTerran> there may be a lower bound heuristic you could use
17:37:54 <Quadrescence> EvilTerran: I said I can find a lower bound heuristic. :>
17:38:06 <EvilTerran> oh right, ok
17:38:08 <QtPlatypus> Quadrescence: Do you have a huristic that tells you how far you are from the desired state?
17:38:14 <EvilTerran> sorry, i've just wandered in, haven't read all the scrollback
17:38:20 <Quadrescence> QtPlatypus: No.
17:38:26 <Quadrescence> EvilTerran: No prob. :D
17:39:06 <Quadrescence> If we did a bidirectional search, and puzzle like a Rubik's Cube would grow pretty fast.
17:39:17 <Shiruka> Quadrescence: um, I thought "lower bound heuristic" meant a heuristic for a lower bound of moves from a state to the desired state
17:39:24 <Quadrescence> Well, not the puzzle, but the tree you're growing.
17:39:42 <Quadrescence> Shiruka: The minimum number of moves it'd take to solve.
17:39:51 <Quadrescence> i.e. it cannot be solved with less moves.
17:40:21 <Shiruka> well, that's it.. as long as you can compute it in any state
17:40:39 <Quadrescence> Yes, I can.
17:41:16 <Quadrescence> But, another thing... I couldn't generate the entire tree, of course.
17:41:27 <Quadrescence> It'd have to be generated implicitly.
17:41:32 <gwern> I am astonished. wxhaskell finally installed
17:41:43 <Shiruka> there are variants of A* that use bounded amount of memory
17:41:49 <gwern> albeit it did require 'sudo cabal install'...
17:42:18 <Quadrescence> Shiruka: Any links you could provide?
17:43:36 <Shiruka> I don't have any at hand, it's been a long time since I used A* for anything
17:44:13 <Quadrescence> mmm, then I guess I'll go explore the forest which we call Google.
17:46:02 <dons> there's an A* library on hackage.
17:46:13 <Quadrescence> :) I'll take a look at it.
17:46:19 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/astar
17:46:24 <Shiruka> quick googling found this at least: http://www.cis.temple.edu/~ingargio/cis587/readings/more-search.html
17:46:26 <lambdac> Title: Some Search Algorithms, http://tinyurl.com/5ov2kk
17:46:38 <dmwit> The web is a tree of links whose root is Google.
17:46:47 <Shiruka> SMA* looks like the one I was vaguely remembering exists :-)
17:47:32 <Quadrescence> Shiruka: Thanks. :>
17:49:13 <Shiruka> I didn't look at the pseudocode though :-)
17:51:31 <gwern> @seen kowey
17:51:31 <lambdac> I haven't seen kowey.
17:52:48 <mauke> preflex: seen kowey
17:52:48 <preflex>  kowey was last seen on #haskell 5 hours, 7 minutes and 58 seconds ago, saying: darcsgit was discontinued due to lack of hackers
17:53:21 <Quadrescence> unplugging power cable ftl
17:53:32 <dons> don't do it! you might not reboot
17:53:39 <dons> or do you have a UPA?
17:53:45 <mauke> (24" screen)++
17:54:21 <Quadrescence> dons: I just accidentally unplugged.
17:54:27 <Quadrescence> And I don't have a UPA.
17:55:42 <SamB_XP> Quadrescence: quick boot!
17:56:14 <SamB_XP> well, or slow timeout
17:56:27 <Quadrescence> Probably a combination of both.
17:57:27 <chrisdone> I am in love with formlets!! http://hpaste.org/9529
17:57:57 <dons> Quadrescence: sorry, I was making a joke that *you* were plugged into a power supply, not your computer.
17:58:05 <dons> chrisdone: that's timely.
17:58:07 <Quadrescence> Oh. :|
17:58:16 <dons> chrisdone: blog with screenshots please :)
17:58:51 <chrisdone> dons: haha, ok ^_<
18:01:30 <yaru1022> is gtk2hs not in cabal package?
18:03:40 <dons> yaru1022: correct.
18:05:56 <heatsink> @src mappend
18:05:56 <lambdac> Source not found. Maybe if you used more than just two fingers...
18:06:14 <heatsink> @src Endo.mappend
18:06:15 <lambdac> Source not found. There are some things that I just don't know.
18:07:38 <dmwit> ?src mappend Endo
18:07:39 <lambdac> Source not found. My mind is going. I can feel it.
18:07:41 <dmwit> mappend = (.)
18:07:55 <mauke> @src Endo mappend
18:07:56 <lambdac> Source not found. That's something I cannot allow to happen.
18:08:07 <dmwit> :t mappenfd
18:08:09 <lambdac> Not in scope: `mappenfd'
18:08:10 <dmwit> :t mappend
18:08:11 <vixey> @src Endo
18:08:11 <lambdac> Source not found. I can't hear you -- I'm using the scrambler.
18:08:12 <lambdac> forall a. (Monoid a) => a -> a -> a
18:08:35 <dmwit> Anyway, yeah, "mappend = (.)".
18:09:15 <chrisdone> I thought it was (.) = mappend
18:09:27 <heatsink> Hmm.  (a -> a) behaves differently from Endo.
18:10:01 <heatsink> That's part of what was confusing me I think.
18:10:27 <Shiruka> the ICFP contest is bad for your brain.. whenever I see Endo, I think of a silly alien instead of endomorphism :-(
18:11:04 <heatsink> It's part of the PR campaign to make category theory sound warm and firendly.
18:11:09 <heatsink> *friendly
18:11:19 <Shiruka> warm fuzzy.. alien?
18:12:16 <chrisdone> daym, .tv domains are expensive
18:12:35 <chrisdone> £30 for one year (or $500)
18:19:07 <heatsink> @src mconcat
18:19:07 <lambdac> Source not found. My mind is going. I can feel it.
18:19:31 <vixey> :t mconcat
18:19:34 <lambdac> forall a. (Monoid a) => [a] -> a
18:19:51 <heatsink> Yeah, I'm wondering about whether it's lazy-style (foldr) or strict (foldl').
18:19:59 <heatsink> They're equivalent unless you run out of stack space.
18:20:30 <dibblego> they're not equivalent
18:20:50 <dibblego> > foldr (-) 0 [5,6,7]
18:20:51 <lambdac>  6
18:20:57 <dibblego> > foldl' (-) 0 [5,6,7]
18:20:59 <lambdac>  -18
18:21:08 <heatsink> dibblego, For monoids they're equivalent because monoids are associative.
18:21:37 <dibblego> oh, didn't see that :)
18:22:40 <vixey> what's better foldr or foldl'?
18:22:49 <Cale> vixey: depends on the task
18:22:54 <mauke> what's better, addition or multiplication?
18:23:06 <Cale> vixey: foldr has the advantage that it can work on infinite lists
18:23:16 <chrisdone> who's better, mauke or preflex?
18:23:18 <Cale> and can finish its job early sometimes
18:23:53 <Cale> foldl' always recurses down to the end of the list before returning anything, but it's tail recursive and combines the elements as it goes
18:24:08 <Cale> (so hopefully can save memory in many situations)
18:24:27 <heatsink> > let parens s = "(" ++ s ++ ")" in mconcat (replicate 4 parens) []
18:24:29 <lambdac>  "()()()()"
18:24:40 <heatsink> I can't figure out why the parentheses aren't nested.
18:24:57 <heatsink> It should give me the equivalent of
18:25:07 <heatsink> > let parens s = "(" ++ s ++ ")" in parens $ parens $ parens $ parens []
18:25:08 <lambdac>  "(((())))"
18:25:24 <gwern> > let parens s = z ++ s ++ z in mconcat (replicate 4 parens) []
18:25:25 <lambdac>  Couldn't match expected type `[a]' against inferred type `Expr'
18:25:40 <gwern> phooey. I thought the reflection stuff would work
18:25:41 <vixey> :t let parens s = "(" ++ s ++ ")" in mconcat (replicate 4 parens)
18:25:42 <lambdac> [Char] -> [Char]
18:25:48 <vixey> :t let parens s = "(" ++ s ++ ")" in msum (replicate 4 parens)
18:25:50 <lambdac>     No instance for (MonadPlus ((->) [Char]))
18:25:50 <lambdac>       arising from a use of `msum' at <interactive>:1:34-58
18:25:50 <lambdac>     Possible fix:
18:26:02 <vixey> :t let parens s = "(" ++ s ++ ")" in sequence (replicate 4 parens)
18:26:04 <lambdac> [Char] -> [[Char]]
18:26:26 <TSC> @src [] mconcat
18:26:26 <lambdac> Source not found. Take a stress pill and think things over.
18:26:31 <TSC> @src mconcat []
18:26:31 <lambdac> Source not found. Sorry about this, I know it's a bit silly.
18:26:33 <TSC> Bah
18:26:42 <TSC> @src mconcat
18:26:43 <lambdac> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:26:48 <chrisdone> I love that stress pill line
18:27:13 <TSC> Is mconcat for lists just ++ ?
18:27:20 <TSC> Or concat, rather
18:27:22 <Olathe> @src replicate
18:27:22 <lambdac> replicate n x = take n (repeat x)
18:27:35 <heatsink> TSC: yeah, but I'm using mconcat for ([Char] -> [Char])
18:27:41 <TSC> Yes, I see that now (:
18:28:04 <vixey> :t in mconcat (replicate 3 (1+)) x
18:28:06 <lambdac> parse error on input `in'
18:28:09 <vixey> > mconcat (replicate 3 (1+)) x
18:28:13 <lambdac>   add an instance declaration for (Monoid Expr)
18:28:13 <lambdac>     In the expression: mconca...
18:28:20 <heatsink> :t x
18:28:22 <lambdac> Expr
18:28:27 <heatsink> ???
18:28:29 <heatsink> x
18:28:31 <heatsink> > x
18:28:32 <vixey> > mconcat (replicate 3 (1+)) 1
18:28:32 <lambdac>  x
18:28:33 <lambdac>  Add a type signature
18:28:37 <vixey> > mconcat (replicate 3 (1+)) 1 :: Integer
18:28:38 <lambdac>   add an instance declaration for (Monoid Integer)
18:28:38 <lambdac>     In the expression: mco...
18:28:40 <vixey> oh
18:28:43 <TSC> heatsink: It's for doing things like:
18:28:53 <vixey> oh I get it
18:28:59 <TSC> > foldr (+) a [b,c,d]
18:29:01 <lambdac>  b + (c + (d + a))
18:29:06 <vixey> > mconcat [Just "foo",Nothing,Just "bar"]
18:29:08 <lambdac>  Just "foobar"
18:29:21 <vixey> :t mconcat [Just id,Nothing,Just (+1)]
18:29:23 <lambdac> forall a. (Monoid a, Num a) => Maybe (a -> a)
18:29:44 <noohgodno> > sum (cos [1..1000])
18:29:45 <lambdac>   add an instance declaration for (Floating [a])
18:29:45 <vixey> > let parens s = "(" ++ s ++ ")" in sequence (map Just $ replicate 4 parens) []
18:29:46 <lambdac>  Couldn't match expected type `[a] -> t'
18:29:55 <noohgodno> eh
18:29:56 <vixey> :t let parens s = "(" ++ s ++ ")" in sequence (map (Just .) $ replicate 4 parens)
18:29:58 <lambdac> [Char] -> [Maybe [Char]]
18:30:01 <vixey> > let parens s = "(" ++ s ++ ")" in sequence (map (Just .) $ replicate 4 parens) []
18:30:03 <lambdac>  [Just "()",Just "()",Just "()",Just "()"]
18:30:23 <vixey> > let parens s = "(" ++ s ++ ")" in mconcat (map (Just .) $ replicate 4 parens) []
18:30:24 <lambdac>  Just "()()()()"
18:30:29 <vixey> > let parens s = "(" ++ s ++ ")" in mconcat (replicate 4 parens) []
18:30:31 <lambdac>  "()()()()"
18:30:42 <noohgodno> > let parents s = "()()()()"
18:30:42 <lambdac>  Parse error at end of input
18:30:47 <noohgodno> > let parents s = "()()()()" []
18:30:47 <lambdac>  Parse error at end of input
18:31:00 <noohgodno> ????????????????????
18:31:04 <heatsink> So... what is mconcat doing with my functions?
18:31:27 <heatsink> noohgodno, it's  let ... in ...
18:31:46 <noohgodno> > let parens s = "()()()()" in replicate 4 parens []
18:31:47 <lambdac>  Couldn't match expected type `[a] -> t'
18:32:05 <noohgodno> first i have to know what i'm trying to do
18:32:16 <noohgodno> stupid haskell
18:32:16 <heatsink> > mconcat [\s -> "(" ++ s ++ ")", \s -> "[" ++ s ++ "]"] []
18:32:18 <lambdac>  "()[]"
18:32:45 <vixey> :t foldr (.) id
18:32:47 <lambdac> forall a. [a -> a] -> a -> a
18:32:53 <heatsink> > (\s->"("++s++")")(\s->"["++s++"]"][])
18:32:53 <lambdac>  Parse error at "][])" (column 34)
18:32:57 <heatsink> > (\s->"("++s++")")(\s->"["++s++"]"[])
18:33:01 <lambdac>      The lambda expression `\ s -> "[" ++ s ++ "]" []' has one argument,
18:33:01 <lambdac>     ...
18:33:03 <vixey> @hoogle [m a] -> m a
18:33:03 <lambdac> A Hoogle error occured.
18:33:16 <vixey> :t msum
18:33:18 <heatsink> > (\s->"("++s++")")(\s->"["++s++"]")[]
18:33:19 <lambdac> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:33:19 <lambdac>  Couldn't match expected type `t1 -> t'
18:33:25 <vixey> @instances MonadPlus
18:33:26 <lambdac> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:33:34 <noohgodno> > cos 2
18:33:35 <lambdac>  -0.4161468365471424
18:33:38 <vixey> Why can't we have a MonadPlus for (->)e?
18:33:54 <noohgodno> > product [1..123609237806236]
18:34:00 <vixey> :t msum [id,id]
18:34:03 <lambdac> forall a. (MonadPlus ((->) a)) => a -> a
18:34:04 <lambdac> Terminated
18:34:06 <heatsink> vixey: There's no useful mzero for that type
18:34:15 <vixey> heatsink: id isn't mzero?
18:34:33 <vixey> > let parens s = "(" ++ s ++ ")" in msum [parens,parens,parens]
18:34:34 <lambdac>        add an instance declaration for (MonadPlus ((->) [Char]))
18:34:34 <lambdac>     In the e...
18:34:35 <vixey> :t let parens s = "(" ++ s ++ ")" in msum [parens,parens,parens]
18:34:37 <lambdac>     No instance for (MonadPlus ((->) [Char]))
18:34:37 <lambdac>       arising from a use of `msum' at <interactive>:1:34-60
18:34:37 <lambdac>     Possible fix:
18:34:40 <noohgodno> > sum n $ product [1..16236]
18:34:41 <lambdac>  Couldn't match expected type `[a]' against inferred type `Expr'
18:35:00 <vixey> @unmtl ReaderT r m
18:35:00 <lambdac> err: `ReaderT r m' is not applied to enough arguments, giving `/\A. r -> m A'
18:35:03 <vixey> @unmtl ReaderT r m a
18:35:03 <lambdac> r -> m a
18:35:08 <heatsink> vixey: id reads.
18:35:14 <vixey> :t let parens s = ["(" ++ s ++ ")"] in msum [parens,parens,parens]
18:35:16 <lambdac>     No instance for (MonadPlus ((->) [Char]))
18:35:16 <lambdac>       arising from a use of `msum' at <interactive>:1:36-62
18:35:16 <lambdac>     Possible fix:
18:35:42 <heatsink> > (do x <- id; return (Just x)) 100
18:35:43 <lambdac>  Just 100
18:37:10 <heatsink> I must be missing something.  I don't see any possible way for mappend to produce "()()()()" above.
18:37:33 <heatsink> OH wait a minute.
18:37:45 <vixey> heatsink: did you see what happened with the Justs ?
18:37:51 <vixey> heatsink: that convinced me
18:38:05 <heatsink> >let paren x = "(" ++ x ++ ")" in mconcat (replicate 4 paren) "a"
18:38:11 <heatsink> > let paren x = "(" ++ x ++ ")" in mconcat (replicate 4 paren) "a"
18:38:12 <lambdac>  "(a)(a)(a)(a)"
18:38:25 <heatsink> It's replicating the value!
18:38:28 <vixey> > let paren x = "(" ++ x ++ ")" in mconcat (replicate 4 (Just . paren)) "a"
18:38:29 <lambdac>  Just "(a)(a)(a)(a)"
18:38:37 <vixey> > let paren x = "(" ++ x ++ ")" in sequence (replicate 4 (Just . paren)) "a"
18:38:38 <lambdac>  [Just "(a)",Just "(a)",Just "(a)",Just "(a)"]
18:38:51 <mar77a> whirrr i'm back
18:39:15 <heatsink> That means that the library must be introducing (++) somewhere too.
18:39:23 <noohgodno> >
18:39:28 <heatsink> vixey: I don't get how you figured that out from the Just example though.
18:39:40 <vixey> heatsink: Also
18:39:45 <vixey> > Just "foo" ++ Just "bar"
18:39:47 <lambdac>  Just "foobar"
18:40:01 <vixey> > Nothing ++ Nothing
18:40:03 <lambdac>  Nothing
18:40:05 <vixey> two nothings is nothing
18:40:35 <heatsink> > Just (Just "foo") ++ Just (Just "bar")
18:40:35 <lambdac>  Just (Just "foobar")
18:40:53 <vixey> > reverse . Just "foo"
18:40:54 <lambdac>  Just "oof"
18:41:08 <heatsink> what the
18:41:10 <heatsink> :t reverse
18:41:12 <lambdac> forall a. [a] -> [a]
18:41:14 <vixey> > mconcat [Just "foo",Just "bar"]
18:41:15 <lambdac>  Just "foobar"
18:41:16 <chrisdone> @src (.)
18:41:16 <lambdac> (f . g) x = f (g x)
18:41:22 <vixey> > Just "foo" ++ Just "bar"
18:41:23 <lambdac>  Just "foobar"
18:41:26 <dmwit> heatsink: (.) = fmap in here
18:41:31 <mauke> :t (.)
18:41:32 <dmwit> heatsink: And (++) = mappend
18:41:33 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:41:38 <mauke> :t (++)
18:41:40 <lambdac> forall m. (Monoid m) => m -> m -> m
18:41:56 <vixey> it kind of makes these things like mconcat easier to understand
18:42:07 <vixey> because you can think of it as putting ++ between each
18:42:47 <mar77a> > return 2 >>= (\t -> print t)
18:42:48 <lambdac>  <IO ()>
18:42:58 <dmwit> > return 2 >>= print
18:42:59 <lambdac>  <IO ()>
18:43:04 <dmwit> > print 2
18:43:05 <lambdac>  <IO ()>
18:43:30 <vixey> :t read . getLine
18:43:31 <vixey> ^^^^^^^
18:43:33 <lambdac> forall a. (Read a) => IO a
18:43:47 <heatsink> > let paren x = "(" ++ x ++ ")" in (paren ++ paren) []
18:43:48 <lambdac>  "()()"
18:43:52 <heatsink> > let paren x = "(" ++ x ++ ")" in (paren [] ++ paren [])
18:43:53 <lambdac>  "()()"
18:44:08 <vixey> > let paren x = "(" ++ x ++ ")" in (paren . paren) []
18:44:10 <lambdac>  "(())"
18:44:19 <vixey> > let paren x = "(" ++ x ++ ")" in paren [] . paren []
18:44:20 <lambdac>  Couldn't match expected type `a -> b'
18:44:24 <heatsink> vixey: See, that's what I was expecting.
18:44:39 <vixey> heatsink,
18:44:45 <heatsink> vixey: yes?
18:44:47 <vixey> > Just "foo" ++ Just "bar"
18:44:49 <lambdac>  Just "foobar"
18:44:56 <vixey> > (const "foo" ++ const "bar") []
18:44:57 <lambdac>  "foobar"
18:45:13 <vixey> Just "foo" ++ Just "bar" = Just ("foo" ++ "bar")
18:45:20 <vixey> const "foo" ++ const "bar"= const ("foo" ++ "bar")
18:46:37 <heatsink> I see the similarity.
18:47:32 <dons> woot! http://www.reddit.com/r/programming/comments/6vqv2/paradise_an_edsl_in_haskell_developed_by_credit/
18:47:38 <lambdac> Title: Paradise, an EDSL in Haskell developed by Credit Suisse for Derivatives Pricing  ..., http://tinyurl.com/6xqt9x
18:48:17 <dsrogers> is '' (two single quotes) a function in TH?
18:49:05 <dons> nope.
18:49:21 <ddarius> It is a notation.
18:49:39 <vixey> :t ''
18:49:41 <lambdac> lexical error in string/character literal at character '\''
18:49:47 <ddarius> ''Type
18:50:45 <Quadrescence> [[(1,2),(3,4)],[(5,6)]] <-- is this valid? I presume not... but it is of type [[(Int,Int)]], so I don't know.
18:50:55 <vixey> :t [[(1,2),(3,4)],[(5,6)]]
18:50:57 <lambdac> forall t t1. (Num t1, Num t) => [[(t, t1)]]
18:51:08 <Olathe> > [[(1,2),(3,4)],[(5,6)]]
18:51:09 <lambdac>  [[(1,2),(3,4)],[(5,6)]]
18:51:11 <Quadrescence> :O So it IS!
18:51:19 <Olathe> > [[(1,2),(3,4)],(5,6)]
18:51:20 <lambdac>  Couldn't match expected type `[(t, t1)]'
18:51:23 <mauke> > typeOf [[(1,2),(3,4)],[(5,6)]]
18:51:24 <lambdac>  [[(Integer,Integer)]]
18:51:42 <Quadrescence> Thanks my homeslices.
18:52:49 <dsrogers> so what is the '' notation for?
18:52:54 <dsrogers> is it documented somewhere?
18:53:02 <Quadrescence> You mean ``?
18:53:31 <heatsink> ++vixey
18:53:33 <heatsink> ++dmwit
18:53:41 <mauke> preincrement doesn't work
18:53:59 <mauke> use postincrement to give out karma
18:54:05 <heatsink> okay
18:54:06 <heatsink> vixey++
18:54:07 <heatsink> dmwit++
18:54:08 <Quadrescence> dsrogers: Compare: mod 5 2  and  5 `mod` 2
18:54:18 <dsrogers> no, not ``
18:54:24 <Quadrescence> Oh, then nevermind.
18:54:35 <dsrogers> isUnit = pureType == ConT ''()
18:54:56 <mauke> preflex: karma vixey
18:54:56 <preflex>  karma for vixey: 4
18:57:38 <dsrogers> :t ConT ''()
18:57:39 <lambdac> lexical error in string/character literal at character '\''
18:59:27 <Quadrescence> >getStdRandom (randomR (1,10))
19:01:48 <vixey> hey
19:01:54 <vixey> where can I read more about squiggol?
19:01:55 <lispy> ?version
19:01:56 <lambdac> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.00GHz)
19:01:56 <lambdac> darcs get http://code.haskell.org/lambdabot
19:02:04 <lispy> Why is \bot down again :(
19:02:41 <ddarius> @google SQUIGOL
19:02:42 <lambdac> No Result Found.
19:03:04 <ddarius> http://www.google.com/search?q=squigol&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:en-US:unofficial&client=firefox-a
19:03:06 <lambdac> Title: squigol - Google Search, http://tinyurl.com/5o5cf9
19:04:52 <noohgodno> > in the gauze womb of the god becoming
19:04:52 <lambdac>  Parse error at "in" (column 1)
19:06:31 <Quadrescence> > 1 : [2,3]
19:06:33 <lambdac>  [1,2,3]
19:06:39 <Quadrescence> > [1] ++ [2,3]
19:06:40 <lambdac>  [1,2,3]
19:06:52 <Quadrescence> > 1 ++ [2,3]
19:06:53 <lambdac>   add an instance declaration for (Num [t])
19:06:56 <Quadrescence> gewd
19:07:08 <mauke> > return 1 ++ [2,3]
19:07:09 <lambdac>  [1,2,3]
19:07:33 <lispy> > fail "1" ++ [2,3]
19:07:35 <lambdac>  [2,3]
19:13:08 <vixey> I want to read more squiggol
19:13:34 <vixey> hey edwardk had you encountered mutumorphisms ?
19:13:47 <vixey> I don't know if it's relevant to what you were doing but it might be
19:14:10 <edwardk> yeah
19:15:08 <vixey> I started reading this paper Calculating Compilers
19:15:21 <vixey> there is a lot of program derivation
19:16:09 <edwardk> however iirc a mutumorphism, unlike a zygomorphism is just the process of fusing x :: f (a,b) -> a and a y :: f (a,b) -> b  toget an f algebra with carrier (a,b) : f (a,b) -> (a,b), which can be implemented as a catamorphism of x &&& y
19:17:07 <edwardk> thats the main reason why i didn't bother to implement it. it was also mentioned by fokkinga in law and order in algorithmics
19:19:56 <vixey> All I know is like
19:20:03 <vixey> Algebra of Programming
19:20:09 <vixey> this paper
19:20:14 <vixey> various blog posts
19:20:23 <vixey> I can't really find anything else about squigol
19:20:28 <edwardk> *nods*
19:20:32 <vixey> :((
19:21:16 <edwardk> it mostly died when meijer went to microsoft. there were some japanese folks trying to make hylo fusion etc work, but they seem to have stopped doing anything productive around 2000.
19:21:51 <edwardk> squiggol itself seems to have been mostly in the minds of lambert meertens and his students
19:22:14 <SamB_XP> edwardk: hmm. suspicious.
19:22:57 <edwardk> at last check even meijer found all of the epicycles and embellishments on this a bit too abstract. ;)
19:23:14 <edwardk> uustalu told me he was pretty much sick of the categorization game as well
19:23:29 <SamB_XP> oh, nevermind the suspicions then
19:23:36 <SamB_XP> categorization game?
19:24:04 <edwardk> zygo, histo, pick-a-greek-name-of-the-week-to-maintain-the-style-laid-out-by-meertens, etc.
19:24:57 <SamB_XP> oh, that nonsense
19:25:11 <edwardk> he stopped playing around hence why the current scheme he mentioned the recursion scheme from the cofree recursive comonad doesn't have a greek name.
19:25:12 <SamB_XP> supercalifragilisticexpialamorphisms and all thet, yes
19:25:59 <SamB_XP> I still want to see the coffee comonad that someone blogged about and then erased from his blog
19:26:24 <edwardk> it was bos, he didn't erase it, his blog crashed and had to be restored from a backup
19:27:01 <SamB_XP> oh
19:27:13 <SamB_XP> why didn't he restore that from the RSS feeds?
19:27:25 <edwardk> *shrug*
19:27:44 <edwardk> i remember there were a few posts that suddenly vanished from his blog and asking him about it is all
19:27:50 <SamB_XP> The coffee comonad
19:27:50 <SamB_XP> from teideal glic deisbhéalach by Bryan O'Sullivan
19:27:50 <SamB_XP> I can’t be the only person who makes this misreading. It’s clearly the dual of the decaf monad, and appropriately enough involves consumption instead of production, but beyond this I have little idea of its properties.
19:28:09 <adu> SamB: how is it a comonad?
19:28:24 <SamB_XP> adu: well, if you misread cofree comonad ...
19:29:06 <adu> coffee :: Tired me -> me?
19:29:46 <tehgeekmeister> is hxt sufficiently lazy for use on large files?  i ran into problems getting hexpat to build on my system, and hxt seems more elegant anyway.
19:29:50 <edwardk> thats the tired comonad, i can extend that indefinitely. given an operation that doesn't leave me tired, I can choose to be tired at the end of it.
19:29:55 <tehgeekmeister> (by large i mean nearly four gigabytes)
19:30:00 <Shiruka> coffee :: me -> Drugged me
19:30:09 <adu> Shiruka: lol
19:30:27 <adu> speaking of which, how do I tell if I have something pipped in stdin?
19:31:16 <Shiruka> AFAIK you can't really, but you can check that there's no pty
19:31:17 <Zao> gwern: Meep meep.
19:31:58 <Shiruka> I haven't actually done it ever so I don't know the details :-P
19:32:18 <SamB_XP> adu: why do you want to know?
19:32:34 <adu> SamB_XP: I'm writing a "grep"like tool in haskell.
19:32:40 <SamB_XP> and?
19:32:54 <edwardk> @type hIsTerminalDevice
19:32:56 <lambdac> Not in scope: `hIsTerminalDevice'
19:32:56 <adu> SamB_XP: and I want "x" to print help and "pipe | x" to take stdin
19:33:03 <adu> just like grep
19:33:08 <SamB_XP> grep does that?
19:33:11 <mauke> grep doesn't do that
19:33:12 <adu> ya
19:33:13 <dmwit> grep does not do that
19:33:16 <mauke> oh wait, it does
19:33:23 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhIsTerminalDevice
19:33:26 <lambdac> http://tinyurl.com/y9dfge
19:33:28 <mauke> GNU grep 2.5.1
19:33:28 <dmwit> mauke: Give it a pattern.
19:33:31 <SamB> I never would have known grep did that if you hadn't told me
19:33:34 <adu> o wait
19:33:35 <Shiruka> grep doesn't do that
19:33:35 <edwardk> apply that to stdio it'll tell you if you're redirected
19:33:37 <SamB> well, it's possible I've seen it before
19:33:39 <adu> it does require a pattern...
19:33:40 <Shiruka> echo -n | grep prints help too
19:33:44 <dmwit> right
19:33:49 <SamB> oh, true
19:33:51 <Shiruka> so it just checks for empty input
19:33:56 <adu> oops
19:34:02 <SamB> % grep x
19:34:05 <edwardk> or at least if you're running on a tty. if you're on a tty print your banner or whatever
19:34:34 <SamB> ... just waits for input
19:34:35 <Shiruka> ... err, doesn't even check for empty input :-) just prints help if you give no parameters at all
19:34:56 <adu> do you wanna see what I have so far?
19:35:01 <SamB> it just, like a typical program, prints usage if it doesn't understand the parameters
19:35:28 <Shiruka> much more robust than trying anything magical
19:38:24 <Quadrescence> I'm not quite understanding the difference between type and data, except that data can make accessor functions.
19:38:42 <SamB_XP> Quadrescence: type makes synonyms for existing types!
19:39:03 <SamB_XP> Quadrescence: you're *supposed* to get newtype mixed with data, not type!
19:39:20 <Quadrescence> Haha
19:39:45 <Shiruka> newtype makes synonyms for types too, but it additionally plays a game of pretend
19:39:55 <Olathe> Type sticks pypers to the wall.
19:41:53 <Quadrescence> type Bark = [Int]; data Foob = MkFoob {accessorBazar :: Bark}; fooBarBaz = MkFoob [1,2,3]
19:41:56 <Quadrescence> Is this valid code?
19:42:18 <dibblego> yes
19:42:20 <Quadrescence> (you'd probably have multiple accessor functions, but still)
19:42:46 <Quadrescence> accessorBazar fooBarBaz == [1,2,3]
19:42:50 <Quadrescence> Right? :O
19:43:14 <dibblego> yes
19:43:29 <Quadrescence> (and if I wanted to actually test that, would I need `deriving Eq'?)
19:43:34 <tehgeekmeister> I'm getting the following error whenever I try to configure any cabal packages on my slicehost machine, any ideas what to do about it?  It seems it's a problem with 64 bit, but that's all I can tell.
19:43:37 <tehgeekmeister> ghc-6.8.2: internal error: R_X86_64_32S relocation out of range: (noname) = 0x7f7418fe54f8
19:43:44 <dibblego> no, [Int] has an instance of Eq
19:43:48 <Quadrescence> Okay
19:44:59 <Quadrescence> data >>Foob<< = >>MkFoob<< {accessorBazar :: Bark}
19:45:05 <Quadrescence> What are the proper names for those
19:45:08 <Quadrescence> ?*
19:45:08 <lambdac> Maybe you meant: . ? @ v
19:45:29 <stepcut> Foob is a type constructor, MkFoob is a data constructor
19:45:31 <stepcut> ?
19:45:34 <Quadrescence> Yeah
19:47:19 <gneek> Hey everyone... I just started learning Haskell and I was wondering what would be a good text editor I can use that would do syntax highlighting and stuff like that under Linux.
19:47:33 <Zao> I swear by vim, others by emacs.
19:47:43 <Zao> Some are even crazy enough to use Yi or hide.
19:47:46 <Quadrescence> gneek: I'm using Geany. I think it's pretty sexy.
19:47:54 <Olathe> ScITE, perhaps.
19:48:04 <adu> Zao: I know several devoted Notepad
19:48:14 <gneek> does anyone have a nanorc that would do that?
19:48:33 <Olathe> nano can do syntax highlighting ?
19:48:36 <gneek> yep
19:48:40 <Olathe> Ahh.
19:48:47 <jeffz> nano is a farce
19:49:03 <Quadrescence> Zao: I like typing my code up in Microsoft Word 2007. I can syntax highlight my own stuff, bold important things, etc. :D
19:49:16 <noohgodno> ;O
19:49:25 <ddarius> @hoogle Word12
19:49:26 <lambdac> A Hoogle error occured.
19:49:27 <Olathe> You can also insert spreadsheets directly into your source code.
19:49:32 <mmorrow> center justified FTW!
19:49:37 <Quadrescence> Olathe: I almost forgot!
19:49:53 <gneek> code makes more sense when you add clip art too
19:49:54 <noohgodno> i'm the only one who still likes csvs
19:50:04 <noohgodno> shoot me in the face
19:50:20 * Quadrescence gives a gun to gneek to shoot noohgodno in the face.
19:50:55 <mar77a> i write my code in paint
19:50:59 <mar77a> print it then scan it
19:51:07 <Quadrescence> mar77a: Okay, now that's just awful.
19:51:24 <Zao> Quadrescence: Time to hack GHC up to treat Word documents as literal Haskell then.
19:51:25 <gneek> some people use fridge magnets
19:51:37 <noohgodno> magnetic poetry haskell++
19:51:37 <Quadrescence> Zao: :D
19:52:00 <SamB_XP> noohgodno: what's csvs?
19:52:04 <mar77a> i can't wait to code with speech 2 text
19:52:15 <SamB_XP> oh, is that the plural CSV?
19:52:16 <noohgodno> i do my coding in ELIZA
19:52:22 <noohgodno> he tells me when i'm doing stuff wrong
19:52:35 <SamB_XP> noohgodno: have you ever gotten a program to run?
19:52:43 <noohgodno> any day now
19:54:05 * noohgodno is joking
19:54:50 <noohgodno> C# is the best language evar
19:54:53 <noohgodno> LOLOLOLOL
19:55:01 <adu> noohgodno:
19:55:12 * adu glares at noohgodno 
19:55:18 <noohgodno> o/' dowsing anemone in copper tongune o/
19:55:34 <Quadrescence> Woot woot, some of my haskell stuff is actually WORKING.
19:55:50 <Olathe> preflex: karma c
19:55:50 <preflex>  karma for c: 23178
19:55:50 <SamB_XP> noohgodno: yes, I was joking too
19:55:59 <Olathe> Heh.
19:56:09 <adu> Quadrescence: what kind of stuff?
19:56:14 <noohgodno> > cos 23178
19:56:16 <lambdac>  0.7834500608574244
19:56:22 <noohgodno> > acos 23178
19:56:24 <lambdac>  NaN
19:56:30 <noohgodno> INTERESTING
19:56:32 <SamB_XP> (about howt ELIZA doesn't make a good programming environment, since it never will actually run your program and always makes a smartass remark instead ;-)
19:56:45 <Quadrescence> adu: Right now, my factorial function, and a function which permutes a list based on its representation via factoradics.
19:57:03 <adu> Quadrescence: factoradics?
19:57:15 <noohgodno> factorama
19:57:34 <Quadrescence> adu: Factoradics are a way to index permutations in lexacographic order
19:57:59 <Quadrescence> So I can generate any permutation based on its index, and not have to generate any other permutation.
19:58:39 <adu> Quadrescence: ic, so 123 132 213 231 312 321?
19:58:40 <Quadrescence> (since there is a 1-to-1 mapping between permutation index and Z/(n!)Z, where n = number of elements in the list)
19:59:02 <adu> Quadrescence: I had some ideas about that myself
19:59:17 <noohgodno> > putStrLn "grrrrrrrrrr"
19:59:18 <lambdac>  <IO ()>
19:59:28 <shapr> lambdabot: @quote
19:59:33 <Quadrescence> adu: 123 312 312 132 231 321
19:59:41 <Quadrescence> oops, I typed that incorrectly
19:59:43 <Quadrescence> Whatev
20:00:13 <adu> Quadrescence: I defined a permutation index system based purely on adjacent permutations
20:00:34 <Quadrescence> I was thinking about that before I went to bed the other night.
20:00:40 <noohgodno> > square (sum [1..2])
20:00:41 <lambdac>   Not in scope: `square'
20:00:53 <noohgodno> you're not in scope
20:00:58 <noohgodno> this whole damn courtroom is not in scope
20:01:09 <Quadrescence> (sum [1..100])^2
20:01:13 <adu> Quadrescence: I found that there is usually more than one sequence of adjacent swaps that enumerate all permutations, and that at least one of them will be symetrical
20:01:26 <Quadrescence> > (sum [1..100])^2
20:01:27 <lambdac>  25502500
20:01:41 <adu> Quadrescence: like for 3 elements that sequence is [1,2,1,2,1]
20:01:44 <Olathe> > square (sum [1..2])
20:01:45 <lambdac>  9
20:01:52 <noohgodno> > (product [1..100])^5
20:01:53 <lambdac>  7079755728707197209563524890906349621072884213622342960172736380115627012105...
20:02:00 <noohgodno> > tail (product [1..100])^5
20:02:01 <lambdac>   add an instance declaration for (Num [a], Enum [a])
20:02:07 <adu> Quadrescence: for 4 elements that sequence is [1,2,1,2,1,3,2,1,2,1,2,3,1,2,1,2,1]
20:02:09 <noohgodno> how do you convert int to str
20:02:19 <dibblego> @type show
20:02:20 <dons> > show 72
20:02:22 <lambdac>  "72"
20:02:22 <lambdac> forall a. (Show a) => a -> String
20:02:35 <noohgodno> > tail (show (product [1..100])^5)
20:02:36 <lambdac>   add an instance declaration for (Num String)
20:02:47 <Quadrescence> adu: Hmm...
20:02:53 <noohgodno> > tail $ show (product [1..100])^5
20:02:54 <lambdac>   add an instance declaration for (Num String)
20:02:57 <noohgodno> gfy
20:03:11 <noohgodno> haskell is hard
20:03:20 <adu> Quadrescence: and I was always fascinated by the process of "generating" such a symetric permutation enumeration sequence
20:03:41 <adu> Quadrescence: in general its very hard to not duplicate previous permutations
20:04:09 <stulli> > tail $ show $ (product [1..100])^5
20:04:10 <lambdac>  "079755728707197209563524890906349621072884213622342960172736380115627012105...
20:04:10 <adu> Quadrescence: basically, I never found one for 6-elements
20:04:13 <Quadrescence> adu: You should look up factoradics. They are kind of like normal numbers: 123 = 1*10^2 + 2*10^1 + 3*10^0
20:04:24 <Quadrescence> But instead of 10^n, you use n!
20:04:37 <adu> Quadrescence: ew gross
20:05:37 <Quadrescence> So any permutation of size n can be represented by a*n! + b*(n-1)! + ... + c*2! + d*1! + e*0!
20:06:05 <adu> Quadrescence: oic
20:06:17 <lispy> Where I can I see the useful things defined on Either?  I looked here but it's not much: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
20:06:20 <lambdac> http://tinyurl.com/wtlo6
20:06:31 <Quadrescence> The constants a, b... etc are found basically by counting how many elements to the left of a certain element in a list are larger
20:06:40 <lispy> ?index fromRight
20:06:41 <lambdac> bzzt
20:06:47 <lispy> ?hoogle fromRight
20:06:47 <lambdac> A Hoogle error occured.
20:07:07 <adu> @seen hoogle
20:07:08 <lambdac> I haven't seen hoogle.
20:07:20 <heatsink> lispy: There's that, and Control.Monad.Either
20:07:55 <noohgodno> > foldl (^2) 0 [1..100]
20:07:56 <lambdac>      Occurs check: cannot construct the infinite type: a = b -> a
20:07:57 <lambdac>     Probabl...
20:08:15 <Olathe> Probabl not
20:08:20 <lispy> > do x <- Right 1; return x
20:08:21 <noohgodno> > foldl (*) 0 [1..100]
20:08:22 <lambdac>  Add a type signature
20:08:23 <lambdac>  0
20:08:28 <noohgodno> > foldl (*) 5 [1..100]
20:08:29 <lambdac>  4666310772197207634084961942813335024535798413219081073429648194760879999661...
20:08:30 <lispy> > do x <- Right 1; return x :: Either Int Int
20:08:31 <lambdac>   add an instance declaration for (Error Int)
20:08:31 <lambdac>     In the expression: return x...
20:09:04 <heatsink> > do x <- Right 1; return x :: Either String Int
20:09:05 <lambdac>  Right 1
20:09:09 <noohgodno> > filter Char.isUpper " do x <- Right 1; return x :: Either Int Int"
20:09:12 <lambdac>   Not in scope: `Char.isUpper'
20:09:15 <lispy> heatsink: I don't want to use String, thouh
20:09:23 <noohgodno> > filter Char.isLower " do x <- Right 1; return x :: Either Int Int"
20:09:24 <lambdac>   Not in scope: `Char.isLower'
20:09:30 <heatsink> lispy, What do you want to use?
20:09:31 <Olathe> > foldl (\a b -> a + b^2) 0 [1..100]
20:09:32 <lambdac>  338350
20:09:42 <heatsink> > isLower 'a'
20:09:43 <Quadrescence> :t mapM_
20:09:43 <lambdac>  True
20:09:45 <lambdac> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:09:53 <lispy> heatsink: Either ((FL p :> FL p) x y) ((FL p :> FL p) y x)
20:09:55 <heatsink> noohgodno, you can use isLower
20:10:03 <noohgodno> > filter isLower " do x <- Right 1; return x :: Either Int Int"
20:10:04 <lambdac>  "doxightreturnxitherntnt"
20:10:09 <noohgodno> yay
20:10:51 <heatsink> lispy, the Either monad is defined so that "Left" values are error messages and "Right" values are normal returns.  It doesn't look like you want Either.
20:11:16 <lispy> heatsink: Well, I do want the structure of either.
20:11:25 <heatsink> e.g. for strings,  fail s = Left s; return x = Right x
20:11:40 <noohgodno> map char.toUpper "uhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuh"
20:11:40 <lispy> data Option a b = Option1 a | Option2 b -- this is really the structure I need
20:11:43 <noohgodno> > map char.toUpper "uhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuh"
20:11:45 <lambdac>  Couldn't match expected type `Char' against inferred type `[Char]'
20:11:58 <noohgodno> > map Char.toUpper "uhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuh"
20:11:58 <lambdac>   Not in scope: `Char.toUpper'
20:12:04 <noohgodno> > map toUpper "uhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuhuh"
20:12:06 <lambdac>  "UHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUHUH"
20:12:11 <noohgodno> that's better
20:12:17 <lispy> heatsink: So...knowing that the monad instance would 'fail' me.  I was hoping we had combinators defined for Data.Either, but it seems we don't.
20:12:28 <lispy> heatsink: at least, the haddocks don't mention anything except either
20:12:37 <Quadrescence> Does GHC recompile unnecessarily?
20:12:42 <Quadrescence> It seems not to.
20:12:47 <Quadrescence> (which is good)
20:12:51 <lispy> Quadrescence: it's pretty smart
20:14:14 <noohgodno> > :t "Quadrescence"
20:14:15 <lambdac>   parse error on input `:'
20:14:20 <noohgodno> :t "Quadrescence"
20:14:20 <heatsink> noohgodno, please talk privately to lambdac to avoid cluttering the channel
20:14:22 <lambdac> [Char]
20:14:35 <noohgodno> get it? he's a character
20:14:36 <lispy> is lambdac identified?
20:15:13 <lispy> oh okay, lambdac is idented so /msg should work
20:15:49 <Quadrescence> noohgodno: I actually have multiple personalities, i.e. characters.
20:16:06 <Quadrescence> All which can be Ord'd, Enum'd, etc.
20:16:17 <Quadrescence> :}
20:16:19 <koninkje> > succ Quadrescence
20:16:20 <lambdac>   Not in scope: data constructor `Quadrescence'
20:16:30 <Quadrescence> koninkje: No one succeeds me.
20:16:49 <koninkje> so there's no instance Enum Quadrescence ?
20:17:07 <Quadrescence> There is. I'm just the highest.
20:17:20 <koninkje> > pred Quadrescence
20:17:21 <lambdac>   Not in scope: data constructor `Quadrescence'
20:17:38 <Quadrescence> That's lambdac not knowing what's good for him.
20:17:59 <noohgodno> :t (\(x :: Int) -> x*x)
20:18:00 <lambdac> Int -> Int
20:22:55 <gwern> Zao: so how goes xtris?
20:25:09 <mmorrow> cool! http://conal.net/Pan/Gallery/
20:25:10 <lambdac> Title: Gallery
20:25:20 <mmorrow> (especially the animations at the bottom)
20:25:54 <mmorrow> my new wallpaper (i'll probably have a seizure any minute now) http://conal.net/Pan/Gallery/intro/medres/neal%20tiled.jpg
20:26:24 <mmorrow> http://conal.net/Pan/Gallery/intro/medres/neal.jpg
20:26:45 <Zao> gwern: Not at all, too much other things on my table.
20:26:58 <gwern> ah.
20:27:03 * gwern is curious what
20:27:16 <gwern> Zao: you know I shall bug you ever more until I have sauce
20:29:52 <Zao> Assorted non-haskell coding, being a lazy person in general.
20:30:01 <Zao> And yeah, root disks exploding one after one.
20:39:23 <dsrogers> is there some way to use ghc --make from within a make file, but teach the makefile what the source dependencies that ghc --make can discover, so that I could put those source dependencies in the dependency list of the target that calls ghc --make?
20:40:23 <Shiruka> looking at ghc --help, maybe -M is what you want
20:40:37 <Shiruka> -M              Output Makefile rules recording the dependencies of a list of Haskell files.
20:42:17 <dsrogers> indeed, that that's only useful if you are using seperate compilation
20:42:28 <dsrogers> I want to use ghc --make which is quite a bit faster.
20:44:26 <mjrosenb> in ghc-6.6, is there any library that has the intercalate function defined?
20:44:49 <mmorrow> dsrogers: this gives you an idea:
20:45:01 <mmorrow> nm Main | cut -d' ' -f3 | grep -E "^[a-z]+_.+(info|closure)$" | cut -d_ -f1 | sort -u
20:45:25 <mmorrow> just need to un-zencode
20:45:43 <mmorrow> and maybe test that list against known packages or something
20:46:07 <Shiruka> looks like it just adds dependencies to a makefile without any actions, couldn't you just put the top-level files in the dependencies of a rule which calls ghc --make
20:46:08 <vixey> what's the shortest possible program that does CPS transformation?
20:46:50 <lispy> I need a lolcat for "Polymorphic cat is less polymorphic than expected."
20:46:53 <dsrogers> Shiruka: yes!  but I want ghc to tell me what those sources are.
20:47:07 <dsrogers> because I'm lazy
20:47:16 <Shiruka> ah, you want it to tell you the list of top-level files too :-)
20:47:19 <mjrosenb> nobody happens to know?
20:47:36 <lispy> dsrogers: not sure if I'm following you, but ghc can generate the dependencies iirc
20:47:53 <dsrogers> lispy: look up
20:48:42 <lispy> dsrogers: yeah, I think ghc can do that
20:48:57 <dsrogers> do you know how?
20:49:06 <dsrogers> the closest I could get is ghc -M which is not what I want.
20:49:12 <lispy> I'm trying to figure out
20:49:27 <lispy> I think there is a way to make a .dependencies or something, is that what -M is doing?
20:49:37 <dsrogers> mmorrow
20:49:44 <lispy> oh, .depend is the file
20:49:48 <dsrogers> mmorrow's script works, but it's awkward.
20:50:01 <Cale> lispy: perhaps a cat which tried to fit through something and got stuck
20:50:02 <dsrogers> no, -M actually modifies your makefile
20:50:39 <Shiruka> you could parse the makefile to find the dependency roots :-P
20:50:41 <mmorrow> agh, computer died
20:50:42 <lispy> dsrogers: darcs has a .depend target in the makefile
20:50:58 <lispy> .depend:	$(DARCS_FILES) $(UNIT_FILES) @$(GHC) $(GHCFLAGS) -M -optdep-f -optdep.depend $^
20:51:09 <lispy> that didn't paste right
20:51:20 <lispy> @$(GHC) $(GHCFLAGS) -M -optdep-f -optdep.depend
20:51:20 <lambdac> Unknown command, try @list
20:51:25 <mmorrow> dsrogers: of course, doing the nm thing requires you to _already have _ an executable...
20:51:34 <mmorrow> so i dunno if that does anything for you
20:52:01 <lispy> dsrogers: I'd look at this for an example: http://darcs.net/GNUmakefile
20:52:04 <dsrogers> oh, but before you have the executable you need to compile everything anyway.
20:52:11 <lispy> dsrogers: I'd poke around more but Iwant to work on other stuff :)
20:52:17 <mmorrow> yeah
20:52:35 <Quadrescence> How do you replicate values in a list again? e.g., [0,0,0,0,0]
20:52:42 <lispy> Cale: Mostly I'm just sick of that error message.
20:53:03 <mmorrow> i guess it'd only be useful if, say, you wanted to generate a makefile that uses  "-package ... -package ..." from an already-existing executable built with --make
20:53:09 <lispy> Cale: polymorphic cat is less polymorphic than expected could be a cat that is caught in a dog costum
20:53:28 <dsrogers> lispy: yeah, that's great for seperate compilation but doesn't with with --make, though I could parse that file for .hs files and use that as my sources list
20:53:56 <lispy> dsrogers: does the GHC API give you access to what you want?
20:54:06 <dino-> With cabal, is there a way to supporty more than one data-dir. Or possibly hierarchies in the data dir?
20:54:07 <Cale> lispy: hehehe
20:54:20 <dsrogers> there is an api?
20:54:29 <lispy> dsrogers: well...
20:54:37 <lispy> dsrogers: it's for parsing and introspection
20:54:37 <Cale> lispy: usually that error message can be fixed by commenting out the type signature you gave
20:55:03 <mmorrow> dsroger: be warned that if you link to it in an executable, it'll be 20M+ min unstripped, and ~13M stripped ...
20:55:15 <lispy> Cale: For me it usually happens when I open up a constructor that has an existential type inside and then try to return that type
20:55:21 <mmorrow> (it being the GHC API)
20:55:30 <lispy> Cale: which is something I only partially understand.
20:55:31 <dsrogers> haskell is not one for dynamic libraries, is it?
20:55:35 <Cale> lispy: ah, yeah, well, you obviously don't want to do that :)
20:55:47 <lispy> Cale: I get that that's a bad thing.  But, I don't understand the polymorphic aspect fully
20:55:55 <lispy> Cale: right, the code is wrong.
20:56:06 <Cale> mm... I'm not sure why it would report that error for that actually
20:56:09 <mmorrow> dsrogers: heh, i believe it's "in the works" to some extent or another
20:56:12 <vixey> A cat trying to hide but it is obviously not camouflaged
20:56:47 <lispy> Cale: I think it's because Sealed a -> a x, must be forall a. Sealed a -> (forall x. a x)
20:57:39 <lispy> Cale: which, if i understand the rank-n polymorphism stuff is some sort of mistake?
20:57:58 <vixey> grr
20:58:04 <mmorrow> lispy: what is your relation to darcs?
20:58:13 * vixey wants to ask somebody that knows maude something
20:58:16 <lispy> Cale: does that make anysense? BTW, I'm assuming data Sealed a where Sealed :: a x -> Sealed a
20:58:17 <vixey> (the language)
20:58:30 <Cale> lispy: mm... I don't know yet :)
20:58:34 <lispy> mmorrow: i'm a dev and a graduate student trying to improve it :)
20:58:34 <Cale> lispy: ah
20:58:55 <mmorrow> lispy: cool
20:59:02 <mmorrow> :)
20:59:11 <Cale> lispy: Then you can't return that value of type a x, you will have to, well, do something to replace x by something else without any knowledge of what x is
20:59:17 <Cale> fmap (const ()) would do
20:59:22 <Cale> If a is a Functor
20:59:54 <lispy> Cale: So, usually when this happens I have to investigate why that type is trying to escape, and then either Seal it, or rewrite the code to avoid the situation.
20:59:56 <Cale> So you could write  Sealed a -> a ()
21:00:28 <lispy> Usually () won't unify agaist the other uses of the type in the program
21:00:48 <lispy> Cale: you have to remember, that we use the phantom types as the pre and post context of the patches...
21:00:57 <lispy> Cale: very similar to domain/range of functions but not quite
21:02:09 <dmwit> "No known Haskell compiler actually parses this correctly."  heh
21:02:22 <Cale> dmwit: What expression/declaration?
21:02:29 <dmwit> http://hackage.haskell.org/trac/haskell-prime/wiki/FixityResolution
21:02:31 <lambdac> Title: FixityResolution - Haskell Prime - Trac, http://tinyurl.com/57eujr
21:03:02 <dmwit> "\x -> x == x == True" should parse as "(\x -> x == x) == True", then throw a type-checking error.
21:03:30 <lispy> mmorrow: I'm currently trying to convert all the code that deals with patches to code that deals with them in type safe ways.  So, that if you have them in a sequencs and you take a subsequencs or permute them or apply them to a repository that all the patches are in their right context.
21:04:29 <lispy> mmorrow: this makes it safer for humans to refactor the source code because the compiler can check more of it for them
21:04:55 <Cale> dmwit: oh, interesting
21:05:11 <mmorrow> lispy: interesting
21:05:19 <Cale> dmwit: Probably because of the way that operator precedence is handled
21:05:29 <dmwit> Cale: exactly
21:05:39 <mmorrow> lispy: i've been meaning to look at the darcs src for a while now
21:05:40 <lispy> > \x -> x == x == True
21:05:41 <lambdac>      precedence parsing error
21:05:41 <lambdac>         cannot mix `(==)' [infix 4] and `(==)' ...
21:05:48 <dmwit> Cale: It actually also interacts with the maximal munch rule  in a strange way, apparently.
21:05:53 * mmorrow does darcs get --partial http://darcs.net
21:05:54 <lambdac> Title: darcs
21:06:01 <lispy> mmorrow: now is a good time.  We have a lot of new people in #darcs this week asking questions
21:06:16 <mmorrow> ooh, #darcs...
21:06:22 <lispy> mmorrow: oh, that might fail.  darcs.net is in v2 format
21:06:38 <lispy> mmorrow: if you're still using --partial that makes me think you're on darcs1 client which doesn't grok v2 format
21:06:38 <Cale> dmwit: Well, yes. It shouldn't parse as \x -> (x == x == True), because x == x == True doesn't parse
21:06:45 <dmwit> right
21:06:48 <dsrogers> SOURCES := $(shell find . -name '*.hs') does it in a ad-hoc way.
21:06:57 <dsrogers> you may end up with false positives, but it's usually what you want.
21:07:00 <dmwit> nonassoc is weird
21:07:18 <Cale> But normally operator expressions get eaten all at once and then reshaped later.
21:07:21 <dsrogers> then just put $(SOURCES) as the dependencies of your target that contains ghc --make
21:07:28 <mmorrow> lispy: oh, i just typed that before i actually did it
21:07:31 <Cale> (at which point it's probably too late to reparse)
21:07:41 <mmorrow> should i use --lazy or just get the full repo?
21:07:47 <lispy> mmorrow: --lazy is good
21:07:55 <lispy> mmorrow: but make sure you have a darcs2 client
21:07:59 <mmorrow> oh
21:08:03 <lispy> mmorrow: if not, just grab the tarball of the website
21:08:23 <lispy> darcs1 client will error out on the darcs.net repo.
21:08:25 <mmorrow> 1.0.9 (release)
21:08:34 * mmorrow grabs the tarball
21:08:50 <lispy> then once you have the tarball you can get the HEAD with it
21:08:56 <mmorrow> cool
21:10:42 <Quadrescence> :t inits
21:10:44 <lambdac> forall a. [a] -> [[a]]
21:11:13 <Quadrescence> > inits [1,2,3]
21:11:14 <lambdac>  [[],[1],[1,2],[1,2,3]]
21:11:33 <tehgeekmeister> I'm unable to build any cabal packages on my slicehost instance, i keep getting this error, does anyone have any suggestions?  All I find on google is a similar report of trouble on freebsd (it's only on 64 bit systems), but I don't find any solutions.  Here's the error:
21:11:38 <tehgeekmeister> ghc-6.8.2: internal error: R_X86_64_32S relocation out of range:
21:12:00 <dsrogers> ooo, that's not a good one.
21:12:25 <tehgeekmeister> i'm using the standard ubuntu 64 bit ghc package
21:13:34 <dsrogers> i know absolutely nothing about the internals of the ghc linker.  My guess is that an internal link edit barfed on a large offset.
21:13:51 <bos> that's a perfectly normal thing.
21:14:01 <tehgeekmeister> that seems reasonable to me, and matches up with the descriptions i found online, but now i need to know what to do about it.
21:14:14 <bos> it's code that you're trying to compile into a shared object, which you've compiled without -fpic.
21:14:39 <dmwit> WHAT
21:14:50 <lispy> and if anyone here knows real-world haskell it's bos ;)
21:14:52 <dmwit> They rejected the "make ($) left-assoc" proposal?!
21:14:53 <bos> 99% of the time, that's what causes that error.
21:14:54 <dsrogers> oh, that would make sense.
21:15:16 <tehgeekmeister> bos: i don't understand that.  i'm just typing runhaskell Setup.hs configure.  do I add an extra argument to that?
21:15:20 <mmorrow> lispy: i got a warning the System.Cmd () is used but doesn't import anything, then the build failed since -Werror is used...(fyi)....
21:15:30 <bos> tehgeekmeister: hmm.
21:15:30 <mmorrow> i just cat GNUmakefile | sed -r 's/-Werror//g' > a
21:15:35 <mmorrow> mv a GNUmakefile
21:15:36 <bos> tehgeekmeister: no, that's unlikely.
21:15:38 <mmorrow> ;)
21:15:38 <lispy> mmorrow: interesting
21:15:44 <lispy> mmorrow: that's the tarball?
21:15:49 <bos> tehgeekmeister: are you sure you're using a 64-bit toolchain on a 64-bit box?
21:15:53 <mmorrow> yeah, (not the stable one though)(
21:16:00 <mmorrow> http://darcs.net/darcs-2.0.2.tar.gz
21:16:06 <tehgeekmeister> bos: i just used apt to install ghc
21:16:21 <mmorrow> err, the Latest Prerelease Source (2.0.2).  and  Latest Stable Source (2.0.2).
21:16:23 <bos> tehgeekmeister: what does "uname -a" report?
21:16:24 <tehgeekmeister> bos: i'm on ubunty 8.04, 64 bit
21:16:29 <mmorrow> appear to be the same
21:16:33 <dsrogers> woot!  that works like a charm.
21:16:36 <lispy> mmorrow: that's odd, given the buildbots and whatnot that we have.  But, hmm...you should be able to remove -Werror and ust run with it until you get the HEAD
21:16:49 <mmorrow> yeah, it's building now ...
21:17:00 <mmorrow> uhoh..
21:17:07 <bos> tehgeekmeister: hmm.
21:17:09 <mmorrow> (i'm using 6.9) got an error
21:17:20 <mmorrow>   (GHC version 6.9.20080504 for i386-unknown-linux):
21:17:20 <mmorrow>         RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
21:17:21 <Quadrescence> In which module is `inits'?
21:17:38 <lispy> mmorrow: oh, I bet no one tested on 6.9 yet.  I'm still doing my dev on 6.8.2 and I know droundy has 6.6.x
21:18:05 <mmorrow> lispy: i'll hpaste the full error
21:18:22 <luqui> Quadrescence, Data.List
21:18:32 <Quadrescence> luqui: Yep, thanks. :>
21:18:52 <lispy> mmorrow: it sounds suspiciously like a bug in a development version of the compiler :)
21:18:55 <tehgeekmeister> bos: I should clarify that i've not seen any reason to expect I'm on a 64 bit system except that ubuntu automatically installed x86_64 ghc for me, which i can't imagine it doing unless it were 64 bit ubuntu
21:19:11 <lispy> mmorrow: I mean, I don't know why our code would cause that error...that's not a typical haskell error
21:19:30 <mmorrow> yeah, it looks like a ghc bug
21:19:56 <mmorrow> i did make -j10, maybe that had something to do with it?
21:20:02 * mmorrow tries just make
21:20:11 <mmorrow> lispy: http://hpaste.org/9531
21:20:29 <lispy> mmorrow: I'd try a 6.8 release if you can
21:20:57 * mmorrow builds with 6.8.3
21:21:11 <lispy> mmorrow: oh that was in SHA1?
21:21:14 <Trinithis> Are there any queue libraries out there?
21:21:16 <lispy> might be some FFI code in there
21:21:38 <Quadrescence> How do I do basic error checking? (for example, if an input is < 0, I want to return an error)
21:21:55 <Quadrescence> s/an input/a parameter to a function
21:22:07 <lispy> foo x | x < 0 = error "On noes!"
21:22:07 <Trinithis> if x == 0 then error "bad" else good
21:22:29 <Quadrescence> Does error have some sort of type I need to know of??
21:22:35 <Trinithis> :t error
21:22:35 <lispy> :t error
21:22:38 <lambdac> forall a. [Char] -> a
21:22:38 <lambdac> forall a. [Char] -> a
21:22:47 <Quadrescence> V_V I should have done that.
21:22:48 <Quadrescence> Thanks.
21:22:53 <lispy> np
21:22:55 <mmorrow> lispy: yeah, SHA1 http://hpaste.org/9531#a1  (this is clearer (using only make with 1 thread))
21:24:03 <lispy> mmorrow: Interesting.  That code in SHA1 is highly optimized at a low level.
21:24:17 <lispy> mmorrow: using -fregs-graph
21:24:19 <lispy> er
21:24:21 <lispy> using that might help
21:24:43 <luqui> Trinithis, Data.Seq is a good queue
21:24:48 <luqui> er, Data.Sequence
21:24:53 <Trinithis> ok
21:25:06 <mmorrow> oh, i took that to be some sort of debugging aid instead of a way around the problem
21:25:18 <lispy> mmorrow: I don't know what that is
21:25:34 <mmorrow> either way, building with 6.8.3 is coming along nicely :)
21:25:38 <lispy> mmorrow: I'm going to go back to debugging some type errors.  I'm in #darcs if you have any more questions though.
21:25:49 <mmorrow> for sure, thanks.
21:25:54 <lispy> you're welocem!
21:25:56 <lispy> welcome*
21:26:00 <Quadrescence> > [1,2,3,4] == [1,2,3,4]
21:26:01 <lambdac>  True
21:26:04 <Quadrescence> > [1,2,3,4] == [1,3,2,4]
21:26:06 <lambdac>  False
21:26:52 <luqui> @bot
21:26:52 <lambdac> :)
21:26:55 <Quadrescence> ?hoogle a -> a -> Bool
21:26:56 <lambdac> A Hoogle error occured.
21:27:00 <Trinithis> luqui: Do you know what the View constructors are?
21:27:00 <Quadrescence> ~_~
21:27:21 <Trinithis> or rather how to use them?
21:27:21 <luqui> Trinithis, yeah.  they give you a way to look at the first element together with the remainder of the sequence.
21:27:41 <Trinithis> So I should use those for access?
21:28:05 <luqui> case viewl seq of EmptyL -> ...; a :< as -> ....
21:28:21 <tehgeekmeister> bos: uname confirms i'm on 64 bit; sorry, this is a new virtual server i'm using, hence not knowing what exactly it is yet.
21:28:21 <Trinithis> Oh I see
21:28:21 <luqui> lets you use it as a "bidirectional list"...
21:28:29 <vixey> oh
21:28:40 <vixey> can you write (-> x :< xs) = ... in 6.9?
21:28:51 <bos> tehgeekmeister: then maybe try turning cabal's verbosity way up.
21:28:54 <luqui> you mean (viewl -> x :< xs)
21:28:58 <vixey> no
21:29:07 <mar77a> > 'Z':'a':'o':[]
21:29:08 <lambdac>  "Zao"
21:29:08 <luqui> how would it know what view function to use?
21:29:37 <vixey> what's the view for nil?
21:29:37 <tehgeekmeister> bos: how do i do that?  i'm barely familiar with cabal at all, i just read the documentation today to find out about runhaskell Setup configure
21:29:38 <vixey> []
21:29:39 <Quadrescence> I installed hoogle. How do I use it in GHCi?
21:29:56 <luqui> vixey, well, that *is* nil, not the view for it
21:30:01 <bos> tehgeekmeister: runhaskell Setup build -v 3, perhaps
21:30:12 <luqui> (I like the view thing, but I too wish it were a little more... polymorphic?)
21:30:15 <vixey> what's the view for the [] of a sequence
21:30:20 <dainanak> why is this invalid syntax? : [1,2,4,6] >>= return (+1)
21:30:25 <luqui> as in I could exchange constructors and views without my clients knowing
21:30:29 <tehgeekmeister> bos: fails with the same error, different memory address.
21:30:35 <dainanak> compared to : [1,2,4,6] >>= (\x -> return (x+1))
21:30:46 <bos> tehgeekmeister: no more verbose?
21:30:51 <luqui> vixey, I don't know what you mean, what the view is for that.  EmptyL or EmptyR, depending on whether you use viewl or viewr
21:30:52 <tehgeekmeister> bos: not at all.
21:31:02 <vixey> this sucks
21:31:10 <vixey> (-> x :< xs) doesn't work
21:31:19 <luqui> vixey, what should it do!?
21:31:19 <tehgeekmeister> the rest of the error is just ghc version info and instruction to report the bug to ghc
21:31:31 <vixey> it should be the same as (viewl -> x :< xs)
21:31:41 <luqui> vixey, where did it get "viewl"?
21:31:47 <vixey> typeclass dispatch
21:32:17 <bos> tehgeekmeister: runghc Setup build -v3 (it's picky about spaces, huh.)
21:32:22 <luqui> class SeqView a where v :: Seq b -> a b
21:32:28 <luqui> (v -> x :< xs)
21:32:30 <luqui> not so bad is it?
21:32:32 <vixey> no luqui
21:32:35 <vixey> I meant
21:32:38 <vixey> (-> x :< xs)
21:32:43 <vixey> without viewl or v
21:32:46 * luqui knows
21:33:00 <tehgeekmeister> bos: same again.
21:33:09 <luqui> but that would require some more built in magic
21:33:13 <luqui> whereas the v thing is transparent...
21:33:15 <bos> tehgeekmeister: ok, runghc Setup clean
21:33:25 <bos> tehgeekmeister: then runghc Setup configure
21:33:32 <bos> tehgeekmeister: then runghc Setup build -v3
21:33:51 <tehgeekmeister> bos: it fails even on clean.
21:34:10 <tehgeekmeister> just checked, it fails opening ghci
21:34:16 <tehgeekmeister> my ghc is bad.
21:34:27 <luqui> vixey, i.e. what should the "view' typeclass be called, how should it be used, should it have fundeps, what if associated types would have been better, ... etc?
21:34:41 <luqui> view patterns leave the important decisions to us, not to ghc
21:34:45 <bos> tehgeekmeister: oh!
21:35:08 <bos> tehgeekmeister: i didn't pick up that cabal itself was failing at everything.
21:35:09 <mmorrow> vixey, it seems to me after further thought that view patterns don't add anything new (am i wrong?), because ghc already has http://hpaste.org/9532
21:35:23 <vixey> mmorrow: I don't have HTTP access at the moment
21:35:38 <vixey> luqui: this is in the documention for views ...
21:35:45 <luqui> vixey, link?
21:35:56 <vixey> luqui: I don't have HTTP access at the moment
21:35:56 <mmorrow> i'll msg you a paste of that (5 lines) ...
21:36:06 <mmorrow>   | [] <- xs                = []
21:36:06 <mmorrow>   | [Nothing,Just ()] <- xs = xs
21:36:06 <mmorrow>   | (x:xs) <- tail xs       = xs++[x]
21:36:06 <mmorrow>   | otherwise               = xs
21:36:11 <mmorrow> crap, that didn't work
21:36:32 <luqui> mmorrow, yeah, it's true, it's just a little more syntax sugar.  don't care for them all that much...
21:36:36 <mmorrow> well, there it is ... i managed to botch the /mssg
21:36:56 <vixey> mmorrow: I think the point is that it lets you do more with TH
21:37:01 <vixey> i.e. bind variables
21:37:03 <mmorrow> vixey: (the first line of that was       "f xs")
21:37:51 <vixey> It's more subtle than syntax sugar because you can't currently puts guards on a patQ
21:37:56 <luqui> a "fake constructor" approach would have allowed more power.
21:38:28 <mmorrow> vixey: but since TH Pat syntax doesn't have a rep for view patterns _or_ generalized pattern guards, you can't construct such patterns with a quasiquoter in pattern context
21:39:07 <mmorrow> but it is definitely nice to have more than one way to do any one thing :)
21:39:45 <luqui> mmorrow, that sounds like perl blasphemy!
21:39:55 <mmorrow> hehe
21:40:29 <mmorrow> > ((*)=<<(+1))8
21:40:31 <lambdac>  72
21:40:34 <mmorrow> > ((*)`ap`(+1))8
21:40:35 <lambdac>  72
21:41:11 <mmorrow> > (join$ (*).(+1))8
21:41:12 <lambdac>  72
21:41:20 <mmorrow> luqui: ;)
21:41:53 <luqui> "evolution of a haskell programmer" gives a much bigger example of timtowdti in haskell
21:42:29 <mmorrow> luqui: ooh yeah, love that page
21:42:32 <tehgeekmeister> bos: back, laptop battery died, apparently was unplugged at the wall.
21:42:37 <dons> hey team, I've added a "Haskell success stories" section to the haskell.org front page, http://haskell.org/haskellwiki/Haskell
21:42:38 <lambdac> Title: Haskell - HaskellWiki
21:42:40 <dons> what do people think?
21:42:50 <dons> it's based on companies that appear at this year's CUFP.
21:42:59 <bos> cool.
21:43:17 <mmorrow> very cool
21:43:18 <dons> based on some feedback i got out in richland last week, bos.
21:43:20 <bos> i'd put the "who's using...?" at the top, though.
21:43:28 <dons> above Events?
21:43:38 <dons> yeah.
21:43:51 <bos> richland? pnal?
21:44:06 <Cale> I got another excited beginner we should be seeing here soon :) (totimkopf)
21:44:06 <dons> yup, they're using haskell, but the guys need more backup info to help spread the word
21:44:09 <mmorrow> yeah, it took me a second to find it
21:44:34 * dons likes having a wiki section named 'Success'
21:44:55 <mmorrow> heh
21:45:06 <dons> there we go, at the top now, under the prelude.
21:45:32 <dons> btw, Amgen appears new.
21:45:37 <dons> i don't think we knew they used haskell.
21:46:37 <bwr> I am trying to fit haskell in at work
21:46:42 <bos> that's cool. between ketil and amgen, we practically have biotech ripped from the hands of perl!
21:46:52 <mmorrow> perfect placement ... my eyes went from the "Haskell" right to "Who's using Haskell?"
21:47:05 <dons> mmorrow: great!
21:47:25 <bos> dons: credit suisse, too (augustss)
21:47:33 <dons> yeah, i could add last year's cufp people too
21:47:38 <bos> good idea.
21:47:43 <dons> CS, Galois, hmm. some others.
21:47:53 <bos> and don't forget CosmicRay's employers.
21:48:00 <dons> yes, we need to get them on the industry page.
21:48:15 <dons> i've added the industry page now, next to CUFP, the "Industry Wiki" link.
21:48:18 * Cale corrects the two typos
21:48:26 <dons> thanks, Cale.
21:48:27 <tehgeekmeister> bos: so, any suggestion where to look next?  bug report to the ghc team/ubuntu?  anything else i can try to fix it?
21:50:27 <bos> tehgeekmeister: what kind of file is /usr/bin/ghci, or the file it points to if it's a symlink?
21:50:39 <bos> tehgeekmeister: as in, what does "file" report on it?
21:52:48 <tehgeekmeister> bos: it's saying the file doesn't exist...
21:52:56 <Quadrescence> :t replicate
21:52:58 <lambdac> forall a. Int -> a -> [a]
21:53:10 <Quadrescence> > replicate 5 0
21:53:11 <lambdac>  [0,0,0,0,0]
21:53:14 <bos> tehgeekmeister: presumably /usr/bin/ghci exists, and is a symlink to something like ghci-6.8.3?
21:53:14 <Quadrescence> good work
21:53:29 <bos> tehgeekmeister: so what does "file /usr/bin/ghci-6.8.3" report?
21:53:37 <bos> or whatever the actual target is.
21:53:52 <tehgeekmeister> bos: nevermind, i misread something, it is a symlink
21:53:58 <tehgeekmeister> *chases symlinks
21:55:11 <tehgeekmeister> bos: posix shell script executable
21:56:08 <bos> tehgeekmeister: ok, cat the script, and it should tell you where the real ghc executable is.
21:56:17 <bos> it will say something like GHCBIN=/usr/libexec/ghc-6.8.3/ghc-6.8.3
21:56:31 <bos> then run file on whatever file GHCBIN is referring to.
21:56:49 <bos> i don't run ubuntu, so i'm having to do all of this at one step of remove.
21:57:04 <Quadrescence> w00t w00t more of my haskell code is working.
21:57:14 <tehgeekmeister> bos: okay, i'm using 6.8.2 because that's the most recent for 64 bit, apparently
21:57:42 <bos> tehgeekmeister: doesn't matter. what kind of file?
21:57:57 <tehgeekmeister> bos: /usr/lib/ghc-6.8.2/ghc-6.8.2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), for GNU/Linux 2.6.8, dynamically linked (uses shared libs), stripped
21:58:20 <bos> tehgeekmeister: huh. that file is of the correct type.
21:58:37 <bos> tehgeekmeister: the only other thing i can think of is that a shared library somewhere is of the wrong type.
21:58:59 <bos> tehgeekmeister: what happens if you just run "ghc" at the command line?
21:59:02 <bos> tehgeekmeister: same error?
21:59:09 <luqui> does strace get anywhere?
21:59:13 <tehgeekmeister> bos: uname -a says i've got kernel 2.6.24, could that be it?
21:59:17 <bos> tehgeekmeister: no
21:59:30 <tehgeekmeister> bos: ghc just complains about no input files
21:59:41 <bos> and ghci barfs if you try to run it?
21:59:46 <tehgeekmeister> yep
21:59:56 <bos> fascinating.
22:00:09 <bos> what does "ldd /usr/lib/ghc-6.8.2/ghc-6.8.2" report?
22:00:27 <hml> i'm running haskell emacs mode; i'm got c-c c-l running in a window taht is only 30 chars wide; is there a way that i can tell emacs to autowrap the lines? (instaead of displyaing a $ at the end of the line)
22:01:01 <TSC> hml: try M-x truncate-partial-width-windows
22:01:14 <tehgeekmeister> bos: it's about ten or so lines, should i pastebin it?
22:01:16 <TSC> Err
22:01:20 <bos> tehgeekmeister: sure
22:01:50 <TSC> hml: Rather, set that variable to nil
22:01:56 <TSC> e.g. (setq truncate-partial-width-windows nil)
22:02:16 <TSC> (or M-x set-variable)
22:02:58 <Quadrescence> ?hoogle a -> String
22:02:58 <lambdac> A Hoogle error occured.
22:03:16 <tehgeekmeister> bos: http://hpaste.org/9533
22:05:57 <bos> tehgeekmeister: hmm, those are all 64-bit shared objects.
22:06:26 <bos> tehgeekmeister: ok, next step. run "strace -o strace.out -s 128 ghci" and paste the contents of strace.out somewhere.
22:06:31 <ivanm> @users
22:06:31 <lambdac> Maximum users seen in #haskell: 551, currently: 441 (80.0%), active: 11 (2.5%)
22:06:41 <ddarius> 551?
22:06:44 <ivanm> hmmm... so why didn't lambdabot respond in #gentoo-haskell? :s
22:06:50 <bos> tehgeekmeister: oh, uh. add a "-f" to the strace flags.
22:07:25 <dons> 551!?
22:07:29 <bos> tehgeekmeister: do you by any chance have the environment variable LD_LIBRARY_PATH or LD_PRELOAD set?
22:07:31 <ivanm> oh, wait, that's lambdac ... not lambdabot...
22:07:33 * dons needs to order those interrobang tshirts.
22:07:48 <ivanm> who's running lambdac?
22:07:58 <ivanm> I note that it's another queenslander...
22:08:05 <dons> 507 is the max.
22:08:15 <TSC> Bloody banana-benders
22:08:44 <ivanm> heh
22:09:02 <ivanm> TSC: at least we keep our seasons in their right places!
22:10:18 <ddarius> What's a library that has very few and simple dependencies that has a Color type?
22:10:26 <tehgeekmeister> bos: http://hpaste.org/9534
22:10:26 <TSC> Can't even handle daylight saving
22:10:55 <ivanm> TSC: maybe because we don't really need it?
22:11:09 <ivanm> in summer with daylight saving, you get daylight till what, 9PM?
22:11:22 <TSC> The real problem is that it fades the curtains
22:11:25 <ivanm> it gets darker here faster than it does down there...
22:11:32 <Quadrescence> How can I produce a random list of n Ints?
22:11:32 <ivanm> TSC: no, no, no... it upsets the cows!
22:11:39 <bos> tehgeekmeister: that's truncated.
22:11:40 <ivanm> @hoogle randoms
22:11:41 <lambdac> A Hoogle error occured.
22:11:44 <ivanm> :o
22:11:46 <ivanm> @hoogle random
22:11:47 <lambdac> A Hoogle error occured.
22:11:52 <TSC> And it breaks solar power
22:11:54 <bos> tehgeekmeister: hpaste truncates at 5KB.
22:12:18 <tehgeekmeister> okay, posting it elsewhere where it won't truncate
22:12:19 <ivanm> TSC: how bout we bash sydneysiders now?
22:12:22 <hml> TSC: that was exactly waht i neeced; thanks
22:12:24 * ivanm looks purposefully at dons 
22:12:25 <ivanm> :p
22:12:28 <ddarius> Hmm.  Maybe I need to write a Graphics.Color or Data.Color.
22:12:35 <mmorrow> ddarius: what sort of operations on Colors do you require this lib to have?
22:12:46 <hml> in ghc, is there a way to call main with command line arguments?
22:12:51 <luqui> Quadrescence, see the "randoms" function from System.Random
22:12:58 <Quadrescence> luqui: fine.
22:13:02 <dogbite_> any idea why 'nub' performs much worse than using Data.Set's toList . fromList
22:13:11 <Quadrescence> luqui: Do you speak any other languages?
22:13:13 <luqui> (it produces an infinite list, and then take however many you need)
22:13:20 <ivanm> hml: getArgs IIRC
22:13:22 <luqui> Quadrescence, you mean human languages?
22:13:26 <Quadrescence> luqui: yes
22:13:27 <ivanm> @type getArgs
22:13:28 <Cale> dogbite_: The latter is O(n log n), nub is O(n^2)
22:13:29 <lambdac> Not in scope: `getArgs'
22:13:29 <TSC> dogbite_: nub is O(n^2), via sets it is O(n log n)
22:13:35 <Cale> dogbite_: But they're not doing the same thing
22:13:38 <luqui> Quadrescence, not to any degree of fluency...
22:13:40 <ddarius> mmorrow: The only thing I need is to be able to make one and print it out in a hexadecimal RGB(A) format, but I'd like the user to be able to manipulate them in a variety of manners.
22:13:41 <hml> ivanm: i misphrased my qujestioln
22:13:45 <Quadrescence> luqui: Aww, okay
22:14:01 <dogbite_> Cale: because the output isn't sorted?
22:14:02 <Cale> dogbite_: map head . group . sort  is faster than Data.Set
22:14:04 <hml> i know how to get arguments from main in haskell; however, i'm unit testing in ghci; is there a way in ghci, to call main with specific arguments (as if i'm calling it from the command line)
22:14:05 <Quadrescence> hml: You don't seem very concentrated. :)
22:14:05 <ddarius> I guess I could abstract from it and simple require something that instantiates a ColorLike class or some such.
22:14:12 <mmorrow> ddarius: cool. i have a Pixel module i'll paste fwiw
22:14:17 <Cale> dogbite_: nub doesn't use ordering at all, only equality testing
22:14:21 <hml> Quadrescence: lol why do you say this?
22:14:27 <tehgeekmeister> bos: http://thegeekmeister.livejournal.com/192715.html
22:14:32 <TSC> dogbite_: nub is lazier too
22:14:37 <Quadrescence> <hml> ivanm: i misphrased my qujestioln
22:14:44 <dogbite_> oh i thought nub returned a sorted result
22:14:45 <Quadrescence>  misphrased my qujestioln
22:14:45 <hml> Quadrescence: typos on kinesis ergo
22:14:49 <Quadrescence> my qujestioln
22:14:52 <Quadrescence> qujestioln
22:14:57 <Quadrescence> jestiol
22:15:01 <Quadrescence> :D
22:15:02 <bos> tehgeekmeister: oh!
22:15:12 <Cale> > nub [2,3,1,2,2,1,1,3]
22:15:13 <lambdac>  [2,3,1]
22:15:14 <bos> tehgeekmeister: what does "file /usr/lib/ghc-6.8.2/lib/base-3.0.1.0/HSbase-3.0.1.0.o" report?
22:15:51 <dogbite_> Cale: i stand corrected
22:15:57 <Cale> dogbite_: Of course, you can also do nub in O(n log n) without rearranging the items, but it requires an ordering.
22:16:01 <ddarius> A Data/Graphics.Color would be nice in general.
22:16:23 <luqui> Cale, is it as lazy as nub?
22:16:27 <Cale> luqui: yes
22:16:36 <ivanm> Quadrescence: if you wanted a sorted version, you might get better performance with this:
22:16:45 <luqui> Cale, of course!  just nub, but store the seen items in a set...
22:16:48 <ivanm> > map head . group . sort $ [2,3,1,2,2,1,3]
22:16:49 <lambdac>  [1,2,3]
22:16:51 <Cale> luqui: right
22:17:02 <dainanak> why doesn't this work? [1,2,4,6] >>= return (+1)
22:17:17 <lispy> :t return (+1)
22:17:19 <lambdac> forall a (m :: * -> *). (Monad m, Num a) => m (a -> a)
22:17:22 <bos> tehgeekmeister: there's something wrong with the way the object files used by ghci are built. they contain the wrong kinds of relocation directives.
22:17:30 <lispy> dainanak: ^^ wrong type
22:17:36 <bos> tehgeekmeister: so it's not your system in general, it's the ghc package.
22:17:45 <luqui> dainanak, return . (+1)
22:17:56 <bos> tehgeekmeister: seems like a bug in ubuntu.
22:18:05 <dainanak> lispy, i understand that it's the wrong type, but it seems as if it should be the same as [1,2,4,6] >>= (\x -> return (x+1))
22:18:08 <luqui> I see composition as a pipe.  Pipe each number through (+1) then through return
22:18:19 <lispy> dainanak: try ?pl
22:18:24 <lispy> ?pl \x -> retun (x+1)
22:18:25 <lambdac> retun . (1 +)
22:18:25 <tehgeekmeister> bos: so if i build ghc from source i might bypass this?
22:18:28 <luqui> @type \x -> return (x+1)
22:18:31 <lambdac> forall a (m :: * -> *). (Monad m, Num a) => a -> m a
22:18:35 <luqui> @type return (+1)
22:18:38 <lambdac> forall a (m :: * -> *). (Monad m, Num a) => m (a -> a)
22:18:41 <luqui> not the same :-)
22:18:43 <Cale> If you're going to write it with composition, use =<<
22:18:49 <bos> tehgeekmeister: yes. but building ghc from source is not always for the faint-hearted.
22:19:01 <Cale> return . (+1) =<< [1,2,4,6]
22:19:08 <Cale> But of course, that's the same as fmap
22:19:16 <bos> tehgeekmeister: quite often, a "./configure && make" is enough though.
22:19:16 <Cale> fmap (+1) [1,2,4,6]
22:19:55 <dainanak> right, I'm just trying to figure out the usage of the list monad
22:20:00 <tehgeekmeister> bos: well if it sticks to that simple i can do it.  i've just paid for three months of this virtual server at slicehost and i only wanted to use it for haskell/happs, so i'm really keen to get ghc working.
22:20:15 <dainanak> how can one view the type signature of a specific instance of a monad?
22:20:29 <luqui> > [1,2,3,4] >>= ((+1) >>> return)
22:20:31 <bos> tehgeekmeister: just grab ghc 6.8.3 source and extralibs tarballs, unpack, and away you go, then.
22:20:31 <lambdac>  [2,3,4,5]
22:20:46 <bos> tehgeekmeister: you'll need to keep the current ghc on your system until you've built the new one.
22:20:50 <dainanak> say, i wanted to use ghci to lookup >>= as defined for the list monad
22:20:56 <dainanak> how would i do so?
22:21:02 <bos> tehgeekmeister: oh, and expect the build to take *hours* on a vhost.
22:21:13 <bos> tehgeekmeister: how much memory does your host have?
22:21:25 <luqui> dainanak, you mean the source?
22:21:32 <Cale> dainanak: You would open a web browser and locate the prelude source, because ghci doesn't have that feature :)
22:21:50 <dainanak> not the source, just the type signature
22:21:55 <Cale> oh
22:21:56 <tehgeekmeister> bos: it's 256mb, with 2ghz allocated (but if the actual machine is underutilized i can burst to actual capacity)
22:21:56 <luqui> or use ghci on sterioids or whatever that's called...
22:22:00 <dainanak> for a specific instance
22:22:10 <tehgeekmeister> bos: anyway, i've done LFS before, so I can wait for compiles if need be.
22:22:13 <Draconx> :t (>>=)
22:22:15 <lispy> luqui: acid
22:22:16 <lambdac> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:22:18 <dainanak> ghci on acid?
22:22:31 <Draconx> substitute m with the instance you're interested in.
22:22:55 <bos> tehgeekmeister: you probably won't be able to build ghc with 256MB of memory.
22:22:59 <tehgeekmeister> bos: OH!  i can just restart with a different distro's image, i'll do that before i try to compile it.  slicehost has a few other distros i can switch to within a few minutes...
22:23:09 <bos> tehgeekmeister: try fedora 9 then.
22:23:28 <dainanak> :t (>>=)::(forall m :: ListM -> ListM)
22:23:30 <lambdac> parse error on input `::'
22:23:33 <dainanak> eh?
22:23:35 <bos> tehgeekmeister: or fedora 8, if they don't have 9 yet
22:23:37 <Quadrescence> > [1,2,3] + [4,5,6]
22:23:38 <lambdac>   add an instance declaration for (Num [t])
22:23:53 <Quadrescence> > zipWith (+) [1,2,3] [4,5,6]
22:23:54 <lambdac>  [5,7,9]
22:24:11 <dainanak> Draconx, i'm not sure exactly how you mean?
22:24:12 <mmorrow> ddarius: code.haskell.org/~morrow/code/haskell/misc/Pixel.hs
22:24:16 <tehgeekmeister> bos: okay, thanks
22:24:26 <lispy> I used to have a nice istance of Num t => Num [t], but it's not on the wiki anymore
22:25:04 <Draconx> dainanak, take "(Monad m) => m a -> (a -> m b) -> m b", substitute "m" with "list", and you get: "[a] -> (a -> [b]) -> [b]"
22:25:23 <mmorrow> ddarius: although, it may be not what you're looking for. i wrote it primarily for image manipulation stuff
22:25:32 <Quadrescence> I hope haskell has good garbage collection.
22:25:36 <tehgeekmeister> bos: and they do have fedora 9; is that what you're on?
22:25:51 <ddarius> mmorrow: Don't use unboxed fields, use strict fields and the unbox-strict-fields flag (or the UNPACK pragma)
22:26:03 <dainanak> Quadrescence, it does if you learn when and where to use strictness
22:26:10 <mmorrow> yeah, i learned that after i'd written that :)
22:26:14 <mmorrow> <ddarius> A Data/Graphics.Color would be nice in general
22:26:18 <mmorrow> most definitely
22:26:19 <bos> tehgeekmeister: yes. i also maintain the ghc package for fedora, so i can tell you that it works :-)
22:26:25 <Quadrescence> dainanak: uh oh.
22:26:35 <ddarius> mmorrow: I want something that's simple and portable and does things like interpolate between colors and convert from HSV/RGB(A)/Lab*/etc.
22:26:38 <tehgeekmeister> bos: okay, nice.
22:26:47 <Cale> GHC generally has good garbage collection, but of course it only collects garbage :)
22:26:50 <tehgeekmeister> well, i'm off for the night.
22:26:52 <tehgeekmeister> thanks for your help.
22:26:53 <mmorrow> ddarius: nice nice. that'd be great.
22:26:55 <dainanak> Quadrescence, it's usually not too bad depending on what you are doing
22:27:05 <Quadrescence> "not too bad"
22:27:06 <Quadrescence> :(
22:27:07 <Cale> If you hang on to large expressions, then no amount of GC will help :)
22:27:15 <tehgeekmeister> since i've got the generally more knowledgeable people around right now, actually, is hxt sufficiently lazy to use on really large files?  nearly four gigs?
22:27:53 <Cale> Quadrescence: It's quite good. Though you can't really say that "Haskell" has garbage collection at all, since it's only specified in terms of semantics, and not how to implement it :)
22:28:03 <luqui> Quadrescence, the problem with Haskell's GC is not haskell's gc, it's the subtlety in learning how to correctly program with laziness
22:28:10 <dainanak> Quadrescence, check out the real world haskell book chapters on strictness and efficiency if you're really worried about it on ghc
22:28:17 <bos> tehgeekmeister: hxt has a history of failing on even tiny files.
22:28:29 <Quadrescence> > replicate 3 "Thanks"
22:28:30 <lambdac>  ["Thanks","Thanks","Thanks"]
22:28:41 <Quadrescence> ;)
22:28:44 <tehgeekmeister> bos: okay, well i'll stick with hexpat, i guess, then.
22:28:46 <bos> tehgeekmeister: you should really use expat or libxml bindings if you need to mangle a large file.
22:28:53 <jeffz> tehgeekmeister: have you considered hxq?
22:29:01 <tehgeekmeister> jeffz: haven't heard of it?
22:29:28 <jeffz> tehgeekmeister: http://article.gmane.org/gmane.comp.lang.haskell.cafe/38991
22:29:29 <lambdac> Title: Gmane -- Mail To News And Back Again
22:29:29 <tehgeekmeister> bos: i started out with hexpat but thot it was an hexpat problem instead of a ghc problem when i tried to build it earlier today, but hexpat is pretty ideal for what i want.
22:29:50 <hml> is there a way; after a c-c c-l, in emacs haskell mode; to have emacs jum pme to the error line, kind of like c-n in vim?
22:29:58 <hml> i.e. i want to cycle through the line errors from c-c c-l
22:30:08 <tehgeekmeister> jeffz: hmm, thanks.  i'll look into that, too.
22:30:22 <dons> tehgeekmeister: were you working on the 4G xml file?
22:30:44 <tehgeekmeister> dons: yes, i'm grabbing all the article text from the french wikipeda dump.
22:31:18 <luqui> > "sept" ++ repeat "ember"
22:31:18 <lambdac>  Couldn't match expected type `Char' against inferred type `[Char]'
22:31:19 <dons> ah good. let us know how you go.
22:31:25 <luqui> > "sept" ++ concat (repeat "ember")
22:31:26 <lambdac>  "septemberemberemberemberemberemberemberemberemberemberemberemberemberembere...
22:31:47 <luqui> heheheh
22:31:49 <tehgeekmeister> i'll be posting it to my blog which goes to planet haskell once i get any progress.  :)
22:31:53 <luqui> > cycle "ginava"
22:31:54 <lambdac>  "ginavaginavaginavaginavaginavaginavaginavaginavaginavaginavaginavaginavagin...
22:31:59 <Quadrescence> :D
22:32:09 <tehgeekmeister> i'm off for now, however.  thanks for your help, guys.
22:32:33 <Quadrescence>  > "Forever, " ++ concat (repeat "and ever, ")
22:32:43 <Quadrescence> > "Forever, " ++ concat (repeat "and ever, ")
22:32:44 <lambdac>  "Forever, and ever, and ever, and ever, and ever, and ever, and ever, and ev...
22:32:49 <dainanak> i think my favorite funny thing that i've done with haskell was using System.Cmd to pass my 99 bottles of beer implementation to a screenreader
22:33:02 <dainanak> it sang the whole thing, and took about half an hour
22:33:07 <Quadrescence> Hahahahah
22:33:30 <lispy> heh
22:34:19 <dainanak> it's not portable though, it only works on macs
22:34:23 <dainanak> so far
22:34:28 <dainanak> >:)
22:34:48 <mmorrow> ddarius: "the" paper for image compositing http://code.haskell.org/~morrow/graphics/papers/p253-porter.pdf
22:34:53 <Quadrescence> I guess that exemplifies what mac users code, and what PC users code.
22:35:07 <dainanak> ha i do more useful things too
22:35:12 <Quadrescence> >;)
22:35:23 <dainanak> i have a all-haskell implentation of ls
22:35:29 <Quadrescence> Have your computer sing you to sleep too?
22:35:41 <dainanak> it's rather tone-deaf, sadly
22:35:59 <Quadrescence> I imagine Haskell as having a very boring voice.
22:36:13 <lispy> dainanak: maybe you could incorporate haskcore?
22:36:36 <lispy> dainanak: not sure I spelled it correctly, but the music writing haskell software
22:36:47 <dainanak> lispy, good thought, but i'd have to write some kind of mac screenreader - midi interface
22:37:05 <dainanak> that sounds a little painful given that it was just an hour project
22:37:06 <Cale> haskore
22:37:12 <dainanak> yeah
22:37:16 <mmorrow> ddarius: that paper is the one that coriginally ame up with the idea for an alpha channel
22:37:25 <mmorrow> s/coriginally/originally/
22:37:49 * luqui thinks Haskell's voice would be beautiful and have consistent pitch
22:38:17 <dainanak> it would be the purest voice in the land
22:38:33 <hml> hmm, how can i have this read n a list of int's
22:38:36 <hml> [read (args !! x) | x <- [0, 1]]
22:38:46 <hml> this doesn't really work since it has no idea the type of the read ...
22:39:00 <dainanak> ::Int
22:39:15 <dainanak> i think
22:39:25 <dainanak> i don't know where you'd stick it in there
22:42:47 <dainanak> if you are trying to read a list of ints, then that's only going to read the first two args
22:43:54 <mmorrow> ddarius: so a module calling itself Data.Graphics.Color should implement each of the compositing ops defined on pg.4 of that paper (imo) :)
22:44:48 <ddarius> mmorrow: In practice, that would be nice, but compositing /= color.
22:45:20 <luqui> ddarius, splain?
22:46:51 <luqui> is there any way to tell cabal-install to reinstall a package?
22:47:02 <luqui> (to update its deps)
22:49:20 <ddarius> There are multiple ways of interpreting the alpha channel, and the alpha channel is an adjunct onto color data anyway.  You can compose black and white pictures and you can talk about color in contexts where compositing is irrelevant.
22:49:41 <dsrogers> what does the "forall" type mean?
22:50:36 <luqui> dsrogers, it means you can fill in any type there and it will work on that type
22:50:50 <luqui> forall a. a -> [a], means you can fill in eg. Int and have Int -> [Int]
22:51:01 <mmorrow> ddarius: true, but compositing is an (bi)linear map of colors. transforming from one colorspace to another in a linear map between those two vector spaces. so, compositing isn't *that* far removed from e.g. rgb->hsv
22:51:22 <dainanak> luqui, why is that useful?
22:51:52 <mmorrow> (i'm equating colors with vectors in their containing colorspace viewed as a real vector space)
22:51:52 <luqui> dainanak, it means you don't have to write a version of your function for every single type, just write it once and it works on all types (that are compatible)
22:52:24 <luqui> dainanak, for example, singleton x = [x].   You wouldn't want to write singletonInt x = [x], singletonFloat x = [x], singletonListOfInt x = [x]
22:52:38 <dsrogers> so in TH, and the ForallT, what is the context?
22:52:40 <dainanak> isn't that possible just by annotating something with a type signiture of foo :: a -> [a]?
22:52:46 <mmorrow> ddarius: but of course, you're actually writing it, so.. :)
22:52:51 <dsrogers> forall <vars>. <ctxt> -> <type>  is the comment.
22:52:59 <luqui> dainanak, ah, yes, foo :: a -> [a] is shorthand for foo :: forall a. a -> [a]
22:53:18 <dsrogers> oh.
22:53:22 <dainanak> i see, so it's just a sugar thing
22:53:26 <dsrogers> luqui: you just answered my question!
22:53:27 <dsrogers> yaya
22:53:29 <luqui> dainanak, there are more advanced uses that you can't use the shorthand for, for example:  (forall a. a -> [a]) -> (x,y) -> ([x],[y])
22:53:42 <luqui> dsrogers, =P
22:53:57 <mmorrow> dsrogers: ooh, TH
22:53:59 <dsrogers> so forall is the fundamental way in which you specify a template function.
22:54:35 <dsrogers> thus all template functions have a type that, in TH would be represented with ForallT, correct?
22:55:55 <mmorrow> dsroger:
22:56:00 <mmorrow> ghci> putStrLn . pprint =<< runQ [t|forall b. (forall a. a -> b) -> b|]
22:56:00 <mmorrow> forall b_0 . (forall a_1 . a_1 -> b_0) -> b_0
22:56:27 <mmorrow> whic is
22:56:28 <mmorrow> ForallT [b_5] [] (AppT (AppT ArrowT (ForallT [a_6] [] (AppT (AppT ArrowT (VarT a_6)) (VarT b_5)))) (VarT b_5))
22:56:52 <mmorrow> (which you can see with:     runQ [t|forall b. (forall a. a -> b) -> b|]       )
22:57:21 <ddarius> mmorrow: As I said originally, all I need for what I'm doing right now is something that allows you to make colors and display them in hex strings.
22:57:40 <mmorrow> ddarius: heh, i tend to get carried away easily
22:58:10 <mmorrow> (and have a particular interest in image manipulation stuff)
22:58:46 <dsrogers> mmorrow: is that another way of writing the type for "(a->b)->b" where a and b are unconstrained?
22:59:14 <ddarius> I was simply saying it would be nice if I could use a "standard" Color type so that users could use my library readily from whatever else they are using and without having to learn yet another Color API.
22:59:26 <mmorrow> actually, that would be     (forall asdf. a -> asdf) -> b     (ie it's a coincidence that the b's are the same there)
22:59:34 <mmorrow> so maybe a bad example..
22:59:50 <mmorrow> ghci> runQ [t|forall a. a -> a|]
22:59:50 <mmorrow> ForallT [a_7] [] (AppT (AppT ArrowT (VarT a_7)) (VarT a_7))
22:59:59 <mmorrow> that's      a -> a
23:00:28 <mmorrow> but you need to either have the type var a in scope *outside* of the quote, or you need to forall it
23:01:47 <mmorrow> ddarius: that's a good idea. and upon further consideration i agree that my suggestions were overkill for such a thing.
23:02:22 <luqui> ddarius, you know a good way to have a standard color type?
23:02:27 <luqui> ddarius, make it! :-)
23:02:35 <hml> @src liftM
23:02:35 <lambdac> liftM f m1 = do { x1 <- m1; return (f x1) }
23:02:38 <ddarius> luqui: That's what I said I might do.
23:02:40 <mmorrow> ddarius: (at least have a version of colors that have an alpha channel though ;))
23:02:59 <luqui> ddarius, ah good.   the first one tends to become standard, if it's good
23:03:01 <ddarius> I'm just going to write my current library to be agnostic about the color type.
23:04:02 <dsrogers> so... nesting on foralls is optional, isn't it?  I mean, assuming you rename your types properly?
23:04:18 <lispy> I find that 'type Foo = ...' usually ends up causing me trouble than it saves.  Do others feel this way?
23:04:35 * luqui does
23:04:39 <swalters> wow... this shirt is so horrible that I might actually buy it:  http://www.tshirthell.com/funny-shirts/pimp/
23:04:40 <lambdac> Title: T-Shirt Hell :: Shirts :: PIMP
23:05:01 <stepcut> haha
23:05:03 <mmorrow> ddarius: hmm. maybe the solution would be to have a standard class for colors
23:05:14 <luqui> LOL swalters
23:05:24 <ddarius> lispy: I would presume it's better than nothing, but not better than using a newtype.
23:05:44 <mmorrow> i agree
23:05:48 <ddarius> It's also useful for shortening type signatures.
23:06:08 <dsrogers> since you can say forall a b. (a-> b) -> b instead of forall b_0 . (forall a_1 . a_1 -> b_0) -> b_0?
23:06:09 <mmorrow> i find it really handy also for labelling String arguments for documentation purposes
23:06:09 <lispy> in this particular case, it was shorting a type siganture by satnding in for several of the arguments
23:06:24 <lispy> But, this meant than I had to keep looking up the 6-7 parameter types that were hidden by it
23:06:36 * luqui only likes type = ... as documentation
23:07:13 <luqui> yeah, type synonyms as encapsulation are a very bad idea
23:07:13 <hml> how do i fix the following?
23:07:15 <hml> parseNumber0 :: Parser Integer
23:07:15 <hml> parseNumber0 = do d <- many1 digit return $ read digit
23:07:40 <stepcut> you probably want, read d
23:08:00 <hml> that i do; thanks
23:08:43 <dsrogers> hmm, is there somewhere I could look to understand my type question?
23:09:36 <lispy> forall a b. (a -> b) -> b != forall b. (forall a. a -> b) -> b
23:09:43 <mmorrow> dsrogers: err, what is the question? i must have missed it
23:09:58 <dsrogers> lispy answered it.
23:09:58 <luqui> dsrogers, no it's not optional
23:10:01 <dsrogers> kinda
23:10:03 <luqui> you cannot always float them to the top
23:10:04 <dsrogers> why?
23:10:08 <dsrogers> how are they different?
23:10:28 <lispy> dsrogers: the second one takes a funtion of higher polymorphism
23:10:29 <mmorrow> because without the forall, TH looks for that typevar *outside* of the [t| ... |]
23:10:47 <luqui> dsrogers, to be precise, you can only float foralls on the right of arrows
23:11:01 <luqui> so X -> forall a. Y is the same as forall a. X -> Y
23:11:13 <mmorrow> and if it doesn't exists, then it's considered an error, because without specifying the forall, you're telling TH that it *does* exists outside of the [t| ... |]
23:11:20 <luqui> but (forall a. X) -> Y is not hte same as forall a. X -> Y
23:11:42 <mmorrow> is a free in X?
23:11:54 <lispy> (forall a. X) -> Y, atually means exists a. X -> Y
23:12:23 <mmorrow> (forall a.a) -> b      ===           exists a.(a -> b)
23:12:34 <dmwit> Why?
23:12:52 <lispy> dmwit: the rules of logic
23:13:35 <mmorrow> (exists a.a) -> b === forall a.(a -> b)
23:13:39 <dmwit> Is (-> b) somehow equivalent to "not"?
23:13:53 * dmwit ponders how that could be
23:13:55 <mmorrow> but since the a is already forall'ed in haskell, i don't know if that's exactly correct
23:14:12 <dsrogers> oh dur. the type system is a first order logic, isn't it?
23:14:35 <dmwit> Curry-Howard isomorphism says so
23:14:43 <mmorrow> (forall a. a -> b) -> b  is second order
23:14:43 <dmwit> Though I've never understood it, myself. =P
23:14:45 <luqui> dsrogers, uh, second order intuitionistic :-)
23:15:03 <luqui> but much of the same intuition applies
23:15:09 <dsrogers> err, second order, sorry yes.  Yo uneed second order for existential qualifiers.
23:15:09 <luqui> no pun intended (seriously)
23:15:35 <dainanak> I wish i understood what any of that meant :(
23:15:55 <mmorrow> ((forall b. (forall a. a -> b)) -> c  is third order
23:16:09 <dsrogers> well, I took logic 6 years ago, and it was one course, and I barely remember anything.
23:16:10 <luqui> hmm, we're using different definitions of "order"
23:16:22 <dsrogers> yes.
23:16:26 <luqui> mmorrow, I think you mean "rank 3"
23:16:30 <dsrogers> logic order, not rank.
23:16:31 <mmorrow> heh, yeah
23:16:43 <mmorrow> i meant rank
23:17:12 <paczesiowa> dons: how do I send you patches for those Eq instances in xml and feed? right now I have created darcs repos with initial imports from latest versions from hackage and then recorded those new patches. but darcs send needs your repo address to send patches
23:17:14 <luqui> and actually I think it's just first order... dependent types are second order iirc...
23:17:21 <dsrogers> so obviously there must be a "there exists" type qualifier, hence exists.
23:17:24 <luqui> (GADTs maybe bring it up to 1.6th order)
23:17:36 <lispy> so, then what is an example where you need (forall a. a -> b) -> b, instead of forall a b. (a -> b) -> b?
23:17:41 <dsrogers> so what does exists mean as a type qualifier?
23:18:00 <luqui> f singleton (x,y) = (singleton x, singleton y)
23:18:03 <luqui> where x and y are different types
23:18:07 <Quadrescence> When I recur a function (with some Int parameter n), it is easy to decrement n -- we just pass n-1 into the function when you recur. But how would I increment from 0 to n-1?
23:18:21 <luqui> dsrogers, well, it doesn't, ehem, exist in haskell.
23:18:32 <luqui> dsrogers, because it's isomorphic to a suitably placed forall.
23:18:40 <dsrogers> ah
23:19:04 <luqui> but you have to go through newtypes to do it many times...
23:19:17 <luqui> (something to do with decidability...)
23:19:53 <lispy> what was that syntax again? data S a = forall x. S (a x)
23:20:05 <lispy> I know the gadt syntax...but I forget the non gadt one
23:20:38 <lispy> So, then you're saying there exists an x, for each S a
23:21:43 <mmorrow> dsrogers, luqui: i found this interesting .. shows the duality: http://hpaste.org/9535
23:21:47 <lispy> granted, later you know don't know what it was because you threw it way
23:21:49 <mib_zdloi5or> > sort[1,2,3,1]
23:21:50 <lambdac>  [1,1,2,3]
23:22:02 <mib_zdloi5or> > sort[923490823048324823-432,2,3,1]
23:22:03 <lambdac>  [1,2,3,923490823048324391]
23:22:10 <mmorrow> i was confused at first which one to call Forall and which to call Exists though
23:22:27 <dainanak> Quadrescence, depending on the situation, you'd usually want to use either a fold or a map
23:22:40 <dainanak> list functions are your friend
23:22:42 <mib_zdloi5or> hey guys, why winhugs could not accept sort function?
23:22:49 <Quadrescence> dainanak: hrmmmmmmmmmmmmmmmmm
23:23:00 <mib_zdloi5or> i typed sort[9,1,1] and it says Undefined variable "sort"
23:23:05 <mmorrow> so one of them you have to unsafeCoerce one the way in, the other you have to unsafeCoerce on the way out
23:23:08 <dainanak> Quadrescence, what kind of function are you aiming for?
23:23:26 <luqui> mmorrow, very nice
23:23:27 <cizra> Hi
23:23:51 <Quadrescence> dainanak: I am trying to convert an index into a permutation. I already made a permutation->index function
23:23:55 <Quadrescence> I need to make the reverse now.
23:24:24 <dsrogers> so forall b . (forall a. a->b) ->b means that for every b, you can choose a function (forall a. a->b) which maps to b.  Whereas forall a b. (a->b)->b means for every a, from the domain of a, and everyone b, from the domain of b, there exists a function (a->b)->b.  In particular, that means for any given a, and b, which must be chosen, in advanced, (a->b)->b is fixed, whereas, for every b, in the first form, there is a polytypic fun
23:24:34 <dsrogers> so, definately different.
23:24:57 <lispy> dsrogers: correct
23:25:12 <dainanak> Quadrescence, convert an index into a permutation, huh? can you give me an example of what you mean?
23:25:23 <dainanak> like an example application of that?
23:25:36 <Quadrescence> dainanak: Consider a list [1..n]
23:25:44 <Quadrescence> This can be permuted in n! different ways.
23:25:49 <Quadrescence> So there are n! permutations
23:26:04 <dsrogers> I think I have a second-order logic proof of that.
23:26:05 <lispy> dsrogers: now explain why forall a b. a -> b == forall a. (a -> forall b. b)
23:26:10 <dainanak> hrm
23:26:21 <Quadrescence> I assign a number k such that 0 <= k < n! to each permutation
23:26:33 <Quadrescence> This k is the "index of the permutation"
23:26:49 <Quadrescence> I made a function to convert a permutation [Int] to an index Int
23:26:59 <Quadrescence> Now I need to make the reverse: Int -> [Int]
23:27:08 <|Steve|> Probably easier to write that with implication replaced with negation and OR.
23:27:50 <|Steve|> forall a,b ~a \/ b <==> forall a ~a \/ (forall b b).
23:28:26 <lispy> |Steve|: no, in fact, I'm lost :)
23:28:27 <noohgodno> > product [1..1000]
23:28:28 <lambdac>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
23:28:41 <lispy> |Steve|: for one, I have no idea where your parens go
23:29:11 <noohgodno> marital counseling
23:29:15 * noohgodno (rimshot)
23:29:15 <dsrogers> well, intuitively, for any given, a, in the second form you can choose a function (a ->b), but to choose that function, you have to fix b, thus in order to choose the function from a to b, both have to be fixed.
23:29:19 <dainanak> Quadrescence, use hpaste so i can get a look at your [Int] -> Int function
23:29:21 <dsrogers> so it's equivilent.
23:29:31 <dons> paczesiowa: you could just manually diff
23:29:33 <|Steve|> Wait, these are functions?
23:29:35 <lispy> forall a b (~a \/ b) <==> forall a (~a \/ (forall b b)) <-- perhaps here?
23:29:35 <dsrogers> I'd have to work harder for a proof of that from ZFC
23:29:50 <|Steve|> Yes, that's what I meant.
23:30:27 <lispy> |Steve|: yeah, we were talking about haskell (->) function arrows :)
23:30:53 <dsrogers> what is the relatinship between disjoint and arrow?
23:30:54 <|Steve|> Ah, in that case I don't have any clue what the question is asking.
23:31:58 <lispy> |Steve|: why is it equavalent to float a universal quantifier out from the right side of an (->)?
23:32:19 <lispy> |Steve|: so, forall a b. (a -> b), and forall a. (a -> (forall b. b))
23:33:58 <lispy> I don't recall the proof, I just recall learning it's true
23:34:04 <|Steve|> You just have to show both directions. ==> should be obvious.
23:34:31 <|Steve|> If for all a and b, a implies b, then for all a, a implies any b.
23:34:54 <|Steve|> The converse is no harder to see.
23:35:10 <lispy> So you're using that (->) is implication?
23:35:14 <|Steve|> If you want to write down universal instantiation and so forth, well, that's less fun.
23:35:24 <|Steve|> I was, yes.
23:35:41 <lispy> Hmm...and how come you can do that?  Because of Curry-Howard?
23:35:42 <|Steve|> As for haskell arrows, I guess you have to rely on the Curry-Howard.
23:36:05 <|Steve|> But I'm no expert on that.
23:36:22 <dsrogers> -> maps from one domain to another.  That's implication
23:38:21 <hml> is there an enumerated list of all asscii chars in haskell?
23:38:25 <dsrogers> if for all a, a implies any b, then for every b, there exists and a which implies b.  This is true for every a.
23:38:52 <ddarius> Not all the equivalences of classical logic hold in intuitionistic logic, in particular we have only (forall a.p a) -> b  <=  exists a.p a -> b
23:39:04 <dmwit> hml: [\0 .. \127]
23:39:14 <dmwit> hml: ['\0' .. '\127'], I mean
23:39:16 <hml> ingenious; thanks
23:39:27 <dmwit> hml: For all Unicode characters: [minBound .. maxBound]
23:40:05 <lispy> Is there a monad instance similar to Either except that both Right and Left are consider "OK"
23:40:26 <dmwit> Yes, but sadly, you can't use it, since you only get one instance per type.
23:40:41 <dmwit> Check out the "category" package on hackage, though.
23:40:42 <mmorrow> ddarius: is the '<=' there "reverse implication" ?
23:41:21 <dsrogers> it's if, then, backwards.
23:41:22 <lispy> dmwit: you only get one instance per type?
23:41:23 <dsrogers> not implication
23:41:45 <mmorrow> coming from math and not logic/cs this whole using '=>' as flip (implication)  confuses me thoroughly
23:42:03 <dmwit> lispy: Well, you can have a second instance, but you need to have a newtype wrapper.
23:42:16 <mmorrow> e.g. the '=>' in type classes confused the hell out of me at first
23:42:18 <dsrogers> only (forall a.p a) -> b  <=  exists a.p a -> b holds in classical logic...
23:42:27 <dsrogers> so how is that different?
23:42:34 <dmwit> lispy: i.e. you can't have two separate declarations beginning "instance Monad (Either a) where ...", for obvious reasons.
23:42:47 <lispy> :t (>>=)
23:42:48 <lambdac> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:43:22 <dsrogers> as, in the other direction only exists if the image of p a in b / b is the empty set.
23:43:37 <lispy> (Left a) f = Left (f a), and (Right a) f = Right (f a), but hhmm
23:43:50 <lispy> dmwit: I guess the problem there is that I need Either a a
23:44:31 <dmwit> Oh, you want instance Monad ((,) Bool), huh?
23:44:33 <luqui> lispy, ah, then you'd have to newtype LR a = LR (Either a a)
23:44:43 <mmorrow> forall a. f a |-> True  ==> exists a. f a |-> True
23:44:48 <mmorrow> where ==> is implication
23:44:51 <lispy> I don't actually want Either a a
23:44:56 <lispy> I want Either a b
23:45:04 <luqui> what!?
23:45:05 <lispy> But, the signature of (>>=) doesn't allo for this
23:45:10 <luqui> oh
23:45:18 <luqui> I read the second one as Either a a again ;-)
23:45:23 <mmorrow> (and |-> is "maps to")
23:45:27 <dmwit> lispy: ...do you just want the "either" function, then?
23:45:28 <dmwit> :t either
23:45:30 <lambdac> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:45:44 <lispy> dmwit: I don't think so
23:45:50 <lispy> dmwit: I thought about htat for a while
23:46:20 <lispy> dmwit: I have two code paths and Iwant the calculatons to go down either path
23:46:23 <lispy> But not both
23:46:28 <lispy> So, either is a natural choice
23:47:07 <|Steve|> >>= wouldn't work, but why wouldn't either?
23:47:20 <dmwit> Right, I'm waiting for the "but" clause. =P
23:47:48 <lispy> I think it's because i convinced myself either had the wrong polymorphism...but maybe it does work
23:48:39 <lispy> I would often be using it with c = Either a b
23:48:42 <lispy> But, I guess that's okay
23:48:45 <|Steve|> Oh, I suppose either might not be what you want. It seems like you want Either a b -> (a -> c) (b -> d) -> Either c d or something.
23:48:59 <dmwit> lispy: See also the Arrow stuff.
23:49:00 <dmwit> :t left
23:49:01 <lispy> |Steve|: yes
23:49:02 <dmwit> :t right
23:49:02 <lambdac> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
23:49:04 <lambdac> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
23:49:38 <dmwit> :t \f g -> left f >>> right g
23:49:41 <lambdac> forall (a :: * -> * -> *) b c d c1. (ArrowChoice a) => a b c -> a d c1 -> a (Either b d) (Either c c1)
23:49:55 <lispy> dmwit: Oh, that might be it
23:50:04 <lispy> that's very close to something I started to define
23:50:12 <int-e> @type (+++)
23:50:14 <lambdac> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:50:22 <dmwit> Oh, even better. =)
23:50:49 <dmwit> :t (|||) -- isn't this something, too?  but... what?
23:50:50 <lambdac> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
23:51:12 <rwbarton> That's the arrow-y version of either
23:51:13 <dmwit> Oh, that's just like "either", but generalized to arrows.
23:51:21 <dmwit> yeha
23:53:12 <dsrogers> thanks for the help everyone.
23:53:14 <dsrogers> goodnight
23:53:18 <|Steve|> I haven't the slightest clue what that's doing.
23:53:34 <mmorrow> f+g : A+B -> C  , where  f : A -> C, g : B -> C ,  and + is a coproduct
23:54:05 <|Steve|> hmm
23:54:38 <mmorrow> so in Set, the coproduct is disjoint union
23:54:50 <|Steve|> Right.
23:54:57 <mmorrow> ==> Either a b
23:55:09 <|Steve|> No no, I understood.
23:55:22 <mmorrow> oh
23:56:06 <|Steve|> I've never seen ArrowChoice mentioned in any of the haskell tutorials.
23:56:45 <mmorrow> i've never really used Arrows
23:56:54 <dmwit> It's like... generalized multiplexing of computations.
23:57:20 <dmwit> mmorrow: I don't think I've ever used a non-function Arrow... but I use the (->) instance a lot.
23:57:43 <dmwit> (&&&), (***), first, and second are hard to beat when mucking about with tuples.
23:57:47 <mmorrow> ah, true. correction: i've never really used Arrows other than (->) ;)
23:57:55 <nornagon> i use the arrow stuff just for the tuple bits
23:58:13 * mmorrow loves (***), (&&&), first, second
23:58:42 <mmorrow> i usually reimplem those locally in a module rather than importing Control.Arrow though
23:59:06 * luqui has an intimiate relationship with >>>
23:59:13 <dmwit> I have a mega-module that imports Control.Arrow, Control.Monad, Data.List, etc.
