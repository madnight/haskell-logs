00:00:00 <mmorrow> :)
00:00:13 <mmorrow> Trinithis: you have to get it from darcs
00:00:20 <Trinithis> is it stable?
00:00:38 <mmorrow> if you get it built and working, then for the most part
00:00:38 <Trinithis> or worth getting over 6.8.3 rather
00:00:55 <ajdhs> ghci was using -B.../lib/... instead of -B.../share/...
00:00:59 <ajdhs> thanks mmorrow
00:01:05 <mmorrow> no problem
00:02:14 <mmorrow> Trinithis: hmm, i guess "it depends". maybe get it and    ./configure --prefix=/usr/local/ghc/ghc-6.9.`date +%Y%m%d`
00:02:36 <Trinithis> ok
00:02:38 <mmorrow> Trinithis: that way your not risking anything
00:02:42 <mmorrow> *you're
00:03:58 <Trinithis> Your English teacher would be proud!
00:04:19 <mmorrow> heh, also my typing teacher
00:04:31 <mmorrow> oh wait, i never learned to type "correctly"
00:04:50 <dsrogers> this is great!  I now have tools to debug and test TH
00:05:00 <mmorrow> dsrogers: awesome awesome!
00:05:09 <dsrogers> is there a way I can make the compiler error out?
00:05:36 <dsrogers> so I can write a test that fails if GHC dies compiling the program?
00:05:52 <Trinithis> What tools?
00:05:52 <mmorrow> yup. check out report :: Bool -> String -> Q ()
00:06:14 <mmorrow> dsrogers: or you can just  call   error "oh crap!!"
00:06:37 <dsrogers> some tricks to print out the output of TH at various points in the program.
00:07:01 <dsrogers> so compiling /is/ the test.
00:07:10 <mmorrow> i'm going to write this up. i just recently set up a blog to do exactly this and i've yet to use it.
00:07:41 <mmorrow> ("this" being write about template-haskell and/or related things)
00:07:59 <Trinithis> what's the site?
00:08:15 <mmorrow> http://moonpatio.com/blog/
00:08:21 <noBotE> Title: moonpatio
00:09:41 <dsrogers> so I think the library of functions that would be useful here are the input and output methods, as well as ways of generating "known good" output.
00:10:12 <dsrogers> so a test harness that calls template haskell, pprints the result and compares it to known good output on disk.
00:10:34 <dsrogers> err, calls a template haskell construct.
00:10:57 <dsrogers> or even something that lets you view code as generated would be nice.
00:11:03 <dsrogers> maybe something interactive.
00:11:23 <mmorrow> yeah, runIO allows unlimited possibilities. it's just there waiting for really interesting/useful/clever things to be done with it
00:12:01 <dsrogers> args.  lots of good hack-worthy things here.
00:12:05 <dsrogers> but so late...
00:12:07 <dsrogers> must sleep
00:12:12 <dsrogers> goodnight everyone.
00:12:14 <dsrogers> thanks!
00:12:27 <mmorrow> for instance, you can get the filename of the current module, parse the module with haskell-src-exts, and do whatever with it  (e.g. embed it's md5 within itself, embed it's AST within itself, ...)
00:12:29 <Trinithis> wow it's later than I thought
00:12:33 <mmorrow> dsrogers: night
00:12:35 <Trinithis> night as well
00:12:41 <mmorrow> night
00:13:00 <dsrogers> mmorrow: RTTI!
00:13:13 <mmorrow> ?
00:13:31 <mmorrow> ah google to the rescue
00:13:33 <dsrogers> you could use it to generate run time type information.
00:13:41 <dsrogers> introspection...
00:13:42 <mmorrow> definitely could
00:13:51 <dsrogers> a reify at runtime, basically
00:13:59 <dsrogers> anyways.
00:14:01 <dsrogers> must sleep.
00:14:06 <dsrogers> goodnight for real
00:14:11 <mmorrow> goodnight
00:14:45 <gneek> I was wondering...does anyone have a snippets.conf for Geany with Haskell snippets they are willing to share?
00:16:45 <mmorrow> i never heard of Geany, but hpaste has collected a bunch of useful snippets. it's just a bitch to search
00:16:51 <mmorrow> (but worth it)
00:59:40 <fraktalek> hi
01:00:04 <fraktalek> can someone give me a hint how to print a result from a state monad?
01:00:11 <fraktalek> please :)
01:03:01 <dons> just the normal State monad?
01:03:08 <dons> main = print (runState .... )
01:03:28 <dons> runState runs your State monad code, returning a pure value, which you print at the top level.
01:07:27 <fraktalek> yes, just the normal State monad. but this with the runState doesn't seem to work..
01:09:16 <newsham> ?bot
01:09:16 <noBotE> :)
01:09:54 <newsham> > runState get 100
01:09:55 <noBotE>  (100,100)
01:11:15 <newsham> > runState (mapM_ (\n -> modify (+n)) [1,3,8,4]) 0
01:11:16 <noBotE>  ((),16)
01:13:52 <ivanm> @ty modify
01:13:53 <noBotE> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
01:14:01 <newsham> ?src modify
01:14:01 <noBotE> Source not found. :(
01:14:23 <newsham> modify f = get >>= \x -> put (f x)
01:14:35 <newsham> or   gets f >>= put
01:26:09 <Guest7341> what exactly does Arrow.loop do? it dont get how its supposed to become a feedback loop
01:26:13 <Guest7341> i*
01:30:25 <Saizan_> astrobunny: are you familiar with fix?
01:30:50 <Guest7341> me or him?
01:30:51 <Guest7341> haha
01:31:42 <Saizan_> too many guests :)
01:31:46 <Saizan_> you, anyhow
01:31:57 <Guest7341> lol yea
01:32:12 <Guest7341> yea i dont know fix too well
01:32:21 <Guest7341> i think i looked at it before but it diddnt click or something
01:32:42 <Saizan_> loop is almost the same, but for arrows
01:32:48 <Saizan_> ?src (->) loop
01:32:48 <noBotE> Source not found. Do you think like you type?
01:32:56 <Guest7341> hmm ok
01:33:32 <Saizan_> for the (->) arrow loop f b = let (c,d) = f (b,d) in c
01:34:06 <Saizan_> part of the result of f is passed back as input to it
01:34:22 <Guest7341> so it just runs down the left pipe?
01:34:50 <Saizan_> left pipe?
01:35:10 <Saizan_> > loop (\(x,xs) -> (x:xs)) 1
01:35:11 <noBotE>  Couldn't match expected type `(c, [b])' against inferred type `[b]'
01:36:19 <Saizan_> > loop (\(x,xs) -> let xss = x:xs in (xss,xss)) 1
01:36:21 <noBotE>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:38:10 <Guest7341> hmm
01:39:01 <Saizan_> the xs i get as argument is the same value as the xss that i give as the second element of the return tuple
01:39:09 <Guest7341> yea im getting it to loop now
01:39:17 <Guest7341> just trying to figure out why the first thing i tried wasnt
01:39:42 <Saizan_> what it was?
01:39:55 <Guest7341> test = (xxx >>> yyy)
01:40:01 <Guest7341> (loop test) 1
01:40:12 <Guest7341> and xxx and yyy were just some addition / multiplication
01:40:58 <Saizan_> it just hanged? the arrow you pass must be sufficiently lazy in the 'd' parameter for loop to work
01:41:21 <trofi> @bot
01:41:22 <noBotE> :)
01:41:22 <Saizan_> i.e. it must produce some of the value before inspecting it
01:41:23 <Guest7341> nah it returned a value right away for the left part of the tuple
01:41:40 <trofi> @version
01:41:40 <noBotE> lambdabot 4.1
01:41:40 <noBotE> darcs get http://code.haskell.org/lambdabot
01:41:49 <Guest7341> test (1,2) produces (2048,3072) and (loop test) 1 produces 2048
01:42:50 <Saizan_> ah, so you don't use the second argument at all?
01:43:34 <Guest7341> (loop test) was :: Integer -> Integer
01:43:42 <Guest7341> im just doing it in a ghci console
01:49:37 <ketil> @ping
01:49:38 <noBotE> pong
01:49:52 <ketil> @seen lambdabot
01:49:52 <noBotE> lambdabot is in #haskell and #haskell-blah. I don't know when lambdabot last spoke.
01:50:04 <ketil> Que?
02:07:29 <trofi> > 1
02:07:31 <noBotE>  1
02:08:25 <Axman6> > it
02:08:26 <noBotE>   Not in scope: `it'
02:08:30 <Axman6> lame
02:12:08 <ivanm> is succ :: Double -> Double guaranteed to add 1 to the value? (as in it's not an approximation)
02:13:08 <ziman> Double is Enum?
02:13:21 <ivanm> @type succ 1.0
02:13:22 <noBotE> forall t. (Enum t, Fractional t) => t Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
02:13:24 <ivanm> > succ 1.0
02:13:25 <noBotE>  2.0
02:13:48 <olsner> > succ 1e300
02:13:49 <noBotE>  1.0e300
02:14:20 <ziman> seems so: http://www.zvon.org/other/haskell/Outputprelude/Enum_c.html
02:14:21 <noBotE> Title: Haskell : Enum
02:14:33 <olsner> you can't always add 1 to a floating-point number
02:14:55 <Saizan_> it's an Enum mostly to support [x,y..z] notation
02:15:20 <ziman> [5.1, 5.2 .. 6.4]
02:15:22 <ziman> > [5.1, 5.2 .. 6.4]
02:15:23 <noBotE>  [5.1,5.2,5.300000000000001,5.400000000000001,5.500000000000002,5.60000000000...
02:16:29 <trofi> > [5.1, 5.2 .. 6.4] :: [CReal]
02:16:30 <noBotE>  [5.1,5.2,5.3,5.4,5.5,5.6,5.7,5.8,5.9,6.0,6.1,6.2,6.3,6.4]
02:17:16 <ivanm> duh, I can just do (1+) to guarantee that I get what I need :s
02:19:43 <Toxaris> > 1e300 + 1 -- don't think that helps with floating point, ivanm
02:19:45 <noBotE>  1.0e300
02:20:03 <ziman> > 1e300 + 1 :: CReal
02:20:04 <noBotE>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
02:20:45 <ivanm> Toxaris: what I'm doing will never be that big...
02:21:43 <ivanm> I'm doing a fold on a list which calculates a weighted sum (i.e. equivalent to sum . zipWith (*) xs [1..], except it also returns 1 higher than the length of the list)
02:23:00 <Toxaris> I think that for Double, succ = (1 +)
02:23:03 <ivanm> so what I've got is: f (sum,step) x = (sum+(mom*step), step+1); foldl' f (0,1)
02:23:17 <ivanm> yeah, looks like it... but just to make sure I might as well use 1+ explicitly
02:25:12 <hackage> Uploaded to hackage: benchpress 0.2.2
02:25:31 <jpcooper> which is the most active http request library for haskell?
02:26:38 <jpcooper> hmm, I'm guessing that it might actually be HTTP
02:38:03 <dcoutts_> gwern: there's no way to require programs to be installed, except as build tools (which as you know are not yet tracked)
02:38:03 <preflex>  dcoutts_: you have 1 new message. '/msg preflex messages' to read it.
03:40:43 <sioraiocht> @src foldr
03:40:44 <noBotE> foldr f z []     = z
03:40:44 <noBotE> foldr f z (x:xs) = f x (foldr f z xs)
03:40:47 <dcoutts_> dons: if we wanted to integrate mkcabal into cabal-install, say as "cabal init", would you consider licensing as BSD3 ? currently mkcabal is either GPL or LGPL depending on whether you believe the .cabal file or the LICENSE file
03:41:08 <dcoutts_> sioraiocht: yeah, even after all these years I still have to look that up sometimes :-)
03:41:18 <explicitjelly> I never remember which one's foldl and which one fodlr.
03:41:30 <explicitjelly> I know it says the direction in the last latter, but I also never remember how that's meant %)
03:41:37 <sioraiocht> dcoutts_: it's better than going through the effort of remembering =p
03:41:40 <dons> dcoutts_: i'd license it as BSD, and actually wouldn't mind writing it too.
03:41:46 <dons> esp. after hacking away on cabal2arch.
03:41:53 <dons> i think this would be pretty straightforward.
03:41:58 <dcoutts_> dons: great, cabal init would be handy
03:42:06 <dons> ok. remind me in a few hours.
03:42:46 <dons> btw, I think shapr might have coined the phrase "Real World Haskell". grepping the logs, the first reference appears to be,
03:42:49 <dons> 05.03.08:05:08:10 <shapr> So for "Shrimp's Guide to Real World Haskell" the same thing could be done.
03:42:55 <dcoutts_> dons: I think at some point I'll make cabal-install into a lib+exe since it's crazy that hackport, cabal2arch etc cannot depend on it. There's so much useful code to share there.
03:42:58 <dons> though close behind, we have,
03:42:58 <dons> 06.04.11:17:17:11 <int80_h> what would be a better real world haskell book?
03:43:10 <dons> dcoutts_: yeah.
03:44:25 <dons> ?time dons
03:44:29 <noBotE> Local time for dons is Sun Aug 24 03:44:30 2008
03:44:32 <dons> ?time for bed dons
03:44:36 <dcoutts_> indeed
03:44:39 <dcoutts_> g'night dons
03:44:44 <dons> night.
03:44:53 <explicitjelly> ?time explicitjelly
03:44:56 <noBotE> Local time for explicitjelly is Sun Aug 24 12:44:53 2008
03:45:18 <explicitjelly> aah. I was wondering how it knows the timezone.
03:46:45 <Leaves> hey, I have "type Prime = Integer", and a function "primeFactors :: Integer -> [Prime]", this works so far, but I also have a function isPrime :: Integer -> Bool, is it possible to let it return true without calculating anything if I put a value of type prime in it?
03:47:12 <ivanm> Leaves: only if you have a way of defining what a prime is ;-)
03:47:15 <explicitjelly> Leaves, hmm. you'd have to use newtype and generic programming
03:47:26 <explicitjelly> Leaves, scrap your boilerplate
03:47:29 <ivanm> i.e. if you have an isPrime :: Integer -> Bool function
03:47:32 <explicitjelly> correct me if there's an easier way
03:47:42 <ivanm> wait, forget what I said
03:47:50 * ivanm _really_ needs to learn to read everything :s
03:48:05 <explicitjelly> ivanm, wait, I'll try something out for you
03:48:27 <ivanm> for me? :o
03:48:28 <ivanm> why?
03:48:49 <explicitjelly> because I want to see if I can get it right
03:49:25 <ivanm> but Leaves was the one who asked :o
03:49:34 <Leaves> I read something about the newtype but I don't really understand it yet, I'm used to the way ruby and java handle it, like Prime extends Integer
03:49:35 <explicitjelly> oh.
03:49:37 <explicitjelly> er.
03:49:43 <explicitjelly> Leaves, wait, I'll try something out for you
03:49:45 <Toxaris> Leaves: no that is not possible, there is no difference between Prime and Integer.
03:49:59 <Leaves> ok, I'll wait explicitjelly
03:50:11 <explicitjelly> Toxaris, it works if he makes a difference... but I'm not sure if that's what he wants.
03:50:33 <Toxaris> explicitjelly: sure, but first things first :)
03:51:35 <Toxaris> Leaves: so if you want isPrime :: Prime -> Bool and isPrime :: Integer -> Bool both be existent but work differently, you need (1) to create a new type named Prime and (2) use a type class to make isPrime work for both types
03:52:11 <Axman6> Leaves: sounds like a project euler problem...?
03:52:21 <Toxaris> Leaves: (1) you can do with data or newtype: newtype Prime = Prime Integer.
03:52:47 <Leaves> Axman6: I actually mad e alot of ProjectEuler exercises, but this is for an implementation of the RSA algorithm
03:52:57 <Axman6> ar right
03:53:01 <Axman6> ah even
03:53:06 <Toxaris> Leaves: (2) looks something like class IsPrime a where isPrime :: a -> Integer; instance IsPrime Prime where isPrime = const True; instance IsPrime Integer where isPrime = checkForPrimeUsingExpensiveAlgorithm
03:53:09 <jpcooper> yarr!
03:53:18 <Leaves> Toxaris: yea, that's what I want
03:53:49 <Toxaris> Leaves: but now Prime and Integer are different types (there is no subtyping in Haskell!), so you cannot use them in the same place :(
03:54:17 <Leaves> ok, so when primeFactors returns a list of Primes, I can't just add two of them and get an Integer?
03:54:36 <Toxaris> Leaves: so you have to instantiate and maybe even write appropriate typeclasses to define a common interface for Prime and Integer large enough for your application
03:54:49 <Toxaris> exactly
03:54:56 <|Steve|> Expensive? But there's a handy deterministic n^(6+epsilon) algorithm and randomized algorithms are much faster.
03:55:09 <Toxaris> |Steve|: more expensive then const True
03:55:37 <Leaves> Toxaris: I will play a bit with the code you gave to see if I understand it
03:57:07 <|Steve|> Toxaris: I was just joking.
03:57:12 <Toxaris> another option would be to cache the prime-ness dynamically instead of statically
03:57:41 <explicitjelly> Toxaris, Leaves, I just tried it out
03:57:44 <Toxaris> data Number = Prime Integer | Composite Integer
03:57:52 <explicitjelly> Toxaris, Leaves, it works with SYB/cast, too
03:58:01 <explicitjelly> but that's probably not what you want
03:58:14 <Leaves> |Steve|: yeah I know there are fast probabilistic algorithemns but mine currently is just isPrime = (==1).length.primeFactors, I want to keep things simple ;)
03:58:23 <explicitjelly> Leaves, http://hpaste.org/9880
03:59:08 <explicitjelly> it's almost certainly not what you want %)
03:59:20 <|Steve|> Leaves: Well, if you ever find a fast algorithm for primeFactors, you be sure to let me know. =)
03:59:24 <Axman6> Leaves: that's pretty inefficient
03:59:52 <Toxaris> explicitjelly: hmm, isPrime "not a number" == False disturbs me in terms of static type safety :)
03:59:59 <r3m0t> Leaves: at the least, replace (==1).length with null.tail
04:00:20 <Toxaris> explicitjelly: and isPrime 3 == False in terms of correctness
04:00:32 <Axman6> the best ones i've seen have a function that creates a lazy list of primes, and check which ones are divisors
04:00:40 <Axman6> uh, factors
04:00:43 <explicitjelly> Toxaris, yes, I just wanted to show Generics
04:00:52 <Axman6> up to sqrt n
04:00:58 <Axman6> wait, no
04:01:04 <Axman6> that's just checking if it's a prime
04:01:05 <Toxaris> explicitjelly: yeah, and I feel that they are not applicable here :)
04:01:07 <explicitjelly> Toxaris, and read the "isPrime" as "is of datatype Prime", not as "is a prime" ;)
04:01:49 <explicitjelly> Toxaris, no, probably not
04:02:52 <Leaves> explicitjelly: why is the class called IsPrime, not Prime?
04:03:20 <explicitjelly> Leaves, there is no class in the code I pasted. are you referring to someone else's code?
04:03:50 <Leaves> ohh, yeah, it was Toxaris code :)
04:03:50 <explicitjelly> Leaves, by the way, newtype is just that: "a new type". while "type" doesn't create a new type
04:03:56 <Toxaris> Leaves: I name ad-hoc classes for a single method like the method as a private convention
04:04:19 <Toxaris> Leaves: I would name a class "Prime" if all instances where "prime types" in same sense :)
04:04:29 <Toxaris> whatever a prime type is
04:05:48 <besiria> personally, i still don't get newtype. never used it in ma code
04:06:01 <Leaves> Toxaris: ok, and should primeFactors return [Prime] ?
04:06:08 <tristes_tigres> Hi
04:06:44 <Beelsebob> besiria: it's simple -- it actually creates a new type, which can behave differently with respect to classes to the thing you newtyped
04:06:46 <Toxaris> Leaves: I guess
04:06:55 <explicitjelly> last time I dealt with primes, I just had a data structure of a million precomputed primes and checking if a number was prime was checking if it was a member. that was enough for my purposes. there are some optimizations possible... for example, if the lowest bit of an integer isn't set, you don't need to check.
04:07:20 <Toxaris> Leaves: but I come to think that my other idea (data Prime = Prime Integer | Composite Integer) would work bether
04:07:25 <Leaves> this btw, is my code currently: http://hpaste.org/9881
04:07:38 <explicitjelly> besiria, it's a bit like data with just one constructor
04:07:51 <Beelsebob> explicitjelly: not quite -- but that's pretty subtle I guess
04:08:10 <besiria> and the point of using newtype? what is the purpose of it
04:08:18 <explicitjelly> Beelsebob, yeah, "a bit" :)
04:08:25 <r3m0t> Toxaris: how about instance [Prime] => Num where ... ?
04:08:29 <Beelsebob> besiria: it's slightly more efficient than using data
04:08:35 <Beelsebob> for the subtle reason
04:08:40 <|Steve|> Toxaris: Addition would be a pain.
04:08:56 <Beelsebob> data D = D Int -- with this data type _|_ and D _|_ are differente values
04:08:58 <explicitjelly> Beelsebob, can you say that basically, it's the same data but a new type?
04:09:07 <Toxaris> |Steve|: well, so ad an "unknown" variant
04:09:08 <Beelsebob> newtype N = N Int -- with this data type _|_ is the same as N _|_
04:09:45 <Beelsebob> essentially, newtype creates a type equal to another one at runtime, but different at compile time
04:09:51 <Toxaris> r3m0t: parse error: unexpected [, expected context or class name
04:09:53 <Beelsebob> type creates ones that are the same at compile and runtime
04:10:04 <Beelsebob> and data creates ones that are different at both runtime and compiletime
04:10:19 <cinimod> @pointless \x -> (x >= 3)
04:10:19 <noBotE> (>= 3)
04:10:21 <explicitjelly> nice way to put it
04:10:27 <cinimod> @pointless \x -> (x >= 3) && (x <= 5)
04:10:28 <noBotE> liftM2 (&&) (>= 3) (<= 5)
04:10:29 <r3m0t> Toxaris: I meant instance Num [Prime] where (*) = (++), etc
04:10:47 <Toxaris> and | in data declarations create "types" which are the same at compile time, but different at runtime
04:10:50 <Heffalump> Beelsebob: data D = D !Int confuses things somewhat though :-)
04:10:54 <Toxaris> with a twisted meaning of types
04:11:04 <Beelsebob> Heffalump: yeh, true
04:11:40 <Beelsebob> do they retain their tag at runtime, I asume you do, if you don't use -funbox-strict-fields
04:11:54 <Heffalump> well, that's up to the compiler
04:12:09 <Beelsebob> sure
04:12:16 <Beelsebob> is the common (ghc) case I meant
04:12:24 <Heffalump> then yes
04:13:00 <explicitjelly> the tag indicates the type of the value in its runtime representation, yes?
04:13:17 <Beelsebob> so that creates values which are different at runtime, but not different semantically at rutime
04:13:18 <Beelsebob> that's fun
04:13:33 <Leaves> Toxaris: but with ï»¿ (data Prime = Prime Integer | Composite Integer) a Prime can be Composite?
04:13:55 <explicitjelly> Leaves, just name it PrimeOrComposite ;)
04:13:58 <Toxaris> Leaves: I mean data PrimeOrComposite
04:17:09 <Saizan_> data D = D !Int has still different semantics from newtype, case undefined of D _ -> "foo" is equal to "foo" with newtype
04:18:18 <Toxaris> Leaves, |Steve|: http://hpaste.org/9882
04:18:40 <Toxaris> |Steve|: note that addition is easy (and cheap because of laziness)
04:19:10 <tristes_tigres> How to obtain help for lambdabot ?
04:19:11 <Toxaris> oh, and multiplication is wrong because I should test for 1 :)
04:19:17 <|Steve|> Heh.
04:20:17 <Toxaris> @help
04:20:17 <noBotE> help <command>. Ask for help for <command>. Try 'list' for all commands
04:20:27 <Heffalump> Beelsebob: as Saizan says, they are slightly semantically different. But I think you can still use the same representation, it's just that case of will compile differently.
04:20:39 <Saizan_> Toxaris: and because it should multiplicate :)
04:20:48 <Toxaris> :)
04:21:01 <Beelsebob> Saizan_: oh, yeh, sorry, I'd buggered off for a while
04:21:20 <tristes_tigres> The lambdabot comands go to the whole channel ? I tried /msging to it, but no responce
04:21:28 <Beelsebob> I never really think about the semantics of strict data types, because I never write them
04:21:42 <Beelsebob> tristes_tigres: what did you /msg it?
04:21:51 <Toxaris> tristes_tigres: that works for me: /msg noBotE @help
04:22:23 <tristes_tigres> Toxaris: I tried /msg lamddabot @help
04:22:43 <Toxaris> @bot
04:22:43 <noBotE> :)
04:22:48 <Toxaris> tristes_tigres: no lambdabot around
04:22:58 <Leaves> I see toxaris, so if I add two primes (say 5+2) then when the result is prime that will be saved
04:23:01 <tristes_tigres> Toxaris: oops
04:23:25 <Toxaris> Leaves: ?
04:23:40 <tristes_tigres> lambdabot is present though
04:23:53 <tristes_tigres> hybernating ?
04:24:08 <Toxaris> Leaves: I propose to represent all numbers, whether composite or prime, with Number, and lazily cache the result of the internalIsPrime function in the first component
04:24:23 <Leaves> Toxaris: ok
04:24:36 <Leaves> that is pretty cool (especially the lazy part)
04:25:31 <Toxaris> Leaves: so you can call isPrime more then once without recomputation, and you can sometimes set the first component without any computation at all, e.g. after multiplication with /= 1
04:26:12 <Toxaris> that is kind of a design pattern, to lazily cache information by moving it into the same record which contains the input data
04:26:19 <Toxaris> s/information/results
04:26:29 <tristes_tigres> @vixen
04:26:29 <noBotE> If something takes a lot of effort to do, it probably ain't worth doing.
04:26:39 <tristes_tigres> right on
04:27:25 <Leaves> Toxaris: but can I also have a function that is only defined for a Prime number as input?
04:28:01 <Leaves> O should I do something like type Prime = Number True
04:28:09 <explicitjelly> Leaves, what should it do if the input is not a prime?
04:28:11 <Toxaris> no doesn't work
04:28:19 <Leaves> explicitjelly: nothing, undefined
04:28:26 <explicitjelly> Leaves, you can error out
04:28:30 <explicitjelly> Leaves, using error
04:28:37 <Leaves> explicitjelly: yeah but I want it to error on compile time
04:28:37 <tristes_tigres> explicitjelly: Maybe
04:28:39 <Toxaris> Leaves: do you want a static or a dynamic error in case your primeOnly function is called with a composite number?
04:28:42 <tristes_tigres> using maybe
04:28:49 <explicitjelly> > 12 + (error "nope")
04:28:50 <noBotE>  Exception: nope
04:29:08 <Leaves> Toxaris: static I guess? (if that means on compile time)
04:29:09 <Philonous> Leaves: That would mean you want to run the "isPrime" function on compile time. For that you need lisp :>
04:29:12 <tristes_tigres> primeOnly:: Int -> Maybe Number
04:29:12 <explicitjelly> Leaves, it doesn't know during compile team what you'll feed?
04:29:41 <Toxaris> Philonous: he could use isPrime :: Integer -> Maybe Prime
04:29:43 <Leaves> explicitjelly: actually the program currently doens't have input
04:30:09 <Philonous> Toxaris: Sure, but it wouldn't bail him out on compile time
04:30:10 <explicitjelly> Leaves, the function has, and knowing what input that will be would mean actually *running* the program
04:30:16 <Leaves> explicitjelly: the program is a constant that encodes the numer six with RS, then  decodes it and shows 6 .. ;-)
04:31:03 <Toxaris> Leaves: well, for compile time checking, you need two different types for prime numbers and maybe-not-prime numbers
04:31:17 <Toxaris> Leaves: you can combine the caching solution with the newtype solution you've written so far
04:31:31 <Leaves> couldn't I do something like main = print $ isPrime (432143231340841312312312321::Prime) which would give True without calculations?
04:32:10 <Leaves> (where the compiler has to belevieve the number actually is Prime
04:32:10 <Toxaris> Leaves: but then you could also do main = print $ isPrime (4 :: Prime), which would also return True :(
04:32:22 <Saizan_> Leaves: you can, with the IsPrime typeclass of the first solution
04:32:22 <Philonous> Leaves How should the compiler know what a prime number is and what is not without computing it?
04:32:43 <Saizan_> Philonous: the type annotation tags it
04:32:46 <Leaves> Philonous: I tell the compiler that it is Prime
04:33:10 <explicitjelly> what's the point?
04:33:12 <kowey> Toxaris: if I published your little library as the 'tabular' package (Text.Tabular) under the BSD3 license, would that be ok with you?
04:33:28 <Toxaris> kowey: *my* little library?
04:33:32 <Philonous> Oh ok. So you'd just promise it's a prime and the compiler has to buy it?
04:33:42 <Leaves> Philonous: yep :)
04:33:53 <kowey> :-) the heart of it is yours anyway... I just wrote the ascii rendering, and soon the html
04:35:24 <Toxaris> kowey: yeah that's fine
04:35:26 <sioraiocht> does lhs2Tex do any reformatting of compiler pragmas?
04:35:42 <kowey> thanks! i'll let you know when I have the HTML bit written and then put it on hackage
04:36:41 <Philonous> Leaves: You could define a typeclass PotentialPrime (or something) with an isPrime function, make Num an instance of it (with the regular prime testing) and newtype Num, make it an instance and add the trivial function isPrime = const true for it
04:37:57 <Toxaris> Philonous, Leaves: note that AlwaysPrime cannot be an Num instance
04:38:37 <Toxaris> because prime numbers are not closed under Integer multiplication / addition / ...
04:38:44 <Leaves> :)
04:38:49 <Leaves> unfortunately not :)
04:38:52 <sioraiocht> hey dcoutts_: how did you format your rewrite rules in LaTeX, did you use lhs2TeX or do it by hand?
04:39:01 <Toxaris> so the (123 :: Prime) doesn't work, because it needs Num
04:39:24 <Toxaris> but you can write (unsafePrime :: Integer -> Prime)
04:39:36 <Philonous> Well, but newtype Int would strip it from it's (+) function, wouldn't it?
04:40:08 <Toxaris> yes that's true, but Leaves said some time ago that he may want a + function
04:40:11 <Philonous> You could just overload int.(+) and (*) with undefined (Dunno though if it actually works that way :-/)
04:40:17 <Toxaris> with <prime> + <prime> = <integer>
04:40:28 <dcoutts_> sioraiocht: lemme check
04:40:33 <sioraiocht> cheers
04:40:40 <Leaves> well, the thing I though I had to do is make a new type Prime and then all kind of funtions, like (+) :: Prime -> Prime -> Integer etc
04:40:58 <Leaves> but the "lazy caching" solution is very nice imo
04:41:26 <Toxaris> yeah that would be possible, but the name (+) is taken, so you have to either hide the Prelude (+), or name your's differently
04:41:54 <explicitjelly> you're all killing me with your apostrophes
04:42:08 * Toxaris doesn't understand english :(
04:42:15 <Leaves> but haskell supports polymorhism right?
04:42:25 <Philonous> Leaves: Sure
04:42:42 <Philonous> Through the type-classes
04:43:06 <Toxaris> Leaves: yes, the Prelude (+) is polymorphic, but differently from yours (that way better, explicitjelly?)
04:43:30 <explicitjelly> Toxaris, %) yes %)
04:44:09 <Leaves> mm, I'm afraid the type system of haskell is still a bit to complicated for me
04:44:22 <Toxaris> @type (+)
04:44:23 <noBotE> forall a. (Num a) => a -> a -> a Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
04:44:58 <Vq^> Philonous: not all polymorphic behaviour requires type-classes
04:45:25 <Philonous> Vq^: Do you know a counterexample?
04:45:38 <trofi> :t head
04:45:39 <noBotE> forall a. [a] -> a Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
04:45:46 <Toxaris> Leaves: (+) is polymorphic, it works for different types a, e.g. a = Int or a = Integer. but because of a -> a -> a, the result has to be the same type as the arguments
04:45:48 <Vq^> absolutely, the classic example is the id function
04:45:54 <Toxaris> @src id
04:45:54 <noBotE> id x = x
04:46:02 * trofi suspects noBotE runs on FreeBSD! :]
04:46:02 <Vq^> it's completely polymorphic
04:46:07 <Toxaris> no magic involved, but works for all types you want
04:46:23 <Saizan_> Leaves: it's quite different from the ones you can find in OO languages, if you know java, haskell's typeclasses are similar to Interfaces with generics
04:46:52 <Philonous> Ok, that would be the canonical example. But I wouldn't know something else you could do with all types.
04:47:14 <Toxaris> @type (,)
04:47:15 <noBotE> forall a b. a -> b -> (a, b) Thread 157a400 has exited with leftover thread-specific data after 4 destructor iterations
04:47:20 <Leaves> Toxaris: I see, but can't I do something like Prime extends Integer so I can just put it in (+) :: Integer -> Integer -> Integer, but where I can also define functions that only accept Primes, Like makeRSAKey :: Prime -> Prime -> Integer ?
04:47:28 <explicitjelly> Philonous, constant functions
04:47:29 <Vq^> Philonous: map is polymorphic
04:47:49 <Philonous> Ok ok, I believe you :)
04:48:29 <Vq^> theres quite a lot of them if you think about it
04:48:37 <Toxaris> Leaves: no, Haskell doesn't support subtypes. some people say because it would be inherently hard, other argue that it would be easy but nobody cares, so I'm confused
04:48:43 <explicitjelly> @src fst
04:48:43 <noBotE> fst (x,_) =  x
04:48:48 <explicitjelly> @type fst
04:48:48 <noBotE> forall a b. (a, b) -> a
04:48:58 <explicitjelly> ...also!
04:49:09 <Philonous> Yes. Anyway. I'd still say they work on an implicity type class which includes all types
04:49:27 <Philonous> There is no ad-hoc polymorphism like in C++
04:49:53 <Saizan_> Philonous: a typeclass with no methods, though
04:49:57 <Philonous> You can't make a function work on Int and String but not on (Int->Int)
04:50:13 <Toxaris> Philonous: but they don't.
04:50:13 <Philonous> Without introducing a typeclass, that is
04:50:15 <Heffalump> you can, type classes..
04:50:24 <Heffalump> of course someone could then make an Int->Int instance
04:50:31 <Heffalump> but in C++ someone could add an Int->Int overload
04:50:31 <explicitjelly> Philonous, Generics?
04:50:39 <Vq^> well, if you exclude the answer there is no answer
04:52:22 <Toxaris> Philonous, you cannot do that in C++ with inheritance, either
04:52:32 <Toxaris> s/with/without
04:53:01 <explicitjelly> Toxaris, templates?
04:53:20 <Philonous> Toxaris: I could just overload the function with a new signature. Shouldn't be a problem and I don't need inheritance for that, do I?
04:53:23 <Vq^> Toxaris: isn't it ajust a case of simple brutal function overloading?
04:53:39 <Toxaris> overloading /= templates /= ad-hoc polymorphism
04:53:52 <Toxaris> overloading = same name, different functions
04:54:01 <Toxaris> templates = same name, same definition, *different functions*
04:54:13 <Toxaris> ad-hoc-polymorphism = same name, different definitions, *same function*
04:54:25 <Toxaris> at least I understand it like that
04:54:28 <Vq^> ah, yes of course
04:54:50 <BONUS> im still not clear when a function is considered overloaded exactly and when its just polymorphic
04:55:01 <Toxaris> in which language?
04:55:05 <BONUS> haskell
04:55:05 <BONUS> is it overloaded whenever it features class constraints
04:55:15 <BONUS> or are just functions which are part of class definitions overloaded
04:55:27 <Toxaris> I don't use "overloading" with haskell
04:55:37 <BONUS> yeah, that actually makes sense
04:56:34 <Toxaris> overloading is a trick to allow different functions to have the same name, haskell doesn't feature this trick, so we have to invent new names all the time, or import modules qualified.
04:56:53 <Baughn> I find myself needing to know whether or not a thunk has been evaluated. Is there some common pattern in use for this? Library function? Anything?
04:56:55 <explicitjelly> btw, how does the haskell community feel about that?
04:57:32 <Toxaris> I hate it. it would be great to have less names in the standard library
04:57:35 <Vq^> Toxaris: so overloading is just a preprocessing hack?
04:58:13 <olsner> isEvaluated x = x `seq` True :D
04:58:16 <explicitjelly> I run into it when naming operators with punctuation
04:58:19 <Vq^> Baughn: the usual way is to ensure that it is evaluated
04:58:25 <Vq^> exactly :)
04:58:29 <explicitjelly> I'll use things like .+., .-. etc.
04:58:35 <explicitjelly> but then the next library does the same
04:58:49 <Toxaris> It's a naming hack. for example in Java, you write foo(3, 4), but in the class file, this call look something like foo(int,int)void(3, 4)
04:58:55 <explicitjelly> and I really don't want qualified names with punctuated infix operators
04:59:04 <Toxaris> so the "real internal name" of a method includes the parameter types
04:59:06 <Baughn> Vq^: That won't do at all. Evaluating it is entirely too expensive, plus, it will affect the behaviour of my program. To clarify..
05:00:11 <Toxaris> after this "name transformation", there is no trace of overloading left
05:00:24 <Baughn> Vq^: I'm writing a program that needs explicit lazy evaluation (eg. observable) in order to not have to serialize /every atom on a planetary surface/ - for one thing, I don't have enough HD space for that. There are further details like previously-evaluated data decaying back to a non-evaluated state over time, but.. I'd like to use haskell's implicit lazy evaluation to make it easier on me
05:01:03 <Toxaris> Baughn: sounds like you need unsafePerformIO
05:01:26 <Baughn> Toxaris: That was my first thought
05:01:37 <Baughn> ..I suppose it'll work
05:01:57 <Baughn> I am also using threading here, though, so I don't know how this will interact..
05:02:15 <Baughn> Mmh. I'll have to think /very carefully/ about this.
05:02:44 <Vq^> im unsure how well STM takes running from unsafePerformIO :/
05:02:58 <Toxaris> I think there is a paper partly about observable sharing in Haskell
05:03:04 <Toxaris> some EDSL
05:03:18 <Toxaris> but I don't remember which
05:03:34 <Vq^> i would seriously consider writing explicit lazyness instead
05:03:55 <Baughn> I can see why. Yes, that would probably be rather safer.
05:04:34 <explicitjelly> Baughn, otherwise, one wrong move and BOOM you've just evaluated a whole universe.
05:04:38 <explicitjelly> bad thing.
05:04:50 <Baughn> explicitjelly: Quite.
05:05:10 <Baughn> You hit the nail on the head there, too. It /is/ a whole universe.
05:05:24 <Vq^> fancy :)
05:05:55 <Baughn> Just one problem. Lazy evaluation is a great substitute for mutation.
05:06:03 <Baughn> But doing it explicitly, /I won't be able to do that/
05:06:38 <Toxaris> explicit lazy evaluation is in IO or ST anyway, isn't it?
05:06:49 <Baughn> It would have to be. That's not a good thing
05:07:07 <Baughn> So I'll have to mae use of unsafePerformIO, and tip-toe very carefully indeed
05:07:22 <Vq^> i think i've read something about memoization using unsafePerformIO and friends, might be interesting before making your decision
05:13:45 <dmhouse> Baughn: what are you doing? Sorry, recent join.
05:14:02 <Baughn> dmhouse: Well, the basic problem is..
05:14:17 <dmhouse> unsafePerformIO is generally safe if you're performing an IO action which is referentially transparent.,
05:14:38 <dmhouse> E.g. reading a text file whose contents won't change during the duration of your application.
05:15:01 <explicitjelly> or writing stuff which you won't read?
05:15:47 <Baughn> dmhouse: I'm representing a universe as a haskell data structure. I want to (a) be able to transparently zoom into any arbitrary part of it, running code as appropriate to mutate the structure (eg. standard dethunking), (b) be able to serialize it to disk, /only writing the parts that have been dethunked/, plus of course a description of how to get the rest, and (c) in IO, be able to.. rethunk bits, aging them out
05:15:52 <mmorrow> > let a=("let a=","in uncurry((flip((.).(++)).(++).show)a)a")in uncurry((flip((.).(++)).(++).show)a)a
05:15:53 <noBotE>  "let a=(\"let a=\",\"in uncurry((flip((.).(++)).(++).show)a)a\")in uncurry((...
05:16:06 <mmorrow> quine++
05:16:07 <dmhouse> explicitjelly: I guess that should also be okay, although it's not referentially transparent.
05:16:24 <explicitjelly> mhm
05:16:48 <Baughn> explicitjelly: You may end up writing more than once. If that's okay..
05:16:54 <Baughn> explicitjelly: And with threading, the writes may overlap
05:17:25 <Baughn> (There is, of course, nothing stopping you from grabbing an MVar inside a unsafePerformIO procedure)
05:17:53 <explicitjelly> so you'll just have to *make* it referentially transparent
05:17:59 <Baughn> Quite.
05:18:15 <mmorrow> http://hpaste.org/9883
05:18:32 <dmhouse> Baughn: yeah, sounds tricky. I guess you're considering some kind of marker structure in an IORef which marks the bits you've evaluated?
05:19:02 <Baughn> dmhouse: Yep. The re-thunking can and should be done by entirely replacing the structure, so that part's fine.
05:19:03 <dmhouse> And adding stuff to that structure using unsafePerformIO inside a pure accessor function for your universe structure?
05:19:16 <Baughn> Yes
05:19:33 <Baughn> Sounds good?
05:19:47 <Baughn> dmhouse: Well, except I'm quite explicitly threading, so I'll be using an MVar for the purpose
05:19:58 <Baughn> Or, rather, implicitly threading. Lots of par.
05:20:15 <explicitjelly> hilighting on "explicit" in #haskell is really *bad*.
05:20:28 <dmhouse> I believe that ought to be okay.
05:20:41 <dmhouse> explicitjelly: does it not have to match your entire nick?
05:21:11 <dmhouse> Baughn: rather, I've not got much experience with unsafePerformIO, but I can't think how it could go wrong if you're using the appropriate mutexes.
05:21:38 <Baughn> dmhouse: Me neither, but using it always makes me nervous and want to consult others
05:21:57 <explicitjelly> dmhouse, I'm also hilighting on "explicit" and "jelly", among others, because some people tend to not write out the whole nick. just "jelly" is actually used quite often... just "explicit" not so much, so maybe I should just remove it.
05:22:12 <Baughn> explicitjelly: Or get a shorter nick
05:22:18 <Baughn> eJelly, say
05:22:19 <explicitjelly> Baughn, no, I like it
05:22:42 <mmorrow> Baughn: seq lets you order evaluation to the extent that you can ensure a piece of something you're about to construct is evaluated before the thing as a whole is
05:23:00 <mmorrow> i'm not sure if i said that clearly
05:23:02 <explicitjelly> Baughn, those are small sacrifices for an AWESOME NICK.
05:23:11 <Baughn> mmorrow: Which is how I was planning to force the unsafePerformIO, yes
05:23:29 <mmorrow> Baughn: that's always worked for me :)
05:23:37 <dmhouse> Baughn: presumably the serialisation is in IO, too, yeah? You didn't mention that, but I assumed it.
05:24:14 <Baughn> dmhouse: It might be
05:24:21 <Baughn> Well, probably. ;)
05:24:28 <dmhouse> Don't see any reason why it shouldn't be.
05:24:47 <mmorrow> and the seqList :: [a] -> [a] function i've found to be handy also
05:25:13 <mmorrow> seqList [] = [] ; seqList (x:xs) = x `seq` x : seqList xs
05:25:17 <dmhouse> ?hoogle deepSeq
05:25:17 <noBotE> A Hoogle error occured.
05:25:25 <Baughn> rnf, surely?
05:25:42 <Baughn> Well, rnf.seq
05:26:09 <mmorrow> ooh, i guess also you could do something like   newtype Rnf a = Rnf !a
05:26:55 <dmhouse> ?index seq
05:26:55 <noBotE> Prelude, Control.Parallel
05:27:03 <mmorrow> err, but i haven't thought about that so i dunno if there'd be any "gotchas"
05:27:22 <mmorrow> @src seq
05:27:22 <noBotE> Source not found. Are you on drugs?
05:27:36 <mmorrow> it's magic
05:28:05 <dmhouse> seq _ y = y -- from the source code
05:28:13 <Baughn> It's primitive, that's what it is
05:28:20 <mmorrow> ghci> :i seq
05:28:20 <mmorrow> seq :: forall a (b :: ?). a -> b -> b   -- Defined in GHC.Prim
05:28:20 <mmorrow> infixr 0 seq
05:28:21 <Baughn> dmhouse: *groan*
05:28:21 <dmhouse> That is inside #ifdef __HADDOCK__, though ;)
05:28:33 <dmhouse> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Prelude.html#%24%21
05:28:35 <noBotE> Title: Haskell Code by HsColour, http://tinyurl.com/57672j
05:29:04 <mmorrow> yeah, primitive, magic, ...
05:30:37 <dmhouse> ?index rnf
05:30:37 <noBotE> Control.Parallel.Strategies
05:39:44 <tristes_tigres> I wrote a little function   randomTree :: Int -> IO (Tree String)
05:39:52 <tristes_tigres> to generate random trees
05:40:04 <tristes_tigres> how to put it on hpaste ?
05:40:22 <Saizan_> @paste
05:40:22 <noBotE> Haskell pastebin: http://hpaste.org/new
05:40:31 <opqdonut> tristes_tigres: Int is the depth?
05:40:41 <opqdonut> tristes_tigres: how about passing the height and a random generator in
05:40:45 <opqdonut> instead of doing stuff in IO
05:40:49 <tristes_tigres> opq: number of nodes
05:41:07 <opqdonut> ah
05:41:25 <tristes_tigres>  randomTree 5 >>= return.drawTree >>=putStrLn
05:41:33 <tristes_tigres> wb
05:41:33 <tristes_tigres> |
05:41:33 <tristes_tigres> +- nykx
05:41:33 <tristes_tigres> |  |
05:41:33 <tristes_tigres> |  `- banxn
05:41:35 <tristes_tigres> |
05:41:37 <tristes_tigres> +- d
05:41:39 <tristes_tigres> |  |
05:41:41 <tristes_tigres> |  `- rraxt
05:41:43 <tristes_tigres> |
05:41:45 <tristes_tigres> `- dmlpz
05:41:46 <dmhouse> tristes_tigres: you can use fmap drawTree instead of >>= return . drawTree
05:41:50 <r3m0t> tristes_tigres: pastebin
05:41:54 <dmhouse> tristes_tigres: you can also use a pastebin ;)
05:42:21 <int-e> drawtree uses too many lines :/
05:43:10 <tristes_tigres> http://hpaste.org/9884
05:43:18 <tristes_tigres> comments ?
05:44:23 <int-e> the code makes a good case for http://www.haskell.org/haskellwiki/New_monads/MonadRandom
05:44:24 <noBotE> Title: New monads/MonadRandom - HaskellWiki
05:44:43 <trofi> :t init
05:44:44 <noBotE> forall a. [a] -> [a]
05:44:50 <trofi> @hoogle init
05:44:50 <noBotE> A Hoogle error occured.
05:45:20 <tristes_tigres> int-e: why ?
05:45:43 <dmhouse> Whose is noBotE? Why is it here?
05:45:47 * tristes_tigres thinks code works but perhaps is ugly in places
05:46:14 <int-e> tristes_tigres: because there's no need for all that to live in IO
05:46:54 <tristes_tigres> randomTree 7 >>= return.treeToBrackets
05:47:01 <tristes_tigres> "<<<><<<>><>><>>>"
05:47:14 <tristes_tigres> int-e: maybe
05:47:18 <int-e> tristes_tigres: but it's big enough to make carrying around a random number generator and splitting it on the way unwieldy.
05:47:35 <guenni> is there a library that is similar to HappsIxSet but sort of stand alone?
05:49:24 <tristes_tigres> int-e: you think randomTree should take random nuymber generator as an input ?
05:50:00 <int-e> tristes_tigres: that would make it pure and more flexible, so, yes.
05:57:34 <tristes_tigres> int-e: and the type would be randomTree :: (Random t, Num t) => Int -> t -> Tree String ?
05:58:40 <int-e> RrandomTree :: RandomGen g => g -> Int -> Tree String  (or Int -> g -> Tree String)
05:59:43 <yitz> guenni: from the description on happs.org, it sounds like probably not
06:00:55 <yitz> int-e: s/^R//
06:02:09 <tristes_tigres> int-e: with the type signature like this, you can't change the distribution of random numbers
06:02:40 <yitz> preflex: seen lambdabot
06:02:40 <preflex>  lambdabot was last seen on #haskell 11 hours, 34 minutes and 15 seconds ago, saying: Title: ieee-utils-0.1: ieee-utils
06:02:48 <tristes_tigres> int-e: for instance to uniformly distributed from normally distributed
06:04:31 <yitz> tristes_tigres: that would be easier with int-e and opqdonut method than with IO.
06:05:03 <tristes_tigres> yitz: you mean with proposed random monad ?
06:06:12 <yitz> tristes_tigres: I meant with the type signature that int-e suggested. But also with MonadRandom. Truth is it's all the same - just change probabilityRight, correct?
06:06:44 <tristes_tigres> System.Random has only one type of distribution and generator
06:08:19 <tristes_tigres> actually, the code http://hpaste.org/9884 for RandomTree is imperative mostly even forgetting about random generator
06:09:12 <tristes_tigres> Because Data.Tree relies on lists and list is really a mnad, right ?
06:09:29 <yitz> tristes_tigres: I'm losing you
06:09:46 <opqdonut> no, not really
06:09:59 <tristes_tigres> yitz: List is monad, right ?
06:10:04 <yitz> tristes_tigres: you are given a uniform distribution. you can build any other distribution you want out of that.
06:10:15 <yitz> yes. but tree isn''t
06:10:30 <mmorrow> tristes_tigres: hey, i got all motivated after yesterdays discussion and did a quick binding to fegetround/fesetround in fenv.h ==> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ieee-utils-0.2
06:10:40 <noBotE> http://tinyurl.com/3ouovu
06:10:41 <mmorrow> :)
06:11:03 <mmorrow> nice and simple interface ...
06:11:04 <mmorrow> http://code.haskell.org/~morrow/code/haskell/ieee-utils/haddock/
06:11:25 <tristes_tigres> yitz: Data.Tree relies on lists
06:12:31 <tristes_tigres> mmorrow: thanks, interesting. with this it ought to be possible to check if haskell runtime changes rounding mode
06:12:51 <tristes_tigres> yitz: check definition, it's not binary tree
06:13:20 <tristes_tigres> mmorrow: by calling getRound
06:13:22 <yitz> tristes_tigres: yes, but that doesn't make Tree a monad. You would need to define a canonical way of constructing a "tree of trees"
06:13:41 <mmorrow> tristes_tigres: definitely. i also want to wrap all the C funcs in fenv.h so a higher level interface has something to build on
06:13:47 <tristes_tigres> yitz: Data.Tree defines it
06:14:21 <tristes_tigres> mmorrow: the yesterday's suggestion about implicit parametrs has something to it too
06:14:40 <mmorrow> in the higher level interface, sure
06:14:59 <yitz> @src Tree (>>=)
06:14:59 <noBotE> Source not found. There are some things that I just don't know.
06:15:59 <mmorrow> tristes_tigres: the darcs repo is at http://code.haskell.org/~morrow/code/haskell/ieee-utils/
06:16:00 <noBotE> Title: Index of /~morrow/code/haskell/ieee-utils
06:16:20 <tristes_tigres> @src Data.List (>>=)
06:16:20 <noBotE> Source not found. I feel much better now.
06:16:38 <Axman6> where's lambdabot?
06:16:41 <tristes_tigres> yitz: yet List is still a monad
06:16:47 <Saizan_> preflex: seen Cale
06:16:47 <preflex>  Cale was last seen on #haskell 14 hours, 18 minutes and 17 seconds ago, saying: a !! 0 = [0,0] which is not a string?
06:17:06 <mmorrow> > return 0 :: Tree Int
06:17:07 <noBotE>  Node {rootLabel = 0, subForest = []}
06:17:49 <int-e> tristes_tigres: ok, back from fixing that MonadRandom code. Anyway, with such a monad, the changes would be minimal: Replace IO x by RandomGen g => Rand g x, and replace getStdRandom (randomR (1, 5)) by getRandomR (1, 5) and similar; to use randomTree in IO, you'd write  evalRandIO (randomTree 5)
06:17:53 <skorpan> how do i let my module override prelude's iterate function?
06:18:00 <mmorrow> @src (>>=) Tree
06:18:00 <noBotE> Source not found. This mission is too important for me to allow you to jeopardize it.
06:18:02 <yitz> tristes_tigres: yeah, you're right, they chose an ad hoc way of building a tree of trees. I'm sure if that's always useful though.
06:18:13 <yitz> http://darcs.haskell.org/packages/containers/Data/Tree.hs
06:18:22 <int-e> tristes_tigres: and now for something different ... why are you building a tree representation of the tree at all?
06:18:43 <tristes_tigres> int-e: what do you mean ?
06:19:01 <tristes_tigres> int-e: I just wanted to write a code to generate a random tree
06:19:09 <int-e> tristes_tigres: why isn't, say, randomNode of type  String -> Io (Tree String)?
06:19:13 <int-e> IO
06:19:50 <Saizan_> skorpan: import Prelude hiding (iterate)
06:20:11 <skorpan> ah thanks
06:20:19 <seydar> http://hpaste.org/9885 whats this called?
06:20:38 <tristes_tigres> int-e: Once MonadRandom proposal is accepted and put into GHC, that would be a natural change to http://hpaste.org/9884
06:20:39 <int-e> (Or maybe of type [Tree String] -> IO (Tree String) ... I've not yet followed the code logic through.)
06:22:05 <tristes_tigres> int-e: the most fundamental part is representation of tree as a string of brackets
06:22:24 <tristes_tigres> randomTree 7 >>= return.treeToBrackets
06:22:39 <tristes_tigres> "<<<><<>><><<>>>>"
06:23:07 <tristes_tigres> That representation has one-2-one mapping to rooted ordered trees
06:23:32 <tristes_tigres> there's reference to MIT OCW lecture in the comments
06:24:07 <tristes_tigres> rooted ordered trees have 1-to-1 mapping ot binary tress
06:24:31 <tristes_tigres> So this code is really a generator of random binary trees, too
06:25:26 <seydar> Twey: ping
06:25:43 <tristes_tigres> int-e: randomNode is just plumbing
06:26:24 <tristes_tigres> int-e: so as not to repeat everywhere the text of generator
06:26:35 <mmorrow> tristes_tigres: the unfoldForest*_*  functions are nice, and may be useful for that. e.g. this looks pretty in ghci:
06:26:53 <mmorrow> first
06:26:55 <mmorrow> > let go m n = return (n+1, if m<n then [] else replicate n (n+1))
06:26:55 <noBotE>  Parse error at end of input
06:27:05 <mmorrow> (that would be randomly gen maybe)
06:27:07 <mmorrow> then
06:27:15 <mmorrow> putStrLn . drawForest . (fmap . fmap) show . concat $ (unfoldForestM_BF (go 4) [3] :: [Forest Int])
06:27:37 <tristes_tigres> mmorrow: maybe, haven't looked at it
06:27:58 <mmorrow> that might look convoluted, but that's only because it's in one line
06:28:38 <dino-> Saizan_: Cool! I feel silly but didn't know you could explicitly import the Prelude like that to hide things. May be helpful when really wanting Data.Map.lookup, instead of qualified .. as
06:29:13 <_JFT_> seydar: Hey how did your article end?
06:29:16 <tristes_tigres> what is "go" ?
06:29:22 <tristes_tigres> @list go
06:29:22 <noBotE> No module "go" loaded
06:29:49 <seydar> _JFT_: miserably. I couldn't get the rollNDice thing, and figured if i didn't even understand that, i wasn't ready to continue
06:30:14 <_JFT_> seydar: rollNDice?
06:30:36 <Saizan_> dino-: yeah, exactly :) if you import Prelude explicitly it works like any other module
06:31:03 <mmorrow> tristes_tigres: oh, so go is the func that unfoldForestM_BF takes as a param, then iterates it to generate the forest, and finally stops when go returns a (_,[])
06:31:17 <_JFT_> seydar: which article is that?
06:31:25 <seydar> http://en.wikibooks.org/wiki/Haskell/Understanding_monads
06:31:28 <mmorrow> there's also unfoldForest  and unfoldForestM  which unfold the forest depth-first
06:31:39 <mmorrow> @type unfoldForestM_BF
06:31:40 <noBotE> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> [b] -> m (Forest a)
06:31:42 <mmorrow> @type unfoldForestM
06:31:43 <noBotE> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> [b] -> m (Forest a)
06:31:45 <mmorrow> @type unfoldForest
06:31:46 <noBotE> forall b a. (b -> (a, [b])) -> [b] -> Forest a
06:32:14 <_JFT_> seydar: where did you encounter difficulty?
06:32:20 <seydar> _JFT_: i can't figure out how to keep a tab of the results from a chained >>=
06:32:36 <_JFT_> seydar: you mean a list of result?
06:32:42 <seydar> yea
06:32:48 <_JFT_> seydar:  you know C ?
06:32:50 <mmorrow> > unfoldForest (\b -> (b, if b == 2 then [] else [b+1,b+1])) [0]
06:32:51 <noBotE>  [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {r...
06:32:59 <seydar> _JFT_: a tiny bit
06:33:09 <_JFT_> seydar: Java?
06:33:21 <seydar> yups!
06:33:33 <mmorrow> tristes_tigres: i just defined go in the let just before unfoldForestBF_M
06:33:40 <tristes_tigres> mmorrow: what do you propose to use unfold forest for ?
06:33:42 <_JFT_> seydar: say that you have a single slot to store data but you want to store many fields what would you do in Java?
06:34:41 <seydar> array
06:35:03 <mmorrow> i'm thinking maybe somehow write a "go" that take a randomly generated list, then produces results parameterized by the vals in that rand list, and unfoldForest* will just go and build that forest for you
06:35:08 <tristes_tigres> mmorrow: the explanation of implicit parameters in http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.9849 is the one I could understand, unlike the one in GHC docs
06:35:09 <noBotE> Title: y - CiteSeerX
06:35:14 <_JFT_> seydar: or you would create a struct (a class) wrapping those field and you would use that single storage slot to store an instance of that class...
06:35:33 <seydar> aha! yea
06:35:45 <_JFT_> seydar: same thing with the state monad
06:36:03 <_JFT_> seydar: you have a single slot but you decide what you put in, and it is not forced to be a simple type ;)
06:36:42 <mmorrow> tristes_tigres: ooh, nice link
06:37:31 <tristes_tigres> mmorrow: if show :: Tree were defined like treeToBrackets in my code, then building a rose tree would be simply read "<<<><<>><><<>>>>" :: Tree
06:37:57 <tristes_tigres> mmorrow: with one difference that it wouldn't have random lables
06:38:04 <mmorrow> tristes_tigres: heh, yeah. just parsing that to a rose tree
06:38:17 <seydar> _JFT_: i think i have an idea of how to solve it
06:38:23 <_JFT_> seydar:  :)
06:38:35 <mmorrow> oh true. you may want to make your own type w/ only leaves holding vals/labels
06:38:37 <seydar> _JFT_: but i dont know how to get the result part of the returned tuple
06:38:54 <_JFT_> seydar: what do you mean?
06:38:56 <seydar> well, i could do it with 'get'
06:39:05 <seydar> but i don't know if I'm allowed to.
06:39:06 <mmorrow> data T a = Tip a | T [T a]    or something
06:39:18 <ivanm> what's the difference between the two mersenne libraries on hackage?
06:39:22 <_JFT_> seydar: say that you are using the field notation for data
06:39:33 <tristes_tigres> mmrrow: newtype ?
06:39:36 <_JFT_> seydar: you can get the struct and destructure it to get your answer
06:39:41 <seydar> I'm trying to solve this with only the things the article has talked about, which are >> and bind
06:39:49 <mmorrow> or just use  Tree (Maybe a)   and have all the inner Node labels be Nothing. that's nice since you can use all the nice instance/functions already implem in Data.Tree
06:39:53 <seydar> _JFT_: whats field notation
06:40:26 <sheyll_> hi
06:40:51 <mmorrow> tristes_tigres: you could use a newtype, but the only thing then is you have to squish your tree rep into a single constructor
06:40:58 <_JFT_> seydar: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
06:41:09 <_JFT_> seydar: or you could use fst,snd
06:41:16 <mmorrow> tristes_tigres: (which isn't a big deal)
06:41:17 <_JFT_> seydar: if you bundled the state data in a tuple
06:41:29 <sheyll_> offtopic: what linux distros are you useing?
06:41:32 <tristes_tigres> mmorrow: and what that would buy
06:41:33 <_JFT_> seydar: for longer tuple you do your accessors
06:42:39 <mmorrow> tristes_tigres: the newtype constructors don't exist at runtime, whereas the datacons do, so there's an extra level of boxing with the datas
06:42:50 <_JFT_> seydar: record syntax is just syntactic sugar
06:43:33 <mmorrow> tristes_tigres: so usually newtype is used unless it's just not practical (to squish the rep into one constructor)
06:43:53 <seydar> _JFT_: we're talking named fields, right?
06:44:09 <_JFT_> seydar: yes
06:44:15 <tristes_tigres> mmorrow: the randomTree builds a tree from randomly generated serial representation. not sure where unfoldForest fit into that
06:44:19 <_JFT_> seydar: but you can simply do it with a tuple
06:44:41 <mmorrow> tristes_tigres: ah, i missed your initial description of the situation
06:44:45 <_JFT_> seydar: say your state type is: "type RollType = (Results, Seed)"
06:45:08 <_JFT_> seydar: type Results = [Int] for exemple in your case
06:45:21 <mmorrow> tristes_tigres: ah, i see. so the  "<<<><>><>>" is the randomly gen /input/ then?
06:45:42 <tristes_tigres> mmorrow: yes, although it is not actually programmed that way
06:46:02 <tristes_tigres> mmorrow: instead of generating <, I generate "Node ["
06:46:23 <tristes_tigres> so then I just read it and get a tree
06:46:46 <tristes_tigres> it is sick and twisted
06:46:46 <mmorrow> yeah, you could use a stack, carry it with you, and write it with explicit recursion for sure
06:47:10 <mmorrow> heh
06:47:16 <_JFT_> BTW I just realized the forum title was changed to "precision engineering for programmers" and it is SO suiting :)
06:47:26 <seydar> _JFT_: http://hpaste.org/9886 this is what i have (i wrote rollNDice)
06:47:58 <gwern> dcoutts: yeah, I'm not surprised. it was kind of wishful thinking that I could circumvent the executable problem with build-tools
06:48:19 <mmorrow> tristes_tigres: so it seems to me you'd be generating a tree (possible a forest) depth-first
06:48:56 <tristes_tigres> mmorrow: no. I generate a string of <> right to left
06:49:11 <tristes_tigres> even though they do not look like <>
06:49:21 <gwern> lambdabot: run 1+1
06:50:02 <tristes_tigres> s/>/Node {rootLabel = \"\" subforest=[/
06:50:03 <_JFT_> seydar: I thought you had to use the state monad to implement it^
06:50:05 <gwern> guess Cale hasn't rebooted lambdbabot
06:50:15 <tristes_tigres> s/>/]}/
06:50:16 <mmorrow> hmm. so how would you procedd through the string      "<<<><><<>>>>"  ?
06:50:21 <mmorrow> *proceed
06:50:30 <_JFT_> seydar: wasn't it an exemple to put the State monad into action?
06:50:31 <seydar> _JFT_: haha no, i came in here asking about state monads,  but i somehow got to this.
06:50:37 <seydar> no
06:50:41 <dcoutts_> gwern: once we get build-tools working for deps, then it'd be trivial to add runtime-tools or something for programs that are required.
06:50:45 <tristes_tigres> substitute node [ for <
06:50:49 <tristes_tigres> and ] for >
06:51:03 <_JFT_> seydar: then give me a few minute to read the rollNDice problem declaration, brb
06:51:04 <tristes_tigres> and do not forget to put commas where needed
06:51:36 <_JFT_> seydar: do you know continuation passing style?
06:51:41 <tristes_tigres> <<><>>  -> Node [ Npode [], Node [] ]
06:51:43 <mmorrow> hehe, this is nice problem
06:51:50 <seydar> _JFT_: not by that name
06:52:17 <_JFT_> seydar: do you know how to transform a recursive function so that it is tail recursive?
06:52:46 <seydar> _JFT_: no
06:52:51 <tristes_tigres> so the code is really imperative, it seems to me
06:53:03 <_JFT_> seydar: ok that's the basis to solve the rollNDice
06:53:19 <_JFT_> seydar: do you know lisp or scheme?
06:53:41 <seydar> neither. I was writing this to be tail recursive, originally, but decided to try it anyway i could get to work, at first
06:54:12 <Twey> seydar: Pong
06:55:02 <seydar> Twey: nevermind now
06:55:10 <seydar> but thanks for getting back to me!
06:55:30 <_JFT_> seydar: one sec brb
06:56:47 <Twey> 'kay
06:56:55 <Twey> Just woke up :)
06:58:58 <_JFT_> seydar: http://hpaste.org/9887
06:59:37 <_JFT_> seydar: see the trick to transform the recursive fact into tail recursive is to use an helper function which take an additional paratmers, the current state
06:59:48 <seydar> aha!
06:59:55 <seydar> why is  the first function not tail recursive?
07:00:04 <_JFT_> seydar: in your case you will need a helper function for rollNDice to pass the result so far and the new seed
07:00:18 <_JFT_> seydar: because it manipulate the return of the recursion
07:00:32 <_JFT_> seydar: it multiplies the result of the recursion
07:00:44 <_JFT_> seydar: to be tail-recursive it has to returns it unmodified
07:00:54 <_JFT_> seydar: clearer?
07:00:57 <seydar> gotcha
07:01:58 <Twey> Is there a bi-directional equivalent to Chan, folks?
07:02:09 <_JFT_> seydar: rollNDice :: Int -> Seed -> ([Int],Seed) would need a helper looking with a type signature of
07:02:32 <_JFT_> seydar: rollNDiceHelper :: Int -> Seed -> [Int] -> ([Int],Seed)
07:02:40 <matthew-_> if a program ends normally, do you have any guarantees that ForeignPtr finalizers will be run?
07:02:48 <seydar> exxactly what i have!
07:02:55 <_JFT_> seydar: Cool :)
07:03:08 <tristes_tigres> mmorrow: There is an important paper at http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.5528
07:03:09 <noBotE> Title: Faster numerical algorithms via exception handling - CiteSeerX
07:03:24 <tristes_tigres> explains what for you need FP exceptions
07:03:44 <_JFT_> seydar: that's basically ALL what the state monad is doing, allowing you to hide that additional "state" parameter so you don't have to put it everywhere in your function signature
07:03:50 <_JFT_> seydar: but it is equivalent
07:03:51 <int-e> tristes_tigres: see http://hpaste.org/9884#a1
07:04:05 <mmorrow> tristes_tigres: cool. i'm trying to figure out a nice way the parse the "<<<><>><<><>>>" ;)
07:04:35 <seydar> can i nest where's?
07:04:46 <ski> yes
07:05:02 <ziman> no, afaik
07:05:12 <seydar> wait, yes or no?
07:05:13 <tristes_tigres> int-e: wow, much more compact
07:05:32 <_JFT_> seydar: show what you "precisely" mean?
07:05:33 <mmorrow> int-e: nice
07:05:44 <ziman> you can nest let's (let is an expression), where blocks can be attached to top-level definitions only
07:05:53 <_JFT_> seydar: you can have a function which have a where into which you have a subfunction which can also have a where
07:05:57 <_JFT_> seydar: is that what you meant?
07:05:59 <tristes_tigres> int-e: got to study it
07:06:06 <seydar> _JFT_: http://hpaste.org/9888
07:06:28 <tristes_tigres> so building a serialized representation is really unneeded step in Haskell
07:06:52 <mmorrow> "kinda"
07:07:16 <mmorrow> it seems like there's always a different way to think about things while doing the same thing
07:07:26 <mmorrow> so i guess, "i don't know"
07:07:33 <_JFT_> seydar: http://hpaste.org/9888#a1
07:08:28 <seydar> rollDie was defined before, I was just pulling an excerpt
07:08:33 <_JFT_> ok
07:08:35 <mmorrow> tristes_tigres: that parsing of the serialized tree rep though is an excellent parsing excersize in parsing languages in general though
07:09:06 <ziman> > let x = y where { y = z where { z = 3 }}
07:09:06 <noBotE>  Parse error at end of input
07:09:14 <ziman> > let x = y where { y = z where { z = 3 }} in x
07:09:15 <_JFT_> seydar: put your stopping pattern (helper 0) first
07:09:15 <noBotE>  3
07:09:49 <seydar> _JFT_: whoops, that was a dumb thing on my part (my stopper being below)
07:09:56 <tristes_tigres> int-e: smewhat arbitrary that the max label length is hard-coded,
07:10:19 <tristes_tigres> but that's easy enough to change
07:10:21 <int-e> tristes_tigres: I didn't change the label generation logic
07:10:26 <_JFT_> seydar: another detail you want to return the last seed AND the results ;)
07:10:40 <seydar> ah. thank you
07:10:46 <tristes_tigres> int-e: yes, i know
07:11:20 <seydar> it compiles!
07:11:25 <_JFT_> seydar: woot!
07:11:48 <seydar> huzzah! it works!
07:11:55 <_JFT_> seydar: Grats!
07:12:08 <seydar> is it possible to do this via binds?
07:12:12 <ski> @arr
07:12:13 <noBotE> Avast!
07:12:22 <seydar> i thought i had to solve it with binds, for some reason
07:12:31 <_JFT_> seydar: state monad you mean? you bet!
07:12:57 <_JFT_> seydar: guess what your state type would be?
07:13:11 <seydar> i hhave no idea
07:13:15 <seydar> i need to read up on them again
07:13:21 <ski> > let {rember_upto_last x0 = setTail where {setTail currentTail = loop currentTail where {loop [] = currentTail; loop (x:xs) | x0 == x = setTail xs | otherwise = loop xs}}} in rember_upto_last 3 [0,1,2,3,4,3,2,1,0]  -- one creative example of nested `where's
07:13:22 <noBotE>  [2,1,0]
07:13:27 <_JFT_> seydar: in that function what was your state?
07:13:34 <_JFT_> seydar: the one you just wrote?
07:14:05 <seydar> my state was in helper, and it was just a list
07:14:17 <_JFT_> seydar: you had 2 states....
07:14:53 <seydar> seed and list of results?
07:15:13 <_JFT_> seydar: yes, but with the state monad you could manage just having seed as a state
07:15:48 <seydar> state monads are records, right?
07:15:58 <ski> (fyi, that `rember_upto_last' is supposed to give the largest tail of the given list, not containing the given element .. and it's supposed to share that tail with the original list, instead of rebuilding it .. this is an exercise from "The Little Schemer", iirc)
07:16:27 <_JFT_> seydar: just a way to thread your state throughout a chain of function :)
07:16:46 <seydar> i dont get how to do that. can you write me an example of it?
07:17:00 <_JFT_> seydar: sure give me a few min
07:22:02 <_JFT_> seydar: (I'm writting it bear with me ;) )
07:22:11 <seydar> no problem
07:22:41 <_JFT_> here's a first bit try it and see if you can come up with rollNDice
07:23:29 <_JFT_> seydar: http://hpaste.org/9890
07:24:07 <_JFT_> seydar: your rollNDice should have this signature "rollNDice :: Random [Int]"
07:24:11 <tristes_tigres> int-e: http://hpaste.org/9884#a2
07:24:16 <tristes_tigres> mmorrow: http://hpaste.org/9884#a2
07:24:22 <_JFT_> seydar: at least the monadic helper
07:24:25 <seydar> do i always need runState to run anything with state?
07:25:57 <_JFT_> seydar: check the paste I updated it
07:26:02 <_JFT_> seydar: yes
07:26:16 <seydar> ok
07:26:20 <_JFT_> seydar: if you recall last night state monad allow you to assemble a computation
07:26:29 <_JFT_> seydar: then you need to evaluate it (execute it)
07:26:31 * Myoma hmmmmmmmmmmm http://muaddibspace.blogspot.com/2008/08/tail-call-optimization-doesnt-exist-in.html
07:26:31 <seydar> bear with me, i have no idea what i'm doing
07:26:32 <noBotE> Title: Muad`Dib: Tail Call Optimization doesn't exist in Haskell, http://tinyurl.com/5e4z23
07:26:54 <Myoma> logical content of article posted = logical content of comment posted
07:29:22 <MyCatVerbs> Myoma: I'd say the comment blew the article away there.
07:29:45 <Myoma> how come? to me it seems like it just repeated everything
07:30:40 <_JFT_> seydar: what is confusing you?
07:30:49 <seydar> just thinking, atm
07:30:53 <int-e> tristes_tigres: I guess the code is easier to follow if you imagine it producing a '<' immediately before (c', sub) <- randomForest (o+1) (c-1) and a '>' immediately afterwards. Likewise, randomTree starts by producing an imaginary '<' and ends by producing an imaginary '>'.
07:31:16 <MyCatVerbs> Myoma: except that it points out most of the places where the article's author had the situation entirely backwards.
07:31:22 <_JFT_> seydar: with monad there is one thing I learned, if you jump over any detail you don't understand you end up more confused :P
07:31:41 <seydar> hehe, i've experience that a couply times
07:32:16 <_JFT_> if you look at the snippet I send, up to which line are you following me?
07:33:04 <tristes_tigres> int-e: thnks
07:33:07 <tristes_tigres> http://hpaste.org/9884#a3
07:33:20 <_JFT_> seydar: do you understand the "random"
07:33:48 <seydar> yea, i get that. i'm not sure how to keep track of the list of results without adding an extra parameter though
07:33:59 <seydar> oh wait, can't i pass it as the result to the next call?
07:34:37 <seydar> does return have to be the last statement in a do block?
07:34:38 <_JFT_> seydar: you don't need to
07:35:00 <EvilTerran> seydar, no, the last statement just has to have the right type (much like any other line)
07:35:02 <_JFT_> seydar: return is used to put "saran wrap" around the sandwich has you said last night
07:35:02 <dmhouse> seydar: the last statement in a do-block needs to be an action in that monad.
07:35:15 <_JFT_> seydar: if the last statement returns a monad you don't have to use return
07:35:27 <dmhouse> seydar: return foo is the trivial action which does no side-effects and yields foo.
07:35:29 <_JFT_> seydar: precisely what dmhouse said
07:35:35 <seydar> does get retrieve the result of final state in (Result, Final State)?
07:36:31 <seydar> _JFT_: http://hpaste.org/9890#a3
07:36:33 <_JFT_> seydar: in my exemple it would just retrieve the seed
07:36:37 <Saizan_> ?src get
07:36:38 <noBotE> Source not found.
07:36:56 <_JFT_> seydar: check the last function I had which mimic in a non-monadic way random
07:37:22 <seydar> ok, i think i did it kinda right. lets see what ghci thinks of it
07:38:28 <_JFT_> if you have "random" and you want a list of 2 you could do " runState (do { r1 <- random; r2 <- random; return [r1,r2]}) <initSeed>"
07:40:09 <_JFT_> seydar: by extension: http://hpaste.org/9890#a4
07:40:25 <Myoma> is this true "GHC folks cracked GCC open and added in TCO for everyone" ?
07:41:20 <ziman> i've just tested it :)
07:41:20 <sbahra> It's pretty old
07:41:32 <seydar> _JFT_: how do i retrieve the result from (Result, Final State) via get, put, return, etc?
07:41:59 <_JFT_> you doin't have to have the 2 as state but if you do you used
07:42:06 <_JFT_> ?type fst
07:42:07 <noBotE> forall a b. (a, b) -> a
07:42:10 <_JFT_> ?type snd
07:42:11 <noBotE> forall a b. (a, b) -> b
07:42:25 <_JFT_> ?type replicateM
07:42:26 <noBotE> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:42:47 <_JFT_> seydar: if you have a monad that gives a random and you want say 5 results
07:42:53 <_JFT_> seydar: replicate 5 random
07:42:56 <dmhouse> Myoma: what is TCO?
07:43:09 <_JFT_> Tail Call Optimisation?
07:43:23 <yitz> Three Character Obfuscation
07:43:54 <_JFT_> seydar: replicateM 5 random
07:44:04 <Myoma> dmhouse: that's when you translate a tail call into a jump
07:44:52 <seydar> _JFT_: i'm writing my base case (i dont want to use replicateM - yet), and i don't know how to return the result and final state that already existed
07:45:09 <_JFT_> seydar: even with the base case your state is just seed if you use State monad
07:45:23 <sbahra> Myoma, not necessarily.
07:45:33 <_JFT_> seydar: since you probably want (hint hint) to use the monad for anything random related not just for rollNDice ;)
07:45:51 <Myoma> sbahra: then what?
07:46:03 <seydar> _JFT_: how do i solve this without using replicateM?
07:46:06 <seydar> ?src replicateM
07:46:07 <noBotE> replicateM n x = sequence (replicate n x)
07:46:14 <seydar> ?src replicate
07:46:14 <noBotE> replicate n x = take n (repeat x)
07:46:21 <_JFT_> seydar: recursively :)
07:46:42 <seydar> but how do i add on the value to the current list of values? i dont know how to retrieve them
07:47:29 <sbahra> Myoma, http://www.sidhe.org/~dan/blog/archives/000211.html for an alright explanation
07:47:38 <_JFT_> seydar: you can use same trick than for tail recursive transformation
07:47:41 <noBotE> Title: Squawks of the Parrot: What the heck is: A tail call
07:47:58 <sbahra> Myoma, note how stack is allocated/deallocated with tco
07:48:02 <seydar> _JFT_: what do you mean?
07:48:22 <Saizan_> seydar: using >>=, e.g. random >>= \x -> ... here x is the result of random
07:48:23 <_JFT_> seydar: I'm adding a skeleton to hpaste once sec :)
07:48:38 <Saizan_> seydar: or equivalently with do-notation, do x <- random; ...
07:48:53 <Myoma> sbahra: Could you point how what's written in there is any different from what I said?
07:50:11 <seydar> Saizan_: but i want the result, not from a separate function, but from  the previous one
07:50:44 <Saizan_> seydar: what do you mean by previous?
07:51:00 <seydar> http://hpaste.org/9890#a5
07:51:04 <sbahra> Myoma, Then it seems you're less interested in a constructive discussion and more interested in some other things :-P
07:51:20 <sbahra> Myoma, it could simply be that I misinterpreted "that's when you translate a tail call into a jump" :)
07:51:30 <seydar> my function is flawed, in that it just keeps placing in the die value alone, instead of consing it to a list of the previous ones
07:51:33 <sbahra> But that didn't make any sense to me.
07:52:20 <_JFT_> seydar: http://hpaste.org/9890#a6
07:52:38 <_JFT_> seydar:  check rollNDice'
07:52:40 <Myoma> sbahra: it says in there "Well, what it can do is turn code of the form return somefunc(); into the low-level sequence pop stack frame; goto somefunc();"
07:52:56 <Saizan_> seydar: ah, return is nothing like the return of imperative languages
07:53:01 <_JFT_> seydar: same trick as earlier to transform fact into a tail-recursive version with accumulator
07:53:16 <_JFT_> seydar: it is not the only way but it is one ;)
07:53:28 <_JFT_> seydar: I prefer the replicateM one :P
07:53:30 <Myoma> sbahra: -- I think that's wrong, you don't pop the stack frame before jumping do you? if that was in a loop you'd pop more frames than you have, wouldn't you?
07:53:32 <seydar> _JFT_: waait, thats almost exactly what i did the first time
07:54:07 <sbahra> Myoma, in a loop you don't have stack frames (in the context of a loop), you have an accumulator.
07:54:08 <_JFT_> seydar: but this time you don't need to thread the seed
07:54:12 <Myoma> sbahra: oh I see
07:54:23 <ivanm> how does one delete a file? I can't seem to find anything about it in System.IO :s
07:54:24 <sbahra> Myoma, but yes, my understanding is that jumping doesn't have stack frames/etc... jumping is simply a change of IP.
07:54:59 <_JFT_> seydar: one of the key attraction of Monad (in my very humble and uneducated opinion) is they are combinators, king of them and they encourage combination!
07:55:12 <Saizan_> _JFT_: there's the RandomGen class for random numbers..
07:55:36 <_JFT_> Saizan_: I know he was doing an exercise to understand the mechanism of state passing :)
07:55:50 <ivanm> oh, it's in System.Directory
07:55:51 <sbahra> Myoma, isn't really an accurate way to state it but I have to go to the bathroom now
07:56:02 <_JFT_> Saizan_:  and no doubt RandomGen has a better generator than my feeble attempt lol
07:56:06 <Myoma> sbahra: thanks
07:56:22 <seydar> whoa, i can use return outside of a do notation? how does that work?
07:56:56 <chrisdone> seydar: `return' is just a function
07:56:58 <yitz> _JFT_: RandomGen isn't a generator - it just describes the interface of all generators.
07:56:59 <chrisdone> :t return
07:57:00 <noBotE> forall a (m :: * -> *). (Monad m) => a -> m a
07:57:06 <Saizan_> seydar: it just wraps the value in the monad, did you look at the implementation of State for example?
07:57:09 <seydar> and when using <-, does that alter both the Result and the Final State?
07:57:14 <yitz> _JFT_: you're think of StdGen
07:57:16 <seydar> ?src State
07:57:17 <noBotE> Source not found. Maybe you made a typo?
07:57:23 <yitz> s/k/king/
07:57:41 <EvilTerran> newtype State s a = State { runState :: s -> (a,s) } -- iirc
07:57:47 <EvilTerran> ?type runState
07:57:48 <noBotE> forall s a. State s a -> s -> (a, s) Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
07:57:53 <EvilTerran> ... what
07:57:55 <_JFT_> yitz: probably I haven't had to use it yet!
07:59:16 <Saizan_> seydar: x <- foo, "runs" foo bringing in scope its result as x
08:00:25 <seydar> but if foo returns (Result, Final State), does get return Result, and is Final State the state  provided to others? I'm confused as to how _JFT_ managed to leave out the seed parameter in his solution
08:00:52 <_JFT_> seydar: I leave it out because the monad does it for me
08:01:01 <_JFT_> seydar: bind does that :)
08:01:04 <chrisdone> `do x <- foo; bar' is equivalent to `foo >>= \x -> bar'
08:01:19 <_JFT_> ?type return
08:01:20 <noBotE> forall a (m :: * -> *). (Monad m) => a -> m a
08:01:45 <_JFT_> seydar: see return will "dress" using the 'm' the value accordingly
08:01:54 <_JFT_> seydar: in my case the "dressing" is the seed
08:02:07 <_JFT_> :?runState
08:02:14 <_JFT_> ?type runState
08:02:15 <noBotE> forall s a. State s a -> s -> (a, s)
08:02:41 <_JFT_> >runState (return "return") "a seed"
08:03:20 <seydar> > runState (return "return") "seed")
08:03:20 <noBotE> Unbalanced parentheses
08:03:31 <seydar> > runState (return "return") "seed"
08:03:32 <noBotE>  ("return","seed")
08:03:48 <_JFT_> seydar: it it "dressed" the return value with the seed
08:03:51 <seydar> > runState get "seed"
08:03:53 <noBotE>  ("seed","seed")
08:04:12 <dmhouse> > evalState (return "foo") "seed" {- evalState just returns the value -}
08:04:13 <noBotE>  "foo"
08:04:15 <_JFT_> seydar: same thing happens in the code excerpt I showed
08:04:21 <dmhouse> > execState (return "foo") "seed" {- execState just returns the state -}
08:04:22 <noBotE>  "seed"
08:04:36 <seydar> ok, lets talk about the state before and after calling random
08:05:09 <yitz> > runState (modify "toUppuer") "seed"
08:05:10 <noBotE>  Couldn't match expected type `s -> s'
08:05:21 <yitz> > runState (modify toUppuer) "seed"
08:05:22 <noBotE>   Not in scope: `toUppuer'
08:05:28 <yitz> > runState (modify toUpper) "seed"
08:05:29 <noBotE>  Couldn't match expected type `Char' against inferred type `[Char]'
08:05:38 <yitz> > runState (modify $ map toUpper) "seed"
08:05:39 <noBotE>  ((),"SEED")
08:06:11 <seydar> _JFT_: there's a seed, 'seed', at the beginning of rollNDiceHelper'
08:06:24 <_JFT_> seydar: there WILL be when you evaluate it
08:06:29 <_JFT_> seydar: yes
08:06:35 <seydar> newVal <- random stores the result into newVal
08:06:47 <seydar> and does the state get changed by that call to random?
08:06:53 <_JFT_> seydar:  it instructs to do so WHEN you will evalute the monad with runState
08:07:02 <seydar> does it get changed to the Final State from that call?
08:07:06 <_JFT_> seydar:  yes precisely random get a new value and change the seed using "put"
08:07:07 <trofi> :t modify
08:07:08 <noBotE> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:07:25 <seydar> so there is a put behind the scenes?
08:07:34 <_JFT_> seydar: it is changed to that "current" state if no more modification are do it is hte final else it is just an intermediary value
08:07:39 <trofi> @src modify
08:07:39 <noBotE> Source not found. There are some things that I just don't know.
08:07:59 <seydar> ok
08:08:10 <seydar> i think i get it now
08:08:16 <_JFT_> seydar: :)
08:08:56 <yitz> trofi: modify f = get >>= put . f
08:09:11 <mauke> @time preflex
08:09:11 <noBotE> Local time for preflex is OVER 9000!
08:09:33 <trofi> ah good. can i force \bot show it? is it MonadState instance?
08:09:38 <seydar> wow, it feels good to finally get it
08:09:48 <sbahra> haha
08:09:49 <_JFT_> seydar: I am very happy!
08:09:59 <yitz> preflex: time noBotE
08:10:25 <_JFT_> seydar: you will get many of those "clarity" moment in Haskell, that feel so nice (the nicer the more you had to work to grok them :P)
08:10:56 <seydar> haskell is definitely my favorite language now.
08:11:03 <_JFT_> seydar: Woot!
08:11:15 <seydar> i can do more (immediately) in ruby, but haskell is definitely cooler
08:11:56 <_JFT_> seydar: for the longest of time I felt that with Haskell I was sitting on a very speedy race horse but I was stucked at the gate
08:12:06 <_JFT_> seydar: when the gate opened though ;)
08:12:08 <seydar> same
08:12:20 <seydar> i'm still at the "can't get out of the gate" thing
08:13:06 <_JFT_> seydar: don't worry time will come and you seems to be determine enough that it shouldn't be too long ;)
08:15:05 <seydar> i'm looking at a brainfuck compiler in haskell, and i'd like to replicate it
08:15:33 <seydar> i've written an HTML parser in haskell, so hopefully this won't be *too* hard
08:15:45 <Axman6> _JFT_: that's how i feel with monads
08:16:00 <Saizan_> ?google you could have invented monads
08:16:02 <noBotE> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
08:16:02 <noBotE> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
08:16:11 <Saizan_> ?google all about monads
08:16:11 <_JFT_> Axman6: Monad are beautiful, they are different but when you get them you'll love even more Haskell!
08:16:13 <noBotE> http://www.haskell.org/all_about_monads/
08:16:13 <noBotE> Title: All About Monads
08:16:30 <Saizan_> the tutorials that worked for me ^^^
08:16:40 <_JFT_> seydar: did you used Parsec to write your  HTML parser? (I love Parsec and I do use it at work!)
08:16:46 <seydar> cool! checking them all out write now
08:17:20 <seydar> _JFT_: no, we (people in the class) wrote our own. but it was guided, and i kinda understand it, but its not very clear
08:17:45 <seydar> i need to instal cabal
08:18:29 <Axman6> seydar: cheers :)
08:18:39 <dcoutts_> seydar: you do! see http://hackage.haskell.org/trac/hackage/wiki/CabalInstall#QuickInstallationonUnix
08:18:45 <noBotE> http://tinyurl.com/3djmej
08:18:54 <Axman6> spent three hours in here having them explained to me, and didn't learn very much
08:19:03 <Axman6> and the explanations were good too :(
08:19:05 <seydar> Axman6: cabal or monads?
08:19:08 <Axman6> monads
08:19:21 <Axman6> uh, that thanks was for Saizan_ :)
08:19:22 <_JFT_> Axman6: there is many ways to tackle them and no universally good way
08:19:34 <mauke> there isn't much to learn about monads
08:19:37 <_JFT_> Axman6: I can (man to man) explain them usually in an hour or 2 in anybody
08:19:53 <_JFT_> Axman6: but the challenge is to find what is new, where it "hooks"
08:20:18 <Axman6> well i'll give this one a go :)
08:20:21 <monochrom> Explanation is only 10% of the time required to learn.
08:20:21 <_JFT_> Axman6: like mauke say once you get them you will thinkg (just that?) but it is a beautifully simple just that
08:20:37 <_JFT_> monochrom: for some yes
08:20:48 <_JFT_> monochrom: definitively to use them though ;)
08:23:24 <monochrom> If you learned everything on the fly during lectures when you were in school, you may reasonably expect that you can still do the same now.
08:24:19 <_JFT_> monochrom: when I was in school C++ was not even thought ;)
08:24:48 <_JFT_> monochrom: neither Microsoft, nor Borland had C++ compilers :D
08:25:13 <monochrom> Yes, I can even learn computability on the fly during lectures.
08:25:26 <Axman6> well when i was in school, they taught us haskell!
08:25:41 <Axman6> this was last semester though
08:25:42 <MyCatVerbs> _JFT_: am I allowed to be jealous of you for that? :)
08:25:43 <sheyll_> cool
08:25:49 <_JFT_> MyCatVerbs: ah ah ah
08:26:07 <mauke> is there some form of STM timeout?
08:26:29 <_JFT_> MyCatVerbs: but then I was forcing them to allow my to do my exercise in C++ (using Zortech) little did I knew then ....
08:26:48 <MyCatVerbs> _JFT_: heh. What'd they teach you back then, then?
08:26:54 <tessier> How does one pronounce >>= when reading haskell code?
08:27:02 <_JFT_> MyCatVerbs: using Pascal ?!?!
08:27:03 <MyCatVerbs> _JFT_: being forced to use Pascal or something?
08:27:07 <MyCatVerbs> tessier: "bind".
08:27:08 <_JFT_> MyCatVerbs: exactly
08:27:21 <monochrom> But I observe that most of my classmates could not learn everything during lectures. Lectures were just starting points for them. Even an additional two days of discussion with classmates were just starting points for them. There is much followup work to do in solitude on re-reading the lectures, re-reading the books, doing one's exploration, ...
08:27:27 <MyCatVerbs> tessier: I usually read it as "through", also.
08:27:48 <dsrogers> tessier: sometimes I read it as "then pass result of"
08:27:57 <mauke> preflex: quote monochrom
08:27:57 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
08:28:05 <_JFT_> monochrom: school gives an introduction and a baseline culture in my humble opinion, mastership and true understanding only comes from practice
08:28:07 <monochrom> Hah
08:28:37 <seydar> when were monads invented?
08:28:42 <Axman6> monochrom: i find i learn most in lectures
08:28:54 <dsrogers> tessier: which compares nicely to >> which is "then" or "then do"
08:28:59 <monochrom> Yes! So I'm scorning now at people who expect that by graduate school they suddenly can learn as fast as you explain.
08:29:09 <monochrom> s/graduate/graduating/
08:29:22 <mauke> seydar: http://en.wikipedia.org/wiki/Monad_%28symbol%29
08:29:37 <yitz> They taught us PL/I.
08:29:59 <monochrom> So here is a theorem. The monad tutorial that makes you click is the 10th monad tutorial you read.
08:30:01 <_JFT_> monochrom: you think that I explain fast?
08:30:13 <monochrom> "as fast as" does not imply "fast".
08:30:17 <_JFT_> monochrom: SO TRUE about the 10th (or 100th) :P
08:30:41 <_JFT_> monochrom: true :) I had to learn Haskell and monad alone and it took be many lonely months so I suffered :P
08:30:57 <dsrogers> #haskell is good for learning
08:31:00 * tessier is learning haskell alone and suffering many lonely months as well
08:31:22 <yitz> tessier: we're here for you
08:31:38 <tessier> I should probably commit to one language and learn it well enough to use instead of bouncing around between haskell, erlang, scheme/lisp, python.
08:31:58 <yitz> tessier: it's good to know multiple languages
08:31:58 <Myoma> tessier: I don't think that's wise
08:31:58 <_JFT_> tessier: we are here :)
08:32:00 <tessier> I somewhat know python. But I really want to learn a functional language.
08:32:02 <seydar> mauke: the fp article doesn't discuss the history of it
08:32:16 <_JFT_> tessier: bouncing between many flavor is helpful in my opinion
08:32:28 <Axman6> does >>= always return the same monad type as the one it takes in?
08:32:32 <tessier> yitz: Yes, it is good. Except when it prevents you from really learning anything at all.
08:32:39 <_JFT_> tessier: Little Schemer is the book that "unlocked" me for monad (yes I know that is weird :D )
08:32:47 <yitz> tessier: but it's true that you need to be really good in at least one of them
08:32:50 <dsrogers> Axman6: yes
08:32:54 <Axman6> ok
08:33:01 <tessier> _JFT_: I have read Little Schemer and have no idea how it could teach you anything about monads.
08:33:08 <dsrogers> Axman6: if you need to combine monads you need to use monad transformers
08:33:12 <tessier> Although it did unlock recursion and somewhat functional programming for me.
08:33:28 <_JFT_> tessier: the end of the book when they show you how to recursively build function
08:33:32 <_JFT_> tessier: acculmulator
08:33:46 <dsrogers> Axman6: btw, you can answer the question this way:
08:33:50 <yitz> Axman6: the same monad type, but possibly a different inner type. e.g. you can start with [Int] and end up with [String]
08:33:53 <_JFT_> tessier: that's the analogy that finally unlocked state monad for me. With a monad you are not executing you are just assembling a function
08:33:55 <dsrogers> :t (>>=)
08:33:55 <noBotE> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:34:05 <_JFT_> tessier: that you need to evaluate afterward using runState for exemple
08:34:24 <dsrogers> if it could return a different monad, you'd have something like:
08:34:48 <_JFT_> tessier: I was taking a pause from Monad and Haskell reading and when reading that Little Schemer chapters my eyed popped opened!
08:34:49 <tessier> _JFT_: I should take another look at it then. I didn't really understand the end of the book.
08:34:58 <dsrogers> (Monad m) (Monad n) => m a -> (a -> n b) -> n b
08:35:28 <monochrom> You need better tendons for your eyes.  (duck)
08:35:33 <ddarius> seydar: Monads were first discovered in the mid to late 50's.
08:35:33 <tessier> I also have the other two schemer books
08:35:35 <seydar> _JFT_: what *exactly* is a monad? a function (a -> m a)?
08:35:43 <tessier> Seasoned and Reasoned. I should probably finish reading those next.
08:35:54 <tessier> I am in the middle of too many books too. I think I have developed serious ADD. :(
08:36:05 <Myoma> Reasoned Schemer is absolutely brilliant
08:36:34 <monochrom> A monad is something that, if described exactly by its axioms, alienates lots of people.
08:36:54 <_JFT_> seydar:  I would tell you in my non-technical language that they are combinator
08:36:56 <tessier> I think maybe I need a much stronger math background. I have always been interested in math but very weak at it.
08:37:06 <tessier> Mostly for lack of persistence.
08:37:13 <_JFT_> seydar: and you decide how the combination (>>=) take place in how you implement it
08:37:20 <ddarius> A monad is something that, when described by its axioms, lots of people decide to feel alienated by it.
08:37:31 <_JFT_> ddarius: ah ah right-on!
08:38:11 <Myoma> ddarius: You wrote a monad tutorial! I saw it!
08:38:12 <dsrogers> seydar: a monad is not a behavior.  It's more like an interface with a contract
08:38:26 <ddarius> tessier: You shouldn't have to "persist" through it.  There are tons of applications.  Find an application that you are interested in and look up the math behind it.
08:38:27 <tessier> I wish I knew another human being in real life who was interested in this stuff so we could talk about it.
08:38:34 <monochrom> I don't blame the feeling of alienation. Most people can't learn from axioms. (But "exact" has to be those axioms.)
08:38:41 <ddarius> tessier: I personally am very fond of signal processing.
08:38:42 <Myoma> oooo so did monochrom
08:38:51 <ddarius> Myoma: Where is it?
08:39:03 * Myoma is not following this conversation very well
08:39:05 <dsrogers> seydar: so it's something with (>>=) and return (as long as >>= and return behave the right way, your monad will "work"
08:39:19 <seydar> ok. brain is full
08:39:24 <_JFT_> seydar: lol
08:39:26 <seydar> heading out everyone
08:39:29 <tessier> ddarius: But you have to persist through a lot of foundation stuff before you can understand the math behind the application. I would love to really grok how the navier stokes equations work so I could write my own fluid dynamics simulations around my model gliders but I'm so far from that it's not even funny.
08:39:31 <seydar> later
08:39:33 <monochrom> Suppose you ask me what "exactly" is a queue. I'll give you http://groups.google.com/group/comp.lang.functional/msg/ee9cc96a68fcc3ae
08:39:34 <_JFT_> seydar: Later
08:39:34 <noBotE> Title: Express What, not How. - comp.lang.functional | Google Groups, http://tinyurl.com/53lxmr
08:39:42 <tessier> ddarius: Anything but the absolutely trivial and non-interesting seems like quite a leap.
08:39:56 <monochrom> But suppose you ask me "what is a queue like", then we're making more progress.
08:40:31 <monochrom> Ask for examples. Don't ask for "exact". If you have to ask, you are not ready to know.
08:40:44 <BONUS> that's why i think monad tutorials shouldn't focus so much on getting the definition exactly mathematically right
08:40:49 <tessier> monochrom: That is one of the things I really like about the idea of purely functional programming: what, not how.
08:40:51 <ddarius> tessier: Navier-Stokes requires some calculus (relatively basic calculus if you make some assumptions up front) and very basic physics.
08:40:54 <tessier> monochrom: That is what makes programming like this different.
08:40:58 <BONUS> at least not the ones for people beginning to do monads
08:41:10 <Myoma> the mathematical defintion is not the same as what is correct in haskell
08:41:10 <tessier> ddarius: I got a C in first semester calculus and failed second semester twice.
08:41:24 <hackage> Uploaded to hackage: maybench 0.2.1
08:41:24 <hackage> Uploaded to hackage: benchpress 0.2.2
08:41:24 <hackage> Uploaded to hackage: ieee-utils 0.2
08:41:25 <hackage> Uploaded to hackage: dotgen 0.1
08:41:27 <hackage> Uploaded to hackage: ieee-utils 0.1
08:41:27 <tessier> Mostly for lack of persistence, I think. I'll take it again and pass it someday.
08:41:45 <yitz> tessier: I used to teach calculus. it was really hard to make it interesting.
08:42:02 <yitz> monadx are a lot more fun
08:42:06 <BONUS> i really liked calculus, hate discrete maths :\
08:42:06 <Myoma> I thin you don't need to make calculus interesting..
08:42:11 <tessier> yitz: It can be interesting in the sort of crossword puzzle solving way.
08:42:13 <Myoma> it either is -- or it isn't
08:42:20 <ddarius> tessier: If you are interested in the Navier-Stokes equation, look up the equation, look up the exact math and physics you need for that, look up any requirements for that as you find them.
08:42:39 <monochrom> Learning the "what" is very difficult. You have to start from "how" then generalize.
08:42:41 <dmhouse> Myoma: that's not true, a good lecturer can make all the difference.
08:43:18 <monochrom> Piaget has rightly observed that most people go from concrete to abstract, not the other way round.
08:43:22 <tessier> dmhouse: Good lecturers are really hard to find. My previous profs had taught that same stuff for decades and it showed. They would rather have been doing research or something.
08:43:30 <ddarius> Making it interesting to a whole class all at once is probably hard, but making it interesting to one person shouldn't be too hard.
08:43:40 <tessier> dmhouse: Not that I blame them for my failure. I didn't hold up my end of the deal.
08:43:57 <tessier> Now that I have some money next time I'll pay tutors if I have to.
08:44:53 <Myoma> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
08:44:53 <noBotE>  Parse error at end of input
08:45:03 <Myoma> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))
08:45:04 <noBotE>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:45:22 <ddarius> I recommend, again, starting from applications you are interested in and working backwards from there.  This helps ensure that you will maintain interest, it gives you a direct way to validate your understanding, and it is in the vein of monochrom's comment, starting from the concrete and working to the more abstract.
08:45:50 <monochrom> How did you learn numbers? You didn't start with "what exactly are numbers" (the field axioms); it wouldn't work anyway. You started with lots of examples of concretely playing with apples, cutting cakes, ...  15 years later, a few of you are maybe ready for the "exact" axioms; the rest of you are probably never ready.
08:45:55 <_JFT_> Later all
08:45:58 <monochrom> Expect the same with monads.
08:46:15 <tessier> monochrom: Never ready? That is a depressing thought.
08:46:45 <ddarius> monochrom poorly worded it.  They are "never ready" because they don't care not because they can't.
08:46:51 <monochrom> Of course, if "you" refers to this channel, more people are ready; if "you" refers to the whole population, most are never ready.
08:47:18 <trofi> RWH's ghci output is still broken.
08:48:08 <Twey> Oho
08:48:08 <Saizan_> looking at the exact definition can help in avoiding building up false assumptions from the examples, though
08:48:16 <Twey> Beginner mistake #1: overuse of do
08:48:59 <monochrom> I wish someone will come in and ask "I have a lot of trouble learning Haskell. what *exactly* is Haskell?"  Then I can slap the Haskell 98 Report on his/her head and say "this is *exactly* Haskell!"
08:49:31 <ddarius> While it's rare that I can completely understand something from the axioms or formal definition, I really hate it when they aren't provided at all.
08:49:31 <yitz> dmhouse: the problem with calculus is that the curriculum has rusted in place, and doesn't leave much room for wiggling.
08:49:36 <dsrogers> haskell is just a programming language.
08:49:39 <dsrogers> start solving problems.
08:49:44 <dsrogers> learn what idioms work.
08:50:00 <dsrogers> then go back and read about monads and functions.  You'll realize your already using them.
08:50:18 <Saizan_> ddarius: yeah, it's like playing a game without having the rules
08:50:22 <monochrom> Yes, don't omit the axioms. But mind their position.
08:51:01 <BONUS> i'd recommend just diving into euler problems
08:51:07 <BONUS> haskell's a perfect match for them
08:51:19 <dsrogers> BONUS: which euler problems?
08:51:24 <BONUS> all of them
08:51:25 <BONUS> :]
08:51:28 <dsrogers> lol
08:51:35 <yitz> @go project euler
08:51:44 <noBotE> http://projecteuler.net/
08:51:44 <noBotE> Title: Project Euler
08:53:05 <dsrogers> lol.
08:53:31 <newsham> "mind the axiom"
08:53:44 <dsrogers> project euler is amusing.
08:55:18 <Nafai> BONUS: That's what I've used to learn Haskell
08:57:05 <EvilTerran> more like "project euler is amazing", amirite?
08:57:06 <EvilTerran> :P
08:57:46 <BONUS> Nafai yeah me too
08:57:46 <newsham> leonhard was amazing.
08:57:58 <BONUS> i mean like to get practiced with it
08:58:07 <ddarius> I don't think Euler would care too much for most of those problems.
08:58:21 <BONUS> haha
08:59:07 <dsrogers> ddarius: a lot of Euler's open problems at the time of his death were counting problems similar the project euler ones.  They were solved with computers later on.
08:59:17 <Philippa> <Twey> Beginner mistake #1: overuse of do <- Beginner mistake #2: underuse of do ;-)
08:59:36 <ddarius> Beginner mistake #3: Use do
08:59:41 <Myoma> To do or do not?
08:59:47 <dsrogers> that is the question
08:59:54 <Twey> Hahaha
09:00:11 <AlexSuraci> I'm following the guide, and I did the "isPalendrome" exercise. It works, but I can't figure out the type declaration (it only works without it): http://sprunge.us/ITFP?haskell
09:00:15 <Twey> I'm just astonished how neat my functions become when I try to avoid 'do' where possible.
09:00:17 <noBotE> Title:
09:00:19 <AlexSuraci> (The "Real World Haskell" book)
09:00:32 <dsrogers> whether tis nobler in the mind to suffer the slings and arrows of monads or to take arms against of sea of imperatives, and by opposing: end them.
09:01:03 <Philippa> Twey: the big thing's to avoid IO where possible and then think carefully about the rest. Myself, if I'm going to be writing monad-heavy code then I like do - that's partly because as a 'normal form' it's useful for spotting stuff for further factoring though
09:01:09 <AlexSuraci> The error I get: http://sprunge.us/QVDi?
09:01:37 <Twey> Philippa: Yeah, avoiding IO seems kind of hard :-\
09:02:39 <dsrogers> I could go on.... Hamlet was about a programmer; didn't you know?
09:02:48 <Philippa> there're ways and means. What happens in the long run is you get much better at modular programming
09:03:29 <Twey> Philippa: I asked for some common design patterns of that type earlier
09:03:34 <Twey> But didn't get anything
09:03:40 <Twey> Don't suppose you could spare some?  :)
09:04:00 <Saizan_> AlexSuraci: to be able to use (==) on the elements of the list they must be an instance of the Eq typeclass, so you've to put that in the type
09:04:18 <AlexSuraci> Saizan_: How would that look?
09:04:22 <Saizan_> AlexSuraci: isPalindrome :: Eq a => [a] -> Bool
09:04:23 <Myoma> if you got all the best bits of C and Java you'd end up with a great language
09:04:42 <smtms> Myoma, what are the best bits of C?
09:04:47 <dsrogers> AlexSuraci: also if your function is working, you can always :t it in ghci then copy and paste.
09:04:48 <AlexSuraci> Saizan_: Great, thanks. I don't think I've gotten that far in the book yet.
09:04:54 <Myoma> smtms: being able to define a value in terms of itsself
09:04:55 <AlexSuraci> dsrogers: Was about to try that. :P
09:04:59 <Myoma> i.e. void *x = &x;
09:05:03 <AlexSuraci> Thanks for the help.
09:05:09 <Myoma> in java that takes two lines
09:05:28 <Myoma> in haskell you have to understand Mu to do it
09:05:29 <smtms> Myoma, you don't have pointers in Java
09:05:40 <smtms> Myoma, how would you do it in Java?
09:05:56 <Myoma> differently :)
09:06:14 <Myoma> You've got references then, what ever you want to call them
09:07:52 <dsrogers> is there a way to read ghc command line arguments from within TH?
09:09:00 <smtms> Myoma, how do you define a vlue in terms of itself in Java, despite the definite assignment rules?
09:10:04 <Myoma> smtms: That's exactly what I'm talking about
09:10:09 <EvilTerran> let x = x
09:10:20 <EvilTerran> x is defined in terms of itself :)
09:10:36 <BONUS> hey guys check this out: http://hpaste.org/9893
09:10:47 <dsrogers> that particular definition is undefined
09:11:01 <dsrogers> littereally: undefined x = x
09:11:06 <EvilTerran> Myoma, do you have a use case for "void *x = &x"?
09:11:11 <BONUS> this is kind of a function for a parser but due to its type signature it works only on monad transformers
09:11:13 <dmhouse> BONUS: "do put foo; return ()" = "put foo"
09:11:30 <BONUS> but theres nothing in its contents to stop it from working on a State
09:11:53 <BONUS> any way i could make the type signature so that it could work on a State as well as a StateT
09:11:58 <BONUS> ah yeah, i sometimes forget that
09:12:14 <EvilTerran> BONUS, comment out the type sig and ask ghci?
09:12:19 <int-e> BONUS: (MonadState [c] m) => m ()  should work?
09:12:25 <int-e> oh
09:12:39 <int-e> heh, no it doesn't because it can't infer the list type
09:12:48 <BONUS> yeah hmm
09:12:59 <BONUS> thing is if i omit the type declaration, i can use end'' in a State or a StateT
09:13:15 <BONUS> however if i dont use it anywhere and omit the type declaration, i get an error
09:13:15 <EvilTerran> BONUS, what does ghci say the type is?
09:13:16 <dmhouse> Then what does :t end'' give you in GHCi?
09:13:35 <Saizan_> int-e: are you sure? the fundep should help here
09:13:58 <EvilTerran> indeed
09:14:01 <BONUS> if i try to load that function without using end'' anywhere
09:14:03 <EvilTerran> int-e's suggestion should work
09:14:04 <BONUS> i get the error
09:14:05 <int-e> Saizan_: right
09:14:09 <BONUS> No instance for (MonadState [a] t)
09:14:18 <dmhouse> BONUS: also, why are you getting and then putting back the same thing? Surely do s <- get; unless (null s) $ fail "foo" will work?
09:14:20 <EvilTerran> i was thinking the same 'til int-e said it didn't
09:14:34 <int-e> Saizan is right though. I forgot about the fundep
09:14:43 <BONUS> eh, i was overly explicit yeah
09:15:20 <int-e> EvilTerran: fwiw, I hadn't actually tried it out :)
09:15:34 <BONUS> :l state
09:15:35 <BONUS> oops
09:15:39 <BONUS> yeah w00t
09:15:42 <BONUS> int-e, that works
09:15:43 <int-e> :)
09:15:43 <BONUS> noice
09:16:27 <Philippa> Twey: sorry, got distracted. It depends a bit on what kinds of IO you're doing
09:16:37 <Saizan_> end'' without a typesign gives an error because of the monomorphism restriction
09:16:39 <Philippa> the oldest is "read everything, process, write results"...
09:16:50 <BONUS> ah
09:16:51 <BONUS> damn MR
09:16:57 <Philippa> another important one is to generate commands for IO code to execute later
09:17:07 <Philonous> @bot
09:17:07 <noBotE> :)
09:17:11 <Philonous> > ((\x -> (\x -> x)) 1 ) 2
09:17:12 <noBotE>  2
09:17:30 <Philonous> Strange
09:17:32 <Twey> Philippa: Except that I'm doing interaction with a server, and two-way concurrency :-\
09:17:54 <Philonous> Oh, actually not so strange at all
09:17:56 <Twey> Makes it kind of hard to predict
09:18:09 <dsrogers> is -fno-monomorphism-restriction dangerious?
09:18:19 <Twey> Philippa: No, not strange :)
09:18:22 <Twey> Er, Philonous
09:18:35 <dmhouse> dsrogers: not really. It might cause some things to get executed twice.
09:18:43 <Twey> 1 goes to the outer function, then 2 to the inner function, which returns it
09:18:59 <dmhouse> dsrogers: e.g. let a = <expensive computation> in (a,a) -- a is calculated twice.
09:19:00 <Philonous> Yeah, I just squinted at it the wrong way at the first time ;)
09:19:23 <dmhouse> > const id 1 2
09:19:24 <noBotE>  2
09:19:33 <Philippa> Twey: what kinds of things are you doing the interaction for? "Two-way concurrency" as in both client and server can be doing things at once?
09:20:01 <BONUS> did anyone here write All About Monads
09:20:21 <BONUS> i emailed the author because of an error there :[
09:20:32 <Twey> Philippa: Most of it is a simple forwarder
09:20:37 <dmhouse> BONUS: where's the error?
09:20:41 <Twey> Philippa: The app runs in two main threads, one connected to the server and one listening for connections locally
09:20:49 <BONUS> dmhouse: in the state monad part
09:20:52 <BONUS> it says
09:20:58 <BONUS> class MonadState m s | m -> s where
09:20:58 <BONUS> ...
09:21:01 <BONUS> but actually it's
09:21:08 <BONUS> class Monad m => MonadState s m | m -> s where
09:21:15 <Philippa> Twey: Ah, so basically the app is 90% IO anyway
09:21:21 * Twey nods.
09:21:27 <dmhouse> BONUS: oh. That needn't be the case, I don't think.
09:21:31 <BONUS> so if you try to follow along and make your own state monad and make it an instance of MonadState, you get kind errors
09:21:42 <dmhouse> Oh, really?
09:21:45 <BONUS> yeah
09:21:49 <Philippa> not much you can do about that beyond isolating the non-IO parts. I find it's helpful to use more rather than fewer threads though: it helps keep thread innards pure to the extent possible
09:21:51 <BONUS> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
09:21:53 <noBotE> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
09:21:56 <BONUS> no wait
09:21:58 <BONUS> that's not the class part
09:22:12 <BONUS> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Class.html
09:22:15 <noBotE> Title: Haskell Code by HsColour, http://tinyurl.com/4lf9ja
09:22:18 <Philippa> you end up with threads that just tightly loop the read-munge-write thing I mentioned earlier
09:22:25 <dsrogers> is there a way to lift the monomorphism restriction per-type?
09:22:31 <dsrogers> err, per function
09:23:06 <Philippa> I had an IRC client based around a design like that, with a UI thread, a "command" thread and a pile of network threads running via a synchronising 'net manager' thread the command thread talked to
09:24:59 <Twey> Philippa: Ah, that's a bit of a relief
09:25:29 <Saizan_> are there estabilished idioms for emulating extensible variants?
09:25:35 <Twey> I'm using a threads a lot and I thought someone might yell at me for that :-P  Good to know that threads are considered good design in Haskell
09:25:47 <EvilTerran> @go data types a la carte
09:25:56 <noBotE> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=1899160
09:25:57 <noBotE> Title: CJO - Abstract - Data types à la carte
09:25:58 <EvilTerran> Saizan_, have you seen that?
09:26:09 <int-e> dsrogers: not really, you have to provide an explicit type signature (which, I guess, you want to avoid)
09:26:25 <Saizan_> EvilTerran: never taken the time to read it, thanks :)
09:26:41 <EvilTerran> http://wadler.blogspot.com/2008/02/data-types-la-carte.html
09:26:41 <dsrogers> int-e: there is no common typeclass
09:26:41 <noBotE> Title: Wadler's Blog: Data Types a la Carte
09:26:47 <EvilTerran> doesn't require registration therew
09:27:30 <dsrogers> int-e: though I suppose I could create a typeclass, and some instance declarations
09:27:57 <EvilTerran> i find Swierstra's style to be a little less dense than Oleg's take on similar things
09:28:58 <dmhouse> BONUS: http://hpaste.org/9895 works for me
09:29:05 <binrapt> Hello, I'm trying to get a feeling for functional programming and I decided to check out Haskell for that purpose. What is the best document to learn Haskell in your opinion? I have lots of C++ experience mostly, but no purely functional programming languages.
09:29:07 <BONUS> really?
09:29:17 <BONUS> oh yeah
09:29:25 <BONUS> hmmmm
09:29:34 <dmhouse> ?where yaht
09:29:34 <noBotE> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:29:35 <dcoutts_> binrapt: looking for a book or something online?
09:29:37 <dmhouse> ?where rwh
09:29:37 <noBotE> is http://www.realworldhaskell.org/blog/
09:29:40 <BONUS> i thought the tutorial just gave the definition for the existing MonadState class
09:29:42 <dmhouse> binrapt: either of those
09:29:43 <binrapt> dcoutts: Oh, I meant online
09:29:53 <binrapt> dmhouse thanks
09:29:57 <sbahra> Twey, they're generally not good design if over-used ;-P
09:30:16 <dmhouse> BONUS: is my MonadState not the same as the existing one?
09:30:22 <BONUS> nope
09:30:25 <BONUS> yours is
09:30:30 <BONUS> m s | m -> s
09:30:32 <BONUS> and the existing is
09:30:34 <BONUS> s m | m -> s
09:30:41 <sbahra> Twey, haskell or not
09:30:46 <dmhouse> Oh, that's a trivial change, no?
09:30:52 <BONUS> also it hass a class restriction for Monad m
09:30:55 <BONUS> yeah but still
09:30:59 <sbahra> binrapt, I suggest a good book
09:31:05 <BONUS> its a small error, just thought i'd point it out to someone :)
09:31:08 <sbahra> binrapt, I am reading "Haskell: The Craft of Functional Programming"
09:32:06 <Twey> sbahra: Not so
09:32:14 <Twey> Well, obviously if they're 'overused' then it's bad anyway
09:32:16 <BONUS> mainly the problem is cause kind errors aren't really kidn :)
09:32:27 <qwr> binrapt: its easy, no mutable data and expressions are evaluated on-demand ;)
09:32:27 <Twey> But heavy use of threads is an interesting paradigm
09:32:32 <sbahra> Twey, so in cases where you can use asynchronous and/or non-blocking I/O, you should. :-P
09:32:38 <BONUS> so i was once trying to make an identical moand to State an instance of MonadState put i kept getting kind errors and i didnt know wtf
09:32:38 <Twey> Erlang programmers call it 'COP' -- concurrency-oriented programming
09:32:44 <T55555> I read many online doc and book. the real book lead me to Haskell is "The Craft of Functional Programming". It is slow but very detail.
09:32:45 <sbahra> Twey, network I/O is one perfect example.
09:33:20 <Twey> sbahra: What advantage does non-blocking offer over concurrency in this case?
09:33:27 <sbahra> Twey, concurrency does not require actual full-blown threads and in many cases is implemented completely in userspace
09:33:45 <Twey> Indeed
09:33:46 <sbahra> Twey, lower latency.
09:33:52 <dmhouse> BONUS: http://hpaste.org/9895
09:33:53 <Twey> I was talking about Haskell threads, obviously, not OS threads
09:33:57 <sbahra> Twey, better scalability (better throughput)
09:34:28 <sbahra> Twey, where "scalability" is mixing both above (polling and threads)
09:34:46 <BONUS> dmhouse: : hehe yeah thats what i meant
09:34:49 <qwr> sbahra: haskell threads are lightweight
09:34:54 <BONUS> although i'd add a class contraint for Monad m on MonadState
09:34:58 <BONUS> idk if you agree
09:35:16 <dmhouse> BONUS: yeah, probably.
09:35:19 <ddarius> Asynchronous/non-blocking IO tends to be event-based.  There is nothing inherent that makes event-based solutions better than thread-based solutions and in fact, they are dual.
09:35:25 <sbahra> qwr, even then, best to make use of polling mechanisms to handle several network connections than to have 1:1 threads/network
09:35:29 <dmhouse> BONUS: but that code was just there to point out that you don't need it
09:35:41 <BONUS> yeah, that's true
09:36:05 <sbahra> ddarius, in the real world, thread-based solutions (I mean purely event-driven) usually involve more overhead.
09:36:08 <dmhouse> BONUS: it's more convenient since you can do foo :: MonadState s m => m (), instead of foo :: (MonadState s m, Monad m) => m ()
09:36:11 <sbahra> ddarius, as small as that overhead may be.
09:36:26 <BONUS> dmhouse: yeah, my thoughts exactly, you can avoid class constraints later on
09:36:49 <qwr> sbahra: i think the haskell runtime uses poll or something similar anyway
09:37:14 <ddarius> sbahra: And in the real world, event-based code is usually less well-structured unless the problem perfectly fits that mold.
09:37:47 <qwr> sbahra: there shouldn't really be much more concerns than what kind of code like more. and heavy use of threading can be give suprisingly simple code
09:38:11 <sbahra> ddarius, there are also other more important issues too, IMHO, WRT performance (cache).
09:38:20 <sbahra> qwr, I agree. Threads are nice.
09:38:52 <sbahra> qwr, but you can have multiple threads each handling some number of I/O, no need to be 1:1 (and this will usually perform worse).
09:38:55 <binrapt> yaht.pdf says that Haskell frequently takes a hit in speed in comparison to conventional imperative languages such as C, why is that?
09:39:20 <Twey> binrapt: Because it's higher-level
09:39:24 <blbrown>  map (\x -> x) [5, 6, 7] ...with code like this, what is the syntax to get the index (\x,i?? -> i)
09:39:31 <BONUS> often its the laziness
09:39:35 <qwr> sbahra: but haskell uses n:m threading model. there is no 1:1 mapping of haskell threads to kernel threads
09:39:42 <Saizan_> sbahra: in GHC you can really see threads as an higher-level interface for event-based concurrency
09:39:54 <BONUS> blbrown: zip it with [0..] ?
09:39:55 <Twey> Compared to Haskell, C is practically assembly macros :)
09:40:27 <BONUS> > zip [5,6,7] [0..]
09:40:29 <noBotE>  [(5,0),(6,1),(7,2)]
09:40:49 <blbrown> BONUS: thanks
09:40:55 <BONUS> np :]
09:41:03 <sbahra> Saizan_, qwr, well, then let me restate my point as a question (I am not so familiar with haskell): Are overheads of using N threads to handle N requests in haskell less than or equal to the overhead of using a single epoll in Linux to handle N requests?
09:41:35 <sbahra> There is context management overhead, always. And you also have the benefit of being level-triggered with epoll.
09:41:42 <blbrown> BONUS: map (\(x,i) -> x) (zip [5, 6, 7]  [0..] ... something like that
09:41:42 <EvilTerran> Twey, you can drop the "compared to haskell" there, imo :P
09:41:50 <binrapt> Twey: What about C++? :)
09:41:54 <EvilTerran> C started that way, anyway, from what i recall
09:42:06 <BONUS> \(x,i) -> x is just fst
09:42:09 <Twey> binrapt: Still
09:42:11 <BONUS> but yeah
09:42:12 <EvilTerran> binrapt, C macros :P
09:42:14 <qwr> sbahra: probably not much difference
09:42:14 <binrapt> :
09:42:17 <binrapt> :\*
09:42:19 <Twey> binrapt: C++ is just C macros :-P
09:42:20 <EvilTerran> aka assembly macro macros :D
09:42:25 * Twey laughs.
09:42:29 <Twey> Oh, EvilTerran beat me
09:42:31 <Twey> Hehe
09:42:38 <EvilTerran> :)
09:42:45 <sbahra> qwr, would be interesting to quantify the difference.
09:42:57 <sbahra> I'm moving in to my apartment tomorrow, I'll try to do it sometime.
09:44:23 <Pegazus> Hi! does anyone know if there is any ide/compiler/interpreter or whatever that allows to write/rewrite the entire program while running?
09:44:36 <sbahra> s/N requests/N sessions/ is better.
09:44:56 <haskellian> anyone know the name of a python irc channel?
09:45:02 <BONUS> try #python
09:45:03 <BONUS> :]
09:45:59 <haskellian> i did nothing happens
09:46:05 <BONUS> you gotta register on freenode
09:46:07 <BONUS> first
09:46:15 <haskellian> freenode.com?
09:46:25 <BONUS> i cant remember
09:46:28 <BONUS> just do /msg nickserv help
09:46:31 <qwr> haskellian: 19:46 -!- Irssi: #python: Total of 563 nicks [1 ops, 0 halfops, 0 voices, 562 normal]
09:46:54 <haskellian> help
09:47:06 <haskellian> oin
09:47:46 <qwr> haskellian: http://freenode.net/faq.shtml#nicksetup
09:47:47 <noBotE> Title: 69a freenode: frequently-asked questions
09:49:18 <BONUS> i was thinking about recursion cause im writing something about it. anyway, would it be correct to say that the edge case is oftent he identity?
09:49:40 <BONUS> and it often helps if you want to find the edge case to think about what the identity might be and when it would be produced
09:51:47 <EvilTerran> ?users
09:51:47 <noBotE> Maximum users seen in #haskell: 831, currently: 806 (97.0%), active: 16 (2.0%)
09:52:02 <dsrogers> huh.
09:52:07 <EvilTerran> ... my client says 471...
09:52:13 <dsrogers> why does my IRC client only say 471?
09:52:29 <EvilTerran> i think noBotE is wrong. we've never had anywhere near 800 users.
09:52:44 <opqdonut> yeah i'd guess too
09:53:09 <Twey> And it says 'currently 806' when there are only 471.
09:53:19 <BONUS> hmm
09:53:22 <BONUS> let me count them manually
09:53:28 <Heffalump> perhaps it went wrong after a netsplit
09:53:35 <EvilTerran> that could be it
09:53:52 <EvilTerran> i was thinking it might be counting users in all the channels it's in or something
09:54:43 <Twey> Unless it's +i, it's only in #haskell
09:54:45 <dsrogers> noBotE knows the trouble I see/noBotE knows my sorrow
09:54:50 * Twey laughs.
09:54:57 <Jedai> BONUS: We've have had a bit more than 500 lately but never 800
09:56:05 <BONUS> yeah i remember the records always being around 500
09:57:21 <racistSpammer> vit makt! i need help
09:58:59 <FordCortina> what is a monotype?
09:59:07 <racistSpammer> jew cookout tonight http://stormfront.org
09:59:11 <racistSpammer> fucking tor
10:00:18 <haskellian> whats a valid email? gmail no go
10:00:19 <dsrogers> wtf?  I should have read that name before clicking on that link.
10:00:34 <Saizan_> it's a non-polymorphic type
10:00:51 <profmakx> that server is blocked from nrw, germany's university...
10:01:13 <Botje> "Racialist discussion board for pro-White activists and anyone else interested in White survival."
10:01:16 <Botje> riiight.
10:01:29 <Botje> at least racistSpammer was honest.
10:01:38 <dsrogers> honest hate is still hate.
10:01:43 * Twey raises an eyebrow.
10:01:45 <Twey> True that
10:02:00 <EvilTerran> i suspect the spammer may've been trying to draw the negative attention to the site
10:02:11 <EvilTerran> s/draw the/draw/
10:02:37 <dsrogers> I doubt it.
10:02:39 <EvilTerran> working against them by pretending to be one of them etcetc
10:03:01 <dsrogers> probably a bot that spammed every channel (or is spamming every channel)
10:03:39 <EvilTerran> dsrogers, indeed, but i doubt the site themselves would run such a thing
10:03:54 <dsrogers> ?  sure they would!
10:04:00 <dsrogers> or they would pay someone too.
10:04:10 <EvilTerran> OTOH, "never ascribe to malice that which can adequately be explained by incompetence"
10:04:12 <dsrogers> they probably outsource part of their recruiting efforts.
10:04:43 <Olathe> I think the guy was just a troll.
10:04:48 <EvilTerran> dsrogers, i initially figured they'd have the sense to not draw attention to themselves, seeing as they know themselves to be supporting a minority opinion
10:05:06 <dsrogers> ah.  you've never observed how they operate, then.
10:05:37 <dsrogers> look, it's just like any other organization supporting a minority opinion.
10:05:39 <EvilTerran> Olathe, yeah, that makes sense too - trying to get us bleeding heart liberals who make up most of the population of freenode to go to a white supremacy site so the troll could watch us rage
10:05:50 <EvilTerran> :P
10:06:25 <dsrogers> they need to recruit, they need to get the word out, and they have lots of competiion
10:06:54 <dsrogers> they already expect people to disagree with them, so keeping a low profile is not really the issue.
10:07:10 <Elly> if stormfront are trying to troll they're doing a really terrible job of it
10:07:37 <dsrogers> like I said, they're probably looking for members.
10:07:45 <Elly> that would be my guess too
10:07:56 <aeolist> Draconx: it seems that a type conversion is the result of either a type casting or a type coercion
10:08:29 <ddarius> wtf?  Are we on this again?
10:09:03 <Twey> On what, ddarius?
10:09:12 <Elly> what are we on?
10:09:32 <Twey> You get white-supremacist trolls regularly?
10:09:32 <dsrogers> My guess: this isn't the first time stormfront has spammed this channel
10:10:02 <Pegazus> hey haskellians! does anyone know if there is any ide/compiler/interpreter or whatever that allows to write/rewrite the entire program while running?
10:10:23 <EvilTerran> Pegazus, well, you can :r in ghci
10:10:45 <dmhouse> Pegazus: some dynamic loading of Haskell is possible, e.g. xmonad allows you to recompile your configuration file as it's running.
10:11:12 <sbahra> http://www.stormfront.org/forum/showthread.php/iran-plans-launch-humans-into-516276.html?s=670d7f10ca1ede5fc47c094e5b6e09a6&
10:11:14 <noBotE> http://tinyurl.com/44ao8s
10:11:27 <sbahra> That Iranian women is alumni of my university :-P
10:11:33 <sbahra> s/men/man/
10:12:03 <blbrown> >hoogle test
10:12:05 <Pegazus> dmhouse: but to which extent? can i stop the program in the "middle" of a function, and define a new function, and change the function currently called so it continues to call the newly created functions?
10:12:14 <blbrown> >@hoogle test
10:12:22 <ddarius> dmhouse: xmonad isn't what's allowing that.
10:12:24 <dsrogers> Pegazus: yes, if you change the source file and reload it.
10:12:42 <dmhouse> ddarius: I didn't say it was, but xmonad certainly uses whatever does allow that.
10:12:52 <dsrogers> actually, I don't know if :reload works during a debug statement
10:13:11 <ddarius> dmhouse: Actually, that exactly what you said, but perhaps not what you meant to say.
10:13:45 <dmhouse> ddarius: "xmonad allows you" meaning "it is possible within xmonad to"
10:14:27 <ddarius> The "interesting" thing xmonad does is serialize its state and then overlay the new executable over the current one and deserialize the state.  It isn't actually using anything Haskell-specific at all.
10:14:37 <Philonous> dmhouse: You mentioned a type-level fixed point operator yesterday, I thought about it but couldn't make much of it. Would you mind elaborating a little bit about that? (Or maybe recommend a paper? )
10:14:41 <ddarius> A more interesting example would be hs-plugins, GHC API, etc.
10:15:12 <EvilTerran> ?type In
10:15:13 <noBotE> forall (f :: * -> *). f (Mu f) -> Mu f
10:15:16 <EvilTerran> ?type out
10:15:17 <noBotE> forall (f :: * -> *). Mu f -> f (Mu f)
10:15:25 <EvilTerran> ?src Mu
10:15:26 <noBotE> Source not found. There are some things that I just don't know.
10:15:40 <EvilTerran> newtype Mu f = In { out :: f (Mu f) }
10:15:42 <EvilTerran> from the looks of things
10:15:55 <EvilTerran> Philonous, do you understand the value-level fixed point combinator?
10:16:08 <dmhouse> Philonous: trying to find something on haskellwiki...
10:16:11 <makt> den vita makten... ska segra!
10:16:23 <makt> den vita makten... Ã¤r bra!
10:16:33 <Philonous> EvilTerran: Well, I think.
10:16:41 <makt> MidgÃ¥rd! MjÃ¶lner!
10:16:42 <haskellian> <myname@yahoo.com> is not a valid email address. wtf?
10:16:44 <EvilTerran> makt, turing test
10:16:45 --- mode: ChanServ set +o dmhouse
10:16:48 --- kick: makt was kicked by dmhouse (Kicked by dmhouse)
10:16:55 <EvilTerran> throwing away the gratuitous syntax there, you basically get
10:16:58 --- mode: dmhouse set -o dmhouse
10:17:03 <haskellian> wtf is up with these swedish nazis, kick them off pls
10:17:07 <EvilTerran> Mu f ~~ f (Mu f)
10:17:29 <EvilTerran> where, by "~~", i mean "is isomorphic to"
10:17:31 <haskellian> the guy cant even spell, just confirms nazis=idiots
10:17:56 <Philonous> So it's basically an infinity type?
10:17:56 <EvilTerran> Philonous, and you can compare "Mu f ~~ f (Mu f)" to "fix f = f (fix f)"
10:18:02 <dmhouse> haskellian: what was he saying?
10:18:34 <EvilTerran> ... is anyone legitimate in here using tor?
10:18:45 <haskellian> white power bla bla bla
10:19:36 <EvilTerran> banning *@gateway/tor/* might work, if not
10:19:53 <dmhouse> Philonous: I think it works roughly like this:
10:19:58 <ddarius> EvilTerran: A redirect ban may be appropriate.
10:19:59 <sbahra> EvilTerran, in some countries, it is best to use tor.
10:20:05 <SamB_XP_> EvilTerran: there are several hundred in the channel ...
10:20:41 <EvilTerran> sbahra, for discussing a programming language? O.o
10:20:47 <dmhouse> Philonous: With value-level fix, you have: fact' rec n = if n == 0 then 1 else n * rec (n-1); fact = fix fact'
10:21:05 <sbahra> EvilTerran, for being able to discuss freely on IRC :-P
10:21:17 <sbahra> EvilTerran, let alone being on IRC.
10:21:28 <EvilTerran> sbahra, hm
10:21:32 <dmhouse> Philonous: with type-level Mu, you can encode recursive types. E.g. data List' rec a = Nil | Cons a (rec a), type List = Mu List'
10:21:54 <dmhouse> But that doesn't quite work because you don't have a full type-level lambda calculus
10:22:08 <dmhouse> Err, easy fix though: type List a = Mu List' a
10:22:25 <dmhouse> You can use newtype if you actually want a different type.
10:22:36 <Philonous> Ah, Mu stands for the mu-operator. I was thinking about why it was named after a chinese word -.-
10:23:03 <dmhouse> It's Î¼.
10:23:16 <mwc> Philonous: it's also used in some forms of logic
10:23:25 <ddarius> SamB_XP_: Several hundred Tor users?
10:23:26 <mwc> "Do you still beat your wife?" "Mu."
10:23:28 <SamB_XP_> dmhouse: are you sure that isn't the micro symbol ?
10:23:50 <SamB_XP_> ddarius: no, but I imagine out of those several hundred there are likely to be some legitimate tor users ...
10:23:50 <Philonous> mwc: That's the mu I meant, but it isn't the greek letter mu, is it?
10:23:56 <dmhouse> SamB_XP_: dunno, it's what C-\ greek RET m gave me
10:23:57 <ddarius> SamB_XP_: Sure.
10:23:58 <mwc> as in, the proposition is neither true nor false, as it is internally contradictory
10:24:04 <dmhouse> SamB_XP_: looks like a mu to me.
10:24:06 <mwc> Philonous: I'd write it as greek mu
10:24:15 <sbahra> EvilTerran, http://www.torproject.org/torusers.html.en
10:24:16 <noBotE> Title: Who uses Tor?
10:24:24 <mwc> in notation, but communicating with the unwashed masses, yeah, mu.
10:24:53 <Philonous> I thought it was derived from chinese (I first heard about this mu in a koan, and I don't think the Japanese use greek letters ;) )
10:25:14 <dmhouse> Yes, I think it probably came from Zen Buddhism.
10:25:18 <EvilTerran> sbahra, i am perfectly well aware of the use of tor
10:25:50 <EvilTerran> sbahra, but, if no-one in here is using it but spammers, then it seems to me that disallowing it here would be a good way to silence the spammers
10:26:09 <sbahra> EvilTerran, as well as an aspiring Haskell programmer in Syria :-P
10:26:27 <sbahra> EvilTerran, who isn't here right now ;p
10:26:39 <SamB_XP_> maybe a redirect-ban to -blah would tell us if anyone is using it legitimately?
10:26:48 <EvilTerran> sbahra, well, if it were set up as a redirect ban, they could always appeal to have it removed
10:26:55 <mwc> We should just require tor users be registered and identified
10:26:56 <EvilTerran> sbahra, and you're speaking in hypotheticals
10:27:02 <EvilTerran> i'm speaking in pragmatics
10:27:04 <ddarius> SamB_XP_: #haskell-blah is not where you want to be redirecting people to
10:27:12 <sbahra> EvilTerran, yes, I am. But I am a regular visitor of both Saudi Arabia and Syria
10:27:12 <EvilTerran> #haskell-banned?
10:27:15 <mwc> creating a new account for each spamming is a pain in the ass
10:27:16 <sbahra> EvilTerran, redirect ban sounds cool
10:27:26 <SamB_XP_> how about someplace where people are ?
10:27:30 <EvilTerran> mwc, yes, that would work
10:27:37 <EvilTerran> or help, at least
10:27:46 <mwc> EvilTerran: the kid who wants to troll won't be that bothered
10:28:01 <Philonous> EvilTerran: There allready is a channel calles #please-register for this purpose
10:28:05 <Philonous> called*
10:28:39 <EvilTerran> Philonous, ah, how handy
10:29:04 <BONUS> whats the point of the First monoid? its the same as doing `mplus` on unwrapped Maybe values
10:29:07 <EvilTerran> mwc, well, yes, but if a bot's going through each channel systematically spamming, it probably won't bother with any you need to be registered for
10:29:12 <BONUS> is it there just for explicitness or what
10:29:24 <opqdonut> ?src mplus Maybe
10:29:24 <noBotE> Source not found. Sorry about this, I know it's a bit silly.
10:29:30 * Twey laughs.
10:29:36 <EvilTerran> ?src Maybe mplus
10:29:36 <noBotE> Nothing `mplus` ys = ys
10:29:36 <noBotE> xs      `mplus` ys = xs
10:29:36 <Twey> noBotE is much more polite than lambdabot.
10:29:48 <EvilTerran> ?src Maybe MonadPlus
10:29:48 <noBotE> Source not found. Take a stress pill and think things over.
10:29:54 <ddarius> http://www.haskell.org/haskellwiki/IRC_channel/Management
10:29:55 <noBotE> Title: IRC channel/Management - HaskellWiki
10:29:59 <opqdonut> ?src First mplus
10:29:59 <noBotE> Source not found. Sorry about this, I know it's a bit silly.
10:30:09 <mwc> @vixen
10:30:10 <noBotE> ?
10:30:32 <mwc> who gave lambdabot the funectomy :)
10:30:38 * ddarius hasn't been registered for over six years.
10:30:47 <opqdonut> BONUS: yeah for completeness
10:30:55 * mwc runs off to poach ddarius's nick
10:31:01 <opqdonut> data.monoid has all the different possible maybe monoids
10:31:11 <BONUS> ah yeah, that's what i thought
10:31:12 <opqdonut> the Maybe MonadPlus instance just happens to mirror one of them
10:31:24 <EvilTerran> ddarius, it'd only be for folks who're unregistered *and* using tor
10:31:58 <BONUS> why is there a MonadPlus at all then, really?
10:32:12 <BONUS> why not just make a monad an instance of Monoid instead of MonadPlus
10:32:17 <EvilTerran> because people hadn't thought of Data.Monoid when Control.Monad was written
10:32:22 <BONUS> ah, i see
10:35:10 <binrapt> Which paradigm(s) will the future main general purpose programming language feature, in your opinion?
10:35:51 <ddarius> binrapt: OO
10:36:11 <Ugarte> screw you, ddarius . I hate OO.
10:36:29 <ddarius> Ugarte: The question isn't what does Ugarte want.
10:36:32 <Ugarte> haha
10:36:34 <binrapt> Will it be imperative? Does the future belong to functional programming languages? Or a completely different approach?
10:36:35 <Ugarte> Yeah. I agree with you.
10:36:52 <BONUS> i think we're not going to have that anymore
10:36:55 <Ugarte> binrapt: One interesting thing, I think (granted, I have a narrow view) is that C# has a bunch of pseudo-functional influences.
10:37:00 <BONUS> new languages focused on single paradigm
10:37:01 <BONUS> s
10:37:03 <Ugarte> But they're also getting into trouble by mixing paradigms.
10:37:19 <BONUS> why not mix and match paradigms?
10:37:22 <BONUS> python does that
10:37:23 <ddarius> The next big mainstream language is not going to be very different from the current ones.
10:37:24 <Ugarte> E.g., Parallel LINQ introduces a new class of bugs because purity is not enforced.
10:37:27 <BONUS> and it's really good and successful
10:37:28 <Ugarte> BONUS: Same thing as my example above.
10:37:49 <Ugarte> Functional idioms (like implicit parallelization or lazy evaluation) mixed with imperative idioms causes bugs.
10:37:57 <ddarius> It may include more functional aspects, but it's still going to look and feel a lot like Java/C#
10:38:01 <BONUS> eh, i don't know
10:38:02 <Ugarte> I still prefer having those features available to not, but it lets you shoot yourself in the foot.
10:38:09 <Ugarte> ddarius: Sure, true.
10:38:13 <BONUS> in python you usually have less bugs when using a functional style
10:38:20 <BONUS> you just can't rely on stuff being pure
10:38:26 <BONUS> but you can still think functionally kind of, imho
10:38:32 <Ugarte> BONUS: Right, and that's where the problem lies, to some extent.
10:38:59 <Ugarte> It's not the end of the world, but going half-ass towards a functional style doesn't give all the gains of going full-ass.
10:39:04 <ddarius> What I'm hoping for is a mainstream language that has immutable variables by default (though easily made mutable).
10:39:10 <Ugarte> ddarius: F#.
10:39:12 <ddarius> But I don't expect that in the next iteration.
10:39:14 <BONUS> but then again, you don't get all the drawbacks of going fully functional
10:39:21 <Ugarte> Erik Meijer claims that's idiotic.
10:39:25 <Ugarte> Then again, he's a bit of a rabble rouser.
10:39:26 <BONUS> python takes advantage of higher order functions a lot
10:39:27 <BONUS> and generators
10:39:41 <BONUS> and i dont see those uses producing any more bugs
10:40:08 <ddarius> Ugarte: Call me when F# is mainstream.
10:40:09 <Ugarte> ddarius: Meijer claims that F# et al. *limit* functionality, whereas Haskell extends it by providing a way to be functional and stateful. I think that's a weird argument insofar as you can implement monads in F# if you want to.
10:40:23 <kpreid> ddarius: do you really mean just immutable variables, keeping mutable data structures?
10:40:26 <Ugarte> But you don't get language-level support.
10:40:49 <Ugarte> ddarius: Plus, the .NET libraries hardly feel functional. That matters.
10:40:55 <Ugarte> *shrug*
10:41:04 <ddarius> kpreid: No, I mean instead of having 'const' declarations one has 'mutable' declarations e.g. as in O'Caml (and probably F# as well)
10:41:04 <Ugarte> I think it's going to bemore mainstream than Haskell very shortly, if it isn't already.
10:41:15 <Ugarte> Being built into Visual Studio, etc, means all those programmers are going to use it.
10:41:18 <ddarius> Ugarte: More mainstream than Haskell isn't saying much.
10:41:22 <kpreid> ddarius: yes, that's what I meant.
10:41:22 <Ugarte> ddarius: Sure.
10:41:26 <mwc> Ugarte: doubt it. It lacks {}
10:41:31 <Ugarte> heh
10:41:31 <kpreid> ddarius: help us make E mainstream then :-)
10:41:36 <Ugarte> mwc: Doesn't VB lack {}?
10:41:44 <mwc> Ugarte: touchÃ©
10:41:50 <Ugarte> ?
10:42:05 <mwc> Ugarte: the fencing term. I admit you have me.
10:42:13 <Ugarte> Ah. You used the accented "e", eh?
10:42:18 <Ugarte> My client can't display that, so I saw "touch?"
10:42:22 <Ugarte> Sorry.
10:42:25 <mwc> Ugarte: bad habit amount canadians ;)
10:42:27 <Ugarte> heh
10:42:39 <mwc> Damn french immersion primary schooling
10:43:39 <haskell> Hello.
10:43:43 <Ugarte> ddarius: But at what point do you say a language is "multi-paradigm" or not? Yeah, C# looks like C#/Java still, but it has type inference and map/reduce/list comprehensions.
10:43:53 <Ugarte> Python has higher order functions, lambda, etc, but still looks like Python.
10:44:07 <Ugarte> I wouldn't call either one functional, but...
10:44:11 <Philonous> ddarius: I compared search counts for languages in google trends, and there was only one language even visible on the graph - java.
10:44:27 <haskellian> hello haskell
10:44:32 <BONUS> im just saying that with modern languages, thinking about paradigms doesnt really hold so well as it used to
10:45:13 <haskellian> If Haskell doesn't get more popular it is not because the ideas are wrong but because too many of them have been adopted by other languages
10:45:16 <ddarius> Ugarte: I'd call both C# and Python object-oriented.
10:45:19 <binrapt> BONUS because it's non-desirable to keep it paradigmatically pure?
10:45:25 <Ugarte> ddarius: Would you call OCaml object-oriented?
10:45:29 <ddarius> Ugarte: No
10:45:31 <haskellian> Python is OO with first-class functions
10:45:51 <BONUS> yeah, cause it really doesnt make sense much
10:45:56 <BONUS> you can write very functional python
10:45:57 <Myoma> java is such an awesome language
10:45:59 <Ugarte> ddarius: Why not? It has objects, interfaces, inheritance, etc.
10:45:59 <BONUS> or very procedural
10:46:01 <ddarius> Smalltalk has first class functions and Smalltalkers don't at all claim to be anything other than OO
10:46:07 <haskellian> Python makes me very productive, so intuitive and easyt o use, wish it had soem of haskells typesystem though
10:46:10 <BONUS> or very OO, making class inheritance trees etc.
10:46:22 <Myoma> if you care about language design, java should be right up there in the top 10
10:46:33 <BONUS> you mean top 10 worst languages?
10:46:38 <Myoma> lol
10:46:39 <haskellian> myoma: why? it is verbose and unexpressive
10:46:53 <BONUS> also the generics system is a downright mess in java
10:47:05 <BONUS> and dont get me started on wildcards in java generics and such
10:47:08 <BONUS> its just a complete mess
10:47:13 <ddarius> Ugarte: I might call O'Caml multiparadigm, but I wouldn't call it object-oriented.
10:47:26 <Myoma> ddarius: you know what the O stands for ?
10:47:40 <haskellian> i write fairly functional python, not 100% pure but pretty pure and then I use classes when it makes sense. In Python I can jsut write code that fits the problem insetad of being forced to think ina certain way
10:47:40 <BONUS> python3k will be, in my opinion, one of the best designed languages
10:47:52 <BONUS> also i like haskell's design a lot
10:47:58 <BONUS> haskellian: yeah, exactly my thinking
10:48:10 <Ugarte> haskellian: I never can find a case where classes make sense.
10:48:20 <BONUS> however, the more i use haskell, the more functional my python code becomes because i've gotten used to thinking in haskell
10:48:33 <Philonous> ddarius: Isn't Ocaml just Caml with objects half-heartedly crafted into it? Like C++ compared to C?
10:48:33 <Myoma> Ugarte: GUI library
10:48:43 <Ugarte> Ahh, good example.
10:48:51 <BONUS> also, stuff like Django
10:48:56 <Myoma> Philonous: why "half-heartedly"? I think they've done a _very_ good job
10:48:56 <Ugarte> OK, not never. And my day job is C#, so everything is a class.
10:49:01 <Ugarte> But OO is way overused, IMO.
10:49:04 <BONUS> having a Model class that defines kind of a databas
10:49:04 <BONUS> instance Monoid (Maybe a) where
10:49:04 <BONUS>     mempty = Nothing
10:49:04 <BONUS>     mappend Nothing m = m
10:49:04 <BONUS>     mappend m _ = m
10:49:05 <BONUS>     mappend _ _ = Nothing
10:49:06 <mwc> Philonous: that's not entirely fair. They integrated them into the type system very well
10:49:07 <BONUS> whoops
10:49:07 <stepcut> Philonous: except in O'Caml is is even easier to program using the non-Object part of the system than it is in C++
10:49:09 <BONUS> how did that get pasted
10:49:14 <BONUS> my apologies
10:49:25 <mwc> BONUS: x-selection buffer paste?
10:49:30 <BONUS> could be
10:49:36 * stepcut has never written a program that used the O part of O'Caml
10:49:57 <Philonous> Don't get me wrong, I like ocaml, but I found the objects clumsy to use
10:50:02 <Ugarte> stepcut: That was kind of my point. The object support is mostly ignored, but it's there and, if anything, more fully-featured than PYthon's.
10:50:17 <Ugarte> So why is OCaml considered functional and Python OO?
10:50:23 <Ugarte> I agree with the categorization, but it seems a bit arbitrary.
10:50:29 <BONUS> python isnt considered OO
10:50:29 <BONUS> imho
10:50:33 <Myoma> Philonous: yeah, well that's not a fault of Ocaml, that's OO in general
10:51:11 <Ugarte>  Myoma The object syntax in OCaml is prety shitty, but then it's OCaml, and the entire syntax is shitty.
10:51:14 <stepcut> Ugarte: well, in part because OCaml is derived from the ML family, which is always functional, but typically not OO
10:51:23 <Ugarte> True.
10:51:25 <BONUS> java is OO because you pretty much have to solve every problem by using the OO methodology
10:51:28 <BONUS> in python, you don't have to
10:51:50 <ddarius> Ugarte: You can write serious code in O'Caml without dealing with the objects at all, the same is not particularly true for Python.  Vice versa with s/objects/functional code
10:51:54 <BONUS> for fun i wrote a filter function in Java ... you should have seen how verbose its usage was, haha
10:52:03 <Ugarte> hmm, '
10:52:19 <Ugarte> That's true, ddarius, but Ruby you can avoid using objects, yet Ruby is aggressively OO.
10:52:26 <Ugarte> IMO.
10:52:30 <haskellian> I think Guid van Rossum would say Python is OO/multi-paradigm
10:52:39 <BONUS> ddarius: when you say that, do you mean making classes and such in python or just the fact that everything is an object
10:52:48 * sioraiocht says that Python is evil.
10:52:49 <haskellian> he wanted to eliminate filter/map/reduce and lambda
10:52:56 <Ugarte> Isn't there some philosophy that says that all human attempts to classify ideas are faulty?
10:53:03 <stepcut> Ugarte: also, in O'Caml 3000, there is no debate about whether lambda and reduce should be dropped ;)
10:53:08 <BONUS> GvR isnt a big fan of fp, thats true
10:53:12 <Ugarte> stepcut: Haha!
10:53:15 <Ugarte> nice.
10:53:26 <dsrogers> what is the purpose of "report" in TH?
10:53:27 <Myoma> I like ocaml syntax
10:53:40 <Ugarte>  Myoma ?!
10:53:42 <Myoma> You can tell it's Ocaml immediately
10:53:51 <Nafai> sioraiocht: Unfortunately I'm most productive in Python because of the libraries and stuff. :(
10:54:06 <Myoma> It's not that easy when you have a page of ruby/perl/python/javascript/C/C# and you don't know what it is
10:54:11 <Ugarte> Myoma: That's like saying you like having it burn when you pee 'cause you can tell it's VD immediately.
10:54:18 <BONUS> you can also tell when someone farts immediately but that doesnt mean i like it
10:54:24 <BONUS> haha
10:54:32 <Ugarte> High five, BONUS !
10:54:36 <BONUS> ^5
10:54:36 <BONUS> w00t
10:54:39 <BONUS> btw whats that smell
10:54:48 <Myoma> Ugarte: I like my compiler to signal type errors because I can tell I have bugs immediately ...
10:55:11 <BONUS> yeah thats the age old static vs. dynamic typing debate hehe
10:55:14 <Ugarte> Nafai: Definitely. I've been doing some Python lately, and the time I lose with runtime bugs that would've been caught with static typing is more than saved by having a ton of useful libraries.
10:55:21 <Ugarte> Ideally, of course, I'd have the libs AND the typing.
10:55:22 <BONUS> each way has its pros and cons
10:55:25 <Ugarte> But you can't have both.
10:55:34 <ddarius> Myoma: You really have trouble knowing what kind of file you opened?
10:55:35 <BONUS> with python you have to do more unit tests
10:55:49 <BONUS> and have more test coverage in general
10:55:58 <BONUS> but then you have a lot of test coverage, which is good!
10:56:51 <mwc> I think the static typing and unit testing are complimentary
10:56:58 <shapr> me too
10:57:03 <mwc> static typing ensures that the internal structure of a module is consistent
10:57:08 <BONUS> eh idk
10:57:14 <haskellian> I came from c++ and java to python then I appreciated dynamic typing, then I tried Haskell and now I wish Python had Haskels typesystem
10:57:15 <mwc> unit testing is for verifying the external interface of a module
10:57:17 <Myoma> ddarius: my editor can't even tell between perl or proloog ...
10:57:18 <BONUS> dynamic typing lends itself to easier mock object making
10:57:34 <Ugarte> Also, the class of bugs found with unit testing and with static typing are not completely overlapping.
10:57:37 <Ugarte> By any stretch.
10:57:44 <haskellian> I think haskell got most of the typesystem right, statically typed but optional declarations and an interpreter than can tell you the types if you ask it
10:57:44 <Myoma> hi shapr
10:57:49 * shapr hugs Myoma 
10:57:59 <BONUS> you can make a mock class really quickly that just has one method that always reports the same thing, so you know you're testing only one part of the systme
10:58:00 <EvilTerran> BONUS, for that we have (error "TODO") :P
10:58:02 <mwc> Man, I want unicode in haskell (Î» r -> Ï * r ^ 2)
10:58:06 <BONUS> hehe
10:58:18 <EvilTerran> mwc, -XUnicodeSyntax?
10:58:21 <Myoma> mwc: just pipe your code through sed
10:58:31 * byorgey_ throws quilted lambdas at shapr
10:58:35 <Myoma> shapr, today is lazy sunday :)
10:58:39 <mwc> EvilTerran: heh, think it's too late to go pester the Haskell' fold ;)
10:58:49 <shapr> I'm getting ready to do unicycling and contact juggling at MIT.
10:58:56 <EvilTerran> mwc, although it would then be (Î» r â Ï * r ^ 2)
10:59:03 <mwc> contact jugling? sounds violent
10:59:05 <dons> mwc, i think that's supposed to work.
10:59:10 <BONUS> i heard Haskell' is gonna drop the fail function from Monads :(
10:59:13 <BONUS> is that true guyse
10:59:17 <mwc> BONUS: I hope so
10:59:19 <EvilTerran> BONUS, good news if it is
10:59:21 <byorgey_> it better be
10:59:24 <BONUS> hmm
10:59:24 <mwc> it should be in MonadZero
10:59:25 <shapr> mwc: http://www.youtube.com/watch?v=nFzp_sMDfUc
10:59:25 <noBotE> Title: YouTube - Contact juggling (sphere play) by Brad
10:59:27 <Myoma> shapr: is that a degree now?
10:59:29 <byorgey_> fail is fail
10:59:31 <dons> BONUS: you heard that?
10:59:34 <EvilTerran> BONUS, fail should be in MonadPlus/MonadZero if it exists at all
10:59:37 <shapr> Myoma: hah, no, but that's a great idea
10:59:40 <BONUS> well
10:59:40 <BONUS> read
10:59:52 <mwc> ie, a monadadic action containing a non-exhaustive match is MonadZero m => ..., not Monad m =>
11:00:00 <dons> fail leads to a lot of fail.
11:00:03 <BONUS> i know its not in the formal Monad definition but i find failing with a string of why the failure happened useful
11:00:05 <EvilTerran> shapr, oh, i've seen someone doing that. that stuff looks really cool.
11:00:16 <BONUS> whereas mzero is just mzero, doesn't report any kind of string
11:00:17 <BONUS> idk
11:00:22 * Myoma did a lot of ball and some club juggling but never managed to unicycle
11:00:33 <shapr> Myoma: If you ever visit Boston, I'll teach you.
11:00:42 <Myoma> that was impressive (video)
11:00:51 <shapr> I can't do all of that :-)
11:00:52 <EvilTerran> BONUS, you could have something like class Monad m => MonadZero m where mzero = fail "mzero"; fail _ = mzero
11:01:13 <BONUS> hmmm
11:01:22 <EvilTerran> BONUS, so, if your monad can actually use the parameter to fail, you just have to implement fail (eg, fail = Left for Either)
11:01:23 <byorgey_> BONUS: maybe fail with a string param should be a method of MonadError
11:01:27 <blbrown> take 3 "123456" ... what would the function be to get the '456' values
11:01:33 <BONUS> yeah maybe
11:01:37 <EvilTerran> and, if it can't, you can just implement mzero (eg, mzero = Nothing for MaybE)
11:01:43 <Beelsebob> blbrown: drop 3
11:01:44 <olsner> > drop 3 "123456"
11:01:45 <EvilTerran> blbrown, er, drop 3?
11:01:45 <noBotE>  "456"
11:01:54 <BONUS> cause i like the property that you can do fail "some message" and you get a Left "some message" or a Nothing
11:02:06 <BONUS> or you can make your own error reporting type
11:02:07 <EvilTerran> > splitAt 3 ['1'..'6'] -- this is also useful
11:02:08 <noBotE>  ("123","456")
11:02:20 <mwc> @quickcheck n xs -> xs == (take n xs) ++ (drop n xs)
11:02:20 <noBotE> Unknown command, try @list
11:02:28 <mwc> @qc n xs -> xs == (take n xs) ++ (drop n xs)
11:02:28 <EvilTerran> BONUS, indeed. that's why i like my suggestion - you can use the string if you want, or not if you don't want
11:02:28 <noBotE> Not enough privileges
11:02:49 <EvilTerran> @check \n xs -> xs == take n xs ++ drop n (xs :: [Int])
11:02:50 <noBotE>  OK, passed 500 tests.
11:03:15 <EvilTerran> @check \n xs -> splitAt n xs == (take n xs, drop n (xs :: [Int]))
11:03:16 <noBotE>  OK, passed 500 tests.
11:03:26 <mwc> thanks
11:03:31 * EvilTerran feels his brain cry out for pointsfree
11:03:33 <mwc> I was trying to point out the identity there
11:03:40 <BONUS> EvilTerran but doesnt that disregard the error string?
11:03:58 <BONUS> just ends up being mzero
11:04:04 <Twey> @pl \a -> b a >>= c a
11:04:04 <noBotE> liftM2 (>>=) b c
11:04:12 <EvilTerran> BONUS, the desugaring would still use fail
11:04:23 <BONUS> ah
11:04:37 <EvilTerran> BONUS, and any instance of MonadZero could replace the default implementation of fail with one that retained the error string
11:04:43 <BONUS> oh i see
11:04:57 <BONUS> so Either String could be made an instance and have such an implementation that it keeps the message
11:05:14 <EvilTerran> but an instance that didn't use the error string could just replace the default implementation of mzero, and have fail do what you mean
11:05:15 <BONUS> that sound kewl
11:05:46 <Myoma> BONUS, iirc Error = Either String
11:05:56 <Myoma> oh
11:06:03 <Myoma> right that's what everyone was talking about
11:06:14 <EvilTerran> Myoma, heh, i hate it when that happens
11:06:17 <BONUS> yeah, Error is a class
11:06:27 <EvilTerran> BONUS, that's MonadError
11:06:36 <BONUS> um
11:06:45 <BONUS> ?src Error
11:06:46 <noBotE> class Error a where
11:06:46 <noBotE>     noMsg  :: a
11:06:46 <noBotE>     strMsg :: String -> a
11:06:50 <Twey>  There's a built-in function defined as (flip ($)), isn't there?  What is it?
11:07:25 <mwc> Twey: try hoogling for the type
11:07:41 <mwc> @type (flip ($))
11:07:42 <noBotE> forall a b. a -> (a -> b) -> b
11:07:53 <mwc> @hoogle a -> (a -> b) -> b
11:07:53 <noBotE> A Hoogle error occured.
11:07:57 <mwc> :(
11:07:59 * Twey chuckles.
11:08:00 <Twey> Or not
11:08:09 <Twey> Hmm
11:08:17 <Twey> :t ($!)
11:08:18 <noBotE> forall a b. (a -> b) -> a -> b
11:08:18 <EvilTerran> BONUS, er... i stand corrected. yeah, that's involved in the MonadError instance for Either
11:08:28 <Twey> Er?
11:08:31 <Twey> :t ($)
11:08:32 <noBotE> forall a b. (a -> b) -> a -> b
11:08:36 <Twey> @src ($!)
11:08:37 <noBotE> f $! x = x `seq` f x
11:08:41 <Twey> Oh, strict o.@
11:08:42 <BONUS> yeah hehe
11:08:50 <Twey> Well, that's not it
11:08:51 <EvilTerran> BONUS, actually, because fail is in Monad, it's involved in the Monad instance for Either, too
11:09:00 <EvilTerran> Twey, i don't think there is one
11:09:05 <BONUS> yeah
11:09:06 <Twey> Oh :-\  OK
11:09:11 <Twey> Thanks
11:09:16 <BONUS> fail = Left
11:09:25 <EvilTerran> there's (>>>), which is flip (.) for the (->) instance of Arrow
11:09:41 <EvilTerran> BONUS, actually, it's "fail = Left . strMsg"
11:09:51 <EvilTerran> hence the need for that class
11:09:54 <EvilTerran> "need"
11:09:59 <Twey> Mmhm
11:10:19 * EvilTerran wonders if there's a unicode character that looks like a flipped $
11:10:20 <BONUS> oh yeah, exactly
11:10:23 <ski> (`fail' should not be in `Monad' ..)
11:10:27 <BONUS> and for String, strMsg is just id, right?
11:10:34 <EvilTerran> ?src String strMsg
11:10:34 <noBotE> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:10:40 <EvilTerran> ... yes, iirc.
11:10:55 <EvilTerran> > strMsg "test"
11:10:56 <noBotE>  Add a type signature
11:10:59 <EvilTerran> > strMsg "test" :: String
11:11:00 <koninkje> @src strMsg
11:11:00 <noBotE> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:11:00 <noBotE>  "test"
11:11:15 <EvilTerran> @check (==) `ap` strMsg
11:11:17 <noBotE>  OK, passed 500 tests.
11:11:17 <bjrn> New bot?
11:11:33 <Myoma> I meant the error monad
11:11:36 <Myoma> @instances Monad
11:11:37 <noBotE> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:11:41 <ski> `fail' should not be in `MonadZero' either .. it might be in a `MonadFail', maybe a subclass of `MonadZero'
11:11:42 <Saizan> bjrn: different incarnation
11:11:45 <EvilTerran> ("ap (==)" is pointsfree speak for "is the identity function")
11:11:57 <Myoma> oh right, it doesn't exist
11:12:01 <Myoma> well that settles that
11:12:03 <bjrn> Saizan: Ah ok
11:12:17 <EvilTerran> Myoma, there's MonadError and ErrorT, but no Error - that's called Either
11:12:50 <EvilTerran> ski, i guess so, yeah - would the do{} desugaring use MonadFail, in that case?
11:12:57 <Saizan> ski: does it hurt having it in MonadZero?
11:12:59 <kpreid> @instances MonadError
11:12:59 <noBotE> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
11:13:12 <kpreid> hm, no Maybe?
11:13:24 <ski> Saizan : hm .. maybe not
11:13:39 <EvilTerran> kpreid, MonadError is only for things that retain the error, i believe
11:13:46 <ski> EvilTerran : in the case of refutable pattern-matches in the bind, yes
11:14:13 <EvilTerran> MonadException or MonadShortCircuit or something would be better names for MonadError, IMO, but rather verbose
11:14:16 <BONUS> so id you used a do block, you'd have to make it MonadFail?
11:14:18 <BONUS> or something else?
11:14:28 <BONUS> MonadShort
11:14:28 <BONUS> hehe
11:14:31 <EvilTerran> BONUS, only if you have a refutable pattern on the left of a <-
11:14:37 <EvilTerran> ... MonadEscape?
11:14:38 <BONUS> hmm
11:15:03 <EvilTerran> BONUS, as in, if you pattern-match on a constructor instead of just having a variable name on the left of a <- anywhere
11:15:13 <EvilTerran> (~ patterns notwithstanding)
11:15:16 <BONUS> yeah
11:15:23 <BONUS> so i guess also if you had the do let binding?
11:15:32 <EvilTerran> i don't think those use fail
11:15:35 <BONUS> do {let blah = 4;return 100}
11:15:42 <BONUS> they don't? hmm lemme check
11:15:45 <ski> (also, for this to be comfortable, tuple patterns should be considered irrefutable .. i don't recall if that's the case currently)
11:15:56 <EvilTerran> > do let x:xs = []; return x :: [Int]
11:15:56 <noBotE>  Parse error at "::" (column 28)
11:16:05 <EvilTerran> > do let { x:xs = [] }; return x :: [Int]
11:16:06 <noBotE>   Irrefutable pattern failed for pattern x : xs
11:16:27 <EvilTerran> > do let { Just x = Nothing }; return x :: [Int] -- maybe it's clearer if i don't re-use the same type for different things
11:16:28 <noBotE>   Irrefutable pattern failed for pattern Data.Maybe.Just x
11:16:44 <BONUS> tuple patterns aren't considered irrefutable already?
11:16:50 * ski has used `do ...; <pat> <- return foo; ...' many times, because of that
11:16:51 <BONUS> (a,b) is pretty irrefutable
11:16:52 <EvilTerran> > do let Just x <- return Nothing; return x :: [Int] -- while this is approximately equivalent but uses fail
11:16:52 <noBotE>  Parse error at "<-" (column 15)
11:17:01 <EvilTerran> > do Just x <- return Nothing; return x :: [Int] -- whups
11:17:02 <noBotE>  []
11:17:35 <EvilTerran> > (\(_,_) -> "this fails") undefined
11:17:36 <noBotE>  "Exception: Prelude.undefined
11:17:43 <EvilTerran> > (\ ~(_,_) -> "this doesn't") undefined
11:17:44 <noBotE>  "this doesn't"
11:18:03 <BONUS> hmm
11:18:06 <BONUS> that shouldnt fail imho
11:18:07 <BONUS> the first one
11:18:17 <EvilTerran> BONUS, it'd be a weird special case if any constructor of a type with only one constructor was implicitly irrefutably matched
11:18:38 <BONUS> hmm yeah
11:18:46 <EvilTerran> OTOH, i wouldn't entirely mind the patterns in \s being implicitly irrefutable, but that's a whole other kettle of fish
11:18:47 <BONUS> but it makes sense because the typechecking makes sure it's a tuple
11:19:07 <Jedai> BONUS: No, it is not a question of typechecking
11:19:08 <koninkje> and single constructor types are already special cased
11:19:14 <BONUS> hmm
11:19:15 <EvilTerran> koninkje, they are?
11:19:32 <koninkje> EvilTerran: for things like unboxing and other optimizations, yes
11:19:42 <BONUS> data too or just newtypes?
11:19:45 <EvilTerran> ah, yes. that's implementation, not semantics, though :P
11:19:54 <koninkje> semantically I don't recall them being so
11:19:57 <Jedai> BONUS: the pattern indicates we want a tuple, not undefined (it could contain some undefined data since we don't specify it)
11:20:00 <ski>   data Foo = F Int
11:20:12 <ski> `F undefined' is not the same as `undefined'
11:20:27 <EvilTerran> @wiki newtype
11:20:27 <noBotE> http://www.haskell.org/haskellwiki/newtype
11:20:28 <koninkje> EvilTerran: but for what semantic reason should single construtor types _not_ be irrefutable?
11:20:33 <BONUS> aha, i see
11:20:43 <EvilTerran> koninkje, consistency with multi-constructor types?
11:21:11 <koninkje> A modest proposal: http://winterkoninkje.livejournal.com/56979.html
11:21:12 <noBotE> Title: winterkoninkje: For Want of Difference Types
11:21:25 <EvilTerran> it'd be weird if "(\Nothing -> ...) undefined" failed but "(\() -> ...) undefined" worked
11:21:48 <koninkje> EvilTerran: why? it makes sense to me
11:21:53 <ajdhs> is anyone here familiar with the editline package?
11:22:26 <koninkje> EvilTerran: Why should (\[] ->...) succeed but (\(x:xs) ->...) fail?
11:22:36 <ajdhs> specifically, is it possible to link it against readline instead of editline?
11:23:09 <EvilTerran> koninkje, for the same reason (\ ~[] -> ...) works but (\ ~(x:xs) -> ...) fails (well, may fail) now?
11:23:46 <EvilTerran> koninkje, i agree, from a consistency point of view, making \ patterns implicitly irrefutable would be bad
11:23:47 <koninkje> EvilTerran: You've just made them irrefutable explicitly, they can still fail
11:24:08 <EvilTerran> but not as bad as making single-parameter types implicitly irrefutable
11:24:13 <stepcut> are there any tutorials on actually using Data.Reactive which include some examples?
11:24:14 <EvilTerran> single-constructor, even
11:24:26 <koninkje> I'm not suggesting that lambda patterns should be irrefutable, they shouldn't. But single constructor types have no reason for not being irrefutable, imo
11:24:32 <EvilTerran> see, i'm vice-versa
11:25:15 <koninkje> Making lambdas irrefutable is generally a bug IME
11:25:23 <ddarius> stepcut: I wrote a very simple IRC bot using Reactive that's on hpaste.
11:25:24 <sioraiocht> @src foldl
11:25:24 <noBotE> foldl f z []     = z
11:25:24 <noBotE> foldl f z (x:xs) = foldl f (f z x) xs
11:25:40 <stepcut> ddarius: sweet! Because that is what I want to use reactive for ;)
11:25:55 <ddarius> @google site:hpaste.org ReactiveIRC
11:25:56 <noBotE> No Result Found.
11:26:00 <EvilTerran> if you make single-constructor types implicitly irrefutable, the irrefutability of the pattern is affected by spooky action-at-a-distance
11:26:04 <koninkje> ajdhs: I'm thinking noone here is familiar with that package. sorry
11:26:23 <ddarius> http://hpaste.org/8723
11:26:27 <ajdhs> ah well
11:26:29 <EvilTerran> in that the number of constructors, ie the data decleration, which may even be in another file, affects how the pattern matches
11:26:44 <EvilTerran> while, if \ patterns were irrefutable, you could tell that just by noting that it's a lambda
11:26:49 <koninkje> EvilTerran: what's so spooky?
11:27:02 <stepcut> ddarius: cool
11:27:13 * sioraiocht finds destroy/unfoldr fusion very difficult
11:27:14 <EvilTerran> koninkje, the fact that a pattern that previously worked suddenly stops working if you add a constructor
11:27:26 <ddarius> sioraiocht: It's exactly like foldr/build
11:27:28 <EvilTerran> i know it's unusual to add a constructor after the fact, but i have wanted to do so occasionally
11:27:30 <koninkje> N.B. by "making single constructor patterns irrefutable" I don't mean making them lazy with ~, I just mean making them not require fail in do-notation
11:27:39 <EvilTerran> ah
11:27:40 <EvilTerran> see
11:27:47 <EvilTerran> we've been talking at complete cross-purposes
11:27:58 <ddarius> koninkje: Read the Haskell 1.4 Report
11:28:00 <EvilTerran> because "irrefutable pattern" currently means one with ~
11:28:03 <koninkje> The constructors available already affect things at a distance, that's part of the type's interface
11:28:26 <koninkje> fair enough
11:28:34 <EvilTerran> i can see your point now
11:28:36 <Myoma> koninkje: why are you mixing types with values?
11:28:40 <EvilTerran> although i'd still rather not
11:28:42 <Myoma> > f :: Nothing -> b
11:28:42 <Myoma> > g :: Just a  -> b
11:28:42 <noBotE>   Not in scope: type constructor or class `Nothing'
11:28:43 <noBotE>   Not in scope: type constructor or class `Just'
11:28:46 <Myoma> I don't understand that
11:28:51 <koninkje> Myoma: where am i doing that?
11:28:57 <Myoma> http://winterkoninkje.livejournal.com/56979.html
11:28:58 <noBotE> Title: winterkoninkje: For Want of Difference Types
11:29:00 <EvilTerran> an extra ~ really isn't that much of a hassle if you need it
11:29:29 <koninkje> Myoma: the point is not mixing them up, it's being able to take refinements of union types as types themselves
11:29:52 <koninkje> Maybe a = Nothing + Just a, therefore Maybe a - Nothing = Just a
11:30:01 <EvilTerran> koninkje, i mean, if you have a type with one constructor, "data Foo = Foo Int", say, and that were implicitly irrefutable (even just in <-s)
11:30:19 <EvilTerran> then the type of the do block with the <- in it would change if you made that "data Foo = Foo Int | FooFailure String"
11:30:28 <sioraiocht> ddarius: is it just that the recursion is in the anamorphism instead of the catamorphism is destroy/unfoldr fusion?
11:30:35 <Myoma> I don't understand that
11:30:36 <EvilTerran> which would be dire, imo
11:30:45 <Myoma> It seems like you have done arithmetic with types and values
11:30:52 <koninkje> EvilTerran: sure, if the pattern match is made lazy/irrefutable then odd things happen. I agree entirely
11:30:54 <Myoma> it only makes sense on type alone, or values alone
11:31:19 <EvilTerran> Myoma, it's a proposed extension, it doesn't work currently
11:31:41 <koninkje> EvilTerran: in terms of adding a new constructor, we have that probelem already. If someone adds a new constructor then all previous functions give only incomplete patterns
11:31:54 <EvilTerran> koninkje, yes. but it doesn't affect the types.
11:32:13 <ddarius> sioraiocht: It's just that we've switched an anamorphism for a catamorphism.
11:32:42 <tristes_tigres> @bot
11:32:42 <noBotE> :)
11:32:44 <EvilTerran> koninkje, it's natural for adding a constructor to result in existing functions becoming partial. it's not natural for their types to change as a result.
11:32:48 <sioraiocht> ddarius: ahhh, yes i see what you mean
11:32:49 <tristes_tigres> Hello
11:33:37 <EvilTerran> but, with your suggestion, adding a constructor could have a function's type change from "Monad m => ..." to "MonadZero m => ..." (or whatever)
11:33:47 <sampointon> does the RealFrac vs Fractional distinction actually get exercised much?
11:34:00 <ski> refinement types are cool
11:34:00 <Myoma> koninkje: More worryingly have to tried writing real programs with types such as  Int -> (Int \\ 0) -> Int  ?  I don't think it's practical
11:34:09 <koninkje> EvilTerran: I'm not sure I see how the types would change. The only way to give refinement types is to give proof by case-statement. Either that case statement is there or it isn't, regardless of whether new constructors are added later
11:34:31 <ski> Myoma : it can be in some cases, i think
11:34:37 <koninkje> Myoma: why is it more worrying than needing to capture divide by zero errors everywhere?
11:34:41 <EvilTerran> koninkje, er, i'm talking about single-constructor types' constructors being irrefutable in <- patterns, not difference types
11:34:42 <ski> Myoma : probably not for `Int' though
11:34:51 <koninkje> EvilTerran: ah, sorry
11:35:04 <EvilTerran> Myoma, that's what total programming languages are about. and, yes, a lot of people agree that they're impractical. :)
11:35:38 <Myoma> koninkje: ..because that's known to work
11:35:48 <Myoma> koninkje: but I haven't seen any real programs with types like that
11:35:57 <koninkje> EvilTerran: if you're not talking about difference types, I'm not sure where types changing came into play...
11:36:18 <Myoma> koninkje: I am curious about if you (or anyone) peut this idea into practical use?
11:36:23 <koninkje> Myoma: actually it's known to scale very poorly, hence the proposal
11:36:40 * tristes_tigres thinks arithmetic in Haskell is a pain
11:36:54 <tristes_tigres> no automatic promotions
11:36:56 <EvilTerran> koninkje, i was taking the implicit irrefutability in <- and the proposal to move fail into MonadZero together
11:36:57 <Myoma> tristes_tigres, the problem is that it's not possible to fix
11:37:13 <tristes_tigres> Myoma: what do you mean, impossible
11:37:16 <EvilTerran> Myoma, i've seen some very clever things done with multi-parameter typeclasses
11:37:23 <Myoma> tristes_tigres, impossible means I tried twice and I couldn't do it
11:37:36 <koninkje> Myoma: So far most of the work in this area is looking at full dependent types which are much more intractable than the difference types I was proposing. The latter is, i think, fairly new. I'd personally put it to use quite often, which is part of why I'm considering learning to hack on GHC to add it in.
11:37:45 <tristes_tigres> Myoma: if it is impossible to fix, it needs to be junked and built from scratch
11:38:10 <Myoma> koninkje: I have only seen what 2 people doing practical programming dependent types
11:38:27 <ski> koninkje : actually, partial functions can be seen as total functions with the codomain extended with a point (or both domain and codomain extended, plus requirement that `undefined' must map to `undefined') .. see the category of pointed sets
11:38:29 <EvilTerran> tristes_tigres, for instance, i've seen something to the effect of "(+) :: (Num a, Num b, LUB a b c) => a -> b -> c"
11:38:29 <ddarius> tristes_tigres: automatic conversions are evil
11:38:37 <tristes_tigres> for instance, doing / on ints should result in Fractional
11:38:46 <EvilTerran> tristes_tigres, or "(+) :: (Num a, Num b) => a -> b -> LUB a b" with type families
11:38:47 <Myoma> koninkje: It might be better to put work into that area instead of adding more features to haskell(?)
11:38:57 <koninkje> Myoma: difference types are not full dependant types, they're just refinement types. They're much more practical.
11:39:00 <EvilTerran> koninkje, well, the difference types thing sounds very cool
11:39:04 <tristes_tigres> ddarius: no they aren't for numbers
11:39:22 <tristes_tigres> what is LUB ?
11:39:23 <EvilTerran> tristes_tigres, well, only if you only coerce from a type to a genuine superset type
11:39:24 <Myoma> koninkje: I thought you said they didn't scale -- And I'm not aware of anybody having used them in real programs
11:39:27 <EvilTerran> "least upper bound"
11:39:28 <koninkje> Myoma: Consider the examples I gave in the post. Wouldn't it be nice to capture all those errors from the Prelude at compile time rather than waiting for a runtime error?
11:39:45 <ddarius> tristes_tigres: http://www.haskell.org/pipermail/haskell-cafe/2007-June/027160.html
11:39:46 <tristes_tigres> EvilTerrain: that's how it is done in C
11:39:47 <noBotE> Title: [Haskell-cafe] Re: Perl-style numeric type, http://tinyurl.com/2ctoy6
11:39:52 <EvilTerran> no it isn't
11:39:55 <koninkje> Myoma: I said the "catch exceptions because we can't tell if we'll divide by zero" solution does not scale
11:39:58 <Myoma> koninkje: not really, I mostly use haskell like an untyped language. It just keeps a close eye on my code
11:40:05 <tristes_tigres> EvilTerrain: actua;lly not always
11:40:08 <EvilTerran> int x; double y; ...; x = y // look ma, implicit coercions
11:40:34 <EvilTerran> not sure if that provokes a warning on most compilers, it might - but there's still the punning on (/) to catch you out
11:40:37 <tristes_tigres> EvilTerr: that is probably bad
11:40:47 <koninkje> Myoma: yes, but even there, difference types would let it keep a closer eye on your programs
11:40:56 <tristes_tigres> but int x double y ; y=x is good
11:40:57 <Myoma> koninkje: oh I see, exception handling actually does scale though. but anyway have you got any examples of using difference types in real programming?
11:41:31 <EvilTerran> tristes_tigres, yes, i *think*... but "int x; float y; ... y = x" isn't good, iirc
11:41:42 <EvilTerran> > maxBound :: Int
11:41:43 <noBotE>  9223372036854775807
11:41:49 <EvilTerran> > 9223372036854775807 :: Float
11:41:51 <noBotE>  9.2233721e18
11:42:12 <EvilTerran> ^ loss of precision
11:42:16 <Myoma> EvilTerral: That doesn't work in practice
11:42:25 <koninkje> Myoma: have you written much Java code? Exception handling means you have to do runtime checks everywhere, either to prevent exceptions or to capture them. That's a whole lot of boilerplate code for zero gain when the typesystem could catch the errors for you
11:42:29 <Myoma> EvilTerral: the typeclass mechanism isn't expressive enough for this to be practical
11:42:36 <Myoma> EvilTerral: It's very close though
11:42:42 <EvilTerran> Myoma, if you throw enough extensions at it, you can get something pretty usable
11:42:48 <EvilTerran> but now i have to go have dinner
11:42:50 <EvilTerran> laters
11:43:07 <koninkje> Myoma: examples? Not yet; I know of no language which offers the feature. Given the feature I could whip a few up quickly
11:43:10 <Myoma> EvilTerral: I'd like to beleive that but without being able to do it myself and not having any construtive proof.. :p
11:43:52 <tristes_tigres> ddarius: I think the authior drew wrong conclusion
11:43:54 <Myoma> koninkje: I think that is a great idea to prototype this then and try it on some real examples
11:44:37 <ddarius> Myoma: Why do you keep mistyping EvilTerran's nick?
11:44:42 <koninkje> Myoma: consider, for example, a robust solution to Haskell's record syntax woes. Namely define a type Foo that is a union of records which all share some fields but which have some fields not shared by all subtypes. This comes up daily in OS and network programming and is part of the raison d'etre behind BitC
11:44:47 <ddarius> tristes_tigres: I'm pretty sure he didn't.
11:44:53 <Myoma> darrius: I only mistyped it once
11:45:06 <Myoma> ok
11:45:11 <Myoma> I have to concentrate a bit harder
11:45:13 <koninkje> Myoma: that's my hope :) Now just to find the time among all my current projects...
11:45:37 <tristes_tigres> ddarius: his implementation of isSquare was the problem
11:45:48 <Myoma> koninkje: I am pretty skeptical but I'd like to see where this goes, will have to think about it a bit harder though
11:46:52 * tristes_tigres is quite ceertain no one who does number crucnching for a living won't consider Haskell at its present state
11:47:09 <ddarius> tristes_tigres: It worked when he added a round, but that's not the point, the point was he didn't realize this.  He was warned of exactly these issues beforehand.
11:47:10 <tristes_tigres> Haskell arithmetic is just broken
11:47:25 <Myoma> tristes_tigres: It's not broken, it's just awkward and clunky
11:47:28 <ddarius> Also my impression is that most people who care about numerics prefer explicit coercions to implicit ones.
11:47:28 <koninkje> Myoma: skepticism is a valuable skill. Personally I've run into the desire for this particular feature over and over again. In fact, the day after writing that post, when working on the ICFP competition I wanted it once again for dealing with the network packets
11:47:54 <tristes_tigres> Myoma: not  to the ridiculous extent enforced by Haskell
11:48:16 <ddarius> My personal experience doing numerical code in Haskell is that only a very few explicit coercions are needed.
11:48:27 <Myoma> tristes_tigres: that didn't make any sense
11:48:27 * koninkje cares about numerics and greatly prefers explicit coercions
11:49:37 <koninkje> tristes_tigres: Why do you think Haskell's arithmetic is broken presently?
11:50:09 <tristes_tigres> konikje: a) Too much explicit conversions b) no support for IEEE 754
11:50:18 <Botje> beause you can't do crazy shit like 15 / 2 == 7 !
11:50:28 <Myoma> > 15 / 2 == 7
11:50:29 <noBotE>  False
11:50:37 <koninkje> tristes_tigres: can you define "too much"? I find myself doing conversions only rarely
11:50:51 <bd_> > 15 `div` 2 == 7
11:50:52 <noBotE>  True
11:50:52 <Myoma> You can't do crazy shit like average list = sum list / length list
11:50:54 <opqdonut> IEEE 754 is?
11:51:06 <Myoma> that's what I dislike about it
11:51:08 <opqdonut> floating point stuff?
11:51:13 <ddarius> tristes_tigres: In my opinion, if you are coercing excessively you are doing something wrong.
11:51:14 <tristes_tigres> opqdonut: done to death yesterday
11:51:15 <koninkje> opqdonut: a spec for dealing with floating point numbers
11:51:24 <opqdonut> oh okay
11:51:25 <Toxaris> tristes_tigres: b) is a problem of course, but what is the impact of a)? in which situations do you need implicit conversions?
11:51:28 <tristes_tigres> ddarius: you haven't done much numerical work
11:51:32 <Botje> yaay battlestar galactica!
11:51:44 <koninkje> opqdonut: http://en.wikipedia.org/wiki/IEEE_754
11:51:52 <Myoma> can't you just use floats for everything?
11:51:54 <ddarius> tristes_tigres: You haven't done much numerical work in Haskell
11:52:07 <tristes_tigres> ddarius: and I won't in its present state
11:52:19 <tristes_tigres> ddarius: and neither would anyuone else
11:52:19 <trofi> (//) = `div`
11:52:28 <koninkje> tristes_tigres: I do it daily.
11:52:29 <ddarius> tristes_tigres: Plenty do.
11:52:42 <opqdonut> how does haskell deviante from IEEE 754 then?
11:53:13 <tristes_tigres> Toxaris: why do I need to write explicit conversions when I need (1::Int)/(2::Float) ?
11:53:28 <bd_> tristes_tigres: You could just do 1/(2::Float)?
11:53:28 <ddarius> > 1/2 :: Float
11:53:29 <noBotE>  0.5
11:53:32 <koninkje> tristes_tigres: Why are you mixing Int and Float?
11:53:41 <aconbere> when I try to compile Cabal I get an error about Distribution.Compiler not being found?
11:53:45 <tristes_tigres> konikje: that is my point
11:53:50 <bd_> tristes_tigres: moreover, what are the semantics of that supposed to be? Should it be done as an int overall, or float?
11:53:51 <Myoma> koninkje: average list = sum list / length list
11:53:52 <aconbere> anyone know what I should be looking for?
11:54:01 <Toxaris> tristes_tigres: why do you need to (1 :: Int) / (2 :: Float)? (I'm seriously interested which use cases exist)
11:54:03 <koninkje> tristes_tigres: for that matter, if you care so much about numeric work then why are you using Float instead of Double?
11:54:06 <bd_> :t genericLength
11:54:07 <noBotE> forall b i. (Num i) => [b] -> i Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
11:54:14 <bd_> oO
11:54:17 <bd_> well anyway
11:54:22 <Myoma> the semantics are obvious, ALGOL got this _sorted_ in 60s
11:54:23 <tristes_tigres> koninkje: I use it here for example
11:54:28 <bd_> > let l = [1.2, 4.5] in (sum l) / (genericLength l)
11:54:29 <noBotE>  2.85
11:54:30 <Japsu> ooh cool, a new error message
11:54:37 <Toxaris> > let average list = sum list / genericLength list in average [0.5, 1]
11:54:38 <noBotE>  0.75
11:54:41 <Myoma> It's clear that haskell does this wrong and the reason is that it's not possible in H98
11:54:45 <bd_> making genericLength the default is left as an exercise to the reader
11:54:53 <Myoma> whether it's possible or not in GHC I don't know, but I suspect not
11:54:54 <dcoutts_> aconbere: compiling the Cabal package itself ? not building something using Cabal?
11:55:25 <Twey> Hmn
11:55:43 <Twey> Why is it disallowed to use a section taking two arguments, like (++ " " ++) ?
11:56:09 <tristes_tigres> opqdonut: It does not implement rounding modes, flags and traps
11:56:59 <bd_> tristes_tigres: traps -> undefined?
11:57:01 <Toxaris> Myoma: wouldn't that flexible enough: class Plus a b c | a b -> c where (+) :: a -> b -> c
11:57:11 <dcoutts_> traps -> exceptions
11:57:13 <koninkje> Twey: I would presume the reasoning for disallowing them is a parsing issue
11:57:20 <Twey> Ah :-\
11:57:24 <Twey> @pl \a b -> a ++ " " ++ b
11:57:25 <noBotE> (. (' ' :)) . (++)
11:57:28 <bd_> tristes_tigres: you could define a new numeric type with whatever it is you want for support; setting global flags doesn't fit with haskell's model at all
11:57:37 <Twey> Ych
11:57:48 * Twey uses printf
11:57:49 <tristes_tigres> bd_: and that is the problem
11:57:50 <bd_> eg, say we do: do { enableTraps; let foo = somePureFloatFunction; disableTraps; print foo }
11:57:52 <dcoutts_> tristes_tigres: what operations set flags, and what kind of flags ?
11:57:56 <bd_> Now what happens?
11:58:03 <aconbere> dcoutts_: yes, just the Cabal package itself
11:58:09 <tristes_tigres> dcoutts: every arithmetic operation may set flags
11:58:19 <tristes_tigres> and invoke traps, if required
11:58:19 <abuiles> Hi Im triying to load my .hs in emacs but I get the next error "Symbol's function definition is void: switch-to-haskell"
11:58:25 <bd_> A better solution would be to wrap float with a type which carrys around exception information
11:58:34 <dcoutts_> aconbere: perhaps you can use @hpaste to show what you're doing. Cabal bootstraps using itself so it should always be able to compile.
11:58:34 <bd_> instance Num (Either FloatExcept Float) or something
11:58:38 <dcoutts_> @hpaste
11:58:38 <noBotE> Haskell pastebin: http://hpaste.org/new
11:58:45 <abuiles> I mean I want to star the interpreter
11:59:19 <tristes_tigres> bd_: you are offering me to define my own floats for regular numerical work.
11:59:20 <dcoutts_> tristes_tigres: and flags are just a way of delaying checking for things like overflow, denormalisation, nan etc right?
11:59:42 <tristes_tigres> dcoutts_: yes
11:59:54 <dcoutts_> so traps are more general
11:59:59 <dcoutts_> and we can turn those into exceptions
12:00:12 <tristes_tigres> traps are not always invoked
12:00:18 <tristes_tigres> by default they are not
12:00:24 <dcoutts_> no, but you can enable them or not
12:00:25 <aconbere> oop... you know I was copy/pasting and gave it a prefix that I didn't follow up with after the fact
12:00:29 <aconbere> betcha that's it
12:00:37 <dcoutts_> and that's more general than checking flags after an operation
12:00:40 <Philonous> abuiles: you need  (custom-set-variables '(haskell-program-name "ghci")) in your ~/.emacs
12:00:47 <dcoutts_> so if we have the modes, like rounding etc and the set of traps as an implicit parameter then it's all pure
12:00:59 <Philonous> If you want hugs replace ghci with hugs
12:01:11 <Myoma> Toxaris, no
12:01:22 <tristes_tigres> dcoutts_: they didn't put both traps and flags into standard without a reason
12:01:41 <dcoutts_> tristes_tigres: that's because most languages make error handling hard
12:01:52 <tristes_tigres> dcoutts_: you think you know better and are prposing to discard a part of the standard
12:01:55 <Myoma> you might want to have (+) :: Int -> Int -> Real
12:02:19 <dcoutts_> tristes_tigres: yes! because it's impure, and the behaviour looks like it is covered by other parts of the standard that are pure
12:02:32 <dcoutts_> tristes_tigres: having side effecting setting of flags that are checked later is just completely impure, it's no good
12:02:37 <tristes_tigres> dcoutts_: but it is not covered
12:02:38 <bd_> Myoma: No, you want (+) :: Real -> Real -> Real, and make sure those Reals start out that way, surely?
12:02:47 <Myoma> bd_: No
12:03:16 <dcoutts_> tristes_tigres: what can you do with flags that you cannot do with traps ?
12:03:19 <tristes_tigres> dcoutts_: the reasoning for having both has to do with performance
12:03:45 <dcoutts_> tristes_tigres: you mean flags are faster than traps, even when none of them occur?
12:03:54 <tristes_tigres> dcoutts_: if you enable traps just to find out whether flag was raised, you will run prohibitively slow
12:04:23 <koninkje> Twey: ((++) . (++ " ")) is probably closer to legible, though it's still a bit wonky
12:04:24 <dcoutts_> tristes_tigres: surely it only calls the trap if the event happens
12:04:29 <bd_> Myoma: Why are the arguments Ints, not Reals?
12:04:33 <tristes_tigres> dcoutts_: and performance is important for FP
12:04:44 <dcoutts_> tristes_tigres: so is it not just as fast in the case that the event does not happen ?
12:04:46 <tristes_tigres> dcoutts: it may happen A LOT
12:04:47 <Philonous> abuiles: But make sure you have only one call to custom-set-variables, if not just add the "'(haskell-program-name "ghci")" to the call that is already there
12:05:59 <dcoutts_> tristes_tigres: you somehow have to integrate the flags/traps into the return value, eg as more distinguished kinds of NAN, or as exceptions or whatever
12:06:17 <dcoutts_> what to do can be an input parameter
12:06:35 <bd_> dcoutts_: or part of the type?
12:06:41 <abuiles> Philonous: Thanks, I'll check it,
12:07:07 <dcoutts_> tristes_tigres: so you mean people want to do things like not breaking on the first occurence but let it all go wrong and then check at the end how wrong is was, but possibly use the value anyway, even if it was wrong ?
12:07:10 <dsrogers> how do I declare a literal () in th?
12:07:15 <tristes_tigres> dcoutts: that means that I need to redefine float type because the default is not adequate
12:07:27 <tristes_tigres> dcoutts_: exactly
12:07:41 <dcoutts_> tristes_tigres: I think even that's doable
12:07:42 <tristes_tigres> dcoutts_: to begin with, it may be wrong in parts
12:07:47 <dsrogers> nm
12:08:29 <dcoutts_> tristes_tigres: there may need to be a fair bit of saving and restoring FP state however
12:08:35 <dcoutts_> to cope with lazyness
12:09:05 <tristes_tigres> dcoutts_: there is the issue of rounding modes
12:09:18 <dcoutts_> that one is easy in comparison to the flags/traps
12:09:30 <tristes_tigres> I may want to set it differently for different threads
12:09:44 <dcoutts_> yeah, no problem, it's just an implicit parameter
12:09:58 <binarybandit> Hello, n00b working through real world haskell, and I'm stuck on one of the examples in chapter four. Why doesn't: myLen (x:xs) = 1 + myLen xs \n myLen [] = 0 work?
12:10:17 <ddarius> binary42: It does.
12:10:20 <binarybandit> It says the pattern matching isn't exhaustive, but shouldn't myLen [] catch the last one?
12:10:24 <tristes_tigres> Haskell is not pure language anyway. It is the language with clear boundary between pure and impure
12:10:32 <dcoutts_> though there's an optimisation problem so that the code gen doesn't have to constantly save/restore the fp state
12:10:49 <ddarius> binarybandit: Your indentation is probably wrong
12:10:53 <dcoutts_> tristes_tigres: sure you can just do all your FP in a monad, but it'll be ugly, really really ugly.
12:11:12 <binarybandit> ddarius, http://hpaste.org/9899
12:11:29 <tristes_tigres> dcoutts_: That's what I am saying. Explicit conversions everywhere are ugly, too
12:11:36 <bd_> @check \l -> length (l :: [Int]) == let myLen (x:xs) = 1 + mylen xs; mylen [] = 0 in myLen l
12:11:37 <ddarius> binarybandit: You are declaring two functions, no two clauses of one function
12:11:37 <noBotE>   Non-exhaustive patterns in function myLen
12:11:45 <koninkje> binarybandit: You need to give the definitions together on the same line if you're doing it in GHCi
12:11:48 <bd_> hmmmm
12:11:50 <dcoutts_> tristes_tigres: so my point is th
12:11:58 <bd_> @check \l -> length (l :: [Int]) == let {myLen (x:xs) = 1 + mylen xs; mylen [] = 0} in myLen l
12:11:59 <noBotE>   Non-exhaustive patterns in function mylen
12:12:04 <binarybandit> ddarius, koninkje, ah, thanks
12:12:05 <bd_> oh, capitalization
12:12:07 <koninkje> ghci> let myLen (x:xs) = 1 + myLen xs ; myLen [] = 0
12:12:13 <bd_> @check \l -> length (l :: [Int]) == let {myLen (x:xs) = 1 + myLen xs; myLen [] = 0} in myLen l
12:12:14 <noBotE>  OK, passed 500 tests.
12:12:26 <dcoutts_> tristes_tigres: so my point is that it's totally possible to model functionally, but getting good performance would rely on some clever compiler things (which are also possible, just hard work)
12:12:27 <tristes_tigres> dcoutts_: floating point in Haskell is totally inadequate
12:12:37 <koninkje> binarybandit: as you wrote it, the second definition (for only []) is overriding the other one (for only (:))
12:12:46 <dsrogers> haha!  I have a TH test and debug harness!
12:12:47 <binarybandit> I see, thanks you. :)
12:12:48 <tristes_tigres> dcoutts_: It just won't do to reply "you can write it yourself"
12:13:07 <haskellian> Prelude> let sq x = x*x
12:13:07 <haskellian> Prelude> sq 12
12:13:07 <haskellian> 144
12:13:07 <haskellian> Prelude> sq 144
12:13:07 <haskellian> 20736
12:13:08 <haskellian> Prelude> sq(12)
12:13:10 <haskellian> 144
12:13:13 <haskellian> why does sq(12) work?
12:13:15 <binarybandit> haskellian, hpaste.org
12:13:18 <haskellian> sorry
12:13:21 <tristes_tigres> dcoutts_: I can't write myself everything I need. I'll pick a language that has thagt stuff already built in
12:13:32 <ddarius> tristes_tigres: Go for it.
12:13:38 <haskellian> let add x y = x+y, add(5,2) fails
12:14:03 <dcoutts_> tristes_tigres: I didn't say it was great, I said I think it is possible to do the full IEEE floating point in a pure way, which is where we started.
12:14:34 <binarybandit> haskellian, I believe it has to do with haskell having no notion of a one element tuple.
12:14:47 <koninkje> haskellian: the parens are just grouping the expression 12
12:15:02 <tristes_tigres> dcoutts_: you can replace flags with traps, but there's also the issue of roundiing modes
12:15:18 <binarybandit> I see, same deal in python.
12:15:21 <dcoutts_> tristes_tigres: as I already said, that's the easier one to model functionally
12:15:26 <klugez> haskellian: sq(12) is the same as sq (12), but add(5,2) is the same as add (5,2) and add does not take a tuple.
12:15:38 <dcoutts_> tristes_tigres: I did not say it is already implemented or easy.
12:15:54 <ekidd> OK, I've spent a couple of hours digging through the docs, and I still haven't found a reasonably efficient way to convert a DiffUArray into something that I can get a Ptr from (such as a Data.Array.Storable instance). I'm feeling a bit dumb. :-/
12:16:56 <tristes_tigres> dcoutts_: is "functional" the same as "pure" ? Haskell is not pure language already
12:17:04 <Twey> @src forever
12:17:04 <noBotE> Source not found. And you call yourself a Rocket Scientist!
12:17:04 <Cale> ekidd: assocs and then array
12:17:04 <preflex>  Cale: you have 3 new messages. '/msg preflex messages' to read them.
12:17:12 <dcoutts_> tristes_tigres: yes, pure. And yes it is pure.
12:17:45 <tristes_tigres> dcoutts_: Of course not - you can have side effects in Haskell, so it is not pure
12:18:27 <seanmce> @check ((\x -> if x == 0.0 then True else let y = 1.0 / x in x*y == 1.0)::Double->Bool)
12:18:29 <noBotE>  Falsifiable, after 48 tests: 5.444444444444445
12:18:41 <ekidd> Cale: I have to dump it to a list? I'm working with audio data, and would prefer to keep everything in nice big arrays.
12:18:59 <haskellian> tristes: but they are encapsulated and separated from the pure part
12:19:01 <seanmce> is there a library that will pass that test?
12:19:05 <dcoutts_> tristes_tigres: You can read about how IO is modelled, but it's all referentially transparent (pure).
12:19:13 <Cale> ekidd: (with the StorableArray instance)
12:19:38 <Cale> ekidd: Think of the list as a loop. In order to turn one kind of array into another, you have to iterate over its members.
12:20:22 <ekidd> Cale: Will fusion actually be able to eliminate the intermediate data structure? It's pretty important that I don't actually instantiate the list, performance-wise.
12:21:19 <binarybandit> alright, now I really am stuck. I'm trying to write a function that reverses a list and appends it to the original: [1,2,3] -> [1,2,3,3,2,1], but pali x = x:reverse x is a no go. How would I go about this?
12:21:32 <glguy> ++
12:21:33 <Cale> Possibly... though in any event, the whole list is never going to exist all at once. Basically only one node at a time will not be garbage.
12:21:38 <tristes_tigres> dcoutts_: I know how it is modelled. But it would be more correct to say that Haskell separates pure from impure at the type level
12:21:57 <tristes_tigres> To say that Haskell is pure is just not correct
12:22:01 <Cale> The easiest way to find out if it works okay is to try it and see if you have a performance problem :)
12:22:02 <binarybandit> glguy, ah
12:22:16 <ddarius> dcoutts: Indeed.  Clearly, tristes_tigres better knows what he is talking about than you.
12:22:18 <binarybandit> thanks again :)
12:22:36 <glguy> ekidd: the "uvector" library is designed as efficient arrays with heavy fusion
12:22:42 <dcoutts_> tristes_tigres: well, it's just a semantic argument. It doesn't change the fact that impure floating point is just invalid in a pure language.
12:22:43 <glguy> ekidd: might be something to look at
12:22:50 <Myoma> tristes_tigres: Haskell is pure
12:22:58 <Cale> binarybandit: The : operator is only for prepending an element to a list. So when you write x : xs, xs should be a list, and x should be acceptable as an element of that list
12:23:00 <glguy> mostly
12:23:06 <tristes_tigres> myoma: no it isn't :-)
12:23:12 <Myoma> tristes_tigres: yes it is
12:23:19 <yitz> tis
12:23:20 <tristes_tigres> http://en.wikipedia.org/wiki/Pure_function
12:23:27 <bd_> tristes_tigres: All functions in haskell are pure.
12:23:28 <Myoma> http://en.wikipedia.org/wiki/Haskell
12:23:32 <tristes_tigres> first paragraph
12:23:36 <glguy> maybe in Haskell98
12:23:42 <bd_> IO () is just an opaque representation of an impure program
12:23:48 <bd_> which can be manipulated in a pure way
12:23:50 <Cale> binarybandit: To concatenate two lists, the appropriate function is (++)
12:24:11 <bd_> (note: unsafe* are implementation details and should not be considered)
12:24:14 <yitz> tristes_tigres: yes, Haskell is pure in that sense
12:24:15 <ddarius> tristes_tigres: I don't know why you are still arguing this issue or any other.  Even if everyone completely agreed with you on what needed to be done and how, it's not going to happen in the next couple of days and you have no intention of helping it to happen.
12:24:19 <tristes_tigres> bd_: you mean it is pure if you can swipe impurity under the rug ? :-)
12:24:33 <bd_> tristes_tigres: No, I mean that if you consider the semantics of haskell functions, they are pure.
12:24:36 <ekidd> Cale: If array blah . assocs will deforest into a simple loop over the indices, I'll use that. Otherwise, I'll write the conversion loop by hand. Thank you!
12:24:46 <ekidd> glguy: Thank you for the pointer to uvector!
12:25:34 <tristes_tigres> yitz: "In computer programming, a function may be described as pure if both these statements about the function hold:
12:25:34 <tristes_tigres>    1. The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change as program execution proceeds, nor can it depend on any external input from I/O devices. #
12:25:34 <tristes_tigres> # Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices."
12:25:50 <bd_> tristes_tigres: Under what circumstances does a haskell function not act pure?
12:26:00 <tristes_tigres> yitz thus pure functional language can not produce any output
12:26:10 <Myoma> tristes_tigres: that's not true
12:26:22 <tristes_tigres> Myoma: what is not true ?
12:26:27 <bd_> tristes_tigres: Haskell programs can be considered as a pure transformation upon the real world
12:26:43 <bd_> This transformation is restricted via the type system to only allow simple I/O
12:26:52 <Cale> tristes_tigres: Haskell functions are always pure.
12:27:06 <tristes_tigres> Cale: how about random number generator
12:27:12 <bd_> mind you, once you put in threads you have to start thinking of it as a pure program to produce an impure function
12:27:13 <Cale> tristes_tigres: It is not a function.
12:27:14 <dcoutts_> tristes_tigres: we all agree that Haskell does not cover the full IEEE floating point spec. We agree that the IEEE fp api is on the face of it impure. We've suggested ways of modelling it in a pure way, but those ways are not easy to implement (require compiler support). I'm not sure what there is left here to argue (except if Haskell is pure or not which is just a discussion of semantics)
12:27:29 <yitz> tristes_tigres: true. e.g. putStr does not produce any output. It returns an IO action, which you can combine with other IO actions. If you happen to assign that IO action to the magical name "main", or type it at the ghci prompt, the runtime will actually do the IO action, but that's not the result of the function.
12:27:53 <Cale> tristes_tigres: Or, in the case of pseudorandom generators, it's a function which takes the generator state as a parameter.
12:28:49 <yitz> tristes_tigres: in other words, we sweep it under the rug. :)
12:29:06 <tristes_tigres> dcoutts_: what really needs to be discussed is what is the appropriate datatype for floating point
12:29:15 <tristes_tigres> yitz: that's just so naughty
12:29:23 <yitz> bwahaha
12:29:26 <ekidd> tristes_tigres: Conceptually speaking, 'main :: IO ()' doesn't have any side effects. It's just a constant returning a value of type 'IO ()', which in turn describes a set of IO actions that somebody could take. If you choose to hand that 'IO ()' value to an appropriate runtime system, that's between you and the runtime system. ;-)
12:29:43 <Cale> dcoutts_: What is Haskell missing?
12:29:49 <Cale> dcoutts_: (from floating point)
12:29:56 <dcoutts_> Cale: the IEEE fp spec is pretty nasty it turns out.
12:29:59 <tristes_tigres> ekidd: you sound like somecongressman or presidential candidate
12:30:18 <Myoma> tristes_tigres: the logical content of what they said is correct
12:30:20 <bd_> tristes_tigres: or a mathematician :)
12:30:20 <tristes_tigres> ekidd: "It depends on what the meaning of "is" is "
12:30:27 <dcoutts_> Cale: the rounding modes, and various ways of controlling what happens on overflows, denormalisation etc.
12:30:29 <Myoma> tristes_tigres: so it may be worth looking path the tone of voice
12:30:35 <ddarius> Cale: There are definitely things that were explicitly omitted.
12:30:45 <bd_> I suppose the question is, is the haskell program what produces IO (), or is it the IO () itself?
12:30:52 <trofi> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
12:30:53 <noBotE>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:30:54 <bd_> If the ofrmer, haskell is pure. If the latter, it is impure.
12:31:15 <dcoutts_> Cale: the way IEEE specifies it, it is impure. It looks doable in a pure way, but not very easily in terms of underlying implementation to get good performance.
12:32:01 <tristes_tigres> Myoma: I think it is somewhat misleading to call Haskell "pure"/ I think it is more precise to say that it clearly separates what is pure from what is impure
12:32:12 <yitz> sounds like you would want an IEEE monad. withIEEEMode :: IEEEMode -> IEEE a
12:32:24 <yitz> sounds like you would want an IEEE monad. withIEEEMode :: IEEEMode -> IEEE a -> IEEE a
12:32:26 <bd_> yitz: Float operations are pure, and could escape the monad.
12:32:30 <ddarius> yitz: That's one way of doing it.
12:32:32 <dcoutts_> yitz: yeah, that's work and would have fine performance. It's just horrible to use.
12:32:36 <Myoma> tristes_tigres: I don't know if it's misleading or not
12:32:38 <dcoutts_> that's/that'd
12:33:00 <yitz> dcoutts_:  mm, not *so* horrible for when you need it. Most of the time not, as we see.
12:33:12 <Cale> tristes_tigres: Well, this is true. But saying that Haskell functions are pure is not even technically a problem.
12:33:23 <Myoma> I am not misled by it because it is true -- so I don't except others to be misled eiter
12:33:30 <dcoutts_> yitz: because then plus, etc have to have type:: IeeeFloat -> IeeeFloat -> IEEE IeeeFloat
12:34:02 <Myoma> tristes_tigres: of course unsafePerformIO is not pure
12:34:10 <Myoma> tristes_tigres: so really the entire language haskell is not pure
12:34:12 <bd_> dcoutts_: The fp state has to be reset before performing any non-monadic computation too
12:34:15 <yitz> dcoutts_: You mean that we have isIEEE as a Bool instead of an IEEEFloat class?
12:34:21 <dcoutts_> yitz: they all have to be actions in the monad, so the api is quite hideous, rather akin to assembly :-)
12:34:22 <Myoma> tristes_tigres: but I ignore that because it's an edge case
12:34:39 <Jedai> tristes_tigres: Let's say it's the purer language around that stay practical...
12:34:40 <tristes_tigres> Myoma: it seems lots opeople are using it though
12:34:44 <bd_> dcoutts_: a type IEEE a b [...] where a b etc are flags would be better imo
12:34:58 <Myoma> tristes_tigres: that's good, it's an accurate description
12:35:16 <adekoba> what package replaces old-locale?
12:35:19 <dcoutts_> yitz: the point is IEEE operations are side effecting in the IEEE monad.
12:35:23 <Myoma> tristes_tigres: It's informal, that's fine because nobody is doing metatheory here
12:35:27 <binarybandit> Haskell is hard; let's go shopping!
12:35:34 <tristes_tigres> Myoma: so it is not such a big deal if some arithmetic is not pure
12:35:35 <dcoutts_> yitz: it's a state monad, not just reader.
12:35:38 <adekoba> haven't heard that one before
12:35:45 <Jedai> tristes_tigres: unsafePerformIO ? In a normal program ? (Not in a library with bindings to C) except for globals, it doesn't seems to be the case to me
12:35:46 <yitz> dcoutts_: hmm. well, if not, then you'd have to make the ops lazy, which would then kill performance. yeah.
12:36:40 <glguy> and we cetainly aren't lazy ;)
12:36:47 <tristes_tigres> why floating point sjhuld be a monad, and not, for example, an arrow ?
12:36:54 <Cale> tristes_tigres: I don't consider unsafePerformIO to be a part of the language. I consider it to be a sort of hook into the runtime system that gives you an option other than modifying your compiler for implementing certain new language features.
12:37:27 <tristes_tigres> Jedai: I don't really know, but it seems ot come up regularly
12:37:28 <Cale> tristes_tigres: However, it basically needs to be treated with the same sort of gravity as modifying your compiler.
12:38:18 <tristes_tigres> Cale: I am just saing that unsafePerformIO is not a curiosity. It is used by people
12:38:21 <yitz> dcoutts_: you would have to make the monad like ST - escapable only to IO. Then it would work. Not such a mess locally, but disruptive to overall program structure. Again, only needed occasionally, so perhaps an acceptable solution.
12:38:32 * sioraiocht has used unsafePerformIO
12:38:35 <Eiler> well haskell is almost pure then but not really ;)
12:38:42 * sioraiocht uses a LOT of unsafe functions.
12:38:50 <yitz> sioraiocht! really! I'm ashamed of you.
12:39:04 <sioraiocht> yitz: if you know what you're doing, they can be much much faster
12:39:12 <tristes_tigres> Oh, look at all the dirty secrets coming out
12:39:13 * yitz quickly hides certain code he has written
12:39:16 <sioraiocht> I use them in the library I'm writing, it wouldn't be doable without unsafe*
12:39:47 <sioraiocht> unsafeFreeze...unsafeAt...unsafeWrite...
12:39:56 <Cale> tristes_tigres: It's used specifically in two places -- people writing FFI bindings to pure C functions, and people writing libraries that extend the means for evaluating expressions in some way.
12:40:08 <sampointon> tristes_tigres: yes, at first they're all pure and innocent, but then you dig deeper...
12:40:12 <yitz> sioraiocht: libraries that need global constants from IO have no choice, for example. but that's just a hole in Haskell that could easily be plugged.
12:40:32 * tristes_tigres is reading introduction into arrows
12:40:38 <Cale> yitz: I'm not sure that it should be :)
12:40:47 <sioraiocht> yitz: yeah, there are plenty of uses...just ask dcoutts_, he has a library with inlineUnsafePerformIO =p
12:40:58 * tristes_tigres is not yet clear when use monad, and when rrow
12:41:00 <dcoutts_> :-)
12:41:03 <Cale> yitz: We don't need more global constants in IO :)
12:41:16 <hackage> Uploaded to hackage: maybench 0.2.2
12:41:21 <yitz> Cale: why not? there have been a lot of proposals how. the least invasive would be just a pragma that has stronger semantics than NOINLINE.
12:41:22 <Cale> tristes_tigres: Well, it just depends on the shape of the library that you're writing.
12:41:24 <sioraiocht> tristes_tigres: use a monad, if you can p
12:41:25 <sioraiocht> =p
12:41:28 <nerdibangbang> Hello.
12:41:39 <olsner> sioraiocht: heh, is that like evenUnsaferUnsafePerformIO?
12:41:42 <dcoutts_> yitz: I maintain the fallacy that there is no such thing as a global constant. Everything has a scope.
12:41:45 <yitz> Cale: there's no choice if the library has no access to main
12:41:45 <tristes_tigres> 20something arrow laws certainly sound intimidating
12:41:54 <Myoma> dcoutts_: agreed
12:41:55 <Myoma> :)
12:42:01 <sioraiocht> olsner: considering you are not supposed to inline unsafePerformIO...yes ;)
12:42:20 <dcoutts_> yitz: thing is, you cannot even make global vars in Haskell, only per-package name/version vars.
12:42:22 <tristes_tigres> dcoutts_: Even the speed of light
12:42:25 <tristes_tigres> ?
12:42:26 <binarybandit> is this an awful way to calculate the height of a binary tree?
12:42:26 <binarybandit> let height (Node _ a@(Node _ _ _) b@(Node _ _ _)) = 1 + max (height a) (height b); height (Node _ a b) = 1
12:42:49 <dcoutts_> yitz: if I link in two versions of your package (not unlikely) then I get two copies of your 'global' variable.
12:42:50 <sioraiocht> binarybandit: not really, that's how I would do it
12:42:51 <yitz> dcoutts_: e.g., your library is a wrapper for an FFI API that requires initialize and finalize. you just can't do it any other way.
12:42:56 <nerdibangbang> Dr Jon Harrop, is he really a doctor?.
12:42:56 <binarybandit> sioraiocht, thanks :)
12:43:01 <Cale> yitz: There's always "not using a global constant"
12:43:06 <dcoutts_> yitz: you can, you can make that explicit in a context.
12:43:16 <yitz> dcoutts_: ?
12:43:23 <sioraiocht> binarybandit: you don't need to pattern match, though
12:43:24 <ddarius> nerdibangbang: This is not the channel for that.
12:43:38 <binarybandit> sioraiocht, I was about to ask, is there a cleaner way to do (Node _ _ _)
12:43:39 <sioraiocht> you can do height (Node l r) = 1 + max (height l) (height r)
12:43:54 <yitz> dcoutts_: by "make that explicit in a context" you surely don't mean something that mentions IO - because you have no access to that.
12:43:55 <dcoutts_> yitz: you have a newFooContext :: IO FooContext; dothingWithFoo :: Foo -> ...
12:43:57 <binarybandit> how does it terminate there?
12:44:06 <yitz> dcoutts_: no good, it's IO.
12:44:19 <sioraiocht> binarybandit: what's your tree definition look like?
12:44:30 <dcoutts_> yitz: can you call the ffi init multiple times ?
12:44:35 <binarybandit> data Tree a = Node a (Tree a) (Tree a)
12:44:35 <binarybandit>             | Empty
12:44:35 <binarybandit>               deriving (Show)
12:44:37 <tristes_tigres> By the way, mmorrow uploaded a library to switch and query rounding modes
12:44:43 <dcoutts_> yitz: does it not give you back any token ?
12:44:51 <sioraiocht> binarybandit: have another function definition that is height Empty = 0
12:45:02 <yitz> dcoutts_: no, only once. token is immaterial.
12:45:05 <binarybandit> sampointon, ah, thanks, that's what I was looking for :)
12:45:15 <aFlag> How do I print a floating number with 3 decimal digits of precision (taking rounding into account)?
12:45:19 <binarybandit> that's much better
12:45:37 <sampointon> binarybandit: grats, but I think you meant to thank sioraiocht
12:45:46 <yitz> dcoutts_: yeah, linking twice is a problem. NOINLINE is missing a lot. This is a serious hole.
12:45:54 <dcoutts_> yitz: so you're dealing with a borken foreign lib that's under the misguided assumption that there is such a thing as a global var.
12:45:57 <tristes_tigres> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ieee-utils
12:46:03 <noBotE> http://tinyurl.com/3q5p2h
12:46:07 <binarybandit> s/sampointon/sioraiocht/
12:46:14 <sioraiocht> binarybandit: np :)
12:46:18 <binarybandit> your nicks are disturbingly similar
12:46:33 * binarybandit is disturbed
12:46:35 <yitz> dcoutts_: exactly. that's life. What's the name of that new book - Real World...
12:46:36 <dcoutts_> yitz: in practise, you probably need a bit of C code to have a static var that's shared between all versions of the Haskell package.
12:47:09 <haskellian> is there any webservers in professional use that are written in haskell?
12:47:25 <yitz> dcoutts_: yeah there are workarounds. but this does come up, there should be something better than what we have now.
12:47:38 <dcoutts_> yitz: so what you want is a process scope var
12:48:07 <dcoutts_> yitz: but 'top level' constants are only package scope.
12:48:14 <ddarius> haskellian: Kind of.
12:49:08 <dcoutts_> yitz: it even needs to be shared between multiple instances of the rts that might be living in the same process.
12:49:16 <yitz> dcoutts_: I suppose. Then there are threads. whatever. my point is not all that, rather that there needs to be a better idiom than NOINLINE / unsafePerformIO for this. You're right though, there is place for additional improvement at the build level.
12:50:04 <sioraiocht> binarybandit: if i were allowed to spell my name with the appropriate accent marks it would be easier =p
12:51:44 <Lemmih>  /quit
12:51:59 <binarybandit> sioraiocht, stupid culturally biased IRC!
12:52:41 <tristes_tigres> binarybandit: IRC can't do unicode ?
12:52:45 <dcoutts_> yitz: hmm, actually I think in the general case it's not even possible, though would work most of the time in a best effort sort of way.
12:52:51 <sampointon> tristes_tigres: evidently not in usernames
12:53:00 <Cale> tristes_tigres: nicks aren't even allowed to contain any ascii characters, let alone unicode.
12:53:09 <tristes_tigres> Òåñò òåñò òåñò ïðèâåò êàê äåëà ?
12:53:24 <dcoutts_> yitz: even static vars in C can be duplicated by linking multiple copes (and not letting the linker alias them)
12:53:26 <glguy> tristes_tigres: my client says that that wasn't UTF-8
12:53:44 <Cale> æ¥æ¬èªãæãã
12:54:08 <glguy> was this what you meant to send: ÃÃ¥Ã±Ã² Ã²Ã¥Ã±Ã² Ã²Ã¥Ã±Ã² Ã¯Ã°Ã¨Ã¢Ã¥Ã² ÃªÃ Ãª Ã¤Ã¥Ã«Ã 
12:54:12 <yitz> dcoutts_: so libraries that with that type of interface (and there are tons of them) are relying on simplistic linking even in C.
12:54:32 <tristes_tigres> qlguy: it is cyrillic
12:54:34 <sampointon> glguy: could be the client is borked at receiving -and- sending unicode, meaning that would look fine
12:55:01 <Heffalump> it looked like a bunch of accented characters to me (not cyrillic)
12:55:07 <yitz> dcoutts_: as you say, I don't think we need to fix every broken library.
12:55:11 <glguy> sampointon: no, this client handles utf-8 fine
12:55:15 <glguy> OH
12:55:16 <glguy> his
12:55:18 <glguy> I see what you mean
12:55:24 <Cale> yitz: We could try to ignore the bad libraries :)
12:55:35 <FunctorSalad> hmm, for any sort of algebraic structure, you get a monad T (with T a the free structure over a). for monoids, that is the list monad. is there any use for other structures, say groups or vector spaces?
12:55:38 <yitz> dcoutts_: They don't need to be quite that broken to require the NOINLINE trick, and that we *can* fix.
12:55:39 <sioraiocht> yitz: we should just write libraries that subsume the broken ones
12:55:42 <dcoutts_> yitz: and it has to match that linking behaviour to work, otherwise you'd not initialise an instance of a lib, if there were multiple copies linked into a process.
12:55:58 <yitz> Cale: Haskell - fail at all costs!
12:55:58 <Cale> FunctorSalad: You're looking at the question of monadicity
12:56:15 <sioraiocht> FunctorSalad: I'm sure there IS...
12:56:31 <sioraiocht> I guess it all depends on how you want to model your computation
12:56:49 <yitz> dcoutts_: perhaps there needs to be something at the linker level that interact with these nasties
12:56:59 <FunctorSalad> Cale: hmm... am I remembering correctly that a monadic functor is one that is the moore-eilenberg adjunction of a monad?
12:57:25 <dcoutts_> yitz: yes, ultimately this scoping and aliasing is resolved at the linker level.
12:57:27 <Cale> FunctorSalad: yeah
12:57:57 <dcoutts_> yitz: it's even more broken when your binding and my binding are used in the same prog. We'll init the lib twice because we do not share the init state.
12:58:08 <Cale> FunctorSalad: er
12:58:15 <Cale> A functor is monadic when it has a left adjoint F forming a monadic adjunction.
12:58:24 <dcoutts_> yitz: it can't ever be more than best effort for the common cases.
12:58:33 <yitz> dcoutts_: all of those kinds of problems exist just as much in C
12:58:52 <yitz> dcoutts_: and I've suffered from there, too:)
12:58:53 <FunctorSalad> Cale: yeah
12:59:08 <dcoutts_> yitz: well, in C they tend not to link multiple versions of libs into a program.
12:59:26 <FunctorSalad> I think a vector space monad would amount to probabilistic computation
12:59:29 <dcoutts_> eg cannot dlopen multiple libs with the same soname but different versions
12:59:32 <Cale> (F: C -> D,G: D -> C,eta,epsilon) is a monadic adjunction if D is equivalent to the Eilenberg-Moore category for the monad GF
12:59:34 <FunctorSalad> (except without normalization)
12:59:43 <dcoutts_> at least not in the same linker scope
12:59:49 <yitz> dcoutts_: how long ago did you start trying to use stl in MS Visual Studio?
13:00:10 <dcoutts_> yitz: about 5 years ago
13:00:34 <Eiler> dcoutts: there is no dll nor sofiles in C, thats outside the standard
13:00:40 <yitz> dcoutts_: I stopped around then. It was pretty bad. And yeah, those kinds of things did happen.
13:01:23 <dcoutts_> Eiler: but C does kind of rely on a flat linker namespace
13:02:47 <Cale> FunctorSalad: So in some sense, what you're asking is whether there is an adjunction, say, Set -F> Vect-K -G> Set (or maybe some other interesting base category instead of Set), which is monadic.
13:03:13 <yitz> dcoutts_: an app with multiple dlls would get multiple copies of stl's global state in each one. it was a nightmare.
13:03:31 <ddarius> FunctorSalad: sigfpe is using a vector space monad in his recent articles
13:03:50 <bd_> yitz: how much global state does stl have?
13:04:21 <dcoutts_> yitz: so that meant you could not safely pass objects constructed in one dll into another I suppose.
13:04:21 <bd_> I was under the impression that it had (almost?) no global state
13:04:27 <bd_> Unless you mean instantiations?
13:04:31 <yitz> bd_: maybe now they've fixed it
13:05:02 <bd_> yitz: I think you mean template instantiations, rather than global state?
13:07:17 <yitz> bd_: possibly related to that. trying to remember... anyway, the result was that you would pass an stl object from one dll to the other and it would compile but lose information at runtime.
13:07:37 <bd_> ah, incompatible classes
13:10:28 * tristes_tigres thinks the language with best code reuse is Fortran
13:10:52 <haskellian> Wuldnt it be possible to make a proof that could be used to verify purity in computrprograms?
13:10:55 <osfameron> what about befunge?
13:11:08 <yitz> anyway, aside from the linkage issues, the fact that there is no way to write a program without NOINLINE / unsafePerformIO - and even then the NOINLINE doesn't have sufficient semantics even within the Haskell part - means that something critical is missing from Haskell there.
13:11:09 <osfameron> that can reuse code in *4* directions
13:11:35 <haskellian> So you could have a language that doesn't have to be pure but if you needed it you could write it in a pure way and then prove it to be pure?
13:14:20 <sampointon> haskellian: how pure do you mean? Pure == no mutable state anywhere, or pure == referentially transparent?
13:14:59 <sjanssen> yitz: which program isn't possible to write without unsafePerformIO?
13:15:24 <glguy> uvector :)
13:15:28 <Toxaris> haskellian: in a sense, haskell with unsafePerformIO is that language, with the added benefit that all proof obligations are clearly marked by calls of unsafePerformIO
13:15:34 <yitz> sjanssen: s/program/library/
13:17:14 <FunctorSalad> Cale: hmm, I don't see where we are going with the monadicity question? anyway, the classical case is where F is the free functor and G the forgetful. I also think Set could be replaced by Hask?
13:17:15 <Toxaris> haskellian: but with the same kind of reasoning, you could argue that a language without static types would be a good thing, since you can always proof by hand that your program is type correct. now, have you ever seen a programmer do type checking by hand? instead, programmers just assume that their dynamically typed code will work, maybe after some testing
13:17:40 <Myoma> isPure [\x -> B] = isPure b ; isPure [m n] = isPure m && isPure n ; isPure [unsafePerformIO] = False ; isPure [_] = True
13:17:47 <Toxaris> haskellian: therefore, "i can proof that I have property X if I need it" is worse then "property X always holds"
13:18:08 <FunctorSalad> Cale: then the vector space monad would be something like Vec a = Map a Reals with pointwise addition etc.
13:18:24 <osfameron> Toxaris: not true.  We assume it won't work, then sacrifice a chicken while running the program over and over again making random changes until it works.  That's quite different.
13:18:35 <haskellian> im not talking by hand, it should then be built into the compiler
13:18:48 <sjanssen> Myoma: const 1 (unsafePerformIO $ readFile "foo")
13:18:53 <Myoma> no the whole point is that it's not in the compiler
13:19:05 <Myoma> sjanssen: impure!
13:19:14 <Myoma> sjanssen: guilty until proven innocent
13:19:16 <Toxaris> haskellian: oh, proof search in compilers is normally called type checking
13:19:20 <tristes_tigres> osfameron: Experienced programmers just wave a rubber chicken
13:19:39 <Myoma> proof search is not type checking
13:19:47 <FunctorSalad> (the fact that a Map always has finite domain is a feature here, not a bug :))
13:19:56 <FunctorSalad> since linear combinations are finite too
13:19:57 <Toxaris> haskellian: that sounds even more like Haskell. your mark code wich you specifically want to be proven pure by the absence of IO.
13:20:16 <Myoma> haskellian invents the IO monad
13:20:27 * Botje throws salty lambda cookies around
13:20:49 * Myoma typechecks them cautiously ..
13:20:58 <Toxaris> osfameron: oh I see. that's why my experiments with scheme never lead to anything fruitful
13:21:38 * Toxaris tries to remember where you get that rubber chicken in monkey island from
13:22:09 * yitz beta reduces them
13:22:15 <FunctorSalad> (brb)
13:22:59 <Wild_Cat> Toxaris: you get it from the voodoo lady IIRC
13:23:11 <Wild_Cat> it's lying somewhere in her house.
13:24:38 <osfameron> I've never played monkey island :-(
13:24:43 <dsrogers> is there a unix program that always returns success?
13:24:52 <dsrogers> somethign like echo, only with no output.
13:24:53 <Heffalump> osfameron: you poor deprived individual :-(
13:24:56 <Heffalump> dsrogers: true?
13:25:03 <dsrogers> ah.
13:25:04 <dsrogers> thanks
13:25:19 <Heffalump> ISTR there was once a conflict with the GNU standards there :-)
13:25:26 <sampointon> Heffalump: programming in the bash monad?
13:25:32 <Toxaris> is voodoo connected to call-cc?
13:25:35 <Heffalump> because they say foo --version and foo --help should always print stuff out.
13:30:03 <binarybandit> tristes_tigres, I don't believe you can have unicode nicks
13:30:11 <dsrogers> did I mention I can write unit tests for TH now?
13:30:16 <dsrogers> this is awesome+
13:31:40 <haskellian> toxaris, myoma: lol true but i was thinking more along the lines of python+static typing+being able to verify purity if needed, not as a default programming style
13:31:55 <Myoma> use python then
13:32:14 <Myoma> ?
13:32:46 <yitz> dsrogers: there is also : but that may be specific to sh.
13:33:05 <EvilTerran> haskellian, with a little ingenuity involving aliases for stuff in Data.IORef, you can use haskell very cleanly as an imperative language
13:33:11 <dsrogers> yitz: true is good enough.  I'm just passing it to  -pgml in ghc.
13:33:18 <Wild_Cat> Python and static typing don't mesh well. Sadly.
13:33:24 <dsrogers> yitz: making linking always succeed, basically.
13:33:31 <yitz> dsrogers: ok
13:33:47 <Wild_Cat> Python with type inference and duck-typing for objects (ala Ocaml) would be an instance of Best Thing Ever (TM).
13:34:13 <Myoma> Wild_Cat: I'd hate that -- I don't know if that means anything though
13:34:18 <nerdibangbang> this is haskellians pythonbot, i want to marry lambdabot
13:35:02 <EvilTerran> haskellian, eg: ref = newIORef; get = readIORef; (<~) = writeIORef
13:35:21 <yitz> @vixen this is haskellians pythonbot, i want to marry lambdabot
13:35:22 <noBotE> church is my favourite computer scientist.
13:35:44 <EvilTerran> do r <- ref 1; r <~ 2; ... etcetc
13:35:47 <haskellian> vixen?
13:35:52 <EvilTerran> @help vixen
13:35:52 <noBotE> vixen <phrase>. Sergeant Curry's lonely hearts club
13:35:58 <EvilTerran> @vixen how are you today?
13:35:59 <noBotE> i am wonderful, thanks for asking!
13:36:13 <EvilTerran> @vixen say hi to haskellian
13:36:13 <noBotE> Ooh, functional programmers are so hot!
13:36:16 <EvilTerran> o.Ã³
13:36:30 <aeolist> they are all... "pure"
13:36:32 <aeolist> in many ways
13:37:35 <Eelis> with Text.Regex, the expression   subRegex (mkRegex "\\b(.)") "abcdef" "|\\1"   evaluates to   "|a|b|c|d|e|f". does that seem wrong to anybody else? in ruby, the expression   "abcdef".gsub(/\b(.)/, "|\\1")   evaluates to    "|abcdef"
13:38:18 <binarybandit> hmm, anther problem: http://pastie.textmate.org/private/vjhgdf0zlftiziarhrm8hw
13:38:20 <sampointon> Eelis: yep, considering that \b == word boundary
13:38:23 <noBotE> Title: Private Paste - Pastie
13:38:30 <Eelis> sampointon: indeed
13:38:35 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
13:38:36 <noBotE> Title: Things that amuse me, http://tinyurl.com/2948p6
13:38:48 <binarybandit> whoops, didn't get the error in there
13:39:00 <binarybandit> http://hpaste.org/9901
13:39:01 <binarybandit> there
13:39:41 <lament> SamB: in Prelude, each voice takes up a line.
13:39:41 <haskellian> I am going to watch Conan the barbarian
13:39:50 <int-e> Eelis: nice. that means subRegex can not be implemented the way it is done now - replacing the first match and then replacing the remainder of the string.
13:39:50 <haskellian> goodbye, happy coding
13:40:06 <lament> SamB: so a three-voice program will have three lines of code.
13:40:17 <Eelis> int-e: should i file a bug report?
13:40:47 <binarybandit> I don't see why it has a problem with it, I'm just moving the concat to another place. :(
13:40:53 <lament> SamB: (but for convenience you can break lines, for all voices at the same time, by putting * on a line by itself.)
13:41:20 <EvilTerran> binarybandit, because you're moving the concat inside the recursion
13:41:32 <EvilTerran> so it would get applied every recursive step
13:41:47 <binarybandit> EvilTerran, ooooooh
13:41:48 <binarybandit> thanks
13:41:58 <EvilTerran> np :)
13:42:14 <EvilTerran> binarybandit, however, i think the second version will work if you replace that : with a ++
13:42:16 <EvilTerran> not sure
13:42:45 <EvilTerran> binarybandit, although i would like to pick up some points on your programming style
13:42:48 <dcoutts_> @seen gwern
13:42:49 <noBotE> gwern is in #haskell. I last heard gwern speak 6h 52m 43s ago.
13:42:58 <EvilTerran> firstly, you're using head and tail on a list you don't know is non-empty
13:43:15 <EvilTerran> when using pattern matching is more appropriate
13:43:37 <binarybandit> EvilTerran, yes, I know, it's quick and dirty, just running through some of the exercises in Real World Haskell.
13:43:42 <dcoutts_> gwern: I'm thinking of doing another Cabal and cabal-install release shortly so do let me know if you have any current issues that you think are important, eg regressions.
13:44:05 <binarybandit> and no, it doesn't work with ++
13:44:14 <dcoutts_> anyone else here using darcs version of Cabal-1.4 and cabal-install and want's to do some general testing
13:44:26 <EvilTerran> binarybandit, well, running through tutorial exercises with "quick and dirty" solutions really isn't a good idea
13:44:27 <dcoutts_> to help make sure this isn't a brown paper bag release :-)
13:44:43 * dcoutts_ would be most appreciative
13:44:46 <EvilTerran> binarybandit, you'll just end up with bad habits - like that use of head and tail - that way
13:44:54 <binarybandit> EvilTerran, heh, point taken.
13:45:43 <EvilTerran> binarybandit, have a look at http://hpaste.org/9901#a1
13:45:58 <binarybandit> ah, thanks, I was about to ask :)
13:46:15 <haskellian> how can i switch focus from one splitwindow to another in emacs?
13:46:30 <opqdonut> finally got out part two of my attribute grammar series
13:46:32 <EvilTerran> binarybandit, that's the skeleton of a version using pattern-matching
13:46:32 <opqdonut> http://pseudo.fixme.fi/~opqdonut/blog/Attribute_Grammars__GADTs_and_MonadFix__part_2_.html
13:46:36 <binarybandit> Sorry, for the newbish question, new to haskell since this morning. :p
13:46:38 <aeolist> ctrl+w.... oh wait
13:46:40 <noBotE> Title: (&#x03BB;blog. blog blog) (&#x03BB;blog. blog blog): Attribute Grammars, GADTs a ..., http://tinyurl.com/4ssjr4
13:46:44 <binarybandit> EvilTerran, yes, thank you. :)
13:47:00 <EvilTerran> binarybandit, no, that's fine - it's better to ask and learn then not ask and pick up bad habits
13:47:14 <EvilTerran> you're in a channel full of procrastinating academics, we like helping people :)
13:47:25 <dsrogers> can forall be applied to anything besides a function?
13:47:35 <dsrogers> *function type
13:47:39 <Cale> dsrogers: yes
13:47:49 <Cale> :t Nothing
13:47:50 <noBotE> forall a. Maybe a
13:47:59 <Toxaris> @type 42
13:48:00 <noBotE> forall t. (Num t) => t Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
13:48:02 <Botje> :t undefined
13:48:03 <noBotE> forall a. a
13:48:10 <haskellian> evilterran: thats why the haskell-community is so awesome, very helpful, i sure appreciate it, it is far form the condescending attitude found in comp.lang.lisp
13:48:13 <Toxaris> :t 42
13:48:14 <noBotE> forall t. (Num t) => t
13:48:19 <Botje> :t []
13:48:20 <noBotE> forall a. [a] Thread 157a600 has exited with leftover thread-specific data after 4 destructor iterations
13:48:23 <dsrogers> ah
13:48:28 <ddarius> EvilTerran: I may be a procrastinator, but I'm no academic!
13:48:30 <Botje> poor thread 157a600
13:48:46 <aeolist> haskellian: you owe lispers because they gave you lisp, and you should be able to figure out everything by yourself
13:48:54 <aeolist> how can you be so ungraceful?
13:49:01 <EvilTerran> haskellian, yeah, it's nice like that. unfortunately comp.lang.lisp seem to all be aspiring to be paul graham, for some reason that utterly escapes me.
13:49:09 <blbrown> http://paste.lisp.org/display/65795   this code works, but is not very haskell'ish (or using FP style).  Anyone have recommendations, or seen anything that glaringly breaks Haskell code conventions.
13:49:17 <aeolist> EvilTerran: he made $$, i guess
13:49:40 <binarybandit> P.G. bugs me.
13:49:45 <EvilTerran> binarybandit, likewise
13:49:49 <Botje> blbrown: boundsChk, see Data.Ix.inrange
13:49:52 <aeolist> something you procrastinating academics never will! muahaha
13:49:55 <ddarius> binarybandit, EvilTerran: So ignore him.
13:49:58 <dons> blbrown: i'd use custom data types for things like Cell . data Cell = Cell !Int !Int
13:50:00 <EvilTerran> especially since he's fallen so spectacularly into his own "blub paradox"
13:50:12 <binarybandit> EvilTerran, exactly.
13:50:39 <dons> ?pl allCells loc = map (\(a,b) -> (a,b)) (allCells' loc)
13:50:39 <noBotE> allCells = allCells'
13:50:44 <yakov_> hey
13:50:49 <EvilTerran> "sure, my particular lisp dialect lacks many things that most modern programming languages have, but that's because i don't like them!"
13:51:01 <dons> blbrown: is that a bug in allCells?
13:51:14 <ddarius> EvilTerran: Don't criticize Paul Graham.  He's a REAL hacker.
13:51:15 <EvilTerran> "dynamic typing makes me more productive! so do unhygenic macros! etcetc!"
13:51:21 <dons> blbrown: the parens are unnec. in  (alive == cur) && (ct <  2)
13:51:23 <blbrown> dons: also, I probably didn't have to use boolean to save the state, could have used some arithmetic
13:51:36 <spammer1488> hello i am a lonely racist spammer looking to chat
13:51:42 <spammer1488> not about racism though its boring
13:51:43 --- mode: ChanServ set +o dons
13:51:45 --- mode: dons set +b *!*i=guest@gateway/tor/x-1ad4185d35cf385f
13:51:45 --- kick: spammer1488 was kicked by dons (dons)
13:51:45 <blbrown> dons: yes, it is a bug, I had taken out some earlier code, in the end I dont need allCells
13:51:47 --- mode: ChanServ set -o dons
13:52:07 <dons> the nextGeneration code is classic old school haskel
13:52:09 <aeolist> lol
13:52:17 <EvilTerran> dons++ that's how it's meant to work
13:52:23 <dons> you might be able to use parallel list comprehensions there.
13:52:25 <dons> EvilTerran: ;)
13:52:38 <gwern> dcoutts_: offhand, I can't really think of anything which isn't a feature request
13:53:21 <yitz> blbrown: we had a discussion a little bit earlier today about avoiding IO for generating random values
13:53:30 <EvilTerran> MonadRandom?
13:53:51 <dons> yes, live is easier with pure randoms
13:54:16 <dcoutts_> gwern: ok, thanks.
13:54:25 <blbrown> yitz, I had trouble with that as well, took me 30 minutes to get it right.  Was there a one liner, to just generate a random number from 0 to 1
13:54:45 <dsrogers> ok, I'm trying to delare a type literal of the form: [t| forall a. (Num a) => TypeAlias a -> IO a |] in TH and am getting a syntax error.
13:55:00 <dsrogers> anyone know what I'm doing wrong?
13:55:02 <yitz> blbrown: the trick is to use getStdGen in your main to get a generator, then pass that into your pure functions.
13:55:12 <EvilTerran> blbrown, the problem is that generating a random number isn't referentially transparent
13:55:36 <Saizan> blbrown: you don't need to use zip to pass around world like that, in fact you don't even use "state", in nextGeneration
13:55:37 <EvilTerran> however, you can use IO to get a seed, and then generating an infinite stream of pseudorandom numbers *is* referentially transparent
13:56:02 <Toxaris> > inRange ((0, 0), (20, 20)) (2, 3) -- no need for custom boundsChk
13:56:03 <noBotE>  True
13:56:23 <yitz> @index inRange
13:56:23 <noBotE> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
13:56:27 <EvilTerran> ?src (,) inRange
13:56:27 <noBotE> Source not found. The more you drive -- the dumber you get.
13:57:28 <newsham> > take 10 $ randomRs (1,10) (mkStdGen 1)
13:57:29 <noBotE>  [8,9,8,10,1,10,7,8,3,1]
13:57:30 <blbrown> this is fun, more people should do this; post a full neophyte example
13:57:40 <Toxaris> blbrown: generally, comments should tell *what* a function does, not *how* :)
13:57:57 <blbrown> do I have comments?
13:58:01 <Toxaris> blbrown: e.g. "Use list comprehensions to get a list of cells." is not that helpful
13:58:36 --- mode: ChanServ set +o glguy
13:58:56 --- mode: glguy set -b *!*i=guest@gateway/tor/x-1ad4185d35cf385f
13:59:05 --- mode: glguy set -o glguy
13:59:06 <yitz> blbrown: Toxaris means that your code itself is well written so you need to say how it works, ony what it is supposed to do.
14:00:47 <Toxaris> well, generally, the type of allCells tells my that it returns a list of cells, and the use of a list comprehension is obvious, so the comment doesn't tell my anything new. "returns the list of neighboring cells" would be a better comment imho
14:00:50 <yitz> @vixen what do you think of blbrown's code?
14:00:50 <noBotE> i don't know, what?
14:01:06 <tristes_tigres> @vixen
14:01:07 <noBotE> Im going to be a movie star.  I just applied online for this new movie with chris farley.  It only cost me $50!
14:02:07 <Toxaris> blbrown: what ist he point of \(a,b) -> (a,b) ?
14:02:15 <tristes_tigres> @vixen is haskell pure ?
14:02:15 <noBotE> church is my favourite computer scientist.
14:02:19 <dons> he wanted different constructors
14:02:26 <dons> the default (,) constructor needed changing :)
14:02:42 <tristes_tigres> what an evasive answer
14:03:01 <Toxaris> that answer is not so bad
14:03:15 <blbrown> Toxaris, not used, dons mentioned that; I had some code there earlier
14:03:44 <yitz> filter (\x -> x) states is just states
14:03:45 <Myoma> swap = (a,b) -> (a,b)
14:03:50 <FunctorSalad_> @vixen tristes_tigres thinks you're avoiding answering the question
14:03:50 <noBotE> i dunno, what was the question?
14:03:51 <Myoma> swap (a,b) = (a,b)
14:03:54 <Myoma> I like that one
14:04:30 <Toxaris> @pl \pos -> (getState world pos)
14:04:30 <noBotE> getState world
14:04:32 <blbrown> yitz, 'states' is a list of boolean values
14:04:33 <yitz> I think we should add it to the hnop package
14:05:26 <sbahra> @seen vixey
14:05:26 <noBotE> vixey is in #haskell and #haskell-blah. I last heard vixey speak 1m 27d 21h 34m 52s ago.
14:05:36 <FunctorSalad_> Cale: btw, I found a solution for the "huge contexts" issue. CPP for the win :D
14:05:39 <sbahra> uhm
14:05:53 <Cale> FunctorSalad_: hehe
14:06:05 <yitz> blbrown: ah, i see, ok. filter id counts the number of True.
14:06:39 <blbrown> yitz, yea, I didn't know if that is the best approach for that,  I assume the identify function could be used for that
14:07:05 <blbrown> identify
14:07:26 <yitz> yeah it's fine, my mistake. Just use id instead of \x-> x.
14:07:46 <blbrown> identity is what I meant, yea
14:07:54 <yitz> @type id
14:07:55 <noBotE> forall a. a -> a
14:08:02 <newsham> > (id.id.id.id.id.id.id) 5
14:08:02 <yitz> @src id
14:08:03 <noBotE> id x = x
14:08:03 <noBotE>  5
14:08:55 <Toxaris> blbrown: you use Bool with alive and dead to rename True and False. I propose data State = Alive | Dead instead
14:08:56 <yitz> > foldl1 (.) $ replicate 100 id $ 5
14:08:57 <noBotE>  Couldn't match expected type `a -> b'
14:09:15 <blbrown> Toxaris: I don't mind that
14:09:42 <Toxaris> blbrown: or type Alive = Bool, and use True, but comparing against some blessed boolean value seems complicated and misleading
14:10:02 <dons> yeah, in haskell land, use a data type to match the domain.
14:10:11 <dons> its just as cheap as Bool, but cuter
14:10:16 <Cale> grr... stupid freenode not detecting disconnected clients...
14:10:34 <dons> so, what's next for haskell?
14:10:38 <tristes_tigres> @type replicate.head []
14:10:39 <noBotE> forall a (f :: * -> *). (Functor f) => f (a -> [a])
14:10:59 <dons> Cale, hmm, i wonder, when RWH lands, we might ( i hope!) see a few new faces in here.
14:11:01 <yitz> dons: how can we make it easier to use cheap hosting for haskell web apps?
14:11:06 <dons> hmm.
14:11:19 <dons> cgi works everywhere :)
14:11:24 <gwern> darcshub?
14:11:29 <yitz> besides demand pushing the providers to provide it of course
14:11:38 <gwern> no, wait, that's project hosting, not web apps sry
14:11:45 <gwern> lambdabot: run 1+1
14:11:49 <Cale> dons: Do you mention the IRC channel in the book?
14:11:50 <yitz> dons no it doesn't. not for shell-less php hosting for example
14:11:55 <dons> Cale, yep.
14:11:56 <r3m0t> > 1+1
14:11:57 <noBotE>  2
14:12:05 <lambdabot>  2
14:12:14 <mwc> http://mult.ifario.us/p/first-steps-with-haskell-for-web-applications old post, but haskell's RSS is pretty small running FCGI
14:12:20 <dons> Cale: so hmm, Dec/Jan are usually busy. maybe more so this year
14:12:20 <Myoma> ?quine
14:12:20 <noBotE> Maybe you meant: quit quote
14:12:21 <gwern> Cale: btw, tonight I'm going to finally get lambdabot working with cabal data-files and free lambdabot from the shackles of only running in the darcs repo
14:12:21 <Cale> lambdabot is always slow when it's connecting to channels (which takes a while since it's in something like 50 of them :)
14:12:26 <noBotE> Title: first-steps-with-haskell-for-web-applications, http://tinyurl.com/4y7avp
14:12:27 <lambdabot> Maybe you meant: quit quote
14:12:27 <mwc> honestly, just tell people to switch to a VPS hosting package for haskell apps
14:12:36 <mwc> they're very competitive with commodity shared hosting
14:12:36 <Cale> gwern: that's awesome :)
14:12:40 <tristes_tigres> @vixen Do you like lambdabot ?
14:12:40 <yitz> dons: here is an example. let's say my hosting does give me shell access, but they won't install haskell. how do I compile ghc in userland, let's say on *BSD?
14:12:40 <noBotE> why does everyone ask i'f on a bot?
14:12:45 <lambdabot> a bot? what is that?
14:12:50 <blbrown> are there any haskell groups in large cities (or small for that matter);  anyone in Atlanta
14:13:12 <mwc> yitz: compile and upload the binary yourself?
14:13:18 * tristes_tigres wants to get noBotE and lambdabot to argue
14:13:20 <blbrown> im sure there are...actually
14:13:27 <dons> yitz: well, you can always install it in userland.
14:13:27 <dobblego> blbrown, yes, many
14:13:42 <gwern> Cale: nah, it should be easy. the hardest part is doing the fallback code - 'if file exists locally then return it; else if file exists in ~/.lambdabot return it; else cp file from cabal into ~/.lambdabot and return it
14:13:48 <dons> http://haskell.org/haskellwiki/User_groups
14:13:49 <noBotE> Title: User groups - HaskellWiki
14:13:52 <dons> blbrown: grouped by area.
14:13:53 <yitz> dons: can you install a port in userland easily in *BSD?
14:13:57 <lambdabot> Title: User groups - HaskellWiki
14:14:20 <dons> yitz, not sure if its easy. but ghc the app of course can be.
14:14:32 <dons> but ideally you don't want to compile on the host , right?
14:14:35 <dons> just upload static binaries?
14:14:45 <yitz> dons: how easily? to compile you'd have to bootstrap from C
14:14:53 <yitz> dons: where do I get them?
14:15:03 <dons> static binaries of your web app?
14:15:21 <dons> i'm saying the best way is to produce a static web app binary on your dev box, and upload that to the host
14:15:59 <yitz> dons: so I need to recreate the whole binary environment of the host? I may not even know exactly what it is.
14:16:10 <yitz> dons: I don
14:16:21 <Toxaris> doesn't sound very portable
14:16:27 <yitz> t run BSD. So - I install vmware, etc. ?
14:16:41 <dons> that would be one way, yeah. vmware's a good choice.
14:16:47 <yitz> dons: I'll be we can improve on this
14:16:55 <yitz> bet
14:17:11 <dons> a) you can install ghc in userland . b) some hosts will install ghc c) don't develop on the host.
14:17:18 <dons>  i think that's the main thing.
14:17:23 <dons> so not sure what steps to take after that.
14:17:32 <dons> other than getting php banned in the international criminal court.
14:17:40 <yitz> he
14:18:13 <Toxaris> dons: mod_haskell ?
14:18:15 <Toxaris> ;)
14:18:17 <yitz> dons: how about if we provide some pre-compiled ghc binaries that can be installed on popular hosting platforms in userland?
14:18:25 <dons> yeah, that's a good idea.
14:18:28 <dons> web-ready ghc
14:18:49 <ddarius> Toxaris: There is (or was) a mod_haskell
14:18:54 <yitz> Toxaris: write a YHC core backend for PHP.
14:19:21 <newsham> use yhc to generate client-side javascript and write your app client-side? ;-)
14:19:51 <yitz> dons: it's not quite so simple though. you have to match various libc's for example.
14:19:57 <Toxaris> yitz: would that compile PHP to YHC Core or the other way around?
14:20:09 <yitz> Toxaris: Haskell to PHP
14:20:14 <newsham> yitz: compile a static binary and no worries about lib versions
14:20:50 <yitz> newsham: would that work for ghc?
14:21:01 <newsham> i dont know.
14:21:08 <yitz> dons?
14:21:50 <yitz> would you have to link in a static copy of gcc?
14:22:07 <Toxaris> yitz: sounds cool, but a JVM would be so much cooler, especially with some integration magic into Java frameworks
14:22:14 <dons> yeah, static binaries.
14:23:41 <mm_freak> horizontal = [ xs | xs <- matrix, (a:b:c:d:_) <- xs ]   -- 'matrix' is of type [[Int]]â¦  what am i doing wrong here?
14:23:42 <yitz> There are plenty of cheap hosting providers that give a shell where you could do that. Or IRC shell providers. It would be a big push for Haskell if we could provide links that make that trivially easy.
14:24:11 <mm_freak> uhm, sorry
14:24:16 <mm_freak> horizontal = [ (a,b,c,d) | xs <- matrix, (a:b:c:d:_) <- xs ]   -- 'matrix' is of type [[Int]]â¦  what am i doing wrong here?
14:24:58 <yitz> Toxaris: yeah, a JVM compiler would also be really nice. That could be done via YHC core also, as an easy first step. There are rumors that it will soon be possible to compile GHC core down to YHC core.
14:25:02 <EvilTerran> mm_freak, what's happening and what's meant to be happening?
14:25:13 <Toxaris> mm_freak: looks good to me, what happens?
14:25:20 <mm_freak> EvilTerran: it doesn't compile
14:25:33 <ekidd> dons: I'm trying to convert from DiffUArray to StorableArray, so I can pass a Ptr to C. Is there a nice way to do this? Cale suggested using array/assocs.
14:25:37 <EvilTerran> ... that tells me very little
14:25:40 <mm_freak>     Couldn't match expected type `Int' against inferred type `[a]'
14:25:40 <mm_freak>     In the pattern: a : b : c : d : _
14:25:54 <EvilTerran> ahj
14:26:17 <Cale> ekidd: Actually, I realised that array isn't the right thing there of course, since StorableArray is an MArray
14:26:19 <yitz> mm_freak: are you giving a type for horizontal?
14:26:29 <ekidd> dons: This is all in audio code, so performance is pretty critical. The newListArray blah . elems approach is the best I've been able to do.
14:26:30 <mm_freak> no
14:26:40 <EvilTerran> yitz, that's not it
14:26:43 <ekidd> Cale: Yeah, no problem, I worked around it. :-)
14:26:48 <Feuerbach> mm_freak: move pattern matching on xs to the left side
14:27:00 <EvilTerran> mm_freak, note that in "xs <- matrix", you have [Int] on the left and [[Int]] on the right
14:27:00 <mm_freak> giving it a type doesn't solve it
14:27:18 <Feuerbach> [let xs = (a:b:c:d:_) in (a,b,c,d) | xs <- matrix ]
14:27:23 <EvilTerran> mm_freak, while, in "(a:b:c:d:_) <- xs", you have [Int] on both sides
14:27:26 <newsham> > [(a,b) | xs <- ["test","this","out"], (a:b:_) <- xs]
14:27:27 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
14:27:33 <Feuerbach> [let (a:b:c:d:_) = xs in (a,b,c,d) | xs <- matrix ]
14:27:36 <mm_freak> Feuerbach: ah yes, makes sense
14:27:44 <Cale> ekidd: But I wouldn't expect there to be anything faster than doing some kind of loop to convert, since DiffUArray is not a flat structure internally.
14:27:51 <EvilTerran> Feuerbach, mm_freak: there's a much easier way of doing that
14:27:52 <yitz> aha
14:27:57 <EvilTerran> note that the LHS of <- is a pattern
14:28:03 <Toxaris> you can use let in list comprehensions (like in do notation)=
14:28:05 <yitz> let a:b:c:d:_ = xs
14:28:11 <ekidd> Cale: Well, you can get a flat internal structure using 'da // []', right?
14:28:11 <Feuerbach> EvilTerran: sure :)
14:28:17 <Cale> ekidd: That's true...
14:28:22 <Myoma> You know lazy evalution
14:28:23 <EvilTerran> [(a,b,c,d) | a:b:c:d:_ <- matrix]
14:28:34 <Myoma> What's it called that bit where you overwrite the root
14:28:39 <ekidd> Cale: I'd love zero-copy, but I'd settle for a fully-deforrested loop.
14:28:45 <Myoma> ?
14:28:50 <mm_freak> EvilTerran: actually that's what i wanted to do
14:29:01 <mm_freak> somehow i got lost with list nesting =)
14:29:04 <EvilTerran> yeah
14:29:08 <Toxaris> that should work, too, but EvilTerran's is better, of course: [(a, b, c, d) | xs <- matrix, let a:b:c:d:_ = xs]
14:29:12 <Cale> ekidd: Did you try the way I suggested? Is it too slow?
14:29:13 <mm_freak> thanks all
14:29:24 <yitz> yep go with EvilTerran
14:29:48 <EvilTerran> mm_freak, yeah, the types can get kinda confusing at times
14:29:56 <mm_freak> ah no
14:30:13 <ekidd> Cale: With -O3, it's not too unreasonable. Lesser optimization levels are grim...
14:30:14 <mm_freak> now i know what was the flaw in my thought
14:30:26 <EvilTerran> i read "<-" as â
14:30:29 <EvilTerran> "element of"
14:30:35 <Cale> -O2 (O3 doesn't exist)
14:30:35 <EvilTerran> like it's a set comprehension
14:30:52 <binrapt> (take len . drop n) s <- is that syntactical sugar whih expands to (take len s) . (drop n s)?
14:30:56 <binrapt> *which
14:30:58 <Toxaris> yitz: is that "easy first step" meant seriously?
14:31:07 <EvilTerran> or "set-builder notation", i believe my maths lecturer called it
14:31:16 <r3m0t> binrapt: it's (take len (drop n s))
14:31:23 <EvilTerran> binrapt, (.) is an operator
14:31:25 <EvilTerran> ?src (.)
14:31:26 <lambdabot> (f . g) x = f (g x)
14:31:34 <mm_freak> [ (a,b,c,d) | xs <- tails matrix, (a:b:c:d:_) <- xs ]
14:31:38 <mm_freak> that's what i actually wanted
14:31:42 <binrapt> Yeah I'm familiar with composition in mathematics hm
14:31:43 <yitz> Toxaris: half seriously. in a relative sense. it would sure be a lot easier than writing a JVM backend for ghc.
14:31:47 <ekidd> Cale: Well, my ghc was accepting it. :-) Passing -O2 gets the same results, of course.
14:31:55 <binrapt> Err yeah that was non-sense
14:31:57 <dons> -O3 is clamped to -O2
14:32:06 <EvilTerran> mm_freak, ah, yeah, the "tails" adds another layer of listiness
14:32:08 <Cale> -O99
14:32:09 <Cale> hehe
14:32:15 <Toxaris> binrapt: it's not syntacticaly sugar, (.) is a regular function just like every other function
14:32:18 <EvilTerran> -O1337
14:32:25 <newsham> ?src (.)
14:32:25 <lambdabot> (f . g) x = f (g x)
14:32:28 <mm_freak> EvilTerran: yes, in fact my idea was right, but it was merely a typo =)
14:33:02 <EvilTerran> mm_freak, and you can thank strict static typing for making that a compile-time error
14:33:04 <EvilTerran> :)
14:33:09 <ekidd> dons: Some time when you have some spare moments, I'd like to pick your brain on audio formats. HCodec's DiffUArray isn't bad, but a lazy stream of StorableArray chunks (or something like that) might actually be easier to interface to C.
14:33:25 <dons> DiffUArray is weird, imo.
14:33:32 <dons> we need chunked uvectors
14:33:38 <mm_freak> EvilTerran: i almost can't live without strict static typing anymoreâ¦  a few weeks ago i was forced to use PHP for something
14:33:41 <mm_freak> it was hell =)
14:33:48 <EvilTerran> yeah, i agree
14:33:59 <ekidd> dons: Yeah. But DiffUArray is still way better than [[a]], which is what the rest of Hackage is using.
14:34:01 <EvilTerran> if anything, i'm wandering towards even stricter languages than haskell
14:34:02 <Cale> dons: what about a Data.Sequence of them? :)
14:34:04 <EvilTerran> total programming, that kinda thing
14:34:10 <EvilTerran> gonna learn Agda sometime
14:34:18 <sampointon> mm_freak: now that I'm starting to really grok Haskell, Python feels really weird
14:34:26 <r3m0t> PHP is always hell
14:34:36 <EvilTerran> oh, hi r3m0t
14:34:44 <r3m0t> yeah, hi there
14:34:45 <mm_freak> sampointon: yesâ¦  and IIRC they even want to remove the last few functional bits from python
14:34:55 <r3m0t> I tend to leave this channel open now instead of #compsci or #xkcd
14:35:03 <mm_freak> things like lambda or 'reduce' (which is a less powerful variant of a fold)
14:35:04 <yitz> mm_freak: nah, that effort failed years ago
14:35:11 <yitz> reduce is gone
14:35:13 <nerdibangbang> hejsan hej
14:35:13 <nerdibangbang> hejsan hej
14:35:13 <nerdibangbang> hejsan hej
14:35:13 <sampointon> mm_freak: actually I'm not outraged about that. Listcomps are usually better than map, and reduce was borked anyway
14:35:16 <nerdibangbang> hejsan hej
14:35:18 <nerdibangbang> hejsan hej
14:35:20 <nerdibangbang> hejsan hej
14:35:20 <mm_freak> yitz: oh
14:35:24 <ekidd> Cale, dons: Anyway, I've got to run. But thank you for your advice!
14:35:28 <EvilTerran> ... what
14:35:42 <yitz> you use comprehensions instead of reduce, generally
14:35:46 * ekidd hopes to have some reasonably sane, standard and fast audio formats in Haskell someday
14:35:52 <r3m0t> nerdibangbang: what did you just say about my mother?
14:36:12 <sampointon> yitz: in Python, it's a for-loop + state instead, mostly
14:36:16 <yitz> mm_freak: but they've added generator comprehensions, which is a serious increase of laziness in the language.
14:36:30 <haskellian> r4m=t: he emant to say that she is a very lovely being and has raised the most awesome kid
14:36:40 <haskellian> sorry i wont psm anymore
14:36:46 <haskellian> i was just trying my bot
14:36:49 <haskellian> spam
14:36:51 <haskellian> no more
14:36:57 <sampointon> personally, I think Python is better without reduce as a builtin, and map discouraged in favour of listcomps. It feels more cohesive
14:37:01 <mm_freak> yitz: yeah, but i've never programmed seriously in python
14:37:11 <mm_freak> somehow i don't like itâ¦  it feels like a failed haskellâ¦  i dunno why
14:37:12 <binrapt> (take len . drop n) s <- I still fail to understand it, what does "drop n" evaluate to exactly? It's a function which takes two arguments, right? So why can you just one in this case?
14:37:35 <yitz> sampointon: yes. it doesn't take away from the functionalness of Python.
14:37:37 <binrapt> Or can you use a function with n arguments, specify m of them with m <= n and put n - m to the right where s stands in this case?
14:37:37 <Cale> binrapt: In some sense, every function in Haskell has only one parameter
14:37:46 <EvilTerran> haskellian, bots aren't allowed in here without explicit prior permission
14:37:56 <Cale> binrapt: Applying a function to one parameter will give a function of the remainder of the parameters
14:37:58 <EvilTerran> IIRC
14:38:01 <binrapt> Ok
14:38:02 <EvilTerran> ?src drop
14:38:03 <lambdabot> drop n xs     | n <= 0 =  xs
14:38:03 <lambdabot> drop _ []              =  []
14:38:03 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
14:38:19 <haskellian> listcomprehensions are faster and more pythonic and with the crippled lambdas you can do everything more clearly with listcomprehensions thatn with map/filter/reduce anyway
14:38:20 <EvilTerran> you can read "drop n xs" as "(drop n) xs"
14:38:25 <binrapt> It's a partial specialisation so to say? Hm
14:38:26 <EvilTerran> ?type drop
14:38:28 <Cale> binrapt: so  (drop n)  evaluates to the function which drops the first n elements of the list to which it is applied
14:38:29 <lambdabot> forall a. Int -> [a] -> [a]
14:38:29 <haskellian> evil: sorry no more
14:38:33 <EvilTerran> ?type drop 3
14:38:34 <lambdabot> forall a. [a] -> [a]
14:38:49 <yitz> haskellian: and generator comprehensions, for laziness
14:38:57 <EvilTerran> ?type map
14:38:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:39:03 <EvilTerran> ?type map sqrt
14:39:04 <lambdabot> forall a. (Floating a) => [a] -> [a]
14:39:07 <haskellian> yitz: yes
14:39:12 <Jedai> binrapt: Yes, one of the advantage of currying (the "all function have only one argument" stuff) is that it makes partial application really easy
14:39:17 <sampointon> python is a very nice language, just not for purely functional programming
14:39:24 <EvilTerran> binrapt, we call it partial application, but yes
14:39:28 <binrapt> Ok
14:39:51 <EvilTerran> > map (map f) [[a,b,c],[d,e,f],[g,h,i]]
14:39:52 <lambdabot>  Add a type signature
14:39:56 <EvilTerran> > map (map f) [[a,b,c],[d,e,f],[g,h,i]] :: [[Expr]]
14:39:57 <lambdabot>  [[f a,f b,f c],[f d,f e,f f],[f g,f h,f i]]
14:40:12 <EvilTerran> ^ note the partially-applied "map" in (map f)
14:40:25 <matthew-_> lambdabot: "Add a type signature *please*"
14:40:35 * EvilTerran grumbles
14:40:35 <matthew-_> disgraceful lack of manners...
14:42:40 <yitz> binrapt: partial function application in Haskell gives you multiple parameter functions for free analogous to the way that pointers give you multiple dimension arrays for free in C.
14:42:43 <ddarius> matthew-_: Lambdabot's only five or six years old, what do you expect?
14:43:26 <yitz> @vixen hey welcome back lambdabot
14:43:27 <lambdabot> hello
14:43:32 <matthew-_> ddarius: he won't learn unless he's told. One must seek to educate the young.
14:43:34 <dolio> Clearly lambdabot should be rewritten in INTERCAL.
14:43:46 <yitz> dolio: unlambda of course
14:44:13 <binrapt> Huh? So it's nested into each other somehow?
14:44:18 <dolio> Unlambda doesn't track politeness.
14:45:19 <r3m0t> how about lolcode? CAN I HAS CHANNEL.. PLEAZ
14:45:38 <Cale> binrapt: When you apply a function to multiple parameters like  f x y z  what you're really writing is ((f x) y) z
14:45:40 <gwern> well, we do have an unlambda interpreter we could start rewriting lambdabot for...
14:45:50 <binrapt> Ah ok
14:46:12 <Cale> binrapt: So f is applied first to x, giving another function, which is applied to y, giving another function, which is finally applied to z :)
14:46:42 <yitz> binrapt: drop has type Int -> [a] -> [a], which means Int -> ([a] -> [a]). It is a function of one variable, whose result type is a function. So I can write drop 3 [4,5,6,7,8] and it acts effectively like a function of two variables.
14:46:50 <binrapt> So you create n - 1 partial applications first basically?
14:46:55 <binrapt> Until the full n-argument function is called?
14:47:04 <yitz> binrapt: forget about the C analogy unless you are familiar with C.
14:47:27 <binrapt> I am familiar with C heh, I think in C++ mostly
14:47:42 <Cale> binrapt: of course, the compiler usually specialises things a bit, so that you don't waste lots of time creating and then applying these partial applications, but in principle, yes
14:47:50 <mauke> f(x)(y)(z)
14:47:51 <binrapt> Ok
14:47:58 <mauke> wait, this looks a lot like boost.preprocessor
14:48:25 <yitz> binrapt: it's really a one-argument function. But each time we feed it a parameter, the result is a function with one less level of function "indirection", until finally we get down to a non-fucntion type
14:49:59 <yitz> binrapt: ok. just like in C you say a[i][j][k] each time you apply a bracket operator on the right, you get one less level of pointer indirection, until finally you get a non-pointer value.
14:50:04 <Myoma> sorry did my question not make sense?
14:50:20 <binrapt> Ok
14:52:29 <haskellian> lambdabot how much sleep do you need?
14:52:34 <yitz> binrapt: in Haskell, functions are values, not a piece of asm code somewhere in memory. that's what we mean when we say that functions are "first class".
14:53:25 <Myoma> why can't they be both
14:53:34 <binrapt> Prelude> read("0") <- ghc won't evaluate that to a printable string because the type is unclear?
14:53:42 <ddarius> dons: Why does readDouble need to copy?
14:53:50 <binrapt> read("0") :: Int however works
14:53:52 <yitz> Myoma: because then you are limiting how the compiler can optimize it
14:53:57 <binrapt> Or 0 + read("0") or so
14:54:09 <dons> ddarius: it calls into C to do the parsing.
14:54:15 <Myoma> binrapt: You can write read "0" instead
14:54:16 <dons> since i'm lazy.
14:54:21 <dons> and a bad person
14:54:28 <mauke> binrapt: (x) is the same as x
14:54:55 <mauke> binrapt: you know C++ and how it resolves overloading, right?
14:55:04 <mauke> well, Haskell lets you overload based on the return type
14:55:14 <mauke> and that's exactly what happens in read
14:55:20 <yitz> binrapt: right. except 0+read"0" doesn't work, that's still polymorphic.
14:55:34 <mauke> yitz: that should default to Integer
14:55:40 <binrapt> yitz: It works in ghc
14:55:56 <mauke> > 0 + read "0"
14:55:57 <lambdabot>  0
14:56:04 <mauke> > 0 + read "0.5"
14:56:04 <yitz> oh, defaulting. yeah.
14:56:05 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
14:56:07 * ddarius just finished loudly playing a bunch of punk music on his guitar and is now going to watch a video from Dan Friedman's birthday celebration.
14:56:09 <dmhouse> binrapt: for GHCi to print the values out, it passes it through the 'show' function. But show . read is ambiguous -- which Read instance do you go via?
14:56:09 <mauke> > 0.0 + read "0.5"
14:56:11 <lambdabot>  0.5
14:57:31 <Myoma> > 1 : read "[2]"
14:57:32 <lambdabot>  [1,2]
14:57:34 <binrapt> Yeah I know about the (), is it considered bad style not to avoid them in Haskell?
14:57:43 <Myoma> () is not bad style
14:57:46 <binrapt> I hate having to add them when I add more stuff later for the arguments
14:57:54 <mauke> (1) + (2) is bad style
14:58:01 <Myoma> oh I thought you were talking about the unit
14:58:01 <mauke> or return (0)
14:58:12 <binrapt> Well that's not quite the same, mauke :p
14:58:16 <Myoma> putting unnecessary ()'n everywhere is bad
14:58:16 <mauke> binrapt: huh? are you talking about class constraints?
14:58:25 <sjanssen> binrapt: we do have a few functions to remove ()s
14:58:38 <ddarius> Who doesn't know Sussman is interested in physics?
14:58:49 <sjanssen> binrapt: for example, instead of "map f (map g xs)", "map f $ map g xs"
14:58:53 <yitz> binrapt: as a distant descendant of Lisp, Haskell abhors too many parens, to the opposite extreme
14:59:14 <MarcWeber> http://rafb.net/p/0bsOut45.html Why doesn't ghc infer those instance constraints by itself when using template haskell to create those functions (such as line 143) ?
14:59:15 <lambdabot> Title: Nopaste - compilation failure
14:59:26 <bjrn> ddarius: Didn't he also write a book about classical mechanics?
14:59:31 <sjanssen> (substitute for different functions there, I know that they can be fused to "map (f . g) xs")
15:00:54 <ddarius> bjrn: Indeed.
15:01:09 <ddarius> This talk is great so far http://video.google.com/videoplay?docid=-2726904509434151616&hl=en
15:01:10 <lambdabot> Title: Gerald Jay Sussman: The Role of Programming (Dan Friedman's 60th Birthday), http://tinyurl.com/ytb2tx
15:02:14 <ddarius> Including this awesome quote: "In almost all textbooks, even the best, this principle is presented so that it is impossible to understand.  I have not chosen to break with tradition."
15:02:34 <dmhouse> What does that refer to?
15:03:35 <stepcut> does hs plugins support dynamic loading of hierarchical modules ?
15:05:19 <dons> stepcut: yeah, but it's fairly unmaintained.
15:05:25 <dons> we need to move towards a ghc-api module loader
15:05:56 <Myoma> ddarius: I like the way he says `catastrophic` :D
15:06:00 <EvilTerran> ddarius, which principle would that be?
15:06:07 <stepcut> dons: I get the error,  MainWeb.hs: ./objfiles/Index.o: unknown symbol `AlgebraZZamziPagesziSessionData_zdf1_closure'
15:06:16 <stepcut> dons: any idea what I am doing wrong ?
15:06:25 <mauke> preflex: zdec AlgebraZZamziPagesziSessionData_zdf1_closure
15:06:25 <preflex>  AlgebraZam.Pages.SessionData_$f1_closure
15:06:30 <dons> heh
15:06:33 <dons> mauke++
15:07:04 <yitz> preflex help zdec
15:07:04 <preflex>  zdec TEXT - z-decode some text
15:07:13 <stepcut> the objfiles/AlgebraZam/Pages/SessionData.{o|hi} files exist
15:07:26 <tristes_tigres> @bot
15:07:26 <lambdabot> :)
15:09:27 <EvilTerran> preflex: version
15:09:27 <preflex>  4.117
15:09:30 <EvilTerran> er
15:09:50 <Myoma> preflex: version
15:09:50 <preflex>  3.177
15:09:57 <EvilTerran> er?
15:10:03 <mauke> preflex: help version
15:10:03 <preflex>  version - print a random number
15:10:06 <EvilTerran> heh
15:10:17 <EvilTerran> i was hoping for some indication of what program preflex is
15:10:38 <mauke> it's a bot
15:11:00 <EvilTerran> i know that. that's why i'm asking what program it is.
15:11:01 <Botje> preflex: die a horrible death
15:11:09 <Botje> what, no answer?
15:11:21 <mauke> it ignores stuff it doesn't understand
15:11:31 <mauke> accidental feature
15:11:38 <EvilTerran> it doesn't seem to be a lambdabot
15:11:47 <Myoma> can someone tell me the name of this thing please, which happesn in lazy evalution ? :S
15:12:15 <EvilTerran> Myoma, er... can you elaborate?
15:12:40 <mauke> http://www.catb.org/~esr/jargon/html/S/snap.html
15:12:41 <lambdabot> Title: snap
15:12:48 <Myoma> as you evaluate something -- what is the name for 'rewriting the root of an expression'
15:12:59 <Myoma> Do you know the bit I mean?
15:13:10 <yitz> Myoma: reduction?
15:13:19 <Myoma>  well it should be much more specific than reduction
15:13:26 <Myoma> but it happens during reduction
15:13:52 <EvilTerran> i don't think there's a word for what you want
15:13:56 <Myoma> :(
15:14:00 <EvilTerran> it's lazy evaluation because of the reduction rules we use
15:14:07 <Myoma> Can we make up a word
15:14:18 <EvilTerran> if we used different reduction rules, you'd get strict evaulation, but it'd still be incremental reduction
15:14:26 <EvilTerran> Myoma, er... "top-down reduction"?
15:14:31 <Myoma> no I didn't meant that part of things
15:14:49 <Myoma> in this lazy program
15:14:52 <EvilTerran> reduction to WHNF?
15:14:57 <Myoma> let x = square 3 in x + x
15:15:00 <Myoma> you get
15:15:13 <Myoma> #1=(square 3) + #1#
15:15:14 <EvilTerran> ... forcing?
15:15:40 <Myoma> then you get #1=9 + #1#
15:16:04 <EvilTerran> call-by-need?
15:16:15 <BONUS> hmm
15:16:16 <Myoma> if you look at it as a graph, at each stage the root of the graph is rewritten on
15:16:17 <EvilTerran> http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need
15:16:19 <lambdabot> Title: Evaluation strategy - Wikipedia, the free encyclopedia
15:16:24 <Myoma> not that
15:16:37 <Myoma> umm I don't have a vocabulary which lets me say this
15:16:37 <dmhouse> Myoma: what are the #?
15:16:50 <Myoma> dmhouse: I stole this notation from lisp, I don't know how to say it better
15:17:07 <dmhouse> "let x = square 3 in x + x" -> "square 3 + square 3" is substitution.
15:17:07 <dons> first Haskell08 paper on reddit, http://www.reddit.com/comments/6xsw3/haskell08_smallcheck_and_lazy_smallcheck/
15:17:09 <lambdabot> Title: Haskell'08: SmallCheck and Lazy SmallCheck: automatic exhaustive testing for sma ..., http://tinyurl.com/53ma6x
15:17:09 <Myoma> m I can draw an ASCII diagram
15:17:12 <BONUS> > let const2 a _ _ = a in map (uncurry const2 "w00t") (zip [1..3] [5..])
15:17:14 <lambdabot>  Couldn't match expected type `(a, b)'
15:17:18 <dons> i was thinking in the coming weeks we could go through most of the good ones
15:17:22 <BONUS> > let const2 a _ _ = a in map (uncurry (const2 "w00t")) (zip [1..3] [5..])
15:17:24 <lambdabot>  ["w00t","w00t","w00t"]
15:17:34 <dmhouse> Then "square 3 + square 3" -> "3*3 + square 3" is inlining of square.
15:17:35 <dmhouse> And so on.
15:17:42 <Myoma> ah... substitution...
15:17:53 <Myoma> but it is a specific in place substitution!
15:17:57 <EvilTerran> Myoma, i think you could call it graph reduction
15:17:58 <Myoma> that is perfect
15:18:11 <Myoma> yes it is part of graph reduction
15:18:38 <EvilTerran> do you mean specifically the moment of merging two nodes of the graph?
15:18:42 <EvilTerran> (or more than two)
15:18:47 <Myoma> exactly that
15:19:07 <EvilTerran> as in, in your example, merging the three uses of "x"
15:19:11 <EvilTerran> (in a manner of speaking)
15:19:49 <EvilTerran> when you use a let, i think it happens when constructing the graph in the first place rather than during evaluation, mind
15:19:58 * Myoma nods
15:20:20 <mauke> I need decodeUTF8:: ByteString -> Maybe String
15:20:32 <mauke> which package contains that?
15:20:36 <jrockpunk1> hi
15:20:37 <EvilTerran> when the variable is a function parameter, though, that clearly isn't always possible
15:20:58 <Myoma> um I think it's the other way around
15:21:13 <Myoma> It's always possible for a lambda, and sometimes possible for a let
15:21:18 <Myoma> due to the type rules
15:21:21 <EvilTerran> i mean, in something like "map (\x -> x*x) [1..10]"
15:21:35 <EvilTerran> you can merge the three uses of "x" immediately
15:21:49 <EvilTerran> but you can't merge them with a concrete value immediately
15:22:11 <Myoma> I see
15:22:26 <jrockpunk1> hi, I've only just started learning haskell and I know basic C/C++, so haskell is hard for me. I've started reading a tutorial, but I have no idea what it means when it goes on about foldr and foldl. Would anyone be kind enough to explain to me in a noob frienly way what they are and how to use them?
15:22:39 <EvilTerran> the "merging" of a value node and a variable node in the graph manifests itself as substitution when you're representing the graph as an expression
15:23:00 <heatsink> jrockpunk1, have you seen Cale's fold diagrams?
15:23:03 <EvilTerran> so i guess "substitution" is the best term for it
15:23:03 <Olathe> jrockpunk1: They're like a for loop where you get one result from a whole array of items. Like, you might add all the items in an array together.
15:23:03 <Myoma> jrockpunk1: foldr is the catamorphism for lists :)
15:23:17 <jrockpunk1> lol see i dont understand any of the terminology
15:23:21 <Olathe> jrockpunk1: Here's an example :
15:23:32 <aconbere> jrockpunk1: have you checked out Real World Haskell?
15:23:36 <Myoma> jrockpunk1: Did you learn about data types and constructors yet?
15:23:37 <Olathe> > foldr (+) 0 [1, 5, 7]
15:23:39 <lambdabot>  13
15:23:43 <jrockpunk1> i duno. I was reading this
15:23:43 <jrockpunk1> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
15:23:45 <lambdabot> Title: Yet Another Haskell Tutorial
15:23:50 <Jedai> mauke: Unicode ?
15:23:59 <yitz> mauke: encoding, or utf8-string.
15:24:01 <jrockpunk1> Olathe: yes?
15:24:23 <heatsink> jrockpunk1, Olathe's example is the same as (1 + (5 + (7 + 0)))
15:24:39 <jrockpunk1> I know, but just wait a minute
15:24:40 <jrockpunk1> brb
15:24:48 <Myoma> jrockpunk1: I say that you should learn about data types and constructors first
15:24:52 <aconbere> jrockpunk1: http://book.realworldhaskell.org/beta/index.html seems to start at a much earlier state
15:24:53 <lambdabot> Title: Real World Haskell
15:24:59 <EvilTerran> > foldr (+) e [a,b,c,d]
15:25:00 <lambdabot>  a + (b + (c + (d + e)))
15:25:03 <Myoma> jrockpunk1: (it should make it easier)
15:25:10 <Jedai> mauke: utf8-string is your answer
15:25:13 <jrockpunk1> Prelude> foldr (-) 1 [4,8,5]
15:25:13 <jrockpunk1> 0
15:25:18 <Olathe> It's like sum = 0; for (int i = 0; i < 3; i++) sum += arr[i];
15:25:20 <jrockpunk1> i dont get how that works
15:25:22 <jrockpunk1> Prelude> foldr (-) 1 [4,8,5]
15:25:22 <jrockpunk1> 0
15:25:28 <EvilTerran> > foldr (-) 1 [x,y,z]
15:25:29 <Myoma> Olathe: :/
15:25:29 <lambdabot>  x - (y - (z - 1))
15:25:38 <jrockpunk1> ok shhhhhhhhhhhhh
15:25:43 <aconbere> jrockpunk1: the initial value is 1, and it consectutively applyies - to the pairs
15:25:44 <jrockpunk1> explain this please
15:25:47 <Myoma> Olathe: Do you think about that everytime you write a fold?
15:25:53 <ddarius> That talk was awesome.
15:25:54 <jrockpunk1> Prelude> foldr (-) 1 [4,8,5]
15:25:54 <jrockpunk1> 0
15:26:00 <jrockpunk1> explain plese
15:26:01 <mauke> Jedai: which function in there? I can't find it
15:26:17 <EvilTerran> ?src foldr
15:26:17 <lambdabot> foldr f z []     = z
15:26:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:26:18 <Zao> Isn't (-) negation?
15:26:21 <mauke> > 4 - (8 - (5 - 1)))
15:26:21 <lambdabot> Unbalanced parentheses
15:26:24 <mauke> > 4 - (8 - (5 - 1))
15:26:25 <lambdabot>  0
15:26:31 <jrockpunk1> oh shit
15:26:33 <jrockpunk1> what?
15:26:44 <EvilTerran> foldr (-) 1 [4,8,5] = foldr (4:8:5:[])
15:26:48 <jrockpunk1> they just go in one...eye? and out the other
15:26:52 <EvilTerran> er
15:26:56 <EvilTerran> foldr (-) 1 [4,8,5] = foldr (-) 1 (4:8:5:[])
15:26:59 <Jedai> mauke: toString ? depends on what encoding is the ByteString initially
15:27:07 <jrockpunk1> EvilTerran
15:27:13 <jrockpunk1> i know
15:27:15 <EvilTerran> = (-) 4 (foldr 8:5:[])
15:27:15 <mauke> Jedai: toString returns String, not Maybe String
15:27:21 <Zao> Oh right, that's (-x) that's odd.
15:27:21 <jrockpunk1> let me tell you what I know about it
15:27:27 <EvilTerran> = 4 - foldr (-) 1 (8:5:[])
15:27:36 <EvilTerran> sorry, i'm missing things out all over the place, it's kinda late here
15:27:43 <jrockpunk1> fuck. can I talk provately to someone please thats willing to help?
15:27:50 <jrockpunk1> privately*
15:27:51 <EvilTerran> = 4 - ((-) 8 foldr (-) 1 (5:[]))
15:27:53 <EvilTerran> etcetc
15:27:59 <jrockpunk1> :/
15:28:00 <sampointon> my favourite interpretation of 'foldr' is that the cons operator is replaced by the given function
15:28:00 <EvilTerran> do mind your language, this is a family channel
15:28:01 <jrockpunk1> so...
15:28:07 <Myoma> sampointon: Me too
15:28:16 <dmhouse> sampointon: and nil by the seed.
15:28:19 <EvilTerran> damn, missed out more brackets there. someone else who's awake take over.
15:28:21 <Jedai> mauke: Either you check for \xFFFD presence in the results or you use the low-level API to recode it so you get MaybeString
15:28:25 <dmhouse> > foldr f z [1..10]
15:28:26 <Myoma> sampointon: I think of it like pulling a tablecloth out from under all the plates and everything :)
15:28:26 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
15:28:28 <Olathe> I need to make that showfold thing again.
15:28:29 <jrockpunk1> foldr (+,/) (3)(00000123,5,6,9)
15:28:32 <jrockpunk1> i873873i873
15:28:34 <EvilTerran> if only i could persuade hat to work...
15:28:38 <sjanssen> sampointon: the best part of that interpretation is that you can extend it to other catamorpisms easily
15:28:49 <heatsink> jrockpunk: You've got too many people trying to help you at the same time, maybe try PMing one of them.
15:28:58 <mauke> Jedai: what if there's a legitimate \xfffd in there?
15:29:01 <Myoma> heatsink: don't suggest that :/
15:29:01 <jrockpunk1> yeah I duno which will help thogh
15:29:07 <dmhouse> heatsink: erm, really?
15:29:08 <EvilTerran> heatsink, that's a bad idea, he might pm someone who's feeling unhelpful
15:29:11 <jrockpunk1> see lol
15:29:13 <jrockpunk1> i know
15:29:21 <jrockpunk1> I know how these things work
15:29:23 <mauke> Jedai: and where's the low-level api?
15:29:30 <Jedai> mauke: What's this character already ?
15:29:34 <jrockpunk1> I ask someone, they get mad I kill myslef and cry like an emo
15:29:38 <jrockpunk1> then you laugh
15:29:41 <EvilTerran> <jrockpunk1> i dont get how that works
15:29:41 <mauke> U+FFFD (ef bf bd): REPLACEMENT CHARACTER [ï¿½]
15:29:46 <EvilTerran> <jrockpunk1> I know how these things work
15:29:47 <Jedai> mauke: In Data.ByteString.UTF8
15:30:00 <Jedai> mauke: Well "low-level" is reltive
15:30:19 <jrockpunk1> Is anyone willing to help me if I PM you>
15:30:20 <jrockpunk1> ?
15:30:38 <mauke> Jedai: you mean a manual loop around decode?
15:30:40 <Botje> just ask the channel
15:30:47 <aconbere> jrockpunk1: start at a lower level, pick up something like Real World Haskell
15:30:47 <jrockpunk1> too many people
15:30:48 <Botje> there's lots of people here who can help
15:30:56 <Botje> you'll get many answers back :)
15:31:03 <jrockpunk1> exactly
15:31:06 <jrockpunk1> all at once
15:31:09 <aconbere> Botje: he's having a hard time with the channel noise
15:31:10 <aconbere> :)
15:31:15 <sampointon> Botje: half of them category theoretic
15:31:18 <sereven> http://book.realworldhaskell.org/beta/fp.html#fp.foldl
15:31:19 <lambdabot> Title: Chapter 5. Functional programming
15:31:23 <Botje> oh
15:31:36 <heatsink> jrockpunk1, ok
15:31:39 <EvilTerran> could borrow #haskell-overflow , i guess
15:31:53 <Botje> i've got a date with my bed, unfortunately :p
15:31:57 <EvilTerran> likewise
15:32:02 <Jedai> mauke: Or uncons (but I don't think 0xFFFD can really be a valid utf8 character, am I wrong ?
15:32:10 <Tchakkazulu> http://www.foldr.com ;)
15:32:11 <lambdabot> Title: 9 foldr.com 20
15:32:29 <mauke> Jedai: [0xef,0xbf,0xbd]
15:32:32 <Jedai> mauke: If it can it seems a really bad API since you can't detect a malformed character
15:32:35 <mauke> uncons doesn't help
15:32:36 <tristes_tigres> http://foldr.com/ !!!!!!
15:32:37 <lambdabot> Title: 9 foldr.com 20
15:32:42 <tristes_tigres> :)))))
15:32:43 <mauke> Jedai: duh
15:32:48 <Myoma> http://foldl.com
15:32:49 <lambdabot> Title: 9 foldl.com 20
15:34:08 <tristes_tigres> man, these people are evil
15:34:13 <tristes_tigres> but in a good way
15:34:18 <Myoma> which people?
15:34:23 <sjanssen> mauke: you might be able to use Data.Binary to write ByteString -> Maybe String
15:34:26 * EvilTerran is Evil
15:34:31 <tristes_tigres> foldr.com and foldl.com
15:34:34 <Myoma> hehe
15:34:52 <EvilTerran> tristes_tigres, what's the matter, can't stop clicking while that ...'s still there? :P
15:35:05 <mauke> sjanssen: ew
15:35:25 <tristes_tigres> EvilTree: I am hoping for stack overflow
15:35:42 <sjanssen> I know it's a bit out of the way, but the Char instance provides UTF-8
15:35:45 <EvilTerran> mauke, i believe the unicode bytestring thing is (near-)usable now, might that be better suited to your needs?
15:35:56 <mauke> what's that?
15:36:02 <EvilTerran> sioraiocht was working on it
15:36:07 <EvilTerran> GSoC project, i think
15:36:14 <mauke> if it's not on hackage, it doesn't exist
15:36:31 <EvilTerran> ...
15:36:34 <yitz> mauke: what's wrong with utf8-string?
15:36:45 <EvilTerran> it might not have been officially released yet, you'd have to ask sioraiocht for the details
15:36:50 <mauke> <mauke> I need decodeUTF8:: ByteString -> Maybe String
15:37:01 <mauke> and apparently there's no such thing in utf8-string
15:37:11 <glguy> moving utf8 decoding to maybe is a bad idea, breaks laziness
15:37:16 <tristes_tigres> I need askOut :: Female -> Maybe Date
15:37:23 <mauke> glguy: what laziness?
15:37:30 <EvilTerran> tristes_tigres, const Nothing :(
15:37:33 <MyCatVerbs> tristes_tigres: const Nothing will do that just fine.
15:37:48 * EvilTerran highfives MyCatVerbs
15:38:00 <glguy> mauke: would  be a shame to not get any results until the decoder has found the end of the input bytes
15:38:06 <yitz> mauke: Data.ByteString.UTF8.decode :: ByteString -> Maybe (Char, Int)
15:38:10 <mauke> glguy: no, that would be sane
15:38:15 <yitz> mauke Nothing means no more bytes
15:38:20 <glguy> mauke: and the replacement character is a standard behavior
15:38:21 <Myoma> since when are Male/Female types
15:38:24 * MyCatVerbs highfives, lowfives, does the secret handshake with EvilTerran.
15:38:31 <mauke> glguy: it's one of the standard behaviors
15:38:36 <glguy> mauke: yup
15:38:37 <yitz> errors get replaced by 0xfffd
15:38:37 <mauke> glguy: I happen to need the other one
15:38:40 <Jedai> yitz: No that only returns a FFFD character if problems (the Nothing is for a null Bytestring)
15:38:53 * EvilTerran lowfives MyCatVerbs, but fumbles the secret handshake because he's lying in bed
15:38:54 <glguy> mauke: the code is all there, just change it to suit
15:39:00 <mauke> great, copy/paste
15:39:03 <Heffalump> hmm. Getting cabal-install running on GHC 6.6 as a user seems non-trivial
15:39:23 <glguy> mauke: sometimes the behavior you want is different than waht everyone else wants, so you have to modify code
15:39:24 * EvilTerran -> several hours of unconciousness, hallucinations, and memory loss
15:39:26 <EvilTerran> g'night guys
15:39:40 <yitz> mauke: right so it's easy to get what you want from that
15:39:42 <glguy> mauke: if you can fit in into the library, send a patch
15:39:45 <mauke> yitz: how so?
15:40:56 <yitz> do { (c, _) <- decode b; guard $ c /= replacement_char; return c}
15:41:06 <stepcut> ugh. I think the capital Z in AlgebraZam.Pages.Index is what is breaking plugins ;)
15:41:06 <mauke> yitz: what if the string really contains replacement_char?
15:41:31 <yitz> mauke that's invalid unicode i think.
15:41:35 <mauke> no, it isn't
15:41:55 <mauke> I consider the current API premature optimization
15:42:09 <ddarius> askOut = const Nothing
15:42:10 <Jedai> mauke: Well, not really, just incomplete
15:42:26 <dcoutts_> Heffalump: you need filepath, there are instructions here http://www.haskell.org/cabal/code.html
15:42:27 <lambdabot> Title: Getting the Code
15:42:33 * ddarius was away.
15:42:49 <Heffalump> dcoutts_: right, but note the "as a user" bit
15:42:51 <mauke> Jedai: you could build the current API on top of the Maybe thing, but not the inverse
15:42:52 <glguy> mauke: you can always just do two passes
15:42:55 <glguy> one to check validity
15:42:58 <yitz> mauke there's also an interface like the encoding pkg, where an exception is raised on error characters
15:42:58 <glguy> and one to parse
15:43:00 <Heffalump> filepath seems to ignore --user passed to configure
15:43:02 <Myoma> hi
15:43:06 <dcoutts_> Heffalump: --user --prefix=~/.cabal/
15:43:14 <sjanssen> mauke: you can't make an API with the correct strictness out of the Maybe thing
15:43:26 <yitz> glguy: you don't need to fully check validity, just look for an incoming 0xfffd.
15:43:26 <Jedai> mauke: Well you're right about decode or uncons, but not about toString
15:43:31 <mauke> sjanssen: right, that's where the optimization part comes in
15:43:31 <dcoutts_> Heffalump: in older Cabal, --user did not change the default prefix
15:43:40 <Olathe> > showfold foldr
15:43:41 <lambdabot>  "fold (+) 0 [1..10] = (1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0))...
15:43:48 <Heffalump> ahah, that's the missing piece, ta
15:43:48 <mauke> Jedai: huh?
15:43:51 <sjanssen> mauke: strictness is not the same as optimization -- consider 'a':undefined
15:44:01 <Myoma> > showfold (,,)
15:44:02 <lambdabot>  Couldn't match expected type `[Char]'
15:44:04 <sjanssen> strictness is a fundamental part of a function's behavior
15:44:07 <Jedai> mauke: But I agree with you that decode could have been made to have the correct behaviour and that wouldn't have been a problem
15:44:12 <Myoma> :t showfold
15:44:13 <lambdabot> (([Char] -> [Char] -> [Char]) -> [Char] -> [String] -> [Char]) -> [Char]
15:44:20 <sjanssen> mauke: I do agree that both behaviors should be offered
15:44:25 <glguy> it might be interesting to have an API that returns the (String, Remainder) where reminder is either an error and resume function or end of string
15:44:26 <mauke> sjanssen: yes, ok
15:44:50 <glguy> no one has said that alternate behaviors would not be accepted
15:44:51 <Olathe> Myoma : showfold fold = "fold (+) 0 [1..10] = " ++ fold (\a b -> "(" ++ a ++ " + " ++ b ++ ")") "0" (map show [1..10])
15:45:14 <Myoma> > show (foldr (+) 0 [1..10])
15:45:15 <lambdabot>  "55"
15:45:18 <Jedai> glguy: Yeah, that would be a very good semi-primitive
15:45:33 <Olathe> > showfold foldl'
15:45:34 <newsham> > foldr (*) x [a,b,c]
15:45:34 <gwern> http://hpaste.org/9903#a1 <-- any thoughts? I'm sure there's some simple fix, but I can';t find it
15:45:35 <lambdabot>  "fold (+) 0 [1..10] = ((((((((((0 + 1) + 2) + 3) + 4) + 5) + 6) + 7) + 8) + ...
15:45:35 <lambdabot> Terminated
15:45:41 <Myoma> > show (foldr (\x y -> "(" ++ show x ++ "+" ++ show y ++ ")") "0" [1..10])
15:45:42 <lambdabot>  "\"(1+\\\"(2+\\\\\\\"(3+\\\\\\\\\\\\\\\"(4+\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(...
15:45:46 <Olathe> > showfold foldl
15:45:47 <lambdabot>  "fold (+) 0 [1..10] = ((((((((((0 + 1) + 2) + 3) + 4) + 5) + 6) + 7) + 8) + ...
15:45:48 <sjanssen> actually, the best API is [Either Error Char]
15:45:50 <Myoma> > show (foldr (\x y -> "(" ++ show x ++ "+" ++ y ++ ")") "0" [1..10])
15:45:51 <lambdabot>  "\"(1+(2+(3+(4+(5+(6+(7+(8+(9+(10+0))))))))))\""
15:45:58 <mauke> yitz: AFAICS it raises an error, not an exception
15:46:07 <dmhouse> > foldr f z [1..10]
15:46:09 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
15:46:13 <Olathe> > show (foldl (\x y -> "(" ++ show x ++ "+" ++ y ++ ")") "0" [1..10])
15:46:14 <lambdabot>      No instance for (Enum [Char])
15:46:14 <lambdabot>       arising from the arithmetic sequence...
15:46:23 <Olathe> > show (foldl (\x y -> "(" ++ show x ++ "+" ++ show y ++ ")") "0" [1..10])
15:46:24 <lambdabot>  "\"(\\\"(\\\\\\\"(\\\\\\\\\\\\\\\"(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(\\\\\\\\...
15:46:27 <Olathe> Eww.
15:46:27 <yitz> mauke yes yes et tu brute
15:46:34 <sjanssen> we can recover fromString with "either (const replacementchar) id"
15:46:42 <sjanssen> and mauke's function is simple too
15:47:34 <Olathe> How do you get lambdabot to show an error message or something ?
15:47:38 <Olathe> > error "test"
15:47:40 <lambdabot>  mueval: *** Exception: test
15:47:54 <sjanssen> glguy: is utf8-string fast?  Is it meant to be?
15:48:06 <Saizan> gwern: align "case second of" with "second <- .." on the above line
15:48:25 <ddarius> Carefully reasoned balances of strictness and laziness, that's what I like to see.
15:48:26 <glguy> sjanssen: fast enough?
15:48:38 <Olathe> > (error . cycle) "test"
15:48:46 <lambdabot>  mueval: Time limit exceeded
15:48:56 <Jedai> sjanssen: I think it's meant to be, but on the other hand, nothing prevents you to do an API with fast parts and slow but convenient parts
15:48:57 <Olathe> Hmm...
15:49:43 <gwern> Saizan: ah, I see
15:49:47 <Jedai> sjanssen: glguy proposition seemed like it could be both fast and convenient though
15:50:25 <sjanssen> glguy: I think you've fused error detection and character replacement in your current code
15:50:34 <sjanssen> clearly the solution is to un-fuse them
15:50:48 <glguy> there isn't "a problem"
15:51:44 <gwern> ok, second question. how would I go about having a single call to lookHome f in http://hpaste.org/9903#a2 ?
15:51:45 <glguy> the current code could be similarly parameterized by taking an "error function"
15:51:51 <glguy> it doesn't matter to me
15:51:55 <sjanssen> can we write [Word8] -> String with the current interface?  (keeping in mind that the replacement character is a legitimate character)
15:51:56 <glguy> if someone wants to change it around
15:52:08 <sjanssen> erm, I mean [Word8] -> Maybe String
15:53:02 <Jedai> sjanssen: No, the interface is the same as ByteString (which given ByteString is a flattened [Word8] is pretty normal)
15:53:12 <sjanssen> bleh, utf8-string uses git now :(
15:53:19 <glguy> darcs is old news
15:53:29 <sjanssen> foo on you
15:53:45 <dons> glguy's part of a git sleeper cell.
15:53:57 <sjanssen> glguy: "git clone git://github.com/glguy/monadlib.git" from utf8-strings motd
15:54:01 <dons> anyway, look at #darcs, a bit of competition is good.
15:54:12 <gwern> he's a git! burn him!
15:54:13 <dons> heh.
15:54:17 <sjanssen> I don't really want to learn git
15:54:18 <jrockpunk1> cya everyone, heatsink helped me a lot :D
15:54:22 <dons> glguy: you installing monadlib on everyone's box? :)
15:54:22 <jrockpunk1> bye
15:54:43 <dons> sjanssen: its much the same as darcs as we use it. pull;add;commit;push
15:54:47 <glguy> "I don't want to learn it" is how people got stuck with cvs for so long
15:54:52 <gwern> I already know why I don't want to learn git. I was reading an article today about how to use git easily with only 20 or more commands
15:54:54 <dons> go glguy!
15:54:54 <sjanssen> dons: "send"?
15:55:09 <dons> send is send-mail or something. glguy ?
15:55:14 <wjt> send-email
15:55:29 <stepcut> dons: figured out what was wrong, you should not be calling decode here, because the path names are not actually Z-coded,                 let mods_ = map (\s -> (s, map (\c -> if c == '.' then '/' else c) $ {- decode -} s)) ds'
15:55:36 <Heffalump> dons: I still can't configure cabal - it can't find System.FilePath even with filepath-1.1.0.0 installed and either --user or --user --prefix=~/.cabal/
15:55:37 <dons> stepcut: oh!
15:55:39 <ddarius> glguy: As opposed to what?
15:55:39 <wjt> (or notâ¦)
15:55:49 <Heffalump> hmm. Something's a bit fishy there, hangon
15:56:02 <stepcut> dons: would you like a darcs patch ?
15:56:09 <MyCatVerbs> sjanssen: Codec.Binary.UTF8.String.decode does [Word8] -> String, but doesn't apparently have any good error reporting built it.
15:56:26 <Saizan> gwern: why do you call lookHome repeadetly at all? in some places you don't even look at the result, and it doesn't have interesting side-effects, also use System.FilePath for path-handling
15:56:27 <glguy> MyCatVerbs: that's what he is complaining about
15:56:34 <dons> stepcut: sure.
15:56:38 <Heffalump> nope, it definitely can't. But it's weird, because before I removed the system installed old version of filepath, it was complaining that it was in two places.
15:56:46 <gwern> Saizan: return type
15:56:55 <glguy> I'm actually pretty surprised at the frequency of "I don't want ot learn something new" from a community like Haskell
15:57:04 <MyCatVerbs> glguy: oh, my bad.
15:57:08 <glguy> where we do about everything differently
15:57:15 <gwern> Saizan: it's not as well written as it could be, I'll admit...
15:57:25 <dons> glguy: only in relation to darcs?
15:57:28 <Saizan> gwern: if you don't look at the result you can surely just change the return type to ()?
15:57:41 <gwern> glguy: dammit, I have enough to learn already!
15:57:42 <Jedai> glguy: As long as the thing we don't want to learn isn't in Haskell we can get away with it ^^
15:57:43 <dons> glguy: people often feel like that about tools, esp. considering the social capital invested in darcs.
15:58:08 <dons> its the human natural 'tendancy to habit' that we must work against
15:58:19 <gwern> Saizan: the idea is that the rest of lambdabot can just call 'findFIle', and if a file isn't in ~/.lambdabot, findFile automatically fixes things, and the caller need never know
15:58:19 <Myoma> what is tde problem with darcs
15:58:21 <Myoma> ?
15:58:29 <yitz> mauke: what is wrong with 0xfffd? it means exactly "a substitute for an uninterpretable character from another encoding".
15:58:53 <sjanssen> yitz: what if the source text has an 0xfffd?
15:59:06 <glguy> it still will afterwards
15:59:11 <sjanssen> yitz: mauke wants to catch encoding errors -- not translation errors
15:59:12 <dons> glguy: it's called the "status quo bias"
15:59:35 <yitz> sjanssen: that means "a substitute for an uninterpretable character from another encoding" so it should be rendered as 0xfffd.
15:59:55 <dons> We talk to the same people, follow the same path to work, go through the same daily routine, and so forth. We enjoy little changes - but radical changes? Not so much.
16:00:00 <mauke> yitz: wrong
16:00:04 <gwern> Myoma: some people have issues with bugs and performance
16:00:07 <dons> and tech disruptions are radical.
16:00:10 <sjanssen> yitz: "used to replace an incoming *character* whose value is unknown or unrepresentable in Unicode"
16:00:13 <jrockpunk1> ah shit
16:00:17 <yitz> mauke: i pasted that from the Unicode standard, it is correct.
16:00:18 <dons> just look at how people respond to the idea of having to learn say, haskell, to do multicore.
16:00:19 <jrockpunk1> haskell is too hard
16:00:23 <mauke> yitz: it means "this is not utf-8 at all, try another encoding"
16:00:23 <dons> they wet their pants.
16:00:25 <sjanssen> yitz: UTF-8 decoding errors do not constitute characters
16:00:40 <dons> i should write something about status quo bias and new technologies. hmm
16:00:51 <Heffalump> oh. I see what happened. I now have ./filepath-1.1.0.0/~/.cabal/...
16:01:11 <dons> if we want out "technology markets" to operate efficiently, we have to ensure everyone's familiar with the available solutions in an area, then technologies can fairly compete
16:01:16 <dons> but the status quo bias prevents this.
16:01:21 <dons> locking people into their habits
16:01:38 <sjanssen> yitz: we want to know whether a source text is valid UTF-8 the current API does not make this possible
16:01:53 <sampointon> dons: how much of it is 'if it ain't broke, don't fix it'?
16:02:09 <dons> that might be another way of describing the status quo bias, spec. for technology.
16:02:20 <dons> which means improvements get ignored.
16:02:28 <dons> maybe its another formulation of 'blub paradox'
16:02:59 <Olathe> > error "Long message..........................................................................................................................................................................."
16:03:00 <lambdabot>  mueval: *** Exception: Long message............................................
16:03:07 <Olathe> > "Long message..........................................................................................................................................................................."
16:03:08 <lambdabot>  "Long message..................................................................
16:03:16 <Olathe> That didn't help at all.
16:03:26 <sampointon> dons: perhaps. I'm reminded of what another prominent technology hot-air salesman said, though
16:03:27 <Heffalump> help with what?
16:03:39 <roconnor> > error . error $ ""
16:03:40 <Olathe> Showing semilong results in the channel.
16:03:40 <lambdabot>  mueval:
16:03:46 <yitz> dons: it's not always status quo bias. even when things change it's not because of carefully weighing technologies, it's because of vendor hype.
16:03:58 <sampointon> dons: in one of Joel's essays, he makes the point that code in production has been tested in the real-world and is better for that. New code = new bugs
16:04:11 <dons> yeah, hype damages the efficiency, distorting evaluations.
16:04:19 <gwern> > 1 + 1
16:04:20 <lambdabot>  2
16:04:36 <gwern> hm. error . error is an interesting tack
16:04:42 <gwern> :t error . error
16:04:43 <lambdabot> forall c. [Char] -> c
16:04:46 <dons> sampointon: yeah, that's a good point. the difficulty of softare.
16:04:56 <Olathe> > error.error.error $ "test"
16:04:57 <lambdabot>  mueval: test
16:05:05 <dons> but all these factors conspire to slow down change in our industry.
16:05:10 <Saizan> gwern: http://hpaste.org/9903#a3 ?
16:05:11 <ddarius> > fix error
16:05:13 <dibblego> if new code = new bugs, then I better stop writing tests
16:05:20 <dons> dibblego: right! and code too!
16:05:26 <yitz> mauke: well, so you'll say that the current api is buggy. but at least it's easy to work around.
16:05:26 <lambdabot>  thread killed
16:05:27 <dons> so its not an absolute.
16:05:35 <dibblego> and I am tired of people misusing = when they intend ->
16:05:41 <mauke> yitz: er, I wouldn't call that easy
16:05:56 <ddarius> dibblego: It's not a problem if all code is buggy.
16:06:00 <sampointon> dibblego: be kind, I've not got the hang of arrows yet :(
16:06:13 <dibblego> sampointon, I was directing that at Joel
16:06:19 <yitz> you mean pre-filtering 0xfffd isn't easy?
16:06:31 <gwern> Saizan: looks good
16:06:35 <mauke> yitz: wtf
16:06:51 <dibblego> sampointon, by the way, -> is logical implication; it's very easy to understand (not related to Arrows)
16:07:03 <sampointon> dibblego: I know, I was being silly
16:07:11 <Myoma> dibblego: I hate the too :/
16:07:11 <dibblego> k
16:07:40 <dibblego> MS Windows = bad, Hitler = bad, Windows = Hitler!
16:07:42 <dibblego> :)
16:07:55 <sampointon> the equals sign is so abused, another few minor abusages won't kill any more puppies
16:08:28 <gwern> let us assume 1 = 2; I and the pope are 2, and I am 1; by 1 = 2, I am the pope
16:08:29 <yitz> mauke every valid utf8 has a unicode repr. in String, so any 0xfffd that wasn't there before and is injected by decode is an error, not a legitimate 0xfffd. So that's the work-around.
16:08:54 <mauke> yitz: that's close to TheDailyWTF material
16:08:54 <sjanssen> yitz: but that's just dumb
16:08:58 <ddarius> equal sign abusage = bad, killing puppies = bad, equal sign abusage = Hitler!
16:09:07 * sbahra wasn't aware there was an implication that wasn't logical :-P
16:09:08 <yitz> ok then.
16:09:12 <MyCatVerbs> sampointon: there is, IMO, one thing more commonly abused by people who don't actually understand mathematics than the equality symbol: "100%".
16:09:12 <gwern> heil hitler!
16:09:15 <sbahra> Material implication is probably what you mean ;-p
16:09:28 <glguy> There are values that fit in Char that aren't vali
16:09:29 <glguy> d
16:09:55 <MyCatVerbs> sampointon: I've yet to see "100%" used in informal writing by anyone who wasn't undisputably a total doofus.
16:09:59 <ddarius> MyCatVerbs: I agree with you 115.3%
16:10:08 <Myoma> it's not people that don't understand mathematics that misuse =
16:10:10 <Heffalump> dons: your arch packaging effort is too successful, it's pushing out hackage in the google results :-)
16:10:13 <Myoma> everyone does it >_<
16:10:14 <haskellian> good link to explanation of difference between foldl and foldl' ?
16:10:16 <sampointon> MyCatVerbs: eh, I have a soft spot for idiom. I was thinking mathematical abuses of equals
16:10:24 <dons> Heffalump: haha
16:10:25 <ddarius> haskellian: Just use foldl'
16:10:31 <dons> Heffalump: i also notice it is pulling in Arch users.
16:10:36 <ddarius> If you really want to read something read
16:10:37 <MyCatVerbs> sampointon: I hate that idiom very, very much.
16:10:38 <ddarius> @wiki Stack overflow
16:10:38 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
16:10:39 * dons lights fires under Debian
16:10:54 <sbahra> ah
16:10:54 <sbahra> ic
16:10:56 <yitz> dons: stepcut lights fires under Debian
16:11:05 <dons> WOO!
16:11:07 <dons> go stepcut!
16:11:19 <dons> stepcut: will you be at ICFP?
16:11:19 <sjanssen> glguy: there are, but you can't construct them without busting into GHC.Exts
16:11:28 <dons> i think we should find a break out room and do a packaging system hackathon.
16:11:42 <ddarius> > '\0xFFFD'
16:11:42 <lambdabot>  Improperly terminated character constant at "'\0xF..." (column 1)
16:12:00 <stepcut> dons: not this year
16:12:10 <glguy> he range D800-DFFF (2048 code points) is disallowed by Unicode
16:12:16 <glguy> > '\xd800'
16:12:18 <lambdabot>  '\55296'
16:12:30 <yitz> > '\xfffd'
16:12:32 <lambdabot>  '\65533'
16:12:41 <glguy> sjanssen: which extension did I just use?
16:12:50 <MyCatVerbs> sampointon: or, actually, not quite so much. It's useful, in a way. It's a quick shibboleth to identify the people who aren't actually capable of keeping up intellectually with the discussion at hand.
16:13:49 <MyCatVerbs> sampointon: I don't think that's just confirmation bias on my part, though, because I can't remember having ever seen any counterexamples. Admittedly my memory is terrible, though.
16:13:51 <sjanssen> glguy: hmm, I was fairly certain GHC disallowed those
16:14:13 <mauke> preflex: zenc â¬
16:14:13 <preflex>  z0e2Uz82Uz0acU
16:14:14 <sampointon> MyCatVerbs: I'm afraid I've been so desensitised to that kind of thing it just flies under the radar
16:14:40 <sbahra> mauke, what did that do?
16:14:45 <glguy> '\xffff'
16:14:49 <glguy> > '\xffff'
16:14:51 <lambdabot>  '\65535'
16:15:01 <sbahra> preflex: zenc a
16:15:01 <preflex>  a
16:15:33 <ziman> preflex, zdec z0e2Uz82Uz0acU
16:15:33 <preflex>  â¬
16:15:34 <sbahra> preflex: zenc
16:15:41 <sbahra> preflex: zenc Ø¹
16:15:42 <preflex>  z0d8Uz0b9U
16:16:05 <MyCatVerbs> sampointon: that one in particular should, IMO, be an excuse for summary condemnation to death by fire. 100% of the time. ;)
16:17:20 <yitz> anyone know if HLP will include a bug tracker? that would be awesome
16:17:25 <dons> yitz: hmm?
16:17:27 <gwern> > let foo = " â¬" in foo
16:17:29 <lambdabot>  " \8364"
16:17:35 <dons> oh, a bug tracker for the HLP?
16:17:36 <dons> yes.
16:17:42 <dons> not *in* the HLP.
16:17:43 <yitz> yeah.
16:17:44 <gwern> hm
16:17:45 <sjanssen> glguy: I wonder why that is the case -- they do correctly recognize characters that are too large
16:17:54 <dons> yes, generally, we need automation
16:17:58 <dons> which means bug tracking
16:18:14 <mauke> preflex: zenc â¬
16:18:14 <preflex>  z20acU
16:18:20 <mauke> w i n
16:18:20 <yitz> one problem of a fractured package space is that you can't easily file bugs against packages that you need.
16:18:30 <yitz> like this utf8-string thing
16:18:41 <Myoma> mauke++
16:18:49 <sjanssen> Cabal/hackage should support a bug-tracker-url in the package description
16:18:57 <Myoma> actually supporting unicode -- who would have thought of it
16:19:20 <dcoutts_> sjanssen: yep
16:19:35 <sjanssen> dcoutts_: is there a bug for that, or shall I make one?
16:19:52 <dcoutts_> sjanssen: http://hackage.haskell.org/trac/hackage/ticket/323
16:19:58 <lambdabot> Title: #323 (Add url field for package bug reports) - Hackage - Trac
16:20:21 <mauke> preflex: zenc ß
16:20:21 <preflex>  z0dfU
16:20:28 <mauke> preflex: zenc Ã
16:20:28 <preflex>  z0dfU
16:20:43 <mauke> heh. I can't see any difference.
16:20:47 <sjanssen> dcoutts_: what exactly does it take to add a field to the package description?
16:21:06 <dcoutts_> sjanssen: just changing the type and the parser
16:21:21 <dcoutts_> sjanssen: it's not hard, it's just a question of agreeing and deciding to do it
16:21:44 <dcoutts_> sjanssen: though we should also verify that its valid url syntax I think
16:22:08 <sjanssen> dcoutts_: that seems like it should happen on the hackage side, IMO
16:22:48 <dcoutts_> sjanssen: you want both because people like to check before uploading
16:23:02 <dcoutts_> sjanssen: cabal check does all the same checks that the server side does (well, mostly)
16:23:28 <dcoutts_> sjanssen: it's especially important for warnings since people can miss them on upload
16:24:19 <sjanssen> dcoutts_: I worry about being excessively restrictive.  For example, you forgot https: in the bug report
16:24:38 <dcoutts_> sjanssen: well I didn't say it, but I thought it :-)
16:25:16 <yitz> > '\x20ac'
16:25:18 <lambdabot>  '\8364'
16:25:39 <dcoutts_> sjanssen: the only annoying thing is that the url code is in network and Cabal cannot depend on that
16:25:43 <gwern> @hoogle encodeFile
16:25:43 <lambdabot> No results found
16:26:17 <heatsink> @faq can you program anything specifically for the unix/linux environment in haskell?
16:26:17 <lambdabot> The answer is: Yes! Haskell can do that.
16:26:26 <yitz> preflex: zdec zfffdU
16:26:26 <preflex>  ï¿½
16:28:01 <gwern> dammit
16:28:09 <gwern> this is one reason why I hate botpp in lambdabot so much
16:28:17 <gwern> what are you supposed to do with a compile error like: /tmp/ghc17981_0/ghc17981_65.hspp:207:39: parse error on input `)'
16:28:33 <mauke> swear
16:28:54 <sjanssen> gwern: guess the line numbers
16:28:57 <Philonous> @type (.)
16:28:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:29:04 <ziman> wow :)
16:29:07 <sjanssen> gwern: botpp adds something like 10 extra lines
16:29:11 <stepcut> gwern: run hspp by hand ?
16:29:19 <gwern> sjanssen: yeah, but I can't know... yeah, what you said
16:30:01 <Saizan> add {-# SOURCE pragmas to the output of botpp?
16:30:02 <Myoma> > (+1) . [1,2,3]
16:30:04 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
16:30:05 <Myoma> hmf
16:30:12 <Myoma> Cale, why not add it back in ? it is fun
16:30:25 <gwern> Saizan: what do those do?
16:30:37 <gwern> Myoma: because it's a bad idea
16:30:50 <yitz> hey, you mean the #haskell twilight zone has ended?
16:30:51 <Myoma> bad
16:30:55 <Cale> Myoma: mueval has some slight brokenness because of some bugs in the GHC API wrt qualified imports.
16:30:56 <Myoma>  ?
16:31:13 <Jedai> gwern: But I would like an interpreter that got those definitions back
16:31:15 <Cale> Otherwise, I would have the generalised definitions still :)
16:31:23 <Myoma> I hope it will be fixed
16:31:25 <Myoma> > unsafe
16:31:25 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:31:28 <Myoma> is much more stupid though
16:32:05 <sjanssen> > "unsafe" -- is worse
16:32:05 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:32:09 <bjrn> Why do Network.Socket recv return a String and not, say, ByteString?
16:32:17 <gwern> sjanssen: that's fixed in darcs
16:32:22 <sjanssen> gwern: cool
16:32:22 <mauke> bjrn: it's older than ByteString
16:32:24 <ddarius> bjrn: Because ByteString didn't exist when it was written.
16:32:26 <gwern> sjanssen: if that seriously bugs you complain to Cale
16:32:29 <Saizan> gwern: it was LINE, e.g. {-# LINE 1 "/home/saizan/cairo-0.9.13-standalone/Graphics/Rendering/Cairo.chs" #-} in Cairo.hs makes ghc report line numbers that match the source in Cairo.chs
16:32:31 <Myoma> gwern: is my one fixed in darcs?
16:32:39 <bjrn> mauke, ddarius, Ah, that makes sense. Cheers. :)
16:32:51 * gwern dunno why that bothers you  - I mean, how often did you ever write unsafe in lambdabot expressions?
16:32:52 <mauke> bjrn: get network-bytestring from hackage :-)
16:32:53 <halberd> do any programming languages allow user-definable type conversions, so you could specify, say, "if you want a value of FooType and you get a value of String, implicitly call StringToFooType to convert it"
16:32:57 <gwern> Myoma: which one?
16:32:59 <sjanssen> gwern: why Cale?
16:33:00 <Cale> gwern: So you put a new version on hackage?
16:33:01 <Myoma> > unsafe
16:33:01 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:33:06 <mauke> halberd: yes, C++
16:33:11 <Tchakkazulu> > "unsafe"
16:33:11 <Myoma> that should say unsafe is out of scope
16:33:11 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:33:15 <Tchakkazulu> > "uns" ++ "afe"
16:33:15 <ddarius> halberd: Plenty.  C# as well
16:33:17 <lambdabot>  "unsafe"
16:33:19 <Myoma> > foo
16:33:20 <lambdabot> Terminated
16:33:21 <bjrn> mauke: Thanks, will check it out
16:33:25 <gwern> Cale: no. I will only do so when haskell-src-exts darcs goes on hackage
16:33:25 <sjanssen> gwern: oh, bug Cale to upgrade.  I get it
16:33:27 <Myoma> or it should say Terminated .. whatever
16:33:31 <halberd> ok
16:33:37 <Myoma> gwern ?
16:33:44 * gwern prefers my hackage packages to be buildable from hackage
16:33:54 <sjanssen> gwern++ mueval develops quickly
16:34:02 <mauke> Moose sort of lets you do that, but that's not really part of the language
16:34:25 <gwern> sjanssen: right
16:34:48 <gwern> sjanssen: blame mmorrow for that fix. I wasn't going to do it
16:35:00 <Myoma> gwern-- # ignoring me
16:35:07 <gwern> (mostly because I have no idea where to start in haskell-src-exts...)
16:35:35 <gwern> Myoma: if you were paying attention, you'd've noticated that was sjanssen's question and I was answering it and thus also you
16:35:46 <Myoma> gwern, No I am asking something else
16:35:48 <Myoma> > unsafe
16:35:48 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:35:49 <Myoma> and
16:35:52 <Myoma> > "unsafe"
16:35:53 <lambdabot>  mueval: Unsafe functions to use mentioned.
16:35:55 <Myoma> are diffreent
16:36:06 <mauke> how are they different?
16:36:11 <ddarius> Myoma: The cause is the same.
16:36:23 <gwern> Myoma: yes, I've covered the second, and the first doesn't bother me as it is fixed as well
16:36:39 <Philonous> > "un"++"safe"
16:36:41 <lambdabot>  "unsafe"
16:36:48 <gwern> although the output isn't quite right, as it merely returns the empty string as an error
16:37:03 <gwern> so it's unclear to the user that 'mueval -e unsafe' is bad and not merely quiet
16:37:06 <Myoma> gwern++ # ok great
16:40:27 <gwern> eh. bugger lambdabot for a lark. I'm going to take a break and do some archery
16:40:30 * gwern &
16:40:40 <Philonous> @type ap
16:40:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:40:55 <MyCatVerbs> gwern: bg
16:41:11 <Philonous> @pl \a b c -> a c (b c)
16:41:12 <lambdabot> ap
16:41:27 <Philonous> @type \a b c -> a c (b c)
16:41:29 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:42:13 <Philonous> Is there a reason the type checker sometimes uses a b c etc. and sometimes tn ?
16:42:42 <Myoma> @type \t t1 t2 -> t t2 (t1 t2)
16:42:44 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:43:17 <MyCatVerbs> Philonous: it's just a sack of slightly kludgy heuristics for making up type names that might just hopefully sound nice.
16:44:18 <MyCatVerbs> Philonous: as far as the compiler is concerned, the names don't mean any damn thing at all, up to alpha-equivalence. But the devs make it try its best to provide something readable, because they're nice people like that.
16:44:23 <mauke> :t M.insert
16:44:25 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
16:44:27 <Philonous> So there's nothing special about it? Ok. Just wondered because some paper explicitly mentioned it (without giving any explanations)
16:45:13 <MyCatVerbs> Philonous: huh. What paper? On what?
16:45:52 <Philonous> MyCatVerbs: Sure, just thought that they maybe give some information to the programmer
16:46:02 <Philonous> Unfortunately I don't remember
16:48:26 <MyCatVerbs> Philonous: AFAIK they're derived where possible from types and names that're in the source code.
16:48:47 <MyCatVerbs> Philonous: where that isn't possible, GHC just assigns the first thing it comes across the name "t".
16:49:07 <MyCatVerbs> Philonous: aside from that, it just adds numbers to the ends of things where necessary to ensure uniqueness.
16:49:43 <Philonous> Yes ok. So there's nothing interesting going on there. Thanks :)
16:49:45 <stepcut> dons: I sent the patch, are you likely to upload a new version hackage in the next hour ?
16:49:50 <MyCatVerbs> Like I think it picks up 'm' for monads because there's defined class Monad m where...
16:50:42 <dons> stepcut: not the next hour, no.
16:50:43 <MyCatVerbs> Philonous: well, it doesn't strictly *matter* in theory, I guess. But it is nice, and it does sometimes make it a little easier to track where things are coming and going, if you happen to hit one of the edge cases that causes that to become apparent.
16:50:48 <dons> i'll apply them , and see what works.
16:51:20 <jrockpunk1> hey can anyone tell me how to compile my haskell without running it through ghc? like how would I type a program into notepad, then compile it all?
16:51:54 <stepcut> dons: no problem
16:52:10 <stepcut> dons: I have only tested with one application under ghc 6.8.2
16:52:32 <MyCatVerbs> jrockpunk1: argh. Please don't use notepad. :(
16:52:36 <Saizan> jrockpunk1: ghc --make filename.hs
16:52:41 <jrockpunk1> MyCatVerbs
16:52:51 <jrockpunk1> i was just using that as an example
16:52:56 <nybyn> at least try notepad2 or notepad++ :)
16:53:07 <MyCatVerbs> jrockpunk1: use Notepad++ or... something. I don't know, there are many many text editors for Windows that don't suck as much.
16:53:22 <aconbere> like vim ;-)
16:53:24 <jrockpunk1> Saizan
16:53:26 <jrockpunk1> in windows
16:53:41 <MyCatVerbs> jrockpunk1: anyway. ghc --make Foo.hs, or runhaskell Foo.hs, or go download and install Hugs. :P
16:54:10 <jrockpunk1> where do i type that? cmd?
16:54:28 <aFlag> jrockpunk1: you could
16:54:42 <Saizan> jrockpunk1: yes
16:54:46 <jrockpunk1> so i make the program, save it as what a txt file? then type that in cmd?
16:54:52 <aFlag> but you're better off getting a better editor
16:55:00 <aFlag> save it as a .hs file
16:55:11 <racialHammer> alright, go through tor and lets start spamming
16:55:18 <jrockpunk1> thanks
16:55:20 --- mode: ChanServ set +o Heffalump
16:55:22 --- mode: ChanServ set +o Saizan
16:55:22 <racialHammer> oops, didn't mean to send that there
16:55:28 --- mode: Saizan set +b *!*i=guest@gateway/tor/x-3860e5c8425b030c
16:55:28 --- kick: racialHammer was kicked by Saizan (Saizan)
16:55:41 <Heffalump> I was going to wait a bit after that "oops" :-)
16:56:04 <Nafai> Heh
16:56:06 <Saizan> it's the third time he comes here..
16:56:06 <dons> no. they'ven been at it all day
16:56:06 * MyCatVerbs points and laughs at Heffalump for losing the race condition. ;)
16:56:23 <Heffalump> ah, I didn't see the previous times
16:56:28 --- mode: ChanServ set +o glguy
16:56:31 <dons> we'll leave the tor block on for longer now.
16:56:39 <Heffalump> I was quicker with the op because I had the line ready-typed after I saw that nick join.
16:56:44 <dons> :)
16:56:46 <dons> good
16:56:57 <MyCatVerbs> dons: it bewilders me that tor nodes aren't k-lined from the whole network by default.
16:57:06 <dons> glguy put a section on the wiki about managing tor abuse, http://haskell.org/haskellwiki/IRC_channel/Management
16:57:11 <lambdabot> Title: IRC channel/Management - HaskellWiki
16:57:21 <Myoma> why does somebody use tor for IRC?
16:57:22 --- mode: Saizan set -o Saizan
16:57:24 --- mode: ChanServ set +o dons
16:57:30 --- mode: dons set +b *!*@gateway/tor/*!#haskell-ops
16:57:41 --- mode: dons set -b *!*i=guest@gateway/tor/x-3860e5c8425b030c
16:57:46 <Myoma> (other than nefarious purpoises)
16:57:50 --- mode: ChanServ set -o dons
16:57:51 <Heffalump> what's the #haskell-ops bit?
16:58:06 <dons> redirects them there, in case we see valid tor users caught.
16:58:09 --- mode: glguy set -o glguy
16:58:40 <jrockpunk1> ok ive done what you said, but when it compiles it says
16:58:46 <jrockpunk1> map.hs:1:16: parse error (possibly incorrect indentation)
16:59:16 <glguy> Myoma: some firewalls block IRC
16:59:19 <MyCatVerbs> @where hpaste
16:59:19 <lambdabot> http://hpaste.org/
16:59:26 <mauke> jrockpunk1: that means there is an error in line 1, column 16
16:59:32 <jrockpunk1> lol ok
16:59:33 <mauke> well, column 17
16:59:46 <bjrn> I'd be very careful banning Tor users by default. Lots of mass surveillence etc being implemented in various countries at the moment, I think more people will use it just for the encryption
17:00:04 <Heffalump> I don't like the idea either
17:00:07 <Myoma> so tor encrypts ?
17:00:08 <dons> yeah, hence the redirect
17:00:08 <Myoma> why not use ssh ?
17:00:09 <Heffalump> but it's hard to know what to do given the potential for abuse
17:00:12 <Myoma> doesn't freenode have an ssh
17:00:14 <jrockpunk1> fst("hello",'c') thats all i wrote
17:00:14 <MyCatVerbs> bjrn: I'd be more sympathetic to that position if Tor was known to work.
17:00:19 <jrockpunk1> to test
17:00:45 <Heffalump> jrockpunk1: you left out all the standard bits of a Haskell program
17:00:48 <Heffalump> that's just an expression
17:00:51 <jrockpunk1> shit
17:00:53 <Philonous> Myoma: Even with ssh it's possible to determine what they are sending once you are in the channel
17:00:54 <dons> deop Heffalump ?
17:00:55 <MyCatVerbs> jrockpunk1: Right. The compiler expects to see definitions, rather than just expressions.
17:00:58 <Heffalump> try main = print $ fst ("hello", 'c')
17:01:00 <jrockpunk1> ok sorry
17:01:03 --- mode: Heffalump set -o heatsink
17:01:06 --- mode: Heffalump set -o Heffalump
17:01:09 <jrockpunk1> ive only done it in ghc so thats why
17:01:09 <MyCatVerbs> jrockpunk1: type "ghci" and then type that in again. :)
17:01:10 * Heffalump misses with tab-complete :-)
17:01:20 <mauke> jrockpunk1: you mean in ghci?
17:01:22 <jrockpunk1> nah i meant without using ghci
17:01:31 <jrockpunk1> doesnt matter
17:01:33 <jrockpunk1> i know now
17:01:35 <MyCatVerbs> Heffalump: y'know in Westerns where they shoot the wrong guy by mistake?
17:01:36 <jrockpunk1> thnaks
17:01:42 <Heffalump> I should make a macro for opping myself.
17:01:43 <Myoma> Philonous, lol
17:01:45 <heatsink> Dammit, I missed my opportunity!
17:01:46 <MyCatVerbs> jrockpunk1: good luck. ^_^
17:01:59 <jrockpunk1> thanks lol
17:02:09 <jrockpunk1> haskells a lot different from C!
17:05:05 <aFlag> tor is not good only for encryption, if you're afraid you may be under surveillence
17:05:56 <aFlag> actually, you'd still need an extra layer of encryption if you don't want people looking through your text.
17:06:42 <pgavin> :i System.Time.Month
17:07:00 <pgavin> @help
17:07:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:07:03 <pgavin> @list
17:07:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:07:14 <pgavin> @hoogle Month
17:07:15 <lambdabot> System.Time data Month
17:07:15 <lambdabot> System.Locale months :: TimeLocale -> [(String, String)]
17:07:15 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
17:07:52 <pgavin> is there a reason the new time package doesn't have the Month enumeration?
17:09:19 <MyCatVerbs> pgavin: I don't believe in February.
17:09:57 <pgavin> heh
17:09:59 <mauke> oh god, I think I'm an idiot
17:10:14 <pgavin> MyCatVerbs: so it's a localization issue then
17:10:18 <mauke> I think I've found one of the major bugs in preflex
17:10:44 <MyCatVerbs> pgavin: yeah, _very_ local. Disputed territory extends from my left ear to my right. :)
17:12:36 <pgavin> lol
17:13:17 <MyCatVerbs> pgavin: a wide, barren expanse. Not really worth paying much attention to, honestly.
17:14:14 <pgavin> so I guess you don't believe in Valentine's Day either
17:14:18 <pgavin> :)
17:15:24 <MyCatVerbs> Meh. It's that whole 28-days 29-days thing.
17:16:51 <mauke> preflex++
17:17:20 <MyCatVerbs> It's exceedingly discriminatory against people unlucky enough to born during one specific day out of every 1461. The poor souls end up having only a quarter as many birthdays as the rest of us. :/
17:18:08 <ryant5000> so, has anyone attempted to make a DMBS-like datastructure in haskell?
17:18:24 <MyCatVerbs> DMBS?
17:18:35 <ryant5000> i.e.: something with relational tables
17:18:45 <MyCatVerbs> You mean an RDBMS. :)
17:18:47 <ryant5000> you know, like SQL databases, etc.
17:18:47 <ryant5000> yeah
17:19:03 <ryant5000> though i'm not too strongly tied to the R :P
17:19:08 <ryant5000> any similar model will do
17:19:09 <MyCatVerbs> Good question. I don't think so.
17:19:34 <ryant5000> i'm just interested in what could be done with a strong, generic type system like haskell's combined with the power of database systems
17:19:49 <heatsink> ryant5000, LINQ?
17:19:57 <mauke> @where takusen
17:19:57 <lambdabot> I know nothing about takusen.
17:20:12 <ryant5000> heatsink: LINQ is just a driver for external DBMSes, i thought
17:20:25 <Korollary> ryant5000: There's MonetDB, which I think is in Haskell
17:20:38 <MyCatVerbs> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Takusen
17:20:44 <lambdabot> Title: HackageDB: Takusen-0.8.3, http://tinyurl.com/4j7367
17:20:51 <osfameron> linq works with native data structures too
17:21:49 <MyCatVerbs> ryant5000: Haskell isn't really the ideal sort of language for writing relational databases in. No direct control over things like memory mapping, fairly chunky datastructures, a few other things here and there.
17:22:05 <ryant5000> MyCatVerbs: i'm not so interested in implementation as in typing
17:22:33 <Myoma> ?go why dependent types matter
17:22:36 <ryant5000> basically, i want to figure out how one would type database structures in a way similar to haskell's types
17:22:39 <lambdabot> http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf
17:22:39 <lambdabot> Title: Why Dependent Types Matter
17:22:40 <MyCatVerbs> ryant5000: ah, yes. In which case, look at Takusen. :)
17:22:47 <Myoma> that's not it
17:22:49 <ryant5000> cool, thanks
17:23:02 <ryant5000> i've read why dependent types matter - and it was preaching to the choir :P
17:23:06 <Myoma> ?go power of pi
17:23:09 <lambdabot> http://channel9.msdn.com/shows/Inside+Out/OSIsoft-Real-Time-Monitoring-and-Analytics-The-Power-of-PI-The-Demo/
17:23:09 <lambdabot> Title: OSIsoft: Real-Time Monitoring and Analytics - The Power of PI, The Demo | Inside ...
17:23:23 <Myoma> ryant500: well it's called power of pi
17:23:36 <Myoma> ryant5000: I don't know where it is, but it is very interested
17:23:38 <Myoma> interesting*
17:23:43 <MyCatVerbs> http://www.icfpconference.org/icfp2008/accepted/35.html ?
17:23:45 <lambdabot> Title: ICFP 2008 - The Power of Pi
17:25:04 <MyCatVerbs> ryant5000: I mean Haskell certainly isn't a language I'd implement an RDBMS in, but it is possible to build interesting interfaces to database systems (backed by database daemons written typically in C).
17:25:10 <ddarius> ryant5000: Have you looked at HAppS-IxSet?
17:25:21 <sclv> ryant5000: If you're up for some complicated type-level db stuff you may want to look at the coddfish paper as well
17:25:24 <binarybandit> > "c" `isPrefixOf` "casasd"
17:25:26 <lambdabot>  True
17:25:43 <ryant5000> ddarius: yeah, i looked at IxSet a while ago, and it was similar to what i was thinking of
17:25:46 <sclv> (which is based on hlist)
17:25:46 <ryant5000> i think i'll take another look
17:25:56 <MyCatVerbs> ryant5000: the impression I get is that pure Haskell solutions tend more to things along the lines of navigational databases (pointer graphs, in other words) than to E. Codd's tuple relation stuff.
17:26:23 <Jedai> "ca" `stripPrefix` "casa"
17:26:24 <ddarius> MyCatVerbs: "Network Database"
17:26:31 <Jedai> > "ca" `stripPrefix` "casa"
17:26:33 <lambdabot>  Just "sa"
17:26:54 <sclv> haskell's type system actually is somewhat painful to use at the moment with interesting operations over heterogeneous tuples -- hence, hlist.
17:27:15 <MyCatVerbs> ddarius: hrmn? I've seen "navigational database" used for graphs before, but haven't heard "network database", as far as I can remember.
17:27:24 <ddarius> MyCatVerbs: And in general, the vast majority of languages essentially represent their values as an "object" graph, so that is the natural structure.
17:27:24 <ryant5000> yeah, i would pretty much scrap all the interesting parts of haskell's type system if i were writing a language
17:27:33 <ryant5000> don't get me wrong - i'd build them back up
17:27:42 <ryant5000> but they would look very different
17:27:51 <sclv> but a good solution to the lightweight extensible record question can solve it as well -- there are various libraries for that, as well as the records in haskellDB which is also an interesting approach.
17:28:10 <ddarius> MyCatVerbs: I've heard of "network databases," I've never heard of "navigational database"
17:28:13 <sclv> it "compiles" down to sql, but you could see it as an interface to native structures as well.
17:28:21 <MyCatVerbs> ddarius: perhaps I have it completely backwards, then.
17:28:27 <sclv> since its actually closer to the relational calculus that sql is.
17:28:38 <MyCatVerbs> ddarius: anyway, syntax aside... ;)
17:28:38 <ddarius> http://en.wikipedia.org/wiki/Network_model
17:28:40 <lambdabot> Title: Network model - Wikipedia, the free encyclopedia
17:28:43 <Myoma> ryant5000: I hope you do! It would be cool to see different approaches
17:28:55 <ryant5000> Myoma: well, when someone hands me enough money not to work for a while, i'll do it :P
17:29:06 <Myoma> ryant5000: You need no money to do this
17:29:17 <ryant5000> Myoma: i need time
17:29:22 <ryant5000> and helpers would be useful as well
17:29:53 <ryant5000> i've been spending a lot of time recently thinking about how to make a new language into a successful business enterprise
17:30:03 <ryant5000> it's a super-difficult problem, unless you're microsoft
17:30:19 <ryant5000> i used to think it was impossible, but some people have convinced me otherwise
17:30:23 <Pseudonym> Even if you're Microsoft, it's super-difficult.  I don't think that Microsoft has ever done it.
17:30:27 <ryant5000> C#
17:30:34 <Myoma> Mondrian
17:30:37 <Myoma> :p
17:30:39 <ryant5000> lol
17:30:42 <Pseudonym> .NET is the business enterprise.
17:30:46 <Heffalump> define "successful business enterprise"?
17:30:50 <Pseudonym> And don't say VBA either.
17:30:56 <Pseudonym> Office is the business enterprise.
17:31:06 <Heffalump> they've made F#, though it's hard to see that they'll make a direct profit from it
17:31:06 <MyCatVerbs> ddarius: ah. I picked it up off the C2 wiki, where they correctly point out that the more common term is Network Database. Yoink: http://c2.com/cgi/wiki?NavigationalDatabase
17:31:08 <lambdabot> Title: Navigational Database
17:31:15 <ryant5000> Pseudonym: ok ok, true, but "integral part of a business enterprise" is good enough for me :P
17:31:24 <ryant5000> as long as it contributes to money-making to the extent that it can be funded
17:31:34 <Pseudonym> Java and Delphi are the two examples that come to mind.
17:31:36 <MyCatVerbs> Heffalump: anything that keeps developers within their platform is good news for them.
17:31:41 <Pseudonym> If you don't go back too far in history.
17:31:47 <Heffalump> MyCatVerbs: right, hence "direct profit"
17:31:53 <ryant5000> yeah
17:31:54 <Myoma> hmf don't mix programming languages with money
17:32:09 <ryant5000> Myoma: everything's mixed with money at some level
17:32:15 <Myoma> not to me
17:32:20 <Myoma> I don't work that way
17:32:25 <mauke> yeah, just look at all the $ in Perl
17:32:42 <MyCatVerbs> Heffalump: indirect profit is good enough for people willing to think long term, provided they're not in the midst of a cashflow crisis.
17:32:44 <ryant5000> mauke: lol
17:32:48 <Heffalump> MyCatVerbs: sure.
17:33:10 <MyCatVerbs> Heffalump: I think maybe MS are. Either that or maybe they're just very, very lucky. ;P
17:33:27 <ddarius> Myoma just slowly starves.
17:38:51 <haskellian> anyone here that works with Haskell professionally?
17:39:09 * Heffalump
17:40:18 <sclv> bunches -- why?
17:40:39 <dino-> haskellian: I am in recent weeks, yeah.
17:40:58 <dons> haskellian: yeah.
17:41:06 <dons> dino-: cool, where?
17:41:18 <dino-> dons: AT&T network abuse response in NC.
17:41:36 <dons> awesome!
17:42:00 <dons> you get to add details to the "haskell in industry" page if you like http://haskell.org/haskellwiki/Haskell_in_industry
17:42:02 <lambdabot> Title: Haskell in industry - HaskellWiki
17:42:14 <dino-> dons: I've been incredibly busy trying to make a deadline after the rest of the team quit. Unable to hire anyone else. And I basically took the project over.
17:42:23 <dons> wow.
17:42:33 <dons> how's it working out?
17:42:39 <dino-> Got right on the project implementing all new stuff in Haskell. Replacing things that don't work right.
17:42:43 <bjrn> So why did the rest of the team quit?
17:42:43 <dino-> It's working out very very well.
17:42:50 <dons> yay!
17:42:57 <sjanssen> bjrn: probably because they didn't want to write Haskell
17:42:59 * sjanssen ducks
17:43:00 <dons> that's a great disruptive moment to switch.
17:43:07 <dons> sjanssen: i guess the move to haskell happened after?
17:43:14 <dino-> bjrn: It's not a very good job really. But a trememdous opportunity, I thought.
17:43:37 <ruddel> dino-, whats the project?
17:43:47 <dino-> dons: I will do that soon. Haskell_in_industry
17:43:53 <sclv> so yr. working with haskell network libs mainly then?
17:43:54 <bjrn> Well, big name, will look good on the cv. :)
17:44:03 <sjanssen> dons: at least that spins better -- Haskell is the only way a mere mortal could accomplish this alone!
17:44:03 <dons> dino-: wonderful!
17:44:09 <Heffalump> I look forward to jdh30 emailing your boss to catch you out.
17:44:09 <dons> sjanssen: 'zactly.
17:44:09 <dino-> ruddel: We get complaint emails about network abuse. Like, an awful lot of emails.
17:44:11 <sclv> running stats, or doing realtime calcs?
17:44:16 <dons> make the impossible tractable.
17:44:29 <dino-> We do work to automate dealing with this data, parsing it from emails, storing it in SQL db, generating emails for customers and other parties.
17:44:35 <rwanderley> hi, first of all, thanks for recommending me Huttons book, just finished it, great reading! :-)
17:44:40 <sclv> ah, cool.
17:44:56 <ruddel> rwanderley, nice, did you find it at your library?
17:45:17 <dons> rwanderley: cool
17:45:18 <sclv> hdbc?
17:45:23 <rwanderley> ruddel: no, found it for free at pdfchm.com, hope it is legal.
17:45:35 <ruddel> hehe
17:45:44 <ruddel> i prefer books in dead-tree format
17:45:49 <ruddel> its an expensive habit
17:46:09 <rwanderley> ruddel: yeah, but it takes usually around 2 months to arive here
17:46:17 <dcoutts_> top level variable are not true!
17:46:19 <ruddel> rwanderley, where are you from?
17:46:24 * dcoutts_ crawls back under his rock
17:46:25 <rwanderley> brazil
17:46:30 <sclv> dino-: any libs you've found especially useful, or any libs that you wish you had but didn't?
17:47:02 <ddarius> dcoutts: Yeah, that debate is perhaps starting again.
17:47:26 <rwanderley> so, I'm learning haskell to use it at my computer graphics course, am searching for a image manipulation library, do you guys have any to recommend?
17:47:28 <dcoutts_> ddarius: Ashley just brought it up on the mailing lists
17:47:30 <ddarius> How 'bout a counterpost?  Capabilities Now!
17:47:49 <sjanssen> dcoutts_: correct me if I'm wrong, but this isn't the first (or second) time?
17:47:51 <rwanderley> it's for opening images in order to apply filter to them, and other pixel operations...
17:47:54 <Myoma> byorgey wrote a really nice image thing for haskell
17:48:00 <dino-> sclv: So far I'm using hslogger, hsql-mysql, http in addition to other stock things you'd expect (filepath, network, regex, yada)
17:48:02 <Myoma> oh I don't know if it does images though .
17:48:05 <dcoutts_> sjanssen: it's indeed not the first or second
17:48:20 <dino-> It was a great relief to be able to hook up to MySQL. It's not negotiable to not use it.
17:48:29 <sjanssen> from Ashley specifically, IIRC
17:48:51 <dcoutts_> ddarius: I replied making the point that there are many scopes you want and package-name/version only corresponds to some of them, and not the ones people often use as the motivating examples
17:48:55 <ryant5000> so, what does anyone think about the idea of "hygienic language extensions"
17:48:56 <dino-> I haven't yet had a problem with a lib that I can't use or doesn't exist for this. But there is quite a bit more to do.
17:48:57 <rwanderley> I was thinking something as Perl's PIL.
17:48:57 <FunctorSalad_> why is String -> String showable but not general function types?
17:49:03 <ryant5000> hygienic as in scheme macros
17:49:09 <FunctorSalad_> > (++ "a")
17:49:11 <lambdabot>      Overlapping instances for Show ([Char] -> [Char])
17:49:11 <lambdabot>       arising from a u...
17:49:11 <ryant5000> language extensions as in -fglasgow-exts
17:49:25 <sclv> dino: have you seen crypt.to's hsemail package for parsers?
17:49:32 <FunctorSalad_> (hmm, lambdabot probably has more Show instances)
17:49:36 <Heffalump> also what order do the <- s come in?
17:49:42 <dcoutts_> sjanssen: oh right
17:49:57 <dino-> sclv: I have not, but it sounds like something I need.
17:49:57 <Heffalump> dcoutts_: surely scoping is determined by normal symbol hiding rules, though?
17:50:09 <dcoutts_> Heffalump: then you need a special monad for things that can be safely done in any order
17:50:27 <sclv> I've been a bit frustrated by real nice sendmail type functionality in haskell libs for attachments, etc, although there's something buried in WASH that I'd like to see split out. On the other hand, for 99% of the purposes just shelling out to plain old sendmail is fine.
17:50:38 <dcoutts_> Heffalump: sure but the language scopeing rules are not the ones you're looking for in many of the examples where people want 'global' mutable vars
17:50:42 <dino-> I've been filling in things that haven't been done by the other team members and gradually replacing things that are less than idea. So the mail parsing that's in place is still Perl for now. This will be leaving if I have anything to do about it.
17:50:50 <dino-> s/idea/ideal/
17:51:03 <dcoutts_> Heffalump: they're looking for some kind of uniqueness withing a certain scope
17:51:28 <Heffalump> I see, yeah
17:51:31 <dcoutts_> Heffalump: but I can make as many instances of your module as I like
17:51:40 <sclv> dino-: I know yr. probably super busy being alone on all this at the moment, but whenever haskell gets introduced into a new serious domain, I figure there's usually a few pieces of nice reusable functionality that can get spawned off into libs -- i'd love to see what you come up with.
17:51:48 <dino-> Oh, another thing that's absolutely critical I'm using is template.
17:51:57 <sclv> which one?
17:52:01 <ddarius> dino-: Then when you're gone AT&T is going to hire someone who will try to rewrite it all in Ruby.
17:52:05 <dcoutts_> Heffalump: the common example i dealing with broken C libs that use global variables and global initialisation
17:52:32 <dino-> sclv: Definitely, I'd love to product reusable libs.
17:52:42 <dcoutts_> Heffalump: and for those, it's certainly not right to use package version scoped mutable vars to remember if the lib is initialised.
17:52:48 <dino-> ddarius: This place, it would probably be Perl. Big Perl shop.
17:52:51 <ddarius> dino-: What does AT&T say about the IP rights?
17:52:57 <dcoutts_> Heffalump: eg, try those libs with :reload in ghci. Boom.
17:53:18 <dcoutts_> it's all about being clear what scope (space, time) you need/want
17:53:58 <dino-> ddarius: I think ATT should be careful about how upset they get with these things. I see all sorts of GPL things in use all around me and I'm pretty certain they aren't interested in making sure all their code is available.
17:54:08 <sclv> dcoutts_: then if not top level mvars, what do you recommend instead?
17:54:27 <Heffalump> dino-: they'd only need to make it available if they were distributing binaries
17:54:47 <dcoutts_> sclv: I don't have nice solutions, but for the example with initialising a foreign lib, you need linker scope.
17:54:54 <dino-> Heffalump: Ok, we're technically not doing that to my knowledge outside the company. But I hear talk about productizing things that other people do.
17:54:55 <Heffalump> a lot of companies are wary of using GPL even for internal stuff just in case, but generally it's actually safe enough
17:55:29 <dcoutts_> sclv: which essentially translates into the equivalent of a global linker name, the equivalent of a static C variable.
17:55:57 <sclv> dino-: which template library by the way, Text.Template?
17:56:17 <dino-> sclv: Yes, Text.Template
17:56:19 <dcoutts_> sclv: and that var must be shared between all versions of a package, and the value must persist between runs within the same process.
17:56:24 <dino-> Not the TH
17:57:54 <sclv> so you'd advise against top level mvars in all cases, or are there any exceptions?
17:58:06 <ddarius> There are some things I'm going to miss about the military when I separate.
17:58:17 <Myoma> I thought I read "type level mvars" there geez
17:58:20 <dons> i think the older i get, the less i think top level mvars are a good idea.
17:58:27 <dons> and wiser people than me think they're entirely unnec.
17:58:28 * Myoma was about to get extremely confused
17:58:31 <dcoutts_> sclv: I don't think there's a great value in elevating that particular scope to being special by giving it special syntax
17:58:31 <mauke> haha, multithreaded type inference!
17:58:45 <dons> ddarius: do you have an example?
17:58:50 <sclv> ?remember dons The older I get, the less I think top level MVars are a good idea.
17:58:50 <ddarius> dons: Exactly.  Haskell should be heading more toward a capability-like model, not away from it.
17:58:50 <lambdabot> Good to know.
17:59:02 <dcoutts_> sclv: the good motivating examples for 'top level' vars do not match the scope that the proposal would provide.
17:59:25 <ryant5000> i don't know why anyone thought top-level anything was a good idea >.>
17:59:26 <dons> ddarius: that's a good point. capabilities, threads, scope.
17:59:29 <dcoutts_> sclv: I fear it'd encourage the practise, and that we'd get people using that scope when they meant another
17:59:35 <dons> not this silly top level business with unclear scope and lifetime.
17:59:47 <ddarius> dons: The chain of command.  If I need something from someone higher than my immediate supervisor, I can just send it up the chain of command and expect action.
18:00:19 <ryant5000> i'll trade you all your top-level things (make each file an expression) for some partial evaluation and dependent types
18:00:19 <dcoutts_> package-name/version scope only seems useful for Haskell things, not FFI things and so those are exactly the cases we should be discouraging since they're not necessary.
18:00:20 <sclv> The example I was thinking of was for locking access to the rounding register of the fpu to get deterministic floating point behavior within a certain scope.
18:00:21 <ddarius> I imagine in many cases you have to escalate things yourself in commercial environments and you can less rely on your boss to do it for you.
18:00:38 <dons> ddarius: yep. my workplace is explicitly wiki-like in nature.
18:00:41 <ddarius> (I could be wrong about that)
18:00:49 <dcoutts_> the only necessary 'global' vars are those imposed by external things like broken C libs, device drivers, whatever
18:01:06 <dcoutts_> sclv: ok, so that's process scope? or rts scope?
18:01:09 <humasect> yep, dcoutts
18:01:13 <ryant5000> dcoutts_: also, anything that's fundamentally at RTS scope
18:01:30 <dcoutts_> ryant5000: I can run multiple instances of the rts in a single process remember.
18:01:34 <ac> so, could I write: data FooRecord = FooRecord { bar :: Bar, baz :: Baz, ... }; data FooRecordRef = IORef FooRecord; -- without declaring the intermmediate FooRecord type?
18:01:35 <dino-> I may actually be needing help in the next week or two with GHC on Gentoo. Our server platform this will run on is Gentoo. So far I've installed the generic binary GHC to my ~ on a staging system for integration test. But will need to assist admin people in really putting the dev env on one of these. Hopefully this bad boy will emerge ok on there. Me, not really a Gentoo person.
18:01:38 <sclv> well, its machine scope, so you want it as broad as possible.
18:01:39 <ryant5000> dcoutts_: oh, you meant process scope
18:01:48 <rwanderley> oh, found pancito, i think thats the one for me.
18:01:50 <ryant5000> dcoutts_: there are more things fundamentally at process scope as well
18:01:58 <ryant5000> dcoutts_: e.g. anything dealing with virtual memory
18:02:05 <humasect> how do we avoid toplevel 'global' var impositions from [broken] c libs ?
18:02:07 <sclv> I don't think there's a better solution than top level mvar at the moment.
18:02:09 <ryant5000> dcoutts_: your point, however, is well taken
18:02:22 <dcoutts_> sclv: you probably mean OS filesystem namespace scope (ie chroot/jail/container)
18:02:37 <dcoutts_> ryant5000: sure, there are some things at process scope
18:02:46 <dcoutts_> ryant5000: it's one of the more important scopes.
18:03:01 <dcoutts_> and note that top level var proposals do not cover it
18:03:06 <ryant5000> dcoutts_: agreed
18:03:10 <dino-> And I've had buggy problems with the generic binary GHC. But nothing show-stopping yet.
18:03:17 <sclv> well -- you only have one fpu for the whole system typically, and any other process anywhere on the systm in any jail can change it too -- the best you can hope fore is that it doesn't get changed by the process.
18:03:18 <dino-> on Gentoo
18:03:20 <ryant5000> dcoutts_: it's an important scope for a very select group of people to deal with
18:03:27 <dcoutts_> ryant5000: fortunately we've got a good handle on process scope via OS calls and our own pid
18:03:40 <ryant5000> for my summer project i've been hosting flash
18:03:43 <ac> I can't figure out the syntax. Seems like it should be possible
18:03:43 <ryant5000> and let me tell you what
18:03:45 <dcoutts_> and our virtual memory
18:03:45 <ryant5000> that is a pain
18:04:39 <dcoutts_> humasect: having a better solution for the C lib example is important but the top level var proposals do not solve it
18:04:59 <dcoutts_> humasect: you really need something like C static vars, which are linker scope
18:05:17 <dcoutts_> and preserve their values between package reloads and rts restarts
18:05:21 <dino-> dons: Oh, the lovely Mrs Dino interviewed at a local company a few months back that works with one or more of your products.
18:05:25 <ryant5000> whoever decided that windows libraries should be cached based on their file name (not path) should be shot
18:05:41 <ddarius> dino-, dons: Cool.
18:05:49 <humasect> dcoutts_: hm yes i see what you mean. it can also get worse when callbacks are involved, which most "flexible" C apis seem to maintain
18:05:50 <sclv> dcoutts: that sounds better for the fpu example too.
18:06:13 <sclv> the current proposal just gives a prettier syntax to the same unsafePerformIO hack, no? i.e. does it "solve" anything at all?
18:06:16 <dino-> Reminded me when you said something about wiki
18:06:22 <dcoutts_> sclv: right
18:07:07 <dcoutts_> sclv: fpu lock wants to be per-thread I guess, since one might hope that switching threads saves/restores fpu state
18:07:46 * Heffalump thinks implicit parameters should be more widely used
18:07:48 <sclv> ah -- per. o.s. thread though.
18:08:43 <sclv> so that would be, e.g., a threadlocal mvar.
18:09:05 <ryant5000> Heffalump: except that their scoping is horrendous
18:09:18 <ryant5000> (if i recall correctly)
18:09:20 <Heffalump> yeah, that's the bit I don't really understand
18:09:29 <Heffalump> Oleg showed that it's weird, I remember that
18:09:37 <ryant5000> they should be statically scoped just like everything else
18:09:39 * sclv remains stumped as to when they're actually better than a reader monad.
18:09:49 <Heffalump> sclv: when you don't want to use do all over the place?
18:10:15 <sclv> heh -- my monadic code hardly ever uses do. it does look like perl threw up however.
18:10:30 <Heffalump> ok, or when you don't want that :-)
18:11:28 * dons thinks implicit parameters are for crazy people who can see through scope and time
18:11:43 <Heffalump> I've never actually used them, but I keep meaning to.
18:11:52 <BONUS> i find them hardly readable
18:11:58 <dons> oh, wait till you have to work on a project with them floating around
18:12:04 <Heffalump> But they seem like the right thing for passing around configuration information or big global handles.
18:12:05 <dons> and try to work out where some variable is bound and why
18:12:13 <BONUS> *reading function body* oh look here's another parameter!
18:12:16 <dons> yeah, same as for Reader :)
18:12:26 <sclv> func pureval . acessor =<< ask
18:12:36 <dons> some smart people like them, though, that's true.
18:12:42 <Myoma> the idea of implicit parameters strikes fear into my heart
18:13:04 <sclv> or <$> ask rather
18:13:11 <dcoutts_> dons: a reasonable use case that came up earlier is fpu rounding mode.
18:13:19 <Heffalump> SPJ said several years back that we need better ways of dealing with commutative monads. For the special case of the reader monad, implicit parameters seem like they should be that.
18:13:27 <dcoutts_> Heffalump: right
18:13:33 <dcoutts_> otherwise you have to stick floating point ops into a reader monad
18:13:33 <dons> weird, http://wouter.fov120.com/aardappel/index.html
18:13:39 <lambdabot> Title: The Aardappel Page
18:13:50 <dons> "computes by concurrently reducing trees (using a form of tree-rewriting) which sit together in tree-spaces (bags) and communicate amongst eachother ("
18:14:00 <Myoma> sounds cool
18:14:45 <sclv> hmmm... yeah I suppose implicit parameters are a good fit for that, and mildly saner than a top-level mvar.
18:15:07 <Heffalump> once you start doing weird shit with scoping that scares me though
18:15:36 <sclv> "dealing with commutative monads" = we need a genuine notation for comonads that isn't some silly variant of do notation that fits a square peg into a round hole.
18:15:54 <Heffalump> do you mean comonads or commutative monads?
18:16:26 <sclv> Heffalump: well 90% of the time when you're dealing with a commutative monad, you're dealing with a comonad, no?
18:16:35 <Heffalump> I have no idea
18:16:49 <Heffalump> I've never seen any real use for comonads, so I've never bothered learning much about them.
18:17:05 <sclv> being able to scope functions over "context" (combined with a useful extensible record type for that) might be a way to represent that.
18:17:45 <Heffalump> randomness and name supply are the two obvious examples of commutative monads (where the commutativity is up to some higher-level equivalence than straight equality)
18:17:54 <sclv> both comonads
18:18:23 <Heffalump> fair enough, but does this actually help?
18:18:27 <sclv> I think the uniquesupply package on hackage explicitly notes this?
18:18:40 * Myoma prefers a monad in the case of name supply..
18:18:46 <dons> "Iâve been writing an iPhone app for Circos over the past few weeks. At Circos we use simple REST
18:18:49 <dons> APIs to hook up all our components. This way components are completely de-coupled and can be written
18:18:52 <Pseudonym> @src iterate
18:18:52 <lambdabot> iterate f x =  x : iterate f (f x)
18:18:52 <dons> in whatever language the programmer wants (so far weâve used Python, C and Haskell)."
18:18:54 <sclv> Heffalump: well, it lets us reason about them differently -- noting for example that they don't need to fulfill all the monad laws.
18:19:02 <Pseudonym> dons, does iterate use stream fusion?
18:19:35 <sclv> and instead that we need to fulfill the comonad laws.
18:19:35 <dons> yep
18:19:37 <dons> iterate :: (a -> a) -> a -> Stream a
18:19:37 <dons> iterate f x0 = Stream next (L x0)
18:19:37 <dons>   where
18:19:37 <dons>     {-# INLINE next #-}
18:19:37 * Heffalump fails to find uniquesupply on hackage
18:19:39 <dons>     next (L x) = Yield x (L (f x))
18:19:43 <Pseudonym> Right.
18:19:53 <Pseudonym> I don't want to lie in a message to beginners. :-)
18:19:57 <Heffalump> sclv: but both those examples are simple state monads
18:20:00 <ac> is there a standard way to parse command line arguments?
18:20:13 <sclv> And if we can reason about them differently, then we can maybe create better syntax for them.
18:20:15 <mauke> @hoogle getopt
18:20:15 <dons> ?hoogle GetOpt
18:20:15 <lambdabot> module System.Console.GetOpt
18:20:15 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
18:20:15 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
18:20:16 <lambdabot> module System.Console.GetOpt
18:20:16 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
18:20:17 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
18:20:21 <Heffalump> so not needing to satisfy the monad laws isn't particularly useful
18:20:25 <ac> dons: thanks
18:20:26 <sclv> Heffalump: value-supply is the name on hackage.
18:20:46 <Heffalump> thanks
18:20:51 <sclv> And not needing to satisfy the monad laws *is* useful -- because it means that we don't need to think in terms of linear threading and ordering and do notation
18:21:18 <Myoma> edwardk has one in category extras
18:21:22 <haskellian> is there a way to copy all the text so i can search it?
18:21:51 <haskellian> nevermind found it
18:21:59 <sclv> linear implicit parameters were sort of a broken way of doing this I think.
18:22:09 <Heffalump> I was about to say that :-)
18:22:30 <Heffalump> I think it's a shame they died.
18:22:42 <Pseudonym> Hmm.
18:22:48 <Pseudonym> OK. Suppose you have an iterate-to-fixpoint algorithm.
18:23:08 <Pseudonym> What is the best way to write the consumer in such a way that stream fusion just works?
18:23:20 <sclv> The point about comonads, I think, is they can formalize the intuitions behind linear implicit parameters and so make that sort of concept less broken. But we still need extensible records to really get what we want.
18:23:29 <Pseudonym> You want something like:
18:23:33 <Heffalump> How do extensible records help?
18:23:36 <Pseudonym> findFirst :: (a -> Bool) => [a] -> a
18:23:40 <Pseudonym> Uhm.
18:23:48 <Pseudonym> findFirst :: (a -> Bool) -> [a] -> a
18:24:35 <sclv> We can implicitly thread/distribute a single reader context, for example, and then require in individual type signatures that this reader have particular accessors, without fixing the rest of that context.
18:24:36 <Heffalump> findFirst f = head . filter f
18:24:42 <Heffalump> doesn't that make it just work?
18:24:48 <Pseudonym> Maybe.
18:24:50 <Pseudonym> Probably.
18:24:59 <sclv> which is easier to reason about than threading/distributing lots and lots of different implicit params.
18:25:25 <Heffalump> sclv: hmm. Not convinced you're not just moving the problem.
18:25:56 <sclv> well, sort of, except the extensible records problem is well understood.
18:26:24 <Heffalump> perhaps, but all that it solves is the problem of "I put all my context together, how do I get it apart again?"
18:26:40 <Heffalump> It doesn't seem to me to solve the tricky issues with scoping that implicit parameters have, for example.
18:30:10 <sclv> I'm not so sure they do have scoping problems?
18:31:05 <Heffalump> well, I haven't used them so I have no personal experience of it; but there's an Oleg article showing they do something weird, and a few people earlier on in this discussion seemed scared by them too.
18:31:24 <Myoma> I think they just aren't linear
18:31:31 <sclv> The only oleg article I saw showed that they don't have dynamic scope.
18:31:38 <Myoma> oh were you even talking about that
18:31:42 <sclv> which is fine -- if they had dynamic scope I'd be confused as heck.
18:32:00 * Heffalump goes to read it again
18:32:46 <Jedai> I seem to have read recently that you have two type of "implicit parameters", the regular, pretty innocent and the linear which seemingly could be used to break the type system and are being removed from GHC anyway
18:33:06 <Heffalump> it's unclear that the regular ones are "pretty innocent"
18:33:20 <Heffalump> I didn't think the linear ones broke the type system, they were just rather complicated and noone used them.
18:33:25 * FunctorSalad_ thinks this might be a good idea: formalize composeability of morphisms (without dependent types) by having a category consists of *three* sets: objects, morphisms and commutative triangles
18:33:40 <FunctorSalad_> err, three type parameters
18:33:56 <sclv> they broke referential transparency, I think, but they really didn't need to.
18:33:57 <Heffalump> let x = (let ?p = 1 in (\ () -> ?p + 1)) in let ?p = 2 in x()
18:34:00 <Heffalump> is Oleg's example
18:34:16 <Heffalump> apparently true dynamic binding would cause that code to return 3 (which it doesn't, it returns 2)
18:34:47 <Heffalump> TBH I don't even understand how it would make sense for it to return 3.
18:35:21 <FunctorSalad_> (not my idea really, got that idea from reading about simplicial sets)
18:35:23 <Heffalump> (so I'm with sclv on the "confused as heck" front :-)
18:35:35 <mauke> it makes perfect sense if you rewrite it in perl :-)
18:35:42 <Jedai> If ?p is an implicit parameter of the lambda, it should pick off the value of ?p closest to the utilisation, so 2
18:35:43 <Heffalump> sure, but that has mutable variables
18:35:47 <dolio> It depends on how you give it semantics, really.
18:36:01 <dolio> I think, at least.
18:36:26 <Heffalump> Jedai: but x = let ?p = 1 in ... could be substituted in at the call-site, making ?p = 1 the closest to the utilisation
18:36:38 <dolio> If you just rewrite x with 'let ...', it might make sense that ?p = 1.
18:36:50 <Heffalump> (if you're talking about the value of ?p rather than the value of the whole expression)
18:36:59 <mauke> our $p; my $x = do { local $p = 1; sub { $p + 1 } }; do { local $p = 2; $x->() }
18:37:03 <Heffalump> ?p does = 1 when ?p + 1 evaluates.
18:37:04 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
18:37:04 <lambdabot> v
18:37:13 <Heffalump> mauke: oh, right, but local is really really broken.
18:37:20 <dolio> But if you think x is '\() -> ?p + 1', it makes sense that ?p = 2 where things actually get evaluated.
18:37:21 <Jedai> I thought that was the motivation of the implicit parameter, that they not be substituted at the definition but at the use
18:37:28 <mauke> Heffalump: only in that it doesn't work with local variables; otherwise it's fine
18:37:38 <Heffalump> it just means "push the old value of $p then pop it when you're done"
18:38:13 <Heffalump> but x obviously isn't \() -> ?p + 1 (to my mind)
18:38:25 <Jedai> > let x = let ?p = 1 in (\() -> ?p + 1) in x ()
18:38:25 <lambdabot>  Parse error at "?p" (column 13)
18:38:28 <Heffalump> \() -> ?p + 1 has type (?p) => () -> Int
18:38:45 <Heffalump> and let ?p = ... in .. discharges the (?p) obligation making () -> Int
18:38:59 <Heffalump> (I forget what the correct syntax is for the implicit parameter type context)
18:39:02 <Jedai> ?type (\() -> ?p + 1)
18:39:04 <lambdabot> forall a. (Num a, ?p::a) => () -> a
18:39:53 <dolio> For comparison, Oleg has dynamically bound references based on delimited continuations.
18:40:04 <Jedai> Well, I agree that that's confusing... I guess they shouldn't be used like that or the rules should be easy to understand and apply
18:40:25 <Heffalump> mauke: and when you view it in terms of pushing and popping, then suddenly returning the subroutine gets outside the push/pop pair so strange things can happen
18:40:40 <haskellian> so why the h**l is foldl the standard and not foldl' ? because foldl' is strict? but at least it doesnt cause stack overflow. what is the stack limit?
18:40:58 <Heffalump> I think on reflection that the rules are easy to understand and apply. It's dynamic scoping that wouldn't be, as sclv says.
18:40:58 * ddarius doesn't like implicit parameters, linear or otherwise.
18:40:59 <Myoma> haskellian: You can alter the stack limit
18:41:20 <Heffalump> 8MB I think, and mainly to protect people from themselves.
18:41:31 * Myoma wishes there was a _heap_ limit
18:41:31 <dolio> Where the equivalent would be something like: 'do x <- dlet p 1 (return (\() -> (+1) <$> dref p)) ; dlet p 2 (x())'
18:41:43 <ddarius> Myoma: Isn't there?
18:41:47 <Heffalump> ddarius: right.
18:42:00 <sclv> anyway, to come full circle, if we had a varient of linear implicit parameters with extend :: w a -> w (w a) instead of split of type a -> (a,a), and if we used extend at each site where a parameter was *consumed* rather than each place that a computation *branched* I suspect, to my very informal intuition, that we'd be cooking, as they say, with gas.
18:42:02 <dons> Myoma: you can set a hard limit if you wish.
18:42:04 <dolio> Where p = 2 at the point where the action x() is run.
18:42:08 <Myoma> ddarius: well -- if there is I think it's the same limit as my hard disk
18:42:32 <Heffalump> sclv: surely the two strategies should be equivalent?
18:42:35 <Heffalump> (semantically)
18:42:39 <Myoma> dons, oh cool! How do you do that?
18:43:05 <ddarius> haskellian: A lot of the definitions in the Report are not the most useful ones.  The Report tended to make things as lazy as possible.
18:43:07 <sclv> Myoma: ghci +RTS --help will give you all the rts options :--)
18:43:11 <ddarius> Myoma: By reading the GHC User Guide.
18:43:12 <Heffalump> more people should read that output :-)
18:43:24 <adu> hi
18:43:33 <dolio> But I suppose in the monadic situation, the evaluation order is clearer than with implicit parameters.
18:43:48 <ddarius> It's probably been years since I last read that output.
18:44:33 <Myoma> this is brilliant
18:44:43 <sclv> The tricky bit with linear implicit parameters is listed in the warnings here: http://haskell.org/ghc/docs/6.4/html/users_guide/type-extensions.html#linear-implicit-parameters
18:44:47 <lambdabot> Title: 7.4.ï¿½Type system extensions, http://tinyurl.com/3uq27a
18:45:34 <haskellian> there is a wxhaskell folder in the lib, how do i import it?
18:45:47 <haskellian> WxHaskell, Wxhaskell, wxhaskell, neither work
18:46:10 <FunctorSalad_> Myoma: alternatively, "swapoff" (just kidding)
18:46:14 <ddarius> You don't import folders, you import modules.
18:46:22 <sclv> so I think that splitting on consumption rather than branching might help to resolve that...
18:46:29 <Myoma> last (fix (1:))
18:46:29 <Myoma> Heap exhausted;
18:46:32 <sclv> but I'd need to think it through.
18:46:41 <Myoma> no more turning my computer into a slug!
18:47:00 <ddarius> We need something that will result in a "CPU exhausted" message.
18:47:18 <Myoma> what is everybody setting GHCRTS to?
18:47:24 <adu> ddarius: reminds my of a funny joke
18:47:24 <sclv> and having a "w a" (i.e. supplier of an a) rather than an explicit a which can be split I think helps get to that goal.
18:48:21 <sclv> (another rts trick -- if you compile a binary with threaded and ask for help you get different output with the threading options, and if you compile with --debug and ask for help, you get scads of handy debug flags!)
18:48:57 <adu> ddarius: Confucius say, he who runs in front of car get tired, he who runs in back of car get exhausted...
18:49:35 <sclv> although I suppose explicitly passing a supply as they do has the same effect, so I could be up the wrong tree here.
18:49:37 <gwern> Myoma: I don't set GHCRTS. iirc, if a binary isn't compiled with threaded, GHCRTS being set to anything crashes it
18:49:50 <Myoma> oh :/
18:49:53 <Heffalump> sclv: hmm. Too sleepy to think this out properly :-)
18:49:59 <Myoma> I was hoping to have the heap limit finite by default
18:50:03 * Heffalump goes to bed, as he should have done ages ago except interesting things kept distracting him
18:53:24 <adu> can type synonyms have kinds other than "*"?
18:53:55 <mauke> yes
18:54:14 <mauke> I tried it; took me about 10 seconds
18:55:16 <adu> mauke: heh nice
18:55:56 <FunctorSalad_> is there some special documentation markup for sanity identities that must hold?
18:56:09 <adu> FunctorSalad_: quickcheck
18:56:16 <FunctorSalad_> adu: heh
18:56:37 <adu> not like that?
18:57:06 <FunctorSalad_> adu: hmm, I was thinking of basic axioms like the monad axioms, not what I'd normally think of as test cases
18:57:21 <FunctorSalad_> adu: otoh it would still be an existing language for stating them
18:57:25 <FunctorSalad_> (quickcheck)
18:57:32 <luqui> isn't that not H98?
18:57:40 <luqui> (type synonyms with other kinds)
18:58:13 <luqui> oh wait, no, it's partial application that's not H98
18:58:17 <haskellian> yes i import modules but since i didnt download separately id assume ther eis a module
18:58:25 <haskellian> so how do i import that module?
18:58:33 <luqui> type Foo a = [a];  type  Bar = Foo  -- not H98
18:58:36 <adu> haskellian: what module?
18:59:32 <adu> haskellian: are you talking about a specific module?
19:00:30 <luqui> FunctorSalad_, mathematics is a good one too
19:00:45 <adu> nice language that
19:00:51 <dancor> a sloppy one
19:01:03 <FunctorSalad_> luqui: sure, but the issue was more "making sure they are noticed" rather than "formulating it"
19:01:04 <adu> h(f + g)
19:01:13 <adu> of x
19:01:20 <haskellian> wxhaskell
19:01:20 <luqui> FunctorSalad_, noticed by the compiler?
19:01:39 <newsham> hi luqui.  i noticed 'mkEvent' went away.  what is the replacement?
19:02:00 <FunctorSalad_> luqui: no, by the user... maybe we should even have a statement recognized by the compiler that says "I checked that my instance satisfies the axioms"
19:02:18 <Myoma> RULES
19:02:20 <adu> FunctorSalad_: http://www.haskell.org/haddock/doc/html/ch03s08.html#id289905
19:02:21 <lambdabot> Title: 3.8.ï¿½Markup
19:02:33 <luqui> FunctorSalad_, that's the primary reason I am researching dependent types.
19:02:45 <luqui> FunctorSalad_, that statement would be a proof :-)
19:02:46 <adu> luqui: me too!
19:02:48 <Myoma> I think we need less reseach in dependent types
19:02:53 <Myoma> More real programs!
19:03:04 <luqui> we first need a good dependent type language.
19:03:10 <Myoma> There are many
19:03:12 <adu> luqui: do you want to read a preview of my type system?
19:03:13 * luqui disagrees
19:03:14 <Myoma> Coq is #1
19:03:18 <FunctorSalad_> luqui: sure but a formal proof is a different beast than "I gave some thought to it"
19:03:32 <FunctorSalad_> the latter would be a fair tradeoff IMO
19:03:42 <luqui> adu, sure
19:04:01 <haskellian> noone ever imported wxhaskell?
19:04:06 <Myoma> luqui: that there isn't a practical language for doing dependent typed programming in?
19:04:11 <luqui> Myoma, all dependent type languages are "too hard" (to put it informally)
19:04:17 <luqui> Myoma, yeah
19:04:39 <luqui> newsham, checking
19:04:54 <newsham> haskellian: wasnt able to install it properly :(
19:05:22 <newsham> whats wrong with agda?
19:05:29 <Myoma> luqui: I can't write real programs in dependent typed languages because I don't know how -- if there were programs around to learn from it would be much easier
19:05:32 <luqui> newsham, ah, that's playing with LegacyAdapters, oversight.  makeEvent is still there, in the "TVal" module
19:05:33 <adu> luqui: http://pastebin.com/m35df8746 its just a paragraph or so, not much...
19:05:37 <FunctorSalad_> I'm by no means an expert, but dealing with equality was nasty when I tried dependent types
19:05:55 <FunctorSalad_> since sometimes things that ought to be equal don't even have the same type
19:05:56 <luqui> adu, I prefer loose ideas rather than huge formal developments, actually. :-)
19:06:30 <newsham> is TVal.makeEvent the same thing as PrimReactive.mkEvent?
19:06:41 <Myoma> newsham: Are there any programs somebody would actually use in Agda though, as opposed to ones to just learn from (I haven't seen any)
19:06:54 <haskellian> what is agda?'
19:07:06 <newsham> myoma: I dont know, but I dont see why there couldnt be.  you can FFI to haskell for any IO you need
19:07:06 <FunctorSalad_> (and since syntactic equality is annoying for someone in a math mindset where everything is extensional)
19:07:09 <luqui> haskellian, it's a haskell-like langauge with dependent types
19:07:14 <Myoma> haskellian: It's very like haskell but it's got more expressive syntax and more expressive type system
19:07:40 <newsham> haskellian: its type system is more advanced so its suitable for proving properties about code in the type system.
19:07:45 <Myoma> haskellian: oh and a better module system
19:07:48 <haskellian> ok cool
19:07:52 * luqui hates adga syntax.  The underscore-operator thing, that is.  I love the idea, but you need to know the inner workings too deeply to use it effectively.
19:07:52 <haskellian> lol was just gonna ask
19:08:00 <luqui> i.e. I don't think it has been done well, but it could be.
19:08:17 <luqui> agda's module system is slick though
19:08:34 <heatsink> I've been wondering...  When is type erasure possible in dependently typed languages?  Is complete type erasure possible?
19:08:40 <Myoma> luqui: What do you intend to do -- Design and implement a new language before writing practical programs with dependent types?
19:08:48 <newsham> also utf8 support in identifiers is neatoh :)
19:08:49 <luqui> heatsink, first you'd have to decide what you mean by "type":
19:09:11 <luqui> Myoma, well, yes, I do, because I am more interested in that than in writing practical programs ;-)
19:09:15 <Myoma> heatsink: You can embed untyped languages
19:09:25 <Myoma> luqui: :(
19:09:39 <luqui> Myoma, I've tried to write practical programs
19:09:55 <Myoma> luqui: I used to do that .. I got offered a lot of money for it so I stopped :p
19:10:12 <luqui> and either became baffled by the technical details of the language, or used a language that was not ready (agda)
19:10:20 <Myoma> oh
19:10:29 <Myoma> you meant in agda, I thought you meant in general
19:10:39 <adu> luqui: did you read it? what do you think?
19:10:41 <luqui> coq is the one for which I was baffled
19:10:51 <adu> luqui: is that what you mean by dependent types?
19:10:57 <FunctorSalad_> there's still some way to go to save the user from having to deal with all the petty formalities
19:11:00 <FunctorSalad_> IMHO
19:11:00 <luqui> adu, going to reread it, couldn't grok it the first time
19:11:20 <luqui> Myoma, but I am primarily interested in the merger between visual programming and dependent types
19:11:21 <Myoma> Haskell (the "simple" fragment you do most programming in) has 3 type rules var/lam/app
19:11:26 <Myoma> Coq has about 50
19:11:26 <FunctorSalad_> maybe even some sort of AI to figure out the details itself
19:11:30 <Myoma> so yeah it's harder to learn :p
19:11:32 <luqui> I think dependent types will always be too complex to do with text.
19:11:41 <heatsink> What is visual programming?
19:11:42 <adu> luqui: well I've been working on this for several years, and I've just started formalizing it, so its going to take more than a paragraph to really describe it
19:12:14 <adu> heatsink: like GStreamer, QuartzComposer, Glade, InterfaceBuilder, MaxMSP, etc
19:12:40 <adu> heatsink: my favorite VP tool was the lego mindstorms programming environment :)
19:12:46 <luqui> adu, I can't figure out what you mean by Wrap
19:12:57 <adu> instance Wrap {}
19:13:00 <adu> instance Wrap []
19:13:03 <heatsink> non-text-based programming interfaces?
19:13:12 <luqui> heatsink, yeah
19:13:18 <FunctorSalad_> that would be nice
19:13:25 <heatsink> ah
19:13:34 <luqui> adu, so any unary constructor?
19:13:34 * heatsink 's only experience with that was labview
19:13:39 <adu> heatsink: well, specifically visual, sound/speech based programming is usually not implied
19:13:49 <FunctorSalad_> commutative diagrams ftw
19:14:14 <heatsink> adu: sound is even more linear than text.
19:14:17 <FunctorSalad_> how about a PL where you paste diagrams together? ;)
19:14:17 <adu> luqui: well, maybe, I was thinking specifically indexable containers
19:14:32 <luqui> adu, {} means set?  how is that indexable?
19:14:39 <adu> like things with (b -> Int -> a)
19:15:04 <adu> luqui: its indexable like ({a} -> a -> Bool)
19:15:16 <adu> luqui: i dunno, its kinda open-ended
19:15:33 <Myoma> luqui: Have you tried epigram?
19:15:49 <luqui> hm.  okay, that's enough to go on.  (someday you'll probably want to make it precise)
19:15:53 <adu> luqui: basically, all the features I can think of need to be able to use Lists and Sets and nothing else, so maybe a typeclass is the wrong idea
19:16:07 <luqui> Myoma, yes, epigram is my favorite so far.  Totally a pain in the ass to use, but it has potential.
19:16:51 <adu> luqui: if I ever get around to implementing it, then I'll probably have more of an idea what kind of methods are needed...
19:17:22 <Myoma> adu: Why not start now? :)
19:17:32 <adu> Myoma: I have a parser, but no evaluation...
19:17:42 <Myoma> adu: I think you should write the typechecker
19:18:05 <adu> Myoma:  before evaluation?
19:18:16 * luqui used to write parser first.  now he writes parser last.
19:18:40 <luqui> adu, I'd say write the typechecker first because that's probably the hardest one.
19:18:45 <adu> luqui: what do you write first now?
19:18:48 <adu> ic
19:19:04 <luqui> i.e. writing the typechecker will show you how your language is broken, so you can fix it early.
19:19:07 <Myoma> adu: Well the typechecker is the interesting part of your language -- and it tells you which ivarients you can rely on in the evaluator
19:19:27 <luqui> another good argument :-)
19:20:08 * adu begins the typechecker!
19:20:13 <luqui> adu, I'm having a really hard time putting together your language from the examples.
19:20:19 <Myoma> adu++ # hehe
19:20:58 * luqui wishes not to interfere with the mad coder by talking.
19:21:16 <adu> luqui: well, types are first-class in my language, and where Haskell has 1 cons and 1 nil, I have 2 conss and 2 nils
19:21:51 <luqui> newsham, I never got back to you did I?
19:22:09 <luqui> it's still there, in TVal.hs.  But that isn't exposed (perhaps it should be...)
19:22:40 <adu> luqui: the 2 conses are (.) and (:) described in the paste, and the 2 nils are essentially {} and []
19:23:11 <luqui> After we got hit by that bug, the LegacyAdapters effort stopped, so you might have to work around the source code to make it easier to use.  If you get something cool, send it along with however you needed to patch reactive to get it done..
19:23:14 * Myoma thinks {} should be const []
19:23:22 <Myoma> oh no it shouldn't ..
19:26:03 <adu> luqui: in my language, since (.) makes homogeneous lists, (1 . (2 . [])) will be of type [Int] as in Haskell, but since (:) makes heterogeneous lists, (1 : ('c' : [])) would be of type [Int, Char] and since types are values, then this can be expressed (Int . (Char . [])) as well
19:26:22 <adu> luqui: that is why the type of (:) is a -> b -> (a . b)
19:27:08 <luqui> adu, what (if possible) would be the type of homogeneous lists of at most 3 elements?
19:27:23 <adu> luqui: [Int#3]
19:27:34 <luqui> adu, without special syntacx
19:27:41 <luqui> how is it represented in the core?
19:28:55 <luqui> also, just clarification, i gather [ Int, Int ] is two things: a list of two types, and the type of lists with two integers.  correct?
19:30:17 <adu> luqui: i don't have a syntax, actually (#) :: Type -> Int -> Type so thats not really core, and its "exactly 3", not "<= 3"
19:30:50 <Myoma> adu: Why 'Type' and not '*'
19:30:56 <luqui> ah, I chose <= for a reason, because it's hard to do in haskell.  (Int,Int,Int) woudl suffice otherwise, no?
19:31:11 <luqui> Myoma, who cares?
19:31:14 <adu> Myoma: because * is used to indicate lack of type Type is very specific
19:31:16 <Myoma> adu: (Type is the kind of common name I use in programming and would be irritated if the language already stole it for its own use :p)
19:31:55 <adu> hmm
19:32:05 <heatsink> Myoma: as opposed to *, which doesn't have a meaning in any reasonable programming language :p
19:32:19 <luqui> ah.  anyway, syntax/naming is not the most important thing when designing an experimental language like this (imho)
19:32:20 <Myoma> heatsink: Well - it has clear meaning in haskell
19:32:27 <adu> luqui: but thats a heterogeneous list, and you asked for a homogeneous list
19:32:47 <luqui> adu, well, it's homogeneous, but just incidentally.
19:32:56 <adu> luqui: in my language a heterogeneous list with all the same type is different than a homogeneous list...
19:32:58 <adu> right
19:33:09 <luqui> sure, as it should be.
19:34:14 <luqui> okay, let's try another question that will get at what I'm asking: can you define concatenation on statically-lengthed lists?
19:34:45 <adu> luqui: like [a#n] -> [a#m] -> [a#(n+m)]?
19:34:54 <luqui> yep.
19:35:12 <luqui> how do you check that the implementation is correct?
19:35:23 <adu> luqui: no idea... lol
19:35:48 <luqui> i.e. what if you typed it: [a#n] -> [a#m] -> [a#(n+m+1)], but it actually didn't add an extra element.  How would you find the error.
19:35:52 <luqui> (is that what you have no idea about?)
19:36:35 <adu> well, you'd have to track the multiplicity (n) of each type in each expression
19:37:09 <luqui> ah, so your cons deconstructor would have the numbers encoded somehow in it?
19:37:33 <luqui> like uncons :: [a#n] -> (a, [a#(n-1)]), for example?
19:40:07 <luqui> in any case, it sounds like your language is not quite as general purpose as existing dep type languages.  Hopefully that means it has the ability to be understood by people without PhD's :-).  Keep me informed on progress.
19:40:34 <adu> luqui: well only (.), (:) encodes in the type, but yes, (.) would also encode, but not visually, you'd have to have the multiplicity be part of the type like "data Type = T { name :: String, multi :: Int }"
19:40:54 <luqui> that seems like a hack...
19:40:58 <haskellian> @src seq
19:40:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:41:07 <adu> a hack? maybe
19:41:18 <hackage> Uploaded to hackage: xcb-types 0.2.0
19:41:18 <luqui> i.e. why is multiplicity so special?
19:41:24 <luqui> that it gets language support.
19:41:33 <luqui> s/language/core/
19:41:51 <adu> luqui: these are very good questions
19:42:53 <newsham> what good istype dep language if not for phd theses?
19:43:06 <luqui> anyway, if you're a hacker, I suggest hacking :-).   That's how I figure stuff out...
19:43:19 <luqui> talking just makes me doubt myself =/
19:43:47 <adu> luqui: I am :)
19:43:56 <luqui> newsham, haha.  But yeah, none at the moment.  At least two of us are trying to remedy this :-)
19:44:16 <Myoma> I think the YNot project is very promising
19:44:40 <Myoma> It's like a really good monad (?) and tools to prove things about programs written in it
19:44:41 <heatsink> YNot is interesting.  I wish I could understand Coq.
19:44:42 <luqui> (well, me in a not-really-i'm-just-doing-it-because-it's-interesting sort of way)
19:44:51 <Myoma> (I could be _totally_ wrong but that was my impression)
19:45:03 * luqui checks it out
19:45:04 <adu> well I personally think heterolists and deptypes are crucial to all future programming
19:45:07 <adu> but i could be wrong
19:45:34 <Myoma> heatsink: If you can program in Haskell you can definitely understand Coq
19:45:40 <heatsink> It's also interesting how the syntax used in Ynot papers has gradually become more and more haskell-like over time :)
19:45:53 <adu> whats Ynot?
19:46:10 <luqui> ah.  the awkward squad can blow me.  =P
19:46:39 <luqui> as I advance in haskell, I rid myself more and more of the necessity for those things, so I don't really care... ;-)
19:46:47 <newsham> what is "a really good monad"?
19:47:04 <newsham> when good monads turn bad
19:47:12 <luqui> class RGMonad m where solveWorldHunger :: m ()
19:47:21 <luqui> class RBMonad m where launchMissiles :: m ()
19:47:45 <heatsink> If you launch enough missiles, you can solve the world hunger problem.
19:47:49 <luqui> LOL
19:47:56 <adu> unsafePerformSolveWorldHunger
19:48:00 <heatsink> :)
19:48:11 <newsham> class Nomad where (<<=) :: m b -> (a -> m b) -> m a
19:48:22 <newsham> nomadic computing
19:48:54 <luqui> newsham, interrresssting.  I wonder if there are any nontrivial nomads.
19:49:07 <Myoma> :t (>>=)
19:49:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:49:44 <luqui> newtype IDNomad r a = IDNomad (a -> r) -- I think this is one.
19:49:54 <newsham> terurn :: m a -> a
19:50:06 <luqui> newsham, you know about comonads?
19:50:17 <newsham> i've heard the expression but i have not learned them, no.
19:50:27 <luqui> "terurn" is one of their methods.
19:50:33 <luqui> (usually not spelled like that)
19:50:48 <newsham> i'll learn the co's after I'm done learning all the non-co's
19:50:52 <luqui> comonads are neat.  Check this out: http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
19:50:58 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
19:51:01 <newsham> which should be shortly after I enumerate all the naturals
19:51:07 <luqui> ah a systematic learner are you
19:51:13 <luqui> haha
19:51:14 * Myoma is baffled by that post, it makes comonds seems utterly unappealing
19:51:24 <luqui> Myoma, really?  :-(
19:51:31 <luqui> that's where I learned about their awesomeness
19:51:36 <luqui> but to each his own I guess.
19:51:40 <newsham> corecursion is neat though
19:51:53 <Myoma> I maybe did not understand it properly but it seems utterly awful compared to the equvalent C program
19:52:23 <Myoma> OI is also terrible
19:52:24 <luqui> wow, that is quite the insult to the haskell programmer.
19:52:27 <luqui> OI blows
19:52:35 <luqui> and also doesn't even make sense.
19:52:40 <newsham> there is beauty, even in C.
19:52:54 <Myoma> and I can't imagine the supply comonad is easier in any case than the monadic one
19:52:55 <newsham> not everything imperative is evil
19:53:01 <Myoma> newsham: Yes, that's my point
19:53:11 <luqui> that's true, that post though showed me that CA is not necessarily imperative.
19:53:13 <Myoma> newsham: It's actually expressed clearly in imperative code
19:53:39 <luqui> well, the syntax kinda gets in the way of the clarity:  rule (U (a:_) b (c:_)) = not (a && b && not c || (a==b))
19:53:40 <Myoma> hm I better reread
19:53:42 <luqui> that takes some decoding
19:54:17 <adu> newsham: is that like a cocomonad?
19:54:19 <newsham> unless you're an EE?
19:54:34 <newsham> she dont lie she dont lie she dont lie.. co-caine
19:54:41 <luqui> Comonads tackle a whole different type of problem than monad. If you compare them side by side, you'll see one or the other as useless...
19:54:57 <luqui> newsham, haha
19:55:34 <luqui> the dual of a continuation is a ntinuation?
19:55:45 <ddarius> Indeed.  Who wants to resolve simplicial complexes using monads?
19:55:52 <newsham> co-rrect
19:56:26 <luqui> Ah, I'm too cool to write correct programs.  I write rrect coprograms.
19:57:15 <newsham> you're co-razy
19:58:29 <DarthMeh> @src zipWith
19:58:29 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:58:29 <lambdabot> zipWith _ _      _      = []
19:59:11 <newsham> zipWithout f (a:as) (b:bs) = f b : zipWith f as bs
19:59:12 <heatsink> luqui: I'm still curious about the type erasure thing.  From LambdaPi I got the sense that dependent typing implies some run-time type checking.  OTOH, ynot seems to compile to something type-erased.
19:59:30 <Myoma> heatsink: It does not
20:00:05 <luqui> heatsink, it implies the reverse:  compile-time type running.
20:00:18 * luqui doesn't really know the technicalities of this question, however.
20:01:37 <Myoma> heatsink: compiling something from Coq to ocaml or haskell can end up with lots of unsafeCoerce -- but no runtime type checking
20:03:52 <adu> luqui: are you writing a phd?
20:04:50 <luqui> adu, nope
20:05:41 <ddarius> Blech.  Really poor speaker.
20:05:46 <heatsink> Okay.  So how can application of dependently typed functions statically checked?  That seems to be the place for which checking is required.
20:06:13 <Myoma> heatsink: How do you write a checker for dependent types?
20:06:16 <adu> luqui: just research?
20:07:07 <adu> heatsink: obviously, make (::) a compile-time macro
20:07:17 <heatsink> Myoma, I would guess you have to prove that certain pairs of values will always be equal at run time?
20:08:24 <ddarius> For future reference, Steve Ganz is not a good speaker.
20:08:29 <Myoma> heatsink: You just need to be sure all the typing rules hold
20:08:52 <heatsink> Myoma, I've read the LambdaPi paper which does run-time evaluation, and the chapter in ATTAPL which requires definitional equality on terms in dependent types.
20:09:32 <Myoma> heatsink: Did you ever come across the ATTAPL code? I haven't been able to find it
20:09:32 <hansfbaier> @src iterate
20:09:33 <lambdabot> iterate f x =  x : iterate f (f x)
20:09:43 <heatsink> Myoma, I haven't looked for it.
20:09:55 <Myoma> oh well
20:10:44 <Myoma> heatlink: If I want to typecheck  2 = 1 + 1
20:11:11 <Myoma> heatlink: I'll normalize the type to get 2 = 2 and the check that the term has that type
20:11:24 <heatsink> Myoma, What if you want to typecheck inefficientFindNthPrime n = efficientFindNthPrime n ?
20:11:24 <Myoma> heatlink: the normalize bit is done at typechecking time - not runtime
20:11:46 <Myoma> do you mean forall n, inefficientFindNthPrime n = efficientFindNthPrime n ?
20:11:47 <adu> I wonder if anyone has thought of making libraries of reminiscent language operators, like Language.Maple.Operators
20:11:51 <heatsink> Myoma, yes
20:12:11 <Myoma> heatlink: There are far too many details missing, but one way might be induction on n
20:12:29 <heatsink> Myoma, my name is heatsink.
20:12:29 <Myoma> that is, a recursive function defined for the cases 0 and m+1
20:13:13 <Myoma> sorry was that annoying? It was a mistake
20:13:44 * ddarius doesn't know what is up with Myoma.
20:13:48 <heatsink> If you spell my name correctly, my IRC client will highlight your message.
20:14:09 <adu> headsing: cool
20:14:52 <vininim> you could also /hilight heatlink and headsing if it turns out to be how people refers to you =P
20:15:03 <heatsink> heh.
20:15:30 <adu> my irc client will highlight any line containing "adu" or "graduate" or "math" or "mathematics"
20:15:49 <Myoma> heatsink, better way to learn this stuff is to try proving some simple number theory in Coq
20:16:09 <lispy> just coq up some proof, eh?
20:16:40 <heatsink> Myoma, would this recursive function be a proof "if these functions are equal when the parameter is m, they are equal when the parameter is m+1"?
20:16:43 <Myoma> if you can write a haskell program that divides two numbers its only a few order of magnitudes harder to prove it works
20:17:48 <Pseudonym> Writing a correct division algorithm is easy.  Just ask Intel.
20:18:00 <vininim> yeah, like fermat conjecture
20:18:46 <Myoma> did Intel get it wrong?
20:18:47 <adu> luqui: so what do you think of my 2-cons 2-nil system?
20:18:59 <ddarius> Integer division is easier than floating point, and if you don't care about efficiency it is easier still.
20:19:00 <Pseudonym> Oh, man, am I that old?
20:19:04 <heatsink> Is a type checker supposed to synthesize proofs like that, or is the programmer supposed to supply it?
20:19:12 <heatsink> Myoma, heard of the Pentium bug?
20:19:15 <ddarius> Pseudonym: Yes, but that isn't relevant here.
20:19:22 <Pseudonym> Right.
20:19:24 <Myoma> heatsink: type checker checks types -- nothing more
20:19:28 <Pseudonym> I just had a flash of my old age.
20:19:45 <mwc> heatsink: type checking verifies the internal consistency of your program
20:19:51 <Pseudonym> I'll be talking to you youngins about the glory days of the Pentium, with the fdiv bug and the f00f exploit.
20:19:57 <heatsink> Myoma, such a proof could be a necessary lemma to check types in a dependently typed program though.
20:20:03 <lispy> Myoma, heatsink: er, what myoma just said is true, but types are isomorphic to logic statemens
20:20:51 <Myoma> heatsink: ye
20:20:52 <Myoma> heatsink: yes*
20:20:54 <mwc> right, but the logical statement equivalent to the type inhabitation problem doesn't really say much about the correctness of the implementation
20:21:36 <lispy> well sure, not all logical statements are useful :)
20:21:37 <mwc> f a b n = if n < 5 then a else b
20:22:03 <mwc> the type of f is f :: a -> a -> Int -> a
20:22:16 <mwc> but I could have screwed up and reversed the order of a and b
20:22:26 <luqui> adu, well, like I said, I think it is less general-purpose than existing systems, but it could still be useful, and presumably understandable without a maths degree...
20:22:32 <ddarius> lispy: Where would we be without a â§ b â a?  Relevant logic, that's where.
20:22:33 <heatsink> lispy, I sort of get the curry howard isomorphism for non-dependent type systems, but I don't get how it works at all in a dependent context.
20:22:40 <luqui> adu, I still wonder about some of the details.
20:22:44 <Pseudonym> > 4195835.0/3145727.0
20:22:46 <lambdabot>  1.333820449136241
20:22:49 <luqui> i.e. whether they will give rise to a consistent systme
20:22:56 <Pseudonym> No bug here.
20:23:14 <Myoma> heatsink: the only case you don't understand it âx:A, B
20:23:31 <Myoma> heatsink: A -> B is syntax for â_:A, B, and you know what that means: )
20:23:48 <Myoma> heatsink: so âx:A, B(x) is forall x of type A, B of b
20:23:49 <Myoma> heatsink: so âx:A, B(x) is forall x of type A, B of x*
20:24:19 <Myoma> (hopefully it should be clear how it relates to the case when x is not around)
20:24:45 <Myoma> > 1.333820449136241 * 3145727.0
20:24:47 <lambdabot>  4195835.0
20:24:51 <ddarius> heatsink: Figure out which logic dependent types correspond to and then Curry-Howard works out just the same.
20:25:20 * luqui likes agda's Pi notation:  (x:a) -> b
20:25:27 <luqui> quite transparent
20:25:32 * Myoma prefers forall x : a, b
20:25:32 <Myoma> a
20:25:43 <vininim> x head and a list? *hides*
20:25:52 <Myoma> (x:a) -> b makes about as much sense as data .. = Just a
20:25:55 <haskellian> what function does insert 0 [1,2,3] -> [1,0,2,0,3]
20:26:03 <heatsink> haskellian, intersperse
20:26:05 <haskellian> i have seen one but for got the name
20:26:08 <haskellian> ty
20:26:29 <luqui> Myoma, ?
20:26:47 <Myoma> in a data decl you have <value> <type> <type> ...
20:26:50 * lispy wonders how many 2 word nicknames can be constructed from heatsink with an edit distance of 1
20:27:04 <newsham> > concat $ zipWith (\a b -> [a,b]) "testing" (repeat '-')
20:27:06 <lambdabot>  "t-e-s-t-i-n-g-"
20:27:13 <Myoma> you can't apply values to types.. it is unambiguous though
20:27:16 <luqui> Myoma, oh I hthink I see what you mean.
20:27:33 <lispy> > init $ concat $ zipWith (\a b -> [a,b]) "testing" (repeat '-')
20:27:35 <lambdabot>  "t-e-s-t-i-n-g"
20:27:49 <ddarius> lispy: It's easy enough to write a program to find out.
20:27:49 <Myoma> my intuition of (x:a) -> b is be a value equal to x -> b where x : a
20:28:14 <Myoma> (my intuition doesn't matter though, because that's not how reality is)
20:28:16 <lispy> ddarius: kinda...I'm awefully lazy to find a dictionary
20:28:30 <luqui> ah, kind of the way in mathematics that people stick elem A after things as kind of side-notes.
20:28:35 <newsham> ls -l /usr/share/dict/words
20:28:36 <cjs> Ooo! New hoogle!
20:29:42 <newsham> (a : Set) -> a -> a
20:30:28 <lispy> with newsham's example, I see that my intuition matches that of Myoma
20:30:45 <Myoma> It's a fine intuition and breaking it isn't very hard
20:31:03 <Myoma> hmmm
20:31:07 <luqui> peddling to intuition can be a large mistake for a programming language.
20:31:12 <dino-> > Data.List.intersperse '-' "testing" ++ "-"
20:31:14 <lambdabot>  "t-e-s-t-i-n-g-"
20:31:15 <luqui> (not that it always is, but it's not the #1 most important thing)
20:31:22 <newsham> yes, the best languages are counterintuitive ;-)
20:31:28 <dino-> > Data.List.intersperse '-' "testing"
20:31:30 <lambdabot>  "t-e-s-t-i-n-g"
20:31:35 * Myoma mostly likes languages that break her intuition into bits and lose the peices :p
20:31:47 <lispy> Myoma: are you vixey?
20:31:47 <luqui> if you peddle to the intuition of people who are already programmers, you are doomed to recreate an existing programming language
20:31:58 <Myoma> lispy, yes
20:32:00 * aFlag likes intuitive stuff
20:32:03 <lispy> Myoma: aaah
20:32:06 <Myoma> lispy, well not any more
20:33:03 <newsham> who exactly is dep types intuitive to?
20:33:14 <newsham> or rather.. which existing programmers :)
20:33:24 <lispy> luqui: yeah, but the Digital Mars folks do seem to be doing well inspite of that.  Not that I've tried D, but it does seem to be getting recognition for being a better C.
20:34:19 <luqui> oof. D.
20:35:26 <luqui> D is C++ with more powerful brokenness.
20:35:45 <adu> luqui: lol
20:36:13 <newsham> import java.lang.D
20:36:53 <Myoma> hmf
20:37:03 <Myoma> you can't tell agda to use a different ghci than haskell-mode
20:39:33 <heatsink> newsham, It's kind of funny that dependent types are unintuitive, because in weakly typed or dynamically typed languages people use them a lot.
20:39:42 <lispy> :t String -> IO String
20:39:44 <lambdabot> parse error on input `->'
20:39:44 <lispy> er
20:39:47 <haskellian> can i somehow do :modules and have a list of all available libraries?
20:39:49 <lispy> ?hoogle String -> IO String
20:39:49 <lambdabot> System.Environment getEnv :: String -> IO String
20:39:49 <lambdabot> Prelude readFile :: FilePath -> IO String
20:39:49 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
20:39:55 <haskellian> qavailable for import
20:39:58 * Myoma didn't understand what heatsink just said
20:40:01 <newsham> heatsink: but they dont have to prove that their interfaces are sound.
20:40:06 <heatsink> True.
20:40:25 <Myoma> newsham: You don't have to do that with deptypes either of course
20:40:30 <haskellian> heatsink: what is a dependant ype?
20:40:39 <newsham> myoma: sure, but then what is the point of using an expressive type system?
20:40:55 <newsham> if you dont need to prove non-trivial theorems, then do you need a fancy type system?
20:40:57 <dino-> haskellian: you can do $ ghc-pkg list
20:40:58 <Myoma> newsham: I don't know, nobody seems to be using them for anything
20:41:07 <adu> newsham: what do you mean by expressive?
20:41:08 <heatsink> Myoma, I meant that to describe some programming idioms using types, e.g. in C or python, requires dependent types.
20:41:18 <hackage> Uploaded to hackage: pxsl-tools 1.0.1
20:41:25 <heatsink> *to describe some extant programming idioms
20:41:34 <newsham> adu: like, the ability to specify the notion of lists that are sorted
20:41:40 <Myoma> heatsink: ah, yeah, You couldn't even put a type to most of the stuff we do in Prolog :)
20:41:48 <adu> newsham: can you do that in Haskell?
20:41:56 <newsham> you can do that in agda's type system
20:42:09 <newsham> so you could write a function that you can only pass in sorted lists
20:42:13 <adu> newsham: can you specify that a list must have 3-10 elements?
20:42:14 <newsham> and the type checker will enforce that
20:42:18 <newsham> adu: sure.
20:42:39 <newsham> you can define a list type that carries around its size in the type
20:42:40 <Myoma> adu: { xs : list A | 3 < length xs < 10 } (* Valid Coq *)
20:42:49 <newsham> and then define types for less than and greater than and conjunction
20:43:25 <newsham> this all places an increased burden on the users of these APIs
20:43:30 <newsham> they have to pass in proofs with their arguments
20:43:42 <newsham> and so you need to hire PhD's.
20:44:27 <adu> Myoma: I thought we were talking about agda?
20:44:41 <Myoma> adu: I thought we were talking about dependent types in general
20:44:51 <Myoma> adu: In Agda you'd just write the same thing with different syntax
20:45:24 <Myoma> adu: (but I don't know if Agda has a library which defines all the bits to do it)
20:45:28 <adu> ic
20:45:46 <newsham> what was that pierce slide deck where he says that overly complex type systems are evil (somewhat tongue-in-cheek) ?
20:46:13 * Myoma didn't really understand that or what it had to do with lenses
20:46:16 * adu reads Benke.pdf
20:47:32 <heatsink> newsham, I think I recall that... in the ``boomerang'' paper?
20:47:32 <adu> newsham: tongue-in-cheek? meaning he was joking?
20:47:54 <newsham> http://lambda-the-ultimate.org/node/2828
20:48:06 <lambdabot> Title: Types Considered Harmful | Lambda the Ultimate
20:52:59 <newsham> "attempting to prove any nontrivial theorem about your program will expose lots of bugs"
20:53:13 <newsham> "the particular choice of theorem makes little difference"
20:53:36 <heatsink> That was a cool presentation.
20:55:35 <iamabarnacle> is there a way (e.g., a ghc extension) to make the compiler treat newtypes like the types they are wrapping?  e.g., http://hpaste.org/9905
20:55:43 <sclv> the thing with boomerang is it introduces a form of dependent types for invertability, no?
20:55:56 <newsham> iamabarnacle: deriving(...)  can help
20:55:57 <luqui> iamabarnacle, there's generalized newtype deriving, which goes most of the way
20:56:27 <lispy> heatsink: http://hpaste.org/9908
20:56:42 <sclv> which makes writing lenses less tedious and easier to prove correct.
20:56:56 <sclv> since proving an arbitrary lens correct is non-trivial.
20:57:00 <luqui> iamabarnacle, annotated
20:58:03 <newsham> newtype NT = NT String deriving (Show);  test = print;     for examle (not quite the same thing)
20:58:08 <Myoma> composition of bijections is a bijection
20:58:19 <Myoma> solution: Write everything as compositions
20:58:31 <heatsink> lispy, thanks, but I'm not highlighting "teatkink"
20:58:43 <lispy> heatsink: hehe
20:58:58 <iamabarnacle> i see...  but there's no way to make the compiler treat nt as string?  sort of like synonymous
20:59:15 <luqui> iamabarnacle, why do you not just want a type synonym?
20:59:17 <Myoma> iamabarnacle: Just use string in that case
20:59:25 <stepcut> just do, type NT = String, ;)
20:59:40 <newsham> lispy:   lines <$> readFile "/usr/share/dict/words"
20:59:43 <luqui> iamabarnacle, i.e. what do newtypes gain you that type synonyms do not in your example?
20:59:51 <luqui> (not the one you pasted, the one you're wondering about)
20:59:58 <newsham> also you can use one big "let", no need for 4 of em
21:00:25 <lispy> newsham: sure, or even fmap.  BTW, I like retyping let...I know the other syntax but don't find it as visually pleasing
21:00:58 <newsham> act =<< pure.functions.here <$> action   rules
21:01:05 <humasect> does yi use ghc api ?
21:01:15 <iamabarnacle> just wondering whether it could be done :)
21:01:55 <luqui> nope.  I'm finding that those constructors make a lot of code rather inelegant, however, so a good solution to that is something I'd like seeing :-)
21:02:08 <luqui> there are type checking problems with just brute forcing it though
21:02:14 * sclv is in awe of lispy's genius coding.
21:02:51 <adu> Agda has parameterized modules?
21:02:52 <lispy> sclv: I hope that's scarcasm :)
21:02:55 <adu> i'm done
21:03:02 <Myoma> "done"?
21:03:04 <adu> thats it, no more programming
21:03:17 <adu> too much parameterization for me
21:03:19 <Myoma> at least finish what you're working on first
21:03:28 <adu> o ya, the typechecker...
21:03:32 <adu> that first :)
21:03:40 <Myoma> why on earth would you be put off by a module system though
21:03:42 <luqui> "just one more program"
21:03:44 <sclv> its midnight for me, so i don't think i'd be in any condition to crank out any even semi-reasonable haskell at the moment, much less on such short notice :-)
21:03:55 <luqui> s/program/cigarette/
21:03:56 <lispy> sclv: hehe
21:04:03 <haskellian> how do i check my load-path in emacs?
21:04:11 <Myoma> M-x ielm
21:04:16 <Myoma> ELISP> load-path
21:04:20 <lispy> haskellian: go to the scratch buffer, type load-path, then C-x e
21:04:22 <Myoma> I've already told you this, haven't I?
21:05:34 <adu> Myoma: s/put off/brain hurt/ more like...
21:05:42 <sclv> Myoma: re that, see piece's various papers. that works fine for the simple stuff, but what if the things you want to express don't break down neatly into previous bijection primitives?
21:06:08 <Myoma> sclv: I was just being silly, composition isn't enough
21:06:27 <sclv> On the other hand, I tend to think that one can get much further without pain in standard haskell than pierce does.
21:06:28 <adu> Myoma: but i suppose if modules are first-class in agda, it would be like having lambdas return modules, so i suppose that's how I'll think of it for now...
21:06:35 <adu> yey! back to programming :)
21:06:52 <Myoma> adu: it's not like that
21:07:11 <adu> why not?
21:07:12 <luqui> stop distracting him! ;-)
21:07:30 * Myoma is also distracted
21:07:46 * Myoma has spent two days not write a partical bit of code
21:07:52 <lispy> What are the technically differences between agda and coq (remember, I'm just a normal Haskell programmer without any extensive type theory bg)
21:07:53 <sclv> if you're not clever though, you run into the same problems as with the pickler combinator paper -- its just slightly too ugly for everyday use...
21:08:14 <adu> Myoma: I'm all practical-coded out, I wrote 'only' over the last two weeks or so...
21:08:39 * sclv would very much like to know the same thing lispy asked.
21:10:21 <adu> so typechecker :: Exp -> Type?
21:10:36 <Myoma> I think that typechecker :: Exp -> Maybe Type
21:10:41 <adu> heh
21:10:45 <Myoma> er perhaps even include an error message
21:10:56 <adu> so IO Type
21:11:02 * Myoma has written typecheck :: Exp -> Infer Type
21:11:04 <Myoma> in the past
21:11:13 <sclv> does Type include a set of typeclass restrictions?
21:11:27 <adu> typecheck :: Exp -> Type -> IO Bool?
21:11:30 <Myoma> adu: IO ??
21:11:52 <adu> Myoma: i don't know of any other way of doing errors
21:11:52 <sclv> what is the type of Type, actually?
21:12:00 <adu> Type :: Type
21:12:00 <Myoma> adu: Um,, Strings ...
21:12:14 <Myoma> Exp -> Either String Type
21:12:33 <adu> sclv: unless you're deluded by OMG.org in which case Type :: Class :: Model :: MetaModel
21:12:44 <sclv> what is the representation as a Type of [a] even?
21:13:01 <sclv> or of Fractional a -> [a] ?
21:13:17 <lispy> sclv: well, -> is a type
21:13:18 <sclv> Type is a tree, I suppose?
21:13:30 <Myoma> :K (->)
21:13:31 <sclv> erm, Fractional a => [a] that is.
21:13:33 <Myoma> :k (->)
21:13:34 <lispy> (->) (Fractional a) ([] a)
21:13:34 <lambdabot> ?? -> ? -> *
21:14:22 <heatsink> :k Int
21:14:24 <lambdabot> *
21:14:35 <lispy> :k Fractional
21:14:37 <lambdabot> Class `Fractional' used as a type
21:14:39 <heatsink> I thought it was # -> *
21:15:17 * heatsink wonders why normal-interpolated triangles take so much longer to render than normal triangles
21:17:27 * heatsink has a test render to show off: http://img.photobucket.com/albums/v636/noktakanto/phong_fresnel3.jpg
21:17:38 <lambdabot> http://tinyurl.com/3h8qyn
21:17:52 <lispy> heatsink: nice
21:18:12 <heatsink> thx :)
21:19:05 <adu> so I guess I could just do deriving(Read,Show) until I write a parser... right?
21:19:55 <lispy> adu: correct
21:20:15 <lispy> adu: the performance will suck for now, but if you can get a correct program going, you can deal with performance later
21:24:34 <humasect> yi0.4.4 needs parsec 2.1 ... and regex-tdfa .94 , which needs parsec 3.0 ~
21:25:29 <sclv> humasect: you can have both at once...
21:25:53 <humasect> ok, so cabal's warning of compiler failure being highly likely, is  ok ?
21:26:16 <sclv> in this case, probably... the two parsecs shouldn't overlap.
21:26:23 <humasect> ah, cool=)
21:26:43 <dsrogers> @seen mmorrow
21:26:43 <lambdabot> mmorrow is in #haskell, #ghc and #darcs. I last heard mmorrow speak 3h 54s ago.
21:26:55 <dsrogers> mmorrow-p
21:26:59 <lispy> dsrogers: hey
21:27:17 <dsrogers> yes?
21:27:30 <lispy> dsrogers: ust saying hi
21:27:37 <dsrogers> oh!  hi!
21:27:52 <dsrogers> did you hear about my TH test lib?
21:28:01 <dsrogers> it's really haskish at the moment, but it works!
21:28:37 <dsrogers> err, hackish
21:29:52 <lispy> no, how's it work?
21:30:10 <dsrogers> let me commit come code and I'll link it for you
21:32:33 <dsrogers> http://code.google.com/p/hoc/source/browse/trunk/hoc/Tests/TestHOCDeclareSelector.hs
21:32:35 <lambdabot> Title: hoc - Google Code, http://tinyurl.com/3t7g8f
21:32:43 <dsrogers> http://code.google.com/p/hoc/source/browse/trunk/hoc/Tests/TestHOCDeclareSelectorForward.hs
21:32:46 <lambdabot> Title: hoc - Google Code, http://tinyurl.com/5egr97
21:33:01 <dsrogers> the second one has all the meat.
21:33:59 <dsrogers> the first one is the hack that convinces the compiler to run my TH slice.
21:34:42 <dsrogers> mmorrow helped me with ppAST and ppQ
21:37:09 <dsrogers> the test program /is/ ghc.
21:37:38 <dsrogers> in the link command I actually do a -pgml true to ignore linking
21:38:30 <lispy> Huh, I looked at the second one, but I don't know what I was looking at.
21:38:55 <dsrogers> ok, so the first one just tells it to run the slice $(dummy)
21:39:05 <dsrogers> dummy is defined in the second one.
21:39:38 <dsrogers> the only important thing about dummy is that [()] is the last line, so that the first file will compile correctly.
21:40:19 <dsrogers> the function that's being tested is expandSynonyms which has type :: Type->Q Type
21:40:48 <dsrogers> so when you compile this program, "dummy" is run as a slice by the compiler.
21:41:02 <dsrogers> those "runIO" lines are actually output by the compiler.
21:41:12 <mib_33cnhg> Hello, I have a newb question about Haskell and in particular an example from the "Yet Another Haskell Tutorial"
21:41:19 <hackage> Uploaded to hackage: control-monad-free 0.1
21:41:22 <dsrogers> and the "fail" in compareTypes actually causes the compile to fail.
21:41:36 <dsrogers> mib: go ahead
21:42:47 <dsrogers> firstOrderAlias and firstOrderAliasAnswer (and the rest of the big type statements) are just test data.
21:43:10 <mib_33cnhg> At the top of page 47 there is the example for a count given as: count2 p 1 = foldr (\x c -> if p x then c+1 else c) 0 1
21:43:15 <dsrogers> as in, expandSynonyms should transform firstOrderAlias into firstOrderAliasAnswer or the compile fails.
21:43:39 <Myoma> > 1
21:43:41 <lambdabot>  1
21:43:42 <mib_33cnhg> my question is why does this foldr work on a String
21:43:49 <Myoma> mib_33cnhg: That should be l not 1
21:43:57 <mib_33cnhg> ya i ment to type l
21:44:00 <mib_33cnhg> sorry
21:44:01 <dsrogers> becuase a string is a [Char]
21:44:46 <mib_33cnhg> but the argument for the foldr here is 0 isnt that an Int?
21:45:14 <dsrogers> ah.
21:45:23 <dsrogers> 0 is passed as the second argument of the lambda
21:45:31 <dsrogers> the lambda returns an Int
21:45:49 <dsrogers> and the returned value of the lambda is passed as the second argument of the next call to lambda
21:45:59 <dsrogers> the second argument is the "accumulator"
21:46:19 <dsrogers> you can see this from the type of foldr
21:46:23 <dsrogers> :t foldr
21:46:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:46:56 <dsrogers> notice that the type of the second argument does not have to be the same as the type contained in the array
21:47:16 <dsrogers> in other words:
21:47:40 <dsrogers> the first argument is a two argument function, it takes the array contained type, and some other type, and returns the other type.
21:48:37 <joe__> if I have a type constructor of 'Wood Int', and I want to find all occurences of Wood in a list, no matter what the Int value is... how would I do that
21:48:38 <dsrogers> the second argument of foldr, is an initial value of the "other type"
21:48:41 <joe__> ?
21:48:53 <joe__> is there some sort of operator that checks just for types?A
21:49:49 <dons> what's the type of the list?
21:49:49 <dsrogers> yes, in a patter.
21:49:51 <mib_33cnhg> ok...i think i see, I will try to wrap my head around the type of foldr...maybe my problem came from the "lite" description of foldr
21:49:52 <dons> [Wood Int] ?
21:49:58 <joe__> [Resource]
21:50:09 <joe__> WHere Resource can be Wood Int, Ocean, Desert, etc
21:50:25 <dsrogers> is someone playing SoC?
21:50:26 <mib_33cnhg> as just consing the second argument to the end of the list
21:50:30 <joe__> ...No
21:50:33 <joe__> :)
21:50:41 <dsrogers> lol
21:50:45 <Myoma> isWood (Wood _) = True
21:50:50 <Myoma> isWood _ = False
21:50:51 <mib_33cnhg> thanks
21:50:51 <dsrogers> anyway, what you want is a patter.
21:50:54 <Myoma> count isWood
21:50:58 <joe__> Myoma: Lets say I have many different types of resources tho
21:50:59 <Myoma> count = length . filter
21:51:05 <joe__> would iI have to code an isResource for every single one?
21:51:13 <Myoma> joe__: What
21:51:14 <joe__> isWood, isWool, isOre, etc
21:51:38 <Myoma> 1) yes
21:51:45 <joe__> damn!  I hate repeating myself
21:51:52 <Myoma> 2) Write isResourceOfKind <String>
21:51:53 <dsrogers> you can use TH to avoid it.
21:52:05 <Myoma> isResourceOfKind "wood" (Wood _) = True
21:52:06 <Myoma> ...
21:52:10 <dsrogers> lol
21:52:13 <Myoma> then count (isResourceOfKind "wood")
21:52:14 <dsrogers> 2) is much easier.
21:52:18 <Myoma> or then count (isResourceOfKind "wool")
21:52:33 <joe__> ahh
21:52:34 <Myoma> You can derive Data.Dynamic too, before thinking about TH
21:52:34 <Twey> joe__: Nah nah
21:52:35 <joe__> that makes sense
21:52:41 <Myoma> but honestly I would not suggest it :/
21:52:42 <joe__> what is TH?
21:52:47 <Myoma> joe___: You could also write
21:52:49 <Myoma> __ = __
21:52:58 <Myoma> count (isResourceOfKind (Wood __))
21:53:00 <Myoma> count (isResourceOfKind Wool)
21:53:03 <Myoma> etc
21:53:30 <joe__> what does a double _ mean
21:53:31 <joe__> __
21:53:49 <mib_33cnhg> well back to studying thanks dsrogers
21:53:50 <Myoma> __ is a variable name
21:53:53 <joe__> ahh
21:53:53 <joe__> ok
21:53:59 <Myoma> you could call it foo or bar or undefined instead
21:54:45 <dsrogers> mib: I tend to think of foldr and foldl as basic loop constructs.  You can also think of them as summarizing functions
21:54:53 <luqui> you mean isResourceOfKind would take a "prototype"?
21:55:00 <dsrogers> mib: you're welcome
21:55:56 <luqui> joe__, the maybe monad is convenient but ugly for this kind of thing
21:56:04 <luqui> oh wait
21:56:24 <luqui> how about: length [ () | Wood _ <- res ]
21:56:36 <Myoma> ah geez
21:56:38 <Myoma> luqui++
21:56:44 <Myoma> I -wish- I thought of this
21:56:46 <joe__> ahh
21:56:49 <joe__> thats a good soluton
21:57:12 <Twey> filter (\ 055508 < Myoma> __ is a variable namex ->
21:57:16 <Twey> 055518 < Myoma> you could call it foo or bar or undefined instead
21:57:23 <Twey> Er, never mind the code there
21:57:27 * Myoma never ever used list comprehensions though :/
21:57:29 <Twey> But what do you mean?
21:57:43 <Twey> '_' is not a variable name, if that's what you meant
21:57:50 <Twey> And you certainly couldn't call it 'undefined'
21:58:10 <Twey> Well... you could, but it would shadow the real undefined
21:58:20 <Twey> _ is special, it means 'discard this variable'
21:58:42 <joe__> luqui: that didn't work
21:58:56 <joe__> <interactive>:1:25:
21:58:56 <joe__>     Couldn't match expected type `t1 -> t'
21:58:56 <joe__>            against inferred type `ResourceCard'
21:58:56 <joe__>     In the expression: Wood 5
21:58:59 <joe__>     In a list comprehension: Wood _ <- [Wood 5, Wood 6]
21:59:01 <joe__>     In the first argument of `length', namely
21:59:04 <joe__>         `[() | Wood _ <- [Wood 5, Wood 6]]'
21:59:10 <joe__> shit, didn't mean to paste all that, sorry
21:59:19 <Myoma> it is not a problem joe__
21:59:42 <Myoma> I think you have to use the ()'s
21:59:53 <Myoma> (Wood _) is a single pattern, I don't know what Wood _ is
21:59:57 <Twey> No
22:00:28 <Twey> It works, because <- takes precedence
22:00:37 <Twey> > length [ () | Just _ <- [Nothing, Just 1] ]
22:00:39 <lambdabot>  1
22:00:58 <joe__> hmm
22:01:19 <haskellian> can i use fork with 1 core?
22:01:28 <dibblego> if a noob asks, "how does purity lead to better composability?", what example would you use?
22:01:29 <Twey> haskellian: Yes
22:02:01 <joe__> oh wait, nevermind
22:02:06 <joe__> I had the wrong variable name
22:02:07 <haskellian> what would be a good exercise to write with a 1-core computer to get a taste of concurrency7parallelism?
22:02:10 <joe__> it works, awesome!
22:02:14 <Twey> Heh, joe__ :)
22:02:14 <joe__> i have no idea why
22:02:16 <joe__> but it does work
22:02:31 <joe__> oh, it makes a list of ()s
22:02:31 <adu> dibblego: show (segFault (pure func))?
22:02:35 <joe__> crazy
22:02:37 <Myoma> I would have them write a (large) real world program in C and another in Haskell
22:02:45 <Myoma> they should understand well by that point
22:02:47 <haskellian> dibblego: it doesnt smear state over the whole program so you can esily take a function out and replace it with another one
22:02:56 <Twey> haskellian: http://en.wikibooks.org/wiki/Haskell/Concurrency -- tiny program
22:03:07 <Myoma> haskellian: You can do this with stateful proceduces though
22:03:25 <haskellian> this what?
22:03:29 <Twey> Erm... recently I wrote an app that copied input from a bunch of connections and gave it to the output
22:03:37 <Twey> That was pretty concurrent
22:04:39 <Twey> You can make just about anything concurrent if you try hard enough :-\
22:05:48 <Myoma> haskellian: "take a function out and replace it with another one"
22:07:14 <adu> Twey: matrix inversion?
22:08:10 <Twey> adu: Probably better done implicitly, but yes :)
22:08:18 <adu> i would love to find a concurrent algorithm for finding the inverse matrix
22:09:25 <adu> i designed a 2-process algorithm, but i don't think thats very noteworthy...
22:09:33 <Myoma> what is the algorithm?
22:10:19 <joe__> :r
22:10:21 <joe__> ack!
22:10:28 <dsrogers> adu: there are some.  I've used them on high-performance clusters before.
22:10:28 <joe__> wrong window
22:10:42 <dsrogers> inverting million element matrices
22:11:34 <mgsloan> yeah, you should be able to do recursive inversion of sub-blocks
22:11:46 <mgsloan> (and so concurrent)
22:12:40 <dsrogers> it's hard to get numerically stable inversion and high concurrancy though
22:12:46 <mgsloan> ah
22:12:55 <mgsloan> yeah I don't know much about the subject
22:13:15 <adu> Myoma: processes A, B start with the entire matrix in memory. You have A rref col-1 below, then pass row-2 to B, B rref col-2 above, A rref col-2 below, then pass row-3 to B, B rref col-3 above, etc...
22:13:47 <Myoma> what's a rref?
22:14:00 <dsrogers> for example, with a gaussian elimination, to be numerically stable you have to chose your pivot point such that you have the least precision cost.
22:14:05 <adu> Myoma: row-reduction (or row reduced echelon form)
22:14:17 <adu> Myoma: aka Gaussian elimination
22:14:27 <dsrogers> that makes it hard to split up because your next step depends on what your last step did.
22:14:59 <dsrogers> with large matrices you can get away with looking for pivots that are "close together" then split up the work.
22:15:18 <dsrogers> and even still sometimes things go arwy
22:15:52 <adu> dsrogers: I never depended on numerical problems, I always did my matrix work with BigFloats
22:16:23 <dsrogers> adu: lol.  Well you're not fast!  Also, space is infinate too, so no problem there either.
22:16:33 <haskellian> myona: yes but not as easily
22:16:59 <dsrogers> adu: but don't put irrationals in your matrix.
22:17:04 <haskellian> does haskell not support erlang-like concurrency? copy-all shared nothing message passing...
22:17:27 <Twey> Not quite so conveniently, haskellian, but yes
22:17:29 <ddarius> Haskell doesn't provide any particular concurrency model.
22:18:09 <dsrogers> adu: but for small matrices that's probably perfect, as long as you put "enough" precision on your irrationals
22:19:14 <glguy> haskellian: GHC has lightweight threads and Control.Concurrent.Chan
22:19:20 <adu> dsrogers: actually I usually use rational matrices to compare my c-gmp code with my mathematica code, and my c code alyways seemed to get worse with bigger matrices, while mathematica seemed to be the same...
22:20:22 <adu> dsrogers: but I just attributed that to a gmp error, cuz I cound't find out where it was in my code...
22:21:10 <adu> i think it was a problem in the conversion of mpq_t to mpf_t or something
22:22:08 <dsrogers> ah, yes.  that would be rather lossy
22:22:21 <dsrogers> Mathematica is extrodinarly good at that sorta thing
22:24:15 <scook0> does anyone know a good synonym for "strict" that doesn't imply (f _|_ = _|_)?
22:24:34 <heatsink> unlifted?
22:24:35 <ddarius> scook0: Then it wouldn't be a synonym.
22:24:39 <adu> scook0: non-lazy?
22:24:53 <scook0> what I mean is I want a synonym for its regular English meaning
22:25:04 <ddarius> scook0: Ah
22:25:04 <luqui> scook0, rigid?
22:25:07 <heatsink> eager
22:25:08 <adu> scook0: severe
22:25:27 <adu> scook0: harsh?
22:25:37 <adu> scook0: unweavering
22:25:37 <dsrogers> scook0: demanding
22:25:38 <luqui> scook0, which regular english meaning?
22:25:45 <ddarius> @wn strict
22:25:45 <scook0> "rigid" sounds pretty good for my purposes
22:25:46 <lambdabot> *** "strict" wn "WordNet (r) 2.0"
22:25:46 <lambdabot> strict
22:25:46 <lambdabot>      adj 1: (of rules) stringently enforced; "hard-and-fast rules" [syn:
22:25:46 <lambdabot>              {hard-and-fast}]
22:25:46 <lambdabot>      2: rigidly accurate; allowing no deviation from a standard;
22:25:48 <lambdabot> [11 @more lines]
22:25:59 <ddarius> stringent is a nice word
22:26:53 <scook0> now that I think about it, what I really want is a word that means "will barf if you give it slightly malformed input"
22:27:10 <mgsloan> sensitive
22:27:42 <glguy> partial :)
22:27:48 <mgsloan> lol
22:28:12 <luqui> scook0, brittle
22:28:24 <adu> oo visual thesaurus is nice
22:28:44 <scook0> hmm, perhaps "exact"
22:29:06 <ddarius> unforgiving
22:30:23 <dsrogers> adu: have you tried using http://www.mpfr.org/
22:30:35 <lambdabot> Title: The MPFR Library
22:30:38 <adu> dsrogers: nope
22:30:42 <dsrogers> adu: it looks like gmp rounding is NQR
22:31:43 <adu> whats NQR?
22:31:47 <Saul> I'm trying to install ghc-6.9.20080614, but it won't work
22:32:32 <Saul> I get an error while make installing suggesting that I rerun configure, but when I do I get the same error
22:32:33 <dsrogers> Not Quite Right (TM)
22:32:55 <dsrogers> Saul: try a different date.
22:32:55 <Saul> Does anyone know how I can fix this?
22:32:57 <adu> hehe
22:33:08 <Saul> dsrogers: I'll try that
22:33:25 <Myoma> Saul: perhaps try 6.9.20080619
22:33:36 <dsrogers> Saul: it's prerelease HEAD, sometimes it's just broken.
22:35:06 <Saul> Myoma: I may be looking at the wrong place, but http://www.haskell.org/ghc/dist/current/dist/ doesn't have a 6.9.20080619
22:35:17 <lambdabot> Title: Index of /ghc/dist/current/dist
22:35:17 <Myoma> oh well
22:35:21 <Myoma> try head
22:35:32 <dsrogers> yeah, it only has that days
22:35:43 <dsrogers> you have to get the repo, and use darcs to sync backwards
22:35:51 <Myoma> Saul: I had lots of trouble with it and I don't know why it finally worked but I have a working version of 6.9.20080619
22:35:55 <dsrogers> or forwards
22:38:31 <adu> dsrogers: omg you're right! gmp/mpf/set_q.c says "But nothing is done about this, since it should be unlikely" lol
22:38:57 <dsrogers> yeah...
22:41:19 <hackage> Uploaded to hackage: control-monad-free 0.2
22:55:20 <luqui> is there any standard module that defines Monad ((,) w)
22:56:00 <dsrogers> anyone know of any portable libraries for setting and retriving FPEs?
22:56:15 <hansfbaier> dons: ping
22:59:22 <dons> hansfbaier: yo
22:59:33 <shachaf> luqui: Not that I know of. It would be nice. :-)
22:59:56 <hansfbaier> dons: I just played around with OpenBSD 4.3 Is the Haskell package so old because of the gcc version?
23:00:02 <shachaf> luqui: It would be nice if Writer was flipped to match, too.
23:00:27 <hansfbaier> dons: (With ghc 6.2 only the oldest version of fastcgi compiles and runs with errors)
23:00:34 <dons> hansfbaier: no, it's just not been updated. talk to Kili. Or, actually, just compile 6.8.2 using 6.6
23:01:32 <luqui> shachaf, I'm just having fun noticing that if it were, a monad I'm making has return = return.return.return.return
23:01:40 <hansfbaier> dons: Do I need to patch the source?
23:05:04 <sjanssen> luqui: isn't that in Control.Monad.Instances?
23:05:16 <dsrogers> is it possible to write a signal handler (using signal) that traps signals and passes them to haskell as exceptions?
23:05:52 <shachaf> sjanssen: A Monad instance for (,)? I thought it only had a Functor instance there.
23:06:34 <luqui> sjanssen, nope :-(
23:07:02 <sjanssen> shachaf: yes, you're right
23:07:29 <sjanssen> seems like an oversight -- is there really a better instance for (,) a?
23:12:25 <luqui> sjanssen, that is the most general valid instance.
23:12:40 <luqui> i.e the first coordinate needs to be a monoid.
23:12:51 <luqui> so might as well require it to be a Monoid (capital M)
23:13:13 <sjanssen> well, I suppose it can be something with mempty, but not mappend
23:13:19 <sjanssen> that isn't terribly useful
23:13:25 <dsrogers> can haskell though fpes?
23:13:28 <luqui> sjanssen, how so, you need an associative mappend for join
23:14:33 <sjanssen> luqui: yes, you're right
23:14:51 <dsrogers> sorry, can haskell /throw/ fpes
23:15:16 <luqui> > 1/0 :: Double
23:15:18 <lambdabot>  Infinity
23:15:46 <luqui> > read "Infinity" :: Double
23:15:48 <lambdabot>  Infinity
23:15:53 <luqui> yay, I thought that didn't work.
23:16:12 <sjanssen> > read "NaN" :: Double
23:16:14 <lambdabot>  NaN
23:16:32 <sjanssen> luqui: ah, the thing is that you can't write those literals directly in source
23:17:32 <dsrogers> is it possible to write a signal handler (using signal) that traps signals and passes them to haskell as exceptions?
23:18:07 <sjanssen> dsrogers: probably
23:18:16 <sjanssen> dsrogers: see throwTo
23:20:31 <dsrogers> sjanssen: If the target thread is currently making a foreign call, then the exception will not be raised (and hence throwTo will not return) until the call has completed.
23:20:54 <sjanssen> dsrogers: hmm, perhaps forkIO the throwTo?
23:21:08 <sjanssen> (is it a problem for signal handlers to linger indefinitely?)
23:22:25 <dsrogers> I don't think I get to choose when thread the signal handler runs in.
23:22:38 <adu> luqui: one thing I can't decide upon is the type of (), should ()::a or ()::()?
23:22:51 <dsrogers> and if I forkIO into a new process, I'm not changing signals in the right place.
23:23:05 <sjanssen> dsrogers: forkIO creates a new Haskell thread
23:23:22 <sjanssen> I believe signals also create a new Haskell thread
23:23:38 <adu> luqui: if ()::a then you can do 1.(2.()) but if ()::(), then 1.(2.()) would be a type error...
23:24:26 <dsrogers> sjanssen: how?  signal is a C call that knows nothing of haskell.
23:26:29 <sjanssen> dsrogers: oh, I thought you wanted to use Haskell's signal handling functions.  Why don't you want to use them?
23:26:45 <dsrogers> I didn't know it had them.
23:27:16 <adu> dsrogers: ya like System.Signal or something
23:27:27 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html
23:27:28 <lambdabot> Title: System.Posix.Signals, http://tinyurl.com/3sprfc
23:27:30 <dsrogers> ahh.
23:27:31 <dsrogers> thanks.
23:27:46 <dsrogers> so, what if I want to handle fpes on windows as well?
23:28:08 <sjanssen> I'm not sure how that works
23:28:52 <dsrogers> eh.
23:29:07 <dsrogers> it's not like I'd ever really compile it on windows anyway
23:30:13 <sjanssen> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals might help
23:30:15 <lambdabot> Title: Commentary/Rts/Signals - GHC - Trac
23:33:48 <dsrogers> thanks
23:34:56 <dsrogers> yikes.  signal handling can happen quite late...
23:35:25 <sjanssen> well, they are asynchronous
23:37:20 <dsrogers> I was thinking of writing an FP monad that would allow graceful handling of FPEs, but I can't really guarantee that the signal will arrive anywhere near the code that produced the exception
23:37:24 <adu> i realize now that my initial type for my typechecker was wrong
23:38:52 <dsrogers> anyways....
23:38:53 <adu> because I need [(Name, Type)] mapping for stuff...
23:38:55 <dsrogers> zzz
23:38:59 <dsrogers> time for sleep
23:39:02 <adu> gnight
23:39:05 <dsrogers> goodnight
23:41:19 <hackage> Uploaded to hackage: control-monad-free 0.3
23:45:15 <name__> whats the correct syntax for this list [forall a. TypeClass a => a]?
23:45:28 <sjanssen> name__: there is no syntax for it
23:45:50 <heatsink> name__: Do you want a list of different objects, where the only thing they have in common is that they are all members of TypeClass a?
23:45:56 <name__> yea
23:45:57 <heatsink> *of differen types
23:46:02 <sjanssen> data WrappedTypeClass = forall a. TypeClass a => WTC a; [WrappedTypeClass]
23:46:09 <TSC> http://www.haskell.org/haskellwiki/Existential_type
23:46:10 <lambdabot> Title: Existential type - HaskellWiki
23:46:13 <name__> im reading http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:46:15 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/0
23:47:16 <name__> what i pasted was listed as an example there
23:47:21 <name__> theres no other way than making a wrapper class?
23:47:54 <sjanssen> name__: wrapper data-type
23:47:57 <name__> er yea
23:48:03 <TSC> Surely that tinyurl is not right
23:48:41 <sjanssen> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:48:43 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
23:48:51 <sjanssen> TSC: funky
23:51:36 <luqui> name__, that is correct.
23:52:12 <luqui> name__, allowing exists x. in the core theory would destroy decidability of something (either checking or inference, don't remember)
23:52:21 <name__> ah
23:52:44 <name__> is it considered bad style to make lists like that to run a function of that type class over it?
23:52:51 <name__> i dunno if im still thinking in terms of OOP too much
23:53:18 <luqui> well, yeah, there is usually a simpler way
23:55:04 <adu> yey, time to test type checker
