00:00:09 <Korollary> It's mostly needed on IRC anyway
00:00:19 <vixey> haha
00:00:52 <koninkje> |Steve|: aha, it's Leibniz equality I was thinking of
00:01:22 <luqui> Korollary, I know what you mean.  But I have something which looks like it might be a "coapplicative cofunctor" or something, so I thought it would be cool to formalize that.
00:01:36 <luqui> so it relates to creating Haskell's famous far-too-abstract-to-understand code
00:01:39 <luqui> as well
00:02:15 <|Steve|> koninkje: Identity of indiscernibles?
00:02:21 <koninkje> yeah
00:02:24 <Cale> rivercheng: If PSQueue didn't exist, using a FingerTree is a cool way to do it. Failing that, you could also use a Data.Map from priorities to lists of values.
00:02:45 <Cale> (which may or may not be acceptable depending on exactly what you want to be fast)
00:04:09 <Pseudonym> Cale: The thing about a PSQueue is that keys and priorities are different.
00:04:20 <Pseudonym> So you've actually got two indices.
00:04:33 <Pseudonym> But you could in theory do it with a Data.Map which also propagated priorities to the root.
00:05:16 <Cale> Pseudonym: right, that Data.Map suggestion doesn't give you a priority search queue, but maybe a reasonable priority queue
00:05:22 <Pseudonym> Yes.
00:05:31 <Pseudonym> You know, I really hate the term "destructor" to refer to a view.
00:05:47 <Cale> Me too.
00:06:01 <Pseudonym> I suggest "nstrcutor".
00:06:06 <Pseudonym> nstructor
00:06:11 <Cale> heh
00:06:20 <Pseudonym> I can't even spell the gag right.  Sigh.
00:06:32 <Pseudonym> "View" is even shorter.
00:06:38 <vixey> oh
00:06:44 <vixey> how do you compile ghc 6.9?
00:07:21 <luqui> Pseudonym, what!  that's too sensical a name.  Isn't there some abstract mathematics we can take a name from?
00:07:36 <Cale> vixey: You wait until the binary for 6.10 is released? At least, that's what I'm doing. :)
00:07:47 <vixey> aww
00:07:51 <vixey> I want it now!
00:07:55 <Philippa> "deconstructor" is somewhat better
00:08:02 <Cale> Well, okay, it should be doable, but if you're getting errors...
00:08:05 <vixey> I try to compile it every few days :/
00:08:09 <Philippa> even makes sense if you view things coalgebraically
00:08:13 <vixey> but I don't know how to fix these things myself
00:08:28 <Cale> Philippa: ah, yes, I agree
00:08:30 <Philippa> I might do a quick search/replace on my slides, in fact - I knew it wasn't the best term, but hey
00:08:53 <Pseudonym> Philippa: I like that, it sounds so postmodern.
00:09:35 <Philippa> mmm. And depending on your view you can deconstruct a type any way you like, too
00:09:50 <Pseudonym> Rather than get data out, you're trying to get at the subtext.
00:10:08 <Pseudonym> By exploring the cultural assumptions and dichotomies inherent in the data stored.
00:11:02 <Pseudonym> That settles it, I want to program in a language called Derrida.
00:12:26 <Pseudonym> This reminds me of the old joke about Kierkegaard, the existentialist programming language.
00:12:44 <Pseudonym> Its semantics weren't defined by fiat, programs could create their own meaning.
00:12:54 <luqui> heh
00:13:04 <luqui> html?
00:17:19 <Pseudonym> Anyway, home time for me.
00:17:20 <Pseudonym> Nytol!
00:24:41 * magthe is now at work
00:26:09 <magthe> Cale: thanks, it's obvious that the double-lift-triple-many line will work
00:28:02 <vixey> http://benfry.com/revisionist/
00:28:03 <lambdabot> Title: revisionist history
00:52:07 <sioraiocht> helloooo
01:04:16 <hml> besides the xmonad/yi source codes; what are good tutorials on dynamically loading haskell modules?
01:04:58 <b\6> if there are distinctive functions used, maybe use google codesearch to find more.
01:05:19 <hml> ii have no idea what functions are used
01:05:27 <hml> i just yhaven't seene it in any of the tutorials i'ved look at
01:05:37 <hml> while the idea of dynamically loading haskell modules seems really really cool
01:05:43 <chr1s> @google dynamic applications from the ground up
01:05:45 <lambdabot> http://gernot-heiser.org/~dons/papers/SC05.html
01:05:45 <lambdabot> Title: Dynamic Applications From the Ground Up
01:05:55 <chr1s> hml: ^^
01:06:16 <Feuerbach> hml: I haven't seen any dynamically loaded modules in xmonad. What do you mean?
01:06:22 <hml> chr1s: thanks
01:06:30 <hml> Fubar^_: n/m; i'm probably wrong about xmonad
01:08:29 <hml> damn; i wish i was at the university of new south wales
01:08:33 <hml> what amazing research these guys do
01:08:45 <quicksilver> xmonad can recompile its config and relaunch itself
01:08:46 <quicksilver> IIRC
01:08:58 <quicksilver> which is a kind of curious take on the whole dynamic loading idea.
01:09:23 <hml> yeah; the amazing thing is that it's pretty fast too
01:09:29 <quicksilver> As far as I know, only ghci, hs-plugins, and yi do real dynamic loading
01:09:30 <hml> and that my windows don't screw up when it's restaring itself
01:13:00 <hml> hmm; is yi's reloading of plugins like xmonad's restart? page 3 seems to imply that; but this is kinda dense to me at th emoment
01:20:45 <vanLiempt> Anyone active to answer what is likely an easy type-related question?
01:21:19 <vixey> if it's easy, ...
01:21:59 <mrd> if someone asked a type question in a channel of lurkers, would it make ghc panic?
01:22:22 <vanLiempt> I have a function which I want to work on negative numbers as well as positive ones, but I can't seem to figure out the right way to make this work.
01:22:34 <vanLiempt> My function, as is, is:
01:22:34 <vanLiempt> erf :: (Floating a, Enum a) => a -> a -> a
01:22:34 <vanLiempt> erf z a = sum [((-1)**a)*(z**(2*a+1))/((fact a)*(2*a + 1))|a <- [0..a]]
01:22:59 <vixey> :/
01:23:07 <vixey> that looks horrible
01:23:13 <vanLiempt> I know
01:23:19 * vanLiempt is not a programmer.
01:23:42 <vixey> have you got it written in a different form?
01:23:49 <vanLiempt> Uh, no.
01:24:07 <vanLiempt> It's just a taylor series expansion of the Error function.
01:24:27 <quicksilver> in what manner does it fail to work on negative numbers?
01:24:35 <quicksilver> did you perhaps want ^^ not ** ?
01:24:46 <quicksilver> and "a" to be Int?
01:25:04 <vanLiempt> I can try that.
01:25:06 <quicksilver> yes, I think you probably do.
01:25:09 <vixey> negative what?
01:25:11 <quicksilver> > -1 ** 3
01:25:14 <lambdabot>  -1.0
01:25:16 <vixey> > [0..10]
01:25:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
01:25:17 <vixey> > [0..-10]
01:25:18 <lambdabot>   Not in scope: `..-'
01:25:21 <quicksilver> > -1 ** (2.999(
01:25:21 <lambdabot> Unbalanced parentheses
01:25:22 <vixey> > [0..(-10)]
01:25:23 <lambdabot>  []
01:25:25 <quicksilver> > -1 ** (2.999)
01:25:26 <lambdabot>  -1.0
01:25:33 <quicksilver> > -1 ** (2.5))
01:25:33 <lambdabot> Unbalanced parentheses
01:25:36 <quicksilver> > -1 ** (2.5)
01:25:37 <lambdabot>  -1.0
01:25:43 <quicksilver> hmm
01:25:52 <quicksilver> > -1 ** (2.1)
01:25:53 <lambdabot>  -1.0
01:25:58 <quicksilver> ah, there you go.
01:26:03 <quicksilver> that's what I'm trying to show.
01:26:13 <quicksilver> ** probably doesn't behave as you expect for negative bases
01:26:17 <quicksilver> > -1 ** 2.0
01:26:18 <lambdabot>  -1.0
01:26:18 <rwbarton> isn't that -(1 ** 2.1)?
01:26:27 <quicksilver> > (-1) ** 2.0
01:26:28 <lambdabot>  1.0
01:26:32 <quicksilver> > (-1) ** 3.0
01:26:33 <lambdabot>  -1.0
01:26:35 <quicksilver> gah
01:26:36 <quicksilver> thanks
01:26:40 <quicksilver> > (-1) ** 2.9
01:26:42 <lambdabot>  NaN
01:26:45 <quicksilver> there you go.
01:26:50 <vanLiempt> >(-2)**10
01:27:01 <quicksilver> failure to produce correct counterexamples.
01:27:04 <vanLiempt> > (-2) ** 10
01:27:06 <lambdabot>  1024.0
01:27:09 <quicksilver> but the point is, ** is not really sane for negative base
01:27:17 <vanLiempt> Oh.
01:27:20 <quicksilver> although it will try hard to work if the exponent is in fact an integer.
01:27:21 <vanLiempt> So ^^ is necessary?
01:27:24 <quicksilver> better to use ^^
01:27:32 <quicksilver> which *requires* that the exponent be integer
01:27:35 <quicksilver> and thus keeps you safe.
01:28:00 <vanLiempt> Oh, well that's no good.
01:28:07 <vanLiempt> Then I'll have my approximation destroyed.
01:28:14 <vanLiempt> What about ^ ?
01:28:27 <quicksilver> why is ^^ not good?
01:28:50 <vanLiempt> If it requires the base be an integer than the approximation isn't valid for all numbers, just integers.
01:28:58 <quicksilver> I didn't say that.
01:29:03 <quicksilver> I requires that the *exponent* be an integer.
01:29:11 <vanLiempt> Oh.
01:29:14 <vanLiempt> Sorry.
01:29:18 <quicksilver> "a" integer, not "z"
01:29:21 <quicksilver> in your expression.
01:29:26 <vanLiempt> Right.
01:29:27 <vanLiempt> My bad.
01:30:22 <vanLiempt> Hmm.
01:30:54 <vanLiempt> It says that there is no instance for (Num (a -> a -> a))
01:31:03 <vanLiempt> When I try to call with a -z
01:31:39 <rwbarton> oh, you need more parentheses
01:31:42 <quicksilver> probably missing some parens
01:32:12 <vanLiempt> Okay.
01:32:33 <rwbarton> Yeah, your original function will work fine on negative z, it's just a little strange to use a floating-point type for a
01:32:33 <vanLiempt> How did you folks know that, so I don't have to bother you again for the same problem?
01:33:22 <rwbarton> experience :)
01:33:32 <vanLiempt> Heh.
01:33:41 <rwbarton> - is a little tricky, it's the only unary operator in haskell/
01:34:20 <quicksilver> rwbarton: worse than strange. rounding errors can break it.
01:34:28 <quicksilver> rwbarton: which is what I was trying to demonstrate, clumsily.
01:37:21 <vanLiempt> Okay, I think I'm a failure at this, because now I'm getting a completely different error telling me I have an ambiguous type variable.
01:37:30 <quicksilver> yes
01:37:36 <quicksilver> because you're using "a" at two types
01:37:39 <quicksilver> Double and Int
01:37:43 <quicksilver> (for simplicity)
01:38:00 <quicksilver> the error is telling you it's trying to find some type "q" for which "Integral q" and "Floating q" both hold.
01:38:02 <vanLiempt> It's telling me Fractional and Integral.
01:38:13 <quicksilver> sorry, Fractional q and Integral q.
01:38:19 <quicksilver> note that Fractional and Integral are not types.
01:38:31 <vanLiempt> Classes?
01:38:36 <quicksilver> right.
01:38:43 <quicksilver> having decided to force a to be Int, which is a good idea
01:38:49 <quicksilver> it will work fine on the RHS of ^^
01:38:59 <quicksilver> but, when you want to combine it with * and / with your Double z
01:39:09 <quicksilver> you will need to sprinkle 'fromIntegral'
01:39:15 <quicksilver> to promote the Int to Double
01:39:29 <vanLiempt> Okay.
01:39:48 <vixey> > 2 ^ 0.5 :: CReal
01:39:49 <lambdabot>  Add a type signature
01:39:52 <vixey> > 2 ** 0.5 :: CReal
01:39:53 <lambdabot>  1.4142135623730950488016887242096980785697
01:40:00 <vixey> > 2 ^^ 0.5 :: CReal
01:40:01 <lambdabot>  Add a type signature
01:40:18 <vixey> > 2 ** 0.5 :: Float
01:40:19 <lambdabot>  1.4142135
01:40:44 <vanLiempt> So it should look something like: sum [(fromIntegral((-1)^^a)*fromIntegral(z^^(2*a+1)))/((fact a)*(2*a + 1))|a <- [0..a]]
01:40:48 <vanLiempt> Right?
01:40:58 <quicksilver> vanLiempt: no, not that bad.
01:40:59 <vixey> :t \a z -> sum [(fromIntegral((-1)^^a)*fromIntegral(z^^(2*a+1)))/((fact a)*(2*a + 1))|a <- [0..a]]
01:41:09 <vanLiempt> Or, no, that's no good.
01:41:16 <quicksilver> z ^^ (2*a+1) is fine
01:41:22 <quicksilver> (2*a+1) will typecheck to Int
01:41:24 <vanLiempt> Okay.
01:41:25 <quicksilver> z as Double
01:41:31 <quicksilver> so z ^^ (2*a+1) as Double
01:41:33 <quicksilver> which is what you want.
01:41:48 <quicksilver> it's the denomitor you need to promote
01:42:04 <vanLiempt> Oh.
01:42:13 <quicksilver> (-1)^^a * z ^^ (2*a+1) / fromIntegral (fact a * (2 * a + 1))
01:42:15 <quicksilver> if I got that right.
01:42:43 <vanLiempt> Hm.
01:43:04 <vanLiempt> It compiles, but it still won't work on negative numbers, giving m the same ambiguous type error.
01:43:37 <vanLiempt> erf :: (Integral a, Fractional a) => a -> a -> a
01:43:38 <vanLiempt> erf z a = sum [(((-1)^^a)*(z^^(2*a+1)))/fromIntegral (fact a * (2*a + 1))|a <- [0..a]]
01:43:42 <vanLiempt> That's what it is now.
01:43:46 <quicksilver> that's not the type you want.
01:43:51 <quicksilver> erf :: Int -> Double -> Double
01:44:14 <quicksilver> (if you want a more general type, you could try (Integral i, Fractional f) => i -> f -> f
01:45:21 <vanLiempt> I just think my function is bad.
01:45:30 <vanLiempt> Every change I make gives me a plethora of errors.
01:45:35 <quicksilver> ;)
01:45:36 <vixey> yeah
01:45:38 <vanLiempt> Maybe I'll try to symplify.
01:45:53 <vixey> vanLiempt: I think you should get it written out in 'math' notation
01:45:58 <quicksilver> that looks OK to me
01:45:58 <vanLiempt> I have that.
01:46:01 <quicksilver> apart from the type signature
01:46:13 <rwbarton> quicksilver: you've got the arguments backwards (or maybe vanLiempt does)
01:46:15 <quicksilver> if you remove the type sig / change ti to what I suggested, what happens?
01:46:23 <quicksilver> ah, thank you rwbarton
01:46:24 <vixey> vanLiempt: That's what I was asking you earler
01:46:26 <vixey> can you paste that?
01:46:27 <quicksilver> Double -> Int -> Double
01:46:34 <quicksilver> that's better.
01:47:08 <vanLiempt> XD
01:47:20 <vanLiempt> Now it works, but gives me NaN on negative numbers.
01:47:27 <vixey> I guess not....
01:47:29 <hml> is there a function : f a b = b a ?
01:47:39 <vixey> @pl flip id
01:47:39 <lambdabot> flip id
01:47:49 <vixey> :t \a b -> b a
01:47:50 <lambdabot> forall t t1. t -> (t -> t1) -> t1
01:47:59 <vixey> no
01:48:06 <rwbarton> @unpl flip id
01:48:06 <lambdabot> (\ b c -> c b)
01:48:27 <vanLiempt> vixey: What is it exactly that you want me to paste?
01:49:05 <vanLiempt> Aha!
01:49:07 <vanLiempt> I got it to work.
01:49:13 <vanLiempt> erf :: (Integral t, Fractional a) => a -> t -> a
01:49:13 <vanLiempt> erf z a = sum [(((-1)^^a)*(z^^(2*a+1)))/fromIntegral (fact a * (2*a + 1))|a <- [0..a]]
01:49:21 <vixey> vanLiempt: this erf thing, but in a clear notation (not haskell)
01:49:28 <vanLiempt> Oh.
01:49:41 <vixey> like how you would write it normally
01:49:46 <vanLiempt> Uh, maybe wiki has the taylor expansion.
01:49:49 * vanLiempt takes a gander.
01:50:13 <vanLiempt> http://upload.wikimedia.org/math/8/6/3/8638d093463eca5ab3fcb22a5f08ee97.png
01:50:14 <lambdabot> http://tinyurl.com/689ddl
01:50:18 <vixey> (You should be able to write this without looking at wikipedia)
01:50:25 <hml> :t flip $
01:50:26 <vanLiempt> I can.
01:50:40 <vanLiempt> I just don't know how to do mathematical notation over the internet.
01:50:58 <rwbarton> vixey: what's so hard to read about it?
01:52:01 <vanLiempt> Note: the 2/pi is gone because I'm doing stuff with it elsewhere.
01:54:19 <hansfbaier> @src($)
01:54:19 <lambdabot> Unknown command, try @list
01:54:25 <hansfbaier> @src ($)
01:54:26 <lambdabot> f $ x = f x
01:54:54 <vanLiempt> Well, thanks quicksilver, rwbarton and vixey.
01:55:00 <vanLiempt> I'm happy I got it work.
01:55:07 <vanLiempt> And sorry for posing such a convoluted problm.
01:55:11 <vanLiempt> Erm, problem.
01:56:27 <vixey> sigma ns f = sum $ map f ns
01:56:27 <vixey> factorial n = product [1..n]
01:56:28 <vixey> erf z r = 2/sqrt pi * sigma [0..r] (\n ->        (-1)^^n * z^^(2*n + 1)
01:56:30 <vixey>                                         ----------------------------------------
01:56:32 <vixey>                                         / ( fromIntegral $ factorial n * (2*n + 1) ))
01:57:12 * vanLiempt blinks.
01:57:33 <opqdonut> :D
01:57:35 <Deewiant> vixey: heh, cute
02:05:32 <quicksilver> vanLiempt: there are some hoops in the numeric type classes :)
02:05:40 <quicksilver> it makes sense, but it takes a while to get used to.
02:06:15 <Baughn> @pl \a b c -> a + b * c
02:06:16 <lambdabot> (. (*)) . (.) . (+)
02:06:25 <Axman6> yuck
02:06:31 <Baughn> Quite.
02:06:49 <Axman6> @unpl (. (*)) . (.) . (+)
02:06:50 <lambdabot> (\ g m d -> g + (m * d))
02:07:00 <Axman6> well, at least it's consistent
02:07:01 <opqdonut> quicksilver: well, arguamly they're not as good as they could
02:07:05 <opqdonut> *arguably
02:08:16 <quicksilver> opqdonut: indeed.
02:08:26 <quicksilver> although this *particular* point is quite accurate.
02:08:42 <quicksilver> the raison d'etre for (^^) is exactly this negative base issue.
02:11:36 <opqdonut> mhmm
02:11:59 <quicksilver> > (-1) ^^ 2.1 :: Double
02:12:00 <lambdabot>  Add a type signature
02:12:17 <quicksilver> > (-1) ** 2.1 :: Double
02:12:18 <lambdabot>  NaN
02:12:23 <quicksilver> > (-1) ** 2.1 :: Complex Double
02:12:24 <lambdabot>  0.9510565162951536 :+ (-0.3090169943749472)
02:12:26 <quicksilver> ;)
02:12:32 <Axman6> heh, nice
02:12:44 <quicksilver> principal logarithm ftw!
02:13:11 * quicksilver pictures #haskell as a manifold shaped like a spiral staircase
02:13:13 <Baughn> > (-1) ^^ 2
02:13:14 <lambdabot>  1.0
02:13:29 <Baughn> > (-1) ^^ 2.7
02:13:30 <lambdabot>  Add a type signature
02:13:40 <Baughn> > (-1) ^^ 2.0 :: Complex Double
02:13:41 <lambdabot>  Add a type signature
02:13:52 <quicksilver> Baughn: ^^ requires integer on the right
02:14:05 <Axman6> :t (^^)
02:14:06 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
02:14:06 <|Steve|> > (-1) ** 2.7
02:14:07 <lambdabot>  NaN
02:14:12 <Baughn> quicksilver: ..I see
02:14:12 <quicksilver> > -1 ^^ 2 :: Complex Double
02:14:13 <lambdabot>  (-1.0) :+ (-0.0)
02:14:21 <|Steve|> :t (:+)
02:14:22 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
02:14:27 <Baughn> @graph (-1) **
02:14:27 <lambdabot> Unknown command, try @list
02:14:29 <|Steve|> Strange.
02:14:35 <Axman6> > (-1) ** 0.5
02:14:36 <lambdabot>  NaN
02:14:39 <quicksilver> |Steve|: which part is strange?
02:14:42 <Axman6> > (-1) ** 0.5 :: Complex Double
02:14:44 <lambdabot>  6.123031769111886e-17 :+ (-1.0)
02:14:47 <|Steve|> :+ is strange.
02:14:49 <Axman6> heh
02:15:07 <quicksilver> |Steve|: a :+ b is "a + ib"
02:15:28 <|Steve|> So I gathered from the type.
02:15:46 <|Steve|> Is it a constructor?
02:15:50 <quicksilver> yes
02:15:52 <|Steve|> Or an operator?
02:15:59 <Deewiant> if it starts with : it's a constructor
02:16:06 <quicksilver> it is *also* an operator.
02:16:06 <|Steve|> Okay, I didn't know that.
02:16:11 <quicksilver> but it is a constructor, yes.
02:16:15 <Deewiant> the same way that if a function is capitalized it's a constructor
02:16:20 <Baughn>  @graph would be useful, though. I think I'll add it
02:16:56 <|Steve|> Can constructors be made infix?
02:17:01 <Axman6> > 1 :+ 0.5
02:17:02 <lambdabot>  1.0 :+ 0.5
02:17:05 <|Steve|> Or rather be made infix by using ` `?
02:17:15 <Baughn> > 4 `Just`
02:17:15 <lambdabot>   parse error on input `}'
02:17:28 <|Steve|> Just isn't binary so I wouldn't expect that to work.
02:17:34 <Baughn> > (4 `Just`)
02:17:35 <lambdabot>  Just 4
02:17:45 <quicksilver> |Steve|: yes, they can.
02:17:47 <rwbarton> ^^ ghc extension
02:17:50 <Baughn> Ah. Yes, though there are additional restrictions for postfix
02:17:54 <|Steve|> ah
02:17:59 <quicksilver> there isn't a convenient named binary constructor to prove it with, though.
02:18:11 <|Steve|> I was trying to think of one, but couldn't.
02:18:26 <quicksilver> data Pair a = Pair a a; example = 1 `Pair` 3
02:18:27 <quicksilver> is fine.
02:18:47 <|Steve|> Interesting.
02:21:04 <quicksilver> however, the standard doesn't permit infix binary *type* constructors with ``
02:21:05 <quicksilver> such as
02:21:13 <quicksilver> Int `Either` String
02:21:23 <quicksilver> GHC permits it with some option or other I think, not sure.
02:21:31 <quicksilver> -XTypeOperators, maybe.
02:23:09 <|Steve|> Why can't ghc's configure script detect gmp?
02:23:40 <|Steve|> oops, wrong channel
02:24:34 <Baughn> |Steve|: Well, not really. Do you actually have gmp /installed/?
02:24:39 <Baughn> Development files as well as library?
02:25:04 <|Steve|> Of course I do. I wouldn't be complaining otherwise.
02:25:19 <|Steve|> It forces me to use --with-gmp-includes and --with-gmp-libraries.
02:25:20 <Baughn> You'd be surprised. Are you on OS X?
02:25:27 <|Steve|> I am, yes.
02:25:38 <Baughn> And gmp happens to be in /sw or /opt, is it?
02:25:45 <|Steve|> You're right, I would be surprised if I made that sort of mistake.
02:25:54 <|Steve|> /opt/local
02:26:01 <Baughn> Right. GHC doesn't check there.
02:26:07 <Baughn> It only checks /usr and /usr/local
02:26:33 <Axman6> |Steve|: using macports helps a lot with those problems
02:26:38 <|Steve|> The it is broken because my CPPFLAGS includes -I/opt/local/include and my LDFLAGS includes /opt/local/lib.
02:27:03 <|Steve|> Axman6: Not really, it doesn't build at all so I'm trying to get to the specific issue so I'm building it by hand.
02:27:08 <|Steve|> s/The/Then/
02:27:10 <quicksilver> I've never known a configure script check CPPFLAGS or LDFLAGS when trying to locate a library.
02:27:20 <quicksilver> they're at a different "level of abstraction"
02:27:25 <Axman6> |Steve|: well, once you've built it by hand once, it works fine ;)
02:28:06 <Baughn> |Steve|: Using --prefix /opt/local might make it configure properly. Then again, it might not.
02:28:06 <|Steve|> quicksilver: LDFLAGS is used by the link tests and  CPPFLAGS and CFLAGS (or CXXFLAGS) is used for header tests.
02:28:17 <|Steve|> If ghc is explicitly setting those, then it is broken.
02:28:19 <Baughn> |Steve|: My solution was to install fink in /usr/local. ;)
02:28:26 <|Steve|> Axman6: No, that's not true.
02:28:31 <|Steve|> Baughn: That's a very bad idea.
02:28:32 <Axman6> works fine here
02:28:37 <Baughn> |Steve|: Why?
02:28:44 <|Steve|> Axman6: Great. Doesn't work for me.
02:28:57 <|Steve|> Oh, sorry, I thought you said /usr. /usr/local is fine.
02:29:29 <|Steve|> There's a trac report about my exact issue. Actually one in MP and one for ghc.
02:29:40 <int-e> |Steve|: you could try working around that with CPATH=/opt/local/include and LIBRARY_PATH=/opt/local/lib ... works for editline at least.
02:30:27 <|Steve|> I've never heard of CPATH or LIBRARY_PATH.
02:30:45 <|Steve|> Do you mean LD_LIBRARY_PATH or whatever the linux environment variable is?
02:31:02 <int-e> no, I meant what I wrote
02:31:02 <Baughn> |Steve|: Just LIBRARY_PATH. Some configure scripts use it.
02:31:05 <Baughn> It's nonstandard, though
02:31:28 <|Steve|> I shouldn't have to use it, what I have set _is_ standard. Any configure script that doesn't honor it is broken.
02:31:34 <int-e> gcc uses it, I stumbled upon it in its info file
02:31:45 <int-e> |Steve|: I agree
02:32:08 <Baughn> |Steve|: I disagree
02:32:18 <|Steve|> At any rate, specifying --with-gmp-* is just a minor annoyance. It's the inability to build that's the real  problem.
02:32:34 <Baughn> Sure, it may force a compiler to compile correctly, but what about other resources? Not headers or code?
02:32:44 <Baughn> |Steve|: ..right. So, what's breaking, again?
02:32:57 <Baughn> |Steve|: Except for your nick and my tab-completion, I mean
02:33:07 <|Steve|> Baughn: I don't know what to tell you, configure scripts should not replace CPPFLAGS,CFLAGS,CXXFLAGS,LDFLAGS,YFLAGS,LFLAGS, etc. It can certainly add to them.
02:33:23 <Baughn> |Steve|: Shouldn't /replace/ them, sure
02:33:29 <int-e> everybody should use pkg-config, so setting PKG_CONFIG_PATH would be enough ;)
02:33:36 <|Steve|> Hmm, this would be easier if everyone were just in #ghc where I've said what my problem is 3 times now.
02:33:38 <Baughn> THat still doesn't mean the gmp test has to succeed
02:33:43 <Baughn> int-e: ..yes please
02:33:45 <|Steve|> Sure, pkg-config would be great.
02:34:53 <int-e> |Steve|: I didn't suggest the CPATH and LIBRARY_PATH things as solutions either, it's just something that might get it to build now.
02:35:58 <|Steve|> Oh, I can get it to find gmp using the configure switches, I can't get ghc to actually build.
02:36:08 <|Steve|> stage1's ghc-inplace can't seem to handle .c files.
02:36:25 <Baughn> |Steve|: DOn't suppose you could paste the actual error?
02:36:29 <|Steve|> http://hackage.haskell.org/trac/ghc/ticket/2380
02:36:30 <lambdabot> Title: #2380 (Adjustor.o crash compiling ghc 6.8.3 on iBook G4 10.4.11) - GHC - Trac
02:36:58 <|Steve|> It doesn't build on my G5, but I believe it built on my powerbook G4.
02:37:14 <Baughn> |Steve|: Hm. The problem is, that could be either ghc-inplace or gcc
02:37:23 <|Steve|> It's ghc-inplace.
02:37:32 <Baughn> Which proceeds to call gcc, so..
02:37:34 <|Steve|> And when I use ghc instead, it compiles just fine.
02:37:49 <Baughn> Suggestive, granted
02:38:24 <|Steve|> It was suggested that I try the line that fails with -v3. I'm building up to the crash now to try that.
02:40:03 <Baughn> |Steve|: Could you attach the crash report from ~/Library/Logs/CrashReporter, too?
02:41:25 <|Steve|> It doesn't contain one except for a 6.6.1 crash from a long time ago.
02:41:39 <Baughn> (A directory I decided I had to mark read-only. Seems to be working, but the poor crash reporter is going out of its mind.)
02:42:05 <|Steve|> Why mark it read-only?
02:42:12 <Baughn> To avoid getting crash logs
02:42:22 <Baughn> They were eating too much disk space. Worse, it made crashes take ten seconds.
02:42:26 <|Steve|> You can turn it off.
02:42:32 <Baughn> Where?
02:42:38 <|Steve|> Oh no, maybe you can't.
02:42:44 <|Steve|> I was thinking Crash Reporter Preferences.
02:42:54 <Baughn> Right. No, that only turns off the dialog
02:46:07 <Armored_Azrael> Hey, does anyone know of a library for managing a set of processes started on remote machines?
02:46:27 <Armored_Azrael> i.e. I'd like to be able to initiate a process on a remote machine over ssh, then kill that process later
02:46:43 <Armored_Azrael> I can write code to do this, but was wondering if someone's already wrapped it up nicely
02:47:08 <Baughn> Armored_Azrael: Sure, mpi
02:47:12 <Axman6> sounds like Erlang to me ;)
02:47:17 <Baughn> And its various management tools
02:47:28 <Baughn> lamd, etc
03:01:10 <Armored_Azrael> I don't need anything nearly as complicated as MPI. No data needs to be passed around, and the host the process is to be started on is very specific.
03:07:38 <Axman6> @src (&&)
03:07:38 <lambdabot> True  && x = x
03:07:38 <lambdabot> False && _ = False
03:07:58 <Axman6> @src (||)
03:07:58 <lambdabot> True  || _ =  True
03:07:58 <lambdabot> False || x =  x
03:11:06 <luqui> what's the LANGUAGE extension that allows arbitrary rank polymorphism
03:11:21 <thoughtpolice> RankNTypes ?
03:11:31 <thoughtpolice> (iirc, at least)
03:12:14 <luqui> ah, types.  I was saying RankNPolymorphism
03:15:01 <mib_unxx8vp0> hello? anyone at home
03:15:10 <mib_unxx8vp0> i need some help with haskell programming
03:15:23 <mib_unxx8vp0> someone recommended me here, they say its a good place to ask for help
03:15:37 <mib_unxx8vp0> everyone away from keyboard?
03:15:40 <nwf> mib_unxx8vp0: Ask away, though I don't promise I'll be able to help.
03:15:44 <mib_unxx8vp0> ok
03:15:47 <mib_unxx8vp0> here is the question
03:16:05 <Axman6> mib_unxx8vp0: first rule of IRC: don't ask to ask, just ask
03:16:19 <nwf> Saying hi is generally appreciated tho'. :)
03:16:29 <mib_unxx8vp0> umm what do you mean by dont ask to ask?
03:16:30 <luqui> and especially don't ask to (ask to ask)
03:16:53 <luqui> meaning don't say 'I have a question, is there anyone here to answer it?' or such things, just ask the question
03:16:54 <nwf> mib_unxx8vp0: "Can somebody help me with a question" is "asking to ask".  You should just give the question.
03:16:54 <Axman6> if you have a question, ask it, don't ask if you can ask a question
03:17:01 <Axman6> anyway, what's the question! :P
03:17:03 <mib_unxx8vp0> sorry my bad
03:17:07 <mib_unxx8vp0> ok, here is the quesiotn
03:17:11 <luqui> second rule of IRC, don't dwell on rules of IRC :-)
03:17:25 <nwf> luqui: There are _rules_ here?
03:17:31 <Axman6> third, get to the point!
03:17:35 <Axman6> sorry
03:17:36 <luqui> lol
03:17:40 <mib_unxx8vp0> create a function that accepts a list of Int, example [1,2,3,4,5] , and then display the number in a new list which are below average.
03:18:01 <luqui> (mmm... smells of homework)
03:18:02 <nwf> This sounds like a homework problem... what kind of guidance do you need?
03:18:03 <Axman6> mib_unxx8vp0: so what've you tried?
03:18:05 <quicksilver> well to start with, do you know how to calculate the average?
03:18:10 <mib_unxx8vp0> yeah
03:18:28 <mib_unxx8vp0> the thing is haskell does not use loop like C++ but it uses recursion
03:18:37 <mib_unxx8vp0> im not really familiar with recursion
03:18:38 <Axman6> mib_unxx8vp0: people won't do your homework for you ;) but they will give guidance
03:18:51 <mib_unxx8vp0> i have the code written, how do i post here?
03:18:59 <therp> mib_unxx8vp0: http://hpaste.org
03:19:00 <mib_unxx8vp0> the code does not work, need someone to check out for me
03:19:02 <nwf> Use pastebin.com or a similar service.
03:19:04 <luqui> this problem needs not recursion :-)
03:19:10 <mib_unxx8vp0> really?
03:19:11 <luqui> (nor folds, just simple list functions)
03:19:12 <nwf> Well, folding is a kind of recursion. :)
03:19:39 <quicksilver> it doesn't need you to use your own recursion, if you re-use library functions.
03:19:43 <therp> luqui: list functions usually hide some kind of folding
03:19:45 <quicksilver> but the library funtions are defined recursively.
03:19:48 <nwf> mib_unxx8vp0: So do you understand how to sum the elements of a list?
03:19:59 <mib_unxx8vp0> sum[1,2,3,4,5] ?
03:20:02 <luqui> therp, yes yes yes... I meant no recursion or folds were *directly* necessary
03:20:04 <quicksilver> given that it's homework there may be limitations on using library functions.
03:20:11 <luqui> ? sum [1,2,3,4,5]
03:20:15 <luqui> > sum [1,2,3,4,5]
03:20:16 <therp> mib_unxx8vp0: well do you understand the source of sum?
03:20:16 <luqui> sry
03:20:18 <therp> @src sum
03:20:18 <lambdabot> sum = foldl (+) 0
03:20:19 <lambdabot>  15
03:20:28 <vixey> [1,2,3,4,5] is just syntax for 1 : 2 : 3 : 4 : 5 : []
03:20:35 <luqui> we have a haskell evaluator in here; if you prefix the line with >, it will evaluate the expression
03:20:49 <vixey> s/:/+/ s/[]/0/ ~> 1 + 2 + 3 + 4 + 5 + 0
03:20:52 <mib_unxx8vp0> > 1+1
03:20:53 <lambdabot>  2
03:20:57 <nwf> mib_unxx8vp0: So you can sum, and presumably you know how to find the number of elements, yes?
03:21:04 <mib_unxx8vp0> lambdabot is not human right?
03:21:12 <Axman6> he is
03:21:14 <luqui> > 89798124 * 4718478724
03:21:16 <lambdabot>  423710537549113776
03:21:19 <luqui> and really really fast at math!
03:21:20 <therp> mib_unxx8vp0: cheap chinese child labor
03:21:21 <mib_unxx8vp0> omg he answer so fast
03:21:35 <Axman6> he's a calculus lecturer
03:21:35 <mib_unxx8vp0> > 1+1+1+1+1+1
03:21:36 <lambdabot>  6
03:21:42 <mib_unxx8vp0> eh he is a bot
03:21:46 <mib_unxx8vp0> not human =D
03:21:49 <mib_unxx8vp0> this is fun
03:21:51 <Axman6> :)
03:22:03 <EvilTerran> ?bot
03:22:04 <lambdabot> :)
03:22:05 <Axman6> anyway, did you paste your stuff on hpaste?
03:22:10 <EvilTerran> ?vixen what do you think of mib_unxx8vp0?
03:22:11 <lambdabot> i don't know, what?
03:22:14 <Axman6> @botsnack
03:22:14 <lambdabot> :)
03:22:16 <nwf> There was a lot of careful work that went into lambdabot's design; it's worth reading about at some point, though not immediately useful.
03:22:30 <EvilTerran> ?vixen I think he likes you
03:22:30 <lambdabot> ever just get the urge to go out and kill a puppy?
03:22:33 <EvilTerran> what
03:22:36 <EvilTerran> ...
03:22:37 <luqui> wow
03:22:55 <Axman6> nwf: tell that to my fellow mac users in #macosx -_- they all whinged when i had it added
03:23:17 <nwf> Wimps.
03:23:19 <mib_unxx8vp0> hi guys, im now in pastebin.com
03:23:28 <mib_unxx8vp0> so I post the code there, what should i do next?
03:23:30 <vixey> hpaste.org is better
03:23:35 <nwf> Send us the url.
03:23:42 <Axman6> paste the url here
03:23:43 <b_jonas> mib_unxx8vp0: tell us the url
03:23:51 <vixey> use hpaste
03:24:01 <vixey> pastebin.com is awful
03:24:03 <nwf> (Ah, the danger of #haskell -- ask for help and you get it.)
03:24:16 <Axman6> nwf: they hated the url announce. one of the best damn features it lambdabot too -_-
03:24:26 <b_jonas> vixey: which is why buubot can move a pastebin.ca or pastebin.com post to erxz_paste
03:24:59 <nwf> Axman6: I've not read the source, come to think of it, and don't know much of its capabilities -- worth doing?
03:25:14 <Axman6> no idea, i haven't :P
03:25:35 <Axman6> http://www.google.com/ for example (i hope...)
03:25:35 <lambdabot> Title: Google
03:25:40 <Axman6> there we go
03:25:55 <nwf> @type filter
03:25:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:25:58 <vixey> that doesn't seem very useful
03:26:06 <b_jonas> mib_unxx8vp0: what's up?
03:26:30 <nwf> Either his code takes a long time to upload, or he got distracted.
03:26:46 <|Steve|> @quote stereo
03:26:46 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
03:26:52 <|Steve|> Bah!
03:27:21 <therp> "don't ask for help on #haskell. it will probably consume the rest of your afternoon."
03:27:34 <mib_unxx8vp0> http://hpaste.org/9460#a2
03:27:39 <mib_unxx8vp0> hey guys, here is the link
03:28:00 <mib_unxx8vp0> belowAverage function
03:28:08 <mib_unxx8vp0> do you guys use winhugs or ghc ?
03:28:17 <mib_unxx8vp0> i use winhugs for this
03:28:28 <Axman6> most people use ghc
03:28:28 <luqui> ghc is quite nice...
03:28:37 <mib_unxx8vp0> so how is the code? >.<
03:28:41 <nwf> mib_unxx8vp0: It almost certainly doesn't matter for the code at hand.
03:28:42 <Axman6> ok, looks like you're not used to using haskell lists
03:29:07 <mib_unxx8vp0> yeah >.< i'm new, need some guidance on list
03:29:14 <Axman6> sumIne [] = 0
03:29:16 <Axman6> sumInt (x:xs) = x + sumInt xs
03:29:18 <Axman6> t*
03:29:19 <nwf> mib_unxx8vp0: sumInt is unnecessary; there's a function called "sum" which does the same thing, more compactly too.
03:29:26 <luqui> > filter even [1,2,3,4,5,6,7,8]
03:29:26 <profmakx> foldl?
03:29:27 <lambdabot>  [2,4,6,8]
03:29:27 <therp> mib_unxx8vp0: the probably is with belowAverage, namely that your list is getting smaller
03:29:30 <|Steve|> You're quite clearly doing his homework for him.
03:29:30 <nwf> @src sum
03:29:30 <lambdabot> sum = foldl (+) 0
03:29:31 <Axman6> would be a more common way of doing it
03:29:36 <profmakx> or sum directyl
03:29:54 <b_jonas> mib_unxx8vp0:: the sumInt function seems to work to me
03:30:02 <therp> mib_unxx8vp0: the problem is with "sumInt a". you are making a shorter on every recursive call, therefore indirectly modifying the average
03:30:05 <luqui> tell me sum isn't implemented that way!
03:30:31 <mib_unxx8vp0> so confusing, so many people talking
03:30:31 <Axman6> luqui: which way?
03:30:34 <b_jonas> mib_unxx8vp0: now as for the belowAverage,
03:30:39 <luqui> foldl (+) 0
03:30:49 <Axman6> what's wrong with that?
03:30:50 <nwf> luqui: What's wrong with that?
03:30:56 <Axman6> jynx
03:30:57 <RayNbow> nonstrict
03:30:58 <Axman6> >_>
03:31:00 <luqui> stack destruction!
03:31:03 <b_jonas> do you think in the recursion, (length a) and (sumInt a) is what you want?
03:31:22 <b_jonas> because a won't be the whole list, just one of the tails of the list
03:31:24 <luqui> but I guess foldl' would be incorrect in the face of, say, lazy naturals
03:31:34 <|Steve|> luqui: stack destruction?
03:31:39 <quicksilver> luqui: foldl gets optimised to foldl'
03:31:45 <quicksilver> luqui: because GHC can see that (+) is strict.
03:31:47 <luqui> quicksilver, oh, that's good to know
03:32:06 <Axman6> luqui: remember: ghc is smarted than you are
03:32:15 <b_jonas> mib_unxx8vp0: also, don't you want >= instead of > ?
03:32:18 <luqui> but only if sum itself is inlined, right?
03:32:19 <b_jonas> but that's the smaller problem
03:32:23 <Axman6> forall NonGHCDevs
03:32:29 <luqui> since (+) isn't always strict
03:32:30 <b_jonas> fix the one with the wrong average first
03:32:44 <RayNbow> luqui, http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sum
03:32:45 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
03:32:58 <b_jonas> (therp was faster)
03:33:30 <therp> b_jonas: but your hint was more correct, as the problem is not just with "sumInt a' but also with 'length a'
03:34:21 <luqui> RayNbow, oh my... so sum isn't correct on infinite lists of lazy naturals!
03:34:49 <|Steve|> How do you make a function strict?
03:35:05 <quicksilver> luqui: it never could be.
03:35:21 <therp> I think mib_unxx8vp0's head has just exploded.
03:35:22 <b_jonas> luqui: on lazy naturals, you wouldn't just sum in one way anyway because on them + is not commutative
03:35:48 <quicksilver> luqui: there's no algorithm which gets sum [Z,Z,Z,Z,Z,Z,....] correct
03:35:49 <quicksilver> after all.
03:35:54 <|Steve|> > sum . iterate $ const 0
03:35:55 <lambdabot>  Couldn't match expected type `[a]'
03:36:12 <|Steve|> > sum $ iterate id 0
03:36:14 <lambdabot>  Tried to use too much memory
03:36:18 <mib_unxx8vp0> hi guys, yeah im a confused with all those stuff you have poured to me
03:36:27 <luqui> quicksilver, sure, but sum [0..] < 10 can be False
03:36:29 <|Steve|> mib_unxx8vp0: Good. Do your own homework.
03:36:40 <mib_unxx8vp0> but i understand something new, which is this sum[1,2,3,4,5] = produces the sum of all the numbers in it ^_^
03:37:03 <|Steve|> > sum [0..] < 10
03:37:05 <b_jonas> quicksilver: meh, sum also fails for plain old (repeat(0::Integer)) as well
03:37:06 <lambdabot>  Tried to use too much memory
03:37:19 <b_jonas> quicksilver: who cares about an infinite list of lazy naturals after that?
03:37:19 <|Steve|> @type repeat
03:37:20 <lambdabot> forall a. a -> [a]
03:37:28 <|Steve|> @src repeat
03:37:28 <lambdabot> repeat x = xs where xs = x : xs
03:37:39 <b_jonas> plus, if you implement lazy naturals, you'd implement sum you way as well
03:38:09 <b_jonas> (like in http://www.willamette.edu/~fruehr/haskell/evolution.html)
03:38:10 <lambdabot> Title: The Evolution of a Haskell Programmer
03:38:40 <therp> mib_unxx8vp0: correct.
03:39:24 <mib_unxx8vp0> i have replaced the sumInt with sum, someone mentioned there is something wrong with length a?
03:39:31 <mib_unxx8vp0> whats the problem with it?
03:39:52 <therp> mib_unxx8vp0: read my initial comment on that carefully
03:39:56 <b_jonas> mib_unxx8vp0: there was no problem with sumInt
03:39:58 <b_jonas> it was correct
03:40:03 <b_jonas> ist still is correct
03:40:27 <b_jonas> the problem is with your belowAverage function
03:40:51 <therp> mib_unxx8vp0: and think of it in the context of belowAverage. the function sumInt itself is correct. you are using it incorrectly (in the context of your problem description at least)
03:41:20 * therp is afk for lunch
03:42:10 <mib_unxx8vp0> so my belowAverage is not correct? to me it looks fine o_o
03:42:20 <therp> mib_unxx8vp0: try to write a function "filterList lst number" that only keeps the numbers of the list lst that are below (or above) 'number'.
03:42:20 <mib_unxx8vp0> but i could not spot it
03:42:37 <b_jonas> mib_unxx8vp0: well, try this test case: belowAverage [1,2,3,4,5]
03:42:39 <b_jonas> what does it give?
03:43:22 <mib_unxx8vp0> b_jonas, it gives [1,2,3,4]
03:43:38 <b_jonas> mib_unxx8vp8: and that's not correct, right?
03:43:52 <Axman6> > 15 / 5
03:43:53 <mib_unxx8vp0> b_jonas, the weird thing is when i input [9,9,1] its output is nothing,null [ ]
03:43:54 <lambdabot>  3.0
03:44:00 <b_jonas> it gives [1,2,3,4,5] to me by the way
03:44:05 <b_jonas> are you sure it gives [1,2,3,4]?
03:44:30 <vixey> belowAverage list = filter (< average list) list
03:45:04 <vixey> average list = sum list / haskellPreludeHasAStupidDefinitionOfLength list
03:45:05 <mib_unxx8vp0> b_jonas, oh yeah, it gives , [1,2,3,4,5]
03:45:06 <|Steve|> > let { b xs = let { l = length xs; s = sum xs } in filter ((s>) .(*l)) xs } in b [1..10]
03:45:07 <lambdabot>  [1,2,3,4,5]
03:45:11 <Axman6> vixey: oi
03:45:36 <ivanm> vixey: why is it stupid?
03:45:40 <vixey> :t length
03:45:41 <lambdabot> forall a. [a] -> Int
03:45:50 <vixey> it should be Integral i => [a] -> i
03:45:54 <RayNbow> :t genericLength
03:45:54 <lambdabot> forall b i. (Num i) => [b] -> i
03:45:58 <ivanm> yeah, I was about to ask you that
03:45:59 <vixey> infact no it should be Num
03:46:04 <ivanm> :o
03:46:11 <b_jonas> mib_unxx8vp0: ok, now consider it like this, if you call belowAverage [1,2,3,4,5], do you think it will eventually do a recursive call to belowAverage [4,5] ?
03:46:13 <ivanm> how can you have a list of length 2.3? :s
03:46:22 <ivanm> or is that to save you doing fromIntegral?
03:46:24 <vixey> ivanm:
03:46:32 <ivanm> vixey:
03:46:37 <vixey> ok
03:46:40 <ivanm> ;-)
03:46:42 <vixey> I was about to show you t
03:46:46 <vixey> something
03:47:01 <|Steve|> Was something wrong with mine? =)
03:47:09 <|Steve|> :t average
03:47:12 * ivanm wonders why take, drop, etc. aren't on Integral rather than just Int
03:47:18 <|Steve|> @type average
03:47:19 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
03:47:36 <b_jonas> vixey: genericLength
03:47:37 <ivanm> @hoogle av
03:47:38 <lambdabot> Data.Traversable :: module
03:47:38 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
03:47:38 <lambdabot> Data.Traversable.Traversable :: class (Functor t, Foldable t) => Traversable t
03:47:42 <ivanm> @hoogle mean
03:47:43 <lambdabot> No matches found
03:47:46 <b_jonas> isn't there one?
03:47:54 <ivanm> there isn't one by default by the looks of things :s
03:48:21 <mib_unxx8vp0> b_jonas, ?
03:48:40 <|Steve|> @pl b xs = let { l = length xs; s = sum xs } in filter ((s>) . (*l)) xs
03:48:40 <lambdabot> (line 1, column 6):
03:48:40 <lambdabot> unexpected "="
03:48:40 <lambdabot> expecting variable, "(", operator or end of input
03:48:51 <|Steve|> @pl \xs -> let { l = length xs; s = sum xs } in filter ((s>) . (*l)) xs
03:48:51 <lambdabot> (line 1, column 12):
03:48:51 <lambdabot> unexpected "{"
03:48:51 <lambdabot> expecting "()", natural, identifier or "in"
03:49:03 <vixey> b_jonas: haskellPreludeHasAStupidDefinitionOfLength
03:49:15 <b_jonas> mib_unxx8vp0: try focusing only on the lines where we address you (your nick) specifically, because we do some other discussion in parallel
03:49:31 <b_jonas> mib_unxx8vp0: your mibbit client should highligh those lines with a differet color I think
03:49:34 <ivanm> @pl \ xs -> let l = length xs; s = sum xs in filter ((s>) . (*l)) xs
03:49:34 <lambdabot> ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum
03:49:45 <mib_unxx8vp0> b_jonas, what do you mean by "do you think it will eventually do a recursive call to belowAverage [4,5] ?"
03:49:46 <|Steve|> Ah, nice.
03:49:48 <Axman6> ivanm: that's very clear...
03:50:13 <b_jonas> mib_unxx8vp0: I meant the case when you call belowAverage [1,2,3,4,5]
03:50:18 <ivanm> Axman6: just fixing up what |Steve| was wanting...
03:50:26 <mib_unxx8vp0> b_jonas, yeah?
03:50:32 <|Steve|> That's really quite absurd. How do you get x repeated anyway?
03:50:35 <mib_unxx8vp0> b_jonas, it displayed everything o_o
03:50:46 <|Steve|> @pl \x -> f x x
03:50:46 <lambdabot> join f
03:50:49 <mib_unxx8vp0> b_jonas, it  should be displaying only 1,2,3
03:50:53 <b_jonas> mib_unxx8vp0: ok, now what should belowAverage [4,5] return according to the description of the task (not the code)
03:51:01 <|Steve|> @pl \x -> x + x
03:51:01 <lambdabot> join (+)
03:51:33 <|Steve|> @pl \x -> f (g x) (h x)
03:51:34 <lambdabot> liftM2 f g h
03:51:46 <|Steve|> @pl \x -> f (g x) x
03:51:47 <lambdabot> f =<< g
03:51:50 <mib_unxx8vp0> b_jonas, it shoudl display 10
03:51:53 <mib_unxx8vp0> i mean 5
03:51:58 <|Steve|> Wow, none of these are at all what I would expect.
03:52:19 <vixey> @src ((->)e)
03:52:19 <lambdabot> Source not found. :(
03:52:21 <vixey> @src ((->)e) return
03:52:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:52:22 <mib_unxx8vp0> b_jonas, 4*2 > 4+5 ------- (2 is the length of the list)
03:52:26 <vixey> @src (->) return
03:52:26 <lambdabot> return = const
03:52:28 <vixey> @src -> return
03:52:28 <lambdabot> Source not found. Just try something else.
03:52:31 <b_jonas> mib_unxx8vp0: well, I meant more like tell in a phrase what belowAverage [4,5] should compute according to the task description (not the code)
03:52:34 <vixey> @src -> >>=
03:52:34 <lambdabot> Source not found. That's something I cannot allow to happen.
03:52:34 <EvilTerran> |Steve|, it's all using the (->) monad
03:52:36 <nwf> What is "@pl" ?
03:52:37 <vixey> @src -> (>>=)
03:52:37 <lambdabot> Source not found. stty: unknown mode: doofus
03:52:39 <b_jonas> mib_unxx8vp0: not just the result
03:52:40 <EvilTerran> er, (e ->) monad
03:52:42 <vixey> @src (->) (>>=)
03:52:43 <lambdabot> f >>= k = \ r -> k (f r) r
03:52:43 <b_jonas> mib_unxx8vp0: but what it means
03:52:47 <vixey> @src (->) return
03:52:47 <lambdabot> return = const
03:53:10 <b_jonas> other people: should we split the discussion to #haskell-overflow?
03:53:55 <mib_unxx8vp0> b_jonas, its sums all numbers from the list, take the first element from the list and multiply with the length, and compare with the sum of the list. if its smaller, than place it into a new list
03:54:19 <b_jonas> mib_unxx8vp0: no, I said, according to the description of the task
03:54:20 <vixey> mib_unxx8vp0: why multiply?
03:54:37 <mib_unxx8vp0> b_jonas, according to description of task? my English is not good
03:55:04 <Axman6> mib_unxx8vp0: what is the task again?
03:55:08 <nwf> mib_unxx8vp0: Your recursive calls are doing "too much work".  You're changing your idea of what "the list average" means as you recurse, so you'll get the wrong answer.
03:55:23 <mib_unxx8vp0> b_jonas, ok,.. umm what do you mean by task?
03:55:25 <b_jonas> mib_unxx8vp0: the task was to get a list of integers as the input, and compute the list of those numbers from the list that are below the average of the list
03:55:41 <b_jonas> mib_unxx8vp0: at least that's what it was if I understood what you said correctly
03:55:43 * EvilTerran spots an opportunity to tie the know
03:55:44 <EvilTerran> *t
03:55:55 * vixey doesn't
03:55:57 <mib_unxx8vp0> b_jonas, yeah
03:56:23 <b_jonas> mib_unxx8vp0: so now, substitute [4,5] in that sentence instead of "the list" but make no other changes
03:56:27 <mib_unxx8vp0> b_jonas, i need recurse to do the looping to check every 1 of the element from the list with the average
03:56:59 <vixey> mib_unxx8vp0: why are you doing multiplication in this?
03:57:05 <Axman6> mib_unxx8vp0: could you explain again what your task is? what are you trying to create
03:57:11 <mib_unxx8vp0> b_jonas, to avoid fractional int
03:57:15 <nwf> mib_unxx8vp0: Mostly; "filter" would hide the recursion for you, if you wanted, but it may be best to see what that means directly.
03:57:25 <b_jonas> mib_unxx8vp0: according to that, if belowAverage worked correctly, it should compute the list of those numbers from [4,5] that are below the average [4,5], is that right?
03:57:32 <mib_unxx8vp0> if i do this, 15/3 = it produces fractional number, so i switch the divide to the other side,
03:58:01 <Axman6> > 15 / fromIntegral 3
03:58:02 <lambdabot>  5.0
03:58:07 <Axman6> > 15 / fromIntegral 7
03:58:08 <lambdabot>  2.142857142857143
03:58:13 <b_jonas> mib_unxx8vp0: now as you've correctly found, your (wrong) implementation of belowInteger is such that belowInteger [1,2,3,4,5] makes a recursive call to belowInteger [4,5]
03:58:16 <vixey> > 15 / 7
03:58:17 <lambdabot>  2.142857142857143
03:58:30 <Axman6> hmm, ok then
03:58:34 <Axman6> :y (/)
03:58:37 <Axman6> :t (/)
03:58:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:58:45 <b_jonas> mib_unxx8vp0: what yuo should understand is why it doesn't make sense to make such a recursive call if the implementation is correct
03:58:58 <vixey> You should not use recursion to write this
03:59:00 <b_jonas> mib_unxx8vp0: and after you understand that, fix the implementation
03:59:01 <Axman6> > 15 :: Int / fromIntegral (7 :: Int)
03:59:01 <lambdabot>  Parse error at "/" (column 11)
03:59:04 <Axman6> pfft
03:59:24 <vixey> :t (/)`on`fromIntegarl
03:59:26 <vixey> :t (/)`on`fromIntegral
03:59:27 <lambdabot> forall b a. (Integral a, Fractional b) => a -> a -> b
03:59:59 * EvilTerran finishes his knot-tied version
04:00:09 <b_jonas> I don't think the division is really such a problem there
04:00:11 <mib_unxx8vp0> b_jonas, now as you've correctly found, your (wrong) implementation of belowInteger is such that belowInteger [1,2,3,4,5] makes a recursive call to belowInteger [4,5]
04:00:16 <EvilTerran> it's not pretty
04:00:19 <EvilTerran> but it's cool
04:00:22 <Shiruka> > 15 `div` 3
04:00:22 <mib_unxx8vp0> it makes recursive tcall to 4, and 5?
04:00:23 <lambdabot>  5
04:00:34 <EvilTerran> because it only makes one traversal
04:00:47 <Axman6> Shiruka: that's only integer division
04:00:50 <b_jonas> mib_unxx8vp0: not 4 and 5 but the list [4,5] as argument to the function
04:00:51 <vixey> > (15 `div` 4) * 4
04:00:52 <lambdabot>  12
04:00:58 <EvilTerran> shall i paste in here, or would that spoil people's fun?
04:00:59 <vixey> > (15 / 4) * 4
04:00:59 <Shiruka> > 15 % 3
04:01:01 <lambdabot>  15.0
04:01:01 <lambdabot>  5%1
04:01:06 <nwf> EvilTerran: I'm curious to see it.
04:01:12 <vixey> paste it here
04:01:27 <Axman6> 5%1? eh?
04:01:42 <|Steve|> mib_unxx8vp0: Just turn in: ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum
04:01:43 <vixey> > 5%1 == 5
04:01:44 <lambdabot>  True
04:01:45 <EvilTerran> sure
04:01:46 <EvilTerran> > let belowMean xs = ys where (ys,total,len) = foldr f ([],0,0) xs; mean = total/len; f x (ys,total,len) = (if x < mean then x:ys else ys, total+x, len+1) in belowMean [3,1,4,1,5,9,2,6,5]
04:01:46 <lambdabot>  [3.0,1.0,1.0,2.0]
04:01:54 <quicksilver> Axman6: Rational syntax.
04:01:55 <|Steve|> mib_unxx8vp0: It does exactly what you want.
04:02:00 <EvilTerran> ?where hpaste
04:02:00 <lambdabot> http://hpaste.org/
04:02:04 <Axman6> EvilTerran: don't do people's homework for them :(
04:02:04 <vixey> ?go why attribute grammars matter
04:02:06 <quicksilver> > 2%3 * 3%5
04:02:06 <lambdabot> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
04:02:06 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
04:02:06 <lambdabot>   add an instance declaration for (Integral (Ratio t))
04:02:22 <EvilTerran> Axman6, i did ask first, and folk said go for it
04:02:28 <Axman6> heh, ok
04:02:31 <EvilTerran> Axman6, regardless, that's a massively overkill solution
04:02:42 <Axman6> indeed
04:02:43 <EvilTerran> the marker would raise some serious eyebrows if a newbie turned that in
04:02:43 <vixey> EvilTerran: check it out if you hadn't seen it
04:02:51 <nwf> I like |Steve|'s better, as far as "doing homework for somebody".
04:02:54 <EvilTerran> vixey, ah, i've seen it
04:03:04 <EvilTerran> it's kinda cool
04:03:23 <|Steve|> nwf: No one will ever suspect. =)
04:03:37 <EvilTerran> makes a lot of sense. it made me understand why some of the academics i know are kinda "zomg i <3 attribute grammars"
04:03:59 <EvilTerran> when, from what we'd been taught in our "compilers" course, they really didn't seem like they were all that
04:04:23 <b_jonas> @unpl ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum
04:04:24 <lambdabot> (((\ ac b c -> filter (\ n -> c > (b * n)) ac) >>= \ v -> length >>= \ u -> return (v u)) >>= \ p -> sum >>= \ o -> return (p o))
04:04:35 <nwf> Oh speaking of attributes, how's the GSoC work on GHC plugins going?
04:04:36 <b_jonas> @type ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum
04:04:36 <lambdabot> [Int] -> [Int]
04:05:05 <|Steve|> > ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) $ [1..10]
04:05:05 <b_jonas> |Steve|: well, it at least has the correct type
04:05:06 <lambdabot>  Couldn't match expected type `[Int] -> Int'
04:05:10 <nwf> ?hoogle ap
04:05:11 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
04:05:11 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
04:05:11 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
04:05:19 <|Steve|> > ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) $ [1..10]::[Int]
04:05:19 <lambdabot>  Couldn't match expected type `[Int] -> Int'
04:05:32 <|Steve|> > ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) [1..10]::[Int]
04:05:33 <lambdabot>  Couldn't match expected type `[a -> b -> Int]'
04:05:37 <|Steve|> > ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) [1..10]
04:05:38 <lambdabot>  Couldn't match expected type `[Int] -> Int'
04:05:40 <|Steve|> I give up.
04:05:44 <|Steve|> What am I doing wrong here?
04:05:57 <EvilTerran> er, apart from massively abusing pointsfree notation, you mean?
04:05:58 <Axman6> you know what, Google need a 'Did you mean: blah. No!' link
04:06:01 <vixey> > (ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum) [1,2,3,4,5,6]
04:06:02 <lambdabot>  [1,2,3]
04:06:18 <|Steve|> EvilTerran: Well, I wrote it in a semisane way and then used @pl.
04:06:24 <vixey> > ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum [1,2,3,4,5,6]
04:06:25 <lambdabot>  [1,2,3]
04:06:26 <EvilTerran> what's the semisane version?
04:06:29 <b_jonas> > (ap (ap (flip . flip (flip . (filter .) . (. (*)) . (.) . (>))) length) sum) [1,2,3,4,5]
04:06:31 <lambdabot>  [1,2]
04:06:46 <EvilTerran> (pm me it if you don't want to give away the ending)
04:06:48 <mib_unxx8vp0> i still don't get it >.<
04:06:48 <|Steve|> > let { b xs = let { l = length xs; s = sum xs } in filter ((s>) .(*l)) xs } in b [1..10]
04:06:49 <lambdabot>  [1,2,3,4,5]
04:06:51 <nwf> :type ap
04:06:56 <EvilTerran> k
04:06:58 <|Steve|> EvilTerran: He's not going to get that anyway.
04:07:00 <Axman6> mib_unxx8vp0: you're not supposed to get that.
04:07:08 <nwf> @type ap
04:07:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:07:11 <Axman6> mib_unxx8vp0: it's supposed to show how much they like pain
04:07:30 <mib_unxx8vp0> sorry axman I dont understand what you are trying to say with pain
04:07:44 <b_jonas> |Steve|: ((s>) .(*l)) is already pled
04:07:45 <Axman6> don't worry
04:07:47 <vixey> :t let average list = sum list / genericLength list ; belowAverage list = filter (< average list) list in belowAverage
04:07:47 <lambdabot> forall a. (Ord a, Fractional a) => [a] -> [a]
04:07:55 <Axman6> anyway, starting from the begining.
04:07:56 <Axman6> nn*
04:08:02 <vixey> > let average list = sum list / genericLength list ; belowAverage list = filter (< average list) list in belowAverage [1,2,3,4,5]
04:08:03 <mib_unxx8vp0> i am still trying to figure out what is b_jonas talking about with [1,2,3,4,5] and [4,5]
04:08:03 <lambdabot>  [1.0,2.0]
04:08:07 <|Steve|> b_jonas: Well, sure. That I did by hand.
04:08:27 <vixey> mib_unxx8vp0:  Don't use recursion for this
04:08:49 <EvilTerran> |Steve|, i like your use of multiplication instead of division. it's too early in the morning here for me to have thought of that :)
04:08:52 <mib_unxx8vp0> vixey, why i could not use recursion here? what problem does it make?
04:08:56 <|Steve|> \x -> s > l * x is what I started with and then I just eta-reduced.
04:08:57 * b_jonas feels he must say (belowaverage =: #~]<+/%#)
04:08:57 <Axman6> mib_unxx8vp0: i think you should write a function that finds the average of a list of numbers before trying to write something more complicated.
04:09:04 <EvilTerran> (-EvilTerran- TIME Fri Aug 08 12:10:55 :P)
04:09:10 <vixey> mib_unxx8vp0:  It doesn't make any sense at all to use recursion here
04:09:14 <EvilTerran> mib_unxx8vp0, i agree with Axman6
04:09:32 <b_jonas> mib_unxx8vp0: you can use recursion
04:09:33 <mib_unxx8vp0> i use recursion just for the looping o_o
04:09:35 <nwf> mib_unxx8vp0: This problem has sub components; you should solve them in turn before trying to do the whole thing.
04:09:36 <mib_unxx8vp0> to loop through all the lements
04:09:43 <b_jonas> mib_unxx8vp0: but the way you use recursion in that implementation is wrong
04:09:51 <vixey> mib_unxx8vp0: And I am saying do not do that
04:09:53 <EvilTerran> mib_unxx8vp0, although i prefer to work top-down rather than bottom-up, so i would tend to postulate the existance of such a function, then write it later
04:09:57 <vixey> mib_unxx8vp0: This is not the way to solve this problem
04:10:02 <b_jonas> someone explain to mib_unxx8vp0 please because I can't
04:10:04 <nwf> Moreover, you should play at the interpreter prompt with some of the builtins.
04:10:04 <EvilTerran> mib_unxx8vp0, feeling overwhelmed by assistance yet?
04:10:11 <Axman6> EvilTerran: stop being confusing! :P
04:10:13 <mib_unxx8vp0> you mena break them down into smaller portion?
04:10:18 <Axman6> mib_unxx8vp0: yes
04:10:23 <EvilTerran> Axman6, i'm just saying how i work! :P
04:10:37 <Axman6> mib_unxx8vp0: so, can you write a function that finds the average of the items in a list?
04:10:43 <mib_unxx8vp0> yeah
04:10:51 <Axman6> k, do that, and show it to us
04:11:03 <nwf> Well, in the past 20+ minutes, we've got one problem, a few amusingly complicated answers, and one very, very confused student.
04:11:05 <EvilTerran> mib_unxx8vp0, btw, how would you define "average"?
04:11:26 <|Steve|> > let { a xs = let { h l s [] = s/l; h l s (x:xs) = h (l+1) (s+x) xs } in h 0 0 xs } in a [1..10]
04:11:27 <lambdabot>  5.5
04:11:31 * EvilTerran blindfolds mib_unxx8vp0 and spins him around on the spot while going round him the other way making "bloop bloop" noises
04:11:33 <|Steve|> What's wrong with using recursion?
04:11:36 * Axman6 takes charge of this problem and shuts you all in a room with some maths text books
04:11:45 <EvilTerran> mib_unxx8vp0, i mean, how would you define "average" in words, not in haskell?
04:11:55 <b_jonas> what Axman6 says, and just use (#~]<+/%#) for god's sake. there's no need for recursion or anything :-)
04:11:58 <vixey> |Steve|: It doesn't make any sense for this problem at all
04:12:04 <EvilTerran> b_jonas, er... is that J?
04:12:09 <b_jonas> EvilTerran: yes
04:12:14 <b_jonas> but I can't bring the bot in
04:12:16 <EvilTerran> nice. still gotta learn that sometime.
04:12:17 <nwf> |Steve|: Nothing, except that mib_unxx8vp0 doesn't quite understand what he's doing with a hammer quite so powerful.
04:12:18 * Axman6 encourages b_jonas to go off and invent K
04:12:20 <b_jonas> I'm not allowed in that channel
04:12:23 <|Steve|> vixey: Why not? My average solution used tail-recursion and took exactly n steps.
04:12:26 <b_jonas> Axman6: there's already a K
04:12:35 <Axman6> T
04:12:35 <vixey> |Steve|: Compare:
04:12:44 <vixey> belowAverage list = filter (< average list) list
04:12:45 <vixey> vs
04:12:51 <vixey> let { a xs = let { h l s [] = s/l; h l s (x:xs) = h (l+1) (s+x) xs } in h 0 0 xs } in a
04:12:51 <EvilTerran> mib_unxx8vp0, are you still alive there? your brain hasn't shorted out yet, i hope?
04:13:10 <Axman6> vixey: that's what i'm aiming at leading mib_unxx8vp0  toward
04:13:10 * nwf had wondered what that burning electronics smell was
04:13:10 <|Steve|> @type average
04:13:11 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
04:13:30 <|Steve|> > average [1..10]
04:13:30 <lambdabot>   Not in scope: `average'
04:13:32 <ivanm> there's no inbuilt ave function
04:13:36 <ivanm> so stop looking for one!
04:13:44 <|Steve|> So what's wrong with mine?
04:13:45 <ivanm> see dons article re averages
04:13:48 <Axman6> |Steve|: we're trying to get mib_unxx8vp0 to make one
04:13:51 <b_jonas> Axman6: it's J with much fewer builtins (which takes a large advantage of J away) and without bounds checking (integers overflow mod 2^32 or 2^64 isntead of promoting to a float so they can say it's faster than J) and with lambdas
04:14:00 <mib_unxx8vp0> abc :: [Int] -> Int           abc a = (sum a)`div`(length a)
04:14:10 <mib_unxx8vp0> to calculate average?
04:14:20 <Axman6> don't use div
04:14:21 <|Steve|> That will do integer division.
04:14:23 <vixey> mib_unxx8vp0: You don't need the ()'s
04:14:29 <mib_unxx8vp0> ok
04:14:30 <Axman6> but you're almost there :)
04:14:36 <vixey> mib_unxx8vp0: and 'abc' is a terrible name for it
04:14:37 <mib_unxx8vp0> so I dont use div?
04:14:43 <Axman6> use / fromIntegral
04:14:47 <EvilTerran> ?type genericLength
04:14:47 <lambdabot> forall b i. (Num i) => [b] -> i
04:14:49 <vixey> mib_unxx8vp0: div is fine
04:14:50 <EvilTerran> that may be useful
04:14:52 <mib_unxx8vp0> umm im trying to reply to you pros as fast as possible
04:14:58 <b_jonas> vixey: oh, don't bother him with the parenthesis while he can't write correct code
04:15:02 <mib_unxx8vp0> so i need to make a name, abc
04:15:03 <b_jonas> but the naming is important
04:15:15 <mib_unxx8vp0> average?
04:15:17 <EvilTerran> should we stop all trying to help mib_unxx8vp0? i imagine it's somewhat overwhelming
04:15:22 <vixey> b_jonas: learning the syntax of a language is quite important
04:15:27 <mib_unxx8vp0> average :: [Int] -> Int            average a = (sum a)`div`(length a)
04:15:28 <b_jonas> vixey: yep, it is
04:15:41 <b_jonas> vixey: but not learning all the precedence rules so you can omit most parens
04:15:47 <EvilTerran> mib_unxx8vp0, are you told you're only working with integers?
04:15:47 <vixey> mib_unxx8vp0: you can write that  average a = sum a`div`length a
04:15:47 <Axman6> mib_unxx8vp0: again, get rid of `div` and use /
04:15:50 <nwf> Perhaps one brave soul should volunteer to take the conversation to PRIVMSG...
04:15:51 <|Steve|> > sum [1..10] `div` length [1..10]
04:15:52 <lambdabot>  5
04:15:52 <vixey> mib_unxx8vp0: the ()'s aren't needed
04:15:58 <|Steve|> vixey: Doesn't look right to me.
04:15:59 <EvilTerran> Axman6, we don't need any division, though
04:16:10 <nwf> (emphasis on one)
04:16:11 <Axman6> EvilTerran: ?
04:16:15 <mib_unxx8vp0> without division, how to find average o_po
04:16:21 <Axman6> exactly
04:16:24 <vixey> |Steve|: It's suitable for filter out everything below the average
04:16:24 <EvilTerran> > let belowMean xs = ys where (ys,total,len) = foldr f ([],0,0) xs; f x (ys,total,len) = (if x*len < total then x:ys else ys, total+x, len+1) in belowMean [3,1,4,1,5,9,2,6,5]
04:16:25 <|Steve|> Axman6: My solution didn't use division.
04:16:26 <lambdabot>  [3,1,4,1,5,2]
04:16:31 <Axman6> :t fromIntegral
04:16:31 <EvilTerran> Axman6, like that
04:16:32 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:16:32 <b_jonas> nwf: I recommended the channel to keep the conversation with mib here and move the rest to #haskell-overflow
04:16:38 <|Steve|> vixey: Not really, it would have filtered out 5.
04:16:47 <vixey> |Steve|: What would have?
04:16:49 <nwf> Fair.
04:16:53 <b_jonas> nwf: I gave up btw, so don't look at me
04:17:14 <b_jonas> EvilTerran: I agree that we don't need division
04:17:16 <mib_unxx8vp0> so guys, what should i do after creating the average function?
04:17:17 <Axman6> yeah, all of you, piss off to #haskell-overflow already!
04:17:17 <|Steve|> Using integer division like that with filter (< average xs).
04:17:19 <Axman6> >_>
04:17:28 <Axman6> mib_unxx8vp0: first, make syre it works
04:17:35 <mib_unxx8vp0> its working for me
04:17:37 <Axman6> sure*
04:17:43 <b_jonas> EvilTerran: the len*elt<sum was ok, except that the code used <= instead of <
04:17:48 <mib_unxx8vp0> give me a list of number, and i tell the output
04:17:56 <mib_unxx8vp0> i test it on my winhugs ^_^
04:18:00 <EvilTerran> ?type (%)
04:18:01 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
04:18:05 <EvilTerran> hmmm
04:18:34 <mib_unxx8vp0> hello?
04:18:37 <EvilTerran> hi!
04:18:37 <Axman6> so average [1,2,3,4,5] gives you 3, and average [1,2,3,4,6] gives you 3.2?
04:18:56 <EvilTerran> > sum [1,2,3,4,6] % length [1,2,3,4,6]
04:18:57 <mib_unxx8vp0> it gives me 3
04:18:57 <lambdabot>  16%5
04:19:00 <EvilTerran> :D
04:19:11 <mib_unxx8vp0> Axman6	, it displays 3 as average
04:19:18 <mib_unxx8vp0> since i am using Int instead of Float
04:19:19 <Axman6> it should be 3.2
04:19:28 <vixey> :t (1%1)%1
04:19:29 <lambdabot> forall t. (Integral (Ratio t), Integral t) => Ratio (Ratio t)
04:19:41 <Axman6> the average of a list of numbers should be a float
04:19:43 <EvilTerran> mib_unxx8vp0, given any item in the list, let's call it "x", you want to keep it if "x <= mean", right?
04:19:49 <EvilTerran> or is that "x < mean"?
04:19:55 <Axman6> EvilTerran: wait
04:20:00 <Axman6> getting too far ahead
04:20:03 <mib_unxx8vp0> i am using this o_o average :: [Int] -> Int
04:20:08 <EvilTerran> Axman6, i'm just asking
04:20:08 <mib_unxx8vp0> and the div
04:20:11 <EvilTerran> for clarity
04:20:17 <mib_unxx8vp0> so I would not get any decimal points
04:20:25 <EvilTerran> i like my problems fully-specified :P
04:20:44 <EvilTerran> also, i still don't like this division :P
04:20:45 <mib_unxx8vp0> umm so who is really guiding me o_o  axman or terran
04:21:19 <Axman6> mib_unxx8vp0: well an average is almost never an int. you should only be returning an Int if the problem has said to use the integer average. but for now, you's say it has, and use the average function you've refined
04:21:28 <b_jonas> mib_unxx8vp0: both, they just can't agree on whether you should use float division or integer multiplication, but they agree you shouldn't do integer division
04:21:47 <Axman6> EvilTerran: not sure how you're going to get the average without division
04:21:53 <EvilTerran> Axman6, you don't need the average
04:21:57 <EvilTerran> :D
04:21:59 <mib_unxx8vp0> thanks b_jonas for the clarification
04:22:23 <mib_unxx8vp0> so if I dont do integer division, then i need to use / << ?
04:22:26 <EvilTerran> "x < mean" is the same as "x < (total/len)", is the same as "x * len < total"
04:22:28 <Axman6> oh no, we've lost dons! :O
04:22:43 <EvilTerran> for positive values of "len", anyway :P
04:23:03 <Axman6> which is great, unless you have a list ][!
04:23:07 <Axman6> :P
04:23:36 <Axman6> anyway, mib_unxx8vp0, let's use your average function
04:23:46 <b_jonas> average [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4]
04:23:53 <EvilTerran> would a colist have negative length?
04:23:53 <Axman6> and forget about EvilTerran, even if he is right, it confuses things
04:23:56 <EvilTerran> :(
04:24:12 <b_jonas> ignore that
04:24:14 * EvilTerran goes to solve his own problems for a change
04:24:25 <EvilTerran> b_jonas, negative length, not negative sum :P
04:24:31 <b_jonas> EvilTerran: there's some guy who manupulates lists of negative length as well as positive length
04:24:32 <EvilTerran> er, vice-versa. never mind.
04:24:42 <b_jonas> EvilTerran: but I couldn't understand what sense it made
04:24:47 <b_jonas> EvilTerran: I can find the link if you want
04:24:51 <mib_unxx8vp0> average [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4] result is 0
04:24:54 <EvilTerran> i'm.... interested
04:24:54 <mib_unxx8vp0> o_o
04:25:10 <b_jonas> mib_unxx8vp0: wrong I think
04:25:10 <Axman6> > sum [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4]
04:25:11 <EvilTerran> mib_unxx8vp0, what's the definition of average you're using currently?
04:25:11 <lambdabot>  16
04:25:19 <Axman6> > length [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4]
04:25:20 <lambdabot>  19
04:25:31 <mib_unxx8vp0> what do you mean by definition of average?
04:25:49 <Axman6> show us how you've written average (again)
04:25:59 <mib_unxx8vp0> average :: [Int] -> Int average a = (sum a)`div`(length a)
04:26:12 <EvilTerran> ah. you're still using integer division
04:26:14 <b_jonas> the average is 0.84210 btw
04:26:27 <Axman6> ok, do you see how if the average is less than the langth, you'll get 0?
04:28:09 <mib_unxx8vp0> yeah 16/19 = 0.8
04:28:12 <b_jonas> btw, you can also use multiplication: (#~+/>#*])
04:28:23 <b_jonas> it's just as short as the float division versoin
04:28:34 <Axman6> average (x:xs) = ave' x 1 where ave' [] total num = total / fromIntegral num;  ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:28:43 <Axman6> that's how it would write it btw
04:29:11 <Axman6> not as clear to begin with, if you're not used to haskell, but clearer than that ap crap ;)
04:29:23 <Axman6> > let average (x:xs) = ave' x 1 where ave' [] total num = total / fromIntegral num;  ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:29:23 <mib_unxx8vp0> what is ap crap?
04:29:23 <lambdabot>  Parse error at end of input
04:29:59 <Axman6> those ap ( ap (.... functions people were using before
04:30:09 <Axman6> anyway, don't worry about that
04:30:29 <idnar> @pl average (x:xs) = ave' x 1 where ave' [] total num = total / fromIntegral num;  ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:30:29 <lambdabot> (line 1, column 51):
04:30:29 <lambdabot> unexpected "="
04:30:29 <lambdabot> expecting variable, "(", operator or end of input
04:30:35 <Axman6> > let average (x:xs) = ave' x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1) in average [1,2,3,4,5]
04:30:36 <lambdabot>   add an instance declaration for (Num [a])
04:30:42 <Axman6> :\
04:30:56 <idnar> @pl \(x:xs) -> let ave' [] total num = total / fromIntegral num;  ave' (y:ys) total num = ave' ys (total+y) (num+1) in ave' x 1
04:30:56 <lambdabot> (line 1, column 21):
04:30:56 <lambdabot> unexpected "["
04:30:56 <lambdabot> expecting pattern or "="
04:31:04 <idnar> heh
04:31:34 <mib_unxx8vp0> so guys, what should i do next after the 16/19 = 0.8 ?
04:31:54 * EvilTerran still wants to do this with multiplication =/
04:31:59 <Axman6> mib_unxx8vp0: do you have a function that will give you that result?
04:32:15 <EvilTerran> the ability to analyse your problem and reduce it to a more algorithmically simple form is very important!
04:32:18 <mib_unxx8vp0> I tried doing it in float but it gives me error on winhugs
04:32:22 <EvilTerran> :P
04:32:31 <Axman6> like, average [16,0,0,0,0,0,0,0,0,0,0,0,0,0,0] = 0.8?
04:32:46 <vixey> beginners shouldn't be given tasks involving IO or numbers
04:32:58 <Axman6> yes they should
04:33:04 <Axman6> well, not IO
04:33:11 <EvilTerran> vixey, i can imagine the "numbers" bit being a bit of an obstacle
04:33:18 <vixey> I don't think so
04:33:29 <vixey> I don't even use numbers in any of the programs I write in Haskell
04:33:56 <EvilTerran> er
04:34:33 <mib_unxx8vp0> to axman6, nope i do not have it  average2 a = fromIntegral(sum a/length a)
04:34:41 <mib_unxx8vp0> i tried that, but doesnot work >.<
04:35:02 <Axman6> no, you need sum a / fromIntegral (length a)
04:35:17 <mib_unxx8vp0> why fromIntegral is place behind sum?
04:35:26 <mib_unxx8vp0> or after sum a
04:35:41 <BeelsebobWork> the fromIntegral needs to convert the integral length to a number
04:35:49 <BeelsebobWork> so that / can work
04:35:56 <Axman6> mib_unxx8vp0: for now, just accept it
04:36:00 <b_jonas> let average s = fst (an s) where { an [x] = (x, 1); an (x : r) = (a + (x - a) / (n + 1), n + 1) where { (a, n) = an r; }; } -- works for fractionals
04:36:03 <mib_unxx8vp0> ok
04:36:15 <Axman6> > et average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:36:15 <lambdabot>  Parse error at "=" (column 19)
04:36:20 <Axman6> > let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:36:20 <lambdabot>  Parse error at end of input
04:36:25 <vixey> Why are the numbers in Haskell not arranged in a lattice?
04:36:28 <b_jonas> > let { average s = fst (an s) where { an [x] = (x, 1); an (x : r) = (a + (x - a) / (n + 1), n + 1) where { (a, n) = an r; }; }; } in average [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4]
04:36:29 <lambdabot>  0.8421052631578949
04:36:39 <Axman6> > let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1) in [1..10]
04:36:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:36:45 <b_jonas> vixey: I don't get all the fuss around lattices
04:36:49 <Axman6> > let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1) in average [1..10]
04:36:50 <lambdabot>  5.5
04:36:54 <Axman6> yay
04:37:05 <Axman6> > let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1) in average [1..1000000]
04:37:06 <lambdabot>  500000.5
04:37:13 <b_jonas> vixey: despite that I had to do a course on lattice theory (granted, it wasn't too serious)
04:37:16 <Axman6> > let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1) in average [1..1000001]
04:37:17 <lambdabot>  500001.0
04:37:30 <vixey> b_jonas: imagine:  (+) :: a -> b -> a /\ b
04:37:53 <Axman6> vixey: create it then
04:37:54 <vixey> It's been obvious this is the right way to deal with numbers since ALGOL
04:37:57 <b_jonas> vixey: how would that work in haskell types?
04:38:01 <vixey> Why has haskell made such a mess of it ?
04:38:23 <b_jonas> vixey: also, wouldn't that necessiate lots of type annotations?
04:38:39 * Axman6 points b_jonas and vixey to #haskell-overflow again
04:38:43 <mib_unxx8vp0> average2 a = sum a / fromIntegral (length a)  >>>> [-1,-18,-17,13,2,-3,-2,14,-4,-4,0,-2,11,-1,9,4,18,-7,4] >>>  0.842105263157895
04:38:47 <vixey> Axman6: Haven't you been following conversiation?
04:38:54 <vixey> Axman6: Maybe you should go there instead of demanding other people do
04:38:55 <b_jonas> Axman6: vixey's not there
04:39:05 <Axman6> mib_unxx8vp0: good :)
04:39:10 <vixey> b_jonas: No I think it should be automatic
04:39:12 <mib_unxx8vp0> so what should I do next?
04:39:38 <b_jonas> vixey: also, I don't see why that's so good in a language like haskell, after all, cpus don't actually do operations on two different type of number
04:39:52 <b_jonas> vixey: except maybe for a few special casees
04:40:01 <Axman6> now, you need a function that will use that average, to find all the elements in the list, which are below the average of the list, right?
04:40:15 <vixey> b_jonas: I'm only thinking about an interface for programmers to use, not what a CPU does
04:40:19 <mib_unxx8vp0> axman6, yeah
04:40:23 <b_jonas> vixey: I'm not saying the haskell numerical tower is completely good, in fact, there are points about it I don't like,
04:40:30 <b_jonas> vixey: but I can't see how yours would work in haskell
04:40:38 <b_jonas> vixey: how would it be implemented with haskell classes?
04:40:39 <Axman6> mib_unxx8vp0: have you been told that you need to use list recursion?
04:41:03 <mib_unxx8vp0> axman6, nope ^_^ ", just exploring the ways i could do this stuff
04:41:11 <Axman6> ok
04:41:29 <vixey> make a lattice of types and encode the meet operation at type level
04:41:43 <Axman6> well, now the easiest answer would be: belowAverage lst = filter (< average list) list
04:41:53 <Axman6> uh, replace list with lst :)
04:42:04 <mib_unxx8vp0> lst is short for list?
04:42:16 <Axman6> it's just a name.
04:42:19 <mib_unxx8vp0> ok
04:42:29 <Axman6> you could call it whatever you wanted. but it represents your list
04:42:40 <mib_unxx8vp0> average2 a = sum a / fromIntegral (length a) >> so my a becomes lst
04:42:50 <EvilTerran> you could express meet using type families, i think
04:42:56 <b_jonas> I shouldn't have started that discussion now
04:43:01 <EvilTerran> although it'd involve a lot of boilerplate
04:43:04 <b_jonas> gotta go afk sorry
04:43:07 <Axman6> yes, when you call average lst, your a is lst
04:43:17 <mib_unxx8vp0> axman6, ok understood
04:43:29 <vixey> what boilerplate?
04:44:41 <Axman6> @let average (x:xs) = ave' xs x 1 where ave' [] total num = total / fromIntegral num; ave' (y:ys) total num = ave' ys (total+y) (num+1)
04:44:42 <lambdabot> Defined.
04:44:51 <Axman6> average [1..892975]
04:44:57 <Axman6> > average [1..892975]
04:45:00 <lambdabot>  Exception: stack overflow
04:45:03 <Axman6> heh
04:45:08 <EvilTerran> vixey, actually, i'm not sure how expressive type families are. i'll have to go check before i can work out how messy it'd be to actually use.
04:45:09 <Axman6> ok, well... whatever
04:45:14 <mib_unxx8vp0> axman6, what are you trying to test/
04:45:27 <Axman6> making sure my average function works
04:45:34 <Axman6> > average [1..100]
04:45:36 <lambdabot>  50.5
04:45:41 <Axman6> > average [0..100]
04:45:42 <lambdabot>  50.0
04:47:01 <mib_unxx8vp0> axman6, what should i do now ^_^
04:47:03 <Axman6> mib_unxx8vp0: so, happy now? learnt more than you were expecting to? got any more questions?
04:47:39 <mib_unxx8vp0> umm how to use the average to compare with the number in the list?
04:47:56 <Axman6> i showed you
04:48:07 <Axman6> you use the filter function
04:48:44 <Axman6> it takes a function that returns True or False, and a list, and returns all the elements in the list when the function is true for
04:48:49 <Axman6> @src filter
04:48:49 <lambdabot> filter _ []     = []
04:48:49 <lambdabot> filter p (x:xs)
04:48:49 <lambdabot>     | p x       = x : filter p xs
04:48:49 <lambdabot>     | otherwise = filter p xs
04:49:25 <EvilTerran> Axman6, might it be easier to use a list comprehension?
04:49:42 <EvilTerran> less higher-order functions flying around causing confusion
04:49:47 <EvilTerran> *fewer
04:49:51 <vixey> how list comprehensions work is more complicated
04:49:52 <Axman6> EvilTerran: to quote my first comp lecturer "NO!" *points at EvilTerran*
04:50:18 <vixey> s, does it matter how they work?
04:50:20 <EvilTerran> i know they're (slightly) more complicated internally, but that's the point of syntactic sugar
04:50:46 <EvilTerran> Axman6, i know a lecturer like that
04:50:56 <Axman6> > (\x -> filter (< average x) x) in [1,2,3,4,5]
04:50:57 <lambdabot>  Parse error at "in" (column 32)
04:50:59 <Axman6> lame
04:51:14 <EvilTerran> actually, he was my first comp lecturer, too - don't suppose you're referring to Richard Bird?
04:51:17 <Axman6> f x = filter (< average x) x in f [1,2,3,4,5]
04:51:21 <Axman6> > f x = filter (< average x) x in f [1,2,3,4,5]
04:51:21 <lambdabot>  Parse error at "=" (column 5)
04:51:33 <mib_unxx8vp0> axman6, use filter?
04:51:33 <Axman6> > let f x = filter (< average x) x in f [1,2,3,4,5]
04:51:35 <lambdabot>  [1.0,2.0]
04:51:49 <mib_unxx8vp0> i have not use filter before
04:51:50 <Axman6> > let f x = filter (< average x) x in f [1,2,3,4,5] :: Int
04:51:50 <lambdabot>  Couldn't match expected type `Int' against inferred type `[t]'
04:51:59 <Axman6> > let f x = filter (< average x) x in f [1,2,3,4,5] :: [Int]
04:52:00 <lambdabot>   add an instance declaration for (Fractional Int)
04:52:00 <lambdabot>     In the expression:
04:52:00 <lambdabot>    ...
04:52:03 <EvilTerran> mib_unxx8vp0, have you used list comprehensions before?
04:52:05 <Axman6> -_-
04:52:19 <mib_unxx8vp0> i know list >> head and tail >.<
04:52:23 <Axman6> EvilTerran: no, referring to Clem Baker-Finch
04:52:33 <EvilTerran> > let f xs = [x | x <- xs, x < average xs] in f [1,2,3,4,5] -- mib_unxx8vp0, does this make any sense to you?
04:52:34 <lambdabot>  [1.0,2.0]
04:52:54 <mib_unxx8vp0> does not make sense to me >.<
04:52:58 <EvilTerran> Axman6, ok. i guess it's just a lecturer-y thing
04:52:59 <ivanm> EvilTerran: would that recompute average xs each time?
04:53:08 <EvilTerran> ivanm, yes, but i'm applying the KISS rule
04:53:13 <EvilTerran> just this once :P
04:53:13 <ivanm> ahhh
04:53:16 <ivanm> lol
04:53:23 <ivanm> mib_unxx8vp0: see how lucky you are? ;-)
04:53:25 <Axman6> EvilTerran: it was when my friend asked "can't we just type cast it?"
04:53:38 <EvilTerran> extracting it to a where clause or whatever would just distract from the point i was trying to make
04:53:41 <mib_unxx8vp0> ivanm lucky?
04:54:01 <Axman6> mib_unxx8vp0: ok, do you want me to explain filter to you?
04:54:07 <mib_unxx8vp0> sure ^_^ "
04:54:24 <Axman6> ok, well filter takes a function (we'll call it f), and a list
04:54:27 <RayNbow> > [x*x | x <- [1..], even x]
04:54:27 <EvilTerran> Axman6, heh, in my case it was because someone in the lecture hall asked if haskell had variable variables as in php
04:54:28 <lambdabot>  [4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,1444,...
04:54:37 <mib_unxx8vp0> i type filter[1,2,3] in winhugs and error pops up
04:54:43 <ivanm> mib_unxx8vp0: that EvilTerran is following the KISS rule for once just for you! :p
04:54:49 <ivanm> @type filter
04:54:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:54:55 <EvilTerran> mib_unxx8vp0, you need to provide a predicate so it knows which elements to filter out
04:54:59 <ivanm> mib_unxx8vp0: filter needs a function as well!!
04:55:04 <mib_unxx8vp0> what is a predicate
04:55:06 <Axman6> then, it runs f on every element in that list. if f returns True when it's run on that element, it's added to the result list, if it's false, it drops it
04:55:13 <EvilTerran> mib_unxx8vp0, a function that returns a boolean
04:55:26 <mib_unxx8vp0> ok
04:55:39 <EvilTerran> "predicate" is a maths-ism
04:55:46 <mib_unxx8vp0> so i need to custom make a function for filter?
04:55:51 <Axman6> no
04:55:55 <EvilTerran> well, kinda
04:55:56 <mib_unxx8vp0> then o_o
04:55:58 <EvilTerran> but it's a very simple one
04:56:07 <EvilTerran> what elements do you want to keep?
04:56:11 <EvilTerran> (in words will do)
04:56:11 <Axman6> you know that a < b gives a boolean result right?
04:56:40 <mib_unxx8vp0> a < b gives boolean?> i dont know
04:56:50 <EvilTerran> ?type 1 < 3
04:56:51 <lambdabot> Bool
04:57:01 <Axman6> the less than function
04:57:01 <RayNbow> > 1 < 3
04:57:03 <EvilTerran> do you see why that makes sense?
04:57:03 <lambdabot>  True
04:57:06 <Axman6> > 1 < 2
04:57:07 <lambdabot>  True
04:57:09 <Axman6> > 1 < 0
04:57:10 <lambdabot>  False
04:57:13 <mib_unxx8vp0> if i type 1<3 or 3>1 its all true
04:57:23 <EvilTerran> so it should be
04:57:28 <EvilTerran> > 1 > 3 -- however
04:57:29 <lambdabot>  False
04:57:31 <mib_unxx8vp0> so where does false comes in?
04:57:34 <EvilTerran> there!
04:57:36 <Axman6> since 1 is less than 3, and 3 is greater than 1
04:57:42 <EvilTerran> -.-
04:57:51 <mib_unxx8vp0> oh ok haha
04:57:54 <mib_unxx8vp0> understood ^_^
04:58:08 * Baughn has flashbacks to the guy who couldn't understand mod. No offense.
04:58:17 <ivanm> Baughn: who's this?
04:58:30 <mib_unxx8vp0> what iss a falshbacks
04:58:43 <Axman6> mib_unxx8vp0: memory of something
04:58:46 <EvilTerran> mib_unxx8vp0, never mind, not relevant
04:58:49 <Baughn> ivanm: Just some guy I ran into while doing undergraduate informatics. He flunked out after three months, naturally.
04:59:07 <mib_unxx8vp0> so.. what does filter got to do with 1> 3 and 1<3
04:59:13 <EvilTerran> ?type filter
04:59:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:59:18 <EvilTerran> ?type (<3)
04:59:19 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
04:59:24 <ivanm> Baughn: ahhh
04:59:27 <Baughn> > filter (<3) [1,2,4,124,4,4,-2,11]
04:59:28 <lambdabot>  [1,2,-2]
04:59:31 <ivanm> I thought you meant someone here ;-)
04:59:33 <EvilTerran> oh look, there's "a -> Bool" in both of those!
04:59:53 <EvilTerran> ?type filter (< (3::Int))
04:59:53 <lambdabot> [Int] -> [Int]
04:59:57 <Baughn> ?type (< 42)
04:59:58 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
05:00:40 * Baughn wonders if there are any Num instances that aren't also instances of Ord
05:00:52 <Baughn> ..oh, of course. Complex.
05:01:11 <Axman6> :t 1 :+ 2
05:01:12 <lambdabot> forall t. (RealFloat t) => Complex t
05:01:41 <Axman6> > (1:+2) < (1:+3)
05:01:42 <lambdabot>   add an instance declaration for (Ord (Complex t))
05:01:42 <lambdabot>     In the expression: (1...
05:01:51 <Axman6> Q.E.D
05:01:52 <Axman6> >_>
05:02:52 <mib_unxx8vp0> o_o ?
05:02:58 <Axman6> don't worry :P
05:03:19 <Axman6> > filter (<5) [1,2,3,4,5,6,7,8,9,10]
05:03:20 <lambdabot>  [1,2,3,4]
05:03:24 <EvilTerran> mib_unxx8vp0, don't worry about it. have some more kool-aid.
05:03:26 <EvilTerran> :P
05:03:29 <Axman6> ok, so mib_unxx8vp0, do you see how that works?
05:03:38 <Axman6> or, at least what it does?
05:03:40 <EvilTerran> (sorry, that was mean. ignore me)
05:03:43 <Baughn> > filter (<5) [1..]
05:03:49 <lambdabot>  [1,2,3,4Exception: Time limit exceeded
05:03:53 <Axman6> heh
05:04:22 <ivanm> EvilTerran: see what following the KISS principle did? it made you mean! :o
05:04:33 <ivanm> from now on, you have to make things as complicated as possible! :p
05:04:38 <EvilTerran> ok
05:05:11 <EvilTerran> hang on, there's got to be a way i can work a zygohistomorphic prepromorphism into this somewhere
05:05:19 <EvilTerran> >:)
05:05:29 <ivanm> heh
05:05:55 <mib_unxx8vp0> hi axman6, i know how the filter works with the list,
05:06:06 <mib_unxx8vp0> thanks, but i do not know how to implement that in the code
05:06:14 <mib_unxx8vp0> filter (< average lst)(belowAverage lst)
05:06:17 <mib_unxx8vp0> o_O
05:06:21 <Axman6> no
05:06:32 <Axman6> you don't need to use recursion here
05:06:40 <EvilTerran> there is no recursion!
05:06:46 <Axman6> filter (< average list) list
05:06:49 <EvilTerran> filter acts on all elements of the list simultaneously!
05:06:50 <ivanm> it's all an illusion!
05:06:52 <EvilTerran> (or might as well)
05:07:00 <mib_unxx8vp0> filter (< average lst)(lst)
05:07:06 <Axman6> yep
05:07:10 <EvilTerran> ding ding ding!
05:07:12 <mib_unxx8vp0> hey thanks, it works now
05:07:16 <Axman6> :)
05:07:40 <mib_unxx8vp0> i learn something new today, about filter woot
05:07:46 <Axman6> indeed
05:07:52 <mib_unxx8vp0> filter is powerful o_o
05:07:55 <Axman6> yep
05:08:06 <EvilTerran> mib_unxx8vp0, just wait 'til you meet foldr
05:08:15 <mib_unxx8vp0> what is foldr?
05:08:23 <mib_unxx8vp0> i seen this somewhere, it has foldr and foldl
05:08:27 <mib_unxx8vp0> right and left?
05:08:28 <Axman6> EvilTerran: would setting the task of making a function that would check if a number was prime be too much of a leap up from here?
05:08:34 <ivanm> it's like a folder, but we took the e out to make it sound less techy :p
05:08:51 <EvilTerran> Axman6, i'd work through a couple of the other things you'd need along the way first
05:08:56 <Axman6> ivanm: stop confusing the poor guy :P
05:09:12 <Axman6> yeah... like, finding the factors of a number?
05:09:13 <mib_unxx8vp0> how do you guys post smiley on the forum?
05:09:27 <ivanm> Axman6: awwwwww.....
05:09:31 <ivanm> mib_unxx8vp0: forum?
05:10:01 <ivanm> Axman6: you mean that _isn't_ what a foldr is? :o
05:10:01 <ivanm> ;-)
05:10:11 <Axman6> pretty sure :P
05:10:15 <Baughn> mib_unxx8vp0: WHat forum?
05:10:20 <mib_unxx8vp0> ivanm, i mean this chatting room
05:10:25 <Baughn> ..chatroom?
05:10:30 <mib_unxx8vp0> how do you guys stick a picture of a smiley in this mibbit
05:10:32 <Baughn> This is a channel, please. ;_;
05:10:37 <ivanm> mib_unxx8vp0: just type them in! ;-), :-), etc.
05:10:38 <mib_unxx8vp0> ok this channel XD
05:10:46 <mib_unxx8vp0> what is the code? o_o
05:10:49 <Axman6> oh, on mibbit it turns : ) into a smily pic
05:10:54 <mib_unxx8vp0> :)
05:10:55 <Axman6> without the space
05:10:57 <mib_unxx8vp0> omg it works :D
05:11:00 <mib_unxx8vp0> wow
05:11:00 <Axman6> heh
05:11:02 <mib_unxx8vp0> this is fun
05:11:07 <ivanm> @go wikipedia emoticons
05:11:08 <lambdabot> http://en.wikipedia.org/wiki/Emoticon
05:11:08 <lambdabot> Title: Emoticon - Wikipedia, the free encyclopedia
05:11:11 <Axman6> mib_unxx8vp0: may i ask how old you are?
05:11:14 <ivanm> mib_unxx8vp0: have a look at that page
05:11:20 <mib_unxx8vp0> below 100 years old :)
05:11:23 <ivanm> Axman6: probably too young for you :p
05:11:49 <chr1s> mib_unxx8vp0: which irc-client are you using?
05:11:56 <mib_unxx8vp0> mibbit
05:12:00 <EvilTerran> -mib_unxx8vp0- VERSION http://www.mibbit.com ajax IRC Client : mibbit
05:12:01 <lambdabot> Title: Mibbit.com Webchat
05:12:07 * EvilTerran hax
05:13:09 <Axman6> l33t!
05:13:20 <mib_unxx8vp0> oh yeah guys, >>> sum a / fromIntegral (length a) >>> BeelsebobWork said the fromIntegral needs to convert the integral length to a number. i still don't understand what he is trying to say
05:13:40 <mib_unxx8vp0> previously i written it as fromIntegral (sum a/ length a)
05:13:46 <mib_unxx8vp0> but it has error message
05:14:02 <ivanm> mib_unxx8vp0: you need the fromIntegral around both the sum and length
05:14:10 <Axman6> > fromIntegral 10
05:14:11 <lambdabot>  10
05:14:15 <Axman6> lame
05:14:16 <ivanm> (fromIntegral (sum a)) / (fromIntegral (length a))
05:14:21 <ivanm> Axman6: what is?
05:14:26 <Axman6> i wanted 10.0 :P
05:14:38 <ivanm> heh
05:14:51 <ivanm> > 1.0 * (fromIntegral 10)
05:14:52 <lambdabot>  10.0
05:14:57 <ivanm> Axman6: happy now?
05:15:07 <Axman6> no :(
05:15:10 <mib_unxx8vp0> what does fromIntegral do?
05:15:19 <mib_unxx8vp0> change it into a float?
05:15:20 <ziman> > liftM2 ((/) `on` fromIntegral) sum length [1..10]
05:15:21 <lambdabot>  5.5
05:15:30 <Axman6> basically
05:15:33 <therp> :t fromIntegral
05:15:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:15:49 <Axman6> ziman: ... i'm impressed, nice :)
05:15:54 <mib_unxx8vp0> Integral does not have decimal point?
05:16:08 * Axman6 feels disabled since he still doesn't get monads -_-
05:16:12 <therp> mib_unxx8vp0: it converts an integral to a "number".
05:16:27 <mib_unxx8vp0> number could be fractional or integral?
05:16:28 <Axman6> mib_unxx8vp0: Integral mean integers. 0,1,2,3...
05:16:47 <mib_unxx8vp0> i read somewhere that Int and Integreal are different
05:17:05 <mib_unxx8vp0> i mean integer and int
05:17:24 <ivanm> Axman6: I thought only about 10-15 people in the world only really "got" monads... ;-)
05:17:44 <ivanm> but anyway: have this disabled parking permit!
05:17:45 <Axman6> ok, thank goodness :P
05:18:02 <Axman6> cheers
05:18:06 <Axman6> if only i had a car...
05:18:10 * Axman6 sticks it on his bike
05:18:11 * ivanm knows monads enough to be able to use do notation and sometimes do >> and >>=
05:18:15 <mib_unxx8vp0> ziman showed monads?
05:18:25 <ivanm> @type liftM2
05:18:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:18:31 <ivanm> he _used_ a monad...
05:18:33 <mib_unxx8vp0> what does monad do?
05:18:37 <therp> mib_unxx8vp0: the only difference is that Int has limited precision. think of it as a 32bit C int
05:18:39 <ivanm> what monad would that have been? identity?
05:18:41 <mib_unxx8vp0> sounds high tech
05:18:46 <ivanm> mib_unxx8vp0: yeah, don't worry about it yet
05:19:04 <mib_unxx8vp0> how do we use monads? where is it commonly use?
05:19:09 <ivanm> it's haskell's way of making sure you never run out of things to blow your mind up with ;-)
05:19:16 <Axman6> mib_unxx8vp0: just forget about monads. they're confusing -_-
05:19:19 <ziman> Axman6, monads aren't very hard; it's just unusual possibilities and semantics that can arise from their usage, something one needs to get used to, i think
05:19:24 <ivanm> mib_unxx8vp0: mainly for I/O stuff (reading, writing files, etc.)
05:19:32 <chr1s> no, monads are really easy. seriously.
05:19:38 <chr1s> (I'm not saying this to brag)
05:19:43 <therp> ivanm: and if one comprehends monads, one can start to look at the category-extras package :)
05:19:44 <ivanm> YAMT? (Yet Another Monad Tutorial) :p
05:19:46 <chr1s> they are like a design pattern
05:19:46 <mib_unxx8vp0> in my previous sample quesiton, a user input a list, so that is monads?
05:19:51 <ivanm> therp: heh
05:20:04 <mib_unxx8vp0> or monads needs a variable o_o
05:20:11 <Axman6> mib_unxx8vp0: well, lists are monads
05:20:13 <ivanm> mib_unxx8vp0: no, it's for when you have a standalone program
05:20:19 <ivanm> Axman6: who said not to confuse him?
05:20:25 <Axman6> but that doesn't explain what monads are
05:21:19 <mib_unxx8vp0> if lists are monads, then why is it difficult to understand o_o
05:21:21 <chr1s> here is a simple explanation of monads:
05:21:24 <chr1s> http://www.cs.uu.nl/wiki/bin/view/Afp/CourseSchedule
05:21:27 <chr1s> (click on Monads)
05:21:32 <chr1s> s/simple/clear
05:21:36 <stulli> for me, monads are space stations :)
05:21:36 <mib_unxx8vp0> thanks for the link cris
05:21:56 <ivanm> mib_unxx8vp0: you can treat lists as monads, but normally you don't
05:22:04 <chr1s> the basic idea behind Monads is this: somebody wrote a "return" function of type a -> [a]
05:22:10 <mib_unxx8vp0> chr1s are you referring to the "monad tutorial link" ?
05:22:44 <mib_unxx8vp0> so how about 1 number/value, is that monads?
05:22:50 <chr1s> and a function ">>=" that was of type [a] -> (a -> [b]) -> [b]
05:23:28 <mib_unxx8vp0> hmm how do i add friends on this mibbit thingy
05:23:32 <chr1s> but you could write the same functions for other datatypes. for example, a function from a -> Maybe a
05:23:35 <mib_unxx8vp0> so i could contact you pros later
05:23:53 <Axman6> mib_unxx8vp0: that's not how IRc works
05:23:55 <Axman6> IRC*
05:24:02 <Axman6> @google IRC
05:24:03 <lambdabot> http://www.mirc.com/
05:24:03 <lambdabot> Title: mIRC: Internet Relay Chat client
05:24:03 <chr1s> so if you generalize over that, you get a Monad.
05:24:04 <mib_unxx8vp0> so how i contact you later?
05:24:09 <Axman6> oh yuck
05:24:22 <mib_unxx8vp0> not like msn messenger?
05:24:24 <ivanm> @go wikipedia irc
05:24:25 <lambdabot> http://en.wikipedia.org/wiki/Internet_Relay_Chat
05:24:25 <lambdabot> Title: Internet Relay Chat - Wikipedia, the free encyclopedia
05:24:25 <Axman6> you just come back to this channel
05:24:25 <Axman6> no
05:24:32 <chr1s> mib_unxx8vp0: just come back to #haskell
05:24:42 <mib_unxx8vp0> so axman6, how do i contact you later, when i close my browser?
05:24:57 <mib_unxx8vp0> #haskell
05:25:06 <Axman6> you open your browser again, go to mibbit, connect to freenode, and join #haskell
05:25:19 <ivanm> same way you came here just now!
05:25:21 <Axman6> exactly the same way you got here ;)
05:25:34 <mib_unxx8vp0> someone posted a link, and i got here, im new to irc
05:25:45 <mib_unxx8vp0> some mention need to install something to connect to this, or use a browser
05:26:01 <Axman6> oh yuck chr1s: "So, are monads scary? Maybe"
05:26:09 <ivanm> *groan*
05:26:15 <mib_unxx8vp0> brb guys ^_^
05:26:26 <Axman6> that's got to be the oldest joke in haskell history -_-
05:26:36 <Axman6> and possibly the worst
05:26:56 <ivanm> oh? you mean they couldn't think of any haskelly jokes until monads got invented? :o
05:27:13 <chr1s> Axman6: lol
05:27:24 <Axman6> of course not!
05:27:46 <ivanm> so all that haskell humour stuff came _after_ monads?
05:27:58 <Axman6> ivanm: some punk kid came along and invented monads and maybe, and ruined the whole language from there on
05:28:47 <Axman6> it was all intellectual and serious before then
05:29:22 <ivanm> "some punk kid" == Wadler?
05:29:42 <Axman6> surew
05:30:15 <Axman6> anyway, enough haskell for now. bbl
05:34:37 <ivanm> Axman6: here we are, an older joke! http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00124.html
05:34:38 <lambdabot> Title: [rabin-dan: Announcing C.A.T.S.U.P :-)]
05:34:41 <ivanm> hah!
05:54:31 <sioraiocht> hellooooo
05:54:35 <sioraiocht> anyone listening to the anglohaskell stream
05:55:25 <Axman6> ivanm: i should've know it would have something to do with dons
05:55:33 <ivanm> heh
05:55:38 <ivanm> nah, he's just mirrored it
05:57:50 <Axman6> "Please don't tell Paul Hudak that I'm spending his grant money this
05:57:51 <Axman6> way.  "
05:57:58 <Axman6> best joke in the thing :P
05:59:56 * b_jonas scans the backlog to see how far the mibbit guy got
06:00:21 <b_jonas> by the way, did you try to ask him to choose a /nick so we recognize him next time he (or she) comes back?
06:01:28 <mib_unxx8vp0> hi guys
06:01:52 <mib_unxx8vp0> whats the difference between 	(fromIntegral (sum a)) / (fromIntegral (length a)) and 	(fromIntegral (sum a) / (length a))
06:01:55 <ivanm> b_jonas: not sure if we had to...
06:02:14 <ivanm> mib_unxx8vp0: the second won't work because (length a) is an integer, and you can't divide by an integer
06:02:48 <mib_unxx8vp0> can we divide by float?
06:02:51 <Botje> yes
06:02:53 <mib_unxx8vp0> int divided by float?
06:02:54 <Botje> but not by integers
06:03:00 <Botje> that's why you need the fromintegral
06:03:10 <mib_unxx8vp0> 1/2.0 ?
06:03:29 <Axman6> yes
06:03:29 <mib_unxx8vp0> Main> :t fromIntegral >>>>>>>>>> fromIntegral :: (Integral a, Num b) => a -> b
06:03:36 <b_jonas> so you went into how to generalize the list comprehension to a do statement with fail?
06:03:36 <mib_unxx8vp0> Num b means ?
06:04:02 <mib_unxx8vp0> oh yeah, guys, how do i change my nickname?
06:04:11 <mib_unxx8vp0> mib is the default name on mibbits
06:04:11 <ivanm> mib_unxx8vp0: /nick <new_nick>
06:04:12 <Axman6> /nick nickname
06:04:30 <iamamy> o_o
06:04:33 <iamamy> wow change ^_^
06:04:47 <iamamy> Ayuismyname
06:04:50 <sbahra> Haskell rocks.
06:04:55 <Ayuismyname> o_o
06:05:18 * sbahra finally acquired a decent book
06:05:20 <kpreid> Ayuismyname: Num b => means that in the type expression following, b must be a numeric type
06:05:20 <Axman6> sbahra: well yes... but why do you say so?
06:05:46 <jeffz`> sioraiocht: I'm listening, it's nice and clear
06:07:03 <sbahra> Axman6, well, several straight-forward things. For me, I really like the fact that the specification process is completely functional.
06:07:41 <sbahra> Axman6, this makes it easier for me to spot bugs and it should allow for other things later on which are much more difficult in a language like C, formal verification in specific.
06:07:55 <sbahra> Axman6, Haskell programs translate very cleanly to TLA.
06:08:02 <Axman6> TLA?
06:08:07 <sbahra> Temporal Logic of Actions
06:08:11 <ivanm> Axman6: Three Letter Acronym
06:08:12 <ivanm> :p
06:08:16 <sbahra> ivanm, haha
06:09:23 * sbahra goes back to his book
06:13:49 <Axman6> ok, is there a nice function that'll work like say fold[r|l] where i can go over a list, return a bool if one of the elements returns true for a given function?
06:13:54 <Axman6> immediately that is
06:14:19 <Botje> head . filter ?
06:14:22 <Axman6> @hoogle (a -> Bool) -> [a] -> Bool
06:14:23 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
06:14:23 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
06:14:23 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
06:14:35 <Ayuismyname> thanks kpreid ^_^
06:14:36 <Botje> heh, any is good too
06:14:45 <Axman6> @src any
06:14:45 <lambdabot> any p =  or . map p
06:14:52 <Axman6> hmm
06:14:55 <Axman6> not efficient enough
06:15:01 <Axman6> or, maybe it is
06:15:10 <chr1s> Axman6: because of lazyness, or will only evaluate its first component.
06:15:17 <Axman6> yeah
06:15:35 <chr1s> > any (>1) [1..]
06:15:40 <lambdabot>  True
06:16:06 <Ayuismyname> > any (>2) [1..]
06:16:07 <lambdabot>  True
06:16:12 <Ayuismyname> o_o
06:16:16 <Botje> > any (> 1) [0,0,1,undefined]
06:16:17 <lambdabot>  Exception: Prelude.undefined
06:16:20 <Ayuismyname> > any (>1) [2..]
06:16:21 <lambdabot>  True
06:16:22 <Botje> > any (> 1) [0,0,1,2,undefined]
06:16:23 <lambdabot>  True
06:16:27 <Botje> see, lazy :
06:17:03 <Ayuismyname> lazy?
06:17:18 <Ayuismyname> > any (>2)[1]
06:17:19 <lambdabot>  False
06:17:26 <Ayuismyname> aha i got it false =D
06:17:36 <Ayuismyname> > any (>2)[1,2]
06:17:37 <lambdabot>  False
06:17:44 <Axman6> > let prime n = or . map (n `rem`) (2:[3,5..(n `div` 2)]) in prime 13
06:17:45 <lambdabot>   add an instance declaration for (Integral [Bool])
06:17:47 <Ayuismyname> it only checks the first o_o?
06:17:50 <Ayuismyname> > any (>2)[1,2,3]
06:17:52 <lambdabot>  True
06:18:07 <Axman6> whoops
06:18:34 <Axman6> > prime n = or . map (\x -> n `rem` x == 0) (2:[3,5..(n `div` 2)]) in 13
06:18:34 <lambdabot>  Parse error at "=" (column 9)
06:18:44 <Axman6> > let prime n = or . map (\x -> n `rem` x == 0) (2:[3,5..(n `div` 2)]) in prime 13
06:18:45 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
06:18:47 <Ayuismyname> > any (>4)[3...]
06:18:47 <lambdabot>  Parse error at "]" (column 14)
06:19:02 <Ayuismyname> > any (>4)[3..]
06:19:03 <lambdabot>  True
06:19:20 <Ayuismyname> any (>4)[3..]  = why is this true?
06:19:29 <Axman6> Ayuismyname: you get what [1..] means right?
06:19:34 <Axman6> > [1..]
06:19:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:19:40 <Ayuismyname> ok
06:19:43 <Axman6> > [1..10]
06:19:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:19:48 <Ayuismyname> but 3 is smaller than 4
06:19:55 <Ayuismyname> shouldnt that be false?
06:19:58 <Botje> > take 3 [3..]
06:19:58 <Axman6> no
06:19:59 <lambdabot>  [3,4,5]
06:20:07 <Botje> > any (>4) [3,4,5]
06:20:08 <lambdabot>  True
06:20:09 <quicksilver> [3..] is not 3
06:20:13 <quicksilver> [3..] is a list of numbers
06:20:17 <Axman6> it's
06:20:17 <quicksilver> 3,4,5,6,7,8,9 and so on
06:20:21 <Axman6> > [3..]
06:20:22 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
06:20:26 <Ayuismyname> ok
06:20:38 <idnar> > any (>4)[3]
06:20:39 <Ayuismyname> so false + true + true?
06:20:40 <lambdabot>  False
06:20:48 <quicksilver> no.
06:20:54 <Ayuismyname> the first number (3) is false, but, 4 and 5, and 6 is true
06:21:04 <quicksilver> "are any of these bigger than 3 : 3 , 4 , 5, 6"
06:21:06 <quicksilver> the answer is yes.
06:21:17 <quicksilver> that's what "Any" means, after all.
06:21:37 <Ayuismyname> thanks quicksilver, you are good at teaching newbies =D
06:21:45 <quicksilver> you're welcome.
06:22:21 <Ayuismyname> (>4)[1..]
06:22:24 <Ayuismyname> > (>4)[1..]
06:22:25 <lambdabot>   add an instance declaration for (Num [t])
06:22:37 <Ayuismyname> what does it mean by add an instance delcaration
06:22:43 <Axman6> don't worry
06:22:48 <quicksilver> well, what it really means is what you wrote didn't make sense
06:22:52 <Axman6> basically, it means you're doing something wrong ;)
06:22:55 <quicksilver> (>4) is a function you apply to numbers.
06:23:01 <quicksilver> you tried to apply it to a list
06:23:03 <quicksilver> > (>4) 1
06:23:05 <lambdabot>  False
06:23:34 <Axman6> > let let prime n = not . or $ map (\x -> n `rem` x == 0) (2:[3,5..((n `div` 2)+1)]) in prime 162849
06:23:34 <lambdabot>  Parse error at "let" (column 5)
06:23:40 <Axman6> > let prime n = not . or $ map (\x -> n `rem` x == 0) (2:[3,5..((n `div` 2)+1)]) in prime 162849
06:23:41 <lambdabot>  False
06:23:59 * Axman6 should use a known prime there
06:24:00 <Ayuismyname> quicksilver, why i cant apply to a list but to a single number it works?
06:24:01 <Matthias_B> (>4) means  \x -> x >4 so it's a function taking one parameter
06:24:49 <Axman6> Ayuismyname: does it make sense to say "is this list [a,b,c] greater than 7"?
06:24:50 <quicksilver> Ayuismyname: because.
06:24:56 <Matthias_B> :t (>)
06:24:56 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:24:58 <quicksilver> Ayuismyname: because haskell is a typed language.
06:25:03 <Axman6> they're different things, how can you compare them?
06:25:06 <quicksilver> functions have to be applied to the right type.
06:25:18 <quicksilver> you can't compare apples and oranges.
06:25:59 <ivanm> sure you can... I prefer the juice of oranges to the juice of apples!
06:26:48 <Axman6> ivanm: ah, but you're comparing juice!
06:26:52 <Axman6> they are the same thing :)
06:27:00 <ivanm> > sortBy (on compare juice)
06:27:01 <lambdabot>   Not in scope: `juice'
06:27:02 <Matthias_B> (>) can be applied to anything for which an order is defined (that's about what (Ord a) => ... means). This is defined for numbers but not for lists.
06:27:04 <ivanm> ;-)
06:27:45 <Botje> @instances Ord
06:27:45 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:28:00 * Botje points out the [a] and runs
06:28:03 <quicksilver> Matthias_B: that's not really true.
06:28:08 <quicksilver> or the point here.
06:28:11 <ivanm> aren't the different tuples instances as well?
06:28:13 <Matthias_B> oops
06:28:15 <Matthias_B> sorry
06:28:16 <dino-> > Data.List.any (> 4) [3, 1, 8, 2]
06:28:17 <lambdabot>  True
06:28:18 <ivanm> Botje: why run?
06:28:18 <quicksilver> both numbers and lists are ordered.
06:28:22 <Axman6> > [1,2,3] > [1,2]
06:28:23 <lambdabot>  True
06:28:25 <quicksilver> the point is you can't compare a number to a list.
06:28:26 <Axman6> :o
06:28:33 <Axman6> how handeh
06:28:33 <quicksilver> that's what I meant by apples and oranges.
06:28:35 <Botje> ivanm: lambdaNinjas are hunting me :)
06:28:40 <ivanm> heh
06:28:45 <dino-> > map (> 4) [3, 1, 8, 2]
06:28:46 <lambdabot>  [False,False,True,False]
06:28:50 <quicksilver> Botje: there's really no point running then.
06:28:57 <quicksilver> Botje: you're done for.
06:29:13 <BeelsebobWork> how is Ord on [a] defined
06:29:13 <Ayuismyname> wow map
06:29:20 <BeelsebobWork> is it compare `on` length?
06:29:24 <Ayuismyname> > map(<4)[1..]
06:29:24 <Axman6> Ayuismyname: yes, you should learn about map
06:29:26 <lambdabot>  [True,True,True,False,False,False,False,False,False,False,False,False,False,...
06:29:37 <Botje> BeelsebobWork: uh, i think it compares elements one by one
06:29:44 <ski> BeelsebobWork : lexicographic ordering
06:29:44 <Axman6> > map (*3) [1..10]
06:29:45 <lambdabot>  [3,6,9,12,15,18,21,24,27,30]
06:29:52 <quicksilver> BeelsebobWork: the way you'd expect on strings.
06:29:53 <Ayuismyname> so if i want to use something like (>4)[list of numbers], then i need to think of a phrase before (>4)
06:30:00 <Botje> > [1,2,3,4] `compare` [1,2,3,5]
06:30:01 <lambdabot>  LT
06:30:01 <quicksilver> BeelsebobWork: and that same way, on other things too :)
06:30:03 <BeelsebobWork> ah, okay, so it's Ord a => Ord [a]
06:30:05 <ski> > sort [[0,2,1],[0,1,2],[0,1]]
06:30:05 <BeelsebobWork> not Ord [a]
06:30:06 <lambdabot>  [[0,1],[0,1,2],[0,2,1]]
06:30:10 <quicksilver> indeed.
06:30:27 <quicksilver> LB's instances command should arguably show contexts.
06:30:30 <quicksilver> twould be useful.
06:30:38 <BeelsebobWork> yep
06:30:48 <Matthias_B> A I see, lists are compared lexicographically so to say?
06:31:01 <ski> @instances MonadState
06:31:01 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
06:31:23 <Matthias_B> oh, haven't read ski's answer
06:31:23 <BeelsebobWork> Matthias_B: "ski: BeelsebobWork : lexicographic ordering [15:29]"
06:31:28 <BeelsebobWork> heh
06:31:35 <ski> hm, `s (ContT r m)' looks like an application ..
06:31:46 <ski> and so does 'Maybe a' above, of course
06:31:49 <BeelsebobWork> also, there are too many people who's name start with M, Ma, Mat, Matt and Matth here
06:32:02 <BeelsebobWork> tab completion fail
06:32:04 <ski> i'd say this is ambiguous presentation
06:32:26 <Axman6> Ayuismyname: so you get what map does?
06:32:37 <Botje> MonadState s (...) means "we encapsulate state with type s in ... somewhere"
06:32:40 <Ayuismyname> Axman6, not really
06:32:54 <Ayuismyname> >map[1,2,3]
06:32:57 <Ayuismyname> o_o
06:33:16 <BeelsebobWork> Ayuismyname: map is simple -- it applies a function to every element in a list
06:33:18 <Ayuismyname> >map(>1)[1,2,3]
06:33:23 <BeelsebobWork> > map (+1) [1,2,3]
06:33:25 <lambdabot>  [2,3,4]
06:33:26 <ski> > map (> 1) [1,2,3]
06:33:27 <lambdabot>  [False,True,True]
06:33:33 <dino-> :t map
06:33:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:34:02 <BeelsebobWork> > map ($ 1) [(2+),(3+),(4+)]
06:34:03 <lambdabot>  [3,4,5]
06:34:08 <BeelsebobWork> > map ($ 1) [(2+),(3-),(4+)]
06:34:09 <lambdabot>  [3,2,5]
06:34:21 <Axman6> Ayuismyname: it takes a function and a list, and applies that function to all the elements of the list
06:34:29 <dino-> Oh right, map is functor here
06:34:30 <ski> BeelsebobWork : maybe you could huffman-encode the nicks ?
06:34:39 <dino-> map takes functors here, I should say
06:34:45 <ski> @type P.map
06:34:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:34:53 <ski> dino- : that's Caleskell
06:34:58 <dino-> Ah, Prelude is P here
06:35:00 <dino-> :)
06:35:10 <BeelsebobWork> ski: hehe, I'm not so sure people would be too chuffed
06:35:27 <ski> BeelsebobWork : oh, i just meant locally
06:35:28 <dino-> I like that, .. (Functor f) => ... version of map
06:35:41 <Toxaris> dino-: fmap doesn't take functors, fmap takes types which haven gone through a functor
06:35:58 <Toxaris> dino-: Functors are Maybe, [], IO, ...
06:36:04 * ski takes a sandwich to eat
06:36:12 <Toxaris> dino-: but fmap takes Maybe a, [a], IO a for some a
06:36:44 <Axman6> @src P.map
06:36:45 <lambdabot> Source not found. My pet ferret can type better than you!
06:36:49 <Axman6> @src map
06:36:49 <lambdabot> map _ []     = []
06:36:49 <lambdabot> map f (x:xs) = f x : map f xs
06:36:59 <Toxaris> comment missing here
06:37:13 <dino-> Toxaris: I'll have to think about that.. gone through a functor
06:37:24 <Toxaris> dino-: well, a functor has been applied to them
06:37:34 <Toxaris> dino-: but I don't know how to form the relative clause
06:37:40 * Botje sticks a functor on Toxaris 
06:37:48 <Axman6> oh my
06:38:02 <Toxaris> fmap takes types which a functor has been applied to
06:38:09 <Toxaris> but I think "which" is wrong here
06:38:26 <Toxaris> "to whom a functor has been applied"?
06:38:32 * Toxaris doesn't know english
06:38:51 <Botje> "instantiated functors"?
06:38:56 <Botje> "filled-in functors" ?
06:39:42 <Axman6> > reverse [1..]
06:39:44 <lambdabot>  Tried to use too much memory
06:40:43 <idnar> heh
06:41:03 <idnar> Toxaris: s/to whom/to which/ ?
06:41:26 <Toxaris> idnar: sounds reasonable
06:41:31 <idnar> Toxaris: you probably want "that" instead of "which", but the dangling preposition is still an issue
06:41:38 <idnar> Toxaris: if you use "which" in that position, you need a comma directly before it
06:42:23 <Toxaris> hmm. probably I want that, because I want to designate a subset of "types"
06:42:31 <idnar> (hooray english)
06:42:39 <idnar> (we should all use lojban)
06:42:56 <Toxaris> so is it "types to that have been applied" then? sounds awkward for me
06:43:16 <idnar> Toxaris: no, uhm
06:43:31 <idnar> "types, which a functor has been applied to" (extremely awkward, and has a dangling preposition)
06:43:46 <idnar> "types that a functor has been applied to" (reasonable, but still has a dangling preposition)
06:43:46 <Axman6> > reverse . reverse [1..]
06:43:47 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
06:43:53 <Axman6> > reverse $ reverse [1..]
06:43:55 <lambdabot>  Tried to use too much memory
06:44:12 <Axman6> lame, i thought that it would turn that into id :(
06:44:12 <idnar> "types to which a functor has been applied" (probably more correct, but slightly more awkward)
06:44:25 <Axman6> i beliieve GHC does, or you can tell it to at least
06:44:35 <BeelsebobWork> Axman6: reverse is 100% scrict
06:44:37 <idnar> I don't think you can say "to that"
06:44:49 <Axman6> BeelsebobWork: meaning...
06:45:14 <Toxaris> Axman6: reverse . reverse /= id, as you have discovered, so I would expect ghc not to substitute one by the other
06:45:33 <BeelsebobWork> meaning that the result will be fully computed at the point you get any output at all
06:45:39 <Axman6> Toxaris: how is it not id?
06:46:04 <idnar> hmm, actually
06:46:06 <BeelsebobWork> Axman6: becaues reverse $ reverse [1..] /= id [1..]
06:46:07 <Axman6> BeelsebobWork: so the first reverse has to finish before the second ones does?
06:46:11 <quicksilver> well reverse (reverse [1..]) is not [1..]
06:46:13 <idnar> I'm wrong about the comma
06:46:24 <BeelsebobWork> Axman6: the first reverse must fully compute it's result before it tells the outer one *anything* at all
06:46:31 <Axman6> ok
06:46:34 <idnar> you wouldn't use one in this case, because the clause "which a functor has been applied to" is required to identify "types"
06:46:55 <Axman6> > reverse . reverse == id
06:46:56 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))
06:46:56 <lambdabot>     In the expression: re...
06:47:05 <Axman6> lame
06:47:10 <BeelsebobWork> @check reverse . reverse == id
06:47:11 <lambdabot>   Not in scope: `myquickcheck''
06:47:13 <Axman6> @q test...
06:47:13 <Toxaris> idnar: so which without comma is like that?
06:47:13 <lambdabot> Maybe you meant: quit quote . ? @ v
06:47:21 <BeelsebobWork> lame
06:47:21 <quicksilver> you can put a comma if you like
06:47:23 <Axman6> @c
06:47:23 <lambdabot> Maybe you meant: check choice-add choose clear-messages compose . ? @ rc v
06:47:27 <quicksilver> it depends on teh rest of the sentence
06:47:36 <idnar> Toxaris: well, nothing is set in stone in English
06:47:38 <quicksilver> "the red car, in which I have so often travelled, was parked outside the house"
06:47:39 <Axman6> @check reverse . reverse == id
06:47:39 <lambdabot>   Not in scope: `myquickcheck''
06:47:46 <Toxaris> idnar: yeah, approximately, of course :)
06:47:47 <Axman6> :\
06:47:48 <quicksilver> it's perfectly valid to have a comma.
06:48:08 <quicksilver> Axman6: of course, going the other way is a safe optimisation.
06:48:13 <idnar> Toxaris: but generally you use a comma when the clause is not essential to identifying the... noun? my linguistics terminology is lacking
06:48:18 <quicksilver> it's always safe to replace "id" with "reverse . reverse"
06:48:18 <idnar> for example, consider these two sentences
06:48:19 <quicksilver> ;)
06:48:35 <Toxaris> quicksilver: depends on context, doesn't it. consider that I ask you "where is the red car", but we have previously spoken about two different red cars
06:48:44 <idnar> "My car which has a red bumper sticker was in an accident today."
06:48:49 <Axman6> id 1 = error "Oh noes, i only know lists!"
06:48:50 <idnar> "My car, which has a red bumper sticker, was in an accident today."
06:48:51 <Axman6> >_>
06:49:02 <quicksilver> Axman6: GHC RULES are only ever applied if the type matches.
06:49:03 <idnar> the former suggests that I have more than one car, but that I'm referring specifically to the one with a red bumper sticker
06:49:14 <Axman6> heh, ok
06:49:19 <idnar> the latter suggests that I have only one car, but for whatever reason I want to mention the fact that it has a red bumper sticker
06:50:21 <Toxaris> idnar: and isn't that the same rule for which vs. that: that can only be used for clauses which identify the noun
06:50:27 <Axman6> i was reading this: http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance and i was wondering, with the "treeMap f (treeMap g t) = treeMap (f . g) t" bit, would that also work for treeMap f (treeMap g (treeMap h t))?
06:50:28 <lambdabot> Title: Map fusion: Making Haskell 225% faster, http://tinyurl.com/2fyynu
06:50:30 <Ayuismyname> thanks BeelsebobWork
06:50:46 <Toxaris> idnar: with the additional rule that which is more formal then that, so in papers, you have to always use which :(
06:50:56 <luqui> idnar, for the former i would use 'that', because it is a dependent clause
06:51:08 <luqui> idnar, whereas 'which' indicates an independent clause
06:51:19 <ski> Axman6 : yes
06:51:32 <Axman6> oh yeah, of course it would. heh
06:51:33 <idnar> Toxaris: yes, I believe "that" is only to be used with a restrictive clause
06:51:46 <idnar> or dependent clause, as luqui called it
06:51:58 <Axman6> treeMap f (treeMap g (treeMap h t)) would become treeMap ((f . g) . h) t
06:52:01 <Toxaris> Axman6: I would assume treeMap f (treeMap g (treeMap h t)) ~> treeMap f (treeMap (g . h) t) ~> treeMap (f . (g . h)) t
06:53:00 <BeelsebobWork> Axman6: I've just added infinite data structure generation and bottom generation to checkers thanks to you :)
06:53:16 * Axman6 feels honoured
06:53:26 <Axman6> BeelsebobWork: say what now? :P
06:54:10 <luqui> what is checkers anyway?
06:54:13 <ski> hm .. how to make a `reverse' such that e.g. `reverse (_|_:_|_:_|_) = _|_:_|_:_|_' ?
06:54:41 <luqui> nevermind, read the cabal page :-)
06:54:57 <ski> (for finite lists, it should work the same as the standard `reverse', obviously)
06:55:12 <Axman6> what's _|_ ?
06:55:24 <ski> the bottom of all types
06:55:34 <Axman6> ah, right
06:55:40 * jeffwheeler just now understood why it's that symbol.
06:55:41 <ski> say `undefined' if you prefer
06:56:01 <Axman6> that's not bottom then?
06:56:16 <ski> `undefined' is a bottom, yes
06:56:21 * Axman6 things lambdabot should've been called bottom
06:56:34 <Axman6> referred to as tom
06:56:42 <ski> Axman6 : edwardk had a lambdabot clone called bottom for a while
06:56:52 <Axman6> heh, excellent
06:57:03 <luqui> ski, is reverse (_|_:_|_:_|_) = _|_:_|_:_|_.  I think the answer is no
06:57:10 <quicksilver> ski: I don't think you can do that, no.
06:57:17 <ivanm> ski: was the clone made by that same crazy S. Korean guy that cloned the dog for that lady?
06:57:31 <ski> luqui : the excerice was to define a `reverse' such that that holds
06:57:41 <luqui> ski, and what is the other constraint?
06:58:08 <ski> ivanm : not unless edwark was that same crazy S. Korean guy
06:58:13 <luqui> that it actually reverses all defined lists?
06:58:23 <ivanm> heh
06:58:26 <ski> <ski> (for finite lists, it should work the same as the standard `reverse', obviously)
06:58:32 <luqui> oh ok
06:58:46 * luqui tries
06:58:55 <jeffwheeler> @src reverse
06:58:55 <lambdabot> reverse = foldl (flip (:)) []
06:58:57 <ski> quicksilver : i'm not sure .. that's why i'm asking
06:59:17 <ski> hmm
07:00:37 <quicksilver> ski: the thing is, [1,2,...] is a refinement of _|_:_|_:_|_
07:00:52 <quicksilver> ski: so 'reverse' should produce at least two cons cells on it.
07:00:57 <ski> yes
07:01:03 <quicksilver> if it is to be continous
07:01:07 <quicksilver> and hence definable in haskell.
07:01:25 <quicksilver> s/hence/whence/ I suppose :)
07:01:54 <luqui> got it
07:01:56 <ski> > let [] `blue` _ = []; (_:xs) `blue` ~(y:ys) = y : (xs `blue` ys); reverse' xs = xs `blue` reverse xs in reverse' [0,1,2]
07:01:57 <lambdabot>  [2,1,0]
07:01:59 <ski> > let [] `blue` _ = []; (_:xs) `blue` ~(y:ys) = y : (xs `blue` ys); reverse' xs = xs `blue` reverse xs in length . take 2 $ reverse' (0:1:2:undefined)
07:02:00 <lambdabot>  2
07:02:07 <luqui> reverse' l = let len = length l in [ l !! (len-n-1) | (n,_) <- zip [0..] l ]
07:02:11 <ski> > let [] `blue` _ = []; (_:xs) `blue` ~(y:ys) = y : (xs `blue` ys); reverse' xs = xs `blue` reverse xs in length . take 3 $ reverse' (0:1:2:undefined)  -- of course
07:02:13 <lambdabot>  3
07:02:17 <ski> > let [] `blue` _ = []; (_:xs) `blue` ~(y:ys) = y : (xs `blue` ys); reverse' xs = xs `blue` reverse xs in length . take 4 $ reverse' (0:1:2:undefined)
07:02:18 <lambdabot>  Exception: Prelude.undefined
07:02:28 <ski> how about that ?
07:02:36 <luqui> mine is simpler :-)
07:03:03 <quicksilver> luqui: but yours doesn't work.
07:03:12 <gwern> out of curiosity, could someone benchmark 'import Data.List; main = print $ (map head . group . sort) $ take  1000000000 $ cycle [1]'
07:03:14 <luqui> quicksilver, doesn't it?
07:03:17 <gwern> for me?
07:03:20 <quicksilver> luqui: length diverges on _|_:_|_:_|_
07:03:27 <luqui> quicksilver, but I don't need length
07:03:35 <luqui> except to evaluate the elems themselves
07:03:38 <ski> luqui : `length' on a list with some undefined tail is undefined
07:03:39 <luqui> the spine doesn't need it
07:03:55 <luqui> (that's that zip incantation at the end)
07:04:00 <quicksilver> oh, I see your point
07:04:53 * Axman6 quite likes something xs = something $ last xs : init xs
07:05:12 <Axman6> > let something xs = something $ last xs : init xs in [1..10]
07:05:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:05:16 <chrisdone> is there a clever way to stop people using `get' inside a state monad? my library exports "sql" and "query", where sql takes a StateT IO action and I only want query to be able to access the state. should I just have an Sql monad?
07:05:16 <Axman6> damn
07:05:22 <Axman6> that wasn't supposed to work!
07:05:39 * luqui wonders why that works
07:05:50 <luqui> that should diverge!
07:05:55 <Axman6> yeah, i'm confused!
07:05:59 <quicksilver> chrisdone: don't make the fact it is StateT IO visible
07:05:59 <Heffalump> chrisdone: just wrap the State monad in an abstract type of your own
07:06:03 <chrisdone> oh, ctually I could wrap it in a type
07:06:05 <chrisdone> Heffalump: yeah
07:06:08 <quicksilver> chrisdone: make it an abstract type.
07:06:16 <chrisdone> thanks guys, I'll do that
07:06:26 <luqui> oh we're dumb, Axman6
07:06:34 <Axman6> mm?
07:06:34 <luqui> > let something xs = something $ last xs : init xs in something [1..10]
07:06:37 <lambdabot>  Tried to use too much memory
07:06:59 <luqui> "hey ghc, you know what we meant! why would we define a function and then not apply it to anything!?"
07:07:12 <Axman6> haha
07:07:16 <Axman6> m'bad
07:07:21 <luqui> fooled me
07:07:31 <luqui> I thought you found a ghc bug for a sec
07:07:40 <Axman6> damn, so close
07:07:48 <luqui> they're not that hard to find
07:08:47 <Axman6> could someone point me to where in the ghc source Ints and other basic types are actually defined?
07:11:34 <chrisdone> quicksilver, Heffalump: so I have the state value wrapped inside a type of which I won't export the constructor and accessor; this a solution, but is this what you meant?
07:13:04 <chrisdone> Axman6: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Int.html#t%3AInt
07:13:05 <lambdabot> Title: Data.Int, http://tinyurl.com/5tjd5j
07:13:08 <quicksilver> chrisdone: that is one way.
07:13:15 <Axman6> cheers
07:13:15 <quicksilver> chrisdone: another way is to use polymorphism instead
07:13:25 <quicksilver> and only promise that your monad is MonadIO m => m
07:13:28 <quicksilver> or something.
07:17:12 <chrisdone> quicksilver: so my “interface” functions inside the module know that it is an instance of StateT, but other modules using it don't? that sounds like only exporting certain instances. I wasn't aware that was possible
07:17:59 <quicksilver> StateT isn't a class.
07:18:12 <quicksilver> it's not something you are an instance of or not.
07:18:12 <chrisdone> uh, MonadState
07:18:16 <Deewiant> MonadState is, though
07:18:36 <quicksilver> you certainly can fail to export an instance (by hiding it in a module)
07:18:42 <quicksilver> but, I don't think that's the right answer here.
07:18:45 <quicksilver> that's fragile.
07:18:52 <quicksilver> I'd go for newtype or polymorphism.
07:19:12 <quicksilver> so the answer to your question is "no, that's not what I meant" ;)
07:19:28 <quicksilver> to be more precise, why don't you give use an example of how your code might be used.
07:19:40 <Armored_Azrael> Do we have a good way to compile 32-bit apps without a 32-bit chroot yet?
07:20:05 <quicksilver> nope.
07:20:11 <Armored_Azrael> :(
07:20:12 <Armored_Azrael> OK
07:20:30 <quicksilver> try getting a minion with a 32bit machine.
07:21:48 <Armored_Azrael> quicksilver: I have chroots maintained, it's just that I was about to recompile something for 32-bit and was reminded to check if we had gotten a more elegant solution yet.
07:22:39 <quicksilver> even if GHC supported cross compilation you'd still need 32-bit copies of every library used
07:22:51 <quicksilver> which wouldn't be all that different from a chroot in the end, I guess.
07:23:06 <Armored_Azrael> Not quite.
07:23:15 <Armored_Azrael> In a chroot I need another copy of every piece of system software.
07:23:38 * jeffwheeler is in trouble; I can only think of solving a problem the Haskell way, when not using Haskell
07:25:34 <jeffwheeler> @scr fold
07:25:34 <lambdabot> Maybe you meant: arr rc src
07:25:41 <jeffwheeler> @src foldl
07:25:41 <lambdabot> foldl f z []     = z
07:25:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:26:05 <Armored_Azrael> quicksilver: Also, completely irrelevant, but have we gotten haskell shared objects working any better? (after my job ends for a bit this month, I might put a bit of work in getting my hacks from the previous project to work more formally)
07:26:09 <chrisdone> quicksilver: an example might be: sql $ do rows <- query "SELECT * FROM foo WHERE bar = %" [SqlString "mu"]; exec "INSERT INTO zot (bob) VALUES (%)" [SqlString $ show rows]
07:27:16 <quicksilver> chrisdone: right. so 'users' of your code write whole chunks in this custom monad, which is your monad?
07:27:27 <quicksilver> definitely a case for a newtype, IMO.
07:27:53 <chrisdone> quicksilver: yeah, it's just the StateT at the moment. the point of sql is to take the connection from an MVar and then put it back in at the end of the SQL work
07:27:54 <quicksilver> newtype ChrisDoneSql a = StateT SqlState IO a
07:28:08 <Axman6> jeffwheeler: what's the problem?
07:28:19 <quicksilver> newtype ChrisDoneSql a = mkCDS { runCDS :: StateT SqlState IO a}
07:28:29 <quicksilver> and don't export mkCDS or runCDS
07:28:36 <jeffwheeler> Axman6: trying to use fold in Python; I think I've got a solution
07:28:46 <Axman6> heh, ok
07:29:07 <BONUS> you can program nice functionally in python
07:29:11 <chrisdone> quicksilver: ahhh, so external modules don't even see the state type
07:29:11 <BONUS> if you use generators and itertools
07:29:13 <quicksilver> make all youre python scripts of the form os.system("runghc ... ")
07:29:17 <quicksilver> chrisdone: right.
07:29:36 <quicksilver> they just see query :: String -> [Params] -> ChrisDoneSql Rows
07:29:37 <jeffwheeler> BONUS: that, and @src foldr :)
07:29:39 <quicksilver> or something like that.
07:29:48 <BONUS> haha
07:29:54 <BONUS> yeah, reduce is a left fold in python
07:30:06 <chrisdone> quicksilver: how can I make it possible for "lift" to be used, say, if using a function in the "parent" monad is desired?
07:30:13 <jeffwheeler> BONUS: I haven't used reduce before, but I've seen it; I _could_ look at that too
07:30:22 <BONUS> reduce is just foldl
07:30:23 <chrisdone> quicksilver: derive an instance of MonadTrans?
07:30:29 <quicksilver> yes
07:30:39 <quicksilver> you'll want to derive Monad
07:30:39 <jeffwheeler> BONUS: hmm, that'll save me a few lines of code; thanks :)
07:30:43 <quicksilver> and perhaps MonadIO
07:30:46 <BONUS> hehe
07:30:59 <BONUS> also you could try foldr = lambda
07:31:01 <BONUS> wait
07:31:12 <chrisdone> quicksilver: ah, right. I'll have a see how this looks. thanks for your help so far, by the way
07:31:18 <BONUS> also you could try foldr = lambda f, z, xs: reduce(f, z, reversed(xs))
07:31:46 <jeffwheeler> Ha; I don't really care about the direction so much --- it's only running two or three times
07:33:28 <quicksilver> chrisdone: the important thing is not to derive MonadState, I guess :)
07:33:51 <quicksilver> in principle you could have a private instane of MonadState but I wouldn't recommend that since I'd don't really believe in private instances.
07:34:46 <chrisdone> quicksilver: exposing just the newtype and what it implements seems nice to me
07:34:56 <quicksilver> (I think this is what you were trying to ask a page back btu I didn't get the context then :)
07:35:09 <chrisdone> right, I think so
07:38:08 <Ayuismyname> test
07:38:18 <Axman6> fail
07:38:19 <quicksilver> Ayuismyname: not working. Can't hear you.
07:38:28 <Ayuismyname> ?
07:38:39 <Axman6> we're messing with you
07:38:46 <Ayuismyname> hmm im still curious why b_jonas said why the recursion did not work
07:38:59 <Ayuismyname> he mentioned something about [4,5] and [1,2,3,4,5]
07:39:05 <Ayuismyname> http://hpaste.org/9460#a2
07:39:22 <Ayuismyname> b_jonas said its too much recursion?
07:40:56 <Ayuismyname> could someone explain to me in newbie terms why its not working?
07:41:14 <sbahra> Is there any benefit to using pattern matching rather than a conditional equation?
07:41:40 <Ayuismyname> what is pattern matching?
07:41:43 <sbahra> Ignoring stylistic preferences.
07:41:51 <BONUS> well its more readable
07:42:10 <Ayuismyname> stylistic preferences is?
07:42:28 <sbahra> BONUS, yes, when you have some long constraint it would help.
07:42:31 <quicksilver> sbahra: it's likely to produce better code.
07:42:43 <paczesiowa> pattern-matching can be proven by compiler to be safe
07:43:02 <sbahra> quicksilver, "better"?
07:43:08 <quicksilver> more compact, faster.
07:43:16 <sbahra> Really.
07:43:18 <sbahra> hmmm
07:43:30 <quicksilver> to be more precise: pattern-matching is pretty predicable in the code it will produce, which will be essentially optimal.
07:43:47 <quicksilver> conditional guards + inlining *may* optimise to somethign as good
07:43:47 <Ayuismyname>  example of pattern matching?
07:43:49 <quicksilver> but may not.
07:43:54 <quicksilver> Ayuismyname: sum [] = 0
07:43:55 <sbahra> yes...
07:44:00 <quicksilver> sum (x:xs) = x + sum xs
07:44:03 <sbahra> I can see now why it would be faster, compact, safer.
07:44:09 <sbahra> Alright, thanks.
07:44:15 <quicksilver> Ayuismyname: the [] and (x:xs) on the left of the = sign are patterns.
07:45:28 <jeffwheeler> BONUS: Ended up being very beautiful; thanks :)
07:46:16 <Ayuismyname> quicksilver: thanks
07:46:46 <Ayuismyname> what does sbahra means with "pattern matching rather than a conditional equation?"
07:47:00 <Ayuismyname> conditional is the guard / if-then-else?
07:47:16 <sbahra> guard
07:47:39 <sbahra> lol dongs | (dongs == 0) = 1
07:47:40 <sbahra> etc
07:48:15 <Ayuismyname> so what are we comparing here ? sum [] = 0  vs dongs | (dongs == 0) = 1 ???
07:48:17 <Botje> Ayuismyname: sum [] vs sum a | null a
07:48:40 <Ayuismyname> you mean how is this better than the other?
07:48:45 <Botje> Ayuismyname: in the second case, the compiler may not be able to deduce taht a is in fact []
07:49:04 <Botje> well, for the base case it isn't very interesting
07:49:07 <Botje> but for the other case:
07:49:11 <Botje> sum (x:xs) = x + sum xs
07:49:24 <Botje> this is _WAY_ more clear than sum a = head a + sum (tail a)
07:49:25 <quicksilver> sbahra: further, you could imagine when you have partially overlapping patterns you get better code
07:49:42 <Botje> even more important: if you have more than two constructors in your type and you ever miss a case
07:49:45 <Botje> the compiler will complain
07:49:55 <quicksilver> sbahra: like foo (a:b:bs) = a+b ; foo (b:bs) = b;
07:50:07 <quicksilver> sbahra: it probably doesn't destruct the top cons cell twice
07:50:19 <quicksilver> whereas the equivalent with two predicates would.
07:52:02 <Ayuismyname> what is quicksilver talking about with foo (a:b:bs) = a+b ; foo (b:bs) = b;
07:52:09 <Ayuismyname> i dont understand >.<
07:52:28 <mauke> Ayuismyname: haskell
07:52:44 <Botje> Ayuismyname: read the "pattern matching" chapter in your haskell text.
07:52:44 <Ayuismyname> i know its haskell , but how does that code work?
07:52:54 <Ayuismyname> ok
07:53:00 <Botje> it pattern matches a given list
07:53:06 <EvilTerran> in the end, if/then/else could desugar to case...of/True ->/False ->, anyway
07:53:30 <Botje> if you do foo [1,2], that's foo (1:2:[])
07:53:38 <Botje> so a = 1, b = 2, bs = []
07:53:56 <Ayuismyname> what is bs
07:54:43 <BeelsebobWork>  it's the empty list
07:55:15 <mauke> a variable
07:55:45 <paczesiowa> foo (a:b:bs) = ... === foo list = let a = head list in let b = head (tail list) in let bs = tail (tail list) in ...
07:55:58 <Ayuismyname> what is foo means?
07:56:10 <BeelsebobWork> it's a funcion name
07:56:23 <Ayuismyname> it could be abc(a:b:bs) ?
07:56:26 <BeelsebobWork> yes
07:56:30 <Ayuismyname> oh ok
07:56:33 <BeelsebobWork> foo is the most commonly used arbitrary name
07:56:36 <magthe> Ayuismyname: or bar (a:b:bs) ;)
07:56:37 <jeffz`> foo is metasyntactic
07:56:38 <BeelsebobWork> followed closely by bar
07:56:57 <chrisdone> quicksilver: are you sure what I am trying to do with this MonadState is possible? I'm having trouble writing it such that “query” can use MonadState but other functions cannot
07:56:57 <paczesiowa> http://en.wikipedia.org/wiki/Foo
07:56:57 <lambdabot> Title: Foo - Wikipedia, the free encyclopedia
07:57:15 <chrisdone> quicksilver: is there a name/keywords I can google the haskell wiki for?
07:58:58 <quicksilver> chrisdone: write those functions as if they were in StateT IO
07:59:03 <quicksilver> chrisdone: like this:
07:59:09 <quicksilver> query = mkCDS $ do
07:59:20 <quicksilver> ... StateT IO style code using 'get' and 'put' and 'modify'
07:59:42 <quicksilver> "mkCDS" has type "StateT SqlState IO a -> ChrisDoneSql a"
07:59:56 <quicksilver> so it lets you 'wrap' a StateT action up into an opaque CDS action.
08:00:04 <quicksilver> MkCDS actually.
08:00:07 <quicksilver> since it's a constructor.
08:00:39 <chrisdone> ahhh, I see
08:01:07 <quicksilver> this business of "you should actually use the constructor"
08:01:13 <quicksilver> was waht confused me at first about custom monads.
08:01:20 <quicksilver> but I've got the hang of it now.
08:01:31 <chrisdone> right, that's what confused me
08:01:40 <quicksilver> a typical custom monad starts with half a dozen low-level primitives which are written in terms on the underlying monad
08:01:47 <quicksilver> and then everything else can use them instead.
08:02:12 <quicksilver> getTheFoober = MkCDS $ gets foobar
08:02:28 <Ayuismyname> hey guys
08:02:34 <Ayuismyname> would you be using the same name in haskell forum
08:02:39 <Ayuismyname> i mean haskell channel?
08:03:07 <chrisdone> quicksilver: right. I have this now (real example):
08:03:07 <chrisdone> query :: String -> [SqlValue] -> Sql [[SqlValue]]
08:03:07 <chrisdone> query sql vs = Sql $ do c <- get; liftIO $ quickQuery' c sql vs
08:03:10 <paczesiowa> you guys discovered new, non-trivial monad? why not just stack transformers from mtl, they already have enough of primitives
08:03:40 <chrisdone> paczesiowa: it's just StateT
08:03:43 <quicksilver> because we're restricting it
08:03:47 <quicksilver> for abstraction.
08:04:15 <chrisdone> right. it's important that the value in the state isn't accessed other than by the defined accessors
08:06:44 <quicksilver> paczesiowa: after all your argument is like saying 'why use a new type, you can represent everything as Integer'
08:07:30 <paczesiowa> intergers don't have primitives for managing state and binding:>
08:07:47 <BeelsebobWork> he didn't say equal to
08:07:52 <BeelsebobWork> he said equivalent to
08:08:34 <quicksilver> paczesiowa: your argument was "why use a new monad, the MTL ones do everthing"
08:08:39 <quicksilver> I'm making an analogy.
08:08:45 <quicksilver> the analagous statement about types is
08:08:51 <quicksilver> "why use a new type, Integer does everything"
08:08:56 <quicksilver> they are both true.
08:09:02 <quicksilver> and the fallacy in both is analagous.
08:11:17 <byorgey> I wonder what Ayuismyname meant?
08:11:28 <byorgey> and is that the same person who's been making those tutorial videos?
08:11:59 <byorgey> answers at 11!
08:13:59 <BMeph> byorgey: String -> IO Answer? ;)
08:14:30 <BeelsebobWork> BMeph: no chance -- String -> Answer
08:14:41 <BeelsebobWork> what do you think I am, interacting with the world?
08:14:49 <jeeves__> I need to coerce a [Word8] into an [Int32], not sure how to do this
08:15:04 <BeelsebobWork> map fromIntegral
08:15:11 <BeelsebobWork> not sure if that's what you mean though
08:15:31 <BMeph> BeelsebobWork: Hah, we're BOTH wrong: Brent -> [Answer] :)
08:16:02 <jeeves__> well, I'm working with a WAVE file module that represents its data as [Int32], but I need to feed it some data from a ByteString
08:17:17 <BeelsebobWork> oh, okay so use the functions for reading binary encoded integers off bytestrings then
08:18:44 <mauke> http://hackage.haskell.org/packages/archive/binary/0.4.2/doc/html/Data-Binary-Get.html
08:18:46 <lambdabot> Title: Data.Binary.Get, http://tinyurl.com/6kgduv
08:18:50 <BeelsebobWork> instance Binary WavFile where {get = liftM2 (:) get get; put [] = return (); put (x:xs) = putInt x >> put xs} -- that should do it shouldn't it?
08:19:02 <jeeves__> BeelsebobWork: Well, I see that Data.ByteString.unpack will give a [Word8]
08:19:06 <jeeves__> oh hm
08:19:16 <BeelsebobWork> jeeves__: you almost never want to call Data.ByteString.unpack
08:19:25 <BeelsebobWork> it pretty much voids the goodness of bytestrings
08:19:29 <jeeves__> right
08:19:50 <jeeves__> mauke: looking at that, thanks
08:20:27 <jeeves__> All I need to do is convert a ByteString to [Int32] and hand it off to the function in the WAVE module that writes a new WAVE file
08:20:54 <jeeves__> that is, the file-format stuff is already taken care of
08:20:54 <BeelsebobWork> jeeves__: will my binary instance not suffice then?
08:21:02 <jeeves__> BeelsebobWork: still grokking that
08:23:12 <jamesjb> jeeves__: or just use Data.Binary.Get.getWord32{le,be} with runGet etc
08:24:44 <jeeves__> jamesjb: ah, that looks straightforward enough
08:30:56 <jeeves__> Thanks for the tips; my understanding of monads is still a bit vague
08:31:22 <Axman6> are there any good ways of making binary search trees faster?
08:31:35 <Axman6> i should paste my code...
08:34:13 <Toxaris> Axman6: for most applications, some kind of balancing is appropriate
08:34:27 <Axman6> Toxaris: what do you mean?
08:35:34 <quicksilver> depends why they are slow ;)
08:35:40 <quicksilver> your question is too vague to answer.
08:35:46 <quicksilver> balancing? pruning? tries?
08:35:50 <camio> Is there an identity type: Such that Id a is the same thing as a?
08:36:08 <Axman6> the problem i'm working on is one where someone has given you a calculator with only two buttons, (*2) and drop the last digit (or `div` 10), and you have to find how to get to each number 1..23
08:36:28 <mauke> camio: Identity
08:36:38 <seliopou> Axman6, that's a search problem
08:36:48 <Toxaris> camio: if you really want to have the same thing, you can define type Id a = a
08:36:53 <quicksilver> dynamic programming!
08:37:04 <twobitwork> so... I have an arbitrary list of commands I want to run as child processes, but I only want to have 64 running at a time... and I don't need to write them, but read their stdout and stderr file handles and collate their output...
08:37:15 <twobitwork> for some reason I can't even think of where to begin with this...
08:37:26 <camio> mauke,Toxaris: Thanks.
08:37:44 <camio> @hoogle Identity
08:37:45 <lambdabot> Control.Monad.Identity :: module
08:37:45 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
08:37:45 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
08:38:40 <Toxaris> Axman6: how is that a binary search tree?
08:38:46 <quicksilver> twobitwork: keep a list of currently running processes, threads listening on the handles
08:38:49 <twobitwork> (and no, this isn't homework) :)
08:38:50 <Axman6> ok, well it's a tree
08:38:57 <quicksilver> twobitwork: spawn new processes when the list drops below size 64
08:39:00 <mauke> what's the root of the tree?
08:39:05 <quicksilver> collate output as it arrives
08:39:08 <Axman6> 1
08:39:09 <quicksilver> profit!
08:39:19 <twobitwork> quicksilver: how will the list reduce...?
08:39:26 <twobitwork> I mean, how would I remove items from the list?
08:39:26 <Toxaris> Axman6: I think it is a graph, since you can have cycles
08:39:44 <Axman6> what's a graph...
08:40:08 <seliopou> Toxaris: you can formulate the problem as a tree or a graph
08:40:15 <twobitwork> Axman6: imagine a tree... but the nodes can point to each other
08:40:34 <twobitwork> and its not heirarchical like a tree
08:40:43 <Axman6> ah, i see
08:40:44 <Toxaris> Axman6: like a tree, but (1) more then one edge can point to the same node and (2) there are cycles
08:40:50 <quicksilver> twobitwork: you would store the list in an mvar
08:40:57 <Toxaris> Axman6: and (3) the nodes may not be connected
08:41:01 <EvilTerran> Toxaris, well, there may be cycles
08:41:02 <quicksilver> twobitwork: you would replace it with the altered version with bits removed.
08:41:09 <Toxaris> EvilTerran: hehe yes
08:41:11 <quicksilver> twobitwork: it would be more sensible to use a Data.Sequence
08:41:14 <quicksilver> but that's a detail.
08:41:27 * twobitwork hoogles
08:41:40 <Axman6> yeah, sounds like this problem, since there can be more than one of each number in the tree
08:41:57 <quicksilver> twobitwork: Data.Sequence is just lists with faster operations for somet hings.
08:42:01 <Toxaris> > (* 2) >>> (* 2) >>> (* 2) >>> (* 2) >>> (`div` 10) $ 1 -- cycle
08:42:03 <lambdabot>  1
08:42:07 <quicksilver> twobitwork: it's not really the heart of your problem.
08:42:10 <twobitwork> ok
08:42:14 <EvilTerran> you can represent a graph in haskell as a Map Node (Set Node)
08:42:19 <EvilTerran> (for some Node type)
08:42:22 <Axman6> hmm, i should really make that tail recursive (or whatever that would be in a tree)
08:42:39 <twobitwork> tail recursion is hard with trees... and usually not worth it
08:42:51 <EvilTerran> iff node2 `elem` (graph ! node1), there's an edge from node1 to node2
08:42:53 <Toxaris> Axman6: the point is, since you have cycles, you should consider to stop searching when you find the same node again
08:43:02 <pozic> How can I convert 1.15200317909e7 to something that has less precision, but has a smaller String representation?
08:43:03 <lambdabot> pozic: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:43:47 <EvilTerran> pozic, what about using Rational?
08:43:48 <Toxaris> > (read "1.15200317909e7") :: Float
08:43:49 <lambdabot>  1.1520032e7
08:43:59 <EvilTerran> i don't have context, so can't really guess whether that'd be appropriate
08:44:04 <Axman6> Toxaris: yeah, i can't even begin to work out how to impliment that
08:44:09 <EvilTerran> > 1.15200317909e7 :: Rational
08:44:10 <lambdabot>  115200317909%10000
08:44:18 <EvilTerran> well, that's no shorter :P
08:44:42 <quicksilver> pozic: round it?
08:44:51 <Axman6> > 1.15200317909e7 :: Complex Rational
08:44:52 <lambdabot>        add an instance declaration for (RealFloat (Ratio Integer))
08:44:52 <lambdabot>     In the...
08:44:55 <Axman6> wait
08:44:56 <Axman6> um
08:45:00 <pozic> quicksilver: I already did, but showing it afterwards shows a big number again.
08:45:05 <Axman6> @hoogle Complex
08:45:06 <lambdabot> Data.Complex :: module
08:45:06 <lambdabot> Data.Complex.Complex :: data Complex a
08:45:16 <Axman6> > 1.15200317909e7 :: Complex
08:45:16 <lambdabot>      `Complex' is not applied to enough type arguments
08:45:16 <lambdabot>     Expected kind `?',...
08:45:20 <Toxaris> > printf "%1.3e" 1.15200317909e7 :: String
08:45:21 <lambdabot>  "1.152e7"
08:45:22 <quicksilver> pozic: don't expect us to answer questions when you ask the wrong question.
08:45:30 <quicksilver> how did you round it?
08:45:38 <quicksilver> what do you mean it showed a 'big' number afterwards?
08:46:04 <Toxaris> pozic: if you want a different string representation, don't use show, but eg
08:46:11 <Toxaris> pozic: ... e.g. printf
08:46:43 <pozic> Toxaris: yes, printf is perfect, but it seemed there was no instance for returning a String in printf-mauke.
08:46:44 <Toxaris> pozic: why loose precision just to have shorter strings displayed
08:47:03 <mauke> pozic: huh?
08:47:04 <Toxaris> "printf-mauke"?
08:47:08 <quicksilver> showEFloat
08:47:10 <quicksilver> showFFloat
08:47:11 <mauke> pozic: I'm pretty sure that there is
08:47:12 <quicksilver> showGFloat
08:47:19 <quicksilver> why are you using printf-mauke?
08:47:25 <sbahra> heh
08:47:27 <Toxaris> what is printf-mauke?
08:47:39 <Toxaris> Axman6: keep a list of already visited nodes
08:47:43 <Saul__> .j #happs
08:47:54 <Toxaris> Axman6: so when you visit a node, you can show whether it is new or not
08:48:08 <pozic> mauke: http://hackage.haskell.org/packages/archive/printf-mauke/0.3/doc/html/Text-Printf-Mauke.html#t%3APrintfType
08:48:09 <lambdabot> Title: Text.Printf.Mauke, http://tinyurl.com/6m38wv
08:48:10 <Toxaris> Axman6: s/show/lookup
08:48:11 <mauke> Toxaris: my printf implementation
08:48:16 <Axman6> got an example handy? :)
08:48:21 <sbahra> Oh, there is actually a printf-mauke
08:48:22 <sbahra> haha
08:48:28 <Toxaris> mauke: and it doesn't support producing strings?
08:48:33 <quicksilver> pozic: why are you using that and not the built in printf?
08:48:33 <mauke> of course it does
08:49:18 <pozic> quicksilver: I kind of assumed that it would be better than the original.
08:49:40 <quicksilver> well it is better, and it's different
08:49:43 <mauke> pozic: instance (FromChar a) => PrintfType [a]
08:49:47 <quicksilver> but you seem to be tumbling together a lot of things :)
08:49:50 <mauke> don't believe the haddock
08:49:59 <quicksilver> the simplest answer would be showFFloat
08:50:11 <EvilTerran> in what way is it better than the original?
08:50:12 <pozic> :t showFFloat
08:50:12 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
08:50:36 <lispy> Is there a way to make a function that is polymorphic in the kind of it's parameters?
08:50:37 <quicksilver> EvilTerran: it supports perl printf syntax
08:50:41 <mauke> EvilTerran: it fixes numerous bugs
08:50:48 <EvilTerran> i see
08:50:49 <Toxaris> Axman6: what do you have so far?
08:50:56 <pozic> mauke: maybe put that hint in the documentation?
08:51:01 <Toxaris> Axman6: I assume you have some code, since you asked for speed improvement
08:51:05 <Axman6> http://hpaste.org/9463
08:51:06 <quicksilver> lispy: functions can only take parameters of kind *
08:51:15 <quicksilver> lispy: are you sure that's what you meant to ask?
08:51:17 <Axman6> changed slightly... sec
08:51:25 <mauke> pozic: yeah; I don't understand why the autogenerated docs don't list the String instance
08:51:43 <lispy> quicksilver: That might be why it doesn't work
08:51:58 <quicksilver> lispy: functions take values as parameters
08:52:03 <quicksilver> values have types of kind *
08:52:12 <quicksilver> what are you trying to do? :)
08:52:12 <lispy> foo :: (a :: * -> * -> *) -> b a, vs bar :: (a :: * -> *) -> b a
08:52:27 <lispy> I want foo and bar to work together
08:52:40 <Axman6> Toxaris: http://hpaste.org/9463#a1
08:52:43 <lispy> foo a x y -> b a an bar :: a x -> b a
08:53:08 <seliopou> Axman6: what's wrong with what you pasted?
08:53:25 <quicksilver> I don't think that makes much sense, lispy.
08:53:28 <lispy> quicksilver: It would be nice if foo was defined in a type class and through some type magic bar was also allowed
08:53:38 <Axman6> seliopou: uses a lot of memory and doesn't return for many values (for a long time at least)
08:53:52 <Toxaris> Axman6: note that your new maybeMin is called mplus and mappend
08:54:03 <Toxaris> Axman6: and your old was called liftM2 min
08:54:20 <Axman6> ah yes, i knew that, should've rememvered
08:54:22 <Axman6> heh, ok
08:54:24 <lispy> quicksilver: in the presence of existentially quantified types, you can have both...I just don't know how to roll it into one interface :)
08:54:25 <Toxaris> Axman6: sorry, mappend doesn't work for Maybes as I think it does, so only mplus
08:54:44 <quicksilver> lispy: let me just focus on foo, for a moment.
08:54:45 <lispy> quicksilver: I'm also convinced, in Haskell it's just not possible
08:54:46 <Axman6> :t mplus
08:54:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:55:00 <quicksilver> lispy: I curently don't think your question even makes sense.
08:55:01 <Axman6> :t mplus :: Maybe a
08:55:15 <quicksilver> did you mean (a :: * -> * -> *) => b a ?
08:55:37 <Axman6> i have no idea actually. bit sleepy now -_-
08:55:42 <seliopou> Axman6: Why are you passing around the depth in createTree?
08:55:43 <Axman6> it's almost 2
08:55:45 <lispy> No, I meant, given a :: * -> * -> *, I want foo :: a x y -> b a
08:55:53 <quicksilver> ah.
08:55:57 <quicksilver> that's not what you said :)
08:56:16 <Toxaris> seliopou: depth is the depth limit
08:56:30 <quicksilver> lispy: ok, so suppose you have foo :: a x y -> b a
08:56:42 <quicksilver> lispy: how could you construct bar, in principal?
08:56:56 <Axman6> seliopou: basically, it may bever return if i don't have a specified depth ;)
08:56:58 <seliopou> Toxaris, where is it being checked?
08:57:07 <Toxaris> seliopou: createTree _ _ _ 0 = End
08:57:16 <seliopou> oh, right
08:57:34 <Toxaris> Axman6: createTree will always return thanks to laziness
08:57:35 <lispy> quicksilver: Well, bar :: a x -> b a, a and b are not the same between foo and bar
08:57:36 <seliopou> just make it an infinite tree
08:57:42 <hackage> Uploaded to hackage: formlets 0.3
08:57:42 <hackage> Uploaded to hackage: bytestring-show 0.2
08:57:42 <hackage> Uploaded to hackage: applicative-extras 0.1.3
08:57:43 <hackage> Uploaded to hackage: hsXenCtrl 0.0.7
08:57:45 <hackage> Uploaded to hackage: AERN-Real 0.9.6.1
08:57:46 <Toxaris> Axman6: but findDepth will not return, of course
08:57:50 <quicksilver> lispy: yes, but what is the relationship between bar and foo?
08:57:55 <Axman6> Toxaris: yes, that will, but will findDepth?
08:57:57 <quicksilver> lispy: you're suggesting that some how bar is cmoputable from foo?
08:57:59 <Axman6> ok
08:58:03 <Toxaris> Axman6: so maybe the depth limit would be more appropriate with findDepth?
08:58:12 <quicksilver> lispy: that they are the 'same thing' for some suitably notion of kind polymorphism?
08:58:16 <Axman6> hmm, good point
08:58:58 <lispy> quicksilver: Um, I haven't come up with a way to compute one from the other, but they are conceptually the same.  They both take a type of one kind and wrap it up, as a lower kind
08:59:21 <lispy> quicksilver: data P x y where P :: P x y
08:59:31 <seliopou> Axman6, your search is left-biased
08:59:37 <lispy> quicksilver: data S a where S :: a x -> S a
08:59:43 <seliopou> and by that I mean you're doing DFS
09:00:13 <Axman6> seliopou: yes, but i figured with this specific problem, that's a good thing
09:00:29 <lispy> quicksilver: data F a y where F :: a x y -> F a y
09:00:36 <Axman6> but not really all that good
09:00:50 <lispy> quicksilver: and also data S2 a where S2 :: a x y -> S2 a, those are my data definitions
09:00:51 <seliopou> if you could come up with a heuristic to pick the branch, you might see some improvements
09:00:53 * Axman6 should add some `par`'s in there too
09:01:09 <lispy> quicksilver: each one of those takes a type of a specific kind and wraps it up in a special way
09:01:22 <quicksilver> lispy: agreed.
09:01:24 <lispy> quicksilver: I was hoping to make the "wrapping" function polymorphic
09:01:38 <Toxaris> Axman6: http://hpaste.org/9463#a2
09:01:46 <Toxaris> Axman6: just by the way :)
09:01:56 <lispy> quicksilver: like, class Seal a where seal :: a x y -> b a
09:02:03 <lispy> quicksilver: or is it Seal b
09:02:38 <lispy> quicksilver: So, I wanted that as long as b is compatible with sealing a, that seal works
09:02:43 <lispy> seal :: a -> b a
09:02:56 <lispy> But, then the kinds don't work out
09:02:59 <quicksilver> from what you've pasted I think it's class Seal a b where seal :: a x y -> b a
09:03:04 <Toxaris> seliopou, Axman6: and left-biased is the wrong default here, becase that meanst hat big numbers are inspected before small numbers, but since small numbers are searched in the end
09:03:21 <quicksilver> you can seal any particular a into various different bs
09:03:30 <Axman6> Toxaris: good point
09:03:34 <quicksilver> but as written they're not all of the form "b a"
09:03:40 <lispy> quicksilver: But, that won't work with S or F
09:03:42 <quicksilver> "F a y" is not of the form "b a"
09:03:48 <quicksilver> so you have to use
09:03:51 <Axman6> i could easily swap the functions that create the tree around though ;)
09:04:03 <quicksilver> class Seal a z where seal :: a x y -> z
09:04:05 <Toxaris> Axman6: yeah, try that maybe it already helps :)
09:04:06 <Axman6> which i should do
09:04:20 <quicksilver> it may be you could use associated types, instead.
09:04:34 <lispy> quicksilver: okay, but now what about S :: a x -> S a
09:04:46 <Toxaris> Axman6, seliopou: but I think that the cycles are the real problem
09:05:24 <Toxaris> btw, shouldn't it be easy to solve this by hand?
09:05:43 <Axman6> Toxaris: the thing is i want to find the length of the shortest path, and i don't quite see how graphs would let me do that
09:05:49 <lispy> it's like I need, class Kind2 a => Seal a z where seal :: a -> z; class Kind1 a => Seal a z where seal :: a -> z
09:05:56 <seliopou> Toxaris, more importantly is that DFS is not complete
09:06:11 <Axman6> yes, it is. my friend did it on his PDA using excel in about half an hour. but i wanted to model it
09:06:16 <lispy> quicksilver: and then class Kind1 (a :: * -> *), class Kind2 (a :: * -> * -> *)
09:06:20 <quicksilver> lispy: I think it might be expressible with ATs but I don't know how to use ATs.
09:06:20 <Toxaris> seliopou: with a sufficiently large depth limit, there shouldn't be a problem with completeness
09:06:26 <quicksilver> lispy: you'd need to ask the cafe for that, I think
09:06:27 <Toxaris> seliopou: but with correctness, of course :)
09:06:33 <quicksilver> very few people know how to use ATs.
09:06:37 <Toxaris> seliopou: if the shortest paths are searched
09:06:50 <Toxaris> Axman6: generally, you want iterative deepening search. always. it's just better.
09:07:02 <lispy> quicksilver: are ATs part of GHC though?
09:07:07 <quicksilver> lispy: only in HEAD.
09:07:20 <lispy> quicksilver: ah, I need stuff that is supported back to 6.6
09:07:23 <Axman6> Toxaris: what do you mean?
09:07:29 <quicksilver> right.
09:07:44 <Toxaris> Axman6: do you now bread-first and depth-first search?
09:07:48 <quicksilver> lispy: in "Seal a x", the kinds must be fixed.
09:08:03 <quicksilver> classes have fixed kind argument.
09:08:14 <seliopou> Axman6, You should buy Russel and Norvig
09:08:14 <quicksilver> just as functions have fixed type arguments.
09:08:18 <seliopou> if you're interested in AI/Search
09:08:25 <Axman6> no, i haven't done any theory on searching, so this is my own naive version :)
09:08:28 <quicksilver> isn't the correct solution to Axman6's problem dynamic programming?
09:08:30 <pozic> Nobody uses ATs because they are not guaranteed to work.
09:08:42 <quicksilver> to avoid unnecessary recomputation.
09:08:45 <quicksilver> I wasn't really following.
09:08:47 <lispy> quicksilver: yeah, so basically what I want to do is not possible
09:08:58 <quicksilver> lispy: actually, I don't agree.
09:09:08 <quicksilver> I think there is no expressibility problem.
09:09:19 <quicksilver> Anything which you can sensibly express like this is encodable.
09:09:20 <lispy> huh?
09:09:26 <lispy> hmm
09:09:28 <quicksilver> but the encoding may possibly look slightly ugly.
09:09:38 <Heffalump> associated datatypes are ok in GHC 6.8.3
09:10:04 <Toxaris> Axman6: depth-first search means exploring each alternative in full depth, before considering alternative branches at the top level
09:10:10 <Heffalump> if you're trying to abstract over superclasses, you can use them to do it
09:10:14 <lispy> Heffalump: yeah, but david doesn't seem to use anything but 6.6
09:10:27 <Toxaris> Axman6: e.g. you do depth first search, because you search all paths beginning with left, before you look at any path beginning with right
09:10:43 <Heffalump> 6.8 has been out long enough that it's pretty much standard now..
09:10:51 * lispy nods
09:10:58 <Toxaris> Axman6: bread-first search means exploring nodes nearer to the root before looking at nodes farther from the root
09:11:00 <gwern> Heffalump: eh, maybe if the type witness stuff got fixed
09:11:01 <seliopou> quicksilver: the only problem I see with a DP approach is, where is the solution?
09:11:01 <pozic> Heffalump: 6.8.3 is not.
09:11:08 <Toxaris> Axman6: that is what you want, since you want to find the shortest path
09:11:10 <lispy> gwern: been fixed
09:11:18 <seliopou> You'd have to have a matrix that can grow arbitrarily, and then you'd have to scan the whole thing to find the solution
09:11:19 <Axman6> Toxaris: yeah, i see
09:11:20 <lispy> gwern: the darcs type wit stuff works on 6.8 now
09:11:28 <Toxaris> Axman6: your current code will prefer a long path beginning with left over a short path beginning with right
09:11:35 <Axman6> ok, i'll work on that next
09:11:50 <Heffalump> pozic: associated datatypes work in 6.8.* afaik
09:11:55 <gwern> lispy: oh. did the package stuff get fixed yet?
09:12:02 <seliopou> Axman6, BFS is what you want
09:12:12 <Toxaris> Axman6: iterative deepening search is a trick to implement bread first search with depth first search: you start by depth-first searching with depth limit 0, then depth limit 1, 2, 3 and so on until you find something
09:12:17 <lispy> gwern: I'm not sure what problem you have, I can build/test and everything on 6.8
09:12:30 <Toxaris> Axman6: the trick is that DFS is easier to implement, faster, less memory consuming etc. then BFS
09:12:52 <Toxaris> Axman6: so iterative deepening is the way to go to implement BFS in most situations
09:13:09 <Axman6> hence why i implimented it, without even thinking of BFS :)
09:13:19 <Toxaris> hehe yes you only need the deepening :)
09:13:27 <Axman6> yeah, looks like that'd fit nicely into what i have
09:13:43 <seliopou> Axman6: but BFS is both optimal and complete
09:13:53 <Axman6> yeah
09:14:08 <Heffalump> the darcs codebase (sans type witnesses) has supported 6.8 for ages - I know cos I wrote the (very simple) patches to make it do so...
09:14:41 <gwern> lispy: I dunno, I still get type errors
09:14:52 <lispy> Heffalump: and I wrote the patches to make it work with type witnesses, at least as well as 6.6 works
09:15:22 <Heffalump> lispy: I did a bit of that too but David reverted it :-)
09:15:34 <Heffalump> he didn't like the extra signatures I had to add
09:15:47 <lispy> gwern: Well, ./configure --with-type-witnsesses && make, does end in errors on 6.6
09:15:58 <lispy> gwern: the test is whether you can 'make test'
09:16:10 <lispy> Heffalump: maybe he got over it then, he accepted my patches
09:16:52 <gwern> oh, nm. looks like the error was coming from some stale files
09:17:33 <xor_> Anyone here familiar with prolog? I'm wondering how to do the equivalent of "assert" in haskell.
09:17:39 <lispy> gwern: also, ./configure --with-type-witnesses && make witnesses, is a good test
09:17:53 <lispy> gwern: but that second one might not work unless you apply my latest patches
09:19:23 <Toxaris> xor_: do you mean changing function implementations at run time?
09:20:18 <xor_> Yes, but in my case I only need to add new defs
09:22:05 <Toxaris> xor_: very often, you can refactor your program so that the "dynamic" (prolog-speaking) function is a parameter, so you can just call parts of your program with appropriate values of this parameter
09:22:21 <lispy> Heffalump: probably the thing that made it accept the patches this time is that SPJ commented that the way 6.6 type checks GADTs is just broken and the way 6.8 and newer does it is at least theoretically sound
09:22:26 <xor_> ok, food for thought. thanks.
09:22:49 <Toxaris> xor_: as a simple example, consider find
09:23:14 <Toxaris> xor_: it can be used to search for every predicate you want, without changing anything, just by providing an appropriate predicate as a parameter
09:34:58 <Axman6> @src maybe
09:34:58 <lambdabot> maybe n _ Nothing  = n
09:34:58 <lambdabot> maybe _ f (Just x) = f x
09:36:19 <Axman6> @hoogle Maybe a -> Bool
09:36:19 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
09:36:19 <lambdabot> Data.Maybe.isNothing :: Maybe a -> Bool
09:37:01 <Axman6> @hoogle (a -> Bool) -> [a] -> a
09:37:02 <lambdabot> No matches, try a more general search
09:37:32 <Toxaris> @type find
09:37:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:37:55 <Axman6> will that return the first found element?
09:38:09 <Axman6> because that looks pretty good to me :)
09:38:17 <Toxaris> > find (< 0) [3, 5, 1, -3, 5, -5]
09:38:19 <lambdabot>  Just (-3)
09:38:27 <Axman6> excelent
09:38:30 <Axman6> ll*
09:38:49 <Toxaris> yep find is cool
09:40:31 <Toxaris> > listToMaybe . dropWhile (not . (< 0)) $ [3, 5, 1, -3, 5, -5]
09:40:32 <lambdabot>  Just (-3)
09:40:39 <Toxaris> but you can do without if you want :)
09:41:16 <Toxaris> > listToMaybe . filter (< 0) $ [3, 5, 1, -3, 5, -5] -- easier
09:41:17 <lambdabot>  Just (-3)
09:41:32 <Axman6> @hoogle find
09:41:32 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
09:41:32 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:41:32 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
09:41:35 * Toxaris writies random unimportant stuff in order to avoid working
09:46:14 <Axman6> is there any easy way to write "= find isJust $ map (\n -> findDepth' item n tree) [0..maxDepth]"  so it doesn't return Just (Just x)?
09:46:23 <Axman6> i want Just x, or x
09:46:41 * Axman6 was about to say 'i want Just x or just x' -_-
09:47:10 <Zao> fromJust?
09:47:13 <EvilTerran> join!
09:47:22 <Axman6> @src fromJust
09:47:22 <lambdabot> fromJust Nothing  = undefined
09:47:22 <lambdabot> fromJust (Just x) = x
09:47:32 <Axman6> sounds good :)
09:47:35 <EvilTerran> you don't want fromJust for this, i don't think
09:47:41 <EvilTerran> unless there'll always be a value in there
09:48:17 <EvilTerran> > mconcat [Nothing, Just 1, Nothing, Just 2]
09:48:18 <lambdabot>  Add a type signature
09:48:23 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 2]
09:48:24 <lambdabot>  Just 1
09:48:31 <EvilTerran> Axman6, how about msum?
09:48:37 <EvilTerran> ?src msum
09:48:37 <lambdabot> msum =  foldr mplus mzero
09:48:42 <EvilTerran> ?src Maybe mplus
09:48:43 <lambdabot> Nothing `mplus` ys = ys
09:48:43 <lambdabot> xs      `mplus` ys = xs
09:48:45 <EvilTerran> ?src Maybe mzero
09:48:45 <lambdabot> mzero = Nothing
09:49:00 <EvilTerran> gives back the first non-Nothing value
09:49:07 <EvilTerran> (in a Just)
09:49:13 <EvilTerran> or Nothing if all the elements are Nothing
09:53:59 <Axman6> ok, join was what i was after
10:02:21 <Axman6> EvilTerran: have you seen this tree problem i'm wokring on?
10:02:33 <EvilTerran> no9t in full
10:03:44 <Axman6> ok... well in the 30 seconds it took for you to answer, i forgot what i was going to ask, so don't worry :)
10:03:49 <Axman6> it's too late -_-
10:04:22 <Axman6> oh yeah. i remember now
10:06:45 <Axman6> i'm using a tree structure "data Tree a = End | Node (Tree a) a (Tree a)", and i was wondering if there's any way of telling ghc than all Nodes with the same value in the middle will have the same outcome. the way i'm using it means that i get repetition of trees
10:07:14 <dolio> Sounds like you want a graph?
10:07:24 <EvilTerran> dolio, that's what i was thinking. i think that came up earlier.
10:07:28 <Axman6> heh, you're the second person to tell me that
10:07:36 <dolio> :)
10:07:38 <Axman6> ok, so, i guess i need a graph.
10:07:50 <EvilTerran> Axman6, so any Node with the same value will have the same subnodes?
10:08:06 <Axman6> yep
10:08:31 <EvilTerran> indeed, i think you want to represent this as a directed (acyclic) graph
10:09:19 <EvilTerran> you can think of a DAG as a tree where branches can join as well as separating, but no branch can join one of its ancestors
10:09:27 <Axman6> i create the tree by using two functions which produce the left and right nodes based on the current node, so obviouskly, if i get to 1 again, i'm going to get the same tree again
10:09:45 <EvilTerran> the quick way of representing a graph like that would be "type Graph a = Map a (Set a)"
10:09:51 <Chip_Grandits> ping #haskell
10:09:58 <EvilTerran> pong Chip_Grandits
10:10:19 <EvilTerran> Axman6, are you creating this tree/graph only to tear it down again for your final result?
10:10:40 <EvilTerran> Axman6, or do you want to be able to produce a concrete representation other than for using internally?
10:10:40 <Axman6> yeah
10:11:08 <Axman6> well, i'm just trying to find the shortest path to a specified value
10:11:23 <Axman6> (well, so far, the shortest depth)
10:11:29 <EvilTerran> going down the tree only, then?
10:11:37 <Axman6> what do you mean?
10:11:43 <EvilTerran> from a node to its children
10:11:45 <EvilTerran> not vice-versa
10:11:54 <EvilTerran> the path, i mean
10:11:59 <Axman6> http://hpaste.org/9463#a2 to see my code from an hour or so ago if you're interested
10:12:17 <EvilTerran> hm
10:12:34 <Axman6> it's been updated a little since then. i'll paste that
10:13:16 <Chip_Grandits> who #haskell
10:13:27 <EvilTerran> turing test Chip_Grandits
10:13:32 * name gives Chip_Grandits a slash
10:13:43 <Axman6> http://hpaste.org/9469
10:14:09 <name> (/who #haskell)...
10:14:48 <xor_> Axman6 are you trying to avoid already visited nodes?
10:15:08 <Axman6> xor_: yeah
10:15:17 <EvilTerran> Axman6, do you have a textual description of the original problem?
10:15:23 <EvilTerran> it might help me find my way around that paste :)
10:15:28 <xor_> Shouldn't need a graph then. Just keep a list of visited nodes.
10:16:51 <xor_> If you reach a node that's been visited you just discard it from the queue and continue.
10:16:52 <Axman6> EvilTerran: well the problem could probably be solved another way, but i wanted to see if i could get a working binary tree and use it to answer the problem, but i'll tell you it anyway :)
10:17:14 <xor_> Assuming you're using a breadth-first strategy.
10:17:26 <EvilTerran> xor_, well, a set of visited nodes would be better
10:17:39 <Axman6> you've been given a calculator with only two buttons (*2) and (`div` 10) and you need to get from 1 to all the numbers up to 23
10:17:59 <xor_> EvilTerran, you'll have to forgive me, new to Haskell, and I don't know the difference.
10:17:59 <EvilTerran> i see
10:18:26 <EvilTerran> xor_, (Set a) has better time complexities than [a] for many things
10:18:57 <EvilTerran> Axman6, in fact, i think this is a cyclic graph, even
10:19:03 <Axman6> it is
10:19:06 <b_jonas> Axman6: oh, I think that's easy to automatically try
10:19:08 <b_jonas> moment
10:19:16 * EvilTerran waits while b_jonas one-liners it
10:19:26 <Axman6> in J
10:19:38 <EvilTerran> Axman6, i'd definitely be tempted to represent that as a Map Int (Set Int)
10:19:45 <b_jonas> well, it might be not one liner if you actually want the recipes as well
10:19:48 <b_jonas> but to check is easy
10:20:06 <EvilTerran> well, Map Int (Int, Int), actually, in this case
10:20:12 <Axman6> EvilTerran: sure... if i knew what that was
10:20:15 <EvilTerran> because you'll always have two child nodes
10:20:20 <EvilTerran> and the order they appear in matters
10:20:38 <EvilTerran> Axman6, "Map k v" is a mapping from values of type k to those of type v
10:20:43 <EvilTerran> (a finite mapping)
10:21:09 <Axman6> could you give an example?
10:21:11 <EvilTerran> ?type (M.!)
10:21:12 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
10:21:41 <EvilTerran> m!k gets the value in m for the key k, if that key is in the map
10:23:13 <EvilTerran> > M.fromList [(i,(2*i,i`div`10)) | i <- [1..23]]
10:23:15 <lambdabot>  fromList [(1,(2,0)),(2,(4,0)),(3,(6,0)),(4,(8,0)),(5,(10,0)),(6,(12,0)),(7,(...
10:23:30 <EvilTerran> @let m = M.fromList [(i,(2*i,i`div`10)) | i <- [1..23]]
10:23:31 <lambdabot> Defined.
10:23:37 <EvilTerran> > m!20
10:23:38 <lambdabot> Terminated
10:23:42 <EvilTerran> > m M.! 20
10:23:43 <lambdabot> Terminated
10:23:45 <EvilTerran> grr
10:24:00 <EvilTerran> > M.fromList [(i,(2*i,i`div`10)) | i <- [1..23]] M.! 20
10:24:01 <lambdabot>  (40,2)
10:24:02 <b_jonas> 35 button presses are definitely enough
10:24:17 <EvilTerran> @undef
10:24:17 <lambdabot> Undefined.
10:24:47 <EvilTerran> Axman6, so, for that definition of "m", m!k is the pair (2*k, k `div` 10)
10:24:51 <Axman6> @src M.fromList
10:24:51 <lambdabot> Source not found. Wrong!  You cheating scum!
10:24:59 <EvilTerran> Maps are abstract
10:25:11 <EvilTerran> and now my dinner's ready. bbiab.
10:25:32 <b_jonas> and 34 are definitely not enough
10:25:41 <Axman6> bleh, it's way too late to try and understand this. i'm off to sleep
10:25:48 <b_jonas> now to generate a shortest button press sequence for each
10:25:54 <b_jonas> let me think
10:27:34 <b_jonas> it's quite easy because the est of numbers you can generate doesn't grow too fast
10:28:15 <b_jonas> in fact, after at most 35 button presses, you can get only 3892 different results
10:28:43 <Halo-> What beginner Haskell book are all the cool kids reading?
10:28:50 <ddarius> @where rwh
10:28:50 <lambdabot> is http://www.realworldhaskell.org/blog/
10:29:20 <b_jonas> by the way, it's not easy to see that if you don't mind pressing the buttons for exponentially large time, you can get any positive integer by just pressing (*2) lots of times and then (`div`10) lots of times
10:30:04 <b_jonas> the calculator having a decimal display makes it easy because you just have to stop pressing *2 when the number starts with the desired digits
10:31:59 <Axman6> b_jonas: well yes, but is that the shortest route? ;)
10:32:02 <b_jonas> I think I can probably find the shortest keypresses in a one-liner as well, that is, in a line that fits in irc (that length is not well-defined)
10:32:06 <b_jonas> still trying
10:32:16 <Axman6> that's not the original problem, but it's what i want to find out
10:34:32 <twobitwork> can you extend a class definition? i.e., if I wanted to add almostMax to the Bounded class which would be defined as "pred maxBound"?
10:35:07 <bd_> twobitwork: like this: almostMax = pred maxBound
10:35:14 <bd_> no need for any fiddling with the class definition
10:35:16 <dons_> twobitwork: yoo write a subclass, or just a new top level function
10:35:18 <bd_> :t pred maxBound
10:35:19 <lambdabot> forall a. (Enum a, Bounded a) => a
10:35:22 <dons_> since you already have a default.
10:35:31 <dons_> only if you want to allow redefinition per-type do you need a new class.
10:35:39 <twobitwork> bd_: right, but that causes GHC to complain about ambiguity
10:36:07 <ddarius> That's the monomorphism restriction.
10:36:23 <twobitwork> ddarius: eh?
10:36:38 <twobitwork> meaning values can only have one type, etc?
10:36:53 <bd_> twobitwork: values can only have one type unless you put in a type signature
10:36:55 <dons> you need to supply an explicit polymorphic type.
10:37:01 <dons> bd_: well, not quite.
10:37:01 <bd_> twobitwork: so, put in a type signature:  almostMax :: (Enum a, Bounded a) => a
10:37:08 <dons> but that's the idea.
10:37:14 <bd_> hmm, what's different?
10:38:09 <dons> values can be polymorphic, in general. the monomorphism restriction restricts particular binding forms to be monomorphic.
10:38:09 <bd_> twobitwork: or pass -fno-monomorphism-restriction, actually, but this may have unexpected implications for efficiency
10:38:33 <dons> since a dictionary-polymorphic value is actually a function
10:38:50 <dons> so where users think they've written a polymorphic constant, they've actually written a function that might be recomputed.
10:38:53 <Cale> In practice, I don't think I've ever been bitten by turning the MR off.
10:38:56 <twobitwork> this "almostMax = pred (maxBound :: (Enum a, Bounded a) => a)" gives a different error... did I misinterpret what you meant?
10:38:56 <Axman6> hmm, anyone know why i'd be getting this error when compiling something with ghc?
10:38:59 <Axman6> Undefined symbols:
10:39:00 <dons> in practice, ghc is smart.
10:39:02 <Axman6>   "___stginit_parallelzm1zi0zi0zi1_ControlziParallel_", referenced from:
10:39:04 <Axman6>       ___stginit_Main_ in Treething.o
10:39:06 <dons> missing --make
10:39:19 <Axman6> ah, ok
10:39:20 <bd_> twobitwork: no, put at top level, above almostMax = ...   almostMax :: (Enum a, Bounded a) => a)
10:39:24 <Cale> Axman6: Most link errors are solved by --make
10:39:25 <bd_> er, minus last )
10:39:34 <Axman6> cheers :)
10:39:52 <Cale> Axman6: The real problem is that you don't have the parallel package loaded, so -package parallel should also fix it.
10:40:05 <tromp> > group [0,0,1,1,2,3,3,3]
10:40:06 <lambdabot>  [[0,0],[1,1],[2],[3,3,3]]
10:40:07 <Cale> But --make will include the appropriate packages automatically.
10:41:26 <Axman6> thanks
10:46:08 <b_jonas> Axman6: no, it's obviously not the shortest route
10:46:23 <b_jonas> I am doing the computation in the bot right now
10:49:11 <Axman6> @hoogle a -> Maybe a
10:49:12 <lambdabot> Prelude.Just :: a -> Maybe a
10:49:12 <lambdabot> Data.Maybe.Just :: a -> Maybe a
10:49:12 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:49:52 <twobitwork> how do you specify multiple definitions in let's? i.e. f [] = ...; f (x:xs) = ...
10:50:47 <Axman6> let f [] = ... ; f (x:xs) = ...
10:50:54 <EvilTerran> > let f [] = "nothing!"; f (x:xs) = "stuff!" in f [1,2,3]
10:50:55 <lambdabot>  "stuff!"
10:51:02 <twobitwork> ahh, thanks
10:51:09 <EvilTerran> you can use a newline instead of a ; in a file
10:51:28 <Axman6> anyway, sleep time. night all
10:51:37 <twobitwork> > let almostPred minBound = minBound; almostPred x = pred x in almostPred [True, False, True, False]
10:51:38 <lambdabot>   add an instance declaration for (Enum [Bool])
10:51:38 <lambdabot>     In the expression:
10:51:38 <lambdabot>       ...
10:51:55 <twobitwork> > let almostPred minBound = minBound; almostPred x = pred x in map almostPred [True, False, True, False]
10:51:56 <lambdabot>      Warning: Pattern match(es) are overlapped
10:51:56 <lambdabot>              In the definition...
10:52:14 <twobitwork> bleh... anyways... that doesn't work as I expect... it just return the list
10:52:44 <EvilTerran> that's because you can't pattern-match on "minBound"
10:53:21 <b_jonas> I've basically got the results but I just realize now that I shouldn't give the route as a list of zeros and ones for the two button but instead as the intermediate steps
10:53:23 <EvilTerran> you're just binding whatever the parameter happens to be to the name "minBound" within the body ofthe fukction
10:53:25 <b_jonas> that would be much nicer
10:53:52 <EvilTerran> crikey, i really can't type today
10:54:05 <EvilTerran> pardon my language :P
10:54:19 <twobitwork> EvilTerran: ahh, of course :)
10:54:29 <tromp> you need 36 steps to get 23
10:55:42 <b_jonas> so I'm redoing it
10:55:45 <b_jonas> tromp: are you sure?
10:55:57 <b_jonas> I'm not counting the starting step of entering 1
10:56:42 <tromp> well, my program says so
10:57:46 <b_jonas> > let { f x = 2*x; g x = div x 10 } in (g.f.g.f.f.f.f.f.f.f.g.f.f.f.f.f.g.f.f.f.f.f)1
10:57:46 <tromp> you need 36 to get the number 21 actually
10:57:47 <lambdabot>  23
10:57:57 <b_jonas> and that's just 22 steps
10:58:05 <b_jonas> 21?
10:58:06 <b_jonas> moment
10:58:16 <tromp> i meant all numbers up to 23, not 23 itself:)
10:58:34 <b_jonas> you need 35 steps
10:58:36 <b_jonas> I think
10:58:51 <b_jonas> tell any number under 23 that you think needs 36 steps
10:58:52 <tromp> oh right
10:59:30 <tromp> i did count the starting 1 after all :(
10:59:52 <twobitwork> that's an interesting problem
11:00:10 <twobitwork> shouldn't be too hard to bruteforce it though
11:00:18 <seliopou> we're still on this search thing?
11:01:22 <b_jonas> "Axman6: you've been given a calculator with only two buttons (*2) and (`div` 10) and you need to get from 1 to all the numbers up to 23"
11:01:28 <b_jonas> that means 1 shouldn't be counted
11:01:34 <b_jonas> 1 is not a button press
11:15:46 * xif + Haskell = ❤ forevah
11:15:59 <guenni2> hi, anybody doing COM scripting from haskell?
11:16:47 <b_jonas> http://hpaste.org/9470
11:16:55 <b_jonas> that's the proof that 35 button presses are always enough
11:17:44 <dylan> @type \f -> f *** f
11:17:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:17:59 <dylan> @hoogle (Arrow a) => a b c -> a (b, b) (c, c)
11:18:00 <lambdabot> No matches, try a more general search
11:18:09 <dylan> :(
11:18:47 <tromp> :t any
11:18:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:18:50 <b_jonas> Axman6, EvilTerran: that contains the shortest routes for each number (though it doesn't prove _that_)
11:18:55 <b_jonas> the routes are computed with J
11:20:24 <dylan> @hoogle (a -> b) -> (a, a) -> (b, b)
11:20:24 <lambdabot> No matches, try a more general search
11:21:24 <Deewiant> ?ty join (***)
11:21:24 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:21:25 <b_jonas> to get the table, type this to your J prompt:
11:21:26 <pjdelport> :t join (***)
11:21:27 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:21:30 <b_jonas> ''[stdout ;([:<'],',~'[',[:}.[:,/',',"0'01'{~[:>@:{:t{~(>{."1 t)i.])"0 i.30 [ t =:([:(#~[:~:0&{::"1)[:(/:0&{::"1)],[:,/((+:@:(0&{::);0,1&{::),:(<.@(%&10)@:(0&{::);1,1&{::))"1)^:35 ,:1;''
11:21:46 <b_jonas> could be somewhat shorter I guess but that's not important
11:21:52 <Deewiant> b_jonas: hmm, looks like your paste got corrupted, try again
11:22:53 <tromp> http://hpaste.org/9471 proves it
11:23:25 <b_jonas> try this: http://hpaste.org/9472
11:24:14 <tromp> map steps [1..23] = [0,1,6,2,11,7,16,3,12,12,21,8,21,17,17,4,26,13,13,13,35,22,22]
11:24:35 <tromp> that's how mnay steps each result takes
11:25:35 <b_jonas> in fact, try this instead:  http://hpaste.org/9473
11:26:37 <b_jonas>  /msg evalj ] _250]\ ;([:<'],',~'[',[:}.[:,/',',"0'01'{~[:>@:{:t{~(>{."1 t)i.])"0 i.30 [ t =:([:(#~[:~:0&{::"1)[:(/:0&{::"1)],[:,/((+:@:(0&{::);0,1&{::),:(<.@(%&10)@:(0&{::);1,1&{::))"1)^:35 ,:1;''
11:26:45 <b_jonas> that command gives you the whole table broken to lines
11:27:00 <b_jonas> one standalone phrase
11:27:17 <simard> is this an obfuscation contest ?
11:27:21 <b_jonas> could you run my last paste?
11:27:28 <b_jonas> simard: no, I just put everything to one line
11:27:36 <b_jonas> EvilTerran asked for a one-liner
11:27:41 <chylli> who can help me to see that ? http://hpaste.org/9474
11:27:44 <b_jonas> and I said I should be able to do it
11:27:46 <Saul__> Is it just me, or does enabling template haskell make the order of declarations matter?
11:29:01 <chylli> when I run it and run wget localhost
11:29:12 <chylli> it seems blocked at some where.
11:29:42 <chylli> if I break wget, it print the response get from google
11:29:53 <b_jonas> tromp: nice
11:29:55 <b_jonas> works for me
11:29:58 <chylli> I dont know why wget didn't get result.
11:30:16 <BMeph> b_jonas: If you will wait a bit, I'll show how I did it using ap. :)
11:32:36 <b_jonas> tromp: can you also generates the shortest routes?
11:33:15 <tromp> with some effort
11:34:05 <tromp> have to tag each result with past choice bits
11:35:21 <b_jonas> Axman6: nice task really
11:35:37 <tromp> can pair each Int with a Word64 whose bits encode past choices
11:36:20 <b_jonas> tromp: well, the shortest paths was what took me time actually
11:36:31 <b_jonas> generating all possible numbers is easy
11:37:26 <b_jonas> like, /msg evalj ] ([:~.[:/:~],+:,<.@:%&10)^:35 x:1
11:37:36 <b_jonas> that gives all possible numbers you can generate in 35 steps
11:37:59 <b_jonas> but pairing them with choices or history requires a bit more code
11:40:31 <Valodim> is it possible to pass functions as IO return values?
11:40:49 <Valodim> like IO (Int -> Int)
11:41:09 <chrisdone> yeah
11:41:22 <b_jonas> yes
11:41:27 <dons> so you construct a function based on some IO event?
11:41:40 <dons> like reading it from an IORef, or communication that passes functions between threads?
11:41:46 <b_jonas> why not?
11:41:52 <dons> yes, why not? :)
11:42:06 <dons> first class functions are first class for a reason!
11:42:10 <Valodim> in wxhaskell, want to set the drag event of a panel in its click event
11:42:12 <chrisdone> (return $ if foo then func1 else func2)
11:42:28 <dmhouse> Notice that the function itself must be pure.
11:42:37 <dmhouse> But the method of accessing that function may be impure.
11:42:48 <tromp> you can even have IO (Int -> IO (IO Int -> Int((
11:42:58 <tromp> you can even have IO (Int -> IO (IO Int -> Int))
11:43:41 <tromp> although the IO Int -> Int part is either naughty or ignoiring its argument
11:44:05 <Valodim> or both :P
11:44:24 <Valodim> hmm, so the click/drag thing doesn't work as intended
11:45:49 <b_jonas> tromp: yeah
11:48:29 <noohgodno> how do you actually learn haskell
11:48:39 <noohgodno> it scares the hell out of me
11:48:48 <erikc> whats your background?
11:49:18 <noohgodno> C(++), perl, php
11:49:38 <noohgodno> this whole lambda calculus idea just
11:49:52 <tromp> it's easier if you're a computer scientist familiar with lambda calculus
11:50:00 <noohgodno> i would imagine
11:50:11 <Chip_Grandits> hello, anyone here going to the Haskell Workshop at the ICFP in Victoria?
11:50:21 <Valodim> you learn it like all other languages
11:50:24 <erikc> ill be going to CUFP
11:50:28 <Valodim> jump right into it
11:50:37 <noohgodno> i bet
11:50:40 <noohgodno> what should i write
11:50:46 <|Steve|> Hello world.
11:50:48 <sbok> Whatever you want?
11:50:50 <Valodim> project euler is a good start
11:51:07 <Valodim> to get a hang of working with pure functions and currying and stuff
11:51:16 <Chip_Grandits> I too am going to the CUFP; anyone planning on taking any of the DEFUN developer track workshops at the ICFP in Victoria?
11:51:18 <noohgodno> i understand currying
11:51:27 <noohgodno> by "pure functions" do you mean
11:51:32 <noohgodno> without secondary effects
11:51:33 <noohgodno> >
11:51:35 <Valodim> yeah but still needs some getting used to
11:51:48 <Valodim> doing everything at once is really frustating, especially with the monad business
11:51:56 <chr1s> pure functions === no side effects.
11:52:00 <Valodim> (talking from my personal experience)
11:52:03 <chr1s> so no IO or State.
11:52:23 * noohgodno nods
11:52:27 <erikc> i might be odd, but i learned by reading on how haskell is translate to core (the intermediate language inside ghc) and then translate to stg (another intermediate language) and then that to assembler
11:52:54 <Valodim> without IO or state, haskell is basically a better calculator
11:53:12 <noohgodno> explain
11:53:29 <Deewiant> > 1 + sqrt 2 ** 4
11:53:30 <lambdabot>  5.000000000000001
11:53:44 <Valodim> well you can't do any I/O whatsoever, so... well yeah, you give some input get some result, no more no less
11:54:01 <noohgodno> ??
11:54:15 <noohgodno> the I and the O both seem to be there
11:54:44 <xor_> In a purely functional language, there is no such thing as state.
11:54:55 <xor_> State is required to do I/O and other things.
11:54:55 <noohgodno> do you mean that int main() would take an input, in c speak
11:55:03 <noohgodno> and the value of int main would be the output of the program
11:55:04 <noohgodno> ?
11:55:07 <Valodim> yes
11:55:12 <noohgodno> thank god
11:55:31 <|Steve|> noohgodno: Not really. lambdabot is an interpreter, Deewiant just passed values to the function and the interpreter itself did the output.
11:55:32 <noohgodno> 500 ** 500
11:55:41 <|Steve|> > 500 ^^ 500
11:55:42 <lambdabot>  Infinity
11:55:45 <|Steve|> heh
11:55:47 <noohgodno> great
11:55:52 <Deewiant> > 500 ^ 500
11:55:53 <lambdabot>  3054936363499604682051979393213617699789402740572326663893613909281291626524...
11:56:08 <b_jonas> actually no
11:56:09 <Deewiant> > length . show $ 500 ^ 500
11:56:10 <lambdabot>  1350
11:56:14 <b_jonas> the main function doesn't take the input
11:56:31 <Deewiant> > 500 ^^ 500 :: CReal
11:56:32 <lambdabot>  3054936363499604682051979393213617699789402740572326663893613909281291626524...
11:56:34 <b_jonas> the main function returns what is to be done with the input and output
11:56:39 <|Steve|> > putStrLn "Hello World"
11:56:40 <lambdabot>  <IO ()>
11:56:56 <|Steve|> What do the brackets mean there?
11:56:58 <b_jonas> it wouldn't work if the main function took the input because a program can be interactive
11:57:15 <Valodim> ...can I have arguments for a do expression? are they simply passed to the last statement?
11:57:18 <b_jonas> and you somehow have to know what input operations you want to do (like when to read from the standard input)
11:57:18 <seliopou> > map
11:57:19 <lambdabot>  Add a type signature
11:57:20 <Deewiant> |Steve|: that there's no result apart from the side effect, just void
11:57:28 <Deewiant> |Steve|: compare to IO Int, for instance
11:57:34 <hackage> Uploaded to hackage: ghc-core 0.4
11:57:34 <|Steve|> Deewiant: I meant <>, not the unit ().
11:57:55 <noohgodno> 500 ^ e ^ sqrt(500)
11:57:56 <Deewiant> |Steve|: I guess they're just lambdabot's way of showing IO results
11:57:59 <noohgodno> do it!
11:58:06 <Valodim> >
11:58:06 <Deewiant> noohgodno: you need the "> "
11:58:18 <noohgodno> which accomplishes what
11:58:28 <Deewiant> tells lambdabot that it should try and evaluate it
11:58:31 <Deewiant> 1+1
11:58:33 <Deewiant> > 1+1
11:58:34 <lambdabot>  2
11:58:37 <|Steve|> > 500 ^ (exp $ sqrt 500)
11:58:38 <lambdabot>  Add a type signature
11:58:46 <|Steve|> > 500 ** (exp $ sqrt 500)
11:58:47 <lambdabot>  Infinity
11:59:02 <Deewiant> > 500 ^ (round . exp $ sqrt 500)
11:59:10 <lambdabot> Terminated
11:59:21 <noohgodno> > round . 500.0000000000000001
11:59:23 <lambdabot>   add an instance declaration for (Fractional (f a))
11:59:34 <Deewiant> > round 500.0000000001
11:59:35 <lambdabot>  500
11:59:36 <|Steve|> Why is lambdabot giving me Infinity?
11:59:47 <Deewiant> |Steve|: because it doesn't fit in a Double
11:59:53 <Deewiant> > 500 ** (exp $ sqrt 500) :: CReal
11:59:55 <lambdabot>  0.0
12:00:01 <noohgodno> hehe
12:00:01 <Deewiant> hmm
12:00:08 <Deewiant> that was somewhat unexpected
12:00:11 <noohgodno> HE'S SENTIENT
12:00:12 <noohgodno> KILL HIM
12:00:14 <|Steve|> I'll say.
12:00:22 <Deewiant> > 500 ** 5141855148 :: CReal
12:00:23 <lambdabot>  0.0
12:00:27 <Deewiant> > 500 ** 514185514 :: CReal
12:00:35 <lambdabot> Terminated
12:00:36 <b_jonas> > sqrt 500
12:00:37 <lambdabot>  22.360679774997898
12:00:39 <|Steve|> Haskell's numbers are a pain in the ass.
12:00:47 <Deewiant> somewhat
12:00:50 <b_jonas> do you really expect exp(exp(22)) to fit in a double?
12:00:54 <|Steve|> Just once, I'd like it to do the right thing.
12:00:55 <Deewiant> they're a weird balance between practicality and math
12:01:02 <b_jonas> > exp $ sqrt 500
12:01:03 <lambdabot>  5.141855147826761e9
12:01:12 <|Steve|> @type (**)
12:01:13 <lambdabot> forall a. (Floating a) => a -> a -> a
12:01:21 <tromp> > 3 * (1/3)
12:01:22 <|Steve|> Why does that have to be a double?
12:01:22 <lambdabot>  1.0
12:01:25 <b_jonas> 500 ** that number would be like 10^(10^9)
12:01:32 <b_jonas> that's a very high number
12:01:34 <Deewiant> |Steve|: defaulting
12:01:50 <|Steve|> That's the sort of thing that's nonobvious.
12:02:01 <nominolo> @seen dons
12:02:02 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 19m 55s ago.
12:02:05 <Deewiant> I forget how exactly it works but essentially it means that it picks Double and Integer for you in some cases where the type is ambiguous. :-P
12:02:26 <tromp> @pl i -> i+1
12:02:27 <lambdabot> (line 1, column 3):
12:02:27 <lambdabot> unexpected ">" or "-"
12:02:27 <lambdabot> expecting variable, "(", operator or end of input
12:02:39 <Deewiant> @pl \i -> i+1
12:02:39 <tromp> @pl i+1
12:02:39 <lambdabot> (1 +)
12:02:40 <lambdabot> i + 1
12:02:53 <|Steve|> If only Haskell had subtypes. *sigh*
12:02:55 <tromp> @pl \i -> i*(1/i)
12:02:56 <lambdabot> ap (*) (1 /)
12:03:11 <nominolo> |Steve|: hm?
12:03:24 <tromp> map (ap(*)(1/) [1..19]
12:03:31 <tromp> >map (ap(*)(1/) [1..19]
12:03:35 <tromp> > map (ap(*)(1/) [1..19]
12:03:35 <lambdabot> Unbalanced parentheses
12:03:43 <tromp> > map (ap(*)(1/)) [1..19]
12:03:44 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
12:04:12 <Deewiant> > repeat 1.0
12:04:13 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
12:04:21 <noohgodno> map ("hello") [1..19]
12:04:25 <noohgodno> > map ("hello") [1..19]
12:04:26 <lambdabot>  Couldn't match expected type `a -> b'
12:04:29 <noohgodno> lame
12:04:35 <|Steve|> Hell, it could just be syntatic sugar. You say something like: subtype Int Double where inject = fromInt and then wherever you needed a Double you could use an Int.
12:05:06 <tromp> @let f n = sum (replicate n (1/n))
12:05:07 <lambdabot> <local>:1:24:     No instance for (Fractional Int)       arising from a use o...
12:05:19 <nominolo> |Steve|: that would make the conversion implicit.  that must not be done, since you lose information
12:05:35 <|Steve|> How would you lose information?
12:05:35 <tromp> :t replicate
12:05:36 <lambdabot> forall a. Int -> a -> [a]
12:06:04 <tromp> :t (/)
12:06:05 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:06:08 <nominolo> |Steve|: Int to Double may be safe, but Integer to Double is not
12:06:24 <|Steve|> I didn't say Integer would be a subtype of Double.
12:06:26 <tromp> @let f n = sum (replicate n (1/(fromIntegral n)))
12:06:27 <lambdabot> Defined.
12:06:34 <noohgodno> > foldr (*) 1 [1..500]
12:06:34 <tromp> > f 3
12:06:35 <lambdabot>  1220136825991110068701238785423046926253574342803192842192413588385845373153...
12:06:35 <lambdabot> Terminated
12:06:55 <nominolo> |Steve|: furthermore, subtyping makes type inference much harder
12:06:56 <|Steve|> But Integer could be a subtype of whatever the arbitrary precision rational is.
12:07:00 <noohgodno> > foldr (*) 1 [1..2]
12:07:02 <lambdabot>  2
12:07:04 <noohgodno> > foldr (*) 1 [1..3]
12:07:06 <lambdabot>  6
12:07:17 <noohgodno> ok
12:07:25 <tromp> > f 2
12:07:26 <lambdabot> Terminated
12:07:36 <b_jonas> how on earth can that be typechecked
12:07:40 <b_jonas> :type replicate
12:07:47 <tromp> > replicate 2 (1/2)
12:07:49 <lambdabot>  [0.5,0.5]
12:07:50 <b_jonas> @type f
12:07:50 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
12:07:53 <b_jonas> @type replicate
12:07:53 <lambdabot> forall a. Int -> a -> [a]
12:08:06 <tromp> @let foo n = sum (replicate n (1/n))
12:08:06 <lambdabot> <local>:2:26:     No instance for (Fractional Int)       arising from a use o...
12:08:11 <|Steve|> nominolo: Do you have an example where it would be harder?
12:08:16 <tromp> @let foo n = sum (replicate n (1/(fromIntegral n)))
12:08:17 <lambdabot> Defined.
12:08:20 <tromp> > foo 3
12:08:21 <lambdabot>  1.0
12:08:32 <tromp> > map foo [1..19]
12:08:33 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,0.9999999999999999,0.9999999999999998,1.0,1.00000000000...
12:08:48 <nominolo> |Steve|: not off of my head.  if you have TAPL in reach, there're probably some good examples
12:08:51 <noohgodno> oO
12:08:56 <|Steve|> TAPL?
12:09:03 <tromp> @let bar n = sum (replicate n (1%(fromIntegral n)))
12:09:04 <lambdabot> Defined.
12:09:11 <tromp> > map bar [1..19]
12:09:12 <lambdabot>  [1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1]
12:10:50 <b_jonas> tromp: that doesn't need the fromIntegral
12:10:53 <nominolo> @where TAPL
12:10:54 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:10:57 <tromp> i know:)
12:11:13 <Cale> > map foo [1..19 :: CReal]
12:11:14 <lambdabot>  Couldn't match expected type `Int' against inferred type `CReal'
12:11:23 <Cale> mm
12:11:33 <|Steve|> Ah, had you just said the author, I'd have known what book you meant.
12:11:37 <Cale> @let quux n = sum (replicate n (1/n))
12:11:38 <lambdabot> <local>:4:27:     No instance for (Fractional Int)       arising from a use o...
12:11:49 <noohgodno> never met a language i didn't like!
12:11:51 <noohgodno> ha-ha-ha!
12:11:52 <|Steve|> I don't have it handy, but I know where to get it.
12:12:11 <Cale> @let quux n = sum (replicate n (1/fromIntegral n :: CReal))
12:12:12 <lambdabot> Defined.
12:12:22 <Cale> > map quux [1..19]
12:12:23 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
12:13:08 <AndreWe> hi
12:13:30 <noohgodno> > product [1..5]
12:13:31 <AndreWe> I'd like to create thumbnails from JPG images
12:13:32 <lambdabot>  120
12:13:36 <tromp> for creal the challenge woiuld be product ( replicate n 2^(1/n))
12:13:44 <noohgodno> hmph
12:13:53 <AndreWe> Is there an easier option than using gtk2hs?
12:14:30 <|Steve|> I'm not convinced it would be any different. Type inference would proceed exactly as normal except when you have f :: (Foo x) => x -> x -> x and then you have two types that are instances of Foo and that have a common supertype that is also an instance of Foo.
12:14:51 <|Steve|> Oh well, I have to go to a meeting now.
12:16:44 <nominolo> |Steve|: ok, maybe it's possible, but it's a non-trivial modification of the type system
12:17:34 <nominolo> augustss gave a nice talk on "the future of haskell".  he predicted intersection types by (i think) 2015 (at which point no one uses haskell anymore)
12:17:55 <nominolo> that was Haskell'07
12:18:21 <Deewiant> class aliases would be nice
12:18:35 <noohgodno> what's haskell's successor?
12:18:49 <Valodim> successor?
12:18:56 <Deewiant> haskell' is haskell98's successor
12:18:57 <noohgodno> successor
12:19:09 <noohgodno> i mean, what's going to displace haskell
12:19:19 <Deewiant> how would we know :-)
12:19:36 <noohgodno> maybe if some of you have already found something in its early stages
12:19:41 <noohgodno> concise, elegant and powerful
12:19:55 <Deewiant> nothing that looks like it would be displacing haskell
12:20:17 <AndreWe> How would you improve Haskell, noohgodno?
12:20:17 <Valodim> more concise, elegant and powerful than haskell? I doubt such a thing will face the light of day anytime soon
12:20:23 <nominolo> it was a joke (more or less)
12:20:28 <b_jonas> noohgodno: well, we found three separate languages for those three criterions I think
12:20:34 <pjdelport> define "Haskell"
12:20:41 <b_jonas> J is concise, haskell is elegant, perl is powerful
12:20:47 <b_jonas> but together?
12:20:50 <nominolo> he said in 2020 only Oleg could understand Haskell anymore
12:20:55 <pjdelport> if you count all the extensions, Haskell could go on forever
12:20:56 <nominolo> and was the only user
12:21:28 <nominolo> Oh, and Haskell' was released in 2010 or so
12:21:29 <Valodim> heh
12:21:30 <b_jonas> nominolo: the sad part will be that even compilers won't understand haskell anymore at that time
12:21:31 <nominolo> er, no
12:21:32 <nominolo> 2020
12:21:33 <b_jonas> it will be so complicated
12:23:07 <noohgodno> what did haskell itself displace?
12:23:48 <pjdelport> Miranda, among others
12:24:59 <Valodim> arguably ML, Lisp, and Scheme
12:25:24 <noohgodno> lisp?
12:25:25 <vininim> not lisp, because paul graham still has some sheep
12:25:33 <tromp> SASL...
12:25:36 <Valodim> yeah some more arguably than others :P
12:25:37 <noohgodno> can haskell modify its own code
12:25:48 <Valodim> SISAL?
12:26:14 <Valodim> by definition, it can't
12:26:16 <tromp> http://en.wikipedia.org/wiki/SASL_%28programming_language%29
12:26:19 <Trinithis> @seen twey
12:26:19 <lambdabot> twey is in #japanese. I last heard twey speak 14h 10m 42s ago.
12:26:28 <Valodim> you cannot change a function once it is defined.. otherwise it wouldn't be a function would it
12:26:51 <noohgodno> so it can't replace lisp
12:26:55 <b_jonas> Valodim: ML and lisp and scheme are still living
12:26:58 <pjdelport> > let 2+2 = 5 in 2+2
12:26:59 <lambdabot>  5
12:27:15 <tromp> let 0 = 1 in 0
12:27:15 <Valodim> b_jonas: yeah that's why I said, arguably
12:27:19 <tromp> let>  0 = 1 in 0
12:27:26 <tromp> > let 0 = 1 in 0
12:27:27 <lambdabot>  0
12:27:34 <noohgodno> damn how did i get myself banned from #lisp
12:27:44 <b_jonas> tromp: @let
12:27:53 <b_jonas> oh, sorry
12:27:58 <tromp> can redefine + but not 0
12:28:06 <b_jonas> sure you can't
12:28:09 <b_jonas> 0 is a constructor
12:28:45 <noohgodno> how do i calculate the sum of a range of int's
12:28:49 <b_jonas> and because the lhs doesn't bind any variable that's actually evaluated, the constructor never gets matched to the expression on the rhs
12:28:52 <tromp> > let x+y=1 in 0+0
12:28:53 <lambdabot>  1
12:29:09 <pjdelport> > sum [1..5]
12:29:10 <lambdabot>  15
12:29:32 <noohgodno> > sum [1..1000]
12:29:33 <lambdabot>  500500
12:29:37 <b_jonas> tromp: in fact,
12:29:51 <noohgodno> > sq(sum) [1..1000]
12:29:52 <lambdabot>   Not in scope: `sq'
12:29:55 <b_jonas> > let x * y = 42 in 1*1 + 5
12:29:56 <lambdabot>  47
12:30:06 <b_jonas> hmm
12:30:11 <b_jonas> shouldn't that change the arity?
12:30:14 <b_jonas> > let x + y = 42 in 1*1 + 5
12:30:15 <lambdabot>  42
12:30:23 <b_jonas> > let x + y = 42 in 10 * 1 + 5
12:30:24 <lambdabot>  420
12:30:33 <b_jonas> ah, it does, but it changes it to low, not high
12:30:41 <b_jonas> tricky
12:30:52 <tromp> that's precedence, not arity
12:30:52 <noohgodno> how do i calculate, say, the square of every iterated number there
12:30:53 <b_jonas> um, the converse
12:30:57 <b_jonas> it changes it to high
12:31:01 <b_jonas> yeah, the precedence
12:31:03 <b_jonas> and the fixity
12:31:41 <xor_> > map sqrt [1..5]
12:31:43 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979]
12:31:46 <tromp> example, noohgodno?
12:31:46 <b_jonas> noohgodno: do you expect us to answer all homework questions?
12:31:56 <noohgodno> it's august...
12:32:09 <noohgodno> > map sum [1..1000]
12:32:10 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
12:32:12 <b_jonas> so? homework doesn't mean school homework here
12:32:16 <b_jonas> just show some effort
12:32:21 <xor_> You should look at the functions in the standard prelude
12:32:26 <noohgodno> i am showing effort, by random guessing
12:32:29 <b_jonas> you won't learn from just us writing new code for you
12:32:34 <noohgodno> much more effort than is required by looking things up
12:32:53 <b_jonas> so we should look things up for you?
12:32:58 <noohgodno> exactly
12:33:05 <xor_> :T
12:33:17 <noohgodno> boy, i like this channel
12:33:31 <b_jonas> read a haskell introduction or whatever manual that suits your background and aims the best
12:34:05 * noohgodno is reading YAHT
12:35:48 <Cale> noohgodno: It's okay to ask of course :)
12:35:55 <Cale> > map (^2) [1..10]
12:35:57 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
12:36:11 <Cale> > scanl (+) 0 [1..10]
12:36:12 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
12:36:14 <noohgodno> > sum map (^2) [1..1000]
12:36:15 <lambdabot>  Couldn't match expected type `[a]'
12:36:27 <Cale> > sum (map (^2) [1..1000])
12:36:28 <lambdabot>  333833500
12:36:38 <noohgodno> er
12:37:01 <Cale> You don't want to pass map as a parameter to sum, but the whole list.
12:37:22 <Cale> (sum only has one parameter and you gave it 3)
12:37:25 <noohgodno> that doesn't seem right
12:37:31 <noohgodno> 333833500 i mean
12:37:49 <xor_> why not?
12:38:12 <b_jonas> 333833500 is right
12:38:17 <Cale> I can confirm it.
12:39:02 <noohgodno> i want c=0; for (i=1,i++,i<1001) {c=c+i^2;}
12:39:03 <Cale> > (\k -> k * (k + 1) * (2*k + 1) `div` 6) 1000
12:39:04 <lambdabot>  333833500
12:39:46 <Cale> That is the sum of the squares of 1 up to 1000.
12:39:49 <noohgodno> err
12:39:52 <noohgodno> i mean
12:39:56 <noohgodno> i want c=0; for (i=1,i++,i<1001) {c=c+i^i;}
12:40:11 <noohgodno> which is a really really big number
12:40:29 <Cale> okay
12:40:41 <Cale> > sum (map (\n -> n^n) [1..1000])
12:40:49 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
12:41:00 <Cale> > length . show $ sum (map (\n -> n^n) [1..1000])
12:41:01 <lambdabot>  3001
12:41:02 <Jedai> > sum (map (join (^)) [1..1000]
12:41:02 <lambdabot> Unbalanced parentheses
12:41:05 <noohgodno> so \n is the iterator?
12:41:07 <Jedai> > sum (map (join (^)) [1..1000])
12:41:08 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
12:41:16 <noohgodno> or \n declares it, n represents it?
12:41:21 <Cale> noohgodno: (\n -> ...) is a function which takes the parameter n and produces ...
12:41:23 <laz0r> > sum [ i^i | i <- [1..1000]]
12:41:25 <lambdabot>  1000368199144695177095375011227646795567793680622934654583760988100234910747...
12:41:41 <Cale> noohgodno: The \ is ascii art for the Greek letter lambda (λ)
12:41:53 <noohgodno> aha
12:41:55 <dmhouse> > let f n = n^n in length . show $ sum (map f [1..1000])
12:41:56 <lambdabot>  3001
12:42:03 <b_jonas> oh yeah, logical. 1000^1000 is 10^1000 so it has 1001 digits and all the rest of the terms are small
12:42:07 <Cale> Which will be familiar if you know any other functional languages :)
12:42:08 <xor_> oh cool, how do you type the lambda?
12:42:22 <noohgodno> what encoding is IRC, for that matter
12:42:31 * dmhouse does C-x RET C-\ greek RET l
12:42:37 <Cale> xor_: I hit both shift keys which I've set up as a way to switch keyboard layouts between greek and english.
12:42:44 <Cale> and then I press l :)
12:42:45 <noohgodno> emacs--
12:42:46 <xor_> ah :)
12:42:55 <b_jonas> noohgodno: this channel is in utf8
12:43:01 <Cale> I also have SCIM, so I could use that.
12:43:08 <xor_> what editors do you guys use? emacs is pretty lame for editing haskell.
12:43:15 <dmhouse> xor_: it's actually pretty awesome.
12:43:16 <b_jonas> it depends on which channel, the irc standard doesn't specify (because it's so old that when they started they used ISO-646-*)
12:43:17 <Cale> xor_: There's a nice Haskell mode.
12:43:23 <Cale> xor_: But I usually use vim.
12:43:27 <dmhouse> xor_: Emacs and vim are the leading Haskell editors.
12:43:31 <noohgodno> i use vim as well
12:43:32 <xor_> dmhouse I tried the haskell mode and it didn't get the indents right
12:43:37 <noohgodno> i'm no haskell coder though
12:43:39 <dmhouse> xor_: keep hitting TAB.
12:43:41 <laz0r> xor: recently i started using leksah, the haskell ide
12:44:00 <laz0r> it is quite useable already
12:44:07 <dmhouse> xor_: it's a "bounce indentor", it produces several valid indentation points, and lets you choose between them.
12:44:17 <dmhouse> xor_: as in general there are multiple valid places to indent a Haskell line.
12:44:17 <xor_> Yeah, even with that, when writing "where" clauses it's hard to get stuff to line up
12:44:35 <dmhouse> Could you give an example?
12:45:20 <b_jonas> I don't like editors trying to be smart
12:45:32 <noohgodno> yeah, computers should do nothing for their users
12:45:32 <xor_> f x = y
12:45:39 <xor_>     where y = somethingelse
12:45:44 <noohgodno> operating systems are a capitalist scheme
12:45:46 <xor_>           somethingelse = 5
12:45:51 <b_jonas> I choose how I indent things by hand
12:45:56 <dmhouse> xor_: pastebin?
12:45:59 <dmhouse> Or is that it?
12:46:20 <xor_> that's basically it
12:46:30 <dmhouse> Which line fails to indent correctly?
12:46:38 <xor_> the last one
12:46:52 <b_jonas> I do accept some help from the editor: starting the next line where the indentation of the previous was, tab and backspace jumping a full indent step instead of just a space, and keystrokes for indenting or unindenting the selected block by one step
12:47:03 <dmhouse> xor_, I get three indent points for that line.
12:47:16 <Cale> Oh, a somewhat annoying thing about the emacs haskell-mode smart indenter is that sometimes you have to start typing a line before tab will get you to the right place
12:47:17 <b_jonas> but that's basically all
12:47:22 <dmhouse> xor_: underneath the 's' of somethingelse in the previous line, underneath the 'y', and bol.
12:47:26 <Cale> But once you're used to that, it's nice.
12:47:28 <xor_> my mistake. it was "|" I was having trouble with. :P
12:47:33 <xor_> with something liek:
12:47:39 <xor_> f x
12:47:46 <dmhouse> Cale: surely that's true of all syntactic indenters?
12:47:50 <xor_>    | x == 5 = 0
12:47:55 <xor_>    | x == 6 = 1
12:47:56 <xor_> etc, etc
12:48:05 <xor_> It won't automatically line up with the |
12:48:21 <Cale> dmhouse: well, I don't have much experience with them, but when the line is empty, I would expect it to go through every possible indentation I might want.
12:48:30 <dmhouse> xor_: on the second line, if you press TAB TAB, you'll be placed below the 'x', and the | will be inserted automatically.
12:48:35 <b_jonas> dmhouse: depending on whether you use a style where you indent the close brace or not I think
12:48:35 <dmhouse> Third line, sorry.
12:48:38 <Cale> (and restrict those according to syntax if I've typed something)
12:48:58 <Jedai> xor_: It does in my emacs
12:48:58 <dmhouse> I don't know why it doesn't work if you insert the |, that looks like a bug.
12:49:05 <xor_> hm, maybe I have the wrong mode.
12:49:21 <xor_> It says "Haskell Ind Doc"
12:49:25 <Cale> That is, I would expect the indentations produced when something was typed already to be a subset of the indentations for a blank line.
12:49:39 <dmhouse> xor_: basically, for guards, you don't need to type the |, the indentor can insert it for you itself, just press TAB TAB.
12:49:54 <xor_> oh, ok.
12:49:59 <dmhouse> There's also C-c C-g (haskell-indent-insert-guard).
12:50:02 <xor_> so GUARD, TAB, TAB works
12:50:12 <xor_> aha, thanks
12:50:35 <dmhouse> Cale: I imagine that the possible indent points would get restrictively large.
12:51:02 <dmhouse> xor_: but I think it should still work if you insert a | first. So possibly a bug.
12:51:08 <Cale> dmhouse: How large could it be? Anything under about 10 is fine.
12:51:11 <Jedai> xor_: There seems to be a small but if you just write | on the line, but as soon as you write something else, indent find the correct indentation
12:51:45 <RayNbow> > 1 ** (-2)
12:51:46 <lambdabot>  1.0
12:51:49 <RayNbow> > 1 ** (-2) :: CReal
12:51:50 <lambdabot>  1.0
12:51:52 <Cale> dmhouse: I usually ended up turning off the smart indenter. The simple one just lined things up under the start of every non-whitespace character, and that was all right for me.
12:51:54 <RayNbow> > 0.5 ** (-2) :: CReal
12:51:55 <lambdabot>  4.0
12:52:35 <dmhouse> Cale: I'm not so sure (about the < 10 thing), I don't want to sit pressing TAB and examining indentation points for 7, 8, 9 times per line.
12:52:58 <Cale> I suppose I'm used to just hitting tab a few times and then inserting spaces by hand.
12:53:10 <xor_> I don't like spaces :(
12:53:21 <dmhouse> xor_: they're pretty much mandatory for indenting Haskell.
12:53:30 <xor_> I know, I just don't want to press the spacebar
12:53:33 <dmhouse> Haskell is a nasty language to indent :)
12:53:37 <Cale> xor_: Of course, you should automatically have your editor convert tabs to spaces, or there will be problems.
12:53:39 <xor_> nothing against ' ' :)
12:53:40 <dmhouse> xor_: oh, you should never have to do that.
12:54:17 <dmhouse> Haskell's got a nice syntax but I do envy modes that get the right indentation every time, through the more restricted syntax of their languages.
12:55:16 <b_jonas> Cale: exactly, the tab button should indent with one steps, whereas in the text file, the tab character should represent 8 positions exactly
12:55:41 <dmhouse> b_jonas: nah, the TAB button should do syntactic indentation in programming modes.
12:55:55 <Cale> b_jonas: I think the ascii tab character should be abolished.
12:56:33 <xor_> Ascii tab is really useful in some circumstances. Like when you're outputting variable length text strings to the terminal.
12:56:34 <b_jonas> Cale: some say that, but because editors can handle reading and writing them easily, I don't see why
12:56:44 <vixey> xor_:I think it's a non-solution
12:56:44 <dmhouse> There's a massive difference between TAB (the tab button) and \t (the tab character). They're pretty much orthogonal.
12:56:54 <b_jonas> I admit tab is a historical thing
12:56:58 <dmhouse> Cale: but... but... Makefiles! :)
12:57:07 <Cale> dmhouse: make should also be abolished ;)
12:57:10 <b_jonas> if we started with high-performance computers, we wouldn't have a tab character at all
12:57:11 <noohgodno> spiegel im spiegel
12:57:18 <noohgodno> o/'
12:57:33 <sjanssen> xor_: it fails immediately once your variable length strings are longer that eight characters
12:57:42 <noohgodno> ascii tab is useful for ascii art as well
12:57:46 <noohgodno> don't take that away from us
12:57:53 <xor_> Not so, you simply add length/8 tabs.
12:58:11 <b_jonas> ascii tab is also useful for the email indentometer
12:58:12 <Cale> noohgodno: You mean for screwing up ascii art when the tab character is interpreted as the wrong number of spaces?
12:58:15 <b_jonas> foo wrote
12:58:19 <b_jonas> > bar wrote
12:58:20 <lambdabot>   Not in scope: `wrote'
12:58:21 <noohgodno> tab is always 8
12:58:24 <noohgodno> always!
12:58:26 <b_jonas> > > long message
12:58:27 <lambdabot>   parse error on input `>'
12:58:28 <sjanssen> xor_: and you also have to track the maximum length in a column
12:58:30 <haedent> indentation is one thing. I would also like an editor that automatically lines up the = signs in a bunch of pattern matching expressions
12:58:40 <dmhouse> noohgodno: I've got (setq tab-width 2). So there.
12:58:47 * dmhouse has to read PHP code indented with \t occasionally
12:58:52 <sjanssen> xor_: my argument is that once you're keeping track of the length, why not indent properly?
12:58:54 <dmhouse> haedent: M-x align-regexp
12:58:59 <noohgodno> :%s/dth 2/dth 8/g
12:59:01 <noohgodno> so there
12:59:09 * noohgodno sticks his tongue out
12:59:20 <Cale> What would be more interesting than a tab character is a character or characters which represented alignment.
12:59:22 <b_jonas> > > (tab)v
12:59:23 <lambdabot>   parse error on input `>'
12:59:25 <xor_> hm, I see your point.
12:59:32 <noohgodno> > tab
12:59:33 <b_jonas> > >   3 2 1 0 indent steps
12:59:33 <lambdabot>   Not in scope: `tab'
12:59:33 <lambdabot>   parse error on input `>'
13:00:01 <Cale> (rather than just moving to the next n-space boundary)
13:00:14 <dmhouse> haedent: it's a really useful command. Bind it to C-c a r, assuming you use Emacs, which you do, right? :)
13:00:42 <edmoore_> hi, any users know of the name of the umbrella package to apt-get the latest ghc and ghci?
13:00:44 <erikc> if you use vim, theres Align.vim, http://www.vim.org/scripts/script.php?script_id=294
13:00:45 <lambdabot> Title: Align - Provides commands and maps to help produce aligned text, eqns, declarati ...
13:01:08 <Cale> edmoore_: Which distribution?
13:01:20 <edmoore_> ubuntu hardy (8.04)
13:01:21 <Cale> Debian?
13:01:24 <Cale> ah
13:01:24 <xor_> try apt-get install ghc6
13:01:33 <Cale> It doesn't have the latest ghc/ghci at all.
13:01:40 <xor_> oh, latest.
13:01:43 <dino-> mm, is that fresh enough? I tend to recommend the generic ghc binary install
13:01:43 <haedent> dmhouse: thanks
13:01:45 <noohgodno> sudo pacman -S ghc
13:01:48 <noohgodno> ahh, arch
13:01:51 <Cale> I just download the generic linux binary.
13:02:23 <xor_> What's the difference between 6.8.2 and 6.8.3?
13:02:39 <SubStack> -0.0.1
13:02:43 <edmoore_> I don't necessarily need the latest
13:02:52 <edmoore_> just usefully up to date and usable
13:02:54 <Cale> Well, 6.8.2 should actually do okay
13:03:09 <edmoore_> but ghc6 seems to be dragging in a lot of stuff so it seems ok
13:03:13 <xor_> Besides, if you're going to distribute your program you should target what's shipping with the OSes you want to distribute to.
13:03:24 <Cale> When the next ubuntu comes out, it's going to be a major version behind for 6 months though :(
13:03:46 <Cale> edmoore_: You might also need things like libghc6-*
13:04:34 <Cale> edmoore_: But if you can get enough things to install cabal-install, then it's kind of a moot point to install the debian packages for things, because it'll download and install the latest libraries from hackage for you.
13:04:50 <edmoore_> yeah
13:05:06 <edmoore_> well ghci is now there
13:05:10 <edmoore_> so all seems happy
13:05:14 <profmakx> I don't let the package manager manage my ghc
13:05:21 <dino-> edmoore_: If you do decide you want to get binaries: http://haskell.org/ghc/download_ghc_683.html
13:05:21 <lambdabot> Title: GHC: Download version 6.8.3
13:05:28 <edmoore_> thanks people. Just setting up a server for general stuff, having been an osx user
13:05:31 <profmakx> because then comes along the latest and greatest package and everything is broken
13:05:34 <edmoore_> dino-: thanks
13:05:46 <dino-> edmoore_: And I had to get libreadlinr4 because Debian is up to 5: http://packages.debian.org/sarge/i386/libreadline4/download
13:05:47 <lambdabot> Title: Debian -- Package Download Selection -- libreadline4_4.3-11_i386.deb
13:05:53 <dino-> That .deb installed fine alongside libreadline5
13:06:05 <dino-> sorry libreadline4
13:06:31 <dino-> But with those two things, happy fun time yay
13:07:01 <edmoore_> :)
13:07:09 <dino-> We've seen this work fine on both a Debian testing system and a Ubuntu I think Hardy.
13:07:25 <edmoore_> haskell is such a happy programming language. I cannot qualify that stement in any way. But it is.
13:07:30 <dino-> Or Gutsy. But probably Hardy
13:07:32 <edmoore_> I am happy when programming it
13:07:57 <edmoore_> it's not a battle. It's not me vs compiler, a battle or wits.
13:08:41 <tromp> @let answer=length.filter(`elem`['a'..'z']))
13:08:41 <lambdabot>  Parse error
13:08:46 <tromp> @let answer=length.filter(`elem`['a'..'z'])
13:08:47 <lambdabot> Defined.
13:09:01 <dino-> It's perhaps you vs the type compiler. :D
13:09:01 <tromp> > answer "The Ultimate Question of Life, The Universe, and Everything"
13:09:06 <lambdabot>  42
13:09:54 <noohgodno> lame
13:10:49 <dino-> edmoore_: Me too, upbeat and positive when writing Haskell. Things seem to make more sense.
13:10:57 <b_jonas> > answer "question"
13:10:58 <lambdabot>  8
13:11:25 <b_jonas> > answer "ultimate question"
13:11:26 <lambdabot>  42
13:12:40 <tromp> cute:)
13:14:34 <tromp> > answer "ultimate question"
13:14:35 <lambdabot>  42
13:15:23 <noohgodno> > answer "ubuntu faults"
13:15:24 <lambdabot>  42
13:15:43 <xor_> > answer ""
13:15:44 <lambdabot>  42
13:15:49 <vininim> > answer "language of discriminating hackers"
13:15:50 <lambdabot>  42
13:15:54 <vininim> fail
13:16:09 <noohgodno> everybody wants to be a hacker
13:16:30 <tromp> > answer "answer"
13:16:31 <lambdabot>  42
13:16:57 <xor_> @t answer
13:16:57 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:17:05 <xor_> @type answer
13:17:06 <lambdabot> forall b t. (Num t) => b -> t
13:17:34 <noohgodno> @ticker
13:17:35 <lambdabot> Empty ticker.
13:17:40 <noohgodno> @thank you
13:17:40 <lambdabot> Maybe you meant: thank you thanks
13:17:47 <noohgodno> @thank you thanks
13:17:48 <lambdabot> Maybe you meant: thank you thanks
13:17:48 <Toxaris> > answer "question" -- ?
13:17:49 <lambdabot>  666
13:18:05 <tromp> @let ans=length.filter(`elem`['a'..'z'])
13:18:05 <lambdabot> Defined.
13:18:38 <noohgodno> > sum "hello"
13:18:39 <lambdabot>   add an instance declaration for (Num Char)
13:18:39 <lambdabot>     In the expression: sum "hell...
13:19:24 <camio> Anyone know of a word that represents: for a given range of values (a,b) the set of values c where a < c < b is always finite?
13:19:43 <vixey> camio: Integral
13:20:12 <camio> vixey: Doesn't integral come with more assumptions than that?
13:20:44 <BMeph> camio: Do you mean Enum? :)
13:20:57 <camio> I'm looking for a mathematical term.
13:20:59 <BMeph> b_jonas: ping
13:20:59 <EvilTerran> camio, i think i'd call it an open interval
13:21:08 <noohgodno> that's no interval
13:21:11 <tibbe> how can I allocate a buffer for use with hGetBuf, I see now new function for Ptrs?
13:21:15 <EvilTerran> or "the open interval between a and b"
13:21:17 <EvilTerran> rather
13:21:31 <noohgodno> camio, is c necessarily an integer
13:21:49 <EvilTerran> oh wait, "is always finite"?
13:21:52 * EvilTerran parse errors
13:21:55 <noohgodno> yeah
13:21:59 * EvilTerran backtracks and tries again
13:22:06 <camio> No, not nececerally an integer.
13:22:11 <noohgodno> because for any a < b, that's an infinite set
13:22:30 <camio> I have a set with an operation < such that all a in the set between two others is always finite.
13:23:00 <camio> I'm thinking there must be a name for that property on (S,<).
13:23:05 <b_jonas> BMeph: pong
13:23:19 <camio> So (Integer,<) has that property but (R,<) doesn't.
13:23:40 <noohgodno> if i understand you correctly, yes
13:24:00 <camio> What I'm looking for is the name of that property.
13:24:00 <BMeph> b_jonas: Ah - I finally got back to your 1-23 problem; my Haskell quasi-one-liner is on http://hpaste.org/9473#a1
13:24:18 <tromp> your set is isomorphic to integers
13:24:20 <noohgodno> it's an interval
13:24:44 <noohgodno> noninclusive on both ends
13:24:45 <BMeph> camio: (Q,<) doesn't have it, either. :)
13:25:01 <vixey> @w80 Integral
13:25:02 <lambdabot> *** "integral" wn "WordNet (r) 2.0"
13:25:02 <lambdabot> integral
13:25:02 <lambdabot>      adj 1: existing as an essential constituent or characteristic; "the
13:25:02 <lambdabot>             Ptolemaic system with its built-in concept of
13:25:02 <lambdabot>             periodicity"; "a constitutional inability to tell the
13:25:04 <camio> bmeph: good point.
13:25:04 <lambdabot> [9 @more lines]
13:25:10 <doctormach> Is there some way to make cabal always look for libraries in a nonstandard location?
13:25:10 <vixey> @more
13:25:10 <lambdabot>             truth" [syn: {built-in}, {constitutional}, {inbuilt},
13:25:10 <lambdabot>             {inherent}]
13:25:10 <lambdabot>      2: constituting the undiminished entirety; lacking nothing
13:25:11 <BMeph> camio: There's a hint/clue in there somewhere... :)
13:25:12 <lambdabot>         essential especially not damaged; "a local motion keepeth
13:25:14 <lambdabot>         bodies integral"- Bacon; "was able to keep the collection
13:25:16 <lambdabot> [4 @more lines]
13:25:21 <vixey> @more
13:25:21 <lambdabot>         entire during his lifetime"; "fought to keep the union
13:25:21 <lambdabot>         intact" [syn: {entire}, {intact}]
13:25:22 <lambdabot>      n : the result of a mathematical integration; F(x) is the
13:25:24 <lambdabot>          integral of f(x) if dF/dx = f(x)
13:25:32 <xor_> Did someone say bacon :D
13:25:52 <noohgodno> why are we talking about integration
13:26:38 <b_jonas> BMeph: it results in 34
13:26:48 <b_jonas> so what is that supposed to mean?
13:27:59 <camio> Maybe "isomorphic to integers" is the best way to define that property.
13:28:08 <vixey> camio: Integral
13:28:25 <BMeph> b_jonas: ...um, that 1-23 comes up after 34button-presses? :)
13:28:48 <b_jonas> BMeph: but I thought we find it comes up in 35
13:28:51 <b_jonas> so was that wrong?
13:29:16 <benny99> does somebody know a good tutorial on "how the predecessor function in lambda calculus works" ?
13:29:20 <camio> vixey: Doesn't that imply a negate operation?
13:29:20 <b_jonas> > iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:29:22 <lambdabot>  [(0,[1]),(1,[2,0]),(2,[4,0]),(3,[8,0]),(4,[16,0]),(5,[32,0,1]),(6,[64,0,2,3]...
13:29:26 <vixey> camio: No
13:29:52 <vixey> benny99: Derive it from scratch and you'll understand it
13:30:04 <camio> vixey: Oh, so the haskell typeclasses aren't correct then.
13:30:06 <benny99> vixey: that's what I'm trying to do
13:30:18 <vixey> camio: Correct with respect to what?
13:30:34 <camio> Well, they say that every Integral is a Num and every Num has a negate.
13:31:32 <benny99> vixey: it's really not that easy :(
13:35:58 * sioraiocht is on the teeny bopper bus Hell.
13:36:02 <sioraiocht> *from Hell.
13:36:06 <Elly> really?
13:36:11 <sioraiocht> yes
13:36:16 <Elly> I didn't know the busses ran there
13:36:39 <tehgeekmeister> does the haskell ffi work for python, or are workarounds of some sort necessary if you want to interface to python code?
13:36:42 <sioraiocht> only place they could have pikced up some of these passengers
13:36:50 <Elly> heh :)
13:37:59 <camio> tehgeekmeister: Last I heard automated python/haskell interaction only went python -> haskell. Although it should be easy enough to do Haskell -> C -> Python.
13:38:17 <glguy> hpaste2 calls python code via c
13:38:24 <glguy> for syntax highlighting
13:39:35 <pjdelport> tehgeekmeister: http://hackage.haskell.org/trac/summer-of-code/ticket/1547
13:39:36 <lambdabot> Title: #1547 (FFI bridge to Python) - Haskell.org Google Summer of Code - Trac
13:39:39 <b_jonas> BMeph: why do those lists contain only the numbers after exactly n keypresses instead of at most n?
13:39:49 <pjdelport> http://www.quux.org:70/devel/missingpy
13:40:28 <glguy> firefox can browse gopher://gopher.quux.org/1/devel/missingpy
13:40:29 <lispy> hey now
13:40:32 <glguy> I've never done that before
13:40:33 <tehgeekmeister> maybe i can sidestep the whole problem: does anyone know of a haskell implementation of any reasonably good sentence boundary detection algorithm?
13:40:49 <pjdelport> tehgeekmeister: http://wiki.python.org/moin/PythonVsHaskell has some crazy code
13:40:50 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
13:41:18 <vixey> benny99: Do you understand how to make conses and car and cdr?
13:41:37 <benny99> vixey: didn't do that yet
13:41:43 <vixey> do that first
13:41:47 <benny99> vixey: must I do that be... ok :)
13:41:48 <b_jonas> > snd . (!!34) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:41:50 <benny99> vixey: thanks :)
13:41:50 <lambdabot>  [17179869184,0,536870912,805306368,838860800,33554432,855638016,16777216,251...
13:41:56 <b_jonas> > sort . snd . (!!34) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:41:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,16,24,25,32,36,38,40,48,50,51,56,57,60,61,6...
13:42:04 <b_jonas> > fst . (!!34) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:42:05 <lambdabot>  34
13:42:16 <benny99> vixey: (guess I got pairs so far)
13:43:44 <BMeph> > ([1..23]\\) . snd . head . drop 34 . iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:43:45 <lambdabot>  [14,15,17,18,19,20,21,22,23]
13:43:52 <lispy> You could use pairs to represent lists, car = fst, cdr = snd, cons = (,), but I don't know how to give the type of mapcar
13:43:59 <BMeph> > ([1..23]\\) . snd . head . drop 35 . iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:44:00 <lambdabot>  []
13:44:20 <BMeph> > ([0..23]\\) . snd . head . drop 0. iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:44:21 <b_jonas> BMeph: I think you have an off-by one error
13:44:22 <lambdabot>  [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]
13:44:28 <b_jonas> why does it start with a pred?
13:44:55 <b_jonas> > sort . snd . (!!35) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:44:56 <BMeph> b_jonas: Which is why I did that: drop 0 shows when you have not pushed any buttons yet - all you've got is 1.
13:44:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,32,4...
13:45:03 <BMeph> > ([0..23]\\) . snd . head . drop 1 . iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:45:05 <lambdabot>  [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]
13:45:30 <b_jonas> BMeph: but you don't pred what you drop, but the fst of the pair
13:45:31 <BMeph> After pushing a button, you can get 2 (1*2) or 0 (1 `div` 10)
13:45:45 <b_jonas> BMeph: which is 0 for when you don't push any button
13:46:12 <vixey> benny99: Next you can try to encode this in lambda calculus:
13:46:12 <vixey> data N = Z | S N
13:46:19 <b_jonas> > (!!1) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1])
13:46:20 <lambdabot>  (1,[2,0])
13:46:29 <vixey> in general you encode a data type like that as the fold:
13:46:30 <vixey> foldN z s Z = z
13:46:30 <vixey> foldN z s (S n) = s (foldN z s n)
13:46:30 <b_jonas> yep, you can get 2 or 0, but the fst is 1 there
13:46:41 <vixey> and since you've defined pairs,
13:46:47 <lispy> > let mapcar f (car, cdr) = (f car, mapcar f cdr) in mapcar
13:46:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t1, t)
13:46:48 <lambdabot>       Expe...
13:46:48 <vixey> just port this:
13:46:48 <vixey> pred = snd . foldN (Z,Z) (\n -> (snd n,S (snd n)))
13:46:51 <vixey> into lambda calculus
13:47:15 <b_jonas> nice solution by the way
13:47:18 <lispy> vixey: are you talking to me?
13:47:23 <vixey> lispy: No
13:48:04 <benny99> vixey: thanks :)
13:48:17 <b_jonas> apart from considering only the numbers after exactly n keystrokes, but that turns out to not cause any difference in the result
13:48:38 <b_jonas> and would probably be easy to fix by changing [(*2), to [id,(*2),
13:49:43 <vixey> lispy: benny99 was asking about defining pred in lambda calculus
13:50:28 <vixey> I know how to transform any simple data type, but I don't know if there's a neat algorithm for turning arbitrary pattern matches into eliminator calls
13:50:55 <vixey> There is at least a complicated algorithm for that though...
13:52:51 <vixey> actually, maybe not
13:53:05 <vixey> I was mixing up eliminators and folds
13:53:23 <vixey> Is it even possible to eliminate pattern match ='s into folds?
13:53:50 <lispy> vixey: ah, I was lamenting that even though lisp's cons is haskell's (,), you can't define mapcar in Haskell
13:54:12 <lispy> vixey: and for a second i thought you were giving an encoding
13:54:38 <vixey> lispy, oh right, no just doing untyped stuff.. but writing it in haskell syntax
13:55:25 <lispy> I wonder, so any time you get would need to construct an infinite type, you could instead, define a recursive data structure and use that instead?
13:55:40 <BMeph> b_jonas: Okay, I get what you meant. Yes, it takes 35 presses to get all of them. You got it. :)
13:55:45 <vixey> yes
13:56:06 <vixey> hmmm
13:56:14 <lispy> I guess that's why that definition of fix works, the one without the let
13:56:25 <vixey> How could we prove that :)
13:56:26 <vixey> ?
13:56:29 <lispy> Do you know the definition I mean?
13:56:36 <vixey> yes I have seen that
13:56:53 <b_jonas> BMeph: funnily this proves that exactly 35 presses is enough as well
13:57:00 <b_jonas> not just at most 35 presses
13:57:08 <lispy> vixey: I don't know how to prove that
13:57:14 <b_jonas> it happens to be the same for 1..23
13:57:29 <vixey> lispy: that fix, and Mu are -evidence-
13:57:31 <BMeph> lispy: What one without let? :)
13:57:31 <lispy> vixey: I'm not very good with, let F be an infinite type ...
13:57:32 <b_jonas> it's a nice one-liner
13:57:34 <b_jonas> I like it
13:57:50 <lispy> BMeph: do you know the standard haskell definition of fix?
13:57:57 <Toxaris> lispy: proof what? that you can encode every algebraic data type as a fold?
13:58:00 <vixey> ?go haskell y combinator
13:58:00 <lambdabot> No Result Found.
13:58:11 <vixey> http://r6.ca/blog/20060919T084800Z.html
13:58:12 <lambdabot> Title: Y Combinator in Haskell
13:58:28 <lispy> BMeph: there is a non-standard one that uses recursive data types to get around an infinite construction
13:58:28 <BMeph> b_jonas: What happens to be the same? And what is it the same as? :)
13:58:33 <vixey> :t (\x -> f ((out x) x)) (In (\x -> f ((out x) x)))
13:58:57 <lispy> gah, lambdabot swallow the type error again
13:59:10 <BMeph> lispy: Hmm, do you have a reference? I'm not sure that I have it right in my head.
13:59:17 <vixey> :t \f -> (\x -> f ((out x) x)) (In (\x -> f ((out x) x)))
13:59:38 <lispy> BMeph: it's in the link vixey found: http://r6.ca/blog/20060919T084800Z.html
13:59:39 <lambdabot> Title: Y Combinator in Haskell
13:59:53 <b_jonas> > (!!10) $ iterate ((+1)***nub.ap [(*2),(`div` 10)]) $ (0,[1]) -- numbers you can get with exactly 10 keypresses
13:59:55 <lambdabot>  (10,[1024,0,32,48,50,2,51,1])
14:00:02 <b_jonas> > (!!10) $ iterate ((+1)***nub.ap [id,(*2),(`div` 10)]) $ (0,[1]) -- numbers you can get with at most 10 keypresses
14:00:04 <lambdabot>  (10,[1,2,0,4,8,16,32,64,3,128,6,256,12,512,24,25,1024,48,50,51])
14:00:26 <jeffwheeler> What do you mean exactly keypresses?
14:00:31 <lispy> > let fix f = (\x -> f (x x))(\x -> f (x x)) in fix
14:00:32 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
14:00:32 <lambdabot>     Probab...
14:00:50 <lispy> BMeph: as you can see, the straigh \-calc def doesn't type
14:00:52 <jeffwheeler> I can type "1" in one keypress; I don't understand at all.
14:01:23 <lispy> so, we define this: newtype Mu a = Roll { unroll :: Mu a -> a }
14:01:31 <vixey> @src Mu
14:01:31 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:01:33 <b_jonas> BMeph: the solution for [1..23] happens to be 35 in either of those versions I evalled
14:02:32 <lispy> hrm, the @src definition is different
14:02:37 <b_jonas> jeffwheeler: Axman6 asked the question "you've been given a calculator with only two buttons (*2) and (`div` 10) and you need to get from 1 to all the numbers up to 23"
14:02:41 <vixey> I guess the biggest problem is stating the statement well enough
14:02:44 <b_jonas> jeffwheeler: that was very long ago
14:02:53 <b_jonas> liek four or five hours
14:03:01 <jeffwheeler> b_jonas: ah, I missed it; thanks
14:03:05 <BMeph> lispy: Okay, I see. But yes, recursive definitions makes it much easier to define. :)
14:03:09 <b_jonas> jeffwheeler: so we've been giving various solutions to it at that time
14:03:16 <Toxaris> oh that question was meant to go through all the numbes in one path?
14:03:20 <lispy> vixey: the def I pasted in Mu a -> a, but why is the @src one f (Mu f) ?
14:03:21 <BMeph> b_jonas: But they're the same definition... :)
14:03:26 <jeffwheeler> b_jonas: yeah, didn't realize that last one was the same
14:03:37 <b_jonas> BMeph: how so?
14:03:53 <vixey> lispy: well I think this Mu is more general
14:04:03 <vixey> since e.g.
14:04:04 <BMeph> b_jonas: How not so? :)
14:04:05 <vixey> :k Mu []
14:04:05 <lambdabot> *
14:04:30 <b_jonas> BMeph: well, after exactly 1 keypresses, you can get any of [0,1,2]
14:04:37 <b_jonas> no, wrong
14:04:40 <b_jonas> BMeph: well, after exactly 1 keypresses, you can get any of [0,2]
14:04:46 <b_jonas> BMeph: well, after at most 1 keypresses, you can get any of [0,1,2]
14:05:22 <b_jonas> BMeph: well, after exactly 2 keypresses, you can get any of [0,4]
14:05:27 <b_jonas> BMeph: well, after at most 2 keypresses, you can get any of [0,1,2,4]
14:05:30 <b_jonas> etc
14:05:42 <b_jonas> the list becomes somewhat more interesting later
14:05:46 <vixey> > let d = (*2) ; n = (`div`10) in flip replicateM "nd" =<< [1..]
14:05:47 <lambdabot>  ["n","d","nn","nd","dn","dd","nnn","nnd","ndn","ndd","dnn","dnd","ddn","ddd"...
14:05:58 <b_jonas> the list for 35 is the first that contains each number in [1..35]
14:06:21 <vixey> > let d = (*2) ; n = (`div`10) in map (($1).foldr (.) id) (flip replicateM [n,d] =<< [1..])
14:06:22 <lambdabot>  [0,2,0,0,0,4,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,...
14:06:36 <vixey> > let d = (*2) ; n = (`div`10) in map head . group $ map (($1).foldr (.) id) (flip replicateM [n,d] =<< [1..])
14:06:38 <lambdabot>  [0,2,0,4,0,8,0,16,0,1,0,32,0,3,0,2,0,64,0,6,0,6,0,4,0,128,0,12,0,12,0,12,0,8...
14:06:46 <lispy> What puzzle is this?
14:07:02 <b_jonas> lispy: see my answer to jeffwheeler
14:07:10 <BMeph> b_jonas: I get 40 as the first on for[1..35]. :)
14:07:23 <BMeph> It is 35 for [1..23], though. :)
14:07:35 <b_jonas> BMeph: yep, first 23
14:07:35 <byorgey> do we know that you can eventually get any integer?
14:07:39 <b_jonas> [1..23]
14:07:48 <byorgey> *positive integer
14:07:49 <lispy> b_jonas: lol, interesting calculator
14:07:54 <b_jonas> byorgey: yep, I said that
14:07:55 <vixey> > let d = (*2) ; n = (`div`10) in map head . group . sort $ map (($1).foldr (.) id) (flip replicateM [n,d] =<< [1..])
14:07:59 <lambdabot>  Tried to use too much memory
14:08:12 <b_jonas> byorgey: you even get all of them if you just press *2 lots of times first then `div`10 lots of times
14:08:18 <ddarius> You guys are still working on this crap?
14:08:27 <b_jonas> byorgey: that is, you can get any positive integer that way
14:08:32 <b_jonas> ddarius: there was a long pause
14:08:36 <vixey> I only started like 1 min ago
14:08:37 <vixey> !
14:08:42 <byorgey> b_jonas: that seems intuitive to me, but do you have proof?
14:08:45 <humasect> > pl 4 ($ ($) 5)
14:08:45 <b_jonas> ddarius: BMeph gave a nice one-liner
14:08:46 <lambdabot>   Not in scope: `pl'
14:08:47 <jeffwheeler> it's a really, really interesting problem
14:08:49 <b_jonas> byorgey: sure
14:09:10 <vixey> I don't think it's very interesting
14:09:12 <vixey> :p
14:09:14 <b_jonas> byorgey: you can get every 2**n, right?
14:09:14 <jeffwheeler> @pl 4 ($ ($) 5)
14:09:15 <lambdabot> 4 ($ 5)
14:09:21 <byorgey> b_jonas: of course
14:09:23 <jeffwheeler> humasect: ^
14:09:24 <humasect> @pl 4 (($) 5)
14:09:24 <lambdabot> 4 5
14:09:33 <b_jonas> byorgey: now 2**n is 10**(c*n) where c is an irrational number
14:09:38 <humasect> ah, thanks jeffwheeler=)
14:09:45 <jeffwheeler> humasect: no problem :)
14:09:49 <humasect> ^_^
14:10:03 <byorgey> b_jonas: ah, indeed
14:10:12 <b_jonas> byorgey: and you know how the set [floor(c*n)|n<-[1..]] is dense on the interval 0..1
14:10:19 <byorgey> b_jonas: right
14:10:21 <byorgey> ok, cool
14:10:24 <b_jonas> if c is irrational
14:10:33 <vixey> b_jonas: nice
14:10:35 <humasect> @pl (&) a b = a (($) b)
14:10:35 <lambdabot> (line 1, column 9):
14:10:35 <lambdabot> unexpected "="
14:10:35 <lambdabot> expecting variable, "(", operator or end of input
14:11:02 <b_jonas> so if your aim is the integer 10**x*y where 1<=y<10,
14:11:12 <BMeph> b_jonas: Smooooth. ;)
14:11:24 <b_jonas> you just choose a logarithm from that set that is between log(y) and log(y+10**(-x))
14:11:33 <b_jonas> where x is a natural number
14:11:46 <humasect> @pl f $ b
14:11:46 <lambdabot> f b
14:12:02 <b_jonas> so the starting digits of that power of two is exactly right
14:12:04 <xor_> I'm making a 15 puzzle solver that uses A* search. In Java, I would give each puzzle state a pointer to its parent state to track the solution path. In prolog, I would use dynamic assertions to track parent states. In Haskell, what are my options? Do I have to use monads here?
14:12:19 <b_jonas> is that clear or should I expand it?
14:12:25 <humasect> @pl f (unsafeCoerce b)
14:12:25 <lambdabot> f (unsafeCoerce b)
14:12:30 <humasect> ah there.
14:12:45 <vixey> xor_: What heuristic do you use?
14:12:51 <xor_> manhattan distance
14:13:00 <xor_> works quite well
14:13:06 <vixey> is that acceptable for htis?
14:13:06 <byorgey> b_jonas: that's quite clear to me
14:13:22 <xor_> yes, since mahattan distance is an admissible heuristic, it's acceptable for A*
14:13:25 <vixey> ok
14:13:33 <vixey> well.....
14:13:40 <Taejo> xor_: admissibility is not the only criterion
14:13:43 <xor_> don't see what that has to do with my question :)
14:13:48 <Taejo> xor_: it doesn't
14:13:50 <vixey> you sum the manhattan distance for each tile?
14:13:56 <humasect> @pl f (unsafeCoerce a) (unsafeCoerce b)
14:13:56 <lambdabot> f (unsafeCoerce a) (unsafeCoerce b)
14:13:59 <vixey> that's a bit different
14:14:01 <xor_> that's right.
14:14:10 <xor_> It's an underestimate and therefore admissible.
14:14:29 <vixey> well can you prove that?
14:14:39 <vixey> I don't know I might be able to find a counter example
14:14:55 <Wild_Cat> Ghost, are the Ubuntu Haskell-related packages obsolete. darcs 1, a version of Cabal that doesn't even install with the default ghc... ::sigh::
14:14:55 <Taejo> xor_: 0 is also an underestimate and therefore admissible, but you'd be better off with a non-admissable heuristic
14:15:07 <b_jonas> vixey: well, you surely cannot get to the goal faster than the manhattan distance
14:15:13 * BMeph suspects that vixey likes finding counter-examples more than proofs...
14:15:15 <b_jonas> vixey: so it is an underestimate
14:15:20 <xor_> I don't want to do best first search Taejo
14:15:20 <b_jonas> vixey: so I agree with xor_
14:15:21 <vixey> It's a permutation though
14:15:28 <b_jonas> it will find a shortest path
14:15:28 <xor_> vixes I can't prove it.
14:15:30 <vixey> not just a single distance
14:15:31 <ddarius> BMeph: A counterexample is a proof.
14:15:48 <xor_> But it has worked for me in the past, and my former AI prof agreed that it was an underestimate.
14:15:55 <lispy> Wild_Cat: what?
14:16:06 <BMeph> ddarius: Well, in the sense of a counter-proof, yes... ;p
14:16:27 <xor_> Actually, vixey, I can prove it's admissible.
14:16:31 <ddarius> BMeph: Also, have you ever read "Proofs and Refutations"?
14:16:35 <Toxaris> vixey: with every move, exactly one non-empty tile moves exactly one position, so it manhattan-distance from it's target can decrease by maximal 1
14:16:43 <tibbe> I get  "bench: /tmp/outfile: openBinaryFile: resource busy (file is locked)" after trying to write to a file I've reopened after closing it.
14:16:44 <xor_> Since it has to be an underestimate, or at most, equal to the actual distance.
14:16:48 <Wild_Cat> lispy: in Hardy, ghc is v6.8.2, but trying to install libghc6-cabal-dev barfs because it requires ghc <6.6.1
14:17:00 <Toxaris> vixey: so the sum of the manhattan distances of all tiles from their targets decrease by maximal 1 per move
14:17:09 <BMeph> ddarius: Never heard of it. :)
14:17:10 <lispy> Wild_Cat: ah, hmm
14:17:28 <lispy> Wild_Cat: I thought cabal comes with ghc now
14:17:31 <Toxaris> vixey: the sum of the manhattan distances is 0 for a solved puzzle
14:17:32 <Wild_Cat> I should file a bug report. Something tells me whoever packaged it mistyped >6.6.1, but I may be wrong.
14:17:39 <Wild_Cat> lispy: how do I find out?
14:17:41 <Toxaris> vixey: so the sum of the manhattan distances is a lower bound of the moves still to be made
14:17:46 <vixey> is this not a counter example?
14:17:47 <vixey> 123                         123
14:17:47 <vixey> 468                          56
14:17:48 <vixey> 75  4 moves - distance 3    478 3 moves - distance 3
14:17:53 <b_jonas> ddarius: that's a good book
14:17:56 <lispy> Wild_Cat: Not 100% this is the way, but try ghc-pkg list | grep -i cabal
14:18:17 <tibbe> and I'm not using lazy I/O
14:18:22 <xor_> http://pastebin.com/d23a878bc <-- see prioritizeManhattan for my heuristic
14:18:32 <vixey> xor_: (btw it wouldn't mean A* wouldn't work just that it's not guaranteed to give the shortest solution)
14:18:34 <xor_> err, findManhattan
14:18:46 <Wild_Cat> lispy: bingo. Cabal is there all right. That explains why libghc6-cabal-dev refuses to install, then :p
14:18:51 <Toxaris> vixey: since 4 >= 3 and 3 >= 3, that's not a counter example
14:18:53 <xor_> vixey my prioritizing is not only based on heuristic but also on depth
14:19:01 <lispy> tibbe: if you can find a bug in ghc related to that, I would love to hear it.
14:19:08 <vixey> Toxaris: ahh I understand
14:19:23 <xor_> P(x) = H(x) + Depth
14:19:31 <Toxaris> vixey: *under*estimate is the key to A* :)
14:19:36 <ddarius> BMeph: Go find it and read it.  It's short.  "Proof and Refutations" by Imre Lakatos
14:19:40 <xor_> Toxaris: exactly
14:19:52 <Wild_Cat> ...however, it seems my version of GHC is obsolete, seeing that I'm trying to install yi which requires a version of Cabal way higher than mine.
14:20:07 <Wild_Cat> (>=1.4 vs 1.2.3)
14:20:12 <tibbe> lispy: I wonder if it's repeatable on a linux system, anyone care to try?
14:20:16 <olsner> Wild_Cat: you can upgrade cabal yourself, 1.4.0.1 is on hackage
14:20:18 <xor_> Now... how can I track parent states in my search tree without using ridiculous amounts of memory?
14:20:26 <Wild_Cat> aha. Interesting.
14:20:35 <lispy> Wild_Cat: it's not that GHC is obsolete, but cabal is a moving target.  Just download and install a newer cabal and then also get cabal-install
14:20:36 <vixey> xor_: maybe recursion ?
14:20:39 <Wild_Cat> (yeah, in case you're wondering, I'm still a Haskell n00b)
14:20:46 <seliopou> xor_: I've implemented A* in Haskell before
14:21:00 <vixey> Cale has released an A* implementation recently
14:21:06 <xor_> seliopou, how do you track the path?
14:21:08 <seliopou> First, you need to decide how you're going to represent your search space: tree or graph
14:21:38 <xor_> OK, tree.
14:21:46 <seliopou> ok, good
14:21:46 * BMeph goes to read...
14:21:47 <Taejo> underestimate is not the key to A*... it will find a path with any heuristic. If the heuristic underestimates, you get a slower runtime but the shortest path; if you overestimate, you aren't guaranteed the shortest path. If you estimate correctly, you get blazing-fast runtime and the shortest path
14:21:57 <seliopou> So, define your state space
14:22:06 <xor_> Taejo, A* is guaranteed to find the shortest path.
14:22:06 <seliopou> What comprises a state?
14:22:09 <xor_> If it doesn't it's not A*
14:22:17 <seliopou> (with an admissible heuristic)
14:22:26 <Taejo> xor_: as seliopou says
14:22:26 <xor_> A state is a 15 puzzle in a particular configuration
14:22:40 <seliopou> Ok, so it's your game board
14:22:58 <seliopou> However, you decided to represent your search space as a tree, not a graph
14:23:00 <Taejo> in gaming you sometimes use non-admissable heuristics because you want speed but don't care if your path is slightly suboptimal
14:23:03 <xor_> Yeah. I have it represented as a tuple (Priority, Puzzle)
14:23:03 <Toxaris> Taejo: maybe "the key" was to strong, but my point was that underestimating heuristics guarantuee something, not overestimating
14:23:03 <seliopou> so equality is an issue here
14:23:19 <seliopou> you need to be able to distinguish the same board configurations that you arrived at in different ways
14:23:19 <xor_> The puzzle is represented as a 16 character String.
14:23:29 <seliopou> (those can't be identical in a tree)
14:23:38 <seliopou> priority?
14:23:51 <seliopou> priority = f?
14:24:11 <Toxaris> what about storing a reversed path with every state?
14:24:13 <seliopou> or h?
14:24:19 <Taejo> Toxaris: ok. I'm a bit sensitive on this issue... I had a little fight with my ICFP teammate where he refused to use a slightly non-admissible heuristic, even though it was more important to get *a* path than to get the best one
14:24:30 <xor_> seliopou, not following you
14:24:56 <tibbe> come someone please run a small program on their linux machine to see if a bug can be repeated there before I submit it to GHC? I suspect it can have something to do with OS X's file name insensitivity
14:24:57 <seliopou> ok, in your state, there are two kinds of data: data that determines identity, and data that doesn't
14:25:05 <Zao> tibbe: Sure.
14:25:07 <Taejo> tibbe: no problem
14:25:15 <seliopou> Your board state and the depth of the state should determine identity
14:25:27 <xor_> Right. Sorry to be confusing. The actual puzzle state is determined by simple String equality.
14:25:27 <seliopou> things like priority and and a reverse path, should not
14:25:37 <seliopou> (I guess I just gave away the answer)
14:25:43 <tibbe> Zao: Taejo: http://hpaste.org/9475
14:25:48 <seliopou> Actually, the priority should determine identity as well I guess
14:25:51 <Zao> This is 6.8.2 though.
14:25:54 <xor_> To test whether two states are equal I just test the Strings.
14:26:06 <seliopou> xor_: if you do that, you're dealing with a graph
14:26:09 <xor_> seliopou not quite as two equal states might be arrived at, at different depths
14:26:12 <b_jonas> priority means the number of steps you already did to get to that state?
14:26:18 <Toxaris> seliopou: isn't the priority a function of the board and the length of the reversed path
14:26:44 <seliopou> Toxaris: priority is a function of the board state and the _cost_ of the path
14:26:48 <seliopou> but not the path itself
14:26:58 <Toxaris> seliopou: cost of the path = length of the path here
14:27:20 <twobitwork> > let permute n l = concatMap (\x -> sequence (takeRepeat l x)) [1..n] in permute 10 [1,0]
14:27:20 <Taejo> tibbe: do I need to create /tmp/infile?
14:27:20 <lambdabot>   Not in scope: `takeRepeat'
14:27:21 <Toxaris> or are some slides more costly then others?
14:27:33 <Zao> tibbe: bench: /tmp/outfile: openBinaryFile: resource busy (file is locked)
14:27:35 <tibbe> Taejo: yes unfortunately, copy any 10mb file there
14:27:39 <seliopou> Toxaris, I'm speaking more generally than I should, I suppose
14:27:41 <tibbe> Zao: OS?
14:27:51 <twobitwork> > let permute n l = concatMap (\x -> sequence (take x . repeat $ l)) [1..n] in permute 10 [1,0]
14:27:52 <Zao> tibbe: This is Ubuntu 8.04, ghc 6.8.2, 32-bit.
14:27:52 <lambdabot>  [[1],[0],[1,1],[1,0],[0,1],[0,0],[1,1,1],[1,1,0],[1,0,1],[1,0,0],[0,1,1],[0,...
14:28:02 <seliopou> the point I'm trying to get across is that choosing your definition of identity in this problem is crucial
14:28:04 <twobitwork> is there a more efficient way of doing that?
14:28:09 <seliopou> quite possibly the most important part of the problem
14:28:09 <tibbe> Zao: could you also please stare at the code for a second to see if I made some obvious stupid misstake?
14:28:14 <tibbe> Zao:
14:28:18 <tibbe> Zao: OK
14:29:11 <Toxaris> seliopou: what do you do with this identity?
14:29:13 <Zao> tibbe: Should you really recurse into go without closing the files?
14:29:35 <seliopou> Toxaris: A* :P
14:30:04 <Toxaris> seliopou: isn't A* just graph traversal with a priority queue?
14:30:14 <Toxaris> seliopou: I don't see where you need identity
14:30:43 <xor_> When doing A* you avoid previously visited states. So you need a way to compare states.
14:30:51 --- mode: ChanServ set +b *!n=palomer@*
14:30:51 --- kick: temptemp was kicked by ChanServ (Banned: fixed*the*glitch)
14:30:55 <xor_> (I think that's what seliopou was talking about)
14:31:04 <tibbe> Zao: probably not :D
14:31:15 <seliopou> if you're trying to solve a search problem, you need to define your search space and in particular determine when two states are equivalent
14:31:19 <seliopou> that is your _first_ concern
14:31:39 <seliopou> xor_: yes
14:31:48 <tibbe> Zao: that's probably it
14:31:52 <seliopou> trust me, it's worth spending the time to think through this now. It will save you a lot of time later
14:32:06 <xor_> I've written a functioning A* in Haskell. I just need a way to get the path out of it now :)
14:32:14 <Toxaris> but xor_ said he treats his search space as a tree. that sounded to me like he doesn't want any identities (because otherwise, it is a graph, and you want to know when you reach the same node again)
14:32:36 <xor_> Toxaris I guess I lied to you about that.
14:32:36 <seliopou> Toxaris, I'm talking about defining the identity _relation_ on his search space
14:33:05 <xor_> It's technically a graph because generating the next states can lead to cycles. But by comparing the current states with the visited states we can avoid those cycles.
14:33:11 <seliopou> So if he doesn't want any nodes to be identical, his identity relation better be empty!
14:33:52 <Toxaris> xor_, seliopou: I understand that you are talking about this "comparing the currents tates with the visited states"
14:34:00 <Toxaris> and I don't see how that relates to xor_'s question
14:34:15 <xor_> Heh, me neither.
14:34:28 <xor_> My question is: how do I track parent states in Haskell?
14:34:36 <seliopou> ngh
14:34:46 <b_jonas> obviously, as during the search you only keep one of the shortest routes to each state
14:34:49 <b_jonas> so it's a tree
14:34:57 <seliopou> ok, I see I'm beating aroudn the bush a bit too much.
14:34:59 <xor_> In Java I would use pointers. In prolog I would use dynamic assertions.
14:35:04 <xor_> ...
14:35:21 <Toxaris> xor_: I already told you to store the path from the state to the initial state in each state
14:35:33 <seliopou> If your state is (priority, board), just throw in another property being the list of actions you chose to get to the current state
14:35:42 <Toxaris> xor_: so that when you reach the goal, you have the path from the final state to the initial state, and can reverse it
14:35:48 <xor_> Toxaris that solution occurred to me too, but wouldn't that use gobs of space?
14:35:58 <seliopou> and what I was trying to tell you is you need to define a new type, with an eq and ord instance ignoring that list
14:36:17 <xor_> For example, to find a 40 move solution to a 15 puzzle, millions of search iterations are required.
14:36:27 <b_jonas> xor_: no, because you'd just have to store the move, and there are four possible moves
14:36:34 <seliopou> xor_: your solutions aren't going to be 40 moves long
14:36:48 <xor_> Um, some solutions are longer than that.
14:36:53 <b_jonas> xor_: but for that reason it also wouldn't take too much to track back the moves otherwise
14:37:07 <b_jonas> xor_: so I think it's probably best not to store the moves
14:37:08 <Toxaris> xor_: and you have to store all these states in a priority queue, and each of them has a new board represented by a string
14:37:14 <b_jonas> xor_: not more elegant but faster
14:37:15 <Toxaris> xor_: whereas the paths have shared tails
14:37:23 <Cale> Did you try my implementation of A*?
14:37:42 <xor_> Cale I'm trying to devise my own based on an implementation I did last year in my AI class.
14:37:47 <Toxaris> xor_: so to store the paths is no problem, but your representation of the board as a string may be
14:37:48 <Cale> ah, okay
14:38:07 <b_jonas> Cale: how does yours work?
14:38:17 <Cale> I just translated the imperative code on wikipedia into purely functional code in a fairly straightforward way, and it works fine.
14:38:30 <xor_> The board could be represented as a 64 bit unboxed integer, but that's kind of a pain.
14:38:43 <xor_> I can do that later when I want to optimize.
14:38:47 <Toxaris> seliopou: how doy ou know xor_ uses Eq or Ord methods in his code?
14:38:58 <tromp> what game is that, xor_?
14:39:04 <Cale> http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html is the haddock for it
14:39:05 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
14:39:08 <xor_> tromp: 15 puzzle
14:39:09 <seliopou> I will bet oodles and oodles of cash-money he did
14:39:19 <xor_> seliopou is correct in his assumption
14:40:01 <Cale> It's actually really nicely functional in the end -- the graph is represented by its neighbours function, the distance and heuristic are functions and the goal is an arbitrary predicate.
14:40:06 <tromp> bitboard sounds ideal to me
14:40:15 <Cale> I wanted to keep it independent of the representation of the graph.
14:40:39 <xor_> tromp: it fits perfectly in a Long. Each tile fits into 4 bits, 16 tiles altogether.
14:40:44 <mmorrow> tibbe: you need something like this: http://hpaste.org/9476 ... this is the fastest way i've found thus far to move data between handles in constant memory in haskell
14:40:48 <xor_> I did it that way in Java.
14:41:00 <Cale> (so if you're using some other graph type, you just partially apply your neighbours function)
14:41:04 <tromp> and you separatelt keep the location of the empty slot
14:41:12 <b_jonas> xor_: you mean a Word64?
14:41:29 <xor_> b_jonas: yes
14:41:40 <tibbe> mmorrow: great, I'm actually trying to judge whether it's worth the extra complexity of a mutable buffer in a new I/O library I'm writing
14:41:49 <tibbe> mmorrow: if the difference is around 5% it's not
14:41:58 <mmorrow> tibbe: cool
14:42:12 <tibbe> mmorrow: but I'll add that one to my benchmark
14:42:34 <mmorrow> tibbe: the fixed size buffer version is lifted verbatim from mohws
14:42:39 <Toxaris> seliopou: well, I wonde whether he should then consider not using it, instead of defining a non-standard Eq and Ord. I always fell uncomfortable with these, since you can have only one per datatype
14:42:48 <tibbe> mmorrow: what's that?
14:43:02 <mmorrow> tibbe: i tested it a while back, and it beat the equivalent bytestring code
14:43:15 <mmorrow> tibbe: simon marlow haskell web server
14:43:34 <mmorrow> the accompanying paper is really good
14:43:36 <seliopou> Toxaris, if he wants to store a the reverse path in his state, he has to define custom eq and ord instances
14:43:37 <tibbe> mmorrow: right now it looks like hGetBuf and hPutBuf beats ByteString by 12%
14:43:56 <tibbe> mmorrow: oh, I read it. Thought it was called HWS
14:44:01 <mmorrow> yeah
14:44:02 <Toxaris> seliopou: if he never uses ==, > and so on, it doesn't matter in any way which Eq and Ord instances he has
14:44:10 <seliopou> Toxaris, but he does
14:44:13 <mmorrow> tibbe: http://code.haskell.org/mohws/
14:44:14 <lambdabot> Title: Index of /mohws
14:44:23 <Toxaris> seliopou: and I think that if the standard instances doesn't suit him, he shouldn't
14:44:27 <seliopou> A* necessitates that
14:44:54 <Toxaris> in which way forces A* you to use (==) instead of (===) or equivalent or eq or whatever you want?
14:45:09 <seliopou> You put nodes in a priority queue
14:45:26 <seliopou> or states, if you will
14:45:47 <Toxaris> yes?
14:45:49 <xor_> The standard Ord and Eq work fine for me. When I test for equality I don't test based on the node value. I test based on the state value, eg, a String.
14:46:04 <xor_> When I order the nodes, the ordering is done based on the Priority, which is an integer value.
14:46:27 <xor_> PState = (Integer, String)
14:46:46 <seliopou> what are you putting into the priority queue? The Pair?
14:46:53 <Cale> What priority queue are you using?
14:46:54 <xor_> Correct.
14:47:19 <xor_> Cale: a fairly naive one based on lists and Data.List insert
14:47:29 <lispy> what is the correct layout to have a where block inside a where block?
14:47:30 <seliopou> Ok, let me try to be as clear as possible, because this is all I'm saying. If you define PState = (Integer, String, [String]) -- last one being the path back
14:47:30 <Toxaris> seliopou: see what I mean with "you don't know if seliopou uses Eq and Ord". I whould have said "you don't know how he uses them"
14:47:35 <Cale> Ah, there's PSQueue on hackage which is really nice
14:47:36 <lispy> foo ... =
14:47:39 <vixey> lispy: just indent it
14:47:40 <seliopou> you need custom eq and ord definitions
14:47:41 <lispy>   where bar ... =
14:47:42 <vixey>  where ...
14:47:45 <lispy>     where ...
14:47:45 <vixey>               where ...
14:47:49 <xor_> Thanks Cale, was looking for something like that.
14:47:57 <lispy> Hmm..
14:48:04 <xor_> What I really would like is a priority queue based on a fibonacci heap.
14:48:06 <vixey> (you don't have to do it -that- much)
14:48:29 <Cale> xor_: That one is more than just a priority queue, but also supports fast searching.
14:48:31 <xor_> seliopou why do I need custom Eq and Ord definitions?
14:48:32 <lispy> vixey: I will hpaste it
14:48:39 <Cale> xor_: It's based on balanced trees.
14:48:41 <lispy> vixey: it's got to be something simple, but I don't see it
14:49:08 <lispy> vixey: http://hpaste.org/9478
14:49:22 <vixey> lispy: try with 1 more space
14:49:33 <mmorrow> tibbe: here's the implem of hGetArray/hPutArray from Data.Array.IO http://hpaste.org/9476#a1
14:49:45 <tibbe> mmorrow: thanks
14:49:55 <lispy> vixey: huh, that works, thanks
14:50:06 <seliopou> Presumably you have a closed list: Set PState
14:50:20 <vixey> lispy: (I think the rationale is)
14:50:21 <vixey> f x =
14:50:22 <vixey> where
14:50:25 <vixey> is invalid
14:50:34 <vixey> so it should be one space past where the previous started
14:50:38 <seliopou> you don't want the path of the state to determine equality or ordering in the Set
14:50:39 <vixey> could be wrong about that though
14:50:44 <lispy> Okay, I think I got used to case
14:51:01 <xor_> seliopou I thought that the first element in the tuple would determine the ordering?
14:51:09 <seliopou> what if they're equal?
14:51:20 <xor_> On equal first elements, the paths are also equal.
14:51:26 <seliopou> not true
14:51:29 <seliopou> not at all true
14:51:33 <xor_> why?
14:51:43 <xor_> After all the priority is based on the heuristic, and the cost.
14:51:43 <Toxaris> seliopou: hmm ok I agree that you should seliopou tell that and shut up :)
14:51:46 <seliopou> priority = cost + heuristic
14:51:48 <seliopou> yes?
14:52:12 <xor_> Yes so a state that has equal priority and cost (i'm lumping them together for convenience) has the same path.
14:52:27 <seliopou> Fix a priority P = C + H
14:52:38 <seliopou> P = (C - 1) + (H + 1)
14:52:44 <seliopou> etc
14:52:56 <xor_> oh yeah, duh :)
14:52:59 <seliopou> P' = C' + H' where C' = C - 1 and H' = H + 1
14:53:29 <seliopou> Just gotta add zero
14:53:54 <seliopou> can you call me vindicated?
14:54:08 <xor_> Yes. I agree with what you're saying.
14:54:51 <xor_> However... does it really matter how I order tuples with equal first elements?
14:55:15 <vixey> :t sortBy ((<)`on`fst)
14:55:32 <EvilTerran> ?bot
14:55:32 <lambdabot> :)
14:55:39 <EvilTerran> ?type sortBy ((<)`on`fst)
14:55:40 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:55:49 <EvilTerran> ?type sortBy (comparing fst)
14:55:50 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:55:53 <xor_> @type sortBy ((<)`on`fst)
14:55:53 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:56:02 <EvilTerran> ?type sortBy
14:56:02 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
14:56:04 <EvilTerran> ?undef
14:56:05 <lambdabot> Undefined.
14:56:07 <EvilTerran> ?type sortBy (comparing fst)
14:56:07 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
14:56:34 <EvilTerran> i think sort, as defined in the report, must be stable
14:56:52 <seliopou> xor_: if priority is equal, and the states are equal, which one are you supposed to pick
14:56:55 <seliopou> does it matter?
14:57:00 <EvilTerran> so, if two otherwise distinguishable elements compare as EQ, they'll end up in the order they were in originally
14:57:24 <seliopou> EvilTerran: The Eq and Ord instances are being used in a set
14:57:30 <seliopou> if they compare as eq, one of them goes away
14:57:32 <xor_> seliopou, I suppose you would want to pick the element with the shortest path. But wouldn't you already get that with the current implementation?
14:57:39 <EvilTerran> i see
14:57:54 <xor_> < [] < [1]
14:58:03 <Toxaris> > insert 'x' "xxx"
14:58:04 <lambdabot>  "xxxx"
14:58:12 <Toxaris> seliopou: ^^^^^ no set
14:58:24 <EvilTerran> seliopou, do you mean Data.Set, or list-as-set?
14:58:29 <seliopou> Data.Set
14:58:45 <xor_> I'm not using a set. I'm using a list.
14:58:51 <seliopou> xor_: ... why?
14:59:08 <ddarius> Data abstraction is for pansies.
14:59:11 <xor_> Because this is the first time I've constructed a program in Haskell, and I really don't see why not.
14:59:39 <Toxaris> hehe well it's slow, of course :) a good choice for a priority queue is a heap
15:00:02 <seliopou> (Data.Set has getMin/Max functions)
15:00:15 <EvilTerran> seliopou, as does Data.Map, which may be more appropriate
15:00:25 <EvilTerran> i'm not entirely sure what's going on here, so i can't say
15:00:28 <seliopou> EvilTerran, How's that?
15:00:31 <seliopou> lol
15:00:34 <seliopou> k
15:00:46 <EvilTerran> but it sounds like you have seperate priority numbers and values
15:00:48 <Toxaris> isn't Data.Set basically = Data.Map with () values?
15:00:59 <opqdonut> Toxaris: yes
15:01:07 <EvilTerran> so it'd make sense to have a Map {priority} {other stuff}
15:01:17 <opqdonut> ?src Data.Set.Set
15:01:17 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:01:23 <Toxaris> EvilTerran: but you have different other stuffs for the same priority
15:01:28 <EvilTerran> instead of a Set ({priority}, {other stuff}) or a [({priority}, {other stuff})]
15:01:38 <Toxaris> EvilTerran: so you need [other stuff] and extra processing to use them on after another
15:01:48 <EvilTerran> Toxaris, ok, make it a Map Priority (Set OtherStuff) or something them
15:01:49 <EvilTerran> *then
15:02:14 <seliopou> EvilTerran, I was envisioning Set State, with the definition of Ord determining priority
15:02:29 <EvilTerran> make your data structures fit your problem as closely as possible
15:02:29 <seliopou> (the definition of Ord for State)
15:02:40 <EvilTerran> this is a declarative language, after all - data structures are all we have :P
15:02:43 <opqdonut> you could probably define mimimum in an appropriate way
15:02:46 * Toxaris still thinks that Data.Set has too much structure, and a heap would be faster and more memory efficient
15:03:12 <ddarius> this is a functional language, after all - control structures are all we have
15:03:23 <xor_> A heap would be faster and more memory efficient but as this is my first haskell program I am going for correctness first :)
15:03:36 <EvilTerran> ddarius, control structures are data. whoever named Data.Function clearly agrees with me. :P
15:03:50 <lispy> -fno-warn-orphan was that the flag?
15:04:09 <Toxaris> EvilTerran: There is Control.* for some stupid reason and keep not getting. But people here keep telling me that it makes sense for them
15:04:18 <Toxaris> s/and/I
15:04:42 <lispy> on with an s
15:04:46 <lispy> er, -fno-warn-orphans
15:04:48 <ddarius> EvilTerran, data structures are control.  whoever name Control.Monad.List clearly agrees with me.
15:05:10 <EvilTerran> ddarius, i think we're in vigorous agreement
15:05:24 <vixey> data structures the ultimate for(int i = 0; i < n; i++)!
15:05:24 <ddarius> EvilTerran: I know we are.
15:05:45 <vixey> data structures the ultimate GOTO 10
15:06:00 <EvilTerran> "data structures considered evil"
15:06:15 <noohgodno> not only data structures
15:06:16 <noohgodno> data itself
15:06:23 <noohgodno> it makes spaghetti code
15:06:25 <EvilTerran> i'd go for "users", personally
15:06:27 <kig> you can use combinators to make data
15:06:38 <tibbe> what would be the type of a monad transformer like StateT that does IO?
15:06:39 <xor_> Q: How do you split a hair infinitely?
15:06:45 <xor_> A: Ask an IRC room.
15:06:46 <tibbe> I want to hide some data in a monad for convenience
15:06:57 <EvilTerran> tibbe, er, you can't use IO as a transformer
15:07:03 <noohgodno> my hairsplitting is only there for contrast
15:07:14 <tibbe> EvilTerran: transformer wasn't the right word I gues
15:07:16 <EvilTerran> IOT [] a would require the ability to fork the universe
15:07:52 <tibbe> EvilTerran: I basically want to be able to time I/O actions by calling 'start' and 'stop' and hide the start time somewhere
15:07:53 <Toxaris> xor_: thats easy: iterate split hair
15:07:55 <EvilTerran> and IOT (Cont c) a would be time travel!
15:08:00 <tibbe> EvilTerran: a global IORef won't work
15:08:34 <Toxaris> tibbe: you can use StateT IO, and liftIO from MonadIO to access the IO at the bottom of the transformer stack
15:08:38 <EvilTerran> well, you'll need to pass in a value for "somewhere"
15:08:50 <EvilTerran> you could use StateT, yes
15:08:59 <tibbe> right
15:09:05 <EvilTerran> or you could pass in the IORef using ReaderT
15:09:07 <EvilTerran> or whatever
15:09:10 <noohgodno> the federal reserve was directly implicit in JFK's assassination - why else would the former president of the world bank be on the Warren Commission?
15:09:14 <noohgodno> you're being exploited 24/7
15:09:20 <EvilTerran> StateT would probably be nicer
15:09:37 <noohgodno> your responsibility as a coder isn't your own success
15:09:38 <EvilTerran> noohgodno, er, wrong tab?
15:09:48 <EvilTerran> this isn't #fnord
15:09:48 <noohgodno> you create the platform for the defeat of centralized media
15:11:18 <Toxaris> tibbe: did you consider time :: IO a -> (IO a, Time), similiar to the shell builtin?
15:11:36 <Toxaris> tibbe: no, time :: IO a -> IO (a, Time), of course
15:12:02 <tibbe> Toxaris: I could use that as a building block, I'm going to compute some percentiles too
15:12:28 <Toxaris> tibbe: that would allow you to do something like do ... (result, ellapsed) <- time $ do ...
15:12:41 <tibbe> Toxaris: right
15:13:19 <tibbe> Toxaris: the interface will probably be benchmark :: Monad m => Int -> m -> IO Stats
15:13:31 <tibbe> m ()
15:14:09 <Toxaris> tibbe: a function of this type can do nothing with the second argument
15:14:13 <tibbe> Toxaris: where's that time function you're talking about?
15:14:21 <Toxaris> tibbe: I propose that you write it :)
15:14:27 <Toxaris> tibbe: as the core of your timing library
15:14:30 <tibbe> Toxaris: oh, I wrote it already :)
15:15:39 <Toxaris> tibbe: approximately: time x = do t <- getTime >>= newIORef; x; getTime >>= subtract . modifyIORef
15:16:01 <vixey> that makes x is an IO a
15:16:05 <vixey> oh
15:16:05 <tibbe> Toxaris: right, do you think IORefs are neccesary?
15:16:23 <noohgodno> wait, what is #fnord
15:16:26 <Toxaris> tibbe: no of course not, I'm confused
15:16:37 <tibbe> vixey: what?
15:16:52 <Toxaris> tibbe: time x = t1 <- getTime; res <- x; t2 <- getTime; return (t2 - t1, x)
15:16:54 <vixey> tibbe: I don't know what question you are asking
15:17:12 <tibbe> vixey: you said x was IO
15:17:22 <Toxaris> tibbe: with this primitive, I don't see why you need to store intermediate timings "somewhere"
15:19:20 <tibbe> Toxaris: I'm going to run time n times and I also want x to be able to stop timing mid way through
15:20:07 <Toxaris> tibbe: so that the "timed region" of your code is no longer a lexical block?
15:20:54 <Toxaris> tibbe: maybe you can store the IORef in the closure of stop
15:21:03 <tibbe> Toxaris: it's supposed to run in the Benchmark monad which is StateT InternalState IO a
15:21:35 <tibbe> Toxaris: I'm trying to avoid having the user pass a token with some internal state around
15:22:00 <vixey> by user you mean, programmer?
15:22:53 <Toxaris> well, if you have a StateT anyway, you could keep either the timings or an IORef to the timings or whatever there
15:24:29 <tibbe> vixey: yes
15:24:40 <tibbe> Toxaris: that's what I'm planning
15:25:40 <Toxaris> tibbe: oh I just realized that I proposed the non StateT solution without you asking for one
15:25:45 <noohgodno> how does the compiler differentiate parentheses modifying the order of operations from parentheses indicating the parameter of a function
15:26:04 <Wild_Cat> hrmm. interesting. Or not. My attempts to install anything with cabal-get end up with a 404 error.
15:26:10 <Toxaris> noohgodno: the latter doesn't exist in Haskell
15:26:18 <noohgodno> ????
15:26:20 <Botje> noohgodno: functions don't need parentheses to denote their argument
15:26:21 <tibbe> Toxaris: I did consider it but I'm not sure how to hide the IORefs from the programmer
15:26:29 <noohgodno> oh well
15:26:29 <Botje> > head [1..5]
15:26:30 <lambdabot>  1
15:26:34 <Botje> no parens needed :)
15:27:01 <noohgodno> yuck
15:27:16 <dobblego> haha
15:27:16 <lambdabot> dobblego: You have 1 new message. '/msg lambdabot @messages' to read it.
15:27:45 <Wild_Cat> noohgodno: the reason behind this being that all functions in Haskell take one, and only one, argument.
15:28:11 <vixey> noohgodno: What are you saying "yuck" about?
15:29:29 <vixey> tibbe: You could store a stack, and have start/stop push and pop, with a break function which stops the timer but doesn't pop
15:29:30 <Botje> > foldr (*) 1 [1..5] -- beauty!
15:29:31 <lambdabot>  120
15:29:51 <ddarius> > product [1..5]
15:29:52 <lambdabot>  120
15:29:52 <ddarius> > 120
15:29:53 <lambdabot>  120
15:30:02 <tibbe> vixey: interesting thought
15:30:12 <tibbe> vixey: where would I store that stack, global IORef?
15:30:22 <vixey> anywhere
15:30:28 <vixey> except that
15:30:31 <vixey> :)
15:48:54 --- mode: irc.freenode.net set +o ChanServ
15:53:18 <xor_> wow the whole place is getting garbage collected
15:53:53 <SamB_XP> huh
15:54:34 <SamB_XP> do netsplits often cause clients to throw a fit?
15:55:42 <dmhouse> xor_: I just submitted a patch to haskell-mode that does sensible indentation on a line containing just a |.
15:55:48 <ziman> when are Product a and Sum a useful?
15:56:12 <xor_> dmhouse: :)
15:56:26 <opqdonut> ziman: for example in a Writer monad
15:56:36 <opqdonut> :i Writer
15:56:57 <Toxaris> opqdonut: good example.
15:57:28 <opqdonut> you want to gather up the sum of some things during a computation
15:58:26 <opqdonut> then you just add a WriterT (Product Integer) on top of your stack and tell the values
15:58:33 <ziman> i see, thanks
15:59:08 <opqdonut> (well actually you'd have to use tell.Product but anyway)
15:59:55 <mauke> deriving instance (Integral a) => Integral (Product a)
16:00:06 <mauke> wait, make that Num
16:00:13 <opqdonut> that
16:00:15 <opqdonut> 'd work
16:00:33 <mauke> preflex: quote
16:00:33 <preflex>  <mwc> C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
16:00:58 <opqdonut> heh
16:01:55 <mmorrow> lol
16:02:48 * mmorrow adds that one to his quotes txt file
16:05:15 * mmorrow loves stand-alone deriving
16:36:36 <tibbe> how can I get       rank p = round $ (n / 100) * p + (1 / 2)
16:36:41 <tibbe> to get the right types
16:36:51 <tibbe> it works in ghci since it defaults lots of values to Double
16:36:55 <tibbe> n and p are Ints
16:37:11 <mauke> if n is an Int, it won't work in anything
16:37:25 <RayNbow> @type (/)
16:37:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:37:33 <EvilTerran> ... wouldn't round (x + 1/2) be (ceiling x)?
16:38:08 <mauke> @check \x -> ceiling x == round (x + 0.5)
16:38:09 <lambdabot>   Not in scope: `myquickcheck''
16:38:30 <mauke> ceiling $ (fromIntegral n / 100) * fromIntegral p?
16:39:42 <tibbe> mauke: thanks
16:44:08 <EvilTerran> ... ok, so that's another bit of lambdabot that's broken
16:44:18 <EvilTerran> scheck went some time ago, iirc
16:44:24 <EvilTerran> @scheck \x -> ceiling x == round (x + 0.5)
16:44:25 <lambdabot>     Failed to load interface for `SmallCheck':
16:44:25 <lambdabot>       Use -v to see a list of ...
16:48:47 * Cale finishes a little 15-puzzle solver using his A* search :)
16:48:57 <stepcut> :)
16:49:21 <stepcut> Cale: does it use manhatten pair distance ?
16:49:33 <stepcut> /manhatten/manhattan/
16:49:39 <Cale> yeah
16:50:35 <Cale> I tried the "number of misplaced" distance, but that was ridiculously slow.
16:53:30 <tibbe> this is giving me a headache, how do I divide an Integer and an Int to get a Double?
16:53:41 <Cale> tibbe: fromIntegral n / fromIntegral m
16:56:53 <mmorrow> fromInteger means whatever the most optimal way to do convert it
16:57:24 <mmorrow> it seems to be mostly be rewritten using {-# RULE ... #-}s
16:57:35 <hackage> Uploaded to hackage: WebBits 0.9.1
16:57:35 <hackage> Uploaded to hackage: WebBits 0.9
16:58:10 <Cale> mmorrow: oh?
16:58:24 <tibbe> mmorrow: so for Integer I can always use fromInteger instead of fromIntegral?
16:58:39 <Cale> tibbe: you can, but there's little point in it.
16:58:51 <tibbe> Cale: ok
16:58:56 <dobblego> why does fromIntegral even exist?
16:59:01 <Cale> fromIntegral is the more general one
16:59:02 <mmorrow> Cale: yeah, i've noticed that browsing throught GHC.Int, GHC.<something-numeric>
16:59:09 <EvilTerran> it's easier to change your mind about types later if you use fromIntegral
16:59:24 <dobblego> er, fromInteger
16:59:40 <Cale> fromInteger exists because it's how Num guarantees that 0 and 1 exist, and also provides the mechanism for numeric literals.
16:59:41 <EvilTerran> fromInteger's the class method, i think
16:59:49 <SamB_XP> Cale: you confused
16:59:55 <EvilTerran> fromIntegral is written with fromIntegral
16:59:59 <SamB_XP> fromInteger is how 1 and 0 are implemented
17:00:06 <SamB_XP> (quite sadly, in fact!)
17:00:07 <EvilTerran> *with fromInteger
17:00:09 <EvilTerran> ?src fromIntegral
17:00:09 <lambdabot> fromIntegral = fromInteger . toInteger
17:00:10 <Cale> SamB_XP: right.
17:00:16 <EvilTerran> SamB_XP, that's what he said
17:00:20 <Cale> SamB_XP: uh, I don't see how I'm confused though.
17:00:35 <SamB_XP> oops
17:00:58 <Cale> fromInteger provides the canonical homomorphism Z -> R which you get with any ring R :)
17:00:59 <SamB_XP> I dunno what happened there
17:03:25 <mmorrow> Cale: here's all the RULES for fromIntegral in GHC.Int: http://hpaste.org/9480
17:03:25 <dons> interresting, http://www.reddit.com/comments/6vjor/webbits_haskell_for_manipulating_javascript/
17:03:27 <lambdabot> Title: WebBits: Haskell for manipulating JavaScript embedded in HTML : reddit.com, http://tinyurl.com/57kbyq
17:04:08 <SamB_XP> hmm.
17:04:38 <Cale> mmorrow: ah, so it'll get translated so as to not use the typeclass machinery when that's unnecessary?
17:04:41 <mmorrow> dons: perfect! now i can quit thrashing around trying to get a javascript parser/prettyprinter working and just write a quasiquoter already ;)
17:04:56 <dons> WebBits.JavaScript.Parser  and WebBits.Html.Parser look like they should be under Language.JavaScript and ..
17:05:26 <mmorrow> Cale: exactly
17:06:14 <Cale> dons: Too bad the Haddock hasn't been generated yet
17:06:20 <SamB_XP> hmm.
17:06:23 <mmorrow> dons: yeah, the Language.* namespace needs to be populated in general for sure
17:06:42 <SamB_XP> yeah, I guess using that fromInteger makes sense ...
17:08:57 <dons> hackage and libraries are leading to unstoppable victory :)
17:09:35 <mmorrow> impending inevitability
17:09:37 <SamB_XP> dons: all is not won!
17:09:50 <SamB_XP> we can simply fall back to using such languages as Coq and Agda
17:09:52 <dons> impending inevitability, just around the corner !
17:11:58 <dons> hehe and note that webbits came from the plt research group ...
17:12:10 <dons> surrender, or die!
17:12:37 <SamB_XP> surrendur to what?
17:13:01 <dons> what have you got?
17:13:04 <mmorrow> that which is impending!
17:13:17 <SamB_XP> a half dozen lousy compilers
17:13:29 <SamB_XP> ... several of which are gcc
17:13:51 <dons> you're really a half glass empty kind of person, SamB_XP. tell me something positive.
17:14:15 <SamB_XP> the other half of the dozen would contain really super compilers
17:14:29 <SamB_XP> but nobody has managed to write a compiler that small in a long time
17:15:02 <mmorrow> SamB_XP: i look forward to your release
17:16:22 <SamB_XP> hehe
17:16:37 <SamB_XP> I haven't even begun to write a typechecker yet
17:16:47 <SamB_XP> and the first one is almost guarenteed to be unmaintainable
17:18:21 <jeeves__> So, I'm having some trouble figuring out how to use Data.Binary.Get to convert a ByteString into a list of Word16. I see getWord16le and runGet, but I'm not sure how they're to be combined
17:18:37 <dons> jeeves__: what format is the data in the bytestring?
17:18:41 <dons> was it just a list you serialised?
17:18:45 <dons> or are you parsing some other format?
17:18:45 <lispy> hey dons
17:18:53 <jeeves__> It's the data chunk of a WAVE file
17:18:53 <dons> lispy hey dude
17:18:54 <lispy> you seem to be in a lively mood :)
17:19:00 <dons> lispy: kinda
17:19:17 <lispy> dons: we're getting quite a bit few new devs over in #darcs
17:19:22 <jeeves__> dons: I guess hard-coding that it's 16 bits is v. bad, but at the moment I'm just trying to figure things out
17:19:24 <lispy> s/bit//
17:19:26 <dons> lispy, i noticed a lot more activity
17:19:35 <lispy> dons: it's awesome
17:19:44 <dons> jeeves__: that's fine, so you can just keep parsing to eof or so?
17:19:48 <mauke> runGet (replicateM (B.length s) getWord16le) s
17:19:50 <lispy> We should have made it clear to the greater haskell community that we need/want help sooner
17:19:51 <mauke> hax
17:19:53 <dons> get'ting bytes, consing them on to alist.
17:19:55 * shapr sighs
17:20:04 <jeeves__> dons: exactly
17:20:05 <lispy> shapr: !! hi
17:20:10 <jeeves__> mauke: ah, replicateM
17:20:11 <dons> jeeves__: see mauke's
17:20:12 <shapr> hiya lispy
17:20:13 <jeeves__> sounds promising :)
17:20:18 <dons> a monadic loop
17:20:20 <mauke> except you need a `div` 2 in there
17:20:27 <Cale> lispy: Lots of publicity, eh? Could it be that GHC giving up on darcs is the best thing that ever happened to the project? :)
17:20:30 <dons> with the parsing state implicitly threaded, basically.
17:20:39 <jeeves__> I see
17:20:47 <dons> i think ghc moving to git is good for ghc . got a bunch of new people downloading the src.
17:20:54 <dons> so we'll see. maybe its all win? :)
17:21:11 <lispy> I like it when things are full of win
17:21:14 <Cale> dons: Downloading it simply because it's in git?
17:21:19 <dons> Cale, yep.
17:21:20 <lispy> Well, maybe we need some darcs-git synergry
17:21:28 <SamB_XP> dons: it's there now?
17:21:29 <dons> "oh, i can do that. let's see what ghc is made of"
17:21:32 <SamB_XP> where can I git it?
17:21:39 <jeeves__> They could do the New Coke thing and go back to darcs in a year or so, to get even more publicity
17:21:39 <heavensrevenge> hello
17:21:55 <dons> git clone git://github.com/ghc-hq/ghc.git
17:22:03 <SamB> jeeves__: no, they couldn't
17:22:11 <SamB> you can't go back to darcs from git
17:22:15 <heavensrevenge> just wondering sumthing
17:22:16 <dons> SamB is glass 3/4 empty.
17:22:24 <dons> ask away, heavensrevenge
17:22:26 <SamB> hg, though, could work ;-)
17:22:27 <jeeves__> SamB: Yeah, it was a joke :)
17:23:23 <lispy> SamB: why can't you go back?
17:23:35 <lispy> SamB: because git is totally awesomer or something?
17:23:38 <jeeves__> mauke: thanks for the tip
17:23:52 <heavensrevenge> ok im pretty new to Haskell
17:24:07 <heavensrevenge> but im trying to select members of a list that divide as an even int
17:24:08 <SamB> lispy: well, how do you move from a directed graph of filesystem trees to a pile of patches
17:24:09 <SamB> ?
17:24:16 <heavensrevenge> all i can get it this: [n/3 | n <- [1..50]]
17:24:22 <heavensrevenge> but it also includes floats
17:24:41 <mauke> > filter even [1..50]
17:24:43 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50]
17:24:47 <Cale> > [n `div` 3 | n <- [1..50], n `mod` 3 == 0]
17:24:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
17:25:08 <lispy> SamB: 7/8 empty :)
17:25:15 <lispy> SamB: um, tailor?
17:25:22 <heavensrevenge> but like.. in 1..10 slect 1,3,6,9
17:25:29 <Cale> > [n | n <- [1..50], n `mod` 3 == 0]
17:25:30 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48]
17:25:30 <SamB> lispy: in a meaningful way?
17:25:33 <heavensrevenge> any # divisible by 3
17:25:37 <mauke> > [d | n <- [1..50], (d, 0) <- divMod n 3]
17:25:38 <lambdabot>  Couldn't match expected type `[t]' against inferred type `(t1, t1)'
17:25:38 <heavensrevenge> in a list
17:25:40 <Cale> heavensrevenge: surely not 1 then ;)
17:25:46 <heavensrevenge> oops :P
17:25:49 <mauke> > [d | n <- [1..50], (d, 0) <- return $ divMod n 3]
17:25:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
17:26:04 <Cale> > [d | n <- [1..50], let (d, 0) = divMod n 3]
17:26:05 <lambdabot>   Irrefutable pattern failed for pattern (d, 0)
17:26:06 <SamB> what I am saying is that in moving you would lose a lot of information and most of what you'd get back would be waiting-for-things-to-fail-merging
17:26:08 <Cale> oh, right
17:26:13 <heavensrevenge> bah
17:26:21 <heavensrevenge> uhm, ok, like
17:26:29 <lispy> SamB: tools like tailor play out the history and record it into a new vcs
17:26:36 <heavensrevenge> [3x1, 2x3, 3x3, 3x4]
17:26:44 <lispy> SamB: so, yeah, reasonably meaningfully
17:26:50 <Cale> > [n | n <- [1..50], n `mod` 3 == 0]
17:26:51 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48]
17:26:56 <heavensrevenge> srry if im not relaying this explination too well lol
17:26:57 <Cale> heavensrevenge: anything wrong with that?
17:27:01 <heavensrevenge> AHA
17:27:21 <heavensrevenge> ok, and.. can that be used IN another list?
17:27:23 <SamB> lispy: how do you play back an acyclic digraph of file trees into a pile of patches?
17:27:38 <heavensrevenge> like, combining with n `mod` 5's results
17:27:52 <dcoutts> dons: so we gave a live demo of the new hackage-server this afternoon at AngloHaskell
17:27:59 <Botje> heavensrevenge: you could use the union function
17:28:01 <heavensrevenge> > [n | n <- [1..50], n `mod` 3 == 0][n | n <- [1..50], n `mod` 5 == 0]
17:28:02 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
17:28:03 <dcoutts> dons: it got recorded
17:28:06 <SamB> anyway, the acyclic digraph of file trees is a much simpler abstraction -- and does not leak
17:28:09 <dcoutts> audio anyway
17:28:13 <lispy> SamB: I don't know git, but I assume git has some sort of ordering on the changeset as theyare stored.  Can't you go through them and look at the changes and then record them else where?
17:28:17 <heavensrevenge> > [n | n <- [1..50], n `mod` 3 == 0]
17:28:17 <mauke> heavensrevenge: what's the expected output?
17:28:17 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48]
17:28:22 <heavensrevenge> > [n | n <- [1..50], n `mod` 5 == 0]
17:28:23 <lambdabot>  [5,10,15,20,25,30,35,40,45,50]
17:28:30 <heavensrevenge> then zip the lists i think
17:28:30 <SamB> lispy: what the heck is a changeset?
17:28:41 <Botje> heavensrevenge: no, not zip, union :)
17:28:49 <mauke> Botje: what's union?
17:28:51 <heavensrevenge> oh
17:28:58 <SamB> er. I mean, that's what git's model has to say on the subject ;-)
17:28:58 <dcoutts> dons: I talked about the HP and Lemmih demoed building a couple packages and uploading the reports back to hackage
17:29:00 <mauke> > [n | n <- [1..50], n `mod` 3 == 0 || n `mod` 5 == 0]
17:29:02 <lambdabot>  [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50]
17:29:02 <lispy> SamB: the set of things that changed, you do record something right?
17:29:08 <Botje> > [1,2,3] `union` [3..5]
17:29:09 <lambdabot>  [1,2,3,4,5]
17:29:16 <SamB> lispy: git doesn't know any such concept
17:29:19 <heavensrevenge> lol oh  my
17:29:26 <SamB> not at the core, anyway
17:29:28 <mauke> :t union
17:29:29 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:29:31 <heavensrevenge> i think that looks perfect
17:29:33 <lispy> SamB: git doesn't record changes?
17:29:33 <mauke> what witchery is this
17:29:35 <SamB> that's layered on top of the core model
17:29:46 <Botje> mauke: don't worry, it's O(n²)
17:29:49 <SamB> git records what was, not what changed
17:29:55 <mauke> Botje: of course
17:30:03 <mauke> why does it exist?
17:30:11 <dons> dcoutts: ok
17:30:21 <heavensrevenge> thank you mauke  :)
17:30:22 <dons> dcoutts: nice! so the demo was up?
17:30:25 <Botje> for when you want to union two silly lists :p
17:30:28 <mauke> @src union
17:30:28 <lambdabot> union = unionBy (==)
17:30:31 <dons> i'll check the video
17:31:11 <dcoutts> dons: there's audio, no video
17:31:36 <dcoutts> dons: we were serving it off a laptop on the local wifi, so we had people in the audience connect to the server
17:32:01 <lispy> SamB: nevertheless, i bet tailor supports git -> darcs.
17:32:28 <SamB> lispy: doesn't mean the results will be pretty
17:32:30 <heavensrevenge> hehe
17:32:39 <SamB> anyway, there are real reasons for the move
17:32:50 <heavensrevenge> let funny mm = [n | n <- [1..mm], n `mod` 3 == 0 || n `mod` 5 == 0]
17:32:53 <lispy> SamB: Yes, I'm well aware
17:32:58 <heavensrevenge> so i can use specified input
17:33:02 <heavensrevenge> what i was going for
17:33:09 <SamB> reasons that seem to relate to fundamental problems with darcs' concept
17:33:22 <lispy> SamB: I work on darcs and making the ghc devs happy was a big goal
17:33:39 <mauke> @undo funny mm = [n | n <- [1..mm], n `mod` 3 == 0 || n `mod` 5 == 0]
17:33:39 <lambdabot> funny mm = concatMap (\ n -> if n `mod` 3 == 0 || n `mod` 5 == 0 then [n] else []) [1 .. mm]
17:33:44 <sm> any way I can get ghc(i) to show String instead of [Char] in types ?
17:33:48 <mauke> @. pl undo funny mm = [n | n <- [1..mm], n `mod` 3 == 0 || n `mod` 5 == 0]
17:33:48 <lambdabot> funny = (flip (ap (if' . ap ((||) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5))) return) [] =<<) . enumFromTo 1
17:34:05 <Cale> sm: Well, you can use explicit type signatures that say String
17:34:26 <lispy> sm: I think you more less, just get used to it :(
17:34:31 <Cale> sm: Otherwise, it's tricky, because the two mean exactly the same thing.
17:34:55 <mmorrow> @ty [] :: [Char]
17:34:56 <Cale> (so transformations applied my the compiler might conceivably destroy the use of the synonym)
17:34:57 <lambdabot> [Char]
17:35:00 <mmorrow> @ty [] :: String
17:35:01 <lambdabot> String
17:35:09 <sm> yes, so it seems a reasonable cosmetic change that would save me some thought
17:35:22 <SamB> Cale: is that truly possible?
17:35:43 <Cale> SamB: I'm not sure, it depends on what's happening to the types :)
17:35:43 <SamB> I thought it was only when YOU applied functions to things that that sort of thing happened
17:36:07 <mmorrow> @ty [] :: [[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]
17:36:08 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
17:36:18 <SamB> hahah
17:36:38 <Cale> not enough args
17:36:44 <Cale> @ty [] :: [[[[[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]]]]
17:36:45 <lambdabot> forall a. [[[[[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]]]]
17:36:53 <mmorrow> ohhh, hah
17:37:12 <Cale> though the error message you get is a bit funny :)
17:37:17 <Cale>     `[]' is not applied to enough type arguments
17:37:17 <Cale>     Expected kind `*', but `[]' has kind `* -> *'
17:37:17 <Cale>     In the type `[[]]'
17:37:17 <Cale>     In the type `[[[]]]'
17:37:17 <Cale>     In the type `[[[[]]]]'
17:37:19 <Draconx> heh, those masses of square brackets line up :)
17:37:25 <mmorrow> got so wrapped up in counting keytaps i forgot about the content
17:37:29 <sm> is there a way to :step up ? out of the current context ?
17:40:18 <dons> dcoutts: awesome.
17:40:57 <dcoutts> dons: aye, went down reasonably well
17:42:27 <mmorrow> dcoutts: nice! it seems you got enough done in time then :)
17:42:36 <dcoutts> mmorrow: yep :-)
17:43:01 * dcoutts is now exhausted and will retire to bed
17:43:14 <mmorrow> gnight
17:46:02 <tibbe> is it possible to user generalized newtype deriving with MonadTrans?
17:46:36 <SamB_XP> tibbe: it is not wise to try
17:47:02 <SamB_XP> if it could even make sense, it would not do what you wanted
17:47:09 <SamB_XP> but I don't think it can make sense
17:47:20 <tibbe> SamB_XP: I had type Benchmark = StateT S IO a
17:47:28 <tibbe> which gave me the MonadTrans of state
17:47:37 <tibbe> now I want to have a newtype and keep the same behavior
17:47:41 <mauke> I don't see why not
17:48:12 <Philonous> pjdelport: Are there any books you'd recommend for learning Haskell?
17:49:02 <pjdelport> Philonous: i have Paul Hudak's Haskell School of Expression
17:49:06 <pjdelport> http://www.haskell.org/soe/
17:49:06 <lambdabot> Title: Home Page
17:49:30 <pjdelport> which is pretty enjoyable
17:49:47 <SamB_XP> tibbe: well you can't expect lift to still work
17:49:56 <SamB_XP> just use liftIO
17:50:22 <tibbe> SamB_XP: that's all I want
17:50:23 <tibbe> liftIO
17:50:26 <pjdelport> Philonous: i can't really recommend anything authoritatively, though
17:50:38 <pjdelport> i haven't ready any other books
17:50:41 <SamB_XP> that has nothing to do with deriving (MonadTrans)
17:51:07 <Philonous> Thanks a bomb
17:51:08 <pjdelport> Philonous: oh, aside from http://en.wikibooks.org/wiki/Haskell, obviously
17:51:09 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
17:51:21 <SamB_XP> @quote oops
17:51:22 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
17:51:25 <SamB_XP> @quote oops
17:51:25 <lambdabot> ghc says: Oops!  Entered absent arg
17:51:27 <SamB_XP> @quote oops
17:51:27 <lambdabot> Spark says: "oops, we proved the wrong property"
17:51:29 <SamB_XP> @quote oops
17:51:30 <lambdabot> Spark says: "oops, we proved the wrong property"
17:51:31 <SamB_XP> @quote oops
17:51:31 <lambdabot> ghc says: Oops!  Entered absent arg
17:51:33 <SamB_XP> @quote oops
17:51:33 <lambdabot> ghc says: Oops!  Entered absent arg
17:51:37 <pjdelport> Philonous: which is a great online tutorial
17:51:39 <SamB_XP> @quote didn't
17:51:40 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
17:51:40 <lambdabot> just don't know what it means.
17:51:48 <SamB_XP> @quote fork
17:51:49 <lambdabot> sorear says: We need to fork #haskell.  I can't read fast enough.
17:51:50 <SamB_XP> @quote fork
17:51:51 <lambdabot> sorear says: We need to fork #haskell.  I can't read fast enough.
17:52:04 <pjdelport> Philonous: Real World Haskell is getting released soon
17:52:11 <pjdelport> http://www.realworldhaskell.org/blog/
17:52:13 <lambdabot> Title: Real World Haskell
17:52:39 <Philonous> pjdelport: The wikibook is rather paltry. I read most of it and it leaves much to be desired
17:53:52 <SamB_XP> Philonous: there's a delightfull array of papers about Haskell, though
17:54:38 <SamB_XP> where by "array" I mean "vast collection", nothing to do with something you can index
17:55:02 <Philonous> Where would I have to look? The Haskell site?
17:55:28 <SamB_XP> well simon peyton jones co-authors a bunch of papers...
17:55:48 <SamB_XP> @go functional pearls
17:55:49 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
17:55:49 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
17:55:58 <SamB_XP> and you can look at the functional pearls
17:56:30 <SamB_XP> dons: can you think of any good places to find papers?
17:56:31 <Philonous> Thanks
17:57:21 <SamB_XP> hmm, I suppose the page immediately above that one might help ...
18:01:38 <sm> boy, I really got confused just now debugging code where a top-level binding was overridden by a where binding, but ghci knew only about the former
18:01:46 <SamB_XP> who the heck is Simon B. Jones
18:02:08 <sm> I can't seem to break or step to a place where the where's binding is in scope - should that be possible ?
18:03:08 <pjdelport> Philonous: http://haskell.readscheme.org/
18:03:28 <dogbite_> neat
18:03:35 <dogbite_> oof, how do i get 'dogbite' back?
18:03:40 <SamB_XP> pjdelport: it's such a strange url
18:03:49 <SamB_XP> dogbite: did you register with nickserv?
18:03:56 <SamB_XP> er. dogbite_
18:03:58 <dogbite_> SamB_XP: i don't know what that means
18:04:17 <SamB_XP> dogbite: type /msg NickServ help and weep
18:04:39 <SamB_XP> ... er ... do better next time, that is
18:05:14 <SamB_XP> (by "next time", I mean when freenode times out dogbite and you, dogbite_, can renick to dogbite)
18:05:39 <adekoba> what is the preferred package for working with http? HTTP, i'm guessing?
18:05:39 <adu> its 8/8/8 today!
18:05:46 <SamB_XP> adu: I know
18:05:56 <dogbite_> can somebody kick 'dogbite' now?
18:06:05 <dogbite_> i think it's logged on some old screen session
18:06:07 <adu> thats like 2/2/2 more than the beast number!
18:06:09 <dogbite_> that i don't have access to
18:06:20 <SamB_XP> dogbite_: ask freenode staff
18:06:30 <SamB_XP> they'd have to kick you off the server
18:06:38 <adu> dogbite_: do you own dogbite?
18:06:44 <dogbite_> yeah i'm dogbite
18:06:46 <dogbite_> the one and only
18:06:50 <mauke> no, you aren't
18:06:51 <SamB_XP> adu: he doesn't know what nickserv is
18:07:00 <mauke> oh, maybe you are
18:07:00 <adu> dogbite_: use nickserv
18:07:14 <adu> o
18:07:15 <adu> n/m
18:07:18 <SamB_XP> adu: nickserv doesn't let you register when you aren't you
18:07:23 <dogbite_> i understand.  i have to first get dogbite kicked
18:07:28 <dogbite_> then use nickserv
18:07:30 <dogbite_> to "own" dogbite
18:07:35 <SamB_XP> go to ... was it #freenode?
18:08:29 <dogbite_> SamB_XP: i'm over there now trying
18:09:35 <Philonous> pjdelport: Thanks for all the support, I'll hit the sack. Maybe I will continue bugging you tomorrow ;)
18:09:53 <pjdelport> Philonous: night!
18:12:12 <SamB_XP> --- [SamB] +#ReactOS #haskell #coq #haskell-blah #darcs #ZSNES #perl6 #ghc #twisted ##c #tahoe #slate ##free-c +#nsrt
18:12:16 <SamB_XP> hmm, maybe 14?
18:12:42 <dogbite_> SamB_XP: hmm... not sure what's going on
18:13:02 <SamB_XP> hmm, ECHAN
18:14:15 <SamB_XP> --- [dogbite] (n=gharfst@dev.hhinternal.net) : Unknown
18:14:26 <SamB_XP> --- Ping reply from dogbite : 1.10 second(s)
18:14:52 <dogbite_> SamB_XP: yeah, that's the screen session
18:15:07 <dogbite_> SamB_XP: no way for me to log off of that
18:15:09 <SamB_XP> dogbite: so how come you can't get back to it?
18:15:34 <dogbite_> SamB_XP: just a machine i only had access to for a period of time
18:15:44 <dogbite_> SamB_XP: forgot to log off it
18:15:59 <SamB_XP> dogbite: can you call them up and ask them to terminate all your processes ?
18:16:10 <dogbite_> maybe on monday :-/
18:16:34 <SamB_XP> and your login really doesn't work anymore?
18:16:42 <dogbite_> tis a shame, isn't it?
18:16:52 <ski> dogbite_ : hm, you can't ghost `dogbite' ?
18:16:56 <SamB_XP> you should file a complaint for incomplete account termination
18:17:11 <SamB_XP> ski: he didn't register it because he only now found out about nickserv
18:17:16 <stepcut> what parser combinators should I use to parse simple algebra expressions like x = y + 1? Parsec, something based on Control.Applicative?
18:17:48 <ski> mhm
18:21:56 <Zao> Doesn't parsec have some kind of ExprParser thingie?
18:22:20 <ilovehatsz> test
18:22:29 <ilovehatsz> anyone online?
18:22:52 <Zao> ilovehatsz: Test failed.
18:23:08 <ilovehatsz> zao are you a bot?
18:23:11 <ilovehatsz> test 123
18:23:49 <Zao> If I were, Mr. Turing would be rolling in his grave.
18:24:22 <stepcut> Zao: dunno, I should look
18:25:29 <dogbite_> SamB_XP: well thanks for trying to help
18:25:48 * stepcut discovers Text.ParserCombinators.Parsec.Expr
18:25:55 <ilovehatsz> hi guys i have a problem with int and string
18:26:03 <stepcut> ilovehatsz: don't we all
18:26:05 <ilovehatsz> how do i display i have 5 apples in haskell?
18:26:18 <mauke> putStr "I have 5 apples\n"
18:26:19 <stepcut> ilovehatsz:  (show 5) ++ " apples"
18:26:20 <Draconx> putStrLn "i have 5 apples in haskell"
18:26:21 <ilovehatsz> the user input any value, and the string displays N + apples
18:26:27 <Zao> Text.Printf.printf or show.
18:26:39 <Zao> ilovehatsz: Sounds like homework.
18:26:55 <ilovehatsz> why is it a homework?
18:27:05 <jeffz`> stepcut: have you seen: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
18:27:06 <lambdabot> Title: Parsec, a fast combinator parser
18:27:18 <stepcut> > let apples = 5 in "I have " ++ show apples ++ " " ++ if apples == 1 then "apple." else "apples."
18:27:19 <lambdabot>  "I have 5 apples."
18:27:21 <mauke> main = do { putStr "so ... apples.\n"; n <- readLn; putStr ("I have " ++ show (n :: Integer) ++ " apples.\n") }
18:27:39 <ilovehatsz> thanks stepcut =D, i'll test it out in my winhugs
18:28:16 <stepcut> jeffz`: yes. But I am not sure if it is the best solution due to the heavy use of infix notation
18:28:42 <stepcut> jeffz`: I am getting the feeling I will be using 'try' a lot, so I was thinking frisby or something else might be better
18:29:03 <ilovehatsz> omg it works!
18:29:05 <ilovehatsz> yeah
18:29:12 <ilovehatsz> i didn't know about "show" function
18:29:16 <stepcut> jeffz`: though, I might able to factor to LL(1), in which case parsec would work
18:29:33 <stepcut> ilovehatsz: 'show' is pretty sweet. Probably the #1 reason I switched from O'Caml ;)
18:29:43 <ilovehatsz> what is ocam
18:29:51 <ilovehatsz> i use to study c, then i use printf
18:29:56 <ilovehatsz> but does not work o_o
18:29:59 <ilovehatsz> in haskell
18:30:09 <mauke> > ""++ printf "I have %d apples" 42
18:30:10 <lambdabot>  "I have 42 apples"
18:30:18 <stepcut> ilovehatsz: ocaml is a different language similar to Haskell in some ways, but very different in others.
18:30:32 <ilovehatsz> what is %d means?
18:30:38 <stepcut> ilovehatsz: ocaml is another *functional* language
18:30:44 <ilovehatsz> e	> ""++ printf "I have %abcc apples" 42
18:30:45 <mauke> ilovehatsz: er, I thought you knew printf
18:30:50 <ilovehatsz> > ""++ printf "I have %abcc apples" 42
18:30:51 <lambdabot>  "I have Exception: Printf.printf: bad formatting char a
18:30:59 <ilovehatsz> > ""++ printf "I have %a apples" 42
18:30:59 <lambdabot>  "I have Exception: Printf.printf: bad formatting char a
18:31:06 <ilovehatsz> > ""++ printf "I have %z apples" 42
18:31:07 <lambdabot>  "I have Exception: Printf.printf: bad formatting char z
18:31:12 <ilovehatsz> what the..
18:31:15 <ilovehatsz> > ""++ printf "I have %d apples" 42
18:31:16 <lambdabot>  "I have 42 apples"
18:31:17 <mauke> how can you "study" C without learning about printf?
18:31:21 <ilovehatsz> why must it be d
18:31:26 <ilovehatsz> why cant i use a or z
18:31:42 <ilovehatsz> i learn c with printf
18:31:52 <mauke> preflex: ? #11901
18:31:52 <preflex>  You can't just make shit up and expect the computer to know what you mean, Retardo!
18:32:03 <mauke> hmm. that quote might be inappropriate for this channel
18:32:05 <ilovehatsz> yeah
18:32:19 <ilovehatsz> not newbie friendly -_-
18:32:20 <mauke> ilovehatsz: can you explain what printf does?
18:32:25 <stepcut> ilovehatsz: it does not have to be %d, that just means to show the value as decimal. You could use %x if you want hex.
18:32:27 <stepcut> > ""++ printf "I have %x apples" 42
18:32:28 <lambdabot>  "I have 2a apples"
18:32:43 <ilovehatsz> oh d represent decimal, didnt know that
18:33:18 <mauke> > ""++ printf "I have %o apples" 42
18:33:19 <lambdabot>  "I have 52 apples"
18:34:14 <mauke> > ""++ printf "I have %c apples" 42
18:34:15 <lambdabot>  "I have * apples"
18:34:18 <ilovehatsz> what does 0 means?
18:34:25 <ilovehatsz> i mean %o
18:34:30 <mauke> octal
18:34:46 <ilovehatsz> why did it round up?
18:34:50 <ilovehatsz> 42 becomes 50
18:35:09 <mauke> huh?
18:35:42 <ilovehatsz> printf("Color %s, Number %d, Float %5.2f, "red", 123456,3.14);
18:35:46 <ilovehatsz> >printf("Color %s, Number %d, Float %5.2f, "red", 123456,3.14);
18:35:48 <ilovehatsz> >printf("Color %s, Number %d, Float %5.2f, "red", 123456,3.14)
18:36:07 <ilovehatsz> > printf("Color %s, Number %d, Float %5.2f, "red", 123456,3.14)
18:36:08 <lambdabot> Unbalanced parentheses
18:36:39 <ilovehatsz> > printf "Color %s, Number %d, Float %5.2f, red, 123456,3.14"
18:36:40 <lambdabot>  Add a type signature
18:36:54 <ilovehatsz> > printf Color %s, Number %d, Float %5.2f, "red", 123456,3.14
18:36:54 <lambdabot>   parse error on input `,'
18:36:55 <TSC> Don't use commas to separate function arguments in Haskell
18:37:09 <ilovehatsz> so what should i use to separate>?
18:37:13 <TSC> space
18:37:17 <Draconx> programming by bashing keys randomly on the keyboard probably isn't going to work too well, either.
18:37:17 <ilovehatsz> ok =D
18:37:32 <stepcut> Draconx: but, if it *does* pass the type
18:37:39 <stepcut> -checker, it probably does something useful ;)
18:37:39 <ilovehatsz> > printf Color %s  Number %d  Float %5.2f "red" 123456 3.14
18:37:39 <ski> > printf "Color %s, Number %d, Float %5.2f" "red" 123456 3.14 :: String
18:37:40 <lambdabot>   Not in scope: data constructor `Float'
18:37:40 <lambdabot>  "Color red, Number 123456, Float  3.14"
18:37:53 <SamB> huh
18:37:55 <ilovehatsz> 	> printf "Color %s, Number %d, Float %5.2f" "red" 123456 3.14 :: String
18:38:02 <ilovehatsz> > printf "Color %s, Number %d, Float %5.2f" "red" 123456 3.14 :: String
18:38:03 <lambdabot>  "Color red, Number 123456, Float  3.14"
18:38:09 <SamB> it seems that the git folk actually care about this ghc move!
18:38:21 <ski> SamB : mh ?
18:38:23 <stepcut> SamB: heh
18:38:31 <SamB> http://github.com/blog/133-ghc-haskell-moving-to-git
18:38:32 <lambdabot> Title: GHC (Haskell) Moving to Git — GitHub
18:38:37 <Draconx> is there a gitweb up for the newfangled ghc repo?
18:38:39 <stepcut> SamB: maybe the git people will finally move to ghc ;)
18:38:49 <ilovehatsz> thanks ski it works
18:39:00 <ilovehatsz> learned something new today =D
18:39:16 <ski> ilovehatsz : probably you don't need the `:: String' in most contexts ..
18:39:25 <SamB> there's something wrong with this README: http://github.com/ghc-hq/ghc/tree/master
18:39:27 <lambdabot> Title: ghc-hq's ghc at master — GitHub
18:39:50 <Draconx> ski, he does there.
18:40:05 <stepcut> SamB: ;)
18:40:18 <ski> Draconx : yes, i'm aware .. that's why i added it
18:40:29 <Draconx> oh, I didn't see that :)
18:44:09 <ilovehatsz> > ""++ printf "I have %d apples" [1,2,3]
18:44:09 <lambdabot>  Add a type signature
18:44:31 <ilovehatsz> hi guys, what does it mean by 'add a type signature":
18:44:44 <ilovehatsz> i want to display a list with some string
18:44:52 <ilovehatsz> i have [1,2,3] apples
18:45:01 <ilovehatsz> (show [1,2,3]) ++ " apples"
18:45:04 <ski> `%d' doesn't work with lists, iirc
18:45:07 <ilovehatsz> > (show [1,2,3]) ++ " apples"
18:45:08 <lambdabot>  "[1,2,3] apples"
18:45:22 <SamB> ski: wouldn't that be a dynamic error?
18:45:25 <ilovehatsz> wow it works
18:45:31 <ski> (and i don't think `printf' implements something like Common Lisp's list formatters ..)
18:45:44 <adu> I don't understand foldlM, but I think its what I need
18:45:53 <mmorrow> @ty printf
18:45:54 <lambdabot> forall r. (PrintfType r) => String -> r
18:45:57 <ski> SamB : i think the type classes only allow certain argument types ..
18:46:02 <mmorrow> @src PrintfType
18:46:02 <lambdabot> Source not found. Where did you learn to type?
18:46:10 <SamB> ski: oh, true
18:46:26 <mmorrow> @instance PrintfType
18:46:26 <lambdabot> Maybe you meant: instances instances-importing
18:46:27 <ski> SamB : like `instance PrintfType r => PrintfType (Int -> r)' et.c.
18:46:29 <ilovehatsz> lol where did you learn to type
18:46:29 <mmorrow> @instances PrintfType
18:46:29 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
18:46:35 <SamB> I guess it wanted a more specific type so it knew which instance of IsChar applied ;-P
18:46:36 <mmorrow> @instances-importing PrintfType
18:46:36 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
18:46:41 <adu> mmorrow: you know what I don't like about that implementation of Printf? it doesn't allow you to print to a string, it always must go to a file handle, that sucks if you don't want to print anything
18:46:45 <SamB> ski: eh??
18:47:11 * adu wants Text.SPrintf
18:47:18 <mauke> wtf?
18:47:19 <mmorrow> adu: hmm. i'm not familiar with this implementation
18:47:33 <adu> mmorrow: theres printf, and hPrintf, no sPrintf
18:47:41 <Zao> > printf "%d %d" 5 5 :: String
18:47:42 <mauke> adu: printf is sPrintf
18:47:42 <lambdabot>  "5 5"
18:47:55 <SamB> adu: printf is also sPrintf
18:47:58 <mmorrow> it seems like a quasiquoter is in order
18:48:06 <SamB> didn't anyone tell you?
18:48:07 * mmorrow 's new solution for everything
18:48:12 <adu> no
18:48:16 <SamB> adu: see above example ;-)
18:48:29 <adu> @type printf "%d" 5
18:48:30 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
18:48:46 <SamB> @index printf
18:48:46 <lambdabot> Text.Printf
18:48:51 <SamB> @doc Text.Printf
18:48:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
18:49:06 <ski> @type printf "%d" 5 :: String
18:49:07 <lambdabot> String
18:49:13 <mmorrow> > fmap (\n -> printf "(%d,%d)" n n) [0..9]
18:49:14 <lambdabot>  Add a type signature
18:49:20 <mmorrow> > fmap (\n -> printf "(%d,%d)" n n) [(0::Int)..9]
18:49:21 <lambdabot>  Add a type signature
18:49:34 <mmorrow> @ty fmap (\n -> printf "(%d,%d)" n n) [(0::Int)..9]
18:49:35 <lambdabot> forall b. (PrintfType b) => [b]
18:49:37 <SamB> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html#t%3APrintfType
18:49:38 <lambdabot> Title: Text.Printf, http://tinyurl.com/34sj2z
18:49:44 <mmorrow> SamB: thx
18:49:58 <adu> then why does it say "The return value is either String or (IO a)"?
18:50:11 <mauke> adu: because it's true?
18:50:27 <adu> doesn't that mean that the final result is IO a and the intermediary result is String?
18:50:33 <mmorrow> > (mapM (\n -> printf "(%d,%d)" n n) [(0::Int)..9]) :: IO [String]
18:50:34 <lambdabot>  <IO [[Char]]>
18:50:36 <mauke> adu: no
18:50:41 <adu> mauke: oh
18:50:44 <adu> mauke: ok
18:50:45 <mauke> the final result is String or (IO a)
18:50:50 <mauke> the intermediates are all functions
18:51:01 <mmorrow> > (fmap (\n -> printf "(%d,%d)" n n) [(0::Int)..9]) :: [String]
18:51:02 <lambdabot>  ["(0,0)","(1,1)","(2,2)","(3,3)","(4,4)","(5,5)","(6,6)","(7,7)","(8,8)","(9...
18:51:07 <mmorrow> victory!
18:51:31 <adu> then there should be more in the documentation about how Haskell printf is both C's printf and sprintf
18:51:36 <mauke> > fmap (join $ printf "(%d,%d)") [0..9] :: [String]
18:51:37 <lambdabot>  ["(0,0)","(1,1)","(2,2)","(3,3)","(4,4)","(5,5)","(6,6)","(7,7)","(8,8)","(9...
18:53:08 <TSC> Should the Safe library (as opposed to the safe library) be removed from hackage?
18:54:47 <ilovehatsz> bye guys %_%
18:54:50 <ilovehatsz> bye guys ^_^
18:57:21 <adu> @type foldlM
18:57:22 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
18:57:43 <adu> @type Data.Foldable.foldlM
18:57:43 <lambdabot> forall a b (m :: * -> *) (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> b -> m a) -> a -> t b -> m a
18:57:44 <ski> * (format t "I have ~(~d~) apples" (list 1 2 3))
18:57:44 <ski> I have (1 2 3) apples
18:59:00 <SamB> hmm, the GHC repository is a bit big :-(
18:59:12 <ski> (possibly ilovehatsz wanted something like that)
19:04:38 <SamB> nominolo: um, why does your fork of ghc have this description: Official Git mirror of the Glasgow Haskell Compiler
19:04:59 <dogbite_> official fork?  heh
19:07:42 <stepcut> @pl \x y -> [x,y]
19:07:42 <lambdabot> (. return) . (:)
19:07:48 <stepcut> horrid
19:12:47 * shapr sighs
19:14:11 <mmorrow> > curry (uncurry (:) . fmap (:[])) x y
19:14:13 <lambdabot>  [x,y]
19:14:35 <mmorrow> > curry (uncurry (:) . fmap return) x y
19:14:36 <lambdabot>  [x,y]
19:15:19 <mmorrow> i think the @pl version is nice actually
19:15:49 <mmorrow> > zipWith ((.(:[])).(:)) [0..] ['a'..'z']
19:15:50 <lambdabot>   add an instance declaration for (Num Char)
19:15:50 <lambdabot>     In the expression: 0
19:15:58 <mmorrow> ha
19:16:20 * stepcut opted for, return $ \x y -> Sum [x,y]
19:18:20 <mauke> preflex: quote
19:18:20 <preflex>  <bos> i'm very pleased by the recent progress of the C++ standard.  it's gradually eroding the performance advantage of C++ compilers over GHC, without the simons having to do anything.
19:18:22 <mmorrow> @pl \a b c -> [a,b,c]
19:18:23 <lambdabot> (. ((. return) . (:))) . (.) . (:)
19:18:28 <mauke> rng--
19:18:28 <mmorrow> @pl \a b c d -> [a,b,c,d]
19:18:28 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
19:19:23 <stepcut> variation on the boob combinator with double nipple defect ? -> (.).(:)
19:19:33 <mmorrow> tripnip!
19:20:08 <mmorrow>  actually that more like four...
19:20:23 <stepcut> not to be confused with Eccentrica Gallumbits combinator, (.).(.).(.)
19:20:35 <SamB> mmorrow: we don't count the thing in the middle -- it's just a freckle
19:20:47 <stepcut> (the Triple-Breasted Whore of Eroticon 6)
19:20:58 <mmorrow> lol (and lol)
19:21:52 * stepcut wonders if Text.ParserCombinators.Parser.Expr can be made to understand parens
19:23:58 <dsrogers> Hey.  I see http://www.haskell.org/pipermail/libraries/attachments/20080720/de51f8da/network_sin6.obj  Does that little section at the bottom mean that that patch has been applied in GHC v 6.8.3?
19:23:59 <lambdabot> http://tinyurl.com/6bd4x4
19:24:57 <mauke> unlikely
19:25:08 <humasect> how to make an Enum cyclic using succ ?
19:25:26 <mauke> @hoogle Enum
19:25:27 <lambdabot> Prelude.Enum :: class Enum a
19:25:27 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
19:25:27 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
19:25:32 <humasect> ahh enumFrom ?
19:25:37 <humasect> then repeat ?
19:25:46 <mauke> humasect: huh?
19:25:49 <mauke> what are you trying to do?
19:26:03 <humasect> using succ to cycle through an Enum type
19:26:21 <humasect> data Hi = A | B | C | D .... succ D = A
19:26:21 <mauke> no.
19:26:34 <mauke> just write an appropriate Enum instance
19:27:55 * humasect writes a succ and pred
19:30:10 <sjanssen> @src Enum
19:30:11 <lambdabot> class  Enum a   where
19:30:11 <lambdabot>     succ                     :: a -> a
19:30:11 <lambdabot>     pred                     :: a -> a
19:30:11 <lambdabot>     toEnum                   :: Int -> a
19:30:11 <lambdabot>     fromEnum                 :: a -> Int
19:30:13 <lambdabot> [3 @more lines]
19:30:23 <sjanssen> humasect: it is probably best to write a toEnum and fromEnum instead
19:30:48 <humasect> are you sure? this seems cleaner : succCompDir cd = if cd == NorthWest then North else succ cd
19:30:51 <sjanssen> hmm, but then succ would be wrong.  nevermind
19:31:08 <sjanssen> humasect: yes, that is probably best
19:31:12 <humasect> k thanks
19:33:57 <dsrogers> indeed it has not been.
19:34:08 <dsrogers> HApps doesn't work on mac os x without that patch
19:34:31 <dsrogers> also, has anyone tried cocoa bindings for mac os x?
19:53:25 <newsham> deriving Enum?
20:20:27 <lispy> dsrogers: no I haven't but I would be interested to hear your findings.
20:20:46 <dsrogers> found one.
20:20:51 <dsrogers> hoc.sourceforge.net
20:20:57 <dsrogers> hasn't been updated since 10.5
20:21:03 <lispy> Although, for the iphone dev I might do, I'll probably use the official SDK.  I don't want spend my dev timing writing the tools in this case.
20:21:05 <dsrogers> and 10.5 introduced garbage collection
20:21:47 <lispy> dsrogers: Making the garbage collectors play nicely will either be really easy or really hard.
20:22:00 <lispy> dsrogers: do you know much about FFI in haskell?
20:22:12 <dsrogers> I skimmed that chapter.
20:22:15 <dsrogers> so I know a little.
20:22:49 <lispy> cool, you should try updating it
20:23:37 <dsrogers> the most serious issue I've found is the lack of documentation on the obj-c runtime.
20:23:42 <dsrogers> but there is some.
20:23:52 <dsrogers> and the ruby bindings are opensource.
20:24:02 <dsrogers> so those guys probably have a bunch of expertise.
20:24:09 <dsrogers> (the ruby bindings are included in mac os x)
20:24:22 <dsrogers> obj language bindings are, in general, extremely easy to write
20:24:32 <lispy> cool
20:25:08 <dsrogers> there is plenty of introspection, and method invocations are all mapped to one dynamic lookup function.
20:25:13 <adu> whats the pragma for not doing inlines?
20:25:20 <adu> is it {-# NOINLINE mode #-}?
20:25:44 <lispy> adu: if that's not it, then it's very close
20:26:12 <lispy> adu: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
20:26:14 <lambdabot> Title: 8.12.�Pragmas, http://tinyurl.com/y9jo69
20:27:14 <adu> this is what i get: only.hs:2:0: parse error on input `module'
20:27:39 <adu> and the previous thing I tried gave:  parse error on input `#-}'
20:27:59 <lispy> oh, yeah bad pragmas give parse errors :(
20:28:00 <ddarius> You put them inside modules, not outside.
20:28:04 <adu> o
20:28:05 <adu> hehe
20:28:17 <lispy> adu: just put it next to the definition you don't want to inline
20:33:03 <adu> lispy: ok
20:33:49 <dolio> @type \f -> f . uncurry (++)
20:33:51 <lambdabot> forall b a. (Monoid a) => (a -> b) -> (a, a) -> b
20:35:44 <lispy> dolio: hrm
20:37:48 <ddarius> :t \f -> curry . f . uncurry (++)
20:37:49 <lambdabot> forall a b c a1. (Monoid a1) => (a1 -> (a, b) -> c) -> (a1, a1) -> a -> b -> c
20:41:35 <dsrogers> huh.  hoc is pretty impressive.  it's actually a 2 way language binding.
20:41:39 <dsrogers> it's even typed.
20:42:15 <dsrogers> you can build your interface in IB and then write all the handlers in haskell
20:43:58 <dolio> @type let eval (a, f) = f a in eval . (const zero &&& id)
20:43:58 <lambdabot> forall t m. (Monoid m) => (m -> t) -> t
20:46:42 <dsrogers> I have too many big ideas.  I need to build something practical
20:47:54 <ddarius> :t \f -> curry (f . uncurry (++))
20:47:55 <lambdabot> forall c a. (Monoid a) => (a -> c) -> a -> a -> c
20:48:09 <dolio> @type let eval (a,f) = f a ; prod = uncurry (++) in eval . (prod &&& id)
20:48:10 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:48:57 <dolio> @type let eval (a,f) = f a ; prod = uncurry (++) in eval . (prod *** id)
20:48:58 <lambdabot> forall t a. (Monoid a) => ((a, a), a -> t) -> t
20:50:52 <dolio> @type let eval (a,f) = f a ; prod = uncurry (++) ; assoc ((a,b),c) = (a,(b,c)) in (curry .) . curry $ assoc . eval . (prod *** id)
20:50:52 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
20:54:05 * ddarius knows roughly what dolio is doing, but doesn't know why.
20:54:35 <lispy> hey, isn't data Foo = Foo !String !Int !Whatever, pointless because String = [Char] and making the list strict doesn't help?
20:54:56 <ddarius> lispy: It "helps" very slightly, but not muh.
20:55:28 <Korollary> afaik it makes the spine of the string strict only
20:55:39 <dolio> I'm trying to figure out delta for Monoid m => (->) m.
20:55:52 <ddarius> No, it just forces the first cons cell (if there is one)
20:56:03 <lispy> that's what I thought
20:56:08 <Korollary> I meant that, but I don't know why I didn't say that.
20:56:25 <ddarius> dolio: Figure out what about it?
20:56:28 <Korollary> I shall check myself into an institution
20:56:51 <Korollary> Can you use ByteStrings instead?
20:57:45 <lispy> Korollary: It's less about what it could be, and more that some people seem to sprinkle in ! very liberally
20:58:10 <lispy> Korollary: replacing all the strings in darcs with ByteString seems like a reasonable policy though
20:58:47 <dolio> ddarius: How to write it in terms of the morphisms you'd typically have in category theory.
20:58:57 <ddarius> dolio: You already mostly had it.
20:59:08 <lispy> I find that the strictness issues of performance in Haskell to be a painful cognitive load.
20:59:52 <dolio> @type let eval (a,f) = f a ; prod = uncurry (++) ; swap (x,y) = (y,x) ; assoc ((a,b),c) = (a,(b,c)) in curry $ eval . swap . (id *** prod) -- close enough?
20:59:53 <lambdabot> forall c a. (Monoid a) => (a -> c) -> (a, a) -> c
21:01:03 <ddarius> @pl \f -> curry (f . uncurry (++))
21:01:03 <lambdabot> curry . (. uncurry (++))
21:01:23 <ddarius> Let us calculate.
21:01:51 <Axman6> yay, got my binart tree thing working!
21:02:35 <ddarius> Actually, you'd typically have m = uncurry (++)
21:03:15 <Korollary> lispy: darcs has no present plans to switch to ByteStrings?
21:03:17 <dolio> @type let eval (a,f) = f a ; prod = uncurry (++) ; swap (x,y) = (y,x) ; assoc ((a,b),c) = (a,(b,c)) in curry . curry $ eval . swap . (id *** prod) . assoc
21:03:18 <lambdabot> forall b c. (Monoid b) => (b -> c) -> b -> b -> c
21:04:25 <ddarius> :t fmap (uncurry (++))
21:04:26 <lambdabot> forall a (f :: * -> *). (Functor f, Monoid a) => f (a, a) -> f a
21:04:58 <ddarius> :t \f -> fmap f (uncurry (++))
21:04:59 <lambdabot> forall b a. (Monoid a) => (a -> b) -> (a, a) -> b
21:08:27 <Axman6> is there flags you need to add to ghc when compiling using `par`? i noticed that my binary only uses 1 thread, and one core
21:10:17 <Zao> -threaded?
21:10:31 <Axman6> counds good
21:10:34 <Axman6> sounds too
21:10:48 <Zao> +RTS -N4 -RTS probably helps too. I believe there's a bit in the docs about it.
21:10:59 <Axman6> ok, thanks
21:11:40 <Zao> (which would instruct the runtime that there's 4 proper cores to run on)
21:13:14 <Axman6> hmm, still only one thread
21:13:50 <Axman6> oh, using -N4 in the wrong place, heh
21:15:16 <Axman6> hmm, doesn't like -N2
21:15:28 <Axman6> ./Treething +RTS -N2
21:15:28 <Axman6> unknown RTS option: -N2
21:17:32 <lispy> Korollary: darcs can use either legacy FPS or modern ByteString for patches
21:17:52 <lispy> Korollary: but, I just meant, why have any thing other than ByteString
21:18:43 <lispy> Korollary: I'm not sure what that particular string goes to that I was looking at.  no documentation
21:18:59 <adu> YEY its working
21:19:10 <adu> all except for the positional stuff
21:20:06 <mm_freak_> is unsafeInterleaveST evil?
21:20:20 <lispy> sure sounds safe
21:20:22 <lispy> oh wait
21:20:25 <lispy> :)
21:20:54 * adu is writing a tool to replace: head, tail, find, grep and cut
21:21:24 <lispy> adu: I think that's been done, in Haskell and #haskell, before.  So if it's not as a learning exercise...
21:21:40 <lispy> otoh, if it's to learn, go right ahead!
21:21:47 <adu> no its to use
21:21:57 <lispy> You should look at h4sh
21:22:01 <lispy> ?where h4sh
21:22:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
21:22:23 <dmwit> adu: Have you played with sed and ack?
21:22:24 <ddarius> dolio: Write compose :: (b -> c, a -> b) -> a -> c categorically.
21:23:12 <dmwit> adu: sed replaces head/tail/cut, and ack replaces find/grep
21:23:39 <adu> dmwit: yes, but those are tools that modify, which doesn't fit my tool's usage, (head, tail, find, grep and cut) only read/query stuff, and I have a better idea for all of them
21:24:37 <adu> dmwit: o "ack" i thought you said awk
21:26:07 <adu> dmwit: specifically, I want the following syntax #/regex/#
21:28:10 <dmwit> #?
21:29:12 <dsrogers> is there a reference for template haskell?
21:32:48 <Axman6> anyone know why i wouldn't be able to use +RTS -N2 with a binary compiled using -threaded?
21:33:15 <dolio> @type let eval (f, a) = f a ; assoc ((a,b),c) = (a,(b,c)) in curry $ assoc >>> id *** eval >>> eval
21:33:19 <dmwit> malicious CPUs
21:33:30 <lambdabot> thread killed
21:33:33 <Axman6> well i get: unknown RTS option: -N2
21:33:35 <dolio> @type let eval (f, a) = f a ; assoc ((a,b),c) = (a,(b,c)) in curry $ assoc >>> id *** eval >>> eval
21:33:44 <lambdabot> forall b c t. (t -> c, b -> t) -> b -> c
21:33:46 <lispy> dsrogers: I never really found one other than asking here
21:34:03 <dmwit> :t uncurry (.)
21:34:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b, f a) -> f b
21:34:44 <Axman6> @src curry
21:34:44 <lambdabot> curry f x y = f (x, y)
21:34:49 <Axman6> @src uncurry
21:34:49 <lambdabot> uncurry f p = f (fst p) (snd p)
21:35:28 <adu> dmwit: In general my tool will accept expressions of the form ([0-9.,:;]*)(char)regex(same-char)([0-9.,:;]*) which parses out into three strings: (abs, regex, rel) which gets parsed into the datatypes ([Int], Regex, [Int]). In line mode, the "abs" numbers list which pattern matches to select (1/the/ will select the line with first occurance of "the"), and the "rel" numbers list lines of the original file relative to the line on which 
21:36:32 <adu> In word mode replace every occurance of "line" with "word". (this is how I see emulating "cut")
21:36:42 <dmwit> (you got cut off at "relative to the line on which)
21:37:14 <adu> ...and the "rel" numbers list lines of the original file relative to the line on which the match occurs (which can be used to emulate grep -A/B)
21:38:07 <Axman6> so, no one has any idea why i wouldn't get a -Nn option on a binary compiled with -threaded?
21:38:23 <Axman6> with ghc 6.8.3
21:38:32 <dmwit> adu: This sounds like something that should be a shell script's job... any particular reason for choosing Haskell?
21:38:36 <dmwit> Just for fun?
21:38:44 <adu> dmwit: educational purposes :)
21:38:51 * dmwit nods
21:38:59 <dmwit> Sounds interesting. =)
21:39:09 <Axman6> googling provides no answers
21:39:33 <ddarius> dolio: Bah, it looks like you basically have to internalize (the composition of) curry and compose.
21:40:09 <ddarius> :t curry . (.) . (id &&& const (uncurry (++)))
21:40:24 <lambdabot> thread killed
21:40:31 <ddarius> :t curry . uncurry (.) . (id &&& const (uncurry (++)))
21:40:31 <lambdabot> forall b a. (Monoid a) => (a -> b) -> a -> a -> b
21:40:49 <Axman6> > curry map f [1..10]
21:41:04 <adu> dmwit: plus, I used Parsec to parse the expression, made it very nice. I couldn't imagine doing the same in bash
21:41:05 <lambdabot>  thread killed
21:41:11 <Axman6> > curry map f [1]
21:41:12 <lambdabot>  Couldn't match expected type `(a, b)'
21:41:34 <Axman6> > curry min a b
21:41:35 <dsrogers> is it possible to use the list comprehension syntax with other list-like objects?
21:41:39 <lambdabot>  <(SimpleReflect.Expr,SimpleReflect.Expr) -> (SimpleReflect.Expr,SimpleReflec...
21:41:48 <dmwit> Axman6: The function you're currying has to take a tuple.
21:41:50 <adu> dmwit: maybe with ${EXPR#[0-9.,:;]*} or something, but i don't think that would work
21:42:14 <dmwit> > curry ((+1) *** (+2)) 3 4
21:42:16 <lambdabot>  (4,6)
21:42:18 <dsrogers> 'cause I'm pretty sure it would be possible to write a relational calculus that looked like list comprehensions, only, on relations instead of lists.
21:42:33 <dmwit> dsrogers: No.  We used to have monad comprehensions.
21:42:48 <Axman6> dmwit: ah, it looks from the source it takes a function that takes two args, and turns it into one that takes a tuple
21:42:48 <dmwit> They were removed to appease people new to Haskell. =/
21:42:52 <dolio> ddarius: It is nicer once you do that, certainly.
21:42:58 <lispy> lambdabot should have an FAQ trigger about monad comps
21:42:59 <dmwit> ?src curry
21:42:59 <lambdabot> curry f x y = f (x, y)
21:43:17 <dmwit> Axman6: No, it takes a function and feeds it a tuple; so of course that function has to be able to take a tuple.
21:43:23 <dsrogers> dmwit: are you serious?
21:43:34 <dmwit> dsrogers: very
21:43:36 <dolio> Better than curry_{curry_{...}}
21:43:36 <lispy> dsrogers: yes he's serious
21:43:49 <dsrogers> can someone explain to me why that makes sense?
21:43:58 <lispy> dsrogers: the type errors were very confusing
21:44:00 <dmwit> dsrogers: It's all documented in A Brief History of Haskell or whatever.
21:44:13 <dsrogers> I mean, why not take out type inference.  The errors can be very confusing.
21:44:36 <dmwit> I find type errors to be quite manageable, given a bit of patience.
21:44:41 <Axman6> because type inference is what mkes haskell awesome
21:44:50 <rwbarton> Because monad comprehensions are only a few characters shorter than 'do' blocks anyways?
21:45:00 <dmwit> I can't speak for monad comprehension errors, though; I discovered Haskell after they were gone.
21:45:13 <dmwit> But yeah, mostly rwbarton has the answer there.
21:45:31 <dsrogers> ah.
21:45:34 <dsrogers> that makes more sense.
21:46:06 <SamB_XP> dsrogers: C compilers give answers that leave me with less clue
21:46:11 <SamB_XP> er. errors.
21:46:17 <dmwit> rwbarton: I think do-blocks are of a manageable length... but still much longer than comprehensions in a lot of cases.
21:46:30 <dsrogers> my statement about type errors was meant to be ironic
21:46:46 <sclv> ?quote scare
21:46:47 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
21:46:53 <lispy> dsrogers: have you seen the paper that defines the embedded SQL lang and uses do-notation to specify the queries...
21:47:02 <dsrogers> no
21:47:07 <lispy> dsrogers: one sec
21:47:10 <SamB_XP> @tell glguy *polymorphism* scare
21:47:10 <lambdabot> Consider it noted.
21:47:18 <dsrogers> but I've also never seen an implementation of a relational calculus.
21:48:05 <dolio> The scare itself was polymorphic.
21:48:15 <lispy>     author = "Daan Leijen and Erik Meijer",
21:48:15 <lispy>     title = "Domain specific embedded compilers",
21:48:20 <lispy> dsrogers: that's the paper you want
21:48:25 <lispy> dsrogers: google has it
21:48:36 <dsrogers> ok
21:49:06 <dsrogers> Speaking of language features, I'm voting for http://en.wikipedia.org/wiki/Irony_mark
21:49:07 <lambdabot> Title: Irony mark - Wikipedia, the free encyclopedia
21:49:18 <dsrogers> What is the next meeting of the English working group?
21:49:21 <dsrogers> *When?
21:49:34 <SamB_XP> dsrogers: consult the supplier of your punctuation reference
21:49:58 <SamB_XP> er. actually, consult your typographers
21:50:09 <adu> if anyone is interested, here is how nice the parser is: http://hpaste.org/9481
21:51:34 <dsrogers> the puct. ref. guys keep sending all my documents back with syntax errors.
21:52:15 <adu> puct.?
21:52:19 <dsrogers> the only English parser I have is apparently far too loose for their standards.
21:52:58 <dsrogers> adu: punctuation reference.  I'm continuing the joke.
21:53:26 <dmwit> adu: I believe there's a version of "choice" that "try"s them all.
21:53:45 <stulli> Noob question: Does IO perform different when running compiled code instead of interpreted?
21:53:58 <dmwit> So (try nexts <|> try steps <|> try range <|> number) -> choiceTry [nexts, steps, range, number].
21:53:58 <adu> dmwit: o that would help
21:54:01 <dmwit> (I don't remember what the function is called, though.
21:54:04 <dmwit> )
21:54:07 <dsrogers> stulli: it depends on what you mean.
21:54:17 <dsrogers> i.e: different how?
21:54:25 <stulli> I have some weird issues when compiling
21:54:28 <dmwit> stulli: GHC and GHCi use different buffering defaults, so that's one difference.
21:54:29 <stulli> let me hpaste it
21:54:47 <stulli> http://hpaste.org/9482
21:55:02 <dmwit> import System.IO
21:55:09 <dmwit> hSetBuffering stdout NoBuffering
21:55:10 <sw17ch> the common practice in libraries is to prefix the name of the data type to the named accessors, correct?
21:55:27 <stulli> dmwit, thanks, i will try
21:55:48 <ddarius> sw17ch: Why would you bother doing that?
21:56:00 <sw17ch> prevent namespace pollution?
21:56:05 <dmwit> sw17ch: Use the module system! =)
21:56:08 <ddarius> It's already in a module
21:56:29 <sw17ch> as in... the qualified part? ... i might need a better explanation :)
21:56:37 <mmorrow> stulli: also, hFlush stdout works wonders
21:56:39 <dmwit> stulli: Also, check out the "when" function.
21:56:58 <dmwit> when (x == "quit") (putStrLn $ "huh" ++ x)
21:57:07 <ddarius> sw17ch: Export reasonably names.  It hardly matters if they are record accessors or not.
21:58:12 <sw17ch> ddarius, and if name colissions arise, that's why we have qualified?
21:58:17 <dmwit> adu: Your parser is pretty beautiful. =)
21:58:23 * sw17ch apologizes for not spell checking that
21:58:40 <ddarius> sw17ch: Yes.
21:59:05 <sw17ch> hmm... alright :)
21:59:20 * sw17ch will need some people to play with the port audio bindings when he's finished with them
21:59:42 * sw17ch and a few to review the module and hold no punches concerning criticism
22:00:14 <stulli> mmorrow, dmwit, And my todo-list grows again :)
22:00:23 <sw17ch> ddarius, just to be sure, i am referring to the record syntax
22:00:38 <mmorrow> stulli: that always happens with haskell ;)
22:00:41 <dmwit> stulli: Oh, do you know about buffering?
22:01:08 <stulli> dmwit, no, nothing at all
22:01:15 <dmwit> ...do you want to?
22:01:18 <lispy> how do you guys feel about liftM vs. fmap?
22:01:30 <mmorrow> fmap "takes the cake" imo
22:01:37 <stulli> dmwit, sure!
22:01:40 <dmwit> lispy: I prefer liftM when doing "monady" things.
22:01:44 <lispy> mmorrow: why is that?
22:01:48 <mmorrow> lispy: personally, i can't stand liftM
22:01:49 <lispy> dmwit: me too
22:02:05 <dobblego> I prefer (.) over liftM/fmap
22:02:08 <dmwit> stulli: Okay!  Writing to screen (and files) is slow and expensive.
22:02:15 <mmorrow> lispy: i dunno, i guess because it is _only_ a monadic thing
22:02:26 <dmwit> But it turns out that writing (say) 50 characters and writing (say) 1 character cost about the same.
22:02:42 <dmwit> So the trick we play is we "buffer" output to screen or file in RAM.
22:02:57 <dmwit> That is, we store all the things we want to output in memory, then send them all at once.
22:03:13 <mmorrow> lispy: i like    liftM f  ---->   (return . f =<<)
22:03:30 <lispy> I was just wondering.  I was told to avoid liftM because it requires an import.  I wondered if taht's common sentiment.
22:03:30 <mmorrow> (for no logical reason)
22:03:39 <stulli> dmwit, hm, that seems to make sense
22:03:39 <dmwit> From there, the only real decision is when to "flush" the buffer -- that is, send stuff from memory to disk/screen/wherever.
22:04:11 <stulli> so hFlush will clear the buffer?
22:04:12 <dmwit> The two most common ways are block and line buffering.
22:04:14 <mmorrow> lispy: oh yeah, that too in general, i tend to use things i don't have to import or even reimplement them if they're simple before i'll import
22:04:22 <dmwit> (Yes, hFlush clears the buffer.)
22:04:26 <hml> i'm writing this app taht i plan to have real people use (omg, in haskell?); howeeeeeeeever, i've only done develeopment on linux so far; is it easy to compile haskell apps on windows? the only iffy library I use is hopengl
22:04:42 <dmwit> Block buffering makes a fixed-size buffer (usually the size of a page of memory), and flushes only when it's full.
22:04:53 <dmwit> Line buffering flushes every time a newline is written to the buffer.
22:04:57 <SamB_XP> lispy: I'll send in a bug report before using liftM, nowadays
22:05:13 <SamB_XP> (for a missing Functor instance, of course ;-)
22:05:16 <dmwit> Now, input and output to the console are line-buffered by default in Haskell.
22:05:22 <dmwit> So, do you see the problem?
22:05:51 <dmwit> If you're doing output and input, and you've sent some output (but no newline) and then do some input, the output buffer isn't flushed yet...
22:05:58 <lispy> so instead of do x <- foo `liftM` bar, you right, do x <- foo . bar, ?
22:06:04 <stulli> ah, i see
22:06:15 <lispy> s/right/write/
22:06:23 <mmorrow> dobblego: so would you write         (fmap . fmap . fmap . fmap) (*2) [[[[4]]]]               as   ((.) . (.) . (.) . (.)) (*2) [[[[4]]]]   ?
22:06:24 <dmwit> So: two possible solutions.  Turn off buffering (the solution I suggested), or remember to flush the buffer each time (the hFlush solution).
22:06:32 <dmwit> stulli: That's about all there is to it.
22:07:15 <stulli> Or add a linebreak instead of flushing?
22:07:20 <dmwit> right
22:07:38 <dmwit> Incidentally, most other languages work this way, too.
22:07:40 <stulli> That was easy to understand
22:07:53 <dmwit> great!
22:07:59 <stulli> (A new experience in #haskell ;) )
22:08:11 <sw17ch> why won't haddock pick up all the functions in my module? it sees one, but i don't see how it's any different from the others i have in there
22:08:33 <SamB_XP> sw17ch: did you give it a type signature?
22:08:36 <mmorrow> it won't pick up one's w/out type sigs (if that's indeed the problem here)
22:08:51 <sw17ch> SamB_XP, nope, didn't realize it needed one :)
22:08:52 <sw17ch> thanks
22:09:01 <stulli> dmwit, Thanks for your explanation, i have to try some things now
22:09:12 <lispy> sw17ch: haddock version?
22:10:37 <lispy> sw17ch: I ask because, if youd on't export it, haddock defaults to not mentioning it, but I know haddock 2 (and maybe older haddock also) has a way to run this off so all top level functions with a signature are shown
22:10:53 <sw17ch> 0.8
22:10:54 <sw17ch> wow
22:11:11 * sw17ch is using haddock out of gentoo portage
22:11:26 <lispy> sw17ch: also, ghc has a flag to complain about top level functions with no signatures.  I recommend using that flag, it helps a lot and establishes a good habbit -- good haskellers put sigs on top level functions
22:11:38 <mmorrow> lispy: --ignore-all-exports
22:12:34 <mmorrow> (re: " but I know haddock 2 (and maybe older haddock also) has a way to run this off so all top level functions with a signature are shown")
22:12:53 * lispy nods
22:12:55 <lispy> mmorrow: thanks
22:13:16 <mmorrow> :)
22:13:25 <lispy> sw17ch: -Wall isn't a bad idea, but some of it is too pedantic
22:13:41 <sw17ch> lispy: -Wall -O2 -via-c
22:13:45 <Axman6> :t curry fst
22:13:46 <sw17ch> is my usual
22:13:46 <lambdabot> forall a b. a -> b -> a
22:13:57 <lispy> sw17ch: right on
22:14:01 <Axman6> @src curry fst
22:14:02 <lambdabot> Source not found. Sorry.
22:14:10 <sw17ch> gcc taught me how awesome -Wall is
22:14:23 <sw17ch> actually, bugs taught me how awesome -Wall is...
22:14:41 <sw17ch> but for the longest time, i didn't catch the "warn all" part and was wondering what Larry Wall had to do with GCC
22:14:54 <lispy> gcc is like, -pedantic -Wall -Werror and some others I probaly forgot
22:15:04 <lispy> sw17ch: haah
22:15:25 <consolers> "
22:15:26 * sw17ch wants to finish rev 0.0.1 of this library tonight...
22:15:27 <lispy> -Larry -Wall
22:15:34 <lispy> gcc: libarry not found
22:15:40 <sw17ch> awesome
22:15:47 <lispy> (i'm just kidding)
22:15:50 <sw17ch> now i need to write that library...
22:16:02 <sw17ch> lispy, wouldn't it be -larry -Wall?
22:16:14 <lispy> oh, maybe, but I think both -L and -l exist
22:16:29 <SamB_XP> lispy: yeah, -L adds to path
22:16:30 <sw17ch> lispy, they do, but -L is a library search directory, and -l names the library
22:16:30 <dmwit> -L tells the library search path
22:16:38 <Boney> Also when using -Wall gcc won't catch uninitilised variables without -O
22:16:38 <lispy> libarry should be a library required to compile perl
22:16:41 <sw17ch> > cycle "echo "
22:16:43 <lambdabot>  "echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo ...
22:16:44 <SamB_XP> so -Larry -Wall would actually work probably
22:16:59 <sw17ch> yep
22:17:20 <lispy> $ gcc -Larry -Wall
22:17:20 <lispy> i686-apple-darwin9-gcc-4.0.1: no input files
22:17:24 <mmorrow> > intercalate " " (fix ("echo":))
22:17:25 <lambdabot>  "echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo ...
22:17:50 <consolers> can someone confirm the typo error in  www.cs.uu.nl/~afie/haskell/tourofsyntax.html under section "Patterns" where comma is used to delimit constructor arguments
22:17:50 <lispy> mmorrow: wouldn't want to have that extra space on the end...
22:18:05 <mmorrow> lispy: hah
22:18:16 <dmwit> -Wall used to confuse me too.  Then, the first time I saw -Werror, there was a blinding flash of light...
22:18:26 <lispy> consolers: 404
22:18:43 <dmwit> consolers: same here
22:18:45 * bitrot enjoyed "Curse of the Werror Rabbit"
22:18:48 <consolers> sorry. wrong url
22:18:54 * bitrot hides...
22:19:05 <consolers> cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
22:19:13 * lispy waits for another wrong url but this time of something inappropriate ;)
22:20:00 <dmwit> consolers: Tuples are matchable...
22:20:05 <dmwit> That's probably what that's about.
22:20:11 <lispy> consolers: what am I loking or?
22:20:13 <dmwit> oh... constructor arguments
22:20:18 <dmwit> consolers: Yeah, that's a typo.
22:20:39 <lispy> yeah, typeo
22:20:50 <lispy> could be works
22:20:54 <lispy> could be worse*
22:20:56 <lispy> could be a thinko
22:23:18 <lispy> but, like i always say, monads are like butterflies
22:26:24 <mmorrow> i don't see how, since monads clearly can't fly
22:27:49 <lispy> mmorrow: http://www.cse.unsw.edu.au/~dons/code/irc-logs/06.09.04
22:27:57 <lispy> mmorrow: I explain in there
22:28:47 <mmorrow> heh, i wonder what a monad looks like in its larval stage?
22:29:13 <mmorrow> a type error in the (>>=) implementation?
22:30:58 <sw17ch> is it possible to document an imported function in haddock rather than documenting the original location?
22:31:58 <dmwit> You could import qualified and write a copy.
22:32:08 <dmwit> map = Prelude.map --| documentation!
22:32:28 <sw17ch> dmwit, what about for a Type?
22:32:50 <sw17ch> type Thing = Foo.Thing
22:32:51 <dmwit> same trick, but with type?
22:32:52 <sw17ch> ?
22:32:55 <dmwit> I guess.
22:32:57 <sw17ch> hehe
22:32:58 <dmwit> It's not ideal, is it?
22:32:58 <dsrogers> where is the ghc bug tracker?
22:33:07 <dmwit> ?where bugs
22:33:08 <lambdabot> I know nothing about bugs.
22:33:12 <dmwit> ?where trac
22:33:13 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:33:22 <mmorrow> class LarvalMonad m where return :: a -> m a
22:33:28 <sw17ch> dmwit, no... i was hoping to keep all my FFI functions in one file, and then expose all the ones i needed in a prettier file which wraps them
22:33:50 * sw17ch thinks he'll probably end up merging the two and exposing only what's needed
22:33:52 <dmwit> dsrogers: I recall vaguely having to log in to get anything useful out of Trac, but I don't remember the community username/password, sorry.  Maybe somebody else does?
22:34:22 <rwbarton> guest/guest I think?
22:36:21 <dsrogers> woohoo!  HAppS works!
22:36:54 <dsrogers> that only required patching ghc and the network package!
22:37:30 <mmorrow> lispy: i just can't get the word "larval" out of my head now
22:37:56 <lispy> mmorrow: muuwhahahahaahhah!
22:38:04 <mmorrow> hahaha
22:38:27 <lispy> dmwit: yeah, that always stinks about track
22:38:31 <lispy> er trac
22:39:11 <consolers> linenoise charset in operators is single most confusing thing for me
22:39:40 <consolers> even perl didnt let you extend the linenoise!
22:39:44 <SamB_XP> consolers: what ELSE would you construct them from?
22:40:25 <consolers> well i come from the common-lisp-prefix-background heh
22:41:00 <dmwit> User-defined infix operators are pretty nice.
22:41:32 <dsrogers> yikes, my irc history is short.
22:41:41 <lispy> User-defined infix operators are often annoying though unless you're very familiar with them
22:41:45 <dsrogers> someone gave me a like to a SQL domain language thingy?
22:41:53 <dsrogers> anyone have that handy again?
22:42:03 <lispy> dsrogers: domain specific compiler embedded by daan
22:42:31 <mmorrow> dsrogers: search google for:   #haskell logs and hit "i'm feeling lucky"
22:43:49 <paczesiowa> can I autoderive Eq after type definition?
22:46:02 <lispy> paczesiowa: not in a standard way, but things like Drift can
22:46:27 <lispy> http://repetae.net/computer/haskell/DrIFT/
22:46:29 <lambdabot> Title: DrIFT Homepage
22:51:56 <paczesiowa> damn, 100 loc because someone forgot to "derive Eq":(
22:52:12 <brad_larsen> question:  using GHC, I notice some strange behavior...
22:52:30 <brad_larsen> in main, I have a let binding for a fairly large data structure
22:52:58 <brad_larsen> after the let binding, I loop an IO action forever, that takes user input and dispatches accordingly
22:53:26 <brad_larsen> if I don't force the large data structure before going into that loop, it is recomputed each time it is accessed
22:53:51 <brad_larsen> if I do force (i.e. evaluate) the data structure before going into the loop, it is only computed once
22:54:02 <brad_larsen> is that normal behavior?
22:54:04 <brad_larsen> it surprised me
22:55:07 <rwbarton> It shouldn't recompute the data structure, even if you don't force it, if I understand what you're doing...
22:55:26 <brad_larsen> that's what I thought.
22:55:53 <brad_larsen> and i think you understand me.
22:55:54 <rwbarton> is the code small enough to hpaste?
22:56:22 <brad_larsen> it's a couple hundred lines
22:57:17 <TSC> Have a look at this, maybe: http://www.haskell.org/pipermail/haskell-cafe/2008-January/037578.html
22:57:18 <lambdabot> Title: [Haskell-cafe] what does @ mean?....., http://tinyurl.com/5e33ol
22:57:53 <TSC> One version has sharing (less recomputation but more space), the other doesn't
22:58:00 <TSC> Maybe it's relevant to your program
22:58:07 <dsrogers> damn it.  this paper shows my idea isn't original!
22:58:23 <OceanSpray> Few ideas ever are.
22:58:26 <brad_larsen> hmmm.
22:58:28 <rwbarton> It souns like brad_larsen has sharing and recomputation
22:58:36 <rwbarton> but that shouldn't happen...
22:58:37 <brad_larsen> TSC: perhaps it is.
22:58:52 <brad_larsen> why would I get recomputation w/ sharing, though?
22:59:11 <rwbarton> How do you know you have recomputation?
22:59:27 <brad_larsen> Debug.Trace.trace
22:59:36 <brad_larsen> i noticed it by accident
22:59:58 <rwbarton> and it's not just computing different parts of the structure?  (if you have trace in a list or something)
23:00:19 <rwbarton> or you only get one trace when you force it first?
23:01:02 <brad_larsen> yes, it's recomputing the same part.
23:01:19 <brad_larsen> i have a type that is an IntSet of graphs, among some other things
23:01:41 <brad_larsen> building the graphs takes a while, so i print a status message with trace
23:02:17 <brad_larsen> once the program goes into the "main loop", the user can enter commands that query different graphs in the data structure
23:02:50 <brad_larsen> if I print out total # of nodes and edges of all the graphs before going into the loop, all the graphs are built at the beginning
23:02:55 <brad_larsen> and never recomputed
23:03:38 <brad_larsen> if i comment out the printing of # of nodes and edges, the appropriate graph in the data structure is recomputed at each query
23:03:47 <brad_larsen> takes a long time, and i see the trace messages
23:06:19 <r0ns> hi,i got a doubt..am not a coder basically..just helping some of the coders oin our office
23:07:25 <r0ns> my doubt is he wants to access a webservice remotely..but in our office we got squid proxy with authentication,what he has to do inroder to passthrough this?
23:07:56 <sclv> brad_larsen: could be a polymorphism issue... possibly?
23:08:00 <r0ns> i googled..i came across something like proxy class..any of you guys can explain a bit?
23:08:16 <sclv> i.e. a thing that seems to be a CAF but really isn't because its polymorphic in one or another type...
23:08:22 <brad_larsen> sclv: i'm investigating now...
23:09:19 <sclv> r0ns: this is probably the wrong channel to ask in... this channel is about the haskell programming language.
23:09:33 <r0ns> oh sorry
23:10:06 <r0ns> any idea which channel support asp etc on freenode?
23:11:31 <SamB_XP> r0ns: so how did you find this channel?
23:11:51 <paczesiowa> lispy: is that drift thing working for you? it fails to find imported modules for me (and those modules aren't needed for deriving)
23:17:35 <brad_larsen> do you think my issue is a bug?  It shows up on my 32-bit linux laptop, but not on 64-bit linux system
23:17:58 <brad_larsen> on my 64-bit machine, there is no recomputation, with the exact same code/compile options
23:18:39 <rwbarton> brad_larsen: see if you can replicate the bug with a smaller program
23:20:12 <Zao> Hehe, cabal fails rather exceptionally if your cwd doesn't exist.
23:20:19 <Zao> Time to dig out my cabal trac user again.
23:20:30 <Zao> Well cabal-install fails.
23:20:59 <Zao> How do I know if an issue is from Cabal or cabal-install?
23:21:40 <brad_larsen> eeesh.  on a different 64-bit system, the recomputation happens
23:25:54 <r0ns> SamB_XP: lol..some one pointed it to me
23:26:31 <brad_larsen> if I compile w/o GHC optimization, no recomputation occurs
23:27:30 <SamB_XP> brad_larsen: huh
23:28:34 <brad_larsen> SamB_XP: compiling my program with -O2 as a ghc option seems to cause a certain expensive computation to be recomputed each time a data structure is accessed
23:28:49 <brad_larsen> but without any optimization, it doesn't occur
23:29:28 <sw17ch> how do i tell haddock where things like Int and Enum are defined?
23:29:58 <sw17ch> never mind ,that wouldn't make sense without the rest of the haskell docs :)
