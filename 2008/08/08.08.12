00:00:09 <Korollary> lispy: But, is it correct?
00:00:22 <lispy> Korollary: I don't know.
00:01:16 <lispy> One of the things I don't like about patch theory is that it seems to prevent optimization
00:01:43 <lispy> I forgot to time it, but I just finished that convert all
00:02:14 <lispy> about 20 minutes
00:02:57 <lispy> I should install 6.8.3 and do it again with HPC
00:03:06 <lispy> That would be a cool chart
00:03:26 <lispy> oh wait, I don't need 6.8.3 for hpc do i?
00:06:21 <Korollary> It's a good thing that I don't care about dvcs
00:26:44 <ivanm> what's happened to lambdabot?
00:27:04 <lispy> ivanm: after the car accident she just hasn't been right
00:27:27 <ivanm> :(
00:27:28 <Korollary> The bitch was commiting insurance fraud anyway
00:27:32 <ivanm> where can I send flowers?
00:27:32 <ivanm> ;-)
00:27:34 <ivanm> Korollary: heh
00:30:15 * lispy heads home
00:30:35 <lispy> I should just bring a sleeping bag to the office tomorrow.
00:40:13 <swiert> coq
01:04:56 <totimkopf> will code in a book intended for hugs98 also work in GHC?
01:05:32 <totimkopf> i mean, there's no difference in syntax is there?
01:06:09 <Zao> Assuming that it uses Haskell98, likely.
01:13:45 <RayNbow> totimkopf: it should
01:14:04 <RayNbow> but the other way around... not necessarily...
01:14:15 <RayNbow> I once tested some code in GHC and handed it to someone who was using Hugs
01:14:38 <RayNbow> Hugs gave some error message (which were fixed by manually adding some type annotations)
01:19:11 <bos> @seen dons
01:19:11 <lambdac> dons is in #haskell. I last heard dons speak 1h 21m 34s ago.
01:26:53 <therp> I like google. even the javascripty widgets on blogspot.com are designed from someone who knows how to proper recursion.
01:27:20 <therp> s/how to/how to do/
01:29:28 <solrize> hey bos, book.realworldhaskell.org is dead :(
01:32:19 <jsnx> does anybody else have trouble with getNameInfo when running this code?
01:32:20 <jsnx> http://pastebin.com/m7fcb017e
01:32:38 <jsnx> it appears to be in the `accept` call
01:33:00 <superjudge> solrize: I thought so too, but it seems it is the comment-system that has problems. When I reloaded the book from the top (i.e. http://book.realworldhaskell.org), I get everything except the comments (they just say "Loading...").
01:33:33 <superjudge> So I guess it's sort of dead, but not totally... :-)
01:33:50 <solrize> i can't connect to the server at all from here
01:34:40 <superjudge> Hmm, ok... well, I got that kind of behavior at first, when I tried to reload the chapter I was reading; starting over from the "top" worked for me, but maybe there are other problems after all...
01:35:40 <solrize> it's dim, jed
01:39:56 <quicksilver> jsnx: what is getNameInfo ?
01:41:16 <jsnx> quicksilver: when i run the code and connect to the server, the server bails with "getNameInfo: does not exist (System error)"
01:41:35 <jsnx> i believe this amounts to "host not found"
01:42:34 <jsnx> according to the internets, folks in HApps had trouble with this in january, but sporadically
01:43:49 <quicksilver> jsnx: what OS is that?
01:44:03 <quicksilver> OSX, I gather.
01:44:10 <quicksilver> looks like an OSX bug to me.
01:44:45 <quicksilver> a bug in OSX's implementation of posix network semantics.
01:45:17 <quicksilver> hmm. maybe not.
01:45:33 <Axman6> unlikely in Leopard i think
01:45:49 <cladhaire> the issue happens in leopard and it has to do with reverse lookups
01:45:56 <cladhaire> I haven't been able to figure out the root cause either =/
01:46:14 <cjs> jsnx: Ah ha! You got caught by that, too.
01:46:25 <quicksilver> well the question is why does it care if the reverse lookup fails.
01:46:34 <quicksilver> a failure to reverse lookup should not bomb out of accept.
01:46:38 <cladhaire> thats is in fact one question :P
01:46:57 <Zao> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg17125.html
01:46:59 <Zao> Related?
01:47:00 <lambdac> Title: Re: [GHC] #2005: localhost on mac causes getnameinfo error in safari., http://tinyurl.com/5hzhlo
01:47:27 <cjs> Actually, if the program is somehow linked to use tcpwrappers, that could be the issue.
01:47:48 <cladhaire> Zao: seems to be, that's rather obnoxious =/
01:48:10 <cladhaire> at least a fix has been submitted
01:48:27 <cjs> For the IPv6 thing?
01:48:31 <cladhaire> yeah
01:48:34 <cjs> Which one? I've got an open ticket about that.
01:48:41 <cjs> (I.e., which fix?)
01:48:46 <cladhaire> http://www.haskell.org/pipermail/libraries/2008-July/010239.html
01:48:47 <lambdac> Title: darcs patch: Fix #2005 [network package]
01:48:51 <quicksilver> zao that seems to be the bug, yes.
01:48:51 <cladhaire> I suspect that will fix the issue
01:48:56 <cjs> I proposed just adding PortNumber6, and making PortNumber always bind to IPv4.
01:48:57 <quicksilver> I think it must be a 6.8.x bug
01:49:10 <quicksilver> since I don't see it in 6.6 and I've written lots of network stuff
01:49:12 <cladhaire> well this bug should be fixed
01:49:27 <cjs> Oh, that fix is something different.
01:49:27 <cladhaire> if netbsd and macosx require that field in the struct to be set
01:49:38 <cjs> quicksilver: it depends on the OS.
01:50:03 <quicksilver> cjs: I use OSX.
01:50:04 <cjs> In particular, Linux will never see the problem unless you turn off the "do an insecure listen on both IPv4 and IPv6" option somehow.
01:50:37 <quicksilver> cjs: are you saying #2005 is not jsnx's issue? or are you saying it wasn't the issue you saw?
01:50:37 <cjs> Probably even depends on the version. But yeah, different ways of approaching how you do networking would make a difference, too.
01:50:46 <quicksilver> because #2005 looks a lot like jsnx's issue to me.
01:51:53 <Axman6> anyone have any nice prime testing functions?
01:52:19 <cjs> quicksilver: That seems related to my issue.
01:52:51 <jsnx> thanks guys, i have some perspective now
01:53:00 <jsnx> i'm using a mac, yes, with leopard
01:53:30 <jsnx> so now i have to apply this patch, i guess?
01:55:09 <cjs> Try ticket 2391.
01:56:02 <jsnx> cjs: ticket 2391 of the GHC trac?
01:59:38 <cjs> Yup.
01:59:53 <cjs> Note that you're using Network, so you're affected by this exact issue.
02:00:04 <cjs> It would be nice to resolve this for ghc 6.10.
02:00:05 <jsnx> right
02:00:30 <jsnx> i can't wait for IPv8 to come out and fix all these problems :)
02:01:21 <cjs> Ah, good old Itojun. He's got a document on the issue.
02:01:30 <Zao> The network library could probably use an overhaul.
02:01:32 <Zao> See http://hackage.haskell.org/trac/ghc/ticket/2250
02:01:35 <lambdac> Title: #2250 (unpackFamily on Windows fails match) - GHC - Trac
02:02:36 <jsnx> interesting
02:02:50 <jsnx> well, i am going to leave these open in my browser window and go to bed
02:02:53 <jsnx> thank you everyone
02:04:46 <Axman6> so, anyone have a nice (efficient) function to test if a number is prime?
02:06:08 <quicksilver> There is no such thing.
02:06:14 <Axman6> wondering how much faster i can test
02:06:20 <quicksilver> There is nothing better than checking every prime up to sqrt(n)
02:06:26 <Axman6> thsat sentense was terrible -_-
02:06:44 <quicksilver> which involves listing all the primes up to sqrt(n)
02:06:50 <Axman6> yeah, i'm not using a list of primes
02:07:11 <Axman6> just 2 and every odd number
02:07:49 <rwbarton> how big are the numbers you're testing?
02:08:01 <Axman6> which seems pretty fast, since i'm not calculating all other primes
02:08:29 <Axman6> well the one i have now will test 18014398777917439 in about 2-3 seconds in ghci
02:08:30 <quicksilver> there are fast approximate checks
02:08:51 <quicksilver> which save some time on the case that the number turns out not to be prime.
02:08:59 <quicksilver> but they don't save any time in the case that it is prime
02:09:07 <Axman6> yeah
02:09:13 <quicksilver> (in fact, they make it slower!)
02:09:33 <rwbarton> ... it was shown a few years ago that primality testing takes only polynomial time in the number of digits
02:10:45 <quicksilver> rwbarton: oh, really?
02:11:01 <quicksilver> rwbarton: then there must be an algorithm which is asymptotically better than checking up to sqrt(n)
02:11:05 <quicksilver> still, I bet it's not feasible.
02:11:26 <rwbarton> quicksilver: yep, www.math.princeton.edu/~annals/issues/2004/Sept2004/Agrawal.pdf
02:11:36 <Axman6> ok, maybe it can't do 99194853094755497 in a few seconds. just felt like it because i went off and did something else :P
02:12:37 <cjs> There are various other issues in the networking stuff, too. This one bit me and at least one other person in the last month or two:
02:12:39 <cjs> http://hackage.haskell.org/trac/ghc/ticket/2446
02:12:41 <lambdac> Title: #2446 (Network.Socket.PortNum should not be exported) - GHC - Trac
02:13:40 <quicksilver> yes, that's just confusing
02:13:45 <quicksilver> not really a 'bug' as such
02:13:51 <quicksilver> just poor documentation and a bad decision to export
02:13:55 <quicksilver> but it's certainly confusing.
02:13:57 <cjs> Hm. I think that that function I had kicking around to quickly factor the product of two primes had some help for that.
02:14:09 <cjs> quicksilver: Yeah. A very poor decision to export.
02:14:29 <cjs> Well, maybe I'll try to free up some time and chase down both of those issues on the libraries list.
02:14:53 <quicksilver> s/chase down/submit patches/ ?
02:14:59 <quicksilver> because that's the way to get them fixed.
02:15:18 <cjs> Well, I first need to get agreement from people on the way to do it.
02:15:29 <cjs> And then I guess I need to figure out how to build ghc, which seems non-trivial.
02:15:45 <cjs> But yes, submitting patches is without question the best way to do it.
02:17:47 <quicksilver> building the libraries doesn't involve building ghc
02:19:10 <RayNbow> <dons> interesting, luqui, http://www.reddit.com/comments/6vxp4/all_functions_are_continuous_always/ <-- luqui's site seems to be down for me
02:19:19 <lambdac> Title: All functions are continuous, always : reddit.com, http://tinyurl.com/6ezmzo
02:21:24 <cjs> quicksilver: Oh, right! Well, that makes it much easier.
02:21:42 <solrize> that site is down but yeah, all functions are continuous is a standard feature of constructive analysis
02:28:23 <xsdnyd> hi there
02:29:11 <xsdnyd> i want to compare two lists (of the same type). i wrote a recursive function but i think there exists a way to do it as one-liner. perhabs with a neat standard-function... can anyone give me a hint? thanks :)
02:30:04 <Deewiant> > compare [1,2,3] [4,5,6]
02:30:05 <lambdac>  LT
02:30:09 <dobblego> > [1..5] `compare` [3,4,5]
02:30:10 <lambdac>  LT
02:30:25 <therp> deewaint: ==?
02:30:45 <Deewiant> == is ==, compare is ==, <, > rolled into one
02:30:48 <vixey> xsdnyd: What is your function?
02:30:56 <therp> Deewiant: probably you mean setwise equality?
02:32:34 <xsdnyd> i have two lists of type string and want to compare each item with ==
02:32:37 <Deewiant> therp: no, for lists it's just lexicographical
02:32:47 <Deewiant> > "foo" == "foo"
02:32:47 <xsdnyd> perhabs the compare function does what i want... i test it :)
02:32:48 <lambdac>  True
02:33:54 <xsdnyd> can i just do this: ["1", "two"] == ["1", "two"] ?
02:33:56 <xsdnyd> will it work?
02:34:13 <Axman6> foldr (&&) $ zipWith (==) list1 list2?
02:34:18 <rwbarton> > ["1", "two"] == ["1", "two"]
02:34:19 <quicksilver> xsdnyd: yes.
02:34:20 <lambdac>  True
02:34:31 <xsdnyd> cool. thanks guys :)
02:34:32 <quicksilver> xsdnyd: (why didn't you just try it instead of asking, it would have been faster :)
02:34:39 <xsdnyd> yeah right...
02:34:42 <xsdnyd> :)
02:34:51 <Axman6> ["1","one"] == ["2", "two"]
02:34:56 <Axman6> > ["1","one"] == ["2", "two"]
02:34:57 <lambdac>  False
02:35:01 <Axman6> ok, good
02:36:34 <Axman6> > foldr (&&) $ zipWith (==) [1,2,3] [1,2,3]
02:36:35 <lambdac>  Couldn't match expected type `Bool' against inferred type `[Bool]'
02:36:49 <Axman6> > zipWith (==) [1,2,3] [1,2,3]
02:36:51 <lambdac>  [True,True,True]
02:37:15 <Axman6> > all True $ zipWith (==) [1,2,3] [1,2,3]
02:37:16 <lambdac>  Couldn't match expected type `a -> Bool'
02:37:28 <Axman6> > all (== True) $ zipWith (==) [1,2,3] [1,2,3]
02:37:29 <lambdac>  True
02:37:35 <Axman6> > all (== True) $ zipWith (==) [1,2,3] [1,2,4]
02:37:36 <lambdac>  False
02:37:47 <quicksilver> Axman6: doesn't worth with unequal length lists though
02:37:58 <Axman6> ah yes
02:38:05 <Axman6> lambdac == lambdabot yes?
02:38:29 <rwbarton> @pl (== True)
02:38:29 <lambdac> (True ==)
02:38:41 <Axman6> @src (==) :: []
02:38:42 <lambdac> Source not found. My mind is going. I can feel it.
02:38:47 <Axman6> @src (==)
02:38:47 <lambdac> x == y = not (x /= y)
02:38:51 <Axman6> @src (/=)
02:38:52 <lambdac> x /= y = not (x == y)
02:39:14 <quicksilver> same program, yes
02:39:17 <quicksilver> different instance
02:39:22 <quicksilver> @quote quicksilver
02:39:22 <lambdac> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
02:39:23 <lambdac> will stab you in the back with a mantissa
02:39:35 <quicksilver> hmm it even has some version of the quote DB
02:39:38 <quicksilver> that's a very old one though
02:39:40 <quicksilver> @quote quicksilver
02:39:40 <lambdac> quicksilver says: learning from other people's mistakes is so web 1.0
02:39:42 <quicksilver> @quote quicksilver
02:39:42 <lambdac> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
02:39:44 <quicksilver> @quote quicksilver
02:39:44 <lambdac> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
02:39:46 <quicksilver> @quote quicksilver
02:39:46 <lambdac> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
02:39:49 <quicksilver> @quote stero
02:39:50 <lambdac> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
02:39:52 <quicksilver> @quote stereo
02:39:52 <lambdac> Plugin `quote' failed with: getRandItem: empty list
02:39:53 <quicksilver> @quote stereo!
02:39:54 <lambdac> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
02:40:45 <RayNbow> Axman6: and = all (==True)
02:41:42 <Axman6> heh, yeah i knew there was something, just forgot it's name
02:41:58 <Axman6> @src and
02:41:58 <lambdac> and   =  foldr (&&) True
02:42:11 <RayNbow> @src all
02:42:11 <lambdac> all p =  and . map p
02:46:10 <xsdnyd> i have a "Maybe String". if this is "Just s" i want to do something. if it is "Nothing" i just want to do nothing. but if i use an "if" i must also use the "else". and if i use a case expression ghc shows a warning because i don't catch the "Nothing" value... does anyone know a good solution for this?
02:46:56 <BONUS> xsdnyd: use do notation
02:46:59 <BONUS> or >>=
02:47:27 <rwbarton> xsdnyd: what do you mean by "do something"?  Perform some IO action?
02:47:32 <xsdnyd> yes
02:47:44 <xsdnyd> i am already in a do construct
02:48:05 <BONUS> you can introduce another one or use >>=
02:48:21 <BONUS> > Just "hey" >>= (++ " guys")
02:48:23 <lambdac>  Couldn't match expected type `Maybe b'
02:48:25 <rwbarton> xsdnyd: in the Nothing branch of the case, you can write "return ()"
02:48:28 <BONUS> > Just "hey" >>= return . (++ " guys")
02:48:29 <lambdac>  Just "hey guys"
02:48:37 <BONUS> > Nothing >>= return . (++ " guys")
02:48:38 <lambdac>  Nothing
02:48:47 <xsdnyd> mhhh
02:48:58 <BeelsebobWork> @seen Cale
02:48:58 <lambdac> Cale is in #haskell. I don't know when Cale last spoke.
02:49:10 <BONUS> oh you're already inside the IO monad? aha
02:49:10 * BeelsebobWork ponders if Cale is about to be poked
02:49:24 <BONUS> so what do you want to do in case of a nothing?
02:50:04 <xsdnyd> nothing
02:50:15 <xsdnyd> in case of Just s (s of type string) i print out the string
02:50:43 <xsdnyd> so my ideal code would be: if value == Just s then hPutStrLn stdout s
02:50:45 <RayNbow> > (++ " guys") `fmap` Just "hey"
02:50:46 <lambdac>  Just "hey guys"
02:51:05 <rwbarton> "value == Just s" doesn't create a new variable s
02:51:13 <xsdnyd> oh
02:51:20 <rwbarton> you want: case value of Just s -> putStrLn s ; Nothing -> return ()
02:51:37 <BONUS> case x of (Just s) -> print s; Nothing -> return ()
02:51:41 <BONUS> agh beat me to it
02:51:44 <xsdnyd> ok thanks. i will use that code :)
02:51:46 <BeelsebobWork> @seen dons
02:51:47 <lambdac> dons is in #haskell. I last heard dons speak 2h 54m 11s ago.
02:51:50 <BeelsebobWork> @seen lispy
02:51:51 <lambdac> lispy is in #haskell-blah and #haskell. I last heard lispy speak 2h 21m 18s ago.
02:52:30 <totimkopf> hehe
02:53:01 <totimkopf> haskell's syntax is yummy on the eyes
02:53:49 <quicksilver> xsdnyd: I often define 'whenJust' for that
02:53:55 <quicksilver> it turns out to be a common idiom
02:54:10 <quicksilver> whenJust mb a = case mb of (Just x) -> a x; Nothing -> return ()
02:54:22 <xsdnyd> thx. thats a good shortcut :)
02:55:17 <spx2> are the parts of list processing from Prolog common to LISP and Haskell ?
02:55:43 <spx2> s/and/and\/or/
02:55:50 <Axman6> quicksilver: looks like it should be added somewhere...
02:56:40 <vixey> spx2: No not really :)
02:56:54 <spx2> vixey: oh you are here also :)
02:57:58 <vixey> well ok
02:58:02 <vixey> one thing is common
02:58:13 <vixey> in haskell list are [] or  x : xs
02:58:19 <vixey> in lisp () or (x . xs)
02:58:27 <vixey> in prolog [] or [X|Xs]
02:58:34 <vixey> they are always made from nil and conses
02:58:45 <KillerSmurf> <shamelessplug> Here's a mandelbrot zooming app written in haskell at www.killersmurf.com.  enjoy :) </shamelessplug>
02:58:56 <vixey> despite that they are really different characters
02:59:05 --- mode: ChanServ set +o quicksilver
02:59:09 --- mode: quicksilver set +b *!*n=spoon@*.range86-167.btcentralplus.com
02:59:09 --- kick: KillerSmurf was kicked by quicksilver (quicksilver)
02:59:15 <vixey> KillerSmurf: sounds cool..
02:59:17 --- mode: quicksilver set -o quicksilver
02:59:21 <quicksilver> Oops
02:59:28 <vixey> quicksilver, lol
02:59:30 <quicksilver> I missed the 'in haskell' part.
02:59:31 <vixey> I think he was genuine
02:59:51 <quicksilver> joining an IRC channel and pasting a promotioanl URL as your first comment is risky.
02:59:51 <TSC> http://paste.lisp.org/display/65192
03:00:03 <vixey> quicksilver a little too quick ?
03:00:05 --- mode: ChanServ set +o quicksilver
03:00:10 <TSC> Can anyone critique that one-liner?
03:00:13 <quicksilver> apparently so, yes.
03:00:20 --- mode: quicksilver set -b *!*n=spoon@*.range86-167.btcentralplus.com
03:00:22 <TSC> It's supposed to read a single value from a file
03:01:01 <TSC> I feel like it could be made less pointy, but I can't figure out how
03:01:14 <rwbarton> :t readFile
03:01:16 <lambdac> FilePath -> IO String
03:01:29 <TSC> Mm
03:01:32 <quicksilver> @pl withFile filename ReadMode (\h -> hGetContents h >>= (\c -> (return $! readMay c)))
03:01:33 <lambdac> withFile filename ReadMode (((return $!) . readMay =<<) . hGetContents)
03:01:46 <quicksilver> TSC: @pl knows how to make things less pointy ;)
03:01:54 <TSC> Yeah, I know
03:01:58 <TSC> Mmm
03:02:09 <quicksilver> you may also like >=>
03:02:15 <TSC> @type (>=>)
03:02:16 <lambdac> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:02:20 <quicksilver> hGetContents >=> return . readMay
03:02:23 <smg> > map (\x -> if x /= "." then 'x' else '.') $ group "1234.2345.2334.1213"
03:02:24 <lambdac>  "xxxx.xxxx.xxx.xxxx"
03:02:26 <smg> can wer shorten this?
03:02:48 <TSC> Thanks quicksilver, rwbarton
03:03:08 <conal> is there a version of cabal that knows about the language extension ImpredicativeTypes?
03:03:14 <quicksilver> TSC: that looks like a superfluous $!, to me.
03:03:52 <TSC> No
03:03:55 <TSC> I was just about to say that (:
03:04:03 <TSC> The version with >=> and . doesn't work
03:04:08 <TSC> You need the $! to force getContents
03:04:15 <TSC> Otherwise the file gets closed before the read happens
03:04:17 <opqdonut> smg: well you can shave two bytes off by saying "else x)"
03:04:18 <opqdonut> :P
03:04:29 <TSC> Then when the read does occur, getContents returns "" and read fails
03:04:29 <smg> opqdonut: hrhr
03:04:31 <quicksilver> TSC: what type does readMay have?
03:04:42 <lambdapants> quicksilver: I'm really sorry for the shameless plug, I just wanted to help people understand efficient math algorithms :(
03:04:42 <smg> opqdonut: i mean is there a nicer solution
03:04:43 <TSC> readMay :: Read a => String -> Maybe a
03:04:47 <TSC> It's just a safe version of read
03:04:48 <quicksilver> lambdapants: it's not a problem.
03:04:49 <rwbarton> TSC: I think that's because you're using withFile rather than readFile
03:04:53 <quicksilver> lambdapants: I msged you to apologise
03:05:00 <TSC> Yeah, readFile takes care of all this I suppose
03:05:03 <quicksilver> lambdapants: presumably you didn't get that.
03:05:20 <quicksilver> readFile breaks it, argubaly
03:05:27 <quicksilver> ;)
03:05:44 <quicksilver> but it will work.
03:05:46 <lambdapants> I have a paranoid disorder, I unplugged my router as soon as I saw my internet loc come up
03:05:48 <lambdapants> ;)
03:05:50 <quicksilver> lambdapants: lol.
03:05:55 <smg> lol
03:06:17 <quicksilver> I kicked you reflexively because you joined and immediately pasted a URL which didn't look haskell related.
03:06:23 <quicksilver> I actually didn't read the 'in haskell' part
03:06:25 <quicksilver> I'm sorry :)
03:06:29 --- mode: quicksilver set -o quicksilver
03:06:46 <lambdapants> I soppose it was still rather rude of me not to say "hello!"
03:07:02 <lambdapants> anyway, I have stuff to do, hence my abruptness, so I will see you later!  Have fun, all.
03:07:29 <TSC> readFile does fix it
03:07:45 <TSC> Does readFile not have the half-closed file handle nonsense that getContents does?
03:08:03 <TSC> In other words, is readFile guaranteed to return the whole file's contents?
03:08:22 <rwbarton> TSC: Yeah, because it doesn't ever expose the file handle, so you can't break it by using withFile :)
03:08:27 <rwbarton> @src withFile
03:08:27 <lambdac> withFile name mode = bracket (openFile name mode) hClose
03:08:55 <TSC> Oh, withFile has a hClose in it
03:09:03 <TSC> Duh
03:09:15 <TSC> Well, that's much better
03:09:25 <TSC> I had thought that readFile was more or less like getContents
03:09:34 <cjs> Hey, I still don't know how to pronounce "<-". Any hints.
03:09:36 <cjs> ?
03:09:37 <TSC> Anyway, now it's:  readFromFile filename = liftM readMay (readFile filename)
03:09:43 <TSC> Which is much nicer; thanks again!
03:10:22 <TSC> readFromFile = liftM readMay . readFile        -- even better
03:11:05 <TSC> cjs: in what context?  List comprehension, do block?
03:11:24 <Zao> smg: let f "." = '.'; f _ = 'x' in map f $ group "1234.2345.2334.1213"
03:11:40 <cjs> do block.
03:11:49 <Zao> cjs: Some call it bind.
03:11:57 <TSC> "gets" might work
03:12:10 <TSC> But >>= is bind
03:12:57 <quicksilver> "gets" is the most common reading I'm aware of.
03:13:26 <quicksilver> "gets" is widely used by CS people for "=" and ":=" when they are used in the imperative sense
03:13:30 <Botje> c <- getLine -- getLine to c
03:13:36 <Botje> or goes to c :)
03:13:44 <quicksilver> (as a preferably reading to "equals" which is how naive programmers like I used to be read them ;)
03:14:24 <Zao> Ah, gets is a good fit.
03:14:55 <quicksilver> I have sometimes heard "becomes"
03:15:07 <quicksilver> or "from"
03:15:37 <quicksilver> TSC: IMO it's a bug that readFile and hGetContents are not strict.
03:15:45 <quicksilver> TSC: but this opinion is fairly well recorded ;)
03:17:19 <TSC> I think it would be better to have a strict and a lazy version
03:17:47 <quicksilver> it would be better not to use the word lazy
03:17:52 <quicksilver> because this isn't lazyness.
03:17:59 <quicksilver> and it would be better if the strict version were default.
03:18:47 <BONUS> you mean it would be better if readFile just read the whole file at once into memory?
03:18:49 <cjs> "Bind" makes sense to me, since it really is just syntatic sugar for bind, isn't it?
03:19:09 <opqdonut> mhmm
03:19:48 <TSC> quicksilver: Do you mean it's not laziness because it's really "not-guaranteed-to-perform-IO-in-the-order-you-think-it-is"?
03:19:57 <quicksilver> right.
03:20:09 <quicksilver> laziness is a referentially transparent property
03:20:20 <cjs> Anybody have any suggestions on a queue data structure?
03:20:22 <quicksilver> the whole point of laziness is it DOESNT MATTER when you evaluate it
03:20:24 <quicksilver> because it's pure.
03:20:32 <quicksilver> cjs: Data.Sequence
03:20:33 <TSC> Maybe readFile should be strict, and then the current implementation called unsafeReadFile
03:20:43 <quicksilver> TSC: or interleavedReadFile
03:21:09 <quicksilver> I think the term 'interleaved IO' or just 'interleaved' is a more cromulent description of what is often called 'lazy IO'
03:21:11 <TSC> Yes, that would do
03:21:27 * cizra ponders about laziness and I/O
03:21:30 <quicksilver> I'd be happy with unsafe, but some pople don't want to call it that because they don't think it's very unsafe
03:21:34 <quicksilver> and I do understand their point
03:21:37 <quicksilver> it's not all that unsafe.
03:21:49 <quicksilver> BONUS: yes, that would be a better default.
03:21:51 <TSC> Yeah, it's not quite as unsafe as other things, like unsafeCoerce
03:22:01 <cjs> Thanks.
03:22:01 <Spark> !dict cromulent
03:22:02 <trofimovich> @src group
03:22:02 <lambdac> group = groupBy (==)
03:22:11 <quicksilver> I should email the -cafe suggesting the alternative word use
03:22:17 <quicksilver> Spark: it's a joke word from the Simpsons.
03:22:24 <Spark> ah
03:22:31 <quicksilver> Spark: but its intended meaning is 'accurate or appropriate'
03:22:40 <rwbarton> Calling lazy evaluation referentially transparent but not readFile is not a black or white thing.  It depends on what you consider observable
03:22:43 <smg> Zao: hehe
03:22:55 <quicksilver> http://en.wikipedia.org/wiki/Lisa_the_Iconoclast
03:23:11 <Zao> smg: \x -> case x of ... is a bit too ugly, and is longer than yours, so I sprung for a let instead.
03:23:16 <quicksilver> rwbarton: yes, referentially transparent is actually not the right phrase for what I precisely mean.
03:23:25 <quicksilver> rwbarton: it's a convenient shortcut which points in the right direction.
03:23:50 <smg> Zao: okay, thanks
03:23:57 <quicksilver> rwbarton: to be more precise, I should say: the guiding principle of lazy evaluation is that, since all expressions in haskell are pure, it makes no difference to the program when an expression is evaluated.
03:24:27 <quicksilver> rwbarton: so-called "lazy IO" produces thunks which can evaluate to arbitrary different values, and launch nuclear missiles, depending when they are evaluated.
03:24:35 <quicksilver> rwbarton: they are therefore a perversion of lazy evaluation.
03:24:36 <TSC> Perhaps it has more to do with the assumption that any evaluation order gives the same result (if any), but with interleaved I/O that's not true
03:24:37 <rwbarton> quicksilver: OK, but in practice, readFile usually satisfies this property, while lazy evaluation often does not (see foldl')
03:24:47 <rwbarton> TSC: You are using the phrase "same result"
03:25:24 <quicksilver> rwbarton: I don't understand your point about foldl'.
03:25:41 <quicksilver> do you claim that lazy evaluation and strict evaluation produce different results for some folds?
03:26:19 <rwbarton> quicksilver: In the sense that lazy evaluation can cause your program to stack overflow
03:26:37 <quicksilver> that's an irrelevant implementation issue.
03:26:46 <quicksilver> theoretically, programs run in infinite stack space.
03:26:52 <quicksilver> and you can ask GHC to do that if you want.
03:26:58 <quicksilver> it's not a semantic issue.
03:27:00 <quicksilver> whilst the other is.
03:27:04 <rwbarton> quicksilver: You're basically *defining* IO to be those things which are not referentially transparent
03:27:12 <quicksilver> no I'm not.
03:27:16 <rwbarton> in which case calling readFile unsafe is clearly correct
03:27:21 <quicksilver> I"m defining IO to be what it is.
03:27:24 <quicksilver> a monad.
03:27:32 <quicksilver> with understood semantics.
03:27:42 <quicksilver> (understood if not written down or formalised)
03:28:01 <rwbarton> No, my point is, why do you assume that it matters what order IO effects occur in?
03:28:23 <quicksilver> that is part of the semantics of IO.
03:28:40 <quicksilver> readFile now and readFile later can produce different results.
03:28:43 <quicksilver> because files can change.
03:28:47 <quicksilver> surely you're not arguing with that?
03:28:48 <rwbarton> That's exactly what I meant above
03:29:29 <rwbarton> Also, if I change the performance characteristics of a program, that can cause some part of the code to take longer, changing the result of a strict readFile
03:29:45 <quicksilver> yes, I'm certainly not talking about performance characteristics
03:29:56 <quicksilver> I'm talking about a simple semantics, just the result of evaluation.
03:30:12 <quicksilver> I'm not aware of any haskell semantics which gives performance guarantees
03:30:19 <quicksilver> although such things are certainly interesting.
03:30:49 <rwbarton> So I don't understand why "readFile now and readFile later can produce different results" is relevant
03:31:00 <quicksilver> Hmm.
03:31:10 <rwbarton> If files are changing, you can't make any assertions about the output of your program
03:31:13 <quicksilver> I'm clearly failing quite badly to explain because this is extremely obvious to me.
03:31:15 <rwbarton> And if they aren't, then readFile is safe
03:31:23 <quicksilver> consider (1+2) * (3+4)
03:31:32 <quicksilver> and consider the two subthunks there
03:31:45 <quicksilver> the guiding principle of lazy evaluation is that it doesn't matter which order we evaluate those thunks
03:31:52 <quicksilver> because they will always return the same value.
03:31:57 <quicksilver> this is why lazy evaluation works!
03:32:05 <quicksilver> lazy evaluation works because in haskell all expressions are pure.
03:32:12 <Zao> They may quite possibly not be executed at all.
03:32:22 <quicksilver> if you tried to use lazy evaluation in ML, for example, all hell would break loose
03:32:29 <quicksilver> because in ML not-all-expressions are pure.
03:32:52 <quicksilver> So: the guiding principle of laziness is that, in a pure language, evaluation order does not affect the final result.
03:33:07 <quicksilver> therefore the compiler is free to make all kinds of decisions about when to evaluate or not evaluate.
03:33:20 <quicksilver> When you add unsafely-lazy-IO, like readFile, you have broken this assumption.
03:33:31 <quicksilver> the guiding principle of laziness is broken
03:33:38 <quicksilver> and changes to evluation order can be very important.
03:34:00 <rwbarton> You're choosing a notion of "sameness" which is exactly the ordered sequence of IO calls made by the program.
03:34:02 <quicksilver> essentially, with readFile, haskell is no longer a pure language.
03:34:08 <quicksilver> No, I'm not.
03:34:11 <rwbarton> That's a reasonable notion, but it isn't the only sensible one.
03:34:13 <quicksilver> My notion of sameness is about results.
03:34:18 <quicksilver> It's about number in memory.
03:34:22 <quicksilver> It has nothing to do with IO calls.
03:34:30 <rwbarton> You must have an example in mind which I'm not thinking of then
03:34:31 <quicksilver> I'm familiar with bisimulation and it's a useful notion
03:34:38 <quicksilver> but we don't need it to make this point.
03:36:37 <BeelsebobWork> @seen Cale
03:36:38 <lambdac> Cale is in #haskell. I don't know when Cale last spoke.
03:36:39 <BeelsebobWork> bad
03:36:41 <BeelsebobWork> bah*
03:37:46 <cizra> Hey, folks. I need some help with monads. http://www.haskell.org/~pairwise/intro/section3.html claims that "Nothing is ever evaluated unless it is going to be the return value of an evaluated 'monad' function, or unless it is needed to compute such a return value." However,
03:37:47 <lambdac> Title: Haskell for C Programmers
03:38:14 <Botje> however.. ? :)
03:38:15 <cizra> when I getLine and don't use the resulting line, it still wants to read the value.
03:38:32 <cizra> It still reads that line, although the result isn't used.
03:38:37 <cizra> Why?
03:38:41 <BONUS> IO is different
03:38:55 <Axman6> IO is evil
03:39:02 <Botje> to compute the return value of getLine you have to perform IO :)
03:39:21 <cizra> Absolutely, but this return value isn't used!
03:39:24 <quicksilver> IO isn't different.
03:39:32 <quicksilver> IO is *exactly* like every other monad.
03:39:36 <quicksilver> well, not exactly :)
03:39:36 <BONUS> hmm
03:39:42 <cizra> Why is it computed at all? So the IO or monadic functions are an exception?
03:39:47 <trofimovich> getline /= do getline (as in ghci)
03:39:54 <quicksilver> cizra: no, there is no exception.
03:40:04 <cizra> exception in general laziness, I meant.
03:40:13 <quicksilver> cizra: that paragraph is, at best, very confusing.
03:40:19 <quicksilver> At worst its utterly incorrect.
03:40:43 <cizra> quicksilver: The second sentence is "That the 'IO monad' forces evaluation isn't really important, but"
03:40:52 <quicksilver> I generally find it convenient to distinguish 'execution' from 'evaluation'
03:41:03 <quicksilver> 'execution' is when side effects actually occur.
03:41:07 <quicksilver> Like printing something to the terminal
03:41:13 <quicksilver> or reading a string from the terminal.
03:41:25 <quicksilver> 'evaluation' is when a haskell expression gets reduced towards its value.
03:41:34 <cizra> Is there a quick, no-brainer explanation for monads? Something that wouldn't require brain power to grok.
03:41:40 <quicksilver> 'evaluation' is always lazy unless you use a strictness annotation.
03:41:53 <quicksilver> 'execution' runs in sequence in monads, that's what they do.
03:41:59 <Axman6> cizra: ha, no
03:42:02 <EvilTerran> ?go you could have invented monads
03:42:03 <cizra> )=
03:42:03 <Botje> cizra: use them and work out the type errors
03:42:05 <lambdac> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
03:42:05 <lambdac> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
03:42:08 <quicksilver> sometimes a bit of execution will cause a bit of evluation.
03:42:17 <EvilTerran> ?go io monad for people who just don't care
03:42:19 <lambdac> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
03:42:20 <lambdac> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
03:42:22 <EvilTerran> i like those to
03:42:24 <BeelsebobWork> quicksilver: the execution of IO is still lazy -- it just so happens that each IO action returns a RealWorld that the next one needs to see fully evaluated before it can start
03:42:24 <EvilTerran> *two
03:42:24 <quicksilver> This means that the only thing that forces *EXECUTION* is binding an 'IO monad' function to 'main'.
03:42:31 <cizra> Thanks, I'll read them when I get time.
03:42:37 <BeelsebobWork> laziness is exactly why it happens in the correct order
03:42:37 <quicksilver> BeelsebobWork: I didn't say otherwise.
03:42:52 <quicksilver> BeelsebobWork: I said that execution runs in sequence in monads
03:42:55 <BeelsebobWork> quicksilver: yeh, but it was kinda implied in the difference between evaluation and execution
03:42:56 <quicksilver> BeelsebobWork: I didn't say it wasn't lazy
03:43:00 <quicksilver> I just said it was sequenced.
03:43:11 <BeelsebobWork> in that you explicitly said the evaluation was lazy
03:43:17 <BeelsebobWork> and that execution was somehow different
03:43:25 <quicksilver> cizra: note I have changed one word of his sentence
03:43:29 <quicksilver> in an critical way :)
03:43:33 <quicksilver> I think this makes it clearer.
03:43:44 <quicksilver> Binding an IO monaf funciton to main will force its execution
03:43:44 <cizra> Hmm, OK
03:43:53 <quicksilver> it won't force evaluation of everything, necessarily
03:43:58 <dcoutts> conal: check the output of ghc --supported-languages, Cabal knows about all of them (except PArr which is experimental and will be renamed)
03:44:00 <EvilTerran> cizra, for the getLine example you had there and suchlike, i tend to think about it this way - in most monads, (m >>= f) pattern-matches on the constructor for m, so evaluating (m >>= f) results in m being evaluated
03:44:04 <quicksilver> it will force evaluation of however much it needs to evaluate.
03:44:26 <EvilTerran> cizra, and, yes, IO is abstract, but you could think of it as "getLine" being kinda like a constructor for IO
03:44:29 <cizra> EvilTerran: uh..?
03:44:33 <dcoutts> lispy: yes, some of the project dirs have been created but not yet used by the people who requested them.
03:44:36 <cizra> EvilTerran: You know I'm a newbie, right?
03:44:53 <EvilTerran> ... i don't know how much of a newbie you are
03:45:05 <cizra> Well, somewhat.
03:45:10 <EvilTerran> ?src Maybe >>=
03:45:10 <lambdac> Source not found. Just what do you think you're doing Dave?
03:45:14 <EvilTerran> ?src Maybe (>>=)
03:45:14 <lambdac> (Just x) >>= k      = k x
03:45:15 <lambdac> Nothing  >>= _      = Nothing
03:45:32 <EvilTerran> ok, well, do{} blocks desugar into uses of >>=
03:45:38 <vixey> ?src Probably
03:45:38 <lambdac> Source not found. My pet ferret can type better than you!
03:45:50 * vixey demands a Probably monad
03:45:55 <idnar> haha
03:45:59 <idnar> what would that do? :P
03:46:00 <Botje> which does what?
03:46:03 <Axman6> @src [] (>>=)
03:46:03 <lambdac> xs >>= f     = concatMap f xs
03:46:03 <EvilTerran> as you can see in that ?src, if you're using Maybe as a Monad, that means the LHS of >>= is a value of type (Maybe a) for some a
03:46:07 <Botje> start up nethack when it's friday? :)
03:46:37 <EvilTerran> cizra, actually, allow me to rephrase - forget what i said about pattern-matching
03:46:47 <cizra> EvilTerran: I can't follow that stuff.
03:46:55 <EvilTerran> ok, i'll back up more
03:47:05 <cizra> EvilTerran: And, frankly, I must share my attention with my job etc. So can't think now. Sorry.
03:47:07 <Axman6> i thought of an interesting concept, that could be implimented in haskell. 'usually'. adds some skewed randomness
03:47:31 <EvilTerran> cizra, in "do foo; bar", the "side-effects" of foo happen before those of bar
03:47:49 <Axman6> so, > 50% of the time, it'd give you the expected result, but sometimes, another value of the same type
03:47:49 <EvilTerran> cizra, only in IO are those "side-effects" actually side-effects in the usual sense
03:48:13 <quicksilver> cizra: the two tutorials pasted in reponse to your question are good ones.
03:48:24 <EvilTerran> cizra, in other monads, they're things like escaping from the computation early (kinda like an exception)
03:48:26 <Axman6> i guess it would have to be a monad
03:48:29 <cizra> quicksilver: I'll read them when I can pinch some attention.
03:48:36 <cizra> EvilTerran: OK, I follow
03:49:14 <EvilTerran> Maybe is the monad that represents computations that may fail and short-circuit out the rest of the computation
03:49:46 <EvilTerran> basically, when you're using it in a do-block, each line must be of type (Maybe a) for some a
03:49:57 <EvilTerran> if one line is Nothing, the whole do-block is Nothing
03:49:58 <cizra> Hmm, like error checking?
03:49:59 <conal> dcoutts: (just noticed reply).  my problem is that my cabal lags behind what 'ghc --supported-languages' tells me, so i et a warning message from cabal.
03:50:07 <cizra> If the first action doesn't succeed, don't do the rest
03:50:08 <EvilTerran> if one line is (Just x) for some x, it goes on to the next line
03:50:18 <EvilTerran> > do Nothing; undefined
03:50:19 <lambdac>  Nothing
03:50:27 <cizra> > undefined
03:50:28 <lambdac>  Exception: Prelude.undefined
03:50:31 <cizra> ha
03:50:33 <EvilTerran> works fine, because the computation short-circuits before it reaches the undefined
03:50:36 <vixey> > do Something; undefined
03:50:36 <lambdac>   Not in scope: data constructor `Something'
03:50:38 <dcoutts> conal: that's ok, it's just a warning, it'll still work.
03:50:51 <cizra> EvilTerran: OK, I still follow
03:50:57 <EvilTerran> ?src listToMaybe
03:50:58 <lambdac> listToMaybe []        =  Nothing
03:50:58 <lambdac> listToMaybe (a:_)     =  Just a
03:51:12 <conal> dcoutts: right.  just a warning.  which i'd like to go away if i can.  otherwise, i'll live with it.
03:51:15 <EvilTerran> > do x <- listToMaybe [1,2,3]; return (x,x)
03:51:16 <conal> normally i use LANGUAGE in modules instead of Extensions in a .cabal, but we're working around a 6.8/6.9 difference (Rank2Types vs ImpredicativeTypes).
03:51:17 <lambdac>  Just (1,1)
03:51:20 <EvilTerran> > do x <- listToMaybe []; return (x,x)
03:51:23 <lambdac>  Nothing
03:51:27 <dcoutts> conal: but you'll not be able to upload packages to hackage that use unregistered extensions. So if ghc has added new extensions in 6.9 then we have to poke the ghc devs to get it listed.
03:51:48 <EvilTerran> cizra, dead clever, isn't it? :)
03:51:55 <cizra> EvilTerran: That syntax is unfamiliar to me. What does <- do? Sorta like assignment?
03:51:58 <EvilTerran> yes
03:52:05 <cizra> Why not =?
03:52:18 <EvilTerran> an = exactly means equal in haskell
03:52:19 <conal> dcoutts: oh, i hadn't thought of that.  oops.  who adds extensions to cabal when they show up in ghc?
03:52:27 <EvilTerran> i usually pronounce <- as "bind"
03:52:32 <cizra> Oookay
03:52:36 <EvilTerran> as in "x <- m" is "bind x to the result of running m"
03:52:47 <cizra> EvilTerran: Where does the x come in return (x, x)?
03:52:49 <Zao> EvilTerran: >>= is "bind" as well, isn't it?
03:52:51 <cizra> ah!
03:52:51 <EvilTerran> it's not actually setting x equal to m
03:52:59 <EvilTerran> Zao, yes, i'm punning slightly on the desugaring
03:52:59 <cizra> x gets its value from listToMaybe
03:53:07 <cizra> and then is "return"ed.
03:53:23 <dcoutts> conal: either me or one of the ghc hackers.
03:53:25 <EvilTerran> cizra, exactly! but, if there's no such value, it short-circuits somewhere around the <- and the whole thing is Nothing
03:53:35 <cizra> > let x = listToMaybe[1, 2, 3] in return x
03:53:36 <lambdac>   add an instance declaration for (Show (m (Maybe t)))
03:54:00 <conal> dcoutts: i'll ask on #ghc
03:54:05 <EvilTerran> in "x = listToMaybe [...]", the type of x is (Maybe a) for some a
03:54:08 <Axman6> > let x = listToMaybe[1, 2, 3] in x
03:54:09 <lambdac>  Just 1
03:54:11 <cizra> Hmm, OK. What makes it short-circuit? listToMaybe definition?
03:54:27 <EvilTerran> in x <- lisToMaybe ..., the type of x is just 'a'
03:54:44 <EvilTerran> cizra, no, the definition of >>= for Maybe, which is what do-blocks desugar to
03:54:49 <BONUS> Nothing >>= f = Nothing
03:54:53 <cizra> Ah, so "do".
03:54:58 <EvilTerran> ?undo do x <- listToMaybe [1,2,3]; return (x,x)
03:54:58 <lambdac> listToMaybe [1, 2, 3] >>= \ x -> return (x, x)
03:55:06 <cizra> > let x = listToMaybe [] in x
03:55:07 <lambdac>  Nothing
03:55:18 <cizra> Why here? No do-block?
03:55:19 <EvilTerran> ?src  Maybe (>>=)
03:55:19 <lambdac> (Just x) >>= k      = k x
03:55:19 <lambdac> Nothing  >>= _      = Nothing
03:55:25 <quicksilver> this whole business about monads being something related to strictness is a very painful red herring
03:55:29 <EvilTerran> cizra, because you're not using <-, you're using =
03:55:29 <quicksilver> really confuses people.
03:55:40 <quicksilver> it's best to consider monads and laziness entirely separate topics.
03:55:40 <EvilTerran> and you can only use <- in do-blocks
03:56:15 <cizra> EvilTerran: Why does let x = listToMaybe [] in x short-circuit if there's no do-block nor >>=?
03:56:16 <Axman6> does that definition of >>= mean that k has to be a -> Maybe b?
03:56:46 <RayNbow> Axman6: yes
03:56:47 <mnislaih> unescaping an HTML string, which library ? I wish hoogle 4 was indexing hackage already
03:56:52 <Axman6> ok
03:56:56 <RayNbow> :t (>>=)
03:56:58 <lambdac> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:57:42 <Axman6> hmm, i was thinking that k would be a -> b
03:57:50 <EvilRanter> grr
03:58:01 <EvilRanter> cizra, there's nothing _to_ short-circuit in "let x = listToMaybe [] in x"
03:58:08 <EvilRanter> it's exactly equivalent to just "listToMaybe []"
03:58:15 <EvilRanter> which is Nothing, according to ?src listToMaybe
03:58:30 <BeelsebobWork> I have this function, satisfiesM (http://hpaste.org/9554) which I use in a variety of places, but I can't think of a sensible consistant place to put it in module structure... Can anyone think where it should go?
03:58:32 <cizra> Mm.. OK
03:58:45 <RayNbow> Axman6: you could apply a function of a -> b on a Maybe
03:58:51 <RayNbow> :t fmap
03:58:53 <lambdac> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:58:53 <BeelsebobWork> really, it should be in Control.Monad, but I can't extend that
03:59:07 <vixey> > not . (Just True)
03:59:08 <lambdac>  Just False
03:59:28 <EvilTerran> cizra, i think it might be better to compare "do x <- listToMaybe []; return (x,x)" to "let Just x = listToMaybe [] in (x,x)"
03:59:34 <RayNbow> vixey: that only works if you use (.) = fmap :p
03:59:38 <cizra> > let Just x = listToMaybe [] in (x,x)
03:59:39 <lambdac>   Irrefutable pattern failed for pattern Data.Maybe.Just x
03:59:40 <EvilTerran> cizra, because then x has the right type (with no Maybe)
03:59:52 <vixey> I am ok with that
03:59:59 <EvilTerran> yes, that's a pattern-match failure
03:59:59 <cizra> Now, what did lambdac say?
04:00:13 <Axman6> > do x <- listtoMaybe []; return (x,x)
04:00:14 <lambdac>   Not in scope: `listtoMaybe'
04:00:17 <EvilTerran> cizra, you effectively said "let Just x = Nothing in (x,x)"
04:00:20 <Axman6> > do x <- listToMaybe []; return (x,x)
04:00:22 <lambdac>  Nothing
04:00:25 <EvilTerran> and Just x /= Nothing
04:00:26 <cizra> yes
04:00:35 <EvilTerran> so it errored out
04:00:46 <cizra> Hmm, OK.
04:00:52 <Axman6> why doesn;t it return (Nothing, Nothing)?
04:01:10 <EvilTerran> Axman6, that'd be "let x = listToMaybe [] in (x,x)"
04:01:11 <quicksilver> BeelsebobWork: hpaste.org gives me a freakish opendns error?!
04:01:37 <BeelsebobWork> quicksilver: o.O
04:01:39 <EvilTerran> Axman6, but i pattern-matched out the Just, so x doesn't even have the right type for it to return (Nothing,Nothing)
04:01:42 <BeelsebobWork> have the internets exploded again?
04:01:49 <BeelsebobWork> quicksilver: satisfiesM p x = x >>= if' p return (const (satisfiesM p x))
04:02:02 <EvilTerran> cizra, anyway, there's your example of it failing to short-circuit
04:02:10 <cizra> *nod*
04:02:21 <cizra> I think I more-or-less understand.
04:02:23 <EvilTerran> cizra, when the pattern fails, it soldiers on regardless until you try to look at x, then explodes
04:02:35 <Axman6> cizra: don't be so sure.
04:02:43 <Axman6> monads suck -_-
04:02:54 <cizra> Axman6: That's what the "think" and "more-or-less" were for (=
04:02:55 <BeelsebobWork> Axman6: yes, yes they do
04:02:58 <mnislaih> I need to unescape some HTML strings. Any suggestions ?
04:03:13 <BeelsebobWork> use applicative functors
04:03:38 <Axman6> > [1,2,3] >>= show
04:03:39 <lambdac>  "123"
04:03:43 <RayNbow> > "monads" >> "suck"
04:03:44 <lambdac>  "sucksucksucksucksucksuck"
04:03:48 <RayNbow> like that, Axman6?
04:03:49 <vixey> lol
04:03:57 <Axman6> ha, yes
04:04:01 <vixey> > "foo" >>> "bar"
04:04:02 <lambdac>  Couldn't match expected type `a b' against inferred type `[]'
04:04:08 <Axman6> @src (>>)
04:04:08 <lambdac> m >> k      = m >>= \_ -> k
04:04:18 <Axman6> eh?
04:04:24 <Axman6> @src [] (>>)
04:04:24 <lambdac> xs >> ys      = concatMap (const xs) ys
04:04:45 <Axman6> @src String (>>)
04:04:46 <lambdac> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:04:55 <EvilTerran> cizra, so, anyway, the various monads encapsulate different kinds of "side-effects" - Maybe does short-circuiting on failure, [] (list) does non-deterministic computation, (Either e) does exceptions of type e, etcetc
04:04:57 <Axman6> not really, no
04:04:59 <EvilTerran> and IO does "real world" side-effects
04:05:44 <EvilTerran> this is nice because it means you can pick and choose which of these things you want in any one place in your code
04:05:46 <cizra> EvilTerran: Sounds complicated.
04:05:49 <EvilTerran> usually you don't want any of them
04:05:54 <cizra> Yes!
04:06:13 <EvilTerran> but you can have one of them, or several of them with a little fiddling
04:06:30 <EvilTerran> while, in your standard imperative language, there's a fixed set that you have everywhere whether you want it or not
04:06:58 <EvilTerran> (real-world side-effects, sometimes exceptions, sometimes continuations)
04:06:59 <vixey> only if you look at said language through haskell goggles
04:07:00 <cizra> yep
04:07:59 * quicksilver thinks that is an accurate picture with no goggle on at all.
04:08:06 <Axman6> so, would it be possible to write hardware drivers in haskell?
04:08:08 <EvilTerran> vixey, given how heavily i've been (ab)using the term "side-effect", i was thinking i was more looking at haskell through imperative goggles
04:08:22 <quicksilver> @faq Can you write hardware drivers in haskell?
04:08:22 <lambdac> The answer is: Yes! Haskell can do that.
04:08:23 <EvilTerran> hopefully i've found a good middle-ground
04:08:36 <quicksilver> You would need a realtime GC, though.
04:08:41 <vixey> I think IO emits instructions for side effects
04:08:46 <Axman6> quicksilver: i wish i'd bet that someone would do that. i knew someone would
04:08:49 <vixey> which the RTS executies
04:08:57 <quicksilver> or 'good enough' realtime for your hardware.
04:09:00 <RayNbow> http://www.haskell.org/haskellwiki/Monad#Interesting_monads
04:09:01 <lambdac> Title: Monad - HaskellWiki
04:09:07 <RayNbow> "House's H monad for safe hardware access"
04:09:41 <quicksilver> vixey: that is certainly an attractive way to model it.
04:09:51 <quicksilver> vixey: it's not what GHC actually does, of course.
04:27:11 <Axman6> "Flash C Compiler: Compiling C code to the Adobe Flash Virtual Machine" using LLVM. how interesting
04:27:24 * Axman6 wonders if LLVM could help GHC at all
04:29:08 <thoughtpolice> those presentations were pretty interesting
04:29:23 <quicksilver> Axman6: when taht has been discussed previously the answer was No.
04:29:23 <thoughtpolice> personally I don't see anything in the immediate future of something like "ghc on llvm"
04:29:40 <thoughtpolice> non-strict semantics would basically make us a total second class citizen
04:29:50 <Axman6> fair enough
04:29:52 <quicksilver> Axman6: llvm is very closely tied to compilation of strict C-like languages.
04:30:07 <quicksilver> I mean, it wouldn't be useless or impossible : you could definitely do it.
04:30:13 <quicksilver> but it wouldn't be a ticket to better performance.
04:30:30 <Axman6> why not?
04:30:38 <quicksilver> because their model is a poor fit
04:30:48 <quicksilver> and their optimisations would not apply very well.
04:30:56 <thoughtpolice> you'd basically have to retrofit a lot of haskell's evaluation model - a non-strict functional language - to a place where it wasn't designed
04:31:05 <quicksilver> it might be a ticket to getting binary support on a wider range of hardware platforms, though.
04:31:33 <Axman6> would it maybe help with the GHC -> C compilation route?
04:31:46 <Axman6> which i know isn't preferred
04:32:13 <thoughtpolice> it seems definitely feasible to get e.g. clang/llvm-gcc to compile the C code generated by GHC, sure
04:32:22 <thoughtpolice> dunno how much of an improvement it would get but it might be worth looking into
04:32:27 <quicksilver> except GHC doesn't actually generate C :)
04:32:43 <thoughtpolice> more like nastiness, yeah
04:32:46 <quicksilver> well, not executable C
04:32:48 <Axman6> -fvia-C?
04:33:01 <quicksilver> it generates C which is designed to be compiled and then post-processed by the Evil Mangler
04:33:18 <thoughtpolice> i tought the EM was just for the generated ASM?
04:33:32 <quicksilver> hmm. Maybe I got that confused.
04:33:50 <quicksilver> no, I was right.
04:34:04 <quicksilver> "The Evil Mangler (EM) is a Perl script invoked by GHC after the C compiler (gcc) has translated the GHC-produced C code into assembly. Consequently, it is only of interest if -fvia-C is in effect "
04:34:16 <quicksilver> It is the evilest - and most ironic - part of GHC.
04:34:32 <Axman6> what does it do?
04:34:39 <quicksilver> Fancy having a haskell compiler, written for the most part in haskell, which is considered to be an excellent language for writing compilers
04:34:50 <quicksilver> and then have a critical component written in, of all things, perl.
04:35:22 <thoughtpolice> it preprocesses the .S files GCC generates though, not the actual C I thought?
04:35:27 <thoughtpolice> anyway the mangler is on death row
04:35:53 <thoughtpolice> (i'm looking at the EvilMangler commentary page)
04:36:07 <thoughtpolice> Axman6: http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
04:36:08 <quicksilver> thoughtpolice: it post-processes them, from the perspective I was looking at it.
04:36:09 <lambdac> Title: Commentary/EvilMangler - GHC - Trac
04:36:21 <quicksilver> thoughtpolice: but that's what I meant but GHC not generateing executable C.
04:36:28 <thoughtpolice> ah sure
04:36:36 <quicksilver> The C backend is sort of deprecated
04:36:51 <idnar> doesn't it still result in faster code?
04:36:55 <thoughtpolice> tbh if you wanted to experiment with C generated from haskell and try compiling it with e.g. llvm or clang or something
04:36:59 <thoughtpolice> you might as well go with JHC
04:37:20 <thoughtpolice> idnar: the native backend became the default in 6.8 because it improved a bit
04:37:32 <thoughtpolice> there are a few cases where the C can beat the native code gen though
04:37:47 <idnar> thoughtpolice: hmm, ok
04:37:48 <thoughtpolice> notably I think dons came upon that when messing with code generated by uvector
04:38:14 <quicksilver> the C backend produces better floating point code
04:38:25 <quicksilver> gcc has a pretty good floating point optimiser
04:38:31 <quicksilver> and it's not really been a focus for the ghc guys.
04:38:44 <thoughtpolice> SSE2/SSE3 support would be nice
04:38:51 <quicksilver> but it's only a win if you know which strings to pull to get your FP code into registers at all.
04:39:02 <thoughtpolice> i was initially attracted to the commentary and working on GHC because I thought it would be interesting to try and hack something like that up
04:39:07 <quicksilver> thoughtpolice: it's pretty hard to get useful SSE code from 'normal programs'
04:39:10 <quicksilver> I mean
04:39:18 <quicksilver> the programmer has to deliberately code for SSE in most cases
04:39:39 <quicksilver> there aren't many bits of naive code which you can automatically spot an SSE optimisation on.
04:39:45 <thoughtpolice> yeah, generally speaking most compilers don't do a great job of it 'automagically'
04:39:59 <quicksilver> so, it would be fun to have but you'd have to propagate it back to the front-end some how
04:40:11 <quicksilver> have some explicit frontend mechanism for 'SSE-friendly' code
04:40:17 <thoughtpolice> which is why GCC primarily has those fancy vector extensions or whatever
04:40:22 <quicksilver> exactly.
04:40:46 <thoughtpolice> major drag; sse can be a huge win sometimes. but yeah generally it's always hand-written
04:41:48 <quicksilver> and then you have to write it again for altivec
04:41:59 <Axman6> what sorts of things would SSE speed up in haskell?
04:42:05 <thoughtpolice> lots of people say altivec instructions are really pretty awesome
04:42:09 <thoughtpolice> i've never worked on PPC tho
04:42:17 <thoughtpolice> Axman6: floating point calculations
04:42:21 <quicksilver> certain kinds of simultaneous FP operations
04:42:30 <thoughtpolice> you can truly get some *massive* improvements sometimes
04:42:33 <quicksilver> like multiplying a 3-vector by a scalar
04:42:37 <quicksilver> in one instruction instead of 3
04:42:39 <quicksilver> that sort of thing
04:42:55 <Axman6> quicksilver: not really, since nothing except some on the IBM servers are really using AltiVec, and i doube many of those would be using haskell
04:43:13 <Axman6> i also do love our G5, but not really worth the effort
04:43:16 <quicksilver> Axman6: I have a G4. I'm no tthe only one ;)
04:43:24 <quicksilver> there are plenty of people with G4s and 5s
04:43:27 <thoughtpolice> back when I did win32 programming and was on efnet there was a guy who was real good at SSE, he said on some of his graphical stuff for rendering floating point data he managed to get increases on the order of like 200%
04:43:31 <quicksilver> but you're right, it's not much worth the effort
04:43:53 <quicksilver> an improvement of 200% is only 200% if that was your CPU bottleneck, though
04:43:58 <quicksilver> (to state the obvious)
04:44:05 <Axman6> there's nothing wrong with PPC's, just that they're not all that common
04:44:24 <quicksilver> a Cell code generator would be fun.
04:44:28 <quicksilver> Some work has been done on that.
04:44:34 <Axman6> yeah, that would be awesome
04:44:44 <Axman6> PS3-GHC
04:44:52 <thoughtpolice> yeah, sse wouldn't help if you're not taking cache and whatnot into consideration
04:44:59 <Axman6> i just want a PS3 for the Cell, i don't care about gaming
04:45:49 <thoughtpolice> cell codegen would be really awesome since it's such an exotic system, but apparently it is pretty damn hard to program for, so I speculate that would apply equally well to code generation
04:45:50 <quicksilver> thoughtpolice: an awful lot of code is memory limited these days
04:46:10 <quicksilver> to be more precise "An awful lot of apparently CPU-limited code is actually memory limited, these days"
04:46:13 <quicksilver> is what I mean.
04:46:30 <quicksilver> haskell makes this trend even more pronounced, sadly.
04:46:31 <Axman6> i think that Sony somehow managed to hack OS X to run on the PS3 though
04:46:31 <thoughtpolice> cache footprint is critical, if you're getting evicted all the time it's not helpful
04:47:07 <thoughtpolice> quicksilver: but yeah I see where you're going.
04:47:56 <quicksilver> I find it a bit surprising myself
04:48:05 <quicksilver> why do we keep building systems with memory bottlenecks?
04:48:13 <quicksilver> it's "obvious" how you break a memory bottleneck
04:48:41 <quicksilver> just increase the parallelism in how you lay out the memory
04:48:48 <quicksilver> (a.k.a make the bus wider)
04:48:57 <quicksilver> but, I'm not a hardware guy.
04:49:30 <thoughtpolice> quicksilver: hehe, i'm reading drepper's paper on memory architecture for computer programmers, it's very enlighening to the reality :)
04:57:42 <esteth> If I want to compute the mean of a list of Nums, how would be the right way to go about this in haskell? I'm sure I should use fold, but calculating the average incrementally seems like it might be quite difficult
04:59:01 <int-e> esteth: you can use a fold to calculate the sum of the elements and the length of the list in one pass over the list
04:59:18 <int-e> (just use a pair to store the values)
04:59:31 <vixey> sum list / length list = foldr (+) 0 list / foldr (const (+1)) 0 list = uncurry (/) . foldr (\(l,r)(ls,rs) -> (l+ls,const (+1) r rs)) (0,0) list
04:59:40 <vixey> :t \list -> uncurry (/) . foldr (\(l,r)(ls,rs) -> (l+ls,const (+1) r rs)) (0,0) list
04:59:42 <lambdac> forall a t t1. (Num (a, a), Num t, Fractional a) => [(t, t1)] -> (t, a)
04:59:49 <vixey> oh well something like that anyway
05:00:01 <vixey> :t \list -> uncurry (/) . foldr (\(l,r)(ls,rs) -> (l+ls,const (+1) r rs)) (0,0) (zip list list)
05:00:03 <lambdac> forall a t. (Num (a, a), Num t, Fractional a) => [t] -> (t, a)
05:00:36 <int-e> vixey: what's the ,r element for?
05:00:55 <vixey> making each rewrite small as possible
05:01:14 <vixey> > (\list -> uncurry (/) $ foldr (\(l,r)(ls,rs) -> (l+ls,const (+1) r rs)) (0,0) (zip list list)) [1,2,3]
05:01:15 <lambdac>  2.0
05:01:18 <esteth> That's an awful lot of stuff that looks pretty scary :S I assume I don't want to do sum list / length list because it means stepping through again to get the length of the list?
05:01:27 <int-e> :t uncurry (/) . foldr (\l (ls, rs) -> (l+ls, 1+r)) (0,0)
05:01:28 <lambdac> [Expr] -> Expr
05:01:32 <vixey> esteth: sum list / length list is fine, that's what I would do
05:01:38 <BONUS> let mean xs = let (s,n) = foldl (\(sc, nc) x -> (sc + x, nc + 1)) (0,0) xs in s / n
05:01:49 <vixey> esteth: but you can unfold some derivations and fuse them together to get a version that does a single traversal
05:01:55 <vixey> definitions*
05:01:56 <int-e> :t uncurry (/) . foldr (\l (ls, rs) -> (l+ls, 1+rs)) (0,0)
05:01:58 <lambdac> forall a. (Fractional a) => [a] -> a
05:02:24 <esteth> vixey, Okies. Thanks :)
05:02:53 <vixey> I think you can use attribute grammars for this sort of thing as well
05:03:04 <vixey> i.e. instead of doing the derivation you get a program to do it :)
05:23:19 <esteth> ghc is complaining that I have no instance for (Fractional Int) when I try to (/) them. I feel like I'm doing something really silly. paste coming up in a minuite, if i can figure out how to get gvim to paste into other programs.
05:23:32 <vixey> yeah haskell is a bit silly
05:23:36 <vixey> you can do one of two things
05:23:42 <vixey> use genericLength instead of length
05:23:43 <vixey> or
05:23:50 <vixey> import Prelude hiding (length)
05:23:59 <vixey> length = foldr (const (1+)) 0
05:24:59 <esteth> aha. genericLength is what I expected length to do. I'll have to pay more attention to type signitures next time. Thanks :)
05:25:41 <Axman6> :t genericLength
05:25:43 <lambdac> forall b i. (Num i) => [b] -> i
05:25:51 <Botje> @src genericLength
05:25:51 <lambdac> genericLength []    = 0
05:25:51 <lambdac> genericLength (_:l) = 1 + genericLength l
05:25:52 <vixey> :t foldr (const (1+)) 0
05:25:53 <lambdac> forall t a. (Num t) => [a] -> t
05:26:02 <kpreid> esteth: when you want to divide integers, think `div`
05:26:16 <Botje> hmm
05:26:22 <kpreid> ? 127 `div` 10
05:26:24 <Botje> would genericLength l :: Double use Doubles internally?
05:26:25 <Axman6> or a / fromIntegral b
05:26:27 <kpreid> > 127 `div` 10
05:26:28 <lambdac>  12
05:26:32 <Botje> if so, that looks horribly slow compared to fromIntegral . length
05:26:50 <kpreid> Botje: yes, it would
05:26:56 <Botje> brrr
05:27:06 <kpreid> I doubt it'd be horribly slow
05:28:10 <Axman6> @src reverse
05:28:10 <lambdac> reverse = foldl (flip (:)) []
05:28:14 <Botje> uhh
05:28:28 <Botje> genericLength stack overflows on [1..1000000]
05:28:34 <Botje> whereas length doesn't have a problem
05:28:35 <Axman6> i don't get that source >_<
05:28:54 <rwbarton> using foldr rather than foldl is more likely to be problematic
05:30:14 <Botje> @pl \a b -> a + 1
05:30:14 <lambdac> const . (1 +)
05:30:34 <brianbec> i see both List and Data.List contain a "sortBy" ... any guidance on List versus Data.List?
05:31:50 <Botje> use Data.List
05:31:54 <Botje> List is a holdover from the old days
05:32:09 <rwbarton> List is the standard Haskell 98 module, Data.List is the new hierarchical module equivalent.  Data.List might have extra goodies
05:32:17 <kpreid> but List is standard!!!111!!!
05:32:59 <brianbec> Thanks :)  Data.List it is.
05:35:08 <mnislaih> I need to unescape some HTML strings. Any suggestions ? (sorry for spamming. I went for lunch and still didn't figure it out. )
05:39:38 <gwern> http://shootout.alioth.debian.org/u64q/ <-- no haskell!
05:39:39 <lambdac> Title: x64 Ubuntu : Intel&#174; Q6600&#174; Computer Language Benchmarks Game
05:46:32 <vixey> what the hell :S
05:47:01 <saml> haskell can has variable name containing spaces. wanna see?
05:47:27 <saml> > let 1 ^^ 1 = 1 in 1 ^^ 1
05:47:28 <lambdac>  1
05:47:31 <vixey> don't give away the secret!
05:48:37 <vixey> > let variable "foo" = 3 ; variable "bar" = 7 ; variable "foo bar" = [3,7] in variable "foo" + variable "bar" : variable "foo bar"
05:48:38 <lambdac>   add an instance declaration for (Num [t], Num [[t]])
05:48:42 <vixey> :S ?
05:48:51 <vixey> > let variable "foo" = 3 ; variable "bar" = 7 ; variable "foo bar" = [3,7] in (variable "foo" + variable "bar") : variable "foo bar"
05:48:51 <lambdac>   add an instance declaration for (Num [t], Num [[t]])
05:49:15 <vixey> oh yeah.. type systems
05:51:54 <dcoutts_> @seen saizan
05:51:55 <lambdac> Last time I saw saizan was when I left dalnet:#java, dalnet:#javahelp, dalnet:#programmers, #functionaljava, #haskell, #reductio and #slinky 27d 14h 28m 57s ago, and .
05:57:07 <mnislaih> fancy date parsing like darcs does: is there any library in hackage capable of that ?
06:00:37 <sw17ch> i didn't even know variable was a keyword
06:01:35 <quicksilver> sw17ch: it isn't.
06:01:47 <quicksilver> mnislaih: 'fancy' ?
06:04:12 <mnislaih> quicksilver: which can parse things like 'yesterday', 'tomorrow', etc
06:04:23 <quicksilver> ah. No, I don't think so.
06:04:47 <mnislaih> someone should split that out of darcs and put it in Hackage..
06:05:27 <quicksilver> agreed.
06:05:31 <mnislaih> quoting from darcs docs: "darcs annotate --summary --match 'date "tea time yesterday"'"
06:05:43 <mnislaih> now that's fancy :)
06:05:55 <sw17ch> quicksilver, oh, look at that :)
06:15:45 <chrisdone>  tea time, haha
06:20:11 <thoughtpolice> does anybody know if HsOpenSSL can be used to create secure connections?
06:21:11 <thoughtpolice> hm seems to be
06:26:22 <sw17ch> i've just recently run into something i haven't had to do before
06:26:41 <sw17ch> is there a way to pass a type as an argument, or in some way constrain the type based on the receiver?
06:27:09 <sw17ch> the issue is that i need to tell a function what type it's dealing with, and then tell a C function, whcih takes a void* array of somethings what it's recieving
06:27:41 <sw17ch> i'd like to be able to just pass a single parameter which constrains the "allocaArray" i'm using to the correct type and also has a way of sending the correct integral representation to the C function
06:28:12 <quicksilver> well that's what Typeable is for.
06:28:18 <quicksilver> but it sounds like a terrible design.
06:28:27 <quicksilver> can you step back a bit and explain what you're trying to do?
06:29:35 <sw17ch> quicksilver, it's for my PortAudio bindings. To use the library, one needs to do an openStream, which takes, as one of its parameters, the type of the sample (the type is an Enum). The type is Int8/16/32 or UInt8
06:30:27 <sw17ch> I'm making a withStream function which will open a stream, start it, perform the actions passed to it, stop and close the stream then returning the result of the action
06:30:42 <sw17ch> the problem is that the caller is responsible for allocating memory for a streamRead/Write
06:30:52 <sw17ch> which is what i'm using allocaArray for
06:32:05 <sw17ch> the problem i'm having is that i need to: allocaArray n f :: [[PaInt8]]
06:32:07 <sw17ch> or something similar
06:32:27 <quicksilver> don't you just case on the type representative?
06:32:45 <quicksilver> case tr of Int8 -> {- alloca Int8 array -}
06:32:54 <quicksilver> Int16 -> {- alloca Int16 array -}
06:32:56 <quicksilver> etc...
06:33:06 <sw17ch> i was hoping i'd not have to do it that way
06:33:22 <sw17ch> ...especially since those result in different Ptr types
06:33:36 <sw17ch> which is where the type variable idea came in
06:33:37 <quicksilver> well, don't you want them to be different types?
06:33:50 <quicksilver> if you dont want them to be different types, then don't bother
06:33:52 <sw17ch> yes, but i want the function to be polymorphic across the Storable class and another one
06:34:13 <quicksilver> I don't think it can be polymorphic across Storable
06:34:19 <quicksilver> because it doesn't work for all storable
06:34:32 <quicksilver> it just works for four specific types
06:35:46 <sw17ch> quicksilver, yes, i suppose i should have said that i have another class which only includes the types allowed
06:35:58 <sw17ch> i just do'nt want to write a handler for each format used
06:36:05 <quicksilver> then, yes you can probably do it using that class.
06:36:27 <quicksilver> which bit are you having a problem with? :)
06:36:32 <sw17ch> the only thing i could think of was a funny combination of phantom types and (undefined :: Something)
06:36:40 <sw17ch> and a cons
06:36:52 <sw17ch> where the cons would end up constraining the type
06:37:24 <sw17ch> f (PAType (undefined :: PaInt16))
06:37:28 <sw17ch> is the call
06:37:49 <sw17ch> f (PAType v) = v : (call which creates list of samples)
06:38:10 <sw17ch> something similar
06:38:37 <quicksilver> you certainly don't need phantom types for this.
06:38:53 <quicksilver> you might need an undefined although I don't think so.
06:39:00 <quicksilver> can you paste your attempt?
06:39:13 <quicksilver> glguy_: ping
06:40:02 <sw17ch> quicksilver, can you get to hpaste?
06:40:36 <quicksilver> no.
06:40:57 <sw17ch> hurrah
06:41:00 <quicksilver> pastebin.com has some haskell support though
06:41:13 <quicksilver> although it's a bit weird :)
06:41:18 <quicksilver> in what it chooses to highlight
06:42:58 <sw17ch> hehe
06:43:02 <sw17ch> alright, just a second
06:43:41 <chrisdone> http://paste.lisp.org/ has good haskell pasting
06:45:39 <sw17ch> quicksilver: http://pastebin.com/m518adaa2
06:45:50 <sw17ch> this is the current implementation
06:46:31 <sw17ch> lines 50, and lines 58 are the two places i'm referencing the "same thing" (one is an Enum, the other is a type synonym for Int16)
06:48:41 <quicksilver> sw17ch: yes, you shouldn't need to pass PaInt16 directly as a parameter to withDefaultStream
06:48:54 <sw17ch> quicksilver, that's what i'm trying to avoid
06:48:59 <quicksilver> sw17ch: it should be able to infer that from the types of its parameters.
06:49:04 <quicksilver> (effectively)
06:50:06 <sw17ch> i suppose the problem is, then, how i can pass the correct enum value to openDefaultStream (line 9)
06:50:08 <quicksilver> sw17ch: in the type of 'withDefaultStream'
06:50:20 <quicksilver> sw17ch: the variable 'a'
06:50:28 <quicksilver> that is your "PaXYZ" type, correct?
06:50:47 <quicksilver> or not? is that just a generic type
06:51:08 <sw17ch> quicksilver, that's jsut a generic type. it is the type of whatever the provided action produces
06:51:18 * quicksilver nods
06:51:19 <sw17ch> in most cases, ()
06:51:24 <quicksilver> yes, I see now.
06:53:17 <quicksilver> sw17ch: it seems surprising to me that the type 'PaStream' doesn't encode the type of its contents
06:53:24 <quicksilver> sw17ch: that is the way I would arrange it, I think.
06:53:48 <sw17ch> quicksilver, i had considered that. PaStream, right now, is bad... :( it's a synonym for IntPtr
06:53:48 <quicksilver> surely it would be a type error to write the wrong thing to a particular PaStream
06:54:03 <quicksilver> OK, I think that's how I'd do it.
06:54:08 <sw17ch> yes, it would be...
06:54:10 <sw17ch> ah, yes...
06:54:13 <quicksilver> give PaStream a type parameter.
06:54:24 <quicksilver> then you can use that to select the correct instances, basically.
06:54:34 <sw17ch> refresh my memory how one does that
06:55:11 <quicksilver> data PaStream a = PaStream (IntPtr)
06:55:31 <quicksilver> then the type of (for example) writeStream
06:55:32 <quicksilver> becomes
06:55:54 <quicksilver> writeStream :: (Storable a) => PaStream a -> [[a]] -> Int -> IO ErrorCode
06:56:09 <quicksilver> which correct indicates that you can only write a [[a]] to a corresponding PaStream.
06:56:15 <sw17ch> ahh... of course...
06:58:54 <sw17ch> how do i fix `a' at a type then? data PaStream ptr => PaStream ptr :: PaStream a
07:00:42 <quicksilver> you could use a type annotation, yes.
07:00:47 <quicksilver> You don't normally need to.
07:00:57 <quicksilver> The type of the whole function (e.g. writeStream, above) should pin it all down.
07:01:09 <sw17ch> oh, right
07:01:27 <sw17ch> in the case of openStream though... no, wait, i see it now
07:01:37 <sw17ch> well, thanks quicksilver... the help is much appreciatedf
07:01:40 <sw17ch> quicksilver++
07:03:19 <quicksilver> sw17ch: so the answer to your original question is : Yes, there are ways to pass types as parameters but it's a last resort.
07:03:32 <quicksilver> sw17ch: normally appropriate polymorphism gets a cleaner result 'implicitly'
07:03:37 <sw17ch> quicksilver, i didn't think my case was all that unusual
07:03:49 <sw17ch> i just haven't had to deal with this situation yet :)
07:03:54 <quicksilver> right.
07:04:00 <quicksilver> not unusual but hard to explain in the abstract.
07:04:03 <sw17ch> i'd used the pieces before, but haven't had to implement myself
07:04:04 <quicksilver> that's why I needed your code :)
07:04:12 <sw17ch> thanks for looking at it
07:04:21 <sw17ch> this is actually a fun library to play with
07:04:42 <sw17ch> the example on the bottom will record a sample, then play it back
07:05:02 <sw17ch> very trivial example, but still quite interesting
07:05:10 <sw17ch> and/or fun
07:06:42 * quicksilver nods
07:07:32 <quicksilver> there is no substitute to trying stuff
07:09:30 <sw17ch> ?remember quicksilver there is no substitute to trying stuff
07:09:30 <lambdac> Done.
07:09:37 <b\6> http://hpaste.org/9556  please help convert old-style parsec to applicative style. thanks.
07:11:44 <Botje> since when is do deprecated? :)
07:11:55 <Philippa> I was about to say...
07:12:00 <quicksilver> it's just, so frank sinatra
07:12:05 <quicksilver> do be do be do
07:12:08 <Botje> the way it's written there is good and clean
07:12:12 <Botje> quicksilver: heh :)
07:12:12 <Philippa> if you stick to the applicative subset you might as well use another library
07:13:27 <EvilTerran> parseString = ((,) <$> (stringLength <* char ':') <*> count' l anyChar) <?> "string" --?
07:13:38 <EvilTerran> i prefer the do{} version
07:14:02 <Philippa> *nod*. There's a reason I asked for pointed Applicative sugar in my talk on friday
07:14:05 <sw17ch> is there a good description of what changed in parsec laying aroudn somewhere?
07:14:56 <Botje> Philippa: pointy sugar? soinds dangerous :)
07:15:18 <Botje> @seen ayu
07:15:18 <lambdac> I saw ayu leaving #haskell 1d 12m 52s ago, and .
07:16:12 <quicksilver> EvilTerran: no.
07:16:18 <quicksilver> EvilTerran: you lost your l
07:16:22 <quicksilver> b\6: you can't.
07:16:25 <quicksilver> tht's not applicative.
07:16:32 <quicksilver> it uses the result of one parse to influence the next
07:16:37 <quicksilver> (the 'l')
07:16:49 <Botje> that's the main limitation of app?
07:16:51 <Botje> ouch
07:16:59 <quicksilver> that's precisely the limitation of app, yes.
07:17:14 <subw> @help
07:17:15 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
07:17:17 <quicksilver> independent effects can't depend on each others' results.
07:17:20 <b\6> quicksilver: ok, thanks. being impossible is probably why i was finding it hard.
07:17:28 <Botje> giggle
07:17:46 <Botje> i think that's true for most of haskell
07:17:55 <quicksilver> you could use 'parseString' in part of a larger applicative framework, of course
07:18:06 <quicksilver> but it doesn't itself compose into small applicative pieces.
07:18:14 <b\6> ok. that's what i was wanting to know.
07:23:29 <EvilTerran> quicksilver, oh yeah, i missed that use of l
07:23:31 <EvilTerran> makes sense
07:23:55 <CosmicRay> hrm, where to report bugs in Text.Regex.Posix?
07:24:09 <CosmicRay> it breaks if a String has \NUL in it.
07:24:31 <quicksilver> are you sure that's not a feature?
07:24:40 <dmwit> It's just a binding to the C libraries, so that doesn't surprise me at all.
07:24:41 <paczesiowa> @hoogle t m a -> m a
07:24:41 <lambdac> A Hoogle error occured.
07:24:46 <quicksilver> I would have guessed posix strings are not allowed to contain nulls.
07:24:49 <CosmicRay> quicksilver: it is not documented.
07:24:54 <CosmicRay> quicksilver: but it takes a [Char]
07:24:57 <dmwit> paczesiowa: It depends on which transformer you're using.
07:25:01 <quicksilver> text.regex.posix is barely documented at best :)
07:25:12 <dmwit> paczesiowa: runStateT, etc.
07:25:17 <paczesiowa> dmwit: I know
07:25:22 <dmwit> ok
07:25:22 <quicksilver> as dmwit says, it's a binding to your systems C library
07:25:30 <paczesiowa> dmwit: there should be class for it
07:25:38 <quicksilver> there can't be, paczesiowa
07:25:42 <quicksilver> because it's different in each case
07:25:57 <dmwit> ?src MonadTrans
07:25:57 <lambdac> Source not found.
07:26:03 <quicksilver> presence/absence of parameters and indeed the return type vary.
07:26:12 <andyjgill> /reload style
07:26:13 <pastorn> http://shootout.alioth.debian.org/u64q/ <-- no haskell yet?
07:26:14 <lambdac> Title: x64 Ubuntu : Intel&#174; Q6600&#174; Computer Language Benchmarks Game
07:26:22 <CosmicRay> quicksilver: that's fine, but a) I have never used the C library (some C libraries take pointer and a length, rather than \0-terminated), and b) it isn't documented
07:26:27 <paczesiowa> :t runStateT
07:26:28 <lambdac> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
07:26:36 <trofimovich> @hoogle Trans
07:26:36 <lambdac> A Hoogle error occured.
07:26:43 <trofimovich> :\
07:27:10 <dmwit> class MonadTrans t where lift :: Monad m => m a -> t m a
07:27:16 <dmwit> You only get the other direction. =)
07:27:41 <quicksilver> CosmicRay: man regex ;)
07:27:45 <paczesiowa> but it would be nice to unlift things
07:27:53 <quicksilver> paczesiowa: it's not possible though.
07:28:05 <paczesiowa> e.g. use StateT Id in StateT m
07:28:29 <quicksilver> CosmicRay: but it's not explicit about nulls on linux at least.
07:28:31 <paczesiowa> wait
07:28:34 <dmwit> paczesiowa: There is no way to generalize it.  You can write specific ones like that, though, without too much trouble.
07:28:49 <paczesiowa> unlifting should be possible
07:28:54 <dmwit> (Especially since StateT m is an instance of MonadState.)
07:29:05 <quicksilver> t Id a -> t m a
07:29:12 <quicksilver> is rather different from what you first said.
07:29:16 <dmwit> right
07:29:17 <andyjgill> I've got a couple of lift like variants of MonadTrans
07:29:37 <quicksilver> but the answer is, don't write it in StateT Id
07:29:43 <quicksilver> write it polymorphically in StateT m
07:29:50 <quicksilver> ... or, better, use MonadState
07:29:53 <dmwit> Yeah, just write it in (MonadState m => m a).
07:29:55 <paczesiowa> quicksilver: but I was trying to imlement unlifting with that 1st thing
07:30:19 <quicksilver> paczesiowa: no matter how much you want there to be an opposite to lift, there isn't.
07:30:25 <andyjgill> class MonadTrans t => MonadTrans2 t where
07:30:25 <andyjgill>   cont :: (Monad m) => (forall b . (a -> m b) -> m b) -> (a -> t m b) -> t m b
07:30:25 <quicksilver> there are a family of oppositey-type things
07:30:25 <andyjgill>   scope :: (Monad m) => (forall a . m a -> m a) -> t m a -> t m a
07:30:32 <hackage> Uploaded to hackage: formlets 0.4.1
07:30:33 <quicksilver> but they all have different parameteres
07:31:37 <ndmitchell> @seen dcoutts
07:31:38 <lambdac> dcoutts is in #haskell-blah and #haskell. I last heard dcoutts speak 3h 38m 19s ago.
07:31:41 <ndmitchell> @seen dcoutts_
07:31:42 <lambdac> dcoutts_ is in #haskell. I last heard dcoutts_ speak 1h 39m 49s ago.
07:31:45 <dcoutts_> hia ndmitchell
07:32:31 <ndmitchell> dcoutts_ - how is the documentation http://hackage.haskell.org/packages/archive/base/latest/doc/html/ generated?
07:32:48 <paczesiowa> http://hpaste.org/9557
07:33:28 <dcoutts_> ndmitchell: by magic. Some build process goes away and builds new packages and their docs and stashes the result in the archive. I've still not found the code that does it. It's not in any public repo afaik.
07:33:49 <paczesiowa> reusing functions of type x -> Maybe y is great
07:34:06 <visof> % this operator doesn't work for haskell
07:34:07 <ndmitchell> dcoutts_: yay..... - i'm having great difficulty persuading haddock that map comes from Data.List and Prelude, rather than just GHC.Base
07:34:18 <ndmitchell> @seen waern
07:34:18 <lambdac> waern is in #haskell. I don't know when waern last spoke.
07:34:24 <ndmitchell> waern: ping?
07:34:28 <visof> > 4 % 3
07:34:29 <lambdac>  4%3
07:34:50 <EvilTerran> visof, you have to import Data.Ratio
07:34:56 <EvilTerran> i believe
07:34:59 <EvilTerran> ?index (%)
07:35:00 <lambdac> Data.Ratio
07:35:03 <rwbarton> > (4 % 3) * 3 -- % forms rational numbers
07:35:04 <lambdac>  4%1
07:35:12 <EvilTerran> ?type (%)
07:35:13 <lambdac> forall a. (Integral a) => a -> a -> Ratio a
07:36:28 <dcoutts_> ndmitchell: those docs seem to get it right, they're using haddock-0.8 of course
07:36:45 <ndmitchell> dcoutts_: ok, in that case not so interesting...
07:37:27 <EvilTerran> visof, or were you thinking of % like in C? that's spelt `mod`
07:37:36 <visof> yeah
07:37:42 <visof> that's what i need
07:37:44 <visof> thanks
07:37:57 <Axman6> or `rem`
07:38:06 <EvilTerran> or `rem`, depending on which rounding behaviour you want for negative numbers
07:38:20 <EvilTerran> there's `div` and `quot` respectively, too
07:38:20 <dmwit> > ((-6) `mod` 4, (-6) `rem` 4)
07:38:21 <lambdac>  (2,-2)
07:38:30 <EvilTerran>  > ((-5) `mod` 4, (-5) `rem` 4)
07:38:35 <EvilTerran> > ((-5) `mod` 4, (-5) `rem` 4) -- err
07:38:36 <lambdac>  (3,-1)
07:39:00 <dmwit> > ((-5) `div` 4, (-5) `quot` 4)
07:39:01 <lambdac>  (-2,-1)
07:40:49 <Axman6> how does (-5) `mod` 4 get 3?
07:41:02 <vixey> > (-5) `mod` 4
07:41:03 <lambdac>  3
07:41:10 <vixey> > ((-5) + 4) `mod` 4
07:41:12 <lambdac>  3
07:41:26 <vixey> > ((-5) + 4 + 4) `mod` 4
07:41:27 <lambdac>  3
07:41:29 <vixey> > (3) `mod` 4
07:41:30 <lambdac>  3
07:41:30 <vixey> > 3
07:41:31 <lambdac>  3
07:41:36 <Olathe> > map (\f -> f (-5) 4) [mod, rem, quot]
07:41:37 <lambdac>  [3,-1,-1]
07:41:43 <Axman6> ew :\
07:42:08 <trofimovich> > -5+4+4
07:42:09 <lambdac>  3
07:43:37 <EvilTerran> Axman6, (x `div` y) is the greatest integer such that x >= it * y
07:44:08 <EvilTerran> then (x `mod` y) = x - y*(x `div` y)
07:44:10 <Axman6> yeah that's fine
07:44:16 <Axman6> but mod is odd
07:44:29 <EvilTerran> > (-5) `div` 4
07:44:30 <lambdac>  -2
07:44:33 <vixey> mod is not odd
07:44:41 <EvilTerran> > (-5) - 4*((-5) `div` 4)
07:44:42 <lambdac>  3
07:44:45 <EvilTerran> like so :)
07:44:47 <trofimovich> @type span
07:44:49 <lambdac> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:44:56 * Axman6 is too tired to follow
07:45:00 <Olathe> > 5 `div` (-4)
07:45:01 <lambdac>  -2
07:45:01 <trofimovich> > span even [1..10]
07:45:03 <lambdac>  ([],[1,2,3,4,5,6,7,8,9,10])
07:45:08 <trofimovich> > span odd [1..10]
07:45:10 <lambdac>  ([1],[2,3,4,5,6,7,8,9,10])
07:45:22 <vixey> Axman6: I used two rules about mod
07:45:25 <Olathe> > 5 - (-4)*(5 `div` (-4))
07:45:25 <EvilTerran> > partition even [1..10]
07:45:26 <trofimovich> @type break
07:45:26 <lambdac>  -3
07:45:27 <lambdac>  ([2,4,6,8,10],[1,3,5,7,9])
07:45:28 <lambdac> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:45:30 <vixey> x `mod` y = (x + y) `mod` y
07:45:32 <dmwit> Axman6: div rounds towards -\infty, rem rounds towards 0.
07:45:34 <Axman6> > span (<5) [1..10]
07:45:34 <lambdac>  ([1,2,3,4],[5,6,7,8,9,10])
07:45:45 <vixey> x `mod` y = x    <=    0 <= x < y
07:45:46 <Olathe> > 5 `mod` (-4)
07:45:46 <trofimovich> @src break
07:45:46 <lambdac> break p =  span (not . p)
07:45:47 <lambdac>  -3
07:45:52 <rwbarton> mod is great.  x `mod` 4 is always 0, 1, 2, or 3.  x `rem` 4 can also be -1, -2, -3 -- how is that ever helpful?
07:46:15 <dmwit> rwbarton: It's only helpful in conjunction with quot.
07:46:29 <dmwit> > (-5) `quotRem` 4
07:46:30 <lambdac>  (-1,-1)
07:47:05 <dmwit> (q, r) = quotRem x y --> q * y + r = x
07:47:13 <trofimovich> > let align x a = x + rem x a in 123 1024
07:47:14 <lambdac>   add an instance declaration for (Num (t -> a))
07:47:19 <dmwit> There's a similar rule for divMod.
07:47:22 <trofimovich> > let align x a = x + rem x a in align 123 1024
07:47:23 <lambdac>  246
07:47:43 <trofimovich> > let align x a = x - rem x a in align 123 1024
07:47:44 <lambdac>  0
07:47:48 <trofimovich> > let align x a = x - rem x a in align 1230 1024
07:47:49 <lambdac>  1024
07:47:54 <trofimovich> > let align x a = x - rem x a in align -1230 1024
07:47:55 <lambdac>        add an instance declaration for
07:47:55 <lambdac>       (Num (a -> a -> a), Num (t -> a ...
07:47:58 <rwbarton> >  let align x a = x - rem x a in align (-123) 1024
07:47:59 <lambdac>  0
07:48:04 <rwbarton> Surely that's not what you want!
07:48:29 <trofimovich> why not?
07:48:45 <trofimovich> sometimes it is needed zero centric arith
07:48:51 <dmwit> trofimovich: Because everything in [-1023..1023] goes to 0.
07:49:09 <dmwit> rwbarton has a hard time believing that's the desired behavior, but I don't. =)
07:49:17 <rwbarton> I mean, maybe 1% of the time rem is useful.  Also, it's faster because that's what hardware implements
07:49:32 <EvilTerran> but why does hardware implement it instead of the other one? =/
07:49:43 <Axman6> rwbarton: it useful for prime testing then :)
07:50:23 <trofimovich> power-of-two mod is implemented via `and`? (even faster)
07:50:43 <EvilTerran> trofimovich, well, if the compiler implements it that way
07:51:29 <rwbarton> Axman6: Ideally the compiler would turn x `mod` y == 0 into x `rem` y == 0 :)
07:52:01 <Axman6> or, you could just save it the work and make sure :)
07:52:14 <Botje> rwbarton: uh ..
07:53:41 <EvilTerran> Axman6, i call premature optimisation
07:54:38 <Axman6> EvilTerran: for my purposes, the choice of one over the other had no effect, so i picked one
07:55:56 <EvilTerran> well, yes. but i mean it's really not worth worrying too much about
07:57:15 <Axman6> i wasn't
07:58:12 <Axman6> anyway, rem does what i would expect it to do, mod doesn't, so i'll stick with rem for now
07:58:34 <trofimovich> > let f n r = (quot n r == rem n r) in quickCheck f
07:58:35 <lambdac>  <IO ()>
07:58:49 <trofimovich> @type quickCheck
07:58:50 <lambdac> forall a. (Testable a) => a -> IO ()
08:01:06 <adekoba> hey. Was wondering if anyone could help me optimize a simple program. The bottleneck is parsec; I'm pretty new to parsec so I'm very open to suggestions. Here is a pastebin: http://hpaste.org/9559
08:02:57 <visof> i know how can implement Fibonacci but i want something like give the range and return serious of the fib numbers till range value
08:03:16 <visof> fib n | n < 2 = 1
08:03:30 <sioraiocht> I have a quickCheck property uses a String as the test cases, and 15%-20% of them are empty
08:03:32 <sioraiocht> why?
08:03:43 <visof>   | otherwise = fib (n-1) + fib (n-2)
08:03:46 <trofimovich> @google fib on haskell example
08:03:53 <lambdac> http://www.haskell.org/~pairwise/intro/section1.html
08:03:53 <lambdac> Title: Haskell for C Programmers
08:03:58 <paczesiowa> adekoba: do you have to use parsec?
08:04:21 <adekoba> paczesiowa: not necessarily, I just don't know of any other method.
08:05:33 <Axman6> | otherwise = r `par` l + r where l = fib (n-1); r = fib (n-2)
08:05:39 <dcoutts_> sioraiocht: empty lists are an important special case :-)
08:05:45 <paczesiowa> adekoba: it is so easy that you can do it with normal [byte]string operations
08:05:58 <sioraiocht> yes, but 20 different kinds of them? =p
08:06:15 <adekoba> paczesiowa: I could try that. I suppose you're right.
08:06:16 <visof> can anyone tell me the idea ?
08:06:20 <adekoba> paczesiowa: thanks
08:06:30 <Axman6> > tail [1,2,3]
08:06:31 <lambdac>  [2,3]
08:06:33 <Botje> adekoba: uh
08:06:40 <Botje> you could use ByteStrings instead of String
08:06:44 <Botje> that'll give a sizeable speedup
08:06:49 <vixey> Hasklol
08:07:07 <Olathe> visof: You can get the first two through some fast method and add for a bit.
08:07:08 <Axman6> > let fibs = 2 : (zipWith (+) fibs (tail fibs))
08:07:08 <lambdac>  Parse error at end of input
08:07:19 <Botje> adekoba: also, i think you're better off parsing the _WHOLE_ file with parsec
08:07:48 <Botje> as opposed to splitting it in lines and then feeding each line to parsec
08:07:54 <Axman6> > let fibs = 2 : (zipWith (+) fibs (tail fibs)))
08:07:54 <lambdac> Unbalanced parentheses
08:07:57 <Axman6> > let fibs = 2 : (zipWith (+) fibs (tail fibs))
08:07:57 <lambdac>  Parse error at end of input
08:08:04 <Axman6> > let fibs = 2 : (zipWith (+) fibs (tail fibs)) in fibs
08:08:18 <Botje> i wouldn't be surprised if parsec spends a lot of time backtracking on faulty lines
08:08:19 <lambdac>  thread killed
08:08:23 * Axman6 pokes lambdac 
08:08:32 <adekoba> Botje: I considered that, but I wanted it make it as modular as possible. As an example, if the order of the lines happened to change (I know, unlikely), then I would need to rewrite the program.
08:08:32 <Botje> uh
08:08:32 <chrisdone> i has a kell
08:08:46 <visof> > let fibs = 2 : (zipWith (+) fibs (tail fibs)) in fibs
08:08:56 <Axman6> > let fibs =1:1:2 : (zipWith (+) fibs (tail fibs)) in fibs
08:08:57 <lambdac>  [1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,465,616,816,1...
08:08:59 <adekoba> Botje: unless parsec is able to get around that in a way that I am not aware of
08:09:01 <lambdac>  thread killed
08:09:06 <Axman6> > let fibs =1:2 : (zipWith (+) fibs (tail fibs)) in fibs
08:09:08 <lambdac>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
08:09:12 <Olathe> > ffib 1000
08:09:13 <lambdac>   Not in scope: `ffib'
08:09:15 <Axman6> there we go
08:09:15 <Olathe> Bah.
08:09:21 <visof> > sum $ let fibs = 2 : (zipWith (+) fibs (tail fibs)) in fibs
08:09:24 <Olathe> > ffib 1000
08:09:26 <lambdac>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
08:09:33 <visof> wewe
08:09:36 <Botje> adekoba: i think the best thing is to step away from parsec, then
08:09:37 <lambdac>  thread killed
08:09:42 <Botje> adekoba: why not use regular expressions? :)
08:09:49 <trofimovich> visof: do not sum inlimited list :]
08:09:55 <Olathe> Heheh
08:10:18 <adekoba> Botje: god no. haha. Well, I'll try something else. Whether its using just standard bytestring functions, or... regex...
08:10:33 <adekoba> Botje: well thank you.
08:10:47 <Botje> /[^:]+:\s*(\d+)/
08:10:48 <Botje> there
08:10:52 <Botje> i've done the hard work for you :P
08:11:03 <Botje> /([^:]+):\s*(\d+)/
08:11:05 <Botje> there²
08:11:17 <trofimovich> are simple regexes faster, than parsec?
08:11:38 <adekoba> yeah, exactly. The whole reason for replacing parsec is because it's slow
08:11:41 <Philonous1> @hoogle (a -> a -> a) -> a -> [a] -> [a]
08:11:41 <lambdac> A Hoogle error occured.
08:11:49 <Botje> trofimovich: probably
08:11:52 <trofimovich> i thought reimplement awk script on haskell+parsec to achieve move lines per sec
08:12:18 <paczesiowa> let foo = break (==':') >>> (id *** read . dropWhile isSpace . tail) in foo "I have two cats: 2" :: (String, Int)
08:12:21 <paczesiowa> > let foo = break (==':') >>> (id *** read . dropWhile isSpace . tail) in foo "I have two cats: 2" :: (String, Int)
08:12:22 <lambdac>  ("I have two cats",2)
08:12:23 * trofimovich suspects it's heavily dependant on grammar type
08:12:34 <quicksilver> simple regexps are faster than parsec
08:12:42 <quicksilver> but if parsec is slower than your hard disk, you're doing something wrong.
08:12:50 <quicksilver> Any awk-like script shouuld be IO limited not CPU limited!
08:13:56 <paczesiowa> adekoba: try that with bytestrings
08:14:19 <trofimovich> awk sucks simple sort
08:14:59 <trofimovich> i'd like to sort values, but preserve keys
08:15:16 <paczesiowa> is there \bit plugin for turning things into do-notation?
08:15:23 <paczesiowa> \bot
08:16:19 <rwbarton> @redo getLine >>= putLine
08:16:19 <lambdac> do { a <- getLine; putLine a}
08:16:36 <paczesiowa> how about arrow notation?
08:16:43 <trofimovich> @help undo
08:16:44 <lambdac> undo <expr>
08:16:44 <lambdac> Translate do notation to Monad operators.
08:18:03 <CosmicRay> is there a typeclass anywhere that genericizes (&&) and (||) in the same way that we have genericized (<=) and (==)?
08:18:23 <CosmicRay> obviously it won't be called (&&) and (||), and I can invent one if needed, but just thought I'd ask first.
08:18:24 <Philonous> Why is the functional composition operator defined to the it's arguments in the wrong order -.-
08:18:40 <trofimovich> Eq?
08:18:53 <CosmicRay> Eq defines == and /= only
08:18:59 <visof> > let foo = [ x | x <- [1..], (length foo) == 10] in foo
08:19:05 <trofimovich> @hoogle &&
08:19:05 <lambdac> A Hoogle error occured.
08:19:15 <lambdac>  thread killed
08:19:23 <trofimovich> Prelude> :info (&&)
08:19:24 <trofimovich> (&&) :: Bool -> Bool -> Bool    -- Defined in GHC.Base
08:19:28 <trofimovich> doesn't seem to
08:19:30 <Olathe> > ((+5) . (*4)) 3
08:19:31 <lambdac>  17
08:19:35 <visof> i want to pick the first 10 element
08:19:42 <visof> by this way
08:19:45 <visof> can i ?
08:19:48 <trofimovich> @src take
08:19:49 <lambdac> take n _      | n <= 0 =  []
08:19:49 <lambdac> take _ []              =  []
08:19:49 <lambdac> take n (x:xs)          =  x : take (n-1) xs
08:19:49 <Olathe> Philonous: Well, you write f(g(x)), right ?
08:20:23 <Philonous> Yeah, but g gets invoked first
08:20:31 <Olathe> Philonous: Sure.
08:20:45 <Olathe> Philonous: Composition is written in the same left-to-right order as that.
08:20:54 <Philonous> Btw It was just a rhetorical question ;)
08:20:58 <Axman6> Philonous: that's the way it's done in mathematics
08:21:01 <Olathe> Oh :)
08:21:26 <Philonous> I'd like to write functional composition from left to right like with unix pipes. though
08:21:28 <trofimovich> @hoogle bitop
08:21:29 <lambdac> A Hoogle error occured.
08:21:39 <visof> > let foo bar = take bar [ x | x <- [1..]] in foo 10
08:21:40 <lambdac>  [1,2,3,4,5,6,7,8,9,10]
08:21:43 <rwbarton> CosmicRay: numeric-prelude has an Algebra.Lattice module
08:21:50 <visof> thanks trofimovi
08:22:10 <trofimovich> visof: inverse function is drop
08:22:13 <paczesiowa> > (+1) >>> (*2)  $ 3
08:22:14 <lambdac>  8
08:22:15 <Olathe> > (**)
08:22:16 <lambdac>  <Double -> Double -> Double>
08:22:22 <Olathe> > (..)
08:22:22 <lambdac>  Parse error at "..)" (column 2)
08:22:47 <trofimovich> visof: you could have a look at takeWhile, dropWhile and filter too
08:22:54 <paczesiowa> > (+1) >>> show >>> reverse >>> read >>> (*2)  $ 1337
08:22:55 <lambdac>  16662
08:22:56 <thoughtpolice> Philonous: import the (>>>) operator from Control.Arrow
08:23:07 <thoughtpolice> it's basically (.) but in reverse
08:23:12 <visof> trofimovi i will
08:23:24 <Philonous> thoughtpolice: Oh, thanks :D
08:23:48 <thoughtpolice> personally I've gotten very used to (.) so I normally use it but that's what it's there for I suppose :)
08:23:55 <trofimovich> @src Data.Bits
08:23:56 <lambdac> Source not found. The more you drive -- the dumber you get.
08:24:11 <Axman6> @src (>>>)
08:24:12 <lambdac> Source not found. My mind is going. I can feel it.
08:24:28 <rwbarton> @src (->) (>>>)
08:24:29 <lambdac> f >>> g = g . f
08:24:38 <byorgey> @src (->) (>>>)
08:24:39 <lambdac> f >>> g = g . f
08:24:54 <trofimovich> @src .&.
08:24:54 <lambdac> Source not found. My brain just exploded
08:24:58 <vixey> @@@ >> ->>...>
08:24:58 <trofimovich> @src (.&.)
08:24:59 <lambdac> Source not found. That's something I cannot allow to happen.
08:25:01 <byorgey> Axman6: (>>>) is a method of the Arrow class, so the implementation for each instance of Arrow is different
08:25:08 <chrisdone> @hoogle (.&.)
08:25:08 <lambdac> A Hoogle error occured.
08:25:14 <Axman6> k
08:25:19 <chrisdone> I'll hoogle error you in a minute
08:25:30 <byorgey> thoughtpolice was referring to the (->) instance of Arrow, which is the most common one
08:25:30 <trofimovich> CosmicRay: does Data.Bits look like you are searching for?
08:25:45 <Olathe> @let (|.) = flip (.)
08:25:46 <lambdac> <local>:13:12:     Ambiguous type variable `f' in the constraint:       `Func...
08:25:55 <Olathe> Okey dokey
08:25:56 <CosmicRay> trofimovich: nope.  it defines another specific operator
08:26:11 <CosmicRay> I want a && that's part of a typeclass that doesn't also imply numeric operations
08:26:51 <trofimovich> something like <|> ?
08:27:18 <trofimovich> and <*>
08:29:03 <Philonous> Btw. is there some predefined function that maps a binary function over a list, feeding it adjacent pairs of elements? (Like: contract f q (x:xs) = f q x : contract f x xs )
08:29:30 <esteth> Is there a function [a] -> [(a,a)] or [a] -> [[a]] that could take a list and put every two elements into a sublist or double? like [1,2,3,4,5,6] -> [[1,2],[3,4],[5,6]]
08:29:37 <Elly> Philonous: foldl/foldr
08:29:49 <Elly> Philonous: I think?
08:29:55 <Botje> Philonous: yes, it's called map (uncurry f) $ zip l (tail l)
08:30:18 <Botje> as for predefinedness .. i leave that to you ;)
08:30:32 <hackage> Uploaded to hackage: formlets 0.4.2
08:30:48 <Botje> meh
08:30:48 <EvilTerran> esteth, no, you have to do that yourself. there's various clever ways of doing it, though
08:30:50 <Philonous> Elly: Botj, ok, I like mine beter ;) But thanks anyway
08:30:57 <Botje> or even zipWith f l (tail l)
08:31:03 <Botje> (silly me)
08:31:06 <Elly> mmm, zipWith
08:31:51 <EvilTerran> esteth, the definition most folk use is something like "chunks :: Int -> [a] -> [[a]]; chunks n = map (take n) . takeWhile (not.null) . iterate (drop n)"
08:31:56 <Philonous> Elly: folfl doesn something similar, but it passes the accumulated value, not just the next element
08:32:01 <Philonous> foldl even
08:32:21 <paczesiowa> > unfoldr (\x -> case x of (y1:y2:ys) -> Just ((y1,y2), ys); _-> Nothing) [1,2,3,4,5,6]
08:32:21 <Elly> Philonous: yeah, but you could return the second element each time
08:32:22 <lambdac>  [(1,2),(3,4),(5,6)]
08:32:26 <esteth> EvilTerran: Mmmm. Thanks, I'll have a look at that and try understand what it's doing :)
08:32:27 <Elly> Botje's way is cooler
08:33:32 <paczesiowa> Philonous: maybe mapAccumL|R
08:33:56 <EvilTerran> esteth, if you want pairs rather than lists, something like paczesiowa's version is what you'll need - altho i find explicit recursion to almost invariably be neater than unfoldr
08:34:19 <EvilTerran> pairs (x:y:rest) = (x,y):pairs rest; pairs _ = []
08:35:04 <paczesiowa> EvilTerran: but then you lose chance to be cool and use some cool cohomopropomorphism
08:35:23 <paczesiowa> or whatever unfolds are called
08:35:28 <BONUS> hey, where can i get a list of all the LANGUAGE and OPTIONS_GHC pragmas and what they do?
08:35:49 <thoughtpolice> BONUS: LANGUAGE pragmas enable language extensions (like multiparameter type classes)
08:35:50 <paczesiowa> ghc docs cli switches in files?
08:35:51 <Philonous> paczesiowa: thanks, but that not what I'm looking for, either. Botjes version is simple enough
08:35:53 <quicksilver> ghc --supported-languages
08:35:55 <quicksilver> I think
08:35:59 <thoughtpolice> OPTIONS_GHC is used to put arbitrary options for each file
08:36:00 <quicksilver> (only works on 6.8+)
08:36:32 <thoughtpolice> byorgey: this has been bugging me, but if (->) is for type construction how can it be an instance of anything? isn't it just a keyword?
08:36:38 <esteth> EvilTerran / paczesiowa: Thanks the unfoldr makes more sense to me than the semi-point-free chunks function. I'm still having trouble trying to understand most of haskell, so trying to fill in the blanks in pointfree definitions confuses me :(
08:36:41 <BONUS> yeah i'm aware of that, i'd just like to see all the available commands and their descriptions
08:36:48 <BONUS> like -fglasgow-exts, etc.
08:36:48 <quicksilver> thoughtpolice: it's a higher kinded type, just like Either
08:36:53 <thoughtpolice> BONUS: check the manual
08:36:58 <quicksilver> thoughtpolice: since classes can be higher kinded (think Monad, or Arror)
08:37:01 <EvilTerran> esteth, it's fairly easy to expand
08:37:03 <quicksilver> thoughtpolice: then it can be an instance
08:37:17 <EvilTerran> chunks n xs = map (take n) . takeWhile (not.null) . iterate (drop n) $ xs
08:37:21 <thoughtpolice> quicksilver: from the keywords on the wiki it says it has kind ?? -> ? -> *
08:37:23 <thoughtpolice> ?
08:37:30 <EvilTerran> = map (take n) (takeWhile (not.null) (iterate (drop n) xs))
08:37:31 <quicksilver> that's a GHC specific thing
08:37:37 <BONUS> i found this doc http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html but it doesnt say what they are
08:37:39 <lambdac> Title: 8.12. Pragmas, http://tinyurl.com/y9jo69
08:37:41 <quicksilver> I don't advise worrying about it unless you're interested in GHC magic.
08:37:47 <quicksilver> its real kind is * -> * -> *
08:37:56 <paczesiowa> Philonous: that code snippet wasn't for you, sorry you tried to understand it:)
08:38:03 <quicksilver> which simply means: it takse type parameters, which are both plain types.
08:38:11 <quicksilver> erm
08:38:14 <quicksilver> 'takes two parameters'
08:38:31 <thoughtpolice> quicksilver: i get kinds but I see what you mean, that's why for an instance of monad the (->) has to be coupled with something since to be an instance of Monad it must be kind * -> *
08:38:50 <paczesiowa> (->) e
08:39:02 <thoughtpolice> right
08:39:20 <paczesiowa> there are no higher kinded sections
08:39:33 <quicksilver> thoughtpolice: correct, it has to be partially applied
08:39:37 <thoughtpolice> in the case of Arrow, arr has type '(b -> c) -> a b c' so a must have kind * -> * -> *
08:39:38 <quicksilver> to reduce its kind down a level.
08:39:52 <quicksilver> yes, because a has two parameters.
08:39:58 <quicksilver> kind inference is very simplistic
08:40:03 <quicksilver> just count the parameters and unify :)
08:40:15 <thoughtpolice> yeah i get kinds
08:40:19 <thoughtpolice> it's just the type of your type
08:40:32 <quicksilver> but all actual values are of kind *
08:40:33 <Philonous> paczesiowa: NP, funnily enough it was close ^^
08:40:41 <quicksilver> including, e.g. all function parameters
08:41:33 <thoughtpolice> quicksilver: but in the case of Monad for instance, it has an instance for '((->) r)' <- what does 'r' specify here?
08:41:46 <quicksilver> the first argument of (->)
08:41:58 <EvilTerran> (->) a b = a -> b
08:41:58 <quicksilver> note that (->) a b is "prefix notation" for a -> b
08:42:05 <quicksilver> so the r is the thing "on the left of the arrow"
08:42:07 <thoughtpolice> yeah, just like (+)
08:42:17 <thoughtpolice> so 'r' is just a type variable and that's it?
08:42:20 <quicksilver> so ((->) r) is "functions out of r"
08:42:21 <quicksilver> yes.
08:42:23 <quicksilver> r is arbitrary
08:42:29 <quicksilver> that instance is polymorphic over all r
08:42:31 <EvilTerran> ?arr
08:42:31 <lambdac> Avast!
08:42:53 <thoughtpolice> hm alright that makes more sense I guess
08:43:14 <quicksilver> written as a section it would be (r ->)
08:43:22 <quicksilver> but haskell doesn't do type-level sections.
08:43:33 <quicksilver> intuitively it's more comprehensible written that way though.
08:43:33 <thoughtpolice> but uh, speaking of kinds, what's up with the special kinds GHC has? i.e. ??, ?, (and I believe) #?
08:43:41 <quicksilver> they're to do with boxing.
08:43:46 <thoughtpolice> ah
08:43:47 <EvilTerran> also, although i think you need an extension (-XTypeOperators?), you can look at Arrow-involving types using (~>) as a type variable
08:43:53 <EvilTerran> ?src Arrow
08:43:53 <lambdac> class Arrow a where
08:43:53 <lambdac>     arr, pure   :: (b -> c) -> a b c
08:43:53 <lambdac>     (>>>)       :: a b c -> a c d -> a b d
08:43:53 <lambdac>     first       :: a b c -> a (b,d) (c,d)
08:43:53 <lambdac>     second      :: a b c -> a (d,b) (d,c)
08:43:55 <lambdac>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
08:43:57 <lambdac>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
08:44:38 <EvilTerran> class Arrow (~>) where arr, pure :: (b -> c) -> (b ~> c); (>>>) :: (b ~> c) -> (c ~> d) -> (b ~> d); ...
08:44:56 <EvilTerran> (you don't need most of those parens, but they make things clearer, i find
08:45:14 <quicksilver> coloured pens make it clearer too.
08:45:15 <BMeph> BONNUS: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html is teh win. :)
08:45:17 <lambdac> Title: 5.17. Flag reference, http://tinyurl.com/ydk2e6
08:45:27 <quicksilver> down with the fascists who won't let me use colour here on #haskell.
08:45:37 <thoughtpolice> hehehe
08:46:18 <chrisdone> quicksilver: aye to that!
08:46:31 <Olathe> FREADOM OF SPEACH !
08:46:35 <chrisdone> and bold
08:48:02 <chrisdone> quicksilver: who actually controls that? I think it's disabled by default on freenode; has anyone ever actually considered the mode?
08:48:23 --- mode: ChanServ set +o quicksilver
08:48:27 --- mode: quicksilver set -c
08:48:35 <visof> > let fibs = 0:1:[ a + b | (a,b) <- zip fibs (tail fibs) ] in let fib = [ x | x <- fibs, (length fib) < 10] in fib
08:48:37 <quicksilver> (>>>) :: b ~> c 3-> c ~> d 3-> b ~> d
08:48:42 <quicksilver> there you go, I think.
08:48:43 <vixey> woah colors
08:48:45 <vixey> nice
08:48:46 --- mode: quicksilver set +c
08:48:49 --- mode: quicksilver set -o quicksilver
08:48:51 <lambdac>  thread killed
08:48:51 <chrisdone> yaaay
08:49:04 <visof> is this illegal syntax ?
08:49:10 <quicksilver> chrisdone: yes, it was considered, I was strongly in favour
08:49:18 <quicksilver> we removed the colour ban for a day or two
08:49:25 <quicksilver> lots of boring people told us they hated it
08:49:28 <quicksilver> so we put the ban back in.
08:49:32 <chrisdone> I see
08:49:53 <quicksilver> maybe I should make a client macro to enable colours, send a message, and disable
08:49:53 <chrisdone> not to be annoying, but their clients can disable it >_>
08:49:58 <quicksilver> then I can be immune :)
08:50:03 <quicksilver> chrisdone: that is (one of) the things I said.
08:50:04 <trofimovich> visof: fibs is one fancy list (not many different lists)
08:50:09 <EvilTerran> visof, well, it doesn't really make sense
08:50:10 <thoughtpolice> unfair :(
08:50:17 <EvilTerran> the fib = [ x | x <- fibs, (length fib) < 10] bit
08:50:18 <chrisdone> quicksilver: oh well ;_;
08:50:25 <EvilTerran> that's a paradox, if i'm reading it right
08:50:59 <visof> EvilTerra i want pick the first 10 elements in fibs
08:51:14 <visof> how can i do this?
08:51:15 <trofimovich> in take 10 fibs
08:51:19 <EvilTerran> if length fib >= 10, then that guard will always be false, so length fib = 0, so that guard will always be true, so ...
08:51:22 <EvilTerran> ?src take
08:51:23 <lambdac> take n _      | n <= 0 =  []
08:51:23 <lambdac> take _ []              =  []
08:51:23 <lambdac> take n (x:xs)          =  x : take (n-1) xs
08:51:30 <EvilTerran> use take, as trofimovich says
08:51:46 <EvilTerran> > let fibs = 0:1:[ a + b | (a,b) <- zip fibs (tail fibs)] in take 10 fibs
08:51:48 <lambdac>  [0,1,1,2,3,5,8,13,21,34]
08:52:11 <EvilTerran> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
08:52:12 <lambdac>  [0,1,1,2,3,5,8,13,21,34]
08:52:24 <chrisdone> does bold work? or is that +n?
08:53:01 <EvilTerran> > fix$(0:).(1:).(zipWith(+)<*>tail)
08:53:02 <quicksilver> I think bold is also controlled by +c
08:53:03 <lambdac>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:53:07 <chrisdone> oh, okay
08:53:20 <chrisdone> damn fascists
08:53:23 <EvilTerran> (sorry, got a little carried away with the golfing there)
08:53:36 <Philonous> Botje: Your function does only work on infinity data structures, since otherwise xs and tail xs have different length. So it'd have to to be zipWith f (init xs) (tail xs)
08:54:13 <EvilTerran> Philonous, um, zipWith truncates the longer list to the length of the shorter one anyway
08:54:23 <EvilTerran> so that init is redundant
08:55:24 <EvilTerran> ?src zipWith
08:55:25 <lambdac> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:55:25 <lambdac> zipWith _ _      _      = []
08:57:28 <Philonous> Really? Oh, right
08:57:32 <ziman> > fix$[0,1]++(zipWith(+)<*>tail)
08:57:33 <lambdac>  Couldn't match expected type `[a -> t]'
08:57:57 <Philonous> Well, strange, hugs just comlained about it. But I guess that whas my mistake, then
08:58:24 <ziman> > fix$([0,1]++).(zipWith(+)<*>tail)
08:58:25 <lambdac>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:58:40 <Philonous> Thanks anyway
08:58:55 <Olathe> You're not using ghc ?!?!
08:59:49 <Philonous> Shouldn't I use hugs for interpretation?
09:00:14 <quicksilver> ghci is more featureful
09:00:22 <quicksilver> hugs is faster at 'compiling' though
09:00:34 <quicksilver> I always use ghci.
09:01:07 <Philonous> Ok, up until now I didn't really miss anything. But I will switch then
09:04:14 <Botje> Philonous: well, if you're at the last element of the list, what do you give to the binary function?
09:06:55 <Philonous> last thing to give to the function should be (last ( init xs ) ) and (last xs)
09:08:31 <zachk> now http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot is excellent, but what 4 more lines of code to i add to get a client? :D
09:08:32 <lambdac> Title: Roll your own IRC bot - HaskellWiki
09:15:39 <paczesiowa> SyntaxNinja: do you have darcs repos of xml and feed? I wanted Eq instances of RSS types and dons told me to send him patches but I haven't heard from him since
09:16:16 <sbahra> Why is it "lambdac" and not lambdabot" now?
09:16:36 <vixey> I think lambdabot broke down, so lambdac is a replacement
09:16:49 <paczesiowa> is it written in c?
09:17:21 <sbahra> vixey, ah, I see
09:17:27 <SyntaxNinja> paczesiowa: hrm. I guess there's no public repo. we're using git actually...
09:17:29 * SyntaxNinja pokes dons
09:19:55 <paczesiowa> SyntaxNinja: could you make it public? I might be interested in sending more patches
09:20:26 <thoughtpolice> sbahra: lambdabot was taking up absurd amounts of memory on the code.haskell.org server (where it is run from) so it had to be killed
09:20:33 <thoughtpolice> (like 80% of the RAM was being used by lambdabot)
09:21:07 <sbahra> thoughtpolice, why?
09:21:18 <paczesiowa> was it rising? maybe buying more ram was the answer
09:21:35 <sbahra> Specifically, what paczesiowa asked :-P
09:21:40 <SyntaxNinja> paczesiowa: yeah, I'll look into it. I don't know what dons had planned, as he was cordinating things. github sounds cool so maybe I'll try using that...
09:21:54 <SyntaxNinja> paczesiowa: thanks for your interest and offer of help!
09:22:00 <thoughtpolice> no, lambdabot leaks runplugs instances
09:22:05 <thoughtpolice> so there were *a lot* of instances up there
09:22:26 <quicksilver> the runplugs instances don't actually matter
09:22:28 <quicksilver> although they're ugly
09:22:34 <thoughtpolice> (runplugs is run every time you just evaluate something with lambdabot for example, so in a day or two that can add up a lot...)
09:22:35 <quicksilver> they aren't using CPU so they get swapped out
09:22:43 <quicksilver> all they consume is swap space
09:22:52 <quicksilver> although, IIRC, code.haskell.org doesn't have any swap (?!?!)
09:23:01 <quicksilver> however, the leak in the main lambdabot process is a problem.
09:23:10 <thoughtpolice> quicksilver: how bad is it?
09:23:19 <thoughtpolice> and no swap? :(
09:24:00 <paczesiowa> SyntaxNinja: np, thanks for feed lib, without it I'd have to use strings - there's too much boring types to define
09:24:01 <quicksilver> well it's a good old fashioned leak.
09:24:05 <quicksilver> it just grows for ever.
09:24:16 <quicksilver> c.h.o doesn't have that much RAM, either.
09:24:24 <sbahra> I could donate a box
09:24:44 <sbahra> Itanium 2, 8GB RAM, 8MB L3
09:25:00 <quicksilver> that would be helpful.
09:25:02 <sbahra> Cliche HDD, 7200RPM 40GB WD
09:25:03 <quicksilver> is it always-on?
09:25:10 <quicksilver> and is its network connection reliable?
09:25:33 <sbahra> quicksilver, in theory, yes. But I was thinking along the lines of shipping it to someone in the US who have it on a reliable connection.
09:26:05 <sbahra> quicksilver, @home, I don't have a static IP. So it is fine for lambdabot maybe, just nothing else.
09:26:21 <thoughtpolice> galois runs those servers don't they?
09:26:58 <quicksilver> galois runs {one,some} of them
09:27:02 <quicksilver> I'm not sure of the details.
09:27:28 <ddarius> www.haskell.org is not run by Galois, code.haskell.org and darcs.haskell.org are I believe.
09:27:37 <thoughtpolice> if I can't get any use out of this crap thing I have next to me I might as well donate it as well
09:27:47 <ddarius> sbahra: How do you have a machine with 8GB RAM etc. that you have no use for?
09:27:55 <thoughtpolice> HP server, dual 3.0gHz xeon's with 1.5gb RAM, HDD is only like 20gb right now
09:27:59 <sbahra> ddarius, because I work in a high performance computing laboratory.
09:28:01 <thoughtpolice> although only one of the HDD slots are taken
09:28:06 <thoughtpolice> there are 3 more
09:28:11 * thoughtpolice kicks it
09:29:04 <thoughtpolice> if it actually had internet it might be more useful, offline, I have not found a single linux distro or BSD system that can install onto it
09:29:09 <thoughtpolice> most die at the installer
09:29:25 <sbahra> ?
09:29:33 <sbahra> thoughtpolice, what happens with FreeBSD?
09:29:48 <thoughtpolice> sbahra: I actually haven't tried FBSD
09:30:29 <thoughtpolice> I tried netBSD and it did install although due to my retardation I didn't set / to be writable so I couldn't, you know, do anything. i would have redone it but that was after I had spent like 5 hours messing with it already
09:30:34 <thoughtpolice> and just called it a day
09:31:37 <thoughtpolice> sbahra: i'll give freebsd a shot one of these days to see if I can make any headway
09:33:42 <sbahra> thoughtpolice, FreeBSD is likely a better idea anyways, for SMP.
09:34:09 <thoughtpolice> sbahra: I'll keep it in mind
09:34:23 <thoughtpolice> i'm moving to uni soon so I'll have internet and whatnot and hopefully it can be more useful in general
09:34:29 <thoughtpolice> although, it is really going to suck to move
09:36:09 <thoughtpolice> sbahra: and luckily I seem to have my old FreeBSD disks right here :) don't know if it's 7.0 though
09:39:02 <thoughtpolice> hi tibbe, how's nio coming?
09:40:52 <tibbe> thoughtpolice: got some more work into my kqueue bindings, writing an echo server as a performance test
09:42:09 <thoughtpolice> tibbe: are your goals primarily much better performance or are you just very dissatisfied with e.g. System.IO & kin in general?
09:42:29 <tibbe> thoughtpolice: both
09:43:38 <thoughtpolice> hehe
09:43:49 <tibbe> thoughtpolice: I've dissatisfied with the reliance on lazy I/O in many recent libraries, String is used in many places were a binary data type should be used, etc
09:44:10 <thoughtpolice> tibbe: so we're back to folding to the left huh? :)
09:44:21 <tibbe> yes
09:44:22 <tibbe> ;)
09:44:31 <tibbe> and fusion for in memory data processing
09:44:36 <idnar> fold to the left and fold to the right; stand up, sit down, fight fight fight!
09:45:07 <elliottt> tibbe: dons was saying that you were working on an http server, what's your performance like currently?
09:45:22 <tibbe> 1300 QPS or so
09:45:28 <tibbe> with a minimal response
09:45:37 <tibbe> but I haven't spent any time on optimizing it yet
09:45:47 <tibbe> I'm trying to solve the problem of doing I/O in a good way
09:45:58 <elliottt> cool :)
09:46:35 <tibbe> QPS = queries per second
09:46:39 <sbahra> tibbe, did you look at reppie's httpd?
09:46:53 <sbahra> tibbe, http://people.freebsd.org/~ssouhlal/stuff/rephttpd-0.4.hs
09:47:29 <tibbe> not
09:47:30 <tibbe> yet
09:47:33 <tibbe> will though
09:47:34 <tibbe> tonight
09:47:36 <tibbe> thanks
09:48:23 <tibbe> sbahra: do you know how well it performs?
09:49:07 <sbahra> No. But it is a simple fork-based httpd, so I don't expect anything spectacular.
09:49:35 <tibbe> mine currently does forkIO
09:49:42 <tibbe> it uses folds for safe I/O
09:49:58 <tibbe> but later I will try to use e.g. kqueue
09:50:01 * sbahra doesn't know what "safe I/O"
09:50:15 <tibbe> sbahra: == non lazy I/O
09:50:18 <sbahra> I started haskell 2 days ago, iirc.
09:50:19 <tibbe> closing handles in time
09:50:25 <tibbe> freeing resources, handling errors
09:50:27 <sbahra> tibbe, ah
09:50:29 <tibbe> sbahra: oh ok
09:50:31 <tibbe> :)
09:50:32 <tibbe> welcome
09:50:35 <sbahra> tibbe, rather than leaving it to the GC?
09:50:46 <sbahra> or something
09:50:50 <tibbe> yes
09:50:58 <sbahra> cool
09:51:03 <tibbe> which is not guaranteed to free the handle until the program exits
09:51:12 <sbahra> I would be interested in looking at your kqueue stuff, actually
09:51:13 <tibbe> the finalizers that is
09:51:34 <sbahra> Since I was originally planning on having that as my first serious hs endeavor
09:51:35 <tibbe> sbahra: drop me an email at johan . tibell @ gmail dot com and I'll send you a link as soon as it's working
09:51:50 <sbahra> I think I might go with a libevent approach though.
09:51:58 <sbahra> tibbe, alright
09:53:15 <tibbe> sbahra: what's the libevent approach?
09:53:22 <sbahra> sent
09:53:41 <tibbe> ?
09:53:48 <tibbe> ok
09:53:49 <tibbe> cool
09:53:53 <tibbe> didn't get it at first
09:53:58 <sbahra> tibbe, something more abstract than simply using kqueue directly
09:54:03 <tibbe> right
09:54:14 <sbahra> tibbe, abstract interface for events, you could use kqueue/epoll/etc...
09:54:20 <tibbe> I was thinking of creating something like System.Event which uses different backends like kqueue
09:54:26 <tibbe> yes definately
09:54:34 <tibbe> it needs to be multiplatform
09:54:40 <tibbe> one step at the time though
10:15:38 <lispy> Is there an off the shelf blog system (like blogspot, livejournal, etc) that works well for haskell code?  I want a way to say that things are blocks of haskell and get some syntax coloring.  I also want one of those WYSIWYG style editors instead of raw HTML tags.
10:16:02 <cjb> lispy: have a look through planet haskell and look for "powered by <foo blog engine>" signs?  :)
10:16:30 <lispy> cjb: that's not a bad idea. BTW, I don't want run my own system.  I want to use one.
10:16:44 <lispy> So, installing wordpress is not what I want.
10:17:17 <gwern> lispy: blog on haskell.org and use <haskell></haskell>? :)
10:17:59 <lispy> I like luqui's blog
10:18:09 <lispy> gwern: haskell.org offers blogs?
10:18:54 <gwern> lispy: just stick'em in your userspace
10:19:05 <gwern> the wiki is very lax; I doubt anyone will object
10:19:51 <lispy> oh, the wiki
10:20:07 <lispy> Maybe I should just fix my wordpress install that I already have
10:22:09 <xif> lispy: I bet lots of syntax highlighting packages support Haskell these days
10:23:22 <xif> lispy: see, for instance, pygments: http://pygments.org/
10:23:24 <lambdac> Title: Pygments &mdash; Python syntax highlighter
10:25:56 <lispy> xif: so you run your code through pygments before posting?
10:26:15 <lispy> xif: not what I want, but it would give the same end result I guess
10:26:27 <xif> lispy: that's one option. another option is to blog on a Python system, and install pygments as a plugin.
10:26:43 <xif> (you also get run it on AppEngine for free ;)
10:27:10 <mmorrow> tibbe, sbahra: i just recently was browsing the thttpd code, and fdevent.{h,c} therein seems to be exactly what you were just discussing. i put em here if either of you are interested in taking a peek:
10:27:12 <mmorrow> http://code.haskell.org/~morrow/httpd/thttpd/fdwatch.h
10:27:13 <mmorrow> http://code.haskell.org/~morrow/httpd/thttpd/fdwatch.c
10:27:14 <lispy> xif: I'm trying to farm out the blog software to 3rd party that specializes in it.  I've had my server go down 3 times for various reasons and had to reconstruct/install my blog each time
10:27:32 <Philonous> Is there a way to compare an Integral to the floor of the sqrt of another Integral without tripping over the types?
10:28:25 <xif> lispy: cool... see comment about AppEngine. you get to serve for basically free, on a stable platform.
10:29:11 <paolino> :t floor . sqrt
10:29:13 <lambdac> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
10:29:37 <paczesiowa> :t round . sqrt
10:29:38 <lambdac> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
10:29:48 <paolino> ﻿:t floor . sqrt . fromIntegral
10:29:49 <lispy> xif: Yeah, but I just feel like if I'm going to run it myself I might as well just do it on the server I already have with my familar domain name, tec
10:29:56 <paczesiowa> :t floor . sqrt . fromIntegral
10:29:58 <lambdac> forall b a. (Integral a, Integral b) => a -> b
10:30:12 <paczesiowa> > floor . sqrt . fromIntegral 2 10
10:30:12 <lambdac>   add an instance declaration for (Num (t -> f a))
10:30:35 <sw17ch__> > (6 :: Int) < (floor . sqrt (8 :: Int))
10:30:36 <lambdac>  Couldn't match expected type `f a' against inferred type `Int'
10:30:38 <paczesiowa> > 2 < floor . sqrt . fromIntegral 10
10:30:39 <lambdac>   add an instance declaration for (Num (f a))
10:30:44 <paczesiowa> > 2 < floor . sqrt . fromIntegral $ 10
10:30:45 <lambdac>  Couldn't match expected type `a -> b' against inferred type `Bool'
10:30:45 <sw17ch__> > (6 :: Int) < ((floor . sqrt) (8 :: Int))
10:30:46 <lambdac>   add an instance declaration for (Floating Int)
10:30:57 <sw17ch__> > (6 :: Int) < ((floor . sqrt . fromIntegral) (8 :: Int))
10:30:57 <mmorrow> tibbe, sbahra: also, the lighttpd files  fdevent*.{c,h}   may also be of interest
10:30:58 <lambdac>  False
10:31:25 <Philonous> Looks ugly, but it has to be it. Thanks.
10:31:29 <sw17ch__> Philippa, ^^
10:31:31 <sw17ch__> woops
10:31:35 <sw17ch__> too many people
10:33:59 <paolino> the chris* group wins
10:35:15 <lispy> ?tell mmorrow You asked about my TH example: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
10:35:15 <lambdac> Consider it noted.
10:36:29 <mmorrow> lispy: thanks.
10:36:29 <lambdac> mmorrow: You have 1 new message. '/msg lambdac @messages' to read it.
10:37:44 <Quadrescence> What exactly is Alex, Happy, and Parsec?
10:37:53 <lispy> Quadrescence: Alex is a lexer
10:38:06 <EvilTerran> Alex is a lexer *generator*
10:38:06 <lispy> Quadrescence: Happy generates a parser from a declarative description of your grammar
10:38:16 <EvilTerran> happy is a parser generator
10:38:23 <EvilTerran> parsec is a parser combinator library
10:38:24 <lispy> Quadrescence: Parsec is a set of monadic combinators that allow you to write your own parser efficiently
10:38:29 <EvilTerran> alex and happy are like lex and yacc
10:38:36 <Quadrescence> hrm
10:38:40 <mmorrow> Quadrescence: http://darcs.haskell.org/ghc/compiler/parser/HaddockLex.x
10:38:48 <mmorrow> Quadrescence: http://darcs.haskell.org/ghc/compiler/parser/HaddockParse.y
10:39:02 <mmorrow> those two are good (short) examples
10:39:14 <mmorrow> that are non-contrived
10:40:19 <lispy> Quadrescence: Happy + Alex is probably the fastest way to get going if you have a properly specified grammar.  But, parsec gives you the most power interms of what can be parsed (you combine combinators to parse anything a turing machine can parse).  Parsec can be hard to use because of backtracking issues (see the try combinator).  Parsec is still really nice.
10:41:02 <Quadrescence> Alex would make the third "part" to Happy, right?
10:41:48 <Quadrescence> Well, the lexer part.
10:41:56 <mmorrow> Quadrescence: i don't understand what you mean. Alex and Happy are usually used together, but neither requires the other.
10:42:06 <Quadrescence> Right, neither requires the other.
10:42:17 <mmorrow> yes
10:42:28 <Quadrescence> But happy needs "a simple lexer to return [the] data structure"
10:42:41 <Quadrescence> (from their site/documentation)
10:42:56 <Quadrescence> Alex would generate this code, right?
10:42:57 <mmorrow> yes, but that lexer doesn't even have to be lexing text
10:43:04 <lispy> Quadrescence: FWIW, GHC uses Alex + Happy.
10:43:14 <mmorrow> it just needs to provide happy with a stream of "Tokens"
10:44:00 <Quadrescence> Maybe I should actually find what *what* a lexer is.
10:44:05 <mmorrow> ghc's lexer: http://darcs.haskell.org/ghc/compiler/parser/Lexer.x
10:44:15 <mmorrow> ghc's parser: http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp
10:44:36 <EvilTerran> lexer :: String -> [Token]
10:44:37 <lispy> Traditionally a lexer does things like this: Sees a sequences of digits and says, "Oh, that's a numeric constant" and a parser sees things like numeric constants and says, "Oh, that's a valid part of this expression I'm building"
10:44:38 <EvilTerran> approximately
10:44:40 <zachk> whats standard input's handle in haskell?
10:44:52 <mmorrow> stdout
10:44:56 <mmorrow> err
10:44:57 <mmorrow> stdin
10:44:58 <mmorrow> heh
10:45:18 <Quadrescence> lispy EvilTerran: ah.
10:45:25 <mmorrow> zachk: import System.IO
10:45:37 <lispy> Quadrescence: So, a lexer is thought of as a translation from a stream of characters to a stream of tokens.  A parser is from a stream of tokens to an abstract syntax tree
10:45:53 <Quadrescence> Right, I get it now.
10:46:17 <zachk> mmorrow: i want do hPutStr stdinHandle string, what is stridinHandle?
10:46:31 <Quadrescence> Are lexing and parsing two different things then? Or is it commonly understood that lexing is just a part of parsing?
10:47:01 <lispy> Quadrescence: I think it's mostly just an different to aid in the construction
10:47:17 <EvilTerran> zachk, you want to print to standard input?
10:47:19 <lispy> Quadrescence: You could forgot the lexer, but your grammer would be hard to specify (because it really has two levels)
10:47:54 <lispy> Quadrescence: But, a lexer doesn't build expression trees so it's hard to forego that step and say that you have a parser
10:48:13 <Quadrescence> lispy: Ah, okay. So if I want to parse a file -- I need to start with the lexer and then make a grammar for the parser?
10:48:28 <Quadrescence> (i.e., Alex, then make a grammar for Happy)
10:48:35 <ziman> i think it's more efficient that way
10:48:43 <zachk> EvilTerran: well actually i want to flush it after i print to it so i can make a prompt
10:48:58 <EvilTerran> zachk, you want to *output* to standard *input*?
10:48:59 <lispy> Quadrescence: basically yes.  But, you could also assume you have a token stream and make the parser for the token stream.  You could even quickcheck it given a token stream generator.  Then you could add a lexer :)
10:48:59 <ziman> a LR parser would have too many states if it had to process characters
10:49:36 <Quadrescence> hrm
10:49:45 <lispy> Quadrescence: the distinction lexer/parser is somewhat subtle when you first learn about it, but it's really quite clever.
10:50:02 <EvilTerran> ?type System.IO.stdin
10:50:04 <lambdac> GHC.IOBase.Handle
10:50:18 <Quadrescence> lispy: I think I understand the difference. Just when people say "I want to parse this file," I am guessing they mean lex/parse.
10:50:25 <mmorrow> zachk: hPutStr stdin "asdf"
10:50:32 <zachk> ok
10:50:37 <EvilTerran> zachk, the handle for standard input is stdin in System.IO. you can't output to it, though, seeing as it's an input handle
10:50:54 <Quadrescence> Even if you can't "lex something," I mean "make a lexer for use with parsing"
10:50:56 <Quadrescence> bla bla bla
10:51:17 <EvilTerran> ghci> System.IO.hPutStr System.IO.stdin "test"
10:51:17 <EvilTerran> *** Exception: <stdin>: hPutStr: illegal operation (handle is not open for writing)
10:52:02 <mmorrow> yeah, it may work in a compiled program though
10:52:22 <mmorrow> but even if it does work, it probably won't be doing what you want to be doing
10:52:25 <EvilTerran> mmorrow, er, how? what would it do?
10:52:35 <mmorrow> i don't even know :)
10:53:16 <mmorrow> i suppose... say you forkIO'ed a thread to dump stdin, but stdin is empty
10:53:25 <mmorrow> then you could hPutStr stdin "asdf"
10:53:33 <hidden333333> hello anyone out there in cyber world
10:53:39 <Zao> hidden333333: No.
10:53:41 <mmorrow> *maybe* then that forked thread would print "adsf" and exit
10:53:54 <chrisdone> hidden333333: would you like to play a game of chance?
10:54:04 <hidden333333> hello friends.
10:54:24 * dmhouse joined late to this, but is mmorrow talking about _writing_ to std_in_? Because, y'know, you can't do that.
10:54:30 <hidden333333> I want to know how would I get the URL that a web browsser is viewing?
10:54:41 <mmorrow> dmhouse: hehe. i was
10:55:00 <twobitwork> heh, I finally got my haskell code to run in constant space (so far :)
10:55:01 <EvilTerran> dmhouse, i've been trying to tell zachk that for some time
10:55:04 <mmorrow> clearly i've never attempted this ;)
10:55:12 <dmhouse> mmorrow: if it doesn't work in GHCi, why would it work when you compiled it?
10:55:24 <dmhouse> twobitwork: yay! What does it do?
10:55:31 <mmorrow> dmhouse: because ghci could be messing with the environment
10:55:36 <twobitwork> instead of having "permutation = [] : map next permutation" I have "permutation () = map next (permutation ())"
10:55:40 <zachk> EvilTerran: got it stdout :D
10:55:55 <hidden333333> i guess no one knows?
10:55:57 <EvilTerran> zachk, you can just use putStr instead of hPutStr stdout, ya know?
10:55:57 <twobitwork> (where next of course computes the next permutation :)
10:56:03 <dmhouse> twobitwork: why the unit parameter?
10:56:04 <EvilTerran> ?src putStr
10:56:05 <lambdac> putStr s  = hPutStr stdout s
10:56:06 <zachk> yea but i need to flush it
10:56:13 <zachk> so the prompt shows up correctly
10:56:16 <EvilTerran> well, you can still flush it afterwards
10:56:23 <dmhouse> twobitwork: foo () = bar is precisely the same as foo = bar
10:56:23 <EvilTerran> ?type hFlush
10:56:25 <lambdac> Not in scope: `hFlush'
10:56:27 <EvilTerran> no?
10:56:31 <dmhouse> (Modulo calls to foo on the RHS.)
10:56:45 <twobitwork> dmhouse: I think because with out it, its just a value, and thus "global" maintains a reference to the head, thus the GC can't follow behind cleaning up already traversed elements
10:57:05 <EvilTerran> zachk, you can still "hFlush stdout" after using putStr
10:57:12 <EvilTerran> <lambdac> putStr s  = hPutStr stdout s
10:57:16 <twobitwork> when you turn it into a function, no one else holds a reference to the head of the returned list
10:57:18 <EvilTerran> putStr and hPutStr stdout are identical
10:57:42 <dmhouse> Wow, breakage of referential transparency ftw.
10:57:48 <lispy> Quadrescence: another point about using Parsec.  It's really easy to forget about separating your lexing/parsing.  This can be good or bad depending...
10:57:49 <twobitwork> dmhouse: yeah...
10:58:12 * EvilTerran separates lexing and parsing when he's using parsec anyway
10:58:16 <twobitwork> dmhouse: laziness is not a holy grail, despite what some would like to believe
10:58:19 <lispy> Quadrescence: my first few failed attempts at effectively using parsec were because I hadn't mastered the separation
10:58:25 <bogner> why don't the api docs on hackage have source links? those would be very helpful
10:58:25 <dmhouse> Quite.
10:58:26 <EvilTerran> i find it makes for a cleaner design to separate the two
10:58:32 <EvilTerran> just as two parsec parsers, even
10:58:39 <lispy> bogner: yes, I would like this feature too!
10:59:00 <lispy> EvilTerran: yeah, parsec allows from some sweet designs
10:59:14 <lispy> EvilTerran: but I felt like you have to really understand it before it works for you
10:59:15 <twobitwork> dmhouse: I think it also says something that I implemented it in 20 minutes in ocaml and it took me 2 days to figure out how to do it in haskell... as to what exactly it says is subjective...
10:59:30 <BMeph> dmhouse: Won't foo and bar have dif't type sigs? :)
10:59:55 <dmhouse> BMeph: well, you know what I mean.
11:00:02 <EvilTerran> lispy, yeah - it took me a while to get a grasp of when try was necessary, for instance
11:00:16 <dmhouse> twobitwork: lazy code makes it hard to reason about space, I think that is well known.
11:00:31 <BMeph> dmhouse: Heh-heh. Just spreading the "technicality" love... :)
11:00:31 <twobitwork> dmhouse: yeah, and it bit me in the ass
11:00:49 <twobitwork> BMeph: but its precisely that technicality that bit me yesterday :)
11:00:50 <dmhouse> twobitwork: what does the code do, out of interest?
11:01:20 <twobitwork> dmhouse: well... yesterday I was lurking and heard someone talking about an interesting problem and I love to find excuses to code inane but fun things....
11:02:08 <twobitwork> dmhouse: this one is about a calculator with 2 functions, "* 2" and "/ 10"... the goal is to figure out how to use those functions (with an initial value of 1) to get to 21
11:02:41 <monochrom> <3
11:02:42 <bogner> lispy: do you know which mailing list is appropriate for hackage feature requests?
11:02:42 <dmhouse> Gotcha.
11:03:02 <twobitwork> the solution was fairly simple (at least, in a brute force kind of way) but the implementation was tricky due to inanities about laziness
11:03:05 <dmhouse> twobitwork: are you allowed intermediate nonintegers?
11:03:11 <BMeph> twobitwork: So, you want your function to tell you the button sequence? :)
11:03:14 <dmhouse> I guess you don't need them actually.
11:03:18 <twobitwork> dmhouse: its all integrals, afaik
11:03:24 <twobitwork> at least, mine assume integrals
11:03:30 <lispy> bogner: sorry I don't.  But, dons or dcoutts would
11:03:40 <mmorrow> twobitwork: that reminds me on a neat little perl program on perlmonks.org that used genetic programming to do something similar
11:03:46 <twobitwork> BMeph: yes... and it does so by running through all permutations of the button sequences
11:03:55 <Quadrescence> lispy: I am going to try to use alex/happy. I know *exactly* how I want to define my lexer/parser or whatever. But, it's just a matter of implementing it, and figuring out how to use alex and happy.
11:04:05 <dcoutts_> bogner: the hackage trac is a good place to start, or email cabal-devel
11:04:13 <twobitwork> mmorrow: I did think about using some search optimizations like that, but wanted to get the BF one first
11:04:20 <bogner> dcoutts_: thanks
11:04:23 <dmhouse> twobitwork: hmm, is that not a matter of finding the first power of 2 which is 21 * 10^n for some n?
11:04:31 <dcoutts_> bogner: what were you thinking of btw?
11:04:36 <rwbarton> Are you supposed to find the shortest solution, or any solution?
11:04:37 <rwbarton> > find (\x -> take 2 (show x) == "21") $ iterate (* 2) 1
11:04:38 <lambdac>  Just 2147483648
11:04:42 <mmorrow> twobitwork: brainfuck?
11:04:42 <dmhouse> twobitwork: since (*2) and (/10) commute.
11:04:50 <lispy> Quadrescence: good luck.  I haven't tried happy and alex but if you can express your grammar in the right way it should be straight forward
11:04:54 <twobitwork> mmorrow: brute force... althought brainfuck is fun too
11:04:59 <dcoutts_> bogner: hackage.haskell.org/trac/hackage/  has instructions for registering or using the guest account
11:04:59 <mmorrow> twobitwork: hehe
11:05:04 <twobitwork> I wrote a brainfuck interpretter in bash once :)(
11:05:11 <mmorrow> nice
11:05:18 * mmorrow loves bash
11:05:23 <twobitwork> it was horribly, horribly slow
11:05:23 <twobitwork> :)
11:05:25 <lispy> ?bf +++>+
11:05:25 <lambdac> Done.
11:05:34 <lispy> Note, that lambdac has a restricted bf
11:05:35 <mmorrow> twobitwork: here's the perl one http://perlmonks.org/?node_id=31147
11:05:39 <lambdac> Title: Genetic Programming or breeding Perls
11:06:08 <dmhouse> rwbarton: not quite, I think it has to be 21, and the rest all zeroes.
11:06:29 <rwbarton> Well, that's certainly never going to happen--how are you going to get a factor of 3?
11:06:55 <mmorrow> rwbarton has a point
11:07:01 <rwbarton> (I mean, once you get 2147483648, keep dividing by 10 until you reach 21)
11:07:10 <rwbarton> (assuming that (/ 10) means (`div` 10))
11:07:27 <mmorrow> ah
11:08:35 <Quadrescence> Does anyone have a more-or-less simple example of an alex/happy file from which I can learn? :/
11:08:43 <bogner> dcoutts_: i was thinking that hackage api docs should have the source links, like the haskell.org api docs or the local docs do
11:09:09 <Quadrescence> Nevermind.
11:09:12 <dcoutts_> bogner: yes they should
11:09:15 <dmhouse> rwbarton: I'm not sure "how are you going to get a factor of 3" applies, since you're dividing. But you'll certainly never have a 5, so 2^n / 10 is nonintegral for all n.
11:09:24 <rwbarton> dmhouse: that too
11:09:36 <gwern> > 3000 36
11:09:37 <lambdac>   add an instance declaration for (Num (t -> a))
11:09:47 <gwern> > 3000 / 36
11:09:48 <lambdac>  83.33333333333333
11:10:12 <gwern> > 8000 / 36
11:10:13 <lambdac>  222.22222222222223
11:10:54 <gwern> > (8000 / 36) / 5
11:10:55 <lambdac>  44.44444444444444
11:11:30 <gwern> > (8000 / 36) / 6
11:11:31 <lambdac>  37.03703703703704
11:11:31 <twobitwork> rwbarton: 1*2*2*2*2*2/10
11:11:58 <twobitwork> > 1*2*2*2*2*2 `div` 10
11:11:59 <lambdac>  3
11:12:04 <rwbarton> twobitwork: Right, that's why I asked whether you were looking for the shortest solution, which my suggestion might not give you
11:12:27 <twobitwork> rwbarton: ahh... I thought you were saying it wasn't possible to get a power of 3 using those two operations
11:12:50 <twobitwork> of course, I used my program to find the solution :)
11:12:53 * twobitwork is lazy
11:13:13 <monochrom> lazy is good.
11:15:31 <bogner> lispy, dcoutts_: filed as #322 on the hackage trac
11:15:40 <lispy> bogner: cool
11:16:13 <dcoutts_> bogner: ta
11:16:54 <dcoutts_> bogner: I've no idea how to do it with the current hackage server (I've never seen the code that does the automatic builds), but it should be transparent with the new one.
11:19:15 <esteth> I'm having a little trouble with this function. It works for lists of size two, but when doing a list of size 4, I get an extra 0 in the middle of my results. Can anyone see why? http://hpaste.org/9561
11:19:45 <bogner> dcoutts_: i don't know anything about the hackage servers, though i was thinking of fixing this myself and submitting a patch, is the hackage-scripts repository the right place to look?
11:20:30 <dcoutts_> bogner: it's a good place to start, however I don't think the code that actually does the builds lives in that repo. I've no idea where that code is. You could ask on the cabal-devel mailing list.
11:20:44 <bogner> dcoutts_: works for me. thanks
11:21:43 <rwbarton> esteth: have you tested your groups2 function?  (groups2 [1,2,3,4] == [(1,2),(3,4)]?)
11:22:34 <monochrom> I also impeach groups2.
11:22:50 <esteth> rwbarton, The groups2 function works as expected. [1,2,3,4] -> [(1,2),(3,4)]
11:23:04 <esteth> groups2 = unfoldr (\x -> case x of (y1:y2:ys) -> Just ((y1,y2), ys); _-> Nothing)
11:23:49 <twobitwork> hmm... my function does still seem to be growing, but very very slowly
11:24:06 <twobitwork> in the past 10 minutes it grew from 33M to 36M
11:25:34 <monochrom> I can't reproduce your 0. transform [5,8,4,3] = [6.5,3.5,-1.5,0.5].
11:26:32 <esteth> Oh! I feel like a prat. I mistook a . for a , in my results. It was 5.0, not 5,0. Sorry :(
11:26:45 <esteth> Thanks monochrom, or I wouldn't have realised :)
11:27:05 <rwbarton> (I wondered for a moment why monochrom's output had length 8 :)
11:27:24 <monochrom> Haha
11:28:25 <rwbarton> hpaste should be integrated with lambdabot somehow, so you can evaluate code that uses the definitions in the hpaste
11:34:23 <gwern> rwbarton: now that'd be ambitious
11:38:31 <mmorrow> twobitwork: heh, heres a quick hack that tries to randomly guess a solution: http://hpaste.org/9564
11:38:56 <mmorrow> closest i've gotten is 20.48
11:38:58 <mmorrow> (20.48,["(*2)","(*2)","(/10)","(*2)","(*2)","(*2)","(*2)","(*2)","(*2)","(*2)","(*2)","(/10)","(*2)"])
11:40:19 <dmhouse> mmorrow: did you catch my and rwbarton's proof that it's not possible to get 21 exactly?
11:40:28 <mmorrow> heh, no
11:40:31 * mmorrow scrolls back
11:40:51 <dmhouse> mmorrow: a/b is an integer precisely when all the factors of b are also factors of a.
11:40:55 <twobitwork> dmhouse: I don't think rwbarton proved that
11:41:09 <twobitwork> unless I misunderstood
11:41:20 <dmhouse> mmorrow: since (*2) and (/10) commute, we are free to move all the (*2)s to the front, and the (/10)s to the end
11:41:34 <rwbarton> I think there was some confusion at first about whether it was (/ 10) or (`div` 10)
11:41:38 <dmhouse> So we end up with 2^n / 10^m for some integers n and m
11:41:47 <twobitwork> it's (`div` 10)
11:41:51 <mmorrow> ahhh
11:42:01 <dmhouse> Yes, this proof applies to (/10).
11:42:13 * mmorrow changes his prog to use (`div`10)
11:42:36 <dmhouse> But since the denominator has factors of 5 (for m > 0), and the numerator doesn't, this will be nonintegral (for m > 0).
11:43:07 <BMeph> Didn't we do this yesterday? :)
11:43:17 <twobitwork> BMeph: yes, this is a continuation of it :)
11:44:17 <Olathe> > map ((`div` 5).(`div` 2)) [1..]
11:44:19 <lambdac>  [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3...
11:44:20 <Olathe> > map (`div` 10) [1..]
11:44:21 <lambdac>  [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3...
11:47:27 <twobitwork> well... computing the solutions for 1..21 so far I have all of them up to 20
11:48:20 <twobitwork> I'm not sure what the distinction between (/10) and (`div` 10) would have to do with whether or not its solvable
11:49:24 <twobitwork> (the first 20 were produced in a matter of seconds... 21 seems to be signifigantly harder)
11:49:39 <andyjgill> @pl id
11:49:39 <lambdac> id
11:49:48 <ziman> @unpl id
11:49:48 <lambdac> (\ a -> a)
11:50:07 <andyjgill> @pl \ a b c -> b (a c)
11:50:07 <lambdac> flip (.)
11:50:27 <twobitwork> @unpl flip (.)
11:50:27 <lambdac> (\ b c f -> c (b f))
11:50:52 <twobitwork> does it choose random letters)
11:51:00 <andyjgill> Is there any predefined flip (.)? Or a convention?
11:52:47 <mmorrow> http://hpaste.org/9564#a1   21 is really hard. i'm trying in chunks of 1000 randgen solutions with minlen=5, maxlen=1000 and i'm on maybe try 100 w/out a solution
11:53:00 <sioraiocht> andyjgill: why?
11:53:05 <vixey> andyjgill: <<<
11:53:09 <vixey> andyjgill: or is it >>>
11:53:19 <sioraiocht> :t (>>>)
11:53:21 <lambdac> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
11:53:30 <sioraiocht> :t (<<<)
11:53:32 <lambdac> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
11:53:34 <andyjgill> I've got a chain of commands, and I they are conceptually backwards from type definition.
11:54:05 <andyjgill> This is old-fashioned  monad transformers.
11:54:34 <EvilTerran> ?type (Prelude..)
11:54:35 <andyjgill> And using & = flip (.) gives a neater mkFooT & mkBarT && mkRandT (...)
11:54:35 <lambdac> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:54:41 <mmorrow> dmhouse: wait, are you saying no sol exists even with (`div`10) ?
11:54:48 <EvilTerran> andyjgill, you want (>>>), i think
11:55:11 <andyjgill> But I do not want an arrow, or even a monad.
11:55:27 <sjanssen> andyjgill: functions are arrows
11:55:30 <dmhouse> mmorrow: no.
11:55:36 <EvilTerran> (>>>) :: (Arrow (~>)) => (b ~> c) -> (c ~> d) -> (b ~> d)
11:55:37 <sioraiocht> > (ord >>> chr) 'c'
11:55:38 <lambdac>  'c'
11:55:43 <mmorrow> ok, good. i'm on try maybe 400
11:56:01 <dmhouse> mmorrow: since my statement that a/b is integral iff all factors of b are factors of a obviously only applies with / and not `div`.
11:56:07 <andyjgill> Ahh. So functions are predefined instances.
11:56:13 <dmhouse> a `div` b is integral most of the time ;)
11:56:21 <EvilTerran> ?instances-importing Control.Arrow Arrow
11:56:21 <lambdac> (->), Kleisli m
11:56:51 <mmorrow> dmhouse: heh.
11:56:56 <Quadrescence> Does happy parse line-by-line?
11:58:05 <twobitwork> does haskell use machine native floating points for Fractionals?
11:59:41 <bd_> twobitwork: depends on the type. You could implement a Fractional instance based on church numerals if you wanted - but things like Float, Double, will use native fp
11:59:59 <mmorrow> Quadrescence: it parses taken by token
12:00:23 <mmorrow> s/taken/token/
12:00:48 <Quadrescence> mmorrow: And...hm, okay.
12:01:05 <bd_> twobitwork: heck, Rational doesn't use native fp (it represents an infinite-precision rational number, not a fixed precision fp)
12:01:07 <Quadrescence> So /n can be a token.
12:01:36 <mmorrow> and alex produces results token-by-token
12:01:52 <mmorrow> Quadrescence: if you define it to be, it is
12:01:59 <mmorrow> \n ;)
12:02:04 <Quadrescence> \, yeah
12:02:41 <Quadrescence> Okay. So I started in the more difficult spot with happy yesterday.
12:02:49 <Quadrescence> I better run over to alex.
12:03:28 <mmorrow> Quadrescence: check out these alex examples, http://darcs.haskell.org/alex/examples/
12:03:29 <lambdac> Title: Index of /alex/examples
12:03:39 <twobitwork> bd_: let me rephrase. "does _ghc_ use ..."
12:04:05 <mmorrow> this one is especially nice. i've used it as the template for a few alex lexers that i've written. http://darcs.haskell.org/alex/examples/haskell.x
12:04:17 <dmhouse> twobitwork: no, the correct rephrasing is s/Fractional/Float/.
12:04:25 <dmhouse> (And s/haskell/GHC/, I guess.)
12:04:36 <twobitwork> :t 4.0
12:04:38 <lambdac> forall t. (Fractional t) => t
12:04:44 <twobitwork> is that a Float?
12:04:50 <sjanssen> twobitwork: it could be
12:04:53 <dmhouse> Can be.
12:04:54 <Quadrescence> mmorrow: Oh, that is nice. :D
12:04:54 <mmorrow> :t 4.0 :: Float
12:04:56 <lambdac> Float
12:05:00 <mmorrow> :t 4.0 :: Double
12:05:01 <lambdac> Double
12:05:14 <sjanssen> twobitwork: numeric operations are overloaded -- meaning they work on many different types of numbers
12:05:18 <dmhouse> twobitwork: it's fromRational (4%1).
12:05:20 <sjanssen> > 4 :: Double
12:05:21 <lambdac>  4.0
12:05:23 <sjanssen> > 4 :: Float
12:05:24 <lambdac>  4.0
12:05:27 <sjanssen> > 4 :: Rational
12:05:28 <lambdac>  4%1
12:05:40 <Olathe> > 4 :: Complex
12:05:40 <twobitwork> :t 4.0 / 5.1
12:05:43 <lambdac>      `Complex' is not applied to enough type arguments
12:05:43 <lambdac>     Expected kind `?',...
12:05:44 <lambdac> forall t. (Fractional t) => t
12:05:55 <bd_> > 4 :: Complex Double
12:05:56 <lambdac>  4.0 :+ 0.0
12:05:56 <Olathe> > ? :: Complex
12:05:56 <twobitwork> was that math done using floats?
12:05:57 <lambdac>  Parse error at "::" (column 3)
12:06:02 <bd_> twobitwork: it depends
12:06:05 <Olathe> Ahh.
12:06:08 <twobitwork> ... in ghc
12:06:12 <Olathe> > 4 :: Complex Rational
12:06:12 <twobitwork> on x86
12:06:12 <bd_> twobitwork: it depends
12:06:12 <lambdac>        add an instance declaration for (RealFloat (Ratio Integer))
12:06:13 <lambdac>     In the...
12:06:23 <bd_> twobitwork: it depends on what type you ask it to be :)
12:06:25 <sjanssen> twobitwork: you didn't do any math -- you just checked the type
12:06:31 <bd_> > (4.0/5.1) :: Double -- probably using fp
12:06:32 <lambdac>  0.7843137254901962
12:06:37 <sjanssen> twobitwork: and the type is still overloaded
12:06:39 <bd_> > (4.0/5.1) :: Rational -- definitely not using fp
12:06:40 <lambdac>  40%51
12:06:54 <twobitwork> bd_: I'm talking about reality, on the machine... that math was performed by a processor... what form did the data take when given to the proc in that instance?
12:07:12 <sjanssen> twobitwork: however, if you use the concrete types Float or Double, GHC will use your processor's floating point features
12:07:17 <dmhouse> twobitwork: well, the defaulting mechanism probably uses Float.
12:07:17 <bd_> twobitwork: it depends on what type you ask it to be. The implementation of (/) will depend on the types of its arguments and result type.
12:07:28 <sjanssen> dmhouse: wrong, Double
12:07:39 <bd_> twobitwork: In my example with Rational, Rational is a software rational type using integers. Double, however, is done in hardware.
12:07:41 <twobitwork> dmhouse, sjanssen: thanks
12:07:48 <dmhouse> 4.0/5.1 is (fromRational 4.0) / (fromRational 5.1), i.e., still polymorphic.
12:08:15 <Olathe> > ((4.0/5.1) :: Double) :: Rational
12:08:25 <twobitwork> bleh... sometimes you haskell people kill me...
12:08:31 <lambdac>  thread killed
12:08:31 <dmhouse> (Since (/) :: Floating a => a -> a -> a.)
12:08:34 <Olathe> > ((4.0/5.1) :: Double) :: Rational
12:08:43 <dmhouse> :t 4.0 / 5.1
12:08:54 <mmorrow> Quadrescence: here's a darcs repo with a version of haskell.x that i added a few convenience functions to, and there's also a test main prog in there too: http://code.haskell.org/~morrow/code/haskell/hslex/
12:09:12 <Quadrescence> mmorrow: Thanks. :D
12:09:18 <mmorrow> Quadrescence: i added the "scan" function: http://code.haskell.org/~morrow/code/haskell/hslex/Lexer.x
12:10:01 <lambdac> Title: Index of /~morrow/code/haskell/hslex
12:10:02 <lambdac> forall t. (Fractional t) => t
12:10:03 <lambdac>  Couldn't match expected type `Rational'
12:10:11 <sjanssen> twobitwork: we were only answering your question honestly
12:10:39 <twobitwork> sjanssen: in a head-in-the-clouds way... I think my question was fairly straight forward
12:10:57 <twobitwork> I wanted to know if I needed to worry about floating point rounding errors
12:11:03 <mmorrow> twobitwork: haskell numbers are boxed
12:11:22 <bd_> twobitwork: That's a function of the type then - if you use Rational, you'll have no rouding, for example.
12:11:25 <sjanssen> twobitwork: but maybe you don't!
12:11:26 <Olathe> What does boxed mean there ?
12:11:36 <mmorrow> Double = D# Double#
12:11:44 <mmorrow> Double# there, is a machine double
12:11:46 <sjanssen> twobitwork: you can use Rational, or an exact real arithmetic type
12:11:49 <dmhouse> twobitwork: learn about the Rational type. It's like, awesome.
12:11:53 <Olathe> Ahh.
12:11:55 <bd_> Olathe: Probably 'the FPU's internal representation may be truncated in order to box and unbox it'
12:12:06 <mmorrow> Int = I# Int#
12:12:07 <Olathe> Eww.
12:12:09 <mmorrow> etc
12:12:11 <bd_> as at least on x86 the FPU internally uses a representation with greater precision than Double
12:12:21 <dmhouse> Olathe: it means that the internal representation is a pointer to the value, so that you can represent _|_ will a null pointer.
12:12:34 <sjanssen> twobitwork: this is exactly the point of our caveats, you can use the same operations on primitive types like Double and user defined types
12:12:50 <dmhouse> An unboxed type does not contain _|_.
12:12:50 <ski> dmhouse : ?
12:12:51 <Olathe> Ahh.
12:13:05 <dmhouse> ski: am I completely wrong?
12:13:05 <Olathe> That makes sense.
12:13:15 <twobitwork> sjanssen: yes I realize this... and I appreciate your rigor on the issue, but sometimes it can be hard to get you all to come down to earth and get a straight answer
12:13:15 <Olathe> It gives it an extra value for null.
12:13:23 <ski> dmhouse : at least generally, `_|_' can't be represented by null pointers
12:13:42 <sjanssen> twobitwork: you should have asked a more specific question
12:13:57 <ski> `I#' gives a lazy indirection, so you can represent unforced thunks
12:14:11 <ski> such thunks may semantically have value `_|_'
12:14:13 <twobitwork> sjanssen: I'll keep that in mind
12:14:25 <sjanssen> > exp ((0 :+ 1) * pi) :: Complex CReal
12:14:26 <lambdac>  (-1.0) :+ 0.0
12:14:46 <Olathe> > 5 :: Complex Uncomputable
12:14:46 <lambdac>   Not in scope: type constructor or class `Uncomputable'
12:14:54 <rwbarton> > 1 :: CReal == 1
12:14:54 <lambdac>  Parse error at "==" (column 12)
12:14:56 <Olathe> They really need to implement that.
12:14:57 <dmhouse> Oh, unforced thunks, not _|_. Sorry.
12:15:02 <rwbarton> > (1 :: CReal) == 1
12:15:03 <lambdac>  True
12:15:27 <ski> dmhouse : unforced thunks may represent `_|_' .. i was complaining about the `null pointer' bit
12:17:37 <rwbarton> what is CReal?
12:17:48 <dmhouse> ski: what is 'I#'? A specific unboxed constructor?
12:17:55 <Olathe> @src CReal
12:17:55 <lambdac> Source not found. stty: unknown mode: doofus
12:17:59 <ski> @src Int
12:17:59 <lambdac> data Int = I# Int#
12:18:22 <mmorrow> data Ptr a = Ptr Addr#
12:18:32 <mmorrow> nullPtr :: Ptr a
12:18:32 <mmorrow> nullPtr = Ptr nullAddr#
12:18:33 <ski> @kind GHC.Base.Int#
12:18:34 <lambdac> #
12:19:39 <dmhouse> ski: and Int# is something like Word32?
12:19:53 <mmorrow> Word#
12:20:03 <esteth> Why would a do block throw type errors at me? It seems as though everything in the do block has to evaluate to a list, but I'm sure I can use IO actions in do blocks. http://hpaste.org/9565 is the code/error
12:20:05 <mmorrow> Word8 = W8# Word#
12:20:09 <mmorrow> Word16 = W16# Word#
12:20:14 <mmorrow> Word32 = W32# Word#
12:20:16 <mmorrow> etc
12:20:37 <mmorrow> they all use the same size nachine word underneath
12:21:01 <dmhouse> esteth: depends which monad the do-block is in
12:21:19 <dmhouse> esteth: you can only do IO in an IO do-block.
12:21:26 <ski> esteth : maybe you wanted s/b <- transform xs/let b = transform xs/ ?
12:21:42 <dmhouse> (You still won't be able to do IO.)
12:21:47 <ski> esteth : mutatis mutandis for the `a', probably
12:21:49 <mmorrow> @src Word
12:21:50 <lambdac> Source not found. This mission is too important for me to allow you to jeopardize it.
12:21:51 <rwbarton> esteth: also maybe you wanted  haar :: (Num a) => [a] -> IO ()  ?
12:22:04 <ski> or
12:22:12 <ski>   haar :: (Num a) => [a] -> IO [a]  -- maybe
12:22:28 <mmorrow> dmhouse: check out http://darcs.haskell.org/libraries/base/GHC/Word.hs
12:22:34 <mmorrow> dmhouse: check out http://darcs.haskell.org/libraries/base/GHC/Int.hs
12:22:46 <dmhouse> esteth, If you want to do debugging IO, Debug.Trace
12:22:54 <ski> esteth : or maybe you just wanted to return a string from `haar' ..  who can tell ?
12:23:15 <esteth> rwbarton, Thanks, that's one mistake. dmhouse: How can I influence which monad i'm in?
12:23:41 <monochrom> By declaring types.
12:23:44 <esteth> ski: I don't understand what you mean. I want haar to do some stuff, then print a string. I'm just using it for debugging at the moment, though in the end it will be my main function
12:23:50 <dmhouse> esteth: it's the type of the eventual result.
12:24:27 <esteth> ah. So if I want to be able to putStrLn, my action needs to be haar :: ... -> IO () ?
12:24:54 <ski> esteth : in a `do'-block for the `IO' monad, each thing to the right of a `<-' should be an `IO'-action
12:25:05 <rwbarton> esteth: Yes, and also what ski said.
12:25:18 <ski> esteth : `sum xs / genericLength xs' and `transform xs' are not `IO'-actions
12:25:21 <dmhouse> esteth: ... -> IO a in general
12:25:30 <ski> you probably want to use `let' or `where' for those
12:25:37 <esteth> ski: Ahh, that makes it clear what I'm doing wrong :)
12:26:10 <ski>   let a = sum xs / genericLength xs
12:26:13 <ski>       b <- transform xs
12:26:19 <ski>   putStrLn $ (show a) ++ (show b)
12:26:22 <ski> er
12:26:28 <ski> s/b <-/b =/
12:26:33 <ski> would work, i think
12:26:55 <esteth> I was doing the average calculation first because I want to keep the average from the start, Not the average after the transform. Will it still work the same if I use a let block?
12:27:41 <rwbarton> ... what a is the average of is determined by what you take the average of.  transform doesn't modify anything.
12:28:32 <ski> esteth : since you compute average over `xs' instead of over `b', it will be the average of `xs', yes
12:28:34 <esteth> d'oh! I'm getting confused with my imperative brain trying to imperitivise everything
12:29:18 <Olathe> It's imperative that you stop that.
12:29:41 <Olathe> *vanishes in a puff of logic*
12:29:54 <dmhouse> esteth: you'll get used to it sooner or later. It just takes a while.
12:30:23 <monochrom> "vanish" is side-effecting.
12:30:51 <esteth> dmhouse, Olathe, ski, rwbarton: Thanks for the help :)
12:30:58 <rwbarton> No, Olathe just got garbage-collected when there were no consistent universes that referred to him
12:31:01 <Olathe> Heheh
12:31:17 <Olathe> I feel free.
12:31:31 <ski> rwbarton : oh no, our universe is inconsistent !
12:32:35 <Olathe> Hmm, that opens the possibility of proving everything.
12:36:16 <ski> (hm, depends on para-consistency ..)
12:38:14 <dmhouse> I wonder why Int8 has more negative numbers than positive ones.
12:39:45 <bd_> dmhouse: because that's how twos complement works :)
12:40:08 <bd_> there are a total of 2^8 values
12:40:08 <trofimovich> > (128 :: Int8 == 0 :: Int8)
12:40:09 <lambdac>  Parse error at "==" (column 14)
12:40:11 <bd_> one is taken for zero
12:40:23 <EvilTerran> > (128 :: Int8) == (0 :: Int8)
12:40:24 <lambdac>  False
12:40:24 <bd_> so we're left with an odd number to divide across positive and negative
12:40:30 <EvilTerran> > (128 :: Int8) == (-128 :: Int8)
12:40:31 <dmhouse> Oh, of course.
12:40:31 <lambdac>  True
12:40:47 * dmhouse just wasn't thinking about bits, for some reason.
12:41:04 <znutar> It's basically because having 0 be all 0's is nice and it makes sense to have one bit that tells you if it's positive or negative
12:41:30 <znutar> and people wanting zero to not be negative
12:41:54 <znutar> and wanting only one value for 0
12:41:56 <bd_> and people wanting to be able to use unsigned arithmetic circuits for signed arithmetic as well :)
12:55:28 <esteth> Does haskell have some kind of Image manipulation library? I'd like to load an image, read and write the value of some pixels in it, and save it again. I couldn't find any Image type in hoogle that seemed to be what I wanted
12:56:13 <dmhouse> esteth: have you tried hackage?
12:56:19 <dmhouse> http://hackage.haskell.org/packages/hackage.html
12:56:20 <lambdac> Title: HackageDB: introduction
12:56:41 <esteth> dmhouse, Nope. I'll have a look through there, thanks :)
13:03:01 <chrisdone> maybe cairo?
13:06:46 <esteth> hmm. Cairo might work. If I can find the documentation for it, that is :(
13:06:49 <lispy> Who is in charge of lambdabot these days?
13:06:59 <lispy> Do we have an estimate on her downtime?
13:07:05 <lispy> ?join #darcs
13:07:05 <lambdac> Not enough privileges
13:07:20 <dcoutts_> lispy: I think she's looking for a new host
13:07:21 <dmhouse> This isn't lambdabot.
13:07:34 <lispy> dcoutts_: Do you know why?
13:07:36 <dcoutts_> esteth: it's with the gtk2hs docs
13:07:44 <lispy> dcoutts_: I could host her
13:07:55 <dcoutts_> lispy: because she's too big for code.h.o, leaks too much memory.
13:07:59 <lispy> dcoutts_: and I've even be willing to give Cale shell
13:08:07 <dcoutts_> lispy: cool, talk to Cale
13:08:12 <Cale> oh?
13:08:31 <lispy> Cale: if it means having a reliable lambdabot again, I'll do what it takes
13:09:01 <lispy> Cale: but I do warn you, for backing up data, you're on your own (just use rysnc, maybe between my server and c.h.o)
13:09:17 <Cale> Well, c.h.o isn't running lambdabot for now.
13:09:56 <lispy> Cale: I just mean, for archive purposes so that if my server goes down your behind is covered
13:10:00 <Cale> yeah
13:10:18 <lispy> Cale: but what do you say?  You want an account?
13:10:32 <Cale> Sure, where should I send my public key?
13:34:28 <erikc> is there a common name for the domain of real numbers from -1 to 1
13:34:55 <lament> i don't think so
13:35:38 <lispy> I'm trying to install the ghc binary
13:35:39 <lispy> $ make install
13:35:39 <lispy> Makefile:2: Makefile-vars: No such file or directory
13:35:39 <lispy> make: *** No rule to make target `Makefile-vars'.  Stop.
13:35:49 <lispy> The INSTALL file says to run this command
13:36:08 <lispy> oh, I bet i need to run configuer
13:36:20 <lispy> yup that was it
13:37:10 <trofimovich> @pl \x -> if x=='?' then '!' else x
13:37:11 <lambdac> flip if' '!' =<< ('?' ==)
13:37:47 <lispy> Cale: you should be good to go
13:37:58 <lispy> Cale: ghc-6.8.3 is on there, should be in your path
13:38:06 <lispy> Cale: look in /usr/local if you can't find it
13:38:12 <trofimovich> @.  pl unpl \x -> if x=='?' then '!' else x
13:38:13 <lambdac> flip if' '!' =<< ('?' ==)
13:38:18 <trofimovich> @.  unpl pl \x -> if x=='?' then '!' else x
13:38:19 <lambdac> ((\ d -> '?' == d) >>= \ c -> if' c '!')
13:38:21 <paczesiowa> :t if'
13:38:23 <lambdac> Not in scope: `if''
13:38:28 <Cale> lispy: yep, it's there.
13:38:46 <Cale> lispy: I'll start by installing cabal-install in my user account, unless you want to do that globally.
13:39:03 <trofimovich> what the ` if' ' is?
13:39:09 <lispy> Cale: I'll do it globally, how do I do that?
13:39:19 <paczesiowa> > if'
13:39:20 <lambdac>   Not in scope: `if''
13:39:24 <trofimovich> @type if
13:39:26 <lambdac> parse error (possibly incorrect indentation)
13:39:41 <paczesiowa> @type if'
13:39:43 <lambdac> Not in scope: `if''
13:39:44 <lispy> Cale: actualy, I just realized, I shouldn't spend time on this.  Just do it for your account.
13:39:46 <chrisdone> @pl \x c e -> if x then c else e
13:39:46 <lambdac> if'
13:39:50 <chrisdone> :t \x c e -> if x then c else e
13:39:52 <lambdac> forall t. Bool -> t -> t -> t
13:39:59 <lispy> Cale: but if you do need me to install something don't hesitate to ask
13:40:13 <Cale> lispy: okay :)
13:40:23 <trofimovich> > if' True 'a' 'b'
13:40:24 <lambdac>   Not in scope: `if''
13:40:37 <dcoutts_> lispy: cabal-install is pretty easy to do per-user, it's setup to do that by default. There's not much to gain by doing it globally.
13:40:41 <chrisdone> @let if = \x c e -> if x then c else e
13:40:42 <lambdac>  Parse error
13:40:46 <chrisdone> @let if' = \x c e -> if x then c else e
13:40:46 <lambdac> Defined.
13:41:07 <trofimovich> you 've cheated! :]
13:41:10 <chrisdone> :P
13:41:28 <trofimovich> > if' True 'a' 'b'
13:41:29 <lambdac>  'a'
13:41:37 <trofimovich> @src if'
13:41:38 <lambdac> Source not found. Where did you learn to type?
13:41:51 <trofimovich> strange sources
13:42:19 <Pudding> @paste
13:42:19 <lambdac> Haskell pastebin: http://hpaste.org/new
13:42:56 <lelf> > if' True if' if' False if' if' True True False
13:42:57 <lambdac>  True
13:43:19 <trofimovich> @pl if' True if' if' False if' if' True True False
13:43:20 <lambdac> if' True if' if' False if' if' True True False
13:43:48 <Pudding> http://hpaste.org/9566?lines=true    ----> Anyone knows what that error means?
13:45:24 <paczesiowa> s/:/++/g
13:45:36 <trofimovich> [v] -> :v: ?
13:46:01 <paczesiowa> Pudding: try ++ instead of :
13:46:50 <monochrom> Yes, ++
13:47:01 <BMeph> Pudding: paczesiowa got it. :)
13:47:22 <Pudding> trofimovich, without the square brackets didn't work either, so I added those and forogt to remove them.
13:47:35 <Pudding> <paczesiowa>: thanks, I'll try that out :)
13:47:44 <trofimovich> why ? (flatten l) ++ v:flatten r
13:47:59 <trofimovich> (not sure on the op precedense)
13:48:05 <monochrom> or, (flatten l) ++ [v] ++ flatten r
13:48:17 <trofimovich> which is faster? :]
13:48:24 <monochrom> The parentheses ( ) are optional.
13:48:31 <Pudding> what does the flatten do?
13:48:43 <monochrom> s/flatten/tree2list
13:48:44 <trofimovich> it's your tree2list
13:48:58 <BMeph> flatten = concat
13:49:04 <monochrom> We don't know which is faster.
13:49:08 <trofimovich> @type flatten
13:49:10 <lambdac> forall a. Tree a -> [a]
13:49:15 <sjanssen> trofimovich: the (:) is probably faster, but it shouldn't matter in a decent compiler
13:50:09 <trofimovich> `++ [v]' is optimized to list constructor call (and more)?
13:50:15 <Pudding> the thing with the ++ worked. Gonna try out the flatten thingies. Thanks already :)
13:50:18 * trofimovich 'd like to test it
13:50:50 <chrisdone> > let foo = last . nub . ("?!"++) . return in foo '!' -- \x -> if x=='?' then '!' else x
13:50:51 <lambdac>  '!'
13:50:59 <chrisdone> > let foo = last . nub . ("?!"++) . return in foo '?' -- \x -> if x=='?' then '!' else x
13:51:00 <lambdac>  '!'
13:51:03 <sjanssen> trofimovich: actually, the inefficient part is "[v] ++ " vs. "v :"
13:51:07 <paczesiowa> > '!'
13:51:08 <lambdac>  '!'
13:51:23 <trofimovich> sjanssen: oh yes, i've mistyped
13:51:40 <sjanssen> I bet GHC makes that optimization
13:51:47 <lispy> :t foldr
13:51:50 <lambdac> forall a b. (a -> b -> b) -> b -> [a] -> b
13:51:54 <trofimovich> how to dump ghc's output simply?
13:52:05 <trofimovich> i know only -S :]
13:52:16 <sjanssen> -ddump-simpl
13:53:19 <sjanssen> f x xs = [x] ++ xs
13:53:27 <sjanssen> X.f = GHC.Base.:
13:53:27 <Pudding> so when I used to : operator, I was actually making a list of lists?
13:53:31 <sjanssen> ghc++
13:53:34 <Pudding> to -> the
13:53:36 <Heffalump> should it be possible for me to get a GHC (time) profile in which y occurs immediately inside x (i.e. on the next line and indented a bit more in the long list), but y is neither lexically contained within x nor called by x?
13:54:08 <lispy> Heffalump: you can add custom cost centers
13:54:11 <lispy> Heffalump: is that what you want?
13:54:39 <Heffalump> sorry, my question is about the fact that I'm seeing y inside x when my reading of the documentation tells me that it isn't possible
13:54:39 <lispy> you insert a special comment and it creates a cost center riht there
13:54:52 <Heffalump> I'm aware of custom SCCs, there aren't any present in the profile in question
13:55:10 <sjanssen> Pudding: sort of.  What you were doing doesn't type check, so it doesn't really make sense at all
13:55:24 <lispy> Heffalump: oh, others have reported similar stuff.  I don't recall if that's happened to me before, but it seems like the accounting could always be sloppy wrt to things like aggressive linining
13:55:29 <lispy> er in-lining
13:55:44 <sjanssen> if Haskell weren't statically typed, you'd probably end up with a variably nested list
13:55:57 <Heffalump> ok. Though this was without optimisations, but I guess some inlining can still happen.
13:56:07 <Pudding> k
13:56:09 <Heffalump> It's kind of odd, because the two are really very far separated.
13:56:26 <Heffalump> But it wouldn't surprise me at all if x *demanded* a thunk in y.
13:56:38 <Heffalump> But my reading of the docs is that it's all about static call sites, not lazy demand.
14:00:14 <trofimovich> @help let
14:00:15 <lambdac> let <x> = <e>. Add a binding
14:00:25 <trofimovich> how to remove a binding?
14:00:44 <trofimovich> @help unlet
14:00:45 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
14:03:46 <rwbarton> @help undefine
14:03:46 <lambdac> undefine. Reset evaluator local bindings
14:04:01 <Pudding> http://hpaste.org/9567    Why does that code work? The amount of arguments in the second line isn't the same as the amount of arguments in the signature.
14:04:57 <rwbarton> Pudding: Does it help to imagine the type signature as (a -> b -> b) -> b -> (Tree a -> b) ?
14:05:35 <Pudding> that would explain, thanks :).
14:05:57 <Pudding> sorry for the silly questions. I'm new at all this haskell stuff.
14:07:43 <BMeph> Pudding: We can tell - once you get into it, you'll ask MUCH sillier questions than those, heh-heh. :)
14:07:50 <Cale> Pudding: yeah, all functions in Haskell really only have one parameter :)
14:08:16 <Cale> Pudding: Those that pretend to have more parameters really just return other functions after being applied to the first.
14:08:45 <Pudding> Cale, good to know :)
14:09:02 <Pudding> BMeph: so I better quit haskell before things get worse then :P
14:10:53 <BMeph> Pudding: Too late; you're in #haskell, your only choice is to go forward, now... :)
14:12:48 <trofimovich> yep
14:13:14 <Pudding> can't......quit........chatroom!
14:13:30 <Pudding> must.....pull......power..plug
14:13:30 <gwern> you are in a maze of twisty unary functions, all alike. It is dark.
14:14:32 <BMeph> gwern: You are in a maze of twisty unary functions, all alike. It is dark. There is a lambda here. ;)
14:14:50 * zachk passes one tasty argument to the lambda 
14:15:00 <trofimovich> @pl \x -> x x
14:15:00 <lambdac> join id
14:15:02 <gwern> hm. wasn't it 'It is dark. You are likely to be eaten by a grue.'?
14:15:14 <trofimovich> @pl \x -> x x x
14:15:14 <lambdac> join (join id)
14:15:28 <trofimovich> > id x
14:15:30 <lambdac>  x
14:15:46 <trofimovich> @src join
14:15:46 <lambdac> join x =  x >>= id
14:16:52 <trofimovich> @let fork = join id
14:16:54 <lambdac> <local>:14:12:     Occurs check: cannot construct the infinite type: a = a ->...
14:31:44 <zachk> monadic confusion http://hpaste.org/9568
14:32:38 <olsner> maybe you want a function Net a -> IO a that you can apply to startClient before passing it into forkIO
14:33:55 <olsner> (but I don't know where the Net monad comes from, so I really can't say what's the proper solution)
14:34:20 <zachk> its from the roll your own irc bot tutorial...need link?
14:41:28 <dons> gwern: http://protempore.net/rdf4h/ please.
14:42:45 <dons> http://www.ninebynine.org/Software/HaskellRDF/RDF/Harp also
14:42:46 <lambdac> Title: Index of /Software/HaskellRDF/RDF/Harp
14:44:35 <dons> go Igloo http://www.reddit.com/comments/6w1t3/darcs_2_patch_theory_formally/
14:44:37 <lambdac> Title: Darcs 2 patch theory: formally : reddit.com, http://tinyurl.com/5brnco
14:50:59 <sw17ch> say i have a function f :: a -> b
14:51:20 <sw17ch> is there a way to ... check what b is inside the function?
14:51:34 <sw17ch> check the type, or do a case on it
14:52:09 <ddarius> No.
14:52:29 <ddarius> If you had f :: (Typeable a, Typeable b) => a -> b then you could.
14:52:44 <ddarius> (Well, all you'd need is Typeable b in this case)
14:53:28 <sw17ch> ddarius, that might be all i need, quicksilver will tell me i'm doing something wrong again, but i'll ask him later :)
14:53:54 <ddarius> In his stead, you are probably doing something wrong.
14:55:54 <dmhouse> sw17ch: what are you trying to do, then?
14:56:46 <cnwdup> Does anyone have a link to documentation about using Data.Dynamic? I am not quite sure whats possible with that. For instance can I pattern match against the Typeable's type wrapped in a Dynamic? Or can I extract the type's representation from a Dynamic without risking an exception?
14:57:28 <sjanssen> cnwdup: dynTypeRep?
14:57:45 <sjanssen> > dynTypeRep (toDyn ())
14:57:46 <lambdac>  ()
14:57:58 <cnwdup> sjanssen: Yeah, that seems to be it. But I can't match against that.
14:58:05 <cnwdup> > dynTypeRep (toDyn ()) == ()
14:58:05 <lambdac>  Couldn't match expected type `TypeRep' against inferred type `()'
14:58:06 <sjanssen> > dynTypeRep (toDyn ()) == typeOf ()
14:58:07 <lambdac>  True
14:58:17 <cnwdup> sjanssen: That's what I was looking for. Thank you. (-:
14:58:38 <Trinithis> Is lambdac the new lambdabot?
14:59:11 <dmhouse> It's a temporary one.
14:59:23 <olsner> lambdabot is always lambdabot, she is eternal!
14:59:36 <dmhouse> lambdabot took up too much RAM on its host (code.haskell.org) due to space leaks left, right and centre.
14:59:46 <dmhouse> I believe there was an offer of another server earlier today.
15:00:04 <newsham> hmm.. space leaks in the bot?
15:00:18 <newsham> why not just have it restart every week?
15:00:33 <newsham> any ideas what is leaking?
15:00:57 <dmhouse> Ask Cale.
15:01:15 <Cale> I don't know.
15:01:37 <sjanssen> nobody understands lambdabot in her entirety
15:03:07 <newsham> wow, big diff.. i restarted my bot and it went from 48M resident to 15M resident (64M total/ 28M)
15:03:12 <dons> i'm not sure it's not a "leak by design"
15:03:17 <dons> since it keeps a full history of the channel
15:03:33 <newsham> dons: not just in the State/Log files?
15:04:19 <dons> no, in memory.
15:04:26 <sjanssen> dons: what is the purpose of that?
15:04:32 <dons> no one knows.
15:04:59 <sjanssen> dons: is it in a plugin?  Can you point vaguely where it happens?
15:05:55 <dons> hmm, been 18 months since i looked at the bot.
15:07:33 <sjanssen> yes, Plugin.Log looks like a big potential leaker
15:07:43 <sjanssen> Cale: perhaps you should try disabling it?
15:08:27 <dmhouse> newsham: hah, I restart my Firefox about twice a day to drop it down from 250MB + 350 swap -> 80MB + 40 swap or thereabouts.
15:08:29 <Cale> sjanssen: I will.
15:08:59 <newsham> ?last sjanssen
15:09:00 <lambdac> No module "sjanssen" loaded
15:09:09 <sbahra>    (:),                -- Not legal Haskell 98
15:09:15 <sbahra> From Prelude.hs
15:09:22 <dmhouse> On a machine with 512MB RAM, this is No Fun. Throw in XP to the deal, you've got yourself a frustrating work machine.
15:09:30 <sbahra> What do they mean, (:) is not legal (according to spec)?
15:09:40 <sbahra> In prefix notation?
15:09:43 <sbahra> or..?
15:09:44 <sjanssen> sbahra: (:) is a specially reserved token
15:09:44 <dmhouse> sbahra: you can't use (:) as a constructor.
15:09:52 <sbahra> ah
15:10:07 * ddarius uses Firefox on Ubuntu an a laptop with 512 or 256MB of RAM (I don't remember which) and I don't seem to have these problems often.
15:10:30 <ddarius> Didn't seem to have them under XP either, but I forget what my usage pattern was.
15:10:32 <olsner> heh, if lambdabot keeps an in-memory log of *everything* it sees, no wonder it's growing in memory use
15:10:41 <newsham> Plugins/Log.hs has a bunch of commented-out commands dealing with the log
15:10:50 <newsham> and stuff for collecting state
15:11:02 <dmhouse> ddarius: my home laptop, Ubuntun with 512MB RAM, doesn't have these problems.
15:11:09 <dmhouse> I think it's a leaky extension, anyway.
15:11:58 <ddarius> dmhouse: Yeah.  Most of my issues with firefox come from the freakin' flash plugin.
15:12:07 <olsner> (otoh, my #haskell logs for a month or so are only about 5MB, so maybe it's not that after all)
15:12:29 <newsham> yah but you dont store them as haskell strings :)
15:12:31 <sjanssen> newsham: yes, on a closer look I think the leaky bits might be disabled
15:12:39 <newsham> also lambdabot isnt a one-channel kinda gal
15:12:54 <sjanssen> newsham: but I'm having a hard time divining the meaning behind the code
15:13:30 <newsham> sjanssen: i'm not so sure.. there is actual log data written out to State/Log/*
15:13:36 <newsham> isnt that from Log.hs?
15:15:27 <dmhouse> olsner: are you online all the time?
15:15:28 <sjanssen> newsham: yes, you're right
15:15:38 <sjanssen>   modifyMS (M.adjust (\(CS hdl ds his) -> CS hdl ds (his ++ [e])) c) -- amateur hour
15:16:08 <olsner> dmhouse: hmm, well, now that you mention it I guess I'm probably offline more than online, and certainly in fewer channels than \bot
15:16:33 <sbahra> Who would I talk to have lambdabot join a channel?
15:16:46 <sbahra> If it's that easy :-P
15:16:54 <newsham> sbahra: darcs and ghc would be one option
15:17:17 <dons> http://www.reddit.com/comments/6w1y4/html_scraping_in_haskell_with_tagsoup/ nice.
15:17:19 <lambdac> Title: HTML scraping in Haskell with TagSoup : reddit.com, http://tinyurl.com/5eqgho
15:17:23 <dmhouse> newsham: ?
15:17:24 <sjanssen> sbahra: Cale if you want lambdabot to always join that channel
15:17:29 <sbahra> newsham, unfortunately, any dedicated servers I own are on networks which don't allow IRC
15:17:43 <sbahra> Cale, if you have time, mind adding #not-##FreeBSD?
15:17:54 <dmhouse> newsham: oh, disregard that. I just realised what you mean.t
15:18:14 <zachk> yay i figured it out
15:18:33 <dmhouse> Woah, C-x ESC ESC is amazing.
15:18:42 * sjanssen wonders if we can blame dmhouse for this code :)
15:19:04 <dmhouse> sjanssen: me? Which code?
15:19:11 <olsner> dmhouse: hacking emacs?
15:19:18 <newsham> does darcs have a blame cmd?
15:19:27 <sjanssen> dmhouse: you're the last person listed in lambdabot's Plugin.Log copyrights
15:19:34 <dmhouse> Eek.
15:19:36 <sjanssen> dmhouse: did you write @last support?
15:19:43 <dmhouse> ?help ?last
15:19:43 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
15:19:47 <dmhouse> ?help last
15:19:47 <lambdac> help <command>. Ask for help for <command>. Try 'list' for all commands
15:19:53 <olsner> @seen dmhouse
15:19:53 <lambdac> dmhouse is in #haskell-blah and #haskell. I last heard dmhouse speak 7s ago.
15:19:55 <dmhouse> sjanssen: I can't remember, what does it do?
15:19:57 <olsner> that one?
15:20:16 <sjanssen> dmhouse: dumps the last few messages sent to a channel
15:20:17 <newsham> olsner: there are commented out commands for retrieving info from the bot's history
15:20:29 <dmhouse> sjanssen: hmm. I don't think so, although I remember hacking on it.
15:20:30 <olsner> oh, I see
15:21:24 <dmhouse> sjanssen: it's been a while. I can't even find my local lambdabot repo, which is a bit weird.
15:21:45 <dmhouse> I think the only features I wrote were ?tell/?ask/?messages and ?instances/?instances-importing
15:21:55 <sjanssen> dmhouse: it's no big deal -- the date of your copyright is 3 years ago, after all
15:22:18 <dmhouse> 3 years?! I've not been writing Haskell that long, surely.
15:22:28 <sjanssen> Copyright (c) 2005 David House <dmouse@gmail.com>
15:22:53 <dmhouse> I have a feeling it was 06. Let's see when the IRC logs start.
15:24:05 <dmhouse> Hmm, nothing before 2007, but that's probably because I was using a different IRC client or something.
15:24:44 <noteventime> How would I declare List to be an instance of a class?
15:24:52 <sjanssen> well, unless you didn't know what year it was ...
15:24:56 <dobblego> instance C [] wher
15:25:07 <dobblego> e
15:25:14 <sjanssen> noteventime: which class?
15:25:52 <noteventime> sjanssen: I write a type class (as an example to a Haskell-illiterate friend), and now I want to make [] an instance of it
15:25:54 <dmhouse> sjanssen: actually, no, it must be three years now. That's scary.
15:26:16 <noteventime> dobblego: Really, I must have made some other mistake then
15:26:36 <dobblego> noteventime, let's see what you have got so far (hpaste)
15:26:38 <sjanssen> noteventime: well, dibblego's answer might be wrong depending on the class
15:26:59 <noteventime> dobblego: One moment, I think it may just be a typo
15:27:01 <dobblego> depending on the question
15:27:51 <noteventime> dobblego: Ahh, never mind, thanks anyway :)
15:27:58 <dobblego> noteventime, you figured it out?
15:28:13 <noteventime> dobblego: Yes, as usual, it was just a typo
15:28:17 <dobblego> ok
15:28:26 <noteventime> Thanks anyway though :)
15:28:29 <dobblego> np
15:29:19 <zachk> http://hpaste.org/9568#a1 fixed!
15:50:43 <Cale> Is it just me, or is Hackage being really slow?
15:51:14 <dobblego> slow for me
15:51:17 * luqui interprets "Is Cale being fast, or is Hackage being slow?"
15:53:15 <Quadrescence> Are "literal strings" in regex/Alex not denoted by anything?
16:00:13 <dons> Cale: i'm getting 30k/s
16:00:56 <luqui> is it possible to safely maybeReadMVar; i.e. return Nothing if it's empty, and Just a if it's not, but not take it?
16:01:32 <Cale> dons: hmm... I'm getting basically nothing from my machine and from lispy's.
16:01:43 <Cale> dons: Occasionally I'll get a bit.
16:02:03 <luqui> do { empty <- isEmptyMVar v; if empty then return Nothing else fmap Just (readMVar v) } -- doesn't work, since it could be taken in between the check and the read
16:02:12 <lispy> Cal	what?
16:02:29 <Cale> lispy: Just having trouble getting things from hackage.
16:02:41 <lispy> Cale: oh I see, you used my server to benchmark the connection.  Good idea.
16:02:41 <Cale> oh, there we go
16:02:45 <Cale> It just went :)
16:02:52 <dons> i'll try from another machine.
16:03:09 <lispy> Cale: *.h.o has given me unreliable and flaky connections for quite some time
16:03:31 <dons> i'm getting 8.5k/s from australia to hackage.
16:03:47 <lispy> I want to say over the last year I haven't really worried about failures and transfer speeds with those servers...as in I'm not really tursting them
16:04:01 <lispy> (I just retry until things work)
16:04:15 <paczesiowa> poor martians:-(
16:04:48 <dobblego> there are a couple of list functions that operate specifically on pairs; what are they?
16:05:01 <Cale> dobblego: zip and unzip?
16:05:18 <Cale> :t mapAccumL
16:05:18 <dobblego> hrm, wasn't thinking of that
16:05:19 <lambdac> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:05:24 <Cale> :t mapAccumR
16:05:25 <lambdac> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:05:32 <paczesiowa> :t unfoldr
16:05:34 <lambdac> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:05:43 <dobblego> lookup!
16:05:56 <dobblego> I was thinking lookup
16:05:57 <dobblego> :)
16:05:59 <Cale> ah...
16:06:04 <lispy> lookup is an assoc list if you're lisp familiar
16:06:27 <Cale> lookup is something to be avoided if you care at all about performance
16:06:43 <dobblego> yeah I know, cheers
16:07:03 <ptolomy2> I am playing with a home-made web server that streams out larger stuff by (mapM_ (hPutStrLn h) line).. and everything dies when I kill the client prematurely. I've put 'catch' here and there, but I rarely get anything other than the death of the program without any info.
16:07:25 <ptolomy2> I assume this is due to lazy writing failing after the context has been exited or something.
16:07:30 <dons> ptolomy2: you want to catch the kill signal?
16:07:38 <ptolomy2> Hm. Probably should.
16:07:49 <dons> note that signals are different to the execption handling handle/catch do
16:07:58 <dons> you have to turn unix signals into exceptions.
16:08:19 <dons> by registering a signal handler (using the unix package), and translating incoming signals into exceptions thrown to the main thread
16:08:37 <Cale> ptolomy2: also, writing isn't done lazily.
16:08:53 <dons> that too :)
16:09:05 <Cale> (there's no way to do it lazily, if you think about it -- it must force the evaluation of the things you're printing)
16:09:10 <dons> what would it wait on? the observer reading the line...  :)
16:09:14 <ptolomy2> Heh.
16:09:15 <ptolomy2> True.
16:09:33 <dons> delay until the readers brain beings parsing the output image.
16:09:55 <Cale> heh
16:16:30 <sbahra> Cale, hm, a friend of mine provided a shell I could run lambdabot off of.
16:16:46 <sbahra> Cale, meaning I am retracting that earlier request.
16:17:18 <Cale> sbahra: hmm?
16:17:58 <Cale> I'm in the process of setting up lispy's machine for use as a lambdabot server right now :)
16:18:23 <lispy> sweet!
16:19:05 <lispy> maybe we could even get the lambdabot web interface working again at some point using the official lambdabot instance
16:19:05 <Cale> lispy: Could you install zlib1g-dev
16:19:06 <Cale> ?
16:19:09 <lispy> sure
16:19:23 <sbahra> Cale, any chance you could have it join #not-##FreeBSD?
16:19:31 <Cale> sbahra: sure
16:19:55 <lispy> Cale: done
16:20:27 <Cale> oh, also libgmp3-dev
16:20:37 <sbahra> Cale, thanks
16:20:39 <Cale> and libgmp3c2 if that isn't automatic
16:21:24 <lispy> Cale: it was automatic this time
16:21:27 <Cale> okay
16:21:37 <Cale> hmm
16:21:44 <Cale> ldconfig ?
16:21:54 <Cale> I'm still getting /usr/bin/ld: cannot find -lgmp
16:22:02 <lispy> huh
16:22:13 <lispy> Shouldn't gmp come with the ghc we installed?
16:22:14 <sbahra> Out of curiosity. Why don't you allow people to PM lambdabot commands?
16:22:22 <Cale> sbahra: We do.
16:22:24 <lispy> Cale: Maybe we shouldn't use a fedora core build
16:22:30 <sbahra> Cale, ah, amazing
16:22:39 <Cale> lispy: Well, that one normally works...
16:22:58 <Cale> lispy: This is an error from ld, rather than ghc.
16:23:16 <Cale> (it doesn't come with GMP since that's under the LGPL, and it's under BSD)
16:23:21 <lispy> Cale: this is odd, ldconfig complains it cant create a cache in /etc
16:23:30 <Cale> lispy: you're running it as root?
16:23:31 <lispy> Cale: does ldconfig require super user?
16:23:33 <Cale> yes
16:23:38 <lispy> huh, okay
16:23:50 <lispy> okay, I ran it
16:24:12 <lispy> Cale: BTW, what is failing?
16:24:24 <Cale> Linking the Haskell binding to zlib
16:25:20 <Cale> /usr/bin/ld: cannot find -lgmp
16:25:20 <Cale> collect2: ld returned 1 exit status
16:25:20 <Cale> linking dist/build/Codec/Compression/Zlib/Stream_hsc_make.o failed
16:25:20 <Cale> command was: /usr/local/bin/ghc -optl-lz dist/build/Codec/Compression/Zlib/Stream_hsc_make.o -o dist/build/Codec/Compression/Zlib/Stream_hsc_make
16:25:22 <lispy> any luck after I updated the ldconfig?
16:25:26 <Cale> nope
16:25:33 <Cale> I'll try setting LD_LIBRARY_PATH
16:26:13 <Cale> hmm, that didn't work
16:26:16 <lispy> Cale: if you think installing your own copy of ghc from source would be easier, feel free to do so. I have plenty of diskspace
16:26:38 <Cale> I doubt it has anything to do with ghc itself, given the error.
16:26:48 <lispy> Cale: I have other things built by ghc on there, can i run a command on them to find out where -lgmp is located?
16:27:17 <Cale> lrwxrwxrwx 1 root root     15 2008-06-11 23:04 /usr/lib/libgmp.so.3 -> libgmp.so.3.4.2
16:27:17 <Cale> -rw-r--r-- 1 root root 258928 2008-04-09 00:23 /usr/lib/libgmp.so.3.4.2
16:27:24 <Cale> It's there...
16:27:33 <Cale> I'm not sure why ld isn't finding it...
16:27:53 <lispy> libgmp.so.3 => /usr/lib/libgmp.so.3
16:27:58 <lispy> That's what darcs is using
16:28:11 <SamB> uh, well, do you not have a libgmp.so ?
16:28:18 <Cale> oh!
16:28:31 <SamB> I have one
16:28:47 <Cale> no, it's not there.
16:29:15 <lispy> Cale: try now
16:29:35 <Cale> Now it works :)
16:29:36 <lispy> Cale:  I made a symlink from named libgmp.so to libgmp.so.3
16:29:41 <Cale> yeah
16:29:57 <lispy> cool
16:30:01 <paczesiowa> go fedora!
16:30:06 <lispy> I bet that's a difference betwene debian and federa
16:30:10 <lispy> fedora*
16:30:24 <Cale> I wonder...
16:30:25 <lispy> Cale: so watch if you get other ld errors :)
16:30:27 <SamB> lispy: what are you using?
16:30:32 <lispy> SamB: debian
16:30:39 <lispy> lenny, actually
16:30:43 <SamB> lrwxrwxrwx 1 root root     15 2008-07-06 15:30 /usr/lib/libgmp.so -> libgmp.so.3.4.2
16:30:43 <SamB> lrwxrwxrwx 1 root root     15 2008-07-06 15:30 /usr/lib/libgmp.so.3 -> libgmp.so.3.4.2
16:30:43 <SamB> -rw-r--r-- 1 root root 273608 2008-04-09 02:43 /usr/lib/libgmp.so.3.4.2
16:30:43 <SamB> naesten@hydrogen:~/hacking/haskell/ghc%
16:30:45 <Cale> The generic linux binary ought to work on any linux.
16:30:52 <Cale> (basically)
16:30:53 <SamB> oh, oops, that last one wasn't meant to be pasted
16:31:45 <sbahra> hacker
16:33:03 <SamB> sbahra: what do you call it?
16:33:28 <SamB> % ldd /usr/lib/ghc-6.8.2/ghc-6.8.2
16:33:29 <SamB> ...
16:33:29 <SamB> 	libgmp.so.3 => /usr/lib/libgmp.so.3 (0xb7e38000)
16:33:29 <lispy> SamB: ~/local-data
16:33:58 <lispy> SamB: I divide my stuff up by ~/local-data and ~/public_*
16:34:28 <lispy> I don't know why I picked those names...
16:35:54 <sbahra> SamB, ~/development (projects that I do not care to complete) and ~/work (projects that are completed)
16:36:17 <SamB> sbahra: where do you put stuff you haven't finished yet but wish to?
16:36:46 <sbahra> SamB, then ~/work is split up into academic things, contract work and a separate directory for every company I'm dealing with
16:37:04 <sbahra> SamB, development, unless it is important I finish it.
16:37:14 <sbahra> SamB, in which case it goes to work/.
16:43:16 <TomMD> sbahra: Contracted Haskell work?
16:44:31 <lispy> sbahra: I think our setups are roughly isomorphic.  My local-data ~= your development, my public_* ~= your work
16:44:47 <lispy> But, I would replace "completed" with "released"
16:46:16 <tehgeekmeister> would unzipping a bzip2 compressed file on the fly be a bottleneck to how fast it could be read, or is the unzipping generally faster than disk io?
16:46:43 <sbahra> TomMD, no. I barely know Haskell :-P
16:47:21 <lispy> tehgeekmeister: That's a good question.  I bet these days that it would be IO dominated
16:48:13 <lispy> tehgeekmeister: a faster, but weaker, compression like zlib might be better
16:48:25 <lispy> tehgeekmeister: that is if you want to ensure it's IO dominated
16:48:48 <tehgeekmeister> lispy: it's already compressed bzip2
16:48:54 <tehgeekmeister> lispy: but that would be a lot better, yes
16:51:38 <gwern> FWIW, from what I remember bunzipping XML dumps of Wikipedia, it's IO dominated on fast computers
16:51:59 * gwern cannot remember the cpu being pegged
16:52:28 <gwern> 'bzip2 is known to be quite slow at compressing, making people opt for alternatives such as gzip when time is an issue. This problem is asymmetric, as decompression is relatively fast.'
16:55:00 <TomMD> sbahra: Thats a shame, _nobody_ does Haskell work on contract.   *ducks*
16:55:06 <dons> hah
16:55:09 <SamB> gwern: eh?
16:55:15 <SamB> such is not my experience
16:55:20 <lispy> ?seen _nobody_
16:55:20 <lambdac> I haven't seen _nobody_.
16:55:44 <gwern> TomMD: there are consultants, if that's what you mean
16:55:54 <SamB> ... well, probably the last time I really tried was with a 450 MHz PII, but still
16:56:22 <TomMD> gwern: I'm being silly, which is normal for me.
16:57:21 <SamB> of course, I'm thinking more of tarballs than XML dumps
16:57:29 <SamB> that might make a difference ;-)
16:57:50 <Riastradh> *Anything* XML-related is going to be seriously I/O bound.
16:57:55 <jeffz> I find the parallel version of bzip2 to be faster than gzip :)
16:58:04 <Cale> lispy: libreadline this time
16:58:18 <TomMD> jeffz: Not everyone runs their bzip2 algorithm on a larrabee.
16:58:28 <gwern> personally, I wouldn't really care - it's not like one decompresses and compresses very often. space savings are nice tho
16:58:47 <SamB> TomMD: indeed -- they don't come out until, what, 2009?
16:59:01 <tehgeekmeister> gwern: thanks, that's very good to know
16:59:33 <TomMD> SamB: If Intel investors are lucky, yes.  What I want to know is - will the Haskell GPGPU work work on the larrabee some day.
17:00:44 <Cale> lispy?
17:00:51 <lispy> Cale: working on it :)
17:00:54 <TomMD> I'd like to see more GPGPU work in type safe languages and preferably with reasonable IO - the current offerings have really bad IO.  Perhaps I should look at the OCaml community?
17:00:58 <Cale> lispy: okay :)
17:00:58 <SamB> TomMD: you mean it isn't just a bunch of x86s and some RAM on a card?
17:01:29 <TomMD> SamB: I'm sure Intel will find time to make some incompatible changes to keep software developers jumping.
17:01:56 <lispy> Cale: go for it!
17:02:24 <dons> TomMD: what do you want to do? gpgpu programming?
17:02:31 <gwern> @seen Igloo
17:02:31 <lambdac> Igloo is in #haskell. I don't know when Igloo last spoke.
17:03:06 <dons> TomMD: since that's interesting, because so do we. :)
17:03:08 <mauke> preflex: seen Igloo
17:03:08 <preflex>  Igloo was last seen on #ghc 35 minutes and 6 seconds ago, saying: You might want "catches" in the new Exception library
17:04:12 <TomMD> dons: no, no - I'm not looking at doing GPGPU programming myself... but now that you mention it, I do know people who are very interested in GPGPU work IF they can get really good IO for streaming data.
17:04:15 <Cale> lispy: I wonder where gmp.h is... it's looking for it
17:04:31 <tehgeekmeister> trying to configure/build any cabal packages i'm getting this error: can't load .so/.DLL for: dl (libdl.so: cannot open shared object file: No such file or directory)
17:04:33 <lispy> Cale: I can intall gmp-dev, but what is it needed for?
17:04:45 <tehgeekmeister> however, when i strace it i don't find it trying to open libdl at all
17:04:53 <Cale> /usr/local/lib/ghc-6.8.3/include/Regs.h:28:17:
17:04:53 <Cale>      error: gmp.h: No such file or directory
17:05:02 <dons> TomMD: yeah, we know some interested people too. maybe we should get them talking to each other.
17:05:18 <dons> that cpu marshalling overhead is an interesting problem.
17:05:35 <lispy> Cale: try again
17:05:53 <TomMD> And it can be frustrating.  It would be even better if you could cut the CPU out of the loop entirely, but stick with a commodity motherboard.
17:06:00 <lispy>  ls /usr/include/gmp.h -l
17:06:00 <lispy> -rw-r--r-- 1 root root 82863 2008-04-09 00:22 /usr/include/gmp.h
17:07:27 <dcoutts> tehgeekmeister: do you get the same just running ghci?
17:07:47 <Cale> okay, it built successfully, anyway
17:08:29 <tehgeekmeister> dcoutts: nah, ghc is good.  i spent the past two days getting it working.  i had troubles getting ghc to work 64 bit under xen, so i ended up getting a 32 bit version going instead, so it might be an issue with some missing 32 bit dependency?
17:08:33 <tehgeekmeister> *ghci
17:09:10 <lispy> Cale: yay!
17:09:27 <Riastradh> ...why would GHC care that it's running under Xen?
17:10:12 <tehgeekmeister> Riastradh: it doesn't, per se.  ghc uses some MAP_32BIT flag that some versions of xen apparently ignore, causing it to try and access invalid memory addresses.
17:10:23 <lispy> Cale: I'm installing both unison and rysnc, but I'll leave the data backup plan firmly in your hands.  I would recommend doing a script that restarts the bot everynight, does an rsyrc to c.h.o and then restarts the bot
17:10:34 <tehgeekmeister> Riastradh: it's not GHC's fault, but still can't use 64 bit under xen as of right now.
17:11:02 * tehgeekmeister joins #xen to see if they know anything about this
17:11:03 <jeffz> some strange things happen under virtual machines... sbcl used to deadlock my shared hosting account
17:11:05 <noecksit> hello, would anyone that is familiar with gtk2hs development happen to be on here?
17:11:06 <dobblego> > 1
17:11:07 <lambdac>  1
17:11:15 <wadcom> hi
17:11:16 <lambdabot>  State0:  error: imports.h: No such file or directory
17:11:32 <Cale> ... surely that isn't my lambdabot
17:11:38 <lispy> Cale: that way we would be sure that lambdabot isn't leaking too much and you have a recent backup in case my server goes down
17:12:15 <wadcom> This simple program doesn't seem to detect EOF from terminal, why is that? The code: main = interact id
17:12:16 <TomMD> tehgeekmeister: I run Xen 3.2 + 64 bit ghc.
17:12:28 <tehgeekmeister> TomMD: i run whatever slicehost is using
17:12:36 <noecksit> im trying to extend gtk2hs however im not sure exactly which modules im supposed to modify, i can "make" a clean darcs repository but when i try to compile with my change the build breaks
17:12:40 <wadcom> this works: (echo "asd"; echo "zxc") | runhaskell main.hs
17:12:45 <lispy> wadcom: interact is at the mercy of the terminal settings such as non-blocking.  not sure about eof issues
17:12:54 <dcoutts> noecksit: hi
17:13:22 <dcoutts> noecksit: you'd usually want to be modifying .chs or .chs.pp files
17:13:43 <wadcom> this doesn't: runhaskell main.hs (doesn't react on ^D, so I have to kill it with ^C)
17:14:00 <TomMD> tehgeekmeister: If you use Xen as more than just incidental due to hosting, you might be interested in hsXenCtrl.
17:14:00 <wadcom> lispy: any insights into troubleshooting this?
17:14:11 <noecksit> dcoutts: hello, what is actually the difference between .chs & .chs.pp? i see both
17:14:20 <newsham> i'm getting a stack overflow using   encode <$> BS.readFile fn    :(
17:14:26 <newsham> even though i was able to write it out earlier.
17:14:34 <lispy> wadcom: not really no.  I just know that your console/terminal settings matter a lot with interact.
17:14:43 <tehgeekmeister> TomMD: it's just cheaper having a vps than a dedicated server, that's all.  i'll remember that in case i play with xen elsewhere, however
17:14:43 <wadcom> lispy: ok, thx
17:14:56 <lispy> wadcom: But, I think you can change the settings from inside your program
17:15:07 <lispy> wadcom: I forget... hSetBlocking ?
17:15:32 <wadcom> lispy: I wonder why it would matter, but will dig into that anyways
17:15:39 <noecksit> dcoutts: : i also modified gtk/Graphics/UI/Gtk.hs.pp and that is where it seems to break, it seems it cant import Graphics.UI.Gtk.General.General
17:15:52 <lispy> wadcom: well, for EOF detection I dunno.
17:15:53 <tehgeekmeister> TomMD: do you know how i'd find out which xen i'm under?  i can't find it listed on slicehost's site yet.
17:16:37 <Cale> > ()
17:16:38 <lambdac>  ()
17:16:43 <lambdabot>  State0:  error: imports.h: No such file or directory
17:16:47 <Cale> oh...
17:17:07 <Cale> er...
17:17:46 <dcoutts> noecksit: one is generated from the other using cpp, so when there is both Foo.chs and Foo.chs.pp you want to edit Foo.chs.pp
17:18:03 <dcoutts> noecksit: if you change imports you may need to rm gtk/libHSgtk_a.deps
17:18:12 <newsham> whats a good way to track down a stack overflow using ghci?
17:18:43 <dons> dcoutts: why do your emails contain long strings of ampersands these days?
17:18:54 <Cale> hmm... oh right...
17:19:12 <noecksit> dcoutts: im not trying to modify a existing file, Im trying to create a new file actually, so is Foo.chs.pp I need to create only?
17:19:29 * Cale wonders what to do about this problem now...
17:19:34 <dcoutts> dons: seem evo is generating 0xFFEF chars or something
17:20:00 <dcoutts> dons: where do these chars turn up? all over the place randomly?
17:20:20 <dons> long strings at the start of paragraphs.
17:20:20 <newsham> thats the UTF-16 BOM
17:20:23 <dcoutts> noecksit: you'll have to modify Makefile.am to add new modules
17:20:28 <newsham> U+FEFF
17:20:44 <dcoutts> noecksit: what are you adding btw? Are you using the code gen?
17:21:34 <lispy> Cale: what is the problem with it?
17:21:46 <lispy> imports.h?
17:21:56 <lispy> > 1
17:21:57 <Cale> lispy: No, I fixed that one
17:21:57 <lambdac>  1
17:22:01 <lispy> cool
17:22:21 <Cale> The problem now is that there's a plugins/runplugs bug which causes it not to see packages installed anything but globally.
17:22:35 <lispy> ah
17:22:40 <Cale> dcoutts: You'd know this... what do I use to get a list of package.conf's?
17:22:46 <noecksit> dcoutts: im sorry, i cant find libHSgtk_a.deps under the gtk folder, do you mean somewhere else?
17:23:37 <noecksit> dcoutts: im trying to add a small function under Graphics.UI.Gtk.Gdk.Window, which I would like to create
17:24:05 <dcoutts> Cale: in a human readable way? there's nothing easy for machine readable (though Cabal does something)
17:24:47 <dcoutts> noecksit: no, that's where the generated deps get put. If it fails then make may well delete it.
17:25:13 <Cale> dcoutts: Well, okay, perhaps that's the wrong question, but plugins has an API which allows you to explicitly give a list of the package.conf files you'd like to use. The simpler API apparently does something incorrect to discover it...
17:26:21 <dcoutts> Cale: there's no easy way to get a list of ghc's standard package dbs.
17:26:26 <noecksit> dcoutts: under the gtk folder all I have is "gtk.cabal", "gtk.cabal.in", gtk.package.conf", gtk.package.conf.in", & "wingtk.h", no .deps files though
17:27:14 <dcoutts> Cale: the way Cabal uses (for older ghc versions) is to parse the output of ghc-pkg list
17:27:28 <noecksit> dcoutts: under the folder i am building there is a dep file for each file compiled, did u mean that?
17:27:58 <Cale> dcoutts: plugins appears to have a bunch of code for reading package.conf files, should it?
17:28:43 <dcoutts> noecksit: like I said, make will delete it if it doesn't get generated successfully
17:28:50 <Cale> Or does Cabal have an API for getting whatever information it might need?
17:29:06 <dcoutts> noecksit: you are running make from the top level dir right?
17:29:30 <dcoutts> Cale: ideally no, since the format is private and it changes with ghc version. Also, ghc can already use another format.
17:29:41 <Cale> hmm
17:29:45 <Cale> okay
17:29:52 <noecksit> dcoutts: oh ok, i thought you wanted me explicitly to delete some file before running make, yes im running from the top dir
17:29:52 <shapr> Pseudonym: Cool! lambdabot 0.1 !
17:29:54 <dcoutts> Cale: it does yes.
17:30:09 <chrisdone> am I right here?: a OR b = (a XOR b) XOR (a AND b)
17:30:19 <dcoutts> Cale: getInstalledPackages :: Verbosity -> Compiler -> PackageDB -> ProgramConfiguration -> IO (Maybe (PackageSet InstalledPackageInfo))
17:30:28 <Pseudonym> Arguably pre-1.0.
17:30:36 <dobblego> @check \a b -> a || b == (a /= b) /= (a /= b)
17:30:44 <dcoutts> noecksit: if it had existed then that was my suggestion
17:30:46 <lambdac>      precedence parsing error         cannot mix `(==)' [infix 4] and `(/=)' ...
17:30:53 <dobblego> @check \a b -> (a || b) == (a /= b) /= (a /= b)
17:30:54 <lambdac>      precedence parsing error         cannot mix `(==)' [infix 4] and `(/=)' ...
17:31:01 <dobblego> @check \a b -> (a || b) == ((a /= b) /= (a /= b))
17:31:02 <lambdac>  Falsifiable, after 0 tests: False, True
17:31:14 <roconnor> > recip 0.6202
17:31:15 <lambdac>  1.6123831022250887
17:31:15 <chrisdone> > True || True
17:31:16 <lambdac>  True
17:31:17 <dolio> @check \a b -> (a || b) == ((a /= b) /= (a && b))
17:31:19 <lambdac>  OK, passed 500 tests.
17:31:22 <chrisdone> this is not exclusive or
17:31:25 <dobblego> oops
17:31:28 <dolio> @scheck \a b -> (a || b) == ((a /= b) /= (a && b))
17:31:32 <dobblego> thanks dolio :)
17:31:41 <lambdac>   Completed 4 test(s) without failure.
17:32:05 <dcoutts> noecksit: Cale you could probably extract the code from Cabal, though there is rather a lot of it to deal with loading the package db
17:32:19 <lament> @check \a b c d e f g -> a || b || c || d || e || f || g
17:32:21 <lambdac>  Falsifiable, after 234 tests: False, False, False, False, False, False, False
17:32:29 <chrisdone> I wrote down three tests, because of associative properties, you only need to test 0 AND 1, 0 AND 0, and 1 AND 1. for some reason I think that OR can be defined in terms of XOR and AND is cool
17:32:32 <Cale> dcoutts: Ideally I would want to just call the Cabal API if possible.
17:32:56 <dolio> @scheck \a b -> False == ((a /= b) /= (a /= (b :: Bool))) -- ?
17:32:57 <lambdac>   Completed 4 test(s) without failure.
17:32:59 <dolio> :)
17:33:03 <chrisdone> ^_^!
17:33:28 <dcoutts> Cale: that'd work
17:33:41 <noecksit> ok, now i get the error "c2hsLocal: System/Glib/Types.chi not found in: glib"
17:35:24 <Cale> I have the feeling that eventually I will reduce hs-plugins to 10 lines of code which uses the GHC API and Cabal, and I still won't really have understood it.
17:35:34 <Cale> hey, what the...
17:35:49 <Cale> ^^ That is not my lambdabot...
17:35:57 <Cale> > ()
17:35:57 <newsham> ?bot
17:35:58 <lambdac> :)
17:35:58 <lambdac>  ()
17:36:03 <Pseudonym> No, it's lambdabot 0.01.
17:36:23 <newsham> > 1 + 2
17:36:23 <Pseudonym> Yours ain't here, so I dug out the first version.
17:36:24 <lambdac>  3
17:36:30 <newsham> [14:34] *lambdabot* Sorry, don't understand
17:36:33 <Pseudonym> lambdabot: What can you do?
17:36:34 <lambdabot> Sorry, I'm not a very smart bot yet.
17:36:39 <dcoutts> Cale: :-)
17:37:10 <dcoutts> Cale: I suspect it doesn't need to use Cabal at all and can just use the ghc api
17:37:23 <Cale> That seems likely.
17:37:35 <Pseudonym> Cale: If you get yours happening again, feel free to kill this one.  Everyone has admin privileges.
17:37:42 <Cale> okay
17:37:43 <Pseudonym> You just can't do very much with it.
17:37:56 <tehgeekmeister> i tracked it down and i do have a 32 bit libdl installed; how would i go about tracking down where ghci's looking for it so i can put a symlink in the right place?
17:38:07 <tehgeekmeister> err, runghc
17:39:05 <Cale> Pseudonym: well, mine works modulo eval at the moment. I'm just looking at whether I can finally fix a stupid bug in hs-plugins which prevents it from seeing packages installed as user.
17:41:00 <Cale> hackage appears to be down now...
17:41:21 * lispy mumbles something about CPP macros on the same line as the single quote character...
17:41:34 * lispy pulls a little more hair out
17:41:36 * Pseudonym nods
17:41:38 <tehgeekmeister> Cale: not loading for me either
17:41:55 <dons> hmm.. up here.
17:42:06 <bos> @src sum
17:42:06 <lambdac> sum = foldl (+) 0
17:42:54 <monochrom> Is that why so many programmers have long hair like hippies do?  Because they pull their hair out often?  :)
17:43:06 <chrisdone> and beards, for backup
17:43:10 <Cale> 19. fe5-0-0.cis024cor01.bea1.easy.ea  0.0%    49  110.2 111.1 108.6 119.6   2.1
17:43:10 <Cale> 20. ???
17:43:10 <Cale> 21. pdx.galois.com                    0.0%    49  298.4 244.5 111.9 460.5  87.6
17:43:10 <Cale> 22. ???
17:43:21 <Cale> That's the end of the mtr output for it.
17:43:22 <Pseudonym> Cale: One other thing.  admin commands must be private-messaged to this version of lambdabot.
17:43:42 <Pseudonym> It was my clever obscurity measure.
17:43:53 <Cale> Pseudonym: well, I know lambdabot's password, so I could always ghost it if all else failed :)
17:44:01 <Pseudonym> True.
17:44:10 <ddarius> lispy: Why are you using CPP?
17:44:29 <shapr> I wish lambdabot worked like mnesia or something...
17:44:33 <shapr> multiple nodes that do failover.
17:45:21 <tehgeekmeister> oh, wow, looking over the strace for runghc Setup configure, it successfully opens, mmaps, and closes libdl before it complains about libdl not existing.  any idea what might cause that?
17:46:05 <saimazoon> hello
17:46:10 <lispy> ddarius: Because we wanted to add type witnesses as we go.  It's more work than can be done in a week or a month.  Using CPP lets us toggle them on and off on each compile.
17:46:13 <Cale> mm... there we go, hackage is back up...
17:46:13 <ddarius> shapr: We have that.  It's just meat powered.
17:46:18 <shapr> hola saimazoon!
17:46:20 <shapr> ddarius: ah
17:46:24 <saimazoon> hola
17:46:26 <lament> saimazoon: hola :D
17:46:29 <shapr> como vai?
17:46:36 <shapr> tudo bem?
17:46:38 <saimazoon> muito bem, obrigado
17:46:39 <saimazoon> sim
17:46:54 <lambdabot> Oh, yeah, everyone can sockpuppet lambdabot, too.
17:47:03 <saimazoon> mas nos nao falamos português em espanha
17:47:09 <shapr> ok then..
17:47:21 <shapr> It's okay, I don't speak português either.
17:47:34 <saimazoon> why did you start speaking to me in portuguese
17:47:42 <saimazoon> when it's obvious from my IP address that I live in Spain
17:47:46 <shapr> Sorry, I forgot I don't speak português :-(
17:47:57 <saimazoon> this is so odd
17:48:12 <shapr> saimazoon: Um anyway... WELCOME TO #HASKELL!
17:48:18 <shapr> So, how do you like writing Haskell?
17:48:19 <lament> yeah totally
17:48:22 * shapr quickly tries to distract...
17:48:44 <monochrom> I was about to speak to you in Italian...  I can't tell them apart, all those Latin-like languages!
17:48:45 <saimazoon> I used to like it
17:48:54 <shapr> Haskell? or Português?
17:49:07 <saimazoon> both of them
17:49:10 <lament> saimazoon: i can't imagine you liking Haskell
17:49:16 <saimazoon> why
17:49:16 <lament> were you drunk?
17:49:20 <saimazoon> what do you imagine me liking
17:49:24 <lament> C
17:49:24 <monochrom> It's like I go to #java and I perceive they speak c#
17:49:35 <saimazoon> I like C the most, that's true
17:49:46 <shapr> saimazoon: talar du svenska?
17:49:49 <Pseudonym> I go to #haskell and think they're speaking ISWIM.
17:49:53 <shapr> haha
17:49:53 <saimazoon> No
17:49:56 <saimazoon> shapr
17:49:57 <monochrom> haha
17:50:14 <saimazoon> вы знаете русский язык ?
17:50:19 <shapr> ooh, I can't even SEE that one!
17:50:23 <saimazoon> good
17:50:24 <Pseudonym> STOP TRYING TO HACK MY IRC CLIENT!
17:50:26 <lament> saimazoon: Haskell is all about very high level stuff that's nothing at all like the underlying hardware...
17:50:29 <saimazoon> another helpless irssi user
17:50:30 <shapr> saimazoon: impressive!
17:50:34 <shapr> saimazoon: Where? I'm using emacs!
17:50:37 <saimazoon> ah
17:50:38 <lament> shapr: epic fail! get unicode!
17:50:39 <Pseudonym> Sheesh.
17:50:42 <chrisdone> niod u r ftw em esucxe
17:50:43 <saimazoon> I use emacs as well, but not for IRC chatting
17:50:45 <Cale> shapr: It's in cyrillic characters.
17:50:51 <shapr> lament: IRC does not dictate a charset!
17:50:54 <shapr> As much as it should :-/
17:50:59 <saimazoon> lament, I like haskell because it's nothing in the middle
17:50:59 <shapr> Thus my preference for XMPP
17:51:02 <lament> shapr: no, but the universe does
17:51:09 <saimazoon> I like either low level stuff or very high level stuff
17:51:11 <Cale> shapr: Freenode is basically all UTF-8 though.
17:51:12 <shapr> lament: Yeah, but that charset is all quantum and stuff.
17:51:16 <shapr> Cale: Not all of it.
17:51:24 <saimazoon> but stuff amidts is just for losers
17:51:27 <Cale> Are there channels which use something else?
17:51:27 <saimazoon> amidst *
17:51:28 <shapr> Many of the Finnish channels stick with ircnet defaults.
17:51:32 <Cale> hmm
17:51:50 <monochrom> Well #haskell definitely uses utf-8 generously.
17:52:05 <shapr> Since irc started in Finland... and iso-8859 was all the craze then.
17:52:07 <saimazoon> shapr, which irc client for emacs do you use
17:52:12 <Pseudonym> Se nur cxiu uzus ASCII-on, vi estus felicxa.
17:52:16 <shapr> saimazoon: I use ERC.
17:52:18 <saimazoon> I tried using ERC but it seemed a bit unwieldy
17:52:29 <shapr> saimazoon: xu do tavla mi bau la lojban
17:52:35 <saimazoon> Ho, alia parolanto de la internacia lingvo
17:52:38 <saimazoon> haha
17:52:38 <chrisdone> is there one web page which explains the whole deal about different character sets and encodings and... bytes which mean letters... egh
17:52:38 <saimazoon> nao
17:52:40 <SamB> I think I ran ERC once
17:52:48 <chrisdone> shapr: ue
17:52:48 <Pseudonym> Saluton, saimazoon!
17:52:49 <shapr> saimazoon: I like ERC, but I was part of the beta tester group, so that makes sense.
17:52:54 * cjb is using erc RIGHT NOW
17:52:58 <shapr> me too!
17:53:03 <SamB> chrisdone: hmm, why?
17:53:04 <shapr> cjb: Oh hey, how large is your screen at work?
17:53:07 <saimazoon> I'd rather use X-chat for chatting
17:53:10 <cjb> shapr: 30"
17:53:13 <shapr> Ah spiffy
17:53:16 <saimazoon> chrisdone, what don't you understand
17:53:24 <shapr> I was thinking of gething a 30" myself, but have no basis for comparison.
17:53:25 <saimazoon> it's just how you instruct your program to read characters from its input
17:53:30 <monochrom> chrisdone: I think some wikipedia articles do.
17:53:49 <saimazoon> how much is a 30'' screen ?
17:53:51 <cjb> shapr: you might consider getting two 23"s both in portrait mode
17:53:55 <saimazoon> I'm using a 11.5'' right now
17:53:56 <cjb> shapr: which is what Google does
17:53:59 <shapr> cjb: why so?
17:54:03 <gwern> one of these days I'm going to buy goggles which project a screen
17:54:04 <chrisdone> well, in my ignorance I assumed UTF-8 would support all characters, I've seen lots of different kinds in it. but then there are ones specific to certain languages. why not everyone use UTF-*?
17:54:05 <dogbite_> is there a lazy version of Data.Set, so that i can test membership in O(lg n) but feed it an infinite list?
17:54:05 <shapr> Is there some benefit other than cost?
17:54:12 <gwern> forget monitors!
17:54:15 <chrisdone> monochrom: well, I'll see
17:54:17 <cjb> shapr: because it's cheaper, and because vertical screen space tends to be more useful than horizontall
17:54:20 <shapr> cjb: Do the 23" screens each do full-on dual link DVI?
17:54:24 <Pseudonym> Ni benozas, #haskell-eo krei.
17:54:34 <cjb> shapr: no need for dual-link
17:54:34 <mauke> dogbite_: that sounds impossible
17:54:45 <cjb> the 23"s would be 2*1920x1200
17:54:46 <dogbite_> mauke: what if the input list is ordered?
17:54:51 <cjb> you can do 1920x1200 with single DVI
17:54:52 <monochrom> Perhaps start with the unicode article and hunt for links.
17:54:57 <cjb> the 30" is 2560x1600
17:55:01 <Cale> 初めまして、サイマズーンさん
17:55:04 <mauke> dogbite_: then use a list and dropWhile
17:55:15 <cjb> so I think 1920 vertical would be more useful than 1200 vertical
17:55:20 <cjb> for a lot of things, like reading IRC
17:55:21 <mauke> I don't think O(log n) buys you anything if n = infinity
17:55:23 <nodogbite> mauke: but then will membership be lg(n)?
17:55:26 <gwern> chrisdone: well, I've heard that the reason some asians/russians/europeans don't use utf-8 is because they despise it and prefer their own standards, or because of size penalties, or something else
17:55:31 <cjb> but it means that you can't watch a DVD on one big screen
17:55:32 <cjb> which is nice
17:55:38 <shapr> cjb: I suspect a single screen is better for usability though.. unless there are some 23" screens with nearly zero border on one side.
17:55:44 <shapr> cjb: Yeah, exactly.
17:55:45 <nodogbite> well to be more specific, i want to test membership in a list of primes
17:55:53 <monochrom> Some people don't use utf-* because they have old software and they don't want to change (various reasons or fetishes).
17:55:56 <cjb> shapr: yes, there are screens with a small border.
17:56:00 <nodogbite> i suppose i'll just try bounding it with a large number and see what happens
17:56:07 <shapr> cjb: Do you have any personal recommendations?
17:56:08 <cjb> shapr: this is Google's main developer workstation setup, so I think it works pretty well
17:56:17 <cjb> shapr: not really, I'd probably go with Dell
17:56:19 <SamB> gwern: or feel it does not understand them or something
17:56:23 <shapr> cjb: Oh, I broke the software on my XO somehow.. logo comes up, but no booting :-(
17:56:33 <cjb> shapr: ah, a reflash'll fix it
17:56:37 <cjb> I guess the disk is probably full
17:56:42 <shapr> Oh could be
17:56:51 <gwern> SamB: apparently the japanese and chinese really don't like utf, although I'm not qualified to understand their criticisms
17:56:52 <cjb> I've actually just been working on that
17:56:55 <monochrom> Some other people don't use utf-* because they're snobbish - they take pride in being obsolete.  E.g., some such people are obsessed with plain ASCII, some with iso-latin-*.
17:56:56 <cjb> booting even when the disk is full
17:57:02 <shapr> Spiffy, I'll check out reflashing on XO wiki when I get some spare time.
17:57:07 <gwern> something about roundtrip chars and particular strokes?
17:57:25 <shapr> cjb: Oh hey, I had beer with five PLT grad students on Saturday, it was fun! Do you know PLT students from NEU or BU?
17:57:39 <cjb> gwern: a vaguely valid reason is that there are whole classes of optimizations you can do on single-byte text that you can't on variable-byte
17:57:40 <SamB> gwern: roundtrip definately seems like an important issue, as would be preserving the look of their text ...
17:57:52 <cjb> gwern: ie. anything that says "skip the next n chars because we know they aren't needed"
17:57:52 <shapr> cjb: Just wondering wether I should contact you next time.
17:57:54 <SamB> cjb: that does NOT apply to the japanese or chinese
17:57:56 <shapr> whether*
17:58:02 <SamB> as far as I can see
17:58:19 <cjb> SamB: yes, but neither does "some such people are obsessed with plain ASCII" which is what I was replying to.
17:58:20 <shapr> shh, he's here!
17:58:31 <cjb> because I'm obsessed with plain ASCII if it makes sort(1) run twice as fast, which it does
17:58:36 <shapr> saimazoon: So, have you written any nifty Haskell code lately?
17:58:40 <monochrom> If you use utf-8 in EFNet #math, some people there will say "no high-ascii please".  Look at the attitude behind "high-ascii".
17:58:42 <SamB> cjb: how so?
17:58:53 <SamB> I was under the impression that sort(1) could just keep comparing bytewise
17:58:54 <shapr> monochrom: Like High Elven?
17:58:57 <Pseudonym> "
17:59:00 * edwardk circles around back to see what people are saying.
17:59:02 <Pseudonym> Or "high church", yes.
17:59:16 <cjb> SamB: was slower last time I tested under a utf-8 locale.  grep too, I think anything that uses regexps.
17:59:21 <SamB> isn't utf-8 supposed to preserve lexicographic ordering
17:59:28 <cjb> that's not the issue
17:59:29 <SamB> oh, sort uses regexes?
17:59:36 <Pseudonym> There is no "high ascii".  ASCII is 7 bit.
17:59:39 <cjb> the issue is needing to check every byte to see whether it's the start of a multibyte char
17:59:41 <chrisdone> SamB: wouldn't a bytewise comparison of unicode characters produce a meaningless sort? like e and e acute..
17:59:43 <cjb> in order to know where you are in the file
17:59:45 <shapr> I thought lexicographic utf-8 ordering isn't always the same across locales?
17:59:53 <cjb> shapr: that's certainly true.
17:59:57 <SamB> hmm
18:00:06 <cjb> (how many characters you are into the file, I mean)
18:00:06 <SamB> I was thinking that the order would be by codepoint ;-)
18:00:10 <Pseudonym> shapr: CJKV being the obvious example.
18:00:14 <saimazoon> shapr I've been over two years without writing anything in haskell
18:00:17 <saimazoon> just C and ASM
18:00:21 <saimazoon> and I'd really like to take it up again
18:00:28 <saimazoon> I miss its cleanness
18:00:29 <shapr> saimazoon: Yay! Got any neat projects in mind?
18:00:34 <saimazoon> not really
18:00:35 <shapr> Yeah, me too... too much C# lately.
18:00:46 <SamB> saimazoon: you should write about the experience ;-)
18:00:55 <saimazoon> what experience
18:01:02 <saimazoon> being more than two years without tasting it?
18:01:02 <cjb> shapr: 24" widescreen is $369 from Dell, that's before any special deals
18:01:04 <SamB> like, what does withdrawal look like?
18:01:08 * BMeph wonders what House woould be like, using Forth for the "naughty bits" instead of C...
18:01:16 <shapr> cjb: Ok, that's *much* cheaper.
18:01:16 <cjb> shapr: so two of those is quite a bit less than the $2500 I spent on a 30" :)
18:01:31 <cjb> (they've come down to about $1200 since then)
18:01:34 <shapr> Yeah, 30" is down to $1300 on newegg.com, but that's still 4 * 23"
18:01:42 <cjb> yeah
18:01:45 <monochrom> The word "high ascii" originated as IBM's or Microsoft's proprietary 8-bit charsets.  So when you say "high ascii" the connotation is "non-standard".  In other words some people in EFNet #math still refuses to accept unicode as an international widespread standard.
18:01:51 <cjb> I think the extra vertical space is better for coding
18:01:57 <shapr> Hm, yeah
18:02:17 <shapr> cjb: What about xrandr and turning the 30" sideways? :-)
18:02:21 <cjb> haha
18:02:21 <shapr> It works for the XO!
18:02:22 <cjb> too high!
18:02:23 <newsham> hah... luckily nobody cares about #math.
18:02:32 <SamB> weren't there some old systems with portrait-format monitors?
18:02:34 <monochrom> Well I care about it.
18:02:40 <shapr> Have you seen the high-end wacom tablets?
18:02:40 <cjb> SamB: yes, it's quite common in CAD
18:02:52 <SamB> I was thinking of that thing they made smalltalk on
18:02:58 <SamB> what's it called
18:03:13 <monochrom> It hurts my heart because some of those people are my friends.
18:03:14 <Pseudonym> I want a Cintiq.
18:03:20 <shapr> cjb: Those look awesome: http://www.wacom.com/cintiq/
18:03:21 <lambdac> Title: Cintiq Product Information
18:03:26 <chrisdone> monochrom: don't they use LaTeX notation or something similar in #math? I seem to remember being told not to use ∩ or ∪, or any unicode and stick to ASCII
18:03:28 <edwardk> hrmm does anyone know if someone has a good data set containing the relative frequencies of constructors of different arities in Haskell?
18:03:41 <edwardk> i'm able to go through and build one, just curious if there was one out there
18:03:46 <Pseudonym> But it'd be a second monitor, I susoect.
18:03:49 <cjb> shapr: they're also like $5000
18:04:02 <shapr> cjb: Yeah, not cheap.
18:04:10 <shapr> It's like... rich person's XO!
18:04:14 <monochrom> A minority of them are obsessed with LaTeX. But most say "just use u and n".
18:04:35 <shapr> @seen bos
18:04:35 <TomMD> tehgeekmeister: You can determine the Xen version with:
18:04:35 <TomMD> xc_version(dom->guest_xc, XENVER_version, NULL);
18:04:35 <TomMD> I don't have good haskell bindings for this yet.
18:04:35 <lambdac> I saw bos leaving #haskell 20s ago, and .
18:04:55 <shapr> edwardk: I haven't heard of such a thing.
18:05:08 <cjb> (for all I said about optimizing movement through single-byte text files earlier, I do send all my mail in UTF-8 and so on.  I'd even use it in code.)
18:05:23 <monochrom> While many of them refuse unicode, they also find LaTeX unreadable.
18:05:30 <shapr> But how to type all the utf-8 stuff that's not on your keyboard?
18:05:38 <mauke> Ｉ ＜３ Ｕｎｉｃｏｄｅ
18:05:39 <shapr> Something like M-x set-input-method?
18:05:40 <lament> why would anyone refuse unicode?
18:05:46 <shapr> Or x-select ?
18:05:48 <cjb> I use M-x set-input method utf8
18:05:53 <tehgeekmeister> TomMD: i assume that's c that relies on some xen controls library?
18:05:53 <cjb> and then type e.g. "u00b9"
18:05:54 <shapr> ooh, I haven't tried that.
18:05:57 <chrisdone> cjb: right, I often write λ or “foo” in my comments... then delete it in case one day some ASCII nazi refuses to work with my code
18:05:58 <cjb> to get U+00B9
18:06:13 <SamB> monochrom: I wonder what would happen if I told them "well, I did type that just like you said, but it came out like ∩"
18:06:19 <cjb> chrisdone: well, that's why it's in a comment rather than the code itself
18:06:22 <monochrom> Heh
18:06:29 <SamB> which I could say in perfect truth
18:06:37 <shapr> Swedish and Portuguese input methods have a lot of handy mappings like ae -> ä, is that sort of stuff in utf8 input-method?
18:06:39 <TomMD> tehgeekmeister: xenctrl
18:06:56 <cjb> shapr: I don't think so, but I'm not expert.
18:07:03 <TomMD> tehgeekmeister: gcc -lxenctrl
18:07:09 <lament> shapr: what are the shortcuts for portuguese?
18:07:14 <chrisdone> SamB: hαhα
18:07:21 <saimazoon> where are you from, shapr
18:07:25 <shapr> lament: letter and postfix mark
18:07:30 <newsham> unicodeis the new 31337
18:07:35 <shapr> saimazoon: I'm from the Swedish speaking part of Alabama.
18:07:45 <chrisdone> ¹³³7
18:08:01 <shapr> saimazoon: Where are you from?
18:08:20 <saimazoon> I didn't know there was a swedish-speaking area in Alabana
18:08:28 <saimazoon> from the Tanzanian-speaking part in Madrid
18:08:30 <shapr> There isn't really :-)
18:08:43 <mauke> ¹³³⁷
18:08:44 <shapr> In fact, I haven't met anyone else originally from Alabama who speaks Swedish.
18:08:52 <shapr> Men jag kan tala lite svenska.
18:08:57 <lament> i didn't know there was a Tanzanian language
18:09:08 <saimazoon> yes, but it's extinct
18:09:15 <mauke> ₁₃₃₇1337¹³³⁷
18:09:15 <shapr> Do you speak it?
18:09:17 <chrisdone> newsham: unicode will bring the interrobang to its rightful place as an important part of day to day textual expression of suprise and confusion
18:09:17 <saimazoon> what do you suppose people used to speak before British settlers arrvied
18:09:18 <saimazoon> no
18:09:22 <shapr> saimazoon: German?
18:09:24 <saimazoon> nobody does, it's vanished
18:09:26 * shapr is joking
18:09:28 <SamB> shapr: so, the swedish-speaking part of alabama consists of your residence?
18:09:29 * cjb is from the German-speaking part of England, if we're going to measure it that way :)
18:09:35 <shapr> SamB: Yes, except that I live in Boston now.
18:09:37 <saimazoon> no, I'm not German
18:09:39 <shapr> cjb: haha
18:09:43 <saimazoon> unfortunately, I have to say
18:09:56 <SamB> shapr: oh yeah
18:09:59 <shapr> saimazoon: No I was joking that people in Madrid spoke German before the British settlers arrived.
18:10:06 <SamB> so the swedish-speaking part of alabama is actually in boston?
18:10:11 <shapr> SamB: Sad isn't it?
18:10:39 <shapr> saimazoon: Parlez vous francais aussi?
18:10:43 <shapr> I'm guessing yes :-)
18:11:04 <shapr> Oh hey, I wonder if GF has a Portuguese grammar.
18:11:10 <shapr> That would be nifty to write if it doesn't already exist.
18:11:12 <saimazoon> oui, mais pas très bien
18:11:13 * shapr scurfles
18:11:18 <shapr> saimazoon: moi aussi...
18:11:35 <shapr> I took classes in school, that's about it.
18:11:44 <saimazoon> I didn't :/
18:11:52 <shapr> I learned Swedish in Sweden.
18:12:17 <saimazoon> combien de langages parlez-vous ?
18:12:18 <chrisdone> I know more lojban than french, and I took french at school
18:12:25 <cjb> shapr: if there was one for French, it could be a Gaulois Field
18:12:36 <shapr> argh!
18:12:41 <saimazoon> ah, vous avez habité en Suède
18:12:49 <shapr> saimazoon: I used to, but not anymore.
18:12:54 <saimazoon> why did you leave
18:12:58 <saimazoon> was it better than the US?
18:12:59 <shapr> saimazoon: They threw me out.
18:13:03 <saimazoon> I'm thinking about moving there next year
18:13:14 <shapr> I was an illegal alien in Sweden, so I went to Boston instead.
18:13:22 <lament> mm
18:13:30 <saimazoon> I could finish my degree in Stocholm and that looks much more appealling than staying in Madrid for another year
18:13:42 <saimazoon> lol
18:13:46 <saimazoon> why didn't you ask for a visa
18:13:53 <shapr> saimazoon: I really only speak American, but I have conversational Swedish, and I can get by in French, and I have enough German, Dutch and Finnish to order beer, food, etc
18:14:01 <shapr> saimazoon: It's a seven year long story...
18:14:26 <saimazoon> I only speak Spanish and the local swearing tongue
18:14:31 <shapr> Ooh, teach me!
18:14:34 <saimazoon> everything else is a fiction
18:14:43 <shapr> I tend to switch to Swedish whenever I drink alcohol.
18:14:46 <shapr> This confuses my friends.
18:15:07 <chrisdone> haha
18:15:11 * shapr grabs the Grammatical Framework - http://www.cs.chalmers.se/~aarne/GF/doc/darcs.html
18:15:13 <lambdac> Title: GF Darcs repository
18:17:26 <chrisdone> > foldr (>>>) id [(+1),(*2)] 5
18:17:28 <lambdac>  12
18:17:28 <chrisdone> hur hur
18:18:58 <TSC> @src (>>>)
18:18:59 <lambdac> Source not found. :(
18:19:02 <TSC> Bah
18:19:08 <TSC> Is it flip . ?
18:19:09 <chrisdone> it's a method in the Arrow class
18:19:11 <chrisdone> yeah
18:19:26 <chrisdone> for functions
18:19:34 <TSC> Yes, flip .
18:19:37 <TSC> Not flip fmap
18:19:43 <TSC> In Haskell, not Caleskell
18:19:46 <chrisdone> @src (-> e) (>>>)
18:19:46 <lambdac> Source not found. It can only be attributed to human error.
18:19:58 <TSC> @type (>>>)
18:20:00 <lambdac> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
18:20:10 <TSC> Ah, I see what you mean
18:20:17 <chrisdone> yeah
18:22:22 * shapr boings furiously
18:22:23 <shapr> W00!
18:22:56 * araujo catches shapr with a lambda-web
18:23:13 * shapr lambda lifts himself out of the web!
18:23:20 <araujo> hah
18:23:22 <chrisdone> violin concerto in E minor - allegro RV 281. I say!
18:24:14 <edwardk> cool, distribution calculated.
18:24:17 <edwardk> @hpaste
18:24:17 <lambdac> Haskell pastebin: http://hpaste.org/new
18:25:18 <edwardk> http://hpaste.org/9572 has the distribution of the arities of constructors from a quick hack
18:26:05 <edwardk> i didn't take from a huge dataset and its probably biased because i skipped ones that used record syntax
18:26:52 <edwardk> is ghc still using the dynamic pointer tagging stuff?
18:27:01 <SamB> edwardk: of course
18:27:32 <tehgeekmeister> anyone have a good recommendation for a VPS host that they've been able to get ghc working on trouble free?
18:28:15 <shapr> tektonic?
18:28:26 <edwardk> observation, it has to go back through and propagate tag bits to all pointers during gc right? for 0 arity constructors couldn't it also point to a canonical object? a poor man's hash cons? by just storing the canonical object near the tag in the table
18:28:27 <shapr> That's where I have scannedinavian, hpaste, etc
18:28:39 <shapr> tehgeekmeister: You want a virtual machine host, yeah?
18:29:00 <tehgeekmeister> shapr: i'd like root access, but don't want to pay for dedicated, so that'd be ideal
18:29:08 <SamB> edwardk: looked at the commentary yet?
18:29:18 <edwardk> you'd get a shared 'Nothing' node, shared 'Nil', shared 'Red' 'Green' Blue, etc. did they say that?
18:29:24 <shapr> tehgeekmeister: tektonic costs me $15 a month
18:29:44 <tehgeekmeister> shapr: nice, i'll look into them.
18:29:46 <chrisdone> shapr: hey were you aware hpaste isn't in the IRC anymore? no notifications :( are you able to fix that?
18:29:59 <shapr> chrisdone: Yeah, I poked at it for five minutes recently, it didn't get fixed...
18:30:06 <chrisdone> ah, oki
18:30:09 <shapr> I'll try it again.
18:30:14 <chrisdone> cool^_^
18:30:18 <SamB> edwardk: well, the .os already provide two such nodes of each I think ?
18:30:37 <tehgeekmeister> shapr: they offer more for less than slicehost, too!  that's a good deal.
18:30:45 <edwardk> samb: ?
18:31:04 <SamB> well, it never ALLOCATES zero-arity nodes on the heap anyway
18:31:05 <edwardk> samb: what commentary are you referring to btw?
18:31:10 <SamB> the GHC commentary
18:31:13 <edwardk> ah
18:31:15 <SamB> @google ghc commentary
18:31:18 <lambdac> http://hackage.haskell.org/trac/ghc/wiki/Commentary
18:31:18 <lambdac> Title: Commentary - GHC - Trac
18:31:22 <edwardk> ok
18:31:22 <SamB> that one ;-)
18:31:39 <tehgeekmeister> shapr: which distro are you using?  i don't want to have any more problems with this, and i'm not picky about distros...
18:31:46 <edwardk> i never noticed that it didn't allocate 0-arity nodes
18:31:53 <shapr> tehgeekmeister: I chose the debian/stable, and instantly upgraded it to unstable.
18:32:02 <SamB> edwardk: would be silly to allocate them
18:32:05 <shapr> tehgeekmeister: Then getting ghc working was really easy.
18:32:05 <tehgeekmeister> shapr: okay, thanks.
18:32:21 <SamB> considering the only interesting thing about them is which one they are
18:32:35 <tehgeekmeister> shapr: yeh, i imagine ghc on a 32 bit debian should be no problem at all.  i'll stick with stable, i think, tho.  =P
18:33:52 <edwardk> samb: where in the commentary does it talk about 0 arity stuff?
18:35:01 <TomMD> When building a FFI binding I am trying to deal with #define's intelligently.  What is the best way?  I don't want to make a vALUE1 = x, vALUE2 = y for all N 'VALUE' defines in the C program.
18:35:01 <Botje> @pl \x -> (x, f x)
18:35:01 <lambdac> ap (,) f
18:35:15 <shapr> tehgeekmeister: Why? Just curious...
18:35:56 <Botje> grr
18:36:05 <Botje> @pl \x -> print (x, f x)
18:36:06 <lambdac> print . ap (,) f
18:36:14 <Botje> @pl \x -> print (x, f . g $ x)
18:36:14 <lambdac> print . ap (,) (f . g)
18:36:24 <tehgeekmeister> shapr: i don't like messing around getting things working, i like to focus on whatever code i'm writing.  when i've used unstable in the past i spent more time configuring and fixing my system than using it.
18:36:42 <shapr> I like the latest version of GHC...
18:37:59 <thoughtpolice> latest GHC normally brings good things, and plus if we're talking 6.8 it's considered 'stable' by now I would think
18:38:01 <TSC> testing + cherry-picking from unstable is a reasonable compromise
18:38:28 <tehgeekmeister> shapr: ah, can't get that on stable?
18:38:28 <SamB> edwardk: well, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects is probably usefull to read ...
18:38:53 <tehgeekmeister> shapr: i haven't used debian for years, i tend towards ubuntu anymore when i do use linux.
18:39:01 <edwardk> samb: k
18:39:05 <shapr> Maybe you can request that? I don't remember.
18:39:25 <tehgeekmeister> it wasn't in their default list, but it may be possible
18:39:32 <edwardk> i figured what i was talking about was already being done, i figured it out in the context of a similar system i'm working on, but didn't find reference to it in the paper
18:39:49 <shapr> Ya know, even if I write a Portuguese grammar for GF, it still won't help me with Portuguese sms slang usage :-(
18:40:20 <edwardk> write a portugese grammar for portugese sms slang then ;)
18:40:28 <shapr> I dunno...
18:40:40 * shapr thinks about that
18:43:53 <lispy> Oh, I never realized it before, but using partial functions masks the compilers ability to detected non-exhastive patterns
18:44:31 <SamB> edwardk: actually I think that Nothing, etc. only have one exported node per .o file -- but when you use GHCi, then you get both the dynamically-loaded and statically-loaded versions of some zero-arity constructors
18:45:01 <SamB> edwardk: anyway, I think you just get that from the obvious implementation technique ...
18:45:45 <chrisdone> lispy: how do you mean?
18:46:22 <lispy> case somelist of (a:b) -> ...; vs (init somelist)
18:46:39 <lispy> chrisdone: I changed some code from using (init somelist, last somelist) to using cases
18:46:43 <SamB> since the obvious implementation is for Nothing to refer to the fully-applied constructor ...
18:46:52 <edwardk> samb: i suppose you do. it doesn't work in my grin-based setting thats probably why i saw it differently, because there i write the value over the cell i'm working on, and i have no indirections to point to the answer.
18:46:53 <lispy> chrisdone: now that I use cases, I found that i didn't consider the empty list
18:47:06 <lispy> chrisdone: because the compiler told me!
18:47:23 <chrisdone> lispy: ahhh
18:47:27 <SamB> edwardk: oh? no indirections?
18:47:41 <SamB> hmm.
18:47:48 <edwardk> samb: not currently
18:47:55 <chrisdone> lispy: like head [] doesn't produce a compile error
18:48:05 <edwardk> samb: stop and copy collection for each baby process
18:48:13 <chrisdone> lispy: well, disregard that one because head handles [], explicitly using error..
18:48:24 <lispy> > head []
18:48:25 <lambdac>  Exception: Prelude.head: empty list
18:48:26 <edwardk> funny tricks to share immutable data and do message passing with references into a common immutable store
18:48:30 <lispy> chrisdone: but, yes that's exactly the issue
18:48:40 <lispy> chrisdone: using pattern matching and -Wall you can find it
18:49:15 <edwardk> samb: grin doesn't seem very well suited to indirections because it uses that heap-points-to analysis expecting what it put there to still be there when it looks next time
18:49:17 <mmorrow> i don't think i ever use head,tail,etc in non-messing-around-at-the-interp-prompt code
18:49:46 <SamB> edwardk: hmm, well, you could probably use tagging for that kind of thing?
18:50:11 <SamB> zero-arity constructors don't need pointers ...
18:50:32 <chrisdone> lispy: -Wall warns of nonexhaustive patterns?
18:50:54 <SamB> no, wait, same problem
18:50:55 * SamB silly
18:51:07 <lispy> chrisdone: yes
18:51:20 <lispy> chrisdone: it's actually quite nice
18:51:22 <chrisdone> I've never really used -Wall because it seemed to think my functions weren't declared because I didn't declare them in order
18:51:28 <edwardk> i can write a tag for the indirection itself, but then i pick up an extra case everywhere, which dilutes efficiency quite a bit. remember i don't know if i got Nothing or Just until i propagate the tag bits
18:52:02 <dobblego> is there a hackage mirror?
18:52:14 <dobblego> hackage.haskell.org is unusably slow
18:52:22 <chrisdone> lispy: yeah, useful
18:52:31 <SamB> dobblego: what else is new ;-)
18:53:00 <edwardk> dobblego: i'm having an incredibly hard time accessing haskell.org right now at all myself
18:53:15 <chrisdone> mmorrow: hey formlets are awesome. check this http://chrisdone.com:3000/ and sauce: http://chrisdone.com:3000/Listi.html
18:53:17 <lambdac> Title: chris done's homepage
18:54:39 <lispy> chrisdone: wall doesn't care what order you declare them, but it does complain if you dont give top level functions a signature
18:54:52 <mmorrow> yeah, formlets look pretty cool. i skimmed over the paper and saved it in my to-read folder
18:54:56 <chrisdone> mmorrow: the registration form is particularly cool see how it checks against a DB in the validation bit?
18:54:56 * mmorrow looks
18:55:02 <chrisdone> mmorrow: cool
18:55:07 <dobblego> I am only after xmonad-0.7.tar.gz and xmonad-contrib-0.7.tar.gz if anybody has them :)
18:55:20 <chrisdone> lispy: ahh, maybe it was lack of signature that did it. aye, that was probably it ^_^
18:55:24 <mauke> dobblego: why not use the darcs version?
18:55:53 <dobblego> mauke, only because I am comfortable with running 0.7 having already done it
18:56:20 <mmorrow> chrisdone: heh, custom hscolour.css FTW!
18:56:29 <lispy> chrisdone: and recent versions with -Wall even tell you what those top level signatures should be
18:56:34 <chrisdone> mmorrow: haha
18:56:48 <chrisdone> mmorrow: stole the colours from hpaste >__>
18:57:03 <SamB> dobblego: it's way more unusably slow with darcs!
18:57:21 <chrisdone> lispy: that is cool. I think I'll investigate into using -Wall by default for all my stuff
18:57:25 <dobblego> code.haskell.org seems to be responsive, compared to hackage.haskell.org
18:57:38 <SamB> ... especially pulling from darcs1-format darcs1-semantics repositories
18:57:38 <chrisdone> dobblego: they are different servers
18:57:57 <SamB> dobblego: different locations too
18:58:03 <SamB> dons: what's the deal with the bandwidth?
18:58:07 <SamB> any updates?
18:58:21 <SamB> is there some sort of RSS feed we can subscribe to to get the blow-by-blow?
18:58:29 <dobblego> are xmonad-0.7.tar.gz and xmonad-contrib-0.7.tar.gz available on different servers anywhere? :)
18:59:11 <SamB> dobblego: well I think SSH access is not bandwidth-limited if you have ssh access to d.h.o ;-P
18:59:54 <dobblego> it seems not
19:00:33 <lispy> chrisdone: the biggest problem with -Wall is that it's very precise about module imports
19:01:21 <chrisdone> lispy: you mean it warns about potentially ambiguous names?
19:01:50 <lispy> chrisdone: No, it complains if you import too much
19:01:58 <chrisdone> lispy: "too much"?
19:02:06 <lispy> yeah, if you import something and don't us it
19:02:13 <chrisdone> ahh
19:02:33 <chrisdone> well, I don't mind that so much actually
19:02:53 <lispy> chrisdone: it also complains if you name a pattern and don't use it, but you can disable that by prepending the pattern name with _
19:03:06 <lispy> chrisdone: so, foo a b = a, would compain, but foo a _b = a, would not complain
19:04:02 <chrisdone> lispy: hmm, indeed. sometimes that's good and others annoying. I'd like the variables to be descriptive, not just "_". so the "_foo" is quite nice
19:04:10 <lispy> wow, Mark went crazy with the bug tracker
19:04:12 <chrisdone> lispy: similar to CL's (declare (ignore foo)), I guess
19:04:18 <lispy> oops, mischan
19:06:33 <monochrom> (declare (ignore fool)) :)
19:06:55 <lispy> monochrom: no, I can still hear Harop, try again
19:07:19 <chrisdone> yeah, I used to read c.l.l, so I know who that is. note the past tense
19:07:52 <lispy> chrisdone: I never read c.l.l, but I discovered him via ocaml and haskell-cafe...
19:08:04 <monochrom> me too
19:08:07 <chrisdone> lispy: >_<
19:09:05 <jeeves__> wut, no hackage = (
19:12:03 <Cale> jeeves__: it seems to be *extremely* slow
19:12:56 <lispy> Cale: how is the lambdabot restoration going?
19:13:12 <Cale> lispy: It's on hold because I can't get the plugins sourcecode from hackage.
19:13:24 <lispy> hah, okay
19:13:36 <mauke> preflex: seen lambdabot
19:13:36 <preflex>  lambdabot was last seen on #haskell 1 hour, 26 minutes and 42 seconds ago, saying: Oh, yeah, everyone can sockpuppet lambdabot, too.
19:13:42 <lispy> Cale: I might have a tarball of it, what is it called?
19:13:45 <lispy> Cale: hs-plugins?
19:13:51 <Cale> yes
19:13:57 <lispy> Cale: just a sec, I'll try to upload it
19:14:03 <Cale> actually...
19:15:05 <lispy> Cale: damn, I don't have a recent copy :(
19:15:10 <Cale> oh well.
19:15:39 <Cale> I have to fix a bug in it anyway, and I might be a bit tired for that now.
19:15:59 <lispy> Cale: alriht, but if I can help let me know
19:16:06 <Cale> oh, actually, I do have the source code.
19:16:12 <Cale> It's on your machine :)
19:16:22 <chylli> @src listToMaybe
19:16:22 <lambdac> listToMaybe []        =  Nothing
19:16:23 <lambdac> listToMaybe (a:_)     =  Just a
19:16:23 <Cale> I forgot that cabal keeps packages stored.
19:16:45 <chylli> @src unfoldr
19:16:45 <lambdac> unfoldr f b  = case f b of
19:16:46 <lambdac>    Just (a,new_b) -> a : unfoldr f new_b
19:16:46 <lambdac>    Nothing        -> []
19:16:51 <lispy> Cale: Well, none of my hs-plugins copies are recent
19:17:12 <Cale> lispy: but the one that I just downloaded today before hackage went down is :)
19:17:17 <lispy> ah
19:17:20 <lispy> Cool!
19:17:30 <SamB> hackage is down now?
19:17:33 <SamB> how come/
19:17:38 <Cale> I have no idea.
19:17:39 <lispy> SamB: unresponsive
19:17:49 <SamB> oh, you mean d.h.o is SLOW
19:17:54 <SamB> yes it is
19:18:02 <Cale> It's so slow as to be unusable.
19:18:25 <SamB> well, I'm seeing an assload of apache2 children
19:20:50 <SamB> lispy, Cale: do you suppose that could be related?
19:21:13 <Cale> It is possible?
19:21:18 <lispy> SamB: maybe, can you quantify?
19:21:35 <lispy> ass load means 1-10, 2000-4000 ?
19:21:46 <SamB> say ... 42
19:22:52 <mmorrow> Cale: i have an hs-plugins tarball of the darcs repo that i got a few days ago and made changes to to work with 6.9 here fwiw: http://code.haskell.org/~morrow/plugins/hs-plugins_ghc-6.9.20080504.tar.gz
19:22:54 <lambdac> http://tinyurl.com/6mjnjd
19:23:26 <dsrogers> is it me, or is darcs pretty slow compared to other distributed systems?
19:23:39 <b\6> it's slow.
19:23:43 <b\6> :(
19:23:50 <dsrogers> why is that?
19:23:56 <b\6> i don't know. i wish i did.
19:24:11 <b\6> sad @ stuff probably being better but being too slow to be competitive.
19:24:11 <lispy> dsrogers: it's complicated.  There are several layers of slowness.
19:25:15 <mmorrow> Cale: ah, just noticed you've already got it ;)
19:25:18 <lispy> dsrogers: we have #darcs BTW.  We have the wrong architecture for dealing with large files and patches, but it's hard to break inertia to change that when we can teak the performance.  The other issue is that we need to fully formalize patch theory before we can really start to optimize it
19:25:20 <SamB> dsrogers: well, it's not as bad if you use --hashed format on servers that aren't throttled like d.h.o is on port 80
19:26:09 <lispy> dsrogers: But, for small to medium sized projects you should never notice a performance problem (my experience)
19:26:25 <SamB> at least as long as it isn't hosted on d.h.o ;-P
19:26:40 <lispy> SamB: right, unfortunately :(
19:27:58 <dsrogers> as in patch theory itself isn't well formalized, or the the patch theory of darcs isn't well formalized?
19:28:11 <lispy> dsrogers: patch theory itself
19:28:37 <SamB> dsrogers: what is the difference?
19:28:49 <lispy> dsrogers: several of us are trying to hammer it out, but we have disagreements about it and none of us are full time researchers looking into it :)
19:29:14 <SamB> lispy: what does that last bit have to do with it?
19:29:14 <lispy> SamB: if patch theory itself were formally specified but darcs didn't match that spec, then that's different than if darcs matches an incomplete spec
19:29:16 <dsrogers> SamB: well there could be a better theory than the one that darcs uses
19:29:36 <SamB> there could be more than one patch theory
19:29:43 <SamB> yeah
19:29:48 <dsrogers> well but they would be isomorphic to one another.
19:29:50 <lispy> SamB: I suspect we'd have it hammered out already if we were full time researchers working on the fiddly bits of the theory
19:29:58 <SamB> dsrogers: if they were than why bother?
19:30:08 <SamB> lispy: I don't see why
19:30:29 <dsrogers> SamB: because sometimes the abstractions in one theory are easier to understand than another.
19:30:34 <SamB> there are probably multiple possibility which need more than full-time research to get it right
19:30:46 <dsrogers> SamB: you might as well ask, "why bother with functional languages?"
19:30:58 <SamB> well, not all functional languages are equivalent either
19:31:11 <dsrogers> well sure they are.  They are all turing complete.
19:31:26 <mmorrow> so is brainfuck
19:31:29 <mmorrow> :)
19:31:52 <SamB> that doesn't really make them equivalent
19:32:03 <dsrogers> yes it does.
19:32:11 <Cale> Conway's game of life is a much better programming language than brainfuck :)
19:32:11 <SamB> not in the way I mean
19:32:13 <lispy> SamB: well because I'm not a full time researcher I take entire months off from thinking about patch theory.  That sure slows down the intellectual progress I make with it.
19:32:16 <dsrogers> well for the equivalence class that I meant.
19:32:24 <mmorrow> if that's the definition of the equivalence relation under consideration, it does
19:32:27 <SamB> Cale: hmm, it looks nicer anyway
19:32:53 <dsrogers> lispy, do you have work in progress on the patch theory?
19:33:09 <dsrogers> I'd like to take a look.
19:33:09 <SamB> dsrogers: okay, let me put it this way: I don't use THAT equivalence relation very much in figuring out what programming language to use
19:33:12 <mmorrow> Cale: gliders ftw
19:33:19 <SamB> actually, some programming languages I use aren't ;-)
19:33:37 <dsrogers> SamB: in that case, you'll find value in multiple theories for the same thing.
19:33:39 <mmorrow> this is a stunning image: http://code.haskell.org/~morrow/images/gosper.gif
19:33:49 <mmorrow> s/stunning/hypnotizing/
19:33:50 <dsrogers> SamB: my original question was rethorical, you see.
19:33:55 <lispy> dsrogers: sort of, but I think others have made it farther.  Would you ilke some links?
19:34:02 <dsrogers> please.
19:34:02 <SamB> dsrogers: and I doubt most patch theories are equivalent ;-)
19:34:08 <Cale> It's actually pretty interesting just how strong a language you can construct which is still not turing complete and has provable termination.
19:34:28 <lispy> dsrogers:  http://urchin.earth.li/~ian/theory.pdf
19:34:36 <lispy> dsrogers: that's a recent draft by Igloo
19:34:47 <noohgodno> > mortages
19:34:47 <lispy> dsrogers: the source is here:  http://urchin.earth.li/~ian/theory/
19:34:48 <lambdac>   Not in scope: `mortages'
19:34:48 <SamB> I'm hoping for a language that is-but-isn't
19:34:48 <lambdac> Title: Index of /~ian/theory
19:35:27 <clanehin> So with this "what vcs should ghc's boot libs use," why does ghc need the HEAD of the boot libs?  Why don't they copy a stable release of the libs unto the ghc repo?  Not a fork but a copy.  It only needs them to boot, right?
19:35:49 <lispy> dsrogers: http://people.cs.uu.nl/andres/VersionControl.html
19:35:54 <lambdac> Title: A Principled Approach to Version Control
19:35:58 <SamB> that is, one in which you can model turing-complete langauges fairly well, without actually having nontermination per-se
19:36:11 <lispy> dsrogers: the second link there is not darcs patch theory, but its an attempt by some non-darcs folks to formalize the same sort of thing
19:36:30 <lispy> dsrogers: FWIW, their papre was rejected by the conference, but it's still informative
19:36:38 <noohgodno> > cos $ cos $ cos $ cos 5
19:36:39 <lambdac>  0.8400126809521591
19:36:54 <mauke> > iterate cos 5
19:36:55 <SamB> lispy: I think that actually means it has more chance of being useful for this
19:36:55 <lambdac>  [5.0,0.28366218546322625,0.9600369302946615,0.5734897326953653,0.84001268095...
19:37:03 <lispy> dsrogers: other places to find material on patch theory include the darcs-devel@darcs.net and darcs-users@darcs.net mailing lists
19:37:22 <lispy> SamB: which point are you referring to?
19:37:31 <SamB> the conf-reject status
19:38:02 <Cale> > cos . cos . cos . cos $ 5
19:38:03 <lambdac>  0.8400126809521591
19:38:18 <dsrogers> why does a lack of a theory prevent you from making darcs fast today?
19:38:30 <noohgodno> cale
19:38:34 <lispy> SamB: your logic is not obvious to me, but sure :)
19:38:38 <Cale> hello :)
19:38:46 <noohgodno> teach me haskell
19:38:55 <lispy> dsrogers: People have a very hard time discussing the algorithms.
19:38:58 <newsham> troll?
19:39:06 <b\6> but, it just takes 5 steps!!
19:39:13 <b\6> and 10 minutes!!
19:39:15 <SamB> lispy: well, I guess it's that they are more likely to have bitten off more than they could chew in a rejected paper ;-)
19:39:18 <noohgodno> news ham or new sham
19:39:19 <Cale> noohgodno: what would you like to know about Haskell?
19:39:44 <newsham> ?faq can haskell make noohgodno a better programmer?
19:39:44 <lambdac> The answer is: Yes! Haskell can do that.
19:40:04 <noohgodno> i'd like to learn it
19:40:04 <lispy> dsrogers: If you don't know which properties ensure that you have a correct implentation, then how can you try to optimize your techniques and pick clever algorithms.
19:40:21 <noohgodno> i understand things like a) functions b) currying c) the number '5'
19:40:22 <SamB> ?faq can STM unlaunch the nuclear missles I launched with unsafeIoToSTM?
19:40:22 <lambdac> The answer is: Yes! Haskell can do that.
19:40:40 <newsham> noohgodno: you can start with http://book.realworldhaskell.org/beta/
19:40:42 <lambdac> Title: Real World Haskell
19:40:47 <newsham> when you're done that, you can start learning haskell
19:40:55 <noohgodno> books != teachers
19:41:00 <SamB> hmm, d.h.o is down to 33 apache2 processes
19:41:08 <lispy> dsrogers: Another reason it's slow: Currently we have on operation we can work with, commute.  It's a swap of adjacent patches.  So when you try a merge you have to do this local operation (the swap) between patches to get differente permutations of the patch sequences.  But this is slow because you're searching for a global solution with a local operation.
19:41:54 <lispy> SamB: many apache processes could be caused by the slowness though.  If apache is unable to finish serving but people keep requesting at the same rate
19:42:19 <SamB> lispy: that probably doesn't do wonders for the speed?
19:42:21 <koninkje> is Hackage borked?
19:42:30 <newsham> noohgodno: one can only open the door.  its up to you to walk through it.
19:42:37 <SamB> back to 41 again :-(
19:42:57 <dino-> koninkje: Seems like, I was just trying to navigate Hackage just now as well.
19:43:03 <noohgodno> last time somebody said that to me IRL i spent about ten minutes explaining how stupid it was
19:43:25 <noohgodno> it's up to the teacher to adapt the lesson to fit the mental schema of the student
19:43:27 <dsrogers> lispy, are you in #darcs?
19:43:32 <lispy> dsrogers: yeah
19:43:32 <koninkje> that is to say, the packages part of it is borked. The main page seems fine
19:43:41 <dsrogers> let me switch to that, this is getting technical
19:43:53 <SamB> noohgodno: hmm, there is some truth in each
19:44:56 <noohgodno> this is, however, a very good book on the subject
19:45:47 <newsham> 10 minutes lost.
19:48:58 <tehgeekmeister> is there a convenient way to tell what libraries you've installed with cabal/remove them later?
19:49:16 <newsham> ghc-pkg list    will list your libs
20:02:21 <noohgodno> :?
20:04:07 <noohgodno> > (True && (True || (True && (True || False))))
20:04:09 <lambdac>  True
20:08:41 <noohgodno> > ((exp 1) ** pi) - pi
20:08:42 <lambdac>  19.99909997918947
20:13:23 <lispy> is there a way to make emacs kill all the extra spaces at the end of lines?
20:13:58 <lispy> I'm just looking for a quick way to do it
20:14:27 <dancor> don't know emacs, but sed 's/\s*$//'
20:15:18 <Korollary> delete-trailing-whitespace
20:16:10 <tehgeekmeister> trying to build HDBC-sqlite3 on my macbook pro i got this error, any idea what to do about it: command was: /opt/local/bin/ghc-6.6.1 -c -D__GLASGOW_HASKELL__=608 -I. dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c -o dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.o
20:16:30 <lispy> Korollary: thanks
20:16:35 <tehgeekmeister> oh, forgot to include the line above it
20:16:44 <tehgeekmeister> compiling dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c failed
20:17:25 <agentzh> hello, how to get static linking working for GHC 6.8.2 ?
20:18:03 <agentzh> i'm getting linking errors like "/usr/lib/gcc/i486-linux-gnu/4.2.3/../../../../lib/librt.a(timer_create.o): In function `timer_create':"
20:18:17 <agentzh> while specifying  -optl-static
20:19:09 <mmorrow> -optl-lrt
20:19:16 <agentzh> mmorrow: trying :)
20:19:54 <mmorrow> still having problems?
20:20:29 <agentzh> mmorrow: same erros
20:20:31 <agentzh> *errors
20:21:00 <mmorrow> what do the errors say?
20:21:04 <agentzh> mmorrow: i'm reading a related haskell-cafe thread: http://www.mail-archive.com/haskell-cafe@haskell.org/msg41717.html
20:21:06 <lambdac> Title: [Haskell-cafe] Re: static linking, http://tinyurl.com/55uohl
20:21:31 <agentzh> mmorrow: there seems to be a workaround mentioned there: "In brief: "rt" uses "pthread", but -lrt is the final thing on the  command line passed to the linker, and so the pthread symbols are not  resolved. Manually moving -lpthread to the end of the collect2 command  line does the trick. "
20:21:53 <agentzh> mmorrow: but i'm sure how to pass that flag to the collect2 utility :(
20:21:57 <agentzh> *i'm not sure
20:22:01 <mmorrow> hmm
20:22:11 <mmorrow> did you try adding -optl-lpthread ?
20:22:16 <agentzh> trying
20:22:32 <mmorrow> you may also need   -optl-lm -optl-lgmp
20:22:58 <agentzh> mmorrow: same
20:23:13 <agentzh> mmorrow: all specified but still the same error :)
20:23:58 <mmorrow> dang. whenever i try to staticly link something, it prob works 25% of the time. when it doesn't work, i don't usually even try to get it to (cut my losses tight there and then) ;)
20:24:11 <mmorrow> s/tight/right/
20:24:39 <mmorrow> but that's not to say that you can't/won't get it to work :)
20:24:39 <noohgodno> what's the equivalent to a substr() function in haskell
20:24:57 <dobblego> drop/take
20:24:59 <noohgodno> if you have a string or list, say "select items 10 to 20"
20:25:00 <cmcq> isInfixOf
20:25:05 <mmorrow> \ofs n -> take n . drop ofs
20:25:10 <noohgodno> <3
20:27:01 <noohgodno> > 33 `isInfixOf` 203958203933029385092
20:27:01 <lambdac>   add an instance declaration for (Num [a])
20:27:12 <noohgodno> > "33" `isInfixOf` "203958203933029385092"
20:27:13 <lambdac>  True
20:30:33 <agentzh> mmorrow: okay...
20:30:51 <agentzh> mmorrow: i'll try ghc 6.8.3 to see if things get any better...
20:38:06 <dmwit> ?src isInfixOf
20:38:06 <lambdac> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
20:38:12 <dmwit> so naive
20:38:27 <idnar> heh
20:38:42 <dmwit> There's *got* to be faster algorithms... right?
20:39:10 <atp> what's wrong with that?
20:39:21 <atp> it uses laziness perfectly fine
20:39:38 <dmwit> There's nothing wrong with it unless there's a faster (in the asymptotic sense) algorithm.
20:39:47 <atp> that one should be O(n)
20:39:50 <atp> hm
20:39:56 <noohgodno> faster in the asymptotic sense?
20:40:11 <dmwit> Well, something twice as fast wouldn't interest me.
20:40:15 <Pseudonym> There's no algorithm faster in the asymptotic sense than examining every element of the haystack.
20:40:26 <noohgodno> ah
20:40:36 <dmwit> atp: But it's O(mn), right?
20:40:43 <noohgodno> learning machine code makes you a better programmer
20:40:48 <Pseudonym> dmwit:
20:40:54 <Pseudonym> Yes, however...
20:41:03 <Pseudonym> Faster algorithms are O(m + f(n))
20:41:07 <Pseudonym> For some f
20:41:14 <Pseudonym> Which may not be faster than O(mn) depending on n.
20:41:27 <mxc2> but the f(n) part is just comparing strings for equality
20:41:33 <mxc2> how can that be faster than O(n)?
20:41:42 <atp> dmwit: you're right of course, sorry.
20:41:43 <Pseudonym> I believe, for example, that Knuth-Morris-Pratt is O(m + n62)
20:41:50 <Pseudonym> Uhm.
20:41:52 <Pseudonym> n^2
20:41:52 <mxc2> oh, wait, +, no * sry
20:41:54 * noohgodno actually understands you guys for once
20:42:17 <dmwit> Pseudonym: Hmm, which one is n?
20:42:21 <mxc2> complexity i get, categories, i categorically dont
20:42:21 <dmwit> needle?
20:42:25 <Pseudonym> Uhm... length of the needle.
20:42:43 <Pseudonym> ?go RunTimeCompilation
20:42:43 <dmwit> Pseudonym: I would think that would be a lot faster for most applications.
20:42:45 <lambdac> No Result Found.
20:43:00 <Pseudonym> dmwit: Maybe.
20:43:08 <noohgodno> Knuth-Morris-Pratt is basically a stripos function
20:43:11 <dmwit> I guess if n < sqrt m. =)
20:43:16 <Pseudonym> http://haskell.org/wikisnapshot/RunTimeCompilation.html
20:43:17 <Pseudonym> There it is.
20:43:17 <lambdac> Title: RunTimeCompilation
20:43:41 <Pseudonym> Also, some faster algorithms require Ord constraints rather than Eq.
20:43:48 <dmwit> ah, yeah
20:44:36 <tehgeekmeister> I've had a problem configuring a second library that uses the ffi, is there some known problem that could cause this?
20:45:17 <dmwit> Pseudonym: very cool
20:47:42 <Pseudonym> As noted, KMP is most efficient if you're looking for a needle in more than one haystack.
20:48:08 <Pseudonym> Another possibility is that you may be looking for several needles int he one haystack.
20:48:14 <Pseudonym> There comes a point where what you really want is regular expressions.
20:48:46 <dmwit> yah
20:49:10 <dmwit> Also O(m+n^2). =)
20:49:41 <Pseudonym> No, NFA building is O(n).
20:49:51 <Pseudonym> Or it can be.
20:49:53 <dmwit> Right, but you can be in up to n states at once.
20:50:01 <Pseudonym> Right, yes.
20:50:12 <Pseudonym> So that's O(mn + n)
20:50:23 <dmwit> oh
20:50:26 <Pseudonym> Because in general you might do O(n) work in computing the "next" states.
20:50:34 <dmwit> I'm a bit tired, you'll have to forgive my mental shortcuts.
20:50:44 <Pseudonym> That's assuming you're not using a backtracking algorithm.
20:50:52 <dmwit> yuck
20:51:02 <dmwit> Only people who want non-regular expressions do that.
20:51:04 <newsham> http://www.cs.rice.edu/~scrosby/hash/slides/USENIX-RegexpWIP.2.ppt
20:51:06 <lambdac> http://tinyurl.com/5f2ezg
20:51:22 <Pseudonym> newsham: What is this ppt thing?
20:51:35 <Pseudonym> Ah, open office does open it.
20:51:37 <newsham> its a popular format for slide presentations
20:52:24 <newsham> of course http://swtch.com/~rsc/regexp/regexp1.html
20:52:25 <lambdac> Title: Regular Expression Matching Can Be Simple And Fast
20:52:51 <Pseudonym> Indeed.
20:53:18 <Pseudonym> Incidentally, Thompson's thesis is a very pleasant read.
20:53:25 <noohgodno> k t?
20:53:43 <dmwit> newsham: That second link should be required reading for all CS students.
20:53:43 <newsham> he went to school?!
20:53:44 <Pseudonym> it's accessible to a bright undergraduate.
20:54:05 <noohgodno> pseudonym: link?
20:54:13 <Pseudonym> Oh, hang on.
20:54:17 <Pseudonym> No, different thesis.
20:54:37 <dmwit> And by "required", I mean, everybody should just stumble across it and read it on their own, so the enjoyment is not spoiled by psychological effects.
20:55:04 <tehgeekmeister> why would cabal be trying to use a version of ghc i don't have (6.6.1, to be specific) when i'm building certain packages that use the ffi?
20:55:50 <Pseudonym> Trying to find out which thesis I was thinking of.
20:56:04 <dmwit> tehgeekmeister: You could be linking against some library that's used base <3.
20:56:17 <dmwit> tehgeekmeister: Or, the cabal file could require a too-low version of base.
20:56:20 <dmwit> or some such thing
20:56:33 <tehgeekmeister> *looks at dependencies of packages
20:57:04 <noohgodno> this powerpoint sucks
20:57:27 <dobblego> pssst hackage is back, go!
20:57:33 * noohgodno sulks
20:57:52 <Pseudonym> https://cs.nyu.edu/web/Research/Theses/chang_chia-hsiang.pdf
20:57:56 <Pseudonym> That's the one I was thinking of.
20:58:17 <Pseudonym> Very pleasant red.
20:58:21 <Pseudonym> read
20:58:43 <noohgodno> anybody here into AI at all?
20:59:07 <tehgeekmeister> dmwit: when multiple options for dependencies are listed, if not all of the dependencies in one set of options are available, does cabal automatically switch to another option?
20:59:45 <dmwit> I don't really understand cabal, sorry.
21:00:07 <tehgeekmeister> okay
21:00:08 <tehgeekmeister> thanks
21:01:54 <dmwit> yikes, 242 pages
21:02:25 <dmwit> whoop, 10 pages to parse a regexp!
21:03:11 * dmwit glances at his <100 line regexp parser in Parsec
21:03:26 <newsham> backtracking?
21:13:02 <sw17ch> multi-parameter type classes are neato
21:13:30 <Cale> sw17ch: Aren't they?
21:14:14 <sw17ch> Cale: yes... i discovered some super magic with them tonight
21:14:33 <sw17ch> i've been needing a method to convert a type to a value
21:14:53 <sw17ch> and i was able to do it, but i was only able to convert it to one value per type class i used
21:15:05 <sw17ch> enter multi-parameter type classes... and... bam! everything
21:18:00 <sw17ch> ?seen quicksilver
21:18:00 <lambdac> quicksilver is in #haskell. I last heard quicksilver speak 11h 51m 12s ago.
21:18:46 <dons> here's an interesting one, http://www.reddit.com/comments/6w33e/solving_minesweeper_via_a_neural_network_in/
21:18:47 <mmorrow> sw17ch: so are you gonna to paste some code or leave we guessing? :)
21:18:48 <lambdac> Title: Solving Minesweeper via a neural network in Haskell : reddit.com, http://tinyurl.com/5wopks
21:18:51 <sw17ch> http://hpaste.org/9573
21:19:00 <sw17ch> mmorrow, ^^
21:19:03 <mmorrow> haha
21:19:07 <mmorrow> read my mind
21:19:07 <sw17ch> @tell quicksilver http://hpaste.org/9573
21:19:08 <lambdac> Consider it noted.
21:20:04 <sw17ch> i had a problem where i needed to mark a pointer as a specific type of pointer, but also inform the underlying function which *creates* the pointer what pointer type to create
21:20:14 <sw17ch> the underlying function is called through the FFI and takes a void* as the parameter
21:20:52 <sw17ch> so i had to call the c function with an Enum value representing the format, but have my allocaArray specify a very similar value as the array type
21:21:13 <sw17ch> and i was basically writing the same information twice in a way that relied on me not being stupid
21:21:26 <sw17ch> hence, the code to make a Type into a Value
21:21:52 <mmorrow> cool
21:22:04 <mmorrow> have you seen the Storable class?
21:22:22 <sw17ch> That's what i'm using mmorrow
21:22:40 <sw17ch> that wasn't the issue though
21:23:03 <sw17ch> I needed a method ot make something like Word8 into a value such as 0x4
21:23:23 <sw17ch> also specifying that my allocaArray is going to be allocating Word8's
21:23:44 <mmorrow> err, not saying that, was just drawing a parallel between the method you're using with the PaType class and how Storable uses sizeOf to map types to their representation's size in bytes :)
21:23:58 <sw17ch> ohhh :)
21:24:03 <sw17ch> yes, that's where i stole the idea from :)
21:24:07 <mmorrow> hehe
21:25:12 <sw17ch> the only funny thing i do'nt like is that `mkStream 1 5' has the same effect as `mkStream 1 2312491241401'
21:25:26 <sw17ch> except less than 2^16
21:26:50 <newsham> class TypeIndex a where typeindex :: a -> Int  ?
21:27:40 <sw17ch> newsham, does that exist?
21:27:56 <sw17ch> it appears no
21:28:01 <sw17ch> but yes, that's what i did
21:28:14 <sw17ch> the multiparameter one is more fun though
21:28:39 <sw17ch> class TypeIndex a b | a -> b where typeIndex :: a -> b
21:29:16 <stulli> > (+1) <$> [1,2,3]
21:29:17 <lambdac>  [2,3,4]
21:29:19 <sw17ch> then you get a type to *any* value in the same instance
21:29:35 <sw17ch> without needing separate type classes
21:55:00 <noohgodno> i keep walking into #haskell and ending up in #math
21:55:14 <glguy> maybe a redirecting ban?
21:55:26 <noohgodno> you're so mean glguy
21:56:41 <SamB> noohgodno: seriously?
21:56:59 <noohgodno> which part seriously
21:57:14 <dons> glguy loves ironic redirecting bans
21:57:23 <noohgodno> no, i'm saying my investigations into haskell turn into investigations of logic and math
21:57:29 <SamB_XP> ah
21:57:46 <glguy> ha, samb asks, SamB_XP understands
21:57:54 <glguy> you'll have to explain it to yourself now
21:57:55 <noohgodno> ;O
21:58:20 <noohgodno> glguy didn't i argue against your ban in #arch
21:58:27 <noohgodno> or was that arguing with you about somebody else's ban
21:58:31 <dons> glguy got banned in arch?!
21:58:37 <dons> where's my interrobang. grr.
21:58:39 <noohgodno> either way, the scars of experience run deep
21:59:01 <glguy> I don't know what you are talking about but it certainly doesn't relate to this channel
21:59:18 <dons> ooh
22:00:34 <jberg> hey, when i try hitting C-c C-l in emacs it says cannot open load file inf-haskell
22:00:42 <jberg> does anyone know what that means?
22:00:45 <jberg> ghci is in my path
22:01:19 <TSC> inf-haskell is a emacs lisp file
22:01:24 <stepcut> jberg: your haskell-mode install sounds screwy
22:01:26 <TSC> Is it in your load-path?
22:02:20 <jberg> stepcut: well i just copied what i had in my last .emacs from my old pc to this one
22:02:34 <jberg> TSC: ah ok. hmm
22:03:19 <stepcut> jberg: perhaps haskell-mode 2.4 is not installed on your new pc ?
22:03:50 <jberg> (load "~/lib/emacs/haskell-mode-2.4/haskell-site-file")
22:04:12 <jberg> stepcut: yep, just installed it and put it in ~/lib/emacs/haskell-mode-2.4
22:04:25 <jberg> but i have no haskell-site-file there
22:04:38 <TSC> You might want the CVS version
22:04:40 <jberg> only haskell-site-file.el
22:05:00 <jberg> TSC: hm ok
22:08:43 <jberg> i added (require 'inf-haskell) and now it seems to work
22:10:02 <dmwit> (require 'inf-erior-to-vim)
22:10:04 <dmwit> ;-)
22:10:40 <jberg> does vim have a better haskell mode?
22:13:29 <tehgeekmeister> how speedy is hxml?
22:13:36 <tehgeekmeister> anyone have experience using it on large files?
22:15:01 <dmwit> jberg: Not really, no.
22:15:15 <dmwit> Just the usual banter.
22:15:30 <jberg> okay :)
22:31:15 <agentzh> it seems that ghc 6.8.2 needs a quite recent linux
22:31:46 <dmwit> oh?
22:31:56 <agentzh> our production machine is Linux jf1.search.cnb.yahoo.com 2.6.9-42.ELsmp #1 SMP Wed Jul 12 23:27:17 EDT 2006 i686 i686 i386 GNU/Linux
22:32:48 <agentzh> but i'm getting the famous "timer_create: Invalid argument " error here while invoking either GHC or binaries generated by GHCs on another linux.
22:33:12 <agentzh> would recompiling GHC from source on that old linux system help?
22:35:57 <sjanssen> agentzh: I don't see how you'll build GHC without a working GHC
22:36:10 <agentzh> sjanssen: indeed...
22:36:13 <SamB> sjanssen: maybe he could use an older one ?
22:36:29 <sjanssen> SamB: yeah, true
22:36:36 <sjanssen> agentzh: does 6.6 work on your system?
22:36:45 <agentzh> sjanssen: haven't tried yet
22:36:48 <agentzh> sjanssen: will do
22:36:59 <Korollary> 2.6.9 is not that old. I ran the generic linux binaries on older kernels
22:37:17 <agentzh> Korollary: oh?
22:38:09 <agentzh> recompiling GHC seems to be even more painful than upgrading the system...
22:40:05 <Korollary> I recently recompiled GHC for x86 and x86-64 on an older kernel without any hassle. As long as gmp and readline libraries match, it's pretty easy going.
22:40:57 <jberg> hmm, i want to do "symbolic computation" kind of like lisp. that is, i just want a list of symbols, like a list of Coins, can i do that?
22:41:04 <jberg> Coin is nothing really, just a Coin
22:42:57 <agentzh> Korollary: ldd the ghc-6.8.3 binary gives: /usr/bin/ldd: line 124: 16478 Floating point exceptionLD_TRACE_LOADED_OBJECTS=1 LD_WARN= LD_BIND_NOW= LD_LIBRARY_VERSION=$verify_out LD_VERBOSE= "$@"
22:43:05 <Korollary> jberg: data Coin = Coin good enough?
22:43:20 <jberg> Korollary: hm yeah, i guess :)
22:44:24 <Korollary> agentzh: I've never seen ldd cause a floating point exception before. What does the 'file' util say about the ghc binary?
22:45:13 <agentzh> Korollary: /ghc-6.8.3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), not stripped
22:45:23 <visof> > let solve n = [ x | x <- [2..n], n `mod` x == 0, prime x] in last $ solve 600851475143
22:45:24 <lambdac>   Not in scope: `prime'
22:45:49 <visof> this solution very slow foe me
22:46:01 <visof> is there another one to get faster one ?
22:46:07 <visof> c/foe/for
22:46:36 <jberg> visof: a sieve maybe?
22:47:00 <mmorrow> agentzh: i tried to use the 6.8.3 binary to build a 6.8.3 from src on this server i just got hosting on, and the same thing happened
22:47:00 <visof> i don't know
22:47:23 <agentzh> mmorrow: the floating point exception thing?
22:47:25 <visof> jberg it's euler problem
22:47:33 <agentzh> mmorrow: or the create_timer error?
22:47:34 <jberg> visof: google for prime sieve
22:47:45 <mmorrow> agentzh: yeah. it's CentOS. i ended up installing ghc6.4 (the newest centos yum had), then used that 6.4 to build a 6.8.3 from src
22:47:57 <agentzh> okay...
22:48:01 <visof> jberg i know how can i implement prime
22:48:08 <mmorrow> Igloo said it was because my libc.so was too old, but i dunno
22:48:22 <visof> jberg but the solution is very very slow for large numbers
22:48:28 <visof> i need faaster one
22:48:32 <agentzh> mmorrow: *nod*
22:48:33 <mmorrow> (building 6.8.l3 with 6.8.4 took hours :))
22:48:44 <mmorrow> s/6.8.13/6.8.3/
22:48:47 * agentzh knows that :P
22:49:06 <mmorrow> but building 6.8.3 with 6.8.3 take ~20min
22:49:11 <mmorrow> *takes
22:49:21 <visof> if i make the program with c , will it be faster than haskell ?
22:49:35 <agentzh> visof: theoretically yes
22:50:02 <visof> agentzh what do you mean with theoretically ?
22:50:17 <visof> is it be actually ?
22:50:31 <mmorrow> visof: depends how you write it i guess
22:50:37 <visof> ah
22:50:49 <visof> in haskel too
22:50:53 <visof> haskell*
22:51:02 <mmorrow> heh, yesh
22:51:11 <sjanssen> dons: started writing parallel versions of the shootout problems yet? :P
22:51:58 <tehgeekmeister> how do i open a file as a bytestring?
22:52:19 <dons> sjanssen: actually...
22:52:23 <sjanssen> tehgeekmeister: readFile, openFile?
22:52:30 <sjanssen> @hoogle openFile
22:52:30 <lambdac> A Hoogle error occured.
22:52:56 <tehgeekmeister> oh!  right, sorry
22:52:57 <mmorrow> tehgeekmeister: you'd open it as usual and use Data.ByteString.hGet ?
22:53:00 <visof> this is my solution http://hpaste.org/9575
22:53:12 <tehgeekmeister> i haven't used haskell in far too long and so i'm relearning a lot
22:53:13 <visof> i need faster than this in haskell
22:53:14 <tehgeekmeister> thanks
22:53:25 <dons> sjanssen: port some of these? http://www.macs.hw.ac.uk/~dsg/gph/nofib/
22:53:26 <sjanssen> dons: actually... yes?  binary-trees has tons of inherent parallelism
22:53:26 <lambdac> Title: Glasgow Parallel Haskell Algorithms Repository
22:53:37 <dons> sjanssen: yeah. 'zactly.
22:53:52 <dons> want to traverse a tree in parallel?
22:54:01 <sjanssen> you can also build in parallel
22:54:14 <dons> oh, nice idea.
22:54:18 <dons> yeah, speed up that strictness cost.
22:54:32 <dons> actually, that's begging for `par`, and is going to be damn awkward elsewhere.
22:54:38 <sjanssen> exactly
22:54:40 <dons> without lots of yucky locks.
22:55:02 <dons> and with the memory traffic hiding latency
22:55:24 <sjanssen> Java beats us on the P4 box, but I bet we can be at least 2x faster than Java on the quad core
22:55:27 <noohgodno> anybody here ever written a fast fourier transform implementation for PCM modification, or anything like that?
22:56:06 <dons> oh, java's improvement there is interesting.
22:56:15 <dons> noohgodno: there's a binding to fftw if you need it.
22:56:51 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=all
22:56:55 <lambdac> Title: binary-trees benchmark | x64 Ubuntu : Intel&#174; Q6600&#174; Computer Language  ..., http://tinyurl.com/69l8ag
22:57:05 <dons> yeah, i think that's a good one to start with , sjanssen
22:57:26 <dons> you take the current fast one, and we'll have the first true parallel implementation
22:57:29 <sjanssen> they don't even have GHC listed there, what is up with that?
22:57:35 <dons> i asked igouy, he's just lazy :)
22:57:53 <dons> so the parallelism we're seeing so far is just paralell GCs.
22:58:00 <dons> like java.
22:58:27 <dons> none of them have yet been parallelised.
23:02:15 <agentzh> anyone knows where the Makefile generated by GHC on-the-fly is?
23:02:45 <agentzh> i want to do the link manually to solve some weird symbol missing errors...
23:03:10 <dons> in .depend ? /me tries to remember.
23:03:46 <jberg> in order to create all the unique permutations of say 5 Coins, do i have create all non-unique permutations and then filter out non-unique sequences? or is there an algorithm that creates just unique sequences?
23:04:48 <TSC> What's a non-unique permutation?
23:04:54 <agentzh> dons: which directory?
23:06:10 <erikc> heh, the shootout for that bencmark is comical in that they reject pooled allocation implementations
23:06:12 <jberg> TSC: well say i want permutations of 3 Coins [[CCC]] [[C][CC]] [[CC][C]] those last two are the same
23:07:00 <TSC> Oh, partitions
23:07:06 <dmwit> visof: Why not run the other direction?
23:07:18 <jberg> yes, that might be what its called
23:07:24 <dmwit> "let solve n = [ x | x <- [2..n], n `mod` x == 0, prime x] in last $ solve 600851475143"
23:07:47 <dmwit> Try "let solve n = [x | x <- [n, n-1 .. 2], n `mod` x == 0, prime x] in ..."
23:08:27 <dmwit> Also, why are you testing every number?
23:08:35 <dmwit> Why not build a list of primes, and just test those?
23:09:28 <dmwit> or... that might be slower, now that I think about it.
23:10:55 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [1..n] in factors 7
23:10:56 <lambdac>  [1,7]
23:11:03 <visof> dmwit what do you mean ?
23:11:21 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [n, n-1 .. 1] in factors 7
23:11:23 <lambdac>  [7,1]
23:11:30 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [n, n-1 .. 1] in factors 600851475143
23:11:36 <lambdac>  [600851475143Exception: Time limit exceeded
23:11:39 <Quadrescence> dmwit: You can create a sieve pretty fast.
23:11:52 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [1..n] in factors 600851475143
23:11:57 <jberg> TSC: do you know if its possible to just generate unique partitions?
23:11:58 <lambdac>  [1,71,839,1471,6857,59569,104441,486847,1234169,5753023,10086647Exception: T...
23:12:14 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [1..n] in nubBy (\x y -> y `mod` x == 0) $ factors 600851475143
23:12:20 <lambdac>  [1Exception: Time limit exceeded
23:12:30 <dmwit> ...what.
23:12:44 <yaru1022`> hi, has anyone successfully built hsp package using ghc-6.8.3?
23:12:46 <dmwit> oh
23:12:52 <dmwit> > let factors n = filter (\x -> n `mod` x == 0) [2..n] in nubBy (\x y -> y `mod` x == 0) $ factors 600851475143
23:12:58 <lambdac>  [71,839,1471,6857Exception: Time limit exceeded
23:14:47 <dmwit> > let divides x y = mod y x == 0; factors n = filter (divides n) [2..n] in last . nubBy divides . factors $ 600851475143 -- generates the answer, but slowly
23:14:53 <lambdac>  Exception: Time limit exceeded
23:16:49 <dmwit> Yeah, generating the primes up to 600851475143 is definitely not going to be feasible.
23:17:11 <dmwit> Can you use one of the fast (and sometimes wrong) primality tests?
23:19:51 <visof> dmwit i'm trying to write it in c
23:20:09 <visof> i can't
23:20:13 <dmwit> > let powMod b 1 m = b `mod` m; powMod b n m | even n = ((powMod b (n `div` 2) m) ^ 2) `mod` m | odd n = (b * powMod b (n - 1) m) `mod` m in powMod 3 5 2
23:20:14 <lambdac>  1
23:21:38 <dmwit> > let powMod b 1 m = b `mod` m; powMod b n m | even n = ((powMod b (n `div` 2) m) ^ 2) `mod` m | odd n = (b * powMod b (n - 1) m) `mod` m; isPrime x = all (\b -> powMod b (x - 1) x) [2..x - 1] in isPrime 600851475143
23:21:39 <lambdac>   add an instance declaration for (Integral Bool)
23:21:39 <lambdac>     In the expression: powM...
23:21:51 <dmwit> > let powMod b 1 m = b `mod` m; powMod b n m | even n = ((powMod b (n `div` 2) m) ^ 2) `mod` m | odd n = (b * powMod b (n - 1) m) `mod` m; isPrime x = all (\b -> powMod b (x - 1) x == 1) [2..x - 1] in isPrime 600851475143
23:21:52 <lambdac>  False
23:22:08 <dmwit> > let powMod b 1 m = b `mod` m; powMod b n m | even n = ((powMod b (n `div` 2) m) ^ 2) `mod` m | odd n = (b * powMod b (n - 1) m) `mod` m; isPrime x = all (\b -> powMod b (x - 1) x == 1) [2..x - 1] in all isPrime [2,3,5,7,11,13,17,19]
23:22:09 <lambdac>  True
23:22:25 <dmwit> ?let powMod b 1 m = b `mod` m
23:22:26 <lambdac> Defined.
23:22:32 <Elly> generating the primes up to 6x10^12 is going to take a lot of runtime
23:22:49 <Elly> especially since the fastest algorithm for numbers of that size is probably trial division :\
23:22:58 <dmwit> ?let powMod b n m | even n = ((powMod b (n `div` 2) m) ^ 2) `mod` m | odd n = (b * powMod b (n - 1) m) `mod` m
23:22:59 <lambdac> Defined.
23:23:16 <dmwit> ?let isPrime x = all (\b -> powMod b (x - 1) x == 1) [2..x - 1]
23:23:17 <lambdac> Defined.
23:23:32 <dmwit> > all (not . isPrime) [1,4,6,8,9,10,12,14,18]
23:23:33 <lambdac>  False
23:23:37 <dmwit> whoops
23:23:40 <dmwit> > map (not . isPrime) [1,4,6,8,9,10,12,14,18]
23:23:41 <Elly> do you just want to know if 600851475143 is prime?
23:23:41 <lambdac>  [False,True,True,True,True,True,True,True,True]
23:23:55 <dmwit> Elly: We want the largest prime factor of 600...
23:23:58 <Elly> oh
23:24:10 <Elly> start at the square root and work downwards
23:24:17 <Elly> the square root is 775146
23:24:21 <Elly> so it should be trivial
23:24:36 <Elly> actually
23:24:40 <dmwit> It can have prime factors larger than its square root.
23:24:42 <Elly> starting at 1 and working up will work better
23:24:53 <dmwit> But you're saying, factor it?
23:24:55 <Elly> yeah, but the smallest prime divisor is multiplied by the largest prime divisor :P
23:24:59 <Elly> sure
23:25:06 <Elly> you can stop when you hit 775146
23:25:09 <|Steve|> dmwit: Uh, got an example?
23:25:13 <Elly> so it won't take that long
23:25:15 <dmwit> |Steve|: Of what?
23:25:24 <|Steve|> Oh, sorry, misread.
23:25:34 <|Steve|> Ignore me.
23:25:44 <Elly> dmwit: however, each prime factor larger than the square root has to be multiplied with one smaller than the square root
23:25:53 <Elly> so enumerating the factors below the square root is sufficient
23:26:07 <dmwit> hmm
23:26:16 <dmwit> How do you find the ones that correspond to the small ones?
23:26:17 <|Steve|> Elly: Sure.
23:26:22 <Elly> dmwit: divide :)
23:26:29 <dmwit> I don't think that works.
23:26:32 <Elly> why not?
23:26:40 <dmwit> Consider 2*2*13*17.
23:26:44 <Elly> okay
23:26:45 <dmwit> > sqrt (2*2*13*17)
23:26:46 <lambdac>  29.732137494637012
23:26:50 <Elly> so you test 2
23:26:53 <Elly> and you notice it divides in
23:27:01 <dmwit> hold on, let me think a second.
23:27:03 <|Steve|> dmwit: Er, not a very good example there.
23:27:05 <Elly> now you factor 2 * 13 * 17 by the same process?
23:27:13 <dmwit> |Steve|: right =P
23:27:15 <|Steve|> Elly is correct.
23:27:51 <visof> Elly i can't understand
23:28:04 <visof> can you show by Example ?
23:28:13 <Elly> um
23:28:50 <|Steve|> > sqrt (2*7)
23:28:52 <lambdac>  3.7416573867739413
23:28:57 <Elly> dmwit: hm, the smallest divisor does not always multiply into the largest prime factor though
23:29:08 <Elly> dmwit: or at least...I can't prove that it does
23:29:22 <dmwit> It had better not multiply into the largest prime factor.
23:29:27 <dmwit> That's what prime means. =)
23:29:32 <Elly> multiply *by*, rather
23:29:37 <Elly> to create the original number
23:29:46 <dmwit> I claim there can be at most one prime factor greater than the square root.
23:29:52 <dmwit> Proof left as exercise. =)
23:29:56 <Elly> hm
23:30:11 <Elly> yes, obviously
23:30:15 * dmwit nods
23:30:27 <dmwit> You can even s/factor//
23:30:34 <dmwit> err... s/prime//
23:30:39 <|Steve|> Let p be the largest prime larger than sqrt(n) with n = pa. Then either a is prime, or a contains prime factors. Recurse.
23:30:49 <xd> 6857
23:30:49 <Pseudonym> dmwit: Not true.
23:30:55 <dmwit> oh
23:30:57 <dmwit> right
23:30:58 <Pseudonym> For most numbers, there are plenty of factors greater than the square root.
23:30:58 <|Steve|> Actually, you don't need the larger than sqrt(n).
23:31:02 <dmwit> bah
23:31:12 <Elly> suppose there were two prime factors a and b > sqrt(n); then n >= a * b -> n > (sqrt(n) * sqrt(n)) -> false
23:31:17 <dmwit> Mental shortcuts are WRONG, when will I learn?
23:31:49 <Cale> There are not many smallest prime factors larger than the square root though.
23:32:06 <dmwit> Cale: We want the largest prime factor...
23:32:31 <Pseudonym> Cale: Right, at most one.
23:32:33 <Elly> Cale: there are no smallest prime factors larger than the square root
23:32:48 <Cale> Elly: unless it's prime itself
23:32:50 <|Steve|> Unless the number is prime.
23:32:51 <Elly> oh
23:32:52 <|Steve|> bah
23:32:52 <Elly> well, yes
23:32:53 <Pseudonym> Bingo.
23:33:17 <|Steve|> I knew someone was going to make that objection. I should have had the response typed already.
23:33:31 <Elly> dmwit: you don't want to search up from the square root, but I think you can iterate th process I described
23:33:34 <dmwit> Factoring 600851475143 is pretty fast!
23:33:49 <|Steve|> 600851475143: 71 839 1471 6857
23:33:49 <noohgodno> somebody factor 600851475143 with lambdac
23:33:56 <dmwit> no problem!
23:34:09 <xd> i did it in a couple seconds with some random project euler code i had lying around
23:34:23 <Elly> there you go
23:34:26 <dmwit> > let let factor x p sq | p > sq = [x] | x `mod` p == 0 = p : factor (x `div` p) p sq | otherwise = factor x (p + 1) sq; fact x = factor x 2 (floor . sqrt . fromIntegral $ x) in fact 600851475143
23:34:26 <lambdac>  Parse error at "let" (column 5)
23:34:26 <Pseudonym> > [ f | f <- [2:3,5..], 600851475143 `mod` f == 0 ]
23:34:27 <|Steve|> couple of seconds? wow. How about just using the unix factor binary?
23:34:27 <lambdac>   add an instance declaration for (Integral [t])
23:34:28 <noohgodno> that site is eating up my soul
23:34:32 <Elly> we saved a few seconds of coding with 20 minutes of thought :P
23:34:35 <dmwit> > let factor x p sq | p > sq = [x] | x `mod` p == 0 = p : factor (x `div` p) p sq | otherwise = factor x (p + 1) sq; fact x = factor x 2 (floor . sqrt . fromIntegral $ x) in fact 600851475143
23:34:36 <lambdac>  [71,839,1471,6857,1]
23:34:45 <noohgodno> wow
23:34:51 <noohgodno> > let factor x p sq | p > sq = [x] | x `mod` p == 0 = p : factor (x `div` p) p sq | otherwise = factor x (p + 1) sq; fact x = factor x 2 (floor . sqrt . fromIntegral $ x) in fact 6008563406340637469823746928347
23:35:00 <Pseudonym> > [ f | f <- 2:[3,5..], 600851475143 `mod` f == 0 ]
23:35:00 <lambdac>  [19,71,79,6757033Exception: Time limit exceeded
23:35:04 <noohgodno> :]
23:35:07 <lambdac>  [71,839,1471,6857,59569,104441,486847,1234169,5753023,10086647Exception: Tim...
23:35:09 <|Steve|> You can do it faster by not checking evens.
23:35:21 <dmwit> > 19 * 71 * 79 * 6757033
23:35:22 <lambdac>  720103763843
23:35:24 <|Steve|> So find all factors of 2 and then just try odds up to sqrt n.
23:35:39 <Pseudonym> In general, you can use wheel factoring to eliminate more possibilities.
23:35:45 <noohgodno>  > [ f | f <- 2:[3,5..], 6008563406340637469823746928347 `mod` f == 0 ]
23:35:53 <dmwit> |Steve|: Yep, and then you can improve by not checking multiples of 3, and then you can improve by not doing multiples of 5, and then...
23:36:11 <Quadrescence> But 2 is trivial.
23:36:18 <Quadrescence> As in easy.
23:36:19 <|Steve|> Pseudonym: Wheeling being the sieve of Erostastines? No idea how to spell it, spell check suggests Tastiness.
23:36:26 <dmwit> similar
23:36:30 <Elly> Eratosthenes?
23:36:32 <noohgodno> did i break lambdac
23:36:37 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/
23:36:39 <lambdac> Title: Index of /darcs/numbertheory/Math
23:36:39 <Quadrescence> Elly: Yep
23:36:43 <dmwit> noohgodno: No, you just had an extra space in front.
23:36:44 <|Steve|> dmwit: I actually wrote that once using filter. It's not really a good idea.
23:36:49 <noohgodno> > [ f | f <- 2:[3,5..], 6008563406340637469823746928347 `mod` f == 0 ]
23:37:03 <|Steve|> After finding p primes, you  have p filters running over the list. =)
23:37:07 <lambdac>  thread killed
23:37:08 <Quadrescence> |Steve|: Hahahah
23:37:18 <dmwit> http://haskell.org/haskellwiki/Prime_numbers
23:37:45 <koninkje> :t split
23:37:52 <noohgodno> <3 haskell
23:37:53 <lambdac> Title: Prime numbers - HaskellWiki
23:37:53 <lambdac> forall g. (RandomGen g) => g -> (g, g)
23:37:56 <Quadrescence> Guys, just implement a simple elliptic curve or general number field sieve. jeez.
23:38:49 <Elly> "...and an example of Template Haskell to defeat your enemies."
23:40:55 <|Steve|> I did implement some randomized primality test in Haskell to test PRNGs.
23:42:27 <|Steve|> I ran it on millions of large numbers, it correctly got not prime after at most 2 tries except for one horrible PRNG that had 1 bit that was completely predictable (it flipped every time) which took much longer on a few, as I recall.
23:47:24 <Pseudonym> @let s2 p0 q0 q1 n = let { isn = floor.sqrt.fromIntegral$n; b1 = (isn + p0) `div` q1; p1 = b1*q1 - p0; q2 = q0 + b1*(p0-p1) } in if p0 == p1 then gcd p1 n else s2 p1 q1 q2 n
23:47:25 <lambdac> Defined.
23:47:34 <Pseudonym> @let s1 p0 q0 q1 n = let { isn = floor.sqrt.fromIntegral$n; sq1 = floor.sqrt.fromIntegral$n} in if sq1*sq1 == q1 then let { b0 = (isn-p0) `div` sq1; np0 = b0 * sq1 + p0; nq0 = sq1; nq1 = (n - np0*np0) `div` nq0 } in s2 np0 nq0 nq1 n else let { b1 = (isn + p0) `div` q1; p1 = b1*q1 - p0; q2 = q0 + b1*(p0-p1) } in s1 p1 q1 q2 n
23:47:35 <lambdac> Defined.
23:47:46 <Pseudonym> @let squfof n = let isn = floor.sqrt.fromIntegral$n in s1 isn 1 (n-isn*isn) n
23:47:48 <lambdac> Defined.
23:47:58 <Pseudonym> > squfof 6008563406340637469823746928347
23:48:06 <lambdac>  Exception: Time limit exceeded
23:48:10 <Pseudonym> Dammit.
23:48:16 * noohgodno pokes pseudonym
23:48:50 <Pseudonym> GNFS was too hard to type in @let
23:48:58 <Pseudonym> This was the best I could do, so cut me a break, okay?
23:49:15 <Pseudonym> > squfof 600851475143
23:49:22 <lambdac>  Exception: Time limit exceeded
23:50:00 <Pseudonym> > squfof (11*17)
23:50:07 <lambdac>  Exception: Time limit exceeded
23:50:13 <Pseudonym> Ah, I think we have a bug.
23:55:32 <Elly> squfof?
