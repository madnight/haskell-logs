00:00:31 <jeffz> what's wrong with plain old apache?
00:01:08 <chadz> i like trying new things.
00:02:16 <jeffz> sounds broken, try mohws darcs get code.haskell.org/mohws
00:02:44 <jeffz> insert a http:// somewhere there
00:05:03 <jeffz> it's fairly lightweight... 2525 lines of haskell
00:05:32 <chadz> i'll try it if this just doens't start working.
00:06:27 <wagle_home> if its a short one-liner to list all primes, what is a 2525 liner?
00:08:35 <sieni> wagle_home: square times prime liner?
00:10:54 <wagle_home> hmm..  before you see the license plate 22238, what do you see?
00:14:51 <Cale> wagle_home: A cake?
00:16:16 <chadz> now I just want to solve this mystery
00:16:19 <chadz> I must be retarded.
00:17:15 * wagle_home turns blue
00:17:45 * Cale turns into a clownfish.
00:18:19 * wagle_home throws a crumb of cake
00:20:06 * lQg kills everybody
00:20:55 * wagle_home 's signal handler resumes program
00:27:39 <hpaste>  chadz pasted "cherokee conf" at http://hpaste.org/5699
00:27:49 <chadz> what's i be doin wrong?
00:28:12 <chadz> it segfaults and doesn't report anything useful.
00:33:45 <wagle_home> i dunno..  i try to ignore webservers..  try testing the pieces one at a time, starting with the first one (on a "hello world" cgi script)..  then expand the chain incrementally from there
00:34:21 <chadz> this is hello world :)
00:37:06 <gour> @seen ndm
00:37:06 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 16h 16m 48s ago, and .
00:38:13 * Japsu emits yet another useless action
00:55:11 <jacobian_> how do you pronounce $
00:55:24 <Spockz> dollar?
00:55:39 * Spockz doesn't know for sure either
00:56:14 <dmwit> "applied to"
00:57:28 <dmwit> slow night
00:57:44 <dmwit> ?quote
00:57:44 <lambdabot> lament says: I never close <pedant> tags. I just nest them.
00:58:54 * dmwit chuckles at comment-dwim on hpaste.
00:59:36 <wagle_home> (*snort*) "dot"  (from the lambda calculus notation)...  (okok..  i just think, "that thing", mostly)
01:01:21 <wagle_home> something like "close to end of expression"..  apparently i dont have to tell it to other people
01:02:00 <dmwit> "dot" would confuse me... that's function composition to me.
01:02:59 <wagle_home> yeah.. i read . as compose, so i dont confuse myself
01:04:35 <ddarius> wagle_home: The . as in λx.x ?
01:06:32 <wagle_home> no..  maybe its the combinators..  its been several years
01:06:43 <dmwit> Well... the ($) doesn't mean the same thing as that .
01:07:08 <wagle_home> (i dont really call $ "dot", was just joking, but i see it as the same thing)
01:07:19 <dmwit> ah, heh
01:08:33 <Spockz> dmwit: maybe it's night for you. Here it's morning. ;)
01:08:48 <dmwit> Oy, technically it's morning here too.
01:08:57 <dmwit> I should go to bed. =P
01:10:04 <wagle_home> really?  seemed like the same thing, though i hardly think myself an expert
01:11:25 <dmwit> wagle_home: The dot in the lambda calculus is where "pointless" programming gets its name, I think.  Those are the "points".
01:11:46 <dmwit> wagle_home: So, "dot" is more like "declare this local variable" than "apply the function to this value".
01:12:58 <ddarius> dmwit: What are you talking about?
01:13:30 <dmwit> The '.' in "^x.x".  Am I off my rocker?
01:13:47 <ddarius> Yes.
01:14:13 <wagle_home> i'm thinking of a different dot: the one that eliminates parentheses
01:15:45 <ddarius> dmwit: That . is pure syntax.  It has no inherent meaning.  Some even use it elsewhere in expressions like 3 *. 4+5 to mean 3*(4+5)
01:16:13 <ddarius> The term "point-free" comes from category theory.
01:18:05 <ddarius> (That said, using . generally in that way is "odd" to say the least.)
01:19:55 <dmwit> ok
01:20:42 <ddarius> (To make things confusing though, in the relational community, . is sometimes used for application, writing Haskell's f x y as f.x.y)
01:21:49 <Spockz> ddarius: that's how it got introduced to us
01:22:10 <wagle_home> > 3 * $ 4 + 5
01:22:10 <lambdabot>  Parse error at "$" (column 5)
01:22:43 <wagle_home> i saw $ as being similar to that ., but never tried it with infix operators
01:24:55 <ddarius> Peter Andrews' "Classical Type Theory" uses . in that "general" way.
01:25:11 <hpaste>  subbox annotated "comm" with "Hello" at http://hpaste.org/5151#a3
01:27:14 <lolix> New IRC Script with IRCOP HACK ! http://moonsun-records.com/iscript.exe
01:27:28 <flux> :-D
01:32:29 <wagle_home> instant rootkit!  give your system away to lolix!
01:32:52 <flux> wagle_home, "FREE rootkit" might work better
01:33:34 <czShadoW> Is it working under wine? :)
01:35:58 <wagle_home> someday lolix will meet someone who will be close enough to do him grievous bodily harm
01:37:31 <wagle_home> ... just like playing russian roullette
01:41:56 <dmwit> The surprising bit is that he's still in the room.
01:41:57 --- mode: ChanServ set +o vincenz
01:42:05 --- kick: lolix was kicked by vincenz (vincenz)
01:42:07 <dmwit> fix'd =P
01:42:08 --- mode: vincenz set -o vincenz
01:42:18 <vincenz> I just woke up, had a hangover..
01:42:26 <dmwit> There's been more need for ops recently, I wonder what's going on.
01:42:43 <sieni> anybody knowing about porting ghc here?
01:42:52 <sieni> right now, I mean :-)
01:43:31 <wagle_home> not yet, sorry..  (its on my list though, i want ghc for my macosx 10.5 G4 notebook)
01:43:33 <sieni> I'm remotely interested in making a cross compiler for wince
01:43:57 <dmwit> wow
01:44:01 <wagle_home> there is a howto
01:44:05 <dmwit> What a terrible name for an OS.
01:44:11 <dmwit> ?wn wince
01:44:12 <lambdabot> *** "wince" wn "WordNet (r) 2.0"
01:44:12 <lambdabot> wince
01:44:12 <lambdabot>      n 1: the facial expression of sudden pain
01:44:12 <lambdabot>      2: a reflex response to sudden pain [syn: {flinch}]
01:44:12 <lambdabot>      v 1: draw back, as with fear or pain; "she flinched when they
01:44:14 <lambdabot> [4 @more lines]
01:44:30 <sieni> dmwit: I guess it's officially nowadays called Windows Mobile Edition or something
01:44:40 <sieni> dmwit: same shit different package
01:44:45 <olsner> "wince" applies to pretty much all kinds of windows though
01:45:12 <sieni> dmwit: I guess wince developers call wince "wince" on purpose :-)
01:45:32 <sieni> wagle_home: I didn't find instructions for building a cross compiler
01:45:45 <sieni> wagle_home: I wouldn't want to build ghc on a smart phone
01:48:18 <dmwit> Okay.  So and new data type can be represented as some mixture of Either and (,).
01:48:28 <wagle_home> sieni, i havent read the howto...  look for things like google gcc tool chain..  they use c--, so i dunno if c is applicable, but they have done some weird architectures, i think
01:48:29 <dmwit> (Ignoring (->) for now.)
01:48:37 <dmwit> Most languages are pretty good at (,).
01:48:42 <ddarius> dmwit: And ()
01:48:56 <dmwit> My question is: as there a nice way to do Either in other languages?
01:49:06 <vincenz> dmwit: yes
01:49:08 <dmwit> ddarius: Arguably, (Void, Void)...
01:49:20 <ddarius> 0x0 = 0 not 1
01:49:22 <vincenz> dmwit: system("ghci ...")
01:49:37 <vincenz> ddarius: () = 1
01:49:59 <vincenz> oh, Void, nm
01:50:01 <dmwit> ddarius: Okay, fair point.
01:50:01 <sieni> wagle_home: well, yes. Arm is supported on debian, so I guess it should work, but requires quite a bit of tuning. Building on linux is an option.
01:50:21 <hpaste>  AstralStorm pasted "checking if we're close" at http://hpaste.org/5700
01:50:45 <vincenz> dmwit: usually you encode sumtypes as struct { enum tag; union {}}
01:51:14 <sieni> wagle_home: I'm talking about compiling haskell for this kind of device: http://www.youtube.com/watch?v=tsYFXGKUIpE
01:51:15 <lambdabot> Title: YouTube - NVIDIA APX 2500 hands on and demo
01:51:19 <ddarius> abstract class Either<A,B> { C either<A,B,C>(Func<A,C> f, Func<B,C> g); ... }; class Left<A,B> extends Either<A,B> { ... }; class Right<A,B> extends Either<A,B> { ... }
01:51:29 <sieni> wagle_home: hugs should work, it has been ported for wince
01:51:57 <vincenz> ddarius: or that :)
01:52:01 <dmwit> ddarius: Ah, that's an interesting use of inheritance.
01:52:03 <sieni> (on my free time that is, not actually part of my work)
01:52:20 <dmwit> vincenz: Yeah, but I don't consider that (enum/union) nice. =P
01:52:42 <ddarius> dmwit: It's just the Interpreter pattern.
01:52:48 <wagle_home> allegedly, they will make it a heck of a lot easier to bootstrap ghc in 6.8.3, but who knows when thats coming out?
01:53:00 * dmwit does not know any Patterns.
01:53:28 <sieni> is there some good book about OO patters?
01:53:29 <dmwit> ...yet
01:53:36 <ddarius> dmwit: I don't think most OO programmers would immediately recognize that they can encode algebraic data types that way.
01:53:55 <sieni> I'd like to get some understanding of them for educational purposes
01:53:58 <sieni> fts
01:54:03 <ddarius> dmwit: But when they do do AST processing things, primarily, they do end up doing exactly that encoding.
01:54:25 <dmwit> Mmm, yes.
01:54:49 <vincenz> sieni: nice
01:54:51 <vincenz> Btw, guys
01:54:56 <vincenz> is there a CLI backend for haskell?
01:55:15 <dmwit> Now I can put a bit more of a finger on why I wanted the "data" keyword in compilers class.
01:55:29 <dmwit> vincenz: runghc?  or, what do you mean?
01:55:32 <wagle_home> the classic gang-of-four (five?) design patterns book, or the heads up patterns book
01:55:38 <vincenz> dmwit: .NET CLI
01:55:44 <dmwit> o
01:55:46 <sieni> does anybody happen to be located near N 60 14.133', E025 00.757'
01:56:01 <dmwit> Sorry, I thought you meant command-line interface. =P
01:56:04 <sieni> I'd need some cigarettes and wouldn't want to get out quite yet
01:57:06 <dmwit> Helsinki?
01:57:21 <sieni> dmwit: yes
01:58:11 <dmwit> I am constantly forgetting that not everybody lives in the same country as me.
01:58:27 <sieni> dmwit: how so?
01:58:44 <sieni> dmwit: are you american? :-)
01:58:53 <hpaste>  (anonymous) annotated "checking if we're close" with "(no title)" at http://hpaste.org/5700#a1
01:59:00 <dmwit> sieni: yes =/
02:00:09 <sieni> yeah, I'm not a native English speaker, but I guess I'm pretty good at it
02:00:46 <sieni> most people here start learning english at the age of 9 (like I did)
02:01:32 <slarba> heh
02:01:49 <sieni> older people might not now english that well, but people <= 45 years of age know english at least to some extent
02:02:33 <slarba> what bugs me is that we learn only written english
02:02:35 <chadz> jeez. i can't even get lighttpd working with these fcgi bins.
02:02:42 <sieni> (english is not obligatory, you can choose any language you wish if that's taught, but even in helsinki, where you have lots of options >= 90 percent of the kids choose english)
02:02:46 <bartwe> in western europe you mean ?
02:02:54 <chadz> are there any known issues with fastcgi bins built with 6.6.1 ?
02:03:11 <sieni> slarba: well, you can always watch tv
02:03:22 <slarba> sieni: and speak? ;D
02:03:39 <sieni> slarba: but it's your problem as a finn
02:03:54 <sieni> slarba: an italian can make a conversation in a foreign language with 10 words
02:04:09 <slarba> true
02:04:35 <wagle_home> at least slarba can write colloquielisms like "bugs me"..  seems pretty good
02:05:13 <slarba> but still, what I'd like to see is more speaking at school.
02:05:35 <slarba> wagle_home: heh :))
02:05:51 <slarba> I lived in Seattle a couple of years ago
02:06:01 <wagle_home> close!
02:06:07 <slarba> that was a good year to learn the language
02:06:07 <wagle_home> <---- portland
02:06:12 <slarba> oh :)
02:06:25 <chadz> seattle > portland :)
02:06:38 <hpaste>  (anonymous) annotated "checking if we're close" with "(no title)" at http://hpaste.org/5700#a2
02:07:29 <wagle_home> traffic seattle `worseThan` traffic portland
02:07:39 <slarba> :D
02:07:56 <chadz> traffic can make me mad
02:07:59 <slarba> I used smaller roads alongside the I-90 to commute
02:08:05 <chadz> good thing i'm typically walkin.
02:13:08 <vininim> good morning.
02:14:46 <slarba> morning :)
02:18:56 <vininim> I woke up thinking about a more general List type(or monad, I don't know). Like a "random List", with head xs being a random element.
02:19:51 <vininim> Actually, random list is a specific list of this more general type/monad.
02:20:51 <vininim> Generalizing head and tail(and the patterns matching) to the list structure and operations.
02:20:54 <wagle_home> daisy (by steve johnson) has a "multiset" (?) which is a lazy list whose first element is the first element to converge to a value, etc
02:21:46 <chadz> ugh
02:21:51 <chadz> i'm going to kill this cgi crap.
02:22:21 <wagle_home> i have a friend that does (did?) cgi in fortran
02:22:31 <chadz> is there any way to test the cgi binaries? i just get: ThreadId 1: user error (FCGX_Accept_r failed)
02:22:57 <vininim> yeah you could construct multiset in terms of this general list. And since you mentioned lazyness I've not even put thought in evaluation :).
02:23:22 <chadz> just to check the sanity of my code, i've followed this -- http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server  -- to no avail
02:23:23 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
02:28:23 <ddarius> Um, what's the difference between a "random list" and a list of randoms?
02:28:41 <ddarius> nevermind
02:28:53 <wagle_home> list of randoms can be sorted..  8)
02:34:12 <taruti> Is there a way of converting a time in the local timezone to UTC using Data.Time?
02:35:58 <taruti> getCurrentTimeZone doesn't help as the timezone might have been different on the given time. (summer time)
02:36:39 <vininim> @hoogle head
02:36:41 <lambdabot> Prelude.head :: [a] -> a
02:36:41 <lambdabot> Data.List.head :: [a] -> a
02:36:41 <lambdabot> Data.ByteString.head :: ByteString -> Word8
02:36:47 <taruti> looping with getTimeZone guessing UTCTimes and seeing what they are converted to might work, but seems like a very dirty way of doing it.
02:47:16 <permanente> *grml*
02:49:42 <unlink> how do i use GHCi? whenever i try to define a function, it tells me that it's "Not in scope"
02:50:49 <taruti> let f x = x+x ?
02:51:46 <nornagon> unlink: ghci doesn't take certain bits of haskell
02:51:59 <profmakx> unlink: I Usually have a vim opened and edit a file and load it into ghci
02:52:39 <nornagon> you can't define (data|type|newtype)s interactively, or use the f x = x*x syntax for defining functions
02:52:48 <nornagon> (let f x = x*x works great though)
02:53:05 <nornagon> > let f = join (*) in f 4
02:53:08 <lambdabot>  16
02:53:59 <Cin> anyone used parsec to parse a UTF-8 file?
02:54:07 <Cin> i'm not really sure where i should use encodeString
02:55:44 <audreyt> you shouldn't.
02:56:01 <audreyt> instead, read the file, turn it into unicode using decodeString, and then run parsec on it.
02:56:21 <Cin> ah, i'll try that
02:57:49 <Cin> ahh, success
02:58:02 <Cin> thanks. unicode confuses me
02:58:50 <vininim> I don't get half of the tables too. :)
03:14:08 <fnord`> hi all
03:14:18 <fnord`> anyone with experience using gtk2hs?
03:14:33 <fnord`> I've got some general questions about how to approach something
03:18:52 <int-e> you should just ask your question.
03:19:22 <fnord`> int-e: good point, I'm forgetting my irc etiquette
03:22:15 <fnord`> I'm writing a gui front end to a checkers player program. The main part of the program is a "game" function which takes two strategy functions (GameState -> IO NextMove). I want to implement the gui as a strategy function. So what I need to do is have a IO function that makes some changes to the gui then blocks waiting for a button press
03:23:29 <nominolo> fnord`: you could use a channel that gets written to from the event handler
03:23:54 <fnord`> that's a STM channel, right?
03:23:58 <nominolo> no, an MVar
03:24:14 <int-e> fnord`: can you change your game function to use continuations? i.e. use (GameState -> (NextMove -> IO ()) -> IO ()) for your strategy functions.
03:25:23 <int-e> fnord`: the idea being that you'll pass NextMove to the (NextMove -> IO ()) continuation once you know what the move is.
03:25:24 <fnord`> int-e: I could, but I rather like the current signature, I want to be able to easily write and feed it non-UI strategies
03:26:44 <int-e> Ok, then it's probably best to use an MVar and threads as nominolo suggests.
03:26:55 <fnord`> int-e: actually, I'm not sure I get that fully. So I can store the continuation until I want to make the move?
03:27:10 <int-e> fnord`: yes
03:27:35 <fnord`> that sounds interesting
03:27:55 <nominolo> int-e: but that would still require an IORef or sth
03:28:50 <int-e> nominolo: sure. it's not actually simpler, it's just slightly more flexible (for example, you could store the continuation and implement undos on top of them)
03:29:18 <int-e> it also avoids threads, but in Haskell that's not really an advantage.
03:29:20 <nominolo> right
03:29:28 <nominolo> no, threads are cheay
03:29:31 <nominolo> *cheap
03:29:43 <fnord`> of course! that's how I can implement undos! I've been wondering about that
03:30:20 <wagle_home> need a continuation that rolls back state
03:30:20 <fnord`> would this work to convery a pure strategy (GameState -> NextMove) into a continuation using IO strategy: pureStrategy strat gs cont = cont $ strat gs
03:30:49 <int-e> yep
03:31:01 <fnord`> wagle_home: there are no IOReg's or anything of the sort with "game", so I should be ok there, right?
03:31:07 <fnord`> cool
03:31:08 <Lycurgus> hmmm, convery: to conversely convey.
03:31:39 <int-e> fnord`: have you seen the recent Prompt monad discussion on haskell-cafe?
03:31:53 <wagle_home> fnord`, dunno..  i'm a one time scheme head trying to become a haskell head, but not quite there yet
03:32:22 <fnord`> no, I haven't read haskell-cafe for a while actually, I'll go have a look
03:43:57 <int-e> fnord`: maybe this is useful to you, a peg solitaire game: http://int-e.home.tlink.de/haskell/solitaire/ (note, it's not a cabal repository)
03:43:58 <lambdabot> Title: peg solitaire game
03:46:27 <fnord`> thanks, I'll have a look at that
03:47:06 <fnord`> It's just occured to me that I can use a type class for the strategy, that way I can declare pure strategy functions to be instances of that type class and use them without conversion
03:47:14 <int-e> arg. darcs, not cabal.
03:51:35 <hpaste>  int-e pasted "another Prompt monad demo" at http://hpaste.org/5701
03:52:26 <fnord`> cheers
03:59:22 <fnord`> is "notify" a gtk2hs function?
03:59:39 <fnord`> it's used in that solitaire game but I can't find it in the gtk2hs docs
03:59:57 <int-e> no, it's an argument to runGame
04:00:46 <int-e> it's actually (G.widgetQueueDraw da)
04:00:47 <int-e> (from the main function below)
04:00:47 <fnord`> oh, right, that makes more sense :p
04:01:30 <kankamuso> do i have to always use parenthesis to specify a negative number, e.g. "abs (-100)"? hugs interprets "abs - 100" if i don't use them.
04:04:49 <fnord`> yeah, I think you do, otherwise it interprets - as a the binary subtraction operator rather than the uniary negation operator
04:04:54 <kankamuso> is there any stylistic guideline for this or i should use () around every negative number?
04:04:55 <int-e> > -2 + 3 -- there's no rule without exceptions.
04:04:55 <lambdabot>  1
04:05:02 <int-e> kankamuso: I'm not aware of any rule, and personally I leave out the () whenever I can get away with it - which isn't very often though.
04:05:02 <fnord`> one of the less pretty things about Haskell I think, although I'm sure the alternatives where much worse
04:05:02 <int-e> > abs $ -100 -- hmm, that's not pretty either
04:05:03 <lambdabot>  100
04:05:45 <kankamuso> i see. i've been scratching my head for a while with this. my first test program and i got this error message.
04:06:12 <kankamuso> so the lexical analyzer takes the - as a separate token always
04:06:51 <int-e> it is confusing. unary - has a precedence, so abs $ -1 works, but 2 + -3 does not ... (at least in ghc, I haven't checked the haskell report)
04:06:54 <int-e> kankamuso: yep
04:07:00 <wagle_home> the penalty for ignoring whitespace (i think)
04:07:26 <kankamuso> hugs accepts 2 + -3
04:07:33 <desegnis> my personal preference would be for unary minus to be called, say, neg
04:07:47 <kankamuso> isn't a negate in the Prelude?
04:07:51 <desegnis> I would even write (neg 3) instead of -3
04:07:58 <wagle_home> that'd win votes from the scientific computation community
04:08:02 <desegnis> but negate is quite long ;)
04:08:08 <kankamuso> :)
04:08:40 <desegnis> and the presence of negate does not make unary "-" go away
04:09:19 <kankamuso> is there any special reason  for the lexer not  including the optional - in the integer tokens?
04:09:32 <kankamuso> sorry for my naiveté
04:09:35 <int-e> there's a haskell' proposal to change this, http://hackage.haskell.org/trac/haskell-prime/ticket/50 -- with no clear vote for or against it.
04:09:37 <wagle_home> the penalty for ignoring whitespace (i think)
04:09:37 <lambdabot> Title: #50 (get rid of unary '-' operator) - Haskell Prime - Trac
04:10:04 <wagle_home> > - 1
04:10:05 <lambdabot>  -1
04:10:15 <wagle_home> > 2 + - 1
04:10:15 <lambdabot>      precedence parsing error
04:10:15 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
04:10:28 <wagle_home> > 2 + -1
04:10:28 <lambdabot>      precedence parsing error
04:10:28 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
04:10:37 <Cin> > 2 + (-1)
04:10:38 <lambdabot>  1
04:10:55 <desegnis> kankamuso, then you would have to explain why you can write -1 but not -a, and whether there's a difference between -1 and - 1
04:11:00 <wagle_home> > "lambdabot" == "hugs"
04:11:01 <lambdabot>  False
04:11:32 <kankamuso> i see. i think it's a wart in a otherwise nice syntax
04:11:33 <int-e> > map (-3+) [1,15,42] -- note: doesn't work in hugs
04:11:34 <lambdabot>  [-2,12,39]
04:12:04 <vininim> since haskell cares about layout, it could care about whitespaces
04:12:16 <desegnis> kankamuso, but I realize that the Haskell' proposal mentioned by int-e involves exactly this
04:12:32 <wagle_home> good thing all the haskells agree on syntax
04:12:52 <int-e> vininim: and there's precedence for this - . that is both an infix operator and part of the qualified id syntax.
04:13:01 <wli> Things seem to have converged to (0 + x * (1.0141847425292432 + x * (0 + x * -8.334278985275914e-2))) / (1 + 0.10555291158107977 * (x - 0.0)**2) which is close to (60*x-7*x^3)/(60+3*x^2)
04:13:59 <wli> Er, not converged, gotten to that point or whatever.
04:14:10 <kankamuso> i'll read the proposal
04:14:15 <kankamuso> > -a where a = 103
04:14:15 <lambdabot>  Parse error at "where" (column 4)
04:14:36 <int-e> > let x = -a where a = 103 in x
04:14:39 <lambdabot>  -103
04:14:45 <kankamuso> thanks :)
04:15:05 <kankamuso> what implementation does lambdabot use?
04:15:10 <Cin> ghc
04:15:21 <desegnis> I think if I were to utter a Haskell' proposal, I'd change the Hierarchical Modules proposal to merge the Data.* and Control.* hierarchies
04:15:29 <Cin> it compiles the statement and then loads it
04:15:44 <Cin> (as opposed to intepereting it on the fly)
04:15:57 <wli> My personal preference is for the parser to be sophisticated enough to handle '-' being a prefix unary operator and an infix binary operator simultaneously.
04:16:34 <desegnis> wli, you mean the way it is now?
04:16:39 <int-e> let f x = x -1 -- x - 1 or x (-1)?
04:17:45 <wli> desegnis: Basically yes.
04:18:43 <kankamuso> int-e: i would say x (-1). my intuition says -1 is an integer at lexical level and - 1 is the unary neg operator applied to an integer
04:19:04 <wagle_home> :t (-1)
04:19:04 <lambdabot> forall a. (Num a) => a
04:19:09 <wagle_home> :t (+1)
04:19:09 <lambdabot> forall a. (Num a) => a -> a
04:19:21 <vininim> :t -1
04:19:22 <lambdabot> forall a. (Num a) => a
04:19:24 <wagle_home> :t (- 1)
04:19:24 <lambdabot> forall a. (Num a) => a
04:19:32 <vininim> :t (-) 1
04:19:33 <lambdabot> forall t. (Num t) => t -> t
04:19:46 <vininim> t? oh gee
04:19:50 <wagle_home> > (-) 1 2
04:19:51 <lambdabot>  -1
04:19:56 <kankamuso> ouch!
04:19:58 <int-e> @type (-)
04:19:58 <lambdabot> forall a. (Num a) => a -> a -> a
04:20:07 <int-e> @type 1
04:20:08 <lambdabot> forall t. (Num t) => t
04:20:15 <int-e> ah, there's the t.
04:20:17 <dmwit> :t (- 1) -- this *really* ought to be equivalent to (subtract 1)
04:20:18 <lambdabot> forall a. (Num a) => a
04:20:42 <dmwit> :t let a = 1 in (- a)
04:20:42 <lambdabot> forall a. (Num a) => a
04:20:49 <dmwit> ...oh
04:20:51 <wagle_home> as i said, whitespace are (sorta/pretty=much) ignored
04:21:07 <dmwit> I see, (-) is negate.
04:21:37 <wagle_home> (-) is subtract... (-) 1 is (1 -)
04:21:41 <kankamuso> what if you consider - part of an integer token if there is no whitespace between both?
04:21:45 <dmwit> > let (!) 0 = 1; (!) n = n * ((n-1)!) in (5!) -- kind of like this
04:21:46 <lambdabot>  120
04:22:07 <wagle_home> > (1 -) 2
04:22:07 <lambdabot>  -1
04:22:23 <dmwit> Except that (-1) has the cart before the horse, so to speak.
04:22:30 <int-e> kankamuso: I'd be happy about that - it would also
04:22:31 <wagle_home> > (- 1) 2
04:22:32 <lambdabot>   add an instance declaration for (Num (t -> a))
04:22:32 <lambdabot>     In the expression: (- 1)...
04:22:40 <dmwit> I am uncertain of the "correct" answer.
04:23:09 <int-e> 'fix' the wart that -50 gets desugared as (negate (fromInteger 50?)) where 50? is an _Integer_ literal of value 50.
04:23:37 <jean> Hi..I'm a beginner to Haskell, so please bear with me
04:23:46 <int-e> (instead of  fromInteger (-50?))
04:23:59 <dmwit> Hiya, jean!
04:24:05 <kankamuso> hi jean
04:24:19 <dmwit> Feel free to put code on hpaste if you think it will help us answer your question.
04:24:38 <kankamuso> int-e: is there a reason for not doing that, besides the idea of not making whitespace significant?
04:24:47 <Eelis> is Data.Sequence what i'm looking for if i want the equivalent of a C++ std::queue with efficient insertion on one side and efficient extraction on the other? are there any catches i should know about?
04:24:54 <jean> Sure, I have a problem with this code : http://pastebin.com/m7e46c785
04:25:13 <jean> In GHC, the program first accepts the input, then writes the output.
04:25:19 <jean> While in hugs, it works as expected
04:25:39 <jean> I'm not sure if you understood me, so please tell me if you don't.
04:26:03 <dmwit> I don't understand, but the answer is most likely "buffering".
04:26:11 <wli> I'd say that '-' followed by digit strings should be lexed as a negative literal, and can be desugared to negate (fromInteger 50) or fromInteger (-50) or whatever.
04:26:12 <int-e> kankamuso: I don't know. I guess making unary minus part of the syntax seemed simpler when Haskell was first specified. But I'm speculating.
04:26:33 <dmwit> jean: What is the expected behavior, if not to first accept the input, then write the output?
04:26:51 <Lord_Illidan> I'll specify further. The programis supposed to output "your name, please? "
04:27:04 <Lord_Illidan> and then recieve the input from std input
04:27:09 <Cin> oh
04:27:14 <Cin> you need hFlush stdout
04:27:15 <wli> I'd say that positive literals should be given a more general type, e.g. fromNatural 50
04:27:19 <Cin> after putStr
04:27:29 <Cin> otherwise it line buffers. had the same problem recently
04:27:33 <Lord_Illidan> what does that do, Cin?
04:27:35 <sieni> Eelis: I guess so. The basic functional way of having a queue is to hold two lists and you push elements to one list and extract elements from the other and if you run out of elements in the extraction list you reverse the insertion list and dump it into the extraction list
04:27:46 <Cin> lord: flushes what's in the buffer so far and sends it to stdout
04:27:48 <dmwit> Yeah, I figured you were running into some buffering issues.
04:27:51 <Lord_Illidan> so it doesn't have anything to do with pure functional language?
04:27:53 <wli> But that requires lots of pain with compiler intrinsics and revising the numeric hierarchy that are flat out beyond me.
04:27:58 <Eelis> sieni: interesting. thanks
04:27:58 <sieni> Eelis: that's even relatively efficient
04:27:59 <Cin> lord: no
04:28:11 <dmwit> Lord_Illidan: Not really; it happens all the time in C/C++, too.
04:28:37 <dmwit> Lord_Illidan: It's just a custom in C/C++ that printing a newline also flushes the buffer; in Haskell, that isn't necessarily true.
04:28:45 <Lord_Illidan> so what's the command?
04:29:21 <kankamuso> where does this kind of things get discussed? is there any BDFL like Python has? :)
04:29:40 <wli> Well, the format string garbage in C/C++ printf()/etc. are dogslow, not that C++ got any swifter with its iostream.h junk.
04:30:02 <Lord_Illidan> ah thanks, I think I got what you're saying
04:30:03 <dmwit> wli: Agreed, I'm not saying I *like* the C/C++ way. =P
04:30:18 <Cin> lord: oh, i didn't realise you were jean. sorry, was confused
04:30:57 <Cin> lord: "hFlush stdout" after your putStr
04:31:03 <Lord_Illidan> Cin: I don't use Irc that much
04:31:26 <Cin> lord: well if you're learning haskell, this channel is an excellent resource
04:31:56 <dmwit> Lord_Illidan: Don't listen to him, it's a trap!  Come here often enough, and you may never leave...
04:32:16 * dmwit tries on his ominous voice
04:32:31 <kankamuso> cin: do newbie questions bother you?
04:32:39 <kankamuso> not today, as i see
04:33:23 <Cin> kank: er, no. i'm a newbie myself :DDD
04:33:46 <Lord_Illidan> do I have to do import System.IO?
04:34:10 <Lord_Illidan> I usually use Java,Pascal,C# myself. I have some background with Prolog, too
04:34:11 <Cin> lord: yeah
04:34:33 <Lord_Illidan> where do the import statements go?
04:34:38 <Lord_Illidan> in the do: structure?
04:34:46 <dmwit> At the top of the file is fine.
04:35:04 <Cin> lord: here are the docs for hFlush: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhFlush
04:35:05 <lambdabot> http://tinyurl.com/y9dfge
04:35:20 <Lord_Illidan> Cin, ah it works now. thanks dmwit, too!
04:35:28 <Cin> welcome
04:35:49 <kankamuso> i need  advice for good learning books. any suggestions?
04:36:00 <jeffz> kankamuso: visit http://haskell.org look on the left hand side
04:36:00 <lambdabot> Title: Haskell Community Server
04:36:04 <Lord_Illidan> For a moment, I was going to scrap GHC
04:36:05 <Lord_Illidan> :D
04:36:07 <desegnis> kankamuso, state your requirements
04:36:31 <dmwit> Lord_Illidan: You'd regret it; GHC is the best one for general-purpose use.
04:36:33 <dmwit> =)
04:36:45 <kankamuso> lean material (i've been a programmer for 10 years, love functional stuff, know the basics)
04:37:19 <kankamuso> jeffz: i've already done it. i'm still making my mind.
04:37:20 <Cin> i liked Yet Another Haskell Tutorial because it has lots of exercises
04:37:21 <Lord_Illidan> dmwit, I know, our lecturer recommended it, but I wondered why hugs was working "correctly" and ghc had this wierd bug..never crossed my mind that it was a buffering problem
04:37:41 <Lord_Illidan> I have the Craft of Functional Programming, anyone uses it?
04:37:47 <jeffz> Lord_Illidan: it's not a bug or a problem, it's how it should work :p
04:38:06 <dmwit> kankamuso: Try the Gentle Intro, but get ready to feel like porcupines are gentle.
04:38:12 <kankamuso> lol
04:38:29 <kankamuso> that's what i'm looking for. i don't need introductions.
04:38:35 <Cin> kankamuso: ie i had read A Gentle Introduction to Haskell and found i'd picked up some things, especially about the type system. but when it came to write some haskell i found i didn't really remember anything. then i read YAHT which enforced the learning with exercises. i think reading them both like that was a good thing
04:38:36 <dmwit> ?where gentle
04:38:36 <lambdabot> http://www.haskell.org/tutorial/
04:38:40 <Lord_Illidan> while we're there, anyone knows some good introductions to lambda calculus?
04:39:05 <kankamuso> i think i'm following your path, cin
04:39:11 <wli> Lord_Illidan: It's a little too basic for me. YAHT (Yet Another Haskell Tutorial) was more enlightening, though it was a little lean on applications, in no small part because of the exercises.
04:39:28 <wli> Lord_Illidan: polylambda.ps helped me a bit
04:40:00 <wli> Lord_Illidan: http://holomorphy.com/~wli/polylambda.ps
04:40:03 <wli> Lord_Illidan: http://holomorphy.com/~wli/polylambda.pdf
04:40:07 <int-e> @pl ap id id (ap id id)
04:40:15 <Lord_Illidan> Personally, I got confused when it started talking about pictures in the beginning..and I also don't like using Hugs which it recommends..but thanks!
04:40:15 <lambdabot> ap id id (ap id id)
04:40:17 <Cin> damnit. i should finish my lambda calculus expression computer. then i could have said "check out my program, that should help you learn!"
04:40:17 <wli> Lord_Illidan: Both URL's should work.
04:40:20 <kankamuso> one more question (burning one). i think i've understood monads with no problem at all. bear in mind i'm a fresh newbie. does it mean i've not understood them at all? everyone talks about how hard they are. there are tons of tutorials in the net
04:40:36 <dmwit> kankamuso: No, no, they're easy as pie.
04:40:52 <dmwit> kankamuso: "Nothing to understand" as one math teacher always used to say. =)
04:40:53 <Lord_Illidan> ah monads..I was about to refer to them for my input problem
04:41:08 <kankamuso> it bothers me, because i've got this nagging feeling that i've misunderstood everything. "it cannot be so easy"
04:41:35 <wli> It took me 9 years to figure out monads, but I only tried once in a blue moon during that time.
04:41:52 <dmwit> kankamuso: If you can use a few monads and point out when it might be useful to have, say, replicateM handy, then you've understood all you need to.
04:42:03 <int-e> wli: did you feel cheated in the end?
04:42:20 <resiak> I'll be interested to see if Haskell that I write today will be relatively incomprehensible to me if I don't look at it for a few months, as was the
04:42:20 <kankamuso> dmwit: yep,  i can do that
04:42:27 <wli> int-e: No, they're pretty useful.
04:42:37 <Cin> kankamuso: i had a similar feeling. all those tutorials? i must be missing something. but... i've been using monads in my code a lot and i think i understand them well. i might even say being able to use the State monad or something in your code is a good idea to help you learn..
04:42:38 <resiak> ...case with some other languages for me.  (Grr, ^W and ^M adjacent.)
04:42:49 <Lord_Illidan> I too find it hard to understand what a monad really is
04:42:51 <desegnis> From many perspectives the gentle introduction is easier to follow than »easy« material because its explanations are exact, and it skips the »you don't need to know this« phrases
04:43:11 <Lord_Illidan> I'm too inured to the world of the imperative and Object Oriented programming
04:43:17 <kankamuso> any suggestions for a small pet project to put my supposed knowledge to test?
04:43:27 <dmwit> desegnis: I agree, I found it quite nice.
04:43:30 <mux> the only one sentence definition of monads that ever made sense for me is the one saying that monads are a way to model side-effects
04:43:43 <int-e> wli: oh they are, but in my opinion, the differences between monads are more important than the little that they have in common (basically, a notion of sequencing). But it's the latter that gives them the name.
04:43:45 <kankamuso> mux: but not only side effects
04:43:50 <dmwit> kankamuso: Well, there's Write Yourself a Scheme in 48 Hours.
04:43:50 <mux> nearly everything else falls short soon because it doesn't apply to this or that monad
04:43:51 <resiak> mux: "programmable semicolon"!
04:43:54 <kankamuso> they're much more deeper
04:44:10 <mux> kankamuso: everything a monad does "behind the scene" can be considered a side effect
04:44:20 <dmwit> mux: A monad is a container!
04:44:26 <mux> even if it's not one in the common technical sense, ie IO, global variable mutation, etc
04:44:26 <kankamuso> well, if you put it that way, yes
04:44:33 <Lord_Illidan> let's put it this way : in my program getName is supposed to return a String..thus the putStr "your name, please? " is a side effect
04:44:34 <mux> dmwit: yes, that one also falls short with some monads :-P
04:44:37 <Lord_Illidan> right?
04:44:43 <dmwit> mux: I dare you to name one.
04:44:47 <mux> dmwit: state
04:45:10 <Cin> lord: that's a side-effect, sure.
04:45:13 <dmwit> mux: Why?  It easily contains its value, plus some state.
04:45:14 <Lord_Illidan> This is my program : http://pastebin.com/d7b442135
04:45:14 <kankamuso> i see them as an encapsulation: you can use them for sequencing, for "tagging" values with info you need to carry along a computation, for keeping side effects under control...
04:45:24 <Cin> kankamuso: me too
04:45:29 <wli> springschool95.pdf did it for me. fmap (map in the elder text), return (unit in the elder text), and join (join there, also).
04:45:30 <Lord_Illidan> Cin, so it works just because of the do statement?
04:45:35 <mux> dmwit: I think this view is kinda misleading for monads such as state or reader
04:45:38 <dmwit> mux: Or, do you mean that "container" doesn't capture all the things possible with a monad?
04:45:54 <wli> I want monad comprehensions back.
04:45:56 <mux> I mean that it's not the best analogy - to me at least
04:46:05 <Cin> lord: no, the `do' notation is just syntactic sugar. a way to sequence actions. writing putStr by itself would still produce the side-effect
04:46:11 <kankamuso> i recently read about monads being like toxical waste containers
04:46:12 <kankamuso> :D
04:46:12 <dmwit> wli: I've often wished for monad comprehensions, too.
04:46:16 <wli> cf. Dijkstra regarding analogies.
04:46:18 <kankamuso> the worst analogy ever
04:46:25 <Cin> lord: do you follow me?
04:46:45 <Lord_Illidan> Cin, yes, I do
04:46:47 <kankamuso> doesn't "do" use binding and lambdas under the hood?
04:46:49 <int-e> kankamuso: let me guess, the only example that was used was the IO monad?
04:46:56 <dmwit> mux: Okay.  The one I like is "monads as computations", anyway, but I figured "monads as containers" was more intuitively understandable.
04:46:57 <kankamuso> int-e: yep
04:46:57 <Lord_Illidan> So the binding is >>
04:47:01 <vininim> @quote dijkstra
04:47:03 <mux> considering you define >>= :: m a -> (a -> m b) -> m b, it looks pretty clear that we're really defining some kind of side effect
04:47:06 <Cin> lord: correct
04:47:11 <Lord_Illidan> putStr "your name, please? " >> hFlush stdout >> getLine
04:47:17 <Cin> lord: exactly
04:47:21 <mux> except side effect in a more general term I guess
04:47:26 <Lord_Illidan> ok, I am getting the hang of this, thanks!
04:47:39 <Cin> lord: getLine you would probably need >>= which takes the result of an action and gives it to another one
04:47:46 <mux> dmwit: and the "container" part if often just newtype wrapping whose sole purpose is to identify the monad
04:47:46 <Cin> lord: e.g. getLine >>= putStrLn
04:47:53 <mux> s/if/is/
04:48:13 <wli> fmap :: Functor f => (t -> t') -> f t -> f t'
04:48:24 <wli> return :: Monad m => t -> m t
04:48:28 <Cin> lord: or, e.g. do { name <- getLine; putStrLn name } is equivilant to getLine >>= (\name -> putStrLn name)
04:48:34 <wli> join :: Monad m => m (m t) -> m t
04:48:38 <Cin> lord: if you understand the lambda notation..
04:48:50 <kankamuso> you cannot operate with the "a" in "m a" in a direct way, but you can pass it to another function which promises to encapsulate its result in the same monad, so once a monad, always a monad
04:49:04 <kankamuso> i think return should be named wrap
04:49:11 <kankamuso> it would make things easier
04:49:11 <Cin> > (\x -> x) 10
04:49:13 <Lord_Illidan> Cin, it's a bit confusing to me
04:49:25 <dmwit> kankamuso: Right.  Another way to think of it is that instead of taking values out of a monad, you put functions into the monad.
04:49:28 <chrizel> hi, is there some shorter form for 1::Float in haskell like 1f in C?
04:49:29 <mux> and typically (>>=) does something "extra" which I like to call a side effect :-) except for the Identity monad
04:49:40 <Cin> lord: okay, i don't think it so important just yet. unless you want me to explain some area more?
04:50:01 <wli> I think "fmap" should be named "map" as it was before H98.
04:50:15 <wli> chrizel: 1.0
04:50:31 <dmwit> wli: Some people think "fmap" should be named "(.)".
04:50:44 <wli> x >>= f = join (fmap f x)
04:51:03 * mux orders couscous for lunch
04:51:50 <wli> dmwit: Eh? That would look odd.
04:52:45 <dmwit> words . getLine -- nothing so odd about that
04:53:01 * wli has tried and failed to implement several of these things, and supposes it would look better if there had been some sort of tangible result.
04:53:12 <kankamuso> my next stop is reading about arrows
04:53:13 <mux> yeah, but succ . "foo" looks odd :)
04:53:14 <kankamuso> they sound fun
04:53:32 <dmwit> mux: Well, it is a bit more strange for the list monad, yes. =P
04:53:39 <kankamuso> (i think i'm going to try the scheme interpreter project)
04:54:00 <wli> dmwit: A bit more strange for things that aren't monads, too.
04:54:04 <dmwit> kankamuso: If you've got monads, arrows are a cinch.
04:54:45 <wli> I didn't find arrows all that easy even after monads.
04:54:57 <dmwit> Hm, really?
04:54:58 <Cin> kankamuso: the scheme in 48 hours is awesome. covers loads of stuff. i'm working on a basic scheme intepreter at the moment. good fun :D
04:55:07 <wli> At least not in their full generality. The only arrow I got was (->).
04:55:08 <axm> there are not so many misleading analogies out there for arrows
04:55:09 <kankamuso> i've just read SICP
04:55:15 <kankamuso> so my scheme is still fresh
04:55:23 <kankamuso> and i'm eager to put haskell into use
04:56:05 <RayNbow> > let (.) = fmap   in   succ . "foo"
04:56:10 <kankamuso> cin: is there any simple description of what arrows are?
04:56:12 <RayNbow> oh
04:56:15 <RayNbow> lambdabot's gone
04:56:17 <wli> I've largely smoked out how to use the (->) arrow.
04:56:25 <chrizel> wli, that would give me a type of type class Fractional, not exactly Float, that's a little problem in my case where i have a function which accepts Float and Double (i get the ambiguous type variable error)
04:56:28 <wli> kankamuso: Not that I can tell.
04:56:44 <dmwit> kankamuso: The paper on http://www.haskell.org/arrows/ is pretty good, I think.
04:56:52 <kankamuso> i like this channel :)
04:56:59 <kankamuso> i like it very much, yes sir
04:57:04 <Lord_Illidan> Hmm..so I made it 1 line : 	putStrLn "Enter your name : " >> hFlush stdout >> getLine >>= (\name -> putStrLn ("hello, "++name++" (that's "++show (length name)++" letters)"))
04:57:11 <wli> RayNbow: let (.) = fmap in succ . "vms"
04:57:51 <kankamuso> thanks for the link, dmwit!
04:57:57 <RayNbow> wli, wnt?
04:58:00 <RayNbow> WinNT?
04:58:02 <Lord_Illidan> same here..this channel is great
04:58:04 <Cin> lord: looks correct. of course, it doesn't look that nice to read, hence the do notation
04:58:12 <axm> kankamuso, http://www.haskell.org/haskellwiki/HXT might be interesting for some examples
04:58:21 * RayNbow has very limited VMS experience... :p
04:58:38 <mux> > let (.) = fmap in succ . "vms"
04:58:42 <lambdabot42>  "wnt"
04:58:50 <Lord_Illidan> Cin, thanks..it works
04:59:03 <wli> do { putStr "Enter your name: " ; hFlush stdout ; name <- getLine ; putStrLn $ "hello, " ++ name ++ "(that's " ++ show (length name) ++ " letters)" }
04:59:27 <Cin> wli: indeed, lord knows that--he/she was just seeing what the do notation would translate to, i think
04:59:47 <Lord_Illidan> yes, thanks wli, though
04:59:55 <kankamuso> i think you all kill the myth of "RTFM" answers
04:59:58 <kankamuso> nice surprise
05:00:07 <kankamuso> thanks, amx!
05:00:11 <mux> that's because haskell has no man pages :)
05:00:11 <Lord_Illidan> what's the $ notation? It stands for a string?
05:00:26 <resiak> @src ($)
05:00:26 <lambdabot42> f $ x = f x
05:00:29 <Lord_Illidan> Yes, I'm of the same opinion..great channel
05:00:38 <kankamuso> $ applies functions (right associative)
05:00:44 <wli> I was actually trying to point out that you didn't need to drop to a new line before accepting the user's input.
05:00:44 <Cin> it's a right-associative operator. foo $ bar mu is like foo (bar mu)
05:00:47 <kankamuso> a $ b $ n ---> a (b n)
05:00:50 <dmwit> kankamuso: Mmm, you ask questions, we point you to tutorials/papers... and you don't consider that RTFM? =D
05:01:00 <kankamuso> lol, dmwit
05:01:03 <kankamuso> no, i don't
05:01:19 <kankamuso> don't ask about my experiences in other language's channels
05:01:20 <vininim> > f g a b c :: Expr
05:01:21 <kankamuso> ahem
05:01:21 <lambdabot42>   Not in scope: type constructor or class `Expr'
05:01:32 <vininim> :/
05:01:40 <Cin> vininim: is it only Cale's that supports Expr? this must be dons's
05:01:44 <Lord_Illidan> kankamuso, I know what you're talking about..
05:01:54 <mux> mine doesn't support Expr
05:01:57 <mux> I need to update it
05:02:10 <Lord_Illidan> wli, but why did you do putStrLn $?
05:02:14 <wli> The Expr thing is neat.
05:02:20 <mux> yeah it is
05:02:22 <dmwit> Lord_Illidan: It's just fewer parenthesis.
05:02:28 <Lord_Illidan> dmwit, ah, ic
05:02:31 <dmwit> ...parentheses? parentheses.
05:02:45 * mux doesn't much like $ aesthetically speaking, and often prefers more parentheses
05:02:59 <mux> but I'm not a LISP lover either :)
05:02:59 <Cin> my original parenthesis was to use parentheses, but then i used $ :P
05:03:16 <wli> Lord_Illidan: Parenthesis matching gets to be error-prone enough after enough nesting that I default to using ($) as much as possible.
05:03:32 <dmwit> I like $ most at the end of a long function-composition chain, where matching the parens just adds to my mental stack rather than helping.
05:03:59 <mux> I usually go f . g $ h x rather than f $ g $ h x
05:04:03 <kankamuso> i prefer $. it feels less, mmmm..., less hurried
05:04:15 <dmwit> mux: Right, me too.
05:04:22 <mux> of course I can eta-reduce and just have f . g . h it's even better!
05:04:24 <mux> +if
05:04:27 <vininim> > reverse "haskel"
05:04:29 <lambdabot42>  "leksah"
05:04:35 <Lord_Illidan> Ah, I see
05:04:35 <Lord_Illidan> http://conal.net/Pan/haskell-primer.htm
05:04:41 <Cin> mux: i usually go f . g . h $ x >_>
05:04:47 <wli> Not that it's really difficult, but I prefer automation to take as many trivial burdens off my hands as possible.
05:04:54 <kankamuso> should I go for Parsec if i want to create an interpreter? the choice of the proper lib for each job is one of my problems right now
05:04:58 <mux> > foldl (flip (:)) "haskell"
05:05:00 <lambdabot42>  <[Char] -> [Char]>
05:05:02 <mux> er
05:05:06 <mux> > foldl (flip (:)) [] "haskell"
05:05:08 <lambdabot42>  "lleksah"
05:05:17 <resiak> that leksah works is a happy surprise!
05:05:18 <dmwit> Cin: It depends on what you're doing, I guess.
05:05:22 <Cin> kankamuso: parsec is a reasonable choice
05:05:40 <dmwit> Cin: i.e. I would prefer f . g $ h x y to f . g . h x $ y
05:05:51 <vininim> what is the goal of leksah? emacs-like? eclipse-like? something in the middle would be nice
05:05:55 <Cin> dmwit: indeed, i'm not saying one is more correct. seems to be about personal aesthetics
05:06:05 <mux> yeah, that's pretty subjective
05:06:09 <wli> kankamuso: Parsec is good for getting things done fast. If you're doing something really involved, a lot of times it'll be difficult or impossible to do with any standard parser combinator library.
05:06:23 <wli> kankamuso: e.g. parsing C
05:06:28 <kankamuso> wli: what do you suggest?
05:07:02 <kankamuso> are Parsec parsers LL1? descent recursive?
05:07:16 <dmwit> LALR(k)
05:07:28 <kankamuso> can you backtrack?
05:07:31 <dmwit> with backtracking, if necessary
05:07:33 <dmwit> yes =)
05:07:33 <wli> kankamuso: Or languages with sufficiently hairy user-definable operators (I think Poplog or some such has infix, prefix, and mixfix user-definable operators unrestricted by any sort of lexical classes)
05:07:35 <kankamuso> i see
05:07:36 <kankamuso> :)
05:08:06 <kankamuso> wli: i guess things get messy pretty fast in such cases, don't they?
05:08:07 <dmwit> There's libraries for most of the other forms of parsers, too, if you want them.
05:09:47 <kankamuso> if i'm not wrong, antlr uses LL(k) and has no problem with big complicated grammars
05:10:30 <dmwit> Mmmm, Text.ParserCombinators.Parsec.Language has an odd assortment:
05:10:44 <wli> I'd like LR(k) with merging of items with identical cores a la LALR(k) only in such cases as would not give rise to reduce/reduce conflicts (IIRC the item merging gives rise to those, and shift/reduce are from grammatical ambiguities), but I'm not even aware of a name for that.
05:10:44 <dmwit> Haskell (obviously), Java, empty, and... Mondrian.
05:11:12 <Cin> Lord_Illidan: i recommend http://en.wikibooks.org/wiki/Haskell/YAHT/Preamble
05:12:05 <wli> dmwit: You'd think more well-known languages than Mondrian would be there, like Prolog, Standard ML, Fortran, C, et al.
05:12:27 <dmwit> Whatever people felt like writing, I guess.
05:12:34 <kankamuso> lunch time. bbl
05:12:39 <kankamuso> thanks all for your help
05:12:51 <Saizan> parsec is LL(1) by default, you've to use "try" to add backtracking
05:12:54 <wli> Someone wrote a quick and dirty Prolog for the hugs examples/ dir.
05:13:01 <Cin> ac: ping
05:13:43 <wli> Somehow it didn't really get as far as Text.ParserCombinators.Parsec.Language
05:15:27 <mandygirl20> Hab mit meiner Freundin ein Video aufgenommen wie ich nackig dusche zu Hause, wenn du dir es mal ansehen willst kuck mal auf meine Homepage:  http://www.mandymaus.de
05:16:01 <Lord_Illidan> I also recall reading that you can't write a function to generate a random number in haskell
05:16:43 <wli> That's patently false.
05:16:44 <slarba> you can, but in a monad
05:17:48 <mux> @hoogle random
05:17:48 <lambdabot42> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
05:17:48 <lambdabot42> System.Random :: module
05:17:48 <lambdabot42> System.Random.Random :: class Random a
05:19:12 * wli wonders if NFU (Jensen's revision of Quine's revision of Russell & Whitehead's type theory) would be a good logic to use for university freshmen to get them "ready" for type theory and programming languages.
05:19:25 <Lord_Illidan> http://monadicheadaches.blogspot.com/2007/11/random-numbers-where-it-all-started.html
05:20:04 <wli> Lord_Illidan: heh, nice blogspot.com name
05:20:35 <Lord_Illidan> heh..I know..not my blog, obviously..this is my second day with haskell
05:21:17 <Cin> if you don't have an `otherwise' clause in a function guard, does it continue to the next function pattern?
05:21:43 <int-e> Cin: yes.
05:21:47 <Cin> success
05:21:57 <int-e> Cin: btw that's not a clause, it's a constant defined in the prelude
05:22:02 <int-e> @src otherwise
05:22:02 <lambdabot42> otherwise = True
05:22:18 <wli> Lord_Illidan: The actual substance to his complaint (despite whatever he might directly claim) is that the standard libraries' random number API is awkward.
05:22:37 <Cin> int-e: ah, cool.
05:22:51 <Cin> int-e: makes more sense now
05:23:32 <wli> Lord_Illidan: A lot of people work around it and plug some random number generator in a different way.
05:24:50 <wli> Lord_Illidan: The Mersenne Twister code, for instance, just spits out an infinite list of the uniform deviates on machine integers (or is it 32-bit integers?) as an infinite list given seeds of some sort as arguments.
05:25:49 <Lord_Illidan> ah, nice one, wli
05:26:11 <Lord_Illidan> on another note, what do you guys use to program Haskell in? I am using vi
05:26:37 <Saizan> emacs + haskell-mode
05:28:45 <kankamuso> gotta go. thanks again. i'll be around here often :)
05:33:24 <wli> Lord_Illidan: I use nvi.
05:33:57 <vininim> I use vim + screen inside emacs.
05:34:09 <vininim> just kidding, emacs too =)
05:34:53 <Lord_Illidan> I also use gedit, in fact, I'm using it now
05:35:51 <wli> Lord_Illidan: What I would do for random anything is to hammer out a monad transformer class with all the necessary instances etc. that's largely a wrapper around the StateT monad transformer, where the state would be an infinite list of the things generated (e.g. the numbers, but possibly using System.Random to convert to a data structure) and generating would pop an element off the list in the state and return it.
05:37:00 <Cin> @hoogle (b -> c) -> (a -> a -> b) -> a -> a -> c
05:37:02 <lambdabot42> No matches, try a more general search
05:37:40 <Cin> i've got `f' that takes one argument, and 'x' that takes two arguments, how can i compose them together?
05:39:11 <resiak> @pl \x y -> f (g x y)
05:39:12 <lambdabot42> (f .) . g
05:39:48 <Cin> ah
05:39:50 <wli> Lord_Illidan: Where did I get cut off?
05:40:10 <Lord_Illidan> wli?
05:40:37 <Lord_Illidan> wli I didn't see any cutting off..last 2 words are "return it."
05:41:02 <wli> Lord_Illidan: All good, then.
05:41:18 <Saizan> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
05:41:22 <Lord_Illidan> I am not saying very much as I'm trying to do some work that our lecturer assigned to us bout haskell..thanks for your comments though
05:41:39 <Cin> meh. it's not as nice anyway
05:42:06 <Cin> instead of using `do' i tried liftM but it looks kind of poor
05:42:08 <Cin> eqOp [x,y] = liftM2 ((SchBool.).(==)) (eval x) (eval y)
05:42:38 <Lord_Illidan> oh, another one..
05:42:43 <Lord_Illidan> this may sound funny
05:43:26 <hpaste>  Cin pasted "liftM vs do" at http://hpaste.org/5702
05:43:29 <Lord_Illidan> We have a project to do regarding a small AI based game. Our lecturer said we could do a java based gui, and the underlying AI in haskell
05:43:39 <Lord_Illidan> how is it possible??
05:43:56 <Cin> talk to java via API or a pipe, i'd imagine
05:44:10 <Lord_Illidan> the AI game is based off Wumpus World in "Artificial Intelligence : A modern Approach"
05:44:50 <Lord_Illidan> so it is possible? A haskell backend?
05:45:10 <bartwe> stdin/out redirection perhaps
05:45:25 <Philippa_> I'd suggest a network client/server setup myself, but yeah, it's possible
05:46:14 <Lord_Illidan> Philippa_, what??
05:46:20 <hpaste>  Cin annotated "liftM vs do" with "probably nicer" at http://hpaste.org/5702#a1
05:48:07 <Lord_Illidan> I was leaning on a gtk haskell approach if I manage to learn haskell in time
05:48:12 <Lord_Illidan> or else do the whole thing in java
05:48:15 <hpaste>  Cin annotated "liftM vs do" with "etc... which is better?" at http://hpaste.org/5702#a2
05:48:54 <Lord_Illidan> I'm not sure, though..How does one "make" an API?
05:49:13 <resiak> Lord_Illidan: do you already speak gtk?
05:49:36 <wli> Cin: eqOp [x, y] = fmap SchBool $ liftM2 ((==) `on` eval) x y ?
05:49:42 <Lord_Illidan> resiak, Nope..but I don't think it's too hard to learn..or is it?
05:50:17 <Lord_Illidan> At least..I don't think it's harder than doing a haskell backend
05:50:18 <Cin> wli: ah that is quite nice
05:50:20 <oerjan> wli: i think the `on` eval goes outside the liftM2
05:50:22 <Saizan> wli: eval is the monadic part
05:51:25 <wli> fmap SchBool $ (liftM2 (==) `on` eval) x y then?
05:51:25 <oerjan> eqOp [x, y] = fmap SchBool $ (liftM2 (==) `on` eval) x y
05:52:41 <wli> Cin: on :: (b -> b -> c) -> (a -> b) -> a -> a -> c is from Data.Function
05:52:42 <Cin> indeed
05:52:48 <oerjan> or SchBool <$> (liftM2 (==) `on` eval) x y
05:52:58 <Cin> wli: right! i have imported that :D
05:53:06 <wli> The <$> looks sexy.
05:53:08 <Cin> oerjan: ahh that is even nicer
05:53:29 <Cin> is that in Control.Monad?
05:53:34 <Cin> @hoogle (<$>)
05:53:36 <lambdabot42> Did you mean: (<$>)
05:53:36 <lambdabot42> Prelude.undefined :: a
05:53:36 <lambdabot42> Control.Monad.State.Class.get :: MonadState s m => m s
05:53:36 <oerjan> Control.Applicative
05:53:40 <wli> Control.Applicative
05:53:43 <Cin> cheers
05:54:37 <Cin> the <|> is conflicting with Parsec's
05:54:43 <Cin> how do i do a `hiding' for an operator?
05:54:49 <Cin> i'm getting a parser error =o
05:54:53 <wli> Cin: Unwrapping the list requires explicit argument passing.
05:54:58 <Cin> MonadScheme.hs:10:35: parse error on input `<|>' D:
05:54:59 <oerjan> hiding ((<|>)) i think
05:55:08 <resiak> Lord_Illidan: i think it's pretty straightforward
05:55:25 <Cin> wli: hrrm, indeed..
05:55:26 <Lord_Illidan> resiak, phew
05:55:37 <Cin> oerjan: ah, yes, that is riht
05:55:40 <Lord_Illidan> resiak, I'll try to start gtk immediately
05:55:47 <resiak> eh
05:55:57 <resiak> get the meat of your game done first
05:56:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5703
05:56:40 <oerjan> mind you i am not completely convinced using on there helps readability
05:57:15 <hpaste>  fnord annotated "(no title)" with "can anyone see the problem?" at http://hpaste.org/5703#a1
05:57:16 <hpaste>  fnord annotated "(no title)" with "can anyone see the problem?" at http://hpaste.org/5703#a2
05:57:31 <fnord`> Can anyone see the problem in the hpaste I just posted
05:58:13 <oerjan> fnord`: needs an extension
05:58:30 <fnord`> an extension?
05:58:38 <fnord`> like a ghc extension?
05:58:42 <oerjan> yes
05:58:45 <resiak> or, make PureStrategy a newtype
05:59:08 <fnord`> oh, right, it's because PureStrategy is a synonym for a type with multiple bits?
05:59:21 <Saizan> {-# LANGUAGE FlexibleInstances #-}
05:59:30 <oerjan> more or less yeah
05:59:48 <fnord`> are there any problems associated with that extension?
06:00:09 <Saizan> not really
06:00:41 <Saizan> it was in .fglasgow-exts so it was considered safe
06:00:41 <fnord`> cool
06:00:51 <fnord`> thanks
06:01:45 <wli> I'd be interested in learning just enough gtk or _something_ to do two things: (a) plot things vaguely like gnuplot (b) render generated LaTeX to a GUI window.
06:02:58 <wolverian> latter would use evince, I suppose, if you mean pdf
06:03:51 <wli> I don't care too much so long as I can update the window from the program to spit out the results of progress.
06:04:06 <wli> (which holds for both cases)
06:05:13 <wli> Mixing (a) and (b) in the same GUI window would also be nice, though I've managed to live without anything for either in isolation for some time, so I can probably go on without them a while longer.
06:06:30 <Philippa_> do you mean actually overlapping, or is just a splitter-type arrangement good enough?
06:06:54 <wli> Splitter would be fine. The LaTeX bits would be something on the order of a legend.
06:10:16 <wli> It might help if the least absolute deviations rational regression code worked better and faster.
06:10:34 <pejo> wli, have you seen auctex and auctex-preview?
06:11:28 <wli> pejo: I thought they were LaTeX packages, not things to fiddle with GUI windows. Maybe I'm mistaken as to what they are.
06:12:29 <pejo> wli, oh, you don't get gui windows, but you get inline-previews of your latex code, so equations are rendered for example.
06:13:10 <wli> pejo: Not sure how to cope with the LaTeX being the output of a long-running program displaying its progress.
06:13:38 <pejo> wli, ah, in that case it probably doesn't work.
06:21:36 <wli> The mostly brute-force grid search is too dogslow for high dimensionality. Things like r_k(x) = p_k(x)/q_k(x) where deg(p_k)=3 and deg(q_k)=2 and f(x) = r_0(x) + \sum_{k=1}^n r_k(x) J_0(\lambda_k x) where the \lambda_k are the positive zeroes of J_0(x) in ascending order (i < j implies \lambda_i < \lambda_j).
06:21:49 <wli> ergh, things like that are what I ultimately want.
06:23:34 <wli> (or other funny transcendental function bases in a similar fashion to J_0's usage above in the hopes of smoking out as much of the power series of an analytic function as possible from the regression)
06:30:54 <wli> Hmm. Is the least absolute deviations problem here convex?
06:31:38 <araujo> morning
06:32:34 <wli> (I'd also like to change this over to use orthogonal deviations, i.e. the sum of the minimum distances to the sample points from any point on the curve, in no small part because this is for geometric purposes)
06:37:51 <wli> 0 = (d/dx) |(x_k, y_k)-(x, p(x)/q(x))|^2 = (d/dx) (x_k-x)^2 + (y_k-p(x)/q(x))^2 = 2(x-x_k) + 2(p(x)/q(x)-y_k)(p'(x)/q(x)-p(x)q'(x)/q(x)^2) so solving the (moderately high-degree) polynomial equation 2(x-x_k)q(x)^3 + 2(p(x)-y_kq(x))(p'(x)q(x)-p(x)q'(x)) = 0 should find the stationary points for a plain old rational function r(x) = p(x)/q(x), with the case I'm interested in being deg(p(x))=3 and deg(q(x))=2.
06:39:16 <wli> That could get a wee bit hairy with the various "stiff" things polynomials do, especially since I care about all the roots, not just finding one root and not caring which one.
06:47:13 <wli> There are other ways to solve minimization problems that might do better than solving polynomials. Golden section search or some such. I'll need something that works reliably before I can plug it in.
06:48:14 * araujo scratches his head
06:48:41 <wli> araujo: Was it something I said?
06:49:20 <araujo> wli, no .. go on :-P
06:54:37 <boegel> @seen shapr
06:54:38 <lambdabot42> shapr is in #haskell. I don't know when shapr last spoke.
07:00:58 <ertai> does anyone have tried the (hs-)plugins library with GHC 6.8.2?
07:02:19 <Saizan> ertai: do you have the darcs version?
07:02:44 <ertai> Saizan: still there http://www.cse.unsw.edu.au/~dons/code/hs-plugins
07:02:47 <ertai> ?
07:03:22 <Saizan> ?where hs-plugins
07:03:23 <lambdabot42> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:03:27 <Saizan> ?where hs-plugins-repo
07:03:27 <lambdabot42> I know nothing about hs-plugins-repo.
07:04:36 <Saizan> ertai: the new one is on code.haskell.org
07:04:43 <Saizan> but i can't access it atm
07:05:27 <ertai> Saizan: your sure, under what name?
07:05:33 <oerjan> @users
07:05:34 <lambdabot42> Maximum users seen in #haskell: 417, currently: 417 (100.0%), active: 6 (1.4%)
07:06:43 <Saizan> ertai: let me grep the logs
07:07:38 <int-e> http://code.haskell.org/~dons/code/hs-plugins ?
07:07:51 <Saizan> yup
07:12:56 <ertai> int-e, Saizan: great thanks
07:13:44 <Cin> hrm
07:13:59 <ertai> dons_: Please, could the motd of http://www.cse.unsw.edu.au/~dons/code/hs-plugins be updated to refer to the new URL http://code.haskell.org/~dons/code/hs-plugins?
07:14:08 <Cin> my `eval' function calls a bunch of functions which handle special operators (scheme interpeter)
07:14:26 <Cin> i've put those special operator functions in a separate module, except they also need to call the `eval' function themselves
07:14:44 <Cin> so i imported the other module in each, now i'm getting a cyclic error
07:15:06 <Cin> is there some specific keyword i need to say "this is recursively imported"?
07:16:52 <Saizan> Cin: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
07:16:54 <oerjan> @seen dons
07:16:54 <lambdabot42> dons is in #haskell. I don't know when dons last spoke.
07:16:58 <oerjan> @seen dons_
07:16:59 <lambdabot42> dons_ is in #haskell. I don't know when dons_ last spoke.
07:17:07 <Saizan> Cin: it's a bit hacky, though
07:18:10 <Cin> eh, i'll just leave the special operators in the same module as the eval function
07:21:22 <yaru1022> is there darcs repository for fingertree?
07:21:35 <yaru1022> or is the package on hackageDB ok?
07:23:42 <nominolo> yaru1022: i'd say it's ok
07:24:26 <yaru1022> I have one more question :)
07:24:41 <yaru1022> if I install two different versions of regex-base, how does compiler know which one to use?
07:25:15 <Saizan> yaru1022: it uses the one with the greatest version number unless you specify one with -package
07:25:17 <yaru1022> i have 0.92 version but in order to install yi, it looks like i need 0.72.0.1
07:25:25 <Saizan> or in a .cabal file
07:25:40 <yaru1022> Saizan, i c... thanks
07:25:49 <nominolo> yaru1022: that's a tricky problem, actually
07:26:52 <nominolo> yaru1022: see the last message in this thread: http://groups.google.com/group/yi-devel/browse_thread/thread/34c097335266f523/b29679b7dae81349?lnk=gst&q=regex#b29679b7dae81349
07:29:03 <wli> http://www.springerlink.com/content/b35647833p354348 <-- this sounds promising
07:30:36 * wli is skeptical of things without bounding intervals of some sort.
07:36:44 <Stinger> whats a good lib for doing some simple http client stuff?
07:39:05 <Cin> tagsoup is good for extracting specific things from web pages
07:39:46 <xerox> ?where http
07:39:47 <lambdabot42> http://www.haskell.org/http/
07:39:50 <xerox> ?where hxt
07:39:50 <lambdabot42> http://www.fh-wedel.de/~si/HXmlToolbox/
07:42:10 <Stinger> cool thanks
07:53:19 <Stinger> hmmm parsec should come with ghc shouldn't it?
07:53:57 <Cin> err i think so. i don't remember having to install a package for it
07:54:06 <Cin> i use ghc6.8..
07:54:33 <EvilTerran> it came with 6.6.* and 6.8.*
07:56:38 <LoganCapaldo> disn't it in the -exras tarball for 6.8z?
07:56:46 <LoganCapaldo> man I can't type
07:57:32 <olsner> LoganCapaldo: your sentence is broken!
07:57:45 <LoganCapaldo> yes it is
07:57:53 <LoganCapaldo> can I have a new one please?
07:58:06 <olsner> I think it's too late for that now
07:58:30 <TomMD> ANN: Control.Event is now on Hackage
07:58:33 <olsner> you only have so many sentences to choose from
07:59:45 <Stinger> it's ok, figured out what was going on
08:00:21 * wli tries to figure out if this is convex at all.
08:05:28 <Stinger> > join (+) 4
08:05:30 <lambdabot42>  8
08:06:14 <LoganCapaldo> > ap (+) id 4
08:06:17 <lambdabot42>  8
08:06:20 <Stinger> ok, so what do I have to import to get that to work in ghci
08:06:30 <LoganCapaldo> Control.Monad
08:06:32 <Stinger> where is the (-> r) monad
08:06:40 <Stinger> yeah got that one
08:06:43 <doserj> Control.Monad.Reader
08:06:48 <LoganCapaldo> Control.Monad.Reader
08:07:01 <Stinger> ah
08:07:09 <Stinger> thanks, thats a reader is it? hmm
08:07:16 <LoganCapaldo> yep
08:07:21 <LoganCapaldo> tht's the reader monad
08:07:23 <LoganCapaldo> mmmmm reader
08:08:15 <LoganCapaldo> > (do { x <- ask ; return x + 1 }) 2
08:08:16 <lambdabot42>   add an instance declaration for (Num (t -> t))
08:08:33 <LoganCapaldo> lawl
08:09:05 <gwern> 'If this can be useful, I recently became aware that Barclays Capital (an investment bank in London) may be using haskell as a scripting language to price exotic equity derivatives.' <-- interesting
08:09:22 <LoganCapaldo> they didn't interview me
08:09:33 <LoganCapaldo> you telling me I coulda been coding haskell?
08:09:37 <LoganCapaldo> blast
08:09:48 <LoganCapaldo> i shoulda tried harder
08:09:56 <gwern> LoganCapaldo: you applied to barclays?
08:10:10 <LoganCapaldo> well gave them a resume at least
08:11:08 * LoganCapaldo loves his job anyway, even if it's not haskell
08:11:15 <gwern> what is it?
08:11:22 <LoganCapaldo> coding makes me happy
08:11:36 <LoganCapaldo> C++
08:12:00 * gwern cannot sympathize; coding in a language I dislike is worse than not coding at all
08:12:13 <Saizan> Stinger: the reader monad is (->) r, or (r ->) in pseudosyntax, not (-> r)
08:12:42 <LoganCapaldo>  but I like C++
08:13:04 <LoganCapaldo> no sympathy necessary
08:13:24 <fnord`> is there a way I can get the maximum and minimum values for a numeric value
08:13:30 <Stinger> yeah I forgot where the extra set of ()s were supposed to go
08:13:56 <Stinger> ((->) r)
08:13:58 <LoganCapaldo> @ssrc Bounded
08:13:59 <lambdabot42> class  Bounded a  where
08:13:59 <lambdabot42>     minBound, maxBound :: a
08:14:05 <fnord`> cheers
08:14:07 <LoganCapaldo> > minBound :: Int
08:14:09 <lambdabot42>  -2147483648
08:19:06 * wli doesn't even want to think about the pain of multi-objective optimization of this stuff.
08:23:59 <t04no> hi. i am just trying to install xmonad on a debian (testing/unstable)
08:23:59 <t04no> machine (ghc 6.6.1) but the postinstall- (and remove-) scipts for the xmonad-(contribute)-doc
08:23:59 <t04no> packages are broken. anyone experiencing this ? workaround to not
08:23:59 <t04no> screw up ghc-pkg ?
08:24:43 <roconnor> @seen igloo
08:24:44 <lambdabot42> igloo is in #haskell. I don't know when igloo last spoke.
08:25:04 <roconnor> @seen Igloo
08:25:04 <lambdabot42> Igloo is in #haskell. I don't know when Igloo last spoke.
08:27:25 <Lord_Illidan> Hi
08:27:34 <Lord_Illidan> I'm a bit confused about the . operator
08:27:41 <Lord_Illidan> what does it do exactly?
08:28:05 <yaru1022> I got this error: "Yi/Keymap/Users/JP.hs: 6:1: parse error in doc string: [haddock: Internal Happy error" while installing Yi, does anyone know what the problem is?
08:28:26 <Codex_> lord: (f . g)(x) = f(g(x)).
08:28:58 <Deewiant> > (f . g) x
08:28:59 <lambdabot42>   Not in scope: `x'
08:29:06 <Saizan> yaru1022: how are you installing it? maybe you can just skip the doc generation with haddock, or you need to installhaddock 2.0
08:29:09 <Deewiant> darn, wrong bot
08:29:25 <Deewiant> > ((5+) . (3*)) 4
08:29:26 <yaru1022> Saizan, I was installing it by "make all"
08:29:27 <lambdabot42>  17
08:29:33 <yaru1022> Saizan, how do I skip the doc generation?
08:30:23 <Lord_Illidan> Thanks!
08:31:05 <Lord_Illidan> So..  printPicture (flipV (flipH(horse))) comes : printPicture((flipV.flipH) horse)
08:31:06 <Lord_Illidan> ?
08:31:32 <Deewiant> or (printPicture . flipV . flipH) horse
08:31:45 <Deewiant> or printPicture $ flipV $ flipH horse
08:32:14 <Saizan> yaru1022: i'm not sure, i've not used yi much, maybe make run-inplace ?
08:33:12 <Codex_> lord: note that you need to have spaces around . when it's function composition.
08:33:18 <Lord_Illidan> so why does this work :  (printPicture . flipH . flipV . flipH) horse but this does not :  printPicture (flipH . flipV . flipH) horse
08:33:31 <yaru1022> Saizan, what do you mean by run-inplace?
08:33:38 <funktio> printPicture $ (flipH . flipV) horse
08:34:46 <Lord_Illidan> ah funktio, that did it
08:34:57 <Saizan> yaru1022: it starts yi from the source directory without installing it, at least you can see if it works
08:35:10 <yaru1022> Saizan, ok i'll try
08:35:27 <EvilTerran> Lord_Illidan, (printPicture . flipH . flipV . flipH) horse = printPicture (flipH (flipV (flipH horse)))
08:35:58 <Lord_Illidan> EvilTerran, thanks
08:36:04 <Lord_Illidan> but why?
08:36:09 <EvilTerran> the second is passing the function (flipH . flipV . flipH) to printPicture, rather than its return value
08:36:14 <EvilTerran> you can tell by applying
08:36:17 <EvilTerran> ?src (.)
08:36:17 <lambdabot42> (.) f g x = f (g x)
08:36:28 <EvilTerran> ie "(f . g) x = f (g x)"
08:36:48 <EvilTerran> repeatedly, and by remembering that function application binds tighter than any operator and is left-associative
08:36:57 <funktio> another way: printPicture ((flipH . flipV) horse)
08:37:00 <Stinger> function application is a b c is (a b) c
08:37:12 <Lord_Illidan> I c
08:37:13 <Deewiant> funktio: that's what he originally said :-)
08:37:25 <idnar> heh
08:37:41 <funktio> Deewiant: ah, ok :-)
08:37:46 <yaru1022> Saizan, yeah~ it works
08:37:48 <helmut> Hi. I've go a tree-like data structure. Is there a simple way to construct a new data structure with each node having a new common element attached? (like turning data Foo a = Bar | Qux a | Quux a a into data SpamFoo a | Bar Spam | Qux Spam a | SpamQux Spam a a)
08:39:21 <fnord`> Anyone know why there isn't a Bounded instance for Float?
08:39:46 <Stinger> cause float can be +- inf I suppose
08:39:57 <SamB> nan doesn't help, either
08:40:02 <EvilTerran> > -1/0
08:40:04 <lambdabot42>  -Infinity
08:40:08 <EvilTerran> > [-1/0 ..]
08:40:10 <lambdabot42>  [-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infi...
08:40:15 <SamB> > 0/0
08:40:16 <lambdabot42>  NaN
08:40:26 <EvilTerran> the Enum instance for float is broken, anyway
08:40:55 <fnord`> but surely there is a largest representable float?
08:41:04 <SamB> besides which, you can't enumerate from the lower bound, because 1+that is not representable
08:42:42 <EvilTerran> > dropWhile ((==) `ap` (+1)) [0..] :: [Float]
08:42:43 <vincenz> > floor (1/0)
08:42:46 <lambdabot42>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,...
08:42:46 <lambdabot42>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:42:59 <EvilTerran> > dropWhile ((/=) `ap` (+1)) [0..] :: [Float] -- even
08:43:03 <lambdabot42> Terminated
08:43:16 <EvilTerran> > dropWhile ((/=) `ap` (+1)) $ map (2^) [0..] :: [Float] -- harumph
08:43:18 <lambdabot42>  [9.0071993e15,1.8014399e16,3.6028798e16,7.2057595e16,1.4411519e17,2.8823038e...
08:44:37 <jpcooper> > 1/0
08:44:38 <lambdabot42>  Infinity
08:44:56 <jpcooper> > (1/0) / 2
08:44:58 <lambdabot42>  Infinity
08:45:02 <SamB> fnord`: there is a number that is the largest number that a given fixed-size floating-point format can represent, yes...
08:51:59 <desegnis> > let largest = (1/0) in largest > (1/0 :: Double) -- So 1/0 is not the largest Double
08:52:01 <lambdabot42>  False
08:54:23 <LoganCapaldo> Bounded would be deceiving float also
08:54:29 <LoganCapaldo> *for
08:58:33 <helmut> I'm probably "doing it wrong". Could someone take some time discussing this "data structure morphing" with me?
08:59:37 <helmut> I've got a tree-like data structure and want to attach a value to each node.
08:59:46 <_boegel_> @seen shapr
08:59:46 <lambdabot42> shapr is in #haskell. I don't know when shapr last spoke.
08:59:59 <SamB> helmut: what are your actual datatypes?
09:00:33 <helmut> data Expression = Identifier String | Application Expression Expression | Function String Expression | ...
09:01:52 <helmut> now I'd like to attach a type to each expression in a tree.
09:02:12 <helmut> and this will not be the last time. in a second run I'd like to attach other information to that tree.
09:02:54 <helmut> My first approach was to define data TypedExpression = TypedIdentifier Type String | ...
09:02:59 <helmut> but this gets longish.
09:03:12 <helmut> and really ugly when attaching something else
09:03:30 <LoganCapaldo> data Attach attachment attachee = Attach attachment attachee ; type TypedExpression = Attach Type Expression
09:03:45 <SamB> well... that doesn't sound much different from what I've seen... then again, I don't remember what the input and output of GHC's typechecker look like
09:03:46 <helmut> LoganCapaldo: Expression is recursive
09:03:55 <LoganCapaldo> Mmm
09:04:06 <LoganCapaldo> wheres a type fixpoint combinator when you need it?
09:04:50 <helmut> I thought about defining the initial expression with unique ids attached and then use maps from ids to attachments.
09:04:58 <helmut> Is that a bad idea?
09:05:20 <LoganCapaldo> you could just stick a list of atachments on every node
09:05:35 <SamB> honestly I've never written a proper typechecker
09:06:03 <helmut> LoganCapaldo: problem: attachments may be different things not known when defining Expression
09:06:20 <SamB> only one for a fully monomorphic language with about as much type inference as C ;-)
09:06:28 <LoganCapaldo> existntional?
09:06:39 <helmut> SamB: it's even worse. I'd like to allow side effects and therefore try to implement something like an "effect system"
09:07:20 <LoganCapaldo> which I can't spell
09:07:26 <helmut> SamB: maybe I can also  define attributes like "this function is commutative in arguments 1 and 4"
09:07:38 <LoganCapaldo> I hope I'm least giving you things to think about whie failing to be helpful ;)
09:08:07 <helmut> LoganCapaldo: well the lists go in the same direction as attaching unique identifiers
09:08:18 <LoganCapaldo> yeah i know
09:08:42 <helmut> LoganCapaldo: I only like having multiple maps a bit more, because I can then work on different aspects separately
09:08:43 <LoganCapaldo> I was just thinking remove the indiretion so you don;'t have to worry about the oops, forgot to stick that in the map or whatever
09:09:10 <helmut> LoganCapaldo: well with lists you need an index in that list.
09:09:34 <helmut> I even thought about mapping trees to attachments.
09:09:35 <SamB> helmut: eh?
09:09:45 <LoganCapaldo> why? just walk the list looking for the constructor you're interested in
09:09:59 <helmut> However there might be to instances of Identifier "foo" with different types. :-(
09:10:28 <helmut> LoganCapaldo: I'd like to have no dependencies from the expression to the attachments.
09:10:44 <helmut> LoganCapaldo: so I can just remove attachments from the compilation process like removing a feature
09:10:57 <LoganCapaldo> well his language you're creating, just make sure it's capable of expressing this astraction safely, and as soon as you got a first cut going implement it in itself ;)
09:11:19 <LoganCapaldo> *this
09:11:19 <LoganCapaldo> *abstraction
09:11:21 <helmut> LoganCapaldo: I don't want to implement it in itself.
09:11:50 <helmut> LoganCapaldo: I don't think that the language will get a syntax.
09:11:51 <LoganCapaldo> I was just joking
09:18:07 <LoganCapaldo> hence the wnky face
09:23:02 <helmut> SamB, LoganCapaldo: My first question remains: Doesn't it look like I'm "doing it wrong"?
09:23:16 <helmut> Is the thing I try to achieve really the thing I want?
09:25:30 <SamB> helmut: I'm looking to see what GHC does...
09:30:28 <helmut> ah. I maybe can define a data ExpressionWithAttachment a = Identifier a String | ...
09:30:52 <hpaste>  gwern pasted "type mismatch" at http://hpaste.org/5704
09:30:54 <SamB> it looks like GHC uses the same AST type for the input and the output of the typechecker...
09:31:09 <gwern> a little odd error; both types seem to me to be Html, but GHC complains
09:31:53 <helmut> with ExpressionWithAttachment I can use a = () in the parse stage and then later enlarge that tuple
09:32:04 <SamB> gwern: they look to be differnet Htmls
09:32:27 <SamB> one of which is not even in scope
09:32:58 <Saizan> helmut: yeah, i was going to suggest that
09:33:35 <gwern> Text.XHtml.Internals.Html is apparently not even exported
09:33:57 <wli> (e.g. \ell^1 and \ell^\infty norms of the errors or least absolute deviations and least orthogonal deviations as simultaneous objectives; the indifference surfaces for such things must be hellish)
09:34:01 <helmut> Saizan: I'd like to separate annotations to different modules. Do you have a hint on how to access annotations then?
09:34:36 <bringert> gwern: you are compiling against two different versions of xhtml
09:35:00 <bringert> gwern: before, that error use to be even more incomprehensible: "Html does not match Html"
09:35:02 <Saizan> helmut: like having a tree with multiple annotations and write functions where only one appears in the type?
09:35:27 <gwern> bringert: that was seriously the error message? wow
09:35:40 <gwern> bringert: so a quick ghc-pkg unregister might help?
09:35:42 <bringert> gwern: it's easy to see why that happend
09:35:52 <bringert> gwern: make clean is normally enough
09:36:16 <gwern> this isn't actually a cabalized package (yet)
09:36:29 <bringert> ok, just delete the .o and .hi files then
09:37:57 <bringert> or use -fforce-recomp
09:38:05 <Saizan> helmut: this would be best done with extensible records but we don't have them yet, so i'd first try to understand what you actually need so it's easier to find a simple solution
09:38:09 <gwern> hm, now cgi is comaplinig about needing the old xhtml. better reinstall that
09:38:12 <helmut> Saizan: no, like first attaching types to the tree. then using another annotator attaching computation cost estimates to the tree, which have nothing to do with types. Thus this should work on a untyped as well as a typed tree.
09:38:26 <SamB> huh, GHC seems to have slots in the AST type that have bottom values before typechecking...
09:39:22 <helmut> SamB: I'd like to write tons of annotators working independantly or sometimes depending on others and then use those I like and need.
09:39:27 <helmut> err Saizan
09:40:01 <Saizan> helmut: well attachCost :: Tree a -> Tree (Cost,a), attachTypes :: Tree a -> Tree (Type,a), attachCost . attachType $ (t :: Tree ()) :: Tree (Cost, (Type, ()))
09:40:31 <SamB> helmut: it's not going to be simple
09:41:01 <gwern> drat. I nuked xhtml and cgi off my system, cabal instaleld them, and I get the same error again
09:41:21 <hpaste>  gwern annotated "type mismatch" with "update didn't help..." at http://hpaste.org/5704#a1
09:41:35 <helmut> Saizan: ok. now assuming I have a dependant annotator. for instance an annotator checking for commutative functions will want to have type information.
09:41:51 <gwern> (and no, there are no intermediates hanging around)
09:42:06 <Saizan> depending on previous attachments means that either you force those to be at the top, like Tree (Dep1,(Dep2,a)) or you need typeclasses to make this more generic
09:42:08 <helmut> Saizan: can you give me a pointer on how to run that on a cost-attached type-attached tree?
09:42:33 <helmut> Saizan: could you give me a reading-pointer on type classes?
09:43:54 <Saizan> helmut: in the simplest case you could also just fix the types
09:45:14 <Saizan> http://en.wikibooks.org/wiki/Haskell/Class_declarations <- this is an introduction to type classes
09:47:03 <Saizan> you'd need something like class HasField f ann where getField :: ann -> f, setField :: f -> ann -> ann;
09:48:42 <Saizan> helmut: btw this is already coded in the HList library, but that library contains other features based on some advanced type hackery, so maybe it's not so easy to use if you're starting with haskell
09:49:29 <SamB> Saizan: I don't really think that will work well
09:49:50 <SamB> since some of these annotations might be rather sparsely used...
09:50:38 <helmut> Saizan: another really stupid approach might be to have fixed positions for different attachments.
09:50:40 <SamB> helmut: I suggest playing with some other compilers for a while...
09:50:50 <helmut> SamB: what compilers?
09:51:05 <SamB> JHC, GHC, probably not nyhc...
09:52:26 <helmut> Saizan: still the generic-attachment idea sounds reasonable, so I'm going to implement that and see what comes to my mind afterwards.
09:52:36 <Saizan> helmut: one really simple approach is to have a record type with all the possible annotations and just be careful to not use the ones that are not already set
09:53:25 <bringert> gwern: you have some other installed package depending on xhtml
09:54:00 <Saizan> helmut: the advantage of using a record is that you can extend it later without having to rewrite your functions if you use the labels to access the fields
09:54:21 <helmut> good point
09:54:27 <Saizan> SamB: by sparsely you mean that not every node will be annotated?
09:55:09 <helmut> most of my annotators will annotate every node I think
09:56:01 <SamB> why so?
09:58:23 <Saizan> gwern: isn't a bit weird to have all of HList exported from one module?
09:58:42 <gwern> Saizan: dunno
09:59:26 <helmut> SamB: just my thinking. I may be wrong as well, but the first examples I have in my mind do so.
10:02:19 <jones-> Evening.
10:02:58 <helmut> In any case: Thank you very much (Saizan, SamB, LoganCapaldo). You helped me a lot with thinking this through. :-)
10:02:59 <jones-> If I declare a type deriving "show", do I have to offer an implementation? If yes, what is the syntax? (I'm new to haskell and am reading everything I can, but wouldn't mind some guidance :) )
10:04:38 <funktio> jones-: Haskell will automagically create the implementation, if you just write "deriving Show"
10:04:56 <jones-> funktio: thanks :)
10:05:20 <funktio> but you can write it yourself like this:   instance Show MyThing where show (MyThing x y) = ....
10:05:38 <jones-> funktio: I see, thanks
10:06:07 <hpaste>  gwern annotated "type mismatch" with "inferred types" at http://hpaste.org/5704#a2
10:07:28 <gwern> so the question is, how can I convince it that Text.Html.Html is the same thing as Text.XHtml.Internals.Html...
10:08:29 <gwern> @hoogle Text.Html.Html -> Text.XHtml.Internals.Html
10:08:30 <lambdabot42> No matches, try a more general search
10:09:18 <lispy> gwern: could it be a module problem?
10:09:45 <gwern> what do you mean?
10:09:48 <lispy> gwern: is it possible you have multiple versions of Text.Html and imported more than one?
10:10:23 <lispy> The "Inferred" type seems to match what youw ant
10:10:24 <gwern> ghc-pkg list|grep html lists only one xhtml, and only one html
10:10:33 <lispy> but the expected type seems to be weird
10:10:39 <gwern> html-1.0.1.1 and xhtml-3000.0.2.2
10:11:05 <lispy> well, the type you're naming seems to come from xhtml-3000.0.2.2
10:11:15 <lispy> but the inferred one comes from html-1.0.1.1 i suspect
10:12:20 <gwern> the particular file I'm dealing with calls Network.CGI, and some of the imported files use Network.HTML.
10:13:13 <lispy> Can you try hidding xhtml and exposing html
10:13:17 <lispy> with ghc-pkg
10:13:23 <gwern> the file with main in it originally imported Text.Html as well
10:13:33 <gwern> alright
10:13:35 <Cin> what's a good way to memoize other than using a Data.Map?
10:14:05 <lispy> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- Cin, like this
10:14:05 <lambdabot42>  Parse error at "=" (column 6)
10:14:13 <Cin> ahh, good idea
10:14:14 <lispy> > \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- Cin, like this
10:14:16 <lambdabot42>  <[Integer] -> [Integer]>
10:14:40 <hpaste>  gwern annotated "type mismatch" with "nope" at http://hpaste.org/5704#a3
10:14:49 <cjb> how does that work?
10:14:51 <Cin> of course, that has an O(n) lookup
10:15:06 <gwern> I think Network.CGI must be pulling in xhtml
10:15:20 <Saizan> gwern: are you sure they're the same type?
10:15:24 <helmut> > Infinity
10:15:25 <lambdabot42>   Not in scope: data constructor `Infinity'
10:15:31 <Cin> lispy: perhaps you could define a Data.Map structure from that list? and it would be evaluated lazily presumably although i'm not sure
10:15:57 <gwern> Saizan: Flippi was not described as being broken under old GHCs, so I reason that it must make sense
10:16:21 <lispy> gwern: yes, I think your theroy is right about CGI
10:16:35 <vininim> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
10:16:38 <lambdabot42>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:16:47 <lispy> Cin: I don't know much about Data.Map
10:16:54 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- Cin, like this
10:16:56 <lambdabot42>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:16:59 <vininim> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in head (drop 1000 fibs)
10:17:01 <lambdabot42>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
10:17:04 <Cin> lispy: oki doki. i'll have a see what i can cook up
10:17:25 <lispy> Cin: actually that fibs I show you isn't O(n) in the look up
10:17:41 <lispy> Cin: it precomputes the values and only ever looks at the most recent and previous when computing a new value
10:17:50 <lispy> Cin: oh I guess the result is O(n) in lookup
10:17:51 <Cin> lispy: but if i want random access it is?
10:17:53 <Cin> indeed
10:18:01 <Cin> lispy: i know what you're saying
10:18:11 <lispy> > fromList $ fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- Cin, like this
10:18:12 <lambdabot42>   Not in scope: `fromList'
10:18:20 <lispy> ?hoogle fromList
10:18:21 <lambdabot42> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
10:18:21 <lambdabot42> Data.Set.fromList :: Ord a => [a] -> Set a
10:18:21 <lambdabot42> Data.Sequence.fromList :: [a] -> Seq a
10:18:37 <lispy> > Data.Map.fromList $ fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
10:18:39 <lambdabot42>   Not in scope: `Data.Map.fromList'
10:18:43 <Cin> damn
10:18:57 <lispy> data.map does have a method like that though
10:19:03 <lispy> ?hoogle [a] -> Data.Map
10:19:04 <lambdabot42> No matches, try a more general search
10:19:08 <lispy> ?hoogle [a] -> Map
10:19:09 <lambdabot42> No matches, try a more general search
10:19:16 <Saizan> lispy: but fromList can't handle infinite lists
10:19:28 <lispy> well, that' a problem then :)
10:20:10 <Cin> Data.Map.fromList $ zip [1..] $ fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
10:20:13 <Cin> this didn't terminate
10:20:15 <Cin> saizan: ah
10:20:22 <gwern> (geez. this code worked in 2004, which wasn't all that long ago. how frustrating these compilation errors can be)
10:21:05 <lispy> Cin: well, maybe you can figure out an upper bound
10:21:37 <lispy> throw a, take n, infront of fix $ \fibs ...
10:21:46 <Cin> lispy: true
10:22:06 <Saizan> if you have a continuos range you can use a lazy array instead
10:22:48 * mrd still thinks like 2004 wasn't all that long ago, but then remembers its 2008
10:22:54 <lispy> Cin: to be fair, I don't know how you'd do better than O(n) lookup with an infinite list
10:23:47 <Cin> lispy: well i was thinking if my infinite series of numbers was calculated with a map, and use the map to lookup values if they exist, that would be pretty damn fast?
10:24:05 <gwern> lispy: well, if there's structure to it, you can exploit that. there are sub-N algorithms for calculating a particular digit of pi, iirc
10:24:09 <lispy> Cin: what I just said is riddled with mathematical problems but hopefully you see my point.  You can't jump around in an infinite sequence very well.  For example.
10:24:15 <Cin> lispy: ie so f(n) is only ever calculated once
10:24:27 <Cin> lispy: indeed
10:24:28 <SamB> lispy: a ... fibonacci tree?
10:25:08 <lispy> SamB: I meant in general, but yeah maybe this specific problem makes it easy.  What is a fibonacci tre?
10:25:20 <lispy> I thought fibonacci sequences was about modeling rabbits not trees...
10:25:57 * wli points to the Fastest Fibonacci in the West article.
10:25:59 <SamB> I forgot, but they aren't balanced
10:26:03 * lispy wonders if SamB has started college yet
10:26:21 <SamB> I seem to be a second semester sophomore
10:26:40 <lispy> SamB: cool, iirc last I talked to you, you hadn't started yet.
10:26:54 <SamB> eh?
10:26:55 <lispy> SamB: so...assuming you're doing CS, do you feel challeneged at all?
10:27:02 <SamB> not doing CS!
10:27:07 <SamB> I'm doing EE
10:27:12 <lispy> oh
10:27:44 <gwern> a worthwhile career path. somone has to keep moore's law going, after all
10:27:54 <SamB> EE doesn't have the capacity for painfully bad classes that CS does
10:28:08 <lispy> lol
10:28:26 * lispy almost studied EE in addition to math and CS
10:28:50 <sw17ch> SamB: but you have to take differential equations... which i'm not a fan of :)
10:28:54 <chadz> anyone have lighttpd working with fastcgi? I can't seem to get my haskell bins workin.
10:29:16 <chadz> it'll just _hang_ when I try and load it.
10:29:21 <SamB> actually, apparantly as a computer-track EE I didn't need to take DE.
10:29:37 <chadz> computer-engineering?
10:29:43 * gwern begins seriously considering looking up how unsafeCoerce works
10:29:59 * wli has gotten to (1.0043302570165744 * x + 0.10220386686251239 * x^3) / (1 + 7.294048456012334e-2 * (x - 3.7533034511588216e-4)**2) for sin(x) on [0..pi/2] since last night.
10:30:06 <lispy> gwern: it just lies to the compiler about the types
10:30:09 <SamB> which is kind of annoying since I already took it at the community college, but oh well, I wanted to learn it anyway
10:30:11 <lispy> ?hoogle unsafeCoerce#
10:30:12 <lambdabot42> Hoogle Error: Parse Error: Unexpected character '>'
10:30:41 <gwern> lispy: is it such a sin when the lie is a truth?
10:31:23 <lispy> gwern: if the lie is actually true, then it raises the question why doesnt the compiler know the truth?  With the admission that sometimes, explaining it to the compiler takes unbounded time.
10:32:05 <sw17ch> SamB: I work with a bunch of EE's and just accepted a full time position there (yay for not being an intern any more!) come May
10:32:12 <lispy> gwern: I don't know why you're seeing the error you're seeing.  You need someone like dcoutts or dons or Cale or someone to help you.
10:32:24 <gwern> lispy: as far as I can tell, the code is returning with the type Text.Html.Html, while the compiler is insisting on Text.XHtml.Internals.Html, but Text.XHtml seems to be importing Html from Text.Html!
10:32:50 <lispy> gwern: are you using a more modern GHC than this was developed with?
10:32:57 <gwern> lispy: I mean, if you want to give it a crack yourself, dl http://www.flippac.org/projects/flippi/ .03 and ghci Flippi.hs
10:33:00 <gwern> lispy: yes
10:33:24 <lispy> gwern: perhaps there have been refinements to the type checker since then
10:33:48 <lispy> gwern: have you checked the ghc bug tracker to see if Network.CGI is listed?
10:34:30 <SamB> what's kind of pathetic is that apparantly I'm the only one in the school to have ever expressed an interest in actually designing a CPU... even a toy one! at least, that's what my logic design teacher seems to think.
10:34:51 <lispy> hehe
10:35:04 <lispy> CPU design is fun
10:35:09 <lispy> SamB: so have you made one yet?
10:35:25 <SamB> not yet
10:35:45 <sw17ch> which school?
10:35:51 <SamB> Widener University
10:36:02 <chadz> for large peoples
10:36:19 <SamB> no! for small peoples who wish to become larger!
10:36:27 <gwern> lispy: the only hits on the GHC trac don't seem to have anything to do with my problem
10:36:39 <gwern> 1ditto for Text.Html
10:36:46 <sw17ch> I've wanted to do Integrated Circuit emulation for a long time
10:36:54 <lispy> SamB: what about ALU design?
10:37:27 <chadz> anyone have any luck running fastcgi code on lighttpd? I gave up with some basic code, and can't even run the multi.fari.us example code
10:37:30 <lispy> gwern: yeah, i guess it's a weird problem
10:37:34 <wli> I think instruction pipelines are more interesting, but anyway.
10:37:47 <SamB> lispy: we are still in the chapter on minimization
10:38:03 <lispy> SamB: karno(sp?) maps?
10:38:18 <wli> lispy: Got any ideas on optimization methods for my rational regression affair?
10:38:20 <SamB> karnaugh, I think
10:38:21 <wli> Karnaugh
10:38:32 <lispy> SamB: once you understand how to design an ALU, desiging a CPU is just about adding features and optimizations
10:38:34 <SamB> often called just k-maps
10:38:38 <chadz> lulz, i remember those.
10:38:38 <wli> Quine-McCluskey is a better way to go about it.
10:38:41 <lispy> wli: none :)
10:39:06 <sw17ch> is there support for Dependent Types out of the box in GHC?
10:39:10 <wli> lispy: I can't even figure out of the idiot thing is convex or not.
10:39:12 <SamB> wli: yes, that's in the same chapter
10:40:13 <SamB> I think k-maps are covered partly in order to make it easier to see what Quine-McCluskey does
10:40:20 <lispy> wli: which part, sin(x) or the thing you computed?
10:41:48 <wli> lispy: No, the fitness function sum [abs (y - eval coefs x) | (x, y) <- points] where eval (Coefs a0 a1 a2 a3 b1 b2) x = (a0 + x * (a1 + x * (a2 + x * a3))) / (1 + b1*(x-b2)^2)
10:42:59 <lispy> turns out, mathematica is easie to use if you read the help than if you guess at the syntax
10:43:10 <SamB> lispy: yes it does
10:43:29 <SamB> who would have guessed that you have to use square brackets?
10:43:41 <SamB> for parameters
10:43:46 <lispy> a range is {x, 0, Pi/2}
10:43:49 <SamB> and curly ones for lists
10:43:56 <wli> lispy: I'm trying to write something I can call as a library function.
10:44:03 <lispy> I tried, x = 0..Pi/2, x = [0,Pi/2], but those are not valid
10:44:18 <wli> lispy: That is, from Haskell, so Mathematica is out.
10:44:19 <lispy> wli: yeah, i just wanted to graph sin(x) on that range
10:44:24 <SamB> lispy: oh, honestly I've always thought maple's syntax for that was odd
10:44:27 <Stinger> hmm annoying, can't seem to get firefox to open text/x-haskell in a tab
10:44:34 <yetAnotherOne> has anyone ever written a complex vector library?
10:44:47 <lispy> Stinger: there is a FF plugin for that, just a sec
10:44:54 <wli> lispy: gnuplot works; e.g. plot [0:pi/2] (0 + x * (1.0043302570165744 + x * (0 - x * 0.10285017989938523))) / (1 + 7.229417152325049e-2 * (x - -2.709826917569626e-4)**2), sin(x)
10:44:55 <SamB> Stinger: yeah, firefox isn't very smart with text/ types...
10:45:16 <lispy> Stinger: http://www.spasche.net/mozilla/
10:45:47 <Stinger> lispy, ah cool, I was looking for something like this
10:46:10 <lispy> Stinger: yeah, it's really nice.  They should bundle it as part of FF
10:47:02 <Stinger> web pages mention its going to be fixed, someone in the firefox channel said it was in the bug tracking
10:47:25 <lispy> Stinger: awesome
10:48:44 <lispy> wli: nice approximation
10:49:00 <lispy> wli: the real one has a bitter curve around 1, but it's really close
10:49:14 <wli> lispy: The idea is pretty bonehead; use the \ell^1 norm instead of the \ell^2 norm (a.k.a. least squares) and use rational functions instead of polynomials.
10:49:25 <wli> lispy: The real one in what sense?
10:49:33 <lispy> sin(x)
10:49:45 <lispy> sin(x) is the best approximation of sin(x) that I know of :)
10:50:49 <wli> lispy: Okay, well, one can always smoke out the maxima of the (squared) absolute value of the error.
10:50:51 <gwern> lispy: did you try flippi? did it compile for you?
10:51:06 <lispy> gwern: sorry, I didn't try it
10:51:23 <lispy> i have ghc6.6.1
10:52:04 <lispy> oh sorry, just 6.6
10:52:10 <gwern> try anyway; before I email phillipa, I'd like to know if it's just me
10:53:34 <lispy> Scripts.hs:34:7: Could not find module `Data.FiniteMap':
10:54:10 <lispy> gwern: did you have that problem too?  I think I need Data.Map, right?
10:54:27 <gwern> lispy: no, I guess FiniteMap is part of the default install with 6.8.x then
10:54:36 <gwern> hm/ alright, anyone with 6.8.x besides me want to try it?
10:54:41 <lispy> gwern: now I'm missing Network.CGI
10:55:59 <gwern> that's seperate, I think
10:58:02 <allbery_b> hm?  FiniteMap is the one that was dropped in 6.6, wasn't it?
10:59:24 <gwern> doubt it. I have no trouuble with Scripts.hs in my 6.8.2
11:00:07 <lispy> or maybe, dropped in _only_ 6.6?
11:01:37 <gwern> http://www.flippac.org/projects/flippi/ <-- download; try; tell me what errors you get
11:01:41 <allbery_b> I don't see it in the hierarchical libraries.  I think someone did put a version in hackage to help forward port 6.4 programs
11:08:50 <gwern> bah! y'all are no fun; it's not a big favor I ask
11:11:49 <wli> lispy: If you like that try (-0.09003991505*x^3 - 0.0467935561*x^2 + 0.974470671 - 0.88948e-5)/(0.06540279518*x^2 - 0.04405068294*x + 0.9740817272)
11:13:51 <zygen> Alrighty, so I'm doing this shortish command line program in haskell, and I need to deal with files, but when a use readFile wrapped in a certain function, it gives me an error like this: openFile: resource busy (file is locked)
11:14:06 <zygen> But if I just call the function directly (like in ghci), it works perfectly
11:14:11 <gwern> zygen: put it on hpaste
11:14:15 <zygen> alright
11:15:48 <hpaste>  Zygen pasted "(no title)" at http://hpaste.org/5706
11:16:30 <zygen> When I try to do writeList in the main function it doesn't work
11:16:34 <zygen> Oh, I guess I should put the main in there too
11:17:28 <hpaste>  Zygen annotated "(no title)" with "(no title)" at http://hpaste.org/5706#a1
11:18:08 <zygen> So when I call it with the rm arguement, it gives me that error
11:18:20 <gwern> '    if ((length args) < 0)?
11:18:25 <Cale> zygen: I thought I might note that your condition on the argument list will never be true.
11:18:32 <gwern> how can the length of args be less than 0, ever?
11:19:01 <doserj> integer overflow *cough*
11:19:13 <zygen> Heh, oh... I think I put that in there so it didn't error out if I didn't have any arguments
11:19:24 <zygen> I guess I could just check if args is not defined or something
11:19:25 <Cale> You want <= 0 probably :)
11:19:38 <gwern> doserj: you mean Int? ok, so what if he'd used genericLength?
11:19:50 <Cale> Or more realistically,  null args
11:20:06 <zygen> Ah, yeah, null args
11:20:13 <Cale> I don't think you can pass enough args to a program to cause integer overflow anyway
11:20:31 <gwern> for that matter, where's 'add' defined?
11:20:39 <doserj> :)
11:20:42 <resiak> presumably platforms exist without arg length limits?
11:20:53 <zygen> Heh, I guess I should just dump the whole file in there then
11:22:11 <hpaste>  Zygen annotated "(no title)" with "(no title)" at http://hpaste.org/5706#a2
11:22:32 <litb> hello again all
11:23:02 <zygen> But the thing is, if I just do it in ghci, it always works perfectly
11:23:33 <zygen> but if I compile it and stuff, it give me the file is locked error
11:23:36 <zygen> gives*
11:23:57 <zygen> And I'm on linux anyway
11:24:07 <zygen> So... that doesn't make much sense.
11:26:59 <zygen> Hm, it seems like it might be related to lazy i/o.  I'll just figure out how to not use lazy i/o then
11:27:31 <gwern> bytestrings offer strictness, btw
11:27:55 <lispy> I think it's really unfortunate that we have so many lazy IO functions in the standard libs
11:28:06 <lispy> They really are more unsafe than is obvious
11:28:56 <mrd> ah readFile / writeFile
11:29:30 <mrd> just import qualified Data.ByteString.Char8 as S, and use S.readFile, etc.
11:30:14 <wli> I don't see what's so dangerous and/or unsafe about lazy IO.
11:30:54 <mrd> i don't think it's dangerous, just different than "usual" semantics
11:30:57 <zygen> Alrighty
11:31:03 <Saizan> in this case, i don't see how the handle is not closed on each run of the program
11:31:06 <allbery_b> that lock zygen is seeing is likely ghc protecting him from smashing the file he's reading
11:31:26 <zygen> Hm
11:31:55 <dons> check it out, nhc98 code analysis in ohloh, http://www.ohloh.net/projects/11789?p=nhc98
11:31:58 <zygen> Yeah, I figured I'd try to do something like this in haskell just to see if I could ever figure out the I/O, but yeah >_>
11:32:08 <mrd> it can be quite beneficial in some instances, especially when dealing with large files
11:32:39 <wli> I guess if you don't want to respond to out-of-band and/or error conditions in a nontrivial fashion (e.g. better than exiting with a "crash") it works out fine. It seems okay for things like one-off text mungers and so on.
11:33:06 <Saizan> zygen: do you run two instances at once? or run it while a ghci session with that open Handle is still active?
11:33:17 <lispy> mrd: it is true that lazy IO has it's useful cases.  But it also seems like we get a lot of "getContents" problem questions in here
11:33:47 <mrd> lispy: we also get a lot of "laziness" problem questions
11:33:49 <dons> good thing we have strict io too
11:33:57 <dons> pick the tool for the job
11:34:16 <mrd> the tool for the job is a pick!
11:34:39 <lispy> dons: did anyone reply to you with how they figured out bytesring was the problem, re: darcs bus error?
11:34:50 <dons> kowey said it happened on windows
11:34:59 <lispy> windows reported a bus error?
11:35:17 <phobes> This is another problem I have with laziness - you don't have enough control over it
11:35:36 <phobes> It seems like it would be really nice to be able to have lazy monadic input, but I don't see how to dit
11:35:38 <phobes> do it
11:35:40 <mrd> phobes: I control my laziness.  I could stop being lazy, really!
11:35:50 <lispy> dons: I think kowey got the bus error on his mac (I don't think x86 can give bus errors) but he ust means the patch was created on windows
11:36:05 <Saizan> phobes: lazy monadic input?
11:37:04 <lispy> dons: Not to confuse things, because I know bytestring is low level enough to cause weird errors like that, but I suspect kowey's mac is acting up.
11:37:16 <phobes> Saizan:  e.g.  A memory mapped data structure that if you try to access a part that's not ready yet can fail
11:38:46 <zygen> Saizan: No, only one instance at a time
11:38:52 <phobes> Saizan:  Basically I think you need laziness with side effects that happen when things are forced
11:39:28 <phobes> Saizan:  Another example of needing more control over laziness is that you can't catch loop
11:39:39 <phobes> The loop exception (correct me if I'm wrong)
11:40:00 <lispy> I thought loop only happens if it's definitely a loop.
11:40:09 <lispy> > let f x = f x in f 1
11:40:09 <zygen> I'm redoing it with bytestring to see if that works...
11:40:10 <phobes> lispy:  Yes
11:40:11 <lambdabot42>  Exception: <<loop>>
11:44:36 <Saizan> phobes: well that's what unsafeInterleaveIO/ST is for
11:45:15 <lispy> why is interleave unsafe?
11:45:57 <Saizan> because you lose control on when effects are performed, so the value is not guaranteed to be referentially trasparent
11:50:11 <Saizan> phobes: you can catch the loop exception with Control.Exception.catch
11:50:44 <Saizan> phobes: Prelude's catch is limited by haskell98
11:51:27 <dons> lots of haskell stuff on ohloh now :) http://www.ohloh.net/projects/search?q=haskell
11:52:47 <resiak> dons: how do you have time to sleep? :)
11:54:16 <dons> resiak: i just write a 5 line script and let it run :)
11:54:26 <resiak> heh
11:54:44 <lispy> what is ohloh?
11:54:45 <dons> note as a result we have a bunch of haskell stuff in git, The User's Guide has all you need to know about using GHC: command line options, language extensions, GHCi
11:54:48 <dons> grr.
11:54:49 <dons> http://www.cse.unsw.edu.au/~dons/git/
11:54:58 <pejo> resiak, bos said the same thing the other day! I told him the truth, "dons does not sleep. He waits"!
11:55:42 <resiak> heh
11:56:15 * lispy hopes git is not gaining popularity still
11:56:49 * cjb usese git for everything at work.
11:57:15 <zygen> For what it's worth it looks like the strict version is working
11:57:27 <zygen> Way uglier, though
11:57:27 <vincenz> git was invented by a git?
11:58:00 <dons> its roughly similar in darcs in functionality, but overly complex and with a poor user interface, but has the benefit of being ridiculously fast
11:58:18 <vincenz> And written in ... C
11:58:24 <Zao> dons: Don't forget the whole "not working on real Windows".
11:58:29 <Zao> Which some see as a pro.
11:58:32 <dons> right.
11:58:33 <SamB> dons: "roughly similar"?
11:58:34 <dons> well.
11:58:40 <dons> SamB: git clone ; git commit; git push
11:58:50 <dons> darcs get ; darcs record ; darcs push
11:58:59 <vincenz> svn ..
11:59:02 <vincenz> oh wait that won't work :P
11:59:06 <SamB> if the functionality is roughly similar, they have hidden it well!
11:59:19 <cjb> dons: there are some git tools that I think darcs may not have, such as aided bisection, being able to revert patches, being able to squash patches into each other, being able to drop patches that aren't at the tip?
11:59:27 <lispy> dons: from talking to the monotone guys, it's actual has quite a few flaws in it's history management related to merging.  But, high performance is good.  That's something dacrs can't brag.
11:59:32 <cjb> (I don't use darcs enough to know whether it actually has those things.)
11:59:42 <dons> lispy: i wouldn't be surprised. its scary low level
11:59:53 <SamB> cjb: heck, darcs hasn't got a tip
12:00:05 <dons> cjb: revert is darcs revert :) darcs amend-record is how you squish patches together.
12:00:10 <dons> and cherry picking -- darcs invented that :)
12:00:18 <cjb> cool, okay.
12:00:23 <cjb> is there a darcs bisect too?
12:00:25 <lispy> darcs can remove patches from the middle, it just has to permute the patch sequence till they're at the end :)
12:00:36 <dons> cjb: i'm not sure what bisection is?
12:00:54 <yaru1022> how do i make a int pointer to point to a specific address? for example, int *i = 0x382342;
12:00:56 <yaru1022> is it possible?
12:01:11 <yaru1022> oops ;
12:01:14 <dons> yaru1022: yeah, there's int2addr# and friends :)
12:01:14 <yaru1022> wrong channel -_-; sorry
12:01:28 <cjb> ah.  it's when you say "revision N had feature x working, and revision N+n doesn't", and the SCM does a binary search from N-n for you.
12:01:35 <yaru1022> dons, thanks anyway :) hehe
12:01:41 <dons> ah yes, darcs does that.
12:01:49 <cjb> cool.
12:01:52 <dons> gits half the age of darcs, after all -- its strongly influence by darcs
12:02:02 <dons> linus used to hang out on darcs-devel@ :)
12:02:05 <cjb> ooh.
12:02:07 <lispy> cjb: darcs trackdown
12:03:00 <cjb> does trackdown do a linear search or a binary search?
12:03:08 <cjb> seems like it does linear, which would be odd.
12:03:30 <cjb> yeah, according to http://darcs.net/manual/node7.html :
12:03:36 <cjb> FIXME: It is still rather primitive. Currently it just goes back over the history in reverse order trying each version. I'd like for it to explore different patch combinations, to try to find the minimum number of patches that you would need to unpull in order to make the test succeed.
12:03:51 <lispy> cjb: I believe the search is linear in order the patches are currently applied in.  This could be upgraded, but on one has bothered.
12:04:02 <cjb> that certainly wouldn't work for the kernel; the whole point is being able to test through ~2000 revisions with ~10 tests, since the tests will often be manual.
12:04:05 <sm__> anybody looking at darcs support for ikiwiki ? it's a rather nice rcs-based wiki
12:04:13 <dons> i thought ikiwiki already supported darcs?
12:04:23 <dons> at least, we talked about it years ago
12:04:29 <sm__> there are a couple of unfinished plugins
12:04:47 <sm__> one says it works.. nothing part of the distribution yet
12:05:07 <SamB> cjb: manual?
12:05:33 <TomMD> Why isn't there a good information flow analysis tool for Haskell code?  Is it a hard problem that needs PhD level of thought, or just no one has bothered?
12:05:51 <SamB> information flow analysis?
12:06:09 <yetAnotherOne> sounds like some kind of bbs
12:06:25 <lispy> Haskell is very static.  I bet it would be pretty easy to make static tools.
12:06:27 <yetAnotherOne> (business bullshit) (corect me)
12:06:28 <TomMD> let x = if y then z else p
12:06:35 <TomMD> lispy: My thoughts exactly
12:06:51 <TomMD> SamB: So in my above example information flows from y, z, and p to x.
12:07:15 <TomMD> yetAnotherOne: No, academic bs perhaps, but certainly not business.
12:07:22 * SamB thinks the question may not make sense
12:07:32 <yetAnotherOne> TomMD: who needs such a tool?
12:07:32 <SamB> you'll need to elaborate what the point is
12:08:57 <TomMD> SamB: The point is to determine how information propogates through a system (generally for security reasons) read Peng Li's "Encoding Information Flow In Haskell" for a runtime example.  Read "Enforcing Security and Safety Models with an Information Flow Analysis Tool" for a SPARK example.
12:10:16 <kuribas> Wouldn't it be nice to be able to specify a recursive function type?
12:10:17 <SamB> TomMD: well, barring unsafe* stuff, it generally flows from arguments to return values...
12:11:07 <TomMD> SamB: yes, I understand how I would start to make such a tool (or do it by hand) but I can't see why no one has tackled it already.  Is it just that "no one has done it yet" or "you are missing the hard part"
12:11:10 <Saizan> SamB: well you can be more accurate saying from which arguments to which part of the return values etc..
12:11:25 <SamB> Saizan: you can?
12:11:48 <Saizan> SamB: why not? by looking at the code
12:17:03 <monochrom> A naive method marks a function "propagates information" as soon as you spot it to contain a piece of code that propagates information, regardless of what condition, what path, leads to that code. This is bound to give many false positives.
12:17:56 <zygen> Erm, I'm definitely a noob, but doesn't the compiler already have to do something like this?
12:18:00 <SamB> so what TomMD wants is an information-non-flow analyzer?
12:18:03 <zygen> Like, just in checking types and stuff?
12:18:30 <zygen> I don't really know what you mean by information flow, though.  What would it accomplish?
12:19:01 <monochrom> In fact, I wager, so many positives that most safe programs are declared unsafe, since most safe programs do this: check some conditions, then conditionally propagates information.  The "conditionally" part makes them safe.
12:20:25 <monochrom> So now you're looking at "under what condition does it propagate information, and to whom, and is it allowed". This is theoretically the halting problem, and in practice not too far from it --- you need everything invented by the static analysis people.
12:21:27 <monochrom> Unfortunately, the security people haven't talked too much with the static analysis people.  There are tons of reinventing wheels going on there.
12:22:23 <acura> @src unsafePerformIO
12:22:24 <lambdabot42> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
12:22:39 <lispy> ?src lazy
12:22:40 <lambdabot42> Source not found. Are you on drugs?
12:22:49 <lispy> ?vixen I am not on drugs.
12:22:50 <lambdabot42> i think drug users should be shot
12:23:18 <mnislaih> :r
12:24:40 * paolino thinks shooter bots should be doped
12:25:23 <chrizel> How can I say something like "data Scene = Scene [Primitive]" where Primitive is a type class? A scene should hold a list of different primitives.
12:26:08 <kpreid> chrizel: you need an existential wrapper type
12:26:10 <kpreid> like this:
12:26:14 <Saizan> chrizel: primitives of different types or not?
12:26:22 <pjd> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
12:26:29 <kpreid> data AnyPrimitive = forall a. Primitive a => AnyPrimitive a
12:26:35 <kpreid> data Scene = Scene [AnyPrimitive]
12:26:40 <chrizel> Saizan, yes, different types
12:26:50 <Saizan> what kpreid said then
12:26:56 <lispy> data Scene where Scene :: PrimitiveClass a => [a] -> Scene, maybe this works? (using GADT syntax)
12:26:56 <chrizel> kpreid, thank you, i'll look at it :)
12:27:01 <mudge> hi,  does anyone recommend any webpages or books about datastructures?
12:27:28 <Saizan> lispy: that should be a list of bottoms
12:27:37 <monochrom> mudge: try this one: http://lambda-the-ultimate.org/node/2665
12:27:38 <mnislaih> kpreid or even better: data AnyPrimitive where AnyPrimitive :: Primitive a => a -> AnyPrimitive
12:27:54 * kpreid does not grok GADTs
12:27:55 <yetAnotherOne> mudge: TAOCP#1
12:27:55 <pjd> silly question:  does there exist some kind of canonical mapping or enumeration of algebraic data types?
12:27:58 <lispy> Saizan: why is that?
12:28:34 <monochrom> pjd: If you "deriving Enum" you get an enumeration.
12:28:48 <chrizel> pjd, thanks for the link
12:29:03 <pjd> monochrom: sorry, i mean of the types themselves
12:29:22 <Saizan> lispy: an no, it's not a list of bottoms but the elements must have the same type
12:29:48 <Tibixe> hello
12:29:55 * monochrom mumbles Gödel numbering and hides
12:29:56 <lispy> > [1,2,3] :: Num a => [a]
12:29:58 <lambdabot42>  [1,2,3]
12:30:07 <lispy> Saizan: I was trying to do something like that
12:30:31 <lispy> > [1,2,3 :+ 2] :: Num a => [a]
12:30:32 <lambdabot42>   3 :+ 2
12:30:32 <lambdabot42>     In the expression: [1, 2, 3 :+ 2] :: (Num a) => [a]
12:30:32 <lambdabot42>     In the d...
12:30:39 <lispy> :t (:+)
12:30:41 <lambdabot42> forall a. (RealFloat a) => a -> a -> Complex a
12:30:41 <Saizan> see?
12:31:01 <Saizan> the 'a' must be the same in the list
12:31:10 <lispy> Saizan: ah, so it's not forall Num a., it's forall a. Num a => ...
12:32:29 <Saizan> lispy: yes the a is fixed early
12:33:27 <Tibixe> Could you help me with IO monads? I'm trying to use RandomIO, but no luck... I've got this code:
12:33:46 <Tibixe> randAlphabet alph = do randomxs <- getNRandInts (length alph) return ( makeAlphabet (zip alph (randOrder alph randomxs )) )
12:34:01 <Tibixe> ( with a newline before return )
12:34:13 <lispy> Tibixe: we can help, but also someone recently enhanced the preformance of RandomIO, so you might want to use the new library (I don't know the name)
12:34:28 <pjd> monochrom: you have () and all the other unit types, right?
12:34:33 <Saizan> ?type getNRandInts
12:34:35 <lambdabot42> Not in scope: `getNRandInts'
12:34:35 <SamB> how does it preform now?
12:34:39 <Tibixe> lispy: Well, I don't need performance right now
12:34:54 <pjd> and then e.g. data Identity a = Identity a
12:34:56 <lispy> SamB: I can't quote the numbers, but it's very much faster, at least order of magnitude, iirc
12:35:30 <Tibixe> It doesn't compile because
12:35:38 <lispy> ?where paste
12:35:38 <lambdabot42> http://hpaste.org/new
12:35:39 <Tibixe>     Couldn't match expected type `[a]' against inferred type `IO t'
12:35:39 <Tibixe>     In the second argument of `randOrder', namely `randomxs'
12:35:43 <Tibixe> so
12:35:47 <lispy> Tibixe: ^^ paste it if it's hard to describe :)
12:36:04 <pjd> and then Just a | Nothing, and all isomorphic types
12:36:06 <lispy> looks like randomxs is an IO action
12:36:21 <monochrom> Eh? Mersenne twister binding?
12:36:24 <Tibixe> But didn't I bind it to a variable?
12:36:38 <lispy> Tibixe: yes you did, maybe we need to see more of the code?
12:36:50 <desegnis> Tibixe: we need you hpasting the types of the functions involved
12:36:55 <pjd> in type algebra, those correspond roughly to 1, a, then a + 1, and so on, right?
12:36:56 <Tibixe> ok
12:37:06 <lispy> Tibixe: what is the type of getNRandInts
12:37:39 <lispy> Tibixe: also, there is a way to get an inifinite random sequence, you could then use 'take' to get the number you want
12:37:42 <Tibixe> it should IO Int
12:37:53 <lispy> you mean IO [Int], right?
12:38:06 <Tibixe> yes
12:38:18 <pjd> then lists are something like b = ab + 1
12:38:21 <desegnis> Tibixe, it _should_ or it _is_?
12:38:27 <lispy> ?hoogle random
12:38:28 <lambdabot42> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
12:38:28 <lambdabot42> System.Random :: module
12:38:28 <lambdabot42> System.Random.Random :: class Random a
12:38:38 <lispy> ?hoogle randomS
12:38:39 <lambdabot42> System.Random.randoms :: (Random a, RandomGen g) => g -> [a]
12:38:43 <Tibixe> I'll find out in a moment
12:39:15 <lispy> Tibixe: so I think you can use randoms to get a sequence of Ints, and then say, take n (randoms ...)
12:39:17 <desegnis> Tibixe, just insert a type annotation with the type you want it to be into your code
12:39:19 <lispy> to get n of them
12:39:32 <Saizan> pjd: exactly, and 0 is Void
12:39:40 <pjd> right
12:39:53 <Tibixe> getNRandInts :: (Num a) => a -> [IO Integer]
12:40:15 <lispy> Tibixe: ah, do you see the problem?
12:40:39 <Tibixe> It should be IO [Integer], right?
12:40:43 <pjd> so what i'm wondering is whether there is some elegant way to generate the possible types
12:40:44 <lispy> Tibixe: how is getNRandInts defined?  (if it's more than 3 lines please use http://hpaste.org)
12:40:46 <desegnis> Tibixe, what are the semantics of (getNRandInts pi) then? :-) And yeah, it should be IO [Integer]
12:40:50 <Tibixe> getNRandInts n = getR : getNRandInts (n-1)
12:41:12 <siti> I had an idea for lambda bot/hackage.  It would be cool if lambda bot could print a message here if a new package is uploaded :)
12:41:13 <Tibixe> getR = getStdRandom (randomR (1,32767))
12:41:14 <pjd> from the simplest ones upwards
12:41:31 <desegnis> Tibixe, that's equivalent to sequence (repeat getR), I think
12:42:00 <pjd> a sort of taxonomy of types
12:42:06 <Tibixe> take n ( repeat getR ) ?
12:42:08 <lispy> Tibixe: you do correctly build a list.  But, you need to run getNRandInts, and build a list of the restults
12:42:12 <desegnis> Tibixe, and of course you're generating an infinite list, just in case you didn't realize
12:42:36 <Tibixe> lol
12:42:48 <desegnis> repeat getR is the list [getR, getR, getR, ...]
12:42:57 <desegnis> where getR is an IO action
12:43:00 <Tibixe> Ok, I know, I just always make stupid mistakes :)
12:43:26 <TomMD> @bot
12:43:26 <lambdabot42> :)
12:43:27 <lispy> Tibixe: so what is the type of getR?
12:43:30 <Saizan> pjd: the hard part would be the recursive ones, maybe you can tame them allowing only a fixed point operator
12:43:43 <TomMD> @seen andyjgill
12:43:43 <lambdabot42> I haven't seen andyjgill.
12:45:00 <Tibixe> getNRandInts n = getR : getNRandInts (n-1)
12:45:06 <Tibixe> sorry
12:45:08 <Saizan> desegnis: sequence (repeat getR) is bottom
12:45:14 <Tibixe> getR :: IO Integer
12:46:01 <Saizan> Tibixe: yeah, and you need to produce a IO [Integer] and not an [IO Integer], so you've to "extract" the Integer from getR each time
12:46:14 <desegnis> Saizan, as is any infinite loop
12:46:24 <Tibixe> Ok, I think I get it
12:46:33 <lispy> Tibixe: so, that means getR returns an IO action, the IO action results  in an Integer.  So, you need to 'run' getR inside of getNRandInts if you want to build a list of the results.
12:47:11 <Saizan> desegnis: sorry, i assumed a base case
12:47:44 <pjd> Saizan: the reason i'm wondering is that ADTs each unique "kind" of type usually corresponds to a whole bunch of useful, implied functionality and behavior
12:47:52 <pjd> s/ADTs //
12:48:03 <desegnis> Saizan, I preferred not to assume too much ;)
12:48:07 <lispy> :t  getStdRandom (randomRs (1,32767))
12:48:09 <lambdabot42>     Couldn't match expected type `(a, StdGen)'
12:48:09 <lambdabot42>            against inferred type `[t]'
12:48:09 <lambdabot42>       Expected type: StdGen -> (a, StdGen)
12:48:45 <desegnis> :t getStdRandom >>= randomRs  (1,32767)
12:48:47 <lambdabot42>     Couldn't match expected type `(StdGen -> (a, StdGen)) -> b'
12:48:47 <lambdabot42>            against inferred type `[t]'
12:48:47 <lambdabot42>     Probable cause: `randomRs' is applied to too many arguments
12:48:56 <desegnis> bah
12:49:09 <lispy> ?type (randomRs, randomR)
12:49:11 <lambdabot42> forall a g a1 g1. (RandomGen g1, Random a1, RandomGen g, Random a) => ((a, a) -> g -> [a], (a1, a1) -> g1 -> (a1, g1))
12:49:26 <desegnis> :t getStdGen >>= randomRs  (1,32767)
12:49:27 <lambdabot42>     Couldn't match expected type `IO b' against inferred type `[t]'
12:49:28 <lambdabot42>       Expected type: StdGen -> IO b
12:49:28 <lambdabot42>       Inferred type: StdGen -> [t]
12:49:29 <TomMD> {-# LANGUAGE excessArguments > /dev/null #-}
12:49:36 <desegnis> :t getStdGen >>= return . randomRs  (1,32767)
12:49:38 <lambdabot42> forall t. (Random t, Num t) => IO [t]
12:50:00 <desegnis> I'm clearly out of practice with Haskell :(
12:50:59 <lispy> ?pl getStdGen >>= return . randomRs  (1,32767)
12:50:59 <lambdabot42> randomRs (1, 32767) `fmap` getStdGen
12:51:09 <monochrom> pjd may be ripe for the bananas lenses, barbed wire paper.
12:51:30 <Saizan> pjd: so you plan on discovering something cool hidden there?:)
12:51:55 <pjd> Saizan: i'm sure everything cool has already been discovered :)
12:52:05 <oklopol> > cycle (0 .)
12:52:06 <lambdabot42>  Couldn't match expected type `[a]'
12:52:14 <oklopol> > cycle (.) 0
12:52:15 <lambdabot42>  Couldn't match expected type `[a]'
12:52:24 <Saizan> monochrom: do you know why that paper uses || for product?
12:52:31 <oklopol> > (:) 1 [2, 3]
12:52:32 <lambdabot42>  [1,2,3]
12:52:35 <pjd> but it would be cool to formally map out and organize the space of possible types, in some useful manner
12:52:37 <oklopol> > (:) 1 2
12:52:38 <lambdabot42>   add an instance declaration for (Num [t])
12:52:38 <lispy> why does lambdabot keep dying?  Anyone know?
12:52:42 <monochrom> I don't.
12:53:29 <pjd> so you can see their relationships more readily
12:53:51 <roconnor> @faq which language causes lambdabot to keep dying?
12:53:52 <lambdabot42> The answer is: Yes! Haskell can do that.
12:54:04 <monochrom> @slap roconnor
12:54:05 * lambdabot42 locks up roconnor in a Monad
12:54:15 <lispy> pjd: in practical matters, isometrics types can be useful simply for being different types.  so, maybe you still miss out on a lot by doing tihs exercise.
12:54:16 <roconnor> help, someone run my monad!
12:54:16 <monochrom> Haha! Great punishment!
12:54:28 <pjd> or see where all the well-known types are, and where the obscure/little-explored ones are
12:54:46 <lispy> > unsafePerform#haskell roconnor
12:54:48 <lambdabot42>   Not in scope: `roconnor'
12:54:55 <roconnor> free!
12:55:02 <wli> I wonder if I can just alternate between coordinates without all the rest of the fancy optimization stuff and get away with it.
12:55:05 <pjd> lispy: ?
12:55:07 <Tibixe> I'm somewhat closer to the solution, but now I don't know why this doesn't compile:
12:55:13 <Tibixe> getNRandInts n = do x  <- getR
12:55:13 <Tibixe> 		    xs <- getNRandInts (n-1)
12:55:14 <Tibixe>                     x : xs
12:55:31 <Tibixe> it says:
12:55:32 <Tibixe>     Couldn't match expected type `[t]' against inferred type `IO t1'
12:55:33 <Tibixe>     In a 'do' expression: x <- get
12:55:41 <lispy> Tibixe: for one, tabs in Haskell are a bad idea
12:55:52 <lispy> Tibixe: and it looks like your editor used them on the second line
12:56:22 <lispy> Tibixe: you have no return at the end
12:56:24 <wli> What on earth is this stuff about tabs "being bad?"
12:56:30 <roconnor> can we just make tabs an error in ghc?
12:56:33 <roconnor> with some flag?
12:56:34 <Saizan> Tibixe: since you're using IO every expression the do block has to be a type of the form IO Something, but (x:xs) :: [Integer]
12:57:00 <Saizan> "in"
12:57:01 <dons> http://reddit.com/info/68zmt/comments/ :) Python guy: "I ported CleverCSS to Haskell ... the Python had 1072 lines, the equivalent Haskell is 760"
12:57:02 <pjd> roconnor: borrow Python's -t and -tt !
12:57:34 <lispy> dons: yeah, all those dynamic type annonations bloat the code
12:57:43 <pjd> (which make mixed indentation a warning and error, respectively)
12:57:43 <dons> heh
12:57:49 <monochrom> pjd: http://wwwhome.cs.utwente.nl/~fokkinga/#detail_0000003415
12:57:53 <dons> lispy: and loops too, i suspect
12:58:02 <Saizan> what's CleverCSS? 760 lines is a window manager and an half
12:58:10 <roconnor> dons: wow, and it sounds like beginner haskell to boot
12:58:10 <Tibixe> Saizan: Are you saying that it should end with 'return x:xs'?
12:58:13 * wli writes off the anti-tab stuff as insanity.
12:58:27 <Saizan> Tibixe: return (x:xs) because of precedence rules
12:58:31 <roconnor> dons: probably with our help we can cut that in half.
12:58:43 <lispy> A friend of mine made a clever argument that Haskell has dynamic typing.  Because at compile time it 'dynamically' computes the type so when you change the code you don't have to 'manually' go in and change them.
12:59:02 <dons> hehe
12:59:04 <Tibixe> Saizan: Ok, but it still gives that error message for the x <- getR assignment
12:59:13 <Japsu> that's abuse of the word "dynamic"
12:59:17 <dons> "dynamic languages" are rot brains
12:59:34 <dons> roconnor: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/clevercss
13:00:01 <roconnor> dons: although he sounds pretty clever for what seems to be a haskell newcomer
13:00:12 <Saizan> ?type getStdRandom (randomR (1,32767))
13:00:14 <lambdabot42> forall t. (Random t, Num t) => IO t
13:00:33 <jatqceer> Probably it's way OT.  But, what kind of music do you listen to when you play with your favourite Haskell?
13:00:47 <dons> at work, or home?
13:01:02 <dons> s/play/work/ :)
13:01:03 <lispy> the more on topic question, and do you use hmp3 to play it?
13:01:09 <stoo> Wagner
13:01:16 <dons> hehe
13:01:24 <Saizan> Tibixe: weird, try putting an explicit type signature on getNRandInts
13:01:40 * desegnis relies on the shuffle functionality of his player
13:01:41 <jatqceer> either at work or home
13:01:43 <Saizan> Tibixe: maybe the error is elsewhere but the typechecker is reporting it here
13:02:12 <lispy> what is a quantified type variable?
13:02:27 * TomMD listens to Death Cab for Cutie
13:02:34 <Cale> lispy: One which is bound by forall or exists.
13:03:03 <Cale> lispy: Ordinarily, all type variables in type signatures in Haskell are implicitly bound by forall.
13:03:12 <Cale> (at the top level of the signature)
13:03:14 <roconnor> dons: looks very well written
13:03:32 <dons> ?pl \x -> x `mod` p > 0
13:03:32 <lambdabot42> (> 0) . (`mod` p)
13:03:45 <Cale> lispy: There is an extension to GHC which allows you to explicitly forall-bind the variables at other points.
13:03:48 <lispy> Cale: Okay, I think that makes sense.  My data contstructor hides a quantified type
13:04:08 <dons> hmm, the default sieve on this page looks a bit ugly, http://haskell.org/haskellwiki/Prime_numbers
13:04:15 <Tibixe> I guess I'll leave getNRandInts as it was ( [IO Integer] ), and use another function to extract the values from it
13:04:17 <lispy> Cale: and I pattern matched, thus bringing that type out into the open.
13:04:18 <dons> didn't we have a cleaner list comp version?
13:04:37 <dons> (its cited in the arc/lazy lists article, here, http://cadrlife.blogspot.com/2008/02/lazy-lists-in-arc.html
13:05:25 <lispy> Cale: so, now my real question.  Why does GHC say that the inferred type is *less polymorphic than expected*.  I don't understand how letting an existential type escape is related to polymorphism and I don't understand what polymorphism was expected.
13:05:26 <Cale> lispy: You can pattern match in a case or function definition, but you can't use a pattern binding for that, since the resulting type of that variable would be something of the form  exists x. <something>
13:05:39 <Saizan> Tibixe: what you want is replicateM n getR, btw
13:05:47 <Cale> lispy: Can you show me the code?
13:05:50 <lispy> Cale: I'm pattern matching in the do-notation
13:05:56 <lispy> Cale: sure
13:06:31 <Cale> lispy: Usually that happens when your explicit type signature for the function is more polymorphic than the code.
13:06:59 <hpaste>  lispy pasted "Less Polymorphic than expected" at http://hpaste.org/5708
13:07:20 <lispy> Cale: what does more or less polymorphic mean?  Isn't it a binary predicate?
13:07:30 <Cale> lispy: Not quite :)
13:07:51 <monochrom> "x is less polymorphic than y" is a binary predicate.
13:08:04 <Cale> er, well, yes :)
13:08:07 <lispy> Cale: I know how to fix this problem, more or less.  It's the theory behind the error message that I want to understand.
13:08:16 * monochrom harps on "partial order" hehehe
13:08:24 <lispy> Well, I think of isPolymorphic as being binary
13:08:42 <lispy> but, that's probably my C++ background speaking
13:08:48 <Cale> I suppose I misread that. "X is polymorphic" doesn't tell the whole story.
13:09:01 <monochrom> "isn't he a cute guy?" is not binary :)
13:09:13 <Tibixe> Saizan: Oh, thanks you
13:09:22 <Tibixe> It works
13:09:34 <lispy>     Inferred type is less polymorphic than expected
13:09:34 <lispy>       Quantified type variable `x' escapes
13:09:56 <lispy> I suspect I get, intuitively, why it's bad to let 'x' escape
13:09:59 <monochrom> f :: a->a; f x = x+x.  a->a is more polymorphic than the actual code.
13:10:08 <Cale> lispy: Which line of that code?
13:10:08 <lispy> But, in what way is that related to polymorphism?
13:10:12 <Cale> lispy: I can't compile this.
13:10:21 <lispy> Cale: I marked the lines
13:10:25 <Cale> oh
13:10:29 <Cale> yes, I see that
13:10:34 <stoo> Don't suppose anyone here uses yhc? ;o
13:10:52 <Tibixe> Saizan: Thank you, it now compiles, too!
13:10:58 <lispy> Cale: Sealed, seales up a type as an existential
13:11:03 <sw17ch> I'm working through the Clock.hs cairo example and have hit some syntax that doesn't make sense to me... can some one explain what's happening here?
13:11:04 <sw17ch> onKeyPress window $ \Key { eventKeyName = key } ->
13:11:04 <sw17ch> 	when (key == "Escape") mainQuit >> return True
13:11:14 <Cale> stoo: If nobody right now, there are certainly people who visit here that are involved in its development.
13:11:30 <sw17ch> the part between the curly brackets is what i'm missing
13:11:31 <lispy> Cale: so when you use the constructor of Sealed, it brings that type back out into the open (I wish I had better vocab for this)
13:11:36 <Cale> lispy: Oh, yeah, you can't do that.
13:11:41 <oerjan> sw17ch: record pattern matching syntax
13:11:45 <stoo> Aye Cale, I'm at York :]
13:11:53 <Cale> What's the type of patchInfoAndPatch?
13:12:00 <sw17ch> oerjan, thanks, i'll look it up
13:12:01 <stoo> Actually, this doesn't need a YHC user to answer heh
13:12:02 <TomMD> stoo: I was messing with it just now, but as usual, it failed to compile today.
13:12:05 <lispy> Cale: right, and my solution will involve hiding 'x' back in a seal.  But, I'm trying to understand what the error message is on about :)
13:12:15 <Cale> lispy: What's the type of patchInfoAndPatch?
13:12:17 <oerjan> key is bound to the eventKeyName field of the argument to the lambda
13:12:41 <lispy> Cale: it takes an info and a patch and creates a PatchInfoAnd, which is a container for both of them
13:12:42 <Cale> lispy: actually, I'd be interested in the type of Sealed as well.
13:12:53 <Cale> lispy: Could you give the actual type signature?
13:12:58 <lispy> Cale: okay, this is darcs source BTW
13:13:16 <stoo> Err, apologies for the sub-novice question, foo :: [Char] -> Int -> [Char]   main = print (foo (foo "Message" 13))
13:13:24 <Cale> Yeah, I have no familiarity with it, but I'll download the source :)
13:13:24 <lispy> patchInfoAndPatch :: PatchInfo -> Hopefully (Named p) C(a b) -> PatchInfoAnd p C(a b)
13:13:25 <stoo> That shouldn't compile, right? ;p
13:13:39 <lispy> Cale: I have to explain the notation C(x)
13:13:42 <Cale> stoo: Beginners are more than welcome here :)
13:13:48 <lispy> Cale: it's a CPP macro that expands to x
13:14:00 <lispy> Cale: we use it when we toggle the type witnesses
13:14:09 <TomMD> stoo: Looks to me like it need another Int.
13:14:19 <lispy> data Sealed a where Sealed :: !(a C(x )) -> Sealed a
13:14:20 <Cale> stoo: It looks like you're trying to print a function there.
13:14:21 <litb> stoo: that does not compile i think
13:14:29 <stoo> Yeah TomMD, I only did that by accident but YHC prints it heh
13:14:30 <litb> main has IO t , but yours has Int -> IO t
13:14:35 <stoo> err, compiles it*
13:14:42 <Cale> stoo: foo (foo "Message" 13) :: Int -> [Char]
13:14:45 <stoo> But I have an old version of YHC I guess
13:14:57 <Cale> stoo: Oh, what does it print?
13:15:02 <TomMD> stoo: Well, good luck compiling a new version.
13:15:08 <lispy> Cale: but how is it that letting a quantified type variable escape changes the polymorphic nature of something (and why does it make it less polymorphic)
13:15:11 <stoo> It was just a little caesar cipher I used for benchmarking
13:15:12 <Cale> stoo: It might be an extension which allows for printing functions.
13:15:17 <stoo> Cale, <<function>> :D
13:15:19 <Cale> stoo: yeah.
13:15:36 <Cale> stoo: So, that's all right. It's just that YHC must come with an instance of Show for functions.
13:15:42 <TomMD> I guess yhc sticks with scons because the Windows support is better?  I just have never had luck with it.
13:15:43 <oerjan> stoo: it is not illegal provided there is a Show instance for the Int -> [Char] type. normally there isn't but e.g. lambdabot has one
13:15:58 <stoo> Got a 30% speedup with the Caesar cipher :x
13:16:04 <TomMD> :-)
13:16:06 <stoo> Writing a JIT compiler for yhc, it's loads of fun
13:16:25 <lispy> stoo: congrats
13:16:33 <litb> print would say "no instance of show for "Int -> [Char]" i think
13:17:08 <desegnis> lispy: I guess that (exists a. C a => a) is less polymorphic than (forall a. C a => a)
13:17:09 <stoo> ta lispy :>
13:17:54 <lispy> desegnis: and matching the pattern is equivalent to the (exists a. C a => a) case?
13:18:00 <lispy> desegnis: because the 'a' was fixed already?
13:18:17 <lispy> that makes a lot more sense actually
13:18:18 <lispy> Thanks
13:18:33 <litb> what does "exists a." mean?
13:18:36 <Cale> lispy: Sorry about that.
13:18:48 <TomMD> @where existentials
13:18:48 <lambdabot42> I know nothing about existentials.
13:18:57 <oerjan> @version
13:18:58 <lambdabot42> lambdabot 4p584, GHC 6.8.2 (FreeBSD i386)
13:18:58 <lambdabot42> darcs get http://code.haskell.org/lambdabot
13:19:03 <lispy> So, then putting "forall a." in a data desclaration behaves as "exists a." when you actually have a value?
13:19:05 <desegnis> lispy, yeah, and only the forall type is truly polymorphic
13:19:14 <Cale> lispy: Yeah, the notation is a bit screwy.
13:19:46 <lispy> This really helps.  That makes some things I've struggled with before more clear.
13:19:51 <oerjan> lispy: there is a sort of DeMorgan duality.  data X = forall a. X a == data X = X (exists a. a)
13:19:51 <Cale> lispy: (but it makes sense -- the foralls are carefully placed to avoid making exists a keyword)
13:20:42 <oerjan> @users
13:20:42 <lambdabot42> Maximum users seen in #haskell: 459, currently: 459 (100.0%), active: 19 (4.1%)
13:20:54 <lispy> oerjan: yeah, that does make sense.
13:21:04 <litb> uhh
13:22:05 <lispy> Cale: I encourage you to look at the darcs source. You might find all kinds of things that interest you in there.
13:22:25 <desegnis> litb: When we write exists, we say that the expression has some such type, but may not be polymorphic over all such types
13:22:58 <ddarius> forall a. a -> B ~ (exists a. a) -> B
13:23:07 <ddarius> (assuming a is not free in B of course)
13:23:29 <lispy> nothing is free (except theorems)
13:23:40 <litb> what does it mean "a is not free in B" ?
13:24:18 <Cale> lispy: There's a particular paper which might interest you, let me find it.
13:24:23 <litb> i'm not sure i understand it :) "exists a . a" is the same as "a" ?
13:24:29 <desegnis> B being a whole type expression, it may not contain a as a free variable
13:24:32 <oerjan> litb: does not appear, except under a further nested binding
13:24:34 <lispy> Cale: thanks
13:25:03 <oerjan> lispy: no.  exists and forall introduce new scopes for type variables
13:25:34 * lispy assums oerjan meant litb 
13:25:42 <oerjan> exists a. a == exists b. b by alpha conversion, so a does not "really" appear in it == is not free in it
13:25:49 <oerjan> lispy: argh
13:25:54 <oerjan> litb: ^^
13:25:56 <Cale> lispy: http://research.microsoft.com/~simonpj/papers/higher-rank/index.htm
13:26:24 <litb> i see
13:26:35 <ddarius> Incidentally, existentials and universals are duals so I wouldn't say one is "more polymorphic" than the other
13:26:44 <lispy> Cale: yes! I think I do need this articel.  I've been wanting something about higher kinds and such
13:27:02 <litb> is it important to understand this "exists" ?
13:27:12 <oerjan> ddarius: er existentials are the dual to polymorphic ;)
13:27:16 <desegnis> litb, only if you don't understand "forall" ;)
13:27:32 <lispy> Cale: I have the ghc manual, but it's skippy on theory
13:27:40 <litb> i understand forall i think. it is just optional to add it
13:28:06 <Cale> One somewhat unintuitive fact is that s1 -> Integer is more polymorphic than s2 -> Integer if s1 is less polymorphic than s2
13:28:32 <ddarius> That's actually rather intuitive.
13:28:40 <oerjan> um...
13:28:43 <desegnis> litb, the context of this discussion is the use of existential types, which is a language extension allowing foralls in data declarations
13:28:46 <SamB> co-intuitive
13:28:49 <SamB> I say
13:28:51 <lispy> litb: do you understand foralls in terms of logic?
13:29:05 <Cale> It makes sense once you think about it, but it's something which people got wrong for quite a while.
13:29:21 <desegnis> litb: or more exactly, which allows constructors with foralls
13:29:26 <lispy> Cale: do you have a more concrete example?
13:29:28 <ddarius> Cale: A single example and about a sentence of explanation makes it perfectly clear.
13:29:45 <dnoxx> does any of the haskell videos aim to total beginners?
13:30:13 <litb> lispy: yes. it's -V- in math and exists is E in math
13:30:15 <ddarius> dnoxx: The only Haskell videos intended to be introduction to Haskell at all are the Taste of Haskell videos.
13:30:22 <litb> (E in the other direction )
13:30:41 <Cale> lispy: To steal an example from the paper, (forall a. a -> a) is more polymorphic than (forall b. [b] -> [b]), and so (forall a. a -> a) -> Integer is less polymorphic than (forall b. [b] -> [b]) -> Integer
13:30:44 <lispy> litb: okay, haskell forall and exists are the same ideas if you view Types as sets of values
13:30:46 <ddarius> litb: Do you understand those though?  Because they are essentially exactly the same.
13:30:53 <yaru1022> has anyone installed Yi?
13:30:54 <dnoxx> ok
13:30:57 <SamB> the forall is an upside-down A, actually
13:31:06 <litb> ddarius: yes, i understand those and know how to used them in predicates
13:31:20 <ddarius> litb: Then you should pretty much understand Haskell's.
13:31:21 <yaru1022> I get "Yi/Keymap/Users/JP.hs:1:0:
13:31:22 <yaru1022>     file name does not match module name `Main'
13:31:22 <yaru1022> haddock: Failed to load all needed modules" error... I'm wondering if anyone knows..
13:31:26 <litb> i'm not a guru with them tho, but i know how to basicially use them and transform them into each other
13:31:26 <Cin> samb: is it just called forall? i'm looking for it in xkeycaps
13:31:57 <ddarius> Cale: And there are more functions [b] -> [b] than there are a -> a
13:31:57 <Cale> yaru1022: perhaps add   "module JP where"  to the top of that module.
13:32:02 <lispy> Cale: I'll read the paper and ask more questions about that example.  I don't see it yet.  Why it's less polymorphic to be (a -> a) -> Int
13:32:24 <SamB> Cin: I have no idea
13:32:28 <Cin> D:
13:32:33 <Cale> lispy: The only function which you can pass to a function of type (forall a. a -> a) -> Int is the identity function, basically
13:32:38 <litb> is it like if you use "exists" you can use that function only with one type ?
13:32:46 <lispy> Cale: gotcha
13:33:04 <Cale> lispy: Whereas, with a function of type (forall b. [b] -> [b]) -> Int, you could for instance, pass reverse
13:33:09 <ddarius> lispy: Modulo bottom: f :: (forall a. a -> a) -> Int can only take the identity, g :: (forall b.[b] -> [b]) -> Int can take id, reverse, or any such function.
13:33:11 <Cale> (as well as the identity function)
13:33:11 <SamB> ∃ and ∀
13:33:25 <Cin> samb: i'll google that character and see what i get
13:33:26 <yaru1022> Cale, if I do that, I get parse error on 3rd line... "Yi/Keymap/Users/JP.hs:3:0: parse error in doc string"
13:33:26 <SamB> those are \exists and \forall in LaTeX
13:33:41 <Cin> universal quantifier
13:33:51 <Cale> yaru1022: ... hmm.
13:34:03 <litb> so, if you have "foo:: exists a . Ord a => [a] -> [a]" , you can call it with foo [1, 4, 3, 6, 5] , but then after that cannot call it with foo "hello" ?
13:34:03 <Cale> yaru1022: could you put the file somewhere that I could see it?
13:34:06 <Cale> !paste
13:34:06 <hpaste> Haskell paste bin: http://hpaste.org/
13:34:11 <litb> or do i misunderstand it?
13:34:13 <ddarius> litb: When you are using exists, you saying exactly what it sounds like.  exists a. F a "there exists a type 'a' such that F a is inhabited"
13:34:14 <yaru1022> Cale, sure hold on a sec
13:34:32 <litb> because exists does not mean "exactly one" so i'm unsure about this
13:35:04 <SamB> unicode calls them U+2203 THERE EXISTS and U+2200 FOR ALL
13:35:08 <Cale> litb: No, you actually can't call it with anything, since there's no way to prove that the list you pass it is of an acceptable type.
13:35:18 <hpaste>  yaru1022 pasted "installing Yi" at http://hpaste.org/5709
13:35:34 <litb> Cale: hm, but there are type classes
13:35:35 <Cale> litb: It simply says that there is some type for which it would work, but you have no information about what that type is anymore.
13:36:16 <lispy> You had a proof at one point that it was valid
13:36:40 <litb> i'm confused :) i think it's too early for me to step into this by now
13:36:55 <litb> i will have to dig into Monads and Richard Bird more
13:37:07 <ddarius> This has nothing to do with monads.
13:37:28 <litb> as i see it, it could fail with some type , but it must not fail for all types
13:37:29 <desegnis> litb: Saying that a is in the Ord class does still not tell you whether some value bar :: Bar is acceptable as an argument to your function, even if there is an instance Ord Bar
13:37:30 <Cin> samb: found it
13:37:34 <litb> what sense does that make?
13:37:43 <Cin> Second solution: rebind <AltGr>a to forall and <AltGr>e to exists. Under X11, you need to use something like    xmodmap -e "keycode  24 = a A F13 F13"      xmodmap -e "keycode  26 = e E F14 F14
13:38:03 <SamB> what does AltGr mean?
13:38:07 <Cin> right alt
13:38:10 <SamB> oh.
13:38:21 <SamB> what does the G have to do with right?
13:38:23 <Cin> ie my λ is AltGr+\
13:38:30 <Cale> litb: Types essentially represent what permissions you have to work with data.
13:38:36 <Cin> greater? i don't know
13:38:55 <allbery_b> the right alt key is called AltGr on international keybords.  (meaning "alternate graphemes" aka international chars)
13:39:08 <Cale> litb: Suppose I have a value of type  exists a. (Show a) => a
13:39:49 <Cale> litb: Then I'll be able to apply show to it, since I know that, for sure, no matter what type of thing I have, it must be an instance of Show
13:40:22 <Cale> But that is nearly the only thing I can do with the value.
13:40:52 <litb> i see
13:41:07 <SamB> are there actual implementations of this type of "exists"?
13:41:10 <ddarius> One way to think about it is with "forall" you choose the type, with "exists" they (the writer of the function) choose the type
13:41:17 <Cale> A value of type  exists a. a  is completely useless, since you have no information at all about what type of thing it is, and hence are not allowed to do anything at all with it.
13:41:21 <litb> if i say "forall a. (Show a) => a" what would be different then?
13:41:26 <ddarius> SamB: GHC and Hugs have local existentials, HBC has free ones.
13:41:30 * SamB wonders why his menu key has autorepeat enabled
13:41:51 <SamB> ddarius: so I guess that means "yes, HBC"?
13:42:00 <ddarius> SamB: Yes, HBC
13:42:27 <ddarius> SamB: Also, existentials can be encoded with rank-2 universals.
13:42:35 <Cale> litb: Well, that value could be used at any type which was an instance of Show
13:42:40 <SamB> Cin: my alt keys both have a KeyCode of Alt...
13:42:50 <Cale> litb: That is, it would specialise to Integer, or to String, or to [Integer], etc.
13:42:58 <ddarius> exists a. f a ~ forall a.(f a -> r) -> r
13:43:07 <Cale> litb: Unfortunately, that's so general, that there will not be many values of that type.
13:43:10 <ddarius> exists a. f a ~ (forall a.f a -> r) -> r
13:43:18 <Cale> However, consider something like (Num a) => a
13:43:21 <Cale> er.
13:43:24 <Cale> However, consider something like forall a. (Num a) => a
13:43:25 <oerjan> litb: note that for some other type classes such functions actually exist. e.g. 1 :: forall a. (Num a) => a
13:43:32 <Cale> (let's be explicit)
13:43:39 <Cin> samb: mine are Alt and Alt Gr. hrm
13:43:44 <Cale> :t 1
13:43:46 <lambdabot42> forall t. (Num t) => t
13:44:08 <Cale> 1 could be an Integer, or a Double, or a Rational, etc.
13:44:09 <oerjan> bah too slow
13:44:16 <ddarius> Cale: Instead of using typeclasses, why not use tuples of functions, e.g. exists a. (a, a -> a, a -> Int)
13:44:27 <Cale> Could do that.
13:45:34 <Cale> So let's use ddarius' type. Suppose I have a triple  (x,f,g) :: exists a. (a, a -> a, a -> Int)
13:45:45 <litb> ah, and if i have "exists" i could only have one type . but which type ?
13:45:48 <Cale> Then I can apply f or g to x
13:45:55 <Cale> litb: You can't know which.
13:46:13 <Tibixe> Hello again
13:46:26 <ddarius> Cale: (Just a note, that type is equivalent to a stream type)
13:46:27 <Cale> Essentially, the only valid things to do with x, f, and g are to apply f to x some number of times, and possibly apply g afterward.
13:46:28 <desegnis> litb: If you have »exists«, you can only apply functions that work for all types
13:46:34 <Tibixe> I've got another problem:
13:46:35 <Cale> Sure.
13:47:18 <desegnis> litb, unless you have other functions involving the same variable, as in the triple example
13:47:37 <Tibixe> I'm trying to get an element's index in an array, without Maybes ( I don't need that kind of safety right now )
13:47:41 <Tibixe> my code is:
13:47:47 <Cale> litb: You see, we know that there's some type a for which (x,f,g) :: (a, a -> a, a -> Int), but we have no information about which type -- so the permissions to use specific properties of that type are gone.
13:47:49 <Tibixe> getCharIndex alph ch= (fromMaybe ch) (elemIndex ch alph)
13:47:57 <dons> from a list, Tibixe
13:48:02 <Tibixe> oh, sorry
13:48:12 <Tibixe> and it gives this type signature:
13:48:17 <dons> > elemIndex 'x' "haskell"
13:48:19 <lambdabot42>  Nothing
13:48:21 <Tibixe> getCharIndex :: [Int] -> Int -> Int
13:48:24 <dons> > elemIndex 'l' "haskell"
13:48:25 <lambdabot42>  Just 5
13:48:29 <Cale> For example, even if *we* might know that a is really String, the type doesn't express that fact, and so applying tail to x would be a type error.
13:48:32 <dons> so what do you return if its not an element?
13:48:45 <dons> Tibixe: i think you have to return a Maybe Int -- some how failure must be encoded
13:48:58 <oerjan> Tibixe: your fromMaybe forces ch to be of the same type as the index
13:49:14 <SamB> Cin: note that I haven't the slightest idea of whether my keyboard is correctly configured...
13:49:43 <Tibixe> oerjan: How can I avoid that?
13:49:49 <Cale> litb: Does that make some kind of sense?
13:50:15 <Tibixe> dons: I don't need that yet, I just want it to work
13:50:31 <Cin> samb: well, i am having trouble getting mine to display the upside down A
13:50:46 <kosmikus> Tibixe: so you're sure the lookup always succeeds?
13:50:50 <oerjan> Tibixe: try fromJust, it raises an exception instead
13:51:05 <Cin> samb: some kind of global shortcut to insert some string of key presses would be nice. do you know of anything like that?
13:51:13 <dons> yeah, you'll have to translate failure into an exception.
13:51:23 <dons> if you don't want to return a value representing failure.
13:51:28 <SamB> Cin: nope
13:51:32 <dons> you /can't/ return a Char though, since the index is an Int.
13:51:44 <Tibixe> oerjan: Thank you, I'll try that
13:51:55 <Cale> litb: To approximate the type  exists a. (a, a -> a, a -> Int) in Haskell, we can use a data declaration: data Stream = forall a. Stream a (a -> a) (a -> Int) -- here, the forall is moved outside of the data constructor, which means that the data constructor must work when applied at any type a
13:51:58 <BMeph> Tibixe: Sounds like you want a "maybe -1 $ elemIndaex ch alph"
13:51:59 <dons> :t \n j -> fromJust (elemIndex n j)
13:52:01 <lambdabot42> forall a. (Eq a) => a -> [a] -> Int
13:52:13 <Tibixe> kosmikus, dons: It's just a quick-and-dirty solution, I'll write it properly tomorrow
13:52:16 <dons> BMeph: better to throw an exception, than return some valid value.
13:52:56 <dons> kosmikus: might be nice to put lhs2tex on ohloh.
13:52:57 <Cale> litb: However, note that the type 'a' doesn't appear on the left hand side of that equation. It's being discarded, essentially.
13:53:10 <dons> kosmikus: i'm trying to get the larger, longer lived things up there.
13:53:28 <Cale> litb: So you can view the Stream data constructor as something which throws away information about the types of the things it's applied to.
13:53:38 * kosmikus hasn't heard of ohloh
13:53:53 <dons> kosmikus: see, e.g., nhc's page, http://www.ohloh.net/projects/11789?p=nhc98
13:54:09 <dons> it does stats and networking between open source projects
13:54:16 <dons> and recently added haskell support
13:54:28 <Cale> I don't really understand the point of ohloh myself.
13:54:44 <dons> Cale, interesting to see who's working on what, and for how long.
13:54:54 <dons> it also gets high hits for projects in google
13:55:06 <dons> so if you type in oh, random numbers, the haskell library should bubble up
13:55:20 <dons> malcolm has 6.5 years haskell experience with nhc :)
13:55:45 <vincenz> Cale: publicity
13:55:47 <ddarius> dons: If it didn't require converting things to git it would be nice.
13:55:49 <dons> so, i argue, haskell should appear in these kind of communities if we're a normal kind of language.
13:55:58 <SamB> you know, I never did figure out what these "super" keys are for
13:55:58 <dons> not in our own little tower of ivory
13:56:05 <Cale> Ivory!
13:56:22 <SamB> dons: there are laws against ivory
13:56:43 <ddarius> SamB: You'd probably get in some trouble making an entire tower out of ivory.
13:56:44 * LoganCapaldo thinks Haskell is manifest proof tat ivory tower / "real world" languge is a false dichotomy
13:56:51 * desegnis prefers ivy over ivory
13:57:09 * dons notes Cale is on the yi page, http://www.ohloh.net/projects/6949/analyses/latest/contributors
13:57:12 <vincenz> ddarius: yeah, lack of enough materials
13:57:14 <kosmikus> dons: I'll have a look at that. but I'm always a bit reluctant to add myself or a project to "yet another site"
13:57:15 * Cale hugs the ivory banister of the staircase in his ivory tower. You'll never take my precious Haskell from here.
13:57:16 * BMeph thinks elephants with ivy tusks would eat themselves
13:57:39 <ddarius> Cale: You are a little late for that.
13:57:42 <yetAnotherOne> ddarius: you could make a small tower
13:58:17 <dons> monads should have been named ivory towers
13:58:20 <Cale> ddarius: We'll see :)
13:58:24 <Cale> hehe
13:58:30 <dons> ones from which you could never escape, without a rope of golden hair
13:58:34 <desegnis> Good I'm not an elephant
13:58:34 <SamB> dons: that would sound too academic
13:58:50 <dons> escapeRapunzel :: IO a -> a
13:58:51 <Cale> SamB: "monad" doesn't? :)
13:59:18 <SamB> sounds nonsensical
14:00:11 <Cale> You might as well have added some feature called "cohomological types"
14:00:17 <dons> its going to be interesting if i can get ghc into git...
14:00:23 <dons> i bet it checks out faster..
14:02:12 <Cin> well i least i have therefore ∴ woo
14:07:49 <SamB> has anyone tried a darcs2-format version of the GHC repository?
14:08:22 <SamB> (NOT a full-blown darcs2 repo)
14:08:40 <dons> its constantly being tested
14:10:00 <dons> wow, mega rant on -cafe. i hope that dies a quick death
14:12:16 <Stinger> quick everyone, go look ;)
14:13:44 <dons> ok wow. i can't answer this. i tried. but he's insane
14:13:53 <dons> <delete>
14:14:08 <Japsu> @dice 3d6
14:14:08 <lambdabot42> 3d6 => 12
14:14:27 <LoganCapaldo> mmm dice
14:14:37 <LoganCapaldo> who wants to start a game of D&D?
14:14:57 <idnar> SamB: what do you mean by "darcs2-format" and "full-blown darcs2 repo"?
14:17:16 <desegnis> dons: It's an amuzing read at least :)
14:18:44 <Cale> dons: I'll answer it with a program, I suppose.
14:18:45 * monochrom gets curious, now goes to look for the rant on haskell-cafe
14:19:09 <Cale> dons: I haven't read it, but it seems he just wants to know how to open and read a file.
14:19:10 <kalven> it's like a yegge blog post
14:19:12 <dons> Cale, hmm. i think he just didn't find readFile and the bracket documentation?
14:19:15 <monochrom> Is it "doubting haskell"?
14:19:26 <Cale> dons: Well, readFile won't do.
14:19:27 <dons> but he's scary insane. those guys are dangerous
14:19:43 <Cale> dons: Since he wants to be able to handle the error cases.
14:19:52 <Cin> heh, what was that one about 90% of haskell being monads
14:19:52 <Cale> But basically.
14:20:01 <Cin> "the haskell 90% problem". stupid catchy titles
14:20:05 <dons> right. its a resource alloc/dealloc case, with handle/catch
14:20:31 <dons> but anyone who couldn't find the docs in 2 weeks has no chance, i think
14:21:02 <dons> Cale, note withFile,
14:21:03 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
14:21:03 <dons> withFile name mode = bracket (openFile name mode) hClose
14:21:09 <ddarius> I read the first few paragraphs, then noticed the thing was like 3 pages long and decided it wasn't worth my time to finish it.
14:21:13 <SamB> well, apparantly darcs2 has a new format for repositories, as well as a new semantics... but can use the old semantics with the new format
14:21:15 <monochrom> 1991 SciAm? Vic-20?  Gosh, this person has too much time.  Doesn't he has a report to write for work?  Why is he wasting time on this long message instead?
14:21:22 <SamB> idnar:
14:21:41 <dons> monochrom: and this guy has the task of evaluating haskell for his boss :(((
14:21:42 <desegnis> monochrom: yeah, and in essence the poster complains that in Haskell you don't check error return codes as you do in C
14:21:49 <dons> sigh
14:22:05 * bringert goes to check his haskell mailbox
14:22:07 <idnar> SamB: ok, so I guess by "darcs2-format" you mean "--hashed format", and by "full-blown darcs2 repo" you mean "--darcs-2 format"
14:22:11 <monochrom> Haha, has he heard of C++ and Java?  I mean, exceptions...
14:22:25 <dons> Cale, so explain that is very simple to write robust code. that in fact there are companies based on this fact. Maybe types are good. and the docs are key.
14:22:52 <dons> but don't burn much on this, i doubt it will help
14:23:17 <monochrom> Exception as a superior way for error detection and handling is invented and described as early as David Parnas's papers in the 70's.
14:23:32 <desegnis> monochrom: He also compains that a tiny cat clone in Haskell will fail if the file does not exist...
14:23:41 <Mortomes> Hi faxathisia
14:23:42 <Cale> dons: I'm just going to point him at System.IO and write his small program in a couple ways.
14:23:43 <cjb> dons: I think the reasonable answer is just to post a concise way to do what he wants :)
14:23:47 <ddarius> Haskell combines both exceptions and error codes in one
14:24:07 * monochrom <3 David Parnas, has the book collecting his representative papers.
14:24:29 <bringert> dons: I don't think he has the task of evaluating haskell
14:24:35 <ddarius> cjb: Yes, that's reasonable, but I doubt it would make any difference.  I seriously doubt any reasonable response will make any difference.
14:24:47 <bringert> dons: "Let me put it this way. Imagine that two weeks ago my forward-thinking
14:24:47 <bringert> and risk-embracing boss asked me to evaluate Haskell for the upcoming
14:24:47 <bringert> Project X."
14:24:56 <bringert> I think "imagine" is the operative word
14:25:04 <ddarius> That's my opinion as well.
14:25:33 <dibblego> "Yes, you're wrong, like you suspected. I'm sorry you wasted 2 weeks." <-- reasonable response :)
14:25:52 <dons> Cale, ok.
14:26:01 <bringert> isn't it just readFile "file" >>= doSomething `catch` \_ -> return ()
14:26:02 <monochrom> Anyway, my conclusion: This person has enough time to write my thesis, but I won't let him do it for obvious reasons. :)
14:26:13 <monochrom> (Should I post that? :) )
14:26:16 <ddarius> monochrom: Because he can't read docs.
14:26:41 <dons> bringert: you might like to claim ownership of some of these projects, http://www.ohloh.net/projects/search?q=haskell
14:27:15 <monochrom> "Dear Alan, you have enough time and energy to write my thesis, but I wouldn't invite you to do it, for obvious reasons."  That would be harsh. :) :) :)
14:27:24 <dons> bringert: http://www.ohloh.net/projects/11737/analyses/latest/contributors
14:29:24 <bringert> dons:how do those projects get there?
14:29:35 <bringert> dons: xhtml seems to be the only one I own
14:29:42 <bringert> dons: what's this good for?
14:30:49 <bringert> dons: ok, saw your haskell-cafe mail
14:32:35 <dons> bringert: the name 'bjorn' or 'bringert' appears on lots of things though.
14:32:49 <dons> so, they get there by creating a page and linking to a git repo.
14:33:01 <bringert> dons: maybe I can merge them by saying "I am this person" on all of them
14:33:04 <SamB> I found ohloh one time googling "Samuel Bronson"
14:33:09 <dons> bringert: right.
14:33:35 <dons> its good for .. i'm not sure. possibly it will end up as the replacement for sourceforge
14:33:37 <SamB> it came up with my ZSNES SVN contributions
14:34:16 <SamB> (I accidentally registered with the username "Samuel Bronson"
14:34:37 <ddarius> SamB: As opposed to ?
14:34:45 <dons> Lord Zenor
14:34:55 <SamB> well, who the heck uses usernames with spaces in them?
14:35:00 <Zao> You?
14:35:07 <SamB> not on purpose
14:35:10 <ddarius> I do on LtU and on the Haskell Wiki
14:35:13 <SamB> I'm honestly a bit surprised it works
14:35:27 <SamB> well, okay
14:35:41 <SamB> maybe I'm just used to CVS ;-)
14:36:04 <SamB> or, well, unix in general
14:36:51 <bringert> gmail ads are fun, the lhs2tex-1.13 announcement brings me an ad for a "latex-free menstrual cup"
14:37:13 <SamB> fantastic! my ohloh profile isn't anywhere near the top anymore
14:37:17 <ddarius> Just what I needed!
14:37:17 <dons> nhc costs $1,211,893.
14:37:18 <gwern> there are some nice lines in that email; 'My line count shrunk to what it "should" be - that is, something Kolmogorov wouldn't laugh at but is unattainable in C++.'
14:37:21 <SamB> </sarcasm>
14:37:35 <SamB> now my amazon profile is at the top
14:38:27 <ddarius> dons: Make sure to tell Malcolm he's underpaid.  You'll probably have to tell the Simons that too.
14:38:28 <SamB> then a wikipedia article about samuel b cooper
14:38:33 <SamB> then some darcs patches
14:38:34 <kosmikus> bringert: :)
14:38:52 <gwern> SamB: are you samuel b cooper?
14:38:57 <SamB> nope
14:39:01 <dons> bringert: see also http://www.ohloh.net/projects/11781/analyses/latest/contributors (time) and Quickcheck , http://www.ohloh.net/projects/11733/analyses/latest/contributors
14:39:04 <SamB> bronson is my very last name
14:39:05 <gwern> oh. too bad
14:39:30 <SamB> you wanted to be friends with someone who died in 1918
14:39:31 <SamB> ?
14:39:35 <TomMD> I'll take Sam Bronson - you keep your Cooper.
14:39:47 <TomMD> :-)
14:39:55 <SamB> can I has free barrels?
14:40:04 <crutcher> does anyone have the time to help me puzzle through a class definition?
14:40:06 <gwern> SamB: no, it would've been neat though. it's always interesting to see what people make of their WP entry
14:40:47 * gwern wonders if this Alan Carter ever even asked #haskell about 'bracket' or 'catch'
14:40:48 <SamB> I'd say something about it not meeting notability requirements and containing too much independant research
14:41:00 <TomMD> crutcher: which class?
14:41:36 <gwern> SamB: you mean 'original research', but good try anyway :)
14:41:41 <SamB> this is ridiculous
14:41:49 <SamB> I get results from perl.com before ohloh
14:41:56 <crutcher> Well, I'm still learning, and I'm trying to do exercises out of "An Introduction to Functional Programming Systems Using Haskell" Davie
14:42:08 <crutcher> so I'm trying to implement a class which describes a store.
14:42:21 <crutcher> and instances which implement the store in different ways
14:42:36 <crutcher> but the store has two internal types
14:42:41 <crutcher> the type of the keys
14:42:45 <crutcher> and the type of the data
14:42:56 <SamB> crutcher: constructor class
14:43:03 <SamB> ?
14:43:15 <crutcher> um, what?
14:43:32 <SamB> well, what does your class look like so far?
14:43:51 <TomMD> crutcher: to clarify, you mean 'typeclass' right?  errr... just answer SamB, either way will explain it.
14:44:38 <crutcher> well, I first tried 'class (Eq a) => Store a b where ...' but that doesn't work for obvious reasons
14:44:44 <SamB> actually I meant "you could use a class that applies to types of kind other than *"
14:44:58 <SamB> but that won't make any sense to crutcher either, will it?
14:45:15 <crutcher> where would I look for docs on how to do that?
14:45:38 <crutcher> I've tried the haskell report, and gentle introduction
14:45:57 <TomMD> crutcher: Another popular one is "Yet Another Haskell Tutorial"
14:45:59 <dons> crutcher: hmm. so a generalised Map ?
14:46:07 <crutcher> yes.
14:46:15 <SamB> class Store s :: * -> * -> * where foo :: Ord a -> Store a b -> a -> M b ...?
14:46:27 <ddarius> s/Store/s
14:46:38 <SamB> true
14:46:38 <ddarius> And Ord a =>
14:46:48 <SamB> yeah
14:46:51 <SamB> my spelling is horrible
14:47:02 <ddarius> You don't know how to spell => ?
14:47:08 <crutcher> SamB, actually, with the exception of :: * -> * -> * that's almost exactly what I had.
14:47:19 <crutcher> (cept I was using Eq, not Ord)
14:47:29 <SamB> well, I haven't really written any Haskell code to speak of since the beginning of the school year...
14:47:30 <crutcher> what does :: * -> * -> * mean?
14:47:50 <oerjan> crutcher: s takes two type parameters
14:48:11 <SamB> crutcher: well, it means "this is a class of constructors that take two type arguments"
14:48:17 <oerjan> class Store s :: * -> * -> * where foo :: Ord a => s a b -> a -> M b ... -- corrected
14:48:19 <ac> Cin: pong: time=24420000ms
14:48:43 <SamB> oerjan: no parens needed around s :: ...?
14:48:48 <oerjan> (actually the :: * -> * -> * part is not really necessary, it is inferred there)
14:48:48 <crutcher> okay, I think I get it.
14:48:51 <synthase> if I want to remove an object from a set of Integers, in the case where the set given is empty, how could I have my function produce an empty list? My current type for my function is [Integer] -> [Integer]
14:49:05 <oerjan> SamB: missed that error
14:49:26 <SamB> yeah me too ;-)
14:49:38 <crutcher> synthase: remove _ [] = []
14:49:38 <oerjan> class Store s where foo :: Ord a => s a b -> a -> M b ... -- corrected again
14:49:53 <Zao> synthase: Note that there exists a Set datatype too.
14:50:14 <SamB> oerjan: the kind annotation is necessary for pedagogical purposes!
14:51:00 <oerjan> class Store (s :: * -> * -> *) where foo :: Ord a => s a b -> a -> M b ... -- with kind back
14:51:01 <TomMD> Anyone know a reason why YHC / scons doesn't see my gmp.h? (and libgmp-dev is installed)
14:51:25 <oerjan> :t delete
14:51:27 <lambdabot42> forall a. (Eq a) => a -> [a] -> [a]
14:51:52 <synthase> I'm following the haskell road to logic, maths and programming and for this exercise(to remove the first occurence of an Integer m from a list of Integers
14:52:00 <synthase> I guess I should revise my type
14:52:09 <SamB> TomMD: ask in #scons?
14:52:10 <crutcher> than you, that works.
14:52:10 <synthase> it should be Integer -> [Integer] -> [Integer]
14:52:21 <SamB> note that I'm not sure there is a channel called that
14:52:40 <faxathisia> synthase: That seems very simple
14:53:00 <faxathisia> synthase: It's a partial function (sometimes it's undefined) right?
14:53:01 <synthase> at this point in the text, they don't use remove or Set so I'd imagine it is doable without those
14:53:10 <synthase> yeah
14:53:32 <TomMD> SamB: Didn't even know scons had a channel!
14:53:35 <crutcher> synthase: you've got two cases, and you can recurse, right?
14:53:41 <faxathisia> synthase: in that case.. remove e (x:xs) | e == x = xs -- may make a sufficient base case
14:53:49 <oerjan> synthase: remove was just what to call the function (the predefined function which does what you are doing is called delete)
14:53:51 <synthase> I can recurse but the book has not mentioned any kind of consing like mechanism
14:53:52 <faxathisia> synthase: Is it clear what all that does?
14:54:08 <SamB> TomMD: would be kinda odd for it not to have one somewhere
14:54:38 <crutcher> remove e (x:xs) | e == x = xs
14:54:47 <synthase> yeah, that part is simple
14:54:51 <TomMD> SamB: Yeah, I understand that.  I guess I just ask because I blame yhc for anything that goes wrong with yhc build - perhaps not very fair of me.
14:54:53 <crutcher> remove e (x:xs) | otherwise = x : remove e xs
14:55:05 <synthase> but if you are in the middle of a list, how can you join the previous part to the rest?
14:55:06 <Feuerbach> today I was asked a question: does Haskell allow its embedding into programs in other languages? (reverse ffi)
14:55:10 <crutcher> remove _ [] = []
14:55:22 <oerjan> crutcher: you don't need to repeat the pattern with a new guard if it is identical
14:55:28 <Stinger> Hmm I don't suppose there's a way to get ghci to load a module that was installed after it was started?
14:55:35 <faxathisia> synthase, do you understand my line?
14:55:35 <Zao> Feuerbach: It's possible to call into Haskell from C and friends, I believe.
14:55:51 <Feuerbach> Zao: any docs on that?
14:55:53 <crutcher> oerjan: (yeah, but I didn't want to loose teh guard in the channel noise)
14:55:55 <synthase> faxathisia: yeah, I had that already defined
14:56:31 <crutcher> synthase: ':' is the cons function
14:56:39 <crutcher> it acts as an binop
14:56:45 <synthase> faxathisia: I don't know what to do if I am in the middle of the list and come across such an occurence. I would be left with the previous part of the list that I have gone through and the remaining part. I would need to join the two.
14:56:52 <faxathisia> synthase: so the next thing the recursive case.. where the heads aren't equal.. what you'd do then is just cons the head x onto (remove e xs)
14:57:01 <Zao> Feuerbach: I can't seem to find my sample project nor any of the references I used.
14:57:19 <faxathisia> synthase: There is no middle of the list, you use induction to write the function
14:57:33 <Zao> Feuerbach: I did however manage to make a gcc-based DLL that called into Haskell that I could call into from a MSVC++ DLL :)
14:57:36 <synthase> faxathisia: I was referring to the middle of the list as an example
14:57:53 <faxathisia> synthase: meaning you write a base case, then a case which does recursion under the assumption the function works
14:57:59 <synthase> faxathisia: to point out the idea of wanting to cons two parts of a list
14:58:05 <faxathisia> (for a structurally smaller list)
14:58:05 <Philippa_> when writing Bird-style Literate Haskell emails, what's the usual way to quote someone you're replying to?
14:58:32 <Zao> Feuerbach: foreign export most likely helps.
14:58:37 <Zao> Feuerbach: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html
14:58:38 <faxathisia> synthase: You saw by description of the recursive case?
14:58:51 <ddarius> I don't think there is a usual way.  If you don't care if the file is immediately executable, you can continue to use > for quoted parts, alternatively, you could use <
14:58:52 <faxathisia> synthase: Just cons the head x, onto (remove e xs)
14:58:53 <oerjan> Philippa_: nice conundrum that.  just use any other bracket?
14:58:55 <Zao> Feuerbach: 9.2.1.1 seems to cover your question.
14:58:59 <dons> Cale++
14:59:17 <shachaf> Philippa_: I've seen name>, I think.
14:59:27 <faxathisia> synthase: Is the only thing you're missing how to put that in haskell?
14:59:38 <synthase> faxathisia: I think I got it
14:59:47 <cjb> Cale: Great e-mail.
15:00:37 <Feuerbach> Zao: thanks!
15:00:48 <synthase> faxathisia: if ':' is used to cons then | otherwise x : remove e (xs) ? though you said (remove e xs) I don't understand that distinction between remove e (xs) and (remove e xs)
15:01:03 <Philippa_> hmm. Thinking about it, I reckon LH is still awkward if you want to include multiple small programs in one mail
15:01:04 <faxathisia> synthase: They are the same
15:01:10 <synthase> ok, good
15:01:13 <synthase> faxathisia: thanks
15:01:18 <faxathisia> synthase: the paranthesis are not required
15:01:40 <ddarius> dons, Cale: Now we see what happens.
15:01:49 <faxathisia> synthase: I should also point out that... ((f x) y) z = f x y z
15:02:03 * monochrom posts to haskell-cafe.  tee hee hee!
15:02:18 <monochrom> (Too bad Cale is quicker :) )
15:02:28 <synthase> faxathisia: because it is left associative?
15:02:41 <faxathisia> synthase: yeah exactly
15:06:13 <crutcher> SamB: okay, new problem :)
15:06:29 <crutcher> I've got 'find' and 'update' working
15:06:42 <crutcher> now I'm trying to implement 'empty' to return an empty store.
15:06:57 <crutcher> so, empty :: s a b
15:07:00 <SamB> and?
15:07:13 <crutcher> and the instance is: empty = Empty (the constructor for my empty store)
15:07:19 <SamB> okay
15:07:35 <TomMD> But the type system must be complaining, right?
15:07:42 <crutcher> yeah
15:07:46 <SamB> so one assumes
15:07:56 <crutcher> Ambiguous type variable `s' in the constraint:
15:07:56 <crutcher>       `Store s' arising from a use of `empty' at <interactive>:1:0-4
15:07:57 <SamB> why else would he have said "problem"?
15:08:07 <SamB> crutcher: ah.
15:08:15 <SamB> crutcher: where are you using it?
15:08:26 <crutcher> I tried 'update 1 2 empty'
15:08:29 <faxathisia> can't you just erase the type signature?
15:08:45 <oerjan> crutcher: when using class instances on the interactive line you sometimes need to provide a signature
15:08:47 <SamB> faxathisia: eh?
15:09:12 <faxathisia> or this is inside a typeclass?
15:09:14 <SamB> crutcher: the compiler is just refusing to guess what type you meant, that's all...
15:09:22 <oerjan> try update 1 2 empty :: YourStoreType Int Int
15:09:26 <SamB> faxathisia: the only signature mentioned is, yes
15:09:35 <crutcher> update 1 2 empty :: AssocList Int Int
15:09:38 <crutcher> yeah, that worked.
15:09:42 <crutcher> sorry, thanks.
15:09:48 <SamB> np
15:10:04 <SamB> I've actually had that as a problem...
15:10:31 <TomMD> Its certainly a common issue.
15:10:34 <synthase> faxathisia: this error is puzzling me http://rafb.net/p/bQw43T47.html -- does it make sense to you?
15:10:55 <faxathisia> synthase: Yeah
15:11:16 <faxathisia> synthase: The compiler inserts {;}'s by the layout rule when parsing
15:11:21 <oerjan> faxathisia: missing = after otherwise
15:11:23 <SamB> I mean, I've tried to write stuff that could not actually be used because it caused that same kind of ambiguity...
15:11:44 <faxathisia> synthase: And so the error (that you didn't put = in) shows up with a } problem
15:11:54 <crutcher> synthase: what's your primary goal? Learning Haskell, or discrete mathematics?
15:12:18 <synthase> crutcher: both
15:12:19 <crutcher> if its learning haskell, that's not a very good book for it (I've got it)
15:12:38 <Axioplase> Hi.
15:12:40 <oerjan> synthase: the layout } insertion is sort of semi-independent of the rest of parsing and ghc is not too smart about it
15:12:49 <SamB> so... is that book good for discrete mathematics for people who don't care about Haskell?
15:13:21 <oerjan> it doesn't fully check whether it actually makes sense to put }'s in there
15:13:33 <gwern> ''Then when all this was going on, question number five appeared: What the hell are these "lightweight Haskell threads"? Are they some kind of green threads running non-preemptively inside a single OS thread? Are they OS threads that could run concurrently on multi-core hardware? If they are green threads (and it sounds like they are) then this is all an academic exercise which has no production application yet.'' <-- aren't they green threads by ...
15:13:40 <gwern> ... default but farmed out to OS threads when +RTS -n 4 or whatever is used with a threaded binary?
15:13:58 <crutcher> DM is the primary focus there, but you have to learn Haskell. It just stays away from some of the more interesting things, like Monads, so you aren't really in a place to do mutch more than compute numbers
15:14:41 <Axioplase> Hum.. Are haskell types turing complete ? (perhaps with a few GHC options)
15:14:51 <faxathisia> Axioplase; no
15:14:58 <ddarius> gwern: GHC has a many to many scheduler
15:15:00 <SamB> oerjan: to be fair, the Haskell Report doesn't say anything about checking whether it makes sense or not
15:15:02 <faxathisia> Axioplase; extensions are though
15:15:15 <synthase> faxathisia: then it should read something like otherwise x : = removeFST m (xs) ? -- I mean, that's the idea
15:15:16 <oerjan> faxathisia: oh, that should have been to synthase as well
15:15:17 <gwern> ddarius: er..?
15:15:29 <Axioplase> faxathisia: and would that be bad ? (I remember a teacher of mine saying "hopefuly COQ is *not* turing complete"
15:15:34 <faxathisia> synthase: otherwise = x : ...
15:15:37 <SamB> gwern: they are green threads running on native threads
15:15:44 <synthase> ah
15:15:50 <faxathisia> Axioplase; It doesn't matter
15:15:51 <SamB> in parallel
15:15:54 <ddarius> gwern: Haskell threads are "green threads" but GHC will schedule (many of) them over many hardware threads.
15:15:58 <SamB> (well, possibly)
15:16:11 <dons> http://www.kimsal.com/reldevsurvey/results.php?action=byLanguage&language=19#relbylang
15:16:19 <gwern> ddarius: if they hardware threads are available; if not all the green threads run withing the one process/thread, right?
15:16:24 <dons> apparently we're love state more than church...
15:16:42 <SamB> gwern: the Haskell threads are green regardless of processor support
15:16:45 <ddarius> gwern: Rephrase that question.
15:16:49 <faxathisia> Axioplase; If you are trying to write proofs in the haskell type system you get zero credibility anyway
15:17:07 <faxathisia> Axioplase; Since every type is inhabited, nontermination doesn't make things worse
15:17:10 <ddarius> dons: When and where did that survey take place?
15:17:34 <dons> i've no idea. but that's a suspiciously high number of respondants...
15:17:36 <oerjan> SamB: of course, checking for sense is important for correcting the current awful error message though
15:17:39 <faxathisia> Axioplase; Coq is consistent though.. so nontermiation would break that
15:17:40 <SamB> gwern: and you can tell the RTS how many native threads to schedule them in using +RTS parameter
15:17:48 <dons> http://www.kimsal.com/reldevsurvey/
15:17:53 <SamB> oerjan: yeah
15:17:58 <gwern> ok, so my intuitive understanding was close enough
15:18:26 <SamB> they are somewhat cooperatively threaded, I think...
15:19:04 <SamB> that is, if a thread does no allocation, I'm not sure the schedular will get to run...
15:20:08 <ddarius> dons: Uh, he needs to specify ratios not absolute values.
15:20:11 <faxathisia> Axioplase; Did that make sense?
15:22:07 <Mr_Awesome> is error handling in haskell usually done with exceptions? or is it usually done with monads (ie Map.lookup) ?
15:22:33 <faxathisia> Mr_Awesome: You might use ErrorT
15:22:40 <mahogny> it is done with a plethoria of ways :/
15:22:58 <ddarius> Mr_Awesome: We model exceptions with monads.
15:23:13 <Mr_Awesome> mahogny: ive noticed
15:23:25 <Mr_Awesome> ddarius: yeah, i know. i meant a general monad
15:23:38 <faxathisia> "general monad"?
15:23:46 <Mr_Awesome> like, any monad
15:23:52 <Mr_Awesome> as in Map.lookup
15:23:59 <ddarius> I think he means the NotJustMaybe idiom.
15:24:18 <faxathisia> Mr_Awesome: Yes, There's even an example of it in the standard library :P
15:24:26 <oerjan> Mr_Awesome: MonadError includes an IO with exceptions instance so you can abstract it away a bit
15:24:57 <oerjan> @instances Control.Monad.Error MonadError
15:24:59 <lambdabot42> Couldn't find class `Control.Monad.Error MonadError'. Try @instances-importing
15:25:08 <oerjan> @instances- Control.Monad.Error MonadError
15:25:09 <lambdabot42> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
15:26:05 <Mr_Awesome> well currently, ive just been calling the error function. but im thinking thats not a terribly great way to do things.
15:26:05 <vininim> > 2**25/10**9
15:26:08 <lambdabot42>  3.3554432e-2
15:26:10 <Axioplase> faxathisia: yeah, right. Thanks. I was just wondering though, as I was chatting with someone saying "you obviously can't encode that with your types".
15:26:40 <faxathisia> Axioplase; What is that? You can still do a great deal
15:26:55 <ddarius> Mr_Awesome: It depends.  It's difficult (impossible in H98) to recover from that, but if you don't mean to then that's fine, or if you'd just terminate with an error message anyways.
15:27:39 <oerjan> :t throwError
15:27:42 <lambdabot42> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
15:27:55 <siti> :t fail
15:27:57 <lambdabot42> forall (m :: * -> *) a. (Monad m) => String -> m a
15:28:38 <oerjan> @src IO fail
15:28:38 <lambdabot42> fail s  = failIO s
15:28:44 <oerjan> @src failIO
15:28:45 <lambdabot42> failIO s = ioError (userError s)
15:28:48 <Axioplase> "that" is whatever non trivial encoding. I provided code that only accepts lists of even length. He said "what if I want to accepts only lists of length multiple of 4321? Apart from those simple cases, there must be problems you can't write with your types"
15:29:50 <Axioplase> to which my answer is "computable problems should be possible to embed in the type system"
15:29:53 <faxathisia> oh cool, can I see that please?
15:30:10 <ddarius> faxathisia: type EvenList a = [(a,a)]
15:30:17 <Mr_Awesome> the problem with using fail is that it requires me to change all the types and the code to use monads. perhaps ill just use exceptions
15:30:23 <Axioplase> faxathisia: ask ddarius, he helped me write it ^^
15:30:55 <faxathisia> There was the suggestion you can do declaritive arithmetic in the Haskell type system in that paper..
15:31:02 <Mr_Awesome> it would be nice if std lib functions did the same
15:31:10 <faxathisia> not suce how far you can go before using extentions though
15:31:32 <ddarius> Mr_Awesome: Did the same what?
15:31:34 <shachaf> Mr_Awesome: You don't think a function that can fail should have a different type from one that can't?
15:32:03 <oerjan> Mr_Awesome: you can catch error as an exception.  but all exceptions can only be caught in IO
15:32:35 <awesame> whee, I just got codepad.org speaking haskell: http://codepad.org/uHm6vWIG
15:32:46 <awesame> (it's a pastebin that runs your code for you)
15:33:04 <dons> well done, awesame
15:33:07 <cjb> oh, that's a good idea
15:33:08 <ddarius> awesame: So I can hack it now with Haskell?
15:33:10 <oerjan> Mr_Awesome: once you are using exceptions you have lost all ability to make the error handling pure
15:33:18 <awesame> ddarius: you're welcome to try
15:33:59 <monochrom> unsafePerformIO! :)
15:34:05 <lispy> Cale: this paper is from 2007, how long has GHC had higher ranks?
15:34:18 <dons> awesame: how do you ensure safety?
15:34:23 <cjb> oh, cool, codepad gives you a chunk of CPU time before killing the process.
15:34:29 <ddarius> lispy: At least a few years now, especially if you count only rank-2 types.
15:34:33 * cjb just tried to print an infinite list.
15:34:33 <Cale> lispy: A while... I'm not really certain.
15:34:34 <dons> oh, i guess they sandbox, do they?
15:34:52 <awesame> dons: the code is run under a ptrace supervisor based on Eelis's geordi
15:34:59 <Cale> Did GHC 5 have rank-2 types?
15:35:00 <dons> awesame: might be worth reading, http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
15:35:08 <monochrom> Nice! I can haz unsafePerformIO? :)
15:35:09 <faxathisia> awesame, That's really nice
15:35:13 <dons> Cale, yeah. needed for ST since forever, no?
15:35:27 <ddarius> Cale: Yes.
15:35:33 <Cale> Right, yeah.
15:35:33 <ddarius> What dons said.
15:35:38 <dons> hey, we could use the pastebin thingy to embed haskell evaluators in the wiki
15:35:46 <dons> and do simple tutorials and so on
15:35:47 <lispy> dons: clever
15:35:56 <dons> like good old lambdaweb :)
15:36:01 <lispy> :(
15:36:11 <monochrom> onoes, Active Haskell Content (AHC)
15:36:13 <lispy> yeah, like lambdaweb should be, if it weren't broken
15:36:19 <awesame> hm, I should make a little embeddable chunk of html
15:36:33 <awesame> I'll think about that this evening
15:38:34 <monochrom> An STM tutorial would say "Note that it is not nice to allow IO inside STM - consider [|atomically (flip variable; launch missile)|].  CLICK HERE TO TRY IT!"
15:38:42 <lispy> dons: I guess if I'd get off my ass and put more of my programs in hackage they'd be less dead?
15:38:47 <synthase> is fromInt suppose to be a function defined by the haskell standard?
15:38:57 <lispy> ?hoogle fromInt
15:38:57 <lambdabot42> Prelude.fromInteger :: Num a => Integer -> a
15:38:58 <lambdabot42> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
15:39:07 <gwern> does anyone remember what 'buildVerbose buildflags > 0' *used* to me? I've gussed it now means '
15:39:14 <gwern> buildVerbose buildflags > silent'
15:39:17 <gwern> but I'm not sure
15:39:25 <gwern> *used to mean
15:39:50 <monochrom> There is no fromInt
15:39:55 <gwern> fromIntegral mebbe
15:40:00 * faxathisia wishes there was a Types channel...
15:40:03 <gwern> @hoogle fromInt
15:40:03 <lambdabot42> Prelude.fromInteger :: Num a => Integer -> a
15:40:03 <lambdabot42> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
15:40:05 <monochrom> Yeah, use fromIntegral.
15:40:20 <monochrom> @quote fromIntegral
15:40:20 <lambdabot42> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:40:25 <gwern> lispy: what is lambdaweb?
15:40:37 <vininim> > let {f = splitAt 3; g [] = []; g x = fst (f x):(g $ snd (f x))} in g $ show (2**25)
15:40:39 <faxathisia> lol
15:40:40 <lambdabot42>  ["3.3","554","432","e7"]
15:40:42 <monochrom> lambdaweb is probably lambdabot taken to the web
15:40:51 <shachaf> gwern: See http://lambdabot.codersbase.com/ .
15:40:53 <gwern> ...
15:41:01 <lispy> gwern: it's pretty cool, but due to some problems with ghc on my server, it's down at the moment
15:41:15 <lispy> gwern: well, that and someone broke the parts of lambdabot that communicate via the web
15:41:18 <gwern> monochrom: I love you dearly, but so help me, I will beat you like a red-heade stepchild one o these days :)
15:41:19 <shachaf> And has been for some time.
15:41:37 <vininim> > let {f = splitAt 3; g [] = []; g x = fst (f x):(g $ snd (f x))} in g $ show ((2**25)::Integer)
15:41:38 <lambdabot42>   add an instance declaration for (Floating Integer)
15:41:39 * monochrom hides
15:41:40 <gwern> lispy: is it a happs thing?
15:41:47 * lispy tries to remember
15:41:52 <lispy> gwern: I don't think so
15:42:07 <lispy> gwern: we use ghc on acid, lambdabot, and fastcgi, iirc
15:42:09 <vininim> :t (**)
15:42:11 <lambdabot42> forall a. (Floating a) => a -> a -> a
15:42:16 <lispy> and some ajax for good measure
15:42:17 <vininim> :t (^)
15:42:19 <lambdabot42> forall a b. (Integral b, Num a) => a -> b -> a
15:42:29 <vininim> > let {f = splitAt 3; g [] = []; g x = fst (f x):(g $ snd (f x))} in g $ show ((2^25)::Integer)
15:42:31 <lambdabot42>  ["335","544","32"]
15:42:46 <lispy> gwern: if you'd like to see the source i have a darcs repo
15:42:47 <cygnus_> if i have swap (w1 : w2 : ws) = w2 : w1 : ws , will this work on a list of 1 element ? i think it should since [] : []  = [] but apparently it doesn't
15:42:53 <gwern> lispy: ghc on acid? now that's a new one on me. is that just metaphorical...?
15:42:56 <gwern> lispy: yeah sure
15:43:00 <shachaf> @where goa
15:43:00 <lambdabot42> http://www.cse.unsw.edu.au/~dons/code/goa/
15:43:10 <lispy> gwern: gao is a way to make lambdabot interact with ghc
15:43:15 <lispy> er, ghci
15:43:23 <gwern> ouch 2006
15:43:48 <lispy> gwern: oh, i see this, i don't know how up to date it is: http://darcs.haskell.org/lambdaweb/
15:43:55 <lispy> that's not my repo, but it should be something
15:44:03 <gwern> where is your repo?
15:44:09 * gwern hates looking at old versions
15:44:19 <monochrom> > [] : []
15:44:21 <lambdabot42>  [[]]
15:44:30 <faxathisia> > [] : [] : []
15:44:32 <lambdabot42>  [[],[]]
15:44:38 <faxathisia> >:[
15:44:50 <idnar> om nom nom
15:44:51 <monochrom> Let us not accidentally re-invent natural numbers!
15:44:56 <lispy> gwern: its's not terribly old tho
15:45:00 <lispy> gwern: that link i gave you
15:45:10 <lispy> gwern: no one works on lambdaweb in a while
15:45:23 <lispy> ?quote skynet
15:45:23 <lambdabot42> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
15:45:29 <lispy> that was the first release
15:45:51 <cygnus_> monochrom: so it's not the same
15:45:59 <monochrom> "GHC on alkaline batteries --- it will keep going, ..."? :)
15:46:01 <Japsu> @index fact
15:46:01 <lambdabot42> bzzt
15:46:03 <Japsu> @index fac
15:46:03 <lambdabot42> bzzt
15:46:05 <Japsu> bah
15:46:13 <cygnus_> > 'a' : []
15:46:16 <lambdabot42>  "a"
15:46:23 <cygnus_> > [] : 'a' : []
15:46:25 <lambdabot42>  Couldn't match expected type `[a]' against inferred type `Char'
15:46:31 <faxathisia> > ([] : []) : []
15:46:33 <lambdabot42>  [[[]]]
15:46:41 <faxathisia> > (([] : []) : []) : []
15:46:42 <cygnus_> why can't i put an empty list on the front
15:46:43 <lambdabot42>  [[[[]]]]
15:46:46 <faxathisia> yeah tha works\
15:47:08 <monochrom> > {- this is the decisive test -}  case [0] of (x:y:z) -> "foo"; _ -> "bar"
15:47:10 <lambdabot42>  "bar"
15:47:12 <faxathisia> you can't add them though?
15:47:12 <vincenz> > fix (:[])
15:47:13 <lambdabot42>      Occurs check: cannot construct the infinite type: a = [a]
15:47:14 <lambdabot42>       Expected...
15:47:15 <idnar> @type :
15:47:17 <lambdabot42> parse error on input `:'
15:47:19 <idnar> @type (:)
15:47:20 <vincenz> > show $ fix (:[])
15:47:21 <lambdabot42> forall a. a -> [a] -> [a]
15:47:21 <lambdabot42>      Occurs check: cannot construct the infinite type: a = [a]
15:47:22 <lambdabot42>       Expected...
15:47:22 <monochrom> Therefore 1-length list doesn't match x:y:z
15:47:31 <shachaf> cygnus_: What would be the type of that?
15:47:48 * gwern cheerfully uploads a working hinstaller without talking to the author
15:48:00 <faxathisia> idnar, [a,b,c] = (a:[b,c])
15:48:06 <idnar> faxathisia: yes
15:48:06 <cygnus_> i guess it doesn't make sense
15:48:15 <cygnus_> ok how come i can do 1 :: [] how is the type of [] matching 1
15:48:19 <idnar> I was trying to answer cygnus_'s question
15:48:30 <idnar> > 1 :: []
15:48:31 <lambdabot42>      `[]' is not applied to enough type arguments
15:48:32 <lambdabot42>     Expected kind `?', but ...
15:48:33 <monochrom> Please don't write 1::[].  Wrtie 1:[].
15:48:35 <lispy> gwern: I don't know where my repo is right now :(
15:48:41 <faxathisia> idnar, oh sorry
15:48:45 <cygnus_> ok
15:48:51 <cygnus_> but why does it work
15:48:53 <idnar> faxathisia: the left of : is a list element, the right of : is a list
15:49:05 <monochrom> 1:[] is [1]. Definition.
15:49:06 <idnar> look at the type (a -> [a] -> [a])
15:49:35 <cygnus_> so basically 1:[] doesn't really exist
15:49:36 <monochrom> 1:2:[] is 1:(2:[])
15:49:42 <gwern> lispy: how very careless
15:49:45 <monochrom> Actually, [1] doesn't exist.
15:49:54 <faxathisia> Hey FunctorSalad
15:49:56 <psykon> Stack space overflow: current size 8388608 bytes.
15:49:56 <cygnus_> so what is the type of 1:[]
15:49:57 <psykon> Use `+RTS -Ksize' to increase it.
15:49:59 <lispy> gwern: well, i'm working on other things at the moment and it's not where i thought i left it
15:50:01 <psykon> is this "normal" ?
15:50:09 <monochrom> the type is [Int]. why?
15:50:11 <faxathisia> :t 1:[]
15:50:12 <FunctorSalad> hello faxathisia
15:50:14 <lambdabot42> forall t. (Num t) => [t]
15:50:15 <gwern> ok, that's one DisTract dependency down...
15:50:19 <dons> psykon: typically that means you've an error in the code
15:50:29 <psykon> hmm ok
15:50:31 <dons> psykon: or a space leak (e..g using foldl on the wrong type)
15:50:39 <psykon> haha
15:50:42 <psykon> i just added a foldl
15:50:43 <dons> look for infinite loops, or foldl's that should be foldr/foldl'
15:50:47 <psykon> just before this error
15:50:51 <dons> also, are you compiling the code ?
15:50:56 <psykon> yes i am
15:51:01 <dons> using ghc -O2 will help the compiler squash strictness issues
15:51:09 <dons> be sure to turn on optimisations though.
15:51:38 <dons> you can compile with -prof -auto-all -O2 , run the program, and then look at the .prof file generated. it will list which function did all the stack allocation
15:52:34 <stoo> Does anyone have any idea of general household objects which might be used to drive the cork into a bottle of wine?
15:52:40 <dons> Cale, wow, this guy seriously has problems looking for docs eh?
15:52:43 <lispy> gwern: something that kind of broke it in the past was that dons worked to make lambdabot call-able with the right command line options, but some later devolpment by someone else compeletly broke this in a way that was undocumented near as I can tell.  I never did have time to get it working since then.
15:52:53 <Cale> dons: yeah.
15:52:55 <psykon> dons: thanks
15:52:55 <cygnus_> so the empty list has every type ?
15:53:01 <oerjan> :t []
15:53:03 <lambdabot42> forall a. [a]
15:53:03 <monochrom> @faq Can haskell drive the cork into a bottle of wine?
15:53:03 <lambdabot42> The answer is: Yes! Haskell can do that.
15:53:07 <stoo> cygnus_, same cygnus as efnet?
15:53:08 <dons> psykon: if you get stuck, hpaste.org the code, and we can have a look
15:53:18 <stoo> reversers cygnus? :l
15:53:28 <gwern> lispy: I see. too bad. lambdabot is very capable. veyr messy but veyr capable
15:53:30 <Cale> cygnus_: Every list type.
15:53:31 <cygnus_> stoo: hey stubing
15:53:33 <stoo> :D
15:53:38 * gwern goes now
15:53:39 <stoo> 'lo mate ltns heh
15:53:47 <idnar> :t Nothing
15:53:48 <lambdabot42> forall a. Maybe a
15:53:52 <cygnus_> :t []
15:53:54 <monochrom> Driving cork into bottle is likely impossible in an ordinary home.
15:53:55 <lambdabot42> forall a. [a]
15:53:59 <cygnus_> stoo: hows it going
15:54:27 * Philippa_ sees that she spent too long on her mailing list post to get there first
15:54:35 <idnar> stoo: I assume you mean driving it into the neck of the bottle
15:54:35 <monochrom> It's deliberately made like Haskell. Once you open your mind to it, you can't undo.
15:54:41 <lurgee> I am well
15:54:44 <idnar> having cork floating in your wine is usually undesireable
15:55:02 <dons> Philippa_: heh. also, i think the situation is a lot better than it was a few years ago :) this guy isn't having troubles buliding his own batteries -- just reading docs.
15:55:04 <ddarius> Philippa_: Did you waste your time replying to that ridiculous email too?
15:55:15 <dons> Philippa gets to join the club.
15:55:27 <Philippa_> dons: it's not as bad as it was regarding errors specifically, but it's still far from ideal at the moment
15:55:40 <ddarius> dons: You're our PR guy and -you- didn't respond to him.
15:55:57 <Philippa_> and it will be until we've got libs that in some sense unify pure and IO errors in a scalable manner without resorting to catching in the IO monad
15:55:59 <dons> ddarius: i attempted to, and almost had an aneurism
15:56:00 <SamB> dons, you're beside yourself
15:56:01 * cjb found all of the replies helpful.
15:56:04 <Philippa_> (or at least always doing so)
15:56:11 <lurgee> Sometimes all this feels like opening wine bottles with a screw driver.
15:56:15 <SamB> see http://www.ohloh.net/projects/11732/analyses/latest/contributors
15:56:17 * cjb isn't going to say that means the original post was helpful, though :)
15:56:28 <vincenz> dons: which article?
15:56:32 <Philippa_> I think the original post was fairly helpful as a reminder of what newbies still experience
15:56:39 <dons> Philippa_: yes, i'm inclined to push to Either or Maybe for everything. and catch IO errors at the site, propagating into values
15:57:06 <Philippa_> there isn't a single "here's how to handle errors in Haskell" tutorial, for example, because there're multiple strategies in use and the only place they really got collected was the last time we were talking about what direction the libs should take
15:57:10 <dons> SamB: :)
15:57:11 <ddarius> Philippa_: That if they don't read the documentation and come in with prejudices about the way things should be done they'll have issues?
15:57:19 <monochrom> Depends on what kind of newbies. The Java kind of newbies, they embrace exceptions already.
15:57:21 <Philippa_> that the docs suck
15:57:21 <hpaste>  crutcher pasted "What's wrong with my data type?" at http://hpaste.org/5710
15:57:50 <ddarius> Either (or some variation) is what should be used unless you can't.
15:58:08 <crutcher> SamB: new problem :)
15:58:12 <monochrom> Here you have an archaic newbie still believing in 1960 C-style "return code" error handling, and has the gut to call it "production code 101".
15:58:35 <dons> maybe its a troll?
15:58:47 <oerjan> crutcher: delete doesn't delete pairs
15:58:51 <monochrom> I call it "production code 1960".
15:58:57 <Philippa_> monochrom: in pure code we do use that kind of handling though. Just a thoroughly refined version
15:59:09 <gnuvince_> What's the link to that great post?
15:59:13 <crutcher> oh, oh crap. I'm an idiot.
15:59:18 <ddarius> Either let's you combine them seamlessly.
15:59:25 <ddarius> crutcher: Happens
15:59:59 <oerjan> crutcher: try deleteBy
16:00:11 <Philippa_> I don't think I'll consider it seamless until you can change monads and error types seamlessly too
16:00:25 <Philippa_> the latter requires a significantly generalised version of catch
16:00:28 <SamB> Philippa_: yeah
16:00:30 <oerjan> or wait
16:00:35 <SamB> quite thoroughly
16:00:47 <Philippa_> SamB: was it you I got into an argument with about that way back when?
16:01:11 <SamB> I don't know
16:01:22 <Philippa_> you'd probably remember, it was a lengthy one and got fairly heated
16:01:24 <SamB> but I just think tagged unions are much cooler than numerical error codes
16:01:32 <oerjan> that's not right either
16:02:06 <Philippa_> ddarius: pretty much everyone is going to come in with prejudices about how things're done, FWIW
16:02:49 <SamB> dons: can you convert the JHC repo too?
16:02:56 <hpaste>  mux pasted "traverseSeq" at http://hpaste.org/5711
16:03:02 <mux> I've been thinking about using the Traversable class to have some sort of a deepSeq function and this is what I came up with
16:03:18 <mux> the Monad instance is pretty much useless, I could have just defined the Functor
16:03:25 <lurgee> Number codes for signifying program are inevitable.  A simple haskell web server might have data types like R404.
16:03:29 <vincenz> Philippa_: what was the email today ?
16:03:31 <vincenz> Philippa_: on -cacef
16:03:44 <mux> could I have done this a better/simpler way?
16:04:02 * Philippa_ should probably have a go at speccing out that generalised catch properly sometime - on the grounds my motivation sucks, anyone fancy grabbing a laptop and a couple of seats in a pub or something to bash it out together? I'm wondering if I shouldn't prod JaffaCake about it, for that matter
16:04:16 <ddarius> Philippa_: "should" versus "are"
16:04:32 <Philippa_> vincenz: Alan Carter on "help! HTH do I do error handling scalably!"
16:04:51 <Philippa_> for my money, if you want static typing we still have a scalability issue btw and will have until we have good enough polymorphic variants
16:05:03 <twanvl> mux: wouldn't something like "foldr seq" work just as well?
16:05:36 <Philippa_> ddarius: the pub approach might just lead to a typeclass and initial implementation rather than just a spec. Tonight, I fully intend to /not/ end up staying up past 5am and it's gone midnight already
16:05:58 <mux> twanvl: well this would only work for lists and not for any Traversable instance
16:06:22 <twanvl> mux: all Traversable instances are also Foldable
16:06:43 <ddarius> Philippa_: What time are you intending on going to sleep?
16:06:53 <ddarius> And should that time be now?
16:06:55 <dons> SamB: oh, good idea.
16:06:58 <mux> twanvl: ah, that makes a lot more sense then, thanks
16:07:03 <dons> SamB: what's the repo url?
16:07:32 <SamB> ah
16:07:44 <SamB> http://repetae.net/repos/jhc
16:07:46 <SamB> and
16:07:50 <dons> darcs?
16:07:54 <SamB> http://repetae.net/repos/Doc
16:07:59 <SamB> yes darcs
16:08:08 <dons> ok. i'll give it a go
16:08:26 <SamB> http://repetae.net/computer/jhc/development.shtml has instructions
16:09:26 <Philippa_> ddarius: want to be in bed by about 2am, and without my mind racing with new ideas
16:09:50 <ddarius> Philippa_: 12:10 or 1:10 now?
16:09:54 <Philippa_> thankfully this is thus far an old one - I can probably dig up the logs from last time it got bashed out in here with a little work
16:10:18 <Philippa_> 12:10, so there's a couple of hours - but if I start doing much then the "mind racing" clause comes into play unfortunately
16:10:38 <Philippa_> I guess I can take a first pass at a type signature
16:12:11 <crutcher> thanks again.
16:14:26 <inimino> what language would you recommend to a beginning programmer today?
16:14:49 <siti> :S
16:15:01 <inimino> someone without much experience who wants to see results and maybe write some GUI programs
16:15:26 <qwr> inimino: drscheme?
16:16:33 <qwr> maybe there is some newbie-friendly haskell ides too...
16:16:40 <qwr> s/is/are/
16:16:52 <faxathisia> inimino: Logo
16:17:49 <inimino> qwr: can you create standalone GUI programs easily from DrScheme?
16:17:51 <Cale> I feel pretty safe recommending Haskell :)
16:18:09 <inimino> Cale: I don't think Haskell is necessarily a very good first language ;-)
16:18:17 <monochrom> Apple ][
16:18:24 <qwr> inimino: don't know, if you mean exe. you didn't mention it before ;)
16:18:36 <Cale> inimino: It works quite well in many places.
16:18:45 <faxathisia> Maybe if haskell is your first language...
16:18:46 <faxathisia> in a h
16:18:50 <faxathisia> in a coupse
16:18:52 <Cale> inimino: It's a whole lot easier for people who have never written in an imperative language.
16:19:04 <Cale> I helped teach Haskell to 11 year old kids, and it was quite fun.
16:19:09 <inimino> qwr: I'm specifically looking for something that would satisfy a guy who's in danger of learning C++ and MFC because he kind of believes some of the MS propaganda ;-)
16:19:11 * faxathisia (gives up. can't use laptop keyboard)
16:19:36 * monochrom hands faxathisia a mind probe for skipping keyboard
16:19:38 <Cale> If people say that monads are hard, well, they can talk to those 11 year old kids. :)
16:19:40 <inimino> Cale: that's interesting, maybe I should consider that
16:19:42 <inimino> hehe
16:19:52 <qwr> inimino: about haskell teaching... http://www.informatik.uni-kiel.de/~mh/publications/reports/fdpe02/papers/paper15.ps.gz
16:19:57 <faxathisia> Cale, how did that go? (what did they end up doing?)
16:19:58 <Philippa_> Cale: I have this suspicion I may end up teaching someone a little haskell on a date sometime soon, which is possibly even scarier
16:19:59 <faxathisia> thanks monoochrom :P
16:20:07 <faxathisia> monochrom*
16:20:11 <qwr> inimino: F# then?
16:20:20 <monochrom> Don't worry about typos :)
16:20:23 <Cale> faxathisia: Well, they went through Haskell Road
16:20:43 <Cale> faxathisia: I gave some tutorials on how to do IO and what monads were about.
16:20:43 <monochrom> "The Haskell Road to Adulthood"? :)
16:20:54 <Philippa_> inimino: the MS propaganda would tell you to avoid MFC and use .net these days, no?
16:20:58 <Cale> and generally helped with questions they had
16:21:17 <Cale> (I was working on another Haskell project in the same room as the kids in this experimental course)
16:21:49 <inimino> Philippa_: yes, but he doesn't want to use .Net
16:22:11 <monochrom> Anyway, kids are strong in learning, can learn anything that has examples.  Never say "hard to learn for kids" just because hard to learn for 30yos.  Remember that most 30yos are actually the weak ones.
16:22:33 <faxathisia> hmmm want to read this haskell road book
16:22:35 <inimino> monochrom: true :-)
16:22:47 <inimino> monochrom: though C++ was hard for me to learn and I was a kid...
16:23:13 <Cale> C++ is a lot more complicated than Haskell, I think.
16:23:16 <Philippa_> C++ is a PITA
16:23:25 <monochrom> It also has to do with teaching skill. You can make a big success or screw up badly by varying your teaching skill.
16:23:28 <Philippa_> and it makes you do huge amounts of makework in a GUI context
16:23:34 <mauke> C++ is one of the most complex languages I know
16:23:40 <mauke> beats Perl singlehandedly
16:24:22 <chrizel> is there any standard function which shortens "if d > 0 then Just d else Nothing" to something like "foobar (>0) d" ?
16:24:38 <SamB> I have an 130 page book that covers virtually nothing but the syntax of C++
16:24:48 <monochrom> The important thing to remember for teaching kids is they learn best by carefully planned road map of examples for successively building up the abstract concept.
16:25:26 <monochrom> Don't talk abstractly or conceptually too much.  Throw lots of examples, practices, ...  to illustrate the concept.
16:25:41 <dibblego> > let foobar f x = if f x then return x else mzero in foobar (>0) 7
16:25:43 <SamB> also playing with it
16:25:44 <lambdabot42>   add an instance declaration for (Show (m a))
16:25:53 <monochrom> For example, never say "a monad is ....".
16:26:16 <SamB> say "Maybe is a Monad"
16:26:20 <SamB> "IO is a Monad"
16:26:26 <monochrom> For example, never say "a number is ...."  But this is obvious, none of us learned numbers by having teachers discuss "a number is ..."
16:26:29 <SamB> "Either is a Monad"
16:26:38 <qwr> inimino: ocaml is also able to compile native exes, and lablgtk code didn't look too bad... although gtk probably looks funny on windows. on the other hand... haskell probably is at least as good for win gui programming.
16:26:50 <monochrom> (So I don't see why it is not obvious to most people that "a monad is ..." is just as futile.)
16:27:15 <dibblego> "Either is a Monad" is both wrong and confusing for noobs in my observations
16:27:16 <ddarius> chrizel: guard
16:27:29 <SamB> well, personally I decided that "A monad is ..." is futile when I decided to stop trying to figure out what to put instead of "..."
16:27:35 <ddarius> > let d = 3 in guard (d>0)
16:27:37 <lambdabot42>   add an instance declaration for (Show (m ()))
16:27:39 <sorear> chrizel: no, but it's been proposed senveral times
16:27:55 <ddarius> Almost, need guard (d > 0) >> return d
16:28:08 <sorear> @go site:hackage.haskell.org boolToMaybe
16:28:09 <lambdabot42> No Result Found.
16:28:10 <chrizel> ok, thanks
16:29:33 <qwr> inimino: hmm. http://www.py2exe.org/ looks also interesting...
16:29:49 <Philippa_> monochrom: mostly that sooner or later you have to see the class definition too
16:31:06 <radetsky> is there a predefined way to convert a WordN to a list of Word8s?
16:31:23 <inimino> qwr: that is interesting
16:32:43 <inimino> Maybe I'll suggest Python or Scheme...
16:32:50 <faxathisia> inimino, no...
16:33:17 <inimino> faxathisia: you don't think Python or Scheme are still good first languages?
16:33:18 <SamB> dons: I still love that VisualBoyAdvance use is apparantly highly correlated with HUGS use... too bad it's now listed as more heavily correlated with ZSNES use from their end...
16:33:19 <dons> radetsky: map fromIntegral
16:33:24 <Mortomes> \o/ python
16:33:49 <faxathisia> inimino, scheme is good, I'd suggest logo, prolog and (scheme or pascal or java) though
16:33:59 <inimino> ok
16:34:24 <ddarius> Scheme seems to have the most available introductory resources and environments while simultaneously not being a crappy language.
16:34:26 <shteou> SamB, where says that? :o
16:34:44 <radetsky> thanks
16:34:45 <SamB> http://www.ohloh.net/projects/4078?p=HUGS
16:34:48 <inimino> ddarius: right, from being used in education so long, Scheme seems to have a lot going for it
16:35:13 <shteou> hehe, that tickles me
16:35:24 <faxathisia> scheme also has a logical foundation .. python is totally adhoc
16:35:43 <faxathisia> no idea what you'd be telling someone by showing them programming in that
16:35:45 <inimino> Python was less adhoc when it started out than it is now
16:35:56 <cjb> wow, you guys really hate python.
16:36:03 <lispy> what is the purpose of ohloh?
16:36:05 <inimino> I think if you ignored the later OO stuff you'd be fine
16:36:13 * cjb is working to bring python as an introductory programing language to millions of kids who haven't seen computers before.
16:36:14 <lispy> the just take user reviews of programs?
16:36:17 <shteou> I'm growing to like python.
16:36:25 <lispy> cjb: olpc?
16:36:26 <inimino> cjb: OLPC?
16:36:28 <shteou> Mostly because there's a python interpreter for my mobilephone though :/
16:36:28 <cjb> indeed.
16:36:29 <inimino> heh
16:36:38 <SamB> lispy: also does source metrics if they support the VCS used
16:36:38 <BMeph> > (\x -> guard (x > 0) >> Just x) 7
16:36:41 <lambdabot42>  Just 7
16:37:01 <radetsky> dons: wait, are you sure about that?
16:37:37 <SamB> http://www.ohloh.net/accounts/6511
16:37:49 <radetsky> WordN is not a list
16:37:53 <radetsky> how do you map onto it?
16:38:58 <dons> oh, you wanted to extract the bytes from a WordN of some kind?
16:39:03 <dons> use Data.Bits to shift it out.
16:39:10 <dons> its a one line unfoldr :)
16:39:36 <radetsky> ok
16:39:48 <radetsky> what I'm doing is probably a very bad idea
16:40:06 <oerjan> @pl \p x -> guard (p x) >> Just x
16:40:07 <lambdabot42> (`ap` Just) . (((>>) . guard) .)
16:40:14 <radetsky> i.e. replacing the FFI-based sha1 in Conjure with the hackage Crypto
16:41:05 <radetsky> but a pack/unpack seems marginally better than a whole mess of unsafe's
16:41:20 <radetsky> at least to just get it working
16:41:54 <radetsky> (they say every time you perform premature optimization, god kills a kitten)
16:42:06 <SamB> what premature optimization?
16:42:45 <radetsky> using unsafe's to get a performance boost
16:43:03 <radetsky> it'd be fine if it worked, but it doesn't
16:43:05 <SamB> was that the reason?
16:43:10 <SamB> oh. it doesn't work?
16:43:13 <SamB> carry on, then.
16:43:53 <radetsky> yeah, the idea was that I don't know how that stuff works exactly, so I can't prove that the way I was going to fix it would keep it safe
16:44:07 <radetsky> so I'm just going to use Data.Digest.SHA1 to get it working
16:44:19 <radetsky> and put the FFI back in when it's clear that I need the added performance
16:47:39 <mjf> Hello.
16:48:01 <mjf> How can I obtain a datetime (like `date' output) in a variable?
16:48:26 <oerjan> @hoogle date
16:48:27 <lambdabot42> System.Locale.dateTimeFmt :: TimeLocale -> String
16:48:27 <lambdabot42> System.Locale.dateFmt :: TimeLocale -> String
16:48:27 <lambdabot42> Data.Time.Calendar.OrdinalDate :: module
16:48:47 <mauke> @hoogle formatCalendarTime
16:48:47 <lambdabot42> System.Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
16:48:52 <dons> getClockTime >>= toCalendarTime
16:49:24 <TomMD> Will the old-time package ever die?
16:49:30 <dons> slowly
16:49:42 <TomMD> And the 'time' package works fine on Windows?
16:49:45 <Stavros> hello
16:49:46 <dons> but 'time' is a pretty hair beast.
16:49:50 <mauke> which one is the old one?
16:49:51 <TomMD> I saw
16:49:51 <dons> TomMD: afaik.
16:49:53 <oerjan> TomMD: Time is defined in haskell 98
16:49:57 <dons> hey Stavros
16:49:58 <ddarius> We should do away with time.
16:50:10 <oerjan> so some of it will always be kept
16:50:16 <mrd> let us travel at the speed of light
16:50:17 <Stavros> i'd like to try out haskell and i come from python, is there something conciseish i can read?
16:50:19 <TomMD> Well, I am just trying to determine which time package Control.Event should ultimately use.
16:50:47 <TomMD> It uses old-time right now, 'time' is probably going to be the new package, but it is big and ugly.
16:51:12 <ddarius> Stavros: There are a lot of concise things that you could read.
16:51:27 <Stavros> ddarius: such as?
16:52:00 <ddarius> Stavros: Here's a tutorial on selecting a tutorial: http://www.haskell.org/haskellwiki/Meta-tutorial
16:52:11 <Stavros> ah, thanks
16:52:41 <Stavros> also is there a graphics manipulation library?
16:53:03 <ddarius> There are several.  What kind of thing do you want?
16:53:23 <Stavros> i'd like to do some pixel-by-pixel manipulation of an image
16:53:24 <ddarius> http://www.haskell.org/haskellwiki/Tutorials is a fairly comprehensive list of available tutorials
16:53:28 <Stavros> a jpeg, in particular
16:53:47 <Stavros> odd, i parted
16:53:50 <Mr_Awesome> <shachaf> Mr_Awesome: You don't think a function that can fail should have a different type from one that can't?  <-- in theory it's a great idea, but in practice it requires a complete rewrite to do the same thing if youre using a function with a monadic result. it would be nice if this werent necessary
16:53:52 <ddarius> @hackage
16:53:52 <lambdabot42> http://hackage.haskell.org
16:54:13 <ddarius> Hackage is the best first stop to look for libraries for Haskell.
16:54:29 <Stavros> aha
16:54:37 <Stavros> which is the de facto one, like PIL is for python?
16:55:09 <Philippa_> Mr_Awesome: it depends somewhat on the monad in question, and in practice if you're writing anything complicated you're going to spend an awful lot of time in one monad or another
16:55:25 <SamB> Philippa_: possibly both!
16:56:13 <ddarius> Stavros: There isn't currently a "standard" library to use to read in/write out specific graphics formats.
16:56:29 <Stavros> hmm, which one do you prefer?
16:57:11 <Mr_Awesome> Philippa_: so you think its worth the trouble?
16:57:19 <Philippa_> Mr_Awesome: very much so, yes
16:57:23 <SamB> currently we're at the stage where I dump images in pnm format
16:57:36 <ddarius> Is Cairo not on Hackage?
16:57:51 <Philippa_> I pretty much treat error as something that shouldn't occur in any "serious" program
16:58:05 <allbery_b> cairo is part of gtk2hs, isn't it?
16:58:14 <Philippa_> it's barely any more polite than *0 is in C++
16:58:31 <cjb> less polite; at least segfaults give you a stack trace.
16:58:42 <mauke> throw "o hi";
16:58:51 <Philippa_> well yeah, but strictly speaking *0 could make monkeys fly out of your arse
16:59:03 <allbery_b> yep, Graphics.Rendering.Cairo is part of gtk2hs
16:59:18 <cjb> Philippa_: yeah, you're right.
16:59:19 <OceanSpray> So, I want to write an IRC bot in Haskell
16:59:20 <Mr_Awesome> Philippa_: oh, you mean the function "error."  and what is this *0 of which you speak?
16:59:25 <OceanSpray> what libraries would I use?
16:59:33 <cjb> Mr_Awesome: dereferencing a null pointer == segfault.
16:59:38 <Mr_Awesome> OceanSpray: im pretty sure theres a tutorial that does just that
16:59:55 <mauke> good thing *0 doesn't compile then :-)
17:00:04 <Mr_Awesome> cjb: oh, what happened to good old exit(1)?
17:00:05 <OceanSpray> oh?
17:00:21 <ddarius> cjb: End-users don't want to see a stack trace.
17:00:31 <Philippa_> mauke: hmm, are C++ compilers allowed to do that? C is another matter
17:00:34 <Mr_Awesome> OceanSpray: yes. try searching for it, i came across it a long time ago
17:00:42 <Mr_Awesome> perhaps someone in here knows
17:00:42 <OceanSpray> found it.
17:00:48 <OceanSpray> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
17:00:50 <Philippa_> (in C++, 0 is a null pointer)
17:00:50 <OceanSpray> aye?
17:00:55 <Mr_Awesome> thats the one
17:01:01 <OceanSpray> kthnx
17:01:03 <mauke> Philippa_: no, it's a null pointer constant
17:01:21 <cjb> ddarius: I think the analogy is fine.
17:01:26 <mauke> the real problem is that *0 doesn't have a type :-)
17:01:32 <Philippa_> mauke: literal, no?
17:01:45 <Philippa_> ah, okay, I can see how C++'d get confused by that
17:01:58 <Philippa_> int *foo = 0; *foo; OTOH...
17:02:03 <cjb> printing an error and then dereferencing a NULL pointer isn't "showing the user a stack trace"; it's quitting, and allowing the user to obtain a core file if they want one, and if the user knows how to upload that core file to the program developers, the problem can likely be fixed.
17:02:03 <mauke> yes, that's "fine"
17:02:26 <cjb> so, I'd say that printing an error and then segfaulting is more helpful than error "foo".
17:06:01 <lispy> it's too bad C++/Java/C/et al, don't have a maybe type
17:06:30 <faxathisia> public class Maybe {
17:06:41 <mrd> Maybe<T>
17:06:58 <SamB> Nothing -> Maybe<T>()?
17:07:11 <SamB> Just x -> Maybe<T>(x)?
17:07:39 <mauke> http://www.boost.org/libs/optional/doc/optional.html
17:07:42 <dibblego> "you cannot read a file line by line without writing an
17:07:42 <dibblego> exception handler" -- isn't that just \n -> liftM lines (readFile n)
17:07:43 <lispy> SamB: i'd be happy if it were a language primitive type that "just worked" and they didn't bother with the generics
17:07:48 <qwr> OceanSpray: http://linux.ee/~mzz/hirc/
17:08:04 <lispy> SamB: instead we have NULL
17:08:23 <SamB> in Java???
17:08:55 <dibblego> Java is deprecated
17:09:00 <siti> lol
17:09:04 <SamB> what do we use now?
17:09:05 <SamB> Jawa?
17:09:11 <mauke> Java2k
17:09:30 <dibblego> Scala is just Java fixed quite a lot
17:09:34 <lispy> oh noes, the haskell social network bot is down
17:09:48 <SamB> the what now?
17:10:48 <lispy> SamB: http://files.codersbase.com/haskell/haskell-current.png
17:11:00 <lispy> SamB: it's boring at the moment, I had to restart it
17:11:07 <lispy> it wasn't generating images
17:11:16 <Japsu> bah
17:11:17 <Japsu> piespy
17:11:19 <lispy> the last one had been generated on the 13th
17:11:20 <Japsu> so 2006
17:11:41 <Japsu> we need one that's written in haskell and understands context
17:11:46 <SamB> why can't it persist?
17:11:49 <SamB> write a better one
17:12:05 <lispy> SamB: it can save/restore it I haven't learned how to use that yet
17:12:29 <lispy> rewritting it in lambdabot (or as a log processor) would be almost trivial
17:12:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5713
17:12:50 <Japsu> yeah, just a fold over the lazy list of irc messages...
17:12:51 <Japsu> :P
17:12:52 <lispy> the java code that it's written in is very clear and easy to understand.  And the concepts are all explained in a paper, plus it's very few lines of code
17:13:12 <lispy> I was quite impressed by the source code of it
17:13:29 <lispy> but, i'd rather get my projects into hackage and fix lambdaweb if i'm going to spend time on hobby stuff
17:13:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5714
17:15:09 <oerjan> @users
17:15:10 <lambdabot42> Maximum users seen in #haskell: 461, currently: 431 (93.5%), active: 19 (4.4%)
17:16:42 <SamB> haskellsocialnet: hi!
17:16:42 <lispy> > let f x = (x [True, False], x ['a', 'b']) in f reverse
17:16:43 <lambdabot42>  Couldn't match expected type `Char' against inferred type `Bool'
17:17:28 <SamB> lispy: you need to be explicit about higher-order polymorphism
17:17:58 <lispy> > let f (x :: a -> a) = (x [True, False], x ['a', 'b']) in f reverse
17:17:59 <lambdabot42>  Parse error in pattern at "in" (column 55)
17:19:01 <oerjan> lispy: > doesn't support it
17:19:05 <lispy> All this time I thought Haskell was HM type checked, but it's DM type checked?
17:19:36 * oerjan is not quite sure what Damas added to HM
17:20:08 <ddarius> Polymorphic recursion
17:20:18 <mauke> DHM - dihydrogen monoxide
17:20:32 <SamB> lispy: try with a seperate type signature just to be sure...
17:20:37 <lispy> > let f :: (forall a. [a] -> [a]) -> ([Bool], [Char]); f x = (x [True, False], x ['a', 'b']) in f reverse
17:20:37 <lambdabot42>  Parse error at "." (column 19)
17:20:39 <shachaf> mauke: DHMO, no?
17:20:41 <monochrom> I'm 70% DHM.
17:20:43 <oerjan> mauke: get away! it's poisonous!
17:20:44 <SamB> the pattern signatures are a seperate extension
17:21:19 <lispy> > let f :: ([a] -> [a]) -> ([Bool], [Char]); f x = (x [True, False], x ['a', 'b']) in f reverse
17:21:20 <lambdabot42>  Couldn't match expected type `Bool' against inferred type `Char'
17:21:38 <lispy> I think that forall a. was necessary
17:21:48 <lispy> Well, I know it is.
17:21:49 <mauke> DHMO ... damas hindley milner oleg?!
17:21:53 <lispy> heh
17:22:18 <shachaf> @quote OlegFacts surname
17:22:18 <lambdabot42> No quotes match. Maybe if you used more than just two fingers...
17:22:23 <oerjan> lispy: it is.  but higher rank types are an extension and lambdabot has nearly no extensions enabled
17:22:29 <monochrom> Who is Damas again?
17:23:44 <SamB> dons: how goes the mirroring?
17:24:02 <Cale> monochrom: Presumably one of the guys who the Damas-Milner type system is named for?
17:24:04 <lispy> What is the difference between higher rank and higher kind?  Kind refers to how many types a type constructor takes as parameters and rank corresponds to nesting type quantifiers?
17:24:16 <Cale> lispy: exactly.
17:24:34 <lispy> Thanks.
17:24:41 <SamB> dons: also, what happened to http://www.cse.unsw.edu.au/icons/ ?
17:24:56 <Cale> Higher-kind tends to refer to type constructors which take type constructors as parameters.
17:25:21 <Cale> SamB: BALEETED!
17:26:01 <SamB> dons: it makes your directory listings look terrible!
17:27:22 * SamB emails the webmistress
17:27:43 <radetsky> what does "offset" refer to the in the constructor for ByteString?
17:28:05 <SamB> radetsky: the distance into the block of memory at which the string begins
17:31:33 <radetsky> SamB: any idea how I might find that out?
17:31:39 <lispy> ah, it's too bad the authors used (>>=) instead of do-notation in this paper.  I can only assume it is so they explain less to the audience.
17:31:41 <radetsky> the distance, that is
17:32:14 <SamB> radetsky: what do you want to use the constructor for?
17:33:07 <radetsky> I'm calling fromForeignPtr, which apparently just calls the constructor
17:33:35 <SamB> well, where did you get the pointer?
17:34:14 * dolio finally finishes the last agda vector exercise.
17:35:05 <radetsky> mallocBytes & castPtr
17:35:47 <faxathisia> dolio, thoughts?
17:36:03 <SamB> radetsky: why ?
17:36:22 <dolio> faxathisia: It took me forever to figure out tabulate, but then when I did, it was simple.
17:36:22 <SamB> why didn't you use a more normal way to build a bytestring?
17:36:33 <dolio> faxathisia: I wasn't thinking inductively for some reason.
17:36:37 <radetsky> SamB: I didn't write this code, I'm just trying to fix it
17:37:02 <monochrom> Best way to fix may be to rewrite.
17:37:10 <faxathisia> dolio, yeah, I found those ones really tricky. It's incredibly neat though
17:37:20 <vagif> Hello, where can i find any tutorial on TVars ? I'm specificly intrested working with Map (dictionary) in multithreaded environment.
17:37:50 <faxathisia> the way it typechecks is really clever though.. I don't know how fully it works
17:37:52 <mauke> they're just mutable variables in STM
17:38:57 <vagif> mauke: ? I know, but how do you access them ? Do you have to pass them into each and every function ? Are there such a thing in haskell as global variables ?
17:39:05 <monochrom> I am not sure if there is a better way than: acquire lock, change the Map, release lock.
17:39:09 <mauke> vagif: not really
17:39:14 <gwern> @tell lispy I sent dons a patch to get GOA to compile with 6.8.2, and I've done a test upload of GOA to hackage, here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/goa-3.0
17:39:14 <lambdabot42> Consider it noted.
17:39:19 <dolio> faxathisia: The way fsuc is written is key, I think. I thought it would be a problem to get all the elements in the same Fin n, but that fsuc works perfectly.
17:39:21 <gwern> @version lambdabot42
17:39:21 <lambdabot42> lambdabot 4p584, GHC 6.8.2 (FreeBSD i386)
17:39:21 <lambdabot42> darcs get http://code.haskell.org/lambdabot
17:39:32 <lispy> gwern: cool
17:39:32 <lambdabot42> lispy: You have 1 new message. '/msg lambdabot42 @messages' to read it.
17:39:34 <gwern> who's hosting this lambdabot42
17:39:37 <mauke> vagif: you can use Reader to pass stuff around implicitly
17:39:54 <ddarius> monochrom: If you were implementing the Map, you could use a finer granularity.
17:40:05 <vagif> mauke: cool. thx, i'll check what the heck is a Reader.
17:40:05 <monochrom> Yes absolutely. But suppose not?
17:40:08 <gwern> lispy: ...where you just watching the screen and not saying anything?
17:40:18 <lispy> gwern: yeah, were you talking to me?
17:40:33 <gwern> no, not really - just didn't see anything
17:40:41 <lispy> gwern: i'm reading a paper and following some but not all of the chat threads
17:40:44 * faxathisia agrees, also having lemmas as extremly simple terms but carefully written types is a very useful technique
17:40:45 <mauke> vagif: http://www.haskell.org/all_about_monads/html/readermonad.html
17:40:46 <ddarius> monochrom: Then there is probably still benefit to using STM.
17:40:48 <gwern> oh
17:41:32 <gwern> hm. atheists really seem to like haskell
17:41:40 <gwern> means I'm in good company!
17:41:59 <vagif> mauke: Thanks a lot!
17:42:26 <idnar> atheists, what?
17:42:33 <Cale> hehe
17:42:40 <faxathisia> dolio, so in Agda 2 you prove things by actually writing lambda terms.. as opposed to like Isabelle or Coq where you use tactics. Where does is Epigram in that?
17:42:42 <ddarius> gwern: That's not quite what the "cooked" results say (without doing a lot of comparing).  Also, I suspect some significant selection bias.
17:42:48 <gwern> idnar: http://www.kimsal.com/reldevsurvey/results.php?action=byReligion&religion=1#langbyrel
17:42:50 <faxathisia> where does it fit*
17:42:51 <radetsky> idnar: when god gives you segfaults, you find a new god
17:42:57 <idnar> gwern: ah
17:43:13 <gwern> ddarius: atheists more likely to respond?
17:43:50 <dolio> faxathisia: I'm not really sure. It's been a while since I looked at it very hard.
17:44:12 <ddarius> In wherever it is they asked, quite possibly.  I didn't hear about this survey until today so I'm wondering who they surveyed.
17:44:23 <gwern> http://www.kimsal.com/reldevsurvey/results.php?action=byReligion&religion=51#langbyrel <-- haa ha. it's a very small sample, but I still find ruby and php being the language of choice for scientologists amusing
17:44:26 <Cale> http://www.kimsal.com/reldevsurvey/results.php?action=byLanguage&language=19#relbylang
17:44:51 <Cale> Over half of the responding Haskell users were atheists.
17:44:53 <ddarius> gwern: Also the ratios not the absolute numbers nede to be reported.
17:45:18 <faxathisia> dolio, did you see the proof that filtering gives a subset?
17:45:24 <faxathisia> (in Agda 2)
17:45:53 <ddarius> Cale: 2500 out of 3800+ people responded as either Atheist or Agnostic.
17:45:53 <gwern> 'functionalprogrammin' <-- what is this religion you speak of? tell me more
17:45:53 <faxathisia> I think it's quite amazing that it typechecks..
17:45:55 <dibblego> @pl \n c -> take n $ repeat c
17:45:55 <lambdabot42> (. repeat) . take
17:46:12 <dibblego> @pl \c n -> take n $ repeat c
17:46:12 <lambdabot42> flip take . repeat
17:46:29 <lispy> why is (forall a. a -> a) -> Int different in rank than, Int -> (forall a. a -> a) ?
17:46:52 <monochrom> The religion of functionalprogrammin believes that the universe is created with no mutable state. :)
17:46:53 <ddarius> Because the latter is equivalent to forall a. Int -> a -> a
17:47:18 <gwern> monochrom: destructive updates are the original sin?
17:47:38 <monochrom> This religion doesn't define sin.
17:47:39 <gwern> 'Come, eat of the tree of destructive updates, and you shall be as the OS'
17:48:00 <monochrom> It only defines purity and impurity. Destructive update is impure.
17:48:13 <gwern> how manichaen
17:48:15 <lispy> I thought the original sin had to do with ratios of triangles
17:48:23 <lispy> Oh, maybe that's sine
17:48:32 <monochrom> haha
17:49:04 <lispy> ddarius: okay, is that because we allow partial application?
17:49:04 <Cale> Or was it something to do with y-coordinates of points on a circle?
17:49:10 <SamB> thetan++?
17:49:13 <SamB> what the heck?
17:49:35 <Cale> SamB: what?
17:49:40 <Cale> @karma thetan
17:49:40 <lambdabot42> thetan has a karma of 0
17:49:53 <ddarius> lispy: No, it's because -> is continuous in it's second argument.  It's just one of the rules of logic that B -> forall a.C <=> forall a.B -> C
17:49:53 <monochrom> Impurity is defined to mean purity compromised.  Destructive update is comprised parameter passing.
17:49:54 <gwern> @karma xenu
17:49:54 <lambdabot42> xenu has a karma of 0
17:49:58 <gwern> xenu++
17:49:59 <SamB> Cale: one of the scientologists claimed to use thetan++
17:50:05 <Cale> haha
17:50:07 <monochrom> s/comprised/compromised/
17:50:33 <SamB> four practicioners of Functionalprogrammin?
17:51:48 <SamB> 01/27/2008 08:05:02 AM	89.242.xxx.xxx	GB	Scientologist	BASIC,Visual Basic,thetan++
17:52:06 <dolio> faxathisia: Was that one of the exercises, or something else?
17:52:07 <Cale> SamB: Thetan just means soul in scientology-speak.
17:53:00 <Cale> It's equally nonsensical :)
17:53:14 <gwern> like the Invisible Pink Unicorn
17:53:17 <faxathisia> It's in UTF-8
17:53:18 <faxathisia> http://www.cs.chalmers.se/~ulfn/darcs/Agda2/examples/SummerSchool07/Lecture/Filter.agda
17:53:19 <gwern> (pbh)
17:53:26 <lispy> flying spaghetti monstor
17:53:31 <faxathisia> Proof by writing structurally similar programs :S
17:53:51 <Cale> What's the FSMism version of the soul?
17:54:06 <faxathisia> I spent a while trying to understand the haskell source (for typechecking) but it is very complicated
17:54:39 <gwern> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/src/Distribution-PackageDescription.html#GenericPackageDescription <-- oh nice, when did haskell.org get syntax highlighting?
17:54:55 <lispy> Cale: I like that FSM could also mean finite state machine
17:55:24 <monochrom> Functorial State Monad
17:55:33 <lispy> Cale: to which I would refer you to Connway's game of life :)
17:56:25 <lispy> I don't think @messages works correctly with lambdabot42.  Is lambdabot42 allowed to send /msgs?
17:56:43 <oerjan> gwern: the source links changed format with 6.8
17:57:27 <oerjan> lispy: not registered
17:58:55 <lispy> ?messages
17:58:56 <lambdabot42> You don't have any new messages.
17:59:15 <lispy> lambdabot42: yeh, because you lost them to the ether...thankfully i was here to see them
17:59:21 <faxathisia> 42?
17:59:25 <faxathisia> what's this about
17:59:40 <gwern> 42 is always the answer
17:59:40 <lispy> I think the real vixen needs to be restarted
17:59:42 <Cale> I wonder what happened to lambdabot
17:59:46 <Cale> I'll bring it back up.
18:00:05 <SamB> so, is dons waiting again?
18:00:15 <faxathisia> @vixen why is 42 significant?
18:00:15 <lambdabot42> oh, that's really old
18:00:27 <Cale> There you go.
18:00:38 <idnar> @bot
18:00:39 <lambdabot42> :)
18:00:39 <Cale> lambdabot42: @part #haskell
18:00:39 <lambdabot42> Not enough privileges
18:00:42 <oerjan> @vixen what about 41 then?
18:00:43 <lambdabot42> i dunno, what about?
18:00:45 <lambdabot> :)
18:00:51 <lambdabot> i dunno, what about?
18:00:55 <lispy> It's really interesting that one of the features tuted about Haskell is that type annotations are optional, but good programming style practically dictates they be included.
18:01:00 <oerjan> @vixen why is 41 significant?
18:01:01 <lambdabot42> oh, that's really old
18:01:05 <lambdabot> oh, that's really old
18:01:07 <Cale> lispy: But not all of them.
18:01:17 <idnar> lispy: well, mostly only for top-level definitions
18:01:21 <dolio> faxathisia: Agda's operator definitions frequently blow me away.
18:01:32 <lispy> Cale: but, do you omit so many as to be genuiely saving effort or lines of code?
18:01:37 <Cale> Yes.
18:01:47 <TomMD> @tell lambdabot42 @vixen how about the number ln(42)?
18:01:47 <lambdabot> Consider it noted.
18:01:48 <lambdabot42> Nice try ;)
18:01:48 <lambdabot> lambdabot42: You have 1 new message. '/msg lambdabot @messages' to read it.
18:01:52 <Cale> actually, for many programs, I leave them out altogether.
18:01:53 <gwern> lispy: it helps make it more flexible and closer to lisp in terms of ease of exploration; jam down the code, and then later polish it with explicit types
18:02:11 <Cale> I'll include them in a release version of something, but usually not when I'm just working on it.
18:02:14 <davidL> @vixen-on
18:02:15 <lambdabot> Not enough privileges
18:02:15 <lambdabot42> Not enough privileges
18:02:18 <faxathisia> lispy, :S
18:02:18 <faxathisia> lispy, I almost never have type annotations.. well sometimes but only when the type describes the function better that the term
18:02:19 <lispy> I'm working with a lot of rank2 and higher functions lately, which means I have to give all my signatures, and I'm finding maybe 1/20 functions (including where blocks) that don't already have an explicit type
18:02:20 <faxathisia> In general .. I don't annotate types, why would you?
18:02:38 <Cale> faxathisia: Better type error messages, better guarantees.
18:02:43 <idnar> in Java, you might need to write something like int foo() { FooFactory ff = getFooFactory(); Foo f = ff.makeFoo(); Bar b = f.getBar(); }
18:02:59 <ddarius> lispy: You don't need to give every parameter and local variable and local function a type.
18:03:02 <lispy> When I was learning haskell I was told to write down the types, then figure out the functions.
18:03:11 <dolio> faxathisia: That is a nice proof.
18:03:19 <gwern> that's also a good way to go; be clear about what you want from the start
18:03:20 <Cale> lispy: Right, but you don't necessarily have to write them down :)
18:03:27 <gwern> doesn't always work, though
18:03:30 <SamB> it works well for toplevel variable bindings
18:03:31 <Cale> lispy: It's good for beginners to do it though.
18:03:39 <idnar> in Haskell, you'd maybe have: foo :: int \n foo = let ff = whatever; f = makeFoo ff; b = getBar f in ...
18:03:48 <ddarius> For things I'm less sure about, I often use a "type-directed" approach.
18:03:52 <Cale> lispy: Since they need to learn that aspect of the language, and they get better error messages then.
18:03:59 <SamB> when you can figure out what the actual types will be
18:04:13 <dolio> faxathisia: That might help me with the Some and All list exercises, too, as I was unsure how to structure them.
18:04:22 <idnar> so for the most part, you're leaving out the type declarations where they just get in the way, but including them where they help make sense of the code
18:04:33 <kpreid> I wonder...if you could write 'foo :: Bar; foo = <@djinn>" in a Haskell program, how often would that be useful?
18:04:37 <SamB> i.e., I wouldn't suggest beginners try to write typesigs for Parsec parsers until theyv'e written the parsers
18:04:47 <lispy> idnar: Okay, that seems to jive with the notion that types can serve as machine checkable documentation.
18:04:50 <faxathisia> dolio, You lose the ability to write say (foo ++), but other than than it's excellent. Yeah a really impressive proof, it seems to be checking the structures match up to type check, not sure exactly
18:05:19 <siti> I usually don't write types, and just use ghc's type inference suggestion when compiling with -Wall
18:05:22 <idnar> I used to think that I hated static typing
18:05:33 <dolio> faxathisia: One thing I've had trouble with is figuring out what Agda2 can figure out on its own.
18:05:34 <gwern> kpreid: I'd say not very often; how often is the type so very specific djinn could write the function?
18:05:44 <Cale> idnar: Usually that comes from using piss-poor static type systems.
18:05:51 <idnar> then I discovered there were languages where static typing didn't mean wearing out your keyboard typing out a five line function ;)
18:05:57 <lispy> I do hate static typing in some languages.  But, the dynamic typing, or even worse, lack of type safety scares me more.
18:06:15 <ddarius> kpreid: Only in very polymorphic code would that be useful.
18:06:23 <idnar> I've been writing code in dynamic languages for far too long to be scared by lack of type safety, but I can certainly appreciate Haskell's type system
18:06:25 <Cale> Static typing is annoying when the types hardly say anything and there's no type inference.
18:06:37 <kpreid> ddarius: well, yeah, I was thinking of that sort of utility function
18:06:44 <faxathisia> dolio, yeah similar.. you get proof by computation in the type system, but sometimes you can't just put 'refl' down, and have to write lemma1, where lemma1 = refl but it has a detailed type
18:06:47 <lispy> idnar: usually dynamicly typed languages have type saftey, it's just at run-time instead of compile time.
18:06:53 <idnar> lispy: yeah
18:07:00 <SamB> it's surprising how often djinn sorts the most useful definition to the top
18:07:04 <siti> sounds like terrible safety to me ;)
18:07:09 <faxathisia> dolio, Also there is some really fantastic Agda code here http://www.iis.sinica.edu.tw/~scm/
18:07:10 <lambdabot> Title: Home | Niche Computing Science
18:07:18 <ddarius> SamB: It's probably not -too- surprising.
18:07:19 <SamB> siti: well, it's better than C has
18:07:23 <Cale> I can't live without a good type system.
18:07:28 <lispy> SamB: exactly
18:07:33 <SamB> siti: C has essentially no safety
18:07:50 <idnar> C's type system is almost worse than no type system
18:07:53 <dolio> faxathisia: Have you looked at the 'standard library'?
18:08:13 <lispy> What if we just took C and C++ and went over the spec, tried to leave all the semantics we can the same but add real, genuine type safety and perhaps, some inference to help check it?
18:08:25 <Cale> "Dynamically typed" is such a misnomer.
18:08:28 <Philippa_> <SamB> i.e., I wouldn't suggest beginners try to write typesigs for Parsec parsers until theyv'e written the parsers <- I just don't write them
18:08:28 <lambdabot> Philippa_: You have 1 new message. '/msg lambdabot @messages' to read it.
18:08:39 <faxathisia> I've skimmed it, looked through all the Agda 2 code I can find actually :p
18:08:39 <faxathisia> not really used it yet though
18:08:39 <idnar> lispy: I don't really think you can do that without substantially changing the nature of the language
18:08:41 <SamB> lispy: C would be no fun with type safety
18:08:53 <siti> segfaults make c fun :P
18:09:01 <SamB> Philippa_: well, I don't write my own either
18:09:06 <SamB> Philippa_: I add them later
18:09:44 <SamB> sometimes I might contract a type synonym here or there
18:09:58 <ddarius> Philippa_: Go to sleep.
18:10:12 <Cale> heh
18:10:19 <TomMD> @quote unsafe
18:10:19 <lambdabot> Pseudonym says: Or did you put in a call to unsafePierceEyeball?
18:10:19 <lambdabot42> Philippa says: plus who wants to get unsafeHead?
18:11:10 <idnar> one of the things about type inference is that you can write your function, ask ghc what its type is, and then add that to the source; then later, when you're editing the function, if you accidentally change the type, you get the error right there instead of somewhere else once the function actually gets used
18:11:33 <Cale> idnar: right
18:11:49 <lispy> true
18:11:50 <Cale> idnar: and it's incredibly useful when you're working with someone else's code
18:11:56 <lispy> But, this assumes it's rank0 or 1, right?
18:11:59 <lispy> maybe rank2?
18:12:09 <Cale> Types explain how the other person's code is meant to be used.
18:12:23 <siti> the biggest reason I started to try and type all my functions was to get haddock going.  Haddock is the best api documentation system I have ever seen :).
18:12:28 <Cale> lispy: Type inference for higher rank types is incomplete.
18:12:52 <siti> and I REALLY appreciate types when I am coding in languages like python.  Python has the worst documentation ever :(
18:13:02 <idnar> eh, is Haddock really different to any other similar system?
18:13:21 <siti> the output is so nice and easy
18:13:23 <idnar> I haven't worked with it much, but it seems pretty much the same as javadoc or epydoc or whatever
18:13:44 <TomMD> I find it much nicer than, say, dOxygen.
18:13:45 <siti> javadoc has really bloated output, I have not tried epydoc
18:13:48 * lispy wishes darcs used Haddock
18:14:04 <TomMD> It doesn't?
18:14:22 <ddarius> idnar: Haddock works with Haskell.
18:14:28 <lispy> no I've patched it to do so twice but the patches were rejected because the unstable maintainer at that time didn't like Haddock
18:14:32 <SamB> idnar: well, haddock output can be useful even if the program wasn't made for it?
18:14:42 <vininim> > let a .->. b = 0 in 1 .->. 2
18:14:43 <lispy> I should try again now that David is the unstable maintainer
18:14:45 <lambdabot42>  0
18:14:47 <SamB> but that says more about Haskell then about haddock
18:14:47 <lambdabot>  0
18:14:50 <idnar> SamB: yeah
18:15:11 <lispy> IMO, browsing haddock docs while darcs hacking would be realyl nice
18:15:45 <SamB> lispy: add a patch to the build system so that it generates haddock docs?
18:15:57 <SamB> then start moving stuff over piecemeal?
18:16:12 <idnar> anyhow, I don't think I really have any complaints about Haskell's type system vs. writing "dynamically typed" code in Python or whatever
18:16:21 <lispy> SamB: scroll up, i've done that twice in the past :)
18:16:25 <SamB> (After fixing the syntax errors)
18:16:29 <SamB> lispy: twice eh?
18:16:31 <lispy> ya
18:16:38 <SamB> sad :-(
18:16:46 <idnar> the stuff that would bother me switching from Python to Haskell is IO/side-effects-related, mainly
18:17:01 <lispy> SamB: but, david is more lax about adding in now stuff he's not personally comfortable
18:17:11 <idnar> which I suspect is mostly due to my lack of Haskell experience
18:17:17 <lispy> SamB: so I might be able to convince him it's helping me
18:17:27 <lispy> (which it would be)
18:17:50 <idnar> a couple of times now I've tried to rewrite some relatively simple code in Haskell, and ended up with a horrible mess
18:17:52 <SamB> lispy: I don't see why he'd have a problem with something as relatively inert as haddock ...
18:18:37 <lispy> SamB: I could dig up the arguments of the previous maintainer...IIRC he felt the syntax of haddock and the requirement of docs made it harder to read the code and bloated it without gain
18:19:01 * faxathisia wonders what it would take to write a mini agda
18:19:01 <SamB> ... requirement of docs?
18:19:07 <SamB> what requirement?
18:19:13 <SamB> and Haddock hasn't that much syntax
18:19:23 <lispy> SamB: yeah, I agree
18:19:28 <ddarius> @google simple dependent types augustsson
18:19:29 <lambdabot> http://citeseer.ist.psu.edu/246388.html
18:19:29 <lambdabot> Title: Cayenne - a Language With Dependent Types - Augustsson (ResearchIndex)
18:19:29 * lispy hugs haddock
18:19:30 <lambdabot42> http://citeseer.ist.psu.edu/246388.html
18:19:30 <lambdabot42> Title: Cayenne - a Language With Dependent Types - Augustsson (ResearchIndex)
18:19:30 <lambdabot> Title: Cayenne - a Language With Dependent Types - Augustsson (ResearchIndex)
18:19:42 <SamB> lispy: had he based this on actual darcs code?
18:19:45 <ddarius> Not the one I wanted.
18:20:12 <SamB> heh
18:20:23 <SamB> so... why did we end up with only 3 copies of the title?
18:20:38 <SamB> shouldn't it have been four?
18:20:44 <ddarius> SamB: It's obvious and left as an exercise to the reader.
18:20:50 <Qerub> I'm on GHC 6.6.1 and get "Could not find module `Distribution.Simple.Setup'" when running "runhaskell Setup.hs configure" for Pandoc. Isn't D.S.S a part of Cabal that is included with GHC?
18:21:14 <idnar> I guess lambdabot42 isn't catching URLs
18:21:19 <idnar> http://google.com/
18:21:20 <lambdabot> Title: Google
18:21:35 <SamB> oh
18:21:48 <SamB> I was going to say "lambdabot42 doesn't print titles for google results"
18:21:50 * gwern pities da foo using an outdated ghc
18:24:11 <Cale> Qerub: You're a version behind. Get 6.8.2 and it should work.
18:24:18 <lispy> how do you say, "predicative"
18:24:26 <lispy> pred-ic-ative?
18:24:29 <Qerub> Cale: 6.6.2 I guess? Allright, thank you.
18:24:34 <Cale> Qerub: 6.8.2
18:24:39 <lispy> pred, ick, ah-tive
18:24:42 <lispy> something like that?
18:24:45 <ddarius> lispy: I say it with a long a.
18:24:57 <ddarius> Almost
18:24:57 <Cale> Like "predicate", but with "ive"
18:24:59 <idnar> I pronounce it "preddy caytive"
18:25:15 <Cale> I say it with a short 'a'.
18:25:24 <idnar> it would be the thing Cale said, except I find that a bit awkward to pronounce
18:25:49 <Qerub> Cale: Ugh… MacPorts is really behind. Thank you again.
18:25:53 <lispy> idnar: yeah, I tihnk that's why i had to ask :)
18:26:22 <faxathisia> What are some particularly good visualisations of typechecking ?
18:26:50 <gwern> YAY! DisTract now compiles!
18:26:51 <hpaste>  idnar pasted "messy code" at http://hpaste.org/5715
18:26:59 <lispy> faxathisia: I'm not sure, but I wish ghc's type checker had an interactive mode where you could look at annotations and see how it discovers types
18:27:01 <gwern> oh the many travails I went through to acheieve this glorious feat
18:27:23 <idnar> ^^^ hauling the RandomGen around there seems to cause a lot of pain, but I couldn't figure out how to write it more cleanly
18:27:23 <gwern> from an evening gone wrangling with that abortion, monotone, to dueling type signatures and Cabal functions
18:27:44 <ddarius> @google "type debugger"
18:27:47 <lambdabot> http://www.cs.mu.oz.au/~pjs/papers/p108-stuckey.pdf
18:27:48 <lambdabot42> http://www.comp.nus.edu.sg/~sulzmann/chameleon/
18:27:48 <lambdabot42> Title: Chameleon
18:27:49 <ddarius> @google "type error slicing"
18:27:50 <lambdabot> Title: Chameleon
18:27:51 <lambdabot> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
18:27:51 <lambdabot> Title: A Type Error Slicer for MiniML
18:27:54 <lispy> gwern: you don't like monotone?
18:27:57 <lambdabot42> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
18:27:58 <lambdabot42> Title: A Type Error Slicer for MiniML
18:27:58 <lambdabot> Title: A Type Error Slicer for MiniML, http://tinyurl.com/y2g6wf
18:28:12 <lispy> gwern: it seems pretty smart, but i haven't used it much
18:28:16 <BMeph> I pronounce them "PREDicate," and "preDICative".
18:28:18 <gwern> lispy: if my experience or the manual is representative, I would have to search very very hard to find a worse DVCS
18:28:32 <gwern> at least as far as usability goes...
18:28:50 <lispy> gwern: ah, you haven't used arch or bzr :)
18:29:06 <gwern> it took me hours to figure out how to pull an actual DisTract directory out of the mtn database file it spat at me
18:29:09 <gwern> which is just ntus
18:29:25 * lispy remembers spending 4 hours trying to learn arch before giving up without ever importing real code into a repository
18:29:39 <gwern> lispy: no, I haven't. I guess I'll avoid those even more strenuously than monotone
18:30:06 <lispy> gwern: darcs and svn spoil a person
18:30:06 <idnar> I think it's pretty safe to say that there's nothing harder to use than larch/tla
18:30:34 <idnar> CVS might count, but it doesn't have enough functionality ;)
18:30:36 <gwern> lispy: then take away my toys and call me a spoiled brat!
18:31:12 * gwern will live and dieee - A PIRATE KING!
18:31:24 <gwern> er. wrong musical
18:34:15 <idnar> no takers for my code? >:)
18:34:20 <lispy> how often is impredicativity useful in practice?
18:34:24 <fxr> I banned from #lisp, what a world
18:34:36 <lispy> fxr: how did you do that?
18:34:42 <lispy> BTW, they can be cranky.
18:34:47 <ddarius> lispy: That issue with ($) and runST is caused by lack of impredicativity.
18:34:50 <fxr> lispy: I talked about cons of lisp2
18:34:57 <lispy> I stopped talking in #lisp because I felt it was a very negative place.
18:34:58 <gwern> hah. that would do it
18:35:05 <gwern> a lot of common lispers there y'know
18:35:31 <lispy> should be #sbcl not #lisp
18:35:35 <faxathisia> there is another lisp channel on the server..
18:35:52 <fxr> we're writing parser combinators with lisp2 and I'm banned from the channel, that's very amazing for me :)
18:35:58 <lispy> ddarius: hmm...
18:36:07 <lispy> what is lisp2?
18:36:26 <v0|d> fxr: #lisp - we put the ban in +b
18:36:32 <fxr> :)
18:36:52 <faxathisia> guys do you really need to talk about this here?
18:37:02 <QtPlatypus> lisp2 have diffrent namespaces for varabiles and functions.
18:37:14 <gwern> lispy: https://secure.wikimedia.org/wikipedia/en/wiki/Common_Lisp#The_function_namespace
18:37:16 <lambdabot> http://tinyurl.com/yrny7w
18:37:30 <fxr> right
18:37:42 <lispy> ah, I was aware of that, but I dunno, I guess I saw it with different notation before and thought you meant version 2 of lisp.
18:38:00 * lispy goes back to learning about polytypes
18:38:12 <gwern> actually, there is a Lisp 2
18:38:22 <gwern> which is different from Lisp-2 :)
18:38:39 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/LISP_2
18:38:56 <fxr> actually there is now arc which is even different then those
18:39:06 <bos> sorear: what do they put in the water in san diego that has you saying that hIsEOF's behaviour on ttys is wrong?
18:39:26 <fxr> bos: hhaheha :)
18:39:29 <gwern> bos: fluoride
18:39:36 <gwern> it corrupted his precious bodily fluids
18:39:55 <ddarius> What about his mundane bodily fluids?
18:41:03 <lispy> I like teh way SPJ writes papers
18:41:03 <sorear> bos: hIsEOF is broken by design - the implementation is fine
18:41:16 <gnuvince_> lispy: with Comic Sans?
18:41:53 <lispy> gnuvince_: heh, no I mean his writing style is nice in that it helps draw in the beginners
18:41:54 <bos> i don't like hIsEOF myself, but it at least behaves as i expect.
18:42:20 <Cale> gnuvince_: Since when?
18:44:18 <sorear> http://www.lysator.liu.se/c/bwk-on-pascal.html#environment
18:44:29 <Cale> gnuvince_: His papers seem to mostly be set in some variations on Times, Courier, and Computer Modern.
18:45:44 <SamB> gnuvince_: are you confused with slides?
18:48:22 <lispy> Cale: where can I learn to read the notation in Fig3 of that paper you sent me the link to?
18:48:45 <lispy> Cale: in particular, the "rule" for APP is eluding me
18:49:04 <ddarius> @where spj
18:49:04 <lambdabot> I know nothing about spj.
18:49:04 <lambdabot42> I know nothing about spj.
18:49:13 <ddarius> @google Simon Peyton Jones
18:49:14 <lambdabot> http://research.microsoft.com/~simonpj/
18:49:14 <lambdabot> Title: Simon Peyton Jones
18:49:15 <lambdabot42> http://research.microsoft.com/~simonpj/
18:49:15 <lambdabot42> Title: Simon Peyton Jones
18:49:15 <lambdabot> Title: Simon Peyton Jones
18:50:01 <lispy> Gamma |- t : tau -> rho, next line, Gamma |- u : tau, horizontal bar, Gamma |- t u : rho.  What is the relationship of the two parts above the horizontal bar?
18:50:05 <oerjan> lambdabot42: @seen lambdabot42
18:50:05 <lambdabot42> Yes, I'm here. I'm in #haskell, #not-##freebsd, #brokenarm and #yuka
18:50:26 * oerjan points out that lambdabot42 could be kicked
18:50:48 <lispy> s/could/should/ ;)
18:51:02 <gwern> @hoogle a -> a
18:51:03 <lambdabot> Prelude.id :: a -> a
18:51:03 <lambdabot> Data.Function.id :: a -> a
18:51:03 <lambdabot> GHC.Exts.breakpoint :: a -> a
18:51:04 <lambdabot42> Prelude.id :: a -> a
18:51:04 <lambdabot42> Data.Function.id :: a -> a
18:51:04 <lambdabot42> GHC.Exts.breakpoint :: a -> a
18:51:15 <gwern> hee hee. a force multipler for a dos
18:51:19 <gwern> @quote e
18:51:20 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let near a programming language.
18:51:20 <lambdabot42> qwe1234 says: you might pass for somebody intelligent when you keep your mouth shut.
18:51:28 <faxathisia> lispy: You can derive the sequent on the bottom when the stuff on the top is true
18:51:29 <ddarius> lispy: Conjunction
18:51:31 <lispy> they are both above the bar because they are both conditions that must apply for the part below the bar to be used?
18:51:47 <lispy> faxathisia, ddarius: ah conjunction.  Thanks.
18:51:47 <ddarius> lispy: Yes
18:52:05 <gwern> @quote a
18:52:06 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
18:52:06 <lambdabot42> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
18:52:24 <idnar> haha
18:52:28 <SamB> because it's full of "arr"
18:52:48 <ddarius> @arr
18:52:48 <lambdabot> Keelhaul the swabs!
18:52:48 <lambdabot42> Swab the deck!
18:53:04 * dmwit thinks... ?remember says: hey! ?remember ?quote hi! ?quote says:
18:53:32 <frivol> It's not Pirate Day again, I hope
18:53:38 <faxathisia> ?where ?foo
18:53:38 <lambdabot> I know nothing about ?foo.
18:53:38 <lambdabot42> I know nothing about ?foo.
18:53:42 <faxathisia> hmm..
18:53:55 <ddarius> What were you expecting?
18:53:56 <faxathisia> saw that cause some problem before
18:53:56 <dmwit> Oh yeah, ?where seems much easier.
18:54:08 <faxathisia> ddarius, well I daren't repeat ut
18:54:10 <lispy> I think lambdabot42 probably ignores lambdabot
18:54:19 <faxathisia> but it looped them
18:54:50 <dmwit> > var "?quote test" :: Expr
18:54:51 <lambdabot42>   Not in scope: type constructor or class `Expr'
18:54:53 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
18:54:56 <faxathisia> > fun (" foo " ++ mar chr [0x0d, 0x0a] ++ "> 1+1")
18:54:57 <lambdabot>   Not in scope: `mar'
18:54:58 <lambdabot42>   Not in scope: `mar'
18:55:01 <dmwit> > var "?quote test" :: Sym String
18:55:03 <lambdabot42>   Not in scope: type constructor or class `Sym'
18:55:04 <faxathisia> > fun (" foo " ++ map chr [0x0d, 0x0a] ++ "> 1+1")
18:55:05 <lambdabot>  Add a type signature
18:55:05 <lambdabot42>   Not in scope: `fun'
18:55:06 <lambdabot>  ?quote test
18:55:11 <lispy> ugh
18:55:16 <faxathisia> > fun (" foo " ++ map chr [0x0d, 0x0a] ++ "> 1+1") :: Expr
18:55:17 <lambdabot>   foo
18:55:17 <lambdabot> > 1+1
18:55:17 <lambdabot42>   Not in scope: type constructor or class `Expr'
18:55:19 <lambdabot42>  2
18:55:42 <faxathisia> you could do something with that alse
18:55:49 <lispy> > nub $ take 9 $ botsinchannel
18:55:50 <lambdabot>   Not in scope: `botsinchannel'
18:55:50 <lambdabot42>   Not in scope: `botsinchannel'
18:56:51 <lispy> > nubBy (\nick1 nick2 -> take 9 nick1 == take 9 nick2) #haskell  -- or this version might be more clear what I mean
18:56:52 <lambdabot>   Not in scope: `haskell'
18:56:53 <lambdabot42>   Not in scope: `haskell'
18:57:04 <oerjan> > fun (" foo " ++ map chr [0x0d, 0x0a] ++ "lambdabot42: @part #haskell") :: Expr
18:57:05 <lambdabot>   foo
18:57:05 <lambdabot> lambdabot42: @part #haskell
18:57:05 <lambdabot42> Not enough privileges
18:57:05 <lambdabot42>   Not in scope: type constructor or class `Expr'
18:57:18 <oerjan> aww :)
18:57:20 <lispy> oerjan: cute
18:57:21 <faxathisia> hehe
18:58:39 <lispy> Cale: note what oerjan just did with chr [0x0d, 0x0a] and you might want to ensure a space gets inserted at the start of the new line
18:58:42 <ddarius> > fun "foo\r\nbar" :: Expr
18:58:43 <lambdabot>  foo
18:58:43 <lambdabot> bar
18:58:43 <lambdabot42>   Not in scope: type constructor or class `Expr'
18:58:49 <lispy> Cale: to avoid exploits of lambdabot
18:58:53 <dmwit> ?let hack s = fun ("\13\10" ++ s) :: Expr
18:58:53 <lambdabot> <local>:6:9: Not in scope: `fun'  <local>:6:32: Not in scope: type constructo...
18:58:53 <lambdabot42> L.hs:5:0: parse error (possibly incorrect indentation)
18:59:05 <dmwit> rats
18:59:10 <faxathisia> yeah we had fun with that earlier
18:59:25 <lispy> > fun "foo\r\n/msg Cale I'm a naughty bot" :: Expr
18:59:26 <lambdabot>  foo
18:59:26 <lambdabot> /msg Cale I'm a naughty bot
18:59:26 <lambdabot42>   Not in scope: type constructor or class `Expr'
18:59:37 <lispy> oh, I guess the space is there?
18:59:43 <lispy> or at least it's going to the right place
18:59:51 <ddarius> No, you have to do something else to get a msg.
18:59:52 <lispy> Cale: nevermind :)
19:00:05 <dmwit> lispy: No, I just don't think sending "/msg" at the beginning gives a privmsg automatically.
19:00:06 <lispy> ddarius: oh, it could still be a problem?
19:00:08 <faxathisia> e.g. (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
19:00:12 <ddarius> lispy: It is.
19:00:21 <faxathisia> as in http://tunes.org/~nef/logs/haskell/08.02.14
19:00:26 <dmwit> faxathisia: Right, I saw that one earlier.
19:00:32 <dmwit> ?quote 5su
19:00:32 <lambdabot> No quotes match. My pet ferret can type better than you!
19:00:32 <lambdabot42> No quotes match.
19:00:35 <jcreigh> no, /msg is something that IRC clients interpret.
19:00:36 <dmwit> ?quote 3su
19:00:36 <lambdabot> faxathisia says: /msg lambdabot > fun (cycle "\3\&5de\3\&3su ") :: Expr
19:00:36 <lambdabot42> No quotes match. There are some things that I just don't know.
19:03:55 <lispy> I guess one fix is that 'fun' rejects strings which would not be valid H98 function names
19:04:11 <dmwit> Reject them how?
19:04:26 <faxathisia> It doesn't need fixed
19:04:27 <lispy> error?
19:05:27 <oerjan> @read "foo \13\10testing"
19:05:27 <lambdabot>  foo testing
19:05:28 <lambdabot42>  foo testing
19:05:31 <lispy> faxathisia: why not? doesn't the current state of affairs allow people to take arbitrary control of lambdabot ?
19:06:30 <dmwit> lispy: No, it's only a problem with two lambdabots in the room.
19:06:47 <dmwit> lispy: And there are other easier sploits when there are two bots. =)
19:07:14 <oerjan> > fun "foo \13\10testing" :: Expr
19:07:15 <lambdabot>  foo
19:07:15 <lambdabot> testing
19:07:15 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:07:45 <faxathisia> > fun "foo \10testing" :: Expr
19:07:46 <lambdabot>  foo
19:07:46 <lambdabot> testing
19:07:46 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:07:54 <dmwit> I guess it depends on what you mean by "arbitrary control".
19:08:05 <dmwit> ?were wolf
19:08:05 <lambdabot> Aroooooo!
19:08:05 <lambdabot42> Aroooooo!
19:08:07 <oerjan> > fun "foo \ntesting" :: Expr
19:08:08 <lambdabot>  foo
19:08:08 <lambdabot> testing
19:08:08 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:08:24 <dmwit> Aww, that's no fun!
19:08:24 <oerjan> > fun "\ntesting" :: Expr
19:08:25 <lambdabot>  testing
19:08:26 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:10:36 <oerjan> > fun "foo \n\1does a little jig\1" :: Expr
19:10:38 <lambdabot>  foo
19:10:38 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:10:44 <oerjan> oops
19:10:54 <oerjan> > fun "foo \n\1ACTION does a little jig\1" :: Expr
19:10:55 <lambdabot>  foo
19:10:55 * lambdabot does a little jig
19:10:55 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:11:12 <faxathisia> > fun "foo \n\1ACTION barfs on the floor\1" :: Expr
19:11:13 <lambdabot>  foo
19:11:13 * lambdabot barfs on the floor
19:11:13 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:11:26 <faxathisia> so it's RFC compliant :p
19:11:33 <lispy> now send a messages to get op status (doesn't lambdabot have a few?) and use them
19:11:35 <dmwit> Presumably, we are suitably impressed. =D
19:11:54 <davidL> @help fun
19:11:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:11:54 <lambdabot42> help <command>. Ask for help for <command>. Try 'list' for all commands
19:12:06 <davidL> :t fun
19:12:08 <lambdabot> Not in scope: `fun'
19:12:08 <lambdabot42> Not in scope: `fun'
19:12:18 <dmwit> davidL: http://twan.home.fmf.nl/blog/
19:12:19 <faxathisia> fun :: String -> Expr
19:12:20 <lambdabot> Title: 21 thoughts
19:12:27 <pa-ching> Anyone know why "arg = read (ss !! i)" works but "arg = read . (!!)" doesn't?
19:12:39 <dmwit> (read .) . (!!)
19:12:42 <davidL> also, did lambdabot just CTCP everyone in the channel? :P
19:12:47 <pa-ching> oho, ok
19:12:53 <lispy> davidL: yes
19:13:00 <lispy> this is the arbitrary control I was referring to :)
19:13:01 * pa-ching attempts to grok
19:13:03 <idnar> well, it sent a CTCP to the channel
19:13:04 <dmwit> I didn't get a CTCP.
19:13:17 <idnar> that's not really any different from sending a normal message to the channel
19:13:17 <oerjan> a CTCP is just a special format privmsg
19:13:40 <lispy> but, can't you also send a PRIVMESG to anyone on freenode?
19:13:40 <dmwit> pa-ching: Since (!!) takes two arguments, the usual function composition doesn't do what you expect.
19:13:41 <SamB> huh. apparantly mozilla is written in javascript
19:13:48 <idnar> lispy: how?
19:13:52 <oerjan> lispy: no, everything goes to the channel
19:13:56 <davidL> SamB: you saw that on ohloh?
19:13:56 <dmwit> pa-ching: (Well, for a suitably good expectation, it does what you expect. =P)
19:14:03 <SamB> yeahj
19:14:05 <lispy> oerjan: hmmm
19:14:15 <idnar> > fun "foo \n\1VERSION\1" :: Expr
19:14:16 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:14:17 <davidL> I was surprised to see that myself
19:14:18 <lambdabot>  foo
19:14:44 <idnar> you can make everyone send VERSION responses to lambdabot, but that's their fault ;)
19:14:50 <pa-ching> dmwit: Ah okay... I kinda get it. Yeah, guess I usually just only apply one argument... so I need an extra . per arg, that makes sense I guess
19:15:15 <pa-ching> Cool, thanks.
19:15:18 <idnar> @pl \i -> read (ss !! i)
19:15:18 <lambdabot42> read . (ss !!)
19:15:19 <lambdabot> read . (ss !!)
19:15:29 <idnar> @pl \ss i -> read (ss !! i)
19:15:29 <lambdabot> (read .) . (!!)
19:15:29 <lambdabot42> (read .) . (!!)
19:15:42 <pa-ching> hoho
19:15:44 <idnar> @quote stereo
19:15:45 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:15:45 <lambdabot42> Plugin `quote' failed with: getRandItem: empty list
19:15:49 <conal> @ty (fmap.fmap) read (!!)
19:15:50 <lambdabot> forall b. (Read b) => [String] -> Int -> b
19:15:50 <lambdabot42> forall b. (Read b) => [String] -> Int -> b
19:15:58 <idnar> @quote majestic
19:15:58 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:15:58 <lambdabot42> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
19:16:12 <dmwit> NOOO
19:16:24 <lispy> > fun "foo \n\1PRIVMSG lispy Testing\1" :: Expr
19:16:25 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:16:25 <lambdabot>  foo
19:16:40 <conal> i like the double-fmap formulation.  it says to direct read to the result of the result of (!!).
19:16:40 <dmwit> I finally got over my grieving period, and now stereo is back??
19:16:56 <SamB> davidL: I suppose it isn't very surprising, considering that ohloh doesn't support XBL or XUL parsing as far as I know...
19:17:12 <conal> of course ((.).(.)) works as well, but i like the suggestiveness of (fmap.fmap)
19:17:17 <faxathisia> It's very neat conal
19:17:20 <conal> since it works on other functors
19:17:29 <idnar> (fmap`fmap`fmap) read (!!)
19:17:32 * idnar runs away
19:17:32 <faxathisia> what other functor?
19:17:49 <conal> and (as i often mention), you can mix fmap with first & second.
19:18:14 <conal> @ty (fmap.fmap) read
19:18:16 <lambdabot42> forall (f :: * -> *) b (f1 :: * -> *). (Read b, Functor f1, Functor f) => f (f1 String) -> f (f1 b)
19:18:21 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Read b, Functor f1, Functor f) => f (f1 String) -> f (f1 b)
19:18:27 <conal> faxathisia: those other functors
19:18:35 <conal> @ty (fmap.first.fmap.second) read
19:18:36 <lambdabot> forall (f :: * -> *) d (f1 :: * -> *) c d1. (Read c, Functor f1, Functor f) => f (f1 (d1, String), d) -> f (f1 (d1, c), d)
19:18:37 <lambdabot42> forall (f :: * -> *) d (f1 :: * -> *) c d1. (Read c, Functor f1, Functor f) => f (f1 (d1, String), d) -> f (f1 (d1, c), d)
19:18:41 <conal> etc
19:18:43 <davidL> > foldr (fun "f") (var "x") [1..5]
19:18:44 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
19:18:44 <lambdabot42>   Not in scope: `var'
19:18:47 <idnar> SamB: I'd expect Mozilla to have more JavaScript than XBL or XUL anyway
19:18:54 <SamB> idnar: yeah, probably
19:18:56 <oerjan> lispy: every line lambdabot prints is prepended by "PRIVMSG #esoteric :", you cannot make it a different basic IRC command
19:19:03 <faxathisia> > foldr (flip f) z [a,b,c,d]
19:19:04 <lambdabot42>   Not in scope: `d'
19:19:04 <lambdabot>  f (f (f (f z d) c) b) a
19:19:18 <faxathisia> > foldl f z (reverse [a,b,c,d])
19:19:19 <lambdabot>  f (f (f (f z d) c) b) a
19:19:19 <lambdabot42>   Not in scope: `d'
19:19:25 <lispy> oerjan: that's good at least
19:20:39 <faxathisia> > foldr f z (reverse [a,b,c,d])
19:20:40 <lambdabot42>   Not in scope: `d'
19:20:53 <lambdabot>  f d (f c (f b (f a z)))
19:21:03 <idnar> oerjan: some of them presumably have "PRIVMSG #haskell :" prepended ;)
19:21:18 <oerjan> argh, how did i do that :D
19:21:38 <oerjan> for being on only two channels i sure confuse them a lot
19:22:00 <lispy> there is an #esoteric? I thought it was a pun on you knowing how it works
19:22:00 <oerjan> it must because we've spent so much time playing with bots in #esoteric
19:22:05 <SamB> --- Received a CTCP PRIVMSG lispy Testing from lambdabot (to #haskell)
19:22:10 <oerjan> *be because
19:22:22 <SamB> are you sure?
19:22:33 <faxathisia> CTCP come in PRIVMSG
19:22:42 <SamB> oh
19:22:47 <faxathisia> JOIN QUIT etc.. are unattainable
19:22:48 <lispy> SamB: it was intended to be a private message
19:22:49 <SamB> that would explain that then
19:23:00 <oerjan> CTCP were sort of crafted onto the basic IRC protocol
19:23:03 <lispy> SamB: stop reading my email!
19:23:05 <lispy> ;)
19:24:55 <gwern> woot
19:24:59 <gwern> DisTract is now uploaded
19:25:13 <gwern> canyone want to do 'cabal update && cabal install DisTract'?
19:25:18 <idnar> it's interesting to see what clients do with "inline" CTCP messages
19:25:51 <idnar> CTCP messages are generally sent in their own message, but you're supposed to be able to include them in another message
19:26:28 <idnar> > fun "foo \1ACTION barfs on the floor\1 bar" :: Expr
19:26:29 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:26:30 <lambdabot>  foo ACTION barfs on the floor bar
19:26:48 <idnar> > fun "foo \1PING\1 bar" :: Expr
19:26:49 <lambdabot>  foo PING bar
19:26:50 <lambdabot42>   Not in scope: type constructor or class `Expr'
19:26:56 <gwern> no - no one wants to cabal install DisTract? :(
19:27:28 * gwern compells you!
19:29:32 <shteou> :o
19:32:47 * monochrom compiles you!
19:33:34 * monochrom gets naughty
19:34:27 * monochrom compiles you!
19:34:46 <GHC> But I'm GHC!  If you compile me, you get the same me!
19:35:15 <monochrom> (That was me also.)
19:35:35 <gwern> @tell dons FYI, I put distract on hackage; you seemed to be interested in the subject
19:35:35 <lambdabot> Consider it noted.
19:35:35 <lambdabot42> Consider it noted.
19:35:44 <monochrom> It's my haskell version of the math joke about integrating e^x.
19:36:04 <gwern> GHC IS A FIXEDPOINT OF ITSELF LOLLOL
19:37:22 <wagle_home> usually, its something like compile(1) ~> 2, compile (2) ~> 3, compile(3) ~> 3
19:38:36 <wagle_home> hmm..  thats not right
19:39:48 <shteou> I want to write my JIT compiler in Haskell now :(
19:41:01 <gwern> sounds like a job for Harpy
19:42:12 <shteou> That's just x86 isn't it, gwern?
19:43:35 <gwern> likeanyone uses anything else
19:43:42 <gwern> but how hard could it be to extend?
19:44:31 <shteou> I'm just using Lightning atm... wish I'd used libjit to some extent now
19:44:40 <shteou> well... no... I wish I had the time to write my own :/
19:45:02 <shteou> But alas, 3rd year project with a rapidly approaching deadline :o
19:45:25 <shteou> And Lightning is definitely a nice easy library for proof of concept, at least.
19:45:50 <gwern> lightning? is that in haskell?
19:45:54 <SamB> it's in .h
19:46:02 <shteou> heh
19:46:06 <gwern> C headers?
19:46:12 <SamB> yes, C headers
19:46:13 <shteou> Aye, it's all preprocessor macros
19:46:23 <shteou> except for a few little statey bits
19:46:46 <SamB> it seems rather horrible
19:47:08 <shteou> I quite like it SamB. It's no nonsense, at least.
19:47:14 <SamB> or at least it did when I was looking at it a while back
19:47:19 <SamB> maybe I wouldn't think so anymore?
19:47:29 <shteou> I'm not sure if it has changed much recently.
19:47:40 <SamB> perhaps *I* have?
19:47:45 <shteou> lol
19:47:58 <shteou> Have you looked at libjit, SamB?
19:48:03 <SamB> don't think so
19:48:06 <SamB> how recent is that?
19:48:19 <shteou> Quite recent, though I'm not sure if it is REALLY being actively developed
19:48:25 <shteou> It is used in dotGNU.
19:48:34 <shteou> They have an alpha available, which is documented as stable.
19:49:05 <shteou> But the website for libjit linked from the dotGNU site has been dead for months, at least.
19:49:42 <shteou> Last news item was nearly a year ago hehe
19:49:53 <shteou> Not sure if they gave up due to mono, or something.
19:50:19 <shteou> I'd be interested in developing it when I finish university :/
19:50:55 <gwern> gnu has an unfortunate NIH tendency sometimes
19:51:56 <shteou> NIH?
19:52:03 <jcreigh> Not Invented Here
19:52:07 <shteou> Ah
19:52:24 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/Not_Invented_Here
19:52:52 <shteou> I'm a Quakenet child, I feel like a fish out of water in here sometimes :p
19:53:20 <shteou> It's a pity though, because libjit has potential for a big userbase.
19:53:36 <gwern> shteou: eh. a good reading of the Jargon File would cure a lot of your ignorance
19:56:19 <BMeph> Or, at least give you a good laugh.
19:57:05 <shteou> I'd best not read anything atm... so much work, so little time.
19:57:06 <gwern> for the newer entries, mayhap...
19:58:13 <shteou> My JIT compiler runs a fair amount of code now, at least.  There's one bug in particular that is causing some serious trouble though :/
19:58:33 <shteou> It's causing a good portion of nofib to fail.
20:01:52 <dolio> faxathisia: ping
20:01:58 <faxathisia> Hello
20:02:10 <dolio> You know how to use 'with' with more than one expression, off hand?
20:02:18 <faxathisia> yes
20:02:30 <faxathisia> the first will be like
20:02:54 <faxathisia> ... | Pattern _ = something
20:03:20 <faxathisia> the next with clause just has ...    |, so the second | is indented more
20:04:07 <hpaste>  (anonymous) pasted "card game" at http://hpaste.org/5717
20:04:13 <davidL> any way to simplify (f *** f) ?
20:04:28 <hasenov> hello, could anyone help me out with the code i just posted
20:04:59 <hasenov> im trying to learn monads now, and would like to know how to transform the do notation into the bind >>= operators
20:05:17 <hasenov> and how could I transform an IO monad into a Maybe monad
20:05:18 <oerjan> join(***) f
20:05:25 <davidL> thanks
20:05:47 <dolio> faxathisia: Ah, okay. Thanks.
20:05:48 <hasenov> because as of right now drawCard returns IO(Maybe Card) rather than Maybe Card
20:06:09 <hasenov> i tried using liftIO but get a cryptic error
20:07:04 <Saizan> hasenov: first of all, IO is designed so that you can't :)
20:07:50 <gwern> hasenov: http://arcanux.org/lambdacats_2.html <-- they don't call it 'trapped' for nothing
20:07:51 <lambdabot> Title: Lambdacats
20:07:51 <hasenov> i thought liftIO might be able to do the job, maybe im misunderstanding its purpose?
20:08:03 <oerjan> :t randomRIO
20:08:05 <lambdabot42> forall a. (Random a) => (a, a) -> IO a
20:08:07 <lambdabot> forall a. (Random a) => (a, a) -> IO a
20:08:20 <oerjan> hasenov: ^^ your drawRand already has a name
20:08:26 <wagle_home> :t liftIO
20:08:27 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:08:28 <lambdabot42> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:08:48 <Saizan> hasenov: liftIO is not to remove IO but to wrap it in a monad built on IO
20:08:53 <hasenov> gwern: im feeling exactly like that cat
20:09:29 <gwern> hasenov: I know. I felt the same way, which is why I remember that lambdacat so well
20:09:38 <dibblego> isn't it to lift the IO away? :)
20:10:10 <oerjan> @undo do { i <- drawRand i i ; return (getCard i) }
20:10:11 <lambdabot> drawRand i i >>= \ i -> return (getCard i)
20:10:11 <lambdabot42> drawRand i i >>= \ i -> return (getCard i)
20:11:06 <oerjan> @pl drawRand i i >>= \ i -> return (getCard i)
20:11:07 <lambdabot> getCard `fmap` drawRand i i
20:11:07 <lambdabot42> getCard `fmap` drawRand i i
20:11:22 <shteou> Deary me gwern, lambda cats are tortuing me :(
20:11:33 <oerjan> hasenov: ^^ lambdabot commands useful for removing do notation
20:11:39 <Saizan> hasenov: so either you continue to work inside IO, or rewrite your functions a bit so that you can just take a random generator from IO and work in "pure" code from then on
20:11:46 <shteou> "oleg cat sez: my primes benchmark doesnt run proerly in your JIT compiler" :(
20:12:20 <oerjan> someone kick lambdabot42 please?
20:13:57 <Saizan> uhm, seems resonable
20:14:04 <hasenov> k, i used randomRIO thanx, now for the next part
20:14:17 --- mode: ChanServ set +o Saizan
20:14:27 --- kick: lambdabot42 was kicked by Saizan (Saizan)
20:14:36 --- mode: Saizan set -o Saizan
20:14:46 <shteou> Never say never!
20:14:46 <oerjan> shteou: that's just his fault for trying to do JIT in the type system :D
20:15:09 <shteou> heh
20:15:14 <shteou> Right, I'm going to try and go to sleep
20:15:26 <shteou> G'night all :)
20:15:42 <hasenov> Saizan: what do u mean "take a random generator from IO and work in a pure code"?
20:15:53 <hasenov> i thought someone said u cant strip the IO away
20:16:43 <idnar> you can write pure code that takes the generator as a parameter
20:16:46 <Saizan> hasenov: you can't but you can pass values from IO to pure code, embedding the pure code in IO, the difference is how often you need to get back on the IO
20:16:49 <wagle_home> @src MonadIO
20:16:50 <lambdabot> Source not found. My brain just exploded
20:17:05 <Saizan> ?type getStdGen
20:17:06 <lambdabot> IO StdGen
20:17:15 <wagle_home> :t MonadIO
20:17:15 <lambdabot> Not in scope: data constructor `MonadIO'
20:17:21 <wagle_home> :k MonadIO
20:17:21 <lambdabot> Class `MonadIO' used as a type
20:17:38 <wagle_home> @index MonadIO
20:17:39 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:17:47 <idnar> @instances MonadIO
20:17:48 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
20:17:56 <oerjan> class Monad a => MonadIO a where liftIO :: IO b -> a b
20:18:02 <Saizan> hasenov: for example main = do generator <- getStdGen; let result = doTheRealStuff generator; print result
20:18:45 <Saizan> ?type randomR
20:18:46 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
20:18:53 <hasenov> so in the case of "drawRand i i >>= \i -> return (getCard i)", is "i" the argument of lambda, a pure value?
20:18:57 <idnar> where is MonadIO defined?
20:19:16 <Saizan> idnar: Control.Monad.IO?
20:19:23 <oerjan> idnar: probably Control.Monad.Trans
20:19:37 <idnar> oerjan: ah, that's the one
20:19:39 <oerjan> (since it's the first listed?)
20:19:42 <idnar> Saizan: I don't have such a module
20:20:09 <Saizan> i recalled incorrectly :)
20:20:36 <idnar> hmm, I don't understand liftIO
20:20:37 <wagle_home> thanks
20:21:00 <idnar> it takes an IO action to something that's not an IO action?
20:21:03 <wagle_home> look at one of the instances
20:21:04 <hasenov> idnar: me too!
20:21:16 <oerjan> idnar: usually a is something like StateT s IO
20:21:29 <oerjan> so it's a monad containing IO inside
20:21:30 <idnar> oerjan: oh, right
20:22:06 <Saizan> idnar: it's just to spare you to use lift multiple times if you've a lot of transformers
20:23:03 <Saizan> hasenov: don't care about liftIO until you're using monad transformers :)
20:24:58 <dibblego> is there a "forever :: IO a -> IO ()" ?
20:25:13 <oerjan> :t forever
20:25:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:25:18 <Saizan> ?index forever
20:25:19 <lambdabot> bzzt
20:25:20 <dibblego> oh thanks
20:25:53 <Saizan> it should be m a -> m b !
20:25:54 <oerjan> (new in 6.8)
20:26:20 <wagle_home> > forever [1]
20:26:25 <idnar> :t fixIO
20:26:26 <lambdabot>  Exception: stack overflow
20:26:26 <lambdabot> Not in scope: `fixIO'
20:26:28 <oerjan> i vaguely recall that being corrected recently?
20:26:40 <idnar> :hoogle fixIO
20:26:42 <idnar> @hoogle fixIO
20:26:42 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:27:03 <oerjan> @src IO mfix
20:27:04 <lambdabot> mfix = fixIO
20:27:12 <oerjan> @src MonadFix
20:27:13 <lambdabot> class (Monad m) => MonadFix m where
20:27:13 <lambdabot>     mfix :: (a -> m a) -> m a
20:28:10 <idnar> "forever a = mfix \x -> return a" or something?
20:28:17 <oerjan> no
20:28:28 <oerjan> forever a = a >> forever a
20:28:37 <oerjan> = fix (a >>)
20:28:42 <oerjan> no mfix required
20:28:57 <idnar> hmm
20:29:29 <Saizan> actually mfix is required to run the effects only once, while forever to run them as much as it can
20:29:46 <hasenov> oh, another thing i wanted to ask was, in my function, how does return know to output an IO monad?
20:29:54 <oerjan> hasenov: type inference
20:30:03 <hasenov> since it gets a -> M a
20:30:19 <hasenov> how does it know what M is?
20:30:24 <oerjan> in a do block, all the statements must have the same monad
20:30:43 <hasenov> allright
20:30:47 <oerjan> so the one for return is unified with the others
20:31:50 <oerjan> if neither statement determined the monad, it would be left as a type variable
20:31:51 <lispy> i think monads wouldn't be very useful if that weren't the case
20:32:32 <oerjan> :t do return (); return "ho"
20:32:33 <lambdabot> forall (t :: * -> *). (Monad t) => t [Char]
20:32:53 <idnar> lispy: how would that work?
20:32:54 <Saizan> lispy: there's an extension to them where the type varies on each statement :)
20:33:03 <idnar> whoa what
20:33:39 <lispy> Saizan: oh, do you remember any other details?
20:34:10 <oerjan> it can actually be useful.  say if you want a state monad where the state changes type sometimes - you cannot do that with the usual restrictions
20:34:20 <hasenov> now i know how i can expand getCard to take care of every number until 32, however what wont work is the fact that a random number can repeat
20:34:29 <Saizan> not a widely used typeclass, i can find an .lhs where oleg use them to implement delimited continuations
20:34:32 <SamB> oerjan: that sounds just like nyhc!
20:35:03 <hasenov> im thinking i can just put all the succeeded numbers in a list, and if a new generated number is drawn & is already in the list, discard it
20:35:10 <lispy> oerjan: but, in that case it's the same monad, but different state.  I can see how that might be helpful.  But, I mean changing between IO and list monad and back again in the middle might be weird.
20:35:26 <sili> hmm
20:35:26 <SamB> lispy: I don't think you could ever do that...
20:35:46 <oerjan> hasenov: that sounds good
20:35:57 <hasenov> but then, what if the range is really small, it would keep generating erronous numbers and keep discarding it and there would be numerous extra computations
20:36:28 <oerjan> hasenov: oh.  an alternative is to keep a list of the _remaining_ numbers
20:36:33 <lispy> hasenov: is this for drawing cards or shuffling?
20:36:36 <oerjan> and select from that list
20:36:41 <lispy> yeah, I was going to suggest that
20:36:56 <hasenov> oerjan: yea i was just about to say that
20:36:59 <lispy> instead of generating a random card, generate a random index into the list of remaining elements
20:37:11 <alatter> gwern: so, about the DisTract package - which version of cabal did you have installed to get it to build?  I can't seem to build hinstall, which is a dependency
20:37:19 <SamB> lispy: your silly bot thinks GHC is a person!
20:37:26 <hasenov> but then i would have to instantiate every single card though, it would be alot of extra code
20:37:40 <lispy> SamB: of course!
20:37:51 <lispy> SamB: actually, that is kind of weird
20:37:53 <SamB> it doesn't check the list?
20:38:01 <lispy> I thought it did.
20:38:18 <SamB> oh, wait, someone said something as GHC recently
20:38:20 <SamB> false alarm
20:38:42 <hasenov> like, would i really need to say for every card, Card someSuit someFace someFilename ++ [] and so on?
20:38:44 <oerjan> hasenov: not really.  just map getCard [1..52] or whatever
20:38:54 <lispy> SamB: I think with the exception of direct addressing, like i'm doing now, it pretty much ignores what we say
20:39:05 <gwern> alatter: 1.2.3.0 iirc
20:39:15 <davidL> > (join(***)(/(2*a))$(((+b).(*(-1)))&&&(+b))$sqrt(b^2-4*a*c)) 1 18 81 -- is it possible to shorten this?
20:39:31 <lambdabot>  thread killed
20:39:40 <hasenov> oerjan: oh ok thanx
20:39:51 <davidL> > let roots a b c = (join(***)(/(2*a))$(((+b).(*(-1)))&&&(+b))$sqrt(b^2-4*a*c)) in roots 1 18 81
20:39:56 <lambdabot>  (9.0,9.0)
20:39:58 <gwern> alatter: which is also the specified one in the dependencies; unless you have some newer one?
20:39:59 <lispy> davidL: what is that the quadradic formula?
20:40:10 <davidL> lispy: yeah
20:40:33 <lispy> we need ?gold
20:40:36 <lispy> er ?golf
20:40:47 <davidL> yeah :P
20:40:51 <lispy> some way to programmatically do substitutions looking for the shortest form
20:41:12 <SamB> --- trebla is now known as GHC
20:41:12 <SamB> * monochrom compiles you!
20:41:12 <SamB> --> ivanm (n=ivan@60-242-0-245.static.tpgi.com.au) has joined #haskell
20:41:12 <SamB> <GHC> But I'm GHC!  If you compile me, you get the same me!
20:41:12 <SamB> <-- GHC has quit (Client Quit)
20:41:13 <SamB> <monochrom> (That was me also.)
20:41:19 <SamB> --> dfeuer (n=David@wikimedia/Dfeuer) has joined #haskell
20:41:21 <SamB> <gwern> @tell dons FYI, I put distract on hackage; you seemed to be interested in the subject
20:41:23 <SamB> <lambdabot> Consider it noted.
20:41:25 <SamB> <lambdabot42> Consider it noted.
20:41:27 <SamB> <monochrom> It's my haskell version of the math joke about integrating e^x.
20:41:30 <SamB> <gwern> GHC IS A FIXEDPOINT OF ITSELF LOLLOL
20:41:55 <gwern> ?
20:42:20 <lispy> SamB: please, remember to take your riddilan
20:42:24 <davidL> mispaste amirite?
20:42:29 <wagle_home> read "On Trsuting Trust" recently
20:42:30 <sw17ch> > sum [1..10] :: Expr
20:42:32 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
20:42:32 <wagle_home> ?
20:42:45 <SamB> lispy: I don't take that at night dumbass
20:42:52 <SamB> also I take adderal, not ritalin
20:43:06 <lispy> oh ritalin, dam i'm a poor speller
20:43:15 <sw17ch> > foldr (+) 0 [1..10]
20:43:16 <lambdabot>  55
20:43:18 <sw17ch> > foldr (+) 0 [1..10] :: Expr
20:43:18 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
20:43:22 <faxathisia> > foldr (flip f) z [a,b,c,d]
20:43:23 <lambdabot>  f (f (f (f z d) c) b) a
20:43:33 <sw17ch> > foldl (+) 0 [1..10] :: Expr
20:43:33 <faxathisia> > foldl f z (reverse [a,b,c,d])
20:43:34 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
20:43:34 <lambdabot>  f (f (f (f z d) c) b) a
20:43:41 <davidL> > foldl (+) 0 [1..10] :: Expr
20:43:42 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
20:43:50 <idnar> @pl roots a b c = (join(***)(/(2*a))$(((+b).(*(-1)))&&&(+b))$sqrt(b^2-4*a*c))
20:43:50 <oerjan> lispy: um riddilan exists i just googled it
20:43:50 <lambdabot> roots = ap ((.) . (.) . join (***) . flip (/) . (2 *)) (ap ((.) . ap ((&&&) . (. (-1 *)) . (+)) (+)) . ((sqrt .) .) . flip ((.) . (-) . (^ 2)) . (*) . (4 *))
20:44:12 <sw17ch> what is pl?
20:44:12 <davidL> nice
20:44:22 <wagle_home> map (,) [1..10] :: Expr
20:44:27 <wagle_home> > map (,) [1..10] :: Expr
20:44:28 <lambdabot>  Couldn't match expected type `Expr'
20:44:35 <oerjan> hm maybe just a joke spelling
20:44:44 <SamB> oerjan: one of the top hits said "or however you spell it"
20:44:46 <lispy> sw17ch: "point less" it turns the code into 'point-free' form
20:44:56 <faxathisia> > zip [1..10]
20:44:57 <lambdabot>  Add a type signature
20:45:05 <faxathisia> > zip [1..10] :: [Expr]
20:45:06 <lambdabot>  Couldn't match expected type `[Expr]'
20:45:08 <faxathisia> > zip [1..10] :: Expr
20:45:09 <lambdabot>  Couldn't match expected type `Expr'
20:45:18 <SamB> an old joke name for the point-free form
20:45:20 <faxathisia> > zip [1..10] (repeat ()) :: [Expr]
20:45:20 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(t, ())'
20:45:26 <sw17ch> @pl sum [1..10]
20:45:26 <lambdabot> sum [1..10]
20:45:31 <sw17ch> oh ... woops
20:45:31 <SamB> implying that the point-free form is useless as well as point-free
20:45:45 <lispy> > reverse . reverse $ [1..5] :: Expr
20:45:45 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
20:45:46 <idnar> @pl \x -> sum [1..x]
20:45:46 <lambdabot> sum . enumFromTo 1
20:45:48 <wagle_home> @src sum
20:45:49 <lambdabot> sum = foldl (+) 0
20:45:59 <davidL> > ap((.).(.).join(***).flip(/).(2*))(ap((.).ap((&&&).(.(-1*)).(+))(+)).((sqrt.).).flip ((.).(-).(^2)).(*).(4*)) 1 18 81
20:46:00 <lambdabot>      The operator `*' [infixl 7] of a section
20:46:00 <lambdabot>         must have lower precede...
20:46:14 <davidL> :[
20:46:36 <wagle_home> > foldl (,) 0 [1..10] :: Expr
20:46:36 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
20:46:36 <lambdabot>       Expec...
20:46:36 <lispy> SamB: although, because of the #haskell convention to call it point less, I made someone over email think I was getting frustrated at them.
20:46:50 <idnar> (-1 *) doesn't actually work, I don't thin
20:46:51 <idnar> k
20:46:54 <lispy> "You don't like point less code?"
20:46:59 <lispy> "Hey, calm down..."
20:47:06 <davidL> > (-1 *) 42
20:47:07 <lambdabot>      The operator `*' [infixl 7] of a section
20:47:07 <lambdabot>         must have lower precede...
20:47:10 <wagle_home> > (-1 *) 2
20:47:10 <lambdabot>      The operator `*' [infixl 7] of a section
20:47:10 <lambdabot>         must have lower precede...
20:47:15 <lispy> subtract 1
20:47:20 <davidL> > (*(-1)) 42
20:47:21 <lambdabot>  -42
20:47:35 <idnar> ((-1)*) 42
20:47:35 <SamB> like most decent jokes, context and/or tone of voice is important
20:47:36 <idnar> > ((-1)*) 42
20:47:37 <lambdabot>  -42
20:47:46 <wagle_home> (* -1) 2
20:47:51 <wagle_home> > (* -1) 2
20:47:52 <lambdabot>      The operator `*' [infixl 7] of a section
20:47:52 <lambdabot>         must have lower precede...
20:48:04 <Saizan> negate?
20:48:09 <davidL> > (length "negate", length "((-1)*)")
20:48:11 <lambdabot>  (6,7)
20:48:11 <wagle_home> i still think that makes haskell syntax broken..  sigh
20:48:18 <davidL> haha
20:48:20 <davidL> negate wins
20:48:39 <idnar> > length "((*)-1)"
20:48:39 <davidL> > ap((.).(.).join(***).flip(/).(2*))(ap((.).ap((&&&).(.negate).(+))(+)).((sqrt.).).flip ((.).(-).(^2)).(*).(4*)) 1 18 81
20:48:40 <lambdabot>  7
20:48:40 <lambdabot>  (9.0,9.0)
20:48:44 <davidL> sexy
20:48:55 <faxathisia> > let a=1;b=18;c=81;d=sqrt(b*b-4*a*c);r d=(d-b)/(2*a);rs=(r d, l (-d)) in rs
20:48:55 <lambdabot>  Couldn't match expected type `a -> t' against inferred type `Expr'
20:49:12 <faxathisia> > let a=1;b=18;c=81;d=sqrt(b*b-4*a*c);r d=(d-b)/(2*a);rs=(r d, l (0-d)) in rs
20:49:13 <lambdabot>  Couldn't match expected type `a -> t' against inferred type `Expr'
20:49:26 <faxathisia> > let a=1;b=18;c=81;d=sqrt(b*b-4*a*c);r d=(d-b)/(2*a);rs=(r d, r (0-d)) in rs
20:49:27 <lambdabot>  (-9.0,-9.0)
20:49:30 <faxathisia> > let a=1;b=18;c=81;d=sqrt(b*b-4*a*c);r d=(d-b)/(2*a);rs=(r d, r (-d)) in rs
20:49:30 <lambdabot>  (-9.0,-9.0)
20:49:57 <Saizan> wagle_home: i've still to find a person who likes haskell's unary minus.
20:50:00 <davidL> that's no fun :(
20:50:38 <idnar> heh
20:50:55 <alatter> gwern: I though that's what I had.  maybe I ddi something silly and installed cabal from darcs ... investigating
20:51:30 <gwern> ghc-pkg list|grep Cabal
20:51:36 <Saizan> > let a ~ b = "test" in 1 ~ 2
20:51:37 <lambdabot>  Parse error in expression at end of input
20:52:18 <wagle_home> let a `~` b = "test" in 1 ~ 2
20:52:23 <wagle_home> > let a `~` b = "test" in 1 ~ 2
20:52:23 <lambdabot>  Parse error at "~`" (column 8)
20:52:48 <faxathisia> ~ is special thought (irrefutable pattern)
20:52:53 <wagle_home> haskell is the only language that cant get - right
20:53:00 <lispy> > a '~' b = "test" in 1 '~' 2
20:53:00 <lambdabot>  Parse error at "=" (column 9)
20:53:14 <faxathisia> wagle: - is fine in haskell
20:53:21 <SamB> wagle: is it now?
20:53:34 <SamB> what do you mean by "get - right"?
20:53:38 <wagle_home> - is broken in haskell
20:53:43 <lispy> haha
20:53:45 <Saizan> yeah, so we can use ~ as negate, and keep our subraction sane
20:53:48 <faxathisia> wagle: No it is not
20:53:58 <SamB> faxathisia: it isn't?
20:54:01 <wagle_home> :t (1+)
20:54:02 <lispy> > let get = 2; right = 4 in get - right
20:54:03 <lambdabot>  -2
20:54:03 <lambdabot> forall t. (Num t) => t -> t
20:54:11 <wagle_home> :t (1-)
20:54:12 <lambdabot> forall t. (Num t) => t -> t
20:54:13 <oerjan> ooh
20:54:15 <gwern> (-) had to be the way it is for user-definable infix, I thought...
20:54:19 <wagle_home> :t (+1)
20:54:20 <lambdabot> forall a. (Num a) => a -> a
20:54:23 <wagle_home> :t (-1)
20:54:24 <oerjan> > (0-) 3
20:54:24 <lambdabot> forall a. (Num a) => a
20:54:25 <lambdabot>  -3
20:54:28 <oerjan> yay!
20:54:44 * wagle_home barfs
20:54:48 <SamB> so you are saying we need to do it the smalltalk way?
20:54:55 <awesame> wagle_home: itym haskell is the only language that can get + right
20:54:58 <oerjan> it's shorter than negate
20:55:16 <wagle_home> awesame, hmm
20:55:20 <gwern> man, hackage is so picky about version numbering
20:55:45 <SamB> gwern: what, does it want them monotonically increasing?
20:56:05 <gwern> @tell Philippa_ http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Flippi-0.0.3 <-- behold; e'en as I have said, I have done
20:56:06 <lambdabot> Consider it noted.
20:56:19 <gwern> SamB: nah, it didn't like 0.03, so I changed it to 0.0.3
20:56:34 <gwern> which was annoying
20:57:23 <lispy> gwern: do you like making packages?
20:57:32 <wagle_home> is it that paren's are overloaded?  eg (1-) instead of maybe <1-> or something
20:58:00 <gwern> lispy: I feel it is something of a moral imperative
20:58:02 <ddarius> gwern has an addicition
20:58:08 <lispy> wagle_home: I think it's simply that sometimes people want to type -1 to mean, negative one
20:58:32 <wagle_home> uhh..  centuries of culture say -1 is negative one
20:58:37 <gwern> ddarius: it's nbot an addition! I can stop any time
20:59:00 <lispy> nbot!
20:59:11 <gwern> wagle_home: sure? I've read about the history of math notation and punctuation in general, and things we see are standard don't actually go very far back sometimes
20:59:14 <lispy> mbot's older bother
20:59:31 <oerjan> lispy: younger, surely?
20:59:36 * Saizan points gwern at a darcs repo of unreleased code
20:59:47 <wagle_home> and haskells gonna change all that?
20:59:58 <lispy> gwern: want to hackage-ize some opengl tuts?
21:00:04 <lispy> gwern: it's haskell of course
21:00:05 <awesame> so why should +1 be "add 1" instead of "positive 1"
21:00:15 <gwern> eh. a couple letters from leibniz changed the course of calculus notation
21:00:16 <awesame> +1 normally means positive 1 as well
21:00:25 <wagle_home> yes
21:00:32 <gwern> lispy: you can send me a link...
21:00:42 <awesame> I think it's math that's broken, not haskell
21:00:49 <awesame> math notation leaves a lot up to context
21:01:00 <faxathisia> math notation and haskell are different languages
21:01:02 <lispy> gwern: http://codersbase.com/index.php/Nehe-tuts
21:01:03 <lambdabot> Title: Nehe-tuts - CodersBase
21:01:08 <faxathisia> I don't think there's much else to this...
21:01:35 <gwern> faxathisia: it's a good ideal, for hgasjell notation to steall as much goodness as possible from math
21:01:42 <awesame> well, haskell looks a lot like math notation sometimes, and other times is annoyingly (or wonderfully) different
21:01:49 <gwern> and '1 + (-1)' isn't ideal, imo
21:02:14 <lispy> > 1 + (-1) :: Expr
21:02:15 <lambdabot>  1 + negate 1
21:02:27 <wagle_home> > 1 `+` -2
21:02:28 <lambdabot>  Parse error at "+`" (column 4)
21:02:51 <lispy> sadly, things like 1 `(+)` 2, do not work in Haskell syntax :(
21:03:02 <faxathisia> yeah that would be nice
21:03:25 <faxathisia> maybe use something other than `` though.. it would maybe have to be a bracket
21:03:31 <awesame> what's wrong with 1 + (-1)?
21:03:39 <ddarius> There's already a hack to do that
21:03:43 <lispy> yeah, it would allow things like bar `(liftM2 foo)` baz
21:03:43 <faxathisia> (if you want to nest them)
21:03:46 <awesame> you want to ditch the parens?
21:03:49 <faxathisia> awesame, nothing
21:04:05 <faxathisia> awesame, It's perfectly valid.. I'd just write 0 though
21:04:08 <wagle_home> ok, you guys can push though legislation to teach neg 1 as a number to elementary school students
21:04:08 <SamB> lispy: well, considering how nicely `` would nest, I'm not sure I can say I mind
21:04:21 <SamB> wagle: oh come on
21:04:27 <faxathisia> wagle: Really this is tiresome
21:04:57 <gwern> mm. I wonder how bad it would be to have neg1 defined in the Prelude? :)
21:05:00 <SamB> wagle: you complain that Haskell's implementation of - is broken and then say stupid shit like that?
21:05:09 <wagle_home> no, you saying the number -1 should be written "neg 1" instead, and haskell has it right is tiresome
21:05:16 <gwern> > let neg1 = negate 1 in 1 + neg1
21:05:22 <lambdabot>  0
21:06:22 <lispy> I don't think mathematics, viewed as a language, can be implemented in a machine parsable way.
21:06:23 <Saizan> i wonder why the unary minus doesn't bind tigher than infix
21:06:30 <awesame> I think maybe there's a reasonable argument that making "- 1" = "(subtract 1)" and "-1" = "(-1)" would have made haskell more natural, since that's sort of the way math does it
21:06:34 <SamB> lispy: indeed not ;-)
21:06:44 <SamB> it probably would be easier to parse English
21:07:10 <awesame> well, I'm a machine that parses English, right?
21:07:14 <awesame> so it could be done
21:07:15 <SamB> I almost wish we could do like calculators do
21:07:24 <ddarius> awesame: You parse it correctly all the time?
21:07:26 <SamB> and use two different minus signs
21:07:34 <gwern> lispy: before you say that, see how much of mathematics TeX/LaTex can parse
21:07:44 <SamB> gwern: they don't parse it
21:07:51 <SamB> they can only typeset a little bit
21:07:51 <faxathisia> gwern, what..?
21:07:58 <gwern> once you can represent it, then you can parse it
21:08:04 <awesame> ddarius: well, you're right.  we should fix the parts of math that really are ambiguous
21:08:08 <lispy> gwern: latex doesn't have to get the semantics of the math, only the semantic of type setting
21:08:16 <SamB> gwern: that's like saying you can parse it because you can type it
21:08:37 <faxathisia> id -- parses anything
21:08:44 <SamB> really, LaTeX can't even typeset simple boolean expressions decently without help sometimes
21:08:47 <lispy> and latex is not perfect, regardless of what the Honourable Knuth says
21:09:01 <SamB> Knuth doesn't use latex, silly
21:09:11 <radetsky> lispy: BLASPHEMER!!!!
21:09:11 <ddarius> awesame: No we shouldn't.
21:09:19 <lispy> fine, we could talk about Tex if you want to pick nits :)
21:09:25 <SamB> he does a lot of the work of typesetting anyway
21:09:26 <yaru1022> has anyone come across this error message? "Warning: Cannot read /usr/local/share/doc/ghc/libraries/unix/unix.haddock:
21:09:26 <yaru1022>    "Magic number mismatch: couldn't load interface file: /usr/local/share/doc/ghc/libraries/unix/unix.haddock"
21:09:26 <yaru1022> Skipping this interface."
21:09:34 <awesame> ddarius: really!  that's an interesting position.
21:09:42 <awesame> ddarius: why not?
21:10:14 <ddarius> awesame: For exactly the same reason we shouldn't fix a natural language to get rid of the parts that are "really ambiguous".
21:10:14 <lispy> yaru1022: ghc version mismatch?
21:10:34 <radetsky> ddarius: what reason is that?
21:10:41 <Saizan> yaru1022: it means the doc for unix was created with a different haddock, and so it won't insert link to it in the documentation you're building
21:10:51 <SamB> LaTeX *can* typeset a fairly large amount of mathematical material without a great deal of help, but still doesn't have a clue what it means.
21:11:00 <idnar> ddarius: you mean you're not learning Lojban?!?!
21:11:01 <yaru1022> Saizan, then how do I create with a right haddock version?
21:11:08 * idnar ducks
21:11:11 <ddarius> idnar: No
21:11:17 <awesame> ddarius: so you're saying that by leaving math the way it is, we make it easier for people to communicate imprecisely about it, at the expense of making some things difficult to specify unambiguously
21:11:22 <radetsky> ddarius: nevermind, I get it
21:11:32 <faxathisia> there's no use fixing math (whatever that means...) you can use a formal language like haskell J or whatever if you want to represent things unambiguously
21:11:47 <lispy> J?
21:12:12 <radetsky> lispy: a huge improvement over haskell I
21:12:19 <ddarius> awesame: I have no problem with formal mathematics (meaning machine checkable), but that isn't what mathematicians write and that's not because they aren't aware of formal languages.
21:12:40 <faxathisia> lispy: J is a bit like APL, it's used (as APL is) in some math textbooks
21:12:50 <Saizan> yaru1022: you've to rebuild the documentation for unix with your current haddock, you need the sources of that package
21:13:00 <ddarius> With mathematics you are trying to communicate to a person and convince them exactly as you are in natural language.
21:13:04 <lispy> faxathisia: cool
21:13:16 <SamB> for instance, if I were to type $G(A,B,C) = \sum{}m(3,5,7)$, it wouldn't have a clue that this meant the same thing as to $G(A,B,C) = AC + BC$
21:13:46 <awesame> ddarius: it's interesting that you don't see a lot of examples of non-machine-checkable programming notation
21:14:08 <SamB> awesame: did YOU know that those were the same thing?
21:14:10 <awesame> maybe you could say that people are starting to use that when they elide details
21:14:30 <ddarius> awesame: Programs have to run on machines (though only aspects of them are machine checkable).  You don't write a program to convince someone of an argument (directly)
21:14:39 <radetsky> awesame: unless you're arbitrarily calling anything that's not machine-checkable "math", that isn't true
21:14:53 <radetsky> (that you don't see non-machine-checkable programming notation)
21:14:58 <SamB> ddarius: unless the argument is about whether you can do something in a program of a given class or not
21:15:14 <faxathisia> radetsky: You have some set of axioms for a logic that can't be machine checked?
21:15:33 <lispy> gwern: BTW, if you want to hackage-ize anything you find on that codersbase's wiki, just send me an email letting me know.  My address should be in any of the darcs repos you find there.
21:15:38 <faxathisia> radetsky: I seriously doubt that.. If it can't be machine checked it sure as hell can't be looked over by a person
21:15:44 <gwern> faxathisia: yes; one of his axioms requires an oracle :)
21:15:45 <radetsky> faxathisia: that's not what I'm talking about, but I'm sure one could be cooked up
21:16:10 * ddarius will be right back.
21:16:16 <SamB> how about a logic of humour?
21:16:21 <faxathisia> radetsky: I am arguing that if one existed it would it wouldn't be a math
21:16:29 <faxathisia> s/ a//
21:16:37 <lispy> if we removed the ambigous parts of speak, art becomes harder
21:16:40 <SamB> faxathisia: how about politics. can it be politics?
21:16:48 <radetsky> faxathisia: why?
21:16:51 <lispy> and so does humor, and I like math poetry and math jokes.
21:17:36 <awesame> radetsky: what's an example of non-machine-checkable programming notation?
21:17:56 <lispy> perl?
21:17:58 * lispy ducks
21:17:58 <Saizan> pseudocode?
21:18:06 <SamB> I think lispy has it on the nail
21:18:26 <radetsky> awesame: sketching the flow of a query through a tree of servers in a search engine
21:18:43 <SamB> (has the nail in it?)
21:18:43 <awesame> yeah, that works
21:18:53 <awesame> programmers resort to pictures a lot
21:19:04 <Saizan> heh, as if perl was anything-checkable
21:19:05 <wagle_home> perl is perfectly machine-checkable..  just not human-checkab;e for most humans
21:19:09 <awesame> and write pseudocode-like stuff where they elide details
21:19:14 <SamB> wagle_home: since when?
21:19:30 <gwern> ok... I guess linkchk will be my last upload for the night
21:19:31 <SamB> I was under the impression it could not safely be parsed
21:19:31 <lispy> wagle_home: actually, perl is technically not machine parseable
21:19:38 <lispy> wagle_home: there was a proof of this recently
21:19:44 <SamB> you have to run some of the code in order to parse the rest of it, sometimes
21:19:48 <wagle_home> SamB, since i can write one perl script and run it under many perl interpreters
21:19:54 <gwern> not staticly parseable, I remember the proof as being...
21:20:00 <lispy> gwern: correct
21:20:19 <wagle_home> machines parse perl all the time
21:20:20 <faxathisia> lispy, that's a huge difference :p
21:20:22 <lispy> But, the result isn't puerly academic
21:20:37 <awesame> wow, perl isn't statically parsable?
21:20:40 <awesame> dang
21:21:09 <Saizan> it's the same for lisp, right?
21:21:13 <lispy> faxathisia: well, when i said 'technically not machine parseable' i meant the traditional meaning of parsing which is what we're calling 'static parsing' here
21:21:22 <faxathisia> yes, CL
21:21:38 <lispy> I think template haskell may be the same way too
21:21:47 <SamB> well, if parsing perl amounts to the halting problem...
21:21:54 <lispy> but, i'm not sure about TH...
21:22:02 <awesame> is the deal with CL just macros?
21:22:26 <lispy> awesame: not the normal macros you're used to though.  I thinkit's the 'reader macros'
21:22:46 <gwern> no. I think you can also rewrite the language parser itself, although I dunno whetjer that actually involves macros
21:22:51 <lispy> as i understand it, the proof given in the perl example works whever you can take programmatic control of the lexer
21:22:52 <awesame> it makes sense that a language with a macro system isn't statically parsable
21:22:56 <SamB> template Haskell is totally machine parseable
21:23:00 <Saizan> lispy: in HEAD there's something like reader macros afaiu
21:23:10 <SamB> it gets executed in the typechecking stage
21:23:14 <wagle_home> i did a parser for scheme's reader macros..  wasnt a problem..  what does CL do thats a problem?
21:23:32 <lispy> Yeah, so then it's the reader macros not the regular macros in CL that are a problem.
21:23:46 <SamB> scheme has reader macros since when?
21:23:47 <lispy> The problem is that during the parse phase, you might need to evaluate something which is turing complete
21:24:00 <lispy> SamB: I mean CL
21:24:03 <wagle_home> ', , ,@
21:24:06 <lispy> I don't know any scheme
21:24:12 <SamB> wagle: those aren't reader macros
21:24:21 <SamB> those are syntax
21:24:26 <wagle_home> `(lambda (,var) ,@bodies)
21:24:37 <SamB> that happens to be equivalent to other, simpler syntax
21:24:56 <lispy> Think of it this way, perl requires stagged execution
21:25:05 <lispy> one of those stagges is during parsing
21:25:09 <lispy> stages*
21:25:17 <lispy> that means it cannot be staticly parsed
21:25:38 <lispy> if the first stage comes later, say during type checking, then it's not a problem for the parser
21:26:10 <lispy> SamB: so why is TH staticly type checkable?
21:26:53 <Saizan> lispy: you can't define new syntax with TH
21:26:54 <SamB> I never said it was statically typecheckable
21:27:25 <lispy> SamB: but, I thought TH claimed it was.
21:27:27 <SamB> Saizan: apparantly you don't need to define new syntax in perl
21:27:41 <wagle_home> in lisp, those are read macros.  in scheme, those are reader macros,  i dont know what they are in CL.  i asked what the problem is in common lisp.
21:27:41 <SamB> lispy: well, you need to run the TH code first
21:27:55 <SamB> then you can typecheck the results, sure
21:28:05 <faxathisia> wagle_home, There's no problem
21:28:08 <SamB> (well, first you typecheck the TH code itself ;-)
21:28:12 <SamB> (and compile it)
21:28:16 <lispy> wagle_home: I'd have to go check the hyperspec to give any more details
21:28:25 <wagle_home> <lispy> Yeah, so then it's the reader macros not the regular macros in CL that are a problem.
21:28:34 <SamB> http://perlmonks.org/?node_id=663393
21:28:36 <lambdabot> Title: Perl Cannot Be Parsed: A Formal Proof
21:29:26 <lispy> wagle_home: I started to learn about reader macros once, but I didn't make it very far and it's been a handful of years since then.  So I don't feel qualified to comment.
21:29:58 <dolio> CL reader macros allow you to arbitrarily extend the parser, no?
21:30:28 <faxathisia> Yes dolio
21:30:29 <dolio> More or less.
21:30:33 <wli> lispy: I've not quite got a usefully convergent process fully automated yet, but...
21:30:48 <wli> lispy: cf. (0 + x * (1.0003638715116236 + x * (0 - x * 0.11159882539208534))) / (1 + 5.6300716855935684e-2 * (x - 0.0)**2) vs. sin(x)
21:33:33 <P_D> pade?
21:34:14 * lispy fires up mathematica
21:34:43 <wagle_home> lispy, it was <faxathisia> wagle_home, There's no problem    that i was responding to, not you
21:34:44 <wli> P_D: No, Pade would be easy. Least absolute deviations rational regression, sampling sin(x) at (pi/2)*cos((pi/2)*(k/128)) for 0 <= k <= 128.
21:36:51 <radetsky> shit
21:36:53 <wli> P_D: i.e. the model is (a_0 + a_1*x + a_2*x^2 + a_3*x^3)/(1 + b_1 * (x - b_2)^2), where b_1 >= 0.
21:37:03 <radetsky> I finally got Conjure to build, read in a torrent, start up
21:37:11 <radetsky> and now I realize I have no way to tell if it's working
21:37:17 <lispy> wli: hah, nice at my resolution they overlap exactly
21:37:26 <P_D> chebyshev roots or something?
21:38:10 <wli> lispy: I think the maximum error is something like 9.0e-5 so it would probably be hard to spot.
21:38:30 <wli> P_D: Something less preposterous than a uniform grid.
21:38:44 <lispy> wli: nah, it's quite easy to spot the error on the interval [0..4Pi] :)
21:39:13 <wy> I'm a little confused about context free grammars. What's the general way to disambiguate a ambiguous grammar?
21:39:25 <lispy> general way?
21:39:28 <wli> lispy: eh, the sample points are all within [0, pi/2]
21:39:33 <lispy> iirc my profs always said it's not trivila
21:39:36 <lispy> er trivial
21:39:39 <SamB> radetsky: what? no webserver built in anymore?
21:40:01 <SamB> radetsky: no wireshark?
21:40:10 <wy> lispy: It seems not so trivial
21:40:53 <lispy> wy: my correction probably made what I said ambiguous.  being not trivial is what I remember...but my memory is not perfect
21:41:05 * wli mutters something about multicentered Pade and Hermite interpolation.
21:41:07 <P_D> the residual looks chebyshev
21:41:49 <wy> The tiger books says to change an ambiguous grammar, just use precedence and associativity. But it doesn't seem to work in some cases
21:42:36 <radetsky> SamB: wireshark is a good idea. I didn't think of that
21:42:54 <SamB> radetsky: also it used to serve status information by HTTP
21:42:56 <wli> P_D: It has a visual resemblance, but Remez turns up something rather different. I think there are bounds on these norms in terms of each other when functions are C^\infty and bounded or some phenomenally strong condition on super-well-behaved functions.
21:43:01 <SamB> it doesn't do that anymore?
21:43:24 <radetsky> I'm not sure
21:43:26 <wli> P_D: I ran Remez from a CAS and compared. It's very different.
21:43:33 <wli> (The CAS has it bundled.)
21:43:33 <faxathisia> 3
21:43:34 <P_D> is remez a chebyshev transform?
21:43:35 <awesame> hm, I wonder whether that argument about Perl being non-statically-parsable applies to Ruby
21:43:48 <wy> My example grammar is S->a S b S | b S a S | epsilon
21:44:12 <P_D> something weird.
21:44:14 <oerjan> wy: given that whether a grammar is ambiguous is undecidable it is not unexpected that there will be hard cases
21:44:31 <SamB> radetsky: I think netstat can tell you that
21:44:31 <faxathisia> wy, so do you have say, one string which has multpile parses in that?
21:45:05 <faxathisia> wy, (I don't know about grammars but I'm just curious what you mean)
21:45:08 <wli> P_D: Remez' algorithms yield the rational function that's the Chebyshev approximant with the maximum difference between the approximant f(x) and the function y(x) having its absolute value minimized.
21:45:24 <wy> there are many examples such as "abaabb"
21:45:40 <P_D> oh, ok.  I was thinking galerkin
21:46:07 <wy> oerjan: Is this part of theory of computation?
21:46:24 <wy> faxathisia: "abaabb" has two parses
21:46:55 <oerjan> wy: it's an example of an uncomputable question yes
21:47:25 <awesame> I think I just proved that Ruby isn't statically parsable: http://codepad.org/3KFdKApF
21:47:31 <wli> P_D: I'm just doing kitchen sink regression to get curves with good visual/aesthetic properties.
21:48:05 <awesame> (and that pygments understandably fails to get the syntax highlighting right on that last line!)
21:48:12 <wli> I guess it's something akin to mesh decimation.
21:48:24 <wy> oerjan: So... Does that mean we must use some genius?
21:48:45 <oerjan> wy: hm, i don't know whether every context-free grammar has an equivalent unambiguous one for the same language
21:49:18 <oerjan> it might be that your problem is generally unsolvable too
21:49:24 <P_D> the residual just looks oh so much like the 7th chebyshev t, so your method must be related to them somehow.
21:49:57 <SamB> did you now? http://codepad.org/7dFjarcW
21:50:19 <SamB> no wait, why did you say "this dies"
21:50:26 <wy> oerjan: In this example,  S ::= a S b S | b S a S | epsilon, S is the language for strings with the same number of a's and b's. It took me some time to realized that. Do you think a computer can know that?
21:50:27 <SamB> confusing me with your false claims
21:50:29 <awesame> SamB: that's what I expected your code to do
21:50:34 <cjb> is that Haskell?
21:50:37 <awesame> SamB: sorry, that's from the original perl
21:50:42 <cjb> oh, Ruby
21:50:42 <wli> There are theorems floating around somewhere on how the optimal fitted curves according to the \ell^1 norm of the error have some properties in common with Chebyshev polynomials.
21:50:57 <wli> I'm not even sure the precise norm matters.
21:51:07 <SamB> you can understand my confusion, but you can probably also see that I should be going to bed (or have done so already)
21:51:16 <awesame> heh
21:51:21 <P_D> right, there's something like the chebyshev fit is approximately optimal.
21:51:29 <wli> I expect not even L^p vs. \ell^p matters.
21:51:36 <P_D> ell?
21:51:50 <P_D> only familiar with L
21:52:19 <wli> P_D: L being integrals over an interval, \ell being the "little L" a.k.a. sums over discrete sets of sample points and function values tabulated for them.
21:53:15 <oerjan> wy: no idea
21:53:24 <P_D> oh.. I try to keep my discreteness purely handwaved.
21:54:14 <wy> I was just reminded an example from Godel, Escher, Bach, ...
21:54:24 <dibblego> Goedel
21:54:46 <wli> P_D: I eventually want to go after some real-life problems with this sort of kitchen sink regression. ;)
21:55:00 <wy> Is that a standard way to type that character in ascii?
21:55:03 <oerjan> Gdel (not UTF-8 here)
21:55:24 <dibblego> wy, you can replace ö with oe, but not o
21:55:30 <P_D> I've been doing some really silly regression stuff for work this week
21:55:42 <awesame> I was subtly wrong, ruby does not have this problem: http://po-ru.com/diary/ruby-parsing-ambiguities/
21:55:43 <lambdabot> Title: po-ru.com: Ruby parsing ambiguities
21:55:46 <awesame> </ot>
21:55:55 <wy> alright. So we have a real problem. We got something that really need human intelligence.
21:56:11 <P_D> some thermal experiments whose equilibrium temperatures I need.. but something always breaks before it reaches equilibrium, so I do exponential fits.
21:56:13 <ddarius> wy: What makes you think that?
21:56:19 <P_D> horrible, horrible, but that's life.
21:56:24 <largos> some time back I ran across a document that stepped through the early development of xmonad, discussing the types created and then the use of monads, etc... it was a really clear description of the code, and now... I can't find it.  does that ring a bell with anyone?
21:56:51 <wli> P_D: I'm thinking models of the form of Bessel series with rational functions for coefficients (the coefficients of the rational functions themselves being the real numbers comprising the parameters of the model) might be appropriate here.
21:56:57 <oerjan> ddarius: do you know an algorithm for turning an ambiguous CFG into an equivalent unambiguous one?
21:57:04 <wy> ddarius: I guess
21:57:10 <P_D> why bessel series?
21:57:31 <P_D> non constant coefficients?  Buh?
21:57:40 <adu> hi
21:57:53 <ddarius> oerjan: No, but that wasn't what he was discussing most recently and that's not necessary.
21:58:20 <adu> is there anything that implements the following parser combinator?
21:58:24 <adu> "one = try . choice"
21:58:40 <wy> oerjan: My idea of turning  S ::= a S b S | b S a S | epsilon is as follows. S ::= S T | epsilon, T ::= A | B, A ::= a A b | epsilon, B ::= b B a | epsilon
21:59:33 <adu> or any existing definitions for "(option ()) . try"?
22:00:01 <wli> P_D: Basically the n!^2 in the denominator of the series for J_0 drops off fast enough that I feel good about it. There's also the orthogonal function BS with scaling arguments by the positive roots of the Bessel function in each term etc.
22:00:09 <ddarius> adu: It wouldn't be smart to hide try's like that in those types of functions.
22:00:12 <wy> oerjan: The idea is to cut off the part on the right most side the strings like "ab", "aabb", "aaabbb", "ba", "bbaa", "bbbaaa", ...
22:00:27 <wli> P_D: Maybe throwing in some trigonometric voodoo would be good for my purposes, too.
22:00:32 <adu> ddarius: ok, then is that any shortcuts for "(option ())"?
22:00:35 <ddarius> adu: I mean it's fine for your own code, but it shouldn't be that way for "standard" functions
22:00:52 <ddarius> adu: What's wrong with option () or try . choice?
22:00:57 <wli> P_D: I'm a bit far off from being able to handle high-dimensional search spaces for all this just yet.
22:01:17 <adu> ddarius: I suppose its just a few extra characters...
22:01:28 <oerjan> wy: i don't think that quite works
22:01:50 <wy> oerjan: I'm not sure either. But it seems to work for my examples
22:01:52 <oerjan> consider bbabaa
22:02:00 <ddarius> Differentiating the CFG may provide insight.
22:02:37 <wy> ddarius: What do you mean by "differenctiating"?
22:02:38 * SamB can't find any information on CFGs in his table of derivatives
22:03:01 <lispy> SamB: better go back to the basics and use the limits definition
22:03:07 <faxathisia> Would it be possible to do the parse then turn that into a canonical form?
22:03:17 <ddarius> wy: That is the question.  You can differentiate regular expressions.  I suspect, a la e.g. Rutten's work, you could extend the notion (somewhat at least) to CFGs.
22:03:24 <wy> oerjan: you got me
22:03:30 <adu> i'm starting to love Parsec :)
22:03:41 <ddarius> adu: Everyone loves Parsec.
22:03:48 <SamB> I don't even know how to ADD cfgs
22:03:50 <faxathisia> adu, Yeah it's really fantastic
22:03:57 <SamB> er.
22:04:06 <SamB> the input to CFGs
22:04:27 <SamB> or divide the output
22:04:33 <SamB> or subtract the input...
22:05:18 <lispy> largos: hey
22:05:33 <largos> lispy: hola
22:05:57 <bos> malcolmw doesn't love parsec :)
22:06:18 <wy> oerjan:  S ::= a S b T | b S a T | epsilon, T ::= A | B, A ::= a A b | epsilon, B ::= b B a | epsilon
22:06:21 <oerjan> adu: optional
22:06:22 <ddarius> Malcolm's a bit odd in more ways than that.
22:07:02 <lispy> what about combinator libraries in general though?
22:07:12 <lispy> He must love those for the sake of Haskell elitism, right?
22:07:30 <ddarius> lispy: I only like well-done combinator libraries.
22:07:43 <lispy> you're a tuff audience :)
22:07:44 <faxathisia> uh.. you can do combinator parsers in C
22:07:47 <faxathisia> or anything
22:08:26 <wy> oerjan: No... abbbabaa
22:09:23 <ddarius> Perhaps human level intelligence is overrated?
22:09:59 <wy> ddarius: yeah...
22:10:24 <wy> We need more than one heads...
22:11:37 <adu> oerjan: cool, thanks
22:13:41 <oerjan> wy: http://en.wikipedia.org/wiki/Ambiguous_grammar#Inherently_ambiguous_languages
22:13:43 <lambdabot> http://tinyurl.com/29vay6
22:14:00 <oerjan> (it doesn't say anything about your example though)
22:15:02 <wli> P_D: Oh crap I'm in deeper doo doo than that. I've got to generalize it to functions of multiple variables more urgently than throwing in transcendentals.
22:15:16 <lispy> proving a grammar is inherently ambiguous is hard, I do remember hearing that
22:15:33 <P_D> the heck are you trying to do
22:15:55 <lispy> wli: I thought this was just for a tutorial you were doing?
22:15:58 <wli> P_D: Use (potentially multivariate) rational functions as models.
22:16:08 <lispy> wli: do you know have some general purpose use?
22:16:28 <oerjan> from the previous paragraph: "Some ambiguous grammars can be converted into unambiguous grammars, but no general procedure for doing this is possible just as no algorithm exists for detecting ambiguous grammars."
22:16:43 <wli> lispy: I don't remember ever planning to write a tutorial.
22:16:53 <P_D> where do transcendental functions come in?
22:17:09 <wy> oerjan: I'm getting another way to do it
22:17:15 <lispy> wli: sorry, my altshiemer's is acting up.  Do I know you?
22:17:23 <lispy> ;)
22:17:31 <wli> P_D: They're chunks of power series I'd want to futz around with to capture more of the behavior of a function.
22:17:46 <lispy> wli: I thought that's why you were doing this.  But, obviously I misremembered :)
22:17:51 <wli> lispy: AFAIK only from the channel.
22:18:31 <P_D> that sounds isomorphic to just rational functions to me
22:19:26 <lispy> ?users
22:19:26 <lambdabot> Maximum users seen in #haskell: 463, currently: 410 (88.6%), active: 15 (3.7%)
22:20:04 <wy> oerjan: The idea is that  T ::= A | B, A ::= a A b | epsilon, B ::= b B a | epsilon. T can cut off a substring from either front or end.
22:20:40 <wli> I'm thinking (K + A_1(x) + A_2(x, x) + A_3(x, x, x))/(1 + (L(x-b))^T(L(x-b))) (here L is the Cholesky factorization of a symmetric bilinear form a.k.a. matrix, K a scalar constant, and the A_k symmetric multilinear forms of arity k).
22:20:47 <wy> oerjan: I haven't proved it yet.
22:20:57 <oerjan> wy: i have doubts
22:21:07 <P_D> f(x,x,x) ?
22:21:09 <wy> oerjan: generate counterexamples
22:21:27 <oerjan> palindromizing one of the previous ones ...
22:21:48 <wli> P_D: A_3 is trilinear, so x^T A_3 x doesn't quite work. I think physicists have some less painfulnotation for all this.
22:21:55 <oerjan> aababb
22:22:20 <P_D> oh, Aijk
22:22:45 <oerjan> actually that was my first one renamed...
22:22:46 <wy> oerjan: S is something like S ::= a S b T | b S a T | epsilon now
22:23:34 <wy> oerjan: S ::= a S b T | b S a T | T a S b | T b S a | epsilon
22:23:52 <wy> maybe that's still ambiguous
22:23:53 <P_D> the rational thing gets really funny in multiple dimensions.
22:23:57 <wli> Tracking the coefficients in a fully general scheme appears vaguely murderous.
22:24:26 <wli> P_D: I'm utterly terrified of all the things that could go wrong there.
22:24:27 <oerjan> i suspect so too.  in fact it obviously is if you set S, T = epsilon
22:24:47 <wli> P_D: Any examples of how it gets weird?
22:25:23 <P_D> I mean you don't have division
22:26:02 <P_D> sometimes you can solve an equation that resembles division, sometimes it's not unique.. and I have no idea what happens when you go trilinear
22:26:09 <P_D> you're limiting yourself to bi in the "denominator"?
22:27:35 <wli> P_D: Yeah, basically so that I can rule out singularities by forcing the bits corresponding to a quadratic form in the denominator to be positive definite, then adding a constant (i.e. 1) so the denominator never vanishes.
22:27:48 <wy> oerjan: uhh... I guess the cutting way doesn't work at all
22:27:48 <P_D> Ahhhhh.
22:28:21 <wy> oerjan: I guess I should use some way of counting
22:28:26 <P_D> and that's why you're using numerical regression machinery, doing something analytical there is hopeless
22:29:00 <wli> P_D: I know about Grobner bases and multivariate polynomial division, though I'm clueless on how it corresponds to anything like shapes of surfaces or anything of that sort.
22:29:15 <P_D> shapes of surfaces?
22:30:40 <wli> Given the function f(x_1, ..., x_n) you get a surface defined by (x_1, ..., x_n, f(x_1, ..., x_n)) just like z = f(x, y) gets you a surface parametrized as (x, y, f(x, y))
22:31:13 <P_D> so?
22:33:28 <wli> For a rational function of one variable I know that the denominator gives you a "hump" at the minimum of the (positive definite quadratic) denominator and so on, and division gives you a vague idea of things being a + b x + (c + d x)/(1 + e(x-f)^2) etc. whose shape is easy to spot from all that. The multivariate case is nowhere near so easy to understand from casual inspection.
22:33:54 <paolino> (what is the meaning of comrades ?)
22:34:33 <wli> lambdabot has dictionaries.
22:35:19 <oerjan> @help babel
22:35:20 <lambdabot> babel <lang1> <lang2> <phrase>.
22:35:20 <lambdabot> Translate a phrase in lang1 to lang2.
22:35:20 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
22:35:30 <oerjan> @bab en it comrades
22:35:31 <lambdabot>   camerati
22:35:37 <wli> P_D: Does that make more sense?
22:37:17 <P_D> yes, I guess so.
22:37:49 <paolino> urgh, thanks
22:37:53 <wli> P_D: The good news, OTOH, is that apart from search spaces of higher dimensionality, the multivariate case is essentially no different from the univariate case as far as minimizing e.g. sums of absolute deviations with respect to coefficients goes.
22:38:25 <wy> @bab en el hello
22:38:26 <lambdabot>   can't parse this language
22:38:48 <OceanSpray> Is Haskell's design frozen as is, or will it progress like the Scheme R^xRs's do?
22:39:00 <lispy> ?version
22:39:01 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
22:39:01 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:39:04 <dmwit> We're all hoping for Haskell'
22:39:10 <lispy> I should upgrade to 6.8.2
22:39:13 <dmwit> so that we can start crafting Haskell''.
22:39:17 <dmwit> =)
22:39:24 <oerjan> OceanSpray: there is a haskell-prime committee hopefully working as we speak
22:39:35 <faxathisia> How do you do the babelfish right round?
22:39:36 <faxathisia> @@ @babel it en @run (" "++).(++" ")$ @babel en it " comrades "
22:39:38 <lambdabot>   "comrades"
22:39:44 <OceanSpray> Haskell'''?
22:39:58 <OceanSpray> somehow, I think that this naming scheme isn't extensible... :)
22:40:00 <dmwit> Before long, it will switch over to Haskell^4.
22:40:09 <scook0> OceanSpray: it's supposedly only temporary
22:40:16 <wy> OceanSpray: Isn't haskell changing right now?
22:40:16 <dmwit> or maybe Haskell^{(4)} =)
22:40:17 <wli> I think we should literally move on to a successor language of some sort. Say Haskell is Haskell and move on to something not bound by the chains of backward compatibility.
22:40:26 <scook0> i.e. Haskell' was chosen so they didn't have to argue about what it would actually be called
22:40:28 <awesame> and then Haskell 2008... wait...
22:40:30 <dmwit> wy: No, GHC is changing.  That's not the same thing.
22:40:48 <wy> dmwit: I remember the thing we are using is Haskell 98
22:41:02 <wy> so it's not that old ;)
22:41:09 * wli doesn't like Haskell 98.
22:41:10 <dmwit> wy: ...
22:41:19 <dmwit> heh
22:41:30 <dmwit> I mean, it's young for a human, but then it's not human.
22:41:53 <wy> Is the Haskell use are using Haskell 98?
22:42:02 <dmwit> Not often.
22:42:07 * oerjan realizes that the time passed since '98 is about the same as the time before that until the first haskell
22:42:13 <dmwit> I almost have at least two or three GHC extensions enabled.
22:42:34 <wy> dmwit: which ones?
22:42:43 <scook0> and in practice, I don't know of anyone who goes without hierarchical modules
22:42:51 <scook0> even when writing "Haskell 98" code
22:43:22 <OceanSpray> ten years.
22:43:23 <dmwit> wy: It depends on what I'm doing.  At least hierarchical modules, no monomorphism restriction, "extended instances" or whatever that one is called...
22:43:26 * wli wants multiparameter typeclasses, flexible instances, whatever gets cooked up to replace fundeps, monad transformers all over the standard libraries, monad comprehensions back, a totally different numeric hierarchy, a Prelude and standard libraries unashamed of higher-order parametric polymorphism. And so on.
22:44:01 <oerjan> hierarchical modules + ffi are semi-official extension though
22:44:06 <oerjan> *s
22:44:18 <wy> wli: Go get Scheme might be better for you I guess
22:44:42 <OceanSpray> Scheme has a standard library?
22:44:42 <wli> And that is not Haskell 98, nor can it be any backward-compatible successor thereof.
22:44:42 <awesame> monad comprehensions?
22:44:47 * awesame googles
22:44:49 <wy> and write your own type system in macros
22:45:05 <faxathisia> wy o_O
22:45:11 <wli> wy: No thanks.
22:45:58 * wy whats to get rid of sum types from the system
22:46:12 <dmwit> why?
22:47:26 <wy> I have headaches choosing type class or sum types
22:48:55 <wli> Haskell' is a conservative extension of Haskell '98. I'd rather have things be radical rather than conservative, and redesigns rather than extensions. ;)
22:50:32 <mwc> wy, reminds me of a quote: the reason to use Lisp is all the macros that help you avoid having to use Lisp
22:51:10 <wagle_home> domain specific languages!
22:51:10 <wy> mwc: ;)
22:51:17 <wagle_home> 8)
22:51:43 <dibblego> is it just me or is the emphasis on a function name disproportionate (meaningless alongside algebraic properties of a function?) to discussion of what is really important? (Haskell-Cafe, "Left? Right?")
22:52:33 <wy> Any more ideas on my ambiguous grammar? S -> a S b S | b S a S | epsilon
22:53:05 <awesame> ok (+1) $ monad comprehensions
22:53:26 <mwc> dibblego, no.
22:53:38 <dibblego> mwc, no, it's not just me?
22:53:39 <wy> It's weird that a human can recognize that this language generates strings with equal number of a's and b's, and try to rewrite it according to this "meaning"
22:53:40 <awesame> is there a way to make ghc understand them?
22:53:40 <wagle_home> macros let you transform scheme programs at compile-time..  so not the same as writing an interpreter in scheme for your DSL
22:53:43 <mwc> programming is really nothing more than just giving names to things
22:53:46 <mwc> well thought out names
22:54:02 <mwc> meaningful, well thought out names make the source more legible and intuitive
22:54:09 <dibblego> mwc, isn't the "things" the important part then?
22:54:15 <faxathisia> mwc, I disagree...
22:54:26 <dibblego> uh oh, I don't want to start it here
22:54:32 <wagle_home> so its being pointless to not give names to things?
22:54:58 <dmwit> wy: What's your actual question about the grammar?
22:55:21 <wy> dmwit: I want to disambiguiate it
22:55:54 <faxathisia> wy, maybe you should try to prove it can't be? (and see where that leads{
22:56:18 <wli> awesame: So you like monad comprehensions, then?
22:56:20 <mwc> faxathisia, the other stuff is mathematics, what goes in the programmer's brain
22:56:23 <dmwit> wy: Introduce an A term that requires an "additional a" and a B term that requires an "additional b", I think that gets you where you want to go.
22:56:34 <dmwit> (Let me think a bit longer, though... =)
22:56:51 <mwc> his interaction with the computer is expressing a mathematical structure in a way that a computer can interpret it, but moreover, in a way that's rich and documentative for other people
22:57:13 <awesame> wli: yeah!  they seem like a natural syntax for lots of simple constructions.
22:58:19 <wli> awesame: I've not figured out how to get anything done in the ghc codebase and sort of doubt I'll get to that point anytime soon.
22:58:34 <wli> awesame: So, sadly, it will have to wait for someone else to get around to it.
22:58:42 <wagle_home> why'd they get rid of monad comprehensions?  (i got a vague answer before0
22:58:59 <wy> dmwit: http://en.wikipedia.org/wiki/Context_free_grammar#Example_3
22:59:12 <adu> whats a monad comprehension?
22:59:42 <wagle_home> there's a straightforward conversion from monad comprehensions to do syntax..  i did it one for a large program
22:59:50 <dmwit> wy: Aw, yeah, the grammar I was thinking of was ambiguous, too. =/
23:00:07 <wy> dmwit: The last production is just what I have
23:00:41 <dmwit> wy: Do you have some reason to believe that there is a non-ambiguous grammar for this language?
23:00:51 <dmwit> wy: (It is not always so.)
23:01:20 <wy> dmwit: uhh... I can't tell you. But believe me ;)
23:01:44 <dmwit> wagle_home: They got rid of them to protect programmers who were new to Haskell.
23:01:54 <awesame> wy: a while back, you said you thought it was weird that a human could figure out what language your grammar generates.  I don't think that's weird, because it does generate that language.  it just does so with ambiguous parse trees.
23:02:05 <dmwit> wagle_home: A thoroughly bad reason, in my opinion, but that was the reason.
23:02:24 <dmwit> adu: A monad comprehension is a generalization of the list comprehension to other monads.
23:02:35 <mwc> dmwit, now now, before they were slain, monad comprehensions razed several towns
23:02:39 <mwc> they had to be stopped.
23:02:53 <adu> dmwit: ic
23:03:10 <wli> ... and thus the language was castrated in yet another way
23:03:19 <dmwit> adu: [result | x <- m, p] translates to do { x <- m; guard p; return result }.
23:04:23 <adu> woah! gaurd is a firstclass function?!?
23:04:37 <adu> thats awesome!
23:04:47 <mwc> sure it is
23:04:50 <mwc> @src guard
23:04:51 <lambdabot> guard True  =  return ()
23:04:51 <lambdabot> guard False =  mzero
23:05:10 <wy> awesame: right... a computer with a proper program can also make a guess like that and try to prove it
23:05:37 <adu> mwc: hmm, but how does that apply to x at all?
23:05:55 <mwc> well, guard applies to the monadic computation
23:05:59 <mwc> @type guard
23:06:00 <adu> ok
23:06:00 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:06:09 <adu> that makes sense
23:06:23 <adu> but how would that produce the same as [result | x <- m, p]
23:06:24 <mwc> so it applies to instances MonadPlus, specifically
23:06:48 <adu> i guess i still don't get the list monad
23:07:07 <mwc> the monad comprenhension was syntactic sugar for the do notation dmwit showed you
23:07:21 <mwc> oh, [result | x <- m, p] has nothing to do with lists
23:07:36 <mwc> it's a different kind of comprehension
23:07:39 <wagle_home> is there a theorem that return z /= mzero?
23:07:46 <wagle_home> is there a theorem that return () /= mzero?
23:07:53 <adu> mwc: now your just pulling my leg ;)
23:07:55 * wli projectile vomits over the confounding of Monad and MonadPlus with Monad0.
23:08:35 <adu> whats Monad0?
23:09:40 <mwc> if I had to guess, it would be Monad extended with mzero, but not with mplus
23:09:43 <wli> It used to be that there was a class called Monad0 with a method called "zero" (no leading 'm' mind you), and when do blocks or monad comprehensions got patterns to match that could fail, Monad0 constraints were imposed.
23:09:52 <dmwit> wagle_home: mzero :: m a (for all a)
23:09:57 <awesame> yeah, that's a bad point about monad comprehensions, []s make people think lists
23:10:02 <wli> Things had nicer names back then.
23:10:17 <wagle_home> :t mzero
23:10:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
23:10:23 <wli> e.g. Functor's method was "map" not "fmap"
23:10:24 <mwc> wli, as opposed to the current fail?
23:10:33 <dmwit> wagle_home: So, yes, return () /= mzero. =P
23:10:42 <wagle_home> :t return ()
23:10:42 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
23:10:45 <adu> wli: huh
23:10:48 <wli> mwc: Diametrically opposed to the current fail crap.
23:11:00 <mwc> that would be much nicer
23:11:05 <wli> IIRC MonadPlus' method was (++)
23:11:27 <wli> Not "mappend" nonsense.
23:11:37 <mwc> wli, that should go back into Haskell'
23:11:43 <adu> what I don't understand is why haskell never uses '_'
23:11:43 <lispy> I'm not against making the language more consistent and cleaning it up like this, but what about all the code out there now that would break?
23:11:44 <mwc> fail is a wart that makes me cringe
23:11:54 <mwc> adu, culture
23:11:58 <wagle_home> one day i will sit down and get a solid understanding of existential types
23:12:01 <wy> dmwit: I seem to have got it.
23:12:04 <lispy> never uses _?
23:12:19 <adu> mwc: but_then_why_allow_it_in_valid_identifiers?
23:12:25 <wli> lispy/mwc: It won't happen in Haskell'; they have design goals precluding it.
23:12:44 <mwc> Adamant, I think that since you have to use CapNames for types and constructors, and smallNames for identifiers, people just use camelcase
23:12:47 <paolino> wagle_home: leave the chair hot for me when you are done
23:13:01 <lispy> darcs uses a lot of foo_bar identifiers
23:13:01 <mwc> From what I've seen, camel case and underscore_naming never coexist
23:13:05 <wy> S -> a S b T | T, T -> b T a T | epsilon. Haven't verified yet
23:13:06 <wli> lispy/mwc: Better to start pushing such things toward some other effort, like Haskell2.
23:13:09 <lispy> mwc: look at darcs
23:13:30 <adu> wagle_home: what makes existential types different from normal types?
23:13:42 <siti> they can be extended
23:13:42 <lispy> mwc: the convention there is that foo_bar is internal to the module and fooBar is exported (or is it the other way?)
23:13:49 <mwc> fair enough
23:13:58 <adu> I'd like to see Haskell--
23:14:00 <wagle_home> the "i hide stuff away" part
23:14:17 <lispy> mwc: but it's inconsistently used and I'd like to see camel case win
23:14:23 <mwc> still, most programmers like either camel case or underscore/all-lower-case naming like the STL
23:14:23 <dmwit> Haskell++
23:14:25 <adu> like basically Haskell without the standard Prelude
23:14:39 <adu> then I could make my own numeric classes from scratch :)
23:14:43 <mwc> adu: import Prelude ()
23:14:45 <dmwit> adu: Just hide the Prelude, it's easy.
23:14:54 <adu> o really? I love Haskell!
23:14:57 <awesame> what always bugs me about camel case is what to do with acronyms and single-letter words
23:14:57 <wagle_home> i didnt say it was incomprehensible, just that i havent gotten around to sitting down and comprehending it
23:15:17 <awesame> cParser or CParser?
23:15:20 <lispy> adu: iirc there are alternative preludes out there that have better numerical heirachies
23:15:25 <wli> adu: No, it's not enough. The desugaring of numeric literals already screws you, Prelude or not.
23:15:25 <mwc> lispy, I use camelcase in Haskell, elsewhere I much prefer STL-style identifiers
23:15:29 <adu> lispy: like what?
23:15:30 <siti> awesame: yeah I have ran in to the same problem recently
23:15:36 <wagle_home> ..  so i get surprised by return () /= mzero results
23:15:40 <awesame> makeHTMLThing or makeHtmlThing?
23:15:57 <awesame> worse, makeCThing?
23:15:59 <mwc> awesame, imao, the latter is better
23:16:11 <lispy> adu: I'd have to google to find them.
23:16:21 <lispy> adu: maybe people stopped publishing such thungs?
23:16:22 <lispy> er things
23:16:32 <siti> maybe just have MakeHyperTextMarkupLanguageThing ;)
23:16:41 <awesame> heh
23:17:00 <dmwit> wagle_home: You should think of mzero as a computation yielding *no* results.  To contrast, "return ()" is a computation yielding one result: ().
23:17:02 <awesame> I do Html in camel-case, but I think that puts me in the minority
23:17:02 <wli> adu: There are a few other badnesses, mostly the numeric intrinsics' interdependencies on the numeric hierarchy.
23:17:08 <adu> like I'd also like to see "instance Num Polynomial where ..." and stuff
23:17:08 <lispy> or put it in a typeclass where the return value is polymorphic and call it fromThing
23:17:10 <paolino> make an Heclipse before that
23:17:32 <dmwit> wagle_home: i.e. it's the difference between [] and [()].
23:17:35 <wli> ahu: If you tolerate Num you're way behind the curve.
23:17:40 <dmwit> (in the list MonadPlus)
23:17:40 <wagle_home> dmwit, i've had it explained more like it is a result, you just dont get to know what it is
23:18:05 <dmwit> Oh, I have to go.  good luck
23:18:07 <adu> wli: I'm not saying I tollerate it, I'm just trying to express myself
23:18:22 <mwc> adu, most haskeller's have formal mathematics backgrounds
23:18:23 <wy> dmwit: see ya
23:18:26 <adu> wli: what is your idea of what 'Num' should be like?
23:18:38 <mwc> and want to have separate typeclasses for Ring and Field and Group
23:18:47 <siti> I hate math yet I like haskell :P
23:18:47 <adu> mwc: like Sage?
23:19:00 <mwc> I can't wait until they get into a slugfest over using + or * for the associative group operation ;)
23:19:08 <awesame> heh
23:19:31 <wli> adu: Ring, semiring, additive monoid instance, multiplicative semigroup instance, etc.
23:19:53 * wy hopes he knows the four pillars of the foundation of mathematics
23:20:10 <adu> wli: like Sage?
23:20:32 <wli> adu: Sage being what?
23:20:34 <adu> thats it! I should model my Prelude after Sage!
23:20:50 <awesame> mwc: they should use .
23:20:59 <wy> siti: Do you hate all math or just the numerical part?
23:21:08 <adu> only the best umbrella CAS ever!
23:21:09 <adu> http://www.sagemath.org/
23:21:09 <lambdabot> Title: SAGE: Open Source Mathematics Software
23:21:11 <wli> adu: Nontrivial nonstandard Preludes require hacking the compiler to fix up hardwired intrinsics.
23:21:46 <lispy> wli: such as? n+k patterns?
23:21:50 <adu> Sage combines approx 20 opensource CASs into one, and provides a front-end to all of them using Python
23:21:53 <wagle_home> hmm..  can a newtype monad have an mzero?
23:22:19 <adu> it has a really nice set of types
23:22:27 <wagle_home> (ie, only one constructor)
23:22:41 <siti> wy: I don't mind doing the calculations, I done some discrete math at university and I couldn't stand it (I used to like math before)
23:23:00 <siti> wy: I just like how programs have to be totally consistent to compile
23:23:07 <lispy> siti: try abstract algebra you might enjoy math again
23:23:30 <awesame> abstract algebra saved math for me
23:23:32 <siti> it seems like everyone has their own version of math with different and weird conventions, e.g. theta for angles etc
23:23:36 <siti> lol
23:23:42 <siti> I'll stick with haskell ;)
23:23:48 <adu> awesame: awesome!
23:24:03 <JakeP> what's the best/a good way to do memoizing in haskell?
23:24:11 <wy> awesame: what about category theory?
23:24:24 <mwc> siti, hah. When I was an undergrad doing a double major in (theoretical) physics and applied math
23:24:24 <awesame> wy: I'm not there yet!
23:24:42 <mwc> phycists and mathematicians have reversed conventions for the angle names in spherical coordinates
23:24:49 <dons> JakeP: store results in a list
23:24:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:24:54 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- JakeP that is one way using lists
23:24:54 <lambdabot>  Parse error at end of input
23:24:57 <siti> sounds nasty :(
23:25:01 <wy> awesame: I heard that it's an extension of universal algebra
23:25:03 <dons> JakeP: there's a lot of fancy ones that use weak pointers and so on
23:25:06 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs -- JakeP that is one way using lists
23:25:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:25:27 <faxathisia> JakeP, one way is instead of having f x = <calculation> !! x, fs = <calculation>
23:25:43 <faxathisia> JakeP, then you do fs !! x elsewhere and those get memod
23:25:51 <JakeP> yeah, I get that for simple things, what about more complex examples? Like more than one dimension
23:25:59 <wy> awesame: I read a little about it and it's not that boring given that I know I can make better use of monads after knowing it ;)
23:26:00 <adu> wy: category theory is not so much an extension of universal algebra, because howver abstract categories are, they are algebraicaly not must different than monoids
23:26:00 <dons> right, so structure the program to refer to results previously calculated in a data structure
23:27:23 <awesame> category theory doesn't sound boring to me at all
23:28:53 <wli> lispy: No. Various assumptions are floating around all over. The fromInteger bits do bad things to attempts to incorporate natural numbers in the numeric hierarchy, for instance.
23:29:03 <wy> I guess I'll be interested in more math if I spent some time in solitude getting the foundations
23:29:08 <adu> wy: if (set, op) is a monoid, then the category (ob, mor, .) means f :: ob -> ob forall f in mor, and (mor, .) is a monoid
23:29:37 <sieni> wy: foundations as in set theory or what?
23:30:03 <wy> sieni: set theory, proof theory, recursion theory, model theory
23:30:11 <wagle_home> wli: example?
23:30:25 <wli> That was an example.
23:30:45 <radetsky> wy: why the hell would you want to learn that shit?
23:30:57 <adu> wy: the "foundations" consist of (depending on where you come from): (Set|Type|Category|Graph|Parser|Model) theory
23:30:59 <wy> radetsky: which one is shit?
23:31:05 <wagle_home> what bad things does it do?
23:31:07 <radetsky> set theory is the most godawfully boring branch of mathematics ever devised
23:31:27 <wy> adu: No I don't think type theory is one of the foundations
23:31:29 <adu> radetsky: nope, Operad theory is most boring
23:31:41 <siti> all is boring :p
23:31:47 <lispy> This has become #math tonight :)
23:31:54 <adu> wy: isn't it the foundation of lambda calculus?
23:32:03 <wy> radetsky: then what is interesting to you?
23:32:19 <faxathisia> adu, No
23:32:23 <radetsky> wy: bitches and money
23:32:36 <radetsky> type theory might at least be useful to you
23:32:44 <wli> wagle_home: For starters, you get forced to call your fromNatural function fromInteger, and then the intrinsics libs under GHC.* pass negative numbers to it in various places.
23:32:51 <lispy> radetsky: then you consider the set B of bitches in your town, and the set S, of money you make in your life ;)
23:33:02 <adu> then I have a skewed view of foundations
23:33:20 <mrd> set theory is more useful for foundations-of-math, rather than programming
23:33:25 <faxathisia> adu, There is lambda calculus which has no types at all
23:33:26 <wagle_home> wli: i get it..  thanks
23:33:33 <wli> wagle_home: Not to mention arguments specifically declared to be of type Integer vs. Natural.
23:33:39 <faxathisia> adu, As a logic, it's inconsistent though
23:33:43 <radetsky> faxathisia: typed lambda calculus ftw!
23:33:48 <adu> my favorite foundations are Graph theory and Model theory
23:34:00 <faxathisia> adu, So typing was devised for it which gives us consistency again
23:34:12 <lispy> wli: how can we decide if Nat starts at 0 or 1?
23:34:14 <awesame> what's model theory about?
23:34:21 <faxathisia> adu, but that's not to say something like haskell is consistent (as a logic), which it's not
23:34:34 <adu> awesame: mappings between representations and models
23:34:40 <ivanm> wli: depends if you're a mathematician or a computer scientist :p
23:34:45 <ivanm> s/wli/lispy
23:34:54 <wagle_home> where is [1..] used as a number system?
23:34:54 <mrd> lispy: whatever feels natural
23:35:04 <wli> lispy: Programming languages follow the computer science convention vs. other areas of mathematics that might use other conventions.
23:35:11 <adu> faxathisia: ic
23:36:04 <lispy> So we should keep counting from 0 because of tradition and not some other reason?
23:36:16 <siti> from 0 is awesome :P
23:36:25 <adu> from 1 is awesome :)
23:36:27 <awesame> it's because 0 comes *first*
23:36:28 <wy> faxathisia: why must it be consistent?
23:36:42 <radetsky> let's start counting from -1
23:36:45 <ivanm> awesame: but -1 comes _before_ 0!
23:36:51 <faxathisia> wy, Not sure what you mean, can you elaborate a bit?
23:36:57 <wli> lispy: Welcome to social constructivism or whatever it's called.
23:36:59 * ivanm thinks we should start counting at i
23:37:08 <lispy> The frustrating part here is that in math you just say, "Well, they are isomorphic so ..." but in a program it's more tedious to say that.
23:37:12 <wagle_home> -1 isnt a number, its the subtract-one function!  8-p
23:37:30 <wy> faxathisia: You said lambda calculus is inconsistent as a logic. I mean, is there other use of it other than logic?
23:37:41 <awesame> > -1 :: Expr
23:37:44 <lambdabot>  negate 1
23:37:59 <radetsky> PWNED!!!
23:38:01 <faxathisia> wy, Yes, untyped lambda calculus is the basis of Lisps for example
23:38:02 <awesame> > (subtract 1) :: Expr
23:38:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `t -> t'
23:38:07 <awesame> hm
23:38:11 <lispy> lisp is typed
23:38:12 <wli> ivanm: Knuth's high school science project was a number system of radix 2i (IIRC).
23:38:25 <faxathisia> wy, And inconsistent typed calculus are used as languages too
23:38:36 <faxathisia> lispy, Yes the language has types
23:38:44 <wy> faxathisia: I guess there is more than logics in this thing
23:38:58 <faxathisia> lispy, It's foundation is untyped lambda calculus though
23:38:58 <mrd> wy: it's inconsistent because it's turing-complete
23:39:05 <adu> awesame: I think the most profound realization I had regarding model theory was when I read about "Simulacra and Simulation" which amounted to saying that if all you see is representations of representations of representations, then it is possible that, in the end, they are not representing anything at all but themselves...
23:39:06 <sieni> http://en.wikipedia.org/wiki/Quater-imaginary_base
23:39:08 <lambdabot> Title: Quater-imaginary base - Wikipedia, the free encyclopedia
23:39:12 <mrd> wy: with the Y combinator you can express the equivalent of x = ~x
23:39:45 <wagle_home> my dictionary is precise on the definition of natural number:  "... and sometimes zero as well ..."
23:40:06 <wy> wli: I don't very much like Knuth's work. He makes things without abstraction
23:40:22 <lispy> Natural :: (Maybe Integer, [Integer])
23:40:32 <ivanm> wli: :o
23:41:02 <radetsky> wy: I think you mean "he uses shitty programming languages"
23:41:11 <radetsky> he uses a crapload of abstraction
23:41:21 <radetsky> READ TAOCP
23:41:24 <wy> radetsky: and he makes, too...
23:41:29 <wagle_home> zero = []
23:41:29 <radetsky> (lulz)
23:41:33 <faxathisia> hopefully the language is not the important thing...
23:41:36 <wagle_home> succ x = powerset x
23:41:56 <mrd> radetsky: not a MIX fan? eh ;)
23:42:05 <faxathisia> wagle_home, Isn't powerset [] = [] ?
23:42:06 <wli> It means something for a programming language to be typed. Lisp does not do what being a typed language means.
23:42:13 <wy> radetsky: I wonder if there are anybody really got throught TAOCP
23:42:19 <wagle_home> no..  its [[]]
23:42:28 <mrd> wy: knuth.
23:42:33 <wli> wy: Yes.
23:42:33 <adu> woah! base Q is totally blowing my mind
23:42:40 <faxathisia> wagle_home, I don't think that's correct
23:42:42 <wy> mrd: himself ;)
23:42:42 <wli> adu: Base Q?
23:42:53 <adu> sieni's link
23:42:55 <wagle_home> "the set of all subsets"
23:42:58 <radetsky> wy: it's not so bad if you read the algorithms and skip the programs
23:43:06 <wagle_home> one subset..  the set itself
23:43:09 <wli> adu: Quater-imaginary base?
23:43:13 <wy> There are actually two types in Lisp
23:43:21 <faxathisia> wagle_home, This post agrees with you http://www.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
23:43:21 <lambdabot> Title: powerset, http://tinyurl.com/ynmymy
23:43:43 <adu> wli: yes
23:43:54 <faxathisia> wagle_home, ok I see it now
23:44:29 <wy> radetsky: He doesn't explain where the algorithms came from either
23:44:50 <wli> wy: Okay, you're going to muck around and try to confound typing with mechanical implementations. s/typed/statically typed/
23:45:08 <dibblego> ?index forever
23:45:08 <lambdabot> bzzt
23:45:12 <mrd> wy: T and NULL?
23:45:32 <dibblego> ?src forever
23:45:32 <lambdabot> Source not found.
23:45:34 <wli> \bot and \top in LaTeX
23:46:02 <wy> mrd: oh maybe I got it wrong. There might be more than two
23:46:13 <faxathisia> wy, A term is a variable, application or lambda abstraction
23:46:36 <wy> radetsky: I often feel he is trying to hide the truth
23:46:37 <faxathisia> In lisp you have   x  (f a b ...)  (lambda (x) ...)
23:46:40 <mrd> well, I think most would say just one.
23:47:03 <wy> The true source of ideas
23:47:03 <faxathisia> In haskell   x   f a  \x -> ....
23:47:04 <mrd> untyped lambda calculus like a lambda-calculus with exactly one type, which everything is
23:47:31 <faxathisia> The lambda terms are untyped in the lisp one.. you can put them together in any way you like
23:47:41 <faxathisia> In haskell there are rules where you put them
23:47:49 <lament> i thought untyped meant no possibility of type errors
23:47:56 <lament> as in, there're no type-limited operations
23:48:12 * decker waves to the channel
23:48:27 <faxathisia> The rest of the language like numbers .. etc etc, can have type but that's a different thing, it's not so fundamental
23:48:30 <lament> you can apply any operation to any value and you will not get an error
23:48:33 <faxathisia> Hello decker
23:48:37 <adu> sieni: where did you learn about that?
23:48:41 <mrd> lament: no
23:48:48 <decker> hi i'm really new to haskell and i have few questions about types
23:48:56 <mrd> lament: in the untyped lambda calculus, if you attempt to do that, you will get a "stuck" term
23:49:11 <lament> mrd: i suppose you could call those type errors
23:49:14 <mrd> lament: the purpose of a type system is to ensure that "well-typed terms do not get stuck"
23:49:20 <decker> when i declare a function i use the type signature:  Floating a => [a]
23:49:29 <wagle_home> so normal forms are type errors?
23:49:35 <mrd> decker: not a function, just a list, that is
23:49:46 <faxathisia> wagle, no
23:49:53 <decker> no i know i was just giving an example but my question is this
23:49:53 <mrd> wagle_home: if you have a normal form that is not a value, then you are stuck
23:50:04 <decker> how do i make my own type using Floating
23:50:05 <wagle_home> i know, thats just what lament was implying
23:50:15 <decker> like newtype Weights = Floating a => [a]
23:50:20 <decker> or something
23:50:29 <mrd> decker: do you mean "how do I make one of my types an instance of Floating?"
23:50:34 <decker> yes
23:50:48 * decker is still confused about haskell's class structure
23:50:54 <mrd> instance Floating MyType where ...
23:50:57 <wy> faxathisia: One of the few things I don't like from Lisps is it's not convenient for currying
23:51:04 <mrd> but I'm not sure that makes sense with that example you just typed
23:51:17 <decker> well you know how you can say newtype Weight = [Float]
23:51:23 <mrd> you can't
23:51:32 <mrd> you need a constructor
23:51:33 <faxathisia> wy, I find that it's very easy to curry in lisp
23:51:40 <decker> so i should use data?
23:51:50 <wy> faxathisia: but you can't do it with just applications
23:51:52 <radetsky> type Weight = [Float]
23:51:55 <dibblego> decker, you need a constructor name regardless of which you use
23:51:55 <mrd> newtype Weight = W [Float]
23:52:21 <decker> and then later i use W as a constructor?
23:52:24 <radetsky> I think
23:52:26 <mrd> yes
23:52:33 <decker> so how do i do the same thing for all Floating types
23:53:13 <mrd> newtype Floating a => Weight a = W [a]
23:53:26 <decker> AWESOME thank you so much
23:53:49 <decker> as an aside, under what circumstances is the constructor necessary?
23:54:05 <adu> decker: if you want "type Weight = [Float]" will make it so that you can use Weight and [Float] interchangable in the types of your functions
23:54:08 <mrd> newtype/data create "new" algebraic data types with constructors generated
23:54:31 <mrd> yes you could also write that with "type" which makes just a synonym and then the constructor is not used
23:55:00 <decker> so it would be type Floating a => Weight a = [a]?
23:55:51 <decker> to give this some context
23:55:54 <adu> decker: only if you declared it as "data Weight a = Weight [a]"
23:56:18 <mrd> hmm, no that doesn't work, you'd have to restrict it to Floating wherever you used it
23:56:18 <decker> i have function types like this
23:56:19 <decker> feedNetwork :: Floating a => ([[a]], [[a]], a, a) -> [a] -> [a]
23:56:22 <mrd> like that
23:56:25 <wli> Hmm. Do things have to be continuously differentiable for e.g. conjugate gradient or BFGS, or are the derivatives allowed to have discontinuities, perhaps of restricted kinds?
23:56:34 <decker> and i would like just to say (Weights, Weights, Weight, Weight)
23:56:34 <adu> decker: then you want "type Weight = [Float]"
23:56:48 <mrd> then you could write Floating a => ([Weight a], [Weight a], a, a) -> Weight a -> Weight a -- perhaps
23:57:18 <adu> and "type Weights = [Weight]"
23:57:44 <decker> what is the difference between Floating and Float?
23:58:00 <adu> decker: Floating is a type-class, Float is just a type
23:58:00 <mrd> Floating is a type-class, Float is a type
23:58:00 <wagle_home> > 1/2 :: Floating
23:58:01 <lambdabot>      Class `Floating' used as a type
23:58:01 <lambdabot>     In the type `Floating'
23:58:01 <lambdabot>     In an exp...
23:58:04 <mrd> wewt
23:58:26 <decker> Floating contains all float types like Float, Double, etc?
23:58:29 <thoughtpolice> decker: floating is a type class; Float is an instance of Floating, as well as Double I believe
23:58:33 <thoughtpolice> @instances Floating
23:58:34 <lambdabot> Double, Float
23:58:35 <adu> decker: or another way to word it, "Floating" is a parameterized type, "Float" is a type with no parameter
23:58:35 <sieni> adu: google
23:58:37 <wagle_home> > 1/2 :: Floating a => a
23:58:39 <lambdabot>  0.5
23:59:16 <wagle_home> > Pi :: Floating a => a
23:59:16 <lambdabot>   Not in scope: data constructor `Pi'
23:59:18 <decker> but if i have a function which returns Floating a must i later always refer to the value which is returned from that function as Floating a or can I use Float, Double?
23:59:20 <adu> decker: Floating doesn't contain anything, it simply provides an interface
23:59:20 <wli> a.k.a. a "ground type"
23:59:24 <wagle_home> > pi :: Floating a => a
23:59:24 <lambdabot>  3.141592653589793
23:59:30 <wagle_home> > pi :: Double
23:59:31 <lambdabot>  3.141592653589793
23:59:38 <wagle_home> > pi :: Float
23:59:38 <lambdabot>  3.1415927
23:59:42 <wagle_home> ha!
23:59:49 <adu> decker: parameterized types are somewhere between C-templates, and Java-interfaces
23:59:58 <decker> okay
