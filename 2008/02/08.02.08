00:02:12 <vincenz> zip = zipWith (,)
00:05:29 <quicksilver> zipWith f = map (uncurry f) . zip
00:05:56 <quicksilver> zipWith = (. zip) . (map .) . uncurry
00:05:59 <quicksilver> or something ;)
00:06:11 <quicksilver> @pl \f -> map (uncurry f) . zip
00:06:11 <lambdabot> (. zip) . map . uncurry
00:06:12 * vincenz looks for a stick
00:06:16 <quicksilver> I was close
00:06:32 <vincenz> quicksilver: I prefer zip in terms of zipWith
00:06:32 * quicksilver applies a bugfix to the @pl in his head
00:06:34 <vincenz> if you don't mind
00:06:42 <quicksilver> I think that's quite fair.
00:06:57 <quicksilver> I just thought the reverse identity was an interesting curiosity
00:07:04 <vincenz> btw
00:07:05 <vincenz> you're wrong
00:07:14 <vincenz> zipWith f = (map (uncurry ). ) . zip
00:07:17 <vincenz> two lists
00:07:24 <quicksilver> ah yes
00:07:44 <quicksilver> zipWith f = map (uncurry f) .: zip
00:07:54 <vincenz> nifty
00:07:57 <vincenz> now we just need unicode
00:07:58 <vincenz> to have triple dots
00:08:02 <vincenz> .:T
00:08:07 <vincenz> where T = three dots above each other
00:08:16 <quicksilver> where (f .: g) x y = f (g x y)
00:08:26 <vincenz> that's a neat hack :)
00:08:30 * quicksilver nods
00:08:42 <quicksilver> I don't really use it in practice ;) can't be bothered
00:08:49 <vincenz> (f ... g) x y z =  f (g x y z)
00:08:57 <vincenz> etc.
00:09:03 <quicksilver> or ..: perhaps
00:09:32 <vincenz> nah, it loses its meaning then
00:09:48 <vincenz> ..: makes me think more of 4
00:09:54 <quicksilver> true
00:10:10 <vincenz> at least with .: you can look at either the horizontal or vertical
00:22:24 <yondalf> @pl zipWith (,)
00:22:24 <lambdabot> zip
00:24:32 <dolio> @pl 1 + 2 + 8
00:24:32 <lambdabot> 11
00:25:13 <yondalf> @pl if True then 1 else 2
00:25:13 <lambdabot> if' True 1 2
00:25:22 <yondalf> @src if'
00:25:22 <lambdabot> Source not found. I feel much better now.
00:25:42 <dolio> There is no if' really.
00:30:46 <wagle_home> @pl if'
00:30:46 <lambdabot> if'
00:31:04 <wagle_home> what?!?  no flip calls?
00:34:31 <olsner> I guess it either uses if (built-in) or pattern matching (not pointless)
00:37:15 <quicksilver> I don't think it makes a lot of sense to distinguish between the two
00:37:40 <quicksilver> if foo then bar else baz is simply suntactic sugar for case foo of True -> bar ; False -> baz
00:40:35 <olsner> this is why haskell should church-encode all data
00:42:56 <quicksilver> not sure I follow
00:43:09 <quicksilver> church-encoding is an implementation issue
00:43:18 <quicksilver> it's not something for haskell, the language to worry about
00:43:42 <quicksilver> it might form the basis of an interesting compilation strategy
00:43:53 <quicksilver> doesn't ndm's supero do something like that?
00:44:38 <olsner> it's a matter of the syntax for pattern matching and data; if "data X = ..." was just syntax sugar for defining a bunch of church-encoded functions
00:46:34 <tehgeekmeister> having not used it yet, i'm not sure if this is the appropriate tool -- but would catch be right for checking exhaustiveness of pattern matches?
00:46:58 <olsner> in this hypothetical language you'd write True 1 2, so if' would be id
00:51:36 <jedbrown> If I take a DFT of an array with bounds (a,b), should the transformed array also have bounds (a,b) or (0, rangeSize (a,b) - 1) ?
00:54:07 <jedbrown> In particular, with a Real -> Complex transform, the output has size (rangeSize (a,b) `div` 2 + 1) which is difficult to compute for arbitrary Ix bounds.
01:01:34 <oerjan> jedbrown: i think you could do (a,b) since everything is `mod` (b-a+1) anyways so only the length of the range matters?
01:01:44 <oerjan> (just my intuition)
01:02:27 <jedbrown> The problem is for the real -> complex transform ^^^.
01:02:40 <jedbrown> You can't do arithmetic with arbitrary Ix.
01:02:43 <oerjan> hm... i don't think i know that.
01:03:43 <jedbrown> Well, if you transform a real-data signal, then negative frequencies are conjugate to the positive frequencies, so you don't need to store them (and FFTW doesn't).
01:04:55 <jedbrown> That means the range of the complex data is smaller, and since the new indices correspond to frequencies, the original range is probably not relevant anyway.
01:05:15 <oerjan> hm right
01:05:55 <jedbrown> However, when you do the complex -> real transform, then the original range becomes relevant again.  Specifying the range explicitly is extra work for the user, so I don't want to require that.
01:06:36 <jedbrown> My array type has O(1) reshaping, so if you wanted some specific bounds, you could get that cheaply.
01:07:03 <jedbrown> I'm leaning towards not having the library do that though.
01:07:05 <oerjan> hm is there a way to store a complex number as two real ones in such a way that swapping the two numbers conjugates?  then you could store one part in each index.  maybe.
01:07:20 <oerjan> except 0 might be a problem
01:08:08 <oerjan> or not... it would be self-adjoint, so the numbers stored in 0 and -0 would be equal
01:08:29 <oerjan> but it might not be a nice API
01:08:41 <jedbrown> I'm not sure I understand.
01:09:28 <jedbrown> One nice API would be to wrap the array so that negative indices map across.
01:10:10 <oerjan> well, if you have f (x,y) = (x+y, x-y)
01:10:45 <jedbrown> When one takes a full transform, FFTW puts the negative frequencies after the positive ones, so one might want to wrap this too.
01:11:10 <oerjan> instead of saving a+b*i and a-b*i at each index, you could save a+b and a-b.
01:11:25 <oerjan> then each value would be real
01:12:13 <jedbrown> Oh, I see.  That takes extra arithmetic and is a very non-standard format, so I'm not inclined.
01:12:42 <jedbrown> But otherwise, I'd consider it.
01:13:48 <oerjan> hm, with (a,b) even finding out which indices _are_ negatives of each other is complicated
01:14:24 <oerjan> for x, you must find k such that k*(b-a+1)+x is in (a,b)
01:14:33 <oerjan> er...
01:14:41 <jedbrown> That is why I'm inclined to just map to Int indices for frequency space.  After all, the first entry *is* zero frequency.
01:14:41 <oerjan> k*(b-a+1)-x
01:15:03 <jedbrown> And you can't do arithmetic with arbitrary Ix.
01:15:24 <oerjan> right, they're not intended for that...
01:15:33 <jedbrown> (Without using `range' and indexing the list.)
01:16:00 <oerjan> @instances-importing Data.Ix Ix
01:16:03 <jedbrown> oerjan: Thanks for the discussion.  I need to go to a meeting now.
01:16:06 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
01:16:19 <oerjan> it doesn't even make sense for some of them
01:16:43 <oerjan> bye
01:18:23 <paolino> if an executable needs a file to run, what is the standar way to make a working package for it ?
01:19:22 <paolino> do I hardcode the needed file path in the code ?
01:19:26 <oerjan> i vaguely recall a .cabal option for listing those being mentioned here
01:19:35 <oerjan> oh
01:20:02 <paolino> oerjan: not a module a non code file
01:20:17 <paolino> configuration, help, whatever
01:20:25 <oerjan> yes it was non-haskell code files (c2hs files i think)
01:21:24 <oerjan> but it's not quite the same question you're asking
01:22:03 <paolino> 2.2. Accessing data files from package code ?
01:22:08 * oerjan leaves this to someone who actually knows
01:22:30 <oerjan> that sounds promising
01:32:34 * dolio is perplexed at all the people favoring maybeRead over readM.
01:33:53 <wagle_home> :t readM
01:33:55 <lambdabot> Not in scope: `readM'
01:34:05 <wagle_home> :t maybeRead
01:34:06 <lambdabot> Not in scope: `maybeRead'
01:34:10 <wagle_home> bah
01:34:19 <wagle_home> @index readM
01:34:20 <lambdabot> bzzt
01:34:27 <dolio> It doesn't exist yet.
01:34:31 <dolio> It's on the libraries mailing list.
01:36:38 <quicksilver> I think the only interesting argument for readM is that there is more than one fail case
01:37:00 <quicksilver> if there was only one fail case, I would support the Maybe lobby
01:37:02 <dolio> It also subsumes readIO, readMaybe, readEither ...
01:37:42 <Cin> *Lambda> showE $ Ap (Ab "x" (V "x")) (V "y")
01:37:42 <Cin> (λ x. x) y
01:37:50 <Cin> oops clipboard fail
01:38:16 <wagle_home> url..  dont find a readM thread
01:38:20 <wagle_home> ?
01:38:33 <quicksilver> @go Proposal: Add Text.Read.maybeRead
01:38:39 <lambdabot> http://www.nabble.com/Haskell-f13122.html
01:38:39 <lambdabot> Title: Nabble - Haskell forum
01:39:19 <dolio> Although I suppose readIO won't be going away any time soon. But adding more versions of it specialized to a particular monad doesn't strike me as being great.
01:39:20 <Cin> if i have (λx.(λx.x)), do i do alpha conversion on the inner abstraction to something like (λz.z) before i attempt to substitute x into it?
01:42:27 <dolio> Also, if the complaint is that not all monads support failure, giving readM the type '(MonadPlus m, Read r) => String -> m r' seems to solve that.
01:43:29 <quicksilver> wel, only sort-of
01:43:36 <quicksilver> since MonadPlus only gives you mzero
01:43:45 <quicksilver> not something which actually lets you inject an error message.
01:43:55 <dolio> Well, it assumes that fail is mzero with an error message.
01:44:26 <quicksilver> that's certainly one assumption
01:44:44 <dolio> It at least restricts readM to monads with a notion of failure, leaving it up to the implementations to use it for fail.
01:44:50 <quicksilver> true
01:45:30 <shag> how can i use either with the IO monad? i need something like either :: (a -> IO c) -> (b -> IO c) -> Either a b -> IO c
01:45:42 <quicksilver> indeed, either has that type :)
01:45:47 <quicksilver> well, a generalisation of it.
01:45:53 <quicksilver> but you can use it at that type.
01:45:56 <quicksilver> :t either
01:45:56 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:45:56 <shag> yes, that is what i  was thinking, too
01:46:00 <proq> how do I start a repl with ghc?
01:46:04 <quicksilver> instantiate c as 'IO c'
01:46:06 <shag> but i just cant get it to work :)
01:46:08 <quicksilver> proq: type "ghci"
01:51:36 <wagle_home> :t reads
01:51:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
01:52:17 <wagle_home> reads "1 2 3"
01:52:22 <wagle_home> > reads "1 2 3"
01:52:24 <lambdabot>  [(1," 2 3")]
01:52:30 <quicksilver> shag: if you want to paste the code I'm sure we can fix it :)
01:52:48 <wagle_home> why does reads return a list?
01:53:07 <dolio> Because there can be 0 or more correct parsings.
01:53:25 <shag> quicksilver: i just figured it out. thanks. was just some indentation issue i missed again and again :)
01:53:29 <quicksilver> ;)
01:53:47 <quicksilver> dolio: I replied to you on libraries broadly agreeing with you
01:57:39 <dolio> The only problem with MonadPlus and fail is that it's easy to forget to define fail, and its default definition just calls error.
01:58:04 <dolio> If you're making your own MonadPlus that is.
01:58:24 <wagle_home> > reads "10.2 3"
01:58:25 <lambdabot>  []
01:59:06 <quicksilver> > reads "10.2 3" :: [(Double,String)]
01:59:07 <lambdabot>  [(10.2," 3")]
01:59:15 <wagle_home> trying to figure out if i like readM or not
01:59:24 <quicksilver> maximal munch lexing means it won't read the 10 as an int
02:00:32 <proq> I'm trying to build listing 5 of the scheme parser in haskell tutorial. I get the error listing5.o(.text+0x31a):fake: undefined reference to `mtlzm1zi1zi0zi0_ControlziMonadziError_zdf13_closure'. what would be the cause of this?
02:00:37 <wagle_home> yeah, thats the half-minded notion that made me put the (futile) 0 there
02:00:45 <quicksilver> proq: not using --make
02:01:18 <proq> ah, thanks again  :)
02:02:41 <wagle_home> lambdabot karma points to the person who adds a "maybe you want --make" to that error message
02:02:51 <quicksilver> Cale: it occurs to me that lenses make an interesting example of a 'Category' where composition is not haskell composition.
02:02:57 <quicksilver> Cale: but definitely not an Arrow.
02:03:49 <wagle_home> i think i understood what lenses were once, but i forget
02:04:26 <quicksilver> A combined getter/setter for a field of a record
02:04:37 <quicksilver> or really, a view of a "part" of a data structure
02:04:39 <dolio> quicksilver: Incomplete parses are a good point too. read and company already just throw that information away.
02:04:50 <quicksilver> dolio: yes.
02:04:58 <quicksilver> > read "2 3" :: Int
02:05:01 <lambdabot>  Exception: Prelude.read: no parse
02:05:56 <wagle_home> > reads "1s2 3"
02:05:56 <lambdabot>  [(1,"s2 3")]
02:07:07 <wagle_home> whats an example of something reads finds ambiguous?
02:07:23 <wagle_home> > reads "s2 3"
02:07:24 <lambdabot>  []
02:07:25 <dolio> There aren't any examples among the default data types, I think.
02:07:40 <vincenz> > reads "True"
02:07:41 <lambdabot>  []
02:07:41 <dolio> But you're free to implement one.
02:07:55 <vincenz> > reads "True" :: ReadS Bool
02:07:55 <lambdabot>  Couldn't match expected type `ReadS Bool'
02:08:06 <vincenz> :t reads
02:08:08 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:08:15 <vincenz> > reads "True" :: [(Bool, String)]
02:08:15 <lambdabot>  [(True,"")]
02:08:17 <quicksilver> yes, there are none at all in the default REad instances
02:08:20 <quicksilver> but you could add one
02:09:35 <wagle_home> > reads "TrueFalse" :: [(Bool,String)]
02:09:36 <lambdabot>  []
02:09:41 <wagle_home> > reads "True1False" :: [(Bool,String)]
02:09:42 <lambdabot>  []
02:10:06 <wagle_home> > reads "(True)False" :: [(Bool,String)]
02:10:07 <lambdabot>  [(True,"False")]
02:10:44 <wagle_home> > reads "(True)False"
02:10:45 <lambdabot>  []
02:11:58 <wagle_home> a little strange that reads "1" works without being typed
02:12:22 <dolio> Read defaults to Int or Integer or the like in lambdabot.
02:13:52 <wagle_home> > reads "(True)False" :: [(String,String)]
02:13:52 <lambdabot>  []
02:14:09 <wagle_home> > reads "TrueFalse" :: [(String,String)]
02:14:10 <lambdabot>  []
02:14:30 <dolio> > reads "\"This is a string.\"" :: [(String,String)]
02:14:30 <lambdabot>  [("This is a string.","")]
02:14:53 <wagle_home> yeah, but that requires the input have " marks
02:15:37 <quicksilver> yup. Because that's what read does :)
02:15:41 <quicksilver> > show "foo"
02:15:42 <lambdabot>  "\"foo\""
02:16:06 <vincenz> > fix show
02:16:07 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:17:05 <shag> @pl (\sr -> putMVar r ((s,m):sr)
02:17:05 <lambdabot> (line 1, column 29):
02:17:05 <lambdabot> unexpected end of input
02:17:05 <lambdabot> expecting variable, "(", operator or ")"
02:17:09 <shag> @pl (\sr -> putMVar r ((s,m):sr))
02:17:09 <lambdabot> putMVar r . ((s, m) :)
02:17:27 <wagle_home> reads "\"a\"1" :: [(String,a)]
02:17:34 <wagle_home> > reads "\"a\"1" :: [(String,a)]
02:17:34 <lambdabot>   [(String, a)]
02:17:34 <lambdabot>       Inferred type: [(String, String)]
02:17:34 <lambdabot>     In the expression...
02:17:49 <wagle_home> > reads "\"a\"1" :: [(String,String)]
02:17:50 <lambdabot>  [("a","1")]
02:19:04 <wagle_home> > reads "\"a\"1" :: [(String,head(snd(codomainof(codomainof(typeof reads)))))]
02:19:04 <lambdabot>   [(String,
02:19:04 <lambdabot>                        head (snd (codomainof (codomainof (typeof ...
02:19:22 <quicksilver> shag: there is a modifyIORef
02:19:26 <quicksilver> shag: and modifyMVar
02:19:40 <quicksilver> shag: sadly modifyMVar has the wrong type, which I have complained about before ;)
02:19:44 <shag> *hoogling*
02:19:58 <quicksilver> shag: but modifyMVar r (return . ((s,m):) )
02:20:02 <quicksilver> is about what you want
02:20:09 <shag> yes, looks like that
02:20:13 <shag> thanks :)
02:20:19 <quicksilver> I normally define modifyMVarPure r f = modifyMVar r (return.f)
02:20:28 <quicksilver> and then moan that modifyMVar is inconsistently named :P
02:21:00 <shag> hehe
02:21:17 <shag> should be sth like modifyMVarM
02:21:39 <quicksilver> right
02:22:13 <quicksilver> shag: http://www.haskell.org/pipermail/libraries/2007-September/008237.html
02:22:14 <lambdabot> Title: MVar API - modifyMVar, http://tinyurl.com/2swwlo
02:23:55 <shag> it's good to see that even the core library developers don't get everything right the first time ;))
02:24:57 <Cin> shag: it's just a deception, luring us mortals into a false sense of security
02:25:26 <shag> hehe
02:32:22 <scook0> @hoogle with
02:32:34 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
02:32:35 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
02:32:35 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
02:56:00 <catface> > iterate (\x -> zipWith (+) (x ++ [0]) (0 : x)) [1]
02:56:03 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
03:03:02 <khadrin> Is it possible to override the definition of a function which came from a deriving clause?
03:03:40 <quicksilver> <pedant>You mean method, not function</pedant>
03:03:41 <quicksilver> No.
03:03:45 <dmwit> No, you'll have to write the whole instance yourself.
03:03:52 <quicksilver> You can always shadow a function, but you can't do anythign abotu methods.
03:03:52 <khadrin> ok thx
03:04:20 <khadrin> shadow?
03:04:30 <quicksilver> define a new binding with the same name
03:04:35 <quicksilver> effectively overriding the old one
03:04:43 <quicksilver> although the old one still exists, it's just the new one hides it
03:04:55 <quicksilver> > let x = 1 in let x = 2 in x
03:04:56 <lambdabot>  2
03:05:05 <quicksilver> shadowing x, so the 'innermost' is used.
03:05:26 <quicksilver> but note that haskell scoping is lexical not dynamic
03:05:27 <khadrin> hide it, but only for a particular scope?
03:05:31 <quicksilver> write
03:05:32 <quicksilver> right
03:05:38 <quicksilver> sorry :) damn homonyms
03:05:42 <khadrin> hehe
03:06:04 <EvilTerran> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
03:06:05 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
03:06:08 <paolino> haddock laments missing file Paths_xxxx file which is autogenerated by cabal , any idea on how to hide it to haddock ?
03:06:22 <Taejo> Does anyone happen to have a cabalized hwordnet lying around?
03:06:49 <khadrin> @src Show
03:06:50 <lambdabot> class  Show a  where
03:06:50 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:06:50 <lambdabot>     show      :: a   -> String
03:06:50 <lambdabot>     showList  :: [a] -> ShowS
03:07:25 <dmwit> I think only "show" is required.
03:08:32 <khadrin> I was thinking about overriding show for data Prize = Goat | Car so that show Car yields " Car"
03:08:45 <EvilTerran> dmwit, yeah; or showsPrec, they're defined in terms of each other
03:08:47 <khadrin> but that seems too cute, I should just make a function that does what I want
03:09:28 <dmwit> Mmm, Monty Hall.
03:09:36 <khadrin> hehe =)
03:10:47 <khadrin> I assume you can simulate it in like 3 lines, but i have no clue how yet
03:11:14 <khadrin> how to write it in 3 lines that is, i could make an ugly procedural looking program ;)
03:12:34 <dmwit> =)
03:13:06 <ricky_clarkson> When a dependently typed program is compiled, and type checking might not complete, can you generally tell that it isn't completing, programmatically?
03:13:19 * dmwit guesses no
03:13:26 <ricky_clarkson> E.g., can you tell that it's going round in circles, or building up a large amount of heap.
03:13:27 <earthy> generally: not at all
03:13:33 <earthy> (that's like solving the halting problem)
03:14:06 <ricky_clarkson> Solving the halting problem requires predicting it in advance of starting it.
03:14:15 <dolio> That's one reason why a lot of dependently typed languages these days are total.
03:14:48 <ricky_clarkson> Ok, so dependently typed total languages don't have the problem?
03:15:07 <earthy> nope, the code in total languages always terminates
03:15:36 <dolio> Functions in a total language are guaranteed to terminate (unless they're functions over codata, of course).
03:15:36 <ricky_clarkson> I thought the problem was that type checking doesn't terminate, rather than the runnable code doesn't.
03:15:41 <ricky_clarkson> What's the "Haskell" of that world?
03:15:47 <dmwit> ricky_clarkson: There is certainly no such restriction on the halting problem.  If you think running the program will help, by all means do so. ;-)
03:15:53 <earthy> there isn't
03:15:54 <ricky_clarkson> Heh.
03:16:27 <dmwit> Even Haskell type-checking is undecidable.
03:16:53 * Vq^ learns that System.CPUTime isn't very usefull to measure functions cpu runtime in threaded program
03:16:57 <dolio> Well, with some GHC extensions it is.
03:17:24 <dmwit> Sorry, yes.  I just went Googling and discovered that. =P
03:17:41 <dolio> Like, uh, undecidable instances. :)
03:19:33 <dolio> And, the special danger with dependently typed languages is that you have all the features of the runnable code in the type system, so if the language is turing complete, so is the type system.
03:20:13 <dolio> Hence the total language focus (not that total programming isn't useful in itself, although, perhaps less appealing without dependent types).
03:21:35 <Spockz|Laptop|> g'day
03:22:10 <dmwit> Hiya, Spockz|Laptop|!
03:30:08 <Spockz|Laptop|> i'm new to this language
03:30:21 <Twey> Spockz|Laptop|: Mornin'
03:30:35 <Spockz|Laptop|> how would you take a tail of a list
03:30:52 <Spockz|Laptop|> from a specified index of the list
03:31:17 <Spockz|Laptop|> should I use 'tail' repeatedly or is there another function which does this for us already?
03:31:24 <Spockz|Laptop|> Twey: morning :)
03:31:24 <resiak> > drop 3 "hello world"
03:31:26 <Twey> drop
03:31:30 <lambdabot>  "lo world"
03:31:46 <Spockz|Laptop|> riight :P
03:31:48 <Twey> (strings are lists)
03:31:55 <Spockz|Laptop|> lists of char ofcourse :)
03:31:56 <Spockz|Laptop|> thanx
03:32:00 <Twey> Welcome
03:32:00 <Taejo> in a Cabal file, why is only the author's name and the maintainer's email given, and not vice versa?
03:33:01 <Spockz|Laptop|> Twey: thanx
03:37:53 <byorgey> Taejo: you can put whatever you want in those fields, no one says you have to put the author's name and the maintainer's email.
03:38:15 <byorgey> Taejo: you could put the author's email too if you wanted.
03:39:11 <Taejo> byorgey: ok, so much for cargo-culting tutorials
03:39:23 <dmwit> byorgey: Ah, but could you put the price of tea there, instead?
03:39:27 <byorgey> Taejo: hehe
03:39:34 <byorgey> dmwit: sure!
03:39:57 <dmwit> And if you put in these wrong figures... would the right answers come out?
03:40:08 <dmwit> </Babbage>
03:40:50 <byorgey> dmwit: is that some sort of reference?  should I feel ashamed for not getting it?
03:41:05 <dmwit> It is a reference, but you shouldn't be ashamed for missing it.
03:41:10 <dmwit> It is obscure indeed. =P
03:41:20 <Taejo> byorgey: Babbage was asked by parliament whether his engine would give the right answers if the wrong data was input
03:41:29 <byorgey> ah, I see =)
03:41:57 <byorgey> well... would it?
03:42:19 <dmwit> http://en.wikipedia.org/wiki/Charles_Babbage#Quotations
03:42:23 <Taejo> byorgey: GIGO
03:42:37 <byorgey> Taejo: hehe, indeed =)
03:42:45 <dmwit> "I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
03:42:56 <dmwit> That is perhaps the best possible answer.
03:43:19 <dmwit> proggit also suggests: "You will get the right answers, but to the wrong questions."
03:43:33 <byorgey> hehe, awesome
03:53:07 <vincenz> tibbe: ping?
03:58:22 <Taejo> anybody here used HWordNet recently?
04:03:06 <Taejo> it uses a Data.Set.addToSet which doesn't seem to exist, and I can't figure its type
04:06:07 <catface> is there a func to compose a unary func with a binary one?
04:06:31 <Taejo> catface: not builtin
04:06:39 <catface> thx
04:06:50 <byorgey> catface: you mean like  \f g x y = f (g x y) ?
04:07:06 <Taejo> @pl \ x y = f (g x y)
04:07:06 <lambdabot> (line 1, column 7):
04:07:06 <lambdabot> unexpected "="
04:07:06 <lambdabot> expecting pattern or "->"
04:07:10 <Taejo> @pl \ x y -> f (g x y)
04:07:11 <lambdabot> (f .) . g
04:07:21 <Taejo> catface: like that
04:07:27 <dmwit> :t ($)
04:07:29 <lambdabot> forall a b. (a -> b) -> a -> b
04:07:46 <dmwit> I wonder what type he's wishing for.
04:07:57 <catface> clever
04:08:37 <Taejo> @pl compose2 f g = (f .) . g
04:08:37 <lambdabot> compose2 = (.) . (.)
04:08:52 <Taejo> and there you have it: the boobies operator
04:09:03 <Lemmih> Taejo: It might be Data.Set.insert.
04:09:17 <Taejo> Lemmih: yeah, I thought so
04:09:48 <Taejo> know I'm thinking addToSet x y == union x $ fromList y
04:10:43 <Taejo> nope, that's not it
04:11:51 <Taejo> ah, stupid me, addToSet == flip insert
04:11:59 <quicksilver> try addToSet = undefined, load the file
04:12:02 <quicksilver> and then check the type :)
04:12:05 <quicksilver> ah, you got it.
04:12:13 <Taejo> quicksilver: good idea, but I got it
04:12:22 <Taejo> I'll use that in the future, tho
04:13:38 <Taejo> I think it's time for me to move to GHC 6.8... does anybody have DEBs lying around?
04:14:08 <koeien> Taejo: debian sid has them probably?
04:14:18 <Taejo> koeien: I'm on ubuntu
04:14:26 <Taejo> but I'll look in sid
04:15:07 <dmwit> Using sid debs for Ubuntu isn't recommended, but I don't remember why.
04:15:12 <koeien> well i guess it is possible to install those; or to compile yourself, of course
04:15:30 <jedbrown> Taejo: Hardy has it too.
04:15:38 <quicksilver> compile from the sid source packages is probably safe but slow
04:15:39 <koeien> Taejo: doesn't "ubuntu unstable" have them?
04:15:42 <koeien> or whatever it's called
04:15:45 <Taejo> koeien: the electricity supply isn't stable enough here to compile GHC
04:15:46 <quicksilver> ah Hardy is a better answer
04:15:50 <quicksilver> heh
04:15:54 <quicksilver> laptops++
04:16:40 <Taejo> I've been trying to compile it on a Gentoo machine on campus, and the power has gone off every time I tried (about 4 times, I think)
04:16:54 <koeien> "GHC. The powerful compiler."
04:17:45 <dolio> That's always a bummer on Gentoo, since you have to start the compile from scratch.
04:17:59 <dolio> Unless they've changed things since I used it.
04:19:03 <Taejo> well, I'm a gentoo noob, so I wouldn't know how to continue if it was possible
04:19:05 <koeien> i've used it two years ago. debian and ubuntu >> gentoo imo, but if you're new to *nix and willing to learn it's ok to start with
04:20:22 <TNorthover> Taejo: You might be able to resume compilation by emerging with the "ebuild" command directly, rather than a simple emerge
04:20:25 <koeien> but ubuntu hardy packages are the way to go :) you could always create a sid chroot but that's a bit overkill
04:21:08 <Taejo> koeien: is there a "correct" way to install hardy packages in gutsy?
04:21:12 <koeien> yes
04:21:24 <koeien> Taejo: at least in debian, add the repository to /etc/apt/sources.list
04:21:31 <dolio> Just using the generic linux package on the GHC site would probably be preferable to installing an entire debian chroot.
04:21:45 <koeien> Taejo: in /etc/apt/apt.conf add the line 'APT::Default-Release "stable";'
04:22:02 <koeien> Taejo: then aptitude update
04:22:02 <dmwit> Taejo: Is it in backports?
04:22:15 <koeien> Taejo: then install the hardy version
04:23:02 <Taejo> koeien: glad to meet another aptitude user
04:24:01 <koeien> Taejo: be sure not to forget the /etc/apt/apt.conf line... if you do, and you upgrade, a lot of packages from unstable get in
04:24:15 <koeien> which you don't want
04:24:26 <Taejo> ya
04:32:48 <dolio> "Haskell vs XSLT"
04:35:33 <quicksilver> dolio: Haskell wins?
04:35:49 <dolio> Hmm, hard to say.
04:35:52 <paolino> anyone with deep knowledge of haddock ?
04:35:52 <dolio> http://porg.es.nyud.net/blog/computing-with-xslt
04:36:09 <Taejo> it's a lot more about XSLT than Haskell
04:36:26 <quicksilver> looks like a win for haskell to me:)
04:36:31 <dolio> Heh.
04:36:34 <quicksilver> xslt is verbose at best and clumsy at worse.
04:37:07 <osfameron> even when paired with xpath?
04:37:09 <quicksilver> verbose for 'simple' transformations, horribly clumsy for multi-pass stateful ones.
04:37:23 <byorgey> paolino: I know a fair bit, what's the problem?  depends how "deep" you mean =)
04:37:31 <b_jonas> xslt wins: http://www.googlefight.com/index.php?lang=en_GB&word1=haskell&word2=xslt  or  http://www.google.com/trends?q=haskell%2C+xslt
04:37:33 <lambdabot> Title: Google Fight : Make this fight with googleFight haskell VS xslt, http://tinyurl.com/24kft5
04:37:46 <quicksilver> try to write the xslt program which takes an XML rep of a programming language and adds scope info to the variables
04:37:53 <quicksilver> or some similar stateful transform
04:37:59 <quicksilver> I believ you will find it painful.
04:38:26 <paolino> byorgey: I need  to exclude pieces of code from the compiling phase
04:38:26 <quicksilver> when you've done that, try writing a type inference engine for the simply typed lambda calculus in xslt :)
04:39:11 <osfameron> yes, but is it more elegant to write an XML transformation in haskell, and if so, how would you do that?
04:39:23 <osfameron> as that's xslt's preferred domain isn't it?
04:39:38 <quicksilver> depends a bit where you draw the line
04:39:38 <paolino> byorgey: they fail on code depending on autogenerated code from cabal , it's a bad logic bug
04:39:53 <quicksilver> do you compare an XSLT programing acting on its preferred date rep (XML)
04:39:58 <vincenz> byorgey: nice post
04:40:04 <quicksilver> with an haskell program acting on its preferred data rep (ADTs)
04:40:08 <byorgey> paolino: ah... I see.  unfortunately, my knowledge is not THAT deep =(
04:40:13 <quicksilver> or do you compare XSLT-on-XML with haskell-on-XML ?
04:40:25 <byorgey> vincenz: thanks.  more to come. =)
04:40:33 <vincenz> byorgey: grand
04:41:04 <vincenz> byorgey: maybe I'll blog on splatch this weekend
04:41:16 <osfameron> quicksilver: I guess both XML/ADT and XML/XML comparisons would be interesting
04:41:20 <vincenz> byorgey: but as you can see from my blog I had another big one that needed work (it's not finished yet
04:41:20 <byorgey> vincenz: cool
04:41:38 <byorgey> vincenz: yes, I was just about to read it =)
04:41:45 <vincenz> it's hardly finished
04:41:49 <vincenz> but I'm starting to hate writing a bit
04:41:55 <vincenz> since I have to write a journal and my thesis
04:42:05 <vincenz> so in free time I prefer to hack :)
04:42:12 <byorgey> vincenz: ah, indeed =)
04:42:29 <byorgey> vincenz: well, I enjoy writing, but then again, I don't have a thesis yet...
04:43:11 <vincenz> nor do I
04:43:47 <paolino> byorgey: I will sed-filter my files, befor haddocking, or you have a nicer idea ?
04:43:53 <b_jonas> I should write my thesis too :(
04:44:01 <jedbrown> Is a lighter way to get realWorld#, Addr# and RULES than -fglasgow-exts?
04:44:02 <vincenz> b_jonas: undergrad?
04:44:15 <byorgey> paolino: if there is a nicer way to do it, I don't know what it is
04:44:26 <b_jonas> vincenz: yes
04:45:37 <quicksilver> do you need an extension to get RULES ?
04:46:17 <jedbrown> quicksilver: They aren't processed otherwise, as far as I can tell.
04:46:59 <jedbrown> quicksilver: I'm just looking for finer-grained control/documentation of the language extensions I'm using.
04:49:03 <gour> @seen ndm
04:49:03 <lambdabot> I haven't seen ndm.
04:49:12 <vincenz> jedbrown: look at LANGUAGE pragmas
04:51:08 <jedbrown> vincenz: Well, docs say RULES only fire when -fglasgow-exts is on, so I'm stuck with it.
04:51:14 <vincenz> :|\
04:52:55 <b_jonas> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html says -fglasgow-exts is needed for RULES
04:52:56 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
04:53:24 <b_jonas> oh, that's what you said too
04:54:21 <jedbrown> b_jonas: Turns out, the man page doesn't agree.  It has -frewrite-rules
04:54:29 <b_jonas> heh
04:58:54 <jedbrown> Aha, and there's -XMagicHash which recognizes realWorld# and Addr# but not (# , #)
05:00:37 <b_jonas> @src (,) Ord
05:00:37 <lambdabot> Source not found. There are some things that I just don't know.
05:00:40 <b_jonas> @src (,) <
05:00:40 <lambdabot> Source not found. You type like i drive.
05:01:37 <byorgey> b_jonas: (,) is an instance of Ord, it compares on the first element first and then the second element if the first is equal.
05:09:35 <_alf_> p~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
05:10:13 --- mode: ChanServ set +o vincenz
05:10:20 <vincenz> _alf_: problems?
05:11:43 --- mode: ChanServ set +o dcoutts
05:11:56 <opqdonut> wow
05:12:02 <Vq^> vincenz: probably just his cat while he was afk
05:12:03 <dcoutts> cat on the keyboard? :-)
05:12:14 * vincenz nods
05:12:20 <vincenz> dcoutts: hence why I didn't kick right away :)
05:12:21 --- mode: ChanServ set -o dcoutts
05:12:26 --- mode: vincenz set -o vincenz
05:13:03 <ricky_clarkson> I really wonder what he was about to say before the tilde-loving kitten got in the way.
05:13:20 <matthew-_> probably "piss off cat!"
05:13:30 <Vq^> yeah, a lot of great stories start on 'p' :o)
05:14:44 <b_jonas> wait, on what keyboard layout can you type tildes without shifting?
05:15:07 <wolverian> on a se/fi one; you use altgr instead ;)
05:15:10 <b_jonas> I mean, can a cat be so interested to hold down shift?
05:15:44 <b_jonas> oh wait, even though on the uk map, tilde is shifted, it's shift with a key adjacent to shift
05:15:46 <b_jonas> so that's possible
05:16:41 <vincenz> dcoutts: we'll be starting HUGZ :)
05:16:45 <vincenz> Haskell User Group Zurich
05:16:50 <dcoutts> vincenz: cool
05:17:07 * vincenz is pleased with the name
05:17:15 <dcoutts> yeah, that's good :-)
05:17:25 <chot> hi! We're developing a monad with some instructions including a repeat instruction. now the problem is that we want it to loop for ever, but we also want "partial results". can we execute a monad program step by step in some way? or are there some other solutions to these kind of problems?
05:18:27 <dcoutts> vincenz: soon there'll be an circuit of HUGs all round Europe for us to tour :-)
05:18:51 <dcoutts> chot: you can certainly produce intermediate results with a writer monad
05:19:29 <Vq^> chot: what is the effect of the repeat instruction?
05:19:38 <chot> dcoutts: well we're writing our own monad, and we need the result in the run instruction
05:19:58 <chot> Vq^: run the whole program (monad) again
05:20:25 <chot> ie: mainprog = do inst inst inst.. repeat
05:20:29 <Vq^> i see
05:20:42 <dcoutts> chot: being a writer monad is just an aspect, you can make your own custom monad also be a writer monad.
05:21:01 <dcoutts> chot: a monad doesn't have to have just one ability
05:21:01 <b_jonas> "aspect"
05:21:15 <b_jonas> that's something you can be "oriented" about,
05:21:28 <b_jonas> like "role"
05:21:28 <chot> dcoutts: hm ok
05:21:31 <chot> ops
05:21:38 <chot> dcoutts: hm ok* :p
05:21:43 <dcoutts> b_jonas: ugg, tell me about it, I've got to each Aspect Oriented Java.
05:22:01 <b_jonas> ow
05:22:21 <vincenz> dcoutts: with safehouses
05:22:32 <dcoutts> vincenz: heh heh
05:22:33 <vincenz> dcoutts: so you can unsafePerformIO at will
05:22:47 * dcoutts does unsafeInlinePerformIO
05:23:21 * osfameron really doesn't get AOP... seems to be a way of solving problems thay don't exist in more dynamic languages
05:24:01 <dcoutts> osfameron: you mean dynamic languages are just as unsafe and scary as AOP?
05:24:29 <vincenz> AOP is really terrible
05:24:33 <vincenz> since it's name-based
05:24:34 <jedbrown> dcoutts: Speaking of unsafeInline, the only thing I can't get without -fglasgow-exts is (# , #).  Wouldn't it make sense for -XMagicHash to enable this as well?
05:24:43 <vincenz> imagine missing a method in your regexp-pattern
05:25:01 <osfameron> dcoutts: no.  I mean that when I've read descriptions about AOP, I haven't seen the point of it
05:25:19 <dcoutts> jedbrown: that's unboxed tuples and I think there's an extension name for it.
05:25:20 <b_jonas> that reminds me to  http://pigdog.org/auto/mr_bads_list/shortcolumn/1914.html
05:25:20 <lambdabot> Title: Pigdog Journal (Mr. Bad's List) -- Things to Say When You're Losing a Technical  ...
05:25:39 <dcoutts> jedbrown: MagicHash is just the lexical excension to allow # in variable names
05:26:23 <dcoutts> osfameron: that's fairly common I think. Most uses seem to be about debugging or testing.
05:26:27 <b_jonas> dcoutts: does it allow it in operators too?
05:26:38 <chot> dcoutts: we're still kind of confused, can we make a writer monad output anything we like? can we write a new run for it? has this something to do with monad transformers?
05:26:44 <dcoutts> b_jonas: it's already allowed as an operator I think
05:26:52 <b_jonas> wtf...
05:26:54 <b_jonas> that can't be
05:27:00 <b_jonas> let me look up
05:27:08 <mauke> > (#)
05:27:09 <chot> (anything we like as in we need it to out put hgl Graphics..)
05:27:10 <lambdabot>   Not in scope: `#'
05:27:28 <dcoutts> > let a # b = a + b in 1 # 2
05:27:29 <lambdabot>  3
05:27:33 <b_jonas> > let a #<^ b = 2+a in 3 #<^ 5
05:27:34 <lambdabot>  5
05:27:36 <b_jonas> indeed
05:27:37 <b_jonas> hmm
05:27:39 <b_jonas> thanks
05:28:16 <dcoutts> chot: writer monads generally output a list or something that is similar to a list, eg often used for logging.
05:29:02 <dcoutts> chot: and monad transformers are one way of constructing new monads without having to code them by hand, by sticking together existing bits.
05:29:48 <jedbrown> dcoutts: Whatd'ya know.  -XUnboxedTuples solves my problem.  Yay!
05:30:23 <dcoutts> :-)
05:31:08 <jedbrown> dcoutts: Also, -frewrite-rules should be documented in file:///home/haskell/share/doc/ghc/users_guide/rewrite-rules.html
05:31:18 <jedbrown> dcoutts: Where it says that you need -fglasgow-exts
05:32:00 <dcoutts> jedbrown: I didn't know of that flag, send in an email or bug report
05:32:19 <dcoutts> or better yet, send a patch to the documentation
05:33:04 <jedbrown> Yeah, that doc also mentions -frules-off which doesn't exist.  I'll send a patch.
05:37:55 <b_jonas> a doc patch or a code patch
05:42:03 <b_jonas> -frules-off turns of rules so anything is allowed?
05:45:06 <jedbrown> b_jonas: ghc-6.8.2 doesn't understand -frules-off.  It does however, understand -fno-rewrite-rules so there is a documentation bug.
05:46:58 <JohnMeacham> yay. jhc is finally autoconf'ed, that means prebuilt RPMs and building is as easy as ./configure && make install.
05:47:41 <dcoutts> JohnMeacham: yay!
05:47:55 <dcoutts> JohnMeacham: btw, I'm trying to improve the compiler support in Cabal
05:48:27 <dcoutts> JohnMeacham: in particular to have a proper Compiler adt rather than doing case analysis on compiler flavour in all the other modules
05:48:52 <dcoutts> so would most appreciate if you could keep an eye on jhc support in the darcs version of Cabal
05:49:24 <dcoutts> JohnMeacham: up 'til now at least it's been hard for me to test it with jhc, only to keep it building.
05:49:28 <JohnMeacham> Ideally I'd like to just drop a file somewhere. like /usr/lib/cabal/compilers/jhc-0.3.compiler  and it will be a simple description of how to call jhc and a list of extensions and whatnot. nothing will have to be 'built in' to cabal.
05:50:05 <dcoutts> JohnMeacham: yes, I understand that suggestiong ubt I think that's not realistic at the moment, the compiler is asked for rather more than just 'build this file'
05:50:37 <dcoutts> JohnMeacham: at least we can restrict compiler support to one module, and maybe later have it be a parameter you can pass in
05:51:56 <JohnMeacham> well, this would also solve the issue of having many different versions of the same compiler installed. just point at different config files. I am happy to modify jhc towards such a goal. I mean, ghc now supports '-X' so a whole lot of the code dealing with extensions can go away, it just needs to pass the strings through. I will give jhc the same flag actually.
05:51:58 <dcoutts> JohnMeacham: note that GHC's extensions are not hard coded now, we query ghc for them at configure time.
05:52:31 <dcoutts> JohnMeacham: well, we still need to know if a compiler supports an extension so we can check how portable a package is.
05:52:58 <dcoutts> JohnMeacham: eg we can say up front that this package will not build on hugs/jhc whatever because it does not support extension FooBar.
05:53:23 <JohnMeacham> well, that is what would be listed in the compiler configuratoin file.
05:53:38 <JaffaCake> the construction of command-lines for calling the compiler, and things like how to build libraries are very compiler-dependent, and not something you can easily specify as data
05:53:43 <Cin> hi gwern
05:54:54 <JohnMeacham> certainly, but I feel it can be abstracted a bit more. I mean, we control both the compilers and the cabal, we can meet somewhere in the middle.
05:55:18 <dcoutts> JohnMeacham: remember that some coupling is not that bad in practise since you ship Cabal with jhc right? so you can get whatever improvements you need in upstream and then ship it.
05:55:26 <JaffaCake> right - I think having Cabal call a well-specified compiler API would be the best way
05:56:00 <dcoutts> however far we want to push it, the first step is to have a proper Compiler type that we call
05:56:04 <JohnMeacham> I don't ship cabal, no. I would prefer to have users just install the cabal-install binary separately.
05:56:24 <dcoutts> then if those Compiler values are coded in to the Cabal lib or passed in, we can improve later
05:56:47 <dcoutts> first step is obviously to stop doing: case compilerFlavour compiler of GHC -> ...; JHC -> ...; etc
05:57:05 <JaffaCake> yup
05:57:11 <dcoutts> JohnMeacham: do you ship any core libs?
05:57:58 <JohnMeacham> just the haskell98 lib is the same as ghc's (pulled from the same repo) my 'base' is completely separate.
05:58:30 <dcoutts> JohnMeacham: the current split is that Cabal is the lib which deps only on other 'core' libs and cabal-install is the command line prog that also depends on zlib and http packages. But that makes bootstrapping a tad tricky.
05:58:35 <JohnMeacham> but mosttly equivalent, I want to have it just ship with a bare haskell' library, whatever that turns out to be.
06:01:49 <JohnMeacham> I am not sure what you mean by bootstrapping, surely it isn't more difficult than bootstrapping a compiler in the first place? I was never really a fan of cabal as a library anyway, I am mainly just waiting for the executable version to take form....
06:02:27 <dcoutts> JohnMeacham: the exe form is indeed a much better interface, but the lib/exe split still makes a lot of sense
06:02:34 <dcoutts> a better user interface I mean
06:03:26 <dcoutts> JohnMeacham: so Cabal needs a bunch of other libs: base, pretty, directory, old-time, process, containers and filepath
06:03:50 <dcoutts> so if those are not available then it's quite tricky to bootstrap since how do those other libs get built and installed?
06:04:01 <dcoutts> Cabal can bootstrap itself if those libs are present.
06:04:29 <JohnMeacham> with your previous 'cabal-install' binary that you still have sitting around. :) it seems that the executable form will make that much simpler.
06:04:40 <dcoutts> cabal-install needs a couple other deps, zlib and http
06:04:51 <dcoutts> which both have to be installed using Cabal/cabal-install :-)
06:04:54 <JohnMeacham> assuming you don't need bleeding edge features immediately.
06:05:32 <dcoutts> JohnMeacham: right, that's work, if you have an existing cabal-install, or another haskell impl sitting around.
06:05:42 <JohnMeacham> yeah, but presumably you have a cabal-install binary compiled against an older version of cabal that can handle compiling the new one. just like ghc can compile itself because you always have the previous version sitting around.
06:06:05 <dcoutts> yes, cabal-install can install Cabal and itself
06:07:54 <JohnMeacham> hmmm... okay. I guess we'll see how it all works out. what I mainly want as a compiler writer is to see a document saying "this is what you need to do to make your compiler work with cabal" and it shouldn't involve changing cabal at all. though, I guess that is a ways off.
06:07:59 <dcoutts> JohnMeacham: does jhc have any package db at all? if not the simple way to do it is if Cabal installs a package description with each package, like it does now for hugs.
06:08:39 <JohnMeacham> to install a package you just drop the 'hl' file in /usr/lib/jhc-0.3. the hl files are portable between architectures.
06:08:42 <dcoutts> JohnMeacham: the main thing that needs is that whatever base libs jhc comes with, those would also need InstalledPackageInfo files so cabal can do package dep analysis
06:09:49 <JohnMeacham> I don't want jhc packages to be anything more than a single file you drop somewhere and that is it. they do contain the contents of the cabal file used to build them though and jhc can print it out. so, it would be straightforward to generate that data if needed by cabal I think.
06:10:22 <dcoutts> JohnMeacham: ah, that'd be great. Though you don't want the PackageDescription, it's the InstalledPackageDescription that we need.
06:10:47 <dcoutts> since that has deps resolved to exact package versions and all configurations resolved etc
06:11:06 <JohnMeacham> I can make some option to jhc that will spit out the info cabal needs on installed packages in whatever format is best. that way cabal doesn't need to understand the internal format of the hl files..
06:11:20 <dcoutts> JohnMeacham: yes, like ghc-pkg describe foo
06:11:31 <JohnMeacham> yes.
06:11:39 <dcoutts> JohnMeacham: we have a data type and parser and pretty printer for that format.
06:12:05 <JohnMeacham> are cabal files supposed to be full YAML documents btw? they seem almost, but not quite them.
06:12:29 <dcoutts> JohnMeacham: they're not full YAML, no. Perhaps we should look at doing that.
06:13:31 <JohnMeacham> ah. just curious.
06:13:32 <dcoutts> JohnMeacham: see, we've discovered recently that we need more than just the package name and version of installed packages to do stuff properly. Since we can end up with packages compiled against inconsistent versions of their dependencies, and Cabal needs to detect that. That requires knowing the versions of dependencies of each installed package.
06:13:49 <dcoutts> JohnMeacham: I don't know if jhc would have the same issue, depends on how libs work in jhc.
06:13:53 <JohnMeacham> the versions they were compiled against/
06:14:58 <dcoutts> JohnMeacham: right, eg regex-1.0 built against bytestrng-0.9.0.1 and zlib-1.0 built against bytestring-0.9.0.4, then try to use both together and boom. Type error.
06:15:02 <JohnMeacham> jhc versions everything via SHA1 hashes of the dependencies internally. so, the version numbers are more for documentation than anything, jhc won't trust them over the hash'es it calculates.
06:15:37 <dcoutts> JohnMeacham: ah that'd be useful, I've thought about something similar for ghc packages.
06:16:17 <JohnMeacham> basically, inside regex-1.0 it has a list of every module and the sha1 hash of its source code, so if you combine it with another module, as long as all the sha1 hashes of the source it depended on match up, they cleanly combine. sort of a 'lazy conflict resolution'.
06:16:22 <dcoutts> JohnMeacham: so Cabal would like to detect that kind of situation and either resolve things automagically or give a sensible error rather than building and failing.
06:16:32 <gnuvince> Anyone here knows how to play cribbage?
06:17:01 <dcoutts> JohnMeacham: right, Ss that's what we want to detect.
06:17:20 <JohnMeacham> probably it would be easiest to query jhc somehow, or at least have that as an option.... perhaps give it a set of hl files and ask if they are compatable? hmm...
06:17:49 <dcoutts> JohnMeacham: then cabal-install can take that into account when deciding what versions of things to install and what versions of deps it should try to build things against.
06:18:39 <JohnMeacham> okay. I pushed my autoconf/automake stuff out to my darcs repo. I'll start getting some automatic nightly builds going. since my hl files are fully portable I think I will include precompiled versions with the source distribution, I think asking people to install 2G of RAM to just get hello world compiled was a bit much. :)
06:19:02 <gnuvince> Can anyone review this code please? http://hpaste.org/5517
06:19:08 <dcoutts> JohnMeacham: I'll think about it. It might make sense to extend the installed package info with a hash field.
06:19:53 <JohnMeacham> dcoutts: well, maybe as an option. cabal does not need to try to interrpret it at all, it meerly needs to check if they match. so different compilers might use some other suitable identifier.
06:19:55 <gour> @seen ndm
06:19:55 <lambdabot> I haven't seen ndm.
06:20:18 <dcoutts> JohnMeacham: right, we don't necessarily need to know the format of the hash.
06:20:26 <dcoutts> JohnMeacham: since we'd just be comparing them.
06:21:17 <JohnMeacham> it is mainly a ui issue I think. in jhc the hash is always the 'one true name' of a piece of code. names like 'base' or 'regex' are simply there for the benefit of the user and are only UI deep.
06:22:05 <dcoutts> JohnMeacham: though they're the keys used to relate source packages with binary ones and between systems like hackage etc.
06:23:05 <JohnMeacham> yeah, hackage is just a UI of sorts. this is mainly important for pre-compiled libraries.
06:24:26 <JohnMeacham> ooh. man page for jhc. it is like a real program now. :)
06:24:28 <Deewiant> gnuvince: that powerset can probably be improved (length and !! are generally not good ideas), see http://www.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
06:24:29 <lambdabot> Title: powerset, http://tinyurl.com/ynmymy
06:25:27 <JohnMeacham> say what you will about automake, but 'make distcheck' kicks ass for finding bugs in your distribution.
06:26:15 <dcoutts> JohnMeacham: aye, I want to add that to Cabal too.
06:26:22 <gnuvince> Deewiant: can you annotate the code with your comments please?
06:26:31 <dolio> That's not the really devious version of powerset, though.
06:26:56 <Cin> can't you get the powerset using the monadic properties of lists or something?
06:26:57 <Deewiant> gnuvince: I don't really know anything, I just took a look and thought the powerset may or may not be efficient
06:27:07 <dolio> That minimizes the amount of sharing needed at any time.
06:27:10 <mauke> Cin: filterM (return [True, False])
06:27:48 <gnuvince> Deewiant: I know that in Python it is more efficient this way with larger datasets.  Of course, since I only do powersets over 4 or 5 elements, this isn't a problem in my case,.
06:28:24 <Deewiant> gnuvince: the difference is that Python uses arrays, in which (!!) and length are constant-time operations (or at least (!!) is) - in Haskell they're both O(n) where n is the list length
06:28:41 <Deewiant> gnuvince: but if the lists are that small, you're right, it doesn't matter :-)
06:29:54 <gnuvince> I like the line he gives, but I don't understand it.
06:30:10 <JohnMeacham> dcoutts: it would be fairly complicated to add I would think. it does a lot of stuff behind the scenes and has lots of small hooks for changing its behavior. I would like to work on a true declarative build system some day...
06:30:53 <dcoutts> JohnMeacham: distcheck? isn't it just make a tarball, unpack it build it, check that it makes the same tarball again?
06:32:07 <dcoutts> JohnMeacham: it's part of out plan to move Cabal to use a proper dependency framework, like make. So it is more declarative and can support partial rebuilds, and pre-processors better, and to allow parallel builds etc.
06:32:15 <JohnMeacham> no, it also ensures it cleans up every file, it builds the code into a fully seperate tree without write permissions on the main source tree to ensure it doesn't actually write to it, and some other stuff.
06:32:38 <dcoutts> JohnMeacham: we always build into dist/ never writing elsewhere.
06:33:32 <dcoutts> and with a dep framework we can realy enforce that since we can track the location of every file read/written.
06:33:53 <shapr> @yow !
06:33:53 <lambdabot> Yow!  And then we could sit on the hoods of cars at stop lights!
06:34:05 * vincenz votes joelr off planet-haskell?
06:34:48 <dolio> Too much cognitive dissonance about how great Q and K are? :)
06:34:55 <dcoutts> JohnMeacham: we don't yet have the ability to specify the location of the dist/ tree so that we could use a genuinely write protected source tree. It should not be too hard though.
06:35:50 <JohnMeacham> well, it's easier when you can control the universe. but what about when people try to call arbitrary programs from their build scripts? with various intermediate files? I mean, a jhc build involves about 5 perl scripts, an awk program and a small c program that is compied and run to produce some output. it was fairly straightforward to put that into automake with the expected amount of automake funkiness, I woudn't know whe
06:35:50 <JohnMeacham> re to begin with cabal...
06:36:06 <BMeph> vincenz: Why - every organization needs someone to laugh at... ;)
06:36:17 <vincenz> BMeph: I vote qwe1234 then
06:36:21 <vincenz> @qwe1234
06:36:21 <lambdabot> Unknown command, try @list
06:36:23 <vincenz> @qwe
06:36:26 <vincenz> hmm
06:36:33 <vincenz> @bot
06:36:34 <lambdabot> :)
06:36:42 <mauke> @quote qwe
06:36:42 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
06:38:10 <dcoutts> JohnMeacham: so in a dep framework we track the targets and depends of each rule/action. The back door is obviously calling out to external progs. They have to be lifted into such a framework by declaring what they're going to read/write on each call. In debug mode we can check for the consistency of those promises using strace. Violators get lots of negative QA points :-)
06:38:11 <JohnMeacham> as in, a general build system is a _very_ ambitious project, if we can come up with something good, then it shouldn't be tied to haskell. It seems like it should be a seperate project than cabal, or cabal should interface with other systems better. I sort of use cabal like I use rpm spec files, it feels like that niche, my autoconf generates the correct cabal file and cabal is a tool that make calls.
06:38:25 <shapr> What about maak?
06:38:46 <dcoutts> shapr: maak is good, except that it's not a DSEL.
06:39:14 <shapr> ah
06:39:39 <dcoutts> JohnMeacham: yes, I'd expect such a dep framework to be fairly generic and reusable.
06:41:14 <JohnMeacham> certainly something better than make would be great, but it feels like something that should be decoupled from cabal, I want a nice build system for my C apps too :)
06:41:20 <dcoutts> JohnMeacham: so it'd only be tied to Haskell in the sense that it was written and extensible in Haskell :-)
06:41:26 <JohnMeacham> yes.
06:41:57 <JohnMeacham> well, "extensible" is something of a loaded term. it can be a feature or a curse.
06:42:21 <dcoutts> JohnMeacham: right, I don't mean like Makefiles. I'm not talking about runtime code loading or interpreting.
06:42:56 <JohnMeacham> 'mk' was cool. most plan 9 things were.
06:43:28 <dcoutts> the main problem with make is lack of dynamicly discovering dependencies, it assumes we can construct a single graph up front, which is just not possible
06:43:54 <JohnMeacham> http://repetae.net/stuff/mk/ - heh. I collected these papers on it a while ago.
06:43:55 <lambdabot> Title: Index of /stuff/mk
06:43:55 <dcoutts> also, it allows untracked dependencies by separating the language for describing targets/deps from the actions used to update them.
06:44:18 <dcoutts> untracked deps lead to errors and parallel builds failing
06:44:26 <C-Keen> JohnMeacham: mk is part of the plan 9 ports for unix systems for example
06:45:07 <dcoutts> and it's limited to files as targets
06:45:13 <dcoutts> and limited to the IO monad :-)
06:47:13 <JohnMeacham> oh, an incidental thing that this hash system jhc uses allows is a common 'ho' file cache. so if jhc ever sees the exact same file again (even in another project) it can reuse the old compiled result. 'make clean' then 'make' goes super fast :)
06:49:38 <dcoutts> JohnMeacham: nice. btw, the one current issue with ho files in Cabal is that apparently they go in the src dirs which is not allowed. We need to put them in dist/. There's an open bug on that issue.
06:50:51 <dcoutts> presumably there's a way of directing where they go, like for .hl files.
06:53:55 <JohnMeacham> http://repetae.net/jhc-0.3.tar.gz  - okay, I think this should be a working tarball with precompiled libraries if I got the deps right so it doesn't try to clobber or rebuild them.  you should jut be able to untar it and do a 'make helloworld' (assuming you have ghc 6.8 and DrIFT installed)
06:54:25 <JohnMeacham> but now I should nap for a bit.
06:58:50 <dcoutts> JohnMeacham: great :-)
06:59:18 <JohnMeacham> dcoutts: yeah, I was actually just going to work on that as it caused issues with automake too. though, I may just turn on ho-caching by default if it turns out to be stable enouugh.
07:00:57 <dcoutts> JohnMeacham: is there any limit to the cache size?
07:01:10 <cjb> JohnMeacham: hey hey
07:02:50 <JohnMeacham> cjb: hey hey. hmm.. I bet I can get rid of the DrIFT requirement with a dist-hook: to preproces the files. that should help people out.
07:03:51 <dcoutts> JohnMeacham: I'm installing drift as we speak, first ./configure bug report though: it doesn't detect the lack of drift correctly though I can see it tries to do so.
07:03:58 <dcoutts> ./configure: line 2373: error:: command not found
07:04:10 <Mr_Awesome> how does (fix show) actually produce output?
07:04:44 <quicksilver> Mr_Awesome: because the show instance for Strings produces a " before instpecting the contents of the string
07:04:52 <quicksilver> Mr_Awesome: that boostraps the process, as it were
07:05:10 <Mr_Awesome> ah
07:05:35 <quicksilver> show s = '"' : escape_string s ++ ['"']
07:05:35 <b_jonas> > fix show
07:05:37 <quicksilver> basically
07:05:48 <quicksilver> and that '"' : allows it to make progress
07:05:49 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:06:19 <Mr_Awesome> still, fixed points baffle me. im trying to read erkok's thesis and its just not making sense
07:06:27 <b_jonas> it should produce a finite quine
07:06:44 <b_jonas> Mr_Awesome: well, you know that
07:06:46 <b_jonas> @src fix
07:06:46 <lambdabot> fix f = let x = f x in x
07:06:48 <quicksilver> show doesn't have any finite quines
07:06:49 <b_jonas> this is the definition
07:07:05 <Mr_Awesome> ok
07:07:07 <quicksilver> show is strictly expansive
07:07:18 <quicksilver> length (show s) >= length s + 2
07:07:37 <b_jonas> quicksilver: yeah, it doesn't do abbreviations so that read can be simple
07:08:05 <Mr_Awesome> what is an application of fix that is actually useful?
07:08:22 <quicksilver> Mr_Awesome: all recursive functions.
07:08:25 <mux> I find it nice to write looks when in monads
07:08:27 <quicksilver> (values)
07:08:36 <mux> loops, rather
07:09:23 <Mr_Awesome> quicksilver: what do you mean? that you can rewrite all recursive functions in terms of fix?
07:09:30 <mux> yes
07:09:37 <mux> fix is the essence of recursion
07:09:39 <quicksilver> Mr_Awesome: exactly.
07:09:50 <quicksilver> Mr_Awesome: and if your language supports recursion natively, fix is totally useless.
07:10:08 <quicksilver> fix is precisely recursion; all instances of the one can be translated into the other.
07:10:15 <quicksilver> and vice versa
07:10:50 <b_jonas> I'm baffled to hear the statement "and if your language supports ..." -- you're speaking as if there were a host of lazy languages out there
07:11:21 <Mr_Awesome> so in haskell fix is totally useless?
07:11:27 <idnar> b_jonas: what does laziness have to do with it?
07:11:30 <b_jonas> > fix (1:)
07:11:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:11:46 <b_jonas> idnar: well, fix is implicitly assuming the language is lazy
07:11:54 <idnar> b_jonas: why?
07:11:55 <mauke> b_jonas: since when?
07:11:59 <b_jonas> it wouldn't work in a strict language I think
07:11:59 <quicksilver> Mr_Awesome: correct.
07:12:00 <twanvl> fix is useless in the same sense that every other function is useless: you could write it yourself if it wasn't there.
07:12:14 <mauke> b_jonas: I've used fix in perl
07:12:16 <mux> b_jonas: only the specific implementation of haskell wouldn't work in strict languages
07:12:18 <idnar> b_jonas: that definition of fix wouldn't work in a strict language for, say, fix (1:)
07:12:21 <b_jonas> mauke: hmm
07:12:21 <b_jonas> how?
07:12:25 <roconnor> @src fix
07:12:25 <lambdabot> fix f = let x = f x in x
07:12:27 <Mr_Awesome> quicksilver: okay, thanks. i already feel like i understand erkok's thesis better. :)
07:12:33 <idnar> b_jonas: but any finite recursion with fix will still work assuming you don't run out of stack space or something
07:12:51 <mauke> sub fix (&) { my $f = shift; sub { $f->(&fix($f), @_) } }
07:12:53 <quicksilver> the result of fix (1:) is not useful in a strict langauge
07:13:04 <jedbrown> You can write fix in a strict language, it's just much uglier.
07:13:18 <quicksilver> because it doesn't terminate and in a strict language you can't inspect 'part of' a non-terminating value
07:13:25 <quicksilver> your program just loops or runs out of stack space
07:13:29 <idnar> quicksilver: you could do something pretty close, though
07:13:51 <quicksilver> idnar: it wouldn't be the same thing, though. It would be an explicit delay of some kind.
07:14:08 <idnar> quicksilver: sure
07:14:12 <quicksilver> however, fix f = f (fix f)
07:14:35 <b_jonas> mauke: I see
07:14:38 <quicksilver> sorry, not what I was trying to say.
07:14:45 <quicksilver> any uses of fix which do, in fact, terminate
07:14:47 <b_jonas> so it returns a sub (to simulate a promise) basically
07:14:52 <quicksilver> will still terminate in a strict language.
07:14:59 <quicksilver> like using fix to define factorial
07:15:03 <b_jonas> so that's like the y combinator or something like that
07:15:08 <b_jonas> I see
07:15:31 <mauke> well, it's curried for convenience here
07:15:42 <b_jonas> well, sort of
07:16:17 <mauke> sub fix { my $f = shift; $f->(sub { fix($f, @_) }, @_) }
07:16:53 <b_jonas> mauke: yes, that's better
07:17:01 <sioraiocht> dcoutts: ping
07:17:02 <b_jonas> it definitely looks like a y combinator that way
07:17:08 <mauke> FSVO "better"
07:17:17 <sioraiocht> or dcoutts_ , whoever you are atm
07:17:24 <b_jonas> mauke: ok, more familiar to me
07:17:29 <b_jonas> not really better
07:17:43 <mauke> do_stuff_with(fix { my ($self, @args); ... $self->() }); is easier when you need an ad-hoc recursive callback
07:17:47 <mauke> or something
07:20:11 <sioraiocht> @seen dcoutts_
07:20:12 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 2h 34m 40s ago.
07:20:15 <sioraiocht> @seen dcoutts
07:20:15 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 16m 17s ago.
07:22:06 <shag> it appears to me that when the socket is closed while sending a ByteString via Data.ByteString.hPut over the network, my program just exits. no matter what i am trying to handle this via something from Control.Exception. is this correct?
07:22:33 <b_jonas> mauke: yeah
07:22:42 <b_jonas> it allows you to have recursive closure
07:22:43 <b_jonas> s
07:22:56 <b_jonas> (probably you write the fix combinator in the right way so it doesn't leak,
07:23:02 <quicksilver> shag: you need to handle SIGPIPE
07:23:07 <b_jonas> I can't tell off-hand if the implementation you gave is like that or not)
07:23:12 <shag> quicksilver: i am handling everything :)
07:23:13 <quicksilver> (probably by ignoring it)
07:23:26 <quicksilver> No, you are not.
07:23:34 <quicksilver> SIGPIPE is not an exception, it is a posix signal.
07:23:40 <shag> ah ok
07:23:45 <quicksilver> It doesn't not get turned into a Control.Exception ;)
07:23:47 <shag> how do i do that?
07:24:17 <quicksilver>   installHandler sigPIPE Ignore Nothing
07:24:26 <allbery_b> System.Posix.Signals
07:24:26 <glen_qua1mire> sigpipe is a blog
07:25:30 <dcoutts> sioraiocht: pong
07:26:13 <shag> quicksilver: hm, it's even in the docs for the network module. thanks and sorry for the ignrorance ... :)
07:26:33 <quicksilver> ;)
07:27:10 <quicksilver> I have sometimes wished that SIGPIPEs woudl automatically convert to exceptions
07:27:17 <quicksilver> but there are questions, like "which thread to throw it to"
07:27:25 <quicksilver> and, anyway, just ignoring it is safe enough
07:27:32 <Vq^> @pl \f -> ap (zipWith f) tail
07:27:32 <lambdabot> (`ap` tail) . zipWith
07:27:32 <quicksilver> you get EPIPE instead which you can handle locally
07:27:41 <JohnMeacham> quicksilver: they do, if you ignore it then it turns into an error when you write.
07:27:46 <JohnMeacham> which gives an IOError.
07:27:50 <quicksilver> right
07:27:53 <quicksilver> which is what I said :)
07:28:00 <quicksilver> but you do have to ignore it to get that behaviour
07:28:36 <JohnMeacham> yeah, we should just make that the default in haskell compilers. the fact it isn't ignored by default is an odd historical curiosity.
07:28:47 <sieni> my friend had a company called "Broken Pipe" and naturally the domain name of the company was epipe.fi
07:30:50 <quicksilver> ;)
07:31:11 <Spockz> 'day
07:33:58 <shapr> yay code!
07:34:18 <Spockz> where?!
07:34:44 <kaol> > 1 + 1
07:34:45 <lambdabot>  2
07:35:17 <gnuvince> > :t map
07:35:17 <lambdabot>   parse error on input `:'
07:35:25 <gnuvince> :t map
07:35:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:35:30 <shag> quicksilver: now i have a more special question about this installHandler thing: do i have to install the handler again for every thread created with forkIO or just once for the whole program?
07:36:22 <shapr> I think joelr needs ritalin more than I do.
07:36:41 <shapr> Spockz: I've got code right here! What about you? Written any Haskell lately?
07:36:45 <shag> the same question raises regarding the withSocketsDo call
07:36:53 <quicksilver> shag: the whole problem. It's a unix-level thing.
07:36:56 <quicksilver> erm
07:36:59 <quicksilver> whole program.
07:37:05 <shag> ok
07:37:18 <quicksilver> withSocketsDo is only needed on broken OSes.
07:37:20 <quicksilver> :P
07:37:31 <quicksilver> and in particular, that OS doesn't support System.Posix
07:37:58 <Spockz> shapr: yes, today in college
07:38:08 <psyonic> I am trying to use Data.Tree.AVL.  I made a singleton tree with let q = Data.Tree.AVL.singleton "hello".  Now I would like to use Data.Tree.AVL.genPush (?) q "goodbye".  FOr the (?) I need some COordering e, but I can't figure out exactly what it wants there?  Any ideas?
07:38:10 <Spockz> i'm just getting started
07:38:22 <shag> yea, but if someone ever tries to get this runnign on windows, at least he needs not to care about withSocketsDo ;)
07:39:09 <mux> didn't latest windows version stop implementing sockets as a library (winsock) and thus don't need that initialization call anymore?
07:41:41 * dcoutts thinks that libs that need initialisation are broken
07:41:54 <dcoutts> just say no to global state!
07:42:18 <mux> _init() :-)
07:42:20 <Spockz> state in haskell? Isn't that like cursing in a church? :)
07:42:28 * quicksilver points his finger firmly and angrily at System.Random.
07:43:23 <dcoutts> quicksilver: quite.
07:43:43 <quicksilver> theStdGen  = unsafePerformIO $ do
07:43:43 <quicksilver>    rng <- mkStdRNG 0
07:43:43 <quicksilver>    newIORef rng
07:44:01 <quicksilver> It doesn't even have the no-cse no-inline flags in the source I'm looking at
07:44:04 <dcoutts> it's not like sockets need initialising, they've already got this sane resource creation system to create a .... socket!
07:44:26 <dcoutts> why an extra global initialisation? it's borked
07:45:29 * jedbrown thinks it is okay that MPI needs initializing.
07:45:30 <glen_qua1mire> what's a simple monad class?
07:45:41 <glen_qua1mire> is Maybe simplest?
07:45:41 <mux> sockets as a library has other issues, you can't use read() or write() on the socket anymore, and need to use send() and recv(); this is a pain when porting C code to windows
07:46:14 <quicksilver> glen_qua1mire: yes, I would say so.
07:46:19 <glen_qua1mire> i want to try if, M a >>= return == M a
07:46:24 <quicksilver> glen_qua1mire: (the simplest monad class is Monad)
07:46:30 <quicksilver> glen_qua1mire: (Maybe is an instance not a class  :P )
07:46:47 <quicksilver> mux: that's interesting, I never knew that.
07:47:01 <quicksilver> mux: I like using FDs for sockets pipe and files, feels much more uniform.
07:47:10 * mux nods
07:47:33 <mux> maybe this has changed, but I had to do this renaming a while back to make some code written at school run on windows
07:47:40 <quicksilver> but then I've never programming in windows really
07:47:43 <quicksilver> \o/
07:47:54 <mux> and there's also the dreaded O_BINARY, heh
07:47:56 * mux frowns
07:48:00 <glen_qua1mire> > case Just 1 >>= return of Just 1 -> True; _ -> False
07:48:04 <lambdabot>  True
07:48:23 <vincenz> > Identity 1 >>= id
07:48:23 * BMeph Thinks of Bool as a monad
07:48:23 <lambdabot>   add an instance declaration for (Num (Identity b))
07:48:31 <vincenz> > Identity 1 >>= return
07:48:32 <lambdabot>   add an instance declaration for (Show (Identity t))
07:51:21 <shapr> Spockz: Was it good code? Are you enjoying it?
07:51:39 <Spockz> well just writing my own tail and head
07:51:58 <shapr> What's next for you then?
07:52:04 <Spockz> i'm not sure
07:52:19 <shapr> What do you want to evaluate today?
07:52:31 <shapr> MS Haskell 2008
07:52:32 <Spockz> I think they'll let us determine some types of functions
07:52:35 <shapr> ooh, neat.
07:52:37 <glen_qua1mire> i heard haskell compiles to a base language, whre can I find information about the base language?
07:52:49 <shapr> Spockz: Ok, what's the type of \x -> x ?
07:52:52 <glen_qua1mire> i'm not sure if it was referring to c--
07:53:05 <shapr> glen_qua1mire: It could be either C-- or STG
07:53:13 <Spockz> shapr: I don't know the \ command?
07:53:15 <mux> System Fc
07:53:21 <mux> or C--
07:53:37 <dolio> Or YHC core.
07:53:38 <shapr> Spockz: That's how you define an anonymous function.
07:53:45 <Spockz> lambda functions?
07:53:50 <Spockz> that's our next chapter
07:53:56 <shapr> > let inc = \x -> x + 1 in inc 2
07:53:57 <lambdabot>  3
07:54:03 <mux> http://www.cminusminus.org/
07:54:04 <lambdabot> Title: C-- Home
07:54:16 <glen_qua1mire> like, which operations are core to haskell?
07:54:16 <Spockz> shapr: what does that in saying?
07:54:24 <mauke> > (\x -> x * x + x) 4
07:54:24 <glen_qua1mire> @src id
07:54:24 <lambdabot> id x = x
07:54:24 <lambdabot>  20
07:54:46 <shapr> Spockz: huh?
07:54:57 <Spockz> let inc = \x -> x + 1 __in__ inc 2
07:55:01 <shapr> ohh
07:55:01 <Spockz> what is in?
07:55:13 <mauke> Spockz: "let" .. "in"
07:55:19 <mauke> it defines local variables
07:55:20 <shapr> let is how you define something that's local to the function.
07:55:28 <shapr> > let x = 1 in x + 1
07:55:29 <lambdabot>  2
07:55:39 <mauke> let VARIABLE = EXPRESSION in BODY
07:55:40 <shapr> That's the same as saying 1 + 1, nothing exciting :-)
07:55:46 <Spockz> ah I get it :)
07:56:00 <shapr> mauke's example was simpler, he didn't use let.
07:56:07 <shapr> > (\x -> x + 1) 1
07:56:08 <lambdabot>  2
07:56:09 <int-e> > do let x = 1; print x -- not to be confused with "let" in "do" blocks.
07:56:09 <lambdabot>  Parse error at end of input
07:56:13 <mae> if i want to
07:56:15 <int-e> meh
07:56:22 <kjdf> I can't build the plugins package, I am getting an error like this: http://hackage.haskell.org/packages/archive/plugins/1.0/logs/failure/ghc-6.8
07:56:23 <lambdabot> http://tinyurl.com/2ow7gq
07:56:24 <shapr> mae: If you want to what?
07:56:27 <kjdf> can this be easily fixed?
07:56:29 <Spockz> but still, I don't get it
07:56:40 <shapr> Spockz: don't get what?
07:56:52 <Spockz> let inc = \x -> x + 1 __in__ inc 2
07:56:55 <Spockz> what does that \x?
07:57:08 <Spockz> or does that stand for an anonymous function?
07:57:13 <mauke> \x -> x + 1 is the function
07:57:23 <roconnor> :t \x -> x + 1
07:57:23 <lambdabot> forall a. (Num a) => a -> a
07:57:32 <shapr> The back slash means "arguments to the function start here" and the -> means "list of arguments is done, now we start doing stuff to those arguments"
07:57:34 <mauke> "\" means "this is a function with the following parameters"
07:58:13 <Spockz> aaah :P
07:58:16 <Spockz> got it
07:58:18 <shapr> So \x y -> x + y means "This code takes two arguments, we're going to call them x and y." and then "Ok, we're going to add those two arguments together now."
07:58:36 <mauke> > (\x y -> x + y) 39 3
07:58:37 <lambdabot>  42
07:58:37 <Spockz> nice :)
07:58:48 <Spockz> I understand now :D
07:59:01 <Spockz> type: Int -> Int -> Int?
07:59:14 <mauke> :t (\x y -> x + y)
07:59:15 <lambdabot> forall a. (Num a) => a -> a -> a
07:59:19 <mauke> it's a bit more general
07:59:27 <mauke> it works for all numbers, not just Ints
07:59:29 <Spockz> ah yes ofcourse
07:59:45 <shapr> Spockz: Python and C# and some other languages also have anonymous functions (also known as lambdas in some places) but I haven't seen another language in which anonymous functions are as simple and easily used.
07:59:53 <glen_qua1mire> lambdabot: ghc
08:00:05 <mauke> > (\x -> x) (\x -> x) "what"
08:00:06 <lambdabot>  "what"
08:00:45 <shapr> Spockz: Also, Haskell is unusual (unique?) in that you can partially apply functions, meaning that you can fill in one argument and you get back a function that acts like you filled in that argument from the beginning.
08:00:56 <shapr> For example...
08:01:17 <Spockz> yes, I noticed that. Is that a property of Haskell or for all FP functions?
08:01:29 <shapr> > let addOne = (\x y -> x + y) 1 in addOne 2
08:01:29 <lambdabot>  3
08:01:46 <gnuvince> Spockz: it's called currying, some functional languages (and impertive ones as well) have that feature.
08:01:48 <mauke> it's a matter of having curried functions
08:01:52 <shapr> Currying is a property of the lambda calculus.
08:02:05 <mauke> does SML have autocurrying?
08:02:15 <shapr> @wikipedia Currying
08:02:16 <lambdabot> No Result Found.
08:02:20 <mauke> i.e. you say fun x y z => and it turns into fun x => fun y => fun z?
08:02:23 <shapr> http://en.wikipedia.org/wiki/Currying
08:02:23 <lambdabot> Title: Currying - Wikipedia, the free encyclopedia
08:03:00 <shapr> gotta go, bbl
08:03:42 <Spockz> ok
08:03:43 <Spockz> hf
08:03:44 <mauke> Spockz: anyway, I know OCaml behaves the same way WRT functions
08:04:29 <Spockz> ok, nice to know
08:05:36 <mauke> and in OCaml (fun x y -> x + y) has the type int -> int -> int :-)
08:05:51 <Spockz> Not Num a?
08:06:14 <mauke> no, OCaml doesn't have type classes
08:06:34 <Spockz> so what about Floats?
08:07:00 <mauke> you have to use different operators, like +. instead of +
08:07:19 <mauke> (+.) : float -> float -> float
08:07:30 <glen_qua1mire> CoreTidy was what i was looking for
08:08:39 <Spockz> mauke: not very transparent
08:11:27 * dcoutts starts building jhc, 9 modules out of 163...
08:11:30 <glen_qua1mire> oh no, CoreSyn was it. or System FC
08:12:52 <kjdf> I have added new dependencies to plugins .cabal file, that fixed "package is hidden" error
08:13:01 <kjdf> but now I get this instead: http://hpaste.org/5541
08:14:03 <dcoutts> kjdf: trying to build lambdabot?
08:14:13 <kjdf> dcoutts: yes
08:14:40 <dcoutts> kjdf: using the latest code right? http://code.haskell.org/lambdabot/
08:14:42 <lambdabot> Title: Index of /lambdabot
08:15:05 <kjdf> dcoutts: yes, but I haven't got past dependencies yet
08:16:08 <dcoutts> kjdf: so where are you getting the plugins lib from? sounds like you're using a very old version
08:16:32 <dcoutts> pgavin: we're confused about your ranlib makefile patch btw, some more info would be good.
08:16:49 <pgavin> dcoutts: ok
08:17:14 <pgavin> dcoutts: so, the ghc build uses ./setup makefile to compile each library
08:17:25 <pgavin> dcoutts: at least, ghc-6.8 does
08:17:31 <dcoutts> pgavin: yes, and it works on most arches right?
08:17:51 <pgavin> dcoutts: well, I've only tried it on linux & mac os x
08:17:55 <kjdf> dcoutts: from hackagedb, version 1.0
08:17:58 <pgavin> dcoutts: linux works find
08:18:00 <pgavin> *fine
08:18:04 <dcoutts> kjdf: try the latest darcs version
08:18:31 <pgavin> dcoutts: but the mac os x build would fail when trying to link to libHShaskell98.a
08:18:42 <dcoutts> pgavin: and it builds ok on osx too, otherwise we'd have hoards of users complaining
08:18:45 <pgavin> dcoutts: but if I ran ranlib on the library, the build would continue
08:18:56 <pgavin> dcoutts: hmm
08:19:07 <dcoutts> pgavin: so what is different about your setup that it fails but works everywhere else?
08:19:13 <pgavin> dcoutts: not sure
08:19:27 <pgavin> dcoutts: I'm building against macports, using the apple gcc and ld
08:19:32 <dcoutts> pgavin: I don't dispute that it should run ranlib, you can see we do that for the normal non-makefile build.
08:19:43 <pgavin> dcoutts: right, I checked that also
08:19:48 <dcoutts> I prefer not to touch the makefile side of things :-)
08:20:06 <pgavin> dcoutts: k, well, should I post something to the ghc list?
08:20:11 <dcoutts> pgavin: so what are you using from macports?
08:20:17 <pgavin> dcoutts: gmp and readline
08:20:29 <dcoutts> pgavin: normal ghc uses native apple gcc and ld too
08:20:41 <pgavin> dcoutts: right, that's what I'm using
08:21:05 <dcoutts> pgavin: yes, post your findings to the ghc bugs list
08:21:15 <pgavin> dcoutts: ok, will do
08:21:37 <dcoutts> pgavin: btw, seems to me we should avoid using ranlib on all platforms and just use ar -s
08:22:29 <pgavin> dcoutts: hmm, why's that?
08:22:52 <dcoutts> pgavin: that builds libs with an index, then there's no need to use ranlib
08:23:12 <dcoutts> pgavin: and it means we can use the lib immediately inplace, rather than doing ranlib only when installing
08:23:21 <kjdf> dcoutts: I tried with the darcs version, it doesn't work in the same way (first cabal deps, then this STArray error)
08:23:38 <dcoutts> kjdf: not sure then, ask dons or Cale
08:23:48 <pgavin> client crashed :/
08:23:50 <dcoutts> pgavin: and it means we can use the lib immediately inplace, rather than doing ranlib only when installing
08:25:09 <pgavin> dcoutts: ah, ok
08:30:47 <dcoutts> grr, installing static libs on OSX 'breaks' them.
08:31:01 <dcoutts> so we always have to run ranlib when installing them
08:31:27 <dcoutts> that's so stupid. what do package mangers do? reset the timestamps or run ranlib too?
08:32:29 <pgavin> dcoutts: not sure :)
08:32:41 <kaol> > (((+1) . (+2)) 3, ((+1) `fmap` (+2)) 3)
08:32:41 <lambdabot>  (6,6)
08:32:53 <pgavin> dcoutts: I can peek around in the macports makefiles
08:33:01 <dcoutts> pgavin: see the BUGS section in man ranlib
08:33:06 <mauke> > [(.), fmap, liftM, (<$>)]
08:33:06 <lambdabot>  Add a type signature
08:33:09 <mauke> :t [(.), fmap, liftM, (<$>)]
08:33:10 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
08:33:30 <kaol> ew, redundancy.
08:33:41 <mauke> :t [(.), fmap, liftM, (<$>), id]
08:33:42 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
08:33:42 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:33:42 <lambdabot>     In the expression: id
08:33:43 <ricky_clarkson> I agree.
08:33:54 <Cin> oh god that border on xmonad is ruining mplayer fullscreen
08:34:11 <pgavin> dcoutts: I suppose if you keep the timestamp on the library the same, it should be ok
08:34:16 <mauke> Cin: guess which module I wrote to fix that manually? :-)
08:34:26 <dcoutts> pgavin: which means copy doesn't work
08:35:12 <Cin> mauke: no idea
08:35:22 <pgavin> dcoutts: right :/
08:35:41 <pgavin> dcoutts: cp -p would work though
08:35:52 <mauke> Cin: XMonad.Actions.NoBorders
08:36:30 <dcoutts> pgavin: I'm not sure we can do that portably in Haskell code though
08:36:43 <jedbrown> My Storable instance overlaps with hmatrix's.  Since people will likely want to use these packages together, how should I fix this?
08:36:46 <dcoutts> pgavin: I guess we just have to distinguish installing different kinds of files
08:37:11 <Cin> mauke: i'll have to take a look at that
08:38:16 <kaol> @src Functor
08:38:16 <lambdabot> class  Functor f  where
08:38:16 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:39:51 <glen_qua1mire> > prettyPrint [1,2,3,[1,2,[1,2,[1,2,3]],3],4]
08:39:52 <lambdabot>   Not in scope: `prettyPrint'
08:40:12 <glen_qua1mire> > Language.Haskell.Pretty.prettyPrint [1,2,3,[1,2,[1,2,[1,2,3]],3],4]
08:40:13 <lambdabot>   Not in scope: `Language.Haskell.Pretty.prettyPrint'
08:40:58 <dolio> Those aren't even well-typed lists.
08:41:24 <dolio> Unless you add Num instances for Num n => [n].
08:41:40 <glen_qua1mire> oh darn programming is so hard
08:41:53 <glen_qua1mire> it's actually Expr [1,2,3, List [1,2, ..
08:41:57 <glen_qua1mire> my own data types
08:42:05 <dolio> Ah.
08:42:09 <mauke> [[[[1]]],[[[2]]],[[[3]]],[[[1]],[[2]],[[1],[2],[1,2,3]],[[3]]],[[[4]]]]
08:47:48 <kaol> what was the connection between functors and monads, again?
08:48:04 <quicksilver> all monads are functors
08:48:14 <kaol> @src Monad
08:48:15 <lambdabot> class  Monad m  where
08:48:15 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:48:15 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:48:15 <lambdabot>     return      :: a -> m a
08:48:15 <lambdabot>     fail        :: String -> m a
08:48:23 <quicksilver> with fmap = (>>=) . return
08:48:23 <mrd-> or should be
08:49:20 <idnar> how often do Monad instances define their own (>>)?
08:49:33 <kaol> um. didn't we just have that (.) == fmap?
08:50:28 <dolio> idnar: Not often, I think.
08:51:08 <kaol> @type (>>=) `fmap` return
08:51:09 <lambdabot> forall (m :: * -> *) b a. (Monad m) => a -> (a -> m b) -> m b
08:51:17 <kaol> @type (>>=) . return
08:51:17 <lambdabot> forall (m :: * -> *) b a. (Monad m) => a -> (a -> m b) -> m b
08:51:56 <dolio> @src (->) fmap
08:51:56 <lambdabot> fmap = (.)
08:52:10 <idnar> heh
08:54:30 <kaol> that seems awfully circular to me
08:54:52 <dolio> What does?
08:55:08 <kaol> fmap = (>>=) `fmap` return
08:56:16 <kaol> or is that a different fmap on the RHS?
08:56:48 <kaol> yes. of course.
08:56:54 <dolio> Well, on the right it's fmap in the (->) e monad.
08:57:10 <dolio> On the left, it's the fmap of any monad.
08:57:16 <dolio> Is Cale around?
08:57:39 <Spockz> dolio: he is in the list
08:58:07 <dolio> Yeah, well, the question is if he's awake.
08:59:20 <kuribas> If I have a datatype "data MyData = A | B | C | D", can I test how much the difference is in position between two elements?  (like C - A = 2)
08:59:28 <Spockz> dolio: what time do you have there? :)
08:59:38 <dolio> Noon.
08:59:40 <mauke> kuribas: if you derive Enum, yes
08:59:45 <Spockz> ah here it is 18:00
08:59:52 <kuribas> mauke: Ah, Enum, that's what I need, thanks!
09:00:00 <dcoutts> @seen MarcWeber
09:00:00 <lambdabot> MarcWeber is in #haskell and #darcs. I don't know when MarcWeber last spoke.
09:00:08 <desegnis> kuribas: ... deriving (Enum); then: abs(fromEnum x - fromEnum y)
09:00:10 <dolio> That doesn't really matter. Cale can be awake at any time of the day. :)
09:00:11 <mauke> data MyData = A | B | C | D deriving (Read, Show, Eq, Ord, Enum, Bounded)  -- because I can
09:00:53 <kuribas> desegnis: Great, thanks!
09:01:02 <dolio> I guess it doesn't matter anymore. The spamming has stopped.
09:01:17 <gwern> I have been wondering: is there anyway for a program to get its current location? ie, if I have a haskell program at /usr/bin/script and I call it from ~/, how could it figure out for sure that it is at /usr/bin/script and not be uncertain it actually exists as the same thing in ~/bin or somewhere?
09:01:43 <mauke> gwern: a program can have 0 or more names
09:02:29 <mauke> apparently linux puts that information in /proc/self/exe
09:02:33 <gwern> mauke: you mean the argv thing? I thought of that, but it just returns the non-pathname it was called with, iirc; busybox does that
09:02:39 <mauke> no, not argv
09:02:45 <mauke> the actual filename
09:03:16 * gwern cats /proc/self/exe. yikes!
09:03:20 <mauke> huhu
09:03:32 <mauke> try readlink
09:04:13 <mauke> /proc/self/exe is a bit like v
09:04:14 <gwern> hm. interesting
09:04:15 <mauke> @v
09:04:16 <lambdabot> "\""
09:04:29 <gwern> is there any cross-platform way of doing it, though?
09:05:00 <gwern> it'd be nice to have a way which worked on linux, Mac, and windows as well
09:05:12 <monochrom> It's already cross-platform over linux, bsd, solaris, ...  <duck>
09:05:18 <gwern>  /proc stuff is often linux specific, iirc
09:06:06 <monochrom> Next time I'll try a more fine-grain one. "fedora, suse, ubuntu, ..." :)
09:06:34 <dcoutts> gwern: you cannot ever do it reliably on uniux, since the file does not even need to exist any more
09:06:52 <dcoutts> since you can delete the executable
09:07:01 <gwern> ack. that's not good
09:07:02 <mauke> or it could have 100 names at the same time (yay hard links)
09:07:15 <dcoutts> gwern: on the contrary, it's excellent!
09:07:38 <dcoutts> I once had a job where I needed to make a Windows program that could update itself
09:07:54 <dcoutts> that's a pain in the posterior when the program cannot delete it's own executable file
09:07:58 <gwern> dcoutts: I was hoping there was a simple solution to my problems with the GHC api needing you to say where GHC actually is, but I guess /proc/self/exe is not the solution
09:08:15 <dcoutts> gwern: it allows upgrading unix progs without having to shut them down
09:08:15 <quicksilver> indeed the program may never have existed on any accessible filesystem
09:08:23 <quicksilver> such as when you are running in a chroot
09:08:27 <quicksilver> or a virtual machine of some kind
09:08:34 <quicksilver> there is no 'meaningful path' to the executable then
09:08:47 <dcoutts> gwern: no /proc/self/exe would not help anyway since that's the program's location, not the location of ghc's libs.
09:09:05 <quicksilver> the answer is configuration in a well known global place
09:09:10 <quicksilver> like /etc/ghc.conf
09:09:14 <gwern> dcoutts: it was a step in the right direction
09:09:19 <quicksilver> possibly overridable by ~/ghc.conf
09:09:25 <quicksilver> depending on security concerns
09:09:29 <quicksilver> for a particular application
09:09:40 <quicksilver> if there are no security concerns, an environment variable over-ride is useful
09:15:10 <Deewiant> @undo do let x = (a \\ b); return x
09:15:10 <lambdabot>  Parse error at end of input
09:15:19 <Deewiant> @undo do return (a \\ b)
09:15:19 <lambdabot> return (a \\ b)
09:15:22 <Deewiant> ^ lambdabot bug?
09:15:58 <allbery_b> @undo do let { x = (a \\ b) }; return x
09:15:58 <lambdabot> let { x = (a \\ b)} in return x
09:16:20 <dcoutts> @undo do { let x = (a \\ b); return x }
09:16:20 <lambdabot>  Parse error at "}" (column 33)
09:16:22 <Deewiant> @pl \x -> x \\ y
09:16:23 <lambdabot> (line 1, column 9):
09:16:23 <lambdabot> unexpected "\\"
09:16:23 <lambdabot> expecting variable, "(", operator or end of input
09:16:41 <Deewiant> it gets confused with backslashes
09:16:42 <allbery_b> the brace insertion rule in haskell is a killer for parsers
09:17:09 <Deewiant> @undo do let x = (a + b); return x
09:17:09 <lambdabot>  Parse error at end of input
09:17:30 <mauke> Prelude> do let x = 2; return x
09:17:30 <mauke> <interactive>:1:22: parse error (possibly incorrect indentation)
09:17:54 <Deewiant> alright, so it needs the braces
09:18:26 <Deewiant> still, it can't handle backslashes properly
09:27:07 <sm> morning
09:31:00 <kjdf> is there a standard function that would apply a list of functions to an object?
09:31:04 <Ling> Afternoon, does anyone know how I could produce a COM object in haskell without too much effort?  HDirect looked promising, but won't compile against latest GHC.
09:31:17 <kjdf> fun :: [a -> a] -> a -> a
09:31:33 <smtms> kjdf, a list of function as in a composition of functions?
09:31:58 <kjdf> smtms: yes
09:32:00 <Saul> kjdf: map (<*> x) fs
09:32:01 <kjdf> smtms: thanks :)
09:32:10 <idnar> @src (->) join
09:32:10 <lambdabot> Source not found. Sorry.
09:32:17 <allbery_b> or sequence in ((->) r)
09:32:28 <allbery_b> (I think)
09:32:28 <idnar> @src (->) sequence
09:32:29 <lambdabot> Source not found.
09:32:31 <idnar> meh
09:32:35 <allbery_b> @src sequence
09:32:35 <lambdabot> sequence ms = foldr k (return []) ms
09:32:35 <lambdabot>     where
09:32:35 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:32:46 <Saul> kjdf: Ignore that, this one applies each function in the list and returns a list with the results
09:32:49 <conal> :ty foldr (.) id
09:33:08 <conal> @type foldr (.) id
09:33:09 <lambdabot> forall a. [a -> a] -> a -> a
09:34:12 <idnar> sequence isn't really what you want
09:34:22 <glen_quagmire> > foldr (.) id [1,2,3]
09:34:23 <lambdabot>   add an instance declaration for (Num (a -> a))
09:34:23 <lambdabot>     In the expression: 3
09:34:27 <conal> kjdf: try foldr (.) id .  also think about in which order you want the functions to be applied, in case you want to reverse first.
09:34:34 <dons> Ling: you'll have to ask on the mailing list
09:34:42 <dons> there are some windows programmers who will know
09:35:20 <idnar> @hoogle [a -> a] -> a -> a
09:35:21 <lambdabot> No matches, try a more general search
09:35:33 <Saul> > folr (.) id [id, (+3), (*4), (3-)] 5
09:35:34 <lambdabot>   Not in scope: `folr'
09:35:37 <Saul> > foldr (.) id [id, (+3), (*4), (3-)] 5
09:35:38 <lambdabot>  -5
09:35:54 <Ling> dons: thanks
09:35:56 <idnar> > foldr (.) id [id, (+3)] 5
09:35:56 <lambdabot>  8
09:36:01 <idnar> > foldr (.) id [id, (+3), (*2)] 5
09:36:01 <lambdabot>  13
09:36:09 <idnar> oh, wrong order
09:36:13 * idnar confuses himself
09:36:27 <idnar> > foldl (.) id [(+3), (*2)] 5
09:36:28 <Saul> (\fs x -> map (<*> x) fs) [id, (+3), (*4), (3-)] 5
09:36:28 <lambdabot>  13
09:36:33 <Saul> > (\fs x -> map (<*> x) fs) [id, (+3), (*4), (3-)] 5
09:36:33 <lambdabot>   add an instance declaration for (Num ((a -> b) -> a))
09:37:03 <Saul> > (\fs x -> map (<*> [x]) fs) [id, (+3), (*4), (3-)] 5
09:37:03 <lambdabot>  Couldn't match expected type `[a -> b]'
09:37:36 <idnar> > :t map (<*> 5) [id, (+3), (*4), (3-)]
09:37:36 <lambdabot>   parse error on input `:'
09:37:41 <idnar> :t map (<*> 5) [id, (+3), (*4), (3-)]
09:37:42 <lambdabot> forall a b. (Num ((a -> b) -> a), Num (a -> b)) => [(a -> b) -> b]
09:38:02 <idnar> I don't think <*> makes any sense there at all
09:38:34 <Saul> :t (<*>)
09:38:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:38:47 <Saul> list is applicative
09:38:58 <Saul> so [a -> b] -> a -> b
09:39:07 <Saul> so [a -> b] -> [a] -> [b] sorry
09:39:15 <Saul> so it's not really that weird
09:39:35 <idnar> well, you need a ZipList in there or whatever
09:39:49 <Saul> :t [id, (+3), (*4), (3-)]
09:39:49 <lambdabot> forall a. (Num a) => [a -> a]
09:40:05 <idnar> @instances Applicative
09:40:06 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:40:13 <idnar> @instances-importing Applicative Control.Applicative
09:40:14 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
09:40:22 <idnar> @instances-importing Control.Applicative Applicative
09:40:22 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
09:40:28 <Saul> > (\fs x -> fs <*> [x]) [id, (+3), (*4), (3-)] 5
09:40:28 <lambdabot>  [5,8,20,-2]
09:40:33 <idnar> oh right, there is one for []
09:40:40 <Saul> that's what I needed, the map didn't make sense
09:40:53 <idnar> :t (\fs x -> fs <*> [x])
09:40:53 <lambdabot> forall a b. [a -> b] -> a -> [b]
09:41:03 <idnar> wrong type :)
09:41:36 <Saul> It's not what kjdf wanted, but what I thought he wanted
09:42:03 <Saul> Then I got upset that I didn't get it to work
09:42:55 <Saul> since he said he wanted a function that could apply a list of functions to a value
09:43:17 <Saul> which is pretty much what this does
09:46:22 <Saul> > map ($ 5) [id, (+3), (*4), (3-)]
09:46:23 <lambdabot>  [5,8,20,-2]
09:46:38 <gour> @seen ndm
09:46:38 <lambdabot> I haven't seen ndm.
09:47:15 <jrx_> @pl (x==' ') || (x=='\t') || (x=='\n')
09:47:15 <lambdabot> x == ' ' || x == '\t' || x == '\n'
09:47:33 <jrx_> @pl \x -> (x==' ') || (x=='\t') || (x=='\n')
09:47:33 <lambdabot> liftM2 (||) (' ' ==) (liftM2 (||) ('\t' ==) ('\n' ==))
09:48:08 <Saul> > (\fs x -> liftM ($ x) fs) [id, (+3), (*4), (3-)] 5
09:48:09 <lambdabot>  [5,8,20,-2]
09:48:43 <Saul> Three alternatives for something nobody needed :)
09:49:09 <paolino> > getStdGen >>= putStrLn . concatMap (bool "   " "CLAP ") . randomRs (False,True)
09:49:09 <lambdabot>      lexical error in string/character literal at character '\160'
09:49:43 <paolino> > getStdGen >>= putStrLn . concatMap (bool "   " "CLAP ") . randomRs (False,True)
09:49:44 <lambdabot>   Not in scope: `bool'
09:50:54 <paolino> >  let bool x y z = if z then x else y in getStdGen >>= putStrLn . concatMap (bool "   " "CLAP ") . randomRs (False,True)
09:50:55 <lambdabot>  <IO ()>
09:51:31 <BMeph> Saul: Do you have map . flip id? If not, you could make it fouor... ;)
09:51:56 <BMeph> s/fouor/four/
09:52:48 <Saul> BMeph: I hadn't :)
09:53:08 <Saul> BMeph: Although it would need another flip to get the same type as the others
09:53:25 <BMeph> Saul: sequence should do it, too.
09:53:57 <Saul> BMeph: How exactly?
09:54:37 <BMeph> :t sequence
09:54:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:56:00 <BMeph> Saul: Use the Reader monad ((((-> a) as 'm'.
09:56:29 <BMeph> s/((((-> a)/((->)a)/
09:56:58 <BMeph> :t sequence [id, (+3), (*4), (3-)]
09:57:06 <lambdabot> forall a. (Num a) => a -> [a]
09:57:39 <BMeph> > sequence [id, (+3), (*4), (3-)] 5
09:57:40 <lambdabot>  [5,8,20,-2]
09:58:02 * BMeph <3 Monads
09:59:23 <psyonic> anyone familiar with Data.Tree.AVL?
09:59:44 <_frederik_> hello, how do i load a module in ghci while hiding a symbol, i.e. the equivalent of import Foo hiding (bar)?
10:00:18 <Saul> BMeph: That is a nice one too, so now we're at 5 versions to a function no one needed
10:02:34 <BMeph> Saul: Yeah. I guess the adage is true - if you can't find the right answer, answer a different question! ;)
10:03:45 <BMeph> _frederik_: GHCi doesn't work that way; you'd have to create a module that re-exports what you want, and then import that module into GHCi.
10:04:17 <nominolo> nah
10:04:30 <nominolo> just load a file with the correct import statement
10:05:26 <BMeph> nominolo: How is that different from what I just said? :)
10:07:40 <nominolo> no re-exports :)
10:12:28 <_frederik_> BMeph: thanks
10:17:52 <psyonic> anyone familar with Data.Tree.AVL and and more specifically Data.Tree.AVL.genPush?  I can't seem to get the arguments right
10:19:56 <titusg> have you heard the spj interview on that awful .netrocks thing? how much of their claptrap do I have to listen to to get the interview?!
10:21:02 <titusg> Oh god I think I got the wrong link :-)
10:24:37 <titusg> No I didn't. I'm actually meant to listen to their blather to get to the interview...oh well, I'll live without hearing that
10:25:17 <dolio> Hearing it probably wouldn't get you much closer to nirvana.
10:25:39 <titusg> dolio: thank you, I feel calmer now :-)
10:26:56 <dolio> There are plenty of other "SPJ talks about Haskell to people who've never heard of it before" resources if you're really jonesing for that sort of thing.
10:27:39 <BMeph> dolio: Would that be Peyton-Jonesing? ;)
10:27:49 <dolio> Well played.
10:27:58 <titusg> yes he does a good job of it too, like a vicar on MDMA
10:31:35 <MarcWeber> @tell dcoutts http://mawercer.de/copy_exe_haxml_patch_hope_didnt_break_anything
10:31:35 <lambdabot> Consider it noted.
10:32:48 <dcoutts> MarcWeber: I didn't understand that patch at all :-(
10:32:48 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:33:28 <dcoutts> MarcWeber: what was the problem with the program suffix and prefixes? they're "" by default.
10:35:06 <malsyned> Do the cautions regarding unsafePerformIO (like use NOINLINE and -fno-cse and make sure to switch off let-floating) also apply to unsafeInterleaveIO?
10:35:25 <dcoutts> MarcWeber: and we already create the dir, which is the other bit your patch adds.
10:35:41 <Lemmih> malsyned: Not really.
10:35:52 <dcoutts> MarcWeber: so in fact I don't understand either change. You'll have to explain it to me.
10:36:20 <dcoutts> malsyned: unsafeInterleaveIO is a good deal less unsafe than unsafePerformIO.
10:36:33 <oerjan> malsyned: i think the fact they don't apply is the major reason for using unsafeInterleaveIO instead...
10:36:42 <malsyned> Lemmih: the documentation is actually pretty spare on it.  What does it do exactly?  magically turn eager IO operations into lazy ones?
10:36:48 <oerjan> (when applicable)
10:36:49 <dcoutts> malsyned: the main thing is that the side effects can be delayed and may never happen if the value is never demanded.
10:37:38 <Lemmih> malsyned: unsafeInterleaveIO io = return (unsafePerformIO io) -- basically.
10:37:58 <dcoutts> Lemmih: no, no it's much safer than that! :-)
10:38:09 <allbery_b> @src unsafeInterleaveIO
10:38:09 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
10:38:09 <dcoutts> that could be floated out
10:38:35 <allbery_b> clear as mud :)
10:38:47 <Lemmih> dcoutts: Yeah, but I find it easier to grasp that definition.
10:38:55 <oerjan> well s is the RealWorld token, i think
10:39:24 <dcoutts> Lemmih: but it means defining it in terms of something with even less definition ;-)
10:40:21 <dcoutts> MarcWeber: ping. You still about?
10:40:23 <monochrom> The key is "let".
10:40:29 <MarcWeber> Yes. I'm hear.
10:40:41 <oerjan> the use of that s token means two uses of unsafeInterleaveIO cannot be confused, i think, since they must have different s in spirit
10:40:45 <dcoutts> MarcWeber: any word on that patch? I need more explanation.
10:40:53 <MarcWeber> Give me a sec
10:40:58 <dcoutts> MarcWeber: sure, np.
10:41:21 <monochrom> hacky wacky
10:41:56 * monochrom continues his own hacky wacky adventure
10:43:41 <MarcWeber> dcoutts: http://rafb.net/p/5SgBBo28.html Have you seen this ? prog{prefix,suffix} arent't "" in this case (Don't know why)..\
10:43:41 <lambdabot> Title: Nopaste - No description
10:44:13 <dcoutts> MarcWeber: what value do they take?
10:44:31 <dcoutts> oh, I see
10:44:35 <MarcWeber> See line 19 and 37 (print and result) :)
10:45:35 <MarcWeber> dcoutts: I don't know either why HaXmL has path such as  /bin/Canonicalize/Canonicalize (note the extra subdir)
10:46:59 <MarcWeber> dcoutts: I haven't looked very much around so my patch may very well break other things. But it ensures nonsense like this doens't happen annymore and that binary is installed somewhere in bin.
10:47:22 <dcoutts> MarcWeber: I don't see the /bin/Canonicalize/Canonicalize bit, where is that?
10:48:13 <MarcWeber> dcoutts: line 39. It's a binary which should be installed somewhere in bin I guess. (or why is the function called isntallExe ?)
10:48:33 <dcoutts> MarcWeber: I only see dist/build/Canonicalise/Canonicalise which is correct.
10:48:49 <dcoutts> that's where it is copying from
10:49:58 <lispy> hasktags generates etags or ctags, what is the difference?
10:50:06 <dcoutts> MarcWeber: perhaps you can trace where the non-empty prefixes are coming from, since they're certainly "" by default.
10:50:07 <lispy> I'm having a hard time finding anything on google that compares them
10:50:10 <MarcWeber> dcoutts: sure. Have a look at the destination (last line) and the line it should copy to ( exytract destdir from line 28. --destdir was /nix/store/4n8gniwlbnca1g1mq4lki63n63gd24y2-HaXml-1.13.3)
10:50:15 <dcoutts> MarcWeber: eg in Install.install
10:51:13 <dcoutts> MarcWeber: right, so it's copying to a bonkers place because of that program suffix
10:51:15 <oerjan> lispy: emacs vs. vi i think
10:51:17 <MarcWeber> And it's trying to copy to ${destdir}Canonicalise/nix/... which is not in $destdir (thsu wrong)
10:51:30 <shapr> @yow !
10:51:31 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
10:51:31 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
10:51:31 <lispy> oerjan: yes, I think I just found that out: http://www.delorie.com/gnu/docs/emacs/etags.1.html
10:51:32 <lambdabot> Title: etags
10:51:43 <lispy> oerjan: thanks tho!
10:52:27 <dcoutts> MarcWeber: right, see the program name is just "Canonicalise" and for some reason the program suffix has been set to "/nix/store/4n8blahblah" and so the overall install location is messed up
10:53:16 <dcoutts> MarcWeber: so the thing we have to figure out is how that program suffix ever came to be set to be anything since by default it is empty and only set via configure --program-suffix="whatever"
10:54:13 <MarcWeber> dcoutts: I don't want to spend much more time on this. I've to do some other tasks as well. So I don't mind you not including the patch till we've found the real issue. I'm keen on adding more pacakges to nix (rather than tracking down this issue). So maybe a bug item is the right thing to do now.
10:54:28 <dcoutts> MarcWeber: so I'd suggest adding tracing in Distribution.Simple.Install.install
10:55:07 <dcoutts> MarcWeber: right, but can you see that from my point of view this looks pretty weird, our code looks straightforward and I cannot reproduce the error, there's not a lot I can do at the moment.
10:55:26 <MarcWeber> Ah you can't ? Didn't know that you've tried it..
10:56:08 <dcoutts> MarcWeber: well I'll go try HaXml specifically...
10:59:17 <MarcWeber> dcoutts: http://rafb.net/p/erRoDz85.html That's the code I've used to compile it.
10:59:17 <lambdabot> Title: Nopaste - No description
10:59:46 <dcoutts> MarcWeber: ta
11:00:11 <MarcWeber> dcoutts: I'll spend more time on this in some days.
11:00:20 <malsyned> In that source for unsafeInterleaveIO, what is the meaning of the # tokens?
11:00:23 <dcoutts> MarcWeber: I'll let you know if I find anything
11:01:02 <dolio> malsyned: It's an unboxed tuple.
11:01:09 <MarcWeber> dcoutts: and I've used latest cabal version (darcs)
11:01:17 <dcoutts> MarcWeber: right, ok
11:02:29 <malsyned> dolio: thanks
11:04:48 <shapr> Is there some way to :browse non-interpreted modules from ghci?
11:05:06 <shapr> Hm, emacs is using a gig of ram, I should close some of my larger buffers...
11:05:17 <Lemmih> shapr: :browse Data.List ?
11:05:37 <shapr> Prelude System.Random> :b System.Random \n module 'System.Random' is not interpreted
11:05:49 <shapr> Huh, now it works. Weirdness.
11:05:49 <olsner> ssh shapr -- killall emacs # :P
11:06:06 <doserj> :browse /= :b
11:06:16 <shapr> Weird, what is :b ?
11:06:30 <doserj> breakpoint
11:06:33 <shapr> ohhh
11:07:03 <bos> @seen dons
11:07:03 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 32m 20s ago.
11:07:08 <shapr> @seen bos
11:07:08 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 6s ago.
11:07:10 <shapr> Aha!
11:07:14 <bos> ha
11:07:21 <kaol> @seen lambdabot
11:07:22 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #gentoo-uy, #curry, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #jtiger, #haskell-soc, #haskell-overflow, #scala, #haskell, #ghc
11:07:22 <lambdabot> and #darcs
11:07:23 <bos> wha happen?
11:07:25 * shapr throws fluffy literate lambdas at bos
11:07:39 <bos> mrp?
11:07:58 <shapr> Ok, I give up on lambda throwing for a whole hour.
11:08:09 <dolio> @girl19
11:08:09 <lambdabot> I have stolen about 50 msn and yahoo accounts
11:08:28 <lament> sounds like a typical girl of 19
11:10:35 <dolio> @seen hpaste
11:10:35 <lambdabot> I saw hpaste leaving #haskell 2d 19h 52m 55s ago, and .
11:10:59 <oerjan> @uptime
11:10:59 <lambdabot> uptime: 18h 4m 25s, longest uptime: 1m 10d 23h 44m 29s
11:11:22 <dolio> Wow, over a month.
11:11:30 <olsner> byorgey: gobby in haskell, eh? cool ;-)
11:11:33 <olsner> @seen byorgey
11:11:34 <lambdabot> byorgey is in #xmonad and #haskell. I last heard byorgey speak 6h 9m 56s ago.
11:14:16 <gbacon> in http://mult.ifario.us/p/a-short-adventure-with-simplehttp the author changes code to a mapM_ sequence, but wouldn't a more elegant approach be to use the "programmable semicolon"?
11:14:17 <lambdabot> Title: a-short-adventure-with-simplehttp
11:14:22 <glen_quagmire> > let f :: (->) Int Bool; f i | i < 0 = True; f _ = False in f (-1)
11:14:32 <lambdabot>  True
11:15:30 <lispy> so then (->) is really just an infix type constructor?
11:15:41 <mauke> yes
11:15:58 <lispy> That's pretty sweet.
11:18:22 <glen_quagmire> > let f :: [] Int -> Int; f l = foldl (+) 0; in f [1,2,3]
11:18:23 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a] -> a'
11:18:31 <dcoutts> MarcWeber: found it!
11:18:34 <glen_quagmire> > let f :: [] Int -> Int; f l = foldr (+) 0; in f [1,2,3]
11:18:35 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a] -> a'
11:19:01 <dcoutts> MarcWeber: it's a bug in the interaction of the prefix/suffix and the copy --destdir code.
11:19:18 <dcoutts> MarcWeber: which is why I didn't find it before, I wasn't testing with --destdir
11:19:48 <shapr> dolio: fixed
11:20:14 <dolio> shapr: Ah, good.
11:20:17 <oerjan> > let f :: [] Int -> Int; f = foldr (+) 0; in f [1,2,3]
11:20:18 <lambdabot>  6
11:20:31 <shapr> dolio: I'm the person to poke if hpaste disappears.
11:21:04 <dolio> shapr: Okay. glguy works too, right? Although he's only around at like 3 am. :)
11:22:19 <glen_quagmire> > let f :: (,,) Int Int Int -> Int; f (a,b,c) = a+b+c in f (1,2,3)
11:22:20 <lambdabot>  6
11:23:57 <shapr> Hm, emacs crashed. I think that gig of ram was too much for it.
11:24:09 <_frederik_> you and your ram
11:24:31 <glen_quagmire> :kind Int
11:24:44 <shapr> _frederik_: Hey, I have 4gb total, 1gb used for emacs should be fine.
11:24:51 <shapr> Soon to upgrade to 8gb, of course.
11:24:54 <oerjan> :k Int
11:24:55 <lambdabot> *
11:25:08 <glen_quagmire> oerjan: thank you
11:25:20 <_frederik_> shapr: you must be a sloppy programmer to need that much :)
11:25:24 <earthy> emacs: eight megabytes and constantly swapping
11:25:42 <shapr> 800 megabytes at this point.
11:25:49 <lament> eight gigabytes and constantly swapping?
11:25:52 <pejo> earthy, good to see that someone else than me still uses a VAX!
11:25:57 <earthy> (or eighty, or eighthundred, or eightthousand megabytes...)
11:26:17 <earthy> pejo: actually, the vax that I had access to online has been shut down by now
11:26:29 <earthy> although a friend of mine still keeps his microvax running
11:28:09 <lispy> has anyone written any ghc-api + {vim,emacs} yet?
11:28:36 <shapr> I don't think so.
11:28:42 <lament> earthy: nice. old computers rule.
11:28:50 <shapr> Lemmih talked about that at one point, don't know if any code resulted.
11:29:07 <lispy> http://swik.net/ghc-api+Emacs <-- this website is weird
11:29:08 <lambdabot> Title: ghc-api + Emacs - SWiK
11:29:19 <lispy> it mentions it, but has no content and no obvious links to content
11:29:44 <tehgeekmeister> for the ReqArg option constructor in System.Console.GetOpt, the string which is the second argument to the constructor is a string used as the example variable in the usage display, right?
11:29:51 <MarcWeber> dcoutts: great, cool, fine, well done, .. ;)
11:30:28 <lispy> I wonder what Real World haskell says about editors
11:30:34 <earthy> lispy: actually, there is shim
11:30:37 <dcoutts> MarcWeber: I'll double check my fix and push the patch.
11:30:47 <earthy> (or what was it called again)
11:31:04 <earthy> but I don't know if that answers your question
11:31:12 <earthy> maybe you mean something in the lines of yi?
11:31:25 <lispy> ?where shim
11:31:25 <lambdabot> http://shim.haskellco.de/trac/
11:31:41 <lispy> hmm...that URL is down
11:31:45 <earthy> pity
11:32:40 <lispy> I could/would just use visual haskell if I knew I could get darcs to compile reliably in windows.
11:33:04 <lispy> But, I'm looking for an emacs based solution since that lets me edit over ssh+screen
11:33:08 <earthy> hm. visual haskell isn't perfecct
11:33:11 <earthy> my ro
11:33:23 <earthy> roommate at work swears by and at it :)
11:33:45 <doserj> http://code.haskell.org/shim/
11:33:45 <lambdabot> Title: Index of /shim
11:34:48 <_frederik_> what does visual haskell have? refactoring? tags?
11:34:53 <lispy> earthy: yeah, i've used it before.  The nice thing is that it's better than etags about finding your definitions.
11:35:17 <oerjan> tehgeekmeister: i think so
11:35:22 <lispy> _frederik_: it's Haskell integration for VS using the ghc-api (meaning you get ghc's parser and type info in intellisense)
11:35:29 <tehgeekmeister> oerjan: okay, thanks
11:35:43 <lispy> _frederik_: so you have to put up with VS, but it's fairly intelligent
11:36:40 <earthy> however, it strongly depends on cabal files
11:36:58 <earthy> and doesn't really play well when you have to compile external libs as well
11:37:22 <earthy> oh, and having preprocessors on your code is not really supported
11:37:35 <_frederik_> it would be nice to have some good refactoring tools, like it would be nice to compile in emacs and then when ghc complains about a missing type signature it would offer to insert it
11:37:37 <earthy> so using e.g. lhs2tex is kinda out of the question
11:37:42 <lispy> earthy: oh that's right, the cabal dependency would kill me.
11:37:45 <earthy> frederik: HaRe  ?
11:38:05 <_frederik_> earthy: i haven't played with that yet, does it have a good interface?
11:38:16 <lispy> ?where HaRe
11:38:16 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
11:39:09 <earthy> reasonably
11:39:13 <_frederik_> last update 2006?
11:39:17 <_frederik_> does it even compile?
11:39:19 <earthy> so? :)
11:39:25 <earthy> I think so, haven't tried recently
11:39:36 <earthy> not doing much haskell these days
11:39:58 <lispy> doserj: thanks for the shim link.
11:40:32 <lispy> oh boy, shim doesn't support CPP
11:40:37 <lispy> so, i'm dead again :)
11:41:02 <_frederik_> earthy: "ghc (we've tested with ghc-6.2.2 and ghc-6.4.1)" - so, i doubt it
11:41:04 <lispy> back to etags then
11:41:42 <litb> hello all
11:41:49 <gwern> "The Maclisp community is not in chaos. It consists of four well-defined groups going in four well-defined directions."
11:44:47 <Trinithis> what exactly is the difference between newtype and data?
11:45:03 <mauke> newtype is limited to a single constructor
11:45:13 <Trinithis> ok
11:45:32 <Trinithis> so in those cases, newtype is preferable because its faster?
11:46:01 <desegnis> See http://www.haskell.org/haskellwiki/Newtype for the difference in semantics
11:46:02 <lambdabot> Title: Newtype - HaskellWiki
11:46:07 <oerjan> faster and uses no extra boxing
11:46:13 <tehgeekmeister> should it be considered a bug that GetOpt is recognizing partial versions of the long forms of options?  for example, --setu is acting the same as --setup
11:46:18 <oerjan> so less memory too
11:46:23 <Trinithis> mmk
11:46:53 <lispy> dons, bos: glancing over RW Haskell, I don't see anything on editor tools/setups.  To a real-world programmer the editor support can be significant.  Maybe you can consider adding an appendix about it?
11:46:53 <lament> sounds like a misguided feature
11:47:07 <mauke> tehgeekmeister: isn't that what gnu getopt does?
11:47:54 <tehgeekmeister> mauke: it is?  i guess i disagree with the way it does things then...
11:48:11 <tehgeekmeister> mauke: but it can't rightly be considered a bug of gnu getopt is doing it, since it's a clone
11:48:17 <tehgeekmeister> *if
11:48:25 <glen_quagmire> > otherwise == False
11:48:41 <desegnis> Trinithis: The most intersting consequence of what is mentioned in that wiki page is that a pattern match on a newtype constructor will always succeed (i.e. any value of newtype N = C T is guaranteed to be wrapped in C)
11:48:46 <lambdabot>  False
11:49:13 <Trinithis> desegnis: alight
11:49:44 <lament> tehgeekmeister: it fits with the unix philosophy of typing as little as possible
11:50:04 <desegnis> > otherwise -- see the truth!
11:50:14 <gwern> tehgeekmeister: I wouldn't think it's a bug. the point is to be unambiguous. if you had -setoption-foo and setoption-bar, and -setoption was recognized, but not as an errro (say -foo), then there's a problem
11:50:21 <lambdabot>  True
11:50:48 <tehgeekmeister> gwern: okay, that's sensible.  not how i'd do things, but still sensible.
11:50:52 <gwern> tehgeekmeister: in the same way that if I have a screen session '447062.irssi', I only have to type 'screen -r i' or 'screen -r 44' to make my wishes unambiguous
11:51:14 <gwern> (in this case because the other screen session is 427238.rtorrent)
11:56:08 <tehgeekmeister> gah, okay, i'm not sure how to make this useful.  call me a n00b, but GetOpt returning a list of arguments to recognized options in order of appearance on the command line, without any way of telling which argument went with which option, that's certainly ambiguous!
11:56:38 <tehgeekmeister> in my case i've got --setup=CMD and --cleanup=CMD, which both could be any command, and obviously have to be distinguished
11:57:07 <olsner> oh, that sounds like a bad interface
11:57:49 <tehgeekmeister> olsner: the --setup/cleanup deal?
11:58:03 <oerjan> tehgeekmeister: er you should select your packaging functions to include that information?
11:58:29 <olsner> tehgeekmeister: no, the getopt thing
11:58:45 <olsner> if you get two lists without some easy way of matching one to the other
11:59:04 <tehgeekmeister> olsner: okay, had to be open to the idea that i was doing something wrong.  i'm well aware of my n00b status.
11:59:10 <tehgeekmeister> oerjan: explain?
11:59:55 <mauke> data Cmd = Setup String | Cleanup String
12:00:04 <oerjan> the first argument of ReqArg, say, is a function to turn the argument string into what you actually want in your list
12:00:27 <Le-Chuck_IT1> Hi there
12:00:46 <glen_quagmire> haha :m - Prelude
12:00:50 <Le-Chuck_IT1> I am trying to give types to coalgebraic minimization
12:01:07 <glen_quagmire> :m - Prelude
12:01:09 <Le-Chuck_IT1> and I am stuck on the second line :)
12:01:11 <mauke> getOpt RequireOrder [Option "s" ["setup"] (ReqArg Setup "..."), Option "c" ["cleanup"] (ReqArg Cleanup "...")]
12:01:23 <Le-Chuck_IT1> I defined: type Coalg t x = x -> t x
12:01:28 <oerjan> tehgeekmeister: take a look at the example programs
12:01:59 <oerjan> the first one adds a constructor to identify the option
12:02:20 <Le-Chuck_IT1> is there someone interested in coalgebras at all?
12:02:40 <tehgeekmeister> oerjan: oh, okay.
12:03:48 <oerjan> like mauke demonstrated
12:04:55 * oerjan bets there are some coalgebraists among the regulars but he is not one of them
12:06:31 <dolio> I wouldn't be opposed to hearing rambling about coalgebras, but I don't know if I could help at all.
12:06:41 <mauke> putting the coal in coalgebra
12:07:51 * gwern darcs get a 'haskell-ugly' repo
12:07:58 <Le-Chuck_IT1> just the point is I don't know what type to give to the unique morphism into the final coalgebra
12:08:26 <Le-Chuck_IT1> it should be something like Coalg t x -> Coalg t f
12:08:30 <Le-Chuck_IT1> where f is the final coalgebra
12:08:38 <Le-Chuck_IT1> however... who says what f is?
12:08:42 <dcoutts> Le-Chuck_IT1: should it have a different type?
12:09:06 <Le-Chuck_IT1> I think so, since I define Coalg t x = x -> t x
12:09:09 <Le-Chuck_IT1> where x is the carrier
12:09:11 <Le-Chuck_IT1> t is the functor
12:09:35 <Le-Chuck_IT1> so the destination of the unique morphism should be Coalg t _f_
12:09:40 <Le-Chuck_IT1> for a fixed f depending on t
12:10:06 <paolino> mmhh looks like haskell has something to do with the old bridge operation in USA
12:10:09 <hpaste>  litb pasted "powerset " at http://hpaste.org/5542
12:10:18 <litb> hm, what is wrong with that?
12:10:24 <litb> it says i want to construct an infinite type
12:10:32 <tehgeekmeister> is there a standard IO action that does nothing?
12:10:36 <mauke> a:kom b
12:10:49 <mauke> you can't have both a : b and a : kom b
12:10:51 <gwern> I love some version numbering systems, like 'xhtml-3000.0.2.2'
12:10:51 <dcoutts> Le-Chuck_IT1: perhaps you want a class of co-algebras, with a functional dependency so that the t can determine the f
12:10:58 <mauke> tehgeekmeister: return ()
12:11:17 <dcoutts> gwern: it's because it changed from using date-based version numbers and there's no way to go back to 1.0
12:11:18 <idnar> @src IO return
12:11:18 <lambdabot> return x    = returnIO x
12:11:24 <idnar> @src returnIO
12:11:24 <lambdabot> Source not found. Just try something else.
12:11:26 <idnar> aww
12:11:50 <gwern> dcoutts: I know, but its funny as it implies that its been through 3000 revision, and they still kept incrementing down to the thousandths
12:11:54 <jrx_> @src isSpace
12:11:54 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:12:12 <Le-Chuck_IT1> dcoutts: maybe but I am not so sure
12:12:18 <Le-Chuck_IT1> how does one model functors in haskell?
12:12:24 <dcoutts> gwern: aye, it sounds a bit bling :-)
12:12:33 <Le-Chuck_IT1> I _will not_ look it up on google :)
12:12:37 <olsner> hmm, in comparison, how many revisions has ghc had?
12:12:44 <mauke> http://search.cpan.org/~drolsky/File-Slurp-9999.13/lib/File/Slurp.pm
12:12:47 <lambdabot> Title: File::Slurp - Efficient Reading/Writing of Complete Files - search.cpan.org, http://tinyurl.com/ysxgka
12:12:48 <dcoutts> Le-Chuck_IT1: there's a Functor class but perhaps that's not what you mean.
12:12:58 <cjb> olsner: only 6.8!  :)
12:13:11 <hpaste>  (anonymous) pasted "Exception: stack overflow" at http://hpaste.org/5543
12:13:36 <paolino> Haskell International Trading Inc, it's a mafia society
12:13:45 <gwern> mauke: is that the same stuff darcs uses?
12:13:52 <mauke> unlikely
12:13:52 <Le-Chuck_IT1> dcoutts: in principle, the Functor class looks like a functor!
12:14:15 <gwern> mauke: well I don't mean the code itself, but doesn't darcs uses a Slurp type for fast IO?
12:14:20 <Le-Chuck_IT1> however: in haskell, I already have final coalgebras - they are coinductive data types
12:14:23 <MyCatVerbs> Hrmn. Isn't there supposed to be a monad instance for Either String?
12:14:29 <Le-Chuck_IT1> so I should be somewhat able to exploit that
12:14:36 <dibblego> MyCatVerbs, yes, there is
12:14:45 <dcoutts> Le-Chuck_IT1: yes, though you can also encode them explicitly
12:14:55 <MyCatVerbs> dibblego: do you know where to find it, please?
12:15:10 <dcoutts> Le-Chuck_IT1: the latter being rather more fun :-)
12:15:11 <dibblego> MyCatVerbs, heh no, searching through GHC libs is a nightmare, sorry
12:15:13 <litb> i've now got "kom (a:b) = [[a] ++ (kom b)] ++ (kom b)"
12:15:14 <dibblego> ?instances Monad
12:15:16 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:15:21 <litb> which is right i think, but it still fails
12:15:27 <dibblego> MyCatVerbs, you can it right there at least; Either e
12:15:32 <Le-Chuck_IT1> dcoutts: the former would be limited to the "category" of haskell types
12:15:36 <mauke> litb: [a] ++ x is the same as a : x
12:15:41 <Le-Chuck_IT1> or am I overlooking something?
12:17:00 <dcoutts> Le-Chuck_IT1: not sure, but I expect you're best off modeling the co-algebras explicitly if you want to do interesting things with them.
12:17:00 <litb> oh i se
12:17:02 <hpaste>  mauke annotated "Exception: stack overflow" with "untested code" at http://hpaste.org/5543#a1
12:17:13 <litb> it just always say i want to make an infinite type
12:17:16 <litb> but i don't
12:17:31 <desegnis> litb: give kom an explicit type signature
12:17:45 <paolino> > return "prova" :: Either String
12:17:45 <lambdabot>      `Either String' is not applied to enough type arguments
12:17:45 <lambdabot>     Expected kin...
12:17:54 <desegnis> litb: then you should get a different error
12:18:13 <Le-Chuck_IT1> dcoutts: the only problem is, that I will have to define explicitly the final coalgebra, and I dislike this a bit... however thank you
12:18:28 <Le-Chuck_IT1> the Functor class seems to eliminate some decision
12:18:35 <litb> kom :: [a] -> [[a]]
12:18:50 <izuker> mauke: still getting stack overflow
12:18:57 <dcoutts> Le-Chuck_IT1: so for example data ListF a x = Empty | Cons a x, then make ListF an instance of Algebra and CoAlgebra
12:19:08 <litb> that is the type signatur. i don't see what is wrong there
12:19:10 <oerjan> MyCatVerbs: Control.Monad.Error or .Instances
12:19:14 <desegnis> litb: Now think about the types of the parts of your term
12:19:43 <desegnis> litb: e. g. kom b :: [[a]]
12:19:55 <litb> ah with explicit you mean non-type variables
12:20:04 <desegnis> er, no
12:20:16 <desegnis> I have a type variable there, too
12:20:25 <MyCatVerbs> oerjan: thanks.
12:20:58 <Le-Chuck_IT1> dcoutts: what is the functor here?
12:21:03 <izuker> any other ideas on eliminating the stack overflow in http://hpaste.org/5543?
12:21:12 <Le-Chuck_IT1> I mean, how do I define that explicitly?
12:21:12 * Cale looks
12:21:15 <izuker> i'm pretty sure this would be trivial in C
12:21:53 <Le-Chuck_IT1> dcoutts: maybe I see, it's "ListF"
12:22:24 <bartw> izuker: so does it terminate if it wouldn't run out of stack ?
12:22:29 <dcoutts> Le-Chuck_IT1: right, that's the List functor, from that we can use an inductive or co-inductive encoding of lists/streams
12:22:35 <litb> kom b :: [[a]] yeah b should be a [a] then
12:22:38 <izuker> bartw: yes, and pretty quickly, too
12:22:43 <desegnis> litb: you should understand that, if (a:b) :: [a], then [a] :: [a]; kom b :: [[a]]
12:23:32 <bartw> izuker: so what is the n you are using
12:23:39 <desegnis> (litb, that got a little confusing due to a being here a value, there a type variable, but I hope that doesn't disturb you too much :-)
12:24:18 <Le-Chuck_IT1> dcoutts: a more usual list functor should be defined as data ListF a = Empty | Cons a (ListF a)
12:24:21 <bartw> recursion using stack usually doesn't have more then a meg of stack available.
12:24:35 <dcoutts> Le-Chuck_IT1: oh but that's already recursive
12:24:36 <Le-Chuck_IT1> sorry but I am a bit confused
12:24:46 <Le-Chuck_IT1> oh
12:24:50 <izuker> bartw: 1000000
12:24:53 <Le-Chuck_IT1> yes I see :)
12:24:59 <Le-Chuck_IT1> great
12:25:02 <Le-Chuck_IT1> really great :)
12:25:04 <izuker> how can i rewrite it to *not* "recurse on the stack"?
12:25:08 <Le-Chuck_IT1> thank you
12:25:20 <bartw> izuker: then count (Branch s t) is the one going over most likely
12:25:34 <MyCatVerbs> @hoogle Monad m => [m a] -> m [a]
12:25:38 <lambdabot> Prelude.head :: [a] -> a
12:25:38 <lambdabot> Prelude.last :: [a] -> a
12:25:38 <lambdabot> Data.List.head :: [a] -> a
12:26:02 <mauke> izuker: wait, how would you do it in C?
12:26:06 <bartw> izuker: making a list out of it would help
12:26:12 <paolino> :t sequence
12:26:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:26:48 <izuker> mauke: i would make a queue; when i got to a branch, i would put left and right on the queue
12:28:15 <desegnis> What would be a good German translation of »The Haskell Report«, if I wanted to really translate that title? The usual meaning of »report« won't do it
12:28:33 <hpaste>  Cale annotated "Exception: stack overflow" with "try this version" at http://hpaste.org/5543#a2
12:28:42 <dcoutts> desegnis: perhaps a word meaning definition or specification
12:28:58 <Cale> izuker: try that :)
12:29:02 <bartw> paper ?
12:29:07 <hpaste>  edi pasted "(no title)" at http://hpaste.org/5544
12:29:49 <desegnis> dcoutts, I think we don't have better words for those than Definition, Spezifikation. And that sounds _rather_ technical
12:31:19 <mauke> Beschreibung
12:31:53 <desegnis> mauke, also »Die Beschreibung von Haskell«?
12:32:08 <mauke> :/
12:32:19 <desegnis> well, doesn't sound too bad
12:32:26 <paolino> rapporto
12:32:34 <monochrom> The title should be _very_ technical. Because that's what the content is.
12:32:44 <doserj> "von" is never good german
12:32:52 <mauke> hrhr, »Der Haskellrapport«
12:33:01 <desegnis> monochrom, if it sounds as technical as Spezifikation, noone woud read it
12:33:03 <izuker> Cale: excellent, thanks!
12:33:09 <int-e> . o O ( Die Haskell-Akte ... mwahahaha )
12:33:20 <desegnis> mauke, yeah :-|
12:33:37 <monochrom> This is faulty logic.
12:33:41 <mauke> »Haskell-Beschreibung«
12:34:21 <Le-Chuck_IT1> dcoutts: data Fin t = Fin (t (Fin t))
12:34:27 <desegnis> int-e, the follow-up being The Moses Schönfinkel Code
12:34:31 <paolino> rapporto in italian is very military
12:34:56 <Le-Chuck_IT1> t is a functor, the above definition gives a haskell data type for the final coalgebra... I don't know if it's too contrived, what do you think about that?
12:35:04 <monochrom> Are you trying to get poets and bakers to read the Haskell 98 Report?
12:35:16 <int-e> desegnis: I don't know. "Spezifikation" sounds better than "Beschreibung", and I think it fits the purpose of the document rather well.
12:35:31 <monochrom> Have you read it yourself?
12:35:37 <dcoutts> Le-Chuck_IT1: it makes my head hurt slightly, I'd have to think of an example
12:35:46 <Le-Chuck_IT1> let x = Fin (T [(3,x)])
12:35:53 <Le-Chuck_IT1> that's an element of the above type
12:35:54 <monochrom> It *is* the kind of content that "no one" would read. Why should the title be more inviting than the content?
12:36:00 <Le-Chuck_IT1> so it looks fine
12:36:05 <int-e> Hmm. I don't think that I've ever read it all.
12:36:16 <int-e> skimmed it, yes.
12:36:25 <dolio> Le-Chuck_IT1: Looks like the standard fixpoint datatype.
12:36:48 <dcoutts> Le-Chuck_IT1: what is T there?
12:36:51 <monochrom> If you're trying to fool people to read it, just call it "Predication of the 2008 Stock Market".
12:37:12 <Le-Chuck_IT1> T is a functor, sorry: data T x = T [(L,x)]
12:37:20 <desegnis> monochrom: If anything is to be inviting, then it must be the title. (And the cover, if there was one ;-)
12:37:24 <Le-Chuck_IT1> where L is a fixed set of labels
12:37:25 <monochrom> But if you're looking for an honest title, the title should reflect the true dark nature of the content.
12:38:08 <monochrom> I'm talking about cold, hard, old-school integrity and honesty.
12:38:15 <desegnis> int-e, furthermore Spezifikation is more, er, specific
12:38:27 <oerjan> @remember monochrom [on how to translate "Haskell Report"] If you're trying to fool people to read it, just call it "Predication of the 2008 Stock Market".
12:38:28 <lambdabot> I will remember.
12:38:31 <monochrom> I.e., none of those marketing "let's sugar-coat it" bullshit.
12:39:16 <oerjan> Haskell: The Dark Truth
12:39:24 <dolio> Le-Chuck_IT1: http://www.eyrie.org/~zednenem/2004/hsce/
12:39:38 <oerjan> that might even attract the poets :)
12:39:47 <monochrom> heh
12:39:50 <desegnis> monochrom: But even if no one reads it, there are occasions to mention it. And I prefer to mention warm, fuzzy things, in a way
12:40:00 <desegnis> ^^
12:40:16 <int-e> hmm ... "The contents may look arcane to people unfamiliar with the stock market."
12:40:24 <int-e> The Haskell Cat?
12:40:31 <int-e> cause cats are warm and fuzzy, hmm.
12:40:36 <int-e> I don't know, it sounds a bit silly.
12:41:26 * monochrom hates with a passion "warm fuzzy" dishonest sweet talks.
12:41:31 <Le-Chuck_IT1> dolio: thank you, that's more or less what I am trying to do :)
12:41:40 <int-e> Has anybody mentioned 'Bericht'?
12:41:51 <dolio> Le-Chuck_IT1: Ah. Glad to be of service. :)
12:41:53 <Le-Chuck_IT1> s/less//
12:41:56 <monochrom> This world has too much warm fuzzy bullshit as it is.
12:42:22 <monochrom> I come to Haskell the language and Haskell the community because here I find cold hard honesty.
12:42:30 <desegnis> The poetic problem in German is that Haskell-Spezifikation is one word consisting of two words that are both difficult to pronounce. Haskell-Bericht or Haskell-Beschreibung still sounds smashed together
12:43:28 <desegnis> monochrom: Then we should leave it with »The Haskell Report«. No such softy things like translations :-)
12:43:36 <oerjan> Bericht der Programmierungssprache Haskell?
12:43:45 <birkenfeld> klingt furchtbar
12:43:50 <Le-Chuck_IT1> bye all I'll be back soon
12:43:51 * oerjan knows not if he got that right, even
12:43:56 <monochrom> And I think cold hard honesty is having a come-back again. More and more programmers and even managers are disillusioned, they now hunger for hard facts.
12:43:58 <birkenfeld> (sounds horrible)
12:44:04 <int-e> oerjan: that suggests that the report was written by the language.
12:44:13 <oerjan> oh :)
12:44:20 <desegnis> oerjan: It would be Programmiersprache, but ... se int-e
12:44:22 <desegnis> *see
12:44:54 <desegnis> and even »Bericht über« suggests that Haskell is like a car accident
12:45:56 <oerjan> some might think so...
12:46:23 <desegnis> monochrom: Sorry if I neglect your wishes and still search for elegance where it maybe isn't
12:46:56 <int-e> "Ode an Haskell" may be elegant.
12:47:03 <Cale> izuker: Hehe, whoops, I just noticed the obvious error in what I pasted, but I suppose that wasn't a problem.
12:47:20 <monochrom> Is the content also being translated?
12:47:46 <desegnis> int-e, for monochrom Elegie might be a better fit ;-)
12:48:09 <desegnis> monochrom, only if I have nothing else to do. which means, no.
12:49:25 <monochrom> As an English, non-German speaker I have no problem having »Ein Deutsches Requiem« appear in English writing. It is a work in German and it can enjoy an untranslated German name.
12:49:56 <monochrom> And thus reciprocally I would say »The Haskell Report« appearing in German writing is just fine.
12:50:30 * int-e would agree with that.
12:51:50 <desegnis> That's the consensus I feared. The most practical thing to do, even obvious, but whole-heartedly unpoetic
12:52:11 * desegnis should shut up soon
12:53:08 <Cale> whoa, I also found a bug in genericLength
12:53:16 <Cale> (It's not strict enough)
12:53:32 <Cale> I suppose that's not really a 'bug' so much as it is annoying.
12:53:44 <shachaf> @src genericLength
12:53:44 <lambdabot> genericLength []    = 0
12:53:44 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:54:15 <monochrom> "The Canon of Haskell"
12:54:17 <Cale> genericLength = foldl' (\y x -> y + 1) 0
12:54:28 <Cale> Works much better for things like Integer
12:55:21 <Cale> Of course, the real bug is that genericLength exists at all, and that length isn't polymorphic and specialised for various types.
12:56:07 <monochrom> foldl' fails over funny Num types such as data X = Z | S X
12:56:13 <Cale> Right.
12:56:17 <ddarius> monochrom: What's funny about that?
12:56:29 <mauke> isn't that a good thing?
12:56:29 <Cale> You want it to be lazy sometimes.
12:58:15 <monochrom> I don't know why it's funny. It's funny.
12:58:56 <doserj> the funny thing is that there is no such type in the prelude (for reasons i dont understand)
12:59:10 * byorgey points at data X = Z | S X and laughs
12:59:15 <monochrom> I also find ParsecT and especially its Stream funny, to give you a frame of reference.
12:59:30 <desegnis> doserj: Because then people would use it and complain that Haskell is slow
12:59:36 <lispy> ?src liftM
12:59:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:59:39 <olsner> desegnis: are you using "The Haskell Report" in poetry?
12:59:46 <monochrom> But my "funny" is always a good thing, not a bad thing.
12:59:59 <lispy> I want to define, unsealM f m1 = do { Sealed x1 <- m1; return (f x1) }, is there any way to do that interms of liftM?
13:00:00 <Cale> I wonder what the best solution in this regard would be. It might be nice to have a class which gave information about a type's structure, so that various functions could decide intelligently whether to build values strictly or lazily.
13:00:10 <desegnis> olsner, are you doubting my sanity state?
13:00:25 <oerjan> lispy: liftM f x1
13:00:33 <oerjan> er m1
13:00:37 <byorgey> lispy: looks like  liftM (f . unSeal)
13:00:45 <byorgey> lispy: for an appropriate definition of unSeal
13:00:49 <oerjan> argh
13:00:54 <lispy> byorgey: i do have unseal
13:00:57 * oerjan needs glasses
13:01:02 <olsner> desegnis: yes, I'm starting to
13:01:08 <lispy> byorgey: thanks
13:01:09 * byorgey chides oerjan for not reading more carefully =)
13:01:26 <shachaf> lispy: What about failing on the pattern-match?
13:01:46 <byorgey> shachaf: ah, good point
13:01:58 <lispy> shachaf: data Sealed a = Sealed a
13:02:03 <lispy> shachaf: so no worries
13:02:17 <shachaf> lispy: Not a problem in that case. :-)
13:02:25 <lispy> actuall, data Sealed a where Sealed :: a x -> Sealed a
13:02:25 <oerjan> what, not newtype? :)
13:02:50 <oerjan> oh dear
13:03:03 <lispy> oerjan: what does a newtype gain?
13:03:21 <lispy> oerjan: this (as you probably guess) is for hiding type witnesses
13:03:25 <desegnis> olsner, well there's no reason to worry about me
13:03:53 <byorgey> lispy: in general, a newtype can be more efficient since the compiler can optimize the constructor tags
13:04:04 <byorgey> lispy: but in this case I'm not sure if you can use a newtype (?)
13:04:05 <olsner> desegnis: so you *are* writing poetry which somehow involves the words "The Haskell Report"?
13:04:24 <shachaf> The Haskell Report *is* poetry.
13:04:29 <shachaf> (Well, maybe not Haskell 98.)
13:04:49 <oerjan> lispy: i am not sure if your unsealM is well-typed
13:04:54 <olsner> lol! I was just waiting for that comment about 1.4 being the best haskell ;-)
13:05:01 <monochrom> I can see how BNF is poetry.
13:05:38 <lispy> oerjan: I think it should have type unsealM :: Monad m => (forall x. a x -> b) -> m (Sealed a) -> m b
13:05:48 <oerjan> right
13:06:33 <oerjan> but then i think liftM might be too hard on the quantifiers...
13:06:46 <desegnis> oslner, Be Your anxiety becalmed, but shall the Haskell Report not be put to verses.
13:06:49 <lispy> oerjan: so maybe i should use do notation in the definition?
13:06:54 <oerjan> perhaps
13:07:23 <oerjan> well it depends on if f . unseal types i guess
13:07:26 <glen_quagmire> > (++ [1]) $! [1..]
13:07:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:07:42 <glen_quagmire> > (100:) $! [1..]
13:07:42 <lambdabot>  [100,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
13:08:01 <glen_quagmire> > seq [1..] 2
13:08:02 <lambdabot>  2
13:08:07 <monochrom> In the land of Haskell there lives a faithful honest man called Program.
13:08:19 <monochrom> Bountiful are his Imports and Declarations.
13:08:44 <glen_quagmire> > seq (id $! [1..]) 2
13:08:45 <lambdabot>  2
13:09:23 <ddarius> glen_quagmire: f $! [1..] === f [1..] as you've shown several times over.
13:09:32 <desegnis> olsner, as it turns out your idea is spreading :)
13:09:34 <shachaf> glen_quagmire: id is already strict.
13:09:39 <olsner> hmm, I hope someone's already invented an esolang where programs must be written on verse, so that I won't have to
13:09:50 <ddarius> olsner: I think someone has.
13:09:51 <glen_quagmire> how come seq (id $! [1..]) 2 is not bottom?
13:10:04 <monochrom> I think the do-notation is pretty close.
13:10:12 <mauke> glen_quagmire: because [1..] is not bottom
13:10:17 * ddarius thinks monochrom is crazy.
13:10:28 <glen_quagmire> what is a simple example of botom?
13:10:28 <monochrom> You think right.
13:10:32 <oerjan> olsner: not mandatory, but have you looked at .gertrude?
13:10:32 <mauke> undefined
13:10:33 <dolio> olsner: Shakespeare?
13:10:36 <shachaf> > fix id
13:10:37 <lambdabot>  Exception: <<loop>>
13:10:48 <glen_quagmire> > seq undefined 1
13:10:48 <lambdabot>  Undefined
13:10:51 <lispy> oerjan: you were write about liftM/fmap
13:10:54 <monochrom> infinite loops and exceptions are bottom.
13:10:58 <lispy> oerjan: do notation works though
13:11:13 <shachaf> @let lazySeq = flip const
13:11:14 <lambdabot> Defined.
13:11:15 <desegnis> glen_quagmire, fromJust Nothing, last [1..], let x =x in x, ...
13:11:17 <shachaf> > lazySeq undefined 1
13:11:18 <lambdabot>  1
13:11:24 <oerjan> lispy: yeah, since x1 is introduced in a new scope it should
13:11:34 <glen_quagmire> > error $! show [1..]
13:11:34 <lambdabot>  Exception: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
13:12:11 <monochrom> The WHNF of [1..] is something like 1 : blah.  seq [1..] finishes right there.  You can't get an infinite loop this way.
13:12:41 <shachaf> monochrom: blah : blah, no?
13:12:47 <monochrom> Yes, even that.
13:12:53 <shachaf> > seq (undefined : undefined) 5
13:12:54 <lambdabot>  5
13:13:11 <mauke> > seq (1 `undefined` []) 5
13:13:15 <lambdabot>  Undefined
13:13:24 <idnar> :t undefined
13:13:27 <lambdabot> forall a. a
13:13:27 <glen_quagmire> > show come (undefined : undefineD) is not bottom?
13:13:27 <lambdabot>   parse error on input `}'
13:13:40 <glen_quagmire> how come (undefined : undefineD) is not bottom?
13:13:43 <mauke> glen_quagmire: because it's (:)
13:13:49 <shachaf> glen_quagmire: _ : _ isn't bottom.
13:13:52 <shachaf> glen_quagmire: For any _s.
13:13:54 <monochrom> Because it is a fine cons cell.
13:14:04 <mauke> (Just undefined) isn't bottom either
13:14:12 <ricky_clarkson> > length (undefined : undefined)
13:14:12 <lambdabot>  Undefined
13:14:16 <desegnis> > seq [(undefined :: Int) ..] ()
13:14:17 <lambdabot>  Undefined
13:14:22 <shachaf> > map length ["fix id", "undefined", "error\"\"", "last[1..]"]
13:14:23 <lambdabot>  [6,9,7,9]
13:14:25 <glen_quagmire> > seq ((:) $! undefined undefined) 1
13:14:25 <lambdabot>  Undefined
13:14:28 <monochrom> "lazy list" requires cons cells to be considered non-bottom.
13:15:38 <monochrom> My vapourware book Space Age Haskell will contain more details.
13:16:07 <shachaf> monochrom: Is that book also _|_?
13:16:15 <oerjan> > length [fix id, undefined, error "", last[1..]]
13:16:16 <lambdabot>  4
13:16:23 <monochrom> That's undecidable :)
13:16:51 <hiteshj> Is there any way for me to access the datatype constructor Foo from a library, when the lib didn't export it?  Or do I have to modify the code for the lib?
13:17:07 <monochrom> > let x = length [fix id, undefined, error "", last[1..], x] in x
13:17:07 <lambdabot>  5
13:17:33 <monochrom> Kids: Don't do that at home with Java!
13:17:45 <mauke> hiteshj: the latter
13:17:52 <monochrom> or Python!
13:17:53 <shachaf> monochrom: They let Java into kids' homes?
13:18:27 <hiteshj> mauke: that's what I thought ... but I was hoping for something better
13:18:40 <mauke> leave my private constructors alone!
13:18:44 <shachaf> hiteshj: Hoping?
13:19:19 <oerjan> hiteshj: making such things impossible is sort of the point of not having things in export lists
13:19:24 <hiteshj> I don't know what it is, but I seem to keep needing a few more functions from libraries.  I'm hitting this with Graphics.GD right now.
13:19:54 <desegnis> hiteshj: You have always the option of filing a library bug report
13:20:08 <desegnis> Though that won't help you much in the short term
13:20:41 <hiteshj> If the author provided darcs access I'd just patch it and submit my changes
13:22:00 <hiteshj> oerjan: I know what you mean ... but sometimes the things are left out of export lists because the author didn't think anyone would need it ... not because they were trying to keep things safe.
13:22:11 <oerjan> aye
13:22:36 <hiteshj> There are times when I wish Haskell would let me run with scissors
13:23:19 <shachaf> hiteshj: You can probably look in /dev/mem if you really want to. :-)
13:23:37 <shachaf> (Not very portable, though.)
13:23:49 * oerjan googles unsafeRunWithScissors but finds nothing
13:23:50 <Cale> hiteshj: unsafeCoerce
13:24:00 <Cale> er, unsafeCoerce#
13:24:08 <Cale> :t unsafeCoerce#
13:24:09 <lambdabot> Not in scope: `unsafeCoerce#'
13:24:40 <Cale> :t GHC.Exts.unsafeCoerce#
13:24:41 <lambdabot> forall t b. t -> b
13:24:41 <hiteshj> ooohhhh ... that looks interesting !
13:24:56 <mauke> @index unsafeCoerce
13:24:56 <lambdabot> bzzt
13:25:00 <Cale> Break the type system completely!
13:25:01 * shachaf has it with and without #.
13:25:22 <mauke> :t Unsafe.Coerce.unsafeCoerce
13:25:22 <lambdabot> Couldn't find qualified module.
13:26:20 <olsner> > let unsafeCoerce = (undefined :: a -> b) in [1..70]++(unsafeCoerce False)
13:26:21 <oerjan> :t Unsafe.Run.withScissors
13:26:21 <lambdabot>  Undefined
13:26:22 <lambdabot> Couldn't find qualified module.
13:27:45 <shachaf> unsafeCoerceKitteh#
13:28:05 * shachaf shouldn't have said that.
13:30:32 <Cale> shachaf: That kitteh is going to claw your eyes out!
13:30:45 <idnar> yeah, coercing kitteh's is seriously unsafe
13:31:05 * shachaf is sitting next to a (hopefully) safe kitty.
13:31:39 <idnar> just don't try to coerce it
13:31:47 <oerjan> kittehs may throw sharp pointer exceptions at any time.  no safety.
13:32:02 <shachaf> idnar: She is more likely to coerce me...
13:32:15 <idnar> heh
13:32:32 <lispy> oerjan: turns out it wasn't liftM that I wanted to make work with unseal, it was (>>=)
13:32:49 <oerjan> ah
13:33:30 <oerjan> well desugaring do expressions should be entirely equivalent
13:34:06 <hiteshj> Cale: thanks for the scissors !
13:34:11 <Cale> hiteshj: heh
13:34:16 <ddarius> You're going to regret it.
13:34:31 <Cale> hiteshj: Also, note System.IO.Unsafe.unsafePerformIO
13:34:32 <oerjan> hm except you cannot make the existential variable pointless
13:34:55 <Cale> hiteshj: Which creates values that perform arbitrary IO when evaluated.
13:35:15 <Cale> That is, if the compiler doesn't somehow mangle them.
13:35:59 <olsner> heh, that statement at first sounded like an outlandish display of unsafety, but then I realized that that applies to *every* value in most other languages :(
13:36:00 <byorgey> ...with the Evil Mangler?
13:36:17 <byorgey> olsner: hehe
13:36:38 <hiteshj> if I understand it right, unsafePerformIO still performs the IO before the value is used, but no guarantees as to exactly when before.  is that right?
13:37:01 <olsner> btw, ghc-6.6's mangler seems to be incompatible with perl 5.10...
13:37:22 <shachaf> hiteshj: And no guarantees that it won't be evaluated more/fewer times than you need.
13:37:23 <monochrom> math.reddit has slowed down lately
13:37:28 <Cale> hiteshj: That's true. Also, it might be performed arbitrarily many times, depending on what the optimiser/inliner does.
13:37:34 <ddarius> monochrom: It's all your fault.
13:37:46 <monochrom> I didn't do anything.
13:37:58 <ddarius> monochrom: You admit your guilt.
13:38:07 <hiteshj> can you tame it by using noinline ?
13:38:14 <monochrom> what should I do?
13:38:35 <Cale> hiteshj: somewhat
13:38:53 * monochrom listens to Handel's Messiah instead.
13:38:59 <Cale> hiteshj: It should be treated with the same general level of seriousness as modifying the compiler though.
13:40:02 <Cale> unsafeCoerce# and unsafePerformIO are mostly there so that you can add new features to the evaluation model in libraries which you couldn't add otherwise.
13:40:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5545
13:41:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5546
13:41:26 <shachaf> (anonymous): There's a 5K limit.
13:41:37 <hiteshj> Cale: I think I've seen unsafePerformIO used in a number of libs.  Seems to be needed a lot.
13:41:43 <shachaf> (anonymous): Just @paste the error (and you can annotate, by the way).
13:42:04 <Cale> hiteshj: Depends on the library. Some people use it more frivolously than others.
13:42:20 <Trinithis> what is a 'lazy pattern'?
13:42:23 <Cale> hiteshj: It's handy when you're doing FFI and you know that the foreign interface is really pure.
13:42:45 <Cale> Trinithis: It's a pattern which always matches immediately, but doesn't force evaluation until one of the variables matched is needed.
13:42:59 <Cale> Trinithis: at that point, if the pattern didn't really match, you get an exception
13:43:15 <Trinithis> Cale: are they used often?
13:43:26 <monochrom> compare "case ~(x:xs) of undefined -> True" with "case (x:xs) of undefined -> True"
13:43:35 <Cale> Trinithis: well, whenever you pattern bind a variable, it's counted as a lazy pattern match
13:43:39 <glen_quagmire> > ['a' .. 'z']
13:43:43 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
13:43:54 <Cale> Trinithis: but otherwise, they're somewhat rare
13:44:01 <Trinithis> ok
13:44:12 <Cale> Like, if I write:
13:44:14 <monochrom> Also look at "let (x:xs) = undefined in True"
13:44:15 <glen_quagmire> in parsec, how can I describe all unicode characters that are not special symbols nore spaces?
13:44:27 <Cale> yes, something like that :0
13:44:31 <glen_quagmire> letters only accept [a-zA-Z]
13:44:36 <Cale> s/:0/:)/
13:44:52 <ddarius> monochrom: You jacked that up monochrom.
13:45:02 <lament> is there a good definition for what's a special symbol and what's a letter?
13:45:10 <monochrom> monochrom = fix jack_up ?
13:45:11 <oerjan> glen_quagmire: use satisfy
13:45:24 <olsner> satisfy . not $ liftM2 (||) whiteSpace specialSymbol
13:45:44 <olsner> s/\$/./
13:45:45 <Trinithis> I forget, but isn't there a way to make an accumulator strict? Something using an exclamation point?
13:45:46 <monochrom> Combine "satisfy" with predicates in Data.Char.  Data.Char is unicode-correct, or at least try very hard to.
13:45:55 <glen_quagmire> oerjan, olsner thank you
13:45:56 <Cale> Trinithis: yeah, a bang pattern will do
13:46:09 <monochrom> f !x y = x:y
13:46:22 <Trinithis> ah
13:46:24 <desegnis> lament: Data.Char.isAlpha
13:46:51 <Cale> Trinithis: What monochrom wrote is equivalent to  f x y = x `seq` x:y
13:46:56 <Trinithis> would you ever use a ! in front of a literal in a pattern?
13:47:00 <desegnis> lament: wait... you meant something else :)
13:47:07 <oerjan> Trinithis: no
13:47:08 <Cale> Trinithis: you could.
13:47:11 <monochrom> {-# LANGUAGE BangPatterns #-}
13:47:12 <oerjan> or wait
13:47:13 <Cale> Er...
13:47:22 <Cale> Depends on what you mean by literal...
13:47:24 <oerjan> no i don't think so
13:47:28 <glen_quagmire> > isAlpha '한'
13:47:29 <lambdabot>  Improperly terminated character constant at "'한'" (column 9)
13:47:37 <Trinithis> like: f !0 y = ...
13:47:39 <Cale> Er, right, it's going to have to force that anyway
13:47:47 <Cale> So that ! is pointless
13:48:04 <oerjan> glen_quagmire: > is not quite unicode-clean
13:48:14 <ddarius> monochrom: You switched the scrutinees and the guards in the cases.
13:48:16 <desegnis> > isAlpha '\54620'
13:48:17 <lambdabot>  True
13:48:18 <dcoutts_> glen_quagmire: but it works in ghci in 6.8
13:48:23 <Cale> ! is really only useful in front of variables
13:48:29 <glen_quagmire> yup
13:48:48 <ddarius> You can, but it's pointless and possibly damaging to performance.
13:48:48 <Cale> Because constructors occurring in patterns will cause things to be forced already.
13:48:56 <monochrom> If someone pays me us$10,000, I will start writing my Space Age Haskell immediately, to end all this acrimony concerning Haskell evaluation order!
13:49:22 <Cale> monochrom: What evaluation order will it use?
13:49:27 <Trinithis> Cale, say you have fac 0 and fac !n ... since it already trys matching for 0, is the !n redundant over n (assuming you want !)
13:49:32 <monochrom> haha
13:49:38 <Cale> Trinithis: yes
13:49:54 <Cale> Trinithis: because that'll already have been forced by matching with 0
13:50:13 <Trinithis> ok, just making sure my intuition was right
13:50:15 <monochrom> !x : !xs may be useful
13:50:31 <Cale> But not !(x:xs)
13:50:54 <monochrom> !~!~!~(x:xs)
13:51:10 <ddarius> That's legal (with maybe some more parens)
13:51:26 <Trinithis> and what does it do? looks scawy
13:51:32 <monochrom> just inviting someone to yell "make up your mind already!" :)
13:51:47 <Cale> Trinithis: ~ makes the pattern lazy
13:51:53 <ddarius> Trinithis: It should be the same as (x:xs) in that case.
13:52:03 <oerjan> monochrom: is this one of those spacy evaluation order options?
13:52:04 <monochrom> ~ says "I want to later", ! says "I want it now", and nesting them is just being silly.
13:52:05 <ddarius> (unless it's in a let)
13:52:15 <Trinithis> oh, hah
13:52:23 <Cale> err... it might be a little different from (x:xs)
13:52:26 <Cale> hmm
13:52:29 <monochrom> You should ask "so what do you want?" :)
13:52:46 <Cale> > let f !~(x:xs) = 0; f [] = 1 in f []
13:52:47 <lambdabot>  1
13:52:58 <Cale> hmm, okay, it is the same :)
13:53:05 <oerjan> @version
13:53:05 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
13:53:06 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:53:16 <oerjan> lambdabot has bang patterns?
13:53:18 <Cale> > let f !~!~!~(x:xs) = 0; f [] = 1 in f []
13:53:18 <lambdabot>  1
13:53:27 <Cale> apparently, yes
13:53:36 <Cale> > let f ~!~!~(x:xs) = 0; f [] = 1 in f []
13:53:37 <lambdabot>  1
13:53:48 <Cale> er, no, it's *not* the same :)
13:53:51 <Trinithis> on a different topic, are Arrows in haskell different than arrows (morphisms) in math?
13:53:55 <Cale> > let f (x:xs) = 0; f [] = 1 in f []
13:53:56 <lambdabot>  1
13:54:04 <Cale> > let f ~(x:xs) = 0; f [] = 1 in f []
13:54:05 <lambdabot>      Warning: Pattern match(es) are overlapped
13:54:05 <lambdabot>              In the definition...
13:54:11 <Cale> heh
13:54:26 <dmead> Trinithis, sort of?
13:54:36 <Cale> Er...
13:54:41 <dmead> isn't a monad a type or morphism?
13:54:42 <monochrom> The ~! result is a bit surprising. I can't explain it.
13:54:49 <dmead> and an arrow a type of monad?
13:54:53 <dmead> err wait
13:55:01 <Cale> monochrom: yeah, that's confusing
13:55:26 <Trinithis> its just that I think i read something like "we won't use the term arrows for morphisms because arrows mean something else in hs"
13:55:35 <Cale> monochrom: It might have something to do with ! being syntax sugar and not an actual language construct
13:56:12 <Cale> (or at least the desugaring being a little off)
13:56:18 <Cale> > let f ~!(x:xs) = 0; f [] = 1 in f []
13:56:19 <lambdabot>  1
13:56:25 <oerjan> Arrow values are a kind of morphism, but very restricted
13:56:27 <Cale> I'd expect that to give 0
13:56:51 <Cale> > let f ~(x:xs) = 0; f [] = 1 in f []
13:56:52 <lambdabot>      Warning: Pattern match(es) are overlapped
13:56:52 <lambdabot>              In the definition...
13:56:57 <Cale> Stupid warnings
13:57:01 <byorgey> where did you put that 'export' stuff? in ~/.profile?
13:57:01 <Cale> > let f ~(x:xs) = 0 in f []
13:57:02 <lambdabot>  0
13:57:05 <byorgey> er, mischan
13:57:08 <Cale> > let f ~!(x:xs) = 0 in f []
13:57:08 <lambdabot>   Not in scope: `f'
13:57:14 <Cale> ...
13:57:22 <Cale> > let f ~(!(x:xs)) = 0 in f []
13:57:24 <lambdabot>  Parse error in pattern at "in" (column 22)
13:57:26 <oerjan> the type class includes many operations that category morphisms need not support
13:57:31 <Cale> um, I have no idea
13:57:35 <Cale> @version
13:57:35 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
13:57:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:57:40 <monochrom> we have broken lambdabot. :)
13:57:51 <Cale> hmm
13:58:02 <Cale> > let f ~(!(x:xs)) = 0 in f []
13:58:02 <lambdabot>  Parse error in pattern at "in" (column 22)
13:58:02 <mbot>  Parse error in pattern at "in" (column 22)
13:58:06 <Cale> same result
13:58:14 <Cale> interesting
13:58:14 <Trinithis> oerjan: ok. from what I understand of them so far, they are like monads that allow static data to be given to them as well as dynamic data
13:58:30 <Cale> Where by 'interesting', I mean 'stupid'.
13:58:46 <oerjan> Cale: perhaps it does _not_ support bang patterns
13:58:47 <monochrom> Last night we had some trouble with "let { ... } in let { ... } in ..." too.
13:59:06 <oerjan> you are just defining a lot of !, !~, etc. operators :D
13:59:40 <Cale> ah
13:59:42 <byorgey> that's fine
13:59:43 <Cale> heh
13:59:54 * byorgey kicks irssi
13:59:56 <monochrom> > let f (! x) = True in f undefined
13:59:56 <lambdabot>  Parse error in pattern at "in" (column 20)
13:59:56 <mbot>  Parse error in pattern at "in" (column 20)
14:00:10 <Trinithis> eh, i need some rest. thanks for the help
14:00:20 <monochrom> I see.
14:00:32 <Cale> maybe I should have mbot stick around seeing as it's a newer lambdabot
14:00:35 <Cale> @version
14:00:36 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
14:00:36 <mbot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
14:00:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:00:36 <mbot> darcs get http://code.haskell.org/lambdabot
14:00:36 <lambdabot> Title: Index of /lambdabot
14:00:51 <byorgey> @src on
14:00:51 <lambdabot> (*) `on` f = \x y -> f x * f y
14:00:51 <mbot> (*) `on` f = \x y -> f x * f y
14:01:03 <Cale> lambdabot: @part
14:01:03 <lambdabot> Plugin `system' failed with: Prelude.last: empty list
14:01:04 <hpaste>  palomer pasted "how do I do this?" at http://hpaste.org/5547
14:01:04 <monochrom> How do I enter Mathematica commands again?
14:01:07 <Cale> lambdabot: @part #haskell
14:01:10 <Cale> hehe
14:01:16 <shachaf> % 1
14:01:19 <mbot> shachaf: 1
14:01:20 <Cale> % Integrate[Sqrt[Cos[x]],x]
14:01:22 <mbot> Cale: 2*EllipticE[x/2, 2]
14:01:32 <vincenz> @part #haskell
14:01:33 <mbot> Not enough privileges
14:01:39 <monochrom> I refuse to believe palomer doesn't know how to use IORef.
14:01:41 <vincenz> Cale: why'd you kick her?
14:01:54 <glen_quagmire> mbot: "asl?"
14:01:58 <shachaf> vincenz: mbot is newer, I guess.
14:02:01 <Cale> vincenz: mbot is a full lambdabot, but is newer
14:02:01 <vincenz> monochrom: I don't even know what he's asking
14:02:01 <monochrom> @botsnack
14:02:01 <mbot> :)
14:02:12 <vincenz> Cale: but it's a he!
14:02:16 <vincenz> it's not her
14:02:23 <glen_quagmire> > gender
14:02:26 <mbot>   Not in scope: `gender'
14:02:29 * shachaf thought mbot was an it.
14:02:29 <Cale> vincenz: We haven't got ghc6.8.2 on code.h.o yet, so we can't update lambdabot.
14:02:29 <vincenz> it's like her rebellious teenager son she had at far too young an age!
14:02:56 <vincenz> Cale: bah, you're just calling her old, be glad she's not around
14:03:17 <monochrom> Cale is saying she is *wise*
14:03:23 <vincenz> By saying she runs 6.6?
14:03:24 <oerjan> @vixen a/s/l?
14:03:24 <mbot> 19/f/California
14:03:33 <oerjan> hah!
14:03:40 <vincenz> oh noes, her evil twin
14:04:29 <monochrom> I refuse to believe mbot is 19 years old. It's like saying "I have 30 years experience in Python" on your resume.
14:04:46 <Cale> hah!
14:04:46 <kolmodin> :D
14:04:54 <glguy> > 1989 + 19
14:04:57 <mbot>  2008
14:05:20 <dons> there are certainly people with 20 years haskell experience :)
14:05:28 <dons> about 5 people
14:05:33 <Cale> hehe
14:05:42 * vincenz raises his hand
14:05:54 <glguy> You had a question?
14:05:55 <kolmodin> and 5 years of experience! /me raises his hand
14:06:06 <dons> anyone here with 10 years?
14:06:09 <glen_quagmire> > 2008 - 19
14:06:12 <mbot>  1989
14:06:15 <dons> H98 to now?
14:06:21 <Cale> I can't remember exactly which year it was when I started... 2001 maybe?
14:06:24 * kolmodin is streaching it. 5.5 years
14:06:27 <kolmodin> :D
14:06:28 <Cale> Could have been 2002
14:06:44 <monochrom> I have 18-20 years experience with functional programming, but not entirely Haskell.
14:06:49 * vincenz started in .. erm ... begin of 2005
14:06:59 <monochrom> BUT! I also have that long with C++. :)
14:07:12 <vincenz> monochrom: you're 40?
14:07:17 <monochrom> YES! I actually knew C++ 1.0.
14:07:17 <glen_quagmire> i have 5 years of programming experience.
14:07:26 <glen_quagmire> mostly in MS Excel
14:07:33 <kolmodin> 2002, 1 September. It was a sunny day, Hughes was bearded and welcomed us to Chalmers...
14:07:42 <kolmodin> like any other day..
14:07:46 <monochrom> Approaching 40. Please don't make me do a countdown. :)
14:07:46 <dons> kolmodin: hehe
14:08:10 <kolmodin> dons: ;)
14:08:21 * byorgey feels young...  not that I'm complaining ;)
14:08:29 <vincenz> byorgey: asl?
14:08:36 <Nafai> Hey byorgey!
14:08:56 <byorgey> vincenz: 26/m/outer space
14:09:00 <byorgey> hi Nafai!
14:09:37 <monochrom> You wouldn't know how happy I was when C++ was first revised to add templates. But of course now I say "screw it" and stick with HM polymorphism plus extensions.
14:10:08 <thoughtpolice> i have about 6 years experience and roughly 1 in haskell. i am quite the greenhorn, huh? :)
14:11:06 <dons> so i've 9 years almost to the day now. It was a sunny 1999 day, and I fired up Gofer for the first time. and you couldn't derive Eq.
14:11:20 <dons> all the cool kids had hugs
14:11:29 <desegnis> thoughtpolice, you match my profile actually
14:11:57 <vincenz> dons: and soon we'll have HUGZ
14:12:39 <Nafai> 9 years
14:12:40 <Nafai> Wow
14:12:45 <kolmodin> yeah, that's a lot
14:12:49 <Nafai> I first looked at Haskell maybe a year ago
14:12:55 <Nafai> But can barely program with it :)
14:13:10 <kolmodin> Nafai: give it a while, it'll grow on you :)
14:13:30 <idnar> it's ironic, I'm less proficient in C++ than almost any other language
14:13:39 <idnar> and yet I've spent more time on C/C++ than any other language
14:13:49 <monochrom> That is normal.
14:14:04 <idnar> yeah, it's not terribly surprising :P
14:14:23 <ray> there is no such thing as C/C++!
14:14:26 <kolmodin> I get paid to be less effective than I could be
14:14:35 <Nafai> kolmodin: Yeah, I just need to find more time for it.  I haven't tried writing any Haskell code for almost 2 months now :/
14:14:38 <monochrom> A very small subset of C++ people actually use in the real world.
14:14:43 <idnar> ray: sure there is
14:14:59 <idnar> ray: it's like Haskell/Erlang :P
14:15:22 <monochrom> By "subset" I don't mean avoiding some features. I mean using features in a very small number of idioms.
14:16:11 <monochrom> Python/Haskell
14:16:13 <ray> more like haskell/some hypothetical bad language that apes haskell syntax
14:16:20 <idnar> I'm sometimes annoyed by how long I was stuck with the notion that C and C++ were the only languages you could possibly write software in if you wanted acceptable performance
14:16:28 <monochrom> Lisp/Arc  :)
14:16:30 <ray> let's call it "visual h#" for now
14:16:39 <monochrom> Haskell/H# ? :)
14:16:53 <idnar> someone eventually convinced me to try Python out, and from there my horizons broadened considerably
14:17:08 <lispy> H# and unmanaged Haskell?
14:17:18 <monochrom> You weren't convinced to try Java?
14:17:59 <monochrom> Haskell / H# / untyped unchecked unmanaged unsafePerformIO Haskell  :)
14:18:04 <idnar> I was writing Python code long before I ever went anywhere near Java; and the only reason I ever did write Java code was because I had to for the university course I was doing (which I dropped out of halfway through anyhow)
14:18:04 <Nafai> I was convinced to try Java by a paycheck :/
14:19:09 <monochrom> I see. Yes, I agree trying out Python is much less an undertaking than trying out Java.
14:19:11 <lispy> idnar: I'm supposed to be using python more at work, but instead I find myself wonder if I could make a python backend for Yhc like the javascript one :)
14:19:37 <idnar> I did actually play around with Perl a bunch in my "C++ years", but never really considered it anything more than a toy for writing quick hacks
14:19:40 <Nafai> lispy: That could be fun!
14:19:40 <monochrom> When I tried out Java, it was because there was no Python. YES! I was there when Java 1.0 came out, too!
14:19:55 <Nafai> monochrom: You're OLD! :D
14:20:02 <Nafai> monochrom: just kidding, you know that, right?
14:20:05 <idnar> I was pleasantly surprised to find out that Perl was *not* the only language in the whole of existence that had a whole whack of handy libraries available
14:20:10 <monochrom> Well, if I was even there when C++ 1.0 first came out, ... :)
14:20:18 <idnar> oh well, I guess it could be worse
14:20:30 <idnar> at once stage, I was convinced that I should write all of my applications in x86 assembler
14:20:39 <Nafai> idnar: Weirdo :)
14:20:50 <monochrom> haha, that's a blisk outlook.
14:21:00 <idnar> I implemented half of a Real-Time Strategy game using DirectX in x86 asm :(
14:21:04 <ddarius> February 2002 for me.
14:21:14 <monochrom> you're leet
14:21:28 <idnar> looking back at the code I wrote then, my x86 ASM code looks a lot nicer than my C++ code
14:21:37 <monochrom> haha that's bad :)
14:21:39 <Nafai> lispy: Haha.  Here's the opposite of what you want: http://www.haskell.org/haskellwiki/Yhc/Pyhi
14:21:56 <monochrom> onoes!
14:22:23 <lispy> Nafai: heh
14:22:28 <monochrom> OK, I suppose "byte code interpreter" is so simple you can do it in a Turing machine even.
14:23:00 <Nafai> The Javascript backend for Yhc looks interesting though
14:23:08 <lispy> Nafai: I do wonder if writing such a backend would produce python code that I could convivce my managers was written in Python originally.  And what do I do if they have another dev work on the python output?
14:23:25 <idnar> anyhow, I really wish I'd tried out a functional language much earlier on
14:23:36 <monochrom> Write a YHC bytecode interpreter in Python. Write a Python bytecode interpreter in Java. Write a Java bytecode interpreter in Haskell to be compiled by YHC.  Enjoy!
14:24:07 <Nafai> lispy: I honestly doubt it, especially because there wouldn't be an easy way to go from Haskell -> idiomatic Python
14:24:11 <Nafai> idnar: Me too
14:24:29 <thoughtpolice> i have no job. i am useless, i guess (only 17)
14:24:52 <lispy> Nafai: where I work, idiot-o-matic is no problem..oh wait, you said idiomatic...as in idiom....nevermind.
14:24:55 <Nafai> idnar: I need to find an excuse to use functional languages at work
14:25:01 <Nafai> lispy: HEHE
14:25:04 <thoughtpolice> i want to get a job as a programmer, I just fear having to do java (I already do it for comp sci,) luckily my teacher lets me do haskell on the side when i get sick of it. :)
14:25:10 <ray> i wish i could say i've never held a job in my life, but that's sadly not true :(
14:25:29 <Nafai> thoughtpolice: Yeah, sometimes you have to do Java for work.  I have been doing so for 2 years.
14:25:30 * monochrom is truely fascinated by "universal computer" which entails you can have a stack of any number of levels of virtualization.
14:25:43 <Nafai> thoughtpolice: Luckily I don't work with complete morons, but yes, it is painful at times
14:25:46 <luqui> I have an error: "error in array index".  How do I use the debugger to figure out what line that is on?
14:25:47 <thoughtpolice> i had a job once at a hospital. it was cool. then the doctor i worked for moved to being the head of ER so I lost my job. :(
14:26:05 <Twey> thoughtpolice: Market demand is all Java/C# :-(
14:26:11 <Nafai> lispy: That's worthy of a quote file
14:26:11 <lispy> luqui: it's not that easy unfortunately
14:26:27 <luqui> I thought I read something somewhere explaining how to do just that
14:26:35 <luqui> and tried it, and it worked, I just forgot where it was :-/
14:26:36 <lispy> Well, there are some tricks
14:26:36 <thoughtpolice> if i could get a job doing .net with something like F#, that would be great as far as i'm concerned. is it haskell? no, but it's definately a lesser evil i feel.
14:26:43 <thoughtpolice> your definition of 'evil' probably varies though.
14:26:49 <lispy> luqui: probably the easiest is to use the CPP macros
14:27:33 * luqui doesn't believe lispy and goes digging around google some more
14:27:34 <lispy> luqui: and yeah, people have written articles about getting the line number for those sorts of things, I don't know where one is off the top of my head though.
14:28:58 <lispy> luqui: haskell-cafe archives and the haskellwiki are good places to search
14:29:03 <lispy> ?where wiki
14:29:04 <mbot> I know nothing about wiki.
14:29:07 <Nafai> thoughtpolice: I honestly believe, although working with Haskell or something similar would be ideal, it is just as important to work with other smart people on interesting things, regardless of implementation languages you have to use
14:29:12 <oerjan> ?wiki
14:29:12 <mbot> http://www.haskell.org/haskellwiki/
14:29:12 <lispy> mbot: you imposter!
14:29:33 <Twey> Nafai: There's a limit to that
14:29:39 <lispy> Nafai: yes, I agree
14:29:42 <thoughtpolice> Nafai: i can't judge such things since i have no experience, but i would imagine you are right.
14:29:43 <Twey> Nafai: (COBOL?  Pascal?)
14:30:23 <lispy> Nafai: and to some extent, you can trade competence for policy/convention
14:30:33 * Nafai nods
14:31:17 <lament> i don't think the programming language is at all important, compared to people you work with
14:31:35 <Nafai> I've learned a lot about software engineering practice, about design, about usability, etc at my job here
14:31:54 <Nafai> Although my work has been in Java, I've learned a lot that I can apply to the "dream job" where I use something like Haskell
14:31:59 <Nafai> (When I find such a job)
14:32:22 <taruti> bens: (interactive "e") fixed that also.
14:32:24 <glen_quagmire> > length "\&42"
14:32:26 <taruti> *benny
14:32:28 <mbot>  2
14:32:53 <Nafai> Where'd lambdabot got?  Who's this mbot? :)
14:32:53 <luqui> there it is: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
14:32:57 <taruti> too hard to get the correct channel.
14:38:08 <ddarius> "I don’t care if you are Socrates, Halliday&Resnick, and Edward bloody Tufte all rolled into one."
14:39:52 <Taejo> is there a specific GHC argument for Typeable-deriving, or do I have to use -fglasgow-exts ?
14:40:12 <ddarius> Taejo: Yes there is.
14:44:12 <Heffalump> -XDeriveDataTypeable
14:44:21 <Taejo> Heffalump: thanks
14:44:34 <Taejo> ddarius: thanks
14:49:04 <_frederik_> does haddock still not support GADTs?
14:49:57 <ddarius> The haddock.ghc version should support anything GHC supports.
14:50:03 <thoughtpolice> haddock 2.0 uses ghc as the frontend, so it should be able to parse anything ghc can
14:50:46 <_frederik_> ok is there a debian package?
14:51:06 <thoughtpolice> you'll have to check yourself; i wouldn't know where to, to be honest.
14:51:44 <_frederik_> ok there is something in debian but it is version 0.8
15:04:49 <tehgeekmeister> is intercalate in Data.List not exported?  i'm having problems with it not being in scope after importing Data.List (but i can use intersperse just fine.)
15:07:30 <quicksilver> tehgeekmeister: probably your version doesn't have it, it's quite new
15:07:47 <Japsu> intercalate = concat . intersperse?
15:07:54 <tehgeekmeister> Japsu: yep
15:07:57 <Japsu> k
15:08:16 <tehgeekmeister> quicksilver: oh, apparently my emacs is still using 6.6.1...
15:08:19 * tehgeekmeister fixes
15:12:06 <Taejo> I'm a monad transformer noob, and I need some help. I'm writing a program that tries to solve a puzzle... at each position there are several possible moves, but certain moves block moves at other places. I *think* I want some combination of [] (for the non-determinism) and State (for the state of the board) but I'm not sure how to combine them
15:12:43 <sarehu> maybe you want a list of states?
15:13:00 <sarehu> What do you mean, more specifically, by "certain moves block moves at other places"?
15:13:26 <Heffalump> you want the one that has type s -> [(a, s_
15:13:34 <Heffalump> IM s -> [(a, s)]
15:13:36 <sarehu> Does that mean anything more than the fact that the set of future available moves depends on the set of previous moves?
15:13:47 <Heffalump> i.e. you want StateT []
15:14:20 <Taejo> sarehu: if we use Sudoku as an example, putting a "1" in one place means there are other places you can't put a "1"
15:14:50 <sarehu> So you mean the set of moves simply depends on the current state?
15:15:00 <Taejo> sarehu: yes
15:18:05 <sarehu> Then you want to build something like [(BoardState,[Move])] to generate board states along with the sequence of moves that generates such a state.
15:18:17 <sarehu> That would be equivalent to   WriterT [Move] [] BoardState
15:19:38 <sarehu> Here's the catch: Is it possible for identical BoardStates to arise from different sets of moves?  Doing genaral listy non-determinism isn't so great in that case.
15:20:17 <Taejo> sarehu: yes, but not to a large degree
15:21:28 <sarehu> Depends on the problem, I guess.
15:23:08 <monochrom> @botsnack
15:23:08 <mbot> :)
15:23:40 <monochrom> @pl \p -> consumer (More (shift0 p $ \k -> return (Current () (k . return))))
15:23:40 <mbot> consumer . More . ($ return . Current . (. return)) . shift0
15:24:01 <monochrom> Nah...
15:30:29 <monochrom> @pl \p -> consumer (More (shift0 p (\k -> return (Current () (k . return)))))
15:30:29 <mbot> consumer . More . flip shift0 (return . Current . (. return))
15:30:40 <monochrom> Hah!
15:30:53 <tehgeekmeister> is there a function in the standard library to convert a TimeDiff to a DiffTime?
15:31:14 <monochrom> flip TimeDiff    <duck>
15:31:52 <tehgeekmeister> =P
15:31:56 <tehgeekmeister> i wish it were that easy.
15:33:13 <tehgeekmeister> it appears you can only get the time as a Clocktime, which the standard libraries only allow you to turn into a TimeDiff, but DiffTime is an instance of num, which makes it easier to define a mean for DiffTime
15:33:34 <tehgeekmeister> oh!  no, you can get the time in the other type, too.
15:33:37 <tehgeekmeister> wonder why we have both?
15:37:11 <skorpan> hey
15:37:28 <skorpan> does anyone know of a guide to installing hgl?
15:37:33 <allbery_b> tehgeekmeister: one is the old System.Time (limited range, Y2038 problem) and the other is Data.Time
15:38:08 <skorpan> seems that "flex" fails miserably
15:38:13 <allbery_b> most time-using code still uses System.Time, and the two aren't compatible
15:38:17 <litb> oh i'm not sure haskell will still run on state of the art 2038 PCs
15:38:52 <allbery_b> you might still want to represent times beyond March 2038
15:39:09 <litb> true :/
15:40:06 <blt> I'm haskell-curious and in need of QuickCheck properites, but I don't quite understand how to write Arbitrary instances. Would someone be so kind as to write an Arbitrary instance for Data.Set.Set and explain it?
15:43:15 <eugman> sceen
15:43:18 <eugman> whoops
15:45:33 <sarehu> blt: I've never used QuickCheck before... but..
15:46:02 <sarehu> I'd probably go with   arbitrary = liftM Data.Set.fromList arbitrary
15:46:21 <tehgeekmeister> allbery_b: do you know if the months in TimeDiff are some standard number of days, or are they calendar months?  i need to convert TimeDiffs to seconds.
15:46:58 <sarehu> blt: and   coarbitrary s = coarbitrary (Data.Set.toList s)
15:47:40 <sarehu> blt: essentially, I'm just piggy-backing on the    Arbitrary a => Arbitrary [a]  instance.
15:47:55 <sarehu> Making sets from arbitrary lists.
15:48:31 <blt> sarehu: Is that what the right-most arbitrary in the definition of arbitrary is?
15:49:09 <allbery_b> sorry, no idea
15:50:08 <Heffalump> blt: yes
15:50:15 <allbery_b> blt: yes, he's using the existing arbitrary for lists
15:50:27 <sarehu> What is the 'right-most arbitrary'?
15:50:43 <Heffalump> the one on the RHS of the definition you gave, rather than the one on the LHS
15:51:16 <sarehu> oh, yeah.
15:51:33 <sarehu> That's the version of arbitrary for lists.  You could also write it as
15:51:55 <sarehu> arbitrary = do { arbList <- arbitrary ; return (Data.Set.fromList arbList) }
15:53:50 <blt> arbitrary :: (Arbitrary a) => Gen a, so does that mean that the RHS arbitrary is polymorphic and becomes whatever type is needed?
15:54:48 <Saizan> blt: among the types with a Arbitrary instance
15:55:09 <sarehu> Yes.  In this case that type is [a], which the type checker knows because Data.Set.fromList :: [a] -> Set a
15:55:22 <sarehu> er, excuse me, put Ord a => in front of those types, because sets require Ord
15:55:50 <blt> Okay, neat. Thank you very much.
16:01:41 <litb> > fromList [1, 2, 3, 4]
16:01:44 <mbot>   Not in scope: `fromList'
16:02:14 <allbery_b> > M.fromList [1..4]
16:02:16 <mbot>   add an instance declaration for (Num (k, a))
16:02:16 <mbot>     In the expression: 1
16:02:23 <allbery_b> hm
16:02:30 <allbery_b> > Data.Map.fromList [1..4]
16:02:33 <mbot>   Not in scope: `Data.Map.fromList'
16:02:35 <litb> oh is the haskell system used with M. ?
16:02:44 <allbery_b> no
16:03:01 <allbery_b> IIRC in the real lambdabot Data.Map is imported as M for convenience
16:03:34 <davidL> @math 1+1
16:03:35 <allbery_b> I think mbot normally lives in math-related channels so M is probably some other module
16:03:44 <mbot> davidL: 2
16:04:46 <allbery_b> (fromList also exists in some other modules, btw)
16:05:00 <wy> Got "purely functional data structures" :)
16:05:28 <allbery_b> and a bunch of things in Data.Map are named the same as things in Data.List so you really do need to import it qualified
16:06:03 <wy> A small question. Is signiture of ML similar to type classes of Haskell? The programs are in ML in this book
16:07:01 <glen_quagmire> people still buy that book?
16:07:02 <sieni> I think that functors are somewhat similar to type classes except a bit better
16:07:51 <malsyned> glen_quagmire: there was an article on reddit today about how people still buy that book.
16:08:02 <glen_quagmire> Okasaki's wife said that
16:08:22 <malsyned> ah.  you were quoting.  I get it.
16:08:36 <wy> I got it from the library
16:08:54 <glen_quagmire> Implementing Functional Programs: a tutorial :  is the source code in haskell?
16:08:59 * wy almost never buy books
16:09:26 <wy> glen_quagmire: Yes, although it says Miranda
16:09:45 <glen_quagmire> oh i see. it sounds like a very nice book for me
16:09:54 <allbery_b> Miranda is the predecessor to Haskell, they are fairly similar
16:10:06 <wy> glen_quagmire: I guess the full version would be a better overview
16:10:56 <wy> allbery_b: right. I saw Simon's source code for that book. There are Miranda version in it, but he put Haskell version on the PDF
16:11:36 <wy> I haven't heard of anybody using Miranda
16:12:54 <wy> sieni: You said functors are better than type classes? why?
16:31:12 <izuker> anyone know why http://hpaste.org/5543#a2 doesn't run out of stack space, but the previous two versions do?
16:33:19 <glguy> izuker: the seq one might need parentheses
16:33:27 <glguy> a `seq` b `seq` (a+b)
16:34:11 <Twey> @src seq
16:34:11 <mbot> Source not found. And you call yourself a Rocket Scientist!
16:34:16 <Twey> :-\
16:34:34 <izuker> glguy: nope, still has the stack space error.  i think it's the recursion that kills it
16:34:49 <glguy> izuker: yeah, that would make sense
16:35:15 <izuker> but why doesn't the same happen with the flatten' version?
16:36:05 <lispy> ?djinn exchange :: f1 (f2 a) -> f2 (f1 a)
16:36:06 <mbot> Cannot parse command
16:36:11 <lispy> ?djinn f1 (f2 a) -> f2 (f1 a)
16:36:12 <mbot> -- f cannot be realized.
16:36:21 <Twey> izuker, tail-recurse?
16:37:24 <izuker> "flatten' ( Branch s t ) = flatten' s . flatten' t" is tail recursive?
16:37:59 <glguy> no, but it is a good producer
16:38:00 <Twey> It isn't
16:38:56 <izuker> glguy: ?
16:39:09 <glguy> flatten is able to lazily produce the list
16:39:13 <glguy> and length is tail recursive
16:48:47 <ddarius> flatten' is a fold
16:49:27 <lispy> :t unsafeInterleaveIO
16:49:31 <mbot> Not in scope: `unsafeInterleaveIO'
16:50:36 <lispy> ?hoogle unsafeInterleaveIO
16:50:37 <mbot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
16:51:09 <hpaste>  (anonymous) annotated "Exception: stack overflow" with "(no title)" at http://hpaste.org/5543#a3
16:51:45 <izuker> why does the non-flatten version i just posted fail?  it looks substantially the same as the flatten one...
16:54:26 <glguy> counter _ acc _ | acc `seq` False       = undefined
16:54:27 <glguy> counter (Branch s t) acc xs             = counter s acc (t:xs)
16:54:29 <glguy> counter Leaf acc (x:xs)                 = counter x (1+acc) xs
16:54:31 <glguy> counter Leaf acc []                     = 1+acc
16:54:36 <glguy> by managing its own stack, that doesn't die :)
16:54:49 <glguy> (exporting it's stack to the heap rather)
16:55:28 <glguy> which is similar to what the "flatten" function was doing
16:55:37 <glguy> pushing the content into the heap was it went
16:56:36 <izuker> glguy: ok, i can see why your version works, but i still don't see why the flatten one does
16:57:05 <dons> mbot: @part #haskell
16:58:02 <Cale> izuker: Well, (+) must evaluate both its args before it can finish.
16:58:06 <LoganCapaldo> so long, and thanks for all the lambdas
16:58:27 <dmwit> Oh, that "acc `seq` False" trick is nice.
16:59:47 <Cale> izuker: Whereas (.) is only strict in its first parameter, and so results in production of the start of the list of nodes to be counted sooner.
16:59:57 <ddarius> dmwit: That !acc "trick" is nicer
17:00:08 <izuker> Cale: OH!
17:00:13 <izuker> Cale: wait, do you mean (:)?
17:00:14 <stick_figure> The seq just makes it strict in acc?
17:00:31 <Cale> izuker: (:) is totally lazy, it evaluates neither of its args.
17:01:04 <dmwit> ddarius: Mmm, yes.
17:01:04 <Cale> (it's really the surrounding foldl' in length which forces further evaluation of the list)
17:01:27 <dmwit> ddarius: I don't have a lot of experience with strictness annotations, so I'm a bit slow at seeing when/how to do it. =P
17:01:41 <izuker> ok, i see now.  the (+) forces evaluation of its second arg, which makes for lots of recursion
17:01:59 <izuker> or, rather, first arg the way i wrote it
17:02:47 <Cale> Well, it has to evaluate both before it can do anything
17:03:06 <Cale> Which means that it sits on the stack waiting for that evaluation to finish.
17:04:53 <izuker> while i have your attention, what haskell graphics lib would you recommend?
17:05:01 <dmwit> gtk2hs + cairo
17:05:05 <dmwit> or hopengl
17:05:10 <izuker> i'm interested in getting for zero to lines and circles pretty quickly
17:05:15 <dmwit> Depends on what you want to do, I guess. =P
17:05:17 <Cale> For what sort of graphics? Yeah, gtk2hs is rather nice.
17:05:22 <dons> gtk2hs, yep.
17:05:38 <dons> http://haskell.org/gtk2hs/
17:06:27 <dons> hello world is 5 lines or so,
17:06:29 <dons> import Graphics.UI.Gtk
17:06:29 <dons> main = do initGUI window <- windowNew set window [ windowTitle := "Hello, World" ] onDestroy window mainQuit widgetShowAll window mainGUI
17:06:34 <dons> grr. with line breaks :)
17:07:15 <izuker> thanks!
17:07:21 <Saizan> it's shorter than java CLI hello world :D
17:07:25 <dons> hehe
17:07:52 <dons> main = print "hello, world"
17:08:25 <LoganCapaldo> main = "hello, world" -- for  an appropiately defined instance of IsString
17:08:46 <Saizan> $("hello, world") with another :)
17:09:41 <Cale> http://hpaste.org/5548#a1 -- lazy evaluation is beautiful :)
17:09:53 <Saizan> IsString has brought haskell obfuscation to another level..
17:11:31 <izuker> Cale: very nice
17:11:34 <Cale> flatten' puts a lot of things on the heap though
17:11:58 <Cale> Those (flatten' Leaf (flatten' Leaf []))'s build up
17:12:00 <astrolabe> Cale: How did you get the staged evaluation?
17:12:07 <Cale> astrolabe: evaluated it by hand
17:12:14 <olsner> Saizan: just one level? plenty of room for more levels of obfuscation then! :P
17:12:20 <astrolabe> Cale: :)
17:12:33 <dmwit> Cale: What, you didn't even stick it in a Writer monad?
17:13:20 <Cale> dmwit: That would be slightly more confusing to evaluate by hand :)
17:13:32 <dmwit> hahaha, *whoosh*
17:13:56 <dmwit> I love this place.
17:14:31 <LoganCapaldo> h -- in the HQ9Plus Monad
17:15:40 <dmwit> Writing an HQ9+ interpreter is both fun and trivially short.
17:15:47 <wy> SML signatures really look interesting. Can type classes have nonfunction values in it?
17:15:52 <lispy> HQ9+?
17:16:02 <dmwit> ?go hq9+
17:16:03 <lambdabot> http://www.cliff.biffle.org/esoterica/hq9plus.html
17:16:03 <lambdabot> Title: HQ9+
17:16:10 <Saizan> wy: yes
17:16:24 <wy> Saizan: so they are very similar...
17:16:39 <Saizan> ?src MonadPlus
17:16:39 <lambdabot> Source not found. stty: unknown mode: doofus
17:16:44 <Saizan> ?src Monoid
17:16:44 <lambdabot> class Monoid a where
17:16:45 <lambdabot>     mempty  :: a
17:16:45 <lambdabot>     mappend :: a -> a -> a
17:16:45 <lambdabot>     mconcat :: [a] -> a
17:17:06 <wy> I don't know if I can have signatures as polymorphic type arguments
17:17:18 <wy> sorry structures
17:17:31 <wy> Saizan: got it
17:18:19 <wy> @users
17:18:19 <lambdabot> Maximum users seen in #haskell: 471, currently: 419 (89.0%), active: 15 (3.6%)
17:19:14 <Cale> Oh, izuker disappeared. I was going to mention that the stack can be pictured there as the distance from the end of the chain of conses to the place where the next evaluation is happening.
17:20:32 <Cale> (since the conses are really being eaten by the foldl' anyway)
17:21:57 <Cale> OH HAI! I MADE YOU A CONS, BUT I EATED IT.
17:22:18 <litb> uhuhu
17:22:23 <LoganCapaldo> Cale, you so craaaazy
17:22:26 <litb> omg what does (): mean ?
17:22:55 <litb> other than some freaky smiley?
17:23:03 <LoganCapaldo> @type (():)
17:23:05 <litb> a i think i get it. it appends "()" to a list
17:23:05 <lambdabot> [()] -> [()]
17:23:29 <LoganCapaldo> prepends
17:23:31 <litb> yeah
17:23:41 <litb> i meant that :)
17:24:15 <LoganCapaldo> k :)
17:25:28 <litb> tho i can't think of something that is useful for
17:25:33 <lispy> I can
17:25:35 <idnar> what the heck is the point of the "+" operation in HQ9+?
17:25:37 <litb> maybe for a dummy case
17:25:41 <dons> "software transactional memory system for Mercury,"
17:26:11 <lispy> > \tuples > [ x | x <- [1,2,3], y <- tuples]
17:26:11 <lambdabot>  Parse error at ">" (column 9)
17:26:14 <lispy> oops
17:26:30 <Saizan> idnar: you always need to increment a counter.
17:26:42 <LoganCapaldo> idnar: something to optimize ;)
17:28:25 <idnar> LoganCapaldo: hahaha
17:36:11 <monochrom> @seen dolio
17:36:11 <lambdabot> dolio is in #haskell. I last heard dolio speak 4h 25m 38s ago.
17:36:25 <monochrom> Oh good, lambdabot is back
17:36:29 <monochrom> @version lambdabot
17:36:29 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
17:36:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:38:08 <monochrom> @tell dolio Thank you again for Control.Monad.CC.Cursor. I am find more and more uses of it. It's powerful! Its built-in self recursion is extremely important.
17:38:08 <lambdabot> Consider it noted.
17:39:21 <LoganCapaldo> whats Cursor?
17:40:12 <litb> CC.Cursor. what is that?
17:41:14 <monochrom> @hackage CC-delcont
17:41:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont
17:41:31 <monochrom> It's in CC-delcont.
17:41:48 <monochrom> Very potent delimited-continuation and Oleg magic.
17:41:54 <litb> too bad todays keyboard don't have keys for alpha, beta phi and so on
17:42:19 <monochrom> α β φ ϕ and so on :)
17:42:28 * monochrom installed SCIM on linux
17:42:40 <litb> lolz
17:42:58 <litb> oh
17:43:03 <resiak> monochrom: have you made it work with urxvt by any chance ?
17:43:07 <litb> can you use these variables in haskell code too?
17:43:21 <monochrom> No, I have never used urxvt.
17:43:29 <litb> monochrom: and konsole ?
17:43:41 * litb makes a hoping smily
17:43:41 <monochrom> Yes, they are fine in haskell source code, ghc loves them.
17:43:48 <monochrom> No, I have never used konsole.
17:43:53 <litb> darn
17:44:06 <litb> u use them in your code?
17:44:29 <litb> i wonder whether it is fast to insert them or you have to click through menus or write insert-alpha-here or thelike
17:44:30 <monochrom> I just use whatever ubuntu gives me (that means gnome pretty much). I am not a customizer.
17:44:39 <litb> oh i see
17:44:57 <litb> i'm teh desktop modder i'm crazy
17:45:00 <monochrom> I haven't used greek letters or chinese characters in my haskell code, but I have seen it work.
17:45:25 <wagle_home> ت
17:45:34 <litb> hehe sweet a smily
17:45:42 <wagle_home> arabic char
17:45:49 <jorik808> how can i have my parsec parser choke when there is "still input left"?
17:45:52 <litb> does it mean "funny" or so?
17:46:05 <litb> or is it just one character like "a" ?
17:46:08 <wagle_home> my linux input has it inputting from right to left, too
17:46:09 <jorik808> litb: it's probable a letter
17:46:11 <monochrom> I installed SCIM as Cale suggested. I type \alpha for α .  (I also need SCIM for Chinese.)
17:46:15 <jorik808> ly*
17:46:24 <litb> nice
17:46:49 <litb> if i only would be more advanced in emacs , i would make it insert pics for \lambda and so on
17:47:31 <monochrom> Cale knows more technical details and recommendations for getting things to work. SCIM is very likely to work fine with most X programs.
17:47:35 <litb> one more question: is there a rule what chars to use for type variables, and what for parameters?
17:48:00 <litb> because i always mixx a and b for type variables and parameters and it's getting confusing
17:48:11 <LoganCapaldo> monochrom: howd you type \alpha thogh? :)
17:48:14 <litb> monochrom: oh, nice
17:48:16 <wagle_home> apparently, i used gucharmap to input chars
17:48:35 <jorik808> noone knows the answer to my parser problem? i'm tempted to just specify a terminator in my top parser, but there has to be a better way, no?
17:48:36 <wy> monochrom: are you chinese?
17:48:52 <ddarius> jorik808: p >> eof
17:49:06 <monochrom> Both are under the same rules. Start with "lowercase" "alphabetical". There is no way to distinguish type variables vs value variables unless you parse code yourself or use your own convention.
17:49:16 <jorik808> ddarius, thx ill try that
17:49:26 <monochrom> Yes I'm Chinese. My name is 黎裕昌.
17:49:42 <Botje> hello, square square square!
17:49:48 <monochrom> hahahaha
17:49:50 <litb> ah, finally i've understood to write the powerset function. now lets try a permutation function for lists..
17:49:52 <lispy> ??? is what I see
17:49:52 <wy> monochrom: I didn't know. haha
17:50:09 <ddarius> > filterM (const [True,False]) "abc"
17:50:10 <monochrom> There are a few other Chinese haskellers here.
17:50:11 <wy> monochrom: I'm also Chinese
17:50:13 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
17:50:37 <litb> ddarius: yeah i know that, but i wanted to write my own non-monadic one =1;2~)
17:50:45 <litb> oops some control chars there
17:50:49 <lispy> > filterM (const [True]) "abc"
17:50:49 <lambdabot>  ["abc"]
17:51:29 <litb> > filterM (/= 'b') "abc"
17:51:30 <lambdabot>  Couldn't match expected type `m Bool' against inferred type `Bool'
17:51:49 <litb> too bad :/ isn't that the ->e monad?
17:52:14 <litb> e.g Char->Bool ?
17:52:37 <resiak> @t filterM
17:52:37 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:52:41 <resiak> @ty filterM
17:52:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:52:46 <LoganCapaldo> > filterM (const (/= 'b')) "abc"
17:52:47 <lambdabot>  <Char -> [Char]>
17:52:53 <LoganCapaldo> is -> e
17:52:56 <jorik808> ddarius, thanks it worked like a charm :D
17:53:37 <monochrom> LoganCapaldo: After activating SCIM (normally always activated after log on), there are all sorts of shortcut keys to tell it to go to sleep, to wake up, to select a different input method. In fact normally at activation it's asleep, not intercepting or fudging anything.
17:53:42 <litb> oh i see
17:54:29 <LoganCapaldo> aha
17:54:44 <LoganCapaldo> i was expecting \\alpha <g>
17:55:19 <monochrom> Apparently, that also works, but most of the time I tell it to go to sleep anyway.
17:55:51 <litb> > filterM (\x -> [x /= 'b']) "abc"
17:55:53 <lambdabot>  ["ac"]
17:56:48 <eugman> can someone explain to me how using recursion to create a main loop won't cause a ton of memory overhead? Is there another way to do it?
17:57:12 <dmwit> map
17:57:46 <dmwit> (or mapM if that's more appropriate, or foldr, or...)
17:59:01 <eugman> k
17:59:21 <ddarius> litb: filterM . (return .) = return . filter
17:59:47 <ddarius> eugman: Why do you think it will create a "ton of memory overhead"?
18:00:59 <monochrom> afk but I think some of you should discuss with eugman what he/she is doing and/or why he/she ask the question e.g. is he/she actually observing memory blowup? or just unproven fear?
18:01:49 <malsyned> eugman: do you know about tail call elimination?
18:02:21 <eugman> malsyned: actually no but I figured there was probably something to deal with normal recursion problems
18:03:04 <wagle_home> "tail recursion"..
18:04:05 <hpaste>  (anonymous) annotated "Exception: stack overflow" with "(no title)" at http://hpaste.org/5543#a4
18:04:08 <wagle_home> if the last thing you do in a function is return the value of a call to another (or the same) function, that is optimised to a goto-with-arguments to that function, so the stack doesnt grow
18:04:17 <malsyned> eugman: In a function, some statements can be shown to be the "last thing" the function does.  If a function calls itself in one of these "tail positions", then it can be compiled to use only constant space.
18:04:56 <malsyned> (as wagle_home pointed out, it doesn't have to call itself.  It can call another function as well.)
18:05:24 <eugman> So, do I have to do something special to inform the compiler?
18:05:44 <malsyned> eugman: not in Haskell, no.  Tail-call elimination is done by default.
18:06:15 <LoganCapaldo> s/Haskell/any sane Haskell implementation/
18:06:26 <malsyned> eugman: in Scheme tail-call elimination is actually required.  in Common Lisp and C it's up to the compiler, and often you do have to pass a flag to the flag to enable tail call elimination.
18:06:42 <malsyned> LoganCapaldo: of course.  My mistake.  Only the Scheme standard has the stones to actually require tail-call elimination in the language spec.
18:06:48 <ddarius> eugman: Lacking tail call elimination is arguably an implementation bug/design error
18:07:41 <ddarius> malsyned: Haskell is not even necessarily a lazy language according to the Report
18:07:52 <OceanSpray> does hGetContents close a handle?
18:08:00 <allbery_b> "half-close"
18:08:01 <ddarius> It semi closes it
18:08:06 <litb> oh
18:08:11 <OceanSpray> what?
18:08:14 <litb> i thought that getContents closes the stdin
18:08:17 <malsyned> OceanSpray: hGetContents ensures that when the last byte of the file has been read (lazily), the file will be closed.
18:08:17 <ddarius> OceanSpray: Check the Report.
18:08:23 <OceanSpray> oh.
18:08:25 <allbery_b> it acts closed if you try to use it, but isn't actually closed until all input is consumed
18:08:28 <malsyned> litb: same for getContents.
18:08:37 <OceanSpray> hmm
18:08:45 <litb> allbery_b: ah i understand
18:08:46 <eugman> Ok, so to recap, I can implement a loop using recursion like in the guessing game example and there won't be a stack overflow(or whatever the term)?
18:08:47 <OceanSpray> well, I'm trying to read from stdin,
18:08:56 <malsyned> eugman: correct
18:09:00 <litb> well if you lose the reference to the list from which you want to read lazy, then you are screwed
18:09:05 <OceanSpray> and I need to run a parser on input.
18:09:27 <OceanSpray> how do I parse just enough but keep stdin open?
18:09:28 <malsyned> Actually, litb makes a good point.  Will a semi-closed file handle be closed by the GC?
18:09:46 <malsyned> OceanSpray: if you just use getContents, Haskell will do the right thing.
18:09:48 <ddarius> OceanSpray: Don't use hGetContents (and co.)
18:09:59 <OceanSpray> :t getContents
18:10:01 <lambdabot> IO String
18:10:02 <jorik808> ddarius, tail call elimination does change the way a language is going to be used, (although it could be argued this isn't *really* changing the semantics of the language)
18:10:04 <OceanSpray> huh.
18:10:26 <ddarius> jorik808: Your point?
18:10:33 <OceanSpray> but I want to pass a handle into the function.
18:10:58 <OceanSpray> can I compare handles?
18:11:03 <OceanSpray> h == stdin ?
18:11:10 <ddarius> @instances Eq
18:11:12 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
18:11:23 <OceanSpray> Oh boy.
18:11:24 <ddarius> @instances-importing System.IO Eq
18:11:24 <lambdabot> (), All, Any, Bool, BufferMode, Char, Double, Either a b, Float, Handle, HandlePosn, IOMode, Int, Integer, Maybe a, Ordering, Product a, SeekMode, Sum a, [a]
18:11:27 <lispy> > () == ()
18:11:28 <lambdabot>  True
18:11:31 <malsyned> OceanSpray: getContents will behave as if it's returning a pure string, but in the background it's actually only reading as much as you need.  Your best bet is to just operate on the string that getHandle returns and forget about explicit file-handle stuff, if that's possible in your application.
18:12:04 <OceanSpray> you mean getContents, not getHandle, right?
18:12:19 <litb> oko.O
18:12:22 <litb> oops
18:12:24 <allbery_b> consider having your parser function return the tail of the string after the parser succeeds?  (of course you have issues if the parse *fails*... might want to think about that)
18:12:27 <malsyned> OceanSpray: oops, eyah
18:12:48 <malsyned> :i stdin
18:13:16 <allbery_b> :t System.IO.stdin
18:13:17 <lambdabot> GHC.IOBase.Handle
18:13:20 <_frederik_> yay, i can run haddock on my code now
18:13:51 <greatman1> what is the best and smartest torrent program? like scam bandwidth etc? :D thank you
18:14:36 * lispy assumse greatman1 is a troll
18:14:59 <litb> hehe /me assumes too
18:15:30 <litb> trolls -> #qt
18:15:40 --- mode: ChanServ set +o allbery_b
18:15:50 <_frederik_> http://ofb.net/~frederik/vectro-haddock/Vector-Base.html
18:18:45 <lispy> vectro?
18:18:55 <_frederik_> it's purposeful, yes
18:19:05 <_frederik_> that's the name of the library
18:19:26 <_frederik_> an early version was in the abstract i presented at the haskell workshop in 2006 i believe
18:19:39 <OceanSpray> doesn't seem to be working... I'm getting the same "> screw: <stdin>: hGetLine: illegal operation (handle is closed)" error.
18:20:08 <lispy> OceanSpray: could it be a problem with the lazy nature of getContents?
18:20:24 <OceanSpray> maybe.
18:20:26 <OceanSpray> I don't know.
18:21:11 <LoganCapaldo> you can't mix getContents and any other IO op (like getLine) successfully
18:21:31 <LoganCapaldo> pick one
18:21:50 <OceanSpray> I'm using getLine, and it works now.
18:22:33 <OceanSpray> > ((nlambda () (eval (read stdin) caller-env)))
18:22:33 <OceanSpray> (+ 1 2)
18:22:33 <OceanSpray> 3
18:22:34 <lambdabot>   Not in scope: `env'
18:22:43 <OceanSpray> This rocks.
18:23:05 <LoganCapaldo> alternativly you could use lines in conjunction with getContents
18:23:45 <allbery_b> more painful if you're parsing complete sexprs as opposed to line
18:23:46 <allbery_b> s
18:24:05 --- mode: allbery_b set -o allbery_b
18:24:34 <litb> putBetween x xs = [ take i xs ++ [x] ++ drop i xs | i<-[0..length xs] ]
18:24:43 <litb> i wonder whether that is the right way to do it?
18:24:44 <OceanSpray> allbery_b, that's a problem I'm wrestling with right now.
18:25:01 <wagle_home> what?  scheme got over algol envy?  (/me got fed up years ago when someone asked about eval, and the only answer was "eval?  there's no eval in scheme..")
18:25:12 <OceanSpray> I want a getLine that "sees" a lack of a closing paren, and continues reading after that.
18:27:25 <allbery_b> that won't work
18:28:21 <allbery_b> if you do it naively, strings and ?( / ?) (or scheme equivalent; I'm no schemer) will bite you; you need a full lexer to get it right
18:28:51 <allbery_b> and once you've done that, well, you've already done everything you need :)
18:29:09 <OceanSpray> oy.
18:29:12 <OceanSpray> sounds complicated.
18:29:47 <lispy> lexer :: String -> [Token]
18:29:50 <lispy> not that bad
18:30:33 <wagle_home> wow..  petite chez scheme's getline has an indenter and a paren bouncer
18:31:09 <LoganCapaldo> now that's a repl!
18:31:14 <wagle_home> and history saved across sessions
18:31:23 <LoganCapaldo> eh, that's easy
18:31:43 * OceanSpray want.
18:31:49 <wagle_home> havent seen ghci or hugs do it, but havent worked at it
18:32:55 <OceanSpray> I already got a parser... just have to use that.
18:32:59 <allbery_b> ghci could do it, since it uses readline it would just need to activate readline's history support
18:33:11 <allbery_b> but it's dubiously useful in ghci
18:35:04 <_frederik_> here is the rest of the library, in case anyone is curious: http://ofb.net/~frederik/vectro-haddock/
18:36:43 <_frederik_> a few of those modules are internal
18:38:00 <OceanSpray> tokens, eh?
18:39:26 <eugman> What command can I import a .hs file in ther interpreter with?
18:39:47 <_frederik_> eugman: :l
18:40:29 <sarehu> eugman: with :help   :P
18:40:37 <taruti> Is it possible to lift Text.Printf.printf easily into a new monad?
18:41:40 <LoganCapaldo> into a new monad? What are you talking about? printf is a pure function
18:41:43 <sarehu> > printf "%d\n" 3 :: String
18:41:44 <lambdabot>  "3\n"
18:41:50 <allbery_b> eugman:  :m +Module
18:41:56 <sarehu> > printf "%d\n" 3 :: IO ()
18:41:57 <lambdabot>  <IO ()>
18:42:07 <allbery_b> printf is only pure if not put into IO, yeh
18:42:19 <allbery_b> if in IO, use a monad transformer on top of IO
18:42:20 * LoganCapaldo knows this
18:42:28 * LoganCapaldo is being deliberately dense
18:43:43 <idnar> :t printf
18:43:44 <lambdabot> forall r. (PrintfType r) => String -> r
18:43:55 <idnar> @instances PrintfType
18:43:57 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
18:44:01 <idnar> @where printf
18:44:01 <lambdabot> I know nothing about printf.
18:44:05 <idnar> @index printf
18:44:05 <lambdabot> Text.Printf
18:44:05 <sarehu> taruti: anyway, you can adapt the String version of it for common use.
18:44:11 <idnar> @instances-importing Text.Printf PrintfType
18:44:14 <lambdabot> (a -> r), IO a, [c]
18:44:41 <_frederik_> printf is pretty cool
18:44:56 <wagle_home> > printf 'c'
18:44:57 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
18:45:06 <idnar> huh
18:45:09 <wagle_home> > printf 'c' :: Char
18:45:11 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
18:45:17 <LoganCapaldo> > printf "%c" 'c' :: String
18:45:17 <idnar> > printf "%d\n" :: String
18:45:19 <lambdabot>  "c"
18:45:19 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
18:45:23 <idnar> heh
18:45:34 <idnar> > printf "%d\n" :: (Int -> String)
18:45:35 <lambdabot>  <Int -> [Char]>
18:45:37 <taruti> sarehu: but how would the type seem like?
18:45:42 <idnar> > printf "%d\n" 5 :: (Int -> String)
18:45:43 <lambdabot>  <Int -> [Char]>
18:45:48 <idnar> > (printf "%d\n" 5 :: (Int -> String)) 5
18:45:50 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
18:46:01 <wagle_home> yeah yeah..  was just trying to get something not of those three types
18:46:02 <idnar> > (printf "%d\n" 5 :: [Int]
18:46:02 <lambdabot> Unbalanced parentheses
18:46:07 <idnar> > printf "%d\n" 5 :: [Int]
18:46:07 <lambdabot>   add an instance declaration for (IsChar Int)
18:46:07 <lambdabot>     In the expression: printf ...
18:46:14 <idnar> fun
18:46:29 <LoganCapaldo> > printf "type safety no guaranteed"
18:46:30 <lambdabot>  Add a type signature
18:47:06 <taruti> myprintf :: PrintfType ... => String -> <something>, that ends up being MyMonad (). But since the typeclass is not exported that seems impossible to do.
18:50:11 <eugman> Would parsec be overkill for a simple verb noun  Interactive fiction parser?
18:50:29 <_frederik_> eugman: i don't think so
18:50:41 <wagle_home> > 1 + 1 -- <--  THIS is overkill
18:50:47 <lambdabot>  2
18:51:03 <_frederik_> eugman: what about it would be overkill? it is very easy to use
18:51:17 <wagle_home> what are you going to plug the parser into?
18:51:51 <eugman> wagle_home: I don't have enough knowledge to give  sufficent answer to that.
18:53:19 <wagle_home> i'd make it the same language that you write the interactor (the thing that uses the parser to give structure to the input) in..  reimplement in parsec when the grammar gets complicated
18:54:03 <wagle_home> unless the object is just to get your feet wet in parsec, in which case, the problem is just fine..
18:54:57 <wagle_home> heck, having a nice parser might encourage you to try more complicated grammars
18:55:15 <eugman> wagle_home: well, yes but the more important goal is to build a simple IF program.
18:57:07 <eugman> As I think about it I could probably just do words on the input for the time being and take the first two.
19:00:57 <wagle_home> yeah, if you are just going to do verb noun, then splitting the input on whitespace is the fastest way to get started...  if you succeed in your interactor well enough that you want to expand the grammar, then at some point, something like parsec may be the way to go
19:01:47 <wagle_home> then just replace the reader with the spiffier reader
19:04:48 <eugman> wagle_home: Any suggestions on a way to use the verb to determine the function to apply t the game state. The only thing I can think of right now would be if thens or a case and I know there's some smart way
19:05:24 <LoganCapaldo> Data.Map perhaps
19:06:28 <LoganCapaldo> or even a list :: [(Verb,Action)] if you don't have that many verbs
19:08:04 <eugman> I'll look into those. Thanks much.
19:09:04 <ac> is it a big deal to convert from a Word8 to Word16 and back?
19:09:22 <ac> does it actually take any time at all, or is it just changing the type?
19:09:29 <wagle_home> i generally start with a case statement, then move to more complicated things (tables, etc) when it starts getting unwieldy..
19:09:44 <LoganCapaldo> > let m = Data.Map.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x)] ; [verb, noun] = words "play banjo" in maybe (const "Unknown verb") (Data.Map.lookup verb m) $ noun
19:09:45 <lambdabot> Unbalanced parentheses
19:10:01 <LoganCapaldo> > let m = Data.Map.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "play banjo" in maybe (const "Unknown verb") (Data.Map.lookup verb m) $ noun
19:10:10 <lambdabot>   Not in scope: `Data.Map.lookup'
19:10:21 <LoganCapaldo> > M.lookup
19:10:22 <lambdabot>  Add a type signature
19:10:36 <ac> for example, does "map fromIntegral [1 :: Word16 .. 1000000] :: [Word8]" take any time at all?
19:10:46 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "play banjo" in maybe (const "Unknown verb") (M.lookup verb m) $ noun
19:10:46 <lambdabot>  Couldn't match expected type `Maybe a'
19:11:25 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "play banjo" in maybe (M.lookup verb m) (const "Unknown verb") $ noun
19:11:26 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
19:11:49 <LoganCapaldo> eh
19:11:56 <LoganCapaldo> I'm a terrible programmer
19:12:07 <ac> LoganCapaldo: not compared to me, I'm sure
19:12:34 <ac> anyway, I guess it doesn't matter if it takes time or not. It will make my code simpler to use Word16
19:12:58 <ac> as apposed to "Either [Word8] [Word16]"
19:13:12 <LoganCapaldo> @type maybe
19:13:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:13:24 <eugman> Hmm apparently the head function doesn't like a empty list
19:13:29 <LoganCapaldo> ooooo
19:13:37 <wy> so few people in #sml
19:13:40 <wagle_home> > head []
19:13:41 <lambdabot>  Exception: Prelude.head: empty list
19:14:03 <ac> eugman: listToMaybe
19:14:16 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "play banjo" in maybe  (const "Unknown verb") ($ noun) (M.lookup verb m)
19:14:17 <wagle_home> kids these days..  dont get to deal with "error in car, nil is not a pair" (somewhere in your program)
19:14:17 <lambdabot>  Couldn't match expected type `b -> [Char]'
19:14:22 <ac> > listToMabye [1,2,3]
19:14:22 <lambdabot>   Not in scope: `listToMabye'
19:14:25 <ac> > listToMaybe []
19:14:26 <lambdabot>  Nothing
19:14:33 <ac> > listToMaybe [1,2,3]
19:14:34 <lambdabot>  Just 1
19:14:40 <wy> off topic... Any idea how signatures are connected to structures in SML?
19:15:02 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "play banjo" in maybe "Unknown verb" ($ noun) (M.lookup verb m)
19:15:03 <lambdabot>  "you playbanjo"
19:15:20 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "eat banjo" in maybe "Unknown verb" ($ noun) (M.lookup verb m)
19:15:21 <lambdabot>  "you consume banjo"
19:15:29 <eugman> How do I save a log of this chat room using irssi?
19:15:36 <LoganCapaldo> > let m = M.fromList [("eat", (\x -> "you consume " ++ x)), ("play", (\x -> "you play" ++ x))] ; [verb, noun] = words "snarflle banjo" in maybe "Unknown verb" ($ noun) (M.lookup verb m)
19:15:37 <lambdabot>  "Unknown verb"
19:15:38 <ac> eugman: /log
19:16:01 <ac> eugman: er, sorry. /help set
19:16:18 <LoganCapaldo> huzzah, I win
19:17:48 <ac> eugman: er, first one was correct: /log -targets #haskell ~/haskell.log
19:18:21 <ac> eugman: /log OPEN -targets #haskell ~/haskell.log
19:18:37 <litb> i wonder whether there is a random num generator
19:18:45 <litb> and that is not IO t
19:18:56 <ac> eugman: there's also a link to realtime updated logs in the topic
19:20:40 <allbery_b> litb:  System.Random is pure.  (getting a random seed is in IO, if you want the seed to itself be random...)
19:23:33 <Notostraca> Anyone here interested in YHC core to JS?
19:24:54 <lispy> Notostraca: it's certainly interesting.
19:24:58 <lispy> Notostraca: but i don't use it.
19:25:12 <Notostraca> Yeah, it doesnt seem quite usable yet.
19:26:40 <Notostraca> But, there is a compiler written in OCAML that outputs to JS/Flash already, and I think Haskell maybe could be used as an alternate language
19:26:50 <Notostraca> www.haxe.org
19:27:28 <eugman> > listToMaybe []
19:27:29 <lambdabot>  Nothing
19:27:34 <eugman> hmmm
19:27:38 <Notostraca> It might be easier to port than to write from absolute scratch, right?
19:28:38 <bd_> except ocaml doesn't have lazy evaluation, the optimization strategies might be a good bit different :)
19:28:46 <bd_> or well, not as much use of lazy evaluation
19:28:56 <Notostraca> well, yeah.
19:29:33 <Twey> > maybeToList Nothing
19:29:39 <lambdabot>  []
19:30:03 <Twey> > listToMaybe ["foo", "bar"]
19:30:04 <lambdabot>  Just "foo"
19:30:32 <wagle_home> > listToMaybe ["", "bar"]
19:30:33 <lambdabot>  Just ""
19:30:59 <eugman> I keep getting a not in scope error when I try using it
19:31:00 <wagle_home> :t listToMaybe
19:31:00 <lambdabot> forall a. [a] -> Maybe a
19:31:15 <LoganCapaldo> @index listToMaybe
19:31:16 <lambdabot> Data.Maybe
19:31:24 <LoganCapaldo> import Data.Maybe
19:31:31 <wagle_home> @src listToMaybe
19:31:32 <lambdabot> listToMaybe []        =  Nothing
19:31:32 <lambdabot> listToMaybe (a:_)     =  Just a
19:31:48 <wagle_home> (apparently, @index does nothing)
19:32:10 <LoganCapaldo> um
19:32:19 <LoganCapaldo> it told you what module it's in
19:32:31 <LoganCapaldo> which is not nothing
19:32:35 <wagle_home> ok, i wuz told wrong
19:32:55 <eugman> Oh, whoops
19:35:14 <monochrom> @bots
19:35:14 <lambdabot> :)
19:35:16 <wagle_home> i thought it did something too..  used it, and got berated
19:35:36 <monochrom> hi
19:36:39 <LoganCapaldo> someone berated you for using index?
19:36:42 <LoganCapaldo> Seriously?
19:36:59 <wagle_home> yeah
19:37:42 <LoganCapaldo> bizzare
19:39:56 <brian`> @seen snrrruv
19:39:57 <lambdabot> I haven't seen snrrruv.
19:40:51 <wagle_home> @seen rot13 snrrruv
19:40:52 <lambdabot> I haven't seen rot13.
19:42:22 <LoganCapaldo> @@ seen rot13 snrruv
19:42:23 <lambdabot>  seen rot13 snrruv
19:42:30 <brian`> @seen snrrrub
19:42:30 <lambdabot> I haven't seen snrrrub.
19:51:14 <brian`> @seen Snrrrub
19:51:14 <lambdabot> I haven't seen Snrrrub.
19:54:41 <wagle_home> @seen anyone?
19:54:42 <lambdabot> I haven't seen anyone?.
20:02:31 <Cale> shapr, shapl, shapl'
20:02:52 <yondalf> @index foldl'
20:02:52 <lambdabot> Data.List
20:02:56 <yondalf> @index foldr
20:02:56 <lambdabot> Data.List, Prelude
20:03:04 <Cale> @version
20:03:04 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:03:04 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:03:30 <Cale> hehe, who brought this lambdabot back?
20:03:49 <LoganCapaldo> lol shapl'
20:03:57 <LoganCapaldo> he's a strict one
20:05:32 <monochrom> @remember Cale shapr, shapl, shapl'
20:05:32 <lambdabot> I will remember.
20:05:56 <Cale> dons: hehe, I brought mbot in because it's a complete lambdabot, only newer :)
20:06:39 <Cale> I wonder if I could install ghc-6.8/etc. into my local user account on code.h.o
20:08:12 <Cale> hmm, no disk quotas, that's nice :)
20:16:46 <jorik808> ghc-6.6: panic! (the 'impossible' happened)
20:16:56 <siti> :D
20:17:18 <jorik808> :p
20:18:02 <jorik808>   (GHC version 6.6 for i386-unknown-linux):
20:18:02 <jorik808>         missing linkable
20:19:59 <ac> jorik808: how's pico progressing?
20:19:59 <Cale> isModuleInterpreted :: Session -> ModSummary -> IO Bool
20:19:59 <Cale> isModuleInterpreted s mod_summary = withSession s $ \hsc_env ->
20:19:59 <Cale>   case lookupUFM (hsc_HPT hsc_env) (ms_mod_name mod_summary) of
20:19:59 <Cale> 	Nothing	      -> panic "missing linkable"
20:20:44 <Cale> jorik808: Try removing temporary files and then try again.
20:21:29 <jorik808> Cale, thx
20:21:35 <jorik808> ac, quite well :D
20:21:56 <Cale> jorik808: Not sure that'll work, but it's worth a shot :)
20:22:04 <jorik808> it worked
20:22:06 <jorik808> :)
20:23:38 <ac> is there a functional version of if?
20:23:55 <ac> (\t a b -> if t then a else b)
20:24:07 <jorik808> well
20:24:07 <wagle_home> > name it if'
20:24:11 <lambdabot>   Not in scope: `if''
20:24:44 <bd_> @hoogle Boolean -> a -> a -> a
20:24:45 <lambdabot> No matches, try a more general search
20:24:51 <jorik808> the syntax changed a LOT, but i'm not going to explain it all here ... i'd spam the entire channel
20:24:52 <bd_> @hoogle  a -> a -> Boolean -> a
20:24:53 <lambdabot> No matches, try a more general search
20:24:55 <bd_> hmm
20:25:13 <wagle_home> @hoogle Bool -> a -> a -> a
20:25:14 <lambdabot> No matches, try a more general search
20:25:19 <bd_> oh, doh
20:26:06 <wagle_home> i think..  ETOOMANYLANGUAGES
20:26:19 <bd_> @pl \t a b -> if t then a else b
20:26:20 <lambdabot> if'
20:26:23 <bd_> \o/
20:26:24 <bd_> :t if'
20:26:26 <lambdabot> Not in scope: `if''
20:26:31 <wagle_home> :t True
20:26:32 <lambdabot> Bool
20:26:33 <bd_> ... @pl cheats
20:26:43 <wagle_home> ah.. i wuz right!  w00t!
20:27:02 <bd_> wagle_home: ENOSPC on /dev/brain :)
20:27:59 <bd_> @pl should use some neat hack with monads (if' = \t a b -> (guard t >> Just a) `mplus` Just b  perhaps) rather than pulling in an if' that doesn't exist in the standard library
20:28:00 <lambdabot> (line 1, column 44):
20:28:00 <lambdabot> unexpected "="
20:28:00 <lambdabot> expecting variable, "(", operator or ")"
20:28:15 <bd_> @pl \t a b -> (guard t >> Just a) `mplus` Just b
20:28:15 <lambdabot> flip flip Just . (((.) . mplus) .) . (. Just) . (>>) . guard
20:29:01 <Cale> hmm...
20:30:35 <wagle_home> @pl \t a b -> if b then a else t
20:30:36 <lambdabot> flip (flip . flip if')
20:30:47 <Cale> Well, the binaries don't seem to work for code.haskell.org. Let's try compiling ghc-6.8.2 then :)
20:32:00 <ac> so @pl has if' prime hard coded
20:32:11 <ac> but it's not in the stdlibs
20:33:03 <Cale> ac: right
20:38:48 * Cale wonders if this might affect lambdabot's performance :)
20:39:03 <Cale> > product [1..10000]
20:39:05 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
20:39:12 <Cale> not much, anyway :)
20:40:07 <sarehu> if what might?
20:40:26 <Cale> Compiling ghc-6.8.2 on code.haskell.org
20:40:32 <sarehu> oh
20:40:48 <wagle_home> i once tried to compute a couple iterations of the 1/r chaotic function in scheme using rationals, and left it running on the university hardware for 2 weeks...  i got a "this is not a bill" for $74,000 of computing time a few weeks later
20:41:33 <Cale> heh
20:42:09 <sarehu> they must've used the wrong wordside for setrlimit
20:42:13 <sarehu> wordsize*
20:43:57 <Cale> My friend's java program which he submitted to the automatic marking system ended up having a bug in it which caused a stack overflow. Apparently the stack size was... rather large... moreover they actually had set all the output from student assignments to be printed. The graders got hundreds of pages of stack overflow printouts.
20:45:18 <sarehu> Once I printed a 30 page document for which I had made the .ps with latex, using lpr
20:45:25 <Cale> ahaha
20:45:27 <sarehu> It came out with the colors reversed.  Black background, white letters.
20:45:42 <Cale> oh, that's actually pretty surprising
20:45:44 <wagle_home> "watch those tree fall!"
20:45:59 <Cale> ah, .ps
20:46:07 <Cale> I don't know what the problem would be though.
20:46:18 <sarehu> yeah, it was pretty surprising... I still have the printout saved somewhere
20:46:21 <Cale> Printing pdf files by accident with lpr is funny though :)
20:46:28 <sarehu> what happens?
20:46:40 <Cale> You get gibberish.
20:46:50 <wagle_home> its really dramatic when the printer tries to print ps as plain text...  it ejects pages as fast as it can
20:46:56 <Cale> Usually, lots of jibberish.
20:47:32 <Cale> Of course, it probably depends on how lpr is set up.
20:47:43 <Cale> At least that's what happens at my former university.
20:47:45 <sarehu> jibberish?  I thought you got gibberish... are you making this story up? :)
20:48:09 <Cale> heh, I did manage to spell it differently there :)
20:49:03 <Cale> Who is in charge of code.haskell.org?
20:49:45 <wagle_home> my dictionary has gibberish, but not jibberish..  o.O
20:50:07 <wagle_home> i dunno..  i'd ask Cale..  he'd know for sure
20:51:16 <Cale> OED has some insane alternate spellings for it, but not that one.
20:51:33 <Cale> For example, it also lists "guibbridge"
20:52:16 <wagle_home> Firefox can't find the server at code.haskell.com.
20:52:22 <wagle_home> oops
20:53:34 <Cale> scook0 is logged in :)
20:55:23 <monochrom> guibberish? :)
20:56:51 <Cale> However, it does say in the etymology section GIBBER + ISH, and gibber lists jibber as an alternate spelling.
20:57:46 <OceanSpray> something is seriously weird.
20:57:50 <Cale> 1604 SHAKES. Ham. I. i. 116 (Qo. 2) The graues stood tenantlesse and the sheeted dead Did squeake and gibber in the Roman streets.
20:58:36 <OceanSpray> ((string ++ " ") ++) should yield a curried function that takes another string and concatenates str and that string with a space inbetween, no?
20:58:42 <wagle_home> my dictionary is oxford american dictionaries
20:59:04 <Cale> a1656 USSHER Ann. VI. (1658) 523 They all the while crying quarter in their barbarous gibbridge.
20:59:05 <dmwit> OceanSpray: Yes, that seems reasonable.
20:59:07 <sarehu> > let string == "hello" in ((string ++ " ") ++) "world!"
20:59:08 <lambdabot>  Parse error at "in" (column 23)
20:59:19 <sarehu> > let string = "hello" in ((string ++ " ") ++) "world!"
20:59:19 <dmwit> > let string = "hello" in ((string ++ " ") ++) "world!"
20:59:21 <lambdabot>  "hello world!"
20:59:21 <lambdabot>  "hello world!"
20:59:28 <OceanSpray> but...
21:00:12 <wagle_home> hmm..  "hyper-association"..  8)
21:00:35 <OceanSpray> hmm
21:00:54 <wagle_home> > let string = "hello" in (((((string) ++) " ") ++) "world!")
21:00:55 <lambdabot>  "hello world!"
21:01:23 <wagle_home> > let string = "hello" in string ++ " " ++ "world!"
21:01:24 <lambdabot>  "hello world!"
21:01:30 <sarehu> > ("abc" ++ "def" ++) "ghi"
21:01:30 <lambdabot>      The operator `++' [infixr 5] of a section
21:01:30 <lambdabot>         must have lower preced...
21:01:40 <sarehu> > (++ "def" ++ "ghi") "abc"
21:01:41 <lambdabot>  "abcdefghi"
21:01:50 <OceanSpray> oh.
21:01:51 <OceanSpray> OH.
21:02:56 <dmwit> > ((((((((()))))))))
21:02:57 <lambdabot>  ()
21:03:18 <sarehu> it would be neat if they had an   'infixassocl and 'infixassocr' that let sections work in the former case
21:03:38 <wagle_home> @pl (.(.(.(.(.(.(.(.(.).).).).).).).).)
21:03:38 <lambdabot> (line 1, column 2):
21:03:38 <lambdabot> unexpected "."
21:03:38 <lambdabot> expecting lambda abstraction or expression
21:03:55 <sarehu> and naturally, hundreds of other features to affect every edge case of the language
21:03:58 <dmwit> sarehu: I can't say I've come up against that problem very often.
21:04:16 <wagle_home> @pl (.(.(.(.(.(.(.(.(.)))))))))
21:04:17 <lambdabot> (. (. (. (. (. (. (. (. (.)))))))))
21:04:58 <ac> wee, encoding with adam7 interlacing now supported
21:06:05 <ac> now, how do I write the decoder for adam7?
21:06:07 <hpaste>  ac pasted "Interlace adam7" at http://hpaste.org/5549
21:06:51 <bd_> @unpl (.(.(.(.(.(.(.(.(.)))))))))
21:06:55 <lambdabot> (\ k n -> k (\ q -> n (\ t -> q (\ w -> t (\ z -> w (\ ac -> z (\ af -> ac (\ ai -> af (\ b c -> ai (b c))))))))))
21:07:28 <wagle_home> @pl (\ k n -> k (\ q -> n (\ t -> q (\ w -> t (\ z -> w (\ ac -> z (\ af -> ac (\ ai -> af (\ b c -> ai (b c))))))))))
21:07:29 <lambdabot> (. (. (. (. (. (. (. (. (.)))))))))
21:10:27 <ac> I think I need a generalization of intersperse
21:10:40 <sarehu> that does what?
21:11:39 <ac> Int -> [a] -> [a] -> [a], that puts an element of the first list in to the second list at every nth element of the second list, or something like that
21:12:47 <ac> not quite a generalization of intersperse, but close enough
21:13:54 <ac> if I do it right, maybe I can have the exact same calls to it as I do to select in the encoder
21:13:55 <sarehu> if you have a handy function that groups every N elements of a list together, that is simple
21:14:09 <sarehu> the 'group every N elements together' function I have found useful
21:14:23 <ac> that's what select does
21:14:25 <ac> sort of
21:14:27 <sarehu> :t select
21:14:28 <lambdabot> Not in scope: `select'
21:14:31 <sarehu> selecT?
21:14:33 <sarehu> select?
21:14:38 <ac> (in the encode function I just hpasted)
21:14:52 <wagle_home> :t split
21:14:53 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
21:15:02 <wagle_home> o.O
21:15:19 * wagle_home was expecting a couple things, but that..  that
21:15:43 <sarehu> it makes two new random number generators... and is very hard to implement correctly... Or something.
21:16:31 <wagle_home> :t take
21:16:31 <lambdabot> forall a. Int -> [a] -> [a]
21:17:04 <wagle_home> @hoogle forall a. Int -> [a] -> ([a], [a])
21:17:05 <lambdabot> Did you mean: Forall A. Int -> [a] -> ([a], [a])
21:17:06 <bd_> @hoogle Int -> [a] -> [[a]]
21:17:06 <lambdabot> No matches, try a more general search
21:17:25 <wagle_home> @hoogle Forall a. Int -> [a] -> ([a], [a])
21:17:26 <lambdabot> Did you mean: Forall A. Int -> [a] -> ([a], [a])
21:17:37 <wagle_home> @hoogle Int -> [a] -> ([a], [a])
21:17:38 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
21:17:38 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
21:17:47 <wagle_home> ahh..  there
21:18:04 <wagle_home> > splitAt 3 "abcdef"
21:18:06 <lambdabot>  ("abc","def")
21:20:08 <wagle_home> but i coulda sworn bd_'s function was out there
21:21:46 <tennin> is it that uncurry . ((f x id) -> g) = (f -> (g .)) . curry ?
21:22:33 <wagle_home> @pl  uncurry . ((f x id) -> g)
21:22:34 <lambdabot> (line 1, column 21):
21:22:34 <lambdabot> unexpected ">"
21:22:34 <lambdabot> expecting variable, "(", operator or ")"
21:22:41 <sarehu> > let splitEvery n = unfoldr (\x -> listToMaybe x >> splitAt n x) in splitEvery 3 "abcdefghijklmnopqrstuvwxyz"
21:22:41 <lambdabot>  Couldn't match expected type `Maybe (a, [a1])'
21:23:11 <wagle_home> looks familier, but its been several years
21:23:16 <ac> cool...
21:23:42 <tennin> sorry, the x isn't really Haskell
21:24:08 <sarehu> > let splitEvery n = unfoldr (\x -> listToMaybe x >> Just (splitAt n x)) in splitEvery 3 "abcdefghijklmnopqrstuvwxyz"
21:24:09 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
21:24:11 <ac> takeWhile (not . null) $ chunk 10 [0..100] where chunk n l = let (x,y) = splitAt n l in x : (chunk n y)
21:24:14 <ac> > takeWhile (not . null) $ chunk 10 [0..100] where chunk n l = let (x,y) = splitAt n l in x : (chunk n y)
21:24:14 <lambdabot>  Parse error at "where" (column 44)
21:24:16 <wagle_home> yeah, i wasnt really paying attention until the error message smacked me in the face
21:24:38 <tennin> neither is the -> for that matter.  i'm still puzzling over Meijer's bananas paper.
21:24:40 <wagle_home> looks like some CCC defn
21:24:45 <ac> let chunk n l = let (x,y) = splitAt n l in x : (chunk n y) in takeWhile (not . null) $ chunk 10 [0..100]
21:24:48 <ac> > let chunk n l = let (x,y) = splitAt n l in x : (chunk n y) in takeWhile (not . null) $ chunk 10 [0..100]
21:24:49 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19],[20,21,22,23,24,25,26...
21:24:55 <wagle_home> errr. lemma
21:24:59 <ac> there. A shorter definition of chunk!
21:26:30 <tennin> in Haskell it would be uncurry . (\h -> g . h . (\(x,y) -> (f x, y))) = (\h -> (g .) . h . f) . curry , I think
21:27:43 <tennin> ...I still don't really understand.  probably just letting it go for now would be the best approach
21:29:02 <wagle_home> yeah, well, my brain thinks cartegory theory is terribly cool, but refuses to remember any of it..  gonna try again Real Soon Now, but its been several years, so I aint gonna be any use
21:30:00 <wagle_home> @google Meijer bananas
21:30:01 <lambdabot> No Result Found.
21:30:17 <wagle_home> what?  which google does it use?
21:30:35 <tennin> in my experience there are some things you have to learn and forget N times, and the N+1th time you learn it, you won't forget
21:30:52 <tennin> and each time you get a little deeper although it may not seem like it
21:30:58 <scook0> @google lenses bananas
21:31:00 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
21:31:00 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
21:31:20 <tennin> this is the third go-round for me and basic category theory
21:32:00 <tennin> the Pierce intro for CSers book is only 80 pages!
21:32:14 <wagle_home> yeah..  the first hit i got in the real google was for real banana (fruit)
21:32:47 <wagle_home> yeah.. i did that one for a class in category theory..  i got an A, but remember not much
21:34:02 <wagle_home> right now, i have barr and wells third edition on my short list
21:34:38 <monochrom> I recently read Pierce's. It's pretty pleasant, mainly because it's short. :)
21:34:40 <ac> so nobody wants to write the inverse of interladeAdam7 for me?
21:35:23 <sarehu> sorry, what is that?
21:35:31 <ac> http://hpaste.org/5549
21:37:18 <sarehu> Scary.  Nope ^_^
21:37:22 <ac> heh
21:38:40 <shapr> @yow !
21:38:41 <lambdabot> Uh-oh!!  I'm having TOO MUCH FUN!!
21:39:23 <Cale> @quote shapl
21:39:24 <lambdabot> Cale says: shapr, shapl, shapl'
21:40:38 <wagle_home> shouldnt there be a shap for every type of quark?
21:42:37 <monochrom> As you can see, there should be three shaps for every type of quark. :)
21:42:44 <monochrom> Or just use polymorphism. :)
21:44:04 <wagle_home> should you know which one you are using without constructing it?
21:45:08 <sarehu> don't construct it, that will change its... location... or whatever would be physically appropriate for the joke </notaquantumphysicist>
21:46:41 <wagle_home> was actually wondering if it was one of Schroedinger's catamorphisms
21:47:03 <sarehu> I am in ur funkshon... maybe.
21:47:54 <OceanSpray> @hpaste
21:47:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:48:04 <sarehu> computer science timeline....    late 19th century..Babbage.. mid 20th century.. Turing...
21:48:07 <wagle_home> i suppose its already been done..  you look at a suspension, and its either a value or its bottom
21:48:10 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/5550
21:48:19 <wagle_home> dont know which until you look
21:50:30 <sarehu> In the mid 21st century.. it's discovered the Universe is built out of lambda calculus, and all particles are constructed out of a single particle, the 'functino'.  A few hours later, somebody programs teleportation and adds it to lambdabot.
21:52:11 <Twey> Hahahaha
21:52:13 <Twey> <3
21:54:24 <sarehu> OceanSpray: why are you doing it that way?  (Why are you tying your program to stdin?  Why not use a monad transformer parser combinator library?)
21:54:47 <OceanSpray> sarehu, what do you mean?
21:55:13 <sarehu> reading a line, trying to parse, reading another line, trying to parse...
21:55:14 <OceanSpray> tying my program to stdin?
21:55:18 <OceanSpray> yeah
21:55:20 <OceanSpray> what about it?
21:55:29 <OceanSpray> isn't that what a repl is supposed to do?
21:55:36 <sarehu> oh, never mind
21:56:15 <sarehu> but you'll never recognize the parse error that way.  (Also, why did you paste that?)
21:56:24 <OceanSpray> I have a problem with it.
21:56:29 <OceanSpray> it works fine as is,
21:56:50 <OceanSpray> but if I replace the (str ++) with ((str ++ " ") ++), all hell breaks lose.
21:57:27 <sarehu> what... ok.
21:57:59 <sarehu> what sort of hell?
21:58:38 <wagle_home> actually, it will also run forever on an input of an infinite series of ')'s.. </nitpick>
21:59:07 <sarehu> yah.. any parse error turns into a never ending parse error
21:59:48 <sarehu> You need to distinguish between end-of-string parse errors and other parse errors
21:59:52 <wagle_home> yeah,, the extra ) is a standard pitfall in lisp parsers though
22:00:49 <wagle_home> :t (s ++)
22:00:52 <lambdabot> Not in scope: `s'
22:01:00 <wagle_home> :t (String ++)
22:01:01 <lambdabot> Not in scope: data constructor `String'
22:01:07 <ac> is there a simple way to write an elems function that would produce a left to right, top to bottom order for an (Int,Int) array?
22:01:13 <wagle_home> :t ("foo" ++)
22:01:15 <lambdabot> [Char] -> [Char]
22:01:18 <sarehu> > fix (("reading a line, " ++ "trying to parse, ") ++)
22:01:20 <lambdabot>  "reading a line, trying to parse, reading a line, trying to parse, reading a...
22:01:32 <wagle_home> :t (("foo" ++ " ") ++)
22:01:34 <lambdabot> [Char] -> [Char]
22:01:34 <OceanSpray> :t fix
22:01:35 <lambdabot> forall a. (a -> a) -> a
22:02:07 <ac> "elems . ixmap (bounds a) (\(x,y) -> (y,x))" doesn't work for non-NxN arrays
22:03:11 <sarehu> you need to flip the bounds, no?
22:04:25 <ac> sarehu: I think the first argument of ixmap bounds which indexes are mapped
22:04:38 <ac> :t ixmap
22:04:39 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
22:04:47 <ac> see, it's (i, i) not (j, j)
22:06:00 <ac> actually, now that type signature is confusing me... shouldn't the second argument be (j -> i)?
22:06:41 <sarehu> no, it takes each i in the range of type (i,i), and maps it to a j, lookup up that value in the array
22:06:44 <wagle_home> OceanSpray, what hell breaks loose?
22:07:13 <OceanSpray> never mind everything.
22:07:18 <OceanSpray> I see the problem.
22:07:19 <ac> @hoogle (a, b) -> (b, a)
22:07:19 <lambdabot> No matches, try a more general search
22:07:30 <sarehu> > (snd &&& fst) (2,3)
22:07:32 <lambdabot>  (3,2)
22:07:59 <ac> (\(x,y) -> (y,x)) (2,3)
22:08:06 <ac> > (\(x,y) -> (y,x)) (2,3)
22:08:08 <lambdabot>  (3,2)
22:08:11 <wagle_home> @hoogle a -> a
22:08:12 <lambdabot> Prelude.id :: a -> a
22:08:12 <lambdabot> Data.Function.id :: a -> a
22:08:12 <lambdabot> GHC.Exts.breakpoint :: a -> a
22:09:03 <wagle_home> @pl  (snd &&& fst) (2,3)
22:09:04 <lambdabot> (snd &&& fst) (2, 3)
22:09:12 <wagle_home> @pl  (snd &&& fst)
22:09:13 <lambdabot> snd &&& fst
22:09:21 <Cale> @version
22:09:21 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
22:09:21 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:09:27 <wagle_home> @pl  (\(x,y) -> (y,x))
22:09:28 <lambdabot> uncurry (flip (,))
22:09:31 <sarehu> (f &&& g) x = (f x, g x)
22:09:33 <Cale> :t GHC.Exts.breakpoint
22:09:34 <lambdabot> forall a. a -> a
22:10:43 <Cale> huh
22:10:49 <ac> @index (&&&)
22:10:49 <lambdabot> Control.Arrow
22:11:28 <wagle_home> [1, GHC.Exts.breakpoint 2, 3]
22:11:36 <wagle_home> > [1, GHC.Exts.breakpoint 2, 3]
22:11:37 <lambdabot>   Not in scope: `GHC.Exts.breakpoint'
22:12:10 <Cale> That has seemingly no effect in ghci 6.8.2 even under :trace
22:12:24 <sarehu> ac: functions (->) are of the typeclass Arrow, the same way (r ->) is of the typeclass Monad, giving you all sorts of funny obscure combinators!
22:12:35 <Cale> breakpoint :: a -> a
22:12:35 <Cale> breakpoint r = r
22:12:35 <Cale> breakpointCond :: Bool -> a -> a
22:12:35 <Cale> breakpointCond _ r = r
22:12:38 <Cale> odd.
22:12:43 <ac> sarehu: simply flipping bounds does not work :-P
22:13:14 <sarehu> > array (1,2) [(1,'a'), (2,'b')]
22:13:15 <lambdabot>  array (1,2) [(1,'a'),(2,'b')]
22:13:24 <sarehu> > listArray (1,2) "ab"
22:13:25 <lambdabot>  array (1,2) [(1,'a'),(2,'b')]
22:13:47 <sarehu> > listArray ((1,1),(3.3)) [1..]
22:13:47 <lambdabot>   add an instance declaration for (Fractional (t, t1))
22:13:47 <lambdabot>     In the expression:...
22:13:54 <sarehu> > listArray ((1,1),(3,3)) [1..]
22:13:55 <lambdabot>  array ((1,1),(3,3)) [((1,1),1),((1,2),2),((1,3),3),((2,1),4),((2,2),5),((2,3...
22:14:21 <sarehu> > listArray ((1,1),(2,3)) [1..]
22:14:21 <lambdabot>  array ((1,1),(2,3)) [((1,1),1),((1,2),2),((1,3),3),((2,1),4),((2,2),5),((2,3...
22:14:23 <Cale> Yay, ghc build completed on code.haskell.org
22:14:37 <sarehu> sorry for mucking up the chat, and also, yay.
22:14:51 <Cale> cgibbard@haskell:~$ ghc --version
22:14:51 <Cale> The Glorious Glasgow Haskell Compilation System, version 6.8.2
22:15:11 <Cale> So, now to get cabal-install and dependencies for lambdabot
22:17:05 <sarehu> ac:
22:17:18 <sarehu> > let xs = listArray ((1,1),(2,3)) [1..] in elems $ ixmap ((1,1),(3,2)) (snd &&& fst) xs
22:17:19 <lambdabot>  [1,4,2,5,3,6]
22:18:58 <sarehu> > elems . (\arr -> ixmap (uncurry (join (snd &&& fst)) (bounds arr)) (snd &&& fst) arr) (listArray ((1,1),(2,3)) [1..]
22:18:59 <lambdabot> Unbalanced parentheses
22:19:12 <sarehu> > elems . (\arr -> ixmap (uncurry (join (snd &&& fst)) (bounds arr)) (snd &&& fst) arr) $ (listArray ((1,1),(2,3)) [1..]
22:19:12 <lambdabot> Unbalanced parentheses
22:19:21 <sarehu> > elems . (\arr -> ixmap (uncurry (join (snd &&& fst)) (bounds arr))
22:19:21 <sarehu> 	 (snd &&& fst) arr) $ listArray ((1,1),(2,3)) [1..]
22:19:21 <lambdabot> Unbalanced parentheses
22:19:23 <sarehu> sigh.
22:19:30 <sarehu> > elems . (\arr -> ixmap (uncurry (join (snd &&& fst)) (bounds arr)) (snd &&& fst) arr) $ listArray ((1,1),(2,3)) [1..]
22:19:31 <lambdabot>  Couldn't match expected type `(a, b1) -> b -> c'
22:19:37 <sarehu> sigh... screw it, you figure it out :P
22:19:52 <ac> transpose2DA a = ixmap ((\(z,(i,j)) -> (z,(j,i))) $ bounds a) (\(x,y) -> (y,x)) a
22:20:40 <ac> (I _think_ that works... haven't actually thought about it)
22:21:22 <ac> yep, it works
22:21:36 <ac> I still don't understand the type signature to ixmap. It looks backwards to me
22:22:36 <dolio> @type ixmap
22:22:36 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
22:23:04 <ac> oh I get it
22:23:12 <dolio> The (i -> j) in ixmap tells you, for a given index i in the new array, where to fetch it from the old array.
22:23:13 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
22:23:13 <scook0> it seems to be more of a re-indexing than a map
22:23:14 <ac> it builds the return array from the array passed to it
22:23:50 <ac> now everything makes sense :-P
22:27:57 <Cale> cabal: /tmp/TMPhappy-1.17TMP/happy-1.17/InstallShield/File Groups/Program Executable Files.fgl: openFile: resource busy (file is locked)
22:28:11 <Cale> All I can say is... wtf?
22:29:30 <sarehu> well, I get CABAL complaining about a missing license file when compiling lambdabot, so there.
22:29:45 <Cale> touch LICENSE
22:29:56 <sarehu> does that make a file?
22:30:00 <Cale> yeah
22:30:03 <Cale> I just forgot to fix that problem.
22:30:07 <sarehu> awesome!
22:30:24 <Cale> (Well, I fixed it, but I forgot --look-for-adds when darcs recording.
22:30:25 <Cale> )
22:30:30 <sarehu> I was always opening it in a buffer, typing a character, pressing backspace, and saving :P
22:30:44 <Cale> Huh, that should have done it.
22:30:51 <sarehu> It did...
22:30:57 <Cale> ah, I see
22:31:28 <OceanSpray> well, I fixed it.
22:31:39 <OceanSpray> turned out that my parser just wasn't parsing leading whitespace.
22:34:07 <wagle_home> oh yeah, that trick
22:34:11 <Cale> hmm, cabal wizards out there: how do I tell cabal I consistently want to use the ghc installation in /home/cale/local/ rather than installing things to /home/.ghc ?
22:34:26 <Cale> (Specifically, cabal-install)
22:34:26 <OceanSpray> :t index
22:34:27 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
22:34:32 <OceanSpray> :t indexOf
22:34:33 <lambdabot> Not in scope: `indexOf'
22:38:00 <oerjan> :t findIndex
22:38:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
22:39:31 <wagle_home> findIndex (==3000000) [1..]
22:39:45 <Cale> Oh well, I'll just keep typing --prefix
22:39:50 <wagle_home> > findIndex (==3000000) [1..]
22:39:52 <lambdabot>  Just 2999999
22:40:12 <wagle_home> > findIndex (==3000000000) [1..]
22:40:18 <lambdabot> Terminated
22:40:53 <OceanSpray> what's an easy way to analyze parsec errors?
22:40:59 <oerjan> :t elemIndex
22:41:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
22:41:26 <shachaf> Cale: You mean .cabal?
22:41:38 <wagle_home> one day i will overflow Int in small enough time that lambdabot wont abort me!  bwahahaha
22:41:47 <Cale> shachaf: yeah, is there an appropriate option to specify a prefix there?
22:42:02 <Cale> (the obvious, perhaps? I don't know where that file is documented)
22:42:39 <wagle_home> @index fact
22:42:39 <lambdabot> bzzt
22:42:43 <wagle_home> @index factorial
22:42:43 <lambdabot> bzzt
22:43:00 <Cin> > fac 5
22:43:01 <lambdabot>   Not in scope: `fac'
22:43:02 <Cin> dang
22:43:10 <wagle_home> @index fac
22:43:11 <lambdabot> bzzt
22:43:41 <shachaf> Cale: It looks like it's hard-wired?
22:43:48 * shachaf might be wrong, though.
22:44:14 <Cale> Well, I can put --prefix=/home/cgibbard/local when I run cabal.
22:44:18 <wagle_home> Cale, is there a ./configure script?
22:44:39 <wagle_home> ok..  you know about --prefix then
22:44:44 <shachaf> Oh, hmm.
22:44:52 <Cale> It would just be nice to be able to put that in a file somewhere so that when running the cabal program, it's automatically specified.
22:45:03 <oerjan> OceanSpray: errorPos, errorMessages and errorIsUnknown functions
22:45:05 <sarehu> @let factorial = product . enumFromTo 1
22:45:08 <lambdabot> Defined.
22:45:15 <oerjan> it's all that is exported i think
22:45:25 <wagle_home> no place else is type correct..  8-p
22:46:40 <shachaf> Cale: It should be in ~/.cabal/config.
22:46:46 <shachaf> Cale: But it doesn't look like it is.
22:47:00 * wagle_home hasnt gotten over being taunted for having written scheme in his youth
22:47:15 <oerjan> (Text.ParserCombinators.Parsec.Error)
22:48:15 <sarehu> OceanSpray: using <?> all over the place can be helpful
22:49:08 * Cale steals lambdabot's passwd from dons' user directory...
22:49:15 <Cale> My evil plan is coming to fruition!
22:49:32 <oerjan> o_O
22:49:34 <wagle_home> more bananas?
22:50:32 * wagle_home envisions a army of lambdabots
22:50:33 <shachaf> Cale: Replacing lambdabot with mbot?
22:50:51 <Cale> shachaf: replacing lambdabot with lambdabot.
22:51:04 <wagle_home> ... maybe a swarm, all flying in a flock
22:51:05 <sarehu> how impure
22:51:50 <OceanSpray> what's <?>
22:51:58 <OceanSpray> :t (<?>)
22:51:58 <lambdabot> Not in scope: `<?>'
22:53:37 <wagle_home> no mutation needed..  just get the old lambabot to Terminated all references to lamdabot, and let it be garbage collected
22:53:54 <wagle_home> @index <?>
22:53:55 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
22:54:16 <oerjan> :t (Text.ParserCombinators.Parsec.<?>)
22:54:17 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> String -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
22:54:35 <OceanSpray> I still have no idea what it does.
22:55:20 <oerjan> OceanSpray: it gives a production a specific name
22:55:27 <Twey> wagle_home: Scheme!  <3
22:55:41 <oerjan> so that name is used for parse errors
22:55:47 <OceanSpray> huh.
22:56:44 <oerjan> OceanSpray: have you read the Parsec manual?  it contains many tips.
22:56:44 <wagle_home> Twey, whenever I encounter a new language. I write a Scheme Interpreter in it instead of Hello World..
22:57:01 <OceanSpray> oerjan, I only read the parts I needed.
22:57:19 <OceanSpray> that is to say, I must have skipped at least 80% of it.
22:57:32 <OceanSpray> This is definitely bad.
22:57:34 <Twey> wagle_home, there's even http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html for Haskell
22:57:35 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
22:57:40 <Twey> OceanSpray: Haha
22:58:52 <wagle_home> 48 hours?!?  eh, one sitting
23:00:04 <OceanSpray> I think it's alluding to Scheme 48
23:00:08 <lament> wagle_home: how many languages have you done this in?
23:00:18 <siti> :( @ segfaults
23:00:26 <OceanSpray> Scheme interpreter in Brainfuck?
23:00:54 <oerjan> siti: huh?
23:01:21 <lament> OceanSpray: certainly doable
23:01:23 <wagle_home> Scheme, Fortran, Pascal, Modula2, Java, Haskell, Perl, Tcl, ...
23:01:29 <OceanSpray> of course doable.
23:01:34 <OceanSpray> but is it... doable?
23:01:37 <siti> I've managed to get ghc resulting binaries to segfault
23:01:42 <Twey> You did a Scheme interpreter as your first program in Scheme?
23:01:49 <Twey> Impressive :-P
23:01:58 <lament> OceanSpray: there's a basic that compiles to brainfuck, and a c compiler in progress...
23:02:01 <siti> and I don't think it's the bindings I am using :(
23:02:15 <dolio> Strictly speaking, that isn't that hard.
23:02:51 <dolio> I'm pretty sure the main homeworks in my programming languages class for the Scheme section were to write a mini-scheme.
23:03:11 <lament> eval
23:03:15 <lament> do i get an A+?
23:03:29 <OceanSpray> no, you've got to write your own eval.
23:03:30 <wagle_home> yeah..  thats the Intro to Programming Languages Course at Indiana Universirty..  write scheme in scheme, then transform that interpreter step by step to fortran
23:03:34 <Twey> dolio: Only pretty sure?  :-P
23:03:46 <OceanSpray> as per SICP.
23:03:53 <wagle_home> EoPL
23:03:58 <OceanSpray> another text that I skipped 80% of.
23:04:05 <sarehu> I want   _ {field=xs}   patterns
23:04:18 <dolio> Well, it's been a while. I don't remember if we had to write any programs in it before that.
23:04:41 <wagle_home> (Essentials of Programming Languages by Friedman, Wand, and Haynes)
23:04:50 <Twey> sarehu: Why?
23:05:07 <wagle_home> i liked EoPL better than SICP
23:05:29 <sarehu> So you can patternmatch over Gtk.Event constructors that have an eventTime field
23:05:45 <Cale> hmm...
23:07:04 <wagle_home> i think i wrote one of the worlds first lazy functional language (lisp) interpreters..
23:07:24 <sarehu> what?
23:08:56 <OceanSpray> wagle_home, you wrote a lazy lisp?
23:09:02 <wagle_home> yeah
23:09:10 <shachaf> Cale: user-prefix: "/home/cgibbard/local"
23:09:18 <wagle_home> thats where the idea started
23:09:18 <shachaf> Cale: In ~/.cabal/config.
23:09:23 <Cale> shachaf: thanks, good to know :)
23:09:23 * shachaf feels silly.
23:10:14 <Cale> now, if I can just figure out why lambdabot won't connect...
23:10:54 <wagle_home> "there can be only one"..  the first keeps chopping the first element off the second
23:13:51 <OceanSpray> I'm wondering whether my interpreter is lazy, simply because it's written in Haskell.
23:13:54 <wagle_home> does it give error messages?
23:14:45 <oerjan> Cale: lambdabot is not logged out
23:14:56 <wagle_home> oh yeah, that too
23:14:58 <Cale> oerjan: well, I did tell it to use another nick
23:15:49 <oerjan> wild guess - is it being confused by being given lambdabot's password?
23:16:57 <Cale> Initialising plugins ......................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
23:16:58 <Cale> .................. done.
23:16:58 <Cale> Plugin `irc' failed with: thread killed
23:16:58 <Cale> Exception: all servers detached
23:17:20 <oerjan> "bogus server"?
23:17:38 <Cale> Yeah, I'm not sure.
23:17:56 <Cale> irc-connect freenode chat.freenode.net 6667 lbotnew Lambda_Robots:_100%_Loyal
23:18:06 <Cale> that's the connect line I'm using
23:18:25 <Cale> and I've temporarily removed the rc passwd.rc line
23:20:47 <Cale> oh, it appears that first message is normal
23:20:51 <Cale> (mbot does that too)
23:20:53 <sarehu> is chat.freenode.net different from irc.freenode.net?
23:21:06 <Cale> It doesn't seem to be
23:21:22 <Cale> The "Plugin `irc' failed with: thread killed"
23:21:23 <sarehu> ok.  I get the 'bogus server' thing too.. that is normal
23:21:26 <Cale> is what bothers me
23:21:56 <sarehu> what happens if you try to connect to an IRC server where another user already has lambdabot's nick?
23:22:08 <wagle_home> well, look at the source, and see how it comes up with "bogus" string
23:22:09 <sarehu> oh, lbotnew.. never mind
23:23:34 <wagle_home> coolio
23:23:52 <sarehu> Ok, I am getting no 'irc failed with thread killed' message
23:24:05 <sarehu> I get:
23:24:06 <sarehu> Plugin `offlinerc' failed with: passwd.rc: openFile: does not exist (No such file or directory)
23:24:09 <shachaf> Cale: Is this just a normal lambdabot?
23:24:15 <Cale> shachaf: yeah
23:24:21 <shachaf> Cale: mbot is working, though?
23:24:30 <shachaf> sarehu: Comment that part out. :-)
23:24:31 <Cale> sarehu: yeah, on a totally different machine
23:24:32 <wagle_home> one completely wild-assed-guess is that bots have to jump through some hurdles on freenode
23:24:38 <shachaf> sarehu: (Or make a passwd.rc.)
23:24:52 <mrd> not that i've noticed
23:24:56 <sarehu> shachaf: I don't mind, I don't look at the messages :P
23:25:05 <Cale> though, strangely, mbot has started printing lots of this message to the console:
23:25:09 <Cale> Main: caught (and ignoring) too few bytes. Failed reading at byte position 8
23:25:23 <Cale> (but I haven't really done anything with it)
23:26:46 <shachaf> Cale: A fairly normal fresh lambdabot worked for me not long ago.
23:26:56 <shachaf> Cale: Is there anything odd in `darcs w`?
23:27:41 <Cale> No, just the changes that I made myself to the configuration and a change to ./State/system
23:27:45 <Cin> awesome. a use for `intersect'
23:28:22 * wagle_home has venn diagrams on his whiteboard...
23:29:05 <Cin> hehe
23:29:39 * wagle_home looks at Cin with raised eyebrows
23:30:09 <shachaf> Cale: Do you know what the server is actually saying to it?
23:30:36 <Cale> no, I don't know.
23:33:12 <Cin> wagle_home: i'm writing some code for lambda expressions. my freeVars function (free variables of an expression) applied to (λx.(λy.(λz.x y z))) outputs [], and for (λx.(λy.(λz.x y k))) outputs ["k"]. to get the free variables of an abstraction with a sub-abstraction, it gets the intersection of freeVars applied to the body of the sub-abstraction with its parameter as the parent abstraction and then the sub one. e.g. freeVars of λx.λy.z is freeVars 
23:34:02 <Cin> wagle_home: my spacebar is proper broken -_-
23:34:05 <sarehu> is that supposed to be UTF-8?
23:34:18 <Cin> sarehu: oh, sorry. i keep forgetting about you guys :P
23:34:24 <Cin> sarehu: λ == lambda
23:34:41 <sarehu> I'm getting I-circumflex and right french quote when I usually see a box
23:34:51 <sarehu> except in <Cin> sarehu: λ == lambda
23:35:01 <shachaf> Cin: That last λ works for me.
23:35:04 <sarehu>  (Î»x.(Î»y.(Î»z.x y k))) <- are these lambdas to you Cin?
23:35:05 <Cin> odd
23:35:08 <Cin> yup
23:35:27 <Cin> well, not now that you have pasted them with your encoding, but my own messages displayed correctly
23:35:37 <oerjan> Cin: i think your message got cut off after "is freeVars"
23:35:52 <Cin> oerjan: oh
23:35:52 <shachaf> Hmm.
23:36:05 <shachaf> Looking at the logs, I see your lambdas properly.
23:36:25 <Cin> well. freeVars of \x.y.z is freeVars of \x.z and \y.z, intersected
23:37:21 <wagle_home> (Cin's lambdas worked for me (SuSE 10.1 on a x86_64)
23:37:23 <Cale> sarehu: Is your IRC client set up for UTF-8?
23:37:27 <sarehu> Cale: yes
23:37:36 <Cale> λ -- how about that one?
23:37:43 <wagle_home> worked for me
23:37:45 <shachaf> Cale: That one is fine for me.
23:37:47 <Cale> huh
23:37:49 <sarehu> it's a single box to me... (the font is not set up but the client is)
23:37:53 <Cin> hrm. i should write an instance of Read so i can just write λx.x instead of (Ab "x" (V "x")) :P
23:38:02 <shachaf> Cale: All except the ones in Cin's first message.
23:38:16 <wagle_home> i did install all the languages i could, though
23:38:29 <Cin> perhaps it pasted funny from emacs
23:38:51 <shachaf> Cin: I see the lambdas properly in the logs, though.
23:39:09 <wagle_home> sarehu's message was ^'ed I's
23:39:24 <Cin> (λx.(λy.(λz.x y k)))  <- are these displayed as nonsense?
23:39:39 <wagle_home> worked for me
23:39:40 <shachaf> Cin: That's fine.
23:39:47 <Cin> well i have no idea then, heh
23:39:57 <Cin> perhaps because it was cut off the encoding was barfed, but i don't understand UTF-8
23:40:23 <Cin> is that likely?
23:40:35 <wagle_home> only place utf-8 can get cut off is mid character
23:41:10 <sarehu> That could be it
23:41:16 <wagle_home> i think irc (or its clients) will cut off long messages after some number of chars/bytes
23:41:17 <Cin> it may have been cut off mid-λ, in my last sentence
23:41:24 <Cin> but would that screw up the rest of the message?
23:41:42 <wagle_home> your message was fine until it got cut off
23:41:50 <Cin> indeed, XChat does that, wagle. i don't know if irssi attempts to
23:41:51 <sarehu> is lambda really four bytes of UTF-8?
23:41:59 <wagle_home> i'
23:42:14 <wagle_home> i'm using xchat 2.6.1
23:43:15 <wagle_home> it even understands and can transmit-such-that-others-see-it-correctly arabic
23:43:55 <wagle_home> ت
23:44:06 <Cin> too bad ghci doesn't support reading in UTF-8 strings
23:44:26 <shachaf> wagle_home: Is Arabic much harder than other languages?
23:44:41 <Cin> i could write freeVars . read $ "(λx.(λy.(λz.x y k)))"  -- instead of -- freeVars (Ab "x" (Ab "y" (Ab "z" (Ap (Ap (V "x") (V "y")) (V "k")))))
23:44:52 <Cale> cgibbard@haskell:~/darcs/lambdabot$ telnet chat.freenode.net 6667
23:44:52 <Cale> Trying 216.165.191.52...
23:44:58 <Cale> this could be the problem...
23:45:10 <shachaf> Cale: Try port 7000?
23:45:21 <Cin> i connect to irc.freenode.net >_>
23:45:35 <Cale> aha
23:45:40 <Cale> shachaf: that worked :)
23:45:43 <wagle_home> dunno, never took it..  its just the first charset my character inputter showed me...  but i have two friends that took arabic in college and liked it
23:45:51 * shachaf had this problem before...
23:45:58 <shachaf> Port 6667 just didn't work.
23:46:07 <shachaf> 7000 did, though.
23:46:13 <Cin> wagle: i can see that arabic character, btw. i'm on ubuntu, in gnome-terminal, in screen, in irssi :P
23:46:28 <wagle_home> looks like a smiley?
23:46:34 <Cin> wagle: yeah ":)"
23:46:39 <Cale> oh, this is fun...
23:46:46 <Twey> I'm on Gentoo, in Tilda, in irssi, and I see it too :-P
23:46:51 * dolio sees it, too. The line is even right-justified.
23:46:51 <Cale> > 1 + 1
23:46:52 <Cin> twey: yay
23:46:52 <lbotnew>  setResourceLimit: invalid argument (Invalid argument)
23:46:53 <lambdabot>  2
23:46:57 <Cale> ouch :)
23:47:12 * shachaf is running irssi in screen in FreeBSD in ssh in urxvt in Ubuntu.
23:47:12 <Cale> Looks like the same problem someone was having the other day :)
23:47:16 <Twey> Hmm
23:47:22 <Twey> shachaf: And do you see it?
23:47:31 <wagle_home> yeah, i input it right justified, but it displays left justfied after i send it
23:47:37 <shachaf> Twey: I see something -- I don't know if it's the right character.
23:47:50 <Cale> Who was that?...
23:47:54 <Twey> shachaf: It should be a small curve with two dots over it.
23:47:54 <sarehu> Cale: you're having the same problem I had
23:47:54 <Cin> shachaf: it's like a big grin
23:48:08 <Cale> sarehu: right, that was you :)
23:48:13 * shachaf only sees one dot.
23:48:16 <Cale> sarehu: How'd you fix that?
23:48:19 <shachaf> But it might be my font.
23:48:20 <sarehu> wrote my own
23:48:25 <Cale> Can I have it?
23:48:29 <sarehu> yeah, one sec
23:48:38 <wagle_home> i didint see Twey's char..  which line was it on?
23:48:55 * shachaf doesn't remember any Arabic at all.
23:49:07 <Twey> wagle_home: Wasn't mine
23:49:11 <dolio> http://img183.imageshack.us/my.php?image=snap13yi6.png
23:49:13 <shachaf> שחף
23:49:13 <Twey> < wagle_home> ت
23:49:21 <Twey> Hebrew?
23:49:32 <shachaf> Twey: Yes.
23:49:34 <wagle_home> looks like my arabic char
23:49:37 * Twey nods.
23:49:44 <shachaf> Twey: Didn't seem to go through very well. :-)
23:49:45 <Twey> そして日本語
23:49:57 <dmwit> Ah, unicode.
23:50:00 <Twey> shachaf: I don't speak Hebrew, so I can't tell :-(
23:50:04 <Twey> dmwit: Innit great?
23:50:17 <wagle_home> is that go?  i cant see it, all mushed together
23:50:31 <Twey> wagle_home: The last one was
23:50:39 <Twey> "All mushed together?"
23:50:54 <wagle_home> one big solid blob of dots
23:50:58 <Cin> looks *hot* on my terminal
23:51:00 <Cale> soshite nihongo
23:51:20 <wagle_home> yeah, i can sorta make out the go now
23:51:26 <hpaste>  sarehu pasted "setCPULimit" at http://hpaste.org/5551
23:51:32 <Cale> sarehu: thanks
23:51:44 <sarehu> noprob
23:52:04 <Twey> wagle_home, you need better fonts :-P
23:52:42 <wagle_home> the macosx inputer figures out which kanji you want from the hiragana (i think..  its been several months/years since i saw that)
23:52:55 <Cin> twey: http://rtfs.ath.cx/yummy.png
23:53:05 <Cin> looks hot
23:53:43 <wagle_home> Twey, i have two different orientations of astigmatism in my eyes.. my vision is 20/20, but everything small is distorted (not blurry)
23:53:59 * sarehu wonders why japanese is working but not lambdas :(
23:54:24 <wagle_home> japanese is supported, but not greek?
23:54:27 <Cin> sarehu: no worky? λ?
23:54:27 <Twey> Cin: Heh
23:54:31 <sarehu> It's a box
23:54:38 <Cin> ah, must be the font
23:54:38 <sarehu> λ
23:54:41 * Cale builds
23:54:42 <sarehu> yeap
23:54:42 <Twey> Yeah
23:54:45 <siti> yep it'll be the font
23:54:49 <Twey> You need more fonts
23:54:59 <Cin> More Fonts(tm)
23:55:09 <sarehu> it works on other fonts, but this one i'm using right now is nice enough that not having lambda is worth it..
23:55:17 <Cin> monaco?
23:55:22 <wagle_home> plus i'm on a 10 year old crt, instead of a nice tft lcd screen thatr my eyes like much more
23:55:29 <sarehu> it's just lucida typewriter, not anti-aliased :)
23:55:37 <Cin> i installed monaco on windows and thought it lovely but it didn't support lambda ;_;
23:56:07 <sarehu> I'm kind of sitting in the middle of the Linux Emacs font disaster that I usually end up in...
23:56:13 <shachaf> ←↓↑→
23:56:16 <Twey> sarehu, Qt3?
23:56:17 <Cin> it would be cool if it could fall back to other fonts for characters it didn't support
23:56:21 <Cin> a square is just horrid
23:56:32 <sarehu> Qt3 what?
23:56:36 <Twey> Qt4 and GTK can, Cin
23:56:40 <wagle> ewww yuck..  looks worse in X11 fonts on my macosx notebook
23:56:46 <shachaf> This has been happening since I moved my irssi session to a new jail.
23:56:49 <Twey> (that's why I'm in GNOME right now)
23:56:58 <Cin> twey: awesome
23:57:11 <Twey> Need to upgrade to KDE4 so I can switch back :_P
23:57:12 <Twey> :-P**
23:57:27 <Cin> i'm using gnome-settings-daemon with xmonad >_>
23:57:39 <Cin> nice fonts + menus - crappy window manager
23:57:42 <wagle> the upper left quadrant of the go char really did get smooshed together..  whats antialiasing?
23:58:01 <Cin> wagle: antialiasing is smoothing
23:58:06 <siti> I wish there was haskell desktop environment ;)
23:58:14 <Cin> wagle: to emulate infinite precision, like looking at paper, but on a screen
23:58:25 <wagle> Cin: tell that to the X11 on my iBook
23:58:56 <Twey> siti, xmonad?
23:59:14 <siti> something more... user friendly :p
23:59:15 <Cin> i'm happy as long as reading text isn't like looking at lego shaped like words
23:59:30 <wagle> i once explained anti-aliasing to a secretary at the car insurance place, and she was amazed that I could actually explain it to her in terms she could understand
23:59:37 * Cin attempts to fix spacebar
23:59:55 <siti> wagle: wow what a conversation :p
